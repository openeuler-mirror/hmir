(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[77],{

/***/ "./node_modules/prettier/parser-babel.js":
/*!***********************************************!*\
  !*** ./node_modules/prettier/parser-babel.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n!function (t, e) {\n   true ? e(exports) : undefined;\n}(void 0, function (t) {\n  \"use strict\";\n\n  var e = function (t, e) {\n    const s = new SyntaxError(t + \" (\" + e.start.line + \":\" + e.start.column + \")\");\n    return s.loc = e, s;\n  };\n\n  function s(t) {\n    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n  }\n\n  function i(t, e) {\n    return t(e = {\n      exports: {}\n    }, e.exports), e.exports;\n  }\n\n  var r = Object.freeze({\n    __proto__: null,\n    default: {\n      EOL: \"\\n\"\n    }\n  });\n\n  const a = t => {\n    if (\"string\" != typeof t) throw new TypeError(\"Expected a string\");\n    const e = t.match(/(?:\\r?\\n)/g) || [];\n    if (0 === e.length) return;\n    const s = e.filter(t => \"\\r\\n\" === t).length;\n    return s > e.length - s ? \"\\r\\n\" : \"\\n\";\n  };\n\n  var n = a;\n\n  n.graceful = t => \"string\" == typeof t && a(t) || \"\\n\";\n\n  var o,\n      h = (o = r) && o.default || o,\n      p = i(function (t, e) {\n    function s() {\n      const t = h;\n      return s = function () {\n        return t;\n      }, t;\n    }\n\n    function i() {\n      const t = (e = n) && e.__esModule ? e : {\n        default: e\n      };\n      var e;\n      return i = function () {\n        return t;\n      }, t;\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.extract = function (t) {\n      const e = t.match(o);\n      return e ? e[0].trimLeft() : \"\";\n    }, e.strip = function (t) {\n      const e = t.match(o);\n      return e && e[0] ? t.substring(e[0].length) : t;\n    }, e.parse = function (t) {\n      return m(t).pragmas;\n    }, e.parseWithComments = m, e.print = function (_ref) {\n      let {\n        comments: t = \"\",\n        pragmas: e = {}\n      } = _ref;\n      const r = (0, i().default)(t) || s().EOL,\n            a = Object.keys(e),\n            n = a.map(t => f(t, e[t])).reduce((t, e) => t.concat(e), []).map(t => \" * \" + t + r).join(\"\");\n\n      if (!t) {\n        if (0 === a.length) return \"\";\n\n        if (1 === a.length && !Array.isArray(e[a[0]])) {\n          const t = e[a[0]];\n          return \"\".concat(\"/**\", \" \").concat(f(a[0], t)[0]).concat(\" */\");\n        }\n      }\n\n      const o = t.split(r).map(t => \"\".concat(\" *\", \" \").concat(t)).join(r) + r;\n      return \"/**\" + r + (t ? o : \"\") + (t && a.length ? \" *\" + r : \"\") + n + \" */\";\n    };\n    const r = /\\*\\/$/,\n          a = /^\\/\\*\\*/,\n          o = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/,\n          p = /(^|\\s+)\\/\\/([^\\r\\n]*)/g,\n          c = /^(\\r?\\n)+/,\n          u = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g,\n          l = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g,\n          d = /(\\r?\\n|^) *\\* ?/g;\n\n    function m(t) {\n      const e = (0, i().default)(t) || s().EOL;\n      t = t.replace(a, \"\").replace(r, \"\").replace(d, \"$1\");\n      let n = \"\";\n\n      for (; n !== t;) n = t, t = t.replace(u, \"\".concat(e, \"$1 $2\").concat(e));\n\n      t = t.replace(c, \"\").trimRight();\n      const o = Object.create(null),\n            h = t.replace(l, \"\").replace(c, \"\").trimRight();\n      let m;\n\n      for (; m = l.exec(t);) {\n        const t = m[2].replace(p, \"\");\n        \"string\" == typeof o[m[1]] || Array.isArray(o[m[1]]) ? o[m[1]] = [].concat(o[m[1]], t) : o[m[1]] = t;\n      }\n\n      return {\n        comments: h,\n        pragmas: o\n      };\n    }\n\n    function f(t, e) {\n      return [].concat(e).map(e => \"@\".concat(t, \" \").concat(e).trim());\n    }\n  });\n  s(p);\n  p.extract, p.strip, p.parse, p.parseWithComments, p.print;\n\n  var c = {\n    hasPragma: function (t) {\n      const e = Object.keys(p.parse(p.extract(t)));\n      return e.includes(\"prettier\") || e.includes(\"format\");\n    },\n    insertPragma: function (t) {\n      const e = p.parseWithComments(p.extract(t)),\n            s = Object.assign({\n        format: \"\"\n      }, e.pragmas),\n            i = p.print({\n        pragmas: s,\n        comments: e.comments.replace(/^(\\s+?\\r?\\n)+/, \"\")\n      }).replace(/(\\r\\n|\\r)/g, \"\\n\"),\n            r = p.strip(t);\n      return i + (r.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\") + r;\n    }\n  },\n      u = t => t[t.length - 1];\n\n  function l(t, e) {\n    return !(e = e || {}).ignoreDecorators && t.declaration && t.declaration.decorators && t.declaration.decorators.length > 0 ? l(t.declaration.decorators[0]) : !e.ignoreDecorators && t.decorators && t.decorators.length > 0 ? l(t.decorators[0]) : t.__location ? t.__location.startOffset : t.range ? t.range[0] : \"number\" == typeof t.start ? t.start : t.loc ? t.loc.start : null;\n  }\n\n  function d(t) {\n    const e = t.nodes && u(t.nodes);\n    if (e && t.source && !t.source.end && (t = e), t.__location) return t.__location.endOffset;\n    const s = t.range ? t.range[1] : \"number\" == typeof t.end ? t.end : null;\n    return t.typeAnnotation ? Math.max(s, d(t.typeAnnotation)) : t.loc && !s ? t.loc.end : s;\n  }\n\n  var m = {\n    locStart: l,\n    locEnd: d,\n    composeLoc: function (t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : t;\n      const s = \"number\" == typeof e ? e : -1,\n            i = l(t),\n            r = -1 !== s ? i + s : d(e),\n            a = t.loc.start;\n      return {\n        start: i,\n        end: r,\n        range: [i, r],\n        loc: {\n          start: a,\n          end: -1 !== s ? {\n            line: a.line,\n            column: a.column + s\n          } : e.loc.end\n        }\n      };\n    }\n  },\n      f = t => \"string\" == typeof t ? t.replace(function () {\n    let {\n      onlyFirst: t = !1\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const e = [\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"].join(\"|\");\n    return new RegExp(e, t ? void 0 : \"g\");\n  }(), \"\") : t;\n\n  const D = t => !Number.isNaN(t) && t >= 4352 && (t <= 4447 || 9001 === t || 9002 === t || 11904 <= t && t <= 12871 && 12351 !== t || 12880 <= t && t <= 19903 || 19968 <= t && t <= 42182 || 43360 <= t && t <= 43388 || 44032 <= t && t <= 55203 || 63744 <= t && t <= 64255 || 65040 <= t && t <= 65049 || 65072 <= t && t <= 65131 || 65281 <= t && t <= 65376 || 65504 <= t && t <= 65510 || 110592 <= t && t <= 110593 || 127488 <= t && t <= 127569 || 131072 <= t && t <= 262141);\n\n  var y = D,\n      x = D;\n  y.default = x;\n\n  const g = t => {\n    if (\"string\" != typeof (t = t.replace(/\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C\\uDFFB|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83D[\\uDC66\\uDC67]|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)\\uD83C\\uDFFB|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83D\\uDC69(?:\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83C\\uDFF4\\u200D\\u2620)\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDF6\\uD83C\\uDDE6|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDBB\\uDDD2-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g, \"  \")) || 0 === t.length) return 0;\n    t = f(t);\n    let e = 0;\n\n    for (let s = 0; s < t.length; s++) {\n      const i = t.codePointAt(s);\n      i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879 || (i > 65535 && s++, e += y(i) ? 2 : 1);\n    }\n\n    return e;\n  };\n\n  var P = g,\n      E = g;\n  P.default = E;\n  const C = /[|\\\\{}()[\\]^$+*?.-]/g;\n\n  var b = t => {\n    if (\"string\" != typeof t) throw new TypeError(\"Expected a string\");\n    return t.replace(C, \"\\\\$&\");\n  };\n\n  const T = /[^\\x20-\\x7F]/;\n\n  function A(t) {\n    return (e, s, i) => {\n      const r = i && i.backwards;\n      if (!1 === s) return !1;\n      const {\n        length: a\n      } = e;\n      let n = s;\n\n      for (; n >= 0 && n < a;) {\n        const s = e.charAt(n);\n\n        if (t instanceof RegExp) {\n          if (!t.test(s)) return n;\n        } else if (!t.includes(s)) return n;\n\n        r ? n-- : n++;\n      }\n\n      return (-1 === n || n === a) && n;\n    };\n  }\n\n  const w = A(/\\s/),\n        S = A(\" \\t\"),\n        N = A(\",; \\t\"),\n        F = A(/[^\\r\\n]/);\n\n  function k(t, e) {\n    if (!1 === e) return !1;\n    if (\"/\" === t.charAt(e) && \"*\" === t.charAt(e + 1)) for (let s = e + 2; s < t.length; ++s) if (\"*\" === t.charAt(s) && \"/\" === t.charAt(s + 1)) return s + 2;\n    return e;\n  }\n\n  function I(t, e) {\n    return !1 !== e && (\"/\" === t.charAt(e) && \"/\" === t.charAt(e + 1) ? F(t, e) : e);\n  }\n\n  function v(t, e, s) {\n    const i = s && s.backwards;\n    if (!1 === e) return !1;\n    const r = t.charAt(e);\n\n    if (i) {\n      if (\"\\r\" === t.charAt(e - 1) && \"\\n\" === r) return e - 2;\n      if (\"\\n\" === r || \"\\r\" === r || \"\\u2028\" === r || \"\\u2029\" === r) return e - 1;\n    } else {\n      if (\"\\r\" === r && \"\\n\" === t.charAt(e + 1)) return e + 2;\n      if (\"\\n\" === r || \"\\r\" === r || \"\\u2028\" === r || \"\\u2029\" === r) return e + 1;\n    }\n\n    return e;\n  }\n\n  function L(t, e, s) {\n    const i = S(t, (s = s || {}).backwards ? e - 1 : e, s);\n    return i !== v(t, i, s);\n  }\n\n  function B(t, e) {\n    let s = null,\n        i = e;\n\n    for (; i !== s;) s = i, i = N(t, i), i = k(t, i), i = S(t, i);\n\n    return i = I(t, i), i = v(t, i), !1 !== i && L(t, i);\n  }\n\n  function M(t, e) {\n    let s = null,\n        i = e;\n\n    for (; i !== s;) s = i, i = S(t, i), i = k(t, i), i = I(t, i), i = v(t, i);\n\n    return i;\n  }\n\n  function O(t, e, s) {\n    return M(t, s(e));\n  }\n\n  const R = {};\n\n  function _(t) {\n    return R[t];\n  }\n\n  [[\"|>\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]].forEach((t, e) => {\n    t.forEach(t => {\n      R[t] = e;\n    });\n  });\n  const j = {\n    \"==\": !0,\n    \"!=\": !0,\n    \"===\": !0,\n    \"!==\": !0\n  },\n        U = {\n    \"*\": !0,\n    \"/\": !0,\n    \"%\": !0\n  },\n        q = {\n    \">>\": !0,\n    \">>>\": !0,\n    \"<<\": !0\n  };\n\n  function V(t, e, s) {\n    let i = 0;\n\n    for (let r = s = s || 0; r < t.length; ++r) \"\\t\" === t[r] ? i = i + e - i % e : i++;\n\n    return i;\n  }\n\n  function z(t, e) {\n    const s = t.slice(1, -1),\n          i = {\n      quote: '\"',\n      regex: /\"/g\n    },\n          r = {\n      quote: \"'\",\n      regex: /'/g\n    },\n          a = \"'\" === e ? r : i,\n          n = a === r ? i : r;\n    let o = a.quote;\n\n    if (s.includes(a.quote) || s.includes(n.quote)) {\n      o = (s.match(a.regex) || []).length > (s.match(n.regex) || []).length ? n.quote : a.quote;\n    }\n\n    return o;\n  }\n\n  function H(t, e, s) {\n    const i = '\"' === e ? \"'\" : '\"',\n          r = t.replace(/\\\\([\\s\\S])|(['\"])/g, (t, r, a) => r === i ? r : a === e ? \"\\\\\" + a : a || (s && /^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(r) ? r : \"\\\\\" + r));\n    return e + r + e;\n  }\n\n  function W(t) {\n    return t && (t.comments && t.comments.length > 0 && t.comments.some(t => K(t) && !t.unignore) || t.prettierIgnore);\n  }\n\n  function K(t) {\n    return \"prettier-ignore\" === t.value.trim();\n  }\n\n  function J(t, e) {\n    (t.comments || (t.comments = [])).push(e), e.printed = !1, \"JSXText\" === t.type && (e.printed = !0);\n  }\n\n  var X = {\n    replaceEndOfLineWith: function (t, e) {\n      const s = [];\n\n      for (const i of t.split(\"\\n\")) 0 !== s.length && s.push(e), s.push(i);\n\n      return s;\n    },\n    getStringWidth: function (t) {\n      return t ? T.test(t) ? P(t) : t.length : 0;\n    },\n    getMaxContinuousCount: function (t, e) {\n      const s = t.match(new RegExp(\"(\".concat(b(e), \")+\"), \"g\"));\n      return null === s ? 0 : s.reduce((t, s) => Math.max(t, s.length / e.length), 0);\n    },\n    getMinNotPresentContinuousCount: function (t, e) {\n      const s = t.match(new RegExp(\"(\".concat(b(e), \")+\"), \"g\"));\n      if (null === s) return 0;\n      const i = new Map();\n      let r = 0;\n\n      for (const t of s) {\n        const s = t.length / e.length;\n        i.set(s, !0), s > r && (r = s);\n      }\n\n      for (let t = 1; t < r; t++) if (!i.get(t)) return t;\n\n      return r + 1;\n    },\n    getPrecedence: _,\n    shouldFlatten: function (t, e) {\n      return _(e) === _(t) && \"**\" !== t && (!j[t] || !j[e]) && !(\"%\" === e && U[t] || \"%\" === t && U[e]) && (e === t || !U[e] || !U[t]) && (!q[t] || !q[e]);\n    },\n    isBitwiseOperator: function (t) {\n      return !!q[t] || \"|\" === t || \"^\" === t || \"&\" === t;\n    },\n    getPenultimate: function (t) {\n      return t.length > 1 ? t[t.length - 2] : null;\n    },\n    getLast: u,\n    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: M,\n    getNextNonSpaceNonCommentCharacterIndex: O,\n    getNextNonSpaceNonCommentCharacter: function (t, e, s) {\n      return t.charAt(O(t, e, s));\n    },\n    skip: A,\n    skipWhitespace: w,\n    skipSpaces: S,\n    skipToLineEnd: N,\n    skipEverythingButNewLine: F,\n    skipInlineComment: k,\n    skipTrailingComment: I,\n    skipNewline: v,\n    isNextLineEmptyAfterIndex: B,\n    isNextLineEmpty: function (t, e, s) {\n      return B(t, s(e));\n    },\n    isPreviousLineEmpty: function (t, e, s) {\n      let i = s(e) - 1;\n      return i = S(t, i, {\n        backwards: !0\n      }), i = v(t, i, {\n        backwards: !0\n      }), i = S(t, i, {\n        backwards: !0\n      }), i !== v(t, i, {\n        backwards: !0\n      });\n    },\n    hasNewline: L,\n    hasNewlineInRange: function (t, e, s) {\n      for (let i = e; i < s; ++i) if (\"\\n\" === t.charAt(i)) return !0;\n\n      return !1;\n    },\n    hasSpaces: function (t, e, s) {\n      return S(t, (s = s || {}).backwards ? e - 1 : e, s) !== e;\n    },\n    setLocStart: function (t, e) {\n      t.range ? t.range[0] = e : t.start = e;\n    },\n    setLocEnd: function (t, e) {\n      t.range ? t.range[1] = e : t.end = e;\n    },\n    startsWithNoLookaheadToken: function t(e, s) {\n      switch ((e = function t(e) {\n        if (e.left) return t(e.left);\n        return e;\n      }(e)).type) {\n        case \"FunctionExpression\":\n        case \"ClassExpression\":\n        case \"DoExpression\":\n          return s;\n\n        case \"ObjectExpression\":\n          return !0;\n\n        case \"MemberExpression\":\n        case \"OptionalMemberExpression\":\n          return t(e.object, s);\n\n        case \"TaggedTemplateExpression\":\n          return \"FunctionExpression\" !== e.tag.type && t(e.tag, s);\n\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n          return \"FunctionExpression\" !== e.callee.type && t(e.callee, s);\n\n        case \"ConditionalExpression\":\n          return t(e.test, s);\n\n        case \"UpdateExpression\":\n          return !e.prefix && t(e.argument, s);\n\n        case \"BindExpression\":\n          return e.object && t(e.object, s);\n\n        case \"SequenceExpression\":\n          return t(e.expressions[0], s);\n\n        case \"TSAsExpression\":\n          return t(e.expression, s);\n\n        default:\n          return !1;\n      }\n    },\n    getAlignmentSize: V,\n    getIndentSize: function (t, e) {\n      const s = t.lastIndexOf(\"\\n\");\n      return -1 === s ? 0 : V(t.slice(s + 1).match(/^[ \\t]*/)[0], e);\n    },\n    getPreferredQuote: z,\n    printString: function (t, e, s) {\n      const i = t.slice(1, -1),\n            r = !i.includes('\"') && !i.includes(\"'\"),\n            a = \"json\" === e.parser ? '\"' : e.__isInHtmlAttribute ? \"'\" : z(t, e.singleQuote ? \"'\" : '\"');\n      return s ? r ? a + i + a : t : H(i, a, !(\"css\" === e.parser || \"less\" === e.parser || \"scss\" === e.parser || e.embeddedInHtml));\n    },\n    printNumber: function (t) {\n      return t.toLowerCase().replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\").replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\").replace(/^([+-])?\\./, \"$10.\").replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\").replace(/\\.(?=e|$)/, \"\");\n    },\n    hasIgnoreComment: function (t) {\n      return W(t.getValue());\n    },\n    hasNodeIgnoreComment: W,\n    isNodeIgnoreComment: K,\n    makeString: H,\n    addLeadingComment: function (t, e) {\n      e.leading = !0, e.trailing = !1, J(t, e);\n    },\n    addDanglingComment: function (t, e) {\n      e.leading = !1, e.trailing = !1, J(t, e);\n    },\n    addTrailingComment: function (t, e) {\n      e.leading = !1, e.trailing = !0, J(t, e);\n    },\n    isWithinParentArrayProperty: function (t, e) {\n      const s = t.getValue(),\n            i = t.getParentNode();\n      if (null == i) return !1;\n      if (!Array.isArray(i[e])) return !1;\n      const r = t.getName();\n      return i[e][r] === s;\n    }\n  };\n  const {\n    getMaxContinuousCount: G,\n    getStringWidth: Q,\n    getAlignmentSize: Y,\n    getIndentSize: $,\n    skip: Z,\n    skipWhitespace: tt,\n    skipSpaces: et,\n    skipNewline: st,\n    skipToLineEnd: it,\n    skipEverythingButNewLine: rt,\n    skipInlineComment: at,\n    skipTrailingComment: nt,\n    hasNewline: ot,\n    hasNewlineInRange: ht,\n    hasSpaces: pt,\n    isNextLineEmpty: ct,\n    isNextLineEmptyAfterIndex: ut,\n    isPreviousLineEmpty: lt,\n    getNextNonSpaceNonCommentCharacterIndex: dt,\n    makeString: mt,\n    addLeadingComment: ft,\n    addDanglingComment: Dt,\n    addTrailingComment: yt\n  } = X;\n  var xt = {\n    getMaxContinuousCount: G,\n    getStringWidth: Q,\n    getAlignmentSize: Y,\n    getIndentSize: $,\n    skip: Z,\n    skipWhitespace: tt,\n    skipSpaces: et,\n    skipNewline: st,\n    skipToLineEnd: it,\n    skipEverythingButNewLine: rt,\n    skipInlineComment: at,\n    skipTrailingComment: nt,\n    hasNewline: ot,\n    hasNewlineInRange: ht,\n    hasSpaces: pt,\n    isNextLineEmpty: ct,\n    isNextLineEmptyAfterIndex: ut,\n    isPreviousLineEmpty: lt,\n    getNextNonSpaceNonCommentCharacterIndex: dt,\n    makeString: mt,\n    addLeadingComment: ft,\n    addDanglingComment: Dt,\n    addTrailingComment: yt\n  };\n  const {\n    addLeadingComment: gt,\n    addTrailingComment: Pt,\n    addDanglingComment: Et,\n    getNextNonSpaceNonCommentCharacterIndex: Ct\n  } = xt;\n\n  function bt(t, e) {\n    const s = t.body.filter(t => \"EmptyStatement\" !== t.type);\n    0 === s.length ? Et(t, e) : gt(s[0], e);\n  }\n\n  function Tt(t, e) {\n    \"BlockStatement\" === t.type ? bt(t, e) : gt(t, e);\n  }\n\n  function At(t, e, s, i, r, a) {\n    if (!s || \"IfStatement\" !== s.type || !i) return !1;\n    return \")\" === X.getNextNonSpaceNonCommentCharacter(t, r, a.locEnd) ? (Pt(e, r), !0) : e === s.consequent && i === s.alternate ? (\"BlockStatement\" === e.type ? Pt(e, r) : Et(s, r), !0) : \"BlockStatement\" === i.type ? (bt(i, r), !0) : \"IfStatement\" === i.type ? (Tt(i.consequent, r), !0) : s.consequent === i && (gt(i, r), !0);\n  }\n\n  function wt(t, e, s, i, r, a) {\n    if (!s || \"WhileStatement\" !== s.type || !i) return !1;\n    return \")\" === X.getNextNonSpaceNonCommentCharacter(t, r, a.locEnd) ? (Pt(e, r), !0) : \"BlockStatement\" === i.type && (bt(i, r), !0);\n  }\n\n  function St(t, e, s, i) {\n    return !(!t || \"TryStatement\" !== t.type && \"CatchClause\" !== t.type || !s) && (\"CatchClause\" === t.type && e ? (Pt(e, i), !0) : \"BlockStatement\" === s.type ? (bt(s, i), !0) : \"TryStatement\" === s.type ? (Tt(s.finalizer, i), !0) : \"CatchClause\" === s.type && (Tt(s.body, i), !0));\n  }\n\n  function Nt(t, e, s, i) {\n    return !(!(t && (\"ClassDeclaration\" === t.type || \"ClassExpression\" === t.type) && t.decorators && t.decorators.length > 0) || s && \"Decorator\" === s.type) && (t.decorators && 0 !== t.decorators.length ? Pt(t.decorators[t.decorators.length - 1], i) : gt(t, i), !0);\n  }\n\n  function Ft(t, e, s, i, r) {\n    return e && s && (\"Property\" === e.type || \"TSDeclareMethod\" === e.type || \"TSAbstractMethodDefinition\" === e.type) && \"Identifier\" === s.type && e.key === s && \":\" !== X.getNextNonSpaceNonCommentCharacter(t, s, r.locEnd) ? (Pt(s, i), !0) : !(!s || !e || \"Decorator\" !== s.type || \"ClassMethod\" !== e.type && \"ClassProperty\" !== e.type && \"TSAbstractClassProperty\" !== e.type && \"TSAbstractMethodDefinition\" !== e.type && \"TSDeclareMethod\" !== e.type && \"MethodDefinition\" !== e.type) && (Pt(s, i), !0);\n  }\n\n  function kt(t, e, s, i, r, a) {\n    if (e && \"FunctionTypeParam\" === e.type && s && \"FunctionTypeAnnotation\" === s.type && i && \"FunctionTypeParam\" !== i.type) return Pt(e, r), !0;\n    if (e && (\"Identifier\" === e.type || \"AssignmentPattern\" === e.type) && s && Mt(s) && \")\" === X.getNextNonSpaceNonCommentCharacter(t, r, a.locEnd)) return Pt(e, r), !0;\n\n    if (s && \"FunctionDeclaration\" === s.type && i && \"BlockStatement\" === i.type) {\n      const e = (() => {\n        if (0 !== (s.params || s.parameters).length) return X.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(t, a.locEnd(X.getLast(s.params || s.parameters)));\n        const e = X.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(t, a.locEnd(s.id));\n        return X.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(t, e + 1);\n      })();\n\n      if (a.locStart(r) > e) return bt(i, r), !0;\n    }\n\n    return !1;\n  }\n\n  function It(t, e) {\n    return !(!t || \"ImportSpecifier\" !== t.type) && (gt(t, e), !0);\n  }\n\n  function vt(t, e) {\n    return !(!t || \"LabeledStatement\" !== t.type) && (gt(t, e), !0);\n  }\n\n  function Lt(t, e, s, i) {\n    return e && e.body && 0 === e.body.length ? (i ? Et(e, s) : gt(e, s), !0) : !(!t || \"Program\" !== t.type || 0 !== t.body.length || !t.directives || 0 !== t.directives.length) && (i ? Et(t, s) : gt(t, s), !0);\n  }\n\n  function Bt(t) {\n    return \"Block\" === t.type || \"CommentBlock\" === t.type;\n  }\n\n  function Mt(t) {\n    return \"ArrowFunctionExpression\" === t.type || \"FunctionExpression\" === t.type || \"FunctionDeclaration\" === t.type || \"ObjectMethod\" === t.type || \"ClassMethod\" === t.type || \"TSDeclareFunction\" === t.type || \"TSCallSignatureDeclaration\" === t.type || \"TSConstructSignatureDeclaration\" === t.type || \"TSConstructSignatureDeclaration\" === t.type || \"TSMethodSignature\" === t.type || \"TSConstructorType\" === t.type || \"TSFunctionType\" === t.type || \"TSDeclareMethod\" === t.type;\n  }\n\n  function Ot(t) {\n    return Bt(t) && \"*\" === t.value[0] && /@type\\b/.test(t.value);\n  }\n\n  var Rt = {\n    handleOwnLineComment: function (t, e, s, i, r) {\n      const {\n        precedingNode: a,\n        enclosingNode: n,\n        followingNode: o\n      } = t;\n      return kt(e, a, n, o, t, s) || function (t, e, s) {\n        if (t && (\"MemberExpression\" === t.type || \"OptionalMemberExpression\" === t.type) && e && \"Identifier\" === e.type) return gt(t, s), !0;\n        return !1;\n      }(n, o, t) || At(e, a, n, o, t, s) || wt(e, a, n, o, t, s) || St(n, a, o, t) || Nt(n, a, o, t) || It(n, t) || function (t, e, s) {\n        if (t && (\"ForInStatement\" === t.type || \"ForOfStatement\" === t.type)) return gt(t, s), !0;\n        return !1;\n      }(n, 0, t) || function (t, e, s, i) {\n        if (e && (\"UnionTypeAnnotation\" === e.type || \"TSUnionType\" === e.type)) return X.isNodeIgnoreComment(i) && (s.prettierIgnore = !0, i.unignore = !0), !!t && (Pt(t, i), !0);\n        s && (\"UnionTypeAnnotation\" === s.type || \"TSUnionType\" === s.type) && X.isNodeIgnoreComment(i) && (s.types[0].prettierIgnore = !0, i.unignore = !0);\n        return !1;\n      }(a, n, o, t) || Lt(n, i, t, r) || function (t, e, s, i, r) {\n        if (s && \"ImportSpecifier\" === s.type && e && \"ImportDeclaration\" === e.type && X.hasNewline(t, r.locEnd(i))) return Pt(s, i), !0;\n        return !1;\n      }(e, n, a, t, s) || function (t, e) {\n        if (t && \"AssignmentPattern\" === t.type) return gt(t, e), !0;\n        return !1;\n      }(n, t) || Ft(e, n, a, t, s) || vt(n, t);\n    },\n    handleEndOfLineComment: function (t, e, s, i, r) {\n      const {\n        precedingNode: a,\n        enclosingNode: n,\n        followingNode: o\n      } = t;\n      return function (t, e) {\n        if (t && Ot(e)) return gt(t, e), !0;\n        return !1;\n      }(o, t) || kt(e, a, n, o, t, s) || function (t, e, s, i, r, a) {\n        const n = e && !X.hasNewlineInRange(r, a.locEnd(e), a.locStart(i));\n        if ((!e || !n) && t && \"ConditionalExpression\" === t.type && s) return gt(s, i), !0;\n        return !1;\n      }(n, a, o, t, e, s) || It(n, t) || At(e, a, n, o, t, s) || wt(e, a, n, o, t, s) || St(n, a, o, t) || Nt(n, a, o, t) || vt(n, t) || function (t, e, s) {\n        if (e && (\"CallExpression\" === e.type || \"OptionalCallExpression\" === e.type) && t && e.callee === t && e.arguments.length > 0) return gt(e.arguments[0], s), !0;\n        return !1;\n      }(a, n, t) || function (t, e) {\n        if (t && (\"Property\" === t.type || \"ObjectProperty\" === t.type)) return gt(t, e), !0;\n        return !1;\n      }(n, t) || Lt(n, i, t, r) || function (t, e, s) {\n        if (t && \"TypeAlias\" === t.type) return gt(t, s), !0;\n        return !1;\n      }(n, 0, t) || function (t, e, s) {\n        if (t && (\"VariableDeclarator\" === t.type || \"AssignmentExpression\" === t.type) && e && (\"ObjectExpression\" === e.type || \"ArrayExpression\" === e.type || \"TemplateLiteral\" === e.type || \"TaggedTemplateExpression\" === e.type || Bt(s))) return gt(e, s), !0;\n        return !1;\n      }(n, o, t);\n    },\n    handleRemainingComment: function (t, e, s, i, r) {\n      const {\n        precedingNode: a,\n        enclosingNode: n,\n        followingNode: o\n      } = t;\n      return !!(At(e, a, n, o, t, s) || wt(e, a, n, o, t, s) || function (t, e, s) {\n        if (t && (\"ObjectProperty\" === t.type || \"Property\" === t.type) && t.shorthand && t.key === e && \"AssignmentPattern\" === t.value.type) return Pt(t.value.left, s), !0;\n        return !1;\n      }(n, a, t) || function (t, e, s, i) {\n        if (\")\" !== X.getNextNonSpaceNonCommentCharacter(t, s, i.locEnd)) return !1;\n        if (e && (Mt(e) && 0 === (e.params || e.parameters).length || (\"CallExpression\" === e.type || \"OptionalCallExpression\" === e.type || \"NewExpression\" === e.type) && 0 === e.arguments.length)) return Et(e, s), !0;\n        if (e && \"MethodDefinition\" === e.type && 0 === e.value.params.length) return Et(e.value, s), !0;\n        return !1;\n      }(e, n, t, s) || Ft(e, n, a, t, s) || Lt(n, i, t, r) || function (t, e, s, i) {\n        if (!e || \"ArrowFunctionExpression\" !== e.type) return !1;\n        const r = Ct(t, s, i.locEnd);\n        if (\"=>\" === t.slice(r, r + 2)) return Et(e, s), !0;\n        return !1;\n      }(e, n, t, s) || function (t, e, s, i, r) {\n        if (\"(\" !== X.getNextNonSpaceNonCommentCharacter(t, i, r.locEnd)) return !1;\n        if (s && e && (\"FunctionDeclaration\" === e.type || \"FunctionExpression\" === e.type || \"ClassMethod\" === e.type || \"MethodDefinition\" === e.type || \"ObjectMethod\" === e.type)) return Pt(s, i), !0;\n        return !1;\n      }(e, n, a, t, s) || function (t, e, s, i, r) {\n        if (!e || \"TSMappedType\" !== e.type) return !1;\n        if (i && \"TSTypeParameter\" === i.type && i.name) return gt(i.name, r), !0;\n        if (s && \"TSTypeParameter\" === s.type && s.constraint) return Pt(s.constraint, r), !0;\n        return !1;\n      }(0, n, a, o, t) || function (t, e) {\n        if (t && (\"ContinueStatement\" === t.type || \"BreakStatement\" === t.type) && !t.label) return Pt(t, e), !0;\n        return !1;\n      }(n, t) || function (t, e, s, i, r) {\n        if (!s && e && (\"TSMethodSignature\" === e.type || \"TSDeclareFunction\" === e.type || \"TSAbstractMethodDefinition\" === e.type) && \";\" === X.getNextNonSpaceNonCommentCharacter(t, i, r.locEnd)) return Pt(e, i), !0;\n        return !1;\n      }(e, n, o, t, s));\n    },\n    hasLeadingComment: function (t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => !0;\n      return t.leadingComments ? t.leadingComments.some(e) : !!t.comments && t.comments.some(t => t.leading && e(t));\n    },\n    isBlockComment: Bt,\n    isTypeCastComment: Ot,\n    getGapRegex: function (t) {\n      if (t && \"BinaryExpression\" !== t.type && \"LogicalExpression\" !== t.type) return /^[\\s(&|]*$/;\n    },\n    getCommentChildNodes: function (t, e) {\n      if ((\"typescript\" === e.parser || \"flow\" === e.parser) && \"MethodDefinition\" === t.type && t.value && \"FunctionExpression\" === t.value.type && 0 === t.value.params.length && !t.value.returnType && (!t.value.typeParameters || 0 === t.value.typeParameters.length) && t.value.body) return [...(t.decorators || []), t.key, t.value.body];\n    }\n  };\n  const {\n    getLast: _t,\n    getNextNonSpaceNonCommentCharacter: jt\n  } = X,\n        {\n    composeLoc: Ut,\n    locEnd: qt\n  } = m,\n        {\n    isTypeCastComment: Vt\n  } = Rt;\n\n  function zt(t, e, s, i) {\n    if (!t || \"object\" != typeof t) return;\n\n    if (Array.isArray(t)) {\n      for (let s = 0; s < t.length; s++) zt(t[s], e, t, s);\n\n      return;\n    }\n\n    if (\"string\" != typeof t.type) return;\n\n    for (const s of Object.keys(t)) zt(t[s], e, t, s);\n\n    const r = e(t);\n    r && (s[i] = r);\n  }\n\n  function Ht(t) {\n    return \"LogicalExpression\" === t.type && \"LogicalExpression\" === t.right.type && t.operator === t.right.operator;\n  }\n\n  var Wt = function (t, e) {\n    if (\"typescript\" !== e.parser && \"flow\" !== e.parser) {\n      const e = new Set();\n      zt(t, t => {\n        t.leadingComments && t.leadingComments.some(Vt) && e.add(t.start);\n      }), zt(t, t => {\n        if (\"ParenthesizedExpression\" === t.type && !e.has(t.start)) {\n          const {\n            expression: e\n          } = t;\n          return e.extra || (e.extra = {}), e.extra.parenthesized = !0, e.extra.parenStart = t.start, e;\n        }\n      });\n    }\n\n    return zt(t, t => {\n      switch (t.type) {\n        case \"LogicalExpression\":\n          if (Ht(t)) return function t(e) {\n            if (!Ht(e)) return e;\n            return t(Object.assign({\n              type: \"LogicalExpression\",\n              operator: e.operator,\n              left: t(Object.assign({\n                type: \"LogicalExpression\",\n                operator: e.operator,\n                left: e.left,\n                right: e.right.left\n              }, Ut(e.left, e.right.left))),\n              right: e.right.right\n            }, Ut(e)));\n          }(t);\n          break;\n\n        case \"VariableDeclaration\":\n          {\n            const s = _t(t.declarations);\n\n            s && s.init && function (t, s) {\n              if (\";\" === e.originalText[qt(s)]) return;\n              Array.isArray(t.range) ? t.range = [t.range[0], s.range[1]] : t.end = s.end;\n              t.loc = Object.assign({}, t.loc, {\n                end: t.loc.end\n              });\n            }(t, s);\n            break;\n          }\n\n        case \"TSParenthesizedType\":\n          return Object.assign({}, t.typeAnnotation, {}, Ut(t));\n\n        case \"TSUnionType\":\n        case \"TSIntersectionType\":\n          if (1 === t.types.length) return Object.assign({}, t.types[0], {}, Ut(t));\n          break;\n\n        case \"TSTypeParameter\":\n          \"string\" == typeof t.name && (t.name = Object.assign({\n            type: \"Identifier\",\n            name: t.name\n          }, Ut(t, t.name.length)));\n          break;\n\n        case \"SequenceExpression\":\n          t.end && t.end > _t(t.expressions).end && (t.end = _t(t.expressions).end);\n          break;\n\n        case \"ClassProperty\":\n          t.key && \"TSPrivateIdentifier\" === t.key.type && \"?\" === jt(e.originalText, t.key, qt) && (t.optional = !0);\n      }\n    }), t;\n  },\n      Kt = i(function (t, e) {\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n\n    class s {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.rightAssociative = !!e.rightAssociative, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = null != e.binop ? e.binop : null, this.updateContext = null;\n      }\n\n    }\n\n    const i = new Map();\n\n    function r(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      e.keyword = t;\n      const r = new s(t, e);\n      return i.set(t, r), r;\n    }\n\n    function a(t, e) {\n      return new s(t, {\n        beforeExpr: !0,\n        binop: e\n      });\n    }\n\n    const n = {\n      num: new s(\"num\", {\n        startsExpr: !0\n      }),\n      bigint: new s(\"bigint\", {\n        startsExpr: !0\n      }),\n      regexp: new s(\"regexp\", {\n        startsExpr: !0\n      }),\n      string: new s(\"string\", {\n        startsExpr: !0\n      }),\n      name: new s(\"name\", {\n        startsExpr: !0\n      }),\n      eof: new s(\"eof\"),\n      bracketL: new s(\"[\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      bracketHashL: new s(\"#[\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      bracketBarL: new s(\"[|\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      bracketR: new s(\"]\"),\n      bracketBarR: new s(\"|]\"),\n      braceL: new s(\"{\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      braceBarL: new s(\"{|\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      braceHashL: new s(\"#{\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      braceR: new s(\"}\"),\n      braceBarR: new s(\"|}\"),\n      parenL: new s(\"(\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      parenR: new s(\")\"),\n      comma: new s(\",\", {\n        beforeExpr: !0\n      }),\n      semi: new s(\";\", {\n        beforeExpr: !0\n      }),\n      colon: new s(\":\", {\n        beforeExpr: !0\n      }),\n      doubleColon: new s(\"::\", {\n        beforeExpr: !0\n      }),\n      dot: new s(\".\"),\n      question: new s(\"?\", {\n        beforeExpr: !0\n      }),\n      questionDot: new s(\"?.\"),\n      arrow: new s(\"=>\", {\n        beforeExpr: !0\n      }),\n      template: new s(\"template\"),\n      ellipsis: new s(\"...\", {\n        beforeExpr: !0\n      }),\n      backQuote: new s(\"`\", {\n        startsExpr: !0\n      }),\n      dollarBraceL: new s(\"${\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      at: new s(\"@\"),\n      hash: new s(\"#\", {\n        startsExpr: !0\n      }),\n      interpreterDirective: new s(\"#!...\"),\n      eq: new s(\"=\", {\n        beforeExpr: !0,\n        isAssign: !0\n      }),\n      assign: new s(\"_=\", {\n        beforeExpr: !0,\n        isAssign: !0\n      }),\n      incDec: new s(\"++/--\", {\n        prefix: !0,\n        postfix: !0,\n        startsExpr: !0\n      }),\n      bang: new s(\"!\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      tilde: new s(\"~\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      pipeline: a(\"|>\", 0),\n      nullishCoalescing: a(\"??\", 1),\n      logicalOR: a(\"||\", 1),\n      logicalAND: a(\"&&\", 2),\n      bitwiseOR: a(\"|\", 3),\n      bitwiseXOR: a(\"^\", 4),\n      bitwiseAND: a(\"&\", 5),\n      equality: a(\"==/!=/===/!==\", 6),\n      relational: a(\"</>/<=/>=\", 7),\n      bitShift: a(\"<</>>/>>>\", 8),\n      plusMin: new s(\"+/-\", {\n        beforeExpr: !0,\n        binop: 9,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      modulo: new s(\"%\", {\n        beforeExpr: !0,\n        binop: 10,\n        startsExpr: !0\n      }),\n      star: a(\"*\", 10),\n      slash: a(\"/\", 10),\n      exponent: new s(\"**\", {\n        beforeExpr: !0,\n        binop: 11,\n        rightAssociative: !0\n      }),\n      _break: r(\"break\"),\n      _case: r(\"case\", {\n        beforeExpr: !0\n      }),\n      _catch: r(\"catch\"),\n      _continue: r(\"continue\"),\n      _debugger: r(\"debugger\"),\n      _default: r(\"default\", {\n        beforeExpr: !0\n      }),\n      _do: r(\"do\", {\n        isLoop: !0,\n        beforeExpr: !0\n      }),\n      _else: r(\"else\", {\n        beforeExpr: !0\n      }),\n      _finally: r(\"finally\"),\n      _for: r(\"for\", {\n        isLoop: !0\n      }),\n      _function: r(\"function\", {\n        startsExpr: !0\n      }),\n      _if: r(\"if\"),\n      _return: r(\"return\", {\n        beforeExpr: !0\n      }),\n      _switch: r(\"switch\"),\n      _throw: r(\"throw\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      _try: r(\"try\"),\n      _var: r(\"var\"),\n      _const: r(\"const\"),\n      _while: r(\"while\", {\n        isLoop: !0\n      }),\n      _with: r(\"with\"),\n      _new: r(\"new\", {\n        beforeExpr: !0,\n        startsExpr: !0\n      }),\n      _this: r(\"this\", {\n        startsExpr: !0\n      }),\n      _super: r(\"super\", {\n        startsExpr: !0\n      }),\n      _class: r(\"class\", {\n        startsExpr: !0\n      }),\n      _extends: r(\"extends\", {\n        beforeExpr: !0\n      }),\n      _export: r(\"export\"),\n      _import: r(\"import\", {\n        startsExpr: !0\n      }),\n      _null: r(\"null\", {\n        startsExpr: !0\n      }),\n      _true: r(\"true\", {\n        startsExpr: !0\n      }),\n      _false: r(\"false\", {\n        startsExpr: !0\n      }),\n      _in: r(\"in\", {\n        beforeExpr: !0,\n        binop: 7\n      }),\n      _instanceof: r(\"instanceof\", {\n        beforeExpr: !0,\n        binop: 7\n      }),\n      _typeof: r(\"typeof\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      _void: r(\"void\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      }),\n      _delete: r(\"delete\", {\n        beforeExpr: !0,\n        prefix: !0,\n        startsExpr: !0\n      })\n    },\n          o = /\\r\\n?|[\\n\\u2028\\u2029]/,\n          h = new RegExp(o.source, \"g\");\n\n    function p(t) {\n      switch (t) {\n        case 10:\n        case 13:\n        case 8232:\n        case 8233:\n          return !0;\n\n        default:\n          return !1;\n      }\n    }\n\n    const c = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n    function u(t) {\n      switch (t) {\n        case 9:\n        case 11:\n        case 12:\n        case 32:\n        case 160:\n        case 5760:\n        case 8192:\n        case 8193:\n        case 8194:\n        case 8195:\n        case 8196:\n        case 8197:\n        case 8198:\n        case 8199:\n        case 8200:\n        case 8201:\n        case 8202:\n        case 8239:\n        case 8287:\n        case 12288:\n        case 65279:\n          return !0;\n\n        default:\n          return !1;\n      }\n    }\n\n    class l {\n      constructor(t, e) {\n        this.line = t, this.column = e;\n      }\n\n    }\n\n    class d {\n      constructor(t, e) {\n        this.start = t, this.end = e;\n      }\n\n    }\n\n    function m(t) {\n      return t[t.length - 1];\n    }\n\n    const f = Object.freeze({\n      ArgumentsDisallowedInInitializer: \"'arguments' is not allowed in class field initializer\",\n      AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block\",\n      AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function\",\n      AwaitExpressionFormalParameter: \"await is not allowed in async function parameters\",\n      AwaitNotInAsyncFunction: \"Can not use keyword 'await' outside an async function\",\n      BadGetterArity: \"getter must not have any formal parameters\",\n      BadSetterArity: \"setter must have exactly one formal parameter\",\n      BadSetterRestParameter: \"setter function argument must not be a rest parameter\",\n      ConstructorClassField: \"Classes may not have a field named 'constructor'\",\n      ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'\",\n      ConstructorIsAccessor: \"Class constructor may not be an accessor\",\n      ConstructorIsAsync: \"Constructor can't be an async function\",\n      ConstructorIsGenerator: \"Constructor can't be a generator\",\n      DeclarationMissingInitializer: \"%0 require an initialization value\",\n      DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\",\n      DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n      DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n      DecoratorSemicolon: \"Decorators must not be followed by a semicolon\",\n      DeletePrivateField: \"Deleting a private field is not allowed\",\n      DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n      DuplicateConstructor: \"Duplicate constructor in the same class\",\n      DuplicateDefaultExport: \"Only one default export allowed per module.\",\n      DuplicateExport: \"`%0` has already been exported. Exported identifiers must be unique.\",\n      DuplicateProto: \"Redefinition of __proto__ property\",\n      DuplicateRegExpFlags: \"Duplicate regular expression flag\",\n      ElementAfterRest: \"Rest element must be last element\",\n      EscapedCharNotAnIdentifier: \"Invalid Unicode escape\",\n      ForInOfLoopInitializer: \"%0 loop variable declaration may not have an initializer\",\n      GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block\",\n      IllegalBreakContinue: \"Unsyntactic %0\",\n      IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list\",\n      IllegalReturn: \"'return' outside of function\",\n      ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments\",\n      ImportCallArity: \"import() requires exactly one argument\",\n      ImportCallArityLtOne: \"Dynamic imports require a parameter: import('a.js')\",\n      ImportCallNotNewExpression: \"Cannot use new with import(...)\",\n      ImportCallSpreadArgument: \"... is not allowed in import()\",\n      ImportMetaOutsideModule: \"import.meta may appear only with 'sourceType: \\\"module\\\"'\",\n      ImportOutsideModule: \"'import' and 'export' may appear only with 'sourceType: \\\"module\\\"'\",\n      InvalidCodePoint: \"Code point out of bounds\",\n      InvalidDigit: \"Expected number in radix %0\",\n      InvalidEscapeSequence: \"Bad character escape sequence\",\n      InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template\",\n      InvalidEscapedReservedWord: \"Escape sequence in keyword %0\",\n      InvalidIdentifier: \"Invalid identifier %0\",\n      InvalidLhs: \"Invalid left-hand side in %0\",\n      InvalidLhsBinding: \"Binding invalid left-hand side in %0\",\n      InvalidNumber: \"Invalid number\",\n      InvalidOrUnexpectedToken: \"Unexpected character '%0'\",\n      InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern\",\n      InvalidPrivateFieldResolution: \"Private name #%0 is not defined\",\n      InvalidPropertyBindingPattern: \"Binding member expression\",\n      InvalidRestAssignmentPattern: \"Invalid rest operator's argument\",\n      LabelRedeclaration: \"Label '%0' is already declared\",\n      LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n      MalformedRegExpFlags: \"Invalid regular expression flag\",\n      MissingClassName: \"A class name is required\",\n      MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n      MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX\",\n      MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators\",\n      ModuleExportUndefined: \"Export '%0' is not defined\",\n      MultipleDefaultsInSwitch: \"Multiple default clauses\",\n      NewlineAfterThrow: \"Illegal newline after throw\",\n      NoCatchOrFinally: \"Missing catch or finally clause\",\n      NumberIdentifier: \"Identifier directly after number\",\n      NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\",\n      ObsoleteAwaitStar: \"await* has been removed from the async functions proposal. Use Promise.all() instead.\",\n      OptionalChainingNoNew: \"constructors in/after an Optional Chain are not allowed\",\n      OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain\",\n      ParamDupe: \"Argument name clash\",\n      PatternHasAccessor: \"Object pattern can't contain getter or setter\",\n      PatternHasMethod: \"Object pattern can't contain methods\",\n      PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized',\n      PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression\",\n      PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression\",\n      PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference\",\n      PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding\",\n      PrimaryTopicRequiresSmartPipeline: \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",\n      PrivateNameRedeclaration: \"Duplicate private name #%0\",\n      RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n      RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n      RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n      RestTrailingComma: \"Unexpected trailing comma after rest element\",\n      SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement\",\n      StaticPrototype: \"Classes may not have static property named prototype\",\n      StrictDelete: \"Deleting local variable in strict mode\",\n      StrictEvalArguments: \"Assigning to '%0' in strict mode\",\n      StrictEvalArgumentsBinding: \"Binding '%0' in strict mode\",\n      StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block\",\n      StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode\",\n      StrictWith: \"'with' in strict mode\",\n      SuperNotAllowed: \"super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n      SuperPrivateField: \"Private fields can't be accessed on super\",\n      TrailingDecorator: \"Decorators must be attached to a class element\",\n      TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n      TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n      TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n      UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder\",\n      UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal',\n      UnexpectedDigitAfterHash: \"Unexpected digit after hash token\",\n      UnexpectedImportExport: \"'import' and 'export' may only appear at the top level\",\n      UnexpectedKeyword: \"Unexpected keyword '%0'\",\n      UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration\",\n      UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context\",\n      UnexpectedNewTarget: \"new.target can only be used in functions\",\n      UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits\",\n      UnexpectedPrivateField: \"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",\n      UnexpectedReservedWord: \"Unexpected reserved word '%0'\",\n      UnexpectedSuper: \"super is only allowed in object methods and classes\",\n      UnexpectedToken: \"Unexpected token '%'\",\n      UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n      UnsupportedBind: \"Binding should be performed on object property.\",\n      UnsupportedDecoratorExport: \"A decorated export must export a class declaration\",\n      UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n      UnsupportedImport: \"import can only be used in import() or import.meta\",\n      UnsupportedMetaProperty: \"The only valid meta property for %0 is %0.%1\",\n      UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters\",\n      UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties\",\n      UnsupportedSuper: \"super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])\",\n      UnterminatedComment: \"Unterminated comment\",\n      UnterminatedRegExp: \"Unterminated regular expression\",\n      UnterminatedString: \"Unterminated string constant\",\n      UnterminatedTemplate: \"Unterminated template\",\n      VarRedeclaration: \"Identifier '%0' has already been declared\",\n      YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator\",\n      YieldInParameter: \"yield is not allowed in generator parameters\",\n      ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0\"\n    });\n\n    function D(t) {\n      return null != t && \"Property\" === t.type && \"init\" === t.kind && !1 === t.method;\n    }\n\n    class y {\n      constructor(t, e, s, i) {\n        this.token = t, this.isExpr = !!e, this.preserveSpace = !!s, this.override = i;\n      }\n\n    }\n\n    const x = {\n      braceStatement: new y(\"{\", !1),\n      braceExpression: new y(\"{\", !0),\n      templateQuasi: new y(\"${\", !1),\n      parenStatement: new y(\"(\", !1),\n      parenExpression: new y(\"(\", !0),\n      template: new y(\"`\", !0, !0, t => t.readTmplToken()),\n      functionExpression: new y(\"function\", !0),\n      functionStatement: new y(\"function\", !1)\n    };\n    n.parenR.updateContext = n.braceR.updateContext = function () {\n      if (1 === this.state.context.length) return void (this.state.exprAllowed = !0);\n      let t = this.state.context.pop();\n      t === x.braceStatement && \"function\" === this.curContext().token && (t = this.state.context.pop()), this.state.exprAllowed = !t.isExpr;\n    }, n.name.updateContext = function (t) {\n      let e = !1;\n      t !== n.dot && (\"of\" === this.state.value && !this.state.exprAllowed || \"yield\" === this.state.value && this.prodParam.hasYield) && (e = !0), this.state.exprAllowed = e, this.state.isIterator && (this.state.isIterator = !1);\n    }, n.braceL.updateContext = function (t) {\n      this.state.context.push(this.braceIsBlock(t) ? x.braceStatement : x.braceExpression), this.state.exprAllowed = !0;\n    }, n.dollarBraceL.updateContext = function () {\n      this.state.context.push(x.templateQuasi), this.state.exprAllowed = !0;\n    }, n.parenL.updateContext = function (t) {\n      const e = t === n._if || t === n._for || t === n._with || t === n._while;\n      this.state.context.push(e ? x.parenStatement : x.parenExpression), this.state.exprAllowed = !0;\n    }, n.incDec.updateContext = function () {}, n._function.updateContext = n._class.updateContext = function (t) {\n      !t.beforeExpr || t === n.semi || t === n._else || t === n._return && o.test(this.input.slice(this.state.lastTokEnd, this.state.start)) || (t === n.colon || t === n.braceL) && this.curContext() === x.b_stat ? this.state.context.push(x.functionStatement) : this.state.context.push(x.functionExpression), this.state.exprAllowed = !1;\n    }, n.backQuote.updateContext = function () {\n      this.curContext() === x.template ? this.state.context.pop() : this.state.context.push(x.template), this.state.exprAllowed = !1;\n    };\n    let g = \"ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࣇऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-鿼ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-ꟊꟵ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ\",\n        P = \"‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿᫀᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿\";\n    const E = new RegExp(\"[\" + g + \"]\"),\n          C = new RegExp(\"[\" + g + P + \"]\");\n    g = P = null;\n    const b = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938],\n          T = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\n    function A(t, e) {\n      let s = 65536;\n\n      for (let i = 0, r = e.length; i < r; i += 2) {\n        if (s += e[i], s > t) return !1;\n        if (s += e[i + 1], s >= t) return !0;\n      }\n\n      return !1;\n    }\n\n    function w(t) {\n      return t < 65 ? 36 === t : t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && E.test(String.fromCharCode(t)) : A(t, b)));\n    }\n\n    function S(t) {\n      return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && C.test(String.fromCharCode(t)) : A(t, b) || A(t, T))));\n    }\n\n    const N = [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n          F = [\"eval\", \"arguments\"],\n          k = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"]),\n          I = new Set(N),\n          v = new Set(F);\n\n    function L(t, e) {\n      return e && \"await\" === t || \"enum\" === t;\n    }\n\n    function B(t, e) {\n      return L(t, e) || I.has(t);\n    }\n\n    function M(t) {\n      return v.has(t);\n    }\n\n    function O(t, e) {\n      return B(t, e) || M(t);\n    }\n\n    const R = /^in(stanceof)?$/;\n\n    const _ = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]),\n          j = Object.freeze({\n      AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n      AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\",\n      AssignReservedType: \"Cannot overwrite reserved type %0\",\n      DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n      DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n      DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement\",\n      EnumBooleanMemberNotInitialized: \"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",\n      EnumDuplicateMemberName: \"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",\n      EnumInconsistentMemberValues: \"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",\n      EnumInvalidExplicitType: \"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n      EnumInvalidExplicitTypeUnknownSupplied: \"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n      EnumInvalidMemberInitializerPrimaryType: \"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",\n      EnumInvalidMemberInitializerSymbolType: \"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",\n      EnumInvalidMemberInitializerUnknownType: \"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",\n      EnumInvalidMemberName: \"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",\n      EnumNumberMemberNotInitialized: \"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",\n      EnumStringMemberInconsistentlyInitailized: \"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",\n      ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\",\n      InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type\",\n      InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions\",\n      InexactVariance: \"Explicit inexact syntax cannot have variance\",\n      InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`\",\n      MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n      NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`\",\n      NestedFlowComment: \"Cannot have a flow comment inside another flow comment\",\n      OptionalBindingPattern: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n      SpreadVariance: \"Spread properties cannot have variance\",\n      TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n      TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis\",\n      UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object\",\n      UnexpectedReservedType: \"Unexpected reserved type %0\",\n      UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new\",\n      UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n      UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions\",\n      UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\"',\n      UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration\",\n      UnsupportedDeclareExportKind: \"`declare export %0` is not supported. Use `%1` instead\",\n      UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module\",\n      UnterminatedFlowComment: \"Unterminated flow-comment\"\n    });\n\n    function U(t) {\n      return \"type\" === t.importKind || \"typeof\" === t.importKind;\n    }\n\n    function q(t) {\n      return (t.type === n.name || !!t.type.keyword) && \"from\" !== t.value;\n    }\n\n    const V = {\n      const: \"declare export var\",\n      let: \"declare export var\",\n      type: \"export type\",\n      interface: \"export interface\"\n    };\n    const z = /\\*?\\s*@((?:no)?flow)\\b/;\n    const H = {\n      quot: '\"',\n      amp: \"&\",\n      apos: \"'\",\n      lt: \"<\",\n      gt: \">\",\n      nbsp: \" \",\n      iexcl: \"¡\",\n      cent: \"¢\",\n      pound: \"£\",\n      curren: \"¤\",\n      yen: \"¥\",\n      brvbar: \"¦\",\n      sect: \"§\",\n      uml: \"¨\",\n      copy: \"©\",\n      ordf: \"ª\",\n      laquo: \"«\",\n      not: \"¬\",\n      shy: \"­\",\n      reg: \"®\",\n      macr: \"¯\",\n      deg: \"°\",\n      plusmn: \"±\",\n      sup2: \"²\",\n      sup3: \"³\",\n      acute: \"´\",\n      micro: \"µ\",\n      para: \"¶\",\n      middot: \"·\",\n      cedil: \"¸\",\n      sup1: \"¹\",\n      ordm: \"º\",\n      raquo: \"»\",\n      frac14: \"¼\",\n      frac12: \"½\",\n      frac34: \"¾\",\n      iquest: \"¿\",\n      Agrave: \"À\",\n      Aacute: \"Á\",\n      Acirc: \"Â\",\n      Atilde: \"Ã\",\n      Auml: \"Ä\",\n      Aring: \"Å\",\n      AElig: \"Æ\",\n      Ccedil: \"Ç\",\n      Egrave: \"È\",\n      Eacute: \"É\",\n      Ecirc: \"Ê\",\n      Euml: \"Ë\",\n      Igrave: \"Ì\",\n      Iacute: \"Í\",\n      Icirc: \"Î\",\n      Iuml: \"Ï\",\n      ETH: \"Ð\",\n      Ntilde: \"Ñ\",\n      Ograve: \"Ò\",\n      Oacute: \"Ó\",\n      Ocirc: \"Ô\",\n      Otilde: \"Õ\",\n      Ouml: \"Ö\",\n      times: \"×\",\n      Oslash: \"Ø\",\n      Ugrave: \"Ù\",\n      Uacute: \"Ú\",\n      Ucirc: \"Û\",\n      Uuml: \"Ü\",\n      Yacute: \"Ý\",\n      THORN: \"Þ\",\n      szlig: \"ß\",\n      agrave: \"à\",\n      aacute: \"á\",\n      acirc: \"â\",\n      atilde: \"ã\",\n      auml: \"ä\",\n      aring: \"å\",\n      aelig: \"æ\",\n      ccedil: \"ç\",\n      egrave: \"è\",\n      eacute: \"é\",\n      ecirc: \"ê\",\n      euml: \"ë\",\n      igrave: \"ì\",\n      iacute: \"í\",\n      icirc: \"î\",\n      iuml: \"ï\",\n      eth: \"ð\",\n      ntilde: \"ñ\",\n      ograve: \"ò\",\n      oacute: \"ó\",\n      ocirc: \"ô\",\n      otilde: \"õ\",\n      ouml: \"ö\",\n      divide: \"÷\",\n      oslash: \"ø\",\n      ugrave: \"ù\",\n      uacute: \"ú\",\n      ucirc: \"û\",\n      uuml: \"ü\",\n      yacute: \"ý\",\n      thorn: \"þ\",\n      yuml: \"ÿ\",\n      OElig: \"Œ\",\n      oelig: \"œ\",\n      Scaron: \"Š\",\n      scaron: \"š\",\n      Yuml: \"Ÿ\",\n      fnof: \"ƒ\",\n      circ: \"ˆ\",\n      tilde: \"˜\",\n      Alpha: \"Α\",\n      Beta: \"Β\",\n      Gamma: \"Γ\",\n      Delta: \"Δ\",\n      Epsilon: \"Ε\",\n      Zeta: \"Ζ\",\n      Eta: \"Η\",\n      Theta: \"Θ\",\n      Iota: \"Ι\",\n      Kappa: \"Κ\",\n      Lambda: \"Λ\",\n      Mu: \"Μ\",\n      Nu: \"Ν\",\n      Xi: \"Ξ\",\n      Omicron: \"Ο\",\n      Pi: \"Π\",\n      Rho: \"Ρ\",\n      Sigma: \"Σ\",\n      Tau: \"Τ\",\n      Upsilon: \"Υ\",\n      Phi: \"Φ\",\n      Chi: \"Χ\",\n      Psi: \"Ψ\",\n      Omega: \"Ω\",\n      alpha: \"α\",\n      beta: \"β\",\n      gamma: \"γ\",\n      delta: \"δ\",\n      epsilon: \"ε\",\n      zeta: \"ζ\",\n      eta: \"η\",\n      theta: \"θ\",\n      iota: \"ι\",\n      kappa: \"κ\",\n      lambda: \"λ\",\n      mu: \"μ\",\n      nu: \"ν\",\n      xi: \"ξ\",\n      omicron: \"ο\",\n      pi: \"π\",\n      rho: \"ρ\",\n      sigmaf: \"ς\",\n      sigma: \"σ\",\n      tau: \"τ\",\n      upsilon: \"υ\",\n      phi: \"φ\",\n      chi: \"χ\",\n      psi: \"ψ\",\n      omega: \"ω\",\n      thetasym: \"ϑ\",\n      upsih: \"ϒ\",\n      piv: \"ϖ\",\n      ensp: \" \",\n      emsp: \" \",\n      thinsp: \" \",\n      zwnj: \"‌\",\n      zwj: \"‍\",\n      lrm: \"‎\",\n      rlm: \"‏\",\n      ndash: \"–\",\n      mdash: \"—\",\n      lsquo: \"‘\",\n      rsquo: \"’\",\n      sbquo: \"‚\",\n      ldquo: \"“\",\n      rdquo: \"”\",\n      bdquo: \"„\",\n      dagger: \"†\",\n      Dagger: \"‡\",\n      bull: \"•\",\n      hellip: \"…\",\n      permil: \"‰\",\n      prime: \"′\",\n      Prime: \"″\",\n      lsaquo: \"‹\",\n      rsaquo: \"›\",\n      oline: \"‾\",\n      frasl: \"⁄\",\n      euro: \"€\",\n      image: \"ℑ\",\n      weierp: \"℘\",\n      real: \"ℜ\",\n      trade: \"™\",\n      alefsym: \"ℵ\",\n      larr: \"←\",\n      uarr: \"↑\",\n      rarr: \"→\",\n      darr: \"↓\",\n      harr: \"↔\",\n      crarr: \"↵\",\n      lArr: \"⇐\",\n      uArr: \"⇑\",\n      rArr: \"⇒\",\n      dArr: \"⇓\",\n      hArr: \"⇔\",\n      forall: \"∀\",\n      part: \"∂\",\n      exist: \"∃\",\n      empty: \"∅\",\n      nabla: \"∇\",\n      isin: \"∈\",\n      notin: \"∉\",\n      ni: \"∋\",\n      prod: \"∏\",\n      sum: \"∑\",\n      minus: \"−\",\n      lowast: \"∗\",\n      radic: \"√\",\n      prop: \"∝\",\n      infin: \"∞\",\n      ang: \"∠\",\n      and: \"∧\",\n      or: \"∨\",\n      cap: \"∩\",\n      cup: \"∪\",\n      int: \"∫\",\n      there4: \"∴\",\n      sim: \"∼\",\n      cong: \"≅\",\n      asymp: \"≈\",\n      ne: \"≠\",\n      equiv: \"≡\",\n      le: \"≤\",\n      ge: \"≥\",\n      sub: \"⊂\",\n      sup: \"⊃\",\n      nsub: \"⊄\",\n      sube: \"⊆\",\n      supe: \"⊇\",\n      oplus: \"⊕\",\n      otimes: \"⊗\",\n      perp: \"⊥\",\n      sdot: \"⋅\",\n      lceil: \"⌈\",\n      rceil: \"⌉\",\n      lfloor: \"⌊\",\n      rfloor: \"⌋\",\n      lang: \"〈\",\n      rang: \"〉\",\n      loz: \"◊\",\n      spades: \"♠\",\n      clubs: \"♣\",\n      hearts: \"♥\",\n      diams: \"♦\"\n    },\n          W = /^[\\da-fA-F]+$/,\n          K = /^\\d+$/,\n          J = Object.freeze({\n      AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression\",\n      MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>\",\n      MissingClosingTagElement: \"Expected corresponding JSX closing tag for <%0>\",\n      UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text\",\n      UnterminatedJsxContent: \"Unterminated JSX contents\",\n      UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n    });\n\n    function X(t) {\n      return !!t && (\"JSXOpeningFragment\" === t.type || \"JSXClosingFragment\" === t.type);\n    }\n\n    function G(t) {\n      if (\"JSXIdentifier\" === t.type) return t.name;\n      if (\"JSXNamespacedName\" === t.type) return t.namespace.name + \":\" + t.name.name;\n      if (\"JSXMemberExpression\" === t.type) return G(t.object) + \".\" + G(t.property);\n      throw new Error(\"Node had unexpected type: \" + t.type);\n    }\n\n    x.j_oTag = new y(\"<tag\", !1), x.j_cTag = new y(\"</tag\", !1), x.j_expr = new y(\"<tag>...</tag>\", !0, !0), n.jsxName = new s(\"jsxName\"), n.jsxText = new s(\"jsxText\", {\n      beforeExpr: !0\n    }), n.jsxTagStart = new s(\"jsxTagStart\", {\n      startsExpr: !0\n    }), n.jsxTagEnd = new s(\"jsxTagEnd\"), n.jsxTagStart.updateContext = function () {\n      this.state.context.push(x.j_expr), this.state.context.push(x.j_oTag), this.state.exprAllowed = !1;\n    }, n.jsxTagEnd.updateContext = function (t) {\n      const e = this.state.context.pop();\n      e === x.j_oTag && t === n.slash || e === x.j_cTag ? (this.state.context.pop(), this.state.exprAllowed = this.curContext() === x.j_expr) : this.state.exprAllowed = !0;\n    };\n\n    class Q {\n      constructor(t) {\n        this.var = [], this.lexical = [], this.functions = [], this.flags = t;\n      }\n\n    }\n\n    class Y {\n      constructor(t, e) {\n        this.scopeStack = [], this.undefinedExports = new Map(), this.undefinedPrivateNames = new Map(), this.raise = t, this.inModule = e;\n      }\n\n      get inFunction() {\n        return (2 & this.currentVarScope().flags) > 0;\n      }\n\n      get allowSuper() {\n        return (16 & this.currentThisScope().flags) > 0;\n      }\n\n      get allowDirectSuper() {\n        return (32 & this.currentThisScope().flags) > 0;\n      }\n\n      get inClass() {\n        return (64 & this.currentThisScope().flags) > 0;\n      }\n\n      get inNonArrowFunction() {\n        return (2 & this.currentThisScope().flags) > 0;\n      }\n\n      get treatFunctionsAsVar() {\n        return this.treatFunctionsAsVarInScope(this.currentScope());\n      }\n\n      createScope(t) {\n        return new Q(t);\n      }\n\n      enter(t) {\n        this.scopeStack.push(this.createScope(t));\n      }\n\n      exit() {\n        this.scopeStack.pop();\n      }\n\n      treatFunctionsAsVarInScope(t) {\n        return !!(2 & t.flags || !this.inModule && 1 & t.flags);\n      }\n\n      declareName(t, e, s) {\n        let i = this.currentScope();\n        if (8 & e || 16 & e) this.checkRedeclarationInScope(i, t, e, s), 16 & e ? i.functions.push(t) : i.lexical.push(t), 8 & e && this.maybeExportDefined(i, t);else if (4 & e) for (let r = this.scopeStack.length - 1; r >= 0 && (i = this.scopeStack[r], this.checkRedeclarationInScope(i, t, e, s), i.var.push(t), this.maybeExportDefined(i, t), !(131 & i.flags)); --r);\n        this.inModule && 1 & i.flags && this.undefinedExports.delete(t);\n      }\n\n      maybeExportDefined(t, e) {\n        this.inModule && 1 & t.flags && this.undefinedExports.delete(e);\n      }\n\n      checkRedeclarationInScope(t, e, s, i) {\n        this.isRedeclaredInScope(t, e, s) && this.raise(i, f.VarRedeclaration, e);\n      }\n\n      isRedeclaredInScope(t, e, s) {\n        return !!(1 & s) && (8 & s ? t.lexical.indexOf(e) > -1 || t.functions.indexOf(e) > -1 || t.var.indexOf(e) > -1 : 16 & s ? t.lexical.indexOf(e) > -1 || !this.treatFunctionsAsVarInScope(t) && t.var.indexOf(e) > -1 : t.lexical.indexOf(e) > -1 && !(8 & t.flags && t.lexical[0] === e) || !this.treatFunctionsAsVarInScope(t) && t.functions.indexOf(e) > -1);\n      }\n\n      checkLocalExport(t) {\n        -1 === this.scopeStack[0].lexical.indexOf(t.name) && -1 === this.scopeStack[0].var.indexOf(t.name) && -1 === this.scopeStack[0].functions.indexOf(t.name) && this.undefinedExports.set(t.name, t.start);\n      }\n\n      currentScope() {\n        return this.scopeStack[this.scopeStack.length - 1];\n      }\n\n      currentVarScope() {\n        for (let t = this.scopeStack.length - 1;; t--) {\n          const e = this.scopeStack[t];\n          if (131 & e.flags) return e;\n        }\n      }\n\n      currentThisScope() {\n        for (let t = this.scopeStack.length - 1;; t--) {\n          const e = this.scopeStack[t];\n          if ((131 & e.flags || 64 & e.flags) && !(4 & e.flags)) return e;\n        }\n      }\n\n    }\n\n    class $ extends Q {\n      constructor() {\n        super(...arguments), this.types = [], this.enums = [], this.constEnums = [], this.classes = [], this.exportOnlyBindings = [];\n      }\n\n    }\n\n    class Z extends Y {\n      createScope(t) {\n        return new $(t);\n      }\n\n      declareName(t, e, s) {\n        const i = this.currentScope();\n        if (1024 & e) return this.maybeExportDefined(i, t), void i.exportOnlyBindings.push(t);\n        super.declareName(...arguments), 2 & e && (1 & e || (this.checkRedeclarationInScope(i, t, e, s), this.maybeExportDefined(i, t)), i.types.push(t)), 256 & e && i.enums.push(t), 512 & e && i.constEnums.push(t), 128 & e && i.classes.push(t);\n      }\n\n      isRedeclaredInScope(t, e, s) {\n        if (t.enums.indexOf(e) > -1) {\n          if (256 & s) {\n            return !!(512 & s) !== t.constEnums.indexOf(e) > -1;\n          }\n\n          return !0;\n        }\n\n        return 128 & s && t.classes.indexOf(e) > -1 ? t.lexical.indexOf(e) > -1 && !!(1 & s) : !!(2 & s && t.types.indexOf(e) > -1) || super.isRedeclaredInScope(...arguments);\n      }\n\n      checkLocalExport(t) {\n        -1 === this.scopeStack[0].types.indexOf(t.name) && -1 === this.scopeStack[0].exportOnlyBindings.indexOf(t.name) && super.checkLocalExport(t);\n      }\n\n    }\n\n    class tt {\n      constructor() {\n        this.stacks = [];\n      }\n\n      enter(t) {\n        this.stacks.push(t);\n      }\n\n      exit() {\n        this.stacks.pop();\n      }\n\n      currentFlags() {\n        return this.stacks[this.stacks.length - 1];\n      }\n\n      get hasAwait() {\n        return (2 & this.currentFlags()) > 0;\n      }\n\n      get hasYield() {\n        return (1 & this.currentFlags()) > 0;\n      }\n\n      get hasReturn() {\n        return (4 & this.currentFlags()) > 0;\n      }\n\n    }\n\n    function et(t, e) {\n      return (t ? 2 : 0) | (e ? 1 : 0);\n    }\n\n    function st(t) {\n      if (null == t) throw new Error(\"Unexpected \".concat(t, \" value.\"));\n      return t;\n    }\n\n    function it(t) {\n      if (!t) throw new Error(\"Assert fail\");\n    }\n\n    const rt = Object.freeze({\n      ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier\",\n      ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier\",\n      DeclareClassFieldHasInitializer: \"'declare' class fields cannot have an initializer\",\n      DuplicateModifier: \"Duplicate modifier: '%0'\",\n      EmptyHeritageClauseType: \"'%0' list cannot be empty.\",\n      IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier\",\n      IndexSignatureHasAccessibility: \"Index signatures cannot have an accessibility modifier ('%0')\",\n      IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier\",\n      OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n      PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n      PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n      PrivateElementHasAccessibility: \"Private elements cannot have an accessibility modifier ('%0')\",\n      TemplateTypeHasSubstitution: \"Template literal types cannot have any substitution\",\n      TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n      UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n      UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n      UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n      UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal\",\n      UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n      UnsupportedSignatureParameterKind: \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0\"\n    });\n    n.placeholder = new s(\"%%\", {\n      startsExpr: !0\n    });\n\n    function at(t, e) {\n      return t.some(t => Array.isArray(t) ? t[0] === e : t === e);\n    }\n\n    function nt(t, e, s) {\n      const i = t.find(t => Array.isArray(t) ? t[0] === e : t === e);\n      return i && Array.isArray(i) ? i[1][s] : null;\n    }\n\n    const ot = [\"minimal\", \"smart\", \"fsharp\"],\n          ht = [\"hash\", \"bar\"];\n    const pt = {\n      estree: t => class extends t {\n        estreeParseRegExpLiteral(_ref2) {\n          let {\n            pattern: t,\n            flags: e\n          } = _ref2;\n          let s = null;\n\n          try {\n            s = new RegExp(t, e);\n          } catch (t) {}\n\n          const i = this.estreeParseLiteral(s);\n          return i.regex = {\n            pattern: t,\n            flags: e\n          }, i;\n        }\n\n        estreeParseBigIntLiteral(t) {\n          const e = \"undefined\" != typeof BigInt ? BigInt(t) : null,\n                s = this.estreeParseLiteral(e);\n          return s.bigint = String(s.value || t), s;\n        }\n\n        estreeParseLiteral(t) {\n          return this.parseLiteral(t, \"Literal\");\n        }\n\n        directiveToStmt(t) {\n          const e = t.value,\n                s = this.startNodeAt(t.start, t.loc.start),\n                i = this.startNodeAt(e.start, e.loc.start);\n          return i.value = e.value, i.raw = e.extra.raw, s.expression = this.finishNodeAt(i, \"Literal\", e.end, e.loc.end), s.directive = e.extra.raw.slice(1, -1), this.finishNodeAt(s, \"ExpressionStatement\", t.end, t.loc.end);\n        }\n\n        initFunction(t, e) {\n          super.initFunction(t, e), t.expression = !1;\n        }\n\n        checkDeclaration(t) {\n          D(t) ? this.checkDeclaration(t.value) : super.checkDeclaration(t);\n        }\n\n        checkGetterSetterParams(t) {\n          const e = t,\n                s = \"get\" === e.kind ? 0 : 1,\n                i = e.start;\n          e.value.params.length !== s ? \"get\" === t.kind ? this.raise(i, f.BadGetterArity) : this.raise(i, f.BadSetterArity) : \"set\" === e.kind && \"RestElement\" === e.value.params[0].type && this.raise(i, f.BadSetterRestParameter);\n        }\n\n        checkLVal(t) {\n          let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n          let s = arguments.length > 2 ? arguments[2] : undefined;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          let r = arguments.length > 4 ? arguments[4] : undefined;\n\n          switch (t.type) {\n            case \"ObjectPattern\":\n              t.properties.forEach(t => {\n                this.checkLVal(\"Property\" === t.type ? t.value : t, e, s, \"object destructuring pattern\", r);\n              });\n              break;\n\n            default:\n              super.checkLVal(t, e, s, i, r);\n          }\n        }\n\n        checkDuplicatedProto(t, e, s) {\n          if (\"SpreadElement\" === t.type || t.computed || t.method || t.shorthand) return;\n          const i = t.key;\n          \"__proto__\" === (\"Identifier\" === i.type ? i.name : String(i.value)) && \"init\" === t.kind && (e.used && (s && -1 === s.doubleProto ? s.doubleProto = i.start : this.raise(i.start, f.DuplicateProto)), e.used = !0);\n        }\n\n        isValidDirective(t) {\n          return !(\"ExpressionStatement\" !== t.type || \"Literal\" !== t.expression.type || \"string\" != typeof t.expression.value || t.expression.extra && t.expression.extra.parenthesized);\n        }\n\n        stmtToDirective(t) {\n          const e = super.stmtToDirective(t),\n                s = t.expression.value;\n          return e.value.value = s, e;\n        }\n\n        parseBlockBody(t, e, s, i) {\n          super.parseBlockBody(t, e, s, i);\n          const r = t.directives.map(t => this.directiveToStmt(t));\n          t.body = r.concat(t.body), delete t.directives;\n        }\n\n        pushClassMethod(t, e, s, i, r, a) {\n          this.parseMethod(e, s, i, r, a, \"ClassMethod\", !0), e.typeParameters && (e.value.typeParameters = e.typeParameters, delete e.typeParameters), t.body.push(e);\n        }\n\n        parseExprAtom(t) {\n          switch (this.state.type) {\n            case n.num:\n            case n.string:\n              return this.estreeParseLiteral(this.state.value);\n\n            case n.regexp:\n              return this.estreeParseRegExpLiteral(this.state.value);\n\n            case n.bigint:\n              return this.estreeParseBigIntLiteral(this.state.value);\n\n            case n._null:\n              return this.estreeParseLiteral(null);\n\n            case n._true:\n              return this.estreeParseLiteral(!0);\n\n            case n._false:\n              return this.estreeParseLiteral(!1);\n\n            default:\n              return super.parseExprAtom(t);\n          }\n        }\n\n        parseLiteral(t, e, s, i) {\n          const r = super.parseLiteral(t, e, s, i);\n          return r.raw = r.extra.raw, delete r.extra, r;\n        }\n\n        parseFunctionBody(t, e) {\n          let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n          super.parseFunctionBody(t, e, s), t.expression = \"BlockStatement\" !== t.body.type;\n        }\n\n        parseMethod(t, e, s, i, r, a) {\n          let n = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;\n          let o = this.startNode();\n          return o.kind = t.kind, o = super.parseMethod(o, e, s, i, r, a, n), o.type = \"FunctionExpression\", delete o.kind, t.value = o, a = \"ClassMethod\" === a ? \"MethodDefinition\" : a, this.finishNode(t, a);\n        }\n\n        parseObjectMethod(t, e, s, i, r) {\n          const a = super.parseObjectMethod(t, e, s, i, r);\n          return a && (a.type = \"Property\", \"method\" === a.kind && (a.kind = \"init\"), a.shorthand = !1), a;\n        }\n\n        parseObjectProperty(t, e, s, i, r) {\n          const a = super.parseObjectProperty(t, e, s, i, r);\n          return a && (a.kind = \"init\", a.type = \"Property\"), a;\n        }\n\n        toAssignable(t) {\n          return D(t) ? (this.toAssignable(t.value), t) : super.toAssignable(t);\n        }\n\n        toAssignableObjectExpressionProp(t, e) {\n          if (\"get\" === t.kind || \"set\" === t.kind) throw this.raise(t.key.start, f.PatternHasAccessor);\n          if (t.method) throw this.raise(t.key.start, f.PatternHasMethod);\n          super.toAssignableObjectExpressionProp(t, e);\n        }\n\n        finishCallExpression(t, e) {\n          return super.finishCallExpression(t, e), \"Import\" === t.callee.type && (t.type = \"ImportExpression\", t.source = t.arguments[0], delete t.arguments, delete t.callee), t;\n        }\n\n        toReferencedListDeep(t, e) {\n          t && super.toReferencedListDeep(t, e);\n        }\n\n        parseExport(t) {\n          switch (super.parseExport(t), t.type) {\n            case \"ExportAllDeclaration\":\n              t.exported = null;\n              break;\n\n            case \"ExportNamedDeclaration\":\n              1 === t.specifiers.length && \"ExportNamespaceSpecifier\" === t.specifiers[0].type && (t.type = \"ExportAllDeclaration\", t.exported = t.specifiers[0].exported, delete t.specifiers);\n          }\n\n          return t;\n        }\n\n      },\n      jsx: t => class extends t {\n        jsxReadToken() {\n          let t = \"\",\n              e = this.state.pos;\n\n          for (;;) {\n            if (this.state.pos >= this.length) throw this.raise(this.state.start, J.UnterminatedJsxContent);\n            const s = this.input.charCodeAt(this.state.pos);\n\n            switch (s) {\n              case 60:\n              case 123:\n                return this.state.pos === this.state.start ? 60 === s && this.state.exprAllowed ? (++this.state.pos, this.finishToken(n.jsxTagStart)) : super.getTokenFromCode(s) : (t += this.input.slice(e, this.state.pos), this.finishToken(n.jsxText, t));\n\n              case 38:\n                t += this.input.slice(e, this.state.pos), t += this.jsxReadEntity(), e = this.state.pos;\n                break;\n\n              default:\n                p(s) ? (t += this.input.slice(e, this.state.pos), t += this.jsxReadNewLine(!0), e = this.state.pos) : ++this.state.pos;\n            }\n          }\n        }\n\n        jsxReadNewLine(t) {\n          const e = this.input.charCodeAt(this.state.pos);\n          let s;\n          return ++this.state.pos, 13 === e && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, s = t ? \"\\n\" : \"\\r\\n\") : s = String.fromCharCode(e), ++this.state.curLine, this.state.lineStart = this.state.pos, s;\n        }\n\n        jsxReadString(t) {\n          let e = \"\",\n              s = ++this.state.pos;\n\n          for (;;) {\n            if (this.state.pos >= this.length) throw this.raise(this.state.start, f.UnterminatedString);\n            const i = this.input.charCodeAt(this.state.pos);\n            if (i === t) break;\n            38 === i ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos) : p(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(!1), s = this.state.pos) : ++this.state.pos;\n          }\n\n          return e += this.input.slice(s, this.state.pos++), this.finishToken(n.string, e);\n        }\n\n        jsxReadEntity() {\n          let t,\n              e = \"\",\n              s = 0,\n              i = this.input[this.state.pos];\n          const r = ++this.state.pos;\n\n          for (; this.state.pos < this.length && s++ < 10;) {\n            if (i = this.input[this.state.pos++], \";\" === i) {\n              \"#\" === e[0] ? \"x\" === e[1] ? (e = e.substr(2), W.test(e) && (t = String.fromCodePoint(parseInt(e, 16)))) : (e = e.substr(1), K.test(e) && (t = String.fromCodePoint(parseInt(e, 10)))) : t = H[e];\n              break;\n            }\n\n            e += i;\n          }\n\n          return t || (this.state.pos = r, \"&\");\n        }\n\n        jsxReadWord() {\n          let t;\n          const e = this.state.pos;\n\n          do {\n            t = this.input.charCodeAt(++this.state.pos);\n          } while (S(t) || 45 === t);\n\n          return this.finishToken(n.jsxName, this.input.slice(e, this.state.pos));\n        }\n\n        jsxParseIdentifier() {\n          const t = this.startNode();\n          return this.match(n.jsxName) ? t.name = this.state.value : this.state.type.keyword ? t.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(t, \"JSXIdentifier\");\n        }\n\n        jsxParseNamespacedName() {\n          const t = this.state.start,\n                e = this.state.startLoc,\n                s = this.jsxParseIdentifier();\n          if (!this.eat(n.colon)) return s;\n          const i = this.startNodeAt(t, e);\n          return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, \"JSXNamespacedName\");\n        }\n\n        jsxParseElementName() {\n          const t = this.state.start,\n                e = this.state.startLoc;\n          let s = this.jsxParseNamespacedName();\n          if (\"JSXNamespacedName\" === s.type) return s;\n\n          for (; this.eat(n.dot);) {\n            const i = this.startNodeAt(t, e);\n            i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, \"JSXMemberExpression\");\n          }\n\n          return s;\n        }\n\n        jsxParseAttributeValue() {\n          let t;\n\n          switch (this.state.type) {\n            case n.braceL:\n              return t = this.startNode(), this.next(), t = this.jsxParseExpressionContainer(t), \"JSXEmptyExpression\" === t.expression.type && this.raise(t.start, J.AttributeIsEmpty), t;\n\n            case n.jsxTagStart:\n            case n.string:\n              return this.parseExprAtom();\n\n            default:\n              throw this.raise(this.state.start, J.UnsupportedJsxValue);\n          }\n        }\n\n        jsxParseEmptyExpression() {\n          const t = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n          return this.finishNodeAt(t, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n        }\n\n        jsxParseSpreadChild(t) {\n          return this.next(), t.expression = this.parseExpression(), this.expect(n.braceR), this.finishNode(t, \"JSXSpreadChild\");\n        }\n\n        jsxParseExpressionContainer(t) {\n          return this.match(n.braceR) ? t.expression = this.jsxParseEmptyExpression() : t.expression = this.parseExpression(), this.expect(n.braceR), this.finishNode(t, \"JSXExpressionContainer\");\n        }\n\n        jsxParseAttribute() {\n          const t = this.startNode();\n          return this.eat(n.braceL) ? (this.expect(n.ellipsis), t.argument = this.parseMaybeAssign(), this.expect(n.braceR), this.finishNode(t, \"JSXSpreadAttribute\")) : (t.name = this.jsxParseNamespacedName(), t.value = this.eat(n.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(t, \"JSXAttribute\"));\n        }\n\n        jsxParseOpeningElementAt(t, e) {\n          const s = this.startNodeAt(t, e);\n          return this.match(n.jsxTagEnd) ? (this.expect(n.jsxTagEnd), this.finishNode(s, \"JSXOpeningFragment\")) : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));\n        }\n\n        jsxParseOpeningElementAfterName(t) {\n          const e = [];\n\n          for (; !this.match(n.slash) && !this.match(n.jsxTagEnd);) e.push(this.jsxParseAttribute());\n\n          return t.attributes = e, t.selfClosing = this.eat(n.slash), this.expect(n.jsxTagEnd), this.finishNode(t, \"JSXOpeningElement\");\n        }\n\n        jsxParseClosingElementAt(t, e) {\n          const s = this.startNodeAt(t, e);\n          return this.match(n.jsxTagEnd) ? (this.expect(n.jsxTagEnd), this.finishNode(s, \"JSXClosingFragment\")) : (s.name = this.jsxParseElementName(), this.expect(n.jsxTagEnd), this.finishNode(s, \"JSXClosingElement\"));\n        }\n\n        jsxParseElementAt(t, e) {\n          const s = this.startNodeAt(t, e),\n                i = [],\n                r = this.jsxParseOpeningElementAt(t, e);\n          let a = null;\n\n          if (!r.selfClosing) {\n            t: for (;;) switch (this.state.type) {\n              case n.jsxTagStart:\n                if (t = this.state.start, e = this.state.startLoc, this.next(), this.eat(n.slash)) {\n                  a = this.jsxParseClosingElementAt(t, e);\n                  break t;\n                }\n\n                i.push(this.jsxParseElementAt(t, e));\n                break;\n\n              case n.jsxText:\n                i.push(this.parseExprAtom());\n                break;\n\n              case n.braceL:\n                {\n                  const t = this.startNode();\n                  this.next(), this.match(n.ellipsis) ? i.push(this.jsxParseSpreadChild(t)) : i.push(this.jsxParseExpressionContainer(t));\n                  break;\n                }\n\n              default:\n                throw this.unexpected();\n            }\n\n            X(r) && !X(a) ? this.raise(a.start, J.MissingClosingTagFragment) : !X(r) && X(a) ? this.raise(a.start, J.MissingClosingTagElement, G(r.name)) : X(r) || X(a) || G(a.name) !== G(r.name) && this.raise(a.start, J.MissingClosingTagElement, G(r.name));\n          }\n\n          if (X(r) ? (s.openingFragment = r, s.closingFragment = a) : (s.openingElement = r, s.closingElement = a), s.children = i, this.isRelational(\"<\")) throw this.raise(this.state.start, J.UnwrappedAdjacentJSXElements);\n          return X(r) ? this.finishNode(s, \"JSXFragment\") : this.finishNode(s, \"JSXElement\");\n        }\n\n        jsxParseElement() {\n          const t = this.state.start,\n                e = this.state.startLoc;\n          return this.next(), this.jsxParseElementAt(t, e);\n        }\n\n        parseExprAtom(t) {\n          return this.match(n.jsxText) ? this.parseLiteral(this.state.value, \"JSXText\") : this.match(n.jsxTagStart) ? this.jsxParseElement() : this.isRelational(\"<\") && 33 !== this.input.charCodeAt(this.state.pos) ? (this.finishToken(n.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(t);\n        }\n\n        getTokenFromCode(t) {\n          if (this.state.inPropertyName) return super.getTokenFromCode(t);\n          const e = this.curContext();\n          if (e === x.j_expr) return this.jsxReadToken();\n\n          if (e === x.j_oTag || e === x.j_cTag) {\n            if (w(t)) return this.jsxReadWord();\n            if (62 === t) return ++this.state.pos, this.finishToken(n.jsxTagEnd);\n            if ((34 === t || 39 === t) && e === x.j_oTag) return this.jsxReadString(t);\n          }\n\n          return 60 === t && this.state.exprAllowed && 33 !== this.input.charCodeAt(this.state.pos + 1) ? (++this.state.pos, this.finishToken(n.jsxTagStart)) : super.getTokenFromCode(t);\n        }\n\n        updateContext(t) {\n          if (this.match(n.braceL)) {\n            const e = this.curContext();\n            e === x.j_oTag ? this.state.context.push(x.braceExpression) : e === x.j_expr ? this.state.context.push(x.templateQuasi) : super.updateContext(t), this.state.exprAllowed = !0;\n          } else {\n            if (!this.match(n.slash) || t !== n.jsxTagStart) return super.updateContext(t);\n            this.state.context.length -= 2, this.state.context.push(x.j_cTag), this.state.exprAllowed = !1;\n          }\n        }\n\n      },\n      flow: t => class extends t {\n        constructor(t, e) {\n          super(t, e), this.flowPragma = void 0;\n        }\n\n        shouldParseTypes() {\n          return this.getPluginOption(\"flow\", \"all\") || \"flow\" === this.flowPragma;\n        }\n\n        shouldParseEnums() {\n          return !!this.getPluginOption(\"flow\", \"enums\");\n        }\n\n        finishToken(t, e) {\n          return t !== n.string && t !== n.semi && t !== n.interpreterDirective && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(t, e);\n        }\n\n        addComment(t) {\n          if (void 0 === this.flowPragma) {\n            const e = z.exec(t.value);\n            if (e) {\n              if (\"flow\" === e[1]) this.flowPragma = \"flow\";else {\n                if (\"noflow\" !== e[1]) throw new Error(\"Unexpected flow pragma\");\n                this.flowPragma = \"noflow\";\n              }\n            } else ;\n          }\n\n          return super.addComment(t);\n        }\n\n        flowParseTypeInitialiser(t) {\n          const e = this.state.inType;\n          this.state.inType = !0, this.expect(t || n.colon);\n          const s = this.flowParseType();\n          return this.state.inType = e, s;\n        }\n\n        flowParsePredicate() {\n          const t = this.startNode(),\n                e = this.state.startLoc,\n                s = this.state.start;\n          this.expect(n.modulo);\n          const i = this.state.startLoc;\n          return this.expectContextual(\"checks\"), e.line === i.line && e.column === i.column - 1 || this.raise(s, j.UnexpectedSpaceBetweenModuloChecks), this.eat(n.parenL) ? (t.value = this.parseExpression(), this.expect(n.parenR), this.finishNode(t, \"DeclaredPredicate\")) : this.finishNode(t, \"InferredPredicate\");\n        }\n\n        flowParseTypeAndPredicateInitialiser() {\n          const t = this.state.inType;\n          this.state.inType = !0, this.expect(n.colon);\n          let e = null,\n              s = null;\n          return this.match(n.modulo) ? (this.state.inType = t, s = this.flowParsePredicate()) : (e = this.flowParseType(), this.state.inType = t, this.match(n.modulo) && (s = this.flowParsePredicate())), [e, s];\n        }\n\n        flowParseDeclareClass(t) {\n          return this.next(), this.flowParseInterfaceish(t, !0), this.finishNode(t, \"DeclareClass\");\n        }\n\n        flowParseDeclareFunction(t) {\n          this.next();\n          const e = t.id = this.parseIdentifier(),\n                s = this.startNode(),\n                i = this.startNode();\n          this.isRelational(\"<\") ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, this.expect(n.parenL);\n          const r = this.flowParseFunctionTypeParams();\n          return s.params = r.params, s.rest = r.rest, this.expect(n.parenR), [s.returnType, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), i.typeAnnotation = this.finishNode(s, \"FunctionTypeAnnotation\"), e.typeAnnotation = this.finishNode(i, \"TypeAnnotation\"), this.resetEndLocation(e), this.semicolon(), this.finishNode(t, \"DeclareFunction\");\n        }\n\n        flowParseDeclare(t, e) {\n          if (this.match(n._class)) return this.flowParseDeclareClass(t);\n          if (this.match(n._function)) return this.flowParseDeclareFunction(t);\n          if (this.match(n._var)) return this.flowParseDeclareVariable(t);\n          if (this.eatContextual(\"module\")) return this.match(n.dot) ? this.flowParseDeclareModuleExports(t) : (e && this.raise(this.state.lastTokStart, j.NestedDeclareModule), this.flowParseDeclareModule(t));\n          if (this.isContextual(\"type\")) return this.flowParseDeclareTypeAlias(t);\n          if (this.isContextual(\"opaque\")) return this.flowParseDeclareOpaqueType(t);\n          if (this.isContextual(\"interface\")) return this.flowParseDeclareInterface(t);\n          if (this.match(n._export)) return this.flowParseDeclareExportDeclaration(t, e);\n          throw this.unexpected();\n        }\n\n        flowParseDeclareVariable(t) {\n          return this.next(), t.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(t.id.name, 5, t.id.start), this.semicolon(), this.finishNode(t, \"DeclareVariable\");\n        }\n\n        flowParseDeclareModule(t) {\n          this.scope.enter(0), this.match(n.string) ? t.id = this.parseExprAtom() : t.id = this.parseIdentifier();\n          const e = t.body = this.startNode(),\n                s = e.body = [];\n\n          for (this.expect(n.braceL); !this.match(n.braceR);) {\n            let t = this.startNode();\n            this.match(n._import) ? (this.next(), this.isContextual(\"type\") || this.match(n._typeof) || this.raise(this.state.lastTokStart, j.InvalidNonTypeImportInDeclareModule), this.parseImport(t)) : (this.expectContextual(\"declare\", j.UnsupportedStatementInDeclareModule), t = this.flowParseDeclare(t, !0)), s.push(t);\n          }\n\n          this.scope.exit(), this.expect(n.braceR), this.finishNode(e, \"BlockStatement\");\n          let i = null,\n              r = !1;\n          return s.forEach(t => {\n            !function (t) {\n              return \"DeclareExportAllDeclaration\" === t.type || \"DeclareExportDeclaration\" === t.type && (!t.declaration || \"TypeAlias\" !== t.declaration.type && \"InterfaceDeclaration\" !== t.declaration.type);\n            }(t) ? \"DeclareModuleExports\" === t.type && (r && this.raise(t.start, j.DuplicateDeclareModuleExports), \"ES\" === i && this.raise(t.start, j.AmbiguousDeclareModuleKind), i = \"CommonJS\", r = !0) : (\"CommonJS\" === i && this.raise(t.start, j.AmbiguousDeclareModuleKind), i = \"ES\");\n          }), t.kind = i || \"CommonJS\", this.finishNode(t, \"DeclareModule\");\n        }\n\n        flowParseDeclareExportDeclaration(t, e) {\n          if (this.expect(n._export), this.eat(n._default)) return this.match(n._function) || this.match(n._class) ? t.declaration = this.flowParseDeclare(this.startNode()) : (t.declaration = this.flowParseType(), this.semicolon()), t.default = !0, this.finishNode(t, \"DeclareExportDeclaration\");\n\n          if (this.match(n._const) || this.isLet() || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !e) {\n            const t = this.state.value,\n                  e = V[t];\n            throw this.raise(this.state.start, j.UnsupportedDeclareExportKind, t, e);\n          }\n\n          if (this.match(n._var) || this.match(n._function) || this.match(n._class) || this.isContextual(\"opaque\")) return t.declaration = this.flowParseDeclare(this.startNode()), t.default = !1, this.finishNode(t, \"DeclareExportDeclaration\");\n          if (this.match(n.star) || this.match(n.braceL) || this.isContextual(\"interface\") || this.isContextual(\"type\") || this.isContextual(\"opaque\")) return \"ExportNamedDeclaration\" === (t = this.parseExport(t)).type && (t.type = \"ExportDeclaration\", t.default = !1, delete t.exportKind), t.type = \"Declare\" + t.type, t;\n          throw this.unexpected();\n        }\n\n        flowParseDeclareModuleExports(t) {\n          return this.next(), this.expectContextual(\"exports\"), t.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t, \"DeclareModuleExports\");\n        }\n\n        flowParseDeclareTypeAlias(t) {\n          return this.next(), this.flowParseTypeAlias(t), t.type = \"DeclareTypeAlias\", t;\n        }\n\n        flowParseDeclareOpaqueType(t) {\n          return this.next(), this.flowParseOpaqueType(t, !0), t.type = \"DeclareOpaqueType\", t;\n        }\n\n        flowParseDeclareInterface(t) {\n          return this.next(), this.flowParseInterfaceish(t), this.finishNode(t, \"DeclareInterface\");\n        }\n\n        flowParseInterfaceish(t) {\n          let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n          if (t.id = this.flowParseRestrictedIdentifier(!e, !0), this.scope.declareName(t.id.name, e ? 17 : 9, t.id.start), this.isRelational(\"<\") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.extends = [], t.implements = [], t.mixins = [], this.eat(n._extends)) do {\n            t.extends.push(this.flowParseInterfaceExtends());\n          } while (!e && this.eat(n.comma));\n\n          if (this.isContextual(\"mixins\")) {\n            this.next();\n\n            do {\n              t.mixins.push(this.flowParseInterfaceExtends());\n            } while (this.eat(n.comma));\n          }\n\n          if (this.isContextual(\"implements\")) {\n            this.next();\n\n            do {\n              t.implements.push(this.flowParseInterfaceExtends());\n            } while (this.eat(n.comma));\n          }\n\n          t.body = this.flowParseObjectType({\n            allowStatic: e,\n            allowExact: !1,\n            allowSpread: !1,\n            allowProto: e,\n            allowInexact: !1\n          });\n        }\n\n        flowParseInterfaceExtends() {\n          const t = this.startNode();\n          return t.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational(\"<\") ? t.typeParameters = this.flowParseTypeParameterInstantiation() : t.typeParameters = null, this.finishNode(t, \"InterfaceExtends\");\n        }\n\n        flowParseInterface(t) {\n          return this.flowParseInterfaceish(t), this.finishNode(t, \"InterfaceDeclaration\");\n        }\n\n        checkNotUnderscore(t) {\n          \"_\" === t && this.raise(this.state.start, j.UnexpectedReservedUnderscore);\n        }\n\n        checkReservedType(t, e, s) {\n          _.has(t) && this.raise(e, s ? j.AssignReservedType : j.UnexpectedReservedType, t);\n        }\n\n        flowParseRestrictedIdentifier(t, e) {\n          return this.checkReservedType(this.state.value, this.state.start, e), this.parseIdentifier(t);\n        }\n\n        flowParseTypeAlias(t) {\n          return t.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(t.id.name, 9, t.id.start), this.isRelational(\"<\") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.right = this.flowParseTypeInitialiser(n.eq), this.semicolon(), this.finishNode(t, \"TypeAlias\");\n        }\n\n        flowParseOpaqueType(t, e) {\n          return this.expectContextual(\"type\"), t.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(t.id.name, 9, t.id.start), this.isRelational(\"<\") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.supertype = null, this.match(n.colon) && (t.supertype = this.flowParseTypeInitialiser(n.colon)), t.impltype = null, e || (t.impltype = this.flowParseTypeInitialiser(n.eq)), this.semicolon(), this.finishNode(t, \"OpaqueType\");\n        }\n\n        flowParseTypeParameter() {\n          let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n          const e = this.state.start,\n                s = this.startNode(),\n                i = this.flowParseVariance(),\n                r = this.flowParseTypeAnnotatableIdentifier();\n          return s.name = r.name, s.variance = i, s.bound = r.typeAnnotation, this.match(n.eq) ? (this.eat(n.eq), s.default = this.flowParseType()) : t && this.raise(e, j.MissingTypeParamDefault), this.finishNode(s, \"TypeParameter\");\n        }\n\n        flowParseTypeParameterDeclaration() {\n          const t = this.state.inType,\n                e = this.startNode();\n          e.params = [], this.state.inType = !0, this.isRelational(\"<\") || this.match(n.jsxTagStart) ? this.next() : this.unexpected();\n          let s = !1;\n\n          do {\n            const t = this.flowParseTypeParameter(s);\n            e.params.push(t), t.default && (s = !0), this.isRelational(\">\") || this.expect(n.comma);\n          } while (!this.isRelational(\">\"));\n\n          return this.expectRelational(\">\"), this.state.inType = t, this.finishNode(e, \"TypeParameterDeclaration\");\n        }\n\n        flowParseTypeParameterInstantiation() {\n          const t = this.startNode(),\n                e = this.state.inType;\n          t.params = [], this.state.inType = !0, this.expectRelational(\"<\");\n          const s = this.state.noAnonFunctionType;\n\n          for (this.state.noAnonFunctionType = !1; !this.isRelational(\">\");) t.params.push(this.flowParseType()), this.isRelational(\">\") || this.expect(n.comma);\n\n          return this.state.noAnonFunctionType = s, this.expectRelational(\">\"), this.state.inType = e, this.finishNode(t, \"TypeParameterInstantiation\");\n        }\n\n        flowParseTypeParameterInstantiationCallOrNew() {\n          const t = this.startNode(),\n                e = this.state.inType;\n\n          for (t.params = [], this.state.inType = !0, this.expectRelational(\"<\"); !this.isRelational(\">\");) t.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(\">\") || this.expect(n.comma);\n\n          return this.expectRelational(\">\"), this.state.inType = e, this.finishNode(t, \"TypeParameterInstantiation\");\n        }\n\n        flowParseInterfaceType() {\n          const t = this.startNode();\n          if (this.expectContextual(\"interface\"), t.extends = [], this.eat(n._extends)) do {\n            t.extends.push(this.flowParseInterfaceExtends());\n          } while (this.eat(n.comma));\n          return t.body = this.flowParseObjectType({\n            allowStatic: !1,\n            allowExact: !1,\n            allowSpread: !1,\n            allowProto: !1,\n            allowInexact: !1\n          }), this.finishNode(t, \"InterfaceTypeAnnotation\");\n        }\n\n        flowParseObjectPropertyKey() {\n          return this.match(n.num) || this.match(n.string) ? this.parseExprAtom() : this.parseIdentifier(!0);\n        }\n\n        flowParseObjectTypeIndexer(t, e, s) {\n          return t.static = e, this.lookahead().type === n.colon ? (t.id = this.flowParseObjectPropertyKey(), t.key = this.flowParseTypeInitialiser()) : (t.id = null, t.key = this.flowParseType()), this.expect(n.bracketR), t.value = this.flowParseTypeInitialiser(), t.variance = s, this.finishNode(t, \"ObjectTypeIndexer\");\n        }\n\n        flowParseObjectTypeInternalSlot(t, e) {\n          return t.static = e, t.id = this.flowParseObjectPropertyKey(), this.expect(n.bracketR), this.expect(n.bracketR), this.isRelational(\"<\") || this.match(n.parenL) ? (t.method = !0, t.optional = !1, t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start))) : (t.method = !1, this.eat(n.question) && (t.optional = !0), t.value = this.flowParseTypeInitialiser()), this.finishNode(t, \"ObjectTypeInternalSlot\");\n        }\n\n        flowParseObjectTypeMethodish(t) {\n          for (t.params = [], t.rest = null, t.typeParameters = null, this.isRelational(\"<\") && (t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(n.parenL); !this.match(n.parenR) && !this.match(n.ellipsis);) t.params.push(this.flowParseFunctionTypeParam()), this.match(n.parenR) || this.expect(n.comma);\n\n          return this.eat(n.ellipsis) && (t.rest = this.flowParseFunctionTypeParam()), this.expect(n.parenR), t.returnType = this.flowParseTypeInitialiser(), this.finishNode(t, \"FunctionTypeAnnotation\");\n        }\n\n        flowParseObjectTypeCallProperty(t, e) {\n          const s = this.startNode();\n          return t.static = e, t.value = this.flowParseObjectTypeMethodish(s), this.finishNode(t, \"ObjectTypeCallProperty\");\n        }\n\n        flowParseObjectType(_ref3) {\n          let {\n            allowStatic: t,\n            allowExact: e,\n            allowSpread: s,\n            allowProto: i,\n            allowInexact: r\n          } = _ref3;\n          const a = this.state.inType;\n          this.state.inType = !0;\n          const o = this.startNode();\n          let h, p;\n          o.callProperties = [], o.properties = [], o.indexers = [], o.internalSlots = [];\n          let c = !1;\n\n          for (e && this.match(n.braceBarL) ? (this.expect(n.braceBarL), h = n.braceBarR, p = !0) : (this.expect(n.braceL), h = n.braceR, p = !1), o.exact = p; !this.match(h);) {\n            let e = !1,\n                a = null,\n                h = null;\n            const u = this.startNode();\n\n            if (i && this.isContextual(\"proto\")) {\n              const e = this.lookahead();\n              e.type !== n.colon && e.type !== n.question && (this.next(), a = this.state.start, t = !1);\n            }\n\n            if (t && this.isContextual(\"static\")) {\n              const t = this.lookahead();\n              t.type !== n.colon && t.type !== n.question && (this.next(), e = !0);\n            }\n\n            const l = this.flowParseVariance();\n            if (this.eat(n.bracketL)) null != a && this.unexpected(a), this.eat(n.bracketL) ? (l && this.unexpected(l.start), o.internalSlots.push(this.flowParseObjectTypeInternalSlot(u, e))) : o.indexers.push(this.flowParseObjectTypeIndexer(u, e, l));else if (this.match(n.parenL) || this.isRelational(\"<\")) null != a && this.unexpected(a), l && this.unexpected(l.start), o.callProperties.push(this.flowParseObjectTypeCallProperty(u, e));else {\n              let t = \"init\";\n\n              if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n                const e = this.lookahead();\n                e.type !== n.name && e.type !== n.string && e.type !== n.num || (t = this.state.value, this.next());\n              }\n\n              const i = this.flowParseObjectTypeProperty(u, e, a, l, t, s, null != r ? r : !p);\n              null === i ? (c = !0, h = this.state.lastTokStart) : o.properties.push(i);\n            }\n            this.flowObjectTypeSemicolon(), !h || this.match(n.braceR) || this.match(n.braceBarR) || this.raise(h, j.UnexpectedExplicitInexactInObject);\n          }\n\n          this.expect(h), s && (o.inexact = c);\n          const u = this.finishNode(o, \"ObjectTypeAnnotation\");\n          return this.state.inType = a, u;\n        }\n\n        flowParseObjectTypeProperty(t, e, s, i, r, a, o) {\n          if (this.eat(n.ellipsis)) {\n            return this.match(n.comma) || this.match(n.semi) || this.match(n.braceR) || this.match(n.braceBarR) ? (a ? o || this.raise(this.state.lastTokStart, j.InexactInsideExact) : this.raise(this.state.lastTokStart, j.InexactInsideNonObject), i && this.raise(i.start, j.InexactVariance), null) : (a || this.raise(this.state.lastTokStart, j.UnexpectedSpreadType), null != s && this.unexpected(s), i && this.raise(i.start, j.SpreadVariance), t.argument = this.flowParseType(), this.finishNode(t, \"ObjectTypeSpreadProperty\"));\n          }\n\n          {\n            t.key = this.flowParseObjectPropertyKey(), t.static = e, t.proto = null != s, t.kind = r;\n            let a = !1;\n            return this.isRelational(\"<\") || this.match(n.parenL) ? (t.method = !0, null != s && this.unexpected(s), i && this.unexpected(i.start), t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start)), \"get\" !== r && \"set\" !== r || this.flowCheckGetterSetterParams(t)) : (\"init\" !== r && this.unexpected(), t.method = !1, this.eat(n.question) && (a = !0), t.value = this.flowParseTypeInitialiser(), t.variance = i), t.optional = a, this.finishNode(t, \"ObjectTypeProperty\");\n          }\n        }\n\n        flowCheckGetterSetterParams(t) {\n          const e = \"get\" === t.kind ? 0 : 1,\n                s = t.start;\n          t.value.params.length + (t.value.rest ? 1 : 0) !== e && (\"get\" === t.kind ? this.raise(s, f.BadGetterArity) : this.raise(s, f.BadSetterArity)), \"set\" === t.kind && t.value.rest && this.raise(s, f.BadSetterRestParameter);\n        }\n\n        flowObjectTypeSemicolon() {\n          this.eat(n.semi) || this.eat(n.comma) || this.match(n.braceR) || this.match(n.braceBarR) || this.unexpected();\n        }\n\n        flowParseQualifiedTypeIdentifier(t, e, s) {\n          t = t || this.state.start, e = e || this.state.startLoc;\n          let i = s || this.flowParseRestrictedIdentifier(!0);\n\n          for (; this.eat(n.dot);) {\n            const s = this.startNodeAt(t, e);\n            s.qualification = i, s.id = this.flowParseRestrictedIdentifier(!0), i = this.finishNode(s, \"QualifiedTypeIdentifier\");\n          }\n\n          return i;\n        }\n\n        flowParseGenericType(t, e, s) {\n          const i = this.startNodeAt(t, e);\n          return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(t, e, s), this.isRelational(\"<\") && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, \"GenericTypeAnnotation\");\n        }\n\n        flowParseTypeofType() {\n          const t = this.startNode();\n          return this.expect(n._typeof), t.argument = this.flowParsePrimaryType(), this.finishNode(t, \"TypeofTypeAnnotation\");\n        }\n\n        flowParseTupleType() {\n          const t = this.startNode();\n\n          for (t.types = [], this.expect(n.bracketL); this.state.pos < this.length && !this.match(n.bracketR) && (t.types.push(this.flowParseType()), !this.match(n.bracketR));) this.expect(n.comma);\n\n          return this.expect(n.bracketR), this.finishNode(t, \"TupleTypeAnnotation\");\n        }\n\n        flowParseFunctionTypeParam() {\n          let t = null,\n              e = !1,\n              s = null;\n          const i = this.startNode(),\n                r = this.lookahead();\n          return r.type === n.colon || r.type === n.question ? (t = this.parseIdentifier(), this.eat(n.question) && (e = !0), s = this.flowParseTypeInitialiser()) : s = this.flowParseType(), i.name = t, i.optional = e, i.typeAnnotation = s, this.finishNode(i, \"FunctionTypeParam\");\n        }\n\n        reinterpretTypeAsFunctionTypeParam(t) {\n          const e = this.startNodeAt(t.start, t.loc.start);\n          return e.name = null, e.optional = !1, e.typeAnnotation = t, this.finishNode(e, \"FunctionTypeParam\");\n        }\n\n        flowParseFunctionTypeParams() {\n          let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n          let e = null;\n\n          for (; !this.match(n.parenR) && !this.match(n.ellipsis);) t.push(this.flowParseFunctionTypeParam()), this.match(n.parenR) || this.expect(n.comma);\n\n          return this.eat(n.ellipsis) && (e = this.flowParseFunctionTypeParam()), {\n            params: t,\n            rest: e\n          };\n        }\n\n        flowIdentToTypeAnnotation(t, e, s, i) {\n          switch (i.name) {\n            case \"any\":\n              return this.finishNode(s, \"AnyTypeAnnotation\");\n\n            case \"bool\":\n            case \"boolean\":\n              return this.finishNode(s, \"BooleanTypeAnnotation\");\n\n            case \"mixed\":\n              return this.finishNode(s, \"MixedTypeAnnotation\");\n\n            case \"empty\":\n              return this.finishNode(s, \"EmptyTypeAnnotation\");\n\n            case \"number\":\n              return this.finishNode(s, \"NumberTypeAnnotation\");\n\n            case \"string\":\n              return this.finishNode(s, \"StringTypeAnnotation\");\n\n            case \"symbol\":\n              return this.finishNode(s, \"SymbolTypeAnnotation\");\n\n            default:\n              return this.checkNotUnderscore(i.name), this.flowParseGenericType(t, e, i);\n          }\n        }\n\n        flowParsePrimaryType() {\n          const t = this.state.start,\n                e = this.state.startLoc,\n                s = this.startNode();\n          let i,\n              r,\n              a = !1;\n          const o = this.state.noAnonFunctionType;\n\n          switch (this.state.type) {\n            case n.name:\n              return this.isContextual(\"interface\") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(t, e, s, this.parseIdentifier());\n\n            case n.braceL:\n              return this.flowParseObjectType({\n                allowStatic: !1,\n                allowExact: !1,\n                allowSpread: !0,\n                allowProto: !1,\n                allowInexact: !0\n              });\n\n            case n.braceBarL:\n              return this.flowParseObjectType({\n                allowStatic: !1,\n                allowExact: !0,\n                allowSpread: !0,\n                allowProto: !1,\n                allowInexact: !1\n              });\n\n            case n.bracketL:\n              return this.state.noAnonFunctionType = !1, r = this.flowParseTupleType(), this.state.noAnonFunctionType = o, r;\n\n            case n.relational:\n              if (\"<\" === this.state.value) return s.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(n.parenL), i = this.flowParseFunctionTypeParams(), s.params = i.params, s.rest = i.rest, this.expect(n.parenR), this.expect(n.arrow), s.returnType = this.flowParseType(), this.finishNode(s, \"FunctionTypeAnnotation\");\n              break;\n\n            case n.parenL:\n              if (this.next(), !this.match(n.parenR) && !this.match(n.ellipsis)) if (this.match(n.name)) {\n                const t = this.lookahead().type;\n                a = t !== n.question && t !== n.colon;\n              } else a = !0;\n\n              if (a) {\n                if (this.state.noAnonFunctionType = !1, r = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(n.comma) || this.match(n.parenR) && this.lookahead().type === n.arrow)) return this.expect(n.parenR), r;\n                this.eat(n.comma);\n              }\n\n              return i = r ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r)]) : this.flowParseFunctionTypeParams(), s.params = i.params, s.rest = i.rest, this.expect(n.parenR), this.expect(n.arrow), s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, \"FunctionTypeAnnotation\");\n\n            case n.string:\n              return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n            case n._true:\n            case n._false:\n              return s.value = this.match(n._true), this.next(), this.finishNode(s, \"BooleanLiteralTypeAnnotation\");\n\n            case n.plusMin:\n              if (\"-\" === this.state.value) {\n                if (this.next(), this.match(n.num)) return this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", s.start, s.loc.start);\n                if (this.match(n.bigint)) return this.parseLiteral(-this.state.value, \"BigIntLiteralTypeAnnotation\", s.start, s.loc.start);\n                throw this.raise(this.state.start, j.UnexpectedSubtractionOperand);\n              }\n\n              throw this.unexpected();\n\n            case n.num:\n              return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n            case n.bigint:\n              return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n            case n._void:\n              return this.next(), this.finishNode(s, \"VoidTypeAnnotation\");\n\n            case n._null:\n              return this.next(), this.finishNode(s, \"NullLiteralTypeAnnotation\");\n\n            case n._this:\n              return this.next(), this.finishNode(s, \"ThisTypeAnnotation\");\n\n            case n.star:\n              return this.next(), this.finishNode(s, \"ExistsTypeAnnotation\");\n\n            default:\n              if (\"typeof\" === this.state.type.keyword) return this.flowParseTypeofType();\n\n              if (this.state.type.keyword) {\n                const t = this.state.type.label;\n                return this.next(), super.createIdentifier(s, t);\n              }\n\n          }\n\n          throw this.unexpected();\n        }\n\n        flowParsePostfixType() {\n          const t = this.state.start,\n                e = this.state.startLoc;\n          let s = this.flowParsePrimaryType();\n\n          for (; this.match(n.bracketL) && !this.canInsertSemicolon();) {\n            const i = this.startNodeAt(t, e);\n            i.elementType = s, this.expect(n.bracketL), this.expect(n.bracketR), s = this.finishNode(i, \"ArrayTypeAnnotation\");\n          }\n\n          return s;\n        }\n\n        flowParsePrefixType() {\n          const t = this.startNode();\n          return this.eat(n.question) ? (t.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t, \"NullableTypeAnnotation\")) : this.flowParsePostfixType();\n        }\n\n        flowParseAnonFunctionWithoutParens() {\n          const t = this.flowParsePrefixType();\n\n          if (!this.state.noAnonFunctionType && this.eat(n.arrow)) {\n            const e = this.startNodeAt(t.start, t.loc.start);\n            return e.params = [this.reinterpretTypeAsFunctionTypeParam(t)], e.rest = null, e.returnType = this.flowParseType(), e.typeParameters = null, this.finishNode(e, \"FunctionTypeAnnotation\");\n          }\n\n          return t;\n        }\n\n        flowParseIntersectionType() {\n          const t = this.startNode();\n          this.eat(n.bitwiseAND);\n          const e = this.flowParseAnonFunctionWithoutParens();\n\n          for (t.types = [e]; this.eat(n.bitwiseAND);) t.types.push(this.flowParseAnonFunctionWithoutParens());\n\n          return 1 === t.types.length ? e : this.finishNode(t, \"IntersectionTypeAnnotation\");\n        }\n\n        flowParseUnionType() {\n          const t = this.startNode();\n          this.eat(n.bitwiseOR);\n          const e = this.flowParseIntersectionType();\n\n          for (t.types = [e]; this.eat(n.bitwiseOR);) t.types.push(this.flowParseIntersectionType());\n\n          return 1 === t.types.length ? e : this.finishNode(t, \"UnionTypeAnnotation\");\n        }\n\n        flowParseType() {\n          const t = this.state.inType;\n          this.state.inType = !0;\n          const e = this.flowParseUnionType();\n          return this.state.inType = t, this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType, e;\n        }\n\n        flowParseTypeOrImplicitInstantiation() {\n          if (this.state.type === n.name && \"_\" === this.state.value) {\n            const t = this.state.start,\n                  e = this.state.startLoc,\n                  s = this.parseIdentifier();\n            return this.flowParseGenericType(t, e, s);\n          }\n\n          return this.flowParseType();\n        }\n\n        flowParseTypeAnnotation() {\n          const t = this.startNode();\n          return t.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t, \"TypeAnnotation\");\n        }\n\n        flowParseTypeAnnotatableIdentifier(t) {\n          const e = t ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n          return this.match(n.colon) && (e.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e)), e;\n        }\n\n        typeCastToParameter(t) {\n          return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end), t.expression;\n        }\n\n        flowParseVariance() {\n          let t = null;\n          return this.match(n.plusMin) && (t = this.startNode(), \"+\" === this.state.value ? t.kind = \"plus\" : t.kind = \"minus\", this.next(), this.finishNode(t, \"Variance\")), t;\n        }\n\n        parseFunctionBody(t, e) {\n          let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n          return e ? this.forwardNoArrowParamsConversionAt(t, () => super.parseFunctionBody(t, !0, s)) : super.parseFunctionBody(t, !1, s);\n        }\n\n        parseFunctionBodyAndFinish(t, e) {\n          let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n\n          if (this.match(n.colon)) {\n            const e = this.startNode();\n            [e.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), t.returnType = e.typeAnnotation ? this.finishNode(e, \"TypeAnnotation\") : null;\n          }\n\n          super.parseFunctionBodyAndFinish(t, e, s);\n        }\n\n        parseStatement(t, e) {\n          if (this.state.strict && this.match(n.name) && \"interface\" === this.state.value) {\n            const t = this.startNode();\n            return this.next(), this.flowParseInterface(t);\n          }\n\n          if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n            const t = this.startNode();\n            return this.next(), this.flowParseEnumDeclaration(t);\n          }\n\n          {\n            const s = super.parseStatement(t, e);\n            return void 0 !== this.flowPragma || this.isValidDirective(s) || (this.flowPragma = null), s;\n          }\n        }\n\n        parseExpressionStatement(t, e) {\n          if (\"Identifier\" === e.type) if (\"declare\" === e.name) {\n            if (this.match(n._class) || this.match(n.name) || this.match(n._function) || this.match(n._var) || this.match(n._export)) return this.flowParseDeclare(t);\n          } else if (this.match(n.name)) {\n            if (\"interface\" === e.name) return this.flowParseInterface(t);\n            if (\"type\" === e.name) return this.flowParseTypeAlias(t);\n            if (\"opaque\" === e.name) return this.flowParseOpaqueType(t, !1);\n          }\n          return super.parseExpressionStatement(t, e);\n        }\n\n        shouldParseExportDeclaration() {\n          return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || this.shouldParseEnums() && this.isContextual(\"enum\") || super.shouldParseExportDeclaration();\n        }\n\n        isExportDefaultSpecifier() {\n          return (!this.match(n.name) || !(\"type\" === this.state.value || \"interface\" === this.state.value || \"opaque\" === this.state.value || this.shouldParseEnums() && \"enum\" === this.state.value)) && super.isExportDefaultSpecifier();\n        }\n\n        parseExportDefaultExpression() {\n          if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n            const t = this.startNode();\n            return this.next(), this.flowParseEnumDeclaration(t);\n          }\n\n          return super.parseExportDefaultExpression();\n        }\n\n        parseConditional(t, e, s, i, r) {\n          if (!this.match(n.question)) return t;\n\n          if (r) {\n            const a = this.tryParse(() => super.parseConditional(t, e, s, i));\n            return a.node ? (a.error && (this.state = a.failState), a.node) : (r.start = a.error.pos || this.state.start, t);\n          }\n\n          this.expect(n.question);\n          const a = this.state.clone(),\n                o = this.state.noArrowAt,\n                h = this.startNodeAt(s, i);\n          let {\n            consequent: p,\n            failed: c\n          } = this.tryParseConditionalConsequent(),\n              [u, l] = this.getArrowLikeExpressions(p);\n\n          if (c || l.length > 0) {\n            const t = [...o];\n\n            if (l.length > 0) {\n              this.state = a, this.state.noArrowAt = t;\n\n              for (let e = 0; e < l.length; e++) t.push(l[e].start);\n\n              ({\n                consequent: p,\n                failed: c\n              } = this.tryParseConditionalConsequent()), [u, l] = this.getArrowLikeExpressions(p);\n            }\n\n            c && u.length > 1 && this.raise(a.start, j.AmbiguousConditionalArrow), c && 1 === u.length && (this.state = a, this.state.noArrowAt = t.concat(u[0].start), ({\n              consequent: p,\n              failed: c\n            } = this.tryParseConditionalConsequent()));\n          }\n\n          return this.getArrowLikeExpressions(p, !0), this.state.noArrowAt = o, this.expect(n.colon), h.test = t, h.consequent = p, h.alternate = this.forwardNoArrowParamsConversionAt(h, () => this.parseMaybeAssign(e, void 0, void 0, void 0)), this.finishNode(h, \"ConditionalExpression\");\n        }\n\n        tryParseConditionalConsequent() {\n          this.state.noArrowParamsConversionAt.push(this.state.start);\n          const t = this.parseMaybeAssign(),\n                e = !this.match(n.colon);\n          return this.state.noArrowParamsConversionAt.pop(), {\n            consequent: t,\n            failed: e\n          };\n        }\n\n        getArrowLikeExpressions(t, e) {\n          const s = [t],\n                i = [];\n\n          for (; 0 !== s.length;) {\n            const t = s.pop();\n            \"ArrowFunctionExpression\" === t.type ? (t.typeParameters || !t.returnType ? this.finishArrowValidation(t) : i.push(t), s.push(t.body)) : \"ConditionalExpression\" === t.type && (s.push(t.consequent), s.push(t.alternate));\n          }\n\n          return e ? (i.forEach(t => this.finishArrowValidation(t)), [i, []]) : function (t, e) {\n            const s = [],\n                  i = [];\n\n            for (let r = 0; r < t.length; r++) (e(t[r], r, t) ? s : i).push(t[r]);\n\n            return [s, i];\n          }(i, t => t.params.every(t => this.isAssignable(t, !0)));\n        }\n\n        finishArrowValidation(t) {\n          var e;\n          this.toAssignableList(t.params, null == (e = t.extra) ? void 0 : e.trailingComma), this.scope.enter(6), super.checkParams(t, !1, !0), this.scope.exit();\n        }\n\n        forwardNoArrowParamsConversionAt(t, e) {\n          let s;\n          return -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), s = e(), this.state.noArrowParamsConversionAt.pop()) : s = e(), s;\n        }\n\n        parseParenItem(t, e, s) {\n          if (t = super.parseParenItem(t, e, s), this.eat(n.question) && (t.optional = !0, this.resetEndLocation(t)), this.match(n.colon)) {\n            const i = this.startNodeAt(e, s);\n            return i.expression = t, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, \"TypeCastExpression\");\n          }\n\n          return t;\n        }\n\n        assertModuleNodeAllowed(t) {\n          \"ImportDeclaration\" === t.type && (\"type\" === t.importKind || \"typeof\" === t.importKind) || \"ExportNamedDeclaration\" === t.type && \"type\" === t.exportKind || \"ExportAllDeclaration\" === t.type && \"type\" === t.exportKind || super.assertModuleNodeAllowed(t);\n        }\n\n        parseExport(t) {\n          const e = super.parseExport(t);\n          return \"ExportNamedDeclaration\" !== e.type && \"ExportAllDeclaration\" !== e.type || (e.exportKind = e.exportKind || \"value\"), e;\n        }\n\n        parseExportDeclaration(t) {\n          if (this.isContextual(\"type\")) {\n            t.exportKind = \"type\";\n            const e = this.startNode();\n            return this.next(), this.match(n.braceL) ? (t.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(t), null) : this.flowParseTypeAlias(e);\n          }\n\n          if (this.isContextual(\"opaque\")) {\n            t.exportKind = \"type\";\n            const e = this.startNode();\n            return this.next(), this.flowParseOpaqueType(e, !1);\n          }\n\n          if (this.isContextual(\"interface\")) {\n            t.exportKind = \"type\";\n            const e = this.startNode();\n            return this.next(), this.flowParseInterface(e);\n          }\n\n          if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n            t.exportKind = \"value\";\n            const e = this.startNode();\n            return this.next(), this.flowParseEnumDeclaration(e);\n          }\n\n          return super.parseExportDeclaration(t);\n        }\n\n        eatExportStar(t) {\n          return !!super.eatExportStar(...arguments) || !(!this.isContextual(\"type\") || this.lookahead().type !== n.star) && (t.exportKind = \"type\", this.next(), this.next(), !0);\n        }\n\n        maybeParseExportNamespaceSpecifier(t) {\n          const e = this.state.start,\n                s = super.maybeParseExportNamespaceSpecifier(t);\n          return s && \"type\" === t.exportKind && this.unexpected(e), s;\n        }\n\n        parseClassId(t, e, s) {\n          super.parseClassId(t, e, s), this.isRelational(\"<\") && (t.typeParameters = this.flowParseTypeParameterDeclaration());\n        }\n\n        parseClassMember(t, e, s, i) {\n          const r = this.state.start;\n\n          if (this.isContextual(\"declare\")) {\n            if (this.parseClassMemberFromModifier(t, e)) return;\n            e.declare = !0;\n          }\n\n          super.parseClassMember(t, e, s, i), e.declare && (\"ClassProperty\" !== e.type && \"ClassPrivateProperty\" !== e.type ? this.raise(r, j.DeclareClassElement) : e.value && this.raise(e.value.start, j.DeclareClassFieldInitializer));\n        }\n\n        getTokenFromCode(t) {\n          const e = this.input.charCodeAt(this.state.pos + 1);\n          return 123 === t && 124 === e ? this.finishOp(n.braceBarL, 2) : !this.state.inType || 62 !== t && 60 !== t ? function (t, e) {\n            return 64 === t && 64 === e;\n          }(t, e) ? (this.state.isIterator = !0, super.readWord()) : super.getTokenFromCode(t) : this.finishOp(n.relational, 1);\n        }\n\n        isAssignable(t, e) {\n          switch (t.type) {\n            case \"Identifier\":\n            case \"ObjectPattern\":\n            case \"ArrayPattern\":\n            case \"AssignmentPattern\":\n              return !0;\n\n            case \"ObjectExpression\":\n              {\n                const e = t.properties.length - 1;\n                return t.properties.every((t, s) => \"ObjectMethod\" !== t.type && (s === e || \"SpreadElement\" === t.type) && this.isAssignable(t));\n              }\n\n            case \"ObjectProperty\":\n              return this.isAssignable(t.value);\n\n            case \"SpreadElement\":\n              return this.isAssignable(t.argument);\n\n            case \"ArrayExpression\":\n              return t.elements.every(t => this.isAssignable(t));\n\n            case \"AssignmentExpression\":\n              return \"=\" === t.operator;\n\n            case \"ParenthesizedExpression\":\n            case \"TypeCastExpression\":\n              return this.isAssignable(t.expression);\n\n            case \"MemberExpression\":\n            case \"OptionalMemberExpression\":\n              return !e;\n\n            default:\n              return !1;\n          }\n        }\n\n        toAssignable(t) {\n          return \"TypeCastExpression\" === t.type ? super.toAssignable(this.typeCastToParameter(t)) : super.toAssignable(t);\n        }\n\n        toAssignableList(t, e) {\n          for (let e = 0; e < t.length; e++) {\n            const s = t[e];\n            s && \"TypeCastExpression\" === s.type && (t[e] = this.typeCastToParameter(s));\n          }\n\n          return super.toAssignableList(t, e);\n        }\n\n        toReferencedList(t, e) {\n          for (let s = 0; s < t.length; s++) {\n            const i = t[s];\n            !i || \"TypeCastExpression\" !== i.type || i.extra && i.extra.parenthesized || !(t.length > 1) && e || this.raise(i.typeAnnotation.start, j.TypeCastInPattern);\n          }\n\n          return t;\n        }\n\n        checkLVal(t) {\n          let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n          let s = arguments.length > 2 ? arguments[2] : undefined;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n          if (\"TypeCastExpression\" !== t.type) return super.checkLVal(t, e, s, i);\n        }\n\n        parseClassProperty(t) {\n          return this.match(n.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(t);\n        }\n\n        parseClassPrivateProperty(t) {\n          return this.match(n.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(t);\n        }\n\n        isClassMethod() {\n          return this.isRelational(\"<\") || super.isClassMethod();\n        }\n\n        isClassProperty() {\n          return this.match(n.colon) || super.isClassProperty();\n        }\n\n        isNonstaticConstructor(t) {\n          return !this.match(n.colon) && super.isNonstaticConstructor(t);\n        }\n\n        pushClassMethod(t, e, s, i, r, a) {\n          e.variance && this.unexpected(e.variance.start), delete e.variance, this.isRelational(\"<\") && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(t, e, s, i, r, a);\n        }\n\n        pushClassPrivateMethod(t, e, s, i) {\n          e.variance && this.unexpected(e.variance.start), delete e.variance, this.isRelational(\"<\") && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(t, e, s, i);\n        }\n\n        parseClassSuper(t) {\n          if (super.parseClassSuper(t), t.superClass && this.isRelational(\"<\") && (t.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(\"implements\")) {\n            this.next();\n            const e = t.implements = [];\n\n            do {\n              const t = this.startNode();\n              t.id = this.flowParseRestrictedIdentifier(!0), this.isRelational(\"<\") ? t.typeParameters = this.flowParseTypeParameterInstantiation() : t.typeParameters = null, e.push(this.finishNode(t, \"ClassImplements\"));\n            } while (this.eat(n.comma));\n          }\n        }\n\n        parsePropertyName(t, e) {\n          const s = this.flowParseVariance(),\n                i = super.parsePropertyName(t, e);\n          return t.variance = s, i;\n        }\n\n        parseObjPropValue(t, e, s, i, r, a, o, h) {\n          let p;\n          t.variance && this.unexpected(t.variance.start), delete t.variance, this.isRelational(\"<\") && (p = this.flowParseTypeParameterDeclaration(), this.match(n.parenL) || this.unexpected()), super.parseObjPropValue(t, e, s, i, r, a, o, h), p && ((t.value || t).typeParameters = p);\n        }\n\n        parseAssignableListItemTypes(t) {\n          return this.eat(n.question) && (\"Identifier\" !== t.type && this.raise(t.start, j.OptionalBindingPattern), t.optional = !0), this.match(n.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t), t;\n        }\n\n        parseMaybeDefault(t, e, s) {\n          const i = super.parseMaybeDefault(t, e, s);\n          return \"AssignmentPattern\" === i.type && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(i.typeAnnotation.start, j.TypeBeforeInitializer), i;\n        }\n\n        shouldParseDefaultImport(t) {\n          return U(t) ? q(this.state) : super.shouldParseDefaultImport(t);\n        }\n\n        parseImportSpecifierLocal(t, e, s, i) {\n          e.local = U(t) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), this.checkLVal(e.local, 9, void 0, i), t.specifiers.push(this.finishNode(e, s));\n        }\n\n        maybeParseDefaultImportSpecifier(t) {\n          t.importKind = \"value\";\n          let e = null;\n\n          if (this.match(n._typeof) ? e = \"typeof\" : this.isContextual(\"type\") && (e = \"type\"), e) {\n            const s = this.lookahead();\n            \"type\" === e && s.type === n.star && this.unexpected(s.start), (q(s) || s.type === n.braceL || s.type === n.star) && (this.next(), t.importKind = e);\n          }\n\n          return super.maybeParseDefaultImportSpecifier(t);\n        }\n\n        parseImportSpecifier(t) {\n          const e = this.startNode(),\n                s = this.state.start,\n                i = this.parseIdentifier(!0);\n          let r = null;\n          \"type\" === i.name ? r = \"type\" : \"typeof\" === i.name && (r = \"typeof\");\n          let a = !1;\n\n          if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n            const t = this.parseIdentifier(!0);\n            null === r || this.match(n.name) || this.state.type.keyword ? (e.imported = i, e.importKind = null, e.local = this.parseIdentifier()) : (e.imported = t, e.importKind = r, e.local = t.__clone());\n          } else null !== r && (this.match(n.name) || this.state.type.keyword) ? (e.imported = this.parseIdentifier(!0), e.importKind = r, this.eatContextual(\"as\") ? e.local = this.parseIdentifier() : (a = !0, e.local = e.imported.__clone())) : (a = !0, e.imported = i, e.importKind = null, e.local = e.imported.__clone());\n\n          const o = U(t),\n                h = U(e);\n          o && h && this.raise(s, j.ImportTypeShorthandOnlyInPureImport), (o || h) && this.checkReservedType(e.local.name, e.local.start, !0), !a || o || h || this.checkReservedWord(e.local.name, e.start, !0, !0), this.checkLVal(e.local, 9, void 0, \"import specifier\"), t.specifiers.push(this.finishNode(e, \"ImportSpecifier\"));\n        }\n\n        parseFunctionParams(t, e) {\n          const s = t.kind;\n          \"get\" !== s && \"set\" !== s && this.isRelational(\"<\") && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(t, e);\n        }\n\n        parseVarId(t, e) {\n          super.parseVarId(t, e), this.match(n.colon) && (t.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t.id));\n        }\n\n        parseAsyncArrowFromCallExpression(t, e) {\n          if (this.match(n.colon)) {\n            const e = this.state.noAnonFunctionType;\n            this.state.noAnonFunctionType = !0, t.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = e;\n          }\n\n          return super.parseAsyncArrowFromCallExpression(t, e);\n        }\n\n        shouldParseAsyncArrow() {\n          return this.match(n.colon) || super.shouldParseAsyncArrow();\n        }\n\n        parseMaybeAssign(t, e, s, i) {\n          let r,\n              a = null;\n\n          if (this.hasPlugin(\"jsx\") && (this.match(n.jsxTagStart) || this.isRelational(\"<\"))) {\n            if (a = this.state.clone(), r = this.tryParse(() => super.parseMaybeAssign(t, e, s, i), a), !r.error) return r.node;\n            const {\n              context: n\n            } = this.state;\n            n[n.length - 1] === x.j_oTag ? n.length -= 2 : n[n.length - 1] === x.j_expr && (n.length -= 1);\n          }\n\n          if (r && r.error || this.isRelational(\"<\")) {\n            let n;\n            a = a || this.state.clone();\n            const o = this.tryParse(() => {\n              n = this.flowParseTypeParameterDeclaration();\n              const r = this.forwardNoArrowParamsConversionAt(n, () => super.parseMaybeAssign(t, e, s, i));\n              return r.typeParameters = n, this.resetStartLocationFromNode(r, n), r;\n            }, a),\n                  h = o.node && \"ArrowFunctionExpression\" === o.node.type ? o.node : null;\n            if (!o.error && h) return h;\n            if (r && r.node) return this.state = r.failState, r.node;\n            if (h) return this.state = o.failState, h;\n            if (r && r.thrown) throw r.error;\n            if (o.thrown) throw o.error;\n            throw this.raise(n.start, j.UnexpectedTokenAfterTypeParameter);\n          }\n\n          return super.parseMaybeAssign(t, e, s, i);\n        }\n\n        parseArrow(t) {\n          if (this.match(n.colon)) {\n            const e = this.tryParse(() => {\n              const e = this.state.noAnonFunctionType;\n              this.state.noAnonFunctionType = !0;\n              const s = this.startNode();\n              return [s.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = e, this.canInsertSemicolon() && this.unexpected(), this.match(n.arrow) || this.unexpected(), s;\n            });\n            if (e.thrown) return null;\n            e.error && (this.state = e.failState), t.returnType = e.node.typeAnnotation ? this.finishNode(e.node, \"TypeAnnotation\") : null;\n          }\n\n          return super.parseArrow(t);\n        }\n\n        shouldParseArrow() {\n          return this.match(n.colon) || super.shouldParseArrow();\n        }\n\n        setArrowFunctionParameters(t, e) {\n          -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? t.params = e : super.setArrowFunctionParameters(t, e);\n        }\n\n        checkParams(t, e, s) {\n          if (!s || -1 === this.state.noArrowParamsConversionAt.indexOf(t.start)) return super.checkParams(...arguments);\n        }\n\n        parseParenAndDistinguishExpression(t) {\n          return super.parseParenAndDistinguishExpression(t && -1 === this.state.noArrowAt.indexOf(this.state.start));\n        }\n\n        parseSubscripts(t, e, s, i) {\n          if (\"Identifier\" === t.type && \"async\" === t.name && -1 !== this.state.noArrowAt.indexOf(e)) {\n            this.next();\n            const i = this.startNodeAt(e, s);\n            i.callee = t, i.arguments = this.parseCallExpressionArguments(n.parenR, !1), t = this.finishNode(i, \"CallExpression\");\n          } else if (\"Identifier\" === t.type && \"async\" === t.name && this.isRelational(\"<\")) {\n            const r = this.state.clone(),\n                  a = this.tryParse(t => this.parseAsyncArrowWithTypeParameters(e, s) || t(), r);\n            if (!a.error && !a.aborted) return a.node;\n            const n = this.tryParse(() => super.parseSubscripts(t, e, s, i), r);\n            if (n.node && !n.error) return n.node;\n            if (a.node) return this.state = a.failState, a.node;\n            if (n.node) return this.state = n.failState, n.node;\n            throw a.error || n.error;\n          }\n\n          return super.parseSubscripts(t, e, s, i);\n        }\n\n        parseSubscript(t, e, s, i, r) {\n          if (this.match(n.questionDot) && this.isLookaheadRelational(\"<\")) {\n            if (r.optionalChainMember = !0, i) return r.stop = !0, t;\n            this.next();\n            const a = this.startNodeAt(e, s);\n            return a.callee = t, a.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(n.parenL), a.arguments = this.parseCallExpressionArguments(n.parenR, !1), a.optional = !0, this.finishCallExpression(a, !0);\n          }\n\n          if (!i && this.shouldParseTypes() && this.isRelational(\"<\")) {\n            const i = this.startNodeAt(e, s);\n            i.callee = t;\n            const a = this.tryParse(() => (i.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(n.parenL), i.arguments = this.parseCallExpressionArguments(n.parenR, !1), r.optionalChainMember && (i.optional = !1), this.finishCallExpression(i, r.optionalChainMember)));\n            if (a.node) return a.error && (this.state = a.failState), a.node;\n          }\n\n          return super.parseSubscript(t, e, s, i, r);\n        }\n\n        parseNewArguments(t) {\n          let e = null;\n          this.shouldParseTypes() && this.isRelational(\"<\") && (e = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), t.typeArguments = e, super.parseNewArguments(t);\n        }\n\n        parseAsyncArrowWithTypeParameters(t, e) {\n          const s = this.startNodeAt(t, e);\n          if (this.parseFunctionParams(s), this.parseArrow(s)) return this.parseArrowExpression(s, void 0, !0);\n        }\n\n        readToken_mult_modulo(t) {\n          const e = this.input.charCodeAt(this.state.pos + 1);\n          if (42 === t && 47 === e && this.state.hasFlowComment) return this.state.hasFlowComment = !1, this.state.pos += 2, void this.nextToken();\n          super.readToken_mult_modulo(t);\n        }\n\n        readToken_pipe_amp(t) {\n          const e = this.input.charCodeAt(this.state.pos + 1);\n          124 !== t || 125 !== e ? super.readToken_pipe_amp(t) : this.finishOp(n.braceBarR, 2);\n        }\n\n        parseTopLevel(t, e) {\n          const s = super.parseTopLevel(t, e);\n          return this.state.hasFlowComment && this.raise(this.state.pos, j.UnterminatedFlowComment), s;\n        }\n\n        skipBlockComment() {\n          if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) return this.state.hasFlowComment && this.unexpected(null, j.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = !0);\n\n          if (this.state.hasFlowComment) {\n            const t = this.input.indexOf(\"*-/\", this.state.pos += 2);\n            if (-1 === t) throw this.raise(this.state.pos - 2, f.UnterminatedComment);\n            this.state.pos = t + 3;\n          } else super.skipBlockComment();\n        }\n\n        skipFlowComment() {\n          const {\n            pos: t\n          } = this.state;\n          let e = 2;\n\n          for (; [32, 9].includes(this.input.charCodeAt(t + e));) e++;\n\n          const s = this.input.charCodeAt(e + t),\n                i = this.input.charCodeAt(e + t + 1);\n          return 58 === s && 58 === i ? e + 2 : \"flow-include\" === this.input.slice(e + t, e + t + 12) ? e + 12 : 58 === s && 58 !== i && e;\n        }\n\n        hasFlowCommentCompletion() {\n          if (-1 === this.input.indexOf(\"*/\", this.state.pos)) throw this.raise(this.state.pos, f.UnterminatedComment);\n        }\n\n        flowEnumErrorBooleanMemberNotInitialized(t, _ref4) {\n          let {\n            enumName: e,\n            memberName: s\n          } = _ref4;\n          this.raise(t, j.EnumBooleanMemberNotInitialized, s, e);\n        }\n\n        flowEnumErrorInvalidMemberName(t, _ref5) {\n          let {\n            enumName: e,\n            memberName: s\n          } = _ref5;\n          const i = s[0].toUpperCase() + s.slice(1);\n          this.raise(t, j.EnumInvalidMemberName, s, i, e);\n        }\n\n        flowEnumErrorDuplicateMemberName(t, _ref6) {\n          let {\n            enumName: e,\n            memberName: s\n          } = _ref6;\n          this.raise(t, j.EnumDuplicateMemberName, s, e);\n        }\n\n        flowEnumErrorInconsistentMemberValues(t, _ref7) {\n          let {\n            enumName: e\n          } = _ref7;\n          this.raise(t, j.EnumInconsistentMemberValues, e);\n        }\n\n        flowEnumErrorInvalidExplicitType(t, _ref8) {\n          let {\n            enumName: e,\n            suppliedType: s\n          } = _ref8;\n          return this.raise(t, null === s ? j.EnumInvalidExplicitTypeUnknownSupplied : j.EnumInvalidExplicitType, e, s);\n        }\n\n        flowEnumErrorInvalidMemberInitializer(t, _ref9) {\n          let {\n            enumName: e,\n            explicitType: s,\n            memberName: i\n          } = _ref9;\n          let r = null;\n\n          switch (s) {\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n              r = j.EnumInvalidMemberInitializerPrimaryType;\n              break;\n\n            case \"symbol\":\n              r = j.EnumInvalidMemberInitializerSymbolType;\n              break;\n\n            default:\n              r = j.EnumInvalidMemberInitializerUnknownType;\n          }\n\n          return this.raise(t, r, e, i, s);\n        }\n\n        flowEnumErrorNumberMemberNotInitialized(t, _ref10) {\n          let {\n            enumName: e,\n            memberName: s\n          } = _ref10;\n          this.raise(t, j.EnumNumberMemberNotInitialized, e, s);\n        }\n\n        flowEnumErrorStringMemberInconsistentlyInitailized(t, _ref11) {\n          let {\n            enumName: e\n          } = _ref11;\n          this.raise(t, j.EnumStringMemberInconsistentlyInitailized, e);\n        }\n\n        flowEnumMemberInit() {\n          const t = this.state.start,\n                e = () => this.match(n.comma) || this.match(n.braceR);\n\n          switch (this.state.type) {\n            case n.num:\n              {\n                const s = this.parseLiteral(this.state.value, \"NumericLiteral\");\n                return e() ? {\n                  type: \"number\",\n                  pos: s.start,\n                  value: s\n                } : {\n                  type: \"invalid\",\n                  pos: t\n                };\n              }\n\n            case n.string:\n              {\n                const s = this.parseLiteral(this.state.value, \"StringLiteral\");\n                return e() ? {\n                  type: \"string\",\n                  pos: s.start,\n                  value: s\n                } : {\n                  type: \"invalid\",\n                  pos: t\n                };\n              }\n\n            case n._true:\n            case n._false:\n              {\n                const s = this.parseBooleanLiteral();\n                return e() ? {\n                  type: \"boolean\",\n                  pos: s.start,\n                  value: s\n                } : {\n                  type: \"invalid\",\n                  pos: t\n                };\n              }\n\n            default:\n              return {\n                type: \"invalid\",\n                pos: t\n              };\n          }\n        }\n\n        flowEnumMemberRaw() {\n          const t = this.state.start;\n          return {\n            id: this.parseIdentifier(!0),\n            init: this.eat(n.eq) ? this.flowEnumMemberInit() : {\n              type: \"none\",\n              pos: t\n            }\n          };\n        }\n\n        flowEnumCheckExplicitTypeMismatch(t, e, s) {\n          const {\n            explicitType: i\n          } = e;\n          null !== i && i !== s && this.flowEnumErrorInvalidMemberInitializer(t, e);\n        }\n\n        flowEnumMembers(_ref12) {\n          let {\n            enumName: t,\n            explicitType: e\n          } = _ref12;\n          const s = new Set(),\n                i = {\n            booleanMembers: [],\n            numberMembers: [],\n            stringMembers: [],\n            defaultedMembers: []\n          };\n\n          for (; !this.match(n.braceR);) {\n            const r = this.startNode(),\n                  {\n              id: a,\n              init: o\n            } = this.flowEnumMemberRaw(),\n                  h = a.name;\n            if (\"\" === h) continue;\n            /^[a-z]/.test(h) && this.flowEnumErrorInvalidMemberName(a.start, {\n              enumName: t,\n              memberName: h\n            }), s.has(h) && this.flowEnumErrorDuplicateMemberName(a.start, {\n              enumName: t,\n              memberName: h\n            }), s.add(h);\n            const p = {\n              enumName: t,\n              explicitType: e,\n              memberName: h\n            };\n\n            switch (r.id = a, o.type) {\n              case \"boolean\":\n                this.flowEnumCheckExplicitTypeMismatch(o.pos, p, \"boolean\"), r.init = o.value, i.booleanMembers.push(this.finishNode(r, \"EnumBooleanMember\"));\n                break;\n\n              case \"number\":\n                this.flowEnumCheckExplicitTypeMismatch(o.pos, p, \"number\"), r.init = o.value, i.numberMembers.push(this.finishNode(r, \"EnumNumberMember\"));\n                break;\n\n              case \"string\":\n                this.flowEnumCheckExplicitTypeMismatch(o.pos, p, \"string\"), r.init = o.value, i.stringMembers.push(this.finishNode(r, \"EnumStringMember\"));\n                break;\n\n              case \"invalid\":\n                throw this.flowEnumErrorInvalidMemberInitializer(o.pos, p);\n\n              case \"none\":\n                switch (e) {\n                  case \"boolean\":\n                    this.flowEnumErrorBooleanMemberNotInitialized(o.pos, p);\n                    break;\n\n                  case \"number\":\n                    this.flowEnumErrorNumberMemberNotInitialized(o.pos, p);\n                    break;\n\n                  default:\n                    i.defaultedMembers.push(this.finishNode(r, \"EnumDefaultedMember\"));\n                }\n\n            }\n\n            this.match(n.braceR) || this.expect(n.comma);\n          }\n\n          return i;\n        }\n\n        flowEnumStringMembers(t, e, _ref13) {\n          let {\n            enumName: s\n          } = _ref13;\n          if (0 === t.length) return e;\n          if (0 === e.length) return t;\n\n          if (e.length > t.length) {\n            for (let e = 0; e < t.length; e++) {\n              const i = t[e];\n              this.flowEnumErrorStringMemberInconsistentlyInitailized(i.start, {\n                enumName: s\n              });\n            }\n\n            return e;\n          }\n\n          for (let t = 0; t < e.length; t++) {\n            const i = e[t];\n            this.flowEnumErrorStringMemberInconsistentlyInitailized(i.start, {\n              enumName: s\n            });\n          }\n\n          return t;\n        }\n\n        flowEnumParseExplicitType(_ref14) {\n          let {\n            enumName: t\n          } = _ref14;\n\n          if (this.eatContextual(\"of\")) {\n            if (!this.match(n.name)) throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n              enumName: t,\n              suppliedType: null\n            });\n            const {\n              value: e\n            } = this.state;\n            return this.next(), \"boolean\" !== e && \"number\" !== e && \"string\" !== e && \"symbol\" !== e && this.flowEnumErrorInvalidExplicitType(this.state.start, {\n              enumName: t,\n              suppliedType: e\n            }), e;\n          }\n\n          return null;\n        }\n\n        flowEnumBody(t, _ref15) {\n          let {\n            enumName: e,\n            nameLoc: s\n          } = _ref15;\n          const i = this.flowEnumParseExplicitType({\n            enumName: e\n          });\n          this.expect(n.braceL);\n          const r = this.flowEnumMembers({\n            enumName: e,\n            explicitType: i\n          });\n\n          switch (i) {\n            case \"boolean\":\n              return t.explicitType = !0, t.members = r.booleanMembers, this.expect(n.braceR), this.finishNode(t, \"EnumBooleanBody\");\n\n            case \"number\":\n              return t.explicitType = !0, t.members = r.numberMembers, this.expect(n.braceR), this.finishNode(t, \"EnumNumberBody\");\n\n            case \"string\":\n              return t.explicitType = !0, t.members = this.flowEnumStringMembers(r.stringMembers, r.defaultedMembers, {\n                enumName: e\n              }), this.expect(n.braceR), this.finishNode(t, \"EnumStringBody\");\n\n            case \"symbol\":\n              return t.members = r.defaultedMembers, this.expect(n.braceR), this.finishNode(t, \"EnumSymbolBody\");\n\n            default:\n              {\n                const i = () => (t.members = [], this.expect(n.braceR), this.finishNode(t, \"EnumStringBody\"));\n\n                t.explicitType = !1;\n                const a = r.booleanMembers.length,\n                      o = r.numberMembers.length,\n                      h = r.stringMembers.length,\n                      p = r.defaultedMembers.length;\n\n                if (a || o || h || p) {\n                  if (a || o) {\n                    if (!o && !h && a >= p) {\n                      for (let t = 0, s = r.defaultedMembers; t < s.length; t++) {\n                        const i = s[t];\n                        this.flowEnumErrorBooleanMemberNotInitialized(i.start, {\n                          enumName: e,\n                          memberName: i.id.name\n                        });\n                      }\n\n                      return t.members = r.booleanMembers, this.expect(n.braceR), this.finishNode(t, \"EnumBooleanBody\");\n                    }\n\n                    if (!a && !h && o >= p) {\n                      for (let t = 0, s = r.defaultedMembers; t < s.length; t++) {\n                        const i = s[t];\n                        this.flowEnumErrorNumberMemberNotInitialized(i.start, {\n                          enumName: e,\n                          memberName: i.id.name\n                        });\n                      }\n\n                      return t.members = r.numberMembers, this.expect(n.braceR), this.finishNode(t, \"EnumNumberBody\");\n                    }\n\n                    return this.flowEnumErrorInconsistentMemberValues(s, {\n                      enumName: e\n                    }), i();\n                  }\n\n                  return t.members = this.flowEnumStringMembers(r.stringMembers, r.defaultedMembers, {\n                    enumName: e\n                  }), this.expect(n.braceR), this.finishNode(t, \"EnumStringBody\");\n                }\n\n                return i();\n              }\n          }\n        }\n\n        flowParseEnumDeclaration(t) {\n          const e = this.parseIdentifier();\n          return t.id = e, t.body = this.flowEnumBody(this.startNode(), {\n            enumName: e.name,\n            nameLoc: e.start\n          }), this.finishNode(t, \"EnumDeclaration\");\n        }\n\n      },\n      typescript: t => class extends t {\n        getScopeHandler() {\n          return Z;\n        }\n\n        tsIsIdentifier() {\n          return this.match(n.name);\n        }\n\n        tsNextTokenCanFollowModifier() {\n          return this.next(), !(this.hasPrecedingLineBreak() || this.match(n.parenL) || this.match(n.parenR) || this.match(n.colon) || this.match(n.eq) || this.match(n.question) || this.match(n.bang));\n        }\n\n        tsParseModifier(t) {\n          if (!this.match(n.name)) return;\n          const e = this.state.value;\n          return -1 !== t.indexOf(e) && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)) ? e : void 0;\n        }\n\n        tsParseModifiers(t, e) {\n          for (;;) {\n            const s = this.state.start,\n                  i = this.tsParseModifier(e);\n            if (!i) break;\n            Object.hasOwnProperty.call(t, i) && this.raise(s, rt.DuplicateModifier, i), t[i] = !0;\n          }\n        }\n\n        tsIsListTerminator(t) {\n          switch (t) {\n            case \"EnumMembers\":\n            case \"TypeMembers\":\n              return this.match(n.braceR);\n\n            case \"HeritageClauseElement\":\n              return this.match(n.braceL);\n\n            case \"TupleElementTypes\":\n              return this.match(n.bracketR);\n\n            case \"TypeParametersOrArguments\":\n              return this.isRelational(\">\");\n          }\n\n          throw new Error(\"Unreachable\");\n        }\n\n        tsParseList(t, e) {\n          const s = [];\n\n          for (; !this.tsIsListTerminator(t);) s.push(e());\n\n          return s;\n        }\n\n        tsParseDelimitedList(t, e) {\n          return st(this.tsParseDelimitedListWorker(t, e, !0));\n        }\n\n        tsParseDelimitedListWorker(t, e, s) {\n          const i = [];\n\n          for (; !this.tsIsListTerminator(t);) {\n            const r = e();\n            if (null == r) return;\n\n            if (i.push(r), !this.eat(n.comma)) {\n              if (this.tsIsListTerminator(t)) break;\n              return void (s && this.expect(n.comma));\n            }\n          }\n\n          return i;\n        }\n\n        tsParseBracketedList(t, e, s, i) {\n          i || (s ? this.expect(n.bracketL) : this.expectRelational(\"<\"));\n          const r = this.tsParseDelimitedList(t, e);\n          return s ? this.expect(n.bracketR) : this.expectRelational(\">\"), r;\n        }\n\n        tsParseImportType() {\n          const t = this.startNode();\n          return this.expect(n._import), this.expect(n.parenL), this.match(n.string) || this.raise(this.state.start, rt.UnsupportedImportTypeArgument), t.argument = this.parseExprAtom(), this.expect(n.parenR), this.eat(n.dot) && (t.qualifier = this.tsParseEntityName(!0)), this.isRelational(\"<\") && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, \"TSImportType\");\n        }\n\n        tsParseEntityName(t) {\n          let e = this.parseIdentifier();\n\n          for (; this.eat(n.dot);) {\n            const s = this.startNodeAtNode(e);\n            s.left = e, s.right = this.parseIdentifier(t), e = this.finishNode(s, \"TSQualifiedName\");\n          }\n\n          return e;\n        }\n\n        tsParseTypeReference() {\n          const t = this.startNode();\n          return t.typeName = this.tsParseEntityName(!1), !this.hasPrecedingLineBreak() && this.isRelational(\"<\") && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, \"TSTypeReference\");\n        }\n\n        tsParseThisTypePredicate(t) {\n          this.next();\n          const e = this.startNodeAtNode(t);\n          return e.parameterName = t, e.typeAnnotation = this.tsParseTypeAnnotation(!1), this.finishNode(e, \"TSTypePredicate\");\n        }\n\n        tsParseThisTypeNode() {\n          const t = this.startNode();\n          return this.next(), this.finishNode(t, \"TSThisType\");\n        }\n\n        tsParseTypeQuery() {\n          const t = this.startNode();\n          return this.expect(n._typeof), this.match(n._import) ? t.exprName = this.tsParseImportType() : t.exprName = this.tsParseEntityName(!0), this.finishNode(t, \"TSTypeQuery\");\n        }\n\n        tsParseTypeParameter() {\n          const t = this.startNode();\n          return t.name = this.parseIdentifierName(t.start), t.constraint = this.tsEatThenParseType(n._extends), t.default = this.tsEatThenParseType(n.eq), this.finishNode(t, \"TSTypeParameter\");\n        }\n\n        tsTryParseTypeParameters() {\n          if (this.isRelational(\"<\")) return this.tsParseTypeParameters();\n        }\n\n        tsParseTypeParameters() {\n          const t = this.startNode();\n          return this.isRelational(\"<\") || this.match(n.jsxTagStart) ? this.next() : this.unexpected(), t.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), !1, !0), this.finishNode(t, \"TSTypeParameterDeclaration\");\n        }\n\n        tsTryNextParseConstantContext() {\n          return this.lookahead().type === n._const ? (this.next(), this.tsParseTypeReference()) : null;\n        }\n\n        tsFillSignature(t, e) {\n          const s = t === n.arrow;\n          e.typeParameters = this.tsTryParseTypeParameters(), this.expect(n.parenL), e.parameters = this.tsParseBindingListForSignature(), s ? e.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t) : this.match(t) && (e.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t));\n        }\n\n        tsParseBindingListForSignature() {\n          return this.parseBindingList(n.parenR, 41).map(t => (\"Identifier\" !== t.type && \"RestElement\" !== t.type && \"ObjectPattern\" !== t.type && \"ArrayPattern\" !== t.type && this.raise(t.start, rt.UnsupportedSignatureParameterKind, t.type), t));\n        }\n\n        tsParseTypeMemberSemicolon() {\n          this.eat(n.comma) || this.semicolon();\n        }\n\n        tsParseSignatureMember(t, e) {\n          return this.tsFillSignature(n.colon, e), this.tsParseTypeMemberSemicolon(), this.finishNode(e, t);\n        }\n\n        tsIsUnambiguouslyIndexSignature() {\n          return this.next(), this.eat(n.name) && this.match(n.colon);\n        }\n\n        tsTryParseIndexSignature(t) {\n          if (!this.match(n.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;\n          this.expect(n.bracketL);\n          const e = this.parseIdentifier();\n          e.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(e), this.expect(n.bracketR), t.parameters = [e];\n          const s = this.tsTryParseTypeAnnotation();\n          return s && (t.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(t, \"TSIndexSignature\");\n        }\n\n        tsParsePropertyOrMethodSignature(t, e) {\n          this.eat(n.question) && (t.optional = !0);\n          const s = t;\n\n          if (e || !this.match(n.parenL) && !this.isRelational(\"<\")) {\n            const t = s;\n            e && (t.readonly = !0);\n            const i = this.tsTryParseTypeAnnotation();\n            return i && (t.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(t, \"TSPropertySignature\");\n          }\n\n          {\n            const t = s;\n            return this.tsFillSignature(n.colon, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, \"TSMethodSignature\");\n          }\n        }\n\n        tsParseTypeMember() {\n          const t = this.startNode();\n          if (this.match(n.parenL) || this.isRelational(\"<\")) return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", t);\n\n          if (this.match(n._new)) {\n            const e = this.startNode();\n            return this.next(), this.match(n.parenL) || this.isRelational(\"<\") ? this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", t) : (t.key = this.createIdentifier(e, \"new\"), this.tsParsePropertyOrMethodSignature(t, !1));\n          }\n\n          const e = !!this.tsParseModifier([\"readonly\"]),\n                s = this.tsTryParseIndexSignature(t);\n          return s ? (e && (t.readonly = !0), s) : (this.parsePropertyName(t, !1), this.tsParsePropertyOrMethodSignature(t, e));\n        }\n\n        tsParseTypeLiteral() {\n          const t = this.startNode();\n          return t.members = this.tsParseObjectTypeMembers(), this.finishNode(t, \"TSTypeLiteral\");\n        }\n\n        tsParseObjectTypeMembers() {\n          this.expect(n.braceL);\n          const t = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n          return this.expect(n.braceR), t;\n        }\n\n        tsIsStartOfMappedType() {\n          return this.next(), this.eat(n.plusMin) ? this.isContextual(\"readonly\") : (this.isContextual(\"readonly\") && this.next(), !!this.match(n.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(n._in))));\n        }\n\n        tsParseMappedTypeParameter() {\n          const t = this.startNode();\n          return t.name = this.parseIdentifierName(t.start), t.constraint = this.tsExpectThenParseType(n._in), this.finishNode(t, \"TSTypeParameter\");\n        }\n\n        tsParseMappedType() {\n          const t = this.startNode();\n          return this.expect(n.braceL), this.match(n.plusMin) ? (t.readonly = this.state.value, this.next(), this.expectContextual(\"readonly\")) : this.eatContextual(\"readonly\") && (t.readonly = !0), this.expect(n.bracketL), t.typeParameter = this.tsParseMappedTypeParameter(), this.expect(n.bracketR), this.match(n.plusMin) ? (t.optional = this.state.value, this.next(), this.expect(n.question)) : this.eat(n.question) && (t.optional = !0), t.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(n.braceR), this.finishNode(t, \"TSMappedType\");\n        }\n\n        tsParseTupleType() {\n          const t = this.startNode();\n          t.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), !0, !1);\n          let e = !1;\n          return t.elementTypes.forEach(t => {\n            \"TSOptionalType\" === t.type ? e = !0 : e && \"TSRestType\" !== t.type && this.raise(t.start, rt.OptionalTypeBeforeRequired);\n          }), this.finishNode(t, \"TSTupleType\");\n        }\n\n        tsParseTupleElementType() {\n          if (this.match(n.ellipsis)) {\n            const t = this.startNode();\n            return this.next(), t.typeAnnotation = this.tsParseType(), this.match(n.comma) && 93 !== this.lookaheadCharCode() && this.raiseRestNotLast(this.state.start), this.finishNode(t, \"TSRestType\");\n          }\n\n          const t = this.tsParseType();\n\n          if (this.eat(n.question)) {\n            const e = this.startNodeAtNode(t);\n            return e.typeAnnotation = t, this.finishNode(e, \"TSOptionalType\");\n          }\n\n          return t;\n        }\n\n        tsParseParenthesizedType() {\n          const t = this.startNode();\n          return this.expect(n.parenL), t.typeAnnotation = this.tsParseType(), this.expect(n.parenR), this.finishNode(t, \"TSParenthesizedType\");\n        }\n\n        tsParseFunctionOrConstructorType(t) {\n          const e = this.startNode();\n          return \"TSConstructorType\" === t && this.expect(n._new), this.tsFillSignature(n.arrow, e), this.finishNode(e, t);\n        }\n\n        tsParseLiteralTypeNode() {\n          const t = this.startNode();\n          return t.literal = (() => {\n            switch (this.state.type) {\n              case n.num:\n              case n.string:\n              case n._true:\n              case n._false:\n                return this.parseExprAtom();\n\n              default:\n                throw this.unexpected();\n            }\n          })(), this.finishNode(t, \"TSLiteralType\");\n        }\n\n        tsParseTemplateLiteralType() {\n          const t = this.startNode(),\n                e = this.parseTemplate(!1);\n          return e.expressions.length > 0 && this.raise(e.expressions[0].start, rt.TemplateTypeHasSubstitution), t.literal = e, this.finishNode(t, \"TSLiteralType\");\n        }\n\n        tsParseThisTypeOrThisTypePredicate() {\n          const t = this.tsParseThisTypeNode();\n          return this.isContextual(\"is\") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t) : t;\n        }\n\n        tsParseNonArrayType() {\n          switch (this.state.type) {\n            case n.name:\n            case n._void:\n            case n._null:\n              {\n                const t = this.match(n._void) ? \"TSVoidKeyword\" : this.match(n._null) ? \"TSNullKeyword\" : function (t) {\n                  switch (t) {\n                    case \"any\":\n                      return \"TSAnyKeyword\";\n\n                    case \"boolean\":\n                      return \"TSBooleanKeyword\";\n\n                    case \"bigint\":\n                      return \"TSBigIntKeyword\";\n\n                    case \"never\":\n                      return \"TSNeverKeyword\";\n\n                    case \"number\":\n                      return \"TSNumberKeyword\";\n\n                    case \"object\":\n                      return \"TSObjectKeyword\";\n\n                    case \"string\":\n                      return \"TSStringKeyword\";\n\n                    case \"symbol\":\n                      return \"TSSymbolKeyword\";\n\n                    case \"undefined\":\n                      return \"TSUndefinedKeyword\";\n\n                    case \"unknown\":\n                      return \"TSUnknownKeyword\";\n\n                    default:\n                      return;\n                  }\n                }(this.state.value);\n\n                if (void 0 !== t && 46 !== this.lookaheadCharCode()) {\n                  const e = this.startNode();\n                  return this.next(), this.finishNode(e, t);\n                }\n\n                return this.tsParseTypeReference();\n              }\n\n            case n.string:\n            case n.num:\n            case n._true:\n            case n._false:\n              return this.tsParseLiteralTypeNode();\n\n            case n.plusMin:\n              if (\"-\" === this.state.value) {\n                const t = this.startNode();\n                if (this.lookahead().type !== n.num) throw this.unexpected();\n                return t.literal = this.parseMaybeUnary(), this.finishNode(t, \"TSLiteralType\");\n              }\n\n              break;\n\n            case n._this:\n              return this.tsParseThisTypeOrThisTypePredicate();\n\n            case n._typeof:\n              return this.tsParseTypeQuery();\n\n            case n._import:\n              return this.tsParseImportType();\n\n            case n.braceL:\n              return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n            case n.bracketL:\n              return this.tsParseTupleType();\n\n            case n.parenL:\n              return this.tsParseParenthesizedType();\n\n            case n.backQuote:\n              return this.tsParseTemplateLiteralType();\n          }\n\n          throw this.unexpected();\n        }\n\n        tsParseArrayTypeOrHigher() {\n          let t = this.tsParseNonArrayType();\n\n          for (; !this.hasPrecedingLineBreak() && this.eat(n.bracketL);) if (this.match(n.bracketR)) {\n            const e = this.startNodeAtNode(t);\n            e.elementType = t, this.expect(n.bracketR), t = this.finishNode(e, \"TSArrayType\");\n          } else {\n            const e = this.startNodeAtNode(t);\n            e.objectType = t, e.indexType = this.tsParseType(), this.expect(n.bracketR), t = this.finishNode(e, \"TSIndexedAccessType\");\n          }\n\n          return t;\n        }\n\n        tsParseTypeOperator(t) {\n          const e = this.startNode();\n          return this.expectContextual(t), e.operator = t, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), \"readonly\" === t && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, \"TSTypeOperator\");\n        }\n\n        tsCheckTypeAnnotationForReadOnly(t) {\n          switch (t.typeAnnotation.type) {\n            case \"TSTupleType\":\n            case \"TSArrayType\":\n              return;\n\n            default:\n              this.raise(t.start, rt.UnexpectedReadonly);\n          }\n        }\n\n        tsParseInferType() {\n          const t = this.startNode();\n          this.expectContextual(\"infer\");\n          const e = this.startNode();\n          return e.name = this.parseIdentifierName(e.start), t.typeParameter = this.finishNode(e, \"TSTypeParameter\"), this.finishNode(t, \"TSInferType\");\n        }\n\n        tsParseTypeOperatorOrHigher() {\n          const t = [\"keyof\", \"unique\", \"readonly\"].find(t => this.isContextual(t));\n          return t ? this.tsParseTypeOperator(t) : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n        }\n\n        tsParseUnionOrIntersectionType(t, e, s) {\n          this.eat(s);\n          let i = e();\n\n          if (this.match(s)) {\n            const r = [i];\n\n            for (; this.eat(s);) r.push(e());\n\n            const a = this.startNodeAtNode(i);\n            a.types = r, i = this.finishNode(a, t);\n          }\n\n          return i;\n        }\n\n        tsParseIntersectionTypeOrHigher() {\n          return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), n.bitwiseAND);\n        }\n\n        tsParseUnionTypeOrHigher() {\n          return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), n.bitwiseOR);\n        }\n\n        tsIsStartOfFunctionType() {\n          return !!this.isRelational(\"<\") || this.match(n.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n        }\n\n        tsSkipParameterStart() {\n          if (this.match(n.name) || this.match(n._this)) return this.next(), !0;\n\n          if (this.match(n.braceL)) {\n            let t = 1;\n\n            for (this.next(); t > 0;) this.match(n.braceL) ? ++t : this.match(n.braceR) && --t, this.next();\n\n            return !0;\n          }\n\n          if (this.match(n.bracketL)) {\n            let t = 1;\n\n            for (this.next(); t > 0;) this.match(n.bracketL) ? ++t : this.match(n.bracketR) && --t, this.next();\n\n            return !0;\n          }\n\n          return !1;\n        }\n\n        tsIsUnambiguouslyStartOfFunctionType() {\n          if (this.next(), this.match(n.parenR) || this.match(n.ellipsis)) return !0;\n\n          if (this.tsSkipParameterStart()) {\n            if (this.match(n.colon) || this.match(n.comma) || this.match(n.question) || this.match(n.eq)) return !0;\n            if (this.match(n.parenR) && (this.next(), this.match(n.arrow))) return !0;\n          }\n\n          return !1;\n        }\n\n        tsParseTypeOrTypePredicateAnnotation(t) {\n          return this.tsInType(() => {\n            const e = this.startNode();\n            this.expect(t);\n            const s = this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n            if (s && this.match(n._this)) {\n              let t = this.tsParseThisTypeOrThisTypePredicate();\n\n              if (\"TSThisType\" === t.type) {\n                const s = this.startNodeAtNode(e);\n                s.parameterName = t, s.asserts = !0, t = this.finishNode(s, \"TSTypePredicate\");\n              } else t.asserts = !0;\n\n              return e.typeAnnotation = t, this.finishNode(e, \"TSTypeAnnotation\");\n            }\n\n            const i = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n            if (!i) {\n              if (!s) return this.tsParseTypeAnnotation(!1, e);\n              const t = this.startNodeAtNode(e);\n              return t.parameterName = this.parseIdentifier(), t.asserts = s, e.typeAnnotation = this.finishNode(t, \"TSTypePredicate\"), this.finishNode(e, \"TSTypeAnnotation\");\n            }\n\n            const r = this.tsParseTypeAnnotation(!1),\n                  a = this.startNodeAtNode(e);\n            return a.parameterName = i, a.typeAnnotation = r, a.asserts = s, e.typeAnnotation = this.finishNode(a, \"TSTypePredicate\"), this.finishNode(e, \"TSTypeAnnotation\");\n          });\n        }\n\n        tsTryParseTypeOrTypePredicateAnnotation() {\n          return this.match(n.colon) ? this.tsParseTypeOrTypePredicateAnnotation(n.colon) : void 0;\n        }\n\n        tsTryParseTypeAnnotation() {\n          return this.match(n.colon) ? this.tsParseTypeAnnotation() : void 0;\n        }\n\n        tsTryParseType() {\n          return this.tsEatThenParseType(n.colon);\n        }\n\n        tsParseTypePredicatePrefix() {\n          const t = this.parseIdentifier();\n          if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) return this.next(), t;\n        }\n\n        tsParseTypePredicateAsserts() {\n          if (!this.match(n.name) || \"asserts\" !== this.state.value || this.hasPrecedingLineBreak()) return !1;\n          const t = this.state.containsEsc;\n          return this.next(), !(!this.match(n.name) && !this.match(n._this)) && (t && this.raise(this.state.lastTokStart, f.InvalidEscapedReservedWord, \"asserts\"), !0);\n        }\n\n        tsParseTypeAnnotation() {\n          let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;\n          let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.startNode();\n          return this.tsInType(() => {\n            t && this.expect(n.colon), e.typeAnnotation = this.tsParseType();\n          }), this.finishNode(e, \"TSTypeAnnotation\");\n        }\n\n        tsParseType() {\n          it(this.state.inType);\n          const t = this.tsParseNonConditionalType();\n          if (this.hasPrecedingLineBreak() || !this.eat(n._extends)) return t;\n          const e = this.startNodeAtNode(t);\n          return e.checkType = t, e.extendsType = this.tsParseNonConditionalType(), this.expect(n.question), e.trueType = this.tsParseType(), this.expect(n.colon), e.falseType = this.tsParseType(), this.finishNode(e, \"TSConditionalType\");\n        }\n\n        tsParseNonConditionalType() {\n          return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType(\"TSFunctionType\") : this.match(n._new) ? this.tsParseFunctionOrConstructorType(\"TSConstructorType\") : this.tsParseUnionTypeOrHigher();\n        }\n\n        tsParseTypeAssertion() {\n          const t = this.startNode(),\n                e = this.tsTryNextParseConstantContext();\n          return t.typeAnnotation = e || this.tsNextThenParseType(), this.expectRelational(\">\"), t.expression = this.parseMaybeUnary(), this.finishNode(t, \"TSTypeAssertion\");\n        }\n\n        tsParseHeritageClause(t) {\n          const e = this.state.start,\n                s = this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n          return s.length || this.raise(e, rt.EmptyHeritageClauseType, t), s;\n        }\n\n        tsParseExpressionWithTypeArguments() {\n          const t = this.startNode();\n          return t.expression = this.tsParseEntityName(!1), this.isRelational(\"<\") && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, \"TSExpressionWithTypeArguments\");\n        }\n\n        tsParseInterfaceDeclaration(t) {\n          t.id = this.parseIdentifier(), this.checkLVal(t.id, 130, void 0, \"typescript interface declaration\"), t.typeParameters = this.tsTryParseTypeParameters(), this.eat(n._extends) && (t.extends = this.tsParseHeritageClause(\"extends\"));\n          const e = this.startNode();\n          return e.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t.body = this.finishNode(e, \"TSInterfaceBody\"), this.finishNode(t, \"TSInterfaceDeclaration\");\n        }\n\n        tsParseTypeAliasDeclaration(t) {\n          return t.id = this.parseIdentifier(), this.checkLVal(t.id, 2, void 0, \"typescript type alias\"), t.typeParameters = this.tsTryParseTypeParameters(), t.typeAnnotation = this.tsExpectThenParseType(n.eq), this.semicolon(), this.finishNode(t, \"TSTypeAliasDeclaration\");\n        }\n\n        tsInNoContext(t) {\n          const e = this.state.context;\n          this.state.context = [e[0]];\n\n          try {\n            return t();\n          } finally {\n            this.state.context = e;\n          }\n        }\n\n        tsInType(t) {\n          const e = this.state.inType;\n          this.state.inType = !0;\n\n          try {\n            return t();\n          } finally {\n            this.state.inType = e;\n          }\n        }\n\n        tsEatThenParseType(t) {\n          return this.match(t) ? this.tsNextThenParseType() : void 0;\n        }\n\n        tsExpectThenParseType(t) {\n          return this.tsDoThenParseType(() => this.expect(t));\n        }\n\n        tsNextThenParseType() {\n          return this.tsDoThenParseType(() => this.next());\n        }\n\n        tsDoThenParseType(t) {\n          return this.tsInType(() => (t(), this.tsParseType()));\n        }\n\n        tsParseEnumMember() {\n          const t = this.startNode();\n          return t.id = this.match(n.string) ? this.parseExprAtom() : this.parseIdentifier(!0), this.eat(n.eq) && (t.initializer = this.parseMaybeAssign()), this.finishNode(t, \"TSEnumMember\");\n        }\n\n        tsParseEnumDeclaration(t, e) {\n          return e && (t.const = !0), t.id = this.parseIdentifier(), this.checkLVal(t.id, e ? 779 : 267, void 0, \"typescript enum declaration\"), this.expect(n.braceL), t.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this)), this.expect(n.braceR), this.finishNode(t, \"TSEnumDeclaration\");\n        }\n\n        tsParseModuleBlock() {\n          const t = this.startNode();\n          return this.scope.enter(0), this.expect(n.braceL), this.parseBlockOrModuleBlockBody(t.body = [], void 0, !0, n.braceR), this.scope.exit(), this.finishNode(t, \"TSModuleBlock\");\n        }\n\n        tsParseModuleOrNamespaceDeclaration(t) {\n          let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n\n          if (t.id = this.parseIdentifier(), e || this.checkLVal(t.id, 1024, null, \"module or namespace declaration\"), this.eat(n.dot)) {\n            const e = this.startNode();\n            this.tsParseModuleOrNamespaceDeclaration(e, !0), t.body = e;\n          } else this.scope.enter(128), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();\n\n          return this.finishNode(t, \"TSModuleDeclaration\");\n        }\n\n        tsParseAmbientExternalModuleDeclaration(t) {\n          return this.isContextual(\"global\") ? (t.global = !0, t.id = this.parseIdentifier()) : this.match(n.string) ? t.id = this.parseExprAtom() : this.unexpected(), this.match(n.braceL) ? (this.scope.enter(128), this.prodParam.enter(0), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t, \"TSModuleDeclaration\");\n        }\n\n        tsParseImportEqualsDeclaration(t, e) {\n          return t.isExport = e || !1, t.id = this.parseIdentifier(), this.checkLVal(t.id, 9, void 0, \"import equals declaration\"), this.expect(n.eq), t.moduleReference = this.tsParseModuleReference(), this.semicolon(), this.finishNode(t, \"TSImportEqualsDeclaration\");\n        }\n\n        tsIsExternalModuleReference() {\n          return this.isContextual(\"require\") && 40 === this.lookaheadCharCode();\n        }\n\n        tsParseModuleReference() {\n          return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);\n        }\n\n        tsParseExternalModuleReference() {\n          const t = this.startNode();\n          if (this.expectContextual(\"require\"), this.expect(n.parenL), !this.match(n.string)) throw this.unexpected();\n          return t.expression = this.parseExprAtom(), this.expect(n.parenR), this.finishNode(t, \"TSExternalModuleReference\");\n        }\n\n        tsLookAhead(t) {\n          const e = this.state.clone(),\n                s = t();\n          return this.state = e, s;\n        }\n\n        tsTryParseAndCatch(t) {\n          const e = this.tryParse(e => t() || e());\n          if (!e.aborted && e.node) return e.error && (this.state = e.failState), e.node;\n        }\n\n        tsTryParse(t) {\n          const e = this.state.clone(),\n                s = t();\n          return void 0 !== s && !1 !== s ? s : void (this.state = e);\n        }\n\n        tsTryParseDeclare(t) {\n          if (this.isLineTerminator()) return;\n          let e,\n              s = this.state.type;\n\n          switch (this.isContextual(\"let\") && (s = n._var, e = \"let\"), s) {\n            case n._function:\n              return this.parseFunctionStatement(t, !1, !0);\n\n            case n._class:\n              return t.declare = !0, this.parseClass(t, !0, !1);\n\n            case n._const:\n              if (this.match(n._const) && this.isLookaheadContextual(\"enum\")) return this.expect(n._const), this.expectContextual(\"enum\"), this.tsParseEnumDeclaration(t, !0);\n\n            case n._var:\n              return e = e || this.state.value, this.parseVarStatement(t, e);\n\n            case n.name:\n              {\n                const e = this.state.value;\n                return \"global\" === e ? this.tsParseAmbientExternalModuleDeclaration(t) : this.tsParseDeclaration(t, e, !0);\n              }\n          }\n        }\n\n        tsTryParseExportDeclaration() {\n          return this.tsParseDeclaration(this.startNode(), this.state.value, !0);\n        }\n\n        tsParseExpressionStatement(t, e) {\n          switch (e.name) {\n            case \"declare\":\n              {\n                const e = this.tsTryParseDeclare(t);\n                if (e) return e.declare = !0, e;\n                break;\n              }\n\n            case \"global\":\n              if (this.match(n.braceL)) {\n                this.scope.enter(128), this.prodParam.enter(0);\n                const s = t;\n                return s.global = !0, s.id = e, s.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(s, \"TSModuleDeclaration\");\n              }\n\n              break;\n\n            default:\n              return this.tsParseDeclaration(t, e.name, !1);\n          }\n        }\n\n        tsParseDeclaration(t, e, s) {\n          switch (e) {\n            case \"abstract\":\n              if (this.tsCheckLineTerminatorAndMatch(n._class, s)) {\n                const e = t;\n                return e.abstract = !0, s && (this.next(), this.match(n._class) || this.unexpected(null, n._class)), this.parseClass(e, !0, !1);\n              }\n\n              break;\n\n            case \"enum\":\n              if (s || this.match(n.name)) return s && this.next(), this.tsParseEnumDeclaration(t, !1);\n              break;\n\n            case \"interface\":\n              if (this.tsCheckLineTerminatorAndMatch(n.name, s)) return s && this.next(), this.tsParseInterfaceDeclaration(t);\n              break;\n\n            case \"module\":\n              if (s && this.next(), this.match(n.string)) return this.tsParseAmbientExternalModuleDeclaration(t);\n              if (this.tsCheckLineTerminatorAndMatch(n.name, s)) return this.tsParseModuleOrNamespaceDeclaration(t);\n              break;\n\n            case \"namespace\":\n              if (this.tsCheckLineTerminatorAndMatch(n.name, s)) return s && this.next(), this.tsParseModuleOrNamespaceDeclaration(t);\n              break;\n\n            case \"type\":\n              if (this.tsCheckLineTerminatorAndMatch(n.name, s)) return s && this.next(), this.tsParseTypeAliasDeclaration(t);\n          }\n        }\n\n        tsCheckLineTerminatorAndMatch(t, e) {\n          return (e || this.match(t)) && !this.isLineTerminator();\n        }\n\n        tsTryParseGenericAsyncArrowFunction(t, e) {\n          if (!this.isRelational(\"<\")) return;\n          const s = this.state.maybeInArrowParameters,\n                i = this.state.yieldPos,\n                r = this.state.awaitPos;\n          this.state.maybeInArrowParameters = !0, this.state.yieldPos = -1, this.state.awaitPos = -1;\n          const a = this.tsTryParseAndCatch(() => {\n            const s = this.startNodeAt(t, e);\n            return s.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s), s.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(n.arrow), s;\n          });\n          return this.state.maybeInArrowParameters = s, this.state.yieldPos = i, this.state.awaitPos = r, a ? this.parseArrowExpression(a, null, !0) : void 0;\n        }\n\n        tsParseTypeArguments() {\n          const t = this.startNode();\n          return t.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational(\"<\"), this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this))))), this.state.exprAllowed = !1, this.expectRelational(\">\"), this.finishNode(t, \"TSTypeParameterInstantiation\");\n        }\n\n        tsIsDeclarationStart() {\n          if (this.match(n.name)) switch (this.state.value) {\n            case \"abstract\":\n            case \"declare\":\n            case \"enum\":\n            case \"interface\":\n            case \"module\":\n            case \"namespace\":\n            case \"type\":\n              return !0;\n          }\n          return !1;\n        }\n\n        isExportDefaultSpecifier() {\n          return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();\n        }\n\n        parseAssignableListItem(t, e) {\n          const s = this.state.start,\n                i = this.state.startLoc;\n          let r,\n              a = !1;\n          t && (r = this.parseAccessModifier(), a = !!this.tsParseModifier([\"readonly\"]));\n          const n = this.parseMaybeDefault();\n          this.parseAssignableListItemTypes(n);\n          const o = this.parseMaybeDefault(n.start, n.loc.start, n);\n\n          if (r || a) {\n            const t = this.startNodeAt(s, i);\n            return e.length && (t.decorators = e), r && (t.accessibility = r), a && (t.readonly = a), \"Identifier\" !== o.type && \"AssignmentPattern\" !== o.type && this.raise(t.start, rt.UnsupportedParameterPropertyKind), t.parameter = o, this.finishNode(t, \"TSParameterProperty\");\n          }\n\n          return e.length && (n.decorators = e), o;\n        }\n\n        parseFunctionBodyAndFinish(t, e) {\n          let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n          this.match(n.colon) && (t.returnType = this.tsParseTypeOrTypePredicateAnnotation(n.colon));\n          const i = \"FunctionDeclaration\" === e ? \"TSDeclareFunction\" : \"ClassMethod\" === e ? \"TSDeclareMethod\" : void 0;\n          i && !this.match(n.braceL) && this.isLineTerminator() ? this.finishNode(t, i) : super.parseFunctionBodyAndFinish(t, e, s);\n        }\n\n        registerFunctionStatementId(t) {\n          !t.body && t.id ? this.checkLVal(t.id, 1024, null, \"function name\") : super.registerFunctionStatementId(...arguments);\n        }\n\n        parseSubscript(t, e, s, i, r) {\n          if (!this.hasPrecedingLineBreak() && this.match(n.bang)) {\n            this.state.exprAllowed = !1, this.next();\n            const i = this.startNodeAt(e, s);\n            return i.expression = t, this.finishNode(i, \"TSNonNullExpression\");\n          }\n\n          if (this.isRelational(\"<\")) {\n            const a = this.tsTryParseAndCatch(() => {\n              if (!i && this.atPossibleAsyncArrow(t)) {\n                const t = this.tsTryParseGenericAsyncArrowFunction(e, s);\n                if (t) return t;\n              }\n\n              const a = this.startNodeAt(e, s);\n              a.callee = t;\n              const o = this.tsParseTypeArguments();\n\n              if (o) {\n                if (!i && this.eat(n.parenL)) return a.arguments = this.parseCallExpressionArguments(n.parenR, !1), a.typeParameters = o, this.finishCallExpression(a, r.optionalChainMember);\n                if (this.match(n.backQuote)) return this.parseTaggedTemplateExpression(e, s, t, r, o);\n              }\n\n              this.unexpected();\n            });\n            if (a) return a;\n          }\n\n          return super.parseSubscript(t, e, s, i, r);\n        }\n\n        parseNewArguments(t) {\n          if (this.isRelational(\"<\")) {\n            const e = this.tsTryParseAndCatch(() => {\n              const t = this.tsParseTypeArguments();\n              return this.match(n.parenL) || this.unexpected(), t;\n            });\n            e && (t.typeParameters = e);\n          }\n\n          super.parseNewArguments(t);\n        }\n\n        parseExprOp(t, e, s, i, r) {\n          if (st(n._in.binop) > i && !this.hasPrecedingLineBreak() && this.isContextual(\"as\")) {\n            const a = this.startNodeAt(e, s);\n            a.expression = t;\n            const n = this.tsTryNextParseConstantContext();\n            return a.typeAnnotation = n || this.tsNextThenParseType(), this.finishNode(a, \"TSAsExpression\"), this.parseExprOp(a, e, s, i, r);\n          }\n\n          return super.parseExprOp(t, e, s, i, r);\n        }\n\n        checkReservedWord(t, e, s, i) {}\n\n        checkDuplicateExports() {}\n\n        parseImport(t) {\n          if (this.match(n.name) || this.match(n.star) || this.match(n.braceL)) {\n            const e = this.lookahead();\n            if (this.match(n.name) && e.type === n.eq) return this.tsParseImportEqualsDeclaration(t);\n            !this.isContextual(\"type\") || e.type === n.comma || e.type === n.name && \"from\" === e.value ? t.importKind = \"value\" : (t.importKind = \"type\", this.next());\n          }\n\n          const e = super.parseImport(t);\n          return \"type\" === e.importKind && e.specifiers.length > 1 && \"ImportDefaultSpecifier\" === e.specifiers[0].type && this.raise(e.start, \"A type-only import can specify a default import or named bindings, but not both.\"), e;\n        }\n\n        parseExport(t) {\n          if (this.match(n._import)) return this.expect(n._import), this.tsParseImportEqualsDeclaration(t, !0);\n\n          if (this.eat(n.eq)) {\n            const e = t;\n            return e.expression = this.parseExpression(), this.semicolon(), this.finishNode(e, \"TSExportAssignment\");\n          }\n\n          if (this.eatContextual(\"as\")) {\n            const e = t;\n            return this.expectContextual(\"namespace\"), e.id = this.parseIdentifier(), this.semicolon(), this.finishNode(e, \"TSNamespaceExportDeclaration\");\n          }\n\n          return this.isContextual(\"type\") && this.lookahead().type === n.braceL ? (this.next(), t.exportKind = \"type\") : t.exportKind = \"value\", super.parseExport(t);\n        }\n\n        isAbstractClass() {\n          return this.isContextual(\"abstract\") && this.lookahead().type === n._class;\n        }\n\n        parseExportDefaultExpression() {\n          if (this.isAbstractClass()) {\n            const t = this.startNode();\n            return this.next(), this.parseClass(t, !0, !0), t.abstract = !0, t;\n          }\n\n          if (\"interface\" === this.state.value) {\n            const t = this.tsParseDeclaration(this.startNode(), this.state.value, !0);\n            if (t) return t;\n          }\n\n          return super.parseExportDefaultExpression();\n        }\n\n        parseStatementContent(t, e) {\n          if (this.state.type === n._const) {\n            const t = this.lookahead();\n\n            if (t.type === n.name && \"enum\" === t.value) {\n              const t = this.startNode();\n              return this.expect(n._const), this.expectContextual(\"enum\"), this.tsParseEnumDeclaration(t, !0);\n            }\n          }\n\n          return super.parseStatementContent(t, e);\n        }\n\n        parseAccessModifier() {\n          return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n        }\n\n        parseClassMember(t, e, s, i) {\n          this.tsParseModifiers(e, [\"declare\"]);\n          const r = this.parseAccessModifier();\n          r && (e.accessibility = r), this.tsParseModifiers(e, [\"declare\"]), super.parseClassMember(t, e, s, i);\n        }\n\n        parseClassMemberWithIsStatic(t, e, s, i, r) {\n          this.tsParseModifiers(e, [\"abstract\", \"readonly\", \"declare\"]);\n          const a = this.tsTryParseIndexSignature(e);\n          if (a) return t.body.push(a), e.abstract && this.raise(e.start, rt.IndexSignatureHasAbstract), i && this.raise(e.start, rt.IndexSignatureHasStatic), void (e.accessibility && this.raise(e.start, rt.IndexSignatureHasAccessibility, e.accessibility));\n          super.parseClassMemberWithIsStatic(t, e, s, i, r);\n        }\n\n        parsePostMemberNameModifiers(t) {\n          this.eat(n.question) && (t.optional = !0), t.readonly && this.match(n.parenL) && this.raise(t.start, rt.ClassMethodHasReadonly), t.declare && this.match(n.parenL) && this.raise(t.start, rt.ClassMethodHasDeclare);\n        }\n\n        parseExpressionStatement(t, e) {\n          return (\"Identifier\" === e.type ? this.tsParseExpressionStatement(t, e) : void 0) || super.parseExpressionStatement(t, e);\n        }\n\n        shouldParseExportDeclaration() {\n          return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();\n        }\n\n        parseConditional(t, e, s, i, r) {\n          if (!r || !this.match(n.question)) return super.parseConditional(t, e, s, i, r);\n          const a = this.tryParse(() => super.parseConditional(t, e, s, i));\n          return a.node ? (a.error && (this.state = a.failState), a.node) : (r.start = a.error.pos || this.state.start, t);\n        }\n\n        parseParenItem(t, e, s) {\n          if (t = super.parseParenItem(t, e, s), this.eat(n.question) && (t.optional = !0, this.resetEndLocation(t)), this.match(n.colon)) {\n            const i = this.startNodeAt(e, s);\n            return i.expression = t, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, \"TSTypeCastExpression\");\n          }\n\n          return t;\n        }\n\n        parseExportDeclaration(t) {\n          const e = this.state.start,\n                s = this.state.startLoc,\n                i = this.eatContextual(\"declare\");\n          let r;\n          return this.match(n.name) && (r = this.tsTryParseExportDeclaration()), r || (r = super.parseExportDeclaration(t)), r && (\"TSInterfaceDeclaration\" === r.type || \"TSTypeAliasDeclaration\" === r.type || i) && (t.exportKind = \"type\"), r && i && (this.resetStartLocation(r, e, s), r.declare = !0), r;\n        }\n\n        parseClassId(t, e, s) {\n          if ((!e || s) && this.isContextual(\"implements\")) return;\n          super.parseClassId(t, e, s, t.declare ? 1024 : 139);\n          const i = this.tsTryParseTypeParameters();\n          i && (t.typeParameters = i);\n        }\n\n        parseClassPropertyAnnotation(t) {\n          !t.optional && this.eat(n.bang) && (t.definite = !0);\n          const e = this.tsTryParseTypeAnnotation();\n          e && (t.typeAnnotation = e);\n        }\n\n        parseClassProperty(t) {\n          return this.parseClassPropertyAnnotation(t), t.declare && this.match(n.equal) && this.raise(this.state.start, rt.DeclareClassFieldHasInitializer), super.parseClassProperty(t);\n        }\n\n        parseClassPrivateProperty(t) {\n          return t.abstract && this.raise(t.start, rt.PrivateElementHasAbstract), t.accessibility && this.raise(t.start, rt.PrivateElementHasAccessibility, t.accessibility), this.parseClassPropertyAnnotation(t), super.parseClassPrivateProperty(t);\n        }\n\n        pushClassMethod(t, e, s, i, r, a) {\n          const n = this.tsTryParseTypeParameters();\n          n && (e.typeParameters = n), super.pushClassMethod(t, e, s, i, r, a);\n        }\n\n        pushClassPrivateMethod(t, e, s, i) {\n          const r = this.tsTryParseTypeParameters();\n          r && (e.typeParameters = r), super.pushClassPrivateMethod(t, e, s, i);\n        }\n\n        parseClassSuper(t) {\n          super.parseClassSuper(t), t.superClass && this.isRelational(\"<\") && (t.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual(\"implements\") && (t.implements = this.tsParseHeritageClause(\"implements\"));\n        }\n\n        parseObjPropValue(t) {\n          const s = this.tsTryParseTypeParameters();\n\n          for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            e[_key - 1] = arguments[_key];\n          }\n\n          s && (t.typeParameters = s), super.parseObjPropValue(t, ...e);\n        }\n\n        parseFunctionParams(t, e) {\n          const s = this.tsTryParseTypeParameters();\n          s && (t.typeParameters = s), super.parseFunctionParams(t, e);\n        }\n\n        parseVarId(t, e) {\n          super.parseVarId(t, e), \"Identifier\" === t.id.type && this.eat(n.bang) && (t.definite = !0);\n          const s = this.tsTryParseTypeAnnotation();\n          s && (t.id.typeAnnotation = s, this.resetEndLocation(t.id));\n        }\n\n        parseAsyncArrowFromCallExpression(t, e) {\n          return this.match(n.colon) && (t.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(t, e);\n        }\n\n        parseMaybeAssign() {\n          for (var _len2 = arguments.length, t = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            t[_key2] = arguments[_key2];\n          }\n\n          let e, s, i, r;\n\n          if (this.match(n.jsxTagStart)) {\n            if (e = this.state.clone(), s = this.tryParse(() => super.parseMaybeAssign(...t), e), !s.error) return s.node;\n            const {\n              context: i\n            } = this.state;\n            i[i.length - 1] === x.j_oTag ? i.length -= 2 : i[i.length - 1] === x.j_expr && (i.length -= 1);\n          }\n\n          if (!(s && s.error || this.isRelational(\"<\"))) return super.parseMaybeAssign(...t);\n          e = e || this.state.clone();\n          const a = this.tryParse(e => {\n            r = this.tsParseTypeParameters();\n            const s = super.parseMaybeAssign(...t);\n            return (\"ArrowFunctionExpression\" !== s.type || s.extra && s.extra.parenthesized) && e(), r && 0 !== r.params.length && this.resetStartLocationFromNode(s, r), s.typeParameters = r, s;\n          }, e);\n          if (!a.error && !a.aborted) return a.node;\n          if (!s && (it(!this.hasPlugin(\"jsx\")), i = this.tryParse(() => super.parseMaybeAssign(...t), e), !i.error)) return i.node;\n          if (s && s.node) return this.state = s.failState, s.node;\n          if (a.node) return this.state = a.failState, a.node;\n          if (i && i.node) return this.state = i.failState, i.node;\n          if (s && s.thrown) throw s.error;\n          if (a.thrown) throw a.error;\n          if (i && i.thrown) throw i.error;\n          throw s && s.error || a.error || i && i.error;\n        }\n\n        parseMaybeUnary(t) {\n          return !this.hasPlugin(\"jsx\") && this.isRelational(\"<\") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(t);\n        }\n\n        parseArrow(t) {\n          if (this.match(n.colon)) {\n            const e = this.tryParse(t => {\n              const e = this.tsParseTypeOrTypePredicateAnnotation(n.colon);\n              return !this.canInsertSemicolon() && this.match(n.arrow) || t(), e;\n            });\n            if (e.aborted) return;\n            e.thrown || (e.error && (this.state = e.failState), t.returnType = e.node);\n          }\n\n          return super.parseArrow(t);\n        }\n\n        parseAssignableListItemTypes(t) {\n          this.eat(n.question) && (\"Identifier\" !== t.type && this.raise(t.start, rt.PatternIsOptional), t.optional = !0);\n          const e = this.tsTryParseTypeAnnotation();\n          return e && (t.typeAnnotation = e), this.resetEndLocation(t), t;\n        }\n\n        toAssignable(t) {\n          switch (t.type) {\n            case \"TSTypeCastExpression\":\n              return super.toAssignable(this.typeCastToParameter(t));\n\n            case \"TSParameterProperty\":\n              return super.toAssignable(t);\n\n            case \"TSAsExpression\":\n            case \"TSNonNullExpression\":\n            case \"TSTypeAssertion\":\n              return t.expression = this.toAssignable(t.expression), t;\n\n            default:\n              return super.toAssignable(t);\n          }\n        }\n\n        checkLVal(t) {\n          let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n          let s = arguments.length > 2 ? arguments[2] : undefined;\n          let i = arguments.length > 3 ? arguments[3] : undefined;\n\n          switch (t.type) {\n            case \"TSTypeCastExpression\":\n              return;\n\n            case \"TSParameterProperty\":\n              return void this.checkLVal(t.parameter, e, s, \"parameter property\");\n\n            case \"TSAsExpression\":\n            case \"TSNonNullExpression\":\n            case \"TSTypeAssertion\":\n              return void this.checkLVal(t.expression, e, s, i);\n\n            default:\n              return void super.checkLVal(t, e, s, i);\n          }\n        }\n\n        parseBindingAtom() {\n          switch (this.state.type) {\n            case n._this:\n              return this.parseIdentifier(!0);\n\n            default:\n              return super.parseBindingAtom();\n          }\n        }\n\n        parseMaybeDecoratorArguments(t) {\n          if (this.isRelational(\"<\")) {\n            const e = this.tsParseTypeArguments();\n\n            if (this.match(n.parenL)) {\n              const s = super.parseMaybeDecoratorArguments(t);\n              return s.typeParameters = e, s;\n            }\n\n            this.unexpected(this.state.start, n.parenL);\n          }\n\n          return super.parseMaybeDecoratorArguments(t);\n        }\n\n        isClassMethod() {\n          return this.isRelational(\"<\") || super.isClassMethod();\n        }\n\n        isClassProperty() {\n          return this.match(n.bang) || this.match(n.colon) || super.isClassProperty();\n        }\n\n        parseMaybeDefault() {\n          const e = super.parseMaybeDefault(...arguments);\n          return \"AssignmentPattern\" === e.type && e.typeAnnotation && e.right.start < e.typeAnnotation.start && this.raise(e.typeAnnotation.start, rt.TypeAnnotationAfterAssign), e;\n        }\n\n        getTokenFromCode(t) {\n          return !this.state.inType || 62 !== t && 60 !== t ? super.getTokenFromCode(t) : this.finishOp(n.relational, 1);\n        }\n\n        toAssignableList(t) {\n          for (let e = 0; e < t.length; e++) {\n            const s = t[e];\n            if (s) switch (s.type) {\n              case \"TSTypeCastExpression\":\n                t[e] = this.typeCastToParameter(s);\n                break;\n\n              case \"TSAsExpression\":\n              case \"TSTypeAssertion\":\n                this.state.maybeInArrowParameters ? this.raise(s.start, rt.UnexpectedTypeCastInParameter) : t[e] = this.typeCastToParameter(s);\n            }\n          }\n\n          return super.toAssignableList(...arguments);\n        }\n\n        typeCastToParameter(t) {\n          return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end), t.expression;\n        }\n\n        toReferencedList(t, e) {\n          for (let e = 0; e < t.length; e++) {\n            const s = t[e];\n            s && \"TSTypeCastExpression\" === s.type && this.raise(s.start, rt.UnexpectedTypeAnnotation);\n          }\n\n          return t;\n        }\n\n        shouldParseArrow() {\n          return this.match(n.colon) || super.shouldParseArrow();\n        }\n\n        shouldParseAsyncArrow() {\n          return this.match(n.colon) || super.shouldParseAsyncArrow();\n        }\n\n        canHaveLeadingDecorator() {\n          return super.canHaveLeadingDecorator() || this.isAbstractClass();\n        }\n\n        jsxParseOpeningElementAfterName(t) {\n          if (this.isRelational(\"<\")) {\n            const e = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());\n            e && (t.typeParameters = e);\n          }\n\n          return super.jsxParseOpeningElementAfterName(t);\n        }\n\n        getGetterSetterExpectedParamCount(t) {\n          const e = super.getGetterSetterExpectedParamCount(t),\n                s = t.params[0];\n          return s && \"Identifier\" === s.type && \"this\" === s.name ? e + 1 : e;\n        }\n\n      },\n      v8intrinsic: t => class extends t {\n        parseV8Intrinsic() {\n          if (this.match(n.modulo)) {\n            const t = this.state.start,\n                  e = this.startNode();\n\n            if (this.eat(n.modulo), this.match(n.name)) {\n              const t = this.parseIdentifierName(this.state.start),\n                    s = this.createIdentifier(e, t);\n              if (s.type = \"V8IntrinsicIdentifier\", this.match(n.parenL)) return s;\n            }\n\n            this.unexpected(t);\n          }\n        }\n\n        parseExprAtom() {\n          return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n        }\n\n      },\n      placeholders: t => class extends t {\n        parsePlaceholder(t) {\n          if (this.match(n.placeholder)) {\n            const e = this.startNode();\n            return this.next(), this.assertNoSpace(\"Unexpected space in placeholder.\"), e.name = super.parseIdentifier(!0), this.assertNoSpace(\"Unexpected space in placeholder.\"), this.expect(n.placeholder), this.finishPlaceholder(e, t);\n          }\n        }\n\n        finishPlaceholder(t, e) {\n          const s = !(!t.expectedNode || \"Placeholder\" !== t.type);\n          return t.expectedNode = e, s ? t : this.finishNode(t, \"Placeholder\");\n        }\n\n        getTokenFromCode(t) {\n          return 37 === t && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(n.placeholder, 2) : super.getTokenFromCode(...arguments);\n        }\n\n        parseExprAtom() {\n          return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments);\n        }\n\n        parseIdentifier() {\n          return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(...arguments);\n        }\n\n        checkReservedWord(t) {\n          void 0 !== t && super.checkReservedWord(...arguments);\n        }\n\n        parseBindingAtom() {\n          return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments);\n        }\n\n        checkLVal(t) {\n          \"Placeholder\" !== t.type && super.checkLVal(...arguments);\n        }\n\n        toAssignable(t) {\n          return t && \"Placeholder\" === t.type && \"Expression\" === t.expectedNode ? (t.expectedNode = \"Pattern\", t) : super.toAssignable(...arguments);\n        }\n\n        verifyBreakContinue(t) {\n          t.label && \"Placeholder\" === t.label.type || super.verifyBreakContinue(...arguments);\n        }\n\n        parseExpressionStatement(t, e) {\n          if (\"Placeholder\" !== e.type || e.extra && e.extra.parenthesized) return super.parseExpressionStatement(...arguments);\n\n          if (this.match(n.colon)) {\n            const s = t;\n            return s.label = this.finishPlaceholder(e, \"Identifier\"), this.next(), s.body = this.parseStatement(\"label\"), this.finishNode(s, \"LabeledStatement\");\n          }\n\n          return this.semicolon(), t.name = e.name, this.finishPlaceholder(t, \"Statement\");\n        }\n\n        parseBlock() {\n          return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(...arguments);\n        }\n\n        parseFunctionId() {\n          return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(...arguments);\n        }\n\n        parseClass(t, e, s) {\n          const i = e ? \"ClassDeclaration\" : \"ClassExpression\";\n          this.next(), this.takeDecorators(t);\n          const r = this.parsePlaceholder(\"Identifier\");\n          if (r) {\n            if (this.match(n._extends) || this.match(n.placeholder) || this.match(n.braceL)) t.id = r;else {\n              if (s || !e) return t.id = null, t.body = this.finishPlaceholder(r, \"ClassBody\"), this.finishNode(t, i);\n              this.unexpected(null, \"A class name is required\");\n            }\n          } else this.parseClassId(t, e, s);\n          return this.parseClassSuper(t), t.body = this.parsePlaceholder(\"ClassBody\") || this.parseClassBody(!!t.superClass), this.finishNode(t, i);\n        }\n\n        parseExport(t) {\n          const e = this.parsePlaceholder(\"Identifier\");\n          if (!e) return super.parseExport(...arguments);\n          if (!this.isContextual(\"from\") && !this.match(n.comma)) return t.specifiers = [], t.source = null, t.declaration = this.finishPlaceholder(e, \"Declaration\"), this.finishNode(t, \"ExportNamedDeclaration\");\n          this.expectPlugin(\"exportDefaultFrom\");\n          const s = this.startNode();\n          return s.exported = e, t.specifiers = [this.finishNode(s, \"ExportDefaultSpecifier\")], super.parseExport(t);\n        }\n\n        maybeParseExportDefaultSpecifier(t) {\n          return !!(t.specifiers && t.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);\n        }\n\n        checkExport(t) {\n          const {\n            specifiers: e\n          } = t;\n          e && e.length && (t.specifiers = e.filter(t => \"Placeholder\" === t.exported.type)), super.checkExport(t), t.specifiers = e;\n        }\n\n        parseImport(t) {\n          const e = this.parsePlaceholder(\"Identifier\");\n          if (!e) return super.parseImport(...arguments);\n          if (t.specifiers = [], !this.isContextual(\"from\") && !this.match(n.comma)) return t.source = this.finishPlaceholder(e, \"StringLiteral\"), this.semicolon(), this.finishNode(t, \"ImportDeclaration\");\n          const s = this.startNodeAtNode(e);\n\n          if (s.local = e, this.finishNode(s, \"ImportDefaultSpecifier\"), t.specifiers.push(s), this.eat(n.comma)) {\n            this.maybeParseStarImportSpecifier(t) || this.parseNamedImportSpecifiers(t);\n          }\n\n          return this.expectContextual(\"from\"), t.source = this.parseImportSource(), this.semicolon(), this.finishNode(t, \"ImportDeclaration\");\n        }\n\n        parseImportSource() {\n          return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource(...arguments);\n        }\n\n      }\n    },\n          ct = Object.keys(pt),\n          ut = {\n      sourceType: \"script\",\n      sourceFilename: void 0,\n      startLine: 1,\n      allowAwaitOutsideFunction: !1,\n      allowReturnOutsideFunction: !1,\n      allowImportExportEverywhere: !1,\n      allowSuperOutsideMethod: !1,\n      allowUndeclaredExports: !1,\n      plugins: [],\n      strictMode: null,\n      ranges: !1,\n      tokens: !1,\n      createParenthesizedExpressions: !1,\n      errorRecovery: !1\n    };\n\n    class lt {\n      constructor() {\n        this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.inParameters = !1, this.maybeInArrowParameters = !1, this.maybeInAsyncArrowHead = !1, this.inPipeline = !1, this.inType = !1, this.noAnonFunctionType = !1, this.inPropertyName = !1, this.hasFlowComment = !1, this.isIterator = !1, this.topicContext = {\n          maxNumOfResolvableTopics: 0,\n          maxTopicIndex: null\n        }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], this.decoratorStack = [[]], this.yieldPos = -1, this.awaitPos = -1, this.comments = [], this.trailingComments = [], this.leadingComments = [], this.commentStack = [], this.commentPreviousNode = null, this.pos = 0, this.lineStart = 0, this.type = n.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [x.braceStatement], this.exprAllowed = !0, this.containsEsc = !1, this.octalPositions = [], this.exportedIdentifiers = [], this.tokensLength = 0;\n      }\n\n      init(t) {\n        this.strict = !1 !== t.strictMode && \"module\" === t.sourceType, this.curLine = t.startLine, this.startLoc = this.endLoc = this.curPosition();\n      }\n\n      curPosition() {\n        return new l(this.curLine, this.pos - this.lineStart);\n      }\n\n      clone(t) {\n        const e = new lt(),\n              s = Object.keys(this);\n\n        for (let i = 0, r = s.length; i < r; i++) {\n          const r = s[i];\n          let a = this[r];\n          !t && Array.isArray(a) && (a = a.slice()), e[r] = a;\n        }\n\n        return e;\n      }\n\n    }\n\n    var dt = function (t) {\n      return t >= 48 && t <= 57;\n    };\n\n    const mt = new Set([\"g\", \"m\", \"s\", \"i\", \"y\", \"u\"]),\n          ft = {\n      decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n      hex: [46, 88, 95, 120]\n    },\n          Dt = {\n      bin: [48, 49]\n    };\n    Dt.oct = [...Dt.bin, 50, 51, 52, 53, 54, 55], Dt.dec = [...Dt.oct, 56, 57], Dt.hex = [...Dt.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];\n\n    class yt {\n      constructor(t) {\n        this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new d(t.startLoc, t.endLoc);\n      }\n\n    }\n\n    class xt {\n      constructor() {\n        this.shorthandAssign = -1, this.doubleProto = -1;\n      }\n\n    }\n\n    class gt {\n      constructor(t, e, s) {\n        this.type = \"\", this.start = e, this.end = 0, this.loc = new d(s), t && t.options.ranges && (this.range = [e, 0]), t && t.filename && (this.loc.filename = t.filename);\n      }\n\n      __clone() {\n        const t = new gt(),\n              e = Object.keys(this);\n\n        for (let s = 0, i = e.length; s < i; s++) {\n          const i = e[s];\n          \"leadingComments\" !== i && \"trailingComments\" !== i && \"innerComments\" !== i && (t[i] = this[i]);\n        }\n\n        return t;\n      }\n\n    }\n\n    const Pt = t => \"ParenthesizedExpression\" === t.type ? Pt(t.expression) : t;\n\n    const Et = {\n      kind: \"loop\"\n    },\n          Ct = {\n      kind: \"switch\"\n    };\n\n    class bt {\n      constructor() {\n        this.privateNames = new Set(), this.loneAccessors = new Map(), this.undefinedPrivateNames = new Map();\n      }\n\n    }\n\n    class Tt {\n      constructor(t) {\n        this.stack = [], this.undefinedPrivateNames = new Map(), this.raise = t;\n      }\n\n      current() {\n        return this.stack[this.stack.length - 1];\n      }\n\n      enter() {\n        this.stack.push(new bt());\n      }\n\n      exit() {\n        const t = this.stack.pop(),\n              e = this.current();\n\n        for (let s = 0, i = Array.from(t.undefinedPrivateNames); s < i.length; s++) {\n          const [t, r] = i[s];\n          e ? e.undefinedPrivateNames.has(t) || e.undefinedPrivateNames.set(t, r) : this.raise(r, f.InvalidPrivateFieldResolution, t);\n        }\n      }\n\n      declarePrivateName(t, e, s) {\n        const i = this.current();\n        let r = i.privateNames.has(t);\n\n        if (3 & e) {\n          const s = r && i.loneAccessors.get(t);\n\n          if (s) {\n            const a = 4 & s,\n                  n = 4 & e;\n            r = (3 & s) === (3 & e) || a !== n, r || i.loneAccessors.delete(t);\n          } else r || i.loneAccessors.set(t, e);\n        }\n\n        r && this.raise(s, f.PrivateNameRedeclaration, t), i.privateNames.add(t), i.undefinedPrivateNames.delete(t);\n      }\n\n      usePrivateName(t, e) {\n        let s;\n\n        for (let e = 0, i = this.stack; e < i.length; e++) if (s = i[e], s.privateNames.has(t)) return;\n\n        s ? s.undefinedPrivateNames.set(t, e) : this.raise(e, f.InvalidPrivateFieldResolution, t);\n      }\n\n    }\n\n    class At extends class extends class extends class extends class extends class extends class extends class extends class extends class {\n      constructor() {\n        this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;\n      }\n\n      hasPlugin(t) {\n        return this.plugins.has(t);\n      }\n\n      getPluginOption(t, e) {\n        if (this.hasPlugin(t)) return this.plugins.get(t)[e];\n      }\n\n    } {\n      addComment(t) {\n        this.filename && (t.loc.filename = this.filename), this.state.trailingComments.push(t), this.state.leadingComments.push(t);\n      }\n\n      adjustCommentsAfterTrailingComma(t, e, s) {\n        if (0 === this.state.leadingComments.length) return;\n        let i = null,\n            r = e.length;\n\n        for (; null === i && r > 0;) i = e[--r];\n\n        if (null === i) return;\n\n        for (let t = 0; t < this.state.leadingComments.length; t++) this.state.leadingComments[t].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(t, 1), t--);\n\n        const a = [];\n\n        for (let e = 0; e < this.state.leadingComments.length; e++) {\n          const i = this.state.leadingComments[e];\n          i.end < t.end ? (a.push(i), s || (this.state.leadingComments.splice(e, 1), e--)) : (void 0 === t.trailingComments && (t.trailingComments = []), t.trailingComments.push(i));\n        }\n\n        s && (this.state.leadingComments = []), a.length > 0 ? i.trailingComments = a : void 0 !== i.trailingComments && (i.trailingComments = []);\n      }\n\n      processComment(t) {\n        if (\"Program\" === t.type && t.body.length > 0) return;\n        const e = this.state.commentStack;\n        let s, i, r, a, n;\n        if (this.state.trailingComments.length > 0) this.state.trailingComments[0].start >= t.end ? (r = this.state.trailingComments, this.state.trailingComments = []) : this.state.trailingComments.length = 0;else if (e.length > 0) {\n          const s = m(e);\n          s.trailingComments && s.trailingComments[0].start >= t.end && (r = s.trailingComments, delete s.trailingComments);\n        }\n\n        for (e.length > 0 && m(e).start >= t.start && (s = e.pop()); e.length > 0 && m(e).start >= t.start;) i = e.pop();\n\n        if (!i && s && (i = s), s) switch (t.type) {\n          case \"ObjectExpression\":\n            this.adjustCommentsAfterTrailingComma(t, t.properties);\n            break;\n\n          case \"ObjectPattern\":\n            this.adjustCommentsAfterTrailingComma(t, t.properties, !0);\n            break;\n\n          case \"CallExpression\":\n            this.adjustCommentsAfterTrailingComma(t, t.arguments);\n            break;\n\n          case \"ArrayExpression\":\n            this.adjustCommentsAfterTrailingComma(t, t.elements);\n            break;\n\n          case \"ArrayPattern\":\n            this.adjustCommentsAfterTrailingComma(t, t.elements, !0);\n        } else this.state.commentPreviousNode && (\"ImportSpecifier\" === this.state.commentPreviousNode.type && \"ImportSpecifier\" !== t.type || \"ExportSpecifier\" === this.state.commentPreviousNode.type && \"ExportSpecifier\" !== t.type) && this.adjustCommentsAfterTrailingComma(t, [this.state.commentPreviousNode]);\n\n        if (i) {\n          if (i.leadingComments) if (i !== t && i.leadingComments.length > 0 && m(i.leadingComments).end <= t.start) t.leadingComments = i.leadingComments, delete i.leadingComments;else for (a = i.leadingComments.length - 2; a >= 0; --a) if (i.leadingComments[a].end <= t.start) {\n            t.leadingComments = i.leadingComments.splice(0, a + 1);\n            break;\n          }\n        } else if (this.state.leadingComments.length > 0) if (m(this.state.leadingComments).end <= t.start) {\n          if (this.state.commentPreviousNode) for (n = 0; n < this.state.leadingComments.length; n++) this.state.leadingComments[n].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(n, 1), n--);\n          this.state.leadingComments.length > 0 && (t.leadingComments = this.state.leadingComments, this.state.leadingComments = []);\n        } else {\n          for (a = 0; a < this.state.leadingComments.length && !(this.state.leadingComments[a].end > t.start); a++);\n\n          const e = this.state.leadingComments.slice(0, a);\n          e.length && (t.leadingComments = e), r = this.state.leadingComments.slice(a), 0 === r.length && (r = null);\n        }\n\n        this.state.commentPreviousNode = t, r && (r.length && r[0].start >= t.start && m(r).end <= t.end ? t.innerComments = r : t.trailingComments = r), e.push(t);\n      }\n\n    } {\n      getLocationForPosition(t) {\n        let e;\n        return e = t === this.state.start ? this.state.startLoc : t === this.state.lastTokStart ? this.state.lastTokStartLoc : t === this.state.end ? this.state.endLoc : t === this.state.lastTokEnd ? this.state.lastTokEndLoc : function (t, e) {\n          let s,\n              i = 1,\n              r = 0;\n\n          for (h.lastIndex = 0; (s = h.exec(t)) && s.index < e;) i++, r = h.lastIndex;\n\n          return new l(i, e - r);\n        }(this.input, t), e;\n      }\n\n      raise(t, e) {\n        for (var _len3 = arguments.length, s = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n          s[_key3 - 2] = arguments[_key3];\n        }\n\n        return this.raiseWithData(t, void 0, e, ...s);\n      }\n\n      raiseWithData(t, e, s) {\n        for (var _len4 = arguments.length, i = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n          i[_key4 - 3] = arguments[_key4];\n        }\n\n        const r = this.getLocationForPosition(t),\n              a = s.replace(/%(\\d+)/g, (t, e) => i[e]) + \" (\".concat(r.line, \":\").concat(r.column, \")\");\n        return this._raise(Object.assign({\n          loc: r,\n          pos: t\n        }, e), a);\n      }\n\n      _raise(t, e) {\n        const s = new SyntaxError(e);\n        if (Object.assign(s, t), this.options.errorRecovery) return this.isLookahead || this.state.errors.push(s), s;\n        throw s;\n      }\n\n    } {\n      constructor(t, e) {\n        super(), this.tokens = [], this.state = new lt(), this.state.init(t), this.input = e, this.length = e.length, this.isLookahead = !1;\n      }\n\n      pushToken(t) {\n        this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;\n      }\n\n      next() {\n        this.isLookahead || (this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new yt(this.state))), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();\n      }\n\n      eat(t) {\n        return !!this.match(t) && (this.next(), !0);\n      }\n\n      match(t) {\n        return this.state.type === t;\n      }\n\n      lookahead() {\n        const t = this.state;\n        this.state = t.clone(!0), this.isLookahead = !0, this.next(), this.isLookahead = !1;\n        const e = this.state;\n        return this.state = t, e;\n      }\n\n      nextTokenStart() {\n        const t = this.state.pos;\n        return c.lastIndex = t, t + c.exec(this.input)[0].length;\n      }\n\n      lookaheadCharCode() {\n        return this.input.charCodeAt(this.nextTokenStart());\n      }\n\n      setStrict(t) {\n        if (this.state.strict = t, this.match(n.num) || this.match(n.string)) {\n          for (this.state.pos = this.state.start; this.state.pos < this.state.lineStart;) this.state.lineStart = this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1, --this.state.curLine;\n\n          this.nextToken();\n        }\n      }\n\n      curContext() {\n        return this.state.context[this.state.context.length - 1];\n      }\n\n      nextToken() {\n        const t = this.curContext();\n        if (t && t.preserveSpace || this.skipSpace(), this.state.octalPositions = [], this.state.start = this.state.pos, this.state.startLoc = this.state.curPosition(), this.state.pos >= this.length) return void this.finishToken(n.eof);\n        const e = null == t ? void 0 : t.override;\n        e ? e(this) : this.getTokenFromCode(this.input.codePointAt(this.state.pos));\n      }\n\n      pushComment(t, e, s, i, r, a) {\n        const n = {\n          type: t ? \"CommentBlock\" : \"CommentLine\",\n          value: e,\n          start: s,\n          end: i,\n          loc: new d(r, a)\n        };\n        this.options.tokens && this.pushToken(n), this.state.comments.push(n), this.addComment(n);\n      }\n\n      skipBlockComment() {\n        const t = this.state.curPosition(),\n              e = this.state.pos,\n              s = this.input.indexOf(\"*/\", this.state.pos + 2);\n        if (-1 === s) throw this.raise(e, f.UnterminatedComment);\n        let i;\n\n        for (this.state.pos = s + 2, h.lastIndex = e; (i = h.exec(this.input)) && i.index < this.state.pos;) ++this.state.curLine, this.state.lineStart = i.index + i[0].length;\n\n        this.isLookahead || this.pushComment(!0, this.input.slice(e + 2, s), e, this.state.pos, t, this.state.curPosition());\n      }\n\n      skipLineComment(t) {\n        const e = this.state.pos,\n              s = this.state.curPosition();\n        let i = this.input.charCodeAt(this.state.pos += t);\n        if (this.state.pos < this.length) for (; !p(i) && ++this.state.pos < this.length;) i = this.input.charCodeAt(this.state.pos);\n        this.isLookahead || this.pushComment(!1, this.input.slice(e + t, this.state.pos), e, this.state.pos, s, this.state.curPosition());\n      }\n\n      skipSpace() {\n        t: for (; this.state.pos < this.length;) {\n          const t = this.input.charCodeAt(this.state.pos);\n\n          switch (t) {\n            case 32:\n            case 160:\n            case 9:\n              ++this.state.pos;\n              break;\n\n            case 13:\n              10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;\n\n            case 10:\n            case 8232:\n            case 8233:\n              ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;\n              break;\n\n            case 47:\n              switch (this.input.charCodeAt(this.state.pos + 1)) {\n                case 42:\n                  this.skipBlockComment();\n                  break;\n\n                case 47:\n                  this.skipLineComment(2);\n                  break;\n\n                default:\n                  break t;\n              }\n\n              break;\n\n            default:\n              if (!u(t)) break t;\n              ++this.state.pos;\n          }\n        }\n      }\n\n      finishToken(t, e) {\n        this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();\n        const s = this.state.type;\n        this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s);\n      }\n\n      readToken_numberSign() {\n        if (0 === this.state.pos && this.readToken_interpreter()) return;\n        const t = this.state.pos + 1,\n              e = this.input.charCodeAt(t);\n        if (e >= 48 && e <= 57) throw this.raise(this.state.pos, f.UnexpectedDigitAfterHash);\n\n        if (!this.hasPlugin(\"recordAndTuple\") || 123 !== e && 91 !== e) {\n          if (!this.hasPlugin(\"classPrivateProperties\") && !this.hasPlugin(\"classPrivateMethods\") && \"smart\" !== this.getPluginOption(\"pipelineOperator\", \"proposal\")) throw this.raise(this.state.pos, f.InvalidOrUnexpectedToken, \"#\");\n          this.finishOp(n.hash, 1);\n        } else {\n          if (\"hash\" !== this.getPluginOption(\"recordAndTuple\", \"syntaxType\")) throw this.raise(this.state.pos, 123 === e ? f.RecordExpressionHashIncorrectStartSyntaxType : f.TupleExpressionHashIncorrectStartSyntaxType);\n          123 === e ? this.finishToken(n.braceHashL) : this.finishToken(n.bracketHashL), this.state.pos += 2;\n        }\n      }\n\n      readToken_dot() {\n        const t = this.input.charCodeAt(this.state.pos + 1);\n        t >= 48 && t <= 57 ? this.readNumber(!0) : 46 === t && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(n.ellipsis)) : (++this.state.pos, this.finishToken(n.dot));\n      }\n\n      readToken_slash() {\n        if (this.state.exprAllowed && !this.state.inType) return ++this.state.pos, void this.readRegexp();\n        61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(n.assign, 2) : this.finishOp(n.slash, 1);\n      }\n\n      readToken_interpreter() {\n        if (0 !== this.state.pos || this.length < 2) return !1;\n        let t = this.input.charCodeAt(this.state.pos + 1);\n        if (33 !== t) return !1;\n        const e = this.state.pos;\n\n        for (this.state.pos += 1; !p(t) && ++this.state.pos < this.length;) t = this.input.charCodeAt(this.state.pos);\n\n        const s = this.input.slice(e + 2, this.state.pos);\n        return this.finishToken(n.interpreterDirective, s), !0;\n      }\n\n      readToken_mult_modulo(t) {\n        let e = 42 === t ? n.star : n.modulo,\n            s = 1,\n            i = this.input.charCodeAt(this.state.pos + 1);\n        const r = this.state.exprAllowed;\n        42 === t && 42 === i && (s++, i = this.input.charCodeAt(this.state.pos + 2), e = n.exponent), 61 !== i || r || (s++, e = n.assign), this.finishOp(e, s);\n      }\n\n      readToken_pipe_amp(t) {\n        const e = this.input.charCodeAt(this.state.pos + 1);\n\n        if (e !== t) {\n          if (124 === t) {\n            if (62 === e) return void this.finishOp(n.pipeline, 2);\n\n            if (this.hasPlugin(\"recordAndTuple\") && 125 === e) {\n              if (\"bar\" !== this.getPluginOption(\"recordAndTuple\", \"syntaxType\")) throw this.raise(this.state.pos, f.RecordExpressionBarIncorrectEndSyntaxType);\n              return void this.finishOp(n.braceBarR, 2);\n            }\n\n            if (this.hasPlugin(\"recordAndTuple\") && 93 === e) {\n              if (\"bar\" !== this.getPluginOption(\"recordAndTuple\", \"syntaxType\")) throw this.raise(this.state.pos, f.TupleExpressionBarIncorrectEndSyntaxType);\n              return void this.finishOp(n.bracketBarR, 2);\n            }\n          }\n\n          61 !== e ? this.finishOp(124 === t ? n.bitwiseOR : n.bitwiseAND, 1) : this.finishOp(n.assign, 2);\n        } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(n.assign, 3) : this.finishOp(124 === t ? n.logicalOR : n.logicalAND, 2);\n      }\n\n      readToken_caret() {\n        61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(n.assign, 2) : this.finishOp(n.bitwiseXOR, 1);\n      }\n\n      readToken_plus_min(t) {\n        const e = this.input.charCodeAt(this.state.pos + 1);\n        if (e === t) return 45 !== e || this.inModule || 62 !== this.input.charCodeAt(this.state.pos + 2) || 0 !== this.state.lastTokEnd && !o.test(this.input.slice(this.state.lastTokEnd, this.state.pos)) ? void this.finishOp(n.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), void this.nextToken());\n        61 === e ? this.finishOp(n.assign, 2) : this.finishOp(n.plusMin, 1);\n      }\n\n      readToken_lt_gt(t) {\n        const e = this.input.charCodeAt(this.state.pos + 1);\n        let s = 1;\n        return e === t ? (s = 62 === t && 62 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.state.pos + s) ? void this.finishOp(n.assign, s + 1) : void this.finishOp(n.bitShift, s)) : 33 !== e || 60 !== t || this.inModule || 45 !== this.input.charCodeAt(this.state.pos + 2) || 45 !== this.input.charCodeAt(this.state.pos + 3) ? (61 === e && (s = 2), void this.finishOp(n.relational, s)) : (this.skipLineComment(4), this.skipSpace(), void this.nextToken());\n      }\n\n      readToken_eq_excl(t) {\n        const e = this.input.charCodeAt(this.state.pos + 1);\n        if (61 !== e) return 61 === t && 62 === e ? (this.state.pos += 2, void this.finishToken(n.arrow)) : void this.finishOp(61 === t ? n.eq : n.bang, 1);\n        this.finishOp(n.equality, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);\n      }\n\n      readToken_question() {\n        const t = this.input.charCodeAt(this.state.pos + 1),\n              e = this.input.charCodeAt(this.state.pos + 2);\n        63 !== t || this.state.inType ? 46 !== t || e >= 48 && e <= 57 ? (++this.state.pos, this.finishToken(n.question)) : (this.state.pos += 2, this.finishToken(n.questionDot)) : 61 === e ? this.finishOp(n.assign, 3) : this.finishOp(n.nullishCoalescing, 2);\n      }\n\n      getTokenFromCode(t) {\n        switch (t) {\n          case 46:\n            return void this.readToken_dot();\n\n          case 40:\n            return ++this.state.pos, void this.finishToken(n.parenL);\n\n          case 41:\n            return ++this.state.pos, void this.finishToken(n.parenR);\n\n          case 59:\n            return ++this.state.pos, void this.finishToken(n.semi);\n\n          case 44:\n            return ++this.state.pos, void this.finishToken(n.comma);\n\n          case 91:\n            if (this.hasPlugin(\"recordAndTuple\") && 124 === this.input.charCodeAt(this.state.pos + 1)) {\n              if (\"bar\" !== this.getPluginOption(\"recordAndTuple\", \"syntaxType\")) throw this.raise(this.state.pos, f.TupleExpressionBarIncorrectStartSyntaxType);\n              this.finishToken(n.bracketBarL), this.state.pos += 2;\n            } else ++this.state.pos, this.finishToken(n.bracketL);\n\n            return;\n\n          case 93:\n            return ++this.state.pos, void this.finishToken(n.bracketR);\n\n          case 123:\n            if (this.hasPlugin(\"recordAndTuple\") && 124 === this.input.charCodeAt(this.state.pos + 1)) {\n              if (\"bar\" !== this.getPluginOption(\"recordAndTuple\", \"syntaxType\")) throw this.raise(this.state.pos, f.RecordExpressionBarIncorrectStartSyntaxType);\n              this.finishToken(n.braceBarL), this.state.pos += 2;\n            } else ++this.state.pos, this.finishToken(n.braceL);\n\n            return;\n\n          case 125:\n            return ++this.state.pos, void this.finishToken(n.braceR);\n\n          case 58:\n            return void (this.hasPlugin(\"functionBind\") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(n.doubleColon, 2) : (++this.state.pos, this.finishToken(n.colon)));\n\n          case 63:\n            return void this.readToken_question();\n\n          case 96:\n            return ++this.state.pos, void this.finishToken(n.backQuote);\n\n          case 48:\n            {\n              const t = this.input.charCodeAt(this.state.pos + 1);\n              if (120 === t || 88 === t) return void this.readRadixNumber(16);\n              if (111 === t || 79 === t) return void this.readRadixNumber(8);\n              if (98 === t || 66 === t) return void this.readRadixNumber(2);\n            }\n\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n            return void this.readNumber(!1);\n\n          case 34:\n          case 39:\n            return void this.readString(t);\n\n          case 47:\n            return void this.readToken_slash();\n\n          case 37:\n          case 42:\n            return void this.readToken_mult_modulo(t);\n\n          case 124:\n          case 38:\n            return void this.readToken_pipe_amp(t);\n\n          case 94:\n            return void this.readToken_caret();\n\n          case 43:\n          case 45:\n            return void this.readToken_plus_min(t);\n\n          case 60:\n          case 62:\n            return void this.readToken_lt_gt(t);\n\n          case 61:\n          case 33:\n            return void this.readToken_eq_excl(t);\n\n          case 126:\n            return void this.finishOp(n.tilde, 1);\n\n          case 64:\n            return ++this.state.pos, void this.finishToken(n.at);\n\n          case 35:\n            return void this.readToken_numberSign();\n\n          case 92:\n            return void this.readWord();\n\n          default:\n            if (w(t)) return void this.readWord();\n        }\n\n        throw this.raise(this.state.pos, f.InvalidOrUnexpectedToken, String.fromCodePoint(t));\n      }\n\n      finishOp(t, e) {\n        const s = this.input.slice(this.state.pos, this.state.pos + e);\n        this.state.pos += e, this.finishToken(t, s);\n      }\n\n      readRegexp() {\n        const t = this.state.pos;\n        let e, s;\n\n        for (;;) {\n          if (this.state.pos >= this.length) throw this.raise(t, f.UnterminatedRegExp);\n          const i = this.input.charAt(this.state.pos);\n          if (o.test(i)) throw this.raise(t, f.UnterminatedRegExp);\n          if (e) e = !1;else {\n            if (\"[\" === i) s = !0;else if (\"]\" === i && s) s = !1;else if (\"/\" === i && !s) break;\n            e = \"\\\\\" === i;\n          }\n          ++this.state.pos;\n        }\n\n        const i = this.input.slice(t, this.state.pos);\n        ++this.state.pos;\n        let r = \"\";\n\n        for (; this.state.pos < this.length;) {\n          const t = this.input[this.state.pos],\n                e = this.input.codePointAt(this.state.pos);\n          if (mt.has(t)) r.indexOf(t) > -1 && this.raise(this.state.pos + 1, f.DuplicateRegExpFlags);else {\n            if (!S(e) && 92 !== e) break;\n            this.raise(this.state.pos + 1, f.MalformedRegExpFlags);\n          }\n          ++this.state.pos, r += t;\n        }\n\n        this.finishToken(n.regexp, {\n          pattern: i,\n          flags: r\n        });\n      }\n\n      readInt(t, e, s) {\n        let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n        const r = this.state.pos,\n              a = 16 === t ? ft.hex : ft.decBinOct,\n              n = 16 === t ? Dt.hex : 10 === t ? Dt.dec : 8 === t ? Dt.oct : Dt.bin;\n        let o = !1,\n            h = 0;\n\n        for (let r = 0, p = null == e ? 1 / 0 : e; r < p; ++r) {\n          const e = this.input.charCodeAt(this.state.pos);\n          let p;\n\n          if (this.hasPlugin(\"numericSeparator\") && 95 === e) {\n            const t = this.input.charCodeAt(this.state.pos - 1),\n                  e = this.input.charCodeAt(this.state.pos + 1);\n            -1 === n.indexOf(e) ? this.raise(this.state.pos, f.UnexpectedNumericSeparator) : (a.indexOf(t) > -1 || a.indexOf(e) > -1 || Number.isNaN(e)) && this.raise(this.state.pos, f.UnexpectedNumericSeparator), i || this.raise(this.state.pos, f.NumericSeparatorInEscapeSequence), ++this.state.pos;\n          } else {\n            if (p = e >= 97 ? e - 97 + 10 : e >= 65 ? e - 65 + 10 : dt(e) ? e - 48 : 1 / 0, p >= t) if (this.options.errorRecovery && p <= 9) p = 0, this.raise(this.state.start + r + 2, f.InvalidDigit, t);else {\n              if (!s) break;\n              p = 0, o = !0;\n            }\n            ++this.state.pos, h = h * t + p;\n          }\n        }\n\n        return this.state.pos === r || null != e && this.state.pos - r !== e || o ? null : h;\n      }\n\n      readRadixNumber(t) {\n        const e = this.state.pos;\n        let s = !1;\n        this.state.pos += 2;\n        const i = this.readInt(t);\n        if (null == i && this.raise(this.state.start + 2, f.InvalidDigit, t), 110 === this.input.charCodeAt(this.state.pos) && (++this.state.pos, s = !0), w(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, f.NumberIdentifier);\n\n        if (s) {\n          const t = this.input.slice(e, this.state.pos).replace(/[_n]/g, \"\");\n          this.finishToken(n.bigint, t);\n        } else this.finishToken(n.num, i);\n      }\n\n      readNumber(t) {\n        const e = this.state.pos;\n        let s = !1,\n            i = !1,\n            r = !1;\n        t || null !== this.readInt(10) || this.raise(e, f.InvalidNumber);\n        let a = this.state.pos - e >= 2 && 48 === this.input.charCodeAt(e);\n        a && (this.state.strict && this.raise(e, f.StrictOctalLiteral), /[89]/.test(this.input.slice(e, this.state.pos)) && (a = !1, r = !0));\n        let o = this.input.charCodeAt(this.state.pos);\n\n        if (46 !== o || a || (++this.state.pos, this.readInt(10), s = !0, o = this.input.charCodeAt(this.state.pos)), 69 !== o && 101 !== o || a || (o = this.input.charCodeAt(++this.state.pos), 43 !== o && 45 !== o || ++this.state.pos, null === this.readInt(10) && this.raise(e, \"Invalid number\"), s = !0, o = this.input.charCodeAt(this.state.pos)), this.hasPlugin(\"numericSeparator\") && (a || r)) {\n          const t = this.input.slice(e, this.state.pos).indexOf(\"_\");\n          t > 0 && this.raise(t + e, f.ZeroDigitNumericSeparator);\n        }\n\n        if (110 === o && ((s || a || r) && this.raise(e, \"Invalid BigIntLiteral\"), ++this.state.pos, i = !0), w(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, f.NumberIdentifier);\n        const h = this.input.slice(e, this.state.pos).replace(/[_n]/g, \"\");\n        if (i) return void this.finishToken(n.bigint, h);\n        const p = a ? parseInt(h, 8) : parseFloat(h);\n        this.finishToken(n.num, p);\n      }\n\n      readCodePoint(t) {\n        let e;\n\n        if (123 === this.input.charCodeAt(this.state.pos)) {\n          const s = ++this.state.pos;\n\n          if (e = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, !0, t), ++this.state.pos, null !== e && e > 1114111) {\n            if (!t) return null;\n            this.raise(s, f.InvalidCodePoint);\n          }\n        } else e = this.readHexChar(4, !1, t);\n\n        return e;\n      }\n\n      readString(t) {\n        let e = \"\",\n            s = ++this.state.pos;\n\n        for (;;) {\n          if (this.state.pos >= this.length) throw this.raise(this.state.start, f.UnterminatedString);\n          const i = this.input.charCodeAt(this.state.pos);\n          if (i === t) break;\n          if (92 === i) e += this.input.slice(s, this.state.pos), e += this.readEscapedChar(!1), s = this.state.pos;else if (8232 === i || 8233 === i) ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;else {\n            if (p(i)) throw this.raise(this.state.start, f.UnterminatedString);\n            ++this.state.pos;\n          }\n        }\n\n        e += this.input.slice(s, this.state.pos++), this.finishToken(n.string, e);\n      }\n\n      readTmplToken() {\n        let t = \"\",\n            e = this.state.pos,\n            s = !1;\n\n        for (;;) {\n          if (this.state.pos >= this.length) throw this.raise(this.state.start, f.UnterminatedTemplate);\n          const i = this.input.charCodeAt(this.state.pos);\n          if (96 === i || 36 === i && 123 === this.input.charCodeAt(this.state.pos + 1)) return this.state.pos === this.state.start && this.match(n.template) ? 36 === i ? (this.state.pos += 2, void this.finishToken(n.dollarBraceL)) : (++this.state.pos, void this.finishToken(n.backQuote)) : (t += this.input.slice(e, this.state.pos), void this.finishToken(n.template, s ? null : t));\n\n          if (92 === i) {\n            t += this.input.slice(e, this.state.pos);\n            const i = this.readEscapedChar(!0);\n            null === i ? s = !0 : t += i, e = this.state.pos;\n          } else if (p(i)) {\n            switch (t += this.input.slice(e, this.state.pos), ++this.state.pos, i) {\n              case 13:\n                10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;\n\n              case 10:\n                t += \"\\n\";\n                break;\n\n              default:\n                t += String.fromCharCode(i);\n            }\n\n            ++this.state.curLine, this.state.lineStart = this.state.pos, e = this.state.pos;\n          } else ++this.state.pos;\n        }\n      }\n\n      readEscapedChar(t) {\n        const e = !t,\n              s = this.input.charCodeAt(++this.state.pos);\n\n        switch (++this.state.pos, s) {\n          case 110:\n            return \"\\n\";\n\n          case 114:\n            return \"\\r\";\n\n          case 120:\n            {\n              const t = this.readHexChar(2, !1, e);\n              return null === t ? null : String.fromCharCode(t);\n            }\n\n          case 117:\n            {\n              const t = this.readCodePoint(e);\n              return null === t ? null : String.fromCodePoint(t);\n            }\n\n          case 116:\n            return \"\\t\";\n\n          case 98:\n            return \"\\b\";\n\n          case 118:\n            return \"\\v\";\n\n          case 102:\n            return \"\\f\";\n\n          case 13:\n            10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos;\n\n          case 10:\n            this.state.lineStart = this.state.pos, ++this.state.curLine;\n\n          case 8232:\n          case 8233:\n            return \"\";\n\n          case 56:\n          case 57:\n            if (t) return null;\n\n          default:\n            if (s >= 48 && s <= 55) {\n              const e = this.state.pos - 1;\n              let s = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0],\n                  i = parseInt(s, 8);\n              i > 255 && (s = s.slice(0, -1), i = parseInt(s, 8)), this.state.pos += s.length - 1;\n              const r = this.input.charCodeAt(this.state.pos);\n\n              if (\"0\" !== s || 56 === r || 57 === r) {\n                if (t) return null;\n                this.state.strict ? this.raise(e, f.StrictOctalLiteral) : this.state.octalPositions.push(e);\n              }\n\n              return String.fromCharCode(i);\n            }\n\n            return String.fromCharCode(s);\n        }\n      }\n\n      readHexChar(t, e, s) {\n        const i = this.state.pos,\n              r = this.readInt(16, t, e, !1);\n        return null === r && (s ? this.raise(i, f.InvalidEscapeSequence) : this.state.pos = i - 1), r;\n      }\n\n      readWord1() {\n        let t = \"\";\n        this.state.containsEsc = !1;\n        const e = this.state.pos;\n        let s = this.state.pos;\n\n        for (; this.state.pos < this.length;) {\n          const i = this.input.codePointAt(this.state.pos);\n          if (S(i)) this.state.pos += i <= 65535 ? 1 : 2;else if (this.state.isIterator && 64 === i) ++this.state.pos;else {\n            if (92 !== i) break;\n            {\n              this.state.containsEsc = !0, t += this.input.slice(s, this.state.pos);\n              const i = this.state.pos,\n                    r = this.state.pos === e ? w : S;\n\n              if (117 !== this.input.charCodeAt(++this.state.pos)) {\n                this.raise(this.state.pos, f.MissingUnicodeEscape);\n                continue;\n              }\n\n              ++this.state.pos;\n              const a = this.readCodePoint(!0);\n              null !== a && (r(a) || this.raise(i, f.EscapedCharNotAnIdentifier), t += String.fromCodePoint(a)), s = this.state.pos;\n            }\n          }\n        }\n\n        return t + this.input.slice(s, this.state.pos);\n      }\n\n      isIterator(t) {\n        return \"@@iterator\" === t || \"@@asyncIterator\" === t;\n      }\n\n      readWord() {\n        const t = this.readWord1(),\n              e = i.get(t) || n.name;\n        !this.state.isIterator || this.isIterator(t) && this.state.inType || this.raise(this.state.pos, f.InvalidIdentifier, t), this.finishToken(e, t);\n      }\n\n      checkKeywordEscapes() {\n        const t = this.state.type.keyword;\n        t && this.state.containsEsc && this.raise(this.state.start, f.InvalidEscapedReservedWord, t);\n      }\n\n      braceIsBlock(t) {\n        const e = this.curContext();\n        return e === x.functionExpression || e === x.functionStatement || (t !== n.colon || e !== x.braceStatement && e !== x.braceExpression ? t === n._return || t === n.name && this.state.exprAllowed ? o.test(this.input.slice(this.state.lastTokEnd, this.state.start)) : t === n._else || t === n.semi || t === n.eof || t === n.parenR || t === n.arrow || (t === n.braceL ? e === x.braceStatement : t !== n._var && t !== n._const && t !== n.name && (t === n.relational || !this.state.exprAllowed)) : !e.isExpr);\n      }\n\n      updateContext(t) {\n        const e = this.state.type;\n        let s;\n        !e.keyword || t !== n.dot && t !== n.questionDot ? (s = e.updateContext) ? s.call(this, t) : this.state.exprAllowed = e.beforeExpr : this.state.exprAllowed = !1;\n      }\n\n    } {\n      addExtra(t, e, s) {\n        if (!t) return;\n        (t.extra = t.extra || {})[e] = s;\n      }\n\n      isRelational(t) {\n        return this.match(n.relational) && this.state.value === t;\n      }\n\n      isLookaheadRelational(t) {\n        const e = this.nextTokenStart();\n\n        if (this.input.charAt(e) === t) {\n          if (e + 1 === this.input.length) return !0;\n          const s = this.input.charCodeAt(e + 1);\n          return s !== t.charCodeAt(0) && 61 !== s;\n        }\n\n        return !1;\n      }\n\n      expectRelational(t) {\n        this.isRelational(t) ? this.next() : this.unexpected(null, n.relational);\n      }\n\n      isContextual(t) {\n        return this.match(n.name) && this.state.value === t && !this.state.containsEsc;\n      }\n\n      isUnparsedContextual(t, e) {\n        const s = t + e.length;\n        return this.input.slice(t, s) === e && (s === this.input.length || !S(this.input.charCodeAt(s)));\n      }\n\n      isLookaheadContextual(t) {\n        const e = this.nextTokenStart();\n        return this.isUnparsedContextual(e, t);\n      }\n\n      eatContextual(t) {\n        return this.isContextual(t) && this.eat(n.name);\n      }\n\n      expectContextual(t, e) {\n        this.eatContextual(t) || this.unexpected(null, e);\n      }\n\n      canInsertSemicolon() {\n        return this.match(n.eof) || this.match(n.braceR) || this.hasPrecedingLineBreak();\n      }\n\n      hasPrecedingLineBreak() {\n        return o.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n      }\n\n      isLineTerminator() {\n        return this.eat(n.semi) || this.canInsertSemicolon();\n      }\n\n      semicolon() {\n        this.isLineTerminator() || this.unexpected(null, n.semi);\n      }\n\n      expect(t, e) {\n        this.eat(t) || this.unexpected(e, t);\n      }\n\n      assertNoSpace() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Unexpected space.\";\n        this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, t);\n      }\n\n      unexpected(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Unexpected token\";\n        throw \"string\" != typeof e && (e = 'Unexpected token, expected \"'.concat(e.label, '\"')), this.raise(null != t ? t : this.state.start, e);\n      }\n\n      expectPlugin(t, e) {\n        if (!this.hasPlugin(t)) throw this.raiseWithData(null != e ? e : this.state.start, {\n          missingPlugin: [t]\n        }, \"This experimental syntax requires enabling the parser plugin: '\".concat(t, \"'\"));\n        return !0;\n      }\n\n      expectOnePlugin(t, e) {\n        if (!t.some(t => this.hasPlugin(t))) throw this.raiseWithData(null != e ? e : this.state.start, {\n          missingPlugin: t\n        }, \"This experimental syntax requires enabling one of the following parser plugin(s): '\".concat(t.join(\", \"), \"'\"));\n      }\n\n      checkYieldAwaitInDefaultParams() {\n        -1 !== this.state.yieldPos && (-1 === this.state.awaitPos || this.state.yieldPos < this.state.awaitPos) && this.raise(this.state.yieldPos, \"Yield cannot be used as name inside a generator function\"), -1 !== this.state.awaitPos && this.raise(this.state.awaitPos, \"Await cannot be used as name inside an async function\");\n      }\n\n      tryParse(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.clone();\n        const s = {\n          node: null\n        };\n\n        try {\n          const i = t(function () {\n            let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n            throw s.node = t, s;\n          });\n\n          if (this.state.errors.length > e.errors.length) {\n            const t = this.state;\n            return this.state = e, {\n              node: i,\n              error: t.errors[e.errors.length],\n              thrown: !1,\n              aborted: !1,\n              failState: t\n            };\n          }\n\n          return {\n            node: i,\n            error: null,\n            thrown: !1,\n            aborted: !1,\n            failState: null\n          };\n        } catch (t) {\n          const i = this.state;\n          if (this.state = e, t instanceof SyntaxError) return {\n            node: null,\n            error: t,\n            thrown: !0,\n            aborted: !1,\n            failState: i\n          };\n          if (t === s) return {\n            node: s.node,\n            error: null,\n            thrown: !1,\n            aborted: !0,\n            failState: i\n          };\n          throw t;\n        }\n      }\n\n      checkExpressionErrors(t, e) {\n        if (!t) return !1;\n        const {\n          shorthandAssign: s,\n          doubleProto: i\n        } = t;\n        if (!e) return s >= 0 || i >= 0;\n        s >= 0 && this.unexpected(s), i >= 0 && this.raise(i, f.DuplicateProto);\n      }\n\n    } {\n      startNode() {\n        return new gt(this, this.state.start, this.state.startLoc);\n      }\n\n      startNodeAt(t, e) {\n        return new gt(this, t, e);\n      }\n\n      startNodeAtNode(t) {\n        return this.startNodeAt(t.start, t.loc.start);\n      }\n\n      finishNode(t, e) {\n        return this.finishNodeAt(t, e, this.state.lastTokEnd, this.state.lastTokEndLoc);\n      }\n\n      finishNodeAt(t, e, s, i) {\n        return t.type = e, t.end = s, t.loc.end = i, this.options.ranges && (t.range[1] = s), this.processComment(t), t;\n      }\n\n      resetStartLocation(t, e, s) {\n        t.start = e, t.loc.start = s, this.options.ranges && (t.range[0] = e);\n      }\n\n      resetEndLocation(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state.lastTokEnd;\n        let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.state.lastTokEndLoc;\n        t.end = e, t.loc.end = s, this.options.ranges && (t.range[1] = e);\n      }\n\n      resetStartLocationFromNode(t, e) {\n        this.resetStartLocation(t, e.start, e.loc.start);\n      }\n\n    } {\n      toAssignable(t) {\n        var e, s;\n        let i = void 0;\n\n        switch ((\"ParenthesizedExpression\" === t.type || (null == (e = t.extra) ? void 0 : e.parenthesized)) && (i = Pt(t), \"Identifier\" !== i.type && \"MemberExpression\" !== i.type && this.raise(t.start, f.InvalidParenthesizedAssignment)), t.type) {\n          case \"Identifier\":\n          case \"ObjectPattern\":\n          case \"ArrayPattern\":\n          case \"AssignmentPattern\":\n            break;\n\n          case \"ObjectExpression\":\n            t.type = \"ObjectPattern\";\n\n            for (let e = 0, s = t.properties.length, i = s - 1; e < s; e++) {\n              var r;\n              const s = t.properties[e],\n                    a = e === i;\n              this.toAssignableObjectExpressionProp(s, a), a && \"RestElement\" === s.type && (null == (r = t.extra) ? void 0 : r.trailingComma) && this.raiseRestNotLast(t.extra.trailingComma);\n            }\n\n            break;\n\n          case \"ObjectProperty\":\n            this.toAssignable(t.value);\n            break;\n\n          case \"SpreadElement\":\n            {\n              this.checkToRestConversion(t), t.type = \"RestElement\";\n              const e = t.argument;\n              this.toAssignable(e);\n              break;\n            }\n\n          case \"ArrayExpression\":\n            t.type = \"ArrayPattern\", this.toAssignableList(t.elements, null == (s = t.extra) ? void 0 : s.trailingComma);\n            break;\n\n          case \"AssignmentExpression\":\n            \"=\" !== t.operator && this.raise(t.left.end, f.MissingEqInAssignment), t.type = \"AssignmentPattern\", delete t.operator, this.toAssignable(t.left);\n            break;\n\n          case \"ParenthesizedExpression\":\n            this.toAssignable(i);\n        }\n\n        return t;\n      }\n\n      toAssignableObjectExpressionProp(t, e) {\n        if (\"ObjectMethod\" === t.type) {\n          const e = \"get\" === t.kind || \"set\" === t.kind ? f.PatternHasAccessor : f.PatternHasMethod;\n          this.raise(t.key.start, e);\n        } else \"SpreadElement\" !== t.type || e ? this.toAssignable(t) : this.raiseRestNotLast(t.start);\n      }\n\n      toAssignableList(t, e) {\n        let s = t.length;\n\n        if (s) {\n          const i = t[s - 1];\n          if (i && \"RestElement\" === i.type) --s;else if (i && \"SpreadElement\" === i.type) {\n            i.type = \"RestElement\";\n            const t = i.argument;\n            this.toAssignable(t), \"Identifier\" !== t.type && \"MemberExpression\" !== t.type && \"ArrayPattern\" !== t.type && \"ObjectPattern\" !== t.type && this.unexpected(t.start), e && this.raiseTrailingCommaAfterRest(e), --s;\n          }\n        }\n\n        for (let e = 0; e < s; e++) {\n          const s = t[e];\n          s && (this.toAssignable(s), \"RestElement\" === s.type && this.raiseRestNotLast(s.start));\n        }\n\n        return t;\n      }\n\n      toReferencedList(t, e) {\n        return t;\n      }\n\n      toReferencedListDeep(t, e) {\n        this.toReferencedList(t, e);\n\n        for (let e = 0; e < t.length; e++) {\n          const s = t[e];\n          s && \"ArrayExpression\" === s.type && this.toReferencedListDeep(s.elements);\n        }\n      }\n\n      parseSpread(t, e) {\n        const s = this.startNode();\n        return this.next(), s.argument = this.parseMaybeAssign(!1, t, void 0, e), this.finishNode(s, \"SpreadElement\");\n      }\n\n      parseRestBinding() {\n        const t = this.startNode();\n        return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, \"RestElement\");\n      }\n\n      parseBindingAtom() {\n        switch (this.state.type) {\n          case n.bracketL:\n            {\n              const t = this.startNode();\n              return this.next(), t.elements = this.parseBindingList(n.bracketR, 93, !0), this.finishNode(t, \"ArrayPattern\");\n            }\n\n          case n.braceL:\n            return this.parseObj(n.braceR, !0);\n        }\n\n        return this.parseIdentifier();\n      }\n\n      parseBindingList(t, e, s, i) {\n        const r = [];\n        let a = !0;\n\n        for (; !this.eat(t);) if (a ? a = !1 : this.expect(n.comma), s && this.match(n.comma)) r.push(null);else {\n          if (this.eat(t)) break;\n\n          if (this.match(n.ellipsis)) {\n            r.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(e), this.expect(t);\n            break;\n          }\n\n          {\n            const t = [];\n\n            for (this.match(n.at) && this.hasPlugin(\"decorators\") && this.raise(this.state.start, f.UnsupportedParameterDecorator); this.match(n.at);) t.push(this.parseDecorator());\n\n            r.push(this.parseAssignableListItem(i, t));\n          }\n        }\n\n        return r;\n      }\n\n      parseAssignableListItem(t, e) {\n        const s = this.parseMaybeDefault();\n        this.parseAssignableListItemTypes(s);\n        const i = this.parseMaybeDefault(s.start, s.loc.start, s);\n        return e.length && (s.decorators = e), i;\n      }\n\n      parseAssignableListItemTypes(t) {\n        return t;\n      }\n\n      parseMaybeDefault(t, e, s) {\n        if (e = e || this.state.startLoc, t = t || this.state.start, s = s || this.parseBindingAtom(), !this.eat(n.eq)) return s;\n        const i = this.startNodeAt(t, e);\n        return i.left = s, i.right = this.parseMaybeAssign(), this.finishNode(i, \"AssignmentPattern\");\n      }\n\n      checkLVal(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n        let s = arguments.length > 2 ? arguments[2] : undefined;\n        let i = arguments.length > 3 ? arguments[3] : undefined;\n        let r = arguments.length > 4 ? arguments[4] : undefined;\n        let a = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;\n\n        switch (t.type) {\n          case \"Identifier\":\n            if (this.state.strict && (a ? O(t.name, this.inModule) : M(t.name)) && this.raise(t.start, 64 === e ? f.StrictEvalArguments : f.StrictEvalArgumentsBinding, t.name), s) {\n              const e = \"_\".concat(t.name);\n              s[e] ? this.raise(t.start, f.ParamDupe) : s[e] = !0;\n            }\n\n            r && \"let\" === t.name && this.raise(t.start, f.LetInLexicalBinding), 64 & e || this.scope.declareName(t.name, e, t.start);\n            break;\n\n          case \"MemberExpression\":\n            64 !== e && this.raise(t.start, f.InvalidPropertyBindingPattern);\n            break;\n\n          case \"ObjectPattern\":\n            for (let i = 0, a = t.properties; i < a.length; i++) {\n              let t = a[i];\n              if (\"ObjectProperty\" === t.type) t = t.value;else if (\"ObjectMethod\" === t.type) continue;\n              this.checkLVal(t, e, s, \"object destructuring pattern\", r);\n            }\n\n            break;\n\n          case \"ArrayPattern\":\n            for (let i = 0, a = t.elements; i < a.length; i++) {\n              const t = a[i];\n              t && this.checkLVal(t, e, s, \"array destructuring pattern\", r);\n            }\n\n            break;\n\n          case \"AssignmentPattern\":\n            this.checkLVal(t.left, e, s, \"assignment pattern\");\n            break;\n\n          case \"RestElement\":\n            this.checkLVal(t.argument, e, s, \"rest element\");\n            break;\n\n          case \"ParenthesizedExpression\":\n            this.checkLVal(t.expression, e, s, \"parenthesized expression\");\n            break;\n\n          default:\n            this.raise(t.start, 64 === e ? f.InvalidLhs : f.InvalidLhsBinding, i);\n        }\n      }\n\n      checkToRestConversion(t) {\n        \"Identifier\" !== t.argument.type && \"MemberExpression\" !== t.argument.type && this.raise(t.argument.start, f.InvalidRestAssignmentPattern);\n      }\n\n      checkCommaAfterRest(t) {\n        this.match(n.comma) && (this.lookaheadCharCode() === t ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));\n      }\n\n      raiseRestNotLast(t) {\n        throw this.raise(t, f.ElementAfterRest);\n      }\n\n      raiseTrailingCommaAfterRest(t) {\n        this.raise(t, f.RestTrailingComma);\n      }\n\n    } {\n      checkDuplicatedProto(t, e, s) {\n        if (\"SpreadElement\" === t.type || t.computed || t.kind || t.shorthand) return;\n        const i = t.key;\n        \"__proto__\" === (\"Identifier\" === i.type ? i.name : String(i.value)) && (e.used && (s ? -1 === s.doubleProto && (s.doubleProto = i.start) : this.raise(i.start, f.DuplicateProto)), e.used = !0);\n      }\n\n      getExpression() {\n        let t = 0;\n        this.hasPlugin(\"topLevelAwait\") && this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t), this.nextToken();\n        const e = this.parseExpression();\n        return this.match(n.eof) || this.unexpected(), e.comments = this.state.comments, e.errors = this.state.errors, e;\n      }\n\n      parseExpression(t, e) {\n        const s = this.state.start,\n              i = this.state.startLoc,\n              r = this.parseMaybeAssign(t, e);\n\n        if (this.match(n.comma)) {\n          const a = this.startNodeAt(s, i);\n\n          for (a.expressions = [r]; this.eat(n.comma);) a.expressions.push(this.parseMaybeAssign(t, e));\n\n          return this.toReferencedList(a.expressions), this.finishNode(a, \"SequenceExpression\");\n        }\n\n        return r;\n      }\n\n      parseMaybeAssign(t, e, s, i) {\n        const r = this.state.start,\n              a = this.state.startLoc;\n\n        if (this.isContextual(\"yield\")) {\n          if (this.prodParam.hasYield) {\n            let e = this.parseYield(t);\n            return s && (e = s.call(this, e, r, a)), e;\n          }\n\n          this.state.exprAllowed = !1;\n        }\n\n        let o;\n        e ? o = !1 : (e = new xt(), o = !0), (this.match(n.parenL) || this.match(n.name)) && (this.state.potentialArrowAt = this.state.start);\n        let h = this.parseMaybeConditional(t, e, i);\n\n        if (s && (h = s.call(this, h, r, a)), this.state.type.isAssign) {\n          const s = this.startNodeAt(r, a),\n                i = this.state.value;\n          return s.operator = i, \"??=\" === i && this.expectPlugin(\"logicalAssignment\"), \"||=\" !== i && \"&&=\" !== i || this.expectPlugin(\"logicalAssignment\"), this.match(n.eq) ? (s.left = this.toAssignable(h), e.doubleProto = -1) : s.left = h, e.shorthandAssign >= s.left.start && (e.shorthandAssign = -1), this.checkLVal(h, void 0, void 0, \"assignment expression\"), this.next(), s.right = this.parseMaybeAssign(t), this.finishNode(s, \"AssignmentExpression\");\n        }\n\n        return o && this.checkExpressionErrors(e, !0), h;\n      }\n\n      parseMaybeConditional(t, e, s) {\n        const i = this.state.start,\n              r = this.state.startLoc,\n              a = this.state.potentialArrowAt,\n              n = this.parseExprOps(t, e);\n        return \"ArrowFunctionExpression\" === n.type && n.start === a ? n : this.checkExpressionErrors(e, !1) ? n : this.parseConditional(n, t, i, r, s);\n      }\n\n      parseConditional(t, e, s, i, r) {\n        if (this.eat(n.question)) {\n          const r = this.startNodeAt(s, i);\n          return r.test = t, r.consequent = this.parseMaybeAssign(), this.expect(n.colon), r.alternate = this.parseMaybeAssign(e), this.finishNode(r, \"ConditionalExpression\");\n        }\n\n        return t;\n      }\n\n      parseExprOps(t, e) {\n        const s = this.state.start,\n              i = this.state.startLoc,\n              r = this.state.potentialArrowAt,\n              a = this.parseMaybeUnary(e);\n        return \"ArrowFunctionExpression\" === a.type && a.start === r ? a : this.checkExpressionErrors(e, !1) ? a : this.parseExprOp(a, s, i, -1, t);\n      }\n\n      parseExprOp(t, e, s, i, r) {\n        let a = this.state.type.binop;\n\n        if (!(null == a || r && this.match(n._in)) && a > i) {\n          const o = this.state.value;\n          if (\"|>\" === o && this.state.inFSharpPipelineDirectBody) return t;\n          const h = this.startNodeAt(e, s);\n          h.left = t, h.operator = o, \"**\" !== o || \"UnaryExpression\" !== t.type || !this.options.createParenthesizedExpressions && t.extra && t.extra.parenthesized || this.raise(t.argument.start, f.UnexpectedTokenUnaryExponentiation);\n          const p = this.state.type,\n                c = p === n.logicalOR || p === n.logicalAND,\n                u = p === n.nullishCoalescing;\n          if (p === n.pipeline ? (this.expectPlugin(\"pipelineOperator\"), this.state.inPipeline = !0, this.checkPipelineAtInfixOperator(t, e)) : u && (a = n.logicalAND.binop), this.next(), p === n.pipeline && \"minimal\" === this.getPluginOption(\"pipelineOperator\", \"proposal\") && this.match(n.name) && \"await\" === this.state.value && this.prodParam.hasAwait) throw this.raise(this.state.start, f.UnexpectedAwaitAfterPipelineBody);\n          h.right = this.parseExprOpRightExpr(p, a, r), this.finishNode(h, c || u ? \"LogicalExpression\" : \"BinaryExpression\");\n          const l = this.state.type;\n          if (u && (l === n.logicalOR || l === n.logicalAND) || c && l === n.nullishCoalescing) throw this.raise(this.state.start, f.MixingCoalesceWithLogical);\n          return this.parseExprOp(h, e, s, i, r);\n        }\n\n        return t;\n      }\n\n      parseExprOpRightExpr(t, e, s) {\n        const i = this.state.start,\n              r = this.state.startLoc;\n\n        switch (t) {\n          case n.pipeline:\n            switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n              case \"smart\":\n                return this.withTopicPermittingContext(() => this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(t, e, s), i, r));\n\n              case \"fsharp\":\n                return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e, s));\n            }\n\n          default:\n            return this.parseExprOpBaseRightExpr(t, e, s);\n        }\n      }\n\n      parseExprOpBaseRightExpr(t, e, s) {\n        const i = this.state.start,\n              r = this.state.startLoc;\n        return this.parseExprOp(this.parseMaybeUnary(), i, r, t.rightAssociative ? e - 1 : e, s);\n      }\n\n      parseMaybeUnary(t) {\n        if (this.isContextual(\"await\") && this.isAwaitAllowed()) return this.parseAwait();\n\n        if (this.state.type.prefix) {\n          const e = this.startNode(),\n                s = this.match(n.incDec);\n          if (e.operator = this.state.value, e.prefix = !0, \"throw\" === e.operator && this.expectPlugin(\"throwExpressions\"), this.next(), e.argument = this.parseMaybeUnary(), this.checkExpressionErrors(t, !0), s) this.checkLVal(e.argument, void 0, void 0, \"prefix operation\");else if (this.state.strict && \"delete\" === e.operator) {\n            const t = e.argument;\n            \"Identifier\" === t.type ? this.raise(e.start, f.StrictDelete) : \"MemberExpression\" === t.type && \"PrivateName\" === t.property.type && this.raise(e.start, f.DeletePrivateField);\n          }\n          return this.finishNode(e, s ? \"UpdateExpression\" : \"UnaryExpression\");\n        }\n\n        const e = this.state.start,\n              s = this.state.startLoc;\n        let i = this.parseExprSubscripts(t);\n        if (this.checkExpressionErrors(t, !1)) return i;\n\n        for (; this.state.type.postfix && !this.canInsertSemicolon();) {\n          const t = this.startNodeAt(e, s);\n          t.operator = this.state.value, t.prefix = !1, t.argument = i, this.checkLVal(i, void 0, void 0, \"postfix operation\"), this.next(), i = this.finishNode(t, \"UpdateExpression\");\n        }\n\n        return i;\n      }\n\n      parseExprSubscripts(t) {\n        const e = this.state.start,\n              s = this.state.startLoc,\n              i = this.state.potentialArrowAt,\n              r = this.parseExprAtom(t);\n        return \"ArrowFunctionExpression\" === r.type && r.start === i ? r : this.parseSubscripts(r, e, s);\n      }\n\n      parseSubscripts(t, e, s, i) {\n        const r = {\n          optionalChainMember: !1,\n          maybeAsyncArrow: this.atPossibleAsyncArrow(t),\n          stop: !1\n        };\n\n        do {\n          const a = this.state.maybeInAsyncArrowHead;\n          r.maybeAsyncArrow && (this.state.maybeInAsyncArrowHead = !0), t = this.parseSubscript(t, e, s, i, r), r.maybeAsyncArrow = !1, this.state.maybeInAsyncArrowHead = a;\n        } while (!r.stop);\n\n        return t;\n      }\n\n      parseSubscript(t, e, s, i, r) {\n        if (!i && this.eat(n.doubleColon)) {\n          const a = this.startNodeAt(e, s);\n          return a.object = t, a.callee = this.parseNoCallExpr(), r.stop = !0, this.parseSubscripts(this.finishNode(a, \"BindExpression\"), e, s, i);\n        }\n\n        let a = !1;\n\n        if (this.match(n.questionDot)) {\n          if (r.optionalChainMember = a = !0, i && 40 === this.lookaheadCharCode()) return r.stop = !0, t;\n          this.next();\n        }\n\n        const o = this.eat(n.bracketL);\n\n        if (a && !this.match(n.parenL) && !this.match(n.backQuote) || o || this.eat(n.dot)) {\n          const i = this.startNodeAt(e, s);\n          return i.object = t, i.property = o ? this.parseExpression() : a ? this.parseIdentifier(!0) : this.parseMaybePrivateName(!0), i.computed = o, \"PrivateName\" === i.property.type && (\"Super\" === i.object.type && this.raise(e, f.SuperPrivateField), this.classScope.usePrivateName(i.property.id.name, i.property.start)), o && this.expect(n.bracketR), r.optionalChainMember ? (i.optional = a, this.finishNode(i, \"OptionalMemberExpression\")) : this.finishNode(i, \"MemberExpression\");\n        }\n\n        if (!i && this.match(n.parenL)) {\n          const i = this.state.maybeInArrowParameters,\n                o = this.state.yieldPos,\n                h = this.state.awaitPos;\n          this.state.maybeInArrowParameters = !0, this.state.yieldPos = -1, this.state.awaitPos = -1, this.next();\n          let p = this.startNodeAt(e, s);\n          return p.callee = t, a ? (p.optional = !0, p.arguments = this.parseCallExpressionArguments(n.parenR, !1)) : p.arguments = this.parseCallExpressionArguments(n.parenR, r.maybeAsyncArrow, \"Import\" === t.type, \"Super\" !== t.type, p), this.finishCallExpression(p, r.optionalChainMember), r.maybeAsyncArrow && this.shouldParseAsyncArrow() && !a ? (r.stop = !0, p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e, s), p), this.checkYieldAwaitInDefaultParams(), this.state.yieldPos = o, this.state.awaitPos = h) : (this.toReferencedListDeep(p.arguments), -1 !== o && (this.state.yieldPos = o), (this.isAwaitAllowed() || i) && -1 === h || (this.state.awaitPos = h)), this.state.maybeInArrowParameters = i, p;\n        }\n\n        return this.match(n.backQuote) ? this.parseTaggedTemplateExpression(e, s, t, r) : (r.stop = !0, t);\n      }\n\n      parseTaggedTemplateExpression(t, e, s, i, r) {\n        const a = this.startNodeAt(t, e);\n        return a.tag = s, a.quasi = this.parseTemplate(!0), r && (a.typeParameters = r), i.optionalChainMember && this.raise(t, f.OptionalChainingNoTemplate), this.finishNode(a, \"TaggedTemplateExpression\");\n      }\n\n      atPossibleAsyncArrow(t) {\n        return \"Identifier\" === t.type && \"async\" === t.name && this.state.lastTokEnd === t.end && !this.canInsertSemicolon() && t.end - t.start == 5 && t.start === this.state.potentialArrowAt;\n      }\n\n      finishCallExpression(t, e) {\n        if (\"Import\" === t.callee.type) if (1 !== t.arguments.length) this.raise(t.start, f.ImportCallArity);else {\n          const e = t.arguments[0];\n          e && \"SpreadElement\" === e.type && this.raise(e.start, f.ImportCallSpreadArgument);\n        }\n        return this.finishNode(t, e ? \"OptionalCallExpression\" : \"CallExpression\");\n      }\n\n      parseCallExpressionArguments(t, e, s, i, r) {\n        const a = [];\n        let o,\n            h = !0;\n        const p = this.state.inFSharpPipelineDirectBody;\n\n        for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t);) {\n          if (h) h = !1;else if (this.expect(n.comma), this.match(t)) {\n            s && this.raise(this.state.lastTokStart, f.ImportCallArgumentTrailingComma), r && this.addExtra(r, \"trailingComma\", this.state.lastTokStart), this.next();\n            break;\n          }\n          this.match(n.parenL) && !o && (o = this.state.start), a.push(this.parseExprListItem(!1, e ? new xt() : void 0, e ? {\n            start: 0\n          } : void 0, i));\n        }\n\n        return e && o && this.shouldParseAsyncArrow() && this.unexpected(), this.state.inFSharpPipelineDirectBody = p, a;\n      }\n\n      shouldParseAsyncArrow() {\n        return this.match(n.arrow) && !this.canInsertSemicolon();\n      }\n\n      parseAsyncArrowFromCallExpression(t, e) {\n        var s;\n        return this.expect(n.arrow), this.parseArrowExpression(t, e.arguments, !0, null == (s = e.extra) ? void 0 : s.trailingComma), t;\n      }\n\n      parseNoCallExpr() {\n        const t = this.state.start,\n              e = this.state.startLoc;\n        return this.parseSubscripts(this.parseExprAtom(), t, e, !0);\n      }\n\n      parseExprAtom(t) {\n        this.state.type === n.slash && this.readRegexp();\n        const e = this.state.potentialArrowAt === this.state.start;\n        let s;\n\n        switch (this.state.type) {\n          case n._super:\n            return s = this.startNode(), this.next(), !this.match(n.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(s.start, f.UnexpectedSuper) : this.raise(s.start, f.SuperNotAllowed), this.match(n.parenL) || this.match(n.bracketL) || this.match(n.dot) || this.raise(s.start, f.UnsupportedSuper), this.finishNode(s, \"Super\");\n\n          case n._import:\n            return s = this.startNode(), this.next(), this.match(n.dot) ? this.parseImportMetaProperty(s) : (this.match(n.parenL) || this.raise(this.state.lastTokStart, f.UnsupportedImport), this.finishNode(s, \"Import\"));\n\n          case n._this:\n            return s = this.startNode(), this.next(), this.finishNode(s, \"ThisExpression\");\n\n          case n.name:\n            {\n              s = this.startNode();\n              const t = this.state.containsEsc,\n                    i = this.parseIdentifier();\n\n              if (!t && \"async\" === i.name && this.match(n._function) && !this.canInsertSemicolon()) {\n                const t = this.state.context.length - 1;\n                if (this.state.context[t] !== x.functionStatement) throw new Error(\"Internal error\");\n                return this.state.context[t] = x.functionExpression, this.next(), this.parseFunction(s, void 0, !0);\n              }\n\n              if (e && !t && \"async\" === i.name && this.match(n.name) && !this.canInsertSemicolon()) {\n                const t = this.state.maybeInArrowParameters,\n                      e = this.state.maybeInAsyncArrowHead,\n                      i = this.state.yieldPos,\n                      r = this.state.awaitPos;\n                this.state.maybeInArrowParameters = !0, this.state.maybeInAsyncArrowHead = !0, this.state.yieldPos = -1, this.state.awaitPos = -1;\n                const a = [this.parseIdentifier()];\n                return this.expect(n.arrow), this.checkYieldAwaitInDefaultParams(), this.state.maybeInArrowParameters = t, this.state.maybeInAsyncArrowHead = e, this.state.yieldPos = i, this.state.awaitPos = r, this.parseArrowExpression(s, a, !0), s;\n              }\n\n              return e && this.match(n.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(s, [i], !1), s) : i;\n            }\n\n          case n._do:\n            {\n              this.expectPlugin(\"doExpressions\");\n              const t = this.startNode();\n              this.next();\n              const e = this.state.labels;\n              return this.state.labels = [], t.body = this.parseBlock(), this.state.labels = e, this.finishNode(t, \"DoExpression\");\n            }\n\n          case n.regexp:\n            {\n              const t = this.state.value;\n              return s = this.parseLiteral(t.value, \"RegExpLiteral\"), s.pattern = t.pattern, s.flags = t.flags, s;\n            }\n\n          case n.num:\n            return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n          case n.bigint:\n            return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n          case n.string:\n            return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n          case n._null:\n            return s = this.startNode(), this.next(), this.finishNode(s, \"NullLiteral\");\n\n          case n._true:\n          case n._false:\n            return this.parseBooleanLiteral();\n\n          case n.parenL:\n            return this.parseParenAndDistinguishExpression(e);\n\n          case n.bracketBarL:\n          case n.bracketHashL:\n            {\n              this.expectPlugin(\"recordAndTuple\");\n              const e = this.state.inFSharpPipelineDirectBody,\n                    i = this.state.type === n.bracketBarL ? n.bracketBarR : n.bracketR;\n              return this.state.inFSharpPipelineDirectBody = !1, s = this.startNode(), this.next(), s.elements = this.parseExprList(i, !0, t, s), this.state.inFSharpPipelineDirectBody = e, this.finishNode(s, \"TupleExpression\");\n            }\n\n          case n.bracketL:\n            {\n              const e = this.state.inFSharpPipelineDirectBody;\n              return this.state.inFSharpPipelineDirectBody = !1, s = this.startNode(), this.next(), s.elements = this.parseExprList(n.bracketR, !0, t, s), this.state.maybeInArrowParameters || this.toReferencedList(s.elements), this.state.inFSharpPipelineDirectBody = e, this.finishNode(s, \"ArrayExpression\");\n            }\n\n          case n.braceBarL:\n          case n.braceHashL:\n            {\n              this.expectPlugin(\"recordAndTuple\");\n              const e = this.state.inFSharpPipelineDirectBody,\n                    s = this.state.type === n.braceBarL ? n.braceBarR : n.braceR;\n              this.state.inFSharpPipelineDirectBody = !1;\n              const i = this.parseObj(s, !1, !0, t);\n              return this.state.inFSharpPipelineDirectBody = e, i;\n            }\n\n          case n.braceL:\n            {\n              const e = this.state.inFSharpPipelineDirectBody;\n              this.state.inFSharpPipelineDirectBody = !1;\n              const s = this.parseObj(n.braceR, !1, !1, t);\n              return this.state.inFSharpPipelineDirectBody = e, s;\n            }\n\n          case n._function:\n            return this.parseFunctionExpression();\n\n          case n.at:\n            this.parseDecorators();\n\n          case n._class:\n            return s = this.startNode(), this.takeDecorators(s), this.parseClass(s, !1);\n\n          case n._new:\n            return this.parseNew();\n\n          case n.backQuote:\n            return this.parseTemplate(!1);\n\n          case n.doubleColon:\n            {\n              s = this.startNode(), this.next(), s.object = null;\n              const t = s.callee = this.parseNoCallExpr();\n              if (\"MemberExpression\" === t.type) return this.finishNode(s, \"BindExpression\");\n              throw this.raise(t.start, f.UnsupportedBind);\n            }\n\n          case n.hash:\n            if (this.state.inPipeline) return s = this.startNode(), \"smart\" !== this.getPluginOption(\"pipelineOperator\", \"proposal\") && this.raise(s.start, f.PrimaryTopicRequiresSmartPipeline), this.next(), this.primaryTopicReferenceIsAllowedInCurrentTopicContext() || this.raise(s.start, f.PrimaryTopicNotAllowed), this.registerTopicReference(), this.finishNode(s, \"PipelinePrimaryTopicReference\");\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      parseBooleanLiteral() {\n        const t = this.startNode();\n        return t.value = this.match(n._true), this.next(), this.finishNode(t, \"BooleanLiteral\");\n      }\n\n      parseMaybePrivateName(t) {\n        if (this.match(n.hash)) {\n          this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]), t || this.raise(this.state.pos, f.UnexpectedPrivateField);\n          const e = this.startNode();\n          return this.next(), this.assertNoSpace(\"Unexpected space between # and identifier\"), e.id = this.parseIdentifier(!0), this.finishNode(e, \"PrivateName\");\n        }\n\n        return this.parseIdentifier(!0);\n      }\n\n      parseFunctionExpression() {\n        const t = this.startNode();\n        let e = this.startNode();\n        return this.next(), e = this.createIdentifier(e, \"function\"), this.prodParam.hasYield && this.eat(n.dot) ? this.parseMetaProperty(t, e, \"sent\") : this.parseFunction(t);\n      }\n\n      parseMetaProperty(t, e, s) {\n        t.meta = e, \"function\" === e.name && \"sent\" === s && (this.isContextual(s) ? this.expectPlugin(\"functionSent\") : this.hasPlugin(\"functionSent\") || this.unexpected());\n        const i = this.state.containsEsc;\n        return t.property = this.parseIdentifier(!0), (t.property.name !== s || i) && this.raise(t.property.start, f.UnsupportedMetaProperty, e.name, s), this.finishNode(t, \"MetaProperty\");\n      }\n\n      parseImportMetaProperty(t) {\n        const e = this.createIdentifier(this.startNodeAtNode(t), \"import\");\n        return this.expect(n.dot), this.isContextual(\"meta\") ? (this.expectPlugin(\"importMeta\"), this.inModule || this.raiseWithData(e.start, {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        }, f.ImportMetaOutsideModule), this.sawUnambiguousESM = !0) : this.hasPlugin(\"importMeta\") || this.raise(e.start, f.ImportCallArityLtOne), this.parseMetaProperty(t, e, \"meta\");\n      }\n\n      parseLiteral(t, e, s, i) {\n        s = s || this.state.start, i = i || this.state.startLoc;\n        const r = this.startNodeAt(s, i);\n        return this.addExtra(r, \"rawValue\", t), this.addExtra(r, \"raw\", this.input.slice(s, this.state.end)), r.value = t, this.next(), this.finishNode(r, e);\n      }\n\n      parseParenAndDistinguishExpression(t) {\n        const e = this.state.start,\n              s = this.state.startLoc;\n        let i;\n        this.expect(n.parenL);\n        const r = this.state.maybeInArrowParameters,\n              a = this.state.yieldPos,\n              o = this.state.awaitPos,\n              h = this.state.inFSharpPipelineDirectBody;\n        this.state.maybeInArrowParameters = !0, this.state.yieldPos = -1, this.state.awaitPos = -1, this.state.inFSharpPipelineDirectBody = !1;\n        const p = this.state.start,\n              c = this.state.startLoc,\n              u = [],\n              l = new xt(),\n              d = {\n          start: 0\n        };\n        let m,\n            f,\n            D = !0;\n\n        for (; !this.match(n.parenR);) {\n          if (D) D = !1;else if (this.expect(n.comma, d.start || null), this.match(n.parenR)) {\n            f = this.state.start;\n            break;\n          }\n\n          if (this.match(n.ellipsis)) {\n            const t = this.state.start,\n                  e = this.state.startLoc;\n            m = this.state.start, u.push(this.parseParenItem(this.parseRestBinding(), t, e)), this.checkCommaAfterRest(41);\n            break;\n          }\n\n          u.push(this.parseMaybeAssign(!1, l, this.parseParenItem, d));\n        }\n\n        const y = this.state.start,\n              x = this.state.startLoc;\n        this.expect(n.parenR), this.state.maybeInArrowParameters = r, this.state.inFSharpPipelineDirectBody = h;\n        let g = this.startNodeAt(e, s);\n\n        if (t && this.shouldParseArrow() && (g = this.parseArrow(g))) {\n          this.isAwaitAllowed() || this.state.maybeInAsyncArrowHead || (this.state.awaitPos = o), this.checkYieldAwaitInDefaultParams(), this.state.yieldPos = a, this.state.awaitPos = o;\n\n          for (let t = 0; t < u.length; t++) {\n            const e = u[t];\n            e.extra && e.extra.parenthesized && this.unexpected(e.extra.parenStart);\n          }\n\n          return this.parseArrowExpression(g, u, !1), g;\n        }\n\n        if (-1 !== a && (this.state.yieldPos = a), -1 !== o && (this.state.awaitPos = o), u.length || this.unexpected(this.state.lastTokStart), f && this.unexpected(f), m && this.unexpected(m), this.checkExpressionErrors(l, !0), d.start && this.unexpected(d.start), this.toReferencedListDeep(u, !0), u.length > 1 ? (i = this.startNodeAt(p, c), i.expressions = u, this.finishNodeAt(i, \"SequenceExpression\", y, x)) : i = u[0], !this.options.createParenthesizedExpressions) return this.addExtra(i, \"parenthesized\", !0), this.addExtra(i, \"parenStart\", e), i;\n        const P = this.startNodeAt(e, s);\n        return P.expression = i, this.finishNode(P, \"ParenthesizedExpression\"), P;\n      }\n\n      shouldParseArrow() {\n        return !this.canInsertSemicolon();\n      }\n\n      parseArrow(t) {\n        if (this.eat(n.arrow)) return t;\n      }\n\n      parseParenItem(t, e, s) {\n        return t;\n      }\n\n      parseNew() {\n        const t = this.startNode();\n        let e = this.startNode();\n\n        if (this.next(), e = this.createIdentifier(e, \"new\"), this.eat(n.dot)) {\n          const s = this.parseMetaProperty(t, e, \"target\");\n\n          if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n            let t = f.UnexpectedNewTarget;\n            this.hasPlugin(\"classProperties\") && (t += \" or class properties\"), this.raise(s.start, t);\n          }\n\n          return s;\n        }\n\n        return t.callee = this.parseNoCallExpr(), \"Import\" === t.callee.type ? this.raise(t.callee.start, f.ImportCallNotNewExpression) : \"OptionalMemberExpression\" === t.callee.type || \"OptionalCallExpression\" === t.callee.type ? this.raise(this.state.lastTokEnd, f.OptionalChainingNoNew) : this.eat(n.questionDot) && this.raise(this.state.start, f.OptionalChainingNoNew), this.parseNewArguments(t), this.finishNode(t, \"NewExpression\");\n      }\n\n      parseNewArguments(t) {\n        if (this.eat(n.parenL)) {\n          const e = this.parseExprList(n.parenR);\n          this.toReferencedList(e), t.arguments = e;\n        } else t.arguments = [];\n      }\n\n      parseTemplateElement(t) {\n        const e = this.startNode();\n        return null === this.state.value && (t || this.raise(this.state.start + 1, f.InvalidEscapeSequenceTemplate)), e.value = {\n          raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n          cooked: this.state.value\n        }, this.next(), e.tail = this.match(n.backQuote), this.finishNode(e, \"TemplateElement\");\n      }\n\n      parseTemplate(t) {\n        const e = this.startNode();\n        this.next(), e.expressions = [];\n        let s = this.parseTemplateElement(t);\n\n        for (e.quasis = [s]; !s.tail;) this.expect(n.dollarBraceL), e.expressions.push(this.parseExpression()), this.expect(n.braceR), e.quasis.push(s = this.parseTemplateElement(t));\n\n        return this.next(), this.finishNode(e, \"TemplateLiteral\");\n      }\n\n      parseObj(t, e, s, i) {\n        const r = Object.create(null);\n        let a = !0;\n        const o = this.startNode();\n\n        for (o.properties = [], this.next(); !this.eat(t);) {\n          if (a) a = !1;else if (this.expect(n.comma), this.match(t)) {\n            this.addExtra(o, \"trailingComma\", this.state.lastTokStart), this.next();\n            break;\n          }\n          const s = this.parseObjectMember(e, i);\n          e || this.checkDuplicatedProto(s, r, i), s.shorthand && this.addExtra(s, \"shorthand\", !0), o.properties.push(s);\n        }\n\n        let h = \"ObjectExpression\";\n        return e ? h = \"ObjectPattern\" : s && (h = \"RecordExpression\"), this.finishNode(o, h);\n      }\n\n      isAsyncProp(t) {\n        return !t.computed && \"Identifier\" === t.key.type && \"async\" === t.key.name && (this.match(n.name) || this.match(n.num) || this.match(n.string) || this.match(n.bracketL) || this.state.type.keyword || this.match(n.star)) && !this.hasPrecedingLineBreak();\n      }\n\n      parseObjectMember(t, e) {\n        let s = [];\n        if (this.match(n.at)) for (this.hasPlugin(\"decorators\") && this.raise(this.state.start, f.UnsupportedPropertyDecorator); this.match(n.at);) s.push(this.parseDecorator());\n        const i = this.startNode();\n        let r,\n            a,\n            o = !1,\n            h = !1;\n        if (this.match(n.ellipsis)) return s.length && this.unexpected(), t ? (this.next(), i.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(i, \"RestElement\")) : this.parseSpread();\n        s.length && (i.decorators = s, s = []), i.method = !1, (t || e) && (r = this.state.start, a = this.state.startLoc), t || (o = this.eat(n.star));\n        const p = this.state.containsEsc;\n        return this.parsePropertyName(i, !1), t || p || o || !this.isAsyncProp(i) ? h = !1 : (h = !0, o = this.eat(n.star), this.parsePropertyName(i, !1)), this.parseObjPropValue(i, r, a, o, h, t, e, p), i;\n      }\n\n      isGetterOrSetterMethod(t, e) {\n        return !e && !t.computed && \"Identifier\" === t.key.type && (\"get\" === t.key.name || \"set\" === t.key.name) && (this.match(n.string) || this.match(n.num) || this.match(n.bracketL) || this.match(n.name) || !!this.state.type.keyword);\n      }\n\n      getGetterSetterExpectedParamCount(t) {\n        return \"get\" === t.kind ? 0 : 1;\n      }\n\n      checkGetterSetterParams(t) {\n        const e = this.getGetterSetterExpectedParamCount(t),\n              s = t.start;\n        t.params.length !== e && (\"get\" === t.kind ? this.raise(s, f.BadGetterArity) : this.raise(s, f.BadSetterArity)), \"set\" === t.kind && \"RestElement\" === t.params[t.params.length - 1].type && this.raise(s, f.BadSetterRestParameter);\n      }\n\n      parseObjectMethod(t, e, s, i, r) {\n        return s || e || this.match(n.parenL) ? (i && this.unexpected(), t.kind = \"method\", t.method = !0, this.parseMethod(t, e, s, !1, !1, \"ObjectMethod\")) : !r && this.isGetterOrSetterMethod(t, i) ? ((e || s) && this.unexpected(), t.kind = t.key.name, this.parsePropertyName(t, !1), this.parseMethod(t, !1, !1, !1, !1, \"ObjectMethod\"), this.checkGetterSetterParams(t), t) : void 0;\n      }\n\n      parseObjectProperty(t, e, s, i, r) {\n        return t.shorthand = !1, this.eat(n.colon) ? (t.value = i ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(!1, r), this.finishNode(t, \"ObjectProperty\")) : t.computed || \"Identifier\" !== t.key.type ? void 0 : (this.checkReservedWord(t.key.name, t.key.start, !0, !0), i ? t.value = this.parseMaybeDefault(e, s, t.key.__clone()) : this.match(n.eq) && r ? (-1 === r.shorthandAssign && (r.shorthandAssign = this.state.start), t.value = this.parseMaybeDefault(e, s, t.key.__clone())) : t.value = t.key.__clone(), t.shorthand = !0, this.finishNode(t, \"ObjectProperty\"));\n      }\n\n      parseObjPropValue(t, e, s, i, r, a, n, o) {\n        const h = this.parseObjectMethod(t, i, r, a, o) || this.parseObjectProperty(t, e, s, a, n);\n        return h || this.unexpected(), h;\n      }\n\n      parsePropertyName(t, e) {\n        if (this.eat(n.bracketL)) t.computed = !0, t.key = this.parseMaybeAssign(), this.expect(n.bracketR);else {\n          const s = this.state.inPropertyName;\n          this.state.inPropertyName = !0, t.key = this.match(n.num) || this.match(n.string) || this.match(n.bigint) ? this.parseExprAtom() : this.parseMaybePrivateName(e), \"PrivateName\" !== t.key.type && (t.computed = !1), this.state.inPropertyName = s;\n        }\n        return t.key;\n      }\n\n      initFunction(t, e) {\n        t.id = null, t.generator = !1, t.async = !!e;\n      }\n\n      parseMethod(t, e, s, i, r, a) {\n        let n = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;\n        const o = this.state.yieldPos,\n              h = this.state.awaitPos;\n        this.state.yieldPos = -1, this.state.awaitPos = -1, this.initFunction(t, s), t.generator = !!e;\n        const p = i;\n        return this.scope.enter(18 | (n ? 64 : 0) | (r ? 32 : 0)), this.prodParam.enter(et(s, t.generator)), this.parseFunctionParams(t, p), this.parseFunctionBodyAndFinish(t, a, !0), this.prodParam.exit(), this.scope.exit(), this.state.yieldPos = o, this.state.awaitPos = h, t;\n      }\n\n      parseArrowExpression(t, e, s, i) {\n        this.scope.enter(6), this.prodParam.enter(et(s, !1)), this.initFunction(t, s);\n        const r = this.state.maybeInArrowParameters,\n              a = this.state.yieldPos,\n              n = this.state.awaitPos;\n        return e && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, e, i)), this.state.maybeInArrowParameters = !1, this.state.yieldPos = -1, this.state.awaitPos = -1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = r, this.state.yieldPos = a, this.state.awaitPos = n, this.finishNode(t, \"ArrowFunctionExpression\");\n      }\n\n      setArrowFunctionParameters(t, e, s) {\n        t.params = this.toAssignableList(e, s);\n      }\n\n      parseFunctionBodyAndFinish(t, e) {\n        let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        this.parseFunctionBody(t, !1, s), this.finishNode(t, e);\n      }\n\n      parseFunctionBody(t, e) {\n        let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        const i = e && !this.match(n.braceL),\n              r = this.state.inParameters;\n        if (this.state.inParameters = !1, i) t.body = this.parseMaybeAssign(), this.checkParams(t, !1, e, !1);else {\n          const i = this.state.strict,\n                r = this.state.labels;\n          this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), t.body = this.parseBlock(!0, !1, r => {\n            const a = !this.isSimpleParamList(t.params);\n\n            if (r && a) {\n              const e = \"method\" !== t.kind && \"constructor\" !== t.kind || !t.key ? t.start : t.key.end;\n              this.raise(e, f.IllegalLanguageModeDirective);\n            }\n\n            const n = !i && this.state.strict;\n            this.checkParams(t, !(this.state.strict || e || s || a), e, n), this.state.strict && t.id && this.checkLVal(t.id, 65, void 0, \"function name\", void 0, n);\n          }), this.prodParam.exit(), this.state.labels = r;\n        }\n        this.state.inParameters = r;\n      }\n\n      isSimpleParamList(t) {\n        for (let e = 0, s = t.length; e < s; e++) if (\"Identifier\" !== t[e].type) return !1;\n\n        return !0;\n      }\n\n      checkParams(t, e, s) {\n        let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;\n        const r = Object.create(null);\n\n        for (let s = 0; s < t.params.length; s++) this.checkLVal(t.params[s], 5, e ? null : r, \"function parameter list\", void 0, i);\n      }\n\n      parseExprList(t, e, s, i) {\n        const r = [];\n        let a = !0;\n\n        for (; !this.eat(t);) {\n          if (a) a = !1;else if (this.expect(n.comma), this.match(t)) {\n            i && this.addExtra(i, \"trailingComma\", this.state.lastTokStart), this.next();\n            break;\n          }\n          r.push(this.parseExprListItem(e, s));\n        }\n\n        return r;\n      }\n\n      parseExprListItem(t, e, s, i) {\n        let r;\n        if (t && this.match(n.comma)) r = null;else if (this.match(n.ellipsis)) {\n          const t = this.state.start,\n                i = this.state.startLoc;\n          r = this.parseParenItem(this.parseSpread(e, s), t, i);\n        } else if (this.match(n.question)) {\n          this.expectPlugin(\"partialApplication\"), i || this.raise(this.state.start, f.UnexpectedArgumentPlaceholder);\n          const t = this.startNode();\n          this.next(), r = this.finishNode(t, \"ArgumentPlaceholder\");\n        } else r = this.parseMaybeAssign(!1, e, this.parseParenItem, s);\n        return r;\n      }\n\n      parseIdentifier(t) {\n        const e = this.startNode(),\n              s = this.parseIdentifierName(e.start, t);\n        return this.createIdentifier(e, s);\n      }\n\n      createIdentifier(t, e) {\n        return t.name = e, t.loc.identifierName = e, this.finishNode(t, \"Identifier\");\n      }\n\n      parseIdentifierName(t, e) {\n        let s;\n        if (this.match(n.name)) s = this.state.value;else {\n          if (!this.state.type.keyword) throw this.unexpected();\n          s = this.state.type.keyword, \"class\" !== s && \"function\" !== s || this.state.lastTokEnd === this.state.lastTokStart + 1 && 46 === this.input.charCodeAt(this.state.lastTokStart) || this.state.context.pop();\n        }\n        return e ? this.state.type = n.name : this.checkReservedWord(s, this.state.start, !!this.state.type.keyword, !1), this.next(), s;\n      }\n\n      checkReservedWord(t, e, s, i) {\n        if (this.prodParam.hasYield && \"yield\" === t) return void this.raise(e, f.YieldBindingIdentifier);\n\n        if (\"await\" === t) {\n          if (this.prodParam.hasAwait) return void this.raise(e, f.AwaitBindingIdentifier);\n          -1 === this.state.awaitPos && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed()) && (this.state.awaitPos = this.state.start);\n        }\n\n        if (this.scope.inClass && !this.scope.inNonArrowFunction && \"arguments\" === t) return void this.raise(e, f.ArgumentsDisallowedInInitializer);\n        if (s && function (t) {\n          return k.has(t);\n        }(t)) return void this.raise(e, f.UnexpectedKeyword, t);\n        (this.state.strict ? i ? O : B : L)(t, this.inModule) && (this.prodParam.hasAwait || \"await\" !== t ? this.raise(e, f.UnexpectedReservedWord, t) : this.raise(e, f.AwaitNotInAsyncFunction));\n      }\n\n      isAwaitAllowed() {\n        return this.scope.inFunction ? this.prodParam.hasAwait : !!this.options.allowAwaitOutsideFunction || !!this.hasPlugin(\"topLevelAwait\") && this.inModule && this.prodParam.hasAwait;\n      }\n\n      parseAwait() {\n        const t = this.startNode();\n        return this.next(), this.state.inParameters ? this.raise(t.start, f.AwaitExpressionFormalParameter) : -1 === this.state.awaitPos && (this.state.awaitPos = t.start), this.eat(n.star) && this.raise(t.start, f.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.hasPrecedingLineBreak() || this.match(n.plusMin) || this.match(n.parenL) || this.match(n.bracketL) || this.match(n.backQuote) || this.match(n.regexp) || this.match(n.slash) || this.hasPlugin(\"v8intrinsic\") && this.match(n.modulo) ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (t.argument = this.parseMaybeUnary()), this.finishNode(t, \"AwaitExpression\");\n      }\n\n      parseYield(t) {\n        const e = this.startNode();\n        return this.state.inParameters ? this.raise(e.start, f.YieldInParameter) : -1 === this.state.yieldPos && (this.state.yieldPos = e.start), this.next(), this.match(n.semi) || !this.match(n.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak() ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat(n.star), e.argument = this.parseMaybeAssign(t)), this.finishNode(e, \"YieldExpression\");\n      }\n\n      checkPipelineAtInfixOperator(t, e) {\n        \"smart\" === this.getPluginOption(\"pipelineOperator\", \"proposal\") && \"SequenceExpression\" === t.type && this.raise(e, f.PipelineHeadSequenceExpression);\n      }\n\n      parseSmartPipelineBody(t, e, s) {\n        const i = this.checkSmartPipelineBodyStyle(t);\n        return this.checkSmartPipelineBodyEarlyErrors(t, i, e), this.parseSmartPipelineBodyInStyle(t, i, e, s);\n      }\n\n      checkSmartPipelineBodyEarlyErrors(t, e, s) {\n        if (this.match(n.arrow)) throw this.raise(this.state.start, f.PipelineBodyNoArrow);\n        \"PipelineTopicExpression\" === e && \"SequenceExpression\" === t.type && this.raise(s, f.PipelineBodySequenceExpression);\n      }\n\n      parseSmartPipelineBodyInStyle(t, e, s, i) {\n        const r = this.startNodeAt(s, i);\n\n        switch (e) {\n          case \"PipelineBareFunction\":\n            r.callee = t;\n            break;\n\n          case \"PipelineBareConstructor\":\n            r.callee = t.callee;\n            break;\n\n          case \"PipelineBareAwaitedFunction\":\n            r.callee = t.argument;\n            break;\n\n          case \"PipelineTopicExpression\":\n            this.topicReferenceWasUsedInCurrentTopicContext() || this.raise(s, f.PipelineTopicUnused), r.expression = t;\n            break;\n\n          default:\n            throw new Error(\"Internal @babel/parser error: Unknown pipeline style (\".concat(e, \")\"));\n        }\n\n        return this.finishNode(r, e);\n      }\n\n      checkSmartPipelineBodyStyle(t) {\n        return t.type, this.isSimpleReference(t) ? \"PipelineBareFunction\" : \"PipelineTopicExpression\";\n      }\n\n      isSimpleReference(t) {\n        switch (t.type) {\n          case \"MemberExpression\":\n            return !t.computed && this.isSimpleReference(t.object);\n\n          case \"Identifier\":\n            return !0;\n\n          default:\n            return !1;\n        }\n      }\n\n      withTopicPermittingContext(t) {\n        const e = this.state.topicContext;\n        this.state.topicContext = {\n          maxNumOfResolvableTopics: 1,\n          maxTopicIndex: null\n        };\n\n        try {\n          return t();\n        } finally {\n          this.state.topicContext = e;\n        }\n      }\n\n      withTopicForbiddingContext(t) {\n        const e = this.state.topicContext;\n        this.state.topicContext = {\n          maxNumOfResolvableTopics: 0,\n          maxTopicIndex: null\n        };\n\n        try {\n          return t();\n        } finally {\n          this.state.topicContext = e;\n        }\n      }\n\n      withSoloAwaitPermittingContext(t) {\n        const e = this.state.soloAwait;\n        this.state.soloAwait = !0;\n\n        try {\n          return t();\n        } finally {\n          this.state.soloAwait = e;\n        }\n      }\n\n      registerTopicReference() {\n        this.state.topicContext.maxTopicIndex = 0;\n      }\n\n      primaryTopicReferenceIsAllowedInCurrentTopicContext() {\n        return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n      }\n\n      topicReferenceWasUsedInCurrentTopicContext() {\n        return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;\n      }\n\n      parseFSharpPipelineBody(t, e) {\n        const s = this.state.start,\n              i = this.state.startLoc;\n        this.state.potentialArrowAt = this.state.start;\n        const r = this.state.inFSharpPipelineDirectBody;\n        this.state.inFSharpPipelineDirectBody = !0;\n        const a = this.parseExprOp(this.parseMaybeUnary(), s, i, t, e);\n        return this.state.inFSharpPipelineDirectBody = r, a;\n      }\n\n    } {\n      parseTopLevel(t, e) {\n        if (e.sourceType = this.options.sourceType, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, n.eof), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (let t = 0, e = Array.from(this.scope.undefinedExports); t < e.length; t++) {\n          const [s] = e[t],\n                i = this.scope.undefinedExports.get(s);\n          this.raise(i, f.ModuleExportUndefined, s);\n        }\n        return t.program = this.finishNode(e, \"Program\"), t.comments = this.state.comments, this.options.tokens && (t.tokens = this.tokens), this.finishNode(t, \"File\");\n      }\n\n      stmtToDirective(t) {\n        const e = t.expression,\n              s = this.startNodeAt(e.start, e.loc.start),\n              i = this.startNodeAt(t.start, t.loc.start),\n              r = this.input.slice(e.start, e.end),\n              a = s.value = r.slice(1, -1);\n        return this.addExtra(s, \"raw\", r), this.addExtra(s, \"rawValue\", a), i.value = this.finishNodeAt(s, \"DirectiveLiteral\", e.end, e.loc.end), this.finishNodeAt(i, \"Directive\", t.end, t.loc.end);\n      }\n\n      parseInterpreterDirective() {\n        if (!this.match(n.interpreterDirective)) return null;\n        const t = this.startNode();\n        return t.value = this.state.value, this.next(), this.finishNode(t, \"InterpreterDirective\");\n      }\n\n      isLet(t) {\n        if (!this.isContextual(\"let\")) return !1;\n        const e = this.nextTokenStart(),\n              s = this.input.charCodeAt(e);\n        if (91 === s) return !0;\n        if (t) return !1;\n        if (123 === s) return !0;\n\n        if (w(s)) {\n          let t = e + 1;\n\n          for (; S(this.input.charCodeAt(t));) ++t;\n\n          const s = this.input.slice(e, t);\n          if (!R.test(s)) return !0;\n        }\n\n        return !1;\n      }\n\n      parseStatement(t, e) {\n        return this.match(n.at) && this.parseDecorators(!0), this.parseStatementContent(t, e);\n      }\n\n      parseStatementContent(t, e) {\n        let s = this.state.type;\n        const i = this.startNode();\n        let r;\n\n        switch (this.isLet(t) && (s = n._var, r = \"let\"), s) {\n          case n._break:\n          case n._continue:\n            return this.parseBreakContinueStatement(i, s.keyword);\n\n          case n._debugger:\n            return this.parseDebuggerStatement(i);\n\n          case n._do:\n            return this.parseDoStatement(i);\n\n          case n._for:\n            return this.parseForStatement(i);\n\n          case n._function:\n            if (46 === this.lookaheadCharCode()) break;\n            return t && (this.state.strict ? this.raise(this.state.start, f.StrictFunction) : \"if\" !== t && \"label\" !== t && this.raise(this.state.start, f.SloppyFunction)), this.parseFunctionStatement(i, !1, !t);\n\n          case n._class:\n            return t && this.unexpected(), this.parseClass(i, !0);\n\n          case n._if:\n            return this.parseIfStatement(i);\n\n          case n._return:\n            return this.parseReturnStatement(i);\n\n          case n._switch:\n            return this.parseSwitchStatement(i);\n\n          case n._throw:\n            return this.parseThrowStatement(i);\n\n          case n._try:\n            return this.parseTryStatement(i);\n\n          case n._const:\n          case n._var:\n            return r = r || this.state.value, t && \"var\" !== r && this.raise(this.state.start, f.UnexpectedLexicalDeclaration), this.parseVarStatement(i, r);\n\n          case n._while:\n            return this.parseWhileStatement(i);\n\n          case n._with:\n            return this.parseWithStatement(i);\n\n          case n.braceL:\n            return this.parseBlock();\n\n          case n.semi:\n            return this.parseEmptyStatement(i);\n\n          case n._export:\n          case n._import:\n            {\n              const t = this.lookaheadCharCode();\n              if (40 === t || 46 === t) break;\n              let r;\n              return this.options.allowImportExportEverywhere || e || this.raise(this.state.start, f.UnexpectedImportExport), this.next(), s === n._import ? (r = this.parseImport(i), \"ImportDeclaration\" !== r.type || r.importKind && \"value\" !== r.importKind || (this.sawUnambiguousESM = !0)) : (r = this.parseExport(i), (\"ExportNamedDeclaration\" !== r.type || r.exportKind && \"value\" !== r.exportKind) && (\"ExportAllDeclaration\" !== r.type || r.exportKind && \"value\" !== r.exportKind) && \"ExportDefaultDeclaration\" !== r.type || (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(i), r;\n            }\n\n          default:\n            if (this.isAsyncFunction()) return t && this.raise(this.state.start, f.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(i, !0, !t);\n        }\n\n        const a = this.state.value,\n              o = this.parseExpression();\n        return s === n.name && \"Identifier\" === o.type && this.eat(n.colon) ? this.parseLabeledStatement(i, a, o, t) : this.parseExpressionStatement(i, o);\n      }\n\n      assertModuleNodeAllowed(t) {\n        this.options.allowImportExportEverywhere || this.inModule || this.raiseWithData(t.start, {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        }, f.ImportOutsideModule);\n      }\n\n      takeDecorators(t) {\n        const e = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n        e.length && (t.decorators = e, this.resetStartLocationFromNode(t, e[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);\n      }\n\n      canHaveLeadingDecorator() {\n        return this.match(n._class);\n      }\n\n      parseDecorators(t) {\n        const e = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n        for (; this.match(n.at);) {\n          const t = this.parseDecorator();\n          e.push(t);\n        }\n\n        if (this.match(n._export)) t || this.unexpected(), this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") && this.raise(this.state.start, f.DecoratorExportClass);else if (!this.canHaveLeadingDecorator()) throw this.raise(this.state.start, f.UnexpectedLeadingDecorator);\n      }\n\n      parseDecorator() {\n        this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n        const t = this.startNode();\n\n        if (this.next(), this.hasPlugin(\"decorators\")) {\n          this.state.decoratorStack.push([]);\n          const e = this.state.start,\n                s = this.state.startLoc;\n          let i;\n          if (this.eat(n.parenL)) i = this.parseExpression(), this.expect(n.parenR);else for (i = this.parseIdentifier(!1); this.eat(n.dot);) {\n            const t = this.startNodeAt(e, s);\n            t.object = i, t.property = this.parseIdentifier(!0), t.computed = !1, i = this.finishNode(t, \"MemberExpression\");\n          }\n          t.expression = this.parseMaybeDecoratorArguments(i), this.state.decoratorStack.pop();\n        } else t.expression = this.parseExprSubscripts();\n\n        return this.finishNode(t, \"Decorator\");\n      }\n\n      parseMaybeDecoratorArguments(t) {\n        if (this.eat(n.parenL)) {\n          const e = this.startNodeAtNode(t);\n          return e.callee = t, e.arguments = this.parseCallExpressionArguments(n.parenR, !1), this.toReferencedList(e.arguments), this.finishNode(e, \"CallExpression\");\n        }\n\n        return t;\n      }\n\n      parseBreakContinueStatement(t, e) {\n        const s = \"break\" === e;\n        return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, s ? \"BreakStatement\" : \"ContinueStatement\");\n      }\n\n      verifyBreakContinue(t, e) {\n        const s = \"break\" === e;\n        let i;\n\n        for (i = 0; i < this.state.labels.length; ++i) {\n          const e = this.state.labels[i];\n\n          if (null == t.label || e.name === t.label.name) {\n            if (null != e.kind && (s || \"loop\" === e.kind)) break;\n            if (t.label && s) break;\n          }\n        }\n\n        i === this.state.labels.length && this.raise(t.start, f.IllegalBreakContinue, e);\n      }\n\n      parseDebuggerStatement(t) {\n        return this.next(), this.semicolon(), this.finishNode(t, \"DebuggerStatement\");\n      }\n\n      parseHeaderExpression() {\n        this.expect(n.parenL);\n        const t = this.parseExpression();\n        return this.expect(n.parenR), t;\n      }\n\n      parseDoStatement(t) {\n        return this.next(), this.state.labels.push(Et), t.body = this.withTopicForbiddingContext(() => this.parseStatement(\"do\")), this.state.labels.pop(), this.expect(n._while), t.test = this.parseHeaderExpression(), this.eat(n.semi), this.finishNode(t, \"DoWhileStatement\");\n      }\n\n      parseForStatement(t) {\n        this.next(), this.state.labels.push(Et);\n        let e = -1;\n        if (this.isAwaitAllowed() && this.eatContextual(\"await\") && (e = this.state.lastTokStart), this.scope.enter(0), this.expect(n.parenL), this.match(n.semi)) return e > -1 && this.unexpected(e), this.parseFor(t, null);\n        const s = this.isLet();\n\n        if (this.match(n._var) || this.match(n._const) || s) {\n          const i = this.startNode(),\n                r = s ? \"let\" : this.state.value;\n          return this.next(), this.parseVar(i, !0, r), this.finishNode(i, \"VariableDeclaration\"), (this.match(n._in) || this.isContextual(\"of\")) && 1 === i.declarations.length ? this.parseForIn(t, i, e) : (e > -1 && this.unexpected(e), this.parseFor(t, i));\n        }\n\n        const i = new xt(),\n              r = this.parseExpression(!0, i);\n\n        if (this.match(n._in) || this.isContextual(\"of\")) {\n          this.toAssignable(r);\n          const s = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n          return this.checkLVal(r, void 0, void 0, s), this.parseForIn(t, r, e);\n        }\n\n        return this.checkExpressionErrors(i, !0), e > -1 && this.unexpected(e), this.parseFor(t, r);\n      }\n\n      parseFunctionStatement(t, e, s) {\n        return this.next(), this.parseFunction(t, 1 | (s ? 0 : 2), e);\n      }\n\n      parseIfStatement(t) {\n        return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatement(\"if\"), t.alternate = this.eat(n._else) ? this.parseStatement(\"if\") : null, this.finishNode(t, \"IfStatement\");\n      }\n\n      parseReturnStatement(t) {\n        return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, f.IllegalReturn), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, \"ReturnStatement\");\n      }\n\n      parseSwitchStatement(t) {\n        this.next(), t.discriminant = this.parseHeaderExpression();\n        const e = t.cases = [];\n        let s, i;\n\n        for (this.expect(n.braceL), this.state.labels.push(Ct), this.scope.enter(0); !this.match(n.braceR);) if (this.match(n._case) || this.match(n._default)) {\n          const t = this.match(n._case);\n          s && this.finishNode(s, \"SwitchCase\"), e.push(s = this.startNode()), s.consequent = [], this.next(), t ? s.test = this.parseExpression() : (i && this.raise(this.state.lastTokStart, f.MultipleDefaultsInSwitch), i = !0, s.test = null), this.expect(n.colon);\n        } else s ? s.consequent.push(this.parseStatement(null)) : this.unexpected();\n\n        return this.scope.exit(), s && this.finishNode(s, \"SwitchCase\"), this.next(), this.state.labels.pop(), this.finishNode(t, \"SwitchStatement\");\n      }\n\n      parseThrowStatement(t) {\n        return this.next(), o.test(this.input.slice(this.state.lastTokEnd, this.state.start)) && this.raise(this.state.lastTokEnd, f.NewlineAfterThrow), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, \"ThrowStatement\");\n      }\n\n      parseTryStatement(t) {\n        if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(n._catch)) {\n          const e = this.startNode();\n\n          if (this.next(), this.match(n.parenL)) {\n            this.expect(n.parenL), e.param = this.parseBindingAtom();\n            const t = \"Identifier\" === e.param.type;\n            this.scope.enter(t ? 8 : 0), this.checkLVal(e.param, 9, null, \"catch clause\"), this.expect(n.parenR);\n          } else e.param = null, this.scope.enter(0);\n\n          e.body = this.withTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(e, \"CatchClause\");\n        }\n\n        return t.finalizer = this.eat(n._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, f.NoCatchOrFinally), this.finishNode(t, \"TryStatement\");\n      }\n\n      parseVarStatement(t, e) {\n        return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, \"VariableDeclaration\");\n      }\n\n      parseWhileStatement(t) {\n        return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(Et), t.body = this.withTopicForbiddingContext(() => this.parseStatement(\"while\")), this.state.labels.pop(), this.finishNode(t, \"WhileStatement\");\n      }\n\n      parseWithStatement(t) {\n        return this.state.strict && this.raise(this.state.start, f.StrictWith), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withTopicForbiddingContext(() => this.parseStatement(\"with\")), this.finishNode(t, \"WithStatement\");\n      }\n\n      parseEmptyStatement(t) {\n        return this.next(), this.finishNode(t, \"EmptyStatement\");\n      }\n\n      parseLabeledStatement(t, e, s, i) {\n        for (let t = 0, i = this.state.labels; t < i.length; t++) {\n          i[t].name === e && this.raise(s.start, f.LabelRedeclaration, e);\n        }\n\n        const r = this.state.type.isLoop ? \"loop\" : this.match(n._switch) ? \"switch\" : null;\n\n        for (let e = this.state.labels.length - 1; e >= 0; e--) {\n          const s = this.state.labels[e];\n          if (s.statementStart !== t.start) break;\n          s.statementStart = this.state.start, s.kind = r;\n        }\n\n        return this.state.labels.push({\n          name: e,\n          kind: r,\n          statementStart: this.state.start\n        }), t.body = this.parseStatement(i ? -1 === i.indexOf(\"label\") ? i + \"label\" : i : \"label\"), this.state.labels.pop(), t.label = s, this.finishNode(t, \"LabeledStatement\");\n      }\n\n      parseExpressionStatement(t, e) {\n        return t.expression = e, this.semicolon(), this.finishNode(t, \"ExpressionStatement\");\n      }\n\n      parseBlock() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n        let s = arguments.length > 2 ? arguments[2] : undefined;\n        const i = this.startNode();\n        return this.expect(n.braceL), e && this.scope.enter(0), this.parseBlockBody(i, t, !1, n.braceR, s), e && this.scope.exit(), this.finishNode(i, \"BlockStatement\");\n      }\n\n      isValidDirective(t) {\n        return \"ExpressionStatement\" === t.type && \"StringLiteral\" === t.expression.type && !t.expression.extra.parenthesized;\n      }\n\n      parseBlockBody(t, e, s, i, r) {\n        const a = t.body = [],\n              n = t.directives = [];\n        this.parseBlockOrModuleBlockBody(a, e ? n : void 0, s, i, r);\n      }\n\n      parseBlockOrModuleBlockBody(t, e, s, i, r) {\n        const a = [],\n              n = this.state.strict;\n        let o = !1,\n            h = !1;\n\n        for (; !this.match(i);) {\n          !h && this.state.octalPositions.length && a.push(...this.state.octalPositions);\n          const i = this.parseStatement(null, s);\n\n          if (e && !h && this.isValidDirective(i)) {\n            const t = this.stmtToDirective(i);\n            e.push(t), o || \"use strict\" !== t.value.value || (o = !0, this.setStrict(!0));\n          } else h = !0, t.push(i);\n        }\n\n        if (this.state.strict && a.length) for (let t = 0; t < a.length; t++) {\n          const e = a[t];\n          this.raise(e, f.StrictOctalLiteral);\n        }\n        r && r.call(this, o), n || this.setStrict(!1), this.next();\n      }\n\n      parseFor(t, e) {\n        return t.init = e, this.expect(n.semi), t.test = this.match(n.semi) ? null : this.parseExpression(), this.expect(n.semi), t.update = this.match(n.parenR) ? null : this.parseExpression(), this.expect(n.parenR), t.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, \"ForStatement\");\n      }\n\n      parseForIn(t, e, s) {\n        const i = this.match(n._in);\n        return this.next(), i ? s > -1 && this.unexpected(s) : t.await = s > -1, \"VariableDeclaration\" !== e.type || null == e.declarations[0].init || i && !this.state.strict && \"var\" === e.kind && \"Identifier\" === e.declarations[0].id.type ? \"AssignmentPattern\" === e.type && this.raise(e.start, f.InvalidLhs, \"for-loop\") : this.raise(e.start, f.ForInOfLoopInitializer, i ? \"for-in\" : \"for-of\"), t.left = e, t.right = i ? this.parseExpression() : this.parseMaybeAssign(), this.expect(n.parenR), t.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, i ? \"ForInStatement\" : \"ForOfStatement\");\n      }\n\n      parseVar(t, e, s) {\n        const i = t.declarations = [],\n              r = this.hasPlugin(\"typescript\");\n\n        for (t.kind = s;;) {\n          const t = this.startNode();\n          if (this.parseVarId(t, s), this.eat(n.eq) ? t.init = this.parseMaybeAssign(e) : (\"const\" !== s || this.match(n._in) || this.isContextual(\"of\") ? \"Identifier\" === t.id.type || e && (this.match(n._in) || this.isContextual(\"of\")) || this.raise(this.state.lastTokEnd, f.DeclarationMissingInitializer, \"Complex binding patterns\") : r || this.unexpected(), t.init = null), i.push(this.finishNode(t, \"VariableDeclarator\")), !this.eat(n.comma)) break;\n        }\n\n        return t;\n      }\n\n      parseVarId(t, e) {\n        t.id = this.parseBindingAtom(), this.checkLVal(t.id, \"var\" === e ? 5 : 9, void 0, \"variable declaration\", \"var\" !== e);\n      }\n\n      parseFunction(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n        const i = 1 & e,\n              r = 2 & e,\n              a = !(!i || 4 & e);\n        this.initFunction(t, s), this.match(n.star) && r && this.raise(this.state.start, f.GeneratorInSingleStatementContext), t.generator = this.eat(n.star), i && (t.id = this.parseFunctionId(a));\n        const o = this.state.maybeInArrowParameters,\n              h = this.state.yieldPos,\n              p = this.state.awaitPos;\n        return this.state.maybeInArrowParameters = !1, this.state.yieldPos = -1, this.state.awaitPos = -1, this.scope.enter(2), this.prodParam.enter(et(s, t.generator)), i || (t.id = this.parseFunctionId()), this.parseFunctionParams(t), this.withTopicForbiddingContext(() => {\n          this.parseFunctionBodyAndFinish(t, i ? \"FunctionDeclaration\" : \"FunctionExpression\");\n        }), this.prodParam.exit(), this.scope.exit(), i && !r && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, this.state.yieldPos = h, this.state.awaitPos = p, t;\n      }\n\n      parseFunctionId(t) {\n        return t || this.match(n.name) ? this.parseIdentifier() : null;\n      }\n\n      parseFunctionParams(t, e) {\n        const s = this.state.inParameters;\n        this.state.inParameters = !0, this.expect(n.parenL), t.params = this.parseBindingList(n.parenR, 41, !1, e), this.state.inParameters = s, this.checkYieldAwaitInDefaultParams();\n      }\n\n      registerFunctionStatementId(t) {\n        t.id && this.scope.declareName(t.id.name, this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, t.id.start);\n      }\n\n      parseClass(t, e, s) {\n        this.next(), this.takeDecorators(t);\n        const i = this.state.strict;\n        return this.state.strict = !0, this.parseClassId(t, e, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, i), this.state.strict = i, this.finishNode(t, e ? \"ClassDeclaration\" : \"ClassExpression\");\n      }\n\n      isClassProperty() {\n        return this.match(n.eq) || this.match(n.semi) || this.match(n.braceR);\n      }\n\n      isClassMethod() {\n        return this.match(n.parenL);\n      }\n\n      isNonstaticConstructor(t) {\n        return !(t.computed || t.static || \"constructor\" !== t.key.name && \"constructor\" !== t.key.value);\n      }\n\n      parseClassBody(t, e) {\n        this.classScope.enter();\n        const s = {\n          hadConstructor: !1\n        };\n        let i = [];\n        const r = this.startNode();\n        if (r.body = [], this.expect(n.braceL), this.withTopicForbiddingContext(() => {\n          for (; !this.match(n.braceR);) {\n            if (this.eat(n.semi)) {\n              if (i.length > 0) throw this.raise(this.state.lastTokEnd, f.DecoratorSemicolon);\n              continue;\n            }\n\n            if (this.match(n.at)) {\n              i.push(this.parseDecorator());\n              continue;\n            }\n\n            const e = this.startNode();\n            i.length && (e.decorators = i, this.resetStartLocationFromNode(e, i[0]), i = []), this.parseClassMember(r, e, s, t), \"constructor\" === e.kind && e.decorators && e.decorators.length > 0 && this.raise(e.start, f.DecoratorConstructor);\n          }\n        }), e || (this.state.strict = !1), this.next(), i.length) throw this.raise(this.state.start, f.TrailingDecorator);\n        return this.classScope.exit(), this.finishNode(r, \"ClassBody\");\n      }\n\n      parseClassMemberFromModifier(t, e) {\n        const s = this.state.containsEsc,\n              i = this.parseIdentifier(!0);\n\n        if (this.isClassMethod()) {\n          const s = e;\n          return s.kind = \"method\", s.computed = !1, s.key = i, s.static = !1, this.pushClassMethod(t, s, !1, !1, !1, !1), !0;\n        }\n\n        if (this.isClassProperty()) {\n          const s = e;\n          return s.computed = !1, s.key = i, s.static = !1, t.body.push(this.parseClassProperty(s)), !0;\n        }\n\n        if (s) throw this.unexpected();\n        return !1;\n      }\n\n      parseClassMember(t, e, s, i) {\n        const r = this.isContextual(\"static\");\n        r && this.parseClassMemberFromModifier(t, e) || this.parseClassMemberWithIsStatic(t, e, s, r, i);\n      }\n\n      parseClassMemberWithIsStatic(t, e, s, i, r) {\n        const a = e,\n              o = e,\n              h = e,\n              p = e,\n              c = a,\n              u = a;\n        if (e.static = i, this.eat(n.star)) return c.kind = \"method\", this.parseClassPropertyName(c), \"PrivateName\" === c.key.type ? void this.pushClassPrivateMethod(t, o, !0, !1) : (this.isNonstaticConstructor(a) && this.raise(a.key.start, f.ConstructorIsGenerator), void this.pushClassMethod(t, a, !0, !1, !1, !1));\n        const l = this.state.containsEsc,\n              d = this.parseClassPropertyName(e),\n              m = \"PrivateName\" === d.type,\n              D = \"Identifier\" === d.type,\n              y = this.state.start;\n\n        if (this.parsePostMemberNameModifiers(u), this.isClassMethod()) {\n          if (c.kind = \"method\", m) return void this.pushClassPrivateMethod(t, o, !1, !1);\n          const e = this.isNonstaticConstructor(a);\n          let i = !1;\n          e && (a.kind = \"constructor\", s.hadConstructor && !this.hasPlugin(\"typescript\") && this.raise(d.start, f.DuplicateConstructor), s.hadConstructor = !0, i = r), this.pushClassMethod(t, a, !1, !1, e, i);\n        } else if (this.isClassProperty()) m ? this.pushClassPrivateProperty(t, p) : this.pushClassProperty(t, h);else if (!D || \"async\" !== d.name || l || this.isLineTerminator()) !D || \"get\" !== d.name && \"set\" !== d.name || l || this.match(n.star) && this.isLineTerminator() ? this.isLineTerminator() ? m ? this.pushClassPrivateProperty(t, p) : this.pushClassProperty(t, h) : this.unexpected() : (c.kind = d.name, this.parseClassPropertyName(a), \"PrivateName\" === c.key.type ? this.pushClassPrivateMethod(t, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(a.key.start, f.ConstructorIsAccessor), this.pushClassMethod(t, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a));else {\n          const e = this.eat(n.star);\n          u.optional && this.unexpected(y), c.kind = \"method\", this.parseClassPropertyName(c), this.parsePostMemberNameModifiers(u), \"PrivateName\" === c.key.type ? this.pushClassPrivateMethod(t, o, e, !0) : (this.isNonstaticConstructor(a) && this.raise(a.key.start, f.ConstructorIsAsync), this.pushClassMethod(t, a, e, !0, !1, !1));\n        }\n      }\n\n      parseClassPropertyName(t) {\n        const e = this.parsePropertyName(t, !0);\n        return t.computed || !t.static || \"prototype\" !== e.name && \"prototype\" !== e.value || this.raise(e.start, f.StaticPrototype), \"PrivateName\" === e.type && \"constructor\" === e.id.name && this.raise(e.start, f.ConstructorClassPrivateField), e;\n      }\n\n      pushClassProperty(t, e) {\n        e.computed || \"constructor\" !== e.key.name && \"constructor\" !== e.key.value || this.raise(e.key.start, f.ConstructorClassField), t.body.push(this.parseClassProperty(e));\n      }\n\n      pushClassPrivateProperty(t, e) {\n        this.expectPlugin(\"classPrivateProperties\", e.key.start);\n        const s = this.parseClassPrivateProperty(e);\n        t.body.push(s), this.classScope.declarePrivateName(s.key.id.name, 0, s.key.start);\n      }\n\n      pushClassMethod(t, e, s, i, r, a) {\n        t.body.push(this.parseMethod(e, s, i, r, a, \"ClassMethod\", !0));\n      }\n\n      pushClassPrivateMethod(t, e, s, i) {\n        this.expectPlugin(\"classPrivateMethods\", e.key.start);\n        const r = this.parseMethod(e, s, i, !1, !1, \"ClassPrivateMethod\", !0);\n        t.body.push(r);\n        const a = \"get\" === r.kind ? r.static ? 6 : 2 : \"set\" === r.kind ? r.static ? 5 : 1 : 0;\n        this.classScope.declarePrivateName(r.key.id.name, a, r.key.start);\n      }\n\n      parsePostMemberNameModifiers(t) {}\n\n      parseAccessModifier() {}\n\n      parseClassPrivateProperty(t) {\n        return this.scope.enter(80), this.prodParam.enter(0), t.value = this.eat(n.eq) ? this.parseMaybeAssign() : null, this.semicolon(), this.prodParam.exit(), this.scope.exit(), this.finishNode(t, \"ClassPrivateProperty\");\n      }\n\n      parseClassProperty(t) {\n        return t.typeAnnotation || this.expectPlugin(\"classProperties\"), this.scope.enter(80), this.prodParam.enter(0), this.match(n.eq) ? (this.expectPlugin(\"classProperties\"), this.next(), t.value = this.parseMaybeAssign()) : t.value = null, this.semicolon(), this.prodParam.exit(), this.scope.exit(), this.finishNode(t, \"ClassProperty\");\n      }\n\n      parseClassId(t, e, s) {\n        let i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 139;\n        this.match(n.name) ? (t.id = this.parseIdentifier(), e && this.checkLVal(t.id, i, void 0, \"class name\")) : s || !e ? t.id = null : this.unexpected(null, f.MissingClassName);\n      }\n\n      parseClassSuper(t) {\n        t.superClass = this.eat(n._extends) ? this.parseExprSubscripts() : null;\n      }\n\n      parseExport(t) {\n        const e = this.maybeParseExportDefaultSpecifier(t),\n              s = !e || this.eat(n.comma),\n              i = s && this.eatExportStar(t),\n              r = i && this.maybeParseExportNamespaceSpecifier(t),\n              a = s && (!r || this.eat(n.comma)),\n              o = e || i;\n        if (i && !r) return e && this.unexpected(), this.parseExportFrom(t, !0), this.finishNode(t, \"ExportAllDeclaration\");\n        const h = this.maybeParseExportNamedSpecifiers(t);\n        if (e && s && !i && !h || r && a && !h) throw this.unexpected(null, n.braceL);\n        let p;\n        if (o || h ? (p = !1, this.parseExportFrom(t, o)) : p = this.maybeParseExportDeclaration(t), o || h || p) return this.checkExport(t, !0, !1, !!t.source), this.finishNode(t, \"ExportNamedDeclaration\");\n        if (this.eat(n._default)) return t.declaration = this.parseExportDefaultExpression(), this.checkExport(t, !0, !0), this.finishNode(t, \"ExportDefaultDeclaration\");\n        throw this.unexpected(null, n.braceL);\n      }\n\n      eatExportStar(t) {\n        return this.eat(n.star);\n      }\n\n      maybeParseExportDefaultSpecifier(t) {\n        if (this.isExportDefaultSpecifier()) {\n          this.expectPlugin(\"exportDefaultFrom\");\n          const e = this.startNode();\n          return e.exported = this.parseIdentifier(!0), t.specifiers = [this.finishNode(e, \"ExportDefaultSpecifier\")], !0;\n        }\n\n        return !1;\n      }\n\n      maybeParseExportNamespaceSpecifier(t) {\n        if (this.isContextual(\"as\")) {\n          t.specifiers || (t.specifiers = []);\n          const e = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n          return this.next(), e.exported = this.parseIdentifier(!0), t.specifiers.push(this.finishNode(e, \"ExportNamespaceSpecifier\")), !0;\n        }\n\n        return !1;\n      }\n\n      maybeParseExportNamedSpecifiers(t) {\n        return !!this.match(n.braceL) && (t.specifiers || (t.specifiers = []), t.specifiers.push(...this.parseExportSpecifiers()), t.source = null, t.declaration = null, !0);\n      }\n\n      maybeParseExportDeclaration(t) {\n        if (this.shouldParseExportDeclaration()) {\n          if (this.isContextual(\"async\")) {\n            const t = this.nextTokenStart();\n            this.isUnparsedContextual(t, \"function\") || this.unexpected(t, n._function);\n          }\n\n          return t.specifiers = [], t.source = null, t.declaration = this.parseExportDeclaration(t), !0;\n        }\n\n        return !1;\n      }\n\n      isAsyncFunction() {\n        if (!this.isContextual(\"async\")) return !1;\n        const t = this.nextTokenStart();\n        return !o.test(this.input.slice(this.state.pos, t)) && this.isUnparsedContextual(t, \"function\");\n      }\n\n      parseExportDefaultExpression() {\n        const t = this.startNode(),\n              e = this.isAsyncFunction();\n        if (this.match(n._function) || e) return this.next(), e && this.next(), this.parseFunction(t, 5, e);\n        if (this.match(n._class)) return this.parseClass(t, !0, !0);\n        if (this.match(n.at)) return this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") && this.raise(this.state.start, f.DecoratorBeforeExport), this.parseDecorators(!1), this.parseClass(t, !0, !0);\n        if (this.match(n._const) || this.match(n._var) || this.isLet()) throw this.raise(this.state.start, f.UnsupportedDefaultExport);\n        {\n          const t = this.parseMaybeAssign();\n          return this.semicolon(), t;\n        }\n      }\n\n      parseExportDeclaration(t) {\n        return this.parseStatement(null);\n      }\n\n      isExportDefaultSpecifier() {\n        if (this.match(n.name)) return \"async\" !== this.state.value && \"let\" !== this.state.value;\n        if (!this.match(n._default)) return !1;\n        const t = this.nextTokenStart();\n        return 44 === this.input.charCodeAt(t) || this.isUnparsedContextual(t, \"from\");\n      }\n\n      parseExportFrom(t, e) {\n        this.eatContextual(\"from\") ? (t.source = this.parseImportSource(), this.checkExport(t)) : e ? this.unexpected() : t.source = null, this.semicolon();\n      }\n\n      shouldParseExportDeclaration() {\n        if (this.match(n.at) && (this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]), this.hasPlugin(\"decorators\"))) {\n          if (!this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) return !0;\n          this.unexpected(this.state.start, f.DecoratorBeforeExport);\n        }\n\n        return \"var\" === this.state.type.keyword || \"const\" === this.state.type.keyword || \"function\" === this.state.type.keyword || \"class\" === this.state.type.keyword || this.isLet() || this.isAsyncFunction();\n      }\n\n      checkExport(t, e, s, i) {\n        if (e) if (s) this.checkDuplicateExports(t, \"default\");else if (t.specifiers && t.specifiers.length) for (let e = 0, s = t.specifiers; e < s.length; e++) {\n          const t = s[e];\n          this.checkDuplicateExports(t, t.exported.name), !i && t.local && (this.checkReservedWord(t.local.name, t.local.start, !0, !1), this.scope.checkLocalExport(t.local));\n        } else if (t.declaration) if (\"FunctionDeclaration\" === t.declaration.type || \"ClassDeclaration\" === t.declaration.type) {\n          const e = t.declaration.id;\n          if (!e) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(t, e.name);\n        } else if (\"VariableDeclaration\" === t.declaration.type) for (let e = 0, s = t.declaration.declarations; e < s.length; e++) {\n          const t = s[e];\n          this.checkDeclaration(t.id);\n        }\n\n        if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length) {\n          const e = t.declaration && (\"ClassDeclaration\" === t.declaration.type || \"ClassExpression\" === t.declaration.type);\n          if (!t.declaration || !e) throw this.raise(t.start, f.UnsupportedDecoratorExport);\n          this.takeDecorators(t.declaration);\n        }\n      }\n\n      checkDeclaration(t) {\n        if (\"Identifier\" === t.type) this.checkDuplicateExports(t, t.name);else if (\"ObjectPattern\" === t.type) for (let e = 0, s = t.properties; e < s.length; e++) {\n          const t = s[e];\n          this.checkDeclaration(t);\n        } else if (\"ArrayPattern\" === t.type) for (let e = 0, s = t.elements; e < s.length; e++) {\n          const t = s[e];\n          t && this.checkDeclaration(t);\n        } else \"ObjectProperty\" === t.type ? this.checkDeclaration(t.value) : \"RestElement\" === t.type ? this.checkDeclaration(t.argument) : \"AssignmentPattern\" === t.type && this.checkDeclaration(t.left);\n      }\n\n      checkDuplicateExports(t, e) {\n        this.state.exportedIdentifiers.indexOf(e) > -1 && this.raise(t.start, \"default\" === e ? f.DuplicateDefaultExport : f.DuplicateExport, e), this.state.exportedIdentifiers.push(e);\n      }\n\n      parseExportSpecifiers() {\n        const t = [];\n        let e = !0;\n\n        for (this.expect(n.braceL); !this.eat(n.braceR);) {\n          if (e) e = !1;else if (this.expect(n.comma), this.eat(n.braceR)) break;\n          const s = this.startNode();\n          s.local = this.parseIdentifier(!0), s.exported = this.eatContextual(\"as\") ? this.parseIdentifier(!0) : s.local.__clone(), t.push(this.finishNode(s, \"ExportSpecifier\"));\n        }\n\n        return t;\n      }\n\n      parseImport(t) {\n        if (t.specifiers = [], !this.match(n.string)) {\n          const e = !this.maybeParseDefaultImportSpecifier(t) || this.eat(n.comma),\n                s = e && this.maybeParseStarImportSpecifier(t);\n          e && !s && this.parseNamedImportSpecifiers(t), this.expectContextual(\"from\");\n        }\n\n        return t.source = this.parseImportSource(), this.semicolon(), this.finishNode(t, \"ImportDeclaration\");\n      }\n\n      parseImportSource() {\n        return this.match(n.string) || this.unexpected(), this.parseExprAtom();\n      }\n\n      shouldParseDefaultImport(t) {\n        return this.match(n.name);\n      }\n\n      parseImportSpecifierLocal(t, e, s, i) {\n        e.local = this.parseIdentifier(), this.checkLVal(e.local, 9, void 0, i), t.specifiers.push(this.finishNode(e, s));\n      }\n\n      maybeParseDefaultImportSpecifier(t) {\n        return !!this.shouldParseDefaultImport(t) && (this.parseImportSpecifierLocal(t, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\"), !0);\n      }\n\n      maybeParseStarImportSpecifier(t) {\n        if (this.match(n.star)) {\n          const e = this.startNode();\n          return this.next(), this.expectContextual(\"as\"), this.parseImportSpecifierLocal(t, e, \"ImportNamespaceSpecifier\", \"import namespace specifier\"), !0;\n        }\n\n        return !1;\n      }\n\n      parseNamedImportSpecifiers(t) {\n        let e = !0;\n\n        for (this.expect(n.braceL); !this.eat(n.braceR);) {\n          if (e) e = !1;else {\n            if (this.eat(n.colon)) throw this.raise(this.state.start, f.DestructureNamedImport);\n            if (this.expect(n.comma), this.eat(n.braceR)) break;\n          }\n          this.parseImportSpecifier(t);\n        }\n      }\n\n      parseImportSpecifier(t) {\n        const e = this.startNode();\n        e.imported = this.parseIdentifier(!0), this.eatContextual(\"as\") ? e.local = this.parseIdentifier() : (this.checkReservedWord(e.imported.name, e.start, !0, !0), e.local = e.imported.__clone()), this.checkLVal(e.local, 9, void 0, \"import specifier\"), t.specifiers.push(this.finishNode(e, \"ImportSpecifier\"));\n      }\n\n    } {\n      constructor(t, e) {\n        super(t = function (t) {\n          const e = {};\n\n          for (let s = 0, i = Object.keys(ut); s < i.length; s++) {\n            const r = i[s];\n            e[r] = t && null != t[r] ? t[r] : ut[r];\n          }\n\n          return e;\n        }(t), e);\n        const s = this.getScopeHandler();\n        this.options = t, this.inModule = \"module\" === this.options.sourceType, this.scope = new s(this.raise.bind(this), this.inModule), this.prodParam = new tt(), this.classScope = new Tt(this.raise.bind(this)), this.plugins = function (t) {\n          const e = new Map();\n\n          for (let s = 0; s < t.length; s++) {\n            const i = t[s],\n                  [r, a] = Array.isArray(i) ? i : [i, {}];\n            e.has(r) || e.set(r, a || {});\n          }\n\n          return e;\n        }(this.options.plugins), this.filename = t.sourceFilename;\n      }\n\n      getScopeHandler() {\n        return Y;\n      }\n\n      parse() {\n        let t = 0;\n        this.hasPlugin(\"topLevelAwait\") && this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);\n        const e = this.startNode(),\n              s = this.startNode();\n        return this.nextToken(), e.errors = null, this.parseTopLevel(e, s), e.errors = this.state.errors, e;\n      }\n\n    }\n\n    function wt(t, e) {\n      let s = At;\n      return t && t.plugins && (!function (t) {\n        if (at(t, \"decorators\")) {\n          if (at(t, \"decorators-legacy\")) throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n          const e = nt(t, \"decorators\", \"decoratorsBeforeExport\");\n          if (null == e) throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n          if (\"boolean\" != typeof e) throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n        }\n\n        if (at(t, \"flow\") && at(t, \"typescript\")) throw new Error(\"Cannot combine flow and typescript plugins.\");\n        if (at(t, \"placeholders\") && at(t, \"v8intrinsic\")) throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n        if (at(t, \"pipelineOperator\") && !ot.includes(nt(t, \"pipelineOperator\", \"proposal\"))) throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \" + ot.map(t => \"'\".concat(t, \"'\")).join(\", \"));\n        if (at(t, \"recordAndTuple\") && !ht.includes(nt(t, \"recordAndTuple\", \"syntaxType\"))) throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" + ht.map(t => \"'\".concat(t, \"'\")).join(\", \"));\n      }(t.plugins), s = function (t) {\n        const e = ct.filter(e => at(t, e)),\n              s = e.join(\"/\");\n        let i = St[s];\n\n        if (!i) {\n          i = At;\n\n          for (let t = 0; t < e.length; t++) {\n            const s = e[t];\n            i = pt[s](i);\n          }\n\n          St[s] = i;\n        }\n\n        return i;\n      }(t.plugins)), new s(t, e);\n    }\n\n    const St = {};\n    e.parse = function (t, e) {\n      if (!e || \"unambiguous\" !== e.sourceType) return wt(e, t).parse();\n      e = Object.assign({}, e);\n\n      try {\n        e.sourceType = \"module\";\n        const s = wt(e, t),\n              i = s.parse();\n        if (s.sawUnambiguousESM) return i;\n        if (s.ambiguousScriptDifferentAst) try {\n          return e.sourceType = \"script\", wt(e, t).parse();\n        } catch (t) {} else i.program.sourceType = \"script\";\n        return i;\n      } catch (s) {\n        try {\n          return e.sourceType = \"script\", wt(e, t).parse();\n        } catch (t) {}\n\n        throw s;\n      }\n    }, e.parseExpression = function (t, e) {\n      const s = wt(e, t);\n      return s.options.strictMode && (s.state.strict = !0), s.getExpression();\n    }, e.tokTypes = n;\n  });\n\n  s(Kt);\n  Kt.parse, Kt.parseExpression, Kt.tokTypes;\n  const {\n    hasPragma: Jt\n  } = c;\n\n  function Xt() {\n    let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    return {\n      sourceType: \"module\",\n      allowAwaitOutsideFunction: !0,\n      allowImportExportEverywhere: !0,\n      allowReturnOutsideFunction: !0,\n      allowSuperOutsideMethod: !0,\n      allowUndeclaredExports: !0,\n      errorRecovery: !0,\n      createParenthesizedExpressions: !0,\n      plugins: [\"doExpressions\", \"objectRestSpread\", \"classProperties\", \"exportDefaultFrom\", \"exportNamespaceFrom\", \"asyncGenerators\", \"functionBind\", \"functionSent\", \"dynamicImport\", \"numericSeparator\", \"importMeta\", \"optionalCatchBinding\", \"optionalChaining\", \"classPrivateProperties\", [\"pipelineOperator\", {\n        proposal: \"minimal\"\n      }], \"nullishCoalescingOperator\", \"bigInt\", \"throwExpressions\", \"logicalAssignment\", \"classPrivateMethods\", \"v8intrinsic\", \"partialApplication\", [\"decorators\", {\n        decoratorsBeforeExport: !1\n      }], ...t]\n    };\n  }\n\n  function Gt(t) {\n    for (var _len5 = arguments.length, s = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      s[_key5 - 1] = arguments[_key5];\n    }\n\n    return (i, r, a) => {\n      const n = Kt;\n      let o;\n\n      try {\n        o = function (t, e) {\n          let s;\n\n          for (let i = 0; i < e.length; i++) try {\n            return t(e[i]);\n          } catch (t) {\n            s || (s = t);\n          }\n\n          throw s;\n        }(e => n[t](i, e), s.map(Xt));\n      } catch (t) {\n        throw e(t.message.replace(/ \\(.*\\)/, \"\"), {\n          start: {\n            line: t.loc.line,\n            column: t.loc.column + 1\n          }\n        });\n      }\n\n      return delete o.tokens, Wt(o, Object.assign({}, a, {\n        originalText: i\n      }));\n    };\n  }\n\n  const Qt = Gt(\"parse\", [\"jsx\", \"flow\"]),\n        Yt = Gt(\"parse\", [\"jsx\", [\"flow\", {\n    all: !0,\n    enums: !0\n  }]]),\n        $t = Gt(\"parse\", [\"jsx\", \"typescript\"], [\"typescript\"]),\n        Zt = Gt(\"parseExpression\", [\"jsx\"]);\n\n  function te(t, s) {\n    switch (t.type) {\n      case \"ArrayExpression\":\n        return t.elements.forEach(i);\n\n      case \"ObjectExpression\":\n        return t.properties.forEach(i);\n\n      case \"ObjectProperty\":\n        if (t.computed) throw r(\"computed\");\n        if (t.shorthand) throw r(\"shorthand\");\n        return [t.key, t.value].forEach(i);\n\n      case \"UnaryExpression\":\n        switch (t.operator) {\n          case \"+\":\n          case \"-\":\n            return i(t.argument);\n\n          default:\n            throw r(\"operator\");\n        }\n\n      case \"Identifier\":\n        if (s && \"ObjectProperty\" === s.type && s.key === t) return;\n        throw r();\n\n      case \"NullLiteral\":\n      case \"BooleanLiteral\":\n      case \"NumericLiteral\":\n      case \"StringLiteral\":\n        return;\n\n      default:\n        throw r();\n    }\n\n    function i(e) {\n      return te(e, t);\n    }\n\n    function r(s) {\n      const i = s ? \"\".concat(t.type, \" with \").concat(s, \"=\").concat(JSON.stringify(t[s])) : t.type;\n      return e(\"\".concat(i, \" is not allowed in JSON.\"), {\n        start: {\n          line: t.loc.start.line,\n          column: t.loc.start.column + 1\n        }\n      });\n    }\n  }\n\n  const ee = Object.assign({\n    parse: Qt,\n    astFormat: \"estree\",\n    hasPragma: Jt\n  }, m),\n        se = Object.assign({}, ee, {\n    parse: Yt\n  }),\n        ie = Object.assign({}, ee, {\n    parse: $t\n  }),\n        re = Object.assign({}, ee, {\n    parse: Zt\n  });\n  var ae = {\n    parsers: {\n      babel: ee,\n      \"babel-flow\": se,\n      \"babel-ts\": ie,\n      json: Object.assign({}, re, {\n        hasPragma: () => !0\n      }),\n      json5: re,\n      \"json-stringify\": Object.assign({\n        parse: function (t, e, s) {\n          const i = Zt(t, e, s);\n          return i.comments.forEach(te), te(i), i;\n        },\n        astFormat: \"estree-json\"\n      }, m),\n      __js_expression: re,\n      __vue_expression: re,\n      __vue_event_binding: ee\n    }\n  },\n      ne = ae.parsers;\n  t.default = ae, t.parsers = ne, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJldHRpZXIvcGFyc2VyLWJhYmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ByZXR0aWVyL3BhcnNlci1iYWJlbC5qcz82MTAzIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOmUoKCh0PXR8fHNlbGYpLnByZXR0aWVyUGx1Z2lucz10LnByZXR0aWVyUGx1Z2luc3x8e30sdC5wcmV0dGllclBsdWdpbnMuYmFiZWw9e30pKX0odGhpcywoZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ZnVuY3Rpb24odCxlKXtjb25zdCBzPW5ldyBTeW50YXhFcnJvcih0K1wiIChcIitlLnN0YXJ0LmxpbmUrXCI6XCIrZS5zdGFydC5jb2x1bW4rXCIpXCIpO3JldHVybiBzLmxvYz1lLHN9O2Z1bmN0aW9uIHModCl7cmV0dXJuIHQmJnQuX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsXCJkZWZhdWx0XCIpP3QuZGVmYXVsdDp0fWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4gdChlPXtleHBvcnRzOnt9fSxlLmV4cG9ydHMpLGUuZXhwb3J0c312YXIgcj1PYmplY3QuZnJlZXplKHtfX3Byb3RvX186bnVsbCxkZWZhdWx0OntFT0w6XCJcXG5cIn19KTtjb25zdCBhPXQ9PntpZihcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7Y29uc3QgZT10Lm1hdGNoKC8oPzpcXHI/XFxuKS9nKXx8W107aWYoMD09PWUubGVuZ3RoKXJldHVybjtjb25zdCBzPWUuZmlsdGVyKHQ9PlwiXFxyXFxuXCI9PT10KS5sZW5ndGg7cmV0dXJuIHM+ZS5sZW5ndGgtcz9cIlxcclxcblwiOlwiXFxuXCJ9O3ZhciBuPWE7bi5ncmFjZWZ1bD10PT5cInN0cmluZ1wiPT10eXBlb2YgdCYmYSh0KXx8XCJcXG5cIjt2YXIgbyxoPShvPXIpJiZvLmRlZmF1bHR8fG8scD1pKChmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIHMoKXtjb25zdCB0PWg7cmV0dXJuIHM9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1mdW5jdGlvbiBpKCl7Y29uc3QgdD0oZT1uKSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX07dmFyIGU7cmV0dXJuIGk9ZnVuY3Rpb24oKXtyZXR1cm4gdH0sdH1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmV4dHJhY3Q9ZnVuY3Rpb24odCl7Y29uc3QgZT10Lm1hdGNoKG8pO3JldHVybiBlP2VbMF0udHJpbUxlZnQoKTpcIlwifSxlLnN0cmlwPWZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5tYXRjaChvKTtyZXR1cm4gZSYmZVswXT90LnN1YnN0cmluZyhlWzBdLmxlbmd0aCk6dH0sZS5wYXJzZT1mdW5jdGlvbih0KXtyZXR1cm4gbSh0KS5wcmFnbWFzfSxlLnBhcnNlV2l0aENvbW1lbnRzPW0sZS5wcmludD1mdW5jdGlvbih7Y29tbWVudHM6dD1cIlwiLHByYWdtYXM6ZT17fX0pe2NvbnN0IHI9KDAsaSgpLmRlZmF1bHQpKHQpfHxzKCkuRU9MLGE9T2JqZWN0LmtleXMoZSksbj1hLm1hcCh0PT5mKHQsZVt0XSkpLnJlZHVjZSgodCxlKT0+dC5jb25jYXQoZSksW10pLm1hcCh0PT5cIiAqIFwiK3Qrcikuam9pbihcIlwiKTtpZighdCl7aWYoMD09PWEubGVuZ3RoKXJldHVyblwiXCI7aWYoMT09PWEubGVuZ3RoJiYhQXJyYXkuaXNBcnJheShlW2FbMF1dKSl7Y29uc3QgdD1lW2FbMF1dO3JldHVyblwiXCIuY29uY2F0KFwiLyoqXCIsXCIgXCIpLmNvbmNhdChmKGFbMF0sdClbMF0pLmNvbmNhdChcIiAqL1wiKX19Y29uc3Qgbz10LnNwbGl0KHIpLm1hcCh0PT5cIlwiLmNvbmNhdChcIiAqXCIsXCIgXCIpLmNvbmNhdCh0KSkuam9pbihyKStyO3JldHVyblwiLyoqXCIrcisodD9vOlwiXCIpKyh0JiZhLmxlbmd0aD9cIiAqXCIrcjpcIlwiKStuK1wiICovXCJ9O2NvbnN0IHI9L1xcKlxcLyQvLGE9L15cXC9cXCpcXCovLG89L15cXHMqKFxcL1xcKlxcKj8oLnxcXHI/XFxuKSo/XFwqXFwvKS8scD0vKF58XFxzKylcXC9cXC8oW15cXHJcXG5dKikvZyxjPS9eKFxccj9cXG4pKy8sdT0vKD86XnxcXHI/XFxuKSAqKEBbXlxcclxcbl0qPykgKlxccj9cXG4gKig/IVteQFxcclxcbl0qXFwvXFwvW15dKikoW15AXFxyXFxuXFxzXVteQFxcclxcbl0rPykgKlxccj9cXG4vZyxsPS8oPzpefFxccj9cXG4pICpAKFxcUyspICooW15cXHJcXG5dKikvZyxkPS8oXFxyP1xcbnxeKSAqXFwqID8vZztmdW5jdGlvbiBtKHQpe2NvbnN0IGU9KDAsaSgpLmRlZmF1bHQpKHQpfHxzKCkuRU9MO3Q9dC5yZXBsYWNlKGEsXCJcIikucmVwbGFjZShyLFwiXCIpLnJlcGxhY2UoZCxcIiQxXCIpO2xldCBuPVwiXCI7Zm9yKDtuIT09dDspbj10LHQ9dC5yZXBsYWNlKHUsXCJcIi5jb25jYXQoZSxcIiQxICQyXCIpLmNvbmNhdChlKSk7dD10LnJlcGxhY2UoYyxcIlwiKS50cmltUmlnaHQoKTtjb25zdCBvPU9iamVjdC5jcmVhdGUobnVsbCksaD10LnJlcGxhY2UobCxcIlwiKS5yZXBsYWNlKGMsXCJcIikudHJpbVJpZ2h0KCk7bGV0IG07Zm9yKDttPWwuZXhlYyh0KTspe2NvbnN0IHQ9bVsyXS5yZXBsYWNlKHAsXCJcIik7XCJzdHJpbmdcIj09dHlwZW9mIG9bbVsxXV18fEFycmF5LmlzQXJyYXkob1ttWzFdXSk/b1ttWzFdXT1bXS5jb25jYXQob1ttWzFdXSx0KTpvW21bMV1dPXR9cmV0dXJue2NvbW1lbnRzOmgscHJhZ21hczpvfX1mdW5jdGlvbiBmKHQsZSl7cmV0dXJuW10uY29uY2F0KGUpLm1hcChlPT5cIkBcIi5jb25jYXQodCxcIiBcIikuY29uY2F0KGUpLnRyaW0oKSl9fSkpO3MocCk7cC5leHRyYWN0LHAuc3RyaXAscC5wYXJzZSxwLnBhcnNlV2l0aENvbW1lbnRzLHAucHJpbnQ7dmFyIGM9e2hhc1ByYWdtYTpmdW5jdGlvbih0KXtjb25zdCBlPU9iamVjdC5rZXlzKHAucGFyc2UocC5leHRyYWN0KHQpKSk7cmV0dXJuIGUuaW5jbHVkZXMoXCJwcmV0dGllclwiKXx8ZS5pbmNsdWRlcyhcImZvcm1hdFwiKX0saW5zZXJ0UHJhZ21hOmZ1bmN0aW9uKHQpe2NvbnN0IGU9cC5wYXJzZVdpdGhDb21tZW50cyhwLmV4dHJhY3QodCkpLHM9T2JqZWN0LmFzc2lnbih7Zm9ybWF0OlwiXCJ9LGUucHJhZ21hcyksaT1wLnByaW50KHtwcmFnbWFzOnMsY29tbWVudHM6ZS5jb21tZW50cy5yZXBsYWNlKC9eKFxccys/XFxyP1xcbikrLyxcIlwiKX0pLnJlcGxhY2UoLyhcXHJcXG58XFxyKS9nLFwiXFxuXCIpLHI9cC5zdHJpcCh0KTtyZXR1cm4gaSsoci5zdGFydHNXaXRoKFwiXFxuXCIpP1wiXFxuXCI6XCJcXG5cXG5cIikrcn19LHU9dD0+dFt0Lmxlbmd0aC0xXTtmdW5jdGlvbiBsKHQsZSl7cmV0dXJuIShlPWV8fHt9KS5pZ25vcmVEZWNvcmF0b3JzJiZ0LmRlY2xhcmF0aW9uJiZ0LmRlY2xhcmF0aW9uLmRlY29yYXRvcnMmJnQuZGVjbGFyYXRpb24uZGVjb3JhdG9ycy5sZW5ndGg+MD9sKHQuZGVjbGFyYXRpb24uZGVjb3JhdG9yc1swXSk6IWUuaWdub3JlRGVjb3JhdG9ycyYmdC5kZWNvcmF0b3JzJiZ0LmRlY29yYXRvcnMubGVuZ3RoPjA/bCh0LmRlY29yYXRvcnNbMF0pOnQuX19sb2NhdGlvbj90Ll9fbG9jYXRpb24uc3RhcnRPZmZzZXQ6dC5yYW5nZT90LnJhbmdlWzBdOlwibnVtYmVyXCI9PXR5cGVvZiB0LnN0YXJ0P3Quc3RhcnQ6dC5sb2M/dC5sb2Muc3RhcnQ6bnVsbH1mdW5jdGlvbiBkKHQpe2NvbnN0IGU9dC5ub2RlcyYmdSh0Lm5vZGVzKTtpZihlJiZ0LnNvdXJjZSYmIXQuc291cmNlLmVuZCYmKHQ9ZSksdC5fX2xvY2F0aW9uKXJldHVybiB0Ll9fbG9jYXRpb24uZW5kT2Zmc2V0O2NvbnN0IHM9dC5yYW5nZT90LnJhbmdlWzFdOlwibnVtYmVyXCI9PXR5cGVvZiB0LmVuZD90LmVuZDpudWxsO3JldHVybiB0LnR5cGVBbm5vdGF0aW9uP01hdGgubWF4KHMsZCh0LnR5cGVBbm5vdGF0aW9uKSk6dC5sb2MmJiFzP3QubG9jLmVuZDpzfXZhciBtPXtsb2NTdGFydDpsLGxvY0VuZDpkLGNvbXBvc2VMb2M6ZnVuY3Rpb24odCxlPXQpe2NvbnN0IHM9XCJudW1iZXJcIj09dHlwZW9mIGU/ZTotMSxpPWwodCkscj0tMSE9PXM/aStzOmQoZSksYT10LmxvYy5zdGFydDtyZXR1cm57c3RhcnQ6aSxlbmQ6cixyYW5nZTpbaSxyXSxsb2M6e3N0YXJ0OmEsZW5kOi0xIT09cz97bGluZTphLmxpbmUsY29sdW1uOmEuY29sdW1uK3N9OmUubG9jLmVuZH19fX0sZj10PT5cInN0cmluZ1wiPT10eXBlb2YgdD90LnJlcGxhY2UoKCh7b25seUZpcnN0OnQ9ITF9PXt9KT0+e2NvbnN0IGU9W1wiW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/OlthLXpBLVpcXFxcZF0qKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpXCIsXCIoPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW50cXJ5PT48fl0pKVwiXS5qb2luKFwifFwiKTtyZXR1cm4gbmV3IFJlZ0V4cChlLHQ/dm9pZCAwOlwiZ1wiKX0pKCksXCJcIik6dDtjb25zdCBEPXQ9PiFOdW1iZXIuaXNOYU4odCkmJih0Pj00MzUyJiYodDw9NDQ0N3x8OTAwMT09PXR8fDkwMDI9PT10fHwxMTkwNDw9dCYmdDw9MTI4NzEmJjEyMzUxIT09dHx8MTI4ODA8PXQmJnQ8PTE5OTAzfHwxOTk2ODw9dCYmdDw9NDIxODJ8fDQzMzYwPD10JiZ0PD00MzM4OHx8NDQwMzI8PXQmJnQ8PTU1MjAzfHw2Mzc0NDw9dCYmdDw9NjQyNTV8fDY1MDQwPD10JiZ0PD02NTA0OXx8NjUwNzI8PXQmJnQ8PTY1MTMxfHw2NTI4MTw9dCYmdDw9NjUzNzZ8fDY1NTA0PD10JiZ0PD02NTUxMHx8MTEwNTkyPD10JiZ0PD0xMTA1OTN8fDEyNzQ4ODw9dCYmdDw9MTI3NTY5fHwxMzEwNzI8PXQmJnQ8PTI2MjE0MSkpO3ZhciB5PUQseD1EO3kuZGVmYXVsdD14O2NvbnN0IGc9dD0+e2lmKFwic3RyaW5nXCIhPXR5cGVvZih0PXQucmVwbGFjZSgvXFx1RDgzQ1xcdURGRjRcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyKD86XFx1REI0MFxcdURDNjVcXHVEQjQwXFx1REM2RVxcdURCNDBcXHVEQzY3fFxcdURCNDBcXHVEQzczXFx1REI0MFxcdURDNjNcXHVEQjQwXFx1REM3NHxcXHVEQjQwXFx1REM3N1xcdURCNDBcXHVEQzZDXFx1REI0MFxcdURDNzMpXFx1REI0MFxcdURDN0Z8XFx1RDgzRFxcdURDNjgoPzpcXHVEODNDXFx1REZGQ1xcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OFxcdUQ4M0NcXHVERkZCfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRlxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZFXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkRcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkJcXHVERkZDXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY4fCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQoPzpcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSkpfFxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXwoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRnxcXHVEODNEW1xcdURDNjZcXHVEQzY3XXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8KD86XFx1RDgzQ1xcdURGRkJcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkZcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkVcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkRcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkNcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pXFx1RkUwRnxcXHVEODNDXFx1REZGQlxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZCXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkNcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjkpXFx1RDgzQ1xcdURGRkJ8XFx1RDgzRVxcdURERDEoPzpcXHVEODNDXFx1REZGRlxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZFXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkZcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGQ1xcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZEXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY5KSg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkNdKXxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NcXHVERkZFXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZDXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZCXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkRcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZGXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZEXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkVcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjkpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRdKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8KD86XFx1RDgzRFxcdURDNDFcXHVGRTBGXFx1MjAwRFxcdUQ4M0RcXHVEREU4fFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1xcdURGRkZcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkVcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkNcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkJcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkRcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKXwoPzooPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KVxcdUZFMEZ8XFx1RDgzRFxcdURDNkZ8XFx1RDgzRVtcXHVERDNDXFx1RERERVxcdUREREZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDYtXFx1RERERF0pKD86KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfFxcdTIwMERbXFx1MjY0MFxcdTI2NDJdKXxcXHVEODNDXFx1REZGNFxcdTIwMERcXHUyNjIwKVxcdUZFMEZ8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0NcXHVERkYzXFx1RkUwRlxcdTIwMERcXHVEODNDXFx1REYwOHxcXHVEODNEXFx1REMxNVxcdTIwMERcXHVEODNFXFx1RERCQXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2N3xcXHVEODNDXFx1RERGRFxcdUQ4M0NcXHVEREYwfFxcdUQ4M0NcXHVEREY0XFx1RDgzQ1xcdURERjJ8XFx1RDgzQ1xcdURERjZcXHVEODNDXFx1RERFNnxbI1xcKjAtOV1cXHVGRTBGXFx1MjBFM3xcXHVEODNDXFx1RERFNyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUZcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERjkoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRFxcdURERUYtXFx1RERGNFxcdURERjdcXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZGXSl8XFx1RDgzQ1xcdURERUEoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVEXFx1RERGNy1cXHVEREZBXSl8XFx1RDgzRVxcdURERDEoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0NcXHVEREY3KD86XFx1RDgzQ1tcXHVEREVBXFx1RERGNFxcdURERjhcXHVEREZBXFx1RERGQ10pfFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNDXFx1RERGMig/OlxcdUQ4M0NbXFx1RERFNlxcdURERTgtXFx1RERFRFxcdURERjAtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREU2KD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjJcXHVEREY0XFx1RERGNi1cXHVEREZBXFx1RERGQ1xcdURERkRcXHVEREZGXSl8XFx1RDgzQ1xcdURERjAoPzpcXHVEODNDW1xcdURERUFcXHVEREVDLVxcdURERUVcXHVEREYyXFx1RERGM1xcdURERjVcXHVEREY3XFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERUQoPzpcXHVEODNDW1xcdURERjBcXHVEREYyXFx1RERGM1xcdURERjdcXHVEREY5XFx1RERGQV0pfFxcdUQ4M0NcXHVEREU5KD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQ1xcdURERUZcXHVEREYwXFx1RERGMlxcdURERjRcXHVEREZGXSl8XFx1RDgzQ1xcdURERkUoPzpcXHVEODNDW1xcdURERUFcXHVEREY5XSl8XFx1RDgzQ1xcdURERUMoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVFXFx1RERGMS1cXHVEREYzXFx1RERGNS1cXHVEREZBXFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERGOCg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREVBXFx1RERFQy1cXHVEREY0XFx1RERGNy1cXHVEREY5XFx1RERGQlxcdURERkQtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVCKD86XFx1RDgzQ1tcXHVEREVFLVxcdURERjBcXHVEREYyXFx1RERGNFxcdURERjddKXxcXHVEODNDXFx1RERGNSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUEtXFx1RERFRFxcdURERjAtXFx1RERGM1xcdURERjctXFx1RERGOVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERkIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVFXFx1RERGM1xcdURERkFdKXxcXHVEODNDXFx1RERGMyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBLVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjRcXHVEREY1XFx1RERGN1xcdURERkFcXHVEREZGXSl8XFx1RDgzQ1xcdURERTgoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRVxcdURERjAtXFx1RERGNVxcdURERjdcXHVEREZBLVxcdURERkZdKXxcXHVEODNDXFx1RERGMSg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREU4XFx1RERFRVxcdURERjBcXHVEREY3LVxcdURERkJcXHVEREZFXSl8XFx1RDgzQ1xcdURERkYoPzpcXHVEODNDW1xcdURERTZcXHVEREYyXFx1RERGQ10pfFxcdUQ4M0NcXHVEREZDKD86XFx1RDgzQ1tcXHVEREVCXFx1RERGOF0pfFxcdUQ4M0NcXHVEREZBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQ1xcdURERjJcXHVEREYzXFx1RERGOFxcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERUUoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQVxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOV0pfFxcdUQ4M0NcXHVEREVGKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGMlxcdURERjRcXHVEREY1XSl8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjYxRFxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMlxcdURGQzddfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNkItXFx1REM2RFxcdURDNzBcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDQUFcXHVERDc0XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQwRlxcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQzMC1cXHVERDM2XFx1RERCNVxcdUREQjZcXHVEREJCXFx1REREMi1cXHVEREQ1XSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyMzFBXFx1MjMxQlxcdTIzRTktXFx1MjNFQ1xcdTIzRjBcXHUyM0YzXFx1MjVGRFxcdTI1RkVcXHUyNjE0XFx1MjYxNVxcdTI2NDgtXFx1MjY1M1xcdTI2N0ZcXHUyNjkzXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2Q0VcXHUyNkQ0XFx1MjZFQVxcdTI2RjJcXHUyNkYzXFx1MjZGNVxcdTI2RkFcXHUyNkZEXFx1MjcwNVxcdTI3MEFcXHUyNzBCXFx1MjcyOFxcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QjBcXHUyN0JGXFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFMzZcXHVERTM4LVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMFxcdURGMkQtXFx1REYzNVxcdURGMzctXFx1REY3Q1xcdURGN0UtXFx1REY5M1xcdURGQTAtXFx1REZDQVxcdURGQ0YtXFx1REZEM1xcdURGRTAtXFx1REZGMFxcdURGRjRcXHVERkY4LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQzNFXFx1REM0MFxcdURDNDItXFx1RENGQ1xcdURDRkYtXFx1REQzRFxcdURENEItXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdUREN0FcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREZCLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNDXFx1REVEMC1cXHVERUQyXFx1REVENVxcdURFRUJcXHVERUVDXFx1REVGNC1cXHVERUZBXFx1REZFMC1cXHVERkVCXXxcXHVEODNFW1xcdUREMEQtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REQ3MVxcdURENzMtXFx1REQ3NlxcdUREN0EtXFx1RERBMlxcdUREQTUtXFx1RERBQVxcdUREQUUtXFx1RERDQVxcdUREQ0QtXFx1RERGRlxcdURFNzAtXFx1REU3M1xcdURFNzgtXFx1REU3QVxcdURFODAtXFx1REU4MlxcdURFOTAtXFx1REU5NV0pfCg/OlsjXFwqMC05XFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNFxcdTI2MEVcXHUyNjExXFx1MjYxNFxcdTI2MTVcXHUyNjE4XFx1MjYxRFxcdTI2MjBcXHUyNjIyXFx1MjYyM1xcdTI2MjZcXHUyNjJBXFx1MjYyRVxcdTI2MkZcXHUyNjM4LVxcdTI2M0FcXHUyNjQwXFx1MjY0MlxcdTI2NDgtXFx1MjY1M1xcdTI2NUZcXHUyNjYwXFx1MjY2M1xcdTI2NjVcXHUyNjY2XFx1MjY2OFxcdTI2N0JcXHUyNjdFXFx1MjY3RlxcdTI2OTItXFx1MjY5N1xcdTI2OTlcXHUyNjlCXFx1MjY5Q1xcdTI2QTBcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkIwXFx1MjZCMVxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkM4XFx1MjZDRVxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RDRcXHUyNkU5XFx1MjZFQVxcdTI2RjAtXFx1MjZGNVxcdTI2RjctXFx1MjZGQVxcdTI2RkRcXHUyNzAyXFx1MjcwNVxcdTI3MDgtXFx1MjcwRFxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2M1xcdTI3NjRcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ3MFxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUwMlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjFcXHVERjI0LVxcdURGOTNcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUUtXFx1REZGMFxcdURGRjMtXFx1REZGNVxcdURGRjctXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDRkRcXHVEQ0ZGLVxcdUREM0RcXHVERDQ5LVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDZGXFx1REQ3MFxcdURENzMtXFx1REQ3QVxcdUREODdcXHVERDhBLVxcdUREOERcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERBNVxcdUREQThcXHVEREIxXFx1RERCMlxcdUREQkNcXHVEREMyLVxcdUREQzRcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREVcXHVEREUxXFx1RERFM1xcdURERThcXHVEREVGXFx1RERGM1xcdURERkEtXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0ItXFx1REVEMlxcdURFRDVcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVFQlxcdURFRUNcXHVERUYwXFx1REVGMy1cXHVERUZBXFx1REZFMC1cXHVERkVCXXxcXHVEODNFW1xcdUREMEQtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REQ3MVxcdURENzMtXFx1REQ3NlxcdUREN0EtXFx1RERBMlxcdUREQTUtXFx1RERBQVxcdUREQUUtXFx1RERDQVxcdUREQ0QtXFx1RERGRlxcdURFNzAtXFx1REU3M1xcdURFNzgtXFx1REU3QVxcdURFODAtXFx1REU4MlxcdURFOTAtXFx1REU5NV0pXFx1RkUwRnwoPzpbXFx1MjYxRFxcdTI2RjlcXHUyNzBBLVxcdTI3MERdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzItXFx1REZDNFxcdURGQzdcXHVERkNBLVxcdURGQ0NdfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2LVxcdURDNzhcXHVEQzdDXFx1REM4MS1cXHVEQzgzXFx1REM4NS1cXHVEQzg3XFx1REM4RlxcdURDOTFcXHVEQ0FBXFx1REQ3NFxcdURENzVcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0NS1cXHVERTQ3XFx1REU0Qi1cXHVERTRGXFx1REVBM1xcdURFQjQtXFx1REVCNlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMEZcXHVERDE4LVxcdUREMUZcXHVERDI2XFx1REQzMC1cXHVERDM5XFx1REQzQy1cXHVERDNFXFx1RERCNVxcdUREQjZcXHVEREI4XFx1RERCOVxcdUREQkJcXHVERENELVxcdUREQ0ZcXHVEREQxLVxcdURERERdKS9nLFwiICBcIikpfHwwPT09dC5sZW5ndGgpcmV0dXJuIDA7dD1mKHQpO2xldCBlPTA7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2NvbnN0IGk9dC5jb2RlUG9pbnRBdChzKTtpPD0zMXx8aT49MTI3JiZpPD0xNTl8fChpPj03NjgmJmk8PTg3OXx8KGk+NjU1MzUmJnMrKyxlKz15KGkpPzI6MSkpfXJldHVybiBlfTt2YXIgUD1nLEU9ZztQLmRlZmF1bHQ9RTtjb25zdCBDPS9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2c7dmFyIGI9dD0+e2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtyZXR1cm4gdC5yZXBsYWNlKEMsXCJcXFxcJCZcIil9O2NvbnN0IFQ9L1teXFx4MjAtXFx4N0ZdLztmdW5jdGlvbiBBKHQpe3JldHVybihlLHMsaSk9Pntjb25zdCByPWkmJmkuYmFja3dhcmRzO2lmKCExPT09cylyZXR1cm4hMTtjb25zdHtsZW5ndGg6YX09ZTtsZXQgbj1zO2Zvcig7bj49MCYmbjxhOyl7Y29uc3Qgcz1lLmNoYXJBdChuKTtpZih0IGluc3RhbmNlb2YgUmVnRXhwKXtpZighdC50ZXN0KHMpKXJldHVybiBufWVsc2UgaWYoIXQuaW5jbHVkZXMocykpcmV0dXJuIG47cj9uLS06bisrfXJldHVybigtMT09PW58fG49PT1hKSYmbn19Y29uc3Qgdz1BKC9cXHMvKSxTPUEoXCIgXFx0XCIpLE49QShcIiw7IFxcdFwiKSxGPUEoL1teXFxyXFxuXS8pO2Z1bmN0aW9uIGsodCxlKXtpZighMT09PWUpcmV0dXJuITE7aWYoXCIvXCI9PT10LmNoYXJBdChlKSYmXCIqXCI9PT10LmNoYXJBdChlKzEpKWZvcihsZXQgcz1lKzI7czx0Lmxlbmd0aDsrK3MpaWYoXCIqXCI9PT10LmNoYXJBdChzKSYmXCIvXCI9PT10LmNoYXJBdChzKzEpKXJldHVybiBzKzI7cmV0dXJuIGV9ZnVuY3Rpb24gSSh0LGUpe3JldHVybiExIT09ZSYmKFwiL1wiPT09dC5jaGFyQXQoZSkmJlwiL1wiPT09dC5jaGFyQXQoZSsxKT9GKHQsZSk6ZSl9ZnVuY3Rpb24gdih0LGUscyl7Y29uc3QgaT1zJiZzLmJhY2t3YXJkcztpZighMT09PWUpcmV0dXJuITE7Y29uc3Qgcj10LmNoYXJBdChlKTtpZihpKXtpZihcIlxcclwiPT09dC5jaGFyQXQoZS0xKSYmXCJcXG5cIj09PXIpcmV0dXJuIGUtMjtpZihcIlxcblwiPT09cnx8XCJcXHJcIj09PXJ8fFwiXFx1MjAyOFwiPT09cnx8XCJcXHUyMDI5XCI9PT1yKXJldHVybiBlLTF9ZWxzZXtpZihcIlxcclwiPT09ciYmXCJcXG5cIj09PXQuY2hhckF0KGUrMSkpcmV0dXJuIGUrMjtpZihcIlxcblwiPT09cnx8XCJcXHJcIj09PXJ8fFwiXFx1MjAyOFwiPT09cnx8XCJcXHUyMDI5XCI9PT1yKXJldHVybiBlKzF9cmV0dXJuIGV9ZnVuY3Rpb24gTCh0LGUscyl7Y29uc3QgaT1TKHQsKHM9c3x8e30pLmJhY2t3YXJkcz9lLTE6ZSxzKTtyZXR1cm4gaSE9PXYodCxpLHMpfWZ1bmN0aW9uIEIodCxlKXtsZXQgcz1udWxsLGk9ZTtmb3IoO2khPT1zOylzPWksaT1OKHQsaSksaT1rKHQsaSksaT1TKHQsaSk7cmV0dXJuIGk9SSh0LGkpLGk9dih0LGkpLCExIT09aSYmTCh0LGkpfWZ1bmN0aW9uIE0odCxlKXtsZXQgcz1udWxsLGk9ZTtmb3IoO2khPT1zOylzPWksaT1TKHQsaSksaT1rKHQsaSksaT1JKHQsaSksaT12KHQsaSk7cmV0dXJuIGl9ZnVuY3Rpb24gTyh0LGUscyl7cmV0dXJuIE0odCxzKGUpKX1jb25zdCBSPXt9O2Z1bmN0aW9uIF8odCl7cmV0dXJuIFJbdF19W1tcInw+XCJdLFtcIj8/XCJdLFtcInx8XCJdLFtcIiYmXCJdLFtcInxcIl0sW1wiXlwiXSxbXCImXCJdLFtcIj09XCIsXCI9PT1cIixcIiE9XCIsXCIhPT1cIl0sW1wiPFwiLFwiPlwiLFwiPD1cIixcIj49XCIsXCJpblwiLFwiaW5zdGFuY2VvZlwiXSxbXCI+PlwiLFwiPDxcIixcIj4+PlwiXSxbXCIrXCIsXCItXCJdLFtcIipcIixcIi9cIixcIiVcIl0sW1wiKipcIl1dLmZvckVhY2goKHQsZSk9Pnt0LmZvckVhY2godD0+e1JbdF09ZX0pfSk7Y29uc3Qgaj17XCI9PVwiOiEwLFwiIT1cIjohMCxcIj09PVwiOiEwLFwiIT09XCI6ITB9LFU9e1wiKlwiOiEwLFwiL1wiOiEwLFwiJVwiOiEwfSxxPXtcIj4+XCI6ITAsXCI+Pj5cIjohMCxcIjw8XCI6ITB9O2Z1bmN0aW9uIFYodCxlLHMpe2xldCBpPTA7Zm9yKGxldCByPXM9c3x8MDtyPHQubGVuZ3RoOysrcilcIlxcdFwiPT09dFtyXT9pPWkrZS1pJWU6aSsrO3JldHVybiBpfWZ1bmN0aW9uIHoodCxlKXtjb25zdCBzPXQuc2xpY2UoMSwtMSksaT17cXVvdGU6J1wiJyxyZWdleDovXCIvZ30scj17cXVvdGU6XCInXCIscmVnZXg6LycvZ30sYT1cIidcIj09PWU/cjppLG49YT09PXI/aTpyO2xldCBvPWEucXVvdGU7aWYocy5pbmNsdWRlcyhhLnF1b3RlKXx8cy5pbmNsdWRlcyhuLnF1b3RlKSl7bz0ocy5tYXRjaChhLnJlZ2V4KXx8W10pLmxlbmd0aD4ocy5tYXRjaChuLnJlZ2V4KXx8W10pLmxlbmd0aD9uLnF1b3RlOmEucXVvdGV9cmV0dXJuIG99ZnVuY3Rpb24gSCh0LGUscyl7Y29uc3QgaT0nXCInPT09ZT9cIidcIjonXCInLHI9dC5yZXBsYWNlKC9cXFxcKFtcXHNcXFNdKXwoWydcIl0pL2csKHQscixhKT0+cj09PWk/cjphPT09ZT9cIlxcXFxcIithOmF8fChzJiYvXlteXFxcXG5ydnRiZnV4XFxyXFxuXFx1MjAyOFxcdTIwMjlcIicwLTddJC8udGVzdChyKT9yOlwiXFxcXFwiK3IpKTtyZXR1cm4gZStyK2V9ZnVuY3Rpb24gVyh0KXtyZXR1cm4gdCYmKHQuY29tbWVudHMmJnQuY29tbWVudHMubGVuZ3RoPjAmJnQuY29tbWVudHMuc29tZSh0PT5LKHQpJiYhdC51bmlnbm9yZSl8fHQucHJldHRpZXJJZ25vcmUpfWZ1bmN0aW9uIEsodCl7cmV0dXJuXCJwcmV0dGllci1pZ25vcmVcIj09PXQudmFsdWUudHJpbSgpfWZ1bmN0aW9uIEoodCxlKXsodC5jb21tZW50c3x8KHQuY29tbWVudHM9W10pKS5wdXNoKGUpLGUucHJpbnRlZD0hMSxcIkpTWFRleHRcIj09PXQudHlwZSYmKGUucHJpbnRlZD0hMCl9dmFyIFg9e3JlcGxhY2VFbmRPZkxpbmVXaXRoOmZ1bmN0aW9uKHQsZSl7Y29uc3Qgcz1bXTtmb3IoY29uc3QgaSBvZiB0LnNwbGl0KFwiXFxuXCIpKTAhPT1zLmxlbmd0aCYmcy5wdXNoKGUpLHMucHVzaChpKTtyZXR1cm4gc30sZ2V0U3RyaW5nV2lkdGg6ZnVuY3Rpb24odCl7cmV0dXJuIHQ/VC50ZXN0KHQpP1AodCk6dC5sZW5ndGg6MH0sZ2V0TWF4Q29udGludW91c0NvdW50OmZ1bmN0aW9uKHQsZSl7Y29uc3Qgcz10Lm1hdGNoKG5ldyBSZWdFeHAoXCIoXCIuY29uY2F0KGIoZSksXCIpK1wiKSxcImdcIikpO3JldHVybiBudWxsPT09cz8wOnMucmVkdWNlKCh0LHMpPT5NYXRoLm1heCh0LHMubGVuZ3RoL2UubGVuZ3RoKSwwKX0sZ2V0TWluTm90UHJlc2VudENvbnRpbnVvdXNDb3VudDpmdW5jdGlvbih0LGUpe2NvbnN0IHM9dC5tYXRjaChuZXcgUmVnRXhwKFwiKFwiLmNvbmNhdChiKGUpLFwiKStcIiksXCJnXCIpKTtpZihudWxsPT09cylyZXR1cm4gMDtjb25zdCBpPW5ldyBNYXA7bGV0IHI9MDtmb3IoY29uc3QgdCBvZiBzKXtjb25zdCBzPXQubGVuZ3RoL2UubGVuZ3RoO2kuc2V0KHMsITApLHM+ciYmKHI9cyl9Zm9yKGxldCB0PTE7dDxyO3QrKylpZighaS5nZXQodCkpcmV0dXJuIHQ7cmV0dXJuIHIrMX0sZ2V0UHJlY2VkZW5jZTpfLHNob3VsZEZsYXR0ZW46ZnVuY3Rpb24odCxlKXtyZXR1cm4gXyhlKT09PV8odCkmJihcIioqXCIhPT10JiYoKCFqW3RdfHwhaltlXSkmJighKFwiJVwiPT09ZSYmVVt0XXx8XCIlXCI9PT10JiZVW2VdKSYmKChlPT09dHx8IVVbZV18fCFVW3RdKSYmKCFxW3RdfHwhcVtlXSkpKSkpfSxpc0JpdHdpc2VPcGVyYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4hIXFbdF18fFwifFwiPT09dHx8XCJeXCI9PT10fHxcIiZcIj09PXR9LGdldFBlbnVsdGltYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlbmd0aD4xP3RbdC5sZW5ndGgtMl06bnVsbH0sZ2V0TGFzdDp1LGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4Ok0sZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4Ok8sZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlcjpmdW5jdGlvbih0LGUscyl7cmV0dXJuIHQuY2hhckF0KE8odCxlLHMpKX0sc2tpcDpBLHNraXBXaGl0ZXNwYWNlOncsc2tpcFNwYWNlczpTLHNraXBUb0xpbmVFbmQ6Tixza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6Rixza2lwSW5saW5lQ29tbWVudDprLHNraXBUcmFpbGluZ0NvbW1lbnQ6SSxza2lwTmV3bGluZTp2LGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXg6Qixpc05leHRMaW5lRW1wdHk6ZnVuY3Rpb24odCxlLHMpe3JldHVybiBCKHQscyhlKSl9LGlzUHJldmlvdXNMaW5lRW1wdHk6ZnVuY3Rpb24odCxlLHMpe2xldCBpPXMoZSktMTtyZXR1cm4gaT1TKHQsaSx7YmFja3dhcmRzOiEwfSksaT12KHQsaSx7YmFja3dhcmRzOiEwfSksaT1TKHQsaSx7YmFja3dhcmRzOiEwfSksaSE9PXYodCxpLHtiYWNrd2FyZHM6ITB9KX0saGFzTmV3bGluZTpMLGhhc05ld2xpbmVJblJhbmdlOmZ1bmN0aW9uKHQsZSxzKXtmb3IobGV0IGk9ZTtpPHM7KytpKWlmKFwiXFxuXCI9PT10LmNoYXJBdChpKSlyZXR1cm4hMDtyZXR1cm4hMX0saGFzU3BhY2VzOmZ1bmN0aW9uKHQsZSxzKXtyZXR1cm4gUyh0LChzPXN8fHt9KS5iYWNrd2FyZHM/ZS0xOmUscykhPT1lfSxzZXRMb2NTdGFydDpmdW5jdGlvbih0LGUpe3QucmFuZ2U/dC5yYW5nZVswXT1lOnQuc3RhcnQ9ZX0sc2V0TG9jRW5kOmZ1bmN0aW9uKHQsZSl7dC5yYW5nZT90LnJhbmdlWzFdPWU6dC5lbmQ9ZX0sc3RhcnRzV2l0aE5vTG9va2FoZWFkVG9rZW46ZnVuY3Rpb24gdChlLHMpe3N3aXRjaCgoZT1mdW5jdGlvbiB0KGUpe2lmKGUubGVmdClyZXR1cm4gdChlLmxlZnQpO3JldHVybiBlfShlKSkudHlwZSl7Y2FzZVwiRnVuY3Rpb25FeHByZXNzaW9uXCI6Y2FzZVwiQ2xhc3NFeHByZXNzaW9uXCI6Y2FzZVwiRG9FeHByZXNzaW9uXCI6cmV0dXJuIHM7Y2FzZVwiT2JqZWN0RXhwcmVzc2lvblwiOnJldHVybiEwO2Nhc2VcIk1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpyZXR1cm4gdChlLm9iamVjdCxzKTtjYXNlXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpyZXR1cm5cIkZ1bmN0aW9uRXhwcmVzc2lvblwiIT09ZS50YWcudHlwZSYmdChlLnRhZyxzKTtjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm5cIkZ1bmN0aW9uRXhwcmVzc2lvblwiIT09ZS5jYWxsZWUudHlwZSYmdChlLmNhbGxlZSxzKTtjYXNlXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpyZXR1cm4gdChlLnRlc3Qscyk7Y2FzZVwiVXBkYXRlRXhwcmVzc2lvblwiOnJldHVybiFlLnByZWZpeCYmdChlLmFyZ3VtZW50LHMpO2Nhc2VcIkJpbmRFeHByZXNzaW9uXCI6cmV0dXJuIGUub2JqZWN0JiZ0KGUub2JqZWN0LHMpO2Nhc2VcIlNlcXVlbmNlRXhwcmVzc2lvblwiOnJldHVybiB0KGUuZXhwcmVzc2lvbnNbMF0scyk7Y2FzZVwiVFNBc0V4cHJlc3Npb25cIjpyZXR1cm4gdChlLmV4cHJlc3Npb24scyk7ZGVmYXVsdDpyZXR1cm4hMX19LGdldEFsaWdubWVudFNpemU6VixnZXRJbmRlbnRTaXplOmZ1bmN0aW9uKHQsZSl7Y29uc3Qgcz10Lmxhc3RJbmRleE9mKFwiXFxuXCIpO3JldHVybi0xPT09cz8wOlYodC5zbGljZShzKzEpLm1hdGNoKC9eWyBcXHRdKi8pWzBdLGUpfSxnZXRQcmVmZXJyZWRRdW90ZTp6LHByaW50U3RyaW5nOmZ1bmN0aW9uKHQsZSxzKXtjb25zdCBpPXQuc2xpY2UoMSwtMSkscj0haS5pbmNsdWRlcygnXCInKSYmIWkuaW5jbHVkZXMoXCInXCIpLGE9XCJqc29uXCI9PT1lLnBhcnNlcj8nXCInOmUuX19pc0luSHRtbEF0dHJpYnV0ZT9cIidcIjp6KHQsZS5zaW5nbGVRdW90ZT9cIidcIjonXCInKTtyZXR1cm4gcz9yP2EraSthOnQ6SChpLGEsIShcImNzc1wiPT09ZS5wYXJzZXJ8fFwibGVzc1wiPT09ZS5wYXJzZXJ8fFwic2Nzc1wiPT09ZS5wYXJzZXJ8fGUuZW1iZWRkZWRJbkh0bWwpKX0scHJpbnROdW1iZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9eKFsrLV0/W1xcZC5dK2UpKD86XFwrfCgtKSk/MCooXFxkKS8sXCIkMSQyJDNcIikucmVwbGFjZSgvXihbKy1dP1tcXGQuXSspZVsrLV0/MCskLyxcIiQxXCIpLnJlcGxhY2UoL14oWystXSk/XFwuLyxcIiQxMC5cIikucmVwbGFjZSgvKFxcLlxcZCs/KTArKD89ZXwkKS8sXCIkMVwiKS5yZXBsYWNlKC9cXC4oPz1lfCQpLyxcIlwiKX0saGFzSWdub3JlQ29tbWVudDpmdW5jdGlvbih0KXtyZXR1cm4gVyh0LmdldFZhbHVlKCkpfSxoYXNOb2RlSWdub3JlQ29tbWVudDpXLGlzTm9kZUlnbm9yZUNvbW1lbnQ6SyxtYWtlU3RyaW5nOkgsYWRkTGVhZGluZ0NvbW1lbnQ6ZnVuY3Rpb24odCxlKXtlLmxlYWRpbmc9ITAsZS50cmFpbGluZz0hMSxKKHQsZSl9LGFkZERhbmdsaW5nQ29tbWVudDpmdW5jdGlvbih0LGUpe2UubGVhZGluZz0hMSxlLnRyYWlsaW5nPSExLEoodCxlKX0sYWRkVHJhaWxpbmdDb21tZW50OmZ1bmN0aW9uKHQsZSl7ZS5sZWFkaW5nPSExLGUudHJhaWxpbmc9ITAsSih0LGUpfSxpc1dpdGhpblBhcmVudEFycmF5UHJvcGVydHk6ZnVuY3Rpb24odCxlKXtjb25zdCBzPXQuZ2V0VmFsdWUoKSxpPXQuZ2V0UGFyZW50Tm9kZSgpO2lmKG51bGw9PWkpcmV0dXJuITE7aWYoIUFycmF5LmlzQXJyYXkoaVtlXSkpcmV0dXJuITE7Y29uc3Qgcj10LmdldE5hbWUoKTtyZXR1cm4gaVtlXVtyXT09PXN9fTtjb25zdHtnZXRNYXhDb250aW51b3VzQ291bnQ6RyxnZXRTdHJpbmdXaWR0aDpRLGdldEFsaWdubWVudFNpemU6WSxnZXRJbmRlbnRTaXplOiQsc2tpcDpaLHNraXBXaGl0ZXNwYWNlOnR0LHNraXBTcGFjZXM6ZXQsc2tpcE5ld2xpbmU6c3Qsc2tpcFRvTGluZUVuZDppdCxza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6cnQsc2tpcElubGluZUNvbW1lbnQ6YXQsc2tpcFRyYWlsaW5nQ29tbWVudDpudCxoYXNOZXdsaW5lOm90LGhhc05ld2xpbmVJblJhbmdlOmh0LGhhc1NwYWNlczpwdCxpc05leHRMaW5lRW1wdHk6Y3QsaXNOZXh0TGluZUVtcHR5QWZ0ZXJJbmRleDp1dCxpc1ByZXZpb3VzTGluZUVtcHR5Omx0LGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleDpkdCxtYWtlU3RyaW5nOm10LGFkZExlYWRpbmdDb21tZW50OmZ0LGFkZERhbmdsaW5nQ29tbWVudDpEdCxhZGRUcmFpbGluZ0NvbW1lbnQ6eXR9PVg7dmFyIHh0PXtnZXRNYXhDb250aW51b3VzQ291bnQ6RyxnZXRTdHJpbmdXaWR0aDpRLGdldEFsaWdubWVudFNpemU6WSxnZXRJbmRlbnRTaXplOiQsc2tpcDpaLHNraXBXaGl0ZXNwYWNlOnR0LHNraXBTcGFjZXM6ZXQsc2tpcE5ld2xpbmU6c3Qsc2tpcFRvTGluZUVuZDppdCxza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6cnQsc2tpcElubGluZUNvbW1lbnQ6YXQsc2tpcFRyYWlsaW5nQ29tbWVudDpudCxoYXNOZXdsaW5lOm90LGhhc05ld2xpbmVJblJhbmdlOmh0LGhhc1NwYWNlczpwdCxpc05leHRMaW5lRW1wdHk6Y3QsaXNOZXh0TGluZUVtcHR5QWZ0ZXJJbmRleDp1dCxpc1ByZXZpb3VzTGluZUVtcHR5Omx0LGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleDpkdCxtYWtlU3RyaW5nOm10LGFkZExlYWRpbmdDb21tZW50OmZ0LGFkZERhbmdsaW5nQ29tbWVudDpEdCxhZGRUcmFpbGluZ0NvbW1lbnQ6eXR9O2NvbnN0e2FkZExlYWRpbmdDb21tZW50Omd0LGFkZFRyYWlsaW5nQ29tbWVudDpQdCxhZGREYW5nbGluZ0NvbW1lbnQ6RXQsZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4OkN0fT14dDtmdW5jdGlvbiBidCh0LGUpe2NvbnN0IHM9dC5ib2R5LmZpbHRlcih0PT5cIkVtcHR5U3RhdGVtZW50XCIhPT10LnR5cGUpOzA9PT1zLmxlbmd0aD9FdCh0LGUpOmd0KHNbMF0sZSl9ZnVuY3Rpb24gVHQodCxlKXtcIkJsb2NrU3RhdGVtZW50XCI9PT10LnR5cGU/YnQodCxlKTpndCh0LGUpfWZ1bmN0aW9uIEF0KHQsZSxzLGkscixhKXtpZighc3x8XCJJZlN0YXRlbWVudFwiIT09cy50eXBlfHwhaSlyZXR1cm4hMTtyZXR1cm5cIilcIj09PVguZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3Rlcih0LHIsYS5sb2NFbmQpPyhQdChlLHIpLCEwKTplPT09cy5jb25zZXF1ZW50JiZpPT09cy5hbHRlcm5hdGU/KFwiQmxvY2tTdGF0ZW1lbnRcIj09PWUudHlwZT9QdChlLHIpOkV0KHMsciksITApOlwiQmxvY2tTdGF0ZW1lbnRcIj09PWkudHlwZT8oYnQoaSxyKSwhMCk6XCJJZlN0YXRlbWVudFwiPT09aS50eXBlPyhUdChpLmNvbnNlcXVlbnQsciksITApOnMuY29uc2VxdWVudD09PWkmJihndChpLHIpLCEwKX1mdW5jdGlvbiB3dCh0LGUscyxpLHIsYSl7aWYoIXN8fFwiV2hpbGVTdGF0ZW1lbnRcIiE9PXMudHlwZXx8IWkpcmV0dXJuITE7cmV0dXJuXCIpXCI9PT1YLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIodCxyLGEubG9jRW5kKT8oUHQoZSxyKSwhMCk6XCJCbG9ja1N0YXRlbWVudFwiPT09aS50eXBlJiYoYnQoaSxyKSwhMCl9ZnVuY3Rpb24gU3QodCxlLHMsaSl7cmV0dXJuISghdHx8XCJUcnlTdGF0ZW1lbnRcIiE9PXQudHlwZSYmXCJDYXRjaENsYXVzZVwiIT09dC50eXBlfHwhcykmJihcIkNhdGNoQ2xhdXNlXCI9PT10LnR5cGUmJmU/KFB0KGUsaSksITApOlwiQmxvY2tTdGF0ZW1lbnRcIj09PXMudHlwZT8oYnQocyxpKSwhMCk6XCJUcnlTdGF0ZW1lbnRcIj09PXMudHlwZT8oVHQocy5maW5hbGl6ZXIsaSksITApOlwiQ2F0Y2hDbGF1c2VcIj09PXMudHlwZSYmKFR0KHMuYm9keSxpKSwhMCkpfWZ1bmN0aW9uIE50KHQsZSxzLGkpe3JldHVybiEoISh0JiYoXCJDbGFzc0RlY2xhcmF0aW9uXCI9PT10LnR5cGV8fFwiQ2xhc3NFeHByZXNzaW9uXCI9PT10LnR5cGUpJiZ0LmRlY29yYXRvcnMmJnQuZGVjb3JhdG9ycy5sZW5ndGg+MCl8fHMmJlwiRGVjb3JhdG9yXCI9PT1zLnR5cGUpJiYodC5kZWNvcmF0b3JzJiYwIT09dC5kZWNvcmF0b3JzLmxlbmd0aD9QdCh0LmRlY29yYXRvcnNbdC5kZWNvcmF0b3JzLmxlbmd0aC0xXSxpKTpndCh0LGkpLCEwKX1mdW5jdGlvbiBGdCh0LGUscyxpLHIpe3JldHVybiBlJiZzJiYoXCJQcm9wZXJ0eVwiPT09ZS50eXBlfHxcIlRTRGVjbGFyZU1ldGhvZFwiPT09ZS50eXBlfHxcIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCI9PT1lLnR5cGUpJiZcIklkZW50aWZpZXJcIj09PXMudHlwZSYmZS5rZXk9PT1zJiZcIjpcIiE9PVguZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3Rlcih0LHMsci5sb2NFbmQpPyhQdChzLGkpLCEwKTohKCFzfHwhZXx8XCJEZWNvcmF0b3JcIiE9PXMudHlwZXx8XCJDbGFzc01ldGhvZFwiIT09ZS50eXBlJiZcIkNsYXNzUHJvcGVydHlcIiE9PWUudHlwZSYmXCJUU0Fic3RyYWN0Q2xhc3NQcm9wZXJ0eVwiIT09ZS50eXBlJiZcIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCIhPT1lLnR5cGUmJlwiVFNEZWNsYXJlTWV0aG9kXCIhPT1lLnR5cGUmJlwiTWV0aG9kRGVmaW5pdGlvblwiIT09ZS50eXBlKSYmKFB0KHMsaSksITApfWZ1bmN0aW9uIGt0KHQsZSxzLGkscixhKXtpZihlJiZcIkZ1bmN0aW9uVHlwZVBhcmFtXCI9PT1lLnR5cGUmJnMmJlwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiPT09cy50eXBlJiZpJiZcIkZ1bmN0aW9uVHlwZVBhcmFtXCIhPT1pLnR5cGUpcmV0dXJuIFB0KGUsciksITA7aWYoZSYmKFwiSWRlbnRpZmllclwiPT09ZS50eXBlfHxcIkFzc2lnbm1lbnRQYXR0ZXJuXCI9PT1lLnR5cGUpJiZzJiZNdChzKSYmXCIpXCI9PT1YLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIodCxyLGEubG9jRW5kKSlyZXR1cm4gUHQoZSxyKSwhMDtpZihzJiZcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIj09PXMudHlwZSYmaSYmXCJCbG9ja1N0YXRlbWVudFwiPT09aS50eXBlKXtjb25zdCBlPSgoKT0+e2lmKDAhPT0ocy5wYXJhbXN8fHMucGFyYW1ldGVycykubGVuZ3RoKXJldHVybiBYLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4KHQsYS5sb2NFbmQoWC5nZXRMYXN0KHMucGFyYW1zfHxzLnBhcmFtZXRlcnMpKSk7Y29uc3QgZT1YLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4KHQsYS5sb2NFbmQocy5pZCkpO3JldHVybiBYLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4KHQsZSsxKX0pKCk7aWYoYS5sb2NTdGFydChyKT5lKXJldHVybiBidChpLHIpLCEwfXJldHVybiExfWZ1bmN0aW9uIEl0KHQsZSl7cmV0dXJuISghdHx8XCJJbXBvcnRTcGVjaWZpZXJcIiE9PXQudHlwZSkmJihndCh0LGUpLCEwKX1mdW5jdGlvbiB2dCh0LGUpe3JldHVybiEoIXR8fFwiTGFiZWxlZFN0YXRlbWVudFwiIT09dC50eXBlKSYmKGd0KHQsZSksITApfWZ1bmN0aW9uIEx0KHQsZSxzLGkpe3JldHVybiBlJiZlLmJvZHkmJjA9PT1lLmJvZHkubGVuZ3RoPyhpP0V0KGUscyk6Z3QoZSxzKSwhMCk6ISghdHx8XCJQcm9ncmFtXCIhPT10LnR5cGV8fDAhPT10LmJvZHkubGVuZ3RofHwhdC5kaXJlY3RpdmVzfHwwIT09dC5kaXJlY3RpdmVzLmxlbmd0aCkmJihpP0V0KHQscyk6Z3QodCxzKSwhMCl9ZnVuY3Rpb24gQnQodCl7cmV0dXJuXCJCbG9ja1wiPT09dC50eXBlfHxcIkNvbW1lbnRCbG9ja1wiPT09dC50eXBlfWZ1bmN0aW9uIE10KHQpe3JldHVyblwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIj09PXQudHlwZXx8XCJGdW5jdGlvbkV4cHJlc3Npb25cIj09PXQudHlwZXx8XCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI9PT10LnR5cGV8fFwiT2JqZWN0TWV0aG9kXCI9PT10LnR5cGV8fFwiQ2xhc3NNZXRob2RcIj09PXQudHlwZXx8XCJUU0RlY2xhcmVGdW5jdGlvblwiPT09dC50eXBlfHxcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCI9PT10LnR5cGV8fFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiPT09dC50eXBlfHxcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIj09PXQudHlwZXx8XCJUU01ldGhvZFNpZ25hdHVyZVwiPT09dC50eXBlfHxcIlRTQ29uc3RydWN0b3JUeXBlXCI9PT10LnR5cGV8fFwiVFNGdW5jdGlvblR5cGVcIj09PXQudHlwZXx8XCJUU0RlY2xhcmVNZXRob2RcIj09PXQudHlwZX1mdW5jdGlvbiBPdCh0KXtyZXR1cm4gQnQodCkmJlwiKlwiPT09dC52YWx1ZVswXSYmL0B0eXBlXFxiLy50ZXN0KHQudmFsdWUpfXZhciBSdD17aGFuZGxlT3duTGluZUNvbW1lbnQ6ZnVuY3Rpb24odCxlLHMsaSxyKXtjb25zdHtwcmVjZWRpbmdOb2RlOmEsZW5jbG9zaW5nTm9kZTpuLGZvbGxvd2luZ05vZGU6b309dDtyZXR1cm4ga3QoZSxhLG4sbyx0LHMpfHxmdW5jdGlvbih0LGUscyl7aWYodCYmKFwiTWVtYmVyRXhwcmVzc2lvblwiPT09dC50eXBlfHxcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiPT09dC50eXBlKSYmZSYmXCJJZGVudGlmaWVyXCI9PT1lLnR5cGUpcmV0dXJuIGd0KHQscyksITA7cmV0dXJuITF9KG4sbyx0KXx8QXQoZSxhLG4sbyx0LHMpfHx3dChlLGEsbixvLHQscyl8fFN0KG4sYSxvLHQpfHxOdChuLGEsbyx0KXx8SXQobix0KXx8ZnVuY3Rpb24odCxlLHMpe2lmKHQmJihcIkZvckluU3RhdGVtZW50XCI9PT10LnR5cGV8fFwiRm9yT2ZTdGF0ZW1lbnRcIj09PXQudHlwZSkpcmV0dXJuIGd0KHQscyksITA7cmV0dXJuITF9KG4sMCx0KXx8ZnVuY3Rpb24odCxlLHMsaSl7aWYoZSYmKFwiVW5pb25UeXBlQW5ub3RhdGlvblwiPT09ZS50eXBlfHxcIlRTVW5pb25UeXBlXCI9PT1lLnR5cGUpKXJldHVybiBYLmlzTm9kZUlnbm9yZUNvbW1lbnQoaSkmJihzLnByZXR0aWVySWdub3JlPSEwLGkudW5pZ25vcmU9ITApLCEhdCYmKFB0KHQsaSksITApO3MmJihcIlVuaW9uVHlwZUFubm90YXRpb25cIj09PXMudHlwZXx8XCJUU1VuaW9uVHlwZVwiPT09cy50eXBlKSYmWC5pc05vZGVJZ25vcmVDb21tZW50KGkpJiYocy50eXBlc1swXS5wcmV0dGllcklnbm9yZT0hMCxpLnVuaWdub3JlPSEwKTtyZXR1cm4hMX0oYSxuLG8sdCl8fEx0KG4saSx0LHIpfHxmdW5jdGlvbih0LGUscyxpLHIpe2lmKHMmJlwiSW1wb3J0U3BlY2lmaWVyXCI9PT1zLnR5cGUmJmUmJlwiSW1wb3J0RGVjbGFyYXRpb25cIj09PWUudHlwZSYmWC5oYXNOZXdsaW5lKHQsci5sb2NFbmQoaSkpKXJldHVybiBQdChzLGkpLCEwO3JldHVybiExfShlLG4sYSx0LHMpfHxmdW5jdGlvbih0LGUpe2lmKHQmJlwiQXNzaWdubWVudFBhdHRlcm5cIj09PXQudHlwZSlyZXR1cm4gZ3QodCxlKSwhMDtyZXR1cm4hMX0obix0KXx8RnQoZSxuLGEsdCxzKXx8dnQobix0KX0saGFuZGxlRW5kT2ZMaW5lQ29tbWVudDpmdW5jdGlvbih0LGUscyxpLHIpe2NvbnN0e3ByZWNlZGluZ05vZGU6YSxlbmNsb3NpbmdOb2RlOm4sZm9sbG93aW5nTm9kZTpvfT10O3JldHVybiBmdW5jdGlvbih0LGUpe2lmKHQmJk90KGUpKXJldHVybiBndCh0LGUpLCEwO3JldHVybiExfShvLHQpfHxrdChlLGEsbixvLHQscyl8fGZ1bmN0aW9uKHQsZSxzLGkscixhKXtjb25zdCBuPWUmJiFYLmhhc05ld2xpbmVJblJhbmdlKHIsYS5sb2NFbmQoZSksYS5sb2NTdGFydChpKSk7aWYoKCFlfHwhbikmJnQmJlwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI9PT10LnR5cGUmJnMpcmV0dXJuIGd0KHMsaSksITA7cmV0dXJuITF9KG4sYSxvLHQsZSxzKXx8SXQobix0KXx8QXQoZSxhLG4sbyx0LHMpfHx3dChlLGEsbixvLHQscyl8fFN0KG4sYSxvLHQpfHxOdChuLGEsbyx0KXx8dnQobix0KXx8ZnVuY3Rpb24odCxlLHMpe2lmKGUmJihcIkNhbGxFeHByZXNzaW9uXCI9PT1lLnR5cGV8fFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiPT09ZS50eXBlKSYmdCYmZS5jYWxsZWU9PT10JiZlLmFyZ3VtZW50cy5sZW5ndGg+MClyZXR1cm4gZ3QoZS5hcmd1bWVudHNbMF0scyksITA7cmV0dXJuITF9KGEsbix0KXx8ZnVuY3Rpb24odCxlKXtpZih0JiYoXCJQcm9wZXJ0eVwiPT09dC50eXBlfHxcIk9iamVjdFByb3BlcnR5XCI9PT10LnR5cGUpKXJldHVybiBndCh0LGUpLCEwO3JldHVybiExfShuLHQpfHxMdChuLGksdCxyKXx8ZnVuY3Rpb24odCxlLHMpe2lmKHQmJlwiVHlwZUFsaWFzXCI9PT10LnR5cGUpcmV0dXJuIGd0KHQscyksITA7cmV0dXJuITF9KG4sMCx0KXx8ZnVuY3Rpb24odCxlLHMpe2lmKHQmJihcIlZhcmlhYmxlRGVjbGFyYXRvclwiPT09dC50eXBlfHxcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI9PT10LnR5cGUpJiZlJiYoXCJPYmplY3RFeHByZXNzaW9uXCI9PT1lLnR5cGV8fFwiQXJyYXlFeHByZXNzaW9uXCI9PT1lLnR5cGV8fFwiVGVtcGxhdGVMaXRlcmFsXCI9PT1lLnR5cGV8fFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI9PT1lLnR5cGV8fEJ0KHMpKSlyZXR1cm4gZ3QoZSxzKSwhMDtyZXR1cm4hMX0obixvLHQpfSxoYW5kbGVSZW1haW5pbmdDb21tZW50OmZ1bmN0aW9uKHQsZSxzLGkscil7Y29uc3R7cHJlY2VkaW5nTm9kZTphLGVuY2xvc2luZ05vZGU6bixmb2xsb3dpbmdOb2RlOm99PXQ7cmV0dXJuISEoQXQoZSxhLG4sbyx0LHMpfHx3dChlLGEsbixvLHQscyl8fGZ1bmN0aW9uKHQsZSxzKXtpZih0JiYoXCJPYmplY3RQcm9wZXJ0eVwiPT09dC50eXBlfHxcIlByb3BlcnR5XCI9PT10LnR5cGUpJiZ0LnNob3J0aGFuZCYmdC5rZXk9PT1lJiZcIkFzc2lnbm1lbnRQYXR0ZXJuXCI9PT10LnZhbHVlLnR5cGUpcmV0dXJuIFB0KHQudmFsdWUubGVmdCxzKSwhMDtyZXR1cm4hMX0obixhLHQpfHxmdW5jdGlvbih0LGUscyxpKXtpZihcIilcIiE9PVguZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3Rlcih0LHMsaS5sb2NFbmQpKXJldHVybiExO2lmKGUmJihNdChlKSYmMD09PShlLnBhcmFtc3x8ZS5wYXJhbWV0ZXJzKS5sZW5ndGh8fChcIkNhbGxFeHByZXNzaW9uXCI9PT1lLnR5cGV8fFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiPT09ZS50eXBlfHxcIk5ld0V4cHJlc3Npb25cIj09PWUudHlwZSkmJjA9PT1lLmFyZ3VtZW50cy5sZW5ndGgpKXJldHVybiBFdChlLHMpLCEwO2lmKGUmJlwiTWV0aG9kRGVmaW5pdGlvblwiPT09ZS50eXBlJiYwPT09ZS52YWx1ZS5wYXJhbXMubGVuZ3RoKXJldHVybiBFdChlLnZhbHVlLHMpLCEwO3JldHVybiExfShlLG4sdCxzKXx8RnQoZSxuLGEsdCxzKXx8THQobixpLHQscil8fGZ1bmN0aW9uKHQsZSxzLGkpe2lmKCFlfHxcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIhPT1lLnR5cGUpcmV0dXJuITE7Y29uc3Qgcj1DdCh0LHMsaS5sb2NFbmQpO2lmKFwiPT5cIj09PXQuc2xpY2UocixyKzIpKXJldHVybiBFdChlLHMpLCEwO3JldHVybiExfShlLG4sdCxzKXx8ZnVuY3Rpb24odCxlLHMsaSxyKXtpZihcIihcIiE9PVguZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3Rlcih0LGksci5sb2NFbmQpKXJldHVybiExO2lmKHMmJmUmJihcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIj09PWUudHlwZXx8XCJGdW5jdGlvbkV4cHJlc3Npb25cIj09PWUudHlwZXx8XCJDbGFzc01ldGhvZFwiPT09ZS50eXBlfHxcIk1ldGhvZERlZmluaXRpb25cIj09PWUudHlwZXx8XCJPYmplY3RNZXRob2RcIj09PWUudHlwZSkpcmV0dXJuIFB0KHMsaSksITA7cmV0dXJuITF9KGUsbixhLHQscyl8fGZ1bmN0aW9uKHQsZSxzLGkscil7aWYoIWV8fFwiVFNNYXBwZWRUeXBlXCIhPT1lLnR5cGUpcmV0dXJuITE7aWYoaSYmXCJUU1R5cGVQYXJhbWV0ZXJcIj09PWkudHlwZSYmaS5uYW1lKXJldHVybiBndChpLm5hbWUsciksITA7aWYocyYmXCJUU1R5cGVQYXJhbWV0ZXJcIj09PXMudHlwZSYmcy5jb25zdHJhaW50KXJldHVybiBQdChzLmNvbnN0cmFpbnQsciksITA7cmV0dXJuITF9KDAsbixhLG8sdCl8fGZ1bmN0aW9uKHQsZSl7aWYodCYmKFwiQ29udGludWVTdGF0ZW1lbnRcIj09PXQudHlwZXx8XCJCcmVha1N0YXRlbWVudFwiPT09dC50eXBlKSYmIXQubGFiZWwpcmV0dXJuIFB0KHQsZSksITA7cmV0dXJuITF9KG4sdCl8fGZ1bmN0aW9uKHQsZSxzLGkscil7aWYoIXMmJmUmJihcIlRTTWV0aG9kU2lnbmF0dXJlXCI9PT1lLnR5cGV8fFwiVFNEZWNsYXJlRnVuY3Rpb25cIj09PWUudHlwZXx8XCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiPT09ZS50eXBlKSYmXCI7XCI9PT1YLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIodCxpLHIubG9jRW5kKSlyZXR1cm4gUHQoZSxpKSwhMDtyZXR1cm4hMX0oZSxuLG8sdCxzKSl9LGhhc0xlYWRpbmdDb21tZW50OmZ1bmN0aW9uKHQsZT0oKCk9PiEwKSl7cmV0dXJuIHQubGVhZGluZ0NvbW1lbnRzP3QubGVhZGluZ0NvbW1lbnRzLnNvbWUoZSk6ISF0LmNvbW1lbnRzJiZ0LmNvbW1lbnRzLnNvbWUodD0+dC5sZWFkaW5nJiZlKHQpKX0saXNCbG9ja0NvbW1lbnQ6QnQsaXNUeXBlQ2FzdENvbW1lbnQ6T3QsZ2V0R2FwUmVnZXg6ZnVuY3Rpb24odCl7aWYodCYmXCJCaW5hcnlFeHByZXNzaW9uXCIhPT10LnR5cGUmJlwiTG9naWNhbEV4cHJlc3Npb25cIiE9PXQudHlwZSlyZXR1cm4vXltcXHMoJnxdKiQvfSxnZXRDb21tZW50Q2hpbGROb2RlczpmdW5jdGlvbih0LGUpe2lmKChcInR5cGVzY3JpcHRcIj09PWUucGFyc2VyfHxcImZsb3dcIj09PWUucGFyc2VyKSYmXCJNZXRob2REZWZpbml0aW9uXCI9PT10LnR5cGUmJnQudmFsdWUmJlwiRnVuY3Rpb25FeHByZXNzaW9uXCI9PT10LnZhbHVlLnR5cGUmJjA9PT10LnZhbHVlLnBhcmFtcy5sZW5ndGgmJiF0LnZhbHVlLnJldHVyblR5cGUmJighdC52YWx1ZS50eXBlUGFyYW1ldGVyc3x8MD09PXQudmFsdWUudHlwZVBhcmFtZXRlcnMubGVuZ3RoKSYmdC52YWx1ZS5ib2R5KXJldHVyblsuLi50LmRlY29yYXRvcnN8fFtdLHQua2V5LHQudmFsdWUuYm9keV19fTtjb25zdHtnZXRMYXN0Ol90LGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXI6anR9PVgse2NvbXBvc2VMb2M6VXQsbG9jRW5kOnF0fT1tLHtpc1R5cGVDYXN0Q29tbWVudDpWdH09UnQ7ZnVuY3Rpb24genQodCxlLHMsaSl7aWYoIXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0KXJldHVybjtpZihBcnJheS5pc0FycmF5KHQpKXtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl6dCh0W3NdLGUsdCxzKTtyZXR1cm59aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQudHlwZSlyZXR1cm47Zm9yKGNvbnN0IHMgb2YgT2JqZWN0LmtleXModCkpenQodFtzXSxlLHQscyk7Y29uc3Qgcj1lKHQpO3ImJihzW2ldPXIpfWZ1bmN0aW9uIEh0KHQpe3JldHVyblwiTG9naWNhbEV4cHJlc3Npb25cIj09PXQudHlwZSYmXCJMb2dpY2FsRXhwcmVzc2lvblwiPT09dC5yaWdodC50eXBlJiZ0Lm9wZXJhdG9yPT09dC5yaWdodC5vcGVyYXRvcn12YXIgV3Q9ZnVuY3Rpb24odCxlKXtpZihcInR5cGVzY3JpcHRcIiE9PWUucGFyc2VyJiZcImZsb3dcIiE9PWUucGFyc2VyKXtjb25zdCBlPW5ldyBTZXQ7enQodCx0PT57dC5sZWFkaW5nQ29tbWVudHMmJnQubGVhZGluZ0NvbW1lbnRzLnNvbWUoVnQpJiZlLmFkZCh0LnN0YXJ0KX0pLHp0KHQsdD0+e2lmKFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIj09PXQudHlwZSYmIWUuaGFzKHQuc3RhcnQpKXtjb25zdHtleHByZXNzaW9uOmV9PXQ7cmV0dXJuIGUuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnBhcmVudGhlc2l6ZWQ9ITAsZS5leHRyYS5wYXJlblN0YXJ0PXQuc3RhcnQsZX19KX1yZXR1cm4genQodCx0PT57c3dpdGNoKHQudHlwZSl7Y2FzZVwiTG9naWNhbEV4cHJlc3Npb25cIjppZihIdCh0KSlyZXR1cm4gZnVuY3Rpb24gdChlKXtpZighSHQoZSkpcmV0dXJuIGU7cmV0dXJuIHQoT2JqZWN0LmFzc2lnbih7dHlwZTpcIkxvZ2ljYWxFeHByZXNzaW9uXCIsb3BlcmF0b3I6ZS5vcGVyYXRvcixsZWZ0OnQoT2JqZWN0LmFzc2lnbih7dHlwZTpcIkxvZ2ljYWxFeHByZXNzaW9uXCIsb3BlcmF0b3I6ZS5vcGVyYXRvcixsZWZ0OmUubGVmdCxyaWdodDplLnJpZ2h0LmxlZnR9LFV0KGUubGVmdCxlLnJpZ2h0LmxlZnQpKSkscmlnaHQ6ZS5yaWdodC5yaWdodH0sVXQoZSkpKX0odCk7YnJlYWs7Y2FzZVwiVmFyaWFibGVEZWNsYXJhdGlvblwiOntjb25zdCBzPV90KHQuZGVjbGFyYXRpb25zKTtzJiZzLmluaXQmJmZ1bmN0aW9uKHQscyl7aWYoXCI7XCI9PT1lLm9yaWdpbmFsVGV4dFtxdChzKV0pcmV0dXJuO0FycmF5LmlzQXJyYXkodC5yYW5nZSk/dC5yYW5nZT1bdC5yYW5nZVswXSxzLnJhbmdlWzFdXTp0LmVuZD1zLmVuZDt0LmxvYz1PYmplY3QuYXNzaWduKHt9LHQubG9jLHtlbmQ6dC5sb2MuZW5kfSl9KHQscyk7YnJlYWt9Y2FzZVwiVFNQYXJlbnRoZXNpemVkVHlwZVwiOnJldHVybiBPYmplY3QuYXNzaWduKHt9LHQudHlwZUFubm90YXRpb24se30sVXQodCkpO2Nhc2VcIlRTVW5pb25UeXBlXCI6Y2FzZVwiVFNJbnRlcnNlY3Rpb25UeXBlXCI6aWYoMT09PXQudHlwZXMubGVuZ3RoKXJldHVybiBPYmplY3QuYXNzaWduKHt9LHQudHlwZXNbMF0se30sVXQodCkpO2JyZWFrO2Nhc2VcIlRTVHlwZVBhcmFtZXRlclwiOlwic3RyaW5nXCI9PXR5cGVvZiB0Lm5hbWUmJih0Lm5hbWU9T2JqZWN0LmFzc2lnbih7dHlwZTpcIklkZW50aWZpZXJcIixuYW1lOnQubmFtZX0sVXQodCx0Lm5hbWUubGVuZ3RoKSkpO2JyZWFrO2Nhc2VcIlNlcXVlbmNlRXhwcmVzc2lvblwiOnQuZW5kJiZ0LmVuZD5fdCh0LmV4cHJlc3Npb25zKS5lbmQmJih0LmVuZD1fdCh0LmV4cHJlc3Npb25zKS5lbmQpO2JyZWFrO2Nhc2VcIkNsYXNzUHJvcGVydHlcIjp0LmtleSYmXCJUU1ByaXZhdGVJZGVudGlmaWVyXCI9PT10LmtleS50eXBlJiZcIj9cIj09PWp0KGUub3JpZ2luYWxUZXh0LHQua2V5LHF0KSYmKHQub3B0aW9uYWw9ITApfX0pLHR9LEt0PWkoKGZ1bmN0aW9uKHQsZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y2xhc3Mgc3tjb25zdHJ1Y3Rvcih0LGU9e30pe3RoaXMubGFiZWw9dCx0aGlzLmtleXdvcmQ9ZS5rZXl3b3JkLHRoaXMuYmVmb3JlRXhwcj0hIWUuYmVmb3JlRXhwcix0aGlzLnN0YXJ0c0V4cHI9ISFlLnN0YXJ0c0V4cHIsdGhpcy5yaWdodEFzc29jaWF0aXZlPSEhZS5yaWdodEFzc29jaWF0aXZlLHRoaXMuaXNMb29wPSEhZS5pc0xvb3AsdGhpcy5pc0Fzc2lnbj0hIWUuaXNBc3NpZ24sdGhpcy5wcmVmaXg9ISFlLnByZWZpeCx0aGlzLnBvc3RmaXg9ISFlLnBvc3RmaXgsdGhpcy5iaW5vcD1udWxsIT1lLmJpbm9wP2UuYmlub3A6bnVsbCx0aGlzLnVwZGF0ZUNvbnRleHQ9bnVsbH19Y29uc3QgaT1uZXcgTWFwO2Z1bmN0aW9uIHIodCxlPXt9KXtlLmtleXdvcmQ9dDtjb25zdCByPW5ldyBzKHQsZSk7cmV0dXJuIGkuc2V0KHQscikscn1mdW5jdGlvbiBhKHQsZSl7cmV0dXJuIG5ldyBzKHQse2JlZm9yZUV4cHI6ITAsYmlub3A6ZX0pfWNvbnN0IG49e251bTpuZXcgcyhcIm51bVwiLHtzdGFydHNFeHByOiEwfSksYmlnaW50Om5ldyBzKFwiYmlnaW50XCIse3N0YXJ0c0V4cHI6ITB9KSxyZWdleHA6bmV3IHMoXCJyZWdleHBcIix7c3RhcnRzRXhwcjohMH0pLHN0cmluZzpuZXcgcyhcInN0cmluZ1wiLHtzdGFydHNFeHByOiEwfSksbmFtZTpuZXcgcyhcIm5hbWVcIix7c3RhcnRzRXhwcjohMH0pLGVvZjpuZXcgcyhcImVvZlwiKSxicmFja2V0TDpuZXcgcyhcIltcIix7YmVmb3JlRXhwcjohMCxzdGFydHNFeHByOiEwfSksYnJhY2tldEhhc2hMOm5ldyBzKFwiI1tcIix7YmVmb3JlRXhwcjohMCxzdGFydHNFeHByOiEwfSksYnJhY2tldEJhckw6bmV3IHMoXCJbfFwiLHtiZWZvcmVFeHByOiEwLHN0YXJ0c0V4cHI6ITB9KSxicmFja2V0UjpuZXcgcyhcIl1cIiksYnJhY2tldEJhclI6bmV3IHMoXCJ8XVwiKSxicmFjZUw6bmV3IHMoXCJ7XCIse2JlZm9yZUV4cHI6ITAsc3RhcnRzRXhwcjohMH0pLGJyYWNlQmFyTDpuZXcgcyhcInt8XCIse2JlZm9yZUV4cHI6ITAsc3RhcnRzRXhwcjohMH0pLGJyYWNlSGFzaEw6bmV3IHMoXCIje1wiLHtiZWZvcmVFeHByOiEwLHN0YXJ0c0V4cHI6ITB9KSxicmFjZVI6bmV3IHMoXCJ9XCIpLGJyYWNlQmFyUjpuZXcgcyhcInx9XCIpLHBhcmVuTDpuZXcgcyhcIihcIix7YmVmb3JlRXhwcjohMCxzdGFydHNFeHByOiEwfSkscGFyZW5SOm5ldyBzKFwiKVwiKSxjb21tYTpuZXcgcyhcIixcIix7YmVmb3JlRXhwcjohMH0pLHNlbWk6bmV3IHMoXCI7XCIse2JlZm9yZUV4cHI6ITB9KSxjb2xvbjpuZXcgcyhcIjpcIix7YmVmb3JlRXhwcjohMH0pLGRvdWJsZUNvbG9uOm5ldyBzKFwiOjpcIix7YmVmb3JlRXhwcjohMH0pLGRvdDpuZXcgcyhcIi5cIikscXVlc3Rpb246bmV3IHMoXCI/XCIse2JlZm9yZUV4cHI6ITB9KSxxdWVzdGlvbkRvdDpuZXcgcyhcIj8uXCIpLGFycm93Om5ldyBzKFwiPT5cIix7YmVmb3JlRXhwcjohMH0pLHRlbXBsYXRlOm5ldyBzKFwidGVtcGxhdGVcIiksZWxsaXBzaXM6bmV3IHMoXCIuLi5cIix7YmVmb3JlRXhwcjohMH0pLGJhY2tRdW90ZTpuZXcgcyhcImBcIix7c3RhcnRzRXhwcjohMH0pLGRvbGxhckJyYWNlTDpuZXcgcyhcIiR7XCIse2JlZm9yZUV4cHI6ITAsc3RhcnRzRXhwcjohMH0pLGF0Om5ldyBzKFwiQFwiKSxoYXNoOm5ldyBzKFwiI1wiLHtzdGFydHNFeHByOiEwfSksaW50ZXJwcmV0ZXJEaXJlY3RpdmU6bmV3IHMoXCIjIS4uLlwiKSxlcTpuZXcgcyhcIj1cIix7YmVmb3JlRXhwcjohMCxpc0Fzc2lnbjohMH0pLGFzc2lnbjpuZXcgcyhcIl89XCIse2JlZm9yZUV4cHI6ITAsaXNBc3NpZ246ITB9KSxpbmNEZWM6bmV3IHMoXCIrKy8tLVwiLHtwcmVmaXg6ITAscG9zdGZpeDohMCxzdGFydHNFeHByOiEwfSksYmFuZzpuZXcgcyhcIiFcIix7YmVmb3JlRXhwcjohMCxwcmVmaXg6ITAsc3RhcnRzRXhwcjohMH0pLHRpbGRlOm5ldyBzKFwiflwiLHtiZWZvcmVFeHByOiEwLHByZWZpeDohMCxzdGFydHNFeHByOiEwfSkscGlwZWxpbmU6YShcInw+XCIsMCksbnVsbGlzaENvYWxlc2Npbmc6YShcIj8/XCIsMSksbG9naWNhbE9SOmEoXCJ8fFwiLDEpLGxvZ2ljYWxBTkQ6YShcIiYmXCIsMiksYml0d2lzZU9SOmEoXCJ8XCIsMyksYml0d2lzZVhPUjphKFwiXlwiLDQpLGJpdHdpc2VBTkQ6YShcIiZcIiw1KSxlcXVhbGl0eTphKFwiPT0vIT0vPT09LyE9PVwiLDYpLHJlbGF0aW9uYWw6YShcIjwvPi88PS8+PVwiLDcpLGJpdFNoaWZ0OmEoXCI8PC8+Pi8+Pj5cIiw4KSxwbHVzTWluOm5ldyBzKFwiKy8tXCIse2JlZm9yZUV4cHI6ITAsYmlub3A6OSxwcmVmaXg6ITAsc3RhcnRzRXhwcjohMH0pLG1vZHVsbzpuZXcgcyhcIiVcIix7YmVmb3JlRXhwcjohMCxiaW5vcDoxMCxzdGFydHNFeHByOiEwfSksc3RhcjphKFwiKlwiLDEwKSxzbGFzaDphKFwiL1wiLDEwKSxleHBvbmVudDpuZXcgcyhcIioqXCIse2JlZm9yZUV4cHI6ITAsYmlub3A6MTEscmlnaHRBc3NvY2lhdGl2ZTohMH0pLF9icmVhazpyKFwiYnJlYWtcIiksX2Nhc2U6cihcImNhc2VcIix7YmVmb3JlRXhwcjohMH0pLF9jYXRjaDpyKFwiY2F0Y2hcIiksX2NvbnRpbnVlOnIoXCJjb250aW51ZVwiKSxfZGVidWdnZXI6cihcImRlYnVnZ2VyXCIpLF9kZWZhdWx0OnIoXCJkZWZhdWx0XCIse2JlZm9yZUV4cHI6ITB9KSxfZG86cihcImRvXCIse2lzTG9vcDohMCxiZWZvcmVFeHByOiEwfSksX2Vsc2U6cihcImVsc2VcIix7YmVmb3JlRXhwcjohMH0pLF9maW5hbGx5OnIoXCJmaW5hbGx5XCIpLF9mb3I6cihcImZvclwiLHtpc0xvb3A6ITB9KSxfZnVuY3Rpb246cihcImZ1bmN0aW9uXCIse3N0YXJ0c0V4cHI6ITB9KSxfaWY6cihcImlmXCIpLF9yZXR1cm46cihcInJldHVyblwiLHtiZWZvcmVFeHByOiEwfSksX3N3aXRjaDpyKFwic3dpdGNoXCIpLF90aHJvdzpyKFwidGhyb3dcIix7YmVmb3JlRXhwcjohMCxwcmVmaXg6ITAsc3RhcnRzRXhwcjohMH0pLF90cnk6cihcInRyeVwiKSxfdmFyOnIoXCJ2YXJcIiksX2NvbnN0OnIoXCJjb25zdFwiKSxfd2hpbGU6cihcIndoaWxlXCIse2lzTG9vcDohMH0pLF93aXRoOnIoXCJ3aXRoXCIpLF9uZXc6cihcIm5ld1wiLHtiZWZvcmVFeHByOiEwLHN0YXJ0c0V4cHI6ITB9KSxfdGhpczpyKFwidGhpc1wiLHtzdGFydHNFeHByOiEwfSksX3N1cGVyOnIoXCJzdXBlclwiLHtzdGFydHNFeHByOiEwfSksX2NsYXNzOnIoXCJjbGFzc1wiLHtzdGFydHNFeHByOiEwfSksX2V4dGVuZHM6cihcImV4dGVuZHNcIix7YmVmb3JlRXhwcjohMH0pLF9leHBvcnQ6cihcImV4cG9ydFwiKSxfaW1wb3J0OnIoXCJpbXBvcnRcIix7c3RhcnRzRXhwcjohMH0pLF9udWxsOnIoXCJudWxsXCIse3N0YXJ0c0V4cHI6ITB9KSxfdHJ1ZTpyKFwidHJ1ZVwiLHtzdGFydHNFeHByOiEwfSksX2ZhbHNlOnIoXCJmYWxzZVwiLHtzdGFydHNFeHByOiEwfSksX2luOnIoXCJpblwiLHtiZWZvcmVFeHByOiEwLGJpbm9wOjd9KSxfaW5zdGFuY2VvZjpyKFwiaW5zdGFuY2VvZlwiLHtiZWZvcmVFeHByOiEwLGJpbm9wOjd9KSxfdHlwZW9mOnIoXCJ0eXBlb2ZcIix7YmVmb3JlRXhwcjohMCxwcmVmaXg6ITAsc3RhcnRzRXhwcjohMH0pLF92b2lkOnIoXCJ2b2lkXCIse2JlZm9yZUV4cHI6ITAscHJlZml4OiEwLHN0YXJ0c0V4cHI6ITB9KSxfZGVsZXRlOnIoXCJkZWxldGVcIix7YmVmb3JlRXhwcjohMCxwcmVmaXg6ITAsc3RhcnRzRXhwcjohMH0pfSxvPS9cXHJcXG4/fFtcXG5cXHUyMDI4XFx1MjAyOV0vLGg9bmV3IFJlZ0V4cChvLnNvdXJjZSxcImdcIik7ZnVuY3Rpb24gcCh0KXtzd2l0Y2godCl7Y2FzZSAxMDpjYXNlIDEzOmNhc2UgODIzMjpjYXNlIDgyMzM6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19Y29uc3QgYz0vKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztmdW5jdGlvbiB1KHQpe3N3aXRjaCh0KXtjYXNlIDk6Y2FzZSAxMTpjYXNlIDEyOmNhc2UgMzI6Y2FzZSAxNjA6Y2FzZSA1NzYwOmNhc2UgODE5MjpjYXNlIDgxOTM6Y2FzZSA4MTk0OmNhc2UgODE5NTpjYXNlIDgxOTY6Y2FzZSA4MTk3OmNhc2UgODE5ODpjYXNlIDgxOTk6Y2FzZSA4MjAwOmNhc2UgODIwMTpjYXNlIDgyMDI6Y2FzZSA4MjM5OmNhc2UgODI4NzpjYXNlIDEyMjg4OmNhc2UgNjUyNzk6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19Y2xhc3MgbHtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMubGluZT10LHRoaXMuY29sdW1uPWV9fWNsYXNzIGR7Y29uc3RydWN0b3IodCxlKXt0aGlzLnN0YXJ0PXQsdGhpcy5lbmQ9ZX19ZnVuY3Rpb24gbSh0KXtyZXR1cm4gdFt0Lmxlbmd0aC0xXX1jb25zdCBmPU9iamVjdC5mcmVlemUoe0FyZ3VtZW50c0Rpc2FsbG93ZWRJbkluaXRpYWxpemVyOlwiJ2FyZ3VtZW50cycgaXMgbm90IGFsbG93ZWQgaW4gY2xhc3MgZmllbGQgaW5pdGlhbGl6ZXJcIixBc3luY0Z1bmN0aW9uSW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0OlwiQXN5bmMgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRoZSB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2tcIixBd2FpdEJpbmRpbmdJZGVudGlmaWVyOlwiQ2FuIG5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiLEF3YWl0RXhwcmVzc2lvbkZvcm1hbFBhcmFtZXRlcjpcImF3YWl0IGlzIG5vdCBhbGxvd2VkIGluIGFzeW5jIGZ1bmN0aW9uIHBhcmFtZXRlcnNcIixBd2FpdE5vdEluQXN5bmNGdW5jdGlvbjpcIkNhbiBub3QgdXNlIGtleXdvcmQgJ2F3YWl0JyBvdXRzaWRlIGFuIGFzeW5jIGZ1bmN0aW9uXCIsQmFkR2V0dGVyQXJpdHk6XCJnZXR0ZXIgbXVzdCBub3QgaGF2ZSBhbnkgZm9ybWFsIHBhcmFtZXRlcnNcIixCYWRTZXR0ZXJBcml0eTpcInNldHRlciBtdXN0IGhhdmUgZXhhY3RseSBvbmUgZm9ybWFsIHBhcmFtZXRlclwiLEJhZFNldHRlclJlc3RQYXJhbWV0ZXI6XCJzZXR0ZXIgZnVuY3Rpb24gYXJndW1lbnQgbXVzdCBub3QgYmUgYSByZXN0IHBhcmFtZXRlclwiLENvbnN0cnVjdG9yQ2xhc3NGaWVsZDpcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJ1wiLENvbnN0cnVjdG9yQ2xhc3NQcml2YXRlRmllbGQ6XCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHByaXZhdGUgZmllbGQgbmFtZWQgJyNjb25zdHJ1Y3RvcidcIixDb25zdHJ1Y3RvcklzQWNjZXNzb3I6XCJDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFjY2Vzc29yXCIsQ29uc3RydWN0b3JJc0FzeW5jOlwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgZnVuY3Rpb25cIixDb25zdHJ1Y3RvcklzR2VuZXJhdG9yOlwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3JcIixEZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplcjpcIiUwIHJlcXVpcmUgYW4gaW5pdGlhbGl6YXRpb24gdmFsdWVcIixEZWNvcmF0b3JCZWZvcmVFeHBvcnQ6XCJEZWNvcmF0b3JzIG11c3QgYmUgcGxhY2VkICpiZWZvcmUqIHRoZSAnZXhwb3J0JyBrZXl3b3JkLiBZb3UgY2FuIHNldCB0aGUgJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQnIG9wdGlvbiB0byBmYWxzZSB0byB1c2UgdGhlICdleHBvcnQgQGRlY29yYXRvciBjbGFzcyB7fScgc3ludGF4XCIsRGVjb3JhdG9yQ29uc3RydWN0b3I6XCJEZWNvcmF0b3JzIGNhbid0IGJlIHVzZWQgd2l0aCBhIGNvbnN0cnVjdG9yLiBEaWQgeW91IG1lYW4gJ0BkZWMgY2xhc3MgeyAuLi4gfSc/XCIsRGVjb3JhdG9yRXhwb3J0Q2xhc3M6XCJVc2luZyB0aGUgZXhwb3J0IGtleXdvcmQgYmV0d2VlbiBhIGRlY29yYXRvciBhbmQgYSBjbGFzcyBpcyBub3QgYWxsb3dlZC4gUGxlYXNlIHVzZSBgZXhwb3J0IEBkZWMgY2xhc3NgIGluc3RlYWQuXCIsRGVjb3JhdG9yU2VtaWNvbG9uOlwiRGVjb3JhdG9ycyBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBhIHNlbWljb2xvblwiLERlbGV0ZVByaXZhdGVGaWVsZDpcIkRlbGV0aW5nIGEgcHJpdmF0ZSBmaWVsZCBpcyBub3QgYWxsb3dlZFwiLERlc3RydWN0dXJlTmFtZWRJbXBvcnQ6XCJFUzIwMTUgbmFtZWQgaW1wb3J0cyBkbyBub3QgZGVzdHJ1Y3R1cmUuIFVzZSBhbm90aGVyIHN0YXRlbWVudCBmb3IgZGVzdHJ1Y3R1cmluZyBhZnRlciB0aGUgaW1wb3J0LlwiLER1cGxpY2F0ZUNvbnN0cnVjdG9yOlwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzXCIsRHVwbGljYXRlRGVmYXVsdEV4cG9ydDpcIk9ubHkgb25lIGRlZmF1bHQgZXhwb3J0IGFsbG93ZWQgcGVyIG1vZHVsZS5cIixEdXBsaWNhdGVFeHBvcnQ6XCJgJTBgIGhhcyBhbHJlYWR5IGJlZW4gZXhwb3J0ZWQuIEV4cG9ydGVkIGlkZW50aWZpZXJzIG11c3QgYmUgdW5pcXVlLlwiLER1cGxpY2F0ZVByb3RvOlwiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eVwiLER1cGxpY2F0ZVJlZ0V4cEZsYWdzOlwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIsRWxlbWVudEFmdGVyUmVzdDpcIlJlc3QgZWxlbWVudCBtdXN0IGJlIGxhc3QgZWxlbWVudFwiLEVzY2FwZWRDaGFyTm90QW5JZGVudGlmaWVyOlwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiLEZvckluT2ZMb29wSW5pdGlhbGl6ZXI6XCIlMCBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiLEdlbmVyYXRvckluU2luZ2xlU3RhdGVtZW50Q29udGV4dDpcIkdlbmVyYXRvcnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdGhlIHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9ja1wiLElsbGVnYWxCcmVha0NvbnRpbnVlOlwiVW5zeW50YWN0aWMgJTBcIixJbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlOlwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdFwiLElsbGVnYWxSZXR1cm46XCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIsSW1wb3J0Q2FsbEFyZ3VtZW50VHJhaWxpbmdDb21tYTpcIlRyYWlsaW5nIGNvbW1hIGlzIGRpc2FsbG93ZWQgaW5zaWRlIGltcG9ydCguLi4pIGFyZ3VtZW50c1wiLEltcG9ydENhbGxBcml0eTpcImltcG9ydCgpIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50XCIsSW1wb3J0Q2FsbEFyaXR5THRPbmU6XCJEeW5hbWljIGltcG9ydHMgcmVxdWlyZSBhIHBhcmFtZXRlcjogaW1wb3J0KCdhLmpzJylcIixJbXBvcnRDYWxsTm90TmV3RXhwcmVzc2lvbjpcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KC4uLilcIixJbXBvcnRDYWxsU3ByZWFkQXJndW1lbnQ6XCIuLi4gaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KClcIixJbXBvcnRNZXRhT3V0c2lkZU1vZHVsZTpcImltcG9ydC5tZXRhIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBcXFwibW9kdWxlXFxcIidcIixJbXBvcnRPdXRzaWRlTW9kdWxlOlwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBcXFwibW9kdWxlXFxcIidcIixJbnZhbGlkQ29kZVBvaW50OlwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIsSW52YWxpZERpZ2l0OlwiRXhwZWN0ZWQgbnVtYmVyIGluIHJhZGl4ICUwXCIsSW52YWxpZEVzY2FwZVNlcXVlbmNlOlwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIixJbnZhbGlkRXNjYXBlU2VxdWVuY2VUZW1wbGF0ZTpcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlXCIsSW52YWxpZEVzY2FwZWRSZXNlcnZlZFdvcmQ6XCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCAlMFwiLEludmFsaWRJZGVudGlmaWVyOlwiSW52YWxpZCBpZGVudGlmaWVyICUwXCIsSW52YWxpZExoczpcIkludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gJTBcIixJbnZhbGlkTGhzQmluZGluZzpcIkJpbmRpbmcgaW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiAlMFwiLEludmFsaWROdW1iZXI6XCJJbnZhbGlkIG51bWJlclwiLEludmFsaWRPclVuZXhwZWN0ZWRUb2tlbjpcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICclMCdcIixJbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQ6XCJJbnZhbGlkIHBhcmVudGhlc2l6ZWQgYXNzaWdubWVudCBwYXR0ZXJuXCIsSW52YWxpZFByaXZhdGVGaWVsZFJlc29sdXRpb246XCJQcml2YXRlIG5hbWUgIyUwIGlzIG5vdCBkZWZpbmVkXCIsSW52YWxpZFByb3BlcnR5QmluZGluZ1BhdHRlcm46XCJCaW5kaW5nIG1lbWJlciBleHByZXNzaW9uXCIsSW52YWxpZFJlc3RBc3NpZ25tZW50UGF0dGVybjpcIkludmFsaWQgcmVzdCBvcGVyYXRvcidzIGFyZ3VtZW50XCIsTGFiZWxSZWRlY2xhcmF0aW9uOlwiTGFiZWwgJyUwJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIsTGV0SW5MZXhpY2FsQmluZGluZzpcIidsZXQnIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgYXMgYSBuYW1lIGluICdsZXQnIG9yICdjb25zdCcgZGVjbGFyYXRpb25zLlwiLE1hbGZvcm1lZFJlZ0V4cEZsYWdzOlwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZ1wiLE1pc3NpbmdDbGFzc05hbWU6XCJBIGNsYXNzIG5hbWUgaXMgcmVxdWlyZWRcIixNaXNzaW5nRXFJbkFzc2lnbm1lbnQ6XCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiLE1pc3NpbmdVbmljb2RlRXNjYXBlOlwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiLE1peGluZ0NvYWxlc2NlV2l0aExvZ2ljYWw6XCJOdWxsaXNoIGNvYWxlc2Npbmcgb3BlcmF0b3IoPz8pIHJlcXVpcmVzIHBhcmVucyB3aGVuIG1peGluZyB3aXRoIGxvZ2ljYWwgb3BlcmF0b3JzXCIsTW9kdWxlRXhwb3J0VW5kZWZpbmVkOlwiRXhwb3J0ICclMCcgaXMgbm90IGRlZmluZWRcIixNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6XCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIixOZXdsaW5lQWZ0ZXJUaHJvdzpcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiLE5vQ2F0Y2hPckZpbmFsbHk6XCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIsTnVtYmVySWRlbnRpZmllcjpcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIsTnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2U6XCJOdW1lcmljIHNlcGFyYXRvcnMgYXJlIG5vdCBhbGxvd2VkIGluc2lkZSB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZXMgb3IgaGV4IGVzY2FwZSBzZXF1ZW5jZXNcIixPYnNvbGV0ZUF3YWl0U3RhcjpcImF3YWl0KiBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9ucyBwcm9wb3NhbC4gVXNlIFByb21pc2UuYWxsKCkgaW5zdGVhZC5cIixPcHRpb25hbENoYWluaW5nTm9OZXc6XCJjb25zdHJ1Y3RvcnMgaW4vYWZ0ZXIgYW4gT3B0aW9uYWwgQ2hhaW4gYXJlIG5vdCBhbGxvd2VkXCIsT3B0aW9uYWxDaGFpbmluZ05vVGVtcGxhdGU6XCJUYWdnZWQgVGVtcGxhdGUgTGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIG9wdGlvbmFsQ2hhaW5cIixQYXJhbUR1cGU6XCJBcmd1bWVudCBuYW1lIGNsYXNoXCIsUGF0dGVybkhhc0FjY2Vzc29yOlwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIsUGF0dGVybkhhc01ldGhvZDpcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gbWV0aG9kc1wiLFBpcGVsaW5lQm9keU5vQXJyb3c6J1VuZXhwZWN0ZWQgYXJyb3cgXCI9PlwiIGFmdGVyIHBpcGVsaW5lIGJvZHk7IGFycm93IGZ1bmN0aW9uIGluIHBpcGVsaW5lIGJvZHkgbXVzdCBiZSBwYXJlbnRoZXNpemVkJyxQaXBlbGluZUJvZHlTZXF1ZW5jZUV4cHJlc3Npb246XCJQaXBlbGluZSBib2R5IG1heSBub3QgYmUgYSBjb21tYS1zZXBhcmF0ZWQgc2VxdWVuY2UgZXhwcmVzc2lvblwiLFBpcGVsaW5lSGVhZFNlcXVlbmNlRXhwcmVzc2lvbjpcIlBpcGVsaW5lIGhlYWQgc2hvdWxkIG5vdCBiZSBhIGNvbW1hLXNlcGFyYXRlZCBzZXF1ZW5jZSBleHByZXNzaW9uXCIsUGlwZWxpbmVUb3BpY1VudXNlZDpcIlBpcGVsaW5lIGlzIGluIHRvcGljIHN0eWxlIGJ1dCBkb2VzIG5vdCB1c2UgdG9waWMgcmVmZXJlbmNlXCIsUHJpbWFyeVRvcGljTm90QWxsb3dlZDpcIlRvcGljIHJlZmVyZW5jZSB3YXMgdXNlZCBpbiBhIGxleGljYWwgY29udGV4dCB3aXRob3V0IHRvcGljIGJpbmRpbmdcIixQcmltYXJ5VG9waWNSZXF1aXJlc1NtYXJ0UGlwZWxpbmU6XCJQcmltYXJ5IFRvcGljIFJlZmVyZW5jZSBmb3VuZCBidXQgcGlwZWxpbmVPcGVyYXRvciBub3QgcGFzc2VkICdzbWFydCcgZm9yICdwcm9wb3NhbCcgb3B0aW9uLlwiLFByaXZhdGVOYW1lUmVkZWNsYXJhdGlvbjpcIkR1cGxpY2F0ZSBwcml2YXRlIG5hbWUgIyUwXCIsUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGU6XCJSZWNvcmQgZXhwcmVzc2lvbnMgZW5kaW5nIHdpdGggJ3x9JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnYmFyJ1wiLFJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6XCJSZWNvcmQgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAne3wnIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInXCIsUmVjb3JkRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6XCJSZWNvcmQgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnI3snIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdoYXNoJ1wiLFJlc3RUcmFpbGluZ0NvbW1hOlwiVW5leHBlY3RlZCB0cmFpbGluZyBjb21tYSBhZnRlciByZXN0IGVsZW1lbnRcIixTbG9wcHlGdW5jdGlvbjpcIkluIG5vbi1zdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsLCBpbnNpZGUgYSBibG9jaywgb3IgYXMgdGhlIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50XCIsU3RhdGljUHJvdG90eXBlOlwiQ2xhc3NlcyBtYXkgbm90IGhhdmUgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZVwiLFN0cmljdERlbGV0ZTpcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIsU3RyaWN0RXZhbEFyZ3VtZW50czpcIkFzc2lnbmluZyB0byAnJTAnIGluIHN0cmljdCBtb2RlXCIsU3RyaWN0RXZhbEFyZ3VtZW50c0JpbmRpbmc6XCJCaW5kaW5nICclMCcgaW4gc3RyaWN0IG1vZGVcIixTdHJpY3RGdW5jdGlvbjpcIkluIHN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2tcIixTdHJpY3RPY3RhbExpdGVyYWw6XCJMZWdhY3kgb2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXCIsU3RyaWN0V2l0aDpcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiLFN1cGVyTm90QWxsb3dlZDpcInN1cGVyKCkgaXMgb25seSB2YWxpZCBpbnNpZGUgYSBjbGFzcyBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzLiBNYXliZSBhIHR5cG8gaW4gdGhlIG1ldGhvZCBuYW1lICgnY29uc3RydWN0b3InKSBvciBub3QgZXh0ZW5kaW5nIGFub3RoZXIgY2xhc3M/XCIsU3VwZXJQcml2YXRlRmllbGQ6XCJQcml2YXRlIGZpZWxkcyBjYW4ndCBiZSBhY2Nlc3NlZCBvbiBzdXBlclwiLFRyYWlsaW5nRGVjb3JhdG9yOlwiRGVjb3JhdG9ycyBtdXN0IGJlIGF0dGFjaGVkIHRvIGEgY2xhc3MgZWxlbWVudFwiLFR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGU6XCJUdXBsZSBleHByZXNzaW9ucyBlbmRpbmcgd2l0aCAnfF0nIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInXCIsVHVwbGVFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlOlwiVHVwbGUgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnW3wnIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdiYXInXCIsVHVwbGVFeHByZXNzaW9uSGFzaEluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTpcIlR1cGxlIGV4cHJlc3Npb25zIHN0YXJ0aW5nIHdpdGggJyNbJyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnaGFzaCdcIixVbmV4cGVjdGVkQXJndW1lbnRQbGFjZWhvbGRlcjpcIlVuZXhwZWN0ZWQgYXJndW1lbnQgcGxhY2Vob2xkZXJcIixVbmV4cGVjdGVkQXdhaXRBZnRlclBpcGVsaW5lQm9keTonVW5leHBlY3RlZCBcImF3YWl0XCIgYWZ0ZXIgcGlwZWxpbmUgYm9keTsgYXdhaXQgbXVzdCBoYXZlIHBhcmVudGhlc2VzIGluIG1pbmltYWwgcHJvcG9zYWwnLFVuZXhwZWN0ZWREaWdpdEFmdGVySGFzaDpcIlVuZXhwZWN0ZWQgZGlnaXQgYWZ0ZXIgaGFzaCB0b2tlblwiLFVuZXhwZWN0ZWRJbXBvcnRFeHBvcnQ6XCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIixVbmV4cGVjdGVkS2V5d29yZDpcIlVuZXhwZWN0ZWQga2V5d29yZCAnJTAnXCIsVW5leHBlY3RlZExlYWRpbmdEZWNvcmF0b3I6XCJMZWFkaW5nIGRlY29yYXRvcnMgbXVzdCBiZSBhdHRhY2hlZCB0byBhIGNsYXNzIGRlY2xhcmF0aW9uXCIsVW5leHBlY3RlZExleGljYWxEZWNsYXJhdGlvbjpcIkxleGljYWwgZGVjbGFyYXRpb24gY2Fubm90IGFwcGVhciBpbiBhIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dFwiLFVuZXhwZWN0ZWROZXdUYXJnZXQ6XCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIsVW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3I6XCJBIG51bWVyaWMgc2VwYXJhdG9yIGlzIG9ubHkgYWxsb3dlZCBiZXR3ZWVuIHR3byBkaWdpdHNcIixVbmV4cGVjdGVkUHJpdmF0ZUZpZWxkOlwiUHJpdmF0ZSBuYW1lcyBjYW4gb25seSBiZSB1c2VkIGFzIHRoZSBuYW1lIG9mIGEgY2xhc3MgZWxlbWVudCAoaS5lLiBjbGFzcyBDIHsgI3AgPSA0MjsgI20oKSB7fSB9IClcXG4gb3IgYSBwcm9wZXJ0eSBvZiBtZW1iZXIgZXhwcmVzc2lvbiAoaS5lLiB0aGlzLiNwKS5cIixVbmV4cGVjdGVkUmVzZXJ2ZWRXb3JkOlwiVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkICclMCdcIixVbmV4cGVjdGVkU3VwZXI6XCJzdXBlciBpcyBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1ldGhvZHMgYW5kIGNsYXNzZXNcIixVbmV4cGVjdGVkVG9rZW46XCJVbmV4cGVjdGVkIHRva2VuICclJ1wiLFVuZXhwZWN0ZWRUb2tlblVuYXJ5RXhwb25lbnRpYXRpb246XCJJbGxlZ2FsIGV4cHJlc3Npb24uIFdyYXAgbGVmdCBoYW5kIHNpZGUgb3IgZW50aXJlIGV4cG9uZW50aWF0aW9uIGluIHBhcmVudGhlc2VzLlwiLFVuc3VwcG9ydGVkQmluZDpcIkJpbmRpbmcgc2hvdWxkIGJlIHBlcmZvcm1lZCBvbiBvYmplY3QgcHJvcGVydHkuXCIsVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQ6XCJBIGRlY29yYXRlZCBleHBvcnQgbXVzdCBleHBvcnQgYSBjbGFzcyBkZWNsYXJhdGlvblwiLFVuc3VwcG9ydGVkRGVmYXVsdEV4cG9ydDpcIk9ubHkgZXhwcmVzc2lvbnMsIGZ1bmN0aW9ucyBvciBjbGFzc2VzIGFyZSBhbGxvd2VkIGFzIHRoZSBgZGVmYXVsdGAgZXhwb3J0LlwiLFVuc3VwcG9ydGVkSW1wb3J0OlwiaW1wb3J0IGNhbiBvbmx5IGJlIHVzZWQgaW4gaW1wb3J0KCkgb3IgaW1wb3J0Lm1ldGFcIixVbnN1cHBvcnRlZE1ldGFQcm9wZXJ0eTpcIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yICUwIGlzICUwLiUxXCIsVW5zdXBwb3J0ZWRQYXJhbWV0ZXJEZWNvcmF0b3I6XCJEZWNvcmF0b3JzIGNhbm5vdCBiZSB1c2VkIHRvIGRlY29yYXRlIHBhcmFtZXRlcnNcIixVbnN1cHBvcnRlZFByb3BlcnR5RGVjb3JhdG9yOlwiRGVjb3JhdG9ycyBjYW5ub3QgYmUgdXNlZCB0byBkZWNvcmF0ZSBvYmplY3QgbGl0ZXJhbCBwcm9wZXJ0aWVzXCIsVW5zdXBwb3J0ZWRTdXBlcjpcInN1cGVyIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBmdW5jdGlvbiBjYWxscyAoaS5lLiBzdXBlcigpKSBvciBpbiBwcm9wZXJ0eSBhY2Nlc3NlcyAoaS5lLiBzdXBlci5wcm9wIG9yIHN1cGVyW3Byb3BdKVwiLFVudGVybWluYXRlZENvbW1lbnQ6XCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiLFVudGVybWluYXRlZFJlZ0V4cDpcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIixVbnRlcm1pbmF0ZWRTdHJpbmc6XCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIsVW50ZXJtaW5hdGVkVGVtcGxhdGU6XCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIixWYXJSZWRlY2xhcmF0aW9uOlwiSWRlbnRpZmllciAnJTAnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWRcIixZaWVsZEJpbmRpbmdJZGVudGlmaWVyOlwiQ2FuIG5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvclwiLFlpZWxkSW5QYXJhbWV0ZXI6XCJ5aWVsZCBpcyBub3QgYWxsb3dlZCBpbiBnZW5lcmF0b3IgcGFyYW1ldGVyc1wiLFplcm9EaWdpdE51bWVyaWNTZXBhcmF0b3I6XCJOdW1lcmljIHNlcGFyYXRvciBjYW4gbm90IGJlIHVzZWQgYWZ0ZXIgbGVhZGluZyAwXCJ9KTtmdW5jdGlvbiBEKHQpe3JldHVybiBudWxsIT10JiZcIlByb3BlcnR5XCI9PT10LnR5cGUmJlwiaW5pdFwiPT09dC5raW5kJiYhMT09PXQubWV0aG9kfWNsYXNzIHl7Y29uc3RydWN0b3IodCxlLHMsaSl7dGhpcy50b2tlbj10LHRoaXMuaXNFeHByPSEhZSx0aGlzLnByZXNlcnZlU3BhY2U9ISFzLHRoaXMub3ZlcnJpZGU9aX19Y29uc3QgeD17YnJhY2VTdGF0ZW1lbnQ6bmV3IHkoXCJ7XCIsITEpLGJyYWNlRXhwcmVzc2lvbjpuZXcgeShcIntcIiwhMCksdGVtcGxhdGVRdWFzaTpuZXcgeShcIiR7XCIsITEpLHBhcmVuU3RhdGVtZW50Om5ldyB5KFwiKFwiLCExKSxwYXJlbkV4cHJlc3Npb246bmV3IHkoXCIoXCIsITApLHRlbXBsYXRlOm5ldyB5KFwiYFwiLCEwLCEwLHQ9PnQucmVhZFRtcGxUb2tlbigpKSxmdW5jdGlvbkV4cHJlc3Npb246bmV3IHkoXCJmdW5jdGlvblwiLCEwKSxmdW5jdGlvblN0YXRlbWVudDpuZXcgeShcImZ1bmN0aW9uXCIsITEpfTtuLnBhcmVuUi51cGRhdGVDb250ZXh0PW4uYnJhY2VSLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24oKXtpZigxPT09dGhpcy5zdGF0ZS5jb250ZXh0Lmxlbmd0aClyZXR1cm4gdm9pZCh0aGlzLnN0YXRlLmV4cHJBbGxvd2VkPSEwKTtsZXQgdD10aGlzLnN0YXRlLmNvbnRleHQucG9wKCk7dD09PXguYnJhY2VTdGF0ZW1lbnQmJlwiZnVuY3Rpb25cIj09PXRoaXMuY3VyQ29udGV4dCgpLnRva2VuJiYodD10aGlzLnN0YXRlLmNvbnRleHQucG9wKCkpLHRoaXMuc3RhdGUuZXhwckFsbG93ZWQ9IXQuaXNFeHByfSxuLm5hbWUudXBkYXRlQ29udGV4dD1mdW5jdGlvbih0KXtsZXQgZT0hMTt0IT09bi5kb3QmJihcIm9mXCI9PT10aGlzLnN0YXRlLnZhbHVlJiYhdGhpcy5zdGF0ZS5leHByQWxsb3dlZHx8XCJ5aWVsZFwiPT09dGhpcy5zdGF0ZS52YWx1ZSYmdGhpcy5wcm9kUGFyYW0uaGFzWWllbGQpJiYoZT0hMCksdGhpcy5zdGF0ZS5leHByQWxsb3dlZD1lLHRoaXMuc3RhdGUuaXNJdGVyYXRvciYmKHRoaXMuc3RhdGUuaXNJdGVyYXRvcj0hMSl9LG4uYnJhY2VMLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24odCl7dGhpcy5zdGF0ZS5jb250ZXh0LnB1c2godGhpcy5icmFjZUlzQmxvY2sodCk/eC5icmFjZVN0YXRlbWVudDp4LmJyYWNlRXhwcmVzc2lvbiksdGhpcy5zdGF0ZS5leHByQWxsb3dlZD0hMH0sbi5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dD1mdW5jdGlvbigpe3RoaXMuc3RhdGUuY29udGV4dC5wdXNoKHgudGVtcGxhdGVRdWFzaSksdGhpcy5zdGF0ZS5leHByQWxsb3dlZD0hMH0sbi5wYXJlbkwudXBkYXRlQ29udGV4dD1mdW5jdGlvbih0KXtjb25zdCBlPXQ9PT1uLl9pZnx8dD09PW4uX2Zvcnx8dD09PW4uX3dpdGh8fHQ9PT1uLl93aGlsZTt0aGlzLnN0YXRlLmNvbnRleHQucHVzaChlP3gucGFyZW5TdGF0ZW1lbnQ6eC5wYXJlbkV4cHJlc3Npb24pLHRoaXMuc3RhdGUuZXhwckFsbG93ZWQ9ITB9LG4uaW5jRGVjLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24oKXt9LG4uX2Z1bmN0aW9uLnVwZGF0ZUNvbnRleHQ9bi5fY2xhc3MudXBkYXRlQ29udGV4dD1mdW5jdGlvbih0KXshdC5iZWZvcmVFeHByfHx0PT09bi5zZW1pfHx0PT09bi5fZWxzZXx8dD09PW4uX3JldHVybiYmby50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLHRoaXMuc3RhdGUuc3RhcnQpKXx8KHQ9PT1uLmNvbG9ufHx0PT09bi5icmFjZUwpJiZ0aGlzLmN1ckNvbnRleHQoKT09PXguYl9zdGF0P3RoaXMuc3RhdGUuY29udGV4dC5wdXNoKHguZnVuY3Rpb25TdGF0ZW1lbnQpOnRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHguZnVuY3Rpb25FeHByZXNzaW9uKSx0aGlzLnN0YXRlLmV4cHJBbGxvd2VkPSExfSxuLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKCl7dGhpcy5jdXJDb250ZXh0KCk9PT14LnRlbXBsYXRlP3RoaXMuc3RhdGUuY29udGV4dC5wb3AoKTp0aGlzLnN0YXRlLmNvbnRleHQucHVzaCh4LnRlbXBsYXRlKSx0aGlzLnN0YXRlLmV4cHJBbGxvd2VkPSExfTtsZXQgZz1cIsKqwrXCusOALcOWw5gtw7bDuC3LgcuGLcuRy6Aty6TLrMuuzbAtzbTNts23zbotzb3Nv86GzogtzorOjM6OLc6hzqMtz7XPty3SgdKKLdSv1LEt1ZbVmdWgLdaI15At16rXry3XstigLdmK2a7Zr9mxLduT25Xbpdum267br9u6Ldu827/ckNySLdyv3Y0t3qXesd+KLd+q37Tftd+64KCALeCgleCgmuCgpOCgqOChgC3goZjgoaAt4KGq4KKgLeCitOCiti3go4fgpIQt4KS54KS94KWQ4KWYLeCloeClsS3gpoDgpoUt4KaM4KaP4KaQ4KaTLeCmqOCmqi3gprDgprLgprYt4Ka54Ka94KeO4Kec4Ked4KefLeCnoeCnsOCnseCnvOCohS3gqIrgqI/gqJDgqJMt4Kio4KiqLeCosOCosuCos+CoteCotuCouOCoueCpmS3gqZzgqZ7gqbIt4Km04KqFLeCqjeCqjy3gqpHgqpMt4Kqo4KqqLeCqsOCqsuCqs+CqtS3gqrngqr3gq5Dgq6Dgq6Hgq7ngrIUt4KyM4KyP4KyQ4KyTLeCsqOCsqi3grLDgrLLgrLPgrLUt4Ky54Ky94K2c4K2d4K2fLeCtoeCtseCug+CuhS3grorgro4t4K6Q4K6SLeCuleCumeCumuCunOCunuCun+Cuo+CupOCuqC3grqrgrq4t4K654K+Q4LCFLeCwjOCwji3gsJDgsJIt4LCo4LCqLeCwueCwveCxmC3gsZrgsaDgsaHgsoDgsoUt4LKM4LKOLeCykOCyki3gsqjgsqot4LKz4LK1LeCyueCyveCznuCzoOCzoeCzseCzsuC0hC3gtIzgtI4t4LSQ4LSSLeC0uuC0veC1juC1lC3gtZbgtZ8t4LWh4LW6LeC1v+C2hS3gtpbgtpot4Lax4LazLeC2u+C2veC3gC3gt4bguIEt4Liw4Liy4Liz4LmALeC5huC6geC6guC6hOC6hi3guorguowt4Lqj4Lql4LqnLeC6sOC6suC6s+C6veC7gC3gu4Tgu4bgu5wt4Luf4LyA4L2ALeC9h+C9iS3gvazgvogt4L6M4YCALeGAquGAv+GBkC3hgZXhgZot4YGd4YGh4YGl4YGm4YGuLeGBsOGBtS3hgoHhgo7hgqAt4YOF4YOH4YON4YOQLeGDuuGDvC3hiYjhiYot4YmN4YmQLeGJluGJmOGJmi3hiZ3hiaAt4YqI4YqKLeGKjeGKkC3hirDhirIt4Yq14Yq4LeGKvuGLgOGLgi3hi4Xhi4gt4YuW4YuYLeGMkOGMki3hjJXhjJgt4Y2a4Y6ALeGOj+GOoC3hj7Xhj7gt4Y+94ZCBLeGZrOGZry3hmb/hmoEt4Zqa4ZqgLeGbquGbri3hm7jhnIAt4ZyM4ZyOLeGckeGcoC3hnLHhnYAt4Z2R4Z2gLeGdrOGdri3hnbDhnoAt4Z6z4Z+X4Z+c4aCgLeGhuOGigC3hoqjhoqrhorAt4aO14aSALeGknuGlkC3hpa3hpbAt4aW04aaALeGmq+GmsC3hp4nhqIAt4aiW4aigLeGplOGqp+GshS3hrLPhrYUt4a2L4a6DLeGuoOGuruGur+Guui3hr6XhsIAt4bCj4bGNLeGxj+Gxmi3hsb3hsoAt4bKI4bKQLeGyuuGyvS3hsr/hs6kt4bOs4bOuLeGzs+GzteGztuGzuuG0gC3htr/huIAt4byV4byYLeG8neG8oC3hvYXhvYgt4b2N4b2QLeG9l+G9meG9m+G9neG9ny3hvb3hvoAt4b604b62LeG+vOG+vuG/gi3hv4Thv4Yt4b+M4b+QLeG/k+G/li3hv5vhv6At4b+s4b+yLeG/tOG/ti3hv7zigbHigb/igpAt4oKc4oSC4oSH4oSKLeKEk+KEleKEmC3ihJ3ihKTihKbihKjihKot4oS54oS8LeKEv+KFhS3ihYnihY7ihaAt4oaI4rCALeKwruKwsC3isZ7isaAt4rOk4rOrLeKzruKzsuKzs+K0gC3itKXitKfitK3itLAt4rWn4rWv4raALeK2luK2oC3itqbitqgt4rau4rawLeK2tuK2uC3itr7it4At4reG4reILeK3juK3kC3it5bit5gt4ree44CFLeOAh+OAoS3jgKnjgLEt44C144C4LeOAvOOBgS3jgpbjgpst44Kf44KhLeODuuODvC3jg7/jhIUt44Sv44SxLeOGjuOGoC3jhr/jh7At44e/45CALeS2v+S4gC3pv7zqgIAt6pKM6pOQLeqTveqUgC3qmIzqmJAt6pif6piq6pir6pmALeqZruqZvy3qmp3qmqAt6puv6pyXLeqcn+qcoi3qnojqnost6p6/6p+CLeqfiuqftS3qoIHqoIMt6qCF6qCHLeqgiuqgjC3qoKLqoYAt6qGz6qKCLeqis+qjsi3qo7fqo7vqo73qo77qpIot6qSl6qSwLeqlhuqloC3qpbzqpoQt6qay6qeP6qegLeqnpOqnpi3qp6/qp7ot6qe+6qiALeqoqOqpgC3qqYLqqYQt6qmL6qmgLeqptuqpuuqpvi3qqq/qqrHqqrXqqrbqqrkt6qq96quA6quC6qubLeqrneqroC3qq6rqq7It6qu06qyBLeqshuqsiS3qrI7qrJEt6qyW6qygLeqspuqsqC3qrK7qrLAt6q2a6q2cLeqtqeqtsC3qr6LqsIAt7Z6j7Z6wLe2fhu2fiy3tn7vvpIAt76mt76mwLe+rme+sgC3vrIbvrJMt76yX76yd76yfLe+sqO+sqi3vrLbvrLgt76y876y+762A762B762D762E762GLe+use+vky3vtL3vtZAt77aP77aSLe+3h++3sC3vt7vvubAt77m077m2Le+7vO+8oS3vvLrvvYEt772a772mLe++vu+/gi3vv4fvv4ot77+P77+SLe+/l++/mi3vv5xcIixQPVwi4oCM4oCNwrfMgC3Nr86H0oMt0ofWkS3Wvda/14HXgteE14XXh9iQLdia2Yst2anZsNuWLduc258t26Tbp9uo26ot263bsC3budyR3LAt3Yrepi3esN+ALd+J36st37PfveCgli3goJngoJst4KCj4KClLeCgp+CgqS3goK3goZkt4KGb4KOTLeCjoeCjoy3gpIPgpLot4KS84KS+LeClj+ClkS3gpZfgpaLgpaPgpaYt4KWv4KaBLeCmg+CmvOCmvi3gp4Tgp4fgp4jgp4st4KeN4KeX4Kei4Kej4KemLeCnr+CnvuCogS3gqIPgqLzgqL4t4KmC4KmH4KmI4KmLLeCpjeCpkeCppi3gqbHgqbXgqoEt4KqD4Kq84Kq+LeCrheCrhy3gq4ngq4st4KuN4Kui4Kuj4KumLeCrr+Crui3gq7/grIEt4KyD4Ky84Ky+LeCthOCth+CtiOCtiy3grY3grZUt4K2X4K2i4K2j4K2mLeCtr+CuguCuvi3gr4Lgr4Yt4K+I4K+KLeCvjeCvl+Cvpi3gr6/gsIAt4LCE4LC+LeCxhOCxhi3gsYjgsYot4LGN4LGV4LGW4LGi4LGj4LGmLeCxr+CygS3gsoPgsrzgsr4t4LOE4LOGLeCziOCzii3gs43gs5Xgs5bgs6Lgs6Pgs6Yt4LOv4LSALeC0g+C0u+C0vOC0vi3gtYTgtYYt4LWI4LWKLeC1jeC1l+C1ouC1o+C1pi3gta/gtoEt4LaD4LeK4LePLeC3lOC3luC3mC3gt5/gt6Yt4Lev4Ley4Lez4Lix4Li0LeC4uuC5hy3guY7guZAt4LmZ4Lqx4Lq0LeC6vOC7iC3gu43gu5At4LuZ4LyY4LyZ4LygLeC8qeC8teC8t+C8ueC8vuC8v+C9sS3gvoTgvobgvofgvo0t4L6X4L6ZLeC+vOC/huGAqy3hgL7hgYAt4YGJ4YGWLeGBmeGBni3hgaDhgaIt4YGk4YGnLeGBreGBsS3hgbThgoIt4YKN4YKPLeGCneGNnS3hjZ/hjakt4Y2x4ZySLeGclOGcsi3hnLThnZLhnZPhnbLhnbPhnrQt4Z+T4Z+d4Z+gLeGfqeGgiy3hoI3hoJAt4aCZ4aKp4aSgLeGkq+GksC3hpLvhpYYt4aWP4aeQLeGnmuGoly3hqJvhqZUt4ame4amgLeGpvOGpvy3hqonhqpAt4aqZ4aqwLeGqveGqv+GrgOGsgC3hrIThrLQt4a2E4a2QLeGtmeGtqy3hrbPhroAt4a6C4a6hLeGureGusC3hrrnhr6Yt4a+z4bCkLeGwt+GxgC3hsYnhsZAt4bGZ4bOQLeGzkuGzlC3hs6jhs63hs7Ths7ct4bO54beALeG3ueG3uy3ht7/igL/igYDigZTig5At4oOc4oOh4oOlLeKDsOKzry3is7Hitb/it6At4re/44CqLeOAr+OCmeOCmuqYoC3qmKnqma/qmbQt6pm96pqe6pqf6puw6pux6qCC6qCG6qCL6qCjLeqgp+qgrOqigOqigeqitC3qo4Xqo5At6qOZ6qOgLeqjseqjvy3qpInqpKYt6qSt6qWHLeqlk+qmgC3qpoPqprMt6qeA6qeQLeqnmeqnpeqnsC3qp7nqqKkt6qi26qmD6qmM6qmN6qmQLeqpmeqpuy3qqb3qqrDqqrIt6qq06qq36qq46qq+6qq/6quB6qurLeqrr+qrteqrtuqvoy3qr6rqr6zqr63qr7At6q+576ye77iALe+4j++4oC3vuK/vuLPvuLTvuY0t77mP77yQLe+8me+8v1wiO2NvbnN0IEU9bmV3IFJlZ0V4cChcIltcIitnK1wiXVwiKSxDPW5ldyBSZWdFeHAoXCJbXCIrZytQK1wiXVwiKTtnPVA9bnVsbDtjb25zdCBiPVswLDExLDIsMjUsMiwxOCwyLDEsMiwxNCwzLDEzLDM1LDEyMiw3MCw1MiwyNjgsMjgsNCw0OCw0OCwzMSwxNCwyOSw2LDM3LDExLDI5LDMsMzUsNSw3LDIsNCw0MywxNTcsMTksMzUsNSwzNSw1LDM5LDksNTEsMTU3LDMxMCwxMCwyMSwxMSw3LDE1Myw1LDMsMCwyLDQzLDIsMSw0LDAsMywyMiwxMSwyMiwxMCwzMCw2NiwxOCwyLDEsMTEsMjEsMTEsMjUsNzEsNTUsNywxLDY1LDAsMTYsMywyLDIsMiwyOCw0MywyOCw0LDI4LDM2LDcsMiwyNywyOCw1MywxMSwyMSwxMSwxOCwxNCwxNywxMTEsNzIsNTYsNTAsMTQsNTAsMTQsMzUsMzQ5LDQxLDcsMSw3OSwyOCwxMSwwLDksMjEsMTA3LDIwLDI4LDIyLDEzLDUyLDc2LDQ0LDMzLDI0LDI3LDM1LDMwLDAsMywwLDksMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsMjEsMiwzMSw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDE0LDAsNzIsMjYsMjMwLDQzLDExNyw2MywzMiw3LDMsMCwzLDcsMiwxLDIsMjMsMTYsMCwyLDAsOTUsNywzLDM4LDE3LDAsMiwwLDI5LDAsMTEsMzksOCwwLDIyLDAsMTIsNDUsMjAsMCwzNSw1NiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksMTEzLDYsMiwxLDIsMzcsMjIsMCwyNiw1LDIsMSwyLDMxLDE1LDAsMzI4LDE4LDE5MCwwLDgwLDkyMSwxMDMsMTEwLDE4LDE5NSwyNzQ5LDEwNzAsNDA1MCw1ODIsODYzNCw1NjgsOCwzMCwxMTQsMjksMTksNDcsMTcsMywzMiwyMCw2LDE4LDY4OSw2MywxMjksNzQsNiwwLDY3LDEyLDY1LDEsMiwwLDI5LDYxMzUsOSwxMjM3LDQzLDgsODk1MiwyODYsNTAsMiwxOCwzLDksMzk1LDIzMDksMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDIzNTcsNDQsMTEsNiwxNywwLDM3MCw0MywxMzAxLDE5Niw2MCw2Nyw4LDAsMTIwNSwzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxNywzNSw0MTQ4LDEyLDIyMSwzLDU3NjEsMTUsNzQ3MiwzMTA0LDU0MSwxNTA3LDQ5MzhdLFQ9WzUwOSwwLDIyNywwLDE1MCw0LDI5NCw5LDEzNjgsMiwyLDEsNiwzLDQxLDIsNSwwLDE2NiwxLDU3NCwzLDksOSwzNzAsMSwxNTQsMTAsMTc2LDIsNTQsMTQsMzIsOSwxNiwzLDQ2LDEwLDU0LDksNywyLDM3LDEzLDIsOSw2LDEsNDUsMCwxMywyLDQ5LDEzLDksMywyLDExLDgzLDExLDcsMCwxNjEsMTEsNiw5LDcsMyw1NiwxLDIsNiwzLDEsMywyLDEwLDAsMTEsMSwzLDYsNCw0LDE5MywxNywxMCw5LDUsMCw4MiwxOSwxMyw5LDIxNCw2LDMsOCwyOCwxLDgzLDE2LDE2LDksODIsMTIsOSw5LDg0LDE0LDUsOSwyNDMsMTQsMTY2LDksNzEsNSwyLDEsMywzLDIsMCwyLDEsMTMsOSwxMjAsNiwzLDYsNCwwLDI5LDksNDEsNiwyLDMsOSwwLDEwLDEwLDQ3LDE1LDQwNiw3LDIsNywxNyw5LDU3LDIxLDIsMTMsMTIzLDUsNCwwLDIsMSwyLDYsMiwwLDksOSw0OSw0LDIsMSwyLDQsOSw5LDMzMCwzLDE5MzA2LDksMTM1LDQsNjAsNiwyNiw5LDEwMTQsMCwyLDU0LDgsMyw4MiwwLDEyLDEsMTk2MjgsMSw1MzE5LDQsNCw1LDksNywzLDYsMzEsMywxNDksMiwxNDE4LDQ5LDUxMyw1NCw1LDQ5LDksMCwxNSwwLDIzLDQsMiwxNCwxMzYxLDYsMiwxNiwzLDYsMiwxLDIsNCwyNjIsNiwxMCw5LDQxOSwxMywxNDk1LDYsMTEwLDYsNiw5LDQ3NTksOSw3ODc3MTksMjM5XTtmdW5jdGlvbiBBKHQsZSl7bGV0IHM9NjU1MzY7Zm9yKGxldCBpPTAscj1lLmxlbmd0aDtpPHI7aSs9Mil7aWYocys9ZVtpXSxzPnQpcmV0dXJuITE7aWYocys9ZVtpKzFdLHM+PXQpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gdyh0KXtyZXR1cm4gdDw2NT8zNj09PXQ6dDw9OTB8fCh0PDk3Pzk1PT09dDp0PD0xMjJ8fCh0PD02NTUzNT90Pj0xNzAmJkUudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKHQpKTpBKHQsYikpKX1mdW5jdGlvbiBTKHQpe3JldHVybiB0PDQ4PzM2PT09dDp0PDU4fHwhKHQ8NjUpJiYodDw9OTB8fCh0PDk3Pzk1PT09dDp0PD0xMjJ8fCh0PD02NTUzNT90Pj0xNzAmJkMudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKHQpKTpBKHQsYil8fEEodCxUKSkpKX1jb25zdCBOPVtcImltcGxlbWVudHNcIixcImludGVyZmFjZVwiLFwibGV0XCIsXCJwYWNrYWdlXCIsXCJwcml2YXRlXCIsXCJwcm90ZWN0ZWRcIixcInB1YmxpY1wiLFwic3RhdGljXCIsXCJ5aWVsZFwiXSxGPVtcImV2YWxcIixcImFyZ3VtZW50c1wiXSxrPW5ldyBTZXQoW1wiYnJlYWtcIixcImNhc2VcIixcImNhdGNoXCIsXCJjb250aW51ZVwiLFwiZGVidWdnZXJcIixcImRlZmF1bHRcIixcImRvXCIsXCJlbHNlXCIsXCJmaW5hbGx5XCIsXCJmb3JcIixcImZ1bmN0aW9uXCIsXCJpZlwiLFwicmV0dXJuXCIsXCJzd2l0Y2hcIixcInRocm93XCIsXCJ0cnlcIixcInZhclwiLFwiY29uc3RcIixcIndoaWxlXCIsXCJ3aXRoXCIsXCJuZXdcIixcInRoaXNcIixcInN1cGVyXCIsXCJjbGFzc1wiLFwiZXh0ZW5kc1wiLFwiZXhwb3J0XCIsXCJpbXBvcnRcIixcIm51bGxcIixcInRydWVcIixcImZhbHNlXCIsXCJpblwiLFwiaW5zdGFuY2VvZlwiLFwidHlwZW9mXCIsXCJ2b2lkXCIsXCJkZWxldGVcIl0pLEk9bmV3IFNldChOKSx2PW5ldyBTZXQoRik7ZnVuY3Rpb24gTCh0LGUpe3JldHVybiBlJiZcImF3YWl0XCI9PT10fHxcImVudW1cIj09PXR9ZnVuY3Rpb24gQih0LGUpe3JldHVybiBMKHQsZSl8fEkuaGFzKHQpfWZ1bmN0aW9uIE0odCl7cmV0dXJuIHYuaGFzKHQpfWZ1bmN0aW9uIE8odCxlKXtyZXR1cm4gQih0LGUpfHxNKHQpfWNvbnN0IFI9L15pbihzdGFuY2VvZik/JC87Y29uc3QgXz1uZXcgU2V0KFtcIl9cIixcImFueVwiLFwiYm9vbFwiLFwiYm9vbGVhblwiLFwiZW1wdHlcIixcImV4dGVuZHNcIixcImZhbHNlXCIsXCJpbnRlcmZhY2VcIixcIm1peGVkXCIsXCJudWxsXCIsXCJudW1iZXJcIixcInN0YXRpY1wiLFwic3RyaW5nXCIsXCJ0cnVlXCIsXCJ0eXBlb2ZcIixcInZvaWRcIl0pLGo9T2JqZWN0LmZyZWV6ZSh7QW1iaWd1b3VzQ29uZGl0aW9uYWxBcnJvdzpcIkFtYmlndW91cyBleHByZXNzaW9uOiB3cmFwIHRoZSBhcnJvdyBmdW5jdGlvbnMgaW4gcGFyZW50aGVzZXMgdG8gZGlzYW1iaWd1YXRlLlwiLEFtYmlndW91c0RlY2xhcmVNb2R1bGVLaW5kOlwiRm91bmQgYm90aCBgZGVjbGFyZSBtb2R1bGUuZXhwb3J0c2AgYW5kIGBkZWNsYXJlIGV4cG9ydGAgaW4gdGhlIHNhbWUgbW9kdWxlLiBNb2R1bGVzIGNhbiBvbmx5IGhhdmUgMSBzaW5jZSB0aGV5IGFyZSBlaXRoZXIgYW4gRVMgbW9kdWxlIG9yIHRoZXkgYXJlIGEgQ29tbW9uSlMgbW9kdWxlXCIsQXNzaWduUmVzZXJ2ZWRUeXBlOlwiQ2Fubm90IG92ZXJ3cml0ZSByZXNlcnZlZCB0eXBlICUwXCIsRGVjbGFyZUNsYXNzRWxlbWVudDpcIlRoZSBgZGVjbGFyZWAgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGNsYXNzIGZpZWxkcy5cIixEZWNsYXJlQ2xhc3NGaWVsZEluaXRpYWxpemVyOlwiSW5pdGlhbGl6ZXJzIGFyZSBub3QgYWxsb3dlZCBpbiBmaWVsZHMgd2l0aCB0aGUgYGRlY2xhcmVgIG1vZGlmaWVyLlwiLER1cGxpY2F0ZURlY2xhcmVNb2R1bGVFeHBvcnRzOlwiRHVwbGljYXRlIGBkZWNsYXJlIG1vZHVsZS5leHBvcnRzYCBzdGF0ZW1lbnRcIixFbnVtQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkOlwiQm9vbGVhbiBlbnVtIG1lbWJlcnMgbmVlZCB0byBiZSBpbml0aWFsaXplZC4gVXNlIGVpdGhlciBgJTAgPSB0cnVlLGAgb3IgYCUwID0gZmFsc2UsYCBpbiBlbnVtIGAlMWAuXCIsRW51bUR1cGxpY2F0ZU1lbWJlck5hbWU6XCJFbnVtIG1lbWJlciBuYW1lcyBuZWVkIHRvIGJlIHVuaXF1ZSwgYnV0IHRoZSBuYW1lIGAlMGAgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBpbiBlbnVtIGAlMWAuXCIsRW51bUluY29uc2lzdGVudE1lbWJlclZhbHVlczpcIkVudW0gYCUwYCBoYXMgaW5jb25zaXN0ZW50IG1lbWJlciBpbml0aWFsaXplcnMuIEVpdGhlciB1c2Ugbm8gaW5pdGlhbGl6ZXJzLCBvciBjb25zaXN0ZW50bHkgdXNlIGxpdGVyYWxzIChlaXRoZXIgYm9vbGVhbnMsIG51bWJlcnMsIG9yIHN0cmluZ3MpIGZvciBhbGwgbWVtYmVyIGluaXRpYWxpemVycy5cIixFbnVtSW52YWxpZEV4cGxpY2l0VHlwZTpcIkVudW0gdHlwZSBgJTFgIGlzIG5vdCB2YWxpZC4gVXNlIG9uZSBvZiBgYm9vbGVhbmAsIGBudW1iZXJgLCBgc3RyaW5nYCwgb3IgYHN5bWJvbGAgaW4gZW51bSBgJTBgLlwiLEVudW1JbnZhbGlkRXhwbGljaXRUeXBlVW5rbm93blN1cHBsaWVkOlwiU3VwcGxpZWQgZW51bSB0eXBlIGlzIG5vdCB2YWxpZC4gVXNlIG9uZSBvZiBgYm9vbGVhbmAsIGBudW1iZXJgLCBgc3RyaW5nYCwgb3IgYHN5bWJvbGAgaW4gZW51bSBgJTBgLlwiLEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZTpcIkVudW0gYCUwYCBoYXMgdHlwZSBgJTJgLCBzbyB0aGUgaW5pdGlhbGl6ZXIgb2YgYCUxYCBuZWVkcyB0byBiZSBhICUyIGxpdGVyYWwuXCIsRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGU6XCJTeW1ib2wgZW51bSBtZW1iZXJzIGNhbm5vdCBiZSBpbml0aWFsaXplZC4gVXNlIGAlMSxgIGluIGVudW0gYCUwYC5cIixFbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyVW5rbm93blR5cGU6XCJUaGUgZW51bSBtZW1iZXIgaW5pdGlhbGl6ZXIgZm9yIGAlMWAgbmVlZHMgdG8gYmUgYSBsaXRlcmFsIChlaXRoZXIgYSBib29sZWFuLCBudW1iZXIsIG9yIHN0cmluZykgaW4gZW51bSBgJTBgLlwiLEVudW1JbnZhbGlkTWVtYmVyTmFtZTpcIkVudW0gbWVtYmVyIG5hbWVzIGNhbm5vdCBzdGFydCB3aXRoIGxvd2VyY2FzZSAnYScgdGhyb3VnaCAneicuIEluc3RlYWQgb2YgdXNpbmcgYCUwYCwgY29uc2lkZXIgdXNpbmcgYCUxYCwgaW4gZW51bSBgJTJgLlwiLEVudW1OdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZDpcIk51bWJlciBlbnVtIG1lbWJlcnMgbmVlZCB0byBiZSBpbml0aWFsaXplZCwgZS5nLiBgJTEgPSAxYCBpbiBlbnVtIGAlMGAuXCIsRW51bVN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGFpbGl6ZWQ6XCJTdHJpbmcgZW51bSBtZW1iZXJzIG5lZWQgdG8gY29uc2lzdGVudGx5IGVpdGhlciBhbGwgdXNlIGluaXRpYWxpemVycywgb3IgdXNlIG5vIGluaXRpYWxpemVycywgaW4gZW51bSBgJTBgLlwiLEltcG9ydFR5cGVTaG9ydGhhbmRPbmx5SW5QdXJlSW1wb3J0OlwiVGhlIGB0eXBlYCBhbmQgYHR5cGVvZmAga2V5d29yZHMgb24gbmFtZWQgaW1wb3J0cyBjYW4gb25seSBiZSB1c2VkIG9uIHJlZ3VsYXIgYGltcG9ydGAgc3RhdGVtZW50cy4gSXQgY2Fubm90IGJlIHVzZWQgd2l0aCBgaW1wb3J0IHR5cGVgIG9yIGBpbXBvcnQgdHlwZW9mYCBzdGF0ZW1lbnRzXCIsSW5leGFjdEluc2lkZUV4YWN0OlwiRXhwbGljaXQgaW5leGFjdCBzeW50YXggY2Fubm90IGFwcGVhciBpbnNpZGUgYW4gZXhwbGljaXQgZXhhY3Qgb2JqZWN0IHR5cGVcIixJbmV4YWN0SW5zaWRlTm9uT2JqZWN0OlwiRXhwbGljaXQgaW5leGFjdCBzeW50YXggY2Fubm90IGFwcGVhciBpbiBjbGFzcyBvciBpbnRlcmZhY2UgZGVmaW5pdGlvbnNcIixJbmV4YWN0VmFyaWFuY2U6XCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBjYW5ub3QgaGF2ZSB2YXJpYW5jZVwiLEludmFsaWROb25UeXBlSW1wb3J0SW5EZWNsYXJlTW9kdWxlOlwiSW1wb3J0cyB3aXRoaW4gYSBgZGVjbGFyZSBtb2R1bGVgIGJvZHkgbXVzdCBhbHdheXMgYmUgYGltcG9ydCB0eXBlYCBvciBgaW1wb3J0IHR5cGVvZmBcIixNaXNzaW5nVHlwZVBhcmFtRGVmYXVsdDpcIlR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9uIG5lZWRzIGEgZGVmYXVsdCwgc2luY2UgYSBwcmVjZWRpbmcgdHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb24gaGFzIGEgZGVmYXVsdC5cIixOZXN0ZWREZWNsYXJlTW9kdWxlOlwiYGRlY2xhcmUgbW9kdWxlYCBjYW5ub3QgYmUgdXNlZCBpbnNpZGUgYW5vdGhlciBgZGVjbGFyZSBtb2R1bGVgXCIsTmVzdGVkRmxvd0NvbW1lbnQ6XCJDYW5ub3QgaGF2ZSBhIGZsb3cgY29tbWVudCBpbnNpZGUgYW5vdGhlciBmbG93IGNvbW1lbnRcIixPcHRpb25hbEJpbmRpbmdQYXR0ZXJuOlwiQSBiaW5kaW5nIHBhdHRlcm4gcGFyYW1ldGVyIGNhbm5vdCBiZSBvcHRpb25hbCBpbiBhbiBpbXBsZW1lbnRhdGlvbiBzaWduYXR1cmUuXCIsU3ByZWFkVmFyaWFuY2U6XCJTcHJlYWQgcHJvcGVydGllcyBjYW5ub3QgaGF2ZSB2YXJpYW5jZVwiLFR5cGVCZWZvcmVJbml0aWFsaXplcjpcIlR5cGUgYW5ub3RhdGlvbnMgbXVzdCBjb21lIGJlZm9yZSBkZWZhdWx0IGFzc2lnbm1lbnRzLCBlLmcuIGluc3RlYWQgb2YgYGFnZSA9IDI1OiBudW1iZXJgIHVzZSBgYWdlOiBudW1iZXIgPSAyNWBcIixUeXBlQ2FzdEluUGF0dGVybjpcIlRoZSB0eXBlIGNhc3QgZXhwcmVzc2lvbiBpcyBleHBlY3RlZCB0byBiZSB3cmFwcGVkIHdpdGggcGFyZW50aGVzaXNcIixVbmV4cGVjdGVkRXhwbGljaXRJbmV4YWN0SW5PYmplY3Q6XCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBtdXN0IGFwcGVhciBhdCB0aGUgZW5kIG9mIGFuIGluZXhhY3Qgb2JqZWN0XCIsVW5leHBlY3RlZFJlc2VydmVkVHlwZTpcIlVuZXhwZWN0ZWQgcmVzZXJ2ZWQgdHlwZSAlMFwiLFVuZXhwZWN0ZWRSZXNlcnZlZFVuZGVyc2NvcmU6XCJgX2AgaXMgb25seSBhbGxvd2VkIGFzIGEgdHlwZSBhcmd1bWVudCB0byBjYWxsIG9yIG5ld1wiLFVuZXhwZWN0ZWRTcGFjZUJldHdlZW5Nb2R1bG9DaGVja3M6XCJTcGFjZXMgYmV0d2VlbiBgJWAgYW5kIGBjaGVja3NgIGFyZSBub3QgYWxsb3dlZCBoZXJlLlwiLFVuZXhwZWN0ZWRTcHJlYWRUeXBlOlwiU3ByZWFkIG9wZXJhdG9yIGNhbm5vdCBhcHBlYXIgaW4gY2xhc3Mgb3IgaW50ZXJmYWNlIGRlZmluaXRpb25zXCIsVW5leHBlY3RlZFN1YnRyYWN0aW9uT3BlcmFuZDonVW5leHBlY3RlZCB0b2tlbiwgZXhwZWN0ZWQgXCJudW1iZXJcIiBvciBcImJpZ2ludFwiJyxVbmV4cGVjdGVkVG9rZW5BZnRlclR5cGVQYXJhbWV0ZXI6XCJFeHBlY3RlZCBhbiBhcnJvdyBmdW5jdGlvbiBhZnRlciB0aGlzIHR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9uXCIsVW5zdXBwb3J0ZWREZWNsYXJlRXhwb3J0S2luZDpcImBkZWNsYXJlIGV4cG9ydCAlMGAgaXMgbm90IHN1cHBvcnRlZC4gVXNlIGAlMWAgaW5zdGVhZFwiLFVuc3VwcG9ydGVkU3RhdGVtZW50SW5EZWNsYXJlTW9kdWxlOlwiT25seSBkZWNsYXJlcyBhbmQgdHlwZSBpbXBvcnRzIGFyZSBhbGxvd2VkIGluc2lkZSBkZWNsYXJlIG1vZHVsZVwiLFVudGVybWluYXRlZEZsb3dDb21tZW50OlwiVW50ZXJtaW5hdGVkIGZsb3ctY29tbWVudFwifSk7ZnVuY3Rpb24gVSh0KXtyZXR1cm5cInR5cGVcIj09PXQuaW1wb3J0S2luZHx8XCJ0eXBlb2ZcIj09PXQuaW1wb3J0S2luZH1mdW5jdGlvbiBxKHQpe3JldHVybih0LnR5cGU9PT1uLm5hbWV8fCEhdC50eXBlLmtleXdvcmQpJiZcImZyb21cIiE9PXQudmFsdWV9Y29uc3QgVj17Y29uc3Q6XCJkZWNsYXJlIGV4cG9ydCB2YXJcIixsZXQ6XCJkZWNsYXJlIGV4cG9ydCB2YXJcIix0eXBlOlwiZXhwb3J0IHR5cGVcIixpbnRlcmZhY2U6XCJleHBvcnQgaW50ZXJmYWNlXCJ9O2NvbnN0IHo9L1xcKj9cXHMqQCgoPzpubyk/ZmxvdylcXGIvO2NvbnN0IEg9e3F1b3Q6J1wiJyxhbXA6XCImXCIsYXBvczpcIidcIixsdDpcIjxcIixndDpcIj5cIixuYnNwOlwiwqBcIixpZXhjbDpcIsKhXCIsY2VudDpcIsKiXCIscG91bmQ6XCLCo1wiLGN1cnJlbjpcIsKkXCIseWVuOlwiwqVcIixicnZiYXI6XCLCplwiLHNlY3Q6XCLCp1wiLHVtbDpcIsKoXCIsY29weTpcIsKpXCIsb3JkZjpcIsKqXCIsbGFxdW86XCLCq1wiLG5vdDpcIsKsXCIsc2h5Olwiwq1cIixyZWc6XCLCrlwiLG1hY3I6XCLCr1wiLGRlZzpcIsKwXCIscGx1c21uOlwiwrFcIixzdXAyOlwiwrJcIixzdXAzOlwiwrNcIixhY3V0ZTpcIsK0XCIsbWljcm86XCLCtVwiLHBhcmE6XCLCtlwiLG1pZGRvdDpcIsK3XCIsY2VkaWw6XCLCuFwiLHN1cDE6XCLCuVwiLG9yZG06XCLCulwiLHJhcXVvOlwiwrtcIixmcmFjMTQ6XCLCvFwiLGZyYWMxMjpcIsK9XCIsZnJhYzM0Olwiwr5cIixpcXVlc3Q6XCLCv1wiLEFncmF2ZTpcIsOAXCIsQWFjdXRlOlwiw4FcIixBY2lyYzpcIsOCXCIsQXRpbGRlOlwiw4NcIixBdW1sOlwiw4RcIixBcmluZzpcIsOFXCIsQUVsaWc6XCLDhlwiLENjZWRpbDpcIsOHXCIsRWdyYXZlOlwiw4hcIixFYWN1dGU6XCLDiVwiLEVjaXJjOlwiw4pcIixFdW1sOlwiw4tcIixJZ3JhdmU6XCLDjFwiLElhY3V0ZTpcIsONXCIsSWNpcmM6XCLDjlwiLEl1bWw6XCLDj1wiLEVUSDpcIsOQXCIsTnRpbGRlOlwiw5FcIixPZ3JhdmU6XCLDklwiLE9hY3V0ZTpcIsOTXCIsT2NpcmM6XCLDlFwiLE90aWxkZTpcIsOVXCIsT3VtbDpcIsOWXCIsdGltZXM6XCLDl1wiLE9zbGFzaDpcIsOYXCIsVWdyYXZlOlwiw5lcIixVYWN1dGU6XCLDmlwiLFVjaXJjOlwiw5tcIixVdW1sOlwiw5xcIixZYWN1dGU6XCLDnVwiLFRIT1JOOlwiw55cIixzemxpZzpcIsOfXCIsYWdyYXZlOlwiw6BcIixhYWN1dGU6XCLDoVwiLGFjaXJjOlwiw6JcIixhdGlsZGU6XCLDo1wiLGF1bWw6XCLDpFwiLGFyaW5nOlwiw6VcIixhZWxpZzpcIsOmXCIsY2NlZGlsOlwiw6dcIixlZ3JhdmU6XCLDqFwiLGVhY3V0ZTpcIsOpXCIsZWNpcmM6XCLDqlwiLGV1bWw6XCLDq1wiLGlncmF2ZTpcIsOsXCIsaWFjdXRlOlwiw61cIixpY2lyYzpcIsOuXCIsaXVtbDpcIsOvXCIsZXRoOlwiw7BcIixudGlsZGU6XCLDsVwiLG9ncmF2ZTpcIsOyXCIsb2FjdXRlOlwiw7NcIixvY2lyYzpcIsO0XCIsb3RpbGRlOlwiw7VcIixvdW1sOlwiw7ZcIixkaXZpZGU6XCLDt1wiLG9zbGFzaDpcIsO4XCIsdWdyYXZlOlwiw7lcIix1YWN1dGU6XCLDulwiLHVjaXJjOlwiw7tcIix1dW1sOlwiw7xcIix5YWN1dGU6XCLDvVwiLHRob3JuOlwiw75cIix5dW1sOlwiw79cIixPRWxpZzpcIsWSXCIsb2VsaWc6XCLFk1wiLFNjYXJvbjpcIsWgXCIsc2Nhcm9uOlwixaFcIixZdW1sOlwixbhcIixmbm9mOlwixpJcIixjaXJjOlwiy4ZcIix0aWxkZTpcIsucXCIsQWxwaGE6XCLOkVwiLEJldGE6XCLOklwiLEdhbW1hOlwizpNcIixEZWx0YTpcIs6UXCIsRXBzaWxvbjpcIs6VXCIsWmV0YTpcIs6WXCIsRXRhOlwizpdcIixUaGV0YTpcIs6YXCIsSW90YTpcIs6ZXCIsS2FwcGE6XCLOmlwiLExhbWJkYTpcIs6bXCIsTXU6XCLOnFwiLE51Olwizp1cIixYaTpcIs6eXCIsT21pY3JvbjpcIs6fXCIsUGk6XCLOoFwiLFJobzpcIs6hXCIsU2lnbWE6XCLOo1wiLFRhdTpcIs6kXCIsVXBzaWxvbjpcIs6lXCIsUGhpOlwizqZcIixDaGk6XCLOp1wiLFBzaTpcIs6oXCIsT21lZ2E6XCLOqVwiLGFscGhhOlwizrFcIixiZXRhOlwizrJcIixnYW1tYTpcIs6zXCIsZGVsdGE6XCLOtFwiLGVwc2lsb246XCLOtVwiLHpldGE6XCLOtlwiLGV0YTpcIs63XCIsdGhldGE6XCLOuFwiLGlvdGE6XCLOuVwiLGthcHBhOlwizrpcIixsYW1iZGE6XCLOu1wiLG11OlwizrxcIixudTpcIs69XCIseGk6XCLOvlwiLG9taWNyb246XCLOv1wiLHBpOlwiz4BcIixyaG86XCLPgVwiLHNpZ21hZjpcIs+CXCIsc2lnbWE6XCLPg1wiLHRhdTpcIs+EXCIsdXBzaWxvbjpcIs+FXCIscGhpOlwiz4ZcIixjaGk6XCLPh1wiLHBzaTpcIs+IXCIsb21lZ2E6XCLPiVwiLHRoZXRhc3ltOlwiz5FcIix1cHNpaDpcIs+SXCIscGl2Olwiz5ZcIixlbnNwOlwi4oCCXCIsZW1zcDpcIuKAg1wiLHRoaW5zcDpcIuKAiVwiLHp3bmo6XCLigIxcIix6d2o6XCLigI1cIixscm06XCLigI5cIixybG06XCLigI9cIixuZGFzaDpcIuKAk1wiLG1kYXNoOlwi4oCUXCIsbHNxdW86XCLigJhcIixyc3F1bzpcIuKAmVwiLHNicXVvOlwi4oCaXCIsbGRxdW86XCLigJxcIixyZHF1bzpcIuKAnVwiLGJkcXVvOlwi4oCeXCIsZGFnZ2VyOlwi4oCgXCIsRGFnZ2VyOlwi4oChXCIsYnVsbDpcIuKAolwiLGhlbGxpcDpcIuKAplwiLHBlcm1pbDpcIuKAsFwiLHByaW1lOlwi4oCyXCIsUHJpbWU6XCLigLNcIixsc2FxdW86XCLigLlcIixyc2FxdW86XCLigLpcIixvbGluZTpcIuKAvlwiLGZyYXNsOlwi4oGEXCIsZXVybzpcIuKCrFwiLGltYWdlOlwi4oSRXCIsd2VpZXJwOlwi4oSYXCIscmVhbDpcIuKEnFwiLHRyYWRlOlwi4oSiXCIsYWxlZnN5bTpcIuKEtVwiLGxhcnI6XCLihpBcIix1YXJyOlwi4oaRXCIscmFycjpcIuKGklwiLGRhcnI6XCLihpNcIixoYXJyOlwi4oaUXCIsY3JhcnI6XCLihrVcIixsQXJyOlwi4oeQXCIsdUFycjpcIuKHkVwiLHJBcnI6XCLih5JcIixkQXJyOlwi4oeTXCIsaEFycjpcIuKHlFwiLGZvcmFsbDpcIuKIgFwiLHBhcnQ6XCLiiIJcIixleGlzdDpcIuKIg1wiLGVtcHR5Olwi4oiFXCIsbmFibGE6XCLiiIdcIixpc2luOlwi4oiIXCIsbm90aW46XCLiiIlcIixuaTpcIuKIi1wiLHByb2Q6XCLiiI9cIixzdW06XCLiiJFcIixtaW51czpcIuKIklwiLGxvd2FzdDpcIuKIl1wiLHJhZGljOlwi4oiaXCIscHJvcDpcIuKInVwiLGluZmluOlwi4oieXCIsYW5nOlwi4oigXCIsYW5kOlwi4oinXCIsb3I6XCLiiKhcIixjYXA6XCLiiKlcIixjdXA6XCLiiKpcIixpbnQ6XCLiiKtcIix0aGVyZTQ6XCLiiLRcIixzaW06XCLiiLxcIixjb25nOlwi4omFXCIsYXN5bXA6XCLiiYhcIixuZTpcIuKJoFwiLGVxdWl2Olwi4omhXCIsbGU6XCLiiaRcIixnZTpcIuKJpVwiLHN1YjpcIuKKglwiLHN1cDpcIuKKg1wiLG5zdWI6XCLiioRcIixzdWJlOlwi4oqGXCIsc3VwZTpcIuKKh1wiLG9wbHVzOlwi4oqVXCIsb3RpbWVzOlwi4oqXXCIscGVycDpcIuKKpVwiLHNkb3Q6XCLii4VcIixsY2VpbDpcIuKMiFwiLHJjZWlsOlwi4oyJXCIsbGZsb29yOlwi4oyKXCIscmZsb29yOlwi4oyLXCIsbGFuZzpcIuKMqVwiLHJhbmc6XCLijKpcIixsb3o6XCLil4pcIixzcGFkZXM6XCLimaBcIixjbHViczpcIuKZo1wiLGhlYXJ0czpcIuKZpVwiLGRpYW1zOlwi4pmmXCJ9LFc9L15bXFxkYS1mQS1GXSskLyxLPS9eXFxkKyQvLEo9T2JqZWN0LmZyZWV6ZSh7QXR0cmlidXRlSXNFbXB0eTpcIkpTWCBhdHRyaWJ1dGVzIG11c3Qgb25seSBiZSBhc3NpZ25lZCBhIG5vbi1lbXB0eSBleHByZXNzaW9uXCIsTWlzc2luZ0Nsb3NpbmdUYWdGcmFnbWVudDpcIkV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciA8PlwiLE1pc3NpbmdDbG9zaW5nVGFnRWxlbWVudDpcIkV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciA8JTA+XCIsVW5zdXBwb3J0ZWRKc3hWYWx1ZTpcIkpTWCB2YWx1ZSBzaG91bGQgYmUgZWl0aGVyIGFuIGV4cHJlc3Npb24gb3IgYSBxdW90ZWQgSlNYIHRleHRcIixVbnRlcm1pbmF0ZWRKc3hDb250ZW50OlwiVW50ZXJtaW5hdGVkIEpTWCBjb250ZW50c1wiLFVud3JhcHBlZEFkamFjZW50SlNYRWxlbWVudHM6XCJBZGphY2VudCBKU1ggZWxlbWVudHMgbXVzdCBiZSB3cmFwcGVkIGluIGFuIGVuY2xvc2luZyB0YWcuIERpZCB5b3Ugd2FudCBhIEpTWCBmcmFnbWVudCA8Pi4uLjwvPj9cIn0pO2Z1bmN0aW9uIFgodCl7cmV0dXJuISF0JiYoXCJKU1hPcGVuaW5nRnJhZ21lbnRcIj09PXQudHlwZXx8XCJKU1hDbG9zaW5nRnJhZ21lbnRcIj09PXQudHlwZSl9ZnVuY3Rpb24gRyh0KXtpZihcIkpTWElkZW50aWZpZXJcIj09PXQudHlwZSlyZXR1cm4gdC5uYW1lO2lmKFwiSlNYTmFtZXNwYWNlZE5hbWVcIj09PXQudHlwZSlyZXR1cm4gdC5uYW1lc3BhY2UubmFtZStcIjpcIit0Lm5hbWUubmFtZTtpZihcIkpTWE1lbWJlckV4cHJlc3Npb25cIj09PXQudHlwZSlyZXR1cm4gRyh0Lm9iamVjdCkrXCIuXCIrRyh0LnByb3BlcnR5KTt0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGhhZCB1bmV4cGVjdGVkIHR5cGU6IFwiK3QudHlwZSl9eC5qX29UYWc9bmV3IHkoXCI8dGFnXCIsITEpLHgual9jVGFnPW5ldyB5KFwiPC90YWdcIiwhMSkseC5qX2V4cHI9bmV3IHkoXCI8dGFnPi4uLjwvdGFnPlwiLCEwLCEwKSxuLmpzeE5hbWU9bmV3IHMoXCJqc3hOYW1lXCIpLG4uanN4VGV4dD1uZXcgcyhcImpzeFRleHRcIix7YmVmb3JlRXhwcjohMH0pLG4uanN4VGFnU3RhcnQ9bmV3IHMoXCJqc3hUYWdTdGFydFwiLHtzdGFydHNFeHByOiEwfSksbi5qc3hUYWdFbmQ9bmV3IHMoXCJqc3hUYWdFbmRcIiksbi5qc3hUYWdTdGFydC51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKCl7dGhpcy5zdGF0ZS5jb250ZXh0LnB1c2goeC5qX2V4cHIpLHRoaXMuc3RhdGUuY29udGV4dC5wdXNoKHgual9vVGFnKSx0aGlzLnN0YXRlLmV4cHJBbGxvd2VkPSExfSxuLmpzeFRhZ0VuZC51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS5jb250ZXh0LnBvcCgpO2U9PT14Lmpfb1RhZyYmdD09PW4uc2xhc2h8fGU9PT14LmpfY1RhZz8odGhpcy5zdGF0ZS5jb250ZXh0LnBvcCgpLHRoaXMuc3RhdGUuZXhwckFsbG93ZWQ9dGhpcy5jdXJDb250ZXh0KCk9PT14LmpfZXhwcik6dGhpcy5zdGF0ZS5leHByQWxsb3dlZD0hMH07Y2xhc3MgUXtjb25zdHJ1Y3Rvcih0KXt0aGlzLnZhcj1bXSx0aGlzLmxleGljYWw9W10sdGhpcy5mdW5jdGlvbnM9W10sdGhpcy5mbGFncz10fX1jbGFzcyBZe2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5zY29wZVN0YWNrPVtdLHRoaXMudW5kZWZpbmVkRXhwb3J0cz1uZXcgTWFwLHRoaXMudW5kZWZpbmVkUHJpdmF0ZU5hbWVzPW5ldyBNYXAsdGhpcy5yYWlzZT10LHRoaXMuaW5Nb2R1bGU9ZX1nZXQgaW5GdW5jdGlvbigpe3JldHVybigyJnRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MpPjB9Z2V0IGFsbG93U3VwZXIoKXtyZXR1cm4oMTYmdGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MpPjB9Z2V0IGFsbG93RGlyZWN0U3VwZXIoKXtyZXR1cm4oMzImdGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MpPjB9Z2V0IGluQ2xhc3MoKXtyZXR1cm4oNjQmdGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuZmxhZ3MpPjB9Z2V0IGluTm9uQXJyb3dGdW5jdGlvbigpe3JldHVybigyJnRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzKT4wfWdldCB0cmVhdEZ1bmN0aW9uc0FzVmFyKCl7cmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSl9Y3JlYXRlU2NvcGUodCl7cmV0dXJuIG5ldyBRKHQpfWVudGVyKHQpe3RoaXMuc2NvcGVTdGFjay5wdXNoKHRoaXMuY3JlYXRlU2NvcGUodCkpfWV4aXQoKXt0aGlzLnNjb3BlU3RhY2sucG9wKCl9dHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodCl7cmV0dXJuISEoMiZ0LmZsYWdzfHwhdGhpcy5pbk1vZHVsZSYmMSZ0LmZsYWdzKX1kZWNsYXJlTmFtZSh0LGUscyl7bGV0IGk9dGhpcy5jdXJyZW50U2NvcGUoKTtpZig4JmV8fDE2JmUpdGhpcy5jaGVja1JlZGVjbGFyYXRpb25JblNjb3BlKGksdCxlLHMpLDE2JmU/aS5mdW5jdGlvbnMucHVzaCh0KTppLmxleGljYWwucHVzaCh0KSw4JmUmJnRoaXMubWF5YmVFeHBvcnREZWZpbmVkKGksdCk7ZWxzZSBpZig0JmUpZm9yKGxldCByPXRoaXMuc2NvcGVTdGFjay5sZW5ndGgtMTtyPj0wJiYoaT10aGlzLnNjb3BlU3RhY2tbcl0sdGhpcy5jaGVja1JlZGVjbGFyYXRpb25JblNjb3BlKGksdCxlLHMpLGkudmFyLnB1c2godCksdGhpcy5tYXliZUV4cG9ydERlZmluZWQoaSx0KSwhKDEzMSZpLmZsYWdzKSk7LS1yKTt0aGlzLmluTW9kdWxlJiYxJmkuZmxhZ3MmJnRoaXMudW5kZWZpbmVkRXhwb3J0cy5kZWxldGUodCl9bWF5YmVFeHBvcnREZWZpbmVkKHQsZSl7dGhpcy5pbk1vZHVsZSYmMSZ0LmZsYWdzJiZ0aGlzLnVuZGVmaW5lZEV4cG9ydHMuZGVsZXRlKGUpfWNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUodCxlLHMsaSl7dGhpcy5pc1JlZGVjbGFyZWRJblNjb3BlKHQsZSxzKSYmdGhpcy5yYWlzZShpLGYuVmFyUmVkZWNsYXJhdGlvbixlKX1pc1JlZGVjbGFyZWRJblNjb3BlKHQsZSxzKXtyZXR1cm4hISgxJnMpJiYoOCZzP3QubGV4aWNhbC5pbmRleE9mKGUpPi0xfHx0LmZ1bmN0aW9ucy5pbmRleE9mKGUpPi0xfHx0LnZhci5pbmRleE9mKGUpPi0xOjE2JnM/dC5sZXhpY2FsLmluZGV4T2YoZSk+LTF8fCF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHQpJiZ0LnZhci5pbmRleE9mKGUpPi0xOnQubGV4aWNhbC5pbmRleE9mKGUpPi0xJiYhKDgmdC5mbGFncyYmdC5sZXhpY2FsWzBdPT09ZSl8fCF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHQpJiZ0LmZ1bmN0aW9ucy5pbmRleE9mKGUpPi0xKX1jaGVja0xvY2FsRXhwb3J0KHQpey0xPT09dGhpcy5zY29wZVN0YWNrWzBdLmxleGljYWwuaW5kZXhPZih0Lm5hbWUpJiYtMT09PXRoaXMuc2NvcGVTdGFja1swXS52YXIuaW5kZXhPZih0Lm5hbWUpJiYtMT09PXRoaXMuc2NvcGVTdGFja1swXS5mdW5jdGlvbnMuaW5kZXhPZih0Lm5hbWUpJiZ0aGlzLnVuZGVmaW5lZEV4cG9ydHMuc2V0KHQubmFtZSx0LnN0YXJ0KX1jdXJyZW50U2NvcGUoKXtyZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGgtMV19Y3VycmVudFZhclNjb3BlKCl7Zm9yKGxldCB0PXRoaXMuc2NvcGVTdGFjay5sZW5ndGgtMTs7dC0tKXtjb25zdCBlPXRoaXMuc2NvcGVTdGFja1t0XTtpZigxMzEmZS5mbGFncylyZXR1cm4gZX19Y3VycmVudFRoaXNTY29wZSgpe2ZvcihsZXQgdD10aGlzLnNjb3BlU3RhY2subGVuZ3RoLTE7O3QtLSl7Y29uc3QgZT10aGlzLnNjb3BlU3RhY2tbdF07aWYoKDEzMSZlLmZsYWdzfHw2NCZlLmZsYWdzKSYmISg0JmUuZmxhZ3MpKXJldHVybiBlfX19Y2xhc3MgJCBleHRlbmRzIFF7Y29uc3RydWN0b3IoLi4udCl7c3VwZXIoLi4udCksdGhpcy50eXBlcz1bXSx0aGlzLmVudW1zPVtdLHRoaXMuY29uc3RFbnVtcz1bXSx0aGlzLmNsYXNzZXM9W10sdGhpcy5leHBvcnRPbmx5QmluZGluZ3M9W119fWNsYXNzIFogZXh0ZW5kcyBZe2NyZWF0ZVNjb3BlKHQpe3JldHVybiBuZXcgJCh0KX1kZWNsYXJlTmFtZSh0LGUscyl7Y29uc3QgaT10aGlzLmN1cnJlbnRTY29wZSgpO2lmKDEwMjQmZSlyZXR1cm4gdGhpcy5tYXliZUV4cG9ydERlZmluZWQoaSx0KSx2b2lkIGkuZXhwb3J0T25seUJpbmRpbmdzLnB1c2godCk7c3VwZXIuZGVjbGFyZU5hbWUoLi4uYXJndW1lbnRzKSwyJmUmJigxJmV8fCh0aGlzLmNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoaSx0LGUscyksdGhpcy5tYXliZUV4cG9ydERlZmluZWQoaSx0KSksaS50eXBlcy5wdXNoKHQpKSwyNTYmZSYmaS5lbnVtcy5wdXNoKHQpLDUxMiZlJiZpLmNvbnN0RW51bXMucHVzaCh0KSwxMjgmZSYmaS5jbGFzc2VzLnB1c2godCl9aXNSZWRlY2xhcmVkSW5TY29wZSh0LGUscyl7aWYodC5lbnVtcy5pbmRleE9mKGUpPi0xKXtpZigyNTYmcyl7cmV0dXJuISEoNTEyJnMpIT09dC5jb25zdEVudW1zLmluZGV4T2YoZSk+LTF9cmV0dXJuITB9cmV0dXJuIDEyOCZzJiZ0LmNsYXNzZXMuaW5kZXhPZihlKT4tMT90LmxleGljYWwuaW5kZXhPZihlKT4tMSYmISEoMSZzKTohISgyJnMmJnQudHlwZXMuaW5kZXhPZihlKT4tMSl8fHN1cGVyLmlzUmVkZWNsYXJlZEluU2NvcGUoLi4uYXJndW1lbnRzKX1jaGVja0xvY2FsRXhwb3J0KHQpey0xPT09dGhpcy5zY29wZVN0YWNrWzBdLnR5cGVzLmluZGV4T2YodC5uYW1lKSYmLTE9PT10aGlzLnNjb3BlU3RhY2tbMF0uZXhwb3J0T25seUJpbmRpbmdzLmluZGV4T2YodC5uYW1lKSYmc3VwZXIuY2hlY2tMb2NhbEV4cG9ydCh0KX19Y2xhc3MgdHR7Y29uc3RydWN0b3IoKXt0aGlzLnN0YWNrcz1bXX1lbnRlcih0KXt0aGlzLnN0YWNrcy5wdXNoKHQpfWV4aXQoKXt0aGlzLnN0YWNrcy5wb3AoKX1jdXJyZW50RmxhZ3MoKXtyZXR1cm4gdGhpcy5zdGFja3NbdGhpcy5zdGFja3MubGVuZ3RoLTFdfWdldCBoYXNBd2FpdCgpe3JldHVybigyJnRoaXMuY3VycmVudEZsYWdzKCkpPjB9Z2V0IGhhc1lpZWxkKCl7cmV0dXJuKDEmdGhpcy5jdXJyZW50RmxhZ3MoKSk+MH1nZXQgaGFzUmV0dXJuKCl7cmV0dXJuKDQmdGhpcy5jdXJyZW50RmxhZ3MoKSk+MH19ZnVuY3Rpb24gZXQodCxlKXtyZXR1cm4odD8yOjApfChlPzE6MCl9ZnVuY3Rpb24gc3QodCl7aWYobnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFwiLmNvbmNhdCh0LFwiIHZhbHVlLlwiKSk7cmV0dXJuIHR9ZnVuY3Rpb24gaXQodCl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0IGZhaWxcIil9Y29uc3QgcnQ9T2JqZWN0LmZyZWV6ZSh7Q2xhc3NNZXRob2RIYXNEZWNsYXJlOlwiQ2xhc3MgbWV0aG9kcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyXCIsQ2xhc3NNZXRob2RIYXNSZWFkb25seTpcIkNsYXNzIG1ldGhvZHMgY2Fubm90IGhhdmUgdGhlICdyZWFkb25seScgbW9kaWZpZXJcIixEZWNsYXJlQ2xhc3NGaWVsZEhhc0luaXRpYWxpemVyOlwiJ2RlY2xhcmUnIGNsYXNzIGZpZWxkcyBjYW5ub3QgaGF2ZSBhbiBpbml0aWFsaXplclwiLER1cGxpY2F0ZU1vZGlmaWVyOlwiRHVwbGljYXRlIG1vZGlmaWVyOiAnJTAnXCIsRW1wdHlIZXJpdGFnZUNsYXVzZVR5cGU6XCInJTAnIGxpc3QgY2Fubm90IGJlIGVtcHR5LlwiLEluZGV4U2lnbmF0dXJlSGFzQWJzdHJhY3Q6XCJJbmRleCBzaWduYXR1cmVzIGNhbm5vdCBoYXZlIHRoZSAnYWJzdHJhY3QnIG1vZGlmaWVyXCIsSW5kZXhTaWduYXR1cmVIYXNBY2Nlc3NpYmlsaXR5OlwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSBhbiBhY2Nlc3NpYmlsaXR5IG1vZGlmaWVyICgnJTAnKVwiLEluZGV4U2lnbmF0dXJlSGFzU3RhdGljOlwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSB0aGUgJ3N0YXRpYycgbW9kaWZpZXJcIixPcHRpb25hbFR5cGVCZWZvcmVSZXF1aXJlZDpcIkEgcmVxdWlyZWQgZWxlbWVudCBjYW5ub3QgZm9sbG93IGFuIG9wdGlvbmFsIGVsZW1lbnQuXCIsUGF0dGVybklzT3B0aW9uYWw6XCJBIGJpbmRpbmcgcGF0dGVybiBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsIGluIGFuIGltcGxlbWVudGF0aW9uIHNpZ25hdHVyZS5cIixQcml2YXRlRWxlbWVudEhhc0Fic3RyYWN0OlwiUHJpdmF0ZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSB0aGUgJ2Fic3RyYWN0JyBtb2RpZmllci5cIixQcml2YXRlRWxlbWVudEhhc0FjY2Vzc2liaWxpdHk6XCJQcml2YXRlIGVsZW1lbnRzIGNhbm5vdCBoYXZlIGFuIGFjY2Vzc2liaWxpdHkgbW9kaWZpZXIgKCclMCcpXCIsVGVtcGxhdGVUeXBlSGFzU3Vic3RpdHV0aW9uOlwiVGVtcGxhdGUgbGl0ZXJhbCB0eXBlcyBjYW5ub3QgaGF2ZSBhbnkgc3Vic3RpdHV0aW9uXCIsVHlwZUFubm90YXRpb25BZnRlckFzc2lnbjpcIlR5cGUgYW5ub3RhdGlvbnMgbXVzdCBjb21lIGJlZm9yZSBkZWZhdWx0IGFzc2lnbm1lbnRzLCBlLmcuIGluc3RlYWQgb2YgYGFnZSA9IDI1OiBudW1iZXJgIHVzZSBgYWdlOiBudW1iZXIgPSAyNWBcIixVbmV4cGVjdGVkUmVhZG9ubHk6XCIncmVhZG9ubHknIHR5cGUgbW9kaWZpZXIgaXMgb25seSBwZXJtaXR0ZWQgb24gYXJyYXkgYW5kIHR1cGxlIGxpdGVyYWwgdHlwZXMuXCIsVW5leHBlY3RlZFR5cGVBbm5vdGF0aW9uOlwiRGlkIG5vdCBleHBlY3QgYSB0eXBlIGFubm90YXRpb24gaGVyZS5cIixVbmV4cGVjdGVkVHlwZUNhc3RJblBhcmFtZXRlcjpcIlVuZXhwZWN0ZWQgdHlwZSBjYXN0IGluIHBhcmFtZXRlciBwb3NpdGlvbi5cIixVbnN1cHBvcnRlZEltcG9ydFR5cGVBcmd1bWVudDpcIkFyZ3VtZW50IGluIGEgdHlwZSBpbXBvcnQgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsXCIsVW5zdXBwb3J0ZWRQYXJhbWV0ZXJQcm9wZXJ0eUtpbmQ6XCJBIHBhcmFtZXRlciBwcm9wZXJ0eSBtYXkgbm90IGJlIGRlY2xhcmVkIHVzaW5nIGEgYmluZGluZyBwYXR0ZXJuLlwiLFVuc3VwcG9ydGVkU2lnbmF0dXJlUGFyYW1ldGVyS2luZDpcIk5hbWUgaW4gYSBzaWduYXR1cmUgbXVzdCBiZSBhbiBJZGVudGlmaWVyLCBPYmplY3RQYXR0ZXJuIG9yIEFycmF5UGF0dGVybiwgaW5zdGVhZCBnb3QgJTBcIn0pO24ucGxhY2Vob2xkZXI9bmV3IHMoXCIlJVwiLHtzdGFydHNFeHByOiEwfSk7ZnVuY3Rpb24gYXQodCxlKXtyZXR1cm4gdC5zb21lKHQ9PkFycmF5LmlzQXJyYXkodCk/dFswXT09PWU6dD09PWUpfWZ1bmN0aW9uIG50KHQsZSxzKXtjb25zdCBpPXQuZmluZCh0PT5BcnJheS5pc0FycmF5KHQpP3RbMF09PT1lOnQ9PT1lKTtyZXR1cm4gaSYmQXJyYXkuaXNBcnJheShpKT9pWzFdW3NdOm51bGx9Y29uc3Qgb3Q9W1wibWluaW1hbFwiLFwic21hcnRcIixcImZzaGFycFwiXSxodD1bXCJoYXNoXCIsXCJiYXJcIl07Y29uc3QgcHQ9e2VzdHJlZTp0PT5jbGFzcyBleHRlbmRzIHR7ZXN0cmVlUGFyc2VSZWdFeHBMaXRlcmFsKHtwYXR0ZXJuOnQsZmxhZ3M6ZX0pe2xldCBzPW51bGw7dHJ5e3M9bmV3IFJlZ0V4cCh0LGUpfWNhdGNoKHQpe31jb25zdCBpPXRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHMpO3JldHVybiBpLnJlZ2V4PXtwYXR0ZXJuOnQsZmxhZ3M6ZX0saX1lc3RyZWVQYXJzZUJpZ0ludExpdGVyYWwodCl7Y29uc3QgZT1cInVuZGVmaW5lZFwiIT10eXBlb2YgQmlnSW50P0JpZ0ludCh0KTpudWxsLHM9dGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwoZSk7cmV0dXJuIHMuYmlnaW50PVN0cmluZyhzLnZhbHVlfHx0KSxzfWVzdHJlZVBhcnNlTGl0ZXJhbCh0KXtyZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodCxcIkxpdGVyYWxcIil9ZGlyZWN0aXZlVG9TdG10KHQpe2NvbnN0IGU9dC52YWx1ZSxzPXRoaXMuc3RhcnROb2RlQXQodC5zdGFydCx0LmxvYy5zdGFydCksaT10aGlzLnN0YXJ0Tm9kZUF0KGUuc3RhcnQsZS5sb2Muc3RhcnQpO3JldHVybiBpLnZhbHVlPWUudmFsdWUsaS5yYXc9ZS5leHRyYS5yYXcscy5leHByZXNzaW9uPXRoaXMuZmluaXNoTm9kZUF0KGksXCJMaXRlcmFsXCIsZS5lbmQsZS5sb2MuZW5kKSxzLmRpcmVjdGl2ZT1lLmV4dHJhLnJhdy5zbGljZSgxLC0xKSx0aGlzLmZpbmlzaE5vZGVBdChzLFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLHQuZW5kLHQubG9jLmVuZCl9aW5pdEZ1bmN0aW9uKHQsZSl7c3VwZXIuaW5pdEZ1bmN0aW9uKHQsZSksdC5leHByZXNzaW9uPSExfWNoZWNrRGVjbGFyYXRpb24odCl7RCh0KT90aGlzLmNoZWNrRGVjbGFyYXRpb24odC52YWx1ZSk6c3VwZXIuY2hlY2tEZWNsYXJhdGlvbih0KX1jaGVja0dldHRlclNldHRlclBhcmFtcyh0KXtjb25zdCBlPXQscz1cImdldFwiPT09ZS5raW5kPzA6MSxpPWUuc3RhcnQ7ZS52YWx1ZS5wYXJhbXMubGVuZ3RoIT09cz9cImdldFwiPT09dC5raW5kP3RoaXMucmFpc2UoaSxmLkJhZEdldHRlckFyaXR5KTp0aGlzLnJhaXNlKGksZi5CYWRTZXR0ZXJBcml0eSk6XCJzZXRcIj09PWUua2luZCYmXCJSZXN0RWxlbWVudFwiPT09ZS52YWx1ZS5wYXJhbXNbMF0udHlwZSYmdGhpcy5yYWlzZShpLGYuQmFkU2V0dGVyUmVzdFBhcmFtZXRlcil9Y2hlY2tMVmFsKHQsZT02NCxzLGkscil7c3dpdGNoKHQudHlwZSl7Y2FzZVwiT2JqZWN0UGF0dGVyblwiOnQucHJvcGVydGllcy5mb3JFYWNoKHQ9Pnt0aGlzLmNoZWNrTFZhbChcIlByb3BlcnR5XCI9PT10LnR5cGU/dC52YWx1ZTp0LGUscyxcIm9iamVjdCBkZXN0cnVjdHVyaW5nIHBhdHRlcm5cIixyKX0pO2JyZWFrO2RlZmF1bHQ6c3VwZXIuY2hlY2tMVmFsKHQsZSxzLGkscil9fWNoZWNrRHVwbGljYXRlZFByb3RvKHQsZSxzKXtpZihcIlNwcmVhZEVsZW1lbnRcIj09PXQudHlwZXx8dC5jb21wdXRlZHx8dC5tZXRob2R8fHQuc2hvcnRoYW5kKXJldHVybjtjb25zdCBpPXQua2V5O1wiX19wcm90b19fXCI9PT0oXCJJZGVudGlmaWVyXCI9PT1pLnR5cGU/aS5uYW1lOlN0cmluZyhpLnZhbHVlKSkmJlwiaW5pdFwiPT09dC5raW5kJiYoZS51c2VkJiYocyYmLTE9PT1zLmRvdWJsZVByb3RvP3MuZG91YmxlUHJvdG89aS5zdGFydDp0aGlzLnJhaXNlKGkuc3RhcnQsZi5EdXBsaWNhdGVQcm90bykpLGUudXNlZD0hMCl9aXNWYWxpZERpcmVjdGl2ZSh0KXtyZXR1cm4hKFwiRXhwcmVzc2lvblN0YXRlbWVudFwiIT09dC50eXBlfHxcIkxpdGVyYWxcIiE9PXQuZXhwcmVzc2lvbi50eXBlfHxcInN0cmluZ1wiIT10eXBlb2YgdC5leHByZXNzaW9uLnZhbHVlfHx0LmV4cHJlc3Npb24uZXh0cmEmJnQuZXhwcmVzc2lvbi5leHRyYS5wYXJlbnRoZXNpemVkKX1zdG10VG9EaXJlY3RpdmUodCl7Y29uc3QgZT1zdXBlci5zdG10VG9EaXJlY3RpdmUodCkscz10LmV4cHJlc3Npb24udmFsdWU7cmV0dXJuIGUudmFsdWUudmFsdWU9cyxlfXBhcnNlQmxvY2tCb2R5KHQsZSxzLGkpe3N1cGVyLnBhcnNlQmxvY2tCb2R5KHQsZSxzLGkpO2NvbnN0IHI9dC5kaXJlY3RpdmVzLm1hcCh0PT50aGlzLmRpcmVjdGl2ZVRvU3RtdCh0KSk7dC5ib2R5PXIuY29uY2F0KHQuYm9keSksZGVsZXRlIHQuZGlyZWN0aXZlc31wdXNoQ2xhc3NNZXRob2QodCxlLHMsaSxyLGEpe3RoaXMucGFyc2VNZXRob2QoZSxzLGkscixhLFwiQ2xhc3NNZXRob2RcIiwhMCksZS50eXBlUGFyYW1ldGVycyYmKGUudmFsdWUudHlwZVBhcmFtZXRlcnM9ZS50eXBlUGFyYW1ldGVycyxkZWxldGUgZS50eXBlUGFyYW1ldGVycyksdC5ib2R5LnB1c2goZSl9cGFyc2VFeHByQXRvbSh0KXtzd2l0Y2godGhpcy5zdGF0ZS50eXBlKXtjYXNlIG4ubnVtOmNhc2Ugbi5zdHJpbmc6cmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO2Nhc2Ugbi5yZWdleHA6cmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VSZWdFeHBMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO2Nhc2Ugbi5iaWdpbnQ6cmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VCaWdJbnRMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO2Nhc2Ugbi5fbnVsbDpyZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwobnVsbCk7Y2FzZSBuLl90cnVlOnJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbCghMCk7Y2FzZSBuLl9mYWxzZTpyZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwoITEpO2RlZmF1bHQ6cmV0dXJuIHN1cGVyLnBhcnNlRXhwckF0b20odCl9fXBhcnNlTGl0ZXJhbCh0LGUscyxpKXtjb25zdCByPXN1cGVyLnBhcnNlTGl0ZXJhbCh0LGUscyxpKTtyZXR1cm4gci5yYXc9ci5leHRyYS5yYXcsZGVsZXRlIHIuZXh0cmEscn1wYXJzZUZ1bmN0aW9uQm9keSh0LGUscz0hMSl7c3VwZXIucGFyc2VGdW5jdGlvbkJvZHkodCxlLHMpLHQuZXhwcmVzc2lvbj1cIkJsb2NrU3RhdGVtZW50XCIhPT10LmJvZHkudHlwZX1wYXJzZU1ldGhvZCh0LGUscyxpLHIsYSxuPSExKXtsZXQgbz10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiBvLmtpbmQ9dC5raW5kLG89c3VwZXIucGFyc2VNZXRob2QobyxlLHMsaSxyLGEsbiksby50eXBlPVwiRnVuY3Rpb25FeHByZXNzaW9uXCIsZGVsZXRlIG8ua2luZCx0LnZhbHVlPW8sYT1cIkNsYXNzTWV0aG9kXCI9PT1hP1wiTWV0aG9kRGVmaW5pdGlvblwiOmEsdGhpcy5maW5pc2hOb2RlKHQsYSl9cGFyc2VPYmplY3RNZXRob2QodCxlLHMsaSxyKXtjb25zdCBhPXN1cGVyLnBhcnNlT2JqZWN0TWV0aG9kKHQsZSxzLGkscik7cmV0dXJuIGEmJihhLnR5cGU9XCJQcm9wZXJ0eVwiLFwibWV0aG9kXCI9PT1hLmtpbmQmJihhLmtpbmQ9XCJpbml0XCIpLGEuc2hvcnRoYW5kPSExKSxhfXBhcnNlT2JqZWN0UHJvcGVydHkodCxlLHMsaSxyKXtjb25zdCBhPXN1cGVyLnBhcnNlT2JqZWN0UHJvcGVydHkodCxlLHMsaSxyKTtyZXR1cm4gYSYmKGEua2luZD1cImluaXRcIixhLnR5cGU9XCJQcm9wZXJ0eVwiKSxhfXRvQXNzaWduYWJsZSh0KXtyZXR1cm4gRCh0KT8odGhpcy50b0Fzc2lnbmFibGUodC52YWx1ZSksdCk6c3VwZXIudG9Bc3NpZ25hYmxlKHQpfXRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHQsZSl7aWYoXCJnZXRcIj09PXQua2luZHx8XCJzZXRcIj09PXQua2luZCl0aHJvdyB0aGlzLnJhaXNlKHQua2V5LnN0YXJ0LGYuUGF0dGVybkhhc0FjY2Vzc29yKTtpZih0Lm1ldGhvZCl0aHJvdyB0aGlzLnJhaXNlKHQua2V5LnN0YXJ0LGYuUGF0dGVybkhhc01ldGhvZCk7c3VwZXIudG9Bc3NpZ25hYmxlT2JqZWN0RXhwcmVzc2lvblByb3AodCxlKX1maW5pc2hDYWxsRXhwcmVzc2lvbih0LGUpe3JldHVybiBzdXBlci5maW5pc2hDYWxsRXhwcmVzc2lvbih0LGUpLFwiSW1wb3J0XCI9PT10LmNhbGxlZS50eXBlJiYodC50eXBlPVwiSW1wb3J0RXhwcmVzc2lvblwiLHQuc291cmNlPXQuYXJndW1lbnRzWzBdLGRlbGV0ZSB0LmFyZ3VtZW50cyxkZWxldGUgdC5jYWxsZWUpLHR9dG9SZWZlcmVuY2VkTGlzdERlZXAodCxlKXt0JiZzdXBlci50b1JlZmVyZW5jZWRMaXN0RGVlcCh0LGUpfXBhcnNlRXhwb3J0KHQpe3N3aXRjaChzdXBlci5wYXJzZUV4cG9ydCh0KSx0LnR5cGUpe2Nhc2VcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI6dC5leHBvcnRlZD1udWxsO2JyZWFrO2Nhc2VcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjoxPT09dC5zcGVjaWZpZXJzLmxlbmd0aCYmXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIj09PXQuc3BlY2lmaWVyc1swXS50eXBlJiYodC50eXBlPVwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIix0LmV4cG9ydGVkPXQuc3BlY2lmaWVyc1swXS5leHBvcnRlZCxkZWxldGUgdC5zcGVjaWZpZXJzKX1yZXR1cm4gdH19LGpzeDp0PT5jbGFzcyBleHRlbmRzIHR7anN4UmVhZFRva2VuKCl7bGV0IHQ9XCJcIixlPXRoaXMuc3RhdGUucG9zO2Zvcig7Oyl7aWYodGhpcy5zdGF0ZS5wb3M+PXRoaXMubGVuZ3RoKXRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxKLlVudGVybWluYXRlZEpzeENvbnRlbnQpO2NvbnN0IHM9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtzd2l0Y2gocyl7Y2FzZSA2MDpjYXNlIDEyMzpyZXR1cm4gdGhpcy5zdGF0ZS5wb3M9PT10aGlzLnN0YXRlLnN0YXJ0PzYwPT09cyYmdGhpcy5zdGF0ZS5leHByQWxsb3dlZD8oKyt0aGlzLnN0YXRlLnBvcyx0aGlzLmZpbmlzaFRva2VuKG4uanN4VGFnU3RhcnQpKTpzdXBlci5nZXRUb2tlbkZyb21Db2RlKHMpOih0Kz10aGlzLmlucHV0LnNsaWNlKGUsdGhpcy5zdGF0ZS5wb3MpLHRoaXMuZmluaXNoVG9rZW4obi5qc3hUZXh0LHQpKTtjYXNlIDM4OnQrPXRoaXMuaW5wdXQuc2xpY2UoZSx0aGlzLnN0YXRlLnBvcyksdCs9dGhpcy5qc3hSZWFkRW50aXR5KCksZT10aGlzLnN0YXRlLnBvczticmVhaztkZWZhdWx0OnAocyk/KHQrPXRoaXMuaW5wdXQuc2xpY2UoZSx0aGlzLnN0YXRlLnBvcyksdCs9dGhpcy5qc3hSZWFkTmV3TGluZSghMCksZT10aGlzLnN0YXRlLnBvcyk6Kyt0aGlzLnN0YXRlLnBvc319fWpzeFJlYWROZXdMaW5lKHQpe2NvbnN0IGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtsZXQgcztyZXR1cm4rK3RoaXMuc3RhdGUucG9zLDEzPT09ZSYmMTA9PT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpPygrK3RoaXMuc3RhdGUucG9zLHM9dD9cIlxcblwiOlwiXFxyXFxuXCIpOnM9U3RyaW5nLmZyb21DaGFyQ29kZShlKSwrK3RoaXMuc3RhdGUuY3VyTGluZSx0aGlzLnN0YXRlLmxpbmVTdGFydD10aGlzLnN0YXRlLnBvcyxzfWpzeFJlYWRTdHJpbmcodCl7bGV0IGU9XCJcIixzPSsrdGhpcy5zdGF0ZS5wb3M7Zm9yKDs7KXtpZih0aGlzLnN0YXRlLnBvcz49dGhpcy5sZW5ndGgpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGYuVW50ZXJtaW5hdGVkU3RyaW5nKTtjb25zdCBpPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7aWYoaT09PXQpYnJlYWs7Mzg9PT1pPyhlKz10aGlzLmlucHV0LnNsaWNlKHMsdGhpcy5zdGF0ZS5wb3MpLGUrPXRoaXMuanN4UmVhZEVudGl0eSgpLHM9dGhpcy5zdGF0ZS5wb3MpOnAoaSk/KGUrPXRoaXMuaW5wdXQuc2xpY2Uocyx0aGlzLnN0YXRlLnBvcyksZSs9dGhpcy5qc3hSZWFkTmV3TGluZSghMSkscz10aGlzLnN0YXRlLnBvcyk6Kyt0aGlzLnN0YXRlLnBvc31yZXR1cm4gZSs9dGhpcy5pbnB1dC5zbGljZShzLHRoaXMuc3RhdGUucG9zKyspLHRoaXMuZmluaXNoVG9rZW4obi5zdHJpbmcsZSl9anN4UmVhZEVudGl0eSgpe2xldCB0LGU9XCJcIixzPTAsaT10aGlzLmlucHV0W3RoaXMuc3RhdGUucG9zXTtjb25zdCByPSsrdGhpcy5zdGF0ZS5wb3M7Zm9yKDt0aGlzLnN0YXRlLnBvczx0aGlzLmxlbmd0aCYmcysrPDEwOyl7aWYoaT10aGlzLmlucHV0W3RoaXMuc3RhdGUucG9zKytdLFwiO1wiPT09aSl7XCIjXCI9PT1lWzBdP1wieFwiPT09ZVsxXT8oZT1lLnN1YnN0cigyKSxXLnRlc3QoZSkmJih0PVN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KGUsMTYpKSkpOihlPWUuc3Vic3RyKDEpLEsudGVzdChlKSYmKHQ9U3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQoZSwxMCkpKSk6dD1IW2VdO2JyZWFrfWUrPWl9cmV0dXJuIHR8fCh0aGlzLnN0YXRlLnBvcz1yLFwiJlwiKX1qc3hSZWFkV29yZCgpe2xldCB0O2NvbnN0IGU9dGhpcy5zdGF0ZS5wb3M7ZG97dD10aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcyl9d2hpbGUoUyh0KXx8NDU9PT10KTtyZXR1cm4gdGhpcy5maW5pc2hUb2tlbihuLmpzeE5hbWUsdGhpcy5pbnB1dC5zbGljZShlLHRoaXMuc3RhdGUucG9zKSl9anN4UGFyc2VJZGVudGlmaWVyKCl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm1hdGNoKG4uanN4TmFtZSk/dC5uYW1lPXRoaXMuc3RhdGUudmFsdWU6dGhpcy5zdGF0ZS50eXBlLmtleXdvcmQ/dC5uYW1lPXRoaXMuc3RhdGUudHlwZS5rZXl3b3JkOnRoaXMudW5leHBlY3RlZCgpLHRoaXMubmV4dCgpLHRoaXMuZmluaXNoTm9kZSh0LFwiSlNYSWRlbnRpZmllclwiKX1qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCl7Y29uc3QgdD10aGlzLnN0YXRlLnN0YXJ0LGU9dGhpcy5zdGF0ZS5zdGFydExvYyxzPXRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7aWYoIXRoaXMuZWF0KG4uY29sb24pKXJldHVybiBzO2NvbnN0IGk9dGhpcy5zdGFydE5vZGVBdCh0LGUpO3JldHVybiBpLm5hbWVzcGFjZT1zLGkubmFtZT10aGlzLmpzeFBhcnNlSWRlbnRpZmllcigpLHRoaXMuZmluaXNoTm9kZShpLFwiSlNYTmFtZXNwYWNlZE5hbWVcIil9anN4UGFyc2VFbGVtZW50TmFtZSgpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5zdGFydCxlPXRoaXMuc3RhdGUuc3RhcnRMb2M7bGV0IHM9dGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7aWYoXCJKU1hOYW1lc3BhY2VkTmFtZVwiPT09cy50eXBlKXJldHVybiBzO2Zvcig7dGhpcy5lYXQobi5kb3QpOyl7Y29uc3QgaT10aGlzLnN0YXJ0Tm9kZUF0KHQsZSk7aS5vYmplY3Q9cyxpLnByb3BlcnR5PXRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCkscz10aGlzLmZpbmlzaE5vZGUoaSxcIkpTWE1lbWJlckV4cHJlc3Npb25cIil9cmV0dXJuIHN9anN4UGFyc2VBdHRyaWJ1dGVWYWx1ZSgpe2xldCB0O3N3aXRjaCh0aGlzLnN0YXRlLnR5cGUpe2Nhc2Ugbi5icmFjZUw6cmV0dXJuIHQ9dGhpcy5zdGFydE5vZGUoKSx0aGlzLm5leHQoKSx0PXRoaXMuanN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKHQpLFwiSlNYRW1wdHlFeHByZXNzaW9uXCI9PT10LmV4cHJlc3Npb24udHlwZSYmdGhpcy5yYWlzZSh0LnN0YXJ0LEouQXR0cmlidXRlSXNFbXB0eSksdDtjYXNlIG4uanN4VGFnU3RhcnQ6Y2FzZSBuLnN0cmluZzpyZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tKCk7ZGVmYXVsdDp0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsSi5VbnN1cHBvcnRlZEpzeFZhbHVlKX19anN4UGFyc2VFbXB0eUV4cHJlc3Npb24oKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlQXQodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7cmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KHQsXCJKU1hFbXB0eUV4cHJlc3Npb25cIix0aGlzLnN0YXRlLnN0YXJ0LHRoaXMuc3RhdGUuc3RhcnRMb2MpfWpzeFBhcnNlU3ByZWFkQ2hpbGQodCl7cmV0dXJuIHRoaXMubmV4dCgpLHQuZXhwcmVzc2lvbj10aGlzLnBhcnNlRXhwcmVzc2lvbigpLHRoaXMuZXhwZWN0KG4uYnJhY2VSKSx0aGlzLmZpbmlzaE5vZGUodCxcIkpTWFNwcmVhZENoaWxkXCIpfWpzeFBhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcih0KXtyZXR1cm4gdGhpcy5tYXRjaChuLmJyYWNlUik/dC5leHByZXNzaW9uPXRoaXMuanN4UGFyc2VFbXB0eUV4cHJlc3Npb24oKTp0LmV4cHJlc3Npb249dGhpcy5wYXJzZUV4cHJlc3Npb24oKSx0aGlzLmV4cGVjdChuLmJyYWNlUiksdGhpcy5maW5pc2hOb2RlKHQsXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIpfWpzeFBhcnNlQXR0cmlidXRlKCl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLmVhdChuLmJyYWNlTCk/KHRoaXMuZXhwZWN0KG4uZWxsaXBzaXMpLHQuYXJndW1lbnQ9dGhpcy5wYXJzZU1heWJlQXNzaWduKCksdGhpcy5leHBlY3Qobi5icmFjZVIpLHRoaXMuZmluaXNoTm9kZSh0LFwiSlNYU3ByZWFkQXR0cmlidXRlXCIpKToodC5uYW1lPXRoaXMuanN4UGFyc2VOYW1lc3BhY2VkTmFtZSgpLHQudmFsdWU9dGhpcy5lYXQobi5lcSk/dGhpcy5qc3hQYXJzZUF0dHJpYnV0ZVZhbHVlKCk6bnVsbCx0aGlzLmZpbmlzaE5vZGUodCxcIkpTWEF0dHJpYnV0ZVwiKSl9anN4UGFyc2VPcGVuaW5nRWxlbWVudEF0KHQsZSl7Y29uc3Qgcz10aGlzLnN0YXJ0Tm9kZUF0KHQsZSk7cmV0dXJuIHRoaXMubWF0Y2gobi5qc3hUYWdFbmQpPyh0aGlzLmV4cGVjdChuLmpzeFRhZ0VuZCksdGhpcy5maW5pc2hOb2RlKHMsXCJKU1hPcGVuaW5nRnJhZ21lbnRcIikpOihzLm5hbWU9dGhpcy5qc3hQYXJzZUVsZW1lbnROYW1lKCksdGhpcy5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKHMpKX1qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKHQpe2NvbnN0IGU9W107Zm9yKDshdGhpcy5tYXRjaChuLnNsYXNoKSYmIXRoaXMubWF0Y2gobi5qc3hUYWdFbmQpOyllLnB1c2godGhpcy5qc3hQYXJzZUF0dHJpYnV0ZSgpKTtyZXR1cm4gdC5hdHRyaWJ1dGVzPWUsdC5zZWxmQ2xvc2luZz10aGlzLmVhdChuLnNsYXNoKSx0aGlzLmV4cGVjdChuLmpzeFRhZ0VuZCksdGhpcy5maW5pc2hOb2RlKHQsXCJKU1hPcGVuaW5nRWxlbWVudFwiKX1qc3hQYXJzZUNsb3NpbmdFbGVtZW50QXQodCxlKXtjb25zdCBzPXRoaXMuc3RhcnROb2RlQXQodCxlKTtyZXR1cm4gdGhpcy5tYXRjaChuLmpzeFRhZ0VuZCk/KHRoaXMuZXhwZWN0KG4uanN4VGFnRW5kKSx0aGlzLmZpbmlzaE5vZGUocyxcIkpTWENsb3NpbmdGcmFnbWVudFwiKSk6KHMubmFtZT10aGlzLmpzeFBhcnNlRWxlbWVudE5hbWUoKSx0aGlzLmV4cGVjdChuLmpzeFRhZ0VuZCksdGhpcy5maW5pc2hOb2RlKHMsXCJKU1hDbG9zaW5nRWxlbWVudFwiKSl9anN4UGFyc2VFbGVtZW50QXQodCxlKXtjb25zdCBzPXRoaXMuc3RhcnROb2RlQXQodCxlKSxpPVtdLHI9dGhpcy5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QXQodCxlKTtsZXQgYT1udWxsO2lmKCFyLnNlbGZDbG9zaW5nKXt0OmZvcig7Oylzd2l0Y2godGhpcy5zdGF0ZS50eXBlKXtjYXNlIG4uanN4VGFnU3RhcnQ6aWYodD10aGlzLnN0YXRlLnN0YXJ0LGU9dGhpcy5zdGF0ZS5zdGFydExvYyx0aGlzLm5leHQoKSx0aGlzLmVhdChuLnNsYXNoKSl7YT10aGlzLmpzeFBhcnNlQ2xvc2luZ0VsZW1lbnRBdCh0LGUpO2JyZWFrIHR9aS5wdXNoKHRoaXMuanN4UGFyc2VFbGVtZW50QXQodCxlKSk7YnJlYWs7Y2FzZSBuLmpzeFRleHQ6aS5wdXNoKHRoaXMucGFyc2VFeHByQXRvbSgpKTticmVhaztjYXNlIG4uYnJhY2VMOntjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7dGhpcy5uZXh0KCksdGhpcy5tYXRjaChuLmVsbGlwc2lzKT9pLnB1c2godGhpcy5qc3hQYXJzZVNwcmVhZENoaWxkKHQpKTppLnB1c2godGhpcy5qc3hQYXJzZUV4cHJlc3Npb25Db250YWluZXIodCkpO2JyZWFrfWRlZmF1bHQ6dGhyb3cgdGhpcy51bmV4cGVjdGVkKCl9WChyKSYmIVgoYSk/dGhpcy5yYWlzZShhLnN0YXJ0LEouTWlzc2luZ0Nsb3NpbmdUYWdGcmFnbWVudCk6IVgocikmJlgoYSk/dGhpcy5yYWlzZShhLnN0YXJ0LEouTWlzc2luZ0Nsb3NpbmdUYWdFbGVtZW50LEcoci5uYW1lKSk6WChyKXx8WChhKXx8RyhhLm5hbWUpIT09RyhyLm5hbWUpJiZ0aGlzLnJhaXNlKGEuc3RhcnQsSi5NaXNzaW5nQ2xvc2luZ1RhZ0VsZW1lbnQsRyhyLm5hbWUpKX1pZihYKHIpPyhzLm9wZW5pbmdGcmFnbWVudD1yLHMuY2xvc2luZ0ZyYWdtZW50PWEpOihzLm9wZW5pbmdFbGVtZW50PXIscy5jbG9zaW5nRWxlbWVudD1hKSxzLmNoaWxkcmVuPWksdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKXRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxKLlVud3JhcHBlZEFkamFjZW50SlNYRWxlbWVudHMpO3JldHVybiBYKHIpP3RoaXMuZmluaXNoTm9kZShzLFwiSlNYRnJhZ21lbnRcIik6dGhpcy5maW5pc2hOb2RlKHMsXCJKU1hFbGVtZW50XCIpfWpzeFBhcnNlRWxlbWVudCgpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5zdGFydCxlPXRoaXMuc3RhdGUuc3RhcnRMb2M7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuanN4UGFyc2VFbGVtZW50QXQodCxlKX1wYXJzZUV4cHJBdG9tKHQpe3JldHVybiB0aGlzLm1hdGNoKG4uanN4VGV4dCk/dGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSxcIkpTWFRleHRcIik6dGhpcy5tYXRjaChuLmpzeFRhZ1N0YXJ0KT90aGlzLmpzeFBhcnNlRWxlbWVudCgpOnRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSYmMzMhPT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpPyh0aGlzLmZpbmlzaFRva2VuKG4uanN4VGFnU3RhcnQpLHRoaXMuanN4UGFyc2VFbGVtZW50KCkpOnN1cGVyLnBhcnNlRXhwckF0b20odCl9Z2V0VG9rZW5Gcm9tQ29kZSh0KXtpZih0aGlzLnN0YXRlLmluUHJvcGVydHlOYW1lKXJldHVybiBzdXBlci5nZXRUb2tlbkZyb21Db2RlKHQpO2NvbnN0IGU9dGhpcy5jdXJDb250ZXh0KCk7aWYoZT09PXgual9leHByKXJldHVybiB0aGlzLmpzeFJlYWRUb2tlbigpO2lmKGU9PT14Lmpfb1RhZ3x8ZT09PXgual9jVGFnKXtpZih3KHQpKXJldHVybiB0aGlzLmpzeFJlYWRXb3JkKCk7aWYoNjI9PT10KXJldHVybisrdGhpcy5zdGF0ZS5wb3MsdGhpcy5maW5pc2hUb2tlbihuLmpzeFRhZ0VuZCk7aWYoKDM0PT09dHx8Mzk9PT10KSYmZT09PXgual9vVGFnKXJldHVybiB0aGlzLmpzeFJlYWRTdHJpbmcodCl9cmV0dXJuIDYwPT09dCYmdGhpcy5zdGF0ZS5leHByQWxsb3dlZCYmMzMhPT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMSk/KCsrdGhpcy5zdGF0ZS5wb3MsdGhpcy5maW5pc2hUb2tlbihuLmpzeFRhZ1N0YXJ0KSk6c3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZSh0KX11cGRhdGVDb250ZXh0KHQpe2lmKHRoaXMubWF0Y2gobi5icmFjZUwpKXtjb25zdCBlPXRoaXMuY3VyQ29udGV4dCgpO2U9PT14Lmpfb1RhZz90aGlzLnN0YXRlLmNvbnRleHQucHVzaCh4LmJyYWNlRXhwcmVzc2lvbik6ZT09PXgual9leHByP3RoaXMuc3RhdGUuY29udGV4dC5wdXNoKHgudGVtcGxhdGVRdWFzaSk6c3VwZXIudXBkYXRlQ29udGV4dCh0KSx0aGlzLnN0YXRlLmV4cHJBbGxvd2VkPSEwfWVsc2V7aWYoIXRoaXMubWF0Y2gobi5zbGFzaCl8fHQhPT1uLmpzeFRhZ1N0YXJ0KXJldHVybiBzdXBlci51cGRhdGVDb250ZXh0KHQpO3RoaXMuc3RhdGUuY29udGV4dC5sZW5ndGgtPTIsdGhpcy5zdGF0ZS5jb250ZXh0LnB1c2goeC5qX2NUYWcpLHRoaXMuc3RhdGUuZXhwckFsbG93ZWQ9ITF9fX0sZmxvdzp0PT5jbGFzcyBleHRlbmRzIHR7Y29uc3RydWN0b3IodCxlKXtzdXBlcih0LGUpLHRoaXMuZmxvd1ByYWdtYT12b2lkIDB9c2hvdWxkUGFyc2VUeXBlcygpe3JldHVybiB0aGlzLmdldFBsdWdpbk9wdGlvbihcImZsb3dcIixcImFsbFwiKXx8XCJmbG93XCI9PT10aGlzLmZsb3dQcmFnbWF9c2hvdWxkUGFyc2VFbnVtcygpe3JldHVybiEhdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJmbG93XCIsXCJlbnVtc1wiKX1maW5pc2hUb2tlbih0LGUpe3JldHVybiB0IT09bi5zdHJpbmcmJnQhPT1uLnNlbWkmJnQhPT1uLmludGVycHJldGVyRGlyZWN0aXZlJiZ2b2lkIDA9PT10aGlzLmZsb3dQcmFnbWEmJih0aGlzLmZsb3dQcmFnbWE9bnVsbCksc3VwZXIuZmluaXNoVG9rZW4odCxlKX1hZGRDb21tZW50KHQpe2lmKHZvaWQgMD09PXRoaXMuZmxvd1ByYWdtYSl7Y29uc3QgZT16LmV4ZWModC52YWx1ZSk7aWYoZSlpZihcImZsb3dcIj09PWVbMV0pdGhpcy5mbG93UHJhZ21hPVwiZmxvd1wiO2Vsc2V7aWYoXCJub2Zsb3dcIiE9PWVbMV0pdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBmbG93IHByYWdtYVwiKTt0aGlzLmZsb3dQcmFnbWE9XCJub2Zsb3dcIn1lbHNlO31yZXR1cm4gc3VwZXIuYWRkQ29tbWVudCh0KX1mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIodCl7Y29uc3QgZT10aGlzLnN0YXRlLmluVHlwZTt0aGlzLnN0YXRlLmluVHlwZT0hMCx0aGlzLmV4cGVjdCh0fHxuLmNvbG9uKTtjb25zdCBzPXRoaXMuZmxvd1BhcnNlVHlwZSgpO3JldHVybiB0aGlzLnN0YXRlLmluVHlwZT1lLHN9Zmxvd1BhcnNlUHJlZGljYXRlKCl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpLGU9dGhpcy5zdGF0ZS5zdGFydExvYyxzPXRoaXMuc3RhdGUuc3RhcnQ7dGhpcy5leHBlY3Qobi5tb2R1bG8pO2NvbnN0IGk9dGhpcy5zdGF0ZS5zdGFydExvYztyZXR1cm4gdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiY2hlY2tzXCIpLGUubGluZT09PWkubGluZSYmZS5jb2x1bW49PT1pLmNvbHVtbi0xfHx0aGlzLnJhaXNlKHMsai5VbmV4cGVjdGVkU3BhY2VCZXR3ZWVuTW9kdWxvQ2hlY2tzKSx0aGlzLmVhdChuLnBhcmVuTCk/KHQudmFsdWU9dGhpcy5wYXJzZUV4cHJlc3Npb24oKSx0aGlzLmV4cGVjdChuLnBhcmVuUiksdGhpcy5maW5pc2hOb2RlKHQsXCJEZWNsYXJlZFByZWRpY2F0ZVwiKSk6dGhpcy5maW5pc2hOb2RlKHQsXCJJbmZlcnJlZFByZWRpY2F0ZVwiKX1mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlSW5pdGlhbGlzZXIoKXtjb25zdCB0PXRoaXMuc3RhdGUuaW5UeXBlO3RoaXMuc3RhdGUuaW5UeXBlPSEwLHRoaXMuZXhwZWN0KG4uY29sb24pO2xldCBlPW51bGwscz1udWxsO3JldHVybiB0aGlzLm1hdGNoKG4ubW9kdWxvKT8odGhpcy5zdGF0ZS5pblR5cGU9dCxzPXRoaXMuZmxvd1BhcnNlUHJlZGljYXRlKCkpOihlPXRoaXMuZmxvd1BhcnNlVHlwZSgpLHRoaXMuc3RhdGUuaW5UeXBlPXQsdGhpcy5tYXRjaChuLm1vZHVsbykmJihzPXRoaXMuZmxvd1BhcnNlUHJlZGljYXRlKCkpKSxbZSxzXX1mbG93UGFyc2VEZWNsYXJlQ2xhc3ModCl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKHQsITApLHRoaXMuZmluaXNoTm9kZSh0LFwiRGVjbGFyZUNsYXNzXCIpfWZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbih0KXt0aGlzLm5leHQoKTtjb25zdCBlPXQuaWQ9dGhpcy5wYXJzZUlkZW50aWZpZXIoKSxzPXRoaXMuc3RhcnROb2RlKCksaT10aGlzLnN0YXJ0Tm9kZSgpO3RoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKT9zLnR5cGVQYXJhbWV0ZXJzPXRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk6cy50eXBlUGFyYW1ldGVycz1udWxsLHRoaXMuZXhwZWN0KG4ucGFyZW5MKTtjb25zdCByPXRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7cmV0dXJuIHMucGFyYW1zPXIucGFyYW1zLHMucmVzdD1yLnJlc3QsdGhpcy5leHBlY3Qobi5wYXJlblIpLFtzLnJldHVyblR5cGUsdC5wcmVkaWNhdGVdPXRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCksaS50eXBlQW5ub3RhdGlvbj10aGlzLmZpbmlzaE5vZGUocyxcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiksZS50eXBlQW5ub3RhdGlvbj10aGlzLmZpbmlzaE5vZGUoaSxcIlR5cGVBbm5vdGF0aW9uXCIpLHRoaXMucmVzZXRFbmRMb2NhdGlvbihlKSx0aGlzLnNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZSh0LFwiRGVjbGFyZUZ1bmN0aW9uXCIpfWZsb3dQYXJzZURlY2xhcmUodCxlKXtpZih0aGlzLm1hdGNoKG4uX2NsYXNzKSlyZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlQ2xhc3ModCk7aWYodGhpcy5tYXRjaChuLl9mdW5jdGlvbikpcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUZ1bmN0aW9uKHQpO2lmKHRoaXMubWF0Y2gobi5fdmFyKSlyZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUodCk7aWYodGhpcy5lYXRDb250ZXh0dWFsKFwibW9kdWxlXCIpKXJldHVybiB0aGlzLm1hdGNoKG4uZG90KT90aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzKHQpOihlJiZ0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0LGouTmVzdGVkRGVjbGFyZU1vZHVsZSksdGhpcy5mbG93UGFyc2VEZWNsYXJlTW9kdWxlKHQpKTtpZih0aGlzLmlzQ29udGV4dHVhbChcInR5cGVcIikpcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZVR5cGVBbGlhcyh0KTtpZih0aGlzLmlzQ29udGV4dHVhbChcIm9wYXF1ZVwiKSlyZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlT3BhcXVlVHlwZSh0KTtpZih0aGlzLmlzQ29udGV4dHVhbChcImludGVyZmFjZVwiKSlyZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlSW50ZXJmYWNlKHQpO2lmKHRoaXMubWF0Y2gobi5fZXhwb3J0KSlyZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24odCxlKTt0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKX1mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUodCl7cmV0dXJuIHRoaXMubmV4dCgpLHQuaWQ9dGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGFibGVJZGVudGlmaWVyKCEwKSx0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKHQuaWQubmFtZSw1LHQuaWQuc3RhcnQpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKHQsXCJEZWNsYXJlVmFyaWFibGVcIil9Zmxvd1BhcnNlRGVjbGFyZU1vZHVsZSh0KXt0aGlzLnNjb3BlLmVudGVyKDApLHRoaXMubWF0Y2gobi5zdHJpbmcpP3QuaWQ9dGhpcy5wYXJzZUV4cHJBdG9tKCk6dC5pZD10aGlzLnBhcnNlSWRlbnRpZmllcigpO2NvbnN0IGU9dC5ib2R5PXRoaXMuc3RhcnROb2RlKCkscz1lLmJvZHk9W107Zm9yKHRoaXMuZXhwZWN0KG4uYnJhY2VMKTshdGhpcy5tYXRjaChuLmJyYWNlUik7KXtsZXQgdD10aGlzLnN0YXJ0Tm9kZSgpO3RoaXMubWF0Y2gobi5faW1wb3J0KT8odGhpcy5uZXh0KCksdGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpfHx0aGlzLm1hdGNoKG4uX3R5cGVvZil8fHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsai5JbnZhbGlkTm9uVHlwZUltcG9ydEluRGVjbGFyZU1vZHVsZSksdGhpcy5wYXJzZUltcG9ydCh0KSk6KHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImRlY2xhcmVcIixqLlVuc3VwcG9ydGVkU3RhdGVtZW50SW5EZWNsYXJlTW9kdWxlKSx0PXRoaXMuZmxvd1BhcnNlRGVjbGFyZSh0LCEwKSkscy5wdXNoKHQpfXRoaXMuc2NvcGUuZXhpdCgpLHRoaXMuZXhwZWN0KG4uYnJhY2VSKSx0aGlzLmZpbmlzaE5vZGUoZSxcIkJsb2NrU3RhdGVtZW50XCIpO2xldCBpPW51bGwscj0hMTtyZXR1cm4gcy5mb3JFYWNoKHQ9PnshZnVuY3Rpb24odCl7cmV0dXJuXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIj09PXQudHlwZXx8XCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIj09PXQudHlwZSYmKCF0LmRlY2xhcmF0aW9ufHxcIlR5cGVBbGlhc1wiIT09dC5kZWNsYXJhdGlvbi50eXBlJiZcIkludGVyZmFjZURlY2xhcmF0aW9uXCIhPT10LmRlY2xhcmF0aW9uLnR5cGUpfSh0KT9cIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCI9PT10LnR5cGUmJihyJiZ0aGlzLnJhaXNlKHQuc3RhcnQsai5EdXBsaWNhdGVEZWNsYXJlTW9kdWxlRXhwb3J0cyksXCJFU1wiPT09aSYmdGhpcy5yYWlzZSh0LnN0YXJ0LGouQW1iaWd1b3VzRGVjbGFyZU1vZHVsZUtpbmQpLGk9XCJDb21tb25KU1wiLHI9ITApOihcIkNvbW1vbkpTXCI9PT1pJiZ0aGlzLnJhaXNlKHQuc3RhcnQsai5BbWJpZ3VvdXNEZWNsYXJlTW9kdWxlS2luZCksaT1cIkVTXCIpfSksdC5raW5kPWl8fFwiQ29tbW9uSlNcIix0aGlzLmZpbmlzaE5vZGUodCxcIkRlY2xhcmVNb2R1bGVcIil9Zmxvd1BhcnNlRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKHQsZSl7aWYodGhpcy5leHBlY3Qobi5fZXhwb3J0KSx0aGlzLmVhdChuLl9kZWZhdWx0KSlyZXR1cm4gdGhpcy5tYXRjaChuLl9mdW5jdGlvbil8fHRoaXMubWF0Y2gobi5fY2xhc3MpP3QuZGVjbGFyYXRpb249dGhpcy5mbG93UGFyc2VEZWNsYXJlKHRoaXMuc3RhcnROb2RlKCkpOih0LmRlY2xhcmF0aW9uPXRoaXMuZmxvd1BhcnNlVHlwZSgpLHRoaXMuc2VtaWNvbG9uKCkpLHQuZGVmYXVsdD0hMCx0aGlzLmZpbmlzaE5vZGUodCxcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiKTtpZih0aGlzLm1hdGNoKG4uX2NvbnN0KXx8dGhpcy5pc0xldCgpfHwodGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpfHx0aGlzLmlzQ29udGV4dHVhbChcImludGVyZmFjZVwiKSkmJiFlKXtjb25zdCB0PXRoaXMuc3RhdGUudmFsdWUsZT1WW3RdO3Rocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxqLlVuc3VwcG9ydGVkRGVjbGFyZUV4cG9ydEtpbmQsdCxlKX1pZih0aGlzLm1hdGNoKG4uX3Zhcil8fHRoaXMubWF0Y2gobi5fZnVuY3Rpb24pfHx0aGlzLm1hdGNoKG4uX2NsYXNzKXx8dGhpcy5pc0NvbnRleHR1YWwoXCJvcGFxdWVcIikpcmV0dXJuIHQuZGVjbGFyYXRpb249dGhpcy5mbG93UGFyc2VEZWNsYXJlKHRoaXMuc3RhcnROb2RlKCkpLHQuZGVmYXVsdD0hMSx0aGlzLmZpbmlzaE5vZGUodCxcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiKTtpZih0aGlzLm1hdGNoKG4uc3Rhcil8fHRoaXMubWF0Y2gobi5icmFjZUwpfHx0aGlzLmlzQ29udGV4dHVhbChcImludGVyZmFjZVwiKXx8dGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpfHx0aGlzLmlzQ29udGV4dHVhbChcIm9wYXF1ZVwiKSlyZXR1cm5cIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIj09PSh0PXRoaXMucGFyc2VFeHBvcnQodCkpLnR5cGUmJih0LnR5cGU9XCJFeHBvcnREZWNsYXJhdGlvblwiLHQuZGVmYXVsdD0hMSxkZWxldGUgdC5leHBvcnRLaW5kKSx0LnR5cGU9XCJEZWNsYXJlXCIrdC50eXBlLHQ7dGhyb3cgdGhpcy51bmV4cGVjdGVkKCl9Zmxvd1BhcnNlRGVjbGFyZU1vZHVsZUV4cG9ydHModCl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImV4cG9ydHNcIiksdC50eXBlQW5ub3RhdGlvbj10aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCksdGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUodCxcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIpfWZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXModCl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuZmxvd1BhcnNlVHlwZUFsaWFzKHQpLHQudHlwZT1cIkRlY2xhcmVUeXBlQWxpYXNcIix0fWZsb3dQYXJzZURlY2xhcmVPcGFxdWVUeXBlKHQpe3JldHVybiB0aGlzLm5leHQoKSx0aGlzLmZsb3dQYXJzZU9wYXF1ZVR5cGUodCwhMCksdC50eXBlPVwiRGVjbGFyZU9wYXF1ZVR5cGVcIix0fWZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2UodCl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKHQpLHRoaXMuZmluaXNoTm9kZSh0LFwiRGVjbGFyZUludGVyZmFjZVwiKX1mbG93UGFyc2VJbnRlcmZhY2Vpc2godCxlPSExKXtpZih0LmlkPXRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoIWUsITApLHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUodC5pZC5uYW1lLGU/MTc6OSx0LmlkLnN0YXJ0KSx0aGlzLmlzUmVsYXRpb25hbChcIjxcIik/dC50eXBlUGFyYW1ldGVycz10aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpOnQudHlwZVBhcmFtZXRlcnM9bnVsbCx0LmV4dGVuZHM9W10sdC5pbXBsZW1lbnRzPVtdLHQubWl4aW5zPVtdLHRoaXMuZWF0KG4uX2V4dGVuZHMpKWRve3QuZXh0ZW5kcy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKX13aGlsZSghZSYmdGhpcy5lYXQobi5jb21tYSkpO2lmKHRoaXMuaXNDb250ZXh0dWFsKFwibWl4aW5zXCIpKXt0aGlzLm5leHQoKTtkb3t0Lm1peGlucy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKX13aGlsZSh0aGlzLmVhdChuLmNvbW1hKSl9aWYodGhpcy5pc0NvbnRleHR1YWwoXCJpbXBsZW1lbnRzXCIpKXt0aGlzLm5leHQoKTtkb3t0LmltcGxlbWVudHMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSl9d2hpbGUodGhpcy5lYXQobi5jb21tYSkpfXQuYm9keT10aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe2FsbG93U3RhdGljOmUsYWxsb3dFeGFjdDohMSxhbGxvd1NwcmVhZDohMSxhbGxvd1Byb3RvOmUsYWxsb3dJbmV4YWN0OiExfSl9Zmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC5pZD10aGlzLmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKCksdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpP3QudHlwZVBhcmFtZXRlcnM9dGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpOnQudHlwZVBhcmFtZXRlcnM9bnVsbCx0aGlzLmZpbmlzaE5vZGUodCxcIkludGVyZmFjZUV4dGVuZHNcIil9Zmxvd1BhcnNlSW50ZXJmYWNlKHQpe3JldHVybiB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaCh0KSx0aGlzLmZpbmlzaE5vZGUodCxcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpfWNoZWNrTm90VW5kZXJzY29yZSh0KXtcIl9cIj09PXQmJnRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxqLlVuZXhwZWN0ZWRSZXNlcnZlZFVuZGVyc2NvcmUpfWNoZWNrUmVzZXJ2ZWRUeXBlKHQsZSxzKXtfLmhhcyh0KSYmdGhpcy5yYWlzZShlLHM/ai5Bc3NpZ25SZXNlcnZlZFR5cGU6ai5VbmV4cGVjdGVkUmVzZXJ2ZWRUeXBlLHQpfWZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHQsZSl7cmV0dXJuIHRoaXMuY2hlY2tSZXNlcnZlZFR5cGUodGhpcy5zdGF0ZS52YWx1ZSx0aGlzLnN0YXRlLnN0YXJ0LGUpLHRoaXMucGFyc2VJZGVudGlmaWVyKHQpfWZsb3dQYXJzZVR5cGVBbGlhcyh0KXtyZXR1cm4gdC5pZD10aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCExLCEwKSx0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKHQuaWQubmFtZSw5LHQuaWQuc3RhcnQpLHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKT90LnR5cGVQYXJhbWV0ZXJzPXRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk6dC50eXBlUGFyYW1ldGVycz1udWxsLHQucmlnaHQ9dGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIobi5lcSksdGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUodCxcIlR5cGVBbGlhc1wiKX1mbG93UGFyc2VPcGFxdWVUeXBlKHQsZSl7cmV0dXJuIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcInR5cGVcIiksdC5pZD10aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCEwLCEwKSx0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKHQuaWQubmFtZSw5LHQuaWQuc3RhcnQpLHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKT90LnR5cGVQYXJhbWV0ZXJzPXRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk6dC50eXBlUGFyYW1ldGVycz1udWxsLHQuc3VwZXJ0eXBlPW51bGwsdGhpcy5tYXRjaChuLmNvbG9uKSYmKHQuc3VwZXJ0eXBlPXRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKG4uY29sb24pKSx0LmltcGx0eXBlPW51bGwsZXx8KHQuaW1wbHR5cGU9dGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIobi5lcSkpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKHQsXCJPcGFxdWVUeXBlXCIpfWZsb3dQYXJzZVR5cGVQYXJhbWV0ZXIodD0hMSl7Y29uc3QgZT10aGlzLnN0YXRlLnN0YXJ0LHM9dGhpcy5zdGFydE5vZGUoKSxpPXRoaXMuZmxvd1BhcnNlVmFyaWFuY2UoKSxyPXRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcigpO3JldHVybiBzLm5hbWU9ci5uYW1lLHMudmFyaWFuY2U9aSxzLmJvdW5kPXIudHlwZUFubm90YXRpb24sdGhpcy5tYXRjaChuLmVxKT8odGhpcy5lYXQobi5lcSkscy5kZWZhdWx0PXRoaXMuZmxvd1BhcnNlVHlwZSgpKTp0JiZ0aGlzLnJhaXNlKGUsai5NaXNzaW5nVHlwZVBhcmFtRGVmYXVsdCksdGhpcy5maW5pc2hOb2RlKHMsXCJUeXBlUGFyYW1ldGVyXCIpfWZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5pblR5cGUsZT10aGlzLnN0YXJ0Tm9kZSgpO2UucGFyYW1zPVtdLHRoaXMuc3RhdGUuaW5UeXBlPSEwLHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKXx8dGhpcy5tYXRjaChuLmpzeFRhZ1N0YXJ0KT90aGlzLm5leHQoKTp0aGlzLnVuZXhwZWN0ZWQoKTtsZXQgcz0hMTtkb3tjb25zdCB0PXRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlcihzKTtlLnBhcmFtcy5wdXNoKHQpLHQuZGVmYXVsdCYmKHM9ITApLHRoaXMuaXNSZWxhdGlvbmFsKFwiPlwiKXx8dGhpcy5leHBlY3Qobi5jb21tYSl9d2hpbGUoIXRoaXMuaXNSZWxhdGlvbmFsKFwiPlwiKSk7cmV0dXJuIHRoaXMuZXhwZWN0UmVsYXRpb25hbChcIj5cIiksdGhpcy5zdGF0ZS5pblR5cGU9dCx0aGlzLmZpbmlzaE5vZGUoZSxcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKX1mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKSxlPXRoaXMuc3RhdGUuaW5UeXBlO3QucGFyYW1zPVtdLHRoaXMuc3RhdGUuaW5UeXBlPSEwLHRoaXMuZXhwZWN0UmVsYXRpb25hbChcIjxcIik7Y29uc3Qgcz10aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtmb3IodGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU9ITE7IXRoaXMuaXNSZWxhdGlvbmFsKFwiPlwiKTspdC5wYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGUoKSksdGhpcy5pc1JlbGF0aW9uYWwoXCI+XCIpfHx0aGlzLmV4cGVjdChuLmNvbW1hKTtyZXR1cm4gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU9cyx0aGlzLmV4cGVjdFJlbGF0aW9uYWwoXCI+XCIpLHRoaXMuc3RhdGUuaW5UeXBlPWUsdGhpcy5maW5pc2hOb2RlKHQsXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKX1mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKSxlPXRoaXMuc3RhdGUuaW5UeXBlO2Zvcih0LnBhcmFtcz1bXSx0aGlzLnN0YXRlLmluVHlwZT0hMCx0aGlzLmV4cGVjdFJlbGF0aW9uYWwoXCI8XCIpOyF0aGlzLmlzUmVsYXRpb25hbChcIj5cIik7KXQucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VUeXBlT3JJbXBsaWNpdEluc3RhbnRpYXRpb24oKSksdGhpcy5pc1JlbGF0aW9uYWwoXCI+XCIpfHx0aGlzLmV4cGVjdChuLmNvbW1hKTtyZXR1cm4gdGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPlwiKSx0aGlzLnN0YXRlLmluVHlwZT1lLHRoaXMuZmluaXNoTm9kZSh0LFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIil9Zmxvd1BhcnNlSW50ZXJmYWNlVHlwZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtpZih0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJpbnRlcmZhY2VcIiksdC5leHRlbmRzPVtdLHRoaXMuZWF0KG4uX2V4dGVuZHMpKWRve3QuZXh0ZW5kcy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKX13aGlsZSh0aGlzLmVhdChuLmNvbW1hKSk7cmV0dXJuIHQuYm9keT10aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe2FsbG93U3RhdGljOiExLGFsbG93RXhhY3Q6ITEsYWxsb3dTcHJlYWQ6ITEsYWxsb3dQcm90bzohMSxhbGxvd0luZXhhY3Q6ITF9KSx0aGlzLmZpbmlzaE5vZGUodCxcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIpfWZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5KCl7cmV0dXJuIHRoaXMubWF0Y2gobi5udW0pfHx0aGlzLm1hdGNoKG4uc3RyaW5nKT90aGlzLnBhcnNlRXhwckF0b20oKTp0aGlzLnBhcnNlSWRlbnRpZmllcighMCl9Zmxvd1BhcnNlT2JqZWN0VHlwZUluZGV4ZXIodCxlLHMpe3JldHVybiB0LnN0YXRpYz1lLHRoaXMubG9va2FoZWFkKCkudHlwZT09PW4uY29sb24/KHQuaWQ9dGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpLHQua2V5PXRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCkpOih0LmlkPW51bGwsdC5rZXk9dGhpcy5mbG93UGFyc2VUeXBlKCkpLHRoaXMuZXhwZWN0KG4uYnJhY2tldFIpLHQudmFsdWU9dGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKSx0LnZhcmlhbmNlPXMsdGhpcy5maW5pc2hOb2RlKHQsXCJPYmplY3RUeXBlSW5kZXhlclwiKX1mbG93UGFyc2VPYmplY3RUeXBlSW50ZXJuYWxTbG90KHQsZSl7cmV0dXJuIHQuc3RhdGljPWUsdC5pZD10aGlzLmZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5KCksdGhpcy5leHBlY3Qobi5icmFja2V0UiksdGhpcy5leHBlY3Qobi5icmFja2V0UiksdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpfHx0aGlzLm1hdGNoKG4ucGFyZW5MKT8odC5tZXRob2Q9ITAsdC5vcHRpb25hbD0hMSx0LnZhbHVlPXRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZGlzaCh0aGlzLnN0YXJ0Tm9kZUF0KHQuc3RhcnQsdC5sb2Muc3RhcnQpKSk6KHQubWV0aG9kPSExLHRoaXMuZWF0KG4ucXVlc3Rpb24pJiYodC5vcHRpb25hbD0hMCksdC52YWx1ZT10aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpKSx0aGlzLmZpbmlzaE5vZGUodCxcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIil9Zmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZGlzaCh0KXtmb3IodC5wYXJhbXM9W10sdC5yZXN0PW51bGwsdC50eXBlUGFyYW1ldGVycz1udWxsLHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSYmKHQudHlwZVBhcmFtZXRlcnM9dGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKSksdGhpcy5leHBlY3Qobi5wYXJlbkwpOyF0aGlzLm1hdGNoKG4ucGFyZW5SKSYmIXRoaXMubWF0Y2gobi5lbGxpcHNpcyk7KXQucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpKSx0aGlzLm1hdGNoKG4ucGFyZW5SKXx8dGhpcy5leHBlY3Qobi5jb21tYSk7cmV0dXJuIHRoaXMuZWF0KG4uZWxsaXBzaXMpJiYodC5yZXN0PXRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oKSksdGhpcy5leHBlY3Qobi5wYXJlblIpLHQucmV0dXJuVHlwZT10aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpLHRoaXMuZmluaXNoTm9kZSh0LFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKX1mbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5KHQsZSl7Y29uc3Qgcz10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0LnN0YXRpYz1lLHQudmFsdWU9dGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHMpLHRoaXMuZmluaXNoTm9kZSh0LFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiKX1mbG93UGFyc2VPYmplY3RUeXBlKHthbGxvd1N0YXRpYzp0LGFsbG93RXhhY3Q6ZSxhbGxvd1NwcmVhZDpzLGFsbG93UHJvdG86aSxhbGxvd0luZXhhY3Q6cn0pe2NvbnN0IGE9dGhpcy5zdGF0ZS5pblR5cGU7dGhpcy5zdGF0ZS5pblR5cGU9ITA7Y29uc3Qgbz10aGlzLnN0YXJ0Tm9kZSgpO2xldCBoLHA7by5jYWxsUHJvcGVydGllcz1bXSxvLnByb3BlcnRpZXM9W10sby5pbmRleGVycz1bXSxvLmludGVybmFsU2xvdHM9W107bGV0IGM9ITE7Zm9yKGUmJnRoaXMubWF0Y2gobi5icmFjZUJhckwpPyh0aGlzLmV4cGVjdChuLmJyYWNlQmFyTCksaD1uLmJyYWNlQmFyUixwPSEwKToodGhpcy5leHBlY3Qobi5icmFjZUwpLGg9bi5icmFjZVIscD0hMSksby5leGFjdD1wOyF0aGlzLm1hdGNoKGgpOyl7bGV0IGU9ITEsYT1udWxsLGg9bnVsbDtjb25zdCB1PXRoaXMuc3RhcnROb2RlKCk7aWYoaSYmdGhpcy5pc0NvbnRleHR1YWwoXCJwcm90b1wiKSl7Y29uc3QgZT10aGlzLmxvb2thaGVhZCgpO2UudHlwZSE9PW4uY29sb24mJmUudHlwZSE9PW4ucXVlc3Rpb24mJih0aGlzLm5leHQoKSxhPXRoaXMuc3RhdGUuc3RhcnQsdD0hMSl9aWYodCYmdGhpcy5pc0NvbnRleHR1YWwoXCJzdGF0aWNcIikpe2NvbnN0IHQ9dGhpcy5sb29rYWhlYWQoKTt0LnR5cGUhPT1uLmNvbG9uJiZ0LnR5cGUhPT1uLnF1ZXN0aW9uJiYodGhpcy5uZXh0KCksZT0hMCl9Y29uc3QgbD10aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7aWYodGhpcy5lYXQobi5icmFja2V0TCkpbnVsbCE9YSYmdGhpcy51bmV4cGVjdGVkKGEpLHRoaXMuZWF0KG4uYnJhY2tldEwpPyhsJiZ0aGlzLnVuZXhwZWN0ZWQobC5zdGFydCksby5pbnRlcm5hbFNsb3RzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlSW50ZXJuYWxTbG90KHUsZSkpKTpvLmluZGV4ZXJzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlSW5kZXhlcih1LGUsbCkpO2Vsc2UgaWYodGhpcy5tYXRjaChuLnBhcmVuTCl8fHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSludWxsIT1hJiZ0aGlzLnVuZXhwZWN0ZWQoYSksbCYmdGhpcy51bmV4cGVjdGVkKGwuc3RhcnQpLG8uY2FsbFByb3BlcnRpZXMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVDYWxsUHJvcGVydHkodSxlKSk7ZWxzZXtsZXQgdD1cImluaXRcIjtpZih0aGlzLmlzQ29udGV4dHVhbChcImdldFwiKXx8dGhpcy5pc0NvbnRleHR1YWwoXCJzZXRcIikpe2NvbnN0IGU9dGhpcy5sb29rYWhlYWQoKTtlLnR5cGUhPT1uLm5hbWUmJmUudHlwZSE9PW4uc3RyaW5nJiZlLnR5cGUhPT1uLm51bXx8KHQ9dGhpcy5zdGF0ZS52YWx1ZSx0aGlzLm5leHQoKSl9Y29uc3QgaT10aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVQcm9wZXJ0eSh1LGUsYSxsLHQscyxudWxsIT1yP3I6IXApO251bGw9PT1pPyhjPSEwLGg9dGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQpOm8ucHJvcGVydGllcy5wdXNoKGkpfXRoaXMuZmxvd09iamVjdFR5cGVTZW1pY29sb24oKSwhaHx8dGhpcy5tYXRjaChuLmJyYWNlUil8fHRoaXMubWF0Y2gobi5icmFjZUJhclIpfHx0aGlzLnJhaXNlKGgsai5VbmV4cGVjdGVkRXhwbGljaXRJbmV4YWN0SW5PYmplY3QpfXRoaXMuZXhwZWN0KGgpLHMmJihvLmluZXhhY3Q9Yyk7Y29uc3QgdT10aGlzLmZpbmlzaE5vZGUobyxcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpO3JldHVybiB0aGlzLnN0YXRlLmluVHlwZT1hLHV9Zmxvd1BhcnNlT2JqZWN0VHlwZVByb3BlcnR5KHQsZSxzLGkscixhLG8pe2lmKHRoaXMuZWF0KG4uZWxsaXBzaXMpKXtyZXR1cm4gdGhpcy5tYXRjaChuLmNvbW1hKXx8dGhpcy5tYXRjaChuLnNlbWkpfHx0aGlzLm1hdGNoKG4uYnJhY2VSKXx8dGhpcy5tYXRjaChuLmJyYWNlQmFyUik/KGE/b3x8dGhpcy5yYWlzZSh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCxqLkluZXhhY3RJbnNpZGVFeGFjdCk6dGhpcy5yYWlzZSh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCxqLkluZXhhY3RJbnNpZGVOb25PYmplY3QpLGkmJnRoaXMucmFpc2UoaS5zdGFydCxqLkluZXhhY3RWYXJpYW5jZSksbnVsbCk6KGF8fHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsai5VbmV4cGVjdGVkU3ByZWFkVHlwZSksbnVsbCE9cyYmdGhpcy51bmV4cGVjdGVkKHMpLGkmJnRoaXMucmFpc2UoaS5zdGFydCxqLlNwcmVhZFZhcmlhbmNlKSx0LmFyZ3VtZW50PXRoaXMuZmxvd1BhcnNlVHlwZSgpLHRoaXMuZmluaXNoTm9kZSh0LFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIpKX17dC5rZXk9dGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpLHQuc3RhdGljPWUsdC5wcm90bz1udWxsIT1zLHQua2luZD1yO2xldCBhPSExO3JldHVybiB0aGlzLmlzUmVsYXRpb25hbChcIjxcIil8fHRoaXMubWF0Y2gobi5wYXJlbkwpPyh0Lm1ldGhvZD0hMCxudWxsIT1zJiZ0aGlzLnVuZXhwZWN0ZWQocyksaSYmdGhpcy51bmV4cGVjdGVkKGkuc3RhcnQpLHQudmFsdWU9dGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHRoaXMuc3RhcnROb2RlQXQodC5zdGFydCx0LmxvYy5zdGFydCkpLFwiZ2V0XCIhPT1yJiZcInNldFwiIT09cnx8dGhpcy5mbG93Q2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXModCkpOihcImluaXRcIiE9PXImJnRoaXMudW5leHBlY3RlZCgpLHQubWV0aG9kPSExLHRoaXMuZWF0KG4ucXVlc3Rpb24pJiYoYT0hMCksdC52YWx1ZT10aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpLHQudmFyaWFuY2U9aSksdC5vcHRpb25hbD1hLHRoaXMuZmluaXNoTm9kZSh0LFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpfX1mbG93Q2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXModCl7Y29uc3QgZT1cImdldFwiPT09dC5raW5kPzA6MSxzPXQuc3RhcnQ7dC52YWx1ZS5wYXJhbXMubGVuZ3RoKyh0LnZhbHVlLnJlc3Q/MTowKSE9PWUmJihcImdldFwiPT09dC5raW5kP3RoaXMucmFpc2UocyxmLkJhZEdldHRlckFyaXR5KTp0aGlzLnJhaXNlKHMsZi5CYWRTZXR0ZXJBcml0eSkpLFwic2V0XCI9PT10LmtpbmQmJnQudmFsdWUucmVzdCYmdGhpcy5yYWlzZShzLGYuQmFkU2V0dGVyUmVzdFBhcmFtZXRlcil9Zmxvd09iamVjdFR5cGVTZW1pY29sb24oKXt0aGlzLmVhdChuLnNlbWkpfHx0aGlzLmVhdChuLmNvbW1hKXx8dGhpcy5tYXRjaChuLmJyYWNlUil8fHRoaXMubWF0Y2gobi5icmFjZUJhclIpfHx0aGlzLnVuZXhwZWN0ZWQoKX1mbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcih0LGUscyl7dD10fHx0aGlzLnN0YXRlLnN0YXJ0LGU9ZXx8dGhpcy5zdGF0ZS5zdGFydExvYztsZXQgaT1zfHx0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCEwKTtmb3IoO3RoaXMuZWF0KG4uZG90KTspe2NvbnN0IHM9dGhpcy5zdGFydE5vZGVBdCh0LGUpO3MucXVhbGlmaWNhdGlvbj1pLHMuaWQ9dGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcighMCksaT10aGlzLmZpbmlzaE5vZGUocyxcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIpfXJldHVybiBpfWZsb3dQYXJzZUdlbmVyaWNUeXBlKHQsZSxzKXtjb25zdCBpPXRoaXMuc3RhcnROb2RlQXQodCxlKTtyZXR1cm4gaS50eXBlUGFyYW1ldGVycz1udWxsLGkuaWQ9dGhpcy5mbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcih0LGUscyksdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpJiYoaS50eXBlUGFyYW1ldGVycz10aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCkpLHRoaXMuZmluaXNoTm9kZShpLFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIpfWZsb3dQYXJzZVR5cGVvZlR5cGUoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMuZXhwZWN0KG4uX3R5cGVvZiksdC5hcmd1bWVudD10aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCksdGhpcy5maW5pc2hOb2RlKHQsXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiKX1mbG93UGFyc2VUdXBsZVR5cGUoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7Zm9yKHQudHlwZXM9W10sdGhpcy5leHBlY3Qobi5icmFja2V0TCk7dGhpcy5zdGF0ZS5wb3M8dGhpcy5sZW5ndGgmJiF0aGlzLm1hdGNoKG4uYnJhY2tldFIpJiYodC50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlVHlwZSgpKSwhdGhpcy5tYXRjaChuLmJyYWNrZXRSKSk7KXRoaXMuZXhwZWN0KG4uY29tbWEpO3JldHVybiB0aGlzLmV4cGVjdChuLmJyYWNrZXRSKSx0aGlzLmZpbmlzaE5vZGUodCxcIlR1cGxlVHlwZUFubm90YXRpb25cIil9Zmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oKXtsZXQgdD1udWxsLGU9ITEscz1udWxsO2NvbnN0IGk9dGhpcy5zdGFydE5vZGUoKSxyPXRoaXMubG9va2FoZWFkKCk7cmV0dXJuIHIudHlwZT09PW4uY29sb258fHIudHlwZT09PW4ucXVlc3Rpb24/KHQ9dGhpcy5wYXJzZUlkZW50aWZpZXIoKSx0aGlzLmVhdChuLnF1ZXN0aW9uKSYmKGU9ITApLHM9dGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKSk6cz10aGlzLmZsb3dQYXJzZVR5cGUoKSxpLm5hbWU9dCxpLm9wdGlvbmFsPWUsaS50eXBlQW5ub3RhdGlvbj1zLHRoaXMuZmluaXNoTm9kZShpLFwiRnVuY3Rpb25UeXBlUGFyYW1cIil9cmVpbnRlcnByZXRUeXBlQXNGdW5jdGlvblR5cGVQYXJhbSh0KXtjb25zdCBlPXRoaXMuc3RhcnROb2RlQXQodC5zdGFydCx0LmxvYy5zdGFydCk7cmV0dXJuIGUubmFtZT1udWxsLGUub3B0aW9uYWw9ITEsZS50eXBlQW5ub3RhdGlvbj10LHRoaXMuZmluaXNoTm9kZShlLFwiRnVuY3Rpb25UeXBlUGFyYW1cIil9Zmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKHQ9W10pe2xldCBlPW51bGw7Zm9yKDshdGhpcy5tYXRjaChuLnBhcmVuUikmJiF0aGlzLm1hdGNoKG4uZWxsaXBzaXMpOyl0LnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSgpKSx0aGlzLm1hdGNoKG4ucGFyZW5SKXx8dGhpcy5leHBlY3Qobi5jb21tYSk7cmV0dXJuIHRoaXMuZWF0KG4uZWxsaXBzaXMpJiYoZT10aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKCkpLHtwYXJhbXM6dCxyZXN0OmV9fWZsb3dJZGVudFRvVHlwZUFubm90YXRpb24odCxlLHMsaSl7c3dpdGNoKGkubmFtZSl7Y2FzZVwiYW55XCI6cmV0dXJuIHRoaXMuZmluaXNoTm9kZShzLFwiQW55VHlwZUFubm90YXRpb25cIik7Y2FzZVwiYm9vbFwiOmNhc2VcImJvb2xlYW5cIjpyZXR1cm4gdGhpcy5maW5pc2hOb2RlKHMsXCJCb29sZWFuVHlwZUFubm90YXRpb25cIik7Y2FzZVwibWl4ZWRcIjpyZXR1cm4gdGhpcy5maW5pc2hOb2RlKHMsXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIpO2Nhc2VcImVtcHR5XCI6cmV0dXJuIHRoaXMuZmluaXNoTm9kZShzLFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiKTtjYXNlXCJudW1iZXJcIjpyZXR1cm4gdGhpcy5maW5pc2hOb2RlKHMsXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiKTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gdGhpcy5maW5pc2hOb2RlKHMsXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiKTtjYXNlXCJzeW1ib2xcIjpyZXR1cm4gdGhpcy5maW5pc2hOb2RlKHMsXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiKTtkZWZhdWx0OnJldHVybiB0aGlzLmNoZWNrTm90VW5kZXJzY29yZShpLm5hbWUpLHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUodCxlLGkpfX1mbG93UGFyc2VQcmltYXJ5VHlwZSgpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5zdGFydCxlPXRoaXMuc3RhdGUuc3RhcnRMb2Mscz10aGlzLnN0YXJ0Tm9kZSgpO2xldCBpLHIsYT0hMTtjb25zdCBvPXRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlO3N3aXRjaCh0aGlzLnN0YXRlLnR5cGUpe2Nhc2Ugbi5uYW1lOnJldHVybiB0aGlzLmlzQ29udGV4dHVhbChcImludGVyZmFjZVwiKT90aGlzLmZsb3dQYXJzZUludGVyZmFjZVR5cGUoKTp0aGlzLmZsb3dJZGVudFRvVHlwZUFubm90YXRpb24odCxlLHMsdGhpcy5wYXJzZUlkZW50aWZpZXIoKSk7Y2FzZSBuLmJyYWNlTDpyZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHthbGxvd1N0YXRpYzohMSxhbGxvd0V4YWN0OiExLGFsbG93U3ByZWFkOiEwLGFsbG93UHJvdG86ITEsYWxsb3dJbmV4YWN0OiEwfSk7Y2FzZSBuLmJyYWNlQmFyTDpyZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHthbGxvd1N0YXRpYzohMSxhbGxvd0V4YWN0OiEwLGFsbG93U3ByZWFkOiEwLGFsbG93UHJvdG86ITEsYWxsb3dJbmV4YWN0OiExfSk7Y2FzZSBuLmJyYWNrZXRMOnJldHVybiB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZT0hMSxyPXRoaXMuZmxvd1BhcnNlVHVwbGVUeXBlKCksdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU9byxyO2Nhc2Ugbi5yZWxhdGlvbmFsOmlmKFwiPFwiPT09dGhpcy5zdGF0ZS52YWx1ZSlyZXR1cm4gcy50eXBlUGFyYW1ldGVycz10aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpLHRoaXMuZXhwZWN0KG4ucGFyZW5MKSxpPXRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCkscy5wYXJhbXM9aS5wYXJhbXMscy5yZXN0PWkucmVzdCx0aGlzLmV4cGVjdChuLnBhcmVuUiksdGhpcy5leHBlY3Qobi5hcnJvdykscy5yZXR1cm5UeXBlPXRoaXMuZmxvd1BhcnNlVHlwZSgpLHRoaXMuZmluaXNoTm9kZShzLFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTticmVhaztjYXNlIG4ucGFyZW5MOmlmKHRoaXMubmV4dCgpLCF0aGlzLm1hdGNoKG4ucGFyZW5SKSYmIXRoaXMubWF0Y2gobi5lbGxpcHNpcykpaWYodGhpcy5tYXRjaChuLm5hbWUpKXtjb25zdCB0PXRoaXMubG9va2FoZWFkKCkudHlwZTthPXQhPT1uLnF1ZXN0aW9uJiZ0IT09bi5jb2xvbn1lbHNlIGE9ITA7aWYoYSl7aWYodGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU9ITEscj10aGlzLmZsb3dQYXJzZVR5cGUoKSx0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZT1vLHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlfHwhKHRoaXMubWF0Y2gobi5jb21tYSl8fHRoaXMubWF0Y2gobi5wYXJlblIpJiZ0aGlzLmxvb2thaGVhZCgpLnR5cGU9PT1uLmFycm93KSlyZXR1cm4gdGhpcy5leHBlY3Qobi5wYXJlblIpLHI7dGhpcy5lYXQobi5jb21tYSl9cmV0dXJuIGk9cj90aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcyhbdGhpcy5yZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHIpXSk6dGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbXMoKSxzLnBhcmFtcz1pLnBhcmFtcyxzLnJlc3Q9aS5yZXN0LHRoaXMuZXhwZWN0KG4ucGFyZW5SKSx0aGlzLmV4cGVjdChuLmFycm93KSxzLnJldHVyblR5cGU9dGhpcy5mbG93UGFyc2VUeXBlKCkscy50eXBlUGFyYW1ldGVycz1udWxsLHRoaXMuZmluaXNoTm9kZShzLFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtjYXNlIG4uc3RyaW5nOnJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO2Nhc2Ugbi5fdHJ1ZTpjYXNlIG4uX2ZhbHNlOnJldHVybiBzLnZhbHVlPXRoaXMubWF0Y2gobi5fdHJ1ZSksdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKHMsXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO2Nhc2Ugbi5wbHVzTWluOmlmKFwiLVwiPT09dGhpcy5zdGF0ZS52YWx1ZSl7aWYodGhpcy5uZXh0KCksdGhpcy5tYXRjaChuLm51bSkpcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKC10aGlzLnN0YXRlLnZhbHVlLFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIscy5zdGFydCxzLmxvYy5zdGFydCk7aWYodGhpcy5tYXRjaChuLmJpZ2ludCkpcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKC10aGlzLnN0YXRlLnZhbHVlLFwiQmlnSW50TGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIscy5zdGFydCxzLmxvYy5zdGFydCk7dGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGouVW5leHBlY3RlZFN1YnRyYWN0aW9uT3BlcmFuZCl9dGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7Y2FzZSBuLm51bTpyZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSxcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtjYXNlIG4uYmlnaW50OnJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLFwiQmlnSW50TGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO2Nhc2Ugbi5fdm9pZDpyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKHMsXCJWb2lkVHlwZUFubm90YXRpb25cIik7Y2FzZSBuLl9udWxsOnJldHVybiB0aGlzLm5leHQoKSx0aGlzLmZpbmlzaE5vZGUocyxcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIik7Y2FzZSBuLl90aGlzOnJldHVybiB0aGlzLm5leHQoKSx0aGlzLmZpbmlzaE5vZGUocyxcIlRoaXNUeXBlQW5ub3RhdGlvblwiKTtjYXNlIG4uc3RhcjpyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKHMsXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiKTtkZWZhdWx0OmlmKFwidHlwZW9mXCI9PT10aGlzLnN0YXRlLnR5cGUua2V5d29yZClyZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlb2ZUeXBlKCk7aWYodGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpe2NvbnN0IHQ9dGhpcy5zdGF0ZS50eXBlLmxhYmVsO3JldHVybiB0aGlzLm5leHQoKSxzdXBlci5jcmVhdGVJZGVudGlmaWVyKHMsdCl9fXRocm93IHRoaXMudW5leHBlY3RlZCgpfWZsb3dQYXJzZVBvc3RmaXhUeXBlKCl7Y29uc3QgdD10aGlzLnN0YXRlLnN0YXJ0LGU9dGhpcy5zdGF0ZS5zdGFydExvYztsZXQgcz10aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7Zm9yKDt0aGlzLm1hdGNoKG4uYnJhY2tldEwpJiYhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTspe2NvbnN0IGk9dGhpcy5zdGFydE5vZGVBdCh0LGUpO2kuZWxlbWVudFR5cGU9cyx0aGlzLmV4cGVjdChuLmJyYWNrZXRMKSx0aGlzLmV4cGVjdChuLmJyYWNrZXRSKSxzPXRoaXMuZmluaXNoTm9kZShpLFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiKX1yZXR1cm4gc31mbG93UGFyc2VQcmVmaXhUeXBlKCl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLmVhdChuLnF1ZXN0aW9uKT8odC50eXBlQW5ub3RhdGlvbj10aGlzLmZsb3dQYXJzZVByZWZpeFR5cGUoKSx0aGlzLmZpbmlzaE5vZGUodCxcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIikpOnRoaXMuZmxvd1BhcnNlUG9zdGZpeFR5cGUoKX1mbG93UGFyc2VBbm9uRnVuY3Rpb25XaXRob3V0UGFyZW5zKCl7Y29uc3QgdD10aGlzLmZsb3dQYXJzZVByZWZpeFR5cGUoKTtpZighdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUmJnRoaXMuZWF0KG4uYXJyb3cpKXtjb25zdCBlPXRoaXMuc3RhcnROb2RlQXQodC5zdGFydCx0LmxvYy5zdGFydCk7cmV0dXJuIGUucGFyYW1zPVt0aGlzLnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0odCldLGUucmVzdD1udWxsLGUucmV0dXJuVHlwZT10aGlzLmZsb3dQYXJzZVR5cGUoKSxlLnR5cGVQYXJhbWV0ZXJzPW51bGwsdGhpcy5maW5pc2hOb2RlKGUsXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpfXJldHVybiB0fWZsb3dQYXJzZUludGVyc2VjdGlvblR5cGUoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7dGhpcy5lYXQobi5iaXR3aXNlQU5EKTtjb25zdCBlPXRoaXMuZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpO2Zvcih0LnR5cGVzPVtlXTt0aGlzLmVhdChuLmJpdHdpc2VBTkQpOyl0LnR5cGVzLnB1c2godGhpcy5mbG93UGFyc2VBbm9uRnVuY3Rpb25XaXRob3V0UGFyZW5zKCkpO3JldHVybiAxPT09dC50eXBlcy5sZW5ndGg/ZTp0aGlzLmZpbmlzaE5vZGUodCxcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIpfWZsb3dQYXJzZVVuaW9uVHlwZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTt0aGlzLmVhdChuLmJpdHdpc2VPUik7Y29uc3QgZT10aGlzLmZsb3dQYXJzZUludGVyc2VjdGlvblR5cGUoKTtmb3IodC50eXBlcz1bZV07dGhpcy5lYXQobi5iaXR3aXNlT1IpOyl0LnR5cGVzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcnNlY3Rpb25UeXBlKCkpO3JldHVybiAxPT09dC50eXBlcy5sZW5ndGg/ZTp0aGlzLmZpbmlzaE5vZGUodCxcIlVuaW9uVHlwZUFubm90YXRpb25cIil9Zmxvd1BhcnNlVHlwZSgpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5pblR5cGU7dGhpcy5zdGF0ZS5pblR5cGU9ITA7Y29uc3QgZT10aGlzLmZsb3dQYXJzZVVuaW9uVHlwZSgpO3JldHVybiB0aGlzLnN0YXRlLmluVHlwZT10LHRoaXMuc3RhdGUuZXhwckFsbG93ZWQ9dGhpcy5zdGF0ZS5leHByQWxsb3dlZHx8dGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUsZX1mbG93UGFyc2VUeXBlT3JJbXBsaWNpdEluc3RhbnRpYXRpb24oKXtpZih0aGlzLnN0YXRlLnR5cGU9PT1uLm5hbWUmJlwiX1wiPT09dGhpcy5zdGF0ZS52YWx1ZSl7Y29uc3QgdD10aGlzLnN0YXRlLnN0YXJ0LGU9dGhpcy5zdGF0ZS5zdGFydExvYyxzPXRoaXMucGFyc2VJZGVudGlmaWVyKCk7cmV0dXJuIHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUodCxlLHMpfXJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGUoKX1mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC50eXBlQW5ub3RhdGlvbj10aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpLHRoaXMuZmluaXNoTm9kZSh0LFwiVHlwZUFubm90YXRpb25cIil9Zmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcih0KXtjb25zdCBlPXQ/dGhpcy5wYXJzZUlkZW50aWZpZXIoKTp0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCk7cmV0dXJuIHRoaXMubWF0Y2gobi5jb2xvbikmJihlLnR5cGVBbm5vdGF0aW9uPXRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKSx0aGlzLnJlc2V0RW5kTG9jYXRpb24oZSkpLGV9dHlwZUNhc3RUb1BhcmFtZXRlcih0KXtyZXR1cm4gdC5leHByZXNzaW9uLnR5cGVBbm5vdGF0aW9uPXQudHlwZUFubm90YXRpb24sdGhpcy5yZXNldEVuZExvY2F0aW9uKHQuZXhwcmVzc2lvbix0LnR5cGVBbm5vdGF0aW9uLmVuZCx0LnR5cGVBbm5vdGF0aW9uLmxvYy5lbmQpLHQuZXhwcmVzc2lvbn1mbG93UGFyc2VWYXJpYW5jZSgpe2xldCB0PW51bGw7cmV0dXJuIHRoaXMubWF0Y2gobi5wbHVzTWluKSYmKHQ9dGhpcy5zdGFydE5vZGUoKSxcIitcIj09PXRoaXMuc3RhdGUudmFsdWU/dC5raW5kPVwicGx1c1wiOnQua2luZD1cIm1pbnVzXCIsdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKHQsXCJWYXJpYW5jZVwiKSksdH1wYXJzZUZ1bmN0aW9uQm9keSh0LGUscz0hMSl7cmV0dXJuIGU/dGhpcy5mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdCh0LCgpPT5zdXBlci5wYXJzZUZ1bmN0aW9uQm9keSh0LCEwLHMpKTpzdXBlci5wYXJzZUZ1bmN0aW9uQm9keSh0LCExLHMpfXBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKHQsZSxzPSExKXtpZih0aGlzLm1hdGNoKG4uY29sb24pKXtjb25zdCBlPXRoaXMuc3RhcnROb2RlKCk7W2UudHlwZUFubm90YXRpb24sdC5wcmVkaWNhdGVdPXRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCksdC5yZXR1cm5UeXBlPWUudHlwZUFubm90YXRpb24/dGhpcy5maW5pc2hOb2RlKGUsXCJUeXBlQW5ub3RhdGlvblwiKTpudWxsfXN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKHQsZSxzKX1wYXJzZVN0YXRlbWVudCh0LGUpe2lmKHRoaXMuc3RhdGUuc3RyaWN0JiZ0aGlzLm1hdGNoKG4ubmFtZSkmJlwiaW50ZXJmYWNlXCI9PT10aGlzLnN0YXRlLnZhbHVlKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlKHQpfWlmKHRoaXMuc2hvdWxkUGFyc2VFbnVtcygpJiZ0aGlzLmlzQ29udGV4dHVhbChcImVudW1cIikpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24odCl9e2NvbnN0IHM9c3VwZXIucGFyc2VTdGF0ZW1lbnQodCxlKTtyZXR1cm4gdm9pZCAwIT09dGhpcy5mbG93UHJhZ21hfHx0aGlzLmlzVmFsaWREaXJlY3RpdmUocyl8fCh0aGlzLmZsb3dQcmFnbWE9bnVsbCksc319cGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KHQsZSl7aWYoXCJJZGVudGlmaWVyXCI9PT1lLnR5cGUpaWYoXCJkZWNsYXJlXCI9PT1lLm5hbWUpe2lmKHRoaXMubWF0Y2gobi5fY2xhc3MpfHx0aGlzLm1hdGNoKG4ubmFtZSl8fHRoaXMubWF0Y2gobi5fZnVuY3Rpb24pfHx0aGlzLm1hdGNoKG4uX3Zhcil8fHRoaXMubWF0Y2gobi5fZXhwb3J0KSlyZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlKHQpfWVsc2UgaWYodGhpcy5tYXRjaChuLm5hbWUpKXtpZihcImludGVyZmFjZVwiPT09ZS5uYW1lKXJldHVybiB0aGlzLmZsb3dQYXJzZUludGVyZmFjZSh0KTtpZihcInR5cGVcIj09PWUubmFtZSlyZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlQWxpYXModCk7aWYoXCJvcGFxdWVcIj09PWUubmFtZSlyZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKHQsITEpfXJldHVybiBzdXBlci5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQodCxlKX1zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCl7cmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKFwidHlwZVwiKXx8dGhpcy5pc0NvbnRleHR1YWwoXCJpbnRlcmZhY2VcIil8fHRoaXMuaXNDb250ZXh0dWFsKFwib3BhcXVlXCIpfHx0aGlzLnNob3VsZFBhcnNlRW51bXMoKSYmdGhpcy5pc0NvbnRleHR1YWwoXCJlbnVtXCIpfHxzdXBlci5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCl9aXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCl7cmV0dXJuKCF0aGlzLm1hdGNoKG4ubmFtZSl8fCEoXCJ0eXBlXCI9PT10aGlzLnN0YXRlLnZhbHVlfHxcImludGVyZmFjZVwiPT09dGhpcy5zdGF0ZS52YWx1ZXx8XCJvcGFxdWVcIj09PXRoaXMuc3RhdGUudmFsdWV8fHRoaXMuc2hvdWxkUGFyc2VFbnVtcygpJiZcImVudW1cIj09PXRoaXMuc3RhdGUudmFsdWUpKSYmc3VwZXIuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCl9cGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpe2lmKHRoaXMuc2hvdWxkUGFyc2VFbnVtcygpJiZ0aGlzLmlzQ29udGV4dHVhbChcImVudW1cIikpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24odCl9cmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKX1wYXJzZUNvbmRpdGlvbmFsKHQsZSxzLGkscil7aWYoIXRoaXMubWF0Y2gobi5xdWVzdGlvbikpcmV0dXJuIHQ7aWYocil7Y29uc3QgYT10aGlzLnRyeVBhcnNlKCgpPT5zdXBlci5wYXJzZUNvbmRpdGlvbmFsKHQsZSxzLGkpKTtyZXR1cm4gYS5ub2RlPyhhLmVycm9yJiYodGhpcy5zdGF0ZT1hLmZhaWxTdGF0ZSksYS5ub2RlKTooci5zdGFydD1hLmVycm9yLnBvc3x8dGhpcy5zdGF0ZS5zdGFydCx0KX10aGlzLmV4cGVjdChuLnF1ZXN0aW9uKTtjb25zdCBhPXRoaXMuc3RhdGUuY2xvbmUoKSxvPXRoaXMuc3RhdGUubm9BcnJvd0F0LGg9dGhpcy5zdGFydE5vZGVBdChzLGkpO2xldHtjb25zZXF1ZW50OnAsZmFpbGVkOmN9PXRoaXMudHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKSxbdSxsXT10aGlzLmdldEFycm93TGlrZUV4cHJlc3Npb25zKHApO2lmKGN8fGwubGVuZ3RoPjApe2NvbnN0IHQ9Wy4uLm9dO2lmKGwubGVuZ3RoPjApe3RoaXMuc3RhdGU9YSx0aGlzLnN0YXRlLm5vQXJyb3dBdD10O2ZvcihsZXQgZT0wO2U8bC5sZW5ndGg7ZSsrKXQucHVzaChsW2VdLnN0YXJ0KTsoe2NvbnNlcXVlbnQ6cCxmYWlsZWQ6Y309dGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpKSxbdSxsXT10aGlzLmdldEFycm93TGlrZUV4cHJlc3Npb25zKHApfWMmJnUubGVuZ3RoPjEmJnRoaXMucmFpc2UoYS5zdGFydCxqLkFtYmlndW91c0NvbmRpdGlvbmFsQXJyb3cpLGMmJjE9PT11Lmxlbmd0aCYmKHRoaXMuc3RhdGU9YSx0aGlzLnN0YXRlLm5vQXJyb3dBdD10LmNvbmNhdCh1WzBdLnN0YXJ0KSwoe2NvbnNlcXVlbnQ6cCxmYWlsZWQ6Y309dGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpKSl9cmV0dXJuIHRoaXMuZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMocCwhMCksdGhpcy5zdGF0ZS5ub0Fycm93QXQ9byx0aGlzLmV4cGVjdChuLmNvbG9uKSxoLnRlc3Q9dCxoLmNvbnNlcXVlbnQ9cCxoLmFsdGVybmF0ZT10aGlzLmZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KGgsKCk9PnRoaXMucGFyc2VNYXliZUFzc2lnbihlLHZvaWQgMCx2b2lkIDAsdm9pZCAwKSksdGhpcy5maW5pc2hOb2RlKGgsXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIil9dHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKXt0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucHVzaCh0aGlzLnN0YXRlLnN0YXJ0KTtjb25zdCB0PXRoaXMucGFyc2VNYXliZUFzc2lnbigpLGU9IXRoaXMubWF0Y2gobi5jb2xvbik7cmV0dXJuIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wb3AoKSx7Y29uc2VxdWVudDp0LGZhaWxlZDplfX1nZXRBcnJvd0xpa2VFeHByZXNzaW9ucyh0LGUpe2NvbnN0IHM9W3RdLGk9W107Zm9yKDswIT09cy5sZW5ndGg7KXtjb25zdCB0PXMucG9wKCk7XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiPT09dC50eXBlPyh0LnR5cGVQYXJhbWV0ZXJzfHwhdC5yZXR1cm5UeXBlP3RoaXMuZmluaXNoQXJyb3dWYWxpZGF0aW9uKHQpOmkucHVzaCh0KSxzLnB1c2godC5ib2R5KSk6XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIj09PXQudHlwZSYmKHMucHVzaCh0LmNvbnNlcXVlbnQpLHMucHVzaCh0LmFsdGVybmF0ZSkpfXJldHVybiBlPyhpLmZvckVhY2godD0+dGhpcy5maW5pc2hBcnJvd1ZhbGlkYXRpb24odCkpLFtpLFtdXSk6ZnVuY3Rpb24odCxlKXtjb25zdCBzPVtdLGk9W107Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspKGUodFtyXSxyLHQpP3M6aSkucHVzaCh0W3JdKTtyZXR1cm5bcyxpXX0oaSx0PT50LnBhcmFtcy5ldmVyeSh0PT50aGlzLmlzQXNzaWduYWJsZSh0LCEwKSkpfWZpbmlzaEFycm93VmFsaWRhdGlvbih0KXt2YXIgZTt0aGlzLnRvQXNzaWduYWJsZUxpc3QodC5wYXJhbXMsbnVsbD09KGU9dC5leHRyYSk/dm9pZCAwOmUudHJhaWxpbmdDb21tYSksdGhpcy5zY29wZS5lbnRlcig2KSxzdXBlci5jaGVja1BhcmFtcyh0LCExLCEwKSx0aGlzLnNjb3BlLmV4aXQoKX1mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdCh0LGUpe2xldCBzO3JldHVybi0xIT09dGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LmluZGV4T2YodC5zdGFydCk/KHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wdXNoKHRoaXMuc3RhdGUuc3RhcnQpLHM9ZSgpLHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wb3AoKSk6cz1lKCksc31wYXJzZVBhcmVuSXRlbSh0LGUscyl7aWYodD1zdXBlci5wYXJzZVBhcmVuSXRlbSh0LGUscyksdGhpcy5lYXQobi5xdWVzdGlvbikmJih0Lm9wdGlvbmFsPSEwLHRoaXMucmVzZXRFbmRMb2NhdGlvbih0KSksdGhpcy5tYXRjaChuLmNvbG9uKSl7Y29uc3QgaT10aGlzLnN0YXJ0Tm9kZUF0KGUscyk7cmV0dXJuIGkuZXhwcmVzc2lvbj10LGkudHlwZUFubm90YXRpb249dGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpLHRoaXMuZmluaXNoTm9kZShpLFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpfXJldHVybiB0fWFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKHQpe1wiSW1wb3J0RGVjbGFyYXRpb25cIj09PXQudHlwZSYmKFwidHlwZVwiPT09dC5pbXBvcnRLaW5kfHxcInR5cGVvZlwiPT09dC5pbXBvcnRLaW5kKXx8XCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI9PT10LnR5cGUmJlwidHlwZVwiPT09dC5leHBvcnRLaW5kfHxcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI9PT10LnR5cGUmJlwidHlwZVwiPT09dC5leHBvcnRLaW5kfHxzdXBlci5hc3NlcnRNb2R1bGVOb2RlQWxsb3dlZCh0KX1wYXJzZUV4cG9ydCh0KXtjb25zdCBlPXN1cGVyLnBhcnNlRXhwb3J0KHQpO3JldHVyblwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiIT09ZS50eXBlJiZcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIhPT1lLnR5cGV8fChlLmV4cG9ydEtpbmQ9ZS5leHBvcnRLaW5kfHxcInZhbHVlXCIpLGV9cGFyc2VFeHBvcnREZWNsYXJhdGlvbih0KXtpZih0aGlzLmlzQ29udGV4dHVhbChcInR5cGVcIikpe3QuZXhwb3J0S2luZD1cInR5cGVcIjtjb25zdCBlPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMubWF0Y2gobi5icmFjZUwpPyh0LnNwZWNpZmllcnM9dGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoKSx0aGlzLnBhcnNlRXhwb3J0RnJvbSh0KSxudWxsKTp0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhlKX1pZih0aGlzLmlzQ29udGV4dHVhbChcIm9wYXF1ZVwiKSl7dC5leHBvcnRLaW5kPVwidHlwZVwiO2NvbnN0IGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKGUsITEpfWlmKHRoaXMuaXNDb250ZXh0dWFsKFwiaW50ZXJmYWNlXCIpKXt0LmV4cG9ydEtpbmQ9XCJ0eXBlXCI7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSx0aGlzLmZsb3dQYXJzZUludGVyZmFjZShlKX1pZih0aGlzLnNob3VsZFBhcnNlRW51bXMoKSYmdGhpcy5pc0NvbnRleHR1YWwoXCJlbnVtXCIpKXt0LmV4cG9ydEtpbmQ9XCJ2YWx1ZVwiO2NvbnN0IGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24oZSl9cmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24odCl9ZWF0RXhwb3J0U3Rhcih0KXtyZXR1cm4hIXN1cGVyLmVhdEV4cG9ydFN0YXIoLi4uYXJndW1lbnRzKXx8ISghdGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpfHx0aGlzLmxvb2thaGVhZCgpLnR5cGUhPT1uLnN0YXIpJiYodC5leHBvcnRLaW5kPVwidHlwZVwiLHRoaXMubmV4dCgpLHRoaXMubmV4dCgpLCEwKX1tYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS5zdGFydCxzPXN1cGVyLm1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIodCk7cmV0dXJuIHMmJlwidHlwZVwiPT09dC5leHBvcnRLaW5kJiZ0aGlzLnVuZXhwZWN0ZWQoZSksc31wYXJzZUNsYXNzSWQodCxlLHMpe3N1cGVyLnBhcnNlQ2xhc3NJZCh0LGUscyksdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpJiYodC50eXBlUGFyYW1ldGVycz10aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKX1wYXJzZUNsYXNzTWVtYmVyKHQsZSxzLGkpe2NvbnN0IHI9dGhpcy5zdGF0ZS5zdGFydDtpZih0aGlzLmlzQ29udGV4dHVhbChcImRlY2xhcmVcIikpe2lmKHRoaXMucGFyc2VDbGFzc01lbWJlckZyb21Nb2RpZmllcih0LGUpKXJldHVybjtlLmRlY2xhcmU9ITB9c3VwZXIucGFyc2VDbGFzc01lbWJlcih0LGUscyxpKSxlLmRlY2xhcmUmJihcIkNsYXNzUHJvcGVydHlcIiE9PWUudHlwZSYmXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiIT09ZS50eXBlP3RoaXMucmFpc2UocixqLkRlY2xhcmVDbGFzc0VsZW1lbnQpOmUudmFsdWUmJnRoaXMucmFpc2UoZS52YWx1ZS5zdGFydCxqLkRlY2xhcmVDbGFzc0ZpZWxkSW5pdGlhbGl6ZXIpKX1nZXRUb2tlbkZyb21Db2RlKHQpe2NvbnN0IGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpO3JldHVybiAxMjM9PT10JiYxMjQ9PT1lP3RoaXMuZmluaXNoT3Aobi5icmFjZUJhckwsMik6IXRoaXMuc3RhdGUuaW5UeXBlfHw2MiE9PXQmJjYwIT09dD9mdW5jdGlvbih0LGUpe3JldHVybiA2ND09PXQmJjY0PT09ZX0odCxlKT8odGhpcy5zdGF0ZS5pc0l0ZXJhdG9yPSEwLHN1cGVyLnJlYWRXb3JkKCkpOnN1cGVyLmdldFRva2VuRnJvbUNvZGUodCk6dGhpcy5maW5pc2hPcChuLnJlbGF0aW9uYWwsMSl9aXNBc3NpZ25hYmxlKHQsZSl7c3dpdGNoKHQudHlwZSl7Y2FzZVwiSWRlbnRpZmllclwiOmNhc2VcIk9iamVjdFBhdHRlcm5cIjpjYXNlXCJBcnJheVBhdHRlcm5cIjpjYXNlXCJBc3NpZ25tZW50UGF0dGVyblwiOnJldHVybiEwO2Nhc2VcIk9iamVjdEV4cHJlc3Npb25cIjp7Y29uc3QgZT10LnByb3BlcnRpZXMubGVuZ3RoLTE7cmV0dXJuIHQucHJvcGVydGllcy5ldmVyeSgodCxzKT0+XCJPYmplY3RNZXRob2RcIiE9PXQudHlwZSYmKHM9PT1lfHxcIlNwcmVhZEVsZW1lbnRcIj09PXQudHlwZSkmJnRoaXMuaXNBc3NpZ25hYmxlKHQpKX1jYXNlXCJPYmplY3RQcm9wZXJ0eVwiOnJldHVybiB0aGlzLmlzQXNzaWduYWJsZSh0LnZhbHVlKTtjYXNlXCJTcHJlYWRFbGVtZW50XCI6cmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKHQuYXJndW1lbnQpO2Nhc2VcIkFycmF5RXhwcmVzc2lvblwiOnJldHVybiB0LmVsZW1lbnRzLmV2ZXJ5KHQ9PnRoaXMuaXNBc3NpZ25hYmxlKHQpKTtjYXNlXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOnJldHVyblwiPVwiPT09dC5vcGVyYXRvcjtjYXNlXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOmNhc2VcIlR5cGVDYXN0RXhwcmVzc2lvblwiOnJldHVybiB0aGlzLmlzQXNzaWduYWJsZSh0LmV4cHJlc3Npb24pO2Nhc2VcIk1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpyZXR1cm4hZTtkZWZhdWx0OnJldHVybiExfX10b0Fzc2lnbmFibGUodCl7cmV0dXJuXCJUeXBlQ2FzdEV4cHJlc3Npb25cIj09PXQudHlwZT9zdXBlci50b0Fzc2lnbmFibGUodGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKHQpKTpzdXBlci50b0Fzc2lnbmFibGUodCl9dG9Bc3NpZ25hYmxlTGlzdCh0LGUpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBzPXRbZV07cyYmXCJUeXBlQ2FzdEV4cHJlc3Npb25cIj09PXMudHlwZSYmKHRbZV09dGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKHMpKX1yZXR1cm4gc3VwZXIudG9Bc3NpZ25hYmxlTGlzdCh0LGUpfXRvUmVmZXJlbmNlZExpc3QodCxlKXtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl7Y29uc3QgaT10W3NdOyFpfHxcIlR5cGVDYXN0RXhwcmVzc2lvblwiIT09aS50eXBlfHxpLmV4dHJhJiZpLmV4dHJhLnBhcmVudGhlc2l6ZWR8fCEodC5sZW5ndGg+MSkmJmV8fHRoaXMucmFpc2UoaS50eXBlQW5ub3RhdGlvbi5zdGFydCxqLlR5cGVDYXN0SW5QYXR0ZXJuKX1yZXR1cm4gdH1jaGVja0xWYWwodCxlPTY0LHMsaSl7aWYoXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiE9PXQudHlwZSlyZXR1cm4gc3VwZXIuY2hlY2tMVmFsKHQsZSxzLGkpfXBhcnNlQ2xhc3NQcm9wZXJ0eSh0KXtyZXR1cm4gdGhpcy5tYXRjaChuLmNvbG9uKSYmKHQudHlwZUFubm90YXRpb249dGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpKSxzdXBlci5wYXJzZUNsYXNzUHJvcGVydHkodCl9cGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eSh0KXtyZXR1cm4gdGhpcy5tYXRjaChuLmNvbG9uKSYmKHQudHlwZUFubm90YXRpb249dGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpKSxzdXBlci5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KHQpfWlzQ2xhc3NNZXRob2QoKXtyZXR1cm4gdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpfHxzdXBlci5pc0NsYXNzTWV0aG9kKCl9aXNDbGFzc1Byb3BlcnR5KCl7cmV0dXJuIHRoaXMubWF0Y2gobi5jb2xvbil8fHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpfWlzTm9uc3RhdGljQ29uc3RydWN0b3IodCl7cmV0dXJuIXRoaXMubWF0Y2gobi5jb2xvbikmJnN1cGVyLmlzTm9uc3RhdGljQ29uc3RydWN0b3IodCl9cHVzaENsYXNzTWV0aG9kKHQsZSxzLGkscixhKXtlLnZhcmlhbmNlJiZ0aGlzLnVuZXhwZWN0ZWQoZS52YXJpYW5jZS5zdGFydCksZGVsZXRlIGUudmFyaWFuY2UsdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpJiYoZS50eXBlUGFyYW1ldGVycz10aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSxzdXBlci5wdXNoQ2xhc3NNZXRob2QodCxlLHMsaSxyLGEpfXB1c2hDbGFzc1ByaXZhdGVNZXRob2QodCxlLHMsaSl7ZS52YXJpYW5jZSYmdGhpcy51bmV4cGVjdGVkKGUudmFyaWFuY2Uuc3RhcnQpLGRlbGV0ZSBlLnZhcmlhbmNlLHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSYmKGUudHlwZVBhcmFtZXRlcnM9dGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKSksc3VwZXIucHVzaENsYXNzUHJpdmF0ZU1ldGhvZCh0LGUscyxpKX1wYXJzZUNsYXNzU3VwZXIodCl7aWYoc3VwZXIucGFyc2VDbGFzc1N1cGVyKHQpLHQuc3VwZXJDbGFzcyYmdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpJiYodC5zdXBlclR5cGVQYXJhbWV0ZXJzPXRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKSksdGhpcy5pc0NvbnRleHR1YWwoXCJpbXBsZW1lbnRzXCIpKXt0aGlzLm5leHQoKTtjb25zdCBlPXQuaW1wbGVtZW50cz1bXTtkb3tjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7dC5pZD10aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCEwKSx0aGlzLmlzUmVsYXRpb25hbChcIjxcIik/dC50eXBlUGFyYW1ldGVycz10aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk6dC50eXBlUGFyYW1ldGVycz1udWxsLGUucHVzaCh0aGlzLmZpbmlzaE5vZGUodCxcIkNsYXNzSW1wbGVtZW50c1wiKSl9d2hpbGUodGhpcy5lYXQobi5jb21tYSkpfX1wYXJzZVByb3BlcnR5TmFtZSh0LGUpe2NvbnN0IHM9dGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpLGk9c3VwZXIucGFyc2VQcm9wZXJ0eU5hbWUodCxlKTtyZXR1cm4gdC52YXJpYW5jZT1zLGl9cGFyc2VPYmpQcm9wVmFsdWUodCxlLHMsaSxyLGEsbyxoKXtsZXQgcDt0LnZhcmlhbmNlJiZ0aGlzLnVuZXhwZWN0ZWQodC52YXJpYW5jZS5zdGFydCksZGVsZXRlIHQudmFyaWFuY2UsdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpJiYocD10aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpLHRoaXMubWF0Y2gobi5wYXJlbkwpfHx0aGlzLnVuZXhwZWN0ZWQoKSksc3VwZXIucGFyc2VPYmpQcm9wVmFsdWUodCxlLHMsaSxyLGEsbyxoKSxwJiYoKHQudmFsdWV8fHQpLnR5cGVQYXJhbWV0ZXJzPXApfXBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXModCl7cmV0dXJuIHRoaXMuZWF0KG4ucXVlc3Rpb24pJiYoXCJJZGVudGlmaWVyXCIhPT10LnR5cGUmJnRoaXMucmFpc2UodC5zdGFydCxqLk9wdGlvbmFsQmluZGluZ1BhdHRlcm4pLHQub3B0aW9uYWw9ITApLHRoaXMubWF0Y2gobi5jb2xvbikmJih0LnR5cGVBbm5vdGF0aW9uPXRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKSksdGhpcy5yZXNldEVuZExvY2F0aW9uKHQpLHR9cGFyc2VNYXliZURlZmF1bHQodCxlLHMpe2NvbnN0IGk9c3VwZXIucGFyc2VNYXliZURlZmF1bHQodCxlLHMpO3JldHVyblwiQXNzaWdubWVudFBhdHRlcm5cIj09PWkudHlwZSYmaS50eXBlQW5ub3RhdGlvbiYmaS5yaWdodC5zdGFydDxpLnR5cGVBbm5vdGF0aW9uLnN0YXJ0JiZ0aGlzLnJhaXNlKGkudHlwZUFubm90YXRpb24uc3RhcnQsai5UeXBlQmVmb3JlSW5pdGlhbGl6ZXIpLGl9c2hvdWxkUGFyc2VEZWZhdWx0SW1wb3J0KHQpe3JldHVybiBVKHQpP3EodGhpcy5zdGF0ZSk6c3VwZXIuc2hvdWxkUGFyc2VEZWZhdWx0SW1wb3J0KHQpfXBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwodCxlLHMsaSl7ZS5sb2NhbD1VKHQpP3RoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoITAsITApOnRoaXMucGFyc2VJZGVudGlmaWVyKCksdGhpcy5jaGVja0xWYWwoZS5sb2NhbCw5LHZvaWQgMCxpKSx0LnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZSxzKSl9bWF5YmVQYXJzZURlZmF1bHRJbXBvcnRTcGVjaWZpZXIodCl7dC5pbXBvcnRLaW5kPVwidmFsdWVcIjtsZXQgZT1udWxsO2lmKHRoaXMubWF0Y2gobi5fdHlwZW9mKT9lPVwidHlwZW9mXCI6dGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpJiYoZT1cInR5cGVcIiksZSl7Y29uc3Qgcz10aGlzLmxvb2thaGVhZCgpO1widHlwZVwiPT09ZSYmcy50eXBlPT09bi5zdGFyJiZ0aGlzLnVuZXhwZWN0ZWQocy5zdGFydCksKHEocyl8fHMudHlwZT09PW4uYnJhY2VMfHxzLnR5cGU9PT1uLnN0YXIpJiYodGhpcy5uZXh0KCksdC5pbXBvcnRLaW5kPWUpfXJldHVybiBzdXBlci5tYXliZVBhcnNlRGVmYXVsdEltcG9ydFNwZWNpZmllcih0KX1wYXJzZUltcG9ydFNwZWNpZmllcih0KXtjb25zdCBlPXRoaXMuc3RhcnROb2RlKCkscz10aGlzLnN0YXRlLnN0YXJ0LGk9dGhpcy5wYXJzZUlkZW50aWZpZXIoITApO2xldCByPW51bGw7XCJ0eXBlXCI9PT1pLm5hbWU/cj1cInR5cGVcIjpcInR5cGVvZlwiPT09aS5uYW1lJiYocj1cInR5cGVvZlwiKTtsZXQgYT0hMTtpZih0aGlzLmlzQ29udGV4dHVhbChcImFzXCIpJiYhdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJhc1wiKSl7Y29uc3QgdD10aGlzLnBhcnNlSWRlbnRpZmllcighMCk7bnVsbD09PXJ8fHRoaXMubWF0Y2gobi5uYW1lKXx8dGhpcy5zdGF0ZS50eXBlLmtleXdvcmQ/KGUuaW1wb3J0ZWQ9aSxlLmltcG9ydEtpbmQ9bnVsbCxlLmxvY2FsPXRoaXMucGFyc2VJZGVudGlmaWVyKCkpOihlLmltcG9ydGVkPXQsZS5pbXBvcnRLaW5kPXIsZS5sb2NhbD10Ll9fY2xvbmUoKSl9ZWxzZSBudWxsIT09ciYmKHRoaXMubWF0Y2gobi5uYW1lKXx8dGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpPyhlLmltcG9ydGVkPXRoaXMucGFyc2VJZGVudGlmaWVyKCEwKSxlLmltcG9ydEtpbmQ9cix0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKT9lLmxvY2FsPXRoaXMucGFyc2VJZGVudGlmaWVyKCk6KGE9ITAsZS5sb2NhbD1lLmltcG9ydGVkLl9fY2xvbmUoKSkpOihhPSEwLGUuaW1wb3J0ZWQ9aSxlLmltcG9ydEtpbmQ9bnVsbCxlLmxvY2FsPWUuaW1wb3J0ZWQuX19jbG9uZSgpKTtjb25zdCBvPVUodCksaD1VKGUpO28mJmgmJnRoaXMucmFpc2UocyxqLkltcG9ydFR5cGVTaG9ydGhhbmRPbmx5SW5QdXJlSW1wb3J0KSwob3x8aCkmJnRoaXMuY2hlY2tSZXNlcnZlZFR5cGUoZS5sb2NhbC5uYW1lLGUubG9jYWwuc3RhcnQsITApLCFhfHxvfHxofHx0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGUubG9jYWwubmFtZSxlLnN0YXJ0LCEwLCEwKSx0aGlzLmNoZWNrTFZhbChlLmxvY2FsLDksdm9pZCAwLFwiaW1wb3J0IHNwZWNpZmllclwiKSx0LnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZSxcIkltcG9ydFNwZWNpZmllclwiKSl9cGFyc2VGdW5jdGlvblBhcmFtcyh0LGUpe2NvbnN0IHM9dC5raW5kO1wiZ2V0XCIhPT1zJiZcInNldFwiIT09cyYmdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpJiYodC50eXBlUGFyYW1ldGVycz10aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSxzdXBlci5wYXJzZUZ1bmN0aW9uUGFyYW1zKHQsZSl9cGFyc2VWYXJJZCh0LGUpe3N1cGVyLnBhcnNlVmFySWQodCxlKSx0aGlzLm1hdGNoKG4uY29sb24pJiYodC5pZC50eXBlQW5ub3RhdGlvbj10aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCksdGhpcy5yZXNldEVuZExvY2F0aW9uKHQuaWQpKX1wYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24odCxlKXtpZih0aGlzLm1hdGNoKG4uY29sb24pKXtjb25zdCBlPXRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlO3RoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlPSEwLHQucmV0dXJuVHlwZT10aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCksdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU9ZX1yZXR1cm4gc3VwZXIucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKHQsZSl9c2hvdWxkUGFyc2VBc3luY0Fycm93KCl7cmV0dXJuIHRoaXMubWF0Y2gobi5jb2xvbil8fHN1cGVyLnNob3VsZFBhcnNlQXN5bmNBcnJvdygpfXBhcnNlTWF5YmVBc3NpZ24odCxlLHMsaSl7bGV0IHIsYT1udWxsO2lmKHRoaXMuaGFzUGx1Z2luKFwianN4XCIpJiYodGhpcy5tYXRjaChuLmpzeFRhZ1N0YXJ0KXx8dGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKSl7aWYoYT10aGlzLnN0YXRlLmNsb25lKCkscj10aGlzLnRyeVBhcnNlKCgpPT5zdXBlci5wYXJzZU1heWJlQXNzaWduKHQsZSxzLGkpLGEpLCFyLmVycm9yKXJldHVybiByLm5vZGU7Y29uc3R7Y29udGV4dDpufT10aGlzLnN0YXRlO25bbi5sZW5ndGgtMV09PT14Lmpfb1RhZz9uLmxlbmd0aC09MjpuW24ubGVuZ3RoLTFdPT09eC5qX2V4cHImJihuLmxlbmd0aC09MSl9aWYociYmci5lcnJvcnx8dGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKXtsZXQgbjthPWF8fHRoaXMuc3RhdGUuY2xvbmUoKTtjb25zdCBvPXRoaXMudHJ5UGFyc2UoKCk9PntuPXRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7Y29uc3Qgcj10aGlzLmZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KG4sKCk9PnN1cGVyLnBhcnNlTWF5YmVBc3NpZ24odCxlLHMsaSkpO3JldHVybiByLnR5cGVQYXJhbWV0ZXJzPW4sdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShyLG4pLHJ9LGEpLGg9by5ub2RlJiZcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI9PT1vLm5vZGUudHlwZT9vLm5vZGU6bnVsbDtpZighby5lcnJvciYmaClyZXR1cm4gaDtpZihyJiZyLm5vZGUpcmV0dXJuIHRoaXMuc3RhdGU9ci5mYWlsU3RhdGUsci5ub2RlO2lmKGgpcmV0dXJuIHRoaXMuc3RhdGU9by5mYWlsU3RhdGUsaDtpZihyJiZyLnRocm93bil0aHJvdyByLmVycm9yO2lmKG8udGhyb3duKXRocm93IG8uZXJyb3I7dGhyb3cgdGhpcy5yYWlzZShuLnN0YXJ0LGouVW5leHBlY3RlZFRva2VuQWZ0ZXJUeXBlUGFyYW1ldGVyKX1yZXR1cm4gc3VwZXIucGFyc2VNYXliZUFzc2lnbih0LGUscyxpKX1wYXJzZUFycm93KHQpe2lmKHRoaXMubWF0Y2gobi5jb2xvbikpe2NvbnN0IGU9dGhpcy50cnlQYXJzZSgoKT0+e2NvbnN0IGU9dGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7dGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU9ITA7Y29uc3Qgcz10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybltzLnR5cGVBbm5vdGF0aW9uLHQucHJlZGljYXRlXT10aGlzLmZsb3dQYXJzZVR5cGVBbmRQcmVkaWNhdGVJbml0aWFsaXNlcigpLHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlPWUsdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5tYXRjaChuLmFycm93KXx8dGhpcy51bmV4cGVjdGVkKCksc30pO2lmKGUudGhyb3duKXJldHVybiBudWxsO2UuZXJyb3ImJih0aGlzLnN0YXRlPWUuZmFpbFN0YXRlKSx0LnJldHVyblR5cGU9ZS5ub2RlLnR5cGVBbm5vdGF0aW9uP3RoaXMuZmluaXNoTm9kZShlLm5vZGUsXCJUeXBlQW5ub3RhdGlvblwiKTpudWxsfXJldHVybiBzdXBlci5wYXJzZUFycm93KHQpfXNob3VsZFBhcnNlQXJyb3coKXtyZXR1cm4gdGhpcy5tYXRjaChuLmNvbG9uKXx8c3VwZXIuc2hvdWxkUGFyc2VBcnJvdygpfXNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKHQsZSl7LTEhPT10aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5kZXhPZih0LnN0YXJ0KT90LnBhcmFtcz1lOnN1cGVyLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKHQsZSl9Y2hlY2tQYXJhbXModCxlLHMpe2lmKCFzfHwtMT09PXRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5pbmRleE9mKHQuc3RhcnQpKXJldHVybiBzdXBlci5jaGVja1BhcmFtcyguLi5hcmd1bWVudHMpfXBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24odCl7cmV0dXJuIHN1cGVyLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24odCYmLTE9PT10aGlzLnN0YXRlLm5vQXJyb3dBdC5pbmRleE9mKHRoaXMuc3RhdGUuc3RhcnQpKX1wYXJzZVN1YnNjcmlwdHModCxlLHMsaSl7aWYoXCJJZGVudGlmaWVyXCI9PT10LnR5cGUmJlwiYXN5bmNcIj09PXQubmFtZSYmLTEhPT10aGlzLnN0YXRlLm5vQXJyb3dBdC5pbmRleE9mKGUpKXt0aGlzLm5leHQoKTtjb25zdCBpPXRoaXMuc3RhcnROb2RlQXQoZSxzKTtpLmNhbGxlZT10LGkuYXJndW1lbnRzPXRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyhuLnBhcmVuUiwhMSksdD10aGlzLmZpbmlzaE5vZGUoaSxcIkNhbGxFeHByZXNzaW9uXCIpfWVsc2UgaWYoXCJJZGVudGlmaWVyXCI9PT10LnR5cGUmJlwiYXN5bmNcIj09PXQubmFtZSYmdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKXtjb25zdCByPXRoaXMuc3RhdGUuY2xvbmUoKSxhPXRoaXMudHJ5UGFyc2UodD0+dGhpcy5wYXJzZUFzeW5jQXJyb3dXaXRoVHlwZVBhcmFtZXRlcnMoZSxzKXx8dCgpLHIpO2lmKCFhLmVycm9yJiYhYS5hYm9ydGVkKXJldHVybiBhLm5vZGU7Y29uc3Qgbj10aGlzLnRyeVBhcnNlKCgpPT5zdXBlci5wYXJzZVN1YnNjcmlwdHModCxlLHMsaSkscik7aWYobi5ub2RlJiYhbi5lcnJvcilyZXR1cm4gbi5ub2RlO2lmKGEubm9kZSlyZXR1cm4gdGhpcy5zdGF0ZT1hLmZhaWxTdGF0ZSxhLm5vZGU7aWYobi5ub2RlKXJldHVybiB0aGlzLnN0YXRlPW4uZmFpbFN0YXRlLG4ubm9kZTt0aHJvdyBhLmVycm9yfHxuLmVycm9yfXJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdHModCxlLHMsaSl9cGFyc2VTdWJzY3JpcHQodCxlLHMsaSxyKXtpZih0aGlzLm1hdGNoKG4ucXVlc3Rpb25Eb3QpJiZ0aGlzLmlzTG9va2FoZWFkUmVsYXRpb25hbChcIjxcIikpe2lmKHIub3B0aW9uYWxDaGFpbk1lbWJlcj0hMCxpKXJldHVybiByLnN0b3A9ITAsdDt0aGlzLm5leHQoKTtjb25zdCBhPXRoaXMuc3RhcnROb2RlQXQoZSxzKTtyZXR1cm4gYS5jYWxsZWU9dCxhLnR5cGVBcmd1bWVudHM9dGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpLHRoaXMuZXhwZWN0KG4ucGFyZW5MKSxhLmFyZ3VtZW50cz10aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMobi5wYXJlblIsITEpLGEub3B0aW9uYWw9ITAsdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihhLCEwKX1pZighaSYmdGhpcy5zaG91bGRQYXJzZVR5cGVzKCkmJnRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSl7Y29uc3QgaT10aGlzLnN0YXJ0Tm9kZUF0KGUscyk7aS5jYWxsZWU9dDtjb25zdCBhPXRoaXMudHJ5UGFyc2UoKCk9PihpLnR5cGVBcmd1bWVudHM9dGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpLHRoaXMuZXhwZWN0KG4ucGFyZW5MKSxpLmFyZ3VtZW50cz10aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMobi5wYXJlblIsITEpLHIub3B0aW9uYWxDaGFpbk1lbWJlciYmKGkub3B0aW9uYWw9ITEpLHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24oaSxyLm9wdGlvbmFsQ2hhaW5NZW1iZXIpKSk7aWYoYS5ub2RlKXJldHVybiBhLmVycm9yJiYodGhpcy5zdGF0ZT1hLmZhaWxTdGF0ZSksYS5ub2RlfXJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdCh0LGUscyxpLHIpfXBhcnNlTmV3QXJndW1lbnRzKHQpe2xldCBlPW51bGw7dGhpcy5zaG91bGRQYXJzZVR5cGVzKCkmJnRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSYmKGU9dGhpcy50cnlQYXJzZSgoKT0+dGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkNhbGxPck5ldygpKS5ub2RlKSx0LnR5cGVBcmd1bWVudHM9ZSxzdXBlci5wYXJzZU5ld0FyZ3VtZW50cyh0KX1wYXJzZUFzeW5jQXJyb3dXaXRoVHlwZVBhcmFtZXRlcnModCxlKXtjb25zdCBzPXRoaXMuc3RhcnROb2RlQXQodCxlKTtpZih0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMocyksdGhpcy5wYXJzZUFycm93KHMpKXJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHMsdm9pZCAwLCEwKX1yZWFkVG9rZW5fbXVsdF9tb2R1bG8odCl7Y29uc3QgZT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMSk7aWYoNDI9PT10JiY0Nz09PWUmJnRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpcmV0dXJuIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQ9ITEsdGhpcy5zdGF0ZS5wb3MrPTIsdm9pZCB0aGlzLm5leHRUb2tlbigpO3N1cGVyLnJlYWRUb2tlbl9tdWx0X21vZHVsbyh0KX1yZWFkVG9rZW5fcGlwZV9hbXAodCl7Y29uc3QgZT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMSk7MTI0IT09dHx8MTI1IT09ZT9zdXBlci5yZWFkVG9rZW5fcGlwZV9hbXAodCk6dGhpcy5maW5pc2hPcChuLmJyYWNlQmFyUiwyKX1wYXJzZVRvcExldmVsKHQsZSl7Y29uc3Qgcz1zdXBlci5wYXJzZVRvcExldmVsKHQsZSk7cmV0dXJuIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQmJnRoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3Msai5VbnRlcm1pbmF0ZWRGbG93Q29tbWVudCksc31za2lwQmxvY2tDb21tZW50KCl7aWYodGhpcy5oYXNQbHVnaW4oXCJmbG93Q29tbWVudHNcIikmJnRoaXMuc2tpcEZsb3dDb21tZW50KCkpcmV0dXJuIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQmJnRoaXMudW5leHBlY3RlZChudWxsLGouTmVzdGVkRmxvd0NvbW1lbnQpLHRoaXMuaGFzRmxvd0NvbW1lbnRDb21wbGV0aW9uKCksdGhpcy5zdGF0ZS5wb3MrPXRoaXMuc2tpcEZsb3dDb21tZW50KCksdm9pZCh0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50PSEwKTtpZih0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50KXtjb25zdCB0PXRoaXMuaW5wdXQuaW5kZXhPZihcIiotL1wiLHRoaXMuc3RhdGUucG9zKz0yKTtpZigtMT09PXQpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcy0yLGYuVW50ZXJtaW5hdGVkQ29tbWVudCk7dGhpcy5zdGF0ZS5wb3M9dCszfWVsc2Ugc3VwZXIuc2tpcEJsb2NrQ29tbWVudCgpfXNraXBGbG93Q29tbWVudCgpe2NvbnN0e3Bvczp0fT10aGlzLnN0YXRlO2xldCBlPTI7Zm9yKDtbMzIsOV0uaW5jbHVkZXModGhpcy5pbnB1dC5jaGFyQ29kZUF0KHQrZSkpOyllKys7Y29uc3Qgcz10aGlzLmlucHV0LmNoYXJDb2RlQXQoZSt0KSxpPXRoaXMuaW5wdXQuY2hhckNvZGVBdChlK3QrMSk7cmV0dXJuIDU4PT09cyYmNTg9PT1pP2UrMjpcImZsb3ctaW5jbHVkZVwiPT09dGhpcy5pbnB1dC5zbGljZShlK3QsZSt0KzEyKT9lKzEyOjU4PT09cyYmNTghPT1pJiZlfWhhc0Zsb3dDb21tZW50Q29tcGxldGlvbigpe2lmKC0xPT09dGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIix0aGlzLnN0YXRlLnBvcykpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcyxmLlVudGVybWluYXRlZENvbW1lbnQpfWZsb3dFbnVtRXJyb3JCb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQodCx7ZW51bU5hbWU6ZSxtZW1iZXJOYW1lOnN9KXt0aGlzLnJhaXNlKHQsai5FbnVtQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkLHMsZSl9Zmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJOYW1lKHQse2VudW1OYW1lOmUsbWVtYmVyTmFtZTpzfSl7Y29uc3QgaT1zWzBdLnRvVXBwZXJDYXNlKCkrcy5zbGljZSgxKTt0aGlzLnJhaXNlKHQsai5FbnVtSW52YWxpZE1lbWJlck5hbWUscyxpLGUpfWZsb3dFbnVtRXJyb3JEdXBsaWNhdGVNZW1iZXJOYW1lKHQse2VudW1OYW1lOmUsbWVtYmVyTmFtZTpzfSl7dGhpcy5yYWlzZSh0LGouRW51bUR1cGxpY2F0ZU1lbWJlck5hbWUscyxlKX1mbG93RW51bUVycm9ySW5jb25zaXN0ZW50TWVtYmVyVmFsdWVzKHQse2VudW1OYW1lOmV9KXt0aGlzLnJhaXNlKHQsai5FbnVtSW5jb25zaXN0ZW50TWVtYmVyVmFsdWVzLGUpfWZsb3dFbnVtRXJyb3JJbnZhbGlkRXhwbGljaXRUeXBlKHQse2VudW1OYW1lOmUsc3VwcGxpZWRUeXBlOnN9KXtyZXR1cm4gdGhpcy5yYWlzZSh0LG51bGw9PT1zP2ouRW51bUludmFsaWRFeHBsaWNpdFR5cGVVbmtub3duU3VwcGxpZWQ6ai5FbnVtSW52YWxpZEV4cGxpY2l0VHlwZSxlLHMpfWZsb3dFbnVtRXJyb3JJbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXIodCx7ZW51bU5hbWU6ZSxleHBsaWNpdFR5cGU6cyxtZW1iZXJOYW1lOml9KXtsZXQgcj1udWxsO3N3aXRjaChzKXtjYXNlXCJib29sZWFuXCI6Y2FzZVwibnVtYmVyXCI6Y2FzZVwic3RyaW5nXCI6cj1qLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZTticmVhaztjYXNlXCJzeW1ib2xcIjpyPWouRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGU7YnJlYWs7ZGVmYXVsdDpyPWouRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclVua25vd25UeXBlfXJldHVybiB0aGlzLnJhaXNlKHQscixlLGkscyl9Zmxvd0VudW1FcnJvck51bWJlck1lbWJlck5vdEluaXRpYWxpemVkKHQse2VudW1OYW1lOmUsbWVtYmVyTmFtZTpzfSl7dGhpcy5yYWlzZSh0LGouRW51bU51bWJlck1lbWJlck5vdEluaXRpYWxpemVkLGUscyl9Zmxvd0VudW1FcnJvclN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGFpbGl6ZWQodCx7ZW51bU5hbWU6ZX0pe3RoaXMucmFpc2UodCxqLkVudW1TdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRhaWxpemVkLGUpfWZsb3dFbnVtTWVtYmVySW5pdCgpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5zdGFydCxlPSgpPT50aGlzLm1hdGNoKG4uY29tbWEpfHx0aGlzLm1hdGNoKG4uYnJhY2VSKTtzd2l0Y2godGhpcy5zdGF0ZS50eXBlKXtjYXNlIG4ubnVtOntjb25zdCBzPXRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsXCJOdW1lcmljTGl0ZXJhbFwiKTtyZXR1cm4gZSgpP3t0eXBlOlwibnVtYmVyXCIscG9zOnMuc3RhcnQsdmFsdWU6c306e3R5cGU6XCJpbnZhbGlkXCIscG9zOnR9fWNhc2Ugbi5zdHJpbmc6e2NvbnN0IHM9dGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSxcIlN0cmluZ0xpdGVyYWxcIik7cmV0dXJuIGUoKT97dHlwZTpcInN0cmluZ1wiLHBvczpzLnN0YXJ0LHZhbHVlOnN9Ont0eXBlOlwiaW52YWxpZFwiLHBvczp0fX1jYXNlIG4uX3RydWU6Y2FzZSBuLl9mYWxzZTp7Y29uc3Qgcz10aGlzLnBhcnNlQm9vbGVhbkxpdGVyYWwoKTtyZXR1cm4gZSgpP3t0eXBlOlwiYm9vbGVhblwiLHBvczpzLnN0YXJ0LHZhbHVlOnN9Ont0eXBlOlwiaW52YWxpZFwiLHBvczp0fX1kZWZhdWx0OnJldHVybnt0eXBlOlwiaW52YWxpZFwiLHBvczp0fX19Zmxvd0VudW1NZW1iZXJSYXcoKXtjb25zdCB0PXRoaXMuc3RhdGUuc3RhcnQ7cmV0dXJue2lkOnRoaXMucGFyc2VJZGVudGlmaWVyKCEwKSxpbml0OnRoaXMuZWF0KG4uZXEpP3RoaXMuZmxvd0VudW1NZW1iZXJJbml0KCk6e3R5cGU6XCJub25lXCIscG9zOnR9fX1mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2godCxlLHMpe2NvbnN0e2V4cGxpY2l0VHlwZTppfT1lO251bGwhPT1pJiZpIT09cyYmdGhpcy5mbG93RW51bUVycm9ySW52YWxpZE1lbWJlckluaXRpYWxpemVyKHQsZSl9Zmxvd0VudW1NZW1iZXJzKHtlbnVtTmFtZTp0LGV4cGxpY2l0VHlwZTplfSl7Y29uc3Qgcz1uZXcgU2V0LGk9e2Jvb2xlYW5NZW1iZXJzOltdLG51bWJlck1lbWJlcnM6W10sc3RyaW5nTWVtYmVyczpbXSxkZWZhdWx0ZWRNZW1iZXJzOltdfTtmb3IoOyF0aGlzLm1hdGNoKG4uYnJhY2VSKTspe2NvbnN0IHI9dGhpcy5zdGFydE5vZGUoKSx7aWQ6YSxpbml0Om99PXRoaXMuZmxvd0VudW1NZW1iZXJSYXcoKSxoPWEubmFtZTtpZihcIlwiPT09aCljb250aW51ZTsvXlthLXpdLy50ZXN0KGgpJiZ0aGlzLmZsb3dFbnVtRXJyb3JJbnZhbGlkTWVtYmVyTmFtZShhLnN0YXJ0LHtlbnVtTmFtZTp0LG1lbWJlck5hbWU6aH0pLHMuaGFzKGgpJiZ0aGlzLmZsb3dFbnVtRXJyb3JEdXBsaWNhdGVNZW1iZXJOYW1lKGEuc3RhcnQse2VudW1OYW1lOnQsbWVtYmVyTmFtZTpofSkscy5hZGQoaCk7Y29uc3QgcD17ZW51bU5hbWU6dCxleHBsaWNpdFR5cGU6ZSxtZW1iZXJOYW1lOmh9O3N3aXRjaChyLmlkPWEsby50eXBlKXtjYXNlXCJib29sZWFuXCI6dGhpcy5mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2goby5wb3MscCxcImJvb2xlYW5cIiksci5pbml0PW8udmFsdWUsaS5ib29sZWFuTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShyLFwiRW51bUJvb2xlYW5NZW1iZXJcIikpO2JyZWFrO2Nhc2VcIm51bWJlclwiOnRoaXMuZmxvd0VudW1DaGVja0V4cGxpY2l0VHlwZU1pc21hdGNoKG8ucG9zLHAsXCJudW1iZXJcIiksci5pbml0PW8udmFsdWUsaS5udW1iZXJNZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKHIsXCJFbnVtTnVtYmVyTWVtYmVyXCIpKTticmVhaztjYXNlXCJzdHJpbmdcIjp0aGlzLmZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChvLnBvcyxwLFwic3RyaW5nXCIpLHIuaW5pdD1vLnZhbHVlLGkuc3RyaW5nTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShyLFwiRW51bVN0cmluZ01lbWJlclwiKSk7YnJlYWs7Y2FzZVwiaW52YWxpZFwiOnRocm93IHRoaXMuZmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJJbml0aWFsaXplcihvLnBvcyxwKTtjYXNlXCJub25lXCI6c3dpdGNoKGUpe2Nhc2VcImJvb2xlYW5cIjp0aGlzLmZsb3dFbnVtRXJyb3JCb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQoby5wb3MscCk7YnJlYWs7Y2FzZVwibnVtYmVyXCI6dGhpcy5mbG93RW51bUVycm9yTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQoby5wb3MscCk7YnJlYWs7ZGVmYXVsdDppLmRlZmF1bHRlZE1lbWJlcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUocixcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIikpfX10aGlzLm1hdGNoKG4uYnJhY2VSKXx8dGhpcy5leHBlY3Qobi5jb21tYSl9cmV0dXJuIGl9Zmxvd0VudW1TdHJpbmdNZW1iZXJzKHQsZSx7ZW51bU5hbWU6c30pe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZTtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIHQ7aWYoZS5sZW5ndGg+dC5sZW5ndGgpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBpPXRbZV07dGhpcy5mbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0YWlsaXplZChpLnN0YXJ0LHtlbnVtTmFtZTpzfSl9cmV0dXJuIGV9Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2NvbnN0IGk9ZVt0XTt0aGlzLmZsb3dFbnVtRXJyb3JTdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRhaWxpemVkKGkuc3RhcnQse2VudW1OYW1lOnN9KX1yZXR1cm4gdH1mbG93RW51bVBhcnNlRXhwbGljaXRUeXBlKHtlbnVtTmFtZTp0fSl7aWYodGhpcy5lYXRDb250ZXh0dWFsKFwib2ZcIikpe2lmKCF0aGlzLm1hdGNoKG4ubmFtZSkpdGhyb3cgdGhpcy5mbG93RW51bUVycm9ySW52YWxpZEV4cGxpY2l0VHlwZSh0aGlzLnN0YXRlLnN0YXJ0LHtlbnVtTmFtZTp0LHN1cHBsaWVkVHlwZTpudWxsfSk7Y29uc3R7dmFsdWU6ZX09dGhpcy5zdGF0ZTtyZXR1cm4gdGhpcy5uZXh0KCksXCJib29sZWFuXCIhPT1lJiZcIm51bWJlclwiIT09ZSYmXCJzdHJpbmdcIiE9PWUmJlwic3ltYm9sXCIhPT1lJiZ0aGlzLmZsb3dFbnVtRXJyb3JJbnZhbGlkRXhwbGljaXRUeXBlKHRoaXMuc3RhdGUuc3RhcnQse2VudW1OYW1lOnQsc3VwcGxpZWRUeXBlOmV9KSxlfXJldHVybiBudWxsfWZsb3dFbnVtQm9keSh0LHtlbnVtTmFtZTplLG5hbWVMb2M6c30pe2NvbnN0IGk9dGhpcy5mbG93RW51bVBhcnNlRXhwbGljaXRUeXBlKHtlbnVtTmFtZTplfSk7dGhpcy5leHBlY3Qobi5icmFjZUwpO2NvbnN0IHI9dGhpcy5mbG93RW51bU1lbWJlcnMoe2VudW1OYW1lOmUsZXhwbGljaXRUeXBlOml9KTtzd2l0Y2goaSl7Y2FzZVwiYm9vbGVhblwiOnJldHVybiB0LmV4cGxpY2l0VHlwZT0hMCx0Lm1lbWJlcnM9ci5ib29sZWFuTWVtYmVycyx0aGlzLmV4cGVjdChuLmJyYWNlUiksdGhpcy5maW5pc2hOb2RlKHQsXCJFbnVtQm9vbGVhbkJvZHlcIik7Y2FzZVwibnVtYmVyXCI6cmV0dXJuIHQuZXhwbGljaXRUeXBlPSEwLHQubWVtYmVycz1yLm51bWJlck1lbWJlcnMsdGhpcy5leHBlY3Qobi5icmFjZVIpLHRoaXMuZmluaXNoTm9kZSh0LFwiRW51bU51bWJlckJvZHlcIik7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHQuZXhwbGljaXRUeXBlPSEwLHQubWVtYmVycz10aGlzLmZsb3dFbnVtU3RyaW5nTWVtYmVycyhyLnN0cmluZ01lbWJlcnMsci5kZWZhdWx0ZWRNZW1iZXJzLHtlbnVtTmFtZTplfSksdGhpcy5leHBlY3Qobi5icmFjZVIpLHRoaXMuZmluaXNoTm9kZSh0LFwiRW51bVN0cmluZ0JvZHlcIik7Y2FzZVwic3ltYm9sXCI6cmV0dXJuIHQubWVtYmVycz1yLmRlZmF1bHRlZE1lbWJlcnMsdGhpcy5leHBlY3Qobi5icmFjZVIpLHRoaXMuZmluaXNoTm9kZSh0LFwiRW51bVN5bWJvbEJvZHlcIik7ZGVmYXVsdDp7Y29uc3QgaT0oKT0+KHQubWVtYmVycz1bXSx0aGlzLmV4cGVjdChuLmJyYWNlUiksdGhpcy5maW5pc2hOb2RlKHQsXCJFbnVtU3RyaW5nQm9keVwiKSk7dC5leHBsaWNpdFR5cGU9ITE7Y29uc3QgYT1yLmJvb2xlYW5NZW1iZXJzLmxlbmd0aCxvPXIubnVtYmVyTWVtYmVycy5sZW5ndGgsaD1yLnN0cmluZ01lbWJlcnMubGVuZ3RoLHA9ci5kZWZhdWx0ZWRNZW1iZXJzLmxlbmd0aDtpZihhfHxvfHxofHxwKXtpZihhfHxvKXtpZighbyYmIWgmJmE+PXApe2ZvcihsZXQgdD0wLHM9ci5kZWZhdWx0ZWRNZW1iZXJzO3Q8cy5sZW5ndGg7dCsrKXtjb25zdCBpPXNbdF07dGhpcy5mbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKGkuc3RhcnQse2VudW1OYW1lOmUsbWVtYmVyTmFtZTppLmlkLm5hbWV9KX1yZXR1cm4gdC5tZW1iZXJzPXIuYm9vbGVhbk1lbWJlcnMsdGhpcy5leHBlY3Qobi5icmFjZVIpLHRoaXMuZmluaXNoTm9kZSh0LFwiRW51bUJvb2xlYW5Cb2R5XCIpfWlmKCFhJiYhaCYmbz49cCl7Zm9yKGxldCB0PTAscz1yLmRlZmF1bHRlZE1lbWJlcnM7dDxzLmxlbmd0aDt0Kyspe2NvbnN0IGk9c1t0XTt0aGlzLmZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChpLnN0YXJ0LHtlbnVtTmFtZTplLG1lbWJlck5hbWU6aS5pZC5uYW1lfSl9cmV0dXJuIHQubWVtYmVycz1yLm51bWJlck1lbWJlcnMsdGhpcy5leHBlY3Qobi5icmFjZVIpLHRoaXMuZmluaXNoTm9kZSh0LFwiRW51bU51bWJlckJvZHlcIil9cmV0dXJuIHRoaXMuZmxvd0VudW1FcnJvckluY29uc2lzdGVudE1lbWJlclZhbHVlcyhzLHtlbnVtTmFtZTplfSksaSgpfXJldHVybiB0Lm1lbWJlcnM9dGhpcy5mbG93RW51bVN0cmluZ01lbWJlcnMoci5zdHJpbmdNZW1iZXJzLHIuZGVmYXVsdGVkTWVtYmVycyx7ZW51bU5hbWU6ZX0pLHRoaXMuZXhwZWN0KG4uYnJhY2VSKSx0aGlzLmZpbmlzaE5vZGUodCxcIkVudW1TdHJpbmdCb2R5XCIpfXJldHVybiBpKCl9fX1mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24odCl7Y29uc3QgZT10aGlzLnBhcnNlSWRlbnRpZmllcigpO3JldHVybiB0LmlkPWUsdC5ib2R5PXRoaXMuZmxvd0VudW1Cb2R5KHRoaXMuc3RhcnROb2RlKCkse2VudW1OYW1lOmUubmFtZSxuYW1lTG9jOmUuc3RhcnR9KSx0aGlzLmZpbmlzaE5vZGUodCxcIkVudW1EZWNsYXJhdGlvblwiKX19LHR5cGVzY3JpcHQ6dD0+Y2xhc3MgZXh0ZW5kcyB0e2dldFNjb3BlSGFuZGxlcigpe3JldHVybiBafXRzSXNJZGVudGlmaWVyKCl7cmV0dXJuIHRoaXMubWF0Y2gobi5uYW1lKX10c05leHRUb2tlbkNhbkZvbGxvd01vZGlmaWVyKCl7cmV0dXJuIHRoaXMubmV4dCgpLCEodGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKXx8dGhpcy5tYXRjaChuLnBhcmVuTCl8fHRoaXMubWF0Y2gobi5wYXJlblIpfHx0aGlzLm1hdGNoKG4uY29sb24pfHx0aGlzLm1hdGNoKG4uZXEpfHx0aGlzLm1hdGNoKG4ucXVlc3Rpb24pfHx0aGlzLm1hdGNoKG4uYmFuZykpfXRzUGFyc2VNb2RpZmllcih0KXtpZighdGhpcy5tYXRjaChuLm5hbWUpKXJldHVybjtjb25zdCBlPXRoaXMuc3RhdGUudmFsdWU7cmV0dXJuLTEhPT10LmluZGV4T2YoZSkmJnRoaXMudHNUcnlQYXJzZSh0aGlzLnRzTmV4dFRva2VuQ2FuRm9sbG93TW9kaWZpZXIuYmluZCh0aGlzKSk/ZTp2b2lkIDB9dHNQYXJzZU1vZGlmaWVycyh0LGUpe2Zvcig7Oyl7Y29uc3Qgcz10aGlzLnN0YXRlLnN0YXJ0LGk9dGhpcy50c1BhcnNlTW9kaWZpZXIoZSk7aWYoIWkpYnJlYWs7T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxpKSYmdGhpcy5yYWlzZShzLHJ0LkR1cGxpY2F0ZU1vZGlmaWVyLGkpLHRbaV09ITB9fXRzSXNMaXN0VGVybWluYXRvcih0KXtzd2l0Y2godCl7Y2FzZVwiRW51bU1lbWJlcnNcIjpjYXNlXCJUeXBlTWVtYmVyc1wiOnJldHVybiB0aGlzLm1hdGNoKG4uYnJhY2VSKTtjYXNlXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIjpyZXR1cm4gdGhpcy5tYXRjaChuLmJyYWNlTCk7Y2FzZVwiVHVwbGVFbGVtZW50VHlwZXNcIjpyZXR1cm4gdGhpcy5tYXRjaChuLmJyYWNrZXRSKTtjYXNlXCJUeXBlUGFyYW1ldGVyc09yQXJndW1lbnRzXCI6cmV0dXJuIHRoaXMuaXNSZWxhdGlvbmFsKFwiPlwiKX10aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKX10c1BhcnNlTGlzdCh0LGUpe2NvbnN0IHM9W107Zm9yKDshdGhpcy50c0lzTGlzdFRlcm1pbmF0b3IodCk7KXMucHVzaChlKCkpO3JldHVybiBzfXRzUGFyc2VEZWxpbWl0ZWRMaXN0KHQsZSl7cmV0dXJuIHN0KHRoaXMudHNQYXJzZURlbGltaXRlZExpc3RXb3JrZXIodCxlLCEwKSl9dHNQYXJzZURlbGltaXRlZExpc3RXb3JrZXIodCxlLHMpe2NvbnN0IGk9W107Zm9yKDshdGhpcy50c0lzTGlzdFRlcm1pbmF0b3IodCk7KXtjb25zdCByPWUoKTtpZihudWxsPT1yKXJldHVybjtpZihpLnB1c2gociksIXRoaXMuZWF0KG4uY29tbWEpKXtpZih0aGlzLnRzSXNMaXN0VGVybWluYXRvcih0KSlicmVhaztyZXR1cm4gdm9pZChzJiZ0aGlzLmV4cGVjdChuLmNvbW1hKSl9fXJldHVybiBpfXRzUGFyc2VCcmFja2V0ZWRMaXN0KHQsZSxzLGkpe2l8fChzP3RoaXMuZXhwZWN0KG4uYnJhY2tldEwpOnRoaXMuZXhwZWN0UmVsYXRpb25hbChcIjxcIikpO2NvbnN0IHI9dGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdCh0LGUpO3JldHVybiBzP3RoaXMuZXhwZWN0KG4uYnJhY2tldFIpOnRoaXMuZXhwZWN0UmVsYXRpb25hbChcIj5cIikscn10c1BhcnNlSW1wb3J0VHlwZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5leHBlY3Qobi5faW1wb3J0KSx0aGlzLmV4cGVjdChuLnBhcmVuTCksdGhpcy5tYXRjaChuLnN0cmluZyl8fHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxydC5VbnN1cHBvcnRlZEltcG9ydFR5cGVBcmd1bWVudCksdC5hcmd1bWVudD10aGlzLnBhcnNlRXhwckF0b20oKSx0aGlzLmV4cGVjdChuLnBhcmVuUiksdGhpcy5lYXQobi5kb3QpJiYodC5xdWFsaWZpZXI9dGhpcy50c1BhcnNlRW50aXR5TmFtZSghMCkpLHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSYmKHQudHlwZVBhcmFtZXRlcnM9dGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpKSx0aGlzLmZpbmlzaE5vZGUodCxcIlRTSW1wb3J0VHlwZVwiKX10c1BhcnNlRW50aXR5TmFtZSh0KXtsZXQgZT10aGlzLnBhcnNlSWRlbnRpZmllcigpO2Zvcig7dGhpcy5lYXQobi5kb3QpOyl7Y29uc3Qgcz10aGlzLnN0YXJ0Tm9kZUF0Tm9kZShlKTtzLmxlZnQ9ZSxzLnJpZ2h0PXRoaXMucGFyc2VJZGVudGlmaWVyKHQpLGU9dGhpcy5maW5pc2hOb2RlKHMsXCJUU1F1YWxpZmllZE5hbWVcIil9cmV0dXJuIGV9dHNQYXJzZVR5cGVSZWZlcmVuY2UoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHQudHlwZU5hbWU9dGhpcy50c1BhcnNlRW50aXR5TmFtZSghMSksIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkmJnRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSYmKHQudHlwZVBhcmFtZXRlcnM9dGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpKSx0aGlzLmZpbmlzaE5vZGUodCxcIlRTVHlwZVJlZmVyZW5jZVwiKX10c1BhcnNlVGhpc1R5cGVQcmVkaWNhdGUodCl7dGhpcy5uZXh0KCk7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZUF0Tm9kZSh0KTtyZXR1cm4gZS5wYXJhbWV0ZXJOYW1lPXQsZS50eXBlQW5ub3RhdGlvbj10aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbighMSksdGhpcy5maW5pc2hOb2RlKGUsXCJUU1R5cGVQcmVkaWNhdGVcIil9dHNQYXJzZVRoaXNUeXBlTm9kZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKHQsXCJUU1RoaXNUeXBlXCIpfXRzUGFyc2VUeXBlUXVlcnkoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMuZXhwZWN0KG4uX3R5cGVvZiksdGhpcy5tYXRjaChuLl9pbXBvcnQpP3QuZXhwck5hbWU9dGhpcy50c1BhcnNlSW1wb3J0VHlwZSgpOnQuZXhwck5hbWU9dGhpcy50c1BhcnNlRW50aXR5TmFtZSghMCksdGhpcy5maW5pc2hOb2RlKHQsXCJUU1R5cGVRdWVyeVwiKX10c1BhcnNlVHlwZVBhcmFtZXRlcigpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC5uYW1lPXRoaXMucGFyc2VJZGVudGlmaWVyTmFtZSh0LnN0YXJ0KSx0LmNvbnN0cmFpbnQ9dGhpcy50c0VhdFRoZW5QYXJzZVR5cGUobi5fZXh0ZW5kcyksdC5kZWZhdWx0PXRoaXMudHNFYXRUaGVuUGFyc2VUeXBlKG4uZXEpLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNUeXBlUGFyYW1ldGVyXCIpfXRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpe2lmKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSlyZXR1cm4gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnMoKX10c1BhcnNlVHlwZVBhcmFtZXRlcnMoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKXx8dGhpcy5tYXRjaChuLmpzeFRhZ1N0YXJ0KT90aGlzLm5leHQoKTp0aGlzLnVuZXhwZWN0ZWQoKSx0LnBhcmFtcz10aGlzLnRzUGFyc2VCcmFja2V0ZWRMaXN0KFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiLHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXIuYmluZCh0aGlzKSwhMSwhMCksdGhpcy5maW5pc2hOb2RlKHQsXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKX10c1RyeU5leHRQYXJzZUNvbnN0YW50Q29udGV4dCgpe3JldHVybiB0aGlzLmxvb2thaGVhZCgpLnR5cGU9PT1uLl9jb25zdD8odGhpcy5uZXh0KCksdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpKTpudWxsfXRzRmlsbFNpZ25hdHVyZSh0LGUpe2NvbnN0IHM9dD09PW4uYXJyb3c7ZS50eXBlUGFyYW1ldGVycz10aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpLHRoaXMuZXhwZWN0KG4ucGFyZW5MKSxlLnBhcmFtZXRlcnM9dGhpcy50c1BhcnNlQmluZGluZ0xpc3RGb3JTaWduYXR1cmUoKSxzP2UudHlwZUFubm90YXRpb249dGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24odCk6dGhpcy5tYXRjaCh0KSYmKGUudHlwZUFubm90YXRpb249dGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24odCkpfXRzUGFyc2VCaW5kaW5nTGlzdEZvclNpZ25hdHVyZSgpe3JldHVybiB0aGlzLnBhcnNlQmluZGluZ0xpc3Qobi5wYXJlblIsNDEpLm1hcCh0PT4oXCJJZGVudGlmaWVyXCIhPT10LnR5cGUmJlwiUmVzdEVsZW1lbnRcIiE9PXQudHlwZSYmXCJPYmplY3RQYXR0ZXJuXCIhPT10LnR5cGUmJlwiQXJyYXlQYXR0ZXJuXCIhPT10LnR5cGUmJnRoaXMucmFpc2UodC5zdGFydCxydC5VbnN1cHBvcnRlZFNpZ25hdHVyZVBhcmFtZXRlcktpbmQsdC50eXBlKSx0KSl9dHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKXt0aGlzLmVhdChuLmNvbW1hKXx8dGhpcy5zZW1pY29sb24oKX10c1BhcnNlU2lnbmF0dXJlTWVtYmVyKHQsZSl7cmV0dXJuIHRoaXMudHNGaWxsU2lnbmF0dXJlKG4uY29sb24sZSksdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZShlLHQpfXRzSXNVbmFtYmlndW91c2x5SW5kZXhTaWduYXR1cmUoKXtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5lYXQobi5uYW1lKSYmdGhpcy5tYXRjaChuLmNvbG9uKX10c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUodCl7aWYoIXRoaXMubWF0Y2gobi5icmFja2V0TCl8fCF0aGlzLnRzTG9va0FoZWFkKHRoaXMudHNJc1VuYW1iaWd1b3VzbHlJbmRleFNpZ25hdHVyZS5iaW5kKHRoaXMpKSlyZXR1cm47dGhpcy5leHBlY3Qobi5icmFja2V0TCk7Y29uc3QgZT10aGlzLnBhcnNlSWRlbnRpZmllcigpO2UudHlwZUFubm90YXRpb249dGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKSx0aGlzLnJlc2V0RW5kTG9jYXRpb24oZSksdGhpcy5leHBlY3Qobi5icmFja2V0UiksdC5wYXJhbWV0ZXJzPVtlXTtjb25zdCBzPXRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7cmV0dXJuIHMmJih0LnR5cGVBbm5vdGF0aW9uPXMpLHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUodCxcIlRTSW5kZXhTaWduYXR1cmVcIil9dHNQYXJzZVByb3BlcnR5T3JNZXRob2RTaWduYXR1cmUodCxlKXt0aGlzLmVhdChuLnF1ZXN0aW9uKSYmKHQub3B0aW9uYWw9ITApO2NvbnN0IHM9dDtpZihlfHwhdGhpcy5tYXRjaChuLnBhcmVuTCkmJiF0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpe2NvbnN0IHQ9cztlJiYodC5yZWFkb25seT0hMCk7Y29uc3QgaT10aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO3JldHVybiBpJiYodC50eXBlQW5ub3RhdGlvbj1pKSx0aGlzLnRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKHQsXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIpfXtjb25zdCB0PXM7cmV0dXJuIHRoaXMudHNGaWxsU2lnbmF0dXJlKG4uY29sb24sdCksdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNNZXRob2RTaWduYXR1cmVcIil9fXRzUGFyc2VUeXBlTWVtYmVyKCl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpO2lmKHRoaXMubWF0Y2gobi5wYXJlbkwpfHx0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpcmV0dXJuIHRoaXMudHNQYXJzZVNpZ25hdHVyZU1lbWJlcihcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsdCk7aWYodGhpcy5tYXRjaChuLl9uZXcpKXtjb25zdCBlPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMubWF0Y2gobi5wYXJlbkwpfHx0aGlzLmlzUmVsYXRpb25hbChcIjxcIik/dGhpcy50c1BhcnNlU2lnbmF0dXJlTWVtYmVyKFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiLHQpOih0LmtleT10aGlzLmNyZWF0ZUlkZW50aWZpZXIoZSxcIm5ld1wiKSx0aGlzLnRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKHQsITEpKX1jb25zdCBlPSEhdGhpcy50c1BhcnNlTW9kaWZpZXIoW1wicmVhZG9ubHlcIl0pLHM9dGhpcy50c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUodCk7cmV0dXJuIHM/KGUmJih0LnJlYWRvbmx5PSEwKSxzKToodGhpcy5wYXJzZVByb3BlcnR5TmFtZSh0LCExKSx0aGlzLnRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKHQsZSkpfXRzUGFyc2VUeXBlTGl0ZXJhbCgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC5tZW1iZXJzPXRoaXMudHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzKCksdGhpcy5maW5pc2hOb2RlKHQsXCJUU1R5cGVMaXRlcmFsXCIpfXRzUGFyc2VPYmplY3RUeXBlTWVtYmVycygpe3RoaXMuZXhwZWN0KG4uYnJhY2VMKTtjb25zdCB0PXRoaXMudHNQYXJzZUxpc3QoXCJUeXBlTWVtYmVyc1wiLHRoaXMudHNQYXJzZVR5cGVNZW1iZXIuYmluZCh0aGlzKSk7cmV0dXJuIHRoaXMuZXhwZWN0KG4uYnJhY2VSKSx0fXRzSXNTdGFydE9mTWFwcGVkVHlwZSgpe3JldHVybiB0aGlzLm5leHQoKSx0aGlzLmVhdChuLnBsdXNNaW4pP3RoaXMuaXNDb250ZXh0dWFsKFwicmVhZG9ubHlcIik6KHRoaXMuaXNDb250ZXh0dWFsKFwicmVhZG9ubHlcIikmJnRoaXMubmV4dCgpLCEhdGhpcy5tYXRjaChuLmJyYWNrZXRMKSYmKHRoaXMubmV4dCgpLCEhdGhpcy50c0lzSWRlbnRpZmllcigpJiYodGhpcy5uZXh0KCksdGhpcy5tYXRjaChuLl9pbikpKSl9dHNQYXJzZU1hcHBlZFR5cGVQYXJhbWV0ZXIoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHQubmFtZT10aGlzLnBhcnNlSWRlbnRpZmllck5hbWUodC5zdGFydCksdC5jb25zdHJhaW50PXRoaXMudHNFeHBlY3RUaGVuUGFyc2VUeXBlKG4uX2luKSx0aGlzLmZpbmlzaE5vZGUodCxcIlRTVHlwZVBhcmFtZXRlclwiKX10c1BhcnNlTWFwcGVkVHlwZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5leHBlY3Qobi5icmFjZUwpLHRoaXMubWF0Y2gobi5wbHVzTWluKT8odC5yZWFkb25seT10aGlzLnN0YXRlLnZhbHVlLHRoaXMubmV4dCgpLHRoaXMuZXhwZWN0Q29udGV4dHVhbChcInJlYWRvbmx5XCIpKTp0aGlzLmVhdENvbnRleHR1YWwoXCJyZWFkb25seVwiKSYmKHQucmVhZG9ubHk9ITApLHRoaXMuZXhwZWN0KG4uYnJhY2tldEwpLHQudHlwZVBhcmFtZXRlcj10aGlzLnRzUGFyc2VNYXBwZWRUeXBlUGFyYW1ldGVyKCksdGhpcy5leHBlY3Qobi5icmFja2V0UiksdGhpcy5tYXRjaChuLnBsdXNNaW4pPyh0Lm9wdGlvbmFsPXRoaXMuc3RhdGUudmFsdWUsdGhpcy5uZXh0KCksdGhpcy5leHBlY3Qobi5xdWVzdGlvbikpOnRoaXMuZWF0KG4ucXVlc3Rpb24pJiYodC5vcHRpb25hbD0hMCksdC50eXBlQW5ub3RhdGlvbj10aGlzLnRzVHJ5UGFyc2VUeXBlKCksdGhpcy5zZW1pY29sb24oKSx0aGlzLmV4cGVjdChuLmJyYWNlUiksdGhpcy5maW5pc2hOb2RlKHQsXCJUU01hcHBlZFR5cGVcIil9dHNQYXJzZVR1cGxlVHlwZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTt0LmVsZW1lbnRUeXBlcz10aGlzLnRzUGFyc2VCcmFja2V0ZWRMaXN0KFwiVHVwbGVFbGVtZW50VHlwZXNcIix0aGlzLnRzUGFyc2VUdXBsZUVsZW1lbnRUeXBlLmJpbmQodGhpcyksITAsITEpO2xldCBlPSExO3JldHVybiB0LmVsZW1lbnRUeXBlcy5mb3JFYWNoKHQ9PntcIlRTT3B0aW9uYWxUeXBlXCI9PT10LnR5cGU/ZT0hMDplJiZcIlRTUmVzdFR5cGVcIiE9PXQudHlwZSYmdGhpcy5yYWlzZSh0LnN0YXJ0LHJ0Lk9wdGlvbmFsVHlwZUJlZm9yZVJlcXVpcmVkKX0pLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNUdXBsZVR5cGVcIil9dHNQYXJzZVR1cGxlRWxlbWVudFR5cGUoKXtpZih0aGlzLm1hdGNoKG4uZWxsaXBzaXMpKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLHQudHlwZUFubm90YXRpb249dGhpcy50c1BhcnNlVHlwZSgpLHRoaXMubWF0Y2gobi5jb21tYSkmJjkzIT09dGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpJiZ0aGlzLnJhaXNlUmVzdE5vdExhc3QodGhpcy5zdGF0ZS5zdGFydCksdGhpcy5maW5pc2hOb2RlKHQsXCJUU1Jlc3RUeXBlXCIpfWNvbnN0IHQ9dGhpcy50c1BhcnNlVHlwZSgpO2lmKHRoaXMuZWF0KG4ucXVlc3Rpb24pKXtjb25zdCBlPXRoaXMuc3RhcnROb2RlQXROb2RlKHQpO3JldHVybiBlLnR5cGVBbm5vdGF0aW9uPXQsdGhpcy5maW5pc2hOb2RlKGUsXCJUU09wdGlvbmFsVHlwZVwiKX1yZXR1cm4gdH10c1BhcnNlUGFyZW50aGVzaXplZFR5cGUoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMuZXhwZWN0KG4ucGFyZW5MKSx0LnR5cGVBbm5vdGF0aW9uPXRoaXMudHNQYXJzZVR5cGUoKSx0aGlzLmV4cGVjdChuLnBhcmVuUiksdGhpcy5maW5pc2hOb2RlKHQsXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIpfXRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKHQpe2NvbnN0IGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm5cIlRTQ29uc3RydWN0b3JUeXBlXCI9PT10JiZ0aGlzLmV4cGVjdChuLl9uZXcpLHRoaXMudHNGaWxsU2lnbmF0dXJlKG4uYXJyb3csZSksdGhpcy5maW5pc2hOb2RlKGUsdCl9dHNQYXJzZUxpdGVyYWxUeXBlTm9kZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC5saXRlcmFsPSgoKT0+e3N3aXRjaCh0aGlzLnN0YXRlLnR5cGUpe2Nhc2Ugbi5udW06Y2FzZSBuLnN0cmluZzpjYXNlIG4uX3RydWU6Y2FzZSBuLl9mYWxzZTpyZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tKCk7ZGVmYXVsdDp0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKX19KSgpLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNMaXRlcmFsVHlwZVwiKX10c1BhcnNlVGVtcGxhdGVMaXRlcmFsVHlwZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKSxlPXRoaXMucGFyc2VUZW1wbGF0ZSghMSk7cmV0dXJuIGUuZXhwcmVzc2lvbnMubGVuZ3RoPjAmJnRoaXMucmFpc2UoZS5leHByZXNzaW9uc1swXS5zdGFydCxydC5UZW1wbGF0ZVR5cGVIYXNTdWJzdGl0dXRpb24pLHQubGl0ZXJhbD1lLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNMaXRlcmFsVHlwZVwiKX10c1BhcnNlVGhpc1R5cGVPclRoaXNUeXBlUHJlZGljYXRlKCl7Y29uc3QgdD10aGlzLnRzUGFyc2VUaGlzVHlwZU5vZGUoKTtyZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoXCJpc1wiKSYmIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCk/dGhpcy50c1BhcnNlVGhpc1R5cGVQcmVkaWNhdGUodCk6dH10c1BhcnNlTm9uQXJyYXlUeXBlKCl7c3dpdGNoKHRoaXMuc3RhdGUudHlwZSl7Y2FzZSBuLm5hbWU6Y2FzZSBuLl92b2lkOmNhc2Ugbi5fbnVsbDp7Y29uc3QgdD10aGlzLm1hdGNoKG4uX3ZvaWQpP1wiVFNWb2lkS2V5d29yZFwiOnRoaXMubWF0Y2gobi5fbnVsbCk/XCJUU051bGxLZXl3b3JkXCI6ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2VcImFueVwiOnJldHVyblwiVFNBbnlLZXl3b3JkXCI7Y2FzZVwiYm9vbGVhblwiOnJldHVyblwiVFNCb29sZWFuS2V5d29yZFwiO2Nhc2VcImJpZ2ludFwiOnJldHVyblwiVFNCaWdJbnRLZXl3b3JkXCI7Y2FzZVwibmV2ZXJcIjpyZXR1cm5cIlRTTmV2ZXJLZXl3b3JkXCI7Y2FzZVwibnVtYmVyXCI6cmV0dXJuXCJUU051bWJlcktleXdvcmRcIjtjYXNlXCJvYmplY3RcIjpyZXR1cm5cIlRTT2JqZWN0S2V5d29yZFwiO2Nhc2VcInN0cmluZ1wiOnJldHVyblwiVFNTdHJpbmdLZXl3b3JkXCI7Y2FzZVwic3ltYm9sXCI6cmV0dXJuXCJUU1N5bWJvbEtleXdvcmRcIjtjYXNlXCJ1bmRlZmluZWRcIjpyZXR1cm5cIlRTVW5kZWZpbmVkS2V5d29yZFwiO2Nhc2VcInVua25vd25cIjpyZXR1cm5cIlRTVW5rbm93bktleXdvcmRcIjtkZWZhdWx0OnJldHVybn19KHRoaXMuc3RhdGUudmFsdWUpO2lmKHZvaWQgMCE9PXQmJjQ2IT09dGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpKXtjb25zdCBlPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuZmluaXNoTm9kZShlLHQpfXJldHVybiB0aGlzLnRzUGFyc2VUeXBlUmVmZXJlbmNlKCl9Y2FzZSBuLnN0cmluZzpjYXNlIG4ubnVtOmNhc2Ugbi5fdHJ1ZTpjYXNlIG4uX2ZhbHNlOnJldHVybiB0aGlzLnRzUGFyc2VMaXRlcmFsVHlwZU5vZGUoKTtjYXNlIG4ucGx1c01pbjppZihcIi1cIj09PXRoaXMuc3RhdGUudmFsdWUpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtpZih0aGlzLmxvb2thaGVhZCgpLnR5cGUhPT1uLm51bSl0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm4gdC5saXRlcmFsPXRoaXMucGFyc2VNYXliZVVuYXJ5KCksdGhpcy5maW5pc2hOb2RlKHQsXCJUU0xpdGVyYWxUeXBlXCIpfWJyZWFrO2Nhc2Ugbi5fdGhpczpyZXR1cm4gdGhpcy50c1BhcnNlVGhpc1R5cGVPclRoaXNUeXBlUHJlZGljYXRlKCk7Y2FzZSBuLl90eXBlb2Y6cmV0dXJuIHRoaXMudHNQYXJzZVR5cGVRdWVyeSgpO2Nhc2Ugbi5faW1wb3J0OnJldHVybiB0aGlzLnRzUGFyc2VJbXBvcnRUeXBlKCk7Y2FzZSBuLmJyYWNlTDpyZXR1cm4gdGhpcy50c0xvb2tBaGVhZCh0aGlzLnRzSXNTdGFydE9mTWFwcGVkVHlwZS5iaW5kKHRoaXMpKT90aGlzLnRzUGFyc2VNYXBwZWRUeXBlKCk6dGhpcy50c1BhcnNlVHlwZUxpdGVyYWwoKTtjYXNlIG4uYnJhY2tldEw6cmV0dXJuIHRoaXMudHNQYXJzZVR1cGxlVHlwZSgpO2Nhc2Ugbi5wYXJlbkw6cmV0dXJuIHRoaXMudHNQYXJzZVBhcmVudGhlc2l6ZWRUeXBlKCk7Y2FzZSBuLmJhY2tRdW90ZTpyZXR1cm4gdGhpcy50c1BhcnNlVGVtcGxhdGVMaXRlcmFsVHlwZSgpfXRocm93IHRoaXMudW5leHBlY3RlZCgpfXRzUGFyc2VBcnJheVR5cGVPckhpZ2hlcigpe2xldCB0PXRoaXMudHNQYXJzZU5vbkFycmF5VHlwZSgpO2Zvcig7IXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkmJnRoaXMuZWF0KG4uYnJhY2tldEwpOylpZih0aGlzLm1hdGNoKG4uYnJhY2tldFIpKXtjb25zdCBlPXRoaXMuc3RhcnROb2RlQXROb2RlKHQpO2UuZWxlbWVudFR5cGU9dCx0aGlzLmV4cGVjdChuLmJyYWNrZXRSKSx0PXRoaXMuZmluaXNoTm9kZShlLFwiVFNBcnJheVR5cGVcIil9ZWxzZXtjb25zdCBlPXRoaXMuc3RhcnROb2RlQXROb2RlKHQpO2Uub2JqZWN0VHlwZT10LGUuaW5kZXhUeXBlPXRoaXMudHNQYXJzZVR5cGUoKSx0aGlzLmV4cGVjdChuLmJyYWNrZXRSKSx0PXRoaXMuZmluaXNoTm9kZShlLFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiKX1yZXR1cm4gdH10c1BhcnNlVHlwZU9wZXJhdG9yKHQpe2NvbnN0IGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5leHBlY3RDb250ZXh0dWFsKHQpLGUub3BlcmF0b3I9dCxlLnR5cGVBbm5vdGF0aW9uPXRoaXMudHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyKCksXCJyZWFkb25seVwiPT09dCYmdGhpcy50c0NoZWNrVHlwZUFubm90YXRpb25Gb3JSZWFkT25seShlKSx0aGlzLmZpbmlzaE5vZGUoZSxcIlRTVHlwZU9wZXJhdG9yXCIpfXRzQ2hlY2tUeXBlQW5ub3RhdGlvbkZvclJlYWRPbmx5KHQpe3N3aXRjaCh0LnR5cGVBbm5vdGF0aW9uLnR5cGUpe2Nhc2VcIlRTVHVwbGVUeXBlXCI6Y2FzZVwiVFNBcnJheVR5cGVcIjpyZXR1cm47ZGVmYXVsdDp0aGlzLnJhaXNlKHQuc3RhcnQscnQuVW5leHBlY3RlZFJlYWRvbmx5KX19dHNQYXJzZUluZmVyVHlwZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTt0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJpbmZlclwiKTtjb25zdCBlPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIGUubmFtZT10aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoZS5zdGFydCksdC50eXBlUGFyYW1ldGVyPXRoaXMuZmluaXNoTm9kZShlLFwiVFNUeXBlUGFyYW1ldGVyXCIpLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNJbmZlclR5cGVcIil9dHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyKCl7Y29uc3QgdD1bXCJrZXlvZlwiLFwidW5pcXVlXCIsXCJyZWFkb25seVwiXS5maW5kKHQ9PnRoaXMuaXNDb250ZXh0dWFsKHQpKTtyZXR1cm4gdD90aGlzLnRzUGFyc2VUeXBlT3BlcmF0b3IodCk6dGhpcy5pc0NvbnRleHR1YWwoXCJpbmZlclwiKT90aGlzLnRzUGFyc2VJbmZlclR5cGUoKTp0aGlzLnRzUGFyc2VBcnJheVR5cGVPckhpZ2hlcigpfXRzUGFyc2VVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZSh0LGUscyl7dGhpcy5lYXQocyk7bGV0IGk9ZSgpO2lmKHRoaXMubWF0Y2gocykpe2NvbnN0IHI9W2ldO2Zvcig7dGhpcy5lYXQocyk7KXIucHVzaChlKCkpO2NvbnN0IGE9dGhpcy5zdGFydE5vZGVBdE5vZGUoaSk7YS50eXBlcz1yLGk9dGhpcy5maW5pc2hOb2RlKGEsdCl9cmV0dXJuIGl9dHNQYXJzZUludGVyc2VjdGlvblR5cGVPckhpZ2hlcigpe3JldHVybiB0aGlzLnRzUGFyc2VVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZShcIlRTSW50ZXJzZWN0aW9uVHlwZVwiLHRoaXMudHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyLmJpbmQodGhpcyksbi5iaXR3aXNlQU5EKX10c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKXtyZXR1cm4gdGhpcy50c1BhcnNlVW5pb25PckludGVyc2VjdGlvblR5cGUoXCJUU1VuaW9uVHlwZVwiLHRoaXMudHNQYXJzZUludGVyc2VjdGlvblR5cGVPckhpZ2hlci5iaW5kKHRoaXMpLG4uYml0d2lzZU9SKX10c0lzU3RhcnRPZkZ1bmN0aW9uVHlwZSgpe3JldHVybiEhdGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpfHx0aGlzLm1hdGNoKG4ucGFyZW5MKSYmdGhpcy50c0xvb2tBaGVhZCh0aGlzLnRzSXNVbmFtYmlndW91c2x5U3RhcnRPZkZ1bmN0aW9uVHlwZS5iaW5kKHRoaXMpKX10c1NraXBQYXJhbWV0ZXJTdGFydCgpe2lmKHRoaXMubWF0Y2gobi5uYW1lKXx8dGhpcy5tYXRjaChuLl90aGlzKSlyZXR1cm4gdGhpcy5uZXh0KCksITA7aWYodGhpcy5tYXRjaChuLmJyYWNlTCkpe2xldCB0PTE7Zm9yKHRoaXMubmV4dCgpO3Q+MDspdGhpcy5tYXRjaChuLmJyYWNlTCk/Kyt0OnRoaXMubWF0Y2gobi5icmFjZVIpJiYtLXQsdGhpcy5uZXh0KCk7cmV0dXJuITB9aWYodGhpcy5tYXRjaChuLmJyYWNrZXRMKSl7bGV0IHQ9MTtmb3IodGhpcy5uZXh0KCk7dD4wOyl0aGlzLm1hdGNoKG4uYnJhY2tldEwpPysrdDp0aGlzLm1hdGNoKG4uYnJhY2tldFIpJiYtLXQsdGhpcy5uZXh0KCk7cmV0dXJuITB9cmV0dXJuITF9dHNJc1VuYW1iaWd1b3VzbHlTdGFydE9mRnVuY3Rpb25UeXBlKCl7aWYodGhpcy5uZXh0KCksdGhpcy5tYXRjaChuLnBhcmVuUil8fHRoaXMubWF0Y2gobi5lbGxpcHNpcykpcmV0dXJuITA7aWYodGhpcy50c1NraXBQYXJhbWV0ZXJTdGFydCgpKXtpZih0aGlzLm1hdGNoKG4uY29sb24pfHx0aGlzLm1hdGNoKG4uY29tbWEpfHx0aGlzLm1hdGNoKG4ucXVlc3Rpb24pfHx0aGlzLm1hdGNoKG4uZXEpKXJldHVybiEwO2lmKHRoaXMubWF0Y2gobi5wYXJlblIpJiYodGhpcy5uZXh0KCksdGhpcy5tYXRjaChuLmFycm93KSkpcmV0dXJuITB9cmV0dXJuITF9dHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHQpe3JldHVybiB0aGlzLnRzSW5UeXBlKCgpPT57Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpO3RoaXMuZXhwZWN0KHQpO2NvbnN0IHM9dGhpcy50c1RyeVBhcnNlKHRoaXMudHNQYXJzZVR5cGVQcmVkaWNhdGVBc3NlcnRzLmJpbmQodGhpcykpO2lmKHMmJnRoaXMubWF0Y2gobi5fdGhpcykpe2xldCB0PXRoaXMudHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpO2lmKFwiVFNUaGlzVHlwZVwiPT09dC50eXBlKXtjb25zdCBzPXRoaXMuc3RhcnROb2RlQXROb2RlKGUpO3MucGFyYW1ldGVyTmFtZT10LHMuYXNzZXJ0cz0hMCx0PXRoaXMuZmluaXNoTm9kZShzLFwiVFNUeXBlUHJlZGljYXRlXCIpfWVsc2UgdC5hc3NlcnRzPSEwO3JldHVybiBlLnR5cGVBbm5vdGF0aW9uPXQsdGhpcy5maW5pc2hOb2RlKGUsXCJUU1R5cGVBbm5vdGF0aW9uXCIpfWNvbnN0IGk9dGhpcy50c0lzSWRlbnRpZmllcigpJiZ0aGlzLnRzVHJ5UGFyc2UodGhpcy50c1BhcnNlVHlwZVByZWRpY2F0ZVByZWZpeC5iaW5kKHRoaXMpKTtpZighaSl7aWYoIXMpcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCExLGUpO2NvbnN0IHQ9dGhpcy5zdGFydE5vZGVBdE5vZGUoZSk7cmV0dXJuIHQucGFyYW1ldGVyTmFtZT10aGlzLnBhcnNlSWRlbnRpZmllcigpLHQuYXNzZXJ0cz1zLGUudHlwZUFubm90YXRpb249dGhpcy5maW5pc2hOb2RlKHQsXCJUU1R5cGVQcmVkaWNhdGVcIiksdGhpcy5maW5pc2hOb2RlKGUsXCJUU1R5cGVBbm5vdGF0aW9uXCIpfWNvbnN0IHI9dGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oITEpLGE9dGhpcy5zdGFydE5vZGVBdE5vZGUoZSk7cmV0dXJuIGEucGFyYW1ldGVyTmFtZT1pLGEudHlwZUFubm90YXRpb249cixhLmFzc2VydHM9cyxlLnR5cGVBbm5vdGF0aW9uPXRoaXMuZmluaXNoTm9kZShhLFwiVFNUeXBlUHJlZGljYXRlXCIpLHRoaXMuZmluaXNoTm9kZShlLFwiVFNUeXBlQW5ub3RhdGlvblwiKX0pfXRzVHJ5UGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigpe3JldHVybiB0aGlzLm1hdGNoKG4uY29sb24pP3RoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKG4uY29sb24pOnZvaWQgMH10c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKXtyZXR1cm4gdGhpcy5tYXRjaChuLmNvbG9uKT90aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbigpOnZvaWQgMH10c1RyeVBhcnNlVHlwZSgpe3JldHVybiB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZShuLmNvbG9uKX10c1BhcnNlVHlwZVByZWRpY2F0ZVByZWZpeCgpe2NvbnN0IHQ9dGhpcy5wYXJzZUlkZW50aWZpZXIoKTtpZih0aGlzLmlzQ29udGV4dHVhbChcImlzXCIpJiYhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSlyZXR1cm4gdGhpcy5uZXh0KCksdH10c1BhcnNlVHlwZVByZWRpY2F0ZUFzc2VydHMoKXtpZighdGhpcy5tYXRjaChuLm5hbWUpfHxcImFzc2VydHNcIiE9PXRoaXMuc3RhdGUudmFsdWV8fHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpcmV0dXJuITE7Y29uc3QgdD10aGlzLnN0YXRlLmNvbnRhaW5zRXNjO3JldHVybiB0aGlzLm5leHQoKSwhKCF0aGlzLm1hdGNoKG4ubmFtZSkmJiF0aGlzLm1hdGNoKG4uX3RoaXMpKSYmKHQmJnRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsZi5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCxcImFzc2VydHNcIiksITApfXRzUGFyc2VUeXBlQW5ub3RhdGlvbih0PSEwLGU9dGhpcy5zdGFydE5vZGUoKSl7cmV0dXJuIHRoaXMudHNJblR5cGUoKCk9Pnt0JiZ0aGlzLmV4cGVjdChuLmNvbG9uKSxlLnR5cGVBbm5vdGF0aW9uPXRoaXMudHNQYXJzZVR5cGUoKX0pLHRoaXMuZmluaXNoTm9kZShlLFwiVFNUeXBlQW5ub3RhdGlvblwiKX10c1BhcnNlVHlwZSgpe2l0KHRoaXMuc3RhdGUuaW5UeXBlKTtjb25zdCB0PXRoaXMudHNQYXJzZU5vbkNvbmRpdGlvbmFsVHlwZSgpO2lmKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCl8fCF0aGlzLmVhdChuLl9leHRlbmRzKSlyZXR1cm4gdDtjb25zdCBlPXRoaXMuc3RhcnROb2RlQXROb2RlKHQpO3JldHVybiBlLmNoZWNrVHlwZT10LGUuZXh0ZW5kc1R5cGU9dGhpcy50c1BhcnNlTm9uQ29uZGl0aW9uYWxUeXBlKCksdGhpcy5leHBlY3Qobi5xdWVzdGlvbiksZS50cnVlVHlwZT10aGlzLnRzUGFyc2VUeXBlKCksdGhpcy5leHBlY3Qobi5jb2xvbiksZS5mYWxzZVR5cGU9dGhpcy50c1BhcnNlVHlwZSgpLHRoaXMuZmluaXNoTm9kZShlLFwiVFNDb25kaXRpb25hbFR5cGVcIil9dHNQYXJzZU5vbkNvbmRpdGlvbmFsVHlwZSgpe3JldHVybiB0aGlzLnRzSXNTdGFydE9mRnVuY3Rpb25UeXBlKCk/dGhpcy50c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShcIlRTRnVuY3Rpb25UeXBlXCIpOnRoaXMubWF0Y2gobi5fbmV3KT90aGlzLnRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKFwiVFNDb25zdHJ1Y3RvclR5cGVcIik6dGhpcy50c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKX10c1BhcnNlVHlwZUFzc2VydGlvbigpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKSxlPXRoaXMudHNUcnlOZXh0UGFyc2VDb25zdGFudENvbnRleHQoKTtyZXR1cm4gdC50eXBlQW5ub3RhdGlvbj1lfHx0aGlzLnRzTmV4dFRoZW5QYXJzZVR5cGUoKSx0aGlzLmV4cGVjdFJlbGF0aW9uYWwoXCI+XCIpLHQuZXhwcmVzc2lvbj10aGlzLnBhcnNlTWF5YmVVbmFyeSgpLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNUeXBlQXNzZXJ0aW9uXCIpfXRzUGFyc2VIZXJpdGFnZUNsYXVzZSh0KXtjb25zdCBlPXRoaXMuc3RhdGUuc3RhcnQscz10aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiSGVyaXRhZ2VDbGF1c2VFbGVtZW50XCIsdGhpcy50c1BhcnNlRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzLmJpbmQodGhpcykpO3JldHVybiBzLmxlbmd0aHx8dGhpcy5yYWlzZShlLHJ0LkVtcHR5SGVyaXRhZ2VDbGF1c2VUeXBlLHQpLHN9dHNQYXJzZUV4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cygpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC5leHByZXNzaW9uPXRoaXMudHNQYXJzZUVudGl0eU5hbWUoITEpLHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSYmKHQudHlwZVBhcmFtZXRlcnM9dGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpKSx0aGlzLmZpbmlzaE5vZGUodCxcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIpfXRzUGFyc2VJbnRlcmZhY2VEZWNsYXJhdGlvbih0KXt0LmlkPXRoaXMucGFyc2VJZGVudGlmaWVyKCksdGhpcy5jaGVja0xWYWwodC5pZCwxMzAsdm9pZCAwLFwidHlwZXNjcmlwdCBpbnRlcmZhY2UgZGVjbGFyYXRpb25cIiksdC50eXBlUGFyYW1ldGVycz10aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpLHRoaXMuZWF0KG4uX2V4dGVuZHMpJiYodC5leHRlbmRzPXRoaXMudHNQYXJzZUhlcml0YWdlQ2xhdXNlKFwiZXh0ZW5kc1wiKSk7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiBlLmJvZHk9dGhpcy50c0luVHlwZSh0aGlzLnRzUGFyc2VPYmplY3RUeXBlTWVtYmVycy5iaW5kKHRoaXMpKSx0LmJvZHk9dGhpcy5maW5pc2hOb2RlKGUsXCJUU0ludGVyZmFjZUJvZHlcIiksdGhpcy5maW5pc2hOb2RlKHQsXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIpfXRzUGFyc2VUeXBlQWxpYXNEZWNsYXJhdGlvbih0KXtyZXR1cm4gdC5pZD10aGlzLnBhcnNlSWRlbnRpZmllcigpLHRoaXMuY2hlY2tMVmFsKHQuaWQsMix2b2lkIDAsXCJ0eXBlc2NyaXB0IHR5cGUgYWxpYXNcIiksdC50eXBlUGFyYW1ldGVycz10aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpLHQudHlwZUFubm90YXRpb249dGhpcy50c0V4cGVjdFRoZW5QYXJzZVR5cGUobi5lcSksdGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUodCxcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIil9dHNJbk5vQ29udGV4dCh0KXtjb25zdCBlPXRoaXMuc3RhdGUuY29udGV4dDt0aGlzLnN0YXRlLmNvbnRleHQ9W2VbMF1dO3RyeXtyZXR1cm4gdCgpfWZpbmFsbHl7dGhpcy5zdGF0ZS5jb250ZXh0PWV9fXRzSW5UeXBlKHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS5pblR5cGU7dGhpcy5zdGF0ZS5pblR5cGU9ITA7dHJ5e3JldHVybiB0KCl9ZmluYWxseXt0aGlzLnN0YXRlLmluVHlwZT1lfX10c0VhdFRoZW5QYXJzZVR5cGUodCl7cmV0dXJuIHRoaXMubWF0Y2godCk/dGhpcy50c05leHRUaGVuUGFyc2VUeXBlKCk6dm9pZCAwfXRzRXhwZWN0VGhlblBhcnNlVHlwZSh0KXtyZXR1cm4gdGhpcy50c0RvVGhlblBhcnNlVHlwZSgoKT0+dGhpcy5leHBlY3QodCkpfXRzTmV4dFRoZW5QYXJzZVR5cGUoKXtyZXR1cm4gdGhpcy50c0RvVGhlblBhcnNlVHlwZSgoKT0+dGhpcy5uZXh0KCkpfXRzRG9UaGVuUGFyc2VUeXBlKHQpe3JldHVybiB0aGlzLnRzSW5UeXBlKCgpPT4odCgpLHRoaXMudHNQYXJzZVR5cGUoKSkpfXRzUGFyc2VFbnVtTWVtYmVyKCl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0LmlkPXRoaXMubWF0Y2gobi5zdHJpbmcpP3RoaXMucGFyc2VFeHByQXRvbSgpOnRoaXMucGFyc2VJZGVudGlmaWVyKCEwKSx0aGlzLmVhdChuLmVxKSYmKHQuaW5pdGlhbGl6ZXI9dGhpcy5wYXJzZU1heWJlQXNzaWduKCkpLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNFbnVtTWVtYmVyXCIpfXRzUGFyc2VFbnVtRGVjbGFyYXRpb24odCxlKXtyZXR1cm4gZSYmKHQuY29uc3Q9ITApLHQuaWQ9dGhpcy5wYXJzZUlkZW50aWZpZXIoKSx0aGlzLmNoZWNrTFZhbCh0LmlkLGU/Nzc5OjI2Nyx2b2lkIDAsXCJ0eXBlc2NyaXB0IGVudW0gZGVjbGFyYXRpb25cIiksdGhpcy5leHBlY3Qobi5icmFjZUwpLHQubWVtYmVycz10aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiRW51bU1lbWJlcnNcIix0aGlzLnRzUGFyc2VFbnVtTWVtYmVyLmJpbmQodGhpcykpLHRoaXMuZXhwZWN0KG4uYnJhY2VSKSx0aGlzLmZpbmlzaE5vZGUodCxcIlRTRW51bURlY2xhcmF0aW9uXCIpfXRzUGFyc2VNb2R1bGVCbG9jaygpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5zY29wZS5lbnRlcigwKSx0aGlzLmV4cGVjdChuLmJyYWNlTCksdGhpcy5wYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkodC5ib2R5PVtdLHZvaWQgMCwhMCxuLmJyYWNlUiksdGhpcy5zY29wZS5leGl0KCksdGhpcy5maW5pc2hOb2RlKHQsXCJUU01vZHVsZUJsb2NrXCIpfXRzUGFyc2VNb2R1bGVPck5hbWVzcGFjZURlY2xhcmF0aW9uKHQsZT0hMSl7aWYodC5pZD10aGlzLnBhcnNlSWRlbnRpZmllcigpLGV8fHRoaXMuY2hlY2tMVmFsKHQuaWQsMTAyNCxudWxsLFwibW9kdWxlIG9yIG5hbWVzcGFjZSBkZWNsYXJhdGlvblwiKSx0aGlzLmVhdChuLmRvdCkpe2NvbnN0IGU9dGhpcy5zdGFydE5vZGUoKTt0aGlzLnRzUGFyc2VNb2R1bGVPck5hbWVzcGFjZURlY2xhcmF0aW9uKGUsITApLHQuYm9keT1lfWVsc2UgdGhpcy5zY29wZS5lbnRlcigxMjgpLHRoaXMucHJvZFBhcmFtLmVudGVyKDApLHQuYm9keT10aGlzLnRzUGFyc2VNb2R1bGVCbG9jaygpLHRoaXMucHJvZFBhcmFtLmV4aXQoKSx0aGlzLnNjb3BlLmV4aXQoKTtyZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpfXRzUGFyc2VBbWJpZW50RXh0ZXJuYWxNb2R1bGVEZWNsYXJhdGlvbih0KXtyZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoXCJnbG9iYWxcIik/KHQuZ2xvYmFsPSEwLHQuaWQ9dGhpcy5wYXJzZUlkZW50aWZpZXIoKSk6dGhpcy5tYXRjaChuLnN0cmluZyk/dC5pZD10aGlzLnBhcnNlRXhwckF0b20oKTp0aGlzLnVuZXhwZWN0ZWQoKSx0aGlzLm1hdGNoKG4uYnJhY2VMKT8odGhpcy5zY29wZS5lbnRlcigxMjgpLHRoaXMucHJvZFBhcmFtLmVudGVyKDApLHQuYm9keT10aGlzLnRzUGFyc2VNb2R1bGVCbG9jaygpLHRoaXMucHJvZFBhcmFtLmV4aXQoKSx0aGlzLnNjb3BlLmV4aXQoKSk6dGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUodCxcIlRTTW9kdWxlRGVjbGFyYXRpb25cIil9dHNQYXJzZUltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKHQsZSl7cmV0dXJuIHQuaXNFeHBvcnQ9ZXx8ITEsdC5pZD10aGlzLnBhcnNlSWRlbnRpZmllcigpLHRoaXMuY2hlY2tMVmFsKHQuaWQsOSx2b2lkIDAsXCJpbXBvcnQgZXF1YWxzIGRlY2xhcmF0aW9uXCIpLHRoaXMuZXhwZWN0KG4uZXEpLHQubW9kdWxlUmVmZXJlbmNlPXRoaXMudHNQYXJzZU1vZHVsZVJlZmVyZW5jZSgpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKHQsXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIpfXRzSXNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpe3JldHVybiB0aGlzLmlzQ29udGV4dHVhbChcInJlcXVpcmVcIikmJjQwPT09dGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpfXRzUGFyc2VNb2R1bGVSZWZlcmVuY2UoKXtyZXR1cm4gdGhpcy50c0lzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoKT90aGlzLnRzUGFyc2VFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpOnRoaXMudHNQYXJzZUVudGl0eU5hbWUoITEpfXRzUGFyc2VFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtpZih0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJyZXF1aXJlXCIpLHRoaXMuZXhwZWN0KG4ucGFyZW5MKSwhdGhpcy5tYXRjaChuLnN0cmluZykpdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cmV0dXJuIHQuZXhwcmVzc2lvbj10aGlzLnBhcnNlRXhwckF0b20oKSx0aGlzLmV4cGVjdChuLnBhcmVuUiksdGhpcy5maW5pc2hOb2RlKHQsXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIpfXRzTG9va0FoZWFkKHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS5jbG9uZSgpLHM9dCgpO3JldHVybiB0aGlzLnN0YXRlPWUsc310c1RyeVBhcnNlQW5kQ2F0Y2godCl7Y29uc3QgZT10aGlzLnRyeVBhcnNlKGU9PnQoKXx8ZSgpKTtpZighZS5hYm9ydGVkJiZlLm5vZGUpcmV0dXJuIGUuZXJyb3ImJih0aGlzLnN0YXRlPWUuZmFpbFN0YXRlKSxlLm5vZGV9dHNUcnlQYXJzZSh0KXtjb25zdCBlPXRoaXMuc3RhdGUuY2xvbmUoKSxzPXQoKTtyZXR1cm4gdm9pZCAwIT09cyYmITEhPT1zP3M6dm9pZCh0aGlzLnN0YXRlPWUpfXRzVHJ5UGFyc2VEZWNsYXJlKHQpe2lmKHRoaXMuaXNMaW5lVGVybWluYXRvcigpKXJldHVybjtsZXQgZSxzPXRoaXMuc3RhdGUudHlwZTtzd2l0Y2godGhpcy5pc0NvbnRleHR1YWwoXCJsZXRcIikmJihzPW4uX3ZhcixlPVwibGV0XCIpLHMpe2Nhc2Ugbi5fZnVuY3Rpb246cmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudCh0LCExLCEwKTtjYXNlIG4uX2NsYXNzOnJldHVybiB0LmRlY2xhcmU9ITAsdGhpcy5wYXJzZUNsYXNzKHQsITAsITEpO2Nhc2Ugbi5fY29uc3Q6aWYodGhpcy5tYXRjaChuLl9jb25zdCkmJnRoaXMuaXNMb29rYWhlYWRDb250ZXh0dWFsKFwiZW51bVwiKSlyZXR1cm4gdGhpcy5leHBlY3Qobi5fY29uc3QpLHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImVudW1cIiksdGhpcy50c1BhcnNlRW51bURlY2xhcmF0aW9uKHQsITApO2Nhc2Ugbi5fdmFyOnJldHVybiBlPWV8fHRoaXMuc3RhdGUudmFsdWUsdGhpcy5wYXJzZVZhclN0YXRlbWVudCh0LGUpO2Nhc2Ugbi5uYW1lOntjb25zdCBlPXRoaXMuc3RhdGUudmFsdWU7cmV0dXJuXCJnbG9iYWxcIj09PWU/dGhpcy50c1BhcnNlQW1iaWVudEV4dGVybmFsTW9kdWxlRGVjbGFyYXRpb24odCk6dGhpcy50c1BhcnNlRGVjbGFyYXRpb24odCxlLCEwKX19fXRzVHJ5UGFyc2VFeHBvcnREZWNsYXJhdGlvbigpe3JldHVybiB0aGlzLnRzUGFyc2VEZWNsYXJhdGlvbih0aGlzLnN0YXJ0Tm9kZSgpLHRoaXMuc3RhdGUudmFsdWUsITApfXRzUGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KHQsZSl7c3dpdGNoKGUubmFtZSl7Y2FzZVwiZGVjbGFyZVwiOntjb25zdCBlPXRoaXMudHNUcnlQYXJzZURlY2xhcmUodCk7aWYoZSlyZXR1cm4gZS5kZWNsYXJlPSEwLGU7YnJlYWt9Y2FzZVwiZ2xvYmFsXCI6aWYodGhpcy5tYXRjaChuLmJyYWNlTCkpe3RoaXMuc2NvcGUuZW50ZXIoMTI4KSx0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtjb25zdCBzPXQ7cmV0dXJuIHMuZ2xvYmFsPSEwLHMuaWQ9ZSxzLmJvZHk9dGhpcy50c1BhcnNlTW9kdWxlQmxvY2soKSx0aGlzLnNjb3BlLmV4aXQoKSx0aGlzLnByb2RQYXJhbS5leGl0KCksdGhpcy5maW5pc2hOb2RlKHMsXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpfWJyZWFrO2RlZmF1bHQ6cmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKHQsZS5uYW1lLCExKX19dHNQYXJzZURlY2xhcmF0aW9uKHQsZSxzKXtzd2l0Y2goZSl7Y2FzZVwiYWJzdHJhY3RcIjppZih0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvckFuZE1hdGNoKG4uX2NsYXNzLHMpKXtjb25zdCBlPXQ7cmV0dXJuIGUuYWJzdHJhY3Q9ITAscyYmKHRoaXMubmV4dCgpLHRoaXMubWF0Y2gobi5fY2xhc3MpfHx0aGlzLnVuZXhwZWN0ZWQobnVsbCxuLl9jbGFzcykpLHRoaXMucGFyc2VDbGFzcyhlLCEwLCExKX1icmVhaztjYXNlXCJlbnVtXCI6aWYoc3x8dGhpcy5tYXRjaChuLm5hbWUpKXJldHVybiBzJiZ0aGlzLm5leHQoKSx0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24odCwhMSk7YnJlYWs7Y2FzZVwiaW50ZXJmYWNlXCI6aWYodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3JBbmRNYXRjaChuLm5hbWUscykpcmV0dXJuIHMmJnRoaXMubmV4dCgpLHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKHQpO2JyZWFrO2Nhc2VcIm1vZHVsZVwiOmlmKHMmJnRoaXMubmV4dCgpLHRoaXMubWF0Y2gobi5zdHJpbmcpKXJldHVybiB0aGlzLnRzUGFyc2VBbWJpZW50RXh0ZXJuYWxNb2R1bGVEZWNsYXJhdGlvbih0KTtpZih0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvckFuZE1hdGNoKG4ubmFtZSxzKSlyZXR1cm4gdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbih0KTticmVhaztjYXNlXCJuYW1lc3BhY2VcIjppZih0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvckFuZE1hdGNoKG4ubmFtZSxzKSlyZXR1cm4gcyYmdGhpcy5uZXh0KCksdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbih0KTticmVhaztjYXNlXCJ0eXBlXCI6aWYodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3JBbmRNYXRjaChuLm5hbWUscykpcmV0dXJuIHMmJnRoaXMubmV4dCgpLHRoaXMudHNQYXJzZVR5cGVBbGlhc0RlY2xhcmF0aW9uKHQpfX10c0NoZWNrTGluZVRlcm1pbmF0b3JBbmRNYXRjaCh0LGUpe3JldHVybihlfHx0aGlzLm1hdGNoKHQpKSYmIXRoaXMuaXNMaW5lVGVybWluYXRvcigpfXRzVHJ5UGFyc2VHZW5lcmljQXN5bmNBcnJvd0Z1bmN0aW9uKHQsZSl7aWYoIXRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSlyZXR1cm47Y29uc3Qgcz10aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMsaT10aGlzLnN0YXRlLnlpZWxkUG9zLHI9dGhpcy5zdGF0ZS5hd2FpdFBvczt0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM9ITAsdGhpcy5zdGF0ZS55aWVsZFBvcz0tMSx0aGlzLnN0YXRlLmF3YWl0UG9zPS0xO2NvbnN0IGE9dGhpcy50c1RyeVBhcnNlQW5kQ2F0Y2goKCk9Pntjb25zdCBzPXRoaXMuc3RhcnROb2RlQXQodCxlKTtyZXR1cm4gcy50eXBlUGFyYW1ldGVycz10aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVycygpLHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMocykscy5yZXR1cm5UeXBlPXRoaXMudHNUcnlQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKCksdGhpcy5leHBlY3Qobi5hcnJvdyksc30pO3JldHVybiB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM9cyx0aGlzLnN0YXRlLnlpZWxkUG9zPWksdGhpcy5zdGF0ZS5hd2FpdFBvcz1yLGE/dGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihhLG51bGwsITApOnZvaWQgMH10c1BhcnNlVHlwZUFyZ3VtZW50cygpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC5wYXJhbXM9dGhpcy50c0luVHlwZSgoKT0+dGhpcy50c0luTm9Db250ZXh0KCgpPT4odGhpcy5leHBlY3RSZWxhdGlvbmFsKFwiPFwiKSx0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiLHRoaXMudHNQYXJzZVR5cGUuYmluZCh0aGlzKSkpKSksdGhpcy5zdGF0ZS5leHByQWxsb3dlZD0hMSx0aGlzLmV4cGVjdFJlbGF0aW9uYWwoXCI+XCIpLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKX10c0lzRGVjbGFyYXRpb25TdGFydCgpe2lmKHRoaXMubWF0Y2gobi5uYW1lKSlzd2l0Y2godGhpcy5zdGF0ZS52YWx1ZSl7Y2FzZVwiYWJzdHJhY3RcIjpjYXNlXCJkZWNsYXJlXCI6Y2FzZVwiZW51bVwiOmNhc2VcImludGVyZmFjZVwiOmNhc2VcIm1vZHVsZVwiOmNhc2VcIm5hbWVzcGFjZVwiOmNhc2VcInR5cGVcIjpyZXR1cm4hMH1yZXR1cm4hMX1pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKXtyZXR1cm4hdGhpcy50c0lzRGVjbGFyYXRpb25TdGFydCgpJiZzdXBlci5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKX1wYXJzZUFzc2lnbmFibGVMaXN0SXRlbSh0LGUpe2NvbnN0IHM9dGhpcy5zdGF0ZS5zdGFydCxpPXRoaXMuc3RhdGUuc3RhcnRMb2M7bGV0IHIsYT0hMTt0JiYocj10aGlzLnBhcnNlQWNjZXNzTW9kaWZpZXIoKSxhPSEhdGhpcy50c1BhcnNlTW9kaWZpZXIoW1wicmVhZG9ubHlcIl0pKTtjb25zdCBuPXRoaXMucGFyc2VNYXliZURlZmF1bHQoKTt0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXMobik7Y29uc3Qgbz10aGlzLnBhcnNlTWF5YmVEZWZhdWx0KG4uc3RhcnQsbi5sb2Muc3RhcnQsbik7aWYocnx8YSl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZUF0KHMsaSk7cmV0dXJuIGUubGVuZ3RoJiYodC5kZWNvcmF0b3JzPWUpLHImJih0LmFjY2Vzc2liaWxpdHk9ciksYSYmKHQucmVhZG9ubHk9YSksXCJJZGVudGlmaWVyXCIhPT1vLnR5cGUmJlwiQXNzaWdubWVudFBhdHRlcm5cIiE9PW8udHlwZSYmdGhpcy5yYWlzZSh0LnN0YXJ0LHJ0LlVuc3VwcG9ydGVkUGFyYW1ldGVyUHJvcGVydHlLaW5kKSx0LnBhcmFtZXRlcj1vLHRoaXMuZmluaXNoTm9kZSh0LFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiKX1yZXR1cm4gZS5sZW5ndGgmJihuLmRlY29yYXRvcnM9ZSksb31wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaCh0LGUscz0hMSl7dGhpcy5tYXRjaChuLmNvbG9uKSYmKHQucmV0dXJuVHlwZT10aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbihuLmNvbG9uKSk7Y29uc3QgaT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cIj09PWU/XCJUU0RlY2xhcmVGdW5jdGlvblwiOlwiQ2xhc3NNZXRob2RcIj09PWU/XCJUU0RlY2xhcmVNZXRob2RcIjp2b2lkIDA7aSYmIXRoaXMubWF0Y2gobi5icmFjZUwpJiZ0aGlzLmlzTGluZVRlcm1pbmF0b3IoKT90aGlzLmZpbmlzaE5vZGUodCxpKTpzdXBlci5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaCh0LGUscyl9cmVnaXN0ZXJGdW5jdGlvblN0YXRlbWVudElkKHQpeyF0LmJvZHkmJnQuaWQ/dGhpcy5jaGVja0xWYWwodC5pZCwxMDI0LG51bGwsXCJmdW5jdGlvbiBuYW1lXCIpOnN1cGVyLnJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZCguLi5hcmd1bWVudHMpfXBhcnNlU3Vic2NyaXB0KHQsZSxzLGkscil7aWYoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkmJnRoaXMubWF0Y2gobi5iYW5nKSl7dGhpcy5zdGF0ZS5leHByQWxsb3dlZD0hMSx0aGlzLm5leHQoKTtjb25zdCBpPXRoaXMuc3RhcnROb2RlQXQoZSxzKTtyZXR1cm4gaS5leHByZXNzaW9uPXQsdGhpcy5maW5pc2hOb2RlKGksXCJUU05vbk51bGxFeHByZXNzaW9uXCIpfWlmKHRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSl7Y29uc3QgYT10aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKT0+e2lmKCFpJiZ0aGlzLmF0UG9zc2libGVBc3luY0Fycm93KHQpKXtjb25zdCB0PXRoaXMudHNUcnlQYXJzZUdlbmVyaWNBc3luY0Fycm93RnVuY3Rpb24oZSxzKTtpZih0KXJldHVybiB0fWNvbnN0IGE9dGhpcy5zdGFydE5vZGVBdChlLHMpO2EuY2FsbGVlPXQ7Y29uc3Qgbz10aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7aWYobyl7aWYoIWkmJnRoaXMuZWF0KG4ucGFyZW5MKSlyZXR1cm4gYS5hcmd1bWVudHM9dGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKG4ucGFyZW5SLCExKSxhLnR5cGVQYXJhbWV0ZXJzPW8sdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihhLHIub3B0aW9uYWxDaGFpbk1lbWJlcik7aWYodGhpcy5tYXRjaChuLmJhY2tRdW90ZSkpcmV0dXJuIHRoaXMucGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oZSxzLHQscixvKX10aGlzLnVuZXhwZWN0ZWQoKX0pO2lmKGEpcmV0dXJuIGF9cmV0dXJuIHN1cGVyLnBhcnNlU3Vic2NyaXB0KHQsZSxzLGkscil9cGFyc2VOZXdBcmd1bWVudHModCl7aWYodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKXtjb25zdCBlPXRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpPT57Y29uc3QgdD10aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7cmV0dXJuIHRoaXMubWF0Y2gobi5wYXJlbkwpfHx0aGlzLnVuZXhwZWN0ZWQoKSx0fSk7ZSYmKHQudHlwZVBhcmFtZXRlcnM9ZSl9c3VwZXIucGFyc2VOZXdBcmd1bWVudHModCl9cGFyc2VFeHByT3AodCxlLHMsaSxyKXtpZihzdChuLl9pbi5iaW5vcCk+aSYmIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkmJnRoaXMuaXNDb250ZXh0dWFsKFwiYXNcIikpe2NvbnN0IGE9dGhpcy5zdGFydE5vZGVBdChlLHMpO2EuZXhwcmVzc2lvbj10O2NvbnN0IG49dGhpcy50c1RyeU5leHRQYXJzZUNvbnN0YW50Q29udGV4dCgpO3JldHVybiBhLnR5cGVBbm5vdGF0aW9uPW58fHRoaXMudHNOZXh0VGhlblBhcnNlVHlwZSgpLHRoaXMuZmluaXNoTm9kZShhLFwiVFNBc0V4cHJlc3Npb25cIiksdGhpcy5wYXJzZUV4cHJPcChhLGUscyxpLHIpfXJldHVybiBzdXBlci5wYXJzZUV4cHJPcCh0LGUscyxpLHIpfWNoZWNrUmVzZXJ2ZWRXb3JkKHQsZSxzLGkpe31jaGVja0R1cGxpY2F0ZUV4cG9ydHMoKXt9cGFyc2VJbXBvcnQodCl7aWYodGhpcy5tYXRjaChuLm5hbWUpfHx0aGlzLm1hdGNoKG4uc3Rhcil8fHRoaXMubWF0Y2gobi5icmFjZUwpKXtjb25zdCBlPXRoaXMubG9va2FoZWFkKCk7aWYodGhpcy5tYXRjaChuLm5hbWUpJiZlLnR5cGU9PT1uLmVxKXJldHVybiB0aGlzLnRzUGFyc2VJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbih0KTshdGhpcy5pc0NvbnRleHR1YWwoXCJ0eXBlXCIpfHxlLnR5cGU9PT1uLmNvbW1hfHxlLnR5cGU9PT1uLm5hbWUmJlwiZnJvbVwiPT09ZS52YWx1ZT90LmltcG9ydEtpbmQ9XCJ2YWx1ZVwiOih0LmltcG9ydEtpbmQ9XCJ0eXBlXCIsdGhpcy5uZXh0KCkpfWNvbnN0IGU9c3VwZXIucGFyc2VJbXBvcnQodCk7cmV0dXJuXCJ0eXBlXCI9PT1lLmltcG9ydEtpbmQmJmUuc3BlY2lmaWVycy5sZW5ndGg+MSYmXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCI9PT1lLnNwZWNpZmllcnNbMF0udHlwZSYmdGhpcy5yYWlzZShlLnN0YXJ0LFwiQSB0eXBlLW9ubHkgaW1wb3J0IGNhbiBzcGVjaWZ5IGEgZGVmYXVsdCBpbXBvcnQgb3IgbmFtZWQgYmluZGluZ3MsIGJ1dCBub3QgYm90aC5cIiksZX1wYXJzZUV4cG9ydCh0KXtpZih0aGlzLm1hdGNoKG4uX2ltcG9ydCkpcmV0dXJuIHRoaXMuZXhwZWN0KG4uX2ltcG9ydCksdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24odCwhMCk7aWYodGhpcy5lYXQobi5lcSkpe2NvbnN0IGU9dDtyZXR1cm4gZS5leHByZXNzaW9uPXRoaXMucGFyc2VFeHByZXNzaW9uKCksdGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUoZSxcIlRTRXhwb3J0QXNzaWdubWVudFwiKX1pZih0aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKSl7Y29uc3QgZT10O3JldHVybiB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJuYW1lc3BhY2VcIiksZS5pZD10aGlzLnBhcnNlSWRlbnRpZmllcigpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKGUsXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIpfXJldHVybiB0aGlzLmlzQ29udGV4dHVhbChcInR5cGVcIikmJnRoaXMubG9va2FoZWFkKCkudHlwZT09PW4uYnJhY2VMPyh0aGlzLm5leHQoKSx0LmV4cG9ydEtpbmQ9XCJ0eXBlXCIpOnQuZXhwb3J0S2luZD1cInZhbHVlXCIsc3VwZXIucGFyc2VFeHBvcnQodCl9aXNBYnN0cmFjdENsYXNzKCl7cmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKFwiYWJzdHJhY3RcIikmJnRoaXMubG9va2FoZWFkKCkudHlwZT09PW4uX2NsYXNzfXBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKXtpZih0aGlzLmlzQWJzdHJhY3RDbGFzcygpKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMucGFyc2VDbGFzcyh0LCEwLCEwKSx0LmFic3RyYWN0PSEwLHR9aWYoXCJpbnRlcmZhY2VcIj09PXRoaXMuc3RhdGUudmFsdWUpe2NvbnN0IHQ9dGhpcy50c1BhcnNlRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSx0aGlzLnN0YXRlLnZhbHVlLCEwKTtpZih0KXJldHVybiB0fXJldHVybiBzdXBlci5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCl9cGFyc2VTdGF0ZW1lbnRDb250ZW50KHQsZSl7aWYodGhpcy5zdGF0ZS50eXBlPT09bi5fY29uc3Qpe2NvbnN0IHQ9dGhpcy5sb29rYWhlYWQoKTtpZih0LnR5cGU9PT1uLm5hbWUmJlwiZW51bVwiPT09dC52YWx1ZSl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLmV4cGVjdChuLl9jb25zdCksdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZW51bVwiKSx0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24odCwhMCl9fXJldHVybiBzdXBlci5wYXJzZVN0YXRlbWVudENvbnRlbnQodCxlKX1wYXJzZUFjY2Vzc01vZGlmaWVyKCl7cmV0dXJuIHRoaXMudHNQYXJzZU1vZGlmaWVyKFtcInB1YmxpY1wiLFwicHJvdGVjdGVkXCIsXCJwcml2YXRlXCJdKX1wYXJzZUNsYXNzTWVtYmVyKHQsZSxzLGkpe3RoaXMudHNQYXJzZU1vZGlmaWVycyhlLFtcImRlY2xhcmVcIl0pO2NvbnN0IHI9dGhpcy5wYXJzZUFjY2Vzc01vZGlmaWVyKCk7ciYmKGUuYWNjZXNzaWJpbGl0eT1yKSx0aGlzLnRzUGFyc2VNb2RpZmllcnMoZSxbXCJkZWNsYXJlXCJdKSxzdXBlci5wYXJzZUNsYXNzTWVtYmVyKHQsZSxzLGkpfXBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWModCxlLHMsaSxyKXt0aGlzLnRzUGFyc2VNb2RpZmllcnMoZSxbXCJhYnN0cmFjdFwiLFwicmVhZG9ubHlcIixcImRlY2xhcmVcIl0pO2NvbnN0IGE9dGhpcy50c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUoZSk7aWYoYSlyZXR1cm4gdC5ib2R5LnB1c2goYSksZS5hYnN0cmFjdCYmdGhpcy5yYWlzZShlLnN0YXJ0LHJ0LkluZGV4U2lnbmF0dXJlSGFzQWJzdHJhY3QpLGkmJnRoaXMucmFpc2UoZS5zdGFydCxydC5JbmRleFNpZ25hdHVyZUhhc1N0YXRpYyksdm9pZChlLmFjY2Vzc2liaWxpdHkmJnRoaXMucmFpc2UoZS5zdGFydCxydC5JbmRleFNpZ25hdHVyZUhhc0FjY2Vzc2liaWxpdHksZS5hY2Nlc3NpYmlsaXR5KSk7c3VwZXIucGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyh0LGUscyxpLHIpfXBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnModCl7dGhpcy5lYXQobi5xdWVzdGlvbikmJih0Lm9wdGlvbmFsPSEwKSx0LnJlYWRvbmx5JiZ0aGlzLm1hdGNoKG4ucGFyZW5MKSYmdGhpcy5yYWlzZSh0LnN0YXJ0LHJ0LkNsYXNzTWV0aG9kSGFzUmVhZG9ubHkpLHQuZGVjbGFyZSYmdGhpcy5tYXRjaChuLnBhcmVuTCkmJnRoaXMucmFpc2UodC5zdGFydCxydC5DbGFzc01ldGhvZEhhc0RlY2xhcmUpfXBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCh0LGUpe3JldHVybihcIklkZW50aWZpZXJcIj09PWUudHlwZT90aGlzLnRzUGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KHQsZSk6dm9pZCAwKXx8c3VwZXIucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KHQsZSl9c2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpe3JldHVybiEhdGhpcy50c0lzRGVjbGFyYXRpb25TdGFydCgpfHxzdXBlci5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCl9cGFyc2VDb25kaXRpb25hbCh0LGUscyxpLHIpe2lmKCFyfHwhdGhpcy5tYXRjaChuLnF1ZXN0aW9uKSlyZXR1cm4gc3VwZXIucGFyc2VDb25kaXRpb25hbCh0LGUscyxpLHIpO2NvbnN0IGE9dGhpcy50cnlQYXJzZSgoKT0+c3VwZXIucGFyc2VDb25kaXRpb25hbCh0LGUscyxpKSk7cmV0dXJuIGEubm9kZT8oYS5lcnJvciYmKHRoaXMuc3RhdGU9YS5mYWlsU3RhdGUpLGEubm9kZSk6KHIuc3RhcnQ9YS5lcnJvci5wb3N8fHRoaXMuc3RhdGUuc3RhcnQsdCl9cGFyc2VQYXJlbkl0ZW0odCxlLHMpe2lmKHQ9c3VwZXIucGFyc2VQYXJlbkl0ZW0odCxlLHMpLHRoaXMuZWF0KG4ucXVlc3Rpb24pJiYodC5vcHRpb25hbD0hMCx0aGlzLnJlc2V0RW5kTG9jYXRpb24odCkpLHRoaXMubWF0Y2gobi5jb2xvbikpe2NvbnN0IGk9dGhpcy5zdGFydE5vZGVBdChlLHMpO3JldHVybiBpLmV4cHJlc3Npb249dCxpLnR5cGVBbm5vdGF0aW9uPXRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCksdGhpcy5maW5pc2hOb2RlKGksXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKX1yZXR1cm4gdH1wYXJzZUV4cG9ydERlY2xhcmF0aW9uKHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS5zdGFydCxzPXRoaXMuc3RhdGUuc3RhcnRMb2MsaT10aGlzLmVhdENvbnRleHR1YWwoXCJkZWNsYXJlXCIpO2xldCByO3JldHVybiB0aGlzLm1hdGNoKG4ubmFtZSkmJihyPXRoaXMudHNUcnlQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkpLHJ8fChyPXN1cGVyLnBhcnNlRXhwb3J0RGVjbGFyYXRpb24odCkpLHImJihcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIj09PXIudHlwZXx8XCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCI9PT1yLnR5cGV8fGkpJiYodC5leHBvcnRLaW5kPVwidHlwZVwiKSxyJiZpJiYodGhpcy5yZXNldFN0YXJ0TG9jYXRpb24ocixlLHMpLHIuZGVjbGFyZT0hMCkscn1wYXJzZUNsYXNzSWQodCxlLHMpe2lmKCghZXx8cykmJnRoaXMuaXNDb250ZXh0dWFsKFwiaW1wbGVtZW50c1wiKSlyZXR1cm47c3VwZXIucGFyc2VDbGFzc0lkKHQsZSxzLHQuZGVjbGFyZT8xMDI0OjEzOSk7Y29uc3QgaT10aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpO2kmJih0LnR5cGVQYXJhbWV0ZXJzPWkpfXBhcnNlQ2xhc3NQcm9wZXJ0eUFubm90YXRpb24odCl7IXQub3B0aW9uYWwmJnRoaXMuZWF0KG4uYmFuZykmJih0LmRlZmluaXRlPSEwKTtjb25zdCBlPXRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7ZSYmKHQudHlwZUFubm90YXRpb249ZSl9cGFyc2VDbGFzc1Byb3BlcnR5KHQpe3JldHVybiB0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eUFubm90YXRpb24odCksdC5kZWNsYXJlJiZ0aGlzLm1hdGNoKG4uZXF1YWwpJiZ0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQscnQuRGVjbGFyZUNsYXNzRmllbGRIYXNJbml0aWFsaXplciksc3VwZXIucGFyc2VDbGFzc1Byb3BlcnR5KHQpfXBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkodCl7cmV0dXJuIHQuYWJzdHJhY3QmJnRoaXMucmFpc2UodC5zdGFydCxydC5Qcml2YXRlRWxlbWVudEhhc0Fic3RyYWN0KSx0LmFjY2Vzc2liaWxpdHkmJnRoaXMucmFpc2UodC5zdGFydCxydC5Qcml2YXRlRWxlbWVudEhhc0FjY2Vzc2liaWxpdHksdC5hY2Nlc3NpYmlsaXR5KSx0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eUFubm90YXRpb24odCksc3VwZXIucGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eSh0KX1wdXNoQ2xhc3NNZXRob2QodCxlLHMsaSxyLGEpe2NvbnN0IG49dGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnMoKTtuJiYoZS50eXBlUGFyYW1ldGVycz1uKSxzdXBlci5wdXNoQ2xhc3NNZXRob2QodCxlLHMsaSxyLGEpfXB1c2hDbGFzc1ByaXZhdGVNZXRob2QodCxlLHMsaSl7Y29uc3Qgcj10aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycygpO3ImJihlLnR5cGVQYXJhbWV0ZXJzPXIpLHN1cGVyLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QodCxlLHMsaSl9cGFyc2VDbGFzc1N1cGVyKHQpe3N1cGVyLnBhcnNlQ2xhc3NTdXBlcih0KSx0LnN1cGVyQ2xhc3MmJnRoaXMuaXNSZWxhdGlvbmFsKFwiPFwiKSYmKHQuc3VwZXJUeXBlUGFyYW1ldGVycz10aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCkpLHRoaXMuZWF0Q29udGV4dHVhbChcImltcGxlbWVudHNcIikmJih0LmltcGxlbWVudHM9dGhpcy50c1BhcnNlSGVyaXRhZ2VDbGF1c2UoXCJpbXBsZW1lbnRzXCIpKX1wYXJzZU9ialByb3BWYWx1ZSh0LC4uLmUpe2NvbnN0IHM9dGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnMoKTtzJiYodC50eXBlUGFyYW1ldGVycz1zKSxzdXBlci5wYXJzZU9ialByb3BWYWx1ZSh0LC4uLmUpfXBhcnNlRnVuY3Rpb25QYXJhbXModCxlKXtjb25zdCBzPXRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKCk7cyYmKHQudHlwZVBhcmFtZXRlcnM9cyksc3VwZXIucGFyc2VGdW5jdGlvblBhcmFtcyh0LGUpfXBhcnNlVmFySWQodCxlKXtzdXBlci5wYXJzZVZhcklkKHQsZSksXCJJZGVudGlmaWVyXCI9PT10LmlkLnR5cGUmJnRoaXMuZWF0KG4uYmFuZykmJih0LmRlZmluaXRlPSEwKTtjb25zdCBzPXRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7cyYmKHQuaWQudHlwZUFubm90YXRpb249cyx0aGlzLnJlc2V0RW5kTG9jYXRpb24odC5pZCkpfXBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbih0LGUpe3JldHVybiB0aGlzLm1hdGNoKG4uY29sb24pJiYodC5yZXR1cm5UeXBlPXRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCkpLHN1cGVyLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbih0LGUpfXBhcnNlTWF5YmVBc3NpZ24oLi4udCl7bGV0IGUscyxpLHI7aWYodGhpcy5tYXRjaChuLmpzeFRhZ1N0YXJ0KSl7aWYoZT10aGlzLnN0YXRlLmNsb25lKCkscz10aGlzLnRyeVBhcnNlKCgpPT5zdXBlci5wYXJzZU1heWJlQXNzaWduKC4uLnQpLGUpLCFzLmVycm9yKXJldHVybiBzLm5vZGU7Y29uc3R7Y29udGV4dDppfT10aGlzLnN0YXRlO2lbaS5sZW5ndGgtMV09PT14Lmpfb1RhZz9pLmxlbmd0aC09MjppW2kubGVuZ3RoLTFdPT09eC5qX2V4cHImJihpLmxlbmd0aC09MSl9aWYoIShzJiZzLmVycm9yfHx0aGlzLmlzUmVsYXRpb25hbChcIjxcIikpKXJldHVybiBzdXBlci5wYXJzZU1heWJlQXNzaWduKC4uLnQpO2U9ZXx8dGhpcy5zdGF0ZS5jbG9uZSgpO2NvbnN0IGE9dGhpcy50cnlQYXJzZShlPT57cj10aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVycygpO2NvbnN0IHM9c3VwZXIucGFyc2VNYXliZUFzc2lnbiguLi50KTtyZXR1cm4oXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIT09cy50eXBlfHxzLmV4dHJhJiZzLmV4dHJhLnBhcmVudGhlc2l6ZWQpJiZlKCksciYmMCE9PXIucGFyYW1zLmxlbmd0aCYmdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShzLHIpLHMudHlwZVBhcmFtZXRlcnM9cixzfSxlKTtpZighYS5lcnJvciYmIWEuYWJvcnRlZClyZXR1cm4gYS5ub2RlO2lmKCFzJiYoaXQoIXRoaXMuaGFzUGx1Z2luKFwianN4XCIpKSxpPXRoaXMudHJ5UGFyc2UoKCk9PnN1cGVyLnBhcnNlTWF5YmVBc3NpZ24oLi4udCksZSksIWkuZXJyb3IpKXJldHVybiBpLm5vZGU7aWYocyYmcy5ub2RlKXJldHVybiB0aGlzLnN0YXRlPXMuZmFpbFN0YXRlLHMubm9kZTtpZihhLm5vZGUpcmV0dXJuIHRoaXMuc3RhdGU9YS5mYWlsU3RhdGUsYS5ub2RlO2lmKGkmJmkubm9kZSlyZXR1cm4gdGhpcy5zdGF0ZT1pLmZhaWxTdGF0ZSxpLm5vZGU7aWYocyYmcy50aHJvd24pdGhyb3cgcy5lcnJvcjtpZihhLnRocm93bil0aHJvdyBhLmVycm9yO2lmKGkmJmkudGhyb3duKXRocm93IGkuZXJyb3I7dGhyb3cgcyYmcy5lcnJvcnx8YS5lcnJvcnx8aSYmaS5lcnJvcn1wYXJzZU1heWJlVW5hcnkodCl7cmV0dXJuIXRoaXMuaGFzUGx1Z2luKFwianN4XCIpJiZ0aGlzLmlzUmVsYXRpb25hbChcIjxcIik/dGhpcy50c1BhcnNlVHlwZUFzc2VydGlvbigpOnN1cGVyLnBhcnNlTWF5YmVVbmFyeSh0KX1wYXJzZUFycm93KHQpe2lmKHRoaXMubWF0Y2gobi5jb2xvbikpe2NvbnN0IGU9dGhpcy50cnlQYXJzZSh0PT57Y29uc3QgZT10aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbihuLmNvbG9uKTtyZXR1cm4hdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSYmdGhpcy5tYXRjaChuLmFycm93KXx8dCgpLGV9KTtpZihlLmFib3J0ZWQpcmV0dXJuO2UudGhyb3dufHwoZS5lcnJvciYmKHRoaXMuc3RhdGU9ZS5mYWlsU3RhdGUpLHQucmV0dXJuVHlwZT1lLm5vZGUpfXJldHVybiBzdXBlci5wYXJzZUFycm93KHQpfXBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXModCl7dGhpcy5lYXQobi5xdWVzdGlvbikmJihcIklkZW50aWZpZXJcIiE9PXQudHlwZSYmdGhpcy5yYWlzZSh0LnN0YXJ0LHJ0LlBhdHRlcm5Jc09wdGlvbmFsKSx0Lm9wdGlvbmFsPSEwKTtjb25zdCBlPXRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7cmV0dXJuIGUmJih0LnR5cGVBbm5vdGF0aW9uPWUpLHRoaXMucmVzZXRFbmRMb2NhdGlvbih0KSx0fXRvQXNzaWduYWJsZSh0KXtzd2l0Y2godC50eXBlKXtjYXNlXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiOnJldHVybiBzdXBlci50b0Fzc2lnbmFibGUodGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKHQpKTtjYXNlXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6cmV0dXJuIHN1cGVyLnRvQXNzaWduYWJsZSh0KTtjYXNlXCJUU0FzRXhwcmVzc2lvblwiOmNhc2VcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpjYXNlXCJUU1R5cGVBc3NlcnRpb25cIjpyZXR1cm4gdC5leHByZXNzaW9uPXRoaXMudG9Bc3NpZ25hYmxlKHQuZXhwcmVzc2lvbiksdDtkZWZhdWx0OnJldHVybiBzdXBlci50b0Fzc2lnbmFibGUodCl9fWNoZWNrTFZhbCh0LGU9NjQscyxpKXtzd2l0Y2godC50eXBlKXtjYXNlXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiOnJldHVybjtjYXNlXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6cmV0dXJuIHZvaWQgdGhpcy5jaGVja0xWYWwodC5wYXJhbWV0ZXIsZSxzLFwicGFyYW1ldGVyIHByb3BlcnR5XCIpO2Nhc2VcIlRTQXNFeHByZXNzaW9uXCI6Y2FzZVwiVFNOb25OdWxsRXhwcmVzc2lvblwiOmNhc2VcIlRTVHlwZUFzc2VydGlvblwiOnJldHVybiB2b2lkIHRoaXMuY2hlY2tMVmFsKHQuZXhwcmVzc2lvbixlLHMsaSk7ZGVmYXVsdDpyZXR1cm4gdm9pZCBzdXBlci5jaGVja0xWYWwodCxlLHMsaSl9fXBhcnNlQmluZGluZ0F0b20oKXtzd2l0Y2godGhpcy5zdGF0ZS50eXBlKXtjYXNlIG4uX3RoaXM6cmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKCEwKTtkZWZhdWx0OnJldHVybiBzdXBlci5wYXJzZUJpbmRpbmdBdG9tKCl9fXBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHModCl7aWYodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKXtjb25zdCBlPXRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtpZih0aGlzLm1hdGNoKG4ucGFyZW5MKSl7Y29uc3Qgcz1zdXBlci5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKHQpO3JldHVybiBzLnR5cGVQYXJhbWV0ZXJzPWUsc310aGlzLnVuZXhwZWN0ZWQodGhpcy5zdGF0ZS5zdGFydCxuLnBhcmVuTCl9cmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHModCl9aXNDbGFzc01ldGhvZCgpe3JldHVybiB0aGlzLmlzUmVsYXRpb25hbChcIjxcIil8fHN1cGVyLmlzQ2xhc3NNZXRob2QoKX1pc0NsYXNzUHJvcGVydHkoKXtyZXR1cm4gdGhpcy5tYXRjaChuLmJhbmcpfHx0aGlzLm1hdGNoKG4uY29sb24pfHxzdXBlci5pc0NsYXNzUHJvcGVydHkoKX1wYXJzZU1heWJlRGVmYXVsdCguLi50KXtjb25zdCBlPXN1cGVyLnBhcnNlTWF5YmVEZWZhdWx0KC4uLnQpO3JldHVyblwiQXNzaWdubWVudFBhdHRlcm5cIj09PWUudHlwZSYmZS50eXBlQW5ub3RhdGlvbiYmZS5yaWdodC5zdGFydDxlLnR5cGVBbm5vdGF0aW9uLnN0YXJ0JiZ0aGlzLnJhaXNlKGUudHlwZUFubm90YXRpb24uc3RhcnQscnQuVHlwZUFubm90YXRpb25BZnRlckFzc2lnbiksZX1nZXRUb2tlbkZyb21Db2RlKHQpe3JldHVybiF0aGlzLnN0YXRlLmluVHlwZXx8NjIhPT10JiY2MCE9PXQ/c3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZSh0KTp0aGlzLmZpbmlzaE9wKG4ucmVsYXRpb25hbCwxKX10b0Fzc2lnbmFibGVMaXN0KHQpe2ZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBzPXRbZV07aWYocylzd2l0Y2gocy50eXBlKXtjYXNlXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiOnRbZV09dGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKHMpO2JyZWFrO2Nhc2VcIlRTQXNFeHByZXNzaW9uXCI6Y2FzZVwiVFNUeXBlQXNzZXJ0aW9uXCI6dGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzP3RoaXMucmFpc2Uocy5zdGFydCxydC5VbmV4cGVjdGVkVHlwZUNhc3RJblBhcmFtZXRlcik6dFtlXT10aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIocyl9fXJldHVybiBzdXBlci50b0Fzc2lnbmFibGVMaXN0KC4uLmFyZ3VtZW50cyl9dHlwZUNhc3RUb1BhcmFtZXRlcih0KXtyZXR1cm4gdC5leHByZXNzaW9uLnR5cGVBbm5vdGF0aW9uPXQudHlwZUFubm90YXRpb24sdGhpcy5yZXNldEVuZExvY2F0aW9uKHQuZXhwcmVzc2lvbix0LnR5cGVBbm5vdGF0aW9uLmVuZCx0LnR5cGVBbm5vdGF0aW9uLmxvYy5lbmQpLHQuZXhwcmVzc2lvbn10b1JlZmVyZW5jZWRMaXN0KHQsZSl7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IHM9dFtlXTtzJiZcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCI9PT1zLnR5cGUmJnRoaXMucmFpc2Uocy5zdGFydCxydC5VbmV4cGVjdGVkVHlwZUFubm90YXRpb24pfXJldHVybiB0fXNob3VsZFBhcnNlQXJyb3coKXtyZXR1cm4gdGhpcy5tYXRjaChuLmNvbG9uKXx8c3VwZXIuc2hvdWxkUGFyc2VBcnJvdygpfXNob3VsZFBhcnNlQXN5bmNBcnJvdygpe3JldHVybiB0aGlzLm1hdGNoKG4uY29sb24pfHxzdXBlci5zaG91bGRQYXJzZUFzeW5jQXJyb3coKX1jYW5IYXZlTGVhZGluZ0RlY29yYXRvcigpe3JldHVybiBzdXBlci5jYW5IYXZlTGVhZGluZ0RlY29yYXRvcigpfHx0aGlzLmlzQWJzdHJhY3RDbGFzcygpfWpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUodCl7aWYodGhpcy5pc1JlbGF0aW9uYWwoXCI8XCIpKXtjb25zdCBlPXRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpPT50aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCkpO2UmJih0LnR5cGVQYXJhbWV0ZXJzPWUpfXJldHVybiBzdXBlci5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKHQpfWdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudCh0KXtjb25zdCBlPXN1cGVyLmdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudCh0KSxzPXQucGFyYW1zWzBdO3JldHVybiBzJiZcIklkZW50aWZpZXJcIj09PXMudHlwZSYmXCJ0aGlzXCI9PT1zLm5hbWU/ZSsxOmV9fSx2OGludHJpbnNpYzp0PT5jbGFzcyBleHRlbmRzIHR7cGFyc2VWOEludHJpbnNpYygpe2lmKHRoaXMubWF0Y2gobi5tb2R1bG8pKXtjb25zdCB0PXRoaXMuc3RhdGUuc3RhcnQsZT10aGlzLnN0YXJ0Tm9kZSgpO2lmKHRoaXMuZWF0KG4ubW9kdWxvKSx0aGlzLm1hdGNoKG4ubmFtZSkpe2NvbnN0IHQ9dGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKHRoaXMuc3RhdGUuc3RhcnQpLHM9dGhpcy5jcmVhdGVJZGVudGlmaWVyKGUsdCk7aWYocy50eXBlPVwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIsdGhpcy5tYXRjaChuLnBhcmVuTCkpcmV0dXJuIHN9dGhpcy51bmV4cGVjdGVkKHQpfX1wYXJzZUV4cHJBdG9tKCl7cmV0dXJuIHRoaXMucGFyc2VWOEludHJpbnNpYygpfHxzdXBlci5wYXJzZUV4cHJBdG9tKC4uLmFyZ3VtZW50cyl9fSxwbGFjZWhvbGRlcnM6dD0+Y2xhc3MgZXh0ZW5kcyB0e3BhcnNlUGxhY2Vob2xkZXIodCl7aWYodGhpcy5tYXRjaChuLnBsYWNlaG9sZGVyKSl7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSx0aGlzLmFzc2VydE5vU3BhY2UoXCJVbmV4cGVjdGVkIHNwYWNlIGluIHBsYWNlaG9sZGVyLlwiKSxlLm5hbWU9c3VwZXIucGFyc2VJZGVudGlmaWVyKCEwKSx0aGlzLmFzc2VydE5vU3BhY2UoXCJVbmV4cGVjdGVkIHNwYWNlIGluIHBsYWNlaG9sZGVyLlwiKSx0aGlzLmV4cGVjdChuLnBsYWNlaG9sZGVyKSx0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKGUsdCl9fWZpbmlzaFBsYWNlaG9sZGVyKHQsZSl7Y29uc3Qgcz0hKCF0LmV4cGVjdGVkTm9kZXx8XCJQbGFjZWhvbGRlclwiIT09dC50eXBlKTtyZXR1cm4gdC5leHBlY3RlZE5vZGU9ZSxzP3Q6dGhpcy5maW5pc2hOb2RlKHQsXCJQbGFjZWhvbGRlclwiKX1nZXRUb2tlbkZyb21Db2RlKHQpe3JldHVybiAzNz09PXQmJjM3PT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpP3RoaXMuZmluaXNoT3Aobi5wbGFjZWhvbGRlciwyKTpzdXBlci5nZXRUb2tlbkZyb21Db2RlKC4uLmFyZ3VtZW50cyl9cGFyc2VFeHByQXRvbSgpe3JldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJFeHByZXNzaW9uXCIpfHxzdXBlci5wYXJzZUV4cHJBdG9tKC4uLmFyZ3VtZW50cyl9cGFyc2VJZGVudGlmaWVyKCl7cmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIil8fHN1cGVyLnBhcnNlSWRlbnRpZmllciguLi5hcmd1bWVudHMpfWNoZWNrUmVzZXJ2ZWRXb3JkKHQpe3ZvaWQgMCE9PXQmJnN1cGVyLmNoZWNrUmVzZXJ2ZWRXb3JkKC4uLmFyZ3VtZW50cyl9cGFyc2VCaW5kaW5nQXRvbSgpe3JldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJQYXR0ZXJuXCIpfHxzdXBlci5wYXJzZUJpbmRpbmdBdG9tKC4uLmFyZ3VtZW50cyl9Y2hlY2tMVmFsKHQpe1wiUGxhY2Vob2xkZXJcIiE9PXQudHlwZSYmc3VwZXIuY2hlY2tMVmFsKC4uLmFyZ3VtZW50cyl9dG9Bc3NpZ25hYmxlKHQpe3JldHVybiB0JiZcIlBsYWNlaG9sZGVyXCI9PT10LnR5cGUmJlwiRXhwcmVzc2lvblwiPT09dC5leHBlY3RlZE5vZGU/KHQuZXhwZWN0ZWROb2RlPVwiUGF0dGVyblwiLHQpOnN1cGVyLnRvQXNzaWduYWJsZSguLi5hcmd1bWVudHMpfXZlcmlmeUJyZWFrQ29udGludWUodCl7dC5sYWJlbCYmXCJQbGFjZWhvbGRlclwiPT09dC5sYWJlbC50eXBlfHxzdXBlci52ZXJpZnlCcmVha0NvbnRpbnVlKC4uLmFyZ3VtZW50cyl9cGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KHQsZSl7aWYoXCJQbGFjZWhvbGRlclwiIT09ZS50eXBlfHxlLmV4dHJhJiZlLmV4dHJhLnBhcmVudGhlc2l6ZWQpcmV0dXJuIHN1cGVyLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudCguLi5hcmd1bWVudHMpO2lmKHRoaXMubWF0Y2gobi5jb2xvbikpe2NvbnN0IHM9dDtyZXR1cm4gcy5sYWJlbD10aGlzLmZpbmlzaFBsYWNlaG9sZGVyKGUsXCJJZGVudGlmaWVyXCIpLHRoaXMubmV4dCgpLHMuYm9keT10aGlzLnBhcnNlU3RhdGVtZW50KFwibGFiZWxcIiksdGhpcy5maW5pc2hOb2RlKHMsXCJMYWJlbGVkU3RhdGVtZW50XCIpfXJldHVybiB0aGlzLnNlbWljb2xvbigpLHQubmFtZT1lLm5hbWUsdGhpcy5maW5pc2hQbGFjZWhvbGRlcih0LFwiU3RhdGVtZW50XCIpfXBhcnNlQmxvY2soKXtyZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiQmxvY2tTdGF0ZW1lbnRcIil8fHN1cGVyLnBhcnNlQmxvY2soLi4uYXJndW1lbnRzKX1wYXJzZUZ1bmN0aW9uSWQoKXtyZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiSWRlbnRpZmllclwiKXx8c3VwZXIucGFyc2VGdW5jdGlvbklkKC4uLmFyZ3VtZW50cyl9cGFyc2VDbGFzcyh0LGUscyl7Y29uc3QgaT1lP1wiQ2xhc3NEZWNsYXJhdGlvblwiOlwiQ2xhc3NFeHByZXNzaW9uXCI7dGhpcy5uZXh0KCksdGhpcy50YWtlRGVjb3JhdG9ycyh0KTtjb25zdCByPXRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIik7aWYocilpZih0aGlzLm1hdGNoKG4uX2V4dGVuZHMpfHx0aGlzLm1hdGNoKG4ucGxhY2Vob2xkZXIpfHx0aGlzLm1hdGNoKG4uYnJhY2VMKSl0LmlkPXI7ZWxzZXtpZihzfHwhZSlyZXR1cm4gdC5pZD1udWxsLHQuYm9keT10aGlzLmZpbmlzaFBsYWNlaG9sZGVyKHIsXCJDbGFzc0JvZHlcIiksdGhpcy5maW5pc2hOb2RlKHQsaSk7dGhpcy51bmV4cGVjdGVkKG51bGwsXCJBIGNsYXNzIG5hbWUgaXMgcmVxdWlyZWRcIil9ZWxzZSB0aGlzLnBhcnNlQ2xhc3NJZCh0LGUscyk7cmV0dXJuIHRoaXMucGFyc2VDbGFzc1N1cGVyKHQpLHQuYm9keT10aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJDbGFzc0JvZHlcIil8fHRoaXMucGFyc2VDbGFzc0JvZHkoISF0LnN1cGVyQ2xhc3MpLHRoaXMuZmluaXNoTm9kZSh0LGkpfXBhcnNlRXhwb3J0KHQpe2NvbnN0IGU9dGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiSWRlbnRpZmllclwiKTtpZighZSlyZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQoLi4uYXJndW1lbnRzKTtpZighdGhpcy5pc0NvbnRleHR1YWwoXCJmcm9tXCIpJiYhdGhpcy5tYXRjaChuLmNvbW1hKSlyZXR1cm4gdC5zcGVjaWZpZXJzPVtdLHQuc291cmNlPW51bGwsdC5kZWNsYXJhdGlvbj10aGlzLmZpbmlzaFBsYWNlaG9sZGVyKGUsXCJEZWNsYXJhdGlvblwiKSx0aGlzLmZpbmlzaE5vZGUodCxcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIik7dGhpcy5leHBlY3RQbHVnaW4oXCJleHBvcnREZWZhdWx0RnJvbVwiKTtjb25zdCBzPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHMuZXhwb3J0ZWQ9ZSx0LnNwZWNpZmllcnM9W3RoaXMuZmluaXNoTm9kZShzLFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiKV0sc3VwZXIucGFyc2VFeHBvcnQodCl9bWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIodCl7cmV0dXJuISEodC5zcGVjaWZpZXJzJiZ0LnNwZWNpZmllcnMubGVuZ3RoPjApfHxzdXBlci5tYXliZVBhcnNlRXhwb3J0RGVmYXVsdFNwZWNpZmllciguLi5hcmd1bWVudHMpfWNoZWNrRXhwb3J0KHQpe2NvbnN0e3NwZWNpZmllcnM6ZX09dDtlJiZlLmxlbmd0aCYmKHQuc3BlY2lmaWVycz1lLmZpbHRlcih0PT5cIlBsYWNlaG9sZGVyXCI9PT10LmV4cG9ydGVkLnR5cGUpKSxzdXBlci5jaGVja0V4cG9ydCh0KSx0LnNwZWNpZmllcnM9ZX1wYXJzZUltcG9ydCh0KXtjb25zdCBlPXRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIik7aWYoIWUpcmV0dXJuIHN1cGVyLnBhcnNlSW1wb3J0KC4uLmFyZ3VtZW50cyk7aWYodC5zcGVjaWZpZXJzPVtdLCF0aGlzLmlzQ29udGV4dHVhbChcImZyb21cIikmJiF0aGlzLm1hdGNoKG4uY29tbWEpKXJldHVybiB0LnNvdXJjZT10aGlzLmZpbmlzaFBsYWNlaG9sZGVyKGUsXCJTdHJpbmdMaXRlcmFsXCIpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKHQsXCJJbXBvcnREZWNsYXJhdGlvblwiKTtjb25zdCBzPXRoaXMuc3RhcnROb2RlQXROb2RlKGUpO2lmKHMubG9jYWw9ZSx0aGlzLmZpbmlzaE5vZGUocyxcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiksdC5zcGVjaWZpZXJzLnB1c2gocyksdGhpcy5lYXQobi5jb21tYSkpe3RoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIodCl8fHRoaXMucGFyc2VOYW1lZEltcG9ydFNwZWNpZmllcnModCl9cmV0dXJuIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImZyb21cIiksdC5zb3VyY2U9dGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKHQsXCJJbXBvcnREZWNsYXJhdGlvblwiKX1wYXJzZUltcG9ydFNvdXJjZSgpe3JldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJTdHJpbmdMaXRlcmFsXCIpfHxzdXBlci5wYXJzZUltcG9ydFNvdXJjZSguLi5hcmd1bWVudHMpfX19LGN0PU9iamVjdC5rZXlzKHB0KSx1dD17c291cmNlVHlwZTpcInNjcmlwdFwiLHNvdXJjZUZpbGVuYW1lOnZvaWQgMCxzdGFydExpbmU6MSxhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiExLGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiExLGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTohMSxhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDohMSxhbGxvd1VuZGVjbGFyZWRFeHBvcnRzOiExLHBsdWdpbnM6W10sc3RyaWN0TW9kZTpudWxsLHJhbmdlczohMSx0b2tlbnM6ITEsY3JlYXRlUGFyZW50aGVzaXplZEV4cHJlc3Npb25zOiExLGVycm9yUmVjb3Zlcnk6ITF9O2NsYXNzIGx0e2NvbnN0cnVjdG9yKCl7dGhpcy5lcnJvcnM9W10sdGhpcy5wb3RlbnRpYWxBcnJvd0F0PS0xLHRoaXMubm9BcnJvd0F0PVtdLHRoaXMubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdD1bXSx0aGlzLmluUGFyYW1ldGVycz0hMSx0aGlzLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM9ITEsdGhpcy5tYXliZUluQXN5bmNBcnJvd0hlYWQ9ITEsdGhpcy5pblBpcGVsaW5lPSExLHRoaXMuaW5UeXBlPSExLHRoaXMubm9Bbm9uRnVuY3Rpb25UeXBlPSExLHRoaXMuaW5Qcm9wZXJ0eU5hbWU9ITEsdGhpcy5oYXNGbG93Q29tbWVudD0hMSx0aGlzLmlzSXRlcmF0b3I9ITEsdGhpcy50b3BpY0NvbnRleHQ9e21heE51bU9mUmVzb2x2YWJsZVRvcGljczowLG1heFRvcGljSW5kZXg6bnVsbH0sdGhpcy5zb2xvQXdhaXQ9ITEsdGhpcy5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keT0hMSx0aGlzLmxhYmVscz1bXSx0aGlzLmRlY29yYXRvclN0YWNrPVtbXV0sdGhpcy55aWVsZFBvcz0tMSx0aGlzLmF3YWl0UG9zPS0xLHRoaXMuY29tbWVudHM9W10sdGhpcy50cmFpbGluZ0NvbW1lbnRzPVtdLHRoaXMubGVhZGluZ0NvbW1lbnRzPVtdLHRoaXMuY29tbWVudFN0YWNrPVtdLHRoaXMuY29tbWVudFByZXZpb3VzTm9kZT1udWxsLHRoaXMucG9zPTAsdGhpcy5saW5lU3RhcnQ9MCx0aGlzLnR5cGU9bi5lb2YsdGhpcy52YWx1ZT1udWxsLHRoaXMuc3RhcnQ9MCx0aGlzLmVuZD0wLHRoaXMubGFzdFRva0VuZExvYz1udWxsLHRoaXMubGFzdFRva1N0YXJ0TG9jPW51bGwsdGhpcy5sYXN0VG9rU3RhcnQ9MCx0aGlzLmxhc3RUb2tFbmQ9MCx0aGlzLmNvbnRleHQ9W3guYnJhY2VTdGF0ZW1lbnRdLHRoaXMuZXhwckFsbG93ZWQ9ITAsdGhpcy5jb250YWluc0VzYz0hMSx0aGlzLm9jdGFsUG9zaXRpb25zPVtdLHRoaXMuZXhwb3J0ZWRJZGVudGlmaWVycz1bXSx0aGlzLnRva2Vuc0xlbmd0aD0wfWluaXQodCl7dGhpcy5zdHJpY3Q9ITEhPT10LnN0cmljdE1vZGUmJlwibW9kdWxlXCI9PT10LnNvdXJjZVR5cGUsdGhpcy5jdXJMaW5lPXQuc3RhcnRMaW5lLHRoaXMuc3RhcnRMb2M9dGhpcy5lbmRMb2M9dGhpcy5jdXJQb3NpdGlvbigpfWN1clBvc2l0aW9uKCl7cmV0dXJuIG5ldyBsKHRoaXMuY3VyTGluZSx0aGlzLnBvcy10aGlzLmxpbmVTdGFydCl9Y2xvbmUodCl7Y29uc3QgZT1uZXcgbHQscz1PYmplY3Qua2V5cyh0aGlzKTtmb3IobGV0IGk9MCxyPXMubGVuZ3RoO2k8cjtpKyspe2NvbnN0IHI9c1tpXTtsZXQgYT10aGlzW3JdOyF0JiZBcnJheS5pc0FycmF5KGEpJiYoYT1hLnNsaWNlKCkpLGVbcl09YX1yZXR1cm4gZX19dmFyIGR0PWZ1bmN0aW9uKHQpe3JldHVybiB0Pj00OCYmdDw9NTd9O2NvbnN0IG10PW5ldyBTZXQoW1wiZ1wiLFwibVwiLFwic1wiLFwiaVwiLFwieVwiLFwidVwiXSksZnQ9e2RlY0Jpbk9jdDpbNDYsNjYsNjksNzksOTUsOTgsMTAxLDExMV0saGV4Ols0Niw4OCw5NSwxMjBdfSxEdD17YmluOls0OCw0OV19O0R0Lm9jdD1bLi4uRHQuYmluLDUwLDUxLDUyLDUzLDU0LDU1XSxEdC5kZWM9Wy4uLkR0Lm9jdCw1Niw1N10sRHQuaGV4PVsuLi5EdC5kZWMsNjUsNjYsNjcsNjgsNjksNzAsOTcsOTgsOTksMTAwLDEwMSwxMDJdO2NsYXNzIHl0e2NvbnN0cnVjdG9yKHQpe3RoaXMudHlwZT10LnR5cGUsdGhpcy52YWx1ZT10LnZhbHVlLHRoaXMuc3RhcnQ9dC5zdGFydCx0aGlzLmVuZD10LmVuZCx0aGlzLmxvYz1uZXcgZCh0LnN0YXJ0TG9jLHQuZW5kTG9jKX19Y2xhc3MgeHR7Y29uc3RydWN0b3IoKXt0aGlzLnNob3J0aGFuZEFzc2lnbj0tMSx0aGlzLmRvdWJsZVByb3RvPS0xfX1jbGFzcyBndHtjb25zdHJ1Y3Rvcih0LGUscyl7dGhpcy50eXBlPVwiXCIsdGhpcy5zdGFydD1lLHRoaXMuZW5kPTAsdGhpcy5sb2M9bmV3IGQocyksdCYmdC5vcHRpb25zLnJhbmdlcyYmKHRoaXMucmFuZ2U9W2UsMF0pLHQmJnQuZmlsZW5hbWUmJih0aGlzLmxvYy5maWxlbmFtZT10LmZpbGVuYW1lKX1fX2Nsb25lKCl7Y29uc3QgdD1uZXcgZ3QsZT1PYmplY3Qua2V5cyh0aGlzKTtmb3IobGV0IHM9MCxpPWUubGVuZ3RoO3M8aTtzKyspe2NvbnN0IGk9ZVtzXTtcImxlYWRpbmdDb21tZW50c1wiIT09aSYmXCJ0cmFpbGluZ0NvbW1lbnRzXCIhPT1pJiZcImlubmVyQ29tbWVudHNcIiE9PWkmJih0W2ldPXRoaXNbaV0pfXJldHVybiB0fX1jb25zdCBQdD10PT5cIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI9PT10LnR5cGU/UHQodC5leHByZXNzaW9uKTp0O2NvbnN0IEV0PXtraW5kOlwibG9vcFwifSxDdD17a2luZDpcInN3aXRjaFwifTtjbGFzcyBidHtjb25zdHJ1Y3Rvcigpe3RoaXMucHJpdmF0ZU5hbWVzPW5ldyBTZXQsdGhpcy5sb25lQWNjZXNzb3JzPW5ldyBNYXAsdGhpcy51bmRlZmluZWRQcml2YXRlTmFtZXM9bmV3IE1hcH19Y2xhc3MgVHR7Y29uc3RydWN0b3IodCl7dGhpcy5zdGFjaz1bXSx0aGlzLnVuZGVmaW5lZFByaXZhdGVOYW1lcz1uZXcgTWFwLHRoaXMucmFpc2U9dH1jdXJyZW50KCl7cmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGgtMV19ZW50ZXIoKXt0aGlzLnN0YWNrLnB1c2gobmV3IGJ0KX1leGl0KCl7Y29uc3QgdD10aGlzLnN0YWNrLnBvcCgpLGU9dGhpcy5jdXJyZW50KCk7Zm9yKGxldCBzPTAsaT1BcnJheS5mcm9tKHQudW5kZWZpbmVkUHJpdmF0ZU5hbWVzKTtzPGkubGVuZ3RoO3MrKyl7Y29uc3RbdCxyXT1pW3NdO2U/ZS51bmRlZmluZWRQcml2YXRlTmFtZXMuaGFzKHQpfHxlLnVuZGVmaW5lZFByaXZhdGVOYW1lcy5zZXQodCxyKTp0aGlzLnJhaXNlKHIsZi5JbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbix0KX19ZGVjbGFyZVByaXZhdGVOYW1lKHQsZSxzKXtjb25zdCBpPXRoaXMuY3VycmVudCgpO2xldCByPWkucHJpdmF0ZU5hbWVzLmhhcyh0KTtpZigzJmUpe2NvbnN0IHM9ciYmaS5sb25lQWNjZXNzb3JzLmdldCh0KTtpZihzKXtjb25zdCBhPTQmcyxuPTQmZTtyPSgzJnMpPT09KDMmZSl8fGEhPT1uLHJ8fGkubG9uZUFjY2Vzc29ycy5kZWxldGUodCl9ZWxzZSByfHxpLmxvbmVBY2Nlc3NvcnMuc2V0KHQsZSl9ciYmdGhpcy5yYWlzZShzLGYuUHJpdmF0ZU5hbWVSZWRlY2xhcmF0aW9uLHQpLGkucHJpdmF0ZU5hbWVzLmFkZCh0KSxpLnVuZGVmaW5lZFByaXZhdGVOYW1lcy5kZWxldGUodCl9dXNlUHJpdmF0ZU5hbWUodCxlKXtsZXQgcztmb3IobGV0IGU9MCxpPXRoaXMuc3RhY2s7ZTxpLmxlbmd0aDtlKyspaWYocz1pW2VdLHMucHJpdmF0ZU5hbWVzLmhhcyh0KSlyZXR1cm47cz9zLnVuZGVmaW5lZFByaXZhdGVOYW1lcy5zZXQodCxlKTp0aGlzLnJhaXNlKGUsZi5JbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbix0KX19Y2xhc3MgQXQgZXh0ZW5kcyBjbGFzcyBleHRlbmRzIGNsYXNzIGV4dGVuZHMgY2xhc3MgZXh0ZW5kcyBjbGFzcyBleHRlbmRzIGNsYXNzIGV4dGVuZHMgY2xhc3MgZXh0ZW5kcyBjbGFzcyBleHRlbmRzIGNsYXNzIGV4dGVuZHMgY2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnNhd1VuYW1iaWd1b3VzRVNNPSExLHRoaXMuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0PSExfWhhc1BsdWdpbih0KXtyZXR1cm4gdGhpcy5wbHVnaW5zLmhhcyh0KX1nZXRQbHVnaW5PcHRpb24odCxlKXtpZih0aGlzLmhhc1BsdWdpbih0KSlyZXR1cm4gdGhpcy5wbHVnaW5zLmdldCh0KVtlXX19e2FkZENvbW1lbnQodCl7dGhpcy5maWxlbmFtZSYmKHQubG9jLmZpbGVuYW1lPXRoaXMuZmlsZW5hbWUpLHRoaXMuc3RhdGUudHJhaWxpbmdDb21tZW50cy5wdXNoKHQpLHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLnB1c2godCl9YWRqdXN0Q29tbWVudHNBZnRlclRyYWlsaW5nQ29tbWEodCxlLHMpe2lmKDA9PT10aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5sZW5ndGgpcmV0dXJuO2xldCBpPW51bGwscj1lLmxlbmd0aDtmb3IoO251bGw9PT1pJiZyPjA7KWk9ZVstLXJdO2lmKG51bGw9PT1pKXJldHVybjtmb3IobGV0IHQ9MDt0PHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLmxlbmd0aDt0KyspdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHNbdF0uZW5kPHRoaXMuc3RhdGUuY29tbWVudFByZXZpb3VzTm9kZS5lbmQmJih0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5zcGxpY2UodCwxKSx0LS0pO2NvbnN0IGE9W107Zm9yKGxldCBlPTA7ZTx0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5sZW5ndGg7ZSsrKXtjb25zdCBpPXRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzW2VdO2kuZW5kPHQuZW5kPyhhLnB1c2goaSksc3x8KHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLnNwbGljZShlLDEpLGUtLSkpOih2b2lkIDA9PT10LnRyYWlsaW5nQ29tbWVudHMmJih0LnRyYWlsaW5nQ29tbWVudHM9W10pLHQudHJhaWxpbmdDb21tZW50cy5wdXNoKGkpKX1zJiYodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHM9W10pLGEubGVuZ3RoPjA/aS50cmFpbGluZ0NvbW1lbnRzPWE6dm9pZCAwIT09aS50cmFpbGluZ0NvbW1lbnRzJiYoaS50cmFpbGluZ0NvbW1lbnRzPVtdKX1wcm9jZXNzQ29tbWVudCh0KXtpZihcIlByb2dyYW1cIj09PXQudHlwZSYmdC5ib2R5Lmxlbmd0aD4wKXJldHVybjtjb25zdCBlPXRoaXMuc3RhdGUuY29tbWVudFN0YWNrO2xldCBzLGkscixhLG47aWYodGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aD4wKXRoaXMuc3RhdGUudHJhaWxpbmdDb21tZW50c1swXS5zdGFydD49dC5lbmQ/KHI9dGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzLHRoaXMuc3RhdGUudHJhaWxpbmdDb21tZW50cz1bXSk6dGhpcy5zdGF0ZS50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aD0wO2Vsc2UgaWYoZS5sZW5ndGg+MCl7Y29uc3Qgcz1tKGUpO3MudHJhaWxpbmdDb21tZW50cyYmcy50cmFpbGluZ0NvbW1lbnRzWzBdLnN0YXJ0Pj10LmVuZCYmKHI9cy50cmFpbGluZ0NvbW1lbnRzLGRlbGV0ZSBzLnRyYWlsaW5nQ29tbWVudHMpfWZvcihlLmxlbmd0aD4wJiZtKGUpLnN0YXJ0Pj10LnN0YXJ0JiYocz1lLnBvcCgpKTtlLmxlbmd0aD4wJiZtKGUpLnN0YXJ0Pj10LnN0YXJ0OylpPWUucG9wKCk7aWYoIWkmJnMmJihpPXMpLHMpc3dpdGNoKHQudHlwZSl7Y2FzZVwiT2JqZWN0RXhwcmVzc2lvblwiOnRoaXMuYWRqdXN0Q29tbWVudHNBZnRlclRyYWlsaW5nQ29tbWEodCx0LnByb3BlcnRpZXMpO2JyZWFrO2Nhc2VcIk9iamVjdFBhdHRlcm5cIjp0aGlzLmFkanVzdENvbW1lbnRzQWZ0ZXJUcmFpbGluZ0NvbW1hKHQsdC5wcm9wZXJ0aWVzLCEwKTticmVhaztjYXNlXCJDYWxsRXhwcmVzc2lvblwiOnRoaXMuYWRqdXN0Q29tbWVudHNBZnRlclRyYWlsaW5nQ29tbWEodCx0LmFyZ3VtZW50cyk7YnJlYWs7Y2FzZVwiQXJyYXlFeHByZXNzaW9uXCI6dGhpcy5hZGp1c3RDb21tZW50c0FmdGVyVHJhaWxpbmdDb21tYSh0LHQuZWxlbWVudHMpO2JyZWFrO2Nhc2VcIkFycmF5UGF0dGVyblwiOnRoaXMuYWRqdXN0Q29tbWVudHNBZnRlclRyYWlsaW5nQ29tbWEodCx0LmVsZW1lbnRzLCEwKX1lbHNlIHRoaXMuc3RhdGUuY29tbWVudFByZXZpb3VzTm9kZSYmKFwiSW1wb3J0U3BlY2lmaWVyXCI9PT10aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGUudHlwZSYmXCJJbXBvcnRTcGVjaWZpZXJcIiE9PXQudHlwZXx8XCJFeHBvcnRTcGVjaWZpZXJcIj09PXRoaXMuc3RhdGUuY29tbWVudFByZXZpb3VzTm9kZS50eXBlJiZcIkV4cG9ydFNwZWNpZmllclwiIT09dC50eXBlKSYmdGhpcy5hZGp1c3RDb21tZW50c0FmdGVyVHJhaWxpbmdDb21tYSh0LFt0aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGVdKTtpZihpKXtpZihpLmxlYWRpbmdDb21tZW50cylpZihpIT09dCYmaS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoPjAmJm0oaS5sZWFkaW5nQ29tbWVudHMpLmVuZDw9dC5zdGFydCl0LmxlYWRpbmdDb21tZW50cz1pLmxlYWRpbmdDb21tZW50cyxkZWxldGUgaS5sZWFkaW5nQ29tbWVudHM7ZWxzZSBmb3IoYT1pLmxlYWRpbmdDb21tZW50cy5sZW5ndGgtMjthPj0wOy0tYSlpZihpLmxlYWRpbmdDb21tZW50c1thXS5lbmQ8PXQuc3RhcnQpe3QubGVhZGluZ0NvbW1lbnRzPWkubGVhZGluZ0NvbW1lbnRzLnNwbGljZSgwLGErMSk7YnJlYWt9fWVsc2UgaWYodGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoPjApaWYobSh0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cykuZW5kPD10LnN0YXJ0KXtpZih0aGlzLnN0YXRlLmNvbW1lbnRQcmV2aW91c05vZGUpZm9yKG49MDtuPHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLmxlbmd0aDtuKyspdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHNbbl0uZW5kPHRoaXMuc3RhdGUuY29tbWVudFByZXZpb3VzTm9kZS5lbmQmJih0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50cy5zcGxpY2UobiwxKSxuLS0pO3RoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLmxlbmd0aD4wJiYodC5sZWFkaW5nQ29tbWVudHM9dGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHMsdGhpcy5zdGF0ZS5sZWFkaW5nQ29tbWVudHM9W10pfWVsc2V7Zm9yKGE9MDthPHRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLmxlbmd0aCYmISh0aGlzLnN0YXRlLmxlYWRpbmdDb21tZW50c1thXS5lbmQ+dC5zdGFydCk7YSsrKTtjb25zdCBlPXRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLnNsaWNlKDAsYSk7ZS5sZW5ndGgmJih0LmxlYWRpbmdDb21tZW50cz1lKSxyPXRoaXMuc3RhdGUubGVhZGluZ0NvbW1lbnRzLnNsaWNlKGEpLDA9PT1yLmxlbmd0aCYmKHI9bnVsbCl9dGhpcy5zdGF0ZS5jb21tZW50UHJldmlvdXNOb2RlPXQsciYmKHIubGVuZ3RoJiZyWzBdLnN0YXJ0Pj10LnN0YXJ0JiZtKHIpLmVuZDw9dC5lbmQ/dC5pbm5lckNvbW1lbnRzPXI6dC50cmFpbGluZ0NvbW1lbnRzPXIpLGUucHVzaCh0KX19e2dldExvY2F0aW9uRm9yUG9zaXRpb24odCl7bGV0IGU7cmV0dXJuIGU9dD09PXRoaXMuc3RhdGUuc3RhcnQ/dGhpcy5zdGF0ZS5zdGFydExvYzp0PT09dGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQ/dGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2M6dD09PXRoaXMuc3RhdGUuZW5kP3RoaXMuc3RhdGUuZW5kTG9jOnQ9PT10aGlzLnN0YXRlLmxhc3RUb2tFbmQ/dGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jOmZ1bmN0aW9uKHQsZSl7bGV0IHMsaT0xLHI9MDtmb3IoaC5sYXN0SW5kZXg9MDsocz1oLmV4ZWModCkpJiZzLmluZGV4PGU7KWkrKyxyPWgubGFzdEluZGV4O3JldHVybiBuZXcgbChpLGUtcil9KHRoaXMuaW5wdXQsdCksZX1yYWlzZSh0LGUsLi4ucyl7cmV0dXJuIHRoaXMucmFpc2VXaXRoRGF0YSh0LHZvaWQgMCxlLC4uLnMpfXJhaXNlV2l0aERhdGEodCxlLHMsLi4uaSl7Y29uc3Qgcj10aGlzLmdldExvY2F0aW9uRm9yUG9zaXRpb24odCksYT1zLnJlcGxhY2UoLyUoXFxkKykvZywodCxlKT0+aVtlXSkrXCIgKFwiLmNvbmNhdChyLmxpbmUsXCI6XCIpLmNvbmNhdChyLmNvbHVtbixcIilcIik7cmV0dXJuIHRoaXMuX3JhaXNlKE9iamVjdC5hc3NpZ24oe2xvYzpyLHBvczp0fSxlKSxhKX1fcmFpc2UodCxlKXtjb25zdCBzPW5ldyBTeW50YXhFcnJvcihlKTtpZihPYmplY3QuYXNzaWduKHMsdCksdGhpcy5vcHRpb25zLmVycm9yUmVjb3ZlcnkpcmV0dXJuIHRoaXMuaXNMb29rYWhlYWR8fHRoaXMuc3RhdGUuZXJyb3JzLnB1c2gocyksczt0aHJvdyBzfX17Y29uc3RydWN0b3IodCxlKXtzdXBlcigpLHRoaXMudG9rZW5zPVtdLHRoaXMuc3RhdGU9bmV3IGx0LHRoaXMuc3RhdGUuaW5pdCh0KSx0aGlzLmlucHV0PWUsdGhpcy5sZW5ndGg9ZS5sZW5ndGgsdGhpcy5pc0xvb2thaGVhZD0hMX1wdXNoVG9rZW4odCl7dGhpcy50b2tlbnMubGVuZ3RoPXRoaXMuc3RhdGUudG9rZW5zTGVuZ3RoLHRoaXMudG9rZW5zLnB1c2godCksKyt0aGlzLnN0YXRlLnRva2Vuc0xlbmd0aH1uZXh0KCl7dGhpcy5pc0xvb2thaGVhZHx8KHRoaXMuY2hlY2tLZXl3b3JkRXNjYXBlcygpLHRoaXMub3B0aW9ucy50b2tlbnMmJnRoaXMucHVzaFRva2VuKG5ldyB5dCh0aGlzLnN0YXRlKSkpLHRoaXMuc3RhdGUubGFzdFRva0VuZD10aGlzLnN0YXRlLmVuZCx0aGlzLnN0YXRlLmxhc3RUb2tTdGFydD10aGlzLnN0YXRlLnN0YXJ0LHRoaXMuc3RhdGUubGFzdFRva0VuZExvYz10aGlzLnN0YXRlLmVuZExvYyx0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYz10aGlzLnN0YXRlLnN0YXJ0TG9jLHRoaXMubmV4dFRva2VuKCl9ZWF0KHQpe3JldHVybiEhdGhpcy5tYXRjaCh0KSYmKHRoaXMubmV4dCgpLCEwKX1tYXRjaCh0KXtyZXR1cm4gdGhpcy5zdGF0ZS50eXBlPT09dH1sb29rYWhlYWQoKXtjb25zdCB0PXRoaXMuc3RhdGU7dGhpcy5zdGF0ZT10LmNsb25lKCEwKSx0aGlzLmlzTG9va2FoZWFkPSEwLHRoaXMubmV4dCgpLHRoaXMuaXNMb29rYWhlYWQ9ITE7Y29uc3QgZT10aGlzLnN0YXRlO3JldHVybiB0aGlzLnN0YXRlPXQsZX1uZXh0VG9rZW5TdGFydCgpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5wb3M7cmV0dXJuIGMubGFzdEluZGV4PXQsdCtjLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RofWxvb2thaGVhZENoYXJDb2RlKCl7cmV0dXJuIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlblN0YXJ0KCkpfXNldFN0cmljdCh0KXtpZih0aGlzLnN0YXRlLnN0cmljdD10LHRoaXMubWF0Y2gobi5udW0pfHx0aGlzLm1hdGNoKG4uc3RyaW5nKSl7Zm9yKHRoaXMuc3RhdGUucG9zPXRoaXMuc3RhdGUuc3RhcnQ7dGhpcy5zdGF0ZS5wb3M8dGhpcy5zdGF0ZS5saW5lU3RhcnQ7KXRoaXMuc3RhdGUubGluZVN0YXJ0PXRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIix0aGlzLnN0YXRlLmxpbmVTdGFydC0yKSsxLC0tdGhpcy5zdGF0ZS5jdXJMaW5lO3RoaXMubmV4dFRva2VuKCl9fWN1ckNvbnRleHQoKXtyZXR1cm4gdGhpcy5zdGF0ZS5jb250ZXh0W3RoaXMuc3RhdGUuY29udGV4dC5sZW5ndGgtMV19bmV4dFRva2VuKCl7Y29uc3QgdD10aGlzLmN1ckNvbnRleHQoKTtpZih0JiZ0LnByZXNlcnZlU3BhY2V8fHRoaXMuc2tpcFNwYWNlKCksdGhpcy5zdGF0ZS5vY3RhbFBvc2l0aW9ucz1bXSx0aGlzLnN0YXRlLnN0YXJ0PXRoaXMuc3RhdGUucG9zLHRoaXMuc3RhdGUuc3RhcnRMb2M9dGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpLHRoaXMuc3RhdGUucG9zPj10aGlzLmxlbmd0aClyZXR1cm4gdm9pZCB0aGlzLmZpbmlzaFRva2VuKG4uZW9mKTtjb25zdCBlPW51bGw9PXQ/dm9pZCAwOnQub3ZlcnJpZGU7ZT9lKHRoaXMpOnRoaXMuZ2V0VG9rZW5Gcm9tQ29kZSh0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuc3RhdGUucG9zKSl9cHVzaENvbW1lbnQodCxlLHMsaSxyLGEpe2NvbnN0IG49e3R5cGU6dD9cIkNvbW1lbnRCbG9ja1wiOlwiQ29tbWVudExpbmVcIix2YWx1ZTplLHN0YXJ0OnMsZW5kOmksbG9jOm5ldyBkKHIsYSl9O3RoaXMub3B0aW9ucy50b2tlbnMmJnRoaXMucHVzaFRva2VuKG4pLHRoaXMuc3RhdGUuY29tbWVudHMucHVzaChuKSx0aGlzLmFkZENvbW1lbnQobil9c2tpcEJsb2NrQ29tbWVudCgpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpLGU9dGhpcy5zdGF0ZS5wb3Mscz10aGlzLmlucHV0LmluZGV4T2YoXCIqL1wiLHRoaXMuc3RhdGUucG9zKzIpO2lmKC0xPT09cyl0aHJvdyB0aGlzLnJhaXNlKGUsZi5VbnRlcm1pbmF0ZWRDb21tZW50KTtsZXQgaTtmb3IodGhpcy5zdGF0ZS5wb3M9cysyLGgubGFzdEluZGV4PWU7KGk9aC5leGVjKHRoaXMuaW5wdXQpKSYmaS5pbmRleDx0aGlzLnN0YXRlLnBvczspKyt0aGlzLnN0YXRlLmN1ckxpbmUsdGhpcy5zdGF0ZS5saW5lU3RhcnQ9aS5pbmRleCtpWzBdLmxlbmd0aDt0aGlzLmlzTG9va2FoZWFkfHx0aGlzLnB1c2hDb21tZW50KCEwLHRoaXMuaW5wdXQuc2xpY2UoZSsyLHMpLGUsdGhpcy5zdGF0ZS5wb3MsdCx0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpfXNraXBMaW5lQ29tbWVudCh0KXtjb25zdCBlPXRoaXMuc3RhdGUucG9zLHM9dGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO2xldCBpPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcys9dCk7aWYodGhpcy5zdGF0ZS5wb3M8dGhpcy5sZW5ndGgpZm9yKDshcChpKSYmKyt0aGlzLnN0YXRlLnBvczx0aGlzLmxlbmd0aDspaT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO3RoaXMuaXNMb29rYWhlYWR8fHRoaXMucHVzaENvbW1lbnQoITEsdGhpcy5pbnB1dC5zbGljZShlK3QsdGhpcy5zdGF0ZS5wb3MpLGUsdGhpcy5zdGF0ZS5wb3Mscyx0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpfXNraXBTcGFjZSgpe3Q6Zm9yKDt0aGlzLnN0YXRlLnBvczx0aGlzLmxlbmd0aDspe2NvbnN0IHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtzd2l0Y2godCl7Y2FzZSAzMjpjYXNlIDE2MDpjYXNlIDk6Kyt0aGlzLnN0YXRlLnBvczticmVhaztjYXNlIDEzOjEwPT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpJiYrK3RoaXMuc3RhdGUucG9zO2Nhc2UgMTA6Y2FzZSA4MjMyOmNhc2UgODIzMzorK3RoaXMuc3RhdGUucG9zLCsrdGhpcy5zdGF0ZS5jdXJMaW5lLHRoaXMuc3RhdGUubGluZVN0YXJ0PXRoaXMuc3RhdGUucG9zO2JyZWFrO2Nhc2UgNDc6c3dpdGNoKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcysxKSl7Y2FzZSA0Mjp0aGlzLnNraXBCbG9ja0NvbW1lbnQoKTticmVhaztjYXNlIDQ3OnRoaXMuc2tpcExpbmVDb21tZW50KDIpO2JyZWFrO2RlZmF1bHQ6YnJlYWsgdH1icmVhaztkZWZhdWx0OmlmKCF1KHQpKWJyZWFrIHQ7Kyt0aGlzLnN0YXRlLnBvc319fWZpbmlzaFRva2VuKHQsZSl7dGhpcy5zdGF0ZS5lbmQ9dGhpcy5zdGF0ZS5wb3MsdGhpcy5zdGF0ZS5lbmRMb2M9dGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO2NvbnN0IHM9dGhpcy5zdGF0ZS50eXBlO3RoaXMuc3RhdGUudHlwZT10LHRoaXMuc3RhdGUudmFsdWU9ZSx0aGlzLmlzTG9va2FoZWFkfHx0aGlzLnVwZGF0ZUNvbnRleHQocyl9cmVhZFRva2VuX251bWJlclNpZ24oKXtpZigwPT09dGhpcy5zdGF0ZS5wb3MmJnRoaXMucmVhZFRva2VuX2ludGVycHJldGVyKCkpcmV0dXJuO2NvbnN0IHQ9dGhpcy5zdGF0ZS5wb3MrMSxlPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0KTtpZihlPj00OCYmZTw9NTcpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcyxmLlVuZXhwZWN0ZWREaWdpdEFmdGVySGFzaCk7aWYoIXRoaXMuaGFzUGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIil8fDEyMyE9PWUmJjkxIT09ZSl7aWYoIXRoaXMuaGFzUGx1Z2luKFwiY2xhc3NQcml2YXRlUHJvcGVydGllc1wiKSYmIXRoaXMuaGFzUGx1Z2luKFwiY2xhc3NQcml2YXRlTWV0aG9kc1wiKSYmXCJzbWFydFwiIT09dGhpcy5nZXRQbHVnaW5PcHRpb24oXCJwaXBlbGluZU9wZXJhdG9yXCIsXCJwcm9wb3NhbFwiKSl0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLGYuSW52YWxpZE9yVW5leHBlY3RlZFRva2VuLFwiI1wiKTt0aGlzLmZpbmlzaE9wKG4uaGFzaCwxKX1lbHNle2lmKFwiaGFzaFwiIT09dGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLFwic3ludGF4VHlwZVwiKSl0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLDEyMz09PWU/Zi5SZWNvcmRFeHByZXNzaW9uSGFzaEluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTpmLlR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUpOzEyMz09PWU/dGhpcy5maW5pc2hUb2tlbihuLmJyYWNlSGFzaEwpOnRoaXMuZmluaXNoVG9rZW4obi5icmFja2V0SGFzaEwpLHRoaXMuc3RhdGUucG9zKz0yfX1yZWFkVG9rZW5fZG90KCl7Y29uc3QgdD10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMSk7dD49NDgmJnQ8PTU3P3RoaXMucmVhZE51bWJlcighMCk6NDY9PT10JiY0Nj09PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcysyKT8odGhpcy5zdGF0ZS5wb3MrPTMsdGhpcy5maW5pc2hUb2tlbihuLmVsbGlwc2lzKSk6KCsrdGhpcy5zdGF0ZS5wb3MsdGhpcy5maW5pc2hUb2tlbihuLmRvdCkpfXJlYWRUb2tlbl9zbGFzaCgpe2lmKHRoaXMuc3RhdGUuZXhwckFsbG93ZWQmJiF0aGlzLnN0YXRlLmluVHlwZSlyZXR1cm4rK3RoaXMuc3RhdGUucG9zLHZvaWQgdGhpcy5yZWFkUmVnZXhwKCk7NjE9PT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMSk/dGhpcy5maW5pc2hPcChuLmFzc2lnbiwyKTp0aGlzLmZpbmlzaE9wKG4uc2xhc2gsMSl9cmVhZFRva2VuX2ludGVycHJldGVyKCl7aWYoMCE9PXRoaXMuc3RhdGUucG9zfHx0aGlzLmxlbmd0aDwyKXJldHVybiExO2xldCB0PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcysxKTtpZigzMyE9PXQpcmV0dXJuITE7Y29uc3QgZT10aGlzLnN0YXRlLnBvcztmb3IodGhpcy5zdGF0ZS5wb3MrPTE7IXAodCkmJisrdGhpcy5zdGF0ZS5wb3M8dGhpcy5sZW5ndGg7KXQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtjb25zdCBzPXRoaXMuaW5wdXQuc2xpY2UoZSsyLHRoaXMuc3RhdGUucG9zKTtyZXR1cm4gdGhpcy5maW5pc2hUb2tlbihuLmludGVycHJldGVyRGlyZWN0aXZlLHMpLCEwfXJlYWRUb2tlbl9tdWx0X21vZHVsbyh0KXtsZXQgZT00Mj09PXQ/bi5zdGFyOm4ubW9kdWxvLHM9MSxpPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcysxKTtjb25zdCByPXRoaXMuc3RhdGUuZXhwckFsbG93ZWQ7NDI9PT10JiY0Mj09PWkmJihzKyssaT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMiksZT1uLmV4cG9uZW50KSw2MSE9PWl8fHJ8fChzKyssZT1uLmFzc2lnbiksdGhpcy5maW5pc2hPcChlLHMpfXJlYWRUb2tlbl9waXBlX2FtcCh0KXtjb25zdCBlPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcysxKTtpZihlIT09dCl7aWYoMTI0PT09dCl7aWYoNjI9PT1lKXJldHVybiB2b2lkIHRoaXMuZmluaXNoT3Aobi5waXBlbGluZSwyKTtpZih0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpJiYxMjU9PT1lKXtpZihcImJhclwiIT09dGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLFwic3ludGF4VHlwZVwiKSl0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLGYuUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGUpO3JldHVybiB2b2lkIHRoaXMuZmluaXNoT3Aobi5icmFjZUJhclIsMil9aWYodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSYmOTM9PT1lKXtpZihcImJhclwiIT09dGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLFwic3ludGF4VHlwZVwiKSl0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLGYuVHVwbGVFeHByZXNzaW9uQmFySW5jb3JyZWN0RW5kU3ludGF4VHlwZSk7cmV0dXJuIHZvaWQgdGhpcy5maW5pc2hPcChuLmJyYWNrZXRCYXJSLDIpfX02MSE9PWU/dGhpcy5maW5pc2hPcCgxMjQ9PT10P24uYml0d2lzZU9SOm4uYml0d2lzZUFORCwxKTp0aGlzLmZpbmlzaE9wKG4uYXNzaWduLDIpfWVsc2UgNjE9PT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMik/dGhpcy5maW5pc2hPcChuLmFzc2lnbiwzKTp0aGlzLmZpbmlzaE9wKDEyND09PXQ/bi5sb2dpY2FsT1I6bi5sb2dpY2FsQU5ELDIpfXJlYWRUb2tlbl9jYXJldCgpezYxPT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpP3RoaXMuZmluaXNoT3Aobi5hc3NpZ24sMik6dGhpcy5maW5pc2hPcChuLmJpdHdpc2VYT1IsMSl9cmVhZFRva2VuX3BsdXNfbWluKHQpe2NvbnN0IGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpO2lmKGU9PT10KXJldHVybiA0NSE9PWV8fHRoaXMuaW5Nb2R1bGV8fDYyIT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzIpfHwwIT09dGhpcy5zdGF0ZS5sYXN0VG9rRW5kJiYhby50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLHRoaXMuc3RhdGUucG9zKSk/dm9pZCB0aGlzLmZpbmlzaE9wKG4uaW5jRGVjLDIpOih0aGlzLnNraXBMaW5lQ29tbWVudCgzKSx0aGlzLnNraXBTcGFjZSgpLHZvaWQgdGhpcy5uZXh0VG9rZW4oKSk7NjE9PT1lP3RoaXMuZmluaXNoT3Aobi5hc3NpZ24sMik6dGhpcy5maW5pc2hPcChuLnBsdXNNaW4sMSl9cmVhZFRva2VuX2x0X2d0KHQpe2NvbnN0IGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpO2xldCBzPTE7cmV0dXJuIGU9PT10PyhzPTYyPT09dCYmNjI9PT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMik/MzoyLDYxPT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zK3MpP3ZvaWQgdGhpcy5maW5pc2hPcChuLmFzc2lnbixzKzEpOnZvaWQgdGhpcy5maW5pc2hPcChuLmJpdFNoaWZ0LHMpKTozMyE9PWV8fDYwIT09dHx8dGhpcy5pbk1vZHVsZXx8NDUhPT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMil8fDQ1IT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzMpPyg2MT09PWUmJihzPTIpLHZvaWQgdGhpcy5maW5pc2hPcChuLnJlbGF0aW9uYWwscykpOih0aGlzLnNraXBMaW5lQ29tbWVudCg0KSx0aGlzLnNraXBTcGFjZSgpLHZvaWQgdGhpcy5uZXh0VG9rZW4oKSl9cmVhZFRva2VuX2VxX2V4Y2wodCl7Y29uc3QgZT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MrMSk7aWYoNjEhPT1lKXJldHVybiA2MT09PXQmJjYyPT09ZT8odGhpcy5zdGF0ZS5wb3MrPTIsdm9pZCB0aGlzLmZpbmlzaFRva2VuKG4uYXJyb3cpKTp2b2lkIHRoaXMuZmluaXNoT3AoNjE9PT10P24uZXE6bi5iYW5nLDEpO3RoaXMuZmluaXNoT3Aobi5lcXVhbGl0eSw2MT09PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcysyKT8zOjIpfXJlYWRUb2tlbl9xdWVzdGlvbigpe2NvbnN0IHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpLGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzIpOzYzIT09dHx8dGhpcy5zdGF0ZS5pblR5cGU/NDYhPT10fHxlPj00OCYmZTw9NTc/KCsrdGhpcy5zdGF0ZS5wb3MsdGhpcy5maW5pc2hUb2tlbihuLnF1ZXN0aW9uKSk6KHRoaXMuc3RhdGUucG9zKz0yLHRoaXMuZmluaXNoVG9rZW4obi5xdWVzdGlvbkRvdCkpOjYxPT09ZT90aGlzLmZpbmlzaE9wKG4uYXNzaWduLDMpOnRoaXMuZmluaXNoT3Aobi5udWxsaXNoQ29hbGVzY2luZywyKX1nZXRUb2tlbkZyb21Db2RlKHQpe3N3aXRjaCh0KXtjYXNlIDQ2OnJldHVybiB2b2lkIHRoaXMucmVhZFRva2VuX2RvdCgpO2Nhc2UgNDA6cmV0dXJuKyt0aGlzLnN0YXRlLnBvcyx2b2lkIHRoaXMuZmluaXNoVG9rZW4obi5wYXJlbkwpO2Nhc2UgNDE6cmV0dXJuKyt0aGlzLnN0YXRlLnBvcyx2b2lkIHRoaXMuZmluaXNoVG9rZW4obi5wYXJlblIpO2Nhc2UgNTk6cmV0dXJuKyt0aGlzLnN0YXRlLnBvcyx2b2lkIHRoaXMuZmluaXNoVG9rZW4obi5zZW1pKTtjYXNlIDQ0OnJldHVybisrdGhpcy5zdGF0ZS5wb3Msdm9pZCB0aGlzLmZpbmlzaFRva2VuKG4uY29tbWEpO2Nhc2UgOTE6aWYodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSYmMTI0PT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpKXtpZihcImJhclwiIT09dGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLFwic3ludGF4VHlwZVwiKSl0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLGYuVHVwbGVFeHByZXNzaW9uQmFySW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlKTt0aGlzLmZpbmlzaFRva2VuKG4uYnJhY2tldEJhckwpLHRoaXMuc3RhdGUucG9zKz0yfWVsc2UrK3RoaXMuc3RhdGUucG9zLHRoaXMuZmluaXNoVG9rZW4obi5icmFja2V0TCk7cmV0dXJuO2Nhc2UgOTM6cmV0dXJuKyt0aGlzLnN0YXRlLnBvcyx2b2lkIHRoaXMuZmluaXNoVG9rZW4obi5icmFja2V0Uik7Y2FzZSAxMjM6aWYodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSYmMTI0PT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpKXtpZihcImJhclwiIT09dGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLFwic3ludGF4VHlwZVwiKSl0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLGYuUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdFN0YXJ0U3ludGF4VHlwZSk7dGhpcy5maW5pc2hUb2tlbihuLmJyYWNlQmFyTCksdGhpcy5zdGF0ZS5wb3MrPTJ9ZWxzZSsrdGhpcy5zdGF0ZS5wb3MsdGhpcy5maW5pc2hUb2tlbihuLmJyYWNlTCk7cmV0dXJuO2Nhc2UgMTI1OnJldHVybisrdGhpcy5zdGF0ZS5wb3Msdm9pZCB0aGlzLmZpbmlzaFRva2VuKG4uYnJhY2VSKTtjYXNlIDU4OnJldHVybiB2b2lkKHRoaXMuaGFzUGx1Z2luKFwiZnVuY3Rpb25CaW5kXCIpJiY1OD09PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcysxKT90aGlzLmZpbmlzaE9wKG4uZG91YmxlQ29sb24sMik6KCsrdGhpcy5zdGF0ZS5wb3MsdGhpcy5maW5pc2hUb2tlbihuLmNvbG9uKSkpO2Nhc2UgNjM6cmV0dXJuIHZvaWQgdGhpcy5yZWFkVG9rZW5fcXVlc3Rpb24oKTtjYXNlIDk2OnJldHVybisrdGhpcy5zdGF0ZS5wb3Msdm9pZCB0aGlzLmZpbmlzaFRva2VuKG4uYmFja1F1b3RlKTtjYXNlIDQ4Ontjb25zdCB0PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcysxKTtpZigxMjA9PT10fHw4OD09PXQpcmV0dXJuIHZvaWQgdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpO2lmKDExMT09PXR8fDc5PT09dClyZXR1cm4gdm9pZCB0aGlzLnJlYWRSYWRpeE51bWJlcig4KTtpZig5OD09PXR8fDY2PT09dClyZXR1cm4gdm9pZCB0aGlzLnJlYWRSYWRpeE51bWJlcigyKX1jYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmNhc2UgNTY6Y2FzZSA1NzpyZXR1cm4gdm9pZCB0aGlzLnJlYWROdW1iZXIoITEpO2Nhc2UgMzQ6Y2FzZSAzOTpyZXR1cm4gdm9pZCB0aGlzLnJlYWRTdHJpbmcodCk7Y2FzZSA0NzpyZXR1cm4gdm9pZCB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpO2Nhc2UgMzc6Y2FzZSA0MjpyZXR1cm4gdm9pZCB0aGlzLnJlYWRUb2tlbl9tdWx0X21vZHVsbyh0KTtjYXNlIDEyNDpjYXNlIDM4OnJldHVybiB2b2lkIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKHQpO2Nhc2UgOTQ6cmV0dXJuIHZvaWQgdGhpcy5yZWFkVG9rZW5fY2FyZXQoKTtjYXNlIDQzOmNhc2UgNDU6cmV0dXJuIHZvaWQgdGhpcy5yZWFkVG9rZW5fcGx1c19taW4odCk7Y2FzZSA2MDpjYXNlIDYyOnJldHVybiB2b2lkIHRoaXMucmVhZFRva2VuX2x0X2d0KHQpO2Nhc2UgNjE6Y2FzZSAzMzpyZXR1cm4gdm9pZCB0aGlzLnJlYWRUb2tlbl9lcV9leGNsKHQpO2Nhc2UgMTI2OnJldHVybiB2b2lkIHRoaXMuZmluaXNoT3Aobi50aWxkZSwxKTtjYXNlIDY0OnJldHVybisrdGhpcy5zdGF0ZS5wb3Msdm9pZCB0aGlzLmZpbmlzaFRva2VuKG4uYXQpO2Nhc2UgMzU6cmV0dXJuIHZvaWQgdGhpcy5yZWFkVG9rZW5fbnVtYmVyU2lnbigpO2Nhc2UgOTI6cmV0dXJuIHZvaWQgdGhpcy5yZWFkV29yZCgpO2RlZmF1bHQ6aWYodyh0KSlyZXR1cm4gdm9pZCB0aGlzLnJlYWRXb3JkKCl9dGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcyxmLkludmFsaWRPclVuZXhwZWN0ZWRUb2tlbixTdHJpbmcuZnJvbUNvZGVQb2ludCh0KSl9ZmluaXNoT3AodCxlKXtjb25zdCBzPXRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5wb3MsdGhpcy5zdGF0ZS5wb3MrZSk7dGhpcy5zdGF0ZS5wb3MrPWUsdGhpcy5maW5pc2hUb2tlbih0LHMpfXJlYWRSZWdleHAoKXtjb25zdCB0PXRoaXMuc3RhdGUucG9zO2xldCBlLHM7Zm9yKDs7KXtpZih0aGlzLnN0YXRlLnBvcz49dGhpcy5sZW5ndGgpdGhyb3cgdGhpcy5yYWlzZSh0LGYuVW50ZXJtaW5hdGVkUmVnRXhwKTtjb25zdCBpPXRoaXMuaW5wdXQuY2hhckF0KHRoaXMuc3RhdGUucG9zKTtpZihvLnRlc3QoaSkpdGhyb3cgdGhpcy5yYWlzZSh0LGYuVW50ZXJtaW5hdGVkUmVnRXhwKTtpZihlKWU9ITE7ZWxzZXtpZihcIltcIj09PWkpcz0hMDtlbHNlIGlmKFwiXVwiPT09aSYmcylzPSExO2Vsc2UgaWYoXCIvXCI9PT1pJiYhcylicmVhaztlPVwiXFxcXFwiPT09aX0rK3RoaXMuc3RhdGUucG9zfWNvbnN0IGk9dGhpcy5pbnB1dC5zbGljZSh0LHRoaXMuc3RhdGUucG9zKTsrK3RoaXMuc3RhdGUucG9zO2xldCByPVwiXCI7Zm9yKDt0aGlzLnN0YXRlLnBvczx0aGlzLmxlbmd0aDspe2NvbnN0IHQ9dGhpcy5pbnB1dFt0aGlzLnN0YXRlLnBvc10sZT10aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuc3RhdGUucG9zKTtpZihtdC5oYXModCkpci5pbmRleE9mKHQpPi0xJiZ0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zKzEsZi5EdXBsaWNhdGVSZWdFeHBGbGFncyk7ZWxzZXtpZighUyhlKSYmOTIhPT1lKWJyZWFrO3RoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MrMSxmLk1hbGZvcm1lZFJlZ0V4cEZsYWdzKX0rK3RoaXMuc3RhdGUucG9zLHIrPXR9dGhpcy5maW5pc2hUb2tlbihuLnJlZ2V4cCx7cGF0dGVybjppLGZsYWdzOnJ9KX1yZWFkSW50KHQsZSxzLGk9ITApe2NvbnN0IHI9dGhpcy5zdGF0ZS5wb3MsYT0xNj09PXQ/ZnQuaGV4OmZ0LmRlY0Jpbk9jdCxuPTE2PT09dD9EdC5oZXg6MTA9PT10P0R0LmRlYzo4PT09dD9EdC5vY3Q6RHQuYmluO2xldCBvPSExLGg9MDtmb3IobGV0IHI9MCxwPW51bGw9PWU/MS8wOmU7cjxwOysrcil7Y29uc3QgZT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO2xldCBwO2lmKHRoaXMuaGFzUGx1Z2luKFwibnVtZXJpY1NlcGFyYXRvclwiKSYmOTU9PT1lKXtjb25zdCB0PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcy0xKSxlPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcysxKTstMT09PW4uaW5kZXhPZihlKT90aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLGYuVW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3IpOihhLmluZGV4T2YodCk+LTF8fGEuaW5kZXhPZihlKT4tMXx8TnVtYmVyLmlzTmFOKGUpKSYmdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcyxmLlVuZXhwZWN0ZWROdW1lcmljU2VwYXJhdG9yKSxpfHx0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLGYuTnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2UpLCsrdGhpcy5zdGF0ZS5wb3N9ZWxzZXtpZihwPWU+PTk3P2UtOTcrMTA6ZT49NjU/ZS02NSsxMDpkdChlKT9lLTQ4OjEvMCxwPj10KWlmKHRoaXMub3B0aW9ucy5lcnJvclJlY292ZXJ5JiZwPD05KXA9MCx0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQrcisyLGYuSW52YWxpZERpZ2l0LHQpO2Vsc2V7aWYoIXMpYnJlYWs7cD0wLG89ITB9Kyt0aGlzLnN0YXRlLnBvcyxoPWgqdCtwfX1yZXR1cm4gdGhpcy5zdGF0ZS5wb3M9PT1yfHxudWxsIT1lJiZ0aGlzLnN0YXRlLnBvcy1yIT09ZXx8bz9udWxsOmh9cmVhZFJhZGl4TnVtYmVyKHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS5wb3M7bGV0IHM9ITE7dGhpcy5zdGF0ZS5wb3MrPTI7Y29uc3QgaT10aGlzLnJlYWRJbnQodCk7aWYobnVsbD09aSYmdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0KzIsZi5JbnZhbGlkRGlnaXQsdCksMTEwPT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKSYmKCsrdGhpcy5zdGF0ZS5wb3Mscz0hMCksdyh0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuc3RhdGUucG9zKSkpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcyxmLk51bWJlcklkZW50aWZpZXIpO2lmKHMpe2NvbnN0IHQ9dGhpcy5pbnB1dC5zbGljZShlLHRoaXMuc3RhdGUucG9zKS5yZXBsYWNlKC9bX25dL2csXCJcIik7dGhpcy5maW5pc2hUb2tlbihuLmJpZ2ludCx0KX1lbHNlIHRoaXMuZmluaXNoVG9rZW4obi5udW0saSl9cmVhZE51bWJlcih0KXtjb25zdCBlPXRoaXMuc3RhdGUucG9zO2xldCBzPSExLGk9ITEscj0hMTt0fHxudWxsIT09dGhpcy5yZWFkSW50KDEwKXx8dGhpcy5yYWlzZShlLGYuSW52YWxpZE51bWJlcik7bGV0IGE9dGhpcy5zdGF0ZS5wb3MtZT49MiYmNDg9PT10aGlzLmlucHV0LmNoYXJDb2RlQXQoZSk7YSYmKHRoaXMuc3RhdGUuc3RyaWN0JiZ0aGlzLnJhaXNlKGUsZi5TdHJpY3RPY3RhbExpdGVyYWwpLC9bODldLy50ZXN0KHRoaXMuaW5wdXQuc2xpY2UoZSx0aGlzLnN0YXRlLnBvcykpJiYoYT0hMSxyPSEwKSk7bGV0IG89dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtpZig0NiE9PW98fGF8fCgrK3RoaXMuc3RhdGUucG9zLHRoaXMucmVhZEludCgxMCkscz0hMCxvPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykpLDY5IT09byYmMTAxIT09b3x8YXx8KG89dGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5zdGF0ZS5wb3MpLDQzIT09byYmNDUhPT1vfHwrK3RoaXMuc3RhdGUucG9zLG51bGw9PT10aGlzLnJlYWRJbnQoMTApJiZ0aGlzLnJhaXNlKGUsXCJJbnZhbGlkIG51bWJlclwiKSxzPSEwLG89dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKSksdGhpcy5oYXNQbHVnaW4oXCJudW1lcmljU2VwYXJhdG9yXCIpJiYoYXx8cikpe2NvbnN0IHQ9dGhpcy5pbnB1dC5zbGljZShlLHRoaXMuc3RhdGUucG9zKS5pbmRleE9mKFwiX1wiKTt0PjAmJnRoaXMucmFpc2UodCtlLGYuWmVyb0RpZ2l0TnVtZXJpY1NlcGFyYXRvcil9aWYoMTEwPT09byYmKChzfHxhfHxyKSYmdGhpcy5yYWlzZShlLFwiSW52YWxpZCBCaWdJbnRMaXRlcmFsXCIpLCsrdGhpcy5zdGF0ZS5wb3MsaT0hMCksdyh0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMuc3RhdGUucG9zKSkpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcyxmLk51bWJlcklkZW50aWZpZXIpO2NvbnN0IGg9dGhpcy5pbnB1dC5zbGljZShlLHRoaXMuc3RhdGUucG9zKS5yZXBsYWNlKC9bX25dL2csXCJcIik7aWYoaSlyZXR1cm4gdm9pZCB0aGlzLmZpbmlzaFRva2VuKG4uYmlnaW50LGgpO2NvbnN0IHA9YT9wYXJzZUludChoLDgpOnBhcnNlRmxvYXQoaCk7dGhpcy5maW5pc2hUb2tlbihuLm51bSxwKX1yZWFkQ29kZVBvaW50KHQpe2xldCBlO2lmKDEyMz09PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykpe2NvbnN0IHM9Kyt0aGlzLnN0YXRlLnBvcztpZihlPXRoaXMucmVhZEhleENoYXIodGhpcy5pbnB1dC5pbmRleE9mKFwifVwiLHRoaXMuc3RhdGUucG9zKS10aGlzLnN0YXRlLnBvcywhMCx0KSwrK3RoaXMuc3RhdGUucG9zLG51bGwhPT1lJiZlPjExMTQxMTEpe2lmKCF0KXJldHVybiBudWxsO3RoaXMucmFpc2UocyxmLkludmFsaWRDb2RlUG9pbnQpfX1lbHNlIGU9dGhpcy5yZWFkSGV4Q2hhcig0LCExLHQpO3JldHVybiBlfXJlYWRTdHJpbmcodCl7bGV0IGU9XCJcIixzPSsrdGhpcy5zdGF0ZS5wb3M7Zm9yKDs7KXtpZih0aGlzLnN0YXRlLnBvcz49dGhpcy5sZW5ndGgpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGYuVW50ZXJtaW5hdGVkU3RyaW5nKTtjb25zdCBpPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7aWYoaT09PXQpYnJlYWs7aWYoOTI9PT1pKWUrPXRoaXMuaW5wdXQuc2xpY2Uocyx0aGlzLnN0YXRlLnBvcyksZSs9dGhpcy5yZWFkRXNjYXBlZENoYXIoITEpLHM9dGhpcy5zdGF0ZS5wb3M7ZWxzZSBpZig4MjMyPT09aXx8ODIzMz09PWkpKyt0aGlzLnN0YXRlLnBvcywrK3RoaXMuc3RhdGUuY3VyTGluZSx0aGlzLnN0YXRlLmxpbmVTdGFydD10aGlzLnN0YXRlLnBvcztlbHNle2lmKHAoaSkpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGYuVW50ZXJtaW5hdGVkU3RyaW5nKTsrK3RoaXMuc3RhdGUucG9zfX1lKz10aGlzLmlucHV0LnNsaWNlKHMsdGhpcy5zdGF0ZS5wb3MrKyksdGhpcy5maW5pc2hUb2tlbihuLnN0cmluZyxlKX1yZWFkVG1wbFRva2VuKCl7bGV0IHQ9XCJcIixlPXRoaXMuc3RhdGUucG9zLHM9ITE7Zm9yKDs7KXtpZih0aGlzLnN0YXRlLnBvcz49dGhpcy5sZW5ndGgpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGYuVW50ZXJtaW5hdGVkVGVtcGxhdGUpO2NvbnN0IGk9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtpZig5Nj09PWl8fDM2PT09aSYmMTIzPT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKzEpKXJldHVybiB0aGlzLnN0YXRlLnBvcz09PXRoaXMuc3RhdGUuc3RhcnQmJnRoaXMubWF0Y2gobi50ZW1wbGF0ZSk/MzY9PT1pPyh0aGlzLnN0YXRlLnBvcys9Mix2b2lkIHRoaXMuZmluaXNoVG9rZW4obi5kb2xsYXJCcmFjZUwpKTooKyt0aGlzLnN0YXRlLnBvcyx2b2lkIHRoaXMuZmluaXNoVG9rZW4obi5iYWNrUXVvdGUpKToodCs9dGhpcy5pbnB1dC5zbGljZShlLHRoaXMuc3RhdGUucG9zKSx2b2lkIHRoaXMuZmluaXNoVG9rZW4obi50ZW1wbGF0ZSxzP251bGw6dCkpO2lmKDkyPT09aSl7dCs9dGhpcy5pbnB1dC5zbGljZShlLHRoaXMuc3RhdGUucG9zKTtjb25zdCBpPXRoaXMucmVhZEVzY2FwZWRDaGFyKCEwKTtudWxsPT09aT9zPSEwOnQrPWksZT10aGlzLnN0YXRlLnBvc31lbHNlIGlmKHAoaSkpe3N3aXRjaCh0Kz10aGlzLmlucHV0LnNsaWNlKGUsdGhpcy5zdGF0ZS5wb3MpLCsrdGhpcy5zdGF0ZS5wb3MsaSl7Y2FzZSAxMzoxMD09PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykmJisrdGhpcy5zdGF0ZS5wb3M7Y2FzZSAxMDp0Kz1cIlxcblwiO2JyZWFrO2RlZmF1bHQ6dCs9U3RyaW5nLmZyb21DaGFyQ29kZShpKX0rK3RoaXMuc3RhdGUuY3VyTGluZSx0aGlzLnN0YXRlLmxpbmVTdGFydD10aGlzLnN0YXRlLnBvcyxlPXRoaXMuc3RhdGUucG9zfWVsc2UrK3RoaXMuc3RhdGUucG9zfX1yZWFkRXNjYXBlZENoYXIodCl7Y29uc3QgZT0hdCxzPXRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKTtzd2l0Y2goKyt0aGlzLnN0YXRlLnBvcyxzKXtjYXNlIDExMDpyZXR1cm5cIlxcblwiO2Nhc2UgMTE0OnJldHVyblwiXFxyXCI7Y2FzZSAxMjA6e2NvbnN0IHQ9dGhpcy5yZWFkSGV4Q2hhcigyLCExLGUpO3JldHVybiBudWxsPT09dD9udWxsOlN0cmluZy5mcm9tQ2hhckNvZGUodCl9Y2FzZSAxMTc6e2NvbnN0IHQ9dGhpcy5yZWFkQ29kZVBvaW50KGUpO3JldHVybiBudWxsPT09dD9udWxsOlN0cmluZy5mcm9tQ29kZVBvaW50KHQpfWNhc2UgMTE2OnJldHVyblwiXFx0XCI7Y2FzZSA5ODpyZXR1cm5cIlxcYlwiO2Nhc2UgMTE4OnJldHVyblwiXFx2XCI7Y2FzZSAxMDI6cmV0dXJuXCJcXGZcIjtjYXNlIDEzOjEwPT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKSYmKyt0aGlzLnN0YXRlLnBvcztjYXNlIDEwOnRoaXMuc3RhdGUubGluZVN0YXJ0PXRoaXMuc3RhdGUucG9zLCsrdGhpcy5zdGF0ZS5jdXJMaW5lO2Nhc2UgODIzMjpjYXNlIDgyMzM6cmV0dXJuXCJcIjtjYXNlIDU2OmNhc2UgNTc6aWYodClyZXR1cm4gbnVsbDtkZWZhdWx0OmlmKHM+PTQ4JiZzPD01NSl7Y29uc3QgZT10aGlzLnN0YXRlLnBvcy0xO2xldCBzPXRoaXMuaW5wdXQuc3Vic3RyKHRoaXMuc3RhdGUucG9zLTEsMykubWF0Y2goL15bMC03XSsvKVswXSxpPXBhcnNlSW50KHMsOCk7aT4yNTUmJihzPXMuc2xpY2UoMCwtMSksaT1wYXJzZUludChzLDgpKSx0aGlzLnN0YXRlLnBvcys9cy5sZW5ndGgtMTtjb25zdCByPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7aWYoXCIwXCIhPT1zfHw1Nj09PXJ8fDU3PT09cil7aWYodClyZXR1cm4gbnVsbDt0aGlzLnN0YXRlLnN0cmljdD90aGlzLnJhaXNlKGUsZi5TdHJpY3RPY3RhbExpdGVyYWwpOnRoaXMuc3RhdGUub2N0YWxQb3NpdGlvbnMucHVzaChlKX1yZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShpKX1yZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzKX19cmVhZEhleENoYXIodCxlLHMpe2NvbnN0IGk9dGhpcy5zdGF0ZS5wb3Mscj10aGlzLnJlYWRJbnQoMTYsdCxlLCExKTtyZXR1cm4gbnVsbD09PXImJihzP3RoaXMucmFpc2UoaSxmLkludmFsaWRFc2NhcGVTZXF1ZW5jZSk6dGhpcy5zdGF0ZS5wb3M9aS0xKSxyfXJlYWRXb3JkMSgpe2xldCB0PVwiXCI7dGhpcy5zdGF0ZS5jb250YWluc0VzYz0hMTtjb25zdCBlPXRoaXMuc3RhdGUucG9zO2xldCBzPXRoaXMuc3RhdGUucG9zO2Zvcig7dGhpcy5zdGF0ZS5wb3M8dGhpcy5sZW5ndGg7KXtjb25zdCBpPXRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5zdGF0ZS5wb3MpO2lmKFMoaSkpdGhpcy5zdGF0ZS5wb3MrPWk8PTY1NTM1PzE6MjtlbHNlIGlmKHRoaXMuc3RhdGUuaXNJdGVyYXRvciYmNjQ9PT1pKSsrdGhpcy5zdGF0ZS5wb3M7ZWxzZXtpZig5MiE9PWkpYnJlYWs7e3RoaXMuc3RhdGUuY29udGFpbnNFc2M9ITAsdCs9dGhpcy5pbnB1dC5zbGljZShzLHRoaXMuc3RhdGUucG9zKTtjb25zdCBpPXRoaXMuc3RhdGUucG9zLHI9dGhpcy5zdGF0ZS5wb3M9PT1lP3c6UztpZigxMTchPT10aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnN0YXRlLnBvcykpe3RoaXMucmFpc2UodGhpcy5zdGF0ZS5wb3MsZi5NaXNzaW5nVW5pY29kZUVzY2FwZSk7Y29udGludWV9Kyt0aGlzLnN0YXRlLnBvcztjb25zdCBhPXRoaXMucmVhZENvZGVQb2ludCghMCk7bnVsbCE9PWEmJihyKGEpfHx0aGlzLnJhaXNlKGksZi5Fc2NhcGVkQ2hhck5vdEFuSWRlbnRpZmllciksdCs9U3RyaW5nLmZyb21Db2RlUG9pbnQoYSkpLHM9dGhpcy5zdGF0ZS5wb3N9fX1yZXR1cm4gdCt0aGlzLmlucHV0LnNsaWNlKHMsdGhpcy5zdGF0ZS5wb3MpfWlzSXRlcmF0b3IodCl7cmV0dXJuXCJAQGl0ZXJhdG9yXCI9PT10fHxcIkBAYXN5bmNJdGVyYXRvclwiPT09dH1yZWFkV29yZCgpe2NvbnN0IHQ9dGhpcy5yZWFkV29yZDEoKSxlPWkuZ2V0KHQpfHxuLm5hbWU7IXRoaXMuc3RhdGUuaXNJdGVyYXRvcnx8dGhpcy5pc0l0ZXJhdG9yKHQpJiZ0aGlzLnN0YXRlLmluVHlwZXx8dGhpcy5yYWlzZSh0aGlzLnN0YXRlLnBvcyxmLkludmFsaWRJZGVudGlmaWVyLHQpLHRoaXMuZmluaXNoVG9rZW4oZSx0KX1jaGVja0tleXdvcmRFc2NhcGVzKCl7Y29uc3QgdD10aGlzLnN0YXRlLnR5cGUua2V5d29yZDt0JiZ0aGlzLnN0YXRlLmNvbnRhaW5zRXNjJiZ0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCx0KX1icmFjZUlzQmxvY2sodCl7Y29uc3QgZT10aGlzLmN1ckNvbnRleHQoKTtyZXR1cm4gZT09PXguZnVuY3Rpb25FeHByZXNzaW9ufHxlPT09eC5mdW5jdGlvblN0YXRlbWVudHx8KHQhPT1uLmNvbG9ufHxlIT09eC5icmFjZVN0YXRlbWVudCYmZSE9PXguYnJhY2VFeHByZXNzaW9uP3Q9PT1uLl9yZXR1cm58fHQ9PT1uLm5hbWUmJnRoaXMuc3RhdGUuZXhwckFsbG93ZWQ/by50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLHRoaXMuc3RhdGUuc3RhcnQpKTp0PT09bi5fZWxzZXx8dD09PW4uc2VtaXx8dD09PW4uZW9mfHx0PT09bi5wYXJlblJ8fHQ9PT1uLmFycm93fHwodD09PW4uYnJhY2VMP2U9PT14LmJyYWNlU3RhdGVtZW50OnQhPT1uLl92YXImJnQhPT1uLl9jb25zdCYmdCE9PW4ubmFtZSYmKHQ9PT1uLnJlbGF0aW9uYWx8fCF0aGlzLnN0YXRlLmV4cHJBbGxvd2VkKSk6IWUuaXNFeHByKX11cGRhdGVDb250ZXh0KHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS50eXBlO2xldCBzOyFlLmtleXdvcmR8fHQhPT1uLmRvdCYmdCE9PW4ucXVlc3Rpb25Eb3Q/KHM9ZS51cGRhdGVDb250ZXh0KT9zLmNhbGwodGhpcyx0KTp0aGlzLnN0YXRlLmV4cHJBbGxvd2VkPWUuYmVmb3JlRXhwcjp0aGlzLnN0YXRlLmV4cHJBbGxvd2VkPSExfX17YWRkRXh0cmEodCxlLHMpe2lmKCF0KXJldHVybjsodC5leHRyYT10LmV4dHJhfHx7fSlbZV09c31pc1JlbGF0aW9uYWwodCl7cmV0dXJuIHRoaXMubWF0Y2gobi5yZWxhdGlvbmFsKSYmdGhpcy5zdGF0ZS52YWx1ZT09PXR9aXNMb29rYWhlYWRSZWxhdGlvbmFsKHQpe2NvbnN0IGU9dGhpcy5uZXh0VG9rZW5TdGFydCgpO2lmKHRoaXMuaW5wdXQuY2hhckF0KGUpPT09dCl7aWYoZSsxPT09dGhpcy5pbnB1dC5sZW5ndGgpcmV0dXJuITA7Y29uc3Qgcz10aGlzLmlucHV0LmNoYXJDb2RlQXQoZSsxKTtyZXR1cm4gcyE9PXQuY2hhckNvZGVBdCgwKSYmNjEhPT1zfXJldHVybiExfWV4cGVjdFJlbGF0aW9uYWwodCl7dGhpcy5pc1JlbGF0aW9uYWwodCk/dGhpcy5uZXh0KCk6dGhpcy51bmV4cGVjdGVkKG51bGwsbi5yZWxhdGlvbmFsKX1pc0NvbnRleHR1YWwodCl7cmV0dXJuIHRoaXMubWF0Y2gobi5uYW1lKSYmdGhpcy5zdGF0ZS52YWx1ZT09PXQmJiF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjfWlzVW5wYXJzZWRDb250ZXh0dWFsKHQsZSl7Y29uc3Qgcz10K2UubGVuZ3RoO3JldHVybiB0aGlzLmlucHV0LnNsaWNlKHQscyk9PT1lJiYocz09PXRoaXMuaW5wdXQubGVuZ3RofHwhUyh0aGlzLmlucHV0LmNoYXJDb2RlQXQocykpKX1pc0xvb2thaGVhZENvbnRleHR1YWwodCl7Y29uc3QgZT10aGlzLm5leHRUb2tlblN0YXJ0KCk7cmV0dXJuIHRoaXMuaXNVbnBhcnNlZENvbnRleHR1YWwoZSx0KX1lYXRDb250ZXh0dWFsKHQpe3JldHVybiB0aGlzLmlzQ29udGV4dHVhbCh0KSYmdGhpcy5lYXQobi5uYW1lKX1leHBlY3RDb250ZXh0dWFsKHQsZSl7dGhpcy5lYXRDb250ZXh0dWFsKHQpfHx0aGlzLnVuZXhwZWN0ZWQobnVsbCxlKX1jYW5JbnNlcnRTZW1pY29sb24oKXtyZXR1cm4gdGhpcy5tYXRjaChuLmVvZil8fHRoaXMubWF0Y2gobi5icmFjZVIpfHx0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpfWhhc1ByZWNlZGluZ0xpbmVCcmVhaygpe3JldHVybiBvLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLmxhc3RUb2tFbmQsdGhpcy5zdGF0ZS5zdGFydCkpfWlzTGluZVRlcm1pbmF0b3IoKXtyZXR1cm4gdGhpcy5lYXQobi5zZW1pKXx8dGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKX1zZW1pY29sb24oKXt0aGlzLmlzTGluZVRlcm1pbmF0b3IoKXx8dGhpcy51bmV4cGVjdGVkKG51bGwsbi5zZW1pKX1leHBlY3QodCxlKXt0aGlzLmVhdCh0KXx8dGhpcy51bmV4cGVjdGVkKGUsdCl9YXNzZXJ0Tm9TcGFjZSh0PVwiVW5leHBlY3RlZCBzcGFjZS5cIil7dGhpcy5zdGF0ZS5zdGFydD50aGlzLnN0YXRlLmxhc3RUb2tFbmQmJnRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLHQpfXVuZXhwZWN0ZWQodCxlPVwiVW5leHBlY3RlZCB0b2tlblwiKXt0aHJvd1wic3RyaW5nXCIhPXR5cGVvZiBlJiYoZT0nVW5leHBlY3RlZCB0b2tlbiwgZXhwZWN0ZWQgXCInLmNvbmNhdChlLmxhYmVsLCdcIicpKSx0aGlzLnJhaXNlKG51bGwhPXQ/dDp0aGlzLnN0YXRlLnN0YXJ0LGUpfWV4cGVjdFBsdWdpbih0LGUpe2lmKCF0aGlzLmhhc1BsdWdpbih0KSl0aHJvdyB0aGlzLnJhaXNlV2l0aERhdGEobnVsbCE9ZT9lOnRoaXMuc3RhdGUuc3RhcnQse21pc3NpbmdQbHVnaW46W3RdfSxcIlRoaXMgZXhwZXJpbWVudGFsIHN5bnRheCByZXF1aXJlcyBlbmFibGluZyB0aGUgcGFyc2VyIHBsdWdpbjogJ1wiLmNvbmNhdCh0LFwiJ1wiKSk7cmV0dXJuITB9ZXhwZWN0T25lUGx1Z2luKHQsZSl7aWYoIXQuc29tZSh0PT50aGlzLmhhc1BsdWdpbih0KSkpdGhyb3cgdGhpcy5yYWlzZVdpdGhEYXRhKG51bGwhPWU/ZTp0aGlzLnN0YXRlLnN0YXJ0LHttaXNzaW5nUGx1Z2luOnR9LFwiVGhpcyBleHBlcmltZW50YWwgc3ludGF4IHJlcXVpcmVzIGVuYWJsaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nIHBhcnNlciBwbHVnaW4ocyk6ICdcIi5jb25jYXQodC5qb2luKFwiLCBcIiksXCInXCIpKX1jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKXstMSE9PXRoaXMuc3RhdGUueWllbGRQb3MmJigtMT09PXRoaXMuc3RhdGUuYXdhaXRQb3N8fHRoaXMuc3RhdGUueWllbGRQb3M8dGhpcy5zdGF0ZS5hd2FpdFBvcykmJnRoaXMucmFpc2UodGhpcy5zdGF0ZS55aWVsZFBvcyxcIllpZWxkIGNhbm5vdCBiZSB1c2VkIGFzIG5hbWUgaW5zaWRlIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uXCIpLC0xIT09dGhpcy5zdGF0ZS5hd2FpdFBvcyYmdGhpcy5yYWlzZSh0aGlzLnN0YXRlLmF3YWl0UG9zLFwiQXdhaXQgY2Fubm90IGJlIHVzZWQgYXMgbmFtZSBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIil9dHJ5UGFyc2UodCxlPXRoaXMuc3RhdGUuY2xvbmUoKSl7Y29uc3Qgcz17bm9kZTpudWxsfTt0cnl7Y29uc3QgaT10KCh0PW51bGwpPT57dGhyb3cgcy5ub2RlPXQsc30pO2lmKHRoaXMuc3RhdGUuZXJyb3JzLmxlbmd0aD5lLmVycm9ycy5sZW5ndGgpe2NvbnN0IHQ9dGhpcy5zdGF0ZTtyZXR1cm4gdGhpcy5zdGF0ZT1lLHtub2RlOmksZXJyb3I6dC5lcnJvcnNbZS5lcnJvcnMubGVuZ3RoXSx0aHJvd246ITEsYWJvcnRlZDohMSxmYWlsU3RhdGU6dH19cmV0dXJue25vZGU6aSxlcnJvcjpudWxsLHRocm93bjohMSxhYm9ydGVkOiExLGZhaWxTdGF0ZTpudWxsfX1jYXRjaCh0KXtjb25zdCBpPXRoaXMuc3RhdGU7aWYodGhpcy5zdGF0ZT1lLHQgaW5zdGFuY2VvZiBTeW50YXhFcnJvcilyZXR1cm57bm9kZTpudWxsLGVycm9yOnQsdGhyb3duOiEwLGFib3J0ZWQ6ITEsZmFpbFN0YXRlOml9O2lmKHQ9PT1zKXJldHVybntub2RlOnMubm9kZSxlcnJvcjpudWxsLHRocm93bjohMSxhYm9ydGVkOiEwLGZhaWxTdGF0ZTppfTt0aHJvdyB0fX1jaGVja0V4cHJlc3Npb25FcnJvcnModCxlKXtpZighdClyZXR1cm4hMTtjb25zdHtzaG9ydGhhbmRBc3NpZ246cyxkb3VibGVQcm90bzppfT10O2lmKCFlKXJldHVybiBzPj0wfHxpPj0wO3M+PTAmJnRoaXMudW5leHBlY3RlZChzKSxpPj0wJiZ0aGlzLnJhaXNlKGksZi5EdXBsaWNhdGVQcm90byl9fXtzdGFydE5vZGUoKXtyZXR1cm4gbmV3IGd0KHRoaXMsdGhpcy5zdGF0ZS5zdGFydCx0aGlzLnN0YXRlLnN0YXJ0TG9jKX1zdGFydE5vZGVBdCh0LGUpe3JldHVybiBuZXcgZ3QodGhpcyx0LGUpfXN0YXJ0Tm9kZUF0Tm9kZSh0KXtyZXR1cm4gdGhpcy5zdGFydE5vZGVBdCh0LnN0YXJ0LHQubG9jLnN0YXJ0KX1maW5pc2hOb2RlKHQsZSl7cmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KHQsZSx0aGlzLnN0YXRlLmxhc3RUb2tFbmQsdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKX1maW5pc2hOb2RlQXQodCxlLHMsaSl7cmV0dXJuIHQudHlwZT1lLHQuZW5kPXMsdC5sb2MuZW5kPWksdGhpcy5vcHRpb25zLnJhbmdlcyYmKHQucmFuZ2VbMV09cyksdGhpcy5wcm9jZXNzQ29tbWVudCh0KSx0fXJlc2V0U3RhcnRMb2NhdGlvbih0LGUscyl7dC5zdGFydD1lLHQubG9jLnN0YXJ0PXMsdGhpcy5vcHRpb25zLnJhbmdlcyYmKHQucmFuZ2VbMF09ZSl9cmVzZXRFbmRMb2NhdGlvbih0LGU9dGhpcy5zdGF0ZS5sYXN0VG9rRW5kLHM9dGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKXt0LmVuZD1lLHQubG9jLmVuZD1zLHRoaXMub3B0aW9ucy5yYW5nZXMmJih0LnJhbmdlWzFdPWUpfXJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKHQsZSl7dGhpcy5yZXNldFN0YXJ0TG9jYXRpb24odCxlLnN0YXJ0LGUubG9jLnN0YXJ0KX19e3RvQXNzaWduYWJsZSh0KXt2YXIgZSxzO2xldCBpPXZvaWQgMDtzd2l0Y2goKFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIj09PXQudHlwZXx8KG51bGw9PShlPXQuZXh0cmEpP3ZvaWQgMDplLnBhcmVudGhlc2l6ZWQpKSYmKGk9UHQodCksXCJJZGVudGlmaWVyXCIhPT1pLnR5cGUmJlwiTWVtYmVyRXhwcmVzc2lvblwiIT09aS50eXBlJiZ0aGlzLnJhaXNlKHQuc3RhcnQsZi5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQpKSx0LnR5cGUpe2Nhc2VcIklkZW50aWZpZXJcIjpjYXNlXCJPYmplY3RQYXR0ZXJuXCI6Y2FzZVwiQXJyYXlQYXR0ZXJuXCI6Y2FzZVwiQXNzaWdubWVudFBhdHRlcm5cIjpicmVhaztjYXNlXCJPYmplY3RFeHByZXNzaW9uXCI6dC50eXBlPVwiT2JqZWN0UGF0dGVyblwiO2ZvcihsZXQgZT0wLHM9dC5wcm9wZXJ0aWVzLmxlbmd0aCxpPXMtMTtlPHM7ZSsrKXt2YXIgcjtjb25zdCBzPXQucHJvcGVydGllc1tlXSxhPWU9PT1pO3RoaXMudG9Bc3NpZ25hYmxlT2JqZWN0RXhwcmVzc2lvblByb3AocyxhKSxhJiZcIlJlc3RFbGVtZW50XCI9PT1zLnR5cGUmJihudWxsPT0ocj10LmV4dHJhKT92b2lkIDA6ci50cmFpbGluZ0NvbW1hKSYmdGhpcy5yYWlzZVJlc3ROb3RMYXN0KHQuZXh0cmEudHJhaWxpbmdDb21tYSl9YnJlYWs7Y2FzZVwiT2JqZWN0UHJvcGVydHlcIjp0aGlzLnRvQXNzaWduYWJsZSh0LnZhbHVlKTticmVhaztjYXNlXCJTcHJlYWRFbGVtZW50XCI6e3RoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKHQpLHQudHlwZT1cIlJlc3RFbGVtZW50XCI7Y29uc3QgZT10LmFyZ3VtZW50O3RoaXMudG9Bc3NpZ25hYmxlKGUpO2JyZWFrfWNhc2VcIkFycmF5RXhwcmVzc2lvblwiOnQudHlwZT1cIkFycmF5UGF0dGVyblwiLHRoaXMudG9Bc3NpZ25hYmxlTGlzdCh0LmVsZW1lbnRzLG51bGw9PShzPXQuZXh0cmEpP3ZvaWQgMDpzLnRyYWlsaW5nQ29tbWEpO2JyZWFrO2Nhc2VcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XCI9XCIhPT10Lm9wZXJhdG9yJiZ0aGlzLnJhaXNlKHQubGVmdC5lbmQsZi5NaXNzaW5nRXFJbkFzc2lnbm1lbnQpLHQudHlwZT1cIkFzc2lnbm1lbnRQYXR0ZXJuXCIsZGVsZXRlIHQub3BlcmF0b3IsdGhpcy50b0Fzc2lnbmFibGUodC5sZWZ0KTticmVhaztjYXNlXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOnRoaXMudG9Bc3NpZ25hYmxlKGkpfXJldHVybiB0fXRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHQsZSl7aWYoXCJPYmplY3RNZXRob2RcIj09PXQudHlwZSl7Y29uc3QgZT1cImdldFwiPT09dC5raW5kfHxcInNldFwiPT09dC5raW5kP2YuUGF0dGVybkhhc0FjY2Vzc29yOmYuUGF0dGVybkhhc01ldGhvZDt0aGlzLnJhaXNlKHQua2V5LnN0YXJ0LGUpfWVsc2VcIlNwcmVhZEVsZW1lbnRcIiE9PXQudHlwZXx8ZT90aGlzLnRvQXNzaWduYWJsZSh0KTp0aGlzLnJhaXNlUmVzdE5vdExhc3QodC5zdGFydCl9dG9Bc3NpZ25hYmxlTGlzdCh0LGUpe2xldCBzPXQubGVuZ3RoO2lmKHMpe2NvbnN0IGk9dFtzLTFdO2lmKGkmJlwiUmVzdEVsZW1lbnRcIj09PWkudHlwZSktLXM7ZWxzZSBpZihpJiZcIlNwcmVhZEVsZW1lbnRcIj09PWkudHlwZSl7aS50eXBlPVwiUmVzdEVsZW1lbnRcIjtjb25zdCB0PWkuYXJndW1lbnQ7dGhpcy50b0Fzc2lnbmFibGUodCksXCJJZGVudGlmaWVyXCIhPT10LnR5cGUmJlwiTWVtYmVyRXhwcmVzc2lvblwiIT09dC50eXBlJiZcIkFycmF5UGF0dGVyblwiIT09dC50eXBlJiZcIk9iamVjdFBhdHRlcm5cIiE9PXQudHlwZSYmdGhpcy51bmV4cGVjdGVkKHQuc3RhcnQpLGUmJnRoaXMucmFpc2VUcmFpbGluZ0NvbW1hQWZ0ZXJSZXN0KGUpLC0tc319Zm9yKGxldCBlPTA7ZTxzO2UrKyl7Y29uc3Qgcz10W2VdO3MmJih0aGlzLnRvQXNzaWduYWJsZShzKSxcIlJlc3RFbGVtZW50XCI9PT1zLnR5cGUmJnRoaXMucmFpc2VSZXN0Tm90TGFzdChzLnN0YXJ0KSl9cmV0dXJuIHR9dG9SZWZlcmVuY2VkTGlzdCh0LGUpe3JldHVybiB0fXRvUmVmZXJlbmNlZExpc3REZWVwKHQsZSl7dGhpcy50b1JlZmVyZW5jZWRMaXN0KHQsZSk7Zm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2NvbnN0IHM9dFtlXTtzJiZcIkFycmF5RXhwcmVzc2lvblwiPT09cy50eXBlJiZ0aGlzLnRvUmVmZXJlbmNlZExpc3REZWVwKHMuZWxlbWVudHMpfX1wYXJzZVNwcmVhZCh0LGUpe2NvbnN0IHM9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCkscy5hcmd1bWVudD10aGlzLnBhcnNlTWF5YmVBc3NpZ24oITEsdCx2b2lkIDAsZSksdGhpcy5maW5pc2hOb2RlKHMsXCJTcHJlYWRFbGVtZW50XCIpfXBhcnNlUmVzdEJpbmRpbmcoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLHQuYXJndW1lbnQ9dGhpcy5wYXJzZUJpbmRpbmdBdG9tKCksdGhpcy5maW5pc2hOb2RlKHQsXCJSZXN0RWxlbWVudFwiKX1wYXJzZUJpbmRpbmdBdG9tKCl7c3dpdGNoKHRoaXMuc3RhdGUudHlwZSl7Y2FzZSBuLmJyYWNrZXRMOntjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLHQuZWxlbWVudHM9dGhpcy5wYXJzZUJpbmRpbmdMaXN0KG4uYnJhY2tldFIsOTMsITApLHRoaXMuZmluaXNoTm9kZSh0LFwiQXJyYXlQYXR0ZXJuXCIpfWNhc2Ugbi5icmFjZUw6cmV0dXJuIHRoaXMucGFyc2VPYmoobi5icmFjZVIsITApfXJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcigpfXBhcnNlQmluZGluZ0xpc3QodCxlLHMsaSl7Y29uc3Qgcj1bXTtsZXQgYT0hMDtmb3IoOyF0aGlzLmVhdCh0KTspaWYoYT9hPSExOnRoaXMuZXhwZWN0KG4uY29tbWEpLHMmJnRoaXMubWF0Y2gobi5jb21tYSkpci5wdXNoKG51bGwpO2Vsc2V7aWYodGhpcy5lYXQodCkpYnJlYWs7aWYodGhpcy5tYXRjaChuLmVsbGlwc2lzKSl7ci5wdXNoKHRoaXMucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW1UeXBlcyh0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKSkpLHRoaXMuY2hlY2tDb21tYUFmdGVyUmVzdChlKSx0aGlzLmV4cGVjdCh0KTticmVha317Y29uc3QgdD1bXTtmb3IodGhpcy5tYXRjaChuLmF0KSYmdGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpJiZ0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5VbnN1cHBvcnRlZFBhcmFtZXRlckRlY29yYXRvcik7dGhpcy5tYXRjaChuLmF0KTspdC5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7ci5wdXNoKHRoaXMucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW0oaSx0KSl9fXJldHVybiByfXBhcnNlQXNzaWduYWJsZUxpc3RJdGVtKHQsZSl7Y29uc3Qgcz10aGlzLnBhcnNlTWF5YmVEZWZhdWx0KCk7dGhpcy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbVR5cGVzKHMpO2NvbnN0IGk9dGhpcy5wYXJzZU1heWJlRGVmYXVsdChzLnN0YXJ0LHMubG9jLnN0YXJ0LHMpO3JldHVybiBlLmxlbmd0aCYmKHMuZGVjb3JhdG9ycz1lKSxpfXBhcnNlQXNzaWduYWJsZUxpc3RJdGVtVHlwZXModCl7cmV0dXJuIHR9cGFyc2VNYXliZURlZmF1bHQodCxlLHMpe2lmKGU9ZXx8dGhpcy5zdGF0ZS5zdGFydExvYyx0PXR8fHRoaXMuc3RhdGUuc3RhcnQscz1zfHx0aGlzLnBhcnNlQmluZGluZ0F0b20oKSwhdGhpcy5lYXQobi5lcSkpcmV0dXJuIHM7Y29uc3QgaT10aGlzLnN0YXJ0Tm9kZUF0KHQsZSk7cmV0dXJuIGkubGVmdD1zLGkucmlnaHQ9dGhpcy5wYXJzZU1heWJlQXNzaWduKCksdGhpcy5maW5pc2hOb2RlKGksXCJBc3NpZ25tZW50UGF0dGVyblwiKX1jaGVja0xWYWwodCxlPTY0LHMsaSxyLGE9ITEpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIklkZW50aWZpZXJcIjppZih0aGlzLnN0YXRlLnN0cmljdCYmKGE/Tyh0Lm5hbWUsdGhpcy5pbk1vZHVsZSk6TSh0Lm5hbWUpKSYmdGhpcy5yYWlzZSh0LnN0YXJ0LDY0PT09ZT9mLlN0cmljdEV2YWxBcmd1bWVudHM6Zi5TdHJpY3RFdmFsQXJndW1lbnRzQmluZGluZyx0Lm5hbWUpLHMpe2NvbnN0IGU9XCJfXCIuY29uY2F0KHQubmFtZSk7c1tlXT90aGlzLnJhaXNlKHQuc3RhcnQsZi5QYXJhbUR1cGUpOnNbZV09ITB9ciYmXCJsZXRcIj09PXQubmFtZSYmdGhpcy5yYWlzZSh0LnN0YXJ0LGYuTGV0SW5MZXhpY2FsQmluZGluZyksNjQmZXx8dGhpcy5zY29wZS5kZWNsYXJlTmFtZSh0Lm5hbWUsZSx0LnN0YXJ0KTticmVhaztjYXNlXCJNZW1iZXJFeHByZXNzaW9uXCI6NjQhPT1lJiZ0aGlzLnJhaXNlKHQuc3RhcnQsZi5JbnZhbGlkUHJvcGVydHlCaW5kaW5nUGF0dGVybik7YnJlYWs7Y2FzZVwiT2JqZWN0UGF0dGVyblwiOmZvcihsZXQgaT0wLGE9dC5wcm9wZXJ0aWVzO2k8YS5sZW5ndGg7aSsrKXtsZXQgdD1hW2ldO2lmKFwiT2JqZWN0UHJvcGVydHlcIj09PXQudHlwZSl0PXQudmFsdWU7ZWxzZSBpZihcIk9iamVjdE1ldGhvZFwiPT09dC50eXBlKWNvbnRpbnVlO3RoaXMuY2hlY2tMVmFsKHQsZSxzLFwib2JqZWN0IGRlc3RydWN0dXJpbmcgcGF0dGVyblwiLHIpfWJyZWFrO2Nhc2VcIkFycmF5UGF0dGVyblwiOmZvcihsZXQgaT0wLGE9dC5lbGVtZW50cztpPGEubGVuZ3RoO2krKyl7Y29uc3QgdD1hW2ldO3QmJnRoaXMuY2hlY2tMVmFsKHQsZSxzLFwiYXJyYXkgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIscil9YnJlYWs7Y2FzZVwiQXNzaWdubWVudFBhdHRlcm5cIjp0aGlzLmNoZWNrTFZhbCh0LmxlZnQsZSxzLFwiYXNzaWdubWVudCBwYXR0ZXJuXCIpO2JyZWFrO2Nhc2VcIlJlc3RFbGVtZW50XCI6dGhpcy5jaGVja0xWYWwodC5hcmd1bWVudCxlLHMsXCJyZXN0IGVsZW1lbnRcIik7YnJlYWs7Y2FzZVwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjp0aGlzLmNoZWNrTFZhbCh0LmV4cHJlc3Npb24sZSxzLFwicGFyZW50aGVzaXplZCBleHByZXNzaW9uXCIpO2JyZWFrO2RlZmF1bHQ6dGhpcy5yYWlzZSh0LnN0YXJ0LDY0PT09ZT9mLkludmFsaWRMaHM6Zi5JbnZhbGlkTGhzQmluZGluZyxpKX19Y2hlY2tUb1Jlc3RDb252ZXJzaW9uKHQpe1wiSWRlbnRpZmllclwiIT09dC5hcmd1bWVudC50eXBlJiZcIk1lbWJlckV4cHJlc3Npb25cIiE9PXQuYXJndW1lbnQudHlwZSYmdGhpcy5yYWlzZSh0LmFyZ3VtZW50LnN0YXJ0LGYuSW52YWxpZFJlc3RBc3NpZ25tZW50UGF0dGVybil9Y2hlY2tDb21tYUFmdGVyUmVzdCh0KXt0aGlzLm1hdGNoKG4uY29tbWEpJiYodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpPT09dD90aGlzLnJhaXNlVHJhaWxpbmdDb21tYUFmdGVyUmVzdCh0aGlzLnN0YXRlLnN0YXJ0KTp0aGlzLnJhaXNlUmVzdE5vdExhc3QodGhpcy5zdGF0ZS5zdGFydCkpfXJhaXNlUmVzdE5vdExhc3QodCl7dGhyb3cgdGhpcy5yYWlzZSh0LGYuRWxlbWVudEFmdGVyUmVzdCl9cmFpc2VUcmFpbGluZ0NvbW1hQWZ0ZXJSZXN0KHQpe3RoaXMucmFpc2UodCxmLlJlc3RUcmFpbGluZ0NvbW1hKX19e2NoZWNrRHVwbGljYXRlZFByb3RvKHQsZSxzKXtpZihcIlNwcmVhZEVsZW1lbnRcIj09PXQudHlwZXx8dC5jb21wdXRlZHx8dC5raW5kfHx0LnNob3J0aGFuZClyZXR1cm47Y29uc3QgaT10LmtleTtcIl9fcHJvdG9fX1wiPT09KFwiSWRlbnRpZmllclwiPT09aS50eXBlP2kubmFtZTpTdHJpbmcoaS52YWx1ZSkpJiYoZS51c2VkJiYocz8tMT09PXMuZG91YmxlUHJvdG8mJihzLmRvdWJsZVByb3RvPWkuc3RhcnQpOnRoaXMucmFpc2UoaS5zdGFydCxmLkR1cGxpY2F0ZVByb3RvKSksZS51c2VkPSEwKX1nZXRFeHByZXNzaW9uKCl7bGV0IHQ9MDt0aGlzLmhhc1BsdWdpbihcInRvcExldmVsQXdhaXRcIikmJnRoaXMuaW5Nb2R1bGUmJih0fD0yKSx0aGlzLnNjb3BlLmVudGVyKDEpLHRoaXMucHJvZFBhcmFtLmVudGVyKHQpLHRoaXMubmV4dFRva2VuKCk7Y29uc3QgZT10aGlzLnBhcnNlRXhwcmVzc2lvbigpO3JldHVybiB0aGlzLm1hdGNoKG4uZW9mKXx8dGhpcy51bmV4cGVjdGVkKCksZS5jb21tZW50cz10aGlzLnN0YXRlLmNvbW1lbnRzLGUuZXJyb3JzPXRoaXMuc3RhdGUuZXJyb3JzLGV9cGFyc2VFeHByZXNzaW9uKHQsZSl7Y29uc3Qgcz10aGlzLnN0YXRlLnN0YXJ0LGk9dGhpcy5zdGF0ZS5zdGFydExvYyxyPXRoaXMucGFyc2VNYXliZUFzc2lnbih0LGUpO2lmKHRoaXMubWF0Y2gobi5jb21tYSkpe2NvbnN0IGE9dGhpcy5zdGFydE5vZGVBdChzLGkpO2ZvcihhLmV4cHJlc3Npb25zPVtyXTt0aGlzLmVhdChuLmNvbW1hKTspYS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbih0LGUpKTtyZXR1cm4gdGhpcy50b1JlZmVyZW5jZWRMaXN0KGEuZXhwcmVzc2lvbnMpLHRoaXMuZmluaXNoTm9kZShhLFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpfXJldHVybiByfXBhcnNlTWF5YmVBc3NpZ24odCxlLHMsaSl7Y29uc3Qgcj10aGlzLnN0YXRlLnN0YXJ0LGE9dGhpcy5zdGF0ZS5zdGFydExvYztpZih0aGlzLmlzQ29udGV4dHVhbChcInlpZWxkXCIpKXtpZih0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCl7bGV0IGU9dGhpcy5wYXJzZVlpZWxkKHQpO3JldHVybiBzJiYoZT1zLmNhbGwodGhpcyxlLHIsYSkpLGV9dGhpcy5zdGF0ZS5leHByQWxsb3dlZD0hMX1sZXQgbztlP289ITE6KGU9bmV3IHh0LG89ITApLCh0aGlzLm1hdGNoKG4ucGFyZW5MKXx8dGhpcy5tYXRjaChuLm5hbWUpKSYmKHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdD10aGlzLnN0YXRlLnN0YXJ0KTtsZXQgaD10aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbCh0LGUsaSk7aWYocyYmKGg9cy5jYWxsKHRoaXMsaCxyLGEpKSx0aGlzLnN0YXRlLnR5cGUuaXNBc3NpZ24pe2NvbnN0IHM9dGhpcy5zdGFydE5vZGVBdChyLGEpLGk9dGhpcy5zdGF0ZS52YWx1ZTtyZXR1cm4gcy5vcGVyYXRvcj1pLFwiPz89XCI9PT1pJiZ0aGlzLmV4cGVjdFBsdWdpbihcImxvZ2ljYWxBc3NpZ25tZW50XCIpLFwifHw9XCIhPT1pJiZcIiYmPVwiIT09aXx8dGhpcy5leHBlY3RQbHVnaW4oXCJsb2dpY2FsQXNzaWdubWVudFwiKSx0aGlzLm1hdGNoKG4uZXEpPyhzLmxlZnQ9dGhpcy50b0Fzc2lnbmFibGUoaCksZS5kb3VibGVQcm90bz0tMSk6cy5sZWZ0PWgsZS5zaG9ydGhhbmRBc3NpZ24+PXMubGVmdC5zdGFydCYmKGUuc2hvcnRoYW5kQXNzaWduPS0xKSx0aGlzLmNoZWNrTFZhbChoLHZvaWQgMCx2b2lkIDAsXCJhc3NpZ25tZW50IGV4cHJlc3Npb25cIiksdGhpcy5uZXh0KCkscy5yaWdodD10aGlzLnBhcnNlTWF5YmVBc3NpZ24odCksdGhpcy5maW5pc2hOb2RlKHMsXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKX1yZXR1cm4gbyYmdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMoZSwhMCksaH1wYXJzZU1heWJlQ29uZGl0aW9uYWwodCxlLHMpe2NvbnN0IGk9dGhpcy5zdGF0ZS5zdGFydCxyPXRoaXMuc3RhdGUuc3RhcnRMb2MsYT10aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQsbj10aGlzLnBhcnNlRXhwck9wcyh0LGUpO3JldHVyblwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIj09PW4udHlwZSYmbi5zdGFydD09PWE/bjp0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhlLCExKT9uOnRoaXMucGFyc2VDb25kaXRpb25hbChuLHQsaSxyLHMpfXBhcnNlQ29uZGl0aW9uYWwodCxlLHMsaSxyKXtpZih0aGlzLmVhdChuLnF1ZXN0aW9uKSl7Y29uc3Qgcj10aGlzLnN0YXJ0Tm9kZUF0KHMsaSk7cmV0dXJuIHIudGVzdD10LHIuY29uc2VxdWVudD10aGlzLnBhcnNlTWF5YmVBc3NpZ24oKSx0aGlzLmV4cGVjdChuLmNvbG9uKSxyLmFsdGVybmF0ZT10aGlzLnBhcnNlTWF5YmVBc3NpZ24oZSksdGhpcy5maW5pc2hOb2RlKHIsXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIil9cmV0dXJuIHR9cGFyc2VFeHByT3BzKHQsZSl7Y29uc3Qgcz10aGlzLnN0YXRlLnN0YXJ0LGk9dGhpcy5zdGF0ZS5zdGFydExvYyxyPXRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCxhPXRoaXMucGFyc2VNYXliZVVuYXJ5KGUpO3JldHVyblwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIj09PWEudHlwZSYmYS5zdGFydD09PXI/YTp0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhlLCExKT9hOnRoaXMucGFyc2VFeHByT3AoYSxzLGksLTEsdCl9cGFyc2VFeHByT3AodCxlLHMsaSxyKXtsZXQgYT10aGlzLnN0YXRlLnR5cGUuYmlub3A7aWYoIShudWxsPT1hfHxyJiZ0aGlzLm1hdGNoKG4uX2luKSkmJmE+aSl7Y29uc3Qgbz10aGlzLnN0YXRlLnZhbHVlO2lmKFwifD5cIj09PW8mJnRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkpcmV0dXJuIHQ7Y29uc3QgaD10aGlzLnN0YXJ0Tm9kZUF0KGUscyk7aC5sZWZ0PXQsaC5vcGVyYXRvcj1vLFwiKipcIiE9PW98fFwiVW5hcnlFeHByZXNzaW9uXCIhPT10LnR5cGV8fCF0aGlzLm9wdGlvbnMuY3JlYXRlUGFyZW50aGVzaXplZEV4cHJlc3Npb25zJiZ0LmV4dHJhJiZ0LmV4dHJhLnBhcmVudGhlc2l6ZWR8fHRoaXMucmFpc2UodC5hcmd1bWVudC5zdGFydCxmLlVuZXhwZWN0ZWRUb2tlblVuYXJ5RXhwb25lbnRpYXRpb24pO2NvbnN0IHA9dGhpcy5zdGF0ZS50eXBlLGM9cD09PW4ubG9naWNhbE9SfHxwPT09bi5sb2dpY2FsQU5ELHU9cD09PW4ubnVsbGlzaENvYWxlc2Npbmc7aWYocD09PW4ucGlwZWxpbmU/KHRoaXMuZXhwZWN0UGx1Z2luKFwicGlwZWxpbmVPcGVyYXRvclwiKSx0aGlzLnN0YXRlLmluUGlwZWxpbmU9ITAsdGhpcy5jaGVja1BpcGVsaW5lQXRJbmZpeE9wZXJhdG9yKHQsZSkpOnUmJihhPW4ubG9naWNhbEFORC5iaW5vcCksdGhpcy5uZXh0KCkscD09PW4ucGlwZWxpbmUmJlwibWluaW1hbFwiPT09dGhpcy5nZXRQbHVnaW5PcHRpb24oXCJwaXBlbGluZU9wZXJhdG9yXCIsXCJwcm9wb3NhbFwiKSYmdGhpcy5tYXRjaChuLm5hbWUpJiZcImF3YWl0XCI9PT10aGlzLnN0YXRlLnZhbHVlJiZ0aGlzLnByb2RQYXJhbS5oYXNBd2FpdCl0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5VbmV4cGVjdGVkQXdhaXRBZnRlclBpcGVsaW5lQm9keSk7aC5yaWdodD10aGlzLnBhcnNlRXhwck9wUmlnaHRFeHByKHAsYSxyKSx0aGlzLmZpbmlzaE5vZGUoaCxjfHx1P1wiTG9naWNhbEV4cHJlc3Npb25cIjpcIkJpbmFyeUV4cHJlc3Npb25cIik7Y29uc3QgbD10aGlzLnN0YXRlLnR5cGU7aWYodSYmKGw9PT1uLmxvZ2ljYWxPUnx8bD09PW4ubG9naWNhbEFORCl8fGMmJmw9PT1uLm51bGxpc2hDb2FsZXNjaW5nKXRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxmLk1peGluZ0NvYWxlc2NlV2l0aExvZ2ljYWwpO3JldHVybiB0aGlzLnBhcnNlRXhwck9wKGgsZSxzLGkscil9cmV0dXJuIHR9cGFyc2VFeHByT3BSaWdodEV4cHIodCxlLHMpe2NvbnN0IGk9dGhpcy5zdGF0ZS5zdGFydCxyPXRoaXMuc3RhdGUuc3RhcnRMb2M7c3dpdGNoKHQpe2Nhc2Ugbi5waXBlbGluZTpzd2l0Y2godGhpcy5nZXRQbHVnaW5PcHRpb24oXCJwaXBlbGluZU9wZXJhdG9yXCIsXCJwcm9wb3NhbFwiKSl7Y2FzZVwic21hcnRcIjpyZXR1cm4gdGhpcy53aXRoVG9waWNQZXJtaXR0aW5nQ29udGV4dCgoKT0+dGhpcy5wYXJzZVNtYXJ0UGlwZWxpbmVCb2R5KHRoaXMucGFyc2VFeHByT3BCYXNlUmlnaHRFeHByKHQsZSxzKSxpLHIpKTtjYXNlXCJmc2hhcnBcIjpyZXR1cm4gdGhpcy53aXRoU29sb0F3YWl0UGVybWl0dGluZ0NvbnRleHQoKCk9PnRoaXMucGFyc2VGU2hhcnBQaXBlbGluZUJvZHkoZSxzKSl9ZGVmYXVsdDpyZXR1cm4gdGhpcy5wYXJzZUV4cHJPcEJhc2VSaWdodEV4cHIodCxlLHMpfX1wYXJzZUV4cHJPcEJhc2VSaWdodEV4cHIodCxlLHMpe2NvbnN0IGk9dGhpcy5zdGF0ZS5zdGFydCxyPXRoaXMuc3RhdGUuc3RhcnRMb2M7cmV0dXJuIHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkoKSxpLHIsdC5yaWdodEFzc29jaWF0aXZlP2UtMTplLHMpfXBhcnNlTWF5YmVVbmFyeSh0KXtpZih0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpJiZ0aGlzLmlzQXdhaXRBbGxvd2VkKCkpcmV0dXJuIHRoaXMucGFyc2VBd2FpdCgpO2lmKHRoaXMuc3RhdGUudHlwZS5wcmVmaXgpe2NvbnN0IGU9dGhpcy5zdGFydE5vZGUoKSxzPXRoaXMubWF0Y2gobi5pbmNEZWMpO2lmKGUub3BlcmF0b3I9dGhpcy5zdGF0ZS52YWx1ZSxlLnByZWZpeD0hMCxcInRocm93XCI9PT1lLm9wZXJhdG9yJiZ0aGlzLmV4cGVjdFBsdWdpbihcInRocm93RXhwcmVzc2lvbnNcIiksdGhpcy5uZXh0KCksZS5hcmd1bWVudD10aGlzLnBhcnNlTWF5YmVVbmFyeSgpLHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHQsITApLHMpdGhpcy5jaGVja0xWYWwoZS5hcmd1bWVudCx2b2lkIDAsdm9pZCAwLFwicHJlZml4IG9wZXJhdGlvblwiKTtlbHNlIGlmKHRoaXMuc3RhdGUuc3RyaWN0JiZcImRlbGV0ZVwiPT09ZS5vcGVyYXRvcil7Y29uc3QgdD1lLmFyZ3VtZW50O1wiSWRlbnRpZmllclwiPT09dC50eXBlP3RoaXMucmFpc2UoZS5zdGFydCxmLlN0cmljdERlbGV0ZSk6XCJNZW1iZXJFeHByZXNzaW9uXCI9PT10LnR5cGUmJlwiUHJpdmF0ZU5hbWVcIj09PXQucHJvcGVydHkudHlwZSYmdGhpcy5yYWlzZShlLnN0YXJ0LGYuRGVsZXRlUHJpdmF0ZUZpZWxkKX1yZXR1cm4gdGhpcy5maW5pc2hOb2RlKGUscz9cIlVwZGF0ZUV4cHJlc3Npb25cIjpcIlVuYXJ5RXhwcmVzc2lvblwiKX1jb25zdCBlPXRoaXMuc3RhdGUuc3RhcnQscz10aGlzLnN0YXRlLnN0YXJ0TG9jO2xldCBpPXRoaXMucGFyc2VFeHByU3Vic2NyaXB0cyh0KTtpZih0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyh0LCExKSlyZXR1cm4gaTtmb3IoO3RoaXMuc3RhdGUudHlwZS5wb3N0Zml4JiYhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTspe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGVBdChlLHMpO3Qub3BlcmF0b3I9dGhpcy5zdGF0ZS52YWx1ZSx0LnByZWZpeD0hMSx0LmFyZ3VtZW50PWksdGhpcy5jaGVja0xWYWwoaSx2b2lkIDAsdm9pZCAwLFwicG9zdGZpeCBvcGVyYXRpb25cIiksdGhpcy5uZXh0KCksaT10aGlzLmZpbmlzaE5vZGUodCxcIlVwZGF0ZUV4cHJlc3Npb25cIil9cmV0dXJuIGl9cGFyc2VFeHByU3Vic2NyaXB0cyh0KXtjb25zdCBlPXRoaXMuc3RhdGUuc3RhcnQscz10aGlzLnN0YXRlLnN0YXJ0TG9jLGk9dGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0LHI9dGhpcy5wYXJzZUV4cHJBdG9tKHQpO3JldHVyblwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIj09PXIudHlwZSYmci5zdGFydD09PWk/cjp0aGlzLnBhcnNlU3Vic2NyaXB0cyhyLGUscyl9cGFyc2VTdWJzY3JpcHRzKHQsZSxzLGkpe2NvbnN0IHI9e29wdGlvbmFsQ2hhaW5NZW1iZXI6ITEsbWF5YmVBc3luY0Fycm93OnRoaXMuYXRQb3NzaWJsZUFzeW5jQXJyb3codCksc3RvcDohMX07ZG97Y29uc3QgYT10aGlzLnN0YXRlLm1heWJlSW5Bc3luY0Fycm93SGVhZDtyLm1heWJlQXN5bmNBcnJvdyYmKHRoaXMuc3RhdGUubWF5YmVJbkFzeW5jQXJyb3dIZWFkPSEwKSx0PXRoaXMucGFyc2VTdWJzY3JpcHQodCxlLHMsaSxyKSxyLm1heWJlQXN5bmNBcnJvdz0hMSx0aGlzLnN0YXRlLm1heWJlSW5Bc3luY0Fycm93SGVhZD1hfXdoaWxlKCFyLnN0b3ApO3JldHVybiB0fXBhcnNlU3Vic2NyaXB0KHQsZSxzLGkscil7aWYoIWkmJnRoaXMuZWF0KG4uZG91YmxlQ29sb24pKXtjb25zdCBhPXRoaXMuc3RhcnROb2RlQXQoZSxzKTtyZXR1cm4gYS5vYmplY3Q9dCxhLmNhbGxlZT10aGlzLnBhcnNlTm9DYWxsRXhwcigpLHIuc3RvcD0hMCx0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLmZpbmlzaE5vZGUoYSxcIkJpbmRFeHByZXNzaW9uXCIpLGUscyxpKX1sZXQgYT0hMTtpZih0aGlzLm1hdGNoKG4ucXVlc3Rpb25Eb3QpKXtpZihyLm9wdGlvbmFsQ2hhaW5NZW1iZXI9YT0hMCxpJiY0MD09PXRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSlyZXR1cm4gci5zdG9wPSEwLHQ7dGhpcy5uZXh0KCl9Y29uc3Qgbz10aGlzLmVhdChuLmJyYWNrZXRMKTtpZihhJiYhdGhpcy5tYXRjaChuLnBhcmVuTCkmJiF0aGlzLm1hdGNoKG4uYmFja1F1b3RlKXx8b3x8dGhpcy5lYXQobi5kb3QpKXtjb25zdCBpPXRoaXMuc3RhcnROb2RlQXQoZSxzKTtyZXR1cm4gaS5vYmplY3Q9dCxpLnByb3BlcnR5PW8/dGhpcy5wYXJzZUV4cHJlc3Npb24oKTphP3RoaXMucGFyc2VJZGVudGlmaWVyKCEwKTp0aGlzLnBhcnNlTWF5YmVQcml2YXRlTmFtZSghMCksaS5jb21wdXRlZD1vLFwiUHJpdmF0ZU5hbWVcIj09PWkucHJvcGVydHkudHlwZSYmKFwiU3VwZXJcIj09PWkub2JqZWN0LnR5cGUmJnRoaXMucmFpc2UoZSxmLlN1cGVyUHJpdmF0ZUZpZWxkKSx0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUoaS5wcm9wZXJ0eS5pZC5uYW1lLGkucHJvcGVydHkuc3RhcnQpKSxvJiZ0aGlzLmV4cGVjdChuLmJyYWNrZXRSKSxyLm9wdGlvbmFsQ2hhaW5NZW1iZXI/KGkub3B0aW9uYWw9YSx0aGlzLmZpbmlzaE5vZGUoaSxcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSk6dGhpcy5maW5pc2hOb2RlKGksXCJNZW1iZXJFeHByZXNzaW9uXCIpfWlmKCFpJiZ0aGlzLm1hdGNoKG4ucGFyZW5MKSl7Y29uc3QgaT10aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMsbz10aGlzLnN0YXRlLnlpZWxkUG9zLGg9dGhpcy5zdGF0ZS5hd2FpdFBvczt0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM9ITAsdGhpcy5zdGF0ZS55aWVsZFBvcz0tMSx0aGlzLnN0YXRlLmF3YWl0UG9zPS0xLHRoaXMubmV4dCgpO2xldCBwPXRoaXMuc3RhcnROb2RlQXQoZSxzKTtyZXR1cm4gcC5jYWxsZWU9dCxhPyhwLm9wdGlvbmFsPSEwLHAuYXJndW1lbnRzPXRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyhuLnBhcmVuUiwhMSkpOnAuYXJndW1lbnRzPXRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyhuLnBhcmVuUixyLm1heWJlQXN5bmNBcnJvdyxcIkltcG9ydFwiPT09dC50eXBlLFwiU3VwZXJcIiE9PXQudHlwZSxwKSx0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKHAsci5vcHRpb25hbENoYWluTWVtYmVyKSxyLm1heWJlQXN5bmNBcnJvdyYmdGhpcy5zaG91bGRQYXJzZUFzeW5jQXJyb3coKSYmIWE/KHIuc3RvcD0hMCxwPXRoaXMucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoZSxzKSxwKSx0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpLHRoaXMuc3RhdGUueWllbGRQb3M9byx0aGlzLnN0YXRlLmF3YWl0UG9zPWgpOih0aGlzLnRvUmVmZXJlbmNlZExpc3REZWVwKHAuYXJndW1lbnRzKSwtMSE9PW8mJih0aGlzLnN0YXRlLnlpZWxkUG9zPW8pLCh0aGlzLmlzQXdhaXRBbGxvd2VkKCl8fGkpJiYtMT09PWh8fCh0aGlzLnN0YXRlLmF3YWl0UG9zPWgpKSx0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM9aSxwfXJldHVybiB0aGlzLm1hdGNoKG4uYmFja1F1b3RlKT90aGlzLnBhcnNlVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGUscyx0LHIpOihyLnN0b3A9ITAsdCl9cGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24odCxlLHMsaSxyKXtjb25zdCBhPXRoaXMuc3RhcnROb2RlQXQodCxlKTtyZXR1cm4gYS50YWc9cyxhLnF1YXNpPXRoaXMucGFyc2VUZW1wbGF0ZSghMCksciYmKGEudHlwZVBhcmFtZXRlcnM9ciksaS5vcHRpb25hbENoYWluTWVtYmVyJiZ0aGlzLnJhaXNlKHQsZi5PcHRpb25hbENoYWluaW5nTm9UZW1wbGF0ZSksdGhpcy5maW5pc2hOb2RlKGEsXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIil9YXRQb3NzaWJsZUFzeW5jQXJyb3codCl7cmV0dXJuXCJJZGVudGlmaWVyXCI9PT10LnR5cGUmJlwiYXN5bmNcIj09PXQubmFtZSYmdGhpcy5zdGF0ZS5sYXN0VG9rRW5kPT09dC5lbmQmJiF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpJiZ0LmVuZC10LnN0YXJ0PT01JiZ0LnN0YXJ0PT09dGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0fWZpbmlzaENhbGxFeHByZXNzaW9uKHQsZSl7aWYoXCJJbXBvcnRcIj09PXQuY2FsbGVlLnR5cGUpaWYoMSE9PXQuYXJndW1lbnRzLmxlbmd0aCl0aGlzLnJhaXNlKHQuc3RhcnQsZi5JbXBvcnRDYWxsQXJpdHkpO2Vsc2V7Y29uc3QgZT10LmFyZ3VtZW50c1swXTtlJiZcIlNwcmVhZEVsZW1lbnRcIj09PWUudHlwZSYmdGhpcy5yYWlzZShlLnN0YXJ0LGYuSW1wb3J0Q2FsbFNwcmVhZEFyZ3VtZW50KX1yZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsZT9cIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcIkNhbGxFeHByZXNzaW9uXCIpfXBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHModCxlLHMsaSxyKXtjb25zdCBhPVtdO2xldCBvLGg9ITA7Y29uc3QgcD10aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O2Zvcih0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5PSExOyF0aGlzLmVhdCh0KTspe2lmKGgpaD0hMTtlbHNlIGlmKHRoaXMuZXhwZWN0KG4uY29tbWEpLHRoaXMubWF0Y2godCkpe3MmJnRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsZi5JbXBvcnRDYWxsQXJndW1lbnRUcmFpbGluZ0NvbW1hKSxyJiZ0aGlzLmFkZEV4dHJhKHIsXCJ0cmFpbGluZ0NvbW1hXCIsdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQpLHRoaXMubmV4dCgpO2JyZWFrfXRoaXMubWF0Y2gobi5wYXJlbkwpJiYhbyYmKG89dGhpcy5zdGF0ZS5zdGFydCksYS5wdXNoKHRoaXMucGFyc2VFeHByTGlzdEl0ZW0oITEsZT9uZXcgeHQ6dm9pZCAwLGU/e3N0YXJ0OjB9OnZvaWQgMCxpKSl9cmV0dXJuIGUmJm8mJnRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkmJnRoaXMudW5leHBlY3RlZCgpLHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk9cCxhfXNob3VsZFBhcnNlQXN5bmNBcnJvdygpe3JldHVybiB0aGlzLm1hdGNoKG4uYXJyb3cpJiYhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKX1wYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24odCxlKXt2YXIgcztyZXR1cm4gdGhpcy5leHBlY3Qobi5hcnJvdyksdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0LGUuYXJndW1lbnRzLCEwLG51bGw9PShzPWUuZXh0cmEpP3ZvaWQgMDpzLnRyYWlsaW5nQ29tbWEpLHR9cGFyc2VOb0NhbGxFeHByKCl7Y29uc3QgdD10aGlzLnN0YXRlLnN0YXJ0LGU9dGhpcy5zdGF0ZS5zdGFydExvYztyZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksdCxlLCEwKX1wYXJzZUV4cHJBdG9tKHQpe3RoaXMuc3RhdGUudHlwZT09PW4uc2xhc2gmJnRoaXMucmVhZFJlZ2V4cCgpO2NvbnN0IGU9dGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0PT09dGhpcy5zdGF0ZS5zdGFydDtsZXQgcztzd2l0Y2godGhpcy5zdGF0ZS50eXBlKXtjYXNlIG4uX3N1cGVyOnJldHVybiBzPXRoaXMuc3RhcnROb2RlKCksdGhpcy5uZXh0KCksIXRoaXMubWF0Y2gobi5wYXJlbkwpfHx0aGlzLnNjb3BlLmFsbG93RGlyZWN0U3VwZXJ8fHRoaXMub3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZD90aGlzLnNjb3BlLmFsbG93U3VwZXJ8fHRoaXMub3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZHx8dGhpcy5yYWlzZShzLnN0YXJ0LGYuVW5leHBlY3RlZFN1cGVyKTp0aGlzLnJhaXNlKHMuc3RhcnQsZi5TdXBlck5vdEFsbG93ZWQpLHRoaXMubWF0Y2gobi5wYXJlbkwpfHx0aGlzLm1hdGNoKG4uYnJhY2tldEwpfHx0aGlzLm1hdGNoKG4uZG90KXx8dGhpcy5yYWlzZShzLnN0YXJ0LGYuVW5zdXBwb3J0ZWRTdXBlciksdGhpcy5maW5pc2hOb2RlKHMsXCJTdXBlclwiKTtjYXNlIG4uX2ltcG9ydDpyZXR1cm4gcz10aGlzLnN0YXJ0Tm9kZSgpLHRoaXMubmV4dCgpLHRoaXMubWF0Y2gobi5kb3QpP3RoaXMucGFyc2VJbXBvcnRNZXRhUHJvcGVydHkocyk6KHRoaXMubWF0Y2gobi5wYXJlbkwpfHx0aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0LGYuVW5zdXBwb3J0ZWRJbXBvcnQpLHRoaXMuZmluaXNoTm9kZShzLFwiSW1wb3J0XCIpKTtjYXNlIG4uX3RoaXM6cmV0dXJuIHM9dGhpcy5zdGFydE5vZGUoKSx0aGlzLm5leHQoKSx0aGlzLmZpbmlzaE5vZGUocyxcIlRoaXNFeHByZXNzaW9uXCIpO2Nhc2Ugbi5uYW1lOntzPXRoaXMuc3RhcnROb2RlKCk7Y29uc3QgdD10aGlzLnN0YXRlLmNvbnRhaW5zRXNjLGk9dGhpcy5wYXJzZUlkZW50aWZpZXIoKTtpZighdCYmXCJhc3luY1wiPT09aS5uYW1lJiZ0aGlzLm1hdGNoKG4uX2Z1bmN0aW9uKSYmIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5jb250ZXh0Lmxlbmd0aC0xO2lmKHRoaXMuc3RhdGUuY29udGV4dFt0XSE9PXguZnVuY3Rpb25TdGF0ZW1lbnQpdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgZXJyb3JcIik7cmV0dXJuIHRoaXMuc3RhdGUuY29udGV4dFt0XT14LmZ1bmN0aW9uRXhwcmVzc2lvbix0aGlzLm5leHQoKSx0aGlzLnBhcnNlRnVuY3Rpb24ocyx2b2lkIDAsITApfWlmKGUmJiF0JiZcImFzeW5jXCI9PT1pLm5hbWUmJnRoaXMubWF0Y2gobi5uYW1lKSYmIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzLGU9dGhpcy5zdGF0ZS5tYXliZUluQXN5bmNBcnJvd0hlYWQsaT10aGlzLnN0YXRlLnlpZWxkUG9zLHI9dGhpcy5zdGF0ZS5hd2FpdFBvczt0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM9ITAsdGhpcy5zdGF0ZS5tYXliZUluQXN5bmNBcnJvd0hlYWQ9ITAsdGhpcy5zdGF0ZS55aWVsZFBvcz0tMSx0aGlzLnN0YXRlLmF3YWl0UG9zPS0xO2NvbnN0IGE9W3RoaXMucGFyc2VJZGVudGlmaWVyKCldO3JldHVybiB0aGlzLmV4cGVjdChuLmFycm93KSx0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpLHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycz10LHRoaXMuc3RhdGUubWF5YmVJbkFzeW5jQXJyb3dIZWFkPWUsdGhpcy5zdGF0ZS55aWVsZFBvcz1pLHRoaXMuc3RhdGUuYXdhaXRQb3M9cix0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHMsYSwhMCksc31yZXR1cm4gZSYmdGhpcy5tYXRjaChuLmFycm93KSYmIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk/KHRoaXMubmV4dCgpLHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24ocyxbaV0sITEpLHMpOml9Y2FzZSBuLl9kbzp7dGhpcy5leHBlY3RQbHVnaW4oXCJkb0V4cHJlc3Npb25zXCIpO2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTt0aGlzLm5leHQoKTtjb25zdCBlPXRoaXMuc3RhdGUubGFiZWxzO3JldHVybiB0aGlzLnN0YXRlLmxhYmVscz1bXSx0LmJvZHk9dGhpcy5wYXJzZUJsb2NrKCksdGhpcy5zdGF0ZS5sYWJlbHM9ZSx0aGlzLmZpbmlzaE5vZGUodCxcIkRvRXhwcmVzc2lvblwiKX1jYXNlIG4ucmVnZXhwOntjb25zdCB0PXRoaXMuc3RhdGUudmFsdWU7cmV0dXJuIHM9dGhpcy5wYXJzZUxpdGVyYWwodC52YWx1ZSxcIlJlZ0V4cExpdGVyYWxcIikscy5wYXR0ZXJuPXQucGF0dGVybixzLmZsYWdzPXQuZmxhZ3Msc31jYXNlIG4ubnVtOnJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLFwiTnVtZXJpY0xpdGVyYWxcIik7Y2FzZSBuLmJpZ2ludDpyZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSxcIkJpZ0ludExpdGVyYWxcIik7Y2FzZSBuLnN0cmluZzpyZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSxcIlN0cmluZ0xpdGVyYWxcIik7Y2FzZSBuLl9udWxsOnJldHVybiBzPXRoaXMuc3RhcnROb2RlKCksdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKHMsXCJOdWxsTGl0ZXJhbFwiKTtjYXNlIG4uX3RydWU6Y2FzZSBuLl9mYWxzZTpyZXR1cm4gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKCk7Y2FzZSBuLnBhcmVuTDpyZXR1cm4gdGhpcy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGUpO2Nhc2Ugbi5icmFja2V0QmFyTDpjYXNlIG4uYnJhY2tldEhhc2hMOnt0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO2NvbnN0IGU9dGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSxpPXRoaXMuc3RhdGUudHlwZT09PW4uYnJhY2tldEJhckw/bi5icmFja2V0QmFyUjpuLmJyYWNrZXRSO3JldHVybiB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5PSExLHM9dGhpcy5zdGFydE5vZGUoKSx0aGlzLm5leHQoKSxzLmVsZW1lbnRzPXRoaXMucGFyc2VFeHByTGlzdChpLCEwLHQscyksdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keT1lLHRoaXMuZmluaXNoTm9kZShzLFwiVHVwbGVFeHByZXNzaW9uXCIpfWNhc2Ugbi5icmFja2V0TDp7Y29uc3QgZT10aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O3JldHVybiB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5PSExLHM9dGhpcy5zdGFydE5vZGUoKSx0aGlzLm5leHQoKSxzLmVsZW1lbnRzPXRoaXMucGFyc2VFeHByTGlzdChuLmJyYWNrZXRSLCEwLHQscyksdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzfHx0aGlzLnRvUmVmZXJlbmNlZExpc3Qocy5lbGVtZW50cyksdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keT1lLHRoaXMuZmluaXNoTm9kZShzLFwiQXJyYXlFeHByZXNzaW9uXCIpfWNhc2Ugbi5icmFjZUJhckw6Y2FzZSBuLmJyYWNlSGFzaEw6e3RoaXMuZXhwZWN0UGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIik7Y29uc3QgZT10aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5LHM9dGhpcy5zdGF0ZS50eXBlPT09bi5icmFjZUJhckw/bi5icmFjZUJhclI6bi5icmFjZVI7dGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keT0hMTtjb25zdCBpPXRoaXMucGFyc2VPYmoocywhMSwhMCx0KTtyZXR1cm4gdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keT1lLGl9Y2FzZSBuLmJyYWNlTDp7Y29uc3QgZT10aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O3RoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk9ITE7Y29uc3Qgcz10aGlzLnBhcnNlT2JqKG4uYnJhY2VSLCExLCExLHQpO3JldHVybiB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5PWUsc31jYXNlIG4uX2Z1bmN0aW9uOnJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25FeHByZXNzaW9uKCk7Y2FzZSBuLmF0OnRoaXMucGFyc2VEZWNvcmF0b3JzKCk7Y2FzZSBuLl9jbGFzczpyZXR1cm4gcz10aGlzLnN0YXJ0Tm9kZSgpLHRoaXMudGFrZURlY29yYXRvcnMocyksdGhpcy5wYXJzZUNsYXNzKHMsITEpO2Nhc2Ugbi5fbmV3OnJldHVybiB0aGlzLnBhcnNlTmV3KCk7Y2FzZSBuLmJhY2tRdW90ZTpyZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKCExKTtjYXNlIG4uZG91YmxlQ29sb246e3M9dGhpcy5zdGFydE5vZGUoKSx0aGlzLm5leHQoKSxzLm9iamVjdD1udWxsO2NvbnN0IHQ9cy5jYWxsZWU9dGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtpZihcIk1lbWJlckV4cHJlc3Npb25cIj09PXQudHlwZSlyZXR1cm4gdGhpcy5maW5pc2hOb2RlKHMsXCJCaW5kRXhwcmVzc2lvblwiKTt0aHJvdyB0aGlzLnJhaXNlKHQuc3RhcnQsZi5VbnN1cHBvcnRlZEJpbmQpfWNhc2Ugbi5oYXNoOmlmKHRoaXMuc3RhdGUuaW5QaXBlbGluZSlyZXR1cm4gcz10aGlzLnN0YXJ0Tm9kZSgpLFwic21hcnRcIiE9PXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLFwicHJvcG9zYWxcIikmJnRoaXMucmFpc2Uocy5zdGFydCxmLlByaW1hcnlUb3BpY1JlcXVpcmVzU21hcnRQaXBlbGluZSksdGhpcy5uZXh0KCksdGhpcy5wcmltYXJ5VG9waWNSZWZlcmVuY2VJc0FsbG93ZWRJbkN1cnJlbnRUb3BpY0NvbnRleHQoKXx8dGhpcy5yYWlzZShzLnN0YXJ0LGYuUHJpbWFyeVRvcGljTm90QWxsb3dlZCksdGhpcy5yZWdpc3RlclRvcGljUmVmZXJlbmNlKCksdGhpcy5maW5pc2hOb2RlKHMsXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiKTtkZWZhdWx0OnRocm93IHRoaXMudW5leHBlY3RlZCgpfX1wYXJzZUJvb2xlYW5MaXRlcmFsKCl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0LnZhbHVlPXRoaXMubWF0Y2gobi5fdHJ1ZSksdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKHQsXCJCb29sZWFuTGl0ZXJhbFwiKX1wYXJzZU1heWJlUHJpdmF0ZU5hbWUodCl7aWYodGhpcy5tYXRjaChuLmhhc2gpKXt0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJjbGFzc1ByaXZhdGVQcm9wZXJ0aWVzXCIsXCJjbGFzc1ByaXZhdGVNZXRob2RzXCJdKSx0fHx0aGlzLnJhaXNlKHRoaXMuc3RhdGUucG9zLGYuVW5leHBlY3RlZFByaXZhdGVGaWVsZCk7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSx0aGlzLmFzc2VydE5vU3BhY2UoXCJVbmV4cGVjdGVkIHNwYWNlIGJldHdlZW4gIyBhbmQgaWRlbnRpZmllclwiKSxlLmlkPXRoaXMucGFyc2VJZGVudGlmaWVyKCEwKSx0aGlzLmZpbmlzaE5vZGUoZSxcIlByaXZhdGVOYW1lXCIpfXJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcighMCl9cGFyc2VGdW5jdGlvbkV4cHJlc3Npb24oKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7bGV0IGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksZT10aGlzLmNyZWF0ZUlkZW50aWZpZXIoZSxcImZ1bmN0aW9uXCIpLHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkJiZ0aGlzLmVhdChuLmRvdCk/dGhpcy5wYXJzZU1ldGFQcm9wZXJ0eSh0LGUsXCJzZW50XCIpOnRoaXMucGFyc2VGdW5jdGlvbih0KX1wYXJzZU1ldGFQcm9wZXJ0eSh0LGUscyl7dC5tZXRhPWUsXCJmdW5jdGlvblwiPT09ZS5uYW1lJiZcInNlbnRcIj09PXMmJih0aGlzLmlzQ29udGV4dHVhbChzKT90aGlzLmV4cGVjdFBsdWdpbihcImZ1bmN0aW9uU2VudFwiKTp0aGlzLmhhc1BsdWdpbihcImZ1bmN0aW9uU2VudFwiKXx8dGhpcy51bmV4cGVjdGVkKCkpO2NvbnN0IGk9dGhpcy5zdGF0ZS5jb250YWluc0VzYztyZXR1cm4gdC5wcm9wZXJ0eT10aGlzLnBhcnNlSWRlbnRpZmllcighMCksKHQucHJvcGVydHkubmFtZSE9PXN8fGkpJiZ0aGlzLnJhaXNlKHQucHJvcGVydHkuc3RhcnQsZi5VbnN1cHBvcnRlZE1ldGFQcm9wZXJ0eSxlLm5hbWUscyksdGhpcy5maW5pc2hOb2RlKHQsXCJNZXRhUHJvcGVydHlcIil9cGFyc2VJbXBvcnRNZXRhUHJvcGVydHkodCl7Y29uc3QgZT10aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdE5vZGUodCksXCJpbXBvcnRcIik7cmV0dXJuIHRoaXMuZXhwZWN0KG4uZG90KSx0aGlzLmlzQ29udGV4dHVhbChcIm1ldGFcIik/KHRoaXMuZXhwZWN0UGx1Z2luKFwiaW1wb3J0TWV0YVwiKSx0aGlzLmluTW9kdWxlfHx0aGlzLnJhaXNlV2l0aERhdGEoZS5zdGFydCx7Y29kZTpcIkJBQkVMX1BBUlNFUl9TT1VSQ0VUWVBFX01PRFVMRV9SRVFVSVJFRFwifSxmLkltcG9ydE1ldGFPdXRzaWRlTW9kdWxlKSx0aGlzLnNhd1VuYW1iaWd1b3VzRVNNPSEwKTp0aGlzLmhhc1BsdWdpbihcImltcG9ydE1ldGFcIil8fHRoaXMucmFpc2UoZS5zdGFydCxmLkltcG9ydENhbGxBcml0eUx0T25lKSx0aGlzLnBhcnNlTWV0YVByb3BlcnR5KHQsZSxcIm1ldGFcIil9cGFyc2VMaXRlcmFsKHQsZSxzLGkpe3M9c3x8dGhpcy5zdGF0ZS5zdGFydCxpPWl8fHRoaXMuc3RhdGUuc3RhcnRMb2M7Y29uc3Qgcj10aGlzLnN0YXJ0Tm9kZUF0KHMsaSk7cmV0dXJuIHRoaXMuYWRkRXh0cmEocixcInJhd1ZhbHVlXCIsdCksdGhpcy5hZGRFeHRyYShyLFwicmF3XCIsdGhpcy5pbnB1dC5zbGljZShzLHRoaXMuc3RhdGUuZW5kKSksci52YWx1ZT10LHRoaXMubmV4dCgpLHRoaXMuZmluaXNoTm9kZShyLGUpfXBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24odCl7Y29uc3QgZT10aGlzLnN0YXRlLnN0YXJ0LHM9dGhpcy5zdGF0ZS5zdGFydExvYztsZXQgaTt0aGlzLmV4cGVjdChuLnBhcmVuTCk7Y29uc3Qgcj10aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMsYT10aGlzLnN0YXRlLnlpZWxkUG9zLG89dGhpcy5zdGF0ZS5hd2FpdFBvcyxoPXRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7dGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzPSEwLHRoaXMuc3RhdGUueWllbGRQb3M9LTEsdGhpcy5zdGF0ZS5hd2FpdFBvcz0tMSx0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5PSExO2NvbnN0IHA9dGhpcy5zdGF0ZS5zdGFydCxjPXRoaXMuc3RhdGUuc3RhcnRMb2MsdT1bXSxsPW5ldyB4dCxkPXtzdGFydDowfTtsZXQgbSxmLEQ9ITA7Zm9yKDshdGhpcy5tYXRjaChuLnBhcmVuUik7KXtpZihEKUQ9ITE7ZWxzZSBpZih0aGlzLmV4cGVjdChuLmNvbW1hLGQuc3RhcnR8fG51bGwpLHRoaXMubWF0Y2gobi5wYXJlblIpKXtmPXRoaXMuc3RhdGUuc3RhcnQ7YnJlYWt9aWYodGhpcy5tYXRjaChuLmVsbGlwc2lzKSl7Y29uc3QgdD10aGlzLnN0YXRlLnN0YXJ0LGU9dGhpcy5zdGF0ZS5zdGFydExvYzttPXRoaXMuc3RhdGUuc3RhcnQsdS5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCksdCxlKSksdGhpcy5jaGVja0NvbW1hQWZ0ZXJSZXN0KDQxKTticmVha311LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKCExLGwsdGhpcy5wYXJzZVBhcmVuSXRlbSxkKSl9Y29uc3QgeT10aGlzLnN0YXRlLnN0YXJ0LHg9dGhpcy5zdGF0ZS5zdGFydExvYzt0aGlzLmV4cGVjdChuLnBhcmVuUiksdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzPXIsdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keT1oO2xldCBnPXRoaXMuc3RhcnROb2RlQXQoZSxzKTtpZih0JiZ0aGlzLnNob3VsZFBhcnNlQXJyb3coKSYmKGc9dGhpcy5wYXJzZUFycm93KGcpKSl7dGhpcy5pc0F3YWl0QWxsb3dlZCgpfHx0aGlzLnN0YXRlLm1heWJlSW5Bc3luY0Fycm93SGVhZHx8KHRoaXMuc3RhdGUuYXdhaXRQb3M9byksdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKSx0aGlzLnN0YXRlLnlpZWxkUG9zPWEsdGhpcy5zdGF0ZS5hd2FpdFBvcz1vO2ZvcihsZXQgdD0wO3Q8dS5sZW5ndGg7dCsrKXtjb25zdCBlPXVbdF07ZS5leHRyYSYmZS5leHRyYS5wYXJlbnRoZXNpemVkJiZ0aGlzLnVuZXhwZWN0ZWQoZS5leHRyYS5wYXJlblN0YXJ0KX1yZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihnLHUsITEpLGd9aWYoLTEhPT1hJiYodGhpcy5zdGF0ZS55aWVsZFBvcz1hKSwtMSE9PW8mJih0aGlzLnN0YXRlLmF3YWl0UG9zPW8pLHUubGVuZ3RofHx0aGlzLnVuZXhwZWN0ZWQodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQpLGYmJnRoaXMudW5leHBlY3RlZChmKSxtJiZ0aGlzLnVuZXhwZWN0ZWQobSksdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMobCwhMCksZC5zdGFydCYmdGhpcy51bmV4cGVjdGVkKGQuc3RhcnQpLHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAodSwhMCksdS5sZW5ndGg+MT8oaT10aGlzLnN0YXJ0Tm9kZUF0KHAsYyksaS5leHByZXNzaW9ucz11LHRoaXMuZmluaXNoTm9kZUF0KGksXCJTZXF1ZW5jZUV4cHJlc3Npb25cIix5LHgpKTppPXVbMF0sIXRoaXMub3B0aW9ucy5jcmVhdGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbnMpcmV0dXJuIHRoaXMuYWRkRXh0cmEoaSxcInBhcmVudGhlc2l6ZWRcIiwhMCksdGhpcy5hZGRFeHRyYShpLFwicGFyZW5TdGFydFwiLGUpLGk7Y29uc3QgUD10aGlzLnN0YXJ0Tm9kZUF0KGUscyk7cmV0dXJuIFAuZXhwcmVzc2lvbj1pLHRoaXMuZmluaXNoTm9kZShQLFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiksUH1zaG91bGRQYXJzZUFycm93KCl7cmV0dXJuIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCl9cGFyc2VBcnJvdyh0KXtpZih0aGlzLmVhdChuLmFycm93KSlyZXR1cm4gdH1wYXJzZVBhcmVuSXRlbSh0LGUscyl7cmV0dXJuIHR9cGFyc2VOZXcoKXtjb25zdCB0PXRoaXMuc3RhcnROb2RlKCk7bGV0IGU9dGhpcy5zdGFydE5vZGUoKTtpZih0aGlzLm5leHQoKSxlPXRoaXMuY3JlYXRlSWRlbnRpZmllcihlLFwibmV3XCIpLHRoaXMuZWF0KG4uZG90KSl7Y29uc3Qgcz10aGlzLnBhcnNlTWV0YVByb3BlcnR5KHQsZSxcInRhcmdldFwiKTtpZighdGhpcy5zY29wZS5pbk5vbkFycm93RnVuY3Rpb24mJiF0aGlzLnNjb3BlLmluQ2xhc3Mpe2xldCB0PWYuVW5leHBlY3RlZE5ld1RhcmdldDt0aGlzLmhhc1BsdWdpbihcImNsYXNzUHJvcGVydGllc1wiKSYmKHQrPVwiIG9yIGNsYXNzIHByb3BlcnRpZXNcIiksdGhpcy5yYWlzZShzLnN0YXJ0LHQpfXJldHVybiBzfXJldHVybiB0LmNhbGxlZT10aGlzLnBhcnNlTm9DYWxsRXhwcigpLFwiSW1wb3J0XCI9PT10LmNhbGxlZS50eXBlP3RoaXMucmFpc2UodC5jYWxsZWUuc3RhcnQsZi5JbXBvcnRDYWxsTm90TmV3RXhwcmVzc2lvbik6XCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIj09PXQuY2FsbGVlLnR5cGV8fFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiPT09dC5jYWxsZWUudHlwZT90aGlzLnJhaXNlKHRoaXMuc3RhdGUubGFzdFRva0VuZCxmLk9wdGlvbmFsQ2hhaW5pbmdOb05ldyk6dGhpcy5lYXQobi5xdWVzdGlvbkRvdCkmJnRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxmLk9wdGlvbmFsQ2hhaW5pbmdOb05ldyksdGhpcy5wYXJzZU5ld0FyZ3VtZW50cyh0KSx0aGlzLmZpbmlzaE5vZGUodCxcIk5ld0V4cHJlc3Npb25cIil9cGFyc2VOZXdBcmd1bWVudHModCl7aWYodGhpcy5lYXQobi5wYXJlbkwpKXtjb25zdCBlPXRoaXMucGFyc2VFeHByTGlzdChuLnBhcmVuUik7dGhpcy50b1JlZmVyZW5jZWRMaXN0KGUpLHQuYXJndW1lbnRzPWV9ZWxzZSB0LmFyZ3VtZW50cz1bXX1wYXJzZVRlbXBsYXRlRWxlbWVudCh0KXtjb25zdCBlPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIG51bGw9PT10aGlzLnN0YXRlLnZhbHVlJiYodHx8dGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0KzEsZi5JbnZhbGlkRXNjYXBlU2VxdWVuY2VUZW1wbGF0ZSkpLGUudmFsdWU9e3Jhdzp0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhdGUuc3RhcnQsdGhpcy5zdGF0ZS5lbmQpLnJlcGxhY2UoL1xcclxcbj8vZyxcIlxcblwiKSxjb29rZWQ6dGhpcy5zdGF0ZS52YWx1ZX0sdGhpcy5uZXh0KCksZS50YWlsPXRoaXMubWF0Y2gobi5iYWNrUXVvdGUpLHRoaXMuZmluaXNoTm9kZShlLFwiVGVtcGxhdGVFbGVtZW50XCIpfXBhcnNlVGVtcGxhdGUodCl7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpO3RoaXMubmV4dCgpLGUuZXhwcmVzc2lvbnM9W107bGV0IHM9dGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh0KTtmb3IoZS5xdWFzaXM9W3NdOyFzLnRhaWw7KXRoaXMuZXhwZWN0KG4uZG9sbGFyQnJhY2VMKSxlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSksdGhpcy5leHBlY3Qobi5icmFjZVIpLGUucXVhc2lzLnB1c2gocz10aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHQpKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKGUsXCJUZW1wbGF0ZUxpdGVyYWxcIil9cGFyc2VPYmoodCxlLHMsaSl7Y29uc3Qgcj1PYmplY3QuY3JlYXRlKG51bGwpO2xldCBhPSEwO2NvbnN0IG89dGhpcy5zdGFydE5vZGUoKTtmb3Ioby5wcm9wZXJ0aWVzPVtdLHRoaXMubmV4dCgpOyF0aGlzLmVhdCh0KTspe2lmKGEpYT0hMTtlbHNlIGlmKHRoaXMuZXhwZWN0KG4uY29tbWEpLHRoaXMubWF0Y2godCkpe3RoaXMuYWRkRXh0cmEobyxcInRyYWlsaW5nQ29tbWFcIix0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCksdGhpcy5uZXh0KCk7YnJlYWt9Y29uc3Qgcz10aGlzLnBhcnNlT2JqZWN0TWVtYmVyKGUsaSk7ZXx8dGhpcy5jaGVja0R1cGxpY2F0ZWRQcm90byhzLHIsaSkscy5zaG9ydGhhbmQmJnRoaXMuYWRkRXh0cmEocyxcInNob3J0aGFuZFwiLCEwKSxvLnByb3BlcnRpZXMucHVzaChzKX1sZXQgaD1cIk9iamVjdEV4cHJlc3Npb25cIjtyZXR1cm4gZT9oPVwiT2JqZWN0UGF0dGVyblwiOnMmJihoPVwiUmVjb3JkRXhwcmVzc2lvblwiKSx0aGlzLmZpbmlzaE5vZGUobyxoKX1pc0FzeW5jUHJvcCh0KXtyZXR1cm4hdC5jb21wdXRlZCYmXCJJZGVudGlmaWVyXCI9PT10LmtleS50eXBlJiZcImFzeW5jXCI9PT10LmtleS5uYW1lJiYodGhpcy5tYXRjaChuLm5hbWUpfHx0aGlzLm1hdGNoKG4ubnVtKXx8dGhpcy5tYXRjaChuLnN0cmluZyl8fHRoaXMubWF0Y2gobi5icmFja2V0TCl8fHRoaXMuc3RhdGUudHlwZS5rZXl3b3JkfHx0aGlzLm1hdGNoKG4uc3RhcikpJiYhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKX1wYXJzZU9iamVjdE1lbWJlcih0LGUpe2xldCBzPVtdO2lmKHRoaXMubWF0Y2gobi5hdCkpZm9yKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSYmdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGYuVW5zdXBwb3J0ZWRQcm9wZXJ0eURlY29yYXRvcik7dGhpcy5tYXRjaChuLmF0KTspcy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7Y29uc3QgaT10aGlzLnN0YXJ0Tm9kZSgpO2xldCByLGEsbz0hMSxoPSExO2lmKHRoaXMubWF0Y2gobi5lbGxpcHNpcykpcmV0dXJuIHMubGVuZ3RoJiZ0aGlzLnVuZXhwZWN0ZWQoKSx0Pyh0aGlzLm5leHQoKSxpLmFyZ3VtZW50PXRoaXMucGFyc2VJZGVudGlmaWVyKCksdGhpcy5jaGVja0NvbW1hQWZ0ZXJSZXN0KDEyNSksdGhpcy5maW5pc2hOb2RlKGksXCJSZXN0RWxlbWVudFwiKSk6dGhpcy5wYXJzZVNwcmVhZCgpO3MubGVuZ3RoJiYoaS5kZWNvcmF0b3JzPXMscz1bXSksaS5tZXRob2Q9ITEsKHR8fGUpJiYocj10aGlzLnN0YXRlLnN0YXJ0LGE9dGhpcy5zdGF0ZS5zdGFydExvYyksdHx8KG89dGhpcy5lYXQobi5zdGFyKSk7Y29uc3QgcD10aGlzLnN0YXRlLmNvbnRhaW5zRXNjO3JldHVybiB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKGksITEpLHR8fHB8fG98fCF0aGlzLmlzQXN5bmNQcm9wKGkpP2g9ITE6KGg9ITAsbz10aGlzLmVhdChuLnN0YXIpLHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUoaSwhMSkpLHRoaXMucGFyc2VPYmpQcm9wVmFsdWUoaSxyLGEsbyxoLHQsZSxwKSxpfWlzR2V0dGVyT3JTZXR0ZXJNZXRob2QodCxlKXtyZXR1cm4hZSYmIXQuY29tcHV0ZWQmJlwiSWRlbnRpZmllclwiPT09dC5rZXkudHlwZSYmKFwiZ2V0XCI9PT10LmtleS5uYW1lfHxcInNldFwiPT09dC5rZXkubmFtZSkmJih0aGlzLm1hdGNoKG4uc3RyaW5nKXx8dGhpcy5tYXRjaChuLm51bSl8fHRoaXMubWF0Y2gobi5icmFja2V0TCl8fHRoaXMubWF0Y2gobi5uYW1lKXx8ISF0aGlzLnN0YXRlLnR5cGUua2V5d29yZCl9Z2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KHQpe3JldHVyblwiZ2V0XCI9PT10LmtpbmQ/MDoxfWNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKHQpe2NvbnN0IGU9dGhpcy5nZXRHZXR0ZXJTZXR0ZXJFeHBlY3RlZFBhcmFtQ291bnQodCkscz10LnN0YXJ0O3QucGFyYW1zLmxlbmd0aCE9PWUmJihcImdldFwiPT09dC5raW5kP3RoaXMucmFpc2UocyxmLkJhZEdldHRlckFyaXR5KTp0aGlzLnJhaXNlKHMsZi5CYWRTZXR0ZXJBcml0eSkpLFwic2V0XCI9PT10LmtpbmQmJlwiUmVzdEVsZW1lbnRcIj09PXQucGFyYW1zW3QucGFyYW1zLmxlbmd0aC0xXS50eXBlJiZ0aGlzLnJhaXNlKHMsZi5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyKX1wYXJzZU9iamVjdE1ldGhvZCh0LGUscyxpLHIpe3JldHVybiBzfHxlfHx0aGlzLm1hdGNoKG4ucGFyZW5MKT8oaSYmdGhpcy51bmV4cGVjdGVkKCksdC5raW5kPVwibWV0aG9kXCIsdC5tZXRob2Q9ITAsdGhpcy5wYXJzZU1ldGhvZCh0LGUscywhMSwhMSxcIk9iamVjdE1ldGhvZFwiKSk6IXImJnRoaXMuaXNHZXR0ZXJPclNldHRlck1ldGhvZCh0LGkpPygoZXx8cykmJnRoaXMudW5leHBlY3RlZCgpLHQua2luZD10LmtleS5uYW1lLHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUodCwhMSksdGhpcy5wYXJzZU1ldGhvZCh0LCExLCExLCExLCExLFwiT2JqZWN0TWV0aG9kXCIpLHRoaXMuY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXModCksdCk6dm9pZCAwfXBhcnNlT2JqZWN0UHJvcGVydHkodCxlLHMsaSxyKXtyZXR1cm4gdC5zaG9ydGhhbmQ9ITEsdGhpcy5lYXQobi5jb2xvbik/KHQudmFsdWU9aT90aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhdGUuc3RhcnQsdGhpcy5zdGF0ZS5zdGFydExvYyk6dGhpcy5wYXJzZU1heWJlQXNzaWduKCExLHIpLHRoaXMuZmluaXNoTm9kZSh0LFwiT2JqZWN0UHJvcGVydHlcIikpOnQuY29tcHV0ZWR8fFwiSWRlbnRpZmllclwiIT09dC5rZXkudHlwZT92b2lkIDA6KHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQodC5rZXkubmFtZSx0LmtleS5zdGFydCwhMCwhMCksaT90LnZhbHVlPXRoaXMucGFyc2VNYXliZURlZmF1bHQoZSxzLHQua2V5Ll9fY2xvbmUoKSk6dGhpcy5tYXRjaChuLmVxKSYmcj8oLTE9PT1yLnNob3J0aGFuZEFzc2lnbiYmKHIuc2hvcnRoYW5kQXNzaWduPXRoaXMuc3RhdGUuc3RhcnQpLHQudmFsdWU9dGhpcy5wYXJzZU1heWJlRGVmYXVsdChlLHMsdC5rZXkuX19jbG9uZSgpKSk6dC52YWx1ZT10LmtleS5fX2Nsb25lKCksdC5zaG9ydGhhbmQ9ITAsdGhpcy5maW5pc2hOb2RlKHQsXCJPYmplY3RQcm9wZXJ0eVwiKSl9cGFyc2VPYmpQcm9wVmFsdWUodCxlLHMsaSxyLGEsbixvKXtjb25zdCBoPXRoaXMucGFyc2VPYmplY3RNZXRob2QodCxpLHIsYSxvKXx8dGhpcy5wYXJzZU9iamVjdFByb3BlcnR5KHQsZSxzLGEsbik7cmV0dXJuIGh8fHRoaXMudW5leHBlY3RlZCgpLGh9cGFyc2VQcm9wZXJ0eU5hbWUodCxlKXtpZih0aGlzLmVhdChuLmJyYWNrZXRMKSl0LmNvbXB1dGVkPSEwLHQua2V5PXRoaXMucGFyc2VNYXliZUFzc2lnbigpLHRoaXMuZXhwZWN0KG4uYnJhY2tldFIpO2Vsc2V7Y29uc3Qgcz10aGlzLnN0YXRlLmluUHJvcGVydHlOYW1lO3RoaXMuc3RhdGUuaW5Qcm9wZXJ0eU5hbWU9ITAsdC5rZXk9dGhpcy5tYXRjaChuLm51bSl8fHRoaXMubWF0Y2gobi5zdHJpbmcpfHx0aGlzLm1hdGNoKG4uYmlnaW50KT90aGlzLnBhcnNlRXhwckF0b20oKTp0aGlzLnBhcnNlTWF5YmVQcml2YXRlTmFtZShlKSxcIlByaXZhdGVOYW1lXCIhPT10LmtleS50eXBlJiYodC5jb21wdXRlZD0hMSksdGhpcy5zdGF0ZS5pblByb3BlcnR5TmFtZT1zfXJldHVybiB0LmtleX1pbml0RnVuY3Rpb24odCxlKXt0LmlkPW51bGwsdC5nZW5lcmF0b3I9ITEsdC5hc3luYz0hIWV9cGFyc2VNZXRob2QodCxlLHMsaSxyLGEsbj0hMSl7Y29uc3Qgbz10aGlzLnN0YXRlLnlpZWxkUG9zLGg9dGhpcy5zdGF0ZS5hd2FpdFBvczt0aGlzLnN0YXRlLnlpZWxkUG9zPS0xLHRoaXMuc3RhdGUuYXdhaXRQb3M9LTEsdGhpcy5pbml0RnVuY3Rpb24odCxzKSx0LmdlbmVyYXRvcj0hIWU7Y29uc3QgcD1pO3JldHVybiB0aGlzLnNjb3BlLmVudGVyKDE4fChuPzY0OjApfChyPzMyOjApKSx0aGlzLnByb2RQYXJhbS5lbnRlcihldChzLHQuZ2VuZXJhdG9yKSksdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKHQscCksdGhpcy5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaCh0LGEsITApLHRoaXMucHJvZFBhcmFtLmV4aXQoKSx0aGlzLnNjb3BlLmV4aXQoKSx0aGlzLnN0YXRlLnlpZWxkUG9zPW8sdGhpcy5zdGF0ZS5hd2FpdFBvcz1oLHR9cGFyc2VBcnJvd0V4cHJlc3Npb24odCxlLHMsaSl7dGhpcy5zY29wZS5lbnRlcig2KSx0aGlzLnByb2RQYXJhbS5lbnRlcihldChzLCExKSksdGhpcy5pbml0RnVuY3Rpb24odCxzKTtjb25zdCByPXRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyxhPXRoaXMuc3RhdGUueWllbGRQb3Msbj10aGlzLnN0YXRlLmF3YWl0UG9zO3JldHVybiBlJiYodGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzPSEwLHRoaXMuc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnModCxlLGkpKSx0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM9ITEsdGhpcy5zdGF0ZS55aWVsZFBvcz0tMSx0aGlzLnN0YXRlLmF3YWl0UG9zPS0xLHRoaXMucGFyc2VGdW5jdGlvbkJvZHkodCwhMCksdGhpcy5wcm9kUGFyYW0uZXhpdCgpLHRoaXMuc2NvcGUuZXhpdCgpLHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycz1yLHRoaXMuc3RhdGUueWllbGRQb3M9YSx0aGlzLnN0YXRlLmF3YWl0UG9zPW4sdGhpcy5maW5pc2hOb2RlKHQsXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKX1zZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyh0LGUscyl7dC5wYXJhbXM9dGhpcy50b0Fzc2lnbmFibGVMaXN0KGUscyl9cGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2godCxlLHM9ITEpe3RoaXMucGFyc2VGdW5jdGlvbkJvZHkodCwhMSxzKSx0aGlzLmZpbmlzaE5vZGUodCxlKX1wYXJzZUZ1bmN0aW9uQm9keSh0LGUscz0hMSl7Y29uc3QgaT1lJiYhdGhpcy5tYXRjaChuLmJyYWNlTCkscj10aGlzLnN0YXRlLmluUGFyYW1ldGVycztpZih0aGlzLnN0YXRlLmluUGFyYW1ldGVycz0hMSxpKXQuYm9keT10aGlzLnBhcnNlTWF5YmVBc3NpZ24oKSx0aGlzLmNoZWNrUGFyYW1zKHQsITEsZSwhMSk7ZWxzZXtjb25zdCBpPXRoaXMuc3RhdGUuc3RyaWN0LHI9dGhpcy5zdGF0ZS5sYWJlbHM7dGhpcy5zdGF0ZS5sYWJlbHM9W10sdGhpcy5wcm9kUGFyYW0uZW50ZXIoNHx0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKSksdC5ib2R5PXRoaXMucGFyc2VCbG9jayghMCwhMSxyPT57Y29uc3QgYT0hdGhpcy5pc1NpbXBsZVBhcmFtTGlzdCh0LnBhcmFtcyk7aWYociYmYSl7Y29uc3QgZT1cIm1ldGhvZFwiIT09dC5raW5kJiZcImNvbnN0cnVjdG9yXCIhPT10LmtpbmR8fCF0LmtleT90LnN0YXJ0OnQua2V5LmVuZDt0aGlzLnJhaXNlKGUsZi5JbGxlZ2FsTGFuZ3VhZ2VNb2RlRGlyZWN0aXZlKX1jb25zdCBuPSFpJiZ0aGlzLnN0YXRlLnN0cmljdDt0aGlzLmNoZWNrUGFyYW1zKHQsISh0aGlzLnN0YXRlLnN0cmljdHx8ZXx8c3x8YSksZSxuKSx0aGlzLnN0YXRlLnN0cmljdCYmdC5pZCYmdGhpcy5jaGVja0xWYWwodC5pZCw2NSx2b2lkIDAsXCJmdW5jdGlvbiBuYW1lXCIsdm9pZCAwLG4pfSksdGhpcy5wcm9kUGFyYW0uZXhpdCgpLHRoaXMuc3RhdGUubGFiZWxzPXJ9dGhpcy5zdGF0ZS5pblBhcmFtZXRlcnM9cn1pc1NpbXBsZVBhcmFtTGlzdCh0KXtmb3IobGV0IGU9MCxzPXQubGVuZ3RoO2U8cztlKyspaWYoXCJJZGVudGlmaWVyXCIhPT10W2VdLnR5cGUpcmV0dXJuITE7cmV0dXJuITB9Y2hlY2tQYXJhbXModCxlLHMsaT0hMCl7Y29uc3Qgcj1PYmplY3QuY3JlYXRlKG51bGwpO2ZvcihsZXQgcz0wO3M8dC5wYXJhbXMubGVuZ3RoO3MrKyl0aGlzLmNoZWNrTFZhbCh0LnBhcmFtc1tzXSw1LGU/bnVsbDpyLFwiZnVuY3Rpb24gcGFyYW1ldGVyIGxpc3RcIix2b2lkIDAsaSl9cGFyc2VFeHByTGlzdCh0LGUscyxpKXtjb25zdCByPVtdO2xldCBhPSEwO2Zvcig7IXRoaXMuZWF0KHQpOyl7aWYoYSlhPSExO2Vsc2UgaWYodGhpcy5leHBlY3Qobi5jb21tYSksdGhpcy5tYXRjaCh0KSl7aSYmdGhpcy5hZGRFeHRyYShpLFwidHJhaWxpbmdDb21tYVwiLHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0KSx0aGlzLm5leHQoKTticmVha31yLnB1c2godGhpcy5wYXJzZUV4cHJMaXN0SXRlbShlLHMpKX1yZXR1cm4gcn1wYXJzZUV4cHJMaXN0SXRlbSh0LGUscyxpKXtsZXQgcjtpZih0JiZ0aGlzLm1hdGNoKG4uY29tbWEpKXI9bnVsbDtlbHNlIGlmKHRoaXMubWF0Y2gobi5lbGxpcHNpcykpe2NvbnN0IHQ9dGhpcy5zdGF0ZS5zdGFydCxpPXRoaXMuc3RhdGUuc3RhcnRMb2M7cj10aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VTcHJlYWQoZSxzKSx0LGkpfWVsc2UgaWYodGhpcy5tYXRjaChuLnF1ZXN0aW9uKSl7dGhpcy5leHBlY3RQbHVnaW4oXCJwYXJ0aWFsQXBwbGljYXRpb25cIiksaXx8dGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGYuVW5leHBlY3RlZEFyZ3VtZW50UGxhY2Vob2xkZXIpO2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTt0aGlzLm5leHQoKSxyPXRoaXMuZmluaXNoTm9kZSh0LFwiQXJndW1lbnRQbGFjZWhvbGRlclwiKX1lbHNlIHI9dGhpcy5wYXJzZU1heWJlQXNzaWduKCExLGUsdGhpcy5wYXJzZVBhcmVuSXRlbSxzKTtyZXR1cm4gcn1wYXJzZUlkZW50aWZpZXIodCl7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpLHM9dGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKGUuc3RhcnQsdCk7cmV0dXJuIHRoaXMuY3JlYXRlSWRlbnRpZmllcihlLHMpfWNyZWF0ZUlkZW50aWZpZXIodCxlKXtyZXR1cm4gdC5uYW1lPWUsdC5sb2MuaWRlbnRpZmllck5hbWU9ZSx0aGlzLmZpbmlzaE5vZGUodCxcIklkZW50aWZpZXJcIil9cGFyc2VJZGVudGlmaWVyTmFtZSh0LGUpe2xldCBzO2lmKHRoaXMubWF0Y2gobi5uYW1lKSlzPXRoaXMuc3RhdGUudmFsdWU7ZWxzZXtpZighdGhpcy5zdGF0ZS50eXBlLmtleXdvcmQpdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7cz10aGlzLnN0YXRlLnR5cGUua2V5d29yZCxcImNsYXNzXCIhPT1zJiZcImZ1bmN0aW9uXCIhPT1zfHx0aGlzLnN0YXRlLmxhc3RUb2tFbmQ9PT10aGlzLnN0YXRlLmxhc3RUb2tTdGFydCsxJiY0Nj09PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydCl8fHRoaXMuc3RhdGUuY29udGV4dC5wb3AoKX1yZXR1cm4gZT90aGlzLnN0YXRlLnR5cGU9bi5uYW1lOnRoaXMuY2hlY2tSZXNlcnZlZFdvcmQocyx0aGlzLnN0YXRlLnN0YXJ0LCEhdGhpcy5zdGF0ZS50eXBlLmtleXdvcmQsITEpLHRoaXMubmV4dCgpLHN9Y2hlY2tSZXNlcnZlZFdvcmQodCxlLHMsaSl7aWYodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQmJlwieWllbGRcIj09PXQpcmV0dXJuIHZvaWQgdGhpcy5yYWlzZShlLGYuWWllbGRCaW5kaW5nSWRlbnRpZmllcik7aWYoXCJhd2FpdFwiPT09dCl7aWYodGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQpcmV0dXJuIHZvaWQgdGhpcy5yYWlzZShlLGYuQXdhaXRCaW5kaW5nSWRlbnRpZmllcik7LTE9PT10aGlzLnN0YXRlLmF3YWl0UG9zJiYodGhpcy5zdGF0ZS5tYXliZUluQXN5bmNBcnJvd0hlYWR8fHRoaXMuaXNBd2FpdEFsbG93ZWQoKSkmJih0aGlzLnN0YXRlLmF3YWl0UG9zPXRoaXMuc3RhdGUuc3RhcnQpfWlmKHRoaXMuc2NvcGUuaW5DbGFzcyYmIXRoaXMuc2NvcGUuaW5Ob25BcnJvd0Z1bmN0aW9uJiZcImFyZ3VtZW50c1wiPT09dClyZXR1cm4gdm9pZCB0aGlzLnJhaXNlKGUsZi5Bcmd1bWVudHNEaXNhbGxvd2VkSW5Jbml0aWFsaXplcik7aWYocyYmZnVuY3Rpb24odCl7cmV0dXJuIGsuaGFzKHQpfSh0KSlyZXR1cm4gdm9pZCB0aGlzLnJhaXNlKGUsZi5VbmV4cGVjdGVkS2V5d29yZCx0KTsodGhpcy5zdGF0ZS5zdHJpY3Q/aT9POkI6TCkodCx0aGlzLmluTW9kdWxlKSYmKHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0fHxcImF3YWl0XCIhPT10P3RoaXMucmFpc2UoZSxmLlVuZXhwZWN0ZWRSZXNlcnZlZFdvcmQsdCk6dGhpcy5yYWlzZShlLGYuQXdhaXROb3RJbkFzeW5jRnVuY3Rpb24pKX1pc0F3YWl0QWxsb3dlZCgpe3JldHVybiB0aGlzLnNjb3BlLmluRnVuY3Rpb24/dGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQ6ISF0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbnx8ISF0aGlzLmhhc1BsdWdpbihcInRvcExldmVsQXdhaXRcIikmJih0aGlzLmluTW9kdWxlJiZ0aGlzLnByb2RQYXJhbS5oYXNBd2FpdCl9cGFyc2VBd2FpdCgpe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5zdGF0ZS5pblBhcmFtZXRlcnM/dGhpcy5yYWlzZSh0LnN0YXJ0LGYuQXdhaXRFeHByZXNzaW9uRm9ybWFsUGFyYW1ldGVyKTotMT09PXRoaXMuc3RhdGUuYXdhaXRQb3MmJih0aGlzLnN0YXRlLmF3YWl0UG9zPXQuc3RhcnQpLHRoaXMuZWF0KG4uc3RhcikmJnRoaXMucmFpc2UodC5zdGFydCxmLk9ic29sZXRlQXdhaXRTdGFyKSx0aGlzLnNjb3BlLmluRnVuY3Rpb258fHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9ufHwodGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKXx8dGhpcy5tYXRjaChuLnBsdXNNaW4pfHx0aGlzLm1hdGNoKG4ucGFyZW5MKXx8dGhpcy5tYXRjaChuLmJyYWNrZXRMKXx8dGhpcy5tYXRjaChuLmJhY2tRdW90ZSl8fHRoaXMubWF0Y2gobi5yZWdleHApfHx0aGlzLm1hdGNoKG4uc2xhc2gpfHx0aGlzLmhhc1BsdWdpbihcInY4aW50cmluc2ljXCIpJiZ0aGlzLm1hdGNoKG4ubW9kdWxvKT90aGlzLmFtYmlndW91c1NjcmlwdERpZmZlcmVudEFzdD0hMDp0aGlzLnNhd1VuYW1iaWd1b3VzRVNNPSEwKSx0aGlzLnN0YXRlLnNvbG9Bd2FpdHx8KHQuYXJndW1lbnQ9dGhpcy5wYXJzZU1heWJlVW5hcnkoKSksdGhpcy5maW5pc2hOb2RlKHQsXCJBd2FpdEV4cHJlc3Npb25cIil9cGFyc2VZaWVsZCh0KXtjb25zdCBlPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMuc3RhdGUuaW5QYXJhbWV0ZXJzP3RoaXMucmFpc2UoZS5zdGFydCxmLllpZWxkSW5QYXJhbWV0ZXIpOi0xPT09dGhpcy5zdGF0ZS55aWVsZFBvcyYmKHRoaXMuc3RhdGUueWllbGRQb3M9ZS5zdGFydCksdGhpcy5uZXh0KCksdGhpcy5tYXRjaChuLnNlbWkpfHwhdGhpcy5tYXRjaChuLnN0YXIpJiYhdGhpcy5zdGF0ZS50eXBlLnN0YXJ0c0V4cHJ8fHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCk/KGUuZGVsZWdhdGU9ITEsZS5hcmd1bWVudD1udWxsKTooZS5kZWxlZ2F0ZT10aGlzLmVhdChuLnN0YXIpLGUuYXJndW1lbnQ9dGhpcy5wYXJzZU1heWJlQXNzaWduKHQpKSx0aGlzLmZpbmlzaE5vZGUoZSxcIllpZWxkRXhwcmVzc2lvblwiKX1jaGVja1BpcGVsaW5lQXRJbmZpeE9wZXJhdG9yKHQsZSl7XCJzbWFydFwiPT09dGhpcy5nZXRQbHVnaW5PcHRpb24oXCJwaXBlbGluZU9wZXJhdG9yXCIsXCJwcm9wb3NhbFwiKSYmXCJTZXF1ZW5jZUV4cHJlc3Npb25cIj09PXQudHlwZSYmdGhpcy5yYWlzZShlLGYuUGlwZWxpbmVIZWFkU2VxdWVuY2VFeHByZXNzaW9uKX1wYXJzZVNtYXJ0UGlwZWxpbmVCb2R5KHQsZSxzKXtjb25zdCBpPXRoaXMuY2hlY2tTbWFydFBpcGVsaW5lQm9keVN0eWxlKHQpO3JldHVybiB0aGlzLmNoZWNrU21hcnRQaXBlbGluZUJvZHlFYXJseUVycm9ycyh0LGksZSksdGhpcy5wYXJzZVNtYXJ0UGlwZWxpbmVCb2R5SW5TdHlsZSh0LGksZSxzKX1jaGVja1NtYXJ0UGlwZWxpbmVCb2R5RWFybHlFcnJvcnModCxlLHMpe2lmKHRoaXMubWF0Y2gobi5hcnJvdykpdGhyb3cgdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGYuUGlwZWxpbmVCb2R5Tm9BcnJvdyk7XCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiPT09ZSYmXCJTZXF1ZW5jZUV4cHJlc3Npb25cIj09PXQudHlwZSYmdGhpcy5yYWlzZShzLGYuUGlwZWxpbmVCb2R5U2VxdWVuY2VFeHByZXNzaW9uKX1wYXJzZVNtYXJ0UGlwZWxpbmVCb2R5SW5TdHlsZSh0LGUscyxpKXtjb25zdCByPXRoaXMuc3RhcnROb2RlQXQocyxpKTtzd2l0Y2goZSl7Y2FzZVwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIjpyLmNhbGxlZT10O2JyZWFrO2Nhc2VcIlBpcGVsaW5lQmFyZUNvbnN0cnVjdG9yXCI6ci5jYWxsZWU9dC5jYWxsZWU7YnJlYWs7Y2FzZVwiUGlwZWxpbmVCYXJlQXdhaXRlZEZ1bmN0aW9uXCI6ci5jYWxsZWU9dC5hcmd1bWVudDticmVhaztjYXNlXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiOnRoaXMudG9waWNSZWZlcmVuY2VXYXNVc2VkSW5DdXJyZW50VG9waWNDb250ZXh0KCl8fHRoaXMucmFpc2UocyxmLlBpcGVsaW5lVG9waWNVbnVzZWQpLHIuZXhwcmVzc2lvbj10O2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgQGJhYmVsL3BhcnNlciBlcnJvcjogVW5rbm93biBwaXBlbGluZSBzdHlsZSAoXCIuY29uY2F0KGUsXCIpXCIpKX1yZXR1cm4gdGhpcy5maW5pc2hOb2RlKHIsZSl9Y2hlY2tTbWFydFBpcGVsaW5lQm9keVN0eWxlKHQpe3JldHVybiB0LnR5cGUsdGhpcy5pc1NpbXBsZVJlZmVyZW5jZSh0KT9cIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCI6XCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwifWlzU2ltcGxlUmVmZXJlbmNlKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIk1lbWJlckV4cHJlc3Npb25cIjpyZXR1cm4hdC5jb21wdXRlZCYmdGhpcy5pc1NpbXBsZVJlZmVyZW5jZSh0Lm9iamVjdCk7Y2FzZVwiSWRlbnRpZmllclwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fXdpdGhUb3BpY1Blcm1pdHRpbmdDb250ZXh0KHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS50b3BpY0NvbnRleHQ7dGhpcy5zdGF0ZS50b3BpY0NvbnRleHQ9e21heE51bU9mUmVzb2x2YWJsZVRvcGljczoxLG1heFRvcGljSW5kZXg6bnVsbH07dHJ5e3JldHVybiB0KCl9ZmluYWxseXt0aGlzLnN0YXRlLnRvcGljQ29udGV4dD1lfX13aXRoVG9waWNGb3JiaWRkaW5nQ29udGV4dCh0KXtjb25zdCBlPXRoaXMuc3RhdGUudG9waWNDb250ZXh0O3RoaXMuc3RhdGUudG9waWNDb250ZXh0PXttYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6MCxtYXhUb3BpY0luZGV4Om51bGx9O3RyeXtyZXR1cm4gdCgpfWZpbmFsbHl7dGhpcy5zdGF0ZS50b3BpY0NvbnRleHQ9ZX19d2l0aFNvbG9Bd2FpdFBlcm1pdHRpbmdDb250ZXh0KHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS5zb2xvQXdhaXQ7dGhpcy5zdGF0ZS5zb2xvQXdhaXQ9ITA7dHJ5e3JldHVybiB0KCl9ZmluYWxseXt0aGlzLnN0YXRlLnNvbG9Bd2FpdD1lfX1yZWdpc3RlclRvcGljUmVmZXJlbmNlKCl7dGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleD0wfXByaW1hcnlUb3BpY1JlZmVyZW5jZUlzQWxsb3dlZEluQ3VycmVudFRvcGljQ29udGV4dCgpe3JldHVybiB0aGlzLnN0YXRlLnRvcGljQ29udGV4dC5tYXhOdW1PZlJlc29sdmFibGVUb3BpY3M+PTF9dG9waWNSZWZlcmVuY2VXYXNVc2VkSW5DdXJyZW50VG9waWNDb250ZXh0KCl7cmV0dXJuIG51bGwhPXRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXgmJnRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXg+PTB9cGFyc2VGU2hhcnBQaXBlbGluZUJvZHkodCxlKXtjb25zdCBzPXRoaXMuc3RhdGUuc3RhcnQsaT10aGlzLnN0YXRlLnN0YXJ0TG9jO3RoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdD10aGlzLnN0YXRlLnN0YXJ0O2NvbnN0IHI9dGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTt0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5PSEwO2NvbnN0IGE9dGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeSgpLHMsaSx0LGUpO3JldHVybiB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5PXIsYX19e3BhcnNlVG9wTGV2ZWwodCxlKXtpZihlLnNvdXJjZVR5cGU9dGhpcy5vcHRpb25zLnNvdXJjZVR5cGUsZS5pbnRlcnByZXRlcj10aGlzLnBhcnNlSW50ZXJwcmV0ZXJEaXJlY3RpdmUoKSx0aGlzLnBhcnNlQmxvY2tCb2R5KGUsITAsITAsbi5lb2YpLHRoaXMuaW5Nb2R1bGUmJiF0aGlzLm9wdGlvbnMuYWxsb3dVbmRlY2xhcmVkRXhwb3J0cyYmdGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzLnNpemU+MClmb3IobGV0IHQ9MCxlPUFycmF5LmZyb20odGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzKTt0PGUubGVuZ3RoO3QrKyl7Y29uc3Rbc109ZVt0XSxpPXRoaXMuc2NvcGUudW5kZWZpbmVkRXhwb3J0cy5nZXQocyk7dGhpcy5yYWlzZShpLGYuTW9kdWxlRXhwb3J0VW5kZWZpbmVkLHMpfXJldHVybiB0LnByb2dyYW09dGhpcy5maW5pc2hOb2RlKGUsXCJQcm9ncmFtXCIpLHQuY29tbWVudHM9dGhpcy5zdGF0ZS5jb21tZW50cyx0aGlzLm9wdGlvbnMudG9rZW5zJiYodC50b2tlbnM9dGhpcy50b2tlbnMpLHRoaXMuZmluaXNoTm9kZSh0LFwiRmlsZVwiKX1zdG10VG9EaXJlY3RpdmUodCl7Y29uc3QgZT10LmV4cHJlc3Npb24scz10aGlzLnN0YXJ0Tm9kZUF0KGUuc3RhcnQsZS5sb2Muc3RhcnQpLGk9dGhpcy5zdGFydE5vZGVBdCh0LnN0YXJ0LHQubG9jLnN0YXJ0KSxyPXRoaXMuaW5wdXQuc2xpY2UoZS5zdGFydCxlLmVuZCksYT1zLnZhbHVlPXIuc2xpY2UoMSwtMSk7cmV0dXJuIHRoaXMuYWRkRXh0cmEocyxcInJhd1wiLHIpLHRoaXMuYWRkRXh0cmEocyxcInJhd1ZhbHVlXCIsYSksaS52YWx1ZT10aGlzLmZpbmlzaE5vZGVBdChzLFwiRGlyZWN0aXZlTGl0ZXJhbFwiLGUuZW5kLGUubG9jLmVuZCksdGhpcy5maW5pc2hOb2RlQXQoaSxcIkRpcmVjdGl2ZVwiLHQuZW5kLHQubG9jLmVuZCl9cGFyc2VJbnRlcnByZXRlckRpcmVjdGl2ZSgpe2lmKCF0aGlzLm1hdGNoKG4uaW50ZXJwcmV0ZXJEaXJlY3RpdmUpKXJldHVybiBudWxsO2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC52YWx1ZT10aGlzLnN0YXRlLnZhbHVlLHRoaXMubmV4dCgpLHRoaXMuZmluaXNoTm9kZSh0LFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIil9aXNMZXQodCl7aWYoIXRoaXMuaXNDb250ZXh0dWFsKFwibGV0XCIpKXJldHVybiExO2NvbnN0IGU9dGhpcy5uZXh0VG9rZW5TdGFydCgpLHM9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KGUpO2lmKDkxPT09cylyZXR1cm4hMDtpZih0KXJldHVybiExO2lmKDEyMz09PXMpcmV0dXJuITA7aWYodyhzKSl7bGV0IHQ9ZSsxO2Zvcig7Uyh0aGlzLmlucHV0LmNoYXJDb2RlQXQodCkpOykrK3Q7Y29uc3Qgcz10aGlzLmlucHV0LnNsaWNlKGUsdCk7aWYoIVIudGVzdChzKSlyZXR1cm4hMH1yZXR1cm4hMX1wYXJzZVN0YXRlbWVudCh0LGUpe3JldHVybiB0aGlzLm1hdGNoKG4uYXQpJiZ0aGlzLnBhcnNlRGVjb3JhdG9ycyghMCksdGhpcy5wYXJzZVN0YXRlbWVudENvbnRlbnQodCxlKX1wYXJzZVN0YXRlbWVudENvbnRlbnQodCxlKXtsZXQgcz10aGlzLnN0YXRlLnR5cGU7Y29uc3QgaT10aGlzLnN0YXJ0Tm9kZSgpO2xldCByO3N3aXRjaCh0aGlzLmlzTGV0KHQpJiYocz1uLl92YXIscj1cImxldFwiKSxzKXtjYXNlIG4uX2JyZWFrOmNhc2Ugbi5fY29udGludWU6cmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KGkscy5rZXl3b3JkKTtjYXNlIG4uX2RlYnVnZ2VyOnJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQoaSk7Y2FzZSBuLl9kbzpyZXR1cm4gdGhpcy5wYXJzZURvU3RhdGVtZW50KGkpO2Nhc2Ugbi5fZm9yOnJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KGkpO2Nhc2Ugbi5fZnVuY3Rpb246aWYoNDY9PT10aGlzLmxvb2thaGVhZENoYXJDb2RlKCkpYnJlYWs7cmV0dXJuIHQmJih0aGlzLnN0YXRlLnN0cmljdD90aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5TdHJpY3RGdW5jdGlvbik6XCJpZlwiIT09dCYmXCJsYWJlbFwiIT09dCYmdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGYuU2xvcHB5RnVuY3Rpb24pKSx0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQoaSwhMSwhdCk7Y2FzZSBuLl9jbGFzczpyZXR1cm4gdCYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5wYXJzZUNsYXNzKGksITApO2Nhc2Ugbi5faWY6cmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChpKTtjYXNlIG4uX3JldHVybjpyZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChpKTtjYXNlIG4uX3N3aXRjaDpyZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChpKTtjYXNlIG4uX3Rocm93OnJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQoaSk7Y2FzZSBuLl90cnk6cmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQoaSk7Y2FzZSBuLl9jb25zdDpjYXNlIG4uX3ZhcjpyZXR1cm4gcj1yfHx0aGlzLnN0YXRlLnZhbHVlLHQmJlwidmFyXCIhPT1yJiZ0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5VbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uKSx0aGlzLnBhcnNlVmFyU3RhdGVtZW50KGkscik7Y2FzZSBuLl93aGlsZTpyZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KGkpO2Nhc2Ugbi5fd2l0aDpyZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQoaSk7Y2FzZSBuLmJyYWNlTDpyZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7Y2FzZSBuLnNlbWk6cmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChpKTtjYXNlIG4uX2V4cG9ydDpjYXNlIG4uX2ltcG9ydDp7Y29uc3QgdD10aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7aWYoNDA9PT10fHw0Nj09PXQpYnJlYWs7bGV0IHI7cmV0dXJuIHRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmV8fGV8fHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxmLlVuZXhwZWN0ZWRJbXBvcnRFeHBvcnQpLHRoaXMubmV4dCgpLHM9PT1uLl9pbXBvcnQ/KHI9dGhpcy5wYXJzZUltcG9ydChpKSxcIkltcG9ydERlY2xhcmF0aW9uXCIhPT1yLnR5cGV8fHIuaW1wb3J0S2luZCYmXCJ2YWx1ZVwiIT09ci5pbXBvcnRLaW5kfHwodGhpcy5zYXdVbmFtYmlndW91c0VTTT0hMCkpOihyPXRoaXMucGFyc2VFeHBvcnQoaSksKFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiIT09ci50eXBlfHxyLmV4cG9ydEtpbmQmJlwidmFsdWVcIiE9PXIuZXhwb3J0S2luZCkmJihcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIhPT1yLnR5cGV8fHIuZXhwb3J0S2luZCYmXCJ2YWx1ZVwiIT09ci5leHBvcnRLaW5kKSYmXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiE9PXIudHlwZXx8KHRoaXMuc2F3VW5hbWJpZ3VvdXNFU009ITApKSx0aGlzLmFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKGkpLHJ9ZGVmYXVsdDppZih0aGlzLmlzQXN5bmNGdW5jdGlvbigpKXJldHVybiB0JiZ0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5Bc3luY0Z1bmN0aW9uSW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0KSx0aGlzLm5leHQoKSx0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQoaSwhMCwhdCl9Y29uc3QgYT10aGlzLnN0YXRlLnZhbHVlLG89dGhpcy5wYXJzZUV4cHJlc3Npb24oKTtyZXR1cm4gcz09PW4ubmFtZSYmXCJJZGVudGlmaWVyXCI9PT1vLnR5cGUmJnRoaXMuZWF0KG4uY29sb24pP3RoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KGksYSxvLHQpOnRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KGksbyl9YXNzZXJ0TW9kdWxlTm9kZUFsbG93ZWQodCl7dGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZXx8dGhpcy5pbk1vZHVsZXx8dGhpcy5yYWlzZVdpdGhEYXRhKHQuc3RhcnQse2NvZGU6XCJCQUJFTF9QQVJTRVJfU09VUkNFVFlQRV9NT0RVTEVfUkVRVUlSRURcIn0sZi5JbXBvcnRPdXRzaWRlTW9kdWxlKX10YWtlRGVjb3JhdG9ycyh0KXtjb25zdCBlPXRoaXMuc3RhdGUuZGVjb3JhdG9yU3RhY2tbdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFjay5sZW5ndGgtMV07ZS5sZW5ndGgmJih0LmRlY29yYXRvcnM9ZSx0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKHQsZVswXSksdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFja1t0aGlzLnN0YXRlLmRlY29yYXRvclN0YWNrLmxlbmd0aC0xXT1bXSl9Y2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKXtyZXR1cm4gdGhpcy5tYXRjaChuLl9jbGFzcyl9cGFyc2VEZWNvcmF0b3JzKHQpe2NvbnN0IGU9dGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFja1t0aGlzLnN0YXRlLmRlY29yYXRvclN0YWNrLmxlbmd0aC0xXTtmb3IoO3RoaXMubWF0Y2gobi5hdCk7KXtjb25zdCB0PXRoaXMucGFyc2VEZWNvcmF0b3IoKTtlLnB1c2godCl9aWYodGhpcy5tYXRjaChuLl9leHBvcnQpKXR8fHRoaXMudW5leHBlY3RlZCgpLHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSYmIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKSYmdGhpcy5yYWlzZSh0aGlzLnN0YXRlLnN0YXJ0LGYuRGVjb3JhdG9yRXhwb3J0Q2xhc3MpO2Vsc2UgaWYoIXRoaXMuY2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKSl0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5VbmV4cGVjdGVkTGVhZGluZ0RlY29yYXRvcil9cGFyc2VEZWNvcmF0b3IoKXt0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJkZWNvcmF0b3JzLWxlZ2FjeVwiLFwiZGVjb3JhdG9yc1wiXSk7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpO2lmKHRoaXMubmV4dCgpLHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSl7dGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFjay5wdXNoKFtdKTtjb25zdCBlPXRoaXMuc3RhdGUuc3RhcnQscz10aGlzLnN0YXRlLnN0YXJ0TG9jO2xldCBpO2lmKHRoaXMuZWF0KG4ucGFyZW5MKSlpPXRoaXMucGFyc2VFeHByZXNzaW9uKCksdGhpcy5leHBlY3Qobi5wYXJlblIpO2Vsc2UgZm9yKGk9dGhpcy5wYXJzZUlkZW50aWZpZXIoITEpO3RoaXMuZWF0KG4uZG90KTspe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGVBdChlLHMpO3Qub2JqZWN0PWksdC5wcm9wZXJ0eT10aGlzLnBhcnNlSWRlbnRpZmllcighMCksdC5jb21wdXRlZD0hMSxpPXRoaXMuZmluaXNoTm9kZSh0LFwiTWVtYmVyRXhwcmVzc2lvblwiKX10LmV4cHJlc3Npb249dGhpcy5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGkpLHRoaXMuc3RhdGUuZGVjb3JhdG9yU3RhY2sucG9wKCl9ZWxzZSB0LmV4cHJlc3Npb249dGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCk7cmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LFwiRGVjb3JhdG9yXCIpfXBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHModCl7aWYodGhpcy5lYXQobi5wYXJlbkwpKXtjb25zdCBlPXRoaXMuc3RhcnROb2RlQXROb2RlKHQpO3JldHVybiBlLmNhbGxlZT10LGUuYXJndW1lbnRzPXRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyhuLnBhcmVuUiwhMSksdGhpcy50b1JlZmVyZW5jZWRMaXN0KGUuYXJndW1lbnRzKSx0aGlzLmZpbmlzaE5vZGUoZSxcIkNhbGxFeHByZXNzaW9uXCIpfXJldHVybiB0fXBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudCh0LGUpe2NvbnN0IHM9XCJicmVha1wiPT09ZTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCk/dC5sYWJlbD1udWxsOih0LmxhYmVsPXRoaXMucGFyc2VJZGVudGlmaWVyKCksdGhpcy5zZW1pY29sb24oKSksdGhpcy52ZXJpZnlCcmVha0NvbnRpbnVlKHQsZSksdGhpcy5maW5pc2hOb2RlKHQscz9cIkJyZWFrU3RhdGVtZW50XCI6XCJDb250aW51ZVN0YXRlbWVudFwiKX12ZXJpZnlCcmVha0NvbnRpbnVlKHQsZSl7Y29uc3Qgcz1cImJyZWFrXCI9PT1lO2xldCBpO2ZvcihpPTA7aTx0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGg7KytpKXtjb25zdCBlPXRoaXMuc3RhdGUubGFiZWxzW2ldO2lmKG51bGw9PXQubGFiZWx8fGUubmFtZT09PXQubGFiZWwubmFtZSl7aWYobnVsbCE9ZS5raW5kJiYoc3x8XCJsb29wXCI9PT1lLmtpbmQpKWJyZWFrO2lmKHQubGFiZWwmJnMpYnJlYWt9fWk9PT10aGlzLnN0YXRlLmxhYmVscy5sZW5ndGgmJnRoaXMucmFpc2UodC5zdGFydCxmLklsbGVnYWxCcmVha0NvbnRpbnVlLGUpfXBhcnNlRGVidWdnZXJTdGF0ZW1lbnQodCl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKHQsXCJEZWJ1Z2dlclN0YXRlbWVudFwiKX1wYXJzZUhlYWRlckV4cHJlc3Npb24oKXt0aGlzLmV4cGVjdChuLnBhcmVuTCk7Y29uc3QgdD10aGlzLnBhcnNlRXhwcmVzc2lvbigpO3JldHVybiB0aGlzLmV4cGVjdChuLnBhcmVuUiksdH1wYXJzZURvU3RhdGVtZW50KHQpe3JldHVybiB0aGlzLm5leHQoKSx0aGlzLnN0YXRlLmxhYmVscy5wdXNoKEV0KSx0LmJvZHk9dGhpcy53aXRoVG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKT0+dGhpcy5wYXJzZVN0YXRlbWVudChcImRvXCIpKSx0aGlzLnN0YXRlLmxhYmVscy5wb3AoKSx0aGlzLmV4cGVjdChuLl93aGlsZSksdC50ZXN0PXRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCksdGhpcy5lYXQobi5zZW1pKSx0aGlzLmZpbmlzaE5vZGUodCxcIkRvV2hpbGVTdGF0ZW1lbnRcIil9cGFyc2VGb3JTdGF0ZW1lbnQodCl7dGhpcy5uZXh0KCksdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChFdCk7bGV0IGU9LTE7aWYodGhpcy5pc0F3YWl0QWxsb3dlZCgpJiZ0aGlzLmVhdENvbnRleHR1YWwoXCJhd2FpdFwiKSYmKGU9dGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQpLHRoaXMuc2NvcGUuZW50ZXIoMCksdGhpcy5leHBlY3Qobi5wYXJlbkwpLHRoaXMubWF0Y2gobi5zZW1pKSlyZXR1cm4gZT4tMSYmdGhpcy51bmV4cGVjdGVkKGUpLHRoaXMucGFyc2VGb3IodCxudWxsKTtjb25zdCBzPXRoaXMuaXNMZXQoKTtpZih0aGlzLm1hdGNoKG4uX3Zhcil8fHRoaXMubWF0Y2gobi5fY29uc3QpfHxzKXtjb25zdCBpPXRoaXMuc3RhcnROb2RlKCkscj1zP1wibGV0XCI6dGhpcy5zdGF0ZS52YWx1ZTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5wYXJzZVZhcihpLCEwLHIpLHRoaXMuZmluaXNoTm9kZShpLFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSwodGhpcy5tYXRjaChuLl9pbil8fHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpJiYxPT09aS5kZWNsYXJhdGlvbnMubGVuZ3RoP3RoaXMucGFyc2VGb3JJbih0LGksZSk6KGU+LTEmJnRoaXMudW5leHBlY3RlZChlKSx0aGlzLnBhcnNlRm9yKHQsaSkpfWNvbnN0IGk9bmV3IHh0LHI9dGhpcy5wYXJzZUV4cHJlc3Npb24oITAsaSk7aWYodGhpcy5tYXRjaChuLl9pbil8fHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpe3RoaXMudG9Bc3NpZ25hYmxlKHIpO2NvbnN0IHM9dGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKT9cImZvci1vZiBzdGF0ZW1lbnRcIjpcImZvci1pbiBzdGF0ZW1lbnRcIjtyZXR1cm4gdGhpcy5jaGVja0xWYWwocix2b2lkIDAsdm9pZCAwLHMpLHRoaXMucGFyc2VGb3JJbih0LHIsZSl9cmV0dXJuIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKGksITApLGU+LTEmJnRoaXMudW5leHBlY3RlZChlKSx0aGlzLnBhcnNlRm9yKHQscil9cGFyc2VGdW5jdGlvblN0YXRlbWVudCh0LGUscyl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMucGFyc2VGdW5jdGlvbih0LDF8KHM/MDoyKSxlKX1wYXJzZUlmU3RhdGVtZW50KHQpe3JldHVybiB0aGlzLm5leHQoKSx0LnRlc3Q9dGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKSx0LmNvbnNlcXVlbnQ9dGhpcy5wYXJzZVN0YXRlbWVudChcImlmXCIpLHQuYWx0ZXJuYXRlPXRoaXMuZWF0KG4uX2Vsc2UpP3RoaXMucGFyc2VTdGF0ZW1lbnQoXCJpZlwiKTpudWxsLHRoaXMuZmluaXNoTm9kZSh0LFwiSWZTdGF0ZW1lbnRcIil9cGFyc2VSZXR1cm5TdGF0ZW1lbnQodCl7cmV0dXJuIHRoaXMucHJvZFBhcmFtLmhhc1JldHVybnx8dGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9ufHx0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5JbGxlZ2FsUmV0dXJuKSx0aGlzLm5leHQoKSx0aGlzLmlzTGluZVRlcm1pbmF0b3IoKT90LmFyZ3VtZW50PW51bGw6KHQuYXJndW1lbnQ9dGhpcy5wYXJzZUV4cHJlc3Npb24oKSx0aGlzLnNlbWljb2xvbigpKSx0aGlzLmZpbmlzaE5vZGUodCxcIlJldHVyblN0YXRlbWVudFwiKX1wYXJzZVN3aXRjaFN0YXRlbWVudCh0KXt0aGlzLm5leHQoKSx0LmRpc2NyaW1pbmFudD10aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO2NvbnN0IGU9dC5jYXNlcz1bXTtsZXQgcyxpO2Zvcih0aGlzLmV4cGVjdChuLmJyYWNlTCksdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChDdCksdGhpcy5zY29wZS5lbnRlcigwKTshdGhpcy5tYXRjaChuLmJyYWNlUik7KWlmKHRoaXMubWF0Y2gobi5fY2FzZSl8fHRoaXMubWF0Y2gobi5fZGVmYXVsdCkpe2NvbnN0IHQ9dGhpcy5tYXRjaChuLl9jYXNlKTtzJiZ0aGlzLmZpbmlzaE5vZGUocyxcIlN3aXRjaENhc2VcIiksZS5wdXNoKHM9dGhpcy5zdGFydE5vZGUoKSkscy5jb25zZXF1ZW50PVtdLHRoaXMubmV4dCgpLHQ/cy50ZXN0PXRoaXMucGFyc2VFeHByZXNzaW9uKCk6KGkmJnRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsZi5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gpLGk9ITAscy50ZXN0PW51bGwpLHRoaXMuZXhwZWN0KG4uY29sb24pfWVsc2Ugcz9zLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KG51bGwpKTp0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm4gdGhpcy5zY29wZS5leGl0KCkscyYmdGhpcy5maW5pc2hOb2RlKHMsXCJTd2l0Y2hDYXNlXCIpLHRoaXMubmV4dCgpLHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpLHRoaXMuZmluaXNoTm9kZSh0LFwiU3dpdGNoU3RhdGVtZW50XCIpfXBhcnNlVGhyb3dTdGF0ZW1lbnQodCl7cmV0dXJuIHRoaXMubmV4dCgpLG8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhdGUubGFzdFRva0VuZCx0aGlzLnN0YXRlLnN0YXJ0KSkmJnRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLGYuTmV3bGluZUFmdGVyVGhyb3cpLHQuYXJndW1lbnQ9dGhpcy5wYXJzZUV4cHJlc3Npb24oKSx0aGlzLnNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZSh0LFwiVGhyb3dTdGF0ZW1lbnRcIil9cGFyc2VUcnlTdGF0ZW1lbnQodCl7aWYodGhpcy5uZXh0KCksdC5ibG9jaz10aGlzLnBhcnNlQmxvY2soKSx0LmhhbmRsZXI9bnVsbCx0aGlzLm1hdGNoKG4uX2NhdGNoKSl7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpO2lmKHRoaXMubmV4dCgpLHRoaXMubWF0Y2gobi5wYXJlbkwpKXt0aGlzLmV4cGVjdChuLnBhcmVuTCksZS5wYXJhbT10aGlzLnBhcnNlQmluZGluZ0F0b20oKTtjb25zdCB0PVwiSWRlbnRpZmllclwiPT09ZS5wYXJhbS50eXBlO3RoaXMuc2NvcGUuZW50ZXIodD84OjApLHRoaXMuY2hlY2tMVmFsKGUucGFyYW0sOSxudWxsLFwiY2F0Y2ggY2xhdXNlXCIpLHRoaXMuZXhwZWN0KG4ucGFyZW5SKX1lbHNlIGUucGFyYW09bnVsbCx0aGlzLnNjb3BlLmVudGVyKDApO2UuYm9keT10aGlzLndpdGhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpPT50aGlzLnBhcnNlQmxvY2soITEsITEpKSx0aGlzLnNjb3BlLmV4aXQoKSx0LmhhbmRsZXI9dGhpcy5maW5pc2hOb2RlKGUsXCJDYXRjaENsYXVzZVwiKX1yZXR1cm4gdC5maW5hbGl6ZXI9dGhpcy5lYXQobi5fZmluYWxseSk/dGhpcy5wYXJzZUJsb2NrKCk6bnVsbCx0LmhhbmRsZXJ8fHQuZmluYWxpemVyfHx0aGlzLnJhaXNlKHQuc3RhcnQsZi5Ob0NhdGNoT3JGaW5hbGx5KSx0aGlzLmZpbmlzaE5vZGUodCxcIlRyeVN0YXRlbWVudFwiKX1wYXJzZVZhclN0YXRlbWVudCh0LGUpe3JldHVybiB0aGlzLm5leHQoKSx0aGlzLnBhcnNlVmFyKHQsITEsZSksdGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUodCxcIlZhcmlhYmxlRGVjbGFyYXRpb25cIil9cGFyc2VXaGlsZVN0YXRlbWVudCh0KXtyZXR1cm4gdGhpcy5uZXh0KCksdC50ZXN0PXRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCksdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChFdCksdC5ib2R5PXRoaXMud2l0aFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCk9PnRoaXMucGFyc2VTdGF0ZW1lbnQoXCJ3aGlsZVwiKSksdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCksdGhpcy5maW5pc2hOb2RlKHQsXCJXaGlsZVN0YXRlbWVudFwiKX1wYXJzZVdpdGhTdGF0ZW1lbnQodCl7cmV0dXJuIHRoaXMuc3RhdGUuc3RyaWN0JiZ0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5TdHJpY3RXaXRoKSx0aGlzLm5leHQoKSx0Lm9iamVjdD10aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpLHQuYm9keT10aGlzLndpdGhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpPT50aGlzLnBhcnNlU3RhdGVtZW50KFwid2l0aFwiKSksdGhpcy5maW5pc2hOb2RlKHQsXCJXaXRoU3RhdGVtZW50XCIpfXBhcnNlRW1wdHlTdGF0ZW1lbnQodCl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuZmluaXNoTm9kZSh0LFwiRW1wdHlTdGF0ZW1lbnRcIil9cGFyc2VMYWJlbGVkU3RhdGVtZW50KHQsZSxzLGkpe2ZvcihsZXQgdD0wLGk9dGhpcy5zdGF0ZS5sYWJlbHM7dDxpLmxlbmd0aDt0Kyspe2lbdF0ubmFtZT09PWUmJnRoaXMucmFpc2Uocy5zdGFydCxmLkxhYmVsUmVkZWNsYXJhdGlvbixlKX1jb25zdCByPXRoaXMuc3RhdGUudHlwZS5pc0xvb3A/XCJsb29wXCI6dGhpcy5tYXRjaChuLl9zd2l0Y2gpP1wic3dpdGNoXCI6bnVsbDtmb3IobGV0IGU9dGhpcy5zdGF0ZS5sYWJlbHMubGVuZ3RoLTE7ZT49MDtlLS0pe2NvbnN0IHM9dGhpcy5zdGF0ZS5sYWJlbHNbZV07aWYocy5zdGF0ZW1lbnRTdGFydCE9PXQuc3RhcnQpYnJlYWs7cy5zdGF0ZW1lbnRTdGFydD10aGlzLnN0YXRlLnN0YXJ0LHMua2luZD1yfXJldHVybiB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKHtuYW1lOmUsa2luZDpyLHN0YXRlbWVudFN0YXJ0OnRoaXMuc3RhdGUuc3RhcnR9KSx0LmJvZHk9dGhpcy5wYXJzZVN0YXRlbWVudChpPy0xPT09aS5pbmRleE9mKFwibGFiZWxcIik/aStcImxhYmVsXCI6aTpcImxhYmVsXCIpLHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpLHQubGFiZWw9cyx0aGlzLmZpbmlzaE5vZGUodCxcIkxhYmVsZWRTdGF0ZW1lbnRcIil9cGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KHQsZSl7cmV0dXJuIHQuZXhwcmVzc2lvbj1lLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKHQsXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpfXBhcnNlQmxvY2sodD0hMSxlPSEwLHMpe2NvbnN0IGk9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5leHBlY3Qobi5icmFjZUwpLGUmJnRoaXMuc2NvcGUuZW50ZXIoMCksdGhpcy5wYXJzZUJsb2NrQm9keShpLHQsITEsbi5icmFjZVIscyksZSYmdGhpcy5zY29wZS5leGl0KCksdGhpcy5maW5pc2hOb2RlKGksXCJCbG9ja1N0YXRlbWVudFwiKX1pc1ZhbGlkRGlyZWN0aXZlKHQpe3JldHVyblwiRXhwcmVzc2lvblN0YXRlbWVudFwiPT09dC50eXBlJiZcIlN0cmluZ0xpdGVyYWxcIj09PXQuZXhwcmVzc2lvbi50eXBlJiYhdC5leHByZXNzaW9uLmV4dHJhLnBhcmVudGhlc2l6ZWR9cGFyc2VCbG9ja0JvZHkodCxlLHMsaSxyKXtjb25zdCBhPXQuYm9keT1bXSxuPXQuZGlyZWN0aXZlcz1bXTt0aGlzLnBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShhLGU/bjp2b2lkIDAscyxpLHIpfXBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keSh0LGUscyxpLHIpe2NvbnN0IGE9W10sbj10aGlzLnN0YXRlLnN0cmljdDtsZXQgbz0hMSxoPSExO2Zvcig7IXRoaXMubWF0Y2goaSk7KXshaCYmdGhpcy5zdGF0ZS5vY3RhbFBvc2l0aW9ucy5sZW5ndGgmJmEucHVzaCguLi50aGlzLnN0YXRlLm9jdGFsUG9zaXRpb25zKTtjb25zdCBpPXRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCxzKTtpZihlJiYhaCYmdGhpcy5pc1ZhbGlkRGlyZWN0aXZlKGkpKXtjb25zdCB0PXRoaXMuc3RtdFRvRGlyZWN0aXZlKGkpO2UucHVzaCh0KSxvfHxcInVzZSBzdHJpY3RcIiE9PXQudmFsdWUudmFsdWV8fChvPSEwLHRoaXMuc2V0U3RyaWN0KCEwKSl9ZWxzZSBoPSEwLHQucHVzaChpKX1pZih0aGlzLnN0YXRlLnN0cmljdCYmYS5sZW5ndGgpZm9yKGxldCB0PTA7dDxhLmxlbmd0aDt0Kyspe2NvbnN0IGU9YVt0XTt0aGlzLnJhaXNlKGUsZi5TdHJpY3RPY3RhbExpdGVyYWwpfXImJnIuY2FsbCh0aGlzLG8pLG58fHRoaXMuc2V0U3RyaWN0KCExKSx0aGlzLm5leHQoKX1wYXJzZUZvcih0LGUpe3JldHVybiB0LmluaXQ9ZSx0aGlzLmV4cGVjdChuLnNlbWkpLHQudGVzdD10aGlzLm1hdGNoKG4uc2VtaSk/bnVsbDp0aGlzLnBhcnNlRXhwcmVzc2lvbigpLHRoaXMuZXhwZWN0KG4uc2VtaSksdC51cGRhdGU9dGhpcy5tYXRjaChuLnBhcmVuUik/bnVsbDp0aGlzLnBhcnNlRXhwcmVzc2lvbigpLHRoaXMuZXhwZWN0KG4ucGFyZW5SKSx0LmJvZHk9dGhpcy53aXRoVG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKT0+dGhpcy5wYXJzZVN0YXRlbWVudChcImZvclwiKSksdGhpcy5zY29wZS5leGl0KCksdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCksdGhpcy5maW5pc2hOb2RlKHQsXCJGb3JTdGF0ZW1lbnRcIil9cGFyc2VGb3JJbih0LGUscyl7Y29uc3QgaT10aGlzLm1hdGNoKG4uX2luKTtyZXR1cm4gdGhpcy5uZXh0KCksaT9zPi0xJiZ0aGlzLnVuZXhwZWN0ZWQocyk6dC5hd2FpdD1zPi0xLFwiVmFyaWFibGVEZWNsYXJhdGlvblwiIT09ZS50eXBlfHxudWxsPT1lLmRlY2xhcmF0aW9uc1swXS5pbml0fHxpJiYhdGhpcy5zdGF0ZS5zdHJpY3QmJlwidmFyXCI9PT1lLmtpbmQmJlwiSWRlbnRpZmllclwiPT09ZS5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZT9cIkFzc2lnbm1lbnRQYXR0ZXJuXCI9PT1lLnR5cGUmJnRoaXMucmFpc2UoZS5zdGFydCxmLkludmFsaWRMaHMsXCJmb3ItbG9vcFwiKTp0aGlzLnJhaXNlKGUuc3RhcnQsZi5Gb3JJbk9mTG9vcEluaXRpYWxpemVyLGk/XCJmb3ItaW5cIjpcImZvci1vZlwiKSx0LmxlZnQ9ZSx0LnJpZ2h0PWk/dGhpcy5wYXJzZUV4cHJlc3Npb24oKTp0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKSx0aGlzLmV4cGVjdChuLnBhcmVuUiksdC5ib2R5PXRoaXMud2l0aFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCk9PnRoaXMucGFyc2VTdGF0ZW1lbnQoXCJmb3JcIikpLHRoaXMuc2NvcGUuZXhpdCgpLHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpLHRoaXMuZmluaXNoTm9kZSh0LGk/XCJGb3JJblN0YXRlbWVudFwiOlwiRm9yT2ZTdGF0ZW1lbnRcIil9cGFyc2VWYXIodCxlLHMpe2NvbnN0IGk9dC5kZWNsYXJhdGlvbnM9W10scj10aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIik7Zm9yKHQua2luZD1zOzspe2NvbnN0IHQ9dGhpcy5zdGFydE5vZGUoKTtpZih0aGlzLnBhcnNlVmFySWQodCxzKSx0aGlzLmVhdChuLmVxKT90LmluaXQ9dGhpcy5wYXJzZU1heWJlQXNzaWduKGUpOihcImNvbnN0XCIhPT1zfHx0aGlzLm1hdGNoKG4uX2luKXx8dGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKT9cIklkZW50aWZpZXJcIj09PXQuaWQudHlwZXx8ZSYmKHRoaXMubWF0Y2gobi5faW4pfHx0aGlzLmlzQ29udGV4dHVhbChcIm9mXCIpKXx8dGhpcy5yYWlzZSh0aGlzLnN0YXRlLmxhc3RUb2tFbmQsZi5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplcixcIkNvbXBsZXggYmluZGluZyBwYXR0ZXJuc1wiKTpyfHx0aGlzLnVuZXhwZWN0ZWQoKSx0LmluaXQ9bnVsbCksaS5wdXNoKHRoaXMuZmluaXNoTm9kZSh0LFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKSwhdGhpcy5lYXQobi5jb21tYSkpYnJlYWt9cmV0dXJuIHR9cGFyc2VWYXJJZCh0LGUpe3QuaWQ9dGhpcy5wYXJzZUJpbmRpbmdBdG9tKCksdGhpcy5jaGVja0xWYWwodC5pZCxcInZhclwiPT09ZT81Ojksdm9pZCAwLFwidmFyaWFibGUgZGVjbGFyYXRpb25cIixcInZhclwiIT09ZSl9cGFyc2VGdW5jdGlvbih0LGU9MCxzPSExKXtjb25zdCBpPTEmZSxyPTImZSxhPSEoIWl8fDQmZSk7dGhpcy5pbml0RnVuY3Rpb24odCxzKSx0aGlzLm1hdGNoKG4uc3RhcikmJnImJnRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxmLkdlbmVyYXRvckluU2luZ2xlU3RhdGVtZW50Q29udGV4dCksdC5nZW5lcmF0b3I9dGhpcy5lYXQobi5zdGFyKSxpJiYodC5pZD10aGlzLnBhcnNlRnVuY3Rpb25JZChhKSk7Y29uc3Qgbz10aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMsaD10aGlzLnN0YXRlLnlpZWxkUG9zLHA9dGhpcy5zdGF0ZS5hd2FpdFBvcztyZXR1cm4gdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzPSExLHRoaXMuc3RhdGUueWllbGRQb3M9LTEsdGhpcy5zdGF0ZS5hd2FpdFBvcz0tMSx0aGlzLnNjb3BlLmVudGVyKDIpLHRoaXMucHJvZFBhcmFtLmVudGVyKGV0KHMsdC5nZW5lcmF0b3IpKSxpfHwodC5pZD10aGlzLnBhcnNlRnVuY3Rpb25JZCgpKSx0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXModCksdGhpcy53aXRoVG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKT0+e3RoaXMucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2godCxpP1wiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIpfSksdGhpcy5wcm9kUGFyYW0uZXhpdCgpLHRoaXMuc2NvcGUuZXhpdCgpLGkmJiFyJiZ0aGlzLnJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZCh0KSx0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM9byx0aGlzLnN0YXRlLnlpZWxkUG9zPWgsdGhpcy5zdGF0ZS5hd2FpdFBvcz1wLHR9cGFyc2VGdW5jdGlvbklkKHQpe3JldHVybiB0fHx0aGlzLm1hdGNoKG4ubmFtZSk/dGhpcy5wYXJzZUlkZW50aWZpZXIoKTpudWxsfXBhcnNlRnVuY3Rpb25QYXJhbXModCxlKXtjb25zdCBzPXRoaXMuc3RhdGUuaW5QYXJhbWV0ZXJzO3RoaXMuc3RhdGUuaW5QYXJhbWV0ZXJzPSEwLHRoaXMuZXhwZWN0KG4ucGFyZW5MKSx0LnBhcmFtcz10aGlzLnBhcnNlQmluZGluZ0xpc3Qobi5wYXJlblIsNDEsITEsZSksdGhpcy5zdGF0ZS5pblBhcmFtZXRlcnM9cyx0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpfXJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZCh0KXt0LmlkJiZ0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKHQuaWQubmFtZSx0aGlzLnN0YXRlLnN0cmljdHx8dC5nZW5lcmF0b3J8fHQuYXN5bmM/dGhpcy5zY29wZS50cmVhdEZ1bmN0aW9uc0FzVmFyPzU6OToxNyx0LmlkLnN0YXJ0KX1wYXJzZUNsYXNzKHQsZSxzKXt0aGlzLm5leHQoKSx0aGlzLnRha2VEZWNvcmF0b3JzKHQpO2NvbnN0IGk9dGhpcy5zdGF0ZS5zdHJpY3Q7cmV0dXJuIHRoaXMuc3RhdGUuc3RyaWN0PSEwLHRoaXMucGFyc2VDbGFzc0lkKHQsZSxzKSx0aGlzLnBhcnNlQ2xhc3NTdXBlcih0KSx0LmJvZHk9dGhpcy5wYXJzZUNsYXNzQm9keSghIXQuc3VwZXJDbGFzcyxpKSx0aGlzLnN0YXRlLnN0cmljdD1pLHRoaXMuZmluaXNoTm9kZSh0LGU/XCJDbGFzc0RlY2xhcmF0aW9uXCI6XCJDbGFzc0V4cHJlc3Npb25cIil9aXNDbGFzc1Byb3BlcnR5KCl7cmV0dXJuIHRoaXMubWF0Y2gobi5lcSl8fHRoaXMubWF0Y2gobi5zZW1pKXx8dGhpcy5tYXRjaChuLmJyYWNlUil9aXNDbGFzc01ldGhvZCgpe3JldHVybiB0aGlzLm1hdGNoKG4ucGFyZW5MKX1pc05vbnN0YXRpY0NvbnN0cnVjdG9yKHQpe3JldHVybiEodC5jb21wdXRlZHx8dC5zdGF0aWN8fFwiY29uc3RydWN0b3JcIiE9PXQua2V5Lm5hbWUmJlwiY29uc3RydWN0b3JcIiE9PXQua2V5LnZhbHVlKX1wYXJzZUNsYXNzQm9keSh0LGUpe3RoaXMuY2xhc3NTY29wZS5lbnRlcigpO2NvbnN0IHM9e2hhZENvbnN0cnVjdG9yOiExfTtsZXQgaT1bXTtjb25zdCByPXRoaXMuc3RhcnROb2RlKCk7aWYoci5ib2R5PVtdLHRoaXMuZXhwZWN0KG4uYnJhY2VMKSx0aGlzLndpdGhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpPT57Zm9yKDshdGhpcy5tYXRjaChuLmJyYWNlUik7KXtpZih0aGlzLmVhdChuLnNlbWkpKXtpZihpLmxlbmd0aD4wKXRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5sYXN0VG9rRW5kLGYuRGVjb3JhdG9yU2VtaWNvbG9uKTtjb250aW51ZX1pZih0aGlzLm1hdGNoKG4uYXQpKXtpLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtjb250aW51ZX1jb25zdCBlPXRoaXMuc3RhcnROb2RlKCk7aS5sZW5ndGgmJihlLmRlY29yYXRvcnM9aSx0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGUsaVswXSksaT1bXSksdGhpcy5wYXJzZUNsYXNzTWVtYmVyKHIsZSxzLHQpLFwiY29uc3RydWN0b3JcIj09PWUua2luZCYmZS5kZWNvcmF0b3JzJiZlLmRlY29yYXRvcnMubGVuZ3RoPjAmJnRoaXMucmFpc2UoZS5zdGFydCxmLkRlY29yYXRvckNvbnN0cnVjdG9yKX19KSxlfHwodGhpcy5zdGF0ZS5zdHJpY3Q9ITEpLHRoaXMubmV4dCgpLGkubGVuZ3RoKXRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxmLlRyYWlsaW5nRGVjb3JhdG9yKTtyZXR1cm4gdGhpcy5jbGFzc1Njb3BlLmV4aXQoKSx0aGlzLmZpbmlzaE5vZGUocixcIkNsYXNzQm9keVwiKX1wYXJzZUNsYXNzTWVtYmVyRnJvbU1vZGlmaWVyKHQsZSl7Y29uc3Qgcz10aGlzLnN0YXRlLmNvbnRhaW5zRXNjLGk9dGhpcy5wYXJzZUlkZW50aWZpZXIoITApO2lmKHRoaXMuaXNDbGFzc01ldGhvZCgpKXtjb25zdCBzPWU7cmV0dXJuIHMua2luZD1cIm1ldGhvZFwiLHMuY29tcHV0ZWQ9ITEscy5rZXk9aSxzLnN0YXRpYz0hMSx0aGlzLnB1c2hDbGFzc01ldGhvZCh0LHMsITEsITEsITEsITEpLCEwfWlmKHRoaXMuaXNDbGFzc1Byb3BlcnR5KCkpe2NvbnN0IHM9ZTtyZXR1cm4gcy5jb21wdXRlZD0hMSxzLmtleT1pLHMuc3RhdGljPSExLHQuYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5KHMpKSwhMH1pZihzKXRocm93IHRoaXMudW5leHBlY3RlZCgpO3JldHVybiExfXBhcnNlQ2xhc3NNZW1iZXIodCxlLHMsaSl7Y29uc3Qgcj10aGlzLmlzQ29udGV4dHVhbChcInN0YXRpY1wiKTtyJiZ0aGlzLnBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIodCxlKXx8dGhpcy5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKHQsZSxzLHIsaSl9cGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyh0LGUscyxpLHIpe2NvbnN0IGE9ZSxvPWUsaD1lLHA9ZSxjPWEsdT1hO2lmKGUuc3RhdGljPWksdGhpcy5lYXQobi5zdGFyKSlyZXR1cm4gYy5raW5kPVwibWV0aG9kXCIsdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlOYW1lKGMpLFwiUHJpdmF0ZU5hbWVcIj09PWMua2V5LnR5cGU/dm9pZCB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QodCxvLCEwLCExKToodGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKGEpJiZ0aGlzLnJhaXNlKGEua2V5LnN0YXJ0LGYuQ29uc3RydWN0b3JJc0dlbmVyYXRvciksdm9pZCB0aGlzLnB1c2hDbGFzc01ldGhvZCh0LGEsITAsITEsITEsITEpKTtjb25zdCBsPXRoaXMuc3RhdGUuY29udGFpbnNFc2MsZD10aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eU5hbWUoZSksbT1cIlByaXZhdGVOYW1lXCI9PT1kLnR5cGUsRD1cIklkZW50aWZpZXJcIj09PWQudHlwZSx5PXRoaXMuc3RhdGUuc3RhcnQ7aWYodGhpcy5wYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKHUpLHRoaXMuaXNDbGFzc01ldGhvZCgpKXtpZihjLmtpbmQ9XCJtZXRob2RcIixtKXJldHVybiB2b2lkIHRoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZCh0LG8sITEsITEpO2NvbnN0IGU9dGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKGEpO2xldCBpPSExO2UmJihhLmtpbmQ9XCJjb25zdHJ1Y3RvclwiLHMuaGFkQ29uc3RydWN0b3ImJiF0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikmJnRoaXMucmFpc2UoZC5zdGFydCxmLkR1cGxpY2F0ZUNvbnN0cnVjdG9yKSxzLmhhZENvbnN0cnVjdG9yPSEwLGk9ciksdGhpcy5wdXNoQ2xhc3NNZXRob2QodCxhLCExLCExLGUsaSl9ZWxzZSBpZih0aGlzLmlzQ2xhc3NQcm9wZXJ0eSgpKW0/dGhpcy5wdXNoQ2xhc3NQcml2YXRlUHJvcGVydHkodCxwKTp0aGlzLnB1c2hDbGFzc1Byb3BlcnR5KHQsaCk7ZWxzZSBpZighRHx8XCJhc3luY1wiIT09ZC5uYW1lfHxsfHx0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkhRHx8XCJnZXRcIiE9PWQubmFtZSYmXCJzZXRcIiE9PWQubmFtZXx8bHx8dGhpcy5tYXRjaChuLnN0YXIpJiZ0aGlzLmlzTGluZVRlcm1pbmF0b3IoKT90aGlzLmlzTGluZVRlcm1pbmF0b3IoKT9tP3RoaXMucHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KHQscCk6dGhpcy5wdXNoQ2xhc3NQcm9wZXJ0eSh0LGgpOnRoaXMudW5leHBlY3RlZCgpOihjLmtpbmQ9ZC5uYW1lLHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5TmFtZShhKSxcIlByaXZhdGVOYW1lXCI9PT1jLmtleS50eXBlP3RoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZCh0LG8sITEsITEpOih0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IoYSkmJnRoaXMucmFpc2UoYS5rZXkuc3RhcnQsZi5Db25zdHJ1Y3RvcklzQWNjZXNzb3IpLHRoaXMucHVzaENsYXNzTWV0aG9kKHQsYSwhMSwhMSwhMSwhMSkpLHRoaXMuY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMoYSkpO2Vsc2V7Y29uc3QgZT10aGlzLmVhdChuLnN0YXIpO3Uub3B0aW9uYWwmJnRoaXMudW5leHBlY3RlZCh5KSxjLmtpbmQ9XCJtZXRob2RcIix0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eU5hbWUoYyksdGhpcy5wYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKHUpLFwiUHJpdmF0ZU5hbWVcIj09PWMua2V5LnR5cGU/dGhpcy5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKHQsbyxlLCEwKToodGhpcy5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKGEpJiZ0aGlzLnJhaXNlKGEua2V5LnN0YXJ0LGYuQ29uc3RydWN0b3JJc0FzeW5jKSx0aGlzLnB1c2hDbGFzc01ldGhvZCh0LGEsZSwhMCwhMSwhMSkpfX1wYXJzZUNsYXNzUHJvcGVydHlOYW1lKHQpe2NvbnN0IGU9dGhpcy5wYXJzZVByb3BlcnR5TmFtZSh0LCEwKTtyZXR1cm4gdC5jb21wdXRlZHx8IXQuc3RhdGljfHxcInByb3RvdHlwZVwiIT09ZS5uYW1lJiZcInByb3RvdHlwZVwiIT09ZS52YWx1ZXx8dGhpcy5yYWlzZShlLnN0YXJ0LGYuU3RhdGljUHJvdG90eXBlKSxcIlByaXZhdGVOYW1lXCI9PT1lLnR5cGUmJlwiY29uc3RydWN0b3JcIj09PWUuaWQubmFtZSYmdGhpcy5yYWlzZShlLnN0YXJ0LGYuQ29uc3RydWN0b3JDbGFzc1ByaXZhdGVGaWVsZCksZX1wdXNoQ2xhc3NQcm9wZXJ0eSh0LGUpe2UuY29tcHV0ZWR8fFwiY29uc3RydWN0b3JcIiE9PWUua2V5Lm5hbWUmJlwiY29uc3RydWN0b3JcIiE9PWUua2V5LnZhbHVlfHx0aGlzLnJhaXNlKGUua2V5LnN0YXJ0LGYuQ29uc3RydWN0b3JDbGFzc0ZpZWxkKSx0LmJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eShlKSl9cHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KHQsZSl7dGhpcy5leHBlY3RQbHVnaW4oXCJjbGFzc1ByaXZhdGVQcm9wZXJ0aWVzXCIsZS5rZXkuc3RhcnQpO2NvbnN0IHM9dGhpcy5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KGUpO3QuYm9keS5wdXNoKHMpLHRoaXMuY2xhc3NTY29wZS5kZWNsYXJlUHJpdmF0ZU5hbWUocy5rZXkuaWQubmFtZSwwLHMua2V5LnN0YXJ0KX1wdXNoQ2xhc3NNZXRob2QodCxlLHMsaSxyLGEpe3QuYm9keS5wdXNoKHRoaXMucGFyc2VNZXRob2QoZSxzLGkscixhLFwiQ2xhc3NNZXRob2RcIiwhMCkpfXB1c2hDbGFzc1ByaXZhdGVNZXRob2QodCxlLHMsaSl7dGhpcy5leHBlY3RQbHVnaW4oXCJjbGFzc1ByaXZhdGVNZXRob2RzXCIsZS5rZXkuc3RhcnQpO2NvbnN0IHI9dGhpcy5wYXJzZU1ldGhvZChlLHMsaSwhMSwhMSxcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiLCEwKTt0LmJvZHkucHVzaChyKTtjb25zdCBhPVwiZ2V0XCI9PT1yLmtpbmQ/ci5zdGF0aWM/NjoyOlwic2V0XCI9PT1yLmtpbmQ/ci5zdGF0aWM/NToxOjA7dGhpcy5jbGFzc1Njb3BlLmRlY2xhcmVQcml2YXRlTmFtZShyLmtleS5pZC5uYW1lLGEsci5rZXkuc3RhcnQpfXBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnModCl7fXBhcnNlQWNjZXNzTW9kaWZpZXIoKXt9cGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eSh0KXtyZXR1cm4gdGhpcy5zY29wZS5lbnRlcig4MCksdGhpcy5wcm9kUGFyYW0uZW50ZXIoMCksdC52YWx1ZT10aGlzLmVhdChuLmVxKT90aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTpudWxsLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5wcm9kUGFyYW0uZXhpdCgpLHRoaXMuc2NvcGUuZXhpdCgpLHRoaXMuZmluaXNoTm9kZSh0LFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIil9cGFyc2VDbGFzc1Byb3BlcnR5KHQpe3JldHVybiB0LnR5cGVBbm5vdGF0aW9ufHx0aGlzLmV4cGVjdFBsdWdpbihcImNsYXNzUHJvcGVydGllc1wiKSx0aGlzLnNjb3BlLmVudGVyKDgwKSx0aGlzLnByb2RQYXJhbS5lbnRlcigwKSx0aGlzLm1hdGNoKG4uZXEpPyh0aGlzLmV4cGVjdFBsdWdpbihcImNsYXNzUHJvcGVydGllc1wiKSx0aGlzLm5leHQoKSx0LnZhbHVlPXRoaXMucGFyc2VNYXliZUFzc2lnbigpKTp0LnZhbHVlPW51bGwsdGhpcy5zZW1pY29sb24oKSx0aGlzLnByb2RQYXJhbS5leGl0KCksdGhpcy5zY29wZS5leGl0KCksdGhpcy5maW5pc2hOb2RlKHQsXCJDbGFzc1Byb3BlcnR5XCIpfXBhcnNlQ2xhc3NJZCh0LGUscyxpPTEzOSl7dGhpcy5tYXRjaChuLm5hbWUpPyh0LmlkPXRoaXMucGFyc2VJZGVudGlmaWVyKCksZSYmdGhpcy5jaGVja0xWYWwodC5pZCxpLHZvaWQgMCxcImNsYXNzIG5hbWVcIikpOnN8fCFlP3QuaWQ9bnVsbDp0aGlzLnVuZXhwZWN0ZWQobnVsbCxmLk1pc3NpbmdDbGFzc05hbWUpfXBhcnNlQ2xhc3NTdXBlcih0KXt0LnN1cGVyQ2xhc3M9dGhpcy5lYXQobi5fZXh0ZW5kcyk/dGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCk6bnVsbH1wYXJzZUV4cG9ydCh0KXtjb25zdCBlPXRoaXMubWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIodCkscz0hZXx8dGhpcy5lYXQobi5jb21tYSksaT1zJiZ0aGlzLmVhdEV4cG9ydFN0YXIodCkscj1pJiZ0aGlzLm1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIodCksYT1zJiYoIXJ8fHRoaXMuZWF0KG4uY29tbWEpKSxvPWV8fGk7aWYoaSYmIXIpcmV0dXJuIGUmJnRoaXMudW5leHBlY3RlZCgpLHRoaXMucGFyc2VFeHBvcnRGcm9tKHQsITApLHRoaXMuZmluaXNoTm9kZSh0LFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIik7Y29uc3QgaD10aGlzLm1heWJlUGFyc2VFeHBvcnROYW1lZFNwZWNpZmllcnModCk7aWYoZSYmcyYmIWkmJiFofHxyJiZhJiYhaCl0aHJvdyB0aGlzLnVuZXhwZWN0ZWQobnVsbCxuLmJyYWNlTCk7bGV0IHA7aWYob3x8aD8ocD0hMSx0aGlzLnBhcnNlRXhwb3J0RnJvbSh0LG8pKTpwPXRoaXMubWF5YmVQYXJzZUV4cG9ydERlY2xhcmF0aW9uKHQpLG98fGh8fHApcmV0dXJuIHRoaXMuY2hlY2tFeHBvcnQodCwhMCwhMSwhIXQuc291cmNlKSx0aGlzLmZpbmlzaE5vZGUodCxcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIik7aWYodGhpcy5lYXQobi5fZGVmYXVsdCkpcmV0dXJuIHQuZGVjbGFyYXRpb249dGhpcy5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCksdGhpcy5jaGVja0V4cG9ydCh0LCEwLCEwKSx0aGlzLmZpbmlzaE5vZGUodCxcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKTt0aHJvdyB0aGlzLnVuZXhwZWN0ZWQobnVsbCxuLmJyYWNlTCl9ZWF0RXhwb3J0U3Rhcih0KXtyZXR1cm4gdGhpcy5lYXQobi5zdGFyKX1tYXliZVBhcnNlRXhwb3J0RGVmYXVsdFNwZWNpZmllcih0KXtpZih0aGlzLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpKXt0aGlzLmV4cGVjdFBsdWdpbihcImV4cG9ydERlZmF1bHRGcm9tXCIpO2NvbnN0IGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gZS5leHBvcnRlZD10aGlzLnBhcnNlSWRlbnRpZmllcighMCksdC5zcGVjaWZpZXJzPVt0aGlzLmZpbmlzaE5vZGUoZSxcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIildLCEwfXJldHVybiExfW1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIodCl7aWYodGhpcy5pc0NvbnRleHR1YWwoXCJhc1wiKSl7dC5zcGVjaWZpZXJzfHwodC5zcGVjaWZpZXJzPVtdKTtjb25zdCBlPXRoaXMuc3RhcnROb2RlQXQodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnQsdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO3JldHVybiB0aGlzLm5leHQoKSxlLmV4cG9ydGVkPXRoaXMucGFyc2VJZGVudGlmaWVyKCEwKSx0LnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZSxcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSksITB9cmV0dXJuITF9bWF5YmVQYXJzZUV4cG9ydE5hbWVkU3BlY2lmaWVycyh0KXtyZXR1cm4hIXRoaXMubWF0Y2gobi5icmFjZUwpJiYodC5zcGVjaWZpZXJzfHwodC5zcGVjaWZpZXJzPVtdKSx0LnNwZWNpZmllcnMucHVzaCguLi50aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycygpKSx0LnNvdXJjZT1udWxsLHQuZGVjbGFyYXRpb249bnVsbCwhMCl9bWF5YmVQYXJzZUV4cG9ydERlY2xhcmF0aW9uKHQpe2lmKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpKXtpZih0aGlzLmlzQ29udGV4dHVhbChcImFzeW5jXCIpKXtjb25zdCB0PXRoaXMubmV4dFRva2VuU3RhcnQoKTt0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKHQsXCJmdW5jdGlvblwiKXx8dGhpcy51bmV4cGVjdGVkKHQsbi5fZnVuY3Rpb24pfXJldHVybiB0LnNwZWNpZmllcnM9W10sdC5zb3VyY2U9bnVsbCx0LmRlY2xhcmF0aW9uPXRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbih0KSwhMH1yZXR1cm4hMX1pc0FzeW5jRnVuY3Rpb24oKXtpZighdGhpcy5pc0NvbnRleHR1YWwoXCJhc3luY1wiKSlyZXR1cm4hMTtjb25zdCB0PXRoaXMubmV4dFRva2VuU3RhcnQoKTtyZXR1cm4hby50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGF0ZS5wb3MsdCkpJiZ0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKHQsXCJmdW5jdGlvblwiKX1wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCl7Y29uc3QgdD10aGlzLnN0YXJ0Tm9kZSgpLGU9dGhpcy5pc0FzeW5jRnVuY3Rpb24oKTtpZih0aGlzLm1hdGNoKG4uX2Z1bmN0aW9uKXx8ZSlyZXR1cm4gdGhpcy5uZXh0KCksZSYmdGhpcy5uZXh0KCksdGhpcy5wYXJzZUZ1bmN0aW9uKHQsNSxlKTtpZih0aGlzLm1hdGNoKG4uX2NsYXNzKSlyZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHQsITAsITApO2lmKHRoaXMubWF0Y2gobi5hdCkpcmV0dXJuIHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSYmdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsXCJkZWNvcmF0b3JzQmVmb3JlRXhwb3J0XCIpJiZ0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5EZWNvcmF0b3JCZWZvcmVFeHBvcnQpLHRoaXMucGFyc2VEZWNvcmF0b3JzKCExKSx0aGlzLnBhcnNlQ2xhc3ModCwhMCwhMCk7aWYodGhpcy5tYXRjaChuLl9jb25zdCl8fHRoaXMubWF0Y2gobi5fdmFyKXx8dGhpcy5pc0xldCgpKXRocm93IHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdGFydCxmLlVuc3VwcG9ydGVkRGVmYXVsdEV4cG9ydCk7e2NvbnN0IHQ9dGhpcy5wYXJzZU1heWJlQXNzaWduKCk7cmV0dXJuIHRoaXMuc2VtaWNvbG9uKCksdH19cGFyc2VFeHBvcnREZWNsYXJhdGlvbih0KXtyZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKX1pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKXtpZih0aGlzLm1hdGNoKG4ubmFtZSkpcmV0dXJuXCJhc3luY1wiIT09dGhpcy5zdGF0ZS52YWx1ZSYmXCJsZXRcIiE9PXRoaXMuc3RhdGUudmFsdWU7aWYoIXRoaXMubWF0Y2gobi5fZGVmYXVsdCkpcmV0dXJuITE7Y29uc3QgdD10aGlzLm5leHRUb2tlblN0YXJ0KCk7cmV0dXJuIDQ0PT09dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHQpfHx0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKHQsXCJmcm9tXCIpfXBhcnNlRXhwb3J0RnJvbSh0LGUpe3RoaXMuZWF0Q29udGV4dHVhbChcImZyb21cIik/KHQuc291cmNlPXRoaXMucGFyc2VJbXBvcnRTb3VyY2UoKSx0aGlzLmNoZWNrRXhwb3J0KHQpKTplP3RoaXMudW5leHBlY3RlZCgpOnQuc291cmNlPW51bGwsdGhpcy5zZW1pY29sb24oKX1zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCl7aWYodGhpcy5tYXRjaChuLmF0KSYmKHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImRlY29yYXRvcnNcIixcImRlY29yYXRvcnMtbGVnYWN5XCJdKSx0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpKXtpZighdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsXCJkZWNvcmF0b3JzQmVmb3JlRXhwb3J0XCIpKXJldHVybiEwO3RoaXMudW5leHBlY3RlZCh0aGlzLnN0YXRlLnN0YXJ0LGYuRGVjb3JhdG9yQmVmb3JlRXhwb3J0KX1yZXR1cm5cInZhclwiPT09dGhpcy5zdGF0ZS50eXBlLmtleXdvcmR8fFwiY29uc3RcIj09PXRoaXMuc3RhdGUudHlwZS5rZXl3b3JkfHxcImZ1bmN0aW9uXCI9PT10aGlzLnN0YXRlLnR5cGUua2V5d29yZHx8XCJjbGFzc1wiPT09dGhpcy5zdGF0ZS50eXBlLmtleXdvcmR8fHRoaXMuaXNMZXQoKXx8dGhpcy5pc0FzeW5jRnVuY3Rpb24oKX1jaGVja0V4cG9ydCh0LGUscyxpKXtpZihlKWlmKHMpdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHModCxcImRlZmF1bHRcIik7ZWxzZSBpZih0LnNwZWNpZmllcnMmJnQuc3BlY2lmaWVycy5sZW5ndGgpZm9yKGxldCBlPTAscz10LnNwZWNpZmllcnM7ZTxzLmxlbmd0aDtlKyspe2NvbnN0IHQ9c1tlXTt0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyh0LHQuZXhwb3J0ZWQubmFtZSksIWkmJnQubG9jYWwmJih0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHQubG9jYWwubmFtZSx0LmxvY2FsLnN0YXJ0LCEwLCExKSx0aGlzLnNjb3BlLmNoZWNrTG9jYWxFeHBvcnQodC5sb2NhbCkpfWVsc2UgaWYodC5kZWNsYXJhdGlvbilpZihcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIj09PXQuZGVjbGFyYXRpb24udHlwZXx8XCJDbGFzc0RlY2xhcmF0aW9uXCI9PT10LmRlY2xhcmF0aW9uLnR5cGUpe2NvbnN0IGU9dC5kZWNsYXJhdGlvbi5pZDtpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gZmFpbHVyZVwiKTt0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyh0LGUubmFtZSl9ZWxzZSBpZihcIlZhcmlhYmxlRGVjbGFyYXRpb25cIj09PXQuZGVjbGFyYXRpb24udHlwZSlmb3IobGV0IGU9MCxzPXQuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zO2U8cy5sZW5ndGg7ZSsrKXtjb25zdCB0PXNbZV07dGhpcy5jaGVja0RlY2xhcmF0aW9uKHQuaWQpfWlmKHRoaXMuc3RhdGUuZGVjb3JhdG9yU3RhY2tbdGhpcy5zdGF0ZS5kZWNvcmF0b3JTdGFjay5sZW5ndGgtMV0ubGVuZ3RoKXtjb25zdCBlPXQuZGVjbGFyYXRpb24mJihcIkNsYXNzRGVjbGFyYXRpb25cIj09PXQuZGVjbGFyYXRpb24udHlwZXx8XCJDbGFzc0V4cHJlc3Npb25cIj09PXQuZGVjbGFyYXRpb24udHlwZSk7aWYoIXQuZGVjbGFyYXRpb258fCFlKXRocm93IHRoaXMucmFpc2UodC5zdGFydCxmLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0KTt0aGlzLnRha2VEZWNvcmF0b3JzKHQuZGVjbGFyYXRpb24pfX1jaGVja0RlY2xhcmF0aW9uKHQpe2lmKFwiSWRlbnRpZmllclwiPT09dC50eXBlKXRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKHQsdC5uYW1lKTtlbHNlIGlmKFwiT2JqZWN0UGF0dGVyblwiPT09dC50eXBlKWZvcihsZXQgZT0wLHM9dC5wcm9wZXJ0aWVzO2U8cy5sZW5ndGg7ZSsrKXtjb25zdCB0PXNbZV07dGhpcy5jaGVja0RlY2xhcmF0aW9uKHQpfWVsc2UgaWYoXCJBcnJheVBhdHRlcm5cIj09PXQudHlwZSlmb3IobGV0IGU9MCxzPXQuZWxlbWVudHM7ZTxzLmxlbmd0aDtlKyspe2NvbnN0IHQ9c1tlXTt0JiZ0aGlzLmNoZWNrRGVjbGFyYXRpb24odCl9ZWxzZVwiT2JqZWN0UHJvcGVydHlcIj09PXQudHlwZT90aGlzLmNoZWNrRGVjbGFyYXRpb24odC52YWx1ZSk6XCJSZXN0RWxlbWVudFwiPT09dC50eXBlP3RoaXMuY2hlY2tEZWNsYXJhdGlvbih0LmFyZ3VtZW50KTpcIkFzc2lnbm1lbnRQYXR0ZXJuXCI9PT10LnR5cGUmJnRoaXMuY2hlY2tEZWNsYXJhdGlvbih0LmxlZnQpfWNoZWNrRHVwbGljYXRlRXhwb3J0cyh0LGUpe3RoaXMuc3RhdGUuZXhwb3J0ZWRJZGVudGlmaWVycy5pbmRleE9mKGUpPi0xJiZ0aGlzLnJhaXNlKHQuc3RhcnQsXCJkZWZhdWx0XCI9PT1lP2YuRHVwbGljYXRlRGVmYXVsdEV4cG9ydDpmLkR1cGxpY2F0ZUV4cG9ydCxlKSx0aGlzLnN0YXRlLmV4cG9ydGVkSWRlbnRpZmllcnMucHVzaChlKX1wYXJzZUV4cG9ydFNwZWNpZmllcnMoKXtjb25zdCB0PVtdO2xldCBlPSEwO2Zvcih0aGlzLmV4cGVjdChuLmJyYWNlTCk7IXRoaXMuZWF0KG4uYnJhY2VSKTspe2lmKGUpZT0hMTtlbHNlIGlmKHRoaXMuZXhwZWN0KG4uY29tbWEpLHRoaXMuZWF0KG4uYnJhY2VSKSlicmVhaztjb25zdCBzPXRoaXMuc3RhcnROb2RlKCk7cy5sb2NhbD10aGlzLnBhcnNlSWRlbnRpZmllcighMCkscy5leHBvcnRlZD10aGlzLmVhdENvbnRleHR1YWwoXCJhc1wiKT90aGlzLnBhcnNlSWRlbnRpZmllcighMCk6cy5sb2NhbC5fX2Nsb25lKCksdC5wdXNoKHRoaXMuZmluaXNoTm9kZShzLFwiRXhwb3J0U3BlY2lmaWVyXCIpKX1yZXR1cm4gdH1wYXJzZUltcG9ydCh0KXtpZih0LnNwZWNpZmllcnM9W10sIXRoaXMubWF0Y2gobi5zdHJpbmcpKXtjb25zdCBlPSF0aGlzLm1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKHQpfHx0aGlzLmVhdChuLmNvbW1hKSxzPWUmJnRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIodCk7ZSYmIXMmJnRoaXMucGFyc2VOYW1lZEltcG9ydFNwZWNpZmllcnModCksdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKX1yZXR1cm4gdC5zb3VyY2U9dGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKHQsXCJJbXBvcnREZWNsYXJhdGlvblwiKX1wYXJzZUltcG9ydFNvdXJjZSgpe3JldHVybiB0aGlzLm1hdGNoKG4uc3RyaW5nKXx8dGhpcy51bmV4cGVjdGVkKCksdGhpcy5wYXJzZUV4cHJBdG9tKCl9c2hvdWxkUGFyc2VEZWZhdWx0SW1wb3J0KHQpe3JldHVybiB0aGlzLm1hdGNoKG4ubmFtZSl9cGFyc2VJbXBvcnRTcGVjaWZpZXJMb2NhbCh0LGUscyxpKXtlLmxvY2FsPXRoaXMucGFyc2VJZGVudGlmaWVyKCksdGhpcy5jaGVja0xWYWwoZS5sb2NhbCw5LHZvaWQgMCxpKSx0LnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUoZSxzKSl9bWF5YmVQYXJzZURlZmF1bHRJbXBvcnRTcGVjaWZpZXIodCl7cmV0dXJuISF0aGlzLnNob3VsZFBhcnNlRGVmYXVsdEltcG9ydCh0KSYmKHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJMb2NhbCh0LHRoaXMuc3RhcnROb2RlKCksXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsXCJkZWZhdWx0IGltcG9ydCBzcGVjaWZpZXJcIiksITApfW1heWJlUGFyc2VTdGFySW1wb3J0U3BlY2lmaWVyKHQpe2lmKHRoaXMubWF0Y2gobi5zdGFyKSl7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSx0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJhc1wiKSx0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwodCxlLFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsXCJpbXBvcnQgbmFtZXNwYWNlIHNwZWNpZmllclwiKSwhMH1yZXR1cm4hMX1wYXJzZU5hbWVkSW1wb3J0U3BlY2lmaWVycyh0KXtsZXQgZT0hMDtmb3IodGhpcy5leHBlY3Qobi5icmFjZUwpOyF0aGlzLmVhdChuLmJyYWNlUik7KXtpZihlKWU9ITE7ZWxzZXtpZih0aGlzLmVhdChuLmNvbG9uKSl0aHJvdyB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RhcnQsZi5EZXN0cnVjdHVyZU5hbWVkSW1wb3J0KTtpZih0aGlzLmV4cGVjdChuLmNvbW1hKSx0aGlzLmVhdChuLmJyYWNlUikpYnJlYWt9dGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcih0KX19cGFyc2VJbXBvcnRTcGVjaWZpZXIodCl7Y29uc3QgZT10aGlzLnN0YXJ0Tm9kZSgpO2UuaW1wb3J0ZWQ9dGhpcy5wYXJzZUlkZW50aWZpZXIoITApLHRoaXMuZWF0Q29udGV4dHVhbChcImFzXCIpP2UubG9jYWw9dGhpcy5wYXJzZUlkZW50aWZpZXIoKToodGhpcy5jaGVja1Jlc2VydmVkV29yZChlLmltcG9ydGVkLm5hbWUsZS5zdGFydCwhMCwhMCksZS5sb2NhbD1lLmltcG9ydGVkLl9fY2xvbmUoKSksdGhpcy5jaGVja0xWYWwoZS5sb2NhbCw5LHZvaWQgMCxcImltcG9ydCBzcGVjaWZpZXJcIiksdC5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKGUsXCJJbXBvcnRTcGVjaWZpZXJcIikpfX17Y29uc3RydWN0b3IodCxlKXtzdXBlcih0PWZ1bmN0aW9uKHQpe2NvbnN0IGU9e307Zm9yKGxldCBzPTAsaT1PYmplY3Qua2V5cyh1dCk7czxpLmxlbmd0aDtzKyspe2NvbnN0IHI9aVtzXTtlW3JdPXQmJm51bGwhPXRbcl0/dFtyXTp1dFtyXX1yZXR1cm4gZX0odCksZSk7Y29uc3Qgcz10aGlzLmdldFNjb3BlSGFuZGxlcigpO3RoaXMub3B0aW9ucz10LHRoaXMuaW5Nb2R1bGU9XCJtb2R1bGVcIj09PXRoaXMub3B0aW9ucy5zb3VyY2VUeXBlLHRoaXMuc2NvcGU9bmV3IHModGhpcy5yYWlzZS5iaW5kKHRoaXMpLHRoaXMuaW5Nb2R1bGUpLHRoaXMucHJvZFBhcmFtPW5ldyB0dCx0aGlzLmNsYXNzU2NvcGU9bmV3IFR0KHRoaXMucmFpc2UuYmluZCh0aGlzKSksdGhpcy5wbHVnaW5zPWZ1bmN0aW9uKHQpe2NvbnN0IGU9bmV3IE1hcDtmb3IobGV0IHM9MDtzPHQubGVuZ3RoO3MrKyl7Y29uc3QgaT10W3NdLFtyLGFdPUFycmF5LmlzQXJyYXkoaSk/aTpbaSx7fV07ZS5oYXMocil8fGUuc2V0KHIsYXx8e30pfXJldHVybiBlfSh0aGlzLm9wdGlvbnMucGx1Z2lucyksdGhpcy5maWxlbmFtZT10LnNvdXJjZUZpbGVuYW1lfWdldFNjb3BlSGFuZGxlcigpe3JldHVybiBZfXBhcnNlKCl7bGV0IHQ9MDt0aGlzLmhhc1BsdWdpbihcInRvcExldmVsQXdhaXRcIikmJnRoaXMuaW5Nb2R1bGUmJih0fD0yKSx0aGlzLnNjb3BlLmVudGVyKDEpLHRoaXMucHJvZFBhcmFtLmVudGVyKHQpO2NvbnN0IGU9dGhpcy5zdGFydE5vZGUoKSxzPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dFRva2VuKCksZS5lcnJvcnM9bnVsbCx0aGlzLnBhcnNlVG9wTGV2ZWwoZSxzKSxlLmVycm9ycz10aGlzLnN0YXRlLmVycm9ycyxlfX1mdW5jdGlvbiB3dCh0LGUpe2xldCBzPUF0O3JldHVybiB0JiZ0LnBsdWdpbnMmJighZnVuY3Rpb24odCl7aWYoYXQodCxcImRlY29yYXRvcnNcIikpe2lmKGF0KHQsXCJkZWNvcmF0b3JzLWxlZ2FjeVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHRoZSBkZWNvcmF0b3JzIGFuZCBkZWNvcmF0b3JzLWxlZ2FjeSBwbHVnaW4gdG9nZXRoZXJcIik7Y29uc3QgZT1udCh0LFwiZGVjb3JhdG9yc1wiLFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKTtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcIlRoZSAnZGVjb3JhdG9ycycgcGx1Z2luIHJlcXVpcmVzIGEgJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQnIG9wdGlvbiwgd2hvc2UgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uIElmIHlvdSBhcmUgbWlncmF0aW5nIGZyb20gQmFieWxvbi9CYWJlbCA2IG9yIHdhbnQgdG8gdXNlIHRoZSBvbGQgZGVjb3JhdG9ycyBwcm9wb3NhbCwgeW91IHNob3VsZCB1c2UgdGhlICdkZWNvcmF0b3JzLWxlZ2FjeScgcGx1Z2luIGluc3RlYWQgb2YgJ2RlY29yYXRvcnMnLlwiKTtpZihcImJvb2xlYW5cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQnIG11c3QgYmUgYSBib29sZWFuLlwiKX1pZihhdCh0LFwiZmxvd1wiKSYmYXQodCxcInR5cGVzY3JpcHRcIikpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgZmxvdyBhbmQgdHlwZXNjcmlwdCBwbHVnaW5zLlwiKTtpZihhdCh0LFwicGxhY2Vob2xkZXJzXCIpJiZhdCh0LFwidjhpbnRyaW5zaWNcIikpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgcGxhY2Vob2xkZXJzIGFuZCB2OGludHJpbnNpYyBwbHVnaW5zLlwiKTtpZihhdCh0LFwicGlwZWxpbmVPcGVyYXRvclwiKSYmIW90LmluY2x1ZGVzKG50KHQsXCJwaXBlbGluZU9wZXJhdG9yXCIsXCJwcm9wb3NhbFwiKSkpdGhyb3cgbmV3IEVycm9yKFwiJ3BpcGVsaW5lT3BlcmF0b3InIHJlcXVpcmVzICdwcm9wb3NhbCcgb3B0aW9uIHdob3NlIHZhbHVlIHNob3VsZCBiZSBvbmUgb2Y6IFwiK290Lm1hcCh0PT5cIidcIi5jb25jYXQodCxcIidcIikpLmpvaW4oXCIsIFwiKSk7aWYoYXQodCxcInJlY29yZEFuZFR1cGxlXCIpJiYhaHQuaW5jbHVkZXMobnQodCxcInJlY29yZEFuZFR1cGxlXCIsXCJzeW50YXhUeXBlXCIpKSl0aHJvdyBuZXcgRXJyb3IoXCIncmVjb3JkQW5kVHVwbGUnIHJlcXVpcmVzICdzeW50YXhUeXBlJyBvcHRpb24gd2hvc2UgdmFsdWUgc2hvdWxkIGJlIG9uZSBvZjogXCIraHQubWFwKHQ9PlwiJ1wiLmNvbmNhdCh0LFwiJ1wiKSkuam9pbihcIiwgXCIpKX0odC5wbHVnaW5zKSxzPWZ1bmN0aW9uKHQpe2NvbnN0IGU9Y3QuZmlsdGVyKGU9PmF0KHQsZSkpLHM9ZS5qb2luKFwiL1wiKTtsZXQgaT1TdFtzXTtpZighaSl7aT1BdDtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKyl7Y29uc3Qgcz1lW3RdO2k9cHRbc10oaSl9U3Rbc109aX1yZXR1cm4gaX0odC5wbHVnaW5zKSksbmV3IHModCxlKX1jb25zdCBTdD17fTtlLnBhcnNlPWZ1bmN0aW9uKHQsZSl7aWYoIWV8fFwidW5hbWJpZ3VvdXNcIiE9PWUuc291cmNlVHlwZSlyZXR1cm4gd3QoZSx0KS5wYXJzZSgpO2U9T2JqZWN0LmFzc2lnbih7fSxlKTt0cnl7ZS5zb3VyY2VUeXBlPVwibW9kdWxlXCI7Y29uc3Qgcz13dChlLHQpLGk9cy5wYXJzZSgpO2lmKHMuc2F3VW5hbWJpZ3VvdXNFU00pcmV0dXJuIGk7aWYocy5hbWJpZ3VvdXNTY3JpcHREaWZmZXJlbnRBc3QpdHJ5e3JldHVybiBlLnNvdXJjZVR5cGU9XCJzY3JpcHRcIix3dChlLHQpLnBhcnNlKCl9Y2F0Y2godCl7fWVsc2UgaS5wcm9ncmFtLnNvdXJjZVR5cGU9XCJzY3JpcHRcIjtyZXR1cm4gaX1jYXRjaChzKXt0cnl7cmV0dXJuIGUuc291cmNlVHlwZT1cInNjcmlwdFwiLHd0KGUsdCkucGFyc2UoKX1jYXRjaCh0KXt9dGhyb3cgc319LGUucGFyc2VFeHByZXNzaW9uPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgcz13dChlLHQpO3JldHVybiBzLm9wdGlvbnMuc3RyaWN0TW9kZSYmKHMuc3RhdGUuc3RyaWN0PSEwKSxzLmdldEV4cHJlc3Npb24oKX0sZS50b2tUeXBlcz1ufSkpO3MoS3QpO0t0LnBhcnNlLEt0LnBhcnNlRXhwcmVzc2lvbixLdC50b2tUeXBlcztjb25zdHtoYXNQcmFnbWE6SnR9PWM7ZnVuY3Rpb24gWHQodD1bXSl7cmV0dXJue3NvdXJjZVR5cGU6XCJtb2R1bGVcIixhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiEwLGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTohMCxhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjohMCxhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDohMCxhbGxvd1VuZGVjbGFyZWRFeHBvcnRzOiEwLGVycm9yUmVjb3Zlcnk6ITAsY3JlYXRlUGFyZW50aGVzaXplZEV4cHJlc3Npb25zOiEwLHBsdWdpbnM6W1wiZG9FeHByZXNzaW9uc1wiLFwib2JqZWN0UmVzdFNwcmVhZFwiLFwiY2xhc3NQcm9wZXJ0aWVzXCIsXCJleHBvcnREZWZhdWx0RnJvbVwiLFwiZXhwb3J0TmFtZXNwYWNlRnJvbVwiLFwiYXN5bmNHZW5lcmF0b3JzXCIsXCJmdW5jdGlvbkJpbmRcIixcImZ1bmN0aW9uU2VudFwiLFwiZHluYW1pY0ltcG9ydFwiLFwibnVtZXJpY1NlcGFyYXRvclwiLFwiaW1wb3J0TWV0YVwiLFwib3B0aW9uYWxDYXRjaEJpbmRpbmdcIixcIm9wdGlvbmFsQ2hhaW5pbmdcIixcImNsYXNzUHJpdmF0ZVByb3BlcnRpZXNcIixbXCJwaXBlbGluZU9wZXJhdG9yXCIse3Byb3Bvc2FsOlwibWluaW1hbFwifV0sXCJudWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yXCIsXCJiaWdJbnRcIixcInRocm93RXhwcmVzc2lvbnNcIixcImxvZ2ljYWxBc3NpZ25tZW50XCIsXCJjbGFzc1ByaXZhdGVNZXRob2RzXCIsXCJ2OGludHJpbnNpY1wiLFwicGFydGlhbEFwcGxpY2F0aW9uXCIsW1wiZGVjb3JhdG9yc1wiLHtkZWNvcmF0b3JzQmVmb3JlRXhwb3J0OiExfV0sLi4udF19fWZ1bmN0aW9uIEd0KHQsLi4ucyl7cmV0dXJuKGkscixhKT0+e2NvbnN0IG49S3Q7bGV0IG87dHJ5e289ZnVuY3Rpb24odCxlKXtsZXQgcztmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyl0cnl7cmV0dXJuIHQoZVtpXSl9Y2F0Y2godCl7c3x8KHM9dCl9dGhyb3cgc30oZT0+blt0XShpLGUpLHMubWFwKFh0KSl9Y2F0Y2godCl7dGhyb3cgZSh0Lm1lc3NhZ2UucmVwbGFjZSgvIFxcKC4qXFwpLyxcIlwiKSx7c3RhcnQ6e2xpbmU6dC5sb2MubGluZSxjb2x1bW46dC5sb2MuY29sdW1uKzF9fSl9cmV0dXJuIGRlbGV0ZSBvLnRva2VucyxXdChvLE9iamVjdC5hc3NpZ24oe30sYSx7b3JpZ2luYWxUZXh0Oml9KSl9fWNvbnN0IFF0PUd0KFwicGFyc2VcIixbXCJqc3hcIixcImZsb3dcIl0pLFl0PUd0KFwicGFyc2VcIixbXCJqc3hcIixbXCJmbG93XCIse2FsbDohMCxlbnVtczohMH1dXSksJHQ9R3QoXCJwYXJzZVwiLFtcImpzeFwiLFwidHlwZXNjcmlwdFwiXSxbXCJ0eXBlc2NyaXB0XCJdKSxadD1HdChcInBhcnNlRXhwcmVzc2lvblwiLFtcImpzeFwiXSk7ZnVuY3Rpb24gdGUodCxzKXtzd2l0Y2godC50eXBlKXtjYXNlXCJBcnJheUV4cHJlc3Npb25cIjpyZXR1cm4gdC5lbGVtZW50cy5mb3JFYWNoKGkpO2Nhc2VcIk9iamVjdEV4cHJlc3Npb25cIjpyZXR1cm4gdC5wcm9wZXJ0aWVzLmZvckVhY2goaSk7Y2FzZVwiT2JqZWN0UHJvcGVydHlcIjppZih0LmNvbXB1dGVkKXRocm93IHIoXCJjb21wdXRlZFwiKTtpZih0LnNob3J0aGFuZCl0aHJvdyByKFwic2hvcnRoYW5kXCIpO3JldHVyblt0LmtleSx0LnZhbHVlXS5mb3JFYWNoKGkpO2Nhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOnN3aXRjaCh0Lm9wZXJhdG9yKXtjYXNlXCIrXCI6Y2FzZVwiLVwiOnJldHVybiBpKHQuYXJndW1lbnQpO2RlZmF1bHQ6dGhyb3cgcihcIm9wZXJhdG9yXCIpfWNhc2VcIklkZW50aWZpZXJcIjppZihzJiZcIk9iamVjdFByb3BlcnR5XCI9PT1zLnR5cGUmJnMua2V5PT09dClyZXR1cm47dGhyb3cgcigpO2Nhc2VcIk51bGxMaXRlcmFsXCI6Y2FzZVwiQm9vbGVhbkxpdGVyYWxcIjpjYXNlXCJOdW1lcmljTGl0ZXJhbFwiOmNhc2VcIlN0cmluZ0xpdGVyYWxcIjpyZXR1cm47ZGVmYXVsdDp0aHJvdyByKCl9ZnVuY3Rpb24gaShlKXtyZXR1cm4gdGUoZSx0KX1mdW5jdGlvbiByKHMpe2NvbnN0IGk9cz9cIlwiLmNvbmNhdCh0LnR5cGUsXCIgd2l0aCBcIikuY29uY2F0KHMsXCI9XCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeSh0W3NdKSk6dC50eXBlO3JldHVybiBlKFwiXCIuY29uY2F0KGksXCIgaXMgbm90IGFsbG93ZWQgaW4gSlNPTi5cIikse3N0YXJ0OntsaW5lOnQubG9jLnN0YXJ0LmxpbmUsY29sdW1uOnQubG9jLnN0YXJ0LmNvbHVtbisxfX0pfX1jb25zdCBlZT1PYmplY3QuYXNzaWduKHtwYXJzZTpRdCxhc3RGb3JtYXQ6XCJlc3RyZWVcIixoYXNQcmFnbWE6SnR9LG0pLHNlPU9iamVjdC5hc3NpZ24oe30sZWUse3BhcnNlOll0fSksaWU9T2JqZWN0LmFzc2lnbih7fSxlZSx7cGFyc2U6JHR9KSxyZT1PYmplY3QuYXNzaWduKHt9LGVlLHtwYXJzZTpadH0pO3ZhciBhZT17cGFyc2Vyczp7YmFiZWw6ZWUsXCJiYWJlbC1mbG93XCI6c2UsXCJiYWJlbC10c1wiOmllLGpzb246T2JqZWN0LmFzc2lnbih7fSxyZSx7aGFzUHJhZ21hOigpPT4hMH0pLGpzb241OnJlLFwianNvbi1zdHJpbmdpZnlcIjpPYmplY3QuYXNzaWduKHtwYXJzZTpmdW5jdGlvbih0LGUscyl7Y29uc3QgaT1adCh0LGUscyk7cmV0dXJuIGkuY29tbWVudHMuZm9yRWFjaCh0ZSksdGUoaSksaX0sYXN0Rm9ybWF0OlwiZXN0cmVlLWpzb25cIn0sbSksX19qc19leHByZXNzaW9uOnJlLF9fdnVlX2V4cHJlc3Npb246cmUsX192dWVfZXZlbnRfYmluZGluZzplZX19LG5lPWFlLnBhcnNlcnM7dC5kZWZhdWx0PWFlLHQucGFyc2Vycz1uZSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prettier/parser-babel.js\n");

/***/ }),

/***/ "./node_modules/prettier/standalone.js":
/*!*********************************************!*\
  !*** ./node_modules/prettier/standalone.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {(function(global,factory){ true?module.exports=factory():undefined;})(void 0,function(){'use strict';var name=\"prettier\";var version=\"2.0.4\";var description=\"Prettier is an opinionated code formatter\";var bin=\"./bin/prettier.js\";var repository=\"prettier/prettier\";var homepage=\"https://prettier.io\";var author=\"James Long\";var license=\"MIT\";var main=\"./index.js\";var engines={node:\">=10.13.0\"};var dependencies={\"@angular/compiler\":\"9.0.5\",\"@babel/code-frame\":\"7.8.0\",\"@babel/parser\":\"7.9.4\",\"@glimmer/syntax\":\"0.50.0\",\"@iarna/toml\":\"2.2.3\",\"@typescript-eslint/typescript-estree\":\"2.26.0\",\"angular-estree-parser\":\"1.3.0\",\"angular-html-parser\":\"1.4.0\",camelcase:\"5.3.1\",chalk:\"4.0.0\",\"ci-info\":\"watson/ci-info#f43f6a1cefff47fb361c88cf4b943fdbcaafe540\",\"cjk-regex\":\"2.0.0\",cosmiconfig:\"6.0.0\",dashify:\"2.0.0\",dedent:\"0.7.0\",diff:\"4.0.2\",editorconfig:\"0.15.3\",\"editorconfig-to-prettier\":\"0.1.1\",\"escape-string-regexp\":\"2.0.0\",esutils:\"2.0.3\",\"fast-glob\":\"3.2.2\",\"find-parent-dir\":\"0.3.0\",\"find-project-root\":\"1.1.1\",\"flow-parser\":\"0.122.0\",\"get-stream\":\"5.1.0\",globby:\"11.0.0\",graphql:\"15.0.0\",\"html-element-attributes\":\"2.2.1\",\"html-styles\":\"1.0.0\",\"html-tag-names\":\"1.1.5\",ignore:\"4.0.6\",\"jest-docblock\":\"25.2.6\",\"json-stable-stringify\":\"1.0.1\",leven:\"3.1.0\",\"lines-and-columns\":\"1.1.6\",\"linguist-languages\":\"7.9.0\",lodash:\"4.17.15\",mem:\"6.0.1\",minimatch:\"3.0.4\",minimist:\"1.2.5\",\"n-readlines\":\"1.0.0\",\"please-upgrade-node\":\"3.2.0\",\"postcss-less\":\"3.1.4\",\"postcss-media-query-parser\":\"0.2.3\",\"postcss-scss\":\"2.0.0\",\"postcss-selector-parser\":\"2.2.3\",\"postcss-values-parser\":\"2.0.1\",\"regexp-util\":\"1.2.2\",\"remark-math\":\"1.0.6\",\"remark-parse\":\"5.0.0\",semver:\"7.1.3\",srcset:\"2.0.1\",\"string-width\":\"4.2.0\",typescript:\"3.8.3\",\"unicode-regex\":\"3.0.0\",unified:\"9.0.0\",vnopts:\"1.0.2\",\"yaml-unist-parser\":\"1.1.1\"};var devDependencies={\"@babel/core\":\"7.9.0\",\"@babel/preset-env\":\"7.9.0\",\"@rollup/plugin-alias\":\"3.0.1\",\"@rollup/plugin-commonjs\":\"11.0.2\",\"@rollup/plugin-json\":\"4.0.2\",\"@rollup/plugin-node-resolve\":\"7.1.1\",\"@rollup/plugin-replace\":\"2.3.1\",\"babel-loader\":\"8.1.0\",benchmark:\"2.1.4\",\"builtin-modules\":\"3.1.0\",codecov:\"3.6.5\",\"cross-env\":\"7.0.2\",cspell:\"4.0.55\",eslint:\"6.8.0\",\"eslint-config-prettier\":\"6.10.1\",\"eslint-formatter-friendly\":\"7.0.0\",\"eslint-plugin-import\":\"2.20.2\",\"eslint-plugin-prettier\":\"3.1.2\",\"eslint-plugin-react\":\"7.19.0\",\"eslint-plugin-unicorn\":\"18.0.1\",execa:\"4.0.0\",jest:\"25.2.7\",\"jest-snapshot-serializer-ansi\":\"1.0.0\",\"jest-snapshot-serializer-raw\":\"1.1.0\",\"jest-watch-typeahead\":\"0.5.0\",prettier:\"2.0.3\",rimraf:\"3.0.2\",rollup:\"2.3.2\",\"rollup-plugin-babel\":\"4.4.0\",\"rollup-plugin-node-globals\":\"1.4.0\",\"rollup-plugin-terser\":\"5.3.0\",shelljs:\"0.8.3\",\"snapshot-diff\":\"0.7.0\",\"strip-ansi\":\"6.0.0\",\"synchronous-promise\":\"2.0.10\",tempy:\"0.5.0\",\"terser-webpack-plugin\":\"2.3.5\",webpack:\"4.42.1\"};var scripts={prepublishOnly:\"echo \\\"Error: must publish from dist/\\\" && exit 1\",\"prepare-release\":\"yarn && yarn build && yarn test:dist\",test:\"jest\",\"test:dist\":\"node ./scripts/test-dist.js\",\"test:integration\":\"jest tests_integration\",\"perf:repeat\":\"yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null\",\"perf:repeat-inspect\":\"yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null\",\"perf:benchmark\":\"yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null\",\"lint:typecheck\":\"tsc\",\"lint:eslint\":\"cross-env EFF_NO_LINK_RULES=true eslint . --format friendly\",\"lint:changelog\":\"node ./scripts/lint-changelog.js\",\"lint:prettier\":\"prettier \\\"**/*.{md,json,yml,html,css}\\\" --check\",\"lint:dist\":\"eslint --no-eslintrc --no-ignore --env=es6,browser --parser-options=ecmaVersion:2016 \\\"dist/!(bin-prettier|index|third-party).js\\\"\",\"lint:spellcheck\":\"cspell {bin,scripts,src,website}/**/*.js {docs,website/blog,changelog_unreleased}/**/*.md\",\"lint:deps\":\"node ./scripts/check-deps.js\",build:\"node --max-old-space-size=3072 ./scripts/build/build.js\",\"build-docs\":\"node ./scripts/build-docs.js\"};var _package={name:name,version:version,description:description,bin:bin,repository:repository,homepage:homepage,author:author,license:license,main:main,engines:engines,dependencies:dependencies,devDependencies:devDependencies,scripts:scripts};var _package$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name,version:version,description:description,bin:bin,repository:repository,homepage:homepage,author:author,license:license,main:main,engines:engines,dependencies:dependencies,devDependencies:devDependencies,scripts:scripts,'default':_package});function Diff(){}Diff.prototype={diff:function diff(oldString,newString){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var callback=options.callback;if(typeof options==='function'){callback=options;options={};}this.options=options;var self=this;function done(value){if(callback){setTimeout(function(){callback(undefined,value);},0);return true;}else{return value;}}// Allow subclasses to massage the input prior to running\noldString=this.castInput(oldString);newString=this.castInput(newString);oldString=this.removeEmpty(this.tokenize(oldString));newString=this.removeEmpty(this.tokenize(newString));var newLen=newString.length,oldLen=oldString.length;var editLength=1;var maxEditLength=newLen+oldLen;var bestPath=[{newPos:-1,components:[]}];// Seed editLength = 0, i.e. the content starts with the same values\nvar oldPos=this.extractCommon(bestPath[0],newString,oldString,0);if(bestPath[0].newPos+1>=newLen&&oldPos+1>=oldLen){// Identity per the equality and tokenizer\nreturn done([{value:this.join(newString),count:newString.length}]);}// Main worker method. checks all permutations of a given edit length for acceptance.\nfunction execEditLength(){for(var diagonalPath=-1*editLength;diagonalPath<=editLength;diagonalPath+=2){var basePath=void 0;var addPath=bestPath[diagonalPath-1],removePath=bestPath[diagonalPath+1],_oldPos=(removePath?removePath.newPos:0)-diagonalPath;if(addPath){// No one else is going to attempt to use this value, clear it\nbestPath[diagonalPath-1]=undefined;}var canAdd=addPath&&addPath.newPos+1<newLen,canRemove=removePath&&0<=_oldPos&&_oldPos<oldLen;if(!canAdd&&!canRemove){// If this path is a terminal then prune\nbestPath[diagonalPath]=undefined;continue;}// Select the diagonal that we want to branch from. We select the prior\n// path whose position in the new string is the farthest from the origin\n// and does not pass the bounds of the diff graph\nif(!canAdd||canRemove&&addPath.newPos<removePath.newPos){basePath=clonePath(removePath);self.pushComponent(basePath.components,undefined,true);}else{basePath=addPath;// No need to clone, we've pulled it from the list\nbasePath.newPos++;self.pushComponent(basePath.components,true,undefined);}_oldPos=self.extractCommon(basePath,newString,oldString,diagonalPath);// If we have hit the end of both strings, then we are done\nif(basePath.newPos+1>=newLen&&_oldPos+1>=oldLen){return done(buildValues(self,basePath.components,newString,oldString,self.useLongestToken));}else{// Otherwise track this path as a potential candidate and continue.\nbestPath[diagonalPath]=basePath;}}editLength++;}// Performs the length of edit iteration. Is a bit fugly as this has to support the\n// sync and async mode which is never fun. Loops over execEditLength until a value\n// is produced.\nif(callback){(function exec(){setTimeout(function(){// This should not happen, but we want to be safe.\n/* istanbul ignore next */if(editLength>maxEditLength){return callback();}if(!execEditLength()){exec();}},0);})();}else{while(editLength<=maxEditLength){var ret=execEditLength();if(ret){return ret;}}}},pushComponent:function pushComponent(components,added,removed){var last=components[components.length-1];if(last&&last.added===added&&last.removed===removed){// We need to clone here as the component clone operation is just\n// as shallow array clone\ncomponents[components.length-1]={count:last.count+1,added:added,removed:removed};}else{components.push({count:1,added:added,removed:removed});}},extractCommon:function extractCommon(basePath,newString,oldString,diagonalPath){var newLen=newString.length,oldLen=oldString.length,newPos=basePath.newPos,oldPos=newPos-diagonalPath,commonCount=0;while(newPos+1<newLen&&oldPos+1<oldLen&&this.equals(newString[newPos+1],oldString[oldPos+1])){newPos++;oldPos++;commonCount++;}if(commonCount){basePath.components.push({count:commonCount});}basePath.newPos=newPos;return oldPos;},equals:function equals(left,right){if(this.options.comparator){return this.options.comparator(left,right);}else{return left===right||this.options.ignoreCase&&left.toLowerCase()===right.toLowerCase();}},removeEmpty:function removeEmpty(array){var ret=[];for(var i=0;i<array.length;i++){if(array[i]){ret.push(array[i]);}}return ret;},castInput:function castInput(value){return value;},tokenize:function tokenize(value){return value.split('');},join:function join(chars){return chars.join('');}};function buildValues(diff,components,newString,oldString,useLongestToken){var componentPos=0,componentLen=components.length,newPos=0,oldPos=0;for(;componentPos<componentLen;componentPos++){var component=components[componentPos];if(!component.removed){if(!component.added&&useLongestToken){var value=newString.slice(newPos,newPos+component.count);value=value.map(function(value,i){var oldValue=oldString[oldPos+i];return oldValue.length>value.length?oldValue:value;});component.value=diff.join(value);}else{component.value=diff.join(newString.slice(newPos,newPos+component.count));}newPos+=component.count;// Common case\nif(!component.added){oldPos+=component.count;}}else{component.value=diff.join(oldString.slice(oldPos,oldPos+component.count));oldPos+=component.count;// Reverse add and remove so removes are output first to match common convention\n// The diffing algorithm is tied to add then remove output and this is the simplest\n// route to get the desired output with minimal overhead.\nif(componentPos&&components[componentPos-1].added){var tmp=components[componentPos-1];components[componentPos-1]=components[componentPos];components[componentPos]=tmp;}}}// Special case handle for when one terminal is ignored (i.e. whitespace).\n// For this case we merge the terminal into the prior string and drop the change.\n// This is only available for string mode.\nvar lastComponent=components[componentLen-1];if(componentLen>1&&typeof lastComponent.value==='string'&&(lastComponent.added||lastComponent.removed)&&diff.equals('',lastComponent.value)){components[componentLen-2].value+=lastComponent.value;components.pop();}return components;}function clonePath(path){return{newPos:path.newPos,components:path.components.slice(0)};}var characterDiff=new Diff();function diffChars(oldStr,newStr,options){return characterDiff.diff(oldStr,newStr,options);}function generateOptions(options,defaults){if(typeof options==='function'){defaults.callback=options;}else if(options){for(var name in options){/* istanbul ignore else */if(options.hasOwnProperty(name)){defaults[name]=options[name];}}}return defaults;}//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\nvar extendedWordChars=/^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;var reWhitespace=/\\S/;var wordDiff=new Diff();wordDiff.equals=function(left,right){if(this.options.ignoreCase){left=left.toLowerCase();right=right.toLowerCase();}return left===right||this.options.ignoreWhitespace&&!reWhitespace.test(left)&&!reWhitespace.test(right);};wordDiff.tokenize=function(value){var tokens=value.split(/(\\s+|[()[\\]{}'\"]|\\b)/);// Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\nfor(var i=0;i<tokens.length-1;i++){// If we have an empty string in the next field and we have only word chars before and after, merge\nif(!tokens[i+1]&&tokens[i+2]&&extendedWordChars.test(tokens[i])&&extendedWordChars.test(tokens[i+2])){tokens[i]+=tokens[i+2];tokens.splice(i+1,2);i--;}}return tokens;};function diffWords(oldStr,newStr,options){options=generateOptions(options,{ignoreWhitespace:true});return wordDiff.diff(oldStr,newStr,options);}function diffWordsWithSpace(oldStr,newStr,options){return wordDiff.diff(oldStr,newStr,options);}var lineDiff=new Diff();lineDiff.tokenize=function(value){var retLines=[],linesAndNewlines=value.split(/(\\n|\\r\\n)/);// Ignore the final empty token that occurs if the string ends with a new line\nif(!linesAndNewlines[linesAndNewlines.length-1]){linesAndNewlines.pop();}// Merge the content and line separators into single tokens\nfor(var i=0;i<linesAndNewlines.length;i++){var line=linesAndNewlines[i];if(i%2&&!this.options.newlineIsToken){retLines[retLines.length-1]+=line;}else{if(this.options.ignoreWhitespace){line=line.trim();}retLines.push(line);}}return retLines;};function diffLines(oldStr,newStr,callback){return lineDiff.diff(oldStr,newStr,callback);}function diffTrimmedLines(oldStr,newStr,callback){var options=generateOptions(callback,{ignoreWhitespace:true});return lineDiff.diff(oldStr,newStr,options);}var sentenceDiff=new Diff();sentenceDiff.tokenize=function(value){return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);};function diffSentences(oldStr,newStr,callback){return sentenceDiff.diff(oldStr,newStr,callback);}var cssDiff=new Diff();cssDiff.tokenize=function(value){return value.split(/([{}:;,]|\\s+)/);};function diffCss(oldStr,newStr,callback){return cssDiff.diff(oldStr,newStr,callback);}function _typeof(obj){if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};}return _typeof(obj);}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_nonIterableSpread();}function _arrayWithoutHoles(arr){if(Array.isArray(arr)){for(var i=0,arr2=new Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2;}}function _iterableToArray(iter){if(Symbol.iterator in Object(iter)||Object.prototype.toString.call(iter)===\"[object Arguments]\")return Array.from(iter);}function _nonIterableSpread(){throw new TypeError(\"Invalid attempt to spread non-iterable instance\");}var objectPrototypeToString=Object.prototype.toString;var jsonDiff=new Diff();// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\njsonDiff.useLongestToken=true;jsonDiff.tokenize=lineDiff.tokenize;jsonDiff.castInput=function(value){var _this$options=this.options,undefinedReplacement=_this$options.undefinedReplacement,_this$options$stringi=_this$options.stringifyReplacer,stringifyReplacer=_this$options$stringi===void 0?function(k,v){return typeof v==='undefined'?undefinedReplacement:v;}:_this$options$stringi;return typeof value==='string'?value:JSON.stringify(canonicalize(value,null,null,stringifyReplacer),stringifyReplacer,'  ');};jsonDiff.equals=function(left,right){return Diff.prototype.equals.call(jsonDiff,left.replace(/,([\\r\\n])/g,'$1'),right.replace(/,([\\r\\n])/g,'$1'));};function diffJson(oldObj,newObj,options){return jsonDiff.diff(oldObj,newObj,options);}// This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\nfunction canonicalize(obj,stack,replacementStack,replacer,key){stack=stack||[];replacementStack=replacementStack||[];if(replacer){obj=replacer(key,obj);}var i;for(i=0;i<stack.length;i+=1){if(stack[i]===obj){return replacementStack[i];}}var canonicalizedObj;if('[object Array]'===objectPrototypeToString.call(obj)){stack.push(obj);canonicalizedObj=new Array(obj.length);replacementStack.push(canonicalizedObj);for(i=0;i<obj.length;i+=1){canonicalizedObj[i]=canonicalize(obj[i],stack,replacementStack,replacer,key);}stack.pop();replacementStack.pop();return canonicalizedObj;}if(obj&&obj.toJSON){obj=obj.toJSON();}if(_typeof(obj)==='object'&&obj!==null){stack.push(obj);canonicalizedObj={};replacementStack.push(canonicalizedObj);var sortedKeys=[],_key;for(_key in obj){/* istanbul ignore else */if(obj.hasOwnProperty(_key)){sortedKeys.push(_key);}}sortedKeys.sort();for(i=0;i<sortedKeys.length;i+=1){_key=sortedKeys[i];canonicalizedObj[_key]=canonicalize(obj[_key],stack,replacementStack,replacer,_key);}stack.pop();replacementStack.pop();}else{canonicalizedObj=obj;}return canonicalizedObj;}var arrayDiff=new Diff();arrayDiff.tokenize=function(value){return value.slice();};arrayDiff.join=arrayDiff.removeEmpty=function(value){return value;};function diffArrays(oldArr,newArr,callback){return arrayDiff.diff(oldArr,newArr,callback);}function parsePatch(uniDiff){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var diffstr=uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),delimiters=uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g)||[],list=[],i=0;function parseIndex(){var index={};list.push(index);// Parse diff metadata\nwhile(i<diffstr.length){var line=diffstr[i];// File header found, end parsing diff metadata\nif(/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)){break;}// Diff index\nvar header=/^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);if(header){index.index=header[1];}i++;}// Parse file headers if they are defined. Unified diff requires them, but\n// there's no technical issues to have an isolated hunk without file header\nparseFileHeader(index);parseFileHeader(index);// Parse hunks\nindex.hunks=[];while(i<diffstr.length){var _line=diffstr[i];if(/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)){break;}else if(/^@@/.test(_line)){index.hunks.push(parseHunk());}else if(_line&&options.strict){// Ignore unexpected content unless in strict mode\nthrow new Error('Unknown line '+(i+1)+' '+JSON.stringify(_line));}else{i++;}}}// Parses the --- and +++ headers, if none are found, no lines\n// are consumed.\nfunction parseFileHeader(index){var fileHeader=/^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);if(fileHeader){var keyPrefix=fileHeader[1]==='---'?'old':'new';var data=fileHeader[2].split('\\t',2);var fileName=data[0].replace(/\\\\\\\\/g,'\\\\');if(/^\".*\"$/.test(fileName)){fileName=fileName.substr(1,fileName.length-2);}index[keyPrefix+'FileName']=fileName;index[keyPrefix+'Header']=(data[1]||'').trim();i++;}}// Parses a hunk\n// This assumes that we are at the start of a hunk.\nfunction parseHunk(){var chunkHeaderIndex=i,chunkHeaderLine=diffstr[i++],chunkHeader=chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);var hunk={oldStart:+chunkHeader[1],oldLines:+chunkHeader[2]||1,newStart:+chunkHeader[3],newLines:+chunkHeader[4]||1,lines:[],linedelimiters:[]};var addCount=0,removeCount=0;for(;i<diffstr.length;i++){// Lines starting with '---' could be mistaken for the \"remove line\" operation\n// But they could be the header for the next file. Therefore prune such cases out.\nif(diffstr[i].indexOf('--- ')===0&&i+2<diffstr.length&&diffstr[i+1].indexOf('+++ ')===0&&diffstr[i+2].indexOf('@@')===0){break;}var operation=diffstr[i].length==0&&i!=diffstr.length-1?' ':diffstr[i][0];if(operation==='+'||operation==='-'||operation===' '||operation==='\\\\'){hunk.lines.push(diffstr[i]);hunk.linedelimiters.push(delimiters[i]||'\\n');if(operation==='+'){addCount++;}else if(operation==='-'){removeCount++;}else if(operation===' '){addCount++;removeCount++;}}else{break;}}// Handle the empty block count case\nif(!addCount&&hunk.newLines===1){hunk.newLines=0;}if(!removeCount&&hunk.oldLines===1){hunk.oldLines=0;}// Perform optional sanity checking\nif(options.strict){if(addCount!==hunk.newLines){throw new Error('Added line count did not match for hunk at line '+(chunkHeaderIndex+1));}if(removeCount!==hunk.oldLines){throw new Error('Removed line count did not match for hunk at line '+(chunkHeaderIndex+1));}}return hunk;}while(i<diffstr.length){parseIndex();}return list;}// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator(start,minLine,maxLine){var wantForward=true,backwardExhausted=false,forwardExhausted=false,localOffset=1;return function iterator(){if(wantForward&&!forwardExhausted){if(backwardExhausted){localOffset++;}else{wantForward=false;}// Check if trying to fit beyond text length, and if not, check it fits\n// after offset location (or desired location on first iteration)\nif(start+localOffset<=maxLine){return localOffset;}forwardExhausted=true;}if(!backwardExhausted){if(!forwardExhausted){wantForward=true;}// Check if trying to fit before text beginning, and if not, check it fits\n// before offset location\nif(minLine<=start-localOffset){return-localOffset++;}backwardExhausted=true;return iterator();}// We tried to fit hunk before text beginning and beyond text length, then\n// hunk can't fit on the text. Return undefined\n};}function applyPatch(source,uniDiff){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};if(typeof uniDiff==='string'){uniDiff=parsePatch(uniDiff);}if(Array.isArray(uniDiff)){if(uniDiff.length>1){throw new Error('applyPatch only works with a single input.');}uniDiff=uniDiff[0];}// Apply the diff to the input\nvar lines=source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),delimiters=source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g)||[],hunks=uniDiff.hunks,compareLine=options.compareLine||function(lineNumber,line,operation,patchContent){return line===patchContent;},errorCount=0,fuzzFactor=options.fuzzFactor||0,minLine=0,offset=0,removeEOFNL,addEOFNL;/**\n     * Checks if the hunk exactly fits on the provided location\n     */function hunkFits(hunk,toPos){for(var j=0;j<hunk.lines.length;j++){var line=hunk.lines[j],operation=line.length>0?line[0]:' ',content=line.length>0?line.substr(1):line;if(operation===' '||operation==='-'){// Context sanity check\nif(!compareLine(toPos+1,lines[toPos],operation,content)){errorCount++;if(errorCount>fuzzFactor){return false;}}toPos++;}}return true;}// Search best fit offsets for each hunk based on the previous ones\nfor(var i=0;i<hunks.length;i++){var hunk=hunks[i],maxLine=lines.length-hunk.oldLines,localOffset=0,toPos=offset+hunk.oldStart-1;var iterator=distanceIterator(toPos,minLine,maxLine);for(;localOffset!==undefined;localOffset=iterator()){if(hunkFits(hunk,toPos+localOffset)){hunk.offset=offset+=localOffset;break;}}if(localOffset===undefined){return false;}// Set lower text limit to end of the current hunk, so next ones don't try\n// to fit over already patched text\nminLine=hunk.offset+hunk.oldStart+hunk.oldLines;}// Apply patch hunks\nvar diffOffset=0;for(var _i=0;_i<hunks.length;_i++){var _hunk=hunks[_i],_toPos=_hunk.oldStart+_hunk.offset+diffOffset-1;diffOffset+=_hunk.newLines-_hunk.oldLines;if(_toPos<0){// Creating a new file\n_toPos=0;}for(var j=0;j<_hunk.lines.length;j++){var line=_hunk.lines[j],operation=line.length>0?line[0]:' ',content=line.length>0?line.substr(1):line,delimiter=_hunk.linedelimiters[j];if(operation===' '){_toPos++;}else if(operation==='-'){lines.splice(_toPos,1);delimiters.splice(_toPos,1);/* istanbul ignore else */}else if(operation==='+'){lines.splice(_toPos,0,content);delimiters.splice(_toPos,0,delimiter);_toPos++;}else if(operation==='\\\\'){var previousOperation=_hunk.lines[j-1]?_hunk.lines[j-1][0]:null;if(previousOperation==='+'){removeEOFNL=true;}else if(previousOperation==='-'){addEOFNL=true;}}}}// Handle EOFNL insertion/removal\nif(removeEOFNL){while(!lines[lines.length-1]){lines.pop();delimiters.pop();}}else if(addEOFNL){lines.push('');delimiters.push('\\n');}for(var _k=0;_k<lines.length-1;_k++){lines[_k]=lines[_k]+delimiters[_k];}return lines.join('');}// Wrapper that supports multiple file patches via callbacks.\nfunction applyPatches(uniDiff,options){if(typeof uniDiff==='string'){uniDiff=parsePatch(uniDiff);}var currentIndex=0;function processIndex(){var index=uniDiff[currentIndex++];if(!index){return options.complete();}options.loadFile(index,function(err,data){if(err){return options.complete(err);}var updatedContent=applyPatch(data,index,options);options.patched(index,updatedContent,function(err){if(err){return options.complete(err);}processIndex();});});}processIndex();}function structuredPatch(oldFileName,newFileName,oldStr,newStr,oldHeader,newHeader,options){if(!options){options={};}if(typeof options.context==='undefined'){options.context=4;}var diff=diffLines(oldStr,newStr,options);diff.push({value:'',lines:[]});// Append an empty value to make cleanup easier\nfunction contextLines(lines){return lines.map(function(entry){return' '+entry;});}var hunks=[];var oldRangeStart=0,newRangeStart=0,curRange=[],oldLine=1,newLine=1;var _loop=function _loop(i){var current=diff[i],lines=current.lines||current.value.replace(/\\n$/,'').split('\\n');current.lines=lines;if(current.added||current.removed){var _curRange;// If we have previous context, start with that\nif(!oldRangeStart){var prev=diff[i-1];oldRangeStart=oldLine;newRangeStart=newLine;if(prev){curRange=options.context>0?contextLines(prev.lines.slice(-options.context)):[];oldRangeStart-=curRange.length;newRangeStart-=curRange.length;}}// Output our changes\n(_curRange=curRange).push.apply(_curRange,_toConsumableArray(lines.map(function(entry){return(current.added?'+':'-')+entry;})));// Track the updated file position\nif(current.added){newLine+=lines.length;}else{oldLine+=lines.length;}}else{// Identical context lines. Track line changes\nif(oldRangeStart){// Close out any changes that have been output (or join overlapping)\nif(lines.length<=options.context*2&&i<diff.length-2){var _curRange2;// Overlapping\n(_curRange2=curRange).push.apply(_curRange2,_toConsumableArray(contextLines(lines)));}else{var _curRange3;// end the range and output\nvar contextSize=Math.min(lines.length,options.context);(_curRange3=curRange).push.apply(_curRange3,_toConsumableArray(contextLines(lines.slice(0,contextSize))));var hunk={oldStart:oldRangeStart,oldLines:oldLine-oldRangeStart+contextSize,newStart:newRangeStart,newLines:newLine-newRangeStart+contextSize,lines:curRange};if(i>=diff.length-2&&lines.length<=options.context){// EOF is inside this hunk\nvar oldEOFNewline=/\\n$/.test(oldStr);var newEOFNewline=/\\n$/.test(newStr);var noNlBeforeAdds=lines.length==0&&curRange.length>hunk.oldLines;if(!oldEOFNewline&&noNlBeforeAdds){// special case: old has no eol and no trailing context; no-nl can end up before adds\ncurRange.splice(hunk.oldLines,0,'\\\\ No newline at end of file');}if(!oldEOFNewline&&!noNlBeforeAdds||!newEOFNewline){curRange.push('\\\\ No newline at end of file');}}hunks.push(hunk);oldRangeStart=0;newRangeStart=0;curRange=[];}}oldLine+=lines.length;newLine+=lines.length;}};for(var i=0;i<diff.length;i++){_loop(i);}return{oldFileName:oldFileName,newFileName:newFileName,oldHeader:oldHeader,newHeader:newHeader,hunks:hunks};}function createTwoFilesPatch(oldFileName,newFileName,oldStr,newStr,oldHeader,newHeader,options){var diff=structuredPatch(oldFileName,newFileName,oldStr,newStr,oldHeader,newHeader,options);var ret=[];if(oldFileName==newFileName){ret.push('Index: '+oldFileName);}ret.push('===================================================================');ret.push('--- '+diff.oldFileName+(typeof diff.oldHeader==='undefined'?'':'\\t'+diff.oldHeader));ret.push('+++ '+diff.newFileName+(typeof diff.newHeader==='undefined'?'':'\\t'+diff.newHeader));for(var i=0;i<diff.hunks.length;i++){var hunk=diff.hunks[i];ret.push('@@ -'+hunk.oldStart+','+hunk.oldLines+' +'+hunk.newStart+','+hunk.newLines+' @@');ret.push.apply(ret,hunk.lines);}return ret.join('\\n')+'\\n';}function createPatch(fileName,oldStr,newStr,oldHeader,newHeader,options){return createTwoFilesPatch(fileName,fileName,oldStr,newStr,oldHeader,newHeader,options);}function arrayEqual(a,b){if(a.length!==b.length){return false;}return arrayStartsWith(a,b);}function arrayStartsWith(array,start){if(start.length>array.length){return false;}for(var i=0;i<start.length;i++){if(start[i]!==array[i]){return false;}}return true;}function calcLineCount(hunk){var _calcOldNewLineCount=calcOldNewLineCount(hunk.lines),oldLines=_calcOldNewLineCount.oldLines,newLines=_calcOldNewLineCount.newLines;if(oldLines!==undefined){hunk.oldLines=oldLines;}else{delete hunk.oldLines;}if(newLines!==undefined){hunk.newLines=newLines;}else{delete hunk.newLines;}}function merge(mine,theirs,base){mine=loadPatch(mine,base);theirs=loadPatch(theirs,base);var ret={};// For index we just let it pass through as it doesn't have any necessary meaning.\n// Leaving sanity checks on this to the API consumer that may know more about the\n// meaning in their own context.\nif(mine.index||theirs.index){ret.index=mine.index||theirs.index;}if(mine.newFileName||theirs.newFileName){if(!fileNameChanged(mine)){// No header or no change in ours, use theirs (and ours if theirs does not exist)\nret.oldFileName=theirs.oldFileName||mine.oldFileName;ret.newFileName=theirs.newFileName||mine.newFileName;ret.oldHeader=theirs.oldHeader||mine.oldHeader;ret.newHeader=theirs.newHeader||mine.newHeader;}else if(!fileNameChanged(theirs)){// No header or no change in theirs, use ours\nret.oldFileName=mine.oldFileName;ret.newFileName=mine.newFileName;ret.oldHeader=mine.oldHeader;ret.newHeader=mine.newHeader;}else{// Both changed... figure it out\nret.oldFileName=selectField(ret,mine.oldFileName,theirs.oldFileName);ret.newFileName=selectField(ret,mine.newFileName,theirs.newFileName);ret.oldHeader=selectField(ret,mine.oldHeader,theirs.oldHeader);ret.newHeader=selectField(ret,mine.newHeader,theirs.newHeader);}}ret.hunks=[];var mineIndex=0,theirsIndex=0,mineOffset=0,theirsOffset=0;while(mineIndex<mine.hunks.length||theirsIndex<theirs.hunks.length){var mineCurrent=mine.hunks[mineIndex]||{oldStart:Infinity},theirsCurrent=theirs.hunks[theirsIndex]||{oldStart:Infinity};if(hunkBefore(mineCurrent,theirsCurrent)){// This patch does not overlap with any of the others, yay.\nret.hunks.push(cloneHunk(mineCurrent,mineOffset));mineIndex++;theirsOffset+=mineCurrent.newLines-mineCurrent.oldLines;}else if(hunkBefore(theirsCurrent,mineCurrent)){// This patch does not overlap with any of the others, yay.\nret.hunks.push(cloneHunk(theirsCurrent,theirsOffset));theirsIndex++;mineOffset+=theirsCurrent.newLines-theirsCurrent.oldLines;}else{// Overlap, merge as best we can\nvar mergedHunk={oldStart:Math.min(mineCurrent.oldStart,theirsCurrent.oldStart),oldLines:0,newStart:Math.min(mineCurrent.newStart+mineOffset,theirsCurrent.oldStart+theirsOffset),newLines:0,lines:[]};mergeLines(mergedHunk,mineCurrent.oldStart,mineCurrent.lines,theirsCurrent.oldStart,theirsCurrent.lines);theirsIndex++;mineIndex++;ret.hunks.push(mergedHunk);}}return ret;}function loadPatch(param,base){if(typeof param==='string'){if(/^@@/m.test(param)||/^Index:/m.test(param)){return parsePatch(param)[0];}if(!base){throw new Error('Must provide a base reference or pass in a patch');}return structuredPatch(undefined,undefined,base,param);}return param;}function fileNameChanged(patch){return patch.newFileName&&patch.newFileName!==patch.oldFileName;}function selectField(index,mine,theirs){if(mine===theirs){return mine;}else{index.conflict=true;return{mine:mine,theirs:theirs};}}function hunkBefore(test,check){return test.oldStart<check.oldStart&&test.oldStart+test.oldLines<check.oldStart;}function cloneHunk(hunk,offset){return{oldStart:hunk.oldStart,oldLines:hunk.oldLines,newStart:hunk.newStart+offset,newLines:hunk.newLines,lines:hunk.lines};}function mergeLines(hunk,mineOffset,mineLines,theirOffset,theirLines){// This will generally result in a conflicted hunk, but there are cases where the context\n// is the only overlap where we can successfully merge the content here.\nvar mine={offset:mineOffset,lines:mineLines,index:0},their={offset:theirOffset,lines:theirLines,index:0};// Handle any leading content\ninsertLeading(hunk,mine,their);insertLeading(hunk,their,mine);// Now in the overlap content. Scan through and select the best changes from each.\nwhile(mine.index<mine.lines.length&&their.index<their.lines.length){var mineCurrent=mine.lines[mine.index],theirCurrent=their.lines[their.index];if((mineCurrent[0]==='-'||mineCurrent[0]==='+')&&(theirCurrent[0]==='-'||theirCurrent[0]==='+')){// Both modified ...\nmutualChange(hunk,mine,their);}else if(mineCurrent[0]==='+'&&theirCurrent[0]===' '){var _hunk$lines;// Mine inserted\n(_hunk$lines=hunk.lines).push.apply(_hunk$lines,_toConsumableArray(collectChange(mine)));}else if(theirCurrent[0]==='+'&&mineCurrent[0]===' '){var _hunk$lines2;// Theirs inserted\n(_hunk$lines2=hunk.lines).push.apply(_hunk$lines2,_toConsumableArray(collectChange(their)));}else if(mineCurrent[0]==='-'&&theirCurrent[0]===' '){// Mine removed or edited\nremoval(hunk,mine,their);}else if(theirCurrent[0]==='-'&&mineCurrent[0]===' '){// Their removed or edited\nremoval(hunk,their,mine,true);}else if(mineCurrent===theirCurrent){// Context identity\nhunk.lines.push(mineCurrent);mine.index++;their.index++;}else{// Context mismatch\nconflict(hunk,collectChange(mine),collectChange(their));}}// Now push anything that may be remaining\ninsertTrailing(hunk,mine);insertTrailing(hunk,their);calcLineCount(hunk);}function mutualChange(hunk,mine,their){var myChanges=collectChange(mine),theirChanges=collectChange(their);if(allRemoves(myChanges)&&allRemoves(theirChanges)){// Special case for remove changes that are supersets of one another\nif(arrayStartsWith(myChanges,theirChanges)&&skipRemoveSuperset(their,myChanges,myChanges.length-theirChanges.length)){var _hunk$lines3;(_hunk$lines3=hunk.lines).push.apply(_hunk$lines3,_toConsumableArray(myChanges));return;}else if(arrayStartsWith(theirChanges,myChanges)&&skipRemoveSuperset(mine,theirChanges,theirChanges.length-myChanges.length)){var _hunk$lines4;(_hunk$lines4=hunk.lines).push.apply(_hunk$lines4,_toConsumableArray(theirChanges));return;}}else if(arrayEqual(myChanges,theirChanges)){var _hunk$lines5;(_hunk$lines5=hunk.lines).push.apply(_hunk$lines5,_toConsumableArray(myChanges));return;}conflict(hunk,myChanges,theirChanges);}function removal(hunk,mine,their,swap){var myChanges=collectChange(mine),theirChanges=collectContext(their,myChanges);if(theirChanges.merged){var _hunk$lines6;(_hunk$lines6=hunk.lines).push.apply(_hunk$lines6,_toConsumableArray(theirChanges.merged));}else{conflict(hunk,swap?theirChanges:myChanges,swap?myChanges:theirChanges);}}function conflict(hunk,mine,their){hunk.conflict=true;hunk.lines.push({conflict:true,mine:mine,theirs:their});}function insertLeading(hunk,insert,their){while(insert.offset<their.offset&&insert.index<insert.lines.length){var line=insert.lines[insert.index++];hunk.lines.push(line);insert.offset++;}}function insertTrailing(hunk,insert){while(insert.index<insert.lines.length){var line=insert.lines[insert.index++];hunk.lines.push(line);}}function collectChange(state){var ret=[],operation=state.lines[state.index][0];while(state.index<state.lines.length){var line=state.lines[state.index];// Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\nif(operation==='-'&&line[0]==='+'){operation='+';}if(operation===line[0]){ret.push(line);state.index++;}else{break;}}return ret;}function collectContext(state,matchChanges){var changes=[],merged=[],matchIndex=0,contextChanges=false,conflicted=false;while(matchIndex<matchChanges.length&&state.index<state.lines.length){var change=state.lines[state.index],match=matchChanges[matchIndex];// Once we've hit our add, then we are done\nif(match[0]==='+'){break;}contextChanges=contextChanges||change[0]!==' ';merged.push(match);matchIndex++;// Consume any additions in the other block as a conflict to attempt\n// to pull in the remaining context after this\nif(change[0]==='+'){conflicted=true;while(change[0]==='+'){changes.push(change);change=state.lines[++state.index];}}if(match.substr(1)===change.substr(1)){changes.push(change);state.index++;}else{conflicted=true;}}if((matchChanges[matchIndex]||'')[0]==='+'&&contextChanges){conflicted=true;}if(conflicted){return changes;}while(matchIndex<matchChanges.length){merged.push(matchChanges[matchIndex++]);}return{merged:merged,changes:changes};}function allRemoves(changes){return changes.reduce(function(prev,change){return prev&&change[0]==='-';},true);}function skipRemoveSuperset(state,removeChanges,delta){for(var i=0;i<delta;i++){var changeContent=removeChanges[removeChanges.length-delta+i].substr(1);if(state.lines[state.index+i]!==' '+changeContent){return false;}}state.index+=delta;return true;}function calcOldNewLineCount(lines){var oldLines=0;var newLines=0;lines.forEach(function(line){if(typeof line!=='string'){var myCount=calcOldNewLineCount(line.mine);var theirCount=calcOldNewLineCount(line.theirs);if(oldLines!==undefined){if(myCount.oldLines===theirCount.oldLines){oldLines+=myCount.oldLines;}else{oldLines=undefined;}}if(newLines!==undefined){if(myCount.newLines===theirCount.newLines){newLines+=myCount.newLines;}else{newLines=undefined;}}}else{if(newLines!==undefined&&(line[0]==='+'||line[0]===' ')){newLines++;}if(oldLines!==undefined&&(line[0]==='-'||line[0]===' ')){oldLines++;}}});return{oldLines:oldLines,newLines:newLines};}// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes){var ret=[],change,operation;for(var i=0;i<changes.length;i++){change=changes[i];if(change.added){operation=1;}else if(change.removed){operation=-1;}else{operation=0;}ret.push([operation,change.value]);}return ret;}function convertChangesToXML(changes){var ret=[];for(var i=0;i<changes.length;i++){var change=changes[i];if(change.added){ret.push('<ins>');}else if(change.removed){ret.push('<del>');}ret.push(escapeHTML(change.value));if(change.added){ret.push('</ins>');}else if(change.removed){ret.push('</del>');}}return ret.join('');}function escapeHTML(s){var n=s;n=n.replace(/&/g,'&amp;');n=n.replace(/</g,'&lt;');n=n.replace(/>/g,'&gt;');n=n.replace(/\"/g,'&quot;');return n;}var index_es6=/*#__PURE__*/Object.freeze({__proto__:null,Diff:Diff,diffChars:diffChars,diffWords:diffWords,diffWordsWithSpace:diffWordsWithSpace,diffLines:diffLines,diffTrimmedLines:diffTrimmedLines,diffSentences:diffSentences,diffCss:diffCss,diffJson:diffJson,diffArrays:diffArrays,structuredPatch:structuredPatch,createTwoFilesPatch:createTwoFilesPatch,createPatch:createPatch,applyPatch:applyPatch,applyPatches:applyPatches,parsePatch:parsePatch,merge:merge,convertChangesToDMP:convertChangesToDMP,convertChangesToXML:convertChangesToXML,canonicalize:canonicalize});var _shim_fs={};var _shim_fs$1=/*#__PURE__*/Object.freeze({__proto__:null,'default':_shim_fs});const sep=/[\\\\/]/;function extname(path){const filename=basename(path);const dotIndex=filename.lastIndexOf(\".\");if(dotIndex===-1)return\"\";return filename.slice(dotIndex);}function basename(path){return path.split(sep).pop();}function isAbsolute(){return true;}var path=/*#__PURE__*/Object.freeze({__proto__:null,extname:extname,basename:basename,isAbsolute:isAbsolute});var global$1=typeof global!==\"undefined\"?global:typeof self!==\"undefined\"?self:typeof window!==\"undefined\"?window:{};var lookup=[];var revLookup=[];var Arr=typeof Uint8Array!=='undefined'?Uint8Array:Array;var inited=false;function init(){inited=true;var code='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';for(var i=0,len=code.length;i<len;++i){lookup[i]=code[i];revLookup[code.charCodeAt(i)]=i;}revLookup['-'.charCodeAt(0)]=62;revLookup['_'.charCodeAt(0)]=63;}function toByteArray(b64){if(!inited){init();}var i,j,l,tmp,placeHolders,arr;var len=b64.length;if(len%4>0){throw new Error('Invalid string. Length must be a multiple of 4');}// the number of equal signs (place holders)\n// if there are two placeholders, than the two characters before it\n// represent one byte\n// if there is only one, then the three characters before it represent 2 bytes\n// this is just a cheap hack to not do indexOf twice\nplaceHolders=b64[len-2]==='='?2:b64[len-1]==='='?1:0;// base64 is 4/3 + up to two characters of the original data\narr=new Arr(len*3/4-placeHolders);// if there are placeholders, only get up to the last complete 4 chars\nl=placeHolders>0?len-4:len;var L=0;for(i=0,j=0;i<l;i+=4,j+=3){tmp=revLookup[b64.charCodeAt(i)]<<18|revLookup[b64.charCodeAt(i+1)]<<12|revLookup[b64.charCodeAt(i+2)]<<6|revLookup[b64.charCodeAt(i+3)];arr[L++]=tmp>>16&0xFF;arr[L++]=tmp>>8&0xFF;arr[L++]=tmp&0xFF;}if(placeHolders===2){tmp=revLookup[b64.charCodeAt(i)]<<2|revLookup[b64.charCodeAt(i+1)]>>4;arr[L++]=tmp&0xFF;}else if(placeHolders===1){tmp=revLookup[b64.charCodeAt(i)]<<10|revLookup[b64.charCodeAt(i+1)]<<4|revLookup[b64.charCodeAt(i+2)]>>2;arr[L++]=tmp>>8&0xFF;arr[L++]=tmp&0xFF;}return arr;}function tripletToBase64(num){return lookup[num>>18&0x3F]+lookup[num>>12&0x3F]+lookup[num>>6&0x3F]+lookup[num&0x3F];}function encodeChunk(uint8,start,end){var tmp;var output=[];for(var i=start;i<end;i+=3){tmp=(uint8[i]<<16)+(uint8[i+1]<<8)+uint8[i+2];output.push(tripletToBase64(tmp));}return output.join('');}function fromByteArray(uint8){if(!inited){init();}var tmp;var len=uint8.length;var extraBytes=len%3;// if we have 1 byte left, pad 2 bytes\nvar output='';var parts=[];var maxChunkLength=16383;// must be multiple of 3\n// go through the array every three bytes, we'll deal with trailing stuff later\nfor(var i=0,len2=len-extraBytes;i<len2;i+=maxChunkLength){parts.push(encodeChunk(uint8,i,i+maxChunkLength>len2?len2:i+maxChunkLength));}// pad the end with zeros, but make sure to not forget the extra bytes\nif(extraBytes===1){tmp=uint8[len-1];output+=lookup[tmp>>2];output+=lookup[tmp<<4&0x3F];output+='==';}else if(extraBytes===2){tmp=(uint8[len-2]<<8)+uint8[len-1];output+=lookup[tmp>>10];output+=lookup[tmp>>4&0x3F];output+=lookup[tmp<<2&0x3F];output+='=';}parts.push(output);return parts.join('');}function read(buffer,offset,isLE,mLen,nBytes){var e,m;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var nBits=-7;var i=isLE?nBytes-1:0;var d=isLE?-1:1;var s=buffer[offset+i];i+=d;e=s&(1<<-nBits)-1;s>>=-nBits;nBits+=eLen;for(;nBits>0;e=e*256+buffer[offset+i],i+=d,nBits-=8){}m=e&(1<<-nBits)-1;e>>=-nBits;nBits+=mLen;for(;nBits>0;m=m*256+buffer[offset+i],i+=d,nBits-=8){}if(e===0){e=1-eBias;}else if(e===eMax){return m?NaN:(s?-1:1)*Infinity;}else{m=m+Math.pow(2,mLen);e=e-eBias;}return(s?-1:1)*m*Math.pow(2,e-mLen);}function write(buffer,value,offset,isLE,mLen,nBytes){var e,m,c;var eLen=nBytes*8-mLen-1;var eMax=(1<<eLen)-1;var eBias=eMax>>1;var rt=mLen===23?Math.pow(2,-24)-Math.pow(2,-77):0;var i=isLE?0:nBytes-1;var d=isLE?1:-1;var s=value<0||value===0&&1/value<0?1:0;value=Math.abs(value);if(isNaN(value)||value===Infinity){m=isNaN(value)?1:0;e=eMax;}else{e=Math.floor(Math.log(value)/Math.LN2);if(value*(c=Math.pow(2,-e))<1){e--;c*=2;}if(e+eBias>=1){value+=rt/c;}else{value+=rt*Math.pow(2,1-eBias);}if(value*c>=2){e++;c/=2;}if(e+eBias>=eMax){m=0;e=eMax;}else if(e+eBias>=1){m=(value*c-1)*Math.pow(2,mLen);e=e+eBias;}else{m=value*Math.pow(2,eBias-1)*Math.pow(2,mLen);e=0;}}for(;mLen>=8;buffer[offset+i]=m&0xff,i+=d,m/=256,mLen-=8){}e=e<<mLen|m;eLen+=mLen;for(;eLen>0;buffer[offset+i]=e&0xff,i+=d,e/=256,eLen-=8){}buffer[offset+i-d]|=s*128;}var toString={}.toString;var isArray=Array.isArray||function(arr){return toString.call(arr)=='[object Array]';};var INSPECT_MAX_BYTES=50;/**\n   * If `Buffer.TYPED_ARRAY_SUPPORT`:\n   *   === true    Use Uint8Array implementation (fastest)\n   *   === false   Use Object implementation (most compatible, even IE6)\n   *\n   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n   * Opera 11.6+, iOS 4.2+.\n   *\n   * Due to various browser bugs, sometimes the Object implementation will be used even\n   * when the browser supports typed arrays.\n   *\n   * Note:\n   *\n   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n   *\n   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n   *\n   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n   *     incorrect length in some situations.\n\n   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n   * get the Object implementation, which is slower but behaves correctly.\n   */Buffer.TYPED_ARRAY_SUPPORT=global$1.TYPED_ARRAY_SUPPORT!==undefined?global$1.TYPED_ARRAY_SUPPORT:true;function kMaxLength(){return Buffer.TYPED_ARRAY_SUPPORT?0x7fffffff:0x3fffffff;}function createBuffer(that,length){if(kMaxLength()<length){throw new RangeError('Invalid typed array length');}if(Buffer.TYPED_ARRAY_SUPPORT){// Return an augmented `Uint8Array` instance, for best performance\nthat=new Uint8Array(length);that.__proto__=Buffer.prototype;}else{// Fallback: Return an object instance of the Buffer class\nif(that===null){that=new Buffer(length);}that.length=length;}return that;}/**\n   * The Buffer constructor returns instances of `Uint8Array` that have their\n   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n   * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n   * returns a single octet.\n   *\n   * The `Uint8Array` prototype remains unmodified.\n   */function Buffer(arg,encodingOrOffset,length){if(!Buffer.TYPED_ARRAY_SUPPORT&&!(this instanceof Buffer)){return new Buffer(arg,encodingOrOffset,length);}// Common case.\nif(typeof arg==='number'){if(typeof encodingOrOffset==='string'){throw new Error('If encoding is specified then the first argument must be a string');}return allocUnsafe(this,arg);}return from(this,arg,encodingOrOffset,length);}Buffer.poolSize=8192;// not used by this implementation\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment=function(arr){arr.__proto__=Buffer.prototype;return arr;};function from(that,value,encodingOrOffset,length){if(typeof value==='number'){throw new TypeError('\"value\" argument must not be a number');}if(typeof ArrayBuffer!=='undefined'&&value instanceof ArrayBuffer){return fromArrayBuffer(that,value,encodingOrOffset,length);}if(typeof value==='string'){return fromString(that,value,encodingOrOffset);}return fromObject(that,value);}/**\n   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n   * if value is a number.\n   * Buffer.from(str[, encoding])\n   * Buffer.from(array)\n   * Buffer.from(buffer)\n   * Buffer.from(arrayBuffer[, byteOffset[, length]])\n   **/Buffer.from=function(value,encodingOrOffset,length){return from(null,value,encodingOrOffset,length);};if(Buffer.TYPED_ARRAY_SUPPORT){Buffer.prototype.__proto__=Uint8Array.prototype;Buffer.__proto__=Uint8Array;}function assertSize(size){if(typeof size!=='number'){throw new TypeError('\"size\" argument must be a number');}else if(size<0){throw new RangeError('\"size\" argument must not be negative');}}function alloc(that,size,fill,encoding){assertSize(size);if(size<=0){return createBuffer(that,size);}if(fill!==undefined){// Only pay attention to encoding if it's a string. This\n// prevents accidentally sending in a number that would\n// be interpretted as a start offset.\nreturn typeof encoding==='string'?createBuffer(that,size).fill(fill,encoding):createBuffer(that,size).fill(fill);}return createBuffer(that,size);}/**\n   * Creates a new filled Buffer instance.\n   * alloc(size[, fill[, encoding]])\n   **/Buffer.alloc=function(size,fill,encoding){return alloc(null,size,fill,encoding);};function allocUnsafe(that,size){assertSize(size);that=createBuffer(that,size<0?0:checked(size)|0);if(!Buffer.TYPED_ARRAY_SUPPORT){for(var i=0;i<size;++i){that[i]=0;}}return that;}/**\n   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n   * */Buffer.allocUnsafe=function(size){return allocUnsafe(null,size);};/**\n   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n   */Buffer.allocUnsafeSlow=function(size){return allocUnsafe(null,size);};function fromString(that,string,encoding){if(typeof encoding!=='string'||encoding===''){encoding='utf8';}if(!Buffer.isEncoding(encoding)){throw new TypeError('\"encoding\" must be a valid string encoding');}var length=byteLength(string,encoding)|0;that=createBuffer(that,length);var actual=that.write(string,encoding);if(actual!==length){// Writing a hex string, for example, that contains invalid characters will\n// cause everything after the first invalid character to be ignored. (e.g.\n// 'abxxcd' will be treated as 'ab')\nthat=that.slice(0,actual);}return that;}function fromArrayLike(that,array){var length=array.length<0?0:checked(array.length)|0;that=createBuffer(that,length);for(var i=0;i<length;i+=1){that[i]=array[i]&255;}return that;}function fromArrayBuffer(that,array,byteOffset,length){array.byteLength;// this throws if `array` is not a valid ArrayBuffer\nif(byteOffset<0||array.byteLength<byteOffset){throw new RangeError('\\'offset\\' is out of bounds');}if(array.byteLength<byteOffset+(length||0)){throw new RangeError('\\'length\\' is out of bounds');}if(byteOffset===undefined&&length===undefined){array=new Uint8Array(array);}else if(length===undefined){array=new Uint8Array(array,byteOffset);}else{array=new Uint8Array(array,byteOffset,length);}if(Buffer.TYPED_ARRAY_SUPPORT){// Return an augmented `Uint8Array` instance, for best performance\nthat=array;that.__proto__=Buffer.prototype;}else{// Fallback: Return an object instance of the Buffer class\nthat=fromArrayLike(that,array);}return that;}function fromObject(that,obj){if(internalIsBuffer(obj)){var len=checked(obj.length)|0;that=createBuffer(that,len);if(that.length===0){return that;}obj.copy(that,0,0,len);return that;}if(obj){if(typeof ArrayBuffer!=='undefined'&&obj.buffer instanceof ArrayBuffer||'length'in obj){if(typeof obj.length!=='number'||isnan(obj.length)){return createBuffer(that,0);}return fromArrayLike(that,obj);}if(obj.type==='Buffer'&&isArray(obj.data)){return fromArrayLike(that,obj.data);}}throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');}function checked(length){// Note: cannot use `length < kMaxLength()` here because that fails when\n// length is NaN (which is otherwise coerced to zero.)\nif(length>=kMaxLength()){throw new RangeError('Attempt to allocate Buffer larger than maximum '+'size: 0x'+kMaxLength().toString(16)+' bytes');}return length|0;}Buffer.isBuffer=isBuffer;function internalIsBuffer(b){return!!(b!=null&&b._isBuffer);}Buffer.compare=function compare(a,b){if(!internalIsBuffer(a)||!internalIsBuffer(b)){throw new TypeError('Arguments must be Buffers');}if(a===b)return 0;var x=a.length;var y=b.length;for(var i=0,len=Math.min(x,y);i<len;++i){if(a[i]!==b[i]){x=a[i];y=b[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};Buffer.isEncoding=function isEncoding(encoding){switch(String(encoding).toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return true;default:return false;}};Buffer.concat=function concat(list,length){if(!isArray(list)){throw new TypeError('\"list\" argument must be an Array of Buffers');}if(list.length===0){return Buffer.alloc(0);}var i;if(length===undefined){length=0;for(i=0;i<list.length;++i){length+=list[i].length;}}var buffer=Buffer.allocUnsafe(length);var pos=0;for(i=0;i<list.length;++i){var buf=list[i];if(!internalIsBuffer(buf)){throw new TypeError('\"list\" argument must be an Array of Buffers');}buf.copy(buffer,pos);pos+=buf.length;}return buffer;};function byteLength(string,encoding){if(internalIsBuffer(string)){return string.length;}if(typeof ArrayBuffer!=='undefined'&&typeof ArrayBuffer.isView==='function'&&(ArrayBuffer.isView(string)||string instanceof ArrayBuffer)){return string.byteLength;}if(typeof string!=='string'){string=''+string;}var len=string.length;if(len===0)return 0;// Use a for loop to avoid recursion\nvar loweredCase=false;for(;;){switch(encoding){case'ascii':case'latin1':case'binary':return len;case'utf8':case'utf-8':case undefined:return utf8ToBytes(string).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return len*2;case'hex':return len>>>1;case'base64':return base64ToBytes(string).length;default:if(loweredCase)return utf8ToBytes(string).length;// assume utf8\nencoding=(''+encoding).toLowerCase();loweredCase=true;}}}Buffer.byteLength=byteLength;function slowToString(encoding,start,end){var loweredCase=false;// No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\n// undefined is handled specially as per ECMA-262 6th Edition,\n// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\nif(start===undefined||start<0){start=0;}// Return early if start > this.length. Done here to prevent potential uint32\n// coercion fail below.\nif(start>this.length){return'';}if(end===undefined||end>this.length){end=this.length;}if(end<=0){return'';}// Force coersion to uint32. This will also coerce falsey/NaN values to 0.\nend>>>=0;start>>>=0;if(end<=start){return'';}if(!encoding)encoding='utf8';while(true){switch(encoding){case'hex':return hexSlice(this,start,end);case'utf8':case'utf-8':return utf8Slice(this,start,end);case'ascii':return asciiSlice(this,start,end);case'latin1':case'binary':return latin1Slice(this,start,end);case'base64':return base64Slice(this,start,end);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return utf16leSlice(this,start,end);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(encoding+'').toLowerCase();loweredCase=true;}}}// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer=true;function swap(b,n,m){var i=b[n];b[n]=b[m];b[m]=i;}Buffer.prototype.swap16=function swap16(){var len=this.length;if(len%2!==0){throw new RangeError('Buffer size must be a multiple of 16-bits');}for(var i=0;i<len;i+=2){swap(this,i,i+1);}return this;};Buffer.prototype.swap32=function swap32(){var len=this.length;if(len%4!==0){throw new RangeError('Buffer size must be a multiple of 32-bits');}for(var i=0;i<len;i+=4){swap(this,i,i+3);swap(this,i+1,i+2);}return this;};Buffer.prototype.swap64=function swap64(){var len=this.length;if(len%8!==0){throw new RangeError('Buffer size must be a multiple of 64-bits');}for(var i=0;i<len;i+=8){swap(this,i,i+7);swap(this,i+1,i+6);swap(this,i+2,i+5);swap(this,i+3,i+4);}return this;};Buffer.prototype.toString=function toString(){var length=this.length|0;if(length===0)return'';if(arguments.length===0)return utf8Slice(this,0,length);return slowToString.apply(this,arguments);};Buffer.prototype.equals=function equals(b){if(!internalIsBuffer(b))throw new TypeError('Argument must be a Buffer');if(this===b)return true;return Buffer.compare(this,b)===0;};Buffer.prototype.inspect=function inspect(){var str='';var max=INSPECT_MAX_BYTES;if(this.length>0){str=this.toString('hex',0,max).match(/.{2}/g).join(' ');if(this.length>max)str+=' ... ';}return'<Buffer '+str+'>';};Buffer.prototype.compare=function compare(target,start,end,thisStart,thisEnd){if(!internalIsBuffer(target)){throw new TypeError('Argument must be a Buffer');}if(start===undefined){start=0;}if(end===undefined){end=target?target.length:0;}if(thisStart===undefined){thisStart=0;}if(thisEnd===undefined){thisEnd=this.length;}if(start<0||end>target.length||thisStart<0||thisEnd>this.length){throw new RangeError('out of range index');}if(thisStart>=thisEnd&&start>=end){return 0;}if(thisStart>=thisEnd){return-1;}if(start>=end){return 1;}start>>>=0;end>>>=0;thisStart>>>=0;thisEnd>>>=0;if(this===target)return 0;var x=thisEnd-thisStart;var y=end-start;var len=Math.min(x,y);var thisCopy=this.slice(thisStart,thisEnd);var targetCopy=target.slice(start,end);for(var i=0;i<len;++i){if(thisCopy[i]!==targetCopy[i]){x=thisCopy[i];y=targetCopy[i];break;}}if(x<y)return-1;if(y<x)return 1;return 0;};// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf(buffer,val,byteOffset,encoding,dir){// Empty buffer means no match\nif(buffer.length===0)return-1;// Normalize byteOffset\nif(typeof byteOffset==='string'){encoding=byteOffset;byteOffset=0;}else if(byteOffset>0x7fffffff){byteOffset=0x7fffffff;}else if(byteOffset<-0x80000000){byteOffset=-0x80000000;}byteOffset=+byteOffset;// Coerce to Number.\nif(isNaN(byteOffset)){// byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\nbyteOffset=dir?0:buffer.length-1;}// Normalize byteOffset: negative offsets start from the end of the buffer\nif(byteOffset<0)byteOffset=buffer.length+byteOffset;if(byteOffset>=buffer.length){if(dir)return-1;else byteOffset=buffer.length-1;}else if(byteOffset<0){if(dir)byteOffset=0;else return-1;}// Normalize val\nif(typeof val==='string'){val=Buffer.from(val,encoding);}// Finally, search either indexOf (if dir is true) or lastIndexOf\nif(internalIsBuffer(val)){// Special case: looking for empty string/buffer always fails\nif(val.length===0){return-1;}return arrayIndexOf(buffer,val,byteOffset,encoding,dir);}else if(typeof val==='number'){val=val&0xFF;// Search for a byte value [0-255]\nif(Buffer.TYPED_ARRAY_SUPPORT&&typeof Uint8Array.prototype.indexOf==='function'){if(dir){return Uint8Array.prototype.indexOf.call(buffer,val,byteOffset);}else{return Uint8Array.prototype.lastIndexOf.call(buffer,val,byteOffset);}}return arrayIndexOf(buffer,[val],byteOffset,encoding,dir);}throw new TypeError('val must be string, number or Buffer');}function arrayIndexOf(arr,val,byteOffset,encoding,dir){var indexSize=1;var arrLength=arr.length;var valLength=val.length;if(encoding!==undefined){encoding=String(encoding).toLowerCase();if(encoding==='ucs2'||encoding==='ucs-2'||encoding==='utf16le'||encoding==='utf-16le'){if(arr.length<2||val.length<2){return-1;}indexSize=2;arrLength/=2;valLength/=2;byteOffset/=2;}}function read(buf,i){if(indexSize===1){return buf[i];}else{return buf.readUInt16BE(i*indexSize);}}var i;if(dir){var foundIndex=-1;for(i=byteOffset;i<arrLength;i++){if(read(arr,i)===read(val,foundIndex===-1?0:i-foundIndex)){if(foundIndex===-1)foundIndex=i;if(i-foundIndex+1===valLength)return foundIndex*indexSize;}else{if(foundIndex!==-1)i-=i-foundIndex;foundIndex=-1;}}}else{if(byteOffset+valLength>arrLength)byteOffset=arrLength-valLength;for(i=byteOffset;i>=0;i--){var found=true;for(var j=0;j<valLength;j++){if(read(arr,i+j)!==read(val,j)){found=false;break;}}if(found)return i;}}return-1;}Buffer.prototype.includes=function includes(val,byteOffset,encoding){return this.indexOf(val,byteOffset,encoding)!==-1;};Buffer.prototype.indexOf=function indexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,true);};Buffer.prototype.lastIndexOf=function lastIndexOf(val,byteOffset,encoding){return bidirectionalIndexOf(this,val,byteOffset,encoding,false);};function hexWrite(buf,string,offset,length){offset=Number(offset)||0;var remaining=buf.length-offset;if(!length){length=remaining;}else{length=Number(length);if(length>remaining){length=remaining;}}// must be an even number of digits\nvar strLen=string.length;if(strLen%2!==0)throw new TypeError('Invalid hex string');if(length>strLen/2){length=strLen/2;}for(var i=0;i<length;++i){var parsed=parseInt(string.substr(i*2,2),16);if(isNaN(parsed))return i;buf[offset+i]=parsed;}return i;}function utf8Write(buf,string,offset,length){return blitBuffer(utf8ToBytes(string,buf.length-offset),buf,offset,length);}function asciiWrite(buf,string,offset,length){return blitBuffer(asciiToBytes(string),buf,offset,length);}function latin1Write(buf,string,offset,length){return asciiWrite(buf,string,offset,length);}function base64Write(buf,string,offset,length){return blitBuffer(base64ToBytes(string),buf,offset,length);}function ucs2Write(buf,string,offset,length){return blitBuffer(utf16leToBytes(string,buf.length-offset),buf,offset,length);}Buffer.prototype.write=function write(string,offset,length,encoding){// Buffer#write(string)\nif(offset===undefined){encoding='utf8';length=this.length;offset=0;// Buffer#write(string, encoding)\n}else if(length===undefined&&typeof offset==='string'){encoding=offset;length=this.length;offset=0;// Buffer#write(string, offset[, length][, encoding])\n}else if(isFinite(offset)){offset=offset|0;if(isFinite(length)){length=length|0;if(encoding===undefined)encoding='utf8';}else{encoding=length;length=undefined;}// legacy write(string, encoding, offset, length) - remove in v0.13\n}else{throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');}var remaining=this.length-offset;if(length===undefined||length>remaining)length=remaining;if(string.length>0&&(length<0||offset<0)||offset>this.length){throw new RangeError('Attempt to write outside buffer bounds');}if(!encoding)encoding='utf8';var loweredCase=false;for(;;){switch(encoding){case'hex':return hexWrite(this,string,offset,length);case'utf8':case'utf-8':return utf8Write(this,string,offset,length);case'ascii':return asciiWrite(this,string,offset,length);case'latin1':case'binary':return latin1Write(this,string,offset,length);case'base64':// Warning: maxLength not taken into account in base64Write\nreturn base64Write(this,string,offset,length);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return ucs2Write(this,string,offset,length);default:if(loweredCase)throw new TypeError('Unknown encoding: '+encoding);encoding=(''+encoding).toLowerCase();loweredCase=true;}}};Buffer.prototype.toJSON=function toJSON(){return{type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)};};function base64Slice(buf,start,end){if(start===0&&end===buf.length){return fromByteArray(buf);}else{return fromByteArray(buf.slice(start,end));}}function utf8Slice(buf,start,end){end=Math.min(buf.length,end);var res=[];var i=start;while(i<end){var firstByte=buf[i];var codePoint=null;var bytesPerSequence=firstByte>0xEF?4:firstByte>0xDF?3:firstByte>0xBF?2:1;if(i+bytesPerSequence<=end){var secondByte,thirdByte,fourthByte,tempCodePoint;switch(bytesPerSequence){case 1:if(firstByte<0x80){codePoint=firstByte;}break;case 2:secondByte=buf[i+1];if((secondByte&0xC0)===0x80){tempCodePoint=(firstByte&0x1F)<<0x6|secondByte&0x3F;if(tempCodePoint>0x7F){codePoint=tempCodePoint;}}break;case 3:secondByte=buf[i+1];thirdByte=buf[i+2];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0xC|(secondByte&0x3F)<<0x6|thirdByte&0x3F;if(tempCodePoint>0x7FF&&(tempCodePoint<0xD800||tempCodePoint>0xDFFF)){codePoint=tempCodePoint;}}break;case 4:secondByte=buf[i+1];thirdByte=buf[i+2];fourthByte=buf[i+3];if((secondByte&0xC0)===0x80&&(thirdByte&0xC0)===0x80&&(fourthByte&0xC0)===0x80){tempCodePoint=(firstByte&0xF)<<0x12|(secondByte&0x3F)<<0xC|(thirdByte&0x3F)<<0x6|fourthByte&0x3F;if(tempCodePoint>0xFFFF&&tempCodePoint<0x110000){codePoint=tempCodePoint;}}}}if(codePoint===null){// we did not generate a valid codePoint so insert a\n// replacement char (U+FFFD) and advance only 1 byte\ncodePoint=0xFFFD;bytesPerSequence=1;}else if(codePoint>0xFFFF){// encode to utf16 (surrogate pair dance)\ncodePoint-=0x10000;res.push(codePoint>>>10&0x3FF|0xD800);codePoint=0xDC00|codePoint&0x3FF;}res.push(codePoint);i+=bytesPerSequence;}return decodeCodePointsArray(res);}// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH=0x1000;function decodeCodePointsArray(codePoints){var len=codePoints.length;if(len<=MAX_ARGUMENTS_LENGTH){return String.fromCharCode.apply(String,codePoints);// avoid extra slice()\n}// Decode in chunks to avoid \"call stack size exceeded\".\nvar res='';var i=0;while(i<len){res+=String.fromCharCode.apply(String,codePoints.slice(i,i+=MAX_ARGUMENTS_LENGTH));}return res;}function asciiSlice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]&0x7F);}return ret;}function latin1Slice(buf,start,end){var ret='';end=Math.min(buf.length,end);for(var i=start;i<end;++i){ret+=String.fromCharCode(buf[i]);}return ret;}function hexSlice(buf,start,end){var len=buf.length;if(!start||start<0)start=0;if(!end||end<0||end>len)end=len;var out='';for(var i=start;i<end;++i){out+=toHex(buf[i]);}return out;}function utf16leSlice(buf,start,end){var bytes=buf.slice(start,end);var res='';for(var i=0;i<bytes.length;i+=2){res+=String.fromCharCode(bytes[i]+bytes[i+1]*256);}return res;}Buffer.prototype.slice=function slice(start,end){var len=this.length;start=~~start;end=end===undefined?len:~~end;if(start<0){start+=len;if(start<0)start=0;}else if(start>len){start=len;}if(end<0){end+=len;if(end<0)end=0;}else if(end>len){end=len;}if(end<start)end=start;var newBuf;if(Buffer.TYPED_ARRAY_SUPPORT){newBuf=this.subarray(start,end);newBuf.__proto__=Buffer.prototype;}else{var sliceLen=end-start;newBuf=new Buffer(sliceLen,undefined);for(var i=0;i<sliceLen;++i){newBuf[i]=this[i+start];}}return newBuf;};/*\n   * Need to make sure that buffer isn't trying to write out of bounds.\n   */function checkOffset(offset,ext,length){if(offset%1!==0||offset<0)throw new RangeError('offset is not uint');if(offset+ext>length)throw new RangeError('Trying to access beyond buffer length');}Buffer.prototype.readUIntLE=function readUIntLE(offset,byteLength,noAssert){offset=offset|0;byteLength=byteLength|0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}return val;};Buffer.prototype.readUIntBE=function readUIntBE(offset,byteLength,noAssert){offset=offset|0;byteLength=byteLength|0;if(!noAssert){checkOffset(offset,byteLength,this.length);}var val=this[offset+--byteLength];var mul=1;while(byteLength>0&&(mul*=0x100)){val+=this[offset+--byteLength]*mul;}return val;};Buffer.prototype.readUInt8=function readUInt8(offset,noAssert){if(!noAssert)checkOffset(offset,1,this.length);return this[offset];};Buffer.prototype.readUInt16LE=function readUInt16LE(offset,noAssert){if(!noAssert)checkOffset(offset,2,this.length);return this[offset]|this[offset+1]<<8;};Buffer.prototype.readUInt16BE=function readUInt16BE(offset,noAssert){if(!noAssert)checkOffset(offset,2,this.length);return this[offset]<<8|this[offset+1];};Buffer.prototype.readUInt32LE=function readUInt32LE(offset,noAssert){if(!noAssert)checkOffset(offset,4,this.length);return(this[offset]|this[offset+1]<<8|this[offset+2]<<16)+this[offset+3]*0x1000000;};Buffer.prototype.readUInt32BE=function readUInt32BE(offset,noAssert){if(!noAssert)checkOffset(offset,4,this.length);return this[offset]*0x1000000+(this[offset+1]<<16|this[offset+2]<<8|this[offset+3]);};Buffer.prototype.readIntLE=function readIntLE(offset,byteLength,noAssert){offset=offset|0;byteLength=byteLength|0;if(!noAssert)checkOffset(offset,byteLength,this.length);var val=this[offset];var mul=1;var i=0;while(++i<byteLength&&(mul*=0x100)){val+=this[offset+i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readIntBE=function readIntBE(offset,byteLength,noAssert){offset=offset|0;byteLength=byteLength|0;if(!noAssert)checkOffset(offset,byteLength,this.length);var i=byteLength;var mul=1;var val=this[offset+--i];while(i>0&&(mul*=0x100)){val+=this[offset+--i]*mul;}mul*=0x80;if(val>=mul)val-=Math.pow(2,8*byteLength);return val;};Buffer.prototype.readInt8=function readInt8(offset,noAssert){if(!noAssert)checkOffset(offset,1,this.length);if(!(this[offset]&0x80))return this[offset];return(0xff-this[offset]+1)*-1;};Buffer.prototype.readInt16LE=function readInt16LE(offset,noAssert){if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset]|this[offset+1]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt16BE=function readInt16BE(offset,noAssert){if(!noAssert)checkOffset(offset,2,this.length);var val=this[offset+1]|this[offset]<<8;return val&0x8000?val|0xFFFF0000:val;};Buffer.prototype.readInt32LE=function readInt32LE(offset,noAssert){if(!noAssert)checkOffset(offset,4,this.length);return this[offset]|this[offset+1]<<8|this[offset+2]<<16|this[offset+3]<<24;};Buffer.prototype.readInt32BE=function readInt32BE(offset,noAssert){if(!noAssert)checkOffset(offset,4,this.length);return this[offset]<<24|this[offset+1]<<16|this[offset+2]<<8|this[offset+3];};Buffer.prototype.readFloatLE=function readFloatLE(offset,noAssert){if(!noAssert)checkOffset(offset,4,this.length);return read(this,offset,true,23,4);};Buffer.prototype.readFloatBE=function readFloatBE(offset,noAssert){if(!noAssert)checkOffset(offset,4,this.length);return read(this,offset,false,23,4);};Buffer.prototype.readDoubleLE=function readDoubleLE(offset,noAssert){if(!noAssert)checkOffset(offset,8,this.length);return read(this,offset,true,52,8);};Buffer.prototype.readDoubleBE=function readDoubleBE(offset,noAssert){if(!noAssert)checkOffset(offset,8,this.length);return read(this,offset,false,52,8);};function checkInt(buf,value,offset,ext,max,min){if(!internalIsBuffer(buf))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(value>max||value<min)throw new RangeError('\"value\" argument is out of bounds');if(offset+ext>buf.length)throw new RangeError('Index out of range');}Buffer.prototype.writeUIntLE=function writeUIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset|0;byteLength=byteLength|0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var mul=1;var i=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUIntBE=function writeUIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset|0;byteLength=byteLength|0;if(!noAssert){var maxBytes=Math.pow(2,8*byteLength)-1;checkInt(this,value,offset,byteLength,maxBytes,0);}var i=byteLength-1;var mul=1;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){this[offset+i]=value/mul&0xFF;}return offset+byteLength;};Buffer.prototype.writeUInt8=function writeUInt8(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,1,0xff,0);if(!Buffer.TYPED_ARRAY_SUPPORT)value=Math.floor(value);this[offset]=value&0xff;return offset+1;};function objectWriteUInt16(buf,value,offset,littleEndian){if(value<0)value=0xffff+value+1;for(var i=0,j=Math.min(buf.length-offset,2);i<j;++i){buf[offset+i]=(value&0xff<<8*(littleEndian?i:1-i))>>>(littleEndian?i:1-i)*8;}}Buffer.prototype.writeUInt16LE=function writeUInt16LE(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);if(Buffer.TYPED_ARRAY_SUPPORT){this[offset]=value&0xff;this[offset+1]=value>>>8;}else{objectWriteUInt16(this,value,offset,true);}return offset+2;};Buffer.prototype.writeUInt16BE=function writeUInt16BE(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,2,0xffff,0);if(Buffer.TYPED_ARRAY_SUPPORT){this[offset]=value>>>8;this[offset+1]=value&0xff;}else{objectWriteUInt16(this,value,offset,false);}return offset+2;};function objectWriteUInt32(buf,value,offset,littleEndian){if(value<0)value=0xffffffff+value+1;for(var i=0,j=Math.min(buf.length-offset,4);i<j;++i){buf[offset+i]=value>>>(littleEndian?i:3-i)*8&0xff;}}Buffer.prototype.writeUInt32LE=function writeUInt32LE(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);if(Buffer.TYPED_ARRAY_SUPPORT){this[offset+3]=value>>>24;this[offset+2]=value>>>16;this[offset+1]=value>>>8;this[offset]=value&0xff;}else{objectWriteUInt32(this,value,offset,true);}return offset+4;};Buffer.prototype.writeUInt32BE=function writeUInt32BE(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,4,0xffffffff,0);if(Buffer.TYPED_ARRAY_SUPPORT){this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;}else{objectWriteUInt32(this,value,offset,false);}return offset+4;};Buffer.prototype.writeIntLE=function writeIntLE(value,offset,byteLength,noAssert){value=+value;offset=offset|0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=0;var mul=1;var sub=0;this[offset]=value&0xFF;while(++i<byteLength&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i-1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeIntBE=function writeIntBE(value,offset,byteLength,noAssert){value=+value;offset=offset|0;if(!noAssert){var limit=Math.pow(2,8*byteLength-1);checkInt(this,value,offset,byteLength,limit-1,-limit);}var i=byteLength-1;var mul=1;var sub=0;this[offset+i]=value&0xFF;while(--i>=0&&(mul*=0x100)){if(value<0&&sub===0&&this[offset+i+1]!==0){sub=1;}this[offset+i]=(value/mul>>0)-sub&0xFF;}return offset+byteLength;};Buffer.prototype.writeInt8=function writeInt8(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,1,0x7f,-0x80);if(!Buffer.TYPED_ARRAY_SUPPORT)value=Math.floor(value);if(value<0)value=0xff+value+1;this[offset]=value&0xff;return offset+1;};Buffer.prototype.writeInt16LE=function writeInt16LE(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);if(Buffer.TYPED_ARRAY_SUPPORT){this[offset]=value&0xff;this[offset+1]=value>>>8;}else{objectWriteUInt16(this,value,offset,true);}return offset+2;};Buffer.prototype.writeInt16BE=function writeInt16BE(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,2,0x7fff,-0x8000);if(Buffer.TYPED_ARRAY_SUPPORT){this[offset]=value>>>8;this[offset+1]=value&0xff;}else{objectWriteUInt16(this,value,offset,false);}return offset+2;};Buffer.prototype.writeInt32LE=function writeInt32LE(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);if(Buffer.TYPED_ARRAY_SUPPORT){this[offset]=value&0xff;this[offset+1]=value>>>8;this[offset+2]=value>>>16;this[offset+3]=value>>>24;}else{objectWriteUInt32(this,value,offset,true);}return offset+4;};Buffer.prototype.writeInt32BE=function writeInt32BE(value,offset,noAssert){value=+value;offset=offset|0;if(!noAssert)checkInt(this,value,offset,4,0x7fffffff,-0x80000000);if(value<0)value=0xffffffff+value+1;if(Buffer.TYPED_ARRAY_SUPPORT){this[offset]=value>>>24;this[offset+1]=value>>>16;this[offset+2]=value>>>8;this[offset+3]=value&0xff;}else{objectWriteUInt32(this,value,offset,false);}return offset+4;};function checkIEEE754(buf,value,offset,ext,max,min){if(offset+ext>buf.length)throw new RangeError('Index out of range');if(offset<0)throw new RangeError('Index out of range');}function writeFloat(buf,value,offset,littleEndian,noAssert){if(!noAssert){checkIEEE754(buf,value,offset,4);}write(buf,value,offset,littleEndian,23,4);return offset+4;}Buffer.prototype.writeFloatLE=function writeFloatLE(value,offset,noAssert){return writeFloat(this,value,offset,true,noAssert);};Buffer.prototype.writeFloatBE=function writeFloatBE(value,offset,noAssert){return writeFloat(this,value,offset,false,noAssert);};function writeDouble(buf,value,offset,littleEndian,noAssert){if(!noAssert){checkIEEE754(buf,value,offset,8);}write(buf,value,offset,littleEndian,52,8);return offset+8;}Buffer.prototype.writeDoubleLE=function writeDoubleLE(value,offset,noAssert){return writeDouble(this,value,offset,true,noAssert);};Buffer.prototype.writeDoubleBE=function writeDoubleBE(value,offset,noAssert){return writeDouble(this,value,offset,false,noAssert);};// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy=function copy(target,targetStart,start,end){if(!start)start=0;if(!end&&end!==0)end=this.length;if(targetStart>=target.length)targetStart=target.length;if(!targetStart)targetStart=0;if(end>0&&end<start)end=start;// Copy 0 bytes; we're done\nif(end===start)return 0;if(target.length===0||this.length===0)return 0;// Fatal error conditions\nif(targetStart<0){throw new RangeError('targetStart out of bounds');}if(start<0||start>=this.length)throw new RangeError('sourceStart out of bounds');if(end<0)throw new RangeError('sourceEnd out of bounds');// Are we oob?\nif(end>this.length)end=this.length;if(target.length-targetStart<end-start){end=target.length-targetStart+start;}var len=end-start;var i;if(this===target&&start<targetStart&&targetStart<end){// descending copy from end\nfor(i=len-1;i>=0;--i){target[i+targetStart]=this[i+start];}}else if(len<1000||!Buffer.TYPED_ARRAY_SUPPORT){// ascending copy from start\nfor(i=0;i<len;++i){target[i+targetStart]=this[i+start];}}else{Uint8Array.prototype.set.call(target,this.subarray(start,start+len),targetStart);}return len;};// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill=function fill(val,start,end,encoding){// Handle string cases:\nif(typeof val==='string'){if(typeof start==='string'){encoding=start;start=0;end=this.length;}else if(typeof end==='string'){encoding=end;end=this.length;}if(val.length===1){var code=val.charCodeAt(0);if(code<256){val=code;}}if(encoding!==undefined&&typeof encoding!=='string'){throw new TypeError('encoding must be a string');}if(typeof encoding==='string'&&!Buffer.isEncoding(encoding)){throw new TypeError('Unknown encoding: '+encoding);}}else if(typeof val==='number'){val=val&255;}// Invalid ranges are not set to a default, so can range check early.\nif(start<0||this.length<start||this.length<end){throw new RangeError('Out of range index');}if(end<=start){return this;}start=start>>>0;end=end===undefined?this.length:end>>>0;if(!val)val=0;var i;if(typeof val==='number'){for(i=start;i<end;++i){this[i]=val;}}else{var bytes=internalIsBuffer(val)?val:utf8ToBytes(new Buffer(val,encoding).toString());var len=bytes.length;for(i=0;i<end-start;++i){this[i+start]=bytes[i%len];}}return this;};// HELPER FUNCTIONS\n// ================\nvar INVALID_BASE64_RE=/[^+\\/0-9A-Za-z-_]/g;function base64clean(str){// Node strips out invalid characters like \\n and \\t from the string, base64-js does not\nstr=stringtrim(str).replace(INVALID_BASE64_RE,'');// Node converts strings with length < 2 to ''\nif(str.length<2)return'';// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\nwhile(str.length%4!==0){str=str+'=';}return str;}function stringtrim(str){if(str.trim)return str.trim();return str.replace(/^\\s+|\\s+$/g,'');}function toHex(n){if(n<16)return'0'+n.toString(16);return n.toString(16);}function utf8ToBytes(string,units){units=units||Infinity;var codePoint;var length=string.length;var leadSurrogate=null;var bytes=[];for(var i=0;i<length;++i){codePoint=string.charCodeAt(i);// is surrogate component\nif(codePoint>0xD7FF&&codePoint<0xE000){// last char was a lead\nif(!leadSurrogate){// no lead yet\nif(codePoint>0xDBFF){// unexpected trail\nif((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}else if(i+1===length){// unpaired lead\nif((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);continue;}// valid lead\nleadSurrogate=codePoint;continue;}// 2 leads in a row\nif(codePoint<0xDC00){if((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);leadSurrogate=codePoint;continue;}// valid surrogate pair\ncodePoint=(leadSurrogate-0xD800<<10|codePoint-0xDC00)+0x10000;}else if(leadSurrogate){// valid bmp char, but last char was a lead\nif((units-=3)>-1)bytes.push(0xEF,0xBF,0xBD);}leadSurrogate=null;// encode utf8\nif(codePoint<0x80){if((units-=1)<0)break;bytes.push(codePoint);}else if(codePoint<0x800){if((units-=2)<0)break;bytes.push(codePoint>>0x6|0xC0,codePoint&0x3F|0x80);}else if(codePoint<0x10000){if((units-=3)<0)break;bytes.push(codePoint>>0xC|0xE0,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else if(codePoint<0x110000){if((units-=4)<0)break;bytes.push(codePoint>>0x12|0xF0,codePoint>>0xC&0x3F|0x80,codePoint>>0x6&0x3F|0x80,codePoint&0x3F|0x80);}else{throw new Error('Invalid code point');}}return bytes;}function asciiToBytes(str){var byteArray=[];for(var i=0;i<str.length;++i){// Node's code seems to be doing this and not & 0x7F..\nbyteArray.push(str.charCodeAt(i)&0xFF);}return byteArray;}function utf16leToBytes(str,units){var c,hi,lo;var byteArray=[];for(var i=0;i<str.length;++i){if((units-=2)<0)break;c=str.charCodeAt(i);hi=c>>8;lo=c%256;byteArray.push(lo);byteArray.push(hi);}return byteArray;}function base64ToBytes(str){return toByteArray(base64clean(str));}function blitBuffer(src,dst,offset,length){for(var i=0;i<length;++i){if(i+offset>=dst.length||i>=src.length)break;dst[i+offset]=src[i];}return i;}function isnan(val){return val!==val;// eslint-disable-line no-self-compare\n}// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nfunction isBuffer(obj){return obj!=null&&(!!obj._isBuffer||isFastBuffer(obj)||isSlowBuffer(obj));}function isFastBuffer(obj){return!!obj.constructor&&typeof obj.constructor.isBuffer==='function'&&obj.constructor.isBuffer(obj);}// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer(obj){return typeof obj.readFloatLE==='function'&&typeof obj.slice==='function'&&isFastBuffer(obj.slice(0,0));}var commonjsGlobal=typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function unwrapExports(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}function createCommonjsModule(fn,module){return module={exports:{}},fn(module,module.exports),module.exports;}function getCjsExportFromNamespace(n){return n&&n['default']||n;}var fs=getCjsExportFromNamespace(_shim_fs$1);/**\n   * @class\n   */class LineByLine{constructor(file,options){options=options||{};if(!options.readChunk)options.readChunk=1024;if(!options.newLineCharacter){options.newLineCharacter=0x0a;//linux line ending\n}else{options.newLineCharacter=options.newLineCharacter.charCodeAt(0);}if(typeof file==='number'){this.fd=file;}else{this.fd=fs.openSync(file,'r');}this.options=options;this.newLineCharacter=options.newLineCharacter;this.reset();}_searchInBuffer(buffer,hexNeedle){let found=-1;for(let i=0;i<=buffer.length;i++){let b_byte=buffer[i];if(b_byte===hexNeedle){found=i;break;}}return found;}reset(){this.eofReached=false;this.linesCache=[];this.fdPosition=0;}close(){fs.closeSync(this.fd);this.fd=null;}_extractLines(buffer){let line;const lines=[];let bufferPosition=0;let lastNewLineBufferPosition=0;while(true){let bufferPositionValue=buffer[bufferPosition++];if(bufferPositionValue===this.newLineCharacter){line=buffer.slice(lastNewLineBufferPosition,bufferPosition);lines.push(line);lastNewLineBufferPosition=bufferPosition;}else if(!bufferPositionValue){break;}}let leftovers=buffer.slice(lastNewLineBufferPosition,bufferPosition);if(leftovers.length){lines.push(leftovers);}return lines;}_readChunk(lineLeftovers){let totalBytesRead=0;let bytesRead;const buffers=[];do{const readBuffer=new Buffer(this.options.readChunk);bytesRead=fs.readSync(this.fd,readBuffer,0,this.options.readChunk,this.fdPosition);totalBytesRead=totalBytesRead+bytesRead;this.fdPosition=this.fdPosition+bytesRead;buffers.push(readBuffer);}while(bytesRead&&this._searchInBuffer(buffers[buffers.length-1],this.options.newLineCharacter)===-1);let bufferData=Buffer.concat(buffers);if(bytesRead<this.options.readChunk){this.eofReached=true;bufferData=bufferData.slice(0,totalBytesRead);}if(totalBytesRead){this.linesCache=this._extractLines(bufferData);if(lineLeftovers){this.linesCache[0]=Buffer.concat([lineLeftovers,this.linesCache[0]]);}}return totalBytesRead;}next(){if(!this.fd)return false;let line=false;if(this.eofReached&&this.linesCache.length===0){return line;}let bytesRead;if(!this.linesCache.length){bytesRead=this._readChunk();}if(this.linesCache.length){line=this.linesCache.shift();const lastLineCharacter=line[line.length-1];if(lastLineCharacter!==0x0a){bytesRead=this._readChunk(line);if(bytesRead){line=this.linesCache.shift();}}}if(this.eofReached&&this.linesCache.length===0){this.close();}if(line&&line[line.length-1]===this.newLineCharacter){line=line.slice(0,line.length-1);}return line;}}var readlines=LineByLine;/**\n   * The inverse of `_.toPairs`; this method returns an object composed\n   * from key-value `pairs`.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Array\n   * @param {Array} pairs The key-value pairs.\n   * @returns {Object} Returns the new object.\n   * @example\n   *\n   * _.fromPairs([['a', 1], ['b', 2]]);\n   * // => { 'a': 1, 'b': 2 }\n   */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}var fromPairs_1=fromPairs;class ConfigError extends Error{}class DebugError extends Error{}class UndefinedParserError extends Error{}var errors={ConfigError,DebugError,UndefinedParserError};function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}function _taggedTemplateLiteral(strings,raw){if(!raw){raw=strings.slice(0);}return Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}));}// based off https://github.com/defunctzombie/node-process/blob/master/browser.js\nfunction defaultSetTimout(){throw new Error('setTimeout has not been defined');}function defaultClearTimeout(){throw new Error('clearTimeout has not been defined');}var cachedSetTimeout=defaultSetTimout;var cachedClearTimeout=defaultClearTimeout;if(typeof global$1.setTimeout==='function'){cachedSetTimeout=setTimeout;}if(typeof global$1.clearTimeout==='function'){cachedClearTimeout=clearTimeout;}function runTimeout(fun){if(cachedSetTimeout===setTimeout){//normal enviroments in sane situations\nreturn setTimeout(fun,0);}// if setTimeout wasn't available but was latter defined\nif((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout){cachedSetTimeout=setTimeout;return setTimeout(fun,0);}try{// when when somebody has screwed with setTimeout but no I.E. maddness\nreturn cachedSetTimeout(fun,0);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\nreturn cachedSetTimeout.call(null,fun,0);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\nreturn cachedSetTimeout.call(this,fun,0);}}}function runClearTimeout(marker){if(cachedClearTimeout===clearTimeout){//normal enviroments in sane situations\nreturn clearTimeout(marker);}// if clearTimeout wasn't available but was latter defined\nif((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout){cachedClearTimeout=clearTimeout;return clearTimeout(marker);}try{// when when somebody has screwed with setTimeout but no I.E. maddness\nreturn cachedClearTimeout(marker);}catch(e){try{// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\nreturn cachedClearTimeout.call(null,marker);}catch(e){// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n// Some versions of I.E. have different rules for clearTimeout vs setTimeout\nreturn cachedClearTimeout.call(this,marker);}}}var queue=[];var draining=false;var currentQueue;var queueIndex=-1;function cleanUpNextTick(){if(!draining||!currentQueue){return;}draining=false;if(currentQueue.length){queue=currentQueue.concat(queue);}else{queueIndex=-1;}if(queue.length){drainQueue();}}function drainQueue(){if(draining){return;}var timeout=runTimeout(cleanUpNextTick);draining=true;var len=queue.length;while(len){currentQueue=queue;queue=[];while(++queueIndex<len){if(currentQueue){currentQueue[queueIndex].run();}}queueIndex=-1;len=queue.length;}currentQueue=null;draining=false;runClearTimeout(timeout);}function nextTick(fun){var args=new Array(arguments.length-1);if(arguments.length>1){for(var i=1;i<arguments.length;i++){args[i-1]=arguments[i];}}queue.push(new Item(fun,args));if(queue.length===1&&!draining){runTimeout(drainQueue);}}// v8 likes predictible objects\nfunction Item(fun,array){this.fun=fun;this.array=array;}Item.prototype.run=function(){this.fun.apply(null,this.array);};var title='browser';var platform='browser';var browser=true;var env={};var argv=[];var version$1='';// empty string to avoid regexp issues\nvar versions={};var release={};var config={};function noop(){}var on=noop;var addListener=noop;var once=noop;var off=noop;var removeListener=noop;var removeAllListeners=noop;var emit=noop;function binding(name){throw new Error('process.binding is not supported');}function cwd(){return'/';}function chdir(dir){throw new Error('process.chdir is not supported');}function umask(){return 0;}// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js\nvar performance=global$1.performance||{};var performanceNow=performance.now||performance.mozNow||performance.msNow||performance.oNow||performance.webkitNow||function(){return new Date().getTime();};// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp){var clocktime=performanceNow.call(performance)*1e-3;var seconds=Math.floor(clocktime);var nanoseconds=Math.floor(clocktime%1*1e9);if(previousTimestamp){seconds=seconds-previousTimestamp[0];nanoseconds=nanoseconds-previousTimestamp[1];if(nanoseconds<0){seconds--;nanoseconds+=1e9;}}return[seconds,nanoseconds];}var startTime=new Date();function uptime(){var currentTime=new Date();var dif=currentTime-startTime;return dif/1000;}var process={nextTick:nextTick,title:title,browser:browser,env:env,argv:argv,version:version$1,versions:versions,on:on,addListener:addListener,once:once,off:off,removeListener:removeListener,removeAllListeners:removeAllListeners,emit:emit,binding:binding,cwd:cwd,chdir:chdir,umask:umask,hrtime:hrtime,platform:platform,release:release,config:config,uptime:uptime};const debug=typeof process==='object'&&process.env&&process.env.NODE_DEBUG&&/\\bsemver\\b/i.test(process.env.NODE_DEBUG)?function(){for(var _len=arguments.length,args=new Array(_len),_key2=0;_key2<_len;_key2++){args[_key2]=arguments[_key2];}return console.error('SEMVER',...args);}:()=>{};var debug_1=debug;// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION='2.0.0';const MAX_LENGTH=256;const MAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER||/* istanbul ignore next */9007199254740991;// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH=16;var constants={SEMVER_SPEC_VERSION,MAX_LENGTH,MAX_SAFE_INTEGER,MAX_SAFE_COMPONENT_LENGTH};var re_1=createCommonjsModule(function(module,exports){const{MAX_SAFE_COMPONENT_LENGTH}=constants;exports=module.exports={};// The actual regexps go on exports.re\nconst re=exports.re=[];const src=exports.src=[];const t=exports.t={};let R=0;const createToken=(name,value,isGlobal)=>{const index=R++;debug_1(index,value);t[name]=index;src[index]=value;re[index]=new RegExp(value,isGlobal?'g':undefined);};// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\ncreateToken('NUMERICIDENTIFIER','0|[1-9]\\\\d*');createToken('NUMERICIDENTIFIERLOOSE','[0-9]+');// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\ncreateToken('NONNUMERICIDENTIFIER','\\\\d*[a-zA-Z-][a-zA-Z0-9-]*');// ## Main Version\n// Three dot-separated numeric identifiers.\ncreateToken('MAINVERSION',\"(\".concat(src[t.NUMERICIDENTIFIER],\")\\\\.\")+\"(\".concat(src[t.NUMERICIDENTIFIER],\")\\\\.\")+\"(\".concat(src[t.NUMERICIDENTIFIER],\")\"));createToken('MAINVERSIONLOOSE',\"(\".concat(src[t.NUMERICIDENTIFIERLOOSE],\")\\\\.\")+\"(\".concat(src[t.NUMERICIDENTIFIERLOOSE],\")\\\\.\")+\"(\".concat(src[t.NUMERICIDENTIFIERLOOSE],\")\"));// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\ncreateToken('PRERELEASEIDENTIFIER',\"(?:\".concat(src[t.NUMERICIDENTIFIER],\"|\").concat(src[t.NONNUMERICIDENTIFIER],\")\"));createToken('PRERELEASEIDENTIFIERLOOSE',\"(?:\".concat(src[t.NUMERICIDENTIFIERLOOSE],\"|\").concat(src[t.NONNUMERICIDENTIFIER],\")\"));// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\ncreateToken('PRERELEASE',\"(?:-(\".concat(src[t.PRERELEASEIDENTIFIER],\"(?:\\\\.\").concat(src[t.PRERELEASEIDENTIFIER],\")*))\"));createToken('PRERELEASELOOSE',\"(?:-?(\".concat(src[t.PRERELEASEIDENTIFIERLOOSE],\"(?:\\\\.\").concat(src[t.PRERELEASEIDENTIFIERLOOSE],\")*))\"));// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\ncreateToken('BUILDIDENTIFIER','[0-9A-Za-z-]+');// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\ncreateToken('BUILD',\"(?:\\\\+(\".concat(src[t.BUILDIDENTIFIER],\"(?:\\\\.\").concat(src[t.BUILDIDENTIFIER],\")*))\"));// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\ncreateToken('FULLPLAIN',\"v?\".concat(src[t.MAINVERSION]).concat(src[t.PRERELEASE],\"?\").concat(src[t.BUILD],\"?\"));createToken('FULL',\"^\".concat(src[t.FULLPLAIN],\"$\"));// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN',\"[v=\\\\s]*\".concat(src[t.MAINVERSIONLOOSE]).concat(src[t.PRERELEASELOOSE],\"?\").concat(src[t.BUILD],\"?\"));createToken('LOOSE',\"^\".concat(src[t.LOOSEPLAIN],\"$\"));createToken('GTLT','((?:<|>)?=?)');// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE',\"\".concat(src[t.NUMERICIDENTIFIERLOOSE],\"|x|X|\\\\*\"));createToken('XRANGEIDENTIFIER',\"\".concat(src[t.NUMERICIDENTIFIER],\"|x|X|\\\\*\"));createToken('XRANGEPLAIN',\"[v=\\\\s]*(\".concat(src[t.XRANGEIDENTIFIER],\")\")+\"(?:\\\\.(\".concat(src[t.XRANGEIDENTIFIER],\")\")+\"(?:\\\\.(\".concat(src[t.XRANGEIDENTIFIER],\")\")+\"(?:\".concat(src[t.PRERELEASE],\")?\").concat(src[t.BUILD],\"?\")+\")?)?\");createToken('XRANGEPLAINLOOSE',\"[v=\\\\s]*(\".concat(src[t.XRANGEIDENTIFIERLOOSE],\")\")+\"(?:\\\\.(\".concat(src[t.XRANGEIDENTIFIERLOOSE],\")\")+\"(?:\\\\.(\".concat(src[t.XRANGEIDENTIFIERLOOSE],\")\")+\"(?:\".concat(src[t.PRERELEASELOOSE],\")?\").concat(src[t.BUILD],\"?\")+\")?)?\");createToken('XRANGE',\"^\".concat(src[t.GTLT],\"\\\\s*\").concat(src[t.XRANGEPLAIN],\"$\"));createToken('XRANGELOOSE',\"^\".concat(src[t.GTLT],\"\\\\s*\").concat(src[t.XRANGEPLAINLOOSE],\"$\"));// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCE',\"\".concat('(^|[^\\\\d])'+'(\\\\d{1,').concat(MAX_SAFE_COMPONENT_LENGTH,\"})\")+\"(?:\\\\.(\\\\d{1,\".concat(MAX_SAFE_COMPONENT_LENGTH,\"}))?\")+\"(?:\\\\.(\\\\d{1,\".concat(MAX_SAFE_COMPONENT_LENGTH,\"}))?\")+\"(?:$|[^\\\\d])\");createToken('COERCERTL',src[t.COERCE],true);// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE','(?:~>?)');createToken('TILDETRIM',\"(\\\\s*)\".concat(src[t.LONETILDE],\"\\\\s+\"),true);exports.tildeTrimReplace='$1~';createToken('TILDE',\"^\".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAIN],\"$\"));createToken('TILDELOOSE',\"^\".concat(src[t.LONETILDE]).concat(src[t.XRANGEPLAINLOOSE],\"$\"));// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET','(?:\\\\^)');createToken('CARETTRIM',\"(\\\\s*)\".concat(src[t.LONECARET],\"\\\\s+\"),true);exports.caretTrimReplace='$1^';createToken('CARET',\"^\".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAIN],\"$\"));createToken('CARETLOOSE',\"^\".concat(src[t.LONECARET]).concat(src[t.XRANGEPLAINLOOSE],\"$\"));// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE',\"^\".concat(src[t.GTLT],\"\\\\s*(\").concat(src[t.LOOSEPLAIN],\")$|^$\"));createToken('COMPARATOR',\"^\".concat(src[t.GTLT],\"\\\\s*(\").concat(src[t.FULLPLAIN],\")$|^$\"));// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM',\"(\\\\s*)\".concat(src[t.GTLT],\"\\\\s*(\").concat(src[t.LOOSEPLAIN],\"|\").concat(src[t.XRANGEPLAIN],\")\"),true);exports.comparatorTrimReplace='$1$2$3';// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE',\"^\\\\s*(\".concat(src[t.XRANGEPLAIN],\")\")+\"\\\\s+-\\\\s+\"+\"(\".concat(src[t.XRANGEPLAIN],\")\")+\"\\\\s*$\");createToken('HYPHENRANGELOOSE',\"^\\\\s*(\".concat(src[t.XRANGEPLAINLOOSE],\")\")+\"\\\\s+-\\\\s+\"+\"(\".concat(src[t.XRANGEPLAINLOOSE],\")\")+\"\\\\s*$\");// Star ranges basically just allow anything at all.\ncreateToken('STAR','(<|>)?=?\\\\s*\\\\*');});var re_2=re_1.re;var re_3=re_1.src;var re_4=re_1.t;var re_5=re_1.tildeTrimReplace;var re_6=re_1.caretTrimReplace;var re_7=re_1.comparatorTrimReplace;const numeric=/^[0-9]+$/;const compareIdentifiers=(a,b)=>{const anum=numeric.test(a);const bnum=numeric.test(b);if(anum&&bnum){a=+a;b=+b;}return a===b?0:anum&&!bnum?-1:bnum&&!anum?1:a<b?-1:1;};const rcompareIdentifiers=(a,b)=>compareIdentifiers(b,a);var identifiers={compareIdentifiers,rcompareIdentifiers};const{MAX_LENGTH:MAX_LENGTH$1,MAX_SAFE_INTEGER:MAX_SAFE_INTEGER$1}=constants;const{re,t}=re_1;const{compareIdentifiers:compareIdentifiers$1}=identifiers;class SemVer{constructor(version,options){if(!options||typeof options!=='object'){options={loose:!!options,includePrerelease:false};}if(version instanceof SemVer){if(version.loose===!!options.loose&&version.includePrerelease===!!options.includePrerelease){return version;}else{version=version.version;}}else if(typeof version!=='string'){throw new TypeError(\"Invalid Version: \".concat(version));}if(version.length>MAX_LENGTH$1){throw new TypeError(\"version is longer than \".concat(MAX_LENGTH$1,\" characters\"));}debug_1('SemVer',version,options);this.options=options;this.loose=!!options.loose;// this isn't actually relevant for versions, but keep it so that we\n// don't run into trouble passing this.options around.\nthis.includePrerelease=!!options.includePrerelease;const m=version.trim().match(options.loose?re[t.LOOSE]:re[t.FULL]);if(!m){throw new TypeError(\"Invalid Version: \".concat(version));}this.raw=version;// these are actually numbers\nthis.major=+m[1];this.minor=+m[2];this.patch=+m[3];if(this.major>MAX_SAFE_INTEGER$1||this.major<0){throw new TypeError('Invalid major version');}if(this.minor>MAX_SAFE_INTEGER$1||this.minor<0){throw new TypeError('Invalid minor version');}if(this.patch>MAX_SAFE_INTEGER$1||this.patch<0){throw new TypeError('Invalid patch version');}// numberify any prerelease numeric ids\nif(!m[4]){this.prerelease=[];}else{this.prerelease=m[4].split('.').map(id=>{if(/^[0-9]+$/.test(id)){const num=+id;if(num>=0&&num<MAX_SAFE_INTEGER$1){return num;}}return id;});}this.build=m[5]?m[5].split('.'):[];this.format();}format(){this.version=\"\".concat(this.major,\".\").concat(this.minor,\".\").concat(this.patch);if(this.prerelease.length){this.version+=\"-\".concat(this.prerelease.join('.'));}return this.version;}toString(){return this.version;}compare(other){debug_1('SemVer.compare',this.version,this.options,other);if(!(other instanceof SemVer)){if(typeof other==='string'&&other===this.version){return 0;}other=new SemVer(other,this.options);}if(other.version===this.version){return 0;}return this.compareMain(other)||this.comparePre(other);}compareMain(other){if(!(other instanceof SemVer)){other=new SemVer(other,this.options);}return compareIdentifiers$1(this.major,other.major)||compareIdentifiers$1(this.minor,other.minor)||compareIdentifiers$1(this.patch,other.patch);}comparePre(other){if(!(other instanceof SemVer)){other=new SemVer(other,this.options);}// NOT having a prerelease is > having one\nif(this.prerelease.length&&!other.prerelease.length){return-1;}else if(!this.prerelease.length&&other.prerelease.length){return 1;}else if(!this.prerelease.length&&!other.prerelease.length){return 0;}let i=0;do{const a=this.prerelease[i];const b=other.prerelease[i];debug_1('prerelease compare',i,a,b);if(a===undefined&&b===undefined){return 0;}else if(b===undefined){return 1;}else if(a===undefined){return-1;}else if(a===b){continue;}else{return compareIdentifiers$1(a,b);}}while(++i);}compareBuild(other){if(!(other instanceof SemVer)){other=new SemVer(other,this.options);}let i=0;do{const a=this.build[i];const b=other.build[i];debug_1('prerelease compare',i,a,b);if(a===undefined&&b===undefined){return 0;}else if(b===undefined){return 1;}else if(a===undefined){return-1;}else if(a===b){continue;}else{return compareIdentifiers$1(a,b);}}while(++i);}// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\ninc(release,identifier){switch(release){case'premajor':this.prerelease.length=0;this.patch=0;this.minor=0;this.major++;this.inc('pre',identifier);break;case'preminor':this.prerelease.length=0;this.patch=0;this.minor++;this.inc('pre',identifier);break;case'prepatch':// If this is already a prerelease, it will bump to the next version\n// drop any prereleases that might already exist, since they are not\n// relevant at this point.\nthis.prerelease.length=0;this.inc('patch',identifier);this.inc('pre',identifier);break;// If the input is a non-prerelease version, this acts the same as\n// prepatch.\ncase'prerelease':if(this.prerelease.length===0){this.inc('patch',identifier);}this.inc('pre',identifier);break;case'major':// If this is a pre-major version, bump up to the same major version.\n// Otherwise increment major.\n// 1.0.0-5 bumps to 1.0.0\n// 1.1.0 bumps to 2.0.0\nif(this.minor!==0||this.patch!==0||this.prerelease.length===0){this.major++;}this.minor=0;this.patch=0;this.prerelease=[];break;case'minor':// If this is a pre-minor version, bump up to the same minor version.\n// Otherwise increment minor.\n// 1.2.0-5 bumps to 1.2.0\n// 1.2.1 bumps to 1.3.0\nif(this.patch!==0||this.prerelease.length===0){this.minor++;}this.patch=0;this.prerelease=[];break;case'patch':// If this is not a pre-release version, it will increment the patch.\n// If it is a pre-release it will bump up to the same patch version.\n// 1.2.0-5 patches to 1.2.0\n// 1.2.0 patches to 1.2.1\nif(this.prerelease.length===0){this.patch++;}this.prerelease=[];break;// This probably shouldn't be used publicly.\n// 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\ncase'pre':if(this.prerelease.length===0){this.prerelease=[0];}else{let i=this.prerelease.length;while(--i>=0){if(typeof this.prerelease[i]==='number'){this.prerelease[i]++;i=-2;}}if(i===-1){// didn't increment anything\nthis.prerelease.push(0);}}if(identifier){// 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n// 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\nif(this.prerelease[0]===identifier){if(isNaN(this.prerelease[1])){this.prerelease=[identifier,0];}}else{this.prerelease=[identifier,0];}}break;default:throw new Error(\"invalid increment argument: \".concat(release));}this.format();this.raw=this.version;return this;}}var semver=SemVer;const compare=(a,b,loose)=>new semver(a,loose).compare(new semver(b,loose));var compare_1=compare;const lt=(a,b,loose)=>compare_1(a,b,loose)<0;var lt_1=lt;const gte=(a,b,loose)=>compare_1(a,b,loose)>=0;var gte_1=gte;var arrayify=(object,keyName)=>Object.entries(object).map(_ref=>{let[key,value]=_ref;return Object.assign({[keyName]:key},value);});var dedent_1=createCommonjsModule(function(module){function dedent(strings){var raw=void 0;if(typeof strings===\"string\"){// dedent can be used as a plain function\nraw=[strings];}else{raw=strings.raw;}// first, perform interpolation\nvar result=\"\";for(var i=0;i<raw.length;i++){result+=raw[i].// join lines when there is a suppressed newline\nreplace(/\\\\\\n[ \\t]*/g,\"\").// handle escaped backticks\nreplace(/\\\\`/g,\"`\");if(i<(arguments.length<=1?0:arguments.length-1)){result+=arguments.length<=i+1?undefined:arguments[i+1];}}// now strip indentation\nvar lines=result.split(\"\\n\");var mindent=null;lines.forEach(function(l){var m=l.match(/^(\\s+)\\S+/);if(m){var indent=m[1].length;if(!mindent){// this is the first indented line\nmindent=indent;}else{mindent=Math.min(mindent,indent);}}});if(mindent!==null){result=lines.map(function(l){return l[0]===\" \"?l.slice(mindent):l;}).join(\"\\n\");}// dedent eats leading and trailing whitespace too\nresult=result.trim();// handle escaped newlines at the end to ensure they don't get stripped too\nreturn result.replace(/\\\\n/g,\"\\n\");}{module.exports=dedent;}});function _templateObject6(){const data=_taggedTemplateLiteral([\"\\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\\n      in order for it to be formatted.\\n    \"]);_templateObject6=function _templateObject6(){return data;};return data;}function _templateObject5(){const data=_taggedTemplateLiteral([\"\\n      Format code starting at a given character offset.\\n      The range will extend backwards to the start of the first line containing the selected statement.\\n      This option cannot be used with --cursor-offset.\\n    \"]);_templateObject5=function _templateObject5(){return data;};return data;}function _templateObject4(){const data=_taggedTemplateLiteral([\"\\n      Format code ending at a given character offset (exclusive).\\n      The range will extend forwards to the end of the selected statement.\\n      This option cannot be used with --cursor-offset.\\n    \"]);_templateObject4=function _templateObject4(){return data;};return data;}function _templateObject3(){const data=_taggedTemplateLiteral([\"\\n      Custom directory that contains prettier plugins in node_modules subdirectory.\\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\\n      Multiple values are accepted.\\n    \"]);_templateObject3=function _templateObject3(){return data;};return data;}function _templateObject2(){const data=_taggedTemplateLiteral([\"\\n          Maintain existing\\n          (mixed values within one file are normalised by looking at what's used after the first line)\\n        \"]);_templateObject2=function _templateObject2(){return data;};return data;}function _templateObject(){const data=_taggedTemplateLiteral([\"\\n      Print (to stderr) where a cursor at the given position would move to after formatting.\\n      This option cannot be used with --range-start and --range-end.\\n    \"]);_templateObject=function _templateObject(){return data;};return data;}const CATEGORY_CONFIG=\"Config\";const CATEGORY_EDITOR=\"Editor\";const CATEGORY_FORMAT=\"Format\";const CATEGORY_OTHER=\"Other\";const CATEGORY_OUTPUT=\"Output\";const CATEGORY_GLOBAL=\"Global\";const CATEGORY_SPECIAL=\"Special\";/**\n   * @typedef {Object} OptionInfo\n   * @property {string} [since] - available since version\n   * @property {string} category\n   * @property {'int' | 'boolean' | 'choice' | 'path'} type\n   * @property {boolean} [array] - indicate it's an array of the specified type\n   * @property {OptionValueInfo} [default]\n   * @property {OptionRangeInfo} [range] - for type int\n   * @property {string} description\n   * @property {string} [deprecated] - deprecated since version\n   * @property {OptionRedirectInfo} [redirect] - redirect deprecated option\n   * @property {(value: any) => boolean} [exception]\n   * @property {OptionChoiceInfo[]} [choices] - for type choice\n   * @property {string} [cliName]\n   * @property {string} [cliCategory]\n   * @property {string} [cliDescription]\n   *\n   * @typedef {number | boolean | string} OptionValue\n   * @typedef {OptionValue | [{ value: OptionValue[] }] | Array<{ since: string, value: OptionValue}>} OptionValueInfo\n   *\n   * @typedef {Object} OptionRedirectInfo\n   * @property {string} option\n   * @property {OptionValue} value\n   *\n   * @typedef {Object} OptionRangeInfo\n   * @property {number} start - recommended range start\n   * @property {number} end - recommended range end\n   * @property {number} step - recommended range step\n   *\n   * @typedef {Object} OptionChoiceInfo\n   * @property {boolean | string} value - boolean for the option that is originally boolean type\n   * @property {string} description\n   * @property {string} [since] - undefined if available since the first version of the option\n   * @property {string} [deprecated] - deprecated since version\n   * @property {OptionValueInfo} [redirect] - redirect deprecated value\n   */ /** @type {{ [name: string]: OptionInfo }} */const options={cursorOffset:{since:\"1.4.0\",category:CATEGORY_SPECIAL,type:\"int\",default:-1,range:{start:-1,end:Infinity,step:1},description:dedent_1(_templateObject()),cliCategory:CATEGORY_EDITOR},endOfLine:{since:\"1.15.0\",category:CATEGORY_GLOBAL,type:\"choice\",default:[{since:\"1.15.0\",value:\"auto\"},{since:\"2.0.0\",value:\"lf\"}],description:\"Which end of line characters to apply.\",choices:[{value:\"lf\",description:\"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\"},{value:\"crlf\",description:\"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\"},{value:\"cr\",description:\"Carriage Return character only (\\\\r), used very rarely\"},{value:\"auto\",description:dedent_1(_templateObject2())}]},filepath:{since:\"1.4.0\",category:CATEGORY_SPECIAL,type:\"path\",description:\"Specify the input filepath. This will be used to do parser inference.\",cliName:\"stdin-filepath\",cliCategory:CATEGORY_OTHER,cliDescription:\"Path to the file to pretend that stdin comes from.\"},insertPragma:{since:\"1.8.0\",category:CATEGORY_SPECIAL,type:\"boolean\",default:false,description:\"Insert @format pragma into file's first docblock comment.\",cliCategory:CATEGORY_OTHER},parser:{since:\"0.0.10\",category:CATEGORY_GLOBAL,type:\"choice\",default:[{since:\"0.0.10\",value:\"babylon\"},{since:\"1.13.0\",value:undefined}],description:\"Which parser to use.\",exception:value=>typeof value===\"string\"||typeof value===\"function\",choices:[{value:\"flow\",description:\"Flow\"},{value:\"babel\",since:\"1.16.0\",description:\"JavaScript\"},{value:\"babel-flow\",since:\"1.16.0\",description:\"Flow\"},{value:\"babel-ts\",since:\"2.0.0\",description:\"TypeScript\"},{value:\"typescript\",since:\"1.4.0\",description:\"TypeScript\"},{value:\"css\",since:\"1.7.1\",description:\"CSS\"},{value:\"less\",since:\"1.7.1\",description:\"Less\"},{value:\"scss\",since:\"1.7.1\",description:\"SCSS\"},{value:\"json\",since:\"1.5.0\",description:\"JSON\"},{value:\"json5\",since:\"1.13.0\",description:\"JSON5\"},{value:\"json-stringify\",since:\"1.13.0\",description:\"JSON.stringify\"},{value:\"graphql\",since:\"1.5.0\",description:\"GraphQL\"},{value:\"markdown\",since:\"1.8.0\",description:\"Markdown\"},{value:\"mdx\",since:\"1.15.0\",description:\"MDX\"},{value:\"vue\",since:\"1.10.0\",description:\"Vue\"},{value:\"yaml\",since:\"1.14.0\",description:\"YAML\"},{value:\"glimmer\",since:null,description:\"Handlebars\"},{value:\"html\",since:\"1.15.0\",description:\"HTML\"},{value:\"angular\",since:\"1.15.0\",description:\"Angular\"},{value:\"lwc\",since:\"1.17.0\",description:\"Lightning Web Components\"}]},plugins:{since:\"1.10.0\",type:\"path\",array:true,default:[{value:[]}],category:CATEGORY_GLOBAL,description:\"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",exception:value=>typeof value===\"string\"||typeof value===\"object\",cliName:\"plugin\",cliCategory:CATEGORY_CONFIG},pluginSearchDirs:{since:\"1.13.0\",type:\"path\",array:true,default:[{value:[]}],category:CATEGORY_GLOBAL,description:dedent_1(_templateObject3()),exception:value=>typeof value===\"string\"||typeof value===\"object\",cliName:\"plugin-search-dir\",cliCategory:CATEGORY_CONFIG},printWidth:{since:\"0.0.0\",category:CATEGORY_GLOBAL,type:\"int\",default:80,description:\"The line length where Prettier will try wrap.\",range:{start:0,end:Infinity,step:1}},rangeEnd:{since:\"1.4.0\",category:CATEGORY_SPECIAL,type:\"int\",default:Infinity,range:{start:0,end:Infinity,step:1},description:dedent_1(_templateObject4()),cliCategory:CATEGORY_EDITOR},rangeStart:{since:\"1.4.0\",category:CATEGORY_SPECIAL,type:\"int\",default:0,range:{start:0,end:Infinity,step:1},description:dedent_1(_templateObject5()),cliCategory:CATEGORY_EDITOR},requirePragma:{since:\"1.7.0\",category:CATEGORY_SPECIAL,type:\"boolean\",default:false,description:dedent_1(_templateObject6()),cliCategory:CATEGORY_OTHER},tabWidth:{type:\"int\",category:CATEGORY_GLOBAL,default:2,description:\"Number of spaces per indentation level.\",range:{start:0,end:Infinity,step:1}},useTabs:{since:\"1.0.0\",category:CATEGORY_GLOBAL,type:\"boolean\",default:false,description:\"Indent with tabs instead of spaces.\"}};var coreOptions={CATEGORY_CONFIG,CATEGORY_EDITOR,CATEGORY_FORMAT,CATEGORY_OTHER,CATEGORY_OUTPUT,CATEGORY_GLOBAL,CATEGORY_SPECIAL,options};var require$$0=getCjsExportFromNamespace(_package$1);const semver$1={compare:compare_1,lt:lt_1,gte:gte_1};const currentVersion=require$$0.version;const coreOptions$1=coreOptions.options;/**\n   * Strings in `plugins` and `pluginSearchDirs` are handled by a wrapped version\n   * of this function created by `withPlugins`. Don't pass them here directly.\n   * @param {object} param0\n   * @param {(string | object)[]=} param0.plugins Strings are resolved by `withPlugins`.\n   * @param {string[]=} param0.pluginSearchDirs Added by `withPlugins`.\n   * @param {boolean=} param0.showUnreleased\n   * @param {boolean=} param0.showDeprecated\n   * @param {boolean=} param0.showInternal\n   */function getSupportInfo(){let{plugins=[],showUnreleased=false,showDeprecated=false,showInternal=false}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// pre-release version is smaller than the normal version in semver,\n// we need to treat it as the normal one so as to test new features.\nconst version=currentVersion.split(\"-\",1)[0];const options=arrayify(Object.assign({},...plugins.map(_ref2=>{let{options}=_ref2;return options;}),coreOptions$1),\"name\").filter(option=>filterSince(option)&&filterDeprecated(option)).sort((a,b)=>a.name===b.name?0:a.name<b.name?-1:1).map(mapInternal).map(option=>{option=Object.assign({},option);if(Array.isArray(option.default)){option.default=option.default.length===1?option.default[0].value:option.default.filter(filterSince).sort((info1,info2)=>semver$1.compare(info2.since,info1.since))[0].value;}if(Array.isArray(option.choices)){option.choices=option.choices.filter(option=>filterSince(option)&&filterDeprecated(option));}const filteredPlugins=plugins.filter(plugin=>plugin.defaultOptions&&plugin.defaultOptions[option.name]!==undefined);const pluginDefaults=filteredPlugins.reduce((reduced,plugin)=>{reduced[plugin.name]=plugin.defaultOptions[option.name];return reduced;},{});return Object.assign({},option,{pluginDefaults});});const languages=plugins.reduce((all,plugin)=>all.concat(plugin.languages||[]),[]).filter(filterSince);return{languages,options};function filterSince(object){return showUnreleased||!(\"since\"in object)||object.since&&semver$1.gte(version,object.since);}function filterDeprecated(object){return showDeprecated||!(\"deprecated\"in object)||object.deprecated&&semver$1.lt(version,object.deprecated);}function mapInternal(object){if(showInternal){return object;}const newObject=_objectWithoutPropertiesLoose(object,[\"cliName\",\"cliCategory\",\"cliDescription\"]);return newObject;}}var support={getSupportInfo};/*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n  See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */ /* global Reflect, Promise */var _extendStatics=function extendStatics(d,b){_extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return _extendStatics(d,b);};function __extends(d,b){_extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());}var _assign=function __assign(){_assign=Object.assign||function __assign(t){for(var s,i=1,n=arguments.length;i<n;i++){s=arguments[i];for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p))t[p]=s[p];}return t;};return _assign.apply(this,arguments);};function __rest(s,e){var t={};for(var p in s)if(Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0)t[p]=s[p];if(s!=null&&typeof Object.getOwnPropertySymbols===\"function\")for(var i=0,p=Object.getOwnPropertySymbols(s);i<p.length;i++){if(e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i]))t[p[i]]=s[p[i]];}return t;}function __decorate(decorators,target,key,desc){var c=arguments.length,r=c<3?target:desc===null?desc=Object.getOwnPropertyDescriptor(target,key):desc,d;if(typeof Reflect===\"object\"&&typeof Reflect.decorate===\"function\")r=Reflect.decorate(decorators,target,key,desc);else for(var i=decorators.length-1;i>=0;i--)if(d=decorators[i])r=(c<3?d(r):c>3?d(target,key,r):d(target,key))||r;return c>3&&r&&Object.defineProperty(target,key,r),r;}function __param(paramIndex,decorator){return function(target,key){decorator(target,key,paramIndex);};}function __metadata(metadataKey,metadataValue){if(typeof Reflect===\"object\"&&typeof Reflect.metadata===\"function\")return Reflect.metadata(metadataKey,metadataValue);}function __awaiter(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value);}).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});}function __generator(thisArg,body){var _={label:0,sent:function sent(){if(t[0]&1)throw t[1];return t[1];},trys:[],ops:[]},f,y,t,g;return g={next:verb(0),\"throw\":verb(1),\"return\":verb(2)},typeof Symbol===\"function\"&&(g[Symbol.iterator]=function(){return this;}),g;function verb(n){return function(v){return step([n,v]);};}function step(op){if(f)throw new TypeError(\"Generator is already executing.\");while(_)try{if(f=1,y&&(t=op[0]&2?y[\"return\"]:op[0]?y[\"throw\"]||((t=y[\"return\"])&&t.call(y),0):y.next)&&!(t=t.call(y,op[1])).done)return t;if(y=0,t)op=[op[0]&2,t.value];switch(op[0]){case 0:case 1:t=op;break;case 4:_.label++;return{value:op[1],done:false};case 5:_.label++;y=op[1];op=[0];continue;case 7:op=_.ops.pop();_.trys.pop();continue;default:if(!(t=_.trys,t=t.length>0&&t[t.length-1])&&(op[0]===6||op[0]===2)){_=0;continue;}if(op[0]===3&&(!t||op[1]>t[0]&&op[1]<t[3])){_.label=op[1];break;}if(op[0]===6&&_.label<t[1]){_.label=t[1];t=op;break;}if(t&&_.label<t[2]){_.label=t[2];_.ops.push(op);break;}if(t[2])_.ops.pop();_.trys.pop();continue;}op=body.call(thisArg,_);}catch(e){op=[6,e];y=0;}finally{f=t=0;}if(op[0]&5)throw op[1];return{value:op[0]?op[1]:void 0,done:true};}}function __exportStar(m,exports){for(var p in m)if(!exports.hasOwnProperty(p))exports[p]=m[p];}function __values(o){var m=typeof Symbol===\"function\"&&o[Symbol.iterator],i=0;if(m)return m.call(o);return{next:function next(){if(o&&i>=o.length)o=void 0;return{value:o&&o[i++],done:!o};}};}function __read(o,n){var m=typeof Symbol===\"function\"&&o[Symbol.iterator];if(!m)return o;var i=m.call(o),r,ar=[],e;try{while((n===void 0||n-->0)&&!(r=i.next()).done)ar.push(r.value);}catch(error){e={error:error};}finally{try{if(r&&!r.done&&(m=i[\"return\"]))m.call(i);}finally{if(e)throw e.error;}}return ar;}function __spread(){for(var ar=[],i=0;i<arguments.length;i++)ar=ar.concat(__read(arguments[i]));return ar;}function __spreadArrays(){for(var s=0,i=0,il=arguments.length;i<il;i++)s+=arguments[i].length;for(var r=Array(s),k=0,i=0;i<il;i++)for(var a=arguments[i],j=0,jl=a.length;j<jl;j++,k++)r[k]=a[j];return r;}function __await(v){return this instanceof __await?(this.v=v,this):new __await(v);}function __asyncGenerator(thisArg,_arguments,generator){if(!Symbol.asyncIterator)throw new TypeError(\"Symbol.asyncIterator is not defined.\");var g=generator.apply(thisArg,_arguments||[]),i,q=[];return i={},verb(\"next\"),verb(\"throw\"),verb(\"return\"),i[Symbol.asyncIterator]=function(){return this;},i;function verb(n){if(g[n])i[n]=function(v){return new Promise(function(a,b){q.push([n,v,a,b])>1||resume(n,v);});};}function resume(n,v){try{step(g[n](v));}catch(e){settle(q[0][3],e);}}function step(r){r.value instanceof __await?Promise.resolve(r.value.v).then(fulfill,reject):settle(q[0][2],r);}function fulfill(value){resume(\"next\",value);}function reject(value){resume(\"throw\",value);}function settle(f,v){if(f(v),q.shift(),q.length)resume(q[0][0],q[0][1]);}}function __asyncDelegator(o){var i,p;return i={},verb(\"next\"),verb(\"throw\",function(e){throw e;}),verb(\"return\"),i[Symbol.iterator]=function(){return this;},i;function verb(n,f){i[n]=o[n]?function(v){return(p=!p)?{value:__await(o[n](v)),done:n===\"return\"}:f?f(v):v;}:f;}}function __asyncValues(o){if(!Symbol.asyncIterator)throw new TypeError(\"Symbol.asyncIterator is not defined.\");var m=o[Symbol.asyncIterator],i;return m?m.call(o):(o=typeof __values===\"function\"?__values(o):o[Symbol.iterator](),i={},verb(\"next\"),verb(\"throw\"),verb(\"return\"),i[Symbol.asyncIterator]=function(){return this;},i);function verb(n){i[n]=o[n]&&function(v){return new Promise(function(resolve,reject){v=o[n](v),settle(resolve,reject,v.done,v.value);});};}function settle(resolve,reject,d,v){Promise.resolve(v).then(function(v){resolve({value:v,done:d});},reject);}}function __makeTemplateObject(cooked,raw){if(Object.defineProperty){Object.defineProperty(cooked,\"raw\",{value:raw});}else{cooked.raw=raw;}return cooked;}function __importStar(mod){if(mod&&mod.__esModule)return mod;var result={};if(mod!=null)for(var k in mod)if(Object.hasOwnProperty.call(mod,k))result[k]=mod[k];result.default=mod;return result;}function __importDefault(mod){return mod&&mod.__esModule?mod:{default:mod};}var tslib_es6=/*#__PURE__*/Object.freeze({__proto__:null,__extends:__extends,get __assign(){return _assign;},__rest:__rest,__decorate:__decorate,__param:__param,__metadata:__metadata,__awaiter:__awaiter,__generator:__generator,__exportStar:__exportStar,__values:__values,__read:__read,__spread:__spread,__spreadArrays:__spreadArrays,__await:__await,__asyncGenerator:__asyncGenerator,__asyncDelegator:__asyncDelegator,__asyncValues:__asyncValues,__makeTemplateObject:__makeTemplateObject,__importStar:__importStar,__importDefault:__importDefault});var api=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});exports.apiDescriptor={key:_key=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(_key)?_key:JSON.stringify(_key),value(value){if(value===null||typeof value!=='object'){return JSON.stringify(value);}if(Array.isArray(value)){return\"[\".concat(value.map(subValue=>exports.apiDescriptor.value(subValue)).join(', '),\"]\");}const keys=Object.keys(value);return keys.length===0?'{}':\"{ \".concat(keys.map(key=>\"\".concat(exports.apiDescriptor.key(key),\": \").concat(exports.apiDescriptor.value(value[key]))).join(', '),\" }\");},pair:_ref3=>{let{key,value}=_ref3;return exports.apiDescriptor.value({[key]:value});}};});unwrapExports(api);var api_1=api.apiDescriptor;var tslib_1=getCjsExportFromNamespace(tslib_es6);var descriptors=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});tslib_1.__exportStar(api,exports);});unwrapExports(descriptors);var matchOperatorsRe=/[|\\\\{}()[\\]^$+*?.]/g;var escapeStringRegexp=function escapeStringRegexp(str){if(typeof str!=='string'){throw new TypeError('Expected a string');}return str.replace(matchOperatorsRe,'\\\\$&');};var colorName={\"aliceblue\":[240,248,255],\"antiquewhite\":[250,235,215],\"aqua\":[0,255,255],\"aquamarine\":[127,255,212],\"azure\":[240,255,255],\"beige\":[245,245,220],\"bisque\":[255,228,196],\"black\":[0,0,0],\"blanchedalmond\":[255,235,205],\"blue\":[0,0,255],\"blueviolet\":[138,43,226],\"brown\":[165,42,42],\"burlywood\":[222,184,135],\"cadetblue\":[95,158,160],\"chartreuse\":[127,255,0],\"chocolate\":[210,105,30],\"coral\":[255,127,80],\"cornflowerblue\":[100,149,237],\"cornsilk\":[255,248,220],\"crimson\":[220,20,60],\"cyan\":[0,255,255],\"darkblue\":[0,0,139],\"darkcyan\":[0,139,139],\"darkgoldenrod\":[184,134,11],\"darkgray\":[169,169,169],\"darkgreen\":[0,100,0],\"darkgrey\":[169,169,169],\"darkkhaki\":[189,183,107],\"darkmagenta\":[139,0,139],\"darkolivegreen\":[85,107,47],\"darkorange\":[255,140,0],\"darkorchid\":[153,50,204],\"darkred\":[139,0,0],\"darksalmon\":[233,150,122],\"darkseagreen\":[143,188,143],\"darkslateblue\":[72,61,139],\"darkslategray\":[47,79,79],\"darkslategrey\":[47,79,79],\"darkturquoise\":[0,206,209],\"darkviolet\":[148,0,211],\"deeppink\":[255,20,147],\"deepskyblue\":[0,191,255],\"dimgray\":[105,105,105],\"dimgrey\":[105,105,105],\"dodgerblue\":[30,144,255],\"firebrick\":[178,34,34],\"floralwhite\":[255,250,240],\"forestgreen\":[34,139,34],\"fuchsia\":[255,0,255],\"gainsboro\":[220,220,220],\"ghostwhite\":[248,248,255],\"gold\":[255,215,0],\"goldenrod\":[218,165,32],\"gray\":[128,128,128],\"green\":[0,128,0],\"greenyellow\":[173,255,47],\"grey\":[128,128,128],\"honeydew\":[240,255,240],\"hotpink\":[255,105,180],\"indianred\":[205,92,92],\"indigo\":[75,0,130],\"ivory\":[255,255,240],\"khaki\":[240,230,140],\"lavender\":[230,230,250],\"lavenderblush\":[255,240,245],\"lawngreen\":[124,252,0],\"lemonchiffon\":[255,250,205],\"lightblue\":[173,216,230],\"lightcoral\":[240,128,128],\"lightcyan\":[224,255,255],\"lightgoldenrodyellow\":[250,250,210],\"lightgray\":[211,211,211],\"lightgreen\":[144,238,144],\"lightgrey\":[211,211,211],\"lightpink\":[255,182,193],\"lightsalmon\":[255,160,122],\"lightseagreen\":[32,178,170],\"lightskyblue\":[135,206,250],\"lightslategray\":[119,136,153],\"lightslategrey\":[119,136,153],\"lightsteelblue\":[176,196,222],\"lightyellow\":[255,255,224],\"lime\":[0,255,0],\"limegreen\":[50,205,50],\"linen\":[250,240,230],\"magenta\":[255,0,255],\"maroon\":[128,0,0],\"mediumaquamarine\":[102,205,170],\"mediumblue\":[0,0,205],\"mediumorchid\":[186,85,211],\"mediumpurple\":[147,112,219],\"mediumseagreen\":[60,179,113],\"mediumslateblue\":[123,104,238],\"mediumspringgreen\":[0,250,154],\"mediumturquoise\":[72,209,204],\"mediumvioletred\":[199,21,133],\"midnightblue\":[25,25,112],\"mintcream\":[245,255,250],\"mistyrose\":[255,228,225],\"moccasin\":[255,228,181],\"navajowhite\":[255,222,173],\"navy\":[0,0,128],\"oldlace\":[253,245,230],\"olive\":[128,128,0],\"olivedrab\":[107,142,35],\"orange\":[255,165,0],\"orangered\":[255,69,0],\"orchid\":[218,112,214],\"palegoldenrod\":[238,232,170],\"palegreen\":[152,251,152],\"paleturquoise\":[175,238,238],\"palevioletred\":[219,112,147],\"papayawhip\":[255,239,213],\"peachpuff\":[255,218,185],\"peru\":[205,133,63],\"pink\":[255,192,203],\"plum\":[221,160,221],\"powderblue\":[176,224,230],\"purple\":[128,0,128],\"rebeccapurple\":[102,51,153],\"red\":[255,0,0],\"rosybrown\":[188,143,143],\"royalblue\":[65,105,225],\"saddlebrown\":[139,69,19],\"salmon\":[250,128,114],\"sandybrown\":[244,164,96],\"seagreen\":[46,139,87],\"seashell\":[255,245,238],\"sienna\":[160,82,45],\"silver\":[192,192,192],\"skyblue\":[135,206,235],\"slateblue\":[106,90,205],\"slategray\":[112,128,144],\"slategrey\":[112,128,144],\"snow\":[255,250,250],\"springgreen\":[0,255,127],\"steelblue\":[70,130,180],\"tan\":[210,180,140],\"teal\":[0,128,128],\"thistle\":[216,191,216],\"tomato\":[255,99,71],\"turquoise\":[64,224,208],\"violet\":[238,130,238],\"wheat\":[245,222,179],\"white\":[255,255,255],\"whitesmoke\":[245,245,245],\"yellow\":[255,255,0],\"yellowgreen\":[154,205,50]};var conversions=createCommonjsModule(function(module){/* MIT license */ // NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\nvar reverseKeywords={};for(var key in colorName){if(colorName.hasOwnProperty(key)){reverseKeywords[colorName[key]]=key;}}var convert=module.exports={rgb:{channels:3,labels:'rgb'},hsl:{channels:3,labels:'hsl'},hsv:{channels:3,labels:'hsv'},hwb:{channels:3,labels:'hwb'},cmyk:{channels:4,labels:'cmyk'},xyz:{channels:3,labels:'xyz'},lab:{channels:3,labels:'lab'},lch:{channels:3,labels:'lch'},hex:{channels:1,labels:['hex']},keyword:{channels:1,labels:['keyword']},ansi16:{channels:1,labels:['ansi16']},ansi256:{channels:1,labels:['ansi256']},hcg:{channels:3,labels:['h','c','g']},apple:{channels:3,labels:['r16','g16','b16']},gray:{channels:1,labels:['gray']}};// hide .channels and .labels properties\nfor(var model in convert){if(convert.hasOwnProperty(model)){if(!('channels'in convert[model])){throw new Error('missing channels property: '+model);}if(!('labels'in convert[model])){throw new Error('missing channel labels property: '+model);}if(convert[model].labels.length!==convert[model].channels){throw new Error('channel and label counts mismatch: '+model);}var channels=convert[model].channels;var labels=convert[model].labels;delete convert[model].channels;delete convert[model].labels;Object.defineProperty(convert[model],'channels',{value:channels});Object.defineProperty(convert[model],'labels',{value:labels});}}convert.rgb.hsl=function(rgb){var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;var min=Math.min(r,g,b);var max=Math.max(r,g,b);var delta=max-min;var h;var s;var l;if(max===min){h=0;}else if(r===max){h=(g-b)/delta;}else if(g===max){h=2+(b-r)/delta;}else if(b===max){h=4+(r-g)/delta;}h=Math.min(h*60,360);if(h<0){h+=360;}l=(min+max)/2;if(max===min){s=0;}else if(l<=0.5){s=delta/(max+min);}else{s=delta/(2-max-min);}return[h,s*100,l*100];};convert.rgb.hsv=function(rgb){var rdif;var gdif;var bdif;var h;var s;var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;var v=Math.max(r,g,b);var diff=v-Math.min(r,g,b);var diffc=function diffc(c){return(v-c)/6/diff+1/2;};if(diff===0){h=s=0;}else{s=diff/v;rdif=diffc(r);gdif=diffc(g);bdif=diffc(b);if(r===v){h=bdif-gdif;}else if(g===v){h=1/3+rdif-bdif;}else if(b===v){h=2/3+gdif-rdif;}if(h<0){h+=1;}else if(h>1){h-=1;}}return[h*360,s*100,v*100];};convert.rgb.hwb=function(rgb){var r=rgb[0];var g=rgb[1];var b=rgb[2];var h=convert.rgb.hsl(rgb)[0];var w=1/255*Math.min(r,Math.min(g,b));b=1-1/255*Math.max(r,Math.max(g,b));return[h,w*100,b*100];};convert.rgb.cmyk=function(rgb){var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;var c;var m;var y;var k;k=Math.min(1-r,1-g,1-b);c=(1-r-k)/(1-k)||0;m=(1-g-k)/(1-k)||0;y=(1-b-k)/(1-k)||0;return[c*100,m*100,y*100,k*100];};/**\n     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n     * */function comparativeDistance(x,y){return Math.pow(x[0]-y[0],2)+Math.pow(x[1]-y[1],2)+Math.pow(x[2]-y[2],2);}convert.rgb.keyword=function(rgb){var reversed=reverseKeywords[rgb];if(reversed){return reversed;}var currentClosestDistance=Infinity;var currentClosestKeyword;for(var keyword in colorName){if(colorName.hasOwnProperty(keyword)){var value=colorName[keyword];// Compute comparative distance\nvar distance=comparativeDistance(rgb,value);// Check if its less, if so set as closest\nif(distance<currentClosestDistance){currentClosestDistance=distance;currentClosestKeyword=keyword;}}}return currentClosestKeyword;};convert.keyword.rgb=function(keyword){return colorName[keyword];};convert.rgb.xyz=function(rgb){var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;// assume sRGB\nr=r>0.04045?Math.pow((r+0.055)/1.055,2.4):r/12.92;g=g>0.04045?Math.pow((g+0.055)/1.055,2.4):g/12.92;b=b>0.04045?Math.pow((b+0.055)/1.055,2.4):b/12.92;var x=r*0.4124+g*0.3576+b*0.1805;var y=r*0.2126+g*0.7152+b*0.0722;var z=r*0.0193+g*0.1192+b*0.9505;return[x*100,y*100,z*100];};convert.rgb.lab=function(rgb){var xyz=convert.rgb.xyz(rgb);var x=xyz[0];var y=xyz[1];var z=xyz[2];var l;var a;var b;x/=95.047;y/=100;z/=108.883;x=x>0.008856?Math.pow(x,1/3):7.787*x+16/116;y=y>0.008856?Math.pow(y,1/3):7.787*y+16/116;z=z>0.008856?Math.pow(z,1/3):7.787*z+16/116;l=116*y-16;a=500*(x-y);b=200*(y-z);return[l,a,b];};convert.hsl.rgb=function(hsl){var h=hsl[0]/360;var s=hsl[1]/100;var l=hsl[2]/100;var t1;var t2;var t3;var rgb;var val;if(s===0){val=l*255;return[val,val,val];}if(l<0.5){t2=l*(1+s);}else{t2=l+s-l*s;}t1=2*l-t2;rgb=[0,0,0];for(var i=0;i<3;i++){t3=h+1/3*-(i-1);if(t3<0){t3++;}if(t3>1){t3--;}if(6*t3<1){val=t1+(t2-t1)*6*t3;}else if(2*t3<1){val=t2;}else if(3*t3<2){val=t1+(t2-t1)*(2/3-t3)*6;}else{val=t1;}rgb[i]=val*255;}return rgb;};convert.hsl.hsv=function(hsl){var h=hsl[0];var s=hsl[1]/100;var l=hsl[2]/100;var smin=s;var lmin=Math.max(l,0.01);var sv;var v;l*=2;s*=l<=1?l:2-l;smin*=lmin<=1?lmin:2-lmin;v=(l+s)/2;sv=l===0?2*smin/(lmin+smin):2*s/(l+s);return[h,sv*100,v*100];};convert.hsv.rgb=function(hsv){var h=hsv[0]/60;var s=hsv[1]/100;var v=hsv[2]/100;var hi=Math.floor(h)%6;var f=h-Math.floor(h);var p=255*v*(1-s);var q=255*v*(1-s*f);var t=255*v*(1-s*(1-f));v*=255;switch(hi){case 0:return[v,t,p];case 1:return[q,v,p];case 2:return[p,v,t];case 3:return[p,q,v];case 4:return[t,p,v];case 5:return[v,p,q];}};convert.hsv.hsl=function(hsv){var h=hsv[0];var s=hsv[1]/100;var v=hsv[2]/100;var vmin=Math.max(v,0.01);var lmin;var sl;var l;l=(2-s)*v;lmin=(2-s)*vmin;sl=s*vmin;sl/=lmin<=1?lmin:2-lmin;sl=sl||0;l/=2;return[h,sl*100,l*100];};// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb=function(hwb){var h=hwb[0]/360;var wh=hwb[1]/100;var bl=hwb[2]/100;var ratio=wh+bl;var i;var v;var f;var n;// wh + bl cant be > 1\nif(ratio>1){wh/=ratio;bl/=ratio;}i=Math.floor(6*h);v=1-bl;f=6*h-i;if((i&0x01)!==0){f=1-f;}n=wh+f*(v-wh);// linear interpolation\nvar r;var g;var b;switch(i){default:case 6:case 0:r=v;g=n;b=wh;break;case 1:r=n;g=v;b=wh;break;case 2:r=wh;g=v;b=n;break;case 3:r=wh;g=n;b=v;break;case 4:r=n;g=wh;b=v;break;case 5:r=v;g=wh;b=n;break;}return[r*255,g*255,b*255];};convert.cmyk.rgb=function(cmyk){var c=cmyk[0]/100;var m=cmyk[1]/100;var y=cmyk[2]/100;var k=cmyk[3]/100;var r;var g;var b;r=1-Math.min(1,c*(1-k)+k);g=1-Math.min(1,m*(1-k)+k);b=1-Math.min(1,y*(1-k)+k);return[r*255,g*255,b*255];};convert.xyz.rgb=function(xyz){var x=xyz[0]/100;var y=xyz[1]/100;var z=xyz[2]/100;var r;var g;var b;r=x*3.2406+y*-1.5372+z*-0.4986;g=x*-0.9689+y*1.8758+z*0.0415;b=x*0.0557+y*-0.2040+z*1.0570;// assume sRGB\nr=r>0.0031308?1.055*Math.pow(r,1.0/2.4)-0.055:r*12.92;g=g>0.0031308?1.055*Math.pow(g,1.0/2.4)-0.055:g*12.92;b=b>0.0031308?1.055*Math.pow(b,1.0/2.4)-0.055:b*12.92;r=Math.min(Math.max(0,r),1);g=Math.min(Math.max(0,g),1);b=Math.min(Math.max(0,b),1);return[r*255,g*255,b*255];};convert.xyz.lab=function(xyz){var x=xyz[0];var y=xyz[1];var z=xyz[2];var l;var a;var b;x/=95.047;y/=100;z/=108.883;x=x>0.008856?Math.pow(x,1/3):7.787*x+16/116;y=y>0.008856?Math.pow(y,1/3):7.787*y+16/116;z=z>0.008856?Math.pow(z,1/3):7.787*z+16/116;l=116*y-16;a=500*(x-y);b=200*(y-z);return[l,a,b];};convert.lab.xyz=function(lab){var l=lab[0];var a=lab[1];var b=lab[2];var x;var y;var z;y=(l+16)/116;x=a/500+y;z=y-b/200;var y2=Math.pow(y,3);var x2=Math.pow(x,3);var z2=Math.pow(z,3);y=y2>0.008856?y2:(y-16/116)/7.787;x=x2>0.008856?x2:(x-16/116)/7.787;z=z2>0.008856?z2:(z-16/116)/7.787;x*=95.047;y*=100;z*=108.883;return[x,y,z];};convert.lab.lch=function(lab){var l=lab[0];var a=lab[1];var b=lab[2];var hr;var h;var c;hr=Math.atan2(b,a);h=hr*360/2/Math.PI;if(h<0){h+=360;}c=Math.sqrt(a*a+b*b);return[l,c,h];};convert.lch.lab=function(lch){var l=lch[0];var c=lch[1];var h=lch[2];var a;var b;var hr;hr=h/360*2*Math.PI;a=c*Math.cos(hr);b=c*Math.sin(hr);return[l,a,b];};convert.rgb.ansi16=function(args){var r=args[0];var g=args[1];var b=args[2];var value=1 in arguments?arguments[1]:convert.rgb.hsv(args)[2];// hsv -> ansi16 optimization\nvalue=Math.round(value/50);if(value===0){return 30;}var ansi=30+(Math.round(b/255)<<2|Math.round(g/255)<<1|Math.round(r/255));if(value===2){ansi+=60;}return ansi;};convert.hsv.ansi16=function(args){// optimization here; we already know the value and don't need to get\n// it converted for us.\nreturn convert.rgb.ansi16(convert.hsv.rgb(args),args[2]);};convert.rgb.ansi256=function(args){var r=args[0];var g=args[1];var b=args[2];// we use the extended greyscale palette here, with the exception of\n// black and white. normal palette only has 4 greyscale shades.\nif(r===g&&g===b){if(r<8){return 16;}if(r>248){return 231;}return Math.round((r-8)/247*24)+232;}var ansi=16+36*Math.round(r/255*5)+6*Math.round(g/255*5)+Math.round(b/255*5);return ansi;};convert.ansi16.rgb=function(args){var color=args%10;// handle greyscale\nif(color===0||color===7){if(args>50){color+=3.5;}color=color/10.5*255;return[color,color,color];}var mult=(~~(args>50)+1)*0.5;var r=(color&1)*mult*255;var g=(color>>1&1)*mult*255;var b=(color>>2&1)*mult*255;return[r,g,b];};convert.ansi256.rgb=function(args){// handle greyscale\nif(args>=232){var c=(args-232)*10+8;return[c,c,c];}args-=16;var rem;var r=Math.floor(args/36)/5*255;var g=Math.floor((rem=args%36)/6)/5*255;var b=rem%6/5*255;return[r,g,b];};convert.rgb.hex=function(args){var integer=((Math.round(args[0])&0xFF)<<16)+((Math.round(args[1])&0xFF)<<8)+(Math.round(args[2])&0xFF);var string=integer.toString(16).toUpperCase();return'000000'.substring(string.length)+string;};convert.hex.rgb=function(args){var match=args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!match){return[0,0,0];}var colorString=match[0];if(match[0].length===3){colorString=colorString.split('').map(function(char){return char+char;}).join('');}var integer=parseInt(colorString,16);var r=integer>>16&0xFF;var g=integer>>8&0xFF;var b=integer&0xFF;return[r,g,b];};convert.rgb.hcg=function(rgb){var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;var max=Math.max(Math.max(r,g),b);var min=Math.min(Math.min(r,g),b);var chroma=max-min;var grayscale;var hue;if(chroma<1){grayscale=min/(1-chroma);}else{grayscale=0;}if(chroma<=0){hue=0;}else if(max===r){hue=(g-b)/chroma%6;}else if(max===g){hue=2+(b-r)/chroma;}else{hue=4+(r-g)/chroma+4;}hue/=6;hue%=1;return[hue*360,chroma*100,grayscale*100];};convert.hsl.hcg=function(hsl){var s=hsl[1]/100;var l=hsl[2]/100;var c=1;var f=0;if(l<0.5){c=2.0*s*l;}else{c=2.0*s*(1.0-l);}if(c<1.0){f=(l-0.5*c)/(1.0-c);}return[hsl[0],c*100,f*100];};convert.hsv.hcg=function(hsv){var s=hsv[1]/100;var v=hsv[2]/100;var c=s*v;var f=0;if(c<1.0){f=(v-c)/(1-c);}return[hsv[0],c*100,f*100];};convert.hcg.rgb=function(hcg){var h=hcg[0]/360;var c=hcg[1]/100;var g=hcg[2]/100;if(c===0.0){return[g*255,g*255,g*255];}var pure=[0,0,0];var hi=h%1*6;var v=hi%1;var w=1-v;var mg=0;switch(Math.floor(hi)){case 0:pure[0]=1;pure[1]=v;pure[2]=0;break;case 1:pure[0]=w;pure[1]=1;pure[2]=0;break;case 2:pure[0]=0;pure[1]=1;pure[2]=v;break;case 3:pure[0]=0;pure[1]=w;pure[2]=1;break;case 4:pure[0]=v;pure[1]=0;pure[2]=1;break;default:pure[0]=1;pure[1]=0;pure[2]=w;}mg=(1.0-c)*g;return[(c*pure[0]+mg)*255,(c*pure[1]+mg)*255,(c*pure[2]+mg)*255];};convert.hcg.hsv=function(hcg){var c=hcg[1]/100;var g=hcg[2]/100;var v=c+g*(1.0-c);var f=0;if(v>0.0){f=c/v;}return[hcg[0],f*100,v*100];};convert.hcg.hsl=function(hcg){var c=hcg[1]/100;var g=hcg[2]/100;var l=g*(1.0-c)+0.5*c;var s=0;if(l>0.0&&l<0.5){s=c/(2*l);}else if(l>=0.5&&l<1.0){s=c/(2*(1-l));}return[hcg[0],s*100,l*100];};convert.hcg.hwb=function(hcg){var c=hcg[1]/100;var g=hcg[2]/100;var v=c+g*(1.0-c);return[hcg[0],(v-c)*100,(1-v)*100];};convert.hwb.hcg=function(hwb){var w=hwb[1]/100;var b=hwb[2]/100;var v=1-b;var c=v-w;var g=0;if(c<1){g=(v-c)/(1-c);}return[hwb[0],c*100,g*100];};convert.apple.rgb=function(apple){return[apple[0]/65535*255,apple[1]/65535*255,apple[2]/65535*255];};convert.rgb.apple=function(rgb){return[rgb[0]/255*65535,rgb[1]/255*65535,rgb[2]/255*65535];};convert.gray.rgb=function(args){return[args[0]/100*255,args[0]/100*255,args[0]/100*255];};convert.gray.hsl=convert.gray.hsv=function(args){return[0,0,args[0]];};convert.gray.hwb=function(gray){return[0,100,gray[0]];};convert.gray.cmyk=function(gray){return[0,0,0,gray[0]];};convert.gray.lab=function(gray){return[gray[0],0,0];};convert.gray.hex=function(gray){var val=Math.round(gray[0]/100*255)&0xFF;var integer=(val<<16)+(val<<8)+val;var string=integer.toString(16).toUpperCase();return'000000'.substring(string.length)+string;};convert.rgb.gray=function(rgb){var val=(rgb[0]+rgb[1]+rgb[2])/3;return[val/255*100];};});var conversions_1=conversions.rgb;var conversions_2=conversions.hsl;var conversions_3=conversions.hsv;var conversions_4=conversions.hwb;var conversions_5=conversions.cmyk;var conversions_6=conversions.xyz;var conversions_7=conversions.lab;var conversions_8=conversions.lch;var conversions_9=conversions.hex;var conversions_10=conversions.keyword;var conversions_11=conversions.ansi16;var conversions_12=conversions.ansi256;var conversions_13=conversions.hcg;var conversions_14=conversions.apple;var conversions_15=conversions.gray;/*\n  \tthis function routes a model to all other models.\n\n  \tall functions that are routed have a property `.conversion` attached\n  \tto the returned synthetic function. This property is an array\n  \tof strings, each with the steps in between the 'from' and 'to'\n  \tcolor models (inclusive).\n\n  \tconversions that are not possible simply are not included.\n  */function buildGraph(){var graph={};// https://jsperf.com/object-keys-vs-for-in-with-closure/3\nvar models=Object.keys(conversions);for(var len=models.length,i=0;i<len;i++){graph[models[i]]={// http://jsperf.com/1-vs-infinity\n// micro-opt, but this is simple.\ndistance:-1,parent:null};}return graph;}// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel){var graph=buildGraph();var queue=[fromModel];// unshift -> queue -> pop\ngraph[fromModel].distance=0;while(queue.length){var current=queue.pop();var adjacents=Object.keys(conversions[current]);for(var len=adjacents.length,i=0;i<len;i++){var adjacent=adjacents[i];var node=graph[adjacent];if(node.distance===-1){node.distance=graph[current].distance+1;node.parent=current;queue.unshift(adjacent);}}}return graph;}function link(from,to){return function(args){return to(from(args));};}function wrapConversion(toModel,graph){var path=[graph[toModel].parent,toModel];var fn=conversions[graph[toModel].parent][toModel];var cur=graph[toModel].parent;while(graph[cur].parent){path.unshift(graph[cur].parent);fn=link(conversions[graph[cur].parent][cur],fn);cur=graph[cur].parent;}fn.conversion=path;return fn;}var route=function route(fromModel){var graph=deriveBFS(fromModel);var conversion={};var models=Object.keys(graph);for(var len=models.length,i=0;i<len;i++){var toModel=models[i];var node=graph[toModel];if(node.parent===null){// no possible conversion, or this node is the source model.\ncontinue;}conversion[toModel]=wrapConversion(toModel,graph);}return conversion;};var convert={};var models=Object.keys(conversions);function wrapRaw(fn){var wrappedFn=function wrappedFn(args){if(args===undefined||args===null){return args;}if(arguments.length>1){args=Array.prototype.slice.call(arguments);}return fn(args);};// preserve .conversion property if there is one\nif('conversion'in fn){wrappedFn.conversion=fn.conversion;}return wrappedFn;}function wrapRounded(fn){var wrappedFn=function wrappedFn(args){if(args===undefined||args===null){return args;}if(arguments.length>1){args=Array.prototype.slice.call(arguments);}var result=fn(args);// we're assuming the result is an array here.\n// see notice in conversions.js; don't use box types\n// in conversion functions.\nif(typeof result==='object'){for(var len=result.length,i=0;i<len;i++){result[i]=Math.round(result[i]);}}return result;};// preserve .conversion property if there is one\nif('conversion'in fn){wrappedFn.conversion=fn.conversion;}return wrappedFn;}models.forEach(function(fromModel){convert[fromModel]={};Object.defineProperty(convert[fromModel],'channels',{value:conversions[fromModel].channels});Object.defineProperty(convert[fromModel],'labels',{value:conversions[fromModel].labels});var routes=route(fromModel);var routeModels=Object.keys(routes);routeModels.forEach(function(toModel){var fn=routes[toModel];convert[fromModel][toModel]=wrapRounded(fn);convert[fromModel][toModel].raw=wrapRaw(fn);});});var colorConvert=convert;var ansiStyles=createCommonjsModule(function(module){const wrapAnsi16=(fn,offset)=>function(){const code=fn.apply(colorConvert,arguments);return\"\\x1B[\".concat(code+offset,\"m\");};const wrapAnsi256=(fn,offset)=>function(){const code=fn.apply(colorConvert,arguments);return\"\\x1B[\".concat(38+offset,\";5;\").concat(code,\"m\");};const wrapAnsi16m=(fn,offset)=>function(){const rgb=fn.apply(colorConvert,arguments);return\"\\x1B[\".concat(38+offset,\";2;\").concat(rgb[0],\";\").concat(rgb[1],\";\").concat(rgb[2],\"m\");};function assembleStyles(){const codes=new Map();const styles={modifier:{reset:[0,0],// 21 isn't widely supported and 22 does the same thing\nbold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],// Bright color\nredBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],// Bright color\nbgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};// Fix humans\nstyles.color.grey=styles.color.gray;for(const groupName of Object.keys(styles)){const group=styles[groupName];for(const styleName of Object.keys(group)){const style=group[styleName];styles[styleName]={open:\"\\x1B[\".concat(style[0],\"m\"),close:\"\\x1B[\".concat(style[1],\"m\")};group[styleName]=styles[styleName];codes.set(style[0],style[1]);}Object.defineProperty(styles,groupName,{value:group,enumerable:false});Object.defineProperty(styles,'codes',{value:codes,enumerable:false});}const ansi2ansi=n=>n;const rgb2rgb=(r,g,b)=>[r,g,b];styles.color.close='\\u001B[39m';styles.bgColor.close='\\u001B[49m';styles.color.ansi={ansi:wrapAnsi16(ansi2ansi,0)};styles.color.ansi256={ansi256:wrapAnsi256(ansi2ansi,0)};styles.color.ansi16m={rgb:wrapAnsi16m(rgb2rgb,0)};styles.bgColor.ansi={ansi:wrapAnsi16(ansi2ansi,10)};styles.bgColor.ansi256={ansi256:wrapAnsi256(ansi2ansi,10)};styles.bgColor.ansi16m={rgb:wrapAnsi16m(rgb2rgb,10)};for(let key of Object.keys(colorConvert)){if(typeof colorConvert[key]!=='object'){continue;}const suite=colorConvert[key];if(key==='ansi16'){key='ansi';}if('ansi16'in suite){styles.color.ansi[key]=wrapAnsi16(suite.ansi16,0);styles.bgColor.ansi[key]=wrapAnsi16(suite.ansi16,10);}if('ansi256'in suite){styles.color.ansi256[key]=wrapAnsi256(suite.ansi256,0);styles.bgColor.ansi256[key]=wrapAnsi256(suite.ansi256,10);}if('rgb'in suite){styles.color.ansi16m[key]=wrapAnsi16m(suite.rgb,0);styles.bgColor.ansi16m[key]=wrapAnsi16m(suite.rgb,10);}}return styles;}// Make the export immutable\nObject.defineProperty(module,'exports',{enumerable:true,get:assembleStyles});});var require$$0$1={EOL:\"\\n\"};var hasFlag=(flag,argv)=>{argv=argv||process.argv;const prefix=flag.startsWith('-')?'':flag.length===1?'-':'--';const pos=argv.indexOf(prefix+flag);const terminatorPos=argv.indexOf('--');return pos!==-1&&(terminatorPos===-1?true:pos<terminatorPos);};const env$1=process.env;let forceColor;if(hasFlag('no-color')||hasFlag('no-colors')||hasFlag('color=false')){forceColor=false;}else if(hasFlag('color')||hasFlag('colors')||hasFlag('color=true')||hasFlag('color=always')){forceColor=true;}if('FORCE_COLOR'in env$1){forceColor=env$1.FORCE_COLOR.length===0||parseInt(env$1.FORCE_COLOR,10)!==0;}function translateLevel(level){if(level===0){return false;}return{level,hasBasic:true,has256:level>=2,has16m:level>=3};}function supportsColor(stream){if(forceColor===false){return 0;}if(hasFlag('color=16m')||hasFlag('color=full')||hasFlag('color=truecolor')){return 3;}if(hasFlag('color=256')){return 2;}if(stream&&!stream.isTTY&&forceColor!==true){return 0;}const min=forceColor?1:0;if(process.platform==='win32'){// Node.js 7.5.0 is the first version of Node.js to include a patch to\n// libuv that enables 256 color output on Windows. Anything earlier and it\n// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n// release that supports 256 colors. Windows 10 build 14931 is the first release\n// that supports 16m/TrueColor.\nconst osRelease=require$$0$1.release().split('.');if(Number(process.versions.node.split('.')[0])>=8&&Number(osRelease[0])>=10&&Number(osRelease[2])>=10586){return Number(osRelease[2])>=14931?3:2;}return 1;}if('CI'in env$1){if(['TRAVIS','CIRCLECI','APPVEYOR','GITLAB_CI'].some(sign=>sign in env$1)||env$1.CI_NAME==='codeship'){return 1;}return min;}if('TEAMCITY_VERSION'in env$1){return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env$1.TEAMCITY_VERSION)?1:0;}if(env$1.COLORTERM==='truecolor'){return 3;}if('TERM_PROGRAM'in env$1){const version=parseInt((env$1.TERM_PROGRAM_VERSION||'').split('.')[0],10);switch(env$1.TERM_PROGRAM){case'iTerm.app':return version>=3?3:2;case'Apple_Terminal':return 2;// No default\n}}if(/-256(color)?$/i.test(env$1.TERM)){return 2;}if(/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)){return 1;}if('COLORTERM'in env$1){return 1;}if(env$1.TERM==='dumb'){return min;}return min;}function getSupportLevel(stream){const level=supportsColor(stream);return translateLevel(level);}var supportsColor_1={supportsColor:getSupportLevel,stdout:getSupportLevel(process.stdout),stderr:getSupportLevel(process.stderr)};const TEMPLATE_REGEX=/(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;const STYLE_REGEX=/(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;const STRING_REGEX=/^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;const ESCAPE_REGEX=/\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;const ESCAPES=new Map([['n','\\n'],['r','\\r'],['t','\\t'],['b','\\b'],['f','\\f'],['v','\\v'],['0','\\0'],['\\\\','\\\\'],['e','\\u001B'],['a','\\u0007']]);function unescape(c){if(c[0]==='u'&&c.length===5||c[0]==='x'&&c.length===3){return String.fromCharCode(parseInt(c.slice(1),16));}return ESCAPES.get(c)||c;}function parseArguments(name,args){const results=[];const chunks=args.trim().split(/\\s*,\\s*/g);let matches;for(const chunk of chunks){if(!isNaN(chunk)){results.push(Number(chunk));}else if(matches=chunk.match(STRING_REGEX)){results.push(matches[2].replace(ESCAPE_REGEX,(m,escape,chr)=>escape?unescape(escape):chr));}else{throw new Error(\"Invalid Chalk template style argument: \".concat(chunk,\" (in style '\").concat(name,\"')\"));}}return results;}function parseStyle(style){STYLE_REGEX.lastIndex=0;const results=[];let matches;while((matches=STYLE_REGEX.exec(style))!==null){const name=matches[1];if(matches[2]){const args=parseArguments(name,matches[2]);results.push([name].concat(args));}else{results.push([name]);}}return results;}function buildStyle(chalk,styles){const enabled={};for(const layer of styles){for(const style of layer.styles){enabled[style[0]]=layer.inverse?null:style.slice(1);}}let current=chalk;for(const styleName of Object.keys(enabled)){if(Array.isArray(enabled[styleName])){if(!(styleName in current)){throw new Error(\"Unknown Chalk style: \".concat(styleName));}if(enabled[styleName].length>0){current=current[styleName].apply(current,enabled[styleName]);}else{current=current[styleName];}}}return current;}var templates=(chalk,tmp)=>{const styles=[];const chunks=[];let chunk=[];// eslint-disable-next-line max-params\ntmp.replace(TEMPLATE_REGEX,(m,escapeChar,inverse,style,close,chr)=>{if(escapeChar){chunk.push(unescape(escapeChar));}else if(style){const str=chunk.join('');chunk=[];chunks.push(styles.length===0?str:buildStyle(chalk,styles)(str));styles.push({inverse,styles:parseStyle(style)});}else if(close){if(styles.length===0){throw new Error('Found extraneous } in Chalk template literal');}chunks.push(buildStyle(chalk,styles)(chunk.join('')));chunk=[];styles.pop();}else{chunk.push(chr);}});chunks.push(chunk.join(''));if(styles.length>0){const errMsg=\"Chalk template literal is missing \".concat(styles.length,\" closing bracket\").concat(styles.length===1?'':'s',\" (`}`)\");throw new Error(errMsg);}return chunks.join('');};var chalk=createCommonjsModule(function(module){const stdoutColor=supportsColor_1.stdout;const isSimpleWindowsTerm=process.platform==='win32'&&!(process.env.TERM||'').toLowerCase().startsWith('xterm');// `supportsColor.level` → `ansiStyles.color[name]` mapping\nconst levelMapping=['ansi','ansi','ansi256','ansi16m'];// `color-convert` models to exclude from the Chalk API due to conflicts and such\nconst skipModels=new Set(['gray']);const styles=Object.create(null);function applyOptions(obj,options){options=options||{};// Detect level if not set manually\nconst scLevel=stdoutColor?stdoutColor.level:0;obj.level=options.level===undefined?scLevel:options.level;obj.enabled='enabled'in options?options.enabled:obj.level>0;}function Chalk(options){// We check for this.template here since calling `chalk.constructor()`\n// by itself will have a `this` of a previously constructed chalk object\nif(!this||!(this instanceof Chalk)||this.template){const chalk={};applyOptions(chalk,options);chalk.template=function(){const args=[].slice.call(arguments);return chalkTag.apply(null,[chalk.template].concat(args));};Object.setPrototypeOf(chalk,Chalk.prototype);Object.setPrototypeOf(chalk.template,chalk);chalk.template.constructor=Chalk;return chalk.template;}applyOptions(this,options);}// Use bright blue on Windows as the normal blue color is illegible\nif(isSimpleWindowsTerm){ansiStyles.blue.open='\\u001B[94m';}for(const key of Object.keys(ansiStyles)){ansiStyles[key].closeRe=new RegExp(escapeStringRegexp(ansiStyles[key].close),'g');styles[key]={get(){const codes=ansiStyles[key];return build.call(this,this._styles?this._styles.concat(codes):[codes],this._empty,key);}};}styles.visible={get(){return build.call(this,this._styles||[],true,'visible');}};ansiStyles.color.closeRe=new RegExp(escapeStringRegexp(ansiStyles.color.close),'g');for(const model of Object.keys(ansiStyles.color.ansi)){if(skipModels.has(model)){continue;}styles[model]={get(){const level=this.level;return function(){const open=ansiStyles.color[levelMapping[level]][model].apply(null,arguments);const codes={open,close:ansiStyles.color.close,closeRe:ansiStyles.color.closeRe};return build.call(this,this._styles?this._styles.concat(codes):[codes],this._empty,model);};}};}ansiStyles.bgColor.closeRe=new RegExp(escapeStringRegexp(ansiStyles.bgColor.close),'g');for(const model of Object.keys(ansiStyles.bgColor.ansi)){if(skipModels.has(model)){continue;}const bgModel='bg'+model[0].toUpperCase()+model.slice(1);styles[bgModel]={get(){const level=this.level;return function(){const open=ansiStyles.bgColor[levelMapping[level]][model].apply(null,arguments);const codes={open,close:ansiStyles.bgColor.close,closeRe:ansiStyles.bgColor.closeRe};return build.call(this,this._styles?this._styles.concat(codes):[codes],this._empty,model);};}};}const proto=Object.defineProperties(()=>{},styles);function build(_styles,_empty,key){const builder=function builder(){return applyStyle.apply(builder,arguments);};builder._styles=_styles;builder._empty=_empty;const self=this;Object.defineProperty(builder,'level',{enumerable:true,get(){return self.level;},set(level){self.level=level;}});Object.defineProperty(builder,'enabled',{enumerable:true,get(){return self.enabled;},set(enabled){self.enabled=enabled;}});// See below for fix regarding invisible grey/dim combination on Windows\nbuilder.hasGrey=this.hasGrey||key==='gray'||key==='grey';// `__proto__` is used because we must return a function, but there is\n// no way to create a function with a different prototype\nbuilder.__proto__=proto;// eslint-disable-line no-proto\nreturn builder;}function applyStyle(){// Support varags, but simply cast to string in case there's only one arg\nconst args=arguments;const argsLen=args.length;let str=String(arguments[0]);if(argsLen===0){return'';}if(argsLen>1){// Don't slice `arguments`, it prevents V8 optimizations\nfor(let a=1;a<argsLen;a++){str+=' '+args[a];}}if(!this.enabled||this.level<=0||!str){return this._empty?'':str;}// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n// see https://github.com/chalk/chalk/issues/58\n// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\nconst originalDim=ansiStyles.dim.open;if(isSimpleWindowsTerm&&this.hasGrey){ansiStyles.dim.open='';}for(const code of this._styles.slice().reverse()){// Replace any instances already present with a re-opening code\n// otherwise only the part of the string until said closing code\n// will be colored, and the rest will simply be 'plain'.\nstr=code.open+str.replace(code.closeRe,code.open)+code.close;// Close the styling before a linebreak and reopen\n// after next line to fix a bleed issue on macOS\n// https://github.com/chalk/chalk/pull/92\nstr=str.replace(/\\r?\\n/g,\"\".concat(code.close,\"$&\").concat(code.open));}// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue\nansiStyles.dim.open=originalDim;return str;}function chalkTag(chalk,strings){if(!Array.isArray(strings)){// If chalk() was called by itself or with a string,\n// return the string itself as a string.\nreturn[].slice.call(arguments,1).join(' ');}const args=[].slice.call(arguments,2);const parts=[strings.raw[0]];for(let i=1;i<strings.length;i++){parts.push(String(args[i-1]).replace(/[{}\\\\]/g,'\\\\$&'));parts.push(String(strings.raw[i]));}return templates(chalk,parts.join(''));}Object.defineProperties(Chalk.prototype,styles);module.exports=Chalk();// eslint-disable-line new-cap\nmodule.exports.supportsColor=stdoutColor;module.exports.default=module.exports;// For TypeScript\n});var chalk_1=chalk.supportsColor;var common=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});exports.commonDeprecatedHandler=(keyOrPair,redirectTo,_ref4)=>{let{descriptor}=_ref4;const messages=[\"\".concat(chalk.default.yellow(typeof keyOrPair==='string'?descriptor.key(keyOrPair):descriptor.pair(keyOrPair)),\" is deprecated\")];if(redirectTo){messages.push(\"we now treat it as \".concat(chalk.default.blue(typeof redirectTo==='string'?descriptor.key(redirectTo):descriptor.pair(redirectTo))));}return messages.join('; ')+'.';};});unwrapExports(common);var common_1=common.commonDeprecatedHandler;var deprecated=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});tslib_1.__exportStar(common,exports);});unwrapExports(deprecated);var common$1=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});exports.commonInvalidHandler=(key,value,utils)=>[\"Invalid \".concat(chalk.default.red(utils.descriptor.key(key)),\" value.\"),\"Expected \".concat(chalk.default.blue(utils.schemas[key].expected(utils)),\",\"),\"but received \".concat(chalk.default.red(utils.descriptor.value(value)),\".\")].join(' ');});unwrapExports(common$1);var common_1$1=common$1.commonInvalidHandler;var invalid=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});tslib_1.__exportStar(common$1,exports);});unwrapExports(invalid);/* eslint-disable no-nested-ternary */var arr=[];var charCodeCache=[];var leven=function leven(a,b){if(a===b){return 0;}var swap=a;// Swapping the strings if `a` is longer than `b` so we know which one is the\n// shortest & which one is the longest\nif(a.length>b.length){a=b;b=swap;}var aLen=a.length;var bLen=b.length;if(aLen===0){return bLen;}if(bLen===0){return aLen;}// Performing suffix trimming:\n// We can linearly drop suffix common to both strings since they\n// don't increase distance at all\n// Note: `~-` is the bitwise way to perform a `- 1` operation\nwhile(aLen>0&&a.charCodeAt(~-aLen)===b.charCodeAt(~-bLen)){aLen--;bLen--;}if(aLen===0){return bLen;}// Performing prefix trimming\n// We can linearly drop prefix common to both strings since they\n// don't increase distance at all\nvar start=0;while(start<aLen&&a.charCodeAt(start)===b.charCodeAt(start)){start++;}aLen-=start;bLen-=start;if(aLen===0){return bLen;}var bCharCode;var ret;var tmp;var tmp2;var i=0;var j=0;while(i<aLen){charCodeCache[start+i]=a.charCodeAt(start+i);arr[i]=++i;}while(j<bLen){bCharCode=b.charCodeAt(start+j);tmp=j++;ret=j;for(i=0;i<aLen;i++){tmp2=bCharCode===charCodeCache[start+i]?tmp:tmp+1;tmp=arr[i];ret=arr[i]=tmp>ret?tmp2>ret?ret+1:tmp2:tmp2>tmp?tmp+1:tmp2;}}return ret;};var leven_1=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});exports.levenUnknownHandler=(key,value,_ref5)=>{let{descriptor,logger,schemas}=_ref5;const messages=[\"Ignored unknown option \".concat(chalk.default.yellow(descriptor.pair({key,value})),\".\")];const suggestion=Object.keys(schemas).sort().find(knownKey=>leven(key,knownKey)<3);if(suggestion){messages.push(\"Did you mean \".concat(chalk.default.blue(descriptor.key(suggestion)),\"?\"));}logger.warn(messages.join(' '));};});unwrapExports(leven_1);var leven_2=leven_1.levenUnknownHandler;var unknown=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});tslib_1.__exportStar(leven_1,exports);});unwrapExports(unknown);var handlers=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});tslib_1.__exportStar(deprecated,exports);tslib_1.__exportStar(invalid,exports);tslib_1.__exportStar(unknown,exports);});unwrapExports(handlers);var schema=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});const HANDLER_KEYS=['default','expected','validate','deprecated','forward','redirect','overlap','preprocess','postprocess'];function createSchema(SchemaConstructor,parameters){const schema=new SchemaConstructor(parameters);const subSchema=Object.create(schema);for(const handlerKey of HANDLER_KEYS){if(handlerKey in parameters){subSchema[handlerKey]=normalizeHandler(parameters[handlerKey],schema,Schema.prototype[handlerKey].length);}}return subSchema;}exports.createSchema=createSchema;class Schema{constructor(parameters){this.name=parameters.name;}static create(parameters){// @ts-ignore: https://github.com/Microsoft/TypeScript/issues/5863\nreturn createSchema(this,parameters);}default(_utils){return undefined;}// istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`\nexpected(_utils){return'nothing';}// istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`\nvalidate(_value,_utils){return false;}deprecated(_value,_utils){return false;}forward(_value,_utils){return undefined;}redirect(_value,_utils){return undefined;}overlap(currentValue,_newValue,_utils){return currentValue;}preprocess(value,_utils){return value;}postprocess(value,_utils){return value;}}exports.Schema=Schema;function normalizeHandler(handler,superSchema,handlerArgumentsLength){return typeof handler==='function'?function(){for(var _len2=arguments.length,args=new Array(_len2),_key3=0;_key3<_len2;_key3++){args[_key3]=arguments[_key3];}return handler(...args.slice(0,handlerArgumentsLength-1),superSchema,...args.slice(handlerArgumentsLength-1));}:()=>handler;}});unwrapExports(schema);var schema_1=schema.createSchema;var schema_2=schema.Schema;var alias=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});class AliasSchema extends schema.Schema{constructor(parameters){super(parameters);this._sourceName=parameters.sourceName;}expected(utils){return utils.schemas[this._sourceName].expected(utils);}validate(value,utils){return utils.schemas[this._sourceName].validate(value,utils);}redirect(_value,_utils){return this._sourceName;}}exports.AliasSchema=AliasSchema;});unwrapExports(alias);var alias_1=alias.AliasSchema;var any=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});class AnySchema extends schema.Schema{expected(){return'anything';}validate(){return true;}}exports.AnySchema=AnySchema;});unwrapExports(any);var any_1=any.AnySchema;var array=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});class ArraySchema extends schema.Schema{constructor(_a){var{valueSchema,name=valueSchema.name}=_a,handlers=tslib_1.__rest(_a,[\"valueSchema\",\"name\"]);super(Object.assign({},handlers,{name}));this._valueSchema=valueSchema;}expected(utils){return\"an array of \".concat(this._valueSchema.expected(utils));}validate(value,utils){if(!Array.isArray(value)){return false;}const invalidValues=[];for(const subValue of value){const subValidateResult=utils.normalizeValidateResult(this._valueSchema.validate(subValue,utils),subValue);if(subValidateResult!==true){invalidValues.push(subValidateResult.value);}}return invalidValues.length===0?true:{value:invalidValues};}deprecated(value,utils){const deprecatedResult=[];for(const subValue of value){const subDeprecatedResult=utils.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue,utils),subValue);if(subDeprecatedResult!==false){deprecatedResult.push(...subDeprecatedResult.map(_ref6=>{let{value:deprecatedValue}=_ref6;return{value:[deprecatedValue]};}));}}return deprecatedResult;}forward(value,utils){const forwardResult=[];for(const subValue of value){const subForwardResult=utils.normalizeForwardResult(this._valueSchema.forward(subValue,utils),subValue);forwardResult.push(...subForwardResult.map(wrapTransferResult));}return forwardResult;}redirect(value,utils){const remain=[];const redirect=[];for(const subValue of value){const subRedirectResult=utils.normalizeRedirectResult(this._valueSchema.redirect(subValue,utils),subValue);if('remain'in subRedirectResult){remain.push(subRedirectResult.remain);}redirect.push(...subRedirectResult.redirect.map(wrapTransferResult));}return remain.length===0?{redirect}:{redirect,remain};}overlap(currentValue,newValue){return currentValue.concat(newValue);}}exports.ArraySchema=ArraySchema;function wrapTransferResult(_ref7){let{from,to}=_ref7;return{from:[from],to};}});unwrapExports(array);var array_1=array.ArraySchema;var boolean_1=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});class BooleanSchema extends schema.Schema{expected(){return'true or false';}validate(value){return typeof value==='boolean';}}exports.BooleanSchema=BooleanSchema;});unwrapExports(boolean_1);var boolean_2=boolean_1.BooleanSchema;var utils=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});function recordFromArray(array,mainKey){const record=Object.create(null);for(const value of array){const key=value[mainKey];// istanbul ignore next\nif(record[key]){throw new Error(\"Duplicate \".concat(mainKey,\" \").concat(JSON.stringify(key)));}// @ts-ignore\nrecord[key]=value;}return record;}exports.recordFromArray=recordFromArray;function mapFromArray(array,mainKey){const map=new Map();for(const value of array){const key=value[mainKey];// istanbul ignore next\nif(map.has(key)){throw new Error(\"Duplicate \".concat(mainKey,\" \").concat(JSON.stringify(key)));}map.set(key,value);}return map;}exports.mapFromArray=mapFromArray;function createAutoChecklist(){const map=Object.create(null);return id=>{const idString=JSON.stringify(id);if(map[idString]){return true;}map[idString]=true;return false;};}exports.createAutoChecklist=createAutoChecklist;function partition(array,predicate){const trueArray=[];const falseArray=[];for(const value of array){if(predicate(value)){trueArray.push(value);}else{falseArray.push(value);}}return[trueArray,falseArray];}exports.partition=partition;function isInt(value){return value===Math.floor(value);}exports.isInt=isInt;function comparePrimitive(a,b){if(a===b){return 0;}const typeofA=typeof a;const typeofB=typeof b;const orders=['undefined','object','boolean','number','string'];if(typeofA!==typeofB){return orders.indexOf(typeofA)-orders.indexOf(typeofB);}if(typeofA!=='string'){return Number(a)-Number(b);}return a.localeCompare(b);}exports.comparePrimitive=comparePrimitive;function normalizeDefaultResult(result){return result===undefined?{}:result;}exports.normalizeDefaultResult=normalizeDefaultResult;function normalizeValidateResult(result,value){return result===true?true:result===false?{value}:result;}exports.normalizeValidateResult=normalizeValidateResult;function normalizeDeprecatedResult(result,value){let doNotNormalizeTrue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;return result===false?false:result===true?doNotNormalizeTrue?true:[{value}]:'value'in result?[result]:result.length===0?false:result;}exports.normalizeDeprecatedResult=normalizeDeprecatedResult;function normalizeTransferResult(result,value){return typeof result==='string'||'key'in result?{from:value,to:result}:'from'in result?{from:result.from,to:result.to}:{from:value,to:result.to};}exports.normalizeTransferResult=normalizeTransferResult;function normalizeForwardResult(result,value){return result===undefined?[]:Array.isArray(result)?result.map(transferResult=>normalizeTransferResult(transferResult,value)):[normalizeTransferResult(result,value)];}exports.normalizeForwardResult=normalizeForwardResult;function normalizeRedirectResult(result,value){const redirect=normalizeForwardResult(typeof result==='object'&&'redirect'in result?result.redirect:result,value);return redirect.length===0?{remain:value,redirect}:typeof result==='object'&&'remain'in result?{remain:result.remain,redirect}:{redirect};}exports.normalizeRedirectResult=normalizeRedirectResult;});unwrapExports(utils);var utils_1=utils.recordFromArray;var utils_2=utils.mapFromArray;var utils_3=utils.createAutoChecklist;var utils_4=utils.partition;var utils_5=utils.isInt;var utils_6=utils.comparePrimitive;var utils_7=utils.normalizeDefaultResult;var utils_8=utils.normalizeValidateResult;var utils_9=utils.normalizeDeprecatedResult;var utils_10=utils.normalizeTransferResult;var utils_11=utils.normalizeForwardResult;var utils_12=utils.normalizeRedirectResult;var choice=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});class ChoiceSchema extends schema.Schema{constructor(parameters){super(parameters);this._choices=utils.mapFromArray(parameters.choices.map(choice=>choice&&typeof choice==='object'?choice:{value:choice}),'value');}expected(_ref8){let{descriptor}=_ref8;const choiceValues=Array.from(this._choices.keys()).map(value=>this._choices.get(value)).filter(choiceInfo=>!choiceInfo.deprecated).map(choiceInfo=>choiceInfo.value).sort(utils.comparePrimitive).map(descriptor.value);const head=choiceValues.slice(0,-2);const tail=choiceValues.slice(-2);return head.concat(tail.join(' or ')).join(', ');}validate(value){return this._choices.has(value);}deprecated(value){const choiceInfo=this._choices.get(value);return choiceInfo&&choiceInfo.deprecated?{value}:false;}forward(value){const choiceInfo=this._choices.get(value);return choiceInfo?choiceInfo.forward:undefined;}redirect(value){const choiceInfo=this._choices.get(value);return choiceInfo?choiceInfo.redirect:undefined;}}exports.ChoiceSchema=ChoiceSchema;});unwrapExports(choice);var choice_1=choice.ChoiceSchema;var number=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});class NumberSchema extends schema.Schema{expected(){return'a number';}validate(value,_utils){return typeof value==='number';}}exports.NumberSchema=NumberSchema;});unwrapExports(number);var number_1=number.NumberSchema;var integer=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});class IntegerSchema extends number.NumberSchema{expected(){return'an integer';}validate(value,utils$1){return utils$1.normalizeValidateResult(super.validate(value,utils$1),value)===true&&utils.isInt(value);}}exports.IntegerSchema=IntegerSchema;});unwrapExports(integer);var integer_1=integer.IntegerSchema;var string=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});class StringSchema extends schema.Schema{expected(){return'a string';}validate(value){return typeof value==='string';}}exports.StringSchema=StringSchema;});unwrapExports(string);var string_1=string.StringSchema;var schemas=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});tslib_1.__exportStar(alias,exports);tslib_1.__exportStar(any,exports);tslib_1.__exportStar(array,exports);tslib_1.__exportStar(boolean_1,exports);tslib_1.__exportStar(choice,exports);tslib_1.__exportStar(integer,exports);tslib_1.__exportStar(number,exports);tslib_1.__exportStar(string,exports);});unwrapExports(schemas);var defaults=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});exports.defaultDescriptor=api.apiDescriptor;exports.defaultUnknownHandler=leven_1.levenUnknownHandler;exports.defaultInvalidHandler=invalid.commonInvalidHandler;exports.defaultDeprecatedHandler=common.commonDeprecatedHandler;});unwrapExports(defaults);var defaults_1=defaults.defaultDescriptor;var defaults_2=defaults.defaultUnknownHandler;var defaults_3=defaults.defaultInvalidHandler;var defaults_4=defaults.defaultDeprecatedHandler;var normalize=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});exports.normalize=(options,schemas,opts)=>new Normalizer(schemas,opts).normalize(options);class Normalizer{constructor(schemas,opts){// istanbul ignore next\nconst{logger=console,descriptor=defaults.defaultDescriptor,unknown=defaults.defaultUnknownHandler,invalid=defaults.defaultInvalidHandler,deprecated=defaults.defaultDeprecatedHandler}=opts||{};this._utils={descriptor,logger:/* istanbul ignore next */logger||{warn:()=>{}},schemas:utils.recordFromArray(schemas,'name'),normalizeDefaultResult:utils.normalizeDefaultResult,normalizeDeprecatedResult:utils.normalizeDeprecatedResult,normalizeForwardResult:utils.normalizeForwardResult,normalizeRedirectResult:utils.normalizeRedirectResult,normalizeValidateResult:utils.normalizeValidateResult};this._unknownHandler=unknown;this._invalidHandler=invalid;this._deprecatedHandler=deprecated;this.cleanHistory();}cleanHistory(){this._hasDeprecationWarned=utils.createAutoChecklist();}normalize(options){const normalized={};const restOptionsArray=[options];const applyNormalization=()=>{while(restOptionsArray.length!==0){const currentOptions=restOptionsArray.shift();const transferredOptionsArray=this._applyNormalization(currentOptions,normalized);restOptionsArray.push(...transferredOptionsArray);}};applyNormalization();for(const key of Object.keys(this._utils.schemas)){const schema=this._utils.schemas[key];if(!(key in normalized)){const defaultResult=utils.normalizeDefaultResult(schema.default(this._utils));if('value'in defaultResult){restOptionsArray.push({[key]:defaultResult.value});}}}applyNormalization();for(const key of Object.keys(this._utils.schemas)){const schema=this._utils.schemas[key];if(key in normalized){normalized[key]=schema.postprocess(normalized[key],this._utils);}}return normalized;}_applyNormalization(options,normalized){const transferredOptionsArray=[];const[knownOptionNames,unknownOptionNames]=utils.partition(Object.keys(options),key=>key in this._utils.schemas);for(const key of knownOptionNames){const schema=this._utils.schemas[key];const value=schema.preprocess(options[key],this._utils);const validateResult=utils.normalizeValidateResult(schema.validate(value,this._utils),value);if(validateResult!==true){const{value:invalidValue}=validateResult;const errorMessageOrError=this._invalidHandler(key,invalidValue,this._utils);throw typeof errorMessageOrError==='string'?new Error(errorMessageOrError):/* istanbul ignore next*/errorMessageOrError;}const appendTransferredOptions=_ref9=>{let{from,to}=_ref9;transferredOptionsArray.push(typeof to==='string'?{[to]:from}:{[to.key]:to.value});};const warnDeprecated=_ref10=>{let{value:currentValue,redirectTo}=_ref10;const deprecatedResult=utils.normalizeDeprecatedResult(schema.deprecated(currentValue,this._utils),value,/* doNotNormalizeTrue */true);if(deprecatedResult===false){return;}if(deprecatedResult===true){if(!this._hasDeprecationWarned(key)){this._utils.logger.warn(this._deprecatedHandler(key,redirectTo,this._utils));}}else{for(const{value:deprecatedValue}of deprecatedResult){const pair={key,value:deprecatedValue};if(!this._hasDeprecationWarned(pair)){const redirectToPair=typeof redirectTo==='string'?{key:redirectTo,value:deprecatedValue}:redirectTo;this._utils.logger.warn(this._deprecatedHandler(pair,redirectToPair,this._utils));}}}};const forwardResult=utils.normalizeForwardResult(schema.forward(value,this._utils),value);forwardResult.forEach(appendTransferredOptions);const redirectResult=utils.normalizeRedirectResult(schema.redirect(value,this._utils),value);redirectResult.redirect.forEach(appendTransferredOptions);if('remain'in redirectResult){const remainingValue=redirectResult.remain;normalized[key]=key in normalized?schema.overlap(normalized[key],remainingValue,this._utils):remainingValue;warnDeprecated({value:remainingValue});}for(const{from,to}of redirectResult.redirect){warnDeprecated({value:from,redirectTo:to});}}for(const key of unknownOptionNames){const value=options[key];const unknownResult=this._unknownHandler(key,value,this._utils);if(unknownResult){for(const unknownKey of Object.keys(unknownResult)){const unknownOption={[unknownKey]:unknownResult[unknownKey]};if(unknownKey in this._utils.schemas){transferredOptionsArray.push(unknownOption);}else{Object.assign(normalized,unknownOption);}}}}return transferredOptionsArray;}}exports.Normalizer=Normalizer;});unwrapExports(normalize);var normalize_1=normalize.normalize;var normalize_2=normalize.Normalizer;var lib=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});tslib_1.__exportStar(descriptors,exports);tslib_1.__exportStar(handlers,exports);tslib_1.__exportStar(schemas,exports);tslib_1.__exportStar(normalize,exports);tslib_1.__exportStar(schema,exports);});unwrapExports(lib);const array$1=[];const charCodeCache$1=[];const leven$1=(left,right)=>{if(left===right){return 0;}const swap=left;// Swapping the strings if `a` is longer than `b` so we know which one is the\n// shortest & which one is the longest\nif(left.length>right.length){left=right;right=swap;}let leftLength=left.length;let rightLength=right.length;// Performing suffix trimming:\n// We can linearly drop suffix common to both strings since they\n// don't increase distance at all\n// Note: `~-` is the bitwise way to perform a `- 1` operation\nwhile(leftLength>0&&left.charCodeAt(~-leftLength)===right.charCodeAt(~-rightLength)){leftLength--;rightLength--;}// Performing prefix trimming\n// We can linearly drop prefix common to both strings since they\n// don't increase distance at all\nlet start=0;while(start<leftLength&&left.charCodeAt(start)===right.charCodeAt(start)){start++;}leftLength-=start;rightLength-=start;if(leftLength===0){return rightLength;}let bCharCode;let result;let temp;let temp2;let i=0;let j=0;while(i<leftLength){charCodeCache$1[i]=left.charCodeAt(start+i);array$1[i]=++i;}while(j<rightLength){bCharCode=right.charCodeAt(start+j);temp=j++;result=j;for(i=0;i<leftLength;i++){temp2=bCharCode===charCodeCache$1[i]?temp:temp+1;temp=array$1[i];// eslint-disable-next-line no-multi-assign\nresult=array$1[i]=temp>result?temp2>result?result+1:temp2:temp2>temp?temp+1:temp2;}}return result;};var leven_1$1=leven$1;// TODO: Remove this for the next major release\nvar default_1=leven$1;leven_1$1.default=default_1;var colorName$1={\"aliceblue\":[240,248,255],\"antiquewhite\":[250,235,215],\"aqua\":[0,255,255],\"aquamarine\":[127,255,212],\"azure\":[240,255,255],\"beige\":[245,245,220],\"bisque\":[255,228,196],\"black\":[0,0,0],\"blanchedalmond\":[255,235,205],\"blue\":[0,0,255],\"blueviolet\":[138,43,226],\"brown\":[165,42,42],\"burlywood\":[222,184,135],\"cadetblue\":[95,158,160],\"chartreuse\":[127,255,0],\"chocolate\":[210,105,30],\"coral\":[255,127,80],\"cornflowerblue\":[100,149,237],\"cornsilk\":[255,248,220],\"crimson\":[220,20,60],\"cyan\":[0,255,255],\"darkblue\":[0,0,139],\"darkcyan\":[0,139,139],\"darkgoldenrod\":[184,134,11],\"darkgray\":[169,169,169],\"darkgreen\":[0,100,0],\"darkgrey\":[169,169,169],\"darkkhaki\":[189,183,107],\"darkmagenta\":[139,0,139],\"darkolivegreen\":[85,107,47],\"darkorange\":[255,140,0],\"darkorchid\":[153,50,204],\"darkred\":[139,0,0],\"darksalmon\":[233,150,122],\"darkseagreen\":[143,188,143],\"darkslateblue\":[72,61,139],\"darkslategray\":[47,79,79],\"darkslategrey\":[47,79,79],\"darkturquoise\":[0,206,209],\"darkviolet\":[148,0,211],\"deeppink\":[255,20,147],\"deepskyblue\":[0,191,255],\"dimgray\":[105,105,105],\"dimgrey\":[105,105,105],\"dodgerblue\":[30,144,255],\"firebrick\":[178,34,34],\"floralwhite\":[255,250,240],\"forestgreen\":[34,139,34],\"fuchsia\":[255,0,255],\"gainsboro\":[220,220,220],\"ghostwhite\":[248,248,255],\"gold\":[255,215,0],\"goldenrod\":[218,165,32],\"gray\":[128,128,128],\"green\":[0,128,0],\"greenyellow\":[173,255,47],\"grey\":[128,128,128],\"honeydew\":[240,255,240],\"hotpink\":[255,105,180],\"indianred\":[205,92,92],\"indigo\":[75,0,130],\"ivory\":[255,255,240],\"khaki\":[240,230,140],\"lavender\":[230,230,250],\"lavenderblush\":[255,240,245],\"lawngreen\":[124,252,0],\"lemonchiffon\":[255,250,205],\"lightblue\":[173,216,230],\"lightcoral\":[240,128,128],\"lightcyan\":[224,255,255],\"lightgoldenrodyellow\":[250,250,210],\"lightgray\":[211,211,211],\"lightgreen\":[144,238,144],\"lightgrey\":[211,211,211],\"lightpink\":[255,182,193],\"lightsalmon\":[255,160,122],\"lightseagreen\":[32,178,170],\"lightskyblue\":[135,206,250],\"lightslategray\":[119,136,153],\"lightslategrey\":[119,136,153],\"lightsteelblue\":[176,196,222],\"lightyellow\":[255,255,224],\"lime\":[0,255,0],\"limegreen\":[50,205,50],\"linen\":[250,240,230],\"magenta\":[255,0,255],\"maroon\":[128,0,0],\"mediumaquamarine\":[102,205,170],\"mediumblue\":[0,0,205],\"mediumorchid\":[186,85,211],\"mediumpurple\":[147,112,219],\"mediumseagreen\":[60,179,113],\"mediumslateblue\":[123,104,238],\"mediumspringgreen\":[0,250,154],\"mediumturquoise\":[72,209,204],\"mediumvioletred\":[199,21,133],\"midnightblue\":[25,25,112],\"mintcream\":[245,255,250],\"mistyrose\":[255,228,225],\"moccasin\":[255,228,181],\"navajowhite\":[255,222,173],\"navy\":[0,0,128],\"oldlace\":[253,245,230],\"olive\":[128,128,0],\"olivedrab\":[107,142,35],\"orange\":[255,165,0],\"orangered\":[255,69,0],\"orchid\":[218,112,214],\"palegoldenrod\":[238,232,170],\"palegreen\":[152,251,152],\"paleturquoise\":[175,238,238],\"palevioletred\":[219,112,147],\"papayawhip\":[255,239,213],\"peachpuff\":[255,218,185],\"peru\":[205,133,63],\"pink\":[255,192,203],\"plum\":[221,160,221],\"powderblue\":[176,224,230],\"purple\":[128,0,128],\"rebeccapurple\":[102,51,153],\"red\":[255,0,0],\"rosybrown\":[188,143,143],\"royalblue\":[65,105,225],\"saddlebrown\":[139,69,19],\"salmon\":[250,128,114],\"sandybrown\":[244,164,96],\"seagreen\":[46,139,87],\"seashell\":[255,245,238],\"sienna\":[160,82,45],\"silver\":[192,192,192],\"skyblue\":[135,206,235],\"slateblue\":[106,90,205],\"slategray\":[112,128,144],\"slategrey\":[112,128,144],\"snow\":[255,250,250],\"springgreen\":[0,255,127],\"steelblue\":[70,130,180],\"tan\":[210,180,140],\"teal\":[0,128,128],\"thistle\":[216,191,216],\"tomato\":[255,99,71],\"turquoise\":[64,224,208],\"violet\":[238,130,238],\"wheat\":[245,222,179],\"white\":[255,255,255],\"whitesmoke\":[245,245,245],\"yellow\":[255,255,0],\"yellowgreen\":[154,205,50]};/* MIT license */ /* eslint-disable no-mixed-operators */ // NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\nconst reverseKeywords={};for(const key of Object.keys(colorName$1)){reverseKeywords[colorName$1[key]]=key;}const convert$1={rgb:{channels:3,labels:'rgb'},hsl:{channels:3,labels:'hsl'},hsv:{channels:3,labels:'hsv'},hwb:{channels:3,labels:'hwb'},cmyk:{channels:4,labels:'cmyk'},xyz:{channels:3,labels:'xyz'},lab:{channels:3,labels:'lab'},lch:{channels:3,labels:'lch'},hex:{channels:1,labels:['hex']},keyword:{channels:1,labels:['keyword']},ansi16:{channels:1,labels:['ansi16']},ansi256:{channels:1,labels:['ansi256']},hcg:{channels:3,labels:['h','c','g']},apple:{channels:3,labels:['r16','g16','b16']},gray:{channels:1,labels:['gray']}};var conversions$1=convert$1;// Hide .channels and .labels properties\nfor(const model of Object.keys(convert$1)){if(!('channels'in convert$1[model])){throw new Error('missing channels property: '+model);}if(!('labels'in convert$1[model])){throw new Error('missing channel labels property: '+model);}if(convert$1[model].labels.length!==convert$1[model].channels){throw new Error('channel and label counts mismatch: '+model);}const{channels,labels}=convert$1[model];delete convert$1[model].channels;delete convert$1[model].labels;Object.defineProperty(convert$1[model],'channels',{value:channels});Object.defineProperty(convert$1[model],'labels',{value:labels});}convert$1.rgb.hsl=function(rgb){const r=rgb[0]/255;const g=rgb[1]/255;const b=rgb[2]/255;const min=Math.min(r,g,b);const max=Math.max(r,g,b);const delta=max-min;let h;let s;if(max===min){h=0;}else if(r===max){h=(g-b)/delta;}else if(g===max){h=2+(b-r)/delta;}else if(b===max){h=4+(r-g)/delta;}h=Math.min(h*60,360);if(h<0){h+=360;}const l=(min+max)/2;if(max===min){s=0;}else if(l<=0.5){s=delta/(max+min);}else{s=delta/(2-max-min);}return[h,s*100,l*100];};convert$1.rgb.hsv=function(rgb){let rdif;let gdif;let bdif;let h;let s;const r=rgb[0]/255;const g=rgb[1]/255;const b=rgb[2]/255;const v=Math.max(r,g,b);const diff=v-Math.min(r,g,b);const diffc=function diffc(c){return(v-c)/6/diff+1/2;};if(diff===0){h=0;s=0;}else{s=diff/v;rdif=diffc(r);gdif=diffc(g);bdif=diffc(b);if(r===v){h=bdif-gdif;}else if(g===v){h=1/3+rdif-bdif;}else if(b===v){h=2/3+gdif-rdif;}if(h<0){h+=1;}else if(h>1){h-=1;}}return[h*360,s*100,v*100];};convert$1.rgb.hwb=function(rgb){const r=rgb[0];const g=rgb[1];let b=rgb[2];const h=convert$1.rgb.hsl(rgb)[0];const w=1/255*Math.min(r,Math.min(g,b));b=1-1/255*Math.max(r,Math.max(g,b));return[h,w*100,b*100];};convert$1.rgb.cmyk=function(rgb){const r=rgb[0]/255;const g=rgb[1]/255;const b=rgb[2]/255;const k=Math.min(1-r,1-g,1-b);const c=(1-r-k)/(1-k)||0;const m=(1-g-k)/(1-k)||0;const y=(1-b-k)/(1-k)||0;return[c*100,m*100,y*100,k*100];};function comparativeDistance(x,y){/*\n    \tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n    */return(x[0]-y[0])**2+(x[1]-y[1])**2+(x[2]-y[2])**2;}convert$1.rgb.keyword=function(rgb){const reversed=reverseKeywords[rgb];if(reversed){return reversed;}let currentClosestDistance=Infinity;let currentClosestKeyword;for(const keyword of Object.keys(colorName$1)){const value=colorName$1[keyword];// Compute comparative distance\nconst distance=comparativeDistance(rgb,value);// Check if its less, if so set as closest\nif(distance<currentClosestDistance){currentClosestDistance=distance;currentClosestKeyword=keyword;}}return currentClosestKeyword;};convert$1.keyword.rgb=function(keyword){return colorName$1[keyword];};convert$1.rgb.xyz=function(rgb){let r=rgb[0]/255;let g=rgb[1]/255;let b=rgb[2]/255;// Assume sRGB\nr=r>0.04045?((r+0.055)/1.055)**2.4:r/12.92;g=g>0.04045?((g+0.055)/1.055)**2.4:g/12.92;b=b>0.04045?((b+0.055)/1.055)**2.4:b/12.92;const x=r*0.4124+g*0.3576+b*0.1805;const y=r*0.2126+g*0.7152+b*0.0722;const z=r*0.0193+g*0.1192+b*0.9505;return[x*100,y*100,z*100];};convert$1.rgb.lab=function(rgb){const xyz=convert$1.rgb.xyz(rgb);let x=xyz[0];let y=xyz[1];let z=xyz[2];x/=95.047;y/=100;z/=108.883;x=x>0.008856?x**(1/3):7.787*x+16/116;y=y>0.008856?y**(1/3):7.787*y+16/116;z=z>0.008856?z**(1/3):7.787*z+16/116;const l=116*y-16;const a=500*(x-y);const b=200*(y-z);return[l,a,b];};convert$1.hsl.rgb=function(hsl){const h=hsl[0]/360;const s=hsl[1]/100;const l=hsl[2]/100;let t2;let t3;let val;if(s===0){val=l*255;return[val,val,val];}if(l<0.5){t2=l*(1+s);}else{t2=l+s-l*s;}const t1=2*l-t2;const rgb=[0,0,0];for(let i=0;i<3;i++){t3=h+1/3*-(i-1);if(t3<0){t3++;}if(t3>1){t3--;}if(6*t3<1){val=t1+(t2-t1)*6*t3;}else if(2*t3<1){val=t2;}else if(3*t3<2){val=t1+(t2-t1)*(2/3-t3)*6;}else{val=t1;}rgb[i]=val*255;}return rgb;};convert$1.hsl.hsv=function(hsl){const h=hsl[0];let s=hsl[1]/100;let l=hsl[2]/100;let smin=s;const lmin=Math.max(l,0.01);l*=2;s*=l<=1?l:2-l;smin*=lmin<=1?lmin:2-lmin;const v=(l+s)/2;const sv=l===0?2*smin/(lmin+smin):2*s/(l+s);return[h,sv*100,v*100];};convert$1.hsv.rgb=function(hsv){const h=hsv[0]/60;const s=hsv[1]/100;let v=hsv[2]/100;const hi=Math.floor(h)%6;const f=h-Math.floor(h);const p=255*v*(1-s);const q=255*v*(1-s*f);const t=255*v*(1-s*(1-f));v*=255;switch(hi){case 0:return[v,t,p];case 1:return[q,v,p];case 2:return[p,v,t];case 3:return[p,q,v];case 4:return[t,p,v];case 5:return[v,p,q];}};convert$1.hsv.hsl=function(hsv){const h=hsv[0];const s=hsv[1]/100;const v=hsv[2]/100;const vmin=Math.max(v,0.01);let sl;let l;l=(2-s)*v;const lmin=(2-s)*vmin;sl=s*vmin;sl/=lmin<=1?lmin:2-lmin;sl=sl||0;l/=2;return[h,sl*100,l*100];};// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert$1.hwb.rgb=function(hwb){const h=hwb[0]/360;let wh=hwb[1]/100;let bl=hwb[2]/100;const ratio=wh+bl;let f;// Wh + bl cant be > 1\nif(ratio>1){wh/=ratio;bl/=ratio;}const i=Math.floor(6*h);const v=1-bl;f=6*h-i;if((i&0x01)!==0){f=1-f;}const n=wh+f*(v-wh);// Linear interpolation\nlet r;let g;let b;/* eslint-disable max-statements-per-line,no-multi-spaces */switch(i){default:case 6:case 0:r=v;g=n;b=wh;break;case 1:r=n;g=v;b=wh;break;case 2:r=wh;g=v;b=n;break;case 3:r=wh;g=n;b=v;break;case 4:r=n;g=wh;b=v;break;case 5:r=v;g=wh;b=n;break;}/* eslint-enable max-statements-per-line,no-multi-spaces */return[r*255,g*255,b*255];};convert$1.cmyk.rgb=function(cmyk){const c=cmyk[0]/100;const m=cmyk[1]/100;const y=cmyk[2]/100;const k=cmyk[3]/100;const r=1-Math.min(1,c*(1-k)+k);const g=1-Math.min(1,m*(1-k)+k);const b=1-Math.min(1,y*(1-k)+k);return[r*255,g*255,b*255];};convert$1.xyz.rgb=function(xyz){const x=xyz[0]/100;const y=xyz[1]/100;const z=xyz[2]/100;let r;let g;let b;r=x*3.2406+y*-1.5372+z*-0.4986;g=x*-0.9689+y*1.8758+z*0.0415;b=x*0.0557+y*-0.2040+z*1.0570;// Assume sRGB\nr=r>0.0031308?1.055*r**(1.0/2.4)-0.055:r*12.92;g=g>0.0031308?1.055*g**(1.0/2.4)-0.055:g*12.92;b=b>0.0031308?1.055*b**(1.0/2.4)-0.055:b*12.92;r=Math.min(Math.max(0,r),1);g=Math.min(Math.max(0,g),1);b=Math.min(Math.max(0,b),1);return[r*255,g*255,b*255];};convert$1.xyz.lab=function(xyz){let x=xyz[0];let y=xyz[1];let z=xyz[2];x/=95.047;y/=100;z/=108.883;x=x>0.008856?x**(1/3):7.787*x+16/116;y=y>0.008856?y**(1/3):7.787*y+16/116;z=z>0.008856?z**(1/3):7.787*z+16/116;const l=116*y-16;const a=500*(x-y);const b=200*(y-z);return[l,a,b];};convert$1.lab.xyz=function(lab){const l=lab[0];const a=lab[1];const b=lab[2];let x;let y;let z;y=(l+16)/116;x=a/500+y;z=y-b/200;const y2=y**3;const x2=x**3;const z2=z**3;y=y2>0.008856?y2:(y-16/116)/7.787;x=x2>0.008856?x2:(x-16/116)/7.787;z=z2>0.008856?z2:(z-16/116)/7.787;x*=95.047;y*=100;z*=108.883;return[x,y,z];};convert$1.lab.lch=function(lab){const l=lab[0];const a=lab[1];const b=lab[2];let h;const hr=Math.atan2(b,a);h=hr*360/2/Math.PI;if(h<0){h+=360;}const c=Math.sqrt(a*a+b*b);return[l,c,h];};convert$1.lch.lab=function(lch){const l=lch[0];const c=lch[1];const h=lch[2];const hr=h/360*2*Math.PI;const a=c*Math.cos(hr);const b=c*Math.sin(hr);return[l,a,b];};convert$1.rgb.ansi16=function(args){let saturation=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;const[r,g,b]=args;let value=saturation===null?convert$1.rgb.hsv(args)[2]:saturation;// Hsv -> ansi16 optimization\nvalue=Math.round(value/50);if(value===0){return 30;}let ansi=30+(Math.round(b/255)<<2|Math.round(g/255)<<1|Math.round(r/255));if(value===2){ansi+=60;}return ansi;};convert$1.hsv.ansi16=function(args){// Optimization here; we already know the value and don't need to get\n// it converted for us.\nreturn convert$1.rgb.ansi16(convert$1.hsv.rgb(args),args[2]);};convert$1.rgb.ansi256=function(args){const r=args[0];const g=args[1];const b=args[2];// We use the extended greyscale palette here, with the exception of\n// black and white. normal palette only has 4 greyscale shades.\nif(r===g&&g===b){if(r<8){return 16;}if(r>248){return 231;}return Math.round((r-8)/247*24)+232;}const ansi=16+36*Math.round(r/255*5)+6*Math.round(g/255*5)+Math.round(b/255*5);return ansi;};convert$1.ansi16.rgb=function(args){let color=args%10;// Handle greyscale\nif(color===0||color===7){if(args>50){color+=3.5;}color=color/10.5*255;return[color,color,color];}const mult=(~~(args>50)+1)*0.5;const r=(color&1)*mult*255;const g=(color>>1&1)*mult*255;const b=(color>>2&1)*mult*255;return[r,g,b];};convert$1.ansi256.rgb=function(args){// Handle greyscale\nif(args>=232){const c=(args-232)*10+8;return[c,c,c];}args-=16;let rem;const r=Math.floor(args/36)/5*255;const g=Math.floor((rem=args%36)/6)/5*255;const b=rem%6/5*255;return[r,g,b];};convert$1.rgb.hex=function(args){const integer=((Math.round(args[0])&0xFF)<<16)+((Math.round(args[1])&0xFF)<<8)+(Math.round(args[2])&0xFF);const string=integer.toString(16).toUpperCase();return'000000'.substring(string.length)+string;};convert$1.hex.rgb=function(args){const match=args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!match){return[0,0,0];}let colorString=match[0];if(match[0].length===3){colorString=colorString.split('').map(char=>{return char+char;}).join('');}const integer=parseInt(colorString,16);const r=integer>>16&0xFF;const g=integer>>8&0xFF;const b=integer&0xFF;return[r,g,b];};convert$1.rgb.hcg=function(rgb){const r=rgb[0]/255;const g=rgb[1]/255;const b=rgb[2]/255;const max=Math.max(Math.max(r,g),b);const min=Math.min(Math.min(r,g),b);const chroma=max-min;let grayscale;let hue;if(chroma<1){grayscale=min/(1-chroma);}else{grayscale=0;}if(chroma<=0){hue=0;}else if(max===r){hue=(g-b)/chroma%6;}else if(max===g){hue=2+(b-r)/chroma;}else{hue=4+(r-g)/chroma;}hue/=6;hue%=1;return[hue*360,chroma*100,grayscale*100];};convert$1.hsl.hcg=function(hsl){const s=hsl[1]/100;const l=hsl[2]/100;const c=l<0.5?2.0*s*l:2.0*s*(1.0-l);let f=0;if(c<1.0){f=(l-0.5*c)/(1.0-c);}return[hsl[0],c*100,f*100];};convert$1.hsv.hcg=function(hsv){const s=hsv[1]/100;const v=hsv[2]/100;const c=s*v;let f=0;if(c<1.0){f=(v-c)/(1-c);}return[hsv[0],c*100,f*100];};convert$1.hcg.rgb=function(hcg){const h=hcg[0]/360;const c=hcg[1]/100;const g=hcg[2]/100;if(c===0.0){return[g*255,g*255,g*255];}const pure=[0,0,0];const hi=h%1*6;const v=hi%1;const w=1-v;let mg=0;/* eslint-disable max-statements-per-line */switch(Math.floor(hi)){case 0:pure[0]=1;pure[1]=v;pure[2]=0;break;case 1:pure[0]=w;pure[1]=1;pure[2]=0;break;case 2:pure[0]=0;pure[1]=1;pure[2]=v;break;case 3:pure[0]=0;pure[1]=w;pure[2]=1;break;case 4:pure[0]=v;pure[1]=0;pure[2]=1;break;default:pure[0]=1;pure[1]=0;pure[2]=w;}/* eslint-enable max-statements-per-line */mg=(1.0-c)*g;return[(c*pure[0]+mg)*255,(c*pure[1]+mg)*255,(c*pure[2]+mg)*255];};convert$1.hcg.hsv=function(hcg){const c=hcg[1]/100;const g=hcg[2]/100;const v=c+g*(1.0-c);let f=0;if(v>0.0){f=c/v;}return[hcg[0],f*100,v*100];};convert$1.hcg.hsl=function(hcg){const c=hcg[1]/100;const g=hcg[2]/100;const l=g*(1.0-c)+0.5*c;let s=0;if(l>0.0&&l<0.5){s=c/(2*l);}else if(l>=0.5&&l<1.0){s=c/(2*(1-l));}return[hcg[0],s*100,l*100];};convert$1.hcg.hwb=function(hcg){const c=hcg[1]/100;const g=hcg[2]/100;const v=c+g*(1.0-c);return[hcg[0],(v-c)*100,(1-v)*100];};convert$1.hwb.hcg=function(hwb){const w=hwb[1]/100;const b=hwb[2]/100;const v=1-b;const c=v-w;let g=0;if(c<1){g=(v-c)/(1-c);}return[hwb[0],c*100,g*100];};convert$1.apple.rgb=function(apple){return[apple[0]/65535*255,apple[1]/65535*255,apple[2]/65535*255];};convert$1.rgb.apple=function(rgb){return[rgb[0]/255*65535,rgb[1]/255*65535,rgb[2]/255*65535];};convert$1.gray.rgb=function(args){return[args[0]/100*255,args[0]/100*255,args[0]/100*255];};convert$1.gray.hsl=function(args){return[0,0,args[0]];};convert$1.gray.hsv=convert$1.gray.hsl;convert$1.gray.hwb=function(gray){return[0,100,gray[0]];};convert$1.gray.cmyk=function(gray){return[0,0,0,gray[0]];};convert$1.gray.lab=function(gray){return[gray[0],0,0];};convert$1.gray.hex=function(gray){const val=Math.round(gray[0]/100*255)&0xFF;const integer=(val<<16)+(val<<8)+val;const string=integer.toString(16).toUpperCase();return'000000'.substring(string.length)+string;};convert$1.rgb.gray=function(rgb){const val=(rgb[0]+rgb[1]+rgb[2])/3;return[val/255*100];};/*\n  \tThis function routes a model to all other models.\n\n  \tall functions that are routed have a property `.conversion` attached\n  \tto the returned synthetic function. This property is an array\n  \tof strings, each with the steps in between the 'from' and 'to'\n  \tcolor models (inclusive).\n\n  \tconversions that are not possible simply are not included.\n  */function buildGraph$1(){const graph={};// https://jsperf.com/object-keys-vs-for-in-with-closure/3\nconst models=Object.keys(conversions$1);for(let len=models.length,i=0;i<len;i++){graph[models[i]]={// http://jsperf.com/1-vs-infinity\n// micro-opt, but this is simple.\ndistance:-1,parent:null};}return graph;}// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS$1(fromModel){const graph=buildGraph$1();const queue=[fromModel];// Unshift -> queue -> pop\ngraph[fromModel].distance=0;while(queue.length){const current=queue.pop();const adjacents=Object.keys(conversions$1[current]);for(let len=adjacents.length,i=0;i<len;i++){const adjacent=adjacents[i];const node=graph[adjacent];if(node.distance===-1){node.distance=graph[current].distance+1;node.parent=current;queue.unshift(adjacent);}}}return graph;}function link$1(from,to){return function(args){return to(from(args));};}function wrapConversion$1(toModel,graph){const path=[graph[toModel].parent,toModel];let fn=conversions$1[graph[toModel].parent][toModel];let cur=graph[toModel].parent;while(graph[cur].parent){path.unshift(graph[cur].parent);fn=link$1(conversions$1[graph[cur].parent][cur],fn);cur=graph[cur].parent;}fn.conversion=path;return fn;}var route$1=function route(fromModel){const graph=deriveBFS$1(fromModel);const conversion={};const models=Object.keys(graph);for(let len=models.length,i=0;i<len;i++){const toModel=models[i];const node=graph[toModel];if(node.parent===null){// No possible conversion, or this node is the source model.\ncontinue;}conversion[toModel]=wrapConversion$1(toModel,graph);}return conversion;};const convert$2={};const models$1=Object.keys(conversions$1);function wrapRaw$1(fn){const wrappedFn=function wrappedFn(){for(var _len3=arguments.length,args=new Array(_len3),_key4=0;_key4<_len3;_key4++){args[_key4]=arguments[_key4];}const arg0=args[0];if(arg0===undefined||arg0===null){return arg0;}if(arg0.length>1){args=arg0;}return fn(args);};// Preserve .conversion property if there is one\nif('conversion'in fn){wrappedFn.conversion=fn.conversion;}return wrappedFn;}function wrapRounded$1(fn){const wrappedFn=function wrappedFn(){for(var _len4=arguments.length,args=new Array(_len4),_key5=0;_key5<_len4;_key5++){args[_key5]=arguments[_key5];}const arg0=args[0];if(arg0===undefined||arg0===null){return arg0;}if(arg0.length>1){args=arg0;}const result=fn(args);// We're assuming the result is an array here.\n// see notice in conversions.js; don't use box types\n// in conversion functions.\nif(typeof result==='object'){for(let len=result.length,i=0;i<len;i++){result[i]=Math.round(result[i]);}}return result;};// Preserve .conversion property if there is one\nif('conversion'in fn){wrappedFn.conversion=fn.conversion;}return wrappedFn;}models$1.forEach(fromModel=>{convert$2[fromModel]={};Object.defineProperty(convert$2[fromModel],'channels',{value:conversions$1[fromModel].channels});Object.defineProperty(convert$2[fromModel],'labels',{value:conversions$1[fromModel].labels});const routes=route$1(fromModel);const routeModels=Object.keys(routes);routeModels.forEach(toModel=>{const fn=routes[toModel];convert$2[fromModel][toModel]=wrapRounded$1(fn);convert$2[fromModel][toModel].raw=wrapRaw$1(fn);});});var colorConvert$1=convert$2;var ansiStyles$1=createCommonjsModule(function(module){const wrapAnsi16=(fn,offset)=>function(){const code=fn(...arguments);return\"\\x1B[\".concat(code+offset,\"m\");};const wrapAnsi256=(fn,offset)=>function(){const code=fn(...arguments);return\"\\x1B[\".concat(38+offset,\";5;\").concat(code,\"m\");};const wrapAnsi16m=(fn,offset)=>function(){const rgb=fn(...arguments);return\"\\x1B[\".concat(38+offset,\";2;\").concat(rgb[0],\";\").concat(rgb[1],\";\").concat(rgb[2],\"m\");};const ansi2ansi=n=>n;const rgb2rgb=(r,g,b)=>[r,g,b];const setLazyProperty=(object,property,_get)=>{Object.defineProperty(object,property,{get:()=>{const value=_get();Object.defineProperty(object,property,{value,enumerable:true,configurable:true});return value;},enumerable:true,configurable:true});};/** @type {typeof import('color-convert')} */let colorConvert;const makeDynamicStyles=(wrap,targetSpace,identity,isBackground)=>{if(colorConvert===undefined){colorConvert=colorConvert$1;}const offset=isBackground?10:0;const styles={};for(const[sourceSpace,suite]of Object.entries(colorConvert)){const name=sourceSpace==='ansi16'?'ansi':sourceSpace;if(sourceSpace===targetSpace){styles[name]=wrap(identity,offset);}else if(typeof suite==='object'){styles[name]=wrap(suite[targetSpace],offset);}}return styles;};function assembleStyles(){const codes=new Map();const styles={modifier:{reset:[0,0],// 21 isn't widely supported and 22 does the same thing\nbold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],// Bright color\nblackBright:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],// Bright color\nbgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};// Alias bright black as gray (and grey)\nstyles.color.gray=styles.color.blackBright;styles.bgColor.bgGray=styles.bgColor.bgBlackBright;styles.color.grey=styles.color.blackBright;styles.bgColor.bgGrey=styles.bgColor.bgBlackBright;for(const[groupName,group]of Object.entries(styles)){for(const[styleName,style]of Object.entries(group)){styles[styleName]={open:\"\\x1B[\".concat(style[0],\"m\"),close:\"\\x1B[\".concat(style[1],\"m\")};group[styleName]=styles[styleName];codes.set(style[0],style[1]);}Object.defineProperty(styles,groupName,{value:group,enumerable:false});}Object.defineProperty(styles,'codes',{value:codes,enumerable:false});styles.color.close='\\u001B[39m';styles.bgColor.close='\\u001B[49m';setLazyProperty(styles.color,'ansi',()=>makeDynamicStyles(wrapAnsi16,'ansi16',ansi2ansi,false));setLazyProperty(styles.color,'ansi256',()=>makeDynamicStyles(wrapAnsi256,'ansi256',ansi2ansi,false));setLazyProperty(styles.color,'ansi16m',()=>makeDynamicStyles(wrapAnsi16m,'rgb',rgb2rgb,false));setLazyProperty(styles.bgColor,'ansi',()=>makeDynamicStyles(wrapAnsi16,'ansi16',ansi2ansi,true));setLazyProperty(styles.bgColor,'ansi256',()=>makeDynamicStyles(wrapAnsi256,'ansi256',ansi2ansi,true));setLazyProperty(styles.bgColor,'ansi16m',()=>makeDynamicStyles(wrapAnsi16m,'rgb',rgb2rgb,true));return styles;}// Make the export immutable\nObject.defineProperty(module,'exports',{enumerable:true,get:assembleStyles});});var tty={isatty(){return false;}};var hasFlag$1=function(flag){let argv=arguments.length>1&&arguments[1]!==undefined?arguments[1]:process.argv;const prefix=flag.startsWith('-')?'':flag.length===1?'-':'--';const position=argv.indexOf(prefix+flag);const terminatorPosition=argv.indexOf('--');return position!==-1&&(terminatorPosition===-1||position<terminatorPosition);};const{env:env$2}=process;let forceColor$1;if(hasFlag$1('no-color')||hasFlag$1('no-colors')||hasFlag$1('color=false')||hasFlag$1('color=never')){forceColor$1=0;}else if(hasFlag$1('color')||hasFlag$1('colors')||hasFlag$1('color=true')||hasFlag$1('color=always')){forceColor$1=1;}if('FORCE_COLOR'in env$2){if(env$2.FORCE_COLOR==='true'){forceColor$1=1;}else if(env$2.FORCE_COLOR==='false'){forceColor$1=0;}else{forceColor$1=env$2.FORCE_COLOR.length===0?1:Math.min(parseInt(env$2.FORCE_COLOR,10),3);}}function translateLevel$1(level){if(level===0){return false;}return{level,hasBasic:true,has256:level>=2,has16m:level>=3};}function supportsColor$1(haveStream,streamIsTTY){if(forceColor$1===0){return 0;}if(hasFlag$1('color=16m')||hasFlag$1('color=full')||hasFlag$1('color=truecolor')){return 3;}if(hasFlag$1('color=256')){return 2;}if(haveStream&&!streamIsTTY&&forceColor$1===undefined){return 0;}const min=forceColor$1||0;if(env$2.TERM==='dumb'){return min;}if(process.platform==='win32'){// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\nconst osRelease=require$$0$1.release().split('.');if(Number(osRelease[0])>=10&&Number(osRelease[2])>=10586){return Number(osRelease[2])>=14931?3:2;}return 1;}if('CI'in env$2){if(['TRAVIS','CIRCLECI','APPVEYOR','GITLAB_CI'].some(sign=>sign in env$2)||env$2.CI_NAME==='codeship'){return 1;}return min;}if('TEAMCITY_VERSION'in env$2){return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env$2.TEAMCITY_VERSION)?1:0;}if('GITHUB_ACTIONS'in env$2){return 1;}if(env$2.COLORTERM==='truecolor'){return 3;}if('TERM_PROGRAM'in env$2){const version=parseInt((env$2.TERM_PROGRAM_VERSION||'').split('.')[0],10);switch(env$2.TERM_PROGRAM){case'iTerm.app':return version>=3?3:2;case'Apple_Terminal':return 2;// No default\n}}if(/-256(color)?$/i.test(env$2.TERM)){return 2;}if(/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$2.TERM)){return 1;}if('COLORTERM'in env$2){return 1;}return min;}function getSupportLevel$1(stream){const level=supportsColor$1(stream,stream&&stream.isTTY);return translateLevel$1(level);}var supportsColor_1$1={supportsColor:getSupportLevel$1,stdout:translateLevel$1(supportsColor$1(true,tty.isatty(1))),stderr:translateLevel$1(supportsColor$1(true,tty.isatty(2)))};const stringReplaceAll=(string,substring,replacer)=>{let index=string.indexOf(substring);if(index===-1){return string;}const substringLength=substring.length;let endIndex=0;let returnValue='';do{returnValue+=string.substr(endIndex,index-endIndex)+substring+replacer;endIndex=index+substringLength;index=string.indexOf(substring,endIndex);}while(index!==-1);returnValue+=string.substr(endIndex);return returnValue;};const stringEncaseCRLFWithFirstIndex=(string,prefix,postfix,index)=>{let endIndex=0;let returnValue='';do{const gotCR=string[index-1]==='\\r';returnValue+=string.substr(endIndex,(gotCR?index-1:index)-endIndex)+prefix+(gotCR?'\\r\\n':'\\n')+postfix;endIndex=index+1;index=string.indexOf('\\n',endIndex);}while(index!==-1);returnValue+=string.substr(endIndex);return returnValue;};var util={stringReplaceAll,stringEncaseCRLFWithFirstIndex};const TEMPLATE_REGEX$1=/(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;const STYLE_REGEX$1=/(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;const STRING_REGEX$1=/^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;const ESCAPE_REGEX$1=/\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;const ESCAPES$1=new Map([['n','\\n'],['r','\\r'],['t','\\t'],['b','\\b'],['f','\\f'],['v','\\v'],['0','\\0'],['\\\\','\\\\'],['e','\\u001B'],['a','\\u0007']]);function unescape$1(c){const u=c[0]==='u';const bracket=c[1]==='{';if(u&&!bracket&&c.length===5||c[0]==='x'&&c.length===3){return String.fromCharCode(parseInt(c.slice(1),16));}if(u&&bracket){return String.fromCodePoint(parseInt(c.slice(2,-1),16));}return ESCAPES$1.get(c)||c;}function parseArguments$1(name,arguments_){const results=[];const chunks=arguments_.trim().split(/\\s*,\\s*/g);let matches;for(const chunk of chunks){const number=Number(chunk);if(!Number.isNaN(number)){results.push(number);}else if(matches=chunk.match(STRING_REGEX$1)){results.push(matches[2].replace(ESCAPE_REGEX$1,(m,escape,character)=>escape?unescape$1(escape):character));}else{throw new Error(\"Invalid Chalk template style argument: \".concat(chunk,\" (in style '\").concat(name,\"')\"));}}return results;}function parseStyle$1(style){STYLE_REGEX$1.lastIndex=0;const results=[];let matches;while((matches=STYLE_REGEX$1.exec(style))!==null){const name=matches[1];if(matches[2]){const args=parseArguments$1(name,matches[2]);results.push([name].concat(args));}else{results.push([name]);}}return results;}function buildStyle$1(chalk,styles){const enabled={};for(const layer of styles){for(const style of layer.styles){enabled[style[0]]=layer.inverse?null:style.slice(1);}}let current=chalk;for(const[styleName,styles]of Object.entries(enabled)){if(!Array.isArray(styles)){continue;}if(!(styleName in current)){throw new Error(\"Unknown Chalk style: \".concat(styleName));}current=styles.length>0?current[styleName](...styles):current[styleName];}return current;}var templates$1=(chalk,temporary)=>{const styles=[];const chunks=[];let chunk=[];// eslint-disable-next-line max-params\ntemporary.replace(TEMPLATE_REGEX$1,(m,escapeCharacter,inverse,style,close,character)=>{if(escapeCharacter){chunk.push(unescape$1(escapeCharacter));}else if(style){const string=chunk.join('');chunk=[];chunks.push(styles.length===0?string:buildStyle$1(chalk,styles)(string));styles.push({inverse,styles:parseStyle$1(style)});}else if(close){if(styles.length===0){throw new Error('Found extraneous } in Chalk template literal');}chunks.push(buildStyle$1(chalk,styles)(chunk.join('')));chunk=[];styles.pop();}else{chunk.push(character);}});chunks.push(chunk.join(''));if(styles.length>0){const errMessage=\"Chalk template literal is missing \".concat(styles.length,\" closing bracket\").concat(styles.length===1?'':'s',\" (`}`)\");throw new Error(errMessage);}return chunks.join('');};const{stdout:stdoutColor,stderr:stderrColor}=supportsColor_1$1;const{stringReplaceAll:stringReplaceAll$1,stringEncaseCRLFWithFirstIndex:stringEncaseCRLFWithFirstIndex$1}=util;// `supportsColor.level` → `ansiStyles.color[name]` mapping\nconst levelMapping=['ansi','ansi','ansi256','ansi16m'];const styles=Object.create(null);const applyOptions=function(object){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(options.level&&!(Number.isInteger(options.level)&&options.level>=0&&options.level<=3)){throw new Error('The `level` option should be an integer from 0 to 3');}// Detect level if not set manually\nconst colorLevel=stdoutColor?stdoutColor.level:0;object.level=options.level===undefined?colorLevel:options.level;};class ChalkClass{constructor(options){// eslint-disable-next-line no-constructor-return\nreturn chalkFactory(options);}}const chalkFactory=options=>{const chalk={};applyOptions(chalk,options);chalk.template=function(){for(var _len5=arguments.length,arguments_=new Array(_len5),_key6=0;_key6<_len5;_key6++){arguments_[_key6]=arguments[_key6];}return chalkTag(chalk.template,...arguments_);};Object.setPrototypeOf(chalk,Chalk.prototype);Object.setPrototypeOf(chalk.template,chalk);chalk.template.constructor=()=>{throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');};chalk.template.Instance=ChalkClass;return chalk.template;};function Chalk(options){return chalkFactory(options);}for(const[styleName,style]of Object.entries(ansiStyles$1)){styles[styleName]={get(){const builder=createBuilder(this,createStyler(style.open,style.close,this._styler),this._isEmpty);Object.defineProperty(this,styleName,{value:builder});return builder;}};}styles.visible={get(){const builder=createBuilder(this,this._styler,true);Object.defineProperty(this,'visible',{value:builder});return builder;}};const usedModels=['rgb','hex','keyword','hsl','hsv','hwb','ansi','ansi256'];for(const model of usedModels){styles[model]={get(){const{level}=this;return function(){const styler=createStyler(ansiStyles$1.color[levelMapping[level]][model](...arguments),ansiStyles$1.color.close,this._styler);return createBuilder(this,styler,this._isEmpty);};}};}for(const model of usedModels){const bgModel='bg'+model[0].toUpperCase()+model.slice(1);styles[bgModel]={get(){const{level}=this;return function(){const styler=createStyler(ansiStyles$1.bgColor[levelMapping[level]][model](...arguments),ansiStyles$1.bgColor.close,this._styler);return createBuilder(this,styler,this._isEmpty);};}};}const proto=Object.defineProperties(()=>{},Object.assign({},styles,{level:{enumerable:true,get(){return this._generator.level;},set(level){this._generator.level=level;}}}));const createStyler=(open,close,parent)=>{let openAll;let closeAll;if(parent===undefined){openAll=open;closeAll=close;}else{openAll=parent.openAll+open;closeAll=close+parent.closeAll;}return{open,close,openAll,closeAll,parent};};const createBuilder=(self,_styler,_isEmpty)=>{const builder=function(){for(var _len6=arguments.length,arguments_=new Array(_len6),_key7=0;_key7<_len6;_key7++){arguments_[_key7]=arguments[_key7];}// Single argument is hot path, implicit coercion is faster than anything\n// eslint-disable-next-line no-implicit-coercion\nreturn applyStyle(builder,arguments_.length===1?''+arguments_[0]:arguments_.join(' '));};// We alter the prototype because we must return a function, but there is\n// no way to create a function with a different prototype\nObject.setPrototypeOf(builder,proto);builder._generator=self;builder._styler=_styler;builder._isEmpty=_isEmpty;return builder;};const applyStyle=(self,string)=>{if(self.level<=0||!string){return self._isEmpty?'':string;}let styler=self._styler;if(styler===undefined){return string;}const{openAll,closeAll}=styler;if(string.indexOf('\\u001B')!==-1){while(styler!==undefined){// Replace any instances already present with a re-opening code\n// otherwise only the part of the string until said closing code\n// will be colored, and the rest will simply be 'plain'.\nstring=stringReplaceAll$1(string,styler.close,styler.open);styler=styler.parent;}}// We can move both next actions out of loop, because remaining actions in loop won't have\n// any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\nconst lfIndex=string.indexOf('\\n');if(lfIndex!==-1){string=stringEncaseCRLFWithFirstIndex$1(string,closeAll,openAll,lfIndex);}return openAll+string+closeAll;};let template;const chalkTag=function(chalk){for(var _len7=arguments.length,strings=new Array(_len7>1?_len7-1:0),_key8=1;_key8<_len7;_key8++){strings[_key8-1]=arguments[_key8];}const[firstString]=strings;if(!Array.isArray(firstString)){// If chalk() was called by itself or with a string,\n// return the string itself as a string.\nreturn strings.join(' ');}const arguments_=strings.slice(1);const parts=[firstString.raw[0]];for(let i=1;i<firstString.length;i++){parts.push(String(arguments_[i-1]).replace(/[{}\\\\]/g,'\\\\$&'),String(firstString.raw[i]));}if(template===undefined){template=templates$1;}return template(chalk,parts.join(''));};Object.defineProperties(Chalk.prototype,styles);const chalk$1=Chalk();// eslint-disable-line new-cap\nchalk$1.supportsColor=stdoutColor;chalk$1.stderr=Chalk({level:stderrColor?stderrColor.level:0});// eslint-disable-line new-cap\nchalk$1.stderr.supportsColor=stderrColor;var source=chalk$1;const cliDescriptor={key:_key=>_key.length===1?\"-\".concat(_key):\"--\".concat(_key),value:_value=>lib.apiDescriptor.value(_value),pair:_ref11=>{let{key,value}=_ref11;return value===false?\"--no-\".concat(key):value===true?cliDescriptor.key(key):value===\"\"?\"\".concat(cliDescriptor.key(key),\" without an argument\"):\"\".concat(cliDescriptor.key(key),\"=\").concat(value);}};class FlagSchema extends lib.ChoiceSchema{constructor(_ref12){let{name,flags}=_ref12;super({name,choices:flags});this._flags=flags.slice().sort();}preprocess(value,utils){if(typeof value===\"string\"&&value.length!==0&&!this._flags.includes(value)){const suggestion=this._flags.find(flag=>leven_1$1(flag,value)<3);if(suggestion){utils.logger.warn([\"Unknown flag \".concat(source.yellow(utils.descriptor.value(value)),\",\"),\"did you mean \".concat(source.blue(utils.descriptor.value(suggestion)),\"?\")].join(\" \"));return suggestion;}}return value;}expected(){return\"a flag\";}}let hasDeprecationWarned;function normalizeOptions(options,optionInfos){let{logger,isCLI=false,passThrough=false}=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const unknown=!passThrough?lib.levenUnknownHandler:Array.isArray(passThrough)?(key,value)=>!passThrough.includes(key)?undefined:{[key]:value}:(key,value)=>({[key]:value});const descriptor=isCLI?cliDescriptor:lib.apiDescriptor;const schemas=optionInfosToSchemas(optionInfos,{isCLI});const normalizer=new lib.Normalizer(schemas,{logger,unknown,descriptor});const shouldSuppressDuplicateDeprecationWarnings=logger!==false;if(shouldSuppressDuplicateDeprecationWarnings&&hasDeprecationWarned){normalizer._hasDeprecationWarned=hasDeprecationWarned;}const normalized=normalizer.normalize(options);if(shouldSuppressDuplicateDeprecationWarnings){hasDeprecationWarned=normalizer._hasDeprecationWarned;}return normalized;}function optionInfosToSchemas(optionInfos,_ref13){let{isCLI}=_ref13;const schemas=[];if(isCLI){schemas.push(lib.AnySchema.create({name:\"_\"}));}for(const optionInfo of optionInfos){schemas.push(optionInfoToSchema(optionInfo,{isCLI,optionInfos}));if(optionInfo.alias&&isCLI){schemas.push(lib.AliasSchema.create({name:optionInfo.alias,sourceName:optionInfo.name}));}}return schemas;}function optionInfoToSchema(optionInfo,_ref14){let{isCLI,optionInfos}=_ref14;let SchemaConstructor;const parameters={name:optionInfo.name};const handlers={};switch(optionInfo.type){case\"int\":SchemaConstructor=lib.IntegerSchema;if(isCLI){parameters.preprocess=value=>Number(value);}break;case\"string\":SchemaConstructor=lib.StringSchema;break;case\"choice\":SchemaConstructor=lib.ChoiceSchema;parameters.choices=optionInfo.choices.map(choiceInfo=>typeof choiceInfo===\"object\"&&choiceInfo.redirect?Object.assign({},choiceInfo,{redirect:{to:{key:optionInfo.name,value:choiceInfo.redirect}}}):choiceInfo);break;case\"boolean\":SchemaConstructor=lib.BooleanSchema;break;case\"flag\":SchemaConstructor=FlagSchema;parameters.flags=optionInfos.map(optionInfo=>[].concat(optionInfo.alias||[],optionInfo.description?optionInfo.name:[],optionInfo.oppositeDescription?\"no-\".concat(optionInfo.name):[])).reduce((a,b)=>a.concat(b),[]);break;case\"path\":SchemaConstructor=lib.StringSchema;break;default:throw new Error(\"Unexpected type \".concat(optionInfo.type));}if(optionInfo.exception){parameters.validate=(value,schema,utils)=>{return optionInfo.exception(value)||schema.validate(value,utils);};}else{parameters.validate=(value,schema,utils)=>{return value===undefined||schema.validate(value,utils);};}if(optionInfo.redirect){handlers.redirect=value=>!value?undefined:{to:{key:optionInfo.redirect.option,value:optionInfo.redirect.value}};}if(optionInfo.deprecated){handlers.deprecated=true;}// allow CLI overriding, e.g., prettier package.json --tab-width 1 --tab-width 2\nif(isCLI&&!optionInfo.array){const originalPreprocess=parameters.preprocess||(x=>x);parameters.preprocess=(value,schema,utils)=>schema.preprocess(originalPreprocess(Array.isArray(value)?value[value.length-1]:value),utils);}return optionInfo.array?lib.ArraySchema.create(Object.assign({},isCLI?{preprocess:v=>[].concat(v)}:{},{},handlers,{valueSchema:SchemaConstructor.create(parameters)})):SchemaConstructor.create(Object.assign({},parameters,{},handlers));}function normalizeApiOptions(options,optionInfos,opts){return normalizeOptions(options,optionInfos,opts);}function normalizeCliOptions(options,optionInfos,opts){return normalizeOptions(options,optionInfos,Object.assign({isCLI:true},opts));}var optionsNormalizer={normalizeApiOptions,normalizeCliOptions};var getLast=arr=>arr[arr.length-1];function locStart(node,opts){opts=opts||{};// Handle nodes with decorators. They should start at the first decorator\nif(!opts.ignoreDecorators&&node.declaration&&node.declaration.decorators&&node.declaration.decorators.length>0){return locStart(node.declaration.decorators[0]);}if(!opts.ignoreDecorators&&node.decorators&&node.decorators.length>0){return locStart(node.decorators[0]);}if(node.__location){return node.__location.startOffset;}if(node.range){return node.range[0];}if(typeof node.start===\"number\"){return node.start;}if(node.loc){return node.loc.start;}return null;}function locEnd(node){const endNode=node.nodes&&getLast(node.nodes);if(endNode&&node.source&&!node.source.end){node=endNode;}if(node.__location){return node.__location.endOffset;}const loc=node.range?node.range[1]:typeof node.end===\"number\"?node.end:null;if(node.typeAnnotation){return Math.max(loc,locEnd(node.typeAnnotation));}if(node.loc&&!loc){return node.loc.end;}return loc;}function composeLoc(startNode){let endNodeOrLength=arguments.length>1&&arguments[1]!==undefined?arguments[1]:startNode;const length=typeof endNodeOrLength===\"number\"?endNodeOrLength:-1;const start=locStart(startNode);const end=length!==-1?start+length:locEnd(endNodeOrLength);const startLoc=startNode.loc.start;return{start,end,range:[start,end],loc:{start:startLoc,end:length!==-1?{line:startLoc.line,column:startLoc.column+length}:endNodeOrLength.loc.end}};}var loc={locStart,locEnd,composeLoc};var jsTokens=createCommonjsModule(function(module,exports){// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell\n// License: MIT. (See LICENSE.)\nObject.defineProperty(exports,\"__esModule\",{value:true});// This regex comes from regex.coffee, and is inserted here by generate-index.js\n// (run `npm run build`).\nexports.default=/((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g;exports.matchToToken=function(match){var token={type:\"invalid\",value:match[0],closed:undefined};if(match[1])token.type=\"string\",token.closed=!!(match[3]||match[4]);else if(match[5])token.type=\"comment\";else if(match[6])token.type=\"comment\",token.closed=!!match[7];else if(match[8])token.type=\"regex\";else if(match[9])token.type=\"number\";else if(match[10])token.type=\"name\";else if(match[11])token.type=\"punctuator\";else if(match[12])token.type=\"whitespace\";return token;};});unwrapExports(jsTokens);var jsTokens_1=jsTokens.matchToToken;var ast=createCommonjsModule(function(module){/*\n      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */(function(){function isExpression(node){if(node==null){return false;}switch(node.type){case'ArrayExpression':case'AssignmentExpression':case'BinaryExpression':case'CallExpression':case'ConditionalExpression':case'FunctionExpression':case'Identifier':case'Literal':case'LogicalExpression':case'MemberExpression':case'NewExpression':case'ObjectExpression':case'SequenceExpression':case'ThisExpression':case'UnaryExpression':case'UpdateExpression':return true;}return false;}function isIterationStatement(node){if(node==null){return false;}switch(node.type){case'DoWhileStatement':case'ForInStatement':case'ForStatement':case'WhileStatement':return true;}return false;}function isStatement(node){if(node==null){return false;}switch(node.type){case'BlockStatement':case'BreakStatement':case'ContinueStatement':case'DebuggerStatement':case'DoWhileStatement':case'EmptyStatement':case'ExpressionStatement':case'ForInStatement':case'ForStatement':case'IfStatement':case'LabeledStatement':case'ReturnStatement':case'SwitchStatement':case'ThrowStatement':case'TryStatement':case'VariableDeclaration':case'WhileStatement':case'WithStatement':return true;}return false;}function isSourceElement(node){return isStatement(node)||node!=null&&node.type==='FunctionDeclaration';}function trailingStatement(node){switch(node.type){case'IfStatement':if(node.alternate!=null){return node.alternate;}return node.consequent;case'LabeledStatement':case'ForStatement':case'ForInStatement':case'WhileStatement':case'WithStatement':return node.body;}return null;}function isProblematicIfStatement(node){var current;if(node.type!=='IfStatement'){return false;}if(node.alternate==null){return false;}current=node.consequent;do{if(current.type==='IfStatement'){if(current.alternate==null){return true;}}current=trailingStatement(current);}while(current);return false;}module.exports={isExpression:isExpression,isStatement:isStatement,isIterationStatement:isIterationStatement,isSourceElement:isSourceElement,isProblematicIfStatement:isProblematicIfStatement,trailingStatement:trailingStatement};})();/* vim: set sw=4 ts=4 et tw=80 : */});var ast_1=ast.isExpression;var ast_2=ast.isStatement;var ast_3=ast.isIterationStatement;var ast_4=ast.isSourceElement;var ast_5=ast.isProblematicIfStatement;var ast_6=ast.trailingStatement;var code=createCommonjsModule(function(module){/*\n      Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n      Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */(function(){var ES6Regex,ES5Regex,NON_ASCII_WHITESPACES,IDENTIFIER_START,IDENTIFIER_PART,ch;// See `tools/generate-identifier-regex.js`.\nES5Regex={// ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:\nNonAsciiIdentifierStart:/[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,// ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:\nNonAsciiIdentifierPart:/[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/};ES6Regex={// ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:\nNonAsciiIdentifierStart:/[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,// ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:\nNonAsciiIdentifierPart:/[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/};function isDecimalDigit(ch){return 0x30<=ch&&ch<=0x39;// 0..9\n}function isHexDigit(ch){return 0x30<=ch&&ch<=0x39||// 0..9\n0x61<=ch&&ch<=0x66||// a..f\n0x41<=ch&&ch<=0x46;// A..F\n}function isOctalDigit(ch){return ch>=0x30&&ch<=0x37;// 0..7\n}// 7.2 White Space\nNON_ASCII_WHITESPACES=[0x1680,0x2000,0x2001,0x2002,0x2003,0x2004,0x2005,0x2006,0x2007,0x2008,0x2009,0x200A,0x202F,0x205F,0x3000,0xFEFF];function isWhiteSpace(ch){return ch===0x20||ch===0x09||ch===0x0B||ch===0x0C||ch===0xA0||ch>=0x1680&&NON_ASCII_WHITESPACES.indexOf(ch)>=0;}// 7.3 Line Terminators\nfunction isLineTerminator(ch){return ch===0x0A||ch===0x0D||ch===0x2028||ch===0x2029;}// 7.6 Identifier Names and Identifiers\nfunction fromCodePoint(cp){if(cp<=0xFFFF){return String.fromCharCode(cp);}var cu1=String.fromCharCode(Math.floor((cp-0x10000)/0x400)+0xD800);var cu2=String.fromCharCode((cp-0x10000)%0x400+0xDC00);return cu1+cu2;}IDENTIFIER_START=new Array(0x80);for(ch=0;ch<0x80;++ch){IDENTIFIER_START[ch]=ch>=0x61&&ch<=0x7A||// a..z\nch>=0x41&&ch<=0x5A||// A..Z\nch===0x24||ch===0x5F;// $ (dollar) and _ (underscore)\n}IDENTIFIER_PART=new Array(0x80);for(ch=0;ch<0x80;++ch){IDENTIFIER_PART[ch]=ch>=0x61&&ch<=0x7A||// a..z\nch>=0x41&&ch<=0x5A||// A..Z\nch>=0x30&&ch<=0x39||// 0..9\nch===0x24||ch===0x5F;// $ (dollar) and _ (underscore)\n}function isIdentifierStartES5(ch){return ch<0x80?IDENTIFIER_START[ch]:ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));}function isIdentifierPartES5(ch){return ch<0x80?IDENTIFIER_PART[ch]:ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));}function isIdentifierStartES6(ch){return ch<0x80?IDENTIFIER_START[ch]:ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));}function isIdentifierPartES6(ch){return ch<0x80?IDENTIFIER_PART[ch]:ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));}module.exports={isDecimalDigit:isDecimalDigit,isHexDigit:isHexDigit,isOctalDigit:isOctalDigit,isWhiteSpace:isWhiteSpace,isLineTerminator:isLineTerminator,isIdentifierStartES5:isIdentifierStartES5,isIdentifierPartES5:isIdentifierPartES5,isIdentifierStartES6:isIdentifierStartES6,isIdentifierPartES6:isIdentifierPartES6};})();/* vim: set sw=4 ts=4 et tw=80 : */});var code_1=code.isDecimalDigit;var code_2=code.isHexDigit;var code_3=code.isOctalDigit;var code_4=code.isWhiteSpace;var code_5=code.isLineTerminator;var code_6=code.isIdentifierStartES5;var code_7=code.isIdentifierPartES5;var code_8=code.isIdentifierStartES6;var code_9=code.isIdentifierPartES6;var keyword=createCommonjsModule(function(module){/*\n      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */(function(){var code$1=code;function isStrictModeReservedWordES6(id){switch(id){case'implements':case'interface':case'package':case'private':case'protected':case'public':case'static':case'let':return true;default:return false;}}function isKeywordES5(id,strict){// yield should not be treated as keyword under non-strict mode.\nif(!strict&&id==='yield'){return false;}return isKeywordES6(id,strict);}function isKeywordES6(id,strict){if(strict&&isStrictModeReservedWordES6(id)){return true;}switch(id.length){case 2:return id==='if'||id==='in'||id==='do';case 3:return id==='var'||id==='for'||id==='new'||id==='try';case 4:return id==='this'||id==='else'||id==='case'||id==='void'||id==='with'||id==='enum';case 5:return id==='while'||id==='break'||id==='catch'||id==='throw'||id==='const'||id==='yield'||id==='class'||id==='super';case 6:return id==='return'||id==='typeof'||id==='delete'||id==='switch'||id==='export'||id==='import';case 7:return id==='default'||id==='finally'||id==='extends';case 8:return id==='function'||id==='continue'||id==='debugger';case 10:return id==='instanceof';default:return false;}}function isReservedWordES5(id,strict){return id==='null'||id==='true'||id==='false'||isKeywordES5(id,strict);}function isReservedWordES6(id,strict){return id==='null'||id==='true'||id==='false'||isKeywordES6(id,strict);}function isRestrictedWord(id){return id==='eval'||id==='arguments';}function isIdentifierNameES5(id){var i,iz,ch;if(id.length===0){return false;}ch=id.charCodeAt(0);if(!code$1.isIdentifierStartES5(ch)){return false;}for(i=1,iz=id.length;i<iz;++i){ch=id.charCodeAt(i);if(!code$1.isIdentifierPartES5(ch)){return false;}}return true;}function decodeUtf16(lead,trail){return(lead-0xD800)*0x400+(trail-0xDC00)+0x10000;}function isIdentifierNameES6(id){var i,iz,ch,lowCh,check;if(id.length===0){return false;}check=code$1.isIdentifierStartES6;for(i=0,iz=id.length;i<iz;++i){ch=id.charCodeAt(i);if(0xD800<=ch&&ch<=0xDBFF){++i;if(i>=iz){return false;}lowCh=id.charCodeAt(i);if(!(0xDC00<=lowCh&&lowCh<=0xDFFF)){return false;}ch=decodeUtf16(ch,lowCh);}if(!check(ch)){return false;}check=code$1.isIdentifierPartES6;}return true;}function isIdentifierES5(id,strict){return isIdentifierNameES5(id)&&!isReservedWordES5(id,strict);}function isIdentifierES6(id,strict){return isIdentifierNameES6(id)&&!isReservedWordES6(id,strict);}module.exports={isKeywordES5:isKeywordES5,isKeywordES6:isKeywordES6,isReservedWordES5:isReservedWordES5,isReservedWordES6:isReservedWordES6,isRestrictedWord:isRestrictedWord,isIdentifierNameES5:isIdentifierNameES5,isIdentifierNameES6:isIdentifierNameES6,isIdentifierES5:isIdentifierES5,isIdentifierES6:isIdentifierES6};})();/* vim: set sw=4 ts=4 et tw=80 : */});var keyword_1=keyword.isKeywordES5;var keyword_2=keyword.isKeywordES6;var keyword_3=keyword.isReservedWordES5;var keyword_4=keyword.isReservedWordES6;var keyword_5=keyword.isRestrictedWord;var keyword_6=keyword.isIdentifierNameES5;var keyword_7=keyword.isIdentifierNameES6;var keyword_8=keyword.isIdentifierES5;var keyword_9=keyword.isIdentifierES6;var utils$1=createCommonjsModule(function(module,exports){/*\n      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */(function(){exports.ast=ast;exports.code=code;exports.keyword=keyword;})();/* vim: set sw=4 ts=4 et tw=80 : */});var utils_1$1=utils$1.ast;var utils_2$1=utils$1.code;var utils_3$1=utils$1.keyword;var matchOperatorsRe$1=/[|\\\\{}()[\\]^$+*?.]/g;var escapeStringRegexp$1=function escapeStringRegexp(str){if(typeof str!=='string'){throw new TypeError('Expected a string');}return str.replace(matchOperatorsRe$1,'\\\\$&');};var colorName$2={\"aliceblue\":[240,248,255],\"antiquewhite\":[250,235,215],\"aqua\":[0,255,255],\"aquamarine\":[127,255,212],\"azure\":[240,255,255],\"beige\":[245,245,220],\"bisque\":[255,228,196],\"black\":[0,0,0],\"blanchedalmond\":[255,235,205],\"blue\":[0,0,255],\"blueviolet\":[138,43,226],\"brown\":[165,42,42],\"burlywood\":[222,184,135],\"cadetblue\":[95,158,160],\"chartreuse\":[127,255,0],\"chocolate\":[210,105,30],\"coral\":[255,127,80],\"cornflowerblue\":[100,149,237],\"cornsilk\":[255,248,220],\"crimson\":[220,20,60],\"cyan\":[0,255,255],\"darkblue\":[0,0,139],\"darkcyan\":[0,139,139],\"darkgoldenrod\":[184,134,11],\"darkgray\":[169,169,169],\"darkgreen\":[0,100,0],\"darkgrey\":[169,169,169],\"darkkhaki\":[189,183,107],\"darkmagenta\":[139,0,139],\"darkolivegreen\":[85,107,47],\"darkorange\":[255,140,0],\"darkorchid\":[153,50,204],\"darkred\":[139,0,0],\"darksalmon\":[233,150,122],\"darkseagreen\":[143,188,143],\"darkslateblue\":[72,61,139],\"darkslategray\":[47,79,79],\"darkslategrey\":[47,79,79],\"darkturquoise\":[0,206,209],\"darkviolet\":[148,0,211],\"deeppink\":[255,20,147],\"deepskyblue\":[0,191,255],\"dimgray\":[105,105,105],\"dimgrey\":[105,105,105],\"dodgerblue\":[30,144,255],\"firebrick\":[178,34,34],\"floralwhite\":[255,250,240],\"forestgreen\":[34,139,34],\"fuchsia\":[255,0,255],\"gainsboro\":[220,220,220],\"ghostwhite\":[248,248,255],\"gold\":[255,215,0],\"goldenrod\":[218,165,32],\"gray\":[128,128,128],\"green\":[0,128,0],\"greenyellow\":[173,255,47],\"grey\":[128,128,128],\"honeydew\":[240,255,240],\"hotpink\":[255,105,180],\"indianred\":[205,92,92],\"indigo\":[75,0,130],\"ivory\":[255,255,240],\"khaki\":[240,230,140],\"lavender\":[230,230,250],\"lavenderblush\":[255,240,245],\"lawngreen\":[124,252,0],\"lemonchiffon\":[255,250,205],\"lightblue\":[173,216,230],\"lightcoral\":[240,128,128],\"lightcyan\":[224,255,255],\"lightgoldenrodyellow\":[250,250,210],\"lightgray\":[211,211,211],\"lightgreen\":[144,238,144],\"lightgrey\":[211,211,211],\"lightpink\":[255,182,193],\"lightsalmon\":[255,160,122],\"lightseagreen\":[32,178,170],\"lightskyblue\":[135,206,250],\"lightslategray\":[119,136,153],\"lightslategrey\":[119,136,153],\"lightsteelblue\":[176,196,222],\"lightyellow\":[255,255,224],\"lime\":[0,255,0],\"limegreen\":[50,205,50],\"linen\":[250,240,230],\"magenta\":[255,0,255],\"maroon\":[128,0,0],\"mediumaquamarine\":[102,205,170],\"mediumblue\":[0,0,205],\"mediumorchid\":[186,85,211],\"mediumpurple\":[147,112,219],\"mediumseagreen\":[60,179,113],\"mediumslateblue\":[123,104,238],\"mediumspringgreen\":[0,250,154],\"mediumturquoise\":[72,209,204],\"mediumvioletred\":[199,21,133],\"midnightblue\":[25,25,112],\"mintcream\":[245,255,250],\"mistyrose\":[255,228,225],\"moccasin\":[255,228,181],\"navajowhite\":[255,222,173],\"navy\":[0,0,128],\"oldlace\":[253,245,230],\"olive\":[128,128,0],\"olivedrab\":[107,142,35],\"orange\":[255,165,0],\"orangered\":[255,69,0],\"orchid\":[218,112,214],\"palegoldenrod\":[238,232,170],\"palegreen\":[152,251,152],\"paleturquoise\":[175,238,238],\"palevioletred\":[219,112,147],\"papayawhip\":[255,239,213],\"peachpuff\":[255,218,185],\"peru\":[205,133,63],\"pink\":[255,192,203],\"plum\":[221,160,221],\"powderblue\":[176,224,230],\"purple\":[128,0,128],\"rebeccapurple\":[102,51,153],\"red\":[255,0,0],\"rosybrown\":[188,143,143],\"royalblue\":[65,105,225],\"saddlebrown\":[139,69,19],\"salmon\":[250,128,114],\"sandybrown\":[244,164,96],\"seagreen\":[46,139,87],\"seashell\":[255,245,238],\"sienna\":[160,82,45],\"silver\":[192,192,192],\"skyblue\":[135,206,235],\"slateblue\":[106,90,205],\"slategray\":[112,128,144],\"slategrey\":[112,128,144],\"snow\":[255,250,250],\"springgreen\":[0,255,127],\"steelblue\":[70,130,180],\"tan\":[210,180,140],\"teal\":[0,128,128],\"thistle\":[216,191,216],\"tomato\":[255,99,71],\"turquoise\":[64,224,208],\"violet\":[238,130,238],\"wheat\":[245,222,179],\"white\":[255,255,255],\"whitesmoke\":[245,245,245],\"yellow\":[255,255,0],\"yellowgreen\":[154,205,50]};var conversions$2=createCommonjsModule(function(module){/* MIT license */ // NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\nvar reverseKeywords={};for(var key in colorName$2){if(colorName$2.hasOwnProperty(key)){reverseKeywords[colorName$2[key]]=key;}}var convert=module.exports={rgb:{channels:3,labels:'rgb'},hsl:{channels:3,labels:'hsl'},hsv:{channels:3,labels:'hsv'},hwb:{channels:3,labels:'hwb'},cmyk:{channels:4,labels:'cmyk'},xyz:{channels:3,labels:'xyz'},lab:{channels:3,labels:'lab'},lch:{channels:3,labels:'lch'},hex:{channels:1,labels:['hex']},keyword:{channels:1,labels:['keyword']},ansi16:{channels:1,labels:['ansi16']},ansi256:{channels:1,labels:['ansi256']},hcg:{channels:3,labels:['h','c','g']},apple:{channels:3,labels:['r16','g16','b16']},gray:{channels:1,labels:['gray']}};// hide .channels and .labels properties\nfor(var model in convert){if(convert.hasOwnProperty(model)){if(!('channels'in convert[model])){throw new Error('missing channels property: '+model);}if(!('labels'in convert[model])){throw new Error('missing channel labels property: '+model);}if(convert[model].labels.length!==convert[model].channels){throw new Error('channel and label counts mismatch: '+model);}var channels=convert[model].channels;var labels=convert[model].labels;delete convert[model].channels;delete convert[model].labels;Object.defineProperty(convert[model],'channels',{value:channels});Object.defineProperty(convert[model],'labels',{value:labels});}}convert.rgb.hsl=function(rgb){var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;var min=Math.min(r,g,b);var max=Math.max(r,g,b);var delta=max-min;var h;var s;var l;if(max===min){h=0;}else if(r===max){h=(g-b)/delta;}else if(g===max){h=2+(b-r)/delta;}else if(b===max){h=4+(r-g)/delta;}h=Math.min(h*60,360);if(h<0){h+=360;}l=(min+max)/2;if(max===min){s=0;}else if(l<=0.5){s=delta/(max+min);}else{s=delta/(2-max-min);}return[h,s*100,l*100];};convert.rgb.hsv=function(rgb){var rdif;var gdif;var bdif;var h;var s;var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;var v=Math.max(r,g,b);var diff=v-Math.min(r,g,b);var diffc=function diffc(c){return(v-c)/6/diff+1/2;};if(diff===0){h=s=0;}else{s=diff/v;rdif=diffc(r);gdif=diffc(g);bdif=diffc(b);if(r===v){h=bdif-gdif;}else if(g===v){h=1/3+rdif-bdif;}else if(b===v){h=2/3+gdif-rdif;}if(h<0){h+=1;}else if(h>1){h-=1;}}return[h*360,s*100,v*100];};convert.rgb.hwb=function(rgb){var r=rgb[0];var g=rgb[1];var b=rgb[2];var h=convert.rgb.hsl(rgb)[0];var w=1/255*Math.min(r,Math.min(g,b));b=1-1/255*Math.max(r,Math.max(g,b));return[h,w*100,b*100];};convert.rgb.cmyk=function(rgb){var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;var c;var m;var y;var k;k=Math.min(1-r,1-g,1-b);c=(1-r-k)/(1-k)||0;m=(1-g-k)/(1-k)||0;y=(1-b-k)/(1-k)||0;return[c*100,m*100,y*100,k*100];};/**\n     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n     * */function comparativeDistance(x,y){return Math.pow(x[0]-y[0],2)+Math.pow(x[1]-y[1],2)+Math.pow(x[2]-y[2],2);}convert.rgb.keyword=function(rgb){var reversed=reverseKeywords[rgb];if(reversed){return reversed;}var currentClosestDistance=Infinity;var currentClosestKeyword;for(var keyword in colorName$2){if(colorName$2.hasOwnProperty(keyword)){var value=colorName$2[keyword];// Compute comparative distance\nvar distance=comparativeDistance(rgb,value);// Check if its less, if so set as closest\nif(distance<currentClosestDistance){currentClosestDistance=distance;currentClosestKeyword=keyword;}}}return currentClosestKeyword;};convert.keyword.rgb=function(keyword){return colorName$2[keyword];};convert.rgb.xyz=function(rgb){var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;// assume sRGB\nr=r>0.04045?Math.pow((r+0.055)/1.055,2.4):r/12.92;g=g>0.04045?Math.pow((g+0.055)/1.055,2.4):g/12.92;b=b>0.04045?Math.pow((b+0.055)/1.055,2.4):b/12.92;var x=r*0.4124+g*0.3576+b*0.1805;var y=r*0.2126+g*0.7152+b*0.0722;var z=r*0.0193+g*0.1192+b*0.9505;return[x*100,y*100,z*100];};convert.rgb.lab=function(rgb){var xyz=convert.rgb.xyz(rgb);var x=xyz[0];var y=xyz[1];var z=xyz[2];var l;var a;var b;x/=95.047;y/=100;z/=108.883;x=x>0.008856?Math.pow(x,1/3):7.787*x+16/116;y=y>0.008856?Math.pow(y,1/3):7.787*y+16/116;z=z>0.008856?Math.pow(z,1/3):7.787*z+16/116;l=116*y-16;a=500*(x-y);b=200*(y-z);return[l,a,b];};convert.hsl.rgb=function(hsl){var h=hsl[0]/360;var s=hsl[1]/100;var l=hsl[2]/100;var t1;var t2;var t3;var rgb;var val;if(s===0){val=l*255;return[val,val,val];}if(l<0.5){t2=l*(1+s);}else{t2=l+s-l*s;}t1=2*l-t2;rgb=[0,0,0];for(var i=0;i<3;i++){t3=h+1/3*-(i-1);if(t3<0){t3++;}if(t3>1){t3--;}if(6*t3<1){val=t1+(t2-t1)*6*t3;}else if(2*t3<1){val=t2;}else if(3*t3<2){val=t1+(t2-t1)*(2/3-t3)*6;}else{val=t1;}rgb[i]=val*255;}return rgb;};convert.hsl.hsv=function(hsl){var h=hsl[0];var s=hsl[1]/100;var l=hsl[2]/100;var smin=s;var lmin=Math.max(l,0.01);var sv;var v;l*=2;s*=l<=1?l:2-l;smin*=lmin<=1?lmin:2-lmin;v=(l+s)/2;sv=l===0?2*smin/(lmin+smin):2*s/(l+s);return[h,sv*100,v*100];};convert.hsv.rgb=function(hsv){var h=hsv[0]/60;var s=hsv[1]/100;var v=hsv[2]/100;var hi=Math.floor(h)%6;var f=h-Math.floor(h);var p=255*v*(1-s);var q=255*v*(1-s*f);var t=255*v*(1-s*(1-f));v*=255;switch(hi){case 0:return[v,t,p];case 1:return[q,v,p];case 2:return[p,v,t];case 3:return[p,q,v];case 4:return[t,p,v];case 5:return[v,p,q];}};convert.hsv.hsl=function(hsv){var h=hsv[0];var s=hsv[1]/100;var v=hsv[2]/100;var vmin=Math.max(v,0.01);var lmin;var sl;var l;l=(2-s)*v;lmin=(2-s)*vmin;sl=s*vmin;sl/=lmin<=1?lmin:2-lmin;sl=sl||0;l/=2;return[h,sl*100,l*100];};// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb=function(hwb){var h=hwb[0]/360;var wh=hwb[1]/100;var bl=hwb[2]/100;var ratio=wh+bl;var i;var v;var f;var n;// wh + bl cant be > 1\nif(ratio>1){wh/=ratio;bl/=ratio;}i=Math.floor(6*h);v=1-bl;f=6*h-i;if((i&0x01)!==0){f=1-f;}n=wh+f*(v-wh);// linear interpolation\nvar r;var g;var b;switch(i){default:case 6:case 0:r=v;g=n;b=wh;break;case 1:r=n;g=v;b=wh;break;case 2:r=wh;g=v;b=n;break;case 3:r=wh;g=n;b=v;break;case 4:r=n;g=wh;b=v;break;case 5:r=v;g=wh;b=n;break;}return[r*255,g*255,b*255];};convert.cmyk.rgb=function(cmyk){var c=cmyk[0]/100;var m=cmyk[1]/100;var y=cmyk[2]/100;var k=cmyk[3]/100;var r;var g;var b;r=1-Math.min(1,c*(1-k)+k);g=1-Math.min(1,m*(1-k)+k);b=1-Math.min(1,y*(1-k)+k);return[r*255,g*255,b*255];};convert.xyz.rgb=function(xyz){var x=xyz[0]/100;var y=xyz[1]/100;var z=xyz[2]/100;var r;var g;var b;r=x*3.2406+y*-1.5372+z*-0.4986;g=x*-0.9689+y*1.8758+z*0.0415;b=x*0.0557+y*-0.2040+z*1.0570;// assume sRGB\nr=r>0.0031308?1.055*Math.pow(r,1.0/2.4)-0.055:r*12.92;g=g>0.0031308?1.055*Math.pow(g,1.0/2.4)-0.055:g*12.92;b=b>0.0031308?1.055*Math.pow(b,1.0/2.4)-0.055:b*12.92;r=Math.min(Math.max(0,r),1);g=Math.min(Math.max(0,g),1);b=Math.min(Math.max(0,b),1);return[r*255,g*255,b*255];};convert.xyz.lab=function(xyz){var x=xyz[0];var y=xyz[1];var z=xyz[2];var l;var a;var b;x/=95.047;y/=100;z/=108.883;x=x>0.008856?Math.pow(x,1/3):7.787*x+16/116;y=y>0.008856?Math.pow(y,1/3):7.787*y+16/116;z=z>0.008856?Math.pow(z,1/3):7.787*z+16/116;l=116*y-16;a=500*(x-y);b=200*(y-z);return[l,a,b];};convert.lab.xyz=function(lab){var l=lab[0];var a=lab[1];var b=lab[2];var x;var y;var z;y=(l+16)/116;x=a/500+y;z=y-b/200;var y2=Math.pow(y,3);var x2=Math.pow(x,3);var z2=Math.pow(z,3);y=y2>0.008856?y2:(y-16/116)/7.787;x=x2>0.008856?x2:(x-16/116)/7.787;z=z2>0.008856?z2:(z-16/116)/7.787;x*=95.047;y*=100;z*=108.883;return[x,y,z];};convert.lab.lch=function(lab){var l=lab[0];var a=lab[1];var b=lab[2];var hr;var h;var c;hr=Math.atan2(b,a);h=hr*360/2/Math.PI;if(h<0){h+=360;}c=Math.sqrt(a*a+b*b);return[l,c,h];};convert.lch.lab=function(lch){var l=lch[0];var c=lch[1];var h=lch[2];var a;var b;var hr;hr=h/360*2*Math.PI;a=c*Math.cos(hr);b=c*Math.sin(hr);return[l,a,b];};convert.rgb.ansi16=function(args){var r=args[0];var g=args[1];var b=args[2];var value=1 in arguments?arguments[1]:convert.rgb.hsv(args)[2];// hsv -> ansi16 optimization\nvalue=Math.round(value/50);if(value===0){return 30;}var ansi=30+(Math.round(b/255)<<2|Math.round(g/255)<<1|Math.round(r/255));if(value===2){ansi+=60;}return ansi;};convert.hsv.ansi16=function(args){// optimization here; we already know the value and don't need to get\n// it converted for us.\nreturn convert.rgb.ansi16(convert.hsv.rgb(args),args[2]);};convert.rgb.ansi256=function(args){var r=args[0];var g=args[1];var b=args[2];// we use the extended greyscale palette here, with the exception of\n// black and white. normal palette only has 4 greyscale shades.\nif(r===g&&g===b){if(r<8){return 16;}if(r>248){return 231;}return Math.round((r-8)/247*24)+232;}var ansi=16+36*Math.round(r/255*5)+6*Math.round(g/255*5)+Math.round(b/255*5);return ansi;};convert.ansi16.rgb=function(args){var color=args%10;// handle greyscale\nif(color===0||color===7){if(args>50){color+=3.5;}color=color/10.5*255;return[color,color,color];}var mult=(~~(args>50)+1)*0.5;var r=(color&1)*mult*255;var g=(color>>1&1)*mult*255;var b=(color>>2&1)*mult*255;return[r,g,b];};convert.ansi256.rgb=function(args){// handle greyscale\nif(args>=232){var c=(args-232)*10+8;return[c,c,c];}args-=16;var rem;var r=Math.floor(args/36)/5*255;var g=Math.floor((rem=args%36)/6)/5*255;var b=rem%6/5*255;return[r,g,b];};convert.rgb.hex=function(args){var integer=((Math.round(args[0])&0xFF)<<16)+((Math.round(args[1])&0xFF)<<8)+(Math.round(args[2])&0xFF);var string=integer.toString(16).toUpperCase();return'000000'.substring(string.length)+string;};convert.hex.rgb=function(args){var match=args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);if(!match){return[0,0,0];}var colorString=match[0];if(match[0].length===3){colorString=colorString.split('').map(function(char){return char+char;}).join('');}var integer=parseInt(colorString,16);var r=integer>>16&0xFF;var g=integer>>8&0xFF;var b=integer&0xFF;return[r,g,b];};convert.rgb.hcg=function(rgb){var r=rgb[0]/255;var g=rgb[1]/255;var b=rgb[2]/255;var max=Math.max(Math.max(r,g),b);var min=Math.min(Math.min(r,g),b);var chroma=max-min;var grayscale;var hue;if(chroma<1){grayscale=min/(1-chroma);}else{grayscale=0;}if(chroma<=0){hue=0;}else if(max===r){hue=(g-b)/chroma%6;}else if(max===g){hue=2+(b-r)/chroma;}else{hue=4+(r-g)/chroma+4;}hue/=6;hue%=1;return[hue*360,chroma*100,grayscale*100];};convert.hsl.hcg=function(hsl){var s=hsl[1]/100;var l=hsl[2]/100;var c=1;var f=0;if(l<0.5){c=2.0*s*l;}else{c=2.0*s*(1.0-l);}if(c<1.0){f=(l-0.5*c)/(1.0-c);}return[hsl[0],c*100,f*100];};convert.hsv.hcg=function(hsv){var s=hsv[1]/100;var v=hsv[2]/100;var c=s*v;var f=0;if(c<1.0){f=(v-c)/(1-c);}return[hsv[0],c*100,f*100];};convert.hcg.rgb=function(hcg){var h=hcg[0]/360;var c=hcg[1]/100;var g=hcg[2]/100;if(c===0.0){return[g*255,g*255,g*255];}var pure=[0,0,0];var hi=h%1*6;var v=hi%1;var w=1-v;var mg=0;switch(Math.floor(hi)){case 0:pure[0]=1;pure[1]=v;pure[2]=0;break;case 1:pure[0]=w;pure[1]=1;pure[2]=0;break;case 2:pure[0]=0;pure[1]=1;pure[2]=v;break;case 3:pure[0]=0;pure[1]=w;pure[2]=1;break;case 4:pure[0]=v;pure[1]=0;pure[2]=1;break;default:pure[0]=1;pure[1]=0;pure[2]=w;}mg=(1.0-c)*g;return[(c*pure[0]+mg)*255,(c*pure[1]+mg)*255,(c*pure[2]+mg)*255];};convert.hcg.hsv=function(hcg){var c=hcg[1]/100;var g=hcg[2]/100;var v=c+g*(1.0-c);var f=0;if(v>0.0){f=c/v;}return[hcg[0],f*100,v*100];};convert.hcg.hsl=function(hcg){var c=hcg[1]/100;var g=hcg[2]/100;var l=g*(1.0-c)+0.5*c;var s=0;if(l>0.0&&l<0.5){s=c/(2*l);}else if(l>=0.5&&l<1.0){s=c/(2*(1-l));}return[hcg[0],s*100,l*100];};convert.hcg.hwb=function(hcg){var c=hcg[1]/100;var g=hcg[2]/100;var v=c+g*(1.0-c);return[hcg[0],(v-c)*100,(1-v)*100];};convert.hwb.hcg=function(hwb){var w=hwb[1]/100;var b=hwb[2]/100;var v=1-b;var c=v-w;var g=0;if(c<1){g=(v-c)/(1-c);}return[hwb[0],c*100,g*100];};convert.apple.rgb=function(apple){return[apple[0]/65535*255,apple[1]/65535*255,apple[2]/65535*255];};convert.rgb.apple=function(rgb){return[rgb[0]/255*65535,rgb[1]/255*65535,rgb[2]/255*65535];};convert.gray.rgb=function(args){return[args[0]/100*255,args[0]/100*255,args[0]/100*255];};convert.gray.hsl=convert.gray.hsv=function(args){return[0,0,args[0]];};convert.gray.hwb=function(gray){return[0,100,gray[0]];};convert.gray.cmyk=function(gray){return[0,0,0,gray[0]];};convert.gray.lab=function(gray){return[gray[0],0,0];};convert.gray.hex=function(gray){var val=Math.round(gray[0]/100*255)&0xFF;var integer=(val<<16)+(val<<8)+val;var string=integer.toString(16).toUpperCase();return'000000'.substring(string.length)+string;};convert.rgb.gray=function(rgb){var val=(rgb[0]+rgb[1]+rgb[2])/3;return[val/255*100];};});var conversions_1$1=conversions$2.rgb;var conversions_2$1=conversions$2.hsl;var conversions_3$1=conversions$2.hsv;var conversions_4$1=conversions$2.hwb;var conversions_5$1=conversions$2.cmyk;var conversions_6$1=conversions$2.xyz;var conversions_7$1=conversions$2.lab;var conversions_8$1=conversions$2.lch;var conversions_9$1=conversions$2.hex;var conversions_10$1=conversions$2.keyword;var conversions_11$1=conversions$2.ansi16;var conversions_12$1=conversions$2.ansi256;var conversions_13$1=conversions$2.hcg;var conversions_14$1=conversions$2.apple;var conversions_15$1=conversions$2.gray;/*\n  \tthis function routes a model to all other models.\n\n  \tall functions that are routed have a property `.conversion` attached\n  \tto the returned synthetic function. This property is an array\n  \tof strings, each with the steps in between the 'from' and 'to'\n  \tcolor models (inclusive).\n\n  \tconversions that are not possible simply are not included.\n  */function buildGraph$2(){var graph={};// https://jsperf.com/object-keys-vs-for-in-with-closure/3\nvar models=Object.keys(conversions$2);for(var len=models.length,i=0;i<len;i++){graph[models[i]]={// http://jsperf.com/1-vs-infinity\n// micro-opt, but this is simple.\ndistance:-1,parent:null};}return graph;}// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS$2(fromModel){var graph=buildGraph$2();var queue=[fromModel];// unshift -> queue -> pop\ngraph[fromModel].distance=0;while(queue.length){var current=queue.pop();var adjacents=Object.keys(conversions$2[current]);for(var len=adjacents.length,i=0;i<len;i++){var adjacent=adjacents[i];var node=graph[adjacent];if(node.distance===-1){node.distance=graph[current].distance+1;node.parent=current;queue.unshift(adjacent);}}}return graph;}function link$2(from,to){return function(args){return to(from(args));};}function wrapConversion$2(toModel,graph){var path=[graph[toModel].parent,toModel];var fn=conversions$2[graph[toModel].parent][toModel];var cur=graph[toModel].parent;while(graph[cur].parent){path.unshift(graph[cur].parent);fn=link$2(conversions$2[graph[cur].parent][cur],fn);cur=graph[cur].parent;}fn.conversion=path;return fn;}var route$2=function route(fromModel){var graph=deriveBFS$2(fromModel);var conversion={};var models=Object.keys(graph);for(var len=models.length,i=0;i<len;i++){var toModel=models[i];var node=graph[toModel];if(node.parent===null){// no possible conversion, or this node is the source model.\ncontinue;}conversion[toModel]=wrapConversion$2(toModel,graph);}return conversion;};var convert$3={};var models$2=Object.keys(conversions$2);function wrapRaw$2(fn){var wrappedFn=function wrappedFn(args){if(args===undefined||args===null){return args;}if(arguments.length>1){args=Array.prototype.slice.call(arguments);}return fn(args);};// preserve .conversion property if there is one\nif('conversion'in fn){wrappedFn.conversion=fn.conversion;}return wrappedFn;}function wrapRounded$2(fn){var wrappedFn=function wrappedFn(args){if(args===undefined||args===null){return args;}if(arguments.length>1){args=Array.prototype.slice.call(arguments);}var result=fn(args);// we're assuming the result is an array here.\n// see notice in conversions.js; don't use box types\n// in conversion functions.\nif(typeof result==='object'){for(var len=result.length,i=0;i<len;i++){result[i]=Math.round(result[i]);}}return result;};// preserve .conversion property if there is one\nif('conversion'in fn){wrappedFn.conversion=fn.conversion;}return wrappedFn;}models$2.forEach(function(fromModel){convert$3[fromModel]={};Object.defineProperty(convert$3[fromModel],'channels',{value:conversions$2[fromModel].channels});Object.defineProperty(convert$3[fromModel],'labels',{value:conversions$2[fromModel].labels});var routes=route$2(fromModel);var routeModels=Object.keys(routes);routeModels.forEach(function(toModel){var fn=routes[toModel];convert$3[fromModel][toModel]=wrapRounded$2(fn);convert$3[fromModel][toModel].raw=wrapRaw$2(fn);});});var colorConvert$2=convert$3;var ansiStyles$2=createCommonjsModule(function(module){const wrapAnsi16=(fn,offset)=>function(){const code=fn.apply(colorConvert$2,arguments);return\"\\x1B[\".concat(code+offset,\"m\");};const wrapAnsi256=(fn,offset)=>function(){const code=fn.apply(colorConvert$2,arguments);return\"\\x1B[\".concat(38+offset,\";5;\").concat(code,\"m\");};const wrapAnsi16m=(fn,offset)=>function(){const rgb=fn.apply(colorConvert$2,arguments);return\"\\x1B[\".concat(38+offset,\";2;\").concat(rgb[0],\";\").concat(rgb[1],\";\").concat(rgb[2],\"m\");};function assembleStyles(){const codes=new Map();const styles={modifier:{reset:[0,0],// 21 isn't widely supported and 22 does the same thing\nbold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],// Bright color\nredBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],// Bright color\nbgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};// Fix humans\nstyles.color.grey=styles.color.gray;for(const groupName of Object.keys(styles)){const group=styles[groupName];for(const styleName of Object.keys(group)){const style=group[styleName];styles[styleName]={open:\"\\x1B[\".concat(style[0],\"m\"),close:\"\\x1B[\".concat(style[1],\"m\")};group[styleName]=styles[styleName];codes.set(style[0],style[1]);}Object.defineProperty(styles,groupName,{value:group,enumerable:false});Object.defineProperty(styles,'codes',{value:codes,enumerable:false});}const ansi2ansi=n=>n;const rgb2rgb=(r,g,b)=>[r,g,b];styles.color.close='\\u001B[39m';styles.bgColor.close='\\u001B[49m';styles.color.ansi={ansi:wrapAnsi16(ansi2ansi,0)};styles.color.ansi256={ansi256:wrapAnsi256(ansi2ansi,0)};styles.color.ansi16m={rgb:wrapAnsi16m(rgb2rgb,0)};styles.bgColor.ansi={ansi:wrapAnsi16(ansi2ansi,10)};styles.bgColor.ansi256={ansi256:wrapAnsi256(ansi2ansi,10)};styles.bgColor.ansi16m={rgb:wrapAnsi16m(rgb2rgb,10)};for(let key of Object.keys(colorConvert$2)){if(typeof colorConvert$2[key]!=='object'){continue;}const suite=colorConvert$2[key];if(key==='ansi16'){key='ansi';}if('ansi16'in suite){styles.color.ansi[key]=wrapAnsi16(suite.ansi16,0);styles.bgColor.ansi[key]=wrapAnsi16(suite.ansi16,10);}if('ansi256'in suite){styles.color.ansi256[key]=wrapAnsi256(suite.ansi256,0);styles.bgColor.ansi256[key]=wrapAnsi256(suite.ansi256,10);}if('rgb'in suite){styles.color.ansi16m[key]=wrapAnsi16m(suite.rgb,0);styles.bgColor.ansi16m[key]=wrapAnsi16m(suite.rgb,10);}}return styles;}// Make the export immutable\nObject.defineProperty(module,'exports',{enumerable:true,get:assembleStyles});});const env$3=process.env;let forceColor$2;if(hasFlag('no-color')||hasFlag('no-colors')||hasFlag('color=false')){forceColor$2=false;}else if(hasFlag('color')||hasFlag('colors')||hasFlag('color=true')||hasFlag('color=always')){forceColor$2=true;}if('FORCE_COLOR'in env$3){forceColor$2=env$3.FORCE_COLOR.length===0||parseInt(env$3.FORCE_COLOR,10)!==0;}function translateLevel$2(level){if(level===0){return false;}return{level,hasBasic:true,has256:level>=2,has16m:level>=3};}function supportsColor$2(stream){if(forceColor$2===false){return 0;}if(hasFlag('color=16m')||hasFlag('color=full')||hasFlag('color=truecolor')){return 3;}if(hasFlag('color=256')){return 2;}if(stream&&!stream.isTTY&&forceColor$2!==true){return 0;}const min=forceColor$2?1:0;if(process.platform==='win32'){// Node.js 7.5.0 is the first version of Node.js to include a patch to\n// libuv that enables 256 color output on Windows. Anything earlier and it\n// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n// release that supports 256 colors. Windows 10 build 14931 is the first release\n// that supports 16m/TrueColor.\nconst osRelease=require$$0$1.release().split('.');if(Number(process.versions.node.split('.')[0])>=8&&Number(osRelease[0])>=10&&Number(osRelease[2])>=10586){return Number(osRelease[2])>=14931?3:2;}return 1;}if('CI'in env$3){if(['TRAVIS','CIRCLECI','APPVEYOR','GITLAB_CI'].some(sign=>sign in env$3)||env$3.CI_NAME==='codeship'){return 1;}return min;}if('TEAMCITY_VERSION'in env$3){return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env$3.TEAMCITY_VERSION)?1:0;}if(env$3.COLORTERM==='truecolor'){return 3;}if('TERM_PROGRAM'in env$3){const version=parseInt((env$3.TERM_PROGRAM_VERSION||'').split('.')[0],10);switch(env$3.TERM_PROGRAM){case'iTerm.app':return version>=3?3:2;case'Apple_Terminal':return 2;// No default\n}}if(/-256(color)?$/i.test(env$3.TERM)){return 2;}if(/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$3.TERM)){return 1;}if('COLORTERM'in env$3){return 1;}if(env$3.TERM==='dumb'){return min;}return min;}function getSupportLevel$2(stream){const level=supportsColor$2(stream);return translateLevel$2(level);}var supportsColor_1$2={supportsColor:getSupportLevel$2,stdout:getSupportLevel$2(process.stdout),stderr:getSupportLevel$2(process.stderr)};const TEMPLATE_REGEX$2=/(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;const STYLE_REGEX$2=/(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;const STRING_REGEX$2=/^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;const ESCAPE_REGEX$2=/\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;const ESCAPES$2=new Map([['n','\\n'],['r','\\r'],['t','\\t'],['b','\\b'],['f','\\f'],['v','\\v'],['0','\\0'],['\\\\','\\\\'],['e','\\u001B'],['a','\\u0007']]);function unescape$2(c){if(c[0]==='u'&&c.length===5||c[0]==='x'&&c.length===3){return String.fromCharCode(parseInt(c.slice(1),16));}return ESCAPES$2.get(c)||c;}function parseArguments$2(name,args){const results=[];const chunks=args.trim().split(/\\s*,\\s*/g);let matches;for(const chunk of chunks){if(!isNaN(chunk)){results.push(Number(chunk));}else if(matches=chunk.match(STRING_REGEX$2)){results.push(matches[2].replace(ESCAPE_REGEX$2,(m,escape,chr)=>escape?unescape$2(escape):chr));}else{throw new Error(\"Invalid Chalk template style argument: \".concat(chunk,\" (in style '\").concat(name,\"')\"));}}return results;}function parseStyle$2(style){STYLE_REGEX$2.lastIndex=0;const results=[];let matches;while((matches=STYLE_REGEX$2.exec(style))!==null){const name=matches[1];if(matches[2]){const args=parseArguments$2(name,matches[2]);results.push([name].concat(args));}else{results.push([name]);}}return results;}function buildStyle$2(chalk,styles){const enabled={};for(const layer of styles){for(const style of layer.styles){enabled[style[0]]=layer.inverse?null:style.slice(1);}}let current=chalk;for(const styleName of Object.keys(enabled)){if(Array.isArray(enabled[styleName])){if(!(styleName in current)){throw new Error(\"Unknown Chalk style: \".concat(styleName));}if(enabled[styleName].length>0){current=current[styleName].apply(current,enabled[styleName]);}else{current=current[styleName];}}}return current;}var templates$2=(chalk,tmp)=>{const styles=[];const chunks=[];let chunk=[];// eslint-disable-next-line max-params\ntmp.replace(TEMPLATE_REGEX$2,(m,escapeChar,inverse,style,close,chr)=>{if(escapeChar){chunk.push(unescape$2(escapeChar));}else if(style){const str=chunk.join('');chunk=[];chunks.push(styles.length===0?str:buildStyle$2(chalk,styles)(str));styles.push({inverse,styles:parseStyle$2(style)});}else if(close){if(styles.length===0){throw new Error('Found extraneous } in Chalk template literal');}chunks.push(buildStyle$2(chalk,styles)(chunk.join('')));chunk=[];styles.pop();}else{chunk.push(chr);}});chunks.push(chunk.join(''));if(styles.length>0){const errMsg=\"Chalk template literal is missing \".concat(styles.length,\" closing bracket\").concat(styles.length===1?'':'s',\" (`}`)\");throw new Error(errMsg);}return chunks.join('');};var chalk$2=createCommonjsModule(function(module){const stdoutColor=supportsColor_1$2.stdout;const isSimpleWindowsTerm=process.platform==='win32'&&!(process.env.TERM||'').toLowerCase().startsWith('xterm');// `supportsColor.level` → `ansiStyles.color[name]` mapping\nconst levelMapping=['ansi','ansi','ansi256','ansi16m'];// `color-convert` models to exclude from the Chalk API due to conflicts and such\nconst skipModels=new Set(['gray']);const styles=Object.create(null);function applyOptions(obj,options){options=options||{};// Detect level if not set manually\nconst scLevel=stdoutColor?stdoutColor.level:0;obj.level=options.level===undefined?scLevel:options.level;obj.enabled='enabled'in options?options.enabled:obj.level>0;}function Chalk(options){// We check for this.template here since calling `chalk.constructor()`\n// by itself will have a `this` of a previously constructed chalk object\nif(!this||!(this instanceof Chalk)||this.template){const chalk={};applyOptions(chalk,options);chalk.template=function(){const args=[].slice.call(arguments);return chalkTag.apply(null,[chalk.template].concat(args));};Object.setPrototypeOf(chalk,Chalk.prototype);Object.setPrototypeOf(chalk.template,chalk);chalk.template.constructor=Chalk;return chalk.template;}applyOptions(this,options);}// Use bright blue on Windows as the normal blue color is illegible\nif(isSimpleWindowsTerm){ansiStyles$2.blue.open='\\u001B[94m';}for(const key of Object.keys(ansiStyles$2)){ansiStyles$2[key].closeRe=new RegExp(escapeStringRegexp$1(ansiStyles$2[key].close),'g');styles[key]={get(){const codes=ansiStyles$2[key];return build.call(this,this._styles?this._styles.concat(codes):[codes],this._empty,key);}};}styles.visible={get(){return build.call(this,this._styles||[],true,'visible');}};ansiStyles$2.color.closeRe=new RegExp(escapeStringRegexp$1(ansiStyles$2.color.close),'g');for(const model of Object.keys(ansiStyles$2.color.ansi)){if(skipModels.has(model)){continue;}styles[model]={get(){const level=this.level;return function(){const open=ansiStyles$2.color[levelMapping[level]][model].apply(null,arguments);const codes={open,close:ansiStyles$2.color.close,closeRe:ansiStyles$2.color.closeRe};return build.call(this,this._styles?this._styles.concat(codes):[codes],this._empty,model);};}};}ansiStyles$2.bgColor.closeRe=new RegExp(escapeStringRegexp$1(ansiStyles$2.bgColor.close),'g');for(const model of Object.keys(ansiStyles$2.bgColor.ansi)){if(skipModels.has(model)){continue;}const bgModel='bg'+model[0].toUpperCase()+model.slice(1);styles[bgModel]={get(){const level=this.level;return function(){const open=ansiStyles$2.bgColor[levelMapping[level]][model].apply(null,arguments);const codes={open,close:ansiStyles$2.bgColor.close,closeRe:ansiStyles$2.bgColor.closeRe};return build.call(this,this._styles?this._styles.concat(codes):[codes],this._empty,model);};}};}const proto=Object.defineProperties(()=>{},styles);function build(_styles,_empty,key){const builder=function builder(){return applyStyle.apply(builder,arguments);};builder._styles=_styles;builder._empty=_empty;const self=this;Object.defineProperty(builder,'level',{enumerable:true,get(){return self.level;},set(level){self.level=level;}});Object.defineProperty(builder,'enabled',{enumerable:true,get(){return self.enabled;},set(enabled){self.enabled=enabled;}});// See below for fix regarding invisible grey/dim combination on Windows\nbuilder.hasGrey=this.hasGrey||key==='gray'||key==='grey';// `__proto__` is used because we must return a function, but there is\n// no way to create a function with a different prototype\nbuilder.__proto__=proto;// eslint-disable-line no-proto\nreturn builder;}function applyStyle(){// Support varags, but simply cast to string in case there's only one arg\nconst args=arguments;const argsLen=args.length;let str=String(arguments[0]);if(argsLen===0){return'';}if(argsLen>1){// Don't slice `arguments`, it prevents V8 optimizations\nfor(let a=1;a<argsLen;a++){str+=' '+args[a];}}if(!this.enabled||this.level<=0||!str){return this._empty?'':str;}// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n// see https://github.com/chalk/chalk/issues/58\n// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\nconst originalDim=ansiStyles$2.dim.open;if(isSimpleWindowsTerm&&this.hasGrey){ansiStyles$2.dim.open='';}for(const code of this._styles.slice().reverse()){// Replace any instances already present with a re-opening code\n// otherwise only the part of the string until said closing code\n// will be colored, and the rest will simply be 'plain'.\nstr=code.open+str.replace(code.closeRe,code.open)+code.close;// Close the styling before a linebreak and reopen\n// after next line to fix a bleed issue on macOS\n// https://github.com/chalk/chalk/pull/92\nstr=str.replace(/\\r?\\n/g,\"\".concat(code.close,\"$&\").concat(code.open));}// Reset the original `dim` if we changed it to work around the Windows dimmed gray issue\nansiStyles$2.dim.open=originalDim;return str;}function chalkTag(chalk,strings){if(!Array.isArray(strings)){// If chalk() was called by itself or with a string,\n// return the string itself as a string.\nreturn[].slice.call(arguments,1).join(' ');}const args=[].slice.call(arguments,2);const parts=[strings.raw[0]];for(let i=1;i<strings.length;i++){parts.push(String(args[i-1]).replace(/[{}\\\\]/g,'\\\\$&'));parts.push(String(strings.raw[i]));}return templates$2(chalk,parts.join(''));}Object.defineProperties(Chalk.prototype,styles);module.exports=Chalk();// eslint-disable-line new-cap\nmodule.exports.supportsColor=stdoutColor;module.exports.default=module.exports;// For TypeScript\n});var chalk_1$1=chalk$2.supportsColor;var lib$1=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});exports.shouldHighlight=shouldHighlight;exports.getChalk=getChalk;exports.default=highlight;var _jsTokens=_interopRequireWildcard(jsTokens);var _esutils=_interopRequireDefault(utils$1);var _chalk=_interopRequireDefault(chalk$2);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _getRequireWildcardCache(){if(typeof WeakMap!==\"function\")return null;var cache=new WeakMap();_getRequireWildcardCache=function _getRequireWildcardCache(){return cache;};return cache;}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj};}var cache=_getRequireWildcardCache();if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}function getDefs(chalk){return{keyword:chalk.cyan,capitalized:chalk.yellow,jsx_tag:chalk.yellow,punctuator:chalk.yellow,number:chalk.magenta,string:chalk.green,regex:chalk.magenta,comment:chalk.grey,invalid:chalk.white.bgRed.bold};}const NEWLINE=/\\r\\n|[\\n\\r\\u2028\\u2029]/;const JSX_TAG=/^[a-z][\\w-]*$/i;const BRACKET=/^[()[\\]{}]$/;function getTokenType(match){const[offset,text]=match.slice(-2);const token=(0,_jsTokens.matchToToken)(match);if(token.type===\"name\"){if(_esutils.default.keyword.isReservedWordES6(token.value)){return\"keyword\";}if(JSX_TAG.test(token.value)&&(text[offset-1]===\"<\"||text.substr(offset-2,2)==\"</\")){return\"jsx_tag\";}if(token.value[0]!==token.value[0].toLowerCase()){return\"capitalized\";}}if(token.type===\"punctuator\"&&BRACKET.test(token.value)){return\"bracket\";}if(token.type===\"invalid\"&&(token.value===\"@\"||token.value===\"#\")){return\"punctuator\";}return token.type;}function highlightTokens(defs,text){return text.replace(_jsTokens.default,function(){for(var _len8=arguments.length,args=new Array(_len8),_key9=0;_key9<_len8;_key9++){args[_key9]=arguments[_key9];}const type=getTokenType(args);const colorize=defs[type];if(colorize){return args[0].split(NEWLINE).map(str=>colorize(str)).join(\"\\n\");}else{return args[0];}});}function shouldHighlight(options){return _chalk.default.supportsColor||options.forceColor;}function getChalk(options){let chalk=_chalk.default;if(options.forceColor){chalk=new _chalk.default.constructor({enabled:true,level:1});}return chalk;}function highlight(code){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(shouldHighlight(options)){const chalk=getChalk(options);const defs=getDefs(chalk);return highlightTokens(defs,code);}else{return code;}}});unwrapExports(lib$1);var lib_1=lib$1.shouldHighlight;var lib_2=lib$1.getChalk;var lib$2=createCommonjsModule(function(module,exports){Object.defineProperty(exports,\"__esModule\",{value:true});exports.codeFrameColumns=codeFrameColumns;exports.default=_default;var _highlight=_interopRequireWildcard(lib$1);function _getRequireWildcardCache(){if(typeof WeakMap!==\"function\")return null;var cache=new WeakMap();_getRequireWildcardCache=function _getRequireWildcardCache(){return cache;};return cache;}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{default:obj};}var cache=_getRequireWildcardCache();if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj.default=obj;if(cache){cache.set(obj,newObj);}return newObj;}let deprecationWarningShown=false;function getDefs(chalk){return{gutter:chalk.grey,marker:chalk.red.bold,message:chalk.red.bold};}const NEWLINE=/\\r\\n|[\\n\\r\\u2028\\u2029]/;function getMarkerLines(loc,source,opts){const startLoc=Object.assign({column:0,line:-1},loc.start);const endLoc=Object.assign({},startLoc,{},loc.end);const{linesAbove=2,linesBelow=3}=opts||{};const startLine=startLoc.line;const startColumn=startLoc.column;const endLine=endLoc.line;const endColumn=endLoc.column;let start=Math.max(startLine-(linesAbove+1),0);let end=Math.min(source.length,endLine+linesBelow);if(startLine===-1){start=0;}if(endLine===-1){end=source.length;}const lineDiff=endLine-startLine;const markerLines={};if(lineDiff){for(let i=0;i<=lineDiff;i++){const lineNumber=i+startLine;if(!startColumn){markerLines[lineNumber]=true;}else if(i===0){const sourceLength=source[lineNumber-1].length;markerLines[lineNumber]=[startColumn,sourceLength-startColumn+1];}else if(i===lineDiff){markerLines[lineNumber]=[0,endColumn];}else{const sourceLength=source[lineNumber-i].length;markerLines[lineNumber]=[0,sourceLength];}}}else{if(startColumn===endColumn){if(startColumn){markerLines[startLine]=[startColumn,0];}else{markerLines[startLine]=true;}}else{markerLines[startLine]=[startColumn,endColumn-startColumn];}}return{start,end,markerLines};}function codeFrameColumns(rawLines,loc){let opts=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const highlighted=(opts.highlightCode||opts.forceColor)&&(0,_highlight.shouldHighlight)(opts);const chalk=(0,_highlight.getChalk)(opts);const defs=getDefs(chalk);const maybeHighlight=(chalkFn,string)=>{return highlighted?chalkFn(string):string;};const lines=rawLines.split(NEWLINE);const{start,end,markerLines}=getMarkerLines(loc,lines,opts);const hasColumns=loc.start&&typeof loc.start.column===\"number\";const numberMaxWidth=String(end).length;const highlightedLines=highlighted?(0,_highlight.default)(rawLines,opts):rawLines;let frame=highlightedLines.split(NEWLINE).slice(start,end).map((line,index)=>{const number=start+1+index;const paddedNumber=\" \".concat(number).slice(-numberMaxWidth);const gutter=\" \".concat(paddedNumber,\" | \");const hasMarker=markerLines[number];const lastMarkerLine=!markerLines[number+1];if(hasMarker){let markerLine=\"\";if(Array.isArray(hasMarker)){const markerSpacing=line.slice(0,Math.max(hasMarker[0]-1,0)).replace(/[^\\t]/g,\" \");const numberOfMarkers=hasMarker[1]||1;markerLine=[\"\\n \",maybeHighlight(defs.gutter,gutter.replace(/\\d/g,\" \")),markerSpacing,maybeHighlight(defs.marker,\"^\").repeat(numberOfMarkers)].join(\"\");if(lastMarkerLine&&opts.message){markerLine+=\" \"+maybeHighlight(defs.message,opts.message);}}return[maybeHighlight(defs.marker,\">\"),maybeHighlight(defs.gutter,gutter),line,markerLine].join(\"\");}else{return\" \".concat(maybeHighlight(defs.gutter,gutter)).concat(line);}}).join(\"\\n\");if(opts.message&&!hasColumns){frame=\"\".concat(\" \".repeat(numberMaxWidth+1)).concat(opts.message,\"\\n\").concat(frame);}if(highlighted){return chalk.reset(frame);}else{return frame;}}function _default(rawLines,lineNumber,colNumber){let opts=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};if(!deprecationWarningShown){deprecationWarningShown=true;const message=\"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";if(process.emitWarning){process.emitWarning(message,\"DeprecationWarning\");}else{const deprecationError=new Error(message);deprecationError.name=\"DeprecationWarning\";console.warn(new Error(message));}}colNumber=Math.max(colNumber,0);const location={start:{column:colNumber,line:lineNumber}};return codeFrameColumns(rawLines,location,opts);}});unwrapExports(lib$2);var lib_1$1=lib$2.codeFrameColumns;const{ConfigError:ConfigError$1}=errors;const{locStart:locStart$1,locEnd:locEnd$1}=loc;// Use defineProperties()/getOwnPropertyDescriptor() to prevent\n// triggering the parsers getters.\nconst ownNames=Object.getOwnPropertyNames;const ownDescriptor=Object.getOwnPropertyDescriptor;function getParsers(options){const parsers={};for(const plugin of options.plugins){if(!plugin.parsers){continue;}for(const name of ownNames(plugin.parsers)){Object.defineProperty(parsers,name,ownDescriptor(plugin.parsers,name));}}return parsers;}function resolveParser(opts,parsers){parsers=parsers||getParsers(opts);if(typeof opts.parser===\"function\"){// Custom parser API always works with JavaScript.\nreturn{parse:opts.parser,astFormat:\"estree\",locStart:locStart$1,locEnd:locEnd$1};}if(typeof opts.parser===\"string\"){if(Object.prototype.hasOwnProperty.call(parsers,opts.parser)){return parsers[opts.parser];}/* istanbul ignore next */{throw new ConfigError$1(\"Couldn't resolve parser \\\"\".concat(opts.parser,\"\\\". Parsers must be explicitly added to the standalone bundle.\"));}}}function parse(text,opts){const parsers=getParsers(opts);// Create a new object {parserName: parseFn}. Uses defineProperty() to only call\n// the parsers getters when actually calling the parser `parse` function.\nconst parsersForCustomParserApi=Object.keys(parsers).reduce((object,parserName)=>Object.defineProperty(object,parserName,{enumerable:true,get(){return parsers[parserName].parse;}}),{});const parser=resolveParser(opts,parsers);try{if(parser.preprocess){text=parser.preprocess(text,opts);}return{text,ast:parser.parse(text,parsersForCustomParserApi,opts)};}catch(error){const{loc}=error;if(loc){const codeFrame=lib$2;error.codeFrame=codeFrame.codeFrameColumns(text,loc,{highlightCode:true});error.message+=\"\\n\"+error.codeFrame;throw error;}/* istanbul ignore next */throw error.stack;}}var parser={parse,resolveParser};const{UndefinedParserError:UndefinedParserError$1}=errors;const{getSupportInfo:getSupportInfo$1}=support;const{resolveParser:resolveParser$1}=parser;const hiddenDefaults={astFormat:\"estree\",printer:{},originalText:undefined,locStart:null,locEnd:null};// Copy options and fill in default values.\nfunction normalize$1(options,opts){opts=opts||{};const rawOptions=Object.assign({},options);const supportOptions=getSupportInfo$1({plugins:options.plugins,showUnreleased:true,showDeprecated:true}).options;const defaults=Object.assign({},hiddenDefaults,{},fromPairs_1(supportOptions.filter(optionInfo=>optionInfo.default!==undefined).map(option=>[option.name,option.default])));if(!rawOptions.parser){if(!rawOptions.filepath){const logger=opts.logger||console;logger.warn(\"No parser and no filepath given, using 'babel' the parser now \"+\"but this will throw an error in the future. \"+\"Please specify a parser or a filepath so one can be inferred.\");rawOptions.parser=\"babel\";}else{rawOptions.parser=inferParser(rawOptions.filepath,rawOptions.plugins);if(!rawOptions.parser){throw new UndefinedParserError$1(\"No parser could be inferred for file: \".concat(rawOptions.filepath));}}}const parser=resolveParser$1(optionsNormalizer.normalizeApiOptions(rawOptions,[supportOptions.find(x=>x.name===\"parser\")],{passThrough:true,logger:false}));rawOptions.astFormat=parser.astFormat;rawOptions.locEnd=parser.locEnd;rawOptions.locStart=parser.locStart;const plugin=getPlugin(rawOptions);rawOptions.printer=plugin.printers[rawOptions.astFormat];const pluginDefaults=supportOptions.filter(optionInfo=>optionInfo.pluginDefaults&&optionInfo.pluginDefaults[plugin.name]!==undefined).reduce((reduced,optionInfo)=>Object.assign(reduced,{[optionInfo.name]:optionInfo.pluginDefaults[plugin.name]}),{});const mixedDefaults=Object.assign({},defaults,{},pluginDefaults);Object.keys(mixedDefaults).forEach(k=>{if(rawOptions[k]==null){rawOptions[k]=mixedDefaults[k];}});if(rawOptions.parser===\"json\"){rawOptions.trailingComma=\"none\";}return optionsNormalizer.normalizeApiOptions(rawOptions,supportOptions,Object.assign({passThrough:Object.keys(hiddenDefaults)},opts));}function getPlugin(options){const{astFormat}=options;if(!astFormat){throw new Error(\"getPlugin() requires astFormat to be set\");}const printerPlugin=options.plugins.find(plugin=>plugin.printers&&plugin.printers[astFormat]);if(!printerPlugin){throw new Error(\"Couldn't find plugin for AST format \\\"\".concat(astFormat,\"\\\"\"));}return printerPlugin;}function getInterpreter(filepath){if(typeof filepath!==\"string\"){return\"\";}let fd;try{fd=fs.openSync(filepath,\"r\");}catch(err){// istanbul ignore next\nreturn\"\";}try{const liner=new readlines(fd);const firstLine=liner.next().toString(\"utf8\");// #!/bin/env node, #!/usr/bin/env node\nconst m1=firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);if(m1){return m1[1];}// #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node\nconst m2=firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);if(m2){return m2[1];}return\"\";}catch(err){// There are some weird cases where paths are missing, causing Jest\n// failures. It's unclear what these correspond to in the real world.\nreturn\"\";}finally{try{// There are some weird cases where paths are missing, causing Jest\n// failures. It's unclear what these correspond to in the real world.\nfs.closeSync(fd);}catch(err){// nop\n}}}function inferParser(filepath,plugins){const filename=path.basename(filepath).toLowerCase();const languages=getSupportInfo$1({plugins}).languages.filter(language=>language.since!==null);// If the file has no extension, we can try to infer the language from the\n// interpreter in the shebang line, if any; but since this requires FS access,\n// do it last.\nlet language=languages.find(language=>language.extensions&&language.extensions.some(extension=>filename.endsWith(extension))||language.filenames&&language.filenames.find(name=>name.toLowerCase()===filename));if(!language&&!filename.includes(\".\")){const interpreter=getInterpreter(filepath);language=languages.find(language=>language.interpreters&&language.interpreters.includes(interpreter));}return language&&language.parsers[0];}var options$1={normalize:normalize$1,hiddenDefaults,inferParser};function massageAST(ast,options,parent){if(Array.isArray(ast)){return ast.map(e=>massageAST(e,options,parent)).filter(Boolean);}if(!ast||typeof ast!==\"object\"){return ast;}const newObj={};for(const key of Object.keys(ast)){if(typeof ast[key]!==\"function\"){newObj[key]=massageAST(ast[key],options,ast);}}if(options.printer.massageAstNode){const result=options.printer.massageAstNode(ast,newObj,parent);if(result===null){return undefined;}if(result){return result;}}return newObj;}var massageAst=massageAST;function assert(){}assert.ok=function(){};assert.strictEqual=function(){};/**\n   * @param {Doc[]} parts\n   * @returns Doc\n   */function concat(parts){// access the internals of a document directly.\n// if(parts.length === 1) {\n//   // If it's a single document, no need to concat it.\n//   return parts[0];\n// }\nreturn{type:\"concat\",parts};}/**\n   * @param {Doc} contents\n   * @returns Doc\n   */function indent(contents){return{type:\"indent\",contents};}/**\n   * @param {number} n\n   * @param {Doc} contents\n   * @returns Doc\n   */function align(n,contents){return{type:\"align\",contents,n};}/**\n   * @param {Doc} contents\n   * @param {object} [opts] - TBD ???\n   * @returns Doc\n   */function group(contents,opts){opts=opts||{};return{type:\"group\",id:opts.id,contents,break:!!opts.shouldBreak,expandedStates:opts.expandedStates};}/**\n   * @param {Doc} contents\n   * @returns Doc\n   */function dedentToRoot(contents){return align(-Infinity,contents);}/**\n   * @param {Doc} contents\n   * @returns Doc\n   */function markAsRoot(contents){// @ts-ignore - TBD ???:\nreturn align({type:\"root\"},contents);}/**\n   * @param {Doc} contents\n   * @returns Doc\n   */function dedent(contents){return align(-1,contents);}/**\n   * @param {Doc[]} states\n   * @param {object} [opts] - TBD ???\n   * @returns Doc\n   */function conditionalGroup(states,opts){return group(states[0],Object.assign({},opts,{expandedStates:states}));}/**\n   * @param {Doc[]} parts\n   * @returns Doc\n   */function fill(parts){return{type:\"fill\",parts};}/**\n   * @param {Doc} [breakContents]\n   * @param {Doc} [flatContents]\n   * @param {object} [opts] - TBD ???\n   * @returns Doc\n   */function ifBreak(breakContents,flatContents,opts){opts=opts||{};return{type:\"if-break\",breakContents,flatContents,groupId:opts.groupId};}/**\n   * @param {Doc} contents\n   * @returns Doc\n   */function lineSuffix(contents){return{type:\"line-suffix\",contents};}const lineSuffixBoundary={type:\"line-suffix-boundary\"};const breakParent={type:\"break-parent\"};const trim={type:\"trim\"};const line={type:\"line\"};const softline={type:\"line\",soft:true};const hardline=concat([{type:\"line\",hard:true},breakParent]);const literalline=concat([{type:\"line\",hard:true,literal:true},breakParent]);const cursor={type:\"cursor\",placeholder:Symbol(\"cursor\")};/**\n   * @param {Doc} sep\n   * @param {Doc[]} arr\n   * @returns Doc\n   */function join(sep,arr){const res=[];for(let i=0;i<arr.length;i++){if(i!==0){res.push(sep);}res.push(arr[i]);}return concat(res);}/**\n   * @param {Doc} doc\n   * @param {number} size\n   * @param {number} tabWidth\n   */function addAlignmentToDoc(doc,size,tabWidth){let aligned=doc;if(size>0){// Use indent to add tabs for all the levels of tabs we need\nfor(let i=0;i<Math.floor(size/tabWidth);++i){aligned=indent(aligned);}// Use align for all the spaces that are needed\naligned=align(size%tabWidth,aligned);// size is absolute from 0 and not relative to the current\n// indentation, so we use -Infinity to reset the indentation to 0\naligned=align(-Infinity,aligned);}return aligned;}var docBuilders={concat,join,line,softline,hardline,literalline,group,conditionalGroup,fill,lineSuffix,lineSuffixBoundary,cursor,breakParent,ifBreak,trim,indent,align,addAlignmentToDoc,markAsRoot,dedentToRoot,dedent};var ansiRegex=function(){let{onlyFirst=false}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const pattern=['[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)','(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'].join('|');return new RegExp(pattern,onlyFirst?undefined:'g');};var stripAnsi=string=>typeof string==='string'?string.replace(ansiRegex(),''):string;/* eslint-disable yoda */const isFullwidthCodePoint=codePoint=>{if(Number.isNaN(codePoint)){return false;}// Code points are derived from:\n// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\nif(codePoint>=0x1100&&(codePoint<=0x115F||// Hangul Jamo\ncodePoint===0x2329||// LEFT-POINTING ANGLE BRACKET\ncodePoint===0x232A||// RIGHT-POINTING ANGLE BRACKET\n// CJK Radicals Supplement .. Enclosed CJK Letters and Months\n0x2E80<=codePoint&&codePoint<=0x3247&&codePoint!==0x303F||// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n0x3250<=codePoint&&codePoint<=0x4DBF||// CJK Unified Ideographs .. Yi Radicals\n0x4E00<=codePoint&&codePoint<=0xA4C6||// Hangul Jamo Extended-A\n0xA960<=codePoint&&codePoint<=0xA97C||// Hangul Syllables\n0xAC00<=codePoint&&codePoint<=0xD7A3||// CJK Compatibility Ideographs\n0xF900<=codePoint&&codePoint<=0xFAFF||// Vertical Forms\n0xFE10<=codePoint&&codePoint<=0xFE19||// CJK Compatibility Forms .. Small Form Variants\n0xFE30<=codePoint&&codePoint<=0xFE6B||// Halfwidth and Fullwidth Forms\n0xFF01<=codePoint&&codePoint<=0xFF60||0xFFE0<=codePoint&&codePoint<=0xFFE6||// Kana Supplement\n0x1B000<=codePoint&&codePoint<=0x1B001||// Enclosed Ideographic Supplement\n0x1F200<=codePoint&&codePoint<=0x1F251||// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n0x20000<=codePoint&&codePoint<=0x3FFFD)){return true;}return false;};var isFullwidthCodePoint_1=isFullwidthCodePoint;var default_1$1=isFullwidthCodePoint;isFullwidthCodePoint_1.default=default_1$1;var emojiRegex=function emojiRegex(){// https://mths.be/emoji\nreturn /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C\\uDFFB|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83D[\\uDC66\\uDC67]|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)\\uD83C\\uDFFB|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83D\\uDC69(?:\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83C\\uDFF4\\u200D\\u2620)\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDF6\\uD83C\\uDDE6|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDBB\\uDDD2-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;};const stringWidth=string=>{string=string.replace(emojiRegex(),'  ');if(typeof string!=='string'||string.length===0){return 0;}string=stripAnsi(string);let width=0;for(let i=0;i<string.length;i++){const code=string.codePointAt(i);// Ignore control characters\nif(code<=0x1F||code>=0x7F&&code<=0x9F){continue;}// Ignore combining characters\nif(code>=0x300&&code<=0x36F){continue;}// Surrogates\nif(code>0xFFFF){i++;}width+=isFullwidthCodePoint_1(code)?2:1;}return width;};var stringWidth_1=stringWidth;// TODO: remove this in the next major version\nvar default_1$2=stringWidth;stringWidth_1.default=default_1$2;const matchOperatorsRegex=/[|\\\\{}()[\\]^$+*?.-]/g;var escapeStringRegexp$2=string=>{if(typeof string!=='string'){throw new TypeError('Expected a string');}return string.replace(matchOperatorsRegex,'\\\\$&');};const notAsciiRegex=/[^\\x20-\\x7F]/;function getPenultimate(arr){if(arr.length>1){return arr[arr.length-2];}return null;}/**\n   * @typedef {{backwards?: boolean}} SkipOptions\n   */ /**\n   * @param {string | RegExp} chars\n   * @returns {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */function skip(chars){return(text,index,opts)=>{const backwards=opts&&opts.backwards;// Allow `skip` functions to be threaded together without having\n// to check for failures (did someone say monads?).\nif(index===false){return false;}const{length}=text;let cursor=index;while(cursor>=0&&cursor<length){const c=text.charAt(cursor);if(chars instanceof RegExp){if(!chars.test(c)){return cursor;}}else if(!chars.includes(c)){return cursor;}backwards?cursor--:cursor++;}if(cursor===-1||cursor===length){// If we reached the beginning or end of the file, return the\n// out-of-bounds cursor. It's up to the caller to handle this\n// correctly. We don't want to indicate `false` though if it\n// actually skipped valid characters.\nreturn cursor;}return false;};}/**\n   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */const skipWhitespace=skip(/\\s/);/**\n   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */const skipSpaces=skip(\" \\t\");/**\n   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */const skipToLineEnd=skip(\",; \\t\");/**\n   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}\n   */const skipEverythingButNewLine=skip(/[^\\r\\n]/);/**\n   * @param {string} text\n   * @param {number | false} index\n   * @returns {number | false}\n   */function skipInlineComment(text,index){if(index===false){return false;}if(text.charAt(index)===\"/\"&&text.charAt(index+1)===\"*\"){for(let i=index+2;i<text.length;++i){if(text.charAt(i)===\"*\"&&text.charAt(i+1)===\"/\"){return i+2;}}}return index;}/**\n   * @param {string} text\n   * @param {number | false} index\n   * @returns {number | false}\n   */function skipTrailingComment(text,index){if(index===false){return false;}if(text.charAt(index)===\"/\"&&text.charAt(index+1)===\"/\"){return skipEverythingButNewLine(text,index);}return index;}// This one doesn't use the above helper function because it wants to\n// test \\r\\n in order and `skip` doesn't support ordering and we only\n// want to skip one newline. It's simple to implement.\n/**\n   * @param {string} text\n   * @param {number | false} index\n   * @param {SkipOptions=} opts\n   * @returns {number | false}\n   */function skipNewline(text,index,opts){const backwards=opts&&opts.backwards;if(index===false){return false;}const atIndex=text.charAt(index);if(backwards){if(text.charAt(index-1)===\"\\r\"&&atIndex===\"\\n\"){return index-2;}if(atIndex===\"\\n\"||atIndex===\"\\r\"||atIndex===\"\\u2028\"||atIndex===\"\\u2029\"){return index-1;}}else{if(atIndex===\"\\r\"&&text.charAt(index+1)===\"\\n\"){return index+2;}if(atIndex===\"\\n\"||atIndex===\"\\r\"||atIndex===\"\\u2028\"||atIndex===\"\\u2029\"){return index+1;}}return index;}/**\n   * @param {string} text\n   * @param {number} index\n   * @param {SkipOptions=} opts\n   * @returns {boolean}\n   */function hasNewline(text,index,opts){opts=opts||{};const idx=skipSpaces(text,opts.backwards?index-1:index,opts);const idx2=skipNewline(text,idx,opts);return idx!==idx2;}/**\n   * @param {string} text\n   * @param {number} start\n   * @param {number} end\n   * @returns {boolean}\n   */function hasNewlineInRange(text,start,end){for(let i=start;i<end;++i){if(text.charAt(i)===\"\\n\"){return true;}}return false;}// Note: this function doesn't ignore leading comments unlike isNextLineEmpty\n/**\n   * @template N\n   * @param {string} text\n   * @param {N} node\n   * @param {(node: N) => number} locStart\n   */function isPreviousLineEmpty(text,node,locStart){/** @type {number | false} */let idx=locStart(node)-1;idx=skipSpaces(text,idx,{backwards:true});idx=skipNewline(text,idx,{backwards:true});idx=skipSpaces(text,idx,{backwards:true});const idx2=skipNewline(text,idx,{backwards:true});return idx!==idx2;}/**\n   * @param {string} text\n   * @param {number} index\n   * @returns {boolean}\n   */function isNextLineEmptyAfterIndex(text,index){/** @type {number | false} */let oldIdx=null;/** @type {number | false} */let idx=index;while(idx!==oldIdx){// We need to skip all the potential trailing inline comments\noldIdx=idx;idx=skipToLineEnd(text,idx);idx=skipInlineComment(text,idx);idx=skipSpaces(text,idx);}idx=skipTrailingComment(text,idx);idx=skipNewline(text,idx);return idx!==false&&hasNewline(text,idx);}/**\n   * @template N\n   * @param {string} text\n   * @param {N} node\n   * @param {(node: N) => number} locEnd\n   * @returns {boolean}\n   */function isNextLineEmpty(text,node,locEnd){return isNextLineEmptyAfterIndex(text,locEnd(node));}/**\n   * @param {string} text\n   * @param {number} idx\n   * @returns {number | false}\n   */function getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text,idx){/** @type {number | false} */let oldIdx=null;/** @type {number | false} */let nextIdx=idx;while(nextIdx!==oldIdx){oldIdx=nextIdx;nextIdx=skipSpaces(text,nextIdx);nextIdx=skipInlineComment(text,nextIdx);nextIdx=skipTrailingComment(text,nextIdx);nextIdx=skipNewline(text,nextIdx);}return nextIdx;}/**\n   * @template N\n   * @param {string} text\n   * @param {N} node\n   * @param {(node: N) => number} locEnd\n   * @returns {number | false}\n   */function getNextNonSpaceNonCommentCharacterIndex(text,node,locEnd){return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text,locEnd(node));}/**\n   * @template N\n   * @param {string} text\n   * @param {N} node\n   * @param {(node: N) => number} locEnd\n   * @returns {string}\n   */function getNextNonSpaceNonCommentCharacter(text,node,locEnd){return text.charAt(// @ts-ignore => TBD: can return false, should we define a fallback?\ngetNextNonSpaceNonCommentCharacterIndex(text,node,locEnd));}/**\n   * @param {string} text\n   * @param {number} index\n   * @param {SkipOptions=} opts\n   * @returns {boolean}\n   */function hasSpaces(text,index,opts){opts=opts||{};const idx=skipSpaces(text,opts.backwards?index-1:index,opts);return idx!==index;}/**\n   * @param {{range?: [number, number], start?: number}} node\n   * @param {number} index\n   */function setLocStart(node,index){if(node.range){node.range[0]=index;}else{node.start=index;}}/**\n   * @param {{range?: [number, number], end?: number}} node\n   * @param {number} index\n   */function setLocEnd(node,index){if(node.range){node.range[1]=index;}else{node.end=index;}}const PRECEDENCE={};[[\"|>\"],[\"??\"],[\"||\"],[\"&&\"],[\"|\"],[\"^\"],[\"&\"],[\"==\",\"===\",\"!=\",\"!==\"],[\"<\",\">\",\"<=\",\">=\",\"in\",\"instanceof\"],[\">>\",\"<<\",\">>>\"],[\"+\",\"-\"],[\"*\",\"/\",\"%\"],[\"**\"]].forEach((tier,i)=>{tier.forEach(op=>{PRECEDENCE[op]=i;});});function getPrecedence(op){return PRECEDENCE[op];}const equalityOperators={\"==\":true,\"!=\":true,\"===\":true,\"!==\":true};const multiplicativeOperators={\"*\":true,\"/\":true,\"%\":true};const bitshiftOperators={\">>\":true,\">>>\":true,\"<<\":true};function shouldFlatten(parentOp,nodeOp){if(getPrecedence(nodeOp)!==getPrecedence(parentOp)){return false;}// ** is right-associative\n// x ** y ** z --> x ** (y ** z)\nif(parentOp===\"**\"){return false;}// x == y == z --> (x == y) == z\nif(equalityOperators[parentOp]&&equalityOperators[nodeOp]){return false;}// x * y % z --> (x * y) % z\nif(nodeOp===\"%\"&&multiplicativeOperators[parentOp]||parentOp===\"%\"&&multiplicativeOperators[nodeOp]){return false;}// x * y / z --> (x * y) / z\n// x / y * z --> (x / y) * z\nif(nodeOp!==parentOp&&multiplicativeOperators[nodeOp]&&multiplicativeOperators[parentOp]){return false;}// x << y << z --> (x << y) << z\nif(bitshiftOperators[parentOp]&&bitshiftOperators[nodeOp]){return false;}return true;}function isBitwiseOperator(operator){return!!bitshiftOperators[operator]||operator===\"|\"||operator===\"^\"||operator===\"&\";}// Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr\n// holds) `function`, `class`, or `do {}`. Will be overzealous if there's\n// already necessary grouping parentheses.\nfunction startsWithNoLookaheadToken(node,forbidFunctionClassAndDoExpr){node=getLeftMost(node);switch(node.type){case\"FunctionExpression\":case\"ClassExpression\":case\"DoExpression\":return forbidFunctionClassAndDoExpr;case\"ObjectExpression\":return true;case\"MemberExpression\":case\"OptionalMemberExpression\":return startsWithNoLookaheadToken(node.object,forbidFunctionClassAndDoExpr);case\"TaggedTemplateExpression\":if(node.tag.type===\"FunctionExpression\"){// IIFEs are always already parenthesized\nreturn false;}return startsWithNoLookaheadToken(node.tag,forbidFunctionClassAndDoExpr);case\"CallExpression\":case\"OptionalCallExpression\":if(node.callee.type===\"FunctionExpression\"){// IIFEs are always already parenthesized\nreturn false;}return startsWithNoLookaheadToken(node.callee,forbidFunctionClassAndDoExpr);case\"ConditionalExpression\":return startsWithNoLookaheadToken(node.test,forbidFunctionClassAndDoExpr);case\"UpdateExpression\":return!node.prefix&&startsWithNoLookaheadToken(node.argument,forbidFunctionClassAndDoExpr);case\"BindExpression\":return node.object&&startsWithNoLookaheadToken(node.object,forbidFunctionClassAndDoExpr);case\"SequenceExpression\":return startsWithNoLookaheadToken(node.expressions[0],forbidFunctionClassAndDoExpr);case\"TSAsExpression\":return startsWithNoLookaheadToken(node.expression,forbidFunctionClassAndDoExpr);default:return false;}}function getLeftMost(node){if(node.left){return getLeftMost(node.left);}return node;}/**\n   * @param {string} value\n   * @param {number} tabWidth\n   * @param {number=} startIndex\n   * @returns {number}\n   */function getAlignmentSize(value,tabWidth,startIndex){startIndex=startIndex||0;let size=0;for(let i=startIndex;i<value.length;++i){if(value[i]===\"\\t\"){// Tabs behave in a way that they are aligned to the nearest\n// multiple of tabWidth:\n// 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4\n// 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...\nsize=size+tabWidth-size%tabWidth;}else{size++;}}return size;}/**\n   * @param {string} value\n   * @param {number} tabWidth\n   * @returns {number}\n   */function getIndentSize(value,tabWidth){const lastNewlineIndex=value.lastIndexOf(\"\\n\");if(lastNewlineIndex===-1){return 0;}return getAlignmentSize(// All the leading whitespaces\nvalue.slice(lastNewlineIndex+1).match(/^[ \\t]*/)[0],tabWidth);}/**\n   * @typedef {'\"' | \"'\"} Quote\n   */ /**\n   *\n   * @param {string} raw\n   * @param {Quote} preferredQuote\n   * @returns {Quote}\n   */function getPreferredQuote(raw,preferredQuote){// `rawContent` is the string exactly like it appeared in the input source\n// code, without its enclosing quotes.\nconst rawContent=raw.slice(1,-1);/** @type {{ quote: '\"', regex: RegExp }} */const double={quote:'\"',regex:/\"/g};/** @type {{ quote: \"'\", regex: RegExp }} */const single={quote:\"'\",regex:/'/g};const preferred=preferredQuote===\"'\"?single:double;const alternate=preferred===single?double:single;let result=preferred.quote;// If `rawContent` contains at least one of the quote preferred for enclosing\n// the string, we might want to enclose with the alternate quote instead, to\n// minimize the number of escaped quotes.\nif(rawContent.includes(preferred.quote)||rawContent.includes(alternate.quote)){const numPreferredQuotes=(rawContent.match(preferred.regex)||[]).length;const numAlternateQuotes=(rawContent.match(alternate.regex)||[]).length;result=numPreferredQuotes>numAlternateQuotes?alternate.quote:preferred.quote;}return result;}function printString(raw,options,isDirectiveLiteral){// `rawContent` is the string exactly like it appeared in the input source\n// code, without its enclosing quotes.\nconst rawContent=raw.slice(1,-1);// Check for the alternate quote, to determine if we're allowed to swap\n// the quotes on a DirectiveLiteral.\nconst canChangeDirectiveQuotes=!rawContent.includes('\"')&&!rawContent.includes(\"'\");/** @type {Quote} */const enclosingQuote=options.parser===\"json\"?'\"':options.__isInHtmlAttribute?\"'\":getPreferredQuote(raw,options.singleQuote?\"'\":'\"');// Directives are exact code unit sequences, which means that you can't\n// change the escape sequences they use.\n// See https://github.com/prettier/prettier/issues/1555\n// and https://tc39.github.io/ecma262/#directive-prologue\nif(isDirectiveLiteral){if(canChangeDirectiveQuotes){return enclosingQuote+rawContent+enclosingQuote;}return raw;}// It might sound unnecessary to use `makeString` even if the string already\n// is enclosed with `enclosingQuote`, but it isn't. The string could contain\n// unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes\n// sure that we consistently output the minimum amount of escaped quotes.\nreturn makeString(rawContent,enclosingQuote,!(options.parser===\"css\"||options.parser===\"less\"||options.parser===\"scss\"||options.embeddedInHtml));}/**\n   * @param {string} rawContent\n   * @param {Quote} enclosingQuote\n   * @param {boolean=} unescapeUnnecessaryEscapes\n   * @returns {string}\n   */function makeString(rawContent,enclosingQuote,unescapeUnnecessaryEscapes){const otherQuote=enclosingQuote==='\"'?\"'\":'\"';// Matches _any_ escape and unescaped quotes (both single and double).\nconst regex=/\\\\([\\s\\S])|(['\"])/g;// Escape and unescape single and double quotes as needed to be able to\n// enclose `rawContent` with `enclosingQuote`.\nconst newContent=rawContent.replace(regex,(match,escaped,quote)=>{// If we matched an escape, and the escaped character is a quote of the\n// other type than we intend to enclose the string with, there's no need for\n// it to be escaped, so return it _without_ the backslash.\nif(escaped===otherQuote){return escaped;}// If we matched an unescaped quote and it is of the _same_ type as we\n// intend to enclose the string with, it must be escaped, so return it with\n// a backslash.\nif(quote===enclosingQuote){return\"\\\\\"+quote;}if(quote){return quote;}// Unescape any unnecessarily escaped character.\n// Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27\nreturn unescapeUnnecessaryEscapes&&/^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(escaped)?escaped:\"\\\\\"+escaped;});return enclosingQuote+newContent+enclosingQuote;}function printNumber(rawNumber){return rawNumber.toLowerCase()// Remove unnecessary plus and zeroes from scientific notation.\n.replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/,\"$1$2$3\")// Remove unnecessary scientific notation (1e0).\n.replace(/^([+-]?[\\d.]+)e[+-]?0+$/,\"$1\")// Make sure numbers always start with a digit.\n.replace(/^([+-])?\\./,\"$10.\")// Remove extraneous trailing decimal zeroes.\n.replace(/(\\.\\d+?)0+(?=e|$)/,\"$1\")// Remove trailing dot.\n.replace(/\\.(?=e|$)/,\"\");}/**\n   * @param {string} str\n   * @param {string} target\n   * @returns {number}\n   */function getMaxContinuousCount(str,target){const results=str.match(new RegExp(\"(\".concat(escapeStringRegexp$2(target),\")+\"),\"g\"));if(results===null){return 0;}return results.reduce((maxCount,result)=>Math.max(maxCount,result.length/target.length),0);}function getMinNotPresentContinuousCount(str,target){const matches=str.match(new RegExp(\"(\".concat(escapeStringRegexp$2(target),\")+\"),\"g\"));if(matches===null){return 0;}const countPresent=new Map();let max=0;for(const match of matches){const count=match.length/target.length;countPresent.set(count,true);if(count>max){max=count;}}for(let i=1;i<max;i++){if(!countPresent.get(i)){return i;}}return max+1;}/**\n   * @param {string} text\n   * @returns {number}\n   */function getStringWidth(text){if(!text){return 0;}// shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`\nif(!notAsciiRegex.test(text)){return text.length;}return stringWidth_1(text);}function hasIgnoreComment(path){const node=path.getValue();return hasNodeIgnoreComment(node);}function hasNodeIgnoreComment(node){return node&&(node.comments&&node.comments.length>0&&node.comments.some(comment=>isNodeIgnoreComment(comment)&&!comment.unignore)||node.prettierIgnore);}function isNodeIgnoreComment(comment){return comment.value.trim()===\"prettier-ignore\";}function addCommentHelper(node,comment){const comments=node.comments||(node.comments=[]);comments.push(comment);comment.printed=false;// For some reason, TypeScript parses `// x` inside of JSXText as a comment\n// We already \"print\" it via the raw text, we don't need to re-print it as a\n// comment\nif(node.type===\"JSXText\"){comment.printed=true;}}function addLeadingComment(node,comment){comment.leading=true;comment.trailing=false;addCommentHelper(node,comment);}function addDanglingComment(node,comment){comment.leading=false;comment.trailing=false;addCommentHelper(node,comment);}function addTrailingComment(node,comment){comment.leading=false;comment.trailing=true;addCommentHelper(node,comment);}function isWithinParentArrayProperty(path,propertyName){const node=path.getValue();const parent=path.getParentNode();if(parent==null){return false;}if(!Array.isArray(parent[propertyName])){return false;}const key=path.getName();return parent[propertyName][key]===node;}function replaceEndOfLineWith(text,replacement){const parts=[];for(const part of text.split(\"\\n\")){if(parts.length!==0){parts.push(replacement);}parts.push(part);}return parts;}var util$1={replaceEndOfLineWith,getStringWidth,getMaxContinuousCount,getMinNotPresentContinuousCount,getPrecedence,shouldFlatten,isBitwiseOperator,getPenultimate,getLast,getNextNonSpaceNonCommentCharacterIndexWithStartIndex,getNextNonSpaceNonCommentCharacterIndex,getNextNonSpaceNonCommentCharacter,skip,skipWhitespace,skipSpaces,skipToLineEnd,skipEverythingButNewLine,skipInlineComment,skipTrailingComment,skipNewline,isNextLineEmptyAfterIndex,isNextLineEmpty,isPreviousLineEmpty,hasNewline,hasNewlineInRange,hasSpaces,setLocStart,setLocEnd,startsWithNoLookaheadToken,getAlignmentSize,getIndentSize,getPreferredQuote,printString,printNumber,hasIgnoreComment,hasNodeIgnoreComment,isNodeIgnoreComment,makeString,addLeadingComment,addDanglingComment,addTrailingComment,isWithinParentArrayProperty};function guessEndOfLine(text){const index=text.indexOf(\"\\r\");if(index>=0){return text.charAt(index+1)===\"\\n\"?\"crlf\":\"cr\";}return\"lf\";}function convertEndOfLineToChars(value){switch(value){case\"cr\":return\"\\r\";case\"crlf\":return\"\\r\\n\";default:return\"\\n\";}}var endOfLine={guessEndOfLine,convertEndOfLineToChars};const{getStringWidth:getStringWidth$1}=util$1;const{convertEndOfLineToChars:convertEndOfLineToChars$1}=endOfLine;const{concat:concat$1,fill:fill$1,cursor:cursor$1}=docBuilders;/** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */let groupModeMap;const MODE_BREAK=1;const MODE_FLAT=2;function rootIndent(){return{value:\"\",length:0,queue:[]};}function makeIndent(ind,options){return generateInd(ind,{type:\"indent\"},options);}function makeAlign(ind,n,options){return n===-Infinity?ind.root||rootIndent():n<0?generateInd(ind,{type:\"dedent\"},options):!n?ind:n.type===\"root\"?Object.assign({},ind,{root:ind}):typeof n===\"string\"?generateInd(ind,{type:\"stringAlign\",n},options):generateInd(ind,{type:\"numberAlign\",n},options);}function generateInd(ind,newPart,options){const queue=newPart.type===\"dedent\"?ind.queue.slice(0,-1):ind.queue.concat(newPart);let value=\"\";let length=0;let lastTabs=0;let lastSpaces=0;for(const part of queue){switch(part.type){case\"indent\":flush();if(options.useTabs){addTabs(1);}else{addSpaces(options.tabWidth);}break;case\"stringAlign\":flush();value+=part.n;length+=part.n.length;break;case\"numberAlign\":lastTabs+=1;lastSpaces+=part.n;break;/* istanbul ignore next */default:throw new Error(\"Unexpected type '\".concat(part.type,\"'\"));}}flushSpaces();return Object.assign({},ind,{value,length,queue});function addTabs(count){value+=\"\\t\".repeat(count);length+=options.tabWidth*count;}function addSpaces(count){value+=\" \".repeat(count);length+=count;}function flush(){if(options.useTabs){flushTabs();}else{flushSpaces();}}function flushTabs(){if(lastTabs>0){addTabs(lastTabs);}resetLast();}function flushSpaces(){if(lastSpaces>0){addSpaces(lastSpaces);}resetLast();}function resetLast(){lastTabs=0;lastSpaces=0;}}function trim$1(out){if(out.length===0){return 0;}let trimCount=0;// Trim whitespace at the end of line\nwhile(out.length>0&&typeof out[out.length-1]===\"string\"&&out[out.length-1].match(/^[ \\t]*$/)){trimCount+=out.pop().length;}if(out.length&&typeof out[out.length-1]===\"string\"){const trimmed=out[out.length-1].replace(/[ \\t]*$/,\"\");trimCount+=out[out.length-1].length-trimmed.length;out[out.length-1]=trimmed;}return trimCount;}function fits(next,restCommands,width,options,mustBeFlat){let restIdx=restCommands.length;const cmds=[next];// `out` is only used for width counting because `trim` requires to look\n// backwards for space characters.\nconst out=[];while(width>=0){if(cmds.length===0){if(restIdx===0){return true;}cmds.push(restCommands[restIdx-1]);restIdx--;continue;}const[ind,mode,doc]=cmds.pop();if(typeof doc===\"string\"){out.push(doc);width-=getStringWidth$1(doc);}else{switch(doc.type){case\"concat\":for(let i=doc.parts.length-1;i>=0;i--){cmds.push([ind,mode,doc.parts[i]]);}break;case\"indent\":cmds.push([makeIndent(ind,options),mode,doc.contents]);break;case\"align\":cmds.push([makeAlign(ind,doc.n,options),mode,doc.contents]);break;case\"trim\":width+=trim$1(out);break;case\"group\":if(mustBeFlat&&doc.break){return false;}cmds.push([ind,doc.break?MODE_BREAK:mode,doc.contents]);if(doc.id){groupModeMap[doc.id]=cmds[cmds.length-1][1];}break;case\"fill\":for(let i=doc.parts.length-1;i>=0;i--){cmds.push([ind,mode,doc.parts[i]]);}break;case\"if-break\":{const groupMode=doc.groupId?groupModeMap[doc.groupId]:mode;if(groupMode===MODE_BREAK){if(doc.breakContents){cmds.push([ind,mode,doc.breakContents]);}}if(groupMode===MODE_FLAT){if(doc.flatContents){cmds.push([ind,mode,doc.flatContents]);}}break;}case\"line\":switch(mode){// fallthrough\ncase MODE_FLAT:if(!doc.hard){if(!doc.soft){out.push(\" \");width-=1;}break;}return true;case MODE_BREAK:return true;}break;}}}return false;}function printDocToString(doc,options){groupModeMap={};const width=options.printWidth;const newLine=convertEndOfLineToChars$1(options.endOfLine);let pos=0;// cmds is basically a stack. We've turned a recursive call into a\n// while loop which is much faster. The while loop below adds new\n// cmds to the array instead of recursively calling `print`.\nconst cmds=[[rootIndent(),MODE_BREAK,doc]];const out=[];let shouldRemeasure=false;let lineSuffix=[];while(cmds.length!==0){const[ind,mode,doc]=cmds.pop();if(typeof doc===\"string\"){const formatted=newLine!==\"\\n\"&&doc.includes(\"\\n\")?doc.replace(/\\n/g,newLine):doc;out.push(formatted);pos+=getStringWidth$1(formatted);}else{switch(doc.type){case\"cursor\":out.push(cursor$1.placeholder);break;case\"concat\":for(let i=doc.parts.length-1;i>=0;i--){cmds.push([ind,mode,doc.parts[i]]);}break;case\"indent\":cmds.push([makeIndent(ind,options),mode,doc.contents]);break;case\"align\":cmds.push([makeAlign(ind,doc.n,options),mode,doc.contents]);break;case\"trim\":pos-=trim$1(out);break;case\"group\":switch(mode){case MODE_FLAT:if(!shouldRemeasure){cmds.push([ind,doc.break?MODE_BREAK:MODE_FLAT,doc.contents]);break;}// fallthrough\ncase MODE_BREAK:{shouldRemeasure=false;const next=[ind,MODE_FLAT,doc.contents];const rem=width-pos;if(!doc.break&&fits(next,cmds,rem,options)){cmds.push(next);}else{// Expanded states are a rare case where a document\n// can manually provide multiple representations of\n// itself. It provides an array of documents\n// going from the least expanded (most flattened)\n// representation first to the most expanded. If a\n// group has these, we need to manually go through\n// these states and find the first one that fits.\nif(doc.expandedStates){const mostExpanded=doc.expandedStates[doc.expandedStates.length-1];if(doc.break){cmds.push([ind,MODE_BREAK,mostExpanded]);break;}else{for(let i=1;i<doc.expandedStates.length+1;i++){if(i>=doc.expandedStates.length){cmds.push([ind,MODE_BREAK,mostExpanded]);break;}else{const state=doc.expandedStates[i];const cmd=[ind,MODE_FLAT,state];if(fits(cmd,cmds,rem,options)){cmds.push(cmd);break;}}}}}else{cmds.push([ind,MODE_BREAK,doc.contents]);}}break;}}if(doc.id){groupModeMap[doc.id]=cmds[cmds.length-1][1];}break;// Fills each line with as much code as possible before moving to a new\n// line with the same indentation.\n//\n// Expects doc.parts to be an array of alternating content and\n// whitespace. The whitespace contains the linebreaks.\n//\n// For example:\n//   [\"I\", line, \"love\", line, \"monkeys\"]\n// or\n//   [{ type: group, ... }, softline, { type: group, ... }]\n//\n// It uses this parts structure to handle three main layout cases:\n// * The first two content items fit on the same line without\n//   breaking\n//   -> output the first content item and the whitespace \"flat\".\n// * Only the first content item fits on the line without breaking\n//   -> output the first content item \"flat\" and the whitespace with\n//   \"break\".\n// * Neither content item fits on the line without breaking\n//   -> output the first content item and the whitespace with \"break\".\ncase\"fill\":{const rem=width-pos;const{parts}=doc;if(parts.length===0){break;}const[content,whitespace]=parts;const contentFlatCmd=[ind,MODE_FLAT,content];const contentBreakCmd=[ind,MODE_BREAK,content];const contentFits=fits(contentFlatCmd,[],rem,options,true);if(parts.length===1){if(contentFits){cmds.push(contentFlatCmd);}else{cmds.push(contentBreakCmd);}break;}const whitespaceFlatCmd=[ind,MODE_FLAT,whitespace];const whitespaceBreakCmd=[ind,MODE_BREAK,whitespace];if(parts.length===2){if(contentFits){cmds.push(whitespaceFlatCmd);cmds.push(contentFlatCmd);}else{cmds.push(whitespaceBreakCmd);cmds.push(contentBreakCmd);}break;}// At this point we've handled the first pair (context, separator)\n// and will create a new fill doc for the rest of the content.\n// Ideally we wouldn't mutate the array here but copying all the\n// elements to a new array would make this algorithm quadratic,\n// which is unusable for large arrays (e.g. large texts in JSX).\nparts.splice(0,2);const remainingCmd=[ind,mode,fill$1(parts)];const secondContent=parts[0];const firstAndSecondContentFlatCmd=[ind,MODE_FLAT,concat$1([content,whitespace,secondContent])];const firstAndSecondContentFits=fits(firstAndSecondContentFlatCmd,[],rem,options,true);if(firstAndSecondContentFits){cmds.push(remainingCmd);cmds.push(whitespaceFlatCmd);cmds.push(contentFlatCmd);}else if(contentFits){cmds.push(remainingCmd);cmds.push(whitespaceBreakCmd);cmds.push(contentFlatCmd);}else{cmds.push(remainingCmd);cmds.push(whitespaceBreakCmd);cmds.push(contentBreakCmd);}break;}case\"if-break\":{const groupMode=doc.groupId?groupModeMap[doc.groupId]:mode;if(groupMode===MODE_BREAK){if(doc.breakContents){cmds.push([ind,mode,doc.breakContents]);}}if(groupMode===MODE_FLAT){if(doc.flatContents){cmds.push([ind,mode,doc.flatContents]);}}break;}case\"line-suffix\":lineSuffix.push([ind,mode,doc.contents]);break;case\"line-suffix-boundary\":if(lineSuffix.length>0){cmds.push([ind,mode,{type:\"line\",hard:true}]);}break;case\"line\":switch(mode){case MODE_FLAT:if(!doc.hard){if(!doc.soft){out.push(\" \");pos+=1;}break;}else{// This line was forced into the output even if we\n// were in flattened mode, so we need to tell the next\n// group that no matter what, it needs to remeasure\n// because the previous measurement didn't accurately\n// capture the entire expression (this is necessary\n// for nested groups)\nshouldRemeasure=true;}// fallthrough\ncase MODE_BREAK:if(lineSuffix.length){cmds.push([ind,mode,doc]);cmds.push(...lineSuffix.reverse());lineSuffix=[];break;}if(doc.literal){if(ind.root){out.push(newLine,ind.root.value);pos=ind.root.length;}else{out.push(newLine);pos=0;}}else{pos-=trim$1(out);out.push(newLine+ind.value);pos=ind.length;}break;}break;}}}const cursorPlaceholderIndex=out.indexOf(cursor$1.placeholder);if(cursorPlaceholderIndex!==-1){const otherCursorPlaceholderIndex=out.indexOf(cursor$1.placeholder,cursorPlaceholderIndex+1);const beforeCursor=out.slice(0,cursorPlaceholderIndex).join(\"\");const aroundCursor=out.slice(cursorPlaceholderIndex+1,otherCursorPlaceholderIndex).join(\"\");const afterCursor=out.slice(otherCursorPlaceholderIndex+1).join(\"\");return{formatted:beforeCursor+aroundCursor+afterCursor,cursorNodeStart:beforeCursor.length,cursorNodeText:aroundCursor};}return{formatted:out.join(\"\")};}var docPrinter={printDocToString};const traverseDocOnExitStackMarker={};function traverseDoc(doc,onEnter,onExit,shouldTraverseConditionalGroups){const docsStack=[doc];while(docsStack.length!==0){const doc=docsStack.pop();if(doc===traverseDocOnExitStackMarker){onExit(docsStack.pop());continue;}let shouldRecurse=true;if(onEnter){if(onEnter(doc)===false){shouldRecurse=false;}}if(onExit){docsStack.push(doc);docsStack.push(traverseDocOnExitStackMarker);}if(shouldRecurse){// When there are multiple parts to process,\n// the parts need to be pushed onto the stack in reverse order,\n// so that they are processed in the original order\n// when the stack is popped.\nif(doc.type===\"concat\"||doc.type===\"fill\"){for(let ic=doc.parts.length,i=ic-1;i>=0;--i){docsStack.push(doc.parts[i]);}}else if(doc.type===\"if-break\"){if(doc.flatContents){docsStack.push(doc.flatContents);}if(doc.breakContents){docsStack.push(doc.breakContents);}}else if(doc.type===\"group\"&&doc.expandedStates){if(shouldTraverseConditionalGroups){for(let ic=doc.expandedStates.length,i=ic-1;i>=0;--i){docsStack.push(doc.expandedStates[i]);}}else{docsStack.push(doc.contents);}}else if(doc.contents){docsStack.push(doc.contents);}}}}function mapDoc(doc,cb){if(doc.type===\"concat\"||doc.type===\"fill\"){const parts=doc.parts.map(part=>mapDoc(part,cb));return cb(Object.assign({},doc,{parts}));}else if(doc.type===\"if-break\"){const breakContents=doc.breakContents&&mapDoc(doc.breakContents,cb);const flatContents=doc.flatContents&&mapDoc(doc.flatContents,cb);return cb(Object.assign({},doc,{breakContents,flatContents}));}else if(doc.contents){const contents=mapDoc(doc.contents,cb);return cb(Object.assign({},doc,{contents}));}return cb(doc);}function findInDoc(doc,fn,defaultValue){let result=defaultValue;let hasStopped=false;function findInDocOnEnterFn(doc){const maybeResult=fn(doc);if(maybeResult!==undefined){hasStopped=true;result=maybeResult;}if(hasStopped){return false;}}traverseDoc(doc,findInDocOnEnterFn);return result;}function isEmpty(n){return typeof n===\"string\"&&n.length===0;}function isLineNextFn(doc){if(typeof doc===\"string\"){return false;}if(doc.type===\"line\"){return true;}}function isLineNext(doc){return findInDoc(doc,isLineNextFn,false);}function willBreakFn(doc){if(doc.type===\"group\"&&doc.break){return true;}if(doc.type===\"line\"&&doc.hard){return true;}if(doc.type===\"break-parent\"){return true;}}function willBreak(doc){return findInDoc(doc,willBreakFn,false);}function breakParentGroup(groupStack){if(groupStack.length>0){const parentGroup=groupStack[groupStack.length-1];// Breaks are not propagated through conditional groups because\n// the user is expected to manually handle what breaks.\nif(!parentGroup.expandedStates){parentGroup.break=true;}}return null;}function propagateBreaks(doc){const alreadyVisitedSet=new Set();const groupStack=[];function propagateBreaksOnEnterFn(doc){if(doc.type===\"break-parent\"){breakParentGroup(groupStack);}if(doc.type===\"group\"){groupStack.push(doc);if(alreadyVisitedSet.has(doc)){return false;}alreadyVisitedSet.add(doc);}}function propagateBreaksOnExitFn(doc){if(doc.type===\"group\"){const group=groupStack.pop();if(group.break){breakParentGroup(groupStack);}}}traverseDoc(doc,propagateBreaksOnEnterFn,propagateBreaksOnExitFn,/* shouldTraverseConditionalGroups */true);}function removeLinesFn(doc){// Force this doc into flat mode by statically converting all\n// lines into spaces (or soft lines into nothing). Hard lines\n// should still output because there's too great of a chance\n// of breaking existing assumptions otherwise.\nif(doc.type===\"line\"&&!doc.hard){return doc.soft?\"\":\" \";}else if(doc.type===\"if-break\"){return doc.flatContents||\"\";}return doc;}function removeLines(doc){return mapDoc(doc,removeLinesFn);}function stripTrailingHardline(doc){// HACK remove ending hardline, original PR: #1984\nif(doc.type===\"concat\"&&doc.parts.length!==0){const lastPart=doc.parts[doc.parts.length-1];if(lastPart.type===\"concat\"){if(lastPart.parts.length===2&&lastPart.parts[0].hard&&lastPart.parts[1].type===\"break-parent\"){return{type:\"concat\",parts:doc.parts.slice(0,-1)};}return{type:\"concat\",parts:doc.parts.slice(0,-1).concat(stripTrailingHardline(lastPart))};}}return doc;}var docUtils={isEmpty,willBreak,isLineNext,traverseDoc,findInDoc,mapDoc,propagateBreaks,removeLines,stripTrailingHardline};function flattenDoc(doc){if(doc.type===\"concat\"){const res=[];for(let i=0;i<doc.parts.length;++i){const doc2=doc.parts[i];if(typeof doc2!==\"string\"&&doc2.type===\"concat\"){res.push(...flattenDoc(doc2).parts);}else{const flattened=flattenDoc(doc2);if(flattened!==\"\"){res.push(flattened);}}}return Object.assign({},doc,{parts:res});}else if(doc.type===\"if-break\"){return Object.assign({},doc,{breakContents:doc.breakContents!=null?flattenDoc(doc.breakContents):null,flatContents:doc.flatContents!=null?flattenDoc(doc.flatContents):null});}else if(doc.type===\"group\"){return Object.assign({},doc,{contents:flattenDoc(doc.contents),expandedStates:doc.expandedStates?doc.expandedStates.map(flattenDoc):doc.expandedStates});}else if(doc.contents){return Object.assign({},doc,{contents:flattenDoc(doc.contents)});}return doc;}function printDoc(doc){if(typeof doc===\"string\"){return JSON.stringify(doc);}if(doc.type===\"line\"){if(doc.literal){return\"literalline\";}if(doc.hard){return\"hardline\";}if(doc.soft){return\"softline\";}return\"line\";}if(doc.type===\"break-parent\"){return\"breakParent\";}if(doc.type===\"trim\"){return\"trim\";}if(doc.type===\"concat\"){return\"[\"+doc.parts.map(printDoc).join(\", \")+\"]\";}if(doc.type===\"indent\"){return\"indent(\"+printDoc(doc.contents)+\")\";}if(doc.type===\"align\"){return doc.n===-Infinity?\"dedentToRoot(\"+printDoc(doc.contents)+\")\":doc.n<0?\"dedent(\"+printDoc(doc.contents)+\")\":doc.n.type===\"root\"?\"markAsRoot(\"+printDoc(doc.contents)+\")\":\"align(\"+JSON.stringify(doc.n)+\", \"+printDoc(doc.contents)+\")\";}if(doc.type===\"if-break\"){return\"ifBreak(\"+printDoc(doc.breakContents)+(doc.flatContents?\", \"+printDoc(doc.flatContents):\"\")+\")\";}if(doc.type===\"group\"){if(doc.expandedStates){return\"conditionalGroup(\"+\"[\"+doc.expandedStates.map(printDoc).join(\",\")+\"])\";}return(doc.break?\"wrappedGroup\":\"group\")+\"(\"+printDoc(doc.contents)+\")\";}if(doc.type===\"fill\"){return\"fill\"+\"(\"+doc.parts.map(printDoc).join(\", \")+\")\";}if(doc.type===\"line-suffix\"){return\"lineSuffix(\"+printDoc(doc.contents)+\")\";}if(doc.type===\"line-suffix-boundary\"){return\"lineSuffixBoundary\";}throw new Error(\"Unknown doc type \"+doc.type);}var docDebug={printDocToDebug(doc){return printDoc(flattenDoc(doc));}};var document={builders:docBuilders,printer:docPrinter,utils:docUtils,debug:docDebug};const{getMaxContinuousCount:getMaxContinuousCount$1,getStringWidth:getStringWidth$2,getAlignmentSize:getAlignmentSize$1,getIndentSize:getIndentSize$1,skip:skip$1,skipWhitespace:skipWhitespace$1,skipSpaces:skipSpaces$1,skipNewline:skipNewline$1,skipToLineEnd:skipToLineEnd$1,skipEverythingButNewLine:skipEverythingButNewLine$1,skipInlineComment:skipInlineComment$1,skipTrailingComment:skipTrailingComment$1,hasNewline:hasNewline$1,hasNewlineInRange:hasNewlineInRange$1,hasSpaces:hasSpaces$1,isNextLineEmpty:isNextLineEmpty$1,isNextLineEmptyAfterIndex:isNextLineEmptyAfterIndex$1,isPreviousLineEmpty:isPreviousLineEmpty$1,getNextNonSpaceNonCommentCharacterIndex:getNextNonSpaceNonCommentCharacterIndex$1,makeString:makeString$1,addLeadingComment:addLeadingComment$1,addDanglingComment:addDanglingComment$1,addTrailingComment:addTrailingComment$1}=util$1;var utilShared={getMaxContinuousCount:getMaxContinuousCount$1,getStringWidth:getStringWidth$2,getAlignmentSize:getAlignmentSize$1,getIndentSize:getIndentSize$1,skip:skip$1,skipWhitespace:skipWhitespace$1,skipSpaces:skipSpaces$1,skipNewline:skipNewline$1,skipToLineEnd:skipToLineEnd$1,skipEverythingButNewLine:skipEverythingButNewLine$1,skipInlineComment:skipInlineComment$1,skipTrailingComment:skipTrailingComment$1,hasNewline:hasNewline$1,hasNewlineInRange:hasNewlineInRange$1,hasSpaces:hasSpaces$1,isNextLineEmpty:isNextLineEmpty$1,isNextLineEmptyAfterIndex:isNextLineEmptyAfterIndex$1,isPreviousLineEmpty:isPreviousLineEmpty$1,getNextNonSpaceNonCommentCharacterIndex:getNextNonSpaceNonCommentCharacterIndex$1,makeString:makeString$1,addLeadingComment:addLeadingComment$1,addDanglingComment:addDanglingComment$1,addTrailingComment:addTrailingComment$1};const{concat:concat$2,line:line$1,hardline:hardline$1,breakParent:breakParent$1,indent:indent$1,lineSuffix:lineSuffix$1,join:join$1,cursor:cursor$2}=document.builders;const{hasNewline:hasNewline$2,skipNewline:skipNewline$2,isPreviousLineEmpty:isPreviousLineEmpty$2}=util$1;const{addLeadingComment:addLeadingComment$2,addDanglingComment:addDanglingComment$2,addTrailingComment:addTrailingComment$2}=utilShared;const childNodesCacheKey=Symbol(\"child-nodes\");function getSortedChildNodes(node,options,resultArray){if(!node){return;}const{printer,locStart,locEnd}=options;if(resultArray){if(printer.canAttachComment&&printer.canAttachComment(node)){// This reverse insertion sort almost always takes constant\n// time because we almost always (maybe always?) append the\n// nodes in order anyway.\nlet i;for(i=resultArray.length-1;i>=0;--i){if(locStart(resultArray[i])<=locStart(node)&&locEnd(resultArray[i])<=locEnd(node)){break;}}resultArray.splice(i+1,0,node);return;}}else if(node[childNodesCacheKey]){return node[childNodesCacheKey];}const childNodes=printer.getCommentChildNodes&&printer.getCommentChildNodes(node,options)||typeof node===\"object\"&&Object.keys(node).filter(n=>n!==\"enclosingNode\"&&n!==\"precedingNode\"&&n!==\"followingNode\").map(n=>node[n]);if(!childNodes){return;}if(!resultArray){Object.defineProperty(node,childNodesCacheKey,{value:resultArray=[],enumerable:false});}childNodes.forEach(childNode=>{getSortedChildNodes(childNode,options,resultArray);});return resultArray;}// As efficiently as possible, decorate the comment object with\n// .precedingNode, .enclosingNode, and/or .followingNode properties, at\n// least one of which is guaranteed to be defined.\nfunction decorateComment(node,comment,options){const{locStart,locEnd}=options;const childNodes=getSortedChildNodes(node,options);let precedingNode;let followingNode;// Time to dust off the old binary search robes and wizard hat.\nlet left=0;let right=childNodes.length;while(left<right){const middle=left+right>>1;const child=childNodes[middle];if(locStart(child)-locStart(comment)<=0&&locEnd(comment)-locEnd(child)<=0){// The comment is completely contained by this child node.\ncomment.enclosingNode=child;decorateComment(child,comment,options);return;// Abandon the binary search at this level.\n}if(locEnd(child)-locStart(comment)<=0){// This child node falls completely before the comment.\n// Because we will never consider this node or any nodes\n// before it again, this node must be the closest preceding\n// node we have encountered so far.\nprecedingNode=child;left=middle+1;continue;}if(locEnd(comment)-locStart(child)<=0){// This child node falls completely after the comment.\n// Because we will never consider this node or any nodes after\n// it again, this node must be the closest following node we\n// have encountered so far.\nfollowingNode=child;right=middle;continue;}/* istanbul ignore next */throw new Error(\"Comment location overlaps with node location\");}// We don't want comments inside of different expressions inside of the same\n// template literal to move to another expression.\nif(comment.enclosingNode&&comment.enclosingNode.type===\"TemplateLiteral\"){const{quasis}=comment.enclosingNode;const commentIndex=findExpressionIndexForComment(quasis,comment,options);if(precedingNode&&findExpressionIndexForComment(quasis,precedingNode,options)!==commentIndex){precedingNode=null;}if(followingNode&&findExpressionIndexForComment(quasis,followingNode,options)!==commentIndex){followingNode=null;}}if(precedingNode){comment.precedingNode=precedingNode;}if(followingNode){comment.followingNode=followingNode;}}function attach(comments,ast,text,options){if(!Array.isArray(comments)){return;}const tiesToBreak=[];const{locStart,locEnd}=options;comments.forEach((comment,i)=>{if(options.parser===\"json\"||options.parser===\"json5\"||options.parser===\"__js_expression\"||options.parser===\"__vue_expression\"){if(locStart(comment)-locStart(ast)<=0){addLeadingComment$2(ast,comment);return;}if(locEnd(comment)-locEnd(ast)>=0){addTrailingComment$2(ast,comment);return;}}decorateComment(ast,comment,options);const{precedingNode,enclosingNode,followingNode}=comment;const pluginHandleOwnLineComment=options.printer.handleComments&&options.printer.handleComments.ownLine?options.printer.handleComments.ownLine:()=>false;const pluginHandleEndOfLineComment=options.printer.handleComments&&options.printer.handleComments.endOfLine?options.printer.handleComments.endOfLine:()=>false;const pluginHandleRemainingComment=options.printer.handleComments&&options.printer.handleComments.remaining?options.printer.handleComments.remaining:()=>false;const isLastComment=comments.length-1===i;if(hasNewline$2(text,locStart(comment),{backwards:true})){// If a comment exists on its own line, prefer a leading comment.\n// We also need to check if it's the first line of the file.\nif(pluginHandleOwnLineComment(comment,text,options,ast,isLastComment));else if(followingNode){// Always a leading comment.\naddLeadingComment$2(followingNode,comment);}else if(precedingNode){addTrailingComment$2(precedingNode,comment);}else if(enclosingNode){addDanglingComment$2(enclosingNode,comment);}else{// There are no nodes, let's attach it to the root of the ast\n/* istanbul ignore next */addDanglingComment$2(ast,comment);}}else if(hasNewline$2(text,locEnd(comment))){if(pluginHandleEndOfLineComment(comment,text,options,ast,isLastComment));else if(precedingNode){// There is content before this comment on the same line, but\n// none after it, so prefer a trailing comment of the previous node.\naddTrailingComment$2(precedingNode,comment);}else if(followingNode){addLeadingComment$2(followingNode,comment);}else if(enclosingNode){addDanglingComment$2(enclosingNode,comment);}else{// There are no nodes, let's attach it to the root of the ast\n/* istanbul ignore next */addDanglingComment$2(ast,comment);}}else{if(pluginHandleRemainingComment(comment,text,options,ast,isLastComment));else if(precedingNode&&followingNode){// Otherwise, text exists both before and after the comment on\n// the same line. If there is both a preceding and following\n// node, use a tie-breaking algorithm to determine if it should\n// be attached to the next or previous node. In the last case,\n// simply attach the right node;\nconst tieCount=tiesToBreak.length;if(tieCount>0){const lastTie=tiesToBreak[tieCount-1];if(lastTie.followingNode!==comment.followingNode){breakTies(tiesToBreak,text,options);}}tiesToBreak.push(comment);}else if(precedingNode){addTrailingComment$2(precedingNode,comment);}else if(followingNode){addLeadingComment$2(followingNode,comment);}else if(enclosingNode){addDanglingComment$2(enclosingNode,comment);}else{// There are no nodes, let's attach it to the root of the ast\n/* istanbul ignore next */addDanglingComment$2(ast,comment);}}});breakTies(tiesToBreak,text,options);comments.forEach(comment=>{// These node references were useful for breaking ties, but we\n// don't need them anymore, and they create cycles in the AST that\n// may lead to infinite recursion if we don't delete them here.\ndelete comment.precedingNode;delete comment.enclosingNode;delete comment.followingNode;});}function breakTies(tiesToBreak,text,options){const tieCount=tiesToBreak.length;if(tieCount===0){return;}const{precedingNode,followingNode,enclosingNode}=tiesToBreak[0];const gapRegExp=options.printer.getGapRegex&&options.printer.getGapRegex(enclosingNode)||/^[\\s(]*$/;let gapEndPos=options.locStart(followingNode);// Iterate backwards through tiesToBreak, examining the gaps\n// between the tied comments. In order to qualify as leading, a\n// comment must be separated from followingNode by an unbroken series of\n// gaps (or other comments). Gaps should only contain whitespace or open\n// parentheses.\nlet indexOfFirstLeadingComment;for(indexOfFirstLeadingComment=tieCount;indexOfFirstLeadingComment>0;--indexOfFirstLeadingComment){const comment=tiesToBreak[indexOfFirstLeadingComment-1];assert.strictEqual(comment.precedingNode,precedingNode);assert.strictEqual(comment.followingNode,followingNode);const gap=text.slice(options.locEnd(comment),gapEndPos);if(gapRegExp.test(gap)){gapEndPos=options.locStart(comment);}else{// The gap string contained something other than whitespace or open\n// parentheses.\nbreak;}}tiesToBreak.forEach((comment,i)=>{if(i<indexOfFirstLeadingComment){addTrailingComment$2(precedingNode,comment);}else{addLeadingComment$2(followingNode,comment);}});tiesToBreak.length=0;}function printComment(commentPath,options){const comment=commentPath.getValue();comment.printed=true;return options.printer.printComment(commentPath,options);}function findExpressionIndexForComment(quasis,comment,options){const startPos=options.locStart(comment)-1;for(let i=1;i<quasis.length;++i){if(startPos<getQuasiRange(quasis[i]).start){return i-1;}}// We haven't found it, it probably means that some of the locations are off.\n// Let's just return the first one.\n/* istanbul ignore next */return 0;}function getQuasiRange(expr){if(expr.start!==undefined){// Babel\nreturn{start:expr.start,end:expr.end};}// Flow\nreturn{start:expr.range[0],end:expr.range[1]};}function printLeadingComment(commentPath,print,options){const comment=commentPath.getValue();const contents=printComment(commentPath,options);if(!contents){return\"\";}const isBlock=options.printer.isBlockComment&&options.printer.isBlockComment(comment);// Leading block comments should see if they need to stay on the\n// same line or not.\nif(isBlock){const lineBreak=hasNewline$2(options.originalText,options.locEnd(comment))?hasNewline$2(options.originalText,options.locStart(comment),{backwards:true})?hardline$1:line$1:\" \";return concat$2([contents,lineBreak]);}return concat$2([contents,hardline$1]);}function printTrailingComment(commentPath,print,options){const comment=commentPath.getValue();const contents=printComment(commentPath,options);if(!contents){return\"\";}const isBlock=options.printer.isBlockComment&&options.printer.isBlockComment(comment);// We don't want the line to break\n// when the parentParentNode is a ClassDeclaration/-Expression\n// And the parentNode is in the superClass property\nconst parentNode=commentPath.getNode(1);const parentParentNode=commentPath.getNode(2);const isParentSuperClass=parentParentNode&&(parentParentNode.type===\"ClassDeclaration\"||parentParentNode.type===\"ClassExpression\")&&parentParentNode.superClass===parentNode;if(hasNewline$2(options.originalText,options.locStart(comment),{backwards:true})){// This allows comments at the end of nested structures:\n// {\n//   x: 1,\n//   y: 2\n//   // A comment\n// }\n// Those kinds of comments are almost always leading comments, but\n// here it doesn't go \"outside\" the block and turns it into a\n// trailing comment for `2`. We can simulate the above by checking\n// if this a comment on its own line; normal trailing comments are\n// always at the end of another expression.\nconst isLineBeforeEmpty=isPreviousLineEmpty$2(options.originalText,comment,options.locStart);return lineSuffix$1(concat$2([hardline$1,isLineBeforeEmpty?hardline$1:\"\",contents]));}else if(isBlock||isParentSuperClass){// Trailing block comments never need a newline\nreturn concat$2([\" \",contents]);}return concat$2([lineSuffix$1(concat$2([\" \",contents])),!isBlock?breakParent$1:\"\"]);}function printDanglingComments(path,options,sameIndent,filter){const parts=[];const node=path.getValue();if(!node||!node.comments){return\"\";}path.each(commentPath=>{const comment=commentPath.getValue();if(comment&&!comment.leading&&!comment.trailing&&(!filter||filter(comment))){parts.push(printComment(commentPath,options));}},\"comments\");if(parts.length===0){return\"\";}if(sameIndent){return join$1(hardline$1,parts);}return indent$1(concat$2([hardline$1,join$1(hardline$1,parts)]));}function prependCursorPlaceholder(path,options,printed){if(path.getNode()===options.cursorNode&&path.getValue()){return concat$2([cursor$2,printed,cursor$2]);}return printed;}function printComments(path,print,options,needsSemi){const value=path.getValue();const printed=print(path);const comments=value&&value.comments;if(!comments||comments.length===0){return prependCursorPlaceholder(path,options,printed);}const leadingParts=[];const trailingParts=[needsSemi?\";\":\"\",printed];path.each(commentPath=>{const comment=commentPath.getValue();const{leading,trailing}=comment;if(leading){const contents=printLeadingComment(commentPath,print,options);if(!contents){return;}leadingParts.push(contents);const text=options.originalText;const index=skipNewline$2(text,options.locEnd(comment));if(index!==false&&hasNewline$2(text,index)){leadingParts.push(hardline$1);}}else if(trailing){trailingParts.push(printTrailingComment(commentPath,print,options));}},\"comments\");return prependCursorPlaceholder(path,options,concat$2(leadingParts.concat(trailingParts)));}var comments={attach,printComments,printDanglingComments,getSortedChildNodes};function getNodeHelper(path,count){const stackIndex=getNodeStackIndexHelper(path.stack,count);return stackIndex===-1?null:path.stack[stackIndex];}function getNodeStackIndexHelper(stack,count){for(let i=stack.length-1;i>=0;i-=2){const value=stack[i];if(value&&!Array.isArray(value)&&--count<0){return i;}}return-1;}class FastPath{constructor(value){this.stack=[value];}// The name of the current property is always the penultimate element of\n// this.stack, and always a String.\ngetName(){const{stack}=this;const{length}=stack;if(length>1){return stack[length-2];}// Since the name is always a string, null is a safe sentinel value to\n// return if we do not know the name of the (root) value.\n/* istanbul ignore next */return null;}// The value of the current property is always the final element of\n// this.stack.\ngetValue(){return getLast(this.stack);}getNode(){let count=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;return getNodeHelper(this,count);}getParentNode(){let count=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;return getNodeHelper(this,count+1);}// Temporarily push properties named by string arguments given after the\n// callback function onto this.stack, then call the callback with a\n// reference to this (modified) FastPath object. Note that the stack will\n// be restored to its original state after the callback is finished, so it\n// is probably a mistake to retain a reference to the path.\ncall(callback){const{stack}=this;const{length}=stack;let value=getLast(stack);for(var _len9=arguments.length,names=new Array(_len9>1?_len9-1:0),_key10=1;_key10<_len9;_key10++){names[_key10-1]=arguments[_key10];}for(const name of names){value=value[name];stack.push(name,value);}const result=callback(this);stack.length=length;return result;}callParent(callback){let count=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;const stackIndex=getNodeStackIndexHelper(this.stack,count+1);const parentValues=this.stack.splice(stackIndex+1);const result=callback(this);this.stack.push(...parentValues);return result;}// Similar to FastPath.prototype.call, except that the value obtained by\n// accessing this.getValue()[name1][name2]... should be array-like. The\n// callback will be called with a reference to this path object for each\n// element of the array.\neach(callback){const{stack}=this;const{length}=stack;let value=getLast(stack);for(var _len10=arguments.length,names=new Array(_len10>1?_len10-1:0),_key11=1;_key11<_len10;_key11++){names[_key11-1]=arguments[_key11];}for(const name of names){value=value[name];stack.push(name,value);}for(let i=0;i<value.length;++i){if(i in value){stack.push(i,value[i]);// If the callback needs to know the value of i, call\n// path.getName(), assuming path is the parameter name.\ncallback(this);stack.length-=2;}}stack.length=length;}// Similar to FastPath.prototype.each, except that the results of the\n// callback function invocations are stored in an array and returned at\n// the end of the iteration.\nmap(callback){const{stack}=this;const{length}=stack;let value=getLast(stack);for(var _len11=arguments.length,names=new Array(_len11>1?_len11-1:0),_key12=1;_key12<_len11;_key12++){names[_key12-1]=arguments[_key12];}for(const name of names){value=value[name];stack.push(name,value);}const result=new Array(value.length);for(let i=0;i<value.length;++i){if(i in value){stack.push(i,value[i]);result[i]=callback(this,i);stack.length-=2;}}stack.length=length;return result;}/**\n     * @param {...(\n     *   | ((node: any, name: string | null, number: number | null) => boolean)\n     *   | undefined\n     * )} predicates\n     */match(){let stackPointer=this.stack.length-1;let name=null;let node=this.stack[stackPointer--];for(var _len12=arguments.length,predicates=new Array(_len12),_key13=0;_key13<_len12;_key13++){predicates[_key13]=arguments[_key13];}for(const predicate of predicates){if(node===undefined){return false;}// skip index/array\nlet number=null;if(typeof name===\"number\"){number=name;name=this.stack[stackPointer--];node=this.stack[stackPointer--];}if(predicate&&!predicate(node,name,number)){return false;}name=this.stack[stackPointer--];node=this.stack[stackPointer--];}return true;}}var fastPath=FastPath;const{normalize:normalize$2}=options$1;function printSubtree(path,print,options,printAstToDoc){if(options.printer.embed){return options.printer.embed(path,print,(text,partialNextOptions)=>textToDoc(text,partialNextOptions,options,printAstToDoc),options);}}function textToDoc(text,partialNextOptions,parentOptions,printAstToDoc){const nextOptions=normalize$2(Object.assign({},parentOptions,{},partialNextOptions,{parentParser:parentOptions.parser,embeddedInHtml:!!(parentOptions.embeddedInHtml||parentOptions.parser===\"html\"||parentOptions.parser===\"vue\"||parentOptions.parser===\"angular\"||parentOptions.parser===\"lwc\"),originalText:text}),{passThrough:true});const result=parser.parse(text,nextOptions);const{ast}=result;text=result.text;const astComments=ast.comments;delete ast.comments;comments.attach(astComments,ast,text,nextOptions);return printAstToDoc(ast,nextOptions);}var multiparser={printSubtree};const doc=document;const docBuilders$1=doc.builders;const{concat:concat$3,hardline:hardline$2,addAlignmentToDoc:addAlignmentToDoc$1}=docBuilders$1;const docUtils$1=doc.utils;/**\n   * Takes an abstract syntax tree (AST) and recursively converts it to a\n   * document (series of printing primitives).\n   *\n   * This is done by descending down the AST recursively. The recursion\n   * involves two functions that call each other:\n   *\n   * 1. printGenerically(), which is defined as an inner function here.\n   *    It basically takes care of node caching.\n   * 2. callPluginPrintFunction(), which checks for some options, and\n   *    ultimately calls the print() function provided by the plugin.\n   *\n   * The plugin function will call printGenerically() again for child nodes\n   * of the current node, which will do its housekeeping, then call the\n   * plugin function again, and so on.\n   *\n   * All the while, these functions pass a \"path\" variable around, which\n   * is a stack-like data structure (FastPath) that maintains the current\n   * state of the recursion. It is called \"path\", because it represents\n   * the path to the current node through the Abstract Syntax Tree.\n   */function printAstToDoc(ast,options){let alignmentSize=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0;const{printer}=options;if(printer.preprocess){ast=printer.preprocess(ast,options);}const cache=new Map();function printGenerically(path,args){const node=path.getValue();const shouldCache=node&&typeof node===\"object\"&&args===undefined;if(shouldCache&&cache.has(node)){return cache.get(node);}// We let JSXElement print its comments itself because it adds () around\n// UnionTypeAnnotation has to align the child without the comments\nlet res;if(printer.willPrintOwnComments&&printer.willPrintOwnComments(path,options)){res=callPluginPrintFunction(path,options,printGenerically,args);}else{// printComments will call the plugin print function and check for\n// comments to print\nres=comments.printComments(path,p=>callPluginPrintFunction(p,options,printGenerically,args),options,args&&args.needsSemi);}if(shouldCache){cache.set(node,res);}return res;}let doc=printGenerically(new fastPath(ast));if(alignmentSize>0){// Add a hardline to make the indents take effect\n// It should be removed in index.js format()\ndoc=addAlignmentToDoc$1(concat$3([hardline$2,doc]),alignmentSize,options.tabWidth);}docUtils$1.propagateBreaks(doc);return doc;}function callPluginPrintFunction(path,options,printPath,args){assert.ok(path instanceof fastPath);const node=path.getValue();const{printer}=options;// Escape hatch\nif(printer.hasPrettierIgnore&&printer.hasPrettierIgnore(path)){return options.originalText.slice(options.locStart(node),options.locEnd(node));}if(node){try{// Potentially switch to a different parser\nconst sub=multiparser.printSubtree(path,printPath,options,printAstToDoc);if(sub){return sub;}}catch(error){/* istanbul ignore if */if(commonjsGlobal.PRETTIER_DEBUG){throw error;}// Continue with current parser\n}}return printer.print(path,options,printPath,args);}var astToDoc=printAstToDoc;function findSiblingAncestors(startNodeAndParents,endNodeAndParents,opts){let resultStartNode=startNodeAndParents.node;let resultEndNode=endNodeAndParents.node;if(resultStartNode===resultEndNode){return{startNode:resultStartNode,endNode:resultEndNode};}for(const endParent of endNodeAndParents.parentNodes){if(endParent.type!==\"Program\"&&endParent.type!==\"File\"&&opts.locStart(endParent)>=opts.locStart(startNodeAndParents.node)){resultEndNode=endParent;}else{break;}}for(const startParent of startNodeAndParents.parentNodes){if(startParent.type!==\"Program\"&&startParent.type!==\"File\"&&opts.locEnd(startParent)<=opts.locEnd(endNodeAndParents.node)){resultStartNode=startParent;}else{break;}}return{startNode:resultStartNode,endNode:resultEndNode};}function findNodeAtOffset(node,offset,options,predicate,parentNodes){predicate=predicate||(()=>true);parentNodes=parentNodes||[];const start=options.locStart(node,options.locStart);const end=options.locEnd(node,options.locEnd);if(start<=offset&&offset<=end){for(const childNode of comments.getSortedChildNodes(node,options)){const childResult=findNodeAtOffset(childNode,offset,options,predicate,[node].concat(parentNodes));if(childResult){return childResult;}}if(predicate(node)){return{node,parentNodes};}}}// See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5\nfunction isSourceElement(opts,node){if(node==null){return false;}// JS and JS like to avoid repetitions\nconst jsSourceElements=[\"FunctionDeclaration\",\"BlockStatement\",\"BreakStatement\",\"ContinueStatement\",\"DebuggerStatement\",\"DoWhileStatement\",\"EmptyStatement\",\"ExpressionStatement\",\"ForInStatement\",\"ForStatement\",\"IfStatement\",\"LabeledStatement\",\"ReturnStatement\",\"SwitchStatement\",\"ThrowStatement\",\"TryStatement\",\"VariableDeclaration\",\"WhileStatement\",\"WithStatement\",\"ClassDeclaration\",// ES 2015\n\"ImportDeclaration\",// Module\n\"ExportDefaultDeclaration\",// Module\n\"ExportNamedDeclaration\",// Module\n\"ExportAllDeclaration\",// Module\n\"TypeAlias\",// Flow\n\"InterfaceDeclaration\",// Flow, TypeScript\n\"TypeAliasDeclaration\",// TypeScript\n\"ExportAssignment\",// TypeScript\n\"ExportDeclaration\"// TypeScript\n];const jsonSourceElements=[\"ObjectExpression\",\"ArrayExpression\",\"StringLiteral\",\"NumericLiteral\",\"BooleanLiteral\",\"NullLiteral\"];const graphqlSourceElements=[\"OperationDefinition\",\"FragmentDefinition\",\"VariableDefinition\",\"TypeExtensionDefinition\",\"ObjectTypeDefinition\",\"FieldDefinition\",\"DirectiveDefinition\",\"EnumTypeDefinition\",\"EnumValueDefinition\",\"InputValueDefinition\",\"InputObjectTypeDefinition\",\"SchemaDefinition\",\"OperationTypeDefinition\",\"InterfaceTypeDefinition\",\"UnionTypeDefinition\",\"ScalarTypeDefinition\"];switch(opts.parser){case\"flow\":case\"babel\":case\"babel-flow\":case\"babel-ts\":case\"typescript\":return jsSourceElements.includes(node.type);case\"json\":return jsonSourceElements.includes(node.type);case\"graphql\":return graphqlSourceElements.includes(node.kind);case\"vue\":return node.tag!==\"root\";}return false;}function calculateRange(text,opts,ast){// Contract the range so that it has non-whitespace characters at its endpoints.\n// This ensures we can format a range that doesn't end on a node.\nconst rangeStringOrig=text.slice(opts.rangeStart,opts.rangeEnd);const startNonWhitespace=Math.max(opts.rangeStart+rangeStringOrig.search(/\\S/),opts.rangeStart);let endNonWhitespace;for(endNonWhitespace=opts.rangeEnd;endNonWhitespace>opts.rangeStart;--endNonWhitespace){if(text[endNonWhitespace-1].match(/\\S/)){break;}}const startNodeAndParents=findNodeAtOffset(ast,startNonWhitespace,opts,node=>isSourceElement(opts,node));const endNodeAndParents=findNodeAtOffset(ast,endNonWhitespace,opts,node=>isSourceElement(opts,node));if(!startNodeAndParents||!endNodeAndParents){return{rangeStart:0,rangeEnd:0};}const siblingAncestors=findSiblingAncestors(startNodeAndParents,endNodeAndParents,opts);const{startNode,endNode}=siblingAncestors;const rangeStart=Math.min(opts.locStart(startNode,opts.locStart),opts.locStart(endNode,opts.locStart));const rangeEnd=Math.max(opts.locEnd(startNode,opts.locEnd),opts.locEnd(endNode,opts.locEnd));return{rangeStart,rangeEnd};}var rangeUtil={calculateRange,findNodeAtOffset};var diff=getCjsExportFromNamespace(index_es6);const normalizeOptions$1=options$1.normalize;const{guessEndOfLine:guessEndOfLine$1,convertEndOfLineToChars:convertEndOfLineToChars$2}=endOfLine;const{printer:{printDocToString:printDocToString$1},debug:{printDocToDebug}}=document;const BOM=\"\\uFEFF\";const CURSOR=Symbol(\"cursor\");const PLACEHOLDERS={cursorOffset:\"<<<PRETTIER_CURSOR>>>\",rangeStart:\"<<<PRETTIER_RANGE_START>>>\",rangeEnd:\"<<<PRETTIER_RANGE_END>>>\"};function ensureAllCommentsPrinted(astComments){if(!astComments){return;}for(let i=0;i<astComments.length;++i){if(util$1.isNodeIgnoreComment(astComments[i])){// If there's a prettier-ignore, we're not printing that sub-tree so we\n// don't know if the comments was printed or not.\nreturn;}}astComments.forEach(comment=>{if(!comment.printed){throw new Error('Comment \"'+comment.value.trim()+'\" was not printed. Please report this error!');}delete comment.printed;});}function attachComments(text,ast,opts){const astComments=ast.comments;if(astComments){delete ast.comments;comments.attach(astComments,ast,text,opts);}ast.tokens=[];opts.originalText=opts.parser===\"yaml\"?text:text.trimEnd();return astComments;}function coreFormat(text,opts,addAlignmentSize){if(!text||!text.trim().length){return{formatted:\"\",cursorOffset:0};}addAlignmentSize=addAlignmentSize||0;const parsed=parser.parse(text,opts);const{ast}=parsed;text=parsed.text;if(opts.cursorOffset>=0){const nodeResult=rangeUtil.findNodeAtOffset(ast,opts.cursorOffset,opts);if(nodeResult&&nodeResult.node){opts.cursorNode=nodeResult.node;}}const astComments=attachComments(text,ast,opts);const doc=astToDoc(ast,opts,addAlignmentSize);const result=printDocToString$1(doc,opts);ensureAllCommentsPrinted(astComments);// Remove extra leading indentation as well as the added indentation after last newline\nif(addAlignmentSize>0){const trimmed=result.formatted.trim();if(result.cursorNodeStart!==undefined){result.cursorNodeStart-=result.formatted.indexOf(trimmed);}result.formatted=trimmed+convertEndOfLineToChars$2(opts.endOfLine);}if(opts.cursorOffset>=0){let oldCursorNodeStart;let oldCursorNodeText;let cursorOffsetRelativeToOldCursorNode;let newCursorNodeStart;let newCursorNodeText;if(opts.cursorNode&&result.cursorNodeText){oldCursorNodeStart=opts.locStart(opts.cursorNode);oldCursorNodeText=text.slice(oldCursorNodeStart,opts.locEnd(opts.cursorNode));cursorOffsetRelativeToOldCursorNode=opts.cursorOffset-oldCursorNodeStart;newCursorNodeStart=result.cursorNodeStart;newCursorNodeText=result.cursorNodeText;}else{oldCursorNodeStart=0;oldCursorNodeText=text;cursorOffsetRelativeToOldCursorNode=opts.cursorOffset;newCursorNodeStart=0;newCursorNodeText=result.formatted;}if(oldCursorNodeText===newCursorNodeText){return{formatted:result.formatted,cursorOffset:newCursorNodeStart+cursorOffsetRelativeToOldCursorNode};}// diff old and new cursor node texts, with a special cursor\n// symbol inserted to find out where it moves to\nconst oldCursorNodeCharArray=oldCursorNodeText.split(\"\");oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode,0,CURSOR);const newCursorNodeCharArray=newCursorNodeText.split(\"\");const cursorNodeDiff=diff.diffArrays(oldCursorNodeCharArray,newCursorNodeCharArray);let cursorOffset=newCursorNodeStart;for(const entry of cursorNodeDiff){if(entry.removed){if(entry.value.includes(CURSOR)){break;}}else{cursorOffset+=entry.count;}}return{formatted:result.formatted,cursorOffset};}return{formatted:result.formatted};}function formatRange(text,opts){const parsed=parser.parse(text,opts);const{ast}=parsed;text=parsed.text;const range=rangeUtil.calculateRange(text,opts,ast);const{rangeStart,rangeEnd}=range;const rangeString=text.slice(rangeStart,rangeEnd);// Try to extend the range backwards to the beginning of the line.\n// This is so we can detect indentation correctly and restore it.\n// Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\nconst rangeStart2=Math.min(rangeStart,text.lastIndexOf(\"\\n\",rangeStart)+1);const indentString=text.slice(rangeStart2,rangeStart);const alignmentSize=util$1.getAlignmentSize(indentString,opts.tabWidth);const rangeResult=coreFormat(rangeString,Object.assign({},opts,{rangeStart:0,rangeEnd:Infinity,// track the cursor offset only if it's within our range\ncursorOffset:opts.cursorOffset>=rangeStart&&opts.cursorOffset<rangeEnd?opts.cursorOffset-rangeStart:-1}),alignmentSize);// Since the range contracts to avoid trailing whitespace,\n// we need to remove the newline that was inserted by the `format` call.\nconst rangeTrimmed=rangeResult.formatted.trimEnd();const rangeLeft=text.slice(0,rangeStart);const rangeRight=text.slice(rangeEnd);let{cursorOffset}=opts;if(opts.cursorOffset>=rangeEnd){// handle the case where the cursor was past the end of the range\ncursorOffset=opts.cursorOffset-rangeEnd+(rangeStart+rangeTrimmed.length);}else if(rangeResult.cursorOffset!==undefined){// handle the case where the cursor was in the range\ncursorOffset=rangeResult.cursorOffset+rangeStart;}// keep the cursor as it was if it was before the start of the range\nlet formatted;if(opts.endOfLine===\"lf\"){formatted=rangeLeft+rangeTrimmed+rangeRight;}else{const eol=convertEndOfLineToChars$2(opts.endOfLine);if(cursorOffset>=0){const parts=[rangeLeft,rangeTrimmed,rangeRight];let partIndex=0;let partOffset=cursorOffset;while(partIndex<parts.length){const part=parts[partIndex];if(partOffset<part.length){parts[partIndex]=parts[partIndex].slice(0,partOffset)+PLACEHOLDERS.cursorOffset+parts[partIndex].slice(partOffset);break;}partIndex++;partOffset-=part.length;}const[newRangeLeft,newRangeTrimmed,newRangeRight]=parts;formatted=(newRangeLeft.replace(/\\n/g,eol)+newRangeTrimmed+newRangeRight.replace(/\\n/g,eol)).replace(PLACEHOLDERS.cursorOffset,(_,index)=>{cursorOffset=index;return\"\";});}else{formatted=rangeLeft.replace(/\\n/g,eol)+rangeTrimmed+rangeRight.replace(/\\n/g,eol);}}return{formatted,cursorOffset};}function format(text,opts){const selectedParser=parser.resolveParser(opts);const hasPragma=!selectedParser.hasPragma||selectedParser.hasPragma(text);if(opts.requirePragma&&!hasPragma){return{formatted:text};}if(opts.endOfLine===\"auto\"){opts.endOfLine=guessEndOfLine$1(text);}const hasCursor=opts.cursorOffset>=0;const hasRangeStart=opts.rangeStart>0;const hasRangeEnd=opts.rangeEnd<text.length;// get rid of CR/CRLF parsing\nif(text.includes(\"\\r\")){const offsetKeys=[hasCursor&&\"cursorOffset\",hasRangeStart&&\"rangeStart\",hasRangeEnd&&\"rangeEnd\"].filter(Boolean).sort((aKey,bKey)=>opts[aKey]-opts[bKey]);for(let i=offsetKeys.length-1;i>=0;i--){const key=offsetKeys[i];text=text.slice(0,opts[key])+PLACEHOLDERS[key]+text.slice(opts[key]);}text=text.replace(/\\r\\n?/g,\"\\n\");for(let i=0;i<offsetKeys.length;i++){const key=offsetKeys[i];text=text.replace(PLACEHOLDERS[key],(_,index)=>{opts[key]=index;return\"\";});}}const hasUnicodeBOM=text.charAt(0)===BOM;if(hasUnicodeBOM){text=text.slice(1);if(hasCursor){opts.cursorOffset++;}if(hasRangeStart){opts.rangeStart++;}if(hasRangeEnd){opts.rangeEnd++;}}if(!hasCursor){opts.cursorOffset=-1;}if(opts.rangeStart<0){opts.rangeStart=0;}if(opts.rangeEnd>text.length){opts.rangeEnd=text.length;}const result=hasRangeStart||hasRangeEnd?formatRange(text,opts):coreFormat(opts.insertPragma&&opts.printer.insertPragma&&!hasPragma?opts.printer.insertPragma(text):text,opts);if(hasUnicodeBOM){result.formatted=BOM+result.formatted;if(hasCursor){result.cursorOffset++;}}return result;}var core={formatWithCursor(text,opts){opts=normalizeOptions$1(opts);return format(text,opts);},parse(text,opts,massage){opts=normalizeOptions$1(opts);if(text.includes(\"\\r\")){text=text.replace(/\\r\\n?/g,\"\\n\");}const parsed=parser.parse(text,opts);if(massage){parsed.ast=massageAst(parsed.ast,opts);}return parsed;},formatAST(ast,opts){opts=normalizeOptions$1(opts);const doc=astToDoc(ast,opts);return printDocToString$1(doc,opts);},// Doesn't handle shebang for now\nformatDoc(doc,opts){const debug=printDocToDebug(doc);opts=normalizeOptions$1(Object.assign({},opts,{parser:\"babel\"}));return format(debug,opts).formatted;},printToDoc(text,opts){opts=normalizeOptions$1(opts);const parsed=parser.parse(text,opts);const{ast}=parsed;text=parsed.text;attachComments(text,ast,opts);return astToDoc(ast,opts);},printDocToString(doc,opts){return printDocToString$1(doc,normalizeOptions$1(opts));}};function clean(ast,newObj,parent){[\"raw\",// front-matter\n\"raws\",\"sourceIndex\",\"source\",\"before\",\"after\",\"trailingComma\"].forEach(name=>{delete newObj[name];});if(ast.type===\"yaml\"){delete newObj.value;}// --insert-pragma\nif(ast.type===\"css-comment\"&&parent.type===\"css-root\"&&parent.nodes.length!==0&&(// first non-front-matter comment\nparent.nodes[0]===ast||(parent.nodes[0].type===\"yaml\"||parent.nodes[0].type===\"toml\")&&parent.nodes[1]===ast)){/**\n       * something\n       *\n       * @format\n       */delete newObj.text;// standalone pragma\nif(/^\\*\\s*@(format|prettier)\\s*$/.test(ast.text)){return null;}}if(ast.type===\"media-query\"||ast.type===\"media-query-list\"||ast.type===\"media-feature-expression\"){delete newObj.value;}if(ast.type===\"css-rule\"){delete newObj.params;}if(ast.type===\"selector-combinator\"){newObj.value=newObj.value.replace(/\\s+/g,\" \");}if(ast.type===\"media-feature\"){newObj.value=newObj.value.replace(/ /g,\"\");}if(ast.type===\"value-word\"&&(ast.isColor&&ast.isHex||[\"initial\",\"inherit\",\"unset\",\"revert\"].includes(newObj.value.replace().toLowerCase()))||ast.type===\"media-feature\"||ast.type===\"selector-root-invalid\"||ast.type===\"selector-pseudo\"){newObj.value=newObj.value.toLowerCase();}if(ast.type===\"css-decl\"){newObj.prop=newObj.prop.toLowerCase();}if(ast.type===\"css-atrule\"||ast.type===\"css-import\"){newObj.name=newObj.name.toLowerCase();}if(ast.type===\"value-number\"){newObj.unit=newObj.unit.toLowerCase();}if((ast.type===\"media-feature\"||ast.type===\"media-keyword\"||ast.type===\"media-type\"||ast.type===\"media-unknown\"||ast.type===\"media-url\"||ast.type===\"media-value\"||ast.type===\"selector-attribute\"||ast.type===\"selector-string\"||ast.type===\"selector-class\"||ast.type===\"selector-combinator\"||ast.type===\"value-string\")&&newObj.value){newObj.value=cleanCSSStrings(newObj.value);}if(ast.type===\"selector-attribute\"){newObj.attribute=newObj.attribute.trim();if(newObj.namespace){if(typeof newObj.namespace===\"string\"){newObj.namespace=newObj.namespace.trim();if(newObj.namespace.length===0){newObj.namespace=true;}}}if(newObj.value){newObj.value=newObj.value.trim().replace(/^['\"]|['\"]$/g,\"\");delete newObj.quoted;}}if((ast.type===\"media-value\"||ast.type===\"media-type\"||ast.type===\"value-number\"||ast.type===\"selector-root-invalid\"||ast.type===\"selector-class\"||ast.type===\"selector-combinator\"||ast.type===\"selector-tag\")&&newObj.value){newObj.value=newObj.value.replace(/([\\d.eE+-]+)([a-zA-Z]*)/g,(match,numStr,unit)=>{const num=Number(numStr);return isNaN(num)?match:num+unit.toLowerCase();});}if(ast.type===\"selector-tag\"){const lowercasedValue=ast.value.toLowerCase();if([\"from\",\"to\"].includes(lowercasedValue)){newObj.value=lowercasedValue;}}// Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`\nif(ast.type===\"css-atrule\"&&ast.name.toLowerCase()===\"supports\"){delete newObj.value;}// Workaround for SCSS nested properties\nif(ast.type===\"selector-unknown\"){delete newObj.value;}}function cleanCSSStrings(value){return value.replace(/'/g,'\"').replace(/\\\\([^a-fA-F\\d])/g,\"$1\");}var clean_1=clean;const{builders:{hardline:hardline$3,literalline:literalline$1,concat:concat$4,markAsRoot:markAsRoot$1},utils:{mapDoc:mapDoc$1}}=document;function embed(path,print,textToDoc/*, options */){const node=path.getValue();if(node.type===\"yaml\"){return markAsRoot$1(concat$4([\"---\",hardline$3,node.value.trim()?replaceNewlinesWithLiterallines(textToDoc(node.value,{parser:\"yaml\"})):\"\",\"---\",hardline$3]));}return null;function replaceNewlinesWithLiterallines(doc){return mapDoc$1(doc,currentDoc=>typeof currentDoc===\"string\"&&currentDoc.includes(\"\\n\")?concat$4(currentDoc.split(/(\\n)/g).map((v,i)=>i%2===0?v:literalline$1)):currentDoc);}}var embed_1=embed;const detectNewline=string=>{if(typeof string!=='string'){throw new TypeError('Expected a string');}const newlines=string.match(/(?:\\r?\\n)/g)||[];if(newlines.length===0){return;}const crlf=newlines.filter(newline=>newline==='\\r\\n').length;const lf=newlines.length-crlf;return crlf>lf?'\\r\\n':'\\n';};var detectNewline_1=detectNewline;var graceful=string=>typeof string==='string'&&detectNewline(string)||'\\n';detectNewline_1.graceful=graceful;var build=createCommonjsModule(function(module,exports){Object.defineProperty(exports,'__esModule',{value:true});exports.extract=extract;exports.strip=strip;exports.parse=parse;exports.parseWithComments=parseWithComments;exports.print=print;function _os(){const data=require$$0$1;_os=function _os(){return data;};return data;}function _detectNewline(){const data=_interopRequireDefault(detectNewline_1);_detectNewline=function _detectNewline(){return data;};return data;}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}/**\n     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     */const commentEndRe=/\\*\\/$/;const commentStartRe=/^\\/\\*\\*/;const docblockRe=/^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/;const lineCommentRe=/(^|\\s+)\\/\\/([^\\r\\n]*)/g;const ltrimNewlineRe=/^(\\r?\\n)+/;const multilineRe=/(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g;const propertyRe=/(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g;const stringStartRe=/(\\r?\\n|^) *\\* ?/g;function extract(contents){const match=contents.match(docblockRe);return match?match[0].trimLeft():'';}function strip(contents){const match=contents.match(docblockRe);return match&&match[0]?contents.substring(match[0].length):contents;}function parse(docblock){return parseWithComments(docblock).pragmas;}function parseWithComments(docblock){const line=(0,_detectNewline().default)(docblock)||_os().EOL;docblock=docblock.replace(commentStartRe,'').replace(commentEndRe,'').replace(stringStartRe,'$1');// Normalize multi-line directives\nlet prev='';while(prev!==docblock){prev=docblock;docblock=docblock.replace(multilineRe,\"\".concat(line,\"$1 $2\").concat(line));}docblock=docblock.replace(ltrimNewlineRe,'').trimRight();const result=Object.create(null);const comments=docblock.replace(propertyRe,'').replace(ltrimNewlineRe,'').trimRight();let match;while(match=propertyRe.exec(docblock)){// strip linecomments from pragmas\nconst nextPragma=match[2].replace(lineCommentRe,'');if(typeof result[match[1]]==='string'||Array.isArray(result[match[1]])){result[match[1]]=[].concat(result[match[1]],nextPragma);}else{result[match[1]]=nextPragma;}}return{comments,pragmas:result};}function print(_ref15){let{comments='',pragmas={}}=_ref15;const line=(0,_detectNewline().default)(comments)||_os().EOL;const head='/**';const start=' *';const tail=' */';const keys=Object.keys(pragmas);const printedObject=keys.map(key=>printKeyValues(key,pragmas[key])).reduce((arr,next)=>arr.concat(next),[]).map(keyValue=>start+' '+keyValue+line).join('');if(!comments){if(keys.length===0){return'';}if(keys.length===1&&!Array.isArray(pragmas[keys[0]])){const value=pragmas[keys[0]];return\"\".concat(head,\" \").concat(printKeyValues(keys[0],value)[0]).concat(tail);}}const printedComments=comments.split(line).map(textLine=>\"\".concat(start,\" \").concat(textLine)).join(line)+line;return head+line+(comments?printedComments:'')+(comments&&keys.length?start+line:'')+printedObject+tail;}function printKeyValues(key,valueOrArray){return[].concat(valueOrArray).map(value=>\"@\".concat(key,\" \").concat(value).trim());}});unwrapExports(build);var build_1=build.extract;var build_2=build.strip;var build_3=build.parse;var build_4=build.parseWithComments;var build_5=build.print;function hasPragma(text){const pragmas=Object.keys(build.parse(build.extract(text)));return pragmas.includes(\"prettier\")||pragmas.includes(\"format\");}function insertPragma(text){const parsedDocblock=build.parseWithComments(build.extract(text));const pragmas=Object.assign({format:\"\"},parsedDocblock.pragmas);const newDocblock=build.print({pragmas,comments:parsedDocblock.comments.replace(/^(\\s+?\\r?\\n)+/,\"\")// remove leading newlines\n}).replace(/(\\r\\n|\\r)/g,\"\\n\");// normalise newlines (mitigate use of os.EOL by jest-docblock)\nconst strippedText=build.strip(text);const separatingNewlines=strippedText.startsWith(\"\\n\")?\"\\n\":\"\\n\\n\";return newDocblock+separatingNewlines+strippedText;}var pragma={hasPragma,insertPragma};const DELIMITER_MAP={\"---\":\"yaml\",\"+++\":\"toml\"};function parse$1(text){const delimiterRegex=Object.keys(DELIMITER_MAP).map(escapeStringRegexp$2).join(\"|\");const match=text.match(// trailing spaces after delimiters are allowed\nnew RegExp(\"^(\".concat(delimiterRegex,\")[^\\\\n\\\\S]*\\\\n(?:([\\\\s\\\\S]*?)\\\\n)?\\\\1[^\\\\n\\\\S]*(\\\\n|$)\")));if(match===null){return{frontMatter:null,content:text};}const[raw,delimiter,value]=match;return{frontMatter:{type:DELIMITER_MAP[delimiter],value,raw:raw.replace(/\\n$/,\"\")},content:raw.replace(/[^\\n]/g,\" \")+text.slice(raw.length)};}var frontMatter=parse$1;function hasPragma$1(text){return pragma.hasPragma(frontMatter(text).content);}function insertPragma$1(text){const{frontMatter:frontMatter$1,content}=frontMatter(text);return(frontMatter$1?frontMatter$1.raw+\"\\n\\n\":\"\")+pragma.insertPragma(content);}var pragma$1={hasPragma:hasPragma$1,insertPragma:insertPragma$1};var lineColumnToIndex=function lineColumnToIndex(lineColumn,text){let index=0;for(let i=0;i<lineColumn.line-1;++i){index=text.indexOf(\"\\n\",index)+1;if(index===-1){return-1;}}return index+lineColumn.column;};const{getLast:getLast$1,skipEverythingButNewLine:skipEverythingButNewLine$2}=util$1;function calculateLocStart(node,text){if(node.source){return lineColumnToIndex(node.source.start,text)-1;}return null;}function calculateLocEnd(node,text){if(node.type===\"css-comment\"&&node.inline){return skipEverythingButNewLine$2(text,node.source.startOffset);}const endNode=node.nodes&&getLast$1(node.nodes);if(endNode&&node.source&&!node.source.end){node=endNode;}if(node.source&&node.source.end){return lineColumnToIndex(node.source.end,text);}return null;}function calculateLoc(node,text){if(node&&typeof node===\"object\"){if(node.source){node.source.startOffset=calculateLocStart(node,text);node.source.endOffset=calculateLocEnd(node,text);}for(const key in node){calculateLoc(node[key],text);}}}/**\n   * Workaround for a bug: quotes in inline comments corrupt loc data of subsequent nodes.\n   * This function replaces the quotes with U+FFFE and U+FFFF. Later, when the comments are printed,\n   * their content is extracted from the original text or restored by replacing the placeholder\n   * characters back with quotes.\n   * - https://github.com/prettier/prettier/issues/7780\n   * - https://github.com/shellscape/postcss-less/issues/145\n   * - About noncharacters (U+FFFE and U+FFFF): http://www.unicode.org/faq/private_use.html#nonchar1\n   * @param text {string}\n   */function replaceQuotesInInlineComments(text){/** @typedef { 'initial' | 'single-quotes' | 'double-quotes' | 'url' | 'comment-block' | 'comment-inline' } State */ /** @type {State} */let state=\"initial\";/** @type {State} */let stateToReturnFromQuotes=\"initial\";let inlineCommentStartIndex;let inlineCommentContainsQuotes=false;const inlineCommentsToReplace=[];for(let i=0;i<text.length;i++){const c=text[i];switch(state){case\"initial\":if(c===\"'\"){state=\"single-quotes\";continue;}if(c==='\"'){state=\"double-quotes\";continue;}if((c===\"u\"||c===\"U\")&&text.slice(i,i+4).toLowerCase()===\"url(\"){state=\"url\";i+=3;continue;}if(c===\"*\"&&text[i-1]===\"/\"){state=\"comment-block\";continue;}if(c===\"/\"&&text[i-1]===\"/\"){state=\"comment-inline\";inlineCommentStartIndex=i-1;continue;}continue;case\"single-quotes\":if(c===\"'\"&&text[i-1]!==\"\\\\\"){state=stateToReturnFromQuotes;stateToReturnFromQuotes=\"initial\";}if(c===\"\\n\"||c===\"\\r\"){return text;// invalid input\n}continue;case\"double-quotes\":if(c==='\"'&&text[i-1]!==\"\\\\\"){state=stateToReturnFromQuotes;stateToReturnFromQuotes=\"initial\";}if(c===\"\\n\"||c===\"\\r\"){return text;// invalid input\n}continue;case\"url\":if(c===\")\"){state=\"initial\";}if(c===\"\\n\"||c===\"\\r\"){return text;// invalid input\n}if(c===\"'\"){state=\"single-quotes\";stateToReturnFromQuotes=\"url\";continue;}if(c==='\"'){state=\"double-quotes\";stateToReturnFromQuotes=\"url\";continue;}continue;case\"comment-block\":if(c===\"/\"&&text[i-1]===\"*\"){state=\"initial\";}continue;case\"comment-inline\":if(c==='\"'||c===\"'\"){inlineCommentContainsQuotes=true;}if(c===\"\\n\"||c===\"\\r\"){if(inlineCommentContainsQuotes){inlineCommentsToReplace.push([inlineCommentStartIndex,i]);}state=\"initial\";inlineCommentContainsQuotes=false;}continue;}}for(const[start,end]of inlineCommentsToReplace){text=text.slice(0,start)+text.slice(start,end).replace(/'/g,\"\\ufffe\").replace(/\"/g,\"\\uffff\")+text.slice(end);}return text;}function restoreQuotesInInlineComments(text){return text.replace(/\\ufffe/g,\"'\").replace(/\\uffff/g,'\"');}var loc$1={calculateLoc,replaceQuotesInInlineComments,restoreQuotesInInlineComments};const colorAdjusterFunctions=[\"red\",\"green\",\"blue\",\"alpha\",\"a\",\"rgb\",\"hue\",\"h\",\"saturation\",\"s\",\"lightness\",\"l\",\"whiteness\",\"w\",\"blackness\",\"b\",\"tint\",\"shade\",\"blend\",\"blenda\",\"contrast\",\"hsl\",\"hsla\",\"hwb\",\"hwba\"];function getAncestorCounter(path,typeOrTypes){const types=[].concat(typeOrTypes);let counter=-1;let ancestorNode;while(ancestorNode=path.getParentNode(++counter)){if(types.includes(ancestorNode.type)){return counter;}}return-1;}function getAncestorNode(path,typeOrTypes){const counter=getAncestorCounter(path,typeOrTypes);return counter===-1?null:path.getParentNode(counter);}function getPropOfDeclNode(path){const declAncestorNode=getAncestorNode(path,\"css-decl\");return declAncestorNode&&declAncestorNode.prop&&declAncestorNode.prop.toLowerCase();}function isSCSS(parser,text){const hasExplicitParserChoice=parser===\"less\"||parser===\"scss\";const IS_POSSIBLY_SCSS=/(\\w\\s*:\\s*[^}:]+|#){|@import[^\\n]+(?:url|,)/;return hasExplicitParserChoice?parser===\"scss\":IS_POSSIBLY_SCSS.test(text);}function isWideKeywords(value){return[\"initial\",\"inherit\",\"unset\",\"revert\"].includes(value.toLowerCase());}function isKeyframeAtRuleKeywords(path,value){const atRuleAncestorNode=getAncestorNode(path,\"css-atrule\");return atRuleAncestorNode&&atRuleAncestorNode.name&&atRuleAncestorNode.name.toLowerCase().endsWith(\"keyframes\")&&[\"from\",\"to\"].includes(value.toLowerCase());}function maybeToLowerCase(value){return value.includes(\"$\")||value.includes(\"@\")||value.includes(\"#\")||value.startsWith(\"%\")||value.startsWith(\"--\")||value.startsWith(\":--\")||value.includes(\"(\")&&value.includes(\")\")?value:value.toLowerCase();}function insideValueFunctionNode(path,functionName){const funcAncestorNode=getAncestorNode(path,\"value-func\");return funcAncestorNode&&funcAncestorNode.value&&funcAncestorNode.value.toLowerCase()===functionName;}function insideICSSRuleNode(path){const ruleAncestorNode=getAncestorNode(path,\"css-rule\");return ruleAncestorNode&&ruleAncestorNode.raws&&ruleAncestorNode.raws.selector&&(ruleAncestorNode.raws.selector.startsWith(\":import\")||ruleAncestorNode.raws.selector.startsWith(\":export\"));}function insideAtRuleNode(path,atRuleNameOrAtRuleNames){const atRuleNames=[].concat(atRuleNameOrAtRuleNames);const atRuleAncestorNode=getAncestorNode(path,\"css-atrule\");return atRuleAncestorNode&&atRuleNames.includes(atRuleAncestorNode.name.toLowerCase());}function insideURLFunctionInImportAtRuleNode(path){const node=path.getValue();const atRuleAncestorNode=getAncestorNode(path,\"css-atrule\");return atRuleAncestorNode&&atRuleAncestorNode.name===\"import\"&&node.groups[0].value===\"url\"&&node.groups.length===2;}function isURLFunctionNode(node){return node.type===\"value-func\"&&node.value.toLowerCase()===\"url\";}function isLastNode(path,node){const parentNode=path.getParentNode();if(!parentNode){return false;}const{nodes}=parentNode;return nodes&&nodes.indexOf(node)===nodes.length-1;}function isDetachedRulesetDeclarationNode(node){// If a Less file ends up being parsed with the SCSS parser, Less\n// variable declarations will be parsed as atrules with names ending\n// with a colon, so keep the original case then.\nif(!node.selector){return false;}return typeof node.selector===\"string\"&&/^@.+:.*$/.test(node.selector)||node.selector.value&&/^@.+:.*$/.test(node.selector.value);}function isForKeywordNode(node){return node.type===\"value-word\"&&[\"from\",\"through\",\"end\"].includes(node.value);}function isIfElseKeywordNode(node){return node.type===\"value-word\"&&[\"and\",\"or\",\"not\"].includes(node.value);}function isEachKeywordNode(node){return node.type===\"value-word\"&&node.value===\"in\";}function isMultiplicationNode(node){return node.type===\"value-operator\"&&node.value===\"*\";}function isDivisionNode(node){return node.type===\"value-operator\"&&node.value===\"/\";}function isAdditionNode(node){return node.type===\"value-operator\"&&node.value===\"+\";}function isSubtractionNode(node){return node.type===\"value-operator\"&&node.value===\"-\";}function isModuloNode(node){return node.type===\"value-operator\"&&node.value===\"%\";}function isMathOperatorNode(node){return isMultiplicationNode(node)||isDivisionNode(node)||isAdditionNode(node)||isSubtractionNode(node)||isModuloNode(node);}function isEqualityOperatorNode(node){return node.type===\"value-word\"&&[\"==\",\"!=\"].includes(node.value);}function isRelationalOperatorNode(node){return node.type===\"value-word\"&&[\"<\",\">\",\"<=\",\">=\"].includes(node.value);}function isSCSSControlDirectiveNode(node){return node.type===\"css-atrule\"&&[\"if\",\"else\",\"for\",\"each\",\"while\"].includes(node.name);}function isSCSSNestedPropertyNode(node){if(!node.selector){return false;}return node.selector.replace(/\\/\\*.*?\\*\\//,\"\").replace(/\\/\\/.*?\\n/,\"\").trim().endsWith(\":\");}function isDetachedRulesetCallNode(node){return node.raws&&node.raws.params&&/^\\(\\s*\\)$/.test(node.raws.params);}function isTemplatePlaceholderNode(node){return node.name.startsWith(\"prettier-placeholder\");}function isTemplatePropNode(node){return node.prop.startsWith(\"@prettier-placeholder\");}function isPostcssSimpleVarNode(currentNode,nextNode){return currentNode.value===\"$$\"&&currentNode.type===\"value-func\"&&nextNode&&nextNode.type===\"value-word\"&&!nextNode.raws.before;}function hasComposesNode(node){return node.value&&node.value.type===\"value-root\"&&node.value.group&&node.value.group.type===\"value-value\"&&node.prop.toLowerCase()===\"composes\";}function hasParensAroundNode(node){return node.value&&node.value.group&&node.value.group.group&&node.value.group.group.type===\"value-paren_group\"&&node.value.group.group.open!==null&&node.value.group.group.close!==null;}function hasEmptyRawBefore(node){return node.raws&&node.raws.before===\"\";}function isKeyValuePairNode(node){return node.type===\"value-comma_group\"&&node.groups&&node.groups[1]&&node.groups[1].type===\"value-colon\";}function isKeyValuePairInParenGroupNode(node){return node.type===\"value-paren_group\"&&node.groups&&node.groups[0]&&isKeyValuePairNode(node.groups[0]);}function isSCSSMapItemNode(path){const node=path.getValue();// Ignore empty item (i.e. `$key: ()`)\nif(node.groups.length===0){return false;}const parentParentNode=path.getParentNode(1);// Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)\nif(!isKeyValuePairInParenGroupNode(node)&&!(parentParentNode&&isKeyValuePairInParenGroupNode(parentParentNode))){return false;}const declNode=getAncestorNode(path,\"css-decl\");// SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)\nif(declNode&&declNode.prop&&declNode.prop.startsWith(\"$\")){return true;}// List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)\nif(isKeyValuePairInParenGroupNode(parentParentNode)){return true;}// SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)\nif(parentParentNode.type===\"value-func\"){return true;}return false;}function isInlineValueCommentNode(node){return node.type===\"value-comment\"&&node.inline;}function isHashNode(node){return node.type===\"value-word\"&&node.value===\"#\";}function isLeftCurlyBraceNode(node){return node.type===\"value-word\"&&node.value===\"{\";}function isRightCurlyBraceNode(node){return node.type===\"value-word\"&&node.value===\"}\";}function isWordNode(node){return[\"value-word\",\"value-atword\"].includes(node.type);}function isColonNode(node){return node.type===\"value-colon\";}function isMediaAndSupportsKeywords(node){return node.value&&[\"not\",\"and\",\"or\"].includes(node.value.toLowerCase());}function isColorAdjusterFuncNode(node){if(node.type!==\"value-func\"){return false;}return colorAdjusterFunctions.includes(node.value.toLowerCase());}// TODO: only check `less` when we don't use `less` to parse `css`\nfunction isLessParser(options){return options.parser===\"css\"||options.parser===\"less\";}function lastLineHasInlineComment(text){return /\\/\\//.test(text.split(/[\\r\\n]/).pop());}var utils$2={getAncestorCounter,getAncestorNode,getPropOfDeclNode,maybeToLowerCase,insideValueFunctionNode,insideICSSRuleNode,insideAtRuleNode,insideURLFunctionInImportAtRuleNode,isKeyframeAtRuleKeywords,isWideKeywords,isSCSS,isLastNode,isLessParser,isSCSSControlDirectiveNode,isDetachedRulesetDeclarationNode,isRelationalOperatorNode,isEqualityOperatorNode,isMultiplicationNode,isDivisionNode,isAdditionNode,isSubtractionNode,isModuloNode,isMathOperatorNode,isEachKeywordNode,isForKeywordNode,isURLFunctionNode,isIfElseKeywordNode,hasComposesNode,hasParensAroundNode,hasEmptyRawBefore,isSCSSNestedPropertyNode,isDetachedRulesetCallNode,isTemplatePlaceholderNode,isTemplatePropNode,isPostcssSimpleVarNode,isKeyValuePairNode,isKeyValuePairInParenGroupNode,isSCSSMapItemNode,isInlineValueCommentNode,isHashNode,isLeftCurlyBraceNode,isRightCurlyBraceNode,isWordNode,isColonNode,isMediaAndSupportsKeywords,isColorAdjusterFuncNode,lastLineHasInlineComment};const{insertPragma:insertPragma$2}=pragma$1;const{printNumber:printNumber$1,printString:printString$1,hasIgnoreComment:hasIgnoreComment$1,hasNewline:hasNewline$3}=util$1;const{isNextLineEmpty:isNextLineEmpty$2}=utilShared;const{restoreQuotesInInlineComments:restoreQuotesInInlineComments$1}=loc$1;const{builders:{concat:concat$5,join:join$2,line:line$2,hardline:hardline$4,softline:softline$1,group:group$1,fill:fill$2,indent:indent$2,dedent:dedent$1,ifBreak:ifBreak$1},utils:{removeLines:removeLines$1}}=document;const{getAncestorNode:getAncestorNode$1,getPropOfDeclNode:getPropOfDeclNode$1,maybeToLowerCase:maybeToLowerCase$1,insideValueFunctionNode:insideValueFunctionNode$1,insideICSSRuleNode:insideICSSRuleNode$1,insideAtRuleNode:insideAtRuleNode$1,insideURLFunctionInImportAtRuleNode:insideURLFunctionInImportAtRuleNode$1,isKeyframeAtRuleKeywords:isKeyframeAtRuleKeywords$1,isWideKeywords:isWideKeywords$1,isSCSS:isSCSS$1,isLastNode:isLastNode$1,isLessParser:isLessParser$1,isSCSSControlDirectiveNode:isSCSSControlDirectiveNode$1,isDetachedRulesetDeclarationNode:isDetachedRulesetDeclarationNode$1,isRelationalOperatorNode:isRelationalOperatorNode$1,isEqualityOperatorNode:isEqualityOperatorNode$1,isMultiplicationNode:isMultiplicationNode$1,isDivisionNode:isDivisionNode$1,isAdditionNode:isAdditionNode$1,isSubtractionNode:isSubtractionNode$1,isMathOperatorNode:isMathOperatorNode$1,isEachKeywordNode:isEachKeywordNode$1,isForKeywordNode:isForKeywordNode$1,isURLFunctionNode:isURLFunctionNode$1,isIfElseKeywordNode:isIfElseKeywordNode$1,hasComposesNode:hasComposesNode$1,hasParensAroundNode:hasParensAroundNode$1,hasEmptyRawBefore:hasEmptyRawBefore$1,isKeyValuePairNode:isKeyValuePairNode$1,isDetachedRulesetCallNode:isDetachedRulesetCallNode$1,isTemplatePlaceholderNode:isTemplatePlaceholderNode$1,isTemplatePropNode:isTemplatePropNode$1,isPostcssSimpleVarNode:isPostcssSimpleVarNode$1,isSCSSMapItemNode:isSCSSMapItemNode$1,isInlineValueCommentNode:isInlineValueCommentNode$1,isHashNode:isHashNode$1,isLeftCurlyBraceNode:isLeftCurlyBraceNode$1,isRightCurlyBraceNode:isRightCurlyBraceNode$1,isWordNode:isWordNode$1,isColonNode:isColonNode$1,isMediaAndSupportsKeywords:isMediaAndSupportsKeywords$1,isColorAdjusterFuncNode:isColorAdjusterFuncNode$1,lastLineHasInlineComment:lastLineHasInlineComment$1}=utils$2;function shouldPrintComma(options){switch(options.trailingComma){case\"all\":case\"es5\":return true;case\"none\":default:return false;}}function genericPrint(path,options,print){const node=path.getValue();/* istanbul ignore if */if(!node){return\"\";}if(typeof node===\"string\"){return node;}switch(node.type){case\"yaml\":case\"toml\":return concat$5([node.raw,hardline$4]);case\"css-root\":{const nodes=printNodeSequence(path,options,print);if(nodes.parts.length){return concat$5([nodes,options.__isHTMLStyleAttribute?\"\":hardline$4]);}return nodes;}case\"css-comment\":{const isInlineComment=node.inline||node.raws.inline;const text=options.originalText.slice(options.locStart(node),options.locEnd(node));return isInlineComment?text.trimEnd():text;}case\"css-rule\":{return concat$5([path.call(print,\"selector\"),node.important?\" !important\":\"\",node.nodes?concat$5([node.selector&&node.selector.type===\"selector-unknown\"&&lastLineHasInlineComment$1(node.selector.value)?line$2:\" \",\"{\",node.nodes.length>0?indent$2(concat$5([hardline$4,printNodeSequence(path,options,print)])):\"\",hardline$4,\"}\",isDetachedRulesetDeclarationNode$1(node)?\";\":\"\"]):\";\"]);}case\"css-decl\":{const parentNode=path.getParentNode();return concat$5([node.raws.before.replace(/[\\s;]/g,\"\"),insideICSSRuleNode$1(path)?node.prop:maybeToLowerCase$1(node.prop),node.raws.between.trim()===\":\"?\":\":node.raws.between.trim(),node.extend?\"\":\" \",hasComposesNode$1(node)?removeLines$1(path.call(print,\"value\")):path.call(print,\"value\"),node.raws.important?node.raws.important.replace(/\\s*!\\s*important/i,\" !important\"):node.important?\" !important\":\"\",node.raws.scssDefault?node.raws.scssDefault.replace(/\\s*!default/i,\" !default\"):node.scssDefault?\" !default\":\"\",node.raws.scssGlobal?node.raws.scssGlobal.replace(/\\s*!global/i,\" !global\"):node.scssGlobal?\" !global\":\"\",node.nodes?concat$5([\" {\",indent$2(concat$5([softline$1,printNodeSequence(path,options,print)])),softline$1,\"}\"]):isTemplatePropNode$1(node)&&!parentNode.raws.semicolon&&options.originalText[options.locEnd(node)-1]!==\";\"?\"\":\";\"]);}case\"css-atrule\":{const parentNode=path.getParentNode();const isTemplatePlaceholderNodeWithoutSemiColon=isTemplatePlaceholderNode$1(node)&&!parentNode.raws.semicolon&&options.originalText[options.locEnd(node)-1]!==\";\";if(isLessParser$1(options)){if(node.mixin){return concat$5([path.call(print,\"selector\"),node.important?\" !important\":\"\",isTemplatePlaceholderNodeWithoutSemiColon?\"\":\";\"]);}if(node.function){return concat$5([node.name,concat$5([path.call(print,\"params\")]),isTemplatePlaceholderNodeWithoutSemiColon?\"\":\";\"]);}if(node.variable){return concat$5([\"@\",node.name,\": \",node.value?concat$5([path.call(print,\"value\")]):\"\",node.raws.between.trim()?node.raws.between.trim()+\" \":\"\",node.nodes?concat$5([\"{\",indent$2(concat$5([node.nodes.length>0?softline$1:\"\",printNodeSequence(path,options,print)])),softline$1,\"}\"]):\"\",isTemplatePlaceholderNodeWithoutSemiColon?\"\":\";\"]);}}return concat$5([\"@\",// If a Less file ends up being parsed with the SCSS parser, Less\n// variable declarations will be parsed as at-rules with names ending\n// with a colon, so keep the original case then.\nisDetachedRulesetCallNode$1(node)||node.name.endsWith(\":\")?node.name:maybeToLowerCase$1(node.name),node.params?concat$5([isDetachedRulesetCallNode$1(node)?\"\":isTemplatePlaceholderNode$1(node)?node.raws.afterName===\"\"?\"\":node.name.endsWith(\":\")?\" \":/^\\s*\\n\\s*\\n/.test(node.raws.afterName)?concat$5([hardline$4,hardline$4]):/^\\s*\\n/.test(node.raws.afterName)?hardline$4:\" \":\" \",path.call(print,\"params\")]):\"\",node.selector?indent$2(concat$5([\" \",path.call(print,\"selector\")])):\"\",node.value?group$1(concat$5([\" \",path.call(print,\"value\"),isSCSSControlDirectiveNode$1(node)?hasParensAroundNode$1(node)?\" \":line$2:\"\"])):node.name===\"else\"?\" \":\"\",node.nodes?concat$5([isSCSSControlDirectiveNode$1(node)?\"\":\" \",\"{\",indent$2(concat$5([node.nodes.length>0?softline$1:\"\",printNodeSequence(path,options,print)])),softline$1,\"}\"]):isTemplatePlaceholderNodeWithoutSemiColon?\"\":\";\"]);}// postcss-media-query-parser\ncase\"media-query-list\":{const parts=[];path.each(childPath=>{const node=childPath.getValue();if(node.type===\"media-query\"&&node.value===\"\"){return;}parts.push(childPath.call(print));},\"nodes\");return group$1(indent$2(join$2(line$2,parts)));}case\"media-query\":{return concat$5([join$2(\" \",path.map(print,\"nodes\")),isLastNode$1(path,node)?\"\":\",\"]);}case\"media-type\":{return adjustNumbers(adjustStrings(node.value,options));}case\"media-feature-expression\":{if(!node.nodes){return node.value;}return concat$5([\"(\",concat$5(path.map(print,\"nodes\")),\")\"]);}case\"media-feature\":{return maybeToLowerCase$1(adjustStrings(node.value.replace(/ +/g,\" \"),options));}case\"media-colon\":{return concat$5([node.value,\" \"]);}case\"media-value\":{return adjustNumbers(adjustStrings(node.value,options));}case\"media-keyword\":{return adjustStrings(node.value,options);}case\"media-url\":{return adjustStrings(node.value.replace(/^url\\(\\s+/gi,\"url(\").replace(/\\s+\\)$/gi,\")\"),options);}case\"media-unknown\":{return node.value;}// postcss-selector-parser\ncase\"selector-root\":{return group$1(concat$5([insideAtRuleNode$1(path,\"custom-selector\")?concat$5([getAncestorNode$1(path,\"css-atrule\").customSelector,line$2]):\"\",join$2(concat$5([\",\",insideAtRuleNode$1(path,[\"extend\",\"custom-selector\",\"nest\"])?line$2:hardline$4]),path.map(print,\"nodes\"))]));}case\"selector-selector\":{return group$1(indent$2(concat$5(path.map(print,\"nodes\"))));}case\"selector-comment\":{return node.value;}case\"selector-string\":{return adjustStrings(node.value,options);}case\"selector-tag\":{const parentNode=path.getParentNode();const index=parentNode&&parentNode.nodes.indexOf(node);const prevNode=index&&parentNode.nodes[index-1];return concat$5([node.namespace?concat$5([node.namespace===true?\"\":node.namespace.trim(),\"|\"]):\"\",prevNode.type===\"selector-nesting\"?node.value:adjustNumbers(isKeyframeAtRuleKeywords$1(path,node.value)?node.value.toLowerCase():node.value)]);}case\"selector-id\":{return concat$5([\"#\",node.value]);}case\"selector-class\":{return concat$5([\".\",adjustNumbers(adjustStrings(node.value,options))]);}case\"selector-attribute\":{return concat$5([\"[\",node.namespace?concat$5([node.namespace===true?\"\":node.namespace.trim(),\"|\"]):\"\",node.attribute.trim(),node.operator?node.operator:\"\",node.value?quoteAttributeValue(adjustStrings(node.value.trim(),options),options):\"\",node.insensitive?\" i\":\"\",\"]\"]);}case\"selector-combinator\":{if(node.value===\"+\"||node.value===\">\"||node.value===\"~\"||node.value===\">>>\"){const parentNode=path.getParentNode();const leading=parentNode.type===\"selector-selector\"&&parentNode.nodes[0]===node?\"\":line$2;return concat$5([leading,node.value,isLastNode$1(path,node)?\"\":\" \"]);}const leading=node.value.trim().startsWith(\"(\")?line$2:\"\";const value=adjustNumbers(adjustStrings(node.value.trim(),options))||line$2;return concat$5([leading,value]);}case\"selector-universal\":{return concat$5([node.namespace?concat$5([node.namespace===true?\"\":node.namespace.trim(),\"|\"]):\"\",node.value]);}case\"selector-pseudo\":{return concat$5([maybeToLowerCase$1(node.value),node.nodes&&node.nodes.length>0?concat$5([\"(\",join$2(\", \",path.map(print,\"nodes\")),\")\"]):\"\"]);}case\"selector-nesting\":{return node.value;}case\"selector-unknown\":{const ruleAncestorNode=getAncestorNode$1(path,\"css-rule\");// Nested SCSS property\nif(ruleAncestorNode&&ruleAncestorNode.isSCSSNesterProperty){return adjustNumbers(adjustStrings(maybeToLowerCase$1(node.value),options));}// originalText has to be used for Less, see replaceQuotesInInlineComments in loc.js\nconst parentNode=path.getParentNode();if(parentNode.raws&&parentNode.raws.selector){const start=options.locStart(parentNode);const end=start+parentNode.raws.selector.length;return options.originalText.slice(start,end).trim();}return node.value;}// postcss-values-parser\ncase\"value-value\":case\"value-root\":{return path.call(print,\"group\");}case\"value-comment\":{return concat$5([node.inline?\"//\":\"/*\",// see replaceQuotesInInlineComments in loc.js\n// value-* nodes don't have correct location data, so we have to rely on placeholder characters.\nrestoreQuotesInInlineComments$1(node.value),node.inline?\"\":\"*/\"]);}case\"value-comma_group\":{const parentNode=path.getParentNode();const parentParentNode=path.getParentNode(1);const declAncestorProp=getPropOfDeclNode$1(path);const isGridValue=declAncestorProp&&parentNode.type===\"value-value\"&&(declAncestorProp===\"grid\"||declAncestorProp.startsWith(\"grid-template\"));const atRuleAncestorNode=getAncestorNode$1(path,\"css-atrule\");const isControlDirective=atRuleAncestorNode&&isSCSSControlDirectiveNode$1(atRuleAncestorNode);const printed=path.map(print,\"groups\");const parts=[];const insideURLFunction=insideValueFunctionNode$1(path,\"url\");let insideSCSSInterpolationInString=false;let didBreak=false;for(let i=0;i<node.groups.length;++i){parts.push(printed[i]);const iPrevNode=node.groups[i-1];const iNode=node.groups[i];const iNextNode=node.groups[i+1];const iNextNextNode=node.groups[i+2];if(insideURLFunction){if(iNextNode&&isAdditionNode$1(iNextNode)||isAdditionNode$1(iNode)){parts.push(\" \");}continue;}// Ignore after latest node (i.e. before semicolon)\nif(!iNextNode){continue;}// styled.div` background: var(--${one}); `\nif(!iPrevNode&&iNode.value===\"--\"&&iNextNode.type===\"value-atword\"){continue;}// Ignore spaces before/after string interpolation (i.e. `\"#{my-fn(\"_\")}\"`)\nconst isStartSCSSInterpolationInString=iNode.type===\"value-string\"&&iNode.value.startsWith(\"#{\");const isEndingSCSSInterpolationInString=insideSCSSInterpolationInString&&iNextNode.type===\"value-string\"&&iNextNode.value.endsWith(\"}\");if(isStartSCSSInterpolationInString||isEndingSCSSInterpolationInString){insideSCSSInterpolationInString=!insideSCSSInterpolationInString;continue;}if(insideSCSSInterpolationInString){continue;}// Ignore colon (i.e. `:`)\nif(isColonNode$1(iNode)||isColonNode$1(iNextNode)){continue;}// Ignore `@` in Less (i.e. `@@var;`)\nif(iNode.type===\"value-atword\"&&iNode.value===\"\"){continue;}// Ignore `~` in Less (i.e. `content: ~\"^//* some horrible but needed css hack\";`)\nif(iNode.value===\"~\"){continue;}// Ignore escape `\\`\nif(iNode.value&&iNode.value.includes(\"\\\\\")&&iNextNode&&iNextNode.type!==\"value-comment\"){continue;}// Ignore escaped `/`\nif(iPrevNode&&iPrevNode.value&&iPrevNode.value.indexOf(\"\\\\\")===iPrevNode.value.length-1&&iNode.type===\"value-operator\"&&iNode.value===\"/\"){continue;}// Ignore `\\` (i.e. `$variable: \\@small;`)\nif(iNode.value===\"\\\\\"){continue;}// Ignore `$$` (i.e. `background-color: $$(style)Color;`)\nif(isPostcssSimpleVarNode$1(iNode,iNextNode)){continue;}// Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)\nif(isHashNode$1(iNode)||isLeftCurlyBraceNode$1(iNode)||isRightCurlyBraceNode$1(iNextNode)||isLeftCurlyBraceNode$1(iNextNode)&&hasEmptyRawBefore$1(iNextNode)||isRightCurlyBraceNode$1(iNode)&&hasEmptyRawBefore$1(iNextNode)){continue;}// Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)\nif(iNode.value===\"--\"&&isHashNode$1(iNextNode)){continue;}// Formatting math operations\nconst isMathOperator=isMathOperatorNode$1(iNode);const isNextMathOperator=isMathOperatorNode$1(iNextNode);// Print spaces before and after math operators beside SCSS interpolation as is\n// (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)\n// (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)\nif((isMathOperator&&isHashNode$1(iNextNode)||isNextMathOperator&&isRightCurlyBraceNode$1(iNode))&&hasEmptyRawBefore$1(iNextNode)){continue;}// Print spaces before and after addition and subtraction math operators as is in `calc` function\n// due to the fact that it is not valid syntax\n// (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)\nif(insideValueFunctionNode$1(path,\"calc\")&&(isAdditionNode$1(iNode)||isAdditionNode$1(iNextNode)||isSubtractionNode$1(iNode)||isSubtractionNode$1(iNextNode))&&hasEmptyRawBefore$1(iNextNode)){continue;}// Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)\n// Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.\nconst isColorAdjusterNode=(isAdditionNode$1(iNode)||isSubtractionNode$1(iNode))&&i===0&&(iNextNode.type===\"value-number\"||iNextNode.isHex)&&parentParentNode&&isColorAdjusterFuncNode$1(parentParentNode)&&!hasEmptyRawBefore$1(iNextNode);const requireSpaceBeforeOperator=iNextNextNode&&iNextNextNode.type===\"value-func\"||iNextNextNode&&isWordNode$1(iNextNextNode)||iNode.type===\"value-func\"||isWordNode$1(iNode);const requireSpaceAfterOperator=iNextNode.type===\"value-func\"||isWordNode$1(iNextNode)||iPrevNode&&iPrevNode.type===\"value-func\"||iPrevNode&&isWordNode$1(iPrevNode);// Formatting `/`, `+`, `-` sign\nif(!(isMultiplicationNode$1(iNextNode)||isMultiplicationNode$1(iNode))&&!insideValueFunctionNode$1(path,\"calc\")&&!isColorAdjusterNode&&(isDivisionNode$1(iNextNode)&&!requireSpaceBeforeOperator||isDivisionNode$1(iNode)&&!requireSpaceAfterOperator||isAdditionNode$1(iNextNode)&&!requireSpaceBeforeOperator||isAdditionNode$1(iNode)&&!requireSpaceAfterOperator||isSubtractionNode$1(iNextNode)||isSubtractionNode$1(iNode))&&(hasEmptyRawBefore$1(iNextNode)||isMathOperator&&(!iPrevNode||iPrevNode&&isMathOperatorNode$1(iPrevNode)))){continue;}// Add `hardline` after inline comment (i.e. `// comment\\n foo: bar;`)\nif(isInlineValueCommentNode$1(iNode)){parts.push(hardline$4);continue;}// Handle keywords in SCSS control directive\nif(isControlDirective&&(isEqualityOperatorNode$1(iNextNode)||isRelationalOperatorNode$1(iNextNode)||isIfElseKeywordNode$1(iNextNode)||isEachKeywordNode$1(iNode)||isForKeywordNode$1(iNode))){parts.push(\" \");continue;}// At-rule `namespace` should be in one line\nif(atRuleAncestorNode&&atRuleAncestorNode.name.toLowerCase()===\"namespace\"){parts.push(\" \");continue;}// Formatting `grid` property\nif(isGridValue){if(iNode.source&&iNextNode.source&&iNode.source.start.line!==iNextNode.source.start.line){parts.push(hardline$4);didBreak=true;}else{parts.push(\" \");}continue;}// Add `space` before next math operation\n// Note: `grip` property have `/` delimiter and it is not math operation, so\n// `grid` property handles above\nif(isNextMathOperator){parts.push(\" \");continue;}// Be default all values go through `line`\nparts.push(line$2);}if(didBreak){parts.unshift(hardline$4);}if(isControlDirective){return group$1(indent$2(concat$5(parts)));}// Indent is not needed for import url when url is very long\n// and node has two groups\n// when type is value-comma_group\n// example @import url(\"verylongurl\") projection,tv\nif(insideURLFunctionInImportAtRuleNode$1(path)){return group$1(fill$2(parts));}return group$1(indent$2(fill$2(parts)));}case\"value-paren_group\":{const parentNode=path.getParentNode();if(parentNode&&isURLFunctionNode$1(parentNode)&&(node.groups.length===1||node.groups.length>0&&node.groups[0].type===\"value-comma_group\"&&node.groups[0].groups.length>0&&node.groups[0].groups[0].type===\"value-word\"&&node.groups[0].groups[0].value.startsWith(\"data:\"))){return concat$5([node.open?path.call(print,\"open\"):\"\",join$2(\",\",path.map(print,\"groups\")),node.close?path.call(print,\"close\"):\"\"]);}if(!node.open){const printed=path.map(print,\"groups\");const res=[];for(let i=0;i<printed.length;i++){if(i!==0){res.push(concat$5([\",\",line$2]));}res.push(printed[i]);}return group$1(indent$2(fill$2(res)));}const isSCSSMapItem=isSCSSMapItemNode$1(path);const lastItem=node.groups[node.groups.length-1];const isLastItemComment=lastItem&&lastItem.type===\"value-comment\";return group$1(concat$5([node.open?path.call(print,\"open\"):\"\",indent$2(concat$5([softline$1,join$2(concat$5([\",\",line$2]),path.map(childPath=>{const node=childPath.getValue();const printed=print(childPath);// Key/Value pair in open paren already indented\nif(isKeyValuePairNode$1(node)&&node.type===\"value-comma_group\"&&node.groups&&node.groups[2]&&node.groups[2].type===\"value-paren_group\"){printed.contents.contents.parts[1]=group$1(printed.contents.contents.parts[1]);return group$1(dedent$1(printed));}return printed;},\"groups\"))])),ifBreak$1(!isLastItemComment&&isSCSS$1(options.parser,options.originalText)&&isSCSSMapItem&&shouldPrintComma(options)?\",\":\"\"),softline$1,node.close?path.call(print,\"close\"):\"\"]),{shouldBreak:isSCSSMapItem});}case\"value-func\":{return concat$5([node.value,insideAtRuleNode$1(path,\"supports\")&&isMediaAndSupportsKeywords$1(node)?\" \":\"\",path.call(print,\"group\")]);}case\"value-paren\":{return node.value;}case\"value-number\":{return concat$5([printCssNumber(node.value),maybeToLowerCase$1(node.unit)]);}case\"value-operator\":{return node.value;}case\"value-word\":{if(node.isColor&&node.isHex||isWideKeywords$1(node.value)){return node.value.toLowerCase();}return node.value;}case\"value-colon\":{return concat$5([node.value,// Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)\ninsideValueFunctionNode$1(path,\"url\")?\"\":line$2]);}case\"value-comma\":{return concat$5([node.value,\" \"]);}case\"value-string\":{return printString$1(node.raws.quote+node.value+node.raws.quote,options);}case\"value-atword\":{return concat$5([\"@\",node.value]);}case\"value-unicode-range\":{return node.value;}case\"value-unknown\":{return node.value;}default:/* istanbul ignore next */throw new Error(\"Unknown postcss type \".concat(JSON.stringify(node.type)));}}function printNodeSequence(path,options,print){const node=path.getValue();const parts=[];let i=0;path.map(pathChild=>{const prevNode=node.nodes[i-1];if(prevNode&&prevNode.type===\"css-comment\"&&prevNode.text.trim()===\"prettier-ignore\"){const childNode=pathChild.getValue();parts.push(options.originalText.slice(options.locStart(childNode),options.locEnd(childNode)));}else{parts.push(pathChild.call(print));}if(i!==node.nodes.length-1){if(node.nodes[i+1].type===\"css-comment\"&&!hasNewline$3(options.originalText,options.locStart(node.nodes[i+1]),{backwards:true})&&node.nodes[i].type!==\"yaml\"&&node.nodes[i].type!==\"toml\"||node.nodes[i+1].type===\"css-atrule\"&&node.nodes[i+1].name===\"else\"&&node.nodes[i].type!==\"css-comment\"){parts.push(\" \");}else{parts.push(options.__isHTMLStyleAttribute?line$2:hardline$4);if(isNextLineEmpty$2(options.originalText,pathChild.getValue(),options.locEnd)&&node.nodes[i].type!==\"yaml\"&&node.nodes[i].type!==\"toml\"){parts.push(hardline$4);}}}i++;},\"nodes\");return concat$5(parts);}const STRING_REGEX$3=/(['\"])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/g;const NUMBER_REGEX=/(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g;const STANDARD_UNIT_REGEX=/[a-zA-Z]+/g;const WORD_PART_REGEX=/[$@]?[a-zA-Z_\\u0080-\\uFFFF][\\w\\-\\u0080-\\uFFFF]*/g;const ADJUST_NUMBERS_REGEX=new RegExp(STRING_REGEX$3.source+\"|\"+\"(\".concat(WORD_PART_REGEX.source,\")?\")+\"(\".concat(NUMBER_REGEX.source,\")\")+\"(\".concat(STANDARD_UNIT_REGEX.source,\")?\"),\"g\");function adjustStrings(value,options){return value.replace(STRING_REGEX$3,match=>printString$1(match,options));}function quoteAttributeValue(value,options){const quote=options.singleQuote?\"'\":'\"';return value.includes('\"')||value.includes(\"'\")?value:quote+value+quote;}function adjustNumbers(value){return value.replace(ADJUST_NUMBERS_REGEX,(match,quote,wordPart,number,unit)=>!wordPart&&number?printCssNumber(number)+maybeToLowerCase$1(unit||\"\"):match);}function printCssNumber(rawNumber){return printNumber$1(rawNumber)// Remove trailing `.0`.\n.replace(/\\.0(?=$|e)/,\"\");}var printerPostcss={print:genericPrint,embed:embed_1,insertPragma:insertPragma$2,hasPrettierIgnore:hasIgnoreComment$1,massageAstNode:clean_1};const CATEGORY_COMMON=\"Common\";// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\nvar commonOptions={bracketSpacing:{since:\"0.0.0\",category:CATEGORY_COMMON,type:\"boolean\",default:true,description:\"Print spaces between brackets.\",oppositeDescription:\"Do not print spaces between brackets.\"},singleQuote:{since:\"0.0.0\",category:CATEGORY_COMMON,type:\"boolean\",default:false,description:\"Use single quotes instead of double quotes.\"},proseWrap:{since:\"1.8.2\",category:CATEGORY_COMMON,type:\"choice\",default:[{since:\"1.8.2\",value:true},{since:\"1.9.0\",value:\"preserve\"}],description:\"How to wrap prose.\",choices:[{since:\"1.9.0\",value:\"always\",description:\"Wrap prose if it exceeds the print width.\"},{since:\"1.9.0\",value:\"never\",description:\"Do not wrap prose.\"},{since:\"1.9.0\",value:\"preserve\",description:\"Wrap prose as-is.\"}]}};var options$2={singleQuote:commonOptions.singleQuote};var createLanguage=function createLanguage(linguistData,override){const{languageId}=linguistData,rest=_objectWithoutPropertiesLoose(linguistData,[\"languageId\"]);return Object.assign({linguistLanguageId:languageId},rest,{},override(linguistData));};var name$1=\"CSS\";var type=\"markup\";var tmScope=\"source.css\";var aceMode=\"css\";var codemirrorMode=\"css\";var codemirrorMimeType=\"text/css\";var color=\"#563d7c\";var extensions=[\".css\"];var languageId=50;var CSS={name:name$1,type:type,tmScope:tmScope,aceMode:aceMode,codemirrorMode:codemirrorMode,codemirrorMimeType:codemirrorMimeType,color:color,extensions:extensions,languageId:languageId};var CSS$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$1,type:type,tmScope:tmScope,aceMode:aceMode,codemirrorMode:codemirrorMode,codemirrorMimeType:codemirrorMimeType,color:color,extensions:extensions,languageId:languageId,'default':CSS});var name$2=\"PostCSS\";var type$1=\"markup\";var tmScope$1=\"source.postcss\";var group$2=\"CSS\";var extensions$1=[\".pcss\",\".postcss\"];var aceMode$1=\"text\";var languageId$1=262764437;var PostCSS={name:name$2,type:type$1,tmScope:tmScope$1,group:group$2,extensions:extensions$1,aceMode:aceMode$1,languageId:languageId$1};var PostCSS$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$2,type:type$1,tmScope:tmScope$1,group:group$2,extensions:extensions$1,aceMode:aceMode$1,languageId:languageId$1,'default':PostCSS});var name$3=\"Less\";var type$2=\"markup\";var group$3=\"CSS\";var extensions$2=[\".less\"];var tmScope$2=\"source.css.less\";var aceMode$2=\"less\";var codemirrorMode$1=\"css\";var codemirrorMimeType$1=\"text/css\";var languageId$2=198;var Less={name:name$3,type:type$2,group:group$3,extensions:extensions$2,tmScope:tmScope$2,aceMode:aceMode$2,codemirrorMode:codemirrorMode$1,codemirrorMimeType:codemirrorMimeType$1,languageId:languageId$2};var Less$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$3,type:type$2,group:group$3,extensions:extensions$2,tmScope:tmScope$2,aceMode:aceMode$2,codemirrorMode:codemirrorMode$1,codemirrorMimeType:codemirrorMimeType$1,languageId:languageId$2,'default':Less});var name$4=\"SCSS\";var type$3=\"markup\";var tmScope$3=\"source.css.scss\";var group$4=\"CSS\";var aceMode$3=\"scss\";var codemirrorMode$2=\"css\";var codemirrorMimeType$2=\"text/x-scss\";var extensions$3=[\".scss\"];var languageId$3=329;var SCSS={name:name$4,type:type$3,tmScope:tmScope$3,group:group$4,aceMode:aceMode$3,codemirrorMode:codemirrorMode$2,codemirrorMimeType:codemirrorMimeType$2,extensions:extensions$3,languageId:languageId$3};var SCSS$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$4,type:type$3,tmScope:tmScope$3,group:group$4,aceMode:aceMode$3,codemirrorMode:codemirrorMode$2,codemirrorMimeType:codemirrorMimeType$2,extensions:extensions$3,languageId:languageId$3,'default':SCSS});var require$$0$2=getCjsExportFromNamespace(CSS$1);var require$$1=getCjsExportFromNamespace(PostCSS$1);var require$$2=getCjsExportFromNamespace(Less$1);var require$$3=getCjsExportFromNamespace(SCSS$1);const languages=[createLanguage(require$$0$2,()=>({since:\"1.4.0\",parsers:[\"css\"],vscodeLanguageIds:[\"css\"]})),createLanguage(require$$1,()=>({since:\"1.4.0\",parsers:[\"css\"],vscodeLanguageIds:[\"postcss\"]})),createLanguage(require$$2,()=>({since:\"1.4.0\",parsers:[\"less\"],vscodeLanguageIds:[\"less\"]})),createLanguage(require$$3,()=>({since:\"1.4.0\",parsers:[\"scss\"],vscodeLanguageIds:[\"scss\"]}))];const printers={postcss:printerPostcss};var languageCss={languages,options:options$2,printers};function hasPragma$2(text){return /^\\s*#[^\\n\\S]*@(format|prettier)\\s*(\\n|$)/.test(text);}function insertPragma$3(text){return\"# @format\\n\\n\"+text;}var pragma$2={hasPragma:hasPragma$2,insertPragma:insertPragma$3};const{concat:concat$6,join:join$3,hardline:hardline$5,line:line$3,softline:softline$2,group:group$5,indent:indent$3,ifBreak:ifBreak$2}=document.builders;const{hasIgnoreComment:hasIgnoreComment$2}=util$1;const{isNextLineEmpty:isNextLineEmpty$3}=utilShared;const{insertPragma:insertPragma$4}=pragma$2;function genericPrint$1(path,options,print){const n=path.getValue();if(!n){return\"\";}if(typeof n===\"string\"){return n;}switch(n.kind){case\"Document\":{const parts=[];path.map((pathChild,index)=>{parts.push(concat$6([pathChild.call(print)]));if(index!==n.definitions.length-1){parts.push(hardline$5);if(isNextLineEmpty$3(options.originalText,pathChild.getValue(),options.locEnd)){parts.push(hardline$5);}}},\"definitions\");return concat$6([concat$6(parts),hardline$5]);}case\"OperationDefinition\":{const hasOperation=options.originalText[options.locStart(n)]!==\"{\";const hasName=!!n.name;return concat$6([hasOperation?n.operation:\"\",hasOperation&&hasName?concat$6([\" \",path.call(print,\"name\")]):\"\",n.variableDefinitions&&n.variableDefinitions.length?group$5(concat$6([\"(\",indent$3(concat$6([softline$2,join$3(concat$6([ifBreak$2(\"\",\", \"),softline$2]),path.map(print,\"variableDefinitions\"))])),softline$2,\")\"])):\"\",printDirectives(path,print,n),n.selectionSet?!hasOperation&&!hasName?\"\":\" \":\"\",path.call(print,\"selectionSet\")]);}case\"FragmentDefinition\":{return concat$6([\"fragment \",path.call(print,\"name\"),n.variableDefinitions&&n.variableDefinitions.length?group$5(concat$6([\"(\",indent$3(concat$6([softline$2,join$3(concat$6([ifBreak$2(\"\",\", \"),softline$2]),path.map(print,\"variableDefinitions\"))])),softline$2,\")\"])):\"\",\" on \",path.call(print,\"typeCondition\"),printDirectives(path,print,n),\" \",path.call(print,\"selectionSet\")]);}case\"SelectionSet\":{return concat$6([\"{\",indent$3(concat$6([hardline$5,join$3(hardline$5,path.call(selectionsPath=>printSequence(selectionsPath,options,print),\"selections\"))])),hardline$5,\"}\"]);}case\"Field\":{return group$5(concat$6([n.alias?concat$6([path.call(print,\"alias\"),\": \"]):\"\",path.call(print,\"name\"),n.arguments.length>0?group$5(concat$6([\"(\",indent$3(concat$6([softline$2,join$3(concat$6([ifBreak$2(\"\",\", \"),softline$2]),path.call(argsPath=>printSequence(argsPath,options,print),\"arguments\"))])),softline$2,\")\"])):\"\",printDirectives(path,print,n),n.selectionSet?\" \":\"\",path.call(print,\"selectionSet\")]));}case\"Name\":{return n.value;}case\"StringValue\":{if(n.block){return concat$6(['\"\"\"',hardline$5,join$3(hardline$5,n.value.replace(/\"\"\"/g,\"\\\\$&\").split(\"\\n\")),hardline$5,'\"\"\"']);}return concat$6(['\"',n.value.replace(/[\"\\\\]/g,\"\\\\$&\").replace(/\\n/g,\"\\\\n\"),'\"']);}case\"IntValue\":case\"FloatValue\":case\"EnumValue\":{return n.value;}case\"BooleanValue\":{return n.value?\"true\":\"false\";}case\"NullValue\":{return\"null\";}case\"Variable\":{return concat$6([\"$\",path.call(print,\"name\")]);}case\"ListValue\":{return group$5(concat$6([\"[\",indent$3(concat$6([softline$2,join$3(concat$6([ifBreak$2(\"\",\", \"),softline$2]),path.map(print,\"values\"))])),softline$2,\"]\"]));}case\"ObjectValue\":{return group$5(concat$6([\"{\",options.bracketSpacing&&n.fields.length>0?\" \":\"\",indent$3(concat$6([softline$2,join$3(concat$6([ifBreak$2(\"\",\", \"),softline$2]),path.map(print,\"fields\"))])),softline$2,ifBreak$2(\"\",options.bracketSpacing&&n.fields.length>0?\" \":\"\"),\"}\"]));}case\"ObjectField\":case\"Argument\":{return concat$6([path.call(print,\"name\"),\": \",path.call(print,\"value\")]);}case\"Directive\":{return concat$6([\"@\",path.call(print,\"name\"),n.arguments.length>0?group$5(concat$6([\"(\",indent$3(concat$6([softline$2,join$3(concat$6([ifBreak$2(\"\",\", \"),softline$2]),path.call(argsPath=>printSequence(argsPath,options,print),\"arguments\"))])),softline$2,\")\"])):\"\"]);}case\"NamedType\":{return path.call(print,\"name\");}case\"VariableDefinition\":{return concat$6([path.call(print,\"variable\"),\": \",path.call(print,\"type\"),n.defaultValue?concat$6([\" = \",path.call(print,\"defaultValue\")]):\"\",printDirectives(path,print,n)]);}case\"TypeExtensionDefinition\":{return concat$6([\"extend \",path.call(print,\"definition\")]);}case\"ObjectTypeExtension\":case\"ObjectTypeDefinition\":{return concat$6([path.call(print,\"description\"),n.description?hardline$5:\"\",n.kind===\"ObjectTypeExtension\"?\"extend \":\"\",\"type \",path.call(print,\"name\"),n.interfaces.length>0?concat$6([\" implements \",concat$6(printInterfaces(path,options,print))]):\"\",printDirectives(path,print,n),n.fields.length>0?concat$6([\" {\",indent$3(concat$6([hardline$5,join$3(hardline$5,path.call(fieldsPath=>printSequence(fieldsPath,options,print),\"fields\"))])),hardline$5,\"}\"]):\"\"]);}case\"FieldDefinition\":{return concat$6([path.call(print,\"description\"),n.description?hardline$5:\"\",path.call(print,\"name\"),n.arguments.length>0?group$5(concat$6([\"(\",indent$3(concat$6([softline$2,join$3(concat$6([ifBreak$2(\"\",\", \"),softline$2]),path.call(argsPath=>printSequence(argsPath,options,print),\"arguments\"))])),softline$2,\")\"])):\"\",\": \",path.call(print,\"type\"),printDirectives(path,print,n)]);}case\"DirectiveDefinition\":{return concat$6([path.call(print,\"description\"),n.description?hardline$5:\"\",\"directive \",\"@\",path.call(print,\"name\"),n.arguments.length>0?group$5(concat$6([\"(\",indent$3(concat$6([softline$2,join$3(concat$6([ifBreak$2(\"\",\", \"),softline$2]),path.call(argsPath=>printSequence(argsPath,options,print),\"arguments\"))])),softline$2,\")\"])):\"\",n.repeatable?\" repeatable\":\"\",concat$6([\" on \",join$3(\" | \",path.map(print,\"locations\"))])]);}case\"EnumTypeExtension\":case\"EnumTypeDefinition\":{return concat$6([path.call(print,\"description\"),n.description?hardline$5:\"\",n.kind===\"EnumTypeExtension\"?\"extend \":\"\",\"enum \",path.call(print,\"name\"),printDirectives(path,print,n),n.values.length>0?concat$6([\" {\",indent$3(concat$6([hardline$5,join$3(hardline$5,path.call(valuesPath=>printSequence(valuesPath,options,print),\"values\"))])),hardline$5,\"}\"]):\"\"]);}case\"EnumValueDefinition\":{return concat$6([path.call(print,\"description\"),n.description?hardline$5:\"\",path.call(print,\"name\"),printDirectives(path,print,n)]);}case\"InputValueDefinition\":{return concat$6([path.call(print,\"description\"),n.description?n.description.block?hardline$5:line$3:\"\",path.call(print,\"name\"),\": \",path.call(print,\"type\"),n.defaultValue?concat$6([\" = \",path.call(print,\"defaultValue\")]):\"\",printDirectives(path,print,n)]);}case\"InputObjectTypeExtension\":case\"InputObjectTypeDefinition\":{return concat$6([path.call(print,\"description\"),n.description?hardline$5:\"\",n.kind===\"InputObjectTypeExtension\"?\"extend \":\"\",\"input \",path.call(print,\"name\"),printDirectives(path,print,n),n.fields.length>0?concat$6([\" {\",indent$3(concat$6([hardline$5,join$3(hardline$5,path.call(fieldsPath=>printSequence(fieldsPath,options,print),\"fields\"))])),hardline$5,\"}\"]):\"\"]);}case\"SchemaDefinition\":{return concat$6([\"schema\",printDirectives(path,print,n),\" {\",n.operationTypes.length>0?indent$3(concat$6([hardline$5,join$3(hardline$5,path.call(opsPath=>printSequence(opsPath,options,print),\"operationTypes\"))])):\"\",hardline$5,\"}\"]);}case\"OperationTypeDefinition\":{return concat$6([path.call(print,\"operation\"),\": \",path.call(print,\"type\")]);}case\"InterfaceTypeExtension\":case\"InterfaceTypeDefinition\":{return concat$6([path.call(print,\"description\"),n.description?hardline$5:\"\",n.kind===\"InterfaceTypeExtension\"?\"extend \":\"\",\"interface \",path.call(print,\"name\"),printDirectives(path,print,n),n.fields.length>0?concat$6([\" {\",indent$3(concat$6([hardline$5,join$3(hardline$5,path.call(fieldsPath=>printSequence(fieldsPath,options,print),\"fields\"))])),hardline$5,\"}\"]):\"\"]);}case\"FragmentSpread\":{return concat$6([\"...\",path.call(print,\"name\"),printDirectives(path,print,n)]);}case\"InlineFragment\":{return concat$6([\"...\",n.typeCondition?concat$6([\" on \",path.call(print,\"typeCondition\")]):\"\",printDirectives(path,print,n),\" \",path.call(print,\"selectionSet\")]);}case\"UnionTypeExtension\":case\"UnionTypeDefinition\":{return group$5(concat$6([path.call(print,\"description\"),n.description?hardline$5:\"\",group$5(concat$6([n.kind===\"UnionTypeExtension\"?\"extend \":\"\",\"union \",path.call(print,\"name\"),printDirectives(path,print,n),n.types.length>0?concat$6([\" =\",ifBreak$2(\"\",\" \"),indent$3(concat$6([ifBreak$2(concat$6([line$3,\"  \"])),join$3(concat$6([line$3,\"| \"]),path.map(print,\"types\"))]))]):\"\"]))]));}case\"ScalarTypeExtension\":case\"ScalarTypeDefinition\":{return concat$6([path.call(print,\"description\"),n.description?hardline$5:\"\",n.kind===\"ScalarTypeExtension\"?\"extend \":\"\",\"scalar \",path.call(print,\"name\"),printDirectives(path,print,n)]);}case\"NonNullType\":{return concat$6([path.call(print,\"type\"),\"!\"]);}case\"ListType\":{return concat$6([\"[\",path.call(print,\"type\"),\"]\"]);}default:/* istanbul ignore next */throw new Error(\"unknown graphql type: \"+JSON.stringify(n.kind));}}function printDirectives(path,print,n){if(n.directives.length===0){return\"\";}return concat$6([\" \",group$5(indent$3(concat$6([softline$2,join$3(concat$6([ifBreak$2(\"\",\" \"),softline$2]),path.map(print,\"directives\"))])))]);}function printSequence(sequencePath,options,print){const count=sequencePath.getValue().length;return sequencePath.map((path,i)=>{const printed=print(path);if(isNextLineEmpty$3(options.originalText,path.getValue(),options.locEnd)&&i<count-1){return concat$6([printed,hardline$5]);}return printed;});}function canAttachComment(node){return node.kind&&node.kind!==\"Comment\";}function printComment$1(commentPath){const comment=commentPath.getValue();if(comment.kind===\"Comment\"){return\"#\"+comment.value.trimEnd();}throw new Error(\"Not a comment: \"+JSON.stringify(comment));}function determineInterfaceSeparatorBetween(first,second,options){const textBetween=options.originalText.slice(first.loc.end,second.loc.start).replace(/#.*/g,\"\").trim();return textBetween===\",\"?\", \":\" & \";}function printInterfaces(path,options,print){const node=path.getNode();const parts=[];const{interfaces}=node;const printed=path.map(node=>print(node),\"interfaces\");for(let index=0;index<interfaces.length;index++){const interfaceNode=interfaces[index];if(index>0){parts.push(determineInterfaceSeparatorBetween(interfaces[index-1],interfaceNode,options));}parts.push(printed[index]);}return parts;}function clean$1(node,newNode/*, parent*/){delete newNode.loc;delete newNode.comments;}var printerGraphql={print:genericPrint$1,massageAstNode:clean$1,hasPrettierIgnore:hasIgnoreComment$2,insertPragma:insertPragma$4,printComment:printComment$1,canAttachComment};var options$3={bracketSpacing:commonOptions.bracketSpacing};var name$5=\"GraphQL\";var type$4=\"data\";var extensions$4=[\".graphql\",\".gql\",\".graphqls\"];var tmScope$4=\"source.graphql\";var aceMode$4=\"text\";var languageId$4=139;var GraphQL={name:name$5,type:type$4,extensions:extensions$4,tmScope:tmScope$4,aceMode:aceMode$4,languageId:languageId$4};var GraphQL$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$5,type:type$4,extensions:extensions$4,tmScope:tmScope$4,aceMode:aceMode$4,languageId:languageId$4,'default':GraphQL});var require$$0$3=getCjsExportFromNamespace(GraphQL$1);const languages$1=[createLanguage(require$$0$3,()=>({since:\"1.5.0\",parsers:[\"graphql\"],vscodeLanguageIds:[\"graphql\"]}))];const printers$1={graphql:printerGraphql};var languageGraphql={languages:languages$1,options:options$3,printers:printers$1};var clean$2=function clean(ast,newNode){delete newNode.loc;delete newNode.selfClosing;// (Glimmer/HTML) ignore TextNode whitespace\nif(ast.type===\"TextNode\"){const trimmed=ast.chars.trim();if(!trimmed){return null;}newNode.chars=trimmed;}};function isUppercase(string){return string.toUpperCase()===string;}function isGlimmerComponent(node){return isNodeOfSomeType(node,[\"ElementNode\"])&&typeof node.tag===\"string\"&&(isUppercase(node.tag[0])||node.tag.includes(\".\"));}function isWhitespaceNode(node){return isNodeOfSomeType(node,[\"TextNode\"])&&!/\\S/.test(node.chars);}function isNodeOfSomeType(node,types){return node&&types.some(type=>node.type===type);}function isParentOfSomeType(path,types){const parentNode=path.getParentNode(0);return isNodeOfSomeType(parentNode,types);}function isPreviousNodeOfSomeType(path,types){const previousNode=getPreviousNode(path);return isNodeOfSomeType(previousNode,types);}function isNextNodeOfSomeType(path,types){const nextNode=getNextNode(path);return isNodeOfSomeType(nextNode,types);}function getSiblingNode(path,offset){const node=path.getValue();const parentNode=path.getParentNode(0)||{};const children=parentNode.children||parentNode.body||[];const index=children.indexOf(node);return index!==-1&&children[index+offset];}function getPreviousNode(path){let lookBack=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;return getSiblingNode(path,-lookBack);}function getNextNode(path){return getSiblingNode(path,1);}function isPrettierIgnoreNode(node){return isNodeOfSomeType(node,[\"MustacheCommentStatement\"])&&typeof node.value===\"string\"&&node.value.trim()===\"prettier-ignore\";}function hasPrettierIgnore(path){const node=path.getValue();const previousPreviousNode=getPreviousNode(path,2);return isPrettierIgnoreNode(node)||isPrettierIgnoreNode(previousPreviousNode);}var utils$3={getNextNode,getPreviousNode,hasPrettierIgnore,isGlimmerComponent,isNextNodeOfSomeType,isNodeOfSomeType,isParentOfSomeType,isPreviousNodeOfSomeType,isWhitespaceNode};const{concat:concat$7,join:join$4,softline:softline$3,hardline:hardline$6,line:line$4,group:group$6,indent:indent$4,ifBreak:ifBreak$3}=document.builders;const{getNextNode:getNextNode$1,getPreviousNode:getPreviousNode$1,hasPrettierIgnore:hasPrettierIgnore$1,isGlimmerComponent:isGlimmerComponent$1,isNextNodeOfSomeType:isNextNodeOfSomeType$1,isParentOfSomeType:isParentOfSomeType$1,isPreviousNodeOfSomeType:isPreviousNodeOfSomeType$1,isWhitespaceNode:isWhitespaceNode$1}=utils$3;// http://w3c.github.io/html/single-page.html#void-elements\nconst voidTags=[\"area\",\"base\",\"br\",\"col\",\"embed\",\"hr\",\"img\",\"input\",\"link\",\"meta\",\"param\",\"source\",\"track\",\"wbr\"];// Formatter based on @glimmerjs/syntax's built-in test formatter:\n// https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts\nfunction print(path,options,print){const n=path.getValue();/* istanbul ignore if*/if(!n){return\"\";}if(hasPrettierIgnore$1(path)){const startOffset=locationToOffset(options.originalText,n.loc.start.line-1,n.loc.start.column);const endOffset=locationToOffset(options.originalText,n.loc.end.line-1,n.loc.end.column);const ignoredText=options.originalText.slice(startOffset,endOffset);return ignoredText;}switch(n.type){case\"Block\":case\"Program\":case\"Template\":{return group$6(concat$7(path.map(print,\"body\")));}case\"ElementNode\":{const hasChildren=n.children.length>0;const hasNonWhitespaceChildren=n.children.some(n=>!isWhitespaceNode$1(n));const isVoid=isGlimmerComponent$1(n)&&(!hasChildren||!hasNonWhitespaceChildren)||voidTags.includes(n.tag);const closeTagForNoBreak=isVoid?concat$7([\" />\",softline$3]):\">\";const closeTagForBreak=isVoid?\"/>\":\">\";const printParams=(path,print)=>indent$4(concat$7([n.attributes.length?line$4:\"\",join$4(line$4,path.map(print,\"attributes\")),n.modifiers.length?line$4:\"\",join$4(line$4,path.map(print,\"modifiers\")),n.comments.length?line$4:\"\",join$4(line$4,path.map(print,\"comments\"))]));const nextNode=getNextNode$1(path);return concat$7([group$6(concat$7([\"<\",n.tag,printParams(path,print),n.blockParams.length?\" as |\".concat(n.blockParams.join(\" \"),\"|\"):\"\",ifBreak$3(softline$3,\"\"),ifBreak$3(closeTagForBreak,closeTagForNoBreak)])),!isVoid?group$6(concat$7([hasNonWhitespaceChildren?indent$4(printChildren(path,options,print)):\"\",ifBreak$3(hasChildren?hardline$6:\"\",\"\"),concat$7([\"</\",n.tag,\">\"])])):\"\",nextNode&&nextNode.type===\"ElementNode\"?hardline$6:\"\"]);}case\"BlockStatement\":{const pp=path.getParentNode(1);const isElseIf=pp&&pp.inverse&&pp.inverse.body.length===1&&pp.inverse.body[0]===n&&pp.inverse.body[0].path.parts[0]===\"if\";const hasElseIf=n.inverse&&n.inverse.body.length===1&&n.inverse.body[0].type===\"BlockStatement\"&&n.inverse.body[0].path.parts[0]===\"if\";const indentElse=hasElseIf?a=>a:indent$4;const inverseElseStatement=(n.inverseStrip.open?\"{{~\":\"{{\")+\"else\"+(n.inverseStrip.close?\"~}}\":\"}}\");if(n.inverse){return concat$7([isElseIf?concat$7([n.openStrip.open?\"{{~else \":\"{{else \",printPathParams(path,print),n.openStrip.close?\"~}}\":\"}}\"]):printOpenBlock(path,print,n.openStrip),indent$4(concat$7([hardline$6,path.call(print,\"program\")])),n.inverse&&!hasElseIf?concat$7([hardline$6,inverseElseStatement]):\"\",n.inverse?indentElse(concat$7([hardline$6,path.call(print,\"inverse\")])):\"\",isElseIf?\"\":concat$7([hardline$6,printCloseBlock(path,print,n.closeStrip)])]);}else if(isElseIf){return concat$7([concat$7([n.openStrip.open?\"{{~else\":\"{{else \",printPathParams(path,print),n.openStrip.close?\"~}}\":\"}}\"]),indent$4(concat$7([hardline$6,path.call(print,\"program\")]))]);}const hasNonWhitespaceChildren=n.program.body.some(n=>!isWhitespaceNode$1(n));return concat$7([printOpenBlock(path,print,n.openStrip),group$6(concat$7([indent$4(concat$7([softline$3,path.call(print,\"program\")])),hasNonWhitespaceChildren?hardline$6:softline$3,printCloseBlock(path,print,n.closeStrip)]))]);}case\"ElementModifierStatement\":{return group$6(concat$7([\"{{\",printPathParams(path,print),softline$3,\"}}\"]));}case\"MustacheStatement\":{const isEscaped=n.escaped===false;const{open:openStrip,close:closeStrip}=n.strip;const opening=(isEscaped?\"{{{\":\"{{\")+(openStrip?\"~\":\"\");const closing=(closeStrip?\"~\":\"\")+(isEscaped?\"}}}\":\"}}\");const leading=isParentOfSomeType$1(path,[\"AttrNode\",\"ConcatStatement\",\"ElementNode\"])?[opening,indent$4(softline$3)]:[opening];return group$6(concat$7([...leading,printPathParams(path,print),softline$3,closing]));}case\"SubExpression\":{const params=printParams(path,print);const printedParams=params.length>0?indent$4(concat$7([line$4,group$6(join$4(line$4,params))])):\"\";return group$6(concat$7([\"(\",printPath(path,print),printedParams,softline$3,\")\"]));}case\"AttrNode\":{const isText=n.value.type===\"TextNode\";const isEmptyText=isText&&n.value.chars===\"\";// If the text is empty and the value's loc start and end columns are the\n// same, there is no value for this AttrNode and it should be printed\n// without the `=\"\"`. Example: `<img data-test>` -> `<img data-test>`\nconst isEmptyValue=isEmptyText&&n.value.loc.start.column===n.value.loc.end.column;if(isEmptyValue){return concat$7([n.name]);}const value=path.call(print,\"value\");const quotedValue=isText?printStringLiteral(value.parts.join(),options):value;return concat$7([n.name,\"=\",quotedValue]);}case\"ConcatStatement\":{return concat$7(['\"',concat$7(path.map(partPath=>print(partPath),\"parts\").filter(a=>a!==\"\")),'\"']);}case\"Hash\":{return concat$7([join$4(line$4,path.map(print,\"pairs\"))]);}case\"HashPair\":{return concat$7([n.key,\"=\",path.call(print,\"value\")]);}case\"TextNode\":{const maxLineBreaksToPreserve=2;const isFirstElement=!getPreviousNode$1(path);const isLastElement=!getNextNode$1(path);const isWhitespaceOnly=!/\\S/.test(n.chars);const lineBreaksCount=countNewLines(n.chars);const hasBlockParent=path.getParentNode(0).type===\"Block\";const hasElementParent=path.getParentNode(0).type===\"ElementNode\";const hasTemplateParent=path.getParentNode(0).type===\"Template\";let leadingLineBreaksCount=countLeadingNewLines(n.chars);let trailingLineBreaksCount=countTrailingNewLines(n.chars);if((isFirstElement||isLastElement)&&isWhitespaceOnly&&(hasBlockParent||hasElementParent||hasTemplateParent)){return\"\";}if(isWhitespaceOnly&&lineBreaksCount){leadingLineBreaksCount=Math.min(lineBreaksCount,maxLineBreaksToPreserve);trailingLineBreaksCount=0;}else{if(isNextNodeOfSomeType$1(path,[\"BlockStatement\",\"ElementNode\"])){trailingLineBreaksCount=Math.max(trailingLineBreaksCount,1);}if(isPreviousNodeOfSomeType$1(path,[\"ElementNode\"])||isPreviousNodeOfSomeType$1(path,[\"BlockStatement\"])){leadingLineBreaksCount=Math.max(leadingLineBreaksCount,1);}}let leadingSpace=\"\";let trailingSpace=\"\";// preserve a space inside of an attribute node where whitespace present,\n// when next to mustache statement.\nconst inAttrNode=path.stack.includes(\"attributes\");if(inAttrNode){const parentNode=path.getParentNode(0);const isConcat=parentNode.type===\"ConcatStatement\";if(isConcat){const{parts}=parentNode;const partIndex=parts.indexOf(n);if(partIndex>0){const partType=parts[partIndex-1].type;const isMustache=partType===\"MustacheStatement\";if(isMustache){leadingSpace=\" \";}}if(partIndex<parts.length-1){const partType=parts[partIndex+1].type;const isMustache=partType===\"MustacheStatement\";if(isMustache){trailingSpace=\" \";}}}}else{if(trailingLineBreaksCount===0&&isNextNodeOfSomeType$1(path,[\"MustacheStatement\"])){trailingSpace=\" \";}if(leadingLineBreaksCount===0&&isPreviousNodeOfSomeType$1(path,[\"MustacheStatement\"])){leadingSpace=\" \";}if(isFirstElement){leadingLineBreaksCount=0;leadingSpace=\"\";}if(isLastElement){trailingLineBreaksCount=0;trailingSpace=\"\";}}return concat$7([...generateHardlines(leadingLineBreaksCount,maxLineBreaksToPreserve),n.chars.replace(/^[\\s ]+/g,leadingSpace).replace(/[\\s ]+$/,trailingSpace),...generateHardlines(trailingLineBreaksCount,maxLineBreaksToPreserve)].filter(Boolean));}case\"MustacheCommentStatement\":{const dashes=n.value.includes(\"}}\")?\"--\":\"\";return concat$7([\"{{!\",dashes,n.value,dashes,\"}}\"]);}case\"PathExpression\":{return n.original;}case\"BooleanLiteral\":{return String(n.value);}case\"CommentStatement\":{return concat$7([\"<!--\",n.value,\"-->\"]);}case\"StringLiteral\":{return printStringLiteral(n.value,options);}case\"NumberLiteral\":{return String(n.value);}case\"UndefinedLiteral\":{return\"undefined\";}case\"NullLiteral\":{return\"null\";}/* istanbul ignore next */default:throw new Error(\"unknown glimmer type: \"+JSON.stringify(n.type));}}function printChildren(path,options,print){return concat$7(path.map((childPath,childIndex)=>{const childNode=path.getValue();const isFirstNode=childIndex===0;const isLastNode=childIndex===path.getParentNode(0).children.length-1;const isLastNodeInMultiNodeList=isLastNode&&!isFirstNode;const isWhitespace=isWhitespaceNode$1(childNode);if(isWhitespace&&isLastNodeInMultiNodeList){return print(childPath,options,print);}else if(isFirstNode){return concat$7([softline$3,print(childPath,options,print)]);}return print(childPath,options,print);},\"children\"));}/**\n   * Prints a string literal with the correct surrounding quotes based on\n   * `options.singleQuote` and the number of escaped quotes contained in\n   * the string literal. This function is the glimmer equivalent of `printString`\n   * in `common/util`, but has differences because of the way escaped characters\n   * are treated in hbs string literals.\n   * @param {string} stringLiteral - the string literal value\n   * @param {object} options - the prettier options object\n   */function printStringLiteral(stringLiteral,options){const double={quote:'\"',regex:/\"/g};const single={quote:\"'\",regex:/'/g};const preferred=options.singleQuote?single:double;const alternate=preferred===single?double:single;let shouldUseAlternateQuote=false;// If `stringLiteral` contains at least one of the quote preferred for\n// enclosing the string, we might want to enclose with the alternate quote\n// instead, to minimize the number of escaped quotes.\nif(stringLiteral.includes(preferred.quote)||stringLiteral.includes(alternate.quote)){const numPreferredQuotes=(stringLiteral.match(preferred.regex)||[]).length;const numAlternateQuotes=(stringLiteral.match(alternate.regex)||[]).length;shouldUseAlternateQuote=numPreferredQuotes>numAlternateQuotes;}const enclosingQuote=shouldUseAlternateQuote?alternate:preferred;const escapedStringLiteral=stringLiteral.replace(enclosingQuote.regex,\"\\\\\".concat(enclosingQuote.quote));return concat$7([enclosingQuote.quote,escapedStringLiteral,enclosingQuote.quote]);}function printPath(path,print){return path.call(print,\"path\");}function printParams(path,print){const node=path.getValue();let parts=[];if(node.params.length>0){parts=parts.concat(path.map(print,\"params\"));}if(node.hash&&node.hash.pairs.length>0){parts.push(path.call(print,\"hash\"));}return parts;}function printPathParams(path,print){const printedPath=printPath(path,print);const printedParams=printParams(path,print);const parts=[printedPath,...printedParams];return indent$4(group$6(join$4(line$4,parts)));}function printBlockParams(path){const block=path.getValue();if(!block.program||!block.program.blockParams.length){return\"\";}return concat$7([\" as |\",block.program.blockParams.join(\" \"),\"|\"]);}function printOpenBlock(path,print){let{open:isOpenStrip=false,close:isCloseStrip=false}=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};return group$6(concat$7([isOpenStrip?\"{{~#\":\"{{#\",printPathParams(path,print),printBlockParams(path),softline$3,isCloseStrip?\"~}}\":\"}}\"]));}function printCloseBlock(path,print){let{open:isOpenStrip=false,close:isCloseStrip=false}=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};return concat$7([isOpenStrip?\"{{~/\":\"{{/\",path.call(print,\"path\"),isCloseStrip?\"~}}\":\"}}\"]);}function countNewLines(string){/* istanbul ignore next */string=typeof string===\"string\"?string:\"\";return string.split(\"\\n\").length-1;}function countLeadingNewLines(string){/* istanbul ignore next */string=typeof string===\"string\"?string:\"\";const newLines=(string.match(/^([^\\S\\r\\n]*[\\r\\n])+/g)||[])[0]||\"\";return countNewLines(newLines);}function countTrailingNewLines(string){/* istanbul ignore next */string=typeof string===\"string\"?string:\"\";const newLines=(string.match(/([\\r\\n][^\\S\\r\\n]*)+$/g)||[])[0]||\"\";return countNewLines(newLines);}function generateHardlines(){let number=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;let max=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;return new Array(Math.min(number,max)).fill(hardline$6);}/* istanbul ignore next\n     https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/compiler/lib/location.ts#L5-L29\n  */function locationToOffset(source,line,column){let seenLines=0;let seenChars=0;// eslint-disable-next-line no-constant-condition\nwhile(true){if(seenChars===source.length){return null;}let nextLine=source.indexOf(\"\\n\",seenChars);if(nextLine===-1){nextLine=source.length;}if(seenLines===line){if(seenChars+column>nextLine){return null;}return seenChars+column;}else if(nextLine===-1){return null;}seenLines+=1;seenChars=nextLine+1;}}var printerGlimmer={print,massageAstNode:clean$2};var name$6=\"Handlebars\";var type$5=\"markup\";var group$7=\"HTML\";var aliases=[\"hbs\",\"htmlbars\"];var extensions$5=[\".handlebars\",\".hbs\"];var tmScope$5=\"text.html.handlebars\";var aceMode$5=\"handlebars\";var languageId$5=155;var Handlebars={name:name$6,type:type$5,group:group$7,aliases:aliases,extensions:extensions$5,tmScope:tmScope$5,aceMode:aceMode$5,languageId:languageId$5};var Handlebars$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$6,type:type$5,group:group$7,aliases:aliases,extensions:extensions$5,tmScope:tmScope$5,aceMode:aceMode$5,languageId:languageId$5,'default':Handlebars});var require$$0$4=getCjsExportFromNamespace(Handlebars$1);const languages$2=[createLanguage(require$$0$4,()=>({since:null,// unreleased\nparsers:[\"glimmer\"],vscodeLanguageIds:[\"handlebars\"]}))];const printers$2={glimmer:printerGlimmer};var languageHandlebars={languages:languages$2,printers:printers$2};var clean$3=function clean(ast,newNode){delete newNode.sourceSpan;delete newNode.startSourceSpan;delete newNode.endSourceSpan;delete newNode.nameSpan;delete newNode.valueSpan;if(ast.type===\"text\"||ast.type===\"comment\"){return null;}// may be formatted by multiparser\nif(ast.type===\"yaml\"||ast.type===\"toml\"){return null;}if(ast.type===\"attribute\"){delete newNode.value;}if(ast.type===\"docType\"){delete newNode.value;}};var json={\"CSS_DISPLAY_TAGS\":{\"area\":\"none\",\"base\":\"none\",\"basefont\":\"none\",\"datalist\":\"none\",\"head\":\"none\",\"link\":\"none\",\"meta\":\"none\",\"noembed\":\"none\",\"noframes\":\"none\",\"param\":\"none\",\"rp\":\"none\",\"script\":\"block\",\"source\":\"block\",\"style\":\"none\",\"template\":\"inline\",\"track\":\"block\",\"title\":\"none\",\"html\":\"block\",\"body\":\"block\",\"address\":\"block\",\"blockquote\":\"block\",\"center\":\"block\",\"div\":\"block\",\"figure\":\"block\",\"figcaption\":\"block\",\"footer\":\"block\",\"form\":\"block\",\"header\":\"block\",\"hr\":\"block\",\"legend\":\"block\",\"listing\":\"block\",\"main\":\"block\",\"p\":\"block\",\"plaintext\":\"block\",\"pre\":\"block\",\"xmp\":\"block\",\"slot\":\"contents\",\"ruby\":\"ruby\",\"rt\":\"ruby-text\",\"article\":\"block\",\"aside\":\"block\",\"h1\":\"block\",\"h2\":\"block\",\"h3\":\"block\",\"h4\":\"block\",\"h5\":\"block\",\"h6\":\"block\",\"hgroup\":\"block\",\"nav\":\"block\",\"section\":\"block\",\"dir\":\"block\",\"dd\":\"block\",\"dl\":\"block\",\"dt\":\"block\",\"ol\":\"block\",\"ul\":\"block\",\"li\":\"list-item\",\"table\":\"table\",\"caption\":\"table-caption\",\"colgroup\":\"table-column-group\",\"col\":\"table-column\",\"thead\":\"table-header-group\",\"tbody\":\"table-row-group\",\"tfoot\":\"table-footer-group\",\"tr\":\"table-row\",\"td\":\"table-cell\",\"th\":\"table-cell\",\"fieldset\":\"block\",\"button\":\"inline-block\",\"video\":\"inline-block\",\"audio\":\"inline-block\"},\"CSS_DISPLAY_DEFAULT\":\"inline\",\"CSS_WHITE_SPACE_TAGS\":{\"listing\":\"pre\",\"plaintext\":\"pre\",\"pre\":\"pre\",\"xmp\":\"pre\",\"nobr\":\"nowrap\",\"table\":\"initial\",\"textarea\":\"pre-wrap\"},\"CSS_WHITE_SPACE_DEFAULT\":\"normal\"};var index=[\"a\",\"abbr\",\"acronym\",\"address\",\"applet\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"basefont\",\"bdi\",\"bdo\",\"bgsound\",\"big\",\"blink\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"center\",\"cite\",\"code\",\"col\",\"colgroup\",\"command\",\"content\",\"data\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"dialog\",\"dir\",\"div\",\"dl\",\"dt\",\"element\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"font\",\"footer\",\"form\",\"frame\",\"frameset\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hgroup\",\"hr\",\"html\",\"i\",\"iframe\",\"image\",\"img\",\"input\",\"ins\",\"isindex\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"listing\",\"main\",\"map\",\"mark\",\"marquee\",\"math\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"multicol\",\"nav\",\"nextid\",\"nobr\",\"noembed\",\"noframes\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"picture\",\"plaintext\",\"pre\",\"progress\",\"q\",\"rb\",\"rbc\",\"rp\",\"rt\",\"rtc\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"shadow\",\"slot\",\"small\",\"source\",\"spacer\",\"span\",\"strike\",\"strong\",\"style\",\"sub\",\"summary\",\"sup\",\"svg\",\"table\",\"tbody\",\"td\",\"template\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"tt\",\"u\",\"ul\",\"var\",\"video\",\"wbr\",\"xmp\"];var htmlTagNames=/*#__PURE__*/Object.freeze({__proto__:null,'default':index});var a=[\"accesskey\",\"charset\",\"coords\",\"download\",\"href\",\"hreflang\",\"name\",\"ping\",\"referrerpolicy\",\"rel\",\"rev\",\"shape\",\"tabindex\",\"target\",\"type\"];var abbr=[\"title\"];var applet=[\"align\",\"alt\",\"archive\",\"code\",\"codebase\",\"height\",\"hspace\",\"name\",\"object\",\"vspace\",\"width\"];var area=[\"accesskey\",\"alt\",\"coords\",\"download\",\"href\",\"hreflang\",\"nohref\",\"ping\",\"referrerpolicy\",\"rel\",\"shape\",\"tabindex\",\"target\",\"type\"];var audio=[\"autoplay\",\"controls\",\"crossorigin\",\"loop\",\"muted\",\"preload\",\"src\"];var base=[\"href\",\"target\"];var basefont=[\"color\",\"face\",\"size\"];var bdo=[\"dir\"];var blockquote=[\"cite\"];var body=[\"alink\",\"background\",\"bgcolor\",\"link\",\"text\",\"vlink\"];var br=[\"clear\"];var button=[\"accesskey\",\"autofocus\",\"disabled\",\"form\",\"formaction\",\"formenctype\",\"formmethod\",\"formnovalidate\",\"formtarget\",\"name\",\"tabindex\",\"type\",\"value\"];var canvas=[\"height\",\"width\"];var caption=[\"align\"];var col=[\"align\",\"char\",\"charoff\",\"span\",\"valign\",\"width\"];var colgroup=[\"align\",\"char\",\"charoff\",\"span\",\"valign\",\"width\"];var data=[\"value\"];var del=[\"cite\",\"datetime\"];var details=[\"open\"];var dfn=[\"title\"];var dialog=[\"open\"];var dir=[\"compact\"];var div=[\"align\"];var dl=[\"compact\"];var embed$1=[\"height\",\"src\",\"type\",\"width\"];var fieldset=[\"disabled\",\"form\",\"name\"];var font=[\"color\",\"face\",\"size\"];var form=[\"accept\",\"accept-charset\",\"action\",\"autocomplete\",\"enctype\",\"method\",\"name\",\"novalidate\",\"target\"];var frame=[\"frameborder\",\"longdesc\",\"marginheight\",\"marginwidth\",\"name\",\"noresize\",\"scrolling\",\"src\"];var frameset=[\"cols\",\"rows\"];var h1=[\"align\"];var h2=[\"align\"];var h3=[\"align\"];var h4=[\"align\"];var h5=[\"align\"];var h6=[\"align\"];var head=[\"profile\"];var hr=[\"align\",\"noshade\",\"size\",\"width\"];var html=[\"manifest\",\"version\"];var iframe=[\"align\",\"allow\",\"allowfullscreen\",\"allowpaymentrequest\",\"allowusermedia\",\"frameborder\",\"height\",\"longdesc\",\"marginheight\",\"marginwidth\",\"name\",\"referrerpolicy\",\"sandbox\",\"scrolling\",\"src\",\"srcdoc\",\"width\"];var img=[\"align\",\"alt\",\"border\",\"crossorigin\",\"decoding\",\"height\",\"hspace\",\"ismap\",\"longdesc\",\"name\",\"referrerpolicy\",\"sizes\",\"src\",\"srcset\",\"usemap\",\"vspace\",\"width\"];var input=[\"accept\",\"accesskey\",\"align\",\"alt\",\"autocomplete\",\"autofocus\",\"checked\",\"dirname\",\"disabled\",\"form\",\"formaction\",\"formenctype\",\"formmethod\",\"formnovalidate\",\"formtarget\",\"height\",\"ismap\",\"list\",\"max\",\"maxlength\",\"min\",\"minlength\",\"multiple\",\"name\",\"pattern\",\"placeholder\",\"readonly\",\"required\",\"size\",\"src\",\"step\",\"tabindex\",\"title\",\"type\",\"usemap\",\"value\",\"width\"];var ins=[\"cite\",\"datetime\"];var isindex=[\"prompt\"];var label=[\"accesskey\",\"for\",\"form\"];var legend=[\"accesskey\",\"align\"];var li=[\"type\",\"value\"];var link$3=[\"as\",\"charset\",\"color\",\"crossorigin\",\"href\",\"hreflang\",\"imagesizes\",\"imagesrcset\",\"integrity\",\"media\",\"nonce\",\"referrerpolicy\",\"rel\",\"rev\",\"sizes\",\"target\",\"title\",\"type\"];var map=[\"name\"];var menu=[\"compact\"];var meta=[\"charset\",\"content\",\"http-equiv\",\"name\",\"scheme\"];var meter=[\"high\",\"low\",\"max\",\"min\",\"optimum\",\"value\"];var object=[\"align\",\"archive\",\"border\",\"classid\",\"codebase\",\"codetype\",\"data\",\"declare\",\"form\",\"height\",\"hspace\",\"name\",\"standby\",\"tabindex\",\"type\",\"typemustmatch\",\"usemap\",\"vspace\",\"width\"];var ol=[\"compact\",\"reversed\",\"start\",\"type\"];var optgroup=[\"disabled\",\"label\"];var option=[\"disabled\",\"label\",\"selected\",\"value\"];var output=[\"for\",\"form\",\"name\"];var p=[\"align\"];var param=[\"name\",\"type\",\"value\",\"valuetype\"];var pre=[\"width\"];var progress=[\"max\",\"value\"];var q=[\"cite\"];var script=[\"async\",\"charset\",\"crossorigin\",\"defer\",\"integrity\",\"language\",\"nomodule\",\"nonce\",\"referrerpolicy\",\"src\",\"type\"];var select=[\"autocomplete\",\"autofocus\",\"disabled\",\"form\",\"multiple\",\"name\",\"required\",\"size\",\"tabindex\"];var slot=[\"name\"];var source$1=[\"media\",\"sizes\",\"src\",\"srcset\",\"type\"];var style=[\"media\",\"nonce\",\"title\",\"type\"];var table=[\"align\",\"bgcolor\",\"border\",\"cellpadding\",\"cellspacing\",\"frame\",\"rules\",\"summary\",\"width\"];var tbody=[\"align\",\"char\",\"charoff\",\"valign\"];var td=[\"abbr\",\"align\",\"axis\",\"bgcolor\",\"char\",\"charoff\",\"colspan\",\"headers\",\"height\",\"nowrap\",\"rowspan\",\"scope\",\"valign\",\"width\"];var textarea=[\"accesskey\",\"autocomplete\",\"autofocus\",\"cols\",\"dirname\",\"disabled\",\"form\",\"maxlength\",\"minlength\",\"name\",\"placeholder\",\"readonly\",\"required\",\"rows\",\"tabindex\",\"wrap\"];var tfoot=[\"align\",\"char\",\"charoff\",\"valign\"];var th=[\"abbr\",\"align\",\"axis\",\"bgcolor\",\"char\",\"charoff\",\"colspan\",\"headers\",\"height\",\"nowrap\",\"rowspan\",\"scope\",\"valign\",\"width\"];var thead=[\"align\",\"char\",\"charoff\",\"valign\"];var time=[\"datetime\"];var tr=[\"align\",\"bgcolor\",\"char\",\"charoff\",\"valign\"];var track=[\"default\",\"kind\",\"label\",\"src\",\"srclang\"];var ul=[\"compact\",\"type\"];var video=[\"autoplay\",\"controls\",\"crossorigin\",\"height\",\"loop\",\"muted\",\"playsinline\",\"poster\",\"preload\",\"src\",\"width\"];var index$1={\"*\":[\"accesskey\",\"autocapitalize\",\"autofocus\",\"class\",\"contenteditable\",\"dir\",\"draggable\",\"enterkeyhint\",\"hidden\",\"id\",\"inputmode\",\"is\",\"itemid\",\"itemprop\",\"itemref\",\"itemscope\",\"itemtype\",\"lang\",\"nonce\",\"slot\",\"spellcheck\",\"style\",\"tabindex\",\"title\",\"translate\"],a:a,abbr:abbr,applet:applet,area:area,audio:audio,base:base,basefont:basefont,bdo:bdo,blockquote:blockquote,body:body,br:br,button:button,canvas:canvas,caption:caption,col:col,colgroup:colgroup,data:data,del:del,details:details,dfn:dfn,dialog:dialog,dir:dir,div:div,dl:dl,embed:embed$1,fieldset:fieldset,font:font,form:form,frame:frame,frameset:frameset,h1:h1,h2:h2,h3:h3,h4:h4,h5:h5,h6:h6,head:head,hr:hr,html:html,iframe:iframe,img:img,input:input,ins:ins,isindex:isindex,label:label,legend:legend,li:li,link:link$3,map:map,menu:menu,meta:meta,meter:meter,object:object,ol:ol,optgroup:optgroup,option:option,output:output,p:p,param:param,pre:pre,progress:progress,q:q,script:script,select:select,slot:slot,source:source$1,style:style,table:table,tbody:tbody,td:td,textarea:textarea,tfoot:tfoot,th:th,thead:thead,time:time,tr:tr,track:track,ul:ul,video:video};var htmlElementAttributes=/*#__PURE__*/Object.freeze({__proto__:null,a:a,abbr:abbr,applet:applet,area:area,audio:audio,base:base,basefont:basefont,bdo:bdo,blockquote:blockquote,body:body,br:br,button:button,canvas:canvas,caption:caption,col:col,colgroup:colgroup,data:data,del:del,details:details,dfn:dfn,dialog:dialog,dir:dir,div:div,dl:dl,embed:embed$1,fieldset:fieldset,font:font,form:form,frame:frame,frameset:frameset,h1:h1,h2:h2,h3:h3,h4:h4,h5:h5,h6:h6,head:head,hr:hr,html:html,iframe:iframe,img:img,input:input,ins:ins,isindex:isindex,label:label,legend:legend,li:li,link:link$3,map:map,menu:menu,meta:meta,meter:meter,object:object,ol:ol,optgroup:optgroup,option:option,output:output,p:p,param:param,pre:pre,progress:progress,q:q,script:script,select:select,slot:slot,source:source$1,style:style,table:table,tbody:tbody,td:td,textarea:textarea,tfoot:tfoot,th:th,thead:thead,time:time,tr:tr,track:track,ul:ul,video:video,'default':index$1});var htmlTagNames$1=getCjsExportFromNamespace(htmlTagNames);var htmlElementAttributes$1=getCjsExportFromNamespace(htmlElementAttributes);const{CSS_DISPLAY_TAGS,CSS_DISPLAY_DEFAULT,CSS_WHITE_SPACE_TAGS,CSS_WHITE_SPACE_DEFAULT}=json;const HTML_TAGS=arrayToMap(htmlTagNames$1);const HTML_ELEMENT_ATTRIBUTES=mapObject(htmlElementAttributes$1,arrayToMap);function arrayToMap(array){const map=Object.create(null);for(const value of array){map[value]=true;}return map;}function mapObject(object,fn){const newObject=Object.create(null);for(const key of Object.keys(object)){newObject[key]=fn(object[key],key);}return newObject;}function shouldPreserveContent(node,options){if(!node.endSourceSpan){return false;}if(node.type===\"element\"&&node.fullName===\"template\"&&node.attrMap.lang&&node.attrMap.lang!==\"html\"){return true;}// unterminated node in ie conditional comment\n// e.g. <!--[if lt IE 9]><html><![endif]-->\nif(node.type===\"ieConditionalComment\"&&node.lastChild&&!node.lastChild.isSelfClosing&&!node.lastChild.endSourceSpan){return true;}// incomplete html in ie conditional comment\n// e.g. <!--[if lt IE 9]></div><![endif]-->\nif(node.type===\"ieConditionalComment\"&&!node.complete){return true;}// top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block\n// custom blocks can be written in other languages so we should preserve them to not break the code\nif(options.parser===\"vue\"&&node.type===\"element\"&&node.parent.type===\"root\"&&![\"template\",\"style\",\"script\",// vue parser can be used for vue dom template as well, so we should still format top-level <html>\n\"html\"].includes(node.fullName)){return true;}// TODO: handle non-text children in <pre>\nif(isPreLikeNode(node)&&node.children.some(child=>child.type!==\"text\"&&child.type!==\"interpolation\")){return true;}return false;}function hasPrettierIgnore$2(node){if(node.type===\"attribute\"){return false;}if(!node.parent){return false;}if(typeof node.index!==\"number\"||node.index===0){return false;}const prevNode=node.parent.children[node.index-1];return isPrettierIgnore(prevNode);}function isPrettierIgnore(node){return node.type===\"comment\"&&node.value.trim()===\"prettier-ignore\";}function getPrettierIgnoreAttributeCommentData(value){const match=value.trim().match(/^prettier-ignore-attribute(?:\\s+([^]+))?$/);if(!match){return false;}if(!match[1]){return true;}return match[1].split(/\\s+/);}/** there's no opening/closing tag or it's considered not breakable */function isTextLikeNode(node){return node.type===\"text\"||node.type===\"comment\";}function isScriptLikeTag(node){return node.type===\"element\"&&(node.fullName===\"script\"||node.fullName===\"style\"||node.fullName===\"svg:style\"||isUnknownNamespace(node)&&(node.name===\"script\"||node.name===\"style\"));}function isFrontMatterNode(node){return node.type===\"yaml\"||node.type===\"toml\";}function canHaveInterpolation(node){return node.children&&!isScriptLikeTag(node);}function isWhitespaceSensitiveNode(node){return isScriptLikeTag(node)||node.type===\"interpolation\"||isIndentationSensitiveNode(node);}function isIndentationSensitiveNode(node){return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");}function isLeadingSpaceSensitiveNode(node){const isLeadingSpaceSensitive=_isLeadingSpaceSensitiveNode();if(isLeadingSpaceSensitive&&!node.prev&&node.parent&&node.parent.tagDefinition&&node.parent.tagDefinition.ignoreFirstLf){return node.type===\"interpolation\";}return isLeadingSpaceSensitive;function _isLeadingSpaceSensitiveNode(){if(isFrontMatterNode(node)){return false;}if((node.type===\"text\"||node.type===\"interpolation\")&&node.prev&&(node.prev.type===\"text\"||node.prev.type===\"interpolation\")){return true;}if(!node.parent||node.parent.cssDisplay===\"none\"){return false;}if(isPreLikeNode(node.parent)){return true;}if(!node.prev&&(node.parent.type===\"root\"||isPreLikeNode(node)&&node.parent||isScriptLikeTag(node.parent)||!isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))){return false;}if(node.prev&&!isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)){return false;}return true;}}function isTrailingSpaceSensitiveNode(node){if(isFrontMatterNode(node)){return false;}if((node.type===\"text\"||node.type===\"interpolation\")&&node.next&&(node.next.type===\"text\"||node.next.type===\"interpolation\")){return true;}if(!node.parent||node.parent.cssDisplay===\"none\"){return false;}if(isPreLikeNode(node.parent)){return true;}if(!node.next&&(node.parent.type===\"root\"||isPreLikeNode(node)&&node.parent||isScriptLikeTag(node.parent)||!isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))){return false;}if(node.next&&!isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)){return false;}return true;}function isDanglingSpaceSensitiveNode(node){return isDanglingSpaceSensitiveCssDisplay(node.cssDisplay)&&!isScriptLikeTag(node);}function forceNextEmptyLine(node){return isFrontMatterNode(node)||node.next&&node.sourceSpan.end.line+1<node.next.sourceSpan.start.line;}/** firstChild leadingSpaces and lastChild trailingSpaces */function forceBreakContent(node){return forceBreakChildren(node)||node.type===\"element\"&&node.children.length!==0&&([\"body\",\"script\",\"style\"].includes(node.name)||node.children.some(child=>hasNonTextChild(child)))||node.firstChild&&node.firstChild===node.lastChild&&hasLeadingLineBreak(node.firstChild)&&(!node.lastChild.isTrailingSpaceSensitive||hasTrailingLineBreak(node.lastChild));}/** spaces between children */function forceBreakChildren(node){return node.type===\"element\"&&node.children.length!==0&&([\"html\",\"head\",\"ul\",\"ol\",\"select\"].includes(node.name)||node.cssDisplay.startsWith(\"table\")&&node.cssDisplay!==\"table-cell\");}function preferHardlineAsLeadingSpaces(node){return preferHardlineAsSurroundingSpaces(node)||node.prev&&preferHardlineAsTrailingSpaces(node.prev)||hasSurroundingLineBreak(node);}function preferHardlineAsTrailingSpaces(node){return preferHardlineAsSurroundingSpaces(node)||node.type===\"element\"&&node.fullName===\"br\"||hasSurroundingLineBreak(node);}function hasSurroundingLineBreak(node){return hasLeadingLineBreak(node)&&hasTrailingLineBreak(node);}function hasLeadingLineBreak(node){return node.hasLeadingSpaces&&(node.prev?node.prev.sourceSpan.end.line<node.sourceSpan.start.line:node.parent.type===\"root\"||node.parent.startSourceSpan.end.line<node.sourceSpan.start.line);}function hasTrailingLineBreak(node){return node.hasTrailingSpaces&&(node.next?node.next.sourceSpan.start.line>node.sourceSpan.end.line:node.parent.type===\"root\"||node.parent.endSourceSpan&&node.parent.endSourceSpan.start.line>node.sourceSpan.end.line);}function preferHardlineAsSurroundingSpaces(node){switch(node.type){case\"ieConditionalComment\":case\"comment\":case\"directive\":return true;case\"element\":return[\"script\",\"select\"].includes(node.name);}return false;}function getLastDescendant(node){return node.lastChild?getLastDescendant(node.lastChild):node;}function hasNonTextChild(node){return node.children&&node.children.some(child=>child.type!==\"text\");}function inferScriptParser(node){if(node.name===\"script\"&&!node.attrMap.src){if(!node.attrMap.lang&&!node.attrMap.type||node.attrMap.type===\"module\"||node.attrMap.type===\"text/javascript\"||node.attrMap.type===\"text/babel\"||node.attrMap.type===\"application/javascript\"||node.attrMap.lang===\"jsx\"){return\"babel\";}if(node.attrMap.type===\"application/x-typescript\"||node.attrMap.lang===\"ts\"||node.attrMap.lang===\"tsx\"){return\"typescript\";}if(node.attrMap.type===\"text/markdown\"){return\"markdown\";}if(node.attrMap.type.endsWith(\"json\")||node.attrMap.type.endsWith(\"importmap\")){return\"json\";}if(node.attrMap.type===\"text/x-handlebars-template\"){return\"glimmer\";}}if(node.name===\"style\"){if(!node.attrMap.lang||node.attrMap.lang===\"postcss\"||node.attrMap.lang===\"css\"){return\"css\";}if(node.attrMap.lang===\"scss\"){return\"scss\";}if(node.attrMap.lang===\"less\"){return\"less\";}}return null;}function isBlockLikeCssDisplay(cssDisplay){return cssDisplay===\"block\"||cssDisplay===\"list-item\"||cssDisplay.startsWith(\"table\");}function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay){return!isBlockLikeCssDisplay(cssDisplay)&&cssDisplay!==\"inline-block\";}function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay){return!isBlockLikeCssDisplay(cssDisplay)&&cssDisplay!==\"inline-block\";}function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay){return!isBlockLikeCssDisplay(cssDisplay);}function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay){return!isBlockLikeCssDisplay(cssDisplay);}function isDanglingSpaceSensitiveCssDisplay(cssDisplay){return!isBlockLikeCssDisplay(cssDisplay)&&cssDisplay!==\"inline-block\";}function isPreLikeNode(node){return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");}function countParents(path){let predicate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:()=>true;let counter=0;for(let i=path.stack.length-1;i>=0;i--){const value=path.stack[i];if(value&&typeof value===\"object\"&&!Array.isArray(value)&&predicate(value)){counter++;}}return counter;}function hasParent(node,fn){let current=node;while(current){if(fn(current)){return true;}current=current.parent;}return false;}function getNodeCssStyleDisplay(node,options){if(node.prev&&node.prev.type===\"comment\"){// <!-- display: block -->\nconst match=node.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);if(match){return match[1];}}let isInSvgForeignObject=false;if(node.type===\"element\"&&node.namespace===\"svg\"){if(hasParent(node,parent=>parent.fullName===\"svg:foreignObject\")){isInSvgForeignObject=true;}else{return node.name===\"svg\"?\"inline-block\":\"block\";}}switch(options.htmlWhitespaceSensitivity){case\"strict\":return\"inline\";case\"ignore\":return\"block\";default:return node.type===\"element\"&&(!node.namespace||isInSvgForeignObject||isUnknownNamespace(node))&&CSS_DISPLAY_TAGS[node.name]||CSS_DISPLAY_DEFAULT;}}function isUnknownNamespace(node){return node.type===\"element\"&&!node.hasExplicitNamespace&&![\"html\",\"svg\"].includes(node.namespace);}function getNodeCssStyleWhiteSpace(node){return node.type===\"element\"&&(!node.namespace||isUnknownNamespace(node))&&CSS_WHITE_SPACE_TAGS[node.name]||CSS_WHITE_SPACE_DEFAULT;}function getMinIndentation(text){let minIndentation=Infinity;for(const lineText of text.split(\"\\n\")){if(lineText.length===0){continue;}if(/\\S/.test(lineText[0])){return 0;}const indentation=lineText.match(/^\\s*/)[0].length;if(lineText.length===indentation){continue;}if(indentation<minIndentation){minIndentation=indentation;}}return minIndentation===Infinity?0:minIndentation;}function dedentString(text){let minIndent=arguments.length>1&&arguments[1]!==undefined?arguments[1]:getMinIndentation(text);return minIndent===0?text:text.split(\"\\n\").map(lineText=>lineText.slice(minIndent)).join(\"\\n\");}function normalizeParts(parts){const newParts=[];const restParts=parts.slice();while(restParts.length!==0){const part=restParts.shift();if(!part){continue;}if(part.type===\"concat\"){restParts.unshift(...part.parts);continue;}if(newParts.length!==0&&typeof newParts[newParts.length-1]===\"string\"&&typeof part===\"string\"){newParts.push(newParts.pop()+part);continue;}newParts.push(part);}return newParts;}function identity(x){return x;}function shouldNotPrintClosingTag(node,options){return!node.isSelfClosing&&!node.endSourceSpan&&(hasPrettierIgnore$2(node)||shouldPreserveContent(node.parent,options));}function countChars(text,char){let counter=0;for(let i=0;i<text.length;i++){if(text[i]===char){counter++;}}return counter;}function unescapeQuoteEntities(text){return text.replace(/&apos;/g,\"'\").replace(/&quot;/g,'\"');}var utils$4={HTML_ELEMENT_ATTRIBUTES,HTML_TAGS,canHaveInterpolation,countChars,countParents,dedentString,forceBreakChildren,forceBreakContent,forceNextEmptyLine,getLastDescendant,getNodeCssStyleDisplay,getNodeCssStyleWhiteSpace,getPrettierIgnoreAttributeCommentData,hasPrettierIgnore:hasPrettierIgnore$2,identity,inferScriptParser,isDanglingSpaceSensitiveNode,isFrontMatterNode,isIndentationSensitiveNode,isLeadingSpaceSensitiveNode,isPreLikeNode,isScriptLikeTag,isTextLikeNode,isTrailingSpaceSensitiveNode,isWhitespaceSensitiveNode,isUnknownNamespace,normalizeParts,preferHardlineAsLeadingSpaces,preferHardlineAsTrailingSpaces,shouldNotPrintClosingTag,shouldPreserveContent,unescapeQuoteEntities};const{canHaveInterpolation:canHaveInterpolation$1,getNodeCssStyleDisplay:getNodeCssStyleDisplay$1,isDanglingSpaceSensitiveNode:isDanglingSpaceSensitiveNode$1,isIndentationSensitiveNode:isIndentationSensitiveNode$1,isLeadingSpaceSensitiveNode:isLeadingSpaceSensitiveNode$1,isTrailingSpaceSensitiveNode:isTrailingSpaceSensitiveNode$1,isWhitespaceSensitiveNode:isWhitespaceSensitiveNode$1}=utils$4;const PREPROCESS_PIPELINE=[removeIgnorableFirstLf,mergeIeConditonalStartEndCommentIntoElementOpeningTag,mergeCdataIntoText,extractInterpolation,extractWhitespaces,addCssDisplay,addIsSelfClosing,addHasHtmComponentClosingTag,addIsSpaceSensitive,mergeSimpleElementIntoText];function preprocess(ast,options){for(const fn of PREPROCESS_PIPELINE){ast=fn(ast,options);}return ast;}function removeIgnorableFirstLf(ast/*, options */){return ast.map(node=>{if(node.type===\"element\"&&node.tagDefinition.ignoreFirstLf&&node.children.length!==0&&node.children[0].type===\"text\"&&node.children[0].value[0]===\"\\n\"){const[text,...rest]=node.children;return node.clone({children:text.value.length===1?rest:[text.clone({value:text.value.slice(1)}),...rest]});}return node;});}function mergeIeConditonalStartEndCommentIntoElementOpeningTag(ast/*, options */){/**\n     *     <!--[if ...]><!--><target><!--<![endif]-->\n     */const isTarget=node=>node.type===\"element\"&&node.prev&&node.prev.type===\"ieConditionalStartComment\"&&node.prev.sourceSpan.end.offset===node.startSourceSpan.start.offset&&node.firstChild&&node.firstChild.type===\"ieConditionalEndComment\"&&node.firstChild.sourceSpan.start.offset===node.startSourceSpan.end.offset;return ast.map(node=>{if(node.children){const isTargetResults=node.children.map(isTarget);if(isTargetResults.some(Boolean)){const newChildren=[];for(let i=0;i<node.children.length;i++){const child=node.children[i];if(isTargetResults[i+1]){// ieConditionalStartComment\ncontinue;}if(isTargetResults[i]){const ieConditionalStartComment=child.prev;const ieConditionalEndComment=child.firstChild;const ParseSourceSpan=child.sourceSpan.constructor;const startSourceSpan=new ParseSourceSpan(ieConditionalStartComment.sourceSpan.start,ieConditionalEndComment.sourceSpan.end);const sourceSpan=new ParseSourceSpan(startSourceSpan.start,child.sourceSpan.end);newChildren.push(child.clone({condition:ieConditionalStartComment.condition,sourceSpan,startSourceSpan,children:child.children.slice(1)}));continue;}newChildren.push(child);}return node.clone({children:newChildren});}}return node;});}function mergeNodeIntoText(ast,shouldMerge,getValue){return ast.map(node=>{if(node.children){const shouldMergeResults=node.children.map(shouldMerge);if(shouldMergeResults.some(Boolean)){const newChildren=[];for(let i=0;i<node.children.length;i++){const child=node.children[i];if(child.type!==\"text\"&&!shouldMergeResults[i]){newChildren.push(child);continue;}const newChild=child.type===\"text\"?child:child.clone({type:\"text\",value:getValue(child)});if(newChildren.length===0||newChildren[newChildren.length-1].type!==\"text\"){newChildren.push(newChild);continue;}const lastChild=newChildren.pop();const ParseSourceSpan=lastChild.sourceSpan.constructor;newChildren.push(lastChild.clone({value:lastChild.value+newChild.value,sourceSpan:new ParseSourceSpan(lastChild.sourceSpan.start,newChild.sourceSpan.end)}));}return node.clone({children:newChildren});}}return node;});}function mergeCdataIntoText(ast/*, options */){return mergeNodeIntoText(ast,node=>node.type===\"cdata\",node=>\"<![CDATA[\".concat(node.value,\"]]>\"));}function mergeSimpleElementIntoText(ast/*, options */){const isSimpleElement=node=>node.type===\"element\"&&node.attrs.length===0&&node.children.length===1&&node.firstChild.type===\"text\"&&// \\xA0: non-breaking whitespace\n!/[^\\S\\xA0]/.test(node.children[0].value)&&!node.firstChild.hasLeadingSpaces&&!node.firstChild.hasTrailingSpaces&&node.isLeadingSpaceSensitive&&!node.hasLeadingSpaces&&node.isTrailingSpaceSensitive&&!node.hasTrailingSpaces&&node.prev&&node.prev.type===\"text\"&&node.next&&node.next.type===\"text\";return ast.map(node=>{if(node.children){const isSimpleElementResults=node.children.map(isSimpleElement);if(isSimpleElementResults.some(Boolean)){const newChildren=[];for(let i=0;i<node.children.length;i++){const child=node.children[i];if(isSimpleElementResults[i]){const lastChild=newChildren.pop();const nextChild=node.children[++i];const ParseSourceSpan=node.sourceSpan.constructor;const{isTrailingSpaceSensitive,hasTrailingSpaces}=nextChild;newChildren.push(lastChild.clone({value:lastChild.value+\"<\".concat(child.rawName,\">\")+child.firstChild.value+\"</\".concat(child.rawName,\">\")+nextChild.value,sourceSpan:new ParseSourceSpan(lastChild.sourceSpan.start,nextChild.sourceSpan.end),isTrailingSpaceSensitive,hasTrailingSpaces}));}else{newChildren.push(child);}}return node.clone({children:newChildren});}}return node;});}function extractInterpolation(ast,options){if(options.parser===\"html\"){return ast;}const interpolationRegex=/\\{\\{([\\s\\S]+?)\\}\\}/g;return ast.map(node=>{if(!canHaveInterpolation$1(node)){return node;}const newChildren=[];for(const child of node.children){if(child.type!==\"text\"){newChildren.push(child);continue;}const ParseSourceSpan=child.sourceSpan.constructor;let startSourceSpan=child.sourceSpan.start;let endSourceSpan=null;const components=child.value.split(interpolationRegex);for(let i=0;i<components.length;i++,startSourceSpan=endSourceSpan){const value=components[i];if(i%2===0){endSourceSpan=startSourceSpan.moveBy(value.length);if(value.length!==0){newChildren.push({type:\"text\",value,sourceSpan:new ParseSourceSpan(startSourceSpan,endSourceSpan)});}continue;}endSourceSpan=startSourceSpan.moveBy(value.length+4);// `{{` + `}}`\nnewChildren.push({type:\"interpolation\",sourceSpan:new ParseSourceSpan(startSourceSpan,endSourceSpan),children:value.length===0?[]:[{type:\"text\",value,sourceSpan:new ParseSourceSpan(startSourceSpan.moveBy(2),endSourceSpan.moveBy(-2))}]});}}return node.clone({children:newChildren});});}/**\n   * - add `hasLeadingSpaces` field\n   * - add `hasTrailingSpaces` field\n   * - add `hasDanglingSpaces` field for parent nodes\n   * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes\n   * - remove insensitive whitespaces\n   */function extractWhitespaces(ast/*, options*/){const TYPE_WHITESPACE=\"whitespace\";return ast.map(node=>{if(!node.children){return node;}if(node.children.length===0||node.children.length===1&&node.children[0].type===\"text\"&&node.children[0].value.trim().length===0){return node.clone({children:[],hasDanglingSpaces:node.children.length!==0});}const isWhitespaceSensitive=isWhitespaceSensitiveNode$1(node);const isIndentationSensitive=isIndentationSensitiveNode$1(node);return node.clone({isWhitespaceSensitive,isIndentationSensitive,children:node.children// extract whitespace nodes\n.reduce((newChildren,child)=>{if(child.type!==\"text\"||isWhitespaceSensitive){return newChildren.concat(child);}const localChildren=[];const[,leadingSpaces,text,trailingSpaces]=child.value.match(/^(\\s*)([\\s\\S]*?)(\\s*)$/);if(leadingSpaces){localChildren.push({type:TYPE_WHITESPACE});}const ParseSourceSpan=child.sourceSpan.constructor;if(text){localChildren.push({type:\"text\",value:text,sourceSpan:new ParseSourceSpan(child.sourceSpan.start.moveBy(leadingSpaces.length),child.sourceSpan.end.moveBy(-trailingSpaces.length))});}if(trailingSpaces){localChildren.push({type:TYPE_WHITESPACE});}return newChildren.concat(localChildren);},[])// set hasLeadingSpaces/hasTrailingSpaces and filter whitespace nodes\n.reduce((newChildren,child,i,children)=>{if(child.type===TYPE_WHITESPACE){return newChildren;}const hasLeadingSpaces=i!==0&&children[i-1].type===TYPE_WHITESPACE;const hasTrailingSpaces=i!==children.length-1&&children[i+1].type===TYPE_WHITESPACE;return newChildren.concat(Object.assign({},child,{hasLeadingSpaces,hasTrailingSpaces}));},[])});});}function addIsSelfClosing(ast/*, options */){return ast.map(node=>Object.assign(node,{isSelfClosing:!node.children||node.type===\"element\"&&(node.tagDefinition.isVoid||// self-closing\nnode.startSourceSpan===node.endSourceSpan)}));}function addHasHtmComponentClosingTag(ast,options){return ast.map(node=>node.type!==\"element\"?node:Object.assign(node,{hasHtmComponentClosingTag:node.endSourceSpan&&/^<\\s*\\/\\s*\\/\\s*>$/.test(options.originalText.slice(node.endSourceSpan.start.offset,node.endSourceSpan.end.offset))}));}function addCssDisplay(ast,options){return ast.map(node=>Object.assign(node,{cssDisplay:getNodeCssStyleDisplay$1(node,options)}));}/**\n   * - add `isLeadingSpaceSensitive` field\n   * - add `isTrailingSpaceSensitive` field\n   * - add `isDanglingSpaceSensitive` field for parent nodes\n   */function addIsSpaceSensitive(ast/*, options */){return ast.map(node=>{if(!node.children){return node;}if(node.children.length===0){return node.clone({isDanglingSpaceSensitive:isDanglingSpaceSensitiveNode$1(node)});}return node.clone({children:node.children.map(child=>{return Object.assign({},child,{isLeadingSpaceSensitive:isLeadingSpaceSensitiveNode$1(child),isTrailingSpaceSensitive:isTrailingSpaceSensitiveNode$1(child)});}).map((child,index,children)=>Object.assign({},child,{isLeadingSpaceSensitive:index===0?child.isLeadingSpaceSensitive:children[index-1].isTrailingSpaceSensitive&&child.isLeadingSpaceSensitive,isTrailingSpaceSensitive:index===children.length-1?child.isTrailingSpaceSensitive:children[index+1].isLeadingSpaceSensitive&&child.isTrailingSpaceSensitive}))});});}var preprocess_1=preprocess;function hasPragma$3(text){return /^\\s*<!--\\s*@(format|prettier)\\s*-->/.test(text);}function insertPragma$5(text){return\"<!-- @format -->\\n\\n\"+text.replace(/^\\s*\\n/,\"\");}var pragma$3={hasPragma:hasPragma$3,insertPragma:insertPragma$5};const{builders:{concat:concat$8,group:group$8}}=document;/**\n   *     v-for=\"... in ...\"\n   *     v-for=\"... of ...\"\n   *     v-for=\"(..., ...) in ...\"\n   *     v-for=\"(..., ...) of ...\"\n   */function printVueFor(value,textToDoc){const{left,operator,right}=parseVueFor(value);return concat$8([group$8(textToDoc(\"function _(\".concat(left,\") {}\"),{parser:\"babel\",__isVueForBindingLeft:true})),\" \",operator,\" \",textToDoc(right,{parser:\"__js_expression\"})]);}// modified from https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/parser/index.js#L370-L387\nfunction parseVueFor(value){const forAliasRE=/([^]*?)\\s+(in|of)\\s+([^]*)/;const forIteratorRE=/,([^,}\\]]*)(?:,([^,}\\]]*))?$/;const stripParensRE=/^\\(|\\)$/g;const inMatch=value.match(forAliasRE);if(!inMatch){return;}const res={};res.for=inMatch[3].trim();const alias=inMatch[1].trim().replace(stripParensRE,\"\");const iteratorMatch=alias.match(forIteratorRE);if(iteratorMatch){res.alias=alias.replace(forIteratorRE,\"\");res.iterator1=iteratorMatch[1].trim();if(iteratorMatch[2]){res.iterator2=iteratorMatch[2].trim();}}else{res.alias=alias;}return{left:\"\".concat([res.alias,res.iterator1,res.iterator2].filter(Boolean).join(\",\")),operator:inMatch[2],right:res.for};}function printVueSlotScope(value,textToDoc){return textToDoc(\"function _(\".concat(value,\") {}\"),{parser:\"babel\",__isVueSlotScope:true});}function isVueEventBindingExpression(eventBindingValue){// https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/codegen/events.js#L3-L4\n// arrow function or anonymous function\nconst fnExpRE=/^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;// simple member expression chain (a, a.b, a['b'], a[\"b\"], a[0], a[b])\nconst simplePathRE=/^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;// https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/helpers.js#L104\nconst value=eventBindingValue.trim();return fnExpRE.test(value)||simplePathRE.test(value);}var syntaxVue={isVueEventBindingExpression,printVueFor,printVueSlotScope};const integerRegex=/^\\d+$/;function deepUnique(array){return array.sort().filter((element,index)=>{return JSON.stringify(element)!==JSON.stringify(array[index-1]);});}var parse$2=string=>{return deepUnique(string.split(',').map(part=>{const result={};part.trim().split(/\\s+/).forEach((element,index)=>{if(index===0){result.url=element;return;}const value=element.slice(0,element.length-1);const postfix=element[element.length-1];const integerValue=parseInt(value,10);const floatValue=parseFloat(value);if(postfix==='w'&&integerRegex.test(value)){result.width=integerValue;}else if(postfix==='h'&&integerRegex.test(value)){result.height=integerValue;}else if(postfix==='x'&&!Number.isNaN(floatValue)){result.density=floatValue;}else{throw new Error(\"Invalid srcset descriptor: \".concat(element));}});return result;}));};var stringify=array=>{return[...new Set(array.map(element=>{if(!element.url){throw new Error('URL is required');}const result=[element.url];if(element.width){result.push(\"\".concat(element.width,\"w\"));}if(element.height){result.push(\"\".concat(element.height,\"h\"));}if(element.density){result.push(\"\".concat(element.density,\"x\"));}return result.join(' ');}))].join(', ');};var srcset={parse:parse$2,stringify:stringify};const{builders:{concat:concat$9,ifBreak:ifBreak$4,join:join$5,line:line$5}}=document;const parseSrcset=srcset.parse;function printImgSrcset(value){const srcset=parseSrcset(value);const hasW=srcset.some(src=>src.width);const hasH=srcset.some(src=>src.height);const hasX=srcset.some(src=>src.density);if(hasW+hasH+hasX>1){throw new Error(\"Mixed descriptor in srcset is not supported\");}const key=hasW?\"width\":hasH?\"height\":\"density\";const unit=hasW?\"w\":hasH?\"h\":\"x\";const getMax=values=>Math.max(...values);const urls=srcset.map(src=>src.url);const maxUrlLength=getMax(urls.map(url=>url.length));const descriptors=srcset.map(src=>src[key]).map(descriptor=>descriptor?descriptor.toString():\"\");const descriptorLeftLengths=descriptors.map(descriptor=>{const index=descriptor.indexOf(\".\");return index===-1?descriptor.length:index;});const maxDescriptorLeftLength=getMax(descriptorLeftLengths);return join$5(concat$9([\",\",line$5]),urls.map((url,index)=>{const parts=[url];const descriptor=descriptors[index];if(descriptor){const urlPadding=maxUrlLength-url.length+1;const descriptorPadding=maxDescriptorLeftLength-descriptorLeftLengths[index];const alignment=\" \".repeat(urlPadding+descriptorPadding);parts.push(ifBreak$4(alignment,\" \"),descriptor+unit);}return concat$9(parts);}));}function printClassNames(value){return value.trim().split(/\\s+/).join(\" \");}var syntaxAttribute={printImgSrcset,printClassNames};const{builders,utils:{stripTrailingHardline:stripTrailingHardline$1,mapDoc:mapDoc$2}}=document;const{breakParent:breakParent$2,dedentToRoot:dedentToRoot$1,fill:fill$3,group:group$9,hardline:hardline$7,ifBreak:ifBreak$5,indent:indent$5,join:join$6,line:line$6,literalline:literalline$2,markAsRoot:markAsRoot$2,softline:softline$4}=builders;const{countChars:countChars$1,countParents:countParents$1,dedentString:dedentString$1,forceBreakChildren:forceBreakChildren$1,forceBreakContent:forceBreakContent$1,forceNextEmptyLine:forceNextEmptyLine$1,getLastDescendant:getLastDescendant$1,getPrettierIgnoreAttributeCommentData:getPrettierIgnoreAttributeCommentData$1,hasPrettierIgnore:hasPrettierIgnore$3,inferScriptParser:inferScriptParser$1,isScriptLikeTag:isScriptLikeTag$1,isTextLikeNode:isTextLikeNode$1,normalizeParts:normalizeParts$1,preferHardlineAsLeadingSpaces:preferHardlineAsLeadingSpaces$1,shouldNotPrintClosingTag:shouldNotPrintClosingTag$1,shouldPreserveContent:shouldPreserveContent$1,unescapeQuoteEntities:unescapeQuoteEntities$1}=utils$4;const{replaceEndOfLineWith:replaceEndOfLineWith$1}=util$1;const{insertPragma:insertPragma$6}=pragma$3;const{printVueFor:printVueFor$1,printVueSlotScope:printVueSlotScope$1,isVueEventBindingExpression:isVueEventBindingExpression$1}=syntaxVue;const{printImgSrcset:printImgSrcset$1,printClassNames:printClassNames$1}=syntaxAttribute;function concat$a(parts){const newParts=normalizeParts$1(parts);return newParts.length===0?\"\":newParts.length===1?newParts[0]:builders.concat(newParts);}function embed$2(path,print,textToDoc,options){const node=path.getValue();switch(node.type){case\"text\":{if(isScriptLikeTag$1(node.parent)){const parser=inferScriptParser$1(node.parent);if(parser){const value=parser===\"markdown\"?dedentString$1(node.value.replace(/^[^\\S\\n]*?\\n/,\"\")):node.value;return builders.concat([concat$a([breakParent$2,printOpeningTagPrefix(node,options),stripTrailingHardline$1(textToDoc(value,{parser})),printClosingTagSuffix(node,options)])]);}}else if(node.parent.type===\"interpolation\"){return concat$a([indent$5(concat$a([line$6,textToDoc(node.value,Object.assign({__isInHtmlInterpolation:true},options.parser===\"angular\"?{parser:\"__ng_interpolation\",trailingComma:\"none\"}:options.parser===\"vue\"?{parser:\"__vue_expression\"}:{parser:\"__js_expression\"}))])),node.parent.next&&needsToBorrowPrevClosingTagEndMarker(node.parent.next)?\" \":line$6]);}break;}case\"attribute\":{if(!node.value){break;}// lit-html: html`<my-element obj=${obj}></my-element>`\nif(/^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(options.originalText.slice(node.valueSpan.start.offset,node.valueSpan.end.offset))){return concat$a([node.rawName,\"=\",node.value]);}// lwc: html`<my-element data-for={value}></my-element>`\nif(options.parser===\"lwc\"){const interpolationRegex=/^\\{[\\s\\S]*\\}$/;if(interpolationRegex.test(options.originalText.slice(node.valueSpan.start.offset,node.valueSpan.end.offset))){return concat$a([node.rawName,\"=\",node.value]);}}const embeddedAttributeValueDoc=printEmbeddedAttributeValue(node,(code,opts)=>// strictly prefer single quote to avoid unnecessary html entity escape\ntextToDoc(code,Object.assign({__isInHtmlAttribute:true},opts)),options);if(embeddedAttributeValueDoc){return concat$a([node.rawName,'=\"',group$9(mapDoc$2(embeddedAttributeValueDoc,doc=>typeof doc===\"string\"?doc.replace(/\"/g,\"&quot;\"):doc)),'\"']);}break;}case\"yaml\":return markAsRoot$2(concat$a([\"---\",hardline$7,node.value.trim().length===0?\"\":textToDoc(node.value,{parser:\"yaml\"}),\"---\"]));}}function genericPrint$2(path,options,print){const node=path.getValue();switch(node.type){case\"root\":if(options.__onHtmlRoot){options.__onHtmlRoot(node);}// use original concat to not break stripTrailingHardline\nreturn builders.concat([group$9(printChildren$1(path,options,print)),hardline$7]);case\"element\":case\"ieConditionalComment\":{/**\n           * do not break:\n           *\n           *     <div>{{\n           *         ~\n           *       interpolation\n           *     }}</div>\n           *            ~\n           *\n           * exception: break if the opening tag breaks\n           *\n           *     <div\n           *       long\n           *           ~\n           *       >{{\n           *         interpolation\n           *       }}</div\n           *              ~\n           *     >\n           */const shouldHugContent=node.children.length===1&&node.firstChild.type===\"interpolation\"&&node.firstChild.isLeadingSpaceSensitive&&!node.firstChild.hasLeadingSpaces&&node.lastChild.isTrailingSpaceSensitive&&!node.lastChild.hasTrailingSpaces;const attrGroupId=Symbol(\"element-attr-group-id\");return concat$a([group$9(concat$a([group$9(printOpeningTag(path,options,print),{id:attrGroupId}),node.children.length===0?node.hasDanglingSpaces&&node.isDanglingSpaceSensitive?line$6:\"\":concat$a([forceBreakContent$1(node)?breakParent$2:\"\",(childrenDoc=>shouldHugContent?ifBreak$5(indent$5(childrenDoc),childrenDoc,{groupId:attrGroupId}):isScriptLikeTag$1(node)&&node.parent.type===\"root\"&&options.parser===\"vue\"&&!options.vueIndentScriptAndStyle?childrenDoc:indent$5(childrenDoc))(concat$a([shouldHugContent?ifBreak$5(softline$4,\"\",{groupId:attrGroupId}):node.firstChild.hasLeadingSpaces&&node.firstChild.isLeadingSpaceSensitive?line$6:node.firstChild.type===\"text\"&&node.isWhitespaceSensitive&&node.isIndentationSensitive?dedentToRoot$1(softline$4):softline$4,printChildren$1(path,options,print)])),(node.next?needsToBorrowPrevClosingTagEndMarker(node.next):needsToBorrowLastChildClosingTagEndMarker(node.parent))?node.lastChild.hasTrailingSpaces&&node.lastChild.isTrailingSpaceSensitive?\" \":\"\":shouldHugContent?ifBreak$5(softline$4,\"\",{groupId:attrGroupId}):node.lastChild.hasTrailingSpaces&&node.lastChild.isTrailingSpaceSensitive?line$6:(node.lastChild.type===\"comment\"||node.lastChild.type===\"text\"&&node.isWhitespaceSensitive&&node.isIndentationSensitive)&&new RegExp(\"\\\\n\\\\s{\".concat(options.tabWidth*countParents$1(path,n=>n.parent&&n.parent.type!==\"root\"),\"}$\")).test(node.lastChild.value)?/**\n           *     <div>\n           *       <pre>\n           *         something\n           *       </pre>\n           *            ~\n           *     </div>\n           */\"\":softline$4])])),printClosingTag(node,options)]);}case\"ieConditionalStartComment\":case\"ieConditionalEndComment\":return concat$a([printOpeningTagStart(node),printClosingTagEnd(node)]);case\"interpolation\":return concat$a([printOpeningTagStart(node,options),concat$a(path.map(print,\"children\")),printClosingTagEnd(node,options)]);case\"text\":{if(node.parent.type===\"interpolation\"){// replace the trailing literalline with hardline for better readability\nconst trailingNewlineRegex=/\\n[^\\S\\n]*?$/;const hasTrailingNewline=trailingNewlineRegex.test(node.value);const value=hasTrailingNewline?node.value.replace(trailingNewlineRegex,\"\"):node.value;return concat$a([concat$a(replaceEndOfLineWith$1(value,literalline$2)),hasTrailingNewline?hardline$7:\"\"]);}return fill$3(normalizeParts$1([].concat(printOpeningTagPrefix(node,options),getTextValueParts(node),printClosingTagSuffix(node,options))));}case\"docType\":return concat$a([group$9(concat$a([printOpeningTagStart(node,options),\" \",node.value.replace(/^html\\b/i,\"html\").replace(/\\s+/g,\" \")])),printClosingTagEnd(node,options)]);case\"comment\":{return concat$a([printOpeningTagPrefix(node,options),concat$a(replaceEndOfLineWith$1(options.originalText.slice(options.locStart(node),options.locEnd(node)),literalline$2)),printClosingTagSuffix(node,options)]);}case\"attribute\":{if(node.value===null){return node.rawName;}const value=unescapeQuoteEntities$1(node.value);const singleQuoteCount=countChars$1(value,\"'\");const doubleQuoteCount=countChars$1(value,'\"');const quote=singleQuoteCount<doubleQuoteCount?\"'\":'\"';return concat$a([node.rawName,concat$a([\"=\",quote,concat$a(replaceEndOfLineWith$1(quote==='\"'?value.replace(/\"/g,\"&quot;\"):value.replace(/'/g,\"&apos;\"),literalline$2)),quote])]);}case\"yaml\":case\"toml\":return concat$a(replaceEndOfLineWith$1(node.raw,literalline$2));default:throw new Error(\"Unexpected node type \".concat(node.type));}}function printChildren$1(path,options,print){const node=path.getValue();if(forceBreakChildren$1(node)){return concat$a([breakParent$2,concat$a(path.map(childPath=>{const childNode=childPath.getValue();const prevBetweenLine=!childNode.prev?\"\":printBetweenLine(childNode.prev,childNode);return concat$a([!prevBetweenLine?\"\":concat$a([prevBetweenLine,forceNextEmptyLine$1(childNode.prev)?hardline$7:\"\"]),printChild(childPath)]);},\"children\"))]);}const groupIds=node.children.map(()=>Symbol(\"\"));return concat$a(path.map((childPath,childIndex)=>{const childNode=childPath.getValue();if(isTextLikeNode$1(childNode)){if(childNode.prev&&isTextLikeNode$1(childNode.prev)){const prevBetweenLine=printBetweenLine(childNode.prev,childNode);if(prevBetweenLine){if(forceNextEmptyLine$1(childNode.prev)){return concat$a([hardline$7,hardline$7,printChild(childPath)]);}return concat$a([prevBetweenLine,printChild(childPath)]);}}return printChild(childPath);}const prevParts=[];const leadingParts=[];const trailingParts=[];const nextParts=[];const prevBetweenLine=childNode.prev?printBetweenLine(childNode.prev,childNode):\"\";const nextBetweenLine=childNode.next?printBetweenLine(childNode,childNode.next):\"\";if(prevBetweenLine){if(forceNextEmptyLine$1(childNode.prev)){prevParts.push(hardline$7,hardline$7);}else if(prevBetweenLine===hardline$7){prevParts.push(hardline$7);}else{if(isTextLikeNode$1(childNode.prev)){leadingParts.push(prevBetweenLine);}else{leadingParts.push(ifBreak$5(\"\",softline$4,{groupId:groupIds[childIndex-1]}));}}}if(nextBetweenLine){if(forceNextEmptyLine$1(childNode)){if(isTextLikeNode$1(childNode.next)){nextParts.push(hardline$7,hardline$7);}}else if(nextBetweenLine===hardline$7){if(isTextLikeNode$1(childNode.next)){nextParts.push(hardline$7);}}else{trailingParts.push(nextBetweenLine);}}return concat$a([].concat(prevParts,group$9(concat$a([concat$a(leadingParts),group$9(concat$a([printChild(childPath),concat$a(trailingParts)]),{id:groupIds[childIndex]})])),nextParts));},\"children\"));function printChild(childPath){const child=childPath.getValue();if(hasPrettierIgnore$3(child)){return concat$a([].concat(printOpeningTagPrefix(child,options),replaceEndOfLineWith$1(options.originalText.slice(options.locStart(child)+(child.prev&&needsToBorrowNextOpeningTagStartMarker(child.prev)?printOpeningTagStartMarker(child).length:0),options.locEnd(child)-(child.next&&needsToBorrowPrevClosingTagEndMarker(child.next)?printClosingTagEndMarker(child,options).length:0)),literalline$2),printClosingTagSuffix(child,options)));}if(shouldPreserveContent$1(child,options)){return concat$a([].concat(printOpeningTagPrefix(child,options),group$9(printOpeningTag(childPath,options,print)),replaceEndOfLineWith$1(options.originalText.slice(child.startSourceSpan.end.offset+(child.firstChild&&needsToBorrowParentOpeningTagEndMarker(child.firstChild)?-printOpeningTagEndMarker(child).length:0),child.endSourceSpan.start.offset+(child.lastChild&&needsToBorrowParentClosingTagStartMarker(child.lastChild)?printClosingTagStartMarker(child,options).length:needsToBorrowLastChildClosingTagEndMarker(child)?-printClosingTagEndMarker(child.lastChild,options).length:0)),literalline$2),printClosingTag(child,options),printClosingTagSuffix(child,options)));}return print(childPath);}function printBetweenLine(prevNode,nextNode){return isTextLikeNode$1(prevNode)&&isTextLikeNode$1(nextNode)?prevNode.isTrailingSpaceSensitive?prevNode.hasTrailingSpaces?preferHardlineAsLeadingSpaces$1(nextNode)?hardline$7:line$6:\"\":preferHardlineAsLeadingSpaces$1(nextNode)?hardline$7:softline$4:needsToBorrowNextOpeningTagStartMarker(prevNode)&&(hasPrettierIgnore$3(nextNode)||/**\n       *     123<a\n       *          ~\n       *       ><b>\n       */nextNode.firstChild||/**\n       *     123<!--\n       *            ~\n       *     -->\n       */nextNode.isSelfClosing||/**\n       *     123<span\n       *             ~\n       *       attr\n       */nextNode.type===\"element\"&&nextNode.attrs.length!==0)||/**\n       *     <img\n       *       src=\"long\"\n       *                 ~\n       *     />123\n       */prevNode.type===\"element\"&&prevNode.isSelfClosing&&needsToBorrowPrevClosingTagEndMarker(nextNode)?\"\":!nextNode.isLeadingSpaceSensitive||preferHardlineAsLeadingSpaces$1(nextNode)||/**\n       *       Want to write us a letter? Use our<a\n       *         ><b><a>mailing address</a></b></a\n       *                                          ~\n       *       >.\n       */needsToBorrowPrevClosingTagEndMarker(nextNode)&&prevNode.lastChild&&needsToBorrowParentClosingTagStartMarker(prevNode.lastChild)&&prevNode.lastChild.lastChild&&needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild)?hardline$7:nextNode.hasLeadingSpaces?line$6:softline$4;}}function printOpeningTag(path,options,print){const node=path.getValue();const forceNotToBreakAttrContent=node.type===\"element\"&&node.fullName===\"script\"&&node.attrs.length===1&&node.attrs[0].fullName===\"src\"&&node.children.length===0;return concat$a([printOpeningTagStart(node,options),!node.attrs||node.attrs.length===0?node.isSelfClosing?/**\n     *     <br />\n     *        ^\n     */\" \":\"\":concat$a([indent$5(concat$a([forceNotToBreakAttrContent?\" \":line$6,join$6(line$6,(ignoreAttributeData=>{const hasPrettierIgnoreAttribute=typeof ignoreAttributeData===\"boolean\"?()=>ignoreAttributeData:Array.isArray(ignoreAttributeData)?attr=>ignoreAttributeData.includes(attr.rawName):()=>false;return path.map(attrPath=>{const attr=attrPath.getValue();return hasPrettierIgnoreAttribute(attr)?concat$a(replaceEndOfLineWith$1(options.originalText.slice(options.locStart(attr),options.locEnd(attr)),literalline$2)):print(attrPath);},\"attrs\");})(node.prev&&node.prev.type===\"comment\"&&getPrettierIgnoreAttributeCommentData$1(node.prev.value)))])),/**\n     *     123<a\n     *       attr\n     *           ~\n     *       >456\n     */node.firstChild&&needsToBorrowParentOpeningTagEndMarker(node.firstChild)||/**\n     *     <span\n     *       >123<meta\n     *                ~\n     *     /></span>\n     */node.isSelfClosing&&needsToBorrowLastChildClosingTagEndMarker(node.parent)?node.isSelfClosing?\" \":\"\":node.isSelfClosing?forceNotToBreakAttrContent?\" \":line$6:forceNotToBreakAttrContent?\"\":softline$4]),node.isSelfClosing?\"\":printOpeningTagEnd(node)]);}function printOpeningTagStart(node,options){return node.prev&&needsToBorrowNextOpeningTagStartMarker(node.prev)?\"\":concat$a([printOpeningTagPrefix(node,options),printOpeningTagStartMarker(node)]);}function printOpeningTagEnd(node){return node.firstChild&&needsToBorrowParentOpeningTagEndMarker(node.firstChild)?\"\":printOpeningTagEndMarker(node);}function printClosingTag(node,options){return concat$a([node.isSelfClosing?\"\":printClosingTagStart(node,options),printClosingTagEnd(node,options)]);}function printClosingTagStart(node,options){return node.lastChild&&needsToBorrowParentClosingTagStartMarker(node.lastChild)?\"\":concat$a([printClosingTagPrefix(node,options),printClosingTagStartMarker(node,options)]);}function printClosingTagEnd(node,options){return(node.next?needsToBorrowPrevClosingTagEndMarker(node.next):needsToBorrowLastChildClosingTagEndMarker(node.parent))?\"\":concat$a([printClosingTagEndMarker(node,options),printClosingTagSuffix(node,options)]);}function needsToBorrowNextOpeningTagStartMarker(node){/**\n     *     123<p\n     *        ^^\n     *     >\n     */return node.next&&!isTextLikeNode$1(node.next)&&isTextLikeNode$1(node)&&node.isTrailingSpaceSensitive&&!node.hasTrailingSpaces;}function needsToBorrowParentOpeningTagEndMarker(node){/**\n     *     <p\n     *       >123\n     *       ^\n     *\n     *     <p\n     *       ><a\n     *       ^\n     */return!node.prev&&node.isLeadingSpaceSensitive&&!node.hasLeadingSpaces;}function needsToBorrowPrevClosingTagEndMarker(node){/**\n     *     <p></p\n     *     >123\n     *     ^\n     *\n     *     <p></p\n     *     ><a\n     *     ^\n     */return node.prev&&!isTextLikeNode$1(node.prev)&&node.isLeadingSpaceSensitive&&!node.hasLeadingSpaces;}function needsToBorrowLastChildClosingTagEndMarker(node){/**\n     *     <p\n     *       ><a></a\n     *       ></p\n     *       ^\n     *     >\n     */return node.lastChild&&node.lastChild.isTrailingSpaceSensitive&&!node.lastChild.hasTrailingSpaces&&!isTextLikeNode$1(getLastDescendant$1(node.lastChild));}function needsToBorrowParentClosingTagStartMarker(node){/**\n     *     <p>\n     *       123</p\n     *          ^^^\n     *     >\n     *\n     *         123</b\n     *       ></a\n     *        ^^^\n     *     >\n     */return!node.next&&!node.hasTrailingSpaces&&node.isTrailingSpaceSensitive&&isTextLikeNode$1(getLastDescendant$1(node));}function printOpeningTagPrefix(node,options){return needsToBorrowParentOpeningTagEndMarker(node)?printOpeningTagEndMarker(node.parent):needsToBorrowPrevClosingTagEndMarker(node)?printClosingTagEndMarker(node.prev,options):\"\";}function printClosingTagPrefix(node,options){return needsToBorrowLastChildClosingTagEndMarker(node)?printClosingTagEndMarker(node.lastChild,options):\"\";}function printClosingTagSuffix(node,options){return needsToBorrowParentClosingTagStartMarker(node)?printClosingTagStartMarker(node.parent,options):needsToBorrowNextOpeningTagStartMarker(node)?printOpeningTagStartMarker(node.next):\"\";}function printOpeningTagStartMarker(node){switch(node.type){case\"ieConditionalComment\":case\"ieConditionalStartComment\":return\"<!--[if \".concat(node.condition);case\"ieConditionalEndComment\":return\"<!--<!\";case\"interpolation\":return\"{{\";case\"docType\":return\"<!DOCTYPE\";case\"element\":if(node.condition){return\"<!--[if \".concat(node.condition,\"]><!--><\").concat(node.rawName);}// fall through\ndefault:return\"<\".concat(node.rawName);}}function printOpeningTagEndMarker(node){assert(!node.isSelfClosing);switch(node.type){case\"ieConditionalComment\":return\"]>\";case\"element\":if(node.condition){return\"><!--<![endif]-->\";}// fall through\ndefault:return\">\";}}function printClosingTagStartMarker(node,options){assert(!node.isSelfClosing);if(shouldNotPrintClosingTag$1(node,options)){return\"\";}switch(node.type){case\"ieConditionalComment\":return\"<!\";case\"element\":if(node.hasHtmComponentClosingTag){return\"<//\";}// fall through\ndefault:return\"</\".concat(node.rawName);}}function printClosingTagEndMarker(node,options){if(shouldNotPrintClosingTag$1(node,options)){return\"\";}switch(node.type){case\"ieConditionalComment\":case\"ieConditionalEndComment\":return\"[endif]-->\";case\"ieConditionalStartComment\":return\"]><!-->\";case\"interpolation\":return\"}}\";case\"element\":if(node.isSelfClosing){return\"/>\";}// fall through\ndefault:return\">\";}}function getTextValueParts(node){let value=arguments.length>1&&arguments[1]!==undefined?arguments[1]:node.value;return node.parent.isWhitespaceSensitive?node.parent.isIndentationSensitive?replaceEndOfLineWith$1(value,literalline$2):replaceEndOfLineWith$1(dedentString$1(value.replace(/^\\s*?\\n|\\n\\s*?$/g,\"\")),hardline$7):// https://infra.spec.whatwg.org/#ascii-whitespace\njoin$6(line$6,value.split(/[\\t\\n\\f\\r ]+/)).parts;}function printEmbeddedAttributeValue(node,originalTextToDoc,options){const isKeyMatched=patterns=>new RegExp(patterns.join(\"|\")).test(node.fullName);const getValue=()=>unescapeQuoteEntities$1(node.value);let shouldHug=false;const __onHtmlBindingRoot=(root,options)=>{const rootNode=root.type===\"NGRoot\"?root.node.type===\"NGMicrosyntax\"&&root.node.body.length===1&&root.node.body[0].type===\"NGMicrosyntaxExpression\"?root.node.body[0].expression:root.node:root.type===\"JsExpressionRoot\"?root.node:root;if(rootNode&&(rootNode.type===\"ObjectExpression\"||rootNode.type===\"ArrayExpression\"||options.parser===\"__vue_expression\"&&(rootNode.type===\"TemplateLiteral\"||rootNode.type===\"StringLiteral\"))){shouldHug=true;}};const printHug=doc=>group$9(doc);const printExpand=function(doc){let canHaveTrailingWhitespace=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;return group$9(concat$a([indent$5(concat$a([softline$4,doc])),canHaveTrailingWhitespace?softline$4:\"\"]));};const printMaybeHug=doc=>shouldHug?printHug(doc):printExpand(doc);const textToDoc=(code,opts)=>originalTextToDoc(code,Object.assign({__onHtmlBindingRoot},opts));if(node.fullName===\"srcset\"&&(node.parent.fullName===\"img\"||node.parent.fullName===\"source\")){return printExpand(printImgSrcset$1(getValue()));}if(node.fullName===\"class\"&&!options.parentParser){const value=getValue();if(!value.includes(\"{{\")){return printClassNames$1(value);}}if(node.fullName===\"style\"&&!options.parentParser){const value=getValue();if(!value.includes(\"{{\")){return printExpand(textToDoc(value,{parser:\"css\",__isHTMLStyleAttribute:true}));}}if(options.parser===\"vue\"){if(node.fullName===\"v-for\"){return printVueFor$1(getValue(),textToDoc);}if(node.fullName===\"slot-scope\"){return printVueSlotScope$1(getValue(),textToDoc);}/**\n       *     @click=\"jsStatement\"\n       *     @click=\"jsExpression\"\n       *     v-on:click=\"jsStatement\"\n       *     v-on:click=\"jsExpression\"\n       */const vueEventBindingPatterns=[\"^@\",\"^v-on:\"];/**\n       *     :class=\"vueExpression\"\n       *     v-bind:id=\"vueExpression\"\n       */const vueExpressionBindingPatterns=[\"^:\",\"^v-bind:\"];/**\n       *     v-if=\"jsExpression\"\n       */const jsExpressionBindingPatterns=[\"^v-\"];if(isKeyMatched(vueEventBindingPatterns)){const value=getValue();return printMaybeHug(isVueEventBindingExpression$1(value)?textToDoc(value,{parser:\"__js_expression\"}):stripTrailingHardline$1(textToDoc(value,{parser:\"__vue_event_binding\"})));}if(isKeyMatched(vueExpressionBindingPatterns)){return printMaybeHug(textToDoc(getValue(),{parser:\"__vue_expression\"}));}if(isKeyMatched(jsExpressionBindingPatterns)){return printMaybeHug(textToDoc(getValue(),{parser:\"__js_expression\"}));}}if(options.parser===\"angular\"){const ngTextToDoc=(code,opts)=>// angular does not allow trailing comma\ntextToDoc(code,Object.assign({},opts,{trailingComma:\"none\"}));/**\n       *     *directive=\"angularDirective\"\n       */const ngDirectiveBindingPatterns=[\"^\\\\*\"];/**\n       *     (click)=\"angularStatement\"\n       *     on-click=\"angularStatement\"\n       */const ngStatementBindingPatterns=[\"^\\\\(.+\\\\)$\",\"^on-\"];/**\n       *     [target]=\"angularExpression\"\n       *     bind-target=\"angularExpression\"\n       *     [(target)]=\"angularExpression\"\n       *     bindon-target=\"angularExpression\"\n       */const ngExpressionBindingPatterns=[\"^\\\\[.+\\\\]$\",\"^bind(on)?-\",// Unofficial rudimentary support for some of the most used directives of AngularJS 1.x\n\"^ng-(if|show|hide|class|style)$\"];/**\n       *     i18n=\"longDescription\"\n       *     i18n-attr=\"longDescription\"\n       */const ngI18nPatterns=[\"^i18n(-.+)?$\"];if(isKeyMatched(ngStatementBindingPatterns)){return printMaybeHug(ngTextToDoc(getValue(),{parser:\"__ng_action\"}));}if(isKeyMatched(ngExpressionBindingPatterns)){return printMaybeHug(ngTextToDoc(getValue(),{parser:\"__ng_binding\"}));}if(isKeyMatched(ngI18nPatterns)){const value=getValue().trim();return printExpand(fill$3(getTextValueParts(node,value)),!value.includes(\"@@\"));}if(isKeyMatched(ngDirectiveBindingPatterns)){return printMaybeHug(ngTextToDoc(getValue(),{parser:\"__ng_directive\"}));}const interpolationRegex=/\\{\\{([\\s\\S]+?)\\}\\}/g;const value=getValue();if(interpolationRegex.test(value)){const parts=[];value.split(interpolationRegex).forEach((part,index)=>{if(index%2===0){parts.push(concat$a(replaceEndOfLineWith$1(part,literalline$2)));}else{try{parts.push(group$9(concat$a([\"{{\",indent$5(concat$a([line$6,ngTextToDoc(part,{parser:\"__ng_interpolation\",__isInHtmlInterpolation:true// to avoid unexpected `}}`\n})])),line$6,\"}}\"])));}catch(e){parts.push(\"{{\",concat$a(replaceEndOfLineWith$1(part,literalline$2)),\"}}\");}}});return group$9(concat$a(parts));}}return null;}var printerHtml={preprocess:preprocess_1,print:genericPrint$2,insertPragma:insertPragma$6,massageAstNode:clean$3,embed:embed$2};const CATEGORY_HTML=\"HTML\";// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\nvar options$4={htmlWhitespaceSensitivity:{since:\"1.15.0\",category:CATEGORY_HTML,type:\"choice\",default:\"css\",description:\"How to handle whitespaces in HTML.\",choices:[{value:\"css\",description:\"Respect the default value of CSS display property.\"},{value:\"strict\",description:\"Whitespaces are considered sensitive.\"},{value:\"ignore\",description:\"Whitespaces are considered insensitive.\"}]},vueIndentScriptAndStyle:{since:\"1.19.0\",category:CATEGORY_HTML,type:\"boolean\",default:false,description:\"Indent script and style tags in Vue files.\"}};var name$7=\"HTML\";var type$6=\"markup\";var tmScope$6=\"text.html.basic\";var aceMode$6=\"html\";var codemirrorMode$3=\"htmlmixed\";var codemirrorMimeType$3=\"text/html\";var color$1=\"#e34c26\";var aliases$1=[\"xhtml\"];var extensions$6=[\".html\",\".htm\",\".html.hl\",\".inc\",\".st\",\".xht\",\".xhtml\"];var languageId$6=146;var HTML={name:name$7,type:type$6,tmScope:tmScope$6,aceMode:aceMode$6,codemirrorMode:codemirrorMode$3,codemirrorMimeType:codemirrorMimeType$3,color:color$1,aliases:aliases$1,extensions:extensions$6,languageId:languageId$6};var HTML$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$7,type:type$6,tmScope:tmScope$6,aceMode:aceMode$6,codemirrorMode:codemirrorMode$3,codemirrorMimeType:codemirrorMimeType$3,color:color$1,aliases:aliases$1,extensions:extensions$6,languageId:languageId$6,'default':HTML});var name$8=\"Vue\";var type$7=\"markup\";var color$2=\"#2c3e50\";var extensions$7=[\".vue\"];var tmScope$7=\"text.html.vue\";var aceMode$7=\"html\";var languageId$7=391;var Vue={name:name$8,type:type$7,color:color$2,extensions:extensions$7,tmScope:tmScope$7,aceMode:aceMode$7,languageId:languageId$7};var Vue$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$8,type:type$7,color:color$2,extensions:extensions$7,tmScope:tmScope$7,aceMode:aceMode$7,languageId:languageId$7,'default':Vue});var require$$0$5=getCjsExportFromNamespace(HTML$1);var require$$1$1=getCjsExportFromNamespace(Vue$1);const languages$3=[createLanguage(require$$0$5,()=>({name:\"Angular\",since:\"1.15.0\",parsers:[\"angular\"],vscodeLanguageIds:[\"html\"],extensions:[\".component.html\"],filenames:[]})),createLanguage(require$$0$5,data=>({since:\"1.15.0\",parsers:[\"html\"],vscodeLanguageIds:[\"html\"],extensions:data.extensions.concat([\".mjml\"// MJML is considered XML in Linguist but it should be formatted as HTML\n])})),createLanguage(require$$0$5,()=>({name:\"Lightning Web Components\",since:\"1.17.0\",parsers:[\"lwc\"],vscodeLanguageIds:[\"html\"],extensions:[],filenames:[]})),createLanguage(require$$1$1,()=>({since:\"1.10.0\",parsers:[\"vue\"],vscodeLanguageIds:[\"vue\"]}))];const printers$3={html:printerHtml};var languageHtml={languages:languages$3,printers:printers$3,options:options$4};const{addLeadingComment:addLeadingComment$3,addTrailingComment:addTrailingComment$3,addDanglingComment:addDanglingComment$3,getNextNonSpaceNonCommentCharacterIndex:getNextNonSpaceNonCommentCharacterIndex$2}=utilShared;function handleOwnLineComment(comment,text,options,ast,isLastComment){const{precedingNode,enclosingNode,followingNode}=comment;return handleLastFunctionArgComments(text,precedingNode,enclosingNode,followingNode,comment,options)||handleMemberExpressionComments(enclosingNode,followingNode,comment)||handleIfStatementComments(text,precedingNode,enclosingNode,followingNode,comment,options)||handleWhileComments(text,precedingNode,enclosingNode,followingNode,comment,options)||handleTryStatementComments(enclosingNode,precedingNode,followingNode,comment)||handleClassComments(enclosingNode,precedingNode,followingNode,comment)||handleImportSpecifierComments(enclosingNode,comment)||handleForComments(enclosingNode,precedingNode,comment)||handleUnionTypeComments(precedingNode,enclosingNode,followingNode,comment)||handleOnlyComments(enclosingNode,ast,comment,isLastComment)||handleImportDeclarationComments(text,enclosingNode,precedingNode,comment,options)||handleAssignmentPatternComments(enclosingNode,comment)||handleMethodNameComments(text,enclosingNode,precedingNode,comment,options)||handleLabeledStatementComments(enclosingNode,comment);}function handleEndOfLineComment(comment,text,options,ast,isLastComment){const{precedingNode,enclosingNode,followingNode}=comment;return handleClosureTypeCastComments(followingNode,comment)||handleLastFunctionArgComments(text,precedingNode,enclosingNode,followingNode,comment,options)||handleConditionalExpressionComments(enclosingNode,precedingNode,followingNode,comment,text,options)||handleImportSpecifierComments(enclosingNode,comment)||handleIfStatementComments(text,precedingNode,enclosingNode,followingNode,comment,options)||handleWhileComments(text,precedingNode,enclosingNode,followingNode,comment,options)||handleTryStatementComments(enclosingNode,precedingNode,followingNode,comment)||handleClassComments(enclosingNode,precedingNode,followingNode,comment)||handleLabeledStatementComments(enclosingNode,comment)||handleCallExpressionComments(precedingNode,enclosingNode,comment)||handlePropertyComments(enclosingNode,comment)||handleOnlyComments(enclosingNode,ast,comment,isLastComment)||handleTypeAliasComments(enclosingNode,followingNode,comment)||handleVariableDeclaratorComments(enclosingNode,followingNode,comment);}function handleRemainingComment(comment,text,options,ast,isLastComment){const{precedingNode,enclosingNode,followingNode}=comment;if(handleIfStatementComments(text,precedingNode,enclosingNode,followingNode,comment,options)||handleWhileComments(text,precedingNode,enclosingNode,followingNode,comment,options)||handleObjectPropertyAssignment(enclosingNode,precedingNode,comment)||handleCommentInEmptyParens(text,enclosingNode,comment,options)||handleMethodNameComments(text,enclosingNode,precedingNode,comment,options)||handleOnlyComments(enclosingNode,ast,comment,isLastComment)||handleCommentAfterArrowParams(text,enclosingNode,comment,options)||handleFunctionNameComments(text,enclosingNode,precedingNode,comment,options)||handleTSMappedTypeComments(text,enclosingNode,precedingNode,followingNode,comment)||handleBreakAndContinueStatementComments(enclosingNode,comment)||handleTSFunctionTrailingComments(text,enclosingNode,followingNode,comment,options)){return true;}return false;}function addBlockStatementFirstComment(node,comment){const body=node.body.filter(n=>n.type!==\"EmptyStatement\");if(body.length===0){addDanglingComment$3(node,comment);}else{addLeadingComment$3(body[0],comment);}}function addBlockOrNotComment(node,comment){if(node.type===\"BlockStatement\"){addBlockStatementFirstComment(node,comment);}else{addLeadingComment$3(node,comment);}}function handleClosureTypeCastComments(followingNode,comment){if(followingNode&&isTypeCastComment(comment)){addLeadingComment$3(followingNode,comment);return true;}return false;}// There are often comments before the else clause of if statements like\n//\n//   if (1) { ... }\n//   // comment\n//   else { ... }\n//\n// They are being attached as leading comments of the BlockExpression which\n// is not well printed. What we want is to instead move the comment inside\n// of the block and make it leadingComment of the first element of the block\n// or dangling comment of the block if there is nothing inside\n//\n//   if (1) { ... }\n//   else {\n//     // comment\n//     ...\n//   }\nfunction handleIfStatementComments(text,precedingNode,enclosingNode,followingNode,comment,options){if(!enclosingNode||enclosingNode.type!==\"IfStatement\"||!followingNode){return false;}// We unfortunately have no way using the AST or location of nodes to know\n// if the comment is positioned before the condition parenthesis:\n//   if (a /* comment */) {}\n// The only workaround I found is to look at the next character to see if\n// it is a ).\nconst nextCharacter=util$1.getNextNonSpaceNonCommentCharacter(text,comment,options.locEnd);if(nextCharacter===\")\"){addTrailingComment$3(precedingNode,comment);return true;}// Comments before `else`:\n// - treat as trailing comments of the consequent, if it's a BlockStatement\n// - treat as a dangling comment otherwise\nif(precedingNode===enclosingNode.consequent&&followingNode===enclosingNode.alternate){if(precedingNode.type===\"BlockStatement\"){addTrailingComment$3(precedingNode,comment);}else{addDanglingComment$3(enclosingNode,comment);}return true;}if(followingNode.type===\"BlockStatement\"){addBlockStatementFirstComment(followingNode,comment);return true;}if(followingNode.type===\"IfStatement\"){addBlockOrNotComment(followingNode.consequent,comment);return true;}// For comments positioned after the condition parenthesis in an if statement\n// before the consequent without brackets on, such as\n// if (a) /* comment */ true,\n// we look at the next character to see if the following node\n// is the consequent for the if statement\nif(enclosingNode.consequent===followingNode){addLeadingComment$3(followingNode,comment);return true;}return false;}function handleWhileComments(text,precedingNode,enclosingNode,followingNode,comment,options){if(!enclosingNode||enclosingNode.type!==\"WhileStatement\"||!followingNode){return false;}// We unfortunately have no way using the AST or location of nodes to know\n// if the comment is positioned before the condition parenthesis:\n//   while (a /* comment */) {}\n// The only workaround I found is to look at the next character to see if\n// it is a ).\nconst nextCharacter=util$1.getNextNonSpaceNonCommentCharacter(text,comment,options.locEnd);if(nextCharacter===\")\"){addTrailingComment$3(precedingNode,comment);return true;}if(followingNode.type===\"BlockStatement\"){addBlockStatementFirstComment(followingNode,comment);return true;}return false;}// Same as IfStatement but for TryStatement\nfunction handleTryStatementComments(enclosingNode,precedingNode,followingNode,comment){if(!enclosingNode||enclosingNode.type!==\"TryStatement\"&&enclosingNode.type!==\"CatchClause\"||!followingNode){return false;}if(enclosingNode.type===\"CatchClause\"&&precedingNode){addTrailingComment$3(precedingNode,comment);return true;}if(followingNode.type===\"BlockStatement\"){addBlockStatementFirstComment(followingNode,comment);return true;}if(followingNode.type===\"TryStatement\"){addBlockOrNotComment(followingNode.finalizer,comment);return true;}if(followingNode.type===\"CatchClause\"){addBlockOrNotComment(followingNode.body,comment);return true;}return false;}function handleMemberExpressionComments(enclosingNode,followingNode,comment){if(enclosingNode&&(enclosingNode.type===\"MemberExpression\"||enclosingNode.type===\"OptionalMemberExpression\")&&followingNode&&followingNode.type===\"Identifier\"){addLeadingComment$3(enclosingNode,comment);return true;}return false;}function handleConditionalExpressionComments(enclosingNode,precedingNode,followingNode,comment,text,options){const isSameLineAsPrecedingNode=precedingNode&&!util$1.hasNewlineInRange(text,options.locEnd(precedingNode),options.locStart(comment));if((!precedingNode||!isSameLineAsPrecedingNode)&&enclosingNode&&enclosingNode.type===\"ConditionalExpression\"&&followingNode){addLeadingComment$3(followingNode,comment);return true;}return false;}function handleObjectPropertyAssignment(enclosingNode,precedingNode,comment){if(enclosingNode&&(enclosingNode.type===\"ObjectProperty\"||enclosingNode.type===\"Property\")&&enclosingNode.shorthand&&enclosingNode.key===precedingNode&&enclosingNode.value.type===\"AssignmentPattern\"){addTrailingComment$3(enclosingNode.value.left,comment);return true;}return false;}function handleClassComments(enclosingNode,precedingNode,followingNode,comment){if(enclosingNode&&(enclosingNode.type===\"ClassDeclaration\"||enclosingNode.type===\"ClassExpression\")&&enclosingNode.decorators&&enclosingNode.decorators.length>0&&!(followingNode&&followingNode.type===\"Decorator\")){if(!enclosingNode.decorators||enclosingNode.decorators.length===0){addLeadingComment$3(enclosingNode,comment);}else{addTrailingComment$3(enclosingNode.decorators[enclosingNode.decorators.length-1],comment);}return true;}return false;}function handleMethodNameComments(text,enclosingNode,precedingNode,comment,options){// This is only needed for estree parsers (flow, typescript) to attach\n// after a method name:\n// obj = { fn /*comment*/() {} };\nif(enclosingNode&&precedingNode&&(// \"MethodDefinition\" is handled in getCommentChildNodes\nenclosingNode.type===\"Property\"||enclosingNode.type===\"TSDeclareMethod\"||enclosingNode.type===\"TSAbstractMethodDefinition\")&&precedingNode.type===\"Identifier\"&&enclosingNode.key===precedingNode&&// special Property case: { key: /*comment*/(value) };\n// comment should be attached to value instead of key\nutil$1.getNextNonSpaceNonCommentCharacter(text,precedingNode,options.locEnd)!==\":\"){addTrailingComment$3(precedingNode,comment);return true;}// Print comments between decorators and class methods as a trailing comment\n// on the decorator node instead of the method node\nif(precedingNode&&enclosingNode&&precedingNode.type===\"Decorator\"&&(enclosingNode.type===\"ClassMethod\"||enclosingNode.type===\"ClassProperty\"||enclosingNode.type===\"TSAbstractClassProperty\"||enclosingNode.type===\"TSAbstractMethodDefinition\"||enclosingNode.type===\"TSDeclareMethod\"||enclosingNode.type===\"MethodDefinition\")){addTrailingComment$3(precedingNode,comment);return true;}return false;}function handleFunctionNameComments(text,enclosingNode,precedingNode,comment,options){if(util$1.getNextNonSpaceNonCommentCharacter(text,comment,options.locEnd)!==\"(\"){return false;}if(precedingNode&&enclosingNode&&(enclosingNode.type===\"FunctionDeclaration\"||enclosingNode.type===\"FunctionExpression\"||enclosingNode.type===\"ClassMethod\"||enclosingNode.type===\"MethodDefinition\"||enclosingNode.type===\"ObjectMethod\")){addTrailingComment$3(precedingNode,comment);return true;}return false;}function handleCommentAfterArrowParams(text,enclosingNode,comment,options){if(!(enclosingNode&&enclosingNode.type===\"ArrowFunctionExpression\")){return false;}const index=getNextNonSpaceNonCommentCharacterIndex$2(text,comment,options.locEnd);if(text.slice(index,index+2)===\"=>\"){addDanglingComment$3(enclosingNode,comment);return true;}return false;}function handleCommentInEmptyParens(text,enclosingNode,comment,options){if(util$1.getNextNonSpaceNonCommentCharacter(text,comment,options.locEnd)!==\")\"){return false;}// Only add dangling comments to fix the case when no params are present,\n// i.e. a function without any argument.\nif(enclosingNode&&(isRealFunctionLikeNode(enclosingNode)&&// `params` vs `parameters` - see https://github.com/babel/babel/issues/9231\n(enclosingNode.params||enclosingNode.parameters).length===0||(enclosingNode.type===\"CallExpression\"||enclosingNode.type===\"OptionalCallExpression\"||enclosingNode.type===\"NewExpression\")&&enclosingNode.arguments.length===0)){addDanglingComment$3(enclosingNode,comment);return true;}if(enclosingNode&&enclosingNode.type===\"MethodDefinition\"&&enclosingNode.value.params.length===0){addDanglingComment$3(enclosingNode.value,comment);return true;}return false;}function handleLastFunctionArgComments(text,precedingNode,enclosingNode,followingNode,comment,options){// Flow function type definitions\nif(precedingNode&&precedingNode.type===\"FunctionTypeParam\"&&enclosingNode&&enclosingNode.type===\"FunctionTypeAnnotation\"&&followingNode&&followingNode.type!==\"FunctionTypeParam\"){addTrailingComment$3(precedingNode,comment);return true;}// Real functions and TypeScript function type definitions\nif(precedingNode&&(precedingNode.type===\"Identifier\"||precedingNode.type===\"AssignmentPattern\")&&enclosingNode&&isRealFunctionLikeNode(enclosingNode)&&util$1.getNextNonSpaceNonCommentCharacter(text,comment,options.locEnd)===\")\"){addTrailingComment$3(precedingNode,comment);return true;}if(enclosingNode&&enclosingNode.type===\"FunctionDeclaration\"&&followingNode&&followingNode.type===\"BlockStatement\"){const functionParamRightParenIndex=(()=>{if((enclosingNode.params||enclosingNode.parameters).length!==0){return util$1.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text,options.locEnd(util$1.getLast(enclosingNode.params||enclosingNode.parameters)));}const functionParamLeftParenIndex=util$1.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text,options.locEnd(enclosingNode.id));return util$1.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text,functionParamLeftParenIndex+1);})();if(options.locStart(comment)>functionParamRightParenIndex){addBlockStatementFirstComment(followingNode,comment);return true;}}return false;}function handleImportSpecifierComments(enclosingNode,comment){if(enclosingNode&&enclosingNode.type===\"ImportSpecifier\"){addLeadingComment$3(enclosingNode,comment);return true;}return false;}function handleLabeledStatementComments(enclosingNode,comment){if(enclosingNode&&enclosingNode.type===\"LabeledStatement\"){addLeadingComment$3(enclosingNode,comment);return true;}return false;}function handleBreakAndContinueStatementComments(enclosingNode,comment){if(enclosingNode&&(enclosingNode.type===\"ContinueStatement\"||enclosingNode.type===\"BreakStatement\")&&!enclosingNode.label){addTrailingComment$3(enclosingNode,comment);return true;}return false;}function handleCallExpressionComments(precedingNode,enclosingNode,comment){if(enclosingNode&&(enclosingNode.type===\"CallExpression\"||enclosingNode.type===\"OptionalCallExpression\")&&precedingNode&&enclosingNode.callee===precedingNode&&enclosingNode.arguments.length>0){addLeadingComment$3(enclosingNode.arguments[0],comment);return true;}return false;}function handleUnionTypeComments(precedingNode,enclosingNode,followingNode,comment){if(enclosingNode&&(enclosingNode.type===\"UnionTypeAnnotation\"||enclosingNode.type===\"TSUnionType\")){if(util$1.isNodeIgnoreComment(comment)){followingNode.prettierIgnore=true;comment.unignore=true;}if(precedingNode){addTrailingComment$3(precedingNode,comment);return true;}return false;}if(followingNode&&(followingNode.type===\"UnionTypeAnnotation\"||followingNode.type===\"TSUnionType\")&&util$1.isNodeIgnoreComment(comment)){followingNode.types[0].prettierIgnore=true;comment.unignore=true;}return false;}function handlePropertyComments(enclosingNode,comment){if(enclosingNode&&(enclosingNode.type===\"Property\"||enclosingNode.type===\"ObjectProperty\")){addLeadingComment$3(enclosingNode,comment);return true;}return false;}function handleOnlyComments(enclosingNode,ast,comment,isLastComment){// With Flow the enclosingNode is undefined so use the AST instead.\nif(ast&&ast.body&&ast.body.length===0){if(isLastComment){addDanglingComment$3(ast,comment);}else{addLeadingComment$3(ast,comment);}return true;}else if(enclosingNode&&enclosingNode.type===\"Program\"&&enclosingNode.body.length===0&&enclosingNode.directives&&enclosingNode.directives.length===0){if(isLastComment){addDanglingComment$3(enclosingNode,comment);}else{addLeadingComment$3(enclosingNode,comment);}return true;}return false;}function handleForComments(enclosingNode,precedingNode,comment){if(enclosingNode&&(enclosingNode.type===\"ForInStatement\"||enclosingNode.type===\"ForOfStatement\")){addLeadingComment$3(enclosingNode,comment);return true;}return false;}function handleImportDeclarationComments(text,enclosingNode,precedingNode,comment,options){if(precedingNode&&precedingNode.type===\"ImportSpecifier\"&&enclosingNode&&enclosingNode.type===\"ImportDeclaration\"&&util$1.hasNewline(text,options.locEnd(comment))){addTrailingComment$3(precedingNode,comment);return true;}return false;}function handleAssignmentPatternComments(enclosingNode,comment){if(enclosingNode&&enclosingNode.type===\"AssignmentPattern\"){addLeadingComment$3(enclosingNode,comment);return true;}return false;}function handleTypeAliasComments(enclosingNode,followingNode,comment){if(enclosingNode&&enclosingNode.type===\"TypeAlias\"){addLeadingComment$3(enclosingNode,comment);return true;}return false;}function handleVariableDeclaratorComments(enclosingNode,followingNode,comment){if(enclosingNode&&(enclosingNode.type===\"VariableDeclarator\"||enclosingNode.type===\"AssignmentExpression\")&&followingNode&&(followingNode.type===\"ObjectExpression\"||followingNode.type===\"ArrayExpression\"||followingNode.type===\"TemplateLiteral\"||followingNode.type===\"TaggedTemplateExpression\"||isBlockComment(comment))){addLeadingComment$3(followingNode,comment);return true;}return false;}function handleTSFunctionTrailingComments(text,enclosingNode,followingNode,comment,options){if(!followingNode&&enclosingNode&&(enclosingNode.type===\"TSMethodSignature\"||enclosingNode.type===\"TSDeclareFunction\"||enclosingNode.type===\"TSAbstractMethodDefinition\")&&util$1.getNextNonSpaceNonCommentCharacter(text,comment,options.locEnd)===\";\"){addTrailingComment$3(enclosingNode,comment);return true;}return false;}function handleTSMappedTypeComments(text,enclosingNode,precedingNode,followingNode,comment){if(!enclosingNode||enclosingNode.type!==\"TSMappedType\"){return false;}if(followingNode&&followingNode.type===\"TSTypeParameter\"&&followingNode.name){addLeadingComment$3(followingNode.name,comment);return true;}if(precedingNode&&precedingNode.type===\"TSTypeParameter\"&&precedingNode.constraint){addTrailingComment$3(precedingNode.constraint,comment);return true;}return false;}function isBlockComment(comment){return comment.type===\"Block\"||comment.type===\"CommentBlock\";}function hasLeadingComment(node){let fn=arguments.length>1&&arguments[1]!==undefined?arguments[1]:()=>true;if(node.leadingComments){return node.leadingComments.some(fn);}if(node.comments){return node.comments.some(comment=>comment.leading&&fn(comment));}return false;}function isRealFunctionLikeNode(node){return node.type===\"ArrowFunctionExpression\"||node.type===\"FunctionExpression\"||node.type===\"FunctionDeclaration\"||node.type===\"ObjectMethod\"||node.type===\"ClassMethod\"||node.type===\"TSDeclareFunction\"||node.type===\"TSCallSignatureDeclaration\"||node.type===\"TSConstructSignatureDeclaration\"||node.type===\"TSConstructSignatureDeclaration\"||node.type===\"TSMethodSignature\"||node.type===\"TSConstructorType\"||node.type===\"TSFunctionType\"||node.type===\"TSDeclareMethod\";}function getGapRegex(enclosingNode){if(enclosingNode&&enclosingNode.type!==\"BinaryExpression\"&&enclosingNode.type!==\"LogicalExpression\"){// Support degenerate single-element unions and intersections.\n// E.g.: `type A = /* 1 */ & B`\nreturn /^[\\s(&|]*$/;}}function getCommentChildNodes(node,options){// Prevent attaching comments to FunctionExpression in this case:\n//     class Foo {\n//       bar() // comment\n//       {\n//         baz();\n//       }\n//     }\nif((options.parser===\"typescript\"||options.parser===\"flow\")&&node.type===\"MethodDefinition\"&&node.value&&node.value.type===\"FunctionExpression\"&&node.value.params.length===0&&!node.value.returnType&&(!node.value.typeParameters||node.value.typeParameters.length===0)&&node.value.body){return[...(node.decorators||[]),node.key,node.value.body];}}function isTypeCastComment(comment){return isBlockComment(comment)&&comment.value[0]===\"*\"&&// TypeScript expects the type to be enclosed in curly brackets, however\n// Closure Compiler accepts types in parens and even without any delimiters at all.\n// That's why we just search for \"@type\".\n/@type\\b/.test(comment.value);}var comments$1={handleOwnLineComment,handleEndOfLineComment,handleRemainingComment,hasLeadingComment,isBlockComment,isTypeCastComment,getGapRegex,getCommentChildNodes};const{isBlockComment:isBlockComment$1,hasLeadingComment:hasLeadingComment$1}=comments$1;const{builders:{indent:indent$6,join:join$7,line:line$7,hardline:hardline$8,softline:softline$5,literalline:literalline$3,concat:concat$b,group:group$a,dedentToRoot:dedentToRoot$2},utils:{mapDoc:mapDoc$3,stripTrailingHardline:stripTrailingHardline$2}}=document;function embed$3(path,print,textToDoc,options){const node=path.getValue();const parent=path.getParentNode();const parentParent=path.getParentNode(1);switch(node.type){case\"TemplateLiteral\":{const isCss=[isStyledJsx,isStyledComponents,isCssProp,isAngularComponentStyles].some(isIt=>isIt(path));if(isCss){// Get full template literal with expressions replaced by placeholders\nconst rawQuasis=node.quasis.map(q=>q.value.raw);let placeholderID=0;const text=rawQuasis.reduce((prevVal,currVal,idx)=>{return idx===0?currVal:prevVal+\"@prettier-placeholder-\"+placeholderID++ +\"-id\"+currVal;},\"\");const doc=textToDoc(text,{parser:\"scss\"});return transformCssDoc(doc,path,print);}/*\n           * react-relay and graphql-tag\n           * graphql`...`\n           * graphql.experimental`...`\n           * gql`...`\n           *\n           * This intentionally excludes Relay Classic tags, as Prettier does not\n           * support Relay Classic formatting.\n           */if(isGraphQL(path)){const expressionDocs=node.expressions?path.map(print,\"expressions\"):[];const numQuasis=node.quasis.length;if(numQuasis===1&&node.quasis[0].value.raw.trim()===\"\"){return\"``\";}const parts=[];for(let i=0;i<numQuasis;i++){const templateElement=node.quasis[i];const isFirst=i===0;const isLast=i===numQuasis-1;const text=templateElement.value.cooked;// Bail out if any of the quasis have an invalid escape sequence\n// (which would make the `cooked` value be `null` or `undefined`)\nif(typeof text!==\"string\"){return null;}const lines=text.split(\"\\n\");const numLines=lines.length;const expressionDoc=expressionDocs[i];const startsWithBlankLine=numLines>2&&lines[0].trim()===\"\"&&lines[1].trim()===\"\";const endsWithBlankLine=numLines>2&&lines[numLines-1].trim()===\"\"&&lines[numLines-2].trim()===\"\";const commentsAndWhitespaceOnly=lines.every(line=>/^\\s*(?:#[^\\r\\n]*)?$/.test(line));// Bail out if an interpolation occurs within a comment.\nif(!isLast&&/#[^\\r\\n]*$/.test(lines[numLines-1])){return null;}let doc=null;if(commentsAndWhitespaceOnly){doc=printGraphqlComments(lines);}else{doc=stripTrailingHardline$2(textToDoc(text,{parser:\"graphql\"}));}if(doc){doc=escapeTemplateCharacters(doc,false);if(!isFirst&&startsWithBlankLine){parts.push(\"\");}parts.push(doc);if(!isLast&&endsWithBlankLine){parts.push(\"\");}}else if(!isFirst&&!isLast&&startsWithBlankLine){parts.push(\"\");}if(expressionDoc){parts.push(concat$b([\"${\",expressionDoc,\"}\"]));}}return concat$b([\"`\",indent$6(concat$b([hardline$8,join$7(hardline$8,parts)])),hardline$8,\"`\"]);}const htmlParser=isHtml(path)?\"html\":isAngularComponentTemplate(path)?\"angular\":undefined;if(htmlParser){return printHtmlTemplateLiteral(path,print,textToDoc,htmlParser,options);}break;}case\"TemplateElement\":{/**\n           * md`...`\n           * markdown`...`\n           */if(parentParent&&parentParent.type===\"TaggedTemplateExpression\"&&parent.quasis.length===1&&parentParent.tag.type===\"Identifier\"&&(parentParent.tag.name===\"md\"||parentParent.tag.name===\"markdown\")){const text=parent.quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g,(_,backslashes)=>\"\\\\\".repeat(backslashes.length/2)+\"`\");const indentation=getIndentation(text);const hasIndent=indentation!==\"\";return concat$b([hasIndent?indent$6(concat$b([softline$5,printMarkdown(text.replace(new RegExp(\"^\".concat(indentation),\"gm\"),\"\"))])):concat$b([literalline$3,dedentToRoot$2(printMarkdown(text))]),softline$5]);}break;}}function printMarkdown(text){const doc=textToDoc(text,{parser:\"markdown\",__inJsTemplate:true});return stripTrailingHardline$2(escapeTemplateCharacters(doc,true));}}function getIndentation(str){const firstMatchedIndent=str.match(/^([^\\S\\n]*)\\S/m);return firstMatchedIndent===null?\"\":firstMatchedIndent[1];}function uncook(cookedValue){return cookedValue.replace(/([\\\\`]|\\$\\{)/g,\"\\\\$1\");}function escapeTemplateCharacters(doc,raw){return mapDoc$3(doc,currentDoc=>{if(!currentDoc.parts){return currentDoc;}const parts=[];currentDoc.parts.forEach(part=>{if(typeof part===\"string\"){parts.push(raw?part.replace(/(\\\\*)`/g,\"$1$1\\\\`\"):uncook(part));}else{parts.push(part);}});return Object.assign({},currentDoc,{parts});});}function transformCssDoc(quasisDoc,path,print){const parentNode=path.getValue();const isEmpty=parentNode.quasis.length===1&&!parentNode.quasis[0].value.raw.trim();if(isEmpty){return\"``\";}const expressionDocs=parentNode.expressions?path.map(print,\"expressions\"):[];const newDoc=replacePlaceholders(quasisDoc,expressionDocs);/* istanbul ignore if */if(!newDoc){throw new Error(\"Couldn't insert all the expressions\");}return concat$b([\"`\",indent$6(concat$b([hardline$8,stripTrailingHardline$2(newDoc)])),softline$5,\"`\"]);}// Search all the placeholders in the quasisDoc tree\n// and replace them with the expression docs one by one\n// returns a new doc with all the placeholders replaced,\n// or null if it couldn't replace any expression\nfunction replacePlaceholders(quasisDoc,expressionDocs){if(!expressionDocs||!expressionDocs.length){return quasisDoc;}const expressions=expressionDocs.slice();let replaceCounter=0;const newDoc=mapDoc$3(quasisDoc,doc=>{if(!doc||!doc.parts||!doc.parts.length){return doc;}let{parts}=doc;const atIndex=parts.indexOf(\"@\");const placeholderIndex=atIndex+1;if(atIndex>-1&&typeof parts[placeholderIndex]===\"string\"&&parts[placeholderIndex].startsWith(\"prettier-placeholder\")){// If placeholder is split, join it\nconst at=parts[atIndex];const placeholder=parts[placeholderIndex];const rest=parts.slice(placeholderIndex+1);parts=parts.slice(0,atIndex).concat([at+placeholder]).concat(rest);}const atPlaceholderIndex=parts.findIndex(part=>typeof part===\"string\"&&part.startsWith(\"@prettier-placeholder\"));if(atPlaceholderIndex>-1){const placeholder=parts[atPlaceholderIndex];const rest=parts.slice(atPlaceholderIndex+1);const placeholderMatch=placeholder.match(/@prettier-placeholder-(.+)-id([\\s\\S]*)/);const placeholderID=placeholderMatch[1];// When the expression has a suffix appended, like:\n// animation: linear ${time}s ease-out;\nconst suffix=placeholderMatch[2];const expression=expressions[placeholderID];replaceCounter++;parts=parts.slice(0,atPlaceholderIndex).concat([\"${\",expression,\"}\"+suffix]).concat(rest);}return Object.assign({},doc,{parts});});return expressions.length===replaceCounter?newDoc:null;}function printGraphqlComments(lines){const parts=[];let seenComment=false;lines.map(textLine=>textLine.trim()).forEach((textLine,i,array)=>{// Lines are either whitespace only, or a comment (with potential whitespace\n// around it). Drop whitespace-only lines.\nif(textLine===\"\"){return;}if(array[i-1]===\"\"&&seenComment){// If a non-first comment is preceded by a blank (whitespace only) line,\n// add in a blank line.\nparts.push(concat$b([hardline$8,textLine]));}else{parts.push(textLine);}seenComment=true;});// If `lines` was whitespace only, return `null`.\nreturn parts.length===0?null:join$7(hardline$8,parts);}/**\n   * Template literal in these contexts:\n   * <style jsx>{`div{color:red}`}</style>\n   * css``\n   * css.global``\n   * css.resolve``\n   */function isStyledJsx(path){const node=path.getValue();const parent=path.getParentNode();const parentParent=path.getParentNode(1);return parentParent&&node.quasis&&parent.type===\"JSXExpressionContainer\"&&parentParent.type===\"JSXElement\"&&parentParent.openingElement.name.name===\"style\"&&parentParent.openingElement.attributes.some(attribute=>attribute.name.name===\"jsx\")||parent&&parent.type===\"TaggedTemplateExpression\"&&parent.tag.type===\"Identifier\"&&parent.tag.name===\"css\"||parent&&parent.type===\"TaggedTemplateExpression\"&&parent.tag.type===\"MemberExpression\"&&parent.tag.object.name===\"css\"&&(parent.tag.property.name===\"global\"||parent.tag.property.name===\"resolve\");}/**\n   * Angular Components can have:\n   * - Inline HTML template\n   * - Inline CSS styles\n   *\n   * ...which are both within template literals somewhere\n   * inside of the Component decorator factory.\n   *\n   * E.g.\n   * @Component({\n   *  template: `<div>...</div>`,\n   *  styles: [`h1 { color: blue; }`]\n   * })\n   */function isAngularComponentStyles(path){return path.match(node=>node.type===\"TemplateLiteral\",(node,name)=>node.type===\"ArrayExpression\"&&name===\"elements\",(node,name)=>(node.type===\"Property\"||node.type===\"ObjectProperty\")&&node.key.type===\"Identifier\"&&node.key.name===\"styles\"&&name===\"value\",...angularComponentObjectExpressionPredicates);}function isAngularComponentTemplate(path){return path.match(node=>node.type===\"TemplateLiteral\",(node,name)=>(node.type===\"Property\"||node.type===\"ObjectProperty\")&&node.key.type===\"Identifier\"&&node.key.name===\"template\"&&name===\"value\",...angularComponentObjectExpressionPredicates);}const angularComponentObjectExpressionPredicates=[(node,name)=>node.type===\"ObjectExpression\"&&name===\"properties\",(node,name)=>node.type===\"CallExpression\"&&node.callee.type===\"Identifier\"&&node.callee.name===\"Component\"&&name===\"arguments\",(node,name)=>node.type===\"Decorator\"&&name===\"expression\"];/**\n   * styled-components template literals\n   */function isStyledComponents(path){const parent=path.getParentNode();if(!parent||parent.type!==\"TaggedTemplateExpression\"){return false;}const{tag}=parent;switch(tag.type){case\"MemberExpression\":return(// styled.foo``\nisStyledIdentifier(tag.object)||// Component.extend``\nisStyledExtend(tag));case\"CallExpression\":return(// styled(Component)``\nisStyledIdentifier(tag.callee)||tag.callee.type===\"MemberExpression\"&&(tag.callee.object.type===\"MemberExpression\"&&(// styled.foo.attrs({})``\nisStyledIdentifier(tag.callee.object.object)||// Component.extend.attrs({})``\nisStyledExtend(tag.callee.object))||// styled(Component).attrs({})``\ntag.callee.object.type===\"CallExpression\"&&isStyledIdentifier(tag.callee.object.callee)));case\"Identifier\":// css``\nreturn tag.name===\"css\";default:return false;}}/**\n   * JSX element with CSS prop\n   */function isCssProp(path){const parent=path.getParentNode();const parentParent=path.getParentNode(1);return parentParent&&parent.type===\"JSXExpressionContainer\"&&parentParent.type===\"JSXAttribute\"&&parentParent.name.type===\"JSXIdentifier\"&&parentParent.name.name===\"css\";}function isStyledIdentifier(node){return node.type===\"Identifier\"&&node.name===\"styled\";}function isStyledExtend(node){return /^[A-Z]/.test(node.object.name)&&node.property.name===\"extend\";}/*\n   * react-relay and graphql-tag\n   * graphql`...`\n   * graphql.experimental`...`\n   * gql`...`\n   * GraphQL comment block\n   *\n   * This intentionally excludes Relay Classic tags, as Prettier does not\n   * support Relay Classic formatting.\n   */function isGraphQL(path){const node=path.getValue();const parent=path.getParentNode();return hasLanguageComment(node,\"GraphQL\")||parent&&(parent.type===\"TaggedTemplateExpression\"&&(parent.tag.type===\"MemberExpression\"&&parent.tag.object.name===\"graphql\"&&parent.tag.property.name===\"experimental\"||parent.tag.type===\"Identifier\"&&(parent.tag.name===\"gql\"||parent.tag.name===\"graphql\"))||parent.type===\"CallExpression\"&&parent.callee.type===\"Identifier\"&&parent.callee.name===\"graphql\");}function hasLanguageComment(node,languageName){// This checks for a leading comment that is exactly `/* GraphQL */`\n// In order to be in line with other implementations of this comment tag\n// we will not trim the comment value and we will expect exactly one space on\n// either side of the GraphQL string\n// Also see ./clean.js\nreturn hasLeadingComment$1(node,comment=>isBlockComment$1(comment)&&comment.value===\" \".concat(languageName,\" \"));}/**\n   *     - html`...`\n   *     - HTML comment block\n   */function isHtml(path){return hasLanguageComment(path.getValue(),\"HTML\")||path.match(node=>node.type===\"TemplateLiteral\",(node,name)=>node.type===\"TaggedTemplateExpression\"&&node.tag.type===\"Identifier\"&&node.tag.name===\"html\"&&name===\"quasi\");}// The counter is needed to distinguish nested embeds.\nlet htmlTemplateLiteralCounter=0;function printHtmlTemplateLiteral(path,print,textToDoc,parser,options){const node=path.getValue();const counter=htmlTemplateLiteralCounter;htmlTemplateLiteralCounter=htmlTemplateLiteralCounter+1>>>0;const composePlaceholder=index=>\"PRETTIER_HTML_PLACEHOLDER_\".concat(index,\"_\").concat(counter,\"_IN_JS\");const text=node.quasis.map((quasi,index,quasis)=>index===quasis.length-1?quasi.value.cooked:quasi.value.cooked+composePlaceholder(index)).join(\"\");const expressionDocs=path.map(print,\"expressions\");if(expressionDocs.length===0&&text.trim().length===0){return\"``\";}const placeholderRegex=new RegExp(composePlaceholder(\"(\\\\d+)\"),\"g\");let topLevelCount=0;const contentDoc=mapDoc$3(stripTrailingHardline$2(textToDoc(text,{parser,__onHtmlRoot(root){topLevelCount=root.children.length;}})),doc=>{if(typeof doc!==\"string\"){return doc;}const parts=[];const components=doc.split(placeholderRegex);for(let i=0;i<components.length;i++){let component=components[i];if(i%2===0){if(component){component=uncook(component);if(options.embeddedInHtml){component=component.replace(/<\\/(script)\\b/gi,\"<\\\\/$1\");}parts.push(component);}continue;}const placeholderIndex=+component;parts.push(concat$b([\"${\",group$a(expressionDocs[placeholderIndex]),\"}\"]));}return concat$b(parts);});const leadingWhitespace=/^\\s/.test(text)?\" \":\"\";const trailingWhitespace=/\\s$/.test(text)?\" \":\"\";const linebreak=options.htmlWhitespaceSensitivity===\"ignore\"?hardline$8:leadingWhitespace&&trailingWhitespace?line$7:null;if(linebreak){return group$a(concat$b([\"`\",indent$6(concat$b([linebreak,group$a(contentDoc)])),linebreak,\"`\"]));}return group$a(concat$b([\"`\",leadingWhitespace,topLevelCount>1?indent$6(group$a(contentDoc)):group$a(contentDoc),trailingWhitespace,\"`\"]));}var embed_1$1=embed$3;function clean$4(ast,newObj,parent){[\"range\",\"raw\",\"comments\",\"leadingComments\",\"trailingComments\",\"innerComments\",\"extra\",\"start\",\"end\",\"flags\",\"errors\"].forEach(name=>{delete newObj[name];});if(ast.loc&&ast.loc.source===null){delete newObj.loc.source;}if(ast.type===\"BigIntLiteral\"){newObj.value=newObj.value.toLowerCase();}// We remove extra `;` and add them when needed\nif(ast.type===\"EmptyStatement\"){return null;}// We move text around, including whitespaces and add {\" \"}\nif(ast.type===\"JSXText\"){return null;}if(ast.type===\"JSXExpressionContainer\"&&ast.expression.type===\"Literal\"&&ast.expression.value===\" \"){return null;}// (TypeScript) Ignore `static` in `constructor(static p) {}`\n// and `export` in `constructor(export p) {}`\nif(ast.type===\"TSParameterProperty\"&&ast.accessibility===null&&!ast.readonly){return{type:\"Identifier\",name:ast.parameter.name,typeAnnotation:newObj.parameter.typeAnnotation,decorators:newObj.decorators};}// (TypeScript) ignore empty `specifiers` array\nif(ast.type===\"TSNamespaceExportDeclaration\"&&ast.specifiers&&ast.specifiers.length===0){delete newObj.specifiers;}// We convert <div></div> to <div />\nif(ast.type===\"JSXOpeningElement\"){delete newObj.selfClosing;}if(ast.type===\"JSXElement\"){delete newObj.closingElement;}// We change {'key': value} into {key: value}\nif((ast.type===\"Property\"||ast.type===\"ObjectProperty\"||ast.type===\"MethodDefinition\"||ast.type===\"ClassProperty\"||ast.type===\"TSPropertySignature\"||ast.type===\"ObjectTypeProperty\")&&typeof ast.key===\"object\"&&ast.key&&(ast.key.type===\"Literal\"||ast.key.type===\"StringLiteral\"||ast.key.type===\"Identifier\")){delete newObj.key;}if(ast.type===\"OptionalMemberExpression\"&&ast.optional===false){newObj.type=\"MemberExpression\";delete newObj.optional;}// Remove raw and cooked values from TemplateElement when it's CSS\n// styled-jsx\nif(ast.type===\"JSXElement\"&&ast.openingElement.name.name===\"style\"&&ast.openingElement.attributes.some(attr=>attr.name.name===\"jsx\")){const templateLiterals=newObj.children.filter(child=>child.type===\"JSXExpressionContainer\"&&child.expression.type===\"TemplateLiteral\").map(container=>container.expression);const quasis=templateLiterals.reduce((quasis,templateLiteral)=>quasis.concat(templateLiteral.quasis),[]);quasis.forEach(q=>delete q.value);}// CSS template literals in css prop\nif(ast.type===\"JSXAttribute\"&&ast.name.name===\"css\"&&ast.value.type===\"JSXExpressionContainer\"&&ast.value.expression.type===\"TemplateLiteral\"){newObj.value.expression.quasis.forEach(q=>delete q.value);}// Angular Components: Inline HTML template and Inline CSS styles\nconst expression=ast.expression||ast.callee;if(ast.type===\"Decorator\"&&expression.type===\"CallExpression\"&&expression.callee.name===\"Component\"&&expression.arguments.length===1){const astProps=ast.expression.arguments[0].properties;newObj.expression.arguments[0].properties.forEach((prop,index)=>{let templateLiteral=null;switch(astProps[index].key.name){case\"styles\":if(prop.value.type===\"ArrayExpression\"){templateLiteral=prop.value.elements[0];}break;case\"template\":if(prop.value.type===\"TemplateLiteral\"){templateLiteral=prop.value;}break;}if(templateLiteral){templateLiteral.quasis.forEach(q=>delete q.value);}});}// styled-components, graphql, markdown\nif(ast.type===\"TaggedTemplateExpression\"&&(ast.tag.type===\"MemberExpression\"||ast.tag.type===\"Identifier\"&&(ast.tag.name===\"gql\"||ast.tag.name===\"graphql\"||ast.tag.name===\"css\"||ast.tag.name===\"md\"||ast.tag.name===\"markdown\"||ast.tag.name===\"html\")||ast.tag.type===\"CallExpression\")){newObj.quasi.quasis.forEach(quasi=>delete quasi.value);}if(ast.type===\"TemplateLiteral\"){// This checks for a leading comment that is exactly `/* GraphQL */`\n// In order to be in line with other implementations of this comment tag\n// we will not trim the comment value and we will expect exactly one space on\n// either side of the GraphQL string\n// Also see ./embed.js\nconst hasLanguageComment=ast.leadingComments&&ast.leadingComments.some(comment=>comment.type===\"CommentBlock\"&&[\"GraphQL\",\"HTML\"].some(languageName=>comment.value===\" \".concat(languageName,\" \")));if(hasLanguageComment||parent.type===\"CallExpression\"&&parent.callee.name===\"graphql\"){newObj.quasis.forEach(quasi=>delete quasi.value);}}}var clean_1$1=clean$4;const{getLast:getLast$2,hasNewline:hasNewline$4,hasNewlineInRange:hasNewlineInRange$2,hasIgnoreComment:hasIgnoreComment$3,hasNodeIgnoreComment:hasNodeIgnoreComment$1,skipWhitespace:skipWhitespace$2}=util$1;const isIdentifierName=utils$1.keyword.isIdentifierNameES5;// We match any whitespace except line terminators because\n// Flow annotation comments cannot be split across lines. For example:\n//\n// (this /*\n// : any */).foo = 5;\n//\n// is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so\n// removing the newline would create a type annotation that the user did not intend\n// to create.\nconst NON_LINE_TERMINATING_WHITE_SPACE=\"(?:(?=.)\\\\s)\";const FLOW_SHORTHAND_ANNOTATION=new RegExp(\"^\".concat(NON_LINE_TERMINATING_WHITE_SPACE,\"*:\"));const FLOW_ANNOTATION=new RegExp(\"^\".concat(NON_LINE_TERMINATING_WHITE_SPACE,\"*::\"));function hasFlowShorthandAnnotationComment(node){// https://flow.org/en/docs/types/comments/\n// Syntax example: const r = new (window.Request /*: Class<Request> */)(\"\");\nreturn node.extra&&node.extra.parenthesized&&node.trailingComments&&node.trailingComments[0].value.match(FLOW_SHORTHAND_ANNOTATION);}function hasFlowAnnotationComment(comments){return comments&&comments[0].value.match(FLOW_ANNOTATION);}function hasNode(node,fn){if(!node||typeof node!==\"object\"){return false;}if(Array.isArray(node)){return node.some(value=>hasNode(value,fn));}const result=fn(node);return typeof result===\"boolean\"?result:Object.keys(node).some(key=>hasNode(node[key],fn));}function hasNakedLeftSide(node){return node.type===\"AssignmentExpression\"||node.type===\"BinaryExpression\"||node.type===\"LogicalExpression\"||node.type===\"NGPipeExpression\"||node.type===\"ConditionalExpression\"||node.type===\"CallExpression\"||node.type===\"OptionalCallExpression\"||node.type===\"MemberExpression\"||node.type===\"OptionalMemberExpression\"||node.type===\"SequenceExpression\"||node.type===\"TaggedTemplateExpression\"||node.type===\"BindExpression\"||node.type===\"UpdateExpression\"&&!node.prefix||node.type===\"TSAsExpression\"||node.type===\"TSNonNullExpression\";}function getLeftSide(node){if(node.expressions){return node.expressions[0];}return node.left||node.test||node.callee||node.object||node.tag||node.argument||node.expression;}function getLeftSidePathName(path,node){if(node.expressions){return[\"expressions\",0];}if(node.left){return[\"left\"];}if(node.test){return[\"test\"];}if(node.object){return[\"object\"];}if(node.callee){return[\"callee\"];}if(node.tag){return[\"tag\"];}if(node.argument){return[\"argument\"];}if(node.expression){return[\"expression\"];}throw new Error(\"Unexpected node has no left side\",node);}const exportDeclarationTypes=new Set([\"ExportDefaultDeclaration\",\"ExportDefaultSpecifier\",\"DeclareExportDeclaration\",\"ExportNamedDeclaration\",\"ExportAllDeclaration\"]);function isExportDeclaration(node){return node&&exportDeclarationTypes.has(node.type);}function getParentExportDeclaration(path){const parentNode=path.getParentNode();if(path.getName()===\"declaration\"&&isExportDeclaration(parentNode)){return parentNode;}return null;}function isLiteral(node){return node.type===\"BooleanLiteral\"||node.type===\"DirectiveLiteral\"||node.type===\"Literal\"||node.type===\"NullLiteral\"||node.type===\"NumericLiteral\"||node.type===\"RegExpLiteral\"||node.type===\"StringLiteral\"||node.type===\"TemplateLiteral\"||node.type===\"TSTypeLiteral\"||node.type===\"JSXText\";}function isNumericLiteral(node){return node.type===\"NumericLiteral\"||node.type===\"Literal\"&&typeof node.value===\"number\";}function isStringLiteral(node){return node.type===\"StringLiteral\"||node.type===\"Literal\"&&typeof node.value===\"string\";}function isObjectType(n){return n.type===\"ObjectTypeAnnotation\"||n.type===\"TSTypeLiteral\";}function isFunctionOrArrowExpression(node){return node.type===\"FunctionExpression\"||node.type===\"ArrowFunctionExpression\";}function isFunctionOrArrowExpressionWithBody(node){return node.type===\"FunctionExpression\"||node.type===\"ArrowFunctionExpression\"&&node.body.type===\"BlockStatement\";}function isTemplateLiteral(node){return node.type===\"TemplateLiteral\";}// `inject` is used in AngularJS 1.x, `async` in Angular 2+\n// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\nfunction isAngularTestWrapper(node){return(node.type===\"CallExpression\"||node.type===\"OptionalCallExpression\")&&node.callee.type===\"Identifier\"&&(node.callee.name===\"async\"||node.callee.name===\"inject\"||node.callee.name===\"fakeAsync\");}function isJSXNode(node){return node.type===\"JSXElement\"||node.type===\"JSXFragment\";}function isTheOnlyJSXElementInMarkdown(options,path){if(options.parentParser!==\"markdown\"&&options.parentParser!==\"mdx\"){return false;}const node=path.getNode();if(!node.expression||!isJSXNode(node.expression)){return false;}const parent=path.getParentNode();return parent.type===\"Program\"&&parent.body.length===1;}// Detect an expression node representing `{\" \"}`\nfunction isJSXWhitespaceExpression(node){return node.type===\"JSXExpressionContainer\"&&isLiteral(node.expression)&&node.expression.value===\" \"&&!node.expression.comments;}function isMemberExpressionChain(node){if(node.type!==\"MemberExpression\"&&node.type!==\"OptionalMemberExpression\"){return false;}if(node.object.type===\"Identifier\"){return true;}return isMemberExpressionChain(node.object);}function isGetterOrSetter(node){return node.kind===\"get\"||node.kind===\"set\";}function sameLocStart(nodeA,nodeB,options){return options.locStart(nodeA)===options.locStart(nodeB);}// TODO: This is a bad hack and we need a better way to distinguish between\n// arrow functions and otherwise\nfunction isFunctionNotation(node,options){return isGetterOrSetter(node)||sameLocStart(node,node.value,options);}// Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\nfunction isObjectTypePropertyAFunction(node,options){return(node.type===\"ObjectTypeProperty\"||node.type===\"ObjectTypeInternalSlot\")&&node.value.type===\"FunctionTypeAnnotation\"&&!node.static&&!isFunctionNotation(node,options);}// Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\nfunction isTypeAnnotationAFunction(node,options){return(node.type===\"TypeAnnotation\"||node.type===\"TSTypeAnnotation\")&&node.typeAnnotation.type===\"FunctionTypeAnnotation\"&&!node.static&&!sameLocStart(node,node.typeAnnotation,options);}const binaryishNodeTypes=new Set([\"BinaryExpression\",\"LogicalExpression\",\"NGPipeExpression\"]);function isBinaryish(node){return binaryishNodeTypes.has(node.type);}function isMemberish(node){return node.type===\"MemberExpression\"||node.type===\"OptionalMemberExpression\"||node.type===\"BindExpression\"&&node.object;}function isSimpleFlowType(node){const flowTypeAnnotations=[\"AnyTypeAnnotation\",\"NullLiteralTypeAnnotation\",\"GenericTypeAnnotation\",\"ThisTypeAnnotation\",\"NumberTypeAnnotation\",\"VoidTypeAnnotation\",\"EmptyTypeAnnotation\",\"MixedTypeAnnotation\",\"BooleanTypeAnnotation\",\"BooleanLiteralTypeAnnotation\",\"StringTypeAnnotation\"];return node&&flowTypeAnnotations.includes(node.type)&&!(node.type===\"GenericTypeAnnotation\"&&node.typeParameters);}const unitTestRe=/^(skip|[fx]?(it|describe|test))$/;function isSkipOrOnlyBlock(node){return(node.callee.type===\"MemberExpression\"||node.callee.type===\"OptionalMemberExpression\")&&node.callee.object.type===\"Identifier\"&&node.callee.property.type===\"Identifier\"&&unitTestRe.test(node.callee.object.name)&&(node.callee.property.name===\"only\"||node.callee.property.name===\"skip\");}function isUnitTestSetUp(n){const unitTestSetUpRe=/^(before|after)(Each|All)$/;return n.callee.type===\"Identifier\"&&unitTestSetUpRe.test(n.callee.name)&&n.arguments.length===1;}// eg; `describe(\"some string\", (done) => {})`\nfunction isTestCall(n,parent){if(n.type!==\"CallExpression\"){return false;}if(n.arguments.length===1){if(isAngularTestWrapper(n)&&parent&&isTestCall(parent)){return isFunctionOrArrowExpression(n.arguments[0]);}if(isUnitTestSetUp(n)){return isAngularTestWrapper(n.arguments[0]);}}else if(n.arguments.length===2||n.arguments.length===3){if((n.callee.type===\"Identifier\"&&unitTestRe.test(n.callee.name)||isSkipOrOnlyBlock(n))&&(isTemplateLiteral(n.arguments[0])||isStringLiteral(n.arguments[0]))){// it(\"name\", () => { ... }, 2500)\nif(n.arguments[2]&&!isNumericLiteral(n.arguments[2])){return false;}return(n.arguments.length===2?isFunctionOrArrowExpression(n.arguments[1]):isFunctionOrArrowExpressionWithBody(n.arguments[1])&&n.arguments[1].params.length<=1)||isAngularTestWrapper(n.arguments[1]);}}return false;}function hasLeadingComment$2(node){return node.comments&&node.comments.some(comment=>comment.leading);}function hasTrailingComment(node){return node.comments&&node.comments.some(comment=>comment.trailing);}function isCallOrOptionalCallExpression(node){return node.type===\"CallExpression\"||node.type===\"OptionalCallExpression\";}function hasDanglingComments(node){return node.comments&&node.comments.some(comment=>!comment.leading&&!comment.trailing);}/** identify if an angular expression seems to have side effects */function hasNgSideEffect(path){return hasNode(path.getValue(),node=>{switch(node.type){case undefined:return false;case\"CallExpression\":case\"OptionalCallExpression\":case\"AssignmentExpression\":return true;}});}function isNgForOf(node,index,parentNode){return node.type===\"NGMicrosyntaxKeyedExpression\"&&node.key.name===\"of\"&&index===1&&parentNode.body[0].type===\"NGMicrosyntaxLet\"&&parentNode.body[0].value===null;}/** @param node {import(\"estree\").TemplateLiteral} */function isSimpleTemplateLiteral(node){if(node.expressions.length===0){return false;}return node.expressions.every(expr=>{// Disallow comments since printDocToString can't print them here\nif(expr.comments){return false;}// Allow `x` and `this`\nif(expr.type===\"Identifier\"||expr.type===\"ThisExpression\"){return true;}// Allow `a.b.c`, `a.b[c]`, and `this.x.y`\nif(expr.type===\"MemberExpression\"||expr.type===\"OptionalMemberExpression\"){let head=expr;while(head.type===\"MemberExpression\"||head.type===\"OptionalMemberExpression\"){if(head.property.type!==\"Identifier\"&&head.property.type!==\"Literal\"&&head.property.type!==\"StringLiteral\"&&head.property.type!==\"NumericLiteral\"){return false;}head=head.object;if(head.comments){return false;}}if(head.type===\"Identifier\"||head.type===\"ThisExpression\"){return true;}return false;}return false;});}function getFlowVariance(path){if(!path.variance){return null;}// Babel 7.0 currently uses variance node type, and flow should\n// follow suit soon:\n// https://github.com/babel/babel/issues/4722\nconst variance=path.variance.kind||path.variance;switch(variance){case\"plus\":return\"+\";case\"minus\":return\"-\";default:/* istanbul ignore next */return variance;}}function classPropMayCauseASIProblems(path){const node=path.getNode();if(node.type!==\"ClassProperty\"){return false;}const name=node.key&&node.key.name;// this isn't actually possible yet with most parsers available today\n// so isn't properly tested yet.\nif((name===\"static\"||name===\"get\"||name===\"set\")&&!node.value&&!node.typeAnnotation){return true;}}function classChildNeedsASIProtection(node){if(!node){return;}if(node.static||node.accessibility// TypeScript\n){return false;}if(!node.computed){const name=node.key&&node.key.name;if(name===\"in\"||name===\"instanceof\"){return true;}}switch(node.type){case\"ClassProperty\":case\"TSAbstractClassProperty\":return node.computed;case\"MethodDefinition\":// Flow\ncase\"TSAbstractMethodDefinition\":// TypeScript\ncase\"ClassMethod\":case\"ClassPrivateMethod\":{// Babel\nconst isAsync=node.value?node.value.async:node.async;const isGenerator=node.value?node.value.generator:node.generator;if(isAsync||node.kind===\"get\"||node.kind===\"set\"){return false;}if(node.computed||isGenerator){return true;}return false;}case\"TSIndexSignature\":return true;default:/* istanbul ignore next */return false;}}function getTypeScriptMappedTypeModifier(tokenNode,keyword){if(tokenNode===\"+\"){return\"+\"+keyword;}else if(tokenNode===\"-\"){return\"-\"+keyword;}return keyword;}function hasNewlineBetweenOrAfterDecorators(node,options){return hasNewlineInRange$2(options.originalText,options.locStart(node.decorators[0]),options.locEnd(getLast$2(node.decorators)))||hasNewline$4(options.originalText,options.locEnd(getLast$2(node.decorators)));}// Only space, newline, carriage return, and tab are treated as whitespace\n// inside JSX.\nconst jsxWhitespaceChars=\" \\n\\r\\t\";const matchJsxWhitespaceRegex=new RegExp(\"([\"+jsxWhitespaceChars+\"]+)\");const containsNonJsxWhitespaceRegex=new RegExp(\"[^\"+jsxWhitespaceChars+\"]\");// Meaningful if it contains non-whitespace characters,\n// or it contains whitespace without a new line.\nfunction isMeaningfulJSXText(node){return isLiteral(node)&&(containsNonJsxWhitespaceRegex.test(rawText(node))||!/\\n/.test(rawText(node)));}function hasJsxIgnoreComment(path){const node=path.getValue();const parent=path.getParentNode();if(!parent||!node||!isJSXNode(node)||!isJSXNode(parent)){return false;}// Lookup the previous sibling, ignoring any empty JSXText elements\nconst index=parent.children.indexOf(node);let prevSibling=null;for(let i=index;i>0;i--){const candidate=parent.children[i-1];if(candidate.type===\"JSXText\"&&!isMeaningfulJSXText(candidate)){continue;}prevSibling=candidate;break;}return prevSibling&&prevSibling.type===\"JSXExpressionContainer\"&&prevSibling.expression.type===\"JSXEmptyExpression\"&&prevSibling.expression.comments&&prevSibling.expression.comments.find(comment=>comment.value.trim()===\"prettier-ignore\");}function isEmptyJSXElement(node){if(node.children.length===0){return true;}if(node.children.length>1){return false;}// if there is one text child and does not contain any meaningful text\n// we can treat the element as empty.\nconst child=node.children[0];return isLiteral(child)&&!isMeaningfulJSXText(child);}function hasPrettierIgnore$4(path){return hasIgnoreComment$3(path)||hasJsxIgnoreComment(path);}function isLastStatement(path){const parent=path.getParentNode();if(!parent){return true;}const node=path.getValue();const body=(parent.body||parent.consequent).filter(stmt=>stmt.type!==\"EmptyStatement\");return body&&body[body.length-1]===node;}function isFlowAnnotationComment(text,typeAnnotation,options){const start=options.locStart(typeAnnotation);const end=skipWhitespace$2(text,options.locEnd(typeAnnotation));return text.slice(start,start+2)===\"/*\"&&text.slice(end,end+2)===\"*/\";}function hasLeadingOwnLineComment(text,node,options){if(isJSXNode(node)){return hasNodeIgnoreComment$1(node);}const res=node.comments&&node.comments.some(comment=>comment.leading&&hasNewline$4(text,options.locEnd(comment)));return res;}// This recurses the return argument, looking for the first token\n// (the leftmost leaf node) and, if it (or its parents) has any\n// leadingComments, returns true (so it can be wrapped in parens).\nfunction returnArgumentHasLeadingComment(options,argument){if(hasLeadingOwnLineComment(options.originalText,argument,options)){return true;}if(hasNakedLeftSide(argument)){let leftMost=argument;let newLeftMost;while(newLeftMost=getLeftSide(leftMost)){leftMost=newLeftMost;if(hasLeadingOwnLineComment(options.originalText,leftMost,options)){return true;}}}return false;}function isStringPropSafeToCoerceToIdentifier(node,options){return isStringLiteral(node.key)&&isIdentifierName(node.key.value)&&options.parser!==\"json\"&&// With `--strictPropertyInitialization`, TS treats properties with quoted names differently than unquoted ones.\n// See https://github.com/microsoft/TypeScript/pull/20075\n!((options.parser===\"typescript\"||options.parser===\"babel-ts\")&&node.type===\"ClassProperty\");}function isJestEachTemplateLiteral(node,parentNode){/**\n     * describe.each`table`(name, fn)\n     * describe.only.each`table`(name, fn)\n     * describe.skip.each`table`(name, fn)\n     * test.each`table`(name, fn)\n     * test.only.each`table`(name, fn)\n     * test.skip.each`table`(name, fn)\n     *\n     * Ref: https://github.com/facebook/jest/pull/6102\n     */const jestEachTriggerRegex=/^[xf]?(describe|it|test)$/;return parentNode.type===\"TaggedTemplateExpression\"&&parentNode.quasi===node&&parentNode.tag.type===\"MemberExpression\"&&parentNode.tag.property.type===\"Identifier\"&&parentNode.tag.property.name===\"each\"&&(parentNode.tag.object.type===\"Identifier\"&&jestEachTriggerRegex.test(parentNode.tag.object.name)||parentNode.tag.object.type===\"MemberExpression\"&&parentNode.tag.object.property.type===\"Identifier\"&&(parentNode.tag.object.property.name===\"only\"||parentNode.tag.object.property.name===\"skip\")&&parentNode.tag.object.object.type===\"Identifier\"&&jestEachTriggerRegex.test(parentNode.tag.object.object.name));}function templateLiteralHasNewLines(template){return template.quasis.some(quasi=>quasi.value.raw.includes(\"\\n\"));}function isTemplateOnItsOwnLine(n,text,options){return(n.type===\"TemplateLiteral\"&&templateLiteralHasNewLines(n)||n.type===\"TaggedTemplateExpression\"&&templateLiteralHasNewLines(n.quasi))&&!hasNewline$4(text,options.locStart(n),{backwards:true});}function needsHardlineAfterDanglingComment(node){if(!node.comments){return false;}const lastDanglingComment=getLast$2(node.comments.filter(comment=>!comment.leading&&!comment.trailing));return lastDanglingComment&&!comments$1.isBlockComment(lastDanglingComment);}// If we have nested conditional expressions, we want to print them in JSX mode\n// if there's at least one JSXElement somewhere in the tree.\n//\n// A conditional expression chain like this should be printed in normal mode,\n// because there aren't JSXElements anywhere in it:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";\n//\n// But a conditional expression chain like this should be printed in JSX mode,\n// because there is a JSXElement in the last ConditionalExpression:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;\n//\n// This type of ConditionalExpression chain is structured like this in the AST:\n//\n// ConditionalExpression {\n//   test: ...,\n//   consequent: ...,\n//   alternate: ConditionalExpression {\n//     test: ...,\n//     consequent: ...,\n//     alternate: ConditionalExpression {\n//       test: ...,\n//       consequent: ...,\n//       alternate: ...,\n//     }\n//   }\n// }\n//\n// We want to traverse over that shape and convert it into a flat structure so\n// that we can find if there's a JSXElement somewhere inside.\nfunction getConditionalChainContents(node){// Given this code:\n//\n// // Using a ConditionalExpression as the consequent is uncommon, but should\n// // be handled.\n// A ? B : C ? D : E ? F ? G : H : I\n//\n// which has this AST:\n//\n// ConditionalExpression {\n//   test: Identifier(A),\n//   consequent: Identifier(B),\n//   alternate: ConditionalExpression {\n//     test: Identifier(C),\n//     consequent: Identifier(D),\n//     alternate: ConditionalExpression {\n//       test: Identifier(E),\n//       consequent: ConditionalExpression {\n//         test: Identifier(F),\n//         consequent: Identifier(G),\n//         alternate: Identifier(H),\n//       },\n//       alternate: Identifier(I),\n//     }\n//   }\n// }\n//\n// we should return this Array:\n//\n// [\n//   Identifier(A),\n//   Identifier(B),\n//   Identifier(C),\n//   Identifier(D),\n//   Identifier(E),\n//   Identifier(F),\n//   Identifier(G),\n//   Identifier(H),\n//   Identifier(I)\n// ];\n//\n// This loses the information about whether each node was the test,\n// consequent, or alternate, but we don't care about that here- we are only\n// flattening this structure to find if there's any JSXElements inside.\nconst nonConditionalExpressions=[];function recurse(node){if(node.type===\"ConditionalExpression\"){recurse(node.test);recurse(node.consequent);recurse(node.alternate);}else{nonConditionalExpressions.push(node);}}recurse(node);return nonConditionalExpressions;}function conditionalExpressionChainContainsJSX(node){return Boolean(getConditionalChainContents(node).find(isJSXNode));}// Logic to check for args with multiple anonymous functions. For instance,\n// the following call should be split on multiple lines for readability:\n// source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))\nfunction isFunctionCompositionArgs(args){if(args.length<=1){return false;}let count=0;for(const arg of args){if(isFunctionOrArrowExpression(arg)){count+=1;if(count>1){return true;}}else if(isCallOrOptionalCallExpression(arg)){for(const childArg of arg.arguments){if(isFunctionOrArrowExpression(childArg)){return true;}}}}return false;}// Logic to determine if a call is a “long curried function call”.\n// See https://github.com/prettier/prettier/issues/1420.\n//\n// `connect(a, b, c)(d)`\n// In the above call expression, the second call is the parent node and the\n// first call is the current node.\nfunction isLongCurriedCallExpression(path){const node=path.getValue();const parent=path.getParentNode();return isCallOrOptionalCallExpression(node)&&isCallOrOptionalCallExpression(parent)&&parent.callee===node&&node.arguments.length>parent.arguments.length&&parent.arguments.length>0;}/**\n   * @param {import('estree').Node} node\n   * @param {number} depth\n   * @returns {boolean}\n   */function isSimpleCallArgument(node,depth){if(depth>=2){return false;}const isChildSimple=child=>isSimpleCallArgument(child,depth+1);const regexpPattern=node.type===\"Literal\"&&node.regex&&node.regex.pattern||node.type===\"RegExpLiteral\"&&node.pattern;if(regexpPattern&&regexpPattern.length>5){return false;}if(node.type===\"Literal\"||node.type===\"BooleanLiteral\"||node.type===\"NullLiteral\"||node.type===\"NumericLiteral\"||node.type===\"StringLiteral\"||node.type===\"Identifier\"||node.type===\"ThisExpression\"||node.type===\"Super\"||node.type===\"BigIntLiteral\"||node.type===\"PrivateName\"||node.type===\"ArgumentPlaceholder\"||node.type===\"RegExpLiteral\"||node.type===\"Import\"){return true;}if(node.type===\"TemplateLiteral\"){return node.expressions.every(isChildSimple);}if(node.type===\"ObjectExpression\"){return node.properties.every(p=>!p.computed&&(p.shorthand||p.value&&isChildSimple(p.value)));}if(node.type===\"ArrayExpression\"){return node.elements.every(x=>x==null||isChildSimple(x));}if(node.type===\"CallExpression\"||node.type===\"OptionalCallExpression\"||node.type===\"NewExpression\"){return isSimpleCallArgument(node.callee,depth)&&node.arguments.every(isChildSimple);}if(node.type===\"MemberExpression\"||node.type===\"OptionalMemberExpression\"){return isSimpleCallArgument(node.object,depth)&&isSimpleCallArgument(node.property,depth);}if(node.type===\"UnaryExpression\"&&(node.operator===\"!\"||node.operator===\"-\")){return isSimpleCallArgument(node.argument,depth);}if(node.type===\"TSNonNullExpression\"){return isSimpleCallArgument(node.expression,depth);}return false;}function rawText(node){return node.extra?node.extra.raw:node.raw;}function identity$1(x){return x;}function isTSXFile(options){return options.filepath&&/\\.tsx$/i.test(options.filepath);}var utils$5={classChildNeedsASIProtection,classPropMayCauseASIProblems,conditionalExpressionChainContainsJSX,getFlowVariance,getLeftSidePathName,getParentExportDeclaration,getTypeScriptMappedTypeModifier,hasDanglingComments,hasFlowAnnotationComment,hasFlowShorthandAnnotationComment,hasLeadingComment:hasLeadingComment$2,hasLeadingOwnLineComment,hasNakedLeftSide,hasNewlineBetweenOrAfterDecorators,hasNgSideEffect,hasNode,hasPrettierIgnore:hasPrettierIgnore$4,hasTrailingComment,identity:identity$1,isBinaryish,isCallOrOptionalCallExpression,isEmptyJSXElement,isExportDeclaration,isFlowAnnotationComment,isFunctionCompositionArgs,isFunctionNotation,isFunctionOrArrowExpression,isGetterOrSetter,isJestEachTemplateLiteral,isJSXNode,isJSXWhitespaceExpression,isLastStatement,isLiteral,isLongCurriedCallExpression,isSimpleCallArgument,isMeaningfulJSXText,isMemberExpressionChain,isMemberish,isNgForOf,isNumericLiteral,isObjectType,isObjectTypePropertyAFunction,isSimpleFlowType,isSimpleTemplateLiteral,isStringLiteral,isStringPropSafeToCoerceToIdentifier,isTemplateOnItsOwnLine,isTestCall,isTheOnlyJSXElementInMarkdown,isTSXFile,isTypeAnnotationAFunction,matchJsxWhitespaceRegex,needsHardlineAfterDanglingComment,rawText,returnArgumentHasLeadingComment};const{getLeftSidePathName:getLeftSidePathName$1,hasFlowShorthandAnnotationComment:hasFlowShorthandAnnotationComment$1,hasNakedLeftSide:hasNakedLeftSide$1,hasNode:hasNode$1}=utils$5;function needsParens(path,options){const parent=path.getParentNode();if(!parent){return false;}const name=path.getName();const node=path.getNode();// If the value of this path is some child of a Node and not a Node\n// itself, then it doesn't need parentheses. Only Node objects (in\n// fact, only Expression nodes) need parentheses.\nif(path.getValue()!==node){return false;}// to avoid unexpected `}}` in HTML interpolations\nif(options.__isInHtmlInterpolation&&!options.bracketSpacing&&endsWithRightBracket(node)&&isFollowedByRightBracket(path)){return true;}// Only statements don't need parentheses.\nif(isStatement(node)){return false;}if(// Preserve parens if we have a Flow annotation comment, unless we're using the Flow\n// parser. The Flow parser turns Flow comments into type annotation nodes in its\n// AST, which we handle separately.\noptions.parser!==\"flow\"&&hasFlowShorthandAnnotationComment$1(path.getValue())){return true;}// Identifiers never need parentheses.\nif(node.type===\"Identifier\"){// ...unless those identifiers are embed placeholders. They might be substituted by complex\n// expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):\n//     let tpl = html`<script> f((${expr}) / 2); </script>`;\n// If the inner JS formatter removes the parens, the expression might change its meaning:\n//     f((a + b) / 2)  vs  f(a + b / 2)\nif(node.extra&&node.extra.parenthesized&&/^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)){return true;}return false;}if(parent.type===\"ParenthesizedExpression\"){return false;}// Add parens around the extends clause of a class. It is needed for almost\n// all expressions.\nif((parent.type===\"ClassDeclaration\"||parent.type===\"ClassExpression\")&&parent.superClass===node&&(node.type===\"ArrowFunctionExpression\"||node.type===\"AssignmentExpression\"||node.type===\"AwaitExpression\"||node.type===\"BinaryExpression\"||node.type===\"ConditionalExpression\"||node.type===\"LogicalExpression\"||node.type===\"NewExpression\"||node.type===\"ObjectExpression\"||node.type===\"ParenthesizedExpression\"||node.type===\"SequenceExpression\"||node.type===\"TaggedTemplateExpression\"||node.type===\"UnaryExpression\"||node.type===\"UpdateExpression\"||node.type===\"YieldExpression\")){return true;}if(parent.type===\"ExportDefaultDeclaration\"){return(// `export default function` or `export default class` can't be followed by\n// anything after. So an expression like `export default (function(){}).toString()`\n// needs to be followed by a parentheses\nshouldWrapFunctionForExportDefault(path,options)||// `export default (foo, bar)` also needs parentheses\nnode.type===\"SequenceExpression\");}if(parent.type===\"Decorator\"&&parent.expression===node){let hasCallExpression=false;let hasMemberExpression=false;let current=node;while(current){switch(current.type){case\"MemberExpression\":hasMemberExpression=true;current=current.object;break;case\"CallExpression\":if(/** @(x().y) */hasMemberExpression||/** @(x().y()) */hasCallExpression){return true;}hasCallExpression=true;current=current.callee;break;case\"Identifier\":return false;default:return true;}}return true;}if(parent.type===\"ArrowFunctionExpression\"&&parent.body===node&&node.type!==\"SequenceExpression\"&&// these have parens added anyway\nutil$1.startsWithNoLookaheadToken(node,/* forbidFunctionClassAndDoExpr */false)||parent.type===\"ExpressionStatement\"&&util$1.startsWithNoLookaheadToken(node,/* forbidFunctionClassAndDoExpr */true)){return true;}switch(node.type){case\"SpreadElement\":case\"SpreadProperty\":return parent.type===\"MemberExpression\"&&name===\"object\"&&parent.object===node;case\"UpdateExpression\":if(parent.type===\"UnaryExpression\"){return node.prefix&&(node.operator===\"++\"&&parent.operator===\"+\"||node.operator===\"--\"&&parent.operator===\"-\");}// else fallthrough\ncase\"UnaryExpression\":switch(parent.type){case\"UnaryExpression\":return node.operator===parent.operator&&(node.operator===\"+\"||node.operator===\"-\");case\"BindExpression\":return true;case\"MemberExpression\":case\"OptionalMemberExpression\":return name===\"object\";case\"TaggedTemplateExpression\":return true;case\"NewExpression\":case\"CallExpression\":case\"OptionalCallExpression\":return name===\"callee\";case\"BinaryExpression\":return parent.operator===\"**\"&&name===\"left\";case\"TSNonNullExpression\":return true;default:return false;}case\"BinaryExpression\":{if(parent.type===\"UpdateExpression\"){return true;}const isLeftOfAForStatement=node=>{let i=0;while(node){const parent=path.getParentNode(i++);if(!parent){return false;}if(parent.type===\"ForStatement\"&&parent.init===node){return true;}node=parent;}return false;};if(node.operator===\"in\"&&isLeftOfAForStatement(node)){return true;}}// fallthrough\ncase\"TSTypeAssertion\":case\"TSAsExpression\":case\"LogicalExpression\":switch(parent.type){case\"ConditionalExpression\":return node.type===\"TSAsExpression\";case\"CallExpression\":case\"NewExpression\":case\"OptionalCallExpression\":return name===\"callee\";case\"ClassExpression\":case\"ClassDeclaration\":return name===\"superClass\"&&parent.superClass===node;case\"TSTypeAssertion\":case\"TaggedTemplateExpression\":case\"UnaryExpression\":case\"JSXSpreadAttribute\":case\"SpreadElement\":case\"SpreadProperty\":case\"BindExpression\":case\"AwaitExpression\":case\"TSAsExpression\":case\"TSNonNullExpression\":case\"UpdateExpression\":return true;case\"MemberExpression\":case\"OptionalMemberExpression\":return name===\"object\";case\"AssignmentExpression\":return parent.left===node&&(node.type===\"TSTypeAssertion\"||node.type===\"TSAsExpression\");case\"LogicalExpression\":if(node.type===\"LogicalExpression\"){return parent.operator!==node.operator;}// else fallthrough\ncase\"BinaryExpression\":{if(!node.operator&&node.type!==\"TSTypeAssertion\"){return true;}const po=parent.operator;const pp=util$1.getPrecedence(po);const no=node.operator;const np=util$1.getPrecedence(no);if(pp>np){return true;}if(pp===np&&name===\"right\"){assert.strictEqual(parent.right,node);return true;}if(pp===np&&!util$1.shouldFlatten(po,no)){return true;}if(pp<np&&no===\"%\"){return po===\"+\"||po===\"-\";}// Add parenthesis when working with bitwise operators\n// It's not strictly needed but helps with code understanding\nif(util$1.isBitwiseOperator(po)){return true;}return false;}default:return false;}case\"SequenceExpression\":switch(parent.type){case\"ReturnStatement\":return false;case\"ForStatement\":// Although parentheses wouldn't hurt around sequence\n// expressions in the head of for loops, traditional style\n// dictates that e.g. i++, j++ should not be wrapped with\n// parentheses.\nreturn false;case\"ExpressionStatement\":return name!==\"expression\";case\"ArrowFunctionExpression\":// We do need parentheses, but SequenceExpressions are handled\n// specially when printing bodies of arrow functions.\nreturn name!==\"body\";default:// Otherwise err on the side of overparenthesization, adding\n// explicit exceptions above if this proves overzealous.\nreturn true;}case\"YieldExpression\":if(parent.type===\"UnaryExpression\"||parent.type===\"AwaitExpression\"||parent.type===\"TSAsExpression\"||parent.type===\"TSNonNullExpression\"){return true;}// else fallthrough\ncase\"AwaitExpression\":switch(parent.type){case\"TaggedTemplateExpression\":case\"UnaryExpression\":case\"BinaryExpression\":case\"LogicalExpression\":case\"SpreadElement\":case\"SpreadProperty\":case\"TSAsExpression\":case\"TSNonNullExpression\":case\"BindExpression\":return true;case\"MemberExpression\":case\"OptionalMemberExpression\":return name===\"object\";case\"NewExpression\":case\"CallExpression\":case\"OptionalCallExpression\":return name===\"callee\";case\"ConditionalExpression\":return parent.test===node;default:return false;}case\"TSJSDocFunctionType\":case\"TSConditionalType\":if(parent.type===\"TSConditionalType\"&&node===parent.extendsType){return true;}// fallthrough\ncase\"TSFunctionType\":case\"TSConstructorType\":if(parent.type===\"TSConditionalType\"&&node===parent.checkType){return true;}// fallthrough\ncase\"TSUnionType\":case\"TSIntersectionType\":if(parent.type===\"TSUnionType\"||parent.type===\"TSIntersectionType\"){return true;}// fallthrough\ncase\"TSTypeOperator\":case\"TSInferType\":return parent.type===\"TSArrayType\"||parent.type===\"TSOptionalType\"||parent.type===\"TSRestType\"||parent.type===\"TSIndexedAccessType\"&&node===parent.objectType||parent.type===\"TSTypeOperator\"||parent.type===\"TSTypeAnnotation\"&&/^TSJSDoc/.test(path.getParentNode(1).type);case\"ArrayTypeAnnotation\":return parent.type===\"NullableTypeAnnotation\";case\"IntersectionTypeAnnotation\":case\"UnionTypeAnnotation\":return parent.type===\"ArrayTypeAnnotation\"||parent.type===\"NullableTypeAnnotation\"||parent.type===\"IntersectionTypeAnnotation\"||parent.type===\"UnionTypeAnnotation\";case\"NullableTypeAnnotation\":return parent.type===\"ArrayTypeAnnotation\";case\"FunctionTypeAnnotation\":{const ancestor=parent.type===\"NullableTypeAnnotation\"?path.getParentNode(1):parent;return ancestor.type===\"UnionTypeAnnotation\"||ancestor.type===\"IntersectionTypeAnnotation\"||ancestor.type===\"ArrayTypeAnnotation\"||// We should check ancestor's parent to know whether the parentheses\n// are really needed, but since ??T doesn't make sense this check\n// will almost never be true.\nancestor.type===\"NullableTypeAnnotation\";}case\"StringLiteral\":case\"NumericLiteral\":case\"Literal\":if(typeof node.value===\"string\"&&parent.type===\"ExpressionStatement\"&&(// TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n// See corresponding workaround in printer.js case: \"Literal\"\noptions.parser!==\"typescript\"&&!parent.directive||options.parser===\"typescript\"&&options.originalText.charAt(options.locStart(node)-1)===\"(\")){// To avoid becoming a directive\nconst grandParent=path.getParentNode(1);return grandParent.type===\"Program\"||grandParent.type===\"BlockStatement\";}return parent.type===\"MemberExpression\"&&typeof node.value===\"number\"&&name===\"object\"&&parent.object===node;case\"AssignmentExpression\":{const grandParent=path.getParentNode(1);if(parent.type===\"ArrowFunctionExpression\"&&parent.body===node){return true;}else if(parent.type===\"ClassProperty\"&&parent.key===node&&parent.computed){return false;}else if(parent.type===\"TSPropertySignature\"&&parent.name===node){return false;}else if(parent.type===\"ForStatement\"&&(parent.init===node||parent.update===node)){return false;}else if(parent.type===\"ExpressionStatement\"){return node.left.type===\"ObjectPattern\";}else if(parent.type===\"TSPropertySignature\"&&parent.key===node){return false;}else if(parent.type===\"AssignmentExpression\"){return false;}else if(parent.type===\"SequenceExpression\"&&grandParent&&grandParent.type===\"ForStatement\"&&(grandParent.init===parent||grandParent.update===parent)){return false;}else if(parent.type===\"Property\"&&parent.value===node){return false;}else if(parent.type===\"NGChainedExpression\"){return false;}return true;}case\"ConditionalExpression\":switch(parent.type){case\"TaggedTemplateExpression\":case\"UnaryExpression\":case\"SpreadElement\":case\"SpreadProperty\":case\"BinaryExpression\":case\"LogicalExpression\":case\"NGPipeExpression\":case\"ExportDefaultDeclaration\":case\"AwaitExpression\":case\"JSXSpreadAttribute\":case\"TSTypeAssertion\":case\"TypeCastExpression\":case\"TSAsExpression\":case\"TSNonNullExpression\":return true;case\"NewExpression\":case\"CallExpression\":case\"OptionalCallExpression\":return name===\"callee\";case\"ConditionalExpression\":return name===\"test\"&&parent.test===node;case\"MemberExpression\":case\"OptionalMemberExpression\":return name===\"object\";default:return false;}case\"FunctionExpression\":switch(parent.type){case\"NewExpression\":case\"CallExpression\":case\"OptionalCallExpression\":// Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n// Is necessary if it is `expression` of `ExpressionStatement`.\nreturn name===\"callee\";case\"TaggedTemplateExpression\":return true;// This is basically a kind of IIFE.\ndefault:return false;}case\"ArrowFunctionExpression\":switch(parent.type){case\"NewExpression\":case\"CallExpression\":case\"OptionalCallExpression\":return name===\"callee\";case\"MemberExpression\":case\"OptionalMemberExpression\":return name===\"object\";case\"TSAsExpression\":case\"BindExpression\":case\"TaggedTemplateExpression\":case\"UnaryExpression\":case\"LogicalExpression\":case\"BinaryExpression\":case\"AwaitExpression\":case\"TSTypeAssertion\":return true;case\"ConditionalExpression\":return name===\"test\";default:return false;}case\"ClassExpression\":switch(parent.type){case\"NewExpression\":return name===\"callee\"&&parent.callee===node;default:return false;}case\"OptionalMemberExpression\":case\"OptionalCallExpression\":if(parent.type===\"MemberExpression\"&&name===\"object\"||(parent.type===\"CallExpression\"||parent.type===\"NewExpression\")&&name===\"callee\"){return true;}// fallthrough\ncase\"CallExpression\":case\"MemberExpression\":case\"TaggedTemplateExpression\":case\"TSNonNullExpression\":if((parent.type===\"BindExpression\"||parent.type===\"NewExpression\")&&name===\"callee\"){let object=node;while(object){switch(object.type){case\"CallExpression\":case\"OptionalCallExpression\":return true;case\"MemberExpression\":case\"OptionalMemberExpression\":case\"BindExpression\":object=object.object;break;// tagged templates are basically member expressions from a grammar perspective\n// see https://tc39.github.io/ecma262/#prod-MemberExpression\ncase\"TaggedTemplateExpression\":object=object.tag;break;case\"TSNonNullExpression\":object=object.expression;break;default:return false;}}}return false;case\"BindExpression\":return(parent.type===\"BindExpression\"||parent.type===\"NewExpression\")&&name===\"callee\"||(parent.type===\"MemberExpression\"||parent.type===\"OptionalMemberExpression\")&&name===\"object\";case\"NGPipeExpression\":if(parent.type===\"NGRoot\"||parent.type===\"NGMicrosyntaxExpression\"||parent.type===\"ObjectProperty\"||parent.type===\"ArrayExpression\"||(parent.type===\"CallExpression\"||parent.type===\"OptionalCallExpression\")&&parent.arguments[name]===node||parent.type===\"NGPipeExpression\"&&name===\"right\"||parent.type===\"MemberExpression\"&&name===\"property\"||parent.type===\"AssignmentExpression\"){return false;}return true;case\"JSXFragment\":case\"JSXElement\":return name===\"callee\"||parent.type!==\"ArrayExpression\"&&parent.type!==\"ArrowFunctionExpression\"&&parent.type!==\"AssignmentExpression\"&&parent.type!==\"AssignmentPattern\"&&parent.type!==\"BinaryExpression\"&&parent.type!==\"CallExpression\"&&parent.type!==\"NewExpression\"&&parent.type!==\"ConditionalExpression\"&&parent.type!==\"ExpressionStatement\"&&parent.type!==\"JsExpressionRoot\"&&parent.type!==\"JSXAttribute\"&&parent.type!==\"JSXElement\"&&parent.type!==\"JSXExpressionContainer\"&&parent.type!==\"JSXFragment\"&&parent.type!==\"LogicalExpression\"&&parent.type!==\"ObjectProperty\"&&parent.type!==\"OptionalCallExpression\"&&parent.type!==\"Property\"&&parent.type!==\"ReturnStatement\"&&parent.type!==\"ThrowStatement\"&&parent.type!==\"TypeCastExpression\"&&parent.type!==\"VariableDeclarator\"&&parent.type!==\"YieldExpression\";case\"TypeAnnotation\":return name===\"returnType\"&&parent.type===\"ArrowFunctionExpression\"&&includesFunctionTypeInObjectType(node);}return false;}function isStatement(node){return node.type===\"BlockStatement\"||node.type===\"BreakStatement\"||node.type===\"ClassBody\"||node.type===\"ClassDeclaration\"||node.type===\"ClassMethod\"||node.type===\"ClassProperty\"||node.type===\"ClassPrivateProperty\"||node.type===\"ContinueStatement\"||node.type===\"DebuggerStatement\"||node.type===\"DeclareClass\"||node.type===\"DeclareExportAllDeclaration\"||node.type===\"DeclareExportDeclaration\"||node.type===\"DeclareFunction\"||node.type===\"DeclareInterface\"||node.type===\"DeclareModule\"||node.type===\"DeclareModuleExports\"||node.type===\"DeclareVariable\"||node.type===\"DoWhileStatement\"||node.type===\"EnumDeclaration\"||node.type===\"ExportAllDeclaration\"||node.type===\"ExportDefaultDeclaration\"||node.type===\"ExportNamedDeclaration\"||node.type===\"ExpressionStatement\"||node.type===\"ForInStatement\"||node.type===\"ForOfStatement\"||node.type===\"ForStatement\"||node.type===\"FunctionDeclaration\"||node.type===\"IfStatement\"||node.type===\"ImportDeclaration\"||node.type===\"InterfaceDeclaration\"||node.type===\"LabeledStatement\"||node.type===\"MethodDefinition\"||node.type===\"ReturnStatement\"||node.type===\"SwitchStatement\"||node.type===\"ThrowStatement\"||node.type===\"TryStatement\"||node.type===\"TSDeclareFunction\"||node.type===\"TSEnumDeclaration\"||node.type===\"TSImportEqualsDeclaration\"||node.type===\"TSInterfaceDeclaration\"||node.type===\"TSModuleDeclaration\"||node.type===\"TSNamespaceExportDeclaration\"||node.type===\"TypeAlias\"||node.type===\"VariableDeclaration\"||node.type===\"WhileStatement\"||node.type===\"WithStatement\";}function includesFunctionTypeInObjectType(node){return hasNode$1(node,n1=>n1.type===\"ObjectTypeAnnotation\"&&hasNode$1(n1,n2=>n2.type===\"FunctionTypeAnnotation\"||undefined)||undefined);}function endsWithRightBracket(node){switch(node.type){case\"ObjectExpression\":return true;default:return false;}}function isFollowedByRightBracket(path){const node=path.getValue();const parent=path.getParentNode();const name=path.getName();switch(parent.type){case\"NGPipeExpression\":if(typeof name===\"number\"&&parent.arguments[name]===node&&parent.arguments.length-1===name){return path.callParent(isFollowedByRightBracket);}break;case\"ObjectProperty\":if(name===\"value\"){const parentParent=path.getParentNode(1);return parentParent.properties[parentParent.properties.length-1]===parent;}break;case\"BinaryExpression\":case\"LogicalExpression\":if(name===\"right\"){return path.callParent(isFollowedByRightBracket);}break;case\"ConditionalExpression\":if(name===\"alternate\"){return path.callParent(isFollowedByRightBracket);}break;case\"UnaryExpression\":if(parent.prefix){return path.callParent(isFollowedByRightBracket);}break;}return false;}function shouldWrapFunctionForExportDefault(path,options){const node=path.getValue();const parent=path.getParentNode();if(node.type===\"FunctionExpression\"||node.type===\"ClassExpression\"){return parent.type===\"ExportDefaultDeclaration\"||// in some cases the function is already wrapped\n// (e.g. `export default (function() {})();`)\n// in this case we don't need to add extra parens\n!needsParens(path,options);}if(!hasNakedLeftSide$1(node)||parent.type!==\"ExportDefaultDeclaration\"&&needsParens(path,options)){return false;}return path.call(childPath=>shouldWrapFunctionForExportDefault(childPath,options),...getLeftSidePathName$1(path,node));}var needsParens_1=needsParens;const{builders:{concat:concat$c,join:join$8,line:line$8}}=document;function printHtmlBinding(path,options,print){const node=path.getValue();if(options.__onHtmlBindingRoot&&path.getName()===null){options.__onHtmlBindingRoot(node,options);}if(node.type!==\"File\"){return;}if(options.__isVueForBindingLeft){return path.call(functionDeclarationPath=>{const{params}=functionDeclarationPath.getValue();return concat$c([params.length>1?\"(\":\"\",join$8(concat$c([\",\",line$8]),functionDeclarationPath.map(print,\"params\")),params.length>1?\")\":\"\"]);},\"program\",\"body\",0);}if(options.__isVueSlotScope){return path.call(functionDeclarationPath=>join$8(concat$c([\",\",line$8]),functionDeclarationPath.map(print,\"params\")),\"program\",\"body\",0);}}// based on https://github.com/prettier/prettier/blob/master/src/language-html/syntax-vue.js isVueEventBindingExpression()\nfunction isVueEventBindingExpression$2(node){switch(node.type){case\"MemberExpression\":switch(node.property.type){case\"Identifier\":case\"NumericLiteral\":case\"StringLiteral\":return isVueEventBindingExpression$2(node.object);}return false;case\"Identifier\":return true;default:return false;}}var htmlBinding={isVueEventBindingExpression:isVueEventBindingExpression$2,printHtmlBinding};function preprocess$1(ast,options){switch(options.parser){case\"json\":case\"json5\":case\"json-stringify\":case\"__js_expression\":case\"__vue_expression\":return Object.assign({},ast,{type:options.parser.startsWith(\"__\")?\"JsExpressionRoot\":\"JsonRoot\",node:ast,comments:[],rootMarker:options.rootMarker});default:return ast;}}var preprocess_1$1=preprocess$1;const{shouldFlatten:shouldFlatten$1,getNextNonSpaceNonCommentCharacter:getNextNonSpaceNonCommentCharacter$1,hasNewline:hasNewline$5,hasNewlineInRange:hasNewlineInRange$3,getLast:getLast$3,getStringWidth:getStringWidth$3,printString:printString$2,printNumber:printNumber$2,hasIgnoreComment:hasIgnoreComment$4,hasNodeIgnoreComment:hasNodeIgnoreComment$2,getPenultimate:getPenultimate$1,startsWithNoLookaheadToken:startsWithNoLookaheadToken$1,getIndentSize:getIndentSize$2,getPreferredQuote:getPreferredQuote$1}=util$1;const{isNextLineEmpty:isNextLineEmpty$4,isNextLineEmptyAfterIndex:isNextLineEmptyAfterIndex$2,getNextNonSpaceNonCommentCharacterIndex:getNextNonSpaceNonCommentCharacterIndex$3}=utilShared;const{insertPragma:insertPragma$7}=pragma;const{printHtmlBinding:printHtmlBinding$1,isVueEventBindingExpression:isVueEventBindingExpression$3}=htmlBinding;const{classChildNeedsASIProtection:classChildNeedsASIProtection$1,classPropMayCauseASIProblems:classPropMayCauseASIProblems$1,conditionalExpressionChainContainsJSX:conditionalExpressionChainContainsJSX$1,getFlowVariance:getFlowVariance$1,getLeftSidePathName:getLeftSidePathName$2,getParentExportDeclaration:getParentExportDeclaration$1,getTypeScriptMappedTypeModifier:getTypeScriptMappedTypeModifier$1,hasDanglingComments:hasDanglingComments$1,hasFlowAnnotationComment:hasFlowAnnotationComment$1,hasFlowShorthandAnnotationComment:hasFlowShorthandAnnotationComment$2,hasLeadingComment:hasLeadingComment$3,hasLeadingOwnLineComment:hasLeadingOwnLineComment$1,hasNakedLeftSide:hasNakedLeftSide$2,hasNewlineBetweenOrAfterDecorators:hasNewlineBetweenOrAfterDecorators$1,hasNgSideEffect:hasNgSideEffect$1,hasPrettierIgnore:hasPrettierIgnore$5,hasTrailingComment:hasTrailingComment$1,identity:identity$2,isBinaryish:isBinaryish$1,isCallOrOptionalCallExpression:isCallOrOptionalCallExpression$1,isEmptyJSXElement:isEmptyJSXElement$1,isExportDeclaration:isExportDeclaration$1,isFlowAnnotationComment:isFlowAnnotationComment$1,isFunctionCompositionArgs:isFunctionCompositionArgs$1,isFunctionNotation:isFunctionNotation$1,isFunctionOrArrowExpression:isFunctionOrArrowExpression$1,isGetterOrSetter:isGetterOrSetter$1,isJestEachTemplateLiteral:isJestEachTemplateLiteral$1,isJSXNode:isJSXNode$1,isJSXWhitespaceExpression:isJSXWhitespaceExpression$1,isLastStatement:isLastStatement$1,isLiteral:isLiteral$1,isLongCurriedCallExpression:isLongCurriedCallExpression$1,isMeaningfulJSXText:isMeaningfulJSXText$1,isMemberExpressionChain:isMemberExpressionChain$1,isMemberish:isMemberish$1,isNgForOf:isNgForOf$1,isNumericLiteral:isNumericLiteral$1,isObjectType:isObjectType$1,isObjectTypePropertyAFunction:isObjectTypePropertyAFunction$1,isSimpleCallArgument:isSimpleCallArgument$1,isSimpleFlowType:isSimpleFlowType$1,isSimpleTemplateLiteral:isSimpleTemplateLiteral$1,isStringLiteral:isStringLiteral$1,isStringPropSafeToCoerceToIdentifier:isStringPropSafeToCoerceToIdentifier$1,isTemplateOnItsOwnLine:isTemplateOnItsOwnLine$1,isTestCall:isTestCall$1,isTheOnlyJSXElementInMarkdown:isTheOnlyJSXElementInMarkdown$1,isTSXFile:isTSXFile$1,isTypeAnnotationAFunction:isTypeAnnotationAFunction$1,matchJsxWhitespaceRegex:matchJsxWhitespaceRegex$1,needsHardlineAfterDanglingComment:needsHardlineAfterDanglingComment$1,rawText:rawText$1,returnArgumentHasLeadingComment:returnArgumentHasLeadingComment$1}=utils$5;const needsQuoteProps=new WeakMap();const{builders:{concat:concat$d,join:join$9,line:line$9,hardline:hardline$9,softline:softline$6,literalline:literalline$4,group:group$b,indent:indent$7,align:align$1,conditionalGroup:conditionalGroup$1,fill:fill$4,ifBreak:ifBreak$6,breakParent:breakParent$3,lineSuffixBoundary:lineSuffixBoundary$1,addAlignmentToDoc:addAlignmentToDoc$2,dedent:dedent$2},utils:{willBreak:willBreak$1,isLineNext:isLineNext$1,isEmpty:isEmpty$1,removeLines:removeLines$2},printer:{printDocToString:printDocToString$2}}=document;let uid=0;function shouldPrintComma$1(options,level){level=level||\"es5\";switch(options.trailingComma){case\"all\":if(level===\"all\"){return true;}// fallthrough\ncase\"es5\":if(level===\"es5\"){return true;}// fallthrough\ncase\"none\":default:return false;}}function genericPrint$3(path,options,printPath,args){const node=path.getValue();let needsParens=false;const linesWithoutParens=printPathNoParens(path,options,printPath,args);if(!node||isEmpty$1(linesWithoutParens)){return linesWithoutParens;}const parentExportDecl=getParentExportDeclaration$1(path);const decorators=[];if(node.type===\"ClassMethod\"||node.type===\"ClassPrivateMethod\"||node.type===\"ClassProperty\"||node.type===\"TSAbstractClassProperty\"||node.type===\"ClassPrivateProperty\"||node.type===\"MethodDefinition\"||node.type===\"TSAbstractMethodDefinition\"||node.type===\"TSDeclareMethod\");else if(node.decorators&&node.decorators.length>0&&// If the parent node is an export declaration and the decorator\n// was written before the export, the export will be responsible\n// for printing the decorators.\n!(parentExportDecl&&options.locStart(parentExportDecl,{ignoreDecorators:true})>options.locStart(node.decorators[0]))){const shouldBreak=node.type===\"ClassExpression\"||node.type===\"ClassDeclaration\"||hasNewlineBetweenOrAfterDecorators$1(node,options);const separator=shouldBreak?hardline$9:line$9;path.each(decoratorPath=>{let decorator=decoratorPath.getValue();if(decorator.expression){decorator=decorator.expression;}else{decorator=decorator.callee;}decorators.push(printPath(decoratorPath),separator);},\"decorators\");if(parentExportDecl){decorators.unshift(hardline$9);}}else if(isExportDeclaration$1(node)&&node.declaration&&node.declaration.decorators&&node.declaration.decorators.length>0&&// Only print decorators here if they were written before the export,\n// otherwise they are printed by the node.declaration\noptions.locStart(node,{ignoreDecorators:true})>options.locStart(node.declaration.decorators[0])){// Export declarations are responsible for printing any decorators\n// that logically apply to node.declaration.\npath.each(decoratorPath=>{const decorator=decoratorPath.getValue();const prefix=decorator.type===\"Decorator\"?\"\":\"@\";decorators.push(prefix,printPath(decoratorPath),hardline$9);},\"declaration\",\"decorators\");}else{// Nodes with decorators can't have parentheses, so we can avoid\n// computing pathNeedsParens() except in this case.\nneedsParens=needsParens_1(path,options);}const parts=[];if(needsParens){parts.unshift(\"(\");}parts.push(linesWithoutParens);if(needsParens){const node=path.getValue();if(hasFlowShorthandAnnotationComment$2(node)){parts.push(\" /*\");parts.push(node.trailingComments[0].value.trimStart());parts.push(\"*/\");node.trailingComments[0].printed=true;}parts.push(\")\");}if(decorators.length>0){return group$b(concat$d(decorators.concat(parts)));}return concat$d(parts);}function printDecorators(path,options,print){const node=path.getValue();return group$b(concat$d([join$9(line$9,path.map(print,\"decorators\")),hasNewlineBetweenOrAfterDecorators$1(node,options)?hardline$9:line$9]));}/**\n   * The following is the shared logic for\n   * ternary operators, namely ConditionalExpression\n   * and TSConditionalType\n   * @typedef {Object} OperatorOptions\n   * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.\n   * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.\n   * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.\n   * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".\n   * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".\n   * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".\n   * @property {string[]} testNodePropertyNames - The properties at which the test nodes can be found on the main node, eg \"test\".\n   * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.\n   * @param {Options} options - Prettier options\n   * @param {Function} print - Print function to call recursively\n   * @param {OperatorOptions} operatorOptions\n   * @returns Doc\n   */function printTernaryOperator(path,options,print,operatorOptions){const node=path.getValue();const consequentNode=node[operatorOptions.consequentNodePropertyName];const alternateNode=node[operatorOptions.alternateNodePropertyName];const parts=[];// We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".\n// See tests/jsx/conditional-expression.js for more info.\nlet jsxMode=false;const parent=path.getParentNode();const isParentTest=parent.type===operatorOptions.conditionalNodeType&&operatorOptions.testNodePropertyNames.some(prop=>parent[prop]===node);let forceNoIndent=parent.type===operatorOptions.conditionalNodeType&&!isParentTest;// Find the outermost non-ConditionalExpression parent, and the outermost\n// ConditionalExpression parent. We'll use these to determine if we should\n// print in JSX mode.\nlet currentParent;let previousParent;let i=0;do{previousParent=currentParent||node;currentParent=path.getParentNode(i);i++;}while(currentParent&&currentParent.type===operatorOptions.conditionalNodeType&&operatorOptions.testNodePropertyNames.every(prop=>currentParent[prop]!==previousParent));const firstNonConditionalParent=currentParent||parent;const lastConditionalParent=previousParent;if(operatorOptions.shouldCheckJsx&&(isJSXNode$1(node[operatorOptions.testNodePropertyNames[0]])||isJSXNode$1(consequentNode)||isJSXNode$1(alternateNode)||conditionalExpressionChainContainsJSX$1(lastConditionalParent))){jsxMode=true;forceNoIndent=true;// Even though they don't need parens, we wrap (almost) everything in\n// parens when using ?: within JSX, because the parens are analogous to\n// curly braces in an if statement.\nconst wrap=doc=>concat$d([ifBreak$6(\"(\",\"\"),indent$7(concat$d([softline$6,doc])),softline$6,ifBreak$6(\")\",\"\")]);// The only things we don't wrap are:\n// * Nested conditional expressions in alternates\n// * null\n// * undefined\nconst isNil=node=>node.type===\"NullLiteral\"||node.type===\"Literal\"&&node.value===null||node.type===\"Identifier\"&&node.name===\"undefined\";parts.push(\" ? \",isNil(consequentNode)?path.call(print,operatorOptions.consequentNodePropertyName):wrap(path.call(print,operatorOptions.consequentNodePropertyName)),\" : \",alternateNode.type===operatorOptions.conditionalNodeType||isNil(alternateNode)?path.call(print,operatorOptions.alternateNodePropertyName):wrap(path.call(print,operatorOptions.alternateNodePropertyName)));}else{// normal mode\nconst part=concat$d([line$9,\"? \",consequentNode.type===operatorOptions.conditionalNodeType?ifBreak$6(\"\",\"(\"):\"\",align$1(2,path.call(print,operatorOptions.consequentNodePropertyName)),consequentNode.type===operatorOptions.conditionalNodeType?ifBreak$6(\"\",\")\"):\"\",line$9,\": \",alternateNode.type===operatorOptions.conditionalNodeType?path.call(print,operatorOptions.alternateNodePropertyName):align$1(2,path.call(print,operatorOptions.alternateNodePropertyName))]);parts.push(parent.type!==operatorOptions.conditionalNodeType||parent[operatorOptions.alternateNodePropertyName]===node||isParentTest?part:options.useTabs?dedent$2(indent$7(part)):align$1(Math.max(0,options.tabWidth-2),part));}// We want a whole chain of ConditionalExpressions to all\n// break if any of them break. That means we should only group around the\n// outer-most ConditionalExpression.\nconst maybeGroup=doc=>parent===firstNonConditionalParent?group$b(doc):doc;// Break the closing paren to keep the chain right after it:\n// (a\n//   ? b\n//   : c\n// ).call()\nconst breakClosingParen=!jsxMode&&(parent.type===\"MemberExpression\"||parent.type===\"OptionalMemberExpression\"||parent.type===\"NGPipeExpression\"&&parent.left===node)&&!parent.computed;const result=maybeGroup(concat$d([].concat((testDoc=>/**\n     *     a\n     *       ? b\n     *       : multiline\n     *         test\n     *         node\n     *       ^^ align(2)\n     *       ? d\n     *       : e\n     */parent.type===operatorOptions.conditionalNodeType&&parent[operatorOptions.alternateNodePropertyName]===node?align$1(2,testDoc):testDoc)(concat$d(operatorOptions.beforeParts())),forceNoIndent?concat$d(parts):indent$7(concat$d(parts)),operatorOptions.afterParts(breakClosingParen))));return isParentTest?group$b(concat$d([indent$7(concat$d([softline$6,result])),softline$6])):result;}function printPathNoParens(path,options,print,args){const n=path.getValue();const semi=options.semi?\";\":\"\";if(!n){return\"\";}if(typeof n===\"string\"){return n;}const htmlBinding=printHtmlBinding$1(path,options,print);if(htmlBinding){return htmlBinding;}let parts=[];switch(n.type){case\"JsExpressionRoot\":return path.call(print,\"node\");case\"JsonRoot\":return concat$d([path.call(print,\"node\"),hardline$9]);case\"File\":// Print @babel/parser's InterpreterDirective here so that\n// leading comments on the `Program` node get printed after the hashbang.\nif(n.program&&n.program.interpreter){parts.push(path.call(programPath=>programPath.call(print,\"interpreter\"),\"program\"));}parts.push(path.call(print,\"program\"));return concat$d(parts);case\"Program\":// Babel 6\nif(n.directives){path.each(childPath=>{parts.push(print(childPath),semi,hardline$9);if(isNextLineEmpty$4(options.originalText,childPath.getValue(),options.locEnd)){parts.push(hardline$9);}},\"directives\");}parts.push(path.call(bodyPath=>{return printStatementSequence(bodyPath,options,print);},\"body\"));parts.push(comments.printDanglingComments(path,options,/* sameIndent */true));// Only force a trailing newline if there were any contents.\nif(!n.body.every(_ref16=>{let{type}=_ref16;return type===\"EmptyStatement\";})||n.comments){parts.push(hardline$9);}return concat$d(parts);// Babel extension.\ncase\"EmptyStatement\":return\"\";case\"ExpressionStatement\":// Detect Flow-parsed directives\nif(n.directive){return concat$d([nodeStr(n.expression,options,true),semi]);}if(options.parser===\"__vue_event_binding\"){const parent=path.getParentNode();if(parent.type===\"Program\"&&parent.body.length===1&&parent.body[0]===n){return concat$d([path.call(print,\"expression\"),isVueEventBindingExpression$3(n.expression)?\";\":\"\"]);}}// Do not append semicolon after the only JSX element in a program\nreturn concat$d([path.call(print,\"expression\"),isTheOnlyJSXElementInMarkdown$1(options,path)?\"\":semi]);// Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\ncase\"ParenthesizedExpression\":{const shouldHug=!n.expression.comments;if(shouldHug){return concat$d([\"(\",path.call(print,\"expression\"),\")\"]);}return group$b(concat$d([\"(\",indent$7(concat$d([softline$6,path.call(print,\"expression\")])),softline$6,\")\"]));}case\"AssignmentExpression\":return printAssignment(n.left,path.call(print,\"left\"),concat$d([\" \",n.operator]),n.right,path.call(print,\"right\"),options);case\"BinaryExpression\":case\"LogicalExpression\":case\"NGPipeExpression\":{const parent=path.getParentNode();const parentParent=path.getParentNode(1);const isInsideParenthesis=n!==parent.body&&(parent.type===\"IfStatement\"||parent.type===\"WhileStatement\"||parent.type===\"SwitchStatement\"||parent.type===\"DoWhileStatement\");const parts=printBinaryishExpressions(path,print,options,/* isNested */false,isInsideParenthesis);//   if (\n//     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n//   ) {\n//\n// looks super weird, we want to break the children if the parent breaks\n//\n//   if (\n//     this.hasPlugin(\"dynamicImports\") &&\n//     this.lookahead().type === tt.parenLeft\n//   ) {\nif(isInsideParenthesis){return concat$d(parts);}// Break between the parens in\n// unaries or in a member or specific call expression, i.e.\n//\n//   (\n//     a &&\n//     b &&\n//     c\n//   ).call()\nif((parent.type===\"CallExpression\"||parent.type===\"OptionalCallExpression\")&&parent.callee===n||parent.type===\"UnaryExpression\"||(parent.type===\"MemberExpression\"||parent.type===\"OptionalMemberExpression\")&&!parent.computed){return group$b(concat$d([indent$7(concat$d([softline$6,concat$d(parts)])),softline$6]));}// Avoid indenting sub-expressions in some cases where the first sub-expression is already\n// indented accordingly. We should indent sub-expressions where the first case isn't indented.\nconst shouldNotIndent=parent.type===\"ReturnStatement\"||parent.type===\"ThrowStatement\"||parent.type===\"JSXExpressionContainer\"&&parentParent.type===\"JSXAttribute\"||n.operator!==\"|\"&&parent.type===\"JsExpressionRoot\"||n.type!==\"NGPipeExpression\"&&(parent.type===\"NGRoot\"&&options.parser===\"__ng_binding\"||parent.type===\"NGMicrosyntaxExpression\"&&parentParent.type===\"NGMicrosyntax\"&&parentParent.body.length===1)||n===parent.body&&parent.type===\"ArrowFunctionExpression\"||n!==parent.body&&parent.type===\"ForStatement\"||parent.type===\"ConditionalExpression\"&&parentParent.type!==\"ReturnStatement\"&&parentParent.type!==\"ThrowStatement\"&&parentParent.type!==\"CallExpression\"&&parentParent.type!==\"OptionalCallExpression\"||parent.type===\"TemplateLiteral\";const shouldIndentIfInlining=parent.type===\"AssignmentExpression\"||parent.type===\"VariableDeclarator\"||parent.type===\"ClassProperty\"||parent.type===\"TSAbstractClassProperty\"||parent.type===\"ClassPrivateProperty\"||parent.type===\"ObjectProperty\"||parent.type===\"Property\";const samePrecedenceSubExpression=isBinaryish$1(n.left)&&shouldFlatten$1(n.operator,n.left.operator);if(shouldNotIndent||shouldInlineLogicalExpression(n)&&!samePrecedenceSubExpression||!shouldInlineLogicalExpression(n)&&shouldIndentIfInlining){return group$b(concat$d(parts));}if(parts.length===0){return\"\";}// If the right part is a JSX node, we include it in a separate group to\n// prevent it breaking the whole chain, so we can print the expression like:\n//\n//   foo && bar && (\n//     <Foo>\n//       <Bar />\n//     </Foo>\n//   )\nconst hasJSX=isJSXNode$1(n.right);const rest=concat$d(hasJSX?parts.slice(1,-1):parts.slice(1));const groupId=Symbol(\"logicalChain-\"+ ++uid);const chain=group$b(concat$d([// Don't include the initial expression in the indentation\n// level. The first item is guaranteed to be the first\n// left-most expression.\nparts.length>0?parts[0]:\"\",indent$7(rest)]),{id:groupId});if(!hasJSX){return chain;}const jsxPart=getLast$3(parts);return group$b(concat$d([chain,ifBreak$6(indent$7(jsxPart),jsxPart,{groupId})]));}case\"AssignmentPattern\":return concat$d([path.call(print,\"left\"),\" = \",path.call(print,\"right\")]);case\"TSTypeAssertion\":{const shouldBreakAfterCast=!(n.expression.type===\"ArrayExpression\"||n.expression.type===\"ObjectExpression\");const castGroup=group$b(concat$d([\"<\",indent$7(concat$d([softline$6,path.call(print,\"typeAnnotation\")])),softline$6,\">\"]));const exprContents=concat$d([ifBreak$6(\"(\"),indent$7(concat$d([softline$6,path.call(print,\"expression\")])),softline$6,ifBreak$6(\")\")]);if(shouldBreakAfterCast){return conditionalGroup$1([concat$d([castGroup,path.call(print,\"expression\")]),concat$d([castGroup,group$b(exprContents,{shouldBreak:true})]),concat$d([castGroup,path.call(print,\"expression\")])]);}return group$b(concat$d([castGroup,path.call(print,\"expression\")]));}case\"OptionalMemberExpression\":case\"MemberExpression\":{const parent=path.getParentNode();let firstNonMemberParent;let i=0;do{firstNonMemberParent=path.getParentNode(i);i++;}while(firstNonMemberParent&&(firstNonMemberParent.type===\"MemberExpression\"||firstNonMemberParent.type===\"OptionalMemberExpression\"||firstNonMemberParent.type===\"TSNonNullExpression\"));const shouldInline=firstNonMemberParent&&(firstNonMemberParent.type===\"NewExpression\"||firstNonMemberParent.type===\"BindExpression\"||firstNonMemberParent.type===\"VariableDeclarator\"&&firstNonMemberParent.id.type!==\"Identifier\"||firstNonMemberParent.type===\"AssignmentExpression\"&&firstNonMemberParent.left.type!==\"Identifier\")||n.computed||n.object.type===\"Identifier\"&&n.property.type===\"Identifier\"&&parent.type!==\"MemberExpression\"&&parent.type!==\"OptionalMemberExpression\";return concat$d([path.call(print,\"object\"),shouldInline?printMemberLookup(path,options,print):group$b(indent$7(concat$d([softline$6,printMemberLookup(path,options,print)])))]);}case\"MetaProperty\":return concat$d([path.call(print,\"meta\"),\".\",path.call(print,\"property\")]);case\"BindExpression\":if(n.object){parts.push(path.call(print,\"object\"));}parts.push(group$b(indent$7(concat$d([softline$6,printBindExpressionCallee(path,options,print)]))));return concat$d(parts);case\"Identifier\":{return concat$d([n.name,printOptionalToken(path),printTypeAnnotation(path,options,print)]);}case\"V8IntrinsicIdentifier\":return concat$d([\"%\",n.name]);case\"SpreadElement\":case\"SpreadElementPattern\":case\"SpreadProperty\":case\"SpreadPropertyPattern\":case\"RestElement\":case\"ObjectTypeSpreadProperty\":return concat$d([\"...\",path.call(print,\"argument\"),printTypeAnnotation(path,options,print)]);case\"FunctionDeclaration\":case\"FunctionExpression\":parts.push(printFunctionDeclaration(path,print,options));if(!n.body){parts.push(semi);}return concat$d(parts);case\"ArrowFunctionExpression\":{if(n.async){parts.push(\"async \");}if(shouldPrintParamsWithoutParens(path,options)){parts.push(path.call(print,\"params\",0));}else{parts.push(group$b(concat$d([printFunctionParams(path,print,options,/* expandLast */args&&(args.expandLastArg||args.expandFirstArg),/* printTypeParams */true),printReturnType(path,print,options)])));}const dangling=comments.printDanglingComments(path,options,/* sameIndent */true,comment=>{const nextCharacter=getNextNonSpaceNonCommentCharacterIndex$3(options.originalText,comment,options.locEnd);return options.originalText.slice(nextCharacter,nextCharacter+2)===\"=>\";});if(dangling){parts.push(\" \",dangling);}parts.push(\" =>\");const body=path.call(bodyPath=>print(bodyPath,args),\"body\");// We want to always keep these types of nodes on the same line\n// as the arrow.\nif(!hasLeadingOwnLineComment$1(options.originalText,n.body,options)&&(n.body.type===\"ArrayExpression\"||n.body.type===\"ObjectExpression\"||n.body.type===\"BlockStatement\"||isJSXNode$1(n.body)||isTemplateOnItsOwnLine$1(n.body,options.originalText,options)||n.body.type===\"ArrowFunctionExpression\"||n.body.type===\"DoExpression\")){return group$b(concat$d([concat$d(parts),\" \",body]));}// We handle sequence expressions as the body of arrows specially,\n// so that the required parentheses end up on their own lines.\nif(n.body.type===\"SequenceExpression\"){return group$b(concat$d([concat$d(parts),group$b(concat$d([\" (\",indent$7(concat$d([softline$6,body])),softline$6,\")\"]))]));}// if the arrow function is expanded as last argument, we are adding a\n// level of indentation and need to add a softline to align the closing )\n// with the opening (, or if it's inside a JSXExpression (e.g. an attribute)\n// we should align the expression's closing } with the line with the opening {.\nconst shouldAddSoftLine=(args&&args.expandLastArg||path.getParentNode().type===\"JSXExpressionContainer\")&&!(n.comments&&n.comments.length);const printTrailingComma=args&&args.expandLastArg&&shouldPrintComma$1(options,\"all\");// In order to avoid confusion between\n// a => a ? a : a\n// a <= a ? a : a\nconst shouldAddParens=n.body.type===\"ConditionalExpression\"&&!startsWithNoLookaheadToken$1(n.body,/* forbidFunctionAndClass */false);return group$b(concat$d([concat$d(parts),group$b(concat$d([indent$7(concat$d([line$9,shouldAddParens?ifBreak$6(\"\",\"(\"):\"\",body,shouldAddParens?ifBreak$6(\"\",\")\"):\"\"])),shouldAddSoftLine?concat$d([ifBreak$6(printTrailingComma?\",\":\"\"),softline$6]):\"\"]))]));}case\"YieldExpression\":parts.push(\"yield\");if(n.delegate){parts.push(\"*\");}if(n.argument){parts.push(\" \",path.call(print,\"argument\"));}return concat$d(parts);case\"AwaitExpression\":{parts.push(\"await \",path.call(print,\"argument\"));const parent=path.getParentNode();if((parent.type===\"CallExpression\"||parent.type===\"OptionalCallExpression\")&&parent.callee===n||(parent.type===\"MemberExpression\"||parent.type===\"OptionalMemberExpression\")&&parent.object===n){return group$b(concat$d([indent$7(concat$d([softline$6,concat$d(parts)])),softline$6]));}return concat$d(parts);}case\"ImportSpecifier\":if(n.importKind){parts.push(path.call(print,\"importKind\"),\" \");}parts.push(path.call(print,\"imported\"));if(n.local&&n.local.name!==n.imported.name){parts.push(\" as \",path.call(print,\"local\"));}return concat$d(parts);case\"ExportSpecifier\":parts.push(path.call(print,\"local\"));if(n.exported&&n.exported.name!==n.local.name){parts.push(\" as \",path.call(print,\"exported\"));}return concat$d(parts);case\"ImportNamespaceSpecifier\":parts.push(\"* as \");parts.push(path.call(print,\"local\"));return concat$d(parts);case\"ImportDefaultSpecifier\":return path.call(print,\"local\");case\"TSExportAssignment\":return concat$d([\"export = \",path.call(print,\"expression\"),semi]);case\"ExportDefaultDeclaration\":case\"ExportNamedDeclaration\":return printExportDeclaration(path,options,print);case\"ExportAllDeclaration\":parts.push(\"export \");if(n.exportKind===\"type\"){parts.push(\"type \");}parts.push(\"* \");if(n.exported){parts.push(\"as \",path.call(print,\"exported\"),\" \");}parts.push(\"from \",path.call(print,\"source\"),semi);return concat$d(parts);case\"ExportNamespaceSpecifier\":case\"ExportDefaultSpecifier\":return path.call(print,\"exported\");case\"ImportDeclaration\":{parts.push(\"import \");if(n.importKind&&n.importKind!==\"value\"){parts.push(n.importKind+\" \");}const standalones=[];const grouped=[];if(n.specifiers&&n.specifiers.length>0){path.each(specifierPath=>{const value=specifierPath.getValue();if(value.type===\"ImportDefaultSpecifier\"||value.type===\"ImportNamespaceSpecifier\"){standalones.push(print(specifierPath));}else{grouped.push(print(specifierPath));}},\"specifiers\");if(standalones.length>0){parts.push(join$9(\", \",standalones));}if(standalones.length>0&&grouped.length>0){parts.push(\", \");}if(grouped.length===1&&standalones.length===0&&n.specifiers&&!n.specifiers.some(node=>node.comments)){parts.push(concat$d([\"{\",options.bracketSpacing?\" \":\"\",concat$d(grouped),options.bracketSpacing?\" \":\"\",\"}\"]));}else if(grouped.length>=1){parts.push(group$b(concat$d([\"{\",indent$7(concat$d([options.bracketSpacing?line$9:softline$6,join$9(concat$d([\",\",line$9]),grouped)])),ifBreak$6(shouldPrintComma$1(options)?\",\":\"\"),options.bracketSpacing?line$9:softline$6,\"}\"])));}parts.push(\" from \");}else if(n.importKind&&n.importKind===\"type\"||// import {} from 'x'\n/{\\s*}/.test(options.originalText.slice(options.locStart(n),options.locStart(n.source)))){parts.push(\"{} from \");}parts.push(path.call(print,\"source\"),semi);return concat$d(parts);}case\"Import\":return\"import\";case\"TSModuleBlock\":case\"BlockStatement\":{const naked=path.call(bodyPath=>{return printStatementSequence(bodyPath,options,print);},\"body\");const hasContent=n.body.find(node=>node.type!==\"EmptyStatement\");const hasDirectives=n.directives&&n.directives.length>0;const parent=path.getParentNode();const parentParent=path.getParentNode(1);if(!hasContent&&!hasDirectives&&!hasDanglingComments$1(n)&&(parent.type===\"ArrowFunctionExpression\"||parent.type===\"FunctionExpression\"||parent.type===\"FunctionDeclaration\"||parent.type===\"ObjectMethod\"||parent.type===\"ClassMethod\"||parent.type===\"ClassPrivateMethod\"||parent.type===\"ForStatement\"||parent.type===\"WhileStatement\"||parent.type===\"DoWhileStatement\"||parent.type===\"DoExpression\"||parent.type===\"CatchClause\"&&!parentParent.finalizer||parent.type===\"TSModuleDeclaration\")){return\"{}\";}parts.push(\"{\");// Babel 6\nif(hasDirectives){path.each(childPath=>{parts.push(indent$7(concat$d([hardline$9,print(childPath),semi])));if(isNextLineEmpty$4(options.originalText,childPath.getValue(),options.locEnd)){parts.push(hardline$9);}},\"directives\");}if(hasContent){parts.push(indent$7(concat$d([hardline$9,naked])));}parts.push(comments.printDanglingComments(path,options));parts.push(hardline$9,\"}\");return concat$d(parts);}case\"ReturnStatement\":return concat$d([\"return\",printReturnAndThrowArgument(path,options,print)]);case\"NewExpression\":case\"OptionalCallExpression\":case\"CallExpression\":{const isNew=n.type===\"NewExpression\";const optional=printOptionalToken(path);if(// We want to keep CommonJS- and AMD-style require calls, and AMD-style\n// define calls, as a unit.\n// e.g. `define([\"some/lib\", (lib) => {`\n!isNew&&n.callee.type===\"Identifier\"&&(n.callee.name===\"require\"||n.callee.name===\"define\")||// Template literals as single arguments\nn.arguments.length===1&&isTemplateOnItsOwnLine$1(n.arguments[0],options.originalText,options)||// Keep test declarations on a single line\n// e.g. `it('long name', () => {`\n!isNew&&isTestCall$1(n,path.getParentNode())){return concat$d([isNew?\"new \":\"\",path.call(print,\"callee\"),optional,printFunctionTypeParameters(path,options,print),concat$d([\"(\",join$9(\", \",path.map(print,\"arguments\")),\")\"])]);}// Inline Flow annotation comments following Identifiers in Call nodes need to\n// stay with the Identifier. For example:\n//\n// foo /*:: <SomeGeneric> */(bar);\n//\n// Here, we ensure that such comments stay between the Identifier and the Callee.\nconst isIdentifierWithFlowAnnotation=n.callee.type===\"Identifier\"&&hasFlowAnnotationComment$1(n.callee.trailingComments);if(isIdentifierWithFlowAnnotation){n.callee.trailingComments[0].printed=true;}// We detect calls on member lookups and possibly print them in a\n// special chain format. See `printMemberChain` for more info.\nif(!isNew&&isMemberish$1(n.callee)&&!path.call(path=>needsParens_1(path,options),\"callee\")){return printMemberChain(path,options,print);}const contents=concat$d([isNew?\"new \":\"\",path.call(print,\"callee\"),optional,isIdentifierWithFlowAnnotation?\"/*:: \".concat(n.callee.trailingComments[0].value.slice(2).trim(),\" */\"):\"\",printFunctionTypeParameters(path,options,print),printArgumentsList(path,options,print)]);// We group here when the callee is itself a call expression.\n// See `isLongCurriedCallExpression` for more info.\nif(isCallOrOptionalCallExpression$1(n.callee)){return group$b(contents);}return contents;}case\"TSInterfaceDeclaration\":if(n.declare){parts.push(\"declare \");}parts.push(n.abstract?\"abstract \":\"\",printTypeScriptModifiers(path,options,print),\"interface \",path.call(print,\"id\"),n.typeParameters?path.call(print,\"typeParameters\"):\"\",\" \");if(n.extends&&n.extends.length){parts.push(group$b(indent$7(concat$d([softline$6,\"extends \",(n.extends.length===1?identity$2:indent$7)(join$9(concat$d([\",\",line$9]),path.map(print,\"extends\"))),\" \"]))));}parts.push(path.call(print,\"body\"));return concat$d(parts);case\"ObjectTypeInternalSlot\":return concat$d([n.static?\"static \":\"\",\"[[\",path.call(print,\"id\"),\"]]\",printOptionalToken(path),n.method?\"\":\": \",path.call(print,\"value\")]);case\"ObjectExpression\":case\"ObjectPattern\":case\"ObjectTypeAnnotation\":case\"TSInterfaceBody\":case\"TSTypeLiteral\":{let propertiesField;if(n.type===\"TSTypeLiteral\"){propertiesField=\"members\";}else if(n.type===\"TSInterfaceBody\"){propertiesField=\"body\";}else{propertiesField=\"properties\";}const isTypeAnnotation=n.type===\"ObjectTypeAnnotation\";const fields=[];if(isTypeAnnotation){fields.push(\"indexers\",\"callProperties\",\"internalSlots\");}fields.push(propertiesField);const firstProperty=fields.map(field=>n[field][0]).sort((a,b)=>options.locStart(a)-options.locStart(b))[0];const parent=path.getParentNode(0);const isFlowInterfaceLikeBody=isTypeAnnotation&&parent&&(parent.type===\"InterfaceDeclaration\"||parent.type===\"DeclareInterface\"||parent.type===\"DeclareClass\")&&path.getName()===\"body\";const shouldBreak=n.type===\"TSInterfaceBody\"||isFlowInterfaceLikeBody||n.type===\"ObjectPattern\"&&parent.type!==\"FunctionDeclaration\"&&parent.type!==\"FunctionExpression\"&&parent.type!==\"ArrowFunctionExpression\"&&parent.type!==\"ObjectMethod\"&&parent.type!==\"ClassMethod\"&&parent.type!==\"ClassPrivateMethod\"&&parent.type!==\"AssignmentPattern\"&&parent.type!==\"CatchClause\"&&n.properties.some(property=>property.value&&(property.value.type===\"ObjectPattern\"||property.value.type===\"ArrayPattern\"))||n.type!==\"ObjectPattern\"&&firstProperty&&hasNewlineInRange$3(options.originalText,options.locStart(n),options.locStart(firstProperty));const separator=isFlowInterfaceLikeBody?\";\":n.type===\"TSInterfaceBody\"||n.type===\"TSTypeLiteral\"?ifBreak$6(semi,\";\"):\",\";const leftBrace=n.exact?\"{|\":\"{\";const rightBrace=n.exact?\"|}\":\"}\";// Unfortunately, things are grouped together in the ast can be\n// interleaved in the source code. So we need to reorder them before\n// printing them.\nconst propsAndLoc=[];fields.forEach(field=>{path.each(childPath=>{const node=childPath.getValue();propsAndLoc.push({node,printed:print(childPath),loc:options.locStart(node)});},field);});let separatorParts=[];const props=propsAndLoc.sort((a,b)=>a.loc-b.loc).map(prop=>{const result=concat$d(separatorParts.concat(group$b(prop.printed)));separatorParts=[separator,line$9];if((prop.node.type===\"TSPropertySignature\"||prop.node.type===\"TSMethodSignature\"||prop.node.type===\"TSConstructSignatureDeclaration\")&&hasNodeIgnoreComment$2(prop.node)){separatorParts.shift();}if(isNextLineEmpty$4(options.originalText,prop.node,options.locEnd)){separatorParts.push(hardline$9);}return result;});if(n.inexact){let printed;if(hasDanglingComments$1(n)){const hasLineComments=!n.comments.every(comments$1.isBlockComment);const printedDanglingComments=comments.printDanglingComments(path,options,/* sameIndent */true);printed=concat$d([printedDanglingComments,hasLineComments||hasNewline$5(options.originalText,options.locEnd(n.comments[n.comments.length-1]))?hardline$9:line$9,\"...\"]);}else{printed=\"...\";}props.push(concat$d(separatorParts.concat(printed)));}const lastElem=getLast$3(n[propertiesField]);const canHaveTrailingSeparator=!(n.inexact||lastElem&&(lastElem.type===\"RestElement\"||hasNodeIgnoreComment$2(lastElem)));let content;if(props.length===0){if(!hasDanglingComments$1(n)){return concat$d([leftBrace,rightBrace,printTypeAnnotation(path,options,print)]);}content=group$b(concat$d([leftBrace,comments.printDanglingComments(path,options),softline$6,rightBrace,printOptionalToken(path),printTypeAnnotation(path,options,print)]));}else{content=concat$d([leftBrace,indent$7(concat$d([options.bracketSpacing?line$9:softline$6,concat$d(props)])),ifBreak$6(canHaveTrailingSeparator&&(separator!==\",\"||shouldPrintComma$1(options))?separator:\"\"),concat$d([options.bracketSpacing?line$9:softline$6,rightBrace]),printOptionalToken(path),printTypeAnnotation(path,options,print)]);}// If we inline the object as first argument of the parent, we don't want\n// to create another group so that the object breaks before the return\n// type\nif(path.match(node=>node.type===\"ObjectPattern\"&&!node.decorators,(node,name,number)=>shouldHugArguments(node)&&(name===\"params\"||name===\"parameters\")&&number===0)||path.match(shouldHugType,(node,name)=>name===\"typeAnnotation\",(node,name)=>name===\"typeAnnotation\",(node,name,number)=>shouldHugArguments(node)&&(name===\"params\"||name===\"parameters\")&&number===0)){return content;}return group$b(content,{shouldBreak});}// Babel 6\ncase\"ObjectProperty\":// Non-standard AST node type.\ncase\"Property\":if(n.method||n.kind===\"get\"||n.kind===\"set\"){return printMethod(path,options,print);}if(n.shorthand){parts.push(path.call(print,\"value\"));}else{parts.push(printAssignment(n.key,printPropertyKey(path,options,print),\":\",n.value,path.call(print,\"value\"),options));}return concat$d(parts);// Babel 6\ncase\"ClassMethod\":case\"ClassPrivateMethod\":case\"MethodDefinition\":case\"TSAbstractMethodDefinition\":case\"TSDeclareMethod\":if(n.decorators&&n.decorators.length!==0){parts.push(printDecorators(path,options,print));}if(n.accessibility){parts.push(n.accessibility+\" \");}if(n.static){parts.push(\"static \");}if(n.type===\"TSAbstractMethodDefinition\"||n.abstract){parts.push(\"abstract \");}parts.push(printMethod(path,options,print));return concat$d(parts);case\"ObjectMethod\":return printMethod(path,options,print);case\"Decorator\":return concat$d([\"@\",path.call(print,\"expression\"),path.call(print,\"callee\")]);case\"ArrayExpression\":case\"ArrayPattern\":if(n.elements.length===0){if(!hasDanglingComments$1(n)){parts.push(\"[]\");}else{parts.push(group$b(concat$d([\"[\",comments.printDanglingComments(path,options),softline$6,\"]\"])));}}else{const lastElem=getLast$3(n.elements);const canHaveTrailingComma=!(lastElem&&lastElem.type===\"RestElement\");// JavaScript allows you to have empty elements in an array which\n// changes its length based on the number of commas. The algorithm\n// is that if the last argument is null, we need to force insert\n// a comma to ensure JavaScript recognizes it.\n//   [,].length === 1\n//   [1,].length === 1\n//   [1,,].length === 2\n//\n// Note that getLast returns null if the array is empty, but\n// we already check for an empty array just above so we are safe\nconst needsForcedTrailingComma=canHaveTrailingComma&&lastElem===null;const shouldBreak=n.elements.length>1&&n.elements.every((element,i,elements)=>{const elementType=element&&element.type;if(elementType!==\"ArrayExpression\"&&elementType!==\"ObjectExpression\"){return false;}const nextElement=elements[i+1];if(nextElement&&elementType!==nextElement.type){return false;}const itemsKey=elementType===\"ArrayExpression\"?\"elements\":\"properties\";return element[itemsKey]&&element[itemsKey].length>1;});parts.push(group$b(concat$d([\"[\",indent$7(concat$d([softline$6,printArrayItems(path,options,\"elements\",print)])),needsForcedTrailingComma?\",\":\"\",ifBreak$6(canHaveTrailingComma&&!needsForcedTrailingComma&&shouldPrintComma$1(options)?\",\":\"\"),comments.printDanglingComments(path,options,/* sameIndent */true),softline$6,\"]\"]),{shouldBreak}));}parts.push(printOptionalToken(path),printTypeAnnotation(path,options,print));return concat$d(parts);case\"SequenceExpression\":{const parent=path.getParentNode(0);if(parent.type===\"ExpressionStatement\"||parent.type===\"ForStatement\"){// For ExpressionStatements and for-loop heads, which are among\n// the few places a SequenceExpression appears unparenthesized, we want\n// to indent expressions after the first.\nconst parts=[];path.each(p=>{if(p.getName()===0){parts.push(print(p));}else{parts.push(\",\",indent$7(concat$d([line$9,print(p)])));}},\"expressions\");return group$b(concat$d(parts));}return group$b(concat$d([join$9(concat$d([\",\",line$9]),path.map(print,\"expressions\"))]));}case\"ThisExpression\":return\"this\";case\"Super\":return\"super\";case\"NullLiteral\":// Babel 6 Literal split\nreturn\"null\";case\"RegExpLiteral\":// Babel 6 Literal split\nreturn printRegex(n);case\"NumericLiteral\":// Babel 6 Literal split\nreturn printNumber$2(n.extra.raw);case\"BigIntLiteral\":// babel: n.extra.raw, typescript: n.raw, flow: n.bigint\nreturn(n.bigint||(n.extra?n.extra.raw:n.raw)).toLowerCase();case\"BooleanLiteral\":// Babel 6 Literal split\ncase\"StringLiteral\":// Babel 6 Literal split\ncase\"Literal\":{if(n.regex){return printRegex(n.regex);}if(typeof n.value===\"number\"){return printNumber$2(n.raw);}if(typeof n.value!==\"string\"){return\"\"+n.value;}// TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2\n// See corresponding workaround in needs-parens.js\nconst grandParent=path.getParentNode(1);const isTypeScriptDirective=options.parser===\"typescript\"&&typeof n.value===\"string\"&&grandParent&&(grandParent.type===\"Program\"||grandParent.type===\"BlockStatement\");return nodeStr(n,options,isTypeScriptDirective);}case\"Directive\":return path.call(print,\"value\");// Babel 6\ncase\"DirectiveLiteral\":return nodeStr(n,options);case\"UnaryExpression\":parts.push(n.operator);if(/[a-z]$/.test(n.operator)){parts.push(\" \");}if(n.argument.comments&&n.argument.comments.length>0){parts.push(group$b(concat$d([\"(\",indent$7(concat$d([softline$6,path.call(print,\"argument\")])),softline$6,\")\"])));}else{parts.push(path.call(print,\"argument\"));}return concat$d(parts);case\"UpdateExpression\":parts.push(path.call(print,\"argument\"),n.operator);if(n.prefix){parts.reverse();}return concat$d(parts);case\"ConditionalExpression\":return printTernaryOperator(path,options,print,{beforeParts:()=>[path.call(print,\"test\")],afterParts:breakClosingParen=>[breakClosingParen?softline$6:\"\"],shouldCheckJsx:true,conditionalNodeType:\"ConditionalExpression\",consequentNodePropertyName:\"consequent\",alternateNodePropertyName:\"alternate\",testNodePropertyNames:[\"test\"]});case\"VariableDeclaration\":{const printed=path.map(childPath=>{return print(childPath);},\"declarations\");// We generally want to terminate all variable declarations with a\n// semicolon, except when they in the () part of for loops.\nconst parentNode=path.getParentNode();const isParentForLoop=parentNode.type===\"ForStatement\"||parentNode.type===\"ForInStatement\"||parentNode.type===\"ForOfStatement\";const hasValue=n.declarations.some(decl=>decl.init);let firstVariable;if(printed.length===1&&!n.declarations[0].comments){firstVariable=printed[0];}else if(printed.length>0){// Indent first var to comply with eslint one-var rule\nfirstVariable=indent$7(printed[0]);}parts=[n.declare?\"declare \":\"\",n.kind,firstVariable?concat$d([\" \",firstVariable]):\"\",indent$7(concat$d(printed.slice(1).map(p=>concat$d([\",\",hasValue&&!isParentForLoop?hardline$9:line$9,p]))))];if(!(isParentForLoop&&parentNode.body!==n)){parts.push(semi);}return group$b(concat$d(parts));}case\"TSTypeAliasDeclaration\":{if(n.declare){parts.push(\"declare \");}const printed=printAssignmentRight(n.id,n.typeAnnotation,n.typeAnnotation&&path.call(print,\"typeAnnotation\"),options);parts.push(\"type \",path.call(print,\"id\"),path.call(print,\"typeParameters\"),\" =\",printed,semi);return group$b(concat$d(parts));}case\"VariableDeclarator\":return printAssignment(n.id,path.call(print,\"id\"),\" =\",n.init,n.init&&path.call(print,\"init\"),options);case\"WithStatement\":return group$b(concat$d([\"with (\",path.call(print,\"object\"),\")\",adjustClause(n.body,path.call(print,\"body\"))]));case\"IfStatement\":{const con=adjustClause(n.consequent,path.call(print,\"consequent\"));const opening=group$b(concat$d([\"if (\",group$b(concat$d([indent$7(concat$d([softline$6,path.call(print,\"test\")])),softline$6])),\")\",con]));parts.push(opening);if(n.alternate){const commentOnOwnLine=hasTrailingComment$1(n.consequent)&&n.consequent.comments.some(comment=>comment.trailing&&!comments$1.isBlockComment(comment))||needsHardlineAfterDanglingComment$1(n);const elseOnSameLine=n.consequent.type===\"BlockStatement\"&&!commentOnOwnLine;parts.push(elseOnSameLine?\" \":hardline$9);if(hasDanglingComments$1(n)){parts.push(comments.printDanglingComments(path,options,true),commentOnOwnLine?hardline$9:\" \");}parts.push(\"else\",group$b(adjustClause(n.alternate,path.call(print,\"alternate\"),n.alternate.type===\"IfStatement\")));}return concat$d(parts);}case\"ForStatement\":{const body=adjustClause(n.body,path.call(print,\"body\"));// We want to keep dangling comments above the loop to stay consistent.\n// Any comment positioned between the for statement and the parentheses\n// is going to be printed before the statement.\nconst dangling=comments.printDanglingComments(path,options,/* sameLine */true);const printedComments=dangling?concat$d([dangling,softline$6]):\"\";if(!n.init&&!n.test&&!n.update){return concat$d([printedComments,group$b(concat$d([\"for (;;)\",body]))]);}return concat$d([printedComments,group$b(concat$d([\"for (\",group$b(concat$d([indent$7(concat$d([softline$6,path.call(print,\"init\"),\";\",line$9,path.call(print,\"test\"),\";\",line$9,path.call(print,\"update\")])),softline$6])),\")\",body]))]);}case\"WhileStatement\":return group$b(concat$d([\"while (\",group$b(concat$d([indent$7(concat$d([softline$6,path.call(print,\"test\")])),softline$6])),\")\",adjustClause(n.body,path.call(print,\"body\"))]));case\"ForInStatement\":// Note: esprima can't actually parse \"for each (\".\nreturn group$b(concat$d([n.each?\"for each (\":\"for (\",path.call(print,\"left\"),\" in \",path.call(print,\"right\"),\")\",adjustClause(n.body,path.call(print,\"body\"))]));case\"ForOfStatement\":return group$b(concat$d([\"for\",n.await?\" await\":\"\",\" (\",path.call(print,\"left\"),\" of \",path.call(print,\"right\"),\")\",adjustClause(n.body,path.call(print,\"body\"))]));case\"DoWhileStatement\":{const clause=adjustClause(n.body,path.call(print,\"body\"));const doBody=group$b(concat$d([\"do\",clause]));parts=[doBody];if(n.body.type===\"BlockStatement\"){parts.push(\" \");}else{parts.push(hardline$9);}parts.push(\"while (\");parts.push(group$b(concat$d([indent$7(concat$d([softline$6,path.call(print,\"test\")])),softline$6])),\")\",semi);return concat$d(parts);}case\"DoExpression\":return concat$d([\"do \",path.call(print,\"body\")]);case\"BreakStatement\":parts.push(\"break\");if(n.label){parts.push(\" \",path.call(print,\"label\"));}parts.push(semi);return concat$d(parts);case\"ContinueStatement\":parts.push(\"continue\");if(n.label){parts.push(\" \",path.call(print,\"label\"));}parts.push(semi);return concat$d(parts);case\"LabeledStatement\":if(n.body.type===\"EmptyStatement\"){return concat$d([path.call(print,\"label\"),\":;\"]);}return concat$d([path.call(print,\"label\"),\": \",path.call(print,\"body\")]);case\"TryStatement\":return concat$d([\"try \",path.call(print,\"block\"),n.handler?concat$d([\" \",path.call(print,\"handler\")]):\"\",n.finalizer?concat$d([\" finally \",path.call(print,\"finalizer\")]):\"\"]);case\"CatchClause\":if(n.param){const hasComments=n.param.comments&&n.param.comments.some(comment=>!comments$1.isBlockComment(comment)||comment.leading&&hasNewline$5(options.originalText,options.locEnd(comment))||comment.trailing&&hasNewline$5(options.originalText,options.locStart(comment),{backwards:true}));const param=path.call(print,\"param\");return concat$d([\"catch \",hasComments?concat$d([\"(\",indent$7(concat$d([softline$6,param])),softline$6,\") \"]):concat$d([\"(\",param,\") \"]),path.call(print,\"body\")]);}return concat$d([\"catch \",path.call(print,\"body\")]);case\"ThrowStatement\":return concat$d([\"throw\",printReturnAndThrowArgument(path,options,print)]);// Note: ignoring n.lexical because it has no printing consequences.\ncase\"SwitchStatement\":return concat$d([group$b(concat$d([\"switch (\",indent$7(concat$d([softline$6,path.call(print,\"discriminant\")])),softline$6,\")\"])),\" {\",n.cases.length>0?indent$7(concat$d([hardline$9,join$9(hardline$9,path.map(casePath=>{const caseNode=casePath.getValue();return concat$d([casePath.call(print),n.cases.indexOf(caseNode)!==n.cases.length-1&&isNextLineEmpty$4(options.originalText,caseNode,options.locEnd)?hardline$9:\"\"]);},\"cases\"))])):\"\",hardline$9,\"}\"]);case\"SwitchCase\":{if(n.test){parts.push(\"case \",path.call(print,\"test\"),\":\");}else{parts.push(\"default:\");}const consequent=n.consequent.filter(node=>node.type!==\"EmptyStatement\");if(consequent.length>0){const cons=path.call(consequentPath=>{return printStatementSequence(consequentPath,options,print);},\"consequent\");parts.push(consequent.length===1&&consequent[0].type===\"BlockStatement\"?concat$d([\" \",cons]):indent$7(concat$d([hardline$9,cons])));}return concat$d(parts);}// JSX extensions below.\ncase\"DebuggerStatement\":return concat$d([\"debugger\",semi]);case\"JSXAttribute\":parts.push(path.call(print,\"name\"));if(n.value){let res;if(isStringLiteral$1(n.value)){const raw=rawText$1(n.value);// Unescape all quotes so we get an accurate preferred quote\nlet final=raw.replace(/&apos;/g,\"'\").replace(/&quot;/g,'\"');const quote=getPreferredQuote$1(final,options.jsxSingleQuote?\"'\":'\"');const escape=quote===\"'\"?\"&apos;\":\"&quot;\";final=final.slice(1,-1).replace(new RegExp(quote,\"g\"),escape);res=concat$d([quote,final,quote]);}else{res=path.call(print,\"value\");}parts.push(\"=\",res);}return concat$d(parts);case\"JSXIdentifier\":return\"\"+n.name;case\"JSXNamespacedName\":return join$9(\":\",[path.call(print,\"namespace\"),path.call(print,\"name\")]);case\"JSXMemberExpression\":return join$9(\".\",[path.call(print,\"object\"),path.call(print,\"property\")]);case\"TSQualifiedName\":return join$9(\".\",[path.call(print,\"left\"),path.call(print,\"right\")]);case\"JSXSpreadAttribute\":case\"JSXSpreadChild\":{return concat$d([\"{\",path.call(p=>{const printed=concat$d([\"...\",print(p)]);const n=p.getValue();if(!n.comments||!n.comments.length){return printed;}return concat$d([indent$7(concat$d([softline$6,comments.printComments(p,()=>printed,options)])),softline$6]);},n.type===\"JSXSpreadAttribute\"?\"argument\":\"expression\"),\"}\"]);}case\"JSXExpressionContainer\":{const parent=path.getParentNode(0);const hasComments=n.expression.comments&&n.expression.comments.length>0;const shouldInline=n.expression.type===\"JSXEmptyExpression\"||!hasComments&&(n.expression.type===\"ArrayExpression\"||n.expression.type===\"ObjectExpression\"||n.expression.type===\"ArrowFunctionExpression\"||n.expression.type===\"CallExpression\"||n.expression.type===\"OptionalCallExpression\"||n.expression.type===\"FunctionExpression\"||n.expression.type===\"TemplateLiteral\"||n.expression.type===\"TaggedTemplateExpression\"||n.expression.type===\"DoExpression\"||isJSXNode$1(parent)&&(n.expression.type===\"ConditionalExpression\"||isBinaryish$1(n.expression)));if(shouldInline){return group$b(concat$d([\"{\",path.call(print,\"expression\"),lineSuffixBoundary$1,\"}\"]));}return group$b(concat$d([\"{\",indent$7(concat$d([softline$6,path.call(print,\"expression\")])),softline$6,lineSuffixBoundary$1,\"}\"]));}case\"JSXFragment\":case\"JSXElement\":{const elem=comments.printComments(path,()=>printJSXElement(path,options,print),options);return maybeWrapJSXElementInParens(path,elem,options);}case\"JSXOpeningElement\":{const n=path.getValue();const nameHasComments=n.name&&n.name.comments&&n.name.comments.length>0||n.typeParameters&&n.typeParameters.comments&&n.typeParameters.comments.length>0;// Don't break self-closing elements with no attributes and no comments\nif(n.selfClosing&&!n.attributes.length&&!nameHasComments){return concat$d([\"<\",path.call(print,\"name\"),path.call(print,\"typeParameters\"),\" />\"]);}// don't break up opening elements with a single long text attribute\nif(n.attributes&&n.attributes.length===1&&n.attributes[0].value&&isStringLiteral$1(n.attributes[0].value)&&!n.attributes[0].value.value.includes(\"\\n\")&&// We should break for the following cases:\n// <div\n//   // comment\n//   attr=\"value\"\n// >\n// <div\n//   attr=\"value\"\n//   // comment\n// >\n!nameHasComments&&(!n.attributes[0].comments||!n.attributes[0].comments.length)){return group$b(concat$d([\"<\",path.call(print,\"name\"),path.call(print,\"typeParameters\"),\" \",concat$d(path.map(print,\"attributes\")),n.selfClosing?\" />\":\">\"]));}const lastAttrHasTrailingComments=n.attributes.length&&hasTrailingComment$1(getLast$3(n.attributes));const bracketSameLine=// Simple tags (no attributes and no comment in tag name) should be\n// kept unbroken regardless of `jsxBracketSameLine`\n!n.attributes.length&&!nameHasComments||options.jsxBracketSameLine&&(// We should print the bracket in a new line for the following cases:\n// <div\n//   // comment\n// >\n// <div\n//   attr // comment\n// >\n!nameHasComments||n.attributes.length)&&!lastAttrHasTrailingComments;// We should print the opening element expanded if any prop value is a\n// string literal with newlines\nconst shouldBreak=n.attributes&&n.attributes.some(attr=>attr.value&&isStringLiteral$1(attr.value)&&attr.value.value.includes(\"\\n\"));return group$b(concat$d([\"<\",path.call(print,\"name\"),path.call(print,\"typeParameters\"),concat$d([indent$7(concat$d(path.map(attr=>concat$d([line$9,print(attr)]),\"attributes\"))),n.selfClosing?line$9:bracketSameLine?\">\":softline$6]),n.selfClosing?\"/>\":bracketSameLine?\"\":\">\"]),{shouldBreak});}case\"JSXClosingElement\":return concat$d([\"</\",path.call(print,\"name\"),\">\"]);case\"JSXOpeningFragment\":case\"JSXClosingFragment\":{const hasComment=n.comments&&n.comments.length;const hasOwnLineComment=hasComment&&!n.comments.every(comments$1.isBlockComment);const isOpeningFragment=n.type===\"JSXOpeningFragment\";return concat$d([isOpeningFragment?\"<\":\"</\",indent$7(concat$d([hasOwnLineComment?hardline$9:hasComment&&!isOpeningFragment?\" \":\"\",comments.printDanglingComments(path,options,true)])),hasOwnLineComment?hardline$9:\"\",\">\"]);}case\"JSXText\":/* istanbul ignore next */throw new Error(\"JSXTest should be handled by JSXElement\");case\"JSXEmptyExpression\":{const requiresHardline=n.comments&&!n.comments.every(comments$1.isBlockComment);return concat$d([comments.printDanglingComments(path,options,/* sameIndent */!requiresHardline),requiresHardline?hardline$9:\"\"]);}case\"ClassBody\":if(!n.comments&&n.body.length===0){return\"{}\";}return concat$d([\"{\",n.body.length>0?indent$7(concat$d([hardline$9,path.call(bodyPath=>{return printStatementSequence(bodyPath,options,print);},\"body\")])):comments.printDanglingComments(path,options),hardline$9,\"}\"]);case\"ClassProperty\":case\"TSAbstractClassProperty\":case\"ClassPrivateProperty\":{if(n.decorators&&n.decorators.length!==0){parts.push(printDecorators(path,options,print));}if(n.accessibility){parts.push(n.accessibility+\" \");}if(n.declare){parts.push(\"declare \");}if(n.static){parts.push(\"static \");}if(n.type===\"TSAbstractClassProperty\"||n.abstract){parts.push(\"abstract \");}if(n.readonly){parts.push(\"readonly \");}const variance=getFlowVariance$1(n);if(variance){parts.push(variance);}parts.push(printPropertyKey(path,options,print),printOptionalToken(path),printTypeAnnotation(path,options,print));if(n.value){parts.push(\" =\",printAssignmentRight(n.key,n.value,path.call(print,\"value\"),options));}parts.push(semi);return group$b(concat$d(parts));}case\"ClassDeclaration\":case\"ClassExpression\":if(n.declare){parts.push(\"declare \");}parts.push(concat$d(printClass(path,options,print)));return concat$d(parts);case\"TSInterfaceHeritage\":case\"TSExpressionWithTypeArguments\":// Babel AST\nparts.push(path.call(print,\"expression\"));if(n.typeParameters){parts.push(path.call(print,\"typeParameters\"));}return concat$d(parts);case\"TemplateElement\":return join$9(literalline$4,n.value.raw.split(/\\r?\\n/g));case\"TemplateLiteral\":{let expressions=path.map(print,\"expressions\");const parentNode=path.getParentNode();if(isJestEachTemplateLiteral$1(n,parentNode)){const printed=printJestEachTemplateLiteral(n,expressions,options);if(printed){return printed;}}const isSimple=isSimpleTemplateLiteral$1(n);if(isSimple){expressions=expressions.map(doc=>printDocToString$2(doc,Object.assign({},options,{printWidth:Infinity})).formatted);}parts.push(lineSuffixBoundary$1,\"`\");path.each(childPath=>{const i=childPath.getName();parts.push(print(childPath));if(i<expressions.length){// For a template literal of the following form:\n//   `someQuery {\n//     ${call({\n//       a,\n//       b,\n//     })}\n//   }`\n// the expression is on its own line (there is a \\n in the previous\n// quasi literal), therefore we want to indent the JavaScript\n// expression inside at the beginning of ${ instead of the beginning\n// of the `.\nconst{tabWidth}=options;const quasi=childPath.getValue();const indentSize=getIndentSize$2(quasi.value.raw,tabWidth);let printed=expressions[i];if(!isSimple){// Breaks at the template element boundaries (${ and }) are preferred to breaking\n// in the middle of a MemberExpression\nif(n.expressions[i].comments&&n.expressions[i].comments.length||n.expressions[i].type===\"MemberExpression\"||n.expressions[i].type===\"OptionalMemberExpression\"||n.expressions[i].type===\"ConditionalExpression\"||n.expressions[i].type===\"SequenceExpression\"||n.expressions[i].type===\"TSAsExpression\"||isBinaryish$1(n.expressions[i])){printed=concat$d([indent$7(concat$d([softline$6,printed])),softline$6]);}}const aligned=indentSize===0&&quasi.value.raw.endsWith(\"\\n\")?align$1(-Infinity,printed):addAlignmentToDoc$2(printed,indentSize,tabWidth);parts.push(group$b(concat$d([\"${\",aligned,lineSuffixBoundary$1,\"}\"])));}},\"quasis\");parts.push(\"`\");return concat$d(parts);}// These types are unprintable because they serve as abstract\n// supertypes for other (printable) types.\ncase\"TaggedTemplateExpression\":return concat$d([path.call(print,\"tag\"),path.call(print,\"typeParameters\"),path.call(print,\"quasi\")]);case\"Node\":case\"Printable\":case\"SourceLocation\":case\"Position\":case\"Statement\":case\"Function\":case\"Pattern\":case\"Expression\":case\"Declaration\":case\"Specifier\":case\"NamedSpecifier\":case\"Comment\":case\"MemberTypeAnnotation\":// Flow\ncase\"Type\":/* istanbul ignore next */throw new Error(\"unprintable type: \"+JSON.stringify(n.type));// Type Annotations for Facebook Flow, typically stripped out or\n// transformed away before printing.\ncase\"TypeAnnotation\":case\"TSTypeAnnotation\":if(n.typeAnnotation){return path.call(print,\"typeAnnotation\");}/* istanbul ignore next */return\"\";case\"TSTupleType\":case\"TupleTypeAnnotation\":{const typesField=n.type===\"TSTupleType\"?\"elementTypes\":\"types\";const hasRest=n[typesField].length>0&&getLast$3(n[typesField]).type===\"TSRestType\";return group$b(concat$d([\"[\",indent$7(concat$d([softline$6,printArrayItems(path,options,typesField,print)])),ifBreak$6(shouldPrintComma$1(options,\"all\")&&!hasRest?\",\":\"\"),comments.printDanglingComments(path,options,/* sameIndent */true),softline$6,\"]\"]));}case\"ExistsTypeAnnotation\":return\"*\";case\"EmptyTypeAnnotation\":return\"empty\";case\"AnyTypeAnnotation\":return\"any\";case\"MixedTypeAnnotation\":return\"mixed\";case\"ArrayTypeAnnotation\":return concat$d([path.call(print,\"elementType\"),\"[]\"]);case\"BooleanTypeAnnotation\":return\"boolean\";case\"BooleanLiteralTypeAnnotation\":return\"\"+n.value;case\"DeclareClass\":return printFlowDeclaration(path,printClass(path,options,print));case\"TSDeclareFunction\":// For TypeScript the TSDeclareFunction node shares the AST\n// structure with FunctionDeclaration\nreturn concat$d([n.declare?\"declare \":\"\",printFunctionDeclaration(path,print,options),semi]);case\"DeclareFunction\":return printFlowDeclaration(path,[\"function \",path.call(print,\"id\"),n.predicate?\" \":\"\",path.call(print,\"predicate\"),semi]);case\"DeclareModule\":return printFlowDeclaration(path,[\"module \",path.call(print,\"id\"),\" \",path.call(print,\"body\")]);case\"DeclareModuleExports\":return printFlowDeclaration(path,[\"module.exports\",\": \",path.call(print,\"typeAnnotation\"),semi]);case\"DeclareVariable\":return printFlowDeclaration(path,[\"var \",path.call(print,\"id\"),semi]);case\"DeclareExportAllDeclaration\":return concat$d([\"declare export * from \",path.call(print,\"source\")]);case\"DeclareExportDeclaration\":return concat$d([\"declare \",printExportDeclaration(path,options,print)]);case\"DeclareOpaqueType\":case\"OpaqueType\":{parts.push(\"opaque type \",path.call(print,\"id\"),path.call(print,\"typeParameters\"));if(n.supertype){parts.push(\": \",path.call(print,\"supertype\"));}if(n.impltype){parts.push(\" = \",path.call(print,\"impltype\"));}parts.push(semi);if(n.type===\"DeclareOpaqueType\"){return printFlowDeclaration(path,parts);}return concat$d(parts);}case\"EnumDeclaration\":return concat$d([\"enum \",path.call(print,\"id\"),\" \",path.call(print,\"body\")]);case\"EnumBooleanBody\":case\"EnumNumberBody\":case\"EnumStringBody\":case\"EnumSymbolBody\":{if(n.type===\"EnumSymbolBody\"||n.explicitType){let type=null;switch(n.type){case\"EnumBooleanBody\":type=\"boolean\";break;case\"EnumNumberBody\":type=\"number\";break;case\"EnumStringBody\":type=\"string\";break;case\"EnumSymbolBody\":type=\"symbol\";break;}parts.push(\"of \",type,\" \");}if(n.members.length===0){parts.push(group$b(concat$d([\"{\",comments.printDanglingComments(path,options),softline$6,\"}\"])));}else{parts.push(group$b(concat$d([\"{\",indent$7(concat$d([hardline$9,printArrayItems(path,options,\"members\",print),shouldPrintComma$1(options)?\",\":\"\"])),comments.printDanglingComments(path,options,/* sameIndent */true),hardline$9,\"}\"])));}return concat$d(parts);}case\"EnumBooleanMember\":case\"EnumNumberMember\":case\"EnumStringMember\":return concat$d([path.call(print,\"id\"),\" = \",typeof n.init===\"object\"?path.call(print,\"init\"):String(n.init)]);case\"EnumDefaultedMember\":return path.call(print,\"id\");case\"FunctionTypeAnnotation\":case\"TSFunctionType\":{// FunctionTypeAnnotation is ambiguous:\n// declare function foo(a: B): void; OR\n// var A: (a: B) => void;\nconst parent=path.getParentNode(0);const parentParent=path.getParentNode(1);const parentParentParent=path.getParentNode(2);let isArrowFunctionTypeAnnotation=n.type===\"TSFunctionType\"||!((parent.type===\"ObjectTypeProperty\"||parent.type===\"ObjectTypeInternalSlot\")&&!getFlowVariance$1(parent)&&!parent.optional&&options.locStart(parent)===options.locStart(n)||parent.type===\"ObjectTypeCallProperty\"||parentParentParent&&parentParentParent.type===\"DeclareFunction\");let needsColon=isArrowFunctionTypeAnnotation&&(parent.type===\"TypeAnnotation\"||parent.type===\"TSTypeAnnotation\");// Sadly we can't put it inside of FastPath::needsColon because we are\n// printing \":\" as part of the expression and it would put parenthesis\n// around :(\nconst needsParens=needsColon&&isArrowFunctionTypeAnnotation&&(parent.type===\"TypeAnnotation\"||parent.type===\"TSTypeAnnotation\")&&parentParent.type===\"ArrowFunctionExpression\";if(isObjectTypePropertyAFunction$1(parent,options)){isArrowFunctionTypeAnnotation=true;needsColon=true;}if(needsParens){parts.push(\"(\");}parts.push(printFunctionParams(path,print,options,/* expandArg */false,/* printTypeParams */true));// The returnType is not wrapped in a TypeAnnotation, so the colon\n// needs to be added separately.\nif(n.returnType||n.predicate||n.typeAnnotation){parts.push(isArrowFunctionTypeAnnotation?\" => \":\": \",path.call(print,\"returnType\"),path.call(print,\"predicate\"),path.call(print,\"typeAnnotation\"));}if(needsParens){parts.push(\")\");}return group$b(concat$d(parts));}case\"TSRestType\":return concat$d([\"...\",path.call(print,\"typeAnnotation\")]);case\"TSOptionalType\":return concat$d([path.call(print,\"typeAnnotation\"),\"?\"]);case\"FunctionTypeParam\":return concat$d([path.call(print,\"name\"),printOptionalToken(path),n.name?\": \":\"\",path.call(print,\"typeAnnotation\")]);case\"GenericTypeAnnotation\":return concat$d([path.call(print,\"id\"),path.call(print,\"typeParameters\")]);case\"DeclareInterface\":case\"InterfaceDeclaration\":case\"InterfaceTypeAnnotation\":{if(n.type===\"DeclareInterface\"||n.declare){parts.push(\"declare \");}parts.push(\"interface\");if(n.type===\"DeclareInterface\"||n.type===\"InterfaceDeclaration\"){parts.push(\" \",path.call(print,\"id\"),path.call(print,\"typeParameters\"));}if(n.extends.length>0){parts.push(group$b(indent$7(concat$d([line$9,\"extends \",(n.extends.length===1?identity$2:indent$7)(join$9(concat$d([\",\",line$9]),path.map(print,\"extends\")))]))));}parts.push(\" \",path.call(print,\"body\"));return group$b(concat$d(parts));}case\"ClassImplements\":case\"InterfaceExtends\":return concat$d([path.call(print,\"id\"),path.call(print,\"typeParameters\")]);case\"TSClassImplements\":return concat$d([path.call(print,\"expression\"),path.call(print,\"typeParameters\")]);case\"TSIntersectionType\":case\"IntersectionTypeAnnotation\":{const types=path.map(print,\"types\");const result=[];let wasIndented=false;for(let i=0;i<types.length;++i){if(i===0){result.push(types[i]);}else if(isObjectType$1(n.types[i-1])&&isObjectType$1(n.types[i])){// If both are objects, don't indent\nresult.push(concat$d([\" & \",wasIndented?indent$7(types[i]):types[i]]));}else if(!isObjectType$1(n.types[i-1])&&!isObjectType$1(n.types[i])){// If no object is involved, go to the next line if it breaks\nresult.push(indent$7(concat$d([\" &\",line$9,types[i]])));}else{// If you go from object to non-object or vis-versa, then inline it\nif(i>1){wasIndented=true;}result.push(\" & \",i>1?indent$7(types[i]):types[i]);}}return group$b(concat$d(result));}case\"TSUnionType\":case\"UnionTypeAnnotation\":{// single-line variation\n// A | B | C\n// multi-line variation\n// | A\n// | B\n// | C\nconst parent=path.getParentNode();// If there's a leading comment, the parent is doing the indentation\nconst shouldIndent=parent.type!==\"TypeParameterInstantiation\"&&parent.type!==\"TSTypeParameterInstantiation\"&&parent.type!==\"GenericTypeAnnotation\"&&parent.type!==\"TSTypeReference\"&&parent.type!==\"TSTypeAssertion\"&&parent.type!==\"TupleTypeAnnotation\"&&parent.type!==\"TSTupleType\"&&!(parent.type===\"FunctionTypeParam\"&&!parent.name)&&!((parent.type===\"TypeAlias\"||parent.type===\"VariableDeclarator\"||parent.type===\"TSTypeAliasDeclaration\")&&hasLeadingOwnLineComment$1(options.originalText,n,options));// {\n//   a: string\n// } | null | void\n// should be inlined and not be printed in the multi-line variant\nconst shouldHug=shouldHugType(n);// We want to align the children but without its comment, so it looks like\n// | child1\n// // comment\n// | child2\nconst printed=path.map(typePath=>{let printedType=typePath.call(print);if(!shouldHug){printedType=align$1(2,printedType);}return comments.printComments(typePath,()=>printedType,options);},\"types\");if(shouldHug){return join$9(\" | \",printed);}const shouldAddStartLine=shouldIndent&&!hasLeadingOwnLineComment$1(options.originalText,n,options);const code=concat$d([ifBreak$6(concat$d([shouldAddStartLine?line$9:\"\",\"| \"])),join$9(concat$d([line$9,\"| \"]),printed)]);if(needsParens_1(path,options)){return group$b(concat$d([indent$7(code),softline$6]));}if(parent.type===\"TupleTypeAnnotation\"&&parent.types.length>1||parent.type===\"TSTupleType\"&&parent.elementTypes.length>1){return group$b(concat$d([indent$7(concat$d([ifBreak$6(concat$d([\"(\",softline$6])),code])),softline$6,ifBreak$6(\")\")]));}return group$b(shouldIndent?indent$7(code):code);}case\"NullableTypeAnnotation\":return concat$d([\"?\",path.call(print,\"typeAnnotation\")]);case\"TSNullKeyword\":case\"NullLiteralTypeAnnotation\":return\"null\";case\"ThisTypeAnnotation\":return\"this\";case\"NumberTypeAnnotation\":return\"number\";case\"SymbolTypeAnnotation\":return\"symbol\";case\"ObjectTypeCallProperty\":if(n.static){parts.push(\"static \");}parts.push(path.call(print,\"value\"));return concat$d(parts);case\"ObjectTypeIndexer\":{const variance=getFlowVariance$1(n);return concat$d([variance||\"\",\"[\",path.call(print,\"id\"),n.id?\": \":\"\",path.call(print,\"key\"),\"]: \",path.call(print,\"value\")]);}case\"ObjectTypeProperty\":{const variance=getFlowVariance$1(n);let modifier=\"\";if(n.proto){modifier=\"proto \";}else if(n.static){modifier=\"static \";}return concat$d([modifier,isGetterOrSetter$1(n)?n.kind+\" \":\"\",variance||\"\",printPropertyKey(path,options,print),printOptionalToken(path),isFunctionNotation$1(n,options)?\"\":\": \",path.call(print,\"value\")]);}case\"QualifiedTypeIdentifier\":return concat$d([path.call(print,\"qualification\"),\".\",path.call(print,\"id\")]);case\"StringLiteralTypeAnnotation\":return nodeStr(n,options);case\"NumberLiteralTypeAnnotation\":assert.strictEqual(typeof n.value,\"number\");if(n.extra!=null){return printNumber$2(n.extra.raw);}return printNumber$2(n.raw);case\"StringTypeAnnotation\":return\"string\";case\"DeclareTypeAlias\":case\"TypeAlias\":{if(n.type===\"DeclareTypeAlias\"||n.declare){parts.push(\"declare \");}const printed=printAssignmentRight(n.id,n.right,path.call(print,\"right\"),options);parts.push(\"type \",path.call(print,\"id\"),path.call(print,\"typeParameters\"),\" =\",printed,semi);return group$b(concat$d(parts));}case\"TypeCastExpression\":{return concat$d([\"(\",path.call(print,\"expression\"),printTypeAnnotation(path,options,print),\")\"]);}case\"TypeParameterDeclaration\":case\"TypeParameterInstantiation\":{const value=path.getValue();const commentStart=value.range?options.originalText.slice(0,value.range[0]).lastIndexOf(\"/*\"):-1;// As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here\n// because we know for sure that this is a type definition.\nconst commentSyntax=commentStart>=0&&options.originalText.slice(commentStart).match(/^\\/\\*\\s*::/);if(commentSyntax){return concat$d([\"/*:: \",printTypeParameters(path,options,print,\"params\"),\" */\"]);}return printTypeParameters(path,options,print,\"params\");}case\"TSTypeParameterDeclaration\":case\"TSTypeParameterInstantiation\":return printTypeParameters(path,options,print,\"params\");case\"TSTypeParameter\":case\"TypeParameter\":{const parent=path.getParentNode();if(parent.type===\"TSMappedType\"){parts.push(\"[\",path.call(print,\"name\"));if(n.constraint){parts.push(\" in \",path.call(print,\"constraint\"));}parts.push(\"]\");return concat$d(parts);}const variance=getFlowVariance$1(n);if(variance){parts.push(variance);}parts.push(path.call(print,\"name\"));if(n.bound){parts.push(\": \");parts.push(path.call(print,\"bound\"));}if(n.constraint){parts.push(\" extends \",path.call(print,\"constraint\"));}if(n.default){parts.push(\" = \",path.call(print,\"default\"));}// Keep comma if the file extension is .tsx and\n// has one type parameter that isn't extend with any types.\n// Because, otherwise formatted result will be invalid as tsx.\nconst grandParent=path.getNode(2);if(parent.params&&parent.params.length===1&&isTSXFile$1(options)&&!n.constraint&&grandParent.type===\"ArrowFunctionExpression\"){parts.push(\",\");}return concat$d(parts);}case\"TypeofTypeAnnotation\":return concat$d([\"typeof \",path.call(print,\"argument\")]);case\"VoidTypeAnnotation\":return\"void\";case\"InferredPredicate\":return\"%checks\";// Unhandled types below. If encountered, nodes of these types should\n// be either left alone or desugared into AST types that are fully\n// supported by the pretty-printer.\ncase\"DeclaredPredicate\":return concat$d([\"%checks(\",path.call(print,\"value\"),\")\"]);case\"TSAbstractKeyword\":return\"abstract\";case\"TSAnyKeyword\":return\"any\";case\"TSAsyncKeyword\":return\"async\";case\"TSBooleanKeyword\":return\"boolean\";case\"TSBigIntKeyword\":return\"bigint\";case\"TSConstKeyword\":return\"const\";case\"TSDeclareKeyword\":return\"declare\";case\"TSExportKeyword\":return\"export\";case\"TSNeverKeyword\":return\"never\";case\"TSNumberKeyword\":return\"number\";case\"TSObjectKeyword\":return\"object\";case\"TSProtectedKeyword\":return\"protected\";case\"TSPrivateKeyword\":return\"private\";case\"TSPublicKeyword\":return\"public\";case\"TSReadonlyKeyword\":return\"readonly\";case\"TSSymbolKeyword\":return\"symbol\";case\"TSStaticKeyword\":return\"static\";case\"TSStringKeyword\":return\"string\";case\"TSUndefinedKeyword\":return\"undefined\";case\"TSUnknownKeyword\":return\"unknown\";case\"TSVoidKeyword\":return\"void\";case\"TSAsExpression\":return concat$d([path.call(print,\"expression\"),\" as \",path.call(print,\"typeAnnotation\")]);case\"TSArrayType\":return concat$d([path.call(print,\"elementType\"),\"[]\"]);case\"TSPropertySignature\":{if(n.export){parts.push(\"export \");}if(n.accessibility){parts.push(n.accessibility+\" \");}if(n.static){parts.push(\"static \");}if(n.readonly){parts.push(\"readonly \");}parts.push(printPropertyKey(path,options,print),printOptionalToken(path));if(n.typeAnnotation){parts.push(\": \");parts.push(path.call(print,\"typeAnnotation\"));}// This isn't valid semantically, but it's in the AST so we can print it.\nif(n.initializer){parts.push(\" = \",path.call(print,\"initializer\"));}return concat$d(parts);}case\"TSParameterProperty\":if(n.accessibility){parts.push(n.accessibility+\" \");}if(n.export){parts.push(\"export \");}if(n.static){parts.push(\"static \");}if(n.readonly){parts.push(\"readonly \");}parts.push(path.call(print,\"parameter\"));return concat$d(parts);case\"TSTypeReference\":return concat$d([path.call(print,\"typeName\"),printTypeParameters(path,options,print,\"typeParameters\")]);case\"TSTypeQuery\":return concat$d([\"typeof \",path.call(print,\"exprName\")]);case\"TSIndexSignature\":{const parent=path.getParentNode();// The typescript parser accepts multiple parameters here. If you're\n// using them, it makes sense to have a trailing comma. But if you\n// aren't, this is more like a computed property name than an array.\n// So we leave off the trailing comma when there's just one parameter.\nconst trailingComma=n.parameters.length>1?ifBreak$6(shouldPrintComma$1(options)?\",\":\"\"):\"\";const parametersGroup=group$b(concat$d([indent$7(concat$d([softline$6,join$9(concat$d([\", \",softline$6]),path.map(print,\"parameters\"))])),trailingComma,softline$6]));return concat$d([n.export?\"export \":\"\",n.accessibility?concat$d([n.accessibility,\" \"]):\"\",n.static?\"static \":\"\",n.readonly?\"readonly \":\"\",\"[\",n.parameters?parametersGroup:\"\",n.typeAnnotation?\"]: \":\"]\",n.typeAnnotation?path.call(print,\"typeAnnotation\"):\"\",parent.type===\"ClassBody\"?semi:\"\"]);}case\"TSTypePredicate\":return concat$d([n.asserts?\"asserts \":\"\",path.call(print,\"parameterName\"),n.typeAnnotation?concat$d([\" is \",path.call(print,\"typeAnnotation\")]):\"\"]);case\"TSNonNullExpression\":return concat$d([path.call(print,\"expression\"),\"!\"]);case\"TSThisType\":return\"this\";case\"TSImportType\":return concat$d([!n.isTypeOf?\"\":\"typeof \",\"import(\",path.call(print,n.parameter?\"parameter\":\"argument\"),\")\",!n.qualifier?\"\":concat$d([\".\",path.call(print,\"qualifier\")]),printTypeParameters(path,options,print,\"typeParameters\")]);case\"TSLiteralType\":return path.call(print,\"literal\");case\"TSIndexedAccessType\":return concat$d([path.call(print,\"objectType\"),\"[\",path.call(print,\"indexType\"),\"]\"]);case\"TSConstructSignatureDeclaration\":case\"TSCallSignatureDeclaration\":case\"TSConstructorType\":{if(n.type!==\"TSCallSignatureDeclaration\"){parts.push(\"new \");}parts.push(group$b(printFunctionParams(path,print,options,/* expandArg */false,/* printTypeParams */true)));if(n.returnType||n.typeAnnotation){const isType=n.type===\"TSConstructorType\";parts.push(isType?\" => \":\": \",path.call(print,\"returnType\"),path.call(print,\"typeAnnotation\"));}return concat$d(parts);}case\"TSTypeOperator\":return concat$d([n.operator,\" \",path.call(print,\"typeAnnotation\")]);case\"TSMappedType\":{const shouldBreak=hasNewlineInRange$3(options.originalText,options.locStart(n),options.locEnd(n));return group$b(concat$d([\"{\",indent$7(concat$d([options.bracketSpacing?line$9:softline$6,n.readonly?concat$d([getTypeScriptMappedTypeModifier$1(n.readonly,\"readonly\"),\" \"]):\"\",printTypeScriptModifiers(path,options,print),path.call(print,\"typeParameter\"),n.optional?getTypeScriptMappedTypeModifier$1(n.optional,\"?\"):\"\",n.typeAnnotation?\": \":\"\",path.call(print,\"typeAnnotation\"),ifBreak$6(semi,\"\")])),comments.printDanglingComments(path,options,/* sameIndent */true),options.bracketSpacing?line$9:softline$6,\"}\"]),{shouldBreak});}case\"TSMethodSignature\":parts.push(n.accessibility?concat$d([n.accessibility,\" \"]):\"\",n.export?\"export \":\"\",n.static?\"static \":\"\",n.readonly?\"readonly \":\"\",n.computed?\"[\":\"\",path.call(print,\"key\"),n.computed?\"]\":\"\",printOptionalToken(path),printFunctionParams(path,print,options,/* expandArg */false,/* printTypeParams */true));if(n.returnType||n.typeAnnotation){parts.push(\": \",path.call(print,\"returnType\"),path.call(print,\"typeAnnotation\"));}return group$b(concat$d(parts));case\"TSNamespaceExportDeclaration\":parts.push(\"export as namespace \",path.call(print,\"id\"));if(options.semi){parts.push(\";\");}return group$b(concat$d(parts));case\"TSEnumDeclaration\":if(n.declare){parts.push(\"declare \");}if(n.modifiers){parts.push(printTypeScriptModifiers(path,options,print));}if(n.const){parts.push(\"const \");}parts.push(\"enum \",path.call(print,\"id\"),\" \");if(n.members.length===0){parts.push(group$b(concat$d([\"{\",comments.printDanglingComments(path,options),softline$6,\"}\"])));}else{parts.push(group$b(concat$d([\"{\",indent$7(concat$d([hardline$9,printArrayItems(path,options,\"members\",print),shouldPrintComma$1(options,\"es5\")?\",\":\"\"])),comments.printDanglingComments(path,options,/* sameIndent */true),hardline$9,\"}\"])));}return concat$d(parts);case\"TSEnumMember\":parts.push(path.call(print,\"id\"));if(n.initializer){parts.push(\" = \",path.call(print,\"initializer\"));}return concat$d(parts);case\"TSImportEqualsDeclaration\":if(n.isExport){parts.push(\"export \");}parts.push(\"import \",path.call(print,\"id\"),\" = \",path.call(print,\"moduleReference\"));if(options.semi){parts.push(\";\");}return group$b(concat$d(parts));case\"TSExternalModuleReference\":return concat$d([\"require(\",path.call(print,\"expression\"),\")\"]);case\"TSModuleDeclaration\":{const parent=path.getParentNode();const isExternalModule=isLiteral$1(n.id);const parentIsDeclaration=parent.type===\"TSModuleDeclaration\";const bodyIsDeclaration=n.body&&n.body.type===\"TSModuleDeclaration\";if(parentIsDeclaration){parts.push(\".\");}else{if(n.declare){parts.push(\"declare \");}parts.push(printTypeScriptModifiers(path,options,print));const textBetweenNodeAndItsId=options.originalText.slice(options.locStart(n),options.locStart(n.id));// Global declaration looks like this:\n// (declare)? global { ... }\nconst isGlobalDeclaration=n.id.type===\"Identifier\"&&n.id.name===\"global\"&&!/namespace|module/.test(textBetweenNodeAndItsId);if(!isGlobalDeclaration){parts.push(isExternalModule||/(^|\\s)module(\\s|$)/.test(textBetweenNodeAndItsId)?\"module \":\"namespace \");}}parts.push(path.call(print,\"id\"));if(bodyIsDeclaration){parts.push(path.call(print,\"body\"));}else if(n.body){parts.push(\" \",group$b(path.call(print,\"body\")));}else{parts.push(semi);}return concat$d(parts);}case\"PrivateName\":return concat$d([\"#\",path.call(print,\"id\")]);// TODO: Temporary auto-generated node type. To remove when typescript-estree has proper support for private fields.\ncase\"TSPrivateIdentifier\":return n.escapedText;case\"TSConditionalType\":return printTernaryOperator(path,options,print,{beforeParts:()=>[path.call(print,\"checkType\"),\" \",\"extends\",\" \",path.call(print,\"extendsType\")],afterParts:()=>[],shouldCheckJsx:false,conditionalNodeType:\"TSConditionalType\",consequentNodePropertyName:\"trueType\",alternateNodePropertyName:\"falseType\",testNodePropertyNames:[\"checkType\",\"extendsType\"]});case\"TSInferType\":return concat$d([\"infer\",\" \",path.call(print,\"typeParameter\")]);case\"InterpreterDirective\":parts.push(\"#!\",n.value,hardline$9);if(isNextLineEmpty$4(options.originalText,n,options.locEnd)){parts.push(hardline$9);}return concat$d(parts);case\"NGRoot\":return concat$d([].concat(path.call(print,\"node\"),!n.node.comments||n.node.comments.length===0?[]:concat$d([\" //\",n.node.comments[0].value.trimEnd()])));case\"NGChainedExpression\":return group$b(join$9(concat$d([\";\",line$9]),path.map(childPath=>hasNgSideEffect$1(childPath)?print(childPath):concat$d([\"(\",print(childPath),\")\"]),\"expressions\")));case\"NGEmptyExpression\":return\"\";case\"NGQuotedExpression\":return concat$d([n.prefix,\": \",n.value.trim()]);case\"NGMicrosyntax\":return concat$d(path.map((childPath,index)=>concat$d([index===0?\"\":isNgForOf$1(childPath.getValue(),index,n)?\" \":concat$d([\";\",line$9]),print(childPath)]),\"body\"));case\"NGMicrosyntaxKey\":return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name)?n.name:JSON.stringify(n.name);case\"NGMicrosyntaxExpression\":return concat$d([path.call(print,\"expression\"),n.alias===null?\"\":concat$d([\" as \",path.call(print,\"alias\")])]);case\"NGMicrosyntaxKeyedExpression\":{const index=path.getName();const parentNode=path.getParentNode();const shouldNotPrintColon=isNgForOf$1(n,index,parentNode)||(index===1&&(n.key.name===\"then\"||n.key.name===\"else\")||index===2&&n.key.name===\"else\"&&parentNode.body[index-1].type===\"NGMicrosyntaxKeyedExpression\"&&parentNode.body[index-1].key.name===\"then\")&&parentNode.body[0].type===\"NGMicrosyntaxExpression\";return concat$d([path.call(print,\"key\"),shouldNotPrintColon?\" \":\": \",path.call(print,\"expression\")]);}case\"NGMicrosyntaxLet\":return concat$d([\"let \",path.call(print,\"key\"),n.value===null?\"\":concat$d([\" = \",path.call(print,\"value\")])]);case\"NGMicrosyntaxAs\":return concat$d([path.call(print,\"key\"),\" as \",path.call(print,\"alias\")]);case\"ArgumentPlaceholder\":return\"?\";// These are not valid TypeScript. Printing them just for the sake of error recovery.\ncase\"TSJSDocAllType\":return\"*\";case\"TSJSDocUnknownType\":return\"?\";case\"TSJSDocNullableType\":return concat$d([\"?\",path.call(print,\"typeAnnotation\")]);case\"TSJSDocNonNullableType\":return concat$d([\"!\",path.call(print,\"typeAnnotation\")]);case\"TSJSDocFunctionType\":return concat$d([\"function(\",// The parameters could be here, but typescript-estree doesn't convert them anyway (throws an error).\n\"): \",path.call(print,\"typeAnnotation\")]);default:/* istanbul ignore next */throw new Error(\"unknown type: \"+JSON.stringify(n.type));}}function printStatementSequence(path,options,print){const printed=[];const bodyNode=path.getNode();const isClass=bodyNode.type===\"ClassBody\";path.map((stmtPath,i)=>{const stmt=stmtPath.getValue();// Just in case the AST has been modified to contain falsy\n// \"statements,\" it's safer simply to skip them.\n/* istanbul ignore if */if(!stmt){return;}// Skip printing EmptyStatement nodes to avoid leaving stray\n// semicolons lying around.\nif(stmt.type===\"EmptyStatement\"){return;}const stmtPrinted=print(stmtPath);const text=options.originalText;const parts=[];// in no-semi mode, prepend statement with semicolon if it might break ASI\n// don't prepend the only JSX element in a program with semicolon\nif(!options.semi&&!isClass&&!isTheOnlyJSXElementInMarkdown$1(options,stmtPath)&&stmtNeedsASIProtection(stmtPath,options)){if(stmt.comments&&stmt.comments.some(comment=>comment.leading)){parts.push(print(stmtPath,{needsSemi:true}));}else{parts.push(\";\",stmtPrinted);}}else{parts.push(stmtPrinted);}if(!options.semi&&isClass){if(classPropMayCauseASIProblems$1(stmtPath)){parts.push(\";\");}else if(stmt.type===\"ClassProperty\"){const nextChild=bodyNode.body[i+1];if(classChildNeedsASIProtection$1(nextChild)){parts.push(\";\");}}}if(isNextLineEmpty$4(text,stmt,options.locEnd)&&!isLastStatement$1(stmtPath)){parts.push(hardline$9);}printed.push(concat$d(parts));});return join$9(hardline$9,printed);}function printPropertyKey(path,options,print){const node=path.getNode();if(node.computed){return concat$d([\"[\",path.call(print,\"key\"),\"]\"]);}const parent=path.getParentNode();const{key}=node;if(node.type===\"ClassPrivateProperty\"&&// flow has `Identifier` key, and babel has `PrivateName` key\nkey.type===\"Identifier\"){return concat$d([\"#\",path.call(print,\"key\")]);}if(options.quoteProps===\"consistent\"&&!needsQuoteProps.has(parent)){const objectHasStringProp=(parent.properties||parent.body||parent.members).some(prop=>!prop.computed&&prop.key&&isStringLiteral$1(prop.key)&&!isStringPropSafeToCoerceToIdentifier$1(prop,options));needsQuoteProps.set(parent,objectHasStringProp);}if(key.type===\"Identifier\"&&(options.parser===\"json\"||options.quoteProps===\"consistent\"&&needsQuoteProps.get(parent))){// a -> \"a\"\nconst prop=printString$2(JSON.stringify(key.name),options);return path.call(keyPath=>comments.printComments(keyPath,()=>prop,options),\"key\");}if(isStringPropSafeToCoerceToIdentifier$1(node,options)&&(options.quoteProps===\"as-needed\"||options.quoteProps===\"consistent\"&&!needsQuoteProps.get(parent))){// 'a' -> a\nreturn path.call(keyPath=>comments.printComments(keyPath,()=>key.value,options),\"key\");}return path.call(print,\"key\");}function printMethod(path,options,print){const node=path.getNode();const{kind}=node;const value=node.value||node;const parts=[];if(!kind||kind===\"init\"||kind===\"method\"||kind===\"constructor\"){if(value.async){parts.push(\"async \");}if(value.generator){parts.push(\"*\");}}else{assert.ok(kind===\"get\"||kind===\"set\");parts.push(kind,\" \");}parts.push(printPropertyKey(path,options,print),node.optional||node.key.optional?\"?\":\"\",node===value?printMethodInternal(path,options,print):path.call(path=>printMethodInternal(path,options,print),\"value\"));return concat$d(parts);}function printMethodInternal(path,options,print){const parts=[printFunctionTypeParameters(path,options,print),group$b(concat$d([printFunctionParams(path,print,options),printReturnType(path,print,options)]))];if(path.getNode().body){parts.push(\" \",path.call(print,\"body\"));}else{parts.push(options.semi?\";\":\"\");}return concat$d(parts);}function couldGroupArg(arg){return arg.type===\"ObjectExpression\"&&(arg.properties.length>0||arg.comments)||arg.type===\"ArrayExpression\"&&(arg.elements.length>0||arg.comments)||arg.type===\"TSTypeAssertion\"&&couldGroupArg(arg.expression)||arg.type===\"TSAsExpression\"&&couldGroupArg(arg.expression)||arg.type===\"FunctionExpression\"||arg.type===\"ArrowFunctionExpression\"&&(// we want to avoid breaking inside composite return types but not simple keywords\n// https://github.com/prettier/prettier/issues/4070\n// export class Thing implements OtherThing {\n//   do: (type: Type) => Provider<Prop> = memoize(\n//     (type: ObjectType): Provider<Opts> => {}\n//   );\n// }\n// https://github.com/prettier/prettier/issues/6099\n// app.get(\"/\", (req, res): void => {\n//   res.send(\"Hello World!\");\n// });\n!arg.returnType||!arg.returnType.typeAnnotation||arg.returnType.typeAnnotation.type!==\"TSTypeReference\")&&(arg.body.type===\"BlockStatement\"||arg.body.type===\"ArrowFunctionExpression\"||arg.body.type===\"ObjectExpression\"||arg.body.type===\"ArrayExpression\"||arg.body.type===\"CallExpression\"||arg.body.type===\"OptionalCallExpression\"||arg.body.type===\"ConditionalExpression\"||isJSXNode$1(arg.body));}function shouldGroupLastArg(args){const lastArg=getLast$3(args);const penultimateArg=getPenultimate$1(args);return!hasLeadingComment$3(lastArg)&&!hasTrailingComment$1(lastArg)&&couldGroupArg(lastArg)&&(// If the last two arguments are of the same type,\n// disable last element expansion.\n!penultimateArg||penultimateArg.type!==lastArg.type);}function shouldGroupFirstArg(args){if(args.length!==2){return false;}const[firstArg,secondArg]=args;return(!firstArg.comments||!firstArg.comments.length)&&(firstArg.type===\"FunctionExpression\"||firstArg.type===\"ArrowFunctionExpression\"&&firstArg.body.type===\"BlockStatement\")&&secondArg.type!==\"FunctionExpression\"&&secondArg.type!==\"ArrowFunctionExpression\"&&secondArg.type!==\"ConditionalExpression\"&&!couldGroupArg(secondArg);}function printJestEachTemplateLiteral(node,expressions,options){/**\n     * a    | b    | expected\n     * ${1} | ${1} | ${2}\n     * ${1} | ${2} | ${3}\n     * ${2} | ${1} | ${3}\n     */const headerNames=node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);if(headerNames.length>1||headerNames.some(headerName=>headerName.length!==0)){const parts=[];const stringifiedExpressions=expressions.map(doc=>\"${\"+printDocToString$2(doc,Object.assign({},options,{printWidth:Infinity,endOfLine:\"lf\"})).formatted+\"}\");const tableBody=[{hasLineBreak:false,cells:[]}];for(let i=1;i<node.quasis.length;i++){const row=tableBody[tableBody.length-1];const correspondingExpression=stringifiedExpressions[i-1];row.cells.push(correspondingExpression);if(correspondingExpression.includes(\"\\n\")){row.hasLineBreak=true;}if(node.quasis[i].value.raw.includes(\"\\n\")){tableBody.push({hasLineBreak:false,cells:[]});}}const maxColumnCount=Math.max(headerNames.length,...tableBody.map(row=>row.cells.length));const maxColumnWidths=Array.from({length:maxColumnCount}).fill(0);const table=[{cells:headerNames},...tableBody.filter(row=>row.cells.length!==0)];for(const{cells}of table.filter(row=>!row.hasLineBreak)){cells.forEach((cell,index)=>{maxColumnWidths[index]=Math.max(maxColumnWidths[index],getStringWidth$3(cell));});}parts.push(lineSuffixBoundary$1,\"`\",indent$7(concat$d([hardline$9,join$9(hardline$9,table.map(row=>join$9(\" | \",row.cells.map((cell,index)=>row.hasLineBreak?cell:cell+\" \".repeat(maxColumnWidths[index]-getStringWidth$3(cell))))))])),hardline$9,\"`\");return concat$d(parts);}}function printArgumentsList(path,options,print){const node=path.getValue();const args=node.arguments;if(args.length===0){return concat$d([\"(\",comments.printDanglingComments(path,options,/* sameIndent */true),\")\"]);}// useEffect(() => { ... }, [foo, bar, baz])\nif(args.length===2&&args[0].type===\"ArrowFunctionExpression\"&&args[0].params.length===0&&args[0].body.type===\"BlockStatement\"&&args[1].type===\"ArrayExpression\"&&!args.find(arg=>arg.comments)){return concat$d([\"(\",path.call(print,\"arguments\",0),\", \",path.call(print,\"arguments\",1),\")\"]);}// func(\n//   ({\n//     a,\n//     b\n//   }) => {}\n// );\nfunction shouldBreakForArrowFunctionInArguments(arg,argPath){if(!arg||arg.type!==\"ArrowFunctionExpression\"||!arg.body||arg.body.type!==\"BlockStatement\"||!arg.params||arg.params.length<1){return false;}let shouldBreak=false;argPath.each(paramPath=>{const printed=concat$d([print(paramPath)]);shouldBreak=shouldBreak||willBreak$1(printed);},\"params\");return shouldBreak;}let anyArgEmptyLine=false;let shouldBreakForArrowFunction=false;let hasEmptyLineFollowingFirstArg=false;const lastArgIndex=args.length-1;const printedArguments=path.map((argPath,index)=>{const arg=argPath.getNode();const parts=[print(argPath)];if(index===lastArgIndex);else if(isNextLineEmpty$4(options.originalText,arg,options.locEnd)){if(index===0){hasEmptyLineFollowingFirstArg=true;}anyArgEmptyLine=true;parts.push(\",\",hardline$9,hardline$9);}else{parts.push(\",\",line$9);}shouldBreakForArrowFunction=shouldBreakForArrowFunctionInArguments(arg,argPath);return concat$d(parts);},\"arguments\");const maybeTrailingComma=// Dynamic imports cannot have trailing commas\n!(node.callee&&node.callee.type===\"Import\")&&shouldPrintComma$1(options,\"all\")?\",\":\"\";function allArgsBrokenOut(){return group$b(concat$d([\"(\",indent$7(concat$d([line$9,concat$d(printedArguments)])),maybeTrailingComma,line$9,\")\"]),{shouldBreak:true});}if(path.getParentNode().type!==\"Decorator\"&&isFunctionCompositionArgs$1(args)){return allArgsBrokenOut();}const shouldGroupFirst=shouldGroupFirstArg(args);const shouldGroupLast=shouldGroupLastArg(args);if(shouldGroupFirst||shouldGroupLast){const shouldBreak=(shouldGroupFirst?printedArguments.slice(1).some(willBreak$1):printedArguments.slice(0,-1).some(willBreak$1))||anyArgEmptyLine||shouldBreakForArrowFunction;// We want to print the last argument with a special flag\nlet printedExpanded;let i=0;path.each(argPath=>{if(shouldGroupFirst&&i===0){printedExpanded=[concat$d([argPath.call(p=>print(p,{expandFirstArg:true})),printedArguments.length>1?\",\":\"\",hasEmptyLineFollowingFirstArg?hardline$9:line$9,hasEmptyLineFollowingFirstArg?hardline$9:\"\"])].concat(printedArguments.slice(1));}if(shouldGroupLast&&i===args.length-1){printedExpanded=printedArguments.slice(0,-1).concat(argPath.call(p=>print(p,{expandLastArg:true})));}i++;},\"arguments\");const somePrintedArgumentsWillBreak=printedArguments.some(willBreak$1);const simpleConcat=concat$d([\"(\",concat$d(printedExpanded),\")\"]);return concat$d([somePrintedArgumentsWillBreak?breakParent$3:\"\",conditionalGroup$1([!somePrintedArgumentsWillBreak&&!node.typeArguments&&!node.typeParameters?simpleConcat:ifBreak$6(allArgsBrokenOut(),simpleConcat),shouldGroupFirst?concat$d([\"(\",group$b(printedExpanded[0],{shouldBreak:true}),concat$d(printedExpanded.slice(1)),\")\"]):concat$d([\"(\",concat$d(printedArguments.slice(0,-1)),group$b(getLast$3(printedExpanded),{shouldBreak:true}),\")\"]),allArgsBrokenOut()],{shouldBreak})]);}const contents=concat$d([\"(\",indent$7(concat$d([softline$6,concat$d(printedArguments)])),ifBreak$6(maybeTrailingComma),softline$6,\")\"]);if(isLongCurriedCallExpression$1(path)){// By not wrapping the arguments in a group, the printer prioritizes\n// breaking up these arguments rather than the args of the parent call.\nreturn contents;}return group$b(contents,{shouldBreak:printedArguments.some(willBreak$1)||anyArgEmptyLine});}function printTypeAnnotation(path,options,print){const node=path.getValue();if(!node.typeAnnotation){return\"\";}const parentNode=path.getParentNode();const isDefinite=node.definite||parentNode&&parentNode.type===\"VariableDeclarator\"&&parentNode.definite;const isFunctionDeclarationIdentifier=parentNode.type===\"DeclareFunction\"&&parentNode.id===node;if(isFlowAnnotationComment$1(options.originalText,node.typeAnnotation,options)){return concat$d([\" /*: \",path.call(print,\"typeAnnotation\"),\" */\"]);}return concat$d([isFunctionDeclarationIdentifier?\"\":isDefinite?\"!: \":\": \",path.call(print,\"typeAnnotation\")]);}function printFunctionTypeParameters(path,options,print){const fun=path.getValue();if(fun.typeArguments){return path.call(print,\"typeArguments\");}if(fun.typeParameters){return path.call(print,\"typeParameters\");}return\"\";}function printFunctionParams(path,print,options,expandArg,printTypeParams){const fun=path.getValue();const parent=path.getParentNode();const paramsField=fun.parameters?\"parameters\":\"params\";const isParametersInTestCall=isTestCall$1(parent);const shouldHugParameters=shouldHugArguments(fun);const shouldExpandParameters=expandArg&&!(fun[paramsField]&&fun[paramsField].some(n=>n.comments));const typeParams=printTypeParams?printFunctionTypeParameters(path,options,print):\"\";let printed=[];if(fun[paramsField]){const lastArgIndex=fun[paramsField].length-1;printed=path.map((childPath,index)=>{const parts=[];const param=childPath.getValue();parts.push(print(childPath));if(index===lastArgIndex){if(fun.rest){parts.push(\",\",line$9);}}else if(isParametersInTestCall||shouldHugParameters||shouldExpandParameters){parts.push(\", \");}else if(isNextLineEmpty$4(options.originalText,param,options.locEnd)){parts.push(\",\",hardline$9,hardline$9);}else{parts.push(\",\",line$9);}return concat$d(parts);},paramsField);}if(fun.rest){printed.push(concat$d([\"...\",path.call(print,\"rest\")]));}if(printed.length===0){return concat$d([typeParams,\"(\",comments.printDanglingComments(path,options,/* sameIndent */true,comment=>getNextNonSpaceNonCommentCharacter$1(options.originalText,comment,options.locEnd)===\")\"),\")\"]);}const lastParam=getLast$3(fun[paramsField]);// If the parent is a call with the first/last argument expansion and this is the\n// params of the first/last argument, we don't want the arguments to break and instead\n// want the whole expression to be on a new line.\n//\n// Good:                 Bad:\n//   verylongcall(         verylongcall((\n//     (a, b) => {           a,\n//     }                     b,\n//   })                    ) => {\n//                         })\nif(shouldExpandParameters){return group$b(concat$d([removeLines$2(typeParams),\"(\",concat$d(printed.map(removeLines$2)),\")\"]));}// Single object destructuring should hug\n//\n// function({\n//   a,\n//   b,\n//   c\n// }) {}\nconst hasNotParameterDecorator=fun[paramsField].every(param=>!param.decorators);if(shouldHugParameters&&hasNotParameterDecorator){return concat$d([typeParams,\"(\",concat$d(printed),\")\"]);}// don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`\nif(isParametersInTestCall){return concat$d([typeParams,\"(\",concat$d(printed),\")\"]);}const isFlowShorthandWithOneArg=(isObjectTypePropertyAFunction$1(parent,options)||isTypeAnnotationAFunction$1(parent,options)||parent.type===\"TypeAlias\"||parent.type===\"UnionTypeAnnotation\"||parent.type===\"TSUnionType\"||parent.type===\"IntersectionTypeAnnotation\"||parent.type===\"FunctionTypeAnnotation\"&&parent.returnType===fun)&&fun[paramsField].length===1&&fun[paramsField][0].name===null&&fun[paramsField][0].typeAnnotation&&fun.typeParameters===null&&isSimpleFlowType$1(fun[paramsField][0].typeAnnotation)&&!fun.rest;if(isFlowShorthandWithOneArg){if(options.arrowParens===\"always\"){return concat$d([\"(\",concat$d(printed),\")\"]);}return concat$d(printed);}const canHaveTrailingComma=!(lastParam&&lastParam.type===\"RestElement\")&&!fun.rest;return concat$d([typeParams,\"(\",indent$7(concat$d([softline$6,concat$d(printed)])),ifBreak$6(canHaveTrailingComma&&shouldPrintComma$1(options,\"all\")?\",\":\"\"),softline$6,\")\"]);}function shouldPrintParamsWithoutParens(path,options){if(options.arrowParens===\"always\"){return false;}if(options.arrowParens===\"avoid\"){const node=path.getValue();return canPrintParamsWithoutParens(node);}// Fallback default; should be unreachable\nreturn false;}function canPrintParamsWithoutParens(node){return node.params.length===1&&!node.rest&&!node.typeParameters&&!hasDanglingComments$1(node)&&node.params[0].type===\"Identifier\"&&!node.params[0].typeAnnotation&&!node.params[0].comments&&!node.params[0].optional&&!node.predicate&&!node.returnType;}function printFunctionDeclaration(path,print,options){const n=path.getValue();const parts=[];if(n.async){parts.push(\"async \");}if(n.generator){parts.push(\"function* \");}else{parts.push(\"function \");}if(n.id){parts.push(path.call(print,\"id\"));}parts.push(printFunctionTypeParameters(path,options,print),group$b(concat$d([printFunctionParams(path,print,options),printReturnType(path,print,options)])),n.body?\" \":\"\",path.call(print,\"body\"));return concat$d(parts);}function printReturnType(path,print,options){const n=path.getValue();const returnType=path.call(print,\"returnType\");if(n.returnType&&isFlowAnnotationComment$1(options.originalText,n.returnType,options)){return concat$d([\" /*: \",returnType,\" */\"]);}const parts=[returnType];// prepend colon to TypeScript type annotation\nif(n.returnType&&n.returnType.typeAnnotation){parts.unshift(\": \");}if(n.predicate){// The return type will already add the colon, but otherwise we\n// need to do it ourselves\nparts.push(n.returnType?\" \":\": \",path.call(print,\"predicate\"));}return concat$d(parts);}function printExportDeclaration(path,options,print){const decl=path.getValue();const semi=options.semi?\";\":\"\";const parts=[\"export \"];const isDefault=decl.default||decl.type===\"ExportDefaultDeclaration\";if(isDefault){parts.push(\"default \");}parts.push(comments.printDanglingComments(path,options,/* sameIndent */true));if(needsHardlineAfterDanglingComment$1(decl)){parts.push(hardline$9);}if(decl.declaration){parts.push(path.call(print,\"declaration\"));if(isDefault&&decl.declaration.type!==\"ClassDeclaration\"&&decl.declaration.type!==\"FunctionDeclaration\"&&decl.declaration.type!==\"TSInterfaceDeclaration\"&&decl.declaration.type!==\"DeclareClass\"&&decl.declaration.type!==\"DeclareFunction\"&&decl.declaration.type!==\"TSDeclareFunction\"){parts.push(semi);}}else{if(decl.specifiers&&decl.specifiers.length>0){const specifiers=[];const defaultSpecifiers=[];const namespaceSpecifiers=[];path.each(specifierPath=>{const specifierType=path.getValue().type;if(specifierType===\"ExportSpecifier\"){specifiers.push(print(specifierPath));}else if(specifierType===\"ExportDefaultSpecifier\"){defaultSpecifiers.push(print(specifierPath));}else if(specifierType===\"ExportNamespaceSpecifier\"){namespaceSpecifiers.push(concat$d([\"* as \",print(specifierPath)]));}},\"specifiers\");const isNamespaceFollowed=namespaceSpecifiers.length!==0&&specifiers.length!==0;const isDefaultFollowed=defaultSpecifiers.length!==0&&(namespaceSpecifiers.length!==0||specifiers.length!==0);const canBreak=specifiers.length>1||defaultSpecifiers.length>0||decl.specifiers&&decl.specifiers.some(node=>node.comments);let printed=\"\";if(specifiers.length!==0){if(canBreak){printed=group$b(concat$d([\"{\",indent$7(concat$d([options.bracketSpacing?line$9:softline$6,join$9(concat$d([\",\",line$9]),specifiers)])),ifBreak$6(shouldPrintComma$1(options)?\",\":\"\"),options.bracketSpacing?line$9:softline$6,\"}\"]));}else{printed=concat$d([\"{\",options.bracketSpacing?\" \":\"\",concat$d(specifiers),options.bracketSpacing?\" \":\"\",\"}\"]);}}parts.push(decl.exportKind===\"type\"?\"type \":\"\",concat$d(defaultSpecifiers),concat$d([isDefaultFollowed?\", \":\"\"]),concat$d(namespaceSpecifiers),concat$d([isNamespaceFollowed?\", \":\"\"]),printed);}else{parts.push(\"{}\");}if(decl.source){parts.push(\" from \",path.call(print,\"source\"));}parts.push(semi);}return concat$d(parts);}function printFlowDeclaration(path,parts){const parentExportDecl=getParentExportDeclaration$1(path);if(parentExportDecl){assert.strictEqual(parentExportDecl.type,\"DeclareExportDeclaration\");}else{// If the parent node has type DeclareExportDeclaration, then it\n// will be responsible for printing the \"declare\" token. Otherwise\n// it needs to be printed with this non-exported declaration node.\nparts.unshift(\"declare \");}return concat$d(parts);}function printTypeScriptModifiers(path,options,print){const n=path.getValue();if(!n.modifiers||!n.modifiers.length){return\"\";}return concat$d([join$9(\" \",path.map(print,\"modifiers\")),\" \"]);}function printTypeParameters(path,options,print,paramsKey){const n=path.getValue();if(!n[paramsKey]){return\"\";}// for TypeParameterDeclaration typeParameters is a single node\nif(!Array.isArray(n[paramsKey])){return path.call(print,paramsKey);}const grandparent=path.getNode(2);const greatGrandParent=path.getNode(3);const greatGreatGrandParent=path.getNode(4);const isParameterInTestCall=grandparent!=null&&isTestCall$1(grandparent);const shouldInline=isParameterInTestCall||n[paramsKey].length===0||n[paramsKey].length===1&&(shouldHugType(n[paramsKey][0])||n[paramsKey][0].type===\"GenericTypeAnnotation\"&&shouldHugType(n[paramsKey][0].id)||n[paramsKey][0].type===\"TSTypeReference\"&&shouldHugType(n[paramsKey][0].typeName)||n[paramsKey][0].type===\"NullableTypeAnnotation\"||// See https://github.com/prettier/prettier/pull/6467 for the context.\ngreatGreatGrandParent&&greatGreatGrandParent.type===\"VariableDeclarator\"&&grandparent.type===\"TSTypeAnnotation\"&&greatGrandParent.type!==\"ArrowFunctionExpression\"&&n[paramsKey][0].type!==\"TSUnionType\"&&n[paramsKey][0].type!==\"UnionTypeAnnotation\"&&n[paramsKey][0].type!==\"TSIntersectionType\"&&n[paramsKey][0].type!==\"IntersectionTypeAnnotation\"&&n[paramsKey][0].type!==\"TSConditionalType\"&&n[paramsKey][0].type!==\"TSMappedType\"&&n[paramsKey][0].type!==\"TSTypeOperator\"&&n[paramsKey][0].type!==\"TSIndexedAccessType\"&&n[paramsKey][0].type!==\"TSArrayType\");function printDanglingCommentsForInline(n){if(!hasDanglingComments$1(n)){return\"\";}const hasOnlyBlockComments=n.comments.every(comments$1.isBlockComment);const printed=comments.printDanglingComments(path,options,/* sameIndent */hasOnlyBlockComments);if(hasOnlyBlockComments){return printed;}return concat$d([printed,hardline$9]);}if(shouldInline){return concat$d([\"<\",join$9(\", \",path.map(print,paramsKey)),printDanglingCommentsForInline(n),\">\"]);}return group$b(concat$d([\"<\",indent$7(concat$d([softline$6,join$9(concat$d([\",\",line$9]),path.map(print,paramsKey))])),ifBreak$6(options.parser!==\"typescript\"&&options.parser!==\"babel-ts\"&&shouldPrintComma$1(options,\"all\")?\",\":\"\"),softline$6,\">\"]));}function printClass(path,options,print){const n=path.getValue();const parts=[];if(n.abstract){parts.push(\"abstract \");}parts.push(\"class\");if(n.id){parts.push(\" \",path.call(print,\"id\"));}parts.push(path.call(print,\"typeParameters\"));const partsGroup=[];if(n.superClass){const printed=concat$d([\"extends \",path.call(print,\"superClass\"),path.call(print,\"superTypeParameters\")]);// Keep old behaviour of extends in same line\n// If there is only on extends and there are not comments\nif((!n.implements||n.implements.length===0)&&(!n.superClass.comments||n.superClass.comments.length===0)){parts.push(concat$d([\" \",path.call(superClass=>comments.printComments(superClass,()=>printed,options),\"superClass\")]));}else{partsGroup.push(group$b(concat$d([line$9,path.call(superClass=>comments.printComments(superClass,()=>printed,options),\"superClass\")])));}}else if(n.extends&&n.extends.length>0){parts.push(\" extends \",join$9(\", \",path.map(print,\"extends\")));}if(n.mixins&&n.mixins.length>0){partsGroup.push(line$9,\"mixins \",group$b(indent$7(join$9(concat$d([\",\",line$9]),path.map(print,\"mixins\")))));}if(n.implements&&n.implements.length>0){partsGroup.push(line$9,\"implements\",group$b(indent$7(concat$d([line$9,join$9(concat$d([\",\",line$9]),path.map(print,\"implements\"))]))));}if(partsGroup.length>0){parts.push(group$b(indent$7(concat$d(partsGroup))));}if(n.body&&n.body.comments&&hasLeadingOwnLineComment$1(options.originalText,n.body,options)){parts.push(hardline$9);}else{parts.push(\" \");}parts.push(path.call(print,\"body\"));return parts;}function printOptionalToken(path){const node=path.getValue();if(!node.optional||// It's an optional computed method parsed by typescript-estree.\n// \"?\" is printed in `printMethod`.\nnode.type===\"Identifier\"&&node===path.getParentNode().key){return\"\";}if(node.type===\"OptionalCallExpression\"||node.type===\"OptionalMemberExpression\"&&node.computed){return\"?.\";}return\"?\";}function printMemberLookup(path,options,print){const property=path.call(print,\"property\");const n=path.getValue();const optional=printOptionalToken(path);if(!n.computed){return concat$d([optional,\".\",property]);}if(!n.property||isNumericLiteral$1(n.property)){return concat$d([optional,\"[\",property,\"]\"]);}return group$b(concat$d([optional,\"[\",indent$7(concat$d([softline$6,property])),softline$6,\"]\"]));}function printBindExpressionCallee(path,options,print){return concat$d([\"::\",path.call(print,\"callee\")]);}// We detect calls on member expressions specially to format a\n// common pattern better. The pattern we are looking for is this:\n//\n// arr\n//   .map(x => x + 1)\n//   .filter(x => x > 10)\n//   .some(x => x % 2)\n//\n// The way it is structured in the AST is via a nested sequence of\n// MemberExpression and CallExpression. We need to traverse the AST\n// and make groups out of it to print it in the desired way.\nfunction printMemberChain(path,options,print){// The first phase is to linearize the AST by traversing it down.\n//\n//   a().b()\n// has the following AST structure:\n//   CallExpression(MemberExpression(CallExpression(Identifier)))\n// and we transform it into\n//   [Identifier, CallExpression, MemberExpression, CallExpression]\nconst printedNodes=[];// Here we try to retain one typed empty line after each call expression or\n// the first group whether it is in parentheses or not\nfunction shouldInsertEmptyLineAfter(node){const{originalText}=options;const nextCharIndex=getNextNonSpaceNonCommentCharacterIndex$3(originalText,node,options.locEnd);const nextChar=originalText.charAt(nextCharIndex);// if it is cut off by a parenthesis, we only account for one typed empty\n// line after that parenthesis\nif(nextChar===\")\"){return isNextLineEmptyAfterIndex$2(originalText,nextCharIndex+1,options.locEnd);}return isNextLineEmpty$4(originalText,node,options.locEnd);}function rec(path){const node=path.getValue();if((node.type===\"CallExpression\"||node.type===\"OptionalCallExpression\")&&(isMemberish$1(node.callee)||node.callee.type===\"CallExpression\"||node.callee.type===\"OptionalCallExpression\")){printedNodes.unshift({node,printed:concat$d([comments.printComments(path,()=>concat$d([printOptionalToken(path),printFunctionTypeParameters(path,options,print),printArgumentsList(path,options,print)]),options),shouldInsertEmptyLineAfter(node)?hardline$9:\"\"])});path.call(callee=>rec(callee),\"callee\");}else if(isMemberish$1(node)){printedNodes.unshift({node,needsParens:needsParens_1(path,options),printed:comments.printComments(path,()=>node.type===\"OptionalMemberExpression\"||node.type===\"MemberExpression\"?printMemberLookup(path,options,print):printBindExpressionCallee(path,options,print),options)});path.call(object=>rec(object),\"object\");}else if(node.type===\"TSNonNullExpression\"){printedNodes.unshift({node,printed:comments.printComments(path,()=>\"!\",options)});path.call(expression=>rec(expression),\"expression\");}else{printedNodes.unshift({node,printed:path.call(print)});}}// Note: the comments of the root node have already been printed, so we\n// need to extract this first call without printing them as they would\n// if handled inside of the recursive call.\nconst node=path.getValue();printedNodes.unshift({node,printed:concat$d([printOptionalToken(path),printFunctionTypeParameters(path,options,print),printArgumentsList(path,options,print)])});path.call(callee=>rec(callee),\"callee\");// Once we have a linear list of printed nodes, we want to create groups out\n// of it.\n//\n//   a().b.c().d().e\n// will be grouped as\n//   [\n//     [Identifier, CallExpression],\n//     [MemberExpression, MemberExpression, CallExpression],\n//     [MemberExpression, CallExpression],\n//     [MemberExpression],\n//   ]\n// so that we can print it as\n//   a()\n//     .b.c()\n//     .d()\n//     .e\n// The first group is the first node followed by\n//   - as many CallExpression as possible\n//       < fn()()() >.something()\n//   - as many array accessors as possible\n//       < fn()[0][1][2] >.something()\n//   - then, as many MemberExpression as possible but the last one\n//       < this.items >.something()\nconst groups=[];let currentGroup=[printedNodes[0]];let i=1;for(;i<printedNodes.length;++i){if(printedNodes[i].node.type===\"TSNonNullExpression\"||printedNodes[i].node.type===\"OptionalCallExpression\"||printedNodes[i].node.type===\"CallExpression\"||(printedNodes[i].node.type===\"MemberExpression\"||printedNodes[i].node.type===\"OptionalMemberExpression\")&&printedNodes[i].node.computed&&isNumericLiteral$1(printedNodes[i].node.property)){currentGroup.push(printedNodes[i]);}else{break;}}if(printedNodes[0].node.type!==\"CallExpression\"&&printedNodes[0].node.type!==\"OptionalCallExpression\"){for(;i+1<printedNodes.length;++i){if(isMemberish$1(printedNodes[i].node)&&isMemberish$1(printedNodes[i+1].node)){currentGroup.push(printedNodes[i]);}else{break;}}}groups.push(currentGroup);currentGroup=[];// Then, each following group is a sequence of MemberExpression followed by\n// a sequence of CallExpression. To compute it, we keep adding things to the\n// group until we has seen a CallExpression in the past and reach a\n// MemberExpression\nlet hasSeenCallExpression=false;for(;i<printedNodes.length;++i){if(hasSeenCallExpression&&isMemberish$1(printedNodes[i].node)){// [0] should be appended at the end of the group instead of the\n// beginning of the next one\nif(printedNodes[i].node.computed&&isNumericLiteral$1(printedNodes[i].node.property)){currentGroup.push(printedNodes[i]);continue;}groups.push(currentGroup);currentGroup=[];hasSeenCallExpression=false;}if(printedNodes[i].node.type===\"CallExpression\"||printedNodes[i].node.type===\"OptionalCallExpression\"){hasSeenCallExpression=true;}currentGroup.push(printedNodes[i]);if(printedNodes[i].node.comments&&printedNodes[i].node.comments.some(comment=>comment.trailing)){groups.push(currentGroup);currentGroup=[];hasSeenCallExpression=false;}}if(currentGroup.length>0){groups.push(currentGroup);}// There are cases like Object.keys(), Observable.of(), _.values() where\n// they are the subject of all the chained calls and therefore should\n// be kept on the same line:\n//\n//   Object.keys(items)\n//     .filter(x => x)\n//     .map(x => x)\n//\n// In order to detect those cases, we use an heuristic: if the first\n// node is an identifier with the name starting with a capital\n// letter or just a sequence of _$. The rationale is that they are\n// likely to be factories.\nfunction isFactory(name){return /^[A-Z]|^[_$]+$/.test(name);}// In case the Identifier is shorter than tab width, we can keep the\n// first call in a single line, if it's an ExpressionStatement.\n//\n//   d3.scaleLinear()\n//     .domain([0, 100])\n//     .range([0, width]);\n//\nfunction isShort(name){return name.length<=options.tabWidth;}function shouldNotWrap(groups){const parent=path.getParentNode();const isExpression=parent&&parent.type===\"ExpressionStatement\";const hasComputed=groups[1].length&&groups[1][0].node.computed;if(groups[0].length===1){const firstNode=groups[0][0].node;return firstNode.type===\"ThisExpression\"||firstNode.type===\"Identifier\"&&(isFactory(firstNode.name)||isExpression&&isShort(firstNode.name)||hasComputed);}const lastNode=getLast$3(groups[0]).node;return(lastNode.type===\"MemberExpression\"||lastNode.type===\"OptionalMemberExpression\")&&lastNode.property.type===\"Identifier\"&&(isFactory(lastNode.property.name)||hasComputed);}const shouldMerge=groups.length>=2&&!groups[1][0].node.comments&&shouldNotWrap(groups);function printGroup(printedGroup){const printed=printedGroup.map(tuple=>tuple.printed);// Checks if the last node (i.e. the parent node) needs parens and print\n// accordingly\nif(printedGroup.length>0&&printedGroup[printedGroup.length-1].needsParens){return concat$d([\"(\",...printed,\")\"]);}return concat$d(printed);}function printIndentedGroup(groups){if(groups.length===0){return\"\";}return indent$7(group$b(concat$d([hardline$9,join$9(hardline$9,groups.map(printGroup))])));}const printedGroups=groups.map(printGroup);const oneLine=concat$d(printedGroups);const cutoff=shouldMerge?3:2;const flatGroups=groups.reduce((res,group)=>res.concat(group),[]);const hasComment=flatGroups.slice(1,-1).some(node=>hasLeadingComment$3(node.node))||flatGroups.slice(0,-1).some(node=>hasTrailingComment$1(node.node))||groups[cutoff]&&hasLeadingComment$3(groups[cutoff][0].node);// If we only have a single `.`, we shouldn't do anything fancy and just\n// render everything concatenated together.\nif(groups.length<=cutoff&&!hasComment){if(isLongCurriedCallExpression$1(path)){return oneLine;}return group$b(oneLine);}// Find out the last node in the first group and check if it has an\n// empty line after\nconst lastNodeBeforeIndent=getLast$3(shouldMerge?groups.slice(1,2)[0]:groups[0]).node;const shouldHaveEmptyLineBeforeIndent=lastNodeBeforeIndent.type!==\"CallExpression\"&&lastNodeBeforeIndent.type!==\"OptionalCallExpression\"&&shouldInsertEmptyLineAfter(lastNodeBeforeIndent);const expanded=concat$d([printGroup(groups[0]),shouldMerge?concat$d(groups.slice(1,2).map(printGroup)):\"\",shouldHaveEmptyLineBeforeIndent?hardline$9:\"\",printIndentedGroup(groups.slice(shouldMerge?2:1))]);const callExpressions=printedNodes.map(_ref17=>{let{node}=_ref17;return node;}).filter(isCallOrOptionalCallExpression$1);// We don't want to print in one line if the chain has:\n//  * A comment.\n//  * Non-trivial arguments.\n//  * Any group but the last one has a hard line.\n// If the last group is a function it's okay to inline if it fits.\nif(hasComment||callExpressions.length>2&&callExpressions.some(expr=>!expr.arguments.every(arg=>isSimpleCallArgument$1(arg,0)))||printedGroups.slice(0,-1).some(willBreak$1)||/**\n     *     scopes.filter(scope => scope.value !== '').map((scope, i) => {\n     *       // multi line content\n     *     })\n     */((lastGroupDoc,lastGroupNode)=>isCallOrOptionalCallExpression$1(lastGroupNode)&&willBreak$1(lastGroupDoc))(getLast$3(printedGroups),getLast$3(getLast$3(groups)).node)&&callExpressions.slice(0,-1).some(n=>n.arguments.some(isFunctionOrArrowExpression$1))){return group$b(expanded);}return concat$d([// We only need to check `oneLine` because if `expanded` is chosen\n// that means that the parent group has already been broken\n// naturally\nwillBreak$1(oneLine)||shouldHaveEmptyLineBeforeIndent?breakParent$3:\"\",conditionalGroup$1([oneLine,expanded])]);}function separatorNoWhitespace(isFacebookTranslationTag,child,childNode,nextNode){if(isFacebookTranslationTag){return\"\";}if(childNode.type===\"JSXElement\"&&!childNode.closingElement||nextNode&&nextNode.type===\"JSXElement\"&&!nextNode.closingElement){return child.length===1?softline$6:hardline$9;}return softline$6;}function separatorWithWhitespace(isFacebookTranslationTag,child,childNode,nextNode){if(isFacebookTranslationTag){return hardline$9;}if(child.length===1){return childNode.type===\"JSXElement\"&&!childNode.closingElement||nextNode&&nextNode.type===\"JSXElement\"&&!nextNode.closingElement?hardline$9:softline$6;}return hardline$9;}// JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\nfunction printJSXChildren(path,options,print,jsxWhitespace,isFacebookTranslationTag){const n=path.getValue();const children=[];// using `map` instead of `each` because it provides `i`\npath.map((childPath,i)=>{const child=childPath.getValue();if(isLiteral$1(child)){const text=rawText$1(child);// Contains a non-whitespace character\nif(isMeaningfulJSXText$1(child)){const words=text.split(matchJsxWhitespaceRegex$1);// Starts with whitespace\nif(words[0]===\"\"){children.push(\"\");words.shift();if(/\\n/.test(words[0])){const next=n.children[i+1];children.push(separatorWithWhitespace(isFacebookTranslationTag,words[1],child,next));}else{children.push(jsxWhitespace);}words.shift();}let endWhitespace;// Ends with whitespace\nif(getLast$3(words)===\"\"){words.pop();endWhitespace=words.pop();}// This was whitespace only without a new line.\nif(words.length===0){return;}words.forEach((word,i)=>{if(i%2===1){children.push(line$9);}else{children.push(word);}});if(endWhitespace!==undefined){if(/\\n/.test(endWhitespace)){const next=n.children[i+1];children.push(separatorWithWhitespace(isFacebookTranslationTag,getLast$3(children),child,next));}else{children.push(jsxWhitespace);}}else{const next=n.children[i+1];children.push(separatorNoWhitespace(isFacebookTranslationTag,getLast$3(children),child,next));}}else if(/\\n/.test(text)){// Keep (up to one) blank line between tags/expressions/text.\n// Note: We don't keep blank lines between text elements.\nif(text.match(/\\n/g).length>1){children.push(\"\");children.push(hardline$9);}}else{children.push(\"\");children.push(jsxWhitespace);}}else{const printedChild=print(childPath);children.push(printedChild);const next=n.children[i+1];const directlyFollowedByMeaningfulText=next&&isMeaningfulJSXText$1(next);if(directlyFollowedByMeaningfulText){const firstWord=rawText$1(next).trim().split(matchJsxWhitespaceRegex$1)[0];children.push(separatorNoWhitespace(isFacebookTranslationTag,firstWord,child,next));}else{children.push(hardline$9);}}},\"children\");return children;}// JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\nfunction printJSXElement(path,options,print){const n=path.getValue();if(n.type===\"JSXElement\"&&isEmptyJSXElement$1(n)){return concat$d([path.call(print,\"openingElement\"),path.call(print,\"closingElement\")]);}const openingLines=n.type===\"JSXElement\"?path.call(print,\"openingElement\"):path.call(print,\"openingFragment\");const closingLines=n.type===\"JSXElement\"?path.call(print,\"closingElement\"):path.call(print,\"closingFragment\");if(n.children.length===1&&n.children[0].type===\"JSXExpressionContainer\"&&(n.children[0].expression.type===\"TemplateLiteral\"||n.children[0].expression.type===\"TaggedTemplateExpression\")){return concat$d([openingLines,concat$d(path.map(print,\"children\")),closingLines]);}// Convert `{\" \"}` to text nodes containing a space.\n// This makes it easy to turn them into `jsxWhitespace` which\n// can then print as either a space or `{\" \"}` when breaking.\nn.children=n.children.map(child=>{if(isJSXWhitespaceExpression$1(child)){return{type:\"JSXText\",value:\" \",raw:\" \"};}return child;});const containsTag=n.children.filter(isJSXNode$1).length>0;const containsMultipleExpressions=n.children.filter(child=>child.type===\"JSXExpressionContainer\").length>1;const containsMultipleAttributes=n.type===\"JSXElement\"&&n.openingElement.attributes.length>1;// Record any breaks. Should never go from true to false, only false to true.\nlet forcedBreak=willBreak$1(openingLines)||containsTag||containsMultipleAttributes||containsMultipleExpressions;const isMdxBlock=path.getParentNode().rootMarker===\"mdx\";const rawJsxWhitespace=options.singleQuote?\"{' '}\":'{\" \"}';const jsxWhitespace=isMdxBlock?concat$d([\" \"]):ifBreak$6(concat$d([rawJsxWhitespace,softline$6]),\" \");const isFacebookTranslationTag=n.openingElement&&n.openingElement.name&&n.openingElement.name.name===\"fbt\";const children=printJSXChildren(path,options,print,jsxWhitespace,isFacebookTranslationTag);const containsText=n.children.some(child=>isMeaningfulJSXText$1(child));// We can end up we multiple whitespace elements with empty string\n// content between them.\n// We need to remove empty whitespace and softlines before JSX whitespace\n// to get the correct output.\nfor(let i=children.length-2;i>=0;i--){const isPairOfEmptyStrings=children[i]===\"\"&&children[i+1]===\"\";const isPairOfHardlines=children[i]===hardline$9&&children[i+1]===\"\"&&children[i+2]===hardline$9;const isLineFollowedByJSXWhitespace=(children[i]===softline$6||children[i]===hardline$9)&&children[i+1]===\"\"&&children[i+2]===jsxWhitespace;const isJSXWhitespaceFollowedByLine=children[i]===jsxWhitespace&&children[i+1]===\"\"&&(children[i+2]===softline$6||children[i+2]===hardline$9);const isDoubleJSXWhitespace=children[i]===jsxWhitespace&&children[i+1]===\"\"&&children[i+2]===jsxWhitespace;const isPairOfHardOrSoftLines=children[i]===softline$6&&children[i+1]===\"\"&&children[i+2]===hardline$9||children[i]===hardline$9&&children[i+1]===\"\"&&children[i+2]===softline$6;if(isPairOfHardlines&&containsText||isPairOfEmptyStrings||isLineFollowedByJSXWhitespace||isDoubleJSXWhitespace||isPairOfHardOrSoftLines){children.splice(i,2);}else if(isJSXWhitespaceFollowedByLine){children.splice(i+1,2);}}// Trim trailing lines (or empty strings)\nwhile(children.length&&(isLineNext$1(getLast$3(children))||isEmpty$1(getLast$3(children)))){children.pop();}// Trim leading lines (or empty strings)\nwhile(children.length&&(isLineNext$1(children[0])||isEmpty$1(children[0]))&&(isLineNext$1(children[1])||isEmpty$1(children[1]))){children.shift();children.shift();}// Tweak how we format children if outputting this element over multiple lines.\n// Also detect whether we will force this element to output over multiple lines.\nconst multilineChildren=[];children.forEach((child,i)=>{// There are a number of situations where we need to ensure we display\n// whitespace as `{\" \"}` when outputting this element over multiple lines.\nif(child===jsxWhitespace){if(i===1&&children[i-1]===\"\"){if(children.length===2){// Solitary whitespace\nmultilineChildren.push(rawJsxWhitespace);return;}// Leading whitespace\nmultilineChildren.push(concat$d([rawJsxWhitespace,hardline$9]));return;}else if(i===children.length-1){// Trailing whitespace\nmultilineChildren.push(rawJsxWhitespace);return;}else if(children[i-1]===\"\"&&children[i-2]===hardline$9){// Whitespace after line break\nmultilineChildren.push(rawJsxWhitespace);return;}}multilineChildren.push(child);if(willBreak$1(child)){forcedBreak=true;}});// If there is text we use `fill` to fit as much onto each line as possible.\n// When there is no text (just tags and expressions) we use `group`\n// to output each on a separate line.\nconst content=containsText?fill$4(multilineChildren):group$b(concat$d(multilineChildren),{shouldBreak:true});if(isMdxBlock){return content;}const multiLineElem=group$b(concat$d([openingLines,indent$7(concat$d([hardline$9,content])),hardline$9,closingLines]));if(forcedBreak){return multiLineElem;}return conditionalGroup$1([group$b(concat$d([openingLines,concat$d(children),closingLines])),multiLineElem]);}function maybeWrapJSXElementInParens(path,elem,options){const parent=path.getParentNode();if(!parent){return elem;}const NO_WRAP_PARENTS={ArrayExpression:true,JSXAttribute:true,JSXElement:true,JSXExpressionContainer:true,JSXFragment:true,ExpressionStatement:true,CallExpression:true,OptionalCallExpression:true,ConditionalExpression:true,JsExpressionRoot:true};if(NO_WRAP_PARENTS[parent.type]){return elem;}const shouldBreak=path.match(undefined,node=>node.type===\"ArrowFunctionExpression\",isCallOrOptionalCallExpression$1,node=>node.type===\"JSXExpressionContainer\");const needsParens=needsParens_1(path,options);return group$b(concat$d([needsParens?\"\":ifBreak$6(\"(\"),indent$7(concat$d([softline$6,elem])),softline$6,needsParens?\"\":ifBreak$6(\")\")]),{shouldBreak});}function shouldInlineLogicalExpression(node){if(node.type!==\"LogicalExpression\"){return false;}if(node.right.type===\"ObjectExpression\"&&node.right.properties.length!==0){return true;}if(node.right.type===\"ArrayExpression\"&&node.right.elements.length!==0){return true;}if(isJSXNode$1(node.right)){return true;}return false;}// For binary expressions to be consistent, we need to group\n// subsequent operators with the same precedence level under a single\n// group. Otherwise they will be nested such that some of them break\n// onto new lines but not all. Operators with the same precedence\n// level should either all break or not. Because we group them by\n// precedence level and the AST is structured based on precedence\n// level, things are naturally broken up correctly, i.e. `&&` is\n// broken before `+`.\nfunction printBinaryishExpressions(path,print,options,isNested,isInsideParenthesis){let parts=[];const node=path.getValue();// We treat BinaryExpression and LogicalExpression nodes the same.\nif(isBinaryish$1(node)){// Put all operators with the same precedence level in the same\n// group. The reason we only need to do this with the `left`\n// expression is because given an expression like `1 + 2 - 3`, it\n// is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n// is where the rest of the expression will exist. Binary\n// expressions on the right side mean they have a difference\n// precedence level and should be treated as a separate group, so\n// print them normally. (This doesn't hold for the `**` operator,\n// which is unique in that it is right-associative.)\nif(shouldFlatten$1(node.operator,node.left.operator)){// Flatten them out by recursively calling this function.\nparts=parts.concat(path.call(left=>printBinaryishExpressions(left,print,options,/* isNested */true,isInsideParenthesis),\"left\"));}else{parts.push(path.call(print,\"left\"));}const shouldInline=shouldInlineLogicalExpression(node);const lineBeforeOperator=(node.operator===\"|>\"||node.type===\"NGPipeExpression\"||node.operator===\"|\"&&options.parser===\"__vue_expression\")&&!hasLeadingOwnLineComment$1(options.originalText,node.right,options);const operator=node.type===\"NGPipeExpression\"?\"|\":node.operator;const rightSuffix=node.type===\"NGPipeExpression\"&&node.arguments.length!==0?group$b(indent$7(concat$d([softline$6,\": \",join$9(concat$d([softline$6,\":\",ifBreak$6(\" \")]),path.map(print,\"arguments\").map(arg=>align$1(2,group$b(arg))))]))):\"\";const right=shouldInline?concat$d([operator,\" \",path.call(print,\"right\"),rightSuffix]):concat$d([lineBeforeOperator?softline$6:\"\",operator,lineBeforeOperator?\" \":line$9,path.call(print,\"right\"),rightSuffix]);// If there's only a single binary expression, we want to create a group\n// in order to avoid having a small right part like -1 be on its own line.\nconst parent=path.getParentNode();const shouldGroup=!(isInsideParenthesis&&node.type===\"LogicalExpression\")&&parent.type!==node.type&&node.left.type!==node.type&&node.right.type!==node.type;parts.push(\" \",shouldGroup?group$b(right):right);// The root comments are already printed, but we need to manually print\n// the other ones since we don't call the normal print on BinaryExpression,\n// only for the left and right parts\nif(isNested&&node.comments){parts=comments.printComments(path,()=>concat$d(parts),options);}}else{// Our stopping case. Simply print the node normally.\nparts.push(path.call(print));}return parts;}function printAssignmentRight(leftNode,rightNode,printedRight,options){if(hasLeadingOwnLineComment$1(options.originalText,rightNode,options)){return indent$7(concat$d([line$9,printedRight]));}const canBreak=isBinaryish$1(rightNode)&&!shouldInlineLogicalExpression(rightNode)||rightNode.type===\"ConditionalExpression\"&&isBinaryish$1(rightNode.test)&&!shouldInlineLogicalExpression(rightNode.test)||rightNode.type===\"StringLiteralTypeAnnotation\"||rightNode.type===\"ClassExpression\"&&rightNode.decorators&&rightNode.decorators.length||(leftNode.type===\"Identifier\"||isStringLiteral$1(leftNode)||leftNode.type===\"MemberExpression\")&&(isStringLiteral$1(rightNode)||isMemberExpressionChain$1(rightNode))&&// do not put values on a separate line from the key in json\noptions.parser!==\"json\"&&options.parser!==\"json5\"||rightNode.type===\"SequenceExpression\";if(canBreak){return group$b(indent$7(concat$d([line$9,printedRight])));}return concat$d([\" \",printedRight]);}function printAssignment(leftNode,printedLeft,operator,rightNode,printedRight,options){if(!rightNode){return printedLeft;}const printed=printAssignmentRight(leftNode,rightNode,printedRight,options);return group$b(concat$d([printedLeft,operator,printed]));}function adjustClause(node,clause,forceSpace){if(node.type===\"EmptyStatement\"){return\";\";}if(node.type===\"BlockStatement\"||forceSpace){return concat$d([\" \",clause]);}return indent$7(concat$d([line$9,clause]));}function nodeStr(node,options,isFlowOrTypeScriptDirectiveLiteral){const raw=rawText$1(node);const isDirectiveLiteral=isFlowOrTypeScriptDirectiveLiteral||node.type===\"DirectiveLiteral\";return printString$2(raw,options,isDirectiveLiteral);}function printRegex(node){const flags=node.flags.split(\"\").sort().join(\"\");return\"/\".concat(node.pattern,\"/\").concat(flags);}function exprNeedsASIProtection(path,options){const node=path.getValue();const maybeASIProblem=needsParens_1(path,options)||node.type===\"ParenthesizedExpression\"||node.type===\"TypeCastExpression\"||node.type===\"ArrowFunctionExpression\"&&!shouldPrintParamsWithoutParens(path,options)||node.type===\"ArrayExpression\"||node.type===\"ArrayPattern\"||node.type===\"UnaryExpression\"&&node.prefix&&(node.operator===\"+\"||node.operator===\"-\")||node.type===\"TemplateLiteral\"||node.type===\"TemplateElement\"||isJSXNode$1(node)||node.type===\"BindExpression\"&&!node.object||node.type===\"RegExpLiteral\"||node.type===\"Literal\"&&node.pattern||node.type===\"Literal\"&&node.regex;if(maybeASIProblem){return true;}if(!hasNakedLeftSide$2(node)){return false;}return path.call(childPath=>exprNeedsASIProtection(childPath,options),...getLeftSidePathName$2(path,node));}function stmtNeedsASIProtection(path,options){const node=path.getNode();if(node.type!==\"ExpressionStatement\"){return false;}return path.call(childPath=>exprNeedsASIProtection(childPath,options),\"expression\");}function shouldHugType(node){if(isSimpleFlowType$1(node)||isObjectType$1(node)){return true;}if(node.type===\"UnionTypeAnnotation\"||node.type===\"TSUnionType\"){const voidCount=node.types.filter(n=>n.type===\"VoidTypeAnnotation\"||n.type===\"TSVoidKeyword\"||n.type===\"NullLiteralTypeAnnotation\"||n.type===\"TSNullKeyword\").length;const hasObject=node.types.some(n=>n.type===\"ObjectTypeAnnotation\"||n.type===\"TSTypeLiteral\"||// This is a bit aggressive but captures Array<{x}>\nn.type===\"GenericTypeAnnotation\"||n.type===\"TSTypeReference\");if(node.types.length-1===voidCount&&hasObject){return true;}}return false;}function shouldHugArguments(fun){if(!fun||fun.rest){return false;}const params=fun.params||fun.parameters;if(!params||params.length!==1){return false;}const param=params[0];return!param.comments&&(param.type===\"ObjectPattern\"||param.type===\"ArrayPattern\"||param.type===\"Identifier\"&&param.typeAnnotation&&(param.typeAnnotation.type===\"TypeAnnotation\"||param.typeAnnotation.type===\"TSTypeAnnotation\")&&isObjectType$1(param.typeAnnotation.typeAnnotation)||param.type===\"FunctionTypeParam\"&&isObjectType$1(param.typeAnnotation)||param.type===\"AssignmentPattern\"&&(param.left.type===\"ObjectPattern\"||param.left.type===\"ArrayPattern\")&&(param.right.type===\"Identifier\"||param.right.type===\"ObjectExpression\"&&param.right.properties.length===0||param.right.type===\"ArrayExpression\"&&param.right.elements.length===0));}function printArrayItems(path,options,printPath,print){const printedElements=[];let separatorParts=[];path.each(childPath=>{printedElements.push(concat$d(separatorParts));printedElements.push(group$b(print(childPath)));separatorParts=[\",\",line$9];if(childPath.getValue()&&isNextLineEmpty$4(options.originalText,childPath.getValue(),options.locEnd)){separatorParts.push(softline$6);}},printPath);return concat$d(printedElements);}function printReturnAndThrowArgument(path,options,print){const node=path.getValue();const semi=options.semi?\";\":\"\";const parts=[];if(node.argument){if(returnArgumentHasLeadingComment$1(options,node.argument)){parts.push(concat$d([\" (\",indent$7(concat$d([hardline$9,path.call(print,\"argument\")])),hardline$9,\")\"]));}else if(isBinaryish$1(node.argument)||node.argument.type===\"SequenceExpression\"){parts.push(group$b(concat$d([ifBreak$6(\" (\",\" \"),indent$7(concat$d([softline$6,path.call(print,\"argument\")])),softline$6,ifBreak$6(\")\")])));}else{parts.push(\" \",path.call(print,\"argument\"));}}const lastComment=Array.isArray(node.comments)&&node.comments[node.comments.length-1];const isLastCommentLine=lastComment&&(lastComment.type===\"CommentLine\"||lastComment.type===\"Line\");if(isLastCommentLine){parts.push(semi);}if(hasDanglingComments$1(node)){parts.push(\" \",comments.printDanglingComments(path,options,/* sameIndent */true));}if(!isLastCommentLine){parts.push(semi);}return concat$d(parts);}function willPrintOwnComments(path/*, options */){const node=path.getValue();const parent=path.getParentNode();return(node&&(isJSXNode$1(node)||hasFlowShorthandAnnotationComment$2(node)||parent&&(parent.type===\"CallExpression\"||parent.type===\"OptionalCallExpression\")&&(hasFlowAnnotationComment$1(node.leadingComments)||hasFlowAnnotationComment$1(node.trailingComments)))||parent&&(parent.type===\"JSXSpreadAttribute\"||parent.type===\"JSXSpreadChild\"||parent.type===\"UnionTypeAnnotation\"||parent.type===\"TSUnionType\"||(parent.type===\"ClassDeclaration\"||parent.type===\"ClassExpression\")&&parent.superClass===node))&&(!hasIgnoreComment$4(path)||parent.type===\"UnionTypeAnnotation\"||parent.type===\"TSUnionType\");}function canAttachComment$1(node){return node.type&&node.type!==\"CommentBlock\"&&node.type!==\"CommentLine\"&&node.type!==\"Line\"&&node.type!==\"Block\"&&node.type!==\"EmptyStatement\"&&node.type!==\"TemplateElement\"&&node.type!==\"Import\";}function printComment$2(commentPath,options){const comment=commentPath.getValue();switch(comment.type){case\"CommentBlock\":case\"Block\":{if(isIndentableBlockComment(comment)){const printed=printIndentableBlockComment(comment);// We need to prevent an edge case of a previous trailing comment\n// printed as a `lineSuffix` which causes the comments to be\n// interleaved. See https://github.com/prettier/prettier/issues/4412\nif(comment.trailing&&!hasNewline$5(options.originalText,options.locStart(comment),{backwards:true})){return concat$d([hardline$9,printed]);}return printed;}const commentEnd=options.locEnd(comment);const isInsideFlowComment=options.originalText.slice(commentEnd-3,commentEnd)===\"*-/\";return\"/*\"+comment.value+(isInsideFlowComment?\"*-/\":\"*/\");}case\"CommentLine\":case\"Line\":// Print shebangs with the proper comment characters\nif(options.originalText.slice(options.locStart(comment)).startsWith(\"#!\")){return\"#!\"+comment.value.trimEnd();}return\"//\"+comment.value.trimEnd();default:throw new Error(\"Not a comment: \"+JSON.stringify(comment));}}function isIndentableBlockComment(comment){// If the comment has multiple lines and every line starts with a star\n// we can fix the indentation of each line. The stars in the `/*` and\n// `*/` delimiters are not included in the comment value, so add them\n// back first.\nconst lines=\"*\".concat(comment.value,\"*\").split(\"\\n\");return lines.length>1&&lines.every(line=>line.trim()[0]===\"*\");}function printIndentableBlockComment(comment){const lines=comment.value.split(\"\\n\");return concat$d([\"/*\",join$9(hardline$9,lines.map((line,index)=>index===0?line.trimEnd():\" \"+(index<lines.length-1?line.trim():line.trimStart()))),\"*/\"]);}var printerEstree={preprocess:preprocess_1$1,print:genericPrint$3,embed:embed_1$1,insertPragma:insertPragma$7,massageAstNode:clean_1$1,hasPrettierIgnore:hasPrettierIgnore$5,willPrintOwnComments,canAttachComment:canAttachComment$1,printComment:printComment$2,isBlockComment:comments$1.isBlockComment,handleComments:{ownLine:comments$1.handleOwnLineComment,endOfLine:comments$1.handleEndOfLineComment,remaining:comments$1.handleRemainingComment},getGapRegex:comments$1.getGapRegex,getCommentChildNodes:comments$1.getCommentChildNodes};const{concat:concat$e,hardline:hardline$a,indent:indent$8,join:join$a}=document.builders;function genericPrint$4(path,options,print){const node=path.getValue();switch(node.type){case\"JsonRoot\":return concat$e([path.call(print,\"node\"),hardline$a]);case\"ArrayExpression\":return node.elements.length===0?\"[]\":concat$e([\"[\",indent$8(concat$e([hardline$a,join$a(concat$e([\",\",hardline$a]),path.map(print,\"elements\"))])),hardline$a,\"]\"]);case\"ObjectExpression\":return node.properties.length===0?\"{}\":concat$e([\"{\",indent$8(concat$e([hardline$a,join$a(concat$e([\",\",hardline$a]),path.map(print,\"properties\"))])),hardline$a,\"}\"]);case\"ObjectProperty\":return concat$e([path.call(print,\"key\"),\": \",path.call(print,\"value\")]);case\"UnaryExpression\":return concat$e([node.operator===\"+\"?\"\":node.operator,path.call(print,\"argument\")]);case\"NullLiteral\":return\"null\";case\"BooleanLiteral\":return node.value?\"true\":\"false\";case\"StringLiteral\":case\"NumericLiteral\":return JSON.stringify(node.value);case\"Identifier\":return JSON.stringify(node.name);default:/* istanbul ignore next */throw new Error(\"unknown type: \"+JSON.stringify(node.type));}}function clean$5(node,newNode/*, parent*/){delete newNode.start;delete newNode.end;delete newNode.extra;delete newNode.loc;delete newNode.comments;delete newNode.errors;if(node.type===\"Identifier\"){return{type:\"StringLiteral\",value:node.name};}if(node.type===\"UnaryExpression\"&&node.operator===\"+\"){return newNode.argument;}}var printerEstreeJson={preprocess:preprocess_1$1,print:genericPrint$4,massageAstNode:clean$5};const CATEGORY_JAVASCRIPT=\"JavaScript\";// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\nvar options$5={arrowParens:{since:\"1.9.0\",category:CATEGORY_JAVASCRIPT,type:\"choice\",default:[{since:\"1.9.0\",value:\"avoid\"},{since:\"2.0.0\",value:\"always\"}],description:\"Include parentheses around a sole arrow function parameter.\",choices:[{value:\"always\",description:\"Always include parens. Example: `(x) => x`\"},{value:\"avoid\",description:\"Omit parens when possible. Example: `x => x`\"}]},bracketSpacing:commonOptions.bracketSpacing,jsxBracketSameLine:{since:\"0.17.0\",category:CATEGORY_JAVASCRIPT,type:\"boolean\",default:false,description:\"Put > on the last line instead of at a new line.\"},semi:{since:\"1.0.0\",category:CATEGORY_JAVASCRIPT,type:\"boolean\",default:true,description:\"Print semicolons.\",oppositeDescription:\"Do not print semicolons, except at the beginning of lines which may need them.\"},singleQuote:commonOptions.singleQuote,jsxSingleQuote:{since:\"1.15.0\",category:CATEGORY_JAVASCRIPT,type:\"boolean\",default:false,description:\"Use single quotes in JSX.\"},quoteProps:{since:\"1.17.0\",category:CATEGORY_JAVASCRIPT,type:\"choice\",default:\"as-needed\",description:\"Change when properties in objects are quoted.\",choices:[{value:\"as-needed\",description:\"Only add quotes around object properties where required.\"},{value:\"consistent\",description:\"If at least one property in an object requires quotes, quote all properties.\"},{value:\"preserve\",description:\"Respect the input use of quotes in object properties.\"}]},trailingComma:{since:\"0.0.0\",category:CATEGORY_JAVASCRIPT,type:\"choice\",default:[{since:\"0.0.0\",value:false},{since:\"0.19.0\",value:\"none\"},{since:\"2.0.0\",value:\"es5\"}],description:\"Print trailing commas wherever possible when multi-line.\",choices:[{value:\"es5\",description:\"Trailing commas where valid in ES5 (objects, arrays, etc.)\"},{value:\"none\",description:\"No trailing commas.\"},{value:\"all\",description:\"Trailing commas wherever possible (including function arguments).\"}]}};var name$9=\"JavaScript\";var type$8=\"programming\";var tmScope$8=\"source.js\";var aceMode$8=\"javascript\";var codemirrorMode$4=\"javascript\";var codemirrorMimeType$4=\"text/javascript\";var color$3=\"#f1e05a\";var aliases$2=[\"js\",\"node\"];var extensions$8=[\".js\",\"._js\",\".bones\",\".cjs\",\".es\",\".es6\",\".frag\",\".gs\",\".jake\",\".jsb\",\".jscad\",\".jsfl\",\".jsm\",\".jss\",\".mjs\",\".njs\",\".pac\",\".sjs\",\".ssjs\",\".xsjs\",\".xsjslib\"];var filenames=[\"Jakefile\"];var interpreters=[\"chakra\",\"d8\",\"gjs\",\"js\",\"node\",\"qjs\",\"rhino\",\"v8\",\"v8-shell\"];var languageId$8=183;var JavaScript={name:name$9,type:type$8,tmScope:tmScope$8,aceMode:aceMode$8,codemirrorMode:codemirrorMode$4,codemirrorMimeType:codemirrorMimeType$4,color:color$3,aliases:aliases$2,extensions:extensions$8,filenames:filenames,interpreters:interpreters,languageId:languageId$8};var JavaScript$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$9,type:type$8,tmScope:tmScope$8,aceMode:aceMode$8,codemirrorMode:codemirrorMode$4,codemirrorMimeType:codemirrorMimeType$4,color:color$3,aliases:aliases$2,extensions:extensions$8,filenames:filenames,interpreters:interpreters,languageId:languageId$8,'default':JavaScript});var name$a=\"JSX\";var type$9=\"programming\";var group$c=\"JavaScript\";var extensions$9=[\".jsx\"];var tmScope$9=\"source.js.jsx\";var aceMode$9=\"javascript\";var codemirrorMode$5=\"jsx\";var codemirrorMimeType$5=\"text/jsx\";var languageId$9=178;var JSX={name:name$a,type:type$9,group:group$c,extensions:extensions$9,tmScope:tmScope$9,aceMode:aceMode$9,codemirrorMode:codemirrorMode$5,codemirrorMimeType:codemirrorMimeType$5,languageId:languageId$9};var JSX$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$a,type:type$9,group:group$c,extensions:extensions$9,tmScope:tmScope$9,aceMode:aceMode$9,codemirrorMode:codemirrorMode$5,codemirrorMimeType:codemirrorMimeType$5,languageId:languageId$9,'default':JSX});var name$b=\"TypeScript\";var type$a=\"programming\";var color$4=\"#2b7489\";var aliases$3=[\"ts\"];var interpreters$1=[\"deno\",\"ts-node\"];var extensions$a=[\".ts\"];var tmScope$a=\"source.ts\";var aceMode$a=\"typescript\";var codemirrorMode$6=\"javascript\";var codemirrorMimeType$6=\"application/typescript\";var languageId$a=378;var TypeScript={name:name$b,type:type$a,color:color$4,aliases:aliases$3,interpreters:interpreters$1,extensions:extensions$a,tmScope:tmScope$a,aceMode:aceMode$a,codemirrorMode:codemirrorMode$6,codemirrorMimeType:codemirrorMimeType$6,languageId:languageId$a};var TypeScript$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$b,type:type$a,color:color$4,aliases:aliases$3,interpreters:interpreters$1,extensions:extensions$a,tmScope:tmScope$a,aceMode:aceMode$a,codemirrorMode:codemirrorMode$6,codemirrorMimeType:codemirrorMimeType$6,languageId:languageId$a,'default':TypeScript});var name$c=\"TSX\";var type$b=\"programming\";var group$d=\"TypeScript\";var extensions$b=[\".tsx\"];var tmScope$b=\"source.tsx\";var aceMode$b=\"javascript\";var codemirrorMode$7=\"jsx\";var codemirrorMimeType$7=\"text/jsx\";var languageId$b=94901924;var TSX={name:name$c,type:type$b,group:group$d,extensions:extensions$b,tmScope:tmScope$b,aceMode:aceMode$b,codemirrorMode:codemirrorMode$7,codemirrorMimeType:codemirrorMimeType$7,languageId:languageId$b};var TSX$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$c,type:type$b,group:group$d,extensions:extensions$b,tmScope:tmScope$b,aceMode:aceMode$b,codemirrorMode:codemirrorMode$7,codemirrorMimeType:codemirrorMimeType$7,languageId:languageId$b,'default':TSX});var name$d=\"JSON\";var type$c=\"data\";var tmScope$c=\"source.json\";var aceMode$c=\"json\";var codemirrorMode$8=\"javascript\";var codemirrorMimeType$8=\"application/json\";var searchable=false;var extensions$c=[\".json\",\".avsc\",\".geojson\",\".gltf\",\".har\",\".ice\",\".JSON-tmLanguage\",\".jsonl\",\".mcmeta\",\".tfstate\",\".tfstate.backup\",\".topojson\",\".webapp\",\".webmanifest\",\".yy\",\".yyp\"];var filenames$1=[\".arcconfig\",\".htmlhintrc\",\".tern-config\",\".tern-project\",\".watchmanconfig\",\"composer.lock\",\"mcmod.info\"];var languageId$c=174;var _JSON={name:name$d,type:type$c,tmScope:tmScope$c,aceMode:aceMode$c,codemirrorMode:codemirrorMode$8,codemirrorMimeType:codemirrorMimeType$8,searchable:searchable,extensions:extensions$c,filenames:filenames$1,languageId:languageId$c};var _JSON$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$d,type:type$c,tmScope:tmScope$c,aceMode:aceMode$c,codemirrorMode:codemirrorMode$8,codemirrorMimeType:codemirrorMimeType$8,searchable:searchable,extensions:extensions$c,filenames:filenames$1,languageId:languageId$c,'default':_JSON});var name$e=\"JSON with Comments\";var type$d=\"data\";var group$e=\"JSON\";var tmScope$d=\"source.js\";var aceMode$d=\"javascript\";var codemirrorMode$9=\"javascript\";var codemirrorMimeType$9=\"text/javascript\";var aliases$4=[\"jsonc\"];var extensions$d=[\".jsonc\",\".sublime-build\",\".sublime-commands\",\".sublime-completions\",\".sublime-keymap\",\".sublime-macro\",\".sublime-menu\",\".sublime-mousemap\",\".sublime-project\",\".sublime-settings\",\".sublime-theme\",\".sublime-workspace\",\".sublime_metrics\",\".sublime_session\"];var filenames$2=[\".babelrc\",\".eslintrc.json\",\".jscsrc\",\".jshintrc\",\".jslintrc\",\"jsconfig.json\",\"language-configuration.json\",\"tsconfig.json\"];var languageId$d=423;var JSON_with_Comments={name:name$e,type:type$d,group:group$e,tmScope:tmScope$d,aceMode:aceMode$d,codemirrorMode:codemirrorMode$9,codemirrorMimeType:codemirrorMimeType$9,aliases:aliases$4,extensions:extensions$d,filenames:filenames$2,languageId:languageId$d};var JSON_with_Comments$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$e,type:type$d,group:group$e,tmScope:tmScope$d,aceMode:aceMode$d,codemirrorMode:codemirrorMode$9,codemirrorMimeType:codemirrorMimeType$9,aliases:aliases$4,extensions:extensions$d,filenames:filenames$2,languageId:languageId$d,'default':JSON_with_Comments});var name$f=\"JSON5\";var type$e=\"data\";var extensions$e=[\".json5\"];var tmScope$e=\"source.js\";var aceMode$e=\"javascript\";var codemirrorMode$a=\"javascript\";var codemirrorMimeType$a=\"application/json\";var languageId$e=175;var JSON5={name:name$f,type:type$e,extensions:extensions$e,tmScope:tmScope$e,aceMode:aceMode$e,codemirrorMode:codemirrorMode$a,codemirrorMimeType:codemirrorMimeType$a,languageId:languageId$e};var JSON5$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$f,type:type$e,extensions:extensions$e,tmScope:tmScope$e,aceMode:aceMode$e,codemirrorMode:codemirrorMode$a,codemirrorMimeType:codemirrorMimeType$a,languageId:languageId$e,'default':JSON5});var require$$0$6=getCjsExportFromNamespace(JavaScript$1);var require$$1$2=getCjsExportFromNamespace(JSX$1);var require$$2$1=getCjsExportFromNamespace(TypeScript$1);var require$$3$1=getCjsExportFromNamespace(TSX$1);var require$$4=getCjsExportFromNamespace(_JSON$1);var require$$5=getCjsExportFromNamespace(JSON_with_Comments$1);var require$$6=getCjsExportFromNamespace(JSON5$1);const languages$4=[createLanguage(require$$0$6,data=>({since:\"0.0.0\",parsers:[\"babel\",\"flow\"],vscodeLanguageIds:[\"javascript\",\"mongo\"],interpreters:data.interpreters.concat([\"nodejs\"])})),createLanguage(require$$0$6,()=>({name:\"Flow\",since:\"0.0.0\",parsers:[\"babel\",\"flow\"],vscodeLanguageIds:[\"javascript\"],aliases:[],filenames:[],extensions:[\".js.flow\"]})),createLanguage(require$$1$2,()=>({since:\"0.0.0\",parsers:[\"babel\",\"flow\"],vscodeLanguageIds:[\"javascriptreact\"]})),createLanguage(require$$2$1,()=>({since:\"1.4.0\",parsers:[\"typescript\",\"babel-ts\"],vscodeLanguageIds:[\"typescript\"]})),createLanguage(require$$3$1,()=>({since:\"1.4.0\",parsers:[\"typescript\",\"babel-ts\"],vscodeLanguageIds:[\"typescriptreact\"]})),createLanguage(require$$4,()=>({name:\"JSON.stringify\",since:\"1.13.0\",parsers:[\"json-stringify\"],vscodeLanguageIds:[\"json\"],extensions:[],// .json file defaults to json instead of json-stringify\nfilenames:[\"package.json\",\"package-lock.json\",\"composer.json\"]})),createLanguage(require$$4,data=>({since:\"1.5.0\",parsers:[\"json\"],vscodeLanguageIds:[\"json\"],filenames:data.filenames.concat([\".prettierrc\"])})),createLanguage(require$$5,data=>({since:\"1.5.0\",parsers:[\"json\"],vscodeLanguageIds:[\"jsonc\"],filenames:data.filenames.concat([\".eslintrc\"])})),createLanguage(require$$6,()=>({since:\"1.13.0\",parsers:[\"json5\"],vscodeLanguageIds:[\"json5\"]}))];const printers$4={estree:printerEstree,\"estree-json\":printerEstreeJson};var languageJs={languages:languages$4,options:options$5,printers:printers$4};var json$1={\"cjkPattern\":\"[\\\\u02ea-\\\\u02eb\\\\u1100-\\\\u11ff\\\\u2e80-\\\\u2e99\\\\u2e9b-\\\\u2ef3\\\\u2f00-\\\\u2fd5\\\\u3000-\\\\u303f\\\\u3041-\\\\u3096\\\\u3099-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312f\\\\u3131-\\\\u318e\\\\u3190-\\\\u3191\\\\u3196-\\\\u31ba\\\\u31c0-\\\\u31e3\\\\u31f0-\\\\u321e\\\\u322a-\\\\u3247\\\\u3260-\\\\u327e\\\\u328a-\\\\u32b0\\\\u32c0-\\\\u32cb\\\\u32d0-\\\\u3370\\\\u337b-\\\\u337f\\\\u33e0-\\\\u33fe\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fef\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufe10-\\\\ufe1f\\\\ufe30-\\\\ufe6f\\\\uff00-\\\\uffef]|[\\\\ud840-\\\\ud868\\\\ud86a-\\\\ud86c\\\\ud86f-\\\\ud872\\\\ud874-\\\\ud879][\\\\udc00-\\\\udfff]|\\\\ud82c[\\\\udc00-\\\\udd1e\\\\udd50-\\\\udd52\\\\udd64-\\\\udd67]|\\\\ud83c[\\\\ude00\\\\ude50-\\\\ude51]|\\\\ud869[\\\\udc00-\\\\uded6\\\\udf00-\\\\udfff]|\\\\ud86d[\\\\udc00-\\\\udf34\\\\udf40-\\\\udfff]|\\\\ud86e[\\\\udc00-\\\\udc1d\\\\udc20-\\\\udfff]|\\\\ud873[\\\\udc00-\\\\udea1\\\\udeb0-\\\\udfff]|\\\\ud87a[\\\\udc00-\\\\udfe0]|\\\\ud87e[\\\\udc00-\\\\ude1d]\",\"kPattern\":\"[\\\\u1100-\\\\u11ff\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3013-\\\\u301f\\\\u302e-\\\\u3030\\\\u3037\\\\u30fb\\\\u3131-\\\\u318e\\\\u3200-\\\\u321e\\\\u3260-\\\\u327e\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\ufe45-\\\\ufe46\\\\uff61-\\\\uff65\\\\uffa0-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc]\",\"punctuationPattern\":\"[\\\\u0021-\\\\u002f\\\\u003a-\\\\u0040\\\\u005b-\\\\u0060\\\\u007b-\\\\u007e\\\\u00a1\\\\u00a7\\\\u00ab\\\\u00b6-\\\\u00b7\\\\u00bb\\\\u00bf\\\\u037e\\\\u0387\\\\u055a-\\\\u055f\\\\u0589-\\\\u058a\\\\u05be\\\\u05c0\\\\u05c3\\\\u05c6\\\\u05f3-\\\\u05f4\\\\u0609-\\\\u060a\\\\u060c-\\\\u060d\\\\u061b\\\\u061e-\\\\u061f\\\\u066a-\\\\u066d\\\\u06d4\\\\u0700-\\\\u070d\\\\u07f7-\\\\u07f9\\\\u0830-\\\\u083e\\\\u085e\\\\u0964-\\\\u0965\\\\u0970\\\\u09fd\\\\u0a76\\\\u0af0\\\\u0c77\\\\u0c84\\\\u0df4\\\\u0e4f\\\\u0e5a-\\\\u0e5b\\\\u0f04-\\\\u0f12\\\\u0f14\\\\u0f3a-\\\\u0f3d\\\\u0f85\\\\u0fd0-\\\\u0fd4\\\\u0fd9-\\\\u0fda\\\\u104a-\\\\u104f\\\\u10fb\\\\u1360-\\\\u1368\\\\u1400\\\\u166e\\\\u169b-\\\\u169c\\\\u16eb-\\\\u16ed\\\\u1735-\\\\u1736\\\\u17d4-\\\\u17d6\\\\u17d8-\\\\u17da\\\\u1800-\\\\u180a\\\\u1944-\\\\u1945\\\\u1a1e-\\\\u1a1f\\\\u1aa0-\\\\u1aa6\\\\u1aa8-\\\\u1aad\\\\u1b5a-\\\\u1b60\\\\u1bfc-\\\\u1bff\\\\u1c3b-\\\\u1c3f\\\\u1c7e-\\\\u1c7f\\\\u1cc0-\\\\u1cc7\\\\u1cd3\\\\u2010-\\\\u2027\\\\u2030-\\\\u2043\\\\u2045-\\\\u2051\\\\u2053-\\\\u205e\\\\u207d-\\\\u207e\\\\u208d-\\\\u208e\\\\u2308-\\\\u230b\\\\u2329-\\\\u232a\\\\u2768-\\\\u2775\\\\u27c5-\\\\u27c6\\\\u27e6-\\\\u27ef\\\\u2983-\\\\u2998\\\\u29d8-\\\\u29db\\\\u29fc-\\\\u29fd\\\\u2cf9-\\\\u2cfc\\\\u2cfe-\\\\u2cff\\\\u2d70\\\\u2e00-\\\\u2e2e\\\\u2e30-\\\\u2e4f\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3014-\\\\u301f\\\\u3030\\\\u303d\\\\u30a0\\\\u30fb\\\\ua4fe-\\\\ua4ff\\\\ua60d-\\\\ua60f\\\\ua673\\\\ua67e\\\\ua6f2-\\\\ua6f7\\\\ua874-\\\\ua877\\\\ua8ce-\\\\ua8cf\\\\ua8f8-\\\\ua8fa\\\\ua8fc\\\\ua92e-\\\\ua92f\\\\ua95f\\\\ua9c1-\\\\ua9cd\\\\ua9de-\\\\ua9df\\\\uaa5c-\\\\uaa5f\\\\uaade-\\\\uaadf\\\\uaaf0-\\\\uaaf1\\\\uabeb\\\\ufd3e-\\\\ufd3f\\\\ufe10-\\\\ufe19\\\\ufe30-\\\\ufe52\\\\ufe54-\\\\ufe61\\\\ufe63\\\\ufe68\\\\ufe6a-\\\\ufe6b\\\\uff01-\\\\uff03\\\\uff05-\\\\uff0a\\\\uff0c-\\\\uff0f\\\\uff1a-\\\\uff1b\\\\uff1f-\\\\uff20\\\\uff3b-\\\\uff3d\\\\uff3f\\\\uff5b\\\\uff5d\\\\uff5f-\\\\uff65]|\\\\ud800[\\\\udd00-\\\\udd02\\\\udf9f\\\\udfd0]|\\\\ud801[\\\\udd6f]|\\\\ud802[\\\\udc57\\\\udd1f\\\\udd3f\\\\ude50-\\\\ude58\\\\ude7f\\\\udef0-\\\\udef6\\\\udf39-\\\\udf3f\\\\udf99-\\\\udf9c]|\\\\ud803[\\\\udf55-\\\\udf59]|\\\\ud804[\\\\udc47-\\\\udc4d\\\\udcbb-\\\\udcbc\\\\udcbe-\\\\udcc1\\\\udd40-\\\\udd43\\\\udd74-\\\\udd75\\\\uddc5-\\\\uddc8\\\\uddcd\\\\udddb\\\\udddd-\\\\udddf\\\\ude38-\\\\ude3d\\\\udea9]|\\\\ud805[\\\\udc4b-\\\\udc4f\\\\udc5b\\\\udc5d\\\\udcc6\\\\uddc1-\\\\uddd7\\\\ude41-\\\\ude43\\\\ude60-\\\\ude6c\\\\udf3c-\\\\udf3e]|\\\\ud806[\\\\udc3b\\\\udde2\\\\ude3f-\\\\ude46\\\\ude9a-\\\\ude9c\\\\ude9e-\\\\udea2]|\\\\ud807[\\\\udc41-\\\\udc45\\\\udc70-\\\\udc71\\\\udef7-\\\\udef8\\\\udfff]|\\\\ud809[\\\\udc70-\\\\udc74]|\\\\ud81a[\\\\ude6e-\\\\ude6f\\\\udef5\\\\udf37-\\\\udf3b\\\\udf44]|\\\\ud81b[\\\\ude97-\\\\ude9a\\\\udfe2]|\\\\ud82f[\\\\udc9f]|\\\\ud836[\\\\ude87-\\\\ude8b]|\\\\ud83a[\\\\udd5e-\\\\udd5f]\"};const{cjkPattern,kPattern,punctuationPattern}=json$1;const{getLast:getLast$4}=util$1;const INLINE_NODE_TYPES=[\"liquidNode\",\"inlineCode\",\"emphasis\",\"strong\",\"delete\",\"link\",\"linkReference\",\"image\",\"imageReference\",\"footnote\",\"footnoteReference\",\"sentence\",\"whitespace\",\"word\",\"break\",\"inlineMath\"];const INLINE_NODE_WRAPPER_TYPES=INLINE_NODE_TYPES.concat([\"tableCell\",\"paragraph\",\"heading\"]);const kRegex=new RegExp(kPattern);const punctuationRegex=new RegExp(punctuationPattern);/**\n   * split text into whitespaces and words\n   * @param {string} text\n   * @return {Array<{ type: \"whitespace\", value: \" \" | \"\\n\" | \"\" } | { type: \"word\", value: string }>}\n   */function splitText(text,options){const KIND_NON_CJK=\"non-cjk\";const KIND_CJ_LETTER=\"cj-letter\";const KIND_K_LETTER=\"k-letter\";const KIND_CJK_PUNCTUATION=\"cjk-punctuation\";const nodes=[];(options.proseWrap===\"preserve\"?text:text.replace(new RegExp(\"(\".concat(cjkPattern,\")\\n(\").concat(cjkPattern,\")\"),\"g\"),\"$1$2\")).split(/([ \\t\\n]+)/).forEach((token,index,tokens)=>{// whitespace\nif(index%2===1){nodes.push({type:\"whitespace\",value:/\\n/.test(token)?\"\\n\":\" \"});return;}// word separated by whitespace\nif((index===0||index===tokens.length-1)&&token===\"\"){return;}token.split(new RegExp(\"(\".concat(cjkPattern,\")\"))).forEach((innerToken,innerIndex,innerTokens)=>{if((innerIndex===0||innerIndex===innerTokens.length-1)&&innerToken===\"\"){return;}// non-CJK word\nif(innerIndex%2===0){if(innerToken!==\"\"){appendNode({type:\"word\",value:innerToken,kind:KIND_NON_CJK,hasLeadingPunctuation:punctuationRegex.test(innerToken[0]),hasTrailingPunctuation:punctuationRegex.test(getLast$4(innerToken))});}return;}// CJK character\nappendNode(punctuationRegex.test(innerToken)?{type:\"word\",value:innerToken,kind:KIND_CJK_PUNCTUATION,hasLeadingPunctuation:true,hasTrailingPunctuation:true}:{type:\"word\",value:innerToken,kind:kRegex.test(innerToken)?KIND_K_LETTER:KIND_CJ_LETTER,hasLeadingPunctuation:false,hasTrailingPunctuation:false});});});return nodes;function appendNode(node){const lastNode=getLast$4(nodes);if(lastNode&&lastNode.type===\"word\"){if(lastNode.kind===KIND_NON_CJK&&node.kind===KIND_CJ_LETTER&&!lastNode.hasTrailingPunctuation||lastNode.kind===KIND_CJ_LETTER&&node.kind===KIND_NON_CJK&&!node.hasLeadingPunctuation){nodes.push({type:\"whitespace\",value:\" \"});}else if(!isBetween(KIND_NON_CJK,KIND_CJK_PUNCTUATION)&&// disallow leading/trailing full-width whitespace\n![lastNode.value,node.value].some(value=>/\\u3000/.test(value))){nodes.push({type:\"whitespace\",value:\"\"});}}nodes.push(node);function isBetween(kind1,kind2){return lastNode.kind===kind1&&node.kind===kind2||lastNode.kind===kind2&&node.kind===kind1;}}}function getOrderedListItemInfo(orderListItem,originalText){const[,numberText,marker,leadingSpaces]=originalText.slice(orderListItem.position.start.offset,orderListItem.position.end.offset).match(/^\\s*(\\d+)(\\.|\\))(\\s*)/);return{numberText,marker,leadingSpaces};}function hasGitDiffFriendlyOrderedList(node,options){if(!node.ordered){return false;}if(node.children.length<2){return false;}const firstNumber=Number(getOrderedListItemInfo(node.children[0],options.originalText).numberText);const secondNumber=Number(getOrderedListItemInfo(node.children[1],options.originalText).numberText);if(firstNumber===0&&node.children.length>2){const thirdNumber=Number(getOrderedListItemInfo(node.children[2],options.originalText).numberText);return secondNumber===1&&thirdNumber===1;}return secondNumber===1;}// workaround for https://github.com/remarkjs/remark/issues/351\n// leading and trailing newlines are stripped by remark\nfunction getFencedCodeBlockValue(node,originalText){const text=originalText.slice(node.position.start.offset,node.position.end.offset);const leadingSpaceCount=text.match(/^\\s*/)[0].length;const replaceRegex=new RegExp(\"^\\\\s{0,\".concat(leadingSpaceCount,\"}\"));const lineContents=text.split(\"\\n\");const markerStyle=text[leadingSpaceCount];// ` or ~\nconst marker=text.slice(leadingSpaceCount).match(new RegExp(\"^[\".concat(markerStyle,\"]+\")))[0];// https://spec.commonmark.org/0.28/#example-104: Closing fences may be indented by 0-3 spaces\n// https://spec.commonmark.org/0.28/#example-93: The closing code fence must be at least as long as the opening fence\nconst hasEndMarker=new RegExp(\"^\\\\s{0,3}\".concat(marker)).test(lineContents[lineContents.length-1].slice(getIndent(lineContents.length-1)));return lineContents.slice(1,hasEndMarker?-1:undefined).map((x,i)=>x.slice(getIndent(i+1)).replace(replaceRegex,\"\")).join(\"\\n\");function getIndent(lineIndex){return node.position.indent[lineIndex-1]-1;}}function mapAst(ast,handler){return function preorder(node,index,parentStack){parentStack=parentStack||[];const newNode=Object.assign({},handler(node,index,parentStack));if(newNode.children){newNode.children=newNode.children.map((child,index)=>{return preorder(child,index,[newNode].concat(parentStack));});}return newNode;}(ast,null,null);}var utils$6={mapAst,splitText,punctuationPattern,getFencedCodeBlockValue,getOrderedListItemInfo,hasGitDiffFriendlyOrderedList,INLINE_NODE_TYPES,INLINE_NODE_WRAPPER_TYPES};const{builders:{hardline:hardline$b,literalline:literalline$5,concat:concat$f,markAsRoot:markAsRoot$3},utils:{mapDoc:mapDoc$4}}=document;const{getFencedCodeBlockValue:getFencedCodeBlockValue$1}=utils$6;function embed$4(path,print,textToDoc,options){const node=path.getValue();if(node.type===\"code\"&&node.lang!==null){// only look for the first string so as to support [markdown-preview-enhanced](https://shd101wyy.github.io/markdown-preview-enhanced/#/code-chunk)\nconst langMatch=node.lang.match(/^[A-Za-z0-9_-]+/);const lang=langMatch?langMatch[0]:\"\";const parser=getParserName(lang);if(parser){const styleUnit=options.__inJsTemplate?\"~\":\"`\";const style=styleUnit.repeat(Math.max(3,util$1.getMaxContinuousCount(node.value,styleUnit)+1));const doc=textToDoc(getFencedCodeBlockValue$1(node,options.originalText),{parser});return markAsRoot$3(concat$f([style,node.lang,hardline$b,replaceNewlinesWithLiterallines(doc),style]));}}if(node.type===\"yaml\"){return markAsRoot$3(concat$f([\"---\",hardline$b,node.value&&node.value.trim()?replaceNewlinesWithLiterallines(textToDoc(node.value,{parser:\"yaml\"})):\"\",\"---\"]));}// MDX\nswitch(node.type){case\"importExport\":return textToDoc(node.value,{parser:\"babel\"});case\"jsx\":return textToDoc(\"<$>\".concat(node.value,\"</$>\"),{parser:\"__js_expression\",rootMarker:\"mdx\"});}return null;function getParserName(lang){const supportInfo=support.getSupportInfo({plugins:options.plugins});const language=supportInfo.languages.find(language=>language.name.toLowerCase()===lang||language.aliases&&language.aliases.includes(lang)||language.extensions&&language.extensions.find(ext=>ext===\".\".concat(lang)));if(language){return language.parsers[0];}return null;}function replaceNewlinesWithLiterallines(doc){return mapDoc$4(doc,currentDoc=>typeof currentDoc===\"string\"&&currentDoc.includes(\"\\n\")?concat$f(currentDoc.split(/(\\n)/g).map((v,i)=>i%2===0?v:literalline$5)):currentDoc);}}var embed_1$2=embed$4;const pragmas=[\"format\",\"prettier\"];function startWithPragma(text){const pragma=\"@(\".concat(pragmas.join(\"|\"),\")\");const regex=new RegExp([\"<!--\\\\s*\".concat(pragma,\"\\\\s*-->\"),\"<!--.*\\r?\\n[\\\\s\\\\S]*(^|\\n)[^\\\\S\\n]*\".concat(pragma,\"[^\\\\S\\n]*($|\\n)[\\\\s\\\\S]*\\n.*-->\")].join(\"|\"),\"m\");const matched=text.match(regex);return matched&&matched.index===0;}var pragma$4={startWithPragma,hasPragma:text=>startWithPragma(frontMatter(text).content.trimStart()),insertPragma:text=>{const extracted=frontMatter(text);const pragma=\"<!-- @\".concat(pragmas[0],\" -->\");return extracted.frontMatter?\"\".concat(extracted.frontMatter.raw,\"\\n\\n\").concat(pragma,\"\\n\\n\").concat(extracted.content):\"\".concat(pragma,\"\\n\\n\").concat(extracted.content);}};const{getOrderedListItemInfo:getOrderedListItemInfo$1,mapAst:mapAst$1,splitText:splitText$1}=utils$6;// 0x0 ~ 0x10ffff\n// eslint-disable-next-line no-control-regex\nconst isSingleCharRegex=/^([\\u0000-\\uffff]|[\\ud800-\\udbff][\\udc00-\\udfff])$/;function preprocess$2(ast,options){ast=restoreUnescapedCharacter(ast,options);ast=mergeContinuousTexts(ast);ast=transformInlineCode(ast);ast=transformIndentedCodeblockAndMarkItsParentList(ast,options);ast=markAlignedList(ast,options);ast=splitTextIntoSentences(ast,options);ast=transformImportExport(ast);ast=mergeContinuousImportExport(ast);return ast;}function transformImportExport(ast){return mapAst$1(ast,node=>{if(node.type!==\"import\"&&node.type!==\"export\"){return node;}return Object.assign({},node,{type:\"importExport\"});});}function transformInlineCode(ast){return mapAst$1(ast,node=>{if(node.type!==\"inlineCode\"){return node;}return Object.assign({},node,{value:node.value.replace(/\\s+/g,\" \")});});}function restoreUnescapedCharacter(ast,options){return mapAst$1(ast,node=>{return node.type!==\"text\"?node:Object.assign({},node,{value:node.value!==\"*\"&&node.value!==\"_\"&&node.value!==\"$\"&&// handle these cases in printer\nisSingleCharRegex.test(node.value)&&node.position.end.offset-node.position.start.offset!==node.value.length?options.originalText.slice(node.position.start.offset,node.position.end.offset):node.value});});}function mergeContinuousImportExport(ast){return mergeChildren(ast,(prevNode,node)=>prevNode.type===\"importExport\"&&node.type===\"importExport\",(prevNode,node)=>({type:\"importExport\",value:prevNode.value+\"\\n\\n\"+node.value,position:{start:prevNode.position.start,end:node.position.end}}));}function mergeChildren(ast,shouldMerge,mergeNode){return mapAst$1(ast,node=>{if(!node.children){return node;}const children=node.children.reduce((current,child)=>{const lastChild=current[current.length-1];if(lastChild&&shouldMerge(lastChild,child)){current.splice(-1,1,mergeNode(lastChild,child));}else{current.push(child);}return current;},[]);return Object.assign({},node,{children});});}function mergeContinuousTexts(ast){return mergeChildren(ast,(prevNode,node)=>prevNode.type===\"text\"&&node.type===\"text\",(prevNode,node)=>({type:\"text\",value:prevNode.value+node.value,position:{start:prevNode.position.start,end:node.position.end}}));}function splitTextIntoSentences(ast,options){return mapAst$1(ast,(node,index,_ref18)=>{let[parentNode]=_ref18;if(node.type!==\"text\"){return node;}let{value}=node;if(parentNode.type===\"paragraph\"){if(index===0){value=value.trimStart();}if(index===parentNode.children.length-1){value=value.trimEnd();}}return{type:\"sentence\",position:node.position,children:splitText$1(value,options)};});}function transformIndentedCodeblockAndMarkItsParentList(ast,options){return mapAst$1(ast,(node,index,parentStack)=>{if(node.type===\"code\"){// the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it\nconst isIndented=/^\\n?( {4,}|\\t)/.test(options.originalText.slice(node.position.start.offset,node.position.end.offset));node.isIndented=isIndented;if(isIndented){for(let i=0;i<parentStack.length;i++){const parent=parentStack[i];// no need to check checked items\nif(parent.hasIndentedCodeblock){break;}if(parent.type===\"list\"){parent.hasIndentedCodeblock=true;}}}}return node;});}function markAlignedList(ast,options){return mapAst$1(ast,(node,index,parentStack)=>{if(node.type===\"list\"&&node.children.length!==0){// if one of its parents is not aligned, it's not possible to be aligned in sub-lists\nfor(let i=0;i<parentStack.length;i++){const parent=parentStack[i];if(parent.type===\"list\"&&!parent.isAligned){node.isAligned=false;return node;}}node.isAligned=isAligned(node);}return node;});function getListItemStart(listItem){return listItem.children.length===0?-1:listItem.children[0].position.start.column-1;}function isAligned(list){if(!list.ordered){/**\n         * - 123\n         * - 123\n         */return true;}const[firstItem,secondItem]=list.children;const firstInfo=getOrderedListItemInfo$1(firstItem,options.originalText);if(firstInfo.leadingSpaces.length>1){/**\n         * 1.   123\n         *\n         * 1.   123\n         * 1. 123\n         */return true;}const firstStart=getListItemStart(firstItem);if(firstStart===-1){/**\n         * 1.\n         *\n         * 1.\n         * 1.\n         */return false;}if(list.children.length===1){/**\n         * aligned:\n         *\n         * 11. 123\n         *\n         * not aligned:\n         *\n         * 1. 123\n         */return firstStart%options.tabWidth===0;}const secondStart=getListItemStart(secondItem);if(firstStart!==secondStart){/**\n         * 11. 123\n         * 1. 123\n         *\n         * 1. 123\n         * 11. 123\n         */return false;}if(firstStart%options.tabWidth===0){/**\n         * 11. 123\n         * 12. 123\n         */return true;}/**\n       * aligned:\n       *\n       * 11. 123\n       * 1.  123\n       *\n       * not aligned:\n       *\n       * 1. 123\n       * 2. 123\n       */const secondInfo=getOrderedListItemInfo$1(secondItem,options.originalText);return secondInfo.leadingSpaces.length>1;}}var preprocess_1$2=preprocess$2;const{builders:{breakParent:breakParent$4,concat:concat$g,join:join$b,line:line$a,literalline:literalline$6,markAsRoot:markAsRoot$4,hardline:hardline$c,softline:softline$7,ifBreak:ifBreak$7,fill:fill$5,align:align$2,indent:indent$9,group:group$f},utils:{mapDoc:mapDoc$5},printer:{printDocToString:printDocToString$3}}=document;const{getFencedCodeBlockValue:getFencedCodeBlockValue$2,hasGitDiffFriendlyOrderedList:hasGitDiffFriendlyOrderedList$1,splitText:splitText$2,punctuationPattern:punctuationPattern$1,INLINE_NODE_TYPES:INLINE_NODE_TYPES$1,INLINE_NODE_WRAPPER_TYPES:INLINE_NODE_WRAPPER_TYPES$1}=utils$6;const{replaceEndOfLineWith:replaceEndOfLineWith$2}=util$1;const TRAILING_HARDLINE_NODES=[\"importExport\"];const SINGLE_LINE_NODE_TYPES=[\"heading\",\"tableCell\",\"link\"];const SIBLING_NODE_TYPES=[\"listItem\",\"definition\",\"footnoteDefinition\"];function genericPrint$5(path,options,print){const node=path.getValue();if(shouldRemainTheSameContent(path)){return concat$g(splitText$2(options.originalText.slice(node.position.start.offset,node.position.end.offset),options).map(node=>node.type===\"word\"?node.value:node.value===\"\"?\"\":printLine(path,node.value,options)));}switch(node.type){case\"root\":if(node.children.length===0){return\"\";}return concat$g([normalizeDoc(printRoot(path,options,print)),!TRAILING_HARDLINE_NODES.includes(getLastDescendantNode(node).type)?hardline$c:\"\"]);case\"paragraph\":return printChildren$2(path,options,print,{postprocessor:fill$5});case\"sentence\":return printChildren$2(path,options,print);case\"word\":return node.value.replace(/[*$]/g,\"\\\\$&\")// escape all `*` and `$` (math)\n.replace(new RegExp([\"(^|\".concat(punctuationPattern$1,\")(_+)\"),\"(_+)(\".concat(punctuationPattern$1,\"|$)\")].join(\"|\"),\"g\"),(_,text1,underscore1,underscore2,text2)=>(underscore1?\"\".concat(text1).concat(underscore1):\"\".concat(underscore2).concat(text2)).replace(/_/g,\"\\\\_\"));// escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis\ncase\"whitespace\":{const parentNode=path.getParentNode();const index=parentNode.children.indexOf(node);const nextNode=parentNode.children[index+1];const proseWrap=// leading char that may cause different syntax\nnextNode&&/^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(nextNode.value)?\"never\":options.proseWrap;return printLine(path,node.value,{proseWrap});}case\"emphasis\":{const parentNode=path.getParentNode();const index=parentNode.children.indexOf(node);const prevNode=parentNode.children[index-1];const nextNode=parentNode.children[index+1];const hasPrevOrNextWord=// `1*2*3` is considered emphasis but `1_2_3` is not\nprevNode&&prevNode.type===\"sentence\"&&prevNode.children.length>0&&util$1.getLast(prevNode.children).type===\"word\"&&!util$1.getLast(prevNode.children).hasTrailingPunctuation||nextNode&&nextNode.type===\"sentence\"&&nextNode.children.length>0&&nextNode.children[0].type===\"word\"&&!nextNode.children[0].hasLeadingPunctuation;const style=hasPrevOrNextWord||getAncestorNode$2(path,\"emphasis\")?\"*\":\"_\";return concat$g([style,printChildren$2(path,options,print),style]);}case\"strong\":return concat$g([\"**\",printChildren$2(path,options,print),\"**\"]);case\"delete\":return concat$g([\"~~\",printChildren$2(path,options,print),\"~~\"]);case\"inlineCode\":{const backtickCount=util$1.getMinNotPresentContinuousCount(node.value,\"`\");const style=\"`\".repeat(backtickCount||1);const gap=backtickCount?\" \":\"\";return concat$g([style,gap,node.value,gap,style]);}case\"link\":switch(options.originalText[node.position.start.offset]){case\"<\":{const mailto=\"mailto:\";const url=// <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }\nnode.url.startsWith(mailto)&&options.originalText.slice(node.position.start.offset+1,node.position.start.offset+1+mailto.length)!==mailto?node.url.slice(mailto.length):node.url;return concat$g([\"<\",url,\">\"]);}case\"[\":return concat$g([\"[\",printChildren$2(path,options,print),\"](\",printUrl(node.url,\")\"),printTitle(node.title,options),\")\"]);default:return options.originalText.slice(node.position.start.offset,node.position.end.offset);}case\"image\":return concat$g([\"![\",node.alt||\"\",\"](\",printUrl(node.url,\")\"),printTitle(node.title,options),\")\"]);case\"blockquote\":return concat$g([\"> \",align$2(\"> \",printChildren$2(path,options,print))]);case\"heading\":return concat$g([\"#\".repeat(node.depth)+\" \",printChildren$2(path,options,print)]);case\"code\":{if(node.isIndented){// indented code block\nconst alignment=\" \".repeat(4);return align$2(alignment,concat$g([alignment,concat$g(replaceEndOfLineWith$2(node.value,hardline$c))]));}// fenced code block\nconst styleUnit=options.__inJsTemplate?\"~\":\"`\";const style=styleUnit.repeat(Math.max(3,util$1.getMaxContinuousCount(node.value,styleUnit)+1));return concat$g([style,node.lang||\"\",hardline$c,concat$g(replaceEndOfLineWith$2(getFencedCodeBlockValue$2(node,options.originalText),hardline$c)),hardline$c,style]);}case\"yaml\":case\"toml\":return options.originalText.slice(node.position.start.offset,node.position.end.offset);case\"html\":{const parentNode=path.getParentNode();const value=parentNode.type===\"root\"&&util$1.getLast(parentNode.children)===node?node.value.trimEnd():node.value;const isHtmlComment=/^<!--[\\s\\S]*-->$/.test(value);return concat$g(replaceEndOfLineWith$2(value,isHtmlComment?hardline$c:markAsRoot$4(literalline$6)));}case\"list\":{const nthSiblingIndex=getNthListSiblingIndex(node,path.getParentNode());const isGitDiffFriendlyOrderedList=hasGitDiffFriendlyOrderedList$1(node,options);return printChildren$2(path,options,print,{processor:(childPath,index)=>{const prefix=getPrefix();const childNode=childPath.getValue();if(childNode.children.length===2&&childNode.children[1].type===\"html\"&&childNode.children[0].position.start.column!==childNode.children[1].position.start.column){return concat$g([prefix,printListItem(childPath,options,print,prefix)]);}return concat$g([prefix,align$2(\" \".repeat(prefix.length),printListItem(childPath,options,print,prefix))]);function getPrefix(){const rawPrefix=node.ordered?(index===0?node.start:isGitDiffFriendlyOrderedList?1:node.start+index)+(nthSiblingIndex%2===0?\". \":\") \"):nthSiblingIndex%2===0?\"- \":\"* \";return node.isAligned||/* workaround for https://github.com/remarkjs/remark/issues/315 */node.hasIndentedCodeblock?alignListPrefix(rawPrefix,options):rawPrefix;}}});}case\"thematicBreak\":{const counter=getAncestorCounter$1(path,\"list\");if(counter===-1){return\"---\";}const nthSiblingIndex=getNthListSiblingIndex(path.getParentNode(counter),path.getParentNode(counter+1));return nthSiblingIndex%2===0?\"***\":\"---\";}case\"linkReference\":return concat$g([\"[\",printChildren$2(path,options,print),\"]\",node.referenceType===\"full\"?concat$g([\"[\",node.identifier,\"]\"]):node.referenceType===\"collapsed\"?\"[]\":\"\"]);case\"imageReference\":switch(node.referenceType){case\"full\":return concat$g([\"![\",node.alt||\"\",\"][\",node.identifier,\"]\"]);default:return concat$g([\"![\",node.alt,\"]\",node.referenceType===\"collapsed\"?\"[]\":\"\"]);}case\"definition\":{const lineOrSpace=options.proseWrap===\"always\"?line$a:\" \";return group$f(concat$g([concat$g([\"[\",node.identifier,\"]:\"]),indent$9(concat$g([lineOrSpace,printUrl(node.url),node.title===null?\"\":concat$g([lineOrSpace,printTitle(node.title,options,false)])]))]));}case\"footnote\":return concat$g([\"[^\",printChildren$2(path,options,print),\"]\"]);case\"footnoteReference\":return concat$g([\"[^\",node.identifier,\"]\"]);case\"footnoteDefinition\":{const nextNode=path.getParentNode().children[path.getName()+1];const shouldInlineFootnote=node.children.length===1&&node.children[0].type===\"paragraph\"&&(options.proseWrap===\"never\"||options.proseWrap===\"preserve\"&&node.children[0].position.start.line===node.children[0].position.end.line);return concat$g([\"[^\",node.identifier,\"]: \",shouldInlineFootnote?printChildren$2(path,options,print):group$f(concat$g([align$2(\" \".repeat(options.tabWidth),printChildren$2(path,options,print,{processor:(childPath,index)=>{return index===0?group$f(concat$g([softline$7,childPath.call(print)])):childPath.call(print);}})),nextNode&&nextNode.type===\"footnoteDefinition\"?softline$7:\"\"]))]);}case\"table\":return printTable(path,options,print);case\"tableCell\":return printChildren$2(path,options,print);case\"break\":return /\\s/.test(options.originalText[node.position.start.offset])?concat$g([\"  \",markAsRoot$4(literalline$6)]):concat$g([\"\\\\\",hardline$c]);case\"liquidNode\":return concat$g(replaceEndOfLineWith$2(node.value,hardline$c));// MDX\ncase\"importExport\":case\"jsx\":return node.value;// fallback to the original text if multiparser failed\ncase\"math\":return concat$g([\"$$\",hardline$c,node.value?concat$g([concat$g(replaceEndOfLineWith$2(node.value,hardline$c)),hardline$c]):\"\",\"$$\"]);case\"inlineMath\":{// remark-math trims content but we don't want to remove whitespaces\n// since it's very possible that it's recognized as math accidentally\nreturn options.originalText.slice(options.locStart(node),options.locEnd(node));}case\"tableRow\":// handled in \"table\"\ncase\"listItem\":// handled in \"list\"\ndefault:throw new Error(\"Unknown markdown type \".concat(JSON.stringify(node.type)));}}function printListItem(path,options,print,listPrefix){const node=path.getValue();const prefix=node.checked===null?\"\":node.checked?\"[x] \":\"[ ] \";return concat$g([prefix,printChildren$2(path,options,print,{processor:(childPath,index)=>{if(index===0&&childPath.getValue().type!==\"list\"){return align$2(\" \".repeat(prefix.length),childPath.call(print));}const alignment=\" \".repeat(clamp(options.tabWidth-listPrefix.length,0,3)// 4+ will cause indented code block\n);return concat$g([alignment,align$2(alignment,childPath.call(print))]);}})]);}function alignListPrefix(prefix,options){const additionalSpaces=getAdditionalSpaces();return prefix+\" \".repeat(additionalSpaces>=4?0:additionalSpaces// 4+ will cause indented code block\n);function getAdditionalSpaces(){const restSpaces=prefix.length%options.tabWidth;return restSpaces===0?0:options.tabWidth-restSpaces;}}function getNthListSiblingIndex(node,parentNode){return getNthSiblingIndex(node,parentNode,siblingNode=>siblingNode.ordered===node.ordered);}function getNthSiblingIndex(node,parentNode,condition){condition=condition||(()=>true);let index=-1;for(const childNode of parentNode.children){if(childNode.type===node.type&&condition(childNode)){index++;}else{index=-1;}if(childNode===node){return index;}}}function getAncestorCounter$1(path,typeOrTypes){const types=[].concat(typeOrTypes);let counter=-1;let ancestorNode;while(ancestorNode=path.getParentNode(++counter)){if(types.includes(ancestorNode.type)){return counter;}}return-1;}function getAncestorNode$2(path,typeOrTypes){const counter=getAncestorCounter$1(path,typeOrTypes);return counter===-1?null:path.getParentNode(counter);}function printLine(path,value,options){if(options.proseWrap===\"preserve\"&&value===\"\\n\"){return hardline$c;}const isBreakable=options.proseWrap===\"always\"&&!getAncestorNode$2(path,SINGLE_LINE_NODE_TYPES);return value!==\"\"?isBreakable?line$a:\" \":isBreakable?softline$7:\"\";}function printTable(path,options,print){const hardlineWithoutBreakParent=hardline$c.parts[0];const node=path.getValue();const contents=[];// { [rowIndex: number]: { [columnIndex: number]: string } }\npath.map(rowPath=>{const rowContents=[];rowPath.map(cellPath=>{rowContents.push(printDocToString$3(cellPath.call(print),options).formatted);},\"children\");contents.push(rowContents);},\"children\");// Get the width of each column\nconst columnMaxWidths=contents.reduce((currentWidths,rowContents)=>currentWidths.map((width,columnIndex)=>Math.max(width,util$1.getStringWidth(rowContents[columnIndex]))),contents[0].map(()=>3)// minimum width = 3 (---, :--, :-:, --:)\n);const alignedTable=join$b(hardlineWithoutBreakParent,[printRow(contents[0]),printSeparator(),join$b(hardlineWithoutBreakParent,contents.slice(1).map(rowContents=>printRow(rowContents)))]);if(options.proseWrap!==\"never\"){return concat$g([breakParent$4,alignedTable]);}// Only if the --prose-wrap never is set and it exceeds the print width.\nconst compactTable=join$b(hardlineWithoutBreakParent,[printRow(contents[0],/* isCompact */true),printSeparator(/* isCompact */true),join$b(hardlineWithoutBreakParent,contents.slice(1).map(rowContents=>printRow(rowContents,/* isCompact */true)))]);return concat$g([breakParent$4,group$f(ifBreak$7(compactTable,alignedTable))]);function printSeparator(isCompact){return concat$g([\"| \",join$b(\" | \",columnMaxWidths.map((width,index)=>{const spaces=isCompact?3:width;switch(node.align[index]){case\"left\":return\":\"+\"-\".repeat(spaces-1);case\"right\":return\"-\".repeat(spaces-1)+\":\";case\"center\":return\":\"+\"-\".repeat(spaces-2)+\":\";default:return\"-\".repeat(spaces);}})),\" |\"]);}function printRow(rowContents,isCompact){return concat$g([\"| \",join$b(\" | \",isCompact?rowContents:rowContents.map((rowContent,columnIndex)=>{switch(node.align[columnIndex]){case\"right\":return alignRight(rowContent,columnMaxWidths[columnIndex]);case\"center\":return alignCenter(rowContent,columnMaxWidths[columnIndex]);default:return alignLeft(rowContent,columnMaxWidths[columnIndex]);}})),\" |\"]);}function alignLeft(text,width){const spaces=width-util$1.getStringWidth(text);return concat$g([text,\" \".repeat(spaces)]);}function alignRight(text,width){const spaces=width-util$1.getStringWidth(text);return concat$g([\" \".repeat(spaces),text]);}function alignCenter(text,width){const spaces=width-util$1.getStringWidth(text);const left=Math.floor(spaces/2);const right=spaces-left;return concat$g([\" \".repeat(left),text,\" \".repeat(right)]);}}function printRoot(path,options,print){/** @typedef {{ index: number, offset: number }} IgnorePosition */ /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */const ignoreRanges=[];/** @type {IgnorePosition | null} */let ignoreStart=null;const{children}=path.getValue();children.forEach((childNode,index)=>{switch(isPrettierIgnore$1(childNode)){case\"start\":if(ignoreStart===null){ignoreStart={index,offset:childNode.position.end.offset};}break;case\"end\":if(ignoreStart!==null){ignoreRanges.push({start:ignoreStart,end:{index,offset:childNode.position.start.offset}});ignoreStart=null;}break;}});return printChildren$2(path,options,print,{processor:(childPath,index)=>{if(ignoreRanges.length!==0){const ignoreRange=ignoreRanges[0];if(index===ignoreRange.start.index){return concat$g([children[ignoreRange.start.index].value,options.originalText.slice(ignoreRange.start.offset,ignoreRange.end.offset),children[ignoreRange.end.index].value]);}if(ignoreRange.start.index<index&&index<ignoreRange.end.index){return false;}if(index===ignoreRange.end.index){ignoreRanges.shift();return false;}}return childPath.call(print);}});}function printChildren$2(path,options,print,events){events=events||{};const postprocessor=events.postprocessor||concat$g;const processor=events.processor||(childPath=>childPath.call(print));const node=path.getValue();const parts=[];let lastChildNode;path.map((childPath,index)=>{const childNode=childPath.getValue();const result=processor(childPath,index);if(result!==false){const data={parts,prevNode:lastChildNode,parentNode:node,options};if(!shouldNotPrePrintHardline(childNode,data)){parts.push(hardline$c);if(lastChildNode&&TRAILING_HARDLINE_NODES.includes(lastChildNode.type)){if(shouldPrePrintTripleHardline(childNode,data)){parts.push(hardline$c);}}else{if(shouldPrePrintDoubleHardline(childNode,data)||shouldPrePrintTripleHardline(childNode,data)){parts.push(hardline$c);}if(shouldPrePrintTripleHardline(childNode,data)){parts.push(hardline$c);}}}parts.push(result);lastChildNode=childNode;}},\"children\");return postprocessor(parts);}function getLastDescendantNode(node){let current=node;while(current.children&&current.children.length!==0){current=current.children[current.children.length-1];}return current;}/** @return {false | 'next' | 'start' | 'end'} */function isPrettierIgnore$1(node){if(node.type!==\"html\"){return false;}const match=node.value.match(/^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/);return match===null?false:match[1]?match[1]:\"next\";}function shouldNotPrePrintHardline(node,data){const isFirstNode=data.parts.length===0;const isInlineNode=INLINE_NODE_TYPES$1.includes(node.type);const isInlineHTML=node.type===\"html\"&&INLINE_NODE_WRAPPER_TYPES$1.includes(data.parentNode.type);return isFirstNode||isInlineNode||isInlineHTML;}function shouldPrePrintDoubleHardline(node,data){const isSequence=(data.prevNode&&data.prevNode.type)===node.type;const isSiblingNode=isSequence&&SIBLING_NODE_TYPES.includes(node.type);const isInTightListItem=data.parentNode.type===\"listItem\"&&!data.parentNode.loose;const isPrevNodeLooseListItem=data.prevNode&&data.prevNode.type===\"listItem\"&&data.prevNode.loose;const isPrevNodePrettierIgnore=isPrettierIgnore$1(data.prevNode)===\"next\";const isBlockHtmlWithoutBlankLineBetweenPrevHtml=node.type===\"html\"&&data.prevNode&&data.prevNode.type===\"html\"&&data.prevNode.position.end.line+1===node.position.start.line;const isHtmlDirectAfterListItem=node.type===\"html\"&&data.parentNode.type===\"listItem\"&&data.prevNode&&data.prevNode.type===\"paragraph\"&&data.prevNode.position.end.line+1===node.position.start.line;return isPrevNodeLooseListItem||!(isSiblingNode||isInTightListItem||isPrevNodePrettierIgnore||isBlockHtmlWithoutBlankLineBetweenPrevHtml||isHtmlDirectAfterListItem);}function shouldPrePrintTripleHardline(node,data){const isPrevNodeList=data.prevNode&&data.prevNode.type===\"list\";const isIndentedCode=node.type===\"code\"&&node.isIndented;return isPrevNodeList&&isIndentedCode;}function shouldRemainTheSameContent(path){const ancestorNode=getAncestorNode$2(path,[\"linkReference\",\"imageReference\"]);return ancestorNode&&(ancestorNode.type!==\"linkReference\"||ancestorNode.referenceType!==\"full\");}function normalizeDoc(doc){return mapDoc$5(doc,currentDoc=>{if(!currentDoc.parts){return currentDoc;}if(currentDoc.type===\"concat\"&&currentDoc.parts.length===1){return currentDoc.parts[0];}const parts=currentDoc.parts.reduce((parts,part)=>{if(part.type===\"concat\"){parts.push(...part.parts);}else if(part!==\"\"){parts.push(part);}return parts;},[]);return Object.assign({},currentDoc,{parts:normalizeParts$2(parts)});});}function printUrl(url,dangerousCharOrChars){const dangerousChars=[\" \"].concat(dangerousCharOrChars||[]);return new RegExp(dangerousChars.map(x=>\"\\\\\".concat(x)).join(\"|\")).test(url)?\"<\".concat(url,\">\"):url;}function printTitle(title,options,printSpace){if(printSpace==null){printSpace=true;}if(!title){return\"\";}if(printSpace){return\" \"+printTitle(title,options,false);}if(title.includes('\"')&&title.includes(\"'\")&&!title.includes(\")\")){return\"(\".concat(title,\")\");// avoid escaped quotes\n}// faster than using RegExps: https://jsperf.com/performance-of-match-vs-split\nconst singleCount=title.split(\"'\").length-1;const doubleCount=title.split('\"').length-1;const quote=singleCount>doubleCount?'\"':doubleCount>singleCount?\"'\":options.singleQuote?\"'\":'\"';title=title.replace(new RegExp(\"(\".concat(quote,\")\"),\"g\"),\"\\\\$1\");return\"\".concat(quote).concat(title).concat(quote);}function normalizeParts$2(parts){return parts.reduce((current,part)=>{const lastPart=util$1.getLast(current);if(typeof lastPart===\"string\"&&typeof part===\"string\"){current.splice(-1,1,lastPart+part);}else{current.push(part);}return current;},[]);}function clamp(value,min,max){return value<min?min:value>max?max:value;}function clean$6(ast,newObj,parent){delete newObj.position;delete newObj.raw;// front-matter\n// for codeblock\nif(ast.type===\"code\"||ast.type===\"yaml\"||ast.type===\"import\"||ast.type===\"export\"||ast.type===\"jsx\"){delete newObj.value;}if(ast.type===\"list\"){delete newObj.isAligned;}// texts can be splitted or merged\nif(ast.type===\"text\"){return null;}if(ast.type===\"inlineCode\"){newObj.value=ast.value.replace(/[ \\t\\n]+/g,\" \");}// for insert pragma\nif(parent&&parent.type===\"root\"&&parent.children.length>0&&(parent.children[0]===ast||(parent.children[0].type===\"yaml\"||parent.children[0].type===\"toml\")&&parent.children[1]===ast)&&ast.type===\"html\"&&pragma$4.startWithPragma(ast.value)){return null;}}function hasPrettierIgnore$6(path){const index=+path.getName();if(index===0){return false;}const prevNode=path.getParentNode().children[index-1];return isPrettierIgnore$1(prevNode)===\"next\";}var printerMarkdown={preprocess:preprocess_1$2,print:genericPrint$5,embed:embed_1$2,massageAstNode:clean$6,hasPrettierIgnore:hasPrettierIgnore$6,insertPragma:pragma$4.insertPragma};var options$6={proseWrap:commonOptions.proseWrap,singleQuote:commonOptions.singleQuote};var name$g=\"Markdown\";var type$f=\"prose\";var aliases$5=[\"pandoc\"];var aceMode$f=\"markdown\";var codemirrorMode$b=\"gfm\";var codemirrorMimeType$b=\"text/x-gfm\";var wrap=true;var extensions$f=[\".md\",\".markdown\",\".mdown\",\".mdwn\",\".mdx\",\".mkd\",\".mkdn\",\".mkdown\",\".ronn\",\".workbook\"];var filenames$3=[\"contents.lr\"];var tmScope$f=\"source.gfm\";var languageId$f=222;var Markdown={name:name$g,type:type$f,aliases:aliases$5,aceMode:aceMode$f,codemirrorMode:codemirrorMode$b,codemirrorMimeType:codemirrorMimeType$b,wrap:wrap,extensions:extensions$f,filenames:filenames$3,tmScope:tmScope$f,languageId:languageId$f};var Markdown$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$g,type:type$f,aliases:aliases$5,aceMode:aceMode$f,codemirrorMode:codemirrorMode$b,codemirrorMimeType:codemirrorMimeType$b,wrap:wrap,extensions:extensions$f,filenames:filenames$3,tmScope:tmScope$f,languageId:languageId$f,'default':Markdown});var require$$0$7=getCjsExportFromNamespace(Markdown$1);const languages$5=[createLanguage(require$$0$7,data=>({since:\"1.8.0\",parsers:[\"markdown\"],vscodeLanguageIds:[\"markdown\"],filenames:data.filenames.concat([\"README\"]),extensions:data.extensions.filter(extension=>extension!==\".mdx\")})),createLanguage(require$$0$7,()=>({name:\"MDX\",since:\"1.15.0\",parsers:[\"mdx\"],vscodeLanguageIds:[\"mdx\"],filenames:[],extensions:[\".mdx\"]}))];const printers$5={mdast:printerMarkdown};var languageMarkdown={languages:languages$5,options:options$6,printers:printers$5};function isPragma(text){return /^\\s*@(prettier|format)\\s*$/.test(text);}function hasPragma$4(text){return /^\\s*#[^\\n\\S]*@(prettier|format)\\s*?(\\n|$)/.test(text);}function insertPragma$8(text){return\"# @format\\n\\n\".concat(text);}var pragma$5={isPragma,hasPragma:hasPragma$4,insertPragma:insertPragma$8};const{getLast:getLast$5}=util$1;function getAncestorCount(path,filter){let counter=0;const pathStackLength=path.stack.length-1;for(let i=0;i<pathStackLength;i++){const value=path.stack[i];if(isNode(value)&&filter(value)){counter++;}}return counter;}/**\n   * @param {any} value\n   * @param {string[]=} types\n   */function isNode(value,types){return value&&typeof value.type===\"string\"&&(!types||types.includes(value.type));}function mapNode(node,callback,parent){return callback(\"children\"in node?Object.assign({},node,{children:node.children.map(childNode=>mapNode(childNode,callback,node))}):node,parent);}function defineShortcut(x,key,getter){Object.defineProperty(x,key,{get:getter,enumerable:false});}function isNextLineEmpty$5(node,text){let newlineCount=0;const textLength=text.length;for(let i=node.position.end.offset-1;i<textLength;i++){const char=text[i];if(char===\"\\n\"){newlineCount++;}if(newlineCount===1&&/\\S/.test(char)){return false;}if(newlineCount===2){return true;}}return false;}function isLastDescendantNode(path){const node=path.getValue();switch(node.type){case\"tag\":case\"anchor\":case\"comment\":return false;}const pathStackLength=path.stack.length;for(let i=1;i<pathStackLength;i++){const item=path.stack[i];const parentItem=path.stack[i-1];if(Array.isArray(parentItem)&&typeof item===\"number\"&&item!==parentItem.length-1){return false;}}return true;}function getLastDescendantNode$1(node){return\"children\"in node&&node.children.length!==0?getLastDescendantNode$1(getLast$5(node.children)):node;}function isPrettierIgnore$2(comment){return comment.value.trim()===\"prettier-ignore\";}function hasPrettierIgnore$7(path){const node=path.getValue();if(node.type===\"documentBody\"){const document=path.getParentNode();return hasEndComments(document.head)&&isPrettierIgnore$2(getLast$5(document.head.endComments));}return hasLeadingComments(node)&&isPrettierIgnore$2(getLast$5(node.leadingComments));}function isEmptyNode(node){return(!node.children||node.children.length===0)&&!hasComments(node);}function hasComments(node){return hasLeadingComments(node)||hasMiddleComments(node)||hasIndicatorComment(node)||hasTrailingComment$2(node)||hasEndComments(node);}function hasLeadingComments(node){return node&&node.leadingComments&&node.leadingComments.length!==0;}function hasMiddleComments(node){return node&&node.middleComments&&node.middleComments.length!==0;}function hasIndicatorComment(node){return node&&node.indicatorComment;}function hasTrailingComment$2(node){return node&&node.trailingComment;}function hasEndComments(node){return node&&node.endComments&&node.endComments.length!==0;}/**\n   * \" a   b c   d e   f \" -> [\" a   b\", \"c   d\", \"e   f \"]\n   */function splitWithSingleSpace(text){const parts=[];let lastPart=undefined;for(const part of text.split(/( +)/g)){if(part!==\" \"){if(lastPart===\" \"){parts.push(part);}else{parts.push((parts.pop()||\"\")+part);}}else if(lastPart===undefined){parts.unshift(\"\");}lastPart=part;}if(lastPart===\" \"){parts.push((parts.pop()||\"\")+\" \");}if(parts[0]===\"\"){parts.shift();parts.unshift(\" \"+(parts.shift()||\"\"));}return parts;}function getFlowScalarLineContents(nodeType,content,options){const rawLineContents=content.split(\"\\n\").map((lineContent,index,lineContents)=>index===0&&index===lineContents.length-1?lineContent:index!==0&&index!==lineContents.length-1?lineContent.trim():index===0?lineContent.trimEnd():lineContent.trimStart());if(options.proseWrap===\"preserve\"){return rawLineContents.map(lineContent=>lineContent.length===0?[]:[lineContent]);}return rawLineContents.map(lineContent=>lineContent.length===0?[]:splitWithSingleSpace(lineContent)).reduce((reduced,lineContentWords,index)=>index!==0&&rawLineContents[index-1].length!==0&&lineContentWords.length!==0&&!(// trailing backslash in quoteDouble should be preserved\nnodeType===\"quoteDouble\"&&getLast$5(getLast$5(reduced)).endsWith(\"\\\\\"))?reduced.concat([reduced.pop().concat(lineContentWords)]):reduced.concat([lineContentWords]),[]).map(lineContentWords=>options.proseWrap===\"never\"?[lineContentWords.join(\" \")]:lineContentWords);}function getBlockValueLineContents(node,_ref19){let{parentIndent,isLastDescendant,options}=_ref19;const content=node.position.start.line===node.position.end.line?\"\":options.originalText.slice(node.position.start.offset,node.position.end.offset)// exclude open line `>` or `|`\n.match(/^[^\\n]*?\\n([\\s\\S]*)$/)[1];const leadingSpaceCount=node.indent===null?(match=>match?match[1].length:Infinity)(content.match(/^( *)\\S/m)):node.indent-1+parentIndent;const rawLineContents=content.split(\"\\n\").map(lineContent=>lineContent.slice(leadingSpaceCount));if(options.proseWrap===\"preserve\"||node.type===\"blockLiteral\"){return removeUnnecessaryTrailingNewlines(rawLineContents.map(lineContent=>lineContent.length===0?[]:[lineContent]));}return removeUnnecessaryTrailingNewlines(rawLineContents.map(lineContent=>lineContent.length===0?[]:splitWithSingleSpace(lineContent)).reduce((reduced,lineContentWords,index)=>index!==0&&rawLineContents[index-1].length!==0&&lineContentWords.length!==0&&!/^\\s/.test(lineContentWords[0])&&!/^\\s|\\s$/.test(getLast$5(reduced))?reduced.concat([reduced.pop().concat(lineContentWords)]):reduced.concat([lineContentWords]),[]).map(lineContentWords=>lineContentWords.reduce((reduced,word)=>// disallow trailing spaces\nreduced.length!==0&&/\\s$/.test(getLast$5(reduced))?reduced.concat(reduced.pop()+\" \"+word):reduced.concat(word),[])).map(lineContentWords=>options.proseWrap===\"never\"?[lineContentWords.join(\" \")]:lineContentWords));function removeUnnecessaryTrailingNewlines(lineContents){if(node.chomping===\"keep\"){return getLast$5(lineContents).length===0?lineContents.slice(0,-1):lineContents;}let trailingNewlineCount=0;for(let i=lineContents.length-1;i>=0;i--){if(lineContents[i].length===0){trailingNewlineCount++;}else{break;}}return trailingNewlineCount===0?lineContents:trailingNewlineCount>=2&&!isLastDescendant?// next empty line\nlineContents.slice(0,-(trailingNewlineCount-1)):lineContents.slice(0,-trailingNewlineCount);}}var utils$7={getLast:getLast$5,getAncestorCount,isNode,isEmptyNode,mapNode,defineShortcut,isNextLineEmpty:isNextLineEmpty$5,isLastDescendantNode,getBlockValueLineContents,getFlowScalarLineContents,getLastDescendantNode:getLastDescendantNode$1,hasPrettierIgnore:hasPrettierIgnore$7,hasLeadingComments,hasMiddleComments,hasIndicatorComment,hasTrailingComment:hasTrailingComment$2,hasEndComments};const{insertPragma:insertPragma$9,isPragma:isPragma$1}=pragma$5;const{getAncestorCount:getAncestorCount$1,getBlockValueLineContents:getBlockValueLineContents$1,getFlowScalarLineContents:getFlowScalarLineContents$1,getLast:getLast$6,getLastDescendantNode:getLastDescendantNode$2,hasLeadingComments:hasLeadingComments$1,hasMiddleComments:hasMiddleComments$1,hasIndicatorComment:hasIndicatorComment$1,hasTrailingComment:hasTrailingComment$3,hasEndComments:hasEndComments$1,hasPrettierIgnore:hasPrettierIgnore$8,isLastDescendantNode:isLastDescendantNode$1,isNextLineEmpty:isNextLineEmpty$6,isNode:isNode$1,isEmptyNode:isEmptyNode$1,defineShortcut:defineShortcut$1,mapNode:mapNode$1}=utils$7;const docBuilders$2=document.builders;const{conditionalGroup:conditionalGroup$2,breakParent:breakParent$5,concat:concat$h,dedent:dedent$3,dedentToRoot:dedentToRoot$3,fill:fill$6,group:group$g,hardline:hardline$d,ifBreak:ifBreak$8,join:join$c,line:line$b,lineSuffix:lineSuffix$2,literalline:literalline$7,markAsRoot:markAsRoot$5,softline:softline$8}=docBuilders$2;const{replaceEndOfLineWith:replaceEndOfLineWith$3}=util$1;function preprocess$3(ast){return mapNode$1(ast,defineShortcuts);}function defineShortcuts(node){switch(node.type){case\"document\":defineShortcut$1(node,\"head\",()=>node.children[0]);defineShortcut$1(node,\"body\",()=>node.children[1]);break;case\"documentBody\":case\"sequenceItem\":case\"flowSequenceItem\":case\"mappingKey\":case\"mappingValue\":defineShortcut$1(node,\"content\",()=>node.children[0]);break;case\"mappingItem\":case\"flowMappingItem\":defineShortcut$1(node,\"key\",()=>node.children[0]);defineShortcut$1(node,\"value\",()=>node.children[1]);break;}return node;}function genericPrint$6(path,options,print){const node=path.getValue();const parentNode=path.getParentNode();const tag=!node.tag?\"\":path.call(print,\"tag\");const anchor=!node.anchor?\"\":path.call(print,\"anchor\");const nextEmptyLine=isNode$1(node,[\"mapping\",\"sequence\",\"comment\",\"directive\",\"mappingItem\",\"sequenceItem\"])&&!isLastDescendantNode$1(path)?printNextEmptyLine(path,options.originalText):\"\";return concat$h([node.type!==\"mappingValue\"&&hasLeadingComments$1(node)?concat$h([join$c(hardline$d,path.map(print,\"leadingComments\")),hardline$d]):\"\",tag,tag&&anchor?\" \":\"\",anchor,tag||anchor?isNode$1(node,[\"sequence\",\"mapping\"])&&!hasMiddleComments$1(node)?hardline$d:\" \":\"\",hasMiddleComments$1(node)?concat$h([node.middleComments.length===1?\"\":hardline$d,join$c(hardline$d,path.map(print,\"middleComments\")),hardline$d]):\"\",hasPrettierIgnore$8(path)?concat$h(replaceEndOfLineWith$3(options.originalText.slice(node.position.start.offset,node.position.end.offset),literalline$7)):group$g(_print(node,parentNode,path,options,print)),hasTrailingComment$3(node)&&!isNode$1(node,[\"document\",\"documentHead\"])?lineSuffix$2(concat$h([node.type===\"mappingValue\"&&!node.content?\"\":\" \",parentNode.type===\"mappingKey\"&&path.getParentNode(2).type===\"mapping\"&&isInlineNode(node)?\"\":breakParent$5,path.call(print,\"trailingComment\")])):\"\",nextEmptyLine,hasEndComments$1(node)&&!isNode$1(node,[\"documentHead\",\"documentBody\"])?align$3(node.type===\"sequenceItem\"?2:0,concat$h([hardline$d,join$c(hardline$d,path.map(print,\"endComments\"))])):\"\"]);}function _print(node,parentNode,path,options,print){switch(node.type){case\"root\":return concat$h([join$c(hardline$d,path.map((childPath,index)=>{const document=node.children[index];const nextDocument=node.children[index+1];return concat$h([print(childPath),shouldPrintDocumentEndMarker(document,nextDocument)?concat$h([hardline$d,\"...\",hasTrailingComment$3(document)?concat$h([\" \",path.call(print,\"trailingComment\")]):\"\"]):!nextDocument||hasTrailingComment$3(nextDocument.head)?\"\":concat$h([hardline$d,\"---\"])]);},\"children\")),node.children.length===0||(lastDescendantNode=>isNode$1(lastDescendantNode,[\"blockLiteral\",\"blockFolded\"])&&lastDescendantNode.chomping===\"keep\")(getLastDescendantNode$2(node))?\"\":hardline$d]);case\"document\":{const nextDocument=parentNode.children[path.getName()+1];return join$c(hardline$d,[shouldPrintDocumentHeadEndMarker(node,nextDocument,parentNode,options)===\"head\"?join$c(hardline$d,[node.head.children.length===0&&node.head.endComments.length===0?\"\":path.call(print,\"head\"),concat$h([\"---\",hasTrailingComment$3(node.head)?concat$h([\" \",path.call(print,\"head\",\"trailingComment\")]):\"\"])].filter(Boolean)):\"\",shouldPrintDocumentBody(node)?path.call(print,\"body\"):\"\"].filter(Boolean));}case\"documentHead\":return join$c(hardline$d,[].concat(path.map(print,\"children\"),path.map(print,\"endComments\")));case\"documentBody\":{const children=join$c(hardline$d,path.map(print,\"children\")).parts;const endComments=join$c(hardline$d,path.map(print,\"endComments\")).parts;const separator=children.length===0||endComments.length===0?\"\":(lastDescendantNode=>isNode$1(lastDescendantNode,[\"blockFolded\",\"blockLiteral\"])?lastDescendantNode.chomping===\"keep\"?// there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)\n\"\":// an extra newline for better readability\nconcat$h([hardline$d,hardline$d]):hardline$d)(getLastDescendantNode$2(node));return concat$h([].concat(children,separator,endComments));}case\"directive\":return concat$h([\"%\",join$c(\" \",[node.name].concat(node.parameters))]);case\"comment\":return concat$h([\"#\",node.value]);case\"alias\":return concat$h([\"*\",node.value]);case\"tag\":return options.originalText.slice(node.position.start.offset,node.position.end.offset);case\"anchor\":return concat$h([\"&\",node.value]);case\"plain\":return printFlowScalarContent(node.type,options.originalText.slice(node.position.start.offset,node.position.end.offset),options);case\"quoteDouble\":case\"quoteSingle\":{const singleQuote=\"'\";const doubleQuote='\"';const raw=options.originalText.slice(node.position.start.offset+1,node.position.end.offset-1);if(node.type===\"quoteSingle\"&&raw.includes(\"\\\\\")||node.type===\"quoteDouble\"&&/\\\\[^\"]/.test(raw)){// only quoteDouble can use escape chars\n// and quoteSingle do not need to escape backslashes\nconst originalQuote=node.type===\"quoteDouble\"?doubleQuote:singleQuote;return concat$h([originalQuote,printFlowScalarContent(node.type,raw,options),originalQuote]);}else if(raw.includes(doubleQuote)){return concat$h([singleQuote,printFlowScalarContent(node.type,node.type===\"quoteDouble\"?raw// double quote needs to be escaped by backslash in quoteDouble\n.replace(/\\\\\"/g,doubleQuote).replace(/'/g,singleQuote.repeat(2)):raw,options),singleQuote]);}if(raw.includes(singleQuote)){return concat$h([doubleQuote,printFlowScalarContent(node.type,node.type===\"quoteSingle\"?// single quote needs to be escaped by 2 single quotes in quoteSingle\nraw.replace(/''/g,singleQuote):raw,options),doubleQuote]);}const quote=options.singleQuote?singleQuote:doubleQuote;return concat$h([quote,printFlowScalarContent(node.type,raw,options),quote]);}case\"blockFolded\":case\"blockLiteral\":{const parentIndent=getAncestorCount$1(path,ancestorNode=>isNode$1(ancestorNode,[\"sequence\",\"mapping\"]));const isLastDescendant=isLastDescendantNode$1(path);return concat$h([node.type===\"blockFolded\"?\">\":\"|\",node.indent===null?\"\":node.indent.toString(),node.chomping===\"clip\"?\"\":node.chomping===\"keep\"?\"+\":\"-\",hasIndicatorComment$1(node)?concat$h([\" \",path.call(print,\"indicatorComment\")]):\"\",(node.indent===null?dedent$3:dedentToRoot$3)(align$3(node.indent===null?options.tabWidth:node.indent-1+parentIndent,concat$h(getBlockValueLineContents$1(node,{parentIndent,isLastDescendant,options}).reduce((reduced,lineWords,index,lineContents)=>reduced.concat(index===0?hardline$d:\"\",fill$6(join$c(line$b,lineWords).parts),index!==lineContents.length-1?lineWords.length===0?hardline$d:markAsRoot$5(literalline$7):node.chomping===\"keep\"&&isLastDescendant?lineWords.length===0?dedentToRoot$3(hardline$d):dedentToRoot$3(literalline$7):\"\"),[]))))]);}case\"sequence\":return join$c(hardline$d,path.map(print,\"children\"));case\"sequenceItem\":return concat$h([\"- \",align$3(2,!node.content?\"\":path.call(print,\"content\"))]);case\"mappingKey\":return!node.content?\"\":path.call(print,\"content\");case\"mappingValue\":return!node.content?\"\":path.call(print,\"content\");case\"mapping\":return join$c(hardline$d,path.map(print,\"children\"));case\"mappingItem\":case\"flowMappingItem\":{const isEmptyMappingKey=isEmptyNode$1(node.key);const isEmptyMappingValue=isEmptyNode$1(node.value);if(isEmptyMappingKey&&isEmptyMappingValue){return concat$h([\": \"]);}const key=path.call(print,\"key\");const value=path.call(print,\"value\");if(isEmptyMappingValue){return node.type===\"flowMappingItem\"&&parentNode.type===\"flowMapping\"?key:node.type===\"mappingItem\"&&isAbsolutelyPrintedAsSingleLineNode(node.key.content,options)&&!hasTrailingComment$3(node.key.content)&&(!parentNode.tag||parentNode.tag.value!==\"tag:yaml.org,2002:set\")?concat$h([key,needsSpaceInFrontOfMappingValue(node)?\" \":\"\",\":\"]):concat$h([\"? \",align$3(2,key)]);}if(isEmptyMappingKey){return concat$h([\": \",align$3(2,value)]);}const groupId=Symbol(\"mappingKey\");const forceExplicitKey=hasLeadingComments$1(node.value)||!isInlineNode(node.key.content);return forceExplicitKey?concat$h([\"? \",align$3(2,key),hardline$d,join$c(\"\",path.map(print,\"value\",\"leadingComments\").map(comment=>concat$h([comment,hardline$d]))),\": \",align$3(2,value)]):// force singleline\nisSingleLineNode(node.key.content)&&!hasLeadingComments$1(node.key.content)&&!hasMiddleComments$1(node.key.content)&&!hasTrailingComment$3(node.key.content)&&!hasEndComments$1(node.key)&&!hasLeadingComments$1(node.value.content)&&!hasMiddleComments$1(node.value.content)&&!hasEndComments$1(node.value)&&isAbsolutelyPrintedAsSingleLineNode(node.value.content,options)?concat$h([key,needsSpaceInFrontOfMappingValue(node)?\" \":\"\",\": \",value]):conditionalGroup$2([concat$h([group$g(concat$h([ifBreak$8(\"? \"),group$g(align$3(2,key),{id:groupId})])),ifBreak$8(concat$h([hardline$d,\": \",align$3(2,value)]),indent(concat$h([needsSpaceInFrontOfMappingValue(node)?\" \":\"\",\":\",hasLeadingComments$1(node.value.content)||hasEndComments$1(node.value)&&node.value.content&&!isNode$1(node.value.content,[\"mapping\",\"sequence\"])||parentNode.type===\"mapping\"&&hasTrailingComment$3(node.key.content)&&isInlineNode(node.value.content)||isNode$1(node.value.content,[\"mapping\",\"sequence\"])&&node.value.content.tag===null&&node.value.content.anchor===null?hardline$d:!node.value.content?\"\":line$b,value])),{groupId})])]);}case\"flowMapping\":case\"flowSequence\":{const openMarker=node.type===\"flowMapping\"?\"{\":\"[\";const closeMarker=node.type===\"flowMapping\"?\"}\":\"]\";const bracketSpacing=node.type===\"flowMapping\"&&node.children.length!==0&&options.bracketSpacing?line$b:softline$8;const isLastItemEmptyMappingItem=node.children.length!==0&&(lastItem=>lastItem.type===\"flowMappingItem\"&&isEmptyNode$1(lastItem.key)&&isEmptyNode$1(lastItem.value))(getLast$6(node.children));return concat$h([openMarker,indent(concat$h([bracketSpacing,concat$h(path.map((childPath,index)=>concat$h([print(childPath),index===node.children.length-1?\"\":concat$h([\",\",line$b,node.children[index].position.start.line!==node.children[index+1].position.start.line?printNextEmptyLine(childPath,options.originalText):\"\"])]),\"children\")),ifBreak$8(\",\",\"\")])),isLastItemEmptyMappingItem?\"\":bracketSpacing,closeMarker]);}case\"flowSequenceItem\":return path.call(print,\"content\");// istanbul ignore next\ndefault:throw new Error(\"Unexpected node type \".concat(node.type));}function indent(doc){return docBuilders$2.align(\" \".repeat(options.tabWidth),doc);}}function align$3(n,doc){return typeof n===\"number\"&&n>0?docBuilders$2.align(\" \".repeat(n),doc):docBuilders$2.align(n,doc);}function isInlineNode(node){if(!node){return true;}switch(node.type){case\"plain\":case\"quoteDouble\":case\"quoteSingle\":case\"alias\":case\"flowMapping\":case\"flowSequence\":return true;default:return false;}}function isSingleLineNode(node){if(!node){return true;}switch(node.type){case\"plain\":case\"quoteDouble\":case\"quoteSingle\":return node.position.start.line===node.position.end.line;case\"alias\":return true;default:return false;}}function shouldPrintDocumentBody(document){return document.body.children.length!==0||hasEndComments$1(document.body);}function shouldPrintDocumentEndMarker(document,nextDocument){return(/**\n       *... # trailingComment\n       */hasTrailingComment$3(document)||nextDocument&&(/**\n       * ...\n       * %DIRECTIVE\n       * ---\n       */nextDocument.head.children.length!==0||/**\n       * ...\n       * # endComment\n       * ---\n       */hasEndComments$1(nextDocument.head)));}function shouldPrintDocumentHeadEndMarker(document,nextDocument,root,options){if(/**\n     * ---\n     * preserve the first document head end marker\n     */root.children[0]===document&&/---(\\s|$)/.test(options.originalText.slice(options.locStart(document),options.locStart(document)+4))||/**\n     * %DIRECTIVE\n     * ---\n     */document.head.children.length!==0||/**\n     * # end comment\n     * ---\n     */hasEndComments$1(document.head)||/**\n     * --- # trailing comment\n     */hasTrailingComment$3(document.head)){return\"head\";}if(shouldPrintDocumentEndMarker(document,nextDocument)){return false;}return nextDocument?\"root\":false;}function isAbsolutelyPrintedAsSingleLineNode(node,options){if(!node){return true;}switch(node.type){case\"plain\":case\"quoteSingle\":case\"quoteDouble\":break;case\"alias\":return true;default:return false;}if(options.proseWrap===\"preserve\"){return node.position.start.line===node.position.end.line;}if(// backslash-newline\n/\\\\$/m.test(options.originalText.slice(node.position.start.offset,node.position.end.offset))){return false;}switch(options.proseWrap){case\"never\":return!node.value.includes(\"\\n\");case\"always\":return!/[\\n ]/.test(node.value);// istanbul ignore next\ndefault:return false;}}function needsSpaceInFrontOfMappingValue(node){return node.key.content&&node.key.content.type===\"alias\";}function printNextEmptyLine(path,originalText){const node=path.getValue();const root=path.stack[0];root.isNextEmptyLinePrintedChecklist=root.isNextEmptyLinePrintedChecklist||[];if(!root.isNextEmptyLinePrintedChecklist[node.position.end.line]){if(isNextLineEmpty$6(node,originalText)){root.isNextEmptyLinePrintedChecklist[node.position.end.line]=true;return softline$8;}}return\"\";}function printFlowScalarContent(nodeType,content,options){const lineContents=getFlowScalarLineContents$1(nodeType,content,options);return join$c(hardline$d,lineContents.map(lineContentWords=>fill$6(join$c(line$b,lineContentWords).parts)));}function clean$7(node,newNode/*, parent */){if(isNode$1(newNode)){delete newNode.position;switch(newNode.type){case\"comment\":// insert pragma\nif(isPragma$1(newNode.value)){return null;}break;case\"quoteDouble\":case\"quoteSingle\":newNode.type=\"quote\";break;}}}var printerYaml={preprocess:preprocess$3,print:genericPrint$6,massageAstNode:clean$7,insertPragma:insertPragma$9};var options$7={bracketSpacing:commonOptions.bracketSpacing,singleQuote:commonOptions.singleQuote,proseWrap:commonOptions.proseWrap};var name$h=\"YAML\";var type$g=\"data\";var tmScope$g=\"source.yaml\";var aliases$6=[\"yml\"];var extensions$g=[\".yml\",\".mir\",\".reek\",\".rviz\",\".sublime-syntax\",\".syntax\",\".yaml\",\".yaml-tmlanguage\",\".yaml.sed\",\".yml.mysql\"];var filenames$4=[\".clang-format\",\".clang-tidy\",\".gemrc\",\"glide.lock\",\"yarn.lock\"];var aceMode$g=\"yaml\";var codemirrorMode$c=\"yaml\";var codemirrorMimeType$c=\"text/x-yaml\";var languageId$g=407;var YAML={name:name$h,type:type$g,tmScope:tmScope$g,aliases:aliases$6,extensions:extensions$g,filenames:filenames$4,aceMode:aceMode$g,codemirrorMode:codemirrorMode$c,codemirrorMimeType:codemirrorMimeType$c,languageId:languageId$g};var YAML$1=/*#__PURE__*/Object.freeze({__proto__:null,name:name$h,type:type$g,tmScope:tmScope$g,aliases:aliases$6,extensions:extensions$g,filenames:filenames$4,aceMode:aceMode$g,codemirrorMode:codemirrorMode$c,codemirrorMimeType:codemirrorMimeType$c,languageId:languageId$g,'default':YAML});var require$$0$8=getCjsExportFromNamespace(YAML$1);const languages$6=[createLanguage(require$$0$8,data=>({since:\"1.14.0\",parsers:[\"yaml\"],vscodeLanguageIds:[\"yaml\"],// yarn.lock is not YAML: https://github.com/yarnpkg/yarn/issues/5629\nfilenames:data.filenames.filter(filename=>filename!==\"yarn.lock\")}))];var languageYaml={languages:languages$6,printers:{yaml:printerYaml},options:options$7};const{version:version$2}=require$$0;const{getSupportInfo:getSupportInfo$2}=support;const internalPlugins=[languageCss,languageGraphql,languageHandlebars,languageHtml,languageJs,languageMarkdown,languageYaml];function withPlugins(fn){let optsArgIdx=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;return function(){for(var _len13=arguments.length,args=new Array(_len13),_key14=0;_key14<_len13;_key14++){args[_key14]=arguments[_key14];}const opts=args[optsArgIdx]||{};const plugins=opts.plugins||[];args[optsArgIdx]=Object.assign({},opts,{plugins:[...internalPlugins,...(Array.isArray(plugins)?plugins:Object.values(plugins))]});return fn(...args);};}const formatWithCursor=withPlugins(core.formatWithCursor);var standalone={formatWithCursor,format(text,opts){return formatWithCursor(text,opts).formatted;},check(text,opts){const{formatted}=formatWithCursor(text,opts);return formatted===text;},doc:document,getSupportInfo:withPlugins(getSupportInfo$2,0),version:version$2,util:utilShared,__debug:{parse:withPlugins(core.parse),formatAST:withPlugins(core.formatAST),formatDoc:withPlugins(core.formatDoc),printToDoc:withPlugins(core.printToDoc),printDocToString:withPlugins(core.printDocToString)}};var standalone$1=standalone;return standalone$1;});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJldHRpZXIvc3RhbmRhbG9uZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcmV0dGllci9zdGFuZGFsb25lLmpzPzMyNWIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5wcmV0dGllciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbmFtZSA9IFwicHJldHRpZXJcIjtcbiAgdmFyIHZlcnNpb24gPSBcIjIuMC40XCI7XG4gIHZhciBkZXNjcmlwdGlvbiA9IFwiUHJldHRpZXIgaXMgYW4gb3BpbmlvbmF0ZWQgY29kZSBmb3JtYXR0ZXJcIjtcbiAgdmFyIGJpbiA9IFwiLi9iaW4vcHJldHRpZXIuanNcIjtcbiAgdmFyIHJlcG9zaXRvcnkgPSBcInByZXR0aWVyL3ByZXR0aWVyXCI7XG4gIHZhciBob21lcGFnZSA9IFwiaHR0cHM6Ly9wcmV0dGllci5pb1wiO1xuICB2YXIgYXV0aG9yID0gXCJKYW1lcyBMb25nXCI7XG4gIHZhciBsaWNlbnNlID0gXCJNSVRcIjtcbiAgdmFyIG1haW4gPSBcIi4vaW5kZXguanNcIjtcbiAgdmFyIGVuZ2luZXMgPSB7XG4gIFx0bm9kZTogXCI+PTEwLjEzLjBcIlxuICB9O1xuICB2YXIgZGVwZW5kZW5jaWVzID0ge1xuICBcdFwiQGFuZ3VsYXIvY29tcGlsZXJcIjogXCI5LjAuNVwiLFxuICBcdFwiQGJhYmVsL2NvZGUtZnJhbWVcIjogXCI3LjguMFwiLFxuICBcdFwiQGJhYmVsL3BhcnNlclwiOiBcIjcuOS40XCIsXG4gIFx0XCJAZ2xpbW1lci9zeW50YXhcIjogXCIwLjUwLjBcIixcbiAgXHRcIkBpYXJuYS90b21sXCI6IFwiMi4yLjNcIixcbiAgXHRcIkB0eXBlc2NyaXB0LWVzbGludC90eXBlc2NyaXB0LWVzdHJlZVwiOiBcIjIuMjYuMFwiLFxuICBcdFwiYW5ndWxhci1lc3RyZWUtcGFyc2VyXCI6IFwiMS4zLjBcIixcbiAgXHRcImFuZ3VsYXItaHRtbC1wYXJzZXJcIjogXCIxLjQuMFwiLFxuICBcdGNhbWVsY2FzZTogXCI1LjMuMVwiLFxuICBcdGNoYWxrOiBcIjQuMC4wXCIsXG4gIFx0XCJjaS1pbmZvXCI6IFwid2F0c29uL2NpLWluZm8jZjQzZjZhMWNlZmZmNDdmYjM2MWM4OGNmNGI5NDNmZGJjYWFmZTU0MFwiLFxuICBcdFwiY2prLXJlZ2V4XCI6IFwiMi4wLjBcIixcbiAgXHRjb3NtaWNvbmZpZzogXCI2LjAuMFwiLFxuICBcdGRhc2hpZnk6IFwiMi4wLjBcIixcbiAgXHRkZWRlbnQ6IFwiMC43LjBcIixcbiAgXHRkaWZmOiBcIjQuMC4yXCIsXG4gIFx0ZWRpdG9yY29uZmlnOiBcIjAuMTUuM1wiLFxuICBcdFwiZWRpdG9yY29uZmlnLXRvLXByZXR0aWVyXCI6IFwiMC4xLjFcIixcbiAgXHRcImVzY2FwZS1zdHJpbmctcmVnZXhwXCI6IFwiMi4wLjBcIixcbiAgXHRlc3V0aWxzOiBcIjIuMC4zXCIsXG4gIFx0XCJmYXN0LWdsb2JcIjogXCIzLjIuMlwiLFxuICBcdFwiZmluZC1wYXJlbnQtZGlyXCI6IFwiMC4zLjBcIixcbiAgXHRcImZpbmQtcHJvamVjdC1yb290XCI6IFwiMS4xLjFcIixcbiAgXHRcImZsb3ctcGFyc2VyXCI6IFwiMC4xMjIuMFwiLFxuICBcdFwiZ2V0LXN0cmVhbVwiOiBcIjUuMS4wXCIsXG4gIFx0Z2xvYmJ5OiBcIjExLjAuMFwiLFxuICBcdGdyYXBocWw6IFwiMTUuMC4wXCIsXG4gIFx0XCJodG1sLWVsZW1lbnQtYXR0cmlidXRlc1wiOiBcIjIuMi4xXCIsXG4gIFx0XCJodG1sLXN0eWxlc1wiOiBcIjEuMC4wXCIsXG4gIFx0XCJodG1sLXRhZy1uYW1lc1wiOiBcIjEuMS41XCIsXG4gIFx0aWdub3JlOiBcIjQuMC42XCIsXG4gIFx0XCJqZXN0LWRvY2Jsb2NrXCI6IFwiMjUuMi42XCIsXG4gIFx0XCJqc29uLXN0YWJsZS1zdHJpbmdpZnlcIjogXCIxLjAuMVwiLFxuICBcdGxldmVuOiBcIjMuMS4wXCIsXG4gIFx0XCJsaW5lcy1hbmQtY29sdW1uc1wiOiBcIjEuMS42XCIsXG4gIFx0XCJsaW5ndWlzdC1sYW5ndWFnZXNcIjogXCI3LjkuMFwiLFxuICBcdGxvZGFzaDogXCI0LjE3LjE1XCIsXG4gIFx0bWVtOiBcIjYuMC4xXCIsXG4gIFx0bWluaW1hdGNoOiBcIjMuMC40XCIsXG4gIFx0bWluaW1pc3Q6IFwiMS4yLjVcIixcbiAgXHRcIm4tcmVhZGxpbmVzXCI6IFwiMS4wLjBcIixcbiAgXHRcInBsZWFzZS11cGdyYWRlLW5vZGVcIjogXCIzLjIuMFwiLFxuICBcdFwicG9zdGNzcy1sZXNzXCI6IFwiMy4xLjRcIixcbiAgXHRcInBvc3Rjc3MtbWVkaWEtcXVlcnktcGFyc2VyXCI6IFwiMC4yLjNcIixcbiAgXHRcInBvc3Rjc3Mtc2Nzc1wiOiBcIjIuMC4wXCIsXG4gIFx0XCJwb3N0Y3NzLXNlbGVjdG9yLXBhcnNlclwiOiBcIjIuMi4zXCIsXG4gIFx0XCJwb3N0Y3NzLXZhbHVlcy1wYXJzZXJcIjogXCIyLjAuMVwiLFxuICBcdFwicmVnZXhwLXV0aWxcIjogXCIxLjIuMlwiLFxuICBcdFwicmVtYXJrLW1hdGhcIjogXCIxLjAuNlwiLFxuICBcdFwicmVtYXJrLXBhcnNlXCI6IFwiNS4wLjBcIixcbiAgXHRzZW12ZXI6IFwiNy4xLjNcIixcbiAgXHRzcmNzZXQ6IFwiMi4wLjFcIixcbiAgXHRcInN0cmluZy13aWR0aFwiOiBcIjQuMi4wXCIsXG4gIFx0dHlwZXNjcmlwdDogXCIzLjguM1wiLFxuICBcdFwidW5pY29kZS1yZWdleFwiOiBcIjMuMC4wXCIsXG4gIFx0dW5pZmllZDogXCI5LjAuMFwiLFxuICBcdHZub3B0czogXCIxLjAuMlwiLFxuICBcdFwieWFtbC11bmlzdC1wYXJzZXJcIjogXCIxLjEuMVwiXG4gIH07XG4gIHZhciBkZXZEZXBlbmRlbmNpZXMgPSB7XG4gIFx0XCJAYmFiZWwvY29yZVwiOiBcIjcuOS4wXCIsXG4gIFx0XCJAYmFiZWwvcHJlc2V0LWVudlwiOiBcIjcuOS4wXCIsXG4gIFx0XCJAcm9sbHVwL3BsdWdpbi1hbGlhc1wiOiBcIjMuMC4xXCIsXG4gIFx0XCJAcm9sbHVwL3BsdWdpbi1jb21tb25qc1wiOiBcIjExLjAuMlwiLFxuICBcdFwiQHJvbGx1cC9wbHVnaW4tanNvblwiOiBcIjQuMC4yXCIsXG4gIFx0XCJAcm9sbHVwL3BsdWdpbi1ub2RlLXJlc29sdmVcIjogXCI3LjEuMVwiLFxuICBcdFwiQHJvbGx1cC9wbHVnaW4tcmVwbGFjZVwiOiBcIjIuMy4xXCIsXG4gIFx0XCJiYWJlbC1sb2FkZXJcIjogXCI4LjEuMFwiLFxuICBcdGJlbmNobWFyazogXCIyLjEuNFwiLFxuICBcdFwiYnVpbHRpbi1tb2R1bGVzXCI6IFwiMy4xLjBcIixcbiAgXHRjb2RlY292OiBcIjMuNi41XCIsXG4gIFx0XCJjcm9zcy1lbnZcIjogXCI3LjAuMlwiLFxuICBcdGNzcGVsbDogXCI0LjAuNTVcIixcbiAgXHRlc2xpbnQ6IFwiNi44LjBcIixcbiAgXHRcImVzbGludC1jb25maWctcHJldHRpZXJcIjogXCI2LjEwLjFcIixcbiAgXHRcImVzbGludC1mb3JtYXR0ZXItZnJpZW5kbHlcIjogXCI3LjAuMFwiLFxuICBcdFwiZXNsaW50LXBsdWdpbi1pbXBvcnRcIjogXCIyLjIwLjJcIixcbiAgXHRcImVzbGludC1wbHVnaW4tcHJldHRpZXJcIjogXCIzLjEuMlwiLFxuICBcdFwiZXNsaW50LXBsdWdpbi1yZWFjdFwiOiBcIjcuMTkuMFwiLFxuICBcdFwiZXNsaW50LXBsdWdpbi11bmljb3JuXCI6IFwiMTguMC4xXCIsXG4gIFx0ZXhlY2E6IFwiNC4wLjBcIixcbiAgXHRqZXN0OiBcIjI1LjIuN1wiLFxuICBcdFwiamVzdC1zbmFwc2hvdC1zZXJpYWxpemVyLWFuc2lcIjogXCIxLjAuMFwiLFxuICBcdFwiamVzdC1zbmFwc2hvdC1zZXJpYWxpemVyLXJhd1wiOiBcIjEuMS4wXCIsXG4gIFx0XCJqZXN0LXdhdGNoLXR5cGVhaGVhZFwiOiBcIjAuNS4wXCIsXG4gIFx0cHJldHRpZXI6IFwiMi4wLjNcIixcbiAgXHRyaW1yYWY6IFwiMy4wLjJcIixcbiAgXHRyb2xsdXA6IFwiMi4zLjJcIixcbiAgXHRcInJvbGx1cC1wbHVnaW4tYmFiZWxcIjogXCI0LjQuMFwiLFxuICBcdFwicm9sbHVwLXBsdWdpbi1ub2RlLWdsb2JhbHNcIjogXCIxLjQuMFwiLFxuICBcdFwicm9sbHVwLXBsdWdpbi10ZXJzZXJcIjogXCI1LjMuMFwiLFxuICBcdHNoZWxsanM6IFwiMC44LjNcIixcbiAgXHRcInNuYXBzaG90LWRpZmZcIjogXCIwLjcuMFwiLFxuICBcdFwic3RyaXAtYW5zaVwiOiBcIjYuMC4wXCIsXG4gIFx0XCJzeW5jaHJvbm91cy1wcm9taXNlXCI6IFwiMi4wLjEwXCIsXG4gIFx0dGVtcHk6IFwiMC41LjBcIixcbiAgXHRcInRlcnNlci13ZWJwYWNrLXBsdWdpblwiOiBcIjIuMy41XCIsXG4gIFx0d2VicGFjazogXCI0LjQyLjFcIlxuICB9O1xuICB2YXIgc2NyaXB0cyA9IHtcbiAgXHRwcmVwdWJsaXNoT25seTogXCJlY2hvIFxcXCJFcnJvcjogbXVzdCBwdWJsaXNoIGZyb20gZGlzdC9cXFwiICYmIGV4aXQgMVwiLFxuICBcdFwicHJlcGFyZS1yZWxlYXNlXCI6IFwieWFybiAmJiB5YXJuIGJ1aWxkICYmIHlhcm4gdGVzdDpkaXN0XCIsXG4gIFx0dGVzdDogXCJqZXN0XCIsXG4gIFx0XCJ0ZXN0OmRpc3RcIjogXCJub2RlIC4vc2NyaXB0cy90ZXN0LWRpc3QuanNcIixcbiAgXHRcInRlc3Q6aW50ZWdyYXRpb25cIjogXCJqZXN0IHRlc3RzX2ludGVncmF0aW9uXCIsXG4gIFx0XCJwZXJmOnJlcGVhdFwiOiBcInlhcm4gJiYgeWFybiBidWlsZCAmJiBjcm9zcy1lbnYgTk9ERV9FTlY9cHJvZHVjdGlvbiBub2RlIC4vZGlzdC9iaW4tcHJldHRpZXIuanMgLS1kZWJ1Zy1yZXBlYXQgJHtQRVJGX1JFUEVBVDotMTAwMH0gLS1sb2dsZXZlbCBkZWJ1ZyAke1BFUkZfRklMRTotLi9pbmRleC5qc30gPiAvZGV2L251bGxcIixcbiAgXHRcInBlcmY6cmVwZWF0LWluc3BlY3RcIjogXCJ5YXJuICYmIHlhcm4gYnVpbGQgJiYgY3Jvc3MtZW52IE5PREVfRU5WPXByb2R1Y3Rpb24gbm9kZSAtLWluc3BlY3QtYnJrIC4vZGlzdC9iaW4tcHJldHRpZXIuanMgLS1kZWJ1Zy1yZXBlYXQgJHtQRVJGX1JFUEVBVDotMTAwMH0gLS1sb2dsZXZlbCBkZWJ1ZyAke1BFUkZfRklMRTotLi9pbmRleC5qc30gPiAvZGV2L251bGxcIixcbiAgXHRcInBlcmY6YmVuY2htYXJrXCI6IFwieWFybiAmJiB5YXJuIGJ1aWxkICYmIGNyb3NzLWVudiBOT0RFX0VOVj1wcm9kdWN0aW9uIG5vZGUgLi9kaXN0L2Jpbi1wcmV0dGllci5qcyAtLWRlYnVnLWJlbmNobWFyayAtLWxvZ2xldmVsIGRlYnVnICR7UEVSRl9GSUxFOi0uL2luZGV4LmpzfSA+IC9kZXYvbnVsbFwiLFxuICBcdFwibGludDp0eXBlY2hlY2tcIjogXCJ0c2NcIixcbiAgXHRcImxpbnQ6ZXNsaW50XCI6IFwiY3Jvc3MtZW52IEVGRl9OT19MSU5LX1JVTEVTPXRydWUgZXNsaW50IC4gLS1mb3JtYXQgZnJpZW5kbHlcIixcbiAgXHRcImxpbnQ6Y2hhbmdlbG9nXCI6IFwibm9kZSAuL3NjcmlwdHMvbGludC1jaGFuZ2Vsb2cuanNcIixcbiAgXHRcImxpbnQ6cHJldHRpZXJcIjogXCJwcmV0dGllciBcXFwiKiovKi57bWQsanNvbix5bWwsaHRtbCxjc3N9XFxcIiAtLWNoZWNrXCIsXG4gIFx0XCJsaW50OmRpc3RcIjogXCJlc2xpbnQgLS1uby1lc2xpbnRyYyAtLW5vLWlnbm9yZSAtLWVudj1lczYsYnJvd3NlciAtLXBhcnNlci1vcHRpb25zPWVjbWFWZXJzaW9uOjIwMTYgXFxcImRpc3QvIShiaW4tcHJldHRpZXJ8aW5kZXh8dGhpcmQtcGFydHkpLmpzXFxcIlwiLFxuICBcdFwibGludDpzcGVsbGNoZWNrXCI6IFwiY3NwZWxsIHtiaW4sc2NyaXB0cyxzcmMsd2Vic2l0ZX0vKiovKi5qcyB7ZG9jcyx3ZWJzaXRlL2Jsb2csY2hhbmdlbG9nX3VucmVsZWFzZWR9LyoqLyoubWRcIixcbiAgXHRcImxpbnQ6ZGVwc1wiOiBcIm5vZGUgLi9zY3JpcHRzL2NoZWNrLWRlcHMuanNcIixcbiAgXHRidWlsZDogXCJub2RlIC0tbWF4LW9sZC1zcGFjZS1zaXplPTMwNzIgLi9zY3JpcHRzL2J1aWxkL2J1aWxkLmpzXCIsXG4gIFx0XCJidWlsZC1kb2NzXCI6IFwibm9kZSAuL3NjcmlwdHMvYnVpbGQtZG9jcy5qc1wiXG4gIH07XG4gIHZhciBfcGFja2FnZSA9IHtcbiAgXHRuYW1lOiBuYW1lLFxuICBcdHZlcnNpb246IHZlcnNpb24sXG4gIFx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICBcdGJpbjogYmluLFxuICBcdHJlcG9zaXRvcnk6IHJlcG9zaXRvcnksXG4gIFx0aG9tZXBhZ2U6IGhvbWVwYWdlLFxuICBcdGF1dGhvcjogYXV0aG9yLFxuICBcdGxpY2Vuc2U6IGxpY2Vuc2UsXG4gIFx0bWFpbjogbWFpbixcbiAgXHRlbmdpbmVzOiBlbmdpbmVzLFxuICBcdGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzLFxuICBcdGRldkRlcGVuZGVuY2llczogZGV2RGVwZW5kZW5jaWVzLFxuICBcdHNjcmlwdHM6IHNjcmlwdHNcbiAgfTtcblxuICB2YXIgX3BhY2thZ2UkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSxcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICBiaW46IGJpbixcbiAgICByZXBvc2l0b3J5OiByZXBvc2l0b3J5LFxuICAgIGhvbWVwYWdlOiBob21lcGFnZSxcbiAgICBhdXRob3I6IGF1dGhvcixcbiAgICBsaWNlbnNlOiBsaWNlbnNlLFxuICAgIG1haW46IG1haW4sXG4gICAgZW5naW5lczogZW5naW5lcyxcbiAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcbiAgICBkZXZEZXBlbmRlbmNpZXM6IGRldkRlcGVuZGVuY2llcyxcbiAgICBzY3JpcHRzOiBzY3JpcHRzLFxuICAgICdkZWZhdWx0JzogX3BhY2thZ2VcbiAgfSk7XG5cbiAgZnVuY3Rpb24gRGlmZigpIHt9XG5cbiAgRGlmZi5wcm90b3R5cGUgPSB7XG4gICAgZGlmZjogZnVuY3Rpb24gZGlmZihvbGRTdHJpbmcsIG5ld1N0cmluZykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBmdW5jdGlvbiBkb25lKHZhbHVlKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCB2YWx1ZSk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFsbG93IHN1YmNsYXNzZXMgdG8gbWFzc2FnZSB0aGUgaW5wdXQgcHJpb3IgdG8gcnVubmluZ1xuXG5cbiAgICAgIG9sZFN0cmluZyA9IHRoaXMuY2FzdElucHV0KG9sZFN0cmluZyk7XG4gICAgICBuZXdTdHJpbmcgPSB0aGlzLmNhc3RJbnB1dChuZXdTdHJpbmcpO1xuICAgICAgb2xkU3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG9sZFN0cmluZykpO1xuICAgICAgbmV3U3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG5ld1N0cmluZykpO1xuICAgICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXG4gICAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aDtcbiAgICAgIHZhciBlZGl0TGVuZ3RoID0gMTtcbiAgICAgIHZhciBtYXhFZGl0TGVuZ3RoID0gbmV3TGVuICsgb2xkTGVuO1xuICAgICAgdmFyIGJlc3RQYXRoID0gW3tcbiAgICAgICAgbmV3UG9zOiAtMSxcbiAgICAgICAgY29tcG9uZW50czogW11cbiAgICAgIH1dOyAvLyBTZWVkIGVkaXRMZW5ndGggPSAwLCBpLmUuIHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIHRoZSBzYW1lIHZhbHVlc1xuXG4gICAgICB2YXIgb2xkUG9zID0gdGhpcy5leHRyYWN0Q29tbW9uKGJlc3RQYXRoWzBdLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgMCk7XG5cbiAgICAgIGlmIChiZXN0UGF0aFswXS5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBvbGRQb3MgKyAxID49IG9sZExlbikge1xuICAgICAgICAvLyBJZGVudGl0eSBwZXIgdGhlIGVxdWFsaXR5IGFuZCB0b2tlbml6ZXJcbiAgICAgICAgcmV0dXJuIGRvbmUoW3tcbiAgICAgICAgICB2YWx1ZTogdGhpcy5qb2luKG5ld1N0cmluZyksXG4gICAgICAgICAgY291bnQ6IG5ld1N0cmluZy5sZW5ndGhcbiAgICAgICAgfV0pO1xuICAgICAgfSAvLyBNYWluIHdvcmtlciBtZXRob2QuIGNoZWNrcyBhbGwgcGVybXV0YXRpb25zIG9mIGEgZ2l2ZW4gZWRpdCBsZW5ndGggZm9yIGFjY2VwdGFuY2UuXG5cblxuICAgICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XG4gICAgICAgIGZvciAodmFyIGRpYWdvbmFsUGF0aCA9IC0xICogZWRpdExlbmd0aDsgZGlhZ29uYWxQYXRoIDw9IGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCArPSAyKSB7XG4gICAgICAgICAgdmFyIGJhc2VQYXRoID0gdm9pZCAwO1xuXG4gICAgICAgICAgdmFyIGFkZFBhdGggPSBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSxcbiAgICAgICAgICAgICAgcmVtb3ZlUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCArIDFdLFxuICAgICAgICAgICAgICBfb2xkUG9zID0gKHJlbW92ZVBhdGggPyByZW1vdmVQYXRoLm5ld1BvcyA6IDApIC0gZGlhZ29uYWxQYXRoO1xuXG4gICAgICAgICAgaWYgKGFkZFBhdGgpIHtcbiAgICAgICAgICAgIC8vIE5vIG9uZSBlbHNlIGlzIGdvaW5nIHRvIGF0dGVtcHQgdG8gdXNlIHRoaXMgdmFsdWUsIGNsZWFyIGl0XG4gICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2FuQWRkID0gYWRkUGF0aCAmJiBhZGRQYXRoLm5ld1BvcyArIDEgPCBuZXdMZW4sXG4gICAgICAgICAgICAgIGNhblJlbW92ZSA9IHJlbW92ZVBhdGggJiYgMCA8PSBfb2xkUG9zICYmIF9vbGRQb3MgPCBvbGRMZW47XG5cbiAgICAgICAgICBpZiAoIWNhbkFkZCAmJiAhY2FuUmVtb3ZlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHBhdGggaXMgYSB0ZXJtaW5hbCB0aGVuIHBydW5lXG4gICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBTZWxlY3QgdGhlIGRpYWdvbmFsIHRoYXQgd2Ugd2FudCB0byBicmFuY2ggZnJvbS4gV2Ugc2VsZWN0IHRoZSBwcmlvclxuICAgICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG5ldyBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxuICAgICAgICAgIC8vIGFuZCBkb2VzIG5vdCBwYXNzIHRoZSBib3VuZHMgb2YgdGhlIGRpZmYgZ3JhcGhcblxuXG4gICAgICAgICAgaWYgKCFjYW5BZGQgfHwgY2FuUmVtb3ZlICYmIGFkZFBhdGgubmV3UG9zIDwgcmVtb3ZlUGF0aC5uZXdQb3MpIHtcbiAgICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xuICAgICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcblxuICAgICAgICAgICAgYmFzZVBhdGgubmV3UG9zKys7XG4gICAgICAgICAgICBzZWxmLnB1c2hDb21wb25lbnQoYmFzZVBhdGguY29tcG9uZW50cywgdHJ1ZSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfb2xkUG9zID0gc2VsZi5leHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKTsgLy8gSWYgd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiBib3RoIHN0cmluZ3MsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgICAgICAgIGlmIChiYXNlUGF0aC5uZXdQb3MgKyAxID49IG5ld0xlbiAmJiBfb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdHJhY2sgdGhpcyBwYXRoIGFzIGEgcG90ZW50aWFsIGNhbmRpZGF0ZSBhbmQgY29udGludWUuXG4gICAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWRpdExlbmd0aCsrO1xuICAgICAgfSAvLyBQZXJmb3JtcyB0aGUgbGVuZ3RoIG9mIGVkaXQgaXRlcmF0aW9uLiBJcyBhIGJpdCBmdWdseSBhcyB0aGlzIGhhcyB0byBzdXBwb3J0IHRoZVxuICAgICAgLy8gc3luYyBhbmQgYXN5bmMgbW9kZSB3aGljaCBpcyBuZXZlciBmdW4uIExvb3BzIG92ZXIgZXhlY0VkaXRMZW5ndGggdW50aWwgYSB2YWx1ZVxuICAgICAgLy8gaXMgcHJvZHVjZWQuXG5cblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIChmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IHdlIHdhbnQgdG8gYmUgc2FmZS5cblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmIChlZGl0TGVuZ3RoID4gbWF4RWRpdExlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFleGVjRWRpdExlbmd0aCgpKSB7XG4gICAgICAgICAgICAgIGV4ZWMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcmV0ID0gZXhlY0VkaXRMZW5ndGgoKTtcblxuICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwdXNoQ29tcG9uZW50OiBmdW5jdGlvbiBwdXNoQ29tcG9uZW50KGNvbXBvbmVudHMsIGFkZGVkLCByZW1vdmVkKSB7XG4gICAgICB2YXIgbGFzdCA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKGxhc3QgJiYgbGFzdC5hZGRlZCA9PT0gYWRkZWQgJiYgbGFzdC5yZW1vdmVkID09PSByZW1vdmVkKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2xvbmUgaGVyZSBhcyB0aGUgY29tcG9uZW50IGNsb25lIG9wZXJhdGlvbiBpcyBqdXN0XG4gICAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcbiAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdID0ge1xuICAgICAgICAgIGNvdW50OiBsYXN0LmNvdW50ICsgMSxcbiAgICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKHtcbiAgICAgICAgICBjb3VudDogMSxcbiAgICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dHJhY3RDb21tb246IGZ1bmN0aW9uIGV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpIHtcbiAgICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIG9sZExlbiA9IG9sZFN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgbmV3UG9zID0gYmFzZVBhdGgubmV3UG9zLFxuICAgICAgICAgIG9sZFBvcyA9IG5ld1BvcyAtIGRpYWdvbmFsUGF0aCxcbiAgICAgICAgICBjb21tb25Db3VudCA9IDA7XG5cbiAgICAgIHdoaWxlIChuZXdQb3MgKyAxIDwgbmV3TGVuICYmIG9sZFBvcyArIDEgPCBvbGRMZW4gJiYgdGhpcy5lcXVhbHMobmV3U3RyaW5nW25ld1BvcyArIDFdLCBvbGRTdHJpbmdbb2xkUG9zICsgMV0pKSB7XG4gICAgICAgIG5ld1BvcysrO1xuICAgICAgICBvbGRQb3MrKztcbiAgICAgICAgY29tbW9uQ291bnQrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1vbkNvdW50KSB7XG4gICAgICAgIGJhc2VQYXRoLmNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgICAgY291bnQ6IGNvbW1vbkNvdW50XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBiYXNlUGF0aC5uZXdQb3MgPSBuZXdQb3M7XG4gICAgICByZXR1cm4gb2xkUG9zO1xuICAgIH0sXG4gICAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMobGVmdCwgcmlnaHQpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNvbXBhcmF0b3IobGVmdCwgcmlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlICYmIGxlZnQudG9Mb3dlckNhc2UoKSA9PT0gcmlnaHQudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUVtcHR5OiBmdW5jdGlvbiByZW1vdmVFbXB0eShhcnJheSkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSkge1xuICAgICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgY2FzdElucHV0OiBmdW5jdGlvbiBjYXN0SW5wdXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHRva2VuaXplOiBmdW5jdGlvbiB0b2tlbml6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcnKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oY2hhcnMpIHtcbiAgICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gYnVpbGRWYWx1ZXMoZGlmZiwgY29tcG9uZW50cywgbmV3U3RyaW5nLCBvbGRTdHJpbmcsIHVzZUxvbmdlc3RUb2tlbikge1xuICAgIHZhciBjb21wb25lbnRQb3MgPSAwLFxuICAgICAgICBjb21wb25lbnRMZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcbiAgICAgICAgbmV3UG9zID0gMCxcbiAgICAgICAgb2xkUG9zID0gMDtcblxuICAgIGZvciAoOyBjb21wb25lbnRQb3MgPCBjb21wb25lbnRMZW47IGNvbXBvbmVudFBvcysrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuXG4gICAgICBpZiAoIWNvbXBvbmVudC5yZW1vdmVkKSB7XG4gICAgICAgIGlmICghY29tcG9uZW50LmFkZGVkICYmIHVzZUxvbmdlc3RUb2tlbikge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5ld1N0cmluZy5zbGljZShuZXdQb3MsIG5ld1BvcyArIGNvbXBvbmVudC5jb3VudCk7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGRTdHJpbmdbb2xkUG9zICsgaV07XG4gICAgICAgICAgICByZXR1cm4gb2xkVmFsdWUubGVuZ3RoID4gdmFsdWUubGVuZ3RoID8gb2xkVmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4odmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld1BvcyArPSBjb21wb25lbnQuY291bnQ7IC8vIENvbW1vbiBjYXNlXG5cbiAgICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4ob2xkU3RyaW5nLnNsaWNlKG9sZFBvcywgb2xkUG9zICsgY29tcG9uZW50LmNvdW50KSk7XG4gICAgICAgIG9sZFBvcyArPSBjb21wb25lbnQuY291bnQ7IC8vIFJldmVyc2UgYWRkIGFuZCByZW1vdmUgc28gcmVtb3ZlcyBhcmUgb3V0cHV0IGZpcnN0IHRvIG1hdGNoIGNvbW1vbiBjb252ZW50aW9uXG4gICAgICAgIC8vIFRoZSBkaWZmaW5nIGFsZ29yaXRobSBpcyB0aWVkIHRvIGFkZCB0aGVuIHJlbW92ZSBvdXRwdXQgYW5kIHRoaXMgaXMgdGhlIHNpbXBsZXN0XG4gICAgICAgIC8vIHJvdXRlIHRvIGdldCB0aGUgZGVzaXJlZCBvdXRwdXQgd2l0aCBtaW5pbWFsIG92ZXJoZWFkLlxuXG4gICAgICAgIGlmIChjb21wb25lbnRQb3MgJiYgY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXS5hZGRlZCkge1xuICAgICAgICAgIHZhciB0bXAgPSBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdO1xuICAgICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0gPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XG4gICAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnRQb3NdID0gdG1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBTcGVjaWFsIGNhc2UgaGFuZGxlIGZvciB3aGVuIG9uZSB0ZXJtaW5hbCBpcyBpZ25vcmVkIChpLmUuIHdoaXRlc3BhY2UpLlxuICAgIC8vIEZvciB0aGlzIGNhc2Ugd2UgbWVyZ2UgdGhlIHRlcm1pbmFsIGludG8gdGhlIHByaW9yIHN0cmluZyBhbmQgZHJvcCB0aGUgY2hhbmdlLlxuICAgIC8vIFRoaXMgaXMgb25seSBhdmFpbGFibGUgZm9yIHN0cmluZyBtb2RlLlxuXG5cbiAgICB2YXIgbGFzdENvbXBvbmVudCA9IGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMV07XG5cbiAgICBpZiAoY29tcG9uZW50TGVuID4gMSAmJiB0eXBlb2YgbGFzdENvbXBvbmVudC52YWx1ZSA9PT0gJ3N0cmluZycgJiYgKGxhc3RDb21wb25lbnQuYWRkZWQgfHwgbGFzdENvbXBvbmVudC5yZW1vdmVkKSAmJiBkaWZmLmVxdWFscygnJywgbGFzdENvbXBvbmVudC52YWx1ZSkpIHtcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50TGVuIC0gMl0udmFsdWUgKz0gbGFzdENvbXBvbmVudC52YWx1ZTtcbiAgICAgIGNvbXBvbmVudHMucG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZVBhdGgocGF0aCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXdQb3M6IHBhdGgubmV3UG9zLFxuICAgICAgY29tcG9uZW50czogcGF0aC5jb21wb25lbnRzLnNsaWNlKDApXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjaGFyYWN0ZXJEaWZmID0gbmV3IERpZmYoKTtcblxuICBmdW5jdGlvbiBkaWZmQ2hhcnMob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlT3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVmYXVsdHMuY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgZGVmYXVsdHNbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRzO1xuICB9IC8vXG4gIC8vIFJhbmdlcyBhbmQgZXhjZXB0aW9uczpcbiAgLy8gTGF0aW4tMSBTdXBwbGVtZW50LCAwMDgw4oCTMDBGRlxuICAvLyAgLSBVKzAwRDcgIMOXIE11bHRpcGxpY2F0aW9uIHNpZ25cbiAgLy8gIC0gVSswMEY3ICDDtyBEaXZpc2lvbiBzaWduXG4gIC8vIExhdGluIEV4dGVuZGVkLUEsIDAxMDDigJMwMTdGXG4gIC8vIExhdGluIEV4dGVuZGVkLUIsIDAxODDigJMwMjRGXG4gIC8vIElQQSBFeHRlbnNpb25zLCAwMjUw4oCTMDJBRlxuICAvLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnMsIDAyQjDigJMwMkZGXG4gIC8vICAtIFUrMDJDNyAgy4cgJiM3MTE7ICBDYXJvblxuICAvLyAgLSBVKzAyRDggIMuYICYjNzI4OyAgQnJldmVcbiAgLy8gIC0gVSswMkQ5ICDLmSAmIzcyOTsgIERvdCBBYm92ZVxuICAvLyAgLSBVKzAyREEgIMuaICYjNzMwOyAgUmluZyBBYm92ZVxuICAvLyAgLSBVKzAyREIgIMubICYjNzMxOyAgT2dvbmVrXG4gIC8vICAtIFUrMDJEQyAgy5wgJiM3MzI7ICBTbWFsbCBUaWxkZVxuICAvLyAgLSBVKzAyREQgIMudICYjNzMzOyAgRG91YmxlIEFjdXRlIEFjY2VudFxuICAvLyBMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsLCAxRTAw4oCTMUVGRlxuXG5cbiAgdmFyIGV4dGVuZGVkV29yZENoYXJzID0gL15bQS1aYS16XFx4QzAtXFx1MDJDNlxcdTAyQzgtXFx1MDJEN1xcdTAyREUtXFx1MDJGRlxcdTFFMDAtXFx1MUVGRl0rJC87XG4gIHZhciByZVdoaXRlc3BhY2UgPSAvXFxTLztcbiAgdmFyIHdvcmREaWZmID0gbmV3IERpZmYoKTtcblxuICB3b3JkRGlmZi5lcXVhbHMgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUNhc2UpIHtcbiAgICAgIGxlZnQgPSBsZWZ0LnRvTG93ZXJDYXNlKCk7XG4gICAgICByaWdodCA9IHJpZ2h0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0IHx8IHRoaXMub3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlICYmICFyZVdoaXRlc3BhY2UudGVzdChsZWZ0KSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QocmlnaHQpO1xuICB9O1xuXG4gIHdvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHRva2VucyA9IHZhbHVlLnNwbGl0KC8oXFxzK3xbKClbXFxde30nXCJdfFxcYikvKTsgLy8gSm9pbiB0aGUgYm91bmRhcnkgc3BsaXRzIHRoYXQgd2UgZG8gbm90IGNvbnNpZGVyIHRvIGJlIGJvdW5kYXJpZXMuIFRoaXMgaXMgcHJpbWFyaWx5IHRoZSBleHRlbmRlZCBMYXRpbiBjaGFyYWN0ZXIgc2V0LlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBpbiB0aGUgbmV4dCBmaWVsZCBhbmQgd2UgaGF2ZSBvbmx5IHdvcmQgY2hhcnMgYmVmb3JlIGFuZCBhZnRlciwgbWVyZ2VcbiAgICAgIGlmICghdG9rZW5zW2kgKyAxXSAmJiB0b2tlbnNbaSArIDJdICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2ldKSAmJiBleHRlbmRlZFdvcmRDaGFycy50ZXN0KHRva2Vuc1tpICsgMl0pKSB7XG4gICAgICAgIHRva2Vuc1tpXSArPSB0b2tlbnNbaSArIDJdO1xuICAgICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAyKTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH07XG5cbiAgZnVuY3Rpb24gZGlmZldvcmRzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGdlbmVyYXRlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlmZldvcmRzV2l0aFNwYWNlKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIGxpbmVEaWZmID0gbmV3IERpZmYoKTtcblxuICBsaW5lRGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZXRMaW5lcyA9IFtdLFxuICAgICAgICBsaW5lc0FuZE5ld2xpbmVzID0gdmFsdWUuc3BsaXQoLyhcXG58XFxyXFxuKS8pOyAvLyBJZ25vcmUgdGhlIGZpbmFsIGVtcHR5IHRva2VuIHRoYXQgb2NjdXJzIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGEgbmV3IGxpbmVcblxuICAgIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICBsaW5lc0FuZE5ld2xpbmVzLnBvcCgpO1xuICAgIH0gLy8gTWVyZ2UgdGhlIGNvbnRlbnQgYW5kIGxpbmUgc2VwYXJhdG9ycyBpbnRvIHNpbmdsZSB0b2tlbnNcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzQW5kTmV3bGluZXNbaV07XG5cbiAgICAgIGlmIChpICUgMiAmJiAhdGhpcy5vcHRpb25zLm5ld2xpbmVJc1Rva2VuKSB7XG4gICAgICAgIHJldExpbmVzW3JldExpbmVzLmxlbmd0aCAtIDFdICs9IGxpbmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXRMaW5lcztcbiAgfTtcblxuICBmdW5jdGlvbiBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpZmZUcmltbWVkTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnMoY2FsbGJhY2ssIHtcbiAgICAgIGlnbm9yZVdoaXRlc3BhY2U6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc2VudGVuY2VEaWZmID0gbmV3IERpZmYoKTtcblxuICBzZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoLyhcXFMuKz9bLiE/XSkoPz1cXHMrfCQpLyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZGlmZlNlbnRlbmNlcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2VudGVuY2VEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBjc3NEaWZmID0gbmV3IERpZmYoKTtcblxuICBjc3NEaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNwbGl0KC8oW3t9OjssXXxcXHMrKS8pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRpZmZDc3Mob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGNzc0RpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xuICB9XG5cbiAgZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgICByZXR1cm4gYXJyMjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgICBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgfVxuXG4gIHZhciBvYmplY3RQcm90b3R5cGVUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBqc29uRGlmZiA9IG5ldyBEaWZmKCk7IC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXG4gIC8vIGRhbmdsaW5nIGNvbW1hIGFuZCB0aGUgb3RoZXIgZG9lc24ndC4gVHVybnMgb3V0IGluY2x1ZGluZyB0aGUgZGFuZ2xpbmcgY29tbWEgeWllbGRzIHRoZSBuaWNlc3Qgb3V0cHV0OlxuXG4gIGpzb25EaWZmLnVzZUxvbmdlc3RUb2tlbiA9IHRydWU7XG4gIGpzb25EaWZmLnRva2VuaXplID0gbGluZURpZmYudG9rZW5pemU7XG5cbiAganNvbkRpZmYuY2FzdElucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHVuZGVmaW5lZFJlcGxhY2VtZW50ID0gX3RoaXMkb3B0aW9ucy51bmRlZmluZWRSZXBsYWNlbWVudCxcbiAgICAgICAgX3RoaXMkb3B0aW9ucyRzdHJpbmdpID0gX3RoaXMkb3B0aW9ucy5zdHJpbmdpZnlSZXBsYWNlcixcbiAgICAgICAgc3RyaW5naWZ5UmVwbGFjZXIgPSBfdGhpcyRvcHRpb25zJHN0cmluZ2kgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkUmVwbGFjZW1lbnQgOiB2O1xuICAgIH0gOiBfdGhpcyRvcHRpb25zJHN0cmluZ2k7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KGNhbm9uaWNhbGl6ZSh2YWx1ZSwgbnVsbCwgbnVsbCwgc3RyaW5naWZ5UmVwbGFjZXIpLCBzdHJpbmdpZnlSZXBsYWNlciwgJyAgJyk7XG4gIH07XG5cbiAganNvbkRpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIERpZmYucHJvdG90eXBlLmVxdWFscy5jYWxsKGpzb25EaWZmLCBsZWZ0LnJlcGxhY2UoLywoW1xcclxcbl0pL2csICckMScpLCByaWdodC5yZXBsYWNlKC8sKFtcXHJcXG5dKS9nLCAnJDEnKSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ganNvbkRpZmYuZGlmZihvbGRPYmosIG5ld09iaiwgb3B0aW9ucyk7XG4gIH0gLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBwcmVzZW5jZSBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGJhaWxpbmcgb3V0IHdoZW4gZW5jb3VudGVyaW5nIGFuXG4gIC8vIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgb24gdGhlIFwic3RhY2tcIiBvZiBpdGVtcyBiZWluZyBwcm9jZXNzZWQuIEFjY2VwdHMgYW4gb3B0aW9uYWwgcmVwbGFjZXJcblxuXG4gIGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShvYmosIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KSB7XG4gICAgc3RhY2sgPSBzdGFjayB8fCBbXTtcbiAgICByZXBsYWNlbWVudFN0YWNrID0gcmVwbGFjZW1lbnRTdGFjayB8fCBbXTtcblxuICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgb2JqID0gcmVwbGFjZXIoa2V5LCBvYmopO1xuICAgIH1cblxuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IG9iaikge1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnRTdGFja1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2Fub25pY2FsaXplZE9iajtcblxuICAgIGlmICgnW29iamVjdCBBcnJheV0nID09PSBvYmplY3RQcm90b3R5cGVUb1N0cmluZy5jYWxsKG9iaikpIHtcbiAgICAgIHN0YWNrLnB1c2gob2JqKTtcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSBuZXcgQXJyYXkob2JqLmxlbmd0aCk7XG4gICAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KTtcbiAgICAgIH1cblxuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICByZXBsYWNlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XG4gICAgfVxuXG4gICAgaWYgKG9iaiAmJiBvYmoudG9KU09OKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2Yob2JqKSA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICBzdGFjay5wdXNoKG9iaik7XG4gICAgICBjYW5vbmljYWxpemVkT2JqID0ge307XG4gICAgICByZXBsYWNlbWVudFN0YWNrLnB1c2goY2Fub25pY2FsaXplZE9iaik7XG5cbiAgICAgIHZhciBzb3J0ZWRLZXlzID0gW10sXG4gICAgICAgICAgX2tleTtcblxuICAgICAgZm9yIChfa2V5IGluIG9iaikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KF9rZXkpKSB7XG4gICAgICAgICAgc29ydGVkS2V5cy5wdXNoKF9rZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNvcnRlZEtleXMuc29ydCgpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc29ydGVkS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBfa2V5ID0gc29ydGVkS2V5c1tpXTtcbiAgICAgICAgY2Fub25pY2FsaXplZE9ialtfa2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpbX2tleV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwgX2tleSk7XG4gICAgICB9XG5cbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gY2Fub25pY2FsaXplZE9iajtcbiAgfVxuXG4gIHZhciBhcnJheURpZmYgPSBuZXcgRGlmZigpO1xuXG4gIGFycmF5RGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICB9O1xuXG4gIGFycmF5RGlmZi5qb2luID0gYXJyYXlEaWZmLnJlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRpZmZBcnJheXMob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGFycmF5RGlmZi5kaWZmKG9sZEFyciwgbmV3QXJyLCBjYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBhdGNoKHVuaURpZmYpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIGRpZmZzdHIgPSB1bmlEaWZmLnNwbGl0KC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS8pLFxuICAgICAgICBkZWxpbWl0ZXJzID0gdW5pRGlmZi5tYXRjaCgvXFxyXFxufFtcXG5cXHZcXGZcXHJcXHg4NV0vZykgfHwgW10sXG4gICAgICAgIGxpc3QgPSBbXSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUluZGV4KCkge1xuICAgICAgdmFyIGluZGV4ID0ge307XG4gICAgICBsaXN0LnB1c2goaW5kZXgpOyAvLyBQYXJzZSBkaWZmIG1ldGFkYXRhXG5cbiAgICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBkaWZmc3RyW2ldOyAvLyBGaWxlIGhlYWRlciBmb3VuZCwgZW5kIHBhcnNpbmcgZGlmZiBtZXRhZGF0YVxuXG4gICAgICAgIGlmICgvXihcXC1cXC1cXC18XFwrXFwrXFwrfEBAKVxccy8udGVzdChsaW5lKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIERpZmYgaW5kZXhcblxuXG4gICAgICAgIHZhciBoZWFkZXIgPSAvXig/OkluZGV4OnxkaWZmKD86IC1yIFxcdyspKylcXHMrKC4rPylcXHMqJC8uZXhlYyhsaW5lKTtcblxuICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgaW5kZXguaW5kZXggPSBoZWFkZXJbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9IC8vIFBhcnNlIGZpbGUgaGVhZGVycyBpZiB0aGV5IGFyZSBkZWZpbmVkLiBVbmlmaWVkIGRpZmYgcmVxdWlyZXMgdGhlbSwgYnV0XG4gICAgICAvLyB0aGVyZSdzIG5vIHRlY2huaWNhbCBpc3N1ZXMgdG8gaGF2ZSBhbiBpc29sYXRlZCBodW5rIHdpdGhvdXQgZmlsZSBoZWFkZXJcblxuXG4gICAgICBwYXJzZUZpbGVIZWFkZXIoaW5kZXgpO1xuICAgICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTsgLy8gUGFyc2UgaHVua3NcblxuICAgICAgaW5kZXguaHVua3MgPSBbXTtcblxuICAgICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgICB2YXIgX2xpbmUgPSBkaWZmc3RyW2ldO1xuXG4gICAgICAgIGlmICgvXihJbmRleDp8ZGlmZnxcXC1cXC1cXC18XFwrXFwrXFwrKVxccy8udGVzdChfbGluZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICgvXkBALy50ZXN0KF9saW5lKSkge1xuICAgICAgICAgIGluZGV4Lmh1bmtzLnB1c2gocGFyc2VIdW5rKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKF9saW5lICYmIG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgLy8gSWdub3JlIHVuZXhwZWN0ZWQgY29udGVudCB1bmxlc3MgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGluZSAnICsgKGkgKyAxKSArICcgJyArIEpTT04uc3RyaW5naWZ5KF9saW5lKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xuICAgIC8vIGFyZSBjb25zdW1lZC5cblxuXG4gICAgZnVuY3Rpb24gcGFyc2VGaWxlSGVhZGVyKGluZGV4KSB7XG4gICAgICB2YXIgZmlsZUhlYWRlciA9IC9eKC0tLXxcXCtcXCtcXCspXFxzKyguKikkLy5leGVjKGRpZmZzdHJbaV0pO1xuXG4gICAgICBpZiAoZmlsZUhlYWRlcikge1xuICAgICAgICB2YXIga2V5UHJlZml4ID0gZmlsZUhlYWRlclsxXSA9PT0gJy0tLScgPyAnb2xkJyA6ICduZXcnO1xuICAgICAgICB2YXIgZGF0YSA9IGZpbGVIZWFkZXJbMl0uc3BsaXQoJ1xcdCcsIDIpO1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBkYXRhWzBdLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG5cbiAgICAgICAgaWYgKC9eXCIuKlwiJC8udGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigxLCBmaWxlTmFtZS5sZW5ndGggLSAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4W2tleVByZWZpeCArICdGaWxlTmFtZSddID0gZmlsZU5hbWU7XG4gICAgICAgIGluZGV4W2tleVByZWZpeCArICdIZWFkZXInXSA9IChkYXRhWzFdIHx8ICcnKS50cmltKCk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9IC8vIFBhcnNlcyBhIGh1bmtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBhcmUgYXQgdGhlIHN0YXJ0IG9mIGEgaHVuay5cblxuXG4gICAgZnVuY3Rpb24gcGFyc2VIdW5rKCkge1xuICAgICAgdmFyIGNodW5rSGVhZGVySW5kZXggPSBpLFxuICAgICAgICAgIGNodW5rSGVhZGVyTGluZSA9IGRpZmZzdHJbaSsrXSxcbiAgICAgICAgICBjaHVua0hlYWRlciA9IGNodW5rSGVhZGVyTGluZS5zcGxpdCgvQEAgLShcXGQrKSg/OiwoXFxkKykpPyBcXCsoXFxkKykoPzosKFxcZCspKT8gQEAvKTtcbiAgICAgIHZhciBodW5rID0ge1xuICAgICAgICBvbGRTdGFydDogK2NodW5rSGVhZGVyWzFdLFxuICAgICAgICBvbGRMaW5lczogK2NodW5rSGVhZGVyWzJdIHx8IDEsXG4gICAgICAgIG5ld1N0YXJ0OiArY2h1bmtIZWFkZXJbM10sXG4gICAgICAgIG5ld0xpbmVzOiArY2h1bmtIZWFkZXJbNF0gfHwgMSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBsaW5lZGVsaW1pdGVyczogW11cbiAgICAgIH07XG4gICAgICB2YXIgYWRkQ291bnQgPSAwLFxuICAgICAgICAgIHJlbW92ZUNvdW50ID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBkaWZmc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIExpbmVzIHN0YXJ0aW5nIHdpdGggJy0tLScgY291bGQgYmUgbWlzdGFrZW4gZm9yIHRoZSBcInJlbW92ZSBsaW5lXCIgb3BlcmF0aW9uXG4gICAgICAgIC8vIEJ1dCB0aGV5IGNvdWxkIGJlIHRoZSBoZWFkZXIgZm9yIHRoZSBuZXh0IGZpbGUuIFRoZXJlZm9yZSBwcnVuZSBzdWNoIGNhc2VzIG91dC5cbiAgICAgICAgaWYgKGRpZmZzdHJbaV0uaW5kZXhPZignLS0tICcpID09PSAwICYmIGkgKyAyIDwgZGlmZnN0ci5sZW5ndGggJiYgZGlmZnN0cltpICsgMV0uaW5kZXhPZignKysrICcpID09PSAwICYmIGRpZmZzdHJbaSArIDJdLmluZGV4T2YoJ0BAJykgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBkaWZmc3RyW2ldLmxlbmd0aCA9PSAwICYmIGkgIT0gZGlmZnN0ci5sZW5ndGggLSAxID8gJyAnIDogZGlmZnN0cltpXVswXTtcblxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycgfHwgb3BlcmF0aW9uID09PSAnLScgfHwgb3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnXFxcXCcpIHtcbiAgICAgICAgICBodW5rLmxpbmVzLnB1c2goZGlmZnN0cltpXSk7XG4gICAgICAgICAgaHVuay5saW5lZGVsaW1pdGVycy5wdXNoKGRlbGltaXRlcnNbaV0gfHwgJ1xcbicpO1xuXG4gICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XG4gICAgICAgICAgICBhZGRDb3VudCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xuICAgICAgICAgICAgYWRkQ291bnQrKztcbiAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIEhhbmRsZSB0aGUgZW1wdHkgYmxvY2sgY291bnQgY2FzZVxuXG5cbiAgICAgIGlmICghYWRkQ291bnQgJiYgaHVuay5uZXdMaW5lcyA9PT0gMSkge1xuICAgICAgICBodW5rLm5ld0xpbmVzID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZW1vdmVDb3VudCAmJiBodW5rLm9sZExpbmVzID09PSAxKSB7XG4gICAgICAgIGh1bmsub2xkTGluZXMgPSAwO1xuICAgICAgfSAvLyBQZXJmb3JtIG9wdGlvbmFsIHNhbml0eSBjaGVja2luZ1xuXG5cbiAgICAgIGlmIChvcHRpb25zLnN0cmljdCkge1xuICAgICAgICBpZiAoYWRkQ291bnQgIT09IGh1bmsubmV3TGluZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FkZGVkIGxpbmUgY291bnQgZGlkIG5vdCBtYXRjaCBmb3IgaHVuayBhdCBsaW5lICcgKyAoY2h1bmtIZWFkZXJJbmRleCArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmVDb3VudCAhPT0gaHVuay5vbGRMaW5lcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGh1bms7XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xuICAgICAgcGFyc2VJbmRleCgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9IC8vIEl0ZXJhdG9yIHRoYXQgdHJhdmVyc2VzIGluIHRoZSByYW5nZSBvZiBbbWluLCBtYXhdLCBzdGVwcGluZ1xuICAvLyBieSBkaXN0YW5jZSBmcm9tIGEgZ2l2ZW4gc3RhcnQgcG9zaXRpb24uIEkuZS4gZm9yIFswLCA0XSwgd2l0aFxuICAvLyBzdGFydCBvZiAyLCB0aGlzIHdpbGwgaXRlcmF0ZSAyLCAzLCAxLCA0LCAwLlxuXG5cbiAgZnVuY3Rpb24gZGlzdGFuY2VJdGVyYXRvcihzdGFydCwgbWluTGluZSwgbWF4TGluZSkge1xuICAgIHZhciB3YW50Rm9yd2FyZCA9IHRydWUsXG4gICAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gZmFsc2UsXG4gICAgICAgIGZvcndhcmRFeGhhdXN0ZWQgPSBmYWxzZSxcbiAgICAgICAgbG9jYWxPZmZzZXQgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcbiAgICAgIGlmICh3YW50Rm9yd2FyZCAmJiAhZm9yd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICBpZiAoYmFja3dhcmRFeGhhdXN0ZWQpIHtcbiAgICAgICAgICBsb2NhbE9mZnNldCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhbnRGb3J3YXJkID0gZmFsc2U7XG4gICAgICAgIH0gLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZXlvbmQgdGV4dCBsZW5ndGgsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgICAgLy8gYWZ0ZXIgb2Zmc2V0IGxvY2F0aW9uIChvciBkZXNpcmVkIGxvY2F0aW9uIG9uIGZpcnN0IGl0ZXJhdGlvbilcblxuXG4gICAgICAgIGlmIChzdGFydCArIGxvY2FsT2Zmc2V0IDw9IG1heExpbmUpIHtcbiAgICAgICAgICByZXR1cm4gbG9jYWxPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3J3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFiYWNrd2FyZEV4aGF1c3RlZCkge1xuICAgICAgICBpZiAoIWZvcndhcmRFeGhhdXN0ZWQpIHtcbiAgICAgICAgICB3YW50Rm9yd2FyZCA9IHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgaWYgdHJ5aW5nIHRvIGZpdCBiZWZvcmUgdGV4dCBiZWdpbm5pbmcsIGFuZCBpZiBub3QsIGNoZWNrIGl0IGZpdHNcbiAgICAgICAgLy8gYmVmb3JlIG9mZnNldCBsb2NhdGlvblxuXG5cbiAgICAgICAgaWYgKG1pbkxpbmUgPD0gc3RhcnQgLSBsb2NhbE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiAtbG9jYWxPZmZzZXQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yKCk7XG4gICAgICB9IC8vIFdlIHRyaWVkIHRvIGZpdCBodW5rIGJlZm9yZSB0ZXh0IGJlZ2lubmluZyBhbmQgYmV5b25kIHRleHQgbGVuZ3RoLCB0aGVuXG4gICAgICAvLyBodW5rIGNhbid0IGZpdCBvbiB0aGUgdGV4dC4gUmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5UGF0Y2goc291cmNlLCB1bmlEaWZmKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgaWYgKHR5cGVvZiB1bmlEaWZmID09PSAnc3RyaW5nJykge1xuICAgICAgdW5pRGlmZiA9IHBhcnNlUGF0Y2godW5pRGlmZik7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodW5pRGlmZikpIHtcbiAgICAgIGlmICh1bmlEaWZmLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBseVBhdGNoIG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBpbnB1dC4nKTtcbiAgICAgIH1cblxuICAgICAgdW5pRGlmZiA9IHVuaURpZmZbMF07XG4gICAgfSAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgaW5wdXRcblxuXG4gICAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS8pLFxuICAgICAgICBkZWxpbWl0ZXJzID0gc291cmNlLm1hdGNoKC9cXHJcXG58W1xcblxcdlxcZlxcclxceDg1XS9nKSB8fCBbXSxcbiAgICAgICAgaHVua3MgPSB1bmlEaWZmLmh1bmtzLFxuICAgICAgICBjb21wYXJlTGluZSA9IG9wdGlvbnMuY29tcGFyZUxpbmUgfHwgZnVuY3Rpb24gKGxpbmVOdW1iZXIsIGxpbmUsIG9wZXJhdGlvbiwgcGF0Y2hDb250ZW50KSB7XG4gICAgICByZXR1cm4gbGluZSA9PT0gcGF0Y2hDb250ZW50O1xuICAgIH0sXG4gICAgICAgIGVycm9yQ291bnQgPSAwLFxuICAgICAgICBmdXp6RmFjdG9yID0gb3B0aW9ucy5mdXp6RmFjdG9yIHx8IDAsXG4gICAgICAgIG1pbkxpbmUgPSAwLFxuICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICByZW1vdmVFT0ZOTCxcbiAgICAgICAgYWRkRU9GTkw7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBodW5rIGV4YWN0bHkgZml0cyBvbiB0aGUgcHJvdmlkZWQgbG9jYXRpb25cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gaHVua0ZpdHMoaHVuaywgdG9Qb3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbGluZSA9IGh1bmsubGluZXNbal0sXG4gICAgICAgICAgICBvcGVyYXRpb24gPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lWzBdIDogJyAnLFxuICAgICAgICAgICAgY29udGVudCA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmUuc3Vic3RyKDEpIDogbGluZTtcblxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnICcgfHwgb3BlcmF0aW9uID09PSAnLScpIHtcbiAgICAgICAgICAvLyBDb250ZXh0IHNhbml0eSBjaGVja1xuICAgICAgICAgIGlmICghY29tcGFyZUxpbmUodG9Qb3MgKyAxLCBsaW5lc1t0b1Bvc10sIG9wZXJhdGlvbiwgY29udGVudCkpIHtcbiAgICAgICAgICAgIGVycm9yQ291bnQrKztcblxuICAgICAgICAgICAgaWYgKGVycm9yQ291bnQgPiBmdXp6RmFjdG9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b1BvcysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gU2VhcmNoIGJlc3QgZml0IG9mZnNldHMgZm9yIGVhY2ggaHVuayBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lc1xuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGh1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaHVuayA9IGh1bmtzW2ldLFxuICAgICAgICAgIG1heExpbmUgPSBsaW5lcy5sZW5ndGggLSBodW5rLm9sZExpbmVzLFxuICAgICAgICAgIGxvY2FsT2Zmc2V0ID0gMCxcbiAgICAgICAgICB0b1BvcyA9IG9mZnNldCArIGh1bmsub2xkU3RhcnQgLSAxO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gZGlzdGFuY2VJdGVyYXRvcih0b1BvcywgbWluTGluZSwgbWF4TGluZSk7XG5cbiAgICAgIGZvciAoOyBsb2NhbE9mZnNldCAhPT0gdW5kZWZpbmVkOyBsb2NhbE9mZnNldCA9IGl0ZXJhdG9yKCkpIHtcbiAgICAgICAgaWYgKGh1bmtGaXRzKGh1bmssIHRvUG9zICsgbG9jYWxPZmZzZXQpKSB7XG4gICAgICAgICAgaHVuay5vZmZzZXQgPSBvZmZzZXQgKz0gbG9jYWxPZmZzZXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2FsT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBTZXQgbG93ZXIgdGV4dCBsaW1pdCB0byBlbmQgb2YgdGhlIGN1cnJlbnQgaHVuaywgc28gbmV4dCBvbmVzIGRvbid0IHRyeVxuICAgICAgLy8gdG8gZml0IG92ZXIgYWxyZWFkeSBwYXRjaGVkIHRleHRcblxuXG4gICAgICBtaW5MaW5lID0gaHVuay5vZmZzZXQgKyBodW5rLm9sZFN0YXJ0ICsgaHVuay5vbGRMaW5lcztcbiAgICB9IC8vIEFwcGx5IHBhdGNoIGh1bmtzXG5cblxuICAgIHZhciBkaWZmT2Zmc2V0ID0gMDtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBodW5rcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaHVuayA9IGh1bmtzW19pXSxcbiAgICAgICAgICBfdG9Qb3MgPSBfaHVuay5vbGRTdGFydCArIF9odW5rLm9mZnNldCArIGRpZmZPZmZzZXQgLSAxO1xuXG4gICAgICBkaWZmT2Zmc2V0ICs9IF9odW5rLm5ld0xpbmVzIC0gX2h1bmsub2xkTGluZXM7XG5cbiAgICAgIGlmIChfdG9Qb3MgPCAwKSB7XG4gICAgICAgIC8vIENyZWF0aW5nIGEgbmV3IGZpbGVcbiAgICAgICAgX3RvUG9zID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbGluZSA9IF9odW5rLmxpbmVzW2pdLFxuICAgICAgICAgICAgb3BlcmF0aW9uID0gbGluZS5sZW5ndGggPiAwID8gbGluZVswXSA6ICcgJyxcbiAgICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmUsXG4gICAgICAgICAgICBkZWxpbWl0ZXIgPSBfaHVuay5saW5lZGVsaW1pdGVyc1tqXTtcblxuICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcbiAgICAgICAgICBfdG9Qb3MrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDEpO1xuICAgICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgIGxpbmVzLnNwbGljZShfdG9Qb3MsIDAsIGNvbnRlbnQpO1xuICAgICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMCwgZGVsaW1pdGVyKTtcbiAgICAgICAgICBfdG9Qb3MrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdcXFxcJykge1xuICAgICAgICAgIHZhciBwcmV2aW91c09wZXJhdGlvbiA9IF9odW5rLmxpbmVzW2ogLSAxXSA/IF9odW5rLmxpbmVzW2ogLSAxXVswXSA6IG51bGw7XG5cbiAgICAgICAgICBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICcrJykge1xuICAgICAgICAgICAgcmVtb3ZlRU9GTkwgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNPcGVyYXRpb24gPT09ICctJykge1xuICAgICAgICAgICAgYWRkRU9GTkwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSGFuZGxlIEVPRk5MIGluc2VydGlvbi9yZW1vdmFsXG5cblxuICAgIGlmIChyZW1vdmVFT0ZOTCkge1xuICAgICAgd2hpbGUgKCFsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSkge1xuICAgICAgICBsaW5lcy5wb3AoKTtcbiAgICAgICAgZGVsaW1pdGVycy5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XG4gICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgIGRlbGltaXRlcnMucHVzaCgnXFxuJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGxpbmVzLmxlbmd0aCAtIDE7IF9rKyspIHtcbiAgICAgIGxpbmVzW19rXSA9IGxpbmVzW19rXSArIGRlbGltaXRlcnNbX2tdO1xuICAgIH1cblxuICAgIHJldHVybiBsaW5lcy5qb2luKCcnKTtcbiAgfSAvLyBXcmFwcGVyIHRoYXQgc3VwcG9ydHMgbXVsdGlwbGUgZmlsZSBwYXRjaGVzIHZpYSBjYWxsYmFja3MuXG5cblxuICBmdW5jdGlvbiBhcHBseVBhdGNoZXModW5pRGlmZiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdW5pRGlmZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHVuaURpZmYgPSBwYXJzZVBhdGNoKHVuaURpZmYpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SW5kZXggPSAwO1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0luZGV4KCkge1xuICAgICAgdmFyIGluZGV4ID0gdW5pRGlmZltjdXJyZW50SW5kZXgrK107XG5cbiAgICAgIGlmICghaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5sb2FkRmlsZShpbmRleCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGRhdGVkQ29udGVudCA9IGFwcGx5UGF0Y2goZGF0YSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zLnBhdGNoZWQoaW5kZXgsIHVwZGF0ZWRDb250ZW50LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9jZXNzSW5kZXgoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm9jZXNzSW5kZXgoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy5jb250ZXh0ID0gNDtcbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGRpZmZMaW5lcyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XG4gICAgZGlmZi5wdXNoKHtcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIGxpbmVzOiBbXVxuICAgIH0pOyAvLyBBcHBlbmQgYW4gZW1wdHkgdmFsdWUgdG8gbWFrZSBjbGVhbnVwIGVhc2llclxuXG4gICAgZnVuY3Rpb24gY29udGV4dExpbmVzKGxpbmVzKSB7XG4gICAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICByZXR1cm4gJyAnICsgZW50cnk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaHVua3MgPSBbXTtcbiAgICB2YXIgb2xkUmFuZ2VTdGFydCA9IDAsXG4gICAgICAgIG5ld1JhbmdlU3RhcnQgPSAwLFxuICAgICAgICBjdXJSYW5nZSA9IFtdLFxuICAgICAgICBvbGRMaW5lID0gMSxcbiAgICAgICAgbmV3TGluZSA9IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGRpZmZbaV0sXG4gICAgICAgICAgbGluZXMgPSBjdXJyZW50LmxpbmVzIHx8IGN1cnJlbnQudmFsdWUucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgICBjdXJyZW50LmxpbmVzID0gbGluZXM7XG5cbiAgICAgIGlmIChjdXJyZW50LmFkZGVkIHx8IGN1cnJlbnQucmVtb3ZlZCkge1xuICAgICAgICB2YXIgX2N1clJhbmdlOyAvLyBJZiB3ZSBoYXZlIHByZXZpb3VzIGNvbnRleHQsIHN0YXJ0IHdpdGggdGhhdFxuXG5cbiAgICAgICAgaWYgKCFvbGRSYW5nZVN0YXJ0KSB7XG4gICAgICAgICAgdmFyIHByZXYgPSBkaWZmW2kgLSAxXTtcbiAgICAgICAgICBvbGRSYW5nZVN0YXJ0ID0gb2xkTGluZTtcbiAgICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gbmV3TGluZTtcblxuICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBjdXJSYW5nZSA9IG9wdGlvbnMuY29udGV4dCA+IDAgPyBjb250ZXh0TGluZXMocHJldi5saW5lcy5zbGljZSgtb3B0aW9ucy5jb250ZXh0KSkgOiBbXTtcbiAgICAgICAgICAgIG9sZFJhbmdlU3RhcnQgLT0gY3VyUmFuZ2UubGVuZ3RoO1xuICAgICAgICAgICAgbmV3UmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE91dHB1dCBvdXIgY2hhbmdlc1xuXG5cbiAgICAgICAgKF9jdXJSYW5nZSA9IGN1clJhbmdlKS5wdXNoLmFwcGx5KF9jdXJSYW5nZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gKGN1cnJlbnQuYWRkZWQgPyAnKycgOiAnLScpICsgZW50cnk7XG4gICAgICAgIH0pKSk7IC8vIFRyYWNrIHRoZSB1cGRhdGVkIGZpbGUgcG9zaXRpb25cblxuXG4gICAgICAgIGlmIChjdXJyZW50LmFkZGVkKSB7XG4gICAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElkZW50aWNhbCBjb250ZXh0IGxpbmVzLiBUcmFjayBsaW5lIGNoYW5nZXNcbiAgICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcbiAgICAgICAgICAvLyBDbG9zZSBvdXQgYW55IGNoYW5nZXMgdGhhdCBoYXZlIGJlZW4gb3V0cHV0IChvciBqb2luIG92ZXJsYXBwaW5nKVxuICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gb3B0aW9ucy5jb250ZXh0ICogMiAmJiBpIDwgZGlmZi5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICB2YXIgX2N1clJhbmdlMjsgLy8gT3ZlcmxhcHBpbmdcblxuXG4gICAgICAgICAgICAoX2N1clJhbmdlMiA9IGN1clJhbmdlKS5wdXNoLmFwcGx5KF9jdXJSYW5nZTIsIF90b0NvbnN1bWFibGVBcnJheShjb250ZXh0TGluZXMobGluZXMpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfY3VyUmFuZ2UzOyAvLyBlbmQgdGhlIHJhbmdlIGFuZCBvdXRwdXRcblxuXG4gICAgICAgICAgICB2YXIgY29udGV4dFNpemUgPSBNYXRoLm1pbihsaW5lcy5sZW5ndGgsIG9wdGlvbnMuY29udGV4dCk7XG5cbiAgICAgICAgICAgIChfY3VyUmFuZ2UzID0gY3VyUmFuZ2UpLnB1c2guYXBwbHkoX2N1clJhbmdlMywgX3RvQ29uc3VtYWJsZUFycmF5KGNvbnRleHRMaW5lcyhsaW5lcy5zbGljZSgwLCBjb250ZXh0U2l6ZSkpKSk7XG5cbiAgICAgICAgICAgIHZhciBodW5rID0ge1xuICAgICAgICAgICAgICBvbGRTdGFydDogb2xkUmFuZ2VTdGFydCxcbiAgICAgICAgICAgICAgb2xkTGluZXM6IG9sZExpbmUgLSBvbGRSYW5nZVN0YXJ0ICsgY29udGV4dFNpemUsXG4gICAgICAgICAgICAgIG5ld1N0YXJ0OiBuZXdSYW5nZVN0YXJ0LFxuICAgICAgICAgICAgICBuZXdMaW5lczogbmV3TGluZSAtIG5ld1JhbmdlU3RhcnQgKyBjb250ZXh0U2l6ZSxcbiAgICAgICAgICAgICAgbGluZXM6IGN1clJhbmdlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaSA+PSBkaWZmLmxlbmd0aCAtIDIgJiYgbGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgICAgICAvLyBFT0YgaXMgaW5zaWRlIHRoaXMgaHVua1xuICAgICAgICAgICAgICB2YXIgb2xkRU9GTmV3bGluZSA9IC9cXG4kLy50ZXN0KG9sZFN0cik7XG4gICAgICAgICAgICAgIHZhciBuZXdFT0ZOZXdsaW5lID0gL1xcbiQvLnRlc3QobmV3U3RyKTtcbiAgICAgICAgICAgICAgdmFyIG5vTmxCZWZvcmVBZGRzID0gbGluZXMubGVuZ3RoID09IDAgJiYgY3VyUmFuZ2UubGVuZ3RoID4gaHVuay5vbGRMaW5lcztcblxuICAgICAgICAgICAgICBpZiAoIW9sZEVPRk5ld2xpbmUgJiYgbm9ObEJlZm9yZUFkZHMpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9sZCBoYXMgbm8gZW9sIGFuZCBubyB0cmFpbGluZyBjb250ZXh0OyBuby1ubCBjYW4gZW5kIHVwIGJlZm9yZSBhZGRzXG4gICAgICAgICAgICAgICAgY3VyUmFuZ2Uuc3BsaWNlKGh1bmsub2xkTGluZXMsIDAsICdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghb2xkRU9GTmV3bGluZSAmJiAhbm9ObEJlZm9yZUFkZHMgfHwgIW5ld0VPRk5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBodW5rcy5wdXNoKGh1bmspO1xuICAgICAgICAgICAgb2xkUmFuZ2VTdGFydCA9IDA7XG4gICAgICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGN1clJhbmdlID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIG5ld0xpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9sb29wKGkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbGRGaWxlTmFtZTogb2xkRmlsZU5hbWUsXG4gICAgICBuZXdGaWxlTmFtZTogbmV3RmlsZU5hbWUsXG4gICAgICBvbGRIZWFkZXI6IG9sZEhlYWRlcixcbiAgICAgIG5ld0hlYWRlcjogbmV3SGVhZGVyLFxuICAgICAgaHVua3M6IGh1bmtzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVR3b0ZpbGVzUGF0Y2gob2xkRmlsZU5hbWUsIG5ld0ZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGlmZiA9IHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgaWYgKG9sZEZpbGVOYW1lID09IG5ld0ZpbGVOYW1lKSB7XG4gICAgICByZXQucHVzaCgnSW5kZXg6ICcgKyBvbGRGaWxlTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0LnB1c2goJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcbiAgICByZXQucHVzaCgnLS0tICcgKyBkaWZmLm9sZEZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm9sZEhlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5vbGRIZWFkZXIpKTtcbiAgICByZXQucHVzaCgnKysrICcgKyBkaWZmLm5ld0ZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm5ld0hlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXHQnICsgZGlmZi5uZXdIZWFkZXIpKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZi5odW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGh1bmsgPSBkaWZmLmh1bmtzW2ldO1xuICAgICAgcmV0LnB1c2goJ0BAIC0nICsgaHVuay5vbGRTdGFydCArICcsJyArIGh1bmsub2xkTGluZXMgKyAnICsnICsgaHVuay5uZXdTdGFydCArICcsJyArIGh1bmsubmV3TGluZXMgKyAnIEBAJyk7XG4gICAgICByZXQucHVzaC5hcHBseShyZXQsIGh1bmsubGluZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQuam9pbignXFxuJykgKyAnXFxuJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoKGZpbGVOYW1lLCBvbGRTdHIsIG5ld1N0ciwgb2xkSGVhZGVyLCBuZXdIZWFkZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlVHdvRmlsZXNQYXRjaChmaWxlTmFtZSwgZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBhcnJheUVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5U3RhcnRzV2l0aChhLCBiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5U3RhcnRzV2l0aChhcnJheSwgc3RhcnQpIHtcbiAgICBpZiAoc3RhcnQubGVuZ3RoID4gYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YXJ0W2ldICE9PSBhcnJheVtpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjTGluZUNvdW50KGh1bmspIHtcbiAgICB2YXIgX2NhbGNPbGROZXdMaW5lQ291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGh1bmsubGluZXMpLFxuICAgICAgICBvbGRMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm9sZExpbmVzLFxuICAgICAgICBuZXdMaW5lcyA9IF9jYWxjT2xkTmV3TGluZUNvdW50Lm5ld0xpbmVzO1xuXG4gICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGh1bmsub2xkTGluZXMgPSBvbGRMaW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGh1bmsub2xkTGluZXM7XG4gICAgfVxuXG4gICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGh1bmsubmV3TGluZXMgPSBuZXdMaW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIGh1bmsubmV3TGluZXM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2UobWluZSwgdGhlaXJzLCBiYXNlKSB7XG4gICAgbWluZSA9IGxvYWRQYXRjaChtaW5lLCBiYXNlKTtcbiAgICB0aGVpcnMgPSBsb2FkUGF0Y2godGhlaXJzLCBiYXNlKTtcbiAgICB2YXIgcmV0ID0ge307IC8vIEZvciBpbmRleCB3ZSBqdXN0IGxldCBpdCBwYXNzIHRocm91Z2ggYXMgaXQgZG9lc24ndCBoYXZlIGFueSBuZWNlc3NhcnkgbWVhbmluZy5cbiAgICAvLyBMZWF2aW5nIHNhbml0eSBjaGVja3Mgb24gdGhpcyB0byB0aGUgQVBJIGNvbnN1bWVyIHRoYXQgbWF5IGtub3cgbW9yZSBhYm91dCB0aGVcbiAgICAvLyBtZWFuaW5nIGluIHRoZWlyIG93biBjb250ZXh0LlxuXG4gICAgaWYgKG1pbmUuaW5kZXggfHwgdGhlaXJzLmluZGV4KSB7XG4gICAgICByZXQuaW5kZXggPSBtaW5lLmluZGV4IHx8IHRoZWlycy5pbmRleDtcbiAgICB9XG5cbiAgICBpZiAobWluZS5uZXdGaWxlTmFtZSB8fCB0aGVpcnMubmV3RmlsZU5hbWUpIHtcbiAgICAgIGlmICghZmlsZU5hbWVDaGFuZ2VkKG1pbmUpKSB7XG4gICAgICAgIC8vIE5vIGhlYWRlciBvciBubyBjaGFuZ2UgaW4gb3VycywgdXNlIHRoZWlycyAoYW5kIG91cnMgaWYgdGhlaXJzIGRvZXMgbm90IGV4aXN0KVxuICAgICAgICByZXQub2xkRmlsZU5hbWUgPSB0aGVpcnMub2xkRmlsZU5hbWUgfHwgbWluZS5vbGRGaWxlTmFtZTtcbiAgICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gdGhlaXJzLm5ld0ZpbGVOYW1lIHx8IG1pbmUubmV3RmlsZU5hbWU7XG4gICAgICAgIHJldC5vbGRIZWFkZXIgPSB0aGVpcnMub2xkSGVhZGVyIHx8IG1pbmUub2xkSGVhZGVyO1xuICAgICAgICByZXQubmV3SGVhZGVyID0gdGhlaXJzLm5ld0hlYWRlciB8fCBtaW5lLm5ld0hlYWRlcjtcbiAgICAgIH0gZWxzZSBpZiAoIWZpbGVOYW1lQ2hhbmdlZCh0aGVpcnMpKSB7XG4gICAgICAgIC8vIE5vIGhlYWRlciBvciBubyBjaGFuZ2UgaW4gdGhlaXJzLCB1c2Ugb3Vyc1xuICAgICAgICByZXQub2xkRmlsZU5hbWUgPSBtaW5lLm9sZEZpbGVOYW1lO1xuICAgICAgICByZXQubmV3RmlsZU5hbWUgPSBtaW5lLm5ld0ZpbGVOYW1lO1xuICAgICAgICByZXQub2xkSGVhZGVyID0gbWluZS5vbGRIZWFkZXI7XG4gICAgICAgIHJldC5uZXdIZWFkZXIgPSBtaW5lLm5ld0hlYWRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJvdGggY2hhbmdlZC4uLiBmaWd1cmUgaXQgb3V0XG4gICAgICAgIHJldC5vbGRGaWxlTmFtZSA9IHNlbGVjdEZpZWxkKHJldCwgbWluZS5vbGRGaWxlTmFtZSwgdGhlaXJzLm9sZEZpbGVOYW1lKTtcbiAgICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0ZpbGVOYW1lLCB0aGVpcnMubmV3RmlsZU5hbWUpO1xuICAgICAgICByZXQub2xkSGVhZGVyID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm9sZEhlYWRlciwgdGhlaXJzLm9sZEhlYWRlcik7XG4gICAgICAgIHJldC5uZXdIZWFkZXIgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUubmV3SGVhZGVyLCB0aGVpcnMubmV3SGVhZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXQuaHVua3MgPSBbXTtcbiAgICB2YXIgbWluZUluZGV4ID0gMCxcbiAgICAgICAgdGhlaXJzSW5kZXggPSAwLFxuICAgICAgICBtaW5lT2Zmc2V0ID0gMCxcbiAgICAgICAgdGhlaXJzT2Zmc2V0ID0gMDtcblxuICAgIHdoaWxlIChtaW5lSW5kZXggPCBtaW5lLmh1bmtzLmxlbmd0aCB8fCB0aGVpcnNJbmRleCA8IHRoZWlycy5odW5rcy5sZW5ndGgpIHtcbiAgICAgIHZhciBtaW5lQ3VycmVudCA9IG1pbmUuaHVua3NbbWluZUluZGV4XSB8fCB7XG4gICAgICAgIG9sZFN0YXJ0OiBJbmZpbml0eVxuICAgICAgfSxcbiAgICAgICAgICB0aGVpcnNDdXJyZW50ID0gdGhlaXJzLmh1bmtzW3RoZWlyc0luZGV4XSB8fCB7XG4gICAgICAgIG9sZFN0YXJ0OiBJbmZpbml0eVxuICAgICAgfTtcblxuICAgICAgaWYgKGh1bmtCZWZvcmUobWluZUN1cnJlbnQsIHRoZWlyc0N1cnJlbnQpKSB7XG4gICAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayhtaW5lQ3VycmVudCwgbWluZU9mZnNldCkpO1xuICAgICAgICBtaW5lSW5kZXgrKztcbiAgICAgICAgdGhlaXJzT2Zmc2V0ICs9IG1pbmVDdXJyZW50Lm5ld0xpbmVzIC0gbWluZUN1cnJlbnQub2xkTGluZXM7XG4gICAgICB9IGVsc2UgaWYgKGh1bmtCZWZvcmUodGhlaXJzQ3VycmVudCwgbWluZUN1cnJlbnQpKSB7XG4gICAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXG4gICAgICAgIHJldC5odW5rcy5wdXNoKGNsb25lSHVuayh0aGVpcnNDdXJyZW50LCB0aGVpcnNPZmZzZXQpKTtcbiAgICAgICAgdGhlaXJzSW5kZXgrKztcbiAgICAgICAgbWluZU9mZnNldCArPSB0aGVpcnNDdXJyZW50Lm5ld0xpbmVzIC0gdGhlaXJzQ3VycmVudC5vbGRMaW5lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE92ZXJsYXAsIG1lcmdlIGFzIGJlc3Qgd2UgY2FuXG4gICAgICAgIHZhciBtZXJnZWRIdW5rID0ge1xuICAgICAgICAgIG9sZFN0YXJ0OiBNYXRoLm1pbihtaW5lQ3VycmVudC5vbGRTdGFydCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCksXG4gICAgICAgICAgb2xkTGluZXM6IDAsXG4gICAgICAgICAgbmV3U3RhcnQ6IE1hdGgubWluKG1pbmVDdXJyZW50Lm5ld1N0YXJ0ICsgbWluZU9mZnNldCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCArIHRoZWlyc09mZnNldCksXG4gICAgICAgICAgbmV3TGluZXM6IDAsXG4gICAgICAgICAgbGluZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIG1lcmdlTGluZXMobWVyZ2VkSHVuaywgbWluZUN1cnJlbnQub2xkU3RhcnQsIG1pbmVDdXJyZW50LmxpbmVzLCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0LCB0aGVpcnNDdXJyZW50LmxpbmVzKTtcbiAgICAgICAgdGhlaXJzSW5kZXgrKztcbiAgICAgICAgbWluZUluZGV4Kys7XG4gICAgICAgIHJldC5odW5rcy5wdXNoKG1lcmdlZEh1bmspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkUGF0Y2gocGFyYW0sIGJhc2UpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKC9eQEAvbS50ZXN0KHBhcmFtKSB8fCAvXkluZGV4Oi9tLnRlc3QocGFyYW0pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVBhdGNoKHBhcmFtKVswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFiYXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgYmFzZSByZWZlcmVuY2Ugb3IgcGFzcyBpbiBhIHBhdGNoJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJ1Y3R1cmVkUGF0Y2godW5kZWZpbmVkLCB1bmRlZmluZWQsIGJhc2UsIHBhcmFtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW07XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlTmFtZUNoYW5nZWQocGF0Y2gpIHtcbiAgICByZXR1cm4gcGF0Y2gubmV3RmlsZU5hbWUgJiYgcGF0Y2gubmV3RmlsZU5hbWUgIT09IHBhdGNoLm9sZEZpbGVOYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0RmllbGQoaW5kZXgsIG1pbmUsIHRoZWlycykge1xuICAgIGlmIChtaW5lID09PSB0aGVpcnMpIHtcbiAgICAgIHJldHVybiBtaW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleC5jb25mbGljdCA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5lOiBtaW5lLFxuICAgICAgICB0aGVpcnM6IHRoZWlyc1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBodW5rQmVmb3JlKHRlc3QsIGNoZWNrKSB7XG4gICAgcmV0dXJuIHRlc3Qub2xkU3RhcnQgPCBjaGVjay5vbGRTdGFydCAmJiB0ZXN0Lm9sZFN0YXJ0ICsgdGVzdC5vbGRMaW5lcyA8IGNoZWNrLm9sZFN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVIdW5rKGh1bmssIG9mZnNldCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbGRTdGFydDogaHVuay5vbGRTdGFydCxcbiAgICAgIG9sZExpbmVzOiBodW5rLm9sZExpbmVzLFxuICAgICAgbmV3U3RhcnQ6IGh1bmsubmV3U3RhcnQgKyBvZmZzZXQsXG4gICAgICBuZXdMaW5lczogaHVuay5uZXdMaW5lcyxcbiAgICAgIGxpbmVzOiBodW5rLmxpbmVzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlTGluZXMoaHVuaywgbWluZU9mZnNldCwgbWluZUxpbmVzLCB0aGVpck9mZnNldCwgdGhlaXJMaW5lcykge1xuICAgIC8vIFRoaXMgd2lsbCBnZW5lcmFsbHkgcmVzdWx0IGluIGEgY29uZmxpY3RlZCBodW5rLCBidXQgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHRoZSBjb250ZXh0XG4gICAgLy8gaXMgdGhlIG9ubHkgb3ZlcmxhcCB3aGVyZSB3ZSBjYW4gc3VjY2Vzc2Z1bGx5IG1lcmdlIHRoZSBjb250ZW50IGhlcmUuXG4gICAgdmFyIG1pbmUgPSB7XG4gICAgICBvZmZzZXQ6IG1pbmVPZmZzZXQsXG4gICAgICBsaW5lczogbWluZUxpbmVzLFxuICAgICAgaW5kZXg6IDBcbiAgICB9LFxuICAgICAgICB0aGVpciA9IHtcbiAgICAgIG9mZnNldDogdGhlaXJPZmZzZXQsXG4gICAgICBsaW5lczogdGhlaXJMaW5lcyxcbiAgICAgIGluZGV4OiAwXG4gICAgfTsgLy8gSGFuZGxlIGFueSBsZWFkaW5nIGNvbnRlbnRcblxuICAgIGluc2VydExlYWRpbmcoaHVuaywgbWluZSwgdGhlaXIpO1xuICAgIGluc2VydExlYWRpbmcoaHVuaywgdGhlaXIsIG1pbmUpOyAvLyBOb3cgaW4gdGhlIG92ZXJsYXAgY29udGVudC4gU2NhbiB0aHJvdWdoIGFuZCBzZWxlY3QgdGhlIGJlc3QgY2hhbmdlcyBmcm9tIGVhY2guXG5cbiAgICB3aGlsZSAobWluZS5pbmRleCA8IG1pbmUubGluZXMubGVuZ3RoICYmIHRoZWlyLmluZGV4IDwgdGhlaXIubGluZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgbWluZUN1cnJlbnQgPSBtaW5lLmxpbmVzW21pbmUuaW5kZXhdLFxuICAgICAgICAgIHRoZWlyQ3VycmVudCA9IHRoZWlyLmxpbmVzW3RoZWlyLmluZGV4XTtcblxuICAgICAgaWYgKChtaW5lQ3VycmVudFswXSA9PT0gJy0nIHx8IG1pbmVDdXJyZW50WzBdID09PSAnKycpICYmICh0aGVpckN1cnJlbnRbMF0gPT09ICctJyB8fCB0aGVpckN1cnJlbnRbMF0gPT09ICcrJykpIHtcbiAgICAgICAgLy8gQm90aCBtb2RpZmllZCAuLi5cbiAgICAgICAgbXV0dWFsQ2hhbmdlKGh1bmssIG1pbmUsIHRoZWlyKTtcbiAgICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnRbMF0gPT09ICcrJyAmJiB0aGVpckN1cnJlbnRbMF0gPT09ICcgJykge1xuICAgICAgICB2YXIgX2h1bmskbGluZXM7IC8vIE1pbmUgaW5zZXJ0ZWRcblxuXG4gICAgICAgIChfaHVuayRsaW5lcyA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXMsIF90b0NvbnN1bWFibGVBcnJheShjb2xsZWN0Q2hhbmdlKG1pbmUpKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJysnICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgICAgdmFyIF9odW5rJGxpbmVzMjsgLy8gVGhlaXJzIGluc2VydGVkXG5cblxuICAgICAgICAoX2h1bmskbGluZXMyID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczIsIF90b0NvbnN1bWFibGVBcnJheShjb2xsZWN0Q2hhbmdlKHRoZWlyKSkpO1xuICAgICAgfSBlbHNlIGlmIChtaW5lQ3VycmVudFswXSA9PT0gJy0nICYmIHRoZWlyQ3VycmVudFswXSA9PT0gJyAnKSB7XG4gICAgICAgIC8vIE1pbmUgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgICAgcmVtb3ZhbChodW5rLCBtaW5lLCB0aGVpcik7XG4gICAgICB9IGVsc2UgaWYgKHRoZWlyQ3VycmVudFswXSA9PT0gJy0nICYmIG1pbmVDdXJyZW50WzBdID09PSAnICcpIHtcbiAgICAgICAgLy8gVGhlaXIgcmVtb3ZlZCBvciBlZGl0ZWRcbiAgICAgICAgcmVtb3ZhbChodW5rLCB0aGVpciwgbWluZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50ID09PSB0aGVpckN1cnJlbnQpIHtcbiAgICAgICAgLy8gQ29udGV4dCBpZGVudGl0eVxuICAgICAgICBodW5rLmxpbmVzLnB1c2gobWluZUN1cnJlbnQpO1xuICAgICAgICBtaW5lLmluZGV4Kys7XG4gICAgICAgIHRoZWlyLmluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb250ZXh0IG1pc21hdGNoXG4gICAgICAgIGNvbmZsaWN0KGh1bmssIGNvbGxlY3RDaGFuZ2UobWluZSksIGNvbGxlY3RDaGFuZ2UodGhlaXIpKTtcbiAgICAgIH1cbiAgICB9IC8vIE5vdyBwdXNoIGFueXRoaW5nIHRoYXQgbWF5IGJlIHJlbWFpbmluZ1xuXG5cbiAgICBpbnNlcnRUcmFpbGluZyhodW5rLCBtaW5lKTtcbiAgICBpbnNlcnRUcmFpbGluZyhodW5rLCB0aGVpcik7XG4gICAgY2FsY0xpbmVDb3VudChodW5rKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcikge1xuICAgIHZhciBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxuICAgICAgICB0aGVpckNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKHRoZWlyKTtcblxuICAgIGlmIChhbGxSZW1vdmVzKG15Q2hhbmdlcykgJiYgYWxsUmVtb3Zlcyh0aGVpckNoYW5nZXMpKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHJlbW92ZSBjaGFuZ2VzIHRoYXQgYXJlIHN1cGVyc2V0cyBvZiBvbmUgYW5vdGhlclxuICAgICAgaWYgKGFycmF5U3RhcnRzV2l0aChteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykgJiYgc2tpcFJlbW92ZVN1cGVyc2V0KHRoZWlyLCBteUNoYW5nZXMsIG15Q2hhbmdlcy5sZW5ndGggLSB0aGVpckNoYW5nZXMubGVuZ3RoKSkge1xuICAgICAgICB2YXIgX2h1bmskbGluZXMzO1xuXG4gICAgICAgIChfaHVuayRsaW5lczMgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzMywgX3RvQ29uc3VtYWJsZUFycmF5KG15Q2hhbmdlcykpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXlTdGFydHNXaXRoKHRoZWlyQ2hhbmdlcywgbXlDaGFuZ2VzKSAmJiBza2lwUmVtb3ZlU3VwZXJzZXQobWluZSwgdGhlaXJDaGFuZ2VzLCB0aGVpckNoYW5nZXMubGVuZ3RoIC0gbXlDaGFuZ2VzLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIF9odW5rJGxpbmVzNDtcblxuICAgICAgICAoX2h1bmskbGluZXM0ID0gaHVuay5saW5lcykucHVzaC5hcHBseShfaHVuayRsaW5lczQsIF90b0NvbnN1bWFibGVBcnJheSh0aGVpckNoYW5nZXMpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcnJheUVxdWFsKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSkge1xuICAgICAgdmFyIF9odW5rJGxpbmVzNTtcblxuICAgICAgKF9odW5rJGxpbmVzNSA9IGh1bmsubGluZXMpLnB1c2guYXBwbHkoX2h1bmskbGluZXM1LCBfdG9Db25zdW1hYmxlQXJyYXkobXlDaGFuZ2VzKSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25mbGljdChodW5rLCBteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcyk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmFsKGh1bmssIG1pbmUsIHRoZWlyLCBzd2FwKSB7XG4gICAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXG4gICAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDb250ZXh0KHRoZWlyLCBteUNoYW5nZXMpO1xuXG4gICAgaWYgKHRoZWlyQ2hhbmdlcy5tZXJnZWQpIHtcbiAgICAgIHZhciBfaHVuayRsaW5lczY7XG5cbiAgICAgIChfaHVuayRsaW5lczYgPSBodW5rLmxpbmVzKS5wdXNoLmFwcGx5KF9odW5rJGxpbmVzNiwgX3RvQ29uc3VtYWJsZUFycmF5KHRoZWlyQ2hhbmdlcy5tZXJnZWQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmxpY3QoaHVuaywgc3dhcCA/IHRoZWlyQ2hhbmdlcyA6IG15Q2hhbmdlcywgc3dhcCA/IG15Q2hhbmdlcyA6IHRoZWlyQ2hhbmdlcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29uZmxpY3QoaHVuaywgbWluZSwgdGhlaXIpIHtcbiAgICBodW5rLmNvbmZsaWN0ID0gdHJ1ZTtcbiAgICBodW5rLmxpbmVzLnB1c2goe1xuICAgICAgY29uZmxpY3Q6IHRydWUsXG4gICAgICBtaW5lOiBtaW5lLFxuICAgICAgdGhlaXJzOiB0aGVpclxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0TGVhZGluZyhodW5rLCBpbnNlcnQsIHRoZWlyKSB7XG4gICAgd2hpbGUgKGluc2VydC5vZmZzZXQgPCB0aGVpci5vZmZzZXQgJiYgaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xuICAgICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xuICAgICAgaHVuay5saW5lcy5wdXNoKGxpbmUpO1xuICAgICAgaW5zZXJ0Lm9mZnNldCsrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydFRyYWlsaW5nKGh1bmssIGluc2VydCkge1xuICAgIHdoaWxlIChpbnNlcnQuaW5kZXggPCBpbnNlcnQubGluZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XG4gICAgICBodW5rLmxpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdENoYW5nZShzdGF0ZSkge1xuICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgb3BlcmF0aW9uID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdWzBdO1xuXG4gICAgd2hpbGUgKHN0YXRlLmluZGV4IDwgc3RhdGUubGluZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgbGluZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XTsgLy8gR3JvdXAgYWRkaXRpb25zIHRoYXQgYXJlIGltbWVkaWF0ZWx5IGFmdGVyIHN1YnRyYWN0aW9ucyBhbmQgdHJlYXQgdGhlbSBhcyBvbmUgXCJhdG9taWNcIiBtb2RpZnkgY2hhbmdlLlxuXG4gICAgICBpZiAob3BlcmF0aW9uID09PSAnLScgJiYgbGluZVswXSA9PT0gJysnKSB7XG4gICAgICAgIG9wZXJhdGlvbiA9ICcrJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gbGluZVswXSkge1xuICAgICAgICByZXQucHVzaChsaW5lKTtcbiAgICAgICAgc3RhdGUuaW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0Q29udGV4dChzdGF0ZSwgbWF0Y2hDaGFuZ2VzKSB7XG4gICAgdmFyIGNoYW5nZXMgPSBbXSxcbiAgICAgICAgbWVyZ2VkID0gW10sXG4gICAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgICBjb250ZXh0Q2hhbmdlcyA9IGZhbHNlLFxuICAgICAgICBjb25mbGljdGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGggJiYgc3RhdGUuaW5kZXggPCBzdGF0ZS5saW5lcy5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBzdGF0ZS5saW5lc1tzdGF0ZS5pbmRleF0sXG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF07IC8vIE9uY2Ugd2UndmUgaGl0IG91ciBhZGQsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgICAgaWYgKG1hdGNoWzBdID09PSAnKycpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHRDaGFuZ2VzID0gY29udGV4dENoYW5nZXMgfHwgY2hhbmdlWzBdICE9PSAnICc7XG4gICAgICBtZXJnZWQucHVzaChtYXRjaCk7XG4gICAgICBtYXRjaEluZGV4Kys7IC8vIENvbnN1bWUgYW55IGFkZGl0aW9ucyBpbiB0aGUgb3RoZXIgYmxvY2sgYXMgYSBjb25mbGljdCB0byBhdHRlbXB0XG4gICAgICAvLyB0byBwdWxsIGluIHRoZSByZW1haW5pbmcgY29udGV4dCBhZnRlciB0aGlzXG5cbiAgICAgIGlmIChjaGFuZ2VbMF0gPT09ICcrJykge1xuICAgICAgICBjb25mbGljdGVkID0gdHJ1ZTtcblxuICAgICAgICB3aGlsZSAoY2hhbmdlWzBdID09PSAnKycpIHtcbiAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICBjaGFuZ2UgPSBzdGF0ZS5saW5lc1srK3N0YXRlLmluZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2guc3Vic3RyKDEpID09PSBjaGFuZ2Uuc3Vic3RyKDEpKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICBzdGF0ZS5pbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmxpY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF0gfHwgJycpWzBdID09PSAnKycgJiYgY29udGV4dENoYW5nZXMpIHtcbiAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjb25mbGljdGVkKSB7XG4gICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG5cbiAgICB3aGlsZSAobWF0Y2hJbmRleCA8IG1hdGNoQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIG1lcmdlZC5wdXNoKG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4KytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWVyZ2VkOiBtZXJnZWQsXG4gICAgICBjaGFuZ2VzOiBjaGFuZ2VzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbFJlbW92ZXMoY2hhbmdlcykge1xuICAgIHJldHVybiBjaGFuZ2VzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY2hhbmdlKSB7XG4gICAgICByZXR1cm4gcHJldiAmJiBjaGFuZ2VbMF0gPT09ICctJztcbiAgICB9LCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBSZW1vdmVTdXBlcnNldChzdGF0ZSwgcmVtb3ZlQ2hhbmdlcywgZGVsdGEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbHRhOyBpKyspIHtcbiAgICAgIHZhciBjaGFuZ2VDb250ZW50ID0gcmVtb3ZlQ2hhbmdlc1tyZW1vdmVDaGFuZ2VzLmxlbmd0aCAtIGRlbHRhICsgaV0uc3Vic3RyKDEpO1xuXG4gICAgICBpZiAoc3RhdGUubGluZXNbc3RhdGUuaW5kZXggKyBpXSAhPT0gJyAnICsgY2hhbmdlQ29udGVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUuaW5kZXggKz0gZGVsdGE7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmVzKSB7XG4gICAgdmFyIG9sZExpbmVzID0gMDtcbiAgICB2YXIgbmV3TGluZXMgPSAwO1xuICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG15Q291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUubWluZSk7XG4gICAgICAgIHZhciB0aGVpckNvdW50ID0gY2FsY09sZE5ld0xpbmVDb3VudChsaW5lLnRoZWlycyk7XG5cbiAgICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobXlDb3VudC5vbGRMaW5lcyA9PT0gdGhlaXJDb3VudC5vbGRMaW5lcykge1xuICAgICAgICAgICAgb2xkTGluZXMgKz0gbXlDb3VudC5vbGRMaW5lcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2xkTGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobXlDb3VudC5uZXdMaW5lcyA9PT0gdGhlaXJDb3VudC5uZXdMaW5lcykge1xuICAgICAgICAgICAgbmV3TGluZXMgKz0gbXlDb3VudC5uZXdMaW5lcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGluZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCAmJiAobGluZVswXSA9PT0gJysnIHx8IGxpbmVbMF0gPT09ICcgJykpIHtcbiAgICAgICAgICBuZXdMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9sZExpbmVzICE9PSB1bmRlZmluZWQgJiYgKGxpbmVbMF0gPT09ICctJyB8fCBsaW5lWzBdID09PSAnICcpKSB7XG4gICAgICAgICAgb2xkTGluZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBvbGRMaW5lczogb2xkTGluZXMsXG4gICAgICBuZXdMaW5lczogbmV3TGluZXNcbiAgICB9O1xuICB9IC8vIFNlZTogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvQVBJXG5cblxuICBmdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvRE1QKGNoYW5nZXMpIHtcbiAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgIGNoYW5nZSxcbiAgICAgICAgb3BlcmF0aW9uO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuXG4gICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICAgIG9wZXJhdGlvbiA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICAgIG9wZXJhdGlvbiA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BlcmF0aW9uID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0LnB1c2goW29wZXJhdGlvbiwgY2hhbmdlLnZhbHVlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9YTUwoY2hhbmdlcykge1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbaV07XG5cbiAgICAgIGlmIChjaGFuZ2UuYWRkZWQpIHtcbiAgICAgICAgcmV0LnB1c2goJzxpbnM+Jyk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XG4gICAgICAgIHJldC5wdXNoKCc8ZGVsPicpO1xuICAgICAgfVxuXG4gICAgICByZXQucHVzaChlc2NhcGVIVE1MKGNoYW5nZS52YWx1ZSkpO1xuXG4gICAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XG4gICAgICAgIHJldC5wdXNoKCc8L2lucz4nKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbmdlLnJlbW92ZWQpIHtcbiAgICAgICAgcmV0LnB1c2goJzwvZGVsPicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQuam9pbignJyk7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVIVE1MKHMpIHtcbiAgICB2YXIgbiA9IHM7XG4gICAgbiA9IG4ucmVwbGFjZSgvJi9nLCAnJmFtcDsnKTtcbiAgICBuID0gbi5yZXBsYWNlKC88L2csICcmbHQ7Jyk7XG4gICAgbiA9IG4ucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuICAgIG4gPSBuLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHZhciBpbmRleF9lczYgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIERpZmY6IERpZmYsXG4gICAgZGlmZkNoYXJzOiBkaWZmQ2hhcnMsXG4gICAgZGlmZldvcmRzOiBkaWZmV29yZHMsXG4gICAgZGlmZldvcmRzV2l0aFNwYWNlOiBkaWZmV29yZHNXaXRoU3BhY2UsXG4gICAgZGlmZkxpbmVzOiBkaWZmTGluZXMsXG4gICAgZGlmZlRyaW1tZWRMaW5lczogZGlmZlRyaW1tZWRMaW5lcyxcbiAgICBkaWZmU2VudGVuY2VzOiBkaWZmU2VudGVuY2VzLFxuICAgIGRpZmZDc3M6IGRpZmZDc3MsXG4gICAgZGlmZkpzb246IGRpZmZKc29uLFxuICAgIGRpZmZBcnJheXM6IGRpZmZBcnJheXMsXG4gICAgc3RydWN0dXJlZFBhdGNoOiBzdHJ1Y3R1cmVkUGF0Y2gsXG4gICAgY3JlYXRlVHdvRmlsZXNQYXRjaDogY3JlYXRlVHdvRmlsZXNQYXRjaCxcbiAgICBjcmVhdGVQYXRjaDogY3JlYXRlUGF0Y2gsXG4gICAgYXBwbHlQYXRjaDogYXBwbHlQYXRjaCxcbiAgICBhcHBseVBhdGNoZXM6IGFwcGx5UGF0Y2hlcyxcbiAgICBwYXJzZVBhdGNoOiBwYXJzZVBhdGNoLFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBjb252ZXJ0Q2hhbmdlc1RvRE1QOiBjb252ZXJ0Q2hhbmdlc1RvRE1QLFxuICAgIGNvbnZlcnRDaGFuZ2VzVG9YTUw6IGNvbnZlcnRDaGFuZ2VzVG9YTUwsXG4gICAgY2Fub25pY2FsaXplOiBjYW5vbmljYWxpemVcbiAgfSk7XG5cbiAgdmFyIF9zaGltX2ZzID0ge307XG5cbiAgdmFyIF9zaGltX2ZzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgICdkZWZhdWx0JzogX3NoaW1fZnNcbiAgfSk7XG5cbiAgY29uc3Qgc2VwID0gL1tcXFxcL10vO1xuICBmdW5jdGlvbiBleHRuYW1lKHBhdGgpIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGJhc2VuYW1lKHBhdGgpO1xuICAgIGNvbnN0IGRvdEluZGV4ID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChkb3RJbmRleCA9PT0gLTEpIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBmaWxlbmFtZS5zbGljZShkb3RJbmRleCk7XG4gIH1cbiAgZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnNwbGl0KHNlcCkucG9wKCk7XG4gIH1cbiAgZnVuY3Rpb24gaXNBYnNvbHV0ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwYXRoID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBleHRuYW1lOiBleHRuYW1lLFxuICAgIGJhc2VuYW1lOiBiYXNlbmFtZSxcbiAgICBpc0Fic29sdXRlOiBpc0Fic29sdXRlXG4gIH0pO1xuXG4gIHZhciBnbG9iYWwkMSA9IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge307XG5cbiAgdmFyIGxvb2t1cCA9IFtdO1xuICB2YXIgcmV2TG9va3VwID0gW107XG4gIHZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXk7XG4gIHZhciBpbml0ZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGluaXRlZCA9IHRydWU7XG4gICAgdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgbG9va3VwW2ldID0gY29kZVtpXTtcbiAgICAgIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgICB9XG5cbiAgICByZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjI7XG4gICAgcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9CeXRlQXJyYXkoYjY0KSB7XG4gICAgaWYgKCFpbml0ZWQpIHtcbiAgICAgIGluaXQoKTtcbiAgICB9XG5cbiAgICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFycjtcbiAgICB2YXIgbGVuID0gYjY0Lmxlbmd0aDtcblxuICAgIGlmIChsZW4gJSA0ID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jyk7XG4gICAgfSAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cblxuICAgIHBsYWNlSG9sZGVycyA9IGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDA7IC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXG4gICAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycyk7IC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblxuICAgIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlbjtcbiAgICB2YXIgTCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgICBhcnJbTCsrXSA9IHRtcCA+PiAxNiAmIDB4RkY7XG4gICAgICBhcnJbTCsrXSA9IHRtcCA+PiA4ICYgMHhGRjtcbiAgICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG4gICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0O1xuICAgICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICAgIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDI7XG4gICAgICBhcnJbTCsrXSA9IHRtcCA+PiA4ICYgMHhGRjtcbiAgICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkge1xuICAgIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZUNodW5rKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHRtcDtcbiAgICB2YXIgb3V0cHV0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyB1aW50OFtpICsgMl07XG4gICAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21CeXRlQXJyYXkodWludDgpIHtcbiAgICBpZiAoIWluaXRlZCkge1xuICAgICAgaW5pdCgpO1xuICAgIH1cblxuICAgIHZhciB0bXA7XG4gICAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aDtcbiAgICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDM7IC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cbiAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7IC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuICAgIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIGkgKyBtYXhDaHVua0xlbmd0aCA+IGxlbjIgPyBsZW4yIDogaSArIG1heENodW5rTGVuZ3RoKSk7XG4gICAgfSAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cblxuICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgICB0bXAgPSB1aW50OFtsZW4gLSAxXTtcbiAgICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdO1xuICAgICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPDwgNCAmIDB4M0ZdO1xuICAgICAgb3V0cHV0ICs9ICc9PSc7XG4gICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXTtcbiAgICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXTtcbiAgICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDQgJiAweDNGXTtcbiAgICAgIG91dHB1dCArPSBsb29rdXBbdG1wIDw8IDIgJiAweDNGXTtcbiAgICAgIG91dHB1dCArPSAnPSc7XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChvdXRwdXQpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICAgIHZhciBlLCBtO1xuICAgIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxO1xuICAgIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxO1xuICAgIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgICB2YXIgbkJpdHMgPSAtNztcbiAgICB2YXIgaSA9IGlzTEUgPyBuQnl0ZXMgLSAxIDogMDtcbiAgICB2YXIgZCA9IGlzTEUgPyAtMSA6IDE7XG4gICAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG4gICAgaSArPSBkO1xuICAgIGUgPSBzICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gICAgcyA+Pj0gLW5CaXRzO1xuICAgIG5CaXRzICs9IGVMZW47XG5cbiAgICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gICAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgICBlID4+PSAtbkJpdHM7XG4gICAgbkJpdHMgKz0gbUxlbjtcblxuICAgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgICBpZiAoZSA9PT0gMCkge1xuICAgICAgZSA9IDEgLSBlQmlhcztcbiAgICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICAgIHJldHVybiBtID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSAtIGVCaWFzO1xuICAgIH1cblxuICAgIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gICAgdmFyIGUsIG0sIGM7XG4gICAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDE7XG4gICAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gICAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICAgIHZhciBydCA9IG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwO1xuICAgIHZhciBpID0gaXNMRSA/IDAgOiBuQnl0ZXMgLSAxO1xuICAgIHZhciBkID0gaXNMRSA/IDEgOiAtMTtcbiAgICB2YXIgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG4gICAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcblxuICAgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgICBlLS07XG4gICAgICAgIGMgKj0gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICAgIGUrKztcbiAgICAgICAgYyAvPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgICAgbSA9IDA7XG4gICAgICAgIGUgPSBlTWF4O1xuICAgICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICAgIGUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgICBlID0gZSA8PCBtTGVuIHwgbTtcbiAgICBlTGVuICs9IG1MZW47XG5cbiAgICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG4gIH1cblxuICB2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgdmFyIElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG4gIC8qKlxuICAgKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICAgKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICAgKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gICAqXG4gICAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAgICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICAgKlxuICAgKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gICAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICAgKlxuICAgKiBOb3RlOlxuICAgKlxuICAgKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICAgKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gICAqXG4gICAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICAgKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAgICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAgICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gICAqL1xuXG4gIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkID8gZ2xvYmFsJDEuVFlQRURfQVJSQVlfU1VQUE9SVCA6IHRydWU7XG5cbiAgZnVuY3Rpb24ga01heExlbmd0aCgpIHtcbiAgICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAweDdmZmZmZmZmIDogMHgzZmZmZmZmZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpIHtcbiAgICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB0aGF0O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAgICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICAgKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gICAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gICAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gICAqXG4gICAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgICB9IC8vIENvbW1vbiBjYXNlLlxuXG5cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gIH1cbiAgQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuICAvLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cblxuICBCdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBmdW5jdGlvbiBmcm9tKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAgICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gICAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAgICogQnVmZmVyLmZyb20oYXJyYXkpXG4gICAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAgICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gICAqKi9cblxuXG4gIEJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlO1xuICAgIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0U2l6ZShzaXplKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG9jKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gICAgYXNzZXJ0U2l6ZShzaXplKTtcblxuICAgIGlmIChzaXplIDw9IDApIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICAgKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gICAqKi9cblxuXG4gIEJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICAgIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gYWxsb2NVbnNhZmUodGhhdCwgc2l6ZSkge1xuICAgIGFzc2VydFNpemUoc2l6ZSk7XG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMCk7XG5cbiAgICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgICB0aGF0W2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhhdDtcbiAgfVxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAgICogKi9cblxuXG4gIEJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpO1xuICB9O1xuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gICAqL1xuXG5cbiAgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZyb21TdHJpbmcodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgfVxuXG4gICAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKTtcbiAgICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKTtcblxuICAgIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGF0O1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDA7XG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICAgIH1cblxuICAgIHJldHVybiB0aGF0O1xuICB9XG5cbiAgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cblxuICAgIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cblxuICAgIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgICB0aGF0ID0gYXJyYXk7XG4gICAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhhdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyb21PYmplY3QodGhhdCwgb2JqKSB7XG4gICAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwO1xuICAgICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pO1xuXG4gICAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9XG5cbiAgICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbik7XG4gICAgICByZXR1cm4gdGhhdDtcbiAgICB9XG5cbiAgICBpZiAob2JqKSB7XG4gICAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tlZChsZW5ndGgpIHtcbiAgICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpO1xuICAgIH1cblxuICAgIHJldHVybiBsZW5ndGggfCAwO1xuICB9XG4gIEJ1ZmZlci5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuXG4gIGZ1bmN0aW9uIGludGVybmFsSXNCdWZmZXIoYikge1xuICAgIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xuICB9XG5cbiAgQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoIWludGVybmFsSXNCdWZmZXIoYSkgfHwgIWludGVybmFsSXNCdWZmZXIoYikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKTtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIDA7XG4gICAgdmFyIHggPSBhLmxlbmd0aDtcbiAgICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgIHggPSBhW2ldO1xuICAgICAgICB5ID0gYltpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHggPCB5KSByZXR1cm4gLTE7XG4gICAgaWYgKHkgPCB4KSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICBCdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChsaXN0LCBsZW5ndGgpIHtcbiAgICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO1xuICAgIH1cblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcblxuICAgIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgICB2YXIgcG9zID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcblxuICAgICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgICB9XG5cbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgZnVuY3Rpb24gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB7XG4gICAgaWYgKGludGVybmFsSXNCdWZmZXIoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAwKSByZXR1cm4gMDsgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG5cbiAgICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgIHJldHVybiBsZW47XG5cbiAgICAgICAgY2FzZSAndXRmOCc6XG4gICAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoO1xuXG4gICAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgICBjYXNlICd1Y3MtMic6XG4gICAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgICAgcmV0dXJuIGxlbiAqIDI7XG5cbiAgICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgICByZXR1cm4gbGVuID4+PiAxO1xuXG4gICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGg7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aDsgLy8gYXNzdW1lIHV0ZjhcblxuICAgICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIEJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcblxuICBmdW5jdGlvbiBzbG93VG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTsgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gICAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cbiAgICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cblxuICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH0gLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuXG5cbiAgICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKGVuZCA8PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuXG5cbiAgICBlbmQgPj4+PSAwO1xuICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKTtcblxuICAgICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgICAgY2FzZSAndWNzMic6XG4gICAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICAgICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuICAvLyBCdWZmZXIgaW5zdGFuY2VzLlxuXG5cbiAgQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHN3YXAoYiwgbiwgbSkge1xuICAgIHZhciBpID0gYltuXTtcbiAgICBiW25dID0gYlttXTtcbiAgICBiW21dID0gaTtcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2KCkge1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICAgIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICAgIHN3YXAodGhpcywgaSwgaSArIDcpO1xuICAgICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpO1xuICAgICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuICAgICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpO1xuICAgIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhiKSB7XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJyk7XG4gICAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMDtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB2YXIgbWF4ID0gSU5TUEVDVF9NQVhfQllURVM7XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICc7XG4gICAgfVxuXG4gICAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPic7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICAgIGlmICghaW50ZXJuYWxJc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpc1N0YXJ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgc3RhcnQgPj4+PSAwO1xuICAgIGVuZCA+Pj49IDA7XG4gICAgdGhpc1N0YXJ0ID4+Pj0gMDtcbiAgICB0aGlzRW5kID4+Pj0gMDtcbiAgICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMDtcbiAgICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7XG4gICAgdmFyIHkgPSBlbmQgLSBzdGFydDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSk7XG4gICAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpO1xuICAgIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICAgIHggPSB0aGlzQ29weVtpXTtcbiAgICAgICAgeSA9IHRhcmdldENvcHlbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICAgIGlmICh5IDwgeCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH07IC8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbiAgLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbiAgLy9cbiAgLy8gQXJndW1lbnRzOlxuICAvLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuICAvLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuICAvLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbiAgLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbiAgLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcblxuXG4gIGZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gICAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMTsgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcblxuICAgIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICAgIGJ5dGVPZmZzZXQgPSAwO1xuICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmO1xuICAgIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDA7XG4gICAgfVxuXG4gICAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OyAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuXG4gICAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgfSAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuXG5cbiAgICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldDtcblxuICAgIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGlmIChkaXIpIHJldHVybiAtMTtlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMDtlbHNlIHJldHVybiAtMTtcbiAgICB9IC8vIE5vcm1hbGl6ZSB2YWxcblxuXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKTtcbiAgICB9IC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG5cblxuICAgIGlmIChpbnRlcm5hbElzQnVmZmVyKHZhbCkpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsID0gdmFsICYgMHhGRjsgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuXG4gICAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gICAgdmFyIGluZGV4U2l6ZSA9IDE7XG4gICAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XG5cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8IGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhTaXplID0gMjtcbiAgICAgICAgYXJyTGVuZ3RoIC89IDI7XG4gICAgICAgIHZhbExlbmd0aCAvPSAyO1xuICAgICAgICBieXRlT2Zmc2V0IC89IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZChidWYsIGkpIHtcbiAgICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZltpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpO1xuXG4gICAgaWYgKGRpcikge1xuICAgICAgdmFyIGZvdW5kSW5kZXggPSAtMTtcblxuICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4O1xuICAgICAgICAgIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aDtcblxuICAgICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGZvdW5kID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSk7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGhleFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDA7XG4gICAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7XG5cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgICBsZW5ndGggPSByZW1haW5pbmc7XG4gICAgICB9XG4gICAgfSAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuXG5cbiAgICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG5cbiAgICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaTtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0ZjhXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGF0aW4xV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhc2U2NFdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBmdW5jdGlvbiB1Y3MyV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH1cblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgIG9mZnNldCA9IDA7IC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICBvZmZzZXQgPSAwOyAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICAgIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcblxuICAgICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMDtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gICAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nO1xuXG4gICAgaWYgKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4JztcbiAgICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICAgICAgY2FzZSAndXRmOCc6XG4gICAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgICBjYXNlICd1Y3MtMic6XG4gICAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdCdWZmZXInLFxuICAgICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBiYXNlNjRTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHV0ZjhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IHN0YXJ0O1xuXG4gICAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV07XG4gICAgICB2YXIgY29kZVBvaW50ID0gbnVsbDtcbiAgICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gZmlyc3RCeXRlID4gMHhFRiA/IDQgOiBmaXJzdEJ5dGUgPiAweERGID8gMyA6IGZpcnN0Qnl0ZSA+IDB4QkYgPyAyIDogMTtcblxuICAgICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuXG4gICAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcblxuICAgICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCBzZWNvbmRCeXRlICYgMHgzRjtcblxuICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuXG4gICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgdGhpcmRCeXRlICYgMHgzRjtcblxuICAgICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdO1xuICAgICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdO1xuXG4gICAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IGZvdXJ0aEJ5dGUgJiAweDNGO1xuXG4gICAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG4gICAgICB9XG5cbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCk7XG4gICAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpO1xuICB9IC8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuICAvLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4gIC8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcblxuXG4gIHZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMDtcblxuICBmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoY29kZVBvaW50cykge1xuICAgIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aDtcblxuICAgIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cyk7IC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgICB9IC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cblxuXG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBmdW5jdGlvbiBhc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgIHZhciByZXQgPSAnJztcbiAgICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBsYXRpbjFTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG4gICAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoZXhTbGljZShidWYsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcbiAgICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICAgIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG4gICAgdmFyIG91dCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIG91dCArPSB0b0hleChidWZbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICBmdW5jdGlvbiB1dGYxNmxlU2xpY2UoYnVmLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHZhciByZXMgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gICAgc3RhcnQgPSB+fnN0YXJ0O1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQ7XG5cbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICBzdGFydCArPSBsZW47XG4gICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gICAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgICAgc3RhcnQgPSBsZW47XG4gICAgfVxuXG4gICAgaWYgKGVuZCA8IDApIHtcbiAgICAgIGVuZCArPSBsZW47XG4gICAgICBpZiAoZW5kIDwgMCkgZW5kID0gMDtcbiAgICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgICAgZW5kID0gbGVuO1xuICAgIH1cblxuICAgIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG4gICAgdmFyIG5ld0J1ZjtcblxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0J1ZjtcbiAgfTtcbiAgLypcbiAgICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY2hlY2tPZmZzZXQob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICAgIGlmIChvZmZzZXQgJSAxICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKTtcbiAgICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRShvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgICB2YXIgbXVsID0gMTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcblxuICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF07XG4gICAgdmFyIG11bCA9IDE7XG5cbiAgICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgODtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAxXTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuICh0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2KSArIHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDA7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzW29mZnNldF0gKiAweDEwMDAwMDAgKyAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM10pO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICAgIHZhciBtdWwgPSAxO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgICB9XG5cbiAgICBtdWwgKj0gMHg4MDtcbiAgICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgaSA9IGJ5dGVMZW5ndGg7XG4gICAgdmFyIG11bCA9IDE7XG4gICAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXTtcblxuICAgIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDtcbiAgICB9XG5cbiAgICBtdWwgKj0gMHg4MDtcbiAgICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gdmFsO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gICAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiB0aGlzW29mZnNldF07XG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7XG4gICAgcmV0dXJuIHZhbCAmIDB4ODAwMCA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWw7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8IHRoaXNbb2Zmc2V0XSA8PCA4O1xuICAgIHJldHVybiB2YWwgJiAweDgwMDAgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYgfCB0aGlzW29mZnNldCArIDNdIDw8IDI0O1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCAyNCB8IHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYgfCB0aGlzW29mZnNldCArIDJdIDw8IDggfCB0aGlzW29mZnNldCArIDNdO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRShvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNCk7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNCk7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUob2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gcmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tJbnQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuXG4gICAgaWYgKCFub0Fzc2VydCkge1xuICAgICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKTtcbiAgICB9XG5cbiAgICB2YXIgbXVsID0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGO1xuXG4gICAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAvIG11bCAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDA7XG5cbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxO1xuICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICAgIH1cblxuICAgIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gICAgdmFyIG11bCA9IDE7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcblxuICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlIC8gbXVsICYgMHhGRjtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKTtcbiAgICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgICByZXR1cm4gb2Zmc2V0ICsgMTtcbiAgfTtcblxuICBmdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgMHhmZiA8PCA4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDg7XG4gICAgfVxuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcblxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweGZmO1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSA+Pj4gODtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgMjtcbiAgfTtcblxuICBmdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDggJiAweGZmO1xuICAgIH1cbiAgfVxuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0O1xuICAgICAgdGhpc1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+PiAxNjtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCk7XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiAyNDtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgICB0aGlzW29mZnNldCArIDJdID0gdmFsdWUgPj4+IDg7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIDQ7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG5cbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbXVsID0gMTtcbiAgICB2YXIgc3ViID0gMDtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG5cbiAgICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgICAgc3ViID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG5cbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuICAgICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICAgIH1cblxuICAgIHZhciBpID0gYnl0ZUxlbmd0aCAtIDE7XG4gICAgdmFyIG11bCA9IDE7XG4gICAgdmFyIHN1YiA9IDA7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRjtcblxuICAgIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgICAgc3ViID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCA+PiAwKSAtIHN1YiAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKTtcbiAgICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMTtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgcmV0dXJuIG9mZnNldCArIDE7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldCArIDI7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMCk7XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlID4+PiA4O1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgKyAyO1xuICB9O1xuXG4gIEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgdmFsdWUgPSArdmFsdWU7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG5cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhmZjtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+Pj4gODtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gMTY7XG4gICAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWUgPj4+IDI0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICAgIHZhbHVlID0gK3ZhbHVlO1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gICAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICAgIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMTtcblxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgICAgdGhpc1tvZmZzZXRdID0gdmFsdWUgPj4+IDI0O1xuICAgICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+PiAxNjtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSB2YWx1ZSA+Pj4gODtcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0ICsgNDtcbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gICAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVGbG9hdChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0KTtcbiAgICB9XG5cbiAgICB3cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpO1xuICAgIHJldHVybiBvZmZzZXQgKyA0O1xuICB9XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG4gIH07XG5cbiAgQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICAgIGlmICghbm9Bc3NlcnQpIHtcbiAgICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgpO1xuICAgIH1cblxuICAgIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG4gICAgcmV0dXJuIG9mZnNldCArIDg7XG4gIH1cblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbiAgfTtcblxuICBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gICAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG4gIH07IC8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcblxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcbiAgICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGg7XG4gICAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuICAgIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydDsgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG5cbiAgICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gICAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwOyAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG5cbiAgICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gICAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpOyAvLyBBcmUgd2Ugb29iP1xuXG4gICAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAgIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQ7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwodGFyZ2V0LCB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldFN0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuO1xuICB9OyAvLyBVc2FnZTpcbiAgLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4gIC8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuICAvLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcblxuXG4gIEJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAgIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbmNvZGluZyA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbmNvZGluZyA9IGVuZDtcbiAgICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgICB2YWwgPSBjb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsID0gdmFsICYgMjU1O1xuICAgIH0gLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG5cblxuICAgIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpO1xuICAgIH1cblxuICAgIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXJ0ID0gc3RhcnQgPj4+IDA7XG4gICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMDtcbiAgICBpZiAoIXZhbCkgdmFsID0gMDtcbiAgICB2YXIgaTtcblxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICB0aGlzW2ldID0gdmFsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnl0ZXMgPSBpbnRlcm5hbElzQnVmZmVyKHZhbCkgPyB2YWwgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpO1xuICAgICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIEhFTFBFUiBGVU5DVElPTlNcbiAgLy8gPT09PT09PT09PT09PT09PVxuXG5cbiAgdmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nO1xuXG4gIGZ1bmN0aW9uIGJhc2U2NGNsZWFuKHN0cikge1xuICAgIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICAgIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJyk7IC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcblxuICAgIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnOyAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcblxuICAgIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3RyID0gc3RyICsgJz0nO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmd0cmltKHN0cikge1xuICAgIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKCk7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiB0b0hleChuKSB7XG4gICAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cmluZywgdW5pdHMpIHtcbiAgICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5O1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuICAgIHZhciBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7IC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcblxuICAgICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gdmFsaWQgbGVhZFxuXG5cbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIDIgbGVhZHMgaW4gYSByb3dcblxuXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuXG5cbiAgICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgIH1cblxuICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7IC8vIGVuY29kZSB1dGY4XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVhaztcbiAgICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwKTtcbiAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWs7XG4gICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCwgY29kZVBvaW50ICYgMHgzRiB8IDB4ODApO1xuICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWs7XG4gICAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLCBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCwgY29kZVBvaW50ICYgMHgzRiB8IDB4ODApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cblxuICBmdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gICAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZUFycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoc3RyLCB1bml0cykge1xuICAgIHZhciBjLCBoaSwgbG87XG4gICAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVhaztcbiAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgIGhpID0gYyA+PiA4O1xuICAgICAgbG8gPSBjICUgMjU2O1xuICAgICAgYnl0ZUFycmF5LnB1c2gobG8pO1xuICAgICAgYnl0ZUFycmF5LnB1c2goaGkpO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlQXJyYXk7XG4gIH1cblxuICBmdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICAgIHJldHVybiB0b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJsaXRCdWZmZXIoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCB8fCBpID49IHNyYy5sZW5ndGgpIGJyZWFrO1xuICAgICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNuYW4odmFsKSB7XG4gICAgcmV0dXJuIHZhbCAhPT0gdmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICB9IC8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2VcbiAgLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuICAvLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5cblxuICBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgKCEhb2JqLl9pc0J1ZmZlciB8fCBpc0Zhc3RCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Zhc3RCdWZmZXIob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iaik7XG4gIH0gLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cblxuXG4gIGZ1bmN0aW9uIGlzU2xvd0J1ZmZlcihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzRmFzdEJ1ZmZlcihvYmouc2xpY2UoMCwgMCkpO1xuICB9XG5cbiAgdmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbiAgZnVuY3Rpb24gdW53cmFwRXhwb3J0cyAoeCkge1xuICBcdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG4gIFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSAobikge1xuICBcdHJldHVybiBuICYmIG5bJ2RlZmF1bHQnXSB8fCBuO1xuICB9XG5cbiAgdmFyIGZzID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShfc2hpbV9mcyQxKTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqL1xuXG5cbiAgY2xhc3MgTGluZUJ5TGluZSB7XG4gICAgY29uc3RydWN0b3IoZmlsZSwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIW9wdGlvbnMucmVhZENodW5rKSBvcHRpb25zLnJlYWRDaHVuayA9IDEwMjQ7XG5cbiAgICAgIGlmICghb3B0aW9ucy5uZXdMaW5lQ2hhcmFjdGVyKSB7XG4gICAgICAgIG9wdGlvbnMubmV3TGluZUNoYXJhY3RlciA9IDB4MGE7IC8vbGludXggbGluZSBlbmRpbmdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMubmV3TGluZUNoYXJhY3RlciA9IG9wdGlvbnMubmV3TGluZUNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuZmQgPSBmaWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mZCA9IGZzLm9wZW5TeW5jKGZpbGUsICdyJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLm5ld0xpbmVDaGFyYWN0ZXIgPSBvcHRpb25zLm5ld0xpbmVDaGFyYWN0ZXI7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgX3NlYXJjaEluQnVmZmVyKGJ1ZmZlciwgaGV4TmVlZGxlKSB7XG4gICAgICBsZXQgZm91bmQgPSAtMTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBiX2J5dGUgPSBidWZmZXJbaV07XG5cbiAgICAgICAgaWYgKGJfYnl0ZSA9PT0gaGV4TmVlZGxlKSB7XG4gICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgIHRoaXMuZW9mUmVhY2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5saW5lc0NhY2hlID0gW107XG4gICAgICB0aGlzLmZkUG9zaXRpb24gPSAwO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICAgICAgdGhpcy5mZCA9IG51bGw7XG4gICAgfVxuXG4gICAgX2V4dHJhY3RMaW5lcyhidWZmZXIpIHtcbiAgICAgIGxldCBsaW5lO1xuICAgICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICAgIGxldCBidWZmZXJQb3NpdGlvbiA9IDA7XG4gICAgICBsZXQgbGFzdE5ld0xpbmVCdWZmZXJQb3NpdGlvbiA9IDA7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBidWZmZXJQb3NpdGlvblZhbHVlID0gYnVmZmVyW2J1ZmZlclBvc2l0aW9uKytdO1xuXG4gICAgICAgIGlmIChidWZmZXJQb3NpdGlvblZhbHVlID09PSB0aGlzLm5ld0xpbmVDaGFyYWN0ZXIpIHtcbiAgICAgICAgICBsaW5lID0gYnVmZmVyLnNsaWNlKGxhc3ROZXdMaW5lQnVmZmVyUG9zaXRpb24sIGJ1ZmZlclBvc2l0aW9uKTtcbiAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgIGxhc3ROZXdMaW5lQnVmZmVyUG9zaXRpb24gPSBidWZmZXJQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICghYnVmZmVyUG9zaXRpb25WYWx1ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBsZWZ0b3ZlcnMgPSBidWZmZXIuc2xpY2UobGFzdE5ld0xpbmVCdWZmZXJQb3NpdGlvbiwgYnVmZmVyUG9zaXRpb24pO1xuXG4gICAgICBpZiAobGVmdG92ZXJzLmxlbmd0aCkge1xuICAgICAgICBsaW5lcy5wdXNoKGxlZnRvdmVycyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG5cbiAgICBfcmVhZENodW5rKGxpbmVMZWZ0b3ZlcnMpIHtcbiAgICAgIGxldCB0b3RhbEJ5dGVzUmVhZCA9IDA7XG4gICAgICBsZXQgYnl0ZXNSZWFkO1xuICAgICAgY29uc3QgYnVmZmVycyA9IFtdO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IHJlYWRCdWZmZXIgPSBuZXcgQnVmZmVyKHRoaXMub3B0aW9ucy5yZWFkQ2h1bmspO1xuICAgICAgICBieXRlc1JlYWQgPSBmcy5yZWFkU3luYyh0aGlzLmZkLCByZWFkQnVmZmVyLCAwLCB0aGlzLm9wdGlvbnMucmVhZENodW5rLCB0aGlzLmZkUG9zaXRpb24pO1xuICAgICAgICB0b3RhbEJ5dGVzUmVhZCA9IHRvdGFsQnl0ZXNSZWFkICsgYnl0ZXNSZWFkO1xuICAgICAgICB0aGlzLmZkUG9zaXRpb24gPSB0aGlzLmZkUG9zaXRpb24gKyBieXRlc1JlYWQ7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChyZWFkQnVmZmVyKTtcbiAgICAgIH0gd2hpbGUgKGJ5dGVzUmVhZCAmJiB0aGlzLl9zZWFyY2hJbkJ1ZmZlcihidWZmZXJzW2J1ZmZlcnMubGVuZ3RoIC0gMV0sIHRoaXMub3B0aW9ucy5uZXdMaW5lQ2hhcmFjdGVyKSA9PT0gLTEpO1xuXG4gICAgICBsZXQgYnVmZmVyRGF0YSA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG5cbiAgICAgIGlmIChieXRlc1JlYWQgPCB0aGlzLm9wdGlvbnMucmVhZENodW5rKSB7XG4gICAgICAgIHRoaXMuZW9mUmVhY2hlZCA9IHRydWU7XG4gICAgICAgIGJ1ZmZlckRhdGEgPSBidWZmZXJEYXRhLnNsaWNlKDAsIHRvdGFsQnl0ZXNSZWFkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvdGFsQnl0ZXNSZWFkKSB7XG4gICAgICAgIHRoaXMubGluZXNDYWNoZSA9IHRoaXMuX2V4dHJhY3RMaW5lcyhidWZmZXJEYXRhKTtcblxuICAgICAgICBpZiAobGluZUxlZnRvdmVycykge1xuICAgICAgICAgIHRoaXMubGluZXNDYWNoZVswXSA9IEJ1ZmZlci5jb25jYXQoW2xpbmVMZWZ0b3ZlcnMsIHRoaXMubGluZXNDYWNoZVswXV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b3RhbEJ5dGVzUmVhZDtcbiAgICB9XG5cbiAgICBuZXh0KCkge1xuICAgICAgaWYgKCF0aGlzLmZkKSByZXR1cm4gZmFsc2U7XG4gICAgICBsZXQgbGluZSA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5lb2ZSZWFjaGVkICYmIHRoaXMubGluZXNDYWNoZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICB9XG5cbiAgICAgIGxldCBieXRlc1JlYWQ7XG5cbiAgICAgIGlmICghdGhpcy5saW5lc0NhY2hlLmxlbmd0aCkge1xuICAgICAgICBieXRlc1JlYWQgPSB0aGlzLl9yZWFkQ2h1bmsoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGluZXNDYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgbGluZSA9IHRoaXMubGluZXNDYWNoZS5zaGlmdCgpO1xuICAgICAgICBjb25zdCBsYXN0TGluZUNoYXJhY3RlciA9IGxpbmVbbGluZS5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAobGFzdExpbmVDaGFyYWN0ZXIgIT09IDB4MGEpIHtcbiAgICAgICAgICBieXRlc1JlYWQgPSB0aGlzLl9yZWFkQ2h1bmsobGluZSk7XG5cbiAgICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5saW5lc0NhY2hlLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVvZlJlYWNoZWQgJiYgdGhpcy5saW5lc0NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5lICYmIGxpbmVbbGluZS5sZW5ndGggLSAxXSA9PT0gdGhpcy5uZXdMaW5lQ2hhcmFjdGVyKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIGxpbmUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuICB9XG5cbiAgdmFyIHJlYWRsaW5lcyA9IExpbmVCeUxpbmU7XG5cbiAgLyoqXG4gICAqIFRoZSBpbnZlcnNlIG9mIGBfLnRvUGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZFxuICAgKiBmcm9tIGtleS12YWx1ZSBgcGFpcnNgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICovXG4gIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgZnJvbVBhaXJzXzEgPSBmcm9tUGFpcnM7XG5cbiAgY2xhc3MgQ29uZmlnRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4gIGNsYXNzIERlYnVnRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4gIGNsYXNzIFVuZGVmaW5lZFBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuICB2YXIgZXJyb3JzID0ge1xuICAgIENvbmZpZ0Vycm9yLFxuICAgIERlYnVnRXJyb3IsXG4gICAgVW5kZWZpbmVkUGFyc2VyRXJyb3JcbiAgfTtcblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChzdHJpbmdzLCByYXcpIHtcbiAgICBpZiAoIXJhdykge1xuICAgICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzdHJpbmdzLCB7XG4gICAgICByYXc6IHtcbiAgICAgICAgdmFsdWU6IE9iamVjdC5mcmVlemUocmF3KVxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIC8vIGJhc2VkIG9mZiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXByb2Nlc3MvYmxvYi9tYXN0ZXIvYnJvd3Nlci5qc1xuXG4gIGZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG4gIH1cblxuICB2YXIgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gIHZhciBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuXG4gIGlmICh0eXBlb2YgZ2xvYmFsJDEuc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnbG9iYWwkMS5jbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXG5cbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cblxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBkcmFpbmluZyA9IGZhbHNlO1xuICB2YXIgY3VycmVudFF1ZXVlO1xuICB2YXIgcXVldWVJbmRleCA9IC0xO1xuXG4gIGZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG5cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4pIHtcbiAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgcXVldWUgPSBbXTtcblxuICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2soZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuXG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxuICB9IC8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcblxuICBmdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gIH1cblxuICBJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG4gIH07XG5cbiAgdmFyIHRpdGxlID0gJ2Jyb3dzZXInO1xuICB2YXIgcGxhdGZvcm0gPSAnYnJvd3Nlcic7XG4gIHZhciBicm93c2VyID0gdHJ1ZTtcbiAgdmFyIGVudiA9IHt9O1xuICB2YXIgYXJndiA9IFtdO1xuICB2YXIgdmVyc2lvbiQxID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5cbiAgdmFyIHZlcnNpb25zID0ge307XG4gIHZhciByZWxlYXNlID0ge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICB2YXIgb24gPSBub29wO1xuICB2YXIgYWRkTGlzdGVuZXIgPSBub29wO1xuICB2YXIgb25jZSA9IG5vb3A7XG4gIHZhciBvZmYgPSBub29wO1xuICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBub29wO1xuICB2YXIgcmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbiAgdmFyIGVtaXQgPSBub29wO1xuICBmdW5jdGlvbiBiaW5kaW5nKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gIH1cbiAgZnVuY3Rpb24gY3dkKCkge1xuICAgIHJldHVybiAnLyc7XG4gIH1cbiAgZnVuY3Rpb24gY2hkaXIoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgfVxuICBmdW5jdGlvbiB1bWFzaygpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rdW1hdmlzL2Jyb3dzZXItcHJvY2Vzcy1ocnRpbWUvYmxvYi9tYXN0ZXIvaW5kZXguanNcblxuICB2YXIgcGVyZm9ybWFuY2UgPSBnbG9iYWwkMS5wZXJmb3JtYW5jZSB8fCB7fTtcblxuICB2YXIgcGVyZm9ybWFuY2VOb3cgPSBwZXJmb3JtYW5jZS5ub3cgfHwgcGVyZm9ybWFuY2UubW96Tm93IHx8IHBlcmZvcm1hbmNlLm1zTm93IHx8IHBlcmZvcm1hbmNlLm9Ob3cgfHwgcGVyZm9ybWFuY2Uud2Via2l0Tm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07IC8vIGdlbmVyYXRlIHRpbWVzdGFtcCBvciBkZWx0YVxuICAvLyBzZWUgaHR0cDovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzX3Byb2Nlc3NfaHJ0aW1lXG5cblxuICBmdW5jdGlvbiBocnRpbWUocHJldmlvdXNUaW1lc3RhbXApIHtcbiAgICB2YXIgY2xvY2t0aW1lID0gcGVyZm9ybWFuY2VOb3cuY2FsbChwZXJmb3JtYW5jZSkgKiAxZS0zO1xuICAgIHZhciBzZWNvbmRzID0gTWF0aC5mbG9vcihjbG9ja3RpbWUpO1xuICAgIHZhciBuYW5vc2Vjb25kcyA9IE1hdGguZmxvb3IoY2xvY2t0aW1lICUgMSAqIDFlOSk7XG5cbiAgICBpZiAocHJldmlvdXNUaW1lc3RhbXApIHtcbiAgICAgIHNlY29uZHMgPSBzZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMF07XG4gICAgICBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMV07XG5cbiAgICAgIGlmIChuYW5vc2Vjb25kcyA8IDApIHtcbiAgICAgICAgc2Vjb25kcy0tO1xuICAgICAgICBuYW5vc2Vjb25kcyArPSAxZTk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzZWNvbmRzLCBuYW5vc2Vjb25kc107XG4gIH1cbiAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gIGZ1bmN0aW9uIHVwdGltZSgpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciBkaWYgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcbiAgICByZXR1cm4gZGlmIC8gMTAwMDtcbiAgfVxuICB2YXIgcHJvY2VzcyA9IHtcbiAgICBuZXh0VGljazogbmV4dFRpY2ssXG4gICAgdGl0bGU6IHRpdGxlLFxuICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgZW52OiBlbnYsXG4gICAgYXJndjogYXJndixcbiAgICB2ZXJzaW9uOiB2ZXJzaW9uJDEsXG4gICAgdmVyc2lvbnM6IHZlcnNpb25zLFxuICAgIG9uOiBvbixcbiAgICBhZGRMaXN0ZW5lcjogYWRkTGlzdGVuZXIsXG4gICAgb25jZTogb25jZSxcbiAgICBvZmY6IG9mZixcbiAgICByZW1vdmVMaXN0ZW5lcjogcmVtb3ZlTGlzdGVuZXIsXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiByZW1vdmVBbGxMaXN0ZW5lcnMsXG4gICAgZW1pdDogZW1pdCxcbiAgICBiaW5kaW5nOiBiaW5kaW5nLFxuICAgIGN3ZDogY3dkLFxuICAgIGNoZGlyOiBjaGRpcixcbiAgICB1bWFzazogdW1hc2ssXG4gICAgaHJ0aW1lOiBocnRpbWUsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtLFxuICAgIHJlbGVhc2U6IHJlbGVhc2UsXG4gICAgY29uZmlnOiBjb25maWcsXG4gICAgdXB0aW1lOiB1cHRpbWVcbiAgfTtcblxuICBjb25zdCBkZWJ1ZyA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0RFQlVHICYmIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpID8gKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoJ1NFTVZFUicsIC4uLmFyZ3MpIDogKCkgPT4ge307XG4gIHZhciBkZWJ1Z18xID0gZGVidWc7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuICAvLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG4gIGNvbnN0IFNFTVZFUl9TUEVDX1ZFUlNJT04gPSAnMi4wLjAnO1xuICBjb25zdCBNQVhfTEVOR1RIID0gMjU2O1xuICBjb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgOTAwNzE5OTI1NDc0MDk5MTsgLy8gTWF4IHNhZmUgc2VnbWVudCBsZW5ndGggZm9yIGNvZXJjaW9uLlxuXG4gIGNvbnN0IE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNjtcbiAgdmFyIGNvbnN0YW50cyA9IHtcbiAgICBTRU1WRVJfU1BFQ19WRVJTSU9OLFxuICAgIE1BWF9MRU5HVEgsXG4gICAgTUFYX1NBRkVfSU5URUdFUixcbiAgICBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIXG4gIH07XG5cbiAgdmFyIHJlXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSFxuICAgIH0gPSBjb25zdGFudHM7XG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge307IC8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG5cbiAgICBjb25zdCByZSA9IGV4cG9ydHMucmUgPSBbXTtcbiAgICBjb25zdCBzcmMgPSBleHBvcnRzLnNyYyA9IFtdO1xuICAgIGNvbnN0IHQgPSBleHBvcnRzLnQgPSB7fTtcbiAgICBsZXQgUiA9IDA7XG5cbiAgICBjb25zdCBjcmVhdGVUb2tlbiA9IChuYW1lLCB2YWx1ZSwgaXNHbG9iYWwpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gUisrO1xuICAgICAgZGVidWdfMShpbmRleCwgdmFsdWUpO1xuICAgICAgdFtuYW1lXSA9IGluZGV4O1xuICAgICAgc3JjW2luZGV4XSA9IHZhbHVlO1xuICAgICAgcmVbaW5kZXhdID0gbmV3IFJlZ0V4cCh2YWx1ZSwgaXNHbG9iYWwgPyAnZycgOiB1bmRlZmluZWQpO1xuICAgIH07IC8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbiAgICAvLyB2YWxpZGF0aW5nLCBhbmQgcGFyc2luZyBTZW1WZXIgdmVyc2lvbiBzdHJpbmdzLlxuICAgIC8vICMjIE51bWVyaWMgSWRlbnRpZmllclxuICAgIC8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG5cbiAgICBjcmVhdGVUb2tlbignTlVNRVJJQ0lERU5USUZJRVInLCAnMHxbMS05XVxcXFxkKicpO1xuICAgIGNyZWF0ZVRva2VuKCdOVU1FUklDSURFTlRJRklFUkxPT1NFJywgJ1swLTldKycpOyAvLyAjIyBOb24tbnVtZXJpYyBJZGVudGlmaWVyXG4gICAgLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4gICAgLy8gbW9yZSBsZXR0ZXJzLCBkaWdpdHMsIG9yIGh5cGhlbnMuXG5cbiAgICBjcmVhdGVUb2tlbignTk9OTlVNRVJJQ0lERU5USUZJRVInLCAnXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKicpOyAvLyAjIyBNYWluIFZlcnNpb25cbiAgICAvLyBUaHJlZSBkb3Qtc2VwYXJhdGVkIG51bWVyaWMgaWRlbnRpZmllcnMuXG5cbiAgICBjcmVhdGVUb2tlbignTUFJTlZFUlNJT04nLCBcIihcIi5jb25jYXQoc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdLCBcIilcXFxcLlwiKSArIFwiKFwiLmNvbmNhdChzcmNbdC5OVU1FUklDSURFTlRJRklFUl0sIFwiKVxcXFwuXCIpICsgXCIoXCIuY29uY2F0KHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSwgXCIpXCIpKTtcbiAgICBjcmVhdGVUb2tlbignTUFJTlZFUlNJT05MT09TRScsIFwiKFwiLmNvbmNhdChzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSwgXCIpXFxcXC5cIikgKyBcIihcIi5jb25jYXQoc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0sIFwiKVxcXFwuXCIpICsgXCIoXCIuY29uY2F0KHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdLCBcIilcIikpOyAvLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbiAgICAvLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG4gICAgY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VJREVOVElGSUVSJywgXCIoPzpcIi5jb25jYXQoc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdLCBcInxcIikuY29uY2F0KHNyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXSwgXCIpXCIpKTtcbiAgICBjcmVhdGVUb2tlbignUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRScsIFwiKD86XCIuY29uY2F0KHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdLCBcInxcIikuY29uY2F0KHNyY1t0Lk5PTk5VTUVSSUNJREVOVElGSUVSXSwgXCIpXCIpKTsgLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuICAgIC8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4gICAgLy8gaWRlbnRpZmllcnMuXG5cbiAgICBjcmVhdGVUb2tlbignUFJFUkVMRUFTRScsIFwiKD86LShcIi5jb25jYXQoc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdLCBcIig/OlxcXFwuXCIpLmNvbmNhdChzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl0sIFwiKSopKVwiKSk7XG4gICAgY3JlYXRlVG9rZW4oJ1BSRVJFTEVBU0VMT09TRScsIFwiKD86LT8oXCIuY29uY2F0KHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdLCBcIig/OlxcXFwuXCIpLmNvbmNhdChzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSwgXCIpKikpXCIpKTsgLy8gIyMgQnVpbGQgTWV0YWRhdGEgSWRlbnRpZmllclxuICAgIC8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbiAgICBjcmVhdGVUb2tlbignQlVJTERJREVOVElGSUVSJywgJ1swLTlBLVphLXotXSsnKTsgLy8gIyMgQnVpbGQgTWV0YWRhdGFcbiAgICAvLyBQbHVzIHNpZ24sIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHBlcmlvZC1zZXBhcmF0ZWQgYnVpbGQgbWV0YWRhdGFcbiAgICAvLyBpZGVudGlmaWVycy5cblxuICAgIGNyZWF0ZVRva2VuKCdCVUlMRCcsIFwiKD86XFxcXCsoXCIuY29uY2F0KHNyY1t0LkJVSUxESURFTlRJRklFUl0sIFwiKD86XFxcXC5cIikuY29uY2F0KHNyY1t0LkJVSUxESURFTlRJRklFUl0sIFwiKSopKVwiKSk7IC8vICMjIEZ1bGwgVmVyc2lvbiBTdHJpbmdcbiAgICAvLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4gICAgLy8gYnVpbGQgbWV0YWRhdGEuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBvbmx5IG1ham9yLCBtaW5vciwgcGF0Y2gsIGFuZCBwcmUtcmVsZWFzZSBzZWN0aW9ucyBvZlxuICAgIC8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuICAgIC8vIGNhcHR1cmluZyBncm91cCwgYmVjYXVzZSBpdCBzaG91bGQgbm90IGV2ZXIgYmUgdXNlZCBpbiB2ZXJzaW9uXG4gICAgLy8gY29tcGFyaXNvbi5cblxuICAgIGNyZWF0ZVRva2VuKCdGVUxMUExBSU4nLCBcInY/XCIuY29uY2F0KHNyY1t0Lk1BSU5WRVJTSU9OXSkuY29uY2F0KHNyY1t0LlBSRVJFTEVBU0VdLCBcIj9cIikuY29uY2F0KHNyY1t0LkJVSUxEXSwgXCI/XCIpKTtcbiAgICBjcmVhdGVUb2tlbignRlVMTCcsIFwiXlwiLmNvbmNhdChzcmNbdC5GVUxMUExBSU5dLCBcIiRcIikpOyAvLyBsaWtlIGZ1bGwsIGJ1dCBhbGxvd3MgdjEuMi4zIGFuZCA9MS4yLjMsIHdoaWNoIHBlb3BsZSBkbyBzb21ldGltZXMuXG4gICAgLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbiAgICAvLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cblxuICAgIGNyZWF0ZVRva2VuKCdMT09TRVBMQUlOJywgXCJbdj1cXFxcc10qXCIuY29uY2F0KHNyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdKS5jb25jYXQoc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSwgXCI/XCIpLmNvbmNhdChzcmNbdC5CVUlMRF0sIFwiP1wiKSk7XG4gICAgY3JlYXRlVG9rZW4oJ0xPT1NFJywgXCJeXCIuY29uY2F0KHNyY1t0LkxPT1NFUExBSU5dLCBcIiRcIikpO1xuICAgIGNyZWF0ZVRva2VuKCdHVExUJywgJygoPzo8fD4pPz0/KScpOyAvLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbiAgICAvLyBOb3RlIHRoYXQgXCJ4LnhcIiBpcyBhIHZhbGlkIHhSYW5nZSBpZGVudGlmZXIsIG1lYW5pbmcgXCJhbnkgdmVyc2lvblwiXG4gICAgLy8gT25seSB0aGUgZmlyc3QgaXRlbSBpcyBzdHJpY3RseSByZXF1aXJlZC5cblxuICAgIGNyZWF0ZVRva2VuKCdYUkFOR0VJREVOVElGSUVSTE9PU0UnLCBcIlwiLmNvbmNhdChzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSwgXCJ8eHxYfFxcXFwqXCIpKTtcbiAgICBjcmVhdGVUb2tlbignWFJBTkdFSURFTlRJRklFUicsIFwiXCIuY29uY2F0KHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSwgXCJ8eHxYfFxcXFwqXCIpKTtcbiAgICBjcmVhdGVUb2tlbignWFJBTkdFUExBSU4nLCBcIlt2PVxcXFxzXSooXCIuY29uY2F0KHNyY1t0LlhSQU5HRUlERU5USUZJRVJdLCBcIilcIikgKyBcIig/OlxcXFwuKFwiLmNvbmNhdChzcmNbdC5YUkFOR0VJREVOVElGSUVSXSwgXCIpXCIpICsgXCIoPzpcXFxcLihcIi5jb25jYXQoc3JjW3QuWFJBTkdFSURFTlRJRklFUl0sIFwiKVwiKSArIFwiKD86XCIuY29uY2F0KHNyY1t0LlBSRVJFTEVBU0VdLCBcIik/XCIpLmNvbmNhdChzcmNbdC5CVUlMRF0sIFwiP1wiKSArIFwiKT8pP1wiKTtcbiAgICBjcmVhdGVUb2tlbignWFJBTkdFUExBSU5MT09TRScsIFwiW3Y9XFxcXHNdKihcIi5jb25jYXQoc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSwgXCIpXCIpICsgXCIoPzpcXFxcLihcIi5jb25jYXQoc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSwgXCIpXCIpICsgXCIoPzpcXFxcLihcIi5jb25jYXQoc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSwgXCIpXCIpICsgXCIoPzpcIi5jb25jYXQoc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSwgXCIpP1wiKS5jb25jYXQoc3JjW3QuQlVJTERdLCBcIj9cIikgKyBcIik/KT9cIik7XG4gICAgY3JlYXRlVG9rZW4oJ1hSQU5HRScsIFwiXlwiLmNvbmNhdChzcmNbdC5HVExUXSwgXCJcXFxccypcIikuY29uY2F0KHNyY1t0LlhSQU5HRVBMQUlOXSwgXCIkXCIpKTtcbiAgICBjcmVhdGVUb2tlbignWFJBTkdFTE9PU0UnLCBcIl5cIi5jb25jYXQoc3JjW3QuR1RMVF0sIFwiXFxcXHMqXCIpLmNvbmNhdChzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSwgXCIkXCIpKTsgLy8gQ29lcmNpb24uXG4gICAgLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxuXG4gICAgY3JlYXRlVG9rZW4oJ0NPRVJDRScsIFwiXCIuY29uY2F0KCcoXnxbXlxcXFxkXSknICsgJyhcXFxcZHsxLCcpLmNvbmNhdChNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILCBcIn0pXCIpICsgXCIoPzpcXFxcLihcXFxcZHsxLFwiLmNvbmNhdChNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RILCBcIn0pKT9cIikgKyBcIig/OlxcXFwuKFxcXFxkezEsXCIuY29uY2F0KE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEgsIFwifSkpP1wiKSArIFwiKD86JHxbXlxcXFxkXSlcIik7XG4gICAgY3JlYXRlVG9rZW4oJ0NPRVJDRVJUTCcsIHNyY1t0LkNPRVJDRV0sIHRydWUpOyAvLyBUaWxkZSByYW5nZXMuXG4gICAgLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcblxuICAgIGNyZWF0ZVRva2VuKCdMT05FVElMREUnLCAnKD86fj4/KScpO1xuICAgIGNyZWF0ZVRva2VuKCdUSUxERVRSSU0nLCBcIihcXFxccyopXCIuY29uY2F0KHNyY1t0LkxPTkVUSUxERV0sIFwiXFxcXHMrXCIpLCB0cnVlKTtcbiAgICBleHBvcnRzLnRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+JztcbiAgICBjcmVhdGVUb2tlbignVElMREUnLCBcIl5cIi5jb25jYXQoc3JjW3QuTE9ORVRJTERFXSkuY29uY2F0KHNyY1t0LlhSQU5HRVBMQUlOXSwgXCIkXCIpKTtcbiAgICBjcmVhdGVUb2tlbignVElMREVMT09TRScsIFwiXlwiLmNvbmNhdChzcmNbdC5MT05FVElMREVdKS5jb25jYXQoc3JjW3QuWFJBTkdFUExBSU5MT09TRV0sIFwiJFwiKSk7IC8vIENhcmV0IHJhbmdlcy5cbiAgICAvLyBNZWFuaW5nIGlzIFwiYXQgbGVhc3QgYW5kIGJhY2t3YXJkcyBjb21wYXRpYmxlIHdpdGhcIlxuXG4gICAgY3JlYXRlVG9rZW4oJ0xPTkVDQVJFVCcsICcoPzpcXFxcXiknKTtcbiAgICBjcmVhdGVUb2tlbignQ0FSRVRUUklNJywgXCIoXFxcXHMqKVwiLmNvbmNhdChzcmNbdC5MT05FQ0FSRVRdLCBcIlxcXFxzK1wiKSwgdHJ1ZSk7XG4gICAgZXhwb3J0cy5jYXJldFRyaW1SZXBsYWNlID0gJyQxXic7XG4gICAgY3JlYXRlVG9rZW4oJ0NBUkVUJywgXCJeXCIuY29uY2F0KHNyY1t0LkxPTkVDQVJFVF0pLmNvbmNhdChzcmNbdC5YUkFOR0VQTEFJTl0sIFwiJFwiKSk7XG4gICAgY3JlYXRlVG9rZW4oJ0NBUkVUTE9PU0UnLCBcIl5cIi5jb25jYXQoc3JjW3QuTE9ORUNBUkVUXSkuY29uY2F0KHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdLCBcIiRcIikpOyAvLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxuXG4gICAgY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JMT09TRScsIFwiXlwiLmNvbmNhdChzcmNbdC5HVExUXSwgXCJcXFxccyooXCIpLmNvbmNhdChzcmNbdC5MT09TRVBMQUlOXSwgXCIpJHxeJFwiKSk7XG4gICAgY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1InLCBcIl5cIi5jb25jYXQoc3JjW3QuR1RMVF0sIFwiXFxcXHMqKFwiKS5jb25jYXQoc3JjW3QuRlVMTFBMQUlOXSwgXCIpJHxeJFwiKSk7IC8vIEFuIGV4cHJlc3Npb24gdG8gc3RyaXAgYW55IHdoaXRlc3BhY2UgYmV0d2VlbiB0aGUgZ3RsdCBhbmQgdGhlIHRoaW5nXG4gICAgLy8gaXQgbW9kaWZpZXMsIHNvIHRoYXQgYD4gMS4yLjNgID09PiBgPjEuMi4zYFxuXG4gICAgY3JlYXRlVG9rZW4oJ0NPTVBBUkFUT1JUUklNJywgXCIoXFxcXHMqKVwiLmNvbmNhdChzcmNbdC5HVExUXSwgXCJcXFxccyooXCIpLmNvbmNhdChzcmNbdC5MT09TRVBMQUlOXSwgXCJ8XCIpLmNvbmNhdChzcmNbdC5YUkFOR0VQTEFJTl0sIFwiKVwiKSwgdHJ1ZSk7XG4gICAgZXhwb3J0cy5jb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJzsgLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4gICAgLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuICAgIC8vIGNoZWNrZWQgYWdhaW5zdCBlaXRoZXIgdGhlIHN0cmljdCBvciBsb29zZSBjb21wYXJhdG9yIGZvcm1cbiAgICAvLyBsYXRlci5cblxuICAgIGNyZWF0ZVRva2VuKCdIWVBIRU5SQU5HRScsIFwiXlxcXFxzKihcIi5jb25jYXQoc3JjW3QuWFJBTkdFUExBSU5dLCBcIilcIikgKyBcIlxcXFxzKy1cXFxccytcIiArIFwiKFwiLmNvbmNhdChzcmNbdC5YUkFOR0VQTEFJTl0sIFwiKVwiKSArIFwiXFxcXHMqJFwiKTtcbiAgICBjcmVhdGVUb2tlbignSFlQSEVOUkFOR0VMT09TRScsIFwiXlxcXFxzKihcIi5jb25jYXQoc3JjW3QuWFJBTkdFUExBSU5MT09TRV0sIFwiKVwiKSArIFwiXFxcXHMrLVxcXFxzK1wiICsgXCIoXCIuY29uY2F0KHNyY1t0LlhSQU5HRVBMQUlOTE9PU0VdLCBcIilcIikgKyBcIlxcXFxzKiRcIik7IC8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cblxuICAgIGNyZWF0ZVRva2VuKCdTVEFSJywgJyg8fD4pPz0/XFxcXHMqXFxcXConKTtcbiAgfSk7XG4gIHZhciByZV8yID0gcmVfMS5yZTtcbiAgdmFyIHJlXzMgPSByZV8xLnNyYztcbiAgdmFyIHJlXzQgPSByZV8xLnQ7XG4gIHZhciByZV81ID0gcmVfMS50aWxkZVRyaW1SZXBsYWNlO1xuICB2YXIgcmVfNiA9IHJlXzEuY2FyZXRUcmltUmVwbGFjZTtcbiAgdmFyIHJlXzcgPSByZV8xLmNvbXBhcmF0b3JUcmltUmVwbGFjZTtcblxuICBjb25zdCBudW1lcmljID0gL15bMC05XSskLztcblxuICBjb25zdCBjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IGFudW0gPSBudW1lcmljLnRlc3QoYSk7XG4gICAgY29uc3QgYm51bSA9IG51bWVyaWMudGVzdChiKTtcblxuICAgIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICAgIGEgPSArYTtcbiAgICAgIGIgPSArYjtcbiAgICB9XG5cbiAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhbnVtICYmICFibnVtID8gLTEgOiBibnVtICYmICFhbnVtID8gMSA6IGEgPCBiID8gLTEgOiAxO1xuICB9O1xuXG4gIGNvbnN0IHJjb21wYXJlSWRlbnRpZmllcnMgPSAoYSwgYikgPT4gY29tcGFyZUlkZW50aWZpZXJzKGIsIGEpO1xuXG4gIHZhciBpZGVudGlmaWVycyA9IHtcbiAgICBjb21wYXJlSWRlbnRpZmllcnMsXG4gICAgcmNvbXBhcmVJZGVudGlmaWVyc1xuICB9O1xuXG4gIGNvbnN0IHtcbiAgICBNQVhfTEVOR1RIOiBNQVhfTEVOR1RIJDEsXG4gICAgTUFYX1NBRkVfSU5URUdFUjogTUFYX1NBRkVfSU5URUdFUiQxXG4gIH0gPSBjb25zdGFudHM7XG4gIGNvbnN0IHtcbiAgICByZSxcbiAgICB0XG4gIH0gPSByZV8xO1xuICBjb25zdCB7XG4gICAgY29tcGFyZUlkZW50aWZpZXJzOiBjb21wYXJlSWRlbnRpZmllcnMkMVxuICB9ID0gaWRlbnRpZmllcnM7XG5cbiAgY2xhc3MgU2VtVmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgICAgICBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICAgICAgaWYgKHZlcnNpb24ubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSAmJiB2ZXJzaW9uLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBWZXJzaW9uOiBcIi5jb25jYXQodmVyc2lvbikpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIJDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gXCIuY29uY2F0KE1BWF9MRU5HVEgkMSwgXCIgY2hhcmFjdGVyc1wiKSk7XG4gICAgICB9XG5cbiAgICAgIGRlYnVnXzEoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMubG9vc2UgPSAhIW9wdGlvbnMubG9vc2U7IC8vIHRoaXMgaXNuJ3QgYWN0dWFsbHkgcmVsZXZhbnQgZm9yIHZlcnNpb25zLCBidXQga2VlcCBpdCBzbyB0aGF0IHdlXG4gICAgICAvLyBkb24ndCBydW4gaW50byB0cm91YmxlIHBhc3NpbmcgdGhpcy5vcHRpb25zIGFyb3VuZC5cblxuICAgICAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZTtcbiAgICAgIGNvbnN0IG0gPSB2ZXJzaW9uLnRyaW0oKS5tYXRjaChvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdKTtcblxuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIFZlcnNpb246IFwiLmNvbmNhdCh2ZXJzaW9uKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF3ID0gdmVyc2lvbjsgLy8gdGhlc2UgYXJlIGFjdHVhbGx5IG51bWJlcnNcblxuICAgICAgdGhpcy5tYWpvciA9ICttWzFdO1xuICAgICAgdGhpcy5taW5vciA9ICttWzJdO1xuICAgICAgdGhpcy5wYXRjaCA9ICttWzNdO1xuXG4gICAgICBpZiAodGhpcy5tYWpvciA+IE1BWF9TQUZFX0lOVEVHRVIkMSB8fCB0aGlzLm1ham9yIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWlub3IgPiBNQVhfU0FGRV9JTlRFR0VSJDEgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtaW5vciB2ZXJzaW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiQxIHx8IHRoaXMucGF0Y2ggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpO1xuICAgICAgfSAvLyBudW1iZXJpZnkgYW55IHByZXJlbGVhc2UgbnVtZXJpYyBpZHNcblxuXG4gICAgICBpZiAoIW1bNF0pIHtcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKGlkID0+IHtcbiAgICAgICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK2lkO1xuXG4gICAgICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUiQxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5idWlsZCA9IG1bNV0gPyBtWzVdLnNwbGl0KCcuJykgOiBbXTtcbiAgICAgIHRoaXMuZm9ybWF0KCk7XG4gICAgfVxuXG4gICAgZm9ybWF0KCkge1xuICAgICAgdGhpcy52ZXJzaW9uID0gXCJcIi5jb25jYXQodGhpcy5tYWpvciwgXCIuXCIpLmNvbmNhdCh0aGlzLm1pbm9yLCBcIi5cIikuY29uY2F0KHRoaXMucGF0Y2gpO1xuXG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gKz0gXCItXCIuY29uY2F0KHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJykpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy52ZXJzaW9uO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbiAgICB9XG5cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICBkZWJ1Z18xKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcik7XG5cbiAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgICAgICBpZiAodHlwZW9mIG90aGVyID09PSAnc3RyaW5nJyAmJiBvdGhlciA9PT0gdGhpcy52ZXJzaW9uKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdGhlci52ZXJzaW9uID09PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpO1xuICAgIH1cblxuICAgIGNvbXBhcmVNYWluKG90aGVyKSB7XG4gICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICAgICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzJDEodGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8IGNvbXBhcmVJZGVudGlmaWVycyQxKHRoaXMubWlub3IsIG90aGVyLm1pbm9yKSB8fCBjb21wYXJlSWRlbnRpZmllcnMkMSh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaCk7XG4gICAgfVxuXG4gICAgY29tcGFyZVByZShvdGhlcikge1xuICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH0gLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG5cblxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoICYmICFvdGhlci5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLnByZXJlbGVhc2VbaV07XG4gICAgICAgIGNvbnN0IGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldO1xuICAgICAgICBkZWJ1Z18xKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKTtcblxuICAgICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyQxKGEsIGIpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgrK2kpO1xuICAgIH1cblxuICAgIGNvbXBhcmVCdWlsZChvdGhlcikge1xuICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmJ1aWxkW2ldO1xuICAgICAgICBjb25zdCBiID0gb3RoZXIuYnVpbGRbaV07XG4gICAgICAgIGRlYnVnXzEoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpO1xuXG4gICAgICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzJDEoYSwgYik7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKCsraSk7XG4gICAgfSAvLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4gICAgLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuXG5cbiAgICBpbmMocmVsZWFzZSwgaWRlbnRpZmllcikge1xuICAgICAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgICAgIGNhc2UgJ3ByZW1ham9yJzpcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgICAgICB0aGlzLm1ham9yKys7XG4gICAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3ByZW1pbm9yJzpcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgICAgICB0aGlzLm1pbm9yKys7XG4gICAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgICAgIC8vIGRyb3AgYW55IHByZXJlbGVhc2VzIHRoYXQgbWlnaHQgYWxyZWFkeSBleGlzdCwgc2luY2UgdGhleSBhcmUgbm90XG4gICAgICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhIG5vbi1wcmVyZWxlYXNlIHZlcnNpb24sIHRoaXMgYWN0cyB0aGUgc2FtZSBhc1xuICAgICAgICAvLyBwcmVwYXRjaC5cblxuICAgICAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21ham9yJzpcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1ham9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbi5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgICAgICAvLyAxLjEuMCBidW1wcyB0byAyLjAuMFxuICAgICAgICAgIGlmICh0aGlzLm1pbm9yICE9PSAwIHx8IHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgcHJlLW1pbm9yIHZlcnNpb24sIGJ1bXAgdXAgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbi5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgICAgICAvLyAxLjIuMSBidW1wcyB0byAxLjMuMFxuICAgICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubWlub3IrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwYXRjaCc6XG4gICAgICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAgICAgLy8gSWYgaXQgaXMgYSBwcmUtcmVsZWFzZSBpdCB3aWxsIGJ1bXAgdXAgdG8gdGhlIHNhbWUgcGF0Y2ggdmVyc2lvbi5cbiAgICAgICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGF0Y2grKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAgICAgLy8gMS4wLjAgJ3ByZScgd291bGQgYmVjb21lIDEuMC4wLTAgd2hpY2ggaXMgdGhlIHdyb25nIGRpcmVjdGlvbi5cblxuICAgICAgICBjYXNlICdwcmUnOlxuICAgICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcmVsZWFzZVtpXSsrO1xuICAgICAgICAgICAgICAgIGkgPSAtMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UucHVzaCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgLy8gMS4yLjAtYmV0YS4xIGJ1bXBzIHRvIDEuMi4wLWJldGEuMixcbiAgICAgICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIGlmIChpc05hTih0aGlzLnByZXJlbGVhc2VbMV0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogXCIuY29uY2F0KHJlbGVhc2UpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mb3JtYXQoKTtcbiAgICAgIHRoaXMucmF3ID0gdGhpcy52ZXJzaW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH1cblxuICB2YXIgc2VtdmVyID0gU2VtVmVyO1xuXG4gIGNvbnN0IGNvbXBhcmUgPSAoYSwgYiwgbG9vc2UpID0+IG5ldyBzZW12ZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IHNlbXZlcihiLCBsb29zZSkpO1xuXG4gIHZhciBjb21wYXJlXzEgPSBjb21wYXJlO1xuXG4gIGNvbnN0IGx0ID0gKGEsIGIsIGxvb3NlKSA9PiBjb21wYXJlXzEoYSwgYiwgbG9vc2UpIDwgMDtcblxuICB2YXIgbHRfMSA9IGx0O1xuXG4gIGNvbnN0IGd0ZSA9IChhLCBiLCBsb29zZSkgPT4gY29tcGFyZV8xKGEsIGIsIGxvb3NlKSA+PSAwO1xuXG4gIHZhciBndGVfMSA9IGd0ZTtcblxuICB2YXIgYXJyYXlpZnkgPSAob2JqZWN0LCBrZXlOYW1lKSA9PiBPYmplY3QuZW50cmllcyhvYmplY3QpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBPYmplY3QuYXNzaWduKHtcbiAgICBba2V5TmFtZV06IGtleVxuICB9LCB2YWx1ZSkpO1xuXG4gIHZhciBkZWRlbnRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICAgIGZ1bmN0aW9uIGRlZGVudChzdHJpbmdzKSB7XG4gICAgICB2YXIgcmF3ID0gdm9pZCAwO1xuXG4gICAgICBpZiAodHlwZW9mIHN0cmluZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gZGVkZW50IGNhbiBiZSB1c2VkIGFzIGEgcGxhaW4gZnVuY3Rpb25cbiAgICAgICAgcmF3ID0gW3N0cmluZ3NdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmF3ID0gc3RyaW5ncy5yYXc7XG4gICAgICB9IC8vIGZpcnN0LCBwZXJmb3JtIGludGVycG9sYXRpb25cblxuXG4gICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHJhd1tpXS4gLy8gam9pbiBsaW5lcyB3aGVuIHRoZXJlIGlzIGEgc3VwcHJlc3NlZCBuZXdsaW5lXG4gICAgICAgIHJlcGxhY2UoL1xcXFxcXG5bIFxcdF0qL2csIFwiXCIpLiAvLyBoYW5kbGUgZXNjYXBlZCBiYWNrdGlja3NcbiAgICAgICAgcmVwbGFjZSgvXFxcXGAvZywgXCJgXCIpO1xuXG4gICAgICAgIGlmIChpIDwgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IDAgOiBhcmd1bWVudHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYXJndW1lbnRzLmxlbmd0aCA8PSBpICsgMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gbm93IHN0cmlwIGluZGVudGF0aW9uXG5cblxuICAgICAgdmFyIGxpbmVzID0gcmVzdWx0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgdmFyIG1pbmRlbnQgPSBudWxsO1xuICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICB2YXIgbSA9IGwubWF0Y2goL14oXFxzKylcXFMrLyk7XG5cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICB2YXIgaW5kZW50ID0gbVsxXS5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoIW1pbmRlbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGZpcnN0IGluZGVudGVkIGxpbmVcbiAgICAgICAgICAgIG1pbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbmRlbnQgPSBNYXRoLm1pbihtaW5kZW50LCBpbmRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChtaW5kZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IGxpbmVzLm1hcChmdW5jdGlvbiAobCkge1xuICAgICAgICAgIHJldHVybiBsWzBdID09PSBcIiBcIiA/IGwuc2xpY2UobWluZGVudCkgOiBsO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgICAgfSAvLyBkZWRlbnQgZWF0cyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIHRvb1xuXG5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdC50cmltKCk7IC8vIGhhbmRsZSBlc2NhcGVkIG5ld2xpbmVzIGF0IHRoZSBlbmQgdG8gZW5zdXJlIHRoZXkgZG9uJ3QgZ2V0IHN0cmlwcGVkIHRvb1xuXG4gICAgICByZXR1cm4gcmVzdWx0LnJlcGxhY2UoL1xcXFxuL2csIFwiXFxuXCIpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVkZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0NigpIHtcbiAgICBjb25zdCBkYXRhID0gX3RhZ2dlZFRlbXBsYXRlTGl0ZXJhbChbXCJcXG4gICAgICBSZXF1aXJlIGVpdGhlciAnQHByZXR0aWVyJyBvciAnQGZvcm1hdCcgdG8gYmUgcHJlc2VudCBpbiB0aGUgZmlsZSdzIGZpcnN0IGRvY2Jsb2NrIGNvbW1lbnRcXG4gICAgICBpbiBvcmRlciBmb3IgaXQgdG8gYmUgZm9ybWF0dGVkLlxcbiAgICBcIl0pO1xuXG4gICAgX3RlbXBsYXRlT2JqZWN0NiA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDYoKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3Q1KCkge1xuICAgIGNvbnN0IGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgIEZvcm1hdCBjb2RlIHN0YXJ0aW5nIGF0IGEgZ2l2ZW4gY2hhcmFjdGVyIG9mZnNldC5cXG4gICAgICBUaGUgcmFuZ2Ugd2lsbCBleHRlbmQgYmFja3dhcmRzIHRvIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgbGluZSBjb250YWluaW5nIHRoZSBzZWxlY3RlZCBzdGF0ZW1lbnQuXFxuICAgICAgVGhpcyBvcHRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCAtLWN1cnNvci1vZmZzZXQuXFxuICAgIFwiXSk7XG5cbiAgICBfdGVtcGxhdGVPYmplY3Q1ID0gZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0NSgpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDQoKSB7XG4gICAgY29uc3QgZGF0YSA9IF90YWdnZWRUZW1wbGF0ZUxpdGVyYWwoW1wiXFxuICAgICAgRm9ybWF0IGNvZGUgZW5kaW5nIGF0IGEgZ2l2ZW4gY2hhcmFjdGVyIG9mZnNldCAoZXhjbHVzaXZlKS5cXG4gICAgICBUaGUgcmFuZ2Ugd2lsbCBleHRlbmQgZm9yd2FyZHMgdG8gdGhlIGVuZCBvZiB0aGUgc2VsZWN0ZWQgc3RhdGVtZW50LlxcbiAgICAgIFRoaXMgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggLS1jdXJzb3Itb2Zmc2V0LlxcbiAgICBcIl0pO1xuXG4gICAgX3RlbXBsYXRlT2JqZWN0NCA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDQoKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QzKCkge1xuICAgIGNvbnN0IGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgIEN1c3RvbSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBwcmV0dGllciBwbHVnaW5zIGluIG5vZGVfbW9kdWxlcyBzdWJkaXJlY3RvcnkuXFxuICAgICAgT3ZlcnJpZGVzIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiBwbHVnaW5zIGFyZSBzZWFyY2hlZCByZWxhdGl2ZWx5IHRvIHRoZSBsb2NhdGlvbiBvZiBQcmV0dGllci5cXG4gICAgICBNdWx0aXBsZSB2YWx1ZXMgYXJlIGFjY2VwdGVkLlxcbiAgICBcIl0pO1xuXG4gICAgX3RlbXBsYXRlT2JqZWN0MyA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdDMoKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QyKCkge1xuICAgIGNvbnN0IGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgICAgICBNYWludGFpbiBleGlzdGluZ1xcbiAgICAgICAgICAobWl4ZWQgdmFsdWVzIHdpdGhpbiBvbmUgZmlsZSBhcmUgbm9ybWFsaXNlZCBieSBsb29raW5nIGF0IHdoYXQncyB1c2VkIGFmdGVyIHRoZSBmaXJzdCBsaW5lKVxcbiAgICAgICAgXCJdKTtcblxuICAgIF90ZW1wbGF0ZU9iamVjdDIgPSBmdW5jdGlvbiBfdGVtcGxhdGVPYmplY3QyKCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgZnVuY3Rpb24gX3RlbXBsYXRlT2JqZWN0KCkge1xuICAgIGNvbnN0IGRhdGEgPSBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsKFtcIlxcbiAgICAgIFByaW50ICh0byBzdGRlcnIpIHdoZXJlIGEgY3Vyc29yIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiB3b3VsZCBtb3ZlIHRvIGFmdGVyIGZvcm1hdHRpbmcuXFxuICAgICAgVGhpcyBvcHRpb24gY2Fubm90IGJlIHVzZWQgd2l0aCAtLXJhbmdlLXN0YXJ0IGFuZCAtLXJhbmdlLWVuZC5cXG4gICAgXCJdKTtcblxuICAgIF90ZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIF90ZW1wbGF0ZU9iamVjdCgpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IENBVEVHT1JZX0NPTkZJRyA9IFwiQ29uZmlnXCI7XG4gIGNvbnN0IENBVEVHT1JZX0VESVRPUiA9IFwiRWRpdG9yXCI7XG4gIGNvbnN0IENBVEVHT1JZX0ZPUk1BVCA9IFwiRm9ybWF0XCI7XG4gIGNvbnN0IENBVEVHT1JZX09USEVSID0gXCJPdGhlclwiO1xuICBjb25zdCBDQVRFR09SWV9PVVRQVVQgPSBcIk91dHB1dFwiO1xuICBjb25zdCBDQVRFR09SWV9HTE9CQUwgPSBcIkdsb2JhbFwiO1xuICBjb25zdCBDQVRFR09SWV9TUEVDSUFMID0gXCJTcGVjaWFsXCI7XG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25JbmZvXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2luY2VdIC0gYXZhaWxhYmxlIHNpbmNlIHZlcnNpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdGVnb3J5XG4gICAqIEBwcm9wZXJ0eSB7J2ludCcgfCAnYm9vbGVhbicgfCAnY2hvaWNlJyB8ICdwYXRoJ30gdHlwZVxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcnJheV0gLSBpbmRpY2F0ZSBpdCdzIGFuIGFycmF5IG9mIHRoZSBzcGVjaWZpZWQgdHlwZVxuICAgKiBAcHJvcGVydHkge09wdGlvblZhbHVlSW5mb30gW2RlZmF1bHRdXG4gICAqIEBwcm9wZXJ0eSB7T3B0aW9uUmFuZ2VJbmZvfSBbcmFuZ2VdIC0gZm9yIHR5cGUgaW50XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2RlcHJlY2F0ZWRdIC0gZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uXG4gICAqIEBwcm9wZXJ0eSB7T3B0aW9uUmVkaXJlY3RJbmZvfSBbcmVkaXJlY3RdIC0gcmVkaXJlY3QgZGVwcmVjYXRlZCBvcHRpb25cbiAgICogQHByb3BlcnR5IHsodmFsdWU6IGFueSkgPT4gYm9vbGVhbn0gW2V4Y2VwdGlvbl1cbiAgICogQHByb3BlcnR5IHtPcHRpb25DaG9pY2VJbmZvW119IFtjaG9pY2VzXSAtIGZvciB0eXBlIGNob2ljZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2NsaU5hbWVdXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xpQ2F0ZWdvcnldXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY2xpRGVzY3JpcHRpb25dXG4gICAqXG4gICAqIEB0eXBlZGVmIHtudW1iZXIgfCBib29sZWFuIHwgc3RyaW5nfSBPcHRpb25WYWx1ZVxuICAgKiBAdHlwZWRlZiB7T3B0aW9uVmFsdWUgfCBbeyB2YWx1ZTogT3B0aW9uVmFsdWVbXSB9XSB8IEFycmF5PHsgc2luY2U6IHN0cmluZywgdmFsdWU6IE9wdGlvblZhbHVlfT59IE9wdGlvblZhbHVlSW5mb1xuICAgKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25SZWRpcmVjdEluZm9cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IG9wdGlvblxuICAgKiBAcHJvcGVydHkge09wdGlvblZhbHVlfSB2YWx1ZVxuICAgKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25SYW5nZUluZm9cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0IC0gcmVjb21tZW5kZWQgcmFuZ2Ugc3RhcnRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZCAtIHJlY29tbWVuZGVkIHJhbmdlIGVuZFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RlcCAtIHJlY29tbWVuZGVkIHJhbmdlIHN0ZXBcbiAgICpcbiAgICogQHR5cGVkZWYge09iamVjdH0gT3B0aW9uQ2hvaWNlSW5mb1xuICAgKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBzdHJpbmd9IHZhbHVlIC0gYm9vbGVhbiBmb3IgdGhlIG9wdGlvbiB0aGF0IGlzIG9yaWdpbmFsbHkgYm9vbGVhbiB0eXBlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZXNjcmlwdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3NpbmNlXSAtIHVuZGVmaW5lZCBpZiBhdmFpbGFibGUgc2luY2UgdGhlIGZpcnN0IHZlcnNpb24gb2YgdGhlIG9wdGlvblxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2RlcHJlY2F0ZWRdIC0gZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uXG4gICAqIEBwcm9wZXJ0eSB7T3B0aW9uVmFsdWVJbmZvfSBbcmVkaXJlY3RdIC0gcmVkaXJlY3QgZGVwcmVjYXRlZCB2YWx1ZVxuICAgKi9cblxuICAvKiogQHR5cGUge3sgW25hbWU6IHN0cmluZ106IE9wdGlvbkluZm8gfX0gKi9cblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGN1cnNvck9mZnNldDoge1xuICAgICAgc2luY2U6IFwiMS40LjBcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9TUEVDSUFMLFxuICAgICAgdHlwZTogXCJpbnRcIixcbiAgICAgIGRlZmF1bHQ6IC0xLFxuICAgICAgcmFuZ2U6IHtcbiAgICAgICAgc3RhcnQ6IC0xLFxuICAgICAgICBlbmQ6IEluZmluaXR5LFxuICAgICAgICBzdGVwOiAxXG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IGRlZGVudF8xKF90ZW1wbGF0ZU9iamVjdCgpKSxcbiAgICAgIGNsaUNhdGVnb3J5OiBDQVRFR09SWV9FRElUT1JcbiAgICB9LFxuICAgIGVuZE9mTGluZToge1xuICAgICAgc2luY2U6IFwiMS4xNS4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfR0xPQkFMLFxuICAgICAgdHlwZTogXCJjaG9pY2VcIixcbiAgICAgIGRlZmF1bHQ6IFt7XG4gICAgICAgIHNpbmNlOiBcIjEuMTUuMFwiLFxuICAgICAgICB2YWx1ZTogXCJhdXRvXCJcbiAgICAgIH0sIHtcbiAgICAgICAgc2luY2U6IFwiMi4wLjBcIixcbiAgICAgICAgdmFsdWU6IFwibGZcIlxuICAgICAgfV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJXaGljaCBlbmQgb2YgbGluZSBjaGFyYWN0ZXJzIHRvIGFwcGx5LlwiLFxuICAgICAgY2hvaWNlczogW3tcbiAgICAgICAgdmFsdWU6IFwibGZcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTGluZSBGZWVkIG9ubHkgKFxcXFxuKSwgY29tbW9uIG9uIExpbnV4IGFuZCBtYWNPUyBhcyB3ZWxsIGFzIGluc2lkZSBnaXQgcmVwb3NcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJjcmxmXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkNhcnJpYWdlIFJldHVybiArIExpbmUgRmVlZCBjaGFyYWN0ZXJzIChcXFxcclxcXFxuKSwgY29tbW9uIG9uIFdpbmRvd3NcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJjclwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDYXJyaWFnZSBSZXR1cm4gY2hhcmFjdGVyIG9ubHkgKFxcXFxyKSwgdXNlZCB2ZXJ5IHJhcmVseVwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImF1dG9cIixcbiAgICAgICAgZGVzY3JpcHRpb246IGRlZGVudF8xKF90ZW1wbGF0ZU9iamVjdDIoKSlcbiAgICAgIH1dXG4gICAgfSxcbiAgICBmaWxlcGF0aDoge1xuICAgICAgc2luY2U6IFwiMS40LjBcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9TUEVDSUFMLFxuICAgICAgdHlwZTogXCJwYXRoXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJTcGVjaWZ5IHRoZSBpbnB1dCBmaWxlcGF0aC4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZG8gcGFyc2VyIGluZmVyZW5jZS5cIixcbiAgICAgIGNsaU5hbWU6IFwic3RkaW4tZmlsZXBhdGhcIixcbiAgICAgIGNsaUNhdGVnb3J5OiBDQVRFR09SWV9PVEhFUixcbiAgICAgIGNsaURlc2NyaXB0aW9uOiBcIlBhdGggdG8gdGhlIGZpbGUgdG8gcHJldGVuZCB0aGF0IHN0ZGluIGNvbWVzIGZyb20uXCJcbiAgICB9LFxuICAgIGluc2VydFByYWdtYToge1xuICAgICAgc2luY2U6IFwiMS44LjBcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9TUEVDSUFMLFxuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkluc2VydCBAZm9ybWF0IHByYWdtYSBpbnRvIGZpbGUncyBmaXJzdCBkb2NibG9jayBjb21tZW50LlwiLFxuICAgICAgY2xpQ2F0ZWdvcnk6IENBVEVHT1JZX09USEVSXG4gICAgfSxcbiAgICBwYXJzZXI6IHtcbiAgICAgIHNpbmNlOiBcIjAuMC4xMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0dMT0JBTCxcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBkZWZhdWx0OiBbe1xuICAgICAgICBzaW5jZTogXCIwLjAuMTBcIixcbiAgICAgICAgdmFsdWU6IFwiYmFieWxvblwiXG4gICAgICB9LCB7XG4gICAgICAgIHNpbmNlOiBcIjEuMTMuMFwiLFxuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICB9XSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIldoaWNoIHBhcnNlciB0byB1c2UuXCIsXG4gICAgICBleGNlcHRpb246IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIixcbiAgICAgIGNob2ljZXM6IFt7XG4gICAgICAgIHZhbHVlOiBcImZsb3dcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmxvd1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImJhYmVsXCIsXG4gICAgICAgIHNpbmNlOiBcIjEuMTYuMFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJKYXZhU2NyaXB0XCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiYmFiZWwtZmxvd1wiLFxuICAgICAgICBzaW5jZTogXCIxLjE2LjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRmxvd1wiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImJhYmVsLXRzXCIsXG4gICAgICAgIHNpbmNlOiBcIjIuMC4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlR5cGVTY3JpcHRcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJ0eXBlc2NyaXB0XCIsXG4gICAgICAgIHNpbmNlOiBcIjEuNC4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlR5cGVTY3JpcHRcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJjc3NcIixcbiAgICAgICAgc2luY2U6IFwiMS43LjFcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ1NTXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwibGVzc1wiLFxuICAgICAgICBzaW5jZTogXCIxLjcuMVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJMZXNzXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwic2Nzc1wiLFxuICAgICAgICBzaW5jZTogXCIxLjcuMVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJTQ1NTXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwianNvblwiLFxuICAgICAgICBzaW5jZTogXCIxLjUuMFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJKU09OXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwianNvbjVcIixcbiAgICAgICAgc2luY2U6IFwiMS4xMy4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkpTT041XCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwianNvbi1zdHJpbmdpZnlcIixcbiAgICAgICAgc2luY2U6IFwiMS4xMy4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkpTT04uc3RyaW5naWZ5XCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiZ3JhcGhxbFwiLFxuICAgICAgICBzaW5jZTogXCIxLjUuMFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJHcmFwaFFMXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwibWFya2Rvd25cIixcbiAgICAgICAgc2luY2U6IFwiMS44LjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTWFya2Rvd25cIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJtZHhcIixcbiAgICAgICAgc2luY2U6IFwiMS4xNS4wXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk1EWFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcInZ1ZVwiLFxuICAgICAgICBzaW5jZTogXCIxLjEwLjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVnVlXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwieWFtbFwiLFxuICAgICAgICBzaW5jZTogXCIxLjE0LjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiWUFNTFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImdsaW1tZXJcIixcbiAgICAgICAgc2luY2U6IG51bGwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkhhbmRsZWJhcnNcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJodG1sXCIsXG4gICAgICAgIHNpbmNlOiBcIjEuMTUuMFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJIVE1MXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiYW5ndWxhclwiLFxuICAgICAgICBzaW5jZTogXCIxLjE1LjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQW5ndWxhclwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImx3Y1wiLFxuICAgICAgICBzaW5jZTogXCIxLjE3LjBcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTGlnaHRuaW5nIFdlYiBDb21wb25lbnRzXCJcbiAgICAgIH1dXG4gICAgfSxcbiAgICBwbHVnaW5zOiB7XG4gICAgICBzaW5jZTogXCIxLjEwLjBcIixcbiAgICAgIHR5cGU6IFwicGF0aFwiLFxuICAgICAgYXJyYXk6IHRydWUsXG4gICAgICBkZWZhdWx0OiBbe1xuICAgICAgICB2YWx1ZTogW11cbiAgICAgIH1dLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0dMT0JBTCxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkFkZCBhIHBsdWdpbi4gTXVsdGlwbGUgcGx1Z2lucyBjYW4gYmUgcGFzc2VkIGFzIHNlcGFyYXRlIGAtLXBsdWdpbmBzLlwiLFxuICAgICAgZXhjZXB0aW9uOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiLFxuICAgICAgY2xpTmFtZTogXCJwbHVnaW5cIixcbiAgICAgIGNsaUNhdGVnb3J5OiBDQVRFR09SWV9DT05GSUdcbiAgICB9LFxuICAgIHBsdWdpblNlYXJjaERpcnM6IHtcbiAgICAgIHNpbmNlOiBcIjEuMTMuMFwiLFxuICAgICAgdHlwZTogXCJwYXRoXCIsXG4gICAgICBhcnJheTogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IFt7XG4gICAgICAgIHZhbHVlOiBbXVxuICAgICAgfV0sXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfR0xPQkFMLFxuICAgICAgZGVzY3JpcHRpb246IGRlZGVudF8xKF90ZW1wbGF0ZU9iamVjdDMoKSksXG4gICAgICBleGNlcHRpb246IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIsXG4gICAgICBjbGlOYW1lOiBcInBsdWdpbi1zZWFyY2gtZGlyXCIsXG4gICAgICBjbGlDYXRlZ29yeTogQ0FURUdPUllfQ09ORklHXG4gICAgfSxcbiAgICBwcmludFdpZHRoOiB7XG4gICAgICBzaW5jZTogXCIwLjAuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0dMT0JBTCxcbiAgICAgIHR5cGU6IFwiaW50XCIsXG4gICAgICBkZWZhdWx0OiA4MCxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBsaW5lIGxlbmd0aCB3aGVyZSBQcmV0dGllciB3aWxsIHRyeSB3cmFwLlwiLFxuICAgICAgcmFuZ2U6IHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogSW5maW5pdHksXG4gICAgICAgIHN0ZXA6IDFcbiAgICAgIH1cbiAgICB9LFxuICAgIHJhbmdlRW5kOiB7XG4gICAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX1NQRUNJQUwsXG4gICAgICB0eXBlOiBcImludFwiLFxuICAgICAgZGVmYXVsdDogSW5maW5pdHksXG4gICAgICByYW5nZToge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiBJbmZpbml0eSxcbiAgICAgICAgc3RlcDogMVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBkZWRlbnRfMShfdGVtcGxhdGVPYmplY3Q0KCkpLFxuICAgICAgY2xpQ2F0ZWdvcnk6IENBVEVHT1JZX0VESVRPUlxuICAgIH0sXG4gICAgcmFuZ2VTdGFydDoge1xuICAgICAgc2luY2U6IFwiMS40LjBcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9TUEVDSUFMLFxuICAgICAgdHlwZTogXCJpbnRcIixcbiAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICByYW5nZToge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiBJbmZpbml0eSxcbiAgICAgICAgc3RlcDogMVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBkZWRlbnRfMShfdGVtcGxhdGVPYmplY3Q1KCkpLFxuICAgICAgY2xpQ2F0ZWdvcnk6IENBVEVHT1JZX0VESVRPUlxuICAgIH0sXG4gICAgcmVxdWlyZVByYWdtYToge1xuICAgICAgc2luY2U6IFwiMS43LjBcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9TUEVDSUFMLFxuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBkZWRlbnRfMShfdGVtcGxhdGVPYmplY3Q2KCkpLFxuICAgICAgY2xpQ2F0ZWdvcnk6IENBVEVHT1JZX09USEVSXG4gICAgfSxcbiAgICB0YWJXaWR0aDoge1xuICAgICAgdHlwZTogXCJpbnRcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9HTE9CQUwsXG4gICAgICBkZWZhdWx0OiAyLFxuICAgICAgZGVzY3JpcHRpb246IFwiTnVtYmVyIG9mIHNwYWNlcyBwZXIgaW5kZW50YXRpb24gbGV2ZWwuXCIsXG4gICAgICByYW5nZToge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiBJbmZpbml0eSxcbiAgICAgICAgc3RlcDogMVxuICAgICAgfVxuICAgIH0sXG4gICAgdXNlVGFiczoge1xuICAgICAgc2luY2U6IFwiMS4wLjBcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9HTE9CQUwsXG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246IFwiSW5kZW50IHdpdGggdGFicyBpbnN0ZWFkIG9mIHNwYWNlcy5cIlxuICAgIH1cbiAgfTtcbiAgdmFyIGNvcmVPcHRpb25zID0ge1xuICAgIENBVEVHT1JZX0NPTkZJRyxcbiAgICBDQVRFR09SWV9FRElUT1IsXG4gICAgQ0FURUdPUllfRk9STUFULFxuICAgIENBVEVHT1JZX09USEVSLFxuICAgIENBVEVHT1JZX09VVFBVVCxcbiAgICBDQVRFR09SWV9HTE9CQUwsXG4gICAgQ0FURUdPUllfU1BFQ0lBTCxcbiAgICBvcHRpb25zXG4gIH07XG5cbiAgdmFyIHJlcXVpcmUkJDAgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKF9wYWNrYWdlJDEpO1xuXG4gIGNvbnN0IHNlbXZlciQxID0ge1xuICAgIGNvbXBhcmU6IGNvbXBhcmVfMSxcbiAgICBsdDogbHRfMSxcbiAgICBndGU6IGd0ZV8xXG4gIH07XG4gIGNvbnN0IGN1cnJlbnRWZXJzaW9uID0gcmVxdWlyZSQkMC52ZXJzaW9uO1xuICBjb25zdCBjb3JlT3B0aW9ucyQxID0gY29yZU9wdGlvbnMub3B0aW9ucztcbiAgLyoqXG4gICAqIFN0cmluZ3MgaW4gYHBsdWdpbnNgIGFuZCBgcGx1Z2luU2VhcmNoRGlyc2AgYXJlIGhhbmRsZWQgYnkgYSB3cmFwcGVkIHZlcnNpb25cbiAgICogb2YgdGhpcyBmdW5jdGlvbiBjcmVhdGVkIGJ5IGB3aXRoUGx1Z2luc2AuIERvbid0IHBhc3MgdGhlbSBoZXJlIGRpcmVjdGx5LlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW0wXG4gICAqIEBwYXJhbSB7KHN0cmluZyB8IG9iamVjdClbXT19IHBhcmFtMC5wbHVnaW5zIFN0cmluZ3MgYXJlIHJlc29sdmVkIGJ5IGB3aXRoUGx1Z2luc2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nW109fSBwYXJhbTAucGx1Z2luU2VhcmNoRGlycyBBZGRlZCBieSBgd2l0aFBsdWdpbnNgLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwYXJhbTAuc2hvd1VucmVsZWFzZWRcbiAgICogQHBhcmFtIHtib29sZWFuPX0gcGFyYW0wLnNob3dEZXByZWNhdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHBhcmFtMC5zaG93SW50ZXJuYWxcbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0U3VwcG9ydEluZm8oe1xuICAgIHBsdWdpbnMgPSBbXSxcbiAgICBzaG93VW5yZWxlYXNlZCA9IGZhbHNlLFxuICAgIHNob3dEZXByZWNhdGVkID0gZmFsc2UsXG4gICAgc2hvd0ludGVybmFsID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgLy8gcHJlLXJlbGVhc2UgdmVyc2lvbiBpcyBzbWFsbGVyIHRoYW4gdGhlIG5vcm1hbCB2ZXJzaW9uIGluIHNlbXZlcixcbiAgICAvLyB3ZSBuZWVkIHRvIHRyZWF0IGl0IGFzIHRoZSBub3JtYWwgb25lIHNvIGFzIHRvIHRlc3QgbmV3IGZlYXR1cmVzLlxuICAgIGNvbnN0IHZlcnNpb24gPSBjdXJyZW50VmVyc2lvbi5zcGxpdChcIi1cIiwgMSlbMF07XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFycmF5aWZ5KE9iamVjdC5hc3NpZ24oe30sIC4uLnBsdWdpbnMubWFwKCh7XG4gICAgICBvcHRpb25zXG4gICAgfSkgPT4gb3B0aW9ucyksIGNvcmVPcHRpb25zJDEpLCBcIm5hbWVcIikuZmlsdGVyKG9wdGlvbiA9PiBmaWx0ZXJTaW5jZShvcHRpb24pICYmIGZpbHRlckRlcHJlY2F0ZWQob3B0aW9uKSkuc29ydCgoYSwgYikgPT4gYS5uYW1lID09PSBiLm5hbWUgPyAwIDogYS5uYW1lIDwgYi5uYW1lID8gLTEgOiAxKS5tYXAobWFwSW50ZXJuYWwpLm1hcChvcHRpb24gPT4ge1xuICAgICAgb3B0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uLmRlZmF1bHQpKSB7XG4gICAgICAgIG9wdGlvbi5kZWZhdWx0ID0gb3B0aW9uLmRlZmF1bHQubGVuZ3RoID09PSAxID8gb3B0aW9uLmRlZmF1bHRbMF0udmFsdWUgOiBvcHRpb24uZGVmYXVsdC5maWx0ZXIoZmlsdGVyU2luY2UpLnNvcnQoKGluZm8xLCBpbmZvMikgPT4gc2VtdmVyJDEuY29tcGFyZShpbmZvMi5zaW5jZSwgaW5mbzEuc2luY2UpKVswXS52YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uLmNob2ljZXMpKSB7XG4gICAgICAgIG9wdGlvbi5jaG9pY2VzID0gb3B0aW9uLmNob2ljZXMuZmlsdGVyKG9wdGlvbiA9PiBmaWx0ZXJTaW5jZShvcHRpb24pICYmIGZpbHRlckRlcHJlY2F0ZWQob3B0aW9uKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpbHRlcmVkUGx1Z2lucyA9IHBsdWdpbnMuZmlsdGVyKHBsdWdpbiA9PiBwbHVnaW4uZGVmYXVsdE9wdGlvbnMgJiYgcGx1Z2luLmRlZmF1bHRPcHRpb25zW29wdGlvbi5uYW1lXSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IHBsdWdpbkRlZmF1bHRzID0gZmlsdGVyZWRQbHVnaW5zLnJlZHVjZSgocmVkdWNlZCwgcGx1Z2luKSA9PiB7XG4gICAgICAgIHJlZHVjZWRbcGx1Z2luLm5hbWVdID0gcGx1Z2luLmRlZmF1bHRPcHRpb25zW29wdGlvbi5uYW1lXTtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWQ7XG4gICAgICB9LCB7fSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uLCB7XG4gICAgICAgIHBsdWdpbkRlZmF1bHRzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBsYW5ndWFnZXMgPSBwbHVnaW5zLnJlZHVjZSgoYWxsLCBwbHVnaW4pID0+IGFsbC5jb25jYXQocGx1Z2luLmxhbmd1YWdlcyB8fCBbXSksIFtdKS5maWx0ZXIoZmlsdGVyU2luY2UpO1xuICAgIHJldHVybiB7XG4gICAgICBsYW5ndWFnZXMsXG4gICAgICBvcHRpb25zXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZpbHRlclNpbmNlKG9iamVjdCkge1xuICAgICAgcmV0dXJuIHNob3dVbnJlbGVhc2VkIHx8ICEoXCJzaW5jZVwiIGluIG9iamVjdCkgfHwgb2JqZWN0LnNpbmNlICYmIHNlbXZlciQxLmd0ZSh2ZXJzaW9uLCBvYmplY3Quc2luY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlckRlcHJlY2F0ZWQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gc2hvd0RlcHJlY2F0ZWQgfHwgIShcImRlcHJlY2F0ZWRcIiBpbiBvYmplY3QpIHx8IG9iamVjdC5kZXByZWNhdGVkICYmIHNlbXZlciQxLmx0KHZlcnNpb24sIG9iamVjdC5kZXByZWNhdGVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBJbnRlcm5hbChvYmplY3QpIHtcbiAgICAgIGlmIChzaG93SW50ZXJuYWwpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3T2JqZWN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uob2JqZWN0LCBbXCJjbGlOYW1lXCIsIFwiY2xpQ2F0ZWdvcnlcIiwgXCJjbGlEZXNjcmlwdGlvblwiXSk7XG5cbiAgICAgIHJldHVybiBuZXdPYmplY3Q7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgZ2V0U3VwcG9ydEluZm9cbiAgfTtcblxuICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxuICB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG4gIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gIFRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbiAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuICBNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuICBTZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuICAvKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuICB2YXIgX2V4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiBleHRlbmRTdGF0aWNzKGQsIGIpIHtcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICAgIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuXG4gICAgZnVuY3Rpb24gX18oKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgICB9XG5cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH1cblxuICB2YXIgX2Fzc2lnbiA9IGZ1bmN0aW9uIF9fYXNzaWduKCkge1xuICAgIF9hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICAgIHZhciB0ID0ge307XG5cbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG5cbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLFxuICAgICAgICBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7ZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuICB9XG4gIGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgICAgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkge1xuICAgICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQudmFsdWUpO1xuICAgICAgICB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0ge1xuICAgICAgbGFiZWw6IDAsXG4gICAgICBzZW50OiBmdW5jdGlvbiBzZW50KCkge1xuICAgICAgICBpZiAodFswXSAmIDEpIHRocm93IHRbMV07XG4gICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgfSxcbiAgICAgIHRyeXM6IFtdLFxuICAgICAgb3BzOiBbXVxuICAgIH0sXG4gICAgICAgIGYsXG4gICAgICAgIHksXG4gICAgICAgIHQsXG4gICAgICAgIGc7XG4gICAgcmV0dXJuIGcgPSB7XG4gICAgICBuZXh0OiB2ZXJiKDApLFxuICAgICAgXCJ0aHJvd1wiOiB2ZXJiKDEpLFxuICAgICAgXCJyZXR1cm5cIjogdmVyYigyKVxuICAgIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSksIGc7XG5cbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gc3RlcChbbiwgdl0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cbiAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblxuICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG9wWzFdLFxuICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgIG9wID0gWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuXG4gICAgICAgICAgICBfLnRyeXMucG9wKCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgIF8gPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCBvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkge1xuICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgIHQgPSBvcDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7XG4gICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuXG4gICAgICAgICAgICAgIF8ub3BzLnB1c2gob3ApO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cbiAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgb3AgPSBbNiwgZV07XG4gICAgICAgIHkgPSAwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbiAgfVxuICBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLFxuICAgICAgICBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogbyAmJiBvW2krK10sXG4gICAgICAgICAgZG9uZTogIW9cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksXG4gICAgICAgIHIsXG4gICAgICAgIGFyID0gW10sXG4gICAgICAgIGU7XG5cbiAgICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGUgPSB7XG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZSkgdGhyb3cgZS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXI7XG4gIH1cbiAgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcblxuICAgIHJldHVybiBhcjtcbiAgfVxuICBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcblxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKykgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspIHJba10gPSBhW2pdO1xuXG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG4gIH1cbiAgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLFxuICAgICAgICBpLFxuICAgICAgICBxID0gW107XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBpO1xuXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnW25dKHYpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0dGxlKHFbMF1bM10sIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAocikge1xuICAgICAgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkge1xuICAgICAgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgICByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHtcbiAgICAgIGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICAgIHZhciBpLCBwO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGk7XG5cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHtcbiAgICAgIGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIChwID0gIXApID8ge1xuICAgICAgICAgIHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLFxuICAgICAgICAgIGRvbmU6IG4gPT09IFwicmV0dXJuXCJcbiAgICAgICAgfSA6IGYgPyBmKHYpIDogdjtcbiAgICAgIH0gOiBmO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sXG4gICAgICAgIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGkpO1xuXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7XG4gICAgICBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgICAgZG9uZTogZFxuICAgICAgICB9KTtcbiAgICAgIH0sIHJlamVjdCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwge1xuICAgICAgICB2YWx1ZTogcmF3XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29va2VkLnJhdyA9IHJhdztcbiAgICB9XG5cbiAgICByZXR1cm4gY29va2VkO1xuICB9XG4gIGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdC5kZWZhdWx0ID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgICBkZWZhdWx0OiBtb2RcbiAgICB9O1xuICB9XG5cbiAgdmFyIHRzbGliX2VzNiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgX19leHRlbmRzOiBfX2V4dGVuZHMsXG4gICAgZ2V0IF9fYXNzaWduICgpIHsgcmV0dXJuIF9hc3NpZ247IH0sXG4gICAgX19yZXN0OiBfX3Jlc3QsXG4gICAgX19kZWNvcmF0ZTogX19kZWNvcmF0ZSxcbiAgICBfX3BhcmFtOiBfX3BhcmFtLFxuICAgIF9fbWV0YWRhdGE6IF9fbWV0YWRhdGEsXG4gICAgX19hd2FpdGVyOiBfX2F3YWl0ZXIsXG4gICAgX19nZW5lcmF0b3I6IF9fZ2VuZXJhdG9yLFxuICAgIF9fZXhwb3J0U3RhcjogX19leHBvcnRTdGFyLFxuICAgIF9fdmFsdWVzOiBfX3ZhbHVlcyxcbiAgICBfX3JlYWQ6IF9fcmVhZCxcbiAgICBfX3NwcmVhZDogX19zcHJlYWQsXG4gICAgX19zcHJlYWRBcnJheXM6IF9fc3ByZWFkQXJyYXlzLFxuICAgIF9fYXdhaXQ6IF9fYXdhaXQsXG4gICAgX19hc3luY0dlbmVyYXRvcjogX19hc3luY0dlbmVyYXRvcixcbiAgICBfX2FzeW5jRGVsZWdhdG9yOiBfX2FzeW5jRGVsZWdhdG9yLFxuICAgIF9fYXN5bmNWYWx1ZXM6IF9fYXN5bmNWYWx1ZXMsXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3Q6IF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxuICAgIF9faW1wb3J0U3RhcjogX19pbXBvcnRTdGFyLFxuICAgIF9faW1wb3J0RGVmYXVsdDogX19pbXBvcnREZWZhdWx0XG4gIH0pO1xuXG4gIHZhciBhcGkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0cy5hcGlEZXNjcmlwdG9yID0ge1xuICAgICAga2V5OiBfa2V5ID0+IC9eWyRfYS16QS1aXVskX2EtekEtWjAtOV0qJC8udGVzdChfa2V5KSA/IF9rZXkgOiBKU09OLnN0cmluZ2lmeShfa2V5KSxcblxuICAgICAgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdCh2YWx1ZS5tYXAoc3ViVmFsdWUgPT4gZXhwb3J0cy5hcGlEZXNjcmlwdG9yLnZhbHVlKHN1YlZhbHVlKSkuam9pbignLCAnKSwgXCJdXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoID09PSAwID8gJ3t9JyA6IFwieyBcIi5jb25jYXQoa2V5cy5tYXAoa2V5ID0+IFwiXCIuY29uY2F0KGV4cG9ydHMuYXBpRGVzY3JpcHRvci5rZXkoa2V5KSwgXCI6IFwiKS5jb25jYXQoZXhwb3J0cy5hcGlEZXNjcmlwdG9yLnZhbHVlKHZhbHVlW2tleV0pKSkuam9pbignLCAnKSwgXCIgfVwiKTtcbiAgICAgIH0sXG5cbiAgICAgIHBhaXI6ICh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pID0+IGV4cG9ydHMuYXBpRGVzY3JpcHRvci52YWx1ZSh7XG4gICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgfSlcbiAgICB9O1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhhcGkpO1xuICB2YXIgYXBpXzEgPSBhcGkuYXBpRGVzY3JpcHRvcjtcblxuICB2YXIgdHNsaWJfMSA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UodHNsaWJfZXM2KTtcblxuICB2YXIgZGVzY3JpcHRvcnMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihhcGksIGV4cG9ydHMpO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhkZXNjcmlwdG9ycyk7XG5cbiAgdmFyIG1hdGNoT3BlcmF0b3JzUmUgPSAvW3xcXFxce30oKVtcXF1eJCsqPy5dL2c7XG5cbiAgdmFyIGVzY2FwZVN0cmluZ1JlZ2V4cCA9IGZ1bmN0aW9uIGVzY2FwZVN0cmluZ1JlZ2V4cChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUsICdcXFxcJCYnKTtcbiAgfTtcblxuICB2YXIgY29sb3JOYW1lID0ge1xuICAgIFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcbiAgICBcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXG4gICAgXCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXG4gICAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcbiAgICBcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcbiAgICBcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcbiAgICBcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXG4gICAgXCJibGFja1wiOiBbMCwgMCwgMF0sXG4gICAgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXG4gICAgXCJibHVlXCI6IFswLCAwLCAyNTVdLFxuICAgIFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcbiAgICBcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXG4gICAgXCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxuICAgIFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxuICAgIFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxuICAgIFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxuICAgIFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXG4gICAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXG4gICAgXCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXG4gICAgXCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXG4gICAgXCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXG4gICAgXCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcbiAgICBcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXG4gICAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxuICAgIFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxuICAgIFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxuICAgIFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxuICAgIFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcbiAgICBcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXG4gICAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxuICAgIFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxuICAgIFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcbiAgICBcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXG4gICAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcbiAgICBcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXG4gICAgXCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXG4gICAgXCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcbiAgICBcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxuICAgIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxuICAgIFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxuICAgIFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXG4gICAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxuICAgIFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgXCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICBcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXG4gICAgXCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcbiAgICBcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcbiAgICBcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXG4gICAgXCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXG4gICAgXCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxuICAgIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXG4gICAgXCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXG4gICAgXCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXG4gICAgXCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICBcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxuICAgIFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXG4gICAgXCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICBcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcbiAgICBcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxuICAgIFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXG4gICAgXCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxuICAgIFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxuICAgIFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxuICAgIFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxuICAgIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXG4gICAgXCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcbiAgICBcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXG4gICAgXCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxuICAgIFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXG4gICAgXCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxuICAgIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxuICAgIFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxuICAgIFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXG4gICAgXCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXG4gICAgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxuICAgIFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcbiAgICBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcbiAgICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcbiAgICBcImxpbWVcIjogWzAsIDI1NSwgMF0sXG4gICAgXCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcbiAgICBcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcbiAgICBcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcbiAgICBcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcbiAgICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxuICAgIFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcbiAgICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcbiAgICBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXG4gICAgXCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcbiAgICBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXG4gICAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxuICAgIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxuICAgIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxuICAgIFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXG4gICAgXCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxuICAgIFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcbiAgICBcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcbiAgICBcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcbiAgICBcIm5hdnlcIjogWzAsIDAsIDEyOF0sXG4gICAgXCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcbiAgICBcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXG4gICAgXCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXG4gICAgXCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcbiAgICBcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXG4gICAgXCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxuICAgIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXG4gICAgXCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxuICAgIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXG4gICAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcbiAgICBcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxuICAgIFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcbiAgICBcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXG4gICAgXCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcbiAgICBcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxuICAgIFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXG4gICAgXCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcbiAgICBcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXG4gICAgXCJyZWRcIjogWzI1NSwgMCwgMF0sXG4gICAgXCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxuICAgIFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxuICAgIFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcbiAgICBcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXG4gICAgXCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxuICAgIFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcbiAgICBcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcbiAgICBcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxuICAgIFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgICBcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxuICAgIFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxuICAgIFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgICBcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgXCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcbiAgICBcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXG4gICAgXCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXG4gICAgXCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxuICAgIFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxuICAgIFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXG4gICAgXCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcbiAgICBcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcbiAgICBcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXG4gICAgXCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgXCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgICBcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxuICAgIFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cbiAgfTtcblxuICB2YXIgY29udmVyc2lvbnMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgLyogTUlUIGxpY2Vuc2UgKi9cbiAgICAvLyBOT1RFOiBjb252ZXJzaW9ucyBzaG91bGQgb25seSByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcyAoaS5lLiBhcnJheXMsIG9yXG4gICAgLy8gICAgICAgdmFsdWVzIHRoYXQgZ2l2ZSBjb3JyZWN0IGB0eXBlb2ZgIHJlc3VsdHMpLlxuICAgIC8vICAgICAgIGRvIG5vdCB1c2UgYm94IHZhbHVlcyB0eXBlcyAoaS5lLiBOdW1iZXIoKSwgU3RyaW5nKCksIGV0Yy4pXG4gICAgdmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbG9yTmFtZSkge1xuICAgICAgaWYgKGNvbG9yTmFtZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldmVyc2VLZXl3b3Jkc1tjb2xvck5hbWVba2V5XV0gPSBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbnZlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIHJnYjoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAncmdiJ1xuICAgICAgfSxcbiAgICAgIGhzbDoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAnaHNsJ1xuICAgICAgfSxcbiAgICAgIGhzdjoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAnaHN2J1xuICAgICAgfSxcbiAgICAgIGh3Yjoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAnaHdiJ1xuICAgICAgfSxcbiAgICAgIGNteWs6IHtcbiAgICAgICAgY2hhbm5lbHM6IDQsXG4gICAgICAgIGxhYmVsczogJ2NteWsnXG4gICAgICB9LFxuICAgICAgeHl6OiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6ICd4eXonXG4gICAgICB9LFxuICAgICAgbGFiOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6ICdsYWInXG4gICAgICB9LFxuICAgICAgbGNoOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6ICdsY2gnXG4gICAgICB9LFxuICAgICAgaGV4OiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsnaGV4J11cbiAgICAgIH0sXG4gICAgICBrZXl3b3JkOiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsna2V5d29yZCddXG4gICAgICB9LFxuICAgICAgYW5zaTE2OiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsnYW5zaTE2J11cbiAgICAgIH0sXG4gICAgICBhbnNpMjU2OiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsnYW5zaTI1NiddXG4gICAgICB9LFxuICAgICAgaGNnOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6IFsnaCcsICdjJywgJ2cnXVxuICAgICAgfSxcbiAgICAgIGFwcGxlOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXVxuICAgICAgfSxcbiAgICAgIGdyYXk6IHtcbiAgICAgICAgY2hhbm5lbHM6IDEsXG4gICAgICAgIGxhYmVsczogWydncmF5J11cbiAgICAgIH1cbiAgICB9OyAvLyBoaWRlIC5jaGFubmVscyBhbmQgLmxhYmVscyBwcm9wZXJ0aWVzXG5cbiAgICBmb3IgKHZhciBtb2RlbCBpbiBjb252ZXJ0KSB7XG4gICAgICBpZiAoY29udmVydC5oYXNPd25Qcm9wZXJ0eShtb2RlbCkpIHtcbiAgICAgICAgaWYgKCEoJ2NoYW5uZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbCBsYWJlbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udmVydFttb2RlbF0ubGFiZWxzLmxlbmd0aCAhPT0gY29udmVydFttb2RlbF0uY2hhbm5lbHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYW5uZWwgYW5kIGxhYmVsIGNvdW50cyBtaXNtYXRjaDogJyArIG1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVscyA9IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuICAgICAgICB2YXIgbGFiZWxzID0gY29udmVydFttb2RlbF0ubGFiZWxzO1xuICAgICAgICBkZWxldGUgY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG4gICAgICAgIGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2NoYW5uZWxzJywge1xuICAgICAgICAgIHZhbHVlOiBjaGFubmVsc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnbGFiZWxzJywge1xuICAgICAgICAgIHZhbHVlOiBsYWJlbHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udmVydC5yZ2IuaHNsID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICB2YXIgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIHZhciBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuICAgICAgdmFyIGg7XG4gICAgICB2YXIgcztcbiAgICAgIHZhciBsO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuICAgICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMzYwO1xuICAgICAgfVxuXG4gICAgICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGwgPD0gMC41KSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5oc3YgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgcmRpZjtcbiAgICAgIHZhciBnZGlmO1xuICAgICAgdmFyIGJkaWY7XG4gICAgICB2YXIgaDtcbiAgICAgIHZhciBzO1xuICAgICAgdmFyIHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICB2YXIgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIHZhciBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgdmFyIHYgPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICAgIHZhciBkaWZmID0gdiAtIE1hdGgubWluKHIsIGcsIGIpO1xuXG4gICAgICB2YXIgZGlmZmMgPSBmdW5jdGlvbiBkaWZmYyhjKSB7XG4gICAgICAgIHJldHVybiAodiAtIGMpIC8gNiAvIGRpZmYgKyAxIC8gMjtcbiAgICAgIH07XG5cbiAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIGggPSBzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBkaWZmIC8gdjtcbiAgICAgICAgcmRpZiA9IGRpZmZjKHIpO1xuICAgICAgICBnZGlmID0gZGlmZmMoZyk7XG4gICAgICAgIGJkaWYgPSBkaWZmYyhiKTtcblxuICAgICAgICBpZiAociA9PT0gdikge1xuICAgICAgICAgIGggPSBiZGlmIC0gZ2RpZjtcbiAgICAgICAgfSBlbHNlIGlmIChnID09PSB2KSB7XG4gICAgICAgICAgaCA9IDEgLyAzICsgcmRpZiAtIGJkaWY7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdikge1xuICAgICAgICAgIGggPSAyIC8gMyArIGdkaWYgLSByZGlmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgaCArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGggPiAxKSB7XG4gICAgICAgICAgaCAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbaCAqIDM2MCwgcyAqIDEwMCwgdiAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLmh3YiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgIHZhciByID0gcmdiWzBdO1xuICAgICAgdmFyIGcgPSByZ2JbMV07XG4gICAgICB2YXIgYiA9IHJnYlsyXTtcbiAgICAgIHZhciBoID0gY29udmVydC5yZ2IuaHNsKHJnYilbMF07XG4gICAgICB2YXIgdyA9IDEgLyAyNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSk7XG4gICAgICBiID0gMSAtIDEgLyAyNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG4gICAgICByZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5jbXlrID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICB2YXIgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIHZhciBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgdmFyIGM7XG4gICAgICB2YXIgbTtcbiAgICAgIHZhciB5O1xuICAgICAgdmFyIGs7XG4gICAgICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gICAgICBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgICBtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgICByZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlIGh0dHBzOi8vZW4ubS53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2Rpc3RhbmNlI1NxdWFyZWRfRXVjbGlkZWFuX2Rpc3RhbmNlXG4gICAgICogKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coeFswXSAtIHlbMF0sIDIpICsgTWF0aC5wb3coeFsxXSAtIHlbMV0sIDIpICsgTWF0aC5wb3coeFsyXSAtIHlbMl0sIDIpO1xuICAgIH1cblxuICAgIGNvbnZlcnQucmdiLmtleXdvcmQgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgcmV2ZXJzZWQgPSByZXZlcnNlS2V5d29yZHNbcmdiXTtcblxuICAgICAgaWYgKHJldmVyc2VkKSB7XG4gICAgICAgIHJldHVybiByZXZlcnNlZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgIHZhciBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG5cbiAgICAgIGZvciAodmFyIGtleXdvcmQgaW4gY29sb3JOYW1lKSB7XG4gICAgICAgIGlmIChjb2xvck5hbWUuaGFzT3duUHJvcGVydHkoa2V5d29yZCkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb2xvck5hbWVba2V5d29yZF07IC8vIENvbXB1dGUgY29tcGFyYXRpdmUgZGlzdGFuY2VcblxuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7IC8vIENoZWNrIGlmIGl0cyBsZXNzLCBpZiBzbyBzZXQgYXMgY2xvc2VzdFxuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgY3VycmVudENsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgY3VycmVudENsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgY3VycmVudENsb3Nlc3RLZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcbiAgICB9O1xuXG4gICAgY29udmVydC5rZXl3b3JkLnJnYiA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XG4gICAgICByZXR1cm4gY29sb3JOYW1lW2tleXdvcmRdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi54eXogPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgciA9IHJnYlswXSAvIDI1NTtcbiAgICAgIHZhciBnID0gcmdiWzFdIC8gMjU1O1xuICAgICAgdmFyIGIgPSByZ2JbMl0gLyAyNTU7IC8vIGFzc3VtZSBzUkdCXG5cbiAgICAgIHIgPSByID4gMC4wNDA0NSA/IE1hdGgucG93KChyICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiByIC8gMTIuOTI7XG4gICAgICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoZyArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogZyAvIDEyLjkyO1xuICAgICAgYiA9IGIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKGIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IGIgLyAxMi45MjtcbiAgICAgIHZhciB4ID0gciAqIDAuNDEyNCArIGcgKiAwLjM1NzYgKyBiICogMC4xODA1O1xuICAgICAgdmFyIHkgPSByICogMC4yMTI2ICsgZyAqIDAuNzE1MiArIGIgKiAwLjA3MjI7XG4gICAgICB2YXIgeiA9IHIgKiAwLjAxOTMgKyBnICogMC4xMTkyICsgYiAqIDAuOTUwNTtcbiAgICAgIHJldHVybiBbeCAqIDEwMCwgeSAqIDEwMCwgeiAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLmxhYiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgIHZhciB4eXogPSBjb252ZXJ0LnJnYi54eXoocmdiKTtcbiAgICAgIHZhciB4ID0geHl6WzBdO1xuICAgICAgdmFyIHkgPSB4eXpbMV07XG4gICAgICB2YXIgeiA9IHh5elsyXTtcbiAgICAgIHZhciBsO1xuICAgICAgdmFyIGE7XG4gICAgICB2YXIgYjtcbiAgICAgIHggLz0gOTUuMDQ3O1xuICAgICAgeSAvPSAxMDA7XG4gICAgICB6IC89IDEwOC44ODM7XG4gICAgICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogNy43ODcgKiB4ICsgMTYgLyAxMTY7XG4gICAgICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogNy43ODcgKiB5ICsgMTYgLyAxMTY7XG4gICAgICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogNy43ODcgKiB6ICsgMTYgLyAxMTY7XG4gICAgICBsID0gMTE2ICogeSAtIDE2O1xuICAgICAgYSA9IDUwMCAqICh4IC0geSk7XG4gICAgICBiID0gMjAwICogKHkgLSB6KTtcbiAgICAgIHJldHVybiBbbCwgYSwgYl07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaHNsLnJnYiA9IGZ1bmN0aW9uIChoc2wpIHtcbiAgICAgIHZhciBoID0gaHNsWzBdIC8gMzYwO1xuICAgICAgdmFyIHMgPSBoc2xbMV0gLyAxMDA7XG4gICAgICB2YXIgbCA9IGhzbFsyXSAvIDEwMDtcbiAgICAgIHZhciB0MTtcbiAgICAgIHZhciB0MjtcbiAgICAgIHZhciB0MztcbiAgICAgIHZhciByZ2I7XG4gICAgICB2YXIgdmFsO1xuXG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICB2YWwgPSBsICogMjU1O1xuICAgICAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICAgICAgfVxuXG4gICAgICBpZiAobCA8IDAuNSkge1xuICAgICAgICB0MiA9IGwgKiAoMSArIHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdDIgPSBsICsgcyAtIGwgKiBzO1xuICAgICAgfVxuXG4gICAgICB0MSA9IDIgKiBsIC0gdDI7XG4gICAgICByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHQzID0gaCArIDEgLyAzICogLShpIC0gMSk7XG5cbiAgICAgICAgaWYgKHQzIDwgMCkge1xuICAgICAgICAgIHQzKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodDMgPiAxKSB7XG4gICAgICAgICAgdDMtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICg2ICogdDMgPCAxKSB7XG4gICAgICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgICAgIH0gZWxzZSBpZiAoMiAqIHQzIDwgMSkge1xuICAgICAgICAgIHZhbCA9IHQyO1xuICAgICAgICB9IGVsc2UgaWYgKDMgKiB0MyA8IDIpIHtcbiAgICAgICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gdDE7XG4gICAgICAgIH1cblxuICAgICAgICByZ2JbaV0gPSB2YWwgKiAyNTU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZ2I7XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaHNsLmhzdiA9IGZ1bmN0aW9uIChoc2wpIHtcbiAgICAgIHZhciBoID0gaHNsWzBdO1xuICAgICAgdmFyIHMgPSBoc2xbMV0gLyAxMDA7XG4gICAgICB2YXIgbCA9IGhzbFsyXSAvIDEwMDtcbiAgICAgIHZhciBzbWluID0gcztcbiAgICAgIHZhciBsbWluID0gTWF0aC5tYXgobCwgMC4wMSk7XG4gICAgICB2YXIgc3Y7XG4gICAgICB2YXIgdjtcbiAgICAgIGwgKj0gMjtcbiAgICAgIHMgKj0gbCA8PSAxID8gbCA6IDIgLSBsO1xuICAgICAgc21pbiAqPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG4gICAgICB2ID0gKGwgKyBzKSAvIDI7XG4gICAgICBzdiA9IGwgPT09IDAgPyAyICogc21pbiAvIChsbWluICsgc21pbikgOiAyICogcyAvIChsICsgcyk7XG4gICAgICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5oc3YucmdiID0gZnVuY3Rpb24gKGhzdikge1xuICAgICAgdmFyIGggPSBoc3ZbMF0gLyA2MDtcbiAgICAgIHZhciBzID0gaHN2WzFdIC8gMTAwO1xuICAgICAgdmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG4gICAgICB2YXIgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcbiAgICAgIHZhciBmID0gaCAtIE1hdGguZmxvb3IoaCk7XG4gICAgICB2YXIgcCA9IDI1NSAqIHYgKiAoMSAtIHMpO1xuICAgICAgdmFyIHEgPSAyNTUgKiB2ICogKDEgLSBzICogZik7XG4gICAgICB2YXIgdCA9IDI1NSAqIHYgKiAoMSAtIHMgKiAoMSAtIGYpKTtcbiAgICAgIHYgKj0gMjU1O1xuXG4gICAgICBzd2l0Y2ggKGhpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gW3YsIHQsIHBdO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gW3EsIHYsIHBdO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gW3AsIHYsIHRdO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gW3AsIHEsIHZdO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gW3QsIHAsIHZdO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gW3YsIHAsIHFdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb252ZXJ0Lmhzdi5oc2wgPSBmdW5jdGlvbiAoaHN2KSB7XG4gICAgICB2YXIgaCA9IGhzdlswXTtcbiAgICAgIHZhciBzID0gaHN2WzFdIC8gMTAwO1xuICAgICAgdmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG4gICAgICB2YXIgdm1pbiA9IE1hdGgubWF4KHYsIDAuMDEpO1xuICAgICAgdmFyIGxtaW47XG4gICAgICB2YXIgc2w7XG4gICAgICB2YXIgbDtcbiAgICAgIGwgPSAoMiAtIHMpICogdjtcbiAgICAgIGxtaW4gPSAoMiAtIHMpICogdm1pbjtcbiAgICAgIHNsID0gcyAqIHZtaW47XG4gICAgICBzbCAvPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG4gICAgICBzbCA9IHNsIHx8IDA7XG4gICAgICBsIC89IDI7XG4gICAgICByZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbiAgICB9OyAvLyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtY29sb3IvI2h3Yi10by1yZ2JcblxuXG4gICAgY29udmVydC5od2IucmdiID0gZnVuY3Rpb24gKGh3Yikge1xuICAgICAgdmFyIGggPSBod2JbMF0gLyAzNjA7XG4gICAgICB2YXIgd2ggPSBod2JbMV0gLyAxMDA7XG4gICAgICB2YXIgYmwgPSBod2JbMl0gLyAxMDA7XG4gICAgICB2YXIgcmF0aW8gPSB3aCArIGJsO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgdjtcbiAgICAgIHZhciBmO1xuICAgICAgdmFyIG47IC8vIHdoICsgYmwgY2FudCBiZSA+IDFcblxuICAgICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgICB3aCAvPSByYXRpbztcbiAgICAgICAgYmwgLz0gcmF0aW87XG4gICAgICB9XG5cbiAgICAgIGkgPSBNYXRoLmZsb29yKDYgKiBoKTtcbiAgICAgIHYgPSAxIC0gYmw7XG4gICAgICBmID0gNiAqIGggLSBpO1xuXG4gICAgICBpZiAoKGkgJiAweDAxKSAhPT0gMCkge1xuICAgICAgICBmID0gMSAtIGY7XG4gICAgICB9XG5cbiAgICAgIG4gPSB3aCArIGYgKiAodiAtIHdoKTsgLy8gbGluZWFyIGludGVycG9sYXRpb25cblxuICAgICAgdmFyIHI7XG4gICAgICB2YXIgZztcbiAgICAgIHZhciBiO1xuXG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgciA9IHY7XG4gICAgICAgICAgZyA9IG47XG4gICAgICAgICAgYiA9IHdoO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByID0gbjtcbiAgICAgICAgICBnID0gdjtcbiAgICAgICAgICBiID0gd2g7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHIgPSB3aDtcbiAgICAgICAgICBnID0gdjtcbiAgICAgICAgICBiID0gbjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgciA9IHdoO1xuICAgICAgICAgIGcgPSBuO1xuICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByID0gbjtcbiAgICAgICAgICBnID0gd2g7XG4gICAgICAgICAgYiA9IHY7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHIgPSB2O1xuICAgICAgICAgIGcgPSB3aDtcbiAgICAgICAgICBiID0gbjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbiAgICB9O1xuXG4gICAgY29udmVydC5jbXlrLnJnYiA9IGZ1bmN0aW9uIChjbXlrKSB7XG4gICAgICB2YXIgYyA9IGNteWtbMF0gLyAxMDA7XG4gICAgICB2YXIgbSA9IGNteWtbMV0gLyAxMDA7XG4gICAgICB2YXIgeSA9IGNteWtbMl0gLyAxMDA7XG4gICAgICB2YXIgayA9IGNteWtbM10gLyAxMDA7XG4gICAgICB2YXIgcjtcbiAgICAgIHZhciBnO1xuICAgICAgdmFyIGI7XG4gICAgICByID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG4gICAgICBnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG4gICAgICBiID0gMSAtIE1hdGgubWluKDEsIHkgKiAoMSAtIGspICsgayk7XG4gICAgICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0Lnh5ei5yZ2IgPSBmdW5jdGlvbiAoeHl6KSB7XG4gICAgICB2YXIgeCA9IHh5elswXSAvIDEwMDtcbiAgICAgIHZhciB5ID0geHl6WzFdIC8gMTAwO1xuICAgICAgdmFyIHogPSB4eXpbMl0gLyAxMDA7XG4gICAgICB2YXIgcjtcbiAgICAgIHZhciBnO1xuICAgICAgdmFyIGI7XG4gICAgICByID0geCAqIDMuMjQwNiArIHkgKiAtMS41MzcyICsgeiAqIC0wLjQ5ODY7XG4gICAgICBnID0geCAqIC0wLjk2ODkgKyB5ICogMS44NzU4ICsgeiAqIDAuMDQxNTtcbiAgICAgIGIgPSB4ICogMC4wNTU3ICsgeSAqIC0wLjIwNDAgKyB6ICogMS4wNTcwOyAvLyBhc3N1bWUgc1JHQlxuXG4gICAgICByID0gciA+IDAuMDAzMTMwOCA/IDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSAtIDAuMDU1IDogciAqIDEyLjkyO1xuICAgICAgZyA9IGcgPiAwLjAwMzEzMDggPyAxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkgLSAwLjA1NSA6IGcgKiAxMi45MjtcbiAgICAgIGIgPSBiID4gMC4wMDMxMzA4ID8gMS4wNTUgKiBNYXRoLnBvdyhiLCAxLjAgLyAyLjQpIC0gMC4wNTUgOiBiICogMTIuOTI7XG4gICAgICByID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgciksIDEpO1xuICAgICAgZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcbiAgICAgIGIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBiKSwgMSk7XG4gICAgICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0Lnh5ei5sYWIgPSBmdW5jdGlvbiAoeHl6KSB7XG4gICAgICB2YXIgeCA9IHh5elswXTtcbiAgICAgIHZhciB5ID0geHl6WzFdO1xuICAgICAgdmFyIHogPSB4eXpbMl07XG4gICAgICB2YXIgbDtcbiAgICAgIHZhciBhO1xuICAgICAgdmFyIGI7XG4gICAgICB4IC89IDk1LjA0NztcbiAgICAgIHkgLz0gMTAwO1xuICAgICAgeiAvPSAxMDguODgzO1xuICAgICAgeCA9IHggPiAwLjAwODg1NiA/IE1hdGgucG93KHgsIDEgLyAzKSA6IDcuNzg3ICogeCArIDE2IC8gMTE2O1xuICAgICAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6IDcuNzg3ICogeSArIDE2IC8gMTE2O1xuICAgICAgeiA9IHogPiAwLjAwODg1NiA/IE1hdGgucG93KHosIDEgLyAzKSA6IDcuNzg3ICogeiArIDE2IC8gMTE2O1xuICAgICAgbCA9IDExNiAqIHkgLSAxNjtcbiAgICAgIGEgPSA1MDAgKiAoeCAtIHkpO1xuICAgICAgYiA9IDIwMCAqICh5IC0geik7XG4gICAgICByZXR1cm4gW2wsIGEsIGJdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmxhYi54eXogPSBmdW5jdGlvbiAobGFiKSB7XG4gICAgICB2YXIgbCA9IGxhYlswXTtcbiAgICAgIHZhciBhID0gbGFiWzFdO1xuICAgICAgdmFyIGIgPSBsYWJbMl07XG4gICAgICB2YXIgeDtcbiAgICAgIHZhciB5O1xuICAgICAgdmFyIHo7XG4gICAgICB5ID0gKGwgKyAxNikgLyAxMTY7XG4gICAgICB4ID0gYSAvIDUwMCArIHk7XG4gICAgICB6ID0geSAtIGIgLyAyMDA7XG4gICAgICB2YXIgeTIgPSBNYXRoLnBvdyh5LCAzKTtcbiAgICAgIHZhciB4MiA9IE1hdGgucG93KHgsIDMpO1xuICAgICAgdmFyIHoyID0gTWF0aC5wb3coeiwgMyk7XG4gICAgICB5ID0geTIgPiAwLjAwODg1NiA/IHkyIDogKHkgLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICAgIHggPSB4MiA+IDAuMDA4ODU2ID8geDIgOiAoeCAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuICAgICAgeiA9IHoyID4gMC4wMDg4NTYgPyB6MiA6ICh6IC0gMTYgLyAxMTYpIC8gNy43ODc7XG4gICAgICB4ICo9IDk1LjA0NztcbiAgICAgIHkgKj0gMTAwO1xuICAgICAgeiAqPSAxMDguODgzO1xuICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9O1xuXG4gICAgY29udmVydC5sYWIubGNoID0gZnVuY3Rpb24gKGxhYikge1xuICAgICAgdmFyIGwgPSBsYWJbMF07XG4gICAgICB2YXIgYSA9IGxhYlsxXTtcbiAgICAgIHZhciBiID0gbGFiWzJdO1xuICAgICAgdmFyIGhyO1xuICAgICAgdmFyIGg7XG4gICAgICB2YXIgYztcbiAgICAgIGhyID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgICAgIGggPSBociAqIDM2MCAvIDIgLyBNYXRoLlBJO1xuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCArPSAzNjA7XG4gICAgICB9XG5cbiAgICAgIGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICByZXR1cm4gW2wsIGMsIGhdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmxjaC5sYWIgPSBmdW5jdGlvbiAobGNoKSB7XG4gICAgICB2YXIgbCA9IGxjaFswXTtcbiAgICAgIHZhciBjID0gbGNoWzFdO1xuICAgICAgdmFyIGggPSBsY2hbMl07XG4gICAgICB2YXIgYTtcbiAgICAgIHZhciBiO1xuICAgICAgdmFyIGhyO1xuICAgICAgaHIgPSBoIC8gMzYwICogMiAqIE1hdGguUEk7XG4gICAgICBhID0gYyAqIE1hdGguY29zKGhyKTtcbiAgICAgIGIgPSBjICogTWF0aC5zaW4oaHIpO1xuICAgICAgcmV0dXJuIFtsLCBhLCBiXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5yZ2IuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciByID0gYXJnc1swXTtcbiAgICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICAgIHZhciBiID0gYXJnc1syXTtcbiAgICAgIHZhciB2YWx1ZSA9IDEgaW4gYXJndW1lbnRzID8gYXJndW1lbnRzWzFdIDogY29udmVydC5yZ2IuaHN2KGFyZ3MpWzJdOyAvLyBoc3YgLT4gYW5zaTE2IG9wdGltaXphdGlvblxuXG4gICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyA1MCk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMzA7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbnNpID0gMzAgKyAoTWF0aC5yb3VuZChiIC8gMjU1KSA8PCAyIHwgTWF0aC5yb3VuZChnIC8gMjU1KSA8PCAxIHwgTWF0aC5yb3VuZChyIC8gMjU1KSk7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gMikge1xuICAgICAgICBhbnNpICs9IDYwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5zaTtcbiAgICB9O1xuXG4gICAgY29udmVydC5oc3YuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIC8vIG9wdGltaXphdGlvbiBoZXJlOyB3ZSBhbHJlYWR5IGtub3cgdGhlIHZhbHVlIGFuZCBkb24ndCBuZWVkIHRvIGdldFxuICAgICAgLy8gaXQgY29udmVydGVkIGZvciB1cy5cbiAgICAgIHJldHVybiBjb252ZXJ0LnJnYi5hbnNpMTYoY29udmVydC5oc3YucmdiKGFyZ3MpLCBhcmdzWzJdKTtcbiAgICB9O1xuXG4gICAgY29udmVydC5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICB2YXIgciA9IGFyZ3NbMF07XG4gICAgICB2YXIgZyA9IGFyZ3NbMV07XG4gICAgICB2YXIgYiA9IGFyZ3NbMl07IC8vIHdlIHVzZSB0aGUgZXh0ZW5kZWQgZ3JleXNjYWxlIHBhbGV0dGUgaGVyZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mXG4gICAgICAvLyBibGFjayBhbmQgd2hpdGUuIG5vcm1hbCBwYWxldHRlIG9ubHkgaGFzIDQgZ3JleXNjYWxlIHNoYWRlcy5cblxuICAgICAgaWYgKHIgPT09IGcgJiYgZyA9PT0gYikge1xuICAgICAgICBpZiAociA8IDgpIHtcbiAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAociA+IDI0OCkge1xuICAgICAgICAgIHJldHVybiAyMzE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgociAtIDgpIC8gMjQ3ICogMjQpICsgMjMyO1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5zaSA9IDE2ICsgMzYgKiBNYXRoLnJvdW5kKHIgLyAyNTUgKiA1KSArIDYgKiBNYXRoLnJvdW5kKGcgLyAyNTUgKiA1KSArIE1hdGgucm91bmQoYiAvIDI1NSAqIDUpO1xuICAgICAgcmV0dXJuIGFuc2k7XG4gICAgfTtcblxuICAgIGNvbnZlcnQuYW5zaTE2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICB2YXIgY29sb3IgPSBhcmdzICUgMTA7IC8vIGhhbmRsZSBncmV5c2NhbGVcblxuICAgICAgaWYgKGNvbG9yID09PSAwIHx8IGNvbG9yID09PSA3KSB7XG4gICAgICAgIGlmIChhcmdzID4gNTApIHtcbiAgICAgICAgICBjb2xvciArPSAzLjU7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xvciA9IGNvbG9yIC8gMTAuNSAqIDI1NTtcbiAgICAgICAgcmV0dXJuIFtjb2xvciwgY29sb3IsIGNvbG9yXTtcbiAgICAgIH1cblxuICAgICAgdmFyIG11bHQgPSAofn4oYXJncyA+IDUwKSArIDEpICogMC41O1xuICAgICAgdmFyIHIgPSAoY29sb3IgJiAxKSAqIG11bHQgKiAyNTU7XG4gICAgICB2YXIgZyA9IChjb2xvciA+PiAxICYgMSkgKiBtdWx0ICogMjU1O1xuICAgICAgdmFyIGIgPSAoY29sb3IgPj4gMiAmIDEpICogbXVsdCAqIDI1NTtcbiAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuYW5zaTI1Ni5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgLy8gaGFuZGxlIGdyZXlzY2FsZVxuICAgICAgaWYgKGFyZ3MgPj0gMjMyKSB7XG4gICAgICAgIHZhciBjID0gKGFyZ3MgLSAyMzIpICogMTAgKyA4O1xuICAgICAgICByZXR1cm4gW2MsIGMsIGNdO1xuICAgICAgfVxuXG4gICAgICBhcmdzIC09IDE2O1xuICAgICAgdmFyIHJlbTtcbiAgICAgIHZhciByID0gTWF0aC5mbG9vcihhcmdzIC8gMzYpIC8gNSAqIDI1NTtcbiAgICAgIHZhciBnID0gTWF0aC5mbG9vcigocmVtID0gYXJncyAlIDM2KSAvIDYpIC8gNSAqIDI1NTtcbiAgICAgIHZhciBiID0gcmVtICUgNiAvIDUgKiAyNTU7XG4gICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5oZXggPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIGludGVnZXIgPSAoKE1hdGgucm91bmQoYXJnc1swXSkgJiAweEZGKSA8PCAxNikgKyAoKE1hdGgucm91bmQoYXJnc1sxXSkgJiAweEZGKSA8PCA4KSArIChNYXRoLnJvdW5kKGFyZ3NbMl0pICYgMHhGRik7XG4gICAgICB2YXIgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaGV4LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBhcmdzLnRvU3RyaW5nKDE2KS5tYXRjaCgvW2EtZjAtOV17Nn18W2EtZjAtOV17M30vaSk7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIFswLCAwLCAwXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbG9yU3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgICAgIGlmIChtYXRjaFswXS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgY29sb3JTdHJpbmcgPSBjb2xvclN0cmluZy5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXIgKyBjaGFyO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGludGVnZXIgPSBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuICAgICAgdmFyIHIgPSBpbnRlZ2VyID4+IDE2ICYgMHhGRjtcbiAgICAgIHZhciBnID0gaW50ZWdlciA+PiA4ICYgMHhGRjtcbiAgICAgIHZhciBiID0gaW50ZWdlciAmIDB4RkY7XG4gICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5oY2cgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgciA9IHJnYlswXSAvIDI1NTtcbiAgICAgIHZhciBnID0gcmdiWzFdIC8gMjU1O1xuICAgICAgdmFyIGIgPSByZ2JbMl0gLyAyNTU7XG4gICAgICB2YXIgbWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgociwgZyksIGIpO1xuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKE1hdGgubWluKHIsIGcpLCBiKTtcbiAgICAgIHZhciBjaHJvbWEgPSBtYXggLSBtaW47XG4gICAgICB2YXIgZ3JheXNjYWxlO1xuICAgICAgdmFyIGh1ZTtcblxuICAgICAgaWYgKGNocm9tYSA8IDEpIHtcbiAgICAgICAgZ3JheXNjYWxlID0gbWluIC8gKDEgLSBjaHJvbWEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JheXNjYWxlID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNocm9tYSA8PSAwKSB7XG4gICAgICAgIGh1ZSA9IDA7XG4gICAgICB9IGVsc2UgaWYgKG1heCA9PT0gcikge1xuICAgICAgICBodWUgPSAoZyAtIGIpIC8gY2hyb21hICUgNjtcbiAgICAgIH0gZWxzZSBpZiAobWF4ID09PSBnKSB7XG4gICAgICAgIGh1ZSA9IDIgKyAoYiAtIHIpIC8gY2hyb21hO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHVlID0gNCArIChyIC0gZykgLyBjaHJvbWEgKyA0O1xuICAgICAgfVxuXG4gICAgICBodWUgLz0gNjtcbiAgICAgIGh1ZSAlPSAxO1xuICAgICAgcmV0dXJuIFtodWUgKiAzNjAsIGNocm9tYSAqIDEwMCwgZ3JheXNjYWxlICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5oc2wuaGNnID0gZnVuY3Rpb24gKGhzbCkge1xuICAgICAgdmFyIHMgPSBoc2xbMV0gLyAxMDA7XG4gICAgICB2YXIgbCA9IGhzbFsyXSAvIDEwMDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciBmID0gMDtcblxuICAgICAgaWYgKGwgPCAwLjUpIHtcbiAgICAgICAgYyA9IDIuMCAqIHMgKiBsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IDIuMCAqIHMgKiAoMS4wIC0gbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjIDwgMS4wKSB7XG4gICAgICAgIGYgPSAobCAtIDAuNSAqIGMpIC8gKDEuMCAtIGMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2hzbFswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaHN2LmhjZyA9IGZ1bmN0aW9uIChoc3YpIHtcbiAgICAgIHZhciBzID0gaHN2WzFdIC8gMTAwO1xuICAgICAgdmFyIHYgPSBoc3ZbMl0gLyAxMDA7XG4gICAgICB2YXIgYyA9IHMgKiB2O1xuICAgICAgdmFyIGYgPSAwO1xuXG4gICAgICBpZiAoYyA8IDEuMCkge1xuICAgICAgICBmID0gKHYgLSBjKSAvICgxIC0gYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbaHN2WzBdLCBjICogMTAwLCBmICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5oY2cucmdiID0gZnVuY3Rpb24gKGhjZykge1xuICAgICAgdmFyIGggPSBoY2dbMF0gLyAzNjA7XG4gICAgICB2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcbiAgICAgIHZhciBnID0gaGNnWzJdIC8gMTAwO1xuXG4gICAgICBpZiAoYyA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBbZyAqIDI1NSwgZyAqIDI1NSwgZyAqIDI1NV07XG4gICAgICB9XG5cbiAgICAgIHZhciBwdXJlID0gWzAsIDAsIDBdO1xuICAgICAgdmFyIGhpID0gaCAlIDEgKiA2O1xuICAgICAgdmFyIHYgPSBoaSAlIDE7XG4gICAgICB2YXIgdyA9IDEgLSB2O1xuICAgICAgdmFyIG1nID0gMDtcblxuICAgICAgc3dpdGNoIChNYXRoLmZsb29yKGhpKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcHVyZVswXSA9IDE7XG4gICAgICAgICAgcHVyZVsxXSA9IHY7XG4gICAgICAgICAgcHVyZVsyXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHB1cmVbMF0gPSB3O1xuICAgICAgICAgIHB1cmVbMV0gPSAxO1xuICAgICAgICAgIHB1cmVbMl0gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBwdXJlWzBdID0gMDtcbiAgICAgICAgICBwdXJlWzFdID0gMTtcbiAgICAgICAgICBwdXJlWzJdID0gdjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHVyZVswXSA9IDA7XG4gICAgICAgICAgcHVyZVsxXSA9IHc7XG4gICAgICAgICAgcHVyZVsyXSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHB1cmVbMF0gPSB2O1xuICAgICAgICAgIHB1cmVbMV0gPSAwO1xuICAgICAgICAgIHB1cmVbMl0gPSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHVyZVswXSA9IDE7XG4gICAgICAgICAgcHVyZVsxXSA9IDA7XG4gICAgICAgICAgcHVyZVsyXSA9IHc7XG4gICAgICB9XG5cbiAgICAgIG1nID0gKDEuMCAtIGMpICogZztcbiAgICAgIHJldHVybiBbKGMgKiBwdXJlWzBdICsgbWcpICogMjU1LCAoYyAqIHB1cmVbMV0gKyBtZykgKiAyNTUsIChjICogcHVyZVsyXSArIG1nKSAqIDI1NV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaGNnLmhzdiA9IGZ1bmN0aW9uIChoY2cpIHtcbiAgICAgIHZhciBjID0gaGNnWzFdIC8gMTAwO1xuICAgICAgdmFyIGcgPSBoY2dbMl0gLyAxMDA7XG4gICAgICB2YXIgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuICAgICAgdmFyIGYgPSAwO1xuXG4gICAgICBpZiAodiA+IDAuMCkge1xuICAgICAgICBmID0gYyAvIHY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbaGNnWzBdLCBmICogMTAwLCB2ICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5oY2cuaHNsID0gZnVuY3Rpb24gKGhjZykge1xuICAgICAgdmFyIGMgPSBoY2dbMV0gLyAxMDA7XG4gICAgICB2YXIgZyA9IGhjZ1syXSAvIDEwMDtcbiAgICAgIHZhciBsID0gZyAqICgxLjAgLSBjKSArIDAuNSAqIGM7XG4gICAgICB2YXIgcyA9IDA7XG5cbiAgICAgIGlmIChsID4gMC4wICYmIGwgPCAwLjUpIHtcbiAgICAgICAgcyA9IGMgLyAoMiAqIGwpO1xuICAgICAgfSBlbHNlIGlmIChsID49IDAuNSAmJiBsIDwgMS4wKSB7XG4gICAgICAgIHMgPSBjIC8gKDIgKiAoMSAtIGwpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtoY2dbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmhjZy5od2IgPSBmdW5jdGlvbiAoaGNnKSB7XG4gICAgICB2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcbiAgICAgIHZhciBnID0gaGNnWzJdIC8gMTAwO1xuICAgICAgdmFyIHYgPSBjICsgZyAqICgxLjAgLSBjKTtcbiAgICAgIHJldHVybiBbaGNnWzBdLCAodiAtIGMpICogMTAwLCAoMSAtIHYpICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5od2IuaGNnID0gZnVuY3Rpb24gKGh3Yikge1xuICAgICAgdmFyIHcgPSBod2JbMV0gLyAxMDA7XG4gICAgICB2YXIgYiA9IGh3YlsyXSAvIDEwMDtcbiAgICAgIHZhciB2ID0gMSAtIGI7XG4gICAgICB2YXIgYyA9IHYgLSB3O1xuICAgICAgdmFyIGcgPSAwO1xuXG4gICAgICBpZiAoYyA8IDEpIHtcbiAgICAgICAgZyA9ICh2IC0gYykgLyAoMSAtIGMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2h3YlswXSwgYyAqIDEwMCwgZyAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuYXBwbGUucmdiID0gZnVuY3Rpb24gKGFwcGxlKSB7XG4gICAgICByZXR1cm4gW2FwcGxlWzBdIC8gNjU1MzUgKiAyNTUsIGFwcGxlWzFdIC8gNjU1MzUgKiAyNTUsIGFwcGxlWzJdIC8gNjU1MzUgKiAyNTVdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5hcHBsZSA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgIHJldHVybiBbcmdiWzBdIC8gMjU1ICogNjU1MzUsIHJnYlsxXSAvIDI1NSAqIDY1NTM1LCByZ2JbMl0gLyAyNTUgKiA2NTUzNV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuZ3JheS5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgcmV0dXJuIFthcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1XTtcbiAgICB9O1xuXG4gICAgY29udmVydC5ncmF5LmhzbCA9IGNvbnZlcnQuZ3JheS5oc3YgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgcmV0dXJuIFswLCAwLCBhcmdzWzBdXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5ncmF5Lmh3YiA9IGZ1bmN0aW9uIChncmF5KSB7XG4gICAgICByZXR1cm4gWzAsIDEwMCwgZ3JheVswXV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuZ3JheS5jbXlrID0gZnVuY3Rpb24gKGdyYXkpIHtcbiAgICAgIHJldHVybiBbMCwgMCwgMCwgZ3JheVswXV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuZ3JheS5sYWIgPSBmdW5jdGlvbiAoZ3JheSkge1xuICAgICAgcmV0dXJuIFtncmF5WzBdLCAwLCAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5ncmF5LmhleCA9IGZ1bmN0aW9uIChncmF5KSB7XG4gICAgICB2YXIgdmFsID0gTWF0aC5yb3VuZChncmF5WzBdIC8gMTAwICogMjU1KSAmIDB4RkY7XG4gICAgICB2YXIgaW50ZWdlciA9ICh2YWwgPDwgMTYpICsgKHZhbCA8PCA4KSArIHZhbDtcbiAgICAgIHZhciBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbiAgICB9O1xuXG4gICAgY29udmVydC5yZ2IuZ3JheSA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgIHZhciB2YWwgPSAocmdiWzBdICsgcmdiWzFdICsgcmdiWzJdKSAvIDM7XG4gICAgICByZXR1cm4gW3ZhbCAvIDI1NSAqIDEwMF07XG4gICAgfTtcbiAgfSk7XG4gIHZhciBjb252ZXJzaW9uc18xID0gY29udmVyc2lvbnMucmdiO1xuICB2YXIgY29udmVyc2lvbnNfMiA9IGNvbnZlcnNpb25zLmhzbDtcbiAgdmFyIGNvbnZlcnNpb25zXzMgPSBjb252ZXJzaW9ucy5oc3Y7XG4gIHZhciBjb252ZXJzaW9uc180ID0gY29udmVyc2lvbnMuaHdiO1xuICB2YXIgY29udmVyc2lvbnNfNSA9IGNvbnZlcnNpb25zLmNteWs7XG4gIHZhciBjb252ZXJzaW9uc182ID0gY29udmVyc2lvbnMueHl6O1xuICB2YXIgY29udmVyc2lvbnNfNyA9IGNvbnZlcnNpb25zLmxhYjtcbiAgdmFyIGNvbnZlcnNpb25zXzggPSBjb252ZXJzaW9ucy5sY2g7XG4gIHZhciBjb252ZXJzaW9uc185ID0gY29udmVyc2lvbnMuaGV4O1xuICB2YXIgY29udmVyc2lvbnNfMTAgPSBjb252ZXJzaW9ucy5rZXl3b3JkO1xuICB2YXIgY29udmVyc2lvbnNfMTEgPSBjb252ZXJzaW9ucy5hbnNpMTY7XG4gIHZhciBjb252ZXJzaW9uc18xMiA9IGNvbnZlcnNpb25zLmFuc2kyNTY7XG4gIHZhciBjb252ZXJzaW9uc18xMyA9IGNvbnZlcnNpb25zLmhjZztcbiAgdmFyIGNvbnZlcnNpb25zXzE0ID0gY29udmVyc2lvbnMuYXBwbGU7XG4gIHZhciBjb252ZXJzaW9uc18xNSA9IGNvbnZlcnNpb25zLmdyYXk7XG5cbiAgLypcbiAgXHR0aGlzIGZ1bmN0aW9uIHJvdXRlcyBhIG1vZGVsIHRvIGFsbCBvdGhlciBtb2RlbHMuXG5cbiAgXHRhbGwgZnVuY3Rpb25zIHRoYXQgYXJlIHJvdXRlZCBoYXZlIGEgcHJvcGVydHkgYC5jb252ZXJzaW9uYCBhdHRhY2hlZFxuICBcdHRvIHRoZSByZXR1cm5lZCBzeW50aGV0aWMgZnVuY3Rpb24uIFRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXlcbiAgXHRvZiBzdHJpbmdzLCBlYWNoIHdpdGggdGhlIHN0ZXBzIGluIGJldHdlZW4gdGhlICdmcm9tJyBhbmQgJ3RvJ1xuICBcdGNvbG9yIG1vZGVscyAoaW5jbHVzaXZlKS5cblxuICBcdGNvbnZlcnNpb25zIHRoYXQgYXJlIG5vdCBwb3NzaWJsZSBzaW1wbHkgYXJlIG5vdCBpbmNsdWRlZC5cbiAgKi9cblxuICBmdW5jdGlvbiBidWlsZEdyYXBoKCkge1xuICAgIHZhciBncmFwaCA9IHt9OyAvLyBodHRwczovL2pzcGVyZi5jb20vb2JqZWN0LWtleXMtdnMtZm9yLWluLXdpdGgtY2xvc3VyZS8zXG5cbiAgICB2YXIgbW9kZWxzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMpO1xuXG4gICAgZm9yICh2YXIgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZ3JhcGhbbW9kZWxzW2ldXSA9IHtcbiAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vMS12cy1pbmZpbml0eVxuICAgICAgICAvLyBtaWNyby1vcHQsIGJ1dCB0aGlzIGlzIHNpbXBsZS5cbiAgICAgICAgZGlzdGFuY2U6IC0xLFxuICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZWFkdGgtZmlyc3Rfc2VhcmNoXG5cblxuICBmdW5jdGlvbiBkZXJpdmVCRlMoZnJvbU1vZGVsKSB7XG4gICAgdmFyIGdyYXBoID0gYnVpbGRHcmFwaCgpO1xuICAgIHZhciBxdWV1ZSA9IFtmcm9tTW9kZWxdOyAvLyB1bnNoaWZ0IC0+IHF1ZXVlIC0+IHBvcFxuXG4gICAgZ3JhcGhbZnJvbU1vZGVsXS5kaXN0YW5jZSA9IDA7XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgdmFyIGFkamFjZW50cyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zW2N1cnJlbnRdKTtcblxuICAgICAgZm9yICh2YXIgbGVuID0gYWRqYWNlbnRzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYWRqYWNlbnQgPSBhZGphY2VudHNbaV07XG4gICAgICAgIHZhciBub2RlID0gZ3JhcGhbYWRqYWNlbnRdO1xuXG4gICAgICAgIGlmIChub2RlLmRpc3RhbmNlID09PSAtMSkge1xuICAgICAgICAgIG5vZGUuZGlzdGFuY2UgPSBncmFwaFtjdXJyZW50XS5kaXN0YW5jZSArIDE7XG4gICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoYWRqYWNlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluayhmcm9tLCB0bykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgcmV0dXJuIHRvKGZyb20oYXJncykpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCkge1xuICAgIHZhciBwYXRoID0gW2dyYXBoW3RvTW9kZWxdLnBhcmVudCwgdG9Nb2RlbF07XG4gICAgdmFyIGZuID0gY29udmVyc2lvbnNbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcbiAgICB2YXIgY3VyID0gZ3JhcGhbdG9Nb2RlbF0ucGFyZW50O1xuXG4gICAgd2hpbGUgKGdyYXBoW2N1cl0ucGFyZW50KSB7XG4gICAgICBwYXRoLnVuc2hpZnQoZ3JhcGhbY3VyXS5wYXJlbnQpO1xuICAgICAgZm4gPSBsaW5rKGNvbnZlcnNpb25zW2dyYXBoW2N1cl0ucGFyZW50XVtjdXJdLCBmbik7XG4gICAgICBjdXIgPSBncmFwaFtjdXJdLnBhcmVudDtcbiAgICB9XG5cbiAgICBmbi5jb252ZXJzaW9uID0gcGF0aDtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgcm91dGUgPSBmdW5jdGlvbiByb3V0ZShmcm9tTW9kZWwpIHtcbiAgICB2YXIgZ3JhcGggPSBkZXJpdmVCRlMoZnJvbU1vZGVsKTtcbiAgICB2YXIgY29udmVyc2lvbiA9IHt9O1xuICAgIHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhncmFwaCk7XG5cbiAgICBmb3IgKHZhciBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgdG9Nb2RlbCA9IG1vZGVsc1tpXTtcbiAgICAgIHZhciBub2RlID0gZ3JhcGhbdG9Nb2RlbF07XG5cbiAgICAgIGlmIChub2RlLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBubyBwb3NzaWJsZSBjb252ZXJzaW9uLCBvciB0aGlzIG5vZGUgaXMgdGhlIHNvdXJjZSBtb2RlbC5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnZlcnNpb25bdG9Nb2RlbF0gPSB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnNpb247XG4gIH07XG5cbiAgdmFyIGNvbnZlcnQgPSB7fTtcbiAgdmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuICBmdW5jdGlvbiB3cmFwUmF3KGZuKSB7XG4gICAgdmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIHdyYXBwZWRGbihhcmdzKSB7XG4gICAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuKGFyZ3MpO1xuICAgIH07IC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXG5cbiAgICBpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG4gICAgICB3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBwZWRGbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBSb3VuZGVkKGZuKSB7XG4gICAgdmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIHdyYXBwZWRGbihhcmdzKSB7XG4gICAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGZuKGFyZ3MpOyAvLyB3ZSdyZSBhc3N1bWluZyB0aGUgcmVzdWx0IGlzIGFuIGFycmF5IGhlcmUuXG4gICAgICAvLyBzZWUgbm90aWNlIGluIGNvbnZlcnNpb25zLmpzOyBkb24ndCB1c2UgYm94IHR5cGVzXG4gICAgICAvLyBpbiBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGxlbiA9IHJlc3VsdC5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9OyAvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblxuXG4gICAgaWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuICAgICAgd3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVkRm47XG4gIH1cblxuICBtb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG4gICAgY29udmVydFtmcm9tTW9kZWxdID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2NoYW5uZWxzJywge1xuICAgICAgdmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0uY2hhbm5lbHNcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnbGFiZWxzJywge1xuICAgICAgdmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0ubGFiZWxzXG4gICAgfSk7XG4gICAgdmFyIHJvdXRlcyA9IHJvdXRlKGZyb21Nb2RlbCk7XG4gICAgdmFyIHJvdXRlTW9kZWxzID0gT2JqZWN0LmtleXMocm91dGVzKTtcbiAgICByb3V0ZU1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uICh0b01vZGVsKSB7XG4gICAgICB2YXIgZm4gPSByb3V0ZXNbdG9Nb2RlbF07XG4gICAgICBjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0gPSB3cmFwUm91bmRlZChmbik7XG4gICAgICBjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0ucmF3ID0gd3JhcFJhdyhmbik7XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgY29sb3JDb252ZXJ0ID0gY29udmVydDtcblxuICB2YXIgYW5zaVN0eWxlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICAgIGNvbnN0IHdyYXBBbnNpMTYgPSAoZm4sIG9mZnNldCkgPT4gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgY29kZSA9IGZuLmFwcGx5KGNvbG9yQ29udmVydCwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBcIlxceDFCW1wiLmNvbmNhdChjb2RlICsgb2Zmc2V0LCBcIm1cIik7XG4gICAgfTtcblxuICAgIGNvbnN0IHdyYXBBbnNpMjU2ID0gKGZuLCBvZmZzZXQpID0+IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBmbi5hcHBseShjb2xvckNvbnZlcnQsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gXCJcXHgxQltcIi5jb25jYXQoMzggKyBvZmZzZXQsIFwiOzU7XCIpLmNvbmNhdChjb2RlLCBcIm1cIik7XG4gICAgfTtcblxuICAgIGNvbnN0IHdyYXBBbnNpMTZtID0gKGZuLCBvZmZzZXQpID0+IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IHJnYiA9IGZuLmFwcGx5KGNvbG9yQ29udmVydCwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBcIlxceDFCW1wiLmNvbmNhdCgzOCArIG9mZnNldCwgXCI7MjtcIikuY29uY2F0KHJnYlswXSwgXCI7XCIpLmNvbmNhdChyZ2JbMV0sIFwiO1wiKS5jb25jYXQocmdiWzJdLCBcIm1cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzc2VtYmxlU3R5bGVzKCkge1xuICAgICAgY29uc3QgY29kZXMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICAgIG1vZGlmaWVyOiB7XG4gICAgICAgICAgcmVzZXQ6IFswLCAwXSxcbiAgICAgICAgICAvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG4gICAgICAgICAgYm9sZDogWzEsIDIyXSxcbiAgICAgICAgICBkaW06IFsyLCAyMl0sXG4gICAgICAgICAgaXRhbGljOiBbMywgMjNdLFxuICAgICAgICAgIHVuZGVybGluZTogWzQsIDI0XSxcbiAgICAgICAgICBpbnZlcnNlOiBbNywgMjddLFxuICAgICAgICAgIGhpZGRlbjogWzgsIDI4XSxcbiAgICAgICAgICBzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgYmxhY2s6IFszMCwgMzldLFxuICAgICAgICAgIHJlZDogWzMxLCAzOV0sXG4gICAgICAgICAgZ3JlZW46IFszMiwgMzldLFxuICAgICAgICAgIHllbGxvdzogWzMzLCAzOV0sXG4gICAgICAgICAgYmx1ZTogWzM0LCAzOV0sXG4gICAgICAgICAgbWFnZW50YTogWzM1LCAzOV0sXG4gICAgICAgICAgY3lhbjogWzM2LCAzOV0sXG4gICAgICAgICAgd2hpdGU6IFszNywgMzldLFxuICAgICAgICAgIGdyYXk6IFs5MCwgMzldLFxuICAgICAgICAgIC8vIEJyaWdodCBjb2xvclxuICAgICAgICAgIHJlZEJyaWdodDogWzkxLCAzOV0sXG4gICAgICAgICAgZ3JlZW5CcmlnaHQ6IFs5MiwgMzldLFxuICAgICAgICAgIHllbGxvd0JyaWdodDogWzkzLCAzOV0sXG4gICAgICAgICAgYmx1ZUJyaWdodDogWzk0LCAzOV0sXG4gICAgICAgICAgbWFnZW50YUJyaWdodDogWzk1LCAzOV0sXG4gICAgICAgICAgY3lhbkJyaWdodDogWzk2LCAzOV0sXG4gICAgICAgICAgd2hpdGVCcmlnaHQ6IFs5NywgMzldXG4gICAgICAgIH0sXG4gICAgICAgIGJnQ29sb3I6IHtcbiAgICAgICAgICBiZ0JsYWNrOiBbNDAsIDQ5XSxcbiAgICAgICAgICBiZ1JlZDogWzQxLCA0OV0sXG4gICAgICAgICAgYmdHcmVlbjogWzQyLCA0OV0sXG4gICAgICAgICAgYmdZZWxsb3c6IFs0MywgNDldLFxuICAgICAgICAgIGJnQmx1ZTogWzQ0LCA0OV0sXG4gICAgICAgICAgYmdNYWdlbnRhOiBbNDUsIDQ5XSxcbiAgICAgICAgICBiZ0N5YW46IFs0NiwgNDldLFxuICAgICAgICAgIGJnV2hpdGU6IFs0NywgNDldLFxuICAgICAgICAgIC8vIEJyaWdodCBjb2xvclxuICAgICAgICAgIGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSxcbiAgICAgICAgICBiZ1JlZEJyaWdodDogWzEwMSwgNDldLFxuICAgICAgICAgIGJnR3JlZW5CcmlnaHQ6IFsxMDIsIDQ5XSxcbiAgICAgICAgICBiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLFxuICAgICAgICAgIGJnQmx1ZUJyaWdodDogWzEwNCwgNDldLFxuICAgICAgICAgIGJnTWFnZW50YUJyaWdodDogWzEwNSwgNDldLFxuICAgICAgICAgIGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLFxuICAgICAgICAgIGJnV2hpdGVCcmlnaHQ6IFsxMDcsIDQ5XVxuICAgICAgICB9XG4gICAgICB9OyAvLyBGaXggaHVtYW5zXG5cbiAgICAgIHN0eWxlcy5jb2xvci5ncmV5ID0gc3R5bGVzLmNvbG9yLmdyYXk7XG5cbiAgICAgIGZvciAoY29uc3QgZ3JvdXBOYW1lIG9mIE9iamVjdC5rZXlzKHN0eWxlcykpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBzdHlsZXNbZ3JvdXBOYW1lXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBvZiBPYmplY3Qua2V5cyhncm91cCkpIHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IGdyb3VwW3N0eWxlTmFtZV07XG4gICAgICAgICAgc3R5bGVzW3N0eWxlTmFtZV0gPSB7XG4gICAgICAgICAgICBvcGVuOiBcIlxceDFCW1wiLmNvbmNhdChzdHlsZVswXSwgXCJtXCIpLFxuICAgICAgICAgICAgY2xvc2U6IFwiXFx4MUJbXCIuY29uY2F0KHN0eWxlWzFdLCBcIm1cIilcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdyb3VwW3N0eWxlTmFtZV0gPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgICAgICBjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsIGdyb3VwTmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBncm91cCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgJ2NvZGVzJywge1xuICAgICAgICAgIHZhbHVlOiBjb2RlcyxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYW5zaTJhbnNpID0gbiA9PiBuO1xuXG4gICAgICBjb25zdCByZ2IycmdiID0gKHIsIGcsIGIpID0+IFtyLCBnLCBiXTtcblxuICAgICAgc3R5bGVzLmNvbG9yLmNsb3NlID0gJ1xcdTAwMUJbMzltJztcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmNsb3NlID0gJ1xcdTAwMUJbNDltJztcbiAgICAgIHN0eWxlcy5jb2xvci5hbnNpID0ge1xuICAgICAgICBhbnNpOiB3cmFwQW5zaTE2KGFuc2kyYW5zaSwgMClcbiAgICAgIH07XG4gICAgICBzdHlsZXMuY29sb3IuYW5zaTI1NiA9IHtcbiAgICAgICAgYW5zaTI1Njogd3JhcEFuc2kyNTYoYW5zaTJhbnNpLCAwKVxuICAgICAgfTtcbiAgICAgIHN0eWxlcy5jb2xvci5hbnNpMTZtID0ge1xuICAgICAgICByZ2I6IHdyYXBBbnNpMTZtKHJnYjJyZ2IsIDApXG4gICAgICB9O1xuICAgICAgc3R5bGVzLmJnQ29sb3IuYW5zaSA9IHtcbiAgICAgICAgYW5zaTogd3JhcEFuc2kxNihhbnNpMmFuc2ksIDEwKVxuICAgICAgfTtcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmFuc2kyNTYgPSB7XG4gICAgICAgIGFuc2kyNTY6IHdyYXBBbnNpMjU2KGFuc2kyYW5zaSwgMTApXG4gICAgICB9O1xuICAgICAgc3R5bGVzLmJnQ29sb3IuYW5zaTE2bSA9IHtcbiAgICAgICAgcmdiOiB3cmFwQW5zaTE2bShyZ2IycmdiLCAxMClcbiAgICAgIH07XG5cbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb2xvckNvbnZlcnQpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29sb3JDb252ZXJ0W2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdWl0ZSA9IGNvbG9yQ29udmVydFtrZXldO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdhbnNpMTYnKSB7XG4gICAgICAgICAga2V5ID0gJ2Fuc2knO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdhbnNpMTYnIGluIHN1aXRlKSB7XG4gICAgICAgICAgc3R5bGVzLmNvbG9yLmFuc2lba2V5XSA9IHdyYXBBbnNpMTYoc3VpdGUuYW5zaTE2LCAwKTtcbiAgICAgICAgICBzdHlsZXMuYmdDb2xvci5hbnNpW2tleV0gPSB3cmFwQW5zaTE2KHN1aXRlLmFuc2kxNiwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdhbnNpMjU2JyBpbiBzdWl0ZSkge1xuICAgICAgICAgIHN0eWxlcy5jb2xvci5hbnNpMjU2W2tleV0gPSB3cmFwQW5zaTI1NihzdWl0ZS5hbnNpMjU2LCAwKTtcbiAgICAgICAgICBzdHlsZXMuYmdDb2xvci5hbnNpMjU2W2tleV0gPSB3cmFwQW5zaTI1NihzdWl0ZS5hbnNpMjU2LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3JnYicgaW4gc3VpdGUpIHtcbiAgICAgICAgICBzdHlsZXMuY29sb3IuYW5zaTE2bVtrZXldID0gd3JhcEFuc2kxNm0oc3VpdGUucmdiLCAwKTtcbiAgICAgICAgICBzdHlsZXMuYmdDb2xvci5hbnNpMTZtW2tleV0gPSB3cmFwQW5zaTE2bShzdWl0ZS5yZ2IsIDEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0gLy8gTWFrZSB0aGUgZXhwb3J0IGltbXV0YWJsZVxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGFzc2VtYmxlU3R5bGVzXG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciByZXF1aXJlJCQwJDEgPSB7XG4gICAgRU9MOiBcIlxcblwiXG4gIH07XG5cbiAgdmFyIGhhc0ZsYWcgPSAoZmxhZywgYXJndikgPT4ge1xuICAgIGFyZ3YgPSBhcmd2IHx8IHByb2Nlc3MuYXJndjtcbiAgICBjb25zdCBwcmVmaXggPSBmbGFnLnN0YXJ0c1dpdGgoJy0nKSA/ICcnIDogZmxhZy5sZW5ndGggPT09IDEgPyAnLScgOiAnLS0nO1xuICAgIGNvbnN0IHBvcyA9IGFyZ3YuaW5kZXhPZihwcmVmaXggKyBmbGFnKTtcbiAgICBjb25zdCB0ZXJtaW5hdG9yUG9zID0gYXJndi5pbmRleE9mKCctLScpO1xuICAgIHJldHVybiBwb3MgIT09IC0xICYmICh0ZXJtaW5hdG9yUG9zID09PSAtMSA/IHRydWUgOiBwb3MgPCB0ZXJtaW5hdG9yUG9zKTtcbiAgfTtcblxuICBjb25zdCBlbnYkMSA9IHByb2Nlc3MuZW52O1xuICBsZXQgZm9yY2VDb2xvcjtcblxuICBpZiAoaGFzRmxhZygnbm8tY29sb3InKSB8fCBoYXNGbGFnKCduby1jb2xvcnMnKSB8fCBoYXNGbGFnKCdjb2xvcj1mYWxzZScpKSB7XG4gICAgZm9yY2VDb2xvciA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGhhc0ZsYWcoJ2NvbG9yJykgfHwgaGFzRmxhZygnY29sb3JzJykgfHwgaGFzRmxhZygnY29sb3I9dHJ1ZScpIHx8IGhhc0ZsYWcoJ2NvbG9yPWFsd2F5cycpKSB7XG4gICAgZm9yY2VDb2xvciA9IHRydWU7XG4gIH1cblxuICBpZiAoJ0ZPUkNFX0NPTE9SJyBpbiBlbnYkMSkge1xuICAgIGZvcmNlQ29sb3IgPSBlbnYkMS5GT1JDRV9DT0xPUi5sZW5ndGggPT09IDAgfHwgcGFyc2VJbnQoZW52JDEuRk9SQ0VfQ09MT1IsIDEwKSAhPT0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUxldmVsKGxldmVsKSB7XG4gICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsLFxuICAgICAgaGFzQmFzaWM6IHRydWUsXG4gICAgICBoYXMyNTY6IGxldmVsID49IDIsXG4gICAgICBoYXMxNm06IGxldmVsID49IDNcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3VwcG9ydHNDb2xvcihzdHJlYW0pIHtcbiAgICBpZiAoZm9yY2VDb2xvciA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChoYXNGbGFnKCdjb2xvcj0xNm0nKSB8fCBoYXNGbGFnKCdjb2xvcj1mdWxsJykgfHwgaGFzRmxhZygnY29sb3I9dHJ1ZWNvbG9yJykpIHtcbiAgICAgIHJldHVybiAzO1xuICAgIH1cblxuICAgIGlmIChoYXNGbGFnKCdjb2xvcj0yNTYnKSkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbSAmJiAhc3RyZWFtLmlzVFRZICYmIGZvcmNlQ29sb3IgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IGZvcmNlQ29sb3IgPyAxIDogMDtcblxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAvLyBOb2RlLmpzIDcuNS4wIGlzIHRoZSBmaXJzdCB2ZXJzaW9uIG9mIE5vZGUuanMgdG8gaW5jbHVkZSBhIHBhdGNoIHRvXG4gICAgICAvLyBsaWJ1diB0aGF0IGVuYWJsZXMgMjU2IGNvbG9yIG91dHB1dCBvbiBXaW5kb3dzLiBBbnl0aGluZyBlYXJsaWVyIGFuZCBpdFxuICAgICAgLy8gd29uJ3Qgd29yay4gSG93ZXZlciwgaGVyZSB3ZSB0YXJnZXQgTm9kZS5qcyA4IGF0IG1pbmltdW0gYXMgaXQgaXMgYW4gTFRTXG4gICAgICAvLyByZWxlYXNlLCBhbmQgTm9kZS5qcyA3IGlzIG5vdC4gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3QgV2luZG93c1xuICAgICAgLy8gcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDI1NiBjb2xvcnMuIFdpbmRvd3MgMTAgYnVpbGQgMTQ5MzEgaXMgdGhlIGZpcnN0IHJlbGVhc2VcbiAgICAgIC8vIHRoYXQgc3VwcG9ydHMgMTZtL1RydWVDb2xvci5cbiAgICAgIGNvbnN0IG9zUmVsZWFzZSA9IHJlcXVpcmUkJDAkMS5yZWxlYXNlKCkuc3BsaXQoJy4nKTtcblxuICAgICAgaWYgKE51bWJlcihwcm9jZXNzLnZlcnNpb25zLm5vZGUuc3BsaXQoJy4nKVswXSkgPj0gOCAmJiBOdW1iZXIob3NSZWxlYXNlWzBdKSA+PSAxMCAmJiBOdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxMDU4Nikge1xuICAgICAgICByZXR1cm4gTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTQ5MzEgPyAzIDogMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCdDSScgaW4gZW52JDEpIHtcbiAgICAgIGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knXS5zb21lKHNpZ24gPT4gc2lnbiBpbiBlbnYkMSkgfHwgZW52JDEuQ0lfTkFNRSA9PT0gJ2NvZGVzaGlwJykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG5cbiAgICBpZiAoJ1RFQU1DSVRZX1ZFUlNJT04nIGluIGVudiQxKSB7XG4gICAgICByZXR1cm4gL14oOVxcLigwKlsxLTldXFxkKilcXC58XFxkezIsfVxcLikvLnRlc3QoZW52JDEuVEVBTUNJVFlfVkVSU0lPTikgPyAxIDogMDtcbiAgICB9XG5cbiAgICBpZiAoZW52JDEuQ09MT1JURVJNID09PSAndHJ1ZWNvbG9yJykge1xuICAgICAgcmV0dXJuIDM7XG4gICAgfVxuXG4gICAgaWYgKCdURVJNX1BST0dSQU0nIGluIGVudiQxKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoKGVudiQxLlRFUk1fUFJPR1JBTV9WRVJTSU9OIHx8ICcnKS5zcGxpdCgnLicpWzBdLCAxMCk7XG5cbiAgICAgIHN3aXRjaCAoZW52JDEuVEVSTV9QUk9HUkFNKSB7XG4gICAgICAgIGNhc2UgJ2lUZXJtLmFwcCc6XG4gICAgICAgICAgcmV0dXJuIHZlcnNpb24gPj0gMyA/IDMgOiAyO1xuXG4gICAgICAgIGNhc2UgJ0FwcGxlX1Rlcm1pbmFsJzpcbiAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgLy8gTm8gZGVmYXVsdFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgvLTI1Nihjb2xvcik/JC9pLnRlc3QoZW52JDEuVEVSTSkpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cblxuICAgIGlmICgvXnNjcmVlbnxeeHRlcm18XnZ0MTAwfF52dDIyMHxecnh2dHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QoZW52JDEuVEVSTSkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICgnQ09MT1JURVJNJyBpbiBlbnYkMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKGVudiQxLlRFUk0gPT09ICdkdW1iJykge1xuICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3VwcG9ydExldmVsKHN0cmVhbSkge1xuICAgIGNvbnN0IGxldmVsID0gc3VwcG9ydHNDb2xvcihzdHJlYW0pO1xuICAgIHJldHVybiB0cmFuc2xhdGVMZXZlbChsZXZlbCk7XG4gIH1cblxuICB2YXIgc3VwcG9ydHNDb2xvcl8xID0ge1xuICAgIHN1cHBvcnRzQ29sb3I6IGdldFN1cHBvcnRMZXZlbCxcbiAgICBzdGRvdXQ6IGdldFN1cHBvcnRMZXZlbChwcm9jZXNzLnN0ZG91dCksXG4gICAgc3RkZXJyOiBnZXRTdXBwb3J0TGV2ZWwocHJvY2Vzcy5zdGRlcnIpXG4gIH07XG5cbiAgY29uc3QgVEVNUExBVEVfUkVHRVggPSAvKD86XFxcXCh1W2EtZlxcZF17NH18eFthLWZcXGRdezJ9fC4pKXwoPzpcXHsofik/KFxcdysoPzpcXChbXildKlxcKSk/KD86XFwuXFx3Kyg/OlxcKFteKV0qXFwpKT8pKikoPzpbIFxcdF18KD89XFxyP1xcbikpKXwoXFx9KXwoKD86LnxbXFxyXFxuXFxmXSkrPykvZ2k7XG4gIGNvbnN0IFNUWUxFX1JFR0VYID0gLyg/Ol58XFwuKShcXHcrKSg/OlxcKChbXildKilcXCkpPy9nO1xuICBjb25zdCBTVFJJTkdfUkVHRVggPSAvXihbJ1wiXSkoKD86XFxcXC58KD8hXFwxKVteXFxcXF0pKilcXDEkLztcbiAgY29uc3QgRVNDQVBFX1JFR0VYID0gL1xcXFwodVthLWZcXGRdezR9fHhbYS1mXFxkXXsyfXwuKXwoW15cXFxcXSkvZ2k7XG4gIGNvbnN0IEVTQ0FQRVMgPSBuZXcgTWFwKFtbJ24nLCAnXFxuJ10sIFsncicsICdcXHInXSwgWyd0JywgJ1xcdCddLCBbJ2InLCAnXFxiJ10sIFsnZicsICdcXGYnXSwgWyd2JywgJ1xcdiddLCBbJzAnLCAnXFwwJ10sIFsnXFxcXCcsICdcXFxcJ10sIFsnZScsICdcXHUwMDFCJ10sIFsnYScsICdcXHUwMDA3J11dKTtcblxuICBmdW5jdGlvbiB1bmVzY2FwZShjKSB7XG4gICAgaWYgKGNbMF0gPT09ICd1JyAmJiBjLmxlbmd0aCA9PT0gNSB8fCBjWzBdID09PSAneCcgJiYgYy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGMuc2xpY2UoMSksIDE2KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEVTQ0FQRVMuZ2V0KGMpIHx8IGM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyhuYW1lLCBhcmdzKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IGNodW5rcyA9IGFyZ3MudHJpbSgpLnNwbGl0KC9cXHMqLFxccyovZyk7XG4gICAgbGV0IG1hdGNoZXM7XG5cbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgaWYgKCFpc05hTihjaHVuaykpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKE51bWJlcihjaHVuaykpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaGVzID0gY2h1bmsubWF0Y2goU1RSSU5HX1JFR0VYKSkge1xuICAgICAgICByZXN1bHRzLnB1c2gobWF0Y2hlc1syXS5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgKG0sIGVzY2FwZSwgY2hyKSA9PiBlc2NhcGUgPyB1bmVzY2FwZShlc2NhcGUpIDogY2hyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIENoYWxrIHRlbXBsYXRlIHN0eWxlIGFyZ3VtZW50OiBcIi5jb25jYXQoY2h1bmssIFwiIChpbiBzdHlsZSAnXCIpLmNvbmNhdChuYW1lLCBcIicpXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGUoc3R5bGUpIHtcbiAgICBTVFlMRV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgbWF0Y2hlcztcblxuICAgIHdoaWxlICgobWF0Y2hlcyA9IFNUWUxFX1JFR0VYLmV4ZWMoc3R5bGUpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoZXNbMV07XG5cbiAgICAgIGlmIChtYXRjaGVzWzJdKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3VtZW50cyhuYW1lLCBtYXRjaGVzWzJdKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKFtuYW1lXS5jb25jYXQoYXJncykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKFtuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZFN0eWxlKGNoYWxrLCBzdHlsZXMpIHtcbiAgICBjb25zdCBlbmFibGVkID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHN0eWxlcykge1xuICAgICAgZm9yIChjb25zdCBzdHlsZSBvZiBsYXllci5zdHlsZXMpIHtcbiAgICAgICAgZW5hYmxlZFtzdHlsZVswXV0gPSBsYXllci5pbnZlcnNlID8gbnVsbCA6IHN0eWxlLnNsaWNlKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjdXJyZW50ID0gY2hhbGs7XG5cbiAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBvZiBPYmplY3Qua2V5cyhlbmFibGVkKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZFtzdHlsZU5hbWVdKSkge1xuICAgICAgICBpZiAoIShzdHlsZU5hbWUgaW4gY3VycmVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIENoYWxrIHN0eWxlOiBcIi5jb25jYXQoc3R5bGVOYW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5hYmxlZFtzdHlsZU5hbWVdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtzdHlsZU5hbWVdLmFwcGx5KGN1cnJlbnQsIGVuYWJsZWRbc3R5bGVOYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbc3R5bGVOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgdmFyIHRlbXBsYXRlcyA9IChjaGFsaywgdG1wKSA9PiB7XG4gICAgY29uc3Qgc3R5bGVzID0gW107XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgbGV0IGNodW5rID0gW107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5cbiAgICB0bXAucmVwbGFjZShURU1QTEFURV9SRUdFWCwgKG0sIGVzY2FwZUNoYXIsIGludmVyc2UsIHN0eWxlLCBjbG9zZSwgY2hyKSA9PiB7XG4gICAgICBpZiAoZXNjYXBlQ2hhcikge1xuICAgICAgICBjaHVuay5wdXNoKHVuZXNjYXBlKGVzY2FwZUNoYXIpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gY2h1bmsuam9pbignJyk7XG4gICAgICAgIGNodW5rID0gW107XG4gICAgICAgIGNodW5rcy5wdXNoKHN0eWxlcy5sZW5ndGggPT09IDAgPyBzdHIgOiBidWlsZFN0eWxlKGNoYWxrLCBzdHlsZXMpKHN0cikpO1xuICAgICAgICBzdHlsZXMucHVzaCh7XG4gICAgICAgICAgaW52ZXJzZSxcbiAgICAgICAgICBzdHlsZXM6IHBhcnNlU3R5bGUoc3R5bGUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChjbG9zZSkge1xuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgZXh0cmFuZW91cyB9IGluIENoYWxrIHRlbXBsYXRlIGxpdGVyYWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rcy5wdXNoKGJ1aWxkU3R5bGUoY2hhbGssIHN0eWxlcykoY2h1bmsuam9pbignJykpKTtcbiAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgc3R5bGVzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmsucHVzaChjaHIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNodW5rcy5wdXNoKGNodW5rLmpvaW4oJycpKTtcblxuICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZXJyTXNnID0gXCJDaGFsayB0ZW1wbGF0ZSBsaXRlcmFsIGlzIG1pc3NpbmcgXCIuY29uY2F0KHN0eWxlcy5sZW5ndGgsIFwiIGNsb3NpbmcgYnJhY2tldFwiKS5jb25jYXQoc3R5bGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnLCBcIiAoYH1gKVwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgIH1cblxuICAgIHJldHVybiBjaHVua3Muam9pbignJyk7XG4gIH07XG5cbiAgdmFyIGNoYWxrID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXG4gICAgY29uc3Qgc3Rkb3V0Q29sb3IgPSBzdXBwb3J0c0NvbG9yXzEuc3Rkb3V0O1xuICAgIGNvbnN0IGlzU2ltcGxlV2luZG93c1Rlcm0gPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInICYmICEocHJvY2Vzcy5lbnYuVEVSTSB8fCAnJykudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCd4dGVybScpOyAvLyBgc3VwcG9ydHNDb2xvci5sZXZlbGAg4oaSIGBhbnNpU3R5bGVzLmNvbG9yW25hbWVdYCBtYXBwaW5nXG5cbiAgICBjb25zdCBsZXZlbE1hcHBpbmcgPSBbJ2Fuc2knLCAnYW5zaScsICdhbnNpMjU2JywgJ2Fuc2kxNm0nXTsgLy8gYGNvbG9yLWNvbnZlcnRgIG1vZGVscyB0byBleGNsdWRlIGZyb20gdGhlIENoYWxrIEFQSSBkdWUgdG8gY29uZmxpY3RzIGFuZCBzdWNoXG5cbiAgICBjb25zdCBza2lwTW9kZWxzID0gbmV3IFNldChbJ2dyYXknXSk7XG4gICAgY29uc3Qgc3R5bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5T3B0aW9ucyhvYmosIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEZXRlY3QgbGV2ZWwgaWYgbm90IHNldCBtYW51YWxseVxuXG4gICAgICBjb25zdCBzY0xldmVsID0gc3Rkb3V0Q29sb3IgPyBzdGRvdXRDb2xvci5sZXZlbCA6IDA7XG4gICAgICBvYmoubGV2ZWwgPSBvcHRpb25zLmxldmVsID09PSB1bmRlZmluZWQgPyBzY0xldmVsIDogb3B0aW9ucy5sZXZlbDtcbiAgICAgIG9iai5lbmFibGVkID0gJ2VuYWJsZWQnIGluIG9wdGlvbnMgPyBvcHRpb25zLmVuYWJsZWQgOiBvYmoubGV2ZWwgPiAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENoYWxrKG9wdGlvbnMpIHtcbiAgICAgIC8vIFdlIGNoZWNrIGZvciB0aGlzLnRlbXBsYXRlIGhlcmUgc2luY2UgY2FsbGluZyBgY2hhbGsuY29uc3RydWN0b3IoKWBcbiAgICAgIC8vIGJ5IGl0c2VsZiB3aWxsIGhhdmUgYSBgdGhpc2Agb2YgYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGNoYWxrIG9iamVjdFxuICAgICAgaWYgKCF0aGlzIHx8ICEodGhpcyBpbnN0YW5jZW9mIENoYWxrKSB8fCB0aGlzLnRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IGNoYWxrID0ge307XG4gICAgICAgIGFwcGx5T3B0aW9ucyhjaGFsaywgb3B0aW9ucyk7XG5cbiAgICAgICAgY2hhbGsudGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gY2hhbGtUYWcuYXBwbHkobnVsbCwgW2NoYWxrLnRlbXBsYXRlXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFsaywgQ2hhbGsucHJvdG90eXBlKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWxrLnRlbXBsYXRlLCBjaGFsayk7XG4gICAgICAgIGNoYWxrLnRlbXBsYXRlLmNvbnN0cnVjdG9yID0gQ2hhbGs7XG4gICAgICAgIHJldHVybiBjaGFsay50ZW1wbGF0ZTtcbiAgICAgIH1cblxuICAgICAgYXBwbHlPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0gLy8gVXNlIGJyaWdodCBibHVlIG9uIFdpbmRvd3MgYXMgdGhlIG5vcm1hbCBibHVlIGNvbG9yIGlzIGlsbGVnaWJsZVxuXG5cbiAgICBpZiAoaXNTaW1wbGVXaW5kb3dzVGVybSkge1xuICAgICAgYW5zaVN0eWxlcy5ibHVlLm9wZW4gPSAnXFx1MDAxQls5NG0nO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFuc2lTdHlsZXMpKSB7XG4gICAgICBhbnNpU3R5bGVzW2tleV0uY2xvc2VSZSA9IG5ldyBSZWdFeHAoZXNjYXBlU3RyaW5nUmVnZXhwKGFuc2lTdHlsZXNba2V5XS5jbG9zZSksICdnJyk7XG4gICAgICBzdHlsZXNba2V5XSA9IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGNvZGVzID0gYW5zaVN0eWxlc1trZXldO1xuICAgICAgICAgIHJldHVybiBidWlsZC5jYWxsKHRoaXMsIHRoaXMuX3N0eWxlcyA/IHRoaXMuX3N0eWxlcy5jb25jYXQoY29kZXMpIDogW2NvZGVzXSwgdGhpcy5fZW1wdHksIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzdHlsZXMudmlzaWJsZSA9IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzIHx8IFtdLCB0cnVlLCAndmlzaWJsZScpO1xuICAgICAgfVxuXG4gICAgfTtcbiAgICBhbnNpU3R5bGVzLmNvbG9yLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzLmNvbG9yLmNsb3NlKSwgJ2cnKTtcblxuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LmtleXMoYW5zaVN0eWxlcy5jb2xvci5hbnNpKSkge1xuICAgICAgaWYgKHNraXBNb2RlbHMuaGFzKG1vZGVsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVzW21vZGVsXSA9IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5sZXZlbDtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3Qgb3BlbiA9IGFuc2lTdHlsZXMuY29sb3JbbGV2ZWxNYXBwaW5nW2xldmVsXV1bbW9kZWxdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjb25zdCBjb2RlcyA9IHtcbiAgICAgICAgICAgICAgb3BlbixcbiAgICAgICAgICAgICAgY2xvc2U6IGFuc2lTdHlsZXMuY29sb3IuY2xvc2UsXG4gICAgICAgICAgICAgIGNsb3NlUmU6IGFuc2lTdHlsZXMuY29sb3IuY2xvc2VSZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZC5jYWxsKHRoaXMsIHRoaXMuX3N0eWxlcyA/IHRoaXMuX3N0eWxlcy5jb25jYXQoY29kZXMpIDogW2NvZGVzXSwgdGhpcy5fZW1wdHksIG1vZGVsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgYW5zaVN0eWxlcy5iZ0NvbG9yLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cChhbnNpU3R5bGVzLmJnQ29sb3IuY2xvc2UpLCAnZycpO1xuXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3Qua2V5cyhhbnNpU3R5bGVzLmJnQ29sb3IuYW5zaSkpIHtcbiAgICAgIGlmIChza2lwTW9kZWxzLmhhcyhtb2RlbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJnTW9kZWwgPSAnYmcnICsgbW9kZWxbMF0udG9VcHBlckNhc2UoKSArIG1vZGVsLnNsaWNlKDEpO1xuICAgICAgc3R5bGVzW2JnTW9kZWxdID0ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuID0gYW5zaVN0eWxlcy5iZ0NvbG9yW2xldmVsTWFwcGluZ1tsZXZlbF1dW21vZGVsXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgY29uc3QgY29kZXMgPSB7XG4gICAgICAgICAgICAgIG9wZW4sXG4gICAgICAgICAgICAgIGNsb3NlOiBhbnNpU3R5bGVzLmJnQ29sb3IuY2xvc2UsXG4gICAgICAgICAgICAgIGNsb3NlUmU6IGFuc2lTdHlsZXMuYmdDb2xvci5jbG9zZVJlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkLmNhbGwodGhpcywgdGhpcy5fc3R5bGVzID8gdGhpcy5fc3R5bGVzLmNvbmNhdChjb2RlcykgOiBbY29kZXNdLCB0aGlzLl9lbXB0eSwgbW9kZWwpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCgpID0+IHt9LCBzdHlsZXMpO1xuXG4gICAgZnVuY3Rpb24gYnVpbGQoX3N0eWxlcywgX2VtcHR5LCBrZXkpIHtcbiAgICAgIGNvbnN0IGJ1aWxkZXIgPSBmdW5jdGlvbiBidWlsZGVyKCkge1xuICAgICAgICByZXR1cm4gYXBwbHlTdHlsZS5hcHBseShidWlsZGVyLCBhcmd1bWVudHMpO1xuICAgICAgfTtcblxuICAgICAgYnVpbGRlci5fc3R5bGVzID0gX3N0eWxlcztcbiAgICAgIGJ1aWxkZXIuX2VtcHR5ID0gX2VtcHR5O1xuICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVpbGRlciwgJ2xldmVsJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi5sZXZlbDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQobGV2ZWwpIHtcbiAgICAgICAgICBzZWxmLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVpbGRlciwgJ2VuYWJsZWQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmVuYWJsZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0KGVuYWJsZWQpIHtcbiAgICAgICAgICBzZWxmLmVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICB9XG5cbiAgICAgIH0pOyAvLyBTZWUgYmVsb3cgZm9yIGZpeCByZWdhcmRpbmcgaW52aXNpYmxlIGdyZXkvZGltIGNvbWJpbmF0aW9uIG9uIFdpbmRvd3NcblxuICAgICAgYnVpbGRlci5oYXNHcmV5ID0gdGhpcy5oYXNHcmV5IHx8IGtleSA9PT0gJ2dyYXknIHx8IGtleSA9PT0gJ2dyZXknOyAvLyBgX19wcm90b19fYCBpcyB1c2VkIGJlY2F1c2Ugd2UgbXVzdCByZXR1cm4gYSBmdW5jdGlvbiwgYnV0IHRoZXJlIGlzXG4gICAgICAvLyBubyB3YXkgdG8gY3JlYXRlIGEgZnVuY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBwcm90b3R5cGVcblxuICAgICAgYnVpbGRlci5fX3Byb3RvX18gPSBwcm90bzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVN0eWxlKCkge1xuICAgICAgLy8gU3VwcG9ydCB2YXJhZ3MsIGJ1dCBzaW1wbHkgY2FzdCB0byBzdHJpbmcgaW4gY2FzZSB0aGVyZSdzIG9ubHkgb25lIGFyZ1xuICAgICAgY29uc3QgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGNvbnN0IGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgIGxldCBzdHIgPSBTdHJpbmcoYXJndW1lbnRzWzBdKTtcblxuICAgICAgaWYgKGFyZ3NMZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJnc0xlbiA+IDEpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc2xpY2UgYGFyZ3VtZW50c2AsIGl0IHByZXZlbnRzIFY4IG9wdGltaXphdGlvbnNcbiAgICAgICAgZm9yIChsZXQgYSA9IDE7IGEgPCBhcmdzTGVuOyBhKyspIHtcbiAgICAgICAgICBzdHIgKz0gJyAnICsgYXJnc1thXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCB0aGlzLmxldmVsIDw9IDAgfHwgIXN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW1wdHkgPyAnJyA6IHN0cjtcbiAgICAgIH0gLy8gVHVybnMgb3V0IHRoYXQgb24gV2luZG93cyBkaW1tZWQgZ3JheSB0ZXh0IGJlY29tZXMgaW52aXNpYmxlIGluIGNtZC5leGUsXG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL2lzc3Vlcy81OFxuICAgICAgLy8gSWYgd2UncmUgb24gV2luZG93cyBhbmQgd2UncmUgZGVhbGluZyB3aXRoIGEgZ3JheSBjb2xvciwgdGVtcG9yYXJpbHkgbWFrZSAnZGltJyBhIG5vb3AuXG5cblxuICAgICAgY29uc3Qgb3JpZ2luYWxEaW0gPSBhbnNpU3R5bGVzLmRpbS5vcGVuO1xuXG4gICAgICBpZiAoaXNTaW1wbGVXaW5kb3dzVGVybSAmJiB0aGlzLmhhc0dyZXkpIHtcbiAgICAgICAgYW5zaVN0eWxlcy5kaW0ub3BlbiA9ICcnO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGNvZGUgb2YgdGhpcy5fc3R5bGVzLnNsaWNlKCkucmV2ZXJzZSgpKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgYW55IGluc3RhbmNlcyBhbHJlYWR5IHByZXNlbnQgd2l0aCBhIHJlLW9wZW5pbmcgY29kZVxuICAgICAgICAvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG4gICAgICAgIC8vIHdpbGwgYmUgY29sb3JlZCwgYW5kIHRoZSByZXN0IHdpbGwgc2ltcGx5IGJlICdwbGFpbicuXG4gICAgICAgIHN0ciA9IGNvZGUub3BlbiArIHN0ci5yZXBsYWNlKGNvZGUuY2xvc2VSZSwgY29kZS5vcGVuKSArIGNvZGUuY2xvc2U7IC8vIENsb3NlIHRoZSBzdHlsaW5nIGJlZm9yZSBhIGxpbmVicmVhayBhbmQgcmVvcGVuXG4gICAgICAgIC8vIGFmdGVyIG5leHQgbGluZSB0byBmaXggYSBibGVlZCBpc3N1ZSBvbiBtYWNPU1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhbGsvY2hhbGsvcHVsbC85MlxuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHI/XFxuL2csIFwiXCIuY29uY2F0KGNvZGUuY2xvc2UsIFwiJCZcIikuY29uY2F0KGNvZGUub3BlbikpO1xuICAgICAgfSAvLyBSZXNldCB0aGUgb3JpZ2luYWwgYGRpbWAgaWYgd2UgY2hhbmdlZCBpdCB0byB3b3JrIGFyb3VuZCB0aGUgV2luZG93cyBkaW1tZWQgZ3JheSBpc3N1ZVxuXG5cbiAgICAgIGFuc2lTdHlsZXMuZGltLm9wZW4gPSBvcmlnaW5hbERpbTtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbGtUYWcoY2hhbGssIHN0cmluZ3MpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHJpbmdzKSkge1xuICAgICAgICAvLyBJZiBjaGFsaygpIHdhcyBjYWxsZWQgYnkgaXRzZWxmIG9yIHdpdGggYSBzdHJpbmcsXG4gICAgICAgIC8vIHJldHVybiB0aGUgc3RyaW5nIGl0c2VsZiBhcyBhIHN0cmluZy5cbiAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5qb2luKCcgJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICBjb25zdCBwYXJ0cyA9IFtzdHJpbmdzLnJhd1swXV07XG5cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZyhhcmdzW2kgLSAxXSkucmVwbGFjZSgvW3t9XFxcXF0vZywgJ1xcXFwkJicpKTtcbiAgICAgICAgcGFydHMucHVzaChTdHJpbmcoc3RyaW5ncy5yYXdbaV0pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRlbXBsYXRlcyhjaGFsaywgcGFydHMuam9pbignJykpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYWxrLnByb3RvdHlwZSwgc3R5bGVzKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IENoYWxrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXG4gICAgbW9kdWxlLmV4cG9ydHMuc3VwcG9ydHNDb2xvciA9IHN0ZG91dENvbG9yO1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0czsgLy8gRm9yIFR5cGVTY3JpcHRcbiAgfSk7XG4gIHZhciBjaGFsa18xID0gY2hhbGsuc3VwcG9ydHNDb2xvcjtcblxuICB2YXIgY29tbW9uID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgZXhwb3J0cy5jb21tb25EZXByZWNhdGVkSGFuZGxlciA9IChrZXlPclBhaXIsIHJlZGlyZWN0VG8sIHtcbiAgICAgIGRlc2NyaXB0b3JcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IFtcIlwiLmNvbmNhdChjaGFsay5kZWZhdWx0LnllbGxvdyh0eXBlb2Yga2V5T3JQYWlyID09PSAnc3RyaW5nJyA/IGRlc2NyaXB0b3Iua2V5KGtleU9yUGFpcikgOiBkZXNjcmlwdG9yLnBhaXIoa2V5T3JQYWlyKSksIFwiIGlzIGRlcHJlY2F0ZWRcIildO1xuXG4gICAgICBpZiAocmVkaXJlY3RUbykge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKFwid2Ugbm93IHRyZWF0IGl0IGFzIFwiLmNvbmNhdChjaGFsay5kZWZhdWx0LmJsdWUodHlwZW9mIHJlZGlyZWN0VG8gPT09ICdzdHJpbmcnID8gZGVzY3JpcHRvci5rZXkocmVkaXJlY3RUbykgOiBkZXNjcmlwdG9yLnBhaXIocmVkaXJlY3RUbykpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXNzYWdlcy5qb2luKCc7ICcpICsgJy4nO1xuICAgIH07XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGNvbW1vbik7XG4gIHZhciBjb21tb25fMSA9IGNvbW1vbi5jb21tb25EZXByZWNhdGVkSGFuZGxlcjtcblxuICB2YXIgZGVwcmVjYXRlZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIHRzbGliXzEuX19leHBvcnRTdGFyKGNvbW1vbiwgZXhwb3J0cyk7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGRlcHJlY2F0ZWQpO1xuXG4gIHZhciBjb21tb24kMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIGV4cG9ydHMuY29tbW9uSW52YWxpZEhhbmRsZXIgPSAoa2V5LCB2YWx1ZSwgdXRpbHMpID0+IFtcIkludmFsaWQgXCIuY29uY2F0KGNoYWxrLmRlZmF1bHQucmVkKHV0aWxzLmRlc2NyaXB0b3Iua2V5KGtleSkpLCBcIiB2YWx1ZS5cIiksIFwiRXhwZWN0ZWQgXCIuY29uY2F0KGNoYWxrLmRlZmF1bHQuYmx1ZSh1dGlscy5zY2hlbWFzW2tleV0uZXhwZWN0ZWQodXRpbHMpKSwgXCIsXCIpLCBcImJ1dCByZWNlaXZlZCBcIi5jb25jYXQoY2hhbGsuZGVmYXVsdC5yZWQodXRpbHMuZGVzY3JpcHRvci52YWx1ZSh2YWx1ZSkpLCBcIi5cIildLmpvaW4oJyAnKTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoY29tbW9uJDEpO1xuICB2YXIgY29tbW9uXzEkMSA9IGNvbW1vbiQxLmNvbW1vbkludmFsaWRIYW5kbGVyO1xuXG4gIHZhciBpbnZhbGlkID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoY29tbW9uJDEsIGV4cG9ydHMpO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhpbnZhbGlkKTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXN0ZWQtdGVybmFyeSAqL1xuXG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGNoYXJDb2RlQ2FjaGUgPSBbXTtcblxuICB2YXIgbGV2ZW4gPSBmdW5jdGlvbiBsZXZlbihhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBzd2FwID0gYTsgLy8gU3dhcHBpbmcgdGhlIHN0cmluZ3MgaWYgYGFgIGlzIGxvbmdlciB0aGFuIGBiYCBzbyB3ZSBrbm93IHdoaWNoIG9uZSBpcyB0aGVcbiAgICAvLyBzaG9ydGVzdCAmIHdoaWNoIG9uZSBpcyB0aGUgbG9uZ2VzdFxuXG4gICAgaWYgKGEubGVuZ3RoID4gYi5sZW5ndGgpIHtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHN3YXA7XG4gICAgfVxuXG4gICAgdmFyIGFMZW4gPSBhLmxlbmd0aDtcbiAgICB2YXIgYkxlbiA9IGIubGVuZ3RoO1xuXG4gICAgaWYgKGFMZW4gPT09IDApIHtcbiAgICAgIHJldHVybiBiTGVuO1xuICAgIH1cblxuICAgIGlmIChiTGVuID09PSAwKSB7XG4gICAgICByZXR1cm4gYUxlbjtcbiAgICB9IC8vIFBlcmZvcm1pbmcgc3VmZml4IHRyaW1taW5nOlxuICAgIC8vIFdlIGNhbiBsaW5lYXJseSBkcm9wIHN1ZmZpeCBjb21tb24gdG8gYm90aCBzdHJpbmdzIHNpbmNlIHRoZXlcbiAgICAvLyBkb24ndCBpbmNyZWFzZSBkaXN0YW5jZSBhdCBhbGxcbiAgICAvLyBOb3RlOiBgfi1gIGlzIHRoZSBiaXR3aXNlIHdheSB0byBwZXJmb3JtIGEgYC0gMWAgb3BlcmF0aW9uXG5cblxuICAgIHdoaWxlIChhTGVuID4gMCAmJiBhLmNoYXJDb2RlQXQofi1hTGVuKSA9PT0gYi5jaGFyQ29kZUF0KH4tYkxlbikpIHtcbiAgICAgIGFMZW4tLTtcbiAgICAgIGJMZW4tLTtcbiAgICB9XG5cbiAgICBpZiAoYUxlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJMZW47XG4gICAgfSAvLyBQZXJmb3JtaW5nIHByZWZpeCB0cmltbWluZ1xuICAgIC8vIFdlIGNhbiBsaW5lYXJseSBkcm9wIHByZWZpeCBjb21tb24gdG8gYm90aCBzdHJpbmdzIHNpbmNlIHRoZXlcbiAgICAvLyBkb24ndCBpbmNyZWFzZSBkaXN0YW5jZSBhdCBhbGxcblxuXG4gICAgdmFyIHN0YXJ0ID0gMDtcblxuICAgIHdoaWxlIChzdGFydCA8IGFMZW4gJiYgYS5jaGFyQ29kZUF0KHN0YXJ0KSA9PT0gYi5jaGFyQ29kZUF0KHN0YXJ0KSkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG5cbiAgICBhTGVuIC09IHN0YXJ0O1xuICAgIGJMZW4gLT0gc3RhcnQ7XG5cbiAgICBpZiAoYUxlbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJMZW47XG4gICAgfVxuXG4gICAgdmFyIGJDaGFyQ29kZTtcbiAgICB2YXIgcmV0O1xuICAgIHZhciB0bXA7XG4gICAgdmFyIHRtcDI7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgY2hhckNvZGVDYWNoZVtzdGFydCArIGldID0gYS5jaGFyQ29kZUF0KHN0YXJ0ICsgaSk7XG4gICAgICBhcnJbaV0gPSArK2k7XG4gICAgfVxuXG4gICAgd2hpbGUgKGogPCBiTGVuKSB7XG4gICAgICBiQ2hhckNvZGUgPSBiLmNoYXJDb2RlQXQoc3RhcnQgKyBqKTtcbiAgICAgIHRtcCA9IGorKztcbiAgICAgIHJldCA9IGo7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhTGVuOyBpKyspIHtcbiAgICAgICAgdG1wMiA9IGJDaGFyQ29kZSA9PT0gY2hhckNvZGVDYWNoZVtzdGFydCArIGldID8gdG1wIDogdG1wICsgMTtcbiAgICAgICAgdG1wID0gYXJyW2ldO1xuICAgICAgICByZXQgPSBhcnJbaV0gPSB0bXAgPiByZXQgPyB0bXAyID4gcmV0ID8gcmV0ICsgMSA6IHRtcDIgOiB0bXAyID4gdG1wID8gdG1wICsgMSA6IHRtcDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB2YXIgbGV2ZW5fMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIGV4cG9ydHMubGV2ZW5Vbmtub3duSGFuZGxlciA9IChrZXksIHZhbHVlLCB7XG4gICAgICBkZXNjcmlwdG9yLFxuICAgICAgbG9nZ2VyLFxuICAgICAgc2NoZW1hc1xuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW1wiSWdub3JlZCB1bmtub3duIG9wdGlvbiBcIi5jb25jYXQoY2hhbGsuZGVmYXVsdC55ZWxsb3coZGVzY3JpcHRvci5wYWlyKHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSkpLCBcIi5cIildO1xuICAgICAgY29uc3Qgc3VnZ2VzdGlvbiA9IE9iamVjdC5rZXlzKHNjaGVtYXMpLnNvcnQoKS5maW5kKGtub3duS2V5ID0+IGxldmVuKGtleSwga25vd25LZXkpIDwgMyk7XG5cbiAgICAgIGlmIChzdWdnZXN0aW9uKSB7XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goXCJEaWQgeW91IG1lYW4gXCIuY29uY2F0KGNoYWxrLmRlZmF1bHQuYmx1ZShkZXNjcmlwdG9yLmtleShzdWdnZXN0aW9uKSksIFwiP1wiKSk7XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci53YXJuKG1lc3NhZ2VzLmpvaW4oJyAnKSk7XG4gICAgfTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMobGV2ZW5fMSk7XG4gIHZhciBsZXZlbl8yID0gbGV2ZW5fMS5sZXZlblVua25vd25IYW5kbGVyO1xuXG4gIHZhciB1bmtub3duID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIobGV2ZW5fMSwgZXhwb3J0cyk7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKHVua25vd24pO1xuXG4gIHZhciBoYW5kbGVycyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIHRzbGliXzEuX19leHBvcnRTdGFyKGRlcHJlY2F0ZWQsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoaW52YWxpZCwgZXhwb3J0cyk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3Rhcih1bmtub3duLCBleHBvcnRzKTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoaGFuZGxlcnMpO1xuXG4gIHZhciBzY2hlbWEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgSEFORExFUl9LRVlTID0gWydkZWZhdWx0JywgJ2V4cGVjdGVkJywgJ3ZhbGlkYXRlJywgJ2RlcHJlY2F0ZWQnLCAnZm9yd2FyZCcsICdyZWRpcmVjdCcsICdvdmVybGFwJywgJ3ByZXByb2Nlc3MnLCAncG9zdHByb2Nlc3MnXTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVNjaGVtYShTY2hlbWFDb25zdHJ1Y3RvciwgcGFyYW1ldGVycykge1xuICAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYUNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpO1xuICAgICAgY29uc3Qgc3ViU2NoZW1hID0gT2JqZWN0LmNyZWF0ZShzY2hlbWEpO1xuXG4gICAgICBmb3IgKGNvbnN0IGhhbmRsZXJLZXkgb2YgSEFORExFUl9LRVlTKSB7XG4gICAgICAgIGlmIChoYW5kbGVyS2V5IGluIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBzdWJTY2hlbWFbaGFuZGxlcktleV0gPSBub3JtYWxpemVIYW5kbGVyKHBhcmFtZXRlcnNbaGFuZGxlcktleV0sIHNjaGVtYSwgU2NoZW1hLnByb3RvdHlwZVtoYW5kbGVyS2V5XS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdWJTY2hlbWE7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5jcmVhdGVTY2hlbWEgPSBjcmVhdGVTY2hlbWE7XG5cbiAgICBjbGFzcyBTY2hlbWEge1xuICAgICAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgICAgICB0aGlzLm5hbWUgPSBwYXJhbWV0ZXJzLm5hbWU7XG4gICAgICB9XG5cbiAgICAgIHN0YXRpYyBjcmVhdGUocGFyYW1ldGVycykge1xuICAgICAgICAvLyBAdHMtaWdub3JlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzU4NjNcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNjaGVtYSh0aGlzLCBwYXJhbWV0ZXJzKTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdChfdXRpbHMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gaXN0YW5idWwgaWdub3JlIG5leHQ6IHRoaXMgaXMgYWN0dWFsbHkgYW4gYWJzdHJhY3QgbWV0aG9kIGJ1dCB3ZSBuZWVkIGEgcGxhY2Vob2xkZXIgdG8gZ2V0IGBmdW5jdGlvbi5sZW5ndGhgXG5cblxuICAgICAgZXhwZWN0ZWQoX3V0aWxzKSB7XG4gICAgICAgIHJldHVybiAnbm90aGluZyc7XG4gICAgICB9IC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiB0aGlzIGlzIGFjdHVhbGx5IGFuIGFic3RyYWN0IG1ldGhvZCBidXQgd2UgbmVlZCBhIHBsYWNlaG9sZGVyIHRvIGdldCBgZnVuY3Rpb24ubGVuZ3RoYFxuXG5cbiAgICAgIHZhbGlkYXRlKF92YWx1ZSwgX3V0aWxzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZGVwcmVjYXRlZChfdmFsdWUsIF91dGlscykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvcndhcmQoX3ZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmVkaXJlY3QoX3ZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgb3ZlcmxhcChjdXJyZW50VmFsdWUsIF9uZXdWYWx1ZSwgX3V0aWxzKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHByZXByb2Nlc3ModmFsdWUsIF91dGlscykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHBvc3Rwcm9jZXNzKHZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZXhwb3J0cy5TY2hlbWEgPSBTY2hlbWE7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIsIHN1cGVyU2NoZW1hLCBoYW5kbGVyQXJndW1lbnRzTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicgPyAoLi4uYXJncykgPT4gaGFuZGxlciguLi5hcmdzLnNsaWNlKDAsIGhhbmRsZXJBcmd1bWVudHNMZW5ndGggLSAxKSwgc3VwZXJTY2hlbWEsIC4uLmFyZ3Muc2xpY2UoaGFuZGxlckFyZ3VtZW50c0xlbmd0aCAtIDEpKSA6ICgpID0+IGhhbmRsZXI7XG4gICAgfVxuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhzY2hlbWEpO1xuICB2YXIgc2NoZW1hXzEgPSBzY2hlbWEuY3JlYXRlU2NoZW1hO1xuICB2YXIgc2NoZW1hXzIgPSBzY2hlbWEuU2NoZW1hO1xuXG4gIHZhciBhbGlhcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIGNsYXNzIEFsaWFzU2NoZW1hIGV4dGVuZHMgc2NoZW1hLlNjaGVtYSB7XG4gICAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9zb3VyY2VOYW1lID0gcGFyYW1ldGVycy5zb3VyY2VOYW1lO1xuICAgICAgfVxuXG4gICAgICBleHBlY3RlZCh1dGlscykge1xuICAgICAgICByZXR1cm4gdXRpbHMuc2NoZW1hc1t0aGlzLl9zb3VyY2VOYW1lXS5leHBlY3RlZCh1dGlscyk7XG4gICAgICB9XG5cbiAgICAgIHZhbGlkYXRlKHZhbHVlLCB1dGlscykge1xuICAgICAgICByZXR1cm4gdXRpbHMuc2NoZW1hc1t0aGlzLl9zb3VyY2VOYW1lXS52YWxpZGF0ZSh2YWx1ZSwgdXRpbHMpO1xuICAgICAgfVxuXG4gICAgICByZWRpcmVjdChfdmFsdWUsIF91dGlscykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlTmFtZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGV4cG9ydHMuQWxpYXNTY2hlbWEgPSBBbGlhc1NjaGVtYTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoYWxpYXMpO1xuICB2YXIgYWxpYXNfMSA9IGFsaWFzLkFsaWFzU2NoZW1hO1xuXG4gIHZhciBhbnkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBjbGFzcyBBbnlTY2hlbWEgZXh0ZW5kcyBzY2hlbWEuU2NoZW1hIHtcbiAgICAgIGV4cGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gJ2FueXRoaW5nJztcbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZXhwb3J0cy5BbnlTY2hlbWEgPSBBbnlTY2hlbWE7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGFueSk7XG4gIHZhciBhbnlfMSA9IGFueS5BbnlTY2hlbWE7XG5cbiAgdmFyIGFycmF5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgY2xhc3MgQXJyYXlTY2hlbWEgZXh0ZW5kcyBzY2hlbWEuU2NoZW1hIHtcbiAgICAgIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgdmFsdWVTY2hlbWEsXG4gICAgICAgICAgbmFtZSA9IHZhbHVlU2NoZW1hLm5hbWVcbiAgICAgICAgfSA9IF9hLFxuICAgICAgICAgICAgaGFuZGxlcnMgPSB0c2xpYl8xLl9fcmVzdChfYSwgW1widmFsdWVTY2hlbWFcIiwgXCJuYW1lXCJdKTtcblxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBoYW5kbGVycywge1xuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLl92YWx1ZVNjaGVtYSA9IHZhbHVlU2NoZW1hO1xuICAgICAgfVxuXG4gICAgICBleHBlY3RlZCh1dGlscykge1xuICAgICAgICByZXR1cm4gXCJhbiBhcnJheSBvZiBcIi5jb25jYXQodGhpcy5fdmFsdWVTY2hlbWEuZXhwZWN0ZWQodXRpbHMpKTtcbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGUodmFsdWUsIHV0aWxzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbnZhbGlkVmFsdWVzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBzdWJWYWx1ZSBvZiB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHN1YlZhbGlkYXRlUmVzdWx0ID0gdXRpbHMubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQodGhpcy5fdmFsdWVTY2hlbWEudmFsaWRhdGUoc3ViVmFsdWUsIHV0aWxzKSwgc3ViVmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHN1YlZhbGlkYXRlUmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpbnZhbGlkVmFsdWVzLnB1c2goc3ViVmFsaWRhdGVSZXN1bHQudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnZhbGlkVmFsdWVzLmxlbmd0aCA9PT0gMCA/IHRydWUgOiB7XG4gICAgICAgICAgdmFsdWU6IGludmFsaWRWYWx1ZXNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZGVwcmVjYXRlZCh2YWx1ZSwgdXRpbHMpIHtcbiAgICAgICAgY29uc3QgZGVwcmVjYXRlZFJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3Qgc3ViVmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBzdWJEZXByZWNhdGVkUmVzdWx0ID0gdXRpbHMubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdCh0aGlzLl92YWx1ZVNjaGVtYS5kZXByZWNhdGVkKHN1YlZhbHVlLCB1dGlscyksIHN1YlZhbHVlKTtcblxuICAgICAgICAgIGlmIChzdWJEZXByZWNhdGVkUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVwcmVjYXRlZFJlc3VsdC5wdXNoKC4uLnN1YkRlcHJlY2F0ZWRSZXN1bHQubWFwKCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBkZXByZWNhdGVkVmFsdWVcbiAgICAgICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgICAgIHZhbHVlOiBbZGVwcmVjYXRlZFZhbHVlXVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVwcmVjYXRlZFJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZm9yd2FyZCh2YWx1ZSwgdXRpbHMpIHtcbiAgICAgICAgY29uc3QgZm9yd2FyZFJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3Qgc3ViVmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBzdWJGb3J3YXJkUmVzdWx0ID0gdXRpbHMubm9ybWFsaXplRm9yd2FyZFJlc3VsdCh0aGlzLl92YWx1ZVNjaGVtYS5mb3J3YXJkKHN1YlZhbHVlLCB1dGlscyksIHN1YlZhbHVlKTtcbiAgICAgICAgICBmb3J3YXJkUmVzdWx0LnB1c2goLi4uc3ViRm9yd2FyZFJlc3VsdC5tYXAod3JhcFRyYW5zZmVyUmVzdWx0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9yd2FyZFJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgcmVkaXJlY3QodmFsdWUsIHV0aWxzKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbiA9IFtdO1xuICAgICAgICBjb25zdCByZWRpcmVjdCA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3Qgc3ViVmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCBzdWJSZWRpcmVjdFJlc3VsdCA9IHV0aWxzLm5vcm1hbGl6ZVJlZGlyZWN0UmVzdWx0KHRoaXMuX3ZhbHVlU2NoZW1hLnJlZGlyZWN0KHN1YlZhbHVlLCB1dGlscyksIHN1YlZhbHVlKTtcblxuICAgICAgICAgIGlmICgncmVtYWluJyBpbiBzdWJSZWRpcmVjdFJlc3VsdCkge1xuICAgICAgICAgICAgcmVtYWluLnB1c2goc3ViUmVkaXJlY3RSZXN1bHQucmVtYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWRpcmVjdC5wdXNoKC4uLnN1YlJlZGlyZWN0UmVzdWx0LnJlZGlyZWN0Lm1hcCh3cmFwVHJhbnNmZXJSZXN1bHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW1haW4ubGVuZ3RoID09PSAwID8ge1xuICAgICAgICAgIHJlZGlyZWN0XG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgcmVkaXJlY3QsXG4gICAgICAgICAgcmVtYWluXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG92ZXJsYXAoY3VycmVudFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlLmNvbmNhdChuZXdWYWx1ZSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBleHBvcnRzLkFycmF5U2NoZW1hID0gQXJyYXlTY2hlbWE7XG5cbiAgICBmdW5jdGlvbiB3cmFwVHJhbnNmZXJSZXN1bHQoe1xuICAgICAgZnJvbSxcbiAgICAgIHRvXG4gICAgfSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogW2Zyb21dLFxuICAgICAgICB0b1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGFycmF5KTtcbiAgdmFyIGFycmF5XzEgPSBhcnJheS5BcnJheVNjaGVtYTtcblxuICB2YXIgYm9vbGVhbl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgY2xhc3MgQm9vbGVhblNjaGVtYSBleHRlbmRzIHNjaGVtYS5TY2hlbWEge1xuICAgICAgZXhwZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAndHJ1ZSBvciBmYWxzZSc7XG4gICAgICB9XG5cbiAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGV4cG9ydHMuQm9vbGVhblNjaGVtYSA9IEJvb2xlYW5TY2hlbWE7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGJvb2xlYW5fMSk7XG4gIHZhciBib29sZWFuXzIgPSBib29sZWFuXzEuQm9vbGVhblNjaGVtYTtcblxuICB2YXIgdXRpbHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZWNvcmRGcm9tQXJyYXkoYXJyYXksIG1haW5LZXkpIHtcbiAgICAgIGNvbnN0IHJlY29yZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdmFsdWVbbWFpbktleV07IC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbiAgICAgICAgaWYgKHJlY29yZFtrZXldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIFwiLmNvbmNhdChtYWluS2V5LCBcIiBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGtleSkpKTtcbiAgICAgICAgfSAvLyBAdHMtaWdub3JlXG5cblxuICAgICAgICByZWNvcmRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVjb3JkO1xuICAgIH1cblxuICAgIGV4cG9ydHMucmVjb3JkRnJvbUFycmF5ID0gcmVjb3JkRnJvbUFycmF5O1xuXG4gICAgZnVuY3Rpb24gbWFwRnJvbUFycmF5KGFycmF5LCBtYWluS2V5KSB7XG4gICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG5cbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdmFsdWVbbWFpbktleV07IC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5cbiAgICAgICAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBcIi5jb25jYXQobWFpbktleSwgXCIgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShrZXkpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cblxuICAgIGV4cG9ydHMubWFwRnJvbUFycmF5ID0gbWFwRnJvbUFycmF5O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlQXV0b0NoZWNrbGlzdCgpIHtcbiAgICAgIGNvbnN0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gaWQgPT4ge1xuICAgICAgICBjb25zdCBpZFN0cmluZyA9IEpTT04uc3RyaW5naWZ5KGlkKTtcblxuICAgICAgICBpZiAobWFwW2lkU3RyaW5nXSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwW2lkU3RyaW5nXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZXhwb3J0cy5jcmVhdGVBdXRvQ2hlY2tsaXN0ID0gY3JlYXRlQXV0b0NoZWNrbGlzdDtcblxuICAgIGZ1bmN0aW9uIHBhcnRpdGlvbihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICBjb25zdCB0cnVlQXJyYXkgPSBbXTtcbiAgICAgIGNvbnN0IGZhbHNlQXJyYXkgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhcnJheSkge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHRydWVBcnJheS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmYWxzZUFycmF5LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdHJ1ZUFycmF5LCBmYWxzZUFycmF5XTtcbiAgICB9XG5cbiAgICBleHBvcnRzLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcblxuICAgIGZ1bmN0aW9uIGlzSW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IE1hdGguZmxvb3IodmFsdWUpO1xuICAgIH1cblxuICAgIGV4cG9ydHMuaXNJbnQgPSBpc0ludDtcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVQcmltaXRpdmUoYSwgYikge1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGVvZkEgPSB0eXBlb2YgYTtcbiAgICAgIGNvbnN0IHR5cGVvZkIgPSB0eXBlb2YgYjtcbiAgICAgIGNvbnN0IG9yZGVycyA9IFsndW5kZWZpbmVkJywgJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXTtcblxuICAgICAgaWYgKHR5cGVvZkEgIT09IHR5cGVvZkIpIHtcbiAgICAgICAgcmV0dXJuIG9yZGVycy5pbmRleE9mKHR5cGVvZkEpIC0gb3JkZXJzLmluZGV4T2YodHlwZW9mQik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2ZBICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGEpIC0gTnVtYmVyKGIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpO1xuICAgIH1cblxuICAgIGV4cG9ydHMuY29tcGFyZVByaW1pdGl2ZSA9IGNvbXBhcmVQcmltaXRpdmU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVEZWZhdWx0UmVzdWx0KHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8ge30gOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5ub3JtYWxpemVEZWZhdWx0UmVzdWx0ID0gbm9ybWFsaXplRGVmYXVsdFJlc3VsdDtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0KHJlc3VsdCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHRydWUgPyB0cnVlIDogcmVzdWx0ID09PSBmYWxzZSA/IHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5ub3JtYWxpemVWYWxpZGF0ZVJlc3VsdCA9IG5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0O1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdChyZXN1bHQsIHZhbHVlLCBkb05vdE5vcm1hbGl6ZVRydWUgPSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gZmFsc2UgPyBmYWxzZSA6IHJlc3VsdCA9PT0gdHJ1ZSA/IGRvTm90Tm9ybWFsaXplVHJ1ZSA/IHRydWUgOiBbe1xuICAgICAgICB2YWx1ZVxuICAgICAgfV0gOiAndmFsdWUnIGluIHJlc3VsdCA/IFtyZXN1bHRdIDogcmVzdWx0Lmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIGV4cG9ydHMubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdCA9IG5vcm1hbGl6ZURlcHJlY2F0ZWRSZXN1bHQ7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVUcmFuc2ZlclJlc3VsdChyZXN1bHQsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycgfHwgJ2tleScgaW4gcmVzdWx0ID8ge1xuICAgICAgICBmcm9tOiB2YWx1ZSxcbiAgICAgICAgdG86IHJlc3VsdFxuICAgICAgfSA6ICdmcm9tJyBpbiByZXN1bHQgPyB7XG4gICAgICAgIGZyb206IHJlc3VsdC5mcm9tLFxuICAgICAgICB0bzogcmVzdWx0LnRvXG4gICAgICB9IDoge1xuICAgICAgICBmcm9tOiB2YWx1ZSxcbiAgICAgICAgdG86IHJlc3VsdC50b1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBleHBvcnRzLm5vcm1hbGl6ZVRyYW5zZmVyUmVzdWx0ID0gbm9ybWFsaXplVHJhbnNmZXJSZXN1bHQ7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVGb3J3YXJkUmVzdWx0KHJlc3VsdCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IFtdIDogQXJyYXkuaXNBcnJheShyZXN1bHQpID8gcmVzdWx0Lm1hcCh0cmFuc2ZlclJlc3VsdCA9PiBub3JtYWxpemVUcmFuc2ZlclJlc3VsdCh0cmFuc2ZlclJlc3VsdCwgdmFsdWUpKSA6IFtub3JtYWxpemVUcmFuc2ZlclJlc3VsdChyZXN1bHQsIHZhbHVlKV07XG4gICAgfVxuXG4gICAgZXhwb3J0cy5ub3JtYWxpemVGb3J3YXJkUmVzdWx0ID0gbm9ybWFsaXplRm9yd2FyZFJlc3VsdDtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVJlZGlyZWN0UmVzdWx0KHJlc3VsdCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHJlZGlyZWN0ID0gbm9ybWFsaXplRm9yd2FyZFJlc3VsdCh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAncmVkaXJlY3QnIGluIHJlc3VsdCA/IHJlc3VsdC5yZWRpcmVjdCA6IHJlc3VsdCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHJlZGlyZWN0Lmxlbmd0aCA9PT0gMCA/IHtcbiAgICAgICAgcmVtYWluOiB2YWx1ZSxcbiAgICAgICAgcmVkaXJlY3RcbiAgICAgIH0gOiB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiAncmVtYWluJyBpbiByZXN1bHQgPyB7XG4gICAgICAgIHJlbWFpbjogcmVzdWx0LnJlbWFpbixcbiAgICAgICAgcmVkaXJlY3RcbiAgICAgIH0gOiB7XG4gICAgICAgIHJlZGlyZWN0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGV4cG9ydHMubm9ybWFsaXplUmVkaXJlY3RSZXN1bHQgPSBub3JtYWxpemVSZWRpcmVjdFJlc3VsdDtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHModXRpbHMpO1xuICB2YXIgdXRpbHNfMSA9IHV0aWxzLnJlY29yZEZyb21BcnJheTtcbiAgdmFyIHV0aWxzXzIgPSB1dGlscy5tYXBGcm9tQXJyYXk7XG4gIHZhciB1dGlsc18zID0gdXRpbHMuY3JlYXRlQXV0b0NoZWNrbGlzdDtcbiAgdmFyIHV0aWxzXzQgPSB1dGlscy5wYXJ0aXRpb247XG4gIHZhciB1dGlsc181ID0gdXRpbHMuaXNJbnQ7XG4gIHZhciB1dGlsc182ID0gdXRpbHMuY29tcGFyZVByaW1pdGl2ZTtcbiAgdmFyIHV0aWxzXzcgPSB1dGlscy5ub3JtYWxpemVEZWZhdWx0UmVzdWx0O1xuICB2YXIgdXRpbHNfOCA9IHV0aWxzLm5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0O1xuICB2YXIgdXRpbHNfOSA9IHV0aWxzLm5vcm1hbGl6ZURlcHJlY2F0ZWRSZXN1bHQ7XG4gIHZhciB1dGlsc18xMCA9IHV0aWxzLm5vcm1hbGl6ZVRyYW5zZmVyUmVzdWx0O1xuICB2YXIgdXRpbHNfMTEgPSB1dGlscy5ub3JtYWxpemVGb3J3YXJkUmVzdWx0O1xuICB2YXIgdXRpbHNfMTIgPSB1dGlscy5ub3JtYWxpemVSZWRpcmVjdFJlc3VsdDtcblxuICB2YXIgY2hvaWNlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgY2xhc3MgQ2hvaWNlU2NoZW1hIGV4dGVuZHMgc2NoZW1hLlNjaGVtYSB7XG4gICAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9jaG9pY2VzID0gdXRpbHMubWFwRnJvbUFycmF5KHBhcmFtZXRlcnMuY2hvaWNlcy5tYXAoY2hvaWNlID0+IGNob2ljZSAmJiB0eXBlb2YgY2hvaWNlID09PSAnb2JqZWN0JyA/IGNob2ljZSA6IHtcbiAgICAgICAgICB2YWx1ZTogY2hvaWNlXG4gICAgICAgIH0pLCAndmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0ZWQoe1xuICAgICAgICBkZXNjcmlwdG9yXG4gICAgICB9KSB7XG4gICAgICAgIGNvbnN0IGNob2ljZVZhbHVlcyA9IEFycmF5LmZyb20odGhpcy5fY2hvaWNlcy5rZXlzKCkpLm1hcCh2YWx1ZSA9PiB0aGlzLl9jaG9pY2VzLmdldCh2YWx1ZSkpLmZpbHRlcihjaG9pY2VJbmZvID0+ICFjaG9pY2VJbmZvLmRlcHJlY2F0ZWQpLm1hcChjaG9pY2VJbmZvID0+IGNob2ljZUluZm8udmFsdWUpLnNvcnQodXRpbHMuY29tcGFyZVByaW1pdGl2ZSkubWFwKGRlc2NyaXB0b3IudmFsdWUpO1xuICAgICAgICBjb25zdCBoZWFkID0gY2hvaWNlVmFsdWVzLnNsaWNlKDAsIC0yKTtcbiAgICAgICAgY29uc3QgdGFpbCA9IGNob2ljZVZhbHVlcy5zbGljZSgtMik7XG4gICAgICAgIHJldHVybiBoZWFkLmNvbmNhdCh0YWlsLmpvaW4oJyBvciAnKSkuam9pbignLCAnKTtcbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nob2ljZXMuaGFzKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZGVwcmVjYXRlZCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjaG9pY2VJbmZvID0gdGhpcy5fY2hvaWNlcy5nZXQodmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBjaG9pY2VJbmZvICYmIGNob2ljZUluZm8uZGVwcmVjYXRlZCA/IHtcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9IDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvcndhcmQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2hvaWNlSW5mbyA9IHRoaXMuX2Nob2ljZXMuZ2V0KHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gY2hvaWNlSW5mbyA/IGNob2ljZUluZm8uZm9yd2FyZCA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmVkaXJlY3QodmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2hvaWNlSW5mbyA9IHRoaXMuX2Nob2ljZXMuZ2V0KHZhbHVlKTtcblxuICAgICAgICByZXR1cm4gY2hvaWNlSW5mbyA/IGNob2ljZUluZm8ucmVkaXJlY3QgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBleHBvcnRzLkNob2ljZVNjaGVtYSA9IENob2ljZVNjaGVtYTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoY2hvaWNlKTtcbiAgdmFyIGNob2ljZV8xID0gY2hvaWNlLkNob2ljZVNjaGVtYTtcblxuICB2YXIgbnVtYmVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgY2xhc3MgTnVtYmVyU2NoZW1hIGV4dGVuZHMgc2NoZW1hLlNjaGVtYSB7XG4gICAgICBleHBlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICdhIG51bWJlcic7XG4gICAgICB9XG5cbiAgICAgIHZhbGlkYXRlKHZhbHVlLCBfdXRpbHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBleHBvcnRzLk51bWJlclNjaGVtYSA9IE51bWJlclNjaGVtYTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMobnVtYmVyKTtcbiAgdmFyIG51bWJlcl8xID0gbnVtYmVyLk51bWJlclNjaGVtYTtcblxuICB2YXIgaW50ZWdlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgIGNsYXNzIEludGVnZXJTY2hlbWEgZXh0ZW5kcyBudW1iZXIuTnVtYmVyU2NoZW1hIHtcbiAgICAgIGV4cGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gJ2FuIGludGVnZXInO1xuICAgICAgfVxuXG4gICAgICB2YWxpZGF0ZSh2YWx1ZSwgdXRpbHMkMSkge1xuICAgICAgICByZXR1cm4gdXRpbHMkMS5ub3JtYWxpemVWYWxpZGF0ZVJlc3VsdChzdXBlci52YWxpZGF0ZSh2YWx1ZSwgdXRpbHMkMSksIHZhbHVlKSA9PT0gdHJ1ZSAmJiB1dGlscy5pc0ludCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBleHBvcnRzLkludGVnZXJTY2hlbWEgPSBJbnRlZ2VyU2NoZW1hO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhpbnRlZ2VyKTtcbiAgdmFyIGludGVnZXJfMSA9IGludGVnZXIuSW50ZWdlclNjaGVtYTtcblxuICB2YXIgc3RyaW5nID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgY2xhc3MgU3RyaW5nU2NoZW1hIGV4dGVuZHMgc2NoZW1hLlNjaGVtYSB7XG4gICAgICBleHBlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICdhIHN0cmluZyc7XG4gICAgICB9XG5cbiAgICAgIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZXhwb3J0cy5TdHJpbmdTY2hlbWEgPSBTdHJpbmdTY2hlbWE7XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKHN0cmluZyk7XG4gIHZhciBzdHJpbmdfMSA9IHN0cmluZy5TdHJpbmdTY2hlbWE7XG5cbiAgdmFyIHNjaGVtYXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihhbGlhcywgZXhwb3J0cyk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihhbnksIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoYXJyYXksIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoYm9vbGVhbl8xLCBleHBvcnRzKTtcblxuICAgIHRzbGliXzEuX19leHBvcnRTdGFyKGNob2ljZSwgZXhwb3J0cyk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihpbnRlZ2VyLCBleHBvcnRzKTtcblxuICAgIHRzbGliXzEuX19leHBvcnRTdGFyKG51bWJlciwgZXhwb3J0cyk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3RhcihzdHJpbmcsIGV4cG9ydHMpO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhzY2hlbWFzKTtcblxuICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZXhwb3J0cy5kZWZhdWx0RGVzY3JpcHRvciA9IGFwaS5hcGlEZXNjcmlwdG9yO1xuICAgIGV4cG9ydHMuZGVmYXVsdFVua25vd25IYW5kbGVyID0gbGV2ZW5fMS5sZXZlblVua25vd25IYW5kbGVyO1xuICAgIGV4cG9ydHMuZGVmYXVsdEludmFsaWRIYW5kbGVyID0gaW52YWxpZC5jb21tb25JbnZhbGlkSGFuZGxlcjtcbiAgICBleHBvcnRzLmRlZmF1bHREZXByZWNhdGVkSGFuZGxlciA9IGNvbW1vbi5jb21tb25EZXByZWNhdGVkSGFuZGxlcjtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMoZGVmYXVsdHMpO1xuICB2YXIgZGVmYXVsdHNfMSA9IGRlZmF1bHRzLmRlZmF1bHREZXNjcmlwdG9yO1xuICB2YXIgZGVmYXVsdHNfMiA9IGRlZmF1bHRzLmRlZmF1bHRVbmtub3duSGFuZGxlcjtcbiAgdmFyIGRlZmF1bHRzXzMgPSBkZWZhdWx0cy5kZWZhdWx0SW52YWxpZEhhbmRsZXI7XG4gIHZhciBkZWZhdWx0c180ID0gZGVmYXVsdHMuZGVmYXVsdERlcHJlY2F0ZWRIYW5kbGVyO1xuXG4gIHZhciBub3JtYWxpemUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBleHBvcnRzLm5vcm1hbGl6ZSA9IChvcHRpb25zLCBzY2hlbWFzLCBvcHRzKSA9PiBuZXcgTm9ybWFsaXplcihzY2hlbWFzLCBvcHRzKS5ub3JtYWxpemUob3B0aW9ucyk7XG5cbiAgICBjbGFzcyBOb3JtYWxpemVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKHNjaGVtYXMsIG9wdHMpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxvZ2dlciA9IGNvbnNvbGUsXG4gICAgICAgICAgZGVzY3JpcHRvciA9IGRlZmF1bHRzLmRlZmF1bHREZXNjcmlwdG9yLFxuICAgICAgICAgIHVua25vd24gPSBkZWZhdWx0cy5kZWZhdWx0VW5rbm93bkhhbmRsZXIsXG4gICAgICAgICAgaW52YWxpZCA9IGRlZmF1bHRzLmRlZmF1bHRJbnZhbGlkSGFuZGxlcixcbiAgICAgICAgICBkZXByZWNhdGVkID0gZGVmYXVsdHMuZGVmYXVsdERlcHJlY2F0ZWRIYW5kbGVyXG4gICAgICAgIH0gPSBvcHRzIHx8IHt9O1xuICAgICAgICB0aGlzLl91dGlscyA9IHtcbiAgICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICAgIGxvZ2dlcjpcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGxvZ2dlciB8fCB7XG4gICAgICAgICAgICB3YXJuOiAoKSA9PiB7fVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2NoZW1hczogdXRpbHMucmVjb3JkRnJvbUFycmF5KHNjaGVtYXMsICduYW1lJyksXG4gICAgICAgICAgbm9ybWFsaXplRGVmYXVsdFJlc3VsdDogdXRpbHMubm9ybWFsaXplRGVmYXVsdFJlc3VsdCxcbiAgICAgICAgICBub3JtYWxpemVEZXByZWNhdGVkUmVzdWx0OiB1dGlscy5ub3JtYWxpemVEZXByZWNhdGVkUmVzdWx0LFxuICAgICAgICAgIG5vcm1hbGl6ZUZvcndhcmRSZXN1bHQ6IHV0aWxzLm5vcm1hbGl6ZUZvcndhcmRSZXN1bHQsXG4gICAgICAgICAgbm9ybWFsaXplUmVkaXJlY3RSZXN1bHQ6IHV0aWxzLm5vcm1hbGl6ZVJlZGlyZWN0UmVzdWx0LFxuICAgICAgICAgIG5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0OiB1dGlscy5ub3JtYWxpemVWYWxpZGF0ZVJlc3VsdFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl91bmtub3duSGFuZGxlciA9IHVua25vd247XG4gICAgICAgIHRoaXMuX2ludmFsaWRIYW5kbGVyID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy5fZGVwcmVjYXRlZEhhbmRsZXIgPSBkZXByZWNhdGVkO1xuICAgICAgICB0aGlzLmNsZWFuSGlzdG9yeSgpO1xuICAgICAgfVxuXG4gICAgICBjbGVhbkhpc3RvcnkoKSB7XG4gICAgICAgIHRoaXMuX2hhc0RlcHJlY2F0aW9uV2FybmVkID0gdXRpbHMuY3JlYXRlQXV0b0NoZWNrbGlzdCgpO1xuICAgICAgfVxuXG4gICAgICBub3JtYWxpemUob3B0aW9ucykge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkID0ge307XG4gICAgICAgIGNvbnN0IHJlc3RPcHRpb25zQXJyYXkgPSBbb3B0aW9uc107XG5cbiAgICAgICAgY29uc3QgYXBwbHlOb3JtYWxpemF0aW9uID0gKCkgPT4ge1xuICAgICAgICAgIHdoaWxlIChyZXN0T3B0aW9uc0FycmF5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE9wdGlvbnMgPSByZXN0T3B0aW9uc0FycmF5LnNoaWZ0KCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVycmVkT3B0aW9uc0FycmF5ID0gdGhpcy5fYXBwbHlOb3JtYWxpemF0aW9uKGN1cnJlbnRPcHRpb25zLCBub3JtYWxpemVkKTtcblxuICAgICAgICAgICAgcmVzdE9wdGlvbnNBcnJheS5wdXNoKC4uLnRyYW5zZmVycmVkT3B0aW9uc0FycmF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgYXBwbHlOb3JtYWxpemF0aW9uKCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5fdXRpbHMuc2NoZW1hcykpIHtcbiAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl91dGlscy5zY2hlbWFzW2tleV07XG5cbiAgICAgICAgICBpZiAoIShrZXkgaW4gbm9ybWFsaXplZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRSZXN1bHQgPSB1dGlscy5ub3JtYWxpemVEZWZhdWx0UmVzdWx0KHNjaGVtYS5kZWZhdWx0KHRoaXMuX3V0aWxzKSk7XG5cbiAgICAgICAgICAgIGlmICgndmFsdWUnIGluIGRlZmF1bHRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmVzdE9wdGlvbnNBcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgICBba2V5XTogZGVmYXVsdFJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcHBseU5vcm1hbGl6YXRpb24oKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLl91dGlscy5zY2hlbWFzKSkge1xuICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX3V0aWxzLnNjaGVtYXNba2V5XTtcblxuICAgICAgICAgIGlmIChrZXkgaW4gbm9ybWFsaXplZCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZFtrZXldID0gc2NoZW1hLnBvc3Rwcm9jZXNzKG5vcm1hbGl6ZWRba2V5XSwgdGhpcy5fdXRpbHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgICAgfVxuXG4gICAgICBfYXBwbHlOb3JtYWxpemF0aW9uKG9wdGlvbnMsIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmZXJyZWRPcHRpb25zQXJyYXkgPSBbXTtcbiAgICAgICAgY29uc3QgW2tub3duT3B0aW9uTmFtZXMsIHVua25vd25PcHRpb25OYW1lc10gPSB1dGlscy5wYXJ0aXRpb24oT2JqZWN0LmtleXMob3B0aW9ucyksIGtleSA9PiBrZXkgaW4gdGhpcy5fdXRpbHMuc2NoZW1hcyk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga25vd25PcHRpb25OYW1lcykge1xuICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX3V0aWxzLnNjaGVtYXNba2V5XTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNjaGVtYS5wcmVwcm9jZXNzKG9wdGlvbnNba2V5XSwgdGhpcy5fdXRpbHMpO1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRlUmVzdWx0ID0gdXRpbHMubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQoc2NoZW1hLnZhbGlkYXRlKHZhbHVlLCB0aGlzLl91dGlscyksIHZhbHVlKTtcblxuICAgICAgICAgIGlmICh2YWxpZGF0ZVJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB2YWx1ZTogaW52YWxpZFZhbHVlXG4gICAgICAgICAgICB9ID0gdmFsaWRhdGVSZXN1bHQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZU9yRXJyb3IgPSB0aGlzLl9pbnZhbGlkSGFuZGxlcihrZXksIGludmFsaWRWYWx1ZSwgdGhpcy5fdXRpbHMpO1xuXG4gICAgICAgICAgICB0aHJvdyB0eXBlb2YgZXJyb3JNZXNzYWdlT3JFcnJvciA9PT0gJ3N0cmluZycgPyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlT3JFcnJvcikgOlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQqL1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlT3JFcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBhcHBlbmRUcmFuc2ZlcnJlZE9wdGlvbnMgPSAoe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvXG4gICAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgdHJhbnNmZXJyZWRPcHRpb25zQXJyYXkucHVzaCh0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8ge1xuICAgICAgICAgICAgICBbdG9dOiBmcm9tXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICBbdG8ua2V5XTogdG8udmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCB3YXJuRGVwcmVjYXRlZCA9ICh7XG4gICAgICAgICAgICB2YWx1ZTogY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgcmVkaXJlY3RUb1xuICAgICAgICAgIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlcHJlY2F0ZWRSZXN1bHQgPSB1dGlscy5ub3JtYWxpemVEZXByZWNhdGVkUmVzdWx0KHNjaGVtYS5kZXByZWNhdGVkKGN1cnJlbnRWYWx1ZSwgdGhpcy5fdXRpbHMpLCB2YWx1ZSxcbiAgICAgICAgICAgIC8qIGRvTm90Tm9ybWFsaXplVHJ1ZSAqL1xuICAgICAgICAgICAgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChkZXByZWNhdGVkUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXByZWNhdGVkUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5faGFzRGVwcmVjYXRpb25XYXJuZWQoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3V0aWxzLmxvZ2dlci53YXJuKHRoaXMuX2RlcHJlY2F0ZWRIYW5kbGVyKGtleSwgcmVkaXJlY3RUbywgdGhpcy5fdXRpbHMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGRlcHJlY2F0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9IG9mIGRlcHJlY2F0ZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWlyID0ge1xuICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGRlcHJlY2F0ZWRWYWx1ZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2hhc0RlcHJlY2F0aW9uV2FybmVkKHBhaXIpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZWRpcmVjdFRvUGFpciA9IHR5cGVvZiByZWRpcmVjdFRvID09PSAnc3RyaW5nJyA/IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiByZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGVwcmVjYXRlZFZhbHVlXG4gICAgICAgICAgICAgICAgICB9IDogcmVkaXJlY3RUbztcblxuICAgICAgICAgICAgICAgICAgdGhpcy5fdXRpbHMubG9nZ2VyLndhcm4odGhpcy5fZGVwcmVjYXRlZEhhbmRsZXIocGFpciwgcmVkaXJlY3RUb1BhaXIsIHRoaXMuX3V0aWxzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGZvcndhcmRSZXN1bHQgPSB1dGlscy5ub3JtYWxpemVGb3J3YXJkUmVzdWx0KHNjaGVtYS5mb3J3YXJkKHZhbHVlLCB0aGlzLl91dGlscyksIHZhbHVlKTtcbiAgICAgICAgICBmb3J3YXJkUmVzdWx0LmZvckVhY2goYXBwZW5kVHJhbnNmZXJyZWRPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCByZWRpcmVjdFJlc3VsdCA9IHV0aWxzLm5vcm1hbGl6ZVJlZGlyZWN0UmVzdWx0KHNjaGVtYS5yZWRpcmVjdCh2YWx1ZSwgdGhpcy5fdXRpbHMpLCB2YWx1ZSk7XG4gICAgICAgICAgcmVkaXJlY3RSZXN1bHQucmVkaXJlY3QuZm9yRWFjaChhcHBlbmRUcmFuc2ZlcnJlZE9wdGlvbnMpO1xuXG4gICAgICAgICAgaWYgKCdyZW1haW4nIGluIHJlZGlyZWN0UmVzdWx0KSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdWYWx1ZSA9IHJlZGlyZWN0UmVzdWx0LnJlbWFpbjtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGtleSBpbiBub3JtYWxpemVkID8gc2NoZW1hLm92ZXJsYXAobm9ybWFsaXplZFtrZXldLCByZW1haW5pbmdWYWx1ZSwgdGhpcy5fdXRpbHMpIDogcmVtYWluaW5nVmFsdWU7XG4gICAgICAgICAgICB3YXJuRGVwcmVjYXRlZCh7XG4gICAgICAgICAgICAgIHZhbHVlOiByZW1haW5pbmdWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG9cbiAgICAgICAgICB9IG9mIHJlZGlyZWN0UmVzdWx0LnJlZGlyZWN0KSB7XG4gICAgICAgICAgICB3YXJuRGVwcmVjYXRlZCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBmcm9tLFxuICAgICAgICAgICAgICByZWRpcmVjdFRvOiB0b1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bk9wdGlvbk5hbWVzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG5cbiAgICAgICAgICBjb25zdCB1bmtub3duUmVzdWx0ID0gdGhpcy5fdW5rbm93bkhhbmRsZXIoa2V5LCB2YWx1ZSwgdGhpcy5fdXRpbHMpO1xuXG4gICAgICAgICAgaWYgKHVua25vd25SZXN1bHQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdW5rbm93bktleSBvZiBPYmplY3Qua2V5cyh1bmtub3duUmVzdWx0KSkge1xuICAgICAgICAgICAgICBjb25zdCB1bmtub3duT3B0aW9uID0ge1xuICAgICAgICAgICAgICAgIFt1bmtub3duS2V5XTogdW5rbm93blJlc3VsdFt1bmtub3duS2V5XVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmICh1bmtub3duS2V5IGluIHRoaXMuX3V0aWxzLnNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcnJlZE9wdGlvbnNBcnJheS5wdXNoKHVua25vd25PcHRpb24pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obm9ybWFsaXplZCwgdW5rbm93bk9wdGlvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJhbnNmZXJyZWRPcHRpb25zQXJyYXk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBleHBvcnRzLk5vcm1hbGl6ZXIgPSBOb3JtYWxpemVyO1xuICB9KTtcbiAgdW53cmFwRXhwb3J0cyhub3JtYWxpemUpO1xuICB2YXIgbm9ybWFsaXplXzEgPSBub3JtYWxpemUubm9ybWFsaXplO1xuICB2YXIgbm9ybWFsaXplXzIgPSBub3JtYWxpemUuTm9ybWFsaXplcjtcblxuICB2YXIgbGliID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoZGVzY3JpcHRvcnMsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoaGFuZGxlcnMsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoc2NoZW1hcywgZXhwb3J0cyk7XG5cbiAgICB0c2xpYl8xLl9fZXhwb3J0U3Rhcihub3JtYWxpemUsIGV4cG9ydHMpO1xuXG4gICAgdHNsaWJfMS5fX2V4cG9ydFN0YXIoc2NoZW1hLCBleHBvcnRzKTtcbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMobGliKTtcblxuICBjb25zdCBhcnJheSQxID0gW107XG4gIGNvbnN0IGNoYXJDb2RlQ2FjaGUkMSA9IFtdO1xuXG4gIGNvbnN0IGxldmVuJDEgPSAobGVmdCwgcmlnaHQpID0+IHtcbiAgICBpZiAobGVmdCA9PT0gcmlnaHQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbnN0IHN3YXAgPSBsZWZ0OyAvLyBTd2FwcGluZyB0aGUgc3RyaW5ncyBpZiBgYWAgaXMgbG9uZ2VyIHRoYW4gYGJgIHNvIHdlIGtub3cgd2hpY2ggb25lIGlzIHRoZVxuICAgIC8vIHNob3J0ZXN0ICYgd2hpY2ggb25lIGlzIHRoZSBsb25nZXN0XG5cbiAgICBpZiAobGVmdC5sZW5ndGggPiByaWdodC5sZW5ndGgpIHtcbiAgICAgIGxlZnQgPSByaWdodDtcbiAgICAgIHJpZ2h0ID0gc3dhcDtcbiAgICB9XG5cbiAgICBsZXQgbGVmdExlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICAgIGxldCByaWdodExlbmd0aCA9IHJpZ2h0Lmxlbmd0aDsgLy8gUGVyZm9ybWluZyBzdWZmaXggdHJpbW1pbmc6XG4gICAgLy8gV2UgY2FuIGxpbmVhcmx5IGRyb3Agc3VmZml4IGNvbW1vbiB0byBib3RoIHN0cmluZ3Mgc2luY2UgdGhleVxuICAgIC8vIGRvbid0IGluY3JlYXNlIGRpc3RhbmNlIGF0IGFsbFxuICAgIC8vIE5vdGU6IGB+LWAgaXMgdGhlIGJpdHdpc2Ugd2F5IHRvIHBlcmZvcm0gYSBgLSAxYCBvcGVyYXRpb25cblxuICAgIHdoaWxlIChsZWZ0TGVuZ3RoID4gMCAmJiBsZWZ0LmNoYXJDb2RlQXQofi1sZWZ0TGVuZ3RoKSA9PT0gcmlnaHQuY2hhckNvZGVBdCh+LXJpZ2h0TGVuZ3RoKSkge1xuICAgICAgbGVmdExlbmd0aC0tO1xuICAgICAgcmlnaHRMZW5ndGgtLTtcbiAgICB9IC8vIFBlcmZvcm1pbmcgcHJlZml4IHRyaW1taW5nXG4gICAgLy8gV2UgY2FuIGxpbmVhcmx5IGRyb3AgcHJlZml4IGNvbW1vbiB0byBib3RoIHN0cmluZ3Mgc2luY2UgdGhleVxuICAgIC8vIGRvbid0IGluY3JlYXNlIGRpc3RhbmNlIGF0IGFsbFxuXG5cbiAgICBsZXQgc3RhcnQgPSAwO1xuXG4gICAgd2hpbGUgKHN0YXJ0IDwgbGVmdExlbmd0aCAmJiBsZWZ0LmNoYXJDb2RlQXQoc3RhcnQpID09PSByaWdodC5jaGFyQ29kZUF0KHN0YXJ0KSkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG5cbiAgICBsZWZ0TGVuZ3RoIC09IHN0YXJ0O1xuICAgIHJpZ2h0TGVuZ3RoIC09IHN0YXJ0O1xuXG4gICAgaWYgKGxlZnRMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiByaWdodExlbmd0aDtcbiAgICB9XG5cbiAgICBsZXQgYkNoYXJDb2RlO1xuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IHRlbXA7XG4gICAgbGV0IHRlbXAyO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlZnRMZW5ndGgpIHtcbiAgICAgIGNoYXJDb2RlQ2FjaGUkMVtpXSA9IGxlZnQuY2hhckNvZGVBdChzdGFydCArIGkpO1xuICAgICAgYXJyYXkkMVtpXSA9ICsraTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaiA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICBiQ2hhckNvZGUgPSByaWdodC5jaGFyQ29kZUF0KHN0YXJ0ICsgaik7XG4gICAgICB0ZW1wID0gaisrO1xuICAgICAgcmVzdWx0ID0gajtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlZnRMZW5ndGg7IGkrKykge1xuICAgICAgICB0ZW1wMiA9IGJDaGFyQ29kZSA9PT0gY2hhckNvZGVDYWNoZSQxW2ldID8gdGVtcCA6IHRlbXAgKyAxO1xuICAgICAgICB0ZW1wID0gYXJyYXkkMVtpXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW11bHRpLWFzc2lnblxuXG4gICAgICAgIHJlc3VsdCA9IGFycmF5JDFbaV0gPSB0ZW1wID4gcmVzdWx0ID8gdGVtcDIgPiByZXN1bHQgPyByZXN1bHQgKyAxIDogdGVtcDIgOiB0ZW1wMiA+IHRlbXAgPyB0ZW1wICsgMSA6IHRlbXAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIGxldmVuXzEkMSA9IGxldmVuJDE7IC8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5cbiAgdmFyIGRlZmF1bHRfMSA9IGxldmVuJDE7XG4gIGxldmVuXzEkMS5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuXG4gIHZhciBjb2xvck5hbWUkMSA9IHtcbiAgICBcImFsaWNlYmx1ZVwiOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxuICAgIFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxuICAgIFwiYXF1YW1hcmluZVwiOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgXCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgXCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgXCJiaXNxdWVcIjogWzI1NSwgMjI4LCAxOTZdLFxuICAgIFwiYmxhY2tcIjogWzAsIDAsIDBdLFxuICAgIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxuICAgIFwiYmx1ZVwiOiBbMCwgMCwgMjU1XSxcbiAgICBcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXG4gICAgXCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxuICAgIFwiYnVybHl3b29kXCI6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICBcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcbiAgICBcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcbiAgICBcImNob2NvbGF0ZVwiOiBbMjEwLCAxMDUsIDMwXSxcbiAgICBcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxuICAgIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxuICAgIFwiY29ybnNpbGtcIjogWzI1NSwgMjQ4LCAyMjBdLFxuICAgIFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxuICAgIFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxuICAgIFwiZGFya2JsdWVcIjogWzAsIDAsIDEzOV0sXG4gICAgXCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxuICAgIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcbiAgICBcImRhcmtncmF5XCI6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcbiAgICBcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBcImRhcmtraGFraVwiOiBbMTg5LCAxODMsIDEwN10sXG4gICAgXCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxuICAgIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcbiAgICBcImRhcmtvcmFuZ2VcIjogWzI1NSwgMTQwLCAwXSxcbiAgICBcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXG4gICAgXCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxuICAgIFwiZGFya3NhbG1vblwiOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxuICAgIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxuICAgIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsIDc5LCA3OV0sXG4gICAgXCJkYXJrc2xhdGVncmV5XCI6IFs0NywgNzksIDc5XSxcbiAgICBcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiwgMjA5XSxcbiAgICBcImRhcmt2aW9sZXRcIjogWzE0OCwgMCwgMjExXSxcbiAgICBcImRlZXBwaW5rXCI6IFsyNTUsIDIwLCAxNDddLFxuICAgIFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSwgMjU1XSxcbiAgICBcImRpbWdyYXlcIjogWzEwNSwgMTA1LCAxMDVdLFxuICAgIFwiZGltZ3JleVwiOiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgXCJkb2RnZXJibHVlXCI6IFszMCwgMTQ0LCAyNTVdLFxuICAgIFwiZmlyZWJyaWNrXCI6IFsxNzgsIDM0LCAzNF0sXG4gICAgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LCAyNTAsIDI0MF0sXG4gICAgXCJmb3Jlc3RncmVlblwiOiBbMzQsIDEzOSwgMzRdLFxuICAgIFwiZnVjaHNpYVwiOiBbMjU1LCAwLCAyNTVdLFxuICAgIFwiZ2FpbnNib3JvXCI6IFsyMjAsIDIyMCwgMjIwXSxcbiAgICBcImdob3N0d2hpdGVcIjogWzI0OCwgMjQ4LCAyNTVdLFxuICAgIFwiZ29sZFwiOiBbMjU1LCAyMTUsIDBdLFxuICAgIFwiZ29sZGVucm9kXCI6IFsyMTgsIDE2NSwgMzJdLFxuICAgIFwiZ3JheVwiOiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgXCJncmVlblwiOiBbMCwgMTI4LCAwXSxcbiAgICBcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxuICAgIFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgXCJob25leWRld1wiOiBbMjQwLCAyNTUsIDI0MF0sXG4gICAgXCJob3RwaW5rXCI6IFsyNTUsIDEwNSwgMTgwXSxcbiAgICBcImluZGlhbnJlZFwiOiBbMjA1LCA5MiwgOTJdLFxuICAgIFwiaW5kaWdvXCI6IFs3NSwgMCwgMTMwXSxcbiAgICBcIml2b3J5XCI6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICBcImtoYWtpXCI6IFsyNDAsIDIzMCwgMTQwXSxcbiAgICBcImxhdmVuZGVyXCI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgICBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwgMjQwLCAyNDVdLFxuICAgIFwibGF3bmdyZWVuXCI6IFsxMjQsIDI1MiwgMF0sXG4gICAgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwgMjUwLCAyMDVdLFxuICAgIFwibGlnaHRibHVlXCI6IFsxNzMsIDIxNiwgMjMwXSxcbiAgICBcImxpZ2h0Y29yYWxcIjogWzI0MCwgMTI4LCAxMjhdLFxuICAgIFwibGlnaHRjeWFuXCI6IFsyMjQsIDI1NSwgMjU1XSxcbiAgICBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsIDI1MCwgMjEwXSxcbiAgICBcImxpZ2h0Z3JheVwiOiBbMjExLCAyMTEsIDIxMV0sXG4gICAgXCJsaWdodGdyZWVuXCI6IFsxNDQsIDIzOCwgMTQ0XSxcbiAgICBcImxpZ2h0Z3JleVwiOiBbMjExLCAyMTEsIDIxMV0sXG4gICAgXCJsaWdodHBpbmtcIjogWzI1NSwgMTgyLCAxOTNdLFxuICAgIFwibGlnaHRzYWxtb25cIjogWzI1NSwgMTYwLCAxMjJdLFxuICAgIFwibGlnaHRzZWFncmVlblwiOiBbMzIsIDE3OCwgMTcwXSxcbiAgICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDI1MF0sXG4gICAgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LCAxMzYsIDE1M10sXG4gICAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LCAxMzYsIDE1M10sXG4gICAgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LCAxOTYsIDIyMl0sXG4gICAgXCJsaWdodHllbGxvd1wiOiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgXCJsaW1lXCI6IFswLCAyNTUsIDBdLFxuICAgIFwibGltZWdyZWVuXCI6IFs1MCwgMjA1LCA1MF0sXG4gICAgXCJsaW5lblwiOiBbMjUwLCAyNDAsIDIzMF0sXG4gICAgXCJtYWdlbnRhXCI6IFsyNTUsIDAsIDI1NV0sXG4gICAgXCJtYXJvb25cIjogWzEyOCwgMCwgMF0sXG4gICAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsIDIwNSwgMTcwXSxcbiAgICBcIm1lZGl1bWJsdWVcIjogWzAsIDAsIDIwNV0sXG4gICAgXCJtZWRpdW1vcmNoaWRcIjogWzE4NiwgODUsIDIxMV0sXG4gICAgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywgMTEyLCAyMTldLFxuICAgIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLCAxNzksIDExM10sXG4gICAgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywgMTA0LCAyMzhdLFxuICAgIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsIDI1MCwgMTU0XSxcbiAgICBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsIDIwOSwgMjA0XSxcbiAgICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LCAyMSwgMTMzXSxcbiAgICBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsIDI1LCAxMTJdLFxuICAgIFwibWludGNyZWFtXCI6IFsyNDUsIDI1NSwgMjUwXSxcbiAgICBcIm1pc3R5cm9zZVwiOiBbMjU1LCAyMjgsIDIyNV0sXG4gICAgXCJtb2NjYXNpblwiOiBbMjU1LCAyMjgsIDE4MV0sXG4gICAgXCJuYXZham93aGl0ZVwiOiBbMjU1LCAyMjIsIDE3M10sXG4gICAgXCJuYXZ5XCI6IFswLCAwLCAxMjhdLFxuICAgIFwib2xkbGFjZVwiOiBbMjUzLCAyNDUsIDIzMF0sXG4gICAgXCJvbGl2ZVwiOiBbMTI4LCAxMjgsIDBdLFxuICAgIFwib2xpdmVkcmFiXCI6IFsxMDcsIDE0MiwgMzVdLFxuICAgIFwib3JhbmdlXCI6IFsyNTUsIDE2NSwgMF0sXG4gICAgXCJvcmFuZ2VyZWRcIjogWzI1NSwgNjksIDBdLFxuICAgIFwib3JjaGlkXCI6IFsyMTgsIDExMiwgMjE0XSxcbiAgICBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwgMjMyLCAxNzBdLFxuICAgIFwicGFsZWdyZWVuXCI6IFsxNTIsIDI1MSwgMTUyXSxcbiAgICBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwgMjM4LCAyMzhdLFxuICAgIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LCAxMTIsIDE0N10sXG4gICAgXCJwYXBheWF3aGlwXCI6IFsyNTUsIDIzOSwgMjEzXSxcbiAgICBcInBlYWNocHVmZlwiOiBbMjU1LCAyMTgsIDE4NV0sXG4gICAgXCJwZXJ1XCI6IFsyMDUsIDEzMywgNjNdLFxuICAgIFwicGlua1wiOiBbMjU1LCAxOTIsIDIwM10sXG4gICAgXCJwbHVtXCI6IFsyMjEsIDE2MCwgMjIxXSxcbiAgICBcInBvd2RlcmJsdWVcIjogWzE3NiwgMjI0LCAyMzBdLFxuICAgIFwicHVycGxlXCI6IFsxMjgsIDAsIDEyOF0sXG4gICAgXCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsIDUxLCAxNTNdLFxuICAgIFwicmVkXCI6IFsyNTUsIDAsIDBdLFxuICAgIFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcbiAgICBcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcbiAgICBcInNhZGRsZWJyb3duXCI6IFsxMzksIDY5LCAxOV0sXG4gICAgXCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxuICAgIFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICBcInNlYWdyZWVuXCI6IFs0NiwgMTM5LCA4N10sXG4gICAgXCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXG4gICAgXCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcbiAgICBcInNpbHZlclwiOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgXCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcbiAgICBcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcbiAgICBcInNsYXRlZ3JheVwiOiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgXCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxuICAgIFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXG4gICAgXCJzcHJpbmdncmVlblwiOiBbMCwgMjU1LCAxMjddLFxuICAgIFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxuICAgIFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcbiAgICBcInRlYWxcIjogWzAsIDEyOCwgMTI4XSxcbiAgICBcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxuICAgIFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXG4gICAgXCJ0dXJxdW9pc2VcIjogWzY0LCAyMjQsIDIwOF0sXG4gICAgXCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxuICAgIFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxuICAgIFwid2hpdGVcIjogWzI1NSwgMjU1LCAyNTVdLFxuICAgIFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgXCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcbiAgICBcInllbGxvd2dyZWVuXCI6IFsxNTQsIDIwNSwgNTBdXG4gIH07XG5cbiAgLyogTUlUIGxpY2Vuc2UgKi9cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1vcGVyYXRvcnMgKi9cbiAgLy8gTk9URTogY29udmVyc2lvbnMgc2hvdWxkIG9ubHkgcmV0dXJuIHByaW1pdGl2ZSB2YWx1ZXMgKGkuZS4gYXJyYXlzLCBvclxuICAvLyAgICAgICB2YWx1ZXMgdGhhdCBnaXZlIGNvcnJlY3QgYHR5cGVvZmAgcmVzdWx0cykuXG4gIC8vICAgICAgIGRvIG5vdCB1c2UgYm94IHZhbHVlcyB0eXBlcyAoaS5lLiBOdW1iZXIoKSwgU3RyaW5nKCksIGV0Yy4pXG5cbiAgY29uc3QgcmV2ZXJzZUtleXdvcmRzID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29sb3JOYW1lJDEpKSB7XG4gICAgcmV2ZXJzZUtleXdvcmRzW2NvbG9yTmFtZSQxW2tleV1dID0ga2V5O1xuICB9XG5cbiAgY29uc3QgY29udmVydCQxID0ge1xuICAgIHJnYjoge1xuICAgICAgY2hhbm5lbHM6IDMsXG4gICAgICBsYWJlbHM6ICdyZ2InXG4gICAgfSxcbiAgICBoc2w6IHtcbiAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgbGFiZWxzOiAnaHNsJ1xuICAgIH0sXG4gICAgaHN2OiB7XG4gICAgICBjaGFubmVsczogMyxcbiAgICAgIGxhYmVsczogJ2hzdidcbiAgICB9LFxuICAgIGh3Yjoge1xuICAgICAgY2hhbm5lbHM6IDMsXG4gICAgICBsYWJlbHM6ICdod2InXG4gICAgfSxcbiAgICBjbXlrOiB7XG4gICAgICBjaGFubmVsczogNCxcbiAgICAgIGxhYmVsczogJ2NteWsnXG4gICAgfSxcbiAgICB4eXo6IHtcbiAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgbGFiZWxzOiAneHl6J1xuICAgIH0sXG4gICAgbGFiOiB7XG4gICAgICBjaGFubmVsczogMyxcbiAgICAgIGxhYmVsczogJ2xhYidcbiAgICB9LFxuICAgIGxjaDoge1xuICAgICAgY2hhbm5lbHM6IDMsXG4gICAgICBsYWJlbHM6ICdsY2gnXG4gICAgfSxcbiAgICBoZXg6IHtcbiAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgbGFiZWxzOiBbJ2hleCddXG4gICAgfSxcbiAgICBrZXl3b3JkOiB7XG4gICAgICBjaGFubmVsczogMSxcbiAgICAgIGxhYmVsczogWydrZXl3b3JkJ11cbiAgICB9LFxuICAgIGFuc2kxNjoge1xuICAgICAgY2hhbm5lbHM6IDEsXG4gICAgICBsYWJlbHM6IFsnYW5zaTE2J11cbiAgICB9LFxuICAgIGFuc2kyNTY6IHtcbiAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgbGFiZWxzOiBbJ2Fuc2kyNTYnXVxuICAgIH0sXG4gICAgaGNnOiB7XG4gICAgICBjaGFubmVsczogMyxcbiAgICAgIGxhYmVsczogWydoJywgJ2MnLCAnZyddXG4gICAgfSxcbiAgICBhcHBsZToge1xuICAgICAgY2hhbm5lbHM6IDMsXG4gICAgICBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXVxuICAgIH0sXG4gICAgZ3JheToge1xuICAgICAgY2hhbm5lbHM6IDEsXG4gICAgICBsYWJlbHM6IFsnZ3JheSddXG4gICAgfVxuICB9O1xuICB2YXIgY29udmVyc2lvbnMkMSA9IGNvbnZlcnQkMTsgLy8gSGlkZSAuY2hhbm5lbHMgYW5kIC5sYWJlbHMgcHJvcGVydGllc1xuXG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LmtleXMoY29udmVydCQxKSkge1xuICAgIGlmICghKCdjaGFubmVscycgaW4gY29udmVydCQxW21vZGVsXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBjaGFubmVscyBwcm9wZXJ0eTogJyArIG1vZGVsKTtcbiAgICB9XG5cbiAgICBpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0JDFbbW9kZWxdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNoYW5uZWwgbGFiZWxzIHByb3BlcnR5OiAnICsgbW9kZWwpO1xuICAgIH1cblxuICAgIGlmIChjb252ZXJ0JDFbbW9kZWxdLmxhYmVscy5sZW5ndGggIT09IGNvbnZlcnQkMVttb2RlbF0uY2hhbm5lbHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2hhbm5lbCBhbmQgbGFiZWwgY291bnRzIG1pc21hdGNoOiAnICsgbW9kZWwpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGNoYW5uZWxzLFxuICAgICAgbGFiZWxzXG4gICAgfSA9IGNvbnZlcnQkMVttb2RlbF07XG4gICAgZGVsZXRlIGNvbnZlcnQkMVttb2RlbF0uY2hhbm5lbHM7XG4gICAgZGVsZXRlIGNvbnZlcnQkMVttb2RlbF0ubGFiZWxzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0JDFbbW9kZWxdLCAnY2hhbm5lbHMnLCB7XG4gICAgICB2YWx1ZTogY2hhbm5lbHNcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydCQxW21vZGVsXSwgJ2xhYmVscycsIHtcbiAgICAgIHZhbHVlOiBsYWJlbHNcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnZlcnQkMS5yZ2IuaHNsID0gZnVuY3Rpb24gKHJnYikge1xuICAgIGNvbnN0IHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgY29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICBjb25zdCBiID0gcmdiWzJdIC8gMjU1O1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIGNvbnN0IGRlbHRhID0gbWF4IC0gbWluO1xuICAgIGxldCBoO1xuICAgIGxldCBzO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gMDtcbiAgICB9IGVsc2UgaWYgKHIgPT09IG1heCkge1xuICAgICAgaCA9IChnIC0gYikgLyBkZWx0YTtcbiAgICB9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgfSBlbHNlIGlmIChiID09PSBtYXgpIHtcbiAgICAgIGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuICAgIH1cblxuICAgIGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggKz0gMzYwO1xuICAgIH1cblxuICAgIGNvbnN0IGwgPSAobWluICsgbWF4KSAvIDI7XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIHMgPSAwO1xuICAgIH0gZWxzZSBpZiAobCA8PSAwLjUpIHtcbiAgICAgIHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoLCBzICogMTAwLCBsICogMTAwXTtcbiAgfTtcblxuICBjb252ZXJ0JDEucmdiLmhzdiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICBsZXQgcmRpZjtcbiAgICBsZXQgZ2RpZjtcbiAgICBsZXQgYmRpZjtcbiAgICBsZXQgaDtcbiAgICBsZXQgcztcbiAgICBjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuICAgIGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG4gICAgY29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcbiAgICBjb25zdCB2ID0gTWF0aC5tYXgociwgZywgYik7XG4gICAgY29uc3QgZGlmZiA9IHYgLSBNYXRoLm1pbihyLCBnLCBiKTtcblxuICAgIGNvbnN0IGRpZmZjID0gZnVuY3Rpb24gZGlmZmMoYykge1xuICAgICAgcmV0dXJuICh2IC0gYykgLyA2IC8gZGlmZiArIDEgLyAyO1xuICAgIH07XG5cbiAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgaCA9IDA7XG4gICAgICBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IGRpZmYgLyB2O1xuICAgICAgcmRpZiA9IGRpZmZjKHIpO1xuICAgICAgZ2RpZiA9IGRpZmZjKGcpO1xuICAgICAgYmRpZiA9IGRpZmZjKGIpO1xuXG4gICAgICBpZiAociA9PT0gdikge1xuICAgICAgICBoID0gYmRpZiAtIGdkaWY7XG4gICAgICB9IGVsc2UgaWYgKGcgPT09IHYpIHtcbiAgICAgICAgaCA9IDEgLyAzICsgcmRpZiAtIGJkaWY7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IHYpIHtcbiAgICAgICAgaCA9IDIgLyAzICsgZ2RpZiAtIHJkaWY7XG4gICAgICB9XG5cbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKGggPiAxKSB7XG4gICAgICAgIGggLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2ggKiAzNjAsIHMgKiAxMDAsIHYgKiAxMDBdO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5yZ2IuaHdiID0gZnVuY3Rpb24gKHJnYikge1xuICAgIGNvbnN0IHIgPSByZ2JbMF07XG4gICAgY29uc3QgZyA9IHJnYlsxXTtcbiAgICBsZXQgYiA9IHJnYlsyXTtcbiAgICBjb25zdCBoID0gY29udmVydCQxLnJnYi5oc2wocmdiKVswXTtcbiAgICBjb25zdCB3ID0gMSAvIDI1NSAqIE1hdGgubWluKHIsIE1hdGgubWluKGcsIGIpKTtcbiAgICBiID0gMSAtIDEgLyAyNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG4gICAgcmV0dXJuIFtoLCB3ICogMTAwLCBiICogMTAwXTtcbiAgfTtcblxuICBjb252ZXJ0JDEucmdiLmNteWsgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgY29uc3QgciA9IHJnYlswXSAvIDI1NTtcbiAgICBjb25zdCBnID0gcmdiWzFdIC8gMjU1O1xuICAgIGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG4gICAgY29uc3QgayA9IE1hdGgubWluKDEgLSByLCAxIC0gZywgMSAtIGIpO1xuICAgIGNvbnN0IGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcbiAgICBjb25zdCBtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgY29uc3QgeSA9ICgxIC0gYiAtIGspIC8gKDEgLSBrKSB8fCAwO1xuICAgIHJldHVybiBbYyAqIDEwMCwgbSAqIDEwMCwgeSAqIDEwMCwgayAqIDEwMF07XG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG4gICAgLypcbiAgICBcdFNlZSBodHRwczovL2VuLm0ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSNTcXVhcmVkX0V1Y2xpZGVhbl9kaXN0YW5jZVxuICAgICovXG4gICAgcmV0dXJuICh4WzBdIC0geVswXSkgKiogMiArICh4WzFdIC0geVsxXSkgKiogMiArICh4WzJdIC0geVsyXSkgKiogMjtcbiAgfVxuXG4gIGNvbnZlcnQkMS5yZ2Iua2V5d29yZCA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICBjb25zdCByZXZlcnNlZCA9IHJldmVyc2VLZXl3b3Jkc1tyZ2JdO1xuXG4gICAgaWYgKHJldmVyc2VkKSB7XG4gICAgICByZXR1cm4gcmV2ZXJzZWQ7XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBsZXQgY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuXG4gICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIE9iamVjdC5rZXlzKGNvbG9yTmFtZSQxKSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb2xvck5hbWUkMVtrZXl3b3JkXTsgLy8gQ29tcHV0ZSBjb21wYXJhdGl2ZSBkaXN0YW5jZVxuXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7IC8vIENoZWNrIGlmIGl0cyBsZXNzLCBpZiBzbyBzZXQgYXMgY2xvc2VzdFxuXG4gICAgICBpZiAoZGlzdGFuY2UgPCBjdXJyZW50Q2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgIGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgY3VycmVudENsb3Nlc3RLZXl3b3JkID0ga2V5d29yZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudENsb3Nlc3RLZXl3b3JkO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5rZXl3b3JkLnJnYiA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XG4gICAgcmV0dXJuIGNvbG9yTmFtZSQxW2tleXdvcmRdO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5yZ2IueHl6ID0gZnVuY3Rpb24gKHJnYikge1xuICAgIGxldCByID0gcmdiWzBdIC8gMjU1O1xuICAgIGxldCBnID0gcmdiWzFdIC8gMjU1O1xuICAgIGxldCBiID0gcmdiWzJdIC8gMjU1OyAvLyBBc3N1bWUgc1JHQlxuXG4gICAgciA9IHIgPiAwLjA0MDQ1ID8gKChyICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCA6IHIgLyAxMi45MjtcbiAgICBnID0gZyA+IDAuMDQwNDUgPyAoKGcgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40IDogZyAvIDEyLjkyO1xuICAgIGIgPSBiID4gMC4wNDA0NSA/ICgoYiArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQgOiBiIC8gMTIuOTI7XG4gICAgY29uc3QgeCA9IHIgKiAwLjQxMjQgKyBnICogMC4zNTc2ICsgYiAqIDAuMTgwNTtcbiAgICBjb25zdCB5ID0gciAqIDAuMjEyNiArIGcgKiAwLjcxNTIgKyBiICogMC4wNzIyO1xuICAgIGNvbnN0IHogPSByICogMC4wMTkzICsgZyAqIDAuMTE5MiArIGIgKiAwLjk1MDU7XG4gICAgcmV0dXJuIFt4ICogMTAwLCB5ICogMTAwLCB6ICogMTAwXTtcbiAgfTtcblxuICBjb252ZXJ0JDEucmdiLmxhYiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICBjb25zdCB4eXogPSBjb252ZXJ0JDEucmdiLnh5eihyZ2IpO1xuICAgIGxldCB4ID0geHl6WzBdO1xuICAgIGxldCB5ID0geHl6WzFdO1xuICAgIGxldCB6ID0geHl6WzJdO1xuICAgIHggLz0gOTUuMDQ3O1xuICAgIHkgLz0gMTAwO1xuICAgIHogLz0gMTA4Ljg4MztcbiAgICB4ID0geCA+IDAuMDA4ODU2ID8geCAqKiAoMSAvIDMpIDogNy43ODcgKiB4ICsgMTYgLyAxMTY7XG4gICAgeSA9IHkgPiAwLjAwODg1NiA/IHkgKiogKDEgLyAzKSA6IDcuNzg3ICogeSArIDE2IC8gMTE2O1xuICAgIHogPSB6ID4gMC4wMDg4NTYgPyB6ICoqICgxIC8gMykgOiA3Ljc4NyAqIHogKyAxNiAvIDExNjtcbiAgICBjb25zdCBsID0gMTE2ICogeSAtIDE2O1xuICAgIGNvbnN0IGEgPSA1MDAgKiAoeCAtIHkpO1xuICAgIGNvbnN0IGIgPSAyMDAgKiAoeSAtIHopO1xuICAgIHJldHVybiBbbCwgYSwgYl07XG4gIH07XG5cbiAgY29udmVydCQxLmhzbC5yZ2IgPSBmdW5jdGlvbiAoaHNsKSB7XG4gICAgY29uc3QgaCA9IGhzbFswXSAvIDM2MDtcbiAgICBjb25zdCBzID0gaHNsWzFdIC8gMTAwO1xuICAgIGNvbnN0IGwgPSBoc2xbMl0gLyAxMDA7XG4gICAgbGV0IHQyO1xuICAgIGxldCB0MztcbiAgICBsZXQgdmFsO1xuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHZhbCA9IGwgKiAyNTU7XG4gICAgICByZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuICAgIH1cblxuICAgIGlmIChsIDwgMC41KSB7XG4gICAgICB0MiA9IGwgKiAoMSArIHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiA9IGwgKyBzIC0gbCAqIHM7XG4gICAgfVxuXG4gICAgY29uc3QgdDEgPSAyICogbCAtIHQyO1xuICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICB0MyA9IGggKyAxIC8gMyAqIC0oaSAtIDEpO1xuXG4gICAgICBpZiAodDMgPCAwKSB7XG4gICAgICAgIHQzKys7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MyA+IDEpIHtcbiAgICAgICAgdDMtLTtcbiAgICAgIH1cblxuICAgICAgaWYgKDYgKiB0MyA8IDEpIHtcbiAgICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG4gICAgICB9IGVsc2UgaWYgKDIgKiB0MyA8IDEpIHtcbiAgICAgICAgdmFsID0gdDI7XG4gICAgICB9IGVsc2UgaWYgKDMgKiB0MyA8IDIpIHtcbiAgICAgICAgdmFsID0gdDEgKyAodDIgLSB0MSkgKiAoMiAvIDMgLSB0MykgKiA2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gdDE7XG4gICAgICB9XG5cbiAgICAgIHJnYltpXSA9IHZhbCAqIDI1NTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmdiO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5oc2wuaHN2ID0gZnVuY3Rpb24gKGhzbCkge1xuICAgIGNvbnN0IGggPSBoc2xbMF07XG4gICAgbGV0IHMgPSBoc2xbMV0gLyAxMDA7XG4gICAgbGV0IGwgPSBoc2xbMl0gLyAxMDA7XG4gICAgbGV0IHNtaW4gPSBzO1xuICAgIGNvbnN0IGxtaW4gPSBNYXRoLm1heChsLCAwLjAxKTtcbiAgICBsICo9IDI7XG4gICAgcyAqPSBsIDw9IDEgPyBsIDogMiAtIGw7XG4gICAgc21pbiAqPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG4gICAgY29uc3QgdiA9IChsICsgcykgLyAyO1xuICAgIGNvbnN0IHN2ID0gbCA9PT0gMCA/IDIgKiBzbWluIC8gKGxtaW4gKyBzbWluKSA6IDIgKiBzIC8gKGwgKyBzKTtcbiAgICByZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbiAgfTtcblxuICBjb252ZXJ0JDEuaHN2LnJnYiA9IGZ1bmN0aW9uIChoc3YpIHtcbiAgICBjb25zdCBoID0gaHN2WzBdIC8gNjA7XG4gICAgY29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcbiAgICBsZXQgdiA9IGhzdlsyXSAvIDEwMDtcbiAgICBjb25zdCBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuICAgIGNvbnN0IGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcbiAgICBjb25zdCBwID0gMjU1ICogdiAqICgxIC0gcyk7XG4gICAgY29uc3QgcSA9IDI1NSAqIHYgKiAoMSAtIHMgKiBmKTtcbiAgICBjb25zdCB0ID0gMjU1ICogdiAqICgxIC0gcyAqICgxIC0gZikpO1xuICAgIHYgKj0gMjU1O1xuXG4gICAgc3dpdGNoIChoaSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3YsIHQsIHBdO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBbcSwgdiwgcF07XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIFtwLCB2LCB0XTtcblxuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gW3AsIHEsIHZdO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiBbdCwgcCwgdl07XG5cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIFt2LCBwLCBxXTtcbiAgICB9XG4gIH07XG5cbiAgY29udmVydCQxLmhzdi5oc2wgPSBmdW5jdGlvbiAoaHN2KSB7XG4gICAgY29uc3QgaCA9IGhzdlswXTtcbiAgICBjb25zdCBzID0gaHN2WzFdIC8gMTAwO1xuICAgIGNvbnN0IHYgPSBoc3ZbMl0gLyAxMDA7XG4gICAgY29uc3Qgdm1pbiA9IE1hdGgubWF4KHYsIDAuMDEpO1xuICAgIGxldCBzbDtcbiAgICBsZXQgbDtcbiAgICBsID0gKDIgLSBzKSAqIHY7XG4gICAgY29uc3QgbG1pbiA9ICgyIC0gcykgKiB2bWluO1xuICAgIHNsID0gcyAqIHZtaW47XG4gICAgc2wgLz0gbG1pbiA8PSAxID8gbG1pbiA6IDIgLSBsbWluO1xuICAgIHNsID0gc2wgfHwgMDtcbiAgICBsIC89IDI7XG4gICAgcmV0dXJuIFtoLCBzbCAqIDEwMCwgbCAqIDEwMF07XG4gIH07IC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuXG5cbiAgY29udmVydCQxLmh3Yi5yZ2IgPSBmdW5jdGlvbiAoaHdiKSB7XG4gICAgY29uc3QgaCA9IGh3YlswXSAvIDM2MDtcbiAgICBsZXQgd2ggPSBod2JbMV0gLyAxMDA7XG4gICAgbGV0IGJsID0gaHdiWzJdIC8gMTAwO1xuICAgIGNvbnN0IHJhdGlvID0gd2ggKyBibDtcbiAgICBsZXQgZjsgLy8gV2ggKyBibCBjYW50IGJlID4gMVxuXG4gICAgaWYgKHJhdGlvID4gMSkge1xuICAgICAgd2ggLz0gcmF0aW87XG4gICAgICBibCAvPSByYXRpbztcbiAgICB9XG5cbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcig2ICogaCk7XG4gICAgY29uc3QgdiA9IDEgLSBibDtcbiAgICBmID0gNiAqIGggLSBpO1xuXG4gICAgaWYgKChpICYgMHgwMSkgIT09IDApIHtcbiAgICAgIGYgPSAxIC0gZjtcbiAgICB9XG5cbiAgICBjb25zdCBuID0gd2ggKyBmICogKHYgLSB3aCk7IC8vIExpbmVhciBpbnRlcnBvbGF0aW9uXG5cbiAgICBsZXQgcjtcbiAgICBsZXQgZztcbiAgICBsZXQgYjtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cy1wZXItbGluZSxuby1tdWx0aS1zcGFjZXMgKi9cblxuICAgIHN3aXRjaCAoaSkge1xuICAgICAgZGVmYXVsdDpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgciA9IHY7XG4gICAgICAgIGcgPSBuO1xuICAgICAgICBiID0gd2g7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHIgPSBuO1xuICAgICAgICBnID0gdjtcbiAgICAgICAgYiA9IHdoO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByID0gd2g7XG4gICAgICAgIGcgPSB2O1xuICAgICAgICBiID0gbjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgciA9IHdoO1xuICAgICAgICBnID0gbjtcbiAgICAgICAgYiA9IHY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHIgPSBuO1xuICAgICAgICBnID0gd2g7XG4gICAgICAgIGIgPSB2O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA1OlxuICAgICAgICByID0gdjtcbiAgICAgICAgZyA9IHdoO1xuICAgICAgICBiID0gbjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmUsbm8tbXVsdGktc3BhY2VzICovXG5cblxuICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gIH07XG5cbiAgY29udmVydCQxLmNteWsucmdiID0gZnVuY3Rpb24gKGNteWspIHtcbiAgICBjb25zdCBjID0gY215a1swXSAvIDEwMDtcbiAgICBjb25zdCBtID0gY215a1sxXSAvIDEwMDtcbiAgICBjb25zdCB5ID0gY215a1syXSAvIDEwMDtcbiAgICBjb25zdCBrID0gY215a1szXSAvIDEwMDtcbiAgICBjb25zdCByID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG4gICAgY29uc3QgZyA9IDEgLSBNYXRoLm1pbigxLCBtICogKDEgLSBrKSArIGspO1xuICAgIGNvbnN0IGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xuICB9O1xuXG4gIGNvbnZlcnQkMS54eXoucmdiID0gZnVuY3Rpb24gKHh5eikge1xuICAgIGNvbnN0IHggPSB4eXpbMF0gLyAxMDA7XG4gICAgY29uc3QgeSA9IHh5elsxXSAvIDEwMDtcbiAgICBjb25zdCB6ID0geHl6WzJdIC8gMTAwO1xuICAgIGxldCByO1xuICAgIGxldCBnO1xuICAgIGxldCBiO1xuICAgIHIgPSB4ICogMy4yNDA2ICsgeSAqIC0xLjUzNzIgKyB6ICogLTAuNDk4NjtcbiAgICBnID0geCAqIC0wLjk2ODkgKyB5ICogMS44NzU4ICsgeiAqIDAuMDQxNTtcbiAgICBiID0geCAqIDAuMDU1NyArIHkgKiAtMC4yMDQwICsgeiAqIDEuMDU3MDsgLy8gQXNzdW1lIHNSR0JcblxuICAgIHIgPSByID4gMC4wMDMxMzA4ID8gMS4wNTUgKiByICoqICgxLjAgLyAyLjQpIC0gMC4wNTUgOiByICogMTIuOTI7XG4gICAgZyA9IGcgPiAwLjAwMzEzMDggPyAxLjA1NSAqIGcgKiogKDEuMCAvIDIuNCkgLSAwLjA1NSA6IGcgKiAxMi45MjtcbiAgICBiID0gYiA+IDAuMDAzMTMwOCA/IDEuMDU1ICogYiAqKiAoMS4wIC8gMi40KSAtIDAuMDU1IDogYiAqIDEyLjkyO1xuICAgIHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG4gICAgZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcbiAgICBiID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgYiksIDEpO1xuICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gIH07XG5cbiAgY29udmVydCQxLnh5ei5sYWIgPSBmdW5jdGlvbiAoeHl6KSB7XG4gICAgbGV0IHggPSB4eXpbMF07XG4gICAgbGV0IHkgPSB4eXpbMV07XG4gICAgbGV0IHogPSB4eXpbMl07XG4gICAgeCAvPSA5NS4wNDc7XG4gICAgeSAvPSAxMDA7XG4gICAgeiAvPSAxMDguODgzO1xuICAgIHggPSB4ID4gMC4wMDg4NTYgPyB4ICoqICgxIC8gMykgOiA3Ljc4NyAqIHggKyAxNiAvIDExNjtcbiAgICB5ID0geSA+IDAuMDA4ODU2ID8geSAqKiAoMSAvIDMpIDogNy43ODcgKiB5ICsgMTYgLyAxMTY7XG4gICAgeiA9IHogPiAwLjAwODg1NiA/IHogKiogKDEgLyAzKSA6IDcuNzg3ICogeiArIDE2IC8gMTE2O1xuICAgIGNvbnN0IGwgPSAxMTYgKiB5IC0gMTY7XG4gICAgY29uc3QgYSA9IDUwMCAqICh4IC0geSk7XG4gICAgY29uc3QgYiA9IDIwMCAqICh5IC0geik7XG4gICAgcmV0dXJuIFtsLCBhLCBiXTtcbiAgfTtcblxuICBjb252ZXJ0JDEubGFiLnh5eiA9IGZ1bmN0aW9uIChsYWIpIHtcbiAgICBjb25zdCBsID0gbGFiWzBdO1xuICAgIGNvbnN0IGEgPSBsYWJbMV07XG4gICAgY29uc3QgYiA9IGxhYlsyXTtcbiAgICBsZXQgeDtcbiAgICBsZXQgeTtcbiAgICBsZXQgejtcbiAgICB5ID0gKGwgKyAxNikgLyAxMTY7XG4gICAgeCA9IGEgLyA1MDAgKyB5O1xuICAgIHogPSB5IC0gYiAvIDIwMDtcbiAgICBjb25zdCB5MiA9IHkgKiogMztcbiAgICBjb25zdCB4MiA9IHggKiogMztcbiAgICBjb25zdCB6MiA9IHogKiogMztcbiAgICB5ID0geTIgPiAwLjAwODg1NiA/IHkyIDogKHkgLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICB4ID0geDIgPiAwLjAwODg1NiA/IHgyIDogKHggLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICB6ID0gejIgPiAwLjAwODg1NiA/IHoyIDogKHogLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICB4ICo9IDk1LjA0NztcbiAgICB5ICo9IDEwMDtcbiAgICB6ICo9IDEwOC44ODM7XG4gICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgfTtcblxuICBjb252ZXJ0JDEubGFiLmxjaCA9IGZ1bmN0aW9uIChsYWIpIHtcbiAgICBjb25zdCBsID0gbGFiWzBdO1xuICAgIGNvbnN0IGEgPSBsYWJbMV07XG4gICAgY29uc3QgYiA9IGxhYlsyXTtcbiAgICBsZXQgaDtcbiAgICBjb25zdCBociA9IE1hdGguYXRhbjIoYiwgYSk7XG4gICAgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG5cbiAgICBpZiAoaCA8IDApIHtcbiAgICAgIGggKz0gMzYwO1xuICAgIH1cblxuICAgIGNvbnN0IGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgcmV0dXJuIFtsLCBjLCBoXTtcbiAgfTtcblxuICBjb252ZXJ0JDEubGNoLmxhYiA9IGZ1bmN0aW9uIChsY2gpIHtcbiAgICBjb25zdCBsID0gbGNoWzBdO1xuICAgIGNvbnN0IGMgPSBsY2hbMV07XG4gICAgY29uc3QgaCA9IGxjaFsyXTtcbiAgICBjb25zdCBociA9IGggLyAzNjAgKiAyICogTWF0aC5QSTtcbiAgICBjb25zdCBhID0gYyAqIE1hdGguY29zKGhyKTtcbiAgICBjb25zdCBiID0gYyAqIE1hdGguc2luKGhyKTtcbiAgICByZXR1cm4gW2wsIGEsIGJdO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5yZ2IuYW5zaTE2ID0gZnVuY3Rpb24gKGFyZ3MsIHNhdHVyYXRpb24gPSBudWxsKSB7XG4gICAgY29uc3QgW3IsIGcsIGJdID0gYXJncztcbiAgICBsZXQgdmFsdWUgPSBzYXR1cmF0aW9uID09PSBudWxsID8gY29udmVydCQxLnJnYi5oc3YoYXJncylbMl0gOiBzYXR1cmF0aW9uOyAvLyBIc3YgLT4gYW5zaTE2IG9wdGltaXphdGlvblxuXG4gICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gNTApO1xuXG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gMzA7XG4gICAgfVxuXG4gICAgbGV0IGFuc2kgPSAzMCArIChNYXRoLnJvdW5kKGIgLyAyNTUpIDw8IDIgfCBNYXRoLnJvdW5kKGcgLyAyNTUpIDw8IDEgfCBNYXRoLnJvdW5kKHIgLyAyNTUpKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gMikge1xuICAgICAgYW5zaSArPSA2MDtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5zaTtcbiAgfTtcblxuICBjb252ZXJ0JDEuaHN2LmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgLy8gT3B0aW1pemF0aW9uIGhlcmU7IHdlIGFscmVhZHkga25vdyB0aGUgdmFsdWUgYW5kIGRvbid0IG5lZWQgdG8gZ2V0XG4gICAgLy8gaXQgY29udmVydGVkIGZvciB1cy5cbiAgICByZXR1cm4gY29udmVydCQxLnJnYi5hbnNpMTYoY29udmVydCQxLmhzdi5yZ2IoYXJncyksIGFyZ3NbMl0pO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgY29uc3QgciA9IGFyZ3NbMF07XG4gICAgY29uc3QgZyA9IGFyZ3NbMV07XG4gICAgY29uc3QgYiA9IGFyZ3NbMl07IC8vIFdlIHVzZSB0aGUgZXh0ZW5kZWQgZ3JleXNjYWxlIHBhbGV0dGUgaGVyZSwgd2l0aCB0aGUgZXhjZXB0aW9uIG9mXG4gICAgLy8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuXG5cbiAgICBpZiAociA9PT0gZyAmJiBnID09PSBiKSB7XG4gICAgICBpZiAociA8IDgpIHtcbiAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgfVxuXG4gICAgICBpZiAociA+IDI0OCkge1xuICAgICAgICByZXR1cm4gMjMxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgociAtIDgpIC8gMjQ3ICogMjQpICsgMjMyO1xuICAgIH1cblxuICAgIGNvbnN0IGFuc2kgPSAxNiArIDM2ICogTWF0aC5yb3VuZChyIC8gMjU1ICogNSkgKyA2ICogTWF0aC5yb3VuZChnIC8gMjU1ICogNSkgKyBNYXRoLnJvdW5kKGIgLyAyNTUgKiA1KTtcbiAgICByZXR1cm4gYW5zaTtcbiAgfTtcblxuICBjb252ZXJ0JDEuYW5zaTE2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgbGV0IGNvbG9yID0gYXJncyAlIDEwOyAvLyBIYW5kbGUgZ3JleXNjYWxlXG5cbiAgICBpZiAoY29sb3IgPT09IDAgfHwgY29sb3IgPT09IDcpIHtcbiAgICAgIGlmIChhcmdzID4gNTApIHtcbiAgICAgICAgY29sb3IgKz0gMy41O1xuICAgICAgfVxuXG4gICAgICBjb2xvciA9IGNvbG9yIC8gMTAuNSAqIDI1NTtcbiAgICAgIHJldHVybiBbY29sb3IsIGNvbG9yLCBjb2xvcl07XG4gICAgfVxuXG4gICAgY29uc3QgbXVsdCA9ICh+fihhcmdzID4gNTApICsgMSkgKiAwLjU7XG4gICAgY29uc3QgciA9IChjb2xvciAmIDEpICogbXVsdCAqIDI1NTtcbiAgICBjb25zdCBnID0gKGNvbG9yID4+IDEgJiAxKSAqIG11bHQgKiAyNTU7XG4gICAgY29uc3QgYiA9IChjb2xvciA+PiAyICYgMSkgKiBtdWx0ICogMjU1O1xuICAgIHJldHVybiBbciwgZywgYl07XG4gIH07XG5cbiAgY29udmVydCQxLmFuc2kyNTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAvLyBIYW5kbGUgZ3JleXNjYWxlXG4gICAgaWYgKGFyZ3MgPj0gMjMyKSB7XG4gICAgICBjb25zdCBjID0gKGFyZ3MgLSAyMzIpICogMTAgKyA4O1xuICAgICAgcmV0dXJuIFtjLCBjLCBjXTtcbiAgICB9XG5cbiAgICBhcmdzIC09IDE2O1xuICAgIGxldCByZW07XG4gICAgY29uc3QgciA9IE1hdGguZmxvb3IoYXJncyAvIDM2KSAvIDUgKiAyNTU7XG4gICAgY29uc3QgZyA9IE1hdGguZmxvb3IoKHJlbSA9IGFyZ3MgJSAzNikgLyA2KSAvIDUgKiAyNTU7XG4gICAgY29uc3QgYiA9IHJlbSAlIDYgLyA1ICogMjU1O1xuICAgIHJldHVybiBbciwgZywgYl07XG4gIH07XG5cbiAgY29udmVydCQxLnJnYi5oZXggPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGNvbnN0IGludGVnZXIgPSAoKE1hdGgucm91bmQoYXJnc1swXSkgJiAweEZGKSA8PCAxNikgKyAoKE1hdGgucm91bmQoYXJnc1sxXSkgJiAweEZGKSA8PCA4KSArIChNYXRoLnJvdW5kKGFyZ3NbMl0pICYgMHhGRik7XG4gICAgY29uc3Qgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5oZXgucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBjb25zdCBtYXRjaCA9IGFyZ3MudG9TdHJpbmcoMTYpLm1hdGNoKC9bYS1mMC05XXs2fXxbYS1mMC05XXszfS9pKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgfVxuXG4gICAgbGV0IGNvbG9yU3RyaW5nID0gbWF0Y2hbMF07XG5cbiAgICBpZiAobWF0Y2hbMF0ubGVuZ3RoID09PSAzKSB7XG4gICAgICBjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnNwbGl0KCcnKS5tYXAoY2hhciA9PiB7XG4gICAgICAgIHJldHVybiBjaGFyICsgY2hhcjtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cblxuICAgIGNvbnN0IGludGVnZXIgPSBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuICAgIGNvbnN0IHIgPSBpbnRlZ2VyID4+IDE2ICYgMHhGRjtcbiAgICBjb25zdCBnID0gaW50ZWdlciA+PiA4ICYgMHhGRjtcbiAgICBjb25zdCBiID0gaW50ZWdlciAmIDB4RkY7XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfTtcblxuICBjb252ZXJ0JDEucmdiLmhjZyA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICBjb25zdCByID0gcmdiWzBdIC8gMjU1O1xuICAgIGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG4gICAgY29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heChNYXRoLm1heChyLCBnKSwgYik7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4oTWF0aC5taW4ociwgZyksIGIpO1xuICAgIGNvbnN0IGNocm9tYSA9IG1heCAtIG1pbjtcbiAgICBsZXQgZ3JheXNjYWxlO1xuICAgIGxldCBodWU7XG5cbiAgICBpZiAoY2hyb21hIDwgMSkge1xuICAgICAgZ3JheXNjYWxlID0gbWluIC8gKDEgLSBjaHJvbWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBncmF5c2NhbGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChjaHJvbWEgPD0gMCkge1xuICAgICAgaHVlID0gMDtcbiAgICB9IGVsc2UgaWYgKG1heCA9PT0gcikge1xuICAgICAgaHVlID0gKGcgLSBiKSAvIGNocm9tYSAlIDY7XG4gICAgfSBlbHNlIGlmIChtYXggPT09IGcpIHtcbiAgICAgIGh1ZSA9IDIgKyAoYiAtIHIpIC8gY2hyb21hO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWUgPSA0ICsgKHIgLSBnKSAvIGNocm9tYTtcbiAgICB9XG5cbiAgICBodWUgLz0gNjtcbiAgICBodWUgJT0gMTtcbiAgICByZXR1cm4gW2h1ZSAqIDM2MCwgY2hyb21hICogMTAwLCBncmF5c2NhbGUgKiAxMDBdO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5oc2wuaGNnID0gZnVuY3Rpb24gKGhzbCkge1xuICAgIGNvbnN0IHMgPSBoc2xbMV0gLyAxMDA7XG4gICAgY29uc3QgbCA9IGhzbFsyXSAvIDEwMDtcbiAgICBjb25zdCBjID0gbCA8IDAuNSA/IDIuMCAqIHMgKiBsIDogMi4wICogcyAqICgxLjAgLSBsKTtcbiAgICBsZXQgZiA9IDA7XG5cbiAgICBpZiAoYyA8IDEuMCkge1xuICAgICAgZiA9IChsIC0gMC41ICogYykgLyAoMS4wIC0gYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoc2xbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5oc3YuaGNnID0gZnVuY3Rpb24gKGhzdikge1xuICAgIGNvbnN0IHMgPSBoc3ZbMV0gLyAxMDA7XG4gICAgY29uc3QgdiA9IGhzdlsyXSAvIDEwMDtcbiAgICBjb25zdCBjID0gcyAqIHY7XG4gICAgbGV0IGYgPSAwO1xuXG4gICAgaWYgKGMgPCAxLjApIHtcbiAgICAgIGYgPSAodiAtIGMpIC8gKDEgLSBjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2hzdlswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG4gIH07XG5cbiAgY29udmVydCQxLmhjZy5yZ2IgPSBmdW5jdGlvbiAoaGNnKSB7XG4gICAgY29uc3QgaCA9IGhjZ1swXSAvIDM2MDtcbiAgICBjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuICAgIGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG5cbiAgICBpZiAoYyA9PT0gMC4wKSB7XG4gICAgICByZXR1cm4gW2cgKiAyNTUsIGcgKiAyNTUsIGcgKiAyNTVdO1xuICAgIH1cblxuICAgIGNvbnN0IHB1cmUgPSBbMCwgMCwgMF07XG4gICAgY29uc3QgaGkgPSBoICUgMSAqIDY7XG4gICAgY29uc3QgdiA9IGhpICUgMTtcbiAgICBjb25zdCB3ID0gMSAtIHY7XG4gICAgbGV0IG1nID0gMDtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuXG4gICAgc3dpdGNoIChNYXRoLmZsb29yKGhpKSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBwdXJlWzBdID0gMTtcbiAgICAgICAgcHVyZVsxXSA9IHY7XG4gICAgICAgIHB1cmVbMl0gPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOlxuICAgICAgICBwdXJlWzBdID0gdztcbiAgICAgICAgcHVyZVsxXSA9IDE7XG4gICAgICAgIHB1cmVbMl0gPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBwdXJlWzBdID0gMDtcbiAgICAgICAgcHVyZVsxXSA9IDE7XG4gICAgICAgIHB1cmVbMl0gPSB2O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICBwdXJlWzBdID0gMDtcbiAgICAgICAgcHVyZVsxXSA9IHc7XG4gICAgICAgIHB1cmVbMl0gPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA0OlxuICAgICAgICBwdXJlWzBdID0gdjtcbiAgICAgICAgcHVyZVsxXSA9IDA7XG4gICAgICAgIHB1cmVbMl0gPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcHVyZVswXSA9IDE7XG4gICAgICAgIHB1cmVbMV0gPSAwO1xuICAgICAgICBwdXJlWzJdID0gdztcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuXG5cbiAgICBtZyA9ICgxLjAgLSBjKSAqIGc7XG4gICAgcmV0dXJuIFsoYyAqIHB1cmVbMF0gKyBtZykgKiAyNTUsIChjICogcHVyZVsxXSArIG1nKSAqIDI1NSwgKGMgKiBwdXJlWzJdICsgbWcpICogMjU1XTtcbiAgfTtcblxuICBjb252ZXJ0JDEuaGNnLmhzdiA9IGZ1bmN0aW9uIChoY2cpIHtcbiAgICBjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuICAgIGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG4gICAgY29uc3QgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuICAgIGxldCBmID0gMDtcblxuICAgIGlmICh2ID4gMC4wKSB7XG4gICAgICBmID0gYyAvIHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtoY2dbMF0sIGYgKiAxMDAsIHYgKiAxMDBdO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5oY2cuaHNsID0gZnVuY3Rpb24gKGhjZykge1xuICAgIGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG4gICAgY29uc3QgZyA9IGhjZ1syXSAvIDEwMDtcbiAgICBjb25zdCBsID0gZyAqICgxLjAgLSBjKSArIDAuNSAqIGM7XG4gICAgbGV0IHMgPSAwO1xuXG4gICAgaWYgKGwgPiAwLjAgJiYgbCA8IDAuNSkge1xuICAgICAgcyA9IGMgLyAoMiAqIGwpO1xuICAgIH0gZWxzZSBpZiAobCA+PSAwLjUgJiYgbCA8IDEuMCkge1xuICAgICAgcyA9IGMgLyAoMiAqICgxIC0gbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBbaGNnWzBdLCBzICogMTAwLCBsICogMTAwXTtcbiAgfTtcblxuICBjb252ZXJ0JDEuaGNnLmh3YiA9IGZ1bmN0aW9uIChoY2cpIHtcbiAgICBjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuICAgIGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG4gICAgY29uc3QgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuICAgIHJldHVybiBbaGNnWzBdLCAodiAtIGMpICogMTAwLCAoMSAtIHYpICogMTAwXTtcbiAgfTtcblxuICBjb252ZXJ0JDEuaHdiLmhjZyA9IGZ1bmN0aW9uIChod2IpIHtcbiAgICBjb25zdCB3ID0gaHdiWzFdIC8gMTAwO1xuICAgIGNvbnN0IGIgPSBod2JbMl0gLyAxMDA7XG4gICAgY29uc3QgdiA9IDEgLSBiO1xuICAgIGNvbnN0IGMgPSB2IC0gdztcbiAgICBsZXQgZyA9IDA7XG5cbiAgICBpZiAoYyA8IDEpIHtcbiAgICAgIGcgPSAodiAtIGMpIC8gKDEgLSBjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2h3YlswXSwgYyAqIDEwMCwgZyAqIDEwMF07XG4gIH07XG5cbiAgY29udmVydCQxLmFwcGxlLnJnYiA9IGZ1bmN0aW9uIChhcHBsZSkge1xuICAgIHJldHVybiBbYXBwbGVbMF0gLyA2NTUzNSAqIDI1NSwgYXBwbGVbMV0gLyA2NTUzNSAqIDI1NSwgYXBwbGVbMl0gLyA2NTUzNSAqIDI1NV07XG4gIH07XG5cbiAgY29udmVydCQxLnJnYi5hcHBsZSA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICByZXR1cm4gW3JnYlswXSAvIDI1NSAqIDY1NTM1LCByZ2JbMV0gLyAyNTUgKiA2NTUzNSwgcmdiWzJdIC8gMjU1ICogNjU1MzVdO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5ncmF5LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIFthcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1XTtcbiAgfTtcblxuICBjb252ZXJ0JDEuZ3JheS5oc2wgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiBbMCwgMCwgYXJnc1swXV07XG4gIH07XG5cbiAgY29udmVydCQxLmdyYXkuaHN2ID0gY29udmVydCQxLmdyYXkuaHNsO1xuXG4gIGNvbnZlcnQkMS5ncmF5Lmh3YiA9IGZ1bmN0aW9uIChncmF5KSB7XG4gICAgcmV0dXJuIFswLCAxMDAsIGdyYXlbMF1dO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5ncmF5LmNteWsgPSBmdW5jdGlvbiAoZ3JheSkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgZ3JheVswXV07XG4gIH07XG5cbiAgY29udmVydCQxLmdyYXkubGFiID0gZnVuY3Rpb24gKGdyYXkpIHtcbiAgICByZXR1cm4gW2dyYXlbMF0sIDAsIDBdO1xuICB9O1xuXG4gIGNvbnZlcnQkMS5ncmF5LmhleCA9IGZ1bmN0aW9uIChncmF5KSB7XG4gICAgY29uc3QgdmFsID0gTWF0aC5yb3VuZChncmF5WzBdIC8gMTAwICogMjU1KSAmIDB4RkY7XG4gICAgY29uc3QgaW50ZWdlciA9ICh2YWwgPDwgMTYpICsgKHZhbCA8PCA4KSArIHZhbDtcbiAgICBjb25zdCBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiAnMDAwMDAwJy5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCkgKyBzdHJpbmc7XG4gIH07XG5cbiAgY29udmVydCQxLnJnYi5ncmF5ID0gZnVuY3Rpb24gKHJnYikge1xuICAgIGNvbnN0IHZhbCA9IChyZ2JbMF0gKyByZ2JbMV0gKyByZ2JbMl0pIC8gMztcbiAgICByZXR1cm4gW3ZhbCAvIDI1NSAqIDEwMF07XG4gIH07XG5cbiAgLypcbiAgXHRUaGlzIGZ1bmN0aW9uIHJvdXRlcyBhIG1vZGVsIHRvIGFsbCBvdGhlciBtb2RlbHMuXG5cbiAgXHRhbGwgZnVuY3Rpb25zIHRoYXQgYXJlIHJvdXRlZCBoYXZlIGEgcHJvcGVydHkgYC5jb252ZXJzaW9uYCBhdHRhY2hlZFxuICBcdHRvIHRoZSByZXR1cm5lZCBzeW50aGV0aWMgZnVuY3Rpb24uIFRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXlcbiAgXHRvZiBzdHJpbmdzLCBlYWNoIHdpdGggdGhlIHN0ZXBzIGluIGJldHdlZW4gdGhlICdmcm9tJyBhbmQgJ3RvJ1xuICBcdGNvbG9yIG1vZGVscyAoaW5jbHVzaXZlKS5cblxuICBcdGNvbnZlcnNpb25zIHRoYXQgYXJlIG5vdCBwb3NzaWJsZSBzaW1wbHkgYXJlIG5vdCBpbmNsdWRlZC5cbiAgKi9cblxuICBmdW5jdGlvbiBidWlsZEdyYXBoJDEoKSB7XG4gICAgY29uc3QgZ3JhcGggPSB7fTsgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL29iamVjdC1rZXlzLXZzLWZvci1pbi13aXRoLWNsb3N1cmUvM1xuXG4gICAgY29uc3QgbW9kZWxzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMkMSk7XG5cbiAgICBmb3IgKGxldCBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBncmFwaFttb2RlbHNbaV1dID0ge1xuICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS8xLXZzLWluZmluaXR5XG4gICAgICAgIC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuICAgICAgICBkaXN0YW5jZTogLTEsXG4gICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH0gLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlYWR0aC1maXJzdF9zZWFyY2hcblxuXG4gIGZ1bmN0aW9uIGRlcml2ZUJGUyQxKGZyb21Nb2RlbCkge1xuICAgIGNvbnN0IGdyYXBoID0gYnVpbGRHcmFwaCQxKCk7XG4gICAgY29uc3QgcXVldWUgPSBbZnJvbU1vZGVsXTsgLy8gVW5zaGlmdCAtPiBxdWV1ZSAtPiBwb3BcblxuICAgIGdyYXBoW2Zyb21Nb2RlbF0uZGlzdGFuY2UgPSAwO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHF1ZXVlLnBvcCgpO1xuICAgICAgY29uc3QgYWRqYWNlbnRzID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMkMVtjdXJyZW50XSk7XG5cbiAgICAgIGZvciAobGV0IGxlbiA9IGFkamFjZW50cy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWRqYWNlbnQgPSBhZGphY2VudHNbaV07XG4gICAgICAgIGNvbnN0IG5vZGUgPSBncmFwaFthZGphY2VudF07XG5cbiAgICAgICAgaWYgKG5vZGUuZGlzdGFuY2UgPT09IC0xKSB7XG4gICAgICAgICAgbm9kZS5kaXN0YW5jZSA9IGdyYXBoW2N1cnJlbnRdLmRpc3RhbmNlICsgMTtcbiAgICAgICAgICBub2RlLnBhcmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgcXVldWUudW5zaGlmdChhZGphY2VudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5rJDEoZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHJldHVybiB0byhmcm9tKGFyZ3MpKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcENvbnZlcnNpb24kMSh0b01vZGVsLCBncmFwaCkge1xuICAgIGNvbnN0IHBhdGggPSBbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50LCB0b01vZGVsXTtcbiAgICBsZXQgZm4gPSBjb252ZXJzaW9ucyQxW2dyYXBoW3RvTW9kZWxdLnBhcmVudF1bdG9Nb2RlbF07XG4gICAgbGV0IGN1ciA9IGdyYXBoW3RvTW9kZWxdLnBhcmVudDtcblxuICAgIHdoaWxlIChncmFwaFtjdXJdLnBhcmVudCkge1xuICAgICAgcGF0aC51bnNoaWZ0KGdyYXBoW2N1cl0ucGFyZW50KTtcbiAgICAgIGZuID0gbGluayQxKGNvbnZlcnNpb25zJDFbZ3JhcGhbY3VyXS5wYXJlbnRdW2N1cl0sIGZuKTtcbiAgICAgIGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuICAgIH1cblxuICAgIGZuLmNvbnZlcnNpb24gPSBwYXRoO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciByb3V0ZSQxID0gZnVuY3Rpb24gcm91dGUoZnJvbU1vZGVsKSB7XG4gICAgY29uc3QgZ3JhcGggPSBkZXJpdmVCRlMkMShmcm9tTW9kZWwpO1xuICAgIGNvbnN0IGNvbnZlcnNpb24gPSB7fTtcbiAgICBjb25zdCBtb2RlbHMgPSBPYmplY3Qua2V5cyhncmFwaCk7XG5cbiAgICBmb3IgKGxldCBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB0b01vZGVsID0gbW9kZWxzW2ldO1xuICAgICAgY29uc3Qgbm9kZSA9IGdyYXBoW3RvTW9kZWxdO1xuXG4gICAgICBpZiAobm9kZS5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gTm8gcG9zc2libGUgY29udmVyc2lvbiwgb3IgdGhpcyBub2RlIGlzIHRoZSBzb3VyY2UgbW9kZWwuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb252ZXJzaW9uW3RvTW9kZWxdID0gd3JhcENvbnZlcnNpb24kMSh0b01vZGVsLCBncmFwaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnNpb247XG4gIH07XG5cbiAgY29uc3QgY29udmVydCQyID0ge307XG4gIGNvbnN0IG1vZGVscyQxID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMkMSk7XG5cbiAgZnVuY3Rpb24gd3JhcFJhdyQxKGZuKSB7XG4gICAgY29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24gd3JhcHBlZEZuKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGFyZzAgPSBhcmdzWzBdO1xuXG4gICAgICBpZiAoYXJnMCA9PT0gdW5kZWZpbmVkIHx8IGFyZzAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFyZzA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmcwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYXJncyA9IGFyZzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihhcmdzKTtcbiAgICB9OyAvLyBQcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblxuXG4gICAgaWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuICAgICAgd3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVkRm47XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwUm91bmRlZCQxKGZuKSB7XG4gICAgY29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24gd3JhcHBlZEZuKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IGFyZzAgPSBhcmdzWzBdO1xuXG4gICAgICBpZiAoYXJnMCA9PT0gdW5kZWZpbmVkIHx8IGFyZzAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFyZzA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmcwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgYXJncyA9IGFyZzA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKGFyZ3MpOyAvLyBXZSdyZSBhc3N1bWluZyB0aGUgcmVzdWx0IGlzIGFuIGFycmF5IGhlcmUuXG4gICAgICAvLyBzZWUgbm90aWNlIGluIGNvbnZlcnNpb25zLmpzOyBkb24ndCB1c2UgYm94IHR5cGVzXG4gICAgICAvLyBpbiBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAobGV0IGxlbiA9IHJlc3VsdC5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9OyAvLyBQcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblxuXG4gICAgaWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuICAgICAgd3JhcHBlZEZuLmNvbnZlcnNpb24gPSBmbi5jb252ZXJzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwcGVkRm47XG4gIH1cblxuICBtb2RlbHMkMS5mb3JFYWNoKGZyb21Nb2RlbCA9PiB7XG4gICAgY29udmVydCQyW2Zyb21Nb2RlbF0gPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydCQyW2Zyb21Nb2RlbF0sICdjaGFubmVscycsIHtcbiAgICAgIHZhbHVlOiBjb252ZXJzaW9ucyQxW2Zyb21Nb2RlbF0uY2hhbm5lbHNcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydCQyW2Zyb21Nb2RlbF0sICdsYWJlbHMnLCB7XG4gICAgICB2YWx1ZTogY29udmVyc2lvbnMkMVtmcm9tTW9kZWxdLmxhYmVsc1xuICAgIH0pO1xuICAgIGNvbnN0IHJvdXRlcyA9IHJvdXRlJDEoZnJvbU1vZGVsKTtcbiAgICBjb25zdCByb3V0ZU1vZGVscyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG4gICAgcm91dGVNb2RlbHMuZm9yRWFjaCh0b01vZGVsID0+IHtcbiAgICAgIGNvbnN0IGZuID0gcm91dGVzW3RvTW9kZWxdO1xuICAgICAgY29udmVydCQyW2Zyb21Nb2RlbF1bdG9Nb2RlbF0gPSB3cmFwUm91bmRlZCQxKGZuKTtcbiAgICAgIGNvbnZlcnQkMltmcm9tTW9kZWxdW3RvTW9kZWxdLnJhdyA9IHdyYXBSYXckMShmbik7XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgY29sb3JDb252ZXJ0JDEgPSBjb252ZXJ0JDI7XG5cbiAgdmFyIGFuc2lTdHlsZXMkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICAgIGNvbnN0IHdyYXBBbnNpMTYgPSAoZm4sIG9mZnNldCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBmbiguLi5hcmdzKTtcbiAgICAgIHJldHVybiBcIlxceDFCW1wiLmNvbmNhdChjb2RlICsgb2Zmc2V0LCBcIm1cIik7XG4gICAgfTtcblxuICAgIGNvbnN0IHdyYXBBbnNpMjU2ID0gKGZuLCBvZmZzZXQpID0+ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBjb2RlID0gZm4oLi4uYXJncyk7XG4gICAgICByZXR1cm4gXCJcXHgxQltcIi5jb25jYXQoMzggKyBvZmZzZXQsIFwiOzU7XCIpLmNvbmNhdChjb2RlLCBcIm1cIik7XG4gICAgfTtcblxuICAgIGNvbnN0IHdyYXBBbnNpMTZtID0gKGZuLCBvZmZzZXQpID0+ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCByZ2IgPSBmbiguLi5hcmdzKTtcbiAgICAgIHJldHVybiBcIlxceDFCW1wiLmNvbmNhdCgzOCArIG9mZnNldCwgXCI7MjtcIikuY29uY2F0KHJnYlswXSwgXCI7XCIpLmNvbmNhdChyZ2JbMV0sIFwiO1wiKS5jb25jYXQocmdiWzJdLCBcIm1cIik7XG4gICAgfTtcblxuICAgIGNvbnN0IGFuc2kyYW5zaSA9IG4gPT4gbjtcblxuICAgIGNvbnN0IHJnYjJyZ2IgPSAociwgZywgYikgPT4gW3IsIGcsIGJdO1xuXG4gICAgY29uc3Qgc2V0TGF6eVByb3BlcnR5ID0gKG9iamVjdCwgcHJvcGVydHksIF9nZXQpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gX2dldCgpO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKiBAdHlwZSB7dHlwZW9mIGltcG9ydCgnY29sb3ItY29udmVydCcpfSAqL1xuXG5cbiAgICBsZXQgY29sb3JDb252ZXJ0O1xuXG4gICAgY29uc3QgbWFrZUR5bmFtaWNTdHlsZXMgPSAod3JhcCwgdGFyZ2V0U3BhY2UsIGlkZW50aXR5LCBpc0JhY2tncm91bmQpID0+IHtcbiAgICAgIGlmIChjb2xvckNvbnZlcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb2xvckNvbnZlcnQgPSBjb2xvckNvbnZlcnQkMTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrZ3JvdW5kID8gMTAgOiAwO1xuICAgICAgY29uc3Qgc3R5bGVzID0ge307XG5cbiAgICAgIGZvciAoY29uc3QgW3NvdXJjZVNwYWNlLCBzdWl0ZV0gb2YgT2JqZWN0LmVudHJpZXMoY29sb3JDb252ZXJ0KSkge1xuICAgICAgICBjb25zdCBuYW1lID0gc291cmNlU3BhY2UgPT09ICdhbnNpMTYnID8gJ2Fuc2knIDogc291cmNlU3BhY2U7XG5cbiAgICAgICAgaWYgKHNvdXJjZVNwYWNlID09PSB0YXJnZXRTcGFjZSkge1xuICAgICAgICAgIHN0eWxlc1tuYW1lXSA9IHdyYXAoaWRlbnRpdHksIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1aXRlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHN0eWxlc1tuYW1lXSA9IHdyYXAoc3VpdGVbdGFyZ2V0U3BhY2VdLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzc2VtYmxlU3R5bGVzKCkge1xuICAgICAgY29uc3QgY29kZXMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICAgIG1vZGlmaWVyOiB7XG4gICAgICAgICAgcmVzZXQ6IFswLCAwXSxcbiAgICAgICAgICAvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG4gICAgICAgICAgYm9sZDogWzEsIDIyXSxcbiAgICAgICAgICBkaW06IFsyLCAyMl0sXG4gICAgICAgICAgaXRhbGljOiBbMywgMjNdLFxuICAgICAgICAgIHVuZGVybGluZTogWzQsIDI0XSxcbiAgICAgICAgICBpbnZlcnNlOiBbNywgMjddLFxuICAgICAgICAgIGhpZGRlbjogWzgsIDI4XSxcbiAgICAgICAgICBzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgYmxhY2s6IFszMCwgMzldLFxuICAgICAgICAgIHJlZDogWzMxLCAzOV0sXG4gICAgICAgICAgZ3JlZW46IFszMiwgMzldLFxuICAgICAgICAgIHllbGxvdzogWzMzLCAzOV0sXG4gICAgICAgICAgYmx1ZTogWzM0LCAzOV0sXG4gICAgICAgICAgbWFnZW50YTogWzM1LCAzOV0sXG4gICAgICAgICAgY3lhbjogWzM2LCAzOV0sXG4gICAgICAgICAgd2hpdGU6IFszNywgMzldLFxuICAgICAgICAgIC8vIEJyaWdodCBjb2xvclxuICAgICAgICAgIGJsYWNrQnJpZ2h0OiBbOTAsIDM5XSxcbiAgICAgICAgICByZWRCcmlnaHQ6IFs5MSwgMzldLFxuICAgICAgICAgIGdyZWVuQnJpZ2h0OiBbOTIsIDM5XSxcbiAgICAgICAgICB5ZWxsb3dCcmlnaHQ6IFs5MywgMzldLFxuICAgICAgICAgIGJsdWVCcmlnaHQ6IFs5NCwgMzldLFxuICAgICAgICAgIG1hZ2VudGFCcmlnaHQ6IFs5NSwgMzldLFxuICAgICAgICAgIGN5YW5CcmlnaHQ6IFs5NiwgMzldLFxuICAgICAgICAgIHdoaXRlQnJpZ2h0OiBbOTcsIDM5XVxuICAgICAgICB9LFxuICAgICAgICBiZ0NvbG9yOiB7XG4gICAgICAgICAgYmdCbGFjazogWzQwLCA0OV0sXG4gICAgICAgICAgYmdSZWQ6IFs0MSwgNDldLFxuICAgICAgICAgIGJnR3JlZW46IFs0MiwgNDldLFxuICAgICAgICAgIGJnWWVsbG93OiBbNDMsIDQ5XSxcbiAgICAgICAgICBiZ0JsdWU6IFs0NCwgNDldLFxuICAgICAgICAgIGJnTWFnZW50YTogWzQ1LCA0OV0sXG4gICAgICAgICAgYmdDeWFuOiBbNDYsIDQ5XSxcbiAgICAgICAgICBiZ1doaXRlOiBbNDcsIDQ5XSxcbiAgICAgICAgICAvLyBCcmlnaHQgY29sb3JcbiAgICAgICAgICBiZ0JsYWNrQnJpZ2h0OiBbMTAwLCA0OV0sXG4gICAgICAgICAgYmdSZWRCcmlnaHQ6IFsxMDEsIDQ5XSxcbiAgICAgICAgICBiZ0dyZWVuQnJpZ2h0OiBbMTAyLCA0OV0sXG4gICAgICAgICAgYmdZZWxsb3dCcmlnaHQ6IFsxMDMsIDQ5XSxcbiAgICAgICAgICBiZ0JsdWVCcmlnaHQ6IFsxMDQsIDQ5XSxcbiAgICAgICAgICBiZ01hZ2VudGFCcmlnaHQ6IFsxMDUsIDQ5XSxcbiAgICAgICAgICBiZ0N5YW5CcmlnaHQ6IFsxMDYsIDQ5XSxcbiAgICAgICAgICBiZ1doaXRlQnJpZ2h0OiBbMTA3LCA0OV1cbiAgICAgICAgfVxuICAgICAgfTsgLy8gQWxpYXMgYnJpZ2h0IGJsYWNrIGFzIGdyYXkgKGFuZCBncmV5KVxuXG4gICAgICBzdHlsZXMuY29sb3IuZ3JheSA9IHN0eWxlcy5jb2xvci5ibGFja0JyaWdodDtcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmJnR3JheSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG4gICAgICBzdHlsZXMuY29sb3IuZ3JleSA9IHN0eWxlcy5jb2xvci5ibGFja0JyaWdodDtcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmJnR3JleSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG5cbiAgICAgIGZvciAoY29uc3QgW2dyb3VwTmFtZSwgZ3JvdXBdIG9mIE9iamVjdC5lbnRyaWVzKHN0eWxlcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZV0gb2YgT2JqZWN0LmVudHJpZXMoZ3JvdXApKSB7XG4gICAgICAgICAgc3R5bGVzW3N0eWxlTmFtZV0gPSB7XG4gICAgICAgICAgICBvcGVuOiBcIlxceDFCW1wiLmNvbmNhdChzdHlsZVswXSwgXCJtXCIpLFxuICAgICAgICAgICAgY2xvc2U6IFwiXFx4MUJbXCIuY29uY2F0KHN0eWxlWzFdLCBcIm1cIilcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdyb3VwW3N0eWxlTmFtZV0gPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgICAgICBjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsIGdyb3VwTmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBncm91cCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgJ2NvZGVzJywge1xuICAgICAgICB2YWx1ZTogY29kZXMsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHN0eWxlcy5jb2xvci5jbG9zZSA9ICdcXHUwMDFCWzM5bSc7XG4gICAgICBzdHlsZXMuYmdDb2xvci5jbG9zZSA9ICdcXHUwMDFCWzQ5bSc7XG4gICAgICBzZXRMYXp5UHJvcGVydHkoc3R5bGVzLmNvbG9yLCAnYW5zaScsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMTYsICdhbnNpMTYnLCBhbnNpMmFuc2ksIGZhbHNlKSk7XG4gICAgICBzZXRMYXp5UHJvcGVydHkoc3R5bGVzLmNvbG9yLCAnYW5zaTI1NicsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMjU2LCAnYW5zaTI1NicsIGFuc2kyYW5zaSwgZmFsc2UpKTtcbiAgICAgIHNldExhenlQcm9wZXJ0eShzdHlsZXMuY29sb3IsICdhbnNpMTZtJywgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kxNm0sICdyZ2InLCByZ2IycmdiLCBmYWxzZSkpO1xuICAgICAgc2V0TGF6eVByb3BlcnR5KHN0eWxlcy5iZ0NvbG9yLCAnYW5zaScsICgpID0+IG1ha2VEeW5hbWljU3R5bGVzKHdyYXBBbnNpMTYsICdhbnNpMTYnLCBhbnNpMmFuc2ksIHRydWUpKTtcbiAgICAgIHNldExhenlQcm9wZXJ0eShzdHlsZXMuYmdDb2xvciwgJ2Fuc2kyNTYnLCAoKSA9PiBtYWtlRHluYW1pY1N0eWxlcyh3cmFwQW5zaTI1NiwgJ2Fuc2kyNTYnLCBhbnNpMmFuc2ksIHRydWUpKTtcbiAgICAgIHNldExhenlQcm9wZXJ0eShzdHlsZXMuYmdDb2xvciwgJ2Fuc2kxNm0nLCAoKSA9PiBtYWtlRHluYW1pY1N0eWxlcyh3cmFwQW5zaTE2bSwgJ3JnYicsIHJnYjJyZ2IsIHRydWUpKTtcbiAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSAvLyBNYWtlIHRoZSBleHBvcnQgaW1tdXRhYmxlXG5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsICdleHBvcnRzJywge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogYXNzZW1ibGVTdHlsZXNcbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIHR0eSA9IHtcbiAgICBpc2F0dHkoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gIH07XG5cbiAgdmFyIGhhc0ZsYWckMSA9IChmbGFnLCBhcmd2ID0gcHJvY2Vzcy5hcmd2KSA9PiB7XG4gICAgY29uc3QgcHJlZml4ID0gZmxhZy5zdGFydHNXaXRoKCctJykgPyAnJyA6IGZsYWcubGVuZ3RoID09PSAxID8gJy0nIDogJy0tJztcbiAgICBjb25zdCBwb3NpdGlvbiA9IGFyZ3YuaW5kZXhPZihwcmVmaXggKyBmbGFnKTtcbiAgICBjb25zdCB0ZXJtaW5hdG9yUG9zaXRpb24gPSBhcmd2LmluZGV4T2YoJy0tJyk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSAtMSAmJiAodGVybWluYXRvclBvc2l0aW9uID09PSAtMSB8fCBwb3NpdGlvbiA8IHRlcm1pbmF0b3JQb3NpdGlvbik7XG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGVudjogZW52JDJcbiAgfSA9IHByb2Nlc3M7XG4gIGxldCBmb3JjZUNvbG9yJDE7XG5cbiAgaWYgKGhhc0ZsYWckMSgnbm8tY29sb3InKSB8fCBoYXNGbGFnJDEoJ25vLWNvbG9ycycpIHx8IGhhc0ZsYWckMSgnY29sb3I9ZmFsc2UnKSB8fCBoYXNGbGFnJDEoJ2NvbG9yPW5ldmVyJykpIHtcbiAgICBmb3JjZUNvbG9yJDEgPSAwO1xuICB9IGVsc2UgaWYgKGhhc0ZsYWckMSgnY29sb3InKSB8fCBoYXNGbGFnJDEoJ2NvbG9ycycpIHx8IGhhc0ZsYWckMSgnY29sb3I9dHJ1ZScpIHx8IGhhc0ZsYWckMSgnY29sb3I9YWx3YXlzJykpIHtcbiAgICBmb3JjZUNvbG9yJDEgPSAxO1xuICB9XG5cbiAgaWYgKCdGT1JDRV9DT0xPUicgaW4gZW52JDIpIHtcbiAgICBpZiAoZW52JDIuRk9SQ0VfQ09MT1IgPT09ICd0cnVlJykge1xuICAgICAgZm9yY2VDb2xvciQxID0gMTtcbiAgICB9IGVsc2UgaWYgKGVudiQyLkZPUkNFX0NPTE9SID09PSAnZmFsc2UnKSB7XG4gICAgICBmb3JjZUNvbG9yJDEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JjZUNvbG9yJDEgPSBlbnYkMi5GT1JDRV9DT0xPUi5sZW5ndGggPT09IDAgPyAxIDogTWF0aC5taW4ocGFyc2VJbnQoZW52JDIuRk9SQ0VfQ09MT1IsIDEwKSwgMyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlTGV2ZWwkMShsZXZlbCkge1xuICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsZXZlbCxcbiAgICAgIGhhc0Jhc2ljOiB0cnVlLFxuICAgICAgaGFzMjU2OiBsZXZlbCA+PSAyLFxuICAgICAgaGFzMTZtOiBsZXZlbCA+PSAzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN1cHBvcnRzQ29sb3IkMShoYXZlU3RyZWFtLCBzdHJlYW1Jc1RUWSkge1xuICAgIGlmIChmb3JjZUNvbG9yJDEgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChoYXNGbGFnJDEoJ2NvbG9yPTE2bScpIHx8IGhhc0ZsYWckMSgnY29sb3I9ZnVsbCcpIHx8IGhhc0ZsYWckMSgnY29sb3I9dHJ1ZWNvbG9yJykpIHtcbiAgICAgIHJldHVybiAzO1xuICAgIH1cblxuICAgIGlmIChoYXNGbGFnJDEoJ2NvbG9yPTI1NicpKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG5cbiAgICBpZiAoaGF2ZVN0cmVhbSAmJiAhc3RyZWFtSXNUVFkgJiYgZm9yY2VDb2xvciQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IGZvcmNlQ29sb3IkMSB8fCAwO1xuXG4gICAgaWYgKGVudiQyLlRFUk0gPT09ICdkdW1iJykge1xuICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgICAgLy8gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3QgV2luZG93cyByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMjU2IGNvbG9ycy5cbiAgICAgIC8vIFdpbmRvd3MgMTAgYnVpbGQgMTQ5MzEgaXMgdGhlIGZpcnN0IHJlbGVhc2UgdGhhdCBzdXBwb3J0cyAxNm0vVHJ1ZUNvbG9yLlxuICAgICAgY29uc3Qgb3NSZWxlYXNlID0gcmVxdWlyZSQkMCQxLnJlbGVhc2UoKS5zcGxpdCgnLicpO1xuXG4gICAgICBpZiAoTnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiYgTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTA1ODYpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihvc1JlbGVhc2VbMl0pID49IDE0OTMxID8gMyA6IDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICgnQ0knIGluIGVudiQyKSB7XG4gICAgICBpZiAoWydUUkFWSVMnLCAnQ0lSQ0xFQ0knLCAnQVBQVkVZT1InLCAnR0lUTEFCX0NJJ10uc29tZShzaWduID0+IHNpZ24gaW4gZW52JDIpIHx8IGVudiQyLkNJX05BTUUgPT09ICdjb2Rlc2hpcCcpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtaW47XG4gICAgfVxuXG4gICAgaWYgKCdURUFNQ0lUWV9WRVJTSU9OJyBpbiBlbnYkMikge1xuICAgICAgcmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudiQyLlRFQU1DSVRZX1ZFUlNJT04pID8gMSA6IDA7XG4gICAgfVxuXG4gICAgaWYgKCdHSVRIVUJfQUNUSU9OUycgaW4gZW52JDIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmIChlbnYkMi5DT0xPUlRFUk0gPT09ICd0cnVlY29sb3InKSB7XG4gICAgICByZXR1cm4gMztcbiAgICB9XG5cbiAgICBpZiAoJ1RFUk1fUFJPR1JBTScgaW4gZW52JDIpIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludCgoZW52JDIuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuICAgICAgc3dpdGNoIChlbnYkMi5URVJNX1BST0dSQU0pIHtcbiAgICAgICAgY2FzZSAnaVRlcm0uYXBwJzpcbiAgICAgICAgICByZXR1cm4gdmVyc2lvbiA+PSAzID8gMyA6IDI7XG5cbiAgICAgICAgY2FzZSAnQXBwbGVfVGVybWluYWwnOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAvLyBObyBkZWZhdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKC8tMjU2KGNvbG9yKT8kL2kudGVzdChlbnYkMi5URVJNKSkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuXG4gICAgaWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYkMi5URVJNKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCdDT0xPUlRFUk0nIGluIGVudiQyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWluO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3VwcG9ydExldmVsJDEoc3RyZWFtKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBzdXBwb3J0c0NvbG9yJDEoc3RyZWFtLCBzdHJlYW0gJiYgc3RyZWFtLmlzVFRZKTtcbiAgICByZXR1cm4gdHJhbnNsYXRlTGV2ZWwkMShsZXZlbCk7XG4gIH1cblxuICB2YXIgc3VwcG9ydHNDb2xvcl8xJDEgPSB7XG4gICAgc3VwcG9ydHNDb2xvcjogZ2V0U3VwcG9ydExldmVsJDEsXG4gICAgc3Rkb3V0OiB0cmFuc2xhdGVMZXZlbCQxKHN1cHBvcnRzQ29sb3IkMSh0cnVlLCB0dHkuaXNhdHR5KDEpKSksXG4gICAgc3RkZXJyOiB0cmFuc2xhdGVMZXZlbCQxKHN1cHBvcnRzQ29sb3IkMSh0cnVlLCB0dHkuaXNhdHR5KDIpKSlcbiAgfTtcblxuICBjb25zdCBzdHJpbmdSZXBsYWNlQWxsID0gKHN0cmluZywgc3Vic3RyaW5nLCByZXBsYWNlcikgPT4ge1xuICAgIGxldCBpbmRleCA9IHN0cmluZy5pbmRleE9mKHN1YnN0cmluZyk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIGNvbnN0IHN1YnN0cmluZ0xlbmd0aCA9IHN1YnN0cmluZy5sZW5ndGg7XG4gICAgbGV0IGVuZEluZGV4ID0gMDtcbiAgICBsZXQgcmV0dXJuVmFsdWUgPSAnJztcblxuICAgIGRvIHtcbiAgICAgIHJldHVyblZhbHVlICs9IHN0cmluZy5zdWJzdHIoZW5kSW5kZXgsIGluZGV4IC0gZW5kSW5kZXgpICsgc3Vic3RyaW5nICsgcmVwbGFjZXI7XG4gICAgICBlbmRJbmRleCA9IGluZGV4ICsgc3Vic3RyaW5nTGVuZ3RoO1xuICAgICAgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihzdWJzdHJpbmcsIGVuZEluZGV4KTtcbiAgICB9IHdoaWxlIChpbmRleCAhPT0gLTEpO1xuXG4gICAgcmV0dXJuVmFsdWUgKz0gc3RyaW5nLnN1YnN0cihlbmRJbmRleCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xuXG4gIGNvbnN0IHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleCA9IChzdHJpbmcsIHByZWZpeCwgcG9zdGZpeCwgaW5kZXgpID0+IHtcbiAgICBsZXQgZW5kSW5kZXggPSAwO1xuICAgIGxldCByZXR1cm5WYWx1ZSA9ICcnO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgZ290Q1IgPSBzdHJpbmdbaW5kZXggLSAxXSA9PT0gJ1xccic7XG4gICAgICByZXR1cm5WYWx1ZSArPSBzdHJpbmcuc3Vic3RyKGVuZEluZGV4LCAoZ290Q1IgPyBpbmRleCAtIDEgOiBpbmRleCkgLSBlbmRJbmRleCkgKyBwcmVmaXggKyAoZ290Q1IgPyAnXFxyXFxuJyA6ICdcXG4nKSArIHBvc3RmaXg7XG4gICAgICBlbmRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgIGluZGV4ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIGVuZEluZGV4KTtcbiAgICB9IHdoaWxlIChpbmRleCAhPT0gLTEpO1xuXG4gICAgcmV0dXJuVmFsdWUgKz0gc3RyaW5nLnN1YnN0cihlbmRJbmRleCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xuXG4gIHZhciB1dGlsID0ge1xuICAgIHN0cmluZ1JlcGxhY2VBbGwsXG4gICAgc3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4XG4gIH07XG5cbiAgY29uc3QgVEVNUExBVEVfUkVHRVgkMSA9IC8oPzpcXFxcKHUoPzpbYS1mXFxkXXs0fXxcXHtbYS1mXFxkXXsxLDZ9XFx9KXx4W2EtZlxcZF17Mn18LikpfCg/Olxceyh+KT8oXFx3Kyg/OlxcKFteKV0qXFwpKT8oPzpcXC5cXHcrKD86XFwoW14pXSpcXCkpPykqKSg/OlsgXFx0XXwoPz1cXHI/XFxuKSkpfChcXH0pfCgoPzoufFtcXHJcXG5cXGZdKSs/KS9naTtcbiAgY29uc3QgU1RZTEVfUkVHRVgkMSA9IC8oPzpefFxcLikoXFx3KykoPzpcXCgoW14pXSopXFwpKT8vZztcbiAgY29uc3QgU1RSSU5HX1JFR0VYJDEgPSAvXihbJ1wiXSkoKD86XFxcXC58KD8hXFwxKVteXFxcXF0pKilcXDEkLztcbiAgY29uc3QgRVNDQVBFX1JFR0VYJDEgPSAvXFxcXCh1KD86W2EtZlxcZF17NH18e1thLWZcXGRdezEsNn19KXx4W2EtZlxcZF17Mn18Lil8KFteXFxcXF0pL2dpO1xuICBjb25zdCBFU0NBUEVTJDEgPSBuZXcgTWFwKFtbJ24nLCAnXFxuJ10sIFsncicsICdcXHInXSwgWyd0JywgJ1xcdCddLCBbJ2InLCAnXFxiJ10sIFsnZicsICdcXGYnXSwgWyd2JywgJ1xcdiddLCBbJzAnLCAnXFwwJ10sIFsnXFxcXCcsICdcXFxcJ10sIFsnZScsICdcXHUwMDFCJ10sIFsnYScsICdcXHUwMDA3J11dKTtcblxuICBmdW5jdGlvbiB1bmVzY2FwZSQxKGMpIHtcbiAgICBjb25zdCB1ID0gY1swXSA9PT0gJ3UnO1xuICAgIGNvbnN0IGJyYWNrZXQgPSBjWzFdID09PSAneyc7XG5cbiAgICBpZiAodSAmJiAhYnJhY2tldCAmJiBjLmxlbmd0aCA9PT0gNSB8fCBjWzBdID09PSAneCcgJiYgYy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGMuc2xpY2UoMSksIDE2KSk7XG4gICAgfVxuXG4gICAgaWYgKHUgJiYgYnJhY2tldCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KGMuc2xpY2UoMiwgLTEpLCAxNikpO1xuICAgIH1cblxuICAgIHJldHVybiBFU0NBUEVTJDEuZ2V0KGMpIHx8IGM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyQxKG5hbWUsIGFyZ3VtZW50c18pIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgY2h1bmtzID0gYXJndW1lbnRzXy50cmltKCkuc3BsaXQoL1xccyosXFxzKi9nKTtcbiAgICBsZXQgbWF0Y2hlcztcblxuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIoY2h1bmspO1xuXG4gICAgICBpZiAoIU51bWJlci5pc05hTihudW1iZXIpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChudW1iZXIpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaGVzID0gY2h1bmsubWF0Y2goU1RSSU5HX1JFR0VYJDEpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChtYXRjaGVzWzJdLnJlcGxhY2UoRVNDQVBFX1JFR0VYJDEsIChtLCBlc2NhcGUsIGNoYXJhY3RlcikgPT4gZXNjYXBlID8gdW5lc2NhcGUkMShlc2NhcGUpIDogY2hhcmFjdGVyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIENoYWxrIHRlbXBsYXRlIHN0eWxlIGFyZ3VtZW50OiBcIi5jb25jYXQoY2h1bmssIFwiIChpbiBzdHlsZSAnXCIpLmNvbmNhdChuYW1lLCBcIicpXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3R5bGUkMShzdHlsZSkge1xuICAgIFNUWUxFX1JFR0VYJDEubGFzdEluZGV4ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgbGV0IG1hdGNoZXM7XG5cbiAgICB3aGlsZSAoKG1hdGNoZXMgPSBTVFlMRV9SRUdFWCQxLmV4ZWMoc3R5bGUpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoZXNbMV07XG5cbiAgICAgIGlmIChtYXRjaGVzWzJdKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3VtZW50cyQxKG5hbWUsIG1hdGNoZXNbMl0pO1xuICAgICAgICByZXN1bHRzLnB1c2goW25hbWVdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzLnB1c2goW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkU3R5bGUkMShjaGFsaywgc3R5bGVzKSB7XG4gICAgY29uc3QgZW5hYmxlZCA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBzdHlsZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgc3R5bGUgb2YgbGF5ZXIuc3R5bGVzKSB7XG4gICAgICAgIGVuYWJsZWRbc3R5bGVbMF1dID0gbGF5ZXIuaW52ZXJzZSA/IG51bGwgOiBzdHlsZS5zbGljZSgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY3VycmVudCA9IGNoYWxrO1xuXG4gICAgZm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZXNdIG9mIE9iamVjdC5lbnRyaWVzKGVuYWJsZWQpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoc3R5bGVOYW1lIGluIGN1cnJlbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gQ2hhbGsgc3R5bGU6IFwiLmNvbmNhdChzdHlsZU5hbWUpKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IHN0eWxlcy5sZW5ndGggPiAwID8gY3VycmVudFtzdHlsZU5hbWVdKC4uLnN0eWxlcykgOiBjdXJyZW50W3N0eWxlTmFtZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICB2YXIgdGVtcGxhdGVzJDEgPSAoY2hhbGssIHRlbXBvcmFyeSkgPT4ge1xuICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGxldCBjaHVuayA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXBhcmFtc1xuXG4gICAgdGVtcG9yYXJ5LnJlcGxhY2UoVEVNUExBVEVfUkVHRVgkMSwgKG0sIGVzY2FwZUNoYXJhY3RlciwgaW52ZXJzZSwgc3R5bGUsIGNsb3NlLCBjaGFyYWN0ZXIpID0+IHtcbiAgICAgIGlmIChlc2NhcGVDaGFyYWN0ZXIpIHtcbiAgICAgICAgY2h1bmsucHVzaCh1bmVzY2FwZSQxKGVzY2FwZUNoYXJhY3RlcikpO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZSkge1xuICAgICAgICBjb25zdCBzdHJpbmcgPSBjaHVuay5qb2luKCcnKTtcbiAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgY2h1bmtzLnB1c2goc3R5bGVzLmxlbmd0aCA9PT0gMCA/IHN0cmluZyA6IGJ1aWxkU3R5bGUkMShjaGFsaywgc3R5bGVzKShzdHJpbmcpKTtcbiAgICAgICAgc3R5bGVzLnB1c2goe1xuICAgICAgICAgIGludmVyc2UsXG4gICAgICAgICAgc3R5bGVzOiBwYXJzZVN0eWxlJDEoc3R5bGUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChjbG9zZSkge1xuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgZXh0cmFuZW91cyB9IGluIENoYWxrIHRlbXBsYXRlIGxpdGVyYWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNodW5rcy5wdXNoKGJ1aWxkU3R5bGUkMShjaGFsaywgc3R5bGVzKShjaHVuay5qb2luKCcnKSkpO1xuICAgICAgICBjaHVuayA9IFtdO1xuICAgICAgICBzdHlsZXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVuay5wdXNoKGNoYXJhY3Rlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2h1bmtzLnB1c2goY2h1bmsuam9pbignJykpO1xuXG4gICAgaWYgKHN0eWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBlcnJNZXNzYWdlID0gXCJDaGFsayB0ZW1wbGF0ZSBsaXRlcmFsIGlzIG1pc3NpbmcgXCIuY29uY2F0KHN0eWxlcy5sZW5ndGgsIFwiIGNsb3NpbmcgYnJhY2tldFwiKS5jb25jYXQoc3R5bGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnLCBcIiAoYH1gKVwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2h1bmtzLmpvaW4oJycpO1xuICB9O1xuXG4gIGNvbnN0IHtcbiAgICBzdGRvdXQ6IHN0ZG91dENvbG9yLFxuICAgIHN0ZGVycjogc3RkZXJyQ29sb3JcbiAgfSA9IHN1cHBvcnRzQ29sb3JfMSQxO1xuICBjb25zdCB7XG4gICAgc3RyaW5nUmVwbGFjZUFsbDogc3RyaW5nUmVwbGFjZUFsbCQxLFxuICAgIHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleDogc3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4JDFcbiAgfSA9IHV0aWw7IC8vIGBzdXBwb3J0c0NvbG9yLmxldmVsYCDihpIgYGFuc2lTdHlsZXMuY29sb3JbbmFtZV1gIG1hcHBpbmdcblxuICBjb25zdCBsZXZlbE1hcHBpbmcgPSBbJ2Fuc2knLCAnYW5zaScsICdhbnNpMjU2JywgJ2Fuc2kxNm0nXTtcbiAgY29uc3Qgc3R5bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBjb25zdCBhcHBseU9wdGlvbnMgPSAob2JqZWN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAob3B0aW9ucy5sZXZlbCAmJiAhKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sZXZlbCkgJiYgb3B0aW9ucy5sZXZlbCA+PSAwICYmIG9wdGlvbnMubGV2ZWwgPD0gMykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBsZXZlbGAgb3B0aW9uIHNob3VsZCBiZSBhbiBpbnRlZ2VyIGZyb20gMCB0byAzJyk7XG4gICAgfSAvLyBEZXRlY3QgbGV2ZWwgaWYgbm90IHNldCBtYW51YWxseVxuXG5cbiAgICBjb25zdCBjb2xvckxldmVsID0gc3Rkb3V0Q29sb3IgPyBzdGRvdXRDb2xvci5sZXZlbCA6IDA7XG4gICAgb2JqZWN0LmxldmVsID0gb3B0aW9ucy5sZXZlbCA9PT0gdW5kZWZpbmVkID8gY29sb3JMZXZlbCA6IG9wdGlvbnMubGV2ZWw7XG4gIH07XG5cbiAgY2xhc3MgQ2hhbGtDbGFzcyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuICAgICAgcmV0dXJuIGNoYWxrRmFjdG9yeShvcHRpb25zKTtcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IGNoYWxrRmFjdG9yeSA9IG9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IGNoYWxrID0ge307XG4gICAgYXBwbHlPcHRpb25zKGNoYWxrLCBvcHRpb25zKTtcblxuICAgIGNoYWxrLnRlbXBsYXRlID0gKC4uLmFyZ3VtZW50c18pID0+IGNoYWxrVGFnKGNoYWxrLnRlbXBsYXRlLCAuLi5hcmd1bWVudHNfKTtcblxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFsaywgQ2hhbGsucHJvdG90eXBlKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2hhbGsudGVtcGxhdGUsIGNoYWxrKTtcblxuICAgIGNoYWxrLnRlbXBsYXRlLmNvbnN0cnVjdG9yID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgY2hhbGsuY29uc3RydWN0b3IoKWAgaXMgZGVwcmVjYXRlZC4gVXNlIGBuZXcgY2hhbGsuSW5zdGFuY2UoKWAgaW5zdGVhZC4nKTtcbiAgICB9O1xuXG4gICAgY2hhbGsudGVtcGxhdGUuSW5zdGFuY2UgPSBDaGFsa0NsYXNzO1xuICAgIHJldHVybiBjaGFsay50ZW1wbGF0ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBDaGFsayhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNoYWxrRmFjdG9yeShvcHRpb25zKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgW3N0eWxlTmFtZSwgc3R5bGVdIG9mIE9iamVjdC5lbnRyaWVzKGFuc2lTdHlsZXMkMSkpIHtcbiAgICBzdHlsZXNbc3R5bGVOYW1lXSA9IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IGNyZWF0ZUJ1aWxkZXIodGhpcywgY3JlYXRlU3R5bGVyKHN0eWxlLm9wZW4sIHN0eWxlLmNsb3NlLCB0aGlzLl9zdHlsZXIpLCB0aGlzLl9pc0VtcHR5KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHN0eWxlTmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBidWlsZGVyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICAgIH1cblxuICAgIH07XG4gIH1cblxuICBzdHlsZXMudmlzaWJsZSA9IHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBidWlsZGVyID0gY3JlYXRlQnVpbGRlcih0aGlzLCB0aGlzLl9zdHlsZXIsIHRydWUpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd2aXNpYmxlJywge1xuICAgICAgICB2YWx1ZTogYnVpbGRlclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG5cbiAgfTtcbiAgY29uc3QgdXNlZE1vZGVscyA9IFsncmdiJywgJ2hleCcsICdrZXl3b3JkJywgJ2hzbCcsICdoc3YnLCAnaHdiJywgJ2Fuc2knLCAnYW5zaTI1NiddO1xuXG4gIGZvciAoY29uc3QgbW9kZWwgb2YgdXNlZE1vZGVscykge1xuICAgIHN0eWxlc1ttb2RlbF0gPSB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsZXZlbFxuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmd1bWVudHNfKSB7XG4gICAgICAgICAgY29uc3Qgc3R5bGVyID0gY3JlYXRlU3R5bGVyKGFuc2lTdHlsZXMkMS5jb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0oLi4uYXJndW1lbnRzXyksIGFuc2lTdHlsZXMkMS5jb2xvci5jbG9zZSwgdGhpcy5fc3R5bGVyKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQnVpbGRlcih0aGlzLCBzdHlsZXIsIHRoaXMuX2lzRW1wdHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgfTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbW9kZWwgb2YgdXNlZE1vZGVscykge1xuICAgIGNvbnN0IGJnTW9kZWwgPSAnYmcnICsgbW9kZWxbMF0udG9VcHBlckNhc2UoKSArIG1vZGVsLnNsaWNlKDEpO1xuICAgIHN0eWxlc1tiZ01vZGVsXSA9IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxldmVsXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcbiAgICAgICAgICBjb25zdCBzdHlsZXIgPSBjcmVhdGVTdHlsZXIoYW5zaVN0eWxlcyQxLmJnQ29sb3JbbGV2ZWxNYXBwaW5nW2xldmVsXV1bbW9kZWxdKC4uLmFyZ3VtZW50c18pLCBhbnNpU3R5bGVzJDEuYmdDb2xvci5jbG9zZSwgdGhpcy5fc3R5bGVyKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQnVpbGRlcih0aGlzLCBzdHlsZXIsIHRoaXMuX2lzRW1wdHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoKCkgPT4ge30sIE9iamVjdC5hc3NpZ24oe30sIHN0eWxlcywge1xuICAgIGxldmVsOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0b3IubGV2ZWw7XG4gICAgICB9LFxuXG4gICAgICBzZXQobGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdG9yLmxldmVsID0gbGV2ZWw7XG4gICAgICB9XG5cbiAgICB9XG4gIH0pKTtcblxuICBjb25zdCBjcmVhdGVTdHlsZXIgPSAob3BlbiwgY2xvc2UsIHBhcmVudCkgPT4ge1xuICAgIGxldCBvcGVuQWxsO1xuICAgIGxldCBjbG9zZUFsbDtcblxuICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3BlbkFsbCA9IG9wZW47XG4gICAgICBjbG9zZUFsbCA9IGNsb3NlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcGVuQWxsID0gcGFyZW50Lm9wZW5BbGwgKyBvcGVuO1xuICAgICAgY2xvc2VBbGwgPSBjbG9zZSArIHBhcmVudC5jbG9zZUFsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3BlbixcbiAgICAgIGNsb3NlLFxuICAgICAgb3BlbkFsbCxcbiAgICAgIGNsb3NlQWxsLFxuICAgICAgcGFyZW50XG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBjcmVhdGVCdWlsZGVyID0gKHNlbGYsIF9zdHlsZXIsIF9pc0VtcHR5KSA9PiB7XG4gICAgY29uc3QgYnVpbGRlciA9ICguLi5hcmd1bWVudHNfKSA9PiB7XG4gICAgICAvLyBTaW5nbGUgYXJndW1lbnQgaXMgaG90IHBhdGgsIGltcGxpY2l0IGNvZXJjaW9uIGlzIGZhc3RlciB0aGFuIGFueXRoaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW1wbGljaXQtY29lcmNpb25cbiAgICAgIHJldHVybiBhcHBseVN0eWxlKGJ1aWxkZXIsIGFyZ3VtZW50c18ubGVuZ3RoID09PSAxID8gJycgKyBhcmd1bWVudHNfWzBdIDogYXJndW1lbnRzXy5qb2luKCcgJykpO1xuICAgIH07IC8vIFdlIGFsdGVyIHRoZSBwcm90b3R5cGUgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcbiAgICAvLyBubyB3YXkgdG8gY3JlYXRlIGEgZnVuY3Rpb24gd2l0aCBhIGRpZmZlcmVudCBwcm90b3R5cGVcblxuXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1aWxkZXIsIHByb3RvKTtcbiAgICBidWlsZGVyLl9nZW5lcmF0b3IgPSBzZWxmO1xuICAgIGJ1aWxkZXIuX3N0eWxlciA9IF9zdHlsZXI7XG4gICAgYnVpbGRlci5faXNFbXB0eSA9IF9pc0VtcHR5O1xuICAgIHJldHVybiBidWlsZGVyO1xuICB9O1xuXG4gIGNvbnN0IGFwcGx5U3R5bGUgPSAoc2VsZiwgc3RyaW5nKSA9PiB7XG4gICAgaWYgKHNlbGYubGV2ZWwgPD0gMCB8fCAhc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc2VsZi5faXNFbXB0eSA/ICcnIDogc3RyaW5nO1xuICAgIH1cblxuICAgIGxldCBzdHlsZXIgPSBzZWxmLl9zdHlsZXI7XG5cbiAgICBpZiAoc3R5bGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgb3BlbkFsbCxcbiAgICAgIGNsb3NlQWxsXG4gICAgfSA9IHN0eWxlcjtcblxuICAgIGlmIChzdHJpbmcuaW5kZXhPZignXFx1MDAxQicpICE9PSAtMSkge1xuICAgICAgd2hpbGUgKHN0eWxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgYW55IGluc3RhbmNlcyBhbHJlYWR5IHByZXNlbnQgd2l0aCBhIHJlLW9wZW5pbmcgY29kZVxuICAgICAgICAvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG4gICAgICAgIC8vIHdpbGwgYmUgY29sb3JlZCwgYW5kIHRoZSByZXN0IHdpbGwgc2ltcGx5IGJlICdwbGFpbicuXG4gICAgICAgIHN0cmluZyA9IHN0cmluZ1JlcGxhY2VBbGwkMShzdHJpbmcsIHN0eWxlci5jbG9zZSwgc3R5bGVyLm9wZW4pO1xuICAgICAgICBzdHlsZXIgPSBzdHlsZXIucGFyZW50O1xuICAgICAgfVxuICAgIH0gLy8gV2UgY2FuIG1vdmUgYm90aCBuZXh0IGFjdGlvbnMgb3V0IG9mIGxvb3AsIGJlY2F1c2UgcmVtYWluaW5nIGFjdGlvbnMgaW4gbG9vcCB3b24ndCBoYXZlXG4gICAgLy8gYW55L3Zpc2libGUgZWZmZWN0IG9uIHBhcnRzIHdlIGFkZCBoZXJlLiBDbG9zZSB0aGUgc3R5bGluZyBiZWZvcmUgYSBsaW5lYnJlYWsgYW5kIHJlb3BlblxuICAgIC8vIGFmdGVyIG5leHQgbGluZSB0byBmaXggYSBibGVlZCBpc3N1ZSBvbiBtYWNPUzogaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL3B1bGwvOTJcblxuXG4gICAgY29uc3QgbGZJbmRleCA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcblxuICAgIGlmIChsZkluZGV4ICE9PSAtMSkge1xuICAgICAgc3RyaW5nID0gc3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4JDEoc3RyaW5nLCBjbG9zZUFsbCwgb3BlbkFsbCwgbGZJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wZW5BbGwgKyBzdHJpbmcgKyBjbG9zZUFsbDtcbiAgfTtcblxuICBsZXQgdGVtcGxhdGU7XG5cbiAgY29uc3QgY2hhbGtUYWcgPSAoY2hhbGssIC4uLnN0cmluZ3MpID0+IHtcbiAgICBjb25zdCBbZmlyc3RTdHJpbmddID0gc3RyaW5ncztcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShmaXJzdFN0cmluZykpIHtcbiAgICAgIC8vIElmIGNoYWxrKCkgd2FzIGNhbGxlZCBieSBpdHNlbGYgb3Igd2l0aCBhIHN0cmluZyxcbiAgICAgIC8vIHJldHVybiB0aGUgc3RyaW5nIGl0c2VsZiBhcyBhIHN0cmluZy5cbiAgICAgIHJldHVybiBzdHJpbmdzLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcmd1bWVudHNfID0gc3RyaW5ncy5zbGljZSgxKTtcbiAgICBjb25zdCBwYXJ0cyA9IFtmaXJzdFN0cmluZy5yYXdbMF1dO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBmaXJzdFN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgcGFydHMucHVzaChTdHJpbmcoYXJndW1lbnRzX1tpIC0gMV0pLnJlcGxhY2UoL1t7fVxcXFxdL2csICdcXFxcJCYnKSwgU3RyaW5nKGZpcnN0U3RyaW5nLnJhd1tpXSkpO1xuICAgIH1cblxuICAgIGlmICh0ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlcyQxO1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wbGF0ZShjaGFsaywgcGFydHMuam9pbignJykpO1xuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYWxrLnByb3RvdHlwZSwgc3R5bGVzKTtcbiAgY29uc3QgY2hhbGskMSA9IENoYWxrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXG4gIGNoYWxrJDEuc3VwcG9ydHNDb2xvciA9IHN0ZG91dENvbG9yO1xuICBjaGFsayQxLnN0ZGVyciA9IENoYWxrKHtcbiAgICBsZXZlbDogc3RkZXJyQ29sb3IgPyBzdGRlcnJDb2xvci5sZXZlbCA6IDBcbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXG4gIGNoYWxrJDEuc3RkZXJyLnN1cHBvcnRzQ29sb3IgPSBzdGRlcnJDb2xvcjtcbiAgdmFyIHNvdXJjZSA9IGNoYWxrJDE7XG5cbiAgY29uc3QgY2xpRGVzY3JpcHRvciA9IHtcbiAgICBrZXk6IF9rZXkgPT4gX2tleS5sZW5ndGggPT09IDEgPyBcIi1cIi5jb25jYXQoX2tleSkgOiBcIi0tXCIuY29uY2F0KF9rZXkpLFxuICAgIHZhbHVlOiBfdmFsdWUgPT4gbGliLmFwaURlc2NyaXB0b3IudmFsdWUoX3ZhbHVlKSxcbiAgICBwYWlyOiAoe1xuICAgICAga2V5LFxuICAgICAgdmFsdWVcbiAgICB9KSA9PiB2YWx1ZSA9PT0gZmFsc2UgPyBcIi0tbm8tXCIuY29uY2F0KGtleSkgOiB2YWx1ZSA9PT0gdHJ1ZSA/IGNsaURlc2NyaXB0b3Iua2V5KGtleSkgOiB2YWx1ZSA9PT0gXCJcIiA/IFwiXCIuY29uY2F0KGNsaURlc2NyaXB0b3Iua2V5KGtleSksIFwiIHdpdGhvdXQgYW4gYXJndW1lbnRcIikgOiBcIlwiLmNvbmNhdChjbGlEZXNjcmlwdG9yLmtleShrZXkpLCBcIj1cIikuY29uY2F0KHZhbHVlKVxuICB9O1xuXG4gIGNsYXNzIEZsYWdTY2hlbWEgZXh0ZW5kcyBsaWIuQ2hvaWNlU2NoZW1hIHtcbiAgICBjb25zdHJ1Y3Rvcih7XG4gICAgICBuYW1lLFxuICAgICAgZmxhZ3NcbiAgICB9KSB7XG4gICAgICBzdXBlcih7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNob2ljZXM6IGZsYWdzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2ZsYWdzID0gZmxhZ3Muc2xpY2UoKS5zb3J0KCk7XG4gICAgfVxuXG4gICAgcHJlcHJvY2Vzcyh2YWx1ZSwgdXRpbHMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoICE9PSAwICYmICF0aGlzLl9mbGFncy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3Qgc3VnZ2VzdGlvbiA9IHRoaXMuX2ZsYWdzLmZpbmQoZmxhZyA9PiBsZXZlbl8xJDEoZmxhZywgdmFsdWUpIDwgMyk7XG5cbiAgICAgICAgaWYgKHN1Z2dlc3Rpb24pIHtcbiAgICAgICAgICB1dGlscy5sb2dnZXIud2FybihbXCJVbmtub3duIGZsYWcgXCIuY29uY2F0KHNvdXJjZS55ZWxsb3codXRpbHMuZGVzY3JpcHRvci52YWx1ZSh2YWx1ZSkpLCBcIixcIiksIFwiZGlkIHlvdSBtZWFuIFwiLmNvbmNhdChzb3VyY2UuYmx1ZSh1dGlscy5kZXNjcmlwdG9yLnZhbHVlKHN1Z2dlc3Rpb24pKSwgXCI/XCIpXS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgcmV0dXJuIHN1Z2dlc3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGV4cGVjdGVkKCkge1xuICAgICAgcmV0dXJuIFwiYSBmbGFnXCI7XG4gICAgfVxuXG4gIH1cblxuICBsZXQgaGFzRGVwcmVjYXRpb25XYXJuZWQ7XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBvcHRpb25JbmZvcywge1xuICAgIGxvZ2dlcixcbiAgICBpc0NMSSA9IGZhbHNlLFxuICAgIHBhc3NUaHJvdWdoID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgdW5rbm93biA9ICFwYXNzVGhyb3VnaCA/IGxpYi5sZXZlblVua25vd25IYW5kbGVyIDogQXJyYXkuaXNBcnJheShwYXNzVGhyb3VnaCkgPyAoa2V5LCB2YWx1ZSkgPT4gIXBhc3NUaHJvdWdoLmluY2x1ZGVzKGtleSkgPyB1bmRlZmluZWQgOiB7XG4gICAgICBba2V5XTogdmFsdWVcbiAgICB9IDogKGtleSwgdmFsdWUpID0+ICh7XG4gICAgICBba2V5XTogdmFsdWVcbiAgICB9KTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gaXNDTEkgPyBjbGlEZXNjcmlwdG9yIDogbGliLmFwaURlc2NyaXB0b3I7XG4gICAgY29uc3Qgc2NoZW1hcyA9IG9wdGlvbkluZm9zVG9TY2hlbWFzKG9wdGlvbkluZm9zLCB7XG4gICAgICBpc0NMSVxuICAgIH0pO1xuICAgIGNvbnN0IG5vcm1hbGl6ZXIgPSBuZXcgbGliLk5vcm1hbGl6ZXIoc2NoZW1hcywge1xuICAgICAgbG9nZ2VyLFxuICAgICAgdW5rbm93bixcbiAgICAgIGRlc2NyaXB0b3JcbiAgICB9KTtcbiAgICBjb25zdCBzaG91bGRTdXBwcmVzc0R1cGxpY2F0ZURlcHJlY2F0aW9uV2FybmluZ3MgPSBsb2dnZXIgIT09IGZhbHNlO1xuXG4gICAgaWYgKHNob3VsZFN1cHByZXNzRHVwbGljYXRlRGVwcmVjYXRpb25XYXJuaW5ncyAmJiBoYXNEZXByZWNhdGlvbldhcm5lZCkge1xuICAgICAgbm9ybWFsaXplci5faGFzRGVwcmVjYXRpb25XYXJuZWQgPSBoYXNEZXByZWNhdGlvbldhcm5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplci5ub3JtYWxpemUob3B0aW9ucyk7XG5cbiAgICBpZiAoc2hvdWxkU3VwcHJlc3NEdXBsaWNhdGVEZXByZWNhdGlvbldhcm5pbmdzKSB7XG4gICAgICBoYXNEZXByZWNhdGlvbldhcm5lZCA9IG5vcm1hbGl6ZXIuX2hhc0RlcHJlY2F0aW9uV2FybmVkO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkO1xuICB9XG5cbiAgZnVuY3Rpb24gb3B0aW9uSW5mb3NUb1NjaGVtYXMob3B0aW9uSW5mb3MsIHtcbiAgICBpc0NMSVxuICB9KSB7XG4gICAgY29uc3Qgc2NoZW1hcyA9IFtdO1xuXG4gICAgaWYgKGlzQ0xJKSB7XG4gICAgICBzY2hlbWFzLnB1c2gobGliLkFueVNjaGVtYS5jcmVhdGUoe1xuICAgICAgICBuYW1lOiBcIl9cIlxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgb3B0aW9uSW5mbyBvZiBvcHRpb25JbmZvcykge1xuICAgICAgc2NoZW1hcy5wdXNoKG9wdGlvbkluZm9Ub1NjaGVtYShvcHRpb25JbmZvLCB7XG4gICAgICAgIGlzQ0xJLFxuICAgICAgICBvcHRpb25JbmZvc1xuICAgICAgfSkpO1xuXG4gICAgICBpZiAob3B0aW9uSW5mby5hbGlhcyAmJiBpc0NMSSkge1xuICAgICAgICBzY2hlbWFzLnB1c2gobGliLkFsaWFzU2NoZW1hLmNyZWF0ZSh7XG4gICAgICAgICAgbmFtZTogb3B0aW9uSW5mby5hbGlhcyxcbiAgICAgICAgICBzb3VyY2VOYW1lOiBvcHRpb25JbmZvLm5hbWVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWFzO1xuICB9XG5cbiAgZnVuY3Rpb24gb3B0aW9uSW5mb1RvU2NoZW1hKG9wdGlvbkluZm8sIHtcbiAgICBpc0NMSSxcbiAgICBvcHRpb25JbmZvc1xuICB9KSB7XG4gICAgbGV0IFNjaGVtYUNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB7XG4gICAgICBuYW1lOiBvcHRpb25JbmZvLm5hbWVcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXJzID0ge307XG5cbiAgICBzd2l0Y2ggKG9wdGlvbkluZm8udHlwZSkge1xuICAgICAgY2FzZSBcImludFwiOlxuICAgICAgICBTY2hlbWFDb25zdHJ1Y3RvciA9IGxpYi5JbnRlZ2VyU2NoZW1hO1xuXG4gICAgICAgIGlmIChpc0NMSSkge1xuICAgICAgICAgIHBhcmFtZXRlcnMucHJlcHJvY2VzcyA9IHZhbHVlID0+IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBTY2hlbWFDb25zdHJ1Y3RvciA9IGxpYi5TdHJpbmdTY2hlbWE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiY2hvaWNlXCI6XG4gICAgICAgIFNjaGVtYUNvbnN0cnVjdG9yID0gbGliLkNob2ljZVNjaGVtYTtcbiAgICAgICAgcGFyYW1ldGVycy5jaG9pY2VzID0gb3B0aW9uSW5mby5jaG9pY2VzLm1hcChjaG9pY2VJbmZvID0+IHR5cGVvZiBjaG9pY2VJbmZvID09PSBcIm9iamVjdFwiICYmIGNob2ljZUluZm8ucmVkaXJlY3QgPyBPYmplY3QuYXNzaWduKHt9LCBjaG9pY2VJbmZvLCB7XG4gICAgICAgICAgcmVkaXJlY3Q6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGtleTogb3B0aW9uSW5mby5uYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogY2hvaWNlSW5mby5yZWRpcmVjdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkgOiBjaG9pY2VJbmZvKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIFNjaGVtYUNvbnN0cnVjdG9yID0gbGliLkJvb2xlYW5TY2hlbWE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiZmxhZ1wiOlxuICAgICAgICBTY2hlbWFDb25zdHJ1Y3RvciA9IEZsYWdTY2hlbWE7XG4gICAgICAgIHBhcmFtZXRlcnMuZmxhZ3MgPSBvcHRpb25JbmZvcy5tYXAob3B0aW9uSW5mbyA9PiBbXS5jb25jYXQob3B0aW9uSW5mby5hbGlhcyB8fCBbXSwgb3B0aW9uSW5mby5kZXNjcmlwdGlvbiA/IG9wdGlvbkluZm8ubmFtZSA6IFtdLCBvcHRpb25JbmZvLm9wcG9zaXRlRGVzY3JpcHRpb24gPyBcIm5vLVwiLmNvbmNhdChvcHRpb25JbmZvLm5hbWUpIDogW10pKS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgICBTY2hlbWFDb25zdHJ1Y3RvciA9IGxpYi5TdHJpbmdTY2hlbWE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHR5cGUgXCIuY29uY2F0KG9wdGlvbkluZm8udHlwZSkpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25JbmZvLmV4Y2VwdGlvbikge1xuICAgICAgcGFyYW1ldGVycy52YWxpZGF0ZSA9ICh2YWx1ZSwgc2NoZW1hLCB1dGlscykgPT4ge1xuICAgICAgICByZXR1cm4gb3B0aW9uSW5mby5leGNlcHRpb24odmFsdWUpIHx8IHNjaGVtYS52YWxpZGF0ZSh2YWx1ZSwgdXRpbHMpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1ldGVycy52YWxpZGF0ZSA9ICh2YWx1ZSwgc2NoZW1hLCB1dGlscykgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzY2hlbWEudmFsaWRhdGUodmFsdWUsIHV0aWxzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbkluZm8ucmVkaXJlY3QpIHtcbiAgICAgIGhhbmRsZXJzLnJlZGlyZWN0ID0gdmFsdWUgPT4gIXZhbHVlID8gdW5kZWZpbmVkIDoge1xuICAgICAgICB0bzoge1xuICAgICAgICAgIGtleTogb3B0aW9uSW5mby5yZWRpcmVjdC5vcHRpb24sXG4gICAgICAgICAgdmFsdWU6IG9wdGlvbkluZm8ucmVkaXJlY3QudmFsdWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9uSW5mby5kZXByZWNhdGVkKSB7XG4gICAgICBoYW5kbGVycy5kZXByZWNhdGVkID0gdHJ1ZTtcbiAgICB9IC8vIGFsbG93IENMSSBvdmVycmlkaW5nLCBlLmcuLCBwcmV0dGllciBwYWNrYWdlLmpzb24gLS10YWItd2lkdGggMSAtLXRhYi13aWR0aCAyXG5cblxuICAgIGlmIChpc0NMSSAmJiAhb3B0aW9uSW5mby5hcnJheSkge1xuICAgICAgY29uc3Qgb3JpZ2luYWxQcmVwcm9jZXNzID0gcGFyYW1ldGVycy5wcmVwcm9jZXNzIHx8ICh4ID0+IHgpO1xuXG4gICAgICBwYXJhbWV0ZXJzLnByZXByb2Nlc3MgPSAodmFsdWUsIHNjaGVtYSwgdXRpbHMpID0+IHNjaGVtYS5wcmVwcm9jZXNzKG9yaWdpbmFsUHJlcHJvY2VzcyhBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdIDogdmFsdWUpLCB1dGlscyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbkluZm8uYXJyYXkgPyBsaWIuQXJyYXlTY2hlbWEuY3JlYXRlKE9iamVjdC5hc3NpZ24oe30sIGlzQ0xJID8ge1xuICAgICAgcHJlcHJvY2VzczogdiA9PiBbXS5jb25jYXQodilcbiAgICB9IDoge30sIHt9LCBoYW5kbGVycywge1xuICAgICAgdmFsdWVTY2hlbWE6IFNjaGVtYUNvbnN0cnVjdG9yLmNyZWF0ZShwYXJhbWV0ZXJzKVxuICAgIH0pKSA6IFNjaGVtYUNvbnN0cnVjdG9yLmNyZWF0ZShPYmplY3QuYXNzaWduKHt9LCBwYXJhbWV0ZXJzLCB7fSwgaGFuZGxlcnMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUFwaU9wdGlvbnMob3B0aW9ucywgb3B0aW9uSW5mb3MsIG9wdHMpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBvcHRpb25JbmZvcywgb3B0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVDbGlPcHRpb25zKG9wdGlvbnMsIG9wdGlvbkluZm9zLCBvcHRzKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucywgb3B0aW9uSW5mb3MsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgaXNDTEk6IHRydWVcbiAgICB9LCBvcHRzKSk7XG4gIH1cblxuICB2YXIgb3B0aW9uc05vcm1hbGl6ZXIgPSB7XG4gICAgbm9ybWFsaXplQXBpT3B0aW9ucyxcbiAgICBub3JtYWxpemVDbGlPcHRpb25zXG4gIH07XG5cbiAgdmFyIGdldExhc3QgPSBhcnIgPT4gYXJyW2Fyci5sZW5ndGggLSAxXTtcblxuICBmdW5jdGlvbiBsb2NTdGFydChub2RlLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307IC8vIEhhbmRsZSBub2RlcyB3aXRoIGRlY29yYXRvcnMuIFRoZXkgc2hvdWxkIHN0YXJ0IGF0IHRoZSBmaXJzdCBkZWNvcmF0b3JcblxuICAgIGlmICghb3B0cy5pZ25vcmVEZWNvcmF0b3JzICYmIG5vZGUuZGVjbGFyYXRpb24gJiYgbm9kZS5kZWNsYXJhdGlvbi5kZWNvcmF0b3JzICYmIG5vZGUuZGVjbGFyYXRpb24uZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gbG9jU3RhcnQobm9kZS5kZWNsYXJhdGlvbi5kZWNvcmF0b3JzWzBdKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdHMuaWdub3JlRGVjb3JhdG9ycyAmJiBub2RlLmRlY29yYXRvcnMgJiYgbm9kZS5kZWNvcmF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBsb2NTdGFydChub2RlLmRlY29yYXRvcnNbMF0pO1xuICAgIH1cblxuICAgIGlmIChub2RlLl9fbG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBub2RlLl9fbG9jYXRpb24uc3RhcnRPZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUucmFuZ2UpIHtcbiAgICAgIHJldHVybiBub2RlLnJhbmdlWzBdO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygbm9kZS5zdGFydCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubG9jKSB7XG4gICAgICByZXR1cm4gbm9kZS5sb2Muc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBsb2NFbmQobm9kZSkge1xuICAgIGNvbnN0IGVuZE5vZGUgPSBub2RlLm5vZGVzICYmIGdldExhc3Qobm9kZS5ub2Rlcyk7XG5cbiAgICBpZiAoZW5kTm9kZSAmJiBub2RlLnNvdXJjZSAmJiAhbm9kZS5zb3VyY2UuZW5kKSB7XG4gICAgICBub2RlID0gZW5kTm9kZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5fX2xvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gbm9kZS5fX2xvY2F0aW9uLmVuZE9mZnNldDtcbiAgICB9XG5cbiAgICBjb25zdCBsb2MgPSBub2RlLnJhbmdlID8gbm9kZS5yYW5nZVsxXSA6IHR5cGVvZiBub2RlLmVuZCA9PT0gXCJudW1iZXJcIiA/IG5vZGUuZW5kIDogbnVsbDtcblxuICAgIGlmIChub2RlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobG9jLCBsb2NFbmQobm9kZS50eXBlQW5ub3RhdGlvbikpO1xuICAgIH1cblxuICAgIGlmIChub2RlLmxvYyAmJiAhbG9jKSB7XG4gICAgICByZXR1cm4gbm9kZS5sb2MuZW5kO1xuICAgIH1cblxuICAgIHJldHVybiBsb2M7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wb3NlTG9jKHN0YXJ0Tm9kZSwgZW5kTm9kZU9yTGVuZ3RoID0gc3RhcnROb2RlKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdHlwZW9mIGVuZE5vZGVPckxlbmd0aCA9PT0gXCJudW1iZXJcIiA/IGVuZE5vZGVPckxlbmd0aCA6IC0xO1xuICAgIGNvbnN0IHN0YXJ0ID0gbG9jU3RhcnQoc3RhcnROb2RlKTtcbiAgICBjb25zdCBlbmQgPSBsZW5ndGggIT09IC0xID8gc3RhcnQgKyBsZW5ndGggOiBsb2NFbmQoZW5kTm9kZU9yTGVuZ3RoKTtcbiAgICBjb25zdCBzdGFydExvYyA9IHN0YXJ0Tm9kZS5sb2Muc3RhcnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgcmFuZ2U6IFtzdGFydCwgZW5kXSxcbiAgICAgIGxvYzoge1xuICAgICAgICBzdGFydDogc3RhcnRMb2MsXG4gICAgICAgIGVuZDogbGVuZ3RoICE9PSAtMSA/IHtcbiAgICAgICAgICBsaW5lOiBzdGFydExvYy5saW5lLFxuICAgICAgICAgIGNvbHVtbjogc3RhcnRMb2MuY29sdW1uICsgbGVuZ3RoXG4gICAgICAgIH0gOiBlbmROb2RlT3JMZW5ndGgubG9jLmVuZFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgbG9jID0ge1xuICAgIGxvY1N0YXJ0LFxuICAgIGxvY0VuZCxcbiAgICBjb21wb3NlTG9jXG4gIH07XG5cbiAgdmFyIGpzVG9rZW5zID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIC8vIENvcHlyaWdodCAyMDE0LCAyMDE1LCAyMDE2LCAyMDE3LCAyMDE4IFNpbW9uIEx5ZGVsbFxuICAgIC8vIExpY2Vuc2U6IE1JVC4gKFNlZSBMSUNFTlNFLilcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7IC8vIFRoaXMgcmVnZXggY29tZXMgZnJvbSByZWdleC5jb2ZmZWUsIGFuZCBpcyBpbnNlcnRlZCBoZXJlIGJ5IGdlbmVyYXRlLWluZGV4LmpzXG4gICAgLy8gKHJ1biBgbnBtIHJ1biBidWlsZGApLlxuXG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gLygoWydcIl0pKD86KD8hXFwyfFxcXFwpLnxcXFxcKD86XFxyXFxufFtcXHNcXFNdKSkqKFxcMik/fGAoPzpbXmBcXFxcJF18XFxcXFtcXHNcXFNdfFxcJCg/IVxceyl8XFwkXFx7KD86W157fV18XFx7W159XSpcXH0/KSpcXH0/KSooYCk/KXwoXFwvXFwvLiopfChcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKihcXCpcXC8pPyl8KFxcLyg/IVxcKikoPzpcXFsoPzooPyFbXFxdXFxcXF0pLnxcXFxcLikqXFxdfCg/IVtcXC9cXF1cXFxcXSkufFxcXFwuKStcXC8oPzooPyFcXHMqKD86XFxifFtcXHUwMDgwLVxcdUZGRkYkXFxcXCdcIn4oe118WytcXC0hXSg/IT0pfFxcLj9cXGQpKXxbZ21peXVzXXsxLDZ9XFxiKD8hW1xcdTAwODAtXFx1RkZGRiRcXFxcXXxcXHMqKD86WytcXC0qJSZ8Xjw+IT0/KHtdfFxcLyg/IVtcXC8qXSkpKSkpfCgwW3hYXVtcXGRhLWZBLUZdK3wwW29PXVswLTddK3wwW2JCXVswMV0rfCg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPyl8KCg/IVxcZCkoPzooPyFcXHMpWyRcXHdcXHUwMDgwLVxcdUZGRkZdfFxcXFx1W1xcZGEtZkEtRl17NH18XFxcXHVcXHtbXFxkYS1mQS1GXStcXH0pKyl8KC0tfFxcK1xcK3wmJnxcXHxcXHx8PT58XFwuezN9fCg/OlsrXFwtXFwvJSZ8Xl18XFwqezEsMn18PHsxLDJ9fD57MSwzfXwhPT98PXsxLDJ9KT0/fFs/fi4sOjtbXFxdKCl7fV0pfChcXHMrKXwoXiR8W1xcc1xcU10pL2c7XG5cbiAgICBleHBvcnRzLm1hdGNoVG9Ub2tlbiA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgdmFyIHRva2VuID0ge1xuICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgdmFsdWU6IG1hdGNoWzBdLFxuICAgICAgICBjbG9zZWQ6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGlmIChtYXRjaFsxXSkgdG9rZW4udHlwZSA9IFwic3RyaW5nXCIsIHRva2VuLmNsb3NlZCA9ICEhKG1hdGNoWzNdIHx8IG1hdGNoWzRdKTtlbHNlIGlmIChtYXRjaFs1XSkgdG9rZW4udHlwZSA9IFwiY29tbWVudFwiO2Vsc2UgaWYgKG1hdGNoWzZdKSB0b2tlbi50eXBlID0gXCJjb21tZW50XCIsIHRva2VuLmNsb3NlZCA9ICEhbWF0Y2hbN107ZWxzZSBpZiAobWF0Y2hbOF0pIHRva2VuLnR5cGUgPSBcInJlZ2V4XCI7ZWxzZSBpZiAobWF0Y2hbOV0pIHRva2VuLnR5cGUgPSBcIm51bWJlclwiO2Vsc2UgaWYgKG1hdGNoWzEwXSkgdG9rZW4udHlwZSA9IFwibmFtZVwiO2Vsc2UgaWYgKG1hdGNoWzExXSkgdG9rZW4udHlwZSA9IFwicHVuY3R1YXRvclwiO2Vsc2UgaWYgKG1hdGNoWzEyXSkgdG9rZW4udHlwZSA9IFwid2hpdGVzcGFjZVwiO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH07XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGpzVG9rZW5zKTtcbiAgdmFyIGpzVG9rZW5zXzEgPSBqc1Rva2Vucy5tYXRjaFRvVG9rZW47XG5cbiAgdmFyIGFzdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAvKlxuICAgICAgQ29weXJpZ2h0IChDKSAyMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgICBcbiAgICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAgXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAgICBcbiAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgJ0FTIElTJ1xuICAgICAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICAgICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgICAgIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgICAgIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gICAgICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gICAgICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgICAgIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gICAgICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgICAgIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gICAgKi9cbiAgICAoZnVuY3Rpb24gKCkge1xuXG4gICAgICBmdW5jdGlvbiBpc0V4cHJlc3Npb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdBcnJheUV4cHJlc3Npb24nOlxuICAgICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdDYWxsRXhwcmVzc2lvbic6XG4gICAgICAgICAgY2FzZSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdGdW5jdGlvbkV4cHJlc3Npb24nOlxuICAgICAgICAgIGNhc2UgJ0lkZW50aWZpZXInOlxuICAgICAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICAgIGNhc2UgJ0xvZ2ljYWxFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdNZW1iZXJFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdOZXdFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdPYmplY3RFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdTZXF1ZW5jZUV4cHJlc3Npb24nOlxuICAgICAgICAgIGNhc2UgJ1RoaXNFeHByZXNzaW9uJzpcbiAgICAgICAgICBjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuICAgICAgICAgIGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSXRlcmF0aW9uU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnRG9XaGlsZVN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnRm9ySW5TdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0ZvclN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnQmxvY2tTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0JyZWFrU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdDb250aW51ZVN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnRGVidWdnZXJTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0RvV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ0VtcHR5U3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdFeHByZXNzaW9uU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdGb3JJblN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdJZlN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnTGFiZWxlZFN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnUmV0dXJuU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdTd2l0Y2hTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ1Rocm93U3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdUcnlTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ1ZhcmlhYmxlRGVjbGFyYXRpb24nOlxuICAgICAgICAgIGNhc2UgJ1doaWxlU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdXaXRoU3RhdGVtZW50JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1NvdXJjZUVsZW1lbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gaXNTdGF0ZW1lbnQobm9kZSkgfHwgbm9kZSAhPSBudWxsICYmIG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRGVjbGFyYXRpb24nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cmFpbGluZ1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnSWZTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5jb25zZXF1ZW50O1xuXG4gICAgICAgICAgY2FzZSAnTGFiZWxlZFN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnRm9yU3RhdGVtZW50JzpcbiAgICAgICAgICBjYXNlICdGb3JJblN0YXRlbWVudCc6XG4gICAgICAgICAgY2FzZSAnV2hpbGVTdGF0ZW1lbnQnOlxuICAgICAgICAgIGNhc2UgJ1dpdGhTdGF0ZW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB2YXIgY3VycmVudDtcblxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gbm9kZS5jb25zZXF1ZW50O1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAoY3VycmVudC50eXBlID09PSAnSWZTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJyZW50ID0gdHJhaWxpbmdTdGF0ZW1lbnQoY3VycmVudCk7XG4gICAgICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzRXhwcmVzc2lvbjogaXNFeHByZXNzaW9uLFxuICAgICAgICBpc1N0YXRlbWVudDogaXNTdGF0ZW1lbnQsXG4gICAgICAgIGlzSXRlcmF0aW9uU3RhdGVtZW50OiBpc0l0ZXJhdGlvblN0YXRlbWVudCxcbiAgICAgICAgaXNTb3VyY2VFbGVtZW50OiBpc1NvdXJjZUVsZW1lbnQsXG4gICAgICAgIGlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudDogaXNQcm9ibGVtYXRpY0lmU3RhdGVtZW50LFxuICAgICAgICB0cmFpbGluZ1N0YXRlbWVudDogdHJhaWxpbmdTdGF0ZW1lbnRcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICAvKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuXG4gIH0pO1xuICB2YXIgYXN0XzEgPSBhc3QuaXNFeHByZXNzaW9uO1xuICB2YXIgYXN0XzIgPSBhc3QuaXNTdGF0ZW1lbnQ7XG4gIHZhciBhc3RfMyA9IGFzdC5pc0l0ZXJhdGlvblN0YXRlbWVudDtcbiAgdmFyIGFzdF80ID0gYXN0LmlzU291cmNlRWxlbWVudDtcbiAgdmFyIGFzdF81ID0gYXN0LmlzUHJvYmxlbWF0aWNJZlN0YXRlbWVudDtcbiAgdmFyIGFzdF82ID0gYXN0LnRyYWlsaW5nU3RhdGVtZW50O1xuXG4gIHZhciBjb2RlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIC8qXG4gICAgICBDb3B5cmlnaHQgKEMpIDIwMTMtMjAxNCBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gICAgICBDb3B5cmlnaHQgKEMpIDIwMTQgSXZhbiBOaWt1bGluIDxpZmFhYW5AZ21haWwuY29tPlxuICAgIFxuICAgICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAgICBcbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICAgIFxuICAgICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgICAgIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gICAgICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gICAgICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAgICAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICAgICAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gICAgICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAgICAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gICAgICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAgICovXG4gICAgKGZ1bmN0aW9uICgpIHtcblxuICAgICAgdmFyIEVTNlJlZ2V4LCBFUzVSZWdleCwgTk9OX0FTQ0lJX1dISVRFU1BBQ0VTLCBJREVOVElGSUVSX1NUQVJULCBJREVOVElGSUVSX1BBUlQsIGNoOyAvLyBTZWUgYHRvb2xzL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNgLlxuXG4gICAgICBFUzVSZWdleCA9IHtcbiAgICAgICAgLy8gRUNNQVNjcmlwdCA1LjEvVW5pY29kZSB2OS4wLjAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiAvW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdLyxcbiAgICAgICAgLy8gRUNNQVNjcmlwdCA1LjEvVW5pY29kZSB2OS4wLjAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDpcbiAgICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogL1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOEQ0LVxcdTA4RTFcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MC1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU0LVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkItXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzVcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdL1xuICAgICAgfTtcbiAgICAgIEVTNlJlZ2V4ID0ge1xuICAgICAgICAvLyBFQ01BU2NyaXB0IDYvVW5pY29kZSB2OS4wLjAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6XG4gICAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiAvW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlCLVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0IwLVxcdURDRDNcXHVEQ0Q4LVxcdURDRkJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDMDAtXFx1REMzNFxcdURDNDctXFx1REM0QVxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERjAwLVxcdURGMTldfFxcdUQ4MDZbXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MFxcdURGOTMtXFx1REY5RlxcdURGRTBdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVERDAwLVxcdURENDNdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXS8sXG4gICAgICAgIC8vIEVDTUFTY3JpcHQgNi9Vbmljb2RlIHY5LjAuMCBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OlxuICAgICAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiAvW1xceEFBXFx4QjVcXHhCN1xceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODYtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOEQ0LVxcdTA4RTFcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MC1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU0LVxcdTBENTdcXHUwRDVGLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzY5LVxcdTEzNzFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEQVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkItXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5LVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRDVcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzVcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2NVxcdUFCNzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVEREZEXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REVFMFxcdURGMDAtXFx1REYxRlxcdURGMzAtXFx1REY0QVxcdURGNTAtXFx1REY3QVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRlxcdURGRDEtXFx1REZENV18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0EwLVxcdURDQTlcXHVEQ0IwLVxcdURDRDNcXHVEQ0Q4LVxcdURDRkJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTZcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDAtXFx1REM0NlxcdURDNjYtXFx1REM2RlxcdURDN0YtXFx1RENCQVxcdURDRDAtXFx1RENFOFxcdURDRjAtXFx1RENGOVxcdUREMDAtXFx1REQzNFxcdUREMzYtXFx1REQzRlxcdURENTAtXFx1REQ3M1xcdURENzZcXHVERDgwLVxcdUREQzRcXHVERENBLVxcdUREQ0NcXHVEREQwLVxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTM3XFx1REUzRVxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAwLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjUwXFx1REY1N1xcdURGNUQtXFx1REY2M1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzAwLVxcdURDNEFcXHVEQzUwLVxcdURDNTlcXHVEQzgwLVxcdURDQzVcXHVEQ0M3XFx1RENEMC1cXHVEQ0Q5XFx1REQ4MC1cXHVEREI1XFx1RERCOC1cXHVEREMwXFx1REREOC1cXHVEREREXFx1REUwMC1cXHVERTQwXFx1REU0NFxcdURFNTAtXFx1REU1OVxcdURFODAtXFx1REVCN1xcdURFQzAtXFx1REVDOVxcdURGMDAtXFx1REYxOVxcdURGMUQtXFx1REYyQlxcdURGMzAtXFx1REYzOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDRTlcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMzNlxcdURDMzgtXFx1REM0MFxcdURDNTAtXFx1REM1OVxcdURDNzItXFx1REM4RlxcdURDOTItXFx1RENBN1xcdURDQTktXFx1RENCNl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REMwMC1cXHVEQzZFXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3Ml1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REU2MC1cXHVERTY5XFx1REVEMC1cXHVERUVEXFx1REVGMC1cXHVERUY0XFx1REYwMC1cXHVERjM2XFx1REY0MC1cXHVERjQzXFx1REY1MC1cXHVERjU5XFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURGMDAtXFx1REY0NFxcdURGNTAtXFx1REY3RVxcdURGOEYtXFx1REY5RlxcdURGRTBdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkVDXXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwXFx1REMwMV18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTlcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1LVxcdURENjlcXHVERDZELVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQlxcdURGQ0UtXFx1REZGRl18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQV18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVEQ0QwLVxcdURDRDZcXHVERDAwLVxcdURENEFcXHVERDUwLVxcdURENTldfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXXxcXHVEQjQwW1xcdUREMDAtXFx1RERFRl0vXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgICByZXR1cm4gMHgzMCA8PSBjaCAmJiBjaCA8PSAweDM5OyAvLyAwLi45XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIDB4MzAgPD0gY2ggJiYgY2ggPD0gMHgzOSB8fCAvLyAwLi45XG4gICAgICAgIDB4NjEgPD0gY2ggJiYgY2ggPD0gMHg2NiB8fCAvLyBhLi5mXG4gICAgICAgIDB4NDEgPD0gY2ggJiYgY2ggPD0gMHg0NjsgLy8gQS4uRlxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoID49IDB4MzAgJiYgY2ggPD0gMHgzNzsgLy8gMC4uN1xuICAgICAgfSAvLyA3LjIgV2hpdGUgU3BhY2VcblxuXG4gICAgICBOT05fQVNDSUlfV0hJVEVTUEFDRVMgPSBbMHgxNjgwLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXTtcblxuICAgICAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgICAgIHJldHVybiBjaCA9PT0gMHgyMCB8fCBjaCA9PT0gMHgwOSB8fCBjaCA9PT0gMHgwQiB8fCBjaCA9PT0gMHgwQyB8fCBjaCA9PT0gMHhBMCB8fCBjaCA+PSAweDE2ODAgJiYgTk9OX0FTQ0lJX1dISVRFU1BBQ0VTLmluZGV4T2YoY2gpID49IDA7XG4gICAgICB9IC8vIDcuMyBMaW5lIFRlcm1pbmF0b3JzXG5cblxuICAgICAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgICByZXR1cm4gY2ggPT09IDB4MEEgfHwgY2ggPT09IDB4MEQgfHwgY2ggPT09IDB4MjAyOCB8fCBjaCA9PT0gMHgyMDI5O1xuICAgICAgfSAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuXG4gICAgICBmdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNwKSB7XG4gICAgICAgIGlmIChjcCA8PSAweEZGRkYpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjcCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3UxID0gU3RyaW5nLmZyb21DaGFyQ29kZShNYXRoLmZsb29yKChjcCAtIDB4MTAwMDApIC8gMHg0MDApICsgMHhEODAwKTtcbiAgICAgICAgdmFyIGN1MiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNwIC0gMHgxMDAwMCkgJSAweDQwMCArIDB4REMwMCk7XG4gICAgICAgIHJldHVybiBjdTEgKyBjdTI7XG4gICAgICB9XG5cbiAgICAgIElERU5USUZJRVJfU1RBUlQgPSBuZXcgQXJyYXkoMHg4MCk7XG5cbiAgICAgIGZvciAoY2ggPSAwOyBjaCA8IDB4ODA7ICsrY2gpIHtcbiAgICAgICAgSURFTlRJRklFUl9TVEFSVFtjaF0gPSBjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EgfHwgLy8gYS4uelxuICAgICAgICBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHwgLy8gQS4uWlxuICAgICAgICBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RjsgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgIH1cblxuICAgICAgSURFTlRJRklFUl9QQVJUID0gbmV3IEFycmF5KDB4ODApO1xuXG4gICAgICBmb3IgKGNoID0gMDsgY2ggPCAweDgwOyArK2NoKSB7XG4gICAgICAgIElERU5USUZJRVJfUEFSVFtjaF0gPSBjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EgfHwgLy8gYS4uelxuICAgICAgICBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHwgLy8gQS4uWlxuICAgICAgICBjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkgfHwgLy8gMC4uOVxuICAgICAgICBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RjsgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnRFUzUoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoIDwgMHg4MCA/IElERU5USUZJRVJfU1RBUlRbY2hdIDogRVM1UmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChmcm9tQ29kZVBvaW50KGNoKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnRFUzUoY2gpIHtcbiAgICAgICAgcmV0dXJuIGNoIDwgMHg4MCA/IElERU5USUZJRVJfUEFSVFtjaF0gOiBFUzVSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoZnJvbUNvZGVQb2ludChjaCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydEVTNihjaCkge1xuICAgICAgICByZXR1cm4gY2ggPCAweDgwID8gSURFTlRJRklFUl9TVEFSVFtjaF0gOiBFUzZSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGZyb21Db2RlUG9pbnQoY2gpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydEVTNihjaCkge1xuICAgICAgICByZXR1cm4gY2ggPCAweDgwID8gSURFTlRJRklFUl9QQVJUW2NoXSA6IEVTNlJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChmcm9tQ29kZVBvaW50KGNoKSk7XG4gICAgICB9XG5cbiAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBpc0RlY2ltYWxEaWdpdDogaXNEZWNpbWFsRGlnaXQsXG4gICAgICAgIGlzSGV4RGlnaXQ6IGlzSGV4RGlnaXQsXG4gICAgICAgIGlzT2N0YWxEaWdpdDogaXNPY3RhbERpZ2l0LFxuICAgICAgICBpc1doaXRlU3BhY2U6IGlzV2hpdGVTcGFjZSxcbiAgICAgICAgaXNMaW5lVGVybWluYXRvcjogaXNMaW5lVGVybWluYXRvcixcbiAgICAgICAgaXNJZGVudGlmaWVyU3RhcnRFUzU6IGlzSWRlbnRpZmllclN0YXJ0RVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJQYXJ0RVM1OiBpc0lkZW50aWZpZXJQYXJ0RVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJTdGFydEVTNjogaXNJZGVudGlmaWVyU3RhcnRFUzYsXG4gICAgICAgIGlzSWRlbnRpZmllclBhcnRFUzY6IGlzSWRlbnRpZmllclBhcnRFUzZcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICAvKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuXG4gIH0pO1xuICB2YXIgY29kZV8xID0gY29kZS5pc0RlY2ltYWxEaWdpdDtcbiAgdmFyIGNvZGVfMiA9IGNvZGUuaXNIZXhEaWdpdDtcbiAgdmFyIGNvZGVfMyA9IGNvZGUuaXNPY3RhbERpZ2l0O1xuICB2YXIgY29kZV80ID0gY29kZS5pc1doaXRlU3BhY2U7XG4gIHZhciBjb2RlXzUgPSBjb2RlLmlzTGluZVRlcm1pbmF0b3I7XG4gIHZhciBjb2RlXzYgPSBjb2RlLmlzSWRlbnRpZmllclN0YXJ0RVM1O1xuICB2YXIgY29kZV83ID0gY29kZS5pc0lkZW50aWZpZXJQYXJ0RVM1O1xuICB2YXIgY29kZV84ID0gY29kZS5pc0lkZW50aWZpZXJTdGFydEVTNjtcbiAgdmFyIGNvZGVfOSA9IGNvZGUuaXNJZGVudGlmaWVyUGFydEVTNjtcblxuICB2YXIga2V5d29yZCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAvKlxuICAgICAgQ29weXJpZ2h0IChDKSAyMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgICBcbiAgICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gICAgXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAgICBcbiAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gICAgICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICAgICAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICAgICAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgICAgIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgICAgIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICAgICAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgICAgIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICAgICAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAgICAqL1xuICAgIChmdW5jdGlvbiAoKSB7XG5cbiAgICAgIHZhciBjb2RlJDEgPSBjb2RlO1xuXG4gICAgICBmdW5jdGlvbiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmRFUzYoaWQpIHtcbiAgICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICAgICAgY2FzZSAncGFja2FnZSc6XG4gICAgICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICAgICAgY2FzZSAncHJvdGVjdGVkJzpcbiAgICAgICAgICBjYXNlICdwdWJsaWMnOlxuICAgICAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0tleXdvcmRFUzUoaWQsIHN0cmljdCkge1xuICAgICAgICAvLyB5aWVsZCBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXMga2V5d29yZCB1bmRlciBub24tc3RyaWN0IG1vZGUuXG4gICAgICAgIGlmICghc3RyaWN0ICYmIGlkID09PSAneWllbGQnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzS2V5d29yZEVTNihpZCwgc3RyaWN0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNLZXl3b3JkRVM2KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmRFUzYoaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBpZCA9PT0gJ2lmJyB8fCBpZCA9PT0gJ2luJyB8fCBpZCA9PT0gJ2RvJztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBpZCA9PT0gJ3ZhcicgfHwgaWQgPT09ICdmb3InIHx8IGlkID09PSAnbmV3JyB8fCBpZCA9PT0gJ3RyeSc7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09ICd0aGlzJyB8fCBpZCA9PT0gJ2Vsc2UnIHx8IGlkID09PSAnY2FzZScgfHwgaWQgPT09ICd2b2lkJyB8fCBpZCA9PT0gJ3dpdGgnIHx8IGlkID09PSAnZW51bSc7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09ICd3aGlsZScgfHwgaWQgPT09ICdicmVhaycgfHwgaWQgPT09ICdjYXRjaCcgfHwgaWQgPT09ICd0aHJvdycgfHwgaWQgPT09ICdjb25zdCcgfHwgaWQgPT09ICd5aWVsZCcgfHwgaWQgPT09ICdjbGFzcycgfHwgaWQgPT09ICdzdXBlcic7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09ICdyZXR1cm4nIHx8IGlkID09PSAndHlwZW9mJyB8fCBpZCA9PT0gJ2RlbGV0ZScgfHwgaWQgPT09ICdzd2l0Y2gnIHx8IGlkID09PSAnZXhwb3J0JyB8fCBpZCA9PT0gJ2ltcG9ydCc7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09ICdkZWZhdWx0JyB8fCBpZCA9PT0gJ2ZpbmFsbHknIHx8IGlkID09PSAnZXh0ZW5kcyc7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09ICdmdW5jdGlvbicgfHwgaWQgPT09ICdjb250aW51ZScgfHwgaWQgPT09ICdkZWJ1Z2dlcic7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIGlkID09PSAnaW5zdGFuY2VvZic7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkRVM1KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnbnVsbCcgfHwgaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJyB8fCBpc0tleXdvcmRFUzUoaWQsIHN0cmljdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkRVM2KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnbnVsbCcgfHwgaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJyB8fCBpc0tleXdvcmRFUzYoaWQsIHN0cmljdCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGlzUmVzdHJpY3RlZFdvcmQoaWQpIHtcbiAgICAgICAgcmV0dXJuIGlkID09PSAnZXZhbCcgfHwgaWQgPT09ICdhcmd1bWVudHMnO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lRVM1KGlkKSB7XG4gICAgICAgIHZhciBpLCBpeiwgY2g7XG5cbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoID0gaWQuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICBpZiAoIWNvZGUkMS5pc0lkZW50aWZpZXJTdGFydEVTNShjaCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IGlkLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICBjaCA9IGlkLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgICBpZiAoIWNvZGUkMS5pc0lkZW50aWZpZXJQYXJ0RVM1KGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWNvZGVVdGYxNihsZWFkLCB0cmFpbCkge1xuICAgICAgICByZXR1cm4gKGxlYWQgLSAweEQ4MDApICogMHg0MDAgKyAodHJhaWwgLSAweERDMDApICsgMHgxMDAwMDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZUVTNihpZCkge1xuICAgICAgICB2YXIgaSwgaXosIGNoLCBsb3dDaCwgY2hlY2s7XG5cbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrID0gY29kZSQxLmlzSWRlbnRpZmllclN0YXJ0RVM2O1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gaWQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgIGNoID0gaWQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAgIGlmICgweEQ4MDAgPD0gY2ggJiYgY2ggPD0gMHhEQkZGKSB7XG4gICAgICAgICAgICArK2k7XG5cbiAgICAgICAgICAgIGlmIChpID49IGl6KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG93Q2ggPSBpZC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICBpZiAoISgweERDMDAgPD0gbG93Q2ggJiYgbG93Q2ggPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoID0gZGVjb2RlVXRmMTYoY2gsIGxvd0NoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNoZWNrKGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoZWNrID0gY29kZSQxLmlzSWRlbnRpZmllclBhcnRFUzY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyRVM1KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlzSWRlbnRpZmllck5hbWVFUzUoaWQpICYmICFpc1Jlc2VydmVkV29yZEVTNShpZCwgc3RyaWN0KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaXNJZGVudGlmaWVyRVM2KGlkLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGlzSWRlbnRpZmllck5hbWVFUzYoaWQpICYmICFpc1Jlc2VydmVkV29yZEVTNihpZCwgc3RyaWN0KTtcbiAgICAgIH1cblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGlzS2V5d29yZEVTNTogaXNLZXl3b3JkRVM1LFxuICAgICAgICBpc0tleXdvcmRFUzY6IGlzS2V5d29yZEVTNixcbiAgICAgICAgaXNSZXNlcnZlZFdvcmRFUzU6IGlzUmVzZXJ2ZWRXb3JkRVM1LFxuICAgICAgICBpc1Jlc2VydmVkV29yZEVTNjogaXNSZXNlcnZlZFdvcmRFUzYsXG4gICAgICAgIGlzUmVzdHJpY3RlZFdvcmQ6IGlzUmVzdHJpY3RlZFdvcmQsXG4gICAgICAgIGlzSWRlbnRpZmllck5hbWVFUzU6IGlzSWRlbnRpZmllck5hbWVFUzUsXG4gICAgICAgIGlzSWRlbnRpZmllck5hbWVFUzY6IGlzSWRlbnRpZmllck5hbWVFUzYsXG4gICAgICAgIGlzSWRlbnRpZmllckVTNTogaXNJZGVudGlmaWVyRVM1LFxuICAgICAgICBpc0lkZW50aWZpZXJFUzY6IGlzSWRlbnRpZmllckVTNlxuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIC8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG5cbiAgfSk7XG4gIHZhciBrZXl3b3JkXzEgPSBrZXl3b3JkLmlzS2V5d29yZEVTNTtcbiAgdmFyIGtleXdvcmRfMiA9IGtleXdvcmQuaXNLZXl3b3JkRVM2O1xuICB2YXIga2V5d29yZF8zID0ga2V5d29yZC5pc1Jlc2VydmVkV29yZEVTNTtcbiAgdmFyIGtleXdvcmRfNCA9IGtleXdvcmQuaXNSZXNlcnZlZFdvcmRFUzY7XG4gIHZhciBrZXl3b3JkXzUgPSBrZXl3b3JkLmlzUmVzdHJpY3RlZFdvcmQ7XG4gIHZhciBrZXl3b3JkXzYgPSBrZXl3b3JkLmlzSWRlbnRpZmllck5hbWVFUzU7XG4gIHZhciBrZXl3b3JkXzcgPSBrZXl3b3JkLmlzSWRlbnRpZmllck5hbWVFUzY7XG4gIHZhciBrZXl3b3JkXzggPSBrZXl3b3JkLmlzSWRlbnRpZmllckVTNTtcbiAgdmFyIGtleXdvcmRfOSA9IGtleXdvcmQuaXNJZGVudGlmaWVyRVM2O1xuXG4gIHZhciB1dGlscyQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAgIC8qXG4gICAgICBDb3B5cmlnaHQgKEMpIDIwMTMgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICAgIFxuICAgICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gICAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAgICBcbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICAgIFxuICAgICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgICAgIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICAgIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gICAgICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gICAgICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAgICAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICAgICAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gICAgICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAgICAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gICAgICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICAgICovXG4gICAgKGZ1bmN0aW9uICgpIHtcblxuICAgICAgZXhwb3J0cy5hc3QgPSBhc3Q7XG4gICAgICBleHBvcnRzLmNvZGUgPSBjb2RlO1xuICAgICAgZXhwb3J0cy5rZXl3b3JkID0ga2V5d29yZDtcbiAgICB9KSgpO1xuICAgIC8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG5cbiAgfSk7XG4gIHZhciB1dGlsc18xJDEgPSB1dGlscyQxLmFzdDtcbiAgdmFyIHV0aWxzXzIkMSA9IHV0aWxzJDEuY29kZTtcbiAgdmFyIHV0aWxzXzMkMSA9IHV0aWxzJDEua2V5d29yZDtcblxuICB2YXIgbWF0Y2hPcGVyYXRvcnNSZSQxID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xuXG4gIHZhciBlc2NhcGVTdHJpbmdSZWdleHAkMSA9IGZ1bmN0aW9uIGVzY2FwZVN0cmluZ1JlZ2V4cChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKG1hdGNoT3BlcmF0b3JzUmUkMSwgJ1xcXFwkJicpO1xuICB9O1xuXG4gIHZhciBjb2xvck5hbWUkMiA9IHtcbiAgICBcImFsaWNlYmx1ZVwiOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgXCJhbnRpcXVld2hpdGVcIjogWzI1MCwgMjM1LCAyMTVdLFxuICAgIFwiYXF1YVwiOiBbMCwgMjU1LCAyNTVdLFxuICAgIFwiYXF1YW1hcmluZVwiOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgXCJhenVyZVwiOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgXCJiZWlnZVwiOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgXCJiaXNxdWVcIjogWzI1NSwgMjI4LCAxOTZdLFxuICAgIFwiYmxhY2tcIjogWzAsIDAsIDBdLFxuICAgIFwiYmxhbmNoZWRhbG1vbmRcIjogWzI1NSwgMjM1LCAyMDVdLFxuICAgIFwiYmx1ZVwiOiBbMCwgMCwgMjU1XSxcbiAgICBcImJsdWV2aW9sZXRcIjogWzEzOCwgNDMsIDIyNl0sXG4gICAgXCJicm93blwiOiBbMTY1LCA0MiwgNDJdLFxuICAgIFwiYnVybHl3b29kXCI6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICBcImNhZGV0Ymx1ZVwiOiBbOTUsIDE1OCwgMTYwXSxcbiAgICBcImNoYXJ0cmV1c2VcIjogWzEyNywgMjU1LCAwXSxcbiAgICBcImNob2NvbGF0ZVwiOiBbMjEwLCAxMDUsIDMwXSxcbiAgICBcImNvcmFsXCI6IFsyNTUsIDEyNywgODBdLFxuICAgIFwiY29ybmZsb3dlcmJsdWVcIjogWzEwMCwgMTQ5LCAyMzddLFxuICAgIFwiY29ybnNpbGtcIjogWzI1NSwgMjQ4LCAyMjBdLFxuICAgIFwiY3JpbXNvblwiOiBbMjIwLCAyMCwgNjBdLFxuICAgIFwiY3lhblwiOiBbMCwgMjU1LCAyNTVdLFxuICAgIFwiZGFya2JsdWVcIjogWzAsIDAsIDEzOV0sXG4gICAgXCJkYXJrY3lhblwiOiBbMCwgMTM5LCAxMzldLFxuICAgIFwiZGFya2dvbGRlbnJvZFwiOiBbMTg0LCAxMzQsIDExXSxcbiAgICBcImRhcmtncmF5XCI6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBcImRhcmtncmVlblwiOiBbMCwgMTAwLCAwXSxcbiAgICBcImRhcmtncmV5XCI6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBcImRhcmtraGFraVwiOiBbMTg5LCAxODMsIDEwN10sXG4gICAgXCJkYXJrbWFnZW50YVwiOiBbMTM5LCAwLCAxMzldLFxuICAgIFwiZGFya29saXZlZ3JlZW5cIjogWzg1LCAxMDcsIDQ3XSxcbiAgICBcImRhcmtvcmFuZ2VcIjogWzI1NSwgMTQwLCAwXSxcbiAgICBcImRhcmtvcmNoaWRcIjogWzE1MywgNTAsIDIwNF0sXG4gICAgXCJkYXJrcmVkXCI6IFsxMzksIDAsIDBdLFxuICAgIFwiZGFya3NhbG1vblwiOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgXCJkYXJrc2VhZ3JlZW5cIjogWzE0MywgMTg4LCAxNDNdLFxuICAgIFwiZGFya3NsYXRlYmx1ZVwiOiBbNzIsIDYxLCAxMzldLFxuICAgIFwiZGFya3NsYXRlZ3JheVwiOiBbNDcsIDc5LCA3OV0sXG4gICAgXCJkYXJrc2xhdGVncmV5XCI6IFs0NywgNzksIDc5XSxcbiAgICBcImRhcmt0dXJxdW9pc2VcIjogWzAsIDIwNiwgMjA5XSxcbiAgICBcImRhcmt2aW9sZXRcIjogWzE0OCwgMCwgMjExXSxcbiAgICBcImRlZXBwaW5rXCI6IFsyNTUsIDIwLCAxNDddLFxuICAgIFwiZGVlcHNreWJsdWVcIjogWzAsIDE5MSwgMjU1XSxcbiAgICBcImRpbWdyYXlcIjogWzEwNSwgMTA1LCAxMDVdLFxuICAgIFwiZGltZ3JleVwiOiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgXCJkb2RnZXJibHVlXCI6IFszMCwgMTQ0LCAyNTVdLFxuICAgIFwiZmlyZWJyaWNrXCI6IFsxNzgsIDM0LCAzNF0sXG4gICAgXCJmbG9yYWx3aGl0ZVwiOiBbMjU1LCAyNTAsIDI0MF0sXG4gICAgXCJmb3Jlc3RncmVlblwiOiBbMzQsIDEzOSwgMzRdLFxuICAgIFwiZnVjaHNpYVwiOiBbMjU1LCAwLCAyNTVdLFxuICAgIFwiZ2FpbnNib3JvXCI6IFsyMjAsIDIyMCwgMjIwXSxcbiAgICBcImdob3N0d2hpdGVcIjogWzI0OCwgMjQ4LCAyNTVdLFxuICAgIFwiZ29sZFwiOiBbMjU1LCAyMTUsIDBdLFxuICAgIFwiZ29sZGVucm9kXCI6IFsyMTgsIDE2NSwgMzJdLFxuICAgIFwiZ3JheVwiOiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgXCJncmVlblwiOiBbMCwgMTI4LCAwXSxcbiAgICBcImdyZWVueWVsbG93XCI6IFsxNzMsIDI1NSwgNDddLFxuICAgIFwiZ3JleVwiOiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgXCJob25leWRld1wiOiBbMjQwLCAyNTUsIDI0MF0sXG4gICAgXCJob3RwaW5rXCI6IFsyNTUsIDEwNSwgMTgwXSxcbiAgICBcImluZGlhbnJlZFwiOiBbMjA1LCA5MiwgOTJdLFxuICAgIFwiaW5kaWdvXCI6IFs3NSwgMCwgMTMwXSxcbiAgICBcIml2b3J5XCI6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICBcImtoYWtpXCI6IFsyNDAsIDIzMCwgMTQwXSxcbiAgICBcImxhdmVuZGVyXCI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgICBcImxhdmVuZGVyYmx1c2hcIjogWzI1NSwgMjQwLCAyNDVdLFxuICAgIFwibGF3bmdyZWVuXCI6IFsxMjQsIDI1MiwgMF0sXG4gICAgXCJsZW1vbmNoaWZmb25cIjogWzI1NSwgMjUwLCAyMDVdLFxuICAgIFwibGlnaHRibHVlXCI6IFsxNzMsIDIxNiwgMjMwXSxcbiAgICBcImxpZ2h0Y29yYWxcIjogWzI0MCwgMTI4LCAxMjhdLFxuICAgIFwibGlnaHRjeWFuXCI6IFsyMjQsIDI1NSwgMjU1XSxcbiAgICBcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFsyNTAsIDI1MCwgMjEwXSxcbiAgICBcImxpZ2h0Z3JheVwiOiBbMjExLCAyMTEsIDIxMV0sXG4gICAgXCJsaWdodGdyZWVuXCI6IFsxNDQsIDIzOCwgMTQ0XSxcbiAgICBcImxpZ2h0Z3JleVwiOiBbMjExLCAyMTEsIDIxMV0sXG4gICAgXCJsaWdodHBpbmtcIjogWzI1NSwgMTgyLCAxOTNdLFxuICAgIFwibGlnaHRzYWxtb25cIjogWzI1NSwgMTYwLCAxMjJdLFxuICAgIFwibGlnaHRzZWFncmVlblwiOiBbMzIsIDE3OCwgMTcwXSxcbiAgICBcImxpZ2h0c2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDI1MF0sXG4gICAgXCJsaWdodHNsYXRlZ3JheVwiOiBbMTE5LCAxMzYsIDE1M10sXG4gICAgXCJsaWdodHNsYXRlZ3JleVwiOiBbMTE5LCAxMzYsIDE1M10sXG4gICAgXCJsaWdodHN0ZWVsYmx1ZVwiOiBbMTc2LCAxOTYsIDIyMl0sXG4gICAgXCJsaWdodHllbGxvd1wiOiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgXCJsaW1lXCI6IFswLCAyNTUsIDBdLFxuICAgIFwibGltZWdyZWVuXCI6IFs1MCwgMjA1LCA1MF0sXG4gICAgXCJsaW5lblwiOiBbMjUwLCAyNDAsIDIzMF0sXG4gICAgXCJtYWdlbnRhXCI6IFsyNTUsIDAsIDI1NV0sXG4gICAgXCJtYXJvb25cIjogWzEyOCwgMCwgMF0sXG4gICAgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IFsxMDIsIDIwNSwgMTcwXSxcbiAgICBcIm1lZGl1bWJsdWVcIjogWzAsIDAsIDIwNV0sXG4gICAgXCJtZWRpdW1vcmNoaWRcIjogWzE4NiwgODUsIDIxMV0sXG4gICAgXCJtZWRpdW1wdXJwbGVcIjogWzE0NywgMTEyLCAyMTldLFxuICAgIFwibWVkaXVtc2VhZ3JlZW5cIjogWzYwLCAxNzksIDExM10sXG4gICAgXCJtZWRpdW1zbGF0ZWJsdWVcIjogWzEyMywgMTA0LCAyMzhdLFxuICAgIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogWzAsIDI1MCwgMTU0XSxcbiAgICBcIm1lZGl1bXR1cnF1b2lzZVwiOiBbNzIsIDIwOSwgMjA0XSxcbiAgICBcIm1lZGl1bXZpb2xldHJlZFwiOiBbMTk5LCAyMSwgMTMzXSxcbiAgICBcIm1pZG5pZ2h0Ymx1ZVwiOiBbMjUsIDI1LCAxMTJdLFxuICAgIFwibWludGNyZWFtXCI6IFsyNDUsIDI1NSwgMjUwXSxcbiAgICBcIm1pc3R5cm9zZVwiOiBbMjU1LCAyMjgsIDIyNV0sXG4gICAgXCJtb2NjYXNpblwiOiBbMjU1LCAyMjgsIDE4MV0sXG4gICAgXCJuYXZham93aGl0ZVwiOiBbMjU1LCAyMjIsIDE3M10sXG4gICAgXCJuYXZ5XCI6IFswLCAwLCAxMjhdLFxuICAgIFwib2xkbGFjZVwiOiBbMjUzLCAyNDUsIDIzMF0sXG4gICAgXCJvbGl2ZVwiOiBbMTI4LCAxMjgsIDBdLFxuICAgIFwib2xpdmVkcmFiXCI6IFsxMDcsIDE0MiwgMzVdLFxuICAgIFwib3JhbmdlXCI6IFsyNTUsIDE2NSwgMF0sXG4gICAgXCJvcmFuZ2VyZWRcIjogWzI1NSwgNjksIDBdLFxuICAgIFwib3JjaGlkXCI6IFsyMTgsIDExMiwgMjE0XSxcbiAgICBcInBhbGVnb2xkZW5yb2RcIjogWzIzOCwgMjMyLCAxNzBdLFxuICAgIFwicGFsZWdyZWVuXCI6IFsxNTIsIDI1MSwgMTUyXSxcbiAgICBcInBhbGV0dXJxdW9pc2VcIjogWzE3NSwgMjM4LCAyMzhdLFxuICAgIFwicGFsZXZpb2xldHJlZFwiOiBbMjE5LCAxMTIsIDE0N10sXG4gICAgXCJwYXBheWF3aGlwXCI6IFsyNTUsIDIzOSwgMjEzXSxcbiAgICBcInBlYWNocHVmZlwiOiBbMjU1LCAyMTgsIDE4NV0sXG4gICAgXCJwZXJ1XCI6IFsyMDUsIDEzMywgNjNdLFxuICAgIFwicGlua1wiOiBbMjU1LCAxOTIsIDIwM10sXG4gICAgXCJwbHVtXCI6IFsyMjEsIDE2MCwgMjIxXSxcbiAgICBcInBvd2RlcmJsdWVcIjogWzE3NiwgMjI0LCAyMzBdLFxuICAgIFwicHVycGxlXCI6IFsxMjgsIDAsIDEyOF0sXG4gICAgXCJyZWJlY2NhcHVycGxlXCI6IFsxMDIsIDUxLCAxNTNdLFxuICAgIFwicmVkXCI6IFsyNTUsIDAsIDBdLFxuICAgIFwicm9zeWJyb3duXCI6IFsxODgsIDE0MywgMTQzXSxcbiAgICBcInJveWFsYmx1ZVwiOiBbNjUsIDEwNSwgMjI1XSxcbiAgICBcInNhZGRsZWJyb3duXCI6IFsxMzksIDY5LCAxOV0sXG4gICAgXCJzYWxtb25cIjogWzI1MCwgMTI4LCAxMTRdLFxuICAgIFwic2FuZHlicm93blwiOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICBcInNlYWdyZWVuXCI6IFs0NiwgMTM5LCA4N10sXG4gICAgXCJzZWFzaGVsbFwiOiBbMjU1LCAyNDUsIDIzOF0sXG4gICAgXCJzaWVubmFcIjogWzE2MCwgODIsIDQ1XSxcbiAgICBcInNpbHZlclwiOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgXCJza3libHVlXCI6IFsxMzUsIDIwNiwgMjM1XSxcbiAgICBcInNsYXRlYmx1ZVwiOiBbMTA2LCA5MCwgMjA1XSxcbiAgICBcInNsYXRlZ3JheVwiOiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgXCJzbGF0ZWdyZXlcIjogWzExMiwgMTI4LCAxNDRdLFxuICAgIFwic25vd1wiOiBbMjU1LCAyNTAsIDI1MF0sXG4gICAgXCJzcHJpbmdncmVlblwiOiBbMCwgMjU1LCAxMjddLFxuICAgIFwic3RlZWxibHVlXCI6IFs3MCwgMTMwLCAxODBdLFxuICAgIFwidGFuXCI6IFsyMTAsIDE4MCwgMTQwXSxcbiAgICBcInRlYWxcIjogWzAsIDEyOCwgMTI4XSxcbiAgICBcInRoaXN0bGVcIjogWzIxNiwgMTkxLCAyMTZdLFxuICAgIFwidG9tYXRvXCI6IFsyNTUsIDk5LCA3MV0sXG4gICAgXCJ0dXJxdW9pc2VcIjogWzY0LCAyMjQsIDIwOF0sXG4gICAgXCJ2aW9sZXRcIjogWzIzOCwgMTMwLCAyMzhdLFxuICAgIFwid2hlYXRcIjogWzI0NSwgMjIyLCAxNzldLFxuICAgIFwid2hpdGVcIjogWzI1NSwgMjU1LCAyNTVdLFxuICAgIFwid2hpdGVzbW9rZVwiOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgXCJ5ZWxsb3dcIjogWzI1NSwgMjU1LCAwXSxcbiAgICBcInllbGxvd2dyZWVuXCI6IFsxNTQsIDIwNSwgNTBdXG4gIH07XG5cbiAgdmFyIGNvbnZlcnNpb25zJDIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgLyogTUlUIGxpY2Vuc2UgKi9cbiAgICAvLyBOT1RFOiBjb252ZXJzaW9ucyBzaG91bGQgb25seSByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcyAoaS5lLiBhcnJheXMsIG9yXG4gICAgLy8gICAgICAgdmFsdWVzIHRoYXQgZ2l2ZSBjb3JyZWN0IGB0eXBlb2ZgIHJlc3VsdHMpLlxuICAgIC8vICAgICAgIGRvIG5vdCB1c2UgYm94IHZhbHVlcyB0eXBlcyAoaS5lLiBOdW1iZXIoKSwgU3RyaW5nKCksIGV0Yy4pXG4gICAgdmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbG9yTmFtZSQyKSB7XG4gICAgICBpZiAoY29sb3JOYW1lJDIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXZlcnNlS2V5d29yZHNbY29sb3JOYW1lJDJba2V5XV0gPSBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbnZlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgIHJnYjoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAncmdiJ1xuICAgICAgfSxcbiAgICAgIGhzbDoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAnaHNsJ1xuICAgICAgfSxcbiAgICAgIGhzdjoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAnaHN2J1xuICAgICAgfSxcbiAgICAgIGh3Yjoge1xuICAgICAgICBjaGFubmVsczogMyxcbiAgICAgICAgbGFiZWxzOiAnaHdiJ1xuICAgICAgfSxcbiAgICAgIGNteWs6IHtcbiAgICAgICAgY2hhbm5lbHM6IDQsXG4gICAgICAgIGxhYmVsczogJ2NteWsnXG4gICAgICB9LFxuICAgICAgeHl6OiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6ICd4eXonXG4gICAgICB9LFxuICAgICAgbGFiOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6ICdsYWInXG4gICAgICB9LFxuICAgICAgbGNoOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6ICdsY2gnXG4gICAgICB9LFxuICAgICAgaGV4OiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsnaGV4J11cbiAgICAgIH0sXG4gICAgICBrZXl3b3JkOiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsna2V5d29yZCddXG4gICAgICB9LFxuICAgICAgYW5zaTE2OiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsnYW5zaTE2J11cbiAgICAgIH0sXG4gICAgICBhbnNpMjU2OiB7XG4gICAgICAgIGNoYW5uZWxzOiAxLFxuICAgICAgICBsYWJlbHM6IFsnYW5zaTI1NiddXG4gICAgICB9LFxuICAgICAgaGNnOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6IFsnaCcsICdjJywgJ2cnXVxuICAgICAgfSxcbiAgICAgIGFwcGxlOiB7XG4gICAgICAgIGNoYW5uZWxzOiAzLFxuICAgICAgICBsYWJlbHM6IFsncjE2JywgJ2cxNicsICdiMTYnXVxuICAgICAgfSxcbiAgICAgIGdyYXk6IHtcbiAgICAgICAgY2hhbm5lbHM6IDEsXG4gICAgICAgIGxhYmVsczogWydncmF5J11cbiAgICAgIH1cbiAgICB9OyAvLyBoaWRlIC5jaGFubmVscyBhbmQgLmxhYmVscyBwcm9wZXJ0aWVzXG5cbiAgICBmb3IgKHZhciBtb2RlbCBpbiBjb252ZXJ0KSB7XG4gICAgICBpZiAoY29udmVydC5oYXNPd25Qcm9wZXJ0eShtb2RlbCkpIHtcbiAgICAgICAgaWYgKCEoJ2NoYW5uZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbCBsYWJlbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udmVydFttb2RlbF0ubGFiZWxzLmxlbmd0aCAhPT0gY29udmVydFttb2RlbF0uY2hhbm5lbHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoYW5uZWwgYW5kIGxhYmVsIGNvdW50cyBtaXNtYXRjaDogJyArIG1vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVscyA9IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzO1xuICAgICAgICB2YXIgbGFiZWxzID0gY29udmVydFttb2RlbF0ubGFiZWxzO1xuICAgICAgICBkZWxldGUgY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG4gICAgICAgIGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2NoYW5uZWxzJywge1xuICAgICAgICAgIHZhbHVlOiBjaGFubmVsc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbbW9kZWxdLCAnbGFiZWxzJywge1xuICAgICAgICAgIHZhbHVlOiBsYWJlbHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udmVydC5yZ2IuaHNsID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICB2YXIgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIHZhciBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuICAgICAgdmFyIGg7XG4gICAgICB2YXIgcztcbiAgICAgIHZhciBsO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IG1heCkge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhO1xuICAgICAgfSBlbHNlIGlmIChnID09PSBtYXgpIHtcbiAgICAgICAgaCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG4gICAgICB9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuICAgICAgICBoID0gNCArIChyIC0gZykgLyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgaCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgIGggKz0gMzYwO1xuICAgICAgfVxuXG4gICAgICBsID0gKG1pbiArIG1heCkgLyAyO1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGwgPD0gMC41KSB7XG4gICAgICAgIHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5oc3YgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgcmRpZjtcbiAgICAgIHZhciBnZGlmO1xuICAgICAgdmFyIGJkaWY7XG4gICAgICB2YXIgaDtcbiAgICAgIHZhciBzO1xuICAgICAgdmFyIHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICB2YXIgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIHZhciBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgdmFyIHYgPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICAgIHZhciBkaWZmID0gdiAtIE1hdGgubWluKHIsIGcsIGIpO1xuXG4gICAgICB2YXIgZGlmZmMgPSBmdW5jdGlvbiBkaWZmYyhjKSB7XG4gICAgICAgIHJldHVybiAodiAtIGMpIC8gNiAvIGRpZmYgKyAxIC8gMjtcbiAgICAgIH07XG5cbiAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgIGggPSBzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBkaWZmIC8gdjtcbiAgICAgICAgcmRpZiA9IGRpZmZjKHIpO1xuICAgICAgICBnZGlmID0gZGlmZmMoZyk7XG4gICAgICAgIGJkaWYgPSBkaWZmYyhiKTtcblxuICAgICAgICBpZiAociA9PT0gdikge1xuICAgICAgICAgIGggPSBiZGlmIC0gZ2RpZjtcbiAgICAgICAgfSBlbHNlIGlmIChnID09PSB2KSB7XG4gICAgICAgICAgaCA9IDEgLyAzICsgcmRpZiAtIGJkaWY7XG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gdikge1xuICAgICAgICAgIGggPSAyIC8gMyArIGdkaWYgLSByZGlmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgaCArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGggPiAxKSB7XG4gICAgICAgICAgaCAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbaCAqIDM2MCwgcyAqIDEwMCwgdiAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLmh3YiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgIHZhciByID0gcmdiWzBdO1xuICAgICAgdmFyIGcgPSByZ2JbMV07XG4gICAgICB2YXIgYiA9IHJnYlsyXTtcbiAgICAgIHZhciBoID0gY29udmVydC5yZ2IuaHNsKHJnYilbMF07XG4gICAgICB2YXIgdyA9IDEgLyAyNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSk7XG4gICAgICBiID0gMSAtIDEgLyAyNTUgKiBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG4gICAgICByZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5jbXlrID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHIgPSByZ2JbMF0gLyAyNTU7XG4gICAgICB2YXIgZyA9IHJnYlsxXSAvIDI1NTtcbiAgICAgIHZhciBiID0gcmdiWzJdIC8gMjU1O1xuICAgICAgdmFyIGM7XG4gICAgICB2YXIgbTtcbiAgICAgIHZhciB5O1xuICAgICAgdmFyIGs7XG4gICAgICBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG4gICAgICBjID0gKDEgLSByIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgICBtID0gKDEgLSBnIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgICB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG4gICAgICByZXR1cm4gW2MgKiAxMDAsIG0gKiAxMDAsIHkgKiAxMDAsIGsgKiAxMDBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VlIGh0dHBzOi8vZW4ubS53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2Rpc3RhbmNlI1NxdWFyZWRfRXVjbGlkZWFuX2Rpc3RhbmNlXG4gICAgICogKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG4gICAgICByZXR1cm4gTWF0aC5wb3coeFswXSAtIHlbMF0sIDIpICsgTWF0aC5wb3coeFsxXSAtIHlbMV0sIDIpICsgTWF0aC5wb3coeFsyXSAtIHlbMl0sIDIpO1xuICAgIH1cblxuICAgIGNvbnZlcnQucmdiLmtleXdvcmQgPSBmdW5jdGlvbiAocmdiKSB7XG4gICAgICB2YXIgcmV2ZXJzZWQgPSByZXZlcnNlS2V5d29yZHNbcmdiXTtcblxuICAgICAgaWYgKHJldmVyc2VkKSB7XG4gICAgICAgIHJldHVybiByZXZlcnNlZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgIHZhciBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG5cbiAgICAgIGZvciAodmFyIGtleXdvcmQgaW4gY29sb3JOYW1lJDIpIHtcbiAgICAgICAgaWYgKGNvbG9yTmFtZSQyLmhhc093blByb3BlcnR5KGtleXdvcmQpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gY29sb3JOYW1lJDJba2V5d29yZF07IC8vIENvbXB1dGUgY29tcGFyYXRpdmUgZGlzdGFuY2VcblxuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7IC8vIENoZWNrIGlmIGl0cyBsZXNzLCBpZiBzbyBzZXQgYXMgY2xvc2VzdFxuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgY3VycmVudENsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgY3VycmVudENsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgY3VycmVudENsb3Nlc3RLZXl3b3JkID0ga2V5d29yZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcbiAgICB9O1xuXG4gICAgY29udmVydC5rZXl3b3JkLnJnYiA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XG4gICAgICByZXR1cm4gY29sb3JOYW1lJDJba2V5d29yZF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLnh5eiA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgIHZhciByID0gcmdiWzBdIC8gMjU1O1xuICAgICAgdmFyIGcgPSByZ2JbMV0gLyAyNTU7XG4gICAgICB2YXIgYiA9IHJnYlsyXSAvIDI1NTsgLy8gYXNzdW1lIHNSR0JcblxuICAgICAgciA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKHIgKyAwLjA1NSkgLyAxLjA1NSwgMi40KSA6IHIgLyAxMi45MjtcbiAgICAgIGcgPSBnID4gMC4wNDA0NSA/IE1hdGgucG93KChnICsgMC4wNTUpIC8gMS4wNTUsIDIuNCkgOiBnIC8gMTIuOTI7XG4gICAgICBiID0gYiA+IDAuMDQwNDUgPyBNYXRoLnBvdygoYiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpIDogYiAvIDEyLjkyO1xuICAgICAgdmFyIHggPSByICogMC40MTI0ICsgZyAqIDAuMzU3NiArIGIgKiAwLjE4MDU7XG4gICAgICB2YXIgeSA9IHIgKiAwLjIxMjYgKyBnICogMC43MTUyICsgYiAqIDAuMDcyMjtcbiAgICAgIHZhciB6ID0gciAqIDAuMDE5MyArIGcgKiAwLjExOTIgKyBiICogMC45NTA1O1xuICAgICAgcmV0dXJuIFt4ICogMTAwLCB5ICogMTAwLCB6ICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5yZ2IubGFiID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHh5eiA9IGNvbnZlcnQucmdiLnh5eihyZ2IpO1xuICAgICAgdmFyIHggPSB4eXpbMF07XG4gICAgICB2YXIgeSA9IHh5elsxXTtcbiAgICAgIHZhciB6ID0geHl6WzJdO1xuICAgICAgdmFyIGw7XG4gICAgICB2YXIgYTtcbiAgICAgIHZhciBiO1xuICAgICAgeCAvPSA5NS4wNDc7XG4gICAgICB5IC89IDEwMDtcbiAgICAgIHogLz0gMTA4Ljg4MztcbiAgICAgIHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiA3Ljc4NyAqIHggKyAxNiAvIDExNjtcbiAgICAgIHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiA3Ljc4NyAqIHkgKyAxNiAvIDExNjtcbiAgICAgIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiA3Ljc4NyAqIHogKyAxNiAvIDExNjtcbiAgICAgIGwgPSAxMTYgKiB5IC0gMTY7XG4gICAgICBhID0gNTAwICogKHggLSB5KTtcbiAgICAgIGIgPSAyMDAgKiAoeSAtIHopO1xuICAgICAgcmV0dXJuIFtsLCBhLCBiXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5oc2wucmdiID0gZnVuY3Rpb24gKGhzbCkge1xuICAgICAgdmFyIGggPSBoc2xbMF0gLyAzNjA7XG4gICAgICB2YXIgcyA9IGhzbFsxXSAvIDEwMDtcbiAgICAgIHZhciBsID0gaHNsWzJdIC8gMTAwO1xuICAgICAgdmFyIHQxO1xuICAgICAgdmFyIHQyO1xuICAgICAgdmFyIHQzO1xuICAgICAgdmFyIHJnYjtcbiAgICAgIHZhciB2YWw7XG5cbiAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgIHZhbCA9IGwgKiAyNTU7XG4gICAgICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbF07XG4gICAgICB9XG5cbiAgICAgIGlmIChsIDwgMC41KSB7XG4gICAgICAgIHQyID0gbCAqICgxICsgcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0MiA9IGwgKyBzIC0gbCAqIHM7XG4gICAgICB9XG5cbiAgICAgIHQxID0gMiAqIGwgLSB0MjtcbiAgICAgIHJnYiA9IFswLCAwLCAwXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgdDMgPSBoICsgMSAvIDMgKiAtKGkgLSAxKTtcblxuICAgICAgICBpZiAodDMgPCAwKSB7XG4gICAgICAgICAgdDMrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0MyA+IDEpIHtcbiAgICAgICAgICB0My0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKDYgKiB0MyA8IDEpIHtcbiAgICAgICAgICB2YWwgPSB0MSArICh0MiAtIHQxKSAqIDYgKiB0MztcbiAgICAgICAgfSBlbHNlIGlmICgyICogdDMgPCAxKSB7XG4gICAgICAgICAgdmFsID0gdDI7XG4gICAgICAgIH0gZWxzZSBpZiAoMyAqIHQzIDwgMikge1xuICAgICAgICAgIHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSB0MTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJnYltpXSA9IHZhbCAqIDI1NTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJnYjtcbiAgICB9O1xuXG4gICAgY29udmVydC5oc2wuaHN2ID0gZnVuY3Rpb24gKGhzbCkge1xuICAgICAgdmFyIGggPSBoc2xbMF07XG4gICAgICB2YXIgcyA9IGhzbFsxXSAvIDEwMDtcbiAgICAgIHZhciBsID0gaHNsWzJdIC8gMTAwO1xuICAgICAgdmFyIHNtaW4gPSBzO1xuICAgICAgdmFyIGxtaW4gPSBNYXRoLm1heChsLCAwLjAxKTtcbiAgICAgIHZhciBzdjtcbiAgICAgIHZhciB2O1xuICAgICAgbCAqPSAyO1xuICAgICAgcyAqPSBsIDw9IDEgPyBsIDogMiAtIGw7XG4gICAgICBzbWluICo9IGxtaW4gPD0gMSA/IGxtaW4gOiAyIC0gbG1pbjtcbiAgICAgIHYgPSAobCArIHMpIC8gMjtcbiAgICAgIHN2ID0gbCA9PT0gMCA/IDIgKiBzbWluIC8gKGxtaW4gKyBzbWluKSA6IDIgKiBzIC8gKGwgKyBzKTtcbiAgICAgIHJldHVybiBbaCwgc3YgKiAxMDAsIHYgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0Lmhzdi5yZ2IgPSBmdW5jdGlvbiAoaHN2KSB7XG4gICAgICB2YXIgaCA9IGhzdlswXSAvIDYwO1xuICAgICAgdmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG4gICAgICB2YXIgdiA9IGhzdlsyXSAvIDEwMDtcbiAgICAgIHZhciBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuICAgICAgdmFyIGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcbiAgICAgIHZhciBwID0gMjU1ICogdiAqICgxIC0gcyk7XG4gICAgICB2YXIgcSA9IDI1NSAqIHYgKiAoMSAtIHMgKiBmKTtcbiAgICAgIHZhciB0ID0gMjU1ICogdiAqICgxIC0gcyAqICgxIC0gZikpO1xuICAgICAgdiAqPSAyNTU7XG5cbiAgICAgIHN3aXRjaCAoaGkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBbdiwgdCwgcF07XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBbcSwgdiwgcF07XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBbcCwgdiwgdF07XG5cbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBbcCwgcSwgdl07XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBbdCwgcCwgdl07XG5cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBbdiwgcCwgcV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaHN2LmhzbCA9IGZ1bmN0aW9uIChoc3YpIHtcbiAgICAgIHZhciBoID0gaHN2WzBdO1xuICAgICAgdmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG4gICAgICB2YXIgdiA9IGhzdlsyXSAvIDEwMDtcbiAgICAgIHZhciB2bWluID0gTWF0aC5tYXgodiwgMC4wMSk7XG4gICAgICB2YXIgbG1pbjtcbiAgICAgIHZhciBzbDtcbiAgICAgIHZhciBsO1xuICAgICAgbCA9ICgyIC0gcykgKiB2O1xuICAgICAgbG1pbiA9ICgyIC0gcykgKiB2bWluO1xuICAgICAgc2wgPSBzICogdm1pbjtcbiAgICAgIHNsIC89IGxtaW4gPD0gMSA/IGxtaW4gOiAyIC0gbG1pbjtcbiAgICAgIHNsID0gc2wgfHwgMDtcbiAgICAgIGwgLz0gMjtcbiAgICAgIHJldHVybiBbaCwgc2wgKiAxMDAsIGwgKiAxMDBdO1xuICAgIH07IC8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuXG5cbiAgICBjb252ZXJ0Lmh3Yi5yZ2IgPSBmdW5jdGlvbiAoaHdiKSB7XG4gICAgICB2YXIgaCA9IGh3YlswXSAvIDM2MDtcbiAgICAgIHZhciB3aCA9IGh3YlsxXSAvIDEwMDtcbiAgICAgIHZhciBibCA9IGh3YlsyXSAvIDEwMDtcbiAgICAgIHZhciByYXRpbyA9IHdoICsgYmw7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciB2O1xuICAgICAgdmFyIGY7XG4gICAgICB2YXIgbjsgLy8gd2ggKyBibCBjYW50IGJlID4gMVxuXG4gICAgICBpZiAocmF0aW8gPiAxKSB7XG4gICAgICAgIHdoIC89IHJhdGlvO1xuICAgICAgICBibCAvPSByYXRpbztcbiAgICAgIH1cblxuICAgICAgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuICAgICAgdiA9IDEgLSBibDtcbiAgICAgIGYgPSA2ICogaCAtIGk7XG5cbiAgICAgIGlmICgoaSAmIDB4MDEpICE9PSAwKSB7XG4gICAgICAgIGYgPSAxIC0gZjtcbiAgICAgIH1cblxuICAgICAgbiA9IHdoICsgZiAqICh2IC0gd2gpOyAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG4gICAgICB2YXIgcjtcbiAgICAgIHZhciBnO1xuICAgICAgdmFyIGI7XG5cbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByID0gdjtcbiAgICAgICAgICBnID0gbjtcbiAgICAgICAgICBiID0gd2g7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHIgPSBuO1xuICAgICAgICAgIGcgPSB2O1xuICAgICAgICAgIGIgPSB3aDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgciA9IHdoO1xuICAgICAgICAgIGcgPSB2O1xuICAgICAgICAgIGIgPSBuO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByID0gd2g7XG4gICAgICAgICAgZyA9IG47XG4gICAgICAgICAgYiA9IHY7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHIgPSBuO1xuICAgICAgICAgIGcgPSB3aDtcbiAgICAgICAgICBiID0gdjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgciA9IHY7XG4gICAgICAgICAgZyA9IHdoO1xuICAgICAgICAgIGIgPSBuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmNteWsucmdiID0gZnVuY3Rpb24gKGNteWspIHtcbiAgICAgIHZhciBjID0gY215a1swXSAvIDEwMDtcbiAgICAgIHZhciBtID0gY215a1sxXSAvIDEwMDtcbiAgICAgIHZhciB5ID0gY215a1syXSAvIDEwMDtcbiAgICAgIHZhciBrID0gY215a1szXSAvIDEwMDtcbiAgICAgIHZhciByO1xuICAgICAgdmFyIGc7XG4gICAgICB2YXIgYjtcbiAgICAgIHIgPSAxIC0gTWF0aC5taW4oMSwgYyAqICgxIC0gaykgKyBrKTtcbiAgICAgIGcgPSAxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKTtcbiAgICAgIGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcbiAgICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQueHl6LnJnYiA9IGZ1bmN0aW9uICh4eXopIHtcbiAgICAgIHZhciB4ID0geHl6WzBdIC8gMTAwO1xuICAgICAgdmFyIHkgPSB4eXpbMV0gLyAxMDA7XG4gICAgICB2YXIgeiA9IHh5elsyXSAvIDEwMDtcbiAgICAgIHZhciByO1xuICAgICAgdmFyIGc7XG4gICAgICB2YXIgYjtcbiAgICAgIHIgPSB4ICogMy4yNDA2ICsgeSAqIC0xLjUzNzIgKyB6ICogLTAuNDk4NjtcbiAgICAgIGcgPSB4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1O1xuICAgICAgYiA9IHggKiAwLjA1NTcgKyB5ICogLTAuMjA0MCArIHogKiAxLjA1NzA7IC8vIGFzc3VtZSBzUkdCXG5cbiAgICAgIHIgPSByID4gMC4wMDMxMzA4ID8gMS4wNTUgKiBNYXRoLnBvdyhyLCAxLjAgLyAyLjQpIC0gMC4wNTUgOiByICogMTIuOTI7XG4gICAgICBnID0gZyA+IDAuMDAzMTMwOCA/IDEuMDU1ICogTWF0aC5wb3coZywgMS4wIC8gMi40KSAtIDAuMDU1IDogZyAqIDEyLjkyO1xuICAgICAgYiA9IGIgPiAwLjAwMzEzMDggPyAxLjA1NSAqIE1hdGgucG93KGIsIDEuMCAvIDIuNCkgLSAwLjA1NSA6IGIgKiAxMi45MjtcbiAgICAgIHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG4gICAgICBnID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgZyksIDEpO1xuICAgICAgYiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcbiAgICAgIHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQueHl6LmxhYiA9IGZ1bmN0aW9uICh4eXopIHtcbiAgICAgIHZhciB4ID0geHl6WzBdO1xuICAgICAgdmFyIHkgPSB4eXpbMV07XG4gICAgICB2YXIgeiA9IHh5elsyXTtcbiAgICAgIHZhciBsO1xuICAgICAgdmFyIGE7XG4gICAgICB2YXIgYjtcbiAgICAgIHggLz0gOTUuMDQ3O1xuICAgICAgeSAvPSAxMDA7XG4gICAgICB6IC89IDEwOC44ODM7XG4gICAgICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogNy43ODcgKiB4ICsgMTYgLyAxMTY7XG4gICAgICB5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogNy43ODcgKiB5ICsgMTYgLyAxMTY7XG4gICAgICB6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogNy43ODcgKiB6ICsgMTYgLyAxMTY7XG4gICAgICBsID0gMTE2ICogeSAtIDE2O1xuICAgICAgYSA9IDUwMCAqICh4IC0geSk7XG4gICAgICBiID0gMjAwICogKHkgLSB6KTtcbiAgICAgIHJldHVybiBbbCwgYSwgYl07XG4gICAgfTtcblxuICAgIGNvbnZlcnQubGFiLnh5eiA9IGZ1bmN0aW9uIChsYWIpIHtcbiAgICAgIHZhciBsID0gbGFiWzBdO1xuICAgICAgdmFyIGEgPSBsYWJbMV07XG4gICAgICB2YXIgYiA9IGxhYlsyXTtcbiAgICAgIHZhciB4O1xuICAgICAgdmFyIHk7XG4gICAgICB2YXIgejtcbiAgICAgIHkgPSAobCArIDE2KSAvIDExNjtcbiAgICAgIHggPSBhIC8gNTAwICsgeTtcbiAgICAgIHogPSB5IC0gYiAvIDIwMDtcbiAgICAgIHZhciB5MiA9IE1hdGgucG93KHksIDMpO1xuICAgICAgdmFyIHgyID0gTWF0aC5wb3coeCwgMyk7XG4gICAgICB2YXIgejIgPSBNYXRoLnBvdyh6LCAzKTtcbiAgICAgIHkgPSB5MiA+IDAuMDA4ODU2ID8geTIgOiAoeSAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuICAgICAgeCA9IHgyID4gMC4wMDg4NTYgPyB4MiA6ICh4IC0gMTYgLyAxMTYpIC8gNy43ODc7XG4gICAgICB6ID0gejIgPiAwLjAwODg1NiA/IHoyIDogKHogLSAxNiAvIDExNikgLyA3Ljc4NztcbiAgICAgIHggKj0gOTUuMDQ3O1xuICAgICAgeSAqPSAxMDA7XG4gICAgICB6ICo9IDEwOC44ODM7XG4gICAgICByZXR1cm4gW3gsIHksIHpdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmxhYi5sY2ggPSBmdW5jdGlvbiAobGFiKSB7XG4gICAgICB2YXIgbCA9IGxhYlswXTtcbiAgICAgIHZhciBhID0gbGFiWzFdO1xuICAgICAgdmFyIGIgPSBsYWJbMl07XG4gICAgICB2YXIgaHI7XG4gICAgICB2YXIgaDtcbiAgICAgIHZhciBjO1xuICAgICAgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuICAgICAgaCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG5cbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoICs9IDM2MDtcbiAgICAgIH1cblxuICAgICAgYyA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgIHJldHVybiBbbCwgYywgaF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQubGNoLmxhYiA9IGZ1bmN0aW9uIChsY2gpIHtcbiAgICAgIHZhciBsID0gbGNoWzBdO1xuICAgICAgdmFyIGMgPSBsY2hbMV07XG4gICAgICB2YXIgaCA9IGxjaFsyXTtcbiAgICAgIHZhciBhO1xuICAgICAgdmFyIGI7XG4gICAgICB2YXIgaHI7XG4gICAgICBociA9IGggLyAzNjAgKiAyICogTWF0aC5QSTtcbiAgICAgIGEgPSBjICogTWF0aC5jb3MoaHIpO1xuICAgICAgYiA9IGMgKiBNYXRoLnNpbihocik7XG4gICAgICByZXR1cm4gW2wsIGEsIGJdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgdmFyIHIgPSBhcmdzWzBdO1xuICAgICAgdmFyIGcgPSBhcmdzWzFdO1xuICAgICAgdmFyIGIgPSBhcmdzWzJdO1xuICAgICAgdmFyIHZhbHVlID0gMSBpbiBhcmd1bWVudHMgPyBhcmd1bWVudHNbMV0gOiBjb252ZXJ0LnJnYi5oc3YoYXJncylbMl07IC8vIGhzdiAtPiBhbnNpMTYgb3B0aW1pemF0aW9uXG5cbiAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAvIDUwKTtcblxuICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgIHJldHVybiAzMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuc2kgPSAzMCArIChNYXRoLnJvdW5kKGIgLyAyNTUpIDw8IDIgfCBNYXRoLnJvdW5kKGcgLyAyNTUpIDw8IDEgfCBNYXRoLnJvdW5kKHIgLyAyNTUpKTtcblxuICAgICAgaWYgKHZhbHVlID09PSAyKSB7XG4gICAgICAgIGFuc2kgKz0gNjA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbnNpO1xuICAgIH07XG5cbiAgICBjb252ZXJ0Lmhzdi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgLy8gb3B0aW1pemF0aW9uIGhlcmU7IHdlIGFscmVhZHkga25vdyB0aGUgdmFsdWUgYW5kIGRvbid0IG5lZWQgdG8gZ2V0XG4gICAgICAvLyBpdCBjb252ZXJ0ZWQgZm9yIHVzLlxuICAgICAgcmV0dXJuIGNvbnZlcnQucmdiLmFuc2kxNihjb252ZXJ0Lmhzdi5yZ2IoYXJncyksIGFyZ3NbMl0pO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5hbnNpMjU2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciByID0gYXJnc1swXTtcbiAgICAgIHZhciBnID0gYXJnc1sxXTtcbiAgICAgIHZhciBiID0gYXJnc1syXTsgLy8gd2UgdXNlIHRoZSBleHRlbmRlZCBncmV5c2NhbGUgcGFsZXR0ZSBoZXJlLCB3aXRoIHRoZSBleGNlcHRpb24gb2ZcbiAgICAgIC8vIGJsYWNrIGFuZCB3aGl0ZS4gbm9ybWFsIHBhbGV0dGUgb25seSBoYXMgNCBncmV5c2NhbGUgc2hhZGVzLlxuXG4gICAgICBpZiAociA9PT0gZyAmJiBnID09PSBiKSB7XG4gICAgICAgIGlmIChyIDwgOCkge1xuICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyID4gMjQ4KSB7XG4gICAgICAgICAgcmV0dXJuIDIzMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKChyIC0gOCkgLyAyNDcgKiAyNCkgKyAyMzI7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbnNpID0gMTYgKyAzNiAqIE1hdGgucm91bmQociAvIDI1NSAqIDUpICsgNiAqIE1hdGgucm91bmQoZyAvIDI1NSAqIDUpICsgTWF0aC5yb3VuZChiIC8gMjU1ICogNSk7XG4gICAgICByZXR1cm4gYW5zaTtcbiAgICB9O1xuXG4gICAgY29udmVydC5hbnNpMTYucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciBjb2xvciA9IGFyZ3MgJSAxMDsgLy8gaGFuZGxlIGdyZXlzY2FsZVxuXG4gICAgICBpZiAoY29sb3IgPT09IDAgfHwgY29sb3IgPT09IDcpIHtcbiAgICAgICAgaWYgKGFyZ3MgPiA1MCkge1xuICAgICAgICAgIGNvbG9yICs9IDMuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbG9yID0gY29sb3IgLyAxMC41ICogMjU1O1xuICAgICAgICByZXR1cm4gW2NvbG9yLCBjb2xvciwgY29sb3JdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbXVsdCA9ICh+fihhcmdzID4gNTApICsgMSkgKiAwLjU7XG4gICAgICB2YXIgciA9IChjb2xvciAmIDEpICogbXVsdCAqIDI1NTtcbiAgICAgIHZhciBnID0gKGNvbG9yID4+IDEgJiAxKSAqIG11bHQgKiAyNTU7XG4gICAgICB2YXIgYiA9IChjb2xvciA+PiAyICYgMSkgKiBtdWx0ICogMjU1O1xuICAgICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5hbnNpMjU2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAvLyBoYW5kbGUgZ3JleXNjYWxlXG4gICAgICBpZiAoYXJncyA+PSAyMzIpIHtcbiAgICAgICAgdmFyIGMgPSAoYXJncyAtIDIzMikgKiAxMCArIDg7XG4gICAgICAgIHJldHVybiBbYywgYywgY107XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgLT0gMTY7XG4gICAgICB2YXIgcmVtO1xuICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKGFyZ3MgLyAzNikgLyA1ICogMjU1O1xuICAgICAgdmFyIGcgPSBNYXRoLmZsb29yKChyZW0gPSBhcmdzICUgMzYpIC8gNikgLyA1ICogMjU1O1xuICAgICAgdmFyIGIgPSByZW0gJSA2IC8gNSAqIDI1NTtcbiAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLmhleCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICB2YXIgaW50ZWdlciA9ICgoTWF0aC5yb3VuZChhcmdzWzBdKSAmIDB4RkYpIDw8IDE2KSArICgoTWF0aC5yb3VuZChhcmdzWzFdKSAmIDB4RkYpIDw8IDgpICsgKE1hdGgucm91bmQoYXJnc1syXSkgJiAweEZGKTtcbiAgICAgIHZhciBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbiAgICB9O1xuXG4gICAgY29udmVydC5oZXgucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIHZhciBtYXRjaCA9IGFyZ3MudG9TdHJpbmcoMTYpLm1hdGNoKC9bYS1mMC05XXs2fXxbYS1mMC05XXszfS9pKTtcblxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29sb3JTdHJpbmcgPSBtYXRjaFswXTtcblxuICAgICAgaWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGNoYXIpIHtcbiAgICAgICAgICByZXR1cm4gY2hhciArIGNoYXI7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZWdlciA9IHBhcnNlSW50KGNvbG9yU3RyaW5nLCAxNik7XG4gICAgICB2YXIgciA9IGludGVnZXIgPj4gMTYgJiAweEZGO1xuICAgICAgdmFyIGcgPSBpbnRlZ2VyID4+IDggJiAweEZGO1xuICAgICAgdmFyIGIgPSBpbnRlZ2VyICYgMHhGRjtcbiAgICAgIHJldHVybiBbciwgZywgYl07XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLmhjZyA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgICAgIHZhciByID0gcmdiWzBdIC8gMjU1O1xuICAgICAgdmFyIGcgPSByZ2JbMV0gLyAyNTU7XG4gICAgICB2YXIgYiA9IHJnYlsyXSAvIDI1NTtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heChNYXRoLm1heChyLCBnKSwgYik7XG4gICAgICB2YXIgbWluID0gTWF0aC5taW4oTWF0aC5taW4ociwgZyksIGIpO1xuICAgICAgdmFyIGNocm9tYSA9IG1heCAtIG1pbjtcbiAgICAgIHZhciBncmF5c2NhbGU7XG4gICAgICB2YXIgaHVlO1xuXG4gICAgICBpZiAoY2hyb21hIDwgMSkge1xuICAgICAgICBncmF5c2NhbGUgPSBtaW4gLyAoMSAtIGNocm9tYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmF5c2NhbGUgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hyb21hIDw9IDApIHtcbiAgICAgICAgaHVlID0gMDtcbiAgICAgIH0gZWxzZSBpZiAobWF4ID09PSByKSB7XG4gICAgICAgIGh1ZSA9IChnIC0gYikgLyBjaHJvbWEgJSA2O1xuICAgICAgfSBlbHNlIGlmIChtYXggPT09IGcpIHtcbiAgICAgICAgaHVlID0gMiArIChiIC0gcikgLyBjaHJvbWE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodWUgPSA0ICsgKHIgLSBnKSAvIGNocm9tYSArIDQ7XG4gICAgICB9XG5cbiAgICAgIGh1ZSAvPSA2O1xuICAgICAgaHVlICU9IDE7XG4gICAgICByZXR1cm4gW2h1ZSAqIDM2MCwgY2hyb21hICogMTAwLCBncmF5c2NhbGUgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmhzbC5oY2cgPSBmdW5jdGlvbiAoaHNsKSB7XG4gICAgICB2YXIgcyA9IGhzbFsxXSAvIDEwMDtcbiAgICAgIHZhciBsID0gaHNsWzJdIC8gMTAwO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIGYgPSAwO1xuXG4gICAgICBpZiAobCA8IDAuNSkge1xuICAgICAgICBjID0gMi4wICogcyAqIGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjID0gMi4wICogcyAqICgxLjAgLSBsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGMgPCAxLjApIHtcbiAgICAgICAgZiA9IChsIC0gMC41ICogYykgLyAoMS4wIC0gYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbaHNsWzBdLCBjICogMTAwLCBmICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5oc3YuaGNnID0gZnVuY3Rpb24gKGhzdikge1xuICAgICAgdmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG4gICAgICB2YXIgdiA9IGhzdlsyXSAvIDEwMDtcbiAgICAgIHZhciBjID0gcyAqIHY7XG4gICAgICB2YXIgZiA9IDA7XG5cbiAgICAgIGlmIChjIDwgMS4wKSB7XG4gICAgICAgIGYgPSAodiAtIGMpIC8gKDEgLSBjKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtoc3ZbMF0sIGMgKiAxMDAsIGYgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmhjZy5yZ2IgPSBmdW5jdGlvbiAoaGNnKSB7XG4gICAgICB2YXIgaCA9IGhjZ1swXSAvIDM2MDtcbiAgICAgIHZhciBjID0gaGNnWzFdIC8gMTAwO1xuICAgICAgdmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cbiAgICAgIGlmIChjID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIFtnICogMjU1LCBnICogMjU1LCBnICogMjU1XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHB1cmUgPSBbMCwgMCwgMF07XG4gICAgICB2YXIgaGkgPSBoICUgMSAqIDY7XG4gICAgICB2YXIgdiA9IGhpICUgMTtcbiAgICAgIHZhciB3ID0gMSAtIHY7XG4gICAgICB2YXIgbWcgPSAwO1xuXG4gICAgICBzd2l0Y2ggKE1hdGguZmxvb3IoaGkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBwdXJlWzBdID0gMTtcbiAgICAgICAgICBwdXJlWzFdID0gdjtcbiAgICAgICAgICBwdXJlWzJdID0gMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcHVyZVswXSA9IHc7XG4gICAgICAgICAgcHVyZVsxXSA9IDE7XG4gICAgICAgICAgcHVyZVsyXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHB1cmVbMF0gPSAwO1xuICAgICAgICAgIHB1cmVbMV0gPSAxO1xuICAgICAgICAgIHB1cmVbMl0gPSB2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwdXJlWzBdID0gMDtcbiAgICAgICAgICBwdXJlWzFdID0gdztcbiAgICAgICAgICBwdXJlWzJdID0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcHVyZVswXSA9IHY7XG4gICAgICAgICAgcHVyZVsxXSA9IDA7XG4gICAgICAgICAgcHVyZVsyXSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwdXJlWzBdID0gMTtcbiAgICAgICAgICBwdXJlWzFdID0gMDtcbiAgICAgICAgICBwdXJlWzJdID0gdztcbiAgICAgIH1cblxuICAgICAgbWcgPSAoMS4wIC0gYykgKiBnO1xuICAgICAgcmV0dXJuIFsoYyAqIHB1cmVbMF0gKyBtZykgKiAyNTUsIChjICogcHVyZVsxXSArIG1nKSAqIDI1NSwgKGMgKiBwdXJlWzJdICsgbWcpICogMjU1XTtcbiAgICB9O1xuXG4gICAgY29udmVydC5oY2cuaHN2ID0gZnVuY3Rpb24gKGhjZykge1xuICAgICAgdmFyIGMgPSBoY2dbMV0gLyAxMDA7XG4gICAgICB2YXIgZyA9IGhjZ1syXSAvIDEwMDtcbiAgICAgIHZhciB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG4gICAgICB2YXIgZiA9IDA7XG5cbiAgICAgIGlmICh2ID4gMC4wKSB7XG4gICAgICAgIGYgPSBjIC8gdjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtoY2dbMF0sIGYgKiAxMDAsIHYgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmhjZy5oc2wgPSBmdW5jdGlvbiAoaGNnKSB7XG4gICAgICB2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcbiAgICAgIHZhciBnID0gaGNnWzJdIC8gMTAwO1xuICAgICAgdmFyIGwgPSBnICogKDEuMCAtIGMpICsgMC41ICogYztcbiAgICAgIHZhciBzID0gMDtcblxuICAgICAgaWYgKGwgPiAwLjAgJiYgbCA8IDAuNSkge1xuICAgICAgICBzID0gYyAvICgyICogbCk7XG4gICAgICB9IGVsc2UgaWYgKGwgPj0gMC41ICYmIGwgPCAxLjApIHtcbiAgICAgICAgcyA9IGMgLyAoMiAqICgxIC0gbCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2hjZ1swXSwgcyAqIDEwMCwgbCAqIDEwMF07XG4gICAgfTtcblxuICAgIGNvbnZlcnQuaGNnLmh3YiA9IGZ1bmN0aW9uIChoY2cpIHtcbiAgICAgIHZhciBjID0gaGNnWzFdIC8gMTAwO1xuICAgICAgdmFyIGcgPSBoY2dbMl0gLyAxMDA7XG4gICAgICB2YXIgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuICAgICAgcmV0dXJuIFtoY2dbMF0sICh2IC0gYykgKiAxMDAsICgxIC0gdikgKiAxMDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0Lmh3Yi5oY2cgPSBmdW5jdGlvbiAoaHdiKSB7XG4gICAgICB2YXIgdyA9IGh3YlsxXSAvIDEwMDtcbiAgICAgIHZhciBiID0gaHdiWzJdIC8gMTAwO1xuICAgICAgdmFyIHYgPSAxIC0gYjtcbiAgICAgIHZhciBjID0gdiAtIHc7XG4gICAgICB2YXIgZyA9IDA7XG5cbiAgICAgIGlmIChjIDwgMSkge1xuICAgICAgICBnID0gKHYgLSBjKSAvICgxIC0gYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbaHdiWzBdLCBjICogMTAwLCBnICogMTAwXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5hcHBsZS5yZ2IgPSBmdW5jdGlvbiAoYXBwbGUpIHtcbiAgICAgIHJldHVybiBbYXBwbGVbMF0gLyA2NTUzNSAqIDI1NSwgYXBwbGVbMV0gLyA2NTUzNSAqIDI1NSwgYXBwbGVbMl0gLyA2NTUzNSAqIDI1NV07XG4gICAgfTtcblxuICAgIGNvbnZlcnQucmdiLmFwcGxlID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgcmV0dXJuIFtyZ2JbMF0gLyAyNTUgKiA2NTUzNSwgcmdiWzFdIC8gMjU1ICogNjU1MzUsIHJnYlsyXSAvIDI1NSAqIDY1NTM1XTtcbiAgICB9O1xuXG4gICAgY29udmVydC5ncmF5LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICByZXR1cm4gW2FyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTUsIGFyZ3NbMF0gLyAxMDAgKiAyNTVdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmdyYXkuaHNsID0gY29udmVydC5ncmF5LmhzdiA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICByZXR1cm4gWzAsIDAsIGFyZ3NbMF1dO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmdyYXkuaHdiID0gZnVuY3Rpb24gKGdyYXkpIHtcbiAgICAgIHJldHVybiBbMCwgMTAwLCBncmF5WzBdXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5ncmF5LmNteWsgPSBmdW5jdGlvbiAoZ3JheSkge1xuICAgICAgcmV0dXJuIFswLCAwLCAwLCBncmF5WzBdXTtcbiAgICB9O1xuXG4gICAgY29udmVydC5ncmF5LmxhYiA9IGZ1bmN0aW9uIChncmF5KSB7XG4gICAgICByZXR1cm4gW2dyYXlbMF0sIDAsIDBdO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LmdyYXkuaGV4ID0gZnVuY3Rpb24gKGdyYXkpIHtcbiAgICAgIHZhciB2YWwgPSBNYXRoLnJvdW5kKGdyYXlbMF0gLyAxMDAgKiAyNTUpICYgMHhGRjtcbiAgICAgIHZhciBpbnRlZ2VyID0gKHZhbCA8PCAxNikgKyAodmFsIDw8IDgpICsgdmFsO1xuICAgICAgdmFyIHN0cmluZyA9IGludGVnZXIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xuICAgIH07XG5cbiAgICBjb252ZXJ0LnJnYi5ncmF5ID0gZnVuY3Rpb24gKHJnYikge1xuICAgICAgdmFyIHZhbCA9IChyZ2JbMF0gKyByZ2JbMV0gKyByZ2JbMl0pIC8gMztcbiAgICAgIHJldHVybiBbdmFsIC8gMjU1ICogMTAwXTtcbiAgICB9O1xuICB9KTtcbiAgdmFyIGNvbnZlcnNpb25zXzEkMSA9IGNvbnZlcnNpb25zJDIucmdiO1xuICB2YXIgY29udmVyc2lvbnNfMiQxID0gY29udmVyc2lvbnMkMi5oc2w7XG4gIHZhciBjb252ZXJzaW9uc18zJDEgPSBjb252ZXJzaW9ucyQyLmhzdjtcbiAgdmFyIGNvbnZlcnNpb25zXzQkMSA9IGNvbnZlcnNpb25zJDIuaHdiO1xuICB2YXIgY29udmVyc2lvbnNfNSQxID0gY29udmVyc2lvbnMkMi5jbXlrO1xuICB2YXIgY29udmVyc2lvbnNfNiQxID0gY29udmVyc2lvbnMkMi54eXo7XG4gIHZhciBjb252ZXJzaW9uc183JDEgPSBjb252ZXJzaW9ucyQyLmxhYjtcbiAgdmFyIGNvbnZlcnNpb25zXzgkMSA9IGNvbnZlcnNpb25zJDIubGNoO1xuICB2YXIgY29udmVyc2lvbnNfOSQxID0gY29udmVyc2lvbnMkMi5oZXg7XG4gIHZhciBjb252ZXJzaW9uc18xMCQxID0gY29udmVyc2lvbnMkMi5rZXl3b3JkO1xuICB2YXIgY29udmVyc2lvbnNfMTEkMSA9IGNvbnZlcnNpb25zJDIuYW5zaTE2O1xuICB2YXIgY29udmVyc2lvbnNfMTIkMSA9IGNvbnZlcnNpb25zJDIuYW5zaTI1NjtcbiAgdmFyIGNvbnZlcnNpb25zXzEzJDEgPSBjb252ZXJzaW9ucyQyLmhjZztcbiAgdmFyIGNvbnZlcnNpb25zXzE0JDEgPSBjb252ZXJzaW9ucyQyLmFwcGxlO1xuICB2YXIgY29udmVyc2lvbnNfMTUkMSA9IGNvbnZlcnNpb25zJDIuZ3JheTtcblxuICAvKlxuICBcdHRoaXMgZnVuY3Rpb24gcm91dGVzIGEgbW9kZWwgdG8gYWxsIG90aGVyIG1vZGVscy5cblxuICBcdGFsbCBmdW5jdGlvbnMgdGhhdCBhcmUgcm91dGVkIGhhdmUgYSBwcm9wZXJ0eSBgLmNvbnZlcnNpb25gIGF0dGFjaGVkXG4gIFx0dG8gdGhlIHJldHVybmVkIHN5bnRoZXRpYyBmdW5jdGlvbi4gVGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheVxuICBcdG9mIHN0cmluZ3MsIGVhY2ggd2l0aCB0aGUgc3RlcHMgaW4gYmV0d2VlbiB0aGUgJ2Zyb20nIGFuZCAndG8nXG4gIFx0Y29sb3IgbW9kZWxzIChpbmNsdXNpdmUpLlxuXG4gIFx0Y29udmVyc2lvbnMgdGhhdCBhcmUgbm90IHBvc3NpYmxlIHNpbXBseSBhcmUgbm90IGluY2x1ZGVkLlxuICAqL1xuXG4gIGZ1bmN0aW9uIGJ1aWxkR3JhcGgkMigpIHtcbiAgICB2YXIgZ3JhcGggPSB7fTsgLy8gaHR0cHM6Ly9qc3BlcmYuY29tL29iamVjdC1rZXlzLXZzLWZvci1pbi13aXRoLWNsb3N1cmUvM1xuXG4gICAgdmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zJDIpO1xuXG4gICAgZm9yICh2YXIgbGVuID0gbW9kZWxzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZ3JhcGhbbW9kZWxzW2ldXSA9IHtcbiAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vMS12cy1pbmZpbml0eVxuICAgICAgICAvLyBtaWNyby1vcHQsIGJ1dCB0aGlzIGlzIHNpbXBsZS5cbiAgICAgICAgZGlzdGFuY2U6IC0xLFxuICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0JyZWFkdGgtZmlyc3Rfc2VhcmNoXG5cblxuICBmdW5jdGlvbiBkZXJpdmVCRlMkMihmcm9tTW9kZWwpIHtcbiAgICB2YXIgZ3JhcGggPSBidWlsZEdyYXBoJDIoKTtcbiAgICB2YXIgcXVldWUgPSBbZnJvbU1vZGVsXTsgLy8gdW5zaGlmdCAtPiBxdWV1ZSAtPiBwb3BcblxuICAgIGdyYXBoW2Zyb21Nb2RlbF0uZGlzdGFuY2UgPSAwO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBxdWV1ZS5wb3AoKTtcbiAgICAgIHZhciBhZGphY2VudHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyQyW2N1cnJlbnRdKTtcblxuICAgICAgZm9yICh2YXIgbGVuID0gYWRqYWNlbnRzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgYWRqYWNlbnQgPSBhZGphY2VudHNbaV07XG4gICAgICAgIHZhciBub2RlID0gZ3JhcGhbYWRqYWNlbnRdO1xuXG4gICAgICAgIGlmIChub2RlLmRpc3RhbmNlID09PSAtMSkge1xuICAgICAgICAgIG5vZGUuZGlzdGFuY2UgPSBncmFwaFtjdXJyZW50XS5kaXN0YW5jZSArIDE7XG4gICAgICAgICAgbm9kZS5wYXJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoYWRqYWNlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluayQyKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICByZXR1cm4gdG8oZnJvbShhcmdzKSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBDb252ZXJzaW9uJDIodG9Nb2RlbCwgZ3JhcGgpIHtcbiAgICB2YXIgcGF0aCA9IFtncmFwaFt0b01vZGVsXS5wYXJlbnQsIHRvTW9kZWxdO1xuICAgIHZhciBmbiA9IGNvbnZlcnNpb25zJDJbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcbiAgICB2YXIgY3VyID0gZ3JhcGhbdG9Nb2RlbF0ucGFyZW50O1xuXG4gICAgd2hpbGUgKGdyYXBoW2N1cl0ucGFyZW50KSB7XG4gICAgICBwYXRoLnVuc2hpZnQoZ3JhcGhbY3VyXS5wYXJlbnQpO1xuICAgICAgZm4gPSBsaW5rJDIoY29udmVyc2lvbnMkMltncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuICAgICAgY3VyID0gZ3JhcGhbY3VyXS5wYXJlbnQ7XG4gICAgfVxuXG4gICAgZm4uY29udmVyc2lvbiA9IHBhdGg7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHJvdXRlJDIgPSBmdW5jdGlvbiByb3V0ZShmcm9tTW9kZWwpIHtcbiAgICB2YXIgZ3JhcGggPSBkZXJpdmVCRlMkMihmcm9tTW9kZWwpO1xuICAgIHZhciBjb252ZXJzaW9uID0ge307XG4gICAgdmFyIG1vZGVscyA9IE9iamVjdC5rZXlzKGdyYXBoKTtcblxuICAgIGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciB0b01vZGVsID0gbW9kZWxzW2ldO1xuICAgICAgdmFyIG5vZGUgPSBncmFwaFt0b01vZGVsXTtcblxuICAgICAgaWYgKG5vZGUucGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgIC8vIG5vIHBvc3NpYmxlIGNvbnZlcnNpb24sIG9yIHRoaXMgbm9kZSBpcyB0aGUgc291cmNlIG1vZGVsLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29udmVyc2lvblt0b01vZGVsXSA9IHdyYXBDb252ZXJzaW9uJDIodG9Nb2RlbCwgZ3JhcGgpO1xuICAgIH1cblxuICAgIHJldHVybiBjb252ZXJzaW9uO1xuICB9O1xuXG4gIHZhciBjb252ZXJ0JDMgPSB7fTtcbiAgdmFyIG1vZGVscyQyID0gT2JqZWN0LmtleXMoY29udmVyc2lvbnMkMik7XG5cbiAgZnVuY3Rpb24gd3JhcFJhdyQyKGZuKSB7XG4gICAgdmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIHdyYXBwZWRGbihhcmdzKSB7XG4gICAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkIHx8IGFyZ3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZuKGFyZ3MpO1xuICAgIH07IC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXG5cbiAgICBpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG4gICAgICB3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBwZWRGbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBSb3VuZGVkJDIoZm4pIHtcbiAgICB2YXIgd3JhcHBlZEZuID0gZnVuY3Rpb24gd3JhcHBlZEZuKGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gZm4oYXJncyk7IC8vIHdlJ3JlIGFzc3VtaW5nIHRoZSByZXN1bHQgaXMgYW4gYXJyYXkgaGVyZS5cbiAgICAgIC8vIHNlZSBub3RpY2UgaW4gY29udmVyc2lvbnMuanM7IGRvbid0IHVzZSBib3ggdHlwZXNcbiAgICAgIC8vIGluIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIgbGVuID0gcmVzdWx0Lmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IE1hdGgucm91bmQocmVzdWx0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07IC8vIHByZXNlcnZlIC5jb252ZXJzaW9uIHByb3BlcnR5IGlmIHRoZXJlIGlzIG9uZVxuXG5cbiAgICBpZiAoJ2NvbnZlcnNpb24nIGluIGZuKSB7XG4gICAgICB3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyYXBwZWRGbjtcbiAgfVxuXG4gIG1vZGVscyQyLmZvckVhY2goZnVuY3Rpb24gKGZyb21Nb2RlbCkge1xuICAgIGNvbnZlcnQkM1tmcm9tTW9kZWxdID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnQkM1tmcm9tTW9kZWxdLCAnY2hhbm5lbHMnLCB7XG4gICAgICB2YWx1ZTogY29udmVyc2lvbnMkMltmcm9tTW9kZWxdLmNoYW5uZWxzXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnQkM1tmcm9tTW9kZWxdLCAnbGFiZWxzJywge1xuICAgICAgdmFsdWU6IGNvbnZlcnNpb25zJDJbZnJvbU1vZGVsXS5sYWJlbHNcbiAgICB9KTtcbiAgICB2YXIgcm91dGVzID0gcm91dGUkMihmcm9tTW9kZWwpO1xuICAgIHZhciByb3V0ZU1vZGVscyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG4gICAgcm91dGVNb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAodG9Nb2RlbCkge1xuICAgICAgdmFyIGZuID0gcm91dGVzW3RvTW9kZWxdO1xuICAgICAgY29udmVydCQzW2Zyb21Nb2RlbF1bdG9Nb2RlbF0gPSB3cmFwUm91bmRlZCQyKGZuKTtcbiAgICAgIGNvbnZlcnQkM1tmcm9tTW9kZWxdW3RvTW9kZWxdLnJhdyA9IHdyYXBSYXckMihmbik7XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgY29sb3JDb252ZXJ0JDIgPSBjb252ZXJ0JDM7XG5cbiAgdmFyIGFuc2lTdHlsZXMkMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICAgIGNvbnN0IHdyYXBBbnNpMTYgPSAoZm4sIG9mZnNldCkgPT4gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgY29kZSA9IGZuLmFwcGx5KGNvbG9yQ29udmVydCQyLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIFwiXFx4MUJbXCIuY29uY2F0KGNvZGUgKyBvZmZzZXQsIFwibVwiKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgd3JhcEFuc2kyNTYgPSAoZm4sIG9mZnNldCkgPT4gZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgY29kZSA9IGZuLmFwcGx5KGNvbG9yQ29udmVydCQyLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIFwiXFx4MUJbXCIuY29uY2F0KDM4ICsgb2Zmc2V0LCBcIjs1O1wiKS5jb25jYXQoY29kZSwgXCJtXCIpO1xuICAgIH07XG5cbiAgICBjb25zdCB3cmFwQW5zaTE2bSA9IChmbiwgb2Zmc2V0KSA9PiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCByZ2IgPSBmbi5hcHBseShjb2xvckNvbnZlcnQkMiwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBcIlxceDFCW1wiLmNvbmNhdCgzOCArIG9mZnNldCwgXCI7MjtcIikuY29uY2F0KHJnYlswXSwgXCI7XCIpLmNvbmNhdChyZ2JbMV0sIFwiO1wiKS5jb25jYXQocmdiWzJdLCBcIm1cIik7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzc2VtYmxlU3R5bGVzKCkge1xuICAgICAgY29uc3QgY29kZXMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICAgIG1vZGlmaWVyOiB7XG4gICAgICAgICAgcmVzZXQ6IFswLCAwXSxcbiAgICAgICAgICAvLyAyMSBpc24ndCB3aWRlbHkgc3VwcG9ydGVkIGFuZCAyMiBkb2VzIHRoZSBzYW1lIHRoaW5nXG4gICAgICAgICAgYm9sZDogWzEsIDIyXSxcbiAgICAgICAgICBkaW06IFsyLCAyMl0sXG4gICAgICAgICAgaXRhbGljOiBbMywgMjNdLFxuICAgICAgICAgIHVuZGVybGluZTogWzQsIDI0XSxcbiAgICAgICAgICBpbnZlcnNlOiBbNywgMjddLFxuICAgICAgICAgIGhpZGRlbjogWzgsIDI4XSxcbiAgICAgICAgICBzdHJpa2V0aHJvdWdoOiBbOSwgMjldXG4gICAgICAgIH0sXG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgYmxhY2s6IFszMCwgMzldLFxuICAgICAgICAgIHJlZDogWzMxLCAzOV0sXG4gICAgICAgICAgZ3JlZW46IFszMiwgMzldLFxuICAgICAgICAgIHllbGxvdzogWzMzLCAzOV0sXG4gICAgICAgICAgYmx1ZTogWzM0LCAzOV0sXG4gICAgICAgICAgbWFnZW50YTogWzM1LCAzOV0sXG4gICAgICAgICAgY3lhbjogWzM2LCAzOV0sXG4gICAgICAgICAgd2hpdGU6IFszNywgMzldLFxuICAgICAgICAgIGdyYXk6IFs5MCwgMzldLFxuICAgICAgICAgIC8vIEJyaWdodCBjb2xvclxuICAgICAgICAgIHJlZEJyaWdodDogWzkxLCAzOV0sXG4gICAgICAgICAgZ3JlZW5CcmlnaHQ6IFs5MiwgMzldLFxuICAgICAgICAgIHllbGxvd0JyaWdodDogWzkzLCAzOV0sXG4gICAgICAgICAgYmx1ZUJyaWdodDogWzk0LCAzOV0sXG4gICAgICAgICAgbWFnZW50YUJyaWdodDogWzk1LCAzOV0sXG4gICAgICAgICAgY3lhbkJyaWdodDogWzk2LCAzOV0sXG4gICAgICAgICAgd2hpdGVCcmlnaHQ6IFs5NywgMzldXG4gICAgICAgIH0sXG4gICAgICAgIGJnQ29sb3I6IHtcbiAgICAgICAgICBiZ0JsYWNrOiBbNDAsIDQ5XSxcbiAgICAgICAgICBiZ1JlZDogWzQxLCA0OV0sXG4gICAgICAgICAgYmdHcmVlbjogWzQyLCA0OV0sXG4gICAgICAgICAgYmdZZWxsb3c6IFs0MywgNDldLFxuICAgICAgICAgIGJnQmx1ZTogWzQ0LCA0OV0sXG4gICAgICAgICAgYmdNYWdlbnRhOiBbNDUsIDQ5XSxcbiAgICAgICAgICBiZ0N5YW46IFs0NiwgNDldLFxuICAgICAgICAgIGJnV2hpdGU6IFs0NywgNDldLFxuICAgICAgICAgIC8vIEJyaWdodCBjb2xvclxuICAgICAgICAgIGJnQmxhY2tCcmlnaHQ6IFsxMDAsIDQ5XSxcbiAgICAgICAgICBiZ1JlZEJyaWdodDogWzEwMSwgNDldLFxuICAgICAgICAgIGJnR3JlZW5CcmlnaHQ6IFsxMDIsIDQ5XSxcbiAgICAgICAgICBiZ1llbGxvd0JyaWdodDogWzEwMywgNDldLFxuICAgICAgICAgIGJnQmx1ZUJyaWdodDogWzEwNCwgNDldLFxuICAgICAgICAgIGJnTWFnZW50YUJyaWdodDogWzEwNSwgNDldLFxuICAgICAgICAgIGJnQ3lhbkJyaWdodDogWzEwNiwgNDldLFxuICAgICAgICAgIGJnV2hpdGVCcmlnaHQ6IFsxMDcsIDQ5XVxuICAgICAgICB9XG4gICAgICB9OyAvLyBGaXggaHVtYW5zXG5cbiAgICAgIHN0eWxlcy5jb2xvci5ncmV5ID0gc3R5bGVzLmNvbG9yLmdyYXk7XG5cbiAgICAgIGZvciAoY29uc3QgZ3JvdXBOYW1lIG9mIE9iamVjdC5rZXlzKHN0eWxlcykpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBzdHlsZXNbZ3JvdXBOYW1lXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBvZiBPYmplY3Qua2V5cyhncm91cCkpIHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IGdyb3VwW3N0eWxlTmFtZV07XG4gICAgICAgICAgc3R5bGVzW3N0eWxlTmFtZV0gPSB7XG4gICAgICAgICAgICBvcGVuOiBcIlxceDFCW1wiLmNvbmNhdChzdHlsZVswXSwgXCJtXCIpLFxuICAgICAgICAgICAgY2xvc2U6IFwiXFx4MUJbXCIuY29uY2F0KHN0eWxlWzFdLCBcIm1cIilcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdyb3VwW3N0eWxlTmFtZV0gPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgICAgICBjb2Rlcy5zZXQoc3R5bGVbMF0sIHN0eWxlWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsIGdyb3VwTmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBncm91cCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN0eWxlcywgJ2NvZGVzJywge1xuICAgICAgICAgIHZhbHVlOiBjb2RlcyxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYW5zaTJhbnNpID0gbiA9PiBuO1xuXG4gICAgICBjb25zdCByZ2IycmdiID0gKHIsIGcsIGIpID0+IFtyLCBnLCBiXTtcblxuICAgICAgc3R5bGVzLmNvbG9yLmNsb3NlID0gJ1xcdTAwMUJbMzltJztcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmNsb3NlID0gJ1xcdTAwMUJbNDltJztcbiAgICAgIHN0eWxlcy5jb2xvci5hbnNpID0ge1xuICAgICAgICBhbnNpOiB3cmFwQW5zaTE2KGFuc2kyYW5zaSwgMClcbiAgICAgIH07XG4gICAgICBzdHlsZXMuY29sb3IuYW5zaTI1NiA9IHtcbiAgICAgICAgYW5zaTI1Njogd3JhcEFuc2kyNTYoYW5zaTJhbnNpLCAwKVxuICAgICAgfTtcbiAgICAgIHN0eWxlcy5jb2xvci5hbnNpMTZtID0ge1xuICAgICAgICByZ2I6IHdyYXBBbnNpMTZtKHJnYjJyZ2IsIDApXG4gICAgICB9O1xuICAgICAgc3R5bGVzLmJnQ29sb3IuYW5zaSA9IHtcbiAgICAgICAgYW5zaTogd3JhcEFuc2kxNihhbnNpMmFuc2ksIDEwKVxuICAgICAgfTtcbiAgICAgIHN0eWxlcy5iZ0NvbG9yLmFuc2kyNTYgPSB7XG4gICAgICAgIGFuc2kyNTY6IHdyYXBBbnNpMjU2KGFuc2kyYW5zaSwgMTApXG4gICAgICB9O1xuICAgICAgc3R5bGVzLmJnQ29sb3IuYW5zaTE2bSA9IHtcbiAgICAgICAgcmdiOiB3cmFwQW5zaTE2bShyZ2IycmdiLCAxMClcbiAgICAgIH07XG5cbiAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb2xvckNvbnZlcnQkMikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvckNvbnZlcnQkMltrZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3VpdGUgPSBjb2xvckNvbnZlcnQkMltrZXldO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdhbnNpMTYnKSB7XG4gICAgICAgICAga2V5ID0gJ2Fuc2knO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdhbnNpMTYnIGluIHN1aXRlKSB7XG4gICAgICAgICAgc3R5bGVzLmNvbG9yLmFuc2lba2V5XSA9IHdyYXBBbnNpMTYoc3VpdGUuYW5zaTE2LCAwKTtcbiAgICAgICAgICBzdHlsZXMuYmdDb2xvci5hbnNpW2tleV0gPSB3cmFwQW5zaTE2KHN1aXRlLmFuc2kxNiwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdhbnNpMjU2JyBpbiBzdWl0ZSkge1xuICAgICAgICAgIHN0eWxlcy5jb2xvci5hbnNpMjU2W2tleV0gPSB3cmFwQW5zaTI1NihzdWl0ZS5hbnNpMjU2LCAwKTtcbiAgICAgICAgICBzdHlsZXMuYmdDb2xvci5hbnNpMjU2W2tleV0gPSB3cmFwQW5zaTI1NihzdWl0ZS5hbnNpMjU2LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJ3JnYicgaW4gc3VpdGUpIHtcbiAgICAgICAgICBzdHlsZXMuY29sb3IuYW5zaTE2bVtrZXldID0gd3JhcEFuc2kxNm0oc3VpdGUucmdiLCAwKTtcbiAgICAgICAgICBzdHlsZXMuYmdDb2xvci5hbnNpMTZtW2tleV0gPSB3cmFwQW5zaTE2bShzdWl0ZS5yZ2IsIDEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3R5bGVzO1xuICAgIH0gLy8gTWFrZSB0aGUgZXhwb3J0IGltbXV0YWJsZVxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGFzc2VtYmxlU3R5bGVzXG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnN0IGVudiQzID0gcHJvY2Vzcy5lbnY7XG4gIGxldCBmb3JjZUNvbG9yJDI7XG5cbiAgaWYgKGhhc0ZsYWcoJ25vLWNvbG9yJykgfHwgaGFzRmxhZygnbm8tY29sb3JzJykgfHwgaGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuICAgIGZvcmNlQ29sb3IkMiA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGhhc0ZsYWcoJ2NvbG9yJykgfHwgaGFzRmxhZygnY29sb3JzJykgfHwgaGFzRmxhZygnY29sb3I9dHJ1ZScpIHx8IGhhc0ZsYWcoJ2NvbG9yPWFsd2F5cycpKSB7XG4gICAgZm9yY2VDb2xvciQyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICgnRk9SQ0VfQ09MT1InIGluIGVudiQzKSB7XG4gICAgZm9yY2VDb2xvciQyID0gZW52JDMuRk9SQ0VfQ09MT1IubGVuZ3RoID09PSAwIHx8IHBhcnNlSW50KGVudiQzLkZPUkNFX0NPTE9SLCAxMCkgIT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGVMZXZlbCQyKGxldmVsKSB7XG4gICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxldmVsLFxuICAgICAgaGFzQmFzaWM6IHRydWUsXG4gICAgICBoYXMyNTY6IGxldmVsID49IDIsXG4gICAgICBoYXMxNm06IGxldmVsID49IDNcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3VwcG9ydHNDb2xvciQyKHN0cmVhbSkge1xuICAgIGlmIChmb3JjZUNvbG9yJDIgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoaGFzRmxhZygnY29sb3I9MTZtJykgfHwgaGFzRmxhZygnY29sb3I9ZnVsbCcpIHx8IGhhc0ZsYWcoJ2NvbG9yPXRydWVjb2xvcicpKSB7XG4gICAgICByZXR1cm4gMztcbiAgICB9XG5cbiAgICBpZiAoaGFzRmxhZygnY29sb3I9MjU2JykpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cblxuICAgIGlmIChzdHJlYW0gJiYgIXN0cmVhbS5pc1RUWSAmJiBmb3JjZUNvbG9yJDIgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IGZvcmNlQ29sb3IkMiA/IDEgOiAwO1xuXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICAgIC8vIE5vZGUuanMgNy41LjAgaXMgdGhlIGZpcnN0IHZlcnNpb24gb2YgTm9kZS5qcyB0byBpbmNsdWRlIGEgcGF0Y2ggdG9cbiAgICAgIC8vIGxpYnV2IHRoYXQgZW5hYmxlcyAyNTYgY29sb3Igb3V0cHV0IG9uIFdpbmRvd3MuIEFueXRoaW5nIGVhcmxpZXIgYW5kIGl0XG4gICAgICAvLyB3b24ndCB3b3JrLiBIb3dldmVyLCBoZXJlIHdlIHRhcmdldCBOb2RlLmpzIDggYXQgbWluaW11bSBhcyBpdCBpcyBhbiBMVFNcbiAgICAgIC8vIHJlbGVhc2UsIGFuZCBOb2RlLmpzIDcgaXMgbm90LiBXaW5kb3dzIDEwIGJ1aWxkIDEwNTg2IGlzIHRoZSBmaXJzdCBXaW5kb3dzXG4gICAgICAvLyByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMjU2IGNvbG9ycy4gV2luZG93cyAxMCBidWlsZCAxNDkzMSBpcyB0aGUgZmlyc3QgcmVsZWFzZVxuICAgICAgLy8gdGhhdCBzdXBwb3J0cyAxNm0vVHJ1ZUNvbG9yLlxuICAgICAgY29uc3Qgb3NSZWxlYXNlID0gcmVxdWlyZSQkMCQxLnJlbGVhc2UoKS5zcGxpdCgnLicpO1xuXG4gICAgICBpZiAoTnVtYmVyKHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpWzBdKSA+PSA4ICYmIE51bWJlcihvc1JlbGVhc2VbMF0pID49IDEwICYmIE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2KSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxNDkzMSA/IDMgOiAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoJ0NJJyBpbiBlbnYkMykge1xuICAgICAgaWYgKFsnVFJBVklTJywgJ0NJUkNMRUNJJywgJ0FQUFZFWU9SJywgJ0dJVExBQl9DSSddLnNvbWUoc2lnbiA9PiBzaWduIGluIGVudiQzKSB8fCBlbnYkMy5DSV9OQU1FID09PSAnY29kZXNoaXAnKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cblxuICAgIGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52JDMpIHtcbiAgICAgIHJldHVybiAvXig5XFwuKDAqWzEtOV1cXGQqKVxcLnxcXGR7Mix9XFwuKS8udGVzdChlbnYkMy5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuICAgIH1cblxuICAgIGlmIChlbnYkMy5DT0xPUlRFUk0gPT09ICd0cnVlY29sb3InKSB7XG4gICAgICByZXR1cm4gMztcbiAgICB9XG5cbiAgICBpZiAoJ1RFUk1fUFJPR1JBTScgaW4gZW52JDMpIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludCgoZW52JDMuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuICAgICAgc3dpdGNoIChlbnYkMy5URVJNX1BST0dSQU0pIHtcbiAgICAgICAgY2FzZSAnaVRlcm0uYXBwJzpcbiAgICAgICAgICByZXR1cm4gdmVyc2lvbiA+PSAzID8gMyA6IDI7XG5cbiAgICAgICAgY2FzZSAnQXBwbGVfVGVybWluYWwnOlxuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAvLyBObyBkZWZhdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKC8tMjU2KGNvbG9yKT8kL2kudGVzdChlbnYkMy5URVJNKSkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuXG4gICAgaWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYkMy5URVJNKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCdDT0xPUlRFUk0nIGluIGVudiQzKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoZW52JDMuVEVSTSA9PT0gJ2R1bWInKSB7XG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cblxuICAgIHJldHVybiBtaW47XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdXBwb3J0TGV2ZWwkMihzdHJlYW0pIHtcbiAgICBjb25zdCBsZXZlbCA9IHN1cHBvcnRzQ29sb3IkMihzdHJlYW0pO1xuICAgIHJldHVybiB0cmFuc2xhdGVMZXZlbCQyKGxldmVsKTtcbiAgfVxuXG4gIHZhciBzdXBwb3J0c0NvbG9yXzEkMiA9IHtcbiAgICBzdXBwb3J0c0NvbG9yOiBnZXRTdXBwb3J0TGV2ZWwkMixcbiAgICBzdGRvdXQ6IGdldFN1cHBvcnRMZXZlbCQyKHByb2Nlc3Muc3Rkb3V0KSxcbiAgICBzdGRlcnI6IGdldFN1cHBvcnRMZXZlbCQyKHByb2Nlc3Muc3RkZXJyKVxuICB9O1xuXG4gIGNvbnN0IFRFTVBMQVRFX1JFR0VYJDIgPSAvKD86XFxcXCh1W2EtZlxcZF17NH18eFthLWZcXGRdezJ9fC4pKXwoPzpcXHsofik/KFxcdysoPzpcXChbXildKlxcKSk/KD86XFwuXFx3Kyg/OlxcKFteKV0qXFwpKT8pKikoPzpbIFxcdF18KD89XFxyP1xcbikpKXwoXFx9KXwoKD86LnxbXFxyXFxuXFxmXSkrPykvZ2k7XG4gIGNvbnN0IFNUWUxFX1JFR0VYJDIgPSAvKD86XnxcXC4pKFxcdyspKD86XFwoKFteKV0qKVxcKSk/L2c7XG4gIGNvbnN0IFNUUklOR19SRUdFWCQyID0gL14oWydcIl0pKCg/OlxcXFwufCg/IVxcMSlbXlxcXFxdKSopXFwxJC87XG4gIGNvbnN0IEVTQ0FQRV9SRUdFWCQyID0gL1xcXFwodVthLWZcXGRdezR9fHhbYS1mXFxkXXsyfXwuKXwoW15cXFxcXSkvZ2k7XG4gIGNvbnN0IEVTQ0FQRVMkMiA9IG5ldyBNYXAoW1snbicsICdcXG4nXSwgWydyJywgJ1xcciddLCBbJ3QnLCAnXFx0J10sIFsnYicsICdcXGInXSwgWydmJywgJ1xcZiddLCBbJ3YnLCAnXFx2J10sIFsnMCcsICdcXDAnXSwgWydcXFxcJywgJ1xcXFwnXSwgWydlJywgJ1xcdTAwMUInXSwgWydhJywgJ1xcdTAwMDcnXV0pO1xuXG4gIGZ1bmN0aW9uIHVuZXNjYXBlJDIoYykge1xuICAgIGlmIChjWzBdID09PSAndScgJiYgYy5sZW5ndGggPT09IDUgfHwgY1swXSA9PT0gJ3gnICYmIGMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjLnNsaWNlKDEpLCAxNikpO1xuICAgIH1cblxuICAgIHJldHVybiBFU0NBUEVTJDIuZ2V0KGMpIHx8IGM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyQyKG5hbWUsIGFyZ3MpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgY2h1bmtzID0gYXJncy50cmltKCkuc3BsaXQoL1xccyosXFxzKi9nKTtcbiAgICBsZXQgbWF0Y2hlcztcblxuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICBpZiAoIWlzTmFOKGNodW5rKSkge1xuICAgICAgICByZXN1bHRzLnB1c2goTnVtYmVyKGNodW5rKSk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoZXMgPSBjaHVuay5tYXRjaChTVFJJTkdfUkVHRVgkMikpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKG1hdGNoZXNbMl0ucmVwbGFjZShFU0NBUEVfUkVHRVgkMiwgKG0sIGVzY2FwZSwgY2hyKSA9PiBlc2NhcGUgPyB1bmVzY2FwZSQyKGVzY2FwZSkgOiBjaHIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgQ2hhbGsgdGVtcGxhdGUgc3R5bGUgYXJndW1lbnQ6IFwiLmNvbmNhdChjaHVuaywgXCIgKGluIHN0eWxlICdcIikuY29uY2F0KG5hbWUsIFwiJylcIikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdHlsZSQyKHN0eWxlKSB7XG4gICAgU1RZTEVfUkVHRVgkMi5sYXN0SW5kZXggPSAwO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgbWF0Y2hlcztcblxuICAgIHdoaWxlICgobWF0Y2hlcyA9IFNUWUxFX1JFR0VYJDIuZXhlYyhzdHlsZSkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBuYW1lID0gbWF0Y2hlc1sxXTtcblxuICAgICAgaWYgKG1hdGNoZXNbMl0pIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHBhcnNlQXJndW1lbnRzJDIobmFtZSwgbWF0Y2hlc1syXSk7XG4gICAgICAgIHJlc3VsdHMucHVzaChbbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRTdHlsZSQyKGNoYWxrLCBzdHlsZXMpIHtcbiAgICBjb25zdCBlbmFibGVkID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHN0eWxlcykge1xuICAgICAgZm9yIChjb25zdCBzdHlsZSBvZiBsYXllci5zdHlsZXMpIHtcbiAgICAgICAgZW5hYmxlZFtzdHlsZVswXV0gPSBsYXllci5pbnZlcnNlID8gbnVsbCA6IHN0eWxlLnNsaWNlKDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBjdXJyZW50ID0gY2hhbGs7XG5cbiAgICBmb3IgKGNvbnN0IHN0eWxlTmFtZSBvZiBPYmplY3Qua2V5cyhlbmFibGVkKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZFtzdHlsZU5hbWVdKSkge1xuICAgICAgICBpZiAoIShzdHlsZU5hbWUgaW4gY3VycmVudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIENoYWxrIHN0eWxlOiBcIi5jb25jYXQoc3R5bGVOYW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5hYmxlZFtzdHlsZU5hbWVdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtzdHlsZU5hbWVdLmFwcGx5KGN1cnJlbnQsIGVuYWJsZWRbc3R5bGVOYW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbc3R5bGVOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgdmFyIHRlbXBsYXRlcyQyID0gKGNoYWxrLCB0bXApID0+IHtcbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICBsZXQgY2h1bmsgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcblxuICAgIHRtcC5yZXBsYWNlKFRFTVBMQVRFX1JFR0VYJDIsIChtLCBlc2NhcGVDaGFyLCBpbnZlcnNlLCBzdHlsZSwgY2xvc2UsIGNocikgPT4ge1xuICAgICAgaWYgKGVzY2FwZUNoYXIpIHtcbiAgICAgICAgY2h1bmsucHVzaCh1bmVzY2FwZSQyKGVzY2FwZUNoYXIpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGUpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gY2h1bmsuam9pbignJyk7XG4gICAgICAgIGNodW5rID0gW107XG4gICAgICAgIGNodW5rcy5wdXNoKHN0eWxlcy5sZW5ndGggPT09IDAgPyBzdHIgOiBidWlsZFN0eWxlJDIoY2hhbGssIHN0eWxlcykoc3RyKSk7XG4gICAgICAgIHN0eWxlcy5wdXNoKHtcbiAgICAgICAgICBpbnZlcnNlLFxuICAgICAgICAgIHN0eWxlczogcGFyc2VTdHlsZSQyKHN0eWxlKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2xvc2UpIHtcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGV4dHJhbmVvdXMgfSBpbiBDaGFsayB0ZW1wbGF0ZSBsaXRlcmFsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVua3MucHVzaChidWlsZFN0eWxlJDIoY2hhbGssIHN0eWxlcykoY2h1bmsuam9pbignJykpKTtcbiAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgc3R5bGVzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmsucHVzaChjaHIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNodW5rcy5wdXNoKGNodW5rLmpvaW4oJycpKTtcblxuICAgIGlmIChzdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZXJyTXNnID0gXCJDaGFsayB0ZW1wbGF0ZSBsaXRlcmFsIGlzIG1pc3NpbmcgXCIuY29uY2F0KHN0eWxlcy5sZW5ndGgsIFwiIGNsb3NpbmcgYnJhY2tldFwiKS5jb25jYXQoc3R5bGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJ3MnLCBcIiAoYH1gKVwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgIH1cblxuICAgIHJldHVybiBjaHVua3Muam9pbignJyk7XG4gIH07XG5cbiAgdmFyIGNoYWxrJDIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cbiAgICBjb25zdCBzdGRvdXRDb2xvciA9IHN1cHBvcnRzQ29sb3JfMSQyLnN0ZG91dDtcbiAgICBjb25zdCBpc1NpbXBsZVdpbmRvd3NUZXJtID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyAmJiAhKHByb2Nlc3MuZW52LlRFUk0gfHwgJycpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgneHRlcm0nKTsgLy8gYHN1cHBvcnRzQ29sb3IubGV2ZWxgIOKGkiBgYW5zaVN0eWxlcy5jb2xvcltuYW1lXWAgbWFwcGluZ1xuXG4gICAgY29uc3QgbGV2ZWxNYXBwaW5nID0gWydhbnNpJywgJ2Fuc2knLCAnYW5zaTI1NicsICdhbnNpMTZtJ107IC8vIGBjb2xvci1jb252ZXJ0YCBtb2RlbHMgdG8gZXhjbHVkZSBmcm9tIHRoZSBDaGFsayBBUEkgZHVlIHRvIGNvbmZsaWN0cyBhbmQgc3VjaFxuXG4gICAgY29uc3Qgc2tpcE1vZGVscyA9IG5ldyBTZXQoWydncmF5J10pO1xuICAgIGNvbnN0IHN0eWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBmdW5jdGlvbiBhcHBseU9wdGlvbnMob2JqLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRGV0ZWN0IGxldmVsIGlmIG5vdCBzZXQgbWFudWFsbHlcblxuICAgICAgY29uc3Qgc2NMZXZlbCA9IHN0ZG91dENvbG9yID8gc3Rkb3V0Q29sb3IubGV2ZWwgOiAwO1xuICAgICAgb2JqLmxldmVsID0gb3B0aW9ucy5sZXZlbCA9PT0gdW5kZWZpbmVkID8gc2NMZXZlbCA6IG9wdGlvbnMubGV2ZWw7XG4gICAgICBvYmouZW5hYmxlZCA9ICdlbmFibGVkJyBpbiBvcHRpb25zID8gb3B0aW9ucy5lbmFibGVkIDogb2JqLmxldmVsID4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDaGFsayhvcHRpb25zKSB7XG4gICAgICAvLyBXZSBjaGVjayBmb3IgdGhpcy50ZW1wbGF0ZSBoZXJlIHNpbmNlIGNhbGxpbmcgYGNoYWxrLmNvbnN0cnVjdG9yKClgXG4gICAgICAvLyBieSBpdHNlbGYgd2lsbCBoYXZlIGEgYHRoaXNgIG9mIGEgcHJldmlvdXNseSBjb25zdHJ1Y3RlZCBjaGFsayBvYmplY3RcbiAgICAgIGlmICghdGhpcyB8fCAhKHRoaXMgaW5zdGFuY2VvZiBDaGFsaykgfHwgdGhpcy50ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBjaGFsayA9IHt9O1xuICAgICAgICBhcHBseU9wdGlvbnMoY2hhbGssIG9wdGlvbnMpO1xuXG4gICAgICAgIGNoYWxrLnRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgcmV0dXJuIGNoYWxrVGFnLmFwcGx5KG51bGwsIFtjaGFsay50ZW1wbGF0ZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2hhbGssIENoYWxrLnByb3RvdHlwZSk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFsay50ZW1wbGF0ZSwgY2hhbGspO1xuICAgICAgICBjaGFsay50ZW1wbGF0ZS5jb25zdHJ1Y3RvciA9IENoYWxrO1xuICAgICAgICByZXR1cm4gY2hhbGsudGVtcGxhdGU7XG4gICAgICB9XG5cbiAgICAgIGFwcGx5T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9IC8vIFVzZSBicmlnaHQgYmx1ZSBvbiBXaW5kb3dzIGFzIHRoZSBub3JtYWwgYmx1ZSBjb2xvciBpcyBpbGxlZ2libGVcblxuXG4gICAgaWYgKGlzU2ltcGxlV2luZG93c1Rlcm0pIHtcbiAgICAgIGFuc2lTdHlsZXMkMi5ibHVlLm9wZW4gPSAnXFx1MDAxQls5NG0nO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFuc2lTdHlsZXMkMikpIHtcbiAgICAgIGFuc2lTdHlsZXMkMltrZXldLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cCQxKGFuc2lTdHlsZXMkMltrZXldLmNsb3NlKSwgJ2cnKTtcbiAgICAgIHN0eWxlc1trZXldID0ge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgY29kZXMgPSBhbnNpU3R5bGVzJDJba2V5XTtcbiAgICAgICAgICByZXR1cm4gYnVpbGQuY2FsbCh0aGlzLCB0aGlzLl9zdHlsZXMgPyB0aGlzLl9zdHlsZXMuY29uY2F0KGNvZGVzKSA6IFtjb2Rlc10sIHRoaXMuX2VtcHR5LCBrZXkpO1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgc3R5bGVzLnZpc2libGUgPSB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBidWlsZC5jYWxsKHRoaXMsIHRoaXMuX3N0eWxlcyB8fCBbXSwgdHJ1ZSwgJ3Zpc2libGUnKTtcbiAgICAgIH1cblxuICAgIH07XG4gICAgYW5zaVN0eWxlcyQyLmNvbG9yLmNsb3NlUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVN0cmluZ1JlZ2V4cCQxKGFuc2lTdHlsZXMkMi5jb2xvci5jbG9zZSksICdnJyk7XG5cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC5rZXlzKGFuc2lTdHlsZXMkMi5jb2xvci5hbnNpKSkge1xuICAgICAgaWYgKHNraXBNb2RlbHMuaGFzKG1vZGVsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVzW21vZGVsXSA9IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxldmVsID0gdGhpcy5sZXZlbDtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3Qgb3BlbiA9IGFuc2lTdHlsZXMkMi5jb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVzID0ge1xuICAgICAgICAgICAgICBvcGVuLFxuICAgICAgICAgICAgICBjbG9zZTogYW5zaVN0eWxlcyQyLmNvbG9yLmNsb3NlLFxuICAgICAgICAgICAgICBjbG9zZVJlOiBhbnNpU3R5bGVzJDIuY29sb3IuY2xvc2VSZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZC5jYWxsKHRoaXMsIHRoaXMuX3N0eWxlcyA/IHRoaXMuX3N0eWxlcy5jb25jYXQoY29kZXMpIDogW2NvZGVzXSwgdGhpcy5fZW1wdHksIG1vZGVsKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgYW5zaVN0eWxlcyQyLmJnQ29sb3IuY2xvc2VSZSA9IG5ldyBSZWdFeHAoZXNjYXBlU3RyaW5nUmVnZXhwJDEoYW5zaVN0eWxlcyQyLmJnQ29sb3IuY2xvc2UpLCAnZycpO1xuXG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3Qua2V5cyhhbnNpU3R5bGVzJDIuYmdDb2xvci5hbnNpKSkge1xuICAgICAgaWYgKHNraXBNb2RlbHMuaGFzKG1vZGVsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmdNb2RlbCA9ICdiZycgKyBtb2RlbFswXS50b1VwcGVyQ2FzZSgpICsgbW9kZWwuc2xpY2UoMSk7XG4gICAgICBzdHlsZXNbYmdNb2RlbF0gPSB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBjb25zdCBsZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW4gPSBhbnNpU3R5bGVzJDIuYmdDb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVzID0ge1xuICAgICAgICAgICAgICBvcGVuLFxuICAgICAgICAgICAgICBjbG9zZTogYW5zaVN0eWxlcyQyLmJnQ29sb3IuY2xvc2UsXG4gICAgICAgICAgICAgIGNsb3NlUmU6IGFuc2lTdHlsZXMkMi5iZ0NvbG9yLmNsb3NlUmVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYnVpbGQuY2FsbCh0aGlzLCB0aGlzLl9zdHlsZXMgPyB0aGlzLl9zdHlsZXMuY29uY2F0KGNvZGVzKSA6IFtjb2Rlc10sIHRoaXMuX2VtcHR5LCBtb2RlbCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoKCkgPT4ge30sIHN0eWxlcyk7XG5cbiAgICBmdW5jdGlvbiBidWlsZChfc3R5bGVzLCBfZW1wdHksIGtleSkge1xuICAgICAgY29uc3QgYnVpbGRlciA9IGZ1bmN0aW9uIGJ1aWxkZXIoKSB7XG4gICAgICAgIHJldHVybiBhcHBseVN0eWxlLmFwcGx5KGJ1aWxkZXIsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBidWlsZGVyLl9zdHlsZXMgPSBfc3R5bGVzO1xuICAgICAgYnVpbGRlci5fZW1wdHkgPSBfZW1wdHk7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidWlsZGVyLCAnbGV2ZWwnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBzZWxmLmxldmVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldChsZXZlbCkge1xuICAgICAgICAgIHNlbGYubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidWlsZGVyLCAnZW5hYmxlZCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuZW5hYmxlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQoZW5hYmxlZCkge1xuICAgICAgICAgIHNlbGYuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cblxuICAgICAgfSk7IC8vIFNlZSBiZWxvdyBmb3IgZml4IHJlZ2FyZGluZyBpbnZpc2libGUgZ3JleS9kaW0gY29tYmluYXRpb24gb24gV2luZG93c1xuXG4gICAgICBidWlsZGVyLmhhc0dyZXkgPSB0aGlzLmhhc0dyZXkgfHwga2V5ID09PSAnZ3JheScgfHwga2V5ID09PSAnZ3JleSc7IC8vIGBfX3Byb3RvX19gIGlzIHVzZWQgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcbiAgICAgIC8vIG5vIHdheSB0byBjcmVhdGUgYSBmdW5jdGlvbiB3aXRoIGEgZGlmZmVyZW50IHByb3RvdHlwZVxuXG4gICAgICBidWlsZGVyLl9fcHJvdG9fXyA9IHByb3RvOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5U3R5bGUoKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhcmFncywgYnV0IHNpbXBseSBjYXN0IHRvIHN0cmluZyBpbiBjYXNlIHRoZXJlJ3Mgb25seSBvbmUgYXJnXG4gICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgY29uc3QgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoO1xuICAgICAgbGV0IHN0ciA9IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuXG4gICAgICBpZiAoYXJnc0xlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdzTGVuID4gMSkge1xuICAgICAgICAvLyBEb24ndCBzbGljZSBgYXJndW1lbnRzYCwgaXQgcHJldmVudHMgVjggb3B0aW1pemF0aW9uc1xuICAgICAgICBmb3IgKGxldCBhID0gMTsgYSA8IGFyZ3NMZW47IGErKykge1xuICAgICAgICAgIHN0ciArPSAnICcgKyBhcmdzW2FdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8IHRoaXMubGV2ZWwgPD0gMCB8fCAhc3RyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbXB0eSA/ICcnIDogc3RyO1xuICAgICAgfSAvLyBUdXJucyBvdXQgdGhhdCBvbiBXaW5kb3dzIGRpbW1lZCBncmF5IHRleHQgYmVjb21lcyBpbnZpc2libGUgaW4gY21kLmV4ZSxcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhbGsvY2hhbGsvaXNzdWVzLzU4XG4gICAgICAvLyBJZiB3ZSdyZSBvbiBXaW5kb3dzIGFuZCB3ZSdyZSBkZWFsaW5nIHdpdGggYSBncmF5IGNvbG9yLCB0ZW1wb3JhcmlseSBtYWtlICdkaW0nIGEgbm9vcC5cblxuXG4gICAgICBjb25zdCBvcmlnaW5hbERpbSA9IGFuc2lTdHlsZXMkMi5kaW0ub3BlbjtcblxuICAgICAgaWYgKGlzU2ltcGxlV2luZG93c1Rlcm0gJiYgdGhpcy5oYXNHcmV5KSB7XG4gICAgICAgIGFuc2lTdHlsZXMkMi5kaW0ub3BlbiA9ICcnO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGNvZGUgb2YgdGhpcy5fc3R5bGVzLnNsaWNlKCkucmV2ZXJzZSgpKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgYW55IGluc3RhbmNlcyBhbHJlYWR5IHByZXNlbnQgd2l0aCBhIHJlLW9wZW5pbmcgY29kZVxuICAgICAgICAvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG4gICAgICAgIC8vIHdpbGwgYmUgY29sb3JlZCwgYW5kIHRoZSByZXN0IHdpbGwgc2ltcGx5IGJlICdwbGFpbicuXG4gICAgICAgIHN0ciA9IGNvZGUub3BlbiArIHN0ci5yZXBsYWNlKGNvZGUuY2xvc2VSZSwgY29kZS5vcGVuKSArIGNvZGUuY2xvc2U7IC8vIENsb3NlIHRoZSBzdHlsaW5nIGJlZm9yZSBhIGxpbmVicmVhayBhbmQgcmVvcGVuXG4gICAgICAgIC8vIGFmdGVyIG5leHQgbGluZSB0byBmaXggYSBibGVlZCBpc3N1ZSBvbiBtYWNPU1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhbGsvY2hhbGsvcHVsbC85MlxuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXHI/XFxuL2csIFwiXCIuY29uY2F0KGNvZGUuY2xvc2UsIFwiJCZcIikuY29uY2F0KGNvZGUub3BlbikpO1xuICAgICAgfSAvLyBSZXNldCB0aGUgb3JpZ2luYWwgYGRpbWAgaWYgd2UgY2hhbmdlZCBpdCB0byB3b3JrIGFyb3VuZCB0aGUgV2luZG93cyBkaW1tZWQgZ3JheSBpc3N1ZVxuXG5cbiAgICAgIGFuc2lTdHlsZXMkMi5kaW0ub3BlbiA9IG9yaWdpbmFsRGltO1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFsa1RhZyhjaGFsaywgc3RyaW5ncykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0cmluZ3MpKSB7XG4gICAgICAgIC8vIElmIGNoYWxrKCkgd2FzIGNhbGxlZCBieSBpdHNlbGYgb3Igd2l0aCBhIHN0cmluZyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBzdHJpbmcgaXRzZWxmIGFzIGEgc3RyaW5nLlxuICAgICAgICByZXR1cm4gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgIGNvbnN0IHBhcnRzID0gW3N0cmluZ3MucmF3WzBdXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goU3RyaW5nKGFyZ3NbaSAtIDFdKS5yZXBsYWNlKC9be31cXFxcXS9nLCAnXFxcXCQmJykpO1xuICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZyhzdHJpbmdzLnJhd1tpXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGVtcGxhdGVzJDIoY2hhbGssIHBhcnRzLmpvaW4oJycpKTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFsay5wcm90b3R5cGUsIHN0eWxlcyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDaGFsaygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblxuICAgIG1vZHVsZS5leHBvcnRzLnN1cHBvcnRzQ29sb3IgPSBzdGRvdXRDb2xvcjtcbiAgICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7IC8vIEZvciBUeXBlU2NyaXB0XG4gIH0pO1xuICB2YXIgY2hhbGtfMSQxID0gY2hhbGskMi5zdXBwb3J0c0NvbG9yO1xuXG4gIHZhciBsaWIkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzLnNob3VsZEhpZ2hsaWdodCA9IHNob3VsZEhpZ2hsaWdodDtcbiAgICBleHBvcnRzLmdldENoYWxrID0gZ2V0Q2hhbGs7XG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gaGlnaGxpZ2h0O1xuXG4gICAgdmFyIF9qc1Rva2VucyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGpzVG9rZW5zKTtcblxuICAgIHZhciBfZXN1dGlscyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQodXRpbHMkMSk7XG5cbiAgICB2YXIgX2NoYWxrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChjaGFsayQyKTtcblxuICAgIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgICAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuICAgICAgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gICAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWZhdWx0OiBvYmpcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7XG5cbiAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdPYmogPSB7fTtcbiAgICAgIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERlZnMoY2hhbGspIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleXdvcmQ6IGNoYWxrLmN5YW4sXG4gICAgICAgIGNhcGl0YWxpemVkOiBjaGFsay55ZWxsb3csXG4gICAgICAgIGpzeF90YWc6IGNoYWxrLnllbGxvdyxcbiAgICAgICAgcHVuY3R1YXRvcjogY2hhbGsueWVsbG93LFxuICAgICAgICBudW1iZXI6IGNoYWxrLm1hZ2VudGEsXG4gICAgICAgIHN0cmluZzogY2hhbGsuZ3JlZW4sXG4gICAgICAgIHJlZ2V4OiBjaGFsay5tYWdlbnRhLFxuICAgICAgICBjb21tZW50OiBjaGFsay5ncmV5LFxuICAgICAgICBpbnZhbGlkOiBjaGFsay53aGl0ZS5iZ1JlZC5ib2xkXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IE5FV0xJTkUgPSAvXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuICAgIGNvbnN0IEpTWF9UQUcgPSAvXlthLXpdW1xcdy1dKiQvaTtcbiAgICBjb25zdCBCUkFDS0VUID0gL15bKClbXFxde31dJC87XG5cbiAgICBmdW5jdGlvbiBnZXRUb2tlblR5cGUobWF0Y2gpIHtcbiAgICAgIGNvbnN0IFtvZmZzZXQsIHRleHRdID0gbWF0Y2guc2xpY2UoLTIpO1xuICAgICAgY29uc3QgdG9rZW4gPSAoMCwgX2pzVG9rZW5zLm1hdGNoVG9Ub2tlbikobWF0Y2gpO1xuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgaWYgKF9lc3V0aWxzLmRlZmF1bHQua2V5d29yZC5pc1Jlc2VydmVkV29yZEVTNih0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSlNYX1RBRy50ZXN0KHRva2VuLnZhbHVlKSAmJiAodGV4dFtvZmZzZXQgLSAxXSA9PT0gXCI8XCIgfHwgdGV4dC5zdWJzdHIob2Zmc2V0IC0gMiwgMikgPT0gXCI8L1wiKSkge1xuICAgICAgICAgIHJldHVybiBcImpzeF90YWdcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi52YWx1ZVswXSAhPT0gdG9rZW4udmFsdWVbMF0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiBcImNhcGl0YWxpemVkXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwicHVuY3R1YXRvclwiICYmIEJSQUNLRVQudGVzdCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gXCJpbnZhbGlkXCIgJiYgKHRva2VuLnZhbHVlID09PSBcIkBcIiB8fCB0b2tlbi52YWx1ZSA9PT0gXCIjXCIpKSB7XG4gICAgICAgIHJldHVybiBcInB1bmN0dWF0b3JcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VuLnR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0VG9rZW5zKGRlZnMsIHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoX2pzVG9rZW5zLmRlZmF1bHQsIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRUb2tlblR5cGUoYXJncyk7XG4gICAgICAgIGNvbnN0IGNvbG9yaXplID0gZGVmc1t0eXBlXTtcblxuICAgICAgICBpZiAoY29sb3JpemUpIHtcbiAgICAgICAgICByZXR1cm4gYXJnc1swXS5zcGxpdChORVdMSU5FKS5tYXAoc3RyID0+IGNvbG9yaXplKHN0cikpLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZEhpZ2hsaWdodChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gX2NoYWxrLmRlZmF1bHQuc3VwcG9ydHNDb2xvciB8fCBvcHRpb25zLmZvcmNlQ29sb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2hhbGsob3B0aW9ucykge1xuICAgICAgbGV0IGNoYWxrID0gX2NoYWxrLmRlZmF1bHQ7XG5cbiAgICAgIGlmIChvcHRpb25zLmZvcmNlQ29sb3IpIHtcbiAgICAgICAgY2hhbGsgPSBuZXcgX2NoYWxrLmRlZmF1bHQuY29uc3RydWN0b3Ioe1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbGV2ZWw6IDFcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFsaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoaWdobGlnaHQoY29kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICBpZiAoc2hvdWxkSGlnaGxpZ2h0KG9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0IGNoYWxrID0gZ2V0Q2hhbGsob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRlZnMgPSBnZXREZWZzKGNoYWxrKTtcbiAgICAgICAgcmV0dXJuIGhpZ2hsaWdodFRva2VucyhkZWZzLCBjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMobGliJDEpO1xuICB2YXIgbGliXzEgPSBsaWIkMS5zaG91bGRIaWdobGlnaHQ7XG4gIHZhciBsaWJfMiA9IGxpYiQxLmdldENoYWxrO1xuXG4gIHZhciBsaWIkMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzLmNvZGVGcmFtZUNvbHVtbnMgPSBjb2RlRnJhbWVDb2x1bW5zO1xuICAgIGV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0O1xuXG4gICAgdmFyIF9oaWdobGlnaHQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChsaWIkMSk7XG5cbiAgICBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XG4gICAgICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgICBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICAgIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlZmF1bHQ6IG9ialxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld09iaiA9IHt9O1xuICAgICAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdPYmouZGVmYXVsdCA9IG9iajtcblxuICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxuXG4gICAgbGV0IGRlcHJlY2F0aW9uV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBnZXREZWZzKGNoYWxrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBndXR0ZXI6IGNoYWxrLmdyZXksXG4gICAgICAgIG1hcmtlcjogY2hhbGsucmVkLmJvbGQsXG4gICAgICAgIG1lc3NhZ2U6IGNoYWxrLnJlZC5ib2xkXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IE5FV0xJTkUgPSAvXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuXG4gICAgZnVuY3Rpb24gZ2V0TWFya2VyTGluZXMobG9jLCBzb3VyY2UsIG9wdHMpIHtcbiAgICAgIGNvbnN0IHN0YXJ0TG9jID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgbGluZTogLTFcbiAgICAgIH0sIGxvYy5zdGFydCk7XG4gICAgICBjb25zdCBlbmRMb2MgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFydExvYywge30sIGxvYy5lbmQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lc0Fib3ZlID0gMixcbiAgICAgICAgbGluZXNCZWxvdyA9IDNcbiAgICAgIH0gPSBvcHRzIHx8IHt9O1xuICAgICAgY29uc3Qgc3RhcnRMaW5lID0gc3RhcnRMb2MubGluZTtcbiAgICAgIGNvbnN0IHN0YXJ0Q29sdW1uID0gc3RhcnRMb2MuY29sdW1uO1xuICAgICAgY29uc3QgZW5kTGluZSA9IGVuZExvYy5saW5lO1xuICAgICAgY29uc3QgZW5kQ29sdW1uID0gZW5kTG9jLmNvbHVtbjtcbiAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHN0YXJ0TGluZSAtIChsaW5lc0Fib3ZlICsgMSksIDApO1xuICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHNvdXJjZS5sZW5ndGgsIGVuZExpbmUgKyBsaW5lc0JlbG93KTtcblxuICAgICAgaWYgKHN0YXJ0TGluZSA9PT0gLTEpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kTGluZSA9PT0gLTEpIHtcbiAgICAgICAgZW5kID0gc291cmNlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGluZURpZmYgPSBlbmRMaW5lIC0gc3RhcnRMaW5lO1xuICAgICAgY29uc3QgbWFya2VyTGluZXMgPSB7fTtcblxuICAgICAgaWYgKGxpbmVEaWZmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxpbmVEaWZmOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsaW5lTnVtYmVyID0gaSArIHN0YXJ0TGluZTtcblxuICAgICAgICAgIGlmICghc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgIG1hcmtlckxpbmVzW2xpbmVOdW1iZXJdID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUxlbmd0aCA9IHNvdXJjZVtsaW5lTnVtYmVyIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgbWFya2VyTGluZXNbbGluZU51bWJlcl0gPSBbc3RhcnRDb2x1bW4sIHNvdXJjZUxlbmd0aCAtIHN0YXJ0Q29sdW1uICsgMV07XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSBsaW5lRGlmZikge1xuICAgICAgICAgICAgbWFya2VyTGluZXNbbGluZU51bWJlcl0gPSBbMCwgZW5kQ29sdW1uXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTGVuZ3RoID0gc291cmNlW2xpbmVOdW1iZXIgLSBpXS5sZW5ndGg7XG4gICAgICAgICAgICBtYXJrZXJMaW5lc1tsaW5lTnVtYmVyXSA9IFswLCBzb3VyY2VMZW5ndGhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0Q29sdW1uID09PSBlbmRDb2x1bW4pIHtcbiAgICAgICAgICBpZiAoc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgIG1hcmtlckxpbmVzW3N0YXJ0TGluZV0gPSBbc3RhcnRDb2x1bW4sIDBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrZXJMaW5lc1tzdGFydExpbmVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya2VyTGluZXNbc3RhcnRMaW5lXSA9IFtzdGFydENvbHVtbiwgZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW5dO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIG1hcmtlckxpbmVzXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvZGVGcmFtZUNvbHVtbnMocmF3TGluZXMsIGxvYywgb3B0cyA9IHt9KSB7XG4gICAgICBjb25zdCBoaWdobGlnaHRlZCA9IChvcHRzLmhpZ2hsaWdodENvZGUgfHwgb3B0cy5mb3JjZUNvbG9yKSAmJiAoMCwgX2hpZ2hsaWdodC5zaG91bGRIaWdobGlnaHQpKG9wdHMpO1xuICAgICAgY29uc3QgY2hhbGsgPSAoMCwgX2hpZ2hsaWdodC5nZXRDaGFsaykob3B0cyk7XG4gICAgICBjb25zdCBkZWZzID0gZ2V0RGVmcyhjaGFsayk7XG5cbiAgICAgIGNvbnN0IG1heWJlSGlnaGxpZ2h0ID0gKGNoYWxrRm4sIHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgPyBjaGFsa0ZuKHN0cmluZykgOiBzdHJpbmc7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBsaW5lcyA9IHJhd0xpbmVzLnNwbGl0KE5FV0xJTkUpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICBtYXJrZXJMaW5lc1xuICAgICAgfSA9IGdldE1hcmtlckxpbmVzKGxvYywgbGluZXMsIG9wdHMpO1xuICAgICAgY29uc3QgaGFzQ29sdW1ucyA9IGxvYy5zdGFydCAmJiB0eXBlb2YgbG9jLnN0YXJ0LmNvbHVtbiA9PT0gXCJudW1iZXJcIjtcbiAgICAgIGNvbnN0IG51bWJlck1heFdpZHRoID0gU3RyaW5nKGVuZCkubGVuZ3RoO1xuICAgICAgY29uc3QgaGlnaGxpZ2h0ZWRMaW5lcyA9IGhpZ2hsaWdodGVkID8gKDAsIF9oaWdobGlnaHQuZGVmYXVsdCkocmF3TGluZXMsIG9wdHMpIDogcmF3TGluZXM7XG4gICAgICBsZXQgZnJhbWUgPSBoaWdobGlnaHRlZExpbmVzLnNwbGl0KE5FV0xJTkUpLnNsaWNlKHN0YXJ0LCBlbmQpLm1hcCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXg7XG4gICAgICAgIGNvbnN0IHBhZGRlZE51bWJlciA9IFwiIFwiLmNvbmNhdChudW1iZXIpLnNsaWNlKC1udW1iZXJNYXhXaWR0aCk7XG4gICAgICAgIGNvbnN0IGd1dHRlciA9IFwiIFwiLmNvbmNhdChwYWRkZWROdW1iZXIsIFwiIHwgXCIpO1xuICAgICAgICBjb25zdCBoYXNNYXJrZXIgPSBtYXJrZXJMaW5lc1tudW1iZXJdO1xuICAgICAgICBjb25zdCBsYXN0TWFya2VyTGluZSA9ICFtYXJrZXJMaW5lc1tudW1iZXIgKyAxXTtcblxuICAgICAgICBpZiAoaGFzTWFya2VyKSB7XG4gICAgICAgICAgbGV0IG1hcmtlckxpbmUgPSBcIlwiO1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGFzTWFya2VyKSkge1xuICAgICAgICAgICAgY29uc3QgbWFya2VyU3BhY2luZyA9IGxpbmUuc2xpY2UoMCwgTWF0aC5tYXgoaGFzTWFya2VyWzBdIC0gMSwgMCkpLnJlcGxhY2UoL1teXFx0XS9nLCBcIiBcIik7XG4gICAgICAgICAgICBjb25zdCBudW1iZXJPZk1hcmtlcnMgPSBoYXNNYXJrZXJbMV0gfHwgMTtcbiAgICAgICAgICAgIG1hcmtlckxpbmUgPSBbXCJcXG4gXCIsIG1heWJlSGlnaGxpZ2h0KGRlZnMuZ3V0dGVyLCBndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSksIG1hcmtlclNwYWNpbmcsIG1heWJlSGlnaGxpZ2h0KGRlZnMubWFya2VyLCBcIl5cIikucmVwZWF0KG51bWJlck9mTWFya2VycyldLmpvaW4oXCJcIik7XG5cbiAgICAgICAgICAgIGlmIChsYXN0TWFya2VyTGluZSAmJiBvcHRzLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgbWFya2VyTGluZSArPSBcIiBcIiArIG1heWJlSGlnaGxpZ2h0KGRlZnMubWVzc2FnZSwgb3B0cy5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW21heWJlSGlnaGxpZ2h0KGRlZnMubWFya2VyLCBcIj5cIiksIG1heWJlSGlnaGxpZ2h0KGRlZnMuZ3V0dGVyLCBndXR0ZXIpLCBsaW5lLCBtYXJrZXJMaW5lXS5qb2luKFwiXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIiBcIi5jb25jYXQobWF5YmVIaWdobGlnaHQoZGVmcy5ndXR0ZXIsIGd1dHRlcikpLmNvbmNhdChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSkuam9pbihcIlxcblwiKTtcblxuICAgICAgaWYgKG9wdHMubWVzc2FnZSAmJiAhaGFzQ29sdW1ucykge1xuICAgICAgICBmcmFtZSA9IFwiXCIuY29uY2F0KFwiIFwiLnJlcGVhdChudW1iZXJNYXhXaWR0aCArIDEpKS5jb25jYXQob3B0cy5tZXNzYWdlLCBcIlxcblwiKS5jb25jYXQoZnJhbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGlnaGxpZ2h0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGNoYWxrLnJlc2V0KGZyYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGVmYXVsdChyYXdMaW5lcywgbGluZU51bWJlciwgY29sTnVtYmVyLCBvcHRzID0ge30pIHtcbiAgICAgIGlmICghZGVwcmVjYXRpb25XYXJuaW5nU2hvd24pIHtcbiAgICAgICAgZGVwcmVjYXRpb25XYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJQYXNzaW5nIGxpbmVOdW1iZXIgYW5kIGNvbE51bWJlciBpcyBkZXByZWNhdGVkIHRvIEBiYWJlbC9jb2RlLWZyYW1lLiBQbGVhc2UgdXNlIGBjb2RlRnJhbWVDb2x1bW5zYC5cIjtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbWl0V2FybmluZykge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobWVzc2FnZSwgXCJEZXByZWNhdGlvbldhcm5pbmdcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZGVwcmVjYXRpb25FcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICBkZXByZWNhdGlvbkVycm9yLm5hbWUgPSBcIkRlcHJlY2F0aW9uV2FybmluZ1wiO1xuICAgICAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbE51bWJlciA9IE1hdGgubWF4KGNvbE51bWJlciwgMCk7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICBjb2x1bW46IGNvbE51bWJlcixcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gY29kZUZyYW1lQ29sdW1ucyhyYXdMaW5lcywgbG9jYXRpb24sIG9wdHMpO1xuICAgIH1cbiAgfSk7XG4gIHVud3JhcEV4cG9ydHMobGliJDIpO1xuICB2YXIgbGliXzEkMSA9IGxpYiQyLmNvZGVGcmFtZUNvbHVtbnM7XG5cbiAgY29uc3Qge1xuICAgIENvbmZpZ0Vycm9yOiBDb25maWdFcnJvciQxXG4gIH0gPSBlcnJvcnM7XG4gIGNvbnN0IHtcbiAgICBsb2NTdGFydDogbG9jU3RhcnQkMSxcbiAgICBsb2NFbmQ6IGxvY0VuZCQxXG4gIH0gPSBsb2M7IC8vIFVzZSBkZWZpbmVQcm9wZXJ0aWVzKCkvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCkgdG8gcHJldmVudFxuICAvLyB0cmlnZ2VyaW5nIHRoZSBwYXJzZXJzIGdldHRlcnMuXG5cbiAgY29uc3Qgb3duTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgY29uc3Qgb3duRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbiAgZnVuY3Rpb24gZ2V0UGFyc2VycyhvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyc2VycyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2Ygb3B0aW9ucy5wbHVnaW5zKSB7XG4gICAgICBpZiAoIXBsdWdpbi5wYXJzZXJzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3duTmFtZXMocGx1Z2luLnBhcnNlcnMpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJzZXJzLCBuYW1lLCBvd25EZXNjcmlwdG9yKHBsdWdpbi5wYXJzZXJzLCBuYW1lKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlcnM7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlUGFyc2VyKG9wdHMsIHBhcnNlcnMpIHtcbiAgICBwYXJzZXJzID0gcGFyc2VycyB8fCBnZXRQYXJzZXJzKG9wdHMpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBhcnNlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAvLyBDdXN0b20gcGFyc2VyIEFQSSBhbHdheXMgd29ya3Mgd2l0aCBKYXZhU2NyaXB0LlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFyc2U6IG9wdHMucGFyc2VyLFxuICAgICAgICBhc3RGb3JtYXQ6IFwiZXN0cmVlXCIsXG4gICAgICAgIGxvY1N0YXJ0OiBsb2NTdGFydCQxLFxuICAgICAgICBsb2NFbmQ6IGxvY0VuZCQxXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0cy5wYXJzZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFyc2Vycywgb3B0cy5wYXJzZXIpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXJzW29wdHMucGFyc2VyXTtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgQ29uZmlnRXJyb3IkMShcIkNvdWxkbid0IHJlc29sdmUgcGFyc2VyIFxcXCJcIi5jb25jYXQob3B0cy5wYXJzZXIsIFwiXFxcIi4gUGFyc2VycyBtdXN0IGJlIGV4cGxpY2l0bHkgYWRkZWQgdG8gdGhlIHN0YW5kYWxvbmUgYnVuZGxlLlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2UodGV4dCwgb3B0cykge1xuICAgIGNvbnN0IHBhcnNlcnMgPSBnZXRQYXJzZXJzKG9wdHMpOyAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IHtwYXJzZXJOYW1lOiBwYXJzZUZufS4gVXNlcyBkZWZpbmVQcm9wZXJ0eSgpIHRvIG9ubHkgY2FsbFxuICAgIC8vIHRoZSBwYXJzZXJzIGdldHRlcnMgd2hlbiBhY3R1YWxseSBjYWxsaW5nIHRoZSBwYXJzZXIgYHBhcnNlYCBmdW5jdGlvbi5cblxuICAgIGNvbnN0IHBhcnNlcnNGb3JDdXN0b21QYXJzZXJBcGkgPSBPYmplY3Qua2V5cyhwYXJzZXJzKS5yZWR1Y2UoKG9iamVjdCwgcGFyc2VyTmFtZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcGFyc2VyTmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gcGFyc2Vyc1twYXJzZXJOYW1lXS5wYXJzZTtcbiAgICAgIH1cblxuICAgIH0pLCB7fSk7XG4gICAgY29uc3QgcGFyc2VyID0gcmVzb2x2ZVBhcnNlcihvcHRzLCBwYXJzZXJzKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAocGFyc2VyLnByZXByb2Nlc3MpIHtcbiAgICAgICAgdGV4dCA9IHBhcnNlci5wcmVwcm9jZXNzKHRleHQsIG9wdHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0LFxuICAgICAgICBhc3Q6IHBhcnNlci5wYXJzZSh0ZXh0LCBwYXJzZXJzRm9yQ3VzdG9tUGFyc2VyQXBpLCBvcHRzKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsb2NcbiAgICAgIH0gPSBlcnJvcjtcblxuICAgICAgaWYgKGxvYykge1xuICAgICAgICBjb25zdCBjb2RlRnJhbWUgPSBsaWIkMjtcbiAgICAgICAgZXJyb3IuY29kZUZyYW1lID0gY29kZUZyYW1lLmNvZGVGcmFtZUNvbHVtbnModGV4dCwgbG9jLCB7XG4gICAgICAgICAgaGlnaGxpZ2h0Q29kZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZXJyb3IubWVzc2FnZSArPSBcIlxcblwiICsgZXJyb3IuY29kZUZyYW1lO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgICAgdGhyb3cgZXJyb3Iuc3RhY2s7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhcnNlciA9IHtcbiAgICBwYXJzZSxcbiAgICByZXNvbHZlUGFyc2VyXG4gIH07XG5cbiAgY29uc3Qge1xuICAgIFVuZGVmaW5lZFBhcnNlckVycm9yOiBVbmRlZmluZWRQYXJzZXJFcnJvciQxXG4gIH0gPSBlcnJvcnM7XG4gIGNvbnN0IHtcbiAgICBnZXRTdXBwb3J0SW5mbzogZ2V0U3VwcG9ydEluZm8kMVxuICB9ID0gc3VwcG9ydDtcbiAgY29uc3Qge1xuICAgIHJlc29sdmVQYXJzZXI6IHJlc29sdmVQYXJzZXIkMVxuICB9ID0gcGFyc2VyO1xuICBjb25zdCBoaWRkZW5EZWZhdWx0cyA9IHtcbiAgICBhc3RGb3JtYXQ6IFwiZXN0cmVlXCIsXG4gICAgcHJpbnRlcjoge30sXG4gICAgb3JpZ2luYWxUZXh0OiB1bmRlZmluZWQsXG4gICAgbG9jU3RhcnQ6IG51bGwsXG4gICAgbG9jRW5kOiBudWxsXG4gIH07IC8vIENvcHkgb3B0aW9ucyBhbmQgZmlsbCBpbiBkZWZhdWx0IHZhbHVlcy5cblxuICBmdW5jdGlvbiBub3JtYWxpemUkMShvcHRpb25zLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgY29uc3QgcmF3T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGNvbnN0IHN1cHBvcnRPcHRpb25zID0gZ2V0U3VwcG9ydEluZm8kMSh7XG4gICAgICBwbHVnaW5zOiBvcHRpb25zLnBsdWdpbnMsXG4gICAgICBzaG93VW5yZWxlYXNlZDogdHJ1ZSxcbiAgICAgIHNob3dEZXByZWNhdGVkOiB0cnVlXG4gICAgfSkub3B0aW9ucztcbiAgICBjb25zdCBkZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oe30sIGhpZGRlbkRlZmF1bHRzLCB7fSwgZnJvbVBhaXJzXzEoc3VwcG9ydE9wdGlvbnMuZmlsdGVyKG9wdGlvbkluZm8gPT4gb3B0aW9uSW5mby5kZWZhdWx0ICE9PSB1bmRlZmluZWQpLm1hcChvcHRpb24gPT4gW29wdGlvbi5uYW1lLCBvcHRpb24uZGVmYXVsdF0pKSk7XG5cbiAgICBpZiAoIXJhd09wdGlvbnMucGFyc2VyKSB7XG4gICAgICBpZiAoIXJhd09wdGlvbnMuZmlsZXBhdGgpIHtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gb3B0cy5sb2dnZXIgfHwgY29uc29sZTtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJObyBwYXJzZXIgYW5kIG5vIGZpbGVwYXRoIGdpdmVuLCB1c2luZyAnYmFiZWwnIHRoZSBwYXJzZXIgbm93IFwiICsgXCJidXQgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGluIHRoZSBmdXR1cmUuIFwiICsgXCJQbGVhc2Ugc3BlY2lmeSBhIHBhcnNlciBvciBhIGZpbGVwYXRoIHNvIG9uZSBjYW4gYmUgaW5mZXJyZWQuXCIpO1xuICAgICAgICByYXdPcHRpb25zLnBhcnNlciA9IFwiYmFiZWxcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd09wdGlvbnMucGFyc2VyID0gaW5mZXJQYXJzZXIocmF3T3B0aW9ucy5maWxlcGF0aCwgcmF3T3B0aW9ucy5wbHVnaW5zKTtcblxuICAgICAgICBpZiAoIXJhd09wdGlvbnMucGFyc2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZGVmaW5lZFBhcnNlckVycm9yJDEoXCJObyBwYXJzZXIgY291bGQgYmUgaW5mZXJyZWQgZm9yIGZpbGU6IFwiLmNvbmNhdChyYXdPcHRpb25zLmZpbGVwYXRoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZXIgPSByZXNvbHZlUGFyc2VyJDEob3B0aW9uc05vcm1hbGl6ZXIubm9ybWFsaXplQXBpT3B0aW9ucyhyYXdPcHRpb25zLCBbc3VwcG9ydE9wdGlvbnMuZmluZCh4ID0+IHgubmFtZSA9PT0gXCJwYXJzZXJcIildLCB7XG4gICAgICBwYXNzVGhyb3VnaDogdHJ1ZSxcbiAgICAgIGxvZ2dlcjogZmFsc2VcbiAgICB9KSk7XG4gICAgcmF3T3B0aW9ucy5hc3RGb3JtYXQgPSBwYXJzZXIuYXN0Rm9ybWF0O1xuICAgIHJhd09wdGlvbnMubG9jRW5kID0gcGFyc2VyLmxvY0VuZDtcbiAgICByYXdPcHRpb25zLmxvY1N0YXJ0ID0gcGFyc2VyLmxvY1N0YXJ0O1xuICAgIGNvbnN0IHBsdWdpbiA9IGdldFBsdWdpbihyYXdPcHRpb25zKTtcbiAgICByYXdPcHRpb25zLnByaW50ZXIgPSBwbHVnaW4ucHJpbnRlcnNbcmF3T3B0aW9ucy5hc3RGb3JtYXRdO1xuICAgIGNvbnN0IHBsdWdpbkRlZmF1bHRzID0gc3VwcG9ydE9wdGlvbnMuZmlsdGVyKG9wdGlvbkluZm8gPT4gb3B0aW9uSW5mby5wbHVnaW5EZWZhdWx0cyAmJiBvcHRpb25JbmZvLnBsdWdpbkRlZmF1bHRzW3BsdWdpbi5uYW1lXSAhPT0gdW5kZWZpbmVkKS5yZWR1Y2UoKHJlZHVjZWQsIG9wdGlvbkluZm8pID0+IE9iamVjdC5hc3NpZ24ocmVkdWNlZCwge1xuICAgICAgW29wdGlvbkluZm8ubmFtZV06IG9wdGlvbkluZm8ucGx1Z2luRGVmYXVsdHNbcGx1Z2luLm5hbWVdXG4gICAgfSksIHt9KTtcbiAgICBjb25zdCBtaXhlZERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHt9LCBwbHVnaW5EZWZhdWx0cyk7XG4gICAgT2JqZWN0LmtleXMobWl4ZWREZWZhdWx0cykuZm9yRWFjaChrID0+IHtcbiAgICAgIGlmIChyYXdPcHRpb25zW2tdID09IG51bGwpIHtcbiAgICAgICAgcmF3T3B0aW9uc1trXSA9IG1peGVkRGVmYXVsdHNba107XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocmF3T3B0aW9ucy5wYXJzZXIgPT09IFwianNvblwiKSB7XG4gICAgICByYXdPcHRpb25zLnRyYWlsaW5nQ29tbWEgPSBcIm5vbmVcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9uc05vcm1hbGl6ZXIubm9ybWFsaXplQXBpT3B0aW9ucyhyYXdPcHRpb25zLCBzdXBwb3J0T3B0aW9ucywgT2JqZWN0LmFzc2lnbih7XG4gICAgICBwYXNzVGhyb3VnaDogT2JqZWN0LmtleXMoaGlkZGVuRGVmYXVsdHMpXG4gICAgfSwgb3B0cykpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGx1Z2luKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBhc3RGb3JtYXRcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXN0Rm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRQbHVnaW4oKSByZXF1aXJlcyBhc3RGb3JtYXQgdG8gYmUgc2V0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW50ZXJQbHVnaW4gPSBvcHRpb25zLnBsdWdpbnMuZmluZChwbHVnaW4gPT4gcGx1Z2luLnByaW50ZXJzICYmIHBsdWdpbi5wcmludGVyc1thc3RGb3JtYXRdKTtcblxuICAgIGlmICghcHJpbnRlclBsdWdpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBwbHVnaW4gZm9yIEFTVCBmb3JtYXQgXFxcIlwiLmNvbmNhdChhc3RGb3JtYXQsIFwiXFxcIlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByaW50ZXJQbHVnaW47XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnRlcnByZXRlcihmaWxlcGF0aCkge1xuICAgIGlmICh0eXBlb2YgZmlsZXBhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIGxldCBmZDtcblxuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKGZpbGVwYXRoLCBcInJcIik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxpbmVyID0gbmV3IHJlYWRsaW5lcyhmZCk7XG4gICAgICBjb25zdCBmaXJzdExpbmUgPSBsaW5lci5uZXh0KCkudG9TdHJpbmcoXCJ1dGY4XCIpOyAvLyAjIS9iaW4vZW52IG5vZGUsICMhL3Vzci9iaW4vZW52IG5vZGVcblxuICAgICAgY29uc3QgbTEgPSBmaXJzdExpbmUubWF0Y2goL14jIVxcLyg/OnVzclxcLyk/YmluXFwvZW52XFxzKyhcXFMrKS8pO1xuXG4gICAgICBpZiAobTEpIHtcbiAgICAgICAgcmV0dXJuIG0xWzFdO1xuICAgICAgfSAvLyAjIS9iaW4vbm9kZSwgIyEvdXNyL2Jpbi9ub2RlLCAjIS91c3IvbG9jYWwvYmluL25vZGVcblxuXG4gICAgICBjb25zdCBtMiA9IGZpcnN0TGluZS5tYXRjaCgvXiMhXFwvKD86dXNyXFwvKD86bG9jYWxcXC8pPyk/YmluXFwvKFxcUyspLyk7XG5cbiAgICAgIGlmIChtMikge1xuICAgICAgICByZXR1cm4gbTJbMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gVGhlcmUgYXJlIHNvbWUgd2VpcmQgY2FzZXMgd2hlcmUgcGF0aHMgYXJlIG1pc3NpbmcsIGNhdXNpbmcgSmVzdFxuICAgICAgLy8gZmFpbHVyZXMuIEl0J3MgdW5jbGVhciB3aGF0IHRoZXNlIGNvcnJlc3BvbmQgdG8gaW4gdGhlIHJlYWwgd29ybGQuXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIHNvbWUgd2VpcmQgY2FzZXMgd2hlcmUgcGF0aHMgYXJlIG1pc3NpbmcsIGNhdXNpbmcgSmVzdFxuICAgICAgICAvLyBmYWlsdXJlcy4gSXQncyB1bmNsZWFyIHdoYXQgdGhlc2UgY29ycmVzcG9uZCB0byBpbiB0aGUgcmVhbCB3b3JsZC5cbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikgey8vIG5vcFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluZmVyUGFyc2VyKGZpbGVwYXRoLCBwbHVnaW5zKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVwYXRoKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGxhbmd1YWdlcyA9IGdldFN1cHBvcnRJbmZvJDEoe1xuICAgICAgcGx1Z2luc1xuICAgIH0pLmxhbmd1YWdlcy5maWx0ZXIobGFuZ3VhZ2UgPT4gbGFuZ3VhZ2Uuc2luY2UgIT09IG51bGwpOyAvLyBJZiB0aGUgZmlsZSBoYXMgbm8gZXh0ZW5zaW9uLCB3ZSBjYW4gdHJ5IHRvIGluZmVyIHRoZSBsYW5ndWFnZSBmcm9tIHRoZVxuICAgIC8vIGludGVycHJldGVyIGluIHRoZSBzaGViYW5nIGxpbmUsIGlmIGFueTsgYnV0IHNpbmNlIHRoaXMgcmVxdWlyZXMgRlMgYWNjZXNzLFxuICAgIC8vIGRvIGl0IGxhc3QuXG5cbiAgICBsZXQgbGFuZ3VhZ2UgPSBsYW5ndWFnZXMuZmluZChsYW5ndWFnZSA9PiBsYW5ndWFnZS5leHRlbnNpb25zICYmIGxhbmd1YWdlLmV4dGVuc2lvbnMuc29tZShleHRlbnNpb24gPT4gZmlsZW5hbWUuZW5kc1dpdGgoZXh0ZW5zaW9uKSkgfHwgbGFuZ3VhZ2UuZmlsZW5hbWVzICYmIGxhbmd1YWdlLmZpbGVuYW1lcy5maW5kKG5hbWUgPT4gbmFtZS50b0xvd2VyQ2FzZSgpID09PSBmaWxlbmFtZSkpO1xuXG4gICAgaWYgKCFsYW5ndWFnZSAmJiAhZmlsZW5hbWUuaW5jbHVkZXMoXCIuXCIpKSB7XG4gICAgICBjb25zdCBpbnRlcnByZXRlciA9IGdldEludGVycHJldGVyKGZpbGVwYXRoKTtcbiAgICAgIGxhbmd1YWdlID0gbGFuZ3VhZ2VzLmZpbmQobGFuZ3VhZ2UgPT4gbGFuZ3VhZ2UuaW50ZXJwcmV0ZXJzICYmIGxhbmd1YWdlLmludGVycHJldGVycy5pbmNsdWRlcyhpbnRlcnByZXRlcikpO1xuICAgIH1cblxuICAgIHJldHVybiBsYW5ndWFnZSAmJiBsYW5ndWFnZS5wYXJzZXJzWzBdO1xuICB9XG5cbiAgdmFyIG9wdGlvbnMkMSA9IHtcbiAgICBub3JtYWxpemU6IG5vcm1hbGl6ZSQxLFxuICAgIGhpZGRlbkRlZmF1bHRzLFxuICAgIGluZmVyUGFyc2VyXG4gIH07XG5cbiAgZnVuY3Rpb24gbWFzc2FnZUFTVChhc3QsIG9wdGlvbnMsIHBhcmVudCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFzdCkpIHtcbiAgICAgIHJldHVybiBhc3QubWFwKGUgPT4gbWFzc2FnZUFTVChlLCBvcHRpb25zLCBwYXJlbnQpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuXG4gICAgaWYgKCFhc3QgfHwgdHlwZW9mIGFzdCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdPYmogPSB7fTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFzdCkpIHtcbiAgICAgIGlmICh0eXBlb2YgYXN0W2tleV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG1hc3NhZ2VBU1QoYXN0W2tleV0sIG9wdGlvbnMsIGFzdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucHJpbnRlci5tYXNzYWdlQXN0Tm9kZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9ucy5wcmludGVyLm1hc3NhZ2VBc3ROb2RlKGFzdCwgbmV3T2JqLCBwYXJlbnQpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqO1xuICB9XG5cbiAgdmFyIG1hc3NhZ2VBc3QgPSBtYXNzYWdlQVNUO1xuXG4gIGZ1bmN0aW9uIGFzc2VydCgpIHt9XG5cbiAgYXNzZXJ0Lm9rID0gZnVuY3Rpb24gKCkge307XG5cbiAgYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gKCkge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jW119IHBhcnRzXG4gICAqIEByZXR1cm5zIERvY1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvbmNhdChwYXJ0cykge1xuICAgIC8vIGFjY2VzcyB0aGUgaW50ZXJuYWxzIG9mIGEgZG9jdW1lbnQgZGlyZWN0bHkuXG4gICAgLy8gaWYocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gICAvLyBJZiBpdCdzIGEgc2luZ2xlIGRvY3VtZW50LCBubyBuZWVkIHRvIGNvbmNhdCBpdC5cbiAgICAvLyAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAvLyB9XG5cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbmNhdFwiLFxuICAgICAgcGFydHNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gY29udGVudHNcbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5kZW50KGNvbnRlbnRzKSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmRlbnRcIixcbiAgICAgIGNvbnRlbnRzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHBhcmFtIHtEb2N9IGNvbnRlbnRzXG4gICAqIEByZXR1cm5zIERvY1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFsaWduKG4sIGNvbnRlbnRzKSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgY29udGVudHMsXG4gICAgICBuXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGNvbnRlbnRzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0c10gLSBUQkQgPz8/XG4gICAqIEByZXR1cm5zIERvY1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdyb3VwKGNvbnRlbnRzLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJncm91cFwiLFxuICAgICAgaWQ6IG9wdHMuaWQsXG4gICAgICBjb250ZW50cyxcbiAgICAgIGJyZWFrOiAhIW9wdHMuc2hvdWxkQnJlYWssXG4gICAgICBleHBhbmRlZFN0YXRlczogb3B0cy5leHBhbmRlZFN0YXRlc1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBjb250ZW50c1xuICAgKiBAcmV0dXJucyBEb2NcbiAgICovXG5cblxuICBmdW5jdGlvbiBkZWRlbnRUb1Jvb3QoY29udGVudHMpIHtcbiAgICByZXR1cm4gYWxpZ24oLUluZmluaXR5LCBjb250ZW50cyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBjb250ZW50c1xuICAgKiBAcmV0dXJucyBEb2NcbiAgICovXG5cblxuICBmdW5jdGlvbiBtYXJrQXNSb290KGNvbnRlbnRzKSB7XG4gICAgLy8gQHRzLWlnbm9yZSAtIFRCRCA/Pz86XG4gICAgcmV0dXJuIGFsaWduKHtcbiAgICAgIHR5cGU6IFwicm9vdFwiXG4gICAgfSwgY29udGVudHMpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gY29udGVudHNcbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGVkZW50KGNvbnRlbnRzKSB7XG4gICAgcmV0dXJuIGFsaWduKC0xLCBjb250ZW50cyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jW119IHN0YXRlc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdIC0gVEJEID8/P1xuICAgKiBAcmV0dXJucyBEb2NcbiAgICovXG5cblxuICBmdW5jdGlvbiBjb25kaXRpb25hbEdyb3VwKHN0YXRlcywgb3B0cykge1xuICAgIHJldHVybiBncm91cChzdGF0ZXNbMF0sIE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtcbiAgICAgIGV4cGFuZGVkU3RhdGVzOiBzdGF0ZXNcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jW119IHBhcnRzXG4gICAqIEByZXR1cm5zIERvY1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGZpbGwocGFydHMpIHtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZpbGxcIixcbiAgICAgIHBhcnRzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IFticmVha0NvbnRlbnRzXVxuICAgKiBAcGFyYW0ge0RvY30gW2ZsYXRDb250ZW50c11cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSAtIFRCRCA/Pz9cbiAgICogQHJldHVybnMgRG9jXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaWZCcmVhayhicmVha0NvbnRlbnRzLCBmbGF0Q29udGVudHMsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImlmLWJyZWFrXCIsXG4gICAgICBicmVha0NvbnRlbnRzLFxuICAgICAgZmxhdENvbnRlbnRzLFxuICAgICAgZ3JvdXBJZDogb3B0cy5ncm91cElkXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGNvbnRlbnRzXG4gICAqIEByZXR1cm5zIERvY1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGxpbmVTdWZmaXgoY29udGVudHMpIHtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxpbmUtc3VmZml4XCIsXG4gICAgICBjb250ZW50c1xuICAgIH07XG4gIH1cblxuICBjb25zdCBsaW5lU3VmZml4Qm91bmRhcnkgPSB7XG4gICAgdHlwZTogXCJsaW5lLXN1ZmZpeC1ib3VuZGFyeVwiXG4gIH07XG4gIGNvbnN0IGJyZWFrUGFyZW50ID0ge1xuICAgIHR5cGU6IFwiYnJlYWstcGFyZW50XCJcbiAgfTtcbiAgY29uc3QgdHJpbSA9IHtcbiAgICB0eXBlOiBcInRyaW1cIlxuICB9O1xuICBjb25zdCBsaW5lID0ge1xuICAgIHR5cGU6IFwibGluZVwiXG4gIH07XG4gIGNvbnN0IHNvZnRsaW5lID0ge1xuICAgIHR5cGU6IFwibGluZVwiLFxuICAgIHNvZnQ6IHRydWVcbiAgfTtcbiAgY29uc3QgaGFyZGxpbmUgPSBjb25jYXQoW3tcbiAgICB0eXBlOiBcImxpbmVcIixcbiAgICBoYXJkOiB0cnVlXG4gIH0sIGJyZWFrUGFyZW50XSk7XG4gIGNvbnN0IGxpdGVyYWxsaW5lID0gY29uY2F0KFt7XG4gICAgdHlwZTogXCJsaW5lXCIsXG4gICAgaGFyZDogdHJ1ZSxcbiAgICBsaXRlcmFsOiB0cnVlXG4gIH0sIGJyZWFrUGFyZW50XSk7XG4gIGNvbnN0IGN1cnNvciA9IHtcbiAgICB0eXBlOiBcImN1cnNvclwiLFxuICAgIHBsYWNlaG9sZGVyOiBTeW1ib2woXCJjdXJzb3JcIilcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBzZXBcbiAgICogQHBhcmFtIHtEb2NbXX0gYXJyXG4gICAqIEByZXR1cm5zIERvY1xuICAgKi9cblxuICBmdW5jdGlvbiBqb2luKHNlcCwgYXJyKSB7XG4gICAgY29uc3QgcmVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgcmVzLnB1c2goc2VwKTtcbiAgICAgIH1cblxuICAgICAgcmVzLnB1c2goYXJyW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0KHJlcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhYldpZHRoXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYWRkQWxpZ25tZW50VG9Eb2MoZG9jLCBzaXplLCB0YWJXaWR0aCkge1xuICAgIGxldCBhbGlnbmVkID0gZG9jO1xuXG4gICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAvLyBVc2UgaW5kZW50IHRvIGFkZCB0YWJzIGZvciBhbGwgdGhlIGxldmVscyBvZiB0YWJzIHdlIG5lZWRcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5mbG9vcihzaXplIC8gdGFiV2lkdGgpOyArK2kpIHtcbiAgICAgICAgYWxpZ25lZCA9IGluZGVudChhbGlnbmVkKTtcbiAgICAgIH0gLy8gVXNlIGFsaWduIGZvciBhbGwgdGhlIHNwYWNlcyB0aGF0IGFyZSBuZWVkZWRcblxuXG4gICAgICBhbGlnbmVkID0gYWxpZ24oc2l6ZSAlIHRhYldpZHRoLCBhbGlnbmVkKTsgLy8gc2l6ZSBpcyBhYnNvbHV0ZSBmcm9tIDAgYW5kIG5vdCByZWxhdGl2ZSB0byB0aGUgY3VycmVudFxuICAgICAgLy8gaW5kZW50YXRpb24sIHNvIHdlIHVzZSAtSW5maW5pdHkgdG8gcmVzZXQgdGhlIGluZGVudGF0aW9uIHRvIDBcblxuICAgICAgYWxpZ25lZCA9IGFsaWduKC1JbmZpbml0eSwgYWxpZ25lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsaWduZWQ7XG4gIH1cblxuICB2YXIgZG9jQnVpbGRlcnMgPSB7XG4gICAgY29uY2F0LFxuICAgIGpvaW4sXG4gICAgbGluZSxcbiAgICBzb2Z0bGluZSxcbiAgICBoYXJkbGluZSxcbiAgICBsaXRlcmFsbGluZSxcbiAgICBncm91cCxcbiAgICBjb25kaXRpb25hbEdyb3VwLFxuICAgIGZpbGwsXG4gICAgbGluZVN1ZmZpeCxcbiAgICBsaW5lU3VmZml4Qm91bmRhcnksXG4gICAgY3Vyc29yLFxuICAgIGJyZWFrUGFyZW50LFxuICAgIGlmQnJlYWssXG4gICAgdHJpbSxcbiAgICBpbmRlbnQsXG4gICAgYWxpZ24sXG4gICAgYWRkQWxpZ25tZW50VG9Eb2MsXG4gICAgbWFya0FzUm9vdCxcbiAgICBkZWRlbnRUb1Jvb3QsXG4gICAgZGVkZW50XG4gIH07XG5cbiAgdmFyIGFuc2lSZWdleCA9ICh7XG4gICAgb25seUZpcnN0ID0gZmFsc2VcbiAgfSA9IHt9KSA9PiB7XG4gICAgY29uc3QgcGF0dGVybiA9IFsnW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/OlthLXpBLVpcXFxcZF0qKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpJywgJyg/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnRxcnk9Pjx+XSkpJ10uam9pbignfCcpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIG9ubHlGaXJzdCA/IHVuZGVmaW5lZCA6ICdnJyk7XG4gIH07XG5cbiAgdmFyIHN0cmlwQW5zaSA9IHN0cmluZyA9PiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyA/IHN0cmluZy5yZXBsYWNlKGFuc2lSZWdleCgpLCAnJykgOiBzdHJpbmc7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgeW9kYSAqL1xuXG4gIGNvbnN0IGlzRnVsbHdpZHRoQ29kZVBvaW50ID0gY29kZVBvaW50ID0+IHtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGNvZGVQb2ludCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENvZGUgcG9pbnRzIGFyZSBkZXJpdmVkIGZyb206XG4gICAgLy8gaHR0cDovL3d3dy51bml4Lm9yZy9QdWJsaWMvVU5JREFUQS9FYXN0QXNpYW5XaWR0aC50eHRcblxuXG4gICAgaWYgKGNvZGVQb2ludCA+PSAweDExMDAgJiYgKGNvZGVQb2ludCA8PSAweDExNUYgfHwgLy8gSGFuZ3VsIEphbW9cbiAgICBjb2RlUG9pbnQgPT09IDB4MjMyOSB8fCAvLyBMRUZULVBPSU5USU5HIEFOR0xFIEJSQUNLRVRcbiAgICBjb2RlUG9pbnQgPT09IDB4MjMyQSB8fCAvLyBSSUdIVC1QT0lOVElORyBBTkdMRSBCUkFDS0VUXG4gICAgLy8gQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnQgLi4gRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRoc1xuICAgIDB4MkU4MCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MzI0NyAmJiBjb2RlUG9pbnQgIT09IDB4MzAzRiB8fCAvLyBFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzIC4uIENKSyBVbmlmaWVkIElkZW9ncmFwaHMgRXh0ZW5zaW9uIEFcbiAgICAweDMyNTAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDREQkYgfHwgLy8gQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyAuLiBZaSBSYWRpY2Fsc1xuICAgIDB4NEUwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4QTRDNiB8fCAvLyBIYW5ndWwgSmFtbyBFeHRlbmRlZC1BXG4gICAgMHhBOTYwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhBOTdDIHx8IC8vIEhhbmd1bCBTeWxsYWJsZXNcbiAgICAweEFDMDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweEQ3QTMgfHwgLy8gQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1xuICAgIDB4RjkwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4RkFGRiB8fCAvLyBWZXJ0aWNhbCBGb3Jtc1xuICAgIDB4RkUxMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4RkUxOSB8fCAvLyBDSksgQ29tcGF0aWJpbGl0eSBGb3JtcyAuLiBTbWFsbCBGb3JtIFZhcmlhbnRzXG4gICAgMHhGRTMwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhGRTZCIHx8IC8vIEhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXG4gICAgMHhGRjAxIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhGRjYwIHx8IDB4RkZFMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4RkZFNiB8fCAvLyBLYW5hIFN1cHBsZW1lbnRcbiAgICAweDFCMDAwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHgxQjAwMSB8fCAvLyBFbmNsb3NlZCBJZGVvZ3JhcGhpYyBTdXBwbGVtZW50XG4gICAgMHgxRjIwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4MUYyNTEgfHwgLy8gQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQiAuLiBUZXJ0aWFyeSBJZGVvZ3JhcGhpYyBQbGFuZVxuICAgIDB4MjAwMDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDNGRkZEKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHZhciBpc0Z1bGx3aWR0aENvZGVQb2ludF8xID0gaXNGdWxsd2lkdGhDb2RlUG9pbnQ7XG4gIHZhciBkZWZhdWx0XzEkMSA9IGlzRnVsbHdpZHRoQ29kZVBvaW50O1xuICBpc0Z1bGx3aWR0aENvZGVQb2ludF8xLmRlZmF1bHQgPSBkZWZhdWx0XzEkMTtcblxuICB2YXIgZW1vamlSZWdleCA9IGZ1bmN0aW9uIGVtb2ppUmVnZXgoKSB7XG4gICAgLy8gaHR0cHM6Ly9tdGhzLmJlL2Vtb2ppXG4gICAgcmV0dXJuIC9cXHVEODNDXFx1REZGNFxcdURCNDBcXHVEQzY3XFx1REI0MFxcdURDNjIoPzpcXHVEQjQwXFx1REM2NVxcdURCNDBcXHVEQzZFXFx1REI0MFxcdURDNjd8XFx1REI0MFxcdURDNzNcXHVEQjQwXFx1REM2M1xcdURCNDBcXHVEQzc0fFxcdURCNDBcXHVEQzc3XFx1REI0MFxcdURDNkNcXHVEQjQwXFx1REM3MylcXHVEQjQwXFx1REM3RnxcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NcXHVERkZDXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1xcdURGRkJ8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZGXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkVcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRF0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRFxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkNdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRFxcdURDNjh8KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKSl8XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGfFxcdUQ4M0RbXFx1REM2NlxcdURDNjddfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXwoPzpcXHVEODNDXFx1REZGQlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQ1xcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSlcXHVGRTBGfFxcdUQ4M0NcXHVERkZCXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkJcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGQ1xcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OSlcXHVEODNDXFx1REZGQnxcXHVEODNFXFx1REREMSg/OlxcdUQ4M0NcXHVERkZGXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDEpfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkVcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGRlxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZDXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkRcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjkpKD86XFx1RDgzQ1tcXHVERkZCXFx1REZGQ10pfFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1xcdURGRkVcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkNcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkJcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRFxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkZcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSkpfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkRcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGRVxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRF0pfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXwoPzpcXHVEODNEXFx1REM0MVxcdUZFMEZcXHUyMDBEXFx1RDgzRFxcdURERTh8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDXFx1REZGRlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQ1xcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pfCg/Oig/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpXFx1RkUwRnxcXHVEODNEXFx1REM2RnxcXHVEODNFW1xcdUREM0NcXHVERERFXFx1RERERl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENi1cXHVEREREXSkoPzooPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml0pfFxcdUQ4M0NcXHVERkY0XFx1MjAwRFxcdTI2MjApXFx1RkUwRnxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1xcdURGRjNcXHVGRTBGXFx1MjAwRFxcdUQ4M0NcXHVERjA4fFxcdUQ4M0RcXHVEQzE1XFx1MjAwRFxcdUQ4M0VcXHVEREJBfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY3fFxcdUQ4M0NcXHVEREZEXFx1RDgzQ1xcdURERjB8XFx1RDgzQ1xcdURERjRcXHVEODNDXFx1RERGMnxcXHVEODNDXFx1RERGNlxcdUQ4M0NcXHVEREU2fFsjXFwqMC05XVxcdUZFMEZcXHUyMEUzfFxcdUQ4M0NcXHVEREU3KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRlxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERGOSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVEXFx1RERFRi1cXHVEREY0XFx1RERGN1xcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkZdKXxcXHVEODNDXFx1RERFQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERURcXHVEREY3LVxcdURERkFdKXxcXHVEODNFXFx1REREMSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzQ1xcdURERjcoPzpcXHVEODNDW1xcdURERUFcXHVEREY0XFx1RERGOFxcdURERkFcXHVEREZDXSl8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0NcXHVEREYyKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOC1cXHVEREVEXFx1RERGMC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERTYoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGMlxcdURERjRcXHVEREY2LVxcdURERkFcXHVEREZDXFx1RERGRFxcdURERkZdKXxcXHVEODNDXFx1RERGMCg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUMtXFx1RERFRVxcdURERjJcXHVEREYzXFx1RERGNVxcdURERjdcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFRCg/OlxcdUQ4M0NbXFx1RERGMFxcdURERjJcXHVEREYzXFx1RERGN1xcdURERjlcXHVEREZBXSl8XFx1RDgzQ1xcdURERTkoPzpcXHVEODNDW1xcdURERUFcXHVEREVDXFx1RERFRlxcdURERjBcXHVEREYyXFx1RERGNFxcdURERkZdKXxcXHVEODNDXFx1RERGRSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjldKXxcXHVEODNDXFx1RERFQyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREY4KD86XFx1RDgzQ1tcXHVEREU2LVxcdURERUFcXHVEREVDLVxcdURERjRcXHVEREY3LVxcdURERjlcXHVEREZCXFx1RERGRC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERUIoPzpcXHVEODNDW1xcdURERUUtXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGN10pfFxcdUQ4M0NcXHVEREY1KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQS1cXHVEREVEXFx1RERGMC1cXHVEREYzXFx1RERGNy1cXHVEREY5XFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERGQig/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERUVcXHVEREYzXFx1RERGQV0pfFxcdUQ4M0NcXHVEREYzKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUEtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGNFxcdURERjVcXHVEREY3XFx1RERGQVxcdURERkZdKXxcXHVEODNDXFx1RERFOCg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVFXFx1RERGMC1cXHVEREY1XFx1RERGN1xcdURERkEtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREYxKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERThcXHVEREVFXFx1RERGMFxcdURERjctXFx1RERGQlxcdURERkVdKXxcXHVEODNDXFx1RERGRig/OlxcdUQ4M0NbXFx1RERFNlxcdURERjJcXHVEREZDXSl8XFx1RDgzQ1xcdURERkMoPzpcXHVEODNDW1xcdURERUJcXHVEREY4XSl8XFx1RDgzQ1xcdURERkEoPzpcXHVEODNDW1xcdURERTZcXHVEREVDXFx1RERGMlxcdURERjNcXHVEREY4XFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFRSg/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVBXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XSl8XFx1RDgzQ1xcdURERUYoPzpcXHVEODNDW1xcdURERUFcXHVEREYyXFx1RERGNFxcdURERjVdKXwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyNjFEXFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyXFx1REZDN118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjZcXHVEQzY3XFx1REM2Qi1cXHVEQzZEXFx1REM3MFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1RENBQVxcdURENzRcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDBGXFx1REQxOC1cXHVERDFDXFx1REQxRVxcdUREMUZcXHVERDMwLVxcdUREMzZcXHVEREI1XFx1RERCNlxcdUREQkJcXHVEREQyLVxcdURERDVdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTIzMUFcXHUyMzFCXFx1MjNFOS1cXHUyM0VDXFx1MjNGMFxcdTIzRjNcXHUyNUZEXFx1MjVGRVxcdTI2MTRcXHUyNjE1XFx1MjY0OC1cXHUyNjUzXFx1MjY3RlxcdTI2OTNcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGMlxcdTI2RjNcXHUyNkY1XFx1MjZGQVxcdTI2RkRcXHUyNzA1XFx1MjcwQVxcdTI3MEJcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc5NS1cXHUyNzk3XFx1MjdCMFxcdTI3QkZcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzNlxcdURFMzgtXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIwXFx1REYyRC1cXHVERjM1XFx1REYzNy1cXHVERjdDXFx1REY3RS1cXHVERjkzXFx1REZBMC1cXHVERkNBXFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGNFxcdURGRjgtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDM0VcXHVEQzQwXFx1REM0Mi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ3QVxcdUREOTVcXHVERDk2XFx1RERBNFxcdURERkItXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0NcXHVERUQwLVxcdURFRDJcXHVERUQ1XFx1REVFQlxcdURFRUNcXHVERUY0LVxcdURFRkFcXHVERkUwLVxcdURGRUJdfFxcdUQ4M0VbXFx1REQwRC1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERDcxXFx1REQ3My1cXHVERDc2XFx1REQ3QS1cXHVEREEyXFx1RERBNS1cXHVEREFBXFx1RERBRS1cXHVERENBXFx1RERDRC1cXHVEREZGXFx1REU3MC1cXHVERTczXFx1REU3OC1cXHVERTdBXFx1REU4MC1cXHVERTgyXFx1REU5MC1cXHVERTk1XSl8KD86WyNcXCowLTlcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE0XFx1MjYxNVxcdTI2MThcXHUyNjFEXFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY0OC1cXHUyNjUzXFx1MjY1RlxcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjY4XFx1MjY3QlxcdTI2N0VcXHUyNjdGXFx1MjY5Mi1cXHUyNjk3XFx1MjY5OVxcdTI2OUJcXHUyNjlDXFx1MjZBMFxcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QjBcXHUyNkIxXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2QzhcXHUyNkNFXFx1MjZDRlxcdTI2RDFcXHUyNkQzXFx1MjZENFxcdTI2RTlcXHUyNkVBXFx1MjZGMC1cXHUyNkY1XFx1MjZGNy1cXHUyNkZBXFx1MjZGRFxcdTI3MDJcXHUyNzA1XFx1MjcwOC1cXHUyNzBEXFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzXFx1Mjc2NFxcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTAyXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMVxcdURGMjQtXFx1REY5M1xcdURGOTZcXHVERjk3XFx1REY5OS1cXHVERjlCXFx1REY5RS1cXHVERkYwXFx1REZGMy1cXHVERkY1XFx1REZGNy1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1RENGRFxcdURDRkYtXFx1REQzRFxcdURENDktXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdURENkZcXHVERDcwXFx1REQ3My1cXHVERDdBXFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREOTBcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQS1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQi1cXHVERUQyXFx1REVENVxcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUVCXFx1REVFQ1xcdURFRjBcXHVERUYzLVxcdURFRkFcXHVERkUwLVxcdURGRUJdfFxcdUQ4M0VbXFx1REQwRC1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERDcxXFx1REQ3My1cXHVERDc2XFx1REQ3QS1cXHVEREEyXFx1RERBNS1cXHVEREFBXFx1RERBRS1cXHVERENBXFx1RERDRC1cXHVEREZGXFx1REU3MC1cXHVERTczXFx1REU3OC1cXHVERTdBXFx1REU4MC1cXHVERTgyXFx1REU5MC1cXHVERTk1XSlcXHVGRTBGfCg/OltcXHUyNjFEXFx1MjZGOVxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMi1cXHVERkM0XFx1REZDN1xcdURGQ0EtXFx1REZDQ118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjYtXFx1REM3OFxcdURDN0NcXHVEQzgxLVxcdURDODNcXHVEQzg1LVxcdURDODdcXHVEQzhGXFx1REM5MVxcdURDQUFcXHVERDc0XFx1REQ3NVxcdUREN0FcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVERTQ1LVxcdURFNDdcXHVERTRCLVxcdURFNEZcXHVERUEzXFx1REVCNC1cXHVERUI2XFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQwRlxcdUREMTgtXFx1REQxRlxcdUREMjZcXHVERDMwLVxcdUREMzlcXHVERDNDLVxcdUREM0VcXHVEREI1XFx1RERCNlxcdUREQjhcXHVEREI5XFx1RERCQlxcdUREQ0QtXFx1RERDRlxcdURERDEtXFx1RERERF0pL2c7XG4gIH07XG5cbiAgY29uc3Qgc3RyaW5nV2lkdGggPSBzdHJpbmcgPT4ge1xuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGVtb2ppUmVnZXgoKSwgJyAgJyk7XG5cbiAgICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycgfHwgc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgc3RyaW5nID0gc3RyaXBBbnNpKHN0cmluZyk7XG4gICAgbGV0IHdpZHRoID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyaW5nLmNvZGVQb2ludEF0KGkpOyAvLyBJZ25vcmUgY29udHJvbCBjaGFyYWN0ZXJzXG5cbiAgICAgIGlmIChjb2RlIDw9IDB4MUYgfHwgY29kZSA+PSAweDdGICYmIGNvZGUgPD0gMHg5Rikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWdub3JlIGNvbWJpbmluZyBjaGFyYWN0ZXJzXG5cblxuICAgICAgaWYgKGNvZGUgPj0gMHgzMDAgJiYgY29kZSA8PSAweDM2Rikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gU3Vycm9nYXRlc1xuXG5cbiAgICAgIGlmIChjb2RlID4gMHhGRkZGKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgd2lkdGggKz0gaXNGdWxsd2lkdGhDb2RlUG9pbnRfMShjb2RlKSA/IDIgOiAxO1xuICAgIH1cblxuICAgIHJldHVybiB3aWR0aDtcbiAgfTtcblxuICB2YXIgc3RyaW5nV2lkdGhfMSA9IHN0cmluZ1dpZHRoOyAvLyBUT0RPOiByZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5cbiAgdmFyIGRlZmF1bHRfMSQyID0gc3RyaW5nV2lkdGg7XG4gIHN0cmluZ1dpZHRoXzEuZGVmYXVsdCA9IGRlZmF1bHRfMSQyO1xuXG4gIGNvbnN0IG1hdGNoT3BlcmF0b3JzUmVnZXggPSAvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nO1xuXG4gIHZhciBlc2NhcGVTdHJpbmdSZWdleHAkMiA9IHN0cmluZyA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlZ2V4LCAnXFxcXCQmJyk7XG4gIH07XG5cbiAgY29uc3Qgbm90QXNjaWlSZWdleCA9IC9bXlxceDIwLVxceDdGXS87XG5cbiAgZnVuY3Rpb24gZ2V0UGVudWx0aW1hdGUoYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHR5cGVkZWYge3tiYWNrd2FyZHM/OiBib29sZWFufX0gU2tpcE9wdGlvbnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBjaGFyc1xuICAgKiBAcmV0dXJucyB7KHRleHQ6IHN0cmluZywgaW5kZXg6IG51bWJlciB8IGZhbHNlLCBvcHRzPzogU2tpcE9wdGlvbnMpID0+IG51bWJlciB8IGZhbHNlfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNraXAoY2hhcnMpIHtcbiAgICByZXR1cm4gKHRleHQsIGluZGV4LCBvcHRzKSA9PiB7XG4gICAgICBjb25zdCBiYWNrd2FyZHMgPSBvcHRzICYmIG9wdHMuYmFja3dhcmRzOyAvLyBBbGxvdyBgc2tpcGAgZnVuY3Rpb25zIHRvIGJlIHRocmVhZGVkIHRvZ2V0aGVyIHdpdGhvdXQgaGF2aW5nXG4gICAgICAvLyB0byBjaGVjayBmb3IgZmFpbHVyZXMgKGRpZCBzb21lb25lIHNheSBtb25hZHM/KS5cblxuICAgICAgaWYgKGluZGV4ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gdGV4dDtcbiAgICAgIGxldCBjdXJzb3IgPSBpbmRleDtcblxuICAgICAgd2hpbGUgKGN1cnNvciA+PSAwICYmIGN1cnNvciA8IGxlbmd0aCkge1xuICAgICAgICBjb25zdCBjID0gdGV4dC5jaGFyQXQoY3Vyc29yKTtcblxuICAgICAgICBpZiAoY2hhcnMgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICBpZiAoIWNoYXJzLnRlc3QoYykpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFjaGFycy5pbmNsdWRlcyhjKSkge1xuICAgICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgICAgIH1cblxuICAgICAgICBiYWNrd2FyZHMgPyBjdXJzb3ItLSA6IGN1cnNvcisrO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Vyc29yID09PSAtMSB8fCBjdXJzb3IgPT09IGxlbmd0aCkge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSBmaWxlLCByZXR1cm4gdGhlXG4gICAgICAgIC8vIG91dC1vZi1ib3VuZHMgY3Vyc29yLiBJdCdzIHVwIHRvIHRoZSBjYWxsZXIgdG8gaGFuZGxlIHRoaXNcbiAgICAgICAgLy8gY29ycmVjdGx5LiBXZSBkb24ndCB3YW50IHRvIGluZGljYXRlIGBmYWxzZWAgdGhvdWdoIGlmIGl0XG4gICAgICAgIC8vIGFjdHVhbGx5IHNraXBwZWQgdmFsaWQgY2hhcmFjdGVycy5cbiAgICAgICAgcmV0dXJuIGN1cnNvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHsodGV4dDogc3RyaW5nLCBpbmRleDogbnVtYmVyIHwgZmFsc2UsIG9wdHM/OiBTa2lwT3B0aW9ucykgPT4gbnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG5cbiAgY29uc3Qgc2tpcFdoaXRlc3BhY2UgPSBza2lwKC9cXHMvKTtcbiAgLyoqXG4gICAqIEB0eXBlIHsodGV4dDogc3RyaW5nLCBpbmRleDogbnVtYmVyIHwgZmFsc2UsIG9wdHM/OiBTa2lwT3B0aW9ucykgPT4gbnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG4gIGNvbnN0IHNraXBTcGFjZXMgPSBza2lwKFwiIFxcdFwiKTtcbiAgLyoqXG4gICAqIEB0eXBlIHsodGV4dDogc3RyaW5nLCBpbmRleDogbnVtYmVyIHwgZmFsc2UsIG9wdHM/OiBTa2lwT3B0aW9ucykgPT4gbnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG4gIGNvbnN0IHNraXBUb0xpbmVFbmQgPSBza2lwKFwiLDsgXFx0XCIpO1xuICAvKipcbiAgICogQHR5cGUgeyh0ZXh0OiBzdHJpbmcsIGluZGV4OiBudW1iZXIgfCBmYWxzZSwgb3B0cz86IFNraXBPcHRpb25zKSA9PiBudW1iZXIgfCBmYWxzZX1cbiAgICovXG5cbiAgY29uc3Qgc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lID0gc2tpcCgvW15cXHJcXG5dLyk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge251bWJlciB8IGZhbHNlfSBpbmRleFxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNraXBJbmxpbmVDb21tZW50KHRleHQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0ZXh0LmNoYXJBdChpbmRleCkgPT09IFwiL1wiICYmIHRleHQuY2hhckF0KGluZGV4ICsgMSkgPT09IFwiKlwiKSB7XG4gICAgICBmb3IgKGxldCBpID0gaW5kZXggKyAyOyBpIDwgdGV4dC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiKlwiICYmIHRleHQuY2hhckF0KGkgKyAxKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICByZXR1cm4gaSArIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgZmFsc2V9IGluZGV4XG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCBmYWxzZX1cbiAgICovXG5cblxuICBmdW5jdGlvbiBza2lwVHJhaWxpbmdDb21tZW50KHRleHQsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0ZXh0LmNoYXJBdChpbmRleCkgPT09IFwiL1wiICYmIHRleHQuY2hhckF0KGluZGV4ICsgMSkgPT09IFwiL1wiKSB7XG4gICAgICByZXR1cm4gc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lKHRleHQsIGluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH0gLy8gVGhpcyBvbmUgZG9lc24ndCB1c2UgdGhlIGFib3ZlIGhlbHBlciBmdW5jdGlvbiBiZWNhdXNlIGl0IHdhbnRzIHRvXG4gIC8vIHRlc3QgXFxyXFxuIGluIG9yZGVyIGFuZCBgc2tpcGAgZG9lc24ndCBzdXBwb3J0IG9yZGVyaW5nIGFuZCB3ZSBvbmx5XG4gIC8vIHdhbnQgdG8gc2tpcCBvbmUgbmV3bGluZS4gSXQncyBzaW1wbGUgdG8gaW1wbGVtZW50LlxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge251bWJlciB8IGZhbHNlfSBpbmRleFxuICAgKiBAcGFyYW0ge1NraXBPcHRpb25zPX0gb3B0c1xuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc2tpcE5ld2xpbmUodGV4dCwgaW5kZXgsIG9wdHMpIHtcbiAgICBjb25zdCBiYWNrd2FyZHMgPSBvcHRzICYmIG9wdHMuYmFja3dhcmRzO1xuXG4gICAgaWYgKGluZGV4ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGF0SW5kZXggPSB0ZXh0LmNoYXJBdChpbmRleCk7XG5cbiAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICBpZiAodGV4dC5jaGFyQXQoaW5kZXggLSAxKSA9PT0gXCJcXHJcIiAmJiBhdEluZGV4ID09PSBcIlxcblwiKSB7XG4gICAgICAgIHJldHVybiBpbmRleCAtIDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdEluZGV4ID09PSBcIlxcblwiIHx8IGF0SW5kZXggPT09IFwiXFxyXCIgfHwgYXRJbmRleCA9PT0gXCJcXHUyMDI4XCIgfHwgYXRJbmRleCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IC0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF0SW5kZXggPT09IFwiXFxyXCIgJiYgdGV4dC5jaGFyQXQoaW5kZXggKyAxKSA9PT0gXCJcXG5cIikge1xuICAgICAgICByZXR1cm4gaW5kZXggKyAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXRJbmRleCA9PT0gXCJcXG5cIiB8fCBhdEluZGV4ID09PSBcIlxcclwiIHx8IGF0SW5kZXggPT09IFwiXFx1MjAyOFwiIHx8IGF0SW5kZXggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgIHJldHVybiBpbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtTa2lwT3B0aW9ucz19IG9wdHNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzTmV3bGluZSh0ZXh0LCBpbmRleCwgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGNvbnN0IGlkeCA9IHNraXBTcGFjZXModGV4dCwgb3B0cy5iYWNrd2FyZHMgPyBpbmRleCAtIDEgOiBpbmRleCwgb3B0cyk7XG4gICAgY29uc3QgaWR4MiA9IHNraXBOZXdsaW5lKHRleHQsIGlkeCwgb3B0cyk7XG4gICAgcmV0dXJuIGlkeCAhPT0gaWR4MjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzTmV3bGluZUluUmFuZ2UodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lc24ndCBpZ25vcmUgbGVhZGluZyBjb21tZW50cyB1bmxpa2UgaXNOZXh0TGluZUVtcHR5XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBOXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7Tn0gbm9kZVxuICAgKiBAcGFyYW0geyhub2RlOiBOKSA9PiBudW1iZXJ9IGxvY1N0YXJ0XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNQcmV2aW91c0xpbmVFbXB0eSh0ZXh0LCBub2RlLCBsb2NTdGFydCkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgZmFsc2V9ICovXG4gICAgbGV0IGlkeCA9IGxvY1N0YXJ0KG5vZGUpIC0gMTtcbiAgICBpZHggPSBza2lwU3BhY2VzKHRleHQsIGlkeCwge1xuICAgICAgYmFja3dhcmRzOiB0cnVlXG4gICAgfSk7XG4gICAgaWR4ID0gc2tpcE5ld2xpbmUodGV4dCwgaWR4LCB7XG4gICAgICBiYWNrd2FyZHM6IHRydWVcbiAgICB9KTtcbiAgICBpZHggPSBza2lwU3BhY2VzKHRleHQsIGlkeCwge1xuICAgICAgYmFja3dhcmRzOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3QgaWR4MiA9IHNraXBOZXdsaW5lKHRleHQsIGlkeCwge1xuICAgICAgYmFja3dhcmRzOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGlkeCAhPT0gaWR4MjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXgodGV4dCwgaW5kZXgpIHtcbiAgICAvKiogQHR5cGUge251bWJlciB8IGZhbHNlfSAqL1xuICAgIGxldCBvbGRJZHggPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgZmFsc2V9ICovXG5cbiAgICBsZXQgaWR4ID0gaW5kZXg7XG5cbiAgICB3aGlsZSAoaWR4ICE9PSBvbGRJZHgpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gc2tpcCBhbGwgdGhlIHBvdGVudGlhbCB0cmFpbGluZyBpbmxpbmUgY29tbWVudHNcbiAgICAgIG9sZElkeCA9IGlkeDtcbiAgICAgIGlkeCA9IHNraXBUb0xpbmVFbmQodGV4dCwgaWR4KTtcbiAgICAgIGlkeCA9IHNraXBJbmxpbmVDb21tZW50KHRleHQsIGlkeCk7XG4gICAgICBpZHggPSBza2lwU3BhY2VzKHRleHQsIGlkeCk7XG4gICAgfVxuXG4gICAgaWR4ID0gc2tpcFRyYWlsaW5nQ29tbWVudCh0ZXh0LCBpZHgpO1xuICAgIGlkeCA9IHNraXBOZXdsaW5lKHRleHQsIGlkeCk7XG4gICAgcmV0dXJuIGlkeCAhPT0gZmFsc2UgJiYgaGFzTmV3bGluZSh0ZXh0LCBpZHgpO1xuICB9XG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgTlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge059IG5vZGVcbiAgICogQHBhcmFtIHsobm9kZTogTikgPT4gbnVtYmVyfSBsb2NFbmRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNOZXh0TGluZUVtcHR5KHRleHQsIG5vZGUsIGxvY0VuZCkge1xuICAgIHJldHVybiBpc05leHRMaW5lRW1wdHlBZnRlckluZGV4KHRleHQsIGxvY0VuZChub2RlKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZHhcbiAgICogQHJldHVybnMge251bWJlciB8IGZhbHNlfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4KHRleHQsIGlkeCkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgZmFsc2V9ICovXG4gICAgbGV0IG9sZElkeCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtudW1iZXIgfCBmYWxzZX0gKi9cblxuICAgIGxldCBuZXh0SWR4ID0gaWR4O1xuXG4gICAgd2hpbGUgKG5leHRJZHggIT09IG9sZElkeCkge1xuICAgICAgb2xkSWR4ID0gbmV4dElkeDtcbiAgICAgIG5leHRJZHggPSBza2lwU3BhY2VzKHRleHQsIG5leHRJZHgpO1xuICAgICAgbmV4dElkeCA9IHNraXBJbmxpbmVDb21tZW50KHRleHQsIG5leHRJZHgpO1xuICAgICAgbmV4dElkeCA9IHNraXBUcmFpbGluZ0NvbW1lbnQodGV4dCwgbmV4dElkeCk7XG4gICAgICBuZXh0SWR4ID0gc2tpcE5ld2xpbmUodGV4dCwgbmV4dElkeCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRJZHg7XG4gIH1cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBOXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7Tn0gbm9kZVxuICAgKiBAcGFyYW0geyhub2RlOiBOKSA9PiBudW1iZXJ9IGxvY0VuZFxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgZmFsc2V9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4KHRleHQsIG5vZGUsIGxvY0VuZCkge1xuICAgIHJldHVybiBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXhXaXRoU3RhcnRJbmRleCh0ZXh0LCBsb2NFbmQobm9kZSkpO1xuICB9XG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgTlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge059IG5vZGVcbiAgICogQHBhcmFtIHsobm9kZTogTikgPT4gbnVtYmVyfSBsb2NFbmRcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVyKHRleHQsIG5vZGUsIGxvY0VuZCkge1xuICAgIHJldHVybiB0ZXh0LmNoYXJBdCggLy8gQHRzLWlnbm9yZSA9PiBUQkQ6IGNhbiByZXR1cm4gZmFsc2UsIHNob3VsZCB3ZSBkZWZpbmUgYSBmYWxsYmFjaz9cbiAgICBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgodGV4dCwgbm9kZSwgbG9jRW5kKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge1NraXBPcHRpb25zPX0gb3B0c1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBoYXNTcGFjZXModGV4dCwgaW5kZXgsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBjb25zdCBpZHggPSBza2lwU3BhY2VzKHRleHQsIG9wdHMuYmFja3dhcmRzID8gaW5kZXggLSAxIDogaW5kZXgsIG9wdHMpO1xuICAgIHJldHVybiBpZHggIT09IGluZGV4O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3tyYW5nZT86IFtudW1iZXIsIG51bWJlcl0sIHN0YXJ0PzogbnVtYmVyfX0gbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRMb2NTdGFydChub2RlLCBpbmRleCkge1xuICAgIGlmIChub2RlLnJhbmdlKSB7XG4gICAgICBub2RlLnJhbmdlWzBdID0gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhcnQgPSBpbmRleDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7e3JhbmdlPzogW251bWJlciwgbnVtYmVyXSwgZW5kPzogbnVtYmVyfX0gbm9kZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG5cblxuICBmdW5jdGlvbiBzZXRMb2NFbmQobm9kZSwgaW5kZXgpIHtcbiAgICBpZiAobm9kZS5yYW5nZSkge1xuICAgICAgbm9kZS5yYW5nZVsxXSA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmVuZCA9IGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IFBSRUNFREVOQ0UgPSB7fTtcbiAgW1tcInw+XCJdLCBbXCI/P1wiXSwgW1wifHxcIl0sIFtcIiYmXCJdLCBbXCJ8XCJdLCBbXCJeXCJdLCBbXCImXCJdLCBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdLCBbXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIl0sIFtcIj4+XCIsIFwiPDxcIiwgXCI+Pj5cIl0sIFtcIitcIiwgXCItXCJdLCBbXCIqXCIsIFwiL1wiLCBcIiVcIl0sIFtcIioqXCJdXS5mb3JFYWNoKCh0aWVyLCBpKSA9PiB7XG4gICAgdGllci5mb3JFYWNoKG9wID0+IHtcbiAgICAgIFBSRUNFREVOQ0Vbb3BdID0gaTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0UHJlY2VkZW5jZShvcCkge1xuICAgIHJldHVybiBQUkVDRURFTkNFW29wXTtcbiAgfVxuXG4gIGNvbnN0IGVxdWFsaXR5T3BlcmF0b3JzID0ge1xuICAgIFwiPT1cIjogdHJ1ZSxcbiAgICBcIiE9XCI6IHRydWUsXG4gICAgXCI9PT1cIjogdHJ1ZSxcbiAgICBcIiE9PVwiOiB0cnVlXG4gIH07XG4gIGNvbnN0IG11bHRpcGxpY2F0aXZlT3BlcmF0b3JzID0ge1xuICAgIFwiKlwiOiB0cnVlLFxuICAgIFwiL1wiOiB0cnVlLFxuICAgIFwiJVwiOiB0cnVlXG4gIH07XG4gIGNvbnN0IGJpdHNoaWZ0T3BlcmF0b3JzID0ge1xuICAgIFwiPj5cIjogdHJ1ZSxcbiAgICBcIj4+PlwiOiB0cnVlLFxuICAgIFwiPDxcIjogdHJ1ZVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNob3VsZEZsYXR0ZW4ocGFyZW50T3AsIG5vZGVPcCkge1xuICAgIGlmIChnZXRQcmVjZWRlbmNlKG5vZGVPcCkgIT09IGdldFByZWNlZGVuY2UocGFyZW50T3ApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyAqKiBpcyByaWdodC1hc3NvY2lhdGl2ZVxuICAgIC8vIHggKiogeSAqKiB6IC0tPiB4ICoqICh5ICoqIHopXG5cblxuICAgIGlmIChwYXJlbnRPcCA9PT0gXCIqKlwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyB4ID09IHkgPT0geiAtLT4gKHggPT0geSkgPT0gelxuXG5cbiAgICBpZiAoZXF1YWxpdHlPcGVyYXRvcnNbcGFyZW50T3BdICYmIGVxdWFsaXR5T3BlcmF0b3JzW25vZGVPcF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIHggKiB5ICUgeiAtLT4gKHggKiB5KSAlIHpcblxuXG4gICAgaWYgKG5vZGVPcCA9PT0gXCIlXCIgJiYgbXVsdGlwbGljYXRpdmVPcGVyYXRvcnNbcGFyZW50T3BdIHx8IHBhcmVudE9wID09PSBcIiVcIiAmJiBtdWx0aXBsaWNhdGl2ZU9wZXJhdG9yc1tub2RlT3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyB4ICogeSAvIHogLS0+ICh4ICogeSkgLyB6XG4gICAgLy8geCAvIHkgKiB6IC0tPiAoeCAvIHkpICogelxuXG5cbiAgICBpZiAobm9kZU9wICE9PSBwYXJlbnRPcCAmJiBtdWx0aXBsaWNhdGl2ZU9wZXJhdG9yc1tub2RlT3BdICYmIG11bHRpcGxpY2F0aXZlT3BlcmF0b3JzW3BhcmVudE9wXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8geCA8PCB5IDw8IHogLS0+ICh4IDw8IHkpIDw8IHpcblxuXG4gICAgaWYgKGJpdHNoaWZ0T3BlcmF0b3JzW3BhcmVudE9wXSAmJiBiaXRzaGlmdE9wZXJhdG9yc1tub2RlT3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0JpdHdpc2VPcGVyYXRvcihvcGVyYXRvcikge1xuICAgIHJldHVybiAhIWJpdHNoaWZ0T3BlcmF0b3JzW29wZXJhdG9yXSB8fCBvcGVyYXRvciA9PT0gXCJ8XCIgfHwgb3BlcmF0b3IgPT09IFwiXlwiIHx8IG9wZXJhdG9yID09PSBcIiZcIjtcbiAgfSAvLyBUZXN0cyBpZiBhbiBleHByZXNzaW9uIHN0YXJ0cyB3aXRoIGB7YCwgb3IgKGlmIGZvcmJpZEZ1bmN0aW9uQ2xhc3NBbmREb0V4cHJcbiAgLy8gaG9sZHMpIGBmdW5jdGlvbmAsIGBjbGFzc2AsIG9yIGBkbyB7fWAuIFdpbGwgYmUgb3ZlcnplYWxvdXMgaWYgdGhlcmUnc1xuICAvLyBhbHJlYWR5IG5lY2Vzc2FyeSBncm91cGluZyBwYXJlbnRoZXNlcy5cblxuXG4gIGZ1bmN0aW9uIHN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuKG5vZGUsIGZvcmJpZEZ1bmN0aW9uQ2xhc3NBbmREb0V4cHIpIHtcbiAgICBub2RlID0gZ2V0TGVmdE1vc3Qobm9kZSk7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkRvRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcjtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLm9iamVjdCwgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUudGFnLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAvLyBJSUZFcyBhcmUgYWx3YXlzIGFscmVhZHkgcGFyZW50aGVzaXplZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLnRhZywgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAvLyBJSUZFcyBhcmUgYWx3YXlzIGFscmVhZHkgcGFyZW50aGVzaXplZFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLmNhbGxlZSwgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuKG5vZGUudGVzdCwgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAhbm9kZS5wcmVmaXggJiYgc3RhcnRzV2l0aE5vTG9va2FoZWFkVG9rZW4obm9kZS5hcmd1bWVudCwgZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwcik7XG5cbiAgICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5vYmplY3QgJiYgc3RhcnRzV2l0aE5vTG9va2FoZWFkVG9rZW4obm9kZS5vYmplY3QsIGZvcmJpZEZ1bmN0aW9uQ2xhc3NBbmREb0V4cHIpO1xuXG4gICAgICBjYXNlIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLmV4cHJlc3Npb25zWzBdLCBmb3JiaWRGdW5jdGlvbkNsYXNzQW5kRG9FeHByKTtcblxuICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbihub2RlLmV4cHJlc3Npb24sIGZvcmJpZEZ1bmN0aW9uQ2xhc3NBbmREb0V4cHIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGVmdE1vc3Qobm9kZSkge1xuICAgIGlmIChub2RlLmxlZnQpIHtcbiAgICAgIHJldHVybiBnZXRMZWZ0TW9zdChub2RlLmxlZnQpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhYldpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc3RhcnRJbmRleFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEFsaWdubWVudFNpemUodmFsdWUsIHRhYldpZHRoLCBzdGFydEluZGV4KSB7XG4gICAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgICBsZXQgc2l6ZSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodmFsdWVbaV0gPT09IFwiXFx0XCIpIHtcbiAgICAgICAgLy8gVGFicyBiZWhhdmUgaW4gYSB3YXkgdGhhdCB0aGV5IGFyZSBhbGlnbmVkIHRvIHRoZSBuZWFyZXN0XG4gICAgICAgIC8vIG11bHRpcGxlIG9mIHRhYldpZHRoOlxuICAgICAgICAvLyAwIC0+IDQsIDEgLT4gNCwgMiAtPiA0LCAzIC0+IDRcbiAgICAgICAgLy8gNCAtPiA4LCA1IC0+IDgsIDYgLT4gOCwgNyAtPiA4IC4uLlxuICAgICAgICBzaXplID0gc2l6ZSArIHRhYldpZHRoIC0gc2l6ZSAlIHRhYldpZHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaXplO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhYldpZHRoXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0SW5kZW50U2l6ZSh2YWx1ZSwgdGFiV2lkdGgpIHtcbiAgICBjb25zdCBsYXN0TmV3bGluZUluZGV4ID0gdmFsdWUubGFzdEluZGV4T2YoXCJcXG5cIik7XG5cbiAgICBpZiAobGFzdE5ld2xpbmVJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRBbGlnbm1lbnRTaXplKCAvLyBBbGwgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZXNcbiAgICB2YWx1ZS5zbGljZShsYXN0TmV3bGluZUluZGV4ICsgMSkubWF0Y2goL15bIFxcdF0qLylbMF0sIHRhYldpZHRoKTtcbiAgfVxuICAvKipcbiAgICogQHR5cGVkZWYgeydcIicgfCBcIidcIn0gUXVvdGVcbiAgICovXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByYXdcbiAgICogQHBhcmFtIHtRdW90ZX0gcHJlZmVycmVkUXVvdGVcbiAgICogQHJldHVybnMge1F1b3RlfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFByZWZlcnJlZFF1b3RlKHJhdywgcHJlZmVycmVkUXVvdGUpIHtcbiAgICAvLyBgcmF3Q29udGVudGAgaXMgdGhlIHN0cmluZyBleGFjdGx5IGxpa2UgaXQgYXBwZWFyZWQgaW4gdGhlIGlucHV0IHNvdXJjZVxuICAgIC8vIGNvZGUsIHdpdGhvdXQgaXRzIGVuY2xvc2luZyBxdW90ZXMuXG4gICAgY29uc3QgcmF3Q29udGVudCA9IHJhdy5zbGljZSgxLCAtMSk7XG4gICAgLyoqIEB0eXBlIHt7IHF1b3RlOiAnXCInLCByZWdleDogUmVnRXhwIH19ICovXG5cbiAgICBjb25zdCBkb3VibGUgPSB7XG4gICAgICBxdW90ZTogJ1wiJyxcbiAgICAgIHJlZ2V4OiAvXCIvZ1xuICAgIH07XG4gICAgLyoqIEB0eXBlIHt7IHF1b3RlOiBcIidcIiwgcmVnZXg6IFJlZ0V4cCB9fSAqL1xuXG4gICAgY29uc3Qgc2luZ2xlID0ge1xuICAgICAgcXVvdGU6IFwiJ1wiLFxuICAgICAgcmVnZXg6IC8nL2dcbiAgICB9O1xuICAgIGNvbnN0IHByZWZlcnJlZCA9IHByZWZlcnJlZFF1b3RlID09PSBcIidcIiA/IHNpbmdsZSA6IGRvdWJsZTtcbiAgICBjb25zdCBhbHRlcm5hdGUgPSBwcmVmZXJyZWQgPT09IHNpbmdsZSA/IGRvdWJsZSA6IHNpbmdsZTtcbiAgICBsZXQgcmVzdWx0ID0gcHJlZmVycmVkLnF1b3RlOyAvLyBJZiBgcmF3Q29udGVudGAgY29udGFpbnMgYXQgbGVhc3Qgb25lIG9mIHRoZSBxdW90ZSBwcmVmZXJyZWQgZm9yIGVuY2xvc2luZ1xuICAgIC8vIHRoZSBzdHJpbmcsIHdlIG1pZ2h0IHdhbnQgdG8gZW5jbG9zZSB3aXRoIHRoZSBhbHRlcm5hdGUgcXVvdGUgaW5zdGVhZCwgdG9cbiAgICAvLyBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIGVzY2FwZWQgcXVvdGVzLlxuXG4gICAgaWYgKHJhd0NvbnRlbnQuaW5jbHVkZXMocHJlZmVycmVkLnF1b3RlKSB8fCByYXdDb250ZW50LmluY2x1ZGVzKGFsdGVybmF0ZS5xdW90ZSkpIHtcbiAgICAgIGNvbnN0IG51bVByZWZlcnJlZFF1b3RlcyA9IChyYXdDb250ZW50Lm1hdGNoKHByZWZlcnJlZC5yZWdleCkgfHwgW10pLmxlbmd0aDtcbiAgICAgIGNvbnN0IG51bUFsdGVybmF0ZVF1b3RlcyA9IChyYXdDb250ZW50Lm1hdGNoKGFsdGVybmF0ZS5yZWdleCkgfHwgW10pLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IG51bVByZWZlcnJlZFF1b3RlcyA+IG51bUFsdGVybmF0ZVF1b3RlcyA/IGFsdGVybmF0ZS5xdW90ZSA6IHByZWZlcnJlZC5xdW90ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRTdHJpbmcocmF3LCBvcHRpb25zLCBpc0RpcmVjdGl2ZUxpdGVyYWwpIHtcbiAgICAvLyBgcmF3Q29udGVudGAgaXMgdGhlIHN0cmluZyBleGFjdGx5IGxpa2UgaXQgYXBwZWFyZWQgaW4gdGhlIGlucHV0IHNvdXJjZVxuICAgIC8vIGNvZGUsIHdpdGhvdXQgaXRzIGVuY2xvc2luZyBxdW90ZXMuXG4gICAgY29uc3QgcmF3Q29udGVudCA9IHJhdy5zbGljZSgxLCAtMSk7IC8vIENoZWNrIGZvciB0aGUgYWx0ZXJuYXRlIHF1b3RlLCB0byBkZXRlcm1pbmUgaWYgd2UncmUgYWxsb3dlZCB0byBzd2FwXG4gICAgLy8gdGhlIHF1b3RlcyBvbiBhIERpcmVjdGl2ZUxpdGVyYWwuXG5cbiAgICBjb25zdCBjYW5DaGFuZ2VEaXJlY3RpdmVRdW90ZXMgPSAhcmF3Q29udGVudC5pbmNsdWRlcygnXCInKSAmJiAhcmF3Q29udGVudC5pbmNsdWRlcyhcIidcIik7XG4gICAgLyoqIEB0eXBlIHtRdW90ZX0gKi9cblxuICAgIGNvbnN0IGVuY2xvc2luZ1F1b3RlID0gb3B0aW9ucy5wYXJzZXIgPT09IFwianNvblwiID8gJ1wiJyA6IG9wdGlvbnMuX19pc0luSHRtbEF0dHJpYnV0ZSA/IFwiJ1wiIDogZ2V0UHJlZmVycmVkUXVvdGUocmF3LCBvcHRpb25zLnNpbmdsZVF1b3RlID8gXCInXCIgOiAnXCInKTsgLy8gRGlyZWN0aXZlcyBhcmUgZXhhY3QgY29kZSB1bml0IHNlcXVlbmNlcywgd2hpY2ggbWVhbnMgdGhhdCB5b3UgY2FuJ3RcbiAgICAvLyBjaGFuZ2UgdGhlIGVzY2FwZSBzZXF1ZW5jZXMgdGhleSB1c2UuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9pc3N1ZXMvMTU1NVxuICAgIC8vIGFuZCBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI2RpcmVjdGl2ZS1wcm9sb2d1ZVxuXG4gICAgaWYgKGlzRGlyZWN0aXZlTGl0ZXJhbCkge1xuICAgICAgaWYgKGNhbkNoYW5nZURpcmVjdGl2ZVF1b3Rlcykge1xuICAgICAgICByZXR1cm4gZW5jbG9zaW5nUXVvdGUgKyByYXdDb250ZW50ICsgZW5jbG9zaW5nUXVvdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYXc7XG4gICAgfSAvLyBJdCBtaWdodCBzb3VuZCB1bm5lY2Vzc2FyeSB0byB1c2UgYG1ha2VTdHJpbmdgIGV2ZW4gaWYgdGhlIHN0cmluZyBhbHJlYWR5XG4gICAgLy8gaXMgZW5jbG9zZWQgd2l0aCBgZW5jbG9zaW5nUXVvdGVgLCBidXQgaXQgaXNuJ3QuIFRoZSBzdHJpbmcgY291bGQgY29udGFpblxuICAgIC8vIHVubmVjZXNzYXJ5IGVzY2FwZXMgKHN1Y2ggYXMgaW4gYFwiXFwnXCJgKS4gQWx3YXlzIHVzaW5nIGBtYWtlU3RyaW5nYCBtYWtlc1xuICAgIC8vIHN1cmUgdGhhdCB3ZSBjb25zaXN0ZW50bHkgb3V0cHV0IHRoZSBtaW5pbXVtIGFtb3VudCBvZiBlc2NhcGVkIHF1b3Rlcy5cblxuXG4gICAgcmV0dXJuIG1ha2VTdHJpbmcocmF3Q29udGVudCwgZW5jbG9zaW5nUXVvdGUsICEob3B0aW9ucy5wYXJzZXIgPT09IFwiY3NzXCIgfHwgb3B0aW9ucy5wYXJzZXIgPT09IFwibGVzc1wiIHx8IG9wdGlvbnMucGFyc2VyID09PSBcInNjc3NcIiB8fCBvcHRpb25zLmVtYmVkZGVkSW5IdG1sKSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByYXdDb250ZW50XG4gICAqIEBwYXJhbSB7UXVvdGV9IGVuY2xvc2luZ1F1b3RlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuZXNjYXBlVW5uZWNlc3NhcnlFc2NhcGVzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbWFrZVN0cmluZyhyYXdDb250ZW50LCBlbmNsb3NpbmdRdW90ZSwgdW5lc2NhcGVVbm5lY2Vzc2FyeUVzY2FwZXMpIHtcbiAgICBjb25zdCBvdGhlclF1b3RlID0gZW5jbG9zaW5nUXVvdGUgPT09ICdcIicgPyBcIidcIiA6ICdcIic7IC8vIE1hdGNoZXMgX2FueV8gZXNjYXBlIGFuZCB1bmVzY2FwZWQgcXVvdGVzIChib3RoIHNpbmdsZSBhbmQgZG91YmxlKS5cblxuICAgIGNvbnN0IHJlZ2V4ID0gL1xcXFwoW1xcc1xcU10pfChbJ1wiXSkvZzsgLy8gRXNjYXBlIGFuZCB1bmVzY2FwZSBzaW5nbGUgYW5kIGRvdWJsZSBxdW90ZXMgYXMgbmVlZGVkIHRvIGJlIGFibGUgdG9cbiAgICAvLyBlbmNsb3NlIGByYXdDb250ZW50YCB3aXRoIGBlbmNsb3NpbmdRdW90ZWAuXG5cbiAgICBjb25zdCBuZXdDb250ZW50ID0gcmF3Q29udGVudC5yZXBsYWNlKHJlZ2V4LCAobWF0Y2gsIGVzY2FwZWQsIHF1b3RlKSA9PiB7XG4gICAgICAvLyBJZiB3ZSBtYXRjaGVkIGFuIGVzY2FwZSwgYW5kIHRoZSBlc2NhcGVkIGNoYXJhY3RlciBpcyBhIHF1b3RlIG9mIHRoZVxuICAgICAgLy8gb3RoZXIgdHlwZSB0aGFuIHdlIGludGVuZCB0byBlbmNsb3NlIHRoZSBzdHJpbmcgd2l0aCwgdGhlcmUncyBubyBuZWVkIGZvclxuICAgICAgLy8gaXQgdG8gYmUgZXNjYXBlZCwgc28gcmV0dXJuIGl0IF93aXRob3V0XyB0aGUgYmFja3NsYXNoLlxuICAgICAgaWYgKGVzY2FwZWQgPT09IG90aGVyUXVvdGUpIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgICB9IC8vIElmIHdlIG1hdGNoZWQgYW4gdW5lc2NhcGVkIHF1b3RlIGFuZCBpdCBpcyBvZiB0aGUgX3NhbWVfIHR5cGUgYXMgd2VcbiAgICAgIC8vIGludGVuZCB0byBlbmNsb3NlIHRoZSBzdHJpbmcgd2l0aCwgaXQgbXVzdCBiZSBlc2NhcGVkLCBzbyByZXR1cm4gaXQgd2l0aFxuICAgICAgLy8gYSBiYWNrc2xhc2guXG5cblxuICAgICAgaWYgKHF1b3RlID09PSBlbmNsb3NpbmdRdW90ZSkge1xuICAgICAgICByZXR1cm4gXCJcXFxcXCIgKyBxdW90ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHF1b3RlKSB7XG4gICAgICAgIHJldHVybiBxdW90ZTtcbiAgICAgIH0gLy8gVW5lc2NhcGUgYW55IHVubmVjZXNzYXJpbHkgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAvLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvYmxvYi9kZTBiNGFkN2JkODIwYWRlNDFiMWY2MDYwMDhiZWE2ODY4M2RjMTFhL2xpYi9ydWxlcy9uby11c2VsZXNzLWVzY2FwZS5qcyNMMjdcblxuXG4gICAgICByZXR1cm4gdW5lc2NhcGVVbm5lY2Vzc2FyeUVzY2FwZXMgJiYgL15bXlxcXFxucnZ0YmZ1eFxcclxcblxcdTIwMjhcXHUyMDI5XCInMC03XSQvLnRlc3QoZXNjYXBlZCkgPyBlc2NhcGVkIDogXCJcXFxcXCIgKyBlc2NhcGVkO1xuICAgIH0pO1xuICAgIHJldHVybiBlbmNsb3NpbmdRdW90ZSArIG5ld0NvbnRlbnQgKyBlbmNsb3NpbmdRdW90ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50TnVtYmVyKHJhd051bWJlcikge1xuICAgIHJldHVybiByYXdOdW1iZXIudG9Mb3dlckNhc2UoKSAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgcGx1cyBhbmQgemVyb2VzIGZyb20gc2NpZW50aWZpYyBub3RhdGlvbi5cbiAgICAucmVwbGFjZSgvXihbKy1dP1tcXGQuXStlKSg/OlxcK3woLSkpPzAqKFxcZCkvLCBcIiQxJDIkM1wiKSAvLyBSZW1vdmUgdW5uZWNlc3Nhcnkgc2NpZW50aWZpYyBub3RhdGlvbiAoMWUwKS5cbiAgICAucmVwbGFjZSgvXihbKy1dP1tcXGQuXSspZVsrLV0/MCskLywgXCIkMVwiKSAvLyBNYWtlIHN1cmUgbnVtYmVycyBhbHdheXMgc3RhcnQgd2l0aCBhIGRpZ2l0LlxuICAgIC5yZXBsYWNlKC9eKFsrLV0pP1xcLi8sIFwiJDEwLlwiKSAvLyBSZW1vdmUgZXh0cmFuZW91cyB0cmFpbGluZyBkZWNpbWFsIHplcm9lcy5cbiAgICAucmVwbGFjZSgvKFxcLlxcZCs/KTArKD89ZXwkKS8sIFwiJDFcIikgLy8gUmVtb3ZlIHRyYWlsaW5nIGRvdC5cbiAgICAucmVwbGFjZSgvXFwuKD89ZXwkKS8sIFwiXCIpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRNYXhDb250aW51b3VzQ291bnQoc3RyLCB0YXJnZXQpIHtcbiAgICBjb25zdCByZXN1bHRzID0gc3RyLm1hdGNoKG5ldyBSZWdFeHAoXCIoXCIuY29uY2F0KGVzY2FwZVN0cmluZ1JlZ2V4cCQyKHRhcmdldCksIFwiKStcIiksIFwiZ1wiKSk7XG5cbiAgICBpZiAocmVzdWx0cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChtYXhDb3VudCwgcmVzdWx0KSA9PiBNYXRoLm1heChtYXhDb3VudCwgcmVzdWx0Lmxlbmd0aCAvIHRhcmdldC5sZW5ndGgpLCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pbk5vdFByZXNlbnRDb250aW51b3VzQ291bnQoc3RyLCB0YXJnZXQpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gc3RyLm1hdGNoKG5ldyBSZWdFeHAoXCIoXCIuY29uY2F0KGVzY2FwZVN0cmluZ1JlZ2V4cCQyKHRhcmdldCksIFwiKStcIiksIFwiZ1wiKSk7XG5cbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3QgY291bnRQcmVzZW50ID0gbmV3IE1hcCgpO1xuICAgIGxldCBtYXggPSAwO1xuXG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICBjb25zdCBjb3VudCA9IG1hdGNoLmxlbmd0aCAvIHRhcmdldC5sZW5ndGg7XG4gICAgICBjb3VudFByZXNlbnQuc2V0KGNvdW50LCB0cnVlKTtcblxuICAgICAgaWYgKGNvdW50ID4gbWF4KSB7XG4gICAgICAgIG1heCA9IGNvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGlmICghY291bnRQcmVzZW50LmdldChpKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4ICsgMTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRTdHJpbmdXaWR0aCh0ZXh0KSB7XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IC8vIHNob3J0Y3V0IHRvIGF2b2lkIG5lZWRsZXNzIHN0cmluZyBgUmVnRXhwYHMsIHJlcGxhY2VtZW50cywgYW5kIGFsbG9jYXRpb25zIHdpdGhpbiBgc3RyaW5nLXdpZHRoYFxuXG5cbiAgICBpZiAoIW5vdEFzY2lpUmVnZXgudGVzdCh0ZXh0KSkge1xuICAgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdXaWR0aF8xKHRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzSWdub3JlQ29tbWVudChwYXRoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICByZXR1cm4gaGFzTm9kZUlnbm9yZUNvbW1lbnQobm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOb2RlSWdub3JlQ29tbWVudChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUuY29tbWVudHMgJiYgbm9kZS5jb21tZW50cy5sZW5ndGggPiAwICYmIG5vZGUuY29tbWVudHMuc29tZShjb21tZW50ID0+IGlzTm9kZUlnbm9yZUNvbW1lbnQoY29tbWVudCkgJiYgIWNvbW1lbnQudW5pZ25vcmUpIHx8IG5vZGUucHJldHRpZXJJZ25vcmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlSWdub3JlQ29tbWVudChjb21tZW50KSB7XG4gICAgcmV0dXJuIGNvbW1lbnQudmFsdWUudHJpbSgpID09PSBcInByZXR0aWVyLWlnbm9yZVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ29tbWVudEhlbHBlcihub2RlLCBjb21tZW50KSB7XG4gICAgY29uc3QgY29tbWVudHMgPSBub2RlLmNvbW1lbnRzIHx8IChub2RlLmNvbW1lbnRzID0gW10pO1xuICAgIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgY29tbWVudC5wcmludGVkID0gZmFsc2U7IC8vIEZvciBzb21lIHJlYXNvbiwgVHlwZVNjcmlwdCBwYXJzZXMgYC8vIHhgIGluc2lkZSBvZiBKU1hUZXh0IGFzIGEgY29tbWVudFxuICAgIC8vIFdlIGFscmVhZHkgXCJwcmludFwiIGl0IHZpYSB0aGUgcmF3IHRleHQsIHdlIGRvbid0IG5lZWQgdG8gcmUtcHJpbnQgaXQgYXMgYVxuICAgIC8vIGNvbW1lbnRcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSlNYVGV4dFwiKSB7XG4gICAgICBjb21tZW50LnByaW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExlYWRpbmdDb21tZW50KG5vZGUsIGNvbW1lbnQpIHtcbiAgICBjb21tZW50LmxlYWRpbmcgPSB0cnVlO1xuICAgIGNvbW1lbnQudHJhaWxpbmcgPSBmYWxzZTtcbiAgICBhZGRDb21tZW50SGVscGVyKG5vZGUsIGNvbW1lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGFuZ2xpbmdDb21tZW50KG5vZGUsIGNvbW1lbnQpIHtcbiAgICBjb21tZW50LmxlYWRpbmcgPSBmYWxzZTtcbiAgICBjb21tZW50LnRyYWlsaW5nID0gZmFsc2U7XG4gICAgYWRkQ29tbWVudEhlbHBlcihub2RlLCBjb21tZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFRyYWlsaW5nQ29tbWVudChub2RlLCBjb21tZW50KSB7XG4gICAgY29tbWVudC5sZWFkaW5nID0gZmFsc2U7XG4gICAgY29tbWVudC50cmFpbGluZyA9IHRydWU7XG4gICAgYWRkQ29tbWVudEhlbHBlcihub2RlLCBjb21tZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzV2l0aGluUGFyZW50QXJyYXlQcm9wZXJ0eShwYXRoLCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmVudFtwcm9wZXJ0eU5hbWVdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHBhdGguZ2V0TmFtZSgpO1xuICAgIHJldHVybiBwYXJlbnRbcHJvcGVydHlOYW1lXVtrZXldID09PSBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZUVuZE9mTGluZVdpdGgodGV4dCwgcmVwbGFjZW1lbnQpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHRleHQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcGFydHMucHVzaChyZXBsYWNlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgdmFyIHV0aWwkMSA9IHtcbiAgICByZXBsYWNlRW5kT2ZMaW5lV2l0aCxcbiAgICBnZXRTdHJpbmdXaWR0aCxcbiAgICBnZXRNYXhDb250aW51b3VzQ291bnQsXG4gICAgZ2V0TWluTm90UHJlc2VudENvbnRpbnVvdXNDb3VudCxcbiAgICBnZXRQcmVjZWRlbmNlLFxuICAgIHNob3VsZEZsYXR0ZW4sXG4gICAgaXNCaXR3aXNlT3BlcmF0b3IsXG4gICAgZ2V0UGVudWx0aW1hdGUsXG4gICAgZ2V0TGFzdCxcbiAgICBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXhXaXRoU3RhcnRJbmRleCxcbiAgICBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgsXG4gICAgZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlcixcbiAgICBza2lwLFxuICAgIHNraXBXaGl0ZXNwYWNlLFxuICAgIHNraXBTcGFjZXMsXG4gICAgc2tpcFRvTGluZUVuZCxcbiAgICBza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmUsXG4gICAgc2tpcElubGluZUNvbW1lbnQsXG4gICAgc2tpcFRyYWlsaW5nQ29tbWVudCxcbiAgICBza2lwTmV3bGluZSxcbiAgICBpc05leHRMaW5lRW1wdHlBZnRlckluZGV4LFxuICAgIGlzTmV4dExpbmVFbXB0eSxcbiAgICBpc1ByZXZpb3VzTGluZUVtcHR5LFxuICAgIGhhc05ld2xpbmUsXG4gICAgaGFzTmV3bGluZUluUmFuZ2UsXG4gICAgaGFzU3BhY2VzLFxuICAgIHNldExvY1N0YXJ0LFxuICAgIHNldExvY0VuZCxcbiAgICBzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbixcbiAgICBnZXRBbGlnbm1lbnRTaXplLFxuICAgIGdldEluZGVudFNpemUsXG4gICAgZ2V0UHJlZmVycmVkUXVvdGUsXG4gICAgcHJpbnRTdHJpbmcsXG4gICAgcHJpbnROdW1iZXIsXG4gICAgaGFzSWdub3JlQ29tbWVudCxcbiAgICBoYXNOb2RlSWdub3JlQ29tbWVudCxcbiAgICBpc05vZGVJZ25vcmVDb21tZW50LFxuICAgIG1ha2VTdHJpbmcsXG4gICAgYWRkTGVhZGluZ0NvbW1lbnQsXG4gICAgYWRkRGFuZ2xpbmdDb21tZW50LFxuICAgIGFkZFRyYWlsaW5nQ29tbWVudCxcbiAgICBpc1dpdGhpblBhcmVudEFycmF5UHJvcGVydHlcbiAgfTtcblxuICBmdW5jdGlvbiBndWVzc0VuZE9mTGluZSh0ZXh0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0ZXh0LmluZGV4T2YoXCJcXHJcIik7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHRleHQuY2hhckF0KGluZGV4ICsgMSkgPT09IFwiXFxuXCIgPyBcImNybGZcIiA6IFwiY3JcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJsZlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gY29udmVydEVuZE9mTGluZVRvQ2hhcnModmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiY3JcIjpcbiAgICAgICAgcmV0dXJuIFwiXFxyXCI7XG5cbiAgICAgIGNhc2UgXCJjcmxmXCI6XG4gICAgICAgIHJldHVybiBcIlxcclxcblwiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJcXG5cIjtcbiAgICB9XG4gIH1cblxuICB2YXIgZW5kT2ZMaW5lID0ge1xuICAgIGd1ZXNzRW5kT2ZMaW5lLFxuICAgIGNvbnZlcnRFbmRPZkxpbmVUb0NoYXJzXG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGdldFN0cmluZ1dpZHRoOiBnZXRTdHJpbmdXaWR0aCQxXG4gIH0gPSB1dGlsJDE7XG4gIGNvbnN0IHtcbiAgICBjb252ZXJ0RW5kT2ZMaW5lVG9DaGFyczogY29udmVydEVuZE9mTGluZVRvQ2hhcnMkMVxuICB9ID0gZW5kT2ZMaW5lO1xuICBjb25zdCB7XG4gICAgY29uY2F0OiBjb25jYXQkMSxcbiAgICBmaWxsOiBmaWxsJDEsXG4gICAgY3Vyc29yOiBjdXJzb3IkMVxuICB9ID0gZG9jQnVpbGRlcnM7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN5bWJvbCwgdHlwZW9mIE1PREVfQlJFQUsgfCB0eXBlb2YgTU9ERV9GTEFUPn0gKi9cblxuICBsZXQgZ3JvdXBNb2RlTWFwO1xuICBjb25zdCBNT0RFX0JSRUFLID0gMTtcbiAgY29uc3QgTU9ERV9GTEFUID0gMjtcblxuICBmdW5jdGlvbiByb290SW5kZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogXCJcIixcbiAgICAgIGxlbmd0aDogMCxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlSW5kZW50KGluZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZW5lcmF0ZUluZChpbmQsIHtcbiAgICAgIHR5cGU6IFwiaW5kZW50XCJcbiAgICB9LCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VBbGlnbihpbmQsIG4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbiA9PT0gLUluZmluaXR5ID8gaW5kLnJvb3QgfHwgcm9vdEluZGVudCgpIDogbiA8IDAgPyBnZW5lcmF0ZUluZChpbmQsIHtcbiAgICAgIHR5cGU6IFwiZGVkZW50XCJcbiAgICB9LCBvcHRpb25zKSA6ICFuID8gaW5kIDogbi50eXBlID09PSBcInJvb3RcIiA/IE9iamVjdC5hc3NpZ24oe30sIGluZCwge1xuICAgICAgcm9vdDogaW5kXG4gICAgfSkgOiB0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIiA/IGdlbmVyYXRlSW5kKGluZCwge1xuICAgICAgdHlwZTogXCJzdHJpbmdBbGlnblwiLFxuICAgICAgblxuICAgIH0sIG9wdGlvbnMpIDogZ2VuZXJhdGVJbmQoaW5kLCB7XG4gICAgICB0eXBlOiBcIm51bWJlckFsaWduXCIsXG4gICAgICBuXG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUluZChpbmQsIG5ld1BhcnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWV1ZSA9IG5ld1BhcnQudHlwZSA9PT0gXCJkZWRlbnRcIiA/IGluZC5xdWV1ZS5zbGljZSgwLCAtMSkgOiBpbmQucXVldWUuY29uY2F0KG5ld1BhcnQpO1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgbGV0IGxhc3RUYWJzID0gMDtcbiAgICBsZXQgbGFzdFNwYWNlcyA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcXVldWUpIHtcbiAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbmRlbnRcIjpcbiAgICAgICAgICBmbHVzaCgpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudXNlVGFicykge1xuICAgICAgICAgICAgYWRkVGFicygxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkU3BhY2VzKG9wdGlvbnMudGFiV2lkdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJzdHJpbmdBbGlnblwiOlxuICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgdmFsdWUgKz0gcGFydC5uO1xuICAgICAgICAgIGxlbmd0aCArPSBwYXJ0Lm4ubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJudW1iZXJBbGlnblwiOlxuICAgICAgICAgIGxhc3RUYWJzICs9IDE7XG4gICAgICAgICAgbGFzdFNwYWNlcyArPSBwYXJ0Lm47XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdHlwZSAnXCIuY29uY2F0KHBhcnQudHlwZSwgXCInXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmbHVzaFNwYWNlcygpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBpbmQsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgbGVuZ3RoLFxuICAgICAgcXVldWVcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFRhYnMoY291bnQpIHtcbiAgICAgIHZhbHVlICs9IFwiXFx0XCIucmVwZWF0KGNvdW50KTtcbiAgICAgIGxlbmd0aCArPSBvcHRpb25zLnRhYldpZHRoICogY291bnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3BhY2VzKGNvdW50KSB7XG4gICAgICB2YWx1ZSArPSBcIiBcIi5yZXBlYXQoY291bnQpO1xuICAgICAgbGVuZ3RoICs9IGNvdW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgaWYgKG9wdGlvbnMudXNlVGFicykge1xuICAgICAgICBmbHVzaFRhYnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsdXNoU3BhY2VzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2hUYWJzKCkge1xuICAgICAgaWYgKGxhc3RUYWJzID4gMCkge1xuICAgICAgICBhZGRUYWJzKGxhc3RUYWJzKTtcbiAgICAgIH1cblxuICAgICAgcmVzZXRMYXN0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2hTcGFjZXMoKSB7XG4gICAgICBpZiAobGFzdFNwYWNlcyA+IDApIHtcbiAgICAgICAgYWRkU3BhY2VzKGxhc3RTcGFjZXMpO1xuICAgICAgfVxuXG4gICAgICByZXNldExhc3QoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldExhc3QoKSB7XG4gICAgICBsYXN0VGFicyA9IDA7XG4gICAgICBsYXN0U3BhY2VzID0gMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltJDEob3V0KSB7XG4gICAgaWYgKG91dC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGxldCB0cmltQ291bnQgPSAwOyAvLyBUcmltIHdoaXRlc3BhY2UgYXQgdGhlIGVuZCBvZiBsaW5lXG5cbiAgICB3aGlsZSAob3V0Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIG91dFtvdXQubGVuZ3RoIC0gMV0gPT09IFwic3RyaW5nXCIgJiYgb3V0W291dC5sZW5ndGggLSAxXS5tYXRjaCgvXlsgXFx0XSokLykpIHtcbiAgICAgIHRyaW1Db3VudCArPSBvdXQucG9wKCkubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChvdXQubGVuZ3RoICYmIHR5cGVvZiBvdXRbb3V0Lmxlbmd0aCAtIDFdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCB0cmltbWVkID0gb3V0W291dC5sZW5ndGggLSAxXS5yZXBsYWNlKC9bIFxcdF0qJC8sIFwiXCIpO1xuICAgICAgdHJpbUNvdW50ICs9IG91dFtvdXQubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gdHJpbW1lZC5sZW5ndGg7XG4gICAgICBvdXRbb3V0Lmxlbmd0aCAtIDFdID0gdHJpbW1lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJpbUNvdW50O1xuICB9XG5cbiAgZnVuY3Rpb24gZml0cyhuZXh0LCByZXN0Q29tbWFuZHMsIHdpZHRoLCBvcHRpb25zLCBtdXN0QmVGbGF0KSB7XG4gICAgbGV0IHJlc3RJZHggPSByZXN0Q29tbWFuZHMubGVuZ3RoO1xuICAgIGNvbnN0IGNtZHMgPSBbbmV4dF07IC8vIGBvdXRgIGlzIG9ubHkgdXNlZCBmb3Igd2lkdGggY291bnRpbmcgYmVjYXVzZSBgdHJpbWAgcmVxdWlyZXMgdG8gbG9va1xuICAgIC8vIGJhY2t3YXJkcyBmb3Igc3BhY2UgY2hhcmFjdGVycy5cblxuICAgIGNvbnN0IG91dCA9IFtdO1xuXG4gICAgd2hpbGUgKHdpZHRoID49IDApIHtcbiAgICAgIGlmIChjbWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAocmVzdElkeCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY21kcy5wdXNoKHJlc3RDb21tYW5kc1tyZXN0SWR4IC0gMV0pO1xuICAgICAgICByZXN0SWR4LS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbaW5kLCBtb2RlLCBkb2NdID0gY21kcy5wb3AoKTtcblxuICAgICAgaWYgKHR5cGVvZiBkb2MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3V0LnB1c2goZG9jKTtcbiAgICAgICAgd2lkdGggLT0gZ2V0U3RyaW5nV2lkdGgkMShkb2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChkb2MudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJjb25jYXRcIjpcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBkb2MucGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgY21kcy5wdXNoKFtpbmQsIG1vZGUsIGRvYy5wYXJ0c1tpXV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJpbmRlbnRcIjpcbiAgICAgICAgICAgIGNtZHMucHVzaChbbWFrZUluZGVudChpbmQsIG9wdGlvbnMpLCBtb2RlLCBkb2MuY29udGVudHNdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImFsaWduXCI6XG4gICAgICAgICAgICBjbWRzLnB1c2goW21ha2VBbGlnbihpbmQsIGRvYy5uLCBvcHRpb25zKSwgbW9kZSwgZG9jLmNvbnRlbnRzXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJ0cmltXCI6XG4gICAgICAgICAgICB3aWR0aCArPSB0cmltJDEob3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImdyb3VwXCI6XG4gICAgICAgICAgICBpZiAobXVzdEJlRmxhdCAmJiBkb2MuYnJlYWspIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgZG9jLmJyZWFrID8gTU9ERV9CUkVBSyA6IG1vZGUsIGRvYy5jb250ZW50c10pO1xuXG4gICAgICAgICAgICBpZiAoZG9jLmlkKSB7XG4gICAgICAgICAgICAgIGdyb3VwTW9kZU1hcFtkb2MuaWRdID0gY21kc1tjbWRzLmxlbmd0aCAtIDFdWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJmaWxsXCI6XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZG9jLnBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGNtZHMucHVzaChbaW5kLCBtb2RlLCBkb2MucGFydHNbaV1dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaWYtYnJlYWtcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgZ3JvdXBNb2RlID0gZG9jLmdyb3VwSWQgPyBncm91cE1vZGVNYXBbZG9jLmdyb3VwSWRdIDogbW9kZTtcblxuICAgICAgICAgICAgICBpZiAoZ3JvdXBNb2RlID09PSBNT0RFX0JSRUFLKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvYy5icmVha0NvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgbW9kZSwgZG9jLmJyZWFrQ29udGVudHNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZ3JvdXBNb2RlID09PSBNT0RFX0ZMQVQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jLmZsYXRDb250ZW50cykge1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKFtpbmQsIG1vZGUsIGRvYy5mbGF0Q29udGVudHNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgY2FzZSBNT0RFX0ZMQVQ6XG4gICAgICAgICAgICAgICAgaWYgKCFkb2MuaGFyZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFkb2Muc29mdCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChcIiBcIik7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoIC09IDE7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgIGNhc2UgTU9ERV9CUkVBSzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludERvY1RvU3RyaW5nKGRvYywgb3B0aW9ucykge1xuICAgIGdyb3VwTW9kZU1hcCA9IHt9O1xuICAgIGNvbnN0IHdpZHRoID0gb3B0aW9ucy5wcmludFdpZHRoO1xuICAgIGNvbnN0IG5ld0xpbmUgPSBjb252ZXJ0RW5kT2ZMaW5lVG9DaGFycyQxKG9wdGlvbnMuZW5kT2ZMaW5lKTtcbiAgICBsZXQgcG9zID0gMDsgLy8gY21kcyBpcyBiYXNpY2FsbHkgYSBzdGFjay4gV2UndmUgdHVybmVkIGEgcmVjdXJzaXZlIGNhbGwgaW50byBhXG4gICAgLy8gd2hpbGUgbG9vcCB3aGljaCBpcyBtdWNoIGZhc3Rlci4gVGhlIHdoaWxlIGxvb3AgYmVsb3cgYWRkcyBuZXdcbiAgICAvLyBjbWRzIHRvIHRoZSBhcnJheSBpbnN0ZWFkIG9mIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgYHByaW50YC5cblxuICAgIGNvbnN0IGNtZHMgPSBbW3Jvb3RJbmRlbnQoKSwgTU9ERV9CUkVBSywgZG9jXV07XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgbGV0IHNob3VsZFJlbWVhc3VyZSA9IGZhbHNlO1xuICAgIGxldCBsaW5lU3VmZml4ID0gW107XG5cbiAgICB3aGlsZSAoY21kcy5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IFtpbmQsIG1vZGUsIGRvY10gPSBjbWRzLnBvcCgpO1xuXG4gICAgICBpZiAodHlwZW9mIGRvYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBuZXdMaW5lICE9PSBcIlxcblwiICYmIGRvYy5pbmNsdWRlcyhcIlxcblwiKSA/IGRvYy5yZXBsYWNlKC9cXG4vZywgbmV3TGluZSkgOiBkb2M7XG4gICAgICAgIG91dC5wdXNoKGZvcm1hdHRlZCk7XG4gICAgICAgIHBvcyArPSBnZXRTdHJpbmdXaWR0aCQxKGZvcm1hdHRlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGRvYy50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImN1cnNvclwiOlxuICAgICAgICAgICAgb3V0LnB1c2goY3Vyc29yJDEucGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiY29uY2F0XCI6XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZG9jLnBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIGNtZHMucHVzaChbaW5kLCBtb2RlLCBkb2MucGFydHNbaV1dKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiaW5kZW50XCI6XG4gICAgICAgICAgICBjbWRzLnB1c2goW21ha2VJbmRlbnQoaW5kLCBvcHRpb25zKSwgbW9kZSwgZG9jLmNvbnRlbnRzXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJhbGlnblwiOlxuICAgICAgICAgICAgY21kcy5wdXNoKFttYWtlQWxpZ24oaW5kLCBkb2Mubiwgb3B0aW9ucyksIG1vZGUsIGRvYy5jb250ZW50c10pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwidHJpbVwiOlxuICAgICAgICAgICAgcG9zIC09IHRyaW0kMShvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiZ3JvdXBcIjpcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICBjYXNlIE1PREVfRkxBVDpcbiAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJlbWVhc3VyZSkge1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKFtpbmQsIGRvYy5icmVhayA/IE1PREVfQlJFQUsgOiBNT0RFX0ZMQVQsIGRvYy5jb250ZW50c10pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgICAgICAgICAgY2FzZSBNT0RFX0JSRUFLOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHNob3VsZFJlbWVhc3VyZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IFtpbmQsIE1PREVfRkxBVCwgZG9jLmNvbnRlbnRzXTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbSA9IHdpZHRoIC0gcG9zO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWRvYy5icmVhayAmJiBmaXRzKG5leHQsIGNtZHMsIHJlbSwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwYW5kZWQgc3RhdGVzIGFyZSBhIHJhcmUgY2FzZSB3aGVyZSBhIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbiBtYW51YWxseSBwcm92aWRlIG11bHRpcGxlIHJlcHJlc2VudGF0aW9ucyBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBpdHNlbGYuIEl0IHByb3ZpZGVzIGFuIGFycmF5IG9mIGRvY3VtZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBnb2luZyBmcm9tIHRoZSBsZWFzdCBleHBhbmRlZCAobW9zdCBmbGF0dGVuZWQpXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZpcnN0IHRvIHRoZSBtb3N0IGV4cGFuZGVkLiBJZiBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGdyb3VwIGhhcyB0aGVzZSwgd2UgbmVlZCB0byBtYW51YWxseSBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXNlIHN0YXRlcyBhbmQgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgZml0cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvYy5leHBhbmRlZFN0YXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vc3RFeHBhbmRlZCA9IGRvYy5leHBhbmRlZFN0YXRlc1tkb2MuZXhwYW5kZWRTdGF0ZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jLmJyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgTU9ERV9CUkVBSywgbW9zdEV4cGFuZGVkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkb2MuZXhwYW5kZWRTdGF0ZXMubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID49IGRvYy5leHBhbmRlZFN0YXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgTU9ERV9CUkVBSywgbW9zdEV4cGFuZGVkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBkb2MuZXhwYW5kZWRTdGF0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY21kID0gW2luZCwgTU9ERV9GTEFULCBzdGF0ZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml0cyhjbWQsIGNtZHMsIHJlbSwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZHMucHVzaChjbWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNtZHMucHVzaChbaW5kLCBNT0RFX0JSRUFLLCBkb2MuY29udGVudHNdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkb2MuaWQpIHtcbiAgICAgICAgICAgICAgZ3JvdXBNb2RlTWFwW2RvYy5pZF0gPSBjbWRzW2NtZHMubGVuZ3RoIC0gMV1bMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEZpbGxzIGVhY2ggbGluZSB3aXRoIGFzIG11Y2ggY29kZSBhcyBwb3NzaWJsZSBiZWZvcmUgbW92aW5nIHRvIGEgbmV3XG4gICAgICAgICAgLy8gbGluZSB3aXRoIHRoZSBzYW1lIGluZGVudGF0aW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gRXhwZWN0cyBkb2MucGFydHMgdG8gYmUgYW4gYXJyYXkgb2YgYWx0ZXJuYXRpbmcgY29udGVudCBhbmRcbiAgICAgICAgICAvLyB3aGl0ZXNwYWNlLiBUaGUgd2hpdGVzcGFjZSBjb250YWlucyB0aGUgbGluZWJyZWFrcy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEZvciBleGFtcGxlOlxuICAgICAgICAgIC8vICAgW1wiSVwiLCBsaW5lLCBcImxvdmVcIiwgbGluZSwgXCJtb25rZXlzXCJdXG4gICAgICAgICAgLy8gb3JcbiAgICAgICAgICAvLyAgIFt7IHR5cGU6IGdyb3VwLCAuLi4gfSwgc29mdGxpbmUsIHsgdHlwZTogZ3JvdXAsIC4uLiB9XVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSXQgdXNlcyB0aGlzIHBhcnRzIHN0cnVjdHVyZSB0byBoYW5kbGUgdGhyZWUgbWFpbiBsYXlvdXQgY2FzZXM6XG4gICAgICAgICAgLy8gKiBUaGUgZmlyc3QgdHdvIGNvbnRlbnQgaXRlbXMgZml0IG9uIHRoZSBzYW1lIGxpbmUgd2l0aG91dFxuICAgICAgICAgIC8vICAgYnJlYWtpbmdcbiAgICAgICAgICAvLyAgIC0+IG91dHB1dCB0aGUgZmlyc3QgY29udGVudCBpdGVtIGFuZCB0aGUgd2hpdGVzcGFjZSBcImZsYXRcIi5cbiAgICAgICAgICAvLyAqIE9ubHkgdGhlIGZpcnN0IGNvbnRlbnQgaXRlbSBmaXRzIG9uIHRoZSBsaW5lIHdpdGhvdXQgYnJlYWtpbmdcbiAgICAgICAgICAvLyAgIC0+IG91dHB1dCB0aGUgZmlyc3QgY29udGVudCBpdGVtIFwiZmxhdFwiIGFuZCB0aGUgd2hpdGVzcGFjZSB3aXRoXG4gICAgICAgICAgLy8gICBcImJyZWFrXCIuXG4gICAgICAgICAgLy8gKiBOZWl0aGVyIGNvbnRlbnQgaXRlbSBmaXRzIG9uIHRoZSBsaW5lIHdpdGhvdXQgYnJlYWtpbmdcbiAgICAgICAgICAvLyAgIC0+IG91dHB1dCB0aGUgZmlyc3QgY29udGVudCBpdGVtIGFuZCB0aGUgd2hpdGVzcGFjZSB3aXRoIFwiYnJlYWtcIi5cblxuICAgICAgICAgIGNhc2UgXCJmaWxsXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbSA9IHdpZHRoIC0gcG9zO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgcGFydHNcbiAgICAgICAgICAgICAgfSA9IGRvYztcblxuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBbY29udGVudCwgd2hpdGVzcGFjZV0gPSBwYXJ0cztcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudEZsYXRDbWQgPSBbaW5kLCBNT0RFX0ZMQVQsIGNvbnRlbnRdO1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50QnJlYWtDbWQgPSBbaW5kLCBNT0RFX0JSRUFLLCBjb250ZW50XTtcbiAgICAgICAgICAgICAgY29uc3QgY29udGVudEZpdHMgPSBmaXRzKGNvbnRlbnRGbGF0Q21kLCBbXSwgcmVtLCBvcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRGaXRzKSB7XG4gICAgICAgICAgICAgICAgICBjbWRzLnB1c2goY29udGVudEZsYXRDbWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjbWRzLnB1c2goY29udGVudEJyZWFrQ21kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHdoaXRlc3BhY2VGbGF0Q21kID0gW2luZCwgTU9ERV9GTEFULCB3aGl0ZXNwYWNlXTtcbiAgICAgICAgICAgICAgY29uc3Qgd2hpdGVzcGFjZUJyZWFrQ21kID0gW2luZCwgTU9ERV9CUkVBSywgd2hpdGVzcGFjZV07XG5cbiAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Rml0cykge1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKHdoaXRlc3BhY2VGbGF0Q21kKTtcbiAgICAgICAgICAgICAgICAgIGNtZHMucHVzaChjb250ZW50RmxhdENtZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGNtZHMucHVzaCh3aGl0ZXNwYWNlQnJlYWtDbWQpO1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKGNvbnRlbnRCcmVha0NtZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCB3ZSd2ZSBoYW5kbGVkIHRoZSBmaXJzdCBwYWlyIChjb250ZXh0LCBzZXBhcmF0b3IpXG4gICAgICAgICAgICAgIC8vIGFuZCB3aWxsIGNyZWF0ZSBhIG5ldyBmaWxsIGRvYyBmb3IgdGhlIHJlc3Qgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgIC8vIElkZWFsbHkgd2Ugd291bGRuJ3QgbXV0YXRlIHRoZSBhcnJheSBoZXJlIGJ1dCBjb3B5aW5nIGFsbCB0aGVcbiAgICAgICAgICAgICAgLy8gZWxlbWVudHMgdG8gYSBuZXcgYXJyYXkgd291bGQgbWFrZSB0aGlzIGFsZ29yaXRobSBxdWFkcmF0aWMsXG4gICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHVudXNhYmxlIGZvciBsYXJnZSBhcnJheXMgKGUuZy4gbGFyZ2UgdGV4dHMgaW4gSlNYKS5cblxuXG4gICAgICAgICAgICAgIHBhcnRzLnNwbGljZSgwLCAyKTtcbiAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nQ21kID0gW2luZCwgbW9kZSwgZmlsbCQxKHBhcnRzKV07XG4gICAgICAgICAgICAgIGNvbnN0IHNlY29uZENvbnRlbnQgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RBbmRTZWNvbmRDb250ZW50RmxhdENtZCA9IFtpbmQsIE1PREVfRkxBVCwgY29uY2F0JDEoW2NvbnRlbnQsIHdoaXRlc3BhY2UsIHNlY29uZENvbnRlbnRdKV07XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0QW5kU2Vjb25kQ29udGVudEZpdHMgPSBmaXRzKGZpcnN0QW5kU2Vjb25kQ29udGVudEZsYXRDbWQsIFtdLCByZW0sIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgICAgICAgIGlmIChmaXJzdEFuZFNlY29uZENvbnRlbnRGaXRzKSB7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKHJlbWFpbmluZ0NtZCk7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKHdoaXRlc3BhY2VGbGF0Q21kKTtcbiAgICAgICAgICAgICAgICBjbWRzLnB1c2goY29udGVudEZsYXRDbWQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRGaXRzKSB7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKHJlbWFpbmluZ0NtZCk7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKHdoaXRlc3BhY2VCcmVha0NtZCk7XG4gICAgICAgICAgICAgICAgY21kcy5wdXNoKGNvbnRlbnRGbGF0Q21kKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbWRzLnB1c2gocmVtYWluaW5nQ21kKTtcbiAgICAgICAgICAgICAgICBjbWRzLnB1c2god2hpdGVzcGFjZUJyZWFrQ21kKTtcbiAgICAgICAgICAgICAgICBjbWRzLnB1c2goY29udGVudEJyZWFrQ21kKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBcImlmLWJyZWFrXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGdyb3VwTW9kZSA9IGRvYy5ncm91cElkID8gZ3JvdXBNb2RlTWFwW2RvYy5ncm91cElkXSA6IG1vZGU7XG5cbiAgICAgICAgICAgICAgaWYgKGdyb3VwTW9kZSA9PT0gTU9ERV9CUkVBSykge1xuICAgICAgICAgICAgICAgIGlmIChkb2MuYnJlYWtDb250ZW50cykge1xuICAgICAgICAgICAgICAgICAgY21kcy5wdXNoKFtpbmQsIG1vZGUsIGRvYy5icmVha0NvbnRlbnRzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGdyb3VwTW9kZSA9PT0gTU9ERV9GTEFUKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvYy5mbGF0Q29udGVudHMpIHtcbiAgICAgICAgICAgICAgICAgIGNtZHMucHVzaChbaW5kLCBtb2RlLCBkb2MuZmxhdENvbnRlbnRzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFwibGluZS1zdWZmaXhcIjpcbiAgICAgICAgICAgIGxpbmVTdWZmaXgucHVzaChbaW5kLCBtb2RlLCBkb2MuY29udGVudHNdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImxpbmUtc3VmZml4LWJvdW5kYXJ5XCI6XG4gICAgICAgICAgICBpZiAobGluZVN1ZmZpeC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNtZHMucHVzaChbaW5kLCBtb2RlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgICAgICAgaGFyZDogdHJ1ZVxuICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICBjYXNlIE1PREVfRkxBVDpcbiAgICAgICAgICAgICAgICBpZiAoIWRvYy5oYXJkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWRvYy5zb2Z0KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFwiIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGxpbmUgd2FzIGZvcmNlZCBpbnRvIHRoZSBvdXRwdXQgZXZlbiBpZiB3ZVxuICAgICAgICAgICAgICAgICAgLy8gd2VyZSBpbiBmbGF0dGVuZWQgbW9kZSwgc28gd2UgbmVlZCB0byB0ZWxsIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAvLyBncm91cCB0aGF0IG5vIG1hdHRlciB3aGF0LCBpdCBuZWVkcyB0byByZW1lYXN1cmVcbiAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIHByZXZpb3VzIG1lYXN1cmVtZW50IGRpZG4ndCBhY2N1cmF0ZWx5XG4gICAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIHRoZSBlbnRpcmUgZXhwcmVzc2lvbiAodGhpcyBpcyBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgIC8vIGZvciBuZXN0ZWQgZ3JvdXBzKVxuICAgICAgICAgICAgICAgICAgc2hvdWxkUmVtZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgICAgICAgICBjYXNlIE1PREVfQlJFQUs6XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVTdWZmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjbWRzLnB1c2goW2luZCwgbW9kZSwgZG9jXSk7XG4gICAgICAgICAgICAgICAgICBjbWRzLnB1c2goLi4ubGluZVN1ZmZpeC5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgICAgICAgbGluZVN1ZmZpeCA9IFtdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRvYy5saXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5kLnJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2gobmV3TGluZSwgaW5kLnJvb3QudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBpbmQucm9vdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChuZXdMaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9zIC09IHRyaW0kMShvdXQpO1xuICAgICAgICAgICAgICAgICAgb3V0LnB1c2gobmV3TGluZSArIGluZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBwb3MgPSBpbmQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGN1cnNvclBsYWNlaG9sZGVySW5kZXggPSBvdXQuaW5kZXhPZihjdXJzb3IkMS5wbGFjZWhvbGRlcik7XG5cbiAgICBpZiAoY3Vyc29yUGxhY2Vob2xkZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IG90aGVyQ3Vyc29yUGxhY2Vob2xkZXJJbmRleCA9IG91dC5pbmRleE9mKGN1cnNvciQxLnBsYWNlaG9sZGVyLCBjdXJzb3JQbGFjZWhvbGRlckluZGV4ICsgMSk7XG4gICAgICBjb25zdCBiZWZvcmVDdXJzb3IgPSBvdXQuc2xpY2UoMCwgY3Vyc29yUGxhY2Vob2xkZXJJbmRleCkuam9pbihcIlwiKTtcbiAgICAgIGNvbnN0IGFyb3VuZEN1cnNvciA9IG91dC5zbGljZShjdXJzb3JQbGFjZWhvbGRlckluZGV4ICsgMSwgb3RoZXJDdXJzb3JQbGFjZWhvbGRlckluZGV4KS5qb2luKFwiXCIpO1xuICAgICAgY29uc3QgYWZ0ZXJDdXJzb3IgPSBvdXQuc2xpY2Uob3RoZXJDdXJzb3JQbGFjZWhvbGRlckluZGV4ICsgMSkuam9pbihcIlwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdHRlZDogYmVmb3JlQ3Vyc29yICsgYXJvdW5kQ3Vyc29yICsgYWZ0ZXJDdXJzb3IsXG4gICAgICAgIGN1cnNvck5vZGVTdGFydDogYmVmb3JlQ3Vyc29yLmxlbmd0aCxcbiAgICAgICAgY3Vyc29yTm9kZVRleHQ6IGFyb3VuZEN1cnNvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0dGVkOiBvdXQuam9pbihcIlwiKVxuICAgIH07XG4gIH1cblxuICB2YXIgZG9jUHJpbnRlciA9IHtcbiAgICBwcmludERvY1RvU3RyaW5nXG4gIH07XG5cbiAgY29uc3QgdHJhdmVyc2VEb2NPbkV4aXRTdGFja01hcmtlciA9IHt9O1xuXG4gIGZ1bmN0aW9uIHRyYXZlcnNlRG9jKGRvYywgb25FbnRlciwgb25FeGl0LCBzaG91bGRUcmF2ZXJzZUNvbmRpdGlvbmFsR3JvdXBzKSB7XG4gICAgY29uc3QgZG9jc1N0YWNrID0gW2RvY107XG5cbiAgICB3aGlsZSAoZG9jc1N0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgZG9jID0gZG9jc1N0YWNrLnBvcCgpO1xuXG4gICAgICBpZiAoZG9jID09PSB0cmF2ZXJzZURvY09uRXhpdFN0YWNrTWFya2VyKSB7XG4gICAgICAgIG9uRXhpdChkb2NzU3RhY2sucG9wKCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHNob3VsZFJlY3Vyc2UgPSB0cnVlO1xuXG4gICAgICBpZiAob25FbnRlcikge1xuICAgICAgICBpZiAob25FbnRlcihkb2MpID09PSBmYWxzZSkge1xuICAgICAgICAgIHNob3VsZFJlY3Vyc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob25FeGl0KSB7XG4gICAgICAgIGRvY3NTdGFjay5wdXNoKGRvYyk7XG4gICAgICAgIGRvY3NTdGFjay5wdXNoKHRyYXZlcnNlRG9jT25FeGl0U3RhY2tNYXJrZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUmVjdXJzZSkge1xuICAgICAgICAvLyBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXJ0cyB0byBwcm9jZXNzLFxuICAgICAgICAvLyB0aGUgcGFydHMgbmVlZCB0byBiZSBwdXNoZWQgb250byB0aGUgc3RhY2sgaW4gcmV2ZXJzZSBvcmRlcixcbiAgICAgICAgLy8gc28gdGhhdCB0aGV5IGFyZSBwcm9jZXNzZWQgaW4gdGhlIG9yaWdpbmFsIG9yZGVyXG4gICAgICAgIC8vIHdoZW4gdGhlIHN0YWNrIGlzIHBvcHBlZC5cbiAgICAgICAgaWYgKGRvYy50eXBlID09PSBcImNvbmNhdFwiIHx8IGRvYy50eXBlID09PSBcImZpbGxcIikge1xuICAgICAgICAgIGZvciAobGV0IGljID0gZG9jLnBhcnRzLmxlbmd0aCwgaSA9IGljIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGRvY3NTdGFjay5wdXNoKGRvYy5wYXJ0c1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRvYy50eXBlID09PSBcImlmLWJyZWFrXCIpIHtcbiAgICAgICAgICBpZiAoZG9jLmZsYXRDb250ZW50cykge1xuICAgICAgICAgICAgZG9jc1N0YWNrLnB1c2goZG9jLmZsYXRDb250ZW50cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRvYy5icmVha0NvbnRlbnRzKSB7XG4gICAgICAgICAgICBkb2NzU3RhY2sucHVzaChkb2MuYnJlYWtDb250ZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRvYy50eXBlID09PSBcImdyb3VwXCIgJiYgZG9jLmV4cGFuZGVkU3RhdGVzKSB7XG4gICAgICAgICAgaWYgKHNob3VsZFRyYXZlcnNlQ29uZGl0aW9uYWxHcm91cHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGljID0gZG9jLmV4cGFuZGVkU3RhdGVzLmxlbmd0aCwgaSA9IGljIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgZG9jc1N0YWNrLnB1c2goZG9jLmV4cGFuZGVkU3RhdGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jc1N0YWNrLnB1c2goZG9jLmNvbnRlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jLmNvbnRlbnRzKSB7XG4gICAgICAgICAgZG9jc1N0YWNrLnB1c2goZG9jLmNvbnRlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcERvYyhkb2MsIGNiKSB7XG4gICAgaWYgKGRvYy50eXBlID09PSBcImNvbmNhdFwiIHx8IGRvYy50eXBlID09PSBcImZpbGxcIikge1xuICAgICAgY29uc3QgcGFydHMgPSBkb2MucGFydHMubWFwKHBhcnQgPT4gbWFwRG9jKHBhcnQsIGNiKSk7XG4gICAgICByZXR1cm4gY2IoT2JqZWN0LmFzc2lnbih7fSwgZG9jLCB7XG4gICAgICAgIHBhcnRzXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIGlmIChkb2MudHlwZSA9PT0gXCJpZi1icmVha1wiKSB7XG4gICAgICBjb25zdCBicmVha0NvbnRlbnRzID0gZG9jLmJyZWFrQ29udGVudHMgJiYgbWFwRG9jKGRvYy5icmVha0NvbnRlbnRzLCBjYik7XG4gICAgICBjb25zdCBmbGF0Q29udGVudHMgPSBkb2MuZmxhdENvbnRlbnRzICYmIG1hcERvYyhkb2MuZmxhdENvbnRlbnRzLCBjYik7XG4gICAgICByZXR1cm4gY2IoT2JqZWN0LmFzc2lnbih7fSwgZG9jLCB7XG4gICAgICAgIGJyZWFrQ29udGVudHMsXG4gICAgICAgIGZsYXRDb250ZW50c1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSBpZiAoZG9jLmNvbnRlbnRzKSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IG1hcERvYyhkb2MuY29udGVudHMsIGNiKTtcbiAgICAgIHJldHVybiBjYihPYmplY3QuYXNzaWduKHt9LCBkb2MsIHtcbiAgICAgICAgY29udGVudHNcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2IoZG9jKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJbkRvYyhkb2MsIGZuLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gZGVmYXVsdFZhbHVlO1xuICAgIGxldCBoYXNTdG9wcGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBmaW5kSW5Eb2NPbkVudGVyRm4oZG9jKSB7XG4gICAgICBjb25zdCBtYXliZVJlc3VsdCA9IGZuKGRvYyk7XG5cbiAgICAgIGlmIChtYXliZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGhhc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICByZXN1bHQgPSBtYXliZVJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1N0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyYXZlcnNlRG9jKGRvYywgZmluZEluRG9jT25FbnRlckZuKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFbXB0eShuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSBcInN0cmluZ1wiICYmIG4ubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5lTmV4dEZuKGRvYykge1xuICAgIGlmICh0eXBlb2YgZG9jID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGRvYy50eXBlID09PSBcImxpbmVcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNMaW5lTmV4dChkb2MpIHtcbiAgICByZXR1cm4gZmluZEluRG9jKGRvYywgaXNMaW5lTmV4dEZuLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiB3aWxsQnJlYWtGbihkb2MpIHtcbiAgICBpZiAoZG9jLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBkb2MuYnJlYWspIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJsaW5lXCIgJiYgZG9jLmhhcmQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJicmVhay1wYXJlbnRcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd2lsbEJyZWFrKGRvYykge1xuICAgIHJldHVybiBmaW5kSW5Eb2MoZG9jLCB3aWxsQnJlYWtGbiwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYnJlYWtQYXJlbnRHcm91cChncm91cFN0YWNrKSB7XG4gICAgaWYgKGdyb3VwU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcGFyZW50R3JvdXAgPSBncm91cFN0YWNrW2dyb3VwU3RhY2subGVuZ3RoIC0gMV07IC8vIEJyZWFrcyBhcmUgbm90IHByb3BhZ2F0ZWQgdGhyb3VnaCBjb25kaXRpb25hbCBncm91cHMgYmVjYXVzZVxuICAgICAgLy8gdGhlIHVzZXIgaXMgZXhwZWN0ZWQgdG8gbWFudWFsbHkgaGFuZGxlIHdoYXQgYnJlYWtzLlxuXG4gICAgICBpZiAoIXBhcmVudEdyb3VwLmV4cGFuZGVkU3RhdGVzKSB7XG4gICAgICAgIHBhcmVudEdyb3VwLmJyZWFrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3BhZ2F0ZUJyZWFrcyhkb2MpIHtcbiAgICBjb25zdCBhbHJlYWR5VmlzaXRlZFNldCA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBncm91cFN0YWNrID0gW107XG5cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVCcmVha3NPbkVudGVyRm4oZG9jKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwiYnJlYWstcGFyZW50XCIpIHtcbiAgICAgICAgYnJlYWtQYXJlbnRHcm91cChncm91cFN0YWNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRvYy50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgZ3JvdXBTdGFjay5wdXNoKGRvYyk7XG5cbiAgICAgICAgaWYgKGFscmVhZHlWaXNpdGVkU2V0Lmhhcyhkb2MpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYWxyZWFkeVZpc2l0ZWRTZXQuYWRkKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlQnJlYWtzT25FeGl0Rm4oZG9jKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICBjb25zdCBncm91cCA9IGdyb3VwU3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKGdyb3VwLmJyZWFrKSB7XG4gICAgICAgICAgYnJlYWtQYXJlbnRHcm91cChncm91cFN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRyYXZlcnNlRG9jKGRvYywgcHJvcGFnYXRlQnJlYWtzT25FbnRlckZuLCBwcm9wYWdhdGVCcmVha3NPbkV4aXRGbixcbiAgICAvKiBzaG91bGRUcmF2ZXJzZUNvbmRpdGlvbmFsR3JvdXBzICovXG4gICAgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaW5lc0ZuKGRvYykge1xuICAgIC8vIEZvcmNlIHRoaXMgZG9jIGludG8gZmxhdCBtb2RlIGJ5IHN0YXRpY2FsbHkgY29udmVydGluZyBhbGxcbiAgICAvLyBsaW5lcyBpbnRvIHNwYWNlcyAob3Igc29mdCBsaW5lcyBpbnRvIG5vdGhpbmcpLiBIYXJkIGxpbmVzXG4gICAgLy8gc2hvdWxkIHN0aWxsIG91dHB1dCBiZWNhdXNlIHRoZXJlJ3MgdG9vIGdyZWF0IG9mIGEgY2hhbmNlXG4gICAgLy8gb2YgYnJlYWtpbmcgZXhpc3RpbmcgYXNzdW1wdGlvbnMgb3RoZXJ3aXNlLlxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJsaW5lXCIgJiYgIWRvYy5oYXJkKSB7XG4gICAgICByZXR1cm4gZG9jLnNvZnQgPyBcIlwiIDogXCIgXCI7XG4gICAgfSBlbHNlIGlmIChkb2MudHlwZSA9PT0gXCJpZi1icmVha1wiKSB7XG4gICAgICByZXR1cm4gZG9jLmZsYXRDb250ZW50cyB8fCBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBkb2M7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaW5lcyhkb2MpIHtcbiAgICByZXR1cm4gbWFwRG9jKGRvYywgcmVtb3ZlTGluZXNGbik7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nSGFyZGxpbmUoZG9jKSB7XG4gICAgLy8gSEFDSyByZW1vdmUgZW5kaW5nIGhhcmRsaW5lLCBvcmlnaW5hbCBQUjogIzE5ODRcbiAgICBpZiAoZG9jLnR5cGUgPT09IFwiY29uY2F0XCIgJiYgZG9jLnBhcnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgbGFzdFBhcnQgPSBkb2MucGFydHNbZG9jLnBhcnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAobGFzdFBhcnQudHlwZSA9PT0gXCJjb25jYXRcIikge1xuICAgICAgICBpZiAobGFzdFBhcnQucGFydHMubGVuZ3RoID09PSAyICYmIGxhc3RQYXJ0LnBhcnRzWzBdLmhhcmQgJiYgbGFzdFBhcnQucGFydHNbMV0udHlwZSA9PT0gXCJicmVhay1wYXJlbnRcIikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImNvbmNhdFwiLFxuICAgICAgICAgICAgcGFydHM6IGRvYy5wYXJ0cy5zbGljZSgwLCAtMSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImNvbmNhdFwiLFxuICAgICAgICAgIHBhcnRzOiBkb2MucGFydHMuc2xpY2UoMCwgLTEpLmNvbmNhdChzdHJpcFRyYWlsaW5nSGFyZGxpbmUobGFzdFBhcnQpKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkb2M7XG4gIH1cblxuICB2YXIgZG9jVXRpbHMgPSB7XG4gICAgaXNFbXB0eSxcbiAgICB3aWxsQnJlYWssXG4gICAgaXNMaW5lTmV4dCxcbiAgICB0cmF2ZXJzZURvYyxcbiAgICBmaW5kSW5Eb2MsXG4gICAgbWFwRG9jLFxuICAgIHByb3BhZ2F0ZUJyZWFrcyxcbiAgICByZW1vdmVMaW5lcyxcbiAgICBzdHJpcFRyYWlsaW5nSGFyZGxpbmVcbiAgfTtcblxuICBmdW5jdGlvbiBmbGF0dGVuRG9jKGRvYykge1xuICAgIGlmIChkb2MudHlwZSA9PT0gXCJjb25jYXRcIikge1xuICAgICAgY29uc3QgcmVzID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jLnBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGRvYzIgPSBkb2MucGFydHNbaV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkb2MyICE9PSBcInN0cmluZ1wiICYmIGRvYzIudHlwZSA9PT0gXCJjb25jYXRcIikge1xuICAgICAgICAgIHJlcy5wdXNoKC4uLmZsYXR0ZW5Eb2MoZG9jMikucGFydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZsYXR0ZW5lZCA9IGZsYXR0ZW5Eb2MoZG9jMik7XG5cbiAgICAgICAgICBpZiAoZmxhdHRlbmVkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbGF0dGVuZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZG9jLCB7XG4gICAgICAgIHBhcnRzOiByZXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZG9jLnR5cGUgPT09IFwiaWYtYnJlYWtcIikge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRvYywge1xuICAgICAgICBicmVha0NvbnRlbnRzOiBkb2MuYnJlYWtDb250ZW50cyAhPSBudWxsID8gZmxhdHRlbkRvYyhkb2MuYnJlYWtDb250ZW50cykgOiBudWxsLFxuICAgICAgICBmbGF0Q29udGVudHM6IGRvYy5mbGF0Q29udGVudHMgIT0gbnVsbCA/IGZsYXR0ZW5Eb2MoZG9jLmZsYXRDb250ZW50cykgOiBudWxsXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRvYy50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkb2MsIHtcbiAgICAgICAgY29udGVudHM6IGZsYXR0ZW5Eb2MoZG9jLmNvbnRlbnRzKSxcbiAgICAgICAgZXhwYW5kZWRTdGF0ZXM6IGRvYy5leHBhbmRlZFN0YXRlcyA/IGRvYy5leHBhbmRlZFN0YXRlcy5tYXAoZmxhdHRlbkRvYykgOiBkb2MuZXhwYW5kZWRTdGF0ZXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZG9jLmNvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZG9jLCB7XG4gICAgICAgIGNvbnRlbnRzOiBmbGF0dGVuRG9jKGRvYy5jb250ZW50cylcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBkb2M7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludERvYyhkb2MpIHtcbiAgICBpZiAodHlwZW9mIGRvYyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRvYyk7XG4gICAgfVxuXG4gICAgaWYgKGRvYy50eXBlID09PSBcImxpbmVcIikge1xuICAgICAgaWYgKGRvYy5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBcImxpdGVyYWxsaW5lXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb2MuaGFyZCkge1xuICAgICAgICByZXR1cm4gXCJoYXJkbGluZVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoZG9jLnNvZnQpIHtcbiAgICAgICAgcmV0dXJuIFwic29mdGxpbmVcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwibGluZVwiO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJicmVhay1wYXJlbnRcIikge1xuICAgICAgcmV0dXJuIFwiYnJlYWtQYXJlbnRcIjtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnR5cGUgPT09IFwidHJpbVwiKSB7XG4gICAgICByZXR1cm4gXCJ0cmltXCI7XG4gICAgfVxuXG4gICAgaWYgKGRvYy50eXBlID09PSBcImNvbmNhdFwiKSB7XG4gICAgICByZXR1cm4gXCJbXCIgKyBkb2MucGFydHMubWFwKHByaW50RG9jKS5qb2luKFwiLCBcIikgKyBcIl1cIjtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnR5cGUgPT09IFwiaW5kZW50XCIpIHtcbiAgICAgIHJldHVybiBcImluZGVudChcIiArIHByaW50RG9jKGRvYy5jb250ZW50cykgKyBcIilcIjtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnR5cGUgPT09IFwiYWxpZ25cIikge1xuICAgICAgcmV0dXJuIGRvYy5uID09PSAtSW5maW5pdHkgPyBcImRlZGVudFRvUm9vdChcIiArIHByaW50RG9jKGRvYy5jb250ZW50cykgKyBcIilcIiA6IGRvYy5uIDwgMCA/IFwiZGVkZW50KFwiICsgcHJpbnREb2MoZG9jLmNvbnRlbnRzKSArIFwiKVwiIDogZG9jLm4udHlwZSA9PT0gXCJyb290XCIgPyBcIm1hcmtBc1Jvb3QoXCIgKyBwcmludERvYyhkb2MuY29udGVudHMpICsgXCIpXCIgOiBcImFsaWduKFwiICsgSlNPTi5zdHJpbmdpZnkoZG9jLm4pICsgXCIsIFwiICsgcHJpbnREb2MoZG9jLmNvbnRlbnRzKSArIFwiKVwiO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJpZi1icmVha1wiKSB7XG4gICAgICByZXR1cm4gXCJpZkJyZWFrKFwiICsgcHJpbnREb2MoZG9jLmJyZWFrQ29udGVudHMpICsgKGRvYy5mbGF0Q29udGVudHMgPyBcIiwgXCIgKyBwcmludERvYyhkb2MuZmxhdENvbnRlbnRzKSA6IFwiXCIpICsgXCIpXCI7XG4gICAgfVxuXG4gICAgaWYgKGRvYy50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgIGlmIChkb2MuZXhwYW5kZWRTdGF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIFwiY29uZGl0aW9uYWxHcm91cChcIiArIFwiW1wiICsgZG9jLmV4cGFuZGVkU3RhdGVzLm1hcChwcmludERvYykuam9pbihcIixcIikgKyBcIl0pXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoZG9jLmJyZWFrID8gXCJ3cmFwcGVkR3JvdXBcIiA6IFwiZ3JvdXBcIikgKyBcIihcIiArIHByaW50RG9jKGRvYy5jb250ZW50cykgKyBcIilcIjtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnR5cGUgPT09IFwiZmlsbFwiKSB7XG4gICAgICByZXR1cm4gXCJmaWxsXCIgKyBcIihcIiArIGRvYy5wYXJ0cy5tYXAocHJpbnREb2MpLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJsaW5lLXN1ZmZpeFwiKSB7XG4gICAgICByZXR1cm4gXCJsaW5lU3VmZml4KFwiICsgcHJpbnREb2MoZG9jLmNvbnRlbnRzKSArIFwiKVwiO1xuICAgIH1cblxuICAgIGlmIChkb2MudHlwZSA9PT0gXCJsaW5lLXN1ZmZpeC1ib3VuZGFyeVwiKSB7XG4gICAgICByZXR1cm4gXCJsaW5lU3VmZml4Qm91bmRhcnlcIjtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRvYyB0eXBlIFwiICsgZG9jLnR5cGUpO1xuICB9XG5cbiAgdmFyIGRvY0RlYnVnID0ge1xuICAgIHByaW50RG9jVG9EZWJ1Zyhkb2MpIHtcbiAgICAgIHJldHVybiBwcmludERvYyhmbGF0dGVuRG9jKGRvYykpO1xuICAgIH1cblxuICB9O1xuXG4gIHZhciBkb2N1bWVudCA9IHtcbiAgICBidWlsZGVyczogZG9jQnVpbGRlcnMsXG4gICAgcHJpbnRlcjogZG9jUHJpbnRlcixcbiAgICB1dGlsczogZG9jVXRpbHMsXG4gICAgZGVidWc6IGRvY0RlYnVnXG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGdldE1heENvbnRpbnVvdXNDb3VudDogZ2V0TWF4Q29udGludW91c0NvdW50JDEsXG4gICAgZ2V0U3RyaW5nV2lkdGg6IGdldFN0cmluZ1dpZHRoJDIsXG4gICAgZ2V0QWxpZ25tZW50U2l6ZTogZ2V0QWxpZ25tZW50U2l6ZSQxLFxuICAgIGdldEluZGVudFNpemU6IGdldEluZGVudFNpemUkMSxcbiAgICBza2lwOiBza2lwJDEsXG4gICAgc2tpcFdoaXRlc3BhY2U6IHNraXBXaGl0ZXNwYWNlJDEsXG4gICAgc2tpcFNwYWNlczogc2tpcFNwYWNlcyQxLFxuICAgIHNraXBOZXdsaW5lOiBza2lwTmV3bGluZSQxLFxuICAgIHNraXBUb0xpbmVFbmQ6IHNraXBUb0xpbmVFbmQkMSxcbiAgICBza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6IHNraXBFdmVyeXRoaW5nQnV0TmV3TGluZSQxLFxuICAgIHNraXBJbmxpbmVDb21tZW50OiBza2lwSW5saW5lQ29tbWVudCQxLFxuICAgIHNraXBUcmFpbGluZ0NvbW1lbnQ6IHNraXBUcmFpbGluZ0NvbW1lbnQkMSxcbiAgICBoYXNOZXdsaW5lOiBoYXNOZXdsaW5lJDEsXG4gICAgaGFzTmV3bGluZUluUmFuZ2U6IGhhc05ld2xpbmVJblJhbmdlJDEsXG4gICAgaGFzU3BhY2VzOiBoYXNTcGFjZXMkMSxcbiAgICBpc05leHRMaW5lRW1wdHk6IGlzTmV4dExpbmVFbXB0eSQxLFxuICAgIGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXg6IGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXgkMSxcbiAgICBpc1ByZXZpb3VzTGluZUVtcHR5OiBpc1ByZXZpb3VzTGluZUVtcHR5JDEsXG4gICAgZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4OiBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgkMSxcbiAgICBtYWtlU3RyaW5nOiBtYWtlU3RyaW5nJDEsXG4gICAgYWRkTGVhZGluZ0NvbW1lbnQ6IGFkZExlYWRpbmdDb21tZW50JDEsXG4gICAgYWRkRGFuZ2xpbmdDb21tZW50OiBhZGREYW5nbGluZ0NvbW1lbnQkMSxcbiAgICBhZGRUcmFpbGluZ0NvbW1lbnQ6IGFkZFRyYWlsaW5nQ29tbWVudCQxXG4gIH0gPSB1dGlsJDE7XG4gIHZhciB1dGlsU2hhcmVkID0ge1xuICAgIGdldE1heENvbnRpbnVvdXNDb3VudDogZ2V0TWF4Q29udGludW91c0NvdW50JDEsXG4gICAgZ2V0U3RyaW5nV2lkdGg6IGdldFN0cmluZ1dpZHRoJDIsXG4gICAgZ2V0QWxpZ25tZW50U2l6ZTogZ2V0QWxpZ25tZW50U2l6ZSQxLFxuICAgIGdldEluZGVudFNpemU6IGdldEluZGVudFNpemUkMSxcbiAgICBza2lwOiBza2lwJDEsXG4gICAgc2tpcFdoaXRlc3BhY2U6IHNraXBXaGl0ZXNwYWNlJDEsXG4gICAgc2tpcFNwYWNlczogc2tpcFNwYWNlcyQxLFxuICAgIHNraXBOZXdsaW5lOiBza2lwTmV3bGluZSQxLFxuICAgIHNraXBUb0xpbmVFbmQ6IHNraXBUb0xpbmVFbmQkMSxcbiAgICBza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6IHNraXBFdmVyeXRoaW5nQnV0TmV3TGluZSQxLFxuICAgIHNraXBJbmxpbmVDb21tZW50OiBza2lwSW5saW5lQ29tbWVudCQxLFxuICAgIHNraXBUcmFpbGluZ0NvbW1lbnQ6IHNraXBUcmFpbGluZ0NvbW1lbnQkMSxcbiAgICBoYXNOZXdsaW5lOiBoYXNOZXdsaW5lJDEsXG4gICAgaGFzTmV3bGluZUluUmFuZ2U6IGhhc05ld2xpbmVJblJhbmdlJDEsXG4gICAgaGFzU3BhY2VzOiBoYXNTcGFjZXMkMSxcbiAgICBpc05leHRMaW5lRW1wdHk6IGlzTmV4dExpbmVFbXB0eSQxLFxuICAgIGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXg6IGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXgkMSxcbiAgICBpc1ByZXZpb3VzTGluZUVtcHR5OiBpc1ByZXZpb3VzTGluZUVtcHR5JDEsXG4gICAgZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4OiBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgkMSxcbiAgICBtYWtlU3RyaW5nOiBtYWtlU3RyaW5nJDEsXG4gICAgYWRkTGVhZGluZ0NvbW1lbnQ6IGFkZExlYWRpbmdDb21tZW50JDEsXG4gICAgYWRkRGFuZ2xpbmdDb21tZW50OiBhZGREYW5nbGluZ0NvbW1lbnQkMSxcbiAgICBhZGRUcmFpbGluZ0NvbW1lbnQ6IGFkZFRyYWlsaW5nQ29tbWVudCQxXG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGNvbmNhdDogY29uY2F0JDIsXG4gICAgbGluZTogbGluZSQxLFxuICAgIGhhcmRsaW5lOiBoYXJkbGluZSQxLFxuICAgIGJyZWFrUGFyZW50OiBicmVha1BhcmVudCQxLFxuICAgIGluZGVudDogaW5kZW50JDEsXG4gICAgbGluZVN1ZmZpeDogbGluZVN1ZmZpeCQxLFxuICAgIGpvaW46IGpvaW4kMSxcbiAgICBjdXJzb3I6IGN1cnNvciQyXG4gIH0gPSBkb2N1bWVudC5idWlsZGVycztcbiAgY29uc3Qge1xuICAgIGhhc05ld2xpbmU6IGhhc05ld2xpbmUkMixcbiAgICBza2lwTmV3bGluZTogc2tpcE5ld2xpbmUkMixcbiAgICBpc1ByZXZpb3VzTGluZUVtcHR5OiBpc1ByZXZpb3VzTGluZUVtcHR5JDJcbiAgfSA9IHV0aWwkMTtcbiAgY29uc3Qge1xuICAgIGFkZExlYWRpbmdDb21tZW50OiBhZGRMZWFkaW5nQ29tbWVudCQyLFxuICAgIGFkZERhbmdsaW5nQ29tbWVudDogYWRkRGFuZ2xpbmdDb21tZW50JDIsXG4gICAgYWRkVHJhaWxpbmdDb21tZW50OiBhZGRUcmFpbGluZ0NvbW1lbnQkMlxuICB9ID0gdXRpbFNoYXJlZDtcbiAgY29uc3QgY2hpbGROb2Rlc0NhY2hlS2V5ID0gU3ltYm9sKFwiY2hpbGQtbm9kZXNcIik7XG5cbiAgZnVuY3Rpb24gZ2V0U29ydGVkQ2hpbGROb2Rlcyhub2RlLCBvcHRpb25zLCByZXN1bHRBcnJheSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHByaW50ZXIsXG4gICAgICBsb2NTdGFydCxcbiAgICAgIGxvY0VuZFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKHJlc3VsdEFycmF5KSB7XG4gICAgICBpZiAocHJpbnRlci5jYW5BdHRhY2hDb21tZW50ICYmIHByaW50ZXIuY2FuQXR0YWNoQ29tbWVudChub2RlKSkge1xuICAgICAgICAvLyBUaGlzIHJldmVyc2UgaW5zZXJ0aW9uIHNvcnQgYWxtb3N0IGFsd2F5cyB0YWtlcyBjb25zdGFudFxuICAgICAgICAvLyB0aW1lIGJlY2F1c2Ugd2UgYWxtb3N0IGFsd2F5cyAobWF5YmUgYWx3YXlzPykgYXBwZW5kIHRoZVxuICAgICAgICAvLyBub2RlcyBpbiBvcmRlciBhbnl3YXkuXG4gICAgICAgIGxldCBpO1xuXG4gICAgICAgIGZvciAoaSA9IHJlc3VsdEFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgaWYgKGxvY1N0YXJ0KHJlc3VsdEFycmF5W2ldKSA8PSBsb2NTdGFydChub2RlKSAmJiBsb2NFbmQocmVzdWx0QXJyYXlbaV0pIDw9IGxvY0VuZChub2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0QXJyYXkuc3BsaWNlKGkgKyAxLCAwLCBub2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZVtjaGlsZE5vZGVzQ2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gbm9kZVtjaGlsZE5vZGVzQ2FjaGVLZXldO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBwcmludGVyLmdldENvbW1lbnRDaGlsZE5vZGVzICYmIHByaW50ZXIuZ2V0Q29tbWVudENoaWxkTm9kZXMobm9kZSwgb3B0aW9ucykgfHwgdHlwZW9mIG5vZGUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMobm9kZSkuZmlsdGVyKG4gPT4gbiAhPT0gXCJlbmNsb3NpbmdOb2RlXCIgJiYgbiAhPT0gXCJwcmVjZWRpbmdOb2RlXCIgJiYgbiAhPT0gXCJmb2xsb3dpbmdOb2RlXCIpLm1hcChuID0+IG5vZGVbbl0pO1xuXG4gICAgaWYgKCFjaGlsZE5vZGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bHRBcnJheSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIGNoaWxkTm9kZXNDYWNoZUtleSwge1xuICAgICAgICB2YWx1ZTogcmVzdWx0QXJyYXkgPSBbXSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZE5vZGUgPT4ge1xuICAgICAgZ2V0U29ydGVkQ2hpbGROb2RlcyhjaGlsZE5vZGUsIG9wdGlvbnMsIHJlc3VsdEFycmF5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0QXJyYXk7XG4gIH0gLy8gQXMgZWZmaWNpZW50bHkgYXMgcG9zc2libGUsIGRlY29yYXRlIHRoZSBjb21tZW50IG9iamVjdCB3aXRoXG4gIC8vIC5wcmVjZWRpbmdOb2RlLCAuZW5jbG9zaW5nTm9kZSwgYW5kL29yIC5mb2xsb3dpbmdOb2RlIHByb3BlcnRpZXMsIGF0XG4gIC8vIGxlYXN0IG9uZSBvZiB3aGljaCBpcyBndWFyYW50ZWVkIHRvIGJlIGRlZmluZWQuXG5cblxuICBmdW5jdGlvbiBkZWNvcmF0ZUNvbW1lbnQobm9kZSwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGxvY1N0YXJ0LFxuICAgICAgbG9jRW5kXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2hpbGROb2RlcyA9IGdldFNvcnRlZENoaWxkTm9kZXMobm9kZSwgb3B0aW9ucyk7XG4gICAgbGV0IHByZWNlZGluZ05vZGU7XG4gICAgbGV0IGZvbGxvd2luZ05vZGU7IC8vIFRpbWUgdG8gZHVzdCBvZmYgdGhlIG9sZCBiaW5hcnkgc2VhcmNoIHJvYmVzIGFuZCB3aXphcmQgaGF0LlxuXG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCByaWdodCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgY29uc3QgbWlkZGxlID0gbGVmdCArIHJpZ2h0ID4+IDE7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkTm9kZXNbbWlkZGxlXTtcblxuICAgICAgaWYgKGxvY1N0YXJ0KGNoaWxkKSAtIGxvY1N0YXJ0KGNvbW1lbnQpIDw9IDAgJiYgbG9jRW5kKGNvbW1lbnQpIC0gbG9jRW5kKGNoaWxkKSA8PSAwKSB7XG4gICAgICAgIC8vIFRoZSBjb21tZW50IGlzIGNvbXBsZXRlbHkgY29udGFpbmVkIGJ5IHRoaXMgY2hpbGQgbm9kZS5cbiAgICAgICAgY29tbWVudC5lbmNsb3NpbmdOb2RlID0gY2hpbGQ7XG4gICAgICAgIGRlY29yYXRlQ29tbWVudChjaGlsZCwgY29tbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybjsgLy8gQWJhbmRvbiB0aGUgYmluYXJ5IHNlYXJjaCBhdCB0aGlzIGxldmVsLlxuICAgICAgfVxuXG4gICAgICBpZiAobG9jRW5kKGNoaWxkKSAtIGxvY1N0YXJ0KGNvbW1lbnQpIDw9IDApIHtcbiAgICAgICAgLy8gVGhpcyBjaGlsZCBub2RlIGZhbGxzIGNvbXBsZXRlbHkgYmVmb3JlIHRoZSBjb21tZW50LlxuICAgICAgICAvLyBCZWNhdXNlIHdlIHdpbGwgbmV2ZXIgY29uc2lkZXIgdGhpcyBub2RlIG9yIGFueSBub2Rlc1xuICAgICAgICAvLyBiZWZvcmUgaXQgYWdhaW4sIHRoaXMgbm9kZSBtdXN0IGJlIHRoZSBjbG9zZXN0IHByZWNlZGluZ1xuICAgICAgICAvLyBub2RlIHdlIGhhdmUgZW5jb3VudGVyZWQgc28gZmFyLlxuICAgICAgICBwcmVjZWRpbmdOb2RlID0gY2hpbGQ7XG4gICAgICAgIGxlZnQgPSBtaWRkbGUgKyAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvY0VuZChjb21tZW50KSAtIGxvY1N0YXJ0KGNoaWxkKSA8PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgY2hpbGQgbm9kZSBmYWxscyBjb21wbGV0ZWx5IGFmdGVyIHRoZSBjb21tZW50LlxuICAgICAgICAvLyBCZWNhdXNlIHdlIHdpbGwgbmV2ZXIgY29uc2lkZXIgdGhpcyBub2RlIG9yIGFueSBub2RlcyBhZnRlclxuICAgICAgICAvLyBpdCBhZ2FpbiwgdGhpcyBub2RlIG11c3QgYmUgdGhlIGNsb3Nlc3QgZm9sbG93aW5nIG5vZGUgd2VcbiAgICAgICAgLy8gaGF2ZSBlbmNvdW50ZXJlZCBzbyBmYXIuXG4gICAgICAgIGZvbGxvd2luZ05vZGUgPSBjaGlsZDtcbiAgICAgICAgcmlnaHQgPSBtaWRkbGU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50IGxvY2F0aW9uIG92ZXJsYXBzIHdpdGggbm9kZSBsb2NhdGlvblwiKTtcbiAgICB9IC8vIFdlIGRvbid0IHdhbnQgY29tbWVudHMgaW5zaWRlIG9mIGRpZmZlcmVudCBleHByZXNzaW9ucyBpbnNpZGUgb2YgdGhlIHNhbWVcbiAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFsIHRvIG1vdmUgdG8gYW5vdGhlciBleHByZXNzaW9uLlxuXG5cbiAgICBpZiAoY29tbWVudC5lbmNsb3NpbmdOb2RlICYmIGNvbW1lbnQuZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHF1YXNpc1xuICAgICAgfSA9IGNvbW1lbnQuZW5jbG9zaW5nTm9kZTtcbiAgICAgIGNvbnN0IGNvbW1lbnRJbmRleCA9IGZpbmRFeHByZXNzaW9uSW5kZXhGb3JDb21tZW50KHF1YXNpcywgY29tbWVudCwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChwcmVjZWRpbmdOb2RlICYmIGZpbmRFeHByZXNzaW9uSW5kZXhGb3JDb21tZW50KHF1YXNpcywgcHJlY2VkaW5nTm9kZSwgb3B0aW9ucykgIT09IGNvbW1lbnRJbmRleCkge1xuICAgICAgICBwcmVjZWRpbmdOb2RlID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvbGxvd2luZ05vZGUgJiYgZmluZEV4cHJlc3Npb25JbmRleEZvckNvbW1lbnQocXVhc2lzLCBmb2xsb3dpbmdOb2RlLCBvcHRpb25zKSAhPT0gY29tbWVudEluZGV4KSB7XG4gICAgICAgIGZvbGxvd2luZ05vZGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmVjZWRpbmdOb2RlKSB7XG4gICAgICBjb21tZW50LnByZWNlZGluZ05vZGUgPSBwcmVjZWRpbmdOb2RlO1xuICAgIH1cblxuICAgIGlmIChmb2xsb3dpbmdOb2RlKSB7XG4gICAgICBjb21tZW50LmZvbGxvd2luZ05vZGUgPSBmb2xsb3dpbmdOb2RlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaChjb21tZW50cywgYXN0LCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbW1lbnRzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpZXNUb0JyZWFrID0gW107XG4gICAgY29uc3Qge1xuICAgICAgbG9jU3RhcnQsXG4gICAgICBsb2NFbmRcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb21tZW50cy5mb3JFYWNoKChjb21tZW50LCBpKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5wYXJzZXIgPT09IFwianNvblwiIHx8IG9wdGlvbnMucGFyc2VyID09PSBcImpzb241XCIgfHwgb3B0aW9ucy5wYXJzZXIgPT09IFwiX19qc19leHByZXNzaW9uXCIgfHwgb3B0aW9ucy5wYXJzZXIgPT09IFwiX192dWVfZXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChsb2NTdGFydChjb21tZW50KSAtIGxvY1N0YXJ0KGFzdCkgPD0gMCkge1xuICAgICAgICAgIGFkZExlYWRpbmdDb21tZW50JDIoYXN0LCBjb21tZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jRW5kKGNvbW1lbnQpIC0gbG9jRW5kKGFzdCkgPj0gMCkge1xuICAgICAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQyKGFzdCwgY29tbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlY29yYXRlQ29tbWVudChhc3QsIGNvbW1lbnQsIG9wdGlvbnMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwcmVjZWRpbmdOb2RlLFxuICAgICAgICBlbmNsb3NpbmdOb2RlLFxuICAgICAgICBmb2xsb3dpbmdOb2RlXG4gICAgICB9ID0gY29tbWVudDtcbiAgICAgIGNvbnN0IHBsdWdpbkhhbmRsZU93bkxpbmVDb21tZW50ID0gb3B0aW9ucy5wcmludGVyLmhhbmRsZUNvbW1lbnRzICYmIG9wdGlvbnMucHJpbnRlci5oYW5kbGVDb21tZW50cy5vd25MaW5lID8gb3B0aW9ucy5wcmludGVyLmhhbmRsZUNvbW1lbnRzLm93bkxpbmUgOiAoKSA9PiBmYWxzZTtcbiAgICAgIGNvbnN0IHBsdWdpbkhhbmRsZUVuZE9mTGluZUNvbW1lbnQgPSBvcHRpb25zLnByaW50ZXIuaGFuZGxlQ29tbWVudHMgJiYgb3B0aW9ucy5wcmludGVyLmhhbmRsZUNvbW1lbnRzLmVuZE9mTGluZSA/IG9wdGlvbnMucHJpbnRlci5oYW5kbGVDb21tZW50cy5lbmRPZkxpbmUgOiAoKSA9PiBmYWxzZTtcbiAgICAgIGNvbnN0IHBsdWdpbkhhbmRsZVJlbWFpbmluZ0NvbW1lbnQgPSBvcHRpb25zLnByaW50ZXIuaGFuZGxlQ29tbWVudHMgJiYgb3B0aW9ucy5wcmludGVyLmhhbmRsZUNvbW1lbnRzLnJlbWFpbmluZyA/IG9wdGlvbnMucHJpbnRlci5oYW5kbGVDb21tZW50cy5yZW1haW5pbmcgOiAoKSA9PiBmYWxzZTtcbiAgICAgIGNvbnN0IGlzTGFzdENvbW1lbnQgPSBjb21tZW50cy5sZW5ndGggLSAxID09PSBpO1xuXG4gICAgICBpZiAoaGFzTmV3bGluZSQyKHRleHQsIGxvY1N0YXJ0KGNvbW1lbnQpLCB7XG4gICAgICAgIGJhY2t3YXJkczogdHJ1ZVxuICAgICAgfSkpIHtcbiAgICAgICAgLy8gSWYgYSBjb21tZW50IGV4aXN0cyBvbiBpdHMgb3duIGxpbmUsIHByZWZlciBhIGxlYWRpbmcgY29tbWVudC5cbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIGZpbGUuXG4gICAgICAgIGlmIChwbHVnaW5IYW5kbGVPd25MaW5lQ29tbWVudChjb21tZW50LCB0ZXh0LCBvcHRpb25zLCBhc3QsIGlzTGFzdENvbW1lbnQpKSA7IGVsc2UgaWYgKGZvbGxvd2luZ05vZGUpIHtcbiAgICAgICAgICAvLyBBbHdheXMgYSBsZWFkaW5nIGNvbW1lbnQuXG4gICAgICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVjZWRpbmdOb2RlKSB7XG4gICAgICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDIocHJlY2VkaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5jbG9zaW5nTm9kZSkge1xuICAgICAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQyKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBub2RlcywgbGV0J3MgYXR0YWNoIGl0IHRvIHRoZSByb290IG9mIHRoZSBhc3RcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgYWRkRGFuZ2xpbmdDb21tZW50JDIoYXN0LCBjb21tZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNOZXdsaW5lJDIodGV4dCwgbG9jRW5kKGNvbW1lbnQpKSkge1xuICAgICAgICBpZiAocGx1Z2luSGFuZGxlRW5kT2ZMaW5lQ29tbWVudChjb21tZW50LCB0ZXh0LCBvcHRpb25zLCBhc3QsIGlzTGFzdENvbW1lbnQpKSA7IGVsc2UgaWYgKHByZWNlZGluZ05vZGUpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBjb250ZW50IGJlZm9yZSB0aGlzIGNvbW1lbnQgb24gdGhlIHNhbWUgbGluZSwgYnV0XG4gICAgICAgICAgLy8gbm9uZSBhZnRlciBpdCwgc28gcHJlZmVyIGEgdHJhaWxpbmcgY29tbWVudCBvZiB0aGUgcHJldmlvdXMgbm9kZS5cbiAgICAgICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMihwcmVjZWRpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChmb2xsb3dpbmdOb2RlKSB7XG4gICAgICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbmNsb3NpbmdOb2RlKSB7XG4gICAgICAgICAgYWRkRGFuZ2xpbmdDb21tZW50JDIoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIG5vZGVzLCBsZXQncyBhdHRhY2ggaXQgdG8gdGhlIHJvb3Qgb2YgdGhlIGFzdFxuXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMihhc3QsIGNvbW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGx1Z2luSGFuZGxlUmVtYWluaW5nQ29tbWVudChjb21tZW50LCB0ZXh0LCBvcHRpb25zLCBhc3QsIGlzTGFzdENvbW1lbnQpKSA7IGVsc2UgaWYgKHByZWNlZGluZ05vZGUgJiYgZm9sbG93aW5nTm9kZSkge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGV4dCBleGlzdHMgYm90aCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjb21tZW50IG9uXG4gICAgICAgICAgLy8gdGhlIHNhbWUgbGluZS4gSWYgdGhlcmUgaXMgYm90aCBhIHByZWNlZGluZyBhbmQgZm9sbG93aW5nXG4gICAgICAgICAgLy8gbm9kZSwgdXNlIGEgdGllLWJyZWFraW5nIGFsZ29yaXRobSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgICAgICAgLy8gYmUgYXR0YWNoZWQgdG8gdGhlIG5leHQgb3IgcHJldmlvdXMgbm9kZS4gSW4gdGhlIGxhc3QgY2FzZSxcbiAgICAgICAgICAvLyBzaW1wbHkgYXR0YWNoIHRoZSByaWdodCBub2RlO1xuICAgICAgICAgIGNvbnN0IHRpZUNvdW50ID0gdGllc1RvQnJlYWsubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHRpZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFRpZSA9IHRpZXNUb0JyZWFrW3RpZUNvdW50IC0gMV07XG5cbiAgICAgICAgICAgIGlmIChsYXN0VGllLmZvbGxvd2luZ05vZGUgIT09IGNvbW1lbnQuZm9sbG93aW5nTm9kZSkge1xuICAgICAgICAgICAgICBicmVha1RpZXModGllc1RvQnJlYWssIHRleHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpZXNUb0JyZWFrLnB1c2goY29tbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJlY2VkaW5nTm9kZSkge1xuICAgICAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQyKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvbGxvd2luZ05vZGUpIHtcbiAgICAgICAgICBhZGRMZWFkaW5nQ29tbWVudCQyKGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVuY2xvc2luZ05vZGUpIHtcbiAgICAgICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMihlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gbm9kZXMsIGxldCdzIGF0dGFjaCBpdCB0byB0aGUgcm9vdCBvZiB0aGUgYXN0XG5cbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQyKGFzdCwgY29tbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBicmVha1RpZXModGllc1RvQnJlYWssIHRleHQsIG9wdGlvbnMpO1xuICAgIGNvbW1lbnRzLmZvckVhY2goY29tbWVudCA9PiB7XG4gICAgICAvLyBUaGVzZSBub2RlIHJlZmVyZW5jZXMgd2VyZSB1c2VmdWwgZm9yIGJyZWFraW5nIHRpZXMsIGJ1dCB3ZVxuICAgICAgLy8gZG9uJ3QgbmVlZCB0aGVtIGFueW1vcmUsIGFuZCB0aGV5IGNyZWF0ZSBjeWNsZXMgaW4gdGhlIEFTVCB0aGF0XG4gICAgICAvLyBtYXkgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24gaWYgd2UgZG9uJ3QgZGVsZXRlIHRoZW0gaGVyZS5cbiAgICAgIGRlbGV0ZSBjb21tZW50LnByZWNlZGluZ05vZGU7XG4gICAgICBkZWxldGUgY29tbWVudC5lbmNsb3NpbmdOb2RlO1xuICAgICAgZGVsZXRlIGNvbW1lbnQuZm9sbG93aW5nTm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJyZWFrVGllcyh0aWVzVG9CcmVhaywgdGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpZUNvdW50ID0gdGllc1RvQnJlYWsubGVuZ3RoO1xuXG4gICAgaWYgKHRpZUNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgcHJlY2VkaW5nTm9kZSxcbiAgICAgIGZvbGxvd2luZ05vZGUsXG4gICAgICBlbmNsb3NpbmdOb2RlXG4gICAgfSA9IHRpZXNUb0JyZWFrWzBdO1xuICAgIGNvbnN0IGdhcFJlZ0V4cCA9IG9wdGlvbnMucHJpbnRlci5nZXRHYXBSZWdleCAmJiBvcHRpb25zLnByaW50ZXIuZ2V0R2FwUmVnZXgoZW5jbG9zaW5nTm9kZSkgfHwgL15bXFxzKF0qJC87XG4gICAgbGV0IGdhcEVuZFBvcyA9IG9wdGlvbnMubG9jU3RhcnQoZm9sbG93aW5nTm9kZSk7IC8vIEl0ZXJhdGUgYmFja3dhcmRzIHRocm91Z2ggdGllc1RvQnJlYWssIGV4YW1pbmluZyB0aGUgZ2Fwc1xuICAgIC8vIGJldHdlZW4gdGhlIHRpZWQgY29tbWVudHMuIEluIG9yZGVyIHRvIHF1YWxpZnkgYXMgbGVhZGluZywgYVxuICAgIC8vIGNvbW1lbnQgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBmb2xsb3dpbmdOb2RlIGJ5IGFuIHVuYnJva2VuIHNlcmllcyBvZlxuICAgIC8vIGdhcHMgKG9yIG90aGVyIGNvbW1lbnRzKS4gR2FwcyBzaG91bGQgb25seSBjb250YWluIHdoaXRlc3BhY2Ugb3Igb3BlblxuICAgIC8vIHBhcmVudGhlc2VzLlxuXG4gICAgbGV0IGluZGV4T2ZGaXJzdExlYWRpbmdDb21tZW50O1xuXG4gICAgZm9yIChpbmRleE9mRmlyc3RMZWFkaW5nQ29tbWVudCA9IHRpZUNvdW50OyBpbmRleE9mRmlyc3RMZWFkaW5nQ29tbWVudCA+IDA7IC0taW5kZXhPZkZpcnN0TGVhZGluZ0NvbW1lbnQpIHtcbiAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aWVzVG9CcmVha1tpbmRleE9mRmlyc3RMZWFkaW5nQ29tbWVudCAtIDFdO1xuICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKGNvbW1lbnQucHJlY2VkaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSk7XG4gICAgICBhc3NlcnQuc3RyaWN0RXF1YWwoY29tbWVudC5mb2xsb3dpbmdOb2RlLCBmb2xsb3dpbmdOb2RlKTtcbiAgICAgIGNvbnN0IGdhcCA9IHRleHQuc2xpY2Uob3B0aW9ucy5sb2NFbmQoY29tbWVudCksIGdhcEVuZFBvcyk7XG5cbiAgICAgIGlmIChnYXBSZWdFeHAudGVzdChnYXApKSB7XG4gICAgICAgIGdhcEVuZFBvcyA9IG9wdGlvbnMubG9jU3RhcnQoY29tbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgZ2FwIHN0cmluZyBjb250YWluZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gd2hpdGVzcGFjZSBvciBvcGVuXG4gICAgICAgIC8vIHBhcmVudGhlc2VzLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aWVzVG9CcmVhay5mb3JFYWNoKChjb21tZW50LCBpKSA9PiB7XG4gICAgICBpZiAoaSA8IGluZGV4T2ZGaXJzdExlYWRpbmdDb21tZW50KSB7XG4gICAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQyKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMihmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aWVzVG9CcmVhay5sZW5ndGggPSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDb21tZW50KGNvbW1lbnRQYXRoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWVudCA9IGNvbW1lbnRQYXRoLmdldFZhbHVlKCk7XG4gICAgY29tbWVudC5wcmludGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gb3B0aW9ucy5wcmludGVyLnByaW50Q29tbWVudChjb21tZW50UGF0aCwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRXhwcmVzc2lvbkluZGV4Rm9yQ29tbWVudChxdWFzaXMsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9IG9wdGlvbnMubG9jU3RhcnQoY29tbWVudCkgLSAxO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBxdWFzaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChzdGFydFBvcyA8IGdldFF1YXNpUmFuZ2UocXVhc2lzW2ldKS5zdGFydCkge1xuICAgICAgICByZXR1cm4gaSAtIDE7XG4gICAgICB9XG4gICAgfSAvLyBXZSBoYXZlbid0IGZvdW5kIGl0LCBpdCBwcm9iYWJseSBtZWFucyB0aGF0IHNvbWUgb2YgdGhlIGxvY2F0aW9ucyBhcmUgb2ZmLlxuICAgIC8vIExldCdzIGp1c3QgcmV0dXJuIHRoZSBmaXJzdCBvbmUuXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFF1YXNpUmFuZ2UoZXhwcikge1xuICAgIGlmIChleHByLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEJhYmVsXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogZXhwci5zdGFydCxcbiAgICAgICAgZW5kOiBleHByLmVuZFxuICAgICAgfTtcbiAgICB9IC8vIEZsb3dcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBleHByLnJhbmdlWzBdLFxuICAgICAgZW5kOiBleHByLnJhbmdlWzFdXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50TGVhZGluZ0NvbW1lbnQoY29tbWVudFBhdGgsIHByaW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWVudCA9IGNvbW1lbnRQYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgY29udGVudHMgPSBwcmludENvbW1lbnQoY29tbWVudFBhdGgsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCFjb250ZW50cykge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgY29uc3QgaXNCbG9jayA9IG9wdGlvbnMucHJpbnRlci5pc0Jsb2NrQ29tbWVudCAmJiBvcHRpb25zLnByaW50ZXIuaXNCbG9ja0NvbW1lbnQoY29tbWVudCk7IC8vIExlYWRpbmcgYmxvY2sgY29tbWVudHMgc2hvdWxkIHNlZSBpZiB0aGV5IG5lZWQgdG8gc3RheSBvbiB0aGVcbiAgICAvLyBzYW1lIGxpbmUgb3Igbm90LlxuXG4gICAgaWYgKGlzQmxvY2spIHtcbiAgICAgIGNvbnN0IGxpbmVCcmVhayA9IGhhc05ld2xpbmUkMihvcHRpb25zLm9yaWdpbmFsVGV4dCwgb3B0aW9ucy5sb2NFbmQoY29tbWVudCkpID8gaGFzTmV3bGluZSQyKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY1N0YXJ0KGNvbW1lbnQpLCB7XG4gICAgICAgIGJhY2t3YXJkczogdHJ1ZVxuICAgICAgfSkgPyBoYXJkbGluZSQxIDogbGluZSQxIDogXCIgXCI7XG4gICAgICByZXR1cm4gY29uY2F0JDIoW2NvbnRlbnRzLCBsaW5lQnJlYWtdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JDIoW2NvbnRlbnRzLCBoYXJkbGluZSQxXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFRyYWlsaW5nQ29tbWVudChjb21tZW50UGF0aCwgcHJpbnQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb21tZW50ID0gY29tbWVudFBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBjb250ZW50cyA9IHByaW50Q29tbWVudChjb21tZW50UGF0aCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIWNvbnRlbnRzKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBjb25zdCBpc0Jsb2NrID0gb3B0aW9ucy5wcmludGVyLmlzQmxvY2tDb21tZW50ICYmIG9wdGlvbnMucHJpbnRlci5pc0Jsb2NrQ29tbWVudChjb21tZW50KTsgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgbGluZSB0byBicmVha1xuICAgIC8vIHdoZW4gdGhlIHBhcmVudFBhcmVudE5vZGUgaXMgYSBDbGFzc0RlY2xhcmF0aW9uLy1FeHByZXNzaW9uXG4gICAgLy8gQW5kIHRoZSBwYXJlbnROb2RlIGlzIGluIHRoZSBzdXBlckNsYXNzIHByb3BlcnR5XG5cbiAgICBjb25zdCBwYXJlbnROb2RlID0gY29tbWVudFBhdGguZ2V0Tm9kZSgxKTtcbiAgICBjb25zdCBwYXJlbnRQYXJlbnROb2RlID0gY29tbWVudFBhdGguZ2V0Tm9kZSgyKTtcbiAgICBjb25zdCBpc1BhcmVudFN1cGVyQ2xhc3MgPSBwYXJlbnRQYXJlbnROb2RlICYmIChwYXJlbnRQYXJlbnROb2RlLnR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiIHx8IHBhcmVudFBhcmVudE5vZGUudHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikgJiYgcGFyZW50UGFyZW50Tm9kZS5zdXBlckNsYXNzID09PSBwYXJlbnROb2RlO1xuXG4gICAgaWYgKGhhc05ld2xpbmUkMihvcHRpb25zLm9yaWdpbmFsVGV4dCwgb3B0aW9ucy5sb2NTdGFydChjb21tZW50KSwge1xuICAgICAgYmFja3dhcmRzOiB0cnVlXG4gICAgfSkpIHtcbiAgICAgIC8vIFRoaXMgYWxsb3dzIGNvbW1lbnRzIGF0IHRoZSBlbmQgb2YgbmVzdGVkIHN0cnVjdHVyZXM6XG4gICAgICAvLyB7XG4gICAgICAvLyAgIHg6IDEsXG4gICAgICAvLyAgIHk6IDJcbiAgICAgIC8vICAgLy8gQSBjb21tZW50XG4gICAgICAvLyB9XG4gICAgICAvLyBUaG9zZSBraW5kcyBvZiBjb21tZW50cyBhcmUgYWxtb3N0IGFsd2F5cyBsZWFkaW5nIGNvbW1lbnRzLCBidXRcbiAgICAgIC8vIGhlcmUgaXQgZG9lc24ndCBnbyBcIm91dHNpZGVcIiB0aGUgYmxvY2sgYW5kIHR1cm5zIGl0IGludG8gYVxuICAgICAgLy8gdHJhaWxpbmcgY29tbWVudCBmb3IgYDJgLiBXZSBjYW4gc2ltdWxhdGUgdGhlIGFib3ZlIGJ5IGNoZWNraW5nXG4gICAgICAvLyBpZiB0aGlzIGEgY29tbWVudCBvbiBpdHMgb3duIGxpbmU7IG5vcm1hbCB0cmFpbGluZyBjb21tZW50cyBhcmVcbiAgICAgIC8vIGFsd2F5cyBhdCB0aGUgZW5kIG9mIGFub3RoZXIgZXhwcmVzc2lvbi5cbiAgICAgIGNvbnN0IGlzTGluZUJlZm9yZUVtcHR5ID0gaXNQcmV2aW91c0xpbmVFbXB0eSQyKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBjb21tZW50LCBvcHRpb25zLmxvY1N0YXJ0KTtcbiAgICAgIHJldHVybiBsaW5lU3VmZml4JDEoY29uY2F0JDIoW2hhcmRsaW5lJDEsIGlzTGluZUJlZm9yZUVtcHR5ID8gaGFyZGxpbmUkMSA6IFwiXCIsIGNvbnRlbnRzXSkpO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9jayB8fCBpc1BhcmVudFN1cGVyQ2xhc3MpIHtcbiAgICAgIC8vIFRyYWlsaW5nIGJsb2NrIGNvbW1lbnRzIG5ldmVyIG5lZWQgYSBuZXdsaW5lXG4gICAgICByZXR1cm4gY29uY2F0JDIoW1wiIFwiLCBjb250ZW50c10pO1xuICAgIH1cblxuICAgIHJldHVybiBjb25jYXQkMihbbGluZVN1ZmZpeCQxKGNvbmNhdCQyKFtcIiBcIiwgY29udGVudHNdKSksICFpc0Jsb2NrID8gYnJlYWtQYXJlbnQkMSA6IFwiXCJdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLCBzYW1lSW5kZW50LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBpZiAoIW5vZGUgfHwgIW5vZGUuY29tbWVudHMpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHBhdGguZWFjaChjb21tZW50UGF0aCA9PiB7XG4gICAgICBjb25zdCBjb21tZW50ID0gY29tbWVudFBhdGguZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKGNvbW1lbnQgJiYgIWNvbW1lbnQubGVhZGluZyAmJiAhY29tbWVudC50cmFpbGluZyAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoY29tbWVudCkpKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocHJpbnRDb21tZW50KGNvbW1lbnRQYXRoLCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfSwgXCJjb21tZW50c1wiKTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIGlmIChzYW1lSW5kZW50KSB7XG4gICAgICByZXR1cm4gam9pbiQxKGhhcmRsaW5lJDEsIHBhcnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZW50JDEoY29uY2F0JDIoW2hhcmRsaW5lJDEsIGpvaW4kMShoYXJkbGluZSQxLCBwYXJ0cyldKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwZW5kQ3Vyc29yUGxhY2Vob2xkZXIocGF0aCwgb3B0aW9ucywgcHJpbnRlZCkge1xuICAgIGlmIChwYXRoLmdldE5vZGUoKSA9PT0gb3B0aW9ucy5jdXJzb3JOb2RlICYmIHBhdGguZ2V0VmFsdWUoKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCQyKFtjdXJzb3IkMiwgcHJpbnRlZCwgY3Vyc29yJDJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJpbnRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q29tbWVudHMocGF0aCwgcHJpbnQsIG9wdGlvbnMsIG5lZWRzU2VtaSkge1xuICAgIGNvbnN0IHZhbHVlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHByaW50ZWQgPSBwcmludChwYXRoKTtcbiAgICBjb25zdCBjb21tZW50cyA9IHZhbHVlICYmIHZhbHVlLmNvbW1lbnRzO1xuXG4gICAgaWYgKCFjb21tZW50cyB8fCBjb21tZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBwcmVwZW5kQ3Vyc29yUGxhY2Vob2xkZXIocGF0aCwgb3B0aW9ucywgcHJpbnRlZCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVhZGluZ1BhcnRzID0gW107XG4gICAgY29uc3QgdHJhaWxpbmdQYXJ0cyA9IFtuZWVkc1NlbWkgPyBcIjtcIiA6IFwiXCIsIHByaW50ZWRdO1xuICAgIHBhdGguZWFjaChjb21tZW50UGF0aCA9PiB7XG4gICAgICBjb25zdCBjb21tZW50ID0gY29tbWVudFBhdGguZ2V0VmFsdWUoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVhZGluZyxcbiAgICAgICAgdHJhaWxpbmdcbiAgICAgIH0gPSBjb21tZW50O1xuXG4gICAgICBpZiAobGVhZGluZykge1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IHByaW50TGVhZGluZ0NvbW1lbnQoY29tbWVudFBhdGgsIHByaW50LCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoIWNvbnRlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVhZGluZ1BhcnRzLnB1c2goY29udGVudHMpO1xuICAgICAgICBjb25zdCB0ZXh0ID0gb3B0aW9ucy5vcmlnaW5hbFRleHQ7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2tpcE5ld2xpbmUkMih0ZXh0LCBvcHRpb25zLmxvY0VuZChjb21tZW50KSk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSBmYWxzZSAmJiBoYXNOZXdsaW5lJDIodGV4dCwgaW5kZXgpKSB7XG4gICAgICAgICAgbGVhZGluZ1BhcnRzLnB1c2goaGFyZGxpbmUkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHJhaWxpbmcpIHtcbiAgICAgICAgdHJhaWxpbmdQYXJ0cy5wdXNoKHByaW50VHJhaWxpbmdDb21tZW50KGNvbW1lbnRQYXRoLCBwcmludCwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0sIFwiY29tbWVudHNcIik7XG4gICAgcmV0dXJuIHByZXBlbmRDdXJzb3JQbGFjZWhvbGRlcihwYXRoLCBvcHRpb25zLCBjb25jYXQkMihsZWFkaW5nUGFydHMuY29uY2F0KHRyYWlsaW5nUGFydHMpKSk7XG4gIH1cblxuICB2YXIgY29tbWVudHMgPSB7XG4gICAgYXR0YWNoLFxuICAgIHByaW50Q29tbWVudHMsXG4gICAgcHJpbnREYW5nbGluZ0NvbW1lbnRzLFxuICAgIGdldFNvcnRlZENoaWxkTm9kZXNcbiAgfTtcblxuICBmdW5jdGlvbiBnZXROb2RlSGVscGVyKHBhdGgsIGNvdW50KSB7XG4gICAgY29uc3Qgc3RhY2tJbmRleCA9IGdldE5vZGVTdGFja0luZGV4SGVscGVyKHBhdGguc3RhY2ssIGNvdW50KTtcbiAgICByZXR1cm4gc3RhY2tJbmRleCA9PT0gLTEgPyBudWxsIDogcGF0aC5zdGFja1tzdGFja0luZGV4XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVTdGFja0luZGV4SGVscGVyKHN0YWNrLCBjb3VudCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgY29uc3QgdmFsdWUgPSBzdGFja1tpXTtcblxuICAgICAgaWYgKHZhbHVlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAtLWNvdW50IDwgMCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBjbGFzcyBGYXN0UGF0aCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgIHRoaXMuc3RhY2sgPSBbdmFsdWVdO1xuICAgIH0gLy8gVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgcHJvcGVydHkgaXMgYWx3YXlzIHRoZSBwZW51bHRpbWF0ZSBlbGVtZW50IG9mXG4gICAgLy8gdGhpcy5zdGFjaywgYW5kIGFsd2F5cyBhIFN0cmluZy5cblxuXG4gICAgZ2V0TmFtZSgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhY2tcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSBzdGFjaztcblxuICAgICAgaWYgKGxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrW2xlbmd0aCAtIDJdO1xuICAgICAgfSAvLyBTaW5jZSB0aGUgbmFtZSBpcyBhbHdheXMgYSBzdHJpbmcsIG51bGwgaXMgYSBzYWZlIHNlbnRpbmVsIHZhbHVlIHRvXG4gICAgICAvLyByZXR1cm4gaWYgd2UgZG8gbm90IGtub3cgdGhlIG5hbWUgb2YgdGhlIChyb290KSB2YWx1ZS5cblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIFRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eSBpcyBhbHdheXMgdGhlIGZpbmFsIGVsZW1lbnQgb2ZcbiAgICAvLyB0aGlzLnN0YWNrLlxuXG5cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBnZXRMYXN0KHRoaXMuc3RhY2spO1xuICAgIH1cblxuICAgIGdldE5vZGUoY291bnQgPSAwKSB7XG4gICAgICByZXR1cm4gZ2V0Tm9kZUhlbHBlcih0aGlzLCBjb3VudCk7XG4gICAgfVxuXG4gICAgZ2V0UGFyZW50Tm9kZShjb3VudCA9IDApIHtcbiAgICAgIHJldHVybiBnZXROb2RlSGVscGVyKHRoaXMsIGNvdW50ICsgMSk7XG4gICAgfSAvLyBUZW1wb3JhcmlseSBwdXNoIHByb3BlcnRpZXMgbmFtZWQgYnkgc3RyaW5nIGFyZ3VtZW50cyBnaXZlbiBhZnRlciB0aGVcbiAgICAvLyBjYWxsYmFjayBmdW5jdGlvbiBvbnRvIHRoaXMuc3RhY2ssIHRoZW4gY2FsbCB0aGUgY2FsbGJhY2sgd2l0aCBhXG4gICAgLy8gcmVmZXJlbmNlIHRvIHRoaXMgKG1vZGlmaWVkKSBGYXN0UGF0aCBvYmplY3QuIE5vdGUgdGhhdCB0aGUgc3RhY2sgd2lsbFxuICAgIC8vIGJlIHJlc3RvcmVkIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZSBhZnRlciB0aGUgY2FsbGJhY2sgaXMgZmluaXNoZWQsIHNvIGl0XG4gICAgLy8gaXMgcHJvYmFibHkgYSBtaXN0YWtlIHRvIHJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgcGF0aC5cblxuXG4gICAgY2FsbChjYWxsYmFjaywgLi4ubmFtZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhY2tcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSBzdGFjaztcbiAgICAgIGxldCB2YWx1ZSA9IGdldExhc3Qoc3RhY2spO1xuXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVtuYW1lXTtcbiAgICAgICAgc3RhY2sucHVzaChuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKHRoaXMpO1xuICAgICAgc3RhY2subGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjYWxsUGFyZW50KGNhbGxiYWNrLCBjb3VudCA9IDApIHtcbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSBnZXROb2RlU3RhY2tJbmRleEhlbHBlcih0aGlzLnN0YWNrLCBjb3VudCArIDEpO1xuICAgICAgY29uc3QgcGFyZW50VmFsdWVzID0gdGhpcy5zdGFjay5zcGxpY2Uoc3RhY2tJbmRleCArIDEpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2sodGhpcyk7XG4gICAgICB0aGlzLnN0YWNrLnB1c2goLi4ucGFyZW50VmFsdWVzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSAvLyBTaW1pbGFyIHRvIEZhc3RQYXRoLnByb3RvdHlwZS5jYWxsLCBleGNlcHQgdGhhdCB0aGUgdmFsdWUgb2J0YWluZWQgYnlcbiAgICAvLyBhY2Nlc3NpbmcgdGhpcy5nZXRWYWx1ZSgpW25hbWUxXVtuYW1lMl0uLi4gc2hvdWxkIGJlIGFycmF5LWxpa2UuIFRoZVxuICAgIC8vIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYSByZWZlcmVuY2UgdG8gdGhpcyBwYXRoIG9iamVjdCBmb3IgZWFjaFxuICAgIC8vIGVsZW1lbnQgb2YgdGhlIGFycmF5LlxuXG5cbiAgICBlYWNoKGNhbGxiYWNrLCAuLi5uYW1lcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGFja1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSA9IHN0YWNrO1xuICAgICAgbGV0IHZhbHVlID0gZ2V0TGFzdChzdGFjayk7XG5cbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlW25hbWVdO1xuICAgICAgICBzdGFjay5wdXNoKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaSBpbiB2YWx1ZSkge1xuICAgICAgICAgIHN0YWNrLnB1c2goaSwgdmFsdWVbaV0pOyAvLyBJZiB0aGUgY2FsbGJhY2sgbmVlZHMgdG8ga25vdyB0aGUgdmFsdWUgb2YgaSwgY2FsbFxuICAgICAgICAgIC8vIHBhdGguZ2V0TmFtZSgpLCBhc3N1bWluZyBwYXRoIGlzIHRoZSBwYXJhbWV0ZXIgbmFtZS5cblxuICAgICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgIHN0YWNrLmxlbmd0aCAtPSAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YWNrLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9IC8vIFNpbWlsYXIgdG8gRmFzdFBhdGgucHJvdG90eXBlLmVhY2gsIGV4Y2VwdCB0aGF0IHRoZSByZXN1bHRzIG9mIHRoZVxuICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9jYXRpb25zIGFyZSBzdG9yZWQgaW4gYW4gYXJyYXkgYW5kIHJldHVybmVkIGF0XG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgaXRlcmF0aW9uLlxuXG5cbiAgICBtYXAoY2FsbGJhY2ssIC4uLm5hbWVzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YWNrXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gc3RhY2s7XG4gICAgICBsZXQgdmFsdWUgPSBnZXRMYXN0KHN0YWNrKTtcblxuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWVbbmFtZV07XG4gICAgICAgIHN0YWNrLnB1c2gobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkodmFsdWUubGVuZ3RoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaSBpbiB2YWx1ZSkge1xuICAgICAgICAgIHN0YWNrLnB1c2goaSwgdmFsdWVbaV0pO1xuICAgICAgICAgIHJlc3VsdFtpXSA9IGNhbGxiYWNrKHRoaXMsIGkpO1xuICAgICAgICAgIHN0YWNrLmxlbmd0aCAtPSAyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YWNrLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Li4uKFxuICAgICAqICAgfCAoKG5vZGU6IGFueSwgbmFtZTogc3RyaW5nIHwgbnVsbCwgbnVtYmVyOiBudW1iZXIgfCBudWxsKSA9PiBib29sZWFuKVxuICAgICAqICAgfCB1bmRlZmluZWRcbiAgICAgKiApfSBwcmVkaWNhdGVzXG4gICAgICovXG5cblxuICAgIG1hdGNoKC4uLnByZWRpY2F0ZXMpIHtcbiAgICAgIGxldCBzdGFja1BvaW50ZXIgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgbmFtZSA9IG51bGw7XG4gICAgICBsZXQgbm9kZSA9IHRoaXMuc3RhY2tbc3RhY2tQb2ludGVyLS1dO1xuXG4gICAgICBmb3IgKGNvbnN0IHByZWRpY2F0ZSBvZiBwcmVkaWNhdGVzKSB7XG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gc2tpcCBpbmRleC9hcnJheVxuXG5cbiAgICAgICAgbGV0IG51bWJlciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgbnVtYmVyID0gbmFtZTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5zdGFja1tzdGFja1BvaW50ZXItLV07XG4gICAgICAgICAgbm9kZSA9IHRoaXMuc3RhY2tbc3RhY2tQb2ludGVyLS1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZSAmJiAhcHJlZGljYXRlKG5vZGUsIG5hbWUsIG51bWJlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gdGhpcy5zdGFja1tzdGFja1BvaW50ZXItLV07XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YWNrW3N0YWNrUG9pbnRlci0tXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH1cblxuICB2YXIgZmFzdFBhdGggPSBGYXN0UGF0aDtcblxuICBjb25zdCB7XG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUkMlxuICB9ID0gb3B0aW9ucyQxO1xuXG4gIGZ1bmN0aW9uIHByaW50U3VidHJlZShwYXRoLCBwcmludCwgb3B0aW9ucywgcHJpbnRBc3RUb0RvYykge1xuICAgIGlmIChvcHRpb25zLnByaW50ZXIuZW1iZWQpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLnByaW50ZXIuZW1iZWQocGF0aCwgcHJpbnQsICh0ZXh0LCBwYXJ0aWFsTmV4dE9wdGlvbnMpID0+IHRleHRUb0RvYyh0ZXh0LCBwYXJ0aWFsTmV4dE9wdGlvbnMsIG9wdGlvbnMsIHByaW50QXN0VG9Eb2MpLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0VG9Eb2ModGV4dCwgcGFydGlhbE5leHRPcHRpb25zLCBwYXJlbnRPcHRpb25zLCBwcmludEFzdFRvRG9jKSB7XG4gICAgY29uc3QgbmV4dE9wdGlvbnMgPSBub3JtYWxpemUkMihPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRPcHRpb25zLCB7fSwgcGFydGlhbE5leHRPcHRpb25zLCB7XG4gICAgICBwYXJlbnRQYXJzZXI6IHBhcmVudE9wdGlvbnMucGFyc2VyLFxuICAgICAgZW1iZWRkZWRJbkh0bWw6ICEhKHBhcmVudE9wdGlvbnMuZW1iZWRkZWRJbkh0bWwgfHwgcGFyZW50T3B0aW9ucy5wYXJzZXIgPT09IFwiaHRtbFwiIHx8IHBhcmVudE9wdGlvbnMucGFyc2VyID09PSBcInZ1ZVwiIHx8IHBhcmVudE9wdGlvbnMucGFyc2VyID09PSBcImFuZ3VsYXJcIiB8fCBwYXJlbnRPcHRpb25zLnBhcnNlciA9PT0gXCJsd2NcIiksXG4gICAgICBvcmlnaW5hbFRleHQ6IHRleHRcbiAgICB9KSwge1xuICAgICAgcGFzc1Rocm91Z2g6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2UodGV4dCwgbmV4dE9wdGlvbnMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFzdFxuICAgIH0gPSByZXN1bHQ7XG4gICAgdGV4dCA9IHJlc3VsdC50ZXh0O1xuICAgIGNvbnN0IGFzdENvbW1lbnRzID0gYXN0LmNvbW1lbnRzO1xuICAgIGRlbGV0ZSBhc3QuY29tbWVudHM7XG4gICAgY29tbWVudHMuYXR0YWNoKGFzdENvbW1lbnRzLCBhc3QsIHRleHQsIG5leHRPcHRpb25zKTtcbiAgICByZXR1cm4gcHJpbnRBc3RUb0RvYyhhc3QsIG5leHRPcHRpb25zKTtcbiAgfVxuXG4gIHZhciBtdWx0aXBhcnNlciA9IHtcbiAgICBwcmludFN1YnRyZWVcbiAgfTtcblxuICBjb25zdCBkb2MgPSBkb2N1bWVudDtcbiAgY29uc3QgZG9jQnVpbGRlcnMkMSA9IGRvYy5idWlsZGVycztcbiAgY29uc3Qge1xuICAgIGNvbmNhdDogY29uY2F0JDMsXG4gICAgaGFyZGxpbmU6IGhhcmRsaW5lJDIsXG4gICAgYWRkQWxpZ25tZW50VG9Eb2M6IGFkZEFsaWdubWVudFRvRG9jJDFcbiAgfSA9IGRvY0J1aWxkZXJzJDE7XG4gIGNvbnN0IGRvY1V0aWxzJDEgPSBkb2MudXRpbHM7XG4gIC8qKlxuICAgKiBUYWtlcyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSAoQVNUKSBhbmQgcmVjdXJzaXZlbHkgY29udmVydHMgaXQgdG8gYVxuICAgKiBkb2N1bWVudCAoc2VyaWVzIG9mIHByaW50aW5nIHByaW1pdGl2ZXMpLlxuICAgKlxuICAgKiBUaGlzIGlzIGRvbmUgYnkgZGVzY2VuZGluZyBkb3duIHRoZSBBU1QgcmVjdXJzaXZlbHkuIFRoZSByZWN1cnNpb25cbiAgICogaW52b2x2ZXMgdHdvIGZ1bmN0aW9ucyB0aGF0IGNhbGwgZWFjaCBvdGhlcjpcbiAgICpcbiAgICogMS4gcHJpbnRHZW5lcmljYWxseSgpLCB3aGljaCBpcyBkZWZpbmVkIGFzIGFuIGlubmVyIGZ1bmN0aW9uIGhlcmUuXG4gICAqICAgIEl0IGJhc2ljYWxseSB0YWtlcyBjYXJlIG9mIG5vZGUgY2FjaGluZy5cbiAgICogMi4gY2FsbFBsdWdpblByaW50RnVuY3Rpb24oKSwgd2hpY2ggY2hlY2tzIGZvciBzb21lIG9wdGlvbnMsIGFuZFxuICAgKiAgICB1bHRpbWF0ZWx5IGNhbGxzIHRoZSBwcmludCgpIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSBwbHVnaW4uXG4gICAqXG4gICAqIFRoZSBwbHVnaW4gZnVuY3Rpb24gd2lsbCBjYWxsIHByaW50R2VuZXJpY2FsbHkoKSBhZ2FpbiBmb3IgY2hpbGQgbm9kZXNcbiAgICogb2YgdGhlIGN1cnJlbnQgbm9kZSwgd2hpY2ggd2lsbCBkbyBpdHMgaG91c2VrZWVwaW5nLCB0aGVuIGNhbGwgdGhlXG4gICAqIHBsdWdpbiBmdW5jdGlvbiBhZ2FpbiwgYW5kIHNvIG9uLlxuICAgKlxuICAgKiBBbGwgdGhlIHdoaWxlLCB0aGVzZSBmdW5jdGlvbnMgcGFzcyBhIFwicGF0aFwiIHZhcmlhYmxlIGFyb3VuZCwgd2hpY2hcbiAgICogaXMgYSBzdGFjay1saWtlIGRhdGEgc3RydWN0dXJlIChGYXN0UGF0aCkgdGhhdCBtYWludGFpbnMgdGhlIGN1cnJlbnRcbiAgICogc3RhdGUgb2YgdGhlIHJlY3Vyc2lvbi4gSXQgaXMgY2FsbGVkIFwicGF0aFwiLCBiZWNhdXNlIGl0IHJlcHJlc2VudHNcbiAgICogdGhlIHBhdGggdG8gdGhlIGN1cnJlbnQgbm9kZSB0aHJvdWdoIHRoZSBBYnN0cmFjdCBTeW50YXggVHJlZS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcHJpbnRBc3RUb0RvYyhhc3QsIG9wdGlvbnMsIGFsaWdubWVudFNpemUgPSAwKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpbnRlclxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKHByaW50ZXIucHJlcHJvY2Vzcykge1xuICAgICAgYXN0ID0gcHJpbnRlci5wcmVwcm9jZXNzKGFzdCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG5cbiAgICBmdW5jdGlvbiBwcmludEdlbmVyaWNhbGx5KHBhdGgsIGFyZ3MpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgICBjb25zdCBzaG91bGRDYWNoZSA9IG5vZGUgJiYgdHlwZW9mIG5vZGUgPT09IFwib2JqZWN0XCIgJiYgYXJncyA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoc2hvdWxkQ2FjaGUgJiYgY2FjaGUuaGFzKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQobm9kZSk7XG4gICAgICB9IC8vIFdlIGxldCBKU1hFbGVtZW50IHByaW50IGl0cyBjb21tZW50cyBpdHNlbGYgYmVjYXVzZSBpdCBhZGRzICgpIGFyb3VuZFxuICAgICAgLy8gVW5pb25UeXBlQW5ub3RhdGlvbiBoYXMgdG8gYWxpZ24gdGhlIGNoaWxkIHdpdGhvdXQgdGhlIGNvbW1lbnRzXG5cblxuICAgICAgbGV0IHJlcztcblxuICAgICAgaWYgKHByaW50ZXIud2lsbFByaW50T3duQ29tbWVudHMgJiYgcHJpbnRlci53aWxsUHJpbnRPd25Db21tZW50cyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgICByZXMgPSBjYWxsUGx1Z2luUHJpbnRGdW5jdGlvbihwYXRoLCBvcHRpb25zLCBwcmludEdlbmVyaWNhbGx5LCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHByaW50Q29tbWVudHMgd2lsbCBjYWxsIHRoZSBwbHVnaW4gcHJpbnQgZnVuY3Rpb24gYW5kIGNoZWNrIGZvclxuICAgICAgICAvLyBjb21tZW50cyB0byBwcmludFxuICAgICAgICByZXMgPSBjb21tZW50cy5wcmludENvbW1lbnRzKHBhdGgsIHAgPT4gY2FsbFBsdWdpblByaW50RnVuY3Rpb24ocCwgb3B0aW9ucywgcHJpbnRHZW5lcmljYWxseSwgYXJncyksIG9wdGlvbnMsIGFyZ3MgJiYgYXJncy5uZWVkc1NlbWkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgY2FjaGUuc2V0KG5vZGUsIHJlcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgbGV0IGRvYyA9IHByaW50R2VuZXJpY2FsbHkobmV3IGZhc3RQYXRoKGFzdCkpO1xuXG4gICAgaWYgKGFsaWdubWVudFNpemUgPiAwKSB7XG4gICAgICAvLyBBZGQgYSBoYXJkbGluZSB0byBtYWtlIHRoZSBpbmRlbnRzIHRha2UgZWZmZWN0XG4gICAgICAvLyBJdCBzaG91bGQgYmUgcmVtb3ZlZCBpbiBpbmRleC5qcyBmb3JtYXQoKVxuICAgICAgZG9jID0gYWRkQWxpZ25tZW50VG9Eb2MkMShjb25jYXQkMyhbaGFyZGxpbmUkMiwgZG9jXSksIGFsaWdubWVudFNpemUsIG9wdGlvbnMudGFiV2lkdGgpO1xuICAgIH1cblxuICAgIGRvY1V0aWxzJDEucHJvcGFnYXRlQnJlYWtzKGRvYyk7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxQbHVnaW5QcmludEZ1bmN0aW9uKHBhdGgsIG9wdGlvbnMsIHByaW50UGF0aCwgYXJncykge1xuICAgIGFzc2VydC5vayhwYXRoIGluc3RhbmNlb2YgZmFzdFBhdGgpO1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3Qge1xuICAgICAgcHJpbnRlclxuICAgIH0gPSBvcHRpb25zOyAvLyBFc2NhcGUgaGF0Y2hcblxuICAgIGlmIChwcmludGVyLmhhc1ByZXR0aWVySWdub3JlICYmIHByaW50ZXIuaGFzUHJldHRpZXJJZ25vcmUocGF0aCkpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShvcHRpb25zLmxvY1N0YXJ0KG5vZGUpLCBvcHRpb25zLmxvY0VuZChub2RlKSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFBvdGVudGlhbGx5IHN3aXRjaCB0byBhIGRpZmZlcmVudCBwYXJzZXJcbiAgICAgICAgY29uc3Qgc3ViID0gbXVsdGlwYXJzZXIucHJpbnRTdWJ0cmVlKHBhdGgsIHByaW50UGF0aCwgb3B0aW9ucywgcHJpbnRBc3RUb0RvYyk7XG5cbiAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgIHJldHVybiBzdWI7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29tbW9uanNHbG9iYWwuUFJFVFRJRVJfREVCVUcpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSAvLyBDb250aW51ZSB3aXRoIGN1cnJlbnQgcGFyc2VyXG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJpbnRlci5wcmludChwYXRoLCBvcHRpb25zLCBwcmludFBhdGgsIGFyZ3MpO1xuICB9XG5cbiAgdmFyIGFzdFRvRG9jID0gcHJpbnRBc3RUb0RvYztcblxuICBmdW5jdGlvbiBmaW5kU2libGluZ0FuY2VzdG9ycyhzdGFydE5vZGVBbmRQYXJlbnRzLCBlbmROb2RlQW5kUGFyZW50cywgb3B0cykge1xuICAgIGxldCByZXN1bHRTdGFydE5vZGUgPSBzdGFydE5vZGVBbmRQYXJlbnRzLm5vZGU7XG4gICAgbGV0IHJlc3VsdEVuZE5vZGUgPSBlbmROb2RlQW5kUGFyZW50cy5ub2RlO1xuXG4gICAgaWYgKHJlc3VsdFN0YXJ0Tm9kZSA9PT0gcmVzdWx0RW5kTm9kZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnROb2RlOiByZXN1bHRTdGFydE5vZGUsXG4gICAgICAgIGVuZE5vZGU6IHJlc3VsdEVuZE5vZGVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBlbmRQYXJlbnQgb2YgZW5kTm9kZUFuZFBhcmVudHMucGFyZW50Tm9kZXMpIHtcbiAgICAgIGlmIChlbmRQYXJlbnQudHlwZSAhPT0gXCJQcm9ncmFtXCIgJiYgZW5kUGFyZW50LnR5cGUgIT09IFwiRmlsZVwiICYmIG9wdHMubG9jU3RhcnQoZW5kUGFyZW50KSA+PSBvcHRzLmxvY1N0YXJ0KHN0YXJ0Tm9kZUFuZFBhcmVudHMubm9kZSkpIHtcbiAgICAgICAgcmVzdWx0RW5kTm9kZSA9IGVuZFBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc3RhcnRQYXJlbnQgb2Ygc3RhcnROb2RlQW5kUGFyZW50cy5wYXJlbnROb2Rlcykge1xuICAgICAgaWYgKHN0YXJ0UGFyZW50LnR5cGUgIT09IFwiUHJvZ3JhbVwiICYmIHN0YXJ0UGFyZW50LnR5cGUgIT09IFwiRmlsZVwiICYmIG9wdHMubG9jRW5kKHN0YXJ0UGFyZW50KSA8PSBvcHRzLmxvY0VuZChlbmROb2RlQW5kUGFyZW50cy5ub2RlKSkge1xuICAgICAgICByZXN1bHRTdGFydE5vZGUgPSBzdGFydFBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdGFydE5vZGU6IHJlc3VsdFN0YXJ0Tm9kZSxcbiAgICAgIGVuZE5vZGU6IHJlc3VsdEVuZE5vZGVcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZE5vZGVBdE9mZnNldChub2RlLCBvZmZzZXQsIG9wdGlvbnMsIHByZWRpY2F0ZSwgcGFyZW50Tm9kZXMpIHtcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUgfHwgKCgpID0+IHRydWUpO1xuXG4gICAgcGFyZW50Tm9kZXMgPSBwYXJlbnROb2RlcyB8fCBbXTtcbiAgICBjb25zdCBzdGFydCA9IG9wdGlvbnMubG9jU3RhcnQobm9kZSwgb3B0aW9ucy5sb2NTdGFydCk7XG4gICAgY29uc3QgZW5kID0gb3B0aW9ucy5sb2NFbmQobm9kZSwgb3B0aW9ucy5sb2NFbmQpO1xuXG4gICAgaWYgKHN0YXJ0IDw9IG9mZnNldCAmJiBvZmZzZXQgPD0gZW5kKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBjb21tZW50cy5nZXRTb3J0ZWRDaGlsZE5vZGVzKG5vZGUsIG9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUmVzdWx0ID0gZmluZE5vZGVBdE9mZnNldChjaGlsZE5vZGUsIG9mZnNldCwgb3B0aW9ucywgcHJlZGljYXRlLCBbbm9kZV0uY29uY2F0KHBhcmVudE5vZGVzKSk7XG5cbiAgICAgICAgaWYgKGNoaWxkUmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkUmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHBhcmVudE5vZGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFNlZSBodHRwczovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLUEuNVxuXG5cbiAgZnVuY3Rpb24gaXNTb3VyY2VFbGVtZW50KG9wdHMsIG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBKUyBhbmQgSlMgbGlrZSB0byBhdm9pZCByZXBldGl0aW9uc1xuXG5cbiAgICBjb25zdCBqc1NvdXJjZUVsZW1lbnRzID0gW1wiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBcIkJsb2NrU3RhdGVtZW50XCIsIFwiQnJlYWtTdGF0ZW1lbnRcIiwgXCJDb250aW51ZVN0YXRlbWVudFwiLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIFwiRG9XaGlsZVN0YXRlbWVudFwiLCBcIkVtcHR5U3RhdGVtZW50XCIsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLCBcIkZvckluU3RhdGVtZW50XCIsIFwiRm9yU3RhdGVtZW50XCIsIFwiSWZTdGF0ZW1lbnRcIiwgXCJMYWJlbGVkU3RhdGVtZW50XCIsIFwiUmV0dXJuU3RhdGVtZW50XCIsIFwiU3dpdGNoU3RhdGVtZW50XCIsIFwiVGhyb3dTdGF0ZW1lbnRcIiwgXCJUcnlTdGF0ZW1lbnRcIiwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIFwiV2hpbGVTdGF0ZW1lbnRcIiwgXCJXaXRoU3RhdGVtZW50XCIsIFwiQ2xhc3NEZWNsYXJhdGlvblwiLCAvLyBFUyAyMDE1XG4gICAgXCJJbXBvcnREZWNsYXJhdGlvblwiLCAvLyBNb2R1bGVcbiAgICBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLCAvLyBNb2R1bGVcbiAgICBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiwgLy8gTW9kdWxlXG4gICAgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCAvLyBNb2R1bGVcbiAgICBcIlR5cGVBbGlhc1wiLCAvLyBGbG93XG4gICAgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCAvLyBGbG93LCBUeXBlU2NyaXB0XG4gICAgXCJUeXBlQWxpYXNEZWNsYXJhdGlvblwiLCAvLyBUeXBlU2NyaXB0XG4gICAgXCJFeHBvcnRBc3NpZ25tZW50XCIsIC8vIFR5cGVTY3JpcHRcbiAgICBcIkV4cG9ydERlY2xhcmF0aW9uXCIgLy8gVHlwZVNjcmlwdFxuICAgIF07XG4gICAgY29uc3QganNvblNvdXJjZUVsZW1lbnRzID0gW1wiT2JqZWN0RXhwcmVzc2lvblwiLCBcIkFycmF5RXhwcmVzc2lvblwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJvb2xlYW5MaXRlcmFsXCIsIFwiTnVsbExpdGVyYWxcIl07XG4gICAgY29uc3QgZ3JhcGhxbFNvdXJjZUVsZW1lbnRzID0gW1wiT3BlcmF0aW9uRGVmaW5pdGlvblwiLCBcIkZyYWdtZW50RGVmaW5pdGlvblwiLCBcIlZhcmlhYmxlRGVmaW5pdGlvblwiLCBcIlR5cGVFeHRlbnNpb25EZWZpbml0aW9uXCIsIFwiT2JqZWN0VHlwZURlZmluaXRpb25cIiwgXCJGaWVsZERlZmluaXRpb25cIiwgXCJEaXJlY3RpdmVEZWZpbml0aW9uXCIsIFwiRW51bVR5cGVEZWZpbml0aW9uXCIsIFwiRW51bVZhbHVlRGVmaW5pdGlvblwiLCBcIklucHV0VmFsdWVEZWZpbml0aW9uXCIsIFwiSW5wdXRPYmplY3RUeXBlRGVmaW5pdGlvblwiLCBcIlNjaGVtYURlZmluaXRpb25cIiwgXCJPcGVyYXRpb25UeXBlRGVmaW5pdGlvblwiLCBcIkludGVyZmFjZVR5cGVEZWZpbml0aW9uXCIsIFwiVW5pb25UeXBlRGVmaW5pdGlvblwiLCBcIlNjYWxhclR5cGVEZWZpbml0aW9uXCJdO1xuXG4gICAgc3dpdGNoIChvcHRzLnBhcnNlcikge1xuICAgICAgY2FzZSBcImZsb3dcIjpcbiAgICAgIGNhc2UgXCJiYWJlbFwiOlxuICAgICAgY2FzZSBcImJhYmVsLWZsb3dcIjpcbiAgICAgIGNhc2UgXCJiYWJlbC10c1wiOlxuICAgICAgY2FzZSBcInR5cGVzY3JpcHRcIjpcbiAgICAgICAgcmV0dXJuIGpzU291cmNlRWxlbWVudHMuaW5jbHVkZXMobm9kZS50eXBlKTtcblxuICAgICAgY2FzZSBcImpzb25cIjpcbiAgICAgICAgcmV0dXJuIGpzb25Tb3VyY2VFbGVtZW50cy5pbmNsdWRlcyhub2RlLnR5cGUpO1xuXG4gICAgICBjYXNlIFwiZ3JhcGhxbFwiOlxuICAgICAgICByZXR1cm4gZ3JhcGhxbFNvdXJjZUVsZW1lbnRzLmluY2x1ZGVzKG5vZGUua2luZCk7XG5cbiAgICAgIGNhc2UgXCJ2dWVcIjpcbiAgICAgICAgcmV0dXJuIG5vZGUudGFnICE9PSBcInJvb3RcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVSYW5nZSh0ZXh0LCBvcHRzLCBhc3QpIHtcbiAgICAvLyBDb250cmFjdCB0aGUgcmFuZ2Ugc28gdGhhdCBpdCBoYXMgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBhdCBpdHMgZW5kcG9pbnRzLlxuICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBjYW4gZm9ybWF0IGEgcmFuZ2UgdGhhdCBkb2Vzbid0IGVuZCBvbiBhIG5vZGUuXG4gICAgY29uc3QgcmFuZ2VTdHJpbmdPcmlnID0gdGV4dC5zbGljZShvcHRzLnJhbmdlU3RhcnQsIG9wdHMucmFuZ2VFbmQpO1xuICAgIGNvbnN0IHN0YXJ0Tm9uV2hpdGVzcGFjZSA9IE1hdGgubWF4KG9wdHMucmFuZ2VTdGFydCArIHJhbmdlU3RyaW5nT3JpZy5zZWFyY2goL1xcUy8pLCBvcHRzLnJhbmdlU3RhcnQpO1xuICAgIGxldCBlbmROb25XaGl0ZXNwYWNlO1xuXG4gICAgZm9yIChlbmROb25XaGl0ZXNwYWNlID0gb3B0cy5yYW5nZUVuZDsgZW5kTm9uV2hpdGVzcGFjZSA+IG9wdHMucmFuZ2VTdGFydDsgLS1lbmROb25XaGl0ZXNwYWNlKSB7XG4gICAgICBpZiAodGV4dFtlbmROb25XaGl0ZXNwYWNlIC0gMV0ubWF0Y2goL1xcUy8pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0Tm9kZUFuZFBhcmVudHMgPSBmaW5kTm9kZUF0T2Zmc2V0KGFzdCwgc3RhcnROb25XaGl0ZXNwYWNlLCBvcHRzLCBub2RlID0+IGlzU291cmNlRWxlbWVudChvcHRzLCBub2RlKSk7XG4gICAgY29uc3QgZW5kTm9kZUFuZFBhcmVudHMgPSBmaW5kTm9kZUF0T2Zmc2V0KGFzdCwgZW5kTm9uV2hpdGVzcGFjZSwgb3B0cywgbm9kZSA9PiBpc1NvdXJjZUVsZW1lbnQob3B0cywgbm9kZSkpO1xuXG4gICAgaWYgKCFzdGFydE5vZGVBbmRQYXJlbnRzIHx8ICFlbmROb2RlQW5kUGFyZW50cykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2VTdGFydDogMCxcbiAgICAgICAgcmFuZ2VFbmQ6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc2libGluZ0FuY2VzdG9ycyA9IGZpbmRTaWJsaW5nQW5jZXN0b3JzKHN0YXJ0Tm9kZUFuZFBhcmVudHMsIGVuZE5vZGVBbmRQYXJlbnRzLCBvcHRzKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydE5vZGUsXG4gICAgICBlbmROb2RlXG4gICAgfSA9IHNpYmxpbmdBbmNlc3RvcnM7XG4gICAgY29uc3QgcmFuZ2VTdGFydCA9IE1hdGgubWluKG9wdHMubG9jU3RhcnQoc3RhcnROb2RlLCBvcHRzLmxvY1N0YXJ0KSwgb3B0cy5sb2NTdGFydChlbmROb2RlLCBvcHRzLmxvY1N0YXJ0KSk7XG4gICAgY29uc3QgcmFuZ2VFbmQgPSBNYXRoLm1heChvcHRzLmxvY0VuZChzdGFydE5vZGUsIG9wdHMubG9jRW5kKSwgb3B0cy5sb2NFbmQoZW5kTm9kZSwgb3B0cy5sb2NFbmQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2VTdGFydCxcbiAgICAgIHJhbmdlRW5kXG4gICAgfTtcbiAgfVxuXG4gIHZhciByYW5nZVV0aWwgPSB7XG4gICAgY2FsY3VsYXRlUmFuZ2UsXG4gICAgZmluZE5vZGVBdE9mZnNldFxuICB9O1xuXG4gIHZhciBkaWZmID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShpbmRleF9lczYpO1xuXG4gIGNvbnN0IG5vcm1hbGl6ZU9wdGlvbnMkMSA9IG9wdGlvbnMkMS5ub3JtYWxpemU7XG4gIGNvbnN0IHtcbiAgICBndWVzc0VuZE9mTGluZTogZ3Vlc3NFbmRPZkxpbmUkMSxcbiAgICBjb252ZXJ0RW5kT2ZMaW5lVG9DaGFyczogY29udmVydEVuZE9mTGluZVRvQ2hhcnMkMlxuICB9ID0gZW5kT2ZMaW5lO1xuICBjb25zdCB7XG4gICAgcHJpbnRlcjoge1xuICAgICAgcHJpbnREb2NUb1N0cmluZzogcHJpbnREb2NUb1N0cmluZyQxXG4gICAgfSxcbiAgICBkZWJ1Zzoge1xuICAgICAgcHJpbnREb2NUb0RlYnVnXG4gICAgfVxuICB9ID0gZG9jdW1lbnQ7XG4gIGNvbnN0IEJPTSA9IFwiXFx1RkVGRlwiO1xuICBjb25zdCBDVVJTT1IgPSBTeW1ib2woXCJjdXJzb3JcIik7XG4gIGNvbnN0IFBMQUNFSE9MREVSUyA9IHtcbiAgICBjdXJzb3JPZmZzZXQ6IFwiPDw8UFJFVFRJRVJfQ1VSU09SPj4+XCIsXG4gICAgcmFuZ2VTdGFydDogXCI8PDxQUkVUVElFUl9SQU5HRV9TVEFSVD4+PlwiLFxuICAgIHJhbmdlRW5kOiBcIjw8PFBSRVRUSUVSX1JBTkdFX0VORD4+PlwiXG4gIH07XG5cbiAgZnVuY3Rpb24gZW5zdXJlQWxsQ29tbWVudHNQcmludGVkKGFzdENvbW1lbnRzKSB7XG4gICAgaWYgKCFhc3RDb21tZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0Q29tbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh1dGlsJDEuaXNOb2RlSWdub3JlQ29tbWVudChhc3RDb21tZW50c1tpXSkpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHByZXR0aWVyLWlnbm9yZSwgd2UncmUgbm90IHByaW50aW5nIHRoYXQgc3ViLXRyZWUgc28gd2VcbiAgICAgICAgLy8gZG9uJ3Qga25vdyBpZiB0aGUgY29tbWVudHMgd2FzIHByaW50ZWQgb3Igbm90LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXN0Q29tbWVudHMuZm9yRWFjaChjb21tZW50ID0+IHtcbiAgICAgIGlmICghY29tbWVudC5wcmludGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29tbWVudCBcIicgKyBjb21tZW50LnZhbHVlLnRyaW0oKSArICdcIiB3YXMgbm90IHByaW50ZWQuIFBsZWFzZSByZXBvcnQgdGhpcyBlcnJvciEnKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGNvbW1lbnQucHJpbnRlZDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dGFjaENvbW1lbnRzKHRleHQsIGFzdCwgb3B0cykge1xuICAgIGNvbnN0IGFzdENvbW1lbnRzID0gYXN0LmNvbW1lbnRzO1xuXG4gICAgaWYgKGFzdENvbW1lbnRzKSB7XG4gICAgICBkZWxldGUgYXN0LmNvbW1lbnRzO1xuICAgICAgY29tbWVudHMuYXR0YWNoKGFzdENvbW1lbnRzLCBhc3QsIHRleHQsIG9wdHMpO1xuICAgIH1cblxuICAgIGFzdC50b2tlbnMgPSBbXTtcbiAgICBvcHRzLm9yaWdpbmFsVGV4dCA9IG9wdHMucGFyc2VyID09PSBcInlhbWxcIiA/IHRleHQgOiB0ZXh0LnRyaW1FbmQoKTtcbiAgICByZXR1cm4gYXN0Q29tbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBjb3JlRm9ybWF0KHRleHQsIG9wdHMsIGFkZEFsaWdubWVudFNpemUpIHtcbiAgICBpZiAoIXRleHQgfHwgIXRleHQudHJpbSgpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0dGVkOiBcIlwiLFxuICAgICAgICBjdXJzb3JPZmZzZXQ6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgYWRkQWxpZ25tZW50U2l6ZSA9IGFkZEFsaWdubWVudFNpemUgfHwgMDtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZXIucGFyc2UodGV4dCwgb3B0cyk7XG4gICAgY29uc3Qge1xuICAgICAgYXN0XG4gICAgfSA9IHBhcnNlZDtcbiAgICB0ZXh0ID0gcGFyc2VkLnRleHQ7XG5cbiAgICBpZiAob3B0cy5jdXJzb3JPZmZzZXQgPj0gMCkge1xuICAgICAgY29uc3Qgbm9kZVJlc3VsdCA9IHJhbmdlVXRpbC5maW5kTm9kZUF0T2Zmc2V0KGFzdCwgb3B0cy5jdXJzb3JPZmZzZXQsIG9wdHMpO1xuXG4gICAgICBpZiAobm9kZVJlc3VsdCAmJiBub2RlUmVzdWx0Lm5vZGUpIHtcbiAgICAgICAgb3B0cy5jdXJzb3JOb2RlID0gbm9kZVJlc3VsdC5ub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFzdENvbW1lbnRzID0gYXR0YWNoQ29tbWVudHModGV4dCwgYXN0LCBvcHRzKTtcbiAgICBjb25zdCBkb2MgPSBhc3RUb0RvYyhhc3QsIG9wdHMsIGFkZEFsaWdubWVudFNpemUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHByaW50RG9jVG9TdHJpbmckMShkb2MsIG9wdHMpO1xuICAgIGVuc3VyZUFsbENvbW1lbnRzUHJpbnRlZChhc3RDb21tZW50cyk7IC8vIFJlbW92ZSBleHRyYSBsZWFkaW5nIGluZGVudGF0aW9uIGFzIHdlbGwgYXMgdGhlIGFkZGVkIGluZGVudGF0aW9uIGFmdGVyIGxhc3QgbmV3bGluZVxuXG4gICAgaWYgKGFkZEFsaWdubWVudFNpemUgPiAwKSB7XG4gICAgICBjb25zdCB0cmltbWVkID0gcmVzdWx0LmZvcm1hdHRlZC50cmltKCk7XG5cbiAgICAgIGlmIChyZXN1bHQuY3Vyc29yTm9kZVN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0LmN1cnNvck5vZGVTdGFydCAtPSByZXN1bHQuZm9ybWF0dGVkLmluZGV4T2YodHJpbW1lZCk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5mb3JtYXR0ZWQgPSB0cmltbWVkICsgY29udmVydEVuZE9mTGluZVRvQ2hhcnMkMihvcHRzLmVuZE9mTGluZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuY3Vyc29yT2Zmc2V0ID49IDApIHtcbiAgICAgIGxldCBvbGRDdXJzb3JOb2RlU3RhcnQ7XG4gICAgICBsZXQgb2xkQ3Vyc29yTm9kZVRleHQ7XG4gICAgICBsZXQgY3Vyc29yT2Zmc2V0UmVsYXRpdmVUb09sZEN1cnNvck5vZGU7XG4gICAgICBsZXQgbmV3Q3Vyc29yTm9kZVN0YXJ0O1xuICAgICAgbGV0IG5ld0N1cnNvck5vZGVUZXh0O1xuXG4gICAgICBpZiAob3B0cy5jdXJzb3JOb2RlICYmIHJlc3VsdC5jdXJzb3JOb2RlVGV4dCkge1xuICAgICAgICBvbGRDdXJzb3JOb2RlU3RhcnQgPSBvcHRzLmxvY1N0YXJ0KG9wdHMuY3Vyc29yTm9kZSk7XG4gICAgICAgIG9sZEN1cnNvck5vZGVUZXh0ID0gdGV4dC5zbGljZShvbGRDdXJzb3JOb2RlU3RhcnQsIG9wdHMubG9jRW5kKG9wdHMuY3Vyc29yTm9kZSkpO1xuICAgICAgICBjdXJzb3JPZmZzZXRSZWxhdGl2ZVRvT2xkQ3Vyc29yTm9kZSA9IG9wdHMuY3Vyc29yT2Zmc2V0IC0gb2xkQ3Vyc29yTm9kZVN0YXJ0O1xuICAgICAgICBuZXdDdXJzb3JOb2RlU3RhcnQgPSByZXN1bHQuY3Vyc29yTm9kZVN0YXJ0O1xuICAgICAgICBuZXdDdXJzb3JOb2RlVGV4dCA9IHJlc3VsdC5jdXJzb3JOb2RlVGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9sZEN1cnNvck5vZGVTdGFydCA9IDA7XG4gICAgICAgIG9sZEN1cnNvck5vZGVUZXh0ID0gdGV4dDtcbiAgICAgICAgY3Vyc29yT2Zmc2V0UmVsYXRpdmVUb09sZEN1cnNvck5vZGUgPSBvcHRzLmN1cnNvck9mZnNldDtcbiAgICAgICAgbmV3Q3Vyc29yTm9kZVN0YXJ0ID0gMDtcbiAgICAgICAgbmV3Q3Vyc29yTm9kZVRleHQgPSByZXN1bHQuZm9ybWF0dGVkO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkQ3Vyc29yTm9kZVRleHQgPT09IG5ld0N1cnNvck5vZGVUZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm9ybWF0dGVkOiByZXN1bHQuZm9ybWF0dGVkLFxuICAgICAgICAgIGN1cnNvck9mZnNldDogbmV3Q3Vyc29yTm9kZVN0YXJ0ICsgY3Vyc29yT2Zmc2V0UmVsYXRpdmVUb09sZEN1cnNvck5vZGVcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gZGlmZiBvbGQgYW5kIG5ldyBjdXJzb3Igbm9kZSB0ZXh0cywgd2l0aCBhIHNwZWNpYWwgY3Vyc29yXG4gICAgICAvLyBzeW1ib2wgaW5zZXJ0ZWQgdG8gZmluZCBvdXQgd2hlcmUgaXQgbW92ZXMgdG9cblxuXG4gICAgICBjb25zdCBvbGRDdXJzb3JOb2RlQ2hhckFycmF5ID0gb2xkQ3Vyc29yTm9kZVRleHQuc3BsaXQoXCJcIik7XG4gICAgICBvbGRDdXJzb3JOb2RlQ2hhckFycmF5LnNwbGljZShjdXJzb3JPZmZzZXRSZWxhdGl2ZVRvT2xkQ3Vyc29yTm9kZSwgMCwgQ1VSU09SKTtcbiAgICAgIGNvbnN0IG5ld0N1cnNvck5vZGVDaGFyQXJyYXkgPSBuZXdDdXJzb3JOb2RlVGV4dC5zcGxpdChcIlwiKTtcbiAgICAgIGNvbnN0IGN1cnNvck5vZGVEaWZmID0gZGlmZi5kaWZmQXJyYXlzKG9sZEN1cnNvck5vZGVDaGFyQXJyYXksIG5ld0N1cnNvck5vZGVDaGFyQXJyYXkpO1xuICAgICAgbGV0IGN1cnNvck9mZnNldCA9IG5ld0N1cnNvck5vZGVTdGFydDtcblxuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBjdXJzb3JOb2RlRGlmZikge1xuICAgICAgICBpZiAoZW50cnkucmVtb3ZlZCkge1xuICAgICAgICAgIGlmIChlbnRyeS52YWx1ZS5pbmNsdWRlcyhDVVJTT1IpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3Vyc29yT2Zmc2V0ICs9IGVudHJ5LmNvdW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdHRlZDogcmVzdWx0LmZvcm1hdHRlZCxcbiAgICAgICAgY3Vyc29yT2Zmc2V0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmb3JtYXR0ZWQ6IHJlc3VsdC5mb3JtYXR0ZWRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UmFuZ2UodGV4dCwgb3B0cykge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlci5wYXJzZSh0ZXh0LCBvcHRzKTtcbiAgICBjb25zdCB7XG4gICAgICBhc3RcbiAgICB9ID0gcGFyc2VkO1xuICAgIHRleHQgPSBwYXJzZWQudGV4dDtcbiAgICBjb25zdCByYW5nZSA9IHJhbmdlVXRpbC5jYWxjdWxhdGVSYW5nZSh0ZXh0LCBvcHRzLCBhc3QpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJhbmdlU3RhcnQsXG4gICAgICByYW5nZUVuZFxuICAgIH0gPSByYW5nZTtcbiAgICBjb25zdCByYW5nZVN0cmluZyA9IHRleHQuc2xpY2UocmFuZ2VTdGFydCwgcmFuZ2VFbmQpOyAvLyBUcnkgdG8gZXh0ZW5kIHRoZSByYW5nZSBiYWNrd2FyZHMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZS5cbiAgICAvLyBUaGlzIGlzIHNvIHdlIGNhbiBkZXRlY3QgaW5kZW50YXRpb24gY29ycmVjdGx5IGFuZCByZXN0b3JlIGl0LlxuICAgIC8vIFVzZSBgTWF0aC5taW5gIHNpbmNlIGBsYXN0SW5kZXhPZmAgcmV0dXJucyAwIHdoZW4gYHJhbmdlU3RhcnRgIGlzIDBcblxuICAgIGNvbnN0IHJhbmdlU3RhcnQyID0gTWF0aC5taW4ocmFuZ2VTdGFydCwgdGV4dC5sYXN0SW5kZXhPZihcIlxcblwiLCByYW5nZVN0YXJ0KSArIDEpO1xuICAgIGNvbnN0IGluZGVudFN0cmluZyA9IHRleHQuc2xpY2UocmFuZ2VTdGFydDIsIHJhbmdlU3RhcnQpO1xuICAgIGNvbnN0IGFsaWdubWVudFNpemUgPSB1dGlsJDEuZ2V0QWxpZ25tZW50U2l6ZShpbmRlbnRTdHJpbmcsIG9wdHMudGFiV2lkdGgpO1xuICAgIGNvbnN0IHJhbmdlUmVzdWx0ID0gY29yZUZvcm1hdChyYW5nZVN0cmluZywgT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgcmFuZ2VTdGFydDogMCxcbiAgICAgIHJhbmdlRW5kOiBJbmZpbml0eSxcbiAgICAgIC8vIHRyYWNrIHRoZSBjdXJzb3Igb2Zmc2V0IG9ubHkgaWYgaXQncyB3aXRoaW4gb3VyIHJhbmdlXG4gICAgICBjdXJzb3JPZmZzZXQ6IG9wdHMuY3Vyc29yT2Zmc2V0ID49IHJhbmdlU3RhcnQgJiYgb3B0cy5jdXJzb3JPZmZzZXQgPCByYW5nZUVuZCA/IG9wdHMuY3Vyc29yT2Zmc2V0IC0gcmFuZ2VTdGFydCA6IC0xXG4gICAgfSksIGFsaWdubWVudFNpemUpOyAvLyBTaW5jZSB0aGUgcmFuZ2UgY29udHJhY3RzIHRvIGF2b2lkIHRyYWlsaW5nIHdoaXRlc3BhY2UsXG4gICAgLy8gd2UgbmVlZCB0byByZW1vdmUgdGhlIG5ld2xpbmUgdGhhdCB3YXMgaW5zZXJ0ZWQgYnkgdGhlIGBmb3JtYXRgIGNhbGwuXG5cbiAgICBjb25zdCByYW5nZVRyaW1tZWQgPSByYW5nZVJlc3VsdC5mb3JtYXR0ZWQudHJpbUVuZCgpO1xuICAgIGNvbnN0IHJhbmdlTGVmdCA9IHRleHQuc2xpY2UoMCwgcmFuZ2VTdGFydCk7XG4gICAgY29uc3QgcmFuZ2VSaWdodCA9IHRleHQuc2xpY2UocmFuZ2VFbmQpO1xuICAgIGxldCB7XG4gICAgICBjdXJzb3JPZmZzZXRcbiAgICB9ID0gb3B0cztcblxuICAgIGlmIChvcHRzLmN1cnNvck9mZnNldCA+PSByYW5nZUVuZCkge1xuICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjdXJzb3Igd2FzIHBhc3QgdGhlIGVuZCBvZiB0aGUgcmFuZ2VcbiAgICAgIGN1cnNvck9mZnNldCA9IG9wdHMuY3Vyc29yT2Zmc2V0IC0gcmFuZ2VFbmQgKyAocmFuZ2VTdGFydCArIHJhbmdlVHJpbW1lZC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAocmFuZ2VSZXN1bHQuY3Vyc29yT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgY3Vyc29yIHdhcyBpbiB0aGUgcmFuZ2VcbiAgICAgIGN1cnNvck9mZnNldCA9IHJhbmdlUmVzdWx0LmN1cnNvck9mZnNldCArIHJhbmdlU3RhcnQ7XG4gICAgfSAvLyBrZWVwIHRoZSBjdXJzb3IgYXMgaXQgd2FzIGlmIGl0IHdhcyBiZWZvcmUgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZVxuXG5cbiAgICBsZXQgZm9ybWF0dGVkO1xuXG4gICAgaWYgKG9wdHMuZW5kT2ZMaW5lID09PSBcImxmXCIpIHtcbiAgICAgIGZvcm1hdHRlZCA9IHJhbmdlTGVmdCArIHJhbmdlVHJpbW1lZCArIHJhbmdlUmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVvbCA9IGNvbnZlcnRFbmRPZkxpbmVUb0NoYXJzJDIob3B0cy5lbmRPZkxpbmUpO1xuXG4gICAgICBpZiAoY3Vyc29yT2Zmc2V0ID49IDApIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbcmFuZ2VMZWZ0LCByYW5nZVRyaW1tZWQsIHJhbmdlUmlnaHRdO1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICAgICAgbGV0IHBhcnRPZmZzZXQgPSBjdXJzb3JPZmZzZXQ7XG5cbiAgICAgICAgd2hpbGUgKHBhcnRJbmRleCA8IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1twYXJ0SW5kZXhdO1xuXG4gICAgICAgICAgaWYgKHBhcnRPZmZzZXQgPCBwYXJ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcGFydHNbcGFydEluZGV4XSA9IHBhcnRzW3BhcnRJbmRleF0uc2xpY2UoMCwgcGFydE9mZnNldCkgKyBQTEFDRUhPTERFUlMuY3Vyc29yT2Zmc2V0ICsgcGFydHNbcGFydEluZGV4XS5zbGljZShwYXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgIHBhcnRPZmZzZXQgLT0gcGFydC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBbbmV3UmFuZ2VMZWZ0LCBuZXdSYW5nZVRyaW1tZWQsIG5ld1JhbmdlUmlnaHRdID0gcGFydHM7XG4gICAgICAgIGZvcm1hdHRlZCA9IChuZXdSYW5nZUxlZnQucmVwbGFjZSgvXFxuL2csIGVvbCkgKyBuZXdSYW5nZVRyaW1tZWQgKyBuZXdSYW5nZVJpZ2h0LnJlcGxhY2UoL1xcbi9nLCBlb2wpKS5yZXBsYWNlKFBMQUNFSE9MREVSUy5jdXJzb3JPZmZzZXQsIChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGN1cnNvck9mZnNldCA9IGluZGV4O1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdHRlZCA9IHJhbmdlTGVmdC5yZXBsYWNlKC9cXG4vZywgZW9sKSArIHJhbmdlVHJpbW1lZCArIHJhbmdlUmlnaHQucmVwbGFjZSgvXFxuL2csIGVvbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdHRlZCxcbiAgICAgIGN1cnNvck9mZnNldFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQodGV4dCwgb3B0cykge1xuICAgIGNvbnN0IHNlbGVjdGVkUGFyc2VyID0gcGFyc2VyLnJlc29sdmVQYXJzZXIob3B0cyk7XG4gICAgY29uc3QgaGFzUHJhZ21hID0gIXNlbGVjdGVkUGFyc2VyLmhhc1ByYWdtYSB8fCBzZWxlY3RlZFBhcnNlci5oYXNQcmFnbWEodGV4dCk7XG5cbiAgICBpZiAob3B0cy5yZXF1aXJlUHJhZ21hICYmICFoYXNQcmFnbWEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdHRlZDogdGV4dFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5lbmRPZkxpbmUgPT09IFwiYXV0b1wiKSB7XG4gICAgICBvcHRzLmVuZE9mTGluZSA9IGd1ZXNzRW5kT2ZMaW5lJDEodGV4dCk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzQ3Vyc29yID0gb3B0cy5jdXJzb3JPZmZzZXQgPj0gMDtcbiAgICBjb25zdCBoYXNSYW5nZVN0YXJ0ID0gb3B0cy5yYW5nZVN0YXJ0ID4gMDtcbiAgICBjb25zdCBoYXNSYW5nZUVuZCA9IG9wdHMucmFuZ2VFbmQgPCB0ZXh0Lmxlbmd0aDsgLy8gZ2V0IHJpZCBvZiBDUi9DUkxGIHBhcnNpbmdcblxuICAgIGlmICh0ZXh0LmluY2x1ZGVzKFwiXFxyXCIpKSB7XG4gICAgICBjb25zdCBvZmZzZXRLZXlzID0gW2hhc0N1cnNvciAmJiBcImN1cnNvck9mZnNldFwiLCBoYXNSYW5nZVN0YXJ0ICYmIFwicmFuZ2VTdGFydFwiLCBoYXNSYW5nZUVuZCAmJiBcInJhbmdlRW5kXCJdLmZpbHRlcihCb29sZWFuKS5zb3J0KChhS2V5LCBiS2V5KSA9PiBvcHRzW2FLZXldIC0gb3B0c1tiS2V5XSk7XG5cbiAgICAgIGZvciAobGV0IGkgPSBvZmZzZXRLZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG9mZnNldEtleXNbaV07XG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIG9wdHNba2V5XSkgKyBQTEFDRUhPTERFUlNba2V5XSArIHRleHQuc2xpY2Uob3B0c1trZXldKTtcbiAgICAgIH1cblxuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvZmZzZXRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG9mZnNldEtleXNbaV07XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoUExBQ0VIT0xERVJTW2tleV0sIChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgIG9wdHNba2V5XSA9IGluZGV4O1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoYXNVbmljb2RlQk9NID0gdGV4dC5jaGFyQXQoMCkgPT09IEJPTTtcblxuICAgIGlmIChoYXNVbmljb2RlQk9NKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcblxuICAgICAgaWYgKGhhc0N1cnNvcikge1xuICAgICAgICBvcHRzLmN1cnNvck9mZnNldCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzUmFuZ2VTdGFydCkge1xuICAgICAgICBvcHRzLnJhbmdlU3RhcnQrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1JhbmdlRW5kKSB7XG4gICAgICAgIG9wdHMucmFuZ2VFbmQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhc0N1cnNvcikge1xuICAgICAgb3B0cy5jdXJzb3JPZmZzZXQgPSAtMTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yYW5nZVN0YXJ0IDwgMCkge1xuICAgICAgb3B0cy5yYW5nZVN0YXJ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yYW5nZUVuZCA+IHRleHQubGVuZ3RoKSB7XG4gICAgICBvcHRzLnJhbmdlRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaGFzUmFuZ2VTdGFydCB8fCBoYXNSYW5nZUVuZCA/IGZvcm1hdFJhbmdlKHRleHQsIG9wdHMpIDogY29yZUZvcm1hdChvcHRzLmluc2VydFByYWdtYSAmJiBvcHRzLnByaW50ZXIuaW5zZXJ0UHJhZ21hICYmICFoYXNQcmFnbWEgPyBvcHRzLnByaW50ZXIuaW5zZXJ0UHJhZ21hKHRleHQpIDogdGV4dCwgb3B0cyk7XG5cbiAgICBpZiAoaGFzVW5pY29kZUJPTSkge1xuICAgICAgcmVzdWx0LmZvcm1hdHRlZCA9IEJPTSArIHJlc3VsdC5mb3JtYXR0ZWQ7XG5cbiAgICAgIGlmIChoYXNDdXJzb3IpIHtcbiAgICAgICAgcmVzdWx0LmN1cnNvck9mZnNldCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgY29yZSA9IHtcbiAgICBmb3JtYXRXaXRoQ3Vyc29yKHRleHQsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBub3JtYWxpemVPcHRpb25zJDEob3B0cyk7XG4gICAgICByZXR1cm4gZm9ybWF0KHRleHQsIG9wdHMpO1xuICAgIH0sXG5cbiAgICBwYXJzZSh0ZXh0LCBvcHRzLCBtYXNzYWdlKSB7XG4gICAgICBvcHRzID0gbm9ybWFsaXplT3B0aW9ucyQxKG9wdHMpO1xuXG4gICAgICBpZiAodGV4dC5pbmNsdWRlcyhcIlxcclwiKSkge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZXIucGFyc2UodGV4dCwgb3B0cyk7XG5cbiAgICAgIGlmIChtYXNzYWdlKSB7XG4gICAgICAgIHBhcnNlZC5hc3QgPSBtYXNzYWdlQXN0KHBhcnNlZC5hc3QsIG9wdHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH0sXG5cbiAgICBmb3JtYXRBU1QoYXN0LCBvcHRzKSB7XG4gICAgICBvcHRzID0gbm9ybWFsaXplT3B0aW9ucyQxKG9wdHMpO1xuICAgICAgY29uc3QgZG9jID0gYXN0VG9Eb2MoYXN0LCBvcHRzKTtcbiAgICAgIHJldHVybiBwcmludERvY1RvU3RyaW5nJDEoZG9jLCBvcHRzKTtcbiAgICB9LFxuXG4gICAgLy8gRG9lc24ndCBoYW5kbGUgc2hlYmFuZyBmb3Igbm93XG4gICAgZm9ybWF0RG9jKGRvYywgb3B0cykge1xuICAgICAgY29uc3QgZGVidWcgPSBwcmludERvY1RvRGVidWcoZG9jKTtcbiAgICAgIG9wdHMgPSBub3JtYWxpemVPcHRpb25zJDEoT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgICBwYXJzZXI6IFwiYmFiZWxcIlxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGZvcm1hdChkZWJ1Zywgb3B0cykuZm9ybWF0dGVkO1xuICAgIH0sXG5cbiAgICBwcmludFRvRG9jKHRleHQsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBub3JtYWxpemVPcHRpb25zJDEob3B0cyk7XG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZXIucGFyc2UodGV4dCwgb3B0cyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFzdFxuICAgICAgfSA9IHBhcnNlZDtcbiAgICAgIHRleHQgPSBwYXJzZWQudGV4dDtcbiAgICAgIGF0dGFjaENvbW1lbnRzKHRleHQsIGFzdCwgb3B0cyk7XG4gICAgICByZXR1cm4gYXN0VG9Eb2MoYXN0LCBvcHRzKTtcbiAgICB9LFxuXG4gICAgcHJpbnREb2NUb1N0cmluZyhkb2MsIG9wdHMpIHtcbiAgICAgIHJldHVybiBwcmludERvY1RvU3RyaW5nJDEoZG9jLCBub3JtYWxpemVPcHRpb25zJDEob3B0cykpO1xuICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIGNsZWFuKGFzdCwgbmV3T2JqLCBwYXJlbnQpIHtcbiAgICBbXCJyYXdcIiwgLy8gZnJvbnQtbWF0dGVyXG4gICAgXCJyYXdzXCIsIFwic291cmNlSW5kZXhcIiwgXCJzb3VyY2VcIiwgXCJiZWZvcmVcIiwgXCJhZnRlclwiLCBcInRyYWlsaW5nQ29tbWFcIl0uZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpbbmFtZV07XG4gICAgfSk7XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwieWFtbFwiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLnZhbHVlO1xuICAgIH0gLy8gLS1pbnNlcnQtcHJhZ21hXG5cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJjc3MtY29tbWVudFwiICYmIHBhcmVudC50eXBlID09PSBcImNzcy1yb290XCIgJiYgcGFyZW50Lm5vZGVzLmxlbmd0aCAhPT0gMCAmJiAoIC8vIGZpcnN0IG5vbi1mcm9udC1tYXR0ZXIgY29tbWVudFxuICAgIHBhcmVudC5ub2Rlc1swXSA9PT0gYXN0IHx8IChwYXJlbnQubm9kZXNbMF0udHlwZSA9PT0gXCJ5YW1sXCIgfHwgcGFyZW50Lm5vZGVzWzBdLnR5cGUgPT09IFwidG9tbFwiKSAmJiBwYXJlbnQubm9kZXNbMV0gPT09IGFzdCkpIHtcbiAgICAgIC8qKlxuICAgICAgICogc29tZXRoaW5nXG4gICAgICAgKlxuICAgICAgICogQGZvcm1hdFxuICAgICAgICovXG4gICAgICBkZWxldGUgbmV3T2JqLnRleHQ7IC8vIHN0YW5kYWxvbmUgcHJhZ21hXG5cbiAgICAgIGlmICgvXlxcKlxccypAKGZvcm1hdHxwcmV0dGllcilcXHMqJC8udGVzdChhc3QudGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIm1lZGlhLXF1ZXJ5XCIgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEtcXVlcnktbGlzdFwiIHx8IGFzdC50eXBlID09PSBcIm1lZGlhLWZlYXR1cmUtZXhwcmVzc2lvblwiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJjc3MtcnVsZVwiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLnBhcmFtcztcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItY29tYmluYXRvclwiKSB7XG4gICAgICBuZXdPYmoudmFsdWUgPSBuZXdPYmoudmFsdWUucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIm1lZGlhLWZlYXR1cmVcIikge1xuICAgICAgbmV3T2JqLnZhbHVlID0gbmV3T2JqLnZhbHVlLnJlcGxhY2UoLyAvZywgXCJcIik7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiAoYXN0LmlzQ29sb3IgJiYgYXN0LmlzSGV4IHx8IFtcImluaXRpYWxcIiwgXCJpbmhlcml0XCIsIFwidW5zZXRcIiwgXCJyZXZlcnRcIl0uaW5jbHVkZXMobmV3T2JqLnZhbHVlLnJlcGxhY2UoKS50b0xvd2VyQ2FzZSgpKSkgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEtZmVhdHVyZVwiIHx8IGFzdC50eXBlID09PSBcInNlbGVjdG9yLXJvb3QtaW52YWxpZFwiIHx8IGFzdC50eXBlID09PSBcInNlbGVjdG9yLXBzZXVkb1wiKSB7XG4gICAgICBuZXdPYmoudmFsdWUgPSBuZXdPYmoudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiY3NzLWRlY2xcIikge1xuICAgICAgbmV3T2JqLnByb3AgPSBuZXdPYmoucHJvcC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJjc3MtYXRydWxlXCIgfHwgYXN0LnR5cGUgPT09IFwiY3NzLWltcG9ydFwiKSB7XG4gICAgICBuZXdPYmoubmFtZSA9IG5ld09iai5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcInZhbHVlLW51bWJlclwiKSB7XG4gICAgICBuZXdPYmoudW5pdCA9IG5ld09iai51bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKChhc3QudHlwZSA9PT0gXCJtZWRpYS1mZWF0dXJlXCIgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEta2V5d29yZFwiIHx8IGFzdC50eXBlID09PSBcIm1lZGlhLXR5cGVcIiB8fCBhc3QudHlwZSA9PT0gXCJtZWRpYS11bmtub3duXCIgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEtdXJsXCIgfHwgYXN0LnR5cGUgPT09IFwibWVkaWEtdmFsdWVcIiB8fCBhc3QudHlwZSA9PT0gXCJzZWxlY3Rvci1hdHRyaWJ1dGVcIiB8fCBhc3QudHlwZSA9PT0gXCJzZWxlY3Rvci1zdHJpbmdcIiB8fCBhc3QudHlwZSA9PT0gXCJzZWxlY3Rvci1jbGFzc1wiIHx8IGFzdC50eXBlID09PSBcInNlbGVjdG9yLWNvbWJpbmF0b3JcIiB8fCBhc3QudHlwZSA9PT0gXCJ2YWx1ZS1zdHJpbmdcIikgJiYgbmV3T2JqLnZhbHVlKSB7XG4gICAgICBuZXdPYmoudmFsdWUgPSBjbGVhbkNTU1N0cmluZ3MobmV3T2JqLnZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItYXR0cmlidXRlXCIpIHtcbiAgICAgIG5ld09iai5hdHRyaWJ1dGUgPSBuZXdPYmouYXR0cmlidXRlLnRyaW0oKTtcblxuICAgICAgaWYgKG5ld09iai5uYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPYmoubmFtZXNwYWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgbmV3T2JqLm5hbWVzcGFjZSA9IG5ld09iai5uYW1lc3BhY2UudHJpbSgpO1xuXG4gICAgICAgICAgaWYgKG5ld09iai5uYW1lc3BhY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBuZXdPYmoubmFtZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld09iai52YWx1ZSkge1xuICAgICAgICBuZXdPYmoudmFsdWUgPSBuZXdPYmoudmFsdWUudHJpbSgpLnJlcGxhY2UoL15bJ1wiXXxbJ1wiXSQvZywgXCJcIik7XG4gICAgICAgIGRlbGV0ZSBuZXdPYmoucXVvdGVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoYXN0LnR5cGUgPT09IFwibWVkaWEtdmFsdWVcIiB8fCBhc3QudHlwZSA9PT0gXCJtZWRpYS10eXBlXCIgfHwgYXN0LnR5cGUgPT09IFwidmFsdWUtbnVtYmVyXCIgfHwgYXN0LnR5cGUgPT09IFwic2VsZWN0b3Itcm9vdC1pbnZhbGlkXCIgfHwgYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItY2xhc3NcIiB8fCBhc3QudHlwZSA9PT0gXCJzZWxlY3Rvci1jb21iaW5hdG9yXCIgfHwgYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItdGFnXCIpICYmIG5ld09iai52YWx1ZSkge1xuICAgICAgbmV3T2JqLnZhbHVlID0gbmV3T2JqLnZhbHVlLnJlcGxhY2UoLyhbXFxkLmVFKy1dKykoW2EtekEtWl0qKS9nLCAobWF0Y2gsIG51bVN0ciwgdW5pdCkgPT4ge1xuICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIobnVtU3RyKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKG51bSkgPyBtYXRjaCA6IG51bSArIHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJzZWxlY3Rvci10YWdcIikge1xuICAgICAgY29uc3QgbG93ZXJjYXNlZFZhbHVlID0gYXN0LnZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChbXCJmcm9tXCIsIFwidG9cIl0uaW5jbHVkZXMobG93ZXJjYXNlZFZhbHVlKSkge1xuICAgICAgICBuZXdPYmoudmFsdWUgPSBsb3dlcmNhc2VkVmFsdWU7XG4gICAgICB9XG4gICAgfSAvLyBXb3JrYXJvdW5kIHdoZW4gYHBvc3Rjc3MtdmFsdWVzLXBhcnNlcmAgcGFyc2UgYG5vdGAsIGBhbmRgIG9yIGBvcmAga2V5d29yZHMgYXMgYHZhbHVlLWZ1bmNgXG5cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJjc3MtYXRydWxlXCIgJiYgYXN0Lm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJzdXBwb3J0c1wiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLnZhbHVlO1xuICAgIH0gLy8gV29ya2Fyb3VuZCBmb3IgU0NTUyBuZXN0ZWQgcHJvcGVydGllc1xuXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwic2VsZWN0b3ItdW5rbm93blwiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFuQ1NTU3RyaW5ncyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8nL2csICdcIicpLnJlcGxhY2UoL1xcXFwoW15hLWZBLUZcXGRdKS9nLCBcIiQxXCIpO1xuICB9XG5cbiAgdmFyIGNsZWFuXzEgPSBjbGVhbjtcblxuICBjb25zdCB7XG4gICAgYnVpbGRlcnM6IHtcbiAgICAgIGhhcmRsaW5lOiBoYXJkbGluZSQzLFxuICAgICAgbGl0ZXJhbGxpbmU6IGxpdGVyYWxsaW5lJDEsXG4gICAgICBjb25jYXQ6IGNvbmNhdCQ0LFxuICAgICAgbWFya0FzUm9vdDogbWFya0FzUm9vdCQxXG4gICAgfSxcbiAgICB1dGlsczoge1xuICAgICAgbWFwRG9jOiBtYXBEb2MkMVxuICAgIH1cbiAgfSA9IGRvY3VtZW50O1xuXG4gIGZ1bmN0aW9uIGVtYmVkKHBhdGgsIHByaW50LCB0ZXh0VG9Eb2NcbiAgLyosIG9wdGlvbnMgKi9cbiAgKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwieWFtbFwiKSB7XG4gICAgICByZXR1cm4gbWFya0FzUm9vdCQxKGNvbmNhdCQ0KFtcIi0tLVwiLCBoYXJkbGluZSQzLCBub2RlLnZhbHVlLnRyaW0oKSA/IHJlcGxhY2VOZXdsaW5lc1dpdGhMaXRlcmFsbGluZXModGV4dFRvRG9jKG5vZGUudmFsdWUsIHtcbiAgICAgICAgcGFyc2VyOiBcInlhbWxcIlxuICAgICAgfSkpIDogXCJcIiwgXCItLS1cIiwgaGFyZGxpbmUkM10pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VOZXdsaW5lc1dpdGhMaXRlcmFsbGluZXMoZG9jKSB7XG4gICAgICByZXR1cm4gbWFwRG9jJDEoZG9jLCBjdXJyZW50RG9jID0+IHR5cGVvZiBjdXJyZW50RG9jID09PSBcInN0cmluZ1wiICYmIGN1cnJlbnREb2MuaW5jbHVkZXMoXCJcXG5cIikgPyBjb25jYXQkNChjdXJyZW50RG9jLnNwbGl0KC8oXFxuKS9nKS5tYXAoKHYsIGkpID0+IGkgJSAyID09PSAwID8gdiA6IGxpdGVyYWxsaW5lJDEpKSA6IGN1cnJlbnREb2MpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbWJlZF8xID0gZW1iZWQ7XG5cbiAgY29uc3QgZGV0ZWN0TmV3bGluZSA9IHN0cmluZyA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld2xpbmVzID0gc3RyaW5nLm1hdGNoKC8oPzpcXHI/XFxuKS9nKSB8fCBbXTtcblxuICAgIGlmIChuZXdsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjcmxmID0gbmV3bGluZXMuZmlsdGVyKG5ld2xpbmUgPT4gbmV3bGluZSA9PT0gJ1xcclxcbicpLmxlbmd0aDtcbiAgICBjb25zdCBsZiA9IG5ld2xpbmVzLmxlbmd0aCAtIGNybGY7XG4gICAgcmV0dXJuIGNybGYgPiBsZiA/ICdcXHJcXG4nIDogJ1xcbic7XG4gIH07XG5cbiAgdmFyIGRldGVjdE5ld2xpbmVfMSA9IGRldGVjdE5ld2xpbmU7XG5cbiAgdmFyIGdyYWNlZnVsID0gc3RyaW5nID0+IHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICYmIGRldGVjdE5ld2xpbmUoc3RyaW5nKSB8fCAnXFxuJztcbiAgZGV0ZWN0TmV3bGluZV8xLmdyYWNlZnVsID0gZ3JhY2VmdWw7XG5cbiAgdmFyIGJ1aWxkID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcbiAgICBleHBvcnRzLmV4dHJhY3QgPSBleHRyYWN0O1xuICAgIGV4cG9ydHMuc3RyaXAgPSBzdHJpcDtcbiAgICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gICAgZXhwb3J0cy5wYXJzZVdpdGhDb21tZW50cyA9IHBhcnNlV2l0aENvbW1lbnRzO1xuICAgIGV4cG9ydHMucHJpbnQgPSBwcmludDtcblxuICAgIGZ1bmN0aW9uIF9vcygpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSByZXF1aXJlJCQwJDE7XG5cbiAgICAgIF9vcyA9IGZ1bmN0aW9uIF9vcygpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZGV0ZWN0TmV3bGluZSgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGRldGVjdE5ld2xpbmVfMSk7XG5cbiAgICAgIF9kZXRlY3ROZXdsaW5lID0gZnVuY3Rpb24gX2RldGVjdE5ld2xpbmUoKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICAgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAgICovXG5cblxuICAgIGNvbnN0IGNvbW1lbnRFbmRSZSA9IC9cXCpcXC8kLztcbiAgICBjb25zdCBjb21tZW50U3RhcnRSZSA9IC9eXFwvXFwqXFwqLztcbiAgICBjb25zdCBkb2NibG9ja1JlID0gL15cXHMqKFxcL1xcKlxcKj8oLnxcXHI/XFxuKSo/XFwqXFwvKS87XG4gICAgY29uc3QgbGluZUNvbW1lbnRSZSA9IC8oXnxcXHMrKVxcL1xcLyhbXlxcclxcbl0qKS9nO1xuICAgIGNvbnN0IGx0cmltTmV3bGluZVJlID0gL14oXFxyP1xcbikrLztcbiAgICBjb25zdCBtdWx0aWxpbmVSZSA9IC8oPzpefFxccj9cXG4pICooQFteXFxyXFxuXSo/KSAqXFxyP1xcbiAqKD8hW15AXFxyXFxuXSpcXC9cXC9bXl0qKShbXkBcXHJcXG5cXHNdW15AXFxyXFxuXSs/KSAqXFxyP1xcbi9nO1xuICAgIGNvbnN0IHByb3BlcnR5UmUgPSAvKD86XnxcXHI/XFxuKSAqQChcXFMrKSAqKFteXFxyXFxuXSopL2c7XG4gICAgY29uc3Qgc3RyaW5nU3RhcnRSZSA9IC8oXFxyP1xcbnxeKSAqXFwqID8vZztcblxuICAgIGZ1bmN0aW9uIGV4dHJhY3QoY29udGVudHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gY29udGVudHMubWF0Y2goZG9jYmxvY2tSZSk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXS50cmltTGVmdCgpIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaXAoY29udGVudHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gY29udGVudHMubWF0Y2goZG9jYmxvY2tSZSk7XG4gICAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMF0gPyBjb250ZW50cy5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKSA6IGNvbnRlbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGRvY2Jsb2NrKSB7XG4gICAgICByZXR1cm4gcGFyc2VXaXRoQ29tbWVudHMoZG9jYmxvY2spLnByYWdtYXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VXaXRoQ29tbWVudHMoZG9jYmxvY2spIHtcbiAgICAgIGNvbnN0IGxpbmUgPSAoMCwgX2RldGVjdE5ld2xpbmUoKS5kZWZhdWx0KShkb2NibG9jaykgfHwgX29zKCkuRU9MO1xuXG4gICAgICBkb2NibG9jayA9IGRvY2Jsb2NrLnJlcGxhY2UoY29tbWVudFN0YXJ0UmUsICcnKS5yZXBsYWNlKGNvbW1lbnRFbmRSZSwgJycpLnJlcGxhY2Uoc3RyaW5nU3RhcnRSZSwgJyQxJyk7IC8vIE5vcm1hbGl6ZSBtdWx0aS1saW5lIGRpcmVjdGl2ZXNcblxuICAgICAgbGV0IHByZXYgPSAnJztcblxuICAgICAgd2hpbGUgKHByZXYgIT09IGRvY2Jsb2NrKSB7XG4gICAgICAgIHByZXYgPSBkb2NibG9jaztcbiAgICAgICAgZG9jYmxvY2sgPSBkb2NibG9jay5yZXBsYWNlKG11bHRpbGluZVJlLCBcIlwiLmNvbmNhdChsaW5lLCBcIiQxICQyXCIpLmNvbmNhdChsaW5lKSk7XG4gICAgICB9XG5cbiAgICAgIGRvY2Jsb2NrID0gZG9jYmxvY2sucmVwbGFjZShsdHJpbU5ld2xpbmVSZSwgJycpLnRyaW1SaWdodCgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGNvbnN0IGNvbW1lbnRzID0gZG9jYmxvY2sucmVwbGFjZShwcm9wZXJ0eVJlLCAnJykucmVwbGFjZShsdHJpbU5ld2xpbmVSZSwgJycpLnRyaW1SaWdodCgpO1xuICAgICAgbGV0IG1hdGNoO1xuXG4gICAgICB3aGlsZSAobWF0Y2ggPSBwcm9wZXJ0eVJlLmV4ZWMoZG9jYmxvY2spKSB7XG4gICAgICAgIC8vIHN0cmlwIGxpbmVjb21tZW50cyBmcm9tIHByYWdtYXNcbiAgICAgICAgY29uc3QgbmV4dFByYWdtYSA9IG1hdGNoWzJdLnJlcGxhY2UobGluZUNvbW1lbnRSZSwgJycpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W21hdGNoWzFdXSA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShyZXN1bHRbbWF0Y2hbMV1dKSkge1xuICAgICAgICAgIHJlc3VsdFttYXRjaFsxXV0gPSBbXS5jb25jYXQocmVzdWx0W21hdGNoWzFdXSwgbmV4dFByYWdtYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W21hdGNoWzFdXSA9IG5leHRQcmFnbWE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWVudHMsXG4gICAgICAgIHByYWdtYXM6IHJlc3VsdFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludCh7XG4gICAgICBjb21tZW50cyA9ICcnLFxuICAgICAgcHJhZ21hcyA9IHt9XG4gICAgfSkge1xuICAgICAgY29uc3QgbGluZSA9ICgwLCBfZGV0ZWN0TmV3bGluZSgpLmRlZmF1bHQpKGNvbW1lbnRzKSB8fCBfb3MoKS5FT0w7XG5cbiAgICAgIGNvbnN0IGhlYWQgPSAnLyoqJztcbiAgICAgIGNvbnN0IHN0YXJ0ID0gJyAqJztcbiAgICAgIGNvbnN0IHRhaWwgPSAnICovJztcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcmFnbWFzKTtcbiAgICAgIGNvbnN0IHByaW50ZWRPYmplY3QgPSBrZXlzLm1hcChrZXkgPT4gcHJpbnRLZXlWYWx1ZXMoa2V5LCBwcmFnbWFzW2tleV0pKS5yZWR1Y2UoKGFyciwgbmV4dCkgPT4gYXJyLmNvbmNhdChuZXh0KSwgW10pLm1hcChrZXlWYWx1ZSA9PiBzdGFydCArICcgJyArIGtleVZhbHVlICsgbGluZSkuam9pbignJyk7XG5cbiAgICAgIGlmICghY29tbWVudHMpIHtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmICFBcnJheS5pc0FycmF5KHByYWdtYXNba2V5c1swXV0pKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwcmFnbWFzW2tleXNbMF1dO1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChoZWFkLCBcIiBcIikuY29uY2F0KHByaW50S2V5VmFsdWVzKGtleXNbMF0sIHZhbHVlKVswXSkuY29uY2F0KHRhaWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByaW50ZWRDb21tZW50cyA9IGNvbW1lbnRzLnNwbGl0KGxpbmUpLm1hcCh0ZXh0TGluZSA9PiBcIlwiLmNvbmNhdChzdGFydCwgXCIgXCIpLmNvbmNhdCh0ZXh0TGluZSkpLmpvaW4obGluZSkgKyBsaW5lO1xuICAgICAgcmV0dXJuIGhlYWQgKyBsaW5lICsgKGNvbW1lbnRzID8gcHJpbnRlZENvbW1lbnRzIDogJycpICsgKGNvbW1lbnRzICYmIGtleXMubGVuZ3RoID8gc3RhcnQgKyBsaW5lIDogJycpICsgcHJpbnRlZE9iamVjdCArIHRhaWw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRLZXlWYWx1ZXMoa2V5LCB2YWx1ZU9yQXJyYXkpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQodmFsdWVPckFycmF5KS5tYXAodmFsdWUgPT4gXCJAXCIuY29uY2F0KGtleSwgXCIgXCIpLmNvbmNhdCh2YWx1ZSkudHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICB1bndyYXBFeHBvcnRzKGJ1aWxkKTtcbiAgdmFyIGJ1aWxkXzEgPSBidWlsZC5leHRyYWN0O1xuICB2YXIgYnVpbGRfMiA9IGJ1aWxkLnN0cmlwO1xuICB2YXIgYnVpbGRfMyA9IGJ1aWxkLnBhcnNlO1xuICB2YXIgYnVpbGRfNCA9IGJ1aWxkLnBhcnNlV2l0aENvbW1lbnRzO1xuICB2YXIgYnVpbGRfNSA9IGJ1aWxkLnByaW50O1xuXG4gIGZ1bmN0aW9uIGhhc1ByYWdtYSh0ZXh0KSB7XG4gICAgY29uc3QgcHJhZ21hcyA9IE9iamVjdC5rZXlzKGJ1aWxkLnBhcnNlKGJ1aWxkLmV4dHJhY3QodGV4dCkpKTtcbiAgICByZXR1cm4gcHJhZ21hcy5pbmNsdWRlcyhcInByZXR0aWVyXCIpIHx8IHByYWdtYXMuaW5jbHVkZXMoXCJmb3JtYXRcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRQcmFnbWEodGV4dCkge1xuICAgIGNvbnN0IHBhcnNlZERvY2Jsb2NrID0gYnVpbGQucGFyc2VXaXRoQ29tbWVudHMoYnVpbGQuZXh0cmFjdCh0ZXh0KSk7XG4gICAgY29uc3QgcHJhZ21hcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgZm9ybWF0OiBcIlwiXG4gICAgfSwgcGFyc2VkRG9jYmxvY2sucHJhZ21hcyk7XG4gICAgY29uc3QgbmV3RG9jYmxvY2sgPSBidWlsZC5wcmludCh7XG4gICAgICBwcmFnbWFzLFxuICAgICAgY29tbWVudHM6IHBhcnNlZERvY2Jsb2NrLmNvbW1lbnRzLnJlcGxhY2UoL14oXFxzKz9cXHI/XFxuKSsvLCBcIlwiKSAvLyByZW1vdmUgbGVhZGluZyBuZXdsaW5lc1xuXG4gICAgfSkucmVwbGFjZSgvKFxcclxcbnxcXHIpL2csIFwiXFxuXCIpOyAvLyBub3JtYWxpc2UgbmV3bGluZXMgKG1pdGlnYXRlIHVzZSBvZiBvcy5FT0wgYnkgamVzdC1kb2NibG9jaylcblxuICAgIGNvbnN0IHN0cmlwcGVkVGV4dCA9IGJ1aWxkLnN0cmlwKHRleHQpO1xuICAgIGNvbnN0IHNlcGFyYXRpbmdOZXdsaW5lcyA9IHN0cmlwcGVkVGV4dC5zdGFydHNXaXRoKFwiXFxuXCIpID8gXCJcXG5cIiA6IFwiXFxuXFxuXCI7XG4gICAgcmV0dXJuIG5ld0RvY2Jsb2NrICsgc2VwYXJhdGluZ05ld2xpbmVzICsgc3RyaXBwZWRUZXh0O1xuICB9XG5cbiAgdmFyIHByYWdtYSA9IHtcbiAgICBoYXNQcmFnbWEsXG4gICAgaW5zZXJ0UHJhZ21hXG4gIH07XG5cbiAgY29uc3QgREVMSU1JVEVSX01BUCA9IHtcbiAgICBcIi0tLVwiOiBcInlhbWxcIixcbiAgICBcIisrK1wiOiBcInRvbWxcIlxuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlJDEodGV4dCkge1xuICAgIGNvbnN0IGRlbGltaXRlclJlZ2V4ID0gT2JqZWN0LmtleXMoREVMSU1JVEVSX01BUCkubWFwKGVzY2FwZVN0cmluZ1JlZ2V4cCQyKS5qb2luKFwifFwiKTtcbiAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2goIC8vIHRyYWlsaW5nIHNwYWNlcyBhZnRlciBkZWxpbWl0ZXJzIGFyZSBhbGxvd2VkXG4gICAgbmV3IFJlZ0V4cChcIl4oXCIuY29uY2F0KGRlbGltaXRlclJlZ2V4LCBcIilbXlxcXFxuXFxcXFNdKlxcXFxuKD86KFtcXFxcc1xcXFxTXSo/KVxcXFxuKT9cXFxcMVteXFxcXG5cXFxcU10qKFxcXFxufCQpXCIpKSk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb250TWF0dGVyOiBudWxsLFxuICAgICAgICBjb250ZW50OiB0ZXh0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IFtyYXcsIGRlbGltaXRlciwgdmFsdWVdID0gbWF0Y2g7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb250TWF0dGVyOiB7XG4gICAgICAgIHR5cGU6IERFTElNSVRFUl9NQVBbZGVsaW1pdGVyXSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHJhdzogcmF3LnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxuICAgICAgfSxcbiAgICAgIGNvbnRlbnQ6IHJhdy5yZXBsYWNlKC9bXlxcbl0vZywgXCIgXCIpICsgdGV4dC5zbGljZShyYXcubGVuZ3RoKVxuICAgIH07XG4gIH1cblxuICB2YXIgZnJvbnRNYXR0ZXIgPSBwYXJzZSQxO1xuXG4gIGZ1bmN0aW9uIGhhc1ByYWdtYSQxKHRleHQpIHtcbiAgICByZXR1cm4gcHJhZ21hLmhhc1ByYWdtYShmcm9udE1hdHRlcih0ZXh0KS5jb250ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydFByYWdtYSQxKHRleHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcm9udE1hdHRlcjogZnJvbnRNYXR0ZXIkMSxcbiAgICAgIGNvbnRlbnRcbiAgICB9ID0gZnJvbnRNYXR0ZXIodGV4dCk7XG4gICAgcmV0dXJuIChmcm9udE1hdHRlciQxID8gZnJvbnRNYXR0ZXIkMS5yYXcgKyBcIlxcblxcblwiIDogXCJcIikgKyBwcmFnbWEuaW5zZXJ0UHJhZ21hKGNvbnRlbnQpO1xuICB9XG5cbiAgdmFyIHByYWdtYSQxID0ge1xuICAgIGhhc1ByYWdtYTogaGFzUHJhZ21hJDEsXG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkMVxuICB9O1xuXG4gIHZhciBsaW5lQ29sdW1uVG9JbmRleCA9IGZ1bmN0aW9uIGxpbmVDb2x1bW5Ub0luZGV4KGxpbmVDb2x1bW4sIHRleHQpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ29sdW1uLmxpbmUgLSAxOyArK2kpIHtcbiAgICAgIGluZGV4ID0gdGV4dC5pbmRleE9mKFwiXFxuXCIsIGluZGV4KSArIDE7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmRleCArIGxpbmVDb2x1bW4uY29sdW1uO1xuICB9O1xuXG4gIGNvbnN0IHtcbiAgICBnZXRMYXN0OiBnZXRMYXN0JDEsXG4gICAgc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lOiBza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmUkMlxuICB9ID0gdXRpbCQxO1xuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZUxvY1N0YXJ0KG5vZGUsIHRleHQpIHtcbiAgICBpZiAobm9kZS5zb3VyY2UpIHtcbiAgICAgIHJldHVybiBsaW5lQ29sdW1uVG9JbmRleChub2RlLnNvdXJjZS5zdGFydCwgdGV4dCkgLSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlTG9jRW5kKG5vZGUsIHRleHQpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcImNzcy1jb21tZW50XCIgJiYgbm9kZS5pbmxpbmUpIHtcbiAgICAgIHJldHVybiBza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmUkMih0ZXh0LCBub2RlLnNvdXJjZS5zdGFydE9mZnNldCk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kTm9kZSA9IG5vZGUubm9kZXMgJiYgZ2V0TGFzdCQxKG5vZGUubm9kZXMpO1xuXG4gICAgaWYgKGVuZE5vZGUgJiYgbm9kZS5zb3VyY2UgJiYgIW5vZGUuc291cmNlLmVuZCkge1xuICAgICAgbm9kZSA9IGVuZE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuc291cmNlICYmIG5vZGUuc291cmNlLmVuZCkge1xuICAgICAgcmV0dXJuIGxpbmVDb2x1bW5Ub0luZGV4KG5vZGUuc291cmNlLmVuZCwgdGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxjdWxhdGVMb2Mobm9kZSwgdGV4dCkge1xuICAgIGlmIChub2RlICYmIHR5cGVvZiBub2RlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAobm9kZS5zb3VyY2UpIHtcbiAgICAgICAgbm9kZS5zb3VyY2Uuc3RhcnRPZmZzZXQgPSBjYWxjdWxhdGVMb2NTdGFydChub2RlLCB0ZXh0KTtcbiAgICAgICAgbm9kZS5zb3VyY2UuZW5kT2Zmc2V0ID0gY2FsY3VsYXRlTG9jRW5kKG5vZGUsIHRleHQpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBub2RlKSB7XG4gICAgICAgIGNhbGN1bGF0ZUxvYyhub2RlW2tleV0sIHRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogV29ya2Fyb3VuZCBmb3IgYSBidWc6IHF1b3RlcyBpbiBpbmxpbmUgY29tbWVudHMgY29ycnVwdCBsb2MgZGF0YSBvZiBzdWJzZXF1ZW50IG5vZGVzLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJlcGxhY2VzIHRoZSBxdW90ZXMgd2l0aCBVK0ZGRkUgYW5kIFUrRkZGRi4gTGF0ZXIsIHdoZW4gdGhlIGNvbW1lbnRzIGFyZSBwcmludGVkLFxuICAgKiB0aGVpciBjb250ZW50IGlzIGV4dHJhY3RlZCBmcm9tIHRoZSBvcmlnaW5hbCB0ZXh0IG9yIHJlc3RvcmVkIGJ5IHJlcGxhY2luZyB0aGUgcGxhY2Vob2xkZXJcbiAgICogY2hhcmFjdGVycyBiYWNrIHdpdGggcXVvdGVzLlxuICAgKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9pc3N1ZXMvNzc4MFxuICAgKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGVsbHNjYXBlL3Bvc3Rjc3MtbGVzcy9pc3N1ZXMvMTQ1XG4gICAqIC0gQWJvdXQgbm9uY2hhcmFjdGVycyAoVStGRkZFIGFuZCBVK0ZGRkYpOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL2ZhcS9wcml2YXRlX3VzZS5odG1sI25vbmNoYXIxXG4gICAqIEBwYXJhbSB0ZXh0IHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcmVwbGFjZVF1b3Rlc0luSW5saW5lQ29tbWVudHModGV4dCkge1xuICAgIC8qKiBAdHlwZWRlZiB7ICdpbml0aWFsJyB8ICdzaW5nbGUtcXVvdGVzJyB8ICdkb3VibGUtcXVvdGVzJyB8ICd1cmwnIHwgJ2NvbW1lbnQtYmxvY2snIHwgJ2NvbW1lbnQtaW5saW5lJyB9IFN0YXRlICovXG5cbiAgICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICAgIGxldCBzdGF0ZSA9IFwiaW5pdGlhbFwiO1xuICAgIC8qKiBAdHlwZSB7U3RhdGV9ICovXG5cbiAgICBsZXQgc3RhdGVUb1JldHVybkZyb21RdW90ZXMgPSBcImluaXRpYWxcIjtcbiAgICBsZXQgaW5saW5lQ29tbWVudFN0YXJ0SW5kZXg7XG4gICAgbGV0IGlubGluZUNvbW1lbnRDb250YWluc1F1b3RlcyA9IGZhbHNlO1xuICAgIGNvbnN0IGlubGluZUNvbW1lbnRzVG9SZXBsYWNlID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0ZXh0W2ldO1xuXG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJpbml0aWFsXCI6XG4gICAgICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFwic2luZ2xlLXF1b3Rlc1wiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gXCJkb3VibGUtcXVvdGVzXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoKGMgPT09IFwidVwiIHx8IGMgPT09IFwiVVwiKSAmJiB0ZXh0LnNsaWNlKGksIGkgKyA0KS50b0xvd2VyQ2FzZSgpID09PSBcInVybChcIikge1xuICAgICAgICAgICAgc3RhdGUgPSBcInVybFwiO1xuICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT09IFwiKlwiICYmIHRleHRbaSAtIDFdID09PSBcIi9cIikge1xuICAgICAgICAgICAgc3RhdGUgPSBcImNvbW1lbnQtYmxvY2tcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjID09PSBcIi9cIiAmJiB0ZXh0W2kgLSAxXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHN0YXRlID0gXCJjb21tZW50LWlubGluZVwiO1xuICAgICAgICAgICAgaW5saW5lQ29tbWVudFN0YXJ0SW5kZXggPSBpIC0gMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIGNhc2UgXCJzaW5nbGUtcXVvdGVzXCI6XG4gICAgICAgICAgaWYgKGMgPT09IFwiJ1wiICYmIHRleHRbaSAtIDFdICE9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVRvUmV0dXJuRnJvbVF1b3RlcztcbiAgICAgICAgICAgIHN0YXRlVG9SZXR1cm5Gcm9tUXVvdGVzID0gXCJpbml0aWFsXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7IC8vIGludmFsaWQgaW5wdXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBjYXNlIFwiZG91YmxlLXF1b3Rlc1wiOlxuICAgICAgICAgIGlmIChjID09PSAnXCInICYmIHRleHRbaSAtIDFdICE9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZVRvUmV0dXJuRnJvbVF1b3RlcztcbiAgICAgICAgICAgIHN0YXRlVG9SZXR1cm5Gcm9tUXVvdGVzID0gXCJpbml0aWFsXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7IC8vIGludmFsaWQgaW5wdXRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBjYXNlIFwidXJsXCI6XG4gICAgICAgICAgaWYgKGMgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFwiaW5pdGlhbFwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjID09PSBcIlxcblwiIHx8IGMgPT09IFwiXFxyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0OyAvLyBpbnZhbGlkIGlucHV0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFwic2luZ2xlLXF1b3Rlc1wiO1xuICAgICAgICAgICAgc3RhdGVUb1JldHVybkZyb21RdW90ZXMgPSBcInVybFwiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gXCJkb3VibGUtcXVvdGVzXCI7XG4gICAgICAgICAgICBzdGF0ZVRvUmV0dXJuRnJvbVF1b3RlcyA9IFwidXJsXCI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBjYXNlIFwiY29tbWVudC1ibG9ja1wiOlxuICAgICAgICAgIGlmIChjID09PSBcIi9cIiAmJiB0ZXh0W2kgLSAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIHN0YXRlID0gXCJpbml0aWFsXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgY2FzZSBcImNvbW1lbnQtaW5saW5lXCI6XG4gICAgICAgICAgaWYgKGMgPT09ICdcIicgfHwgYyA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIGlubGluZUNvbW1lbnRDb250YWluc1F1b3RlcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGMgPT09IFwiXFxuXCIgfHwgYyA9PT0gXCJcXHJcIikge1xuICAgICAgICAgICAgaWYgKGlubGluZUNvbW1lbnRDb250YWluc1F1b3Rlcykge1xuICAgICAgICAgICAgICBpbmxpbmVDb21tZW50c1RvUmVwbGFjZS5wdXNoKFtpbmxpbmVDb21tZW50U3RhcnRJbmRleCwgaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZSA9IFwiaW5pdGlhbFwiO1xuICAgICAgICAgICAgaW5saW5lQ29tbWVudENvbnRhaW5zUXVvdGVzID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2YgaW5saW5lQ29tbWVudHNUb1JlcGxhY2UpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIHN0YXJ0KSArIHRleHQuc2xpY2Uoc3RhcnQsIGVuZCkucmVwbGFjZSgvJy9nLCBcIlxcdWZmZmVcIikucmVwbGFjZSgvXCIvZywgXCJcXHVmZmZmXCIpICsgdGV4dC5zbGljZShlbmQpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVF1b3Rlc0luSW5saW5lQ29tbWVudHModGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcdWZmZmUvZywgXCInXCIpLnJlcGxhY2UoL1xcdWZmZmYvZywgJ1wiJyk7XG4gIH1cblxuICB2YXIgbG9jJDEgPSB7XG4gICAgY2FsY3VsYXRlTG9jLFxuICAgIHJlcGxhY2VRdW90ZXNJbklubGluZUNvbW1lbnRzLFxuICAgIHJlc3RvcmVRdW90ZXNJbklubGluZUNvbW1lbnRzXG4gIH07XG5cbiAgY29uc3QgY29sb3JBZGp1c3RlckZ1bmN0aW9ucyA9IFtcInJlZFwiLCBcImdyZWVuXCIsIFwiYmx1ZVwiLCBcImFscGhhXCIsIFwiYVwiLCBcInJnYlwiLCBcImh1ZVwiLCBcImhcIiwgXCJzYXR1cmF0aW9uXCIsIFwic1wiLCBcImxpZ2h0bmVzc1wiLCBcImxcIiwgXCJ3aGl0ZW5lc3NcIiwgXCJ3XCIsIFwiYmxhY2tuZXNzXCIsIFwiYlwiLCBcInRpbnRcIiwgXCJzaGFkZVwiLCBcImJsZW5kXCIsIFwiYmxlbmRhXCIsIFwiY29udHJhc3RcIiwgXCJoc2xcIiwgXCJoc2xhXCIsIFwiaHdiXCIsIFwiaHdiYVwiXTtcblxuICBmdW5jdGlvbiBnZXRBbmNlc3RvckNvdW50ZXIocGF0aCwgdHlwZU9yVHlwZXMpIHtcbiAgICBjb25zdCB0eXBlcyA9IFtdLmNvbmNhdCh0eXBlT3JUeXBlcyk7XG4gICAgbGV0IGNvdW50ZXIgPSAtMTtcbiAgICBsZXQgYW5jZXN0b3JOb2RlO1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yTm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgrK2NvdW50ZXIpKSB7XG4gICAgICBpZiAodHlwZXMuaW5jbHVkZXMoYW5jZXN0b3JOb2RlLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBjb3VudGVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuY2VzdG9yTm9kZShwYXRoLCB0eXBlT3JUeXBlcykge1xuICAgIGNvbnN0IGNvdW50ZXIgPSBnZXRBbmNlc3RvckNvdW50ZXIocGF0aCwgdHlwZU9yVHlwZXMpO1xuICAgIHJldHVybiBjb3VudGVyID09PSAtMSA/IG51bGwgOiBwYXRoLmdldFBhcmVudE5vZGUoY291bnRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9wT2ZEZWNsTm9kZShwYXRoKSB7XG4gICAgY29uc3QgZGVjbEFuY2VzdG9yTm9kZSA9IGdldEFuY2VzdG9yTm9kZShwYXRoLCBcImNzcy1kZWNsXCIpO1xuICAgIHJldHVybiBkZWNsQW5jZXN0b3JOb2RlICYmIGRlY2xBbmNlc3Rvck5vZGUucHJvcCAmJiBkZWNsQW5jZXN0b3JOb2RlLnByb3AudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU0NTUyhwYXJzZXIsIHRleHQpIHtcbiAgICBjb25zdCBoYXNFeHBsaWNpdFBhcnNlckNob2ljZSA9IHBhcnNlciA9PT0gXCJsZXNzXCIgfHwgcGFyc2VyID09PSBcInNjc3NcIjtcbiAgICBjb25zdCBJU19QT1NTSUJMWV9TQ1NTID0gLyhcXHdcXHMqOlxccypbXn06XSt8Iyl7fEBpbXBvcnRbXlxcbl0rKD86dXJsfCwpLztcbiAgICByZXR1cm4gaGFzRXhwbGljaXRQYXJzZXJDaG9pY2UgPyBwYXJzZXIgPT09IFwic2Nzc1wiIDogSVNfUE9TU0lCTFlfU0NTUy50ZXN0KHRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNXaWRlS2V5d29yZHModmFsdWUpIHtcbiAgICByZXR1cm4gW1wiaW5pdGlhbFwiLCBcImluaGVyaXRcIiwgXCJ1bnNldFwiLCBcInJldmVydFwiXS5pbmNsdWRlcyh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzS2V5ZnJhbWVBdFJ1bGVLZXl3b3JkcyhwYXRoLCB2YWx1ZSkge1xuICAgIGNvbnN0IGF0UnVsZUFuY2VzdG9yTm9kZSA9IGdldEFuY2VzdG9yTm9kZShwYXRoLCBcImNzcy1hdHJ1bGVcIik7XG4gICAgcmV0dXJuIGF0UnVsZUFuY2VzdG9yTm9kZSAmJiBhdFJ1bGVBbmNlc3Rvck5vZGUubmFtZSAmJiBhdFJ1bGVBbmNlc3Rvck5vZGUubmFtZS50b0xvd2VyQ2FzZSgpLmVuZHNXaXRoKFwia2V5ZnJhbWVzXCIpICYmIFtcImZyb21cIiwgXCJ0b1wiXS5pbmNsdWRlcyh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlVG9Mb3dlckNhc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuaW5jbHVkZXMoXCIkXCIpIHx8IHZhbHVlLmluY2x1ZGVzKFwiQFwiKSB8fCB2YWx1ZS5pbmNsdWRlcyhcIiNcIikgfHwgdmFsdWUuc3RhcnRzV2l0aChcIiVcIikgfHwgdmFsdWUuc3RhcnRzV2l0aChcIi0tXCIpIHx8IHZhbHVlLnN0YXJ0c1dpdGgoXCI6LS1cIikgfHwgdmFsdWUuaW5jbHVkZXMoXCIoXCIpICYmIHZhbHVlLmluY2x1ZGVzKFwiKVwiKSA/IHZhbHVlIDogdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2lkZVZhbHVlRnVuY3Rpb25Ob2RlKHBhdGgsIGZ1bmN0aW9uTmFtZSkge1xuICAgIGNvbnN0IGZ1bmNBbmNlc3Rvck5vZGUgPSBnZXRBbmNlc3Rvck5vZGUocGF0aCwgXCJ2YWx1ZS1mdW5jXCIpO1xuICAgIHJldHVybiBmdW5jQW5jZXN0b3JOb2RlICYmIGZ1bmNBbmNlc3Rvck5vZGUudmFsdWUgJiYgZnVuY0FuY2VzdG9yTm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBmdW5jdGlvbk5hbWU7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNpZGVJQ1NTUnVsZU5vZGUocGF0aCkge1xuICAgIGNvbnN0IHJ1bGVBbmNlc3Rvck5vZGUgPSBnZXRBbmNlc3Rvck5vZGUocGF0aCwgXCJjc3MtcnVsZVwiKTtcbiAgICByZXR1cm4gcnVsZUFuY2VzdG9yTm9kZSAmJiBydWxlQW5jZXN0b3JOb2RlLnJhd3MgJiYgcnVsZUFuY2VzdG9yTm9kZS5yYXdzLnNlbGVjdG9yICYmIChydWxlQW5jZXN0b3JOb2RlLnJhd3Muc2VsZWN0b3Iuc3RhcnRzV2l0aChcIjppbXBvcnRcIikgfHwgcnVsZUFuY2VzdG9yTm9kZS5yYXdzLnNlbGVjdG9yLnN0YXJ0c1dpdGgoXCI6ZXhwb3J0XCIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2lkZUF0UnVsZU5vZGUocGF0aCwgYXRSdWxlTmFtZU9yQXRSdWxlTmFtZXMpIHtcbiAgICBjb25zdCBhdFJ1bGVOYW1lcyA9IFtdLmNvbmNhdChhdFJ1bGVOYW1lT3JBdFJ1bGVOYW1lcyk7XG4gICAgY29uc3QgYXRSdWxlQW5jZXN0b3JOb2RlID0gZ2V0QW5jZXN0b3JOb2RlKHBhdGgsIFwiY3NzLWF0cnVsZVwiKTtcbiAgICByZXR1cm4gYXRSdWxlQW5jZXN0b3JOb2RlICYmIGF0UnVsZU5hbWVzLmluY2x1ZGVzKGF0UnVsZUFuY2VzdG9yTm9kZS5uYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zaWRlVVJMRnVuY3Rpb25JbkltcG9ydEF0UnVsZU5vZGUocGF0aCkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgYXRSdWxlQW5jZXN0b3JOb2RlID0gZ2V0QW5jZXN0b3JOb2RlKHBhdGgsIFwiY3NzLWF0cnVsZVwiKTtcbiAgICByZXR1cm4gYXRSdWxlQW5jZXN0b3JOb2RlICYmIGF0UnVsZUFuY2VzdG9yTm9kZS5uYW1lID09PSBcImltcG9ydFwiICYmIG5vZGUuZ3JvdXBzWzBdLnZhbHVlID09PSBcInVybFwiICYmIG5vZGUuZ3JvdXBzLmxlbmd0aCA9PT0gMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVVJMRnVuY3Rpb25Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLWZ1bmNcIiAmJiBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwidXJsXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xhc3ROb2RlKHBhdGgsIG5vZGUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBub2Rlc1xuICAgIH0gPSBwYXJlbnROb2RlO1xuICAgIHJldHVybiBub2RlcyAmJiBub2Rlcy5pbmRleE9mKG5vZGUpID09PSBub2Rlcy5sZW5ndGggLSAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEZXRhY2hlZFJ1bGVzZXREZWNsYXJhdGlvbk5vZGUobm9kZSkge1xuICAgIC8vIElmIGEgTGVzcyBmaWxlIGVuZHMgdXAgYmVpbmcgcGFyc2VkIHdpdGggdGhlIFNDU1MgcGFyc2VyLCBMZXNzXG4gICAgLy8gdmFyaWFibGUgZGVjbGFyYXRpb25zIHdpbGwgYmUgcGFyc2VkIGFzIGF0cnVsZXMgd2l0aCBuYW1lcyBlbmRpbmdcbiAgICAvLyB3aXRoIGEgY29sb24sIHNvIGtlZXAgdGhlIG9yaWdpbmFsIGNhc2UgdGhlbi5cbiAgICBpZiAoIW5vZGUuc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW9mIG5vZGUuc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgL15ALis6LiokLy50ZXN0KG5vZGUuc2VsZWN0b3IpIHx8IG5vZGUuc2VsZWN0b3IudmFsdWUgJiYgL15ALis6LiokLy50ZXN0KG5vZGUuc2VsZWN0b3IudmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGb3JLZXl3b3JkTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS13b3JkXCIgJiYgW1wiZnJvbVwiLCBcInRocm91Z2hcIiwgXCJlbmRcIl0uaW5jbHVkZXMobm9kZS52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lmRWxzZUtleXdvcmROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBbXCJhbmRcIiwgXCJvclwiLCBcIm5vdFwiXS5pbmNsdWRlcyhub2RlLnZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRWFjaEtleXdvcmROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBub2RlLnZhbHVlID09PSBcImluXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc011bHRpcGxpY2F0aW9uTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1vcGVyYXRvclwiICYmIG5vZGUudmFsdWUgPT09IFwiKlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEaXZpc2lvbk5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwidmFsdWUtb3BlcmF0b3JcIiAmJiBub2RlLnZhbHVlID09PSBcIi9cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQWRkaXRpb25Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLW9wZXJhdG9yXCIgJiYgbm9kZS52YWx1ZSA9PT0gXCIrXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N1YnRyYWN0aW9uTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1vcGVyYXRvclwiICYmIG5vZGUudmFsdWUgPT09IFwiLVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNNb2R1bG9Ob2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLW9wZXJhdG9yXCIgJiYgbm9kZS52YWx1ZSA9PT0gXCIlXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc01hdGhPcGVyYXRvck5vZGUobm9kZSkge1xuICAgIHJldHVybiBpc011bHRpcGxpY2F0aW9uTm9kZShub2RlKSB8fCBpc0RpdmlzaW9uTm9kZShub2RlKSB8fCBpc0FkZGl0aW9uTm9kZShub2RlKSB8fCBpc1N1YnRyYWN0aW9uTm9kZShub2RlKSB8fCBpc01vZHVsb05vZGUobm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VxdWFsaXR5T3BlcmF0b3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBbXCI9PVwiLCBcIiE9XCJdLmluY2x1ZGVzKG5vZGUudmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWxhdGlvbmFsT3BlcmF0b3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBbXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIl0uaW5jbHVkZXMobm9kZS52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NDU1NDb250cm9sRGlyZWN0aXZlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJjc3MtYXRydWxlXCIgJiYgW1wiaWZcIiwgXCJlbHNlXCIsIFwiZm9yXCIsIFwiZWFjaFwiLCBcIndoaWxlXCJdLmluY2x1ZGVzKG5vZGUubmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NDU1NOZXN0ZWRQcm9wZXJ0eU5vZGUobm9kZSkge1xuICAgIGlmICghbm9kZS5zZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlLnNlbGVjdG9yLnJlcGxhY2UoL1xcL1xcKi4qP1xcKlxcLy8sIFwiXCIpLnJlcGxhY2UoL1xcL1xcLy4qP1xcbi8sIFwiXCIpLnRyaW0oKS5lbmRzV2l0aChcIjpcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0RldGFjaGVkUnVsZXNldENhbGxOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5yYXdzICYmIG5vZGUucmF3cy5wYXJhbXMgJiYgL15cXChcXHMqXFwpJC8udGVzdChub2RlLnJhd3MucGFyYW1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGVtcGxhdGVQbGFjZWhvbGRlck5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5hbWUuc3RhcnRzV2l0aChcInByZXR0aWVyLXBsYWNlaG9sZGVyXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUZW1wbGF0ZVByb3BOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wcm9wLnN0YXJ0c1dpdGgoXCJAcHJldHRpZXItcGxhY2Vob2xkZXJcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlKGN1cnJlbnROb2RlLCBuZXh0Tm9kZSkge1xuICAgIHJldHVybiBjdXJyZW50Tm9kZS52YWx1ZSA9PT0gXCIkJFwiICYmIGN1cnJlbnROb2RlLnR5cGUgPT09IFwidmFsdWUtZnVuY1wiICYmIG5leHROb2RlICYmIG5leHROb2RlLnR5cGUgPT09IFwidmFsdWUtd29yZFwiICYmICFuZXh0Tm9kZS5yYXdzLmJlZm9yZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0NvbXBvc2VzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWUgJiYgbm9kZS52YWx1ZS50eXBlID09PSBcInZhbHVlLXJvb3RcIiAmJiBub2RlLnZhbHVlLmdyb3VwICYmIG5vZGUudmFsdWUuZ3JvdXAudHlwZSA9PT0gXCJ2YWx1ZS12YWx1ZVwiICYmIG5vZGUucHJvcC50b0xvd2VyQ2FzZSgpID09PSBcImNvbXBvc2VzXCI7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQYXJlbnNBcm91bmROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlLmdyb3VwICYmIG5vZGUudmFsdWUuZ3JvdXAuZ3JvdXAgJiYgbm9kZS52YWx1ZS5ncm91cC5ncm91cC50eXBlID09PSBcInZhbHVlLXBhcmVuX2dyb3VwXCIgJiYgbm9kZS52YWx1ZS5ncm91cC5ncm91cC5vcGVuICE9PSBudWxsICYmIG5vZGUudmFsdWUuZ3JvdXAuZ3JvdXAuY2xvc2UgIT09IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNFbXB0eVJhd0JlZm9yZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUucmF3cyAmJiBub2RlLnJhd3MuYmVmb3JlID09PSBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXlWYWx1ZVBhaXJOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLWNvbW1hX2dyb3VwXCIgJiYgbm9kZS5ncm91cHMgJiYgbm9kZS5ncm91cHNbMV0gJiYgbm9kZS5ncm91cHNbMV0udHlwZSA9PT0gXCJ2YWx1ZS1jb2xvblwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNLZXlWYWx1ZVBhaXJJblBhcmVuR3JvdXBOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXBhcmVuX2dyb3VwXCIgJiYgbm9kZS5ncm91cHMgJiYgbm9kZS5ncm91cHNbMF0gJiYgaXNLZXlWYWx1ZVBhaXJOb2RlKG5vZGUuZ3JvdXBzWzBdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU0NTU01hcEl0ZW1Ob2RlKHBhdGgpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpOyAvLyBJZ25vcmUgZW1wdHkgaXRlbSAoaS5lLiBgJGtleTogKClgKVxuXG4gICAgaWYgKG5vZGUuZ3JvdXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoMSk7IC8vIENoZWNrIG9wZW4gcGFyZW5zIGNvbnRhaW4ga2V5L3ZhbHVlIHBhaXIgKGkuZS4gYChrZXk6IHZhbHVlKWAgYW5kIGAoa2V5OiAodmFsdWUsIG90aGVyLXZhbHVlKWApXG5cbiAgICBpZiAoIWlzS2V5VmFsdWVQYWlySW5QYXJlbkdyb3VwTm9kZShub2RlKSAmJiAhKHBhcmVudFBhcmVudE5vZGUgJiYgaXNLZXlWYWx1ZVBhaXJJblBhcmVuR3JvdXBOb2RlKHBhcmVudFBhcmVudE5vZGUpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY2xOb2RlID0gZ2V0QW5jZXN0b3JOb2RlKHBhdGgsIFwiY3NzLWRlY2xcIik7IC8vIFNDU1MgbWFwIGRlY2xhcmF0aW9uIChpLmUuIGAkbWFwOiAoa2V5OiB2YWx1ZSwgb3RoZXIta2V5OiBvdGhlci12YWx1ZSlgKVxuXG4gICAgaWYgKGRlY2xOb2RlICYmIGRlY2xOb2RlLnByb3AgJiYgZGVjbE5vZGUucHJvcC5zdGFydHNXaXRoKFwiJFwiKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMaXN0IGFzIHZhbHVlIG9mIGtleSBpbnNpZGUgU0NTUyBtYXAgKGkuZS4gYCRtYXA6IChrZXk6ICh2YWx1ZSBvdGhlci12YWx1ZSBvdGhlci1vdGhlci12YWx1ZSkpYClcblxuXG4gICAgaWYgKGlzS2V5VmFsdWVQYWlySW5QYXJlbkdyb3VwTm9kZShwYXJlbnRQYXJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBTQ1NTIE1hcCBpcyBhcmd1bWVudCBvZiBmdW5jdGlvbiAoaS5lLiBgZnVuYygoa2V5OiB2YWx1ZSwgb3RoZXIta2V5OiBvdGhlci12YWx1ZSkpYClcblxuXG4gICAgaWYgKHBhcmVudFBhcmVudE5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1mdW5jXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5saW5lVmFsdWVDb21tZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1jb21tZW50XCIgJiYgbm9kZS5pbmxpbmU7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hhc2hOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBub2RlLnZhbHVlID09PSBcIiNcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGVmdEN1cmx5QnJhY2VOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInZhbHVlLXdvcmRcIiAmJiBub2RlLnZhbHVlID09PSBcIntcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUmlnaHRDdXJseUJyYWNlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ2YWx1ZS13b3JkXCIgJiYgbm9kZS52YWx1ZSA9PT0gXCJ9XCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1dvcmROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gW1widmFsdWUtd29yZFwiLCBcInZhbHVlLWF0d29yZFwiXS5pbmNsdWRlcyhub2RlLnR5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb2xvbk5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwidmFsdWUtY29sb25cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTWVkaWFBbmRTdXBwb3J0c0tleXdvcmRzKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZSAmJiBbXCJub3RcIiwgXCJhbmRcIiwgXCJvclwiXS5pbmNsdWRlcyhub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNDb2xvckFkanVzdGVyRnVuY05vZGUobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwidmFsdWUtZnVuY1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yQWRqdXN0ZXJGdW5jdGlvbnMuaW5jbHVkZXMobm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgfSAvLyBUT0RPOiBvbmx5IGNoZWNrIGBsZXNzYCB3aGVuIHdlIGRvbid0IHVzZSBgbGVzc2AgdG8gcGFyc2UgYGNzc2BcblxuXG4gIGZ1bmN0aW9uIGlzTGVzc1BhcnNlcihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMucGFyc2VyID09PSBcImNzc1wiIHx8IG9wdGlvbnMucGFyc2VyID09PSBcImxlc3NcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxhc3RMaW5lSGFzSW5saW5lQ29tbWVudCh0ZXh0KSB7XG4gICAgcmV0dXJuIC9cXC9cXC8vLnRlc3QodGV4dC5zcGxpdCgvW1xcclxcbl0vKS5wb3AoKSk7XG4gIH1cblxuICB2YXIgdXRpbHMkMiA9IHtcbiAgICBnZXRBbmNlc3RvckNvdW50ZXIsXG4gICAgZ2V0QW5jZXN0b3JOb2RlLFxuICAgIGdldFByb3BPZkRlY2xOb2RlLFxuICAgIG1heWJlVG9Mb3dlckNhc2UsXG4gICAgaW5zaWRlVmFsdWVGdW5jdGlvbk5vZGUsXG4gICAgaW5zaWRlSUNTU1J1bGVOb2RlLFxuICAgIGluc2lkZUF0UnVsZU5vZGUsXG4gICAgaW5zaWRlVVJMRnVuY3Rpb25JbkltcG9ydEF0UnVsZU5vZGUsXG4gICAgaXNLZXlmcmFtZUF0UnVsZUtleXdvcmRzLFxuICAgIGlzV2lkZUtleXdvcmRzLFxuICAgIGlzU0NTUyxcbiAgICBpc0xhc3ROb2RlLFxuICAgIGlzTGVzc1BhcnNlcixcbiAgICBpc1NDU1NDb250cm9sRGlyZWN0aXZlTm9kZSxcbiAgICBpc0RldGFjaGVkUnVsZXNldERlY2xhcmF0aW9uTm9kZSxcbiAgICBpc1JlbGF0aW9uYWxPcGVyYXRvck5vZGUsXG4gICAgaXNFcXVhbGl0eU9wZXJhdG9yTm9kZSxcbiAgICBpc011bHRpcGxpY2F0aW9uTm9kZSxcbiAgICBpc0RpdmlzaW9uTm9kZSxcbiAgICBpc0FkZGl0aW9uTm9kZSxcbiAgICBpc1N1YnRyYWN0aW9uTm9kZSxcbiAgICBpc01vZHVsb05vZGUsXG4gICAgaXNNYXRoT3BlcmF0b3JOb2RlLFxuICAgIGlzRWFjaEtleXdvcmROb2RlLFxuICAgIGlzRm9yS2V5d29yZE5vZGUsXG4gICAgaXNVUkxGdW5jdGlvbk5vZGUsXG4gICAgaXNJZkVsc2VLZXl3b3JkTm9kZSxcbiAgICBoYXNDb21wb3Nlc05vZGUsXG4gICAgaGFzUGFyZW5zQXJvdW5kTm9kZSxcbiAgICBoYXNFbXB0eVJhd0JlZm9yZSxcbiAgICBpc1NDU1NOZXN0ZWRQcm9wZXJ0eU5vZGUsXG4gICAgaXNEZXRhY2hlZFJ1bGVzZXRDYWxsTm9kZSxcbiAgICBpc1RlbXBsYXRlUGxhY2Vob2xkZXJOb2RlLFxuICAgIGlzVGVtcGxhdGVQcm9wTm9kZSxcbiAgICBpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlLFxuICAgIGlzS2V5VmFsdWVQYWlyTm9kZSxcbiAgICBpc0tleVZhbHVlUGFpckluUGFyZW5Hcm91cE5vZGUsXG4gICAgaXNTQ1NTTWFwSXRlbU5vZGUsXG4gICAgaXNJbmxpbmVWYWx1ZUNvbW1lbnROb2RlLFxuICAgIGlzSGFzaE5vZGUsXG4gICAgaXNMZWZ0Q3VybHlCcmFjZU5vZGUsXG4gICAgaXNSaWdodEN1cmx5QnJhY2VOb2RlLFxuICAgIGlzV29yZE5vZGUsXG4gICAgaXNDb2xvbk5vZGUsXG4gICAgaXNNZWRpYUFuZFN1cHBvcnRzS2V5d29yZHMsXG4gICAgaXNDb2xvckFkanVzdGVyRnVuY05vZGUsXG4gICAgbGFzdExpbmVIYXNJbmxpbmVDb21tZW50XG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGluc2VydFByYWdtYTogaW5zZXJ0UHJhZ21hJDJcbiAgfSA9IHByYWdtYSQxO1xuICBjb25zdCB7XG4gICAgcHJpbnROdW1iZXI6IHByaW50TnVtYmVyJDEsXG4gICAgcHJpbnRTdHJpbmc6IHByaW50U3RyaW5nJDEsXG4gICAgaGFzSWdub3JlQ29tbWVudDogaGFzSWdub3JlQ29tbWVudCQxLFxuICAgIGhhc05ld2xpbmU6IGhhc05ld2xpbmUkM1xuICB9ID0gdXRpbCQxO1xuICBjb25zdCB7XG4gICAgaXNOZXh0TGluZUVtcHR5OiBpc05leHRMaW5lRW1wdHkkMlxuICB9ID0gdXRpbFNoYXJlZDtcbiAgY29uc3Qge1xuICAgIHJlc3RvcmVRdW90ZXNJbklubGluZUNvbW1lbnRzOiByZXN0b3JlUXVvdGVzSW5JbmxpbmVDb21tZW50cyQxXG4gIH0gPSBsb2MkMTtcbiAgY29uc3Qge1xuICAgIGJ1aWxkZXJzOiB7XG4gICAgICBjb25jYXQ6IGNvbmNhdCQ1LFxuICAgICAgam9pbjogam9pbiQyLFxuICAgICAgbGluZTogbGluZSQyLFxuICAgICAgaGFyZGxpbmU6IGhhcmRsaW5lJDQsXG4gICAgICBzb2Z0bGluZTogc29mdGxpbmUkMSxcbiAgICAgIGdyb3VwOiBncm91cCQxLFxuICAgICAgZmlsbDogZmlsbCQyLFxuICAgICAgaW5kZW50OiBpbmRlbnQkMixcbiAgICAgIGRlZGVudDogZGVkZW50JDEsXG4gICAgICBpZkJyZWFrOiBpZkJyZWFrJDFcbiAgICB9LFxuICAgIHV0aWxzOiB7XG4gICAgICByZW1vdmVMaW5lczogcmVtb3ZlTGluZXMkMVxuICAgIH1cbiAgfSA9IGRvY3VtZW50O1xuICBjb25zdCB7XG4gICAgZ2V0QW5jZXN0b3JOb2RlOiBnZXRBbmNlc3Rvck5vZGUkMSxcbiAgICBnZXRQcm9wT2ZEZWNsTm9kZTogZ2V0UHJvcE9mRGVjbE5vZGUkMSxcbiAgICBtYXliZVRvTG93ZXJDYXNlOiBtYXliZVRvTG93ZXJDYXNlJDEsXG4gICAgaW5zaWRlVmFsdWVGdW5jdGlvbk5vZGU6IGluc2lkZVZhbHVlRnVuY3Rpb25Ob2RlJDEsXG4gICAgaW5zaWRlSUNTU1J1bGVOb2RlOiBpbnNpZGVJQ1NTUnVsZU5vZGUkMSxcbiAgICBpbnNpZGVBdFJ1bGVOb2RlOiBpbnNpZGVBdFJ1bGVOb2RlJDEsXG4gICAgaW5zaWRlVVJMRnVuY3Rpb25JbkltcG9ydEF0UnVsZU5vZGU6IGluc2lkZVVSTEZ1bmN0aW9uSW5JbXBvcnRBdFJ1bGVOb2RlJDEsXG4gICAgaXNLZXlmcmFtZUF0UnVsZUtleXdvcmRzOiBpc0tleWZyYW1lQXRSdWxlS2V5d29yZHMkMSxcbiAgICBpc1dpZGVLZXl3b3JkczogaXNXaWRlS2V5d29yZHMkMSxcbiAgICBpc1NDU1M6IGlzU0NTUyQxLFxuICAgIGlzTGFzdE5vZGU6IGlzTGFzdE5vZGUkMSxcbiAgICBpc0xlc3NQYXJzZXI6IGlzTGVzc1BhcnNlciQxLFxuICAgIGlzU0NTU0NvbnRyb2xEaXJlY3RpdmVOb2RlOiBpc1NDU1NDb250cm9sRGlyZWN0aXZlTm9kZSQxLFxuICAgIGlzRGV0YWNoZWRSdWxlc2V0RGVjbGFyYXRpb25Ob2RlOiBpc0RldGFjaGVkUnVsZXNldERlY2xhcmF0aW9uTm9kZSQxLFxuICAgIGlzUmVsYXRpb25hbE9wZXJhdG9yTm9kZTogaXNSZWxhdGlvbmFsT3BlcmF0b3JOb2RlJDEsXG4gICAgaXNFcXVhbGl0eU9wZXJhdG9yTm9kZTogaXNFcXVhbGl0eU9wZXJhdG9yTm9kZSQxLFxuICAgIGlzTXVsdGlwbGljYXRpb25Ob2RlOiBpc011bHRpcGxpY2F0aW9uTm9kZSQxLFxuICAgIGlzRGl2aXNpb25Ob2RlOiBpc0RpdmlzaW9uTm9kZSQxLFxuICAgIGlzQWRkaXRpb25Ob2RlOiBpc0FkZGl0aW9uTm9kZSQxLFxuICAgIGlzU3VidHJhY3Rpb25Ob2RlOiBpc1N1YnRyYWN0aW9uTm9kZSQxLFxuICAgIGlzTWF0aE9wZXJhdG9yTm9kZTogaXNNYXRoT3BlcmF0b3JOb2RlJDEsXG4gICAgaXNFYWNoS2V5d29yZE5vZGU6IGlzRWFjaEtleXdvcmROb2RlJDEsXG4gICAgaXNGb3JLZXl3b3JkTm9kZTogaXNGb3JLZXl3b3JkTm9kZSQxLFxuICAgIGlzVVJMRnVuY3Rpb25Ob2RlOiBpc1VSTEZ1bmN0aW9uTm9kZSQxLFxuICAgIGlzSWZFbHNlS2V5d29yZE5vZGU6IGlzSWZFbHNlS2V5d29yZE5vZGUkMSxcbiAgICBoYXNDb21wb3Nlc05vZGU6IGhhc0NvbXBvc2VzTm9kZSQxLFxuICAgIGhhc1BhcmVuc0Fyb3VuZE5vZGU6IGhhc1BhcmVuc0Fyb3VuZE5vZGUkMSxcbiAgICBoYXNFbXB0eVJhd0JlZm9yZTogaGFzRW1wdHlSYXdCZWZvcmUkMSxcbiAgICBpc0tleVZhbHVlUGFpck5vZGU6IGlzS2V5VmFsdWVQYWlyTm9kZSQxLFxuICAgIGlzRGV0YWNoZWRSdWxlc2V0Q2FsbE5vZGU6IGlzRGV0YWNoZWRSdWxlc2V0Q2FsbE5vZGUkMSxcbiAgICBpc1RlbXBsYXRlUGxhY2Vob2xkZXJOb2RlOiBpc1RlbXBsYXRlUGxhY2Vob2xkZXJOb2RlJDEsXG4gICAgaXNUZW1wbGF0ZVByb3BOb2RlOiBpc1RlbXBsYXRlUHJvcE5vZGUkMSxcbiAgICBpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlOiBpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlJDEsXG4gICAgaXNTQ1NTTWFwSXRlbU5vZGU6IGlzU0NTU01hcEl0ZW1Ob2RlJDEsXG4gICAgaXNJbmxpbmVWYWx1ZUNvbW1lbnROb2RlOiBpc0lubGluZVZhbHVlQ29tbWVudE5vZGUkMSxcbiAgICBpc0hhc2hOb2RlOiBpc0hhc2hOb2RlJDEsXG4gICAgaXNMZWZ0Q3VybHlCcmFjZU5vZGU6IGlzTGVmdEN1cmx5QnJhY2VOb2RlJDEsXG4gICAgaXNSaWdodEN1cmx5QnJhY2VOb2RlOiBpc1JpZ2h0Q3VybHlCcmFjZU5vZGUkMSxcbiAgICBpc1dvcmROb2RlOiBpc1dvcmROb2RlJDEsXG4gICAgaXNDb2xvbk5vZGU6IGlzQ29sb25Ob2RlJDEsXG4gICAgaXNNZWRpYUFuZFN1cHBvcnRzS2V5d29yZHM6IGlzTWVkaWFBbmRTdXBwb3J0c0tleXdvcmRzJDEsXG4gICAgaXNDb2xvckFkanVzdGVyRnVuY05vZGU6IGlzQ29sb3JBZGp1c3RlckZ1bmNOb2RlJDEsXG4gICAgbGFzdExpbmVIYXNJbmxpbmVDb21tZW50OiBsYXN0TGluZUhhc0lubGluZUNvbW1lbnQkMVxuICB9ID0gdXRpbHMkMjtcblxuICBmdW5jdGlvbiBzaG91bGRQcmludENvbW1hKG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMudHJhaWxpbmdDb21tYSkge1xuICAgICAgY2FzZSBcImFsbFwiOlxuICAgICAgY2FzZSBcImVzNVwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmljUHJpbnQocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwieWFtbFwiOlxuICAgICAgY2FzZSBcInRvbWxcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLnJhdywgaGFyZGxpbmUkNF0pO1xuXG4gICAgICBjYXNlIFwiY3NzLXJvb3RcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGVzID0gcHJpbnROb2RlU2VxdWVuY2UocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuXG4gICAgICAgICAgaWYgKG5vZGVzLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2Rlcywgb3B0aW9ucy5fX2lzSFRNTFN0eWxlQXR0cmlidXRlID8gXCJcIiA6IGhhcmRsaW5lJDRdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImNzcy1jb21tZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBpc0lubGluZUNvbW1lbnQgPSBub2RlLmlubGluZSB8fCBub2RlLnJhd3MuaW5saW5lO1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShvcHRpb25zLmxvY1N0YXJ0KG5vZGUpLCBvcHRpb25zLmxvY0VuZChub2RlKSk7XG4gICAgICAgICAgcmV0dXJuIGlzSW5saW5lQ29tbWVudCA/IHRleHQudHJpbUVuZCgpIDogdGV4dDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiY3NzLXJ1bGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNShbcGF0aC5jYWxsKHByaW50LCBcInNlbGVjdG9yXCIpLCBub2RlLmltcG9ydGFudCA/IFwiICFpbXBvcnRhbnRcIiA6IFwiXCIsIG5vZGUubm9kZXMgPyBjb25jYXQkNShbbm9kZS5zZWxlY3RvciAmJiBub2RlLnNlbGVjdG9yLnR5cGUgPT09IFwic2VsZWN0b3ItdW5rbm93blwiICYmIGxhc3RMaW5lSGFzSW5saW5lQ29tbWVudCQxKG5vZGUuc2VsZWN0b3IudmFsdWUpID8gbGluZSQyIDogXCIgXCIsIFwie1wiLCBub2RlLm5vZGVzLmxlbmd0aCA+IDAgPyBpbmRlbnQkMihjb25jYXQkNShbaGFyZGxpbmUkNCwgcHJpbnROb2RlU2VxdWVuY2UocGF0aCwgb3B0aW9ucywgcHJpbnQpXSkpIDogXCJcIiwgaGFyZGxpbmUkNCwgXCJ9XCIsIGlzRGV0YWNoZWRSdWxlc2V0RGVjbGFyYXRpb25Ob2RlJDEobm9kZSkgPyBcIjtcIiA6IFwiXCJdKSA6IFwiO1wiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImNzcy1kZWNsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1tcXHM7XS9nLCBcIlwiKSwgaW5zaWRlSUNTU1J1bGVOb2RlJDEocGF0aCkgPyBub2RlLnByb3AgOiBtYXliZVRvTG93ZXJDYXNlJDEobm9kZS5wcm9wKSwgbm9kZS5yYXdzLmJldHdlZW4udHJpbSgpID09PSBcIjpcIiA/IFwiOlwiIDogbm9kZS5yYXdzLmJldHdlZW4udHJpbSgpLCBub2RlLmV4dGVuZCA/IFwiXCIgOiBcIiBcIiwgaGFzQ29tcG9zZXNOb2RlJDEobm9kZSkgPyByZW1vdmVMaW5lcyQxKHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKSkgOiBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIiksIG5vZGUucmF3cy5pbXBvcnRhbnQgPyBub2RlLnJhd3MuaW1wb3J0YW50LnJlcGxhY2UoL1xccyohXFxzKmltcG9ydGFudC9pLCBcIiAhaW1wb3J0YW50XCIpIDogbm9kZS5pbXBvcnRhbnQgPyBcIiAhaW1wb3J0YW50XCIgOiBcIlwiLCBub2RlLnJhd3Muc2Nzc0RlZmF1bHQgPyBub2RlLnJhd3Muc2Nzc0RlZmF1bHQucmVwbGFjZSgvXFxzKiFkZWZhdWx0L2ksIFwiICFkZWZhdWx0XCIpIDogbm9kZS5zY3NzRGVmYXVsdCA/IFwiICFkZWZhdWx0XCIgOiBcIlwiLCBub2RlLnJhd3Muc2Nzc0dsb2JhbCA/IG5vZGUucmF3cy5zY3NzR2xvYmFsLnJlcGxhY2UoL1xccyohZ2xvYmFsL2ksIFwiICFnbG9iYWxcIikgOiBub2RlLnNjc3NHbG9iYWwgPyBcIiAhZ2xvYmFsXCIgOiBcIlwiLCBub2RlLm5vZGVzID8gY29uY2F0JDUoW1wiIHtcIiwgaW5kZW50JDIoY29uY2F0JDUoW3NvZnRsaW5lJDEsIHByaW50Tm9kZVNlcXVlbmNlKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pKSwgc29mdGxpbmUkMSwgXCJ9XCJdKSA6IGlzVGVtcGxhdGVQcm9wTm9kZSQxKG5vZGUpICYmICFwYXJlbnROb2RlLnJhd3Muc2VtaWNvbG9uICYmIG9wdGlvbnMub3JpZ2luYWxUZXh0W29wdGlvbnMubG9jRW5kKG5vZGUpIC0gMV0gIT09IFwiO1wiID8gXCJcIiA6IFwiO1wiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImNzcy1hdHJ1bGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBpc1RlbXBsYXRlUGxhY2Vob2xkZXJOb2RlV2l0aG91dFNlbWlDb2xvbiA9IGlzVGVtcGxhdGVQbGFjZWhvbGRlck5vZGUkMShub2RlKSAmJiAhcGFyZW50Tm9kZS5yYXdzLnNlbWljb2xvbiAmJiBvcHRpb25zLm9yaWdpbmFsVGV4dFtvcHRpb25zLmxvY0VuZChub2RlKSAtIDFdICE9PSBcIjtcIjtcblxuICAgICAgICAgIGlmIChpc0xlc3NQYXJzZXIkMShvcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubWl4aW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtwYXRoLmNhbGwocHJpbnQsIFwic2VsZWN0b3JcIiksIG5vZGUuaW1wb3J0YW50ID8gXCIgIWltcG9ydGFudFwiIDogXCJcIiwgaXNUZW1wbGF0ZVBsYWNlaG9sZGVyTm9kZVdpdGhvdXRTZW1pQ29sb24gPyBcIlwiIDogXCI7XCJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLm5hbWUsIGNvbmNhdCQ1KFtwYXRoLmNhbGwocHJpbnQsIFwicGFyYW1zXCIpXSksIGlzVGVtcGxhdGVQbGFjZWhvbGRlck5vZGVXaXRob3V0U2VtaUNvbG9uID8gXCJcIiA6IFwiO1wiXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLnZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25jYXQkNShbXCJAXCIsIG5vZGUubmFtZSwgXCI6IFwiLCBub2RlLnZhbHVlID8gY29uY2F0JDUoW3BhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKV0pIDogXCJcIiwgbm9kZS5yYXdzLmJldHdlZW4udHJpbSgpID8gbm9kZS5yYXdzLmJldHdlZW4udHJpbSgpICsgXCIgXCIgOiBcIlwiLCBub2RlLm5vZGVzID8gY29uY2F0JDUoW1wie1wiLCBpbmRlbnQkMihjb25jYXQkNShbbm9kZS5ub2Rlcy5sZW5ndGggPiAwID8gc29mdGxpbmUkMSA6IFwiXCIsIHByaW50Tm9kZVNlcXVlbmNlKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pKSwgc29mdGxpbmUkMSwgXCJ9XCJdKSA6IFwiXCIsIGlzVGVtcGxhdGVQbGFjZWhvbGRlck5vZGVXaXRob3V0U2VtaUNvbG9uID8gXCJcIiA6IFwiO1wiXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtcIkBcIiwgLy8gSWYgYSBMZXNzIGZpbGUgZW5kcyB1cCBiZWluZyBwYXJzZWQgd2l0aCB0aGUgU0NTUyBwYXJzZXIsIExlc3NcbiAgICAgICAgICAvLyB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgd2lsbCBiZSBwYXJzZWQgYXMgYXQtcnVsZXMgd2l0aCBuYW1lcyBlbmRpbmdcbiAgICAgICAgICAvLyB3aXRoIGEgY29sb24sIHNvIGtlZXAgdGhlIG9yaWdpbmFsIGNhc2UgdGhlbi5cbiAgICAgICAgICBpc0RldGFjaGVkUnVsZXNldENhbGxOb2RlJDEobm9kZSkgfHwgbm9kZS5uYW1lLmVuZHNXaXRoKFwiOlwiKSA/IG5vZGUubmFtZSA6IG1heWJlVG9Mb3dlckNhc2UkMShub2RlLm5hbWUpLCBub2RlLnBhcmFtcyA/IGNvbmNhdCQ1KFtpc0RldGFjaGVkUnVsZXNldENhbGxOb2RlJDEobm9kZSkgPyBcIlwiIDogaXNUZW1wbGF0ZVBsYWNlaG9sZGVyTm9kZSQxKG5vZGUpID8gbm9kZS5yYXdzLmFmdGVyTmFtZSA9PT0gXCJcIiA/IFwiXCIgOiBub2RlLm5hbWUuZW5kc1dpdGgoXCI6XCIpID8gXCIgXCIgOiAvXlxccypcXG5cXHMqXFxuLy50ZXN0KG5vZGUucmF3cy5hZnRlck5hbWUpID8gY29uY2F0JDUoW2hhcmRsaW5lJDQsIGhhcmRsaW5lJDRdKSA6IC9eXFxzKlxcbi8udGVzdChub2RlLnJhd3MuYWZ0ZXJOYW1lKSA/IGhhcmRsaW5lJDQgOiBcIiBcIiA6IFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwicGFyYW1zXCIpXSkgOiBcIlwiLCBub2RlLnNlbGVjdG9yID8gaW5kZW50JDIoY29uY2F0JDUoW1wiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwic2VsZWN0b3JcIildKSkgOiBcIlwiLCBub2RlLnZhbHVlID8gZ3JvdXAkMShjb25jYXQkNShbXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKSwgaXNTQ1NTQ29udHJvbERpcmVjdGl2ZU5vZGUkMShub2RlKSA/IGhhc1BhcmVuc0Fyb3VuZE5vZGUkMShub2RlKSA/IFwiIFwiIDogbGluZSQyIDogXCJcIl0pKSA6IG5vZGUubmFtZSA9PT0gXCJlbHNlXCIgPyBcIiBcIiA6IFwiXCIsIG5vZGUubm9kZXMgPyBjb25jYXQkNShbaXNTQ1NTQ29udHJvbERpcmVjdGl2ZU5vZGUkMShub2RlKSA/IFwiXCIgOiBcIiBcIiwgXCJ7XCIsIGluZGVudCQyKGNvbmNhdCQ1KFtub2RlLm5vZGVzLmxlbmd0aCA+IDAgPyBzb2Z0bGluZSQxIDogXCJcIiwgcHJpbnROb2RlU2VxdWVuY2UocGF0aCwgb3B0aW9ucywgcHJpbnQpXSkpLCBzb2Z0bGluZSQxLCBcIn1cIl0pIDogaXNUZW1wbGF0ZVBsYWNlaG9sZGVyTm9kZVdpdGhvdXRTZW1pQ29sb24gPyBcIlwiIDogXCI7XCJdKTtcbiAgICAgICAgfVxuICAgICAgLy8gcG9zdGNzcy1tZWRpYS1xdWVyeS1wYXJzZXJcblxuICAgICAgY2FzZSBcIm1lZGlhLXF1ZXJ5LWxpc3RcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgICAgcGF0aC5lYWNoKGNoaWxkUGF0aCA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2hpbGRQYXRoLmdldFZhbHVlKCk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwibWVkaWEtcXVlcnlcIiAmJiBub2RlLnZhbHVlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMucHVzaChjaGlsZFBhdGguY2FsbChwcmludCkpO1xuICAgICAgICAgIH0sIFwibm9kZXNcIik7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJDEoaW5kZW50JDIoam9pbiQyKGxpbmUkMiwgcGFydHMpKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIm1lZGlhLXF1ZXJ5XCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW2pvaW4kMihcIiBcIiwgcGF0aC5tYXAocHJpbnQsIFwibm9kZXNcIikpLCBpc0xhc3ROb2RlJDEocGF0aCwgbm9kZSkgPyBcIlwiIDogXCIsXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwibWVkaWEtdHlwZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGFkanVzdE51bWJlcnMoYWRqdXN0U3RyaW5ncyhub2RlLnZhbHVlLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIm1lZGlhLWZlYXR1cmUtZXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFub2RlLm5vZGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW1wiKFwiLCBjb25jYXQkNShwYXRoLm1hcChwcmludCwgXCJub2Rlc1wiKSksIFwiKVwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIm1lZGlhLWZlYXR1cmVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBtYXliZVRvTG93ZXJDYXNlJDEoYWRqdXN0U3RyaW5ncyhub2RlLnZhbHVlLnJlcGxhY2UoLyArL2csIFwiIFwiKSwgb3B0aW9ucykpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJtZWRpYS1jb2xvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLnZhbHVlLCBcIiBcIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJtZWRpYS12YWx1ZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGFkanVzdE51bWJlcnMoYWRqdXN0U3RyaW5ncyhub2RlLnZhbHVlLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIm1lZGlhLWtleXdvcmRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBhZGp1c3RTdHJpbmdzKG5vZGUudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJtZWRpYS11cmxcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBhZGp1c3RTdHJpbmdzKG5vZGUudmFsdWUucmVwbGFjZSgvXnVybFxcKFxccysvZ2ksIFwidXJsKFwiKS5yZXBsYWNlKC9cXHMrXFwpJC9naSwgXCIpXCIpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwibWVkaWEtdW5rbm93blwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIC8vIHBvc3Rjc3Mtc2VsZWN0b3ItcGFyc2VyXG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci1yb290XCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkMShjb25jYXQkNShbaW5zaWRlQXRSdWxlTm9kZSQxKHBhdGgsIFwiY3VzdG9tLXNlbGVjdG9yXCIpID8gY29uY2F0JDUoW2dldEFuY2VzdG9yTm9kZSQxKHBhdGgsIFwiY3NzLWF0cnVsZVwiKS5jdXN0b21TZWxlY3RvciwgbGluZSQyXSkgOiBcIlwiLCBqb2luJDIoY29uY2F0JDUoW1wiLFwiLCBpbnNpZGVBdFJ1bGVOb2RlJDEocGF0aCwgW1wiZXh0ZW5kXCIsIFwiY3VzdG9tLXNlbGVjdG9yXCIsIFwibmVzdFwiXSkgPyBsaW5lJDIgOiBoYXJkbGluZSQ0XSksIHBhdGgubWFwKHByaW50LCBcIm5vZGVzXCIpKV0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwic2VsZWN0b3Itc2VsZWN0b3JcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBncm91cCQxKGluZGVudCQyKGNvbmNhdCQ1KHBhdGgubWFwKHByaW50LCBcIm5vZGVzXCIpKSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci1jb21tZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwic2VsZWN0b3Itc3RyaW5nXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gYWRqdXN0U3RyaW5ncyhub2RlLnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwic2VsZWN0b3ItdGFnXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnROb2RlICYmIHBhcmVudE5vZGUubm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICBjb25zdCBwcmV2Tm9kZSA9IGluZGV4ICYmIHBhcmVudE5vZGUubm9kZXNbaW5kZXggLSAxXTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW25vZGUubmFtZXNwYWNlID8gY29uY2F0JDUoW25vZGUubmFtZXNwYWNlID09PSB0cnVlID8gXCJcIiA6IG5vZGUubmFtZXNwYWNlLnRyaW0oKSwgXCJ8XCJdKSA6IFwiXCIsIHByZXZOb2RlLnR5cGUgPT09IFwic2VsZWN0b3ItbmVzdGluZ1wiID8gbm9kZS52YWx1ZSA6IGFkanVzdE51bWJlcnMoaXNLZXlmcmFtZUF0UnVsZUtleXdvcmRzJDEocGF0aCwgbm9kZS52YWx1ZSkgPyBub2RlLnZhbHVlLnRvTG93ZXJDYXNlKCkgOiBub2RlLnZhbHVlKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci1pZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtcIiNcIiwgbm9kZS52YWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci1jbGFzc1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtcIi5cIiwgYWRqdXN0TnVtYmVycyhhZGp1c3RTdHJpbmdzKG5vZGUudmFsdWUsIG9wdGlvbnMpKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci1hdHRyaWJ1dGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNShbXCJbXCIsIG5vZGUubmFtZXNwYWNlID8gY29uY2F0JDUoW25vZGUubmFtZXNwYWNlID09PSB0cnVlID8gXCJcIiA6IG5vZGUubmFtZXNwYWNlLnRyaW0oKSwgXCJ8XCJdKSA6IFwiXCIsIG5vZGUuYXR0cmlidXRlLnRyaW0oKSwgbm9kZS5vcGVyYXRvciA/IG5vZGUub3BlcmF0b3IgOiBcIlwiLCBub2RlLnZhbHVlID8gcXVvdGVBdHRyaWJ1dGVWYWx1ZShhZGp1c3RTdHJpbmdzKG5vZGUudmFsdWUudHJpbSgpLCBvcHRpb25zKSwgb3B0aW9ucykgOiBcIlwiLCBub2RlLmluc2Vuc2l0aXZlID8gXCIgaVwiIDogXCJcIiwgXCJdXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwic2VsZWN0b3ItY29tYmluYXRvclwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG5vZGUudmFsdWUgPT09IFwiK1wiIHx8IG5vZGUudmFsdWUgPT09IFwiPlwiIHx8IG5vZGUudmFsdWUgPT09IFwiflwiIHx8IG5vZGUudmFsdWUgPT09IFwiPj4+XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmcgPSBwYXJlbnROb2RlLnR5cGUgPT09IFwic2VsZWN0b3Itc2VsZWN0b3JcIiAmJiBwYXJlbnROb2RlLm5vZGVzWzBdID09PSBub2RlID8gXCJcIiA6IGxpbmUkMjtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkNShbbGVhZGluZywgbm9kZS52YWx1ZSwgaXNMYXN0Tm9kZSQxKHBhdGgsIG5vZGUpID8gXCJcIiA6IFwiIFwiXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbGVhZGluZyA9IG5vZGUudmFsdWUudHJpbSgpLnN0YXJ0c1dpdGgoXCIoXCIpID8gbGluZSQyIDogXCJcIjtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGFkanVzdE51bWJlcnMoYWRqdXN0U3RyaW5ncyhub2RlLnZhbHVlLnRyaW0oKSwgb3B0aW9ucykpIHx8IGxpbmUkMjtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW2xlYWRpbmcsIHZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLXVuaXZlcnNhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLm5hbWVzcGFjZSA/IGNvbmNhdCQ1KFtub2RlLm5hbWVzcGFjZSA9PT0gdHJ1ZSA/IFwiXCIgOiBub2RlLm5hbWVzcGFjZS50cmltKCksIFwifFwiXSkgOiBcIlwiLCBub2RlLnZhbHVlXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLXBzZXVkb1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFttYXliZVRvTG93ZXJDYXNlJDEobm9kZS52YWx1ZSksIG5vZGUubm9kZXMgJiYgbm9kZS5ub2Rlcy5sZW5ndGggPiAwID8gY29uY2F0JDUoW1wiKFwiLCBqb2luJDIoXCIsIFwiLCBwYXRoLm1hcChwcmludCwgXCJub2Rlc1wiKSksIFwiKVwiXSkgOiBcIlwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInNlbGVjdG9yLW5lc3RpbmdcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZWxlY3Rvci11bmtub3duXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBydWxlQW5jZXN0b3JOb2RlID0gZ2V0QW5jZXN0b3JOb2RlJDEocGF0aCwgXCJjc3MtcnVsZVwiKTsgLy8gTmVzdGVkIFNDU1MgcHJvcGVydHlcblxuICAgICAgICAgIGlmIChydWxlQW5jZXN0b3JOb2RlICYmIHJ1bGVBbmNlc3Rvck5vZGUuaXNTQ1NTTmVzdGVyUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGp1c3ROdW1iZXJzKGFkanVzdFN0cmluZ3MobWF5YmVUb0xvd2VyQ2FzZSQxKG5vZGUudmFsdWUpLCBvcHRpb25zKSk7XG4gICAgICAgICAgfSAvLyBvcmlnaW5hbFRleHQgaGFzIHRvIGJlIHVzZWQgZm9yIExlc3MsIHNlZSByZXBsYWNlUXVvdGVzSW5JbmxpbmVDb21tZW50cyBpbiBsb2MuanNcblxuXG4gICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgICAgICAgaWYgKHBhcmVudE5vZGUucmF3cyAmJiBwYXJlbnROb2RlLnJhd3Muc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5sb2NTdGFydChwYXJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgcGFyZW50Tm9kZS5yYXdzLnNlbGVjdG9yLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShzdGFydCwgZW5kKS50cmltKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIC8vIHBvc3Rjc3MtdmFsdWVzLXBhcnNlclxuXG4gICAgICBjYXNlIFwidmFsdWUtdmFsdWVcIjpcbiAgICAgIGNhc2UgXCJ2YWx1ZS1yb290XCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcImdyb3VwXCIpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ2YWx1ZS1jb21tZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW25vZGUuaW5saW5lID8gXCIvL1wiIDogXCIvKlwiLCAvLyBzZWUgcmVwbGFjZVF1b3Rlc0luSW5saW5lQ29tbWVudHMgaW4gbG9jLmpzXG4gICAgICAgICAgLy8gdmFsdWUtKiBub2RlcyBkb24ndCBoYXZlIGNvcnJlY3QgbG9jYXRpb24gZGF0YSwgc28gd2UgaGF2ZSB0byByZWx5IG9uIHBsYWNlaG9sZGVyIGNoYXJhY3RlcnMuXG4gICAgICAgICAgcmVzdG9yZVF1b3Rlc0luSW5saW5lQ29tbWVudHMkMShub2RlLnZhbHVlKSwgbm9kZS5pbmxpbmUgPyBcIlwiIDogXCIqL1wiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLWNvbW1hX2dyb3VwXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICAgICAgY29uc3QgcGFyZW50UGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcbiAgICAgICAgICBjb25zdCBkZWNsQW5jZXN0b3JQcm9wID0gZ2V0UHJvcE9mRGVjbE5vZGUkMShwYXRoKTtcbiAgICAgICAgICBjb25zdCBpc0dyaWRWYWx1ZSA9IGRlY2xBbmNlc3RvclByb3AgJiYgcGFyZW50Tm9kZS50eXBlID09PSBcInZhbHVlLXZhbHVlXCIgJiYgKGRlY2xBbmNlc3RvclByb3AgPT09IFwiZ3JpZFwiIHx8IGRlY2xBbmNlc3RvclByb3Auc3RhcnRzV2l0aChcImdyaWQtdGVtcGxhdGVcIikpO1xuICAgICAgICAgIGNvbnN0IGF0UnVsZUFuY2VzdG9yTm9kZSA9IGdldEFuY2VzdG9yTm9kZSQxKHBhdGgsIFwiY3NzLWF0cnVsZVwiKTtcbiAgICAgICAgICBjb25zdCBpc0NvbnRyb2xEaXJlY3RpdmUgPSBhdFJ1bGVBbmNlc3Rvck5vZGUgJiYgaXNTQ1NTQ29udHJvbERpcmVjdGl2ZU5vZGUkMShhdFJ1bGVBbmNlc3Rvck5vZGUpO1xuICAgICAgICAgIGNvbnN0IHByaW50ZWQgPSBwYXRoLm1hcChwcmludCwgXCJncm91cHNcIik7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgICBjb25zdCBpbnNpZGVVUkxGdW5jdGlvbiA9IGluc2lkZVZhbHVlRnVuY3Rpb25Ob2RlJDEocGF0aCwgXCJ1cmxcIik7XG4gICAgICAgICAgbGV0IGluc2lkZVNDU1NJbnRlcnBvbGF0aW9uSW5TdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgZGlkQnJlYWsgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5ncm91cHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnRlZFtpXSk7XG4gICAgICAgICAgICBjb25zdCBpUHJldk5vZGUgPSBub2RlLmdyb3Vwc1tpIC0gMV07XG4gICAgICAgICAgICBjb25zdCBpTm9kZSA9IG5vZGUuZ3JvdXBzW2ldO1xuICAgICAgICAgICAgY29uc3QgaU5leHROb2RlID0gbm9kZS5ncm91cHNbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgaU5leHROZXh0Tm9kZSA9IG5vZGUuZ3JvdXBzW2kgKyAyXTtcblxuICAgICAgICAgICAgaWYgKGluc2lkZVVSTEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChpTmV4dE5vZGUgJiYgaXNBZGRpdGlvbk5vZGUkMShpTmV4dE5vZGUpIHx8IGlzQWRkaXRpb25Ob2RlJDEoaU5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChcIiBcIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gSWdub3JlIGFmdGVyIGxhdGVzdCBub2RlIChpLmUuIGJlZm9yZSBzZW1pY29sb24pXG5cblxuICAgICAgICAgICAgaWYgKCFpTmV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIHN0eWxlZC5kaXZgIGJhY2tncm91bmQ6IHZhcigtLSR7b25lfSk7IGBcblxuXG4gICAgICAgICAgICBpZiAoIWlQcmV2Tm9kZSAmJiBpTm9kZS52YWx1ZSA9PT0gXCItLVwiICYmIGlOZXh0Tm9kZS50eXBlID09PSBcInZhbHVlLWF0d29yZFwiKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBJZ25vcmUgc3BhY2VzIGJlZm9yZS9hZnRlciBzdHJpbmcgaW50ZXJwb2xhdGlvbiAoaS5lLiBgXCIje215LWZuKFwiX1wiKX1cImApXG5cblxuICAgICAgICAgICAgY29uc3QgaXNTdGFydFNDU1NJbnRlcnBvbGF0aW9uSW5TdHJpbmcgPSBpTm9kZS50eXBlID09PSBcInZhbHVlLXN0cmluZ1wiICYmIGlOb2RlLnZhbHVlLnN0YXJ0c1dpdGgoXCIje1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGlzRW5kaW5nU0NTU0ludGVycG9sYXRpb25JblN0cmluZyA9IGluc2lkZVNDU1NJbnRlcnBvbGF0aW9uSW5TdHJpbmcgJiYgaU5leHROb2RlLnR5cGUgPT09IFwidmFsdWUtc3RyaW5nXCIgJiYgaU5leHROb2RlLnZhbHVlLmVuZHNXaXRoKFwifVwiKTtcblxuICAgICAgICAgICAgaWYgKGlzU3RhcnRTQ1NTSW50ZXJwb2xhdGlvbkluU3RyaW5nIHx8IGlzRW5kaW5nU0NTU0ludGVycG9sYXRpb25JblN0cmluZykge1xuICAgICAgICAgICAgICBpbnNpZGVTQ1NTSW50ZXJwb2xhdGlvbkluU3RyaW5nID0gIWluc2lkZVNDU1NJbnRlcnBvbGF0aW9uSW5TdHJpbmc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5zaWRlU0NTU0ludGVycG9sYXRpb25JblN0cmluZykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gSWdub3JlIGNvbG9uIChpLmUuIGA6YClcblxuXG4gICAgICAgICAgICBpZiAoaXNDb2xvbk5vZGUkMShpTm9kZSkgfHwgaXNDb2xvbk5vZGUkMShpTmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBJZ25vcmUgYEBgIGluIExlc3MgKGkuZS4gYEBAdmFyO2ApXG5cblxuICAgICAgICAgICAgaWYgKGlOb2RlLnR5cGUgPT09IFwidmFsdWUtYXR3b3JkXCIgJiYgaU5vZGUudmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBgfmAgaW4gTGVzcyAoaS5lLiBgY29udGVudDogflwiXi8vKiBzb21lIGhvcnJpYmxlIGJ1dCBuZWVkZWQgY3NzIGhhY2tcIjtgKVxuXG5cbiAgICAgICAgICAgIGlmIChpTm9kZS52YWx1ZSA9PT0gXCJ+XCIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBlc2NhcGUgYFxcYFxuXG5cbiAgICAgICAgICAgIGlmIChpTm9kZS52YWx1ZSAmJiBpTm9kZS52YWx1ZS5pbmNsdWRlcyhcIlxcXFxcIikgJiYgaU5leHROb2RlICYmIGlOZXh0Tm9kZS50eXBlICE9PSBcInZhbHVlLWNvbW1lbnRcIikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gSWdub3JlIGVzY2FwZWQgYC9gXG5cblxuICAgICAgICAgICAgaWYgKGlQcmV2Tm9kZSAmJiBpUHJldk5vZGUudmFsdWUgJiYgaVByZXZOb2RlLnZhbHVlLmluZGV4T2YoXCJcXFxcXCIpID09PSBpUHJldk5vZGUudmFsdWUubGVuZ3RoIC0gMSAmJiBpTm9kZS50eXBlID09PSBcInZhbHVlLW9wZXJhdG9yXCIgJiYgaU5vZGUudmFsdWUgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBJZ25vcmUgYFxcYCAoaS5lLiBgJHZhcmlhYmxlOiBcXEBzbWFsbDtgKVxuXG5cbiAgICAgICAgICAgIGlmIChpTm9kZS52YWx1ZSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBgJCRgIChpLmUuIGBiYWNrZ3JvdW5kLWNvbG9yOiAkJChzdHlsZSlDb2xvcjtgKVxuXG5cbiAgICAgICAgICAgIGlmIChpc1Bvc3Rjc3NTaW1wbGVWYXJOb2RlJDEoaU5vZGUsIGlOZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBzcGFjZXMgYWZ0ZXIgYCNgIGFuZCBhZnRlciBge2AgYW5kIGJlZm9yZSBgfWAgaW4gU0NTUyBpbnRlcnBvbGF0aW9uIChpLmUuIGAje3ZhcmlhYmxlfWApXG5cblxuICAgICAgICAgICAgaWYgKGlzSGFzaE5vZGUkMShpTm9kZSkgfHwgaXNMZWZ0Q3VybHlCcmFjZU5vZGUkMShpTm9kZSkgfHwgaXNSaWdodEN1cmx5QnJhY2VOb2RlJDEoaU5leHROb2RlKSB8fCBpc0xlZnRDdXJseUJyYWNlTm9kZSQxKGlOZXh0Tm9kZSkgJiYgaGFzRW1wdHlSYXdCZWZvcmUkMShpTmV4dE5vZGUpIHx8IGlzUmlnaHRDdXJseUJyYWNlTm9kZSQxKGlOb2RlKSAmJiBoYXNFbXB0eVJhd0JlZm9yZSQxKGlOZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBjc3MgdmFyaWFibGVzIGFuZCBpbnRlcnBvbGF0aW9uIGluIFNDU1MgKGkuZS4gYC0tI3skdmFyfWApXG5cblxuICAgICAgICAgICAgaWYgKGlOb2RlLnZhbHVlID09PSBcIi0tXCIgJiYgaXNIYXNoTm9kZSQxKGlOZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIEZvcm1hdHRpbmcgbWF0aCBvcGVyYXRpb25zXG5cblxuICAgICAgICAgICAgY29uc3QgaXNNYXRoT3BlcmF0b3IgPSBpc01hdGhPcGVyYXRvck5vZGUkMShpTm9kZSk7XG4gICAgICAgICAgICBjb25zdCBpc05leHRNYXRoT3BlcmF0b3IgPSBpc01hdGhPcGVyYXRvck5vZGUkMShpTmV4dE5vZGUpOyAvLyBQcmludCBzcGFjZXMgYmVmb3JlIGFuZCBhZnRlciBtYXRoIG9wZXJhdG9ycyBiZXNpZGUgU0NTUyBpbnRlcnBvbGF0aW9uIGFzIGlzXG4gICAgICAgICAgICAvLyAoaS5lLiBgI3skdmFyfSs1YCwgYCN7JHZhcn0gKzVgLCBgI3skdmFyfSsgNWAsIGAjeyR2YXJ9ICsgNWApXG4gICAgICAgICAgICAvLyAoaS5lLiBgNSsjeyR2YXJ9YCwgYDUgKyN7JHZhcn1gLCBgNSsgI3skdmFyfWAsIGA1ICsgI3skdmFyfWApXG5cbiAgICAgICAgICAgIGlmICgoaXNNYXRoT3BlcmF0b3IgJiYgaXNIYXNoTm9kZSQxKGlOZXh0Tm9kZSkgfHwgaXNOZXh0TWF0aE9wZXJhdG9yICYmIGlzUmlnaHRDdXJseUJyYWNlTm9kZSQxKGlOb2RlKSkgJiYgaGFzRW1wdHlSYXdCZWZvcmUkMShpTmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBQcmludCBzcGFjZXMgYmVmb3JlIGFuZCBhZnRlciBhZGRpdGlvbiBhbmQgc3VidHJhY3Rpb24gbWF0aCBvcGVyYXRvcnMgYXMgaXMgaW4gYGNhbGNgIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBkdWUgdG8gdGhlIGZhY3QgdGhhdCBpdCBpcyBub3QgdmFsaWQgc3ludGF4XG4gICAgICAgICAgICAvLyAoaS5lLiBgY2FsYygxcHgrMXB4KWAsIGBjYWxjKDFweCsgMXB4KWAsIGBjYWxjKDFweCArMXB4KWAsIGBjYWxjKDFweCArIDFweClgKVxuXG5cbiAgICAgICAgICAgIGlmIChpbnNpZGVWYWx1ZUZ1bmN0aW9uTm9kZSQxKHBhdGgsIFwiY2FsY1wiKSAmJiAoaXNBZGRpdGlvbk5vZGUkMShpTm9kZSkgfHwgaXNBZGRpdGlvbk5vZGUkMShpTmV4dE5vZGUpIHx8IGlzU3VidHJhY3Rpb25Ob2RlJDEoaU5vZGUpIHx8IGlzU3VidHJhY3Rpb25Ob2RlJDEoaU5leHROb2RlKSkgJiYgaGFzRW1wdHlSYXdCZWZvcmUkMShpTmV4dE5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBQcmludCBzcGFjZXMgYWZ0ZXIgYCtgIGFuZCBgLWAgaW4gY29sb3IgYWRqdXN0ZXIgZnVuY3Rpb25zIGFzIGlzIChlLmcuIGBjb2xvcihyZWQgbCgrIDIwJSkpYClcbiAgICAgICAgICAgIC8vIEFkanVzdGVycyB3aXRoIHNpZ25lZCBudW1iZXJzIChlLmcuIGBjb2xvcihyZWQgbCgrMjAlKSlgKSBvdXRwdXQgYXMtaXMuXG5cblxuICAgICAgICAgICAgY29uc3QgaXNDb2xvckFkanVzdGVyTm9kZSA9IChpc0FkZGl0aW9uTm9kZSQxKGlOb2RlKSB8fCBpc1N1YnRyYWN0aW9uTm9kZSQxKGlOb2RlKSkgJiYgaSA9PT0gMCAmJiAoaU5leHROb2RlLnR5cGUgPT09IFwidmFsdWUtbnVtYmVyXCIgfHwgaU5leHROb2RlLmlzSGV4KSAmJiBwYXJlbnRQYXJlbnROb2RlICYmIGlzQ29sb3JBZGp1c3RlckZ1bmNOb2RlJDEocGFyZW50UGFyZW50Tm9kZSkgJiYgIWhhc0VtcHR5UmF3QmVmb3JlJDEoaU5leHROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVTcGFjZUJlZm9yZU9wZXJhdG9yID0gaU5leHROZXh0Tm9kZSAmJiBpTmV4dE5leHROb2RlLnR5cGUgPT09IFwidmFsdWUtZnVuY1wiIHx8IGlOZXh0TmV4dE5vZGUgJiYgaXNXb3JkTm9kZSQxKGlOZXh0TmV4dE5vZGUpIHx8IGlOb2RlLnR5cGUgPT09IFwidmFsdWUtZnVuY1wiIHx8IGlzV29yZE5vZGUkMShpTm9kZSk7XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlU3BhY2VBZnRlck9wZXJhdG9yID0gaU5leHROb2RlLnR5cGUgPT09IFwidmFsdWUtZnVuY1wiIHx8IGlzV29yZE5vZGUkMShpTmV4dE5vZGUpIHx8IGlQcmV2Tm9kZSAmJiBpUHJldk5vZGUudHlwZSA9PT0gXCJ2YWx1ZS1mdW5jXCIgfHwgaVByZXZOb2RlICYmIGlzV29yZE5vZGUkMShpUHJldk5vZGUpOyAvLyBGb3JtYXR0aW5nIGAvYCwgYCtgLCBgLWAgc2lnblxuXG4gICAgICAgICAgICBpZiAoIShpc011bHRpcGxpY2F0aW9uTm9kZSQxKGlOZXh0Tm9kZSkgfHwgaXNNdWx0aXBsaWNhdGlvbk5vZGUkMShpTm9kZSkpICYmICFpbnNpZGVWYWx1ZUZ1bmN0aW9uTm9kZSQxKHBhdGgsIFwiY2FsY1wiKSAmJiAhaXNDb2xvckFkanVzdGVyTm9kZSAmJiAoaXNEaXZpc2lvbk5vZGUkMShpTmV4dE5vZGUpICYmICFyZXF1aXJlU3BhY2VCZWZvcmVPcGVyYXRvciB8fCBpc0RpdmlzaW9uTm9kZSQxKGlOb2RlKSAmJiAhcmVxdWlyZVNwYWNlQWZ0ZXJPcGVyYXRvciB8fCBpc0FkZGl0aW9uTm9kZSQxKGlOZXh0Tm9kZSkgJiYgIXJlcXVpcmVTcGFjZUJlZm9yZU9wZXJhdG9yIHx8IGlzQWRkaXRpb25Ob2RlJDEoaU5vZGUpICYmICFyZXF1aXJlU3BhY2VBZnRlck9wZXJhdG9yIHx8IGlzU3VidHJhY3Rpb25Ob2RlJDEoaU5leHROb2RlKSB8fCBpc1N1YnRyYWN0aW9uTm9kZSQxKGlOb2RlKSkgJiYgKGhhc0VtcHR5UmF3QmVmb3JlJDEoaU5leHROb2RlKSB8fCBpc01hdGhPcGVyYXRvciAmJiAoIWlQcmV2Tm9kZSB8fCBpUHJldk5vZGUgJiYgaXNNYXRoT3BlcmF0b3JOb2RlJDEoaVByZXZOb2RlKSkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBBZGQgYGhhcmRsaW5lYCBhZnRlciBpbmxpbmUgY29tbWVudCAoaS5lLiBgLy8gY29tbWVudFxcbiBmb286IGJhcjtgKVxuXG5cbiAgICAgICAgICAgIGlmIChpc0lubGluZVZhbHVlQ29tbWVudE5vZGUkMShpTm9kZSkpIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSQ0KTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIEhhbmRsZSBrZXl3b3JkcyBpbiBTQ1NTIGNvbnRyb2wgZGlyZWN0aXZlXG5cblxuICAgICAgICAgICAgaWYgKGlzQ29udHJvbERpcmVjdGl2ZSAmJiAoaXNFcXVhbGl0eU9wZXJhdG9yTm9kZSQxKGlOZXh0Tm9kZSkgfHwgaXNSZWxhdGlvbmFsT3BlcmF0b3JOb2RlJDEoaU5leHROb2RlKSB8fCBpc0lmRWxzZUtleXdvcmROb2RlJDEoaU5leHROb2RlKSB8fCBpc0VhY2hLZXl3b3JkTm9kZSQxKGlOb2RlKSB8fCBpc0ZvcktleXdvcmROb2RlJDEoaU5vZGUpKSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIEF0LXJ1bGUgYG5hbWVzcGFjZWAgc2hvdWxkIGJlIGluIG9uZSBsaW5lXG5cblxuICAgICAgICAgICAgaWYgKGF0UnVsZUFuY2VzdG9yTm9kZSAmJiBhdFJ1bGVBbmNlc3Rvck5vZGUubmFtZS50b0xvd2VyQ2FzZSgpID09PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gRm9ybWF0dGluZyBgZ3JpZGAgcHJvcGVydHlcblxuXG4gICAgICAgICAgICBpZiAoaXNHcmlkVmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKGlOb2RlLnNvdXJjZSAmJiBpTmV4dE5vZGUuc291cmNlICYmIGlOb2RlLnNvdXJjZS5zdGFydC5saW5lICE9PSBpTmV4dE5vZGUuc291cmNlLnN0YXJ0LmxpbmUpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDQpO1xuICAgICAgICAgICAgICAgIGRpZEJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBBZGQgYHNwYWNlYCBiZWZvcmUgbmV4dCBtYXRoIG9wZXJhdGlvblxuICAgICAgICAgICAgLy8gTm90ZTogYGdyaXBgIHByb3BlcnR5IGhhdmUgYC9gIGRlbGltaXRlciBhbmQgaXQgaXMgbm90IG1hdGggb3BlcmF0aW9uLCBzb1xuICAgICAgICAgICAgLy8gYGdyaWRgIHByb3BlcnR5IGhhbmRsZXMgYWJvdmVcblxuXG4gICAgICAgICAgICBpZiAoaXNOZXh0TWF0aE9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gLy8gQmUgZGVmYXVsdCBhbGwgdmFsdWVzIGdvIHRocm91Z2ggYGxpbmVgXG5cblxuICAgICAgICAgICAgcGFydHMucHVzaChsaW5lJDIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaWRCcmVhaykge1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdChoYXJkbGluZSQ0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNDb250cm9sRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAkMShpbmRlbnQkMihjb25jYXQkNShwYXJ0cykpKTtcbiAgICAgICAgICB9IC8vIEluZGVudCBpcyBub3QgbmVlZGVkIGZvciBpbXBvcnQgdXJsIHdoZW4gdXJsIGlzIHZlcnkgbG9uZ1xuICAgICAgICAgIC8vIGFuZCBub2RlIGhhcyB0d28gZ3JvdXBzXG4gICAgICAgICAgLy8gd2hlbiB0eXBlIGlzIHZhbHVlLWNvbW1hX2dyb3VwXG4gICAgICAgICAgLy8gZXhhbXBsZSBAaW1wb3J0IHVybChcInZlcnlsb25ndXJsXCIpIHByb2plY3Rpb24sdHZcblxuXG4gICAgICAgICAgaWYgKGluc2lkZVVSTEZ1bmN0aW9uSW5JbXBvcnRBdFJ1bGVOb2RlJDEocGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cCQxKGZpbGwkMihwYXJ0cykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCQxKGluZGVudCQyKGZpbGwkMihwYXJ0cykpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwidmFsdWUtcGFyZW5fZ3JvdXBcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIGlzVVJMRnVuY3Rpb25Ob2RlJDEocGFyZW50Tm9kZSkgJiYgKG5vZGUuZ3JvdXBzLmxlbmd0aCA9PT0gMSB8fCBub2RlLmdyb3Vwcy5sZW5ndGggPiAwICYmIG5vZGUuZ3JvdXBzWzBdLnR5cGUgPT09IFwidmFsdWUtY29tbWFfZ3JvdXBcIiAmJiBub2RlLmdyb3Vwc1swXS5ncm91cHMubGVuZ3RoID4gMCAmJiBub2RlLmdyb3Vwc1swXS5ncm91cHNbMF0udHlwZSA9PT0gXCJ2YWx1ZS13b3JkXCIgJiYgbm9kZS5ncm91cHNbMF0uZ3JvdXBzWzBdLnZhbHVlLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkNShbbm9kZS5vcGVuID8gcGF0aC5jYWxsKHByaW50LCBcIm9wZW5cIikgOiBcIlwiLCBqb2luJDIoXCIsXCIsIHBhdGgubWFwKHByaW50LCBcImdyb3Vwc1wiKSksIG5vZGUuY2xvc2UgPyBwYXRoLmNhbGwocHJpbnQsIFwiY2xvc2VcIikgOiBcIlwiXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFub2RlLm9wZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHByaW50ZWQgPSBwYXRoLm1hcChwcmludCwgXCJncm91cHNcIik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmludGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goY29uY2F0JDUoW1wiLFwiLCBsaW5lJDJdKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXMucHVzaChwcmludGVkW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJDEoaW5kZW50JDIoZmlsbCQyKHJlcykpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpc1NDU1NNYXBJdGVtID0gaXNTQ1NTTWFwSXRlbU5vZGUkMShwYXRoKTtcbiAgICAgICAgICBjb25zdCBsYXN0SXRlbSA9IG5vZGUuZ3JvdXBzW25vZGUuZ3JvdXBzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGNvbnN0IGlzTGFzdEl0ZW1Db21tZW50ID0gbGFzdEl0ZW0gJiYgbGFzdEl0ZW0udHlwZSA9PT0gXCJ2YWx1ZS1jb21tZW50XCI7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJDEoY29uY2F0JDUoW25vZGUub3BlbiA/IHBhdGguY2FsbChwcmludCwgXCJvcGVuXCIpIDogXCJcIiwgaW5kZW50JDIoY29uY2F0JDUoW3NvZnRsaW5lJDEsIGpvaW4kMihjb25jYXQkNShbXCIsXCIsIGxpbmUkMl0pLCBwYXRoLm1hcChjaGlsZFBhdGggPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgY29uc3QgcHJpbnRlZCA9IHByaW50KGNoaWxkUGF0aCk7IC8vIEtleS9WYWx1ZSBwYWlyIGluIG9wZW4gcGFyZW4gYWxyZWFkeSBpbmRlbnRlZFxuXG4gICAgICAgICAgICBpZiAoaXNLZXlWYWx1ZVBhaXJOb2RlJDEobm9kZSkgJiYgbm9kZS50eXBlID09PSBcInZhbHVlLWNvbW1hX2dyb3VwXCIgJiYgbm9kZS5ncm91cHMgJiYgbm9kZS5ncm91cHNbMl0gJiYgbm9kZS5ncm91cHNbMl0udHlwZSA9PT0gXCJ2YWx1ZS1wYXJlbl9ncm91cFwiKSB7XG4gICAgICAgICAgICAgIHByaW50ZWQuY29udGVudHMuY29udGVudHMucGFydHNbMV0gPSBncm91cCQxKHByaW50ZWQuY29udGVudHMuY29udGVudHMucGFydHNbMV0pO1xuICAgICAgICAgICAgICByZXR1cm4gZ3JvdXAkMShkZWRlbnQkMShwcmludGVkKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcmludGVkO1xuICAgICAgICAgIH0sIFwiZ3JvdXBzXCIpKV0pKSwgaWZCcmVhayQxKCFpc0xhc3RJdGVtQ29tbWVudCAmJiBpc1NDU1MkMShvcHRpb25zLnBhcnNlciwgb3B0aW9ucy5vcmlnaW5hbFRleHQpICYmIGlzU0NTU01hcEl0ZW0gJiYgc2hvdWxkUHJpbnRDb21tYShvcHRpb25zKSA/IFwiLFwiIDogXCJcIiksIHNvZnRsaW5lJDEsIG5vZGUuY2xvc2UgPyBwYXRoLmNhbGwocHJpbnQsIFwiY2xvc2VcIikgOiBcIlwiXSksIHtcbiAgICAgICAgICAgIHNob3VsZEJyZWFrOiBpc1NDU1NNYXBJdGVtXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLWZ1bmNcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNShbbm9kZS52YWx1ZSwgaW5zaWRlQXRSdWxlTm9kZSQxKHBhdGgsIFwic3VwcG9ydHNcIikgJiYgaXNNZWRpYUFuZFN1cHBvcnRzS2V5d29yZHMkMShub2RlKSA/IFwiIFwiIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcImdyb3VwXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLXBhcmVuXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwidmFsdWUtbnVtYmVyXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW3ByaW50Q3NzTnVtYmVyKG5vZGUudmFsdWUpLCBtYXliZVRvTG93ZXJDYXNlJDEobm9kZS51bml0KV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ2YWx1ZS1vcGVyYXRvclwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLXdvcmRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChub2RlLmlzQ29sb3IgJiYgbm9kZS5pc0hleCB8fCBpc1dpZGVLZXl3b3JkcyQxKG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ2YWx1ZS1jb2xvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtub2RlLnZhbHVlLCAvLyBEb24ndCBhZGQgc3BhY2VzIG9uIGA6YCBpbiBgdXJsYCBmdW5jdGlvbiAoaS5lLiBgdXJsKGZiZ2x5cGg6IGNyb3NzLW91dGxpbmUsIGZpZy13aGl0ZSlgKVxuICAgICAgICAgIGluc2lkZVZhbHVlRnVuY3Rpb25Ob2RlJDEocGF0aCwgXCJ1cmxcIikgPyBcIlwiIDogbGluZSQyXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLWNvbW1hXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDUoW25vZGUudmFsdWUsIFwiIFwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLXN0cmluZ1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHByaW50U3RyaW5nJDEobm9kZS5yYXdzLnF1b3RlICsgbm9kZS52YWx1ZSArIG5vZGUucmF3cy5xdW90ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInZhbHVlLWF0d29yZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ1KFtcIkBcIiwgbm9kZS52YWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ2YWx1ZS11bmljb2RlLXJhbmdlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwidmFsdWUtdW5rbm93blwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwb3N0Y3NzIHR5cGUgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KG5vZGUudHlwZSkpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmludE5vZGVTZXF1ZW5jZShwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgcGF0aC5tYXAocGF0aENoaWxkID0+IHtcbiAgICAgIGNvbnN0IHByZXZOb2RlID0gbm9kZS5ub2Rlc1tpIC0gMV07XG5cbiAgICAgIGlmIChwcmV2Tm9kZSAmJiBwcmV2Tm9kZS50eXBlID09PSBcImNzcy1jb21tZW50XCIgJiYgcHJldk5vZGUudGV4dC50cmltKCkgPT09IFwicHJldHRpZXItaWdub3JlXCIpIHtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlID0gcGF0aENoaWxkLmdldFZhbHVlKCk7XG4gICAgICAgIHBhcnRzLnB1c2gob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uob3B0aW9ucy5sb2NTdGFydChjaGlsZE5vZGUpLCBvcHRpb25zLmxvY0VuZChjaGlsZE5vZGUpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGhDaGlsZC5jYWxsKHByaW50KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpICE9PSBub2RlLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZXNbaSArIDFdLnR5cGUgPT09IFwiY3NzLWNvbW1lbnRcIiAmJiAhaGFzTmV3bGluZSQzKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY1N0YXJ0KG5vZGUubm9kZXNbaSArIDFdKSwge1xuICAgICAgICAgIGJhY2t3YXJkczogdHJ1ZVxuICAgICAgICB9KSAmJiBub2RlLm5vZGVzW2ldLnR5cGUgIT09IFwieWFtbFwiICYmIG5vZGUubm9kZXNbaV0udHlwZSAhPT0gXCJ0b21sXCIgfHwgbm9kZS5ub2Rlc1tpICsgMV0udHlwZSA9PT0gXCJjc3MtYXRydWxlXCIgJiYgbm9kZS5ub2Rlc1tpICsgMV0ubmFtZSA9PT0gXCJlbHNlXCIgJiYgbm9kZS5ub2Rlc1tpXS50eXBlICE9PSBcImNzcy1jb21tZW50XCIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKG9wdGlvbnMuX19pc0hUTUxTdHlsZUF0dHJpYnV0ZSA/IGxpbmUkMiA6IGhhcmRsaW5lJDQpO1xuXG4gICAgICAgICAgaWYgKGlzTmV4dExpbmVFbXB0eSQyKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBwYXRoQ2hpbGQuZ2V0VmFsdWUoKSwgb3B0aW9ucy5sb2NFbmQpICYmIG5vZGUubm9kZXNbaV0udHlwZSAhPT0gXCJ5YW1sXCIgJiYgbm9kZS5ub2Rlc1tpXS50eXBlICE9PSBcInRvbWxcIikge1xuICAgICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSQ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH0sIFwibm9kZXNcIik7XG4gICAgcmV0dXJuIGNvbmNhdCQ1KHBhcnRzKTtcbiAgfVxuXG4gIGNvbnN0IFNUUklOR19SRUdFWCQzID0gLyhbJ1wiXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcW1xcc1xcU10pKlxcMS9nO1xuICBjb25zdCBOVU1CRVJfUkVHRVggPSAvKD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2c7XG4gIGNvbnN0IFNUQU5EQVJEX1VOSVRfUkVHRVggPSAvW2EtekEtWl0rL2c7XG4gIGNvbnN0IFdPUkRfUEFSVF9SRUdFWCA9IC9bJEBdP1thLXpBLVpfXFx1MDA4MC1cXHVGRkZGXVtcXHdcXC1cXHUwMDgwLVxcdUZGRkZdKi9nO1xuICBjb25zdCBBREpVU1RfTlVNQkVSU19SRUdFWCA9IG5ldyBSZWdFeHAoU1RSSU5HX1JFR0VYJDMuc291cmNlICsgXCJ8XCIgKyBcIihcIi5jb25jYXQoV09SRF9QQVJUX1JFR0VYLnNvdXJjZSwgXCIpP1wiKSArIFwiKFwiLmNvbmNhdChOVU1CRVJfUkVHRVguc291cmNlLCBcIilcIikgKyBcIihcIi5jb25jYXQoU1RBTkRBUkRfVU5JVF9SRUdFWC5zb3VyY2UsIFwiKT9cIiksIFwiZ1wiKTtcblxuICBmdW5jdGlvbiBhZGp1c3RTdHJpbmdzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoU1RSSU5HX1JFR0VYJDMsIG1hdGNoID0+IHByaW50U3RyaW5nJDEobWF0Y2gsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdW90ZSA9IG9wdGlvbnMuc2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIic7XG4gICAgcmV0dXJuIHZhbHVlLmluY2x1ZGVzKCdcIicpIHx8IHZhbHVlLmluY2x1ZGVzKFwiJ1wiKSA/IHZhbHVlIDogcXVvdGUgKyB2YWx1ZSArIHF1b3RlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRqdXN0TnVtYmVycyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKEFESlVTVF9OVU1CRVJTX1JFR0VYLCAobWF0Y2gsIHF1b3RlLCB3b3JkUGFydCwgbnVtYmVyLCB1bml0KSA9PiAhd29yZFBhcnQgJiYgbnVtYmVyID8gcHJpbnRDc3NOdW1iZXIobnVtYmVyKSArIG1heWJlVG9Mb3dlckNhc2UkMSh1bml0IHx8IFwiXCIpIDogbWF0Y2gpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDc3NOdW1iZXIocmF3TnVtYmVyKSB7XG4gICAgcmV0dXJuIHByaW50TnVtYmVyJDEocmF3TnVtYmVyKSAvLyBSZW1vdmUgdHJhaWxpbmcgYC4wYC5cbiAgICAucmVwbGFjZSgvXFwuMCg/PSR8ZSkvLCBcIlwiKTtcbiAgfVxuXG4gIHZhciBwcmludGVyUG9zdGNzcyA9IHtcbiAgICBwcmludDogZ2VuZXJpY1ByaW50LFxuICAgIGVtYmVkOiBlbWJlZF8xLFxuICAgIGluc2VydFByYWdtYTogaW5zZXJ0UHJhZ21hJDIsXG4gICAgaGFzUHJldHRpZXJJZ25vcmU6IGhhc0lnbm9yZUNvbW1lbnQkMSxcbiAgICBtYXNzYWdlQXN0Tm9kZTogY2xlYW5fMVxuICB9O1xuXG4gIGNvbnN0IENBVEVHT1JZX0NPTU1PTiA9IFwiQ29tbW9uXCI7IC8vIGZvcm1hdCBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vcHJldHRpZXIvcHJldHRpZXIvYmxvYi9tYXN0ZXIvc3JjL21haW4vY29yZS1vcHRpb25zLmpzXG5cbiAgdmFyIGNvbW1vbk9wdGlvbnMgPSB7XG4gICAgYnJhY2tldFNwYWNpbmc6IHtcbiAgICAgIHNpbmNlOiBcIjAuMC4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfQ09NTU9OLFxuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246IFwiUHJpbnQgc3BhY2VzIGJldHdlZW4gYnJhY2tldHMuXCIsXG4gICAgICBvcHBvc2l0ZURlc2NyaXB0aW9uOiBcIkRvIG5vdCBwcmludCBzcGFjZXMgYmV0d2VlbiBicmFja2V0cy5cIlxuICAgIH0sXG4gICAgc2luZ2xlUXVvdGU6IHtcbiAgICAgIHNpbmNlOiBcIjAuMC4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfQ09NTU9OLFxuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlVzZSBzaW5nbGUgcXVvdGVzIGluc3RlYWQgb2YgZG91YmxlIHF1b3Rlcy5cIlxuICAgIH0sXG4gICAgcHJvc2VXcmFwOiB7XG4gICAgICBzaW5jZTogXCIxLjguMlwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0NPTU1PTixcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBkZWZhdWx0OiBbe1xuICAgICAgICBzaW5jZTogXCIxLjguMlwiLFxuICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBzaW5jZTogXCIxLjkuMFwiLFxuICAgICAgICB2YWx1ZTogXCJwcmVzZXJ2ZVwiXG4gICAgICB9XSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkhvdyB0byB3cmFwIHByb3NlLlwiLFxuICAgICAgY2hvaWNlczogW3tcbiAgICAgICAgc2luY2U6IFwiMS45LjBcIixcbiAgICAgICAgdmFsdWU6IFwiYWx3YXlzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIldyYXAgcHJvc2UgaWYgaXQgZXhjZWVkcyB0aGUgcHJpbnQgd2lkdGguXCJcbiAgICAgIH0sIHtcbiAgICAgICAgc2luY2U6IFwiMS45LjBcIixcbiAgICAgICAgdmFsdWU6IFwibmV2ZXJcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiRG8gbm90IHdyYXAgcHJvc2UuXCJcbiAgICAgIH0sIHtcbiAgICAgICAgc2luY2U6IFwiMS45LjBcIixcbiAgICAgICAgdmFsdWU6IFwicHJlc2VydmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiV3JhcCBwcm9zZSBhcy1pcy5cIlxuICAgICAgfV1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG9wdGlvbnMkMiA9IHtcbiAgICBzaW5nbGVRdW90ZTogY29tbW9uT3B0aW9ucy5zaW5nbGVRdW90ZVxuICB9O1xuXG4gIHZhciBjcmVhdGVMYW5ndWFnZSA9IGZ1bmN0aW9uIGNyZWF0ZUxhbmd1YWdlKGxpbmd1aXN0RGF0YSwgb3ZlcnJpZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYW5ndWFnZUlkXG4gICAgfSA9IGxpbmd1aXN0RGF0YSxcbiAgICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UobGluZ3Vpc3REYXRhLCBbXCJsYW5ndWFnZUlkXCJdKTtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxpbmd1aXN0TGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZFxuICAgIH0sIHJlc3QsIHt9LCBvdmVycmlkZShsaW5ndWlzdERhdGEpKTtcbiAgfTtcblxuICB2YXIgbmFtZSQxID0gXCJDU1NcIjtcbiAgdmFyIHR5cGUgPSBcIm1hcmt1cFwiO1xuICB2YXIgdG1TY29wZSA9IFwic291cmNlLmNzc1wiO1xuICB2YXIgYWNlTW9kZSA9IFwiY3NzXCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSA9IFwiY3NzXCI7XG4gIHZhciBjb2RlbWlycm9yTWltZVR5cGUgPSBcInRleHQvY3NzXCI7XG4gIHZhciBjb2xvciA9IFwiIzU2M2Q3Y1wiO1xuICB2YXIgZXh0ZW5zaW9ucyA9IFtcbiAgXHRcIi5jc3NcIlxuICBdO1xuICB2YXIgbGFuZ3VhZ2VJZCA9IDUwO1xuICB2YXIgQ1NTID0ge1xuICBcdG5hbWU6IG5hbWUkMSxcbiAgXHR0eXBlOiB0eXBlLFxuICBcdHRtU2NvcGU6IHRtU2NvcGUsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSxcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUsXG4gIFx0Y29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUsXG4gIFx0Y29sb3I6IGNvbG9yLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMsXG4gIFx0bGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZFxuICB9O1xuXG4gIHZhciBDU1MkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSQxLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgdG1TY29wZTogdG1TY29wZSxcbiAgICBhY2VNb2RlOiBhY2VNb2RlLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSxcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSxcbiAgICBjb2xvcjogY29sb3IsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkLFxuICAgICdkZWZhdWx0JzogQ1NTXG4gIH0pO1xuXG4gIHZhciBuYW1lJDIgPSBcIlBvc3RDU1NcIjtcbiAgdmFyIHR5cGUkMSA9IFwibWFya3VwXCI7XG4gIHZhciB0bVNjb3BlJDEgPSBcInNvdXJjZS5wb3N0Y3NzXCI7XG4gIHZhciBncm91cCQyID0gXCJDU1NcIjtcbiAgdmFyIGV4dGVuc2lvbnMkMSA9IFtcbiAgXHRcIi5wY3NzXCIsXG4gIFx0XCIucG9zdGNzc1wiXG4gIF07XG4gIHZhciBhY2VNb2RlJDEgPSBcInRleHRcIjtcbiAgdmFyIGxhbmd1YWdlSWQkMSA9IDI2Mjc2NDQzNztcbiAgdmFyIFBvc3RDU1MgPSB7XG4gIFx0bmFtZTogbmFtZSQyLFxuICBcdHR5cGU6IHR5cGUkMSxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJDEsXG4gIFx0Z3JvdXA6IGdyb3VwJDIsXG4gIFx0ZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQxLFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkMSxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDFcbiAgfTtcblxuICB2YXIgUG9zdENTUyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJDIsXG4gICAgdHlwZTogdHlwZSQxLFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkMSxcbiAgICBncm91cDogZ3JvdXAkMixcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJDEsXG4gICAgYWNlTW9kZTogYWNlTW9kZSQxLFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkMSxcbiAgICAnZGVmYXVsdCc6IFBvc3RDU1NcbiAgfSk7XG5cbiAgdmFyIG5hbWUkMyA9IFwiTGVzc1wiO1xuICB2YXIgdHlwZSQyID0gXCJtYXJrdXBcIjtcbiAgdmFyIGdyb3VwJDMgPSBcIkNTU1wiO1xuICB2YXIgZXh0ZW5zaW9ucyQyID0gW1xuICBcdFwiLmxlc3NcIlxuICBdO1xuICB2YXIgdG1TY29wZSQyID0gXCJzb3VyY2UuY3NzLmxlc3NcIjtcbiAgdmFyIGFjZU1vZGUkMiA9IFwibGVzc1wiO1xuICB2YXIgY29kZW1pcnJvck1vZGUkMSA9IFwiY3NzXCI7XG4gIHZhciBjb2RlbWlycm9yTWltZVR5cGUkMSA9IFwidGV4dC9jc3NcIjtcbiAgdmFyIGxhbmd1YWdlSWQkMiA9IDE5ODtcbiAgdmFyIExlc3MgPSB7XG4gIFx0bmFtZTogbmFtZSQzLFxuICBcdHR5cGU6IHR5cGUkMixcbiAgXHRncm91cDogZ3JvdXAkMyxcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJDIsXG4gIFx0dG1TY29wZTogdG1TY29wZSQyLFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkMixcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkMSxcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQxLFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkMlxuICB9O1xuXG4gIHZhciBMZXNzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkMyxcbiAgICB0eXBlOiB0eXBlJDIsXG4gICAgZ3JvdXA6IGdyb3VwJDMsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQyLFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkMixcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDIsXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDEsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkMSxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDIsXG4gICAgJ2RlZmF1bHQnOiBMZXNzXG4gIH0pO1xuXG4gIHZhciBuYW1lJDQgPSBcIlNDU1NcIjtcbiAgdmFyIHR5cGUkMyA9IFwibWFya3VwXCI7XG4gIHZhciB0bVNjb3BlJDMgPSBcInNvdXJjZS5jc3Muc2Nzc1wiO1xuICB2YXIgZ3JvdXAkNCA9IFwiQ1NTXCI7XG4gIHZhciBhY2VNb2RlJDMgPSBcInNjc3NcIjtcbiAgdmFyIGNvZGVtaXJyb3JNb2RlJDIgPSBcImNzc1wiO1xuICB2YXIgY29kZW1pcnJvck1pbWVUeXBlJDIgPSBcInRleHQveC1zY3NzXCI7XG4gIHZhciBleHRlbnNpb25zJDMgPSBbXG4gIFx0XCIuc2Nzc1wiXG4gIF07XG4gIHZhciBsYW5ndWFnZUlkJDMgPSAzMjk7XG4gIHZhciBTQ1NTID0ge1xuICBcdG5hbWU6IG5hbWUkNCxcbiAgXHR0eXBlOiB0eXBlJDMsXG4gIFx0dG1TY29wZTogdG1TY29wZSQzLFxuICBcdGdyb3VwOiBncm91cCQ0LFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkMyxcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkMixcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQyLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkMyxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDNcbiAgfTtcblxuICB2YXIgU0NTUyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJDQsXG4gICAgdHlwZTogdHlwZSQzLFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkMyxcbiAgICBncm91cDogZ3JvdXAkNCxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDMsXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDIsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkMixcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJDMsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQzLFxuICAgICdkZWZhdWx0JzogU0NTU1xuICB9KTtcblxuICB2YXIgcmVxdWlyZSQkMCQyID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShDU1MkMSk7XG5cbiAgdmFyIHJlcXVpcmUkJDEgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKFBvc3RDU1MkMSk7XG5cbiAgdmFyIHJlcXVpcmUkJDIgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKExlc3MkMSk7XG5cbiAgdmFyIHJlcXVpcmUkJDMgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKFNDU1MkMSk7XG5cbiAgY29uc3QgbGFuZ3VhZ2VzID0gW2NyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDAkMiwgKCkgPT4gKHtcbiAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgIHBhcnNlcnM6IFtcImNzc1wiXSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wiY3NzXCJdXG4gIH0pKSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMSwgKCkgPT4gKHtcbiAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgIHBhcnNlcnM6IFtcImNzc1wiXSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wicG9zdGNzc1wiXVxuICB9KSksIGNyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDIsICgpID0+ICh7XG4gICAgc2luY2U6IFwiMS40LjBcIixcbiAgICBwYXJzZXJzOiBbXCJsZXNzXCJdLFxuICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJsZXNzXCJdXG4gIH0pKSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMywgKCkgPT4gKHtcbiAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgIHBhcnNlcnM6IFtcInNjc3NcIl0sXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInNjc3NcIl1cbiAgfSkpXTtcbiAgY29uc3QgcHJpbnRlcnMgPSB7XG4gICAgcG9zdGNzczogcHJpbnRlclBvc3Rjc3NcbiAgfTtcbiAgdmFyIGxhbmd1YWdlQ3NzID0ge1xuICAgIGxhbmd1YWdlcyxcbiAgICBvcHRpb25zOiBvcHRpb25zJDIsXG4gICAgcHJpbnRlcnNcbiAgfTtcblxuICBmdW5jdGlvbiBoYXNQcmFnbWEkMih0ZXh0KSB7XG4gICAgcmV0dXJuIC9eXFxzKiNbXlxcblxcU10qQChmb3JtYXR8cHJldHRpZXIpXFxzKihcXG58JCkvLnRlc3QodGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRQcmFnbWEkMyh0ZXh0KSB7XG4gICAgcmV0dXJuIFwiIyBAZm9ybWF0XFxuXFxuXCIgKyB0ZXh0O1xuICB9XG5cbiAgdmFyIHByYWdtYSQyID0ge1xuICAgIGhhc1ByYWdtYTogaGFzUHJhZ21hJDIsXG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkM1xuICB9O1xuXG4gIGNvbnN0IHtcbiAgICBjb25jYXQ6IGNvbmNhdCQ2LFxuICAgIGpvaW46IGpvaW4kMyxcbiAgICBoYXJkbGluZTogaGFyZGxpbmUkNSxcbiAgICBsaW5lOiBsaW5lJDMsXG4gICAgc29mdGxpbmU6IHNvZnRsaW5lJDIsXG4gICAgZ3JvdXA6IGdyb3VwJDUsXG4gICAgaW5kZW50OiBpbmRlbnQkMyxcbiAgICBpZkJyZWFrOiBpZkJyZWFrJDJcbiAgfSA9IGRvY3VtZW50LmJ1aWxkZXJzO1xuICBjb25zdCB7XG4gICAgaGFzSWdub3JlQ29tbWVudDogaGFzSWdub3JlQ29tbWVudCQyXG4gIH0gPSB1dGlsJDE7XG4gIGNvbnN0IHtcbiAgICBpc05leHRMaW5lRW1wdHk6IGlzTmV4dExpbmVFbXB0eSQzXG4gIH0gPSB1dGlsU2hhcmVkO1xuICBjb25zdCB7XG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkNFxuICB9ID0gcHJhZ21hJDI7XG5cbiAgZnVuY3Rpb24gZ2VuZXJpY1ByaW50JDEocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICBjb25zdCBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKCFuKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIHN3aXRjaCAobi5raW5kKSB7XG4gICAgICBjYXNlIFwiRG9jdW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgICAgcGF0aC5tYXAoKHBhdGhDaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goY29uY2F0JDYoW3BhdGhDaGlsZC5jYWxsKHByaW50KV0pKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBuLmRlZmluaXRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSQ1KTtcblxuICAgICAgICAgICAgICBpZiAoaXNOZXh0TGluZUVtcHR5JDMob3B0aW9ucy5vcmlnaW5hbFRleHQsIHBhdGhDaGlsZC5nZXRWYWx1ZSgpLCBvcHRpb25zLmxvY0VuZCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgXCJkZWZpbml0aW9uc1wiKTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW2NvbmNhdCQ2KHBhcnRzKSwgaGFyZGxpbmUkNV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJPcGVyYXRpb25EZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBoYXNPcGVyYXRpb24gPSBvcHRpb25zLm9yaWdpbmFsVGV4dFtvcHRpb25zLmxvY1N0YXJ0KG4pXSAhPT0gXCJ7XCI7XG4gICAgICAgICAgY29uc3QgaGFzTmFtZSA9ICEhbi5uYW1lO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbaGFzT3BlcmF0aW9uID8gbi5vcGVyYXRpb24gOiBcIlwiLCBoYXNPcGVyYXRpb24gJiYgaGFzTmFtZSA/IGNvbmNhdCQ2KFtcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIildKSA6IFwiXCIsIG4udmFyaWFibGVEZWZpbml0aW9ucyAmJiBuLnZhcmlhYmxlRGVmaW5pdGlvbnMubGVuZ3RoID8gZ3JvdXAkNShjb25jYXQkNihbXCIoXCIsIGluZGVudCQzKGNvbmNhdCQ2KFtzb2Z0bGluZSQyLCBqb2luJDMoY29uY2F0JDYoW2lmQnJlYWskMihcIlwiLCBcIiwgXCIpLCBzb2Z0bGluZSQyXSksIHBhdGgubWFwKHByaW50LCBcInZhcmlhYmxlRGVmaW5pdGlvbnNcIikpXSkpLCBzb2Z0bGluZSQyLCBcIilcIl0pKSA6IFwiXCIsIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIG4uc2VsZWN0aW9uU2V0ID8gIWhhc09wZXJhdGlvbiAmJiAhaGFzTmFtZSA/IFwiXCIgOiBcIiBcIiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJzZWxlY3Rpb25TZXRcIildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRnJhZ21lbnREZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW1wiZnJhZ21lbnQgXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBuLnZhcmlhYmxlRGVmaW5pdGlvbnMgJiYgbi52YXJpYWJsZURlZmluaXRpb25zLmxlbmd0aCA/IGdyb3VwJDUoY29uY2F0JDYoW1wiKFwiLCBpbmRlbnQkMyhjb25jYXQkNihbc29mdGxpbmUkMiwgam9pbiQzKGNvbmNhdCQ2KFtpZkJyZWFrJDIoXCJcIiwgXCIsIFwiKSwgc29mdGxpbmUkMl0pLCBwYXRoLm1hcChwcmludCwgXCJ2YXJpYWJsZURlZmluaXRpb25zXCIpKV0pKSwgc29mdGxpbmUkMiwgXCIpXCJdKSkgOiBcIlwiLCBcIiBvbiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVDb25kaXRpb25cIiksIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwic2VsZWN0aW9uU2V0XCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlNlbGVjdGlvblNldFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtcIntcIiwgaW5kZW50JDMoY29uY2F0JDYoW2hhcmRsaW5lJDUsIGpvaW4kMyhoYXJkbGluZSQ1LCBwYXRoLmNhbGwoc2VsZWN0aW9uc1BhdGggPT4gcHJpbnRTZXF1ZW5jZShzZWxlY3Rpb25zUGF0aCwgb3B0aW9ucywgcHJpbnQpLCBcInNlbGVjdGlvbnNcIikpXSkpLCBoYXJkbGluZSQ1LCBcIn1cIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJGaWVsZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJDUoY29uY2F0JDYoW24uYWxpYXMgPyBjb25jYXQkNihbcGF0aC5jYWxsKHByaW50LCBcImFsaWFzXCIpLCBcIjogXCJdKSA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBuLmFyZ3VtZW50cy5sZW5ndGggPiAwID8gZ3JvdXAkNShjb25jYXQkNihbXCIoXCIsIGluZGVudCQzKGNvbmNhdCQ2KFtzb2Z0bGluZSQyLCBqb2luJDMoY29uY2F0JDYoW2lmQnJlYWskMihcIlwiLCBcIiwgXCIpLCBzb2Z0bGluZSQyXSksIHBhdGguY2FsbChhcmdzUGF0aCA9PiBwcmludFNlcXVlbmNlKGFyZ3NQYXRoLCBvcHRpb25zLCBwcmludCksIFwiYXJndW1lbnRzXCIpKV0pKSwgc29mdGxpbmUkMiwgXCIpXCJdKSkgOiBcIlwiLCBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pLCBuLnNlbGVjdGlvblNldCA/IFwiIFwiIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcInNlbGVjdGlvblNldFwiKV0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTmFtZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG4udmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlN0cmluZ1ZhbHVlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobi5ibG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFsnXCJcIlwiJywgaGFyZGxpbmUkNSwgam9pbiQzKGhhcmRsaW5lJDUsIG4udmFsdWUucmVwbGFjZSgvXCJcIlwiL2csIFwiXFxcXCQmXCIpLnNwbGl0KFwiXFxuXCIpKSwgaGFyZGxpbmUkNSwgJ1wiXCJcIiddKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoWydcIicsIG4udmFsdWUucmVwbGFjZSgvW1wiXFxcXF0vZywgXCJcXFxcJCZcIikucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIiksICdcIiddKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiSW50VmFsdWVcIjpcbiAgICAgIGNhc2UgXCJGbG9hdFZhbHVlXCI6XG4gICAgICBjYXNlIFwiRW51bVZhbHVlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbi52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQm9vbGVhblZhbHVlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gbi52YWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJOdWxsVmFsdWVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVmFyaWFibGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbXCIkXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkxpc3RWYWx1ZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJDUoY29uY2F0JDYoW1wiW1wiLCBpbmRlbnQkMyhjb25jYXQkNihbc29mdGxpbmUkMiwgam9pbiQzKGNvbmNhdCQ2KFtpZkJyZWFrJDIoXCJcIiwgXCIsIFwiKSwgc29mdGxpbmUkMl0pLCBwYXRoLm1hcChwcmludCwgXCJ2YWx1ZXNcIikpXSkpLCBzb2Z0bGluZSQyLCBcIl1cIl0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiT2JqZWN0VmFsdWVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBncm91cCQ1KGNvbmNhdCQ2KFtcIntcIiwgb3B0aW9ucy5icmFja2V0U3BhY2luZyAmJiBuLmZpZWxkcy5sZW5ndGggPiAwID8gXCIgXCIgOiBcIlwiLCBpbmRlbnQkMyhjb25jYXQkNihbc29mdGxpbmUkMiwgam9pbiQzKGNvbmNhdCQ2KFtpZkJyZWFrJDIoXCJcIiwgXCIsIFwiKSwgc29mdGxpbmUkMl0pLCBwYXRoLm1hcChwcmludCwgXCJmaWVsZHNcIikpXSkpLCBzb2Z0bGluZSQyLCBpZkJyZWFrJDIoXCJcIiwgb3B0aW9ucy5icmFja2V0U3BhY2luZyAmJiBuLmZpZWxkcy5sZW5ndGggPiAwID8gXCIgXCIgOiBcIlwiKSwgXCJ9XCJdKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk9iamVjdEZpZWxkXCI6XG4gICAgICBjYXNlIFwiQXJndW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkRpcmVjdGl2ZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtcIkBcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIG4uYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBncm91cCQ1KGNvbmNhdCQ2KFtcIihcIiwgaW5kZW50JDMoY29uY2F0JDYoW3NvZnRsaW5lJDIsIGpvaW4kMyhjb25jYXQkNihbaWZCcmVhayQyKFwiXCIsIFwiLCBcIiksIHNvZnRsaW5lJDJdKSwgcGF0aC5jYWxsKGFyZ3NQYXRoID0+IHByaW50U2VxdWVuY2UoYXJnc1BhdGgsIG9wdGlvbnMsIHByaW50KSwgXCJhcmd1bWVudHNcIikpXSkpLCBzb2Z0bGluZSQyLCBcIilcIl0pKSA6IFwiXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTmFtZWRUeXBlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIik7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlZhcmlhYmxlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwidmFyaWFibGVcIiksIFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVcIiksIG4uZGVmYXVsdFZhbHVlID8gY29uY2F0JDYoW1wiID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJkZWZhdWx0VmFsdWVcIildKSA6IFwiXCIsIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVHlwZUV4dGVuc2lvbkRlZmluaXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbXCJleHRlbmQgXCIsIHBhdGguY2FsbChwcmludCwgXCJkZWZpbml0aW9uXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk9iamVjdFR5cGVFeHRlbnNpb25cIjpcbiAgICAgIGNhc2UgXCJPYmplY3RUeXBlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiZGVzY3JpcHRpb25cIiksIG4uZGVzY3JpcHRpb24gPyBoYXJkbGluZSQ1IDogXCJcIiwgbi5raW5kID09PSBcIk9iamVjdFR5cGVFeHRlbnNpb25cIiA/IFwiZXh0ZW5kIFwiIDogXCJcIiwgXCJ0eXBlIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgbi5pbnRlcmZhY2VzLmxlbmd0aCA+IDAgPyBjb25jYXQkNihbXCIgaW1wbGVtZW50cyBcIiwgY29uY2F0JDYocHJpbnRJbnRlcmZhY2VzKHBhdGgsIG9wdGlvbnMsIHByaW50KSldKSA6IFwiXCIsIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIG4uZmllbGRzLmxlbmd0aCA+IDAgPyBjb25jYXQkNihbXCIge1wiLCBpbmRlbnQkMyhjb25jYXQkNihbaGFyZGxpbmUkNSwgam9pbiQzKGhhcmRsaW5lJDUsIHBhdGguY2FsbChmaWVsZHNQYXRoID0+IHByaW50U2VxdWVuY2UoZmllbGRzUGF0aCwgb3B0aW9ucywgcHJpbnQpLCBcImZpZWxkc1wiKSldKSksIGhhcmRsaW5lJDUsIFwifVwiXSkgOiBcIlwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkZpZWxkRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiZGVzY3JpcHRpb25cIiksIG4uZGVzY3JpcHRpb24gPyBoYXJkbGluZSQ1IDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIG4uYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBncm91cCQ1KGNvbmNhdCQ2KFtcIihcIiwgaW5kZW50JDMoY29uY2F0JDYoW3NvZnRsaW5lJDIsIGpvaW4kMyhjb25jYXQkNihbaWZCcmVhayQyKFwiXCIsIFwiLCBcIiksIHNvZnRsaW5lJDJdKSwgcGF0aC5jYWxsKGFyZ3NQYXRoID0+IHByaW50U2VxdWVuY2UoYXJnc1BhdGgsIG9wdGlvbnMsIHByaW50KSwgXCJhcmd1bWVudHNcIikpXSkpLCBzb2Z0bGluZSQyLCBcIilcIl0pKSA6IFwiXCIsIFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVcIiksIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRGlyZWN0aXZlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiZGVzY3JpcHRpb25cIiksIG4uZGVzY3JpcHRpb24gPyBoYXJkbGluZSQ1IDogXCJcIiwgXCJkaXJlY3RpdmUgXCIsIFwiQFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgbi5hcmd1bWVudHMubGVuZ3RoID4gMCA/IGdyb3VwJDUoY29uY2F0JDYoW1wiKFwiLCBpbmRlbnQkMyhjb25jYXQkNihbc29mdGxpbmUkMiwgam9pbiQzKGNvbmNhdCQ2KFtpZkJyZWFrJDIoXCJcIiwgXCIsIFwiKSwgc29mdGxpbmUkMl0pLCBwYXRoLmNhbGwoYXJnc1BhdGggPT4gcHJpbnRTZXF1ZW5jZShhcmdzUGF0aCwgb3B0aW9ucywgcHJpbnQpLCBcImFyZ3VtZW50c1wiKSldKSksIHNvZnRsaW5lJDIsIFwiKVwiXSkpIDogXCJcIiwgbi5yZXBlYXRhYmxlID8gXCIgcmVwZWF0YWJsZVwiIDogXCJcIiwgY29uY2F0JDYoW1wiIG9uIFwiLCBqb2luJDMoXCIgfCBcIiwgcGF0aC5tYXAocHJpbnQsIFwibG9jYXRpb25zXCIpKV0pXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkVudW1UeXBlRXh0ZW5zaW9uXCI6XG4gICAgICBjYXNlIFwiRW51bVR5cGVEZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW3BhdGguY2FsbChwcmludCwgXCJkZXNjcmlwdGlvblwiKSwgbi5kZXNjcmlwdGlvbiA/IGhhcmRsaW5lJDUgOiBcIlwiLCBuLmtpbmQgPT09IFwiRW51bVR5cGVFeHRlbnNpb25cIiA/IFwiZXh0ZW5kIFwiIDogXCJcIiwgXCJlbnVtIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcHJpbnREaXJlY3RpdmVzKHBhdGgsIHByaW50LCBuKSwgbi52YWx1ZXMubGVuZ3RoID4gMCA/IGNvbmNhdCQ2KFtcIiB7XCIsIGluZGVudCQzKGNvbmNhdCQ2KFtoYXJkbGluZSQ1LCBqb2luJDMoaGFyZGxpbmUkNSwgcGF0aC5jYWxsKHZhbHVlc1BhdGggPT4gcHJpbnRTZXF1ZW5jZSh2YWx1ZXNQYXRoLCBvcHRpb25zLCBwcmludCksIFwidmFsdWVzXCIpKV0pKSwgaGFyZGxpbmUkNSwgXCJ9XCJdKSA6IFwiXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRW51bVZhbHVlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiZGVzY3JpcHRpb25cIiksIG4uZGVzY3JpcHRpb24gPyBoYXJkbGluZSQ1IDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiSW5wdXRWYWx1ZURlZmluaXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbcGF0aC5jYWxsKHByaW50LCBcImRlc2NyaXB0aW9uXCIpLCBuLmRlc2NyaXB0aW9uID8gbi5kZXNjcmlwdGlvbi5ibG9jayA/IGhhcmRsaW5lJDUgOiBsaW5lJDMgOiBcIlwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVwiKSwgbi5kZWZhdWx0VmFsdWUgPyBjb25jYXQkNihbXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImRlZmF1bHRWYWx1ZVwiKV0pIDogXCJcIiwgcHJpbnREaXJlY3RpdmVzKHBhdGgsIHByaW50LCBuKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJJbnB1dE9iamVjdFR5cGVFeHRlbnNpb25cIjpcbiAgICAgIGNhc2UgXCJJbnB1dE9iamVjdFR5cGVEZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW3BhdGguY2FsbChwcmludCwgXCJkZXNjcmlwdGlvblwiKSwgbi5kZXNjcmlwdGlvbiA/IGhhcmRsaW5lJDUgOiBcIlwiLCBuLmtpbmQgPT09IFwiSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uXCIgPyBcImV4dGVuZCBcIiA6IFwiXCIsIFwiaW5wdXQgXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pLCBuLmZpZWxkcy5sZW5ndGggPiAwID8gY29uY2F0JDYoW1wiIHtcIiwgaW5kZW50JDMoY29uY2F0JDYoW2hhcmRsaW5lJDUsIGpvaW4kMyhoYXJkbGluZSQ1LCBwYXRoLmNhbGwoZmllbGRzUGF0aCA9PiBwcmludFNlcXVlbmNlKGZpZWxkc1BhdGgsIG9wdGlvbnMsIHByaW50KSwgXCJmaWVsZHNcIikpXSkpLCBoYXJkbGluZSQ1LCBcIn1cIl0pIDogXCJcIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJTY2hlbWFEZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW1wic2NoZW1hXCIsIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIFwiIHtcIiwgbi5vcGVyYXRpb25UeXBlcy5sZW5ndGggPiAwID8gaW5kZW50JDMoY29uY2F0JDYoW2hhcmRsaW5lJDUsIGpvaW4kMyhoYXJkbGluZSQ1LCBwYXRoLmNhbGwob3BzUGF0aCA9PiBwcmludFNlcXVlbmNlKG9wc1BhdGgsIG9wdGlvbnMsIHByaW50KSwgXCJvcGVyYXRpb25UeXBlc1wiKSldKSkgOiBcIlwiLCBoYXJkbGluZSQ1LCBcIn1cIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJPcGVyYXRpb25UeXBlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwib3BlcmF0aW9uXCIpLCBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkludGVyZmFjZVR5cGVFeHRlbnNpb25cIjpcbiAgICAgIGNhc2UgXCJJbnRlcmZhY2VUeXBlRGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtwYXRoLmNhbGwocHJpbnQsIFwiZGVzY3JpcHRpb25cIiksIG4uZGVzY3JpcHRpb24gPyBoYXJkbGluZSQ1IDogXCJcIiwgbi5raW5kID09PSBcIkludGVyZmFjZVR5cGVFeHRlbnNpb25cIiA/IFwiZXh0ZW5kIFwiIDogXCJcIiwgXCJpbnRlcmZhY2UgXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpLCBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pLCBuLmZpZWxkcy5sZW5ndGggPiAwID8gY29uY2F0JDYoW1wiIHtcIiwgaW5kZW50JDMoY29uY2F0JDYoW2hhcmRsaW5lJDUsIGpvaW4kMyhoYXJkbGluZSQ1LCBwYXRoLmNhbGwoZmllbGRzUGF0aCA9PiBwcmludFNlcXVlbmNlKGZpZWxkc1BhdGgsIG9wdGlvbnMsIHByaW50KSwgXCJmaWVsZHNcIikpXSkpLCBoYXJkbGluZSQ1LCBcIn1cIl0pIDogXCJcIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJGcmFnbWVudFNwcmVhZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtcIi4uLlwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcHJpbnREaXJlY3RpdmVzKHBhdGgsIHByaW50LCBuKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJJbmxpbmVGcmFnbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ2KFtcIi4uLlwiLCBuLnR5cGVDb25kaXRpb24gPyBjb25jYXQkNihbXCIgb24gXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQ29uZGl0aW9uXCIpXSkgOiBcIlwiLCBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pLCBcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInNlbGVjdGlvblNldFwiKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJVbmlvblR5cGVFeHRlbnNpb25cIjpcbiAgICAgIGNhc2UgXCJVbmlvblR5cGVEZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkNShjb25jYXQkNihbcGF0aC5jYWxsKHByaW50LCBcImRlc2NyaXB0aW9uXCIpLCBuLmRlc2NyaXB0aW9uID8gaGFyZGxpbmUkNSA6IFwiXCIsIGdyb3VwJDUoY29uY2F0JDYoW24ua2luZCA9PT0gXCJVbmlvblR5cGVFeHRlbnNpb25cIiA/IFwiZXh0ZW5kIFwiIDogXCJcIiwgXCJ1bmlvbiBcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbiksIG4udHlwZXMubGVuZ3RoID4gMCA/IGNvbmNhdCQ2KFtcIiA9XCIsIGlmQnJlYWskMihcIlwiLCBcIiBcIiksIGluZGVudCQzKGNvbmNhdCQ2KFtpZkJyZWFrJDIoY29uY2F0JDYoW2xpbmUkMywgXCIgIFwiXSkpLCBqb2luJDMoY29uY2F0JDYoW2xpbmUkMywgXCJ8IFwiXSksIHBhdGgubWFwKHByaW50LCBcInR5cGVzXCIpKV0pKV0pIDogXCJcIl0pKV0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiU2NhbGFyVHlwZUV4dGVuc2lvblwiOlxuICAgICAgY2FzZSBcIlNjYWxhclR5cGVEZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW3BhdGguY2FsbChwcmludCwgXCJkZXNjcmlwdGlvblwiKSwgbi5kZXNjcmlwdGlvbiA/IGhhcmRsaW5lJDUgOiBcIlwiLCBuLmtpbmQgPT09IFwiU2NhbGFyVHlwZUV4dGVuc2lvblwiID8gXCJleHRlbmQgXCIgOiBcIlwiLCBcInNjYWxhciBcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIHByaW50RGlyZWN0aXZlcyhwYXRoLCBwcmludCwgbildKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTm9uTnVsbFR5cGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNihbcGF0aC5jYWxsKHByaW50LCBcInR5cGVcIiksIFwiIVwiXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkxpc3RUeXBlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDYoW1wiW1wiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVwiKSwgXCJdXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGdyYXBocWwgdHlwZTogXCIgKyBKU09OLnN0cmluZ2lmeShuLmtpbmQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmludERpcmVjdGl2ZXMocGF0aCwgcHJpbnQsIG4pIHtcbiAgICBpZiAobi5kaXJlY3RpdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmNhdCQ2KFtcIiBcIiwgZ3JvdXAkNShpbmRlbnQkMyhjb25jYXQkNihbc29mdGxpbmUkMiwgam9pbiQzKGNvbmNhdCQ2KFtpZkJyZWFrJDIoXCJcIiwgXCIgXCIpLCBzb2Z0bGluZSQyXSksIHBhdGgubWFwKHByaW50LCBcImRpcmVjdGl2ZXNcIikpXSkpKV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRTZXF1ZW5jZShzZXF1ZW5jZVBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3QgY291bnQgPSBzZXF1ZW5jZVBhdGguZ2V0VmFsdWUoKS5sZW5ndGg7XG4gICAgcmV0dXJuIHNlcXVlbmNlUGF0aC5tYXAoKHBhdGgsIGkpID0+IHtcbiAgICAgIGNvbnN0IHByaW50ZWQgPSBwcmludChwYXRoKTtcblxuICAgICAgaWYgKGlzTmV4dExpbmVFbXB0eSQzKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBwYXRoLmdldFZhbHVlKCksIG9wdGlvbnMubG9jRW5kKSAmJiBpIDwgY291bnQgLSAxKSB7XG4gICAgICAgIHJldHVybiBjb25jYXQkNihbcHJpbnRlZCwgaGFyZGxpbmUkNV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJpbnRlZDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkF0dGFjaENvbW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLmtpbmQgJiYgbm9kZS5raW5kICE9PSBcIkNvbW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q29tbWVudCQxKGNvbW1lbnRQYXRoKSB7XG4gICAgY29uc3QgY29tbWVudCA9IGNvbW1lbnRQYXRoLmdldFZhbHVlKCk7XG5cbiAgICBpZiAoY29tbWVudC5raW5kID09PSBcIkNvbW1lbnRcIikge1xuICAgICAgcmV0dXJuIFwiI1wiICsgY29tbWVudC52YWx1ZS50cmltRW5kKCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgY29tbWVudDogXCIgKyBKU09OLnN0cmluZ2lmeShjb21tZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXRlcm1pbmVJbnRlcmZhY2VTZXBhcmF0b3JCZXR3ZWVuKGZpcnN0LCBzZWNvbmQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0QmV0d2VlbiA9IG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKGZpcnN0LmxvYy5lbmQsIHNlY29uZC5sb2Muc3RhcnQpLnJlcGxhY2UoLyMuKi9nLCBcIlwiKS50cmltKCk7XG4gICAgcmV0dXJuIHRleHRCZXR3ZWVuID09PSBcIixcIiA/IFwiLCBcIiA6IFwiICYgXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludEludGVyZmFjZXMocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXROb2RlKCk7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcmZhY2VzXG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3QgcHJpbnRlZCA9IHBhdGgubWFwKG5vZGUgPT4gcHJpbnQobm9kZSksIFwiaW50ZXJmYWNlc1wiKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpbnRlcmZhY2VzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgaW50ZXJmYWNlTm9kZSA9IGludGVyZmFjZXNbaW5kZXhdO1xuXG4gICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIHBhcnRzLnB1c2goZGV0ZXJtaW5lSW50ZXJmYWNlU2VwYXJhdG9yQmV0d2VlbihpbnRlcmZhY2VzW2luZGV4IC0gMV0sIGludGVyZmFjZU5vZGUsIG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgcGFydHMucHVzaChwcmludGVkW2luZGV4XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW4kMShub2RlLCBuZXdOb2RlXG4gIC8qLCBwYXJlbnQqL1xuICApIHtcbiAgICBkZWxldGUgbmV3Tm9kZS5sb2M7XG4gICAgZGVsZXRlIG5ld05vZGUuY29tbWVudHM7XG4gIH1cblxuICB2YXIgcHJpbnRlckdyYXBocWwgPSB7XG4gICAgcHJpbnQ6IGdlbmVyaWNQcmludCQxLFxuICAgIG1hc3NhZ2VBc3ROb2RlOiBjbGVhbiQxLFxuICAgIGhhc1ByZXR0aWVySWdub3JlOiBoYXNJZ25vcmVDb21tZW50JDIsXG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkNCxcbiAgICBwcmludENvbW1lbnQ6IHByaW50Q29tbWVudCQxLFxuICAgIGNhbkF0dGFjaENvbW1lbnRcbiAgfTtcblxuICB2YXIgb3B0aW9ucyQzID0ge1xuICAgIGJyYWNrZXRTcGFjaW5nOiBjb21tb25PcHRpb25zLmJyYWNrZXRTcGFjaW5nXG4gIH07XG5cbiAgdmFyIG5hbWUkNSA9IFwiR3JhcGhRTFwiO1xuICB2YXIgdHlwZSQ0ID0gXCJkYXRhXCI7XG4gIHZhciBleHRlbnNpb25zJDQgPSBbXG4gIFx0XCIuZ3JhcGhxbFwiLFxuICBcdFwiLmdxbFwiLFxuICBcdFwiLmdyYXBocWxzXCJcbiAgXTtcbiAgdmFyIHRtU2NvcGUkNCA9IFwic291cmNlLmdyYXBocWxcIjtcbiAgdmFyIGFjZU1vZGUkNCA9IFwidGV4dFwiO1xuICB2YXIgbGFuZ3VhZ2VJZCQ0ID0gMTM5O1xuICB2YXIgR3JhcGhRTCA9IHtcbiAgXHRuYW1lOiBuYW1lJDUsXG4gIFx0dHlwZTogdHlwZSQ0LFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkNCxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJDQsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSQ0LFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkNFxuICB9O1xuXG4gIHZhciBHcmFwaFFMJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkNSxcbiAgICB0eXBlOiB0eXBlJDQsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ0LFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkNCxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDQsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQ0LFxuICAgICdkZWZhdWx0JzogR3JhcGhRTFxuICB9KTtcblxuICB2YXIgcmVxdWlyZSQkMCQzID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShHcmFwaFFMJDEpO1xuXG4gIGNvbnN0IGxhbmd1YWdlcyQxID0gW2NyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDAkMywgKCkgPT4gKHtcbiAgICBzaW5jZTogXCIxLjUuMFwiLFxuICAgIHBhcnNlcnM6IFtcImdyYXBocWxcIl0sXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImdyYXBocWxcIl1cbiAgfSkpXTtcbiAgY29uc3QgcHJpbnRlcnMkMSA9IHtcbiAgICBncmFwaHFsOiBwcmludGVyR3JhcGhxbFxuICB9O1xuICB2YXIgbGFuZ3VhZ2VHcmFwaHFsID0ge1xuICAgIGxhbmd1YWdlczogbGFuZ3VhZ2VzJDEsXG4gICAgb3B0aW9uczogb3B0aW9ucyQzLFxuICAgIHByaW50ZXJzOiBwcmludGVycyQxXG4gIH07XG5cbiAgdmFyIGNsZWFuJDIgPSBmdW5jdGlvbiBjbGVhbihhc3QsIG5ld05vZGUpIHtcbiAgICBkZWxldGUgbmV3Tm9kZS5sb2M7XG4gICAgZGVsZXRlIG5ld05vZGUuc2VsZkNsb3Npbmc7IC8vIChHbGltbWVyL0hUTUwpIGlnbm9yZSBUZXh0Tm9kZSB3aGl0ZXNwYWNlXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiVGV4dE5vZGVcIikge1xuICAgICAgY29uc3QgdHJpbW1lZCA9IGFzdC5jaGFycy50cmltKCk7XG5cbiAgICAgIGlmICghdHJpbW1lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbmV3Tm9kZS5jaGFycyA9IHRyaW1tZWQ7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzVXBwZXJjYXNlKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcudG9VcHBlckNhc2UoKSA9PT0gc3RyaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNHbGltbWVyQ29tcG9uZW50KG5vZGUpIHtcbiAgICByZXR1cm4gaXNOb2RlT2ZTb21lVHlwZShub2RlLCBbXCJFbGVtZW50Tm9kZVwiXSkgJiYgdHlwZW9mIG5vZGUudGFnID09PSBcInN0cmluZ1wiICYmIChpc1VwcGVyY2FzZShub2RlLnRhZ1swXSkgfHwgbm9kZS50YWcuaW5jbHVkZXMoXCIuXCIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZU5vZGUobm9kZSkge1xuICAgIHJldHVybiBpc05vZGVPZlNvbWVUeXBlKG5vZGUsIFtcIlRleHROb2RlXCJdKSAmJiAhL1xcUy8udGVzdChub2RlLmNoYXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZU9mU29tZVR5cGUobm9kZSwgdHlwZXMpIHtcbiAgICByZXR1cm4gbm9kZSAmJiB0eXBlcy5zb21lKHR5cGUgPT4gbm9kZS50eXBlID09PSB0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGFyZW50T2ZTb21lVHlwZShwYXRoLCB0eXBlcykge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoMCk7XG4gICAgcmV0dXJuIGlzTm9kZU9mU29tZVR5cGUocGFyZW50Tm9kZSwgdHlwZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQcmV2aW91c05vZGVPZlNvbWVUeXBlKHBhdGgsIHR5cGVzKSB7XG4gICAgY29uc3QgcHJldmlvdXNOb2RlID0gZ2V0UHJldmlvdXNOb2RlKHBhdGgpO1xuICAgIHJldHVybiBpc05vZGVPZlNvbWVUeXBlKHByZXZpb3VzTm9kZSwgdHlwZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOZXh0Tm9kZU9mU29tZVR5cGUocGF0aCwgdHlwZXMpIHtcbiAgICBjb25zdCBuZXh0Tm9kZSA9IGdldE5leHROb2RlKHBhdGgpO1xuICAgIHJldHVybiBpc05vZGVPZlNvbWVUeXBlKG5leHROb2RlLCB0eXBlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShwYXRoLCBvZmZzZXQpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoMCkgfHwge307XG4gICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkcmVuIHx8IHBhcmVudE5vZGUuYm9keSB8fCBbXTtcbiAgICBjb25zdCBpbmRleCA9IGNoaWxkcmVuLmluZGV4T2Yobm9kZSk7XG4gICAgcmV0dXJuIGluZGV4ICE9PSAtMSAmJiBjaGlsZHJlbltpbmRleCArIG9mZnNldF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcmV2aW91c05vZGUocGF0aCwgbG9va0JhY2sgPSAxKSB7XG4gICAgcmV0dXJuIGdldFNpYmxpbmdOb2RlKHBhdGgsIC1sb29rQmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZXh0Tm9kZShwYXRoKSB7XG4gICAgcmV0dXJuIGdldFNpYmxpbmdOb2RlKHBhdGgsIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQcmV0dGllcklnbm9yZU5vZGUobm9kZSkge1xuICAgIHJldHVybiBpc05vZGVPZlNvbWVUeXBlKG5vZGUsIFtcIk11c3RhY2hlQ29tbWVudFN0YXRlbWVudFwiXSkgJiYgdHlwZW9mIG5vZGUudmFsdWUgPT09IFwic3RyaW5nXCIgJiYgbm9kZS52YWx1ZS50cmltKCkgPT09IFwicHJldHRpZXItaWdub3JlXCI7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQcmV0dGllcklnbm9yZShwYXRoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBwcmV2aW91c1ByZXZpb3VzTm9kZSA9IGdldFByZXZpb3VzTm9kZShwYXRoLCAyKTtcbiAgICByZXR1cm4gaXNQcmV0dGllcklnbm9yZU5vZGUobm9kZSkgfHwgaXNQcmV0dGllcklnbm9yZU5vZGUocHJldmlvdXNQcmV2aW91c05vZGUpO1xuICB9XG5cbiAgdmFyIHV0aWxzJDMgPSB7XG4gICAgZ2V0TmV4dE5vZGUsXG4gICAgZ2V0UHJldmlvdXNOb2RlLFxuICAgIGhhc1ByZXR0aWVySWdub3JlLFxuICAgIGlzR2xpbW1lckNvbXBvbmVudCxcbiAgICBpc05leHROb2RlT2ZTb21lVHlwZSxcbiAgICBpc05vZGVPZlNvbWVUeXBlLFxuICAgIGlzUGFyZW50T2ZTb21lVHlwZSxcbiAgICBpc1ByZXZpb3VzTm9kZU9mU29tZVR5cGUsXG4gICAgaXNXaGl0ZXNwYWNlTm9kZVxuICB9O1xuXG4gIGNvbnN0IHtcbiAgICBjb25jYXQ6IGNvbmNhdCQ3LFxuICAgIGpvaW46IGpvaW4kNCxcbiAgICBzb2Z0bGluZTogc29mdGxpbmUkMyxcbiAgICBoYXJkbGluZTogaGFyZGxpbmUkNixcbiAgICBsaW5lOiBsaW5lJDQsXG4gICAgZ3JvdXA6IGdyb3VwJDYsXG4gICAgaW5kZW50OiBpbmRlbnQkNCxcbiAgICBpZkJyZWFrOiBpZkJyZWFrJDNcbiAgfSA9IGRvY3VtZW50LmJ1aWxkZXJzO1xuICBjb25zdCB7XG4gICAgZ2V0TmV4dE5vZGU6IGdldE5leHROb2RlJDEsXG4gICAgZ2V0UHJldmlvdXNOb2RlOiBnZXRQcmV2aW91c05vZGUkMSxcbiAgICBoYXNQcmV0dGllcklnbm9yZTogaGFzUHJldHRpZXJJZ25vcmUkMSxcbiAgICBpc0dsaW1tZXJDb21wb25lbnQ6IGlzR2xpbW1lckNvbXBvbmVudCQxLFxuICAgIGlzTmV4dE5vZGVPZlNvbWVUeXBlOiBpc05leHROb2RlT2ZTb21lVHlwZSQxLFxuICAgIGlzUGFyZW50T2ZTb21lVHlwZTogaXNQYXJlbnRPZlNvbWVUeXBlJDEsXG4gICAgaXNQcmV2aW91c05vZGVPZlNvbWVUeXBlOiBpc1ByZXZpb3VzTm9kZU9mU29tZVR5cGUkMSxcbiAgICBpc1doaXRlc3BhY2VOb2RlOiBpc1doaXRlc3BhY2VOb2RlJDFcbiAgfSA9IHV0aWxzJDM7IC8vIGh0dHA6Ly93M2MuZ2l0aHViLmlvL2h0bWwvc2luZ2xlLXBhZ2UuaHRtbCN2b2lkLWVsZW1lbnRzXG5cbiAgY29uc3Qgdm9pZFRhZ3MgPSBbXCJhcmVhXCIsIFwiYmFzZVwiLCBcImJyXCIsIFwiY29sXCIsIFwiZW1iZWRcIiwgXCJoclwiLCBcImltZ1wiLCBcImlucHV0XCIsIFwibGlua1wiLCBcIm1ldGFcIiwgXCJwYXJhbVwiLCBcInNvdXJjZVwiLCBcInRyYWNrXCIsIFwid2JyXCJdOyAvLyBGb3JtYXR0ZXIgYmFzZWQgb24gQGdsaW1tZXJqcy9zeW50YXgncyBidWlsdC1pbiB0ZXN0IGZvcm1hdHRlcjpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsaW1tZXJqcy9nbGltbWVyLXZtL2Jsb2IvbWFzdGVyL3BhY2thZ2VzLyU0MGdsaW1tZXIvc3ludGF4L2xpYi9nZW5lcmF0aW9uL3ByaW50LnRzXG5cbiAgZnVuY3Rpb24gcHJpbnQocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICBjb25zdCBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiovXG5cbiAgICBpZiAoIW4pIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIGlmIChoYXNQcmV0dGllcklnbm9yZSQxKHBhdGgpKSB7XG4gICAgICBjb25zdCBzdGFydE9mZnNldCA9IGxvY2F0aW9uVG9PZmZzZXQob3B0aW9ucy5vcmlnaW5hbFRleHQsIG4ubG9jLnN0YXJ0LmxpbmUgLSAxLCBuLmxvYy5zdGFydC5jb2x1bW4pO1xuICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gbG9jYXRpb25Ub09mZnNldChvcHRpb25zLm9yaWdpbmFsVGV4dCwgbi5sb2MuZW5kLmxpbmUgLSAxLCBuLmxvYy5lbmQuY29sdW1uKTtcbiAgICAgIGNvbnN0IGlnbm9yZWRUZXh0ID0gb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICByZXR1cm4gaWdub3JlZFRleHQ7XG4gICAgfVxuXG4gICAgc3dpdGNoIChuLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJCbG9ja1wiOlxuICAgICAgY2FzZSBcIlByb2dyYW1cIjpcbiAgICAgIGNhc2UgXCJUZW1wbGF0ZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJDYoY29uY2F0JDcocGF0aC5tYXAocHJpbnQsIFwiYm9keVwiKSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJFbGVtZW50Tm9kZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaGFzQ2hpbGRyZW4gPSBuLmNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gICAgICAgICAgY29uc3QgaGFzTm9uV2hpdGVzcGFjZUNoaWxkcmVuID0gbi5jaGlsZHJlbi5zb21lKG4gPT4gIWlzV2hpdGVzcGFjZU5vZGUkMShuKSk7XG4gICAgICAgICAgY29uc3QgaXNWb2lkID0gaXNHbGltbWVyQ29tcG9uZW50JDEobikgJiYgKCFoYXNDaGlsZHJlbiB8fCAhaGFzTm9uV2hpdGVzcGFjZUNoaWxkcmVuKSB8fCB2b2lkVGFncy5pbmNsdWRlcyhuLnRhZyk7XG4gICAgICAgICAgY29uc3QgY2xvc2VUYWdGb3JOb0JyZWFrID0gaXNWb2lkID8gY29uY2F0JDcoW1wiIC8+XCIsIHNvZnRsaW5lJDNdKSA6IFwiPlwiO1xuICAgICAgICAgIGNvbnN0IGNsb3NlVGFnRm9yQnJlYWsgPSBpc1ZvaWQgPyBcIi8+XCIgOiBcIj5cIjtcblxuICAgICAgICAgIGNvbnN0IHByaW50UGFyYW1zID0gKHBhdGgsIHByaW50KSA9PiBpbmRlbnQkNChjb25jYXQkNyhbbi5hdHRyaWJ1dGVzLmxlbmd0aCA/IGxpbmUkNCA6IFwiXCIsIGpvaW4kNChsaW5lJDQsIHBhdGgubWFwKHByaW50LCBcImF0dHJpYnV0ZXNcIikpLCBuLm1vZGlmaWVycy5sZW5ndGggPyBsaW5lJDQgOiBcIlwiLCBqb2luJDQobGluZSQ0LCBwYXRoLm1hcChwcmludCwgXCJtb2RpZmllcnNcIikpLCBuLmNvbW1lbnRzLmxlbmd0aCA/IGxpbmUkNCA6IFwiXCIsIGpvaW4kNChsaW5lJDQsIHBhdGgubWFwKHByaW50LCBcImNvbW1lbnRzXCIpKV0pKTtcblxuICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gZ2V0TmV4dE5vZGUkMShwYXRoKTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDcoW2dyb3VwJDYoY29uY2F0JDcoW1wiPFwiLCBuLnRhZywgcHJpbnRQYXJhbXMocGF0aCwgcHJpbnQpLCBuLmJsb2NrUGFyYW1zLmxlbmd0aCA/IFwiIGFzIHxcIi5jb25jYXQobi5ibG9ja1BhcmFtcy5qb2luKFwiIFwiKSwgXCJ8XCIpIDogXCJcIiwgaWZCcmVhayQzKHNvZnRsaW5lJDMsIFwiXCIpLCBpZkJyZWFrJDMoY2xvc2VUYWdGb3JCcmVhaywgY2xvc2VUYWdGb3JOb0JyZWFrKV0pKSwgIWlzVm9pZCA/IGdyb3VwJDYoY29uY2F0JDcoW2hhc05vbldoaXRlc3BhY2VDaGlsZHJlbiA/IGluZGVudCQ0KHByaW50Q2hpbGRyZW4ocGF0aCwgb3B0aW9ucywgcHJpbnQpKSA6IFwiXCIsIGlmQnJlYWskMyhoYXNDaGlsZHJlbiA/IGhhcmRsaW5lJDYgOiBcIlwiLCBcIlwiKSwgY29uY2F0JDcoW1wiPC9cIiwgbi50YWcsIFwiPlwiXSldKSkgOiBcIlwiLCBuZXh0Tm9kZSAmJiBuZXh0Tm9kZS50eXBlID09PSBcIkVsZW1lbnROb2RlXCIgPyBoYXJkbGluZSQ2IDogXCJcIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcHAgPSBwYXRoLmdldFBhcmVudE5vZGUoMSk7XG4gICAgICAgICAgY29uc3QgaXNFbHNlSWYgPSBwcCAmJiBwcC5pbnZlcnNlICYmIHBwLmludmVyc2UuYm9keS5sZW5ndGggPT09IDEgJiYgcHAuaW52ZXJzZS5ib2R5WzBdID09PSBuICYmIHBwLmludmVyc2UuYm9keVswXS5wYXRoLnBhcnRzWzBdID09PSBcImlmXCI7XG4gICAgICAgICAgY29uc3QgaGFzRWxzZUlmID0gbi5pbnZlcnNlICYmIG4uaW52ZXJzZS5ib2R5Lmxlbmd0aCA9PT0gMSAmJiBuLmludmVyc2UuYm9keVswXS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgJiYgbi5pbnZlcnNlLmJvZHlbMF0ucGF0aC5wYXJ0c1swXSA9PT0gXCJpZlwiO1xuICAgICAgICAgIGNvbnN0IGluZGVudEVsc2UgPSBoYXNFbHNlSWYgPyBhID0+IGEgOiBpbmRlbnQkNDtcbiAgICAgICAgICBjb25zdCBpbnZlcnNlRWxzZVN0YXRlbWVudCA9IChuLmludmVyc2VTdHJpcC5vcGVuID8gXCJ7e35cIiA6IFwie3tcIikgKyBcImVsc2VcIiArIChuLmludmVyc2VTdHJpcC5jbG9zZSA/IFwifn19XCIgOiBcIn19XCIpO1xuXG4gICAgICAgICAgaWYgKG4uaW52ZXJzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCQ3KFtpc0Vsc2VJZiA/IGNvbmNhdCQ3KFtuLm9wZW5TdHJpcC5vcGVuID8gXCJ7e35lbHNlIFwiIDogXCJ7e2Vsc2UgXCIsIHByaW50UGF0aFBhcmFtcyhwYXRoLCBwcmludCksIG4ub3BlblN0cmlwLmNsb3NlID8gXCJ+fX1cIiA6IFwifX1cIl0pIDogcHJpbnRPcGVuQmxvY2socGF0aCwgcHJpbnQsIG4ub3BlblN0cmlwKSwgaW5kZW50JDQoY29uY2F0JDcoW2hhcmRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJwcm9ncmFtXCIpXSkpLCBuLmludmVyc2UgJiYgIWhhc0Vsc2VJZiA/IGNvbmNhdCQ3KFtoYXJkbGluZSQ2LCBpbnZlcnNlRWxzZVN0YXRlbWVudF0pIDogXCJcIiwgbi5pbnZlcnNlID8gaW5kZW50RWxzZShjb25jYXQkNyhbaGFyZGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcImludmVyc2VcIildKSkgOiBcIlwiLCBpc0Vsc2VJZiA/IFwiXCIgOiBjb25jYXQkNyhbaGFyZGxpbmUkNiwgcHJpbnRDbG9zZUJsb2NrKHBhdGgsIHByaW50LCBuLmNsb3NlU3RyaXApXSldKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRWxzZUlmKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JDcoW2NvbmNhdCQ3KFtuLm9wZW5TdHJpcC5vcGVuID8gXCJ7e35lbHNlXCIgOiBcInt7ZWxzZSBcIiwgcHJpbnRQYXRoUGFyYW1zKHBhdGgsIHByaW50KSwgbi5vcGVuU3RyaXAuY2xvc2UgPyBcIn59fVwiIDogXCJ9fVwiXSksIGluZGVudCQ0KGNvbmNhdCQ3KFtoYXJkbGluZSQ2LCBwYXRoLmNhbGwocHJpbnQsIFwicHJvZ3JhbVwiKV0pKV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGhhc05vbldoaXRlc3BhY2VDaGlsZHJlbiA9IG4ucHJvZ3JhbS5ib2R5LnNvbWUobiA9PiAhaXNXaGl0ZXNwYWNlTm9kZSQxKG4pKTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDcoW3ByaW50T3BlbkJsb2NrKHBhdGgsIHByaW50LCBuLm9wZW5TdHJpcCksIGdyb3VwJDYoY29uY2F0JDcoW2luZGVudCQ0KGNvbmNhdCQ3KFtzb2Z0bGluZSQzLCBwYXRoLmNhbGwocHJpbnQsIFwicHJvZ3JhbVwiKV0pKSwgaGFzTm9uV2hpdGVzcGFjZUNoaWxkcmVuID8gaGFyZGxpbmUkNiA6IHNvZnRsaW5lJDMsIHByaW50Q2xvc2VCbG9jayhwYXRoLCBwcmludCwgbi5jbG9zZVN0cmlwKV0pKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBncm91cCQ2KGNvbmNhdCQ3KFtcInt7XCIsIHByaW50UGF0aFBhcmFtcyhwYXRoLCBwcmludCksIHNvZnRsaW5lJDMsIFwifX1cIl0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTXVzdGFjaGVTdGF0ZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGlzRXNjYXBlZCA9IG4uZXNjYXBlZCA9PT0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgb3Blbjogb3BlblN0cmlwLFxuICAgICAgICAgICAgY2xvc2U6IGNsb3NlU3RyaXBcbiAgICAgICAgICB9ID0gbi5zdHJpcDtcbiAgICAgICAgICBjb25zdCBvcGVuaW5nID0gKGlzRXNjYXBlZCA/IFwie3t7XCIgOiBcInt7XCIpICsgKG9wZW5TdHJpcCA/IFwiflwiIDogXCJcIik7XG4gICAgICAgICAgY29uc3QgY2xvc2luZyA9IChjbG9zZVN0cmlwID8gXCJ+XCIgOiBcIlwiKSArIChpc0VzY2FwZWQgPyBcIn19fVwiIDogXCJ9fVwiKTtcbiAgICAgICAgICBjb25zdCBsZWFkaW5nID0gaXNQYXJlbnRPZlNvbWVUeXBlJDEocGF0aCwgW1wiQXR0ck5vZGVcIiwgXCJDb25jYXRTdGF0ZW1lbnRcIiwgXCJFbGVtZW50Tm9kZVwiXSkgPyBbb3BlbmluZywgaW5kZW50JDQoc29mdGxpbmUkMyldIDogW29wZW5pbmddO1xuICAgICAgICAgIHJldHVybiBncm91cCQ2KGNvbmNhdCQ3KFsuLi5sZWFkaW5nLCBwcmludFBhdGhQYXJhbXMocGF0aCwgcHJpbnQpLCBzb2Z0bGluZSQzLCBjbG9zaW5nXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJTdWJFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSBwcmludFBhcmFtcyhwYXRoLCBwcmludCk7XG4gICAgICAgICAgY29uc3QgcHJpbnRlZFBhcmFtcyA9IHBhcmFtcy5sZW5ndGggPiAwID8gaW5kZW50JDQoY29uY2F0JDcoW2xpbmUkNCwgZ3JvdXAkNihqb2luJDQobGluZSQ0LCBwYXJhbXMpKV0pKSA6IFwiXCI7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJDYoY29uY2F0JDcoW1wiKFwiLCBwcmludFBhdGgocGF0aCwgcHJpbnQpLCBwcmludGVkUGFyYW1zLCBzb2Z0bGluZSQzLCBcIilcIl0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQXR0ck5vZGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGlzVGV4dCA9IG4udmFsdWUudHlwZSA9PT0gXCJUZXh0Tm9kZVwiO1xuICAgICAgICAgIGNvbnN0IGlzRW1wdHlUZXh0ID0gaXNUZXh0ICYmIG4udmFsdWUuY2hhcnMgPT09IFwiXCI7IC8vIElmIHRoZSB0ZXh0IGlzIGVtcHR5IGFuZCB0aGUgdmFsdWUncyBsb2Mgc3RhcnQgYW5kIGVuZCBjb2x1bW5zIGFyZSB0aGVcbiAgICAgICAgICAvLyBzYW1lLCB0aGVyZSBpcyBubyB2YWx1ZSBmb3IgdGhpcyBBdHRyTm9kZSBhbmQgaXQgc2hvdWxkIGJlIHByaW50ZWRcbiAgICAgICAgICAvLyB3aXRob3V0IHRoZSBgPVwiXCJgLiBFeGFtcGxlOiBgPGltZyBkYXRhLXRlc3Q+YCAtPiBgPGltZyBkYXRhLXRlc3Q+YFxuXG4gICAgICAgICAgY29uc3QgaXNFbXB0eVZhbHVlID0gaXNFbXB0eVRleHQgJiYgbi52YWx1ZS5sb2Muc3RhcnQuY29sdW1uID09PSBuLnZhbHVlLmxvYy5lbmQuY29sdW1uO1xuXG4gICAgICAgICAgaWYgKGlzRW1wdHlWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCQ3KFtuLm5hbWVdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICBjb25zdCBxdW90ZWRWYWx1ZSA9IGlzVGV4dCA/IHByaW50U3RyaW5nTGl0ZXJhbCh2YWx1ZS5wYXJ0cy5qb2luKCksIG9wdGlvbnMpIDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ3KFtuLm5hbWUsIFwiPVwiLCBxdW90ZWRWYWx1ZV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJDb25jYXRTdGF0ZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkNyhbJ1wiJywgY29uY2F0JDcocGF0aC5tYXAocGFydFBhdGggPT4gcHJpbnQocGFydFBhdGgpLCBcInBhcnRzXCIpLmZpbHRlcihhID0+IGEgIT09IFwiXCIpKSwgJ1wiJ10pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJIYXNoXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDcoW2pvaW4kNChsaW5lJDQsIHBhdGgubWFwKHByaW50LCBcInBhaXJzXCIpKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJIYXNoUGFpclwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ3KFtuLmtleSwgXCI9XCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUZXh0Tm9kZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbWF4TGluZUJyZWFrc1RvUHJlc2VydmUgPSAyO1xuICAgICAgICAgIGNvbnN0IGlzRmlyc3RFbGVtZW50ID0gIWdldFByZXZpb3VzTm9kZSQxKHBhdGgpO1xuICAgICAgICAgIGNvbnN0IGlzTGFzdEVsZW1lbnQgPSAhZ2V0TmV4dE5vZGUkMShwYXRoKTtcbiAgICAgICAgICBjb25zdCBpc1doaXRlc3BhY2VPbmx5ID0gIS9cXFMvLnRlc3Qobi5jaGFycyk7XG4gICAgICAgICAgY29uc3QgbGluZUJyZWFrc0NvdW50ID0gY291bnROZXdMaW5lcyhuLmNoYXJzKTtcbiAgICAgICAgICBjb25zdCBoYXNCbG9ja1BhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgwKS50eXBlID09PSBcIkJsb2NrXCI7XG4gICAgICAgICAgY29uc3QgaGFzRWxlbWVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgwKS50eXBlID09PSBcIkVsZW1lbnROb2RlXCI7XG4gICAgICAgICAgY29uc3QgaGFzVGVtcGxhdGVQYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoMCkudHlwZSA9PT0gXCJUZW1wbGF0ZVwiO1xuICAgICAgICAgIGxldCBsZWFkaW5nTGluZUJyZWFrc0NvdW50ID0gY291bnRMZWFkaW5nTmV3TGluZXMobi5jaGFycyk7XG4gICAgICAgICAgbGV0IHRyYWlsaW5nTGluZUJyZWFrc0NvdW50ID0gY291bnRUcmFpbGluZ05ld0xpbmVzKG4uY2hhcnMpO1xuXG4gICAgICAgICAgaWYgKChpc0ZpcnN0RWxlbWVudCB8fCBpc0xhc3RFbGVtZW50KSAmJiBpc1doaXRlc3BhY2VPbmx5ICYmIChoYXNCbG9ja1BhcmVudCB8fCBoYXNFbGVtZW50UGFyZW50IHx8IGhhc1RlbXBsYXRlUGFyZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzV2hpdGVzcGFjZU9ubHkgJiYgbGluZUJyZWFrc0NvdW50KSB7XG4gICAgICAgICAgICBsZWFkaW5nTGluZUJyZWFrc0NvdW50ID0gTWF0aC5taW4obGluZUJyZWFrc0NvdW50LCBtYXhMaW5lQnJlYWtzVG9QcmVzZXJ2ZSk7XG4gICAgICAgICAgICB0cmFpbGluZ0xpbmVCcmVha3NDb3VudCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc05leHROb2RlT2ZTb21lVHlwZSQxKHBhdGgsIFtcIkJsb2NrU3RhdGVtZW50XCIsIFwiRWxlbWVudE5vZGVcIl0pKSB7XG4gICAgICAgICAgICAgIHRyYWlsaW5nTGluZUJyZWFrc0NvdW50ID0gTWF0aC5tYXgodHJhaWxpbmdMaW5lQnJlYWtzQ291bnQsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNQcmV2aW91c05vZGVPZlNvbWVUeXBlJDEocGF0aCwgW1wiRWxlbWVudE5vZGVcIl0pIHx8IGlzUHJldmlvdXNOb2RlT2ZTb21lVHlwZSQxKHBhdGgsIFtcIkJsb2NrU3RhdGVtZW50XCJdKSkge1xuICAgICAgICAgICAgICBsZWFkaW5nTGluZUJyZWFrc0NvdW50ID0gTWF0aC5tYXgobGVhZGluZ0xpbmVCcmVha3NDb3VudCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGxlYWRpbmdTcGFjZSA9IFwiXCI7XG4gICAgICAgICAgbGV0IHRyYWlsaW5nU3BhY2UgPSBcIlwiOyAvLyBwcmVzZXJ2ZSBhIHNwYWNlIGluc2lkZSBvZiBhbiBhdHRyaWJ1dGUgbm9kZSB3aGVyZSB3aGl0ZXNwYWNlIHByZXNlbnQsXG4gICAgICAgICAgLy8gd2hlbiBuZXh0IHRvIG11c3RhY2hlIHN0YXRlbWVudC5cblxuICAgICAgICAgIGNvbnN0IGluQXR0ck5vZGUgPSBwYXRoLnN0YWNrLmluY2x1ZGVzKFwiYXR0cmlidXRlc1wiKTtcblxuICAgICAgICAgIGlmIChpbkF0dHJOb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKDApO1xuICAgICAgICAgICAgY29uc3QgaXNDb25jYXQgPSBwYXJlbnROb2RlLnR5cGUgPT09IFwiQ29uY2F0U3RhdGVtZW50XCI7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbmNhdCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgcGFydHNcbiAgICAgICAgICAgICAgfSA9IHBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRJbmRleCA9IHBhcnRzLmluZGV4T2Yobik7XG5cbiAgICAgICAgICAgICAgaWYgKHBhcnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0VHlwZSA9IHBhcnRzW3BhcnRJbmRleCAtIDFdLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNNdXN0YWNoZSA9IHBhcnRUeXBlID09PSBcIk11c3RhY2hlU3RhdGVtZW50XCI7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNNdXN0YWNoZSkge1xuICAgICAgICAgICAgICAgICAgbGVhZGluZ1NwYWNlID0gXCIgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHBhcnRJbmRleCA8IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0VHlwZSA9IHBhcnRzW3BhcnRJbmRleCArIDFdLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNNdXN0YWNoZSA9IHBhcnRUeXBlID09PSBcIk11c3RhY2hlU3RhdGVtZW50XCI7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNNdXN0YWNoZSkge1xuICAgICAgICAgICAgICAgICAgdHJhaWxpbmdTcGFjZSA9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHJhaWxpbmdMaW5lQnJlYWtzQ291bnQgPT09IDAgJiYgaXNOZXh0Tm9kZU9mU29tZVR5cGUkMShwYXRoLCBbXCJNdXN0YWNoZVN0YXRlbWVudFwiXSkpIHtcbiAgICAgICAgICAgICAgdHJhaWxpbmdTcGFjZSA9IFwiIFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVhZGluZ0xpbmVCcmVha3NDb3VudCA9PT0gMCAmJiBpc1ByZXZpb3VzTm9kZU9mU29tZVR5cGUkMShwYXRoLCBbXCJNdXN0YWNoZVN0YXRlbWVudFwiXSkpIHtcbiAgICAgICAgICAgICAgbGVhZGluZ1NwYWNlID0gXCIgXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0RWxlbWVudCkge1xuICAgICAgICAgICAgICBsZWFkaW5nTGluZUJyZWFrc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgbGVhZGluZ1NwYWNlID0gXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzTGFzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgdHJhaWxpbmdMaW5lQnJlYWtzQ291bnQgPSAwO1xuICAgICAgICAgICAgICB0cmFpbGluZ1NwYWNlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JDcoWy4uLmdlbmVyYXRlSGFyZGxpbmVzKGxlYWRpbmdMaW5lQnJlYWtzQ291bnQsIG1heExpbmVCcmVha3NUb1ByZXNlcnZlKSwgbi5jaGFycy5yZXBsYWNlKC9eW1xccyBdKy9nLCBsZWFkaW5nU3BhY2UpLnJlcGxhY2UoL1tcXHMgXSskLywgdHJhaWxpbmdTcGFjZSksIC4uLmdlbmVyYXRlSGFyZGxpbmVzKHRyYWlsaW5nTGluZUJyZWFrc0NvdW50LCBtYXhMaW5lQnJlYWtzVG9QcmVzZXJ2ZSldLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk11c3RhY2hlQ29tbWVudFN0YXRlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgZGFzaGVzID0gbi52YWx1ZS5pbmNsdWRlcyhcIn19XCIpID8gXCItLVwiIDogXCJcIjtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JDcoW1wie3shXCIsIGRhc2hlcywgbi52YWx1ZSwgZGFzaGVzLCBcIn19XCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiUGF0aEV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBuLm9yaWdpbmFsO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJCb29sZWFuTGl0ZXJhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhuLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQ29tbWVudFN0YXRlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCQ3KFtcIjwhLS1cIiwgbi52YWx1ZSwgXCItLT5cIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcHJpbnRTdHJpbmdMaXRlcmFsKG4udmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJOdW1iZXJMaXRlcmFsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKG4udmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJVbmRlZmluZWRMaXRlcmFsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTnVsbExpdGVyYWxcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGdsaW1tZXIgdHlwZTogXCIgKyBKU09OLnN0cmluZ2lmeShuLnR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENoaWxkcmVuKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgcmV0dXJuIGNvbmNhdCQ3KHBhdGgubWFwKChjaGlsZFBhdGgsIGNoaWxkSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICAgIGNvbnN0IGlzRmlyc3ROb2RlID0gY2hpbGRJbmRleCA9PT0gMDtcbiAgICAgIGNvbnN0IGlzTGFzdE5vZGUgPSBjaGlsZEluZGV4ID09PSBwYXRoLmdldFBhcmVudE5vZGUoMCkuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgIGNvbnN0IGlzTGFzdE5vZGVJbk11bHRpTm9kZUxpc3QgPSBpc0xhc3ROb2RlICYmICFpc0ZpcnN0Tm9kZTtcbiAgICAgIGNvbnN0IGlzV2hpdGVzcGFjZSA9IGlzV2hpdGVzcGFjZU5vZGUkMShjaGlsZE5vZGUpO1xuXG4gICAgICBpZiAoaXNXaGl0ZXNwYWNlICYmIGlzTGFzdE5vZGVJbk11bHRpTm9kZUxpc3QpIHtcbiAgICAgICAgcmV0dXJuIHByaW50KGNoaWxkUGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0Tm9kZSkge1xuICAgICAgICByZXR1cm4gY29uY2F0JDcoW3NvZnRsaW5lJDMsIHByaW50KGNoaWxkUGF0aCwgb3B0aW9ucywgcHJpbnQpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmludChjaGlsZFBhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICB9LCBcImNoaWxkcmVuXCIpKTtcbiAgfVxuICAvKipcbiAgICogUHJpbnRzIGEgc3RyaW5nIGxpdGVyYWwgd2l0aCB0aGUgY29ycmVjdCBzdXJyb3VuZGluZyBxdW90ZXMgYmFzZWQgb25cbiAgICogYG9wdGlvbnMuc2luZ2xlUXVvdGVgIGFuZCB0aGUgbnVtYmVyIG9mIGVzY2FwZWQgcXVvdGVzIGNvbnRhaW5lZCBpblxuICAgKiB0aGUgc3RyaW5nIGxpdGVyYWwuIFRoaXMgZnVuY3Rpb24gaXMgdGhlIGdsaW1tZXIgZXF1aXZhbGVudCBvZiBgcHJpbnRTdHJpbmdgXG4gICAqIGluIGBjb21tb24vdXRpbGAsIGJ1dCBoYXMgZGlmZmVyZW5jZXMgYmVjYXVzZSBvZiB0aGUgd2F5IGVzY2FwZWQgY2hhcmFjdGVyc1xuICAgKiBhcmUgdHJlYXRlZCBpbiBoYnMgc3RyaW5nIGxpdGVyYWxzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nTGl0ZXJhbCAtIHRoZSBzdHJpbmcgbGl0ZXJhbCB2YWx1ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHRoZSBwcmV0dGllciBvcHRpb25zIG9iamVjdFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHByaW50U3RyaW5nTGl0ZXJhbChzdHJpbmdMaXRlcmFsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZG91YmxlID0ge1xuICAgICAgcXVvdGU6ICdcIicsXG4gICAgICByZWdleDogL1wiL2dcbiAgICB9O1xuICAgIGNvbnN0IHNpbmdsZSA9IHtcbiAgICAgIHF1b3RlOiBcIidcIixcbiAgICAgIHJlZ2V4OiAvJy9nXG4gICAgfTtcbiAgICBjb25zdCBwcmVmZXJyZWQgPSBvcHRpb25zLnNpbmdsZVF1b3RlID8gc2luZ2xlIDogZG91YmxlO1xuICAgIGNvbnN0IGFsdGVybmF0ZSA9IHByZWZlcnJlZCA9PT0gc2luZ2xlID8gZG91YmxlIDogc2luZ2xlO1xuICAgIGxldCBzaG91bGRVc2VBbHRlcm5hdGVRdW90ZSA9IGZhbHNlOyAvLyBJZiBgc3RyaW5nTGl0ZXJhbGAgY29udGFpbnMgYXQgbGVhc3Qgb25lIG9mIHRoZSBxdW90ZSBwcmVmZXJyZWQgZm9yXG4gICAgLy8gZW5jbG9zaW5nIHRoZSBzdHJpbmcsIHdlIG1pZ2h0IHdhbnQgdG8gZW5jbG9zZSB3aXRoIHRoZSBhbHRlcm5hdGUgcXVvdGVcbiAgICAvLyBpbnN0ZWFkLCB0byBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIGVzY2FwZWQgcXVvdGVzLlxuXG4gICAgaWYgKHN0cmluZ0xpdGVyYWwuaW5jbHVkZXMocHJlZmVycmVkLnF1b3RlKSB8fCBzdHJpbmdMaXRlcmFsLmluY2x1ZGVzKGFsdGVybmF0ZS5xdW90ZSkpIHtcbiAgICAgIGNvbnN0IG51bVByZWZlcnJlZFF1b3RlcyA9IChzdHJpbmdMaXRlcmFsLm1hdGNoKHByZWZlcnJlZC5yZWdleCkgfHwgW10pLmxlbmd0aDtcbiAgICAgIGNvbnN0IG51bUFsdGVybmF0ZVF1b3RlcyA9IChzdHJpbmdMaXRlcmFsLm1hdGNoKGFsdGVybmF0ZS5yZWdleCkgfHwgW10pLmxlbmd0aDtcbiAgICAgIHNob3VsZFVzZUFsdGVybmF0ZVF1b3RlID0gbnVtUHJlZmVycmVkUXVvdGVzID4gbnVtQWx0ZXJuYXRlUXVvdGVzO1xuICAgIH1cblxuICAgIGNvbnN0IGVuY2xvc2luZ1F1b3RlID0gc2hvdWxkVXNlQWx0ZXJuYXRlUXVvdGUgPyBhbHRlcm5hdGUgOiBwcmVmZXJyZWQ7XG4gICAgY29uc3QgZXNjYXBlZFN0cmluZ0xpdGVyYWwgPSBzdHJpbmdMaXRlcmFsLnJlcGxhY2UoZW5jbG9zaW5nUXVvdGUucmVnZXgsIFwiXFxcXFwiLmNvbmNhdChlbmNsb3NpbmdRdW90ZS5xdW90ZSkpO1xuICAgIHJldHVybiBjb25jYXQkNyhbZW5jbG9zaW5nUXVvdGUucXVvdGUsIGVzY2FwZWRTdHJpbmdMaXRlcmFsLCBlbmNsb3NpbmdRdW90ZS5xdW90ZV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRQYXRoKHBhdGgsIHByaW50KSB7XG4gICAgcmV0dXJuIHBhdGguY2FsbChwcmludCwgXCJwYXRoXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRQYXJhbXMocGF0aCwgcHJpbnQpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuXG4gICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzID0gcGFydHMuY29uY2F0KHBhdGgubWFwKHByaW50LCBcInBhcmFtc1wiKSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuaGFzaCAmJiBub2RlLmhhc2gucGFpcnMubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiaGFzaFwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRQYXRoUGFyYW1zKHBhdGgsIHByaW50KSB7XG4gICAgY29uc3QgcHJpbnRlZFBhdGggPSBwcmludFBhdGgocGF0aCwgcHJpbnQpO1xuICAgIGNvbnN0IHByaW50ZWRQYXJhbXMgPSBwcmludFBhcmFtcyhwYXRoLCBwcmludCk7XG4gICAgY29uc3QgcGFydHMgPSBbcHJpbnRlZFBhdGgsIC4uLnByaW50ZWRQYXJhbXNdO1xuICAgIHJldHVybiBpbmRlbnQkNChncm91cCQ2KGpvaW4kNChsaW5lJDQsIHBhcnRzKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRCbG9ja1BhcmFtcyhwYXRoKSB7XG4gICAgY29uc3QgYmxvY2sgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBpZiAoIWJsb2NrLnByb2dyYW0gfHwgIWJsb2NrLnByb2dyYW0uYmxvY2tQYXJhbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JDcoW1wiIGFzIHxcIiwgYmxvY2sucHJvZ3JhbS5ibG9ja1BhcmFtcy5qb2luKFwiIFwiKSwgXCJ8XCJdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50T3BlbkJsb2NrKHBhdGgsIHByaW50LCB7XG4gICAgb3BlbjogaXNPcGVuU3RyaXAgPSBmYWxzZSxcbiAgICBjbG9zZTogaXNDbG9zZVN0cmlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIGdyb3VwJDYoY29uY2F0JDcoW2lzT3BlblN0cmlwID8gXCJ7e34jXCIgOiBcInt7I1wiLCBwcmludFBhdGhQYXJhbXMocGF0aCwgcHJpbnQpLCBwcmludEJsb2NrUGFyYW1zKHBhdGgpLCBzb2Z0bGluZSQzLCBpc0Nsb3NlU3RyaXAgPyBcIn59fVwiIDogXCJ9fVwiXSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDbG9zZUJsb2NrKHBhdGgsIHByaW50LCB7XG4gICAgb3BlbjogaXNPcGVuU3RyaXAgPSBmYWxzZSxcbiAgICBjbG9zZTogaXNDbG9zZVN0cmlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIGNvbmNhdCQ3KFtpc09wZW5TdHJpcCA/IFwie3t+L1wiIDogXCJ7ey9cIiwgcGF0aC5jYWxsKHByaW50LCBcInBhdGhcIiksIGlzQ2xvc2VTdHJpcCA/IFwifn19XCIgOiBcIn19XCJdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvdW50TmV3TGluZXMoc3RyaW5nKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBzdHJpbmcgPSB0eXBlb2Ygc3RyaW5nID09PSBcInN0cmluZ1wiID8gc3RyaW5nIDogXCJcIjtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KFwiXFxuXCIpLmxlbmd0aCAtIDE7XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudExlYWRpbmdOZXdMaW5lcyhzdHJpbmcpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHN0cmluZyA9IHR5cGVvZiBzdHJpbmcgPT09IFwic3RyaW5nXCIgPyBzdHJpbmcgOiBcIlwiO1xuICAgIGNvbnN0IG5ld0xpbmVzID0gKHN0cmluZy5tYXRjaCgvXihbXlxcU1xcclxcbl0qW1xcclxcbl0pKy9nKSB8fCBbXSlbMF0gfHwgXCJcIjtcbiAgICByZXR1cm4gY291bnROZXdMaW5lcyhuZXdMaW5lcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudFRyYWlsaW5nTmV3TGluZXMoc3RyaW5nKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBzdHJpbmcgPSB0eXBlb2Ygc3RyaW5nID09PSBcInN0cmluZ1wiID8gc3RyaW5nIDogXCJcIjtcbiAgICBjb25zdCBuZXdMaW5lcyA9IChzdHJpbmcubWF0Y2goLyhbXFxyXFxuXVteXFxTXFxyXFxuXSopKyQvZykgfHwgW10pWzBdIHx8IFwiXCI7XG4gICAgcmV0dXJuIGNvdW50TmV3TGluZXMobmV3TGluZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVIYXJkbGluZXMobnVtYmVyID0gMCwgbWF4ID0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXkoTWF0aC5taW4obnVtYmVyLCBtYXgpKS5maWxsKGhhcmRsaW5lJDYpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGltbWVyanMvZ2xpbW1lci12bS9ibG9iL21hc3Rlci9wYWNrYWdlcy8lNDBnbGltbWVyL2NvbXBpbGVyL2xpYi9sb2NhdGlvbi50cyNMNS1MMjlcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGxvY2F0aW9uVG9PZmZzZXQoc291cmNlLCBsaW5lLCBjb2x1bW4pIHtcbiAgICBsZXQgc2VlbkxpbmVzID0gMDtcbiAgICBsZXQgc2VlbkNoYXJzID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChzZWVuQ2hhcnMgPT09IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGxldCBuZXh0TGluZSA9IHNvdXJjZS5pbmRleE9mKFwiXFxuXCIsIHNlZW5DaGFycyk7XG5cbiAgICAgIGlmIChuZXh0TGluZSA9PT0gLTEpIHtcbiAgICAgICAgbmV4dExpbmUgPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VlbkxpbmVzID09PSBsaW5lKSB7XG4gICAgICAgIGlmIChzZWVuQ2hhcnMgKyBjb2x1bW4gPiBuZXh0TGluZSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlZW5DaGFycyArIGNvbHVtbjtcbiAgICAgIH0gZWxzZSBpZiAobmV4dExpbmUgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBzZWVuTGluZXMgKz0gMTtcbiAgICAgIHNlZW5DaGFycyA9IG5leHRMaW5lICsgMTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJpbnRlckdsaW1tZXIgPSB7XG4gICAgcHJpbnQsXG4gICAgbWFzc2FnZUFzdE5vZGU6IGNsZWFuJDJcbiAgfTtcblxuICB2YXIgbmFtZSQ2ID0gXCJIYW5kbGViYXJzXCI7XG4gIHZhciB0eXBlJDUgPSBcIm1hcmt1cFwiO1xuICB2YXIgZ3JvdXAkNyA9IFwiSFRNTFwiO1xuICB2YXIgYWxpYXNlcyA9IFtcbiAgXHRcImhic1wiLFxuICBcdFwiaHRtbGJhcnNcIlxuICBdO1xuICB2YXIgZXh0ZW5zaW9ucyQ1ID0gW1xuICBcdFwiLmhhbmRsZWJhcnNcIixcbiAgXHRcIi5oYnNcIlxuICBdO1xuICB2YXIgdG1TY29wZSQ1ID0gXCJ0ZXh0Lmh0bWwuaGFuZGxlYmFyc1wiO1xuICB2YXIgYWNlTW9kZSQ1ID0gXCJoYW5kbGViYXJzXCI7XG4gIHZhciBsYW5ndWFnZUlkJDUgPSAxNTU7XG4gIHZhciBIYW5kbGViYXJzID0ge1xuICBcdG5hbWU6IG5hbWUkNixcbiAgXHR0eXBlOiB0eXBlJDUsXG4gIFx0Z3JvdXA6IGdyb3VwJDcsXG4gIFx0YWxpYXNlczogYWxpYXNlcyxcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJDUsXG4gIFx0dG1TY29wZTogdG1TY29wZSQ1LFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkNSxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDVcbiAgfTtcblxuICB2YXIgSGFuZGxlYmFycyQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJDYsXG4gICAgdHlwZTogdHlwZSQ1LFxuICAgIGdyb3VwOiBncm91cCQ3LFxuICAgIGFsaWFzZXM6IGFsaWFzZXMsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ1LFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkNSxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDUsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQ1LFxuICAgICdkZWZhdWx0JzogSGFuZGxlYmFyc1xuICB9KTtcblxuICB2YXIgcmVxdWlyZSQkMCQ0ID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShIYW5kbGViYXJzJDEpO1xuXG4gIGNvbnN0IGxhbmd1YWdlcyQyID0gW2NyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDAkNCwgKCkgPT4gKHtcbiAgICBzaW5jZTogbnVsbCxcbiAgICAvLyB1bnJlbGVhc2VkXG4gICAgcGFyc2VyczogW1wiZ2xpbW1lclwiXSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wiaGFuZGxlYmFyc1wiXVxuICB9KSldO1xuICBjb25zdCBwcmludGVycyQyID0ge1xuICAgIGdsaW1tZXI6IHByaW50ZXJHbGltbWVyXG4gIH07XG4gIHZhciBsYW5ndWFnZUhhbmRsZWJhcnMgPSB7XG4gICAgbGFuZ3VhZ2VzOiBsYW5ndWFnZXMkMixcbiAgICBwcmludGVyczogcHJpbnRlcnMkMlxuICB9O1xuXG4gIHZhciBjbGVhbiQzID0gZnVuY3Rpb24gY2xlYW4oYXN0LCBuZXdOb2RlKSB7XG4gICAgZGVsZXRlIG5ld05vZGUuc291cmNlU3BhbjtcbiAgICBkZWxldGUgbmV3Tm9kZS5zdGFydFNvdXJjZVNwYW47XG4gICAgZGVsZXRlIG5ld05vZGUuZW5kU291cmNlU3BhbjtcbiAgICBkZWxldGUgbmV3Tm9kZS5uYW1lU3BhbjtcbiAgICBkZWxldGUgbmV3Tm9kZS52YWx1ZVNwYW47XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwidGV4dFwiIHx8IGFzdC50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBtYXkgYmUgZm9ybWF0dGVkIGJ5IG11bHRpcGFyc2VyXG5cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJ5YW1sXCIgfHwgYXN0LnR5cGUgPT09IFwidG9tbFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiYXR0cmlidXRlXCIpIHtcbiAgICAgIGRlbGV0ZSBuZXdOb2RlLnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJkb2NUeXBlXCIpIHtcbiAgICAgIGRlbGV0ZSBuZXdOb2RlLnZhbHVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIganNvbiA9IHtcbiAgICBcIkNTU19ESVNQTEFZX1RBR1NcIjoge1xuICAgICAgXCJhcmVhXCI6IFwibm9uZVwiLFxuICAgICAgXCJiYXNlXCI6IFwibm9uZVwiLFxuICAgICAgXCJiYXNlZm9udFwiOiBcIm5vbmVcIixcbiAgICAgIFwiZGF0YWxpc3RcIjogXCJub25lXCIsXG4gICAgICBcImhlYWRcIjogXCJub25lXCIsXG4gICAgICBcImxpbmtcIjogXCJub25lXCIsXG4gICAgICBcIm1ldGFcIjogXCJub25lXCIsXG4gICAgICBcIm5vZW1iZWRcIjogXCJub25lXCIsXG4gICAgICBcIm5vZnJhbWVzXCI6IFwibm9uZVwiLFxuICAgICAgXCJwYXJhbVwiOiBcIm5vbmVcIixcbiAgICAgIFwicnBcIjogXCJub25lXCIsXG4gICAgICBcInNjcmlwdFwiOiBcImJsb2NrXCIsXG4gICAgICBcInNvdXJjZVwiOiBcImJsb2NrXCIsXG4gICAgICBcInN0eWxlXCI6IFwibm9uZVwiLFxuICAgICAgXCJ0ZW1wbGF0ZVwiOiBcImlubGluZVwiLFxuICAgICAgXCJ0cmFja1wiOiBcImJsb2NrXCIsXG4gICAgICBcInRpdGxlXCI6IFwibm9uZVwiLFxuICAgICAgXCJodG1sXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiYm9keVwiOiBcImJsb2NrXCIsXG4gICAgICBcImFkZHJlc3NcIjogXCJibG9ja1wiLFxuICAgICAgXCJibG9ja3F1b3RlXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiY2VudGVyXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZGl2XCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZmlndXJlXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZmlnY2FwdGlvblwiOiBcImJsb2NrXCIsXG4gICAgICBcImZvb3RlclwiOiBcImJsb2NrXCIsXG4gICAgICBcImZvcm1cIjogXCJibG9ja1wiLFxuICAgICAgXCJoZWFkZXJcIjogXCJibG9ja1wiLFxuICAgICAgXCJoclwiOiBcImJsb2NrXCIsXG4gICAgICBcImxlZ2VuZFwiOiBcImJsb2NrXCIsXG4gICAgICBcImxpc3RpbmdcIjogXCJibG9ja1wiLFxuICAgICAgXCJtYWluXCI6IFwiYmxvY2tcIixcbiAgICAgIFwicFwiOiBcImJsb2NrXCIsXG4gICAgICBcInBsYWludGV4dFwiOiBcImJsb2NrXCIsXG4gICAgICBcInByZVwiOiBcImJsb2NrXCIsXG4gICAgICBcInhtcFwiOiBcImJsb2NrXCIsXG4gICAgICBcInNsb3RcIjogXCJjb250ZW50c1wiLFxuICAgICAgXCJydWJ5XCI6IFwicnVieVwiLFxuICAgICAgXCJydFwiOiBcInJ1YnktdGV4dFwiLFxuICAgICAgXCJhcnRpY2xlXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiYXNpZGVcIjogXCJibG9ja1wiLFxuICAgICAgXCJoMVwiOiBcImJsb2NrXCIsXG4gICAgICBcImgyXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiaDNcIjogXCJibG9ja1wiLFxuICAgICAgXCJoNFwiOiBcImJsb2NrXCIsXG4gICAgICBcImg1XCI6IFwiYmxvY2tcIixcbiAgICAgIFwiaDZcIjogXCJibG9ja1wiLFxuICAgICAgXCJoZ3JvdXBcIjogXCJibG9ja1wiLFxuICAgICAgXCJuYXZcIjogXCJibG9ja1wiLFxuICAgICAgXCJzZWN0aW9uXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZGlyXCI6IFwiYmxvY2tcIixcbiAgICAgIFwiZGRcIjogXCJibG9ja1wiLFxuICAgICAgXCJkbFwiOiBcImJsb2NrXCIsXG4gICAgICBcImR0XCI6IFwiYmxvY2tcIixcbiAgICAgIFwib2xcIjogXCJibG9ja1wiLFxuICAgICAgXCJ1bFwiOiBcImJsb2NrXCIsXG4gICAgICBcImxpXCI6IFwibGlzdC1pdGVtXCIsXG4gICAgICBcInRhYmxlXCI6IFwidGFibGVcIixcbiAgICAgIFwiY2FwdGlvblwiOiBcInRhYmxlLWNhcHRpb25cIixcbiAgICAgIFwiY29sZ3JvdXBcIjogXCJ0YWJsZS1jb2x1bW4tZ3JvdXBcIixcbiAgICAgIFwiY29sXCI6IFwidGFibGUtY29sdW1uXCIsXG4gICAgICBcInRoZWFkXCI6IFwidGFibGUtaGVhZGVyLWdyb3VwXCIsXG4gICAgICBcInRib2R5XCI6IFwidGFibGUtcm93LWdyb3VwXCIsXG4gICAgICBcInRmb290XCI6IFwidGFibGUtZm9vdGVyLWdyb3VwXCIsXG4gICAgICBcInRyXCI6IFwidGFibGUtcm93XCIsXG4gICAgICBcInRkXCI6IFwidGFibGUtY2VsbFwiLFxuICAgICAgXCJ0aFwiOiBcInRhYmxlLWNlbGxcIixcbiAgICAgIFwiZmllbGRzZXRcIjogXCJibG9ja1wiLFxuICAgICAgXCJidXR0b25cIjogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgIFwidmlkZW9cIjogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgIFwiYXVkaW9cIjogXCJpbmxpbmUtYmxvY2tcIlxuICAgIH0sXG4gICAgXCJDU1NfRElTUExBWV9ERUZBVUxUXCI6IFwiaW5saW5lXCIsXG4gICAgXCJDU1NfV0hJVEVfU1BBQ0VfVEFHU1wiOiB7XG4gICAgICBcImxpc3RpbmdcIjogXCJwcmVcIixcbiAgICAgIFwicGxhaW50ZXh0XCI6IFwicHJlXCIsXG4gICAgICBcInByZVwiOiBcInByZVwiLFxuICAgICAgXCJ4bXBcIjogXCJwcmVcIixcbiAgICAgIFwibm9iclwiOiBcIm5vd3JhcFwiLFxuICAgICAgXCJ0YWJsZVwiOiBcImluaXRpYWxcIixcbiAgICAgIFwidGV4dGFyZWFcIjogXCJwcmUtd3JhcFwiXG4gICAgfSxcbiAgICBcIkNTU19XSElURV9TUEFDRV9ERUZBVUxUXCI6IFwibm9ybWFsXCJcbiAgfTtcblxuICB2YXIgaW5kZXggPSBbXG4gIFx0XCJhXCIsXG4gIFx0XCJhYmJyXCIsXG4gIFx0XCJhY3JvbnltXCIsXG4gIFx0XCJhZGRyZXNzXCIsXG4gIFx0XCJhcHBsZXRcIixcbiAgXHRcImFyZWFcIixcbiAgXHRcImFydGljbGVcIixcbiAgXHRcImFzaWRlXCIsXG4gIFx0XCJhdWRpb1wiLFxuICBcdFwiYlwiLFxuICBcdFwiYmFzZVwiLFxuICBcdFwiYmFzZWZvbnRcIixcbiAgXHRcImJkaVwiLFxuICBcdFwiYmRvXCIsXG4gIFx0XCJiZ3NvdW5kXCIsXG4gIFx0XCJiaWdcIixcbiAgXHRcImJsaW5rXCIsXG4gIFx0XCJibG9ja3F1b3RlXCIsXG4gIFx0XCJib2R5XCIsXG4gIFx0XCJiclwiLFxuICBcdFwiYnV0dG9uXCIsXG4gIFx0XCJjYW52YXNcIixcbiAgXHRcImNhcHRpb25cIixcbiAgXHRcImNlbnRlclwiLFxuICBcdFwiY2l0ZVwiLFxuICBcdFwiY29kZVwiLFxuICBcdFwiY29sXCIsXG4gIFx0XCJjb2xncm91cFwiLFxuICBcdFwiY29tbWFuZFwiLFxuICBcdFwiY29udGVudFwiLFxuICBcdFwiZGF0YVwiLFxuICBcdFwiZGF0YWxpc3RcIixcbiAgXHRcImRkXCIsXG4gIFx0XCJkZWxcIixcbiAgXHRcImRldGFpbHNcIixcbiAgXHRcImRmblwiLFxuICBcdFwiZGlhbG9nXCIsXG4gIFx0XCJkaXJcIixcbiAgXHRcImRpdlwiLFxuICBcdFwiZGxcIixcbiAgXHRcImR0XCIsXG4gIFx0XCJlbGVtZW50XCIsXG4gIFx0XCJlbVwiLFxuICBcdFwiZW1iZWRcIixcbiAgXHRcImZpZWxkc2V0XCIsXG4gIFx0XCJmaWdjYXB0aW9uXCIsXG4gIFx0XCJmaWd1cmVcIixcbiAgXHRcImZvbnRcIixcbiAgXHRcImZvb3RlclwiLFxuICBcdFwiZm9ybVwiLFxuICBcdFwiZnJhbWVcIixcbiAgXHRcImZyYW1lc2V0XCIsXG4gIFx0XCJoMVwiLFxuICBcdFwiaDJcIixcbiAgXHRcImgzXCIsXG4gIFx0XCJoNFwiLFxuICBcdFwiaDVcIixcbiAgXHRcImg2XCIsXG4gIFx0XCJoZWFkXCIsXG4gIFx0XCJoZWFkZXJcIixcbiAgXHRcImhncm91cFwiLFxuICBcdFwiaHJcIixcbiAgXHRcImh0bWxcIixcbiAgXHRcImlcIixcbiAgXHRcImlmcmFtZVwiLFxuICBcdFwiaW1hZ2VcIixcbiAgXHRcImltZ1wiLFxuICBcdFwiaW5wdXRcIixcbiAgXHRcImluc1wiLFxuICBcdFwiaXNpbmRleFwiLFxuICBcdFwia2JkXCIsXG4gIFx0XCJrZXlnZW5cIixcbiAgXHRcImxhYmVsXCIsXG4gIFx0XCJsZWdlbmRcIixcbiAgXHRcImxpXCIsXG4gIFx0XCJsaW5rXCIsXG4gIFx0XCJsaXN0aW5nXCIsXG4gIFx0XCJtYWluXCIsXG4gIFx0XCJtYXBcIixcbiAgXHRcIm1hcmtcIixcbiAgXHRcIm1hcnF1ZWVcIixcbiAgXHRcIm1hdGhcIixcbiAgXHRcIm1lbnVcIixcbiAgXHRcIm1lbnVpdGVtXCIsXG4gIFx0XCJtZXRhXCIsXG4gIFx0XCJtZXRlclwiLFxuICBcdFwibXVsdGljb2xcIixcbiAgXHRcIm5hdlwiLFxuICBcdFwibmV4dGlkXCIsXG4gIFx0XCJub2JyXCIsXG4gIFx0XCJub2VtYmVkXCIsXG4gIFx0XCJub2ZyYW1lc1wiLFxuICBcdFwibm9zY3JpcHRcIixcbiAgXHRcIm9iamVjdFwiLFxuICBcdFwib2xcIixcbiAgXHRcIm9wdGdyb3VwXCIsXG4gIFx0XCJvcHRpb25cIixcbiAgXHRcIm91dHB1dFwiLFxuICBcdFwicFwiLFxuICBcdFwicGFyYW1cIixcbiAgXHRcInBpY3R1cmVcIixcbiAgXHRcInBsYWludGV4dFwiLFxuICBcdFwicHJlXCIsXG4gIFx0XCJwcm9ncmVzc1wiLFxuICBcdFwicVwiLFxuICBcdFwicmJcIixcbiAgXHRcInJiY1wiLFxuICBcdFwicnBcIixcbiAgXHRcInJ0XCIsXG4gIFx0XCJydGNcIixcbiAgXHRcInJ1YnlcIixcbiAgXHRcInNcIixcbiAgXHRcInNhbXBcIixcbiAgXHRcInNjcmlwdFwiLFxuICBcdFwic2VjdGlvblwiLFxuICBcdFwic2VsZWN0XCIsXG4gIFx0XCJzaGFkb3dcIixcbiAgXHRcInNsb3RcIixcbiAgXHRcInNtYWxsXCIsXG4gIFx0XCJzb3VyY2VcIixcbiAgXHRcInNwYWNlclwiLFxuICBcdFwic3BhblwiLFxuICBcdFwic3RyaWtlXCIsXG4gIFx0XCJzdHJvbmdcIixcbiAgXHRcInN0eWxlXCIsXG4gIFx0XCJzdWJcIixcbiAgXHRcInN1bW1hcnlcIixcbiAgXHRcInN1cFwiLFxuICBcdFwic3ZnXCIsXG4gIFx0XCJ0YWJsZVwiLFxuICBcdFwidGJvZHlcIixcbiAgXHRcInRkXCIsXG4gIFx0XCJ0ZW1wbGF0ZVwiLFxuICBcdFwidGV4dGFyZWFcIixcbiAgXHRcInRmb290XCIsXG4gIFx0XCJ0aFwiLFxuICBcdFwidGhlYWRcIixcbiAgXHRcInRpbWVcIixcbiAgXHRcInRpdGxlXCIsXG4gIFx0XCJ0clwiLFxuICBcdFwidHJhY2tcIixcbiAgXHRcInR0XCIsXG4gIFx0XCJ1XCIsXG4gIFx0XCJ1bFwiLFxuICBcdFwidmFyXCIsXG4gIFx0XCJ2aWRlb1wiLFxuICBcdFwid2JyXCIsXG4gIFx0XCJ4bXBcIlxuICBdO1xuXG4gIHZhciBodG1sVGFnTmFtZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgICdkZWZhdWx0JzogaW5kZXhcbiAgfSk7XG5cbiAgdmFyIGEgPSBbXG4gIFx0XCJhY2Nlc3NrZXlcIixcbiAgXHRcImNoYXJzZXRcIixcbiAgXHRcImNvb3Jkc1wiLFxuICBcdFwiZG93bmxvYWRcIixcbiAgXHRcImhyZWZcIixcbiAgXHRcImhyZWZsYW5nXCIsXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJwaW5nXCIsXG4gIFx0XCJyZWZlcnJlcnBvbGljeVwiLFxuICBcdFwicmVsXCIsXG4gIFx0XCJyZXZcIixcbiAgXHRcInNoYXBlXCIsXG4gIFx0XCJ0YWJpbmRleFwiLFxuICBcdFwidGFyZ2V0XCIsXG4gIFx0XCJ0eXBlXCJcbiAgXTtcbiAgdmFyIGFiYnIgPSBbXG4gIFx0XCJ0aXRsZVwiXG4gIF07XG4gIHZhciBhcHBsZXQgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiYWx0XCIsXG4gIFx0XCJhcmNoaXZlXCIsXG4gIFx0XCJjb2RlXCIsXG4gIFx0XCJjb2RlYmFzZVwiLFxuICBcdFwiaGVpZ2h0XCIsXG4gIFx0XCJoc3BhY2VcIixcbiAgXHRcIm5hbWVcIixcbiAgXHRcIm9iamVjdFwiLFxuICBcdFwidnNwYWNlXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciBhcmVhID0gW1xuICBcdFwiYWNjZXNza2V5XCIsXG4gIFx0XCJhbHRcIixcbiAgXHRcImNvb3Jkc1wiLFxuICBcdFwiZG93bmxvYWRcIixcbiAgXHRcImhyZWZcIixcbiAgXHRcImhyZWZsYW5nXCIsXG4gIFx0XCJub2hyZWZcIixcbiAgXHRcInBpbmdcIixcbiAgXHRcInJlZmVycmVycG9saWN5XCIsXG4gIFx0XCJyZWxcIixcbiAgXHRcInNoYXBlXCIsXG4gIFx0XCJ0YWJpbmRleFwiLFxuICBcdFwidGFyZ2V0XCIsXG4gIFx0XCJ0eXBlXCJcbiAgXTtcbiAgdmFyIGF1ZGlvID0gW1xuICBcdFwiYXV0b3BsYXlcIixcbiAgXHRcImNvbnRyb2xzXCIsXG4gIFx0XCJjcm9zc29yaWdpblwiLFxuICBcdFwibG9vcFwiLFxuICBcdFwibXV0ZWRcIixcbiAgXHRcInByZWxvYWRcIixcbiAgXHRcInNyY1wiXG4gIF07XG4gIHZhciBiYXNlID0gW1xuICBcdFwiaHJlZlwiLFxuICBcdFwidGFyZ2V0XCJcbiAgXTtcbiAgdmFyIGJhc2Vmb250ID0gW1xuICBcdFwiY29sb3JcIixcbiAgXHRcImZhY2VcIixcbiAgXHRcInNpemVcIlxuICBdO1xuICB2YXIgYmRvID0gW1xuICBcdFwiZGlyXCJcbiAgXTtcbiAgdmFyIGJsb2NrcXVvdGUgPSBbXG4gIFx0XCJjaXRlXCJcbiAgXTtcbiAgdmFyIGJvZHkgPSBbXG4gIFx0XCJhbGlua1wiLFxuICBcdFwiYmFja2dyb3VuZFwiLFxuICBcdFwiYmdjb2xvclwiLFxuICBcdFwibGlua1wiLFxuICBcdFwidGV4dFwiLFxuICBcdFwidmxpbmtcIlxuICBdO1xuICB2YXIgYnIgPSBbXG4gIFx0XCJjbGVhclwiXG4gIF07XG4gIHZhciBidXR0b24gPSBbXG4gIFx0XCJhY2Nlc3NrZXlcIixcbiAgXHRcImF1dG9mb2N1c1wiLFxuICBcdFwiZGlzYWJsZWRcIixcbiAgXHRcImZvcm1cIixcbiAgXHRcImZvcm1hY3Rpb25cIixcbiAgXHRcImZvcm1lbmN0eXBlXCIsXG4gIFx0XCJmb3JtbWV0aG9kXCIsXG4gIFx0XCJmb3Jtbm92YWxpZGF0ZVwiLFxuICBcdFwiZm9ybXRhcmdldFwiLFxuICBcdFwibmFtZVwiLFxuICBcdFwidGFiaW5kZXhcIixcbiAgXHRcInR5cGVcIixcbiAgXHRcInZhbHVlXCJcbiAgXTtcbiAgdmFyIGNhbnZhcyA9IFtcbiAgXHRcImhlaWdodFwiLFxuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgY2FwdGlvbiA9IFtcbiAgXHRcImFsaWduXCJcbiAgXTtcbiAgdmFyIGNvbCA9IFtcbiAgXHRcImFsaWduXCIsXG4gIFx0XCJjaGFyXCIsXG4gIFx0XCJjaGFyb2ZmXCIsXG4gIFx0XCJzcGFuXCIsXG4gIFx0XCJ2YWxpZ25cIixcbiAgXHRcIndpZHRoXCJcbiAgXTtcbiAgdmFyIGNvbGdyb3VwID0gW1xuICBcdFwiYWxpZ25cIixcbiAgXHRcImNoYXJcIixcbiAgXHRcImNoYXJvZmZcIixcbiAgXHRcInNwYW5cIixcbiAgXHRcInZhbGlnblwiLFxuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgZGF0YSA9IFtcbiAgXHRcInZhbHVlXCJcbiAgXTtcbiAgdmFyIGRlbCA9IFtcbiAgXHRcImNpdGVcIixcbiAgXHRcImRhdGV0aW1lXCJcbiAgXTtcbiAgdmFyIGRldGFpbHMgPSBbXG4gIFx0XCJvcGVuXCJcbiAgXTtcbiAgdmFyIGRmbiA9IFtcbiAgXHRcInRpdGxlXCJcbiAgXTtcbiAgdmFyIGRpYWxvZyA9IFtcbiAgXHRcIm9wZW5cIlxuICBdO1xuICB2YXIgZGlyID0gW1xuICBcdFwiY29tcGFjdFwiXG4gIF07XG4gIHZhciBkaXYgPSBbXG4gIFx0XCJhbGlnblwiXG4gIF07XG4gIHZhciBkbCA9IFtcbiAgXHRcImNvbXBhY3RcIlxuICBdO1xuICB2YXIgZW1iZWQkMSA9IFtcbiAgXHRcImhlaWdodFwiLFxuICBcdFwic3JjXCIsXG4gIFx0XCJ0eXBlXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciBmaWVsZHNldCA9IFtcbiAgXHRcImRpc2FibGVkXCIsXG4gIFx0XCJmb3JtXCIsXG4gIFx0XCJuYW1lXCJcbiAgXTtcbiAgdmFyIGZvbnQgPSBbXG4gIFx0XCJjb2xvclwiLFxuICBcdFwiZmFjZVwiLFxuICBcdFwic2l6ZVwiXG4gIF07XG4gIHZhciBmb3JtID0gW1xuICBcdFwiYWNjZXB0XCIsXG4gIFx0XCJhY2NlcHQtY2hhcnNldFwiLFxuICBcdFwiYWN0aW9uXCIsXG4gIFx0XCJhdXRvY29tcGxldGVcIixcbiAgXHRcImVuY3R5cGVcIixcbiAgXHRcIm1ldGhvZFwiLFxuICBcdFwibmFtZVwiLFxuICBcdFwibm92YWxpZGF0ZVwiLFxuICBcdFwidGFyZ2V0XCJcbiAgXTtcbiAgdmFyIGZyYW1lID0gW1xuICBcdFwiZnJhbWVib3JkZXJcIixcbiAgXHRcImxvbmdkZXNjXCIsXG4gIFx0XCJtYXJnaW5oZWlnaHRcIixcbiAgXHRcIm1hcmdpbndpZHRoXCIsXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJub3Jlc2l6ZVwiLFxuICBcdFwic2Nyb2xsaW5nXCIsXG4gIFx0XCJzcmNcIlxuICBdO1xuICB2YXIgZnJhbWVzZXQgPSBbXG4gIFx0XCJjb2xzXCIsXG4gIFx0XCJyb3dzXCJcbiAgXTtcbiAgdmFyIGgxID0gW1xuICBcdFwiYWxpZ25cIlxuICBdO1xuICB2YXIgaDIgPSBbXG4gIFx0XCJhbGlnblwiXG4gIF07XG4gIHZhciBoMyA9IFtcbiAgXHRcImFsaWduXCJcbiAgXTtcbiAgdmFyIGg0ID0gW1xuICBcdFwiYWxpZ25cIlxuICBdO1xuICB2YXIgaDUgPSBbXG4gIFx0XCJhbGlnblwiXG4gIF07XG4gIHZhciBoNiA9IFtcbiAgXHRcImFsaWduXCJcbiAgXTtcbiAgdmFyIGhlYWQgPSBbXG4gIFx0XCJwcm9maWxlXCJcbiAgXTtcbiAgdmFyIGhyID0gW1xuICBcdFwiYWxpZ25cIixcbiAgXHRcIm5vc2hhZGVcIixcbiAgXHRcInNpemVcIixcbiAgXHRcIndpZHRoXCJcbiAgXTtcbiAgdmFyIGh0bWwgPSBbXG4gIFx0XCJtYW5pZmVzdFwiLFxuICBcdFwidmVyc2lvblwiXG4gIF07XG4gIHZhciBpZnJhbWUgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiYWxsb3dcIixcbiAgXHRcImFsbG93ZnVsbHNjcmVlblwiLFxuICBcdFwiYWxsb3dwYXltZW50cmVxdWVzdFwiLFxuICBcdFwiYWxsb3d1c2VybWVkaWFcIixcbiAgXHRcImZyYW1lYm9yZGVyXCIsXG4gIFx0XCJoZWlnaHRcIixcbiAgXHRcImxvbmdkZXNjXCIsXG4gIFx0XCJtYXJnaW5oZWlnaHRcIixcbiAgXHRcIm1hcmdpbndpZHRoXCIsXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJyZWZlcnJlcnBvbGljeVwiLFxuICBcdFwic2FuZGJveFwiLFxuICBcdFwic2Nyb2xsaW5nXCIsXG4gIFx0XCJzcmNcIixcbiAgXHRcInNyY2RvY1wiLFxuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgaW1nID0gW1xuICBcdFwiYWxpZ25cIixcbiAgXHRcImFsdFwiLFxuICBcdFwiYm9yZGVyXCIsXG4gIFx0XCJjcm9zc29yaWdpblwiLFxuICBcdFwiZGVjb2RpbmdcIixcbiAgXHRcImhlaWdodFwiLFxuICBcdFwiaHNwYWNlXCIsXG4gIFx0XCJpc21hcFwiLFxuICBcdFwibG9uZ2Rlc2NcIixcbiAgXHRcIm5hbWVcIixcbiAgXHRcInJlZmVycmVycG9saWN5XCIsXG4gIFx0XCJzaXplc1wiLFxuICBcdFwic3JjXCIsXG4gIFx0XCJzcmNzZXRcIixcbiAgXHRcInVzZW1hcFwiLFxuICBcdFwidnNwYWNlXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciBpbnB1dCA9IFtcbiAgXHRcImFjY2VwdFwiLFxuICBcdFwiYWNjZXNza2V5XCIsXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiYWx0XCIsXG4gIFx0XCJhdXRvY29tcGxldGVcIixcbiAgXHRcImF1dG9mb2N1c1wiLFxuICBcdFwiY2hlY2tlZFwiLFxuICBcdFwiZGlybmFtZVwiLFxuICBcdFwiZGlzYWJsZWRcIixcbiAgXHRcImZvcm1cIixcbiAgXHRcImZvcm1hY3Rpb25cIixcbiAgXHRcImZvcm1lbmN0eXBlXCIsXG4gIFx0XCJmb3JtbWV0aG9kXCIsXG4gIFx0XCJmb3Jtbm92YWxpZGF0ZVwiLFxuICBcdFwiZm9ybXRhcmdldFwiLFxuICBcdFwiaGVpZ2h0XCIsXG4gIFx0XCJpc21hcFwiLFxuICBcdFwibGlzdFwiLFxuICBcdFwibWF4XCIsXG4gIFx0XCJtYXhsZW5ndGhcIixcbiAgXHRcIm1pblwiLFxuICBcdFwibWlubGVuZ3RoXCIsXG4gIFx0XCJtdWx0aXBsZVwiLFxuICBcdFwibmFtZVwiLFxuICBcdFwicGF0dGVyblwiLFxuICBcdFwicGxhY2Vob2xkZXJcIixcbiAgXHRcInJlYWRvbmx5XCIsXG4gIFx0XCJyZXF1aXJlZFwiLFxuICBcdFwic2l6ZVwiLFxuICBcdFwic3JjXCIsXG4gIFx0XCJzdGVwXCIsXG4gIFx0XCJ0YWJpbmRleFwiLFxuICBcdFwidGl0bGVcIixcbiAgXHRcInR5cGVcIixcbiAgXHRcInVzZW1hcFwiLFxuICBcdFwidmFsdWVcIixcbiAgXHRcIndpZHRoXCJcbiAgXTtcbiAgdmFyIGlucyA9IFtcbiAgXHRcImNpdGVcIixcbiAgXHRcImRhdGV0aW1lXCJcbiAgXTtcbiAgdmFyIGlzaW5kZXggPSBbXG4gIFx0XCJwcm9tcHRcIlxuICBdO1xuICB2YXIgbGFiZWwgPSBbXG4gIFx0XCJhY2Nlc3NrZXlcIixcbiAgXHRcImZvclwiLFxuICBcdFwiZm9ybVwiXG4gIF07XG4gIHZhciBsZWdlbmQgPSBbXG4gIFx0XCJhY2Nlc3NrZXlcIixcbiAgXHRcImFsaWduXCJcbiAgXTtcbiAgdmFyIGxpID0gW1xuICBcdFwidHlwZVwiLFxuICBcdFwidmFsdWVcIlxuICBdO1xuICB2YXIgbGluayQzID0gW1xuICBcdFwiYXNcIixcbiAgXHRcImNoYXJzZXRcIixcbiAgXHRcImNvbG9yXCIsXG4gIFx0XCJjcm9zc29yaWdpblwiLFxuICBcdFwiaHJlZlwiLFxuICBcdFwiaHJlZmxhbmdcIixcbiAgXHRcImltYWdlc2l6ZXNcIixcbiAgXHRcImltYWdlc3Jjc2V0XCIsXG4gIFx0XCJpbnRlZ3JpdHlcIixcbiAgXHRcIm1lZGlhXCIsXG4gIFx0XCJub25jZVwiLFxuICBcdFwicmVmZXJyZXJwb2xpY3lcIixcbiAgXHRcInJlbFwiLFxuICBcdFwicmV2XCIsXG4gIFx0XCJzaXplc1wiLFxuICBcdFwidGFyZ2V0XCIsXG4gIFx0XCJ0aXRsZVwiLFxuICBcdFwidHlwZVwiXG4gIF07XG4gIHZhciBtYXAgPSBbXG4gIFx0XCJuYW1lXCJcbiAgXTtcbiAgdmFyIG1lbnUgPSBbXG4gIFx0XCJjb21wYWN0XCJcbiAgXTtcbiAgdmFyIG1ldGEgPSBbXG4gIFx0XCJjaGFyc2V0XCIsXG4gIFx0XCJjb250ZW50XCIsXG4gIFx0XCJodHRwLWVxdWl2XCIsXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJzY2hlbWVcIlxuICBdO1xuICB2YXIgbWV0ZXIgPSBbXG4gIFx0XCJoaWdoXCIsXG4gIFx0XCJsb3dcIixcbiAgXHRcIm1heFwiLFxuICBcdFwibWluXCIsXG4gIFx0XCJvcHRpbXVtXCIsXG4gIFx0XCJ2YWx1ZVwiXG4gIF07XG4gIHZhciBvYmplY3QgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiYXJjaGl2ZVwiLFxuICBcdFwiYm9yZGVyXCIsXG4gIFx0XCJjbGFzc2lkXCIsXG4gIFx0XCJjb2RlYmFzZVwiLFxuICBcdFwiY29kZXR5cGVcIixcbiAgXHRcImRhdGFcIixcbiAgXHRcImRlY2xhcmVcIixcbiAgXHRcImZvcm1cIixcbiAgXHRcImhlaWdodFwiLFxuICBcdFwiaHNwYWNlXCIsXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJzdGFuZGJ5XCIsXG4gIFx0XCJ0YWJpbmRleFwiLFxuICBcdFwidHlwZVwiLFxuICBcdFwidHlwZW11c3RtYXRjaFwiLFxuICBcdFwidXNlbWFwXCIsXG4gIFx0XCJ2c3BhY2VcIixcbiAgXHRcIndpZHRoXCJcbiAgXTtcbiAgdmFyIG9sID0gW1xuICBcdFwiY29tcGFjdFwiLFxuICBcdFwicmV2ZXJzZWRcIixcbiAgXHRcInN0YXJ0XCIsXG4gIFx0XCJ0eXBlXCJcbiAgXTtcbiAgdmFyIG9wdGdyb3VwID0gW1xuICBcdFwiZGlzYWJsZWRcIixcbiAgXHRcImxhYmVsXCJcbiAgXTtcbiAgdmFyIG9wdGlvbiA9IFtcbiAgXHRcImRpc2FibGVkXCIsXG4gIFx0XCJsYWJlbFwiLFxuICBcdFwic2VsZWN0ZWRcIixcbiAgXHRcInZhbHVlXCJcbiAgXTtcbiAgdmFyIG91dHB1dCA9IFtcbiAgXHRcImZvclwiLFxuICBcdFwiZm9ybVwiLFxuICBcdFwibmFtZVwiXG4gIF07XG4gIHZhciBwID0gW1xuICBcdFwiYWxpZ25cIlxuICBdO1xuICB2YXIgcGFyYW0gPSBbXG4gIFx0XCJuYW1lXCIsXG4gIFx0XCJ0eXBlXCIsXG4gIFx0XCJ2YWx1ZVwiLFxuICBcdFwidmFsdWV0eXBlXCJcbiAgXTtcbiAgdmFyIHByZSA9IFtcbiAgXHRcIndpZHRoXCJcbiAgXTtcbiAgdmFyIHByb2dyZXNzID0gW1xuICBcdFwibWF4XCIsXG4gIFx0XCJ2YWx1ZVwiXG4gIF07XG4gIHZhciBxID0gW1xuICBcdFwiY2l0ZVwiXG4gIF07XG4gIHZhciBzY3JpcHQgPSBbXG4gIFx0XCJhc3luY1wiLFxuICBcdFwiY2hhcnNldFwiLFxuICBcdFwiY3Jvc3NvcmlnaW5cIixcbiAgXHRcImRlZmVyXCIsXG4gIFx0XCJpbnRlZ3JpdHlcIixcbiAgXHRcImxhbmd1YWdlXCIsXG4gIFx0XCJub21vZHVsZVwiLFxuICBcdFwibm9uY2VcIixcbiAgXHRcInJlZmVycmVycG9saWN5XCIsXG4gIFx0XCJzcmNcIixcbiAgXHRcInR5cGVcIlxuICBdO1xuICB2YXIgc2VsZWN0ID0gW1xuICBcdFwiYXV0b2NvbXBsZXRlXCIsXG4gIFx0XCJhdXRvZm9jdXNcIixcbiAgXHRcImRpc2FibGVkXCIsXG4gIFx0XCJmb3JtXCIsXG4gIFx0XCJtdWx0aXBsZVwiLFxuICBcdFwibmFtZVwiLFxuICBcdFwicmVxdWlyZWRcIixcbiAgXHRcInNpemVcIixcbiAgXHRcInRhYmluZGV4XCJcbiAgXTtcbiAgdmFyIHNsb3QgPSBbXG4gIFx0XCJuYW1lXCJcbiAgXTtcbiAgdmFyIHNvdXJjZSQxID0gW1xuICBcdFwibWVkaWFcIixcbiAgXHRcInNpemVzXCIsXG4gIFx0XCJzcmNcIixcbiAgXHRcInNyY3NldFwiLFxuICBcdFwidHlwZVwiXG4gIF07XG4gIHZhciBzdHlsZSA9IFtcbiAgXHRcIm1lZGlhXCIsXG4gIFx0XCJub25jZVwiLFxuICBcdFwidGl0bGVcIixcbiAgXHRcInR5cGVcIlxuICBdO1xuICB2YXIgdGFibGUgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiYmdjb2xvclwiLFxuICBcdFwiYm9yZGVyXCIsXG4gIFx0XCJjZWxscGFkZGluZ1wiLFxuICBcdFwiY2VsbHNwYWNpbmdcIixcbiAgXHRcImZyYW1lXCIsXG4gIFx0XCJydWxlc1wiLFxuICBcdFwic3VtbWFyeVwiLFxuICBcdFwid2lkdGhcIlxuICBdO1xuICB2YXIgdGJvZHkgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiY2hhclwiLFxuICBcdFwiY2hhcm9mZlwiLFxuICBcdFwidmFsaWduXCJcbiAgXTtcbiAgdmFyIHRkID0gW1xuICBcdFwiYWJiclwiLFxuICBcdFwiYWxpZ25cIixcbiAgXHRcImF4aXNcIixcbiAgXHRcImJnY29sb3JcIixcbiAgXHRcImNoYXJcIixcbiAgXHRcImNoYXJvZmZcIixcbiAgXHRcImNvbHNwYW5cIixcbiAgXHRcImhlYWRlcnNcIixcbiAgXHRcImhlaWdodFwiLFxuICBcdFwibm93cmFwXCIsXG4gIFx0XCJyb3dzcGFuXCIsXG4gIFx0XCJzY29wZVwiLFxuICBcdFwidmFsaWduXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciB0ZXh0YXJlYSA9IFtcbiAgXHRcImFjY2Vzc2tleVwiLFxuICBcdFwiYXV0b2NvbXBsZXRlXCIsXG4gIFx0XCJhdXRvZm9jdXNcIixcbiAgXHRcImNvbHNcIixcbiAgXHRcImRpcm5hbWVcIixcbiAgXHRcImRpc2FibGVkXCIsXG4gIFx0XCJmb3JtXCIsXG4gIFx0XCJtYXhsZW5ndGhcIixcbiAgXHRcIm1pbmxlbmd0aFwiLFxuICBcdFwibmFtZVwiLFxuICBcdFwicGxhY2Vob2xkZXJcIixcbiAgXHRcInJlYWRvbmx5XCIsXG4gIFx0XCJyZXF1aXJlZFwiLFxuICBcdFwicm93c1wiLFxuICBcdFwidGFiaW5kZXhcIixcbiAgXHRcIndyYXBcIlxuICBdO1xuICB2YXIgdGZvb3QgPSBbXG4gIFx0XCJhbGlnblwiLFxuICBcdFwiY2hhclwiLFxuICBcdFwiY2hhcm9mZlwiLFxuICBcdFwidmFsaWduXCJcbiAgXTtcbiAgdmFyIHRoID0gW1xuICBcdFwiYWJiclwiLFxuICBcdFwiYWxpZ25cIixcbiAgXHRcImF4aXNcIixcbiAgXHRcImJnY29sb3JcIixcbiAgXHRcImNoYXJcIixcbiAgXHRcImNoYXJvZmZcIixcbiAgXHRcImNvbHNwYW5cIixcbiAgXHRcImhlYWRlcnNcIixcbiAgXHRcImhlaWdodFwiLFxuICBcdFwibm93cmFwXCIsXG4gIFx0XCJyb3dzcGFuXCIsXG4gIFx0XCJzY29wZVwiLFxuICBcdFwidmFsaWduXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciB0aGVhZCA9IFtcbiAgXHRcImFsaWduXCIsXG4gIFx0XCJjaGFyXCIsXG4gIFx0XCJjaGFyb2ZmXCIsXG4gIFx0XCJ2YWxpZ25cIlxuICBdO1xuICB2YXIgdGltZSA9IFtcbiAgXHRcImRhdGV0aW1lXCJcbiAgXTtcbiAgdmFyIHRyID0gW1xuICBcdFwiYWxpZ25cIixcbiAgXHRcImJnY29sb3JcIixcbiAgXHRcImNoYXJcIixcbiAgXHRcImNoYXJvZmZcIixcbiAgXHRcInZhbGlnblwiXG4gIF07XG4gIHZhciB0cmFjayA9IFtcbiAgXHRcImRlZmF1bHRcIixcbiAgXHRcImtpbmRcIixcbiAgXHRcImxhYmVsXCIsXG4gIFx0XCJzcmNcIixcbiAgXHRcInNyY2xhbmdcIlxuICBdO1xuICB2YXIgdWwgPSBbXG4gIFx0XCJjb21wYWN0XCIsXG4gIFx0XCJ0eXBlXCJcbiAgXTtcbiAgdmFyIHZpZGVvID0gW1xuICBcdFwiYXV0b3BsYXlcIixcbiAgXHRcImNvbnRyb2xzXCIsXG4gIFx0XCJjcm9zc29yaWdpblwiLFxuICBcdFwiaGVpZ2h0XCIsXG4gIFx0XCJsb29wXCIsXG4gIFx0XCJtdXRlZFwiLFxuICBcdFwicGxheXNpbmxpbmVcIixcbiAgXHRcInBvc3RlclwiLFxuICBcdFwicHJlbG9hZFwiLFxuICBcdFwic3JjXCIsXG4gIFx0XCJ3aWR0aFwiXG4gIF07XG4gIHZhciBpbmRleCQxID0ge1xuICBcdFwiKlwiOiBbXG4gIFx0XCJhY2Nlc3NrZXlcIixcbiAgXHRcImF1dG9jYXBpdGFsaXplXCIsXG4gIFx0XCJhdXRvZm9jdXNcIixcbiAgXHRcImNsYXNzXCIsXG4gIFx0XCJjb250ZW50ZWRpdGFibGVcIixcbiAgXHRcImRpclwiLFxuICBcdFwiZHJhZ2dhYmxlXCIsXG4gIFx0XCJlbnRlcmtleWhpbnRcIixcbiAgXHRcImhpZGRlblwiLFxuICBcdFwiaWRcIixcbiAgXHRcImlucHV0bW9kZVwiLFxuICBcdFwiaXNcIixcbiAgXHRcIml0ZW1pZFwiLFxuICBcdFwiaXRlbXByb3BcIixcbiAgXHRcIml0ZW1yZWZcIixcbiAgXHRcIml0ZW1zY29wZVwiLFxuICBcdFwiaXRlbXR5cGVcIixcbiAgXHRcImxhbmdcIixcbiAgXHRcIm5vbmNlXCIsXG4gIFx0XCJzbG90XCIsXG4gIFx0XCJzcGVsbGNoZWNrXCIsXG4gIFx0XCJzdHlsZVwiLFxuICBcdFwidGFiaW5kZXhcIixcbiAgXHRcInRpdGxlXCIsXG4gIFx0XCJ0cmFuc2xhdGVcIlxuICBdLFxuICBcdGE6IGEsXG4gIFx0YWJicjogYWJicixcbiAgXHRhcHBsZXQ6IGFwcGxldCxcbiAgXHRhcmVhOiBhcmVhLFxuICBcdGF1ZGlvOiBhdWRpbyxcbiAgXHRiYXNlOiBiYXNlLFxuICBcdGJhc2Vmb250OiBiYXNlZm9udCxcbiAgXHRiZG86IGJkbyxcbiAgXHRibG9ja3F1b3RlOiBibG9ja3F1b3RlLFxuICBcdGJvZHk6IGJvZHksXG4gIFx0YnI6IGJyLFxuICBcdGJ1dHRvbjogYnV0dG9uLFxuICBcdGNhbnZhczogY2FudmFzLFxuICBcdGNhcHRpb246IGNhcHRpb24sXG4gIFx0Y29sOiBjb2wsXG4gIFx0Y29sZ3JvdXA6IGNvbGdyb3VwLFxuICBcdGRhdGE6IGRhdGEsXG4gIFx0ZGVsOiBkZWwsXG4gIFx0ZGV0YWlsczogZGV0YWlscyxcbiAgXHRkZm46IGRmbixcbiAgXHRkaWFsb2c6IGRpYWxvZyxcbiAgXHRkaXI6IGRpcixcbiAgXHRkaXY6IGRpdixcbiAgXHRkbDogZGwsXG4gIFx0ZW1iZWQ6IGVtYmVkJDEsXG4gIFx0ZmllbGRzZXQ6IGZpZWxkc2V0LFxuICBcdGZvbnQ6IGZvbnQsXG4gIFx0Zm9ybTogZm9ybSxcbiAgXHRmcmFtZTogZnJhbWUsXG4gIFx0ZnJhbWVzZXQ6IGZyYW1lc2V0LFxuICBcdGgxOiBoMSxcbiAgXHRoMjogaDIsXG4gIFx0aDM6IGgzLFxuICBcdGg0OiBoNCxcbiAgXHRoNTogaDUsXG4gIFx0aDY6IGg2LFxuICBcdGhlYWQ6IGhlYWQsXG4gIFx0aHI6IGhyLFxuICBcdGh0bWw6IGh0bWwsXG4gIFx0aWZyYW1lOiBpZnJhbWUsXG4gIFx0aW1nOiBpbWcsXG4gIFx0aW5wdXQ6IGlucHV0LFxuICBcdGluczogaW5zLFxuICBcdGlzaW5kZXg6IGlzaW5kZXgsXG4gIFx0bGFiZWw6IGxhYmVsLFxuICBcdGxlZ2VuZDogbGVnZW5kLFxuICBcdGxpOiBsaSxcbiAgXHRsaW5rOiBsaW5rJDMsXG4gIFx0bWFwOiBtYXAsXG4gIFx0bWVudTogbWVudSxcbiAgXHRtZXRhOiBtZXRhLFxuICBcdG1ldGVyOiBtZXRlcixcbiAgXHRvYmplY3Q6IG9iamVjdCxcbiAgXHRvbDogb2wsXG4gIFx0b3B0Z3JvdXA6IG9wdGdyb3VwLFxuICBcdG9wdGlvbjogb3B0aW9uLFxuICBcdG91dHB1dDogb3V0cHV0LFxuICBcdHA6IHAsXG4gIFx0cGFyYW06IHBhcmFtLFxuICBcdHByZTogcHJlLFxuICBcdHByb2dyZXNzOiBwcm9ncmVzcyxcbiAgXHRxOiBxLFxuICBcdHNjcmlwdDogc2NyaXB0LFxuICBcdHNlbGVjdDogc2VsZWN0LFxuICBcdHNsb3Q6IHNsb3QsXG4gIFx0c291cmNlOiBzb3VyY2UkMSxcbiAgXHRzdHlsZTogc3R5bGUsXG4gIFx0dGFibGU6IHRhYmxlLFxuICBcdHRib2R5OiB0Ym9keSxcbiAgXHR0ZDogdGQsXG4gIFx0dGV4dGFyZWE6IHRleHRhcmVhLFxuICBcdHRmb290OiB0Zm9vdCxcbiAgXHR0aDogdGgsXG4gIFx0dGhlYWQ6IHRoZWFkLFxuICBcdHRpbWU6IHRpbWUsXG4gIFx0dHI6IHRyLFxuICBcdHRyYWNrOiB0cmFjayxcbiAgXHR1bDogdWwsXG4gIFx0dmlkZW86IHZpZGVvXG4gIH07XG5cbiAgdmFyIGh0bWxFbGVtZW50QXR0cmlidXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYTogYSxcbiAgICBhYmJyOiBhYmJyLFxuICAgIGFwcGxldDogYXBwbGV0LFxuICAgIGFyZWE6IGFyZWEsXG4gICAgYXVkaW86IGF1ZGlvLFxuICAgIGJhc2U6IGJhc2UsXG4gICAgYmFzZWZvbnQ6IGJhc2Vmb250LFxuICAgIGJkbzogYmRvLFxuICAgIGJsb2NrcXVvdGU6IGJsb2NrcXVvdGUsXG4gICAgYm9keTogYm9keSxcbiAgICBicjogYnIsXG4gICAgYnV0dG9uOiBidXR0b24sXG4gICAgY2FudmFzOiBjYW52YXMsXG4gICAgY2FwdGlvbjogY2FwdGlvbixcbiAgICBjb2w6IGNvbCxcbiAgICBjb2xncm91cDogY29sZ3JvdXAsXG4gICAgZGF0YTogZGF0YSxcbiAgICBkZWw6IGRlbCxcbiAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgIGRmbjogZGZuLFxuICAgIGRpYWxvZzogZGlhbG9nLFxuICAgIGRpcjogZGlyLFxuICAgIGRpdjogZGl2LFxuICAgIGRsOiBkbCxcbiAgICBlbWJlZDogZW1iZWQkMSxcbiAgICBmaWVsZHNldDogZmllbGRzZXQsXG4gICAgZm9udDogZm9udCxcbiAgICBmb3JtOiBmb3JtLFxuICAgIGZyYW1lOiBmcmFtZSxcbiAgICBmcmFtZXNldDogZnJhbWVzZXQsXG4gICAgaDE6IGgxLFxuICAgIGgyOiBoMixcbiAgICBoMzogaDMsXG4gICAgaDQ6IGg0LFxuICAgIGg1OiBoNSxcbiAgICBoNjogaDYsXG4gICAgaGVhZDogaGVhZCxcbiAgICBocjogaHIsXG4gICAgaHRtbDogaHRtbCxcbiAgICBpZnJhbWU6IGlmcmFtZSxcbiAgICBpbWc6IGltZyxcbiAgICBpbnB1dDogaW5wdXQsXG4gICAgaW5zOiBpbnMsXG4gICAgaXNpbmRleDogaXNpbmRleCxcbiAgICBsYWJlbDogbGFiZWwsXG4gICAgbGVnZW5kOiBsZWdlbmQsXG4gICAgbGk6IGxpLFxuICAgIGxpbms6IGxpbmskMyxcbiAgICBtYXA6IG1hcCxcbiAgICBtZW51OiBtZW51LFxuICAgIG1ldGE6IG1ldGEsXG4gICAgbWV0ZXI6IG1ldGVyLFxuICAgIG9iamVjdDogb2JqZWN0LFxuICAgIG9sOiBvbCxcbiAgICBvcHRncm91cDogb3B0Z3JvdXAsXG4gICAgb3B0aW9uOiBvcHRpb24sXG4gICAgb3V0cHV0OiBvdXRwdXQsXG4gICAgcDogcCxcbiAgICBwYXJhbTogcGFyYW0sXG4gICAgcHJlOiBwcmUsXG4gICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgIHE6IHEsXG4gICAgc2NyaXB0OiBzY3JpcHQsXG4gICAgc2VsZWN0OiBzZWxlY3QsXG4gICAgc2xvdDogc2xvdCxcbiAgICBzb3VyY2U6IHNvdXJjZSQxLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICB0YWJsZTogdGFibGUsXG4gICAgdGJvZHk6IHRib2R5LFxuICAgIHRkOiB0ZCxcbiAgICB0ZXh0YXJlYTogdGV4dGFyZWEsXG4gICAgdGZvb3Q6IHRmb290LFxuICAgIHRoOiB0aCxcbiAgICB0aGVhZDogdGhlYWQsXG4gICAgdGltZTogdGltZSxcbiAgICB0cjogdHIsXG4gICAgdHJhY2s6IHRyYWNrLFxuICAgIHVsOiB1bCxcbiAgICB2aWRlbzogdmlkZW8sXG4gICAgJ2RlZmF1bHQnOiBpbmRleCQxXG4gIH0pO1xuXG4gIHZhciBodG1sVGFnTmFtZXMkMSA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoaHRtbFRhZ05hbWVzKTtcblxuICB2YXIgaHRtbEVsZW1lbnRBdHRyaWJ1dGVzJDEgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKGh0bWxFbGVtZW50QXR0cmlidXRlcyk7XG5cbiAgY29uc3Qge1xuICAgIENTU19ESVNQTEFZX1RBR1MsXG4gICAgQ1NTX0RJU1BMQVlfREVGQVVMVCxcbiAgICBDU1NfV0hJVEVfU1BBQ0VfVEFHUyxcbiAgICBDU1NfV0hJVEVfU1BBQ0VfREVGQVVMVFxuICB9ID0ganNvbjtcbiAgY29uc3QgSFRNTF9UQUdTID0gYXJyYXlUb01hcChodG1sVGFnTmFtZXMkMSk7XG4gIGNvbnN0IEhUTUxfRUxFTUVOVF9BVFRSSUJVVEVTID0gbWFwT2JqZWN0KGh0bWxFbGVtZW50QXR0cmlidXRlcyQxLCBhcnJheVRvTWFwKTtcblxuICBmdW5jdGlvbiBhcnJheVRvTWFwKGFycmF5KSB7XG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkpIHtcbiAgICAgIG1hcFt2YWx1ZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBPYmplY3Qob2JqZWN0LCBmbikge1xuICAgIGNvbnN0IG5ld09iamVjdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgICBuZXdPYmplY3Rba2V5XSA9IGZuKG9iamVjdFtrZXldLCBrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmplY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRQcmVzZXJ2ZUNvbnRlbnQobm9kZSwgb3B0aW9ucykge1xuICAgIGlmICghbm9kZS5lbmRTb3VyY2VTcGFuKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5mdWxsTmFtZSA9PT0gXCJ0ZW1wbGF0ZVwiICYmIG5vZGUuYXR0ck1hcC5sYW5nICYmIG5vZGUuYXR0ck1hcC5sYW5nICE9PSBcImh0bWxcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyB1bnRlcm1pbmF0ZWQgbm9kZSBpbiBpZSBjb25kaXRpb25hbCBjb21tZW50XG4gICAgLy8gZS5nLiA8IS0tW2lmIGx0IElFIDldPjxodG1sPjwhW2VuZGlmXS0tPlxuXG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcImllQ29uZGl0aW9uYWxDb21tZW50XCIgJiYgbm9kZS5sYXN0Q2hpbGQgJiYgIW5vZGUubGFzdENoaWxkLmlzU2VsZkNsb3NpbmcgJiYgIW5vZGUubGFzdENoaWxkLmVuZFNvdXJjZVNwYW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gaW5jb21wbGV0ZSBodG1sIGluIGllIGNvbmRpdGlvbmFsIGNvbW1lbnRcbiAgICAvLyBlLmcuIDwhLS1baWYgbHQgSUUgOV0+PC9kaXY+PCFbZW5kaWZdLS0+XG5cblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiaWVDb25kaXRpb25hbENvbW1lbnRcIiAmJiAhbm9kZS5jb21wbGV0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyB0b3AtbGV2ZWwgZWxlbWVudHMgKGV4Y2x1ZGluZyA8dGVtcGxhdGU+LCA8c3R5bGU+IGFuZCA8c2NyaXB0PikgaW4gVnVlIFNGQyBhcmUgY29uc2lkZXJlZCBjdXN0b20gYmxvY2tcbiAgICAvLyBjdXN0b20gYmxvY2tzIGNhbiBiZSB3cml0dGVuIGluIG90aGVyIGxhbmd1YWdlcyBzbyB3ZSBzaG91bGQgcHJlc2VydmUgdGhlbSB0byBub3QgYnJlYWsgdGhlIGNvZGVcblxuXG4gICAgaWYgKG9wdGlvbnMucGFyc2VyID09PSBcInZ1ZVwiICYmIG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5wYXJlbnQudHlwZSA9PT0gXCJyb290XCIgJiYgIVtcInRlbXBsYXRlXCIsIFwic3R5bGVcIiwgXCJzY3JpcHRcIiwgLy8gdnVlIHBhcnNlciBjYW4gYmUgdXNlZCBmb3IgdnVlIGRvbSB0ZW1wbGF0ZSBhcyB3ZWxsLCBzbyB3ZSBzaG91bGQgc3RpbGwgZm9ybWF0IHRvcC1sZXZlbCA8aHRtbD5cbiAgICBcImh0bWxcIl0uaW5jbHVkZXMobm9kZS5mdWxsTmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gVE9ETzogaGFuZGxlIG5vbi10ZXh0IGNoaWxkcmVuIGluIDxwcmU+XG5cblxuICAgIGlmIChpc1ByZUxpa2VOb2RlKG5vZGUpICYmIG5vZGUuY2hpbGRyZW4uc29tZShjaGlsZCA9PiBjaGlsZC50eXBlICE9PSBcInRleHRcIiAmJiBjaGlsZC50eXBlICE9PSBcImludGVycG9sYXRpb25cIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1ByZXR0aWVySWdub3JlJDIobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiYXR0cmlidXRlXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUucGFyZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBub2RlLmluZGV4ICE9PSBcIm51bWJlclwiIHx8IG5vZGUuaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2Tm9kZSA9IG5vZGUucGFyZW50LmNoaWxkcmVuW25vZGUuaW5kZXggLSAxXTtcbiAgICByZXR1cm4gaXNQcmV0dGllcklnbm9yZShwcmV2Tm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ByZXR0aWVySWdub3JlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImNvbW1lbnRcIiAmJiBub2RlLnZhbHVlLnRyaW0oKSA9PT0gXCJwcmV0dGllci1pZ25vcmVcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByZXR0aWVySWdub3JlQXR0cmlidXRlQ29tbWVudERhdGEodmFsdWUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnRyaW0oKS5tYXRjaCgvXnByZXR0aWVyLWlnbm9yZS1hdHRyaWJ1dGUoPzpcXHMrKFteXSspKT8kLyk7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFtYXRjaFsxXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoWzFdLnNwbGl0KC9cXHMrLyk7XG4gIH1cbiAgLyoqIHRoZXJlJ3Mgbm8gb3BlbmluZy9jbG9zaW5nIHRhZyBvciBpdCdzIGNvbnNpZGVyZWQgbm90IGJyZWFrYWJsZSAqL1xuXG5cbiAgZnVuY3Rpb24gaXNUZXh0TGlrZU5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwidGV4dFwiIHx8IG5vZGUudHlwZSA9PT0gXCJjb21tZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NjcmlwdExpa2VUYWcobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIChub2RlLmZ1bGxOYW1lID09PSBcInNjcmlwdFwiIHx8IG5vZGUuZnVsbE5hbWUgPT09IFwic3R5bGVcIiB8fCBub2RlLmZ1bGxOYW1lID09PSBcInN2ZzpzdHlsZVwiIHx8IGlzVW5rbm93bk5hbWVzcGFjZShub2RlKSAmJiAobm9kZS5uYW1lID09PSBcInNjcmlwdFwiIHx8IG5vZGUubmFtZSA9PT0gXCJzdHlsZVwiKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Zyb250TWF0dGVyTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ5YW1sXCIgfHwgbm9kZS50eXBlID09PSBcInRvbWxcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkhhdmVJbnRlcnBvbGF0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jaGlsZHJlbiAmJiAhaXNTY3JpcHRMaWtlVGFnKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIGlzU2NyaXB0TGlrZVRhZyhub2RlKSB8fCBub2RlLnR5cGUgPT09IFwiaW50ZXJwb2xhdGlvblwiIHx8IGlzSW5kZW50YXRpb25TZW5zaXRpdmVOb2RlKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJbmRlbnRhdGlvblNlbnNpdGl2ZU5vZGUobm9kZSkge1xuICAgIHJldHVybiBnZXROb2RlQ3NzU3R5bGVXaGl0ZVNwYWNlKG5vZGUpLnN0YXJ0c1dpdGgoXCJwcmVcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZU5vZGUobm9kZSkge1xuICAgIGNvbnN0IGlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlID0gX2lzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlTm9kZSgpO1xuXG4gICAgaWYgKGlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlICYmICFub2RlLnByZXYgJiYgbm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQudGFnRGVmaW5pdGlvbiAmJiBub2RlLnBhcmVudC50YWdEZWZpbml0aW9uLmlnbm9yZUZpcnN0TGYpIHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiaW50ZXJwb2xhdGlvblwiO1xuICAgIH1cblxuICAgIHJldHVybiBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZTtcblxuICAgIGZ1bmN0aW9uIF9pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZU5vZGUoKSB7XG4gICAgICBpZiAoaXNGcm9udE1hdHRlck5vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5vZGUudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgbm9kZS50eXBlID09PSBcImludGVycG9sYXRpb25cIikgJiYgbm9kZS5wcmV2ICYmIChub2RlLnByZXYudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgbm9kZS5wcmV2LnR5cGUgPT09IFwiaW50ZXJwb2xhdGlvblwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFub2RlLnBhcmVudCB8fCBub2RlLnBhcmVudC5jc3NEaXNwbGF5ID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1ByZUxpa2VOb2RlKG5vZGUucGFyZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFub2RlLnByZXYgJiYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwicm9vdFwiIHx8IGlzUHJlTGlrZU5vZGUobm9kZSkgJiYgbm9kZS5wYXJlbnQgfHwgaXNTY3JpcHRMaWtlVGFnKG5vZGUucGFyZW50KSB8fCAhaXNGaXJzdENoaWxkTGVhZGluZ1NwYWNlU2Vuc2l0aXZlQ3NzRGlzcGxheShub2RlLnBhcmVudC5jc3NEaXNwbGF5KSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5wcmV2ICYmICFpc05leHRMZWFkaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KG5vZGUucHJldi5jc3NEaXNwbGF5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZU5vZGUobm9kZSkge1xuICAgIGlmIChpc0Zyb250TWF0dGVyTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICgobm9kZS50eXBlID09PSBcInRleHRcIiB8fCBub2RlLnR5cGUgPT09IFwiaW50ZXJwb2xhdGlvblwiKSAmJiBub2RlLm5leHQgJiYgKG5vZGUubmV4dC50eXBlID09PSBcInRleHRcIiB8fCBub2RlLm5leHQudHlwZSA9PT0gXCJpbnRlcnBvbGF0aW9uXCIpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUucGFyZW50IHx8IG5vZGUucGFyZW50LmNzc0Rpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJlTGlrZU5vZGUobm9kZS5wYXJlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUubmV4dCAmJiAobm9kZS5wYXJlbnQudHlwZSA9PT0gXCJyb290XCIgfHwgaXNQcmVMaWtlTm9kZShub2RlKSAmJiBub2RlLnBhcmVudCB8fCBpc1NjcmlwdExpa2VUYWcobm9kZS5wYXJlbnQpIHx8ICFpc0xhc3RDaGlsZFRyYWlsaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KG5vZGUucGFyZW50LmNzc0Rpc3BsYXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlLm5leHQgJiYgIWlzUHJldlRyYWlsaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KG5vZGUubmV4dC5jc3NEaXNwbGF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIGlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZUNzc0Rpc3BsYXkobm9kZS5jc3NEaXNwbGF5KSAmJiAhaXNTY3JpcHRMaWtlVGFnKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2VOZXh0RW1wdHlMaW5lKG5vZGUpIHtcbiAgICByZXR1cm4gaXNGcm9udE1hdHRlck5vZGUobm9kZSkgfHwgbm9kZS5uZXh0ICYmIG5vZGUuc291cmNlU3Bhbi5lbmQubGluZSArIDEgPCBub2RlLm5leHQuc291cmNlU3Bhbi5zdGFydC5saW5lO1xuICB9XG4gIC8qKiBmaXJzdENoaWxkIGxlYWRpbmdTcGFjZXMgYW5kIGxhc3RDaGlsZCB0cmFpbGluZ1NwYWNlcyAqL1xuXG5cbiAgZnVuY3Rpb24gZm9yY2VCcmVha0NvbnRlbnQobm9kZSkge1xuICAgIHJldHVybiBmb3JjZUJyZWFrQ2hpbGRyZW4obm9kZSkgfHwgbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiAoW1wiYm9keVwiLCBcInNjcmlwdFwiLCBcInN0eWxlXCJdLmluY2x1ZGVzKG5vZGUubmFtZSkgfHwgbm9kZS5jaGlsZHJlbi5zb21lKGNoaWxkID0+IGhhc05vblRleHRDaGlsZChjaGlsZCkpKSB8fCBub2RlLmZpcnN0Q2hpbGQgJiYgbm9kZS5maXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBoYXNMZWFkaW5nTGluZUJyZWFrKG5vZGUuZmlyc3RDaGlsZCkgJiYgKCFub2RlLmxhc3RDaGlsZC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUgfHwgaGFzVHJhaWxpbmdMaW5lQnJlYWsobm9kZS5sYXN0Q2hpbGQpKTtcbiAgfVxuICAvKiogc3BhY2VzIGJldHdlZW4gY2hpbGRyZW4gKi9cblxuXG4gIGZ1bmN0aW9uIGZvcmNlQnJlYWtDaGlsZHJlbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDAgJiYgKFtcImh0bWxcIiwgXCJoZWFkXCIsIFwidWxcIiwgXCJvbFwiLCBcInNlbGVjdFwiXS5pbmNsdWRlcyhub2RlLm5hbWUpIHx8IG5vZGUuY3NzRGlzcGxheS5zdGFydHNXaXRoKFwidGFibGVcIikgJiYgbm9kZS5jc3NEaXNwbGF5ICE9PSBcInRhYmxlLWNlbGxcIik7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmZXJIYXJkbGluZUFzTGVhZGluZ1NwYWNlcyhub2RlKSB7XG4gICAgcmV0dXJuIHByZWZlckhhcmRsaW5lQXNTdXJyb3VuZGluZ1NwYWNlcyhub2RlKSB8fCBub2RlLnByZXYgJiYgcHJlZmVySGFyZGxpbmVBc1RyYWlsaW5nU3BhY2VzKG5vZGUucHJldikgfHwgaGFzU3Vycm91bmRpbmdMaW5lQnJlYWsobm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmZXJIYXJkbGluZUFzVHJhaWxpbmdTcGFjZXMobm9kZSkge1xuICAgIHJldHVybiBwcmVmZXJIYXJkbGluZUFzU3Vycm91bmRpbmdTcGFjZXMobm9kZSkgfHwgbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBub2RlLmZ1bGxOYW1lID09PSBcImJyXCIgfHwgaGFzU3Vycm91bmRpbmdMaW5lQnJlYWsobm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNTdXJyb3VuZGluZ0xpbmVCcmVhayhub2RlKSB7XG4gICAgcmV0dXJuIGhhc0xlYWRpbmdMaW5lQnJlYWsobm9kZSkgJiYgaGFzVHJhaWxpbmdMaW5lQnJlYWsobm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNMZWFkaW5nTGluZUJyZWFrKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5oYXNMZWFkaW5nU3BhY2VzICYmIChub2RlLnByZXYgPyBub2RlLnByZXYuc291cmNlU3Bhbi5lbmQubGluZSA8IG5vZGUuc291cmNlU3Bhbi5zdGFydC5saW5lIDogbm9kZS5wYXJlbnQudHlwZSA9PT0gXCJyb290XCIgfHwgbm9kZS5wYXJlbnQuc3RhcnRTb3VyY2VTcGFuLmVuZC5saW5lIDwgbm9kZS5zb3VyY2VTcGFuLnN0YXJ0LmxpbmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzVHJhaWxpbmdMaW5lQnJlYWsobm9kZSkge1xuICAgIHJldHVybiBub2RlLmhhc1RyYWlsaW5nU3BhY2VzICYmIChub2RlLm5leHQgPyBub2RlLm5leHQuc291cmNlU3Bhbi5zdGFydC5saW5lID4gbm9kZS5zb3VyY2VTcGFuLmVuZC5saW5lIDogbm9kZS5wYXJlbnQudHlwZSA9PT0gXCJyb290XCIgfHwgbm9kZS5wYXJlbnQuZW5kU291cmNlU3BhbiAmJiBub2RlLnBhcmVudC5lbmRTb3VyY2VTcGFuLnN0YXJ0LmxpbmUgPiBub2RlLnNvdXJjZVNwYW4uZW5kLmxpbmUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlZmVySGFyZGxpbmVBc1N1cnJvdW5kaW5nU3BhY2VzKG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxDb21tZW50XCI6XG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgY2FzZSBcImRpcmVjdGl2ZVwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgY2FzZSBcImVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIFtcInNjcmlwdFwiLCBcInNlbGVjdFwiXS5pbmNsdWRlcyhub2RlLm5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExhc3REZXNjZW5kYW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5sYXN0Q2hpbGQgPyBnZXRMYXN0RGVzY2VuZGFudChub2RlLmxhc3RDaGlsZCkgOiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzTm9uVGV4dENoaWxkKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLnNvbWUoY2hpbGQgPT4gY2hpbGQudHlwZSAhPT0gXCJ0ZXh0XCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5mZXJTY3JpcHRQYXJzZXIobm9kZSkge1xuICAgIGlmIChub2RlLm5hbWUgPT09IFwic2NyaXB0XCIgJiYgIW5vZGUuYXR0ck1hcC5zcmMpIHtcbiAgICAgIGlmICghbm9kZS5hdHRyTWFwLmxhbmcgJiYgIW5vZGUuYXR0ck1hcC50eXBlIHx8IG5vZGUuYXR0ck1hcC50eXBlID09PSBcIm1vZHVsZVwiIHx8IG5vZGUuYXR0ck1hcC50eXBlID09PSBcInRleHQvamF2YXNjcmlwdFwiIHx8IG5vZGUuYXR0ck1hcC50eXBlID09PSBcInRleHQvYmFiZWxcIiB8fCBub2RlLmF0dHJNYXAudHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfHwgbm9kZS5hdHRyTWFwLmxhbmcgPT09IFwianN4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYmFiZWxcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuYXR0ck1hcC50eXBlID09PSBcImFwcGxpY2F0aW9uL3gtdHlwZXNjcmlwdFwiIHx8IG5vZGUuYXR0ck1hcC5sYW5nID09PSBcInRzXCIgfHwgbm9kZS5hdHRyTWFwLmxhbmcgPT09IFwidHN4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwidHlwZXNjcmlwdFwiO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5hdHRyTWFwLnR5cGUgPT09IFwidGV4dC9tYXJrZG93blwiKSB7XG4gICAgICAgIHJldHVybiBcIm1hcmtkb3duXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmF0dHJNYXAudHlwZS5lbmRzV2l0aChcImpzb25cIikgfHwgbm9kZS5hdHRyTWFwLnR5cGUuZW5kc1dpdGgoXCJpbXBvcnRtYXBcIikpIHtcbiAgICAgICAgcmV0dXJuIFwianNvblwiO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5hdHRyTWFwLnR5cGUgPT09IFwidGV4dC94LWhhbmRsZWJhcnMtdGVtcGxhdGVcIikge1xuICAgICAgICByZXR1cm4gXCJnbGltbWVyXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUubmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICBpZiAoIW5vZGUuYXR0ck1hcC5sYW5nIHx8IG5vZGUuYXR0ck1hcC5sYW5nID09PSBcInBvc3Rjc3NcIiB8fCBub2RlLmF0dHJNYXAubGFuZyA9PT0gXCJjc3NcIikge1xuICAgICAgICByZXR1cm4gXCJjc3NcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuYXR0ck1hcC5sYW5nID09PSBcInNjc3NcIikge1xuICAgICAgICByZXR1cm4gXCJzY3NzXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmF0dHJNYXAubGFuZyA9PT0gXCJsZXNzXCIpIHtcbiAgICAgICAgcmV0dXJuIFwibGVzc1wiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNCbG9ja0xpa2VDc3NEaXNwbGF5KGNzc0Rpc3BsYXkpIHtcbiAgICByZXR1cm4gY3NzRGlzcGxheSA9PT0gXCJibG9ja1wiIHx8IGNzc0Rpc3BsYXkgPT09IFwibGlzdC1pdGVtXCIgfHwgY3NzRGlzcGxheS5zdGFydHNXaXRoKFwidGFibGVcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZpcnN0Q2hpbGRMZWFkaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KGNzc0Rpc3BsYXkpIHtcbiAgICByZXR1cm4gIWlzQmxvY2tMaWtlQ3NzRGlzcGxheShjc3NEaXNwbGF5KSAmJiBjc3NEaXNwbGF5ICE9PSBcImlubGluZS1ibG9ja1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMYXN0Q2hpbGRUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlQ3NzRGlzcGxheShjc3NEaXNwbGF5KSB7XG4gICAgcmV0dXJuICFpc0Jsb2NrTGlrZUNzc0Rpc3BsYXkoY3NzRGlzcGxheSkgJiYgY3NzRGlzcGxheSAhPT0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJldlRyYWlsaW5nU3BhY2VTZW5zaXRpdmVDc3NEaXNwbGF5KGNzc0Rpc3BsYXkpIHtcbiAgICByZXR1cm4gIWlzQmxvY2tMaWtlQ3NzRGlzcGxheShjc3NEaXNwbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTmV4dExlYWRpbmdTcGFjZVNlbnNpdGl2ZUNzc0Rpc3BsYXkoY3NzRGlzcGxheSkge1xuICAgIHJldHVybiAhaXNCbG9ja0xpa2VDc3NEaXNwbGF5KGNzc0Rpc3BsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlQ3NzRGlzcGxheShjc3NEaXNwbGF5KSB7XG4gICAgcmV0dXJuICFpc0Jsb2NrTGlrZUNzc0Rpc3BsYXkoY3NzRGlzcGxheSkgJiYgY3NzRGlzcGxheSAhPT0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJlTGlrZU5vZGUobm9kZSkge1xuICAgIHJldHVybiBnZXROb2RlQ3NzU3R5bGVXaGl0ZVNwYWNlKG5vZGUpLnN0YXJ0c1dpdGgoXCJwcmVcIik7XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudFBhcmVudHMocGF0aCwgcHJlZGljYXRlID0gKCkgPT4gdHJ1ZSkge1xuICAgIGxldCBjb3VudGVyID0gMDtcblxuICAgIGZvciAobGV0IGkgPSBwYXRoLnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhdGguc3RhY2tbaV07XG5cbiAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIGZuKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBub2RlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChmbihjdXJyZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVDc3NTdHlsZURpc3BsYXkobm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChub2RlLnByZXYgJiYgbm9kZS5wcmV2LnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAvLyA8IS0tIGRpc3BsYXk6IGJsb2NrIC0tPlxuICAgICAgY29uc3QgbWF0Y2ggPSBub2RlLnByZXYudmFsdWUubWF0Y2goL15cXHMqZGlzcGxheTpcXHMqKFthLXpdKylcXHMqJC8pO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBpc0luU3ZnRm9yZWlnbk9iamVjdCA9IGZhbHNlO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5uYW1lc3BhY2UgPT09IFwic3ZnXCIpIHtcbiAgICAgIGlmIChoYXNQYXJlbnQobm9kZSwgcGFyZW50ID0+IHBhcmVudC5mdWxsTmFtZSA9PT0gXCJzdmc6Zm9yZWlnbk9iamVjdFwiKSkge1xuICAgICAgICBpc0luU3ZnRm9yZWlnbk9iamVjdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZS5uYW1lID09PSBcInN2Z1wiID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwiYmxvY2tcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMuaHRtbFdoaXRlc3BhY2VTZW5zaXRpdml0eSkge1xuICAgICAgY2FzZSBcInN0cmljdFwiOlxuICAgICAgICByZXR1cm4gXCJpbmxpbmVcIjtcblxuICAgICAgY2FzZSBcImlnbm9yZVwiOlxuICAgICAgICByZXR1cm4gXCJibG9ja1wiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiAoIW5vZGUubmFtZXNwYWNlIHx8IGlzSW5TdmdGb3JlaWduT2JqZWN0IHx8IGlzVW5rbm93bk5hbWVzcGFjZShub2RlKSkgJiYgQ1NTX0RJU1BMQVlfVEFHU1tub2RlLm5hbWVdIHx8IENTU19ESVNQTEFZX0RFRkFVTFQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duTmFtZXNwYWNlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiAhbm9kZS5oYXNFeHBsaWNpdE5hbWVzcGFjZSAmJiAhW1wiaHRtbFwiLCBcInN2Z1wiXS5pbmNsdWRlcyhub2RlLm5hbWVzcGFjZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlQ3NzU3R5bGVXaGl0ZVNwYWNlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiAoIW5vZGUubmFtZXNwYWNlIHx8IGlzVW5rbm93bk5hbWVzcGFjZShub2RlKSkgJiYgQ1NTX1dISVRFX1NQQUNFX1RBR1Nbbm9kZS5uYW1lXSB8fCBDU1NfV0hJVEVfU1BBQ0VfREVGQVVMVDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pbkluZGVudGF0aW9uKHRleHQpIHtcbiAgICBsZXQgbWluSW5kZW50YXRpb24gPSBJbmZpbml0eTtcblxuICAgIGZvciAoY29uc3QgbGluZVRleHQgb2YgdGV4dC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgaWYgKGxpbmVUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKC9cXFMvLnRlc3QobGluZVRleHRbMF0pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRlbnRhdGlvbiA9IGxpbmVUZXh0Lm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgaWYgKGxpbmVUZXh0Lmxlbmd0aCA9PT0gaW5kZW50YXRpb24pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRlbnRhdGlvbiA8IG1pbkluZGVudGF0aW9uKSB7XG4gICAgICAgIG1pbkluZGVudGF0aW9uID0gaW5kZW50YXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbkluZGVudGF0aW9uID09PSBJbmZpbml0eSA/IDAgOiBtaW5JbmRlbnRhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZGVudFN0cmluZyh0ZXh0LCBtaW5JbmRlbnQgPSBnZXRNaW5JbmRlbnRhdGlvbih0ZXh0KSkge1xuICAgIHJldHVybiBtaW5JbmRlbnQgPT09IDAgPyB0ZXh0IDogdGV4dC5zcGxpdChcIlxcblwiKS5tYXAobGluZVRleHQgPT4gbGluZVRleHQuc2xpY2UobWluSW5kZW50KSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcnRzKHBhcnRzKSB7XG4gICAgY29uc3QgbmV3UGFydHMgPSBbXTtcbiAgICBjb25zdCByZXN0UGFydHMgPSBwYXJ0cy5zbGljZSgpO1xuXG4gICAgd2hpbGUgKHJlc3RQYXJ0cy5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IHBhcnQgPSByZXN0UGFydHMuc2hpZnQoKTtcblxuICAgICAgaWYgKCFwYXJ0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFydC50eXBlID09PSBcImNvbmNhdFwiKSB7XG4gICAgICAgIHJlc3RQYXJ0cy51bnNoaWZ0KC4uLnBhcnQucGFydHMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1BhcnRzLmxlbmd0aCAhPT0gMCAmJiB0eXBlb2YgbmV3UGFydHNbbmV3UGFydHMubGVuZ3RoIC0gMV0gPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHBhcnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmV3UGFydHMucHVzaChuZXdQYXJ0cy5wb3AoKSArIHBhcnQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmV3UGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UGFydHM7XG4gIH1cblxuICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGROb3RQcmludENsb3NpbmdUYWcobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAhbm9kZS5pc1NlbGZDbG9zaW5nICYmICFub2RlLmVuZFNvdXJjZVNwYW4gJiYgKGhhc1ByZXR0aWVySWdub3JlJDIobm9kZSkgfHwgc2hvdWxkUHJlc2VydmVDb250ZW50KG5vZGUucGFyZW50LCBvcHRpb25zKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb3VudENoYXJzKHRleHQsIGNoYXIpIHtcbiAgICBsZXQgY291bnRlciA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0ZXh0W2ldID09PSBjaGFyKSB7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuZXNjYXBlUXVvdGVFbnRpdGllcyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvJmFwb3M7L2csIFwiJ1wiKS5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJyk7XG4gIH1cblxuICB2YXIgdXRpbHMkNCA9IHtcbiAgICBIVE1MX0VMRU1FTlRfQVRUUklCVVRFUyxcbiAgICBIVE1MX1RBR1MsXG4gICAgY2FuSGF2ZUludGVycG9sYXRpb24sXG4gICAgY291bnRDaGFycyxcbiAgICBjb3VudFBhcmVudHMsXG4gICAgZGVkZW50U3RyaW5nLFxuICAgIGZvcmNlQnJlYWtDaGlsZHJlbixcbiAgICBmb3JjZUJyZWFrQ29udGVudCxcbiAgICBmb3JjZU5leHRFbXB0eUxpbmUsXG4gICAgZ2V0TGFzdERlc2NlbmRhbnQsXG4gICAgZ2V0Tm9kZUNzc1N0eWxlRGlzcGxheSxcbiAgICBnZXROb2RlQ3NzU3R5bGVXaGl0ZVNwYWNlLFxuICAgIGdldFByZXR0aWVySWdub3JlQXR0cmlidXRlQ29tbWVudERhdGEsXG4gICAgaGFzUHJldHRpZXJJZ25vcmU6IGhhc1ByZXR0aWVySWdub3JlJDIsXG4gICAgaWRlbnRpdHksXG4gICAgaW5mZXJTY3JpcHRQYXJzZXIsXG4gICAgaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZSxcbiAgICBpc0Zyb250TWF0dGVyTm9kZSxcbiAgICBpc0luZGVudGF0aW9uU2Vuc2l0aXZlTm9kZSxcbiAgICBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZU5vZGUsXG4gICAgaXNQcmVMaWtlTm9kZSxcbiAgICBpc1NjcmlwdExpa2VUYWcsXG4gICAgaXNUZXh0TGlrZU5vZGUsXG4gICAgaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZSxcbiAgICBpc1doaXRlc3BhY2VTZW5zaXRpdmVOb2RlLFxuICAgIGlzVW5rbm93bk5hbWVzcGFjZSxcbiAgICBub3JtYWxpemVQYXJ0cyxcbiAgICBwcmVmZXJIYXJkbGluZUFzTGVhZGluZ1NwYWNlcyxcbiAgICBwcmVmZXJIYXJkbGluZUFzVHJhaWxpbmdTcGFjZXMsXG4gICAgc2hvdWxkTm90UHJpbnRDbG9zaW5nVGFnLFxuICAgIHNob3VsZFByZXNlcnZlQ29udGVudCxcbiAgICB1bmVzY2FwZVF1b3RlRW50aXRpZXNcbiAgfTtcblxuICBjb25zdCB7XG4gICAgY2FuSGF2ZUludGVycG9sYXRpb246IGNhbkhhdmVJbnRlcnBvbGF0aW9uJDEsXG4gICAgZ2V0Tm9kZUNzc1N0eWxlRGlzcGxheTogZ2V0Tm9kZUNzc1N0eWxlRGlzcGxheSQxLFxuICAgIGlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZU5vZGU6IGlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZU5vZGUkMSxcbiAgICBpc0luZGVudGF0aW9uU2Vuc2l0aXZlTm9kZTogaXNJbmRlbnRhdGlvblNlbnNpdGl2ZU5vZGUkMSxcbiAgICBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZU5vZGU6IGlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlTm9kZSQxLFxuICAgIGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZU5vZGU6IGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZU5vZGUkMSxcbiAgICBpc1doaXRlc3BhY2VTZW5zaXRpdmVOb2RlOiBpc1doaXRlc3BhY2VTZW5zaXRpdmVOb2RlJDFcbiAgfSA9IHV0aWxzJDQ7XG4gIGNvbnN0IFBSRVBST0NFU1NfUElQRUxJTkUgPSBbcmVtb3ZlSWdub3JhYmxlRmlyc3RMZiwgbWVyZ2VJZUNvbmRpdG9uYWxTdGFydEVuZENvbW1lbnRJbnRvRWxlbWVudE9wZW5pbmdUYWcsIG1lcmdlQ2RhdGFJbnRvVGV4dCwgZXh0cmFjdEludGVycG9sYXRpb24sIGV4dHJhY3RXaGl0ZXNwYWNlcywgYWRkQ3NzRGlzcGxheSwgYWRkSXNTZWxmQ2xvc2luZywgYWRkSGFzSHRtQ29tcG9uZW50Q2xvc2luZ1RhZywgYWRkSXNTcGFjZVNlbnNpdGl2ZSwgbWVyZ2VTaW1wbGVFbGVtZW50SW50b1RleHRdO1xuXG4gIGZ1bmN0aW9uIHByZXByb2Nlc3MoYXN0LCBvcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBmbiBvZiBQUkVQUk9DRVNTX1BJUEVMSU5FKSB7XG4gICAgICBhc3QgPSBmbihhc3QsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhc3Q7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVJZ25vcmFibGVGaXJzdExmKGFzdFxuICAvKiwgb3B0aW9ucyAqL1xuICApIHtcbiAgICByZXR1cm4gYXN0Lm1hcChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIG5vZGUudGFnRGVmaW5pdGlvbi5pZ25vcmVGaXJzdExmICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgbm9kZS5jaGlsZHJlblswXS52YWx1ZVswXSA9PT0gXCJcXG5cIikge1xuICAgICAgICBjb25zdCBbdGV4dCwgLi4ucmVzdF0gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gbm9kZS5jbG9uZSh7XG4gICAgICAgICAgY2hpbGRyZW46IHRleHQudmFsdWUubGVuZ3RoID09PSAxID8gcmVzdCA6IFt0ZXh0LmNsb25lKHtcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LnZhbHVlLnNsaWNlKDEpXG4gICAgICAgICAgfSksIC4uLnJlc3RdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSWVDb25kaXRvbmFsU3RhcnRFbmRDb21tZW50SW50b0VsZW1lbnRPcGVuaW5nVGFnKGFzdFxuICAvKiwgb3B0aW9ucyAqL1xuICApIHtcbiAgICAvKipcbiAgICAgKiAgICAgPCEtLVtpZiAuLi5dPjwhLS0+PHRhcmdldD48IS0tPCFbZW5kaWZdLS0+XG4gICAgICovXG4gICAgY29uc3QgaXNUYXJnZXQgPSBub2RlID0+IG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgbm9kZS5wcmV2ICYmIG5vZGUucHJldi50eXBlID09PSBcImllQ29uZGl0aW9uYWxTdGFydENvbW1lbnRcIiAmJiBub2RlLnByZXYuc291cmNlU3Bhbi5lbmQub2Zmc2V0ID09PSBub2RlLnN0YXJ0U291cmNlU3Bhbi5zdGFydC5vZmZzZXQgJiYgbm9kZS5maXJzdENoaWxkICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09PSBcImllQ29uZGl0aW9uYWxFbmRDb21tZW50XCIgJiYgbm9kZS5maXJzdENoaWxkLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0ID09PSBub2RlLnN0YXJ0U291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuXG4gICAgcmV0dXJuIGFzdC5tYXAobm9kZSA9PiB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCBpc1RhcmdldFJlc3VsdHMgPSBub2RlLmNoaWxkcmVuLm1hcChpc1RhcmdldCk7XG5cbiAgICAgICAgaWYgKGlzVGFyZ2V0UmVzdWx0cy5zb21lKEJvb2xlYW4pKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXNUYXJnZXRSZXN1bHRzW2kgKyAxXSkge1xuICAgICAgICAgICAgICAvLyBpZUNvbmRpdGlvbmFsU3RhcnRDb21tZW50XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNUYXJnZXRSZXN1bHRzW2ldKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGllQ29uZGl0aW9uYWxTdGFydENvbW1lbnQgPSBjaGlsZC5wcmV2O1xuICAgICAgICAgICAgICBjb25zdCBpZUNvbmRpdGlvbmFsRW5kQ29tbWVudCA9IGNoaWxkLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnN0IFBhcnNlU291cmNlU3BhbiA9IGNoaWxkLnNvdXJjZVNwYW4uY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oaWVDb25kaXRpb25hbFN0YXJ0Q29tbWVudC5zb3VyY2VTcGFuLnN0YXJ0LCBpZUNvbmRpdGlvbmFsRW5kQ29tbWVudC5zb3VyY2VTcGFuLmVuZCk7XG4gICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0U291cmNlU3Bhbi5zdGFydCwgY2hpbGQuc291cmNlU3Bhbi5lbmQpO1xuICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGNoaWxkLmNsb25lKHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IGllQ29uZGl0aW9uYWxTdGFydENvbW1lbnQuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgc3RhcnRTb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZC5jaGlsZHJlbi5zbGljZSgxKVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbm9kZS5jbG9uZSh7XG4gICAgICAgICAgICBjaGlsZHJlbjogbmV3Q2hpbGRyZW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlTm9kZUludG9UZXh0KGFzdCwgc2hvdWxkTWVyZ2UsIGdldFZhbHVlKSB7XG4gICAgcmV0dXJuIGFzdC5tYXAobm9kZSA9PiB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCBzaG91bGRNZXJnZVJlc3VsdHMgPSBub2RlLmNoaWxkcmVuLm1hcChzaG91bGRNZXJnZSk7XG5cbiAgICAgICAgaWYgKHNob3VsZE1lcmdlUmVzdWx0cy5zb21lKEJvb2xlYW4pKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBbXTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPT0gXCJ0ZXh0XCIgJiYgIXNob3VsZE1lcmdlUmVzdWx0c1tpXSkge1xuICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQudHlwZSA9PT0gXCJ0ZXh0XCIgPyBjaGlsZCA6IGNoaWxkLmNsb25lKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZShjaGlsZClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IG5ld0NoaWxkcmVuW25ld0NoaWxkcmVuLmxlbmd0aCAtIDFdLnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdENoaWxkID0gbmV3Q2hpbGRyZW4ucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBQYXJzZVNvdXJjZVNwYW4gPSBsYXN0Q2hpbGQuc291cmNlU3Bhbi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gobGFzdENoaWxkLmNsb25lKHtcbiAgICAgICAgICAgICAgdmFsdWU6IGxhc3RDaGlsZC52YWx1ZSArIG5ld0NoaWxkLnZhbHVlLFxuICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBuZXcgUGFyc2VTb3VyY2VTcGFuKGxhc3RDaGlsZC5zb3VyY2VTcGFuLnN0YXJ0LCBuZXdDaGlsZC5zb3VyY2VTcGFuLmVuZClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbm9kZS5jbG9uZSh7XG4gICAgICAgICAgICBjaGlsZHJlbjogbmV3Q2hpbGRyZW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQ2RhdGFJbnRvVGV4dChhc3RcbiAgLyosIG9wdGlvbnMgKi9cbiAgKSB7XG4gICAgcmV0dXJuIG1lcmdlTm9kZUludG9UZXh0KGFzdCwgbm9kZSA9PiBub2RlLnR5cGUgPT09IFwiY2RhdGFcIiwgbm9kZSA9PiBcIjwhW0NEQVRBW1wiLmNvbmNhdChub2RlLnZhbHVlLCBcIl1dPlwiKSk7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVNpbXBsZUVsZW1lbnRJbnRvVGV4dChhc3RcbiAgLyosIG9wdGlvbnMgKi9cbiAgKSB7XG4gICAgY29uc3QgaXNTaW1wbGVFbGVtZW50ID0gbm9kZSA9PiBub2RlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIG5vZGUuYXR0cnMubGVuZ3RoID09PSAwICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09PSBcInRleHRcIiAmJiAvLyBcXHhBMDogbm9uLWJyZWFraW5nIHdoaXRlc3BhY2VcbiAgICAhL1teXFxTXFx4QTBdLy50ZXN0KG5vZGUuY2hpbGRyZW5bMF0udmFsdWUpICYmICFub2RlLmZpcnN0Q2hpbGQuaGFzTGVhZGluZ1NwYWNlcyAmJiAhbm9kZS5maXJzdENoaWxkLmhhc1RyYWlsaW5nU3BhY2VzICYmIG5vZGUuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmUgJiYgIW5vZGUuaGFzTGVhZGluZ1NwYWNlcyAmJiBub2RlLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSAmJiAhbm9kZS5oYXNUcmFpbGluZ1NwYWNlcyAmJiBub2RlLnByZXYgJiYgbm9kZS5wcmV2LnR5cGUgPT09IFwidGV4dFwiICYmIG5vZGUubmV4dCAmJiBub2RlLm5leHQudHlwZSA9PT0gXCJ0ZXh0XCI7XG5cbiAgICByZXR1cm4gYXN0Lm1hcChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IGlzU2ltcGxlRWxlbWVudFJlc3VsdHMgPSBub2RlLmNoaWxkcmVuLm1hcChpc1NpbXBsZUVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChpc1NpbXBsZUVsZW1lbnRSZXN1bHRzLnNvbWUoQm9vbGVhbikpIHtcbiAgICAgICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IFtdO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgIGlmIChpc1NpbXBsZUVsZW1lbnRSZXN1bHRzW2ldKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IG5ld0NoaWxkcmVuLnBvcCgpO1xuICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBub2RlLmNoaWxkcmVuWysraV07XG4gICAgICAgICAgICAgIGNvbnN0IFBhcnNlU291cmNlU3BhbiA9IG5vZGUuc291cmNlU3Bhbi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSxcbiAgICAgICAgICAgICAgICBoYXNUcmFpbGluZ1NwYWNlc1xuICAgICAgICAgICAgICB9ID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGxhc3RDaGlsZC5jbG9uZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGxhc3RDaGlsZC52YWx1ZSArIFwiPFwiLmNvbmNhdChjaGlsZC5yYXdOYW1lLCBcIj5cIikgKyBjaGlsZC5maXJzdENoaWxkLnZhbHVlICsgXCI8L1wiLmNvbmNhdChjaGlsZC5yYXdOYW1lLCBcIj5cIikgKyBuZXh0Q2hpbGQudmFsdWUsXG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogbmV3IFBhcnNlU291cmNlU3BhbihsYXN0Q2hpbGQuc291cmNlU3Bhbi5zdGFydCwgbmV4dENoaWxkLnNvdXJjZVNwYW4uZW5kKSxcbiAgICAgICAgICAgICAgICBpc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUsXG4gICAgICAgICAgICAgICAgaGFzVHJhaWxpbmdTcGFjZXNcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmUoe1xuICAgICAgICAgICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0SW50ZXJwb2xhdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXJzZXIgPT09IFwiaHRtbFwiKSB7XG4gICAgICByZXR1cm4gYXN0O1xuICAgIH1cblxuICAgIGNvbnN0IGludGVycG9sYXRpb25SZWdleCA9IC9cXHtcXHsoW1xcc1xcU10rPylcXH1cXH0vZztcbiAgICByZXR1cm4gYXN0Lm1hcChub2RlID0+IHtcbiAgICAgIGlmICghY2FuSGF2ZUludGVycG9sYXRpb24kMShub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgUGFyc2VTb3VyY2VTcGFuID0gY2hpbGQuc291cmNlU3Bhbi5jb25zdHJ1Y3RvcjtcbiAgICAgICAgbGV0IHN0YXJ0U291cmNlU3BhbiA9IGNoaWxkLnNvdXJjZVNwYW4uc3RhcnQ7XG4gICAgICAgIGxldCBlbmRTb3VyY2VTcGFuID0gbnVsbDtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IGNoaWxkLnZhbHVlLnNwbGl0KGludGVycG9sYXRpb25SZWdleCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrLCBzdGFydFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBjb21wb25lbnRzW2ldO1xuXG4gICAgICAgICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBlbmRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuLm1vdmVCeSh2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW5kU291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3Bhbi5tb3ZlQnkodmFsdWUubGVuZ3RoICsgNCk7IC8vIGB7e2AgKyBgfX1gXG5cbiAgICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW50ZXJwb2xhdGlvblwiLFxuICAgICAgICAgICAgc291cmNlU3BhbjogbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4pLFxuICAgICAgICAgICAgY2hpbGRyZW46IHZhbHVlLmxlbmd0aCA9PT0gMCA/IFtdIDogW3tcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0U291cmNlU3Bhbi5tb3ZlQnkoMiksIGVuZFNvdXJjZVNwYW4ubW92ZUJ5KC0yKSlcbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuY2xvbmUoe1xuICAgICAgICBjaGlsZHJlbjogbmV3Q2hpbGRyZW5cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiAtIGFkZCBgaGFzTGVhZGluZ1NwYWNlc2AgZmllbGRcbiAgICogLSBhZGQgYGhhc1RyYWlsaW5nU3BhY2VzYCBmaWVsZFxuICAgKiAtIGFkZCBgaGFzRGFuZ2xpbmdTcGFjZXNgIGZpZWxkIGZvciBwYXJlbnQgbm9kZXNcbiAgICogLSBhZGQgYGlzV2hpdGVzcGFjZVNlbnNpdGl2ZWAsIGBpc0luZGVudGF0aW9uU2Vuc2l0aXZlYCBmaWVsZCBmb3IgdGV4dCBub2Rlc1xuICAgKiAtIHJlbW92ZSBpbnNlbnNpdGl2ZSB3aGl0ZXNwYWNlc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RXaGl0ZXNwYWNlcyhhc3RcbiAgLyosIG9wdGlvbnMqL1xuICApIHtcbiAgICBjb25zdCBUWVBFX1dISVRFU1BBQ0UgPSBcIndoaXRlc3BhY2VcIjtcbiAgICByZXR1cm4gYXN0Lm1hcChub2RlID0+IHtcbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgbm9kZS5jaGlsZHJlblswXS52YWx1ZS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub2RlLmNsb25lKHtcbiAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgaGFzRGFuZ2xpbmdTcGFjZXM6IG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpc1doaXRlc3BhY2VTZW5zaXRpdmUgPSBpc1doaXRlc3BhY2VTZW5zaXRpdmVOb2RlJDEobm9kZSk7XG4gICAgICBjb25zdCBpc0luZGVudGF0aW9uU2Vuc2l0aXZlID0gaXNJbmRlbnRhdGlvblNlbnNpdGl2ZU5vZGUkMShub2RlKTtcbiAgICAgIHJldHVybiBub2RlLmNsb25lKHtcbiAgICAgICAgaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlLFxuICAgICAgICBpc0luZGVudGF0aW9uU2Vuc2l0aXZlLFxuICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbiAvLyBleHRyYWN0IHdoaXRlc3BhY2Ugbm9kZXNcbiAgICAgICAgLnJlZHVjZSgobmV3Q2hpbGRyZW4sIGNoaWxkKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IFwidGV4dFwiIHx8IGlzV2hpdGVzcGFjZVNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuLmNvbmNhdChjaGlsZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbG9jYWxDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgIGNvbnN0IFssIGxlYWRpbmdTcGFjZXMsIHRleHQsIHRyYWlsaW5nU3BhY2VzXSA9IGNoaWxkLnZhbHVlLm1hdGNoKC9eKFxccyopKFtcXHNcXFNdKj8pKFxccyopJC8pO1xuXG4gICAgICAgICAgaWYgKGxlYWRpbmdTcGFjZXMpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFRZUEVfV0hJVEVTUEFDRVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgUGFyc2VTb3VyY2VTcGFuID0gY2hpbGQuc291cmNlU3Bhbi5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBsb2NhbENoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICAgIHNvdXJjZVNwYW46IG5ldyBQYXJzZVNvdXJjZVNwYW4oY2hpbGQuc291cmNlU3Bhbi5zdGFydC5tb3ZlQnkobGVhZGluZ1NwYWNlcy5sZW5ndGgpLCBjaGlsZC5zb3VyY2VTcGFuLmVuZC5tb3ZlQnkoLXRyYWlsaW5nU3BhY2VzLmxlbmd0aCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhaWxpbmdTcGFjZXMpIHtcbiAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFRZUEVfV0hJVEVTUEFDRVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuLmNvbmNhdChsb2NhbENoaWxkcmVuKTtcbiAgICAgICAgfSwgW10pIC8vIHNldCBoYXNMZWFkaW5nU3BhY2VzL2hhc1RyYWlsaW5nU3BhY2VzIGFuZCBmaWx0ZXIgd2hpdGVzcGFjZSBub2Rlc1xuICAgICAgICAucmVkdWNlKChuZXdDaGlsZHJlbiwgY2hpbGQsIGksIGNoaWxkcmVuKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFRZUEVfV0hJVEVTUEFDRSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGhhc0xlYWRpbmdTcGFjZXMgPSBpICE9PSAwICYmIGNoaWxkcmVuW2kgLSAxXS50eXBlID09PSBUWVBFX1dISVRFU1BBQ0U7XG4gICAgICAgICAgY29uc3QgaGFzVHJhaWxpbmdTcGFjZXMgPSBpICE9PSBjaGlsZHJlbi5sZW5ndGggLSAxICYmIGNoaWxkcmVuW2kgKyAxXS50eXBlID09PSBUWVBFX1dISVRFU1BBQ0U7XG4gICAgICAgICAgcmV0dXJuIG5ld0NoaWxkcmVuLmNvbmNhdChPYmplY3QuYXNzaWduKHt9LCBjaGlsZCwge1xuICAgICAgICAgICAgaGFzTGVhZGluZ1NwYWNlcyxcbiAgICAgICAgICAgIGhhc1RyYWlsaW5nU3BhY2VzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9LCBbXSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkSXNTZWxmQ2xvc2luZyhhc3RcbiAgLyosIG9wdGlvbnMgKi9cbiAgKSB7XG4gICAgcmV0dXJuIGFzdC5tYXAobm9kZSA9PiBPYmplY3QuYXNzaWduKG5vZGUsIHtcbiAgICAgIGlzU2VsZkNsb3Npbmc6ICFub2RlLmNoaWxkcmVuIHx8IG5vZGUudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgKG5vZGUudGFnRGVmaW5pdGlvbi5pc1ZvaWQgfHwgLy8gc2VsZi1jbG9zaW5nXG4gICAgICBub2RlLnN0YXJ0U291cmNlU3BhbiA9PT0gbm9kZS5lbmRTb3VyY2VTcGFuKVxuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEhhc0h0bUNvbXBvbmVudENsb3NpbmdUYWcoYXN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFzdC5tYXAobm9kZSA9PiBub2RlLnR5cGUgIT09IFwiZWxlbWVudFwiID8gbm9kZSA6IE9iamVjdC5hc3NpZ24obm9kZSwge1xuICAgICAgaGFzSHRtQ29tcG9uZW50Q2xvc2luZ1RhZzogbm9kZS5lbmRTb3VyY2VTcGFuICYmIC9ePFxccypcXC9cXHMqXFwvXFxzKj4kLy50ZXN0KG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG5vZGUuZW5kU291cmNlU3Bhbi5zdGFydC5vZmZzZXQsIG5vZGUuZW5kU291cmNlU3Bhbi5lbmQub2Zmc2V0KSlcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDc3NEaXNwbGF5KGFzdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBhc3QubWFwKG5vZGUgPT4gT2JqZWN0LmFzc2lnbihub2RlLCB7XG4gICAgICBjc3NEaXNwbGF5OiBnZXROb2RlQ3NzU3R5bGVEaXNwbGF5JDEobm9kZSwgb3B0aW9ucylcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIC0gYWRkIGBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZWAgZmllbGRcbiAgICogLSBhZGQgYGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZWAgZmllbGRcbiAgICogLSBhZGQgYGlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZWAgZmllbGQgZm9yIHBhcmVudCBub2Rlc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFkZElzU3BhY2VTZW5zaXRpdmUoYXN0XG4gIC8qLCBvcHRpb25zICovXG4gICkge1xuICAgIHJldHVybiBhc3QubWFwKG5vZGUgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmUoe1xuICAgICAgICAgIGlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZTogaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZSQxKG5vZGUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5jbG9uZSh7XG4gICAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLm1hcChjaGlsZCA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNoaWxkLCB7XG4gICAgICAgICAgICBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZTogaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmVOb2RlJDEoY2hpbGQpLFxuICAgICAgICAgICAgaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlOiBpc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmVOb2RlJDEoY2hpbGQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLm1hcCgoY2hpbGQsIGluZGV4LCBjaGlsZHJlbikgPT4gT2JqZWN0LmFzc2lnbih7fSwgY2hpbGQsIHtcbiAgICAgICAgICBpc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZTogaW5kZXggPT09IDAgPyBjaGlsZC5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSA6IGNoaWxkcmVuW2luZGV4IC0gMV0uaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlICYmIGNoaWxkLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlLFxuICAgICAgICAgIGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZTogaW5kZXggPT09IGNoaWxkcmVuLmxlbmd0aCAtIDEgPyBjaGlsZC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUgOiBjaGlsZHJlbltpbmRleCArIDFdLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlICYmIGNoaWxkLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZVxuICAgICAgICB9KSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHByZXByb2Nlc3NfMSA9IHByZXByb2Nlc3M7XG5cbiAgZnVuY3Rpb24gaGFzUHJhZ21hJDModGV4dCkge1xuICAgIHJldHVybiAvXlxccyo8IS0tXFxzKkAoZm9ybWF0fHByZXR0aWVyKVxccyotLT4vLnRlc3QodGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRQcmFnbWEkNSh0ZXh0KSB7XG4gICAgcmV0dXJuIFwiPCEtLSBAZm9ybWF0IC0tPlxcblxcblwiICsgdGV4dC5yZXBsYWNlKC9eXFxzKlxcbi8sIFwiXCIpO1xuICB9XG5cbiAgdmFyIHByYWdtYSQzID0ge1xuICAgIGhhc1ByYWdtYTogaGFzUHJhZ21hJDMsXG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkNVxuICB9O1xuXG4gIGNvbnN0IHtcbiAgICBidWlsZGVyczoge1xuICAgICAgY29uY2F0OiBjb25jYXQkOCxcbiAgICAgIGdyb3VwOiBncm91cCQ4XG4gICAgfVxuICB9ID0gZG9jdW1lbnQ7XG4gIC8qKlxuICAgKiAgICAgdi1mb3I9XCIuLi4gaW4gLi4uXCJcbiAgICogICAgIHYtZm9yPVwiLi4uIG9mIC4uLlwiXG4gICAqICAgICB2LWZvcj1cIiguLi4sIC4uLikgaW4gLi4uXCJcbiAgICogICAgIHYtZm9yPVwiKC4uLiwgLi4uKSBvZiAuLi5cIlxuICAgKi9cblxuICBmdW5jdGlvbiBwcmludFZ1ZUZvcih2YWx1ZSwgdGV4dFRvRG9jKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIG9wZXJhdG9yLFxuICAgICAgcmlnaHRcbiAgICB9ID0gcGFyc2VWdWVGb3IodmFsdWUpO1xuICAgIHJldHVybiBjb25jYXQkOChbZ3JvdXAkOCh0ZXh0VG9Eb2MoXCJmdW5jdGlvbiBfKFwiLmNvbmNhdChsZWZ0LCBcIikge31cIiksIHtcbiAgICAgIHBhcnNlcjogXCJiYWJlbFwiLFxuICAgICAgX19pc1Z1ZUZvckJpbmRpbmdMZWZ0OiB0cnVlXG4gICAgfSkpLCBcIiBcIiwgb3BlcmF0b3IsIFwiIFwiLCB0ZXh0VG9Eb2MocmlnaHQsIHtcbiAgICAgIHBhcnNlcjogXCJfX2pzX2V4cHJlc3Npb25cIlxuICAgIH0pXSk7XG4gIH0gLy8gbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL2Jsb2IvdjIuNS4xNy9zcmMvY29tcGlsZXIvcGFyc2VyL2luZGV4LmpzI0wzNzAtTDM4N1xuXG5cbiAgZnVuY3Rpb24gcGFyc2VWdWVGb3IodmFsdWUpIHtcbiAgICBjb25zdCBmb3JBbGlhc1JFID0gLyhbXl0qPylcXHMrKGlufG9mKVxccysoW15dKikvO1xuICAgIGNvbnN0IGZvckl0ZXJhdG9yUkUgPSAvLChbXix9XFxdXSopKD86LChbXix9XFxdXSopKT8kLztcbiAgICBjb25zdCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuICAgIGNvbnN0IGluTWF0Y2ggPSB2YWx1ZS5tYXRjaChmb3JBbGlhc1JFKTtcblxuICAgIGlmICghaW5NYXRjaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIHJlcy5mb3IgPSBpbk1hdGNoWzNdLnRyaW0oKTtcbiAgICBjb25zdCBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgXCJcIik7XG4gICAgY29uc3QgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgXCJcIik7XG4gICAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG5cbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IFwiXCIuY29uY2F0KFtyZXMuYWxpYXMsIHJlcy5pdGVyYXRvcjEsIHJlcy5pdGVyYXRvcjJdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLFwiKSksXG4gICAgICBvcGVyYXRvcjogaW5NYXRjaFsyXSxcbiAgICAgIHJpZ2h0OiByZXMuZm9yXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50VnVlU2xvdFNjb3BlKHZhbHVlLCB0ZXh0VG9Eb2MpIHtcbiAgICByZXR1cm4gdGV4dFRvRG9jKFwiZnVuY3Rpb24gXyhcIi5jb25jYXQodmFsdWUsIFwiKSB7fVwiKSwge1xuICAgICAgcGFyc2VyOiBcImJhYmVsXCIsXG4gICAgICBfX2lzVnVlU2xvdFNjb3BlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb24oZXZlbnRCaW5kaW5nVmFsdWUpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL2Jsb2IvdjIuNS4xNy9zcmMvY29tcGlsZXIvY29kZWdlbi9ldmVudHMuanMjTDMtTDRcbiAgICAvLyBhcnJvdyBmdW5jdGlvbiBvciBhbm9ueW1vdXMgZnVuY3Rpb25cbiAgICBjb25zdCBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqXFwoLzsgLy8gc2ltcGxlIG1lbWJlciBleHByZXNzaW9uIGNoYWluIChhLCBhLmIsIGFbJ2InXSwgYVtcImJcIl0sIGFbMF0sIGFbYl0pXG5cbiAgICBjb25zdCBzaW1wbGVQYXRoUkUgPSAvXltBLVphLXpfJF1bXFx3JF0qKD86XFwuW0EtWmEtel8kXVtcXHckXSp8XFxbJ1teJ10qPyddfFxcW1wiW15cIl0qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKiQvOyAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL2Jsb2IvdjIuNS4xNy9zcmMvY29tcGlsZXIvaGVscGVycy5qcyNMMTA0XG5cbiAgICBjb25zdCB2YWx1ZSA9IGV2ZW50QmluZGluZ1ZhbHVlLnRyaW0oKTtcbiAgICByZXR1cm4gZm5FeHBSRS50ZXN0KHZhbHVlKSB8fCBzaW1wbGVQYXRoUkUudGVzdCh2YWx1ZSk7XG4gIH1cblxuICB2YXIgc3ludGF4VnVlID0ge1xuICAgIGlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbixcbiAgICBwcmludFZ1ZUZvcixcbiAgICBwcmludFZ1ZVNsb3RTY29wZVxuICB9O1xuXG4gIGNvbnN0IGludGVnZXJSZWdleCA9IC9eXFxkKyQvO1xuXG4gIGZ1bmN0aW9uIGRlZXBVbmlxdWUoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmZpbHRlcigoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShlbGVtZW50KSAhPT0gSlNPTi5zdHJpbmdpZnkoYXJyYXlbaW5kZXggLSAxXSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGFyc2UkMiA9IHN0cmluZyA9PiB7XG4gICAgcmV0dXJuIGRlZXBVbmlxdWUoc3RyaW5nLnNwbGl0KCcsJykubWFwKHBhcnQgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBwYXJ0LnRyaW0oKS5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJlc3VsdC51cmwgPSBlbGVtZW50O1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWxlbWVudC5zbGljZSgwLCBlbGVtZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCBwb3N0Zml4ID0gZWxlbWVudFtlbGVtZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBpbnRlZ2VyVmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgICAgICBjb25zdCBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHBvc3RmaXggPT09ICd3JyAmJiBpbnRlZ2VyUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQud2lkdGggPSBpbnRlZ2VyVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zdGZpeCA9PT0gJ2gnICYmIGludGVnZXJSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5oZWlnaHQgPSBpbnRlZ2VyVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zdGZpeCA9PT0gJ3gnICYmICFOdW1iZXIuaXNOYU4oZmxvYXRWYWx1ZSkpIHtcbiAgICAgICAgICByZXN1bHQuZGVuc2l0eSA9IGZsb2F0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzcmNzZXQgZGVzY3JpcHRvcjogXCIuY29uY2F0KGVsZW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKTtcbiAgfTtcblxuICB2YXIgc3RyaW5naWZ5ID0gYXJyYXkgPT4ge1xuICAgIHJldHVybiBbLi4ubmV3IFNldChhcnJheS5tYXAoZWxlbWVudCA9PiB7XG4gICAgICBpZiAoIWVsZW1lbnQudXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVVJMIGlzIHJlcXVpcmVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtlbGVtZW50LnVybF07XG5cbiAgICAgIGlmIChlbGVtZW50LndpZHRoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFwiXCIuY29uY2F0KGVsZW1lbnQud2lkdGgsIFwid1wiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmhlaWdodCkge1xuICAgICAgICByZXN1bHQucHVzaChcIlwiLmNvbmNhdChlbGVtZW50LmhlaWdodCwgXCJoXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuZGVuc2l0eSkge1xuICAgICAgICByZXN1bHQucHVzaChcIlwiLmNvbmNhdChlbGVtZW50LmRlbnNpdHksIFwieFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQuam9pbignICcpO1xuICAgIH0pKV0uam9pbignLCAnKTtcbiAgfTtcblxuICB2YXIgc3Jjc2V0ID0ge1xuICAgIHBhcnNlOiBwYXJzZSQyLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGJ1aWxkZXJzOiB7XG4gICAgICBjb25jYXQ6IGNvbmNhdCQ5LFxuICAgICAgaWZCcmVhazogaWZCcmVhayQ0LFxuICAgICAgam9pbjogam9pbiQ1LFxuICAgICAgbGluZTogbGluZSQ1XG4gICAgfVxuICB9ID0gZG9jdW1lbnQ7XG4gIGNvbnN0IHBhcnNlU3Jjc2V0ID0gc3Jjc2V0LnBhcnNlO1xuXG4gIGZ1bmN0aW9uIHByaW50SW1nU3Jjc2V0KHZhbHVlKSB7XG4gICAgY29uc3Qgc3Jjc2V0ID0gcGFyc2VTcmNzZXQodmFsdWUpO1xuICAgIGNvbnN0IGhhc1cgPSBzcmNzZXQuc29tZShzcmMgPT4gc3JjLndpZHRoKTtcbiAgICBjb25zdCBoYXNIID0gc3Jjc2V0LnNvbWUoc3JjID0+IHNyYy5oZWlnaHQpO1xuICAgIGNvbnN0IGhhc1ggPSBzcmNzZXQuc29tZShzcmMgPT4gc3JjLmRlbnNpdHkpO1xuXG4gICAgaWYgKGhhc1cgKyBoYXNIICsgaGFzWCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1peGVkIGRlc2NyaXB0b3IgaW4gc3Jjc2V0IGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gaGFzVyA/IFwid2lkdGhcIiA6IGhhc0ggPyBcImhlaWdodFwiIDogXCJkZW5zaXR5XCI7XG4gICAgY29uc3QgdW5pdCA9IGhhc1cgPyBcIndcIiA6IGhhc0ggPyBcImhcIiA6IFwieFwiO1xuXG4gICAgY29uc3QgZ2V0TWF4ID0gdmFsdWVzID0+IE1hdGgubWF4KC4uLnZhbHVlcyk7XG5cbiAgICBjb25zdCB1cmxzID0gc3Jjc2V0Lm1hcChzcmMgPT4gc3JjLnVybCk7XG4gICAgY29uc3QgbWF4VXJsTGVuZ3RoID0gZ2V0TWF4KHVybHMubWFwKHVybCA9PiB1cmwubGVuZ3RoKSk7XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBzcmNzZXQubWFwKHNyYyA9PiBzcmNba2V5XSkubWFwKGRlc2NyaXB0b3IgPT4gZGVzY3JpcHRvciA/IGRlc2NyaXB0b3IudG9TdHJpbmcoKSA6IFwiXCIpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JMZWZ0TGVuZ3RocyA9IGRlc2NyaXB0b3JzLm1hcChkZXNjcmlwdG9yID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZGVzY3JpcHRvci5pbmRleE9mKFwiLlwiKTtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBkZXNjcmlwdG9yLmxlbmd0aCA6IGluZGV4O1xuICAgIH0pO1xuICAgIGNvbnN0IG1heERlc2NyaXB0b3JMZWZ0TGVuZ3RoID0gZ2V0TWF4KGRlc2NyaXB0b3JMZWZ0TGVuZ3Rocyk7XG4gICAgcmV0dXJuIGpvaW4kNShjb25jYXQkOShbXCIsXCIsIGxpbmUkNV0pLCB1cmxzLm1hcCgodXJsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGFydHMgPSBbdXJsXTtcbiAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yc1tpbmRleF07XG5cbiAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgIGNvbnN0IHVybFBhZGRpbmcgPSBtYXhVcmxMZW5ndGggLSB1cmwubGVuZ3RoICsgMTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvclBhZGRpbmcgPSBtYXhEZXNjcmlwdG9yTGVmdExlbmd0aCAtIGRlc2NyaXB0b3JMZWZ0TGVuZ3Roc1tpbmRleF07XG4gICAgICAgIGNvbnN0IGFsaWdubWVudCA9IFwiIFwiLnJlcGVhdCh1cmxQYWRkaW5nICsgZGVzY3JpcHRvclBhZGRpbmcpO1xuICAgICAgICBwYXJ0cy5wdXNoKGlmQnJlYWskNChhbGlnbm1lbnQsIFwiIFwiKSwgZGVzY3JpcHRvciArIHVuaXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0JDkocGFydHMpO1xuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q2xhc3NOYW1lcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKFwiIFwiKTtcbiAgfVxuXG4gIHZhciBzeW50YXhBdHRyaWJ1dGUgPSB7XG4gICAgcHJpbnRJbWdTcmNzZXQsXG4gICAgcHJpbnRDbGFzc05hbWVzXG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGJ1aWxkZXJzLFxuICAgIHV0aWxzOiB7XG4gICAgICBzdHJpcFRyYWlsaW5nSGFyZGxpbmU6IHN0cmlwVHJhaWxpbmdIYXJkbGluZSQxLFxuICAgICAgbWFwRG9jOiBtYXBEb2MkMlxuICAgIH1cbiAgfSA9IGRvY3VtZW50O1xuICBjb25zdCB7XG4gICAgYnJlYWtQYXJlbnQ6IGJyZWFrUGFyZW50JDIsXG4gICAgZGVkZW50VG9Sb290OiBkZWRlbnRUb1Jvb3QkMSxcbiAgICBmaWxsOiBmaWxsJDMsXG4gICAgZ3JvdXA6IGdyb3VwJDksXG4gICAgaGFyZGxpbmU6IGhhcmRsaW5lJDcsXG4gICAgaWZCcmVhazogaWZCcmVhayQ1LFxuICAgIGluZGVudDogaW5kZW50JDUsXG4gICAgam9pbjogam9pbiQ2LFxuICAgIGxpbmU6IGxpbmUkNixcbiAgICBsaXRlcmFsbGluZTogbGl0ZXJhbGxpbmUkMixcbiAgICBtYXJrQXNSb290OiBtYXJrQXNSb290JDIsXG4gICAgc29mdGxpbmU6IHNvZnRsaW5lJDRcbiAgfSA9IGJ1aWxkZXJzO1xuICBjb25zdCB7XG4gICAgY291bnRDaGFyczogY291bnRDaGFycyQxLFxuICAgIGNvdW50UGFyZW50czogY291bnRQYXJlbnRzJDEsXG4gICAgZGVkZW50U3RyaW5nOiBkZWRlbnRTdHJpbmckMSxcbiAgICBmb3JjZUJyZWFrQ2hpbGRyZW46IGZvcmNlQnJlYWtDaGlsZHJlbiQxLFxuICAgIGZvcmNlQnJlYWtDb250ZW50OiBmb3JjZUJyZWFrQ29udGVudCQxLFxuICAgIGZvcmNlTmV4dEVtcHR5TGluZTogZm9yY2VOZXh0RW1wdHlMaW5lJDEsXG4gICAgZ2V0TGFzdERlc2NlbmRhbnQ6IGdldExhc3REZXNjZW5kYW50JDEsXG4gICAgZ2V0UHJldHRpZXJJZ25vcmVBdHRyaWJ1dGVDb21tZW50RGF0YTogZ2V0UHJldHRpZXJJZ25vcmVBdHRyaWJ1dGVDb21tZW50RGF0YSQxLFxuICAgIGhhc1ByZXR0aWVySWdub3JlOiBoYXNQcmV0dGllcklnbm9yZSQzLFxuICAgIGluZmVyU2NyaXB0UGFyc2VyOiBpbmZlclNjcmlwdFBhcnNlciQxLFxuICAgIGlzU2NyaXB0TGlrZVRhZzogaXNTY3JpcHRMaWtlVGFnJDEsXG4gICAgaXNUZXh0TGlrZU5vZGU6IGlzVGV4dExpa2VOb2RlJDEsXG4gICAgbm9ybWFsaXplUGFydHM6IG5vcm1hbGl6ZVBhcnRzJDEsXG4gICAgcHJlZmVySGFyZGxpbmVBc0xlYWRpbmdTcGFjZXM6IHByZWZlckhhcmRsaW5lQXNMZWFkaW5nU3BhY2VzJDEsXG4gICAgc2hvdWxkTm90UHJpbnRDbG9zaW5nVGFnOiBzaG91bGROb3RQcmludENsb3NpbmdUYWckMSxcbiAgICBzaG91bGRQcmVzZXJ2ZUNvbnRlbnQ6IHNob3VsZFByZXNlcnZlQ29udGVudCQxLFxuICAgIHVuZXNjYXBlUXVvdGVFbnRpdGllczogdW5lc2NhcGVRdW90ZUVudGl0aWVzJDFcbiAgfSA9IHV0aWxzJDQ7XG4gIGNvbnN0IHtcbiAgICByZXBsYWNlRW5kT2ZMaW5lV2l0aDogcmVwbGFjZUVuZE9mTGluZVdpdGgkMVxuICB9ID0gdXRpbCQxO1xuICBjb25zdCB7XG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkNlxuICB9ID0gcHJhZ21hJDM7XG4gIGNvbnN0IHtcbiAgICBwcmludFZ1ZUZvcjogcHJpbnRWdWVGb3IkMSxcbiAgICBwcmludFZ1ZVNsb3RTY29wZTogcHJpbnRWdWVTbG90U2NvcGUkMSxcbiAgICBpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb246IGlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbiQxXG4gIH0gPSBzeW50YXhWdWU7XG4gIGNvbnN0IHtcbiAgICBwcmludEltZ1NyY3NldDogcHJpbnRJbWdTcmNzZXQkMSxcbiAgICBwcmludENsYXNzTmFtZXM6IHByaW50Q2xhc3NOYW1lcyQxXG4gIH0gPSBzeW50YXhBdHRyaWJ1dGU7XG5cbiAgZnVuY3Rpb24gY29uY2F0JGEocGFydHMpIHtcbiAgICBjb25zdCBuZXdQYXJ0cyA9IG5vcm1hbGl6ZVBhcnRzJDEocGFydHMpO1xuICAgIHJldHVybiBuZXdQYXJ0cy5sZW5ndGggPT09IDAgPyBcIlwiIDogbmV3UGFydHMubGVuZ3RoID09PSAxID8gbmV3UGFydHNbMF0gOiBidWlsZGVycy5jb25jYXQobmV3UGFydHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW1iZWQkMihwYXRoLCBwcmludCwgdGV4dFRvRG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGlzU2NyaXB0TGlrZVRhZyQxKG5vZGUucGFyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gaW5mZXJTY3JpcHRQYXJzZXIkMShub2RlLnBhcmVudCk7XG5cbiAgICAgICAgICAgIGlmIChwYXJzZXIpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZXIgPT09IFwibWFya2Rvd25cIiA/IGRlZGVudFN0cmluZyQxKG5vZGUudmFsdWUucmVwbGFjZSgvXlteXFxTXFxuXSo/XFxuLywgXCJcIikpIDogbm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXJzLmNvbmNhdChbY29uY2F0JGEoW2JyZWFrUGFyZW50JDIsIHByaW50T3BlbmluZ1RhZ1ByZWZpeChub2RlLCBvcHRpb25zKSwgc3RyaXBUcmFpbGluZ0hhcmRsaW5lJDEodGV4dFRvRG9jKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgcGFyc2VyXG4gICAgICAgICAgICAgIH0pKSwgcHJpbnRDbG9zaW5nVGFnU3VmZml4KG5vZGUsIG9wdGlvbnMpXSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09IFwiaW50ZXJwb2xhdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGEoW2luZGVudCQ1KGNvbmNhdCRhKFtsaW5lJDYsIHRleHRUb0RvYyhub2RlLnZhbHVlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgX19pc0luSHRtbEludGVycG9sYXRpb246IHRydWVcbiAgICAgICAgICAgIH0sIG9wdGlvbnMucGFyc2VyID09PSBcImFuZ3VsYXJcIiA/IHtcbiAgICAgICAgICAgICAgcGFyc2VyOiBcIl9fbmdfaW50ZXJwb2xhdGlvblwiLFxuICAgICAgICAgICAgICB0cmFpbGluZ0NvbW1hOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSA6IG9wdGlvbnMucGFyc2VyID09PSBcInZ1ZVwiID8ge1xuICAgICAgICAgICAgICBwYXJzZXI6IFwiX192dWVfZXhwcmVzc2lvblwiXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICBwYXJzZXI6IFwiX19qc19leHByZXNzaW9uXCJcbiAgICAgICAgICAgIH0pKV0pKSwgbm9kZS5wYXJlbnQubmV4dCAmJiBuZWVkc1RvQm9ycm93UHJldkNsb3NpbmdUYWdFbmRNYXJrZXIobm9kZS5wYXJlbnQubmV4dCkgPyBcIiBcIiA6IGxpbmUkNl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJhdHRyaWJ1dGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICghbm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBsaXQtaHRtbDogaHRtbGA8bXktZWxlbWVudCBvYmo9JHtvYmp9PjwvbXktZWxlbWVudD5gXG5cblxuICAgICAgICAgIGlmICgvXlBSRVRUSUVSX0hUTUxfUExBQ0VIT0xERVJfXFxkK19cXGQrX0lOX0pTJC8udGVzdChvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLnZhbHVlU3Bhbi5zdGFydC5vZmZzZXQsIG5vZGUudmFsdWVTcGFuLmVuZC5vZmZzZXQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRhKFtub2RlLnJhd05hbWUsIFwiPVwiLCBub2RlLnZhbHVlXSk7XG4gICAgICAgICAgfSAvLyBsd2M6IGh0bWxgPG15LWVsZW1lbnQgZGF0YS1mb3I9e3ZhbHVlfT48L215LWVsZW1lbnQ+YFxuXG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZXIgPT09IFwibHdjXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRpb25SZWdleCA9IC9eXFx7W1xcc1xcU10qXFx9JC87XG5cbiAgICAgICAgICAgIGlmIChpbnRlcnBvbGF0aW9uUmVnZXgudGVzdChvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLnZhbHVlU3Bhbi5zdGFydC5vZmZzZXQsIG5vZGUudmFsdWVTcGFuLmVuZC5vZmZzZXQpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gY29uY2F0JGEoW25vZGUucmF3TmFtZSwgXCI9XCIsIG5vZGUudmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBlbWJlZGRlZEF0dHJpYnV0ZVZhbHVlRG9jID0gcHJpbnRFbWJlZGRlZEF0dHJpYnV0ZVZhbHVlKG5vZGUsIChjb2RlLCBvcHRzKSA9PiAvLyBzdHJpY3RseSBwcmVmZXIgc2luZ2xlIHF1b3RlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGh0bWwgZW50aXR5IGVzY2FwZVxuICAgICAgICAgIHRleHRUb0RvYyhjb2RlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIF9faXNJbkh0bWxBdHRyaWJ1dGU6IHRydWVcbiAgICAgICAgICB9LCBvcHRzKSksIG9wdGlvbnMpO1xuXG4gICAgICAgICAgaWYgKGVtYmVkZGVkQXR0cmlidXRlVmFsdWVEb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkYShbbm9kZS5yYXdOYW1lLCAnPVwiJywgZ3JvdXAkOShtYXBEb2MkMihlbWJlZGRlZEF0dHJpYnV0ZVZhbHVlRG9jLCBkb2MgPT4gdHlwZW9mIGRvYyA9PT0gXCJzdHJpbmdcIiA/IGRvYy5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKSA6IGRvYykpLCAnXCInXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInlhbWxcIjpcbiAgICAgICAgcmV0dXJuIG1hcmtBc1Jvb3QkMihjb25jYXQkYShbXCItLS1cIiwgaGFyZGxpbmUkNywgbm9kZS52YWx1ZS50cmltKCkubGVuZ3RoID09PSAwID8gXCJcIiA6IHRleHRUb0RvYyhub2RlLnZhbHVlLCB7XG4gICAgICAgICAgcGFyc2VyOiBcInlhbWxcIlxuICAgICAgICB9KSwgXCItLS1cIl0pKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmljUHJpbnQkMihwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcInJvb3RcIjpcbiAgICAgICAgaWYgKG9wdGlvbnMuX19vbkh0bWxSb290KSB7XG4gICAgICAgICAgb3B0aW9ucy5fX29uSHRtbFJvb3Qobm9kZSk7XG4gICAgICAgIH0gLy8gdXNlIG9yaWdpbmFsIGNvbmNhdCB0byBub3QgYnJlYWsgc3RyaXBUcmFpbGluZ0hhcmRsaW5lXG5cblxuICAgICAgICByZXR1cm4gYnVpbGRlcnMuY29uY2F0KFtncm91cCQ5KHByaW50Q2hpbGRyZW4kMShwYXRoLCBvcHRpb25zLCBwcmludCkpLCBoYXJkbGluZSQ3XSk7XG5cbiAgICAgIGNhc2UgXCJlbGVtZW50XCI6XG4gICAgICBjYXNlIFwiaWVDb25kaXRpb25hbENvbW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGRvIG5vdCBicmVhazpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqICAgICA8ZGl2Pnt7XG4gICAgICAgICAgICogICAgICAgICB+XG4gICAgICAgICAgICogICAgICAgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAqICAgICB9fTwvZGl2PlxuICAgICAgICAgICAqICAgICAgICAgICAgflxuICAgICAgICAgICAqXG4gICAgICAgICAgICogZXhjZXB0aW9uOiBicmVhayBpZiB0aGUgb3BlbmluZyB0YWcgYnJlYWtzXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAgICAgPGRpdlxuICAgICAgICAgICAqICAgICAgIGxvbmdcbiAgICAgICAgICAgKiAgICAgICAgICAgflxuICAgICAgICAgICAqICAgICAgID57e1xuICAgICAgICAgICAqICAgICAgICAgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAqICAgICAgIH19PC9kaXZcbiAgICAgICAgICAgKiAgICAgICAgICAgICAgflxuICAgICAgICAgICAqICAgICA+XG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3Qgc2hvdWxkSHVnQ29udGVudCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09PSBcImludGVycG9sYXRpb25cIiAmJiBub2RlLmZpcnN0Q2hpbGQuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmUgJiYgIW5vZGUuZmlyc3RDaGlsZC5oYXNMZWFkaW5nU3BhY2VzICYmIG5vZGUubGFzdENoaWxkLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSAmJiAhbm9kZS5sYXN0Q2hpbGQuaGFzVHJhaWxpbmdTcGFjZXM7XG4gICAgICAgICAgY29uc3QgYXR0ckdyb3VwSWQgPSBTeW1ib2woXCJlbGVtZW50LWF0dHItZ3JvdXAtaWRcIik7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRhKFtncm91cCQ5KGNvbmNhdCRhKFtncm91cCQ5KHByaW50T3BlbmluZ1RhZyhwYXRoLCBvcHRpb25zLCBwcmludCksIHtcbiAgICAgICAgICAgIGlkOiBhdHRyR3JvdXBJZFxuICAgICAgICAgIH0pLCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IG5vZGUuaGFzRGFuZ2xpbmdTcGFjZXMgJiYgbm9kZS5pc0RhbmdsaW5nU3BhY2VTZW5zaXRpdmUgPyBsaW5lJDYgOiBcIlwiIDogY29uY2F0JGEoW2ZvcmNlQnJlYWtDb250ZW50JDEobm9kZSkgPyBicmVha1BhcmVudCQyIDogXCJcIiwgKGNoaWxkcmVuRG9jID0+IHNob3VsZEh1Z0NvbnRlbnQgPyBpZkJyZWFrJDUoaW5kZW50JDUoY2hpbGRyZW5Eb2MpLCBjaGlsZHJlbkRvYywge1xuICAgICAgICAgICAgZ3JvdXBJZDogYXR0ckdyb3VwSWRcbiAgICAgICAgICB9KSA6IGlzU2NyaXB0TGlrZVRhZyQxKG5vZGUpICYmIG5vZGUucGFyZW50LnR5cGUgPT09IFwicm9vdFwiICYmIG9wdGlvbnMucGFyc2VyID09PSBcInZ1ZVwiICYmICFvcHRpb25zLnZ1ZUluZGVudFNjcmlwdEFuZFN0eWxlID8gY2hpbGRyZW5Eb2MgOiBpbmRlbnQkNShjaGlsZHJlbkRvYykpKGNvbmNhdCRhKFtzaG91bGRIdWdDb250ZW50ID8gaWZCcmVhayQ1KHNvZnRsaW5lJDQsIFwiXCIsIHtcbiAgICAgICAgICAgIGdyb3VwSWQ6IGF0dHJHcm91cElkXG4gICAgICAgICAgfSkgOiBub2RlLmZpcnN0Q2hpbGQuaGFzTGVhZGluZ1NwYWNlcyAmJiBub2RlLmZpcnN0Q2hpbGQuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmUgPyBsaW5lJDYgOiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgbm9kZS5pc1doaXRlc3BhY2VTZW5zaXRpdmUgJiYgbm9kZS5pc0luZGVudGF0aW9uU2Vuc2l0aXZlID8gZGVkZW50VG9Sb290JDEoc29mdGxpbmUkNCkgOiBzb2Z0bGluZSQ0LCBwcmludENoaWxkcmVuJDEocGF0aCwgb3B0aW9ucywgcHJpbnQpXSkpLCAobm9kZS5uZXh0ID8gbmVlZHNUb0JvcnJvd1ByZXZDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUubmV4dCkgOiBuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlLnBhcmVudCkpID8gbm9kZS5sYXN0Q2hpbGQuaGFzVHJhaWxpbmdTcGFjZXMgJiYgbm9kZS5sYXN0Q2hpbGQuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlID8gXCIgXCIgOiBcIlwiIDogc2hvdWxkSHVnQ29udGVudCA/IGlmQnJlYWskNShzb2Z0bGluZSQ0LCBcIlwiLCB7XG4gICAgICAgICAgICBncm91cElkOiBhdHRyR3JvdXBJZFxuICAgICAgICAgIH0pIDogbm9kZS5sYXN0Q2hpbGQuaGFzVHJhaWxpbmdTcGFjZXMgJiYgbm9kZS5sYXN0Q2hpbGQuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlID8gbGluZSQ2IDogKG5vZGUubGFzdENoaWxkLnR5cGUgPT09IFwiY29tbWVudFwiIHx8IG5vZGUubGFzdENoaWxkLnR5cGUgPT09IFwidGV4dFwiICYmIG5vZGUuaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlICYmIG5vZGUuaXNJbmRlbnRhdGlvblNlbnNpdGl2ZSkgJiYgbmV3IFJlZ0V4cChcIlxcXFxuXFxcXHN7XCIuY29uY2F0KG9wdGlvbnMudGFiV2lkdGggKiBjb3VudFBhcmVudHMkMShwYXRoLCBuID0+IG4ucGFyZW50ICYmIG4ucGFyZW50LnR5cGUgIT09IFwicm9vdFwiKSwgXCJ9JFwiKSkudGVzdChub2RlLmxhc3RDaGlsZC52YWx1ZSkgP1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqICAgICA8ZGl2PlxuICAgICAgICAgICAqICAgICAgIDxwcmU+XG4gICAgICAgICAgICogICAgICAgICBzb21ldGhpbmdcbiAgICAgICAgICAgKiAgICAgICA8L3ByZT5cbiAgICAgICAgICAgKiAgICAgICAgICAgIH5cbiAgICAgICAgICAgKiAgICAgPC9kaXY+XG4gICAgICAgICAgICovXG4gICAgICAgICAgXCJcIiA6IHNvZnRsaW5lJDRdKV0pKSwgcHJpbnRDbG9zaW5nVGFnKG5vZGUsIG9wdGlvbnMpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxTdGFydENvbW1lbnRcIjpcbiAgICAgIGNhc2UgXCJpZUNvbmRpdGlvbmFsRW5kQ29tbWVudFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGEoW3ByaW50T3BlbmluZ1RhZ1N0YXJ0KG5vZGUpLCBwcmludENsb3NpbmdUYWdFbmQobm9kZSldKTtcblxuICAgICAgY2FzZSBcImludGVycG9sYXRpb25cIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRhKFtwcmludE9wZW5pbmdUYWdTdGFydChub2RlLCBvcHRpb25zKSwgY29uY2F0JGEocGF0aC5tYXAocHJpbnQsIFwiY2hpbGRyZW5cIikpLCBwcmludENsb3NpbmdUYWdFbmQobm9kZSwgb3B0aW9ucyldKTtcblxuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSBcImludGVycG9sYXRpb25cIikge1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgdHJhaWxpbmcgbGl0ZXJhbGxpbmUgd2l0aCBoYXJkbGluZSBmb3IgYmV0dGVyIHJlYWRhYmlsaXR5XG4gICAgICAgICAgICBjb25zdCB0cmFpbGluZ05ld2xpbmVSZWdleCA9IC9cXG5bXlxcU1xcbl0qPyQvO1xuICAgICAgICAgICAgY29uc3QgaGFzVHJhaWxpbmdOZXdsaW5lID0gdHJhaWxpbmdOZXdsaW5lUmVnZXgudGVzdChub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaGFzVHJhaWxpbmdOZXdsaW5lID8gbm9kZS52YWx1ZS5yZXBsYWNlKHRyYWlsaW5nTmV3bGluZVJlZ2V4LCBcIlwiKSA6IG5vZGUudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGEoW2NvbmNhdCRhKHJlcGxhY2VFbmRPZkxpbmVXaXRoJDEodmFsdWUsIGxpdGVyYWxsaW5lJDIpKSwgaGFzVHJhaWxpbmdOZXdsaW5lID8gaGFyZGxpbmUkNyA6IFwiXCJdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmlsbCQzKG5vcm1hbGl6ZVBhcnRzJDEoW10uY29uY2F0KHByaW50T3BlbmluZ1RhZ1ByZWZpeChub2RlLCBvcHRpb25zKSwgZ2V0VGV4dFZhbHVlUGFydHMobm9kZSksIHByaW50Q2xvc2luZ1RhZ1N1ZmZpeChub2RlLCBvcHRpb25zKSkpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZG9jVHlwZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGEoW2dyb3VwJDkoY29uY2F0JGEoW3ByaW50T3BlbmluZ1RhZ1N0YXJ0KG5vZGUsIG9wdGlvbnMpLCBcIiBcIiwgbm9kZS52YWx1ZS5yZXBsYWNlKC9eaHRtbFxcYi9pLCBcImh0bWxcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIildKSksIHByaW50Q2xvc2luZ1RhZ0VuZChub2RlLCBvcHRpb25zKV0pO1xuXG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRhKFtwcmludE9wZW5pbmdUYWdQcmVmaXgobm9kZSwgb3B0aW9ucyksIGNvbmNhdCRhKHJlcGxhY2VFbmRPZkxpbmVXaXRoJDEob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uob3B0aW9ucy5sb2NTdGFydChub2RlKSwgb3B0aW9ucy5sb2NFbmQobm9kZSkpLCBsaXRlcmFsbGluZSQyKSksIHByaW50Q2xvc2luZ1RhZ1N1ZmZpeChub2RlLCBvcHRpb25zKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJhdHRyaWJ1dGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChub2RlLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5yYXdOYW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdW5lc2NhcGVRdW90ZUVudGl0aWVzJDEobm9kZS52YWx1ZSk7XG4gICAgICAgICAgY29uc3Qgc2luZ2xlUXVvdGVDb3VudCA9IGNvdW50Q2hhcnMkMSh2YWx1ZSwgXCInXCIpO1xuICAgICAgICAgIGNvbnN0IGRvdWJsZVF1b3RlQ291bnQgPSBjb3VudENoYXJzJDEodmFsdWUsICdcIicpO1xuICAgICAgICAgIGNvbnN0IHF1b3RlID0gc2luZ2xlUXVvdGVDb3VudCA8IGRvdWJsZVF1b3RlQ291bnQgPyBcIidcIiA6ICdcIic7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRhKFtub2RlLnJhd05hbWUsIGNvbmNhdCRhKFtcIj1cIiwgcXVvdGUsIGNvbmNhdCRhKHJlcGxhY2VFbmRPZkxpbmVXaXRoJDEocXVvdGUgPT09ICdcIicgPyB2YWx1ZS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKSA6IHZhbHVlLnJlcGxhY2UoLycvZywgXCImYXBvcztcIiksIGxpdGVyYWxsaW5lJDIpKSwgcXVvdGVdKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ5YW1sXCI6XG4gICAgICBjYXNlIFwidG9tbFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGEocmVwbGFjZUVuZE9mTGluZVdpdGgkMShub2RlLnJhdywgbGl0ZXJhbGxpbmUkMikpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIi5jb25jYXQobm9kZS50eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDaGlsZHJlbiQxKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmIChmb3JjZUJyZWFrQ2hpbGRyZW4kMShub2RlKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRhKFticmVha1BhcmVudCQyLCBjb25jYXQkYShwYXRoLm1hcChjaGlsZFBhdGggPT4ge1xuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZFBhdGguZ2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcHJldkJldHdlZW5MaW5lID0gIWNoaWxkTm9kZS5wcmV2ID8gXCJcIiA6IHByaW50QmV0d2VlbkxpbmUoY2hpbGROb2RlLnByZXYsIGNoaWxkTm9kZSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkYShbIXByZXZCZXR3ZWVuTGluZSA/IFwiXCIgOiBjb25jYXQkYShbcHJldkJldHdlZW5MaW5lLCBmb3JjZU5leHRFbXB0eUxpbmUkMShjaGlsZE5vZGUucHJldikgPyBoYXJkbGluZSQ3IDogXCJcIl0pLCBwcmludENoaWxkKGNoaWxkUGF0aCldKTtcbiAgICAgIH0sIFwiY2hpbGRyZW5cIikpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3JvdXBJZHMgPSBub2RlLmNoaWxkcmVuLm1hcCgoKSA9PiBTeW1ib2woXCJcIikpO1xuICAgIHJldHVybiBjb25jYXQkYShwYXRoLm1hcCgoY2hpbGRQYXRoLCBjaGlsZEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZFBhdGguZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKGlzVGV4dExpa2VOb2RlJDEoY2hpbGROb2RlKSkge1xuICAgICAgICBpZiAoY2hpbGROb2RlLnByZXYgJiYgaXNUZXh0TGlrZU5vZGUkMShjaGlsZE5vZGUucHJldikpIHtcbiAgICAgICAgICBjb25zdCBwcmV2QmV0d2VlbkxpbmUgPSBwcmludEJldHdlZW5MaW5lKGNoaWxkTm9kZS5wcmV2LCBjaGlsZE5vZGUpO1xuXG4gICAgICAgICAgaWYgKHByZXZCZXR3ZWVuTGluZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlTmV4dEVtcHR5TGluZSQxKGNoaWxkTm9kZS5wcmV2KSkge1xuICAgICAgICAgICAgICByZXR1cm4gY29uY2F0JGEoW2hhcmRsaW5lJDcsIGhhcmRsaW5lJDcsIHByaW50Q2hpbGQoY2hpbGRQYXRoKV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGEoW3ByZXZCZXR3ZWVuTGluZSwgcHJpbnRDaGlsZChjaGlsZFBhdGgpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByaW50Q2hpbGQoY2hpbGRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJldlBhcnRzID0gW107XG4gICAgICBjb25zdCBsZWFkaW5nUGFydHMgPSBbXTtcbiAgICAgIGNvbnN0IHRyYWlsaW5nUGFydHMgPSBbXTtcbiAgICAgIGNvbnN0IG5leHRQYXJ0cyA9IFtdO1xuICAgICAgY29uc3QgcHJldkJldHdlZW5MaW5lID0gY2hpbGROb2RlLnByZXYgPyBwcmludEJldHdlZW5MaW5lKGNoaWxkTm9kZS5wcmV2LCBjaGlsZE5vZGUpIDogXCJcIjtcbiAgICAgIGNvbnN0IG5leHRCZXR3ZWVuTGluZSA9IGNoaWxkTm9kZS5uZXh0ID8gcHJpbnRCZXR3ZWVuTGluZShjaGlsZE5vZGUsIGNoaWxkTm9kZS5uZXh0KSA6IFwiXCI7XG5cbiAgICAgIGlmIChwcmV2QmV0d2VlbkxpbmUpIHtcbiAgICAgICAgaWYgKGZvcmNlTmV4dEVtcHR5TGluZSQxKGNoaWxkTm9kZS5wcmV2KSkge1xuICAgICAgICAgIHByZXZQYXJ0cy5wdXNoKGhhcmRsaW5lJDcsIGhhcmRsaW5lJDcpO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZCZXR3ZWVuTGluZSA9PT0gaGFyZGxpbmUkNykge1xuICAgICAgICAgIHByZXZQYXJ0cy5wdXNoKGhhcmRsaW5lJDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc1RleHRMaWtlTm9kZSQxKGNoaWxkTm9kZS5wcmV2KSkge1xuICAgICAgICAgICAgbGVhZGluZ1BhcnRzLnB1c2gocHJldkJldHdlZW5MaW5lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVhZGluZ1BhcnRzLnB1c2goaWZCcmVhayQ1KFwiXCIsIHNvZnRsaW5lJDQsIHtcbiAgICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZHNbY2hpbGRJbmRleCAtIDFdXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0QmV0d2VlbkxpbmUpIHtcbiAgICAgICAgaWYgKGZvcmNlTmV4dEVtcHR5TGluZSQxKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICBpZiAoaXNUZXh0TGlrZU5vZGUkMShjaGlsZE5vZGUubmV4dCkpIHtcbiAgICAgICAgICAgIG5leHRQYXJ0cy5wdXNoKGhhcmRsaW5lJDcsIGhhcmRsaW5lJDcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0QmV0d2VlbkxpbmUgPT09IGhhcmRsaW5lJDcpIHtcbiAgICAgICAgICBpZiAoaXNUZXh0TGlrZU5vZGUkMShjaGlsZE5vZGUubmV4dCkpIHtcbiAgICAgICAgICAgIG5leHRQYXJ0cy5wdXNoKGhhcmRsaW5lJDcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cmFpbGluZ1BhcnRzLnB1c2gobmV4dEJldHdlZW5MaW5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0JGEoW10uY29uY2F0KHByZXZQYXJ0cywgZ3JvdXAkOShjb25jYXQkYShbY29uY2F0JGEobGVhZGluZ1BhcnRzKSwgZ3JvdXAkOShjb25jYXQkYShbcHJpbnRDaGlsZChjaGlsZFBhdGgpLCBjb25jYXQkYSh0cmFpbGluZ1BhcnRzKV0pLCB7XG4gICAgICAgIGlkOiBncm91cElkc1tjaGlsZEluZGV4XVxuICAgICAgfSldKSksIG5leHRQYXJ0cykpO1xuICAgIH0sIFwiY2hpbGRyZW5cIikpO1xuXG4gICAgZnVuY3Rpb24gcHJpbnRDaGlsZChjaGlsZFBhdGgpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRQYXRoLmdldFZhbHVlKCk7XG5cbiAgICAgIGlmIChoYXNQcmV0dGllcklnbm9yZSQzKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gY29uY2F0JGEoW10uY29uY2F0KHByaW50T3BlbmluZ1RhZ1ByZWZpeChjaGlsZCwgb3B0aW9ucyksIHJlcGxhY2VFbmRPZkxpbmVXaXRoJDEob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uob3B0aW9ucy5sb2NTdGFydChjaGlsZCkgKyAoY2hpbGQucHJldiAmJiBuZWVkc1RvQm9ycm93TmV4dE9wZW5pbmdUYWdTdGFydE1hcmtlcihjaGlsZC5wcmV2KSA/IHByaW50T3BlbmluZ1RhZ1N0YXJ0TWFya2VyKGNoaWxkKS5sZW5ndGggOiAwKSwgb3B0aW9ucy5sb2NFbmQoY2hpbGQpIC0gKGNoaWxkLm5leHQgJiYgbmVlZHNUb0JvcnJvd1ByZXZDbG9zaW5nVGFnRW5kTWFya2VyKGNoaWxkLm5leHQpID8gcHJpbnRDbG9zaW5nVGFnRW5kTWFya2VyKGNoaWxkLCBvcHRpb25zKS5sZW5ndGggOiAwKSksIGxpdGVyYWxsaW5lJDIpLCBwcmludENsb3NpbmdUYWdTdWZmaXgoY2hpbGQsIG9wdGlvbnMpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRQcmVzZXJ2ZUNvbnRlbnQkMShjaGlsZCwgb3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRhKFtdLmNvbmNhdChwcmludE9wZW5pbmdUYWdQcmVmaXgoY2hpbGQsIG9wdGlvbnMpLCBncm91cCQ5KHByaW50T3BlbmluZ1RhZyhjaGlsZFBhdGgsIG9wdGlvbnMsIHByaW50KSksIHJlcGxhY2VFbmRPZkxpbmVXaXRoJDEob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2UoY2hpbGQuc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQgKyAoY2hpbGQuZmlyc3RDaGlsZCAmJiBuZWVkc1RvQm9ycm93UGFyZW50T3BlbmluZ1RhZ0VuZE1hcmtlcihjaGlsZC5maXJzdENoaWxkKSA/IC1wcmludE9wZW5pbmdUYWdFbmRNYXJrZXIoY2hpbGQpLmxlbmd0aCA6IDApLCBjaGlsZC5lbmRTb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCArIChjaGlsZC5sYXN0Q2hpbGQgJiYgbmVlZHNUb0JvcnJvd1BhcmVudENsb3NpbmdUYWdTdGFydE1hcmtlcihjaGlsZC5sYXN0Q2hpbGQpID8gcHJpbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXIoY2hpbGQsIG9wdGlvbnMpLmxlbmd0aCA6IG5lZWRzVG9Cb3Jyb3dMYXN0Q2hpbGRDbG9zaW5nVGFnRW5kTWFya2VyKGNoaWxkKSA/IC1wcmludENsb3NpbmdUYWdFbmRNYXJrZXIoY2hpbGQubGFzdENoaWxkLCBvcHRpb25zKS5sZW5ndGggOiAwKSksIGxpdGVyYWxsaW5lJDIpLCBwcmludENsb3NpbmdUYWcoY2hpbGQsIG9wdGlvbnMpLCBwcmludENsb3NpbmdUYWdTdWZmaXgoY2hpbGQsIG9wdGlvbnMpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmludChjaGlsZFBhdGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50QmV0d2VlbkxpbmUocHJldk5vZGUsIG5leHROb2RlKSB7XG4gICAgICByZXR1cm4gaXNUZXh0TGlrZU5vZGUkMShwcmV2Tm9kZSkgJiYgaXNUZXh0TGlrZU5vZGUkMShuZXh0Tm9kZSkgPyBwcmV2Tm9kZS5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUgPyBwcmV2Tm9kZS5oYXNUcmFpbGluZ1NwYWNlcyA/IHByZWZlckhhcmRsaW5lQXNMZWFkaW5nU3BhY2VzJDEobmV4dE5vZGUpID8gaGFyZGxpbmUkNyA6IGxpbmUkNiA6IFwiXCIgOiBwcmVmZXJIYXJkbGluZUFzTGVhZGluZ1NwYWNlcyQxKG5leHROb2RlKSA/IGhhcmRsaW5lJDcgOiBzb2Z0bGluZSQ0IDogbmVlZHNUb0JvcnJvd05leHRPcGVuaW5nVGFnU3RhcnRNYXJrZXIocHJldk5vZGUpICYmIChoYXNQcmV0dGllcklnbm9yZSQzKG5leHROb2RlKSB8fFxuICAgICAgLyoqXG4gICAgICAgKiAgICAgMTIzPGFcbiAgICAgICAqICAgICAgICAgIH5cbiAgICAgICAqICAgICAgID48Yj5cbiAgICAgICAqL1xuICAgICAgbmV4dE5vZGUuZmlyc3RDaGlsZCB8fFxuICAgICAgLyoqXG4gICAgICAgKiAgICAgMTIzPCEtLVxuICAgICAgICogICAgICAgICAgICB+XG4gICAgICAgKiAgICAgLS0+XG4gICAgICAgKi9cbiAgICAgIG5leHROb2RlLmlzU2VsZkNsb3NpbmcgfHxcbiAgICAgIC8qKlxuICAgICAgICogICAgIDEyMzxzcGFuXG4gICAgICAgKiAgICAgICAgICAgICB+XG4gICAgICAgKiAgICAgICBhdHRyXG4gICAgICAgKi9cbiAgICAgIG5leHROb2RlLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIG5leHROb2RlLmF0dHJzLmxlbmd0aCAhPT0gMCkgfHxcbiAgICAgIC8qKlxuICAgICAgICogICAgIDxpbWdcbiAgICAgICAqICAgICAgIHNyYz1cImxvbmdcIlxuICAgICAgICogICAgICAgICAgICAgICAgIH5cbiAgICAgICAqICAgICAvPjEyM1xuICAgICAgICovXG4gICAgICBwcmV2Tm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBwcmV2Tm9kZS5pc1NlbGZDbG9zaW5nICYmIG5lZWRzVG9Cb3Jyb3dQcmV2Q2xvc2luZ1RhZ0VuZE1hcmtlcihuZXh0Tm9kZSkgPyBcIlwiIDogIW5leHROb2RlLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlIHx8IHByZWZlckhhcmRsaW5lQXNMZWFkaW5nU3BhY2VzJDEobmV4dE5vZGUpIHx8XG4gICAgICAvKipcbiAgICAgICAqICAgICAgIFdhbnQgdG8gd3JpdGUgdXMgYSBsZXR0ZXI/IFVzZSBvdXI8YVxuICAgICAgICogICAgICAgICA+PGI+PGE+bWFpbGluZyBhZGRyZXNzPC9hPjwvYj48L2FcbiAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgflxuICAgICAgICogICAgICAgPi5cbiAgICAgICAqL1xuICAgICAgbmVlZHNUb0JvcnJvd1ByZXZDbG9zaW5nVGFnRW5kTWFya2VyKG5leHROb2RlKSAmJiBwcmV2Tm9kZS5sYXN0Q2hpbGQgJiYgbmVlZHNUb0JvcnJvd1BhcmVudENsb3NpbmdUYWdTdGFydE1hcmtlcihwcmV2Tm9kZS5sYXN0Q2hpbGQpICYmIHByZXZOb2RlLmxhc3RDaGlsZC5sYXN0Q2hpbGQgJiYgbmVlZHNUb0JvcnJvd1BhcmVudENsb3NpbmdUYWdTdGFydE1hcmtlcihwcmV2Tm9kZS5sYXN0Q2hpbGQubGFzdENoaWxkKSA/IGhhcmRsaW5lJDcgOiBuZXh0Tm9kZS5oYXNMZWFkaW5nU3BhY2VzID8gbGluZSQ2IDogc29mdGxpbmUkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmludE9wZW5pbmdUYWcocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IGZvcmNlTm90VG9CcmVha0F0dHJDb250ZW50ID0gbm9kZS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBub2RlLmZ1bGxOYW1lID09PSBcInNjcmlwdFwiICYmIG5vZGUuYXR0cnMubGVuZ3RoID09PSAxICYmIG5vZGUuYXR0cnNbMF0uZnVsbE5hbWUgPT09IFwic3JjXCIgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIGNvbmNhdCRhKFtwcmludE9wZW5pbmdUYWdTdGFydChub2RlLCBvcHRpb25zKSwgIW5vZGUuYXR0cnMgfHwgbm9kZS5hdHRycy5sZW5ndGggPT09IDAgPyBub2RlLmlzU2VsZkNsb3NpbmcgP1xuICAgIC8qKlxuICAgICAqICAgICA8YnIgLz5cbiAgICAgKiAgICAgICAgXlxuICAgICAqL1xuICAgIFwiIFwiIDogXCJcIiA6IGNvbmNhdCRhKFtpbmRlbnQkNShjb25jYXQkYShbZm9yY2VOb3RUb0JyZWFrQXR0ckNvbnRlbnQgPyBcIiBcIiA6IGxpbmUkNiwgam9pbiQ2KGxpbmUkNiwgKGlnbm9yZUF0dHJpYnV0ZURhdGEgPT4ge1xuICAgICAgY29uc3QgaGFzUHJldHRpZXJJZ25vcmVBdHRyaWJ1dGUgPSB0eXBlb2YgaWdub3JlQXR0cmlidXRlRGF0YSA9PT0gXCJib29sZWFuXCIgPyAoKSA9PiBpZ25vcmVBdHRyaWJ1dGVEYXRhIDogQXJyYXkuaXNBcnJheShpZ25vcmVBdHRyaWJ1dGVEYXRhKSA/IGF0dHIgPT4gaWdub3JlQXR0cmlidXRlRGF0YS5pbmNsdWRlcyhhdHRyLnJhd05hbWUpIDogKCkgPT4gZmFsc2U7XG4gICAgICByZXR1cm4gcGF0aC5tYXAoYXR0clBhdGggPT4ge1xuICAgICAgICBjb25zdCBhdHRyID0gYXR0clBhdGguZ2V0VmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIGhhc1ByZXR0aWVySWdub3JlQXR0cmlidXRlKGF0dHIpID8gY29uY2F0JGEocmVwbGFjZUVuZE9mTGluZVdpdGgkMShvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShvcHRpb25zLmxvY1N0YXJ0KGF0dHIpLCBvcHRpb25zLmxvY0VuZChhdHRyKSksIGxpdGVyYWxsaW5lJDIpKSA6IHByaW50KGF0dHJQYXRoKTtcbiAgICAgIH0sIFwiYXR0cnNcIik7XG4gICAgfSkobm9kZS5wcmV2ICYmIG5vZGUucHJldi50eXBlID09PSBcImNvbW1lbnRcIiAmJiBnZXRQcmV0dGllcklnbm9yZUF0dHJpYnV0ZUNvbW1lbnREYXRhJDEobm9kZS5wcmV2LnZhbHVlKSkpXSkpLFxuICAgIC8qKlxuICAgICAqICAgICAxMjM8YVxuICAgICAqICAgICAgIGF0dHJcbiAgICAgKiAgICAgICAgICAgflxuICAgICAqICAgICAgID40NTZcbiAgICAgKi9cbiAgICBub2RlLmZpcnN0Q2hpbGQgJiYgbmVlZHNUb0JvcnJvd1BhcmVudE9wZW5pbmdUYWdFbmRNYXJrZXIobm9kZS5maXJzdENoaWxkKSB8fFxuICAgIC8qKlxuICAgICAqICAgICA8c3BhblxuICAgICAqICAgICAgID4xMjM8bWV0YVxuICAgICAqICAgICAgICAgICAgICAgIH5cbiAgICAgKiAgICAgLz48L3NwYW4+XG4gICAgICovXG4gICAgbm9kZS5pc1NlbGZDbG9zaW5nICYmIG5lZWRzVG9Cb3Jyb3dMYXN0Q2hpbGRDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUucGFyZW50KSA/IG5vZGUuaXNTZWxmQ2xvc2luZyA/IFwiIFwiIDogXCJcIiA6IG5vZGUuaXNTZWxmQ2xvc2luZyA/IGZvcmNlTm90VG9CcmVha0F0dHJDb250ZW50ID8gXCIgXCIgOiBsaW5lJDYgOiBmb3JjZU5vdFRvQnJlYWtBdHRyQ29udGVudCA/IFwiXCIgOiBzb2Z0bGluZSQ0XSksIG5vZGUuaXNTZWxmQ2xvc2luZyA/IFwiXCIgOiBwcmludE9wZW5pbmdUYWdFbmQobm9kZSldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50T3BlbmluZ1RhZ1N0YXJ0KG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbm9kZS5wcmV2ICYmIG5lZWRzVG9Cb3Jyb3dOZXh0T3BlbmluZ1RhZ1N0YXJ0TWFya2VyKG5vZGUucHJldikgPyBcIlwiIDogY29uY2F0JGEoW3ByaW50T3BlbmluZ1RhZ1ByZWZpeChub2RlLCBvcHRpb25zKSwgcHJpbnRPcGVuaW5nVGFnU3RhcnRNYXJrZXIobm9kZSldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50T3BlbmluZ1RhZ0VuZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZmlyc3RDaGlsZCAmJiBuZWVkc1RvQm9ycm93UGFyZW50T3BlbmluZ1RhZ0VuZE1hcmtlcihub2RlLmZpcnN0Q2hpbGQpID8gXCJcIiA6IHByaW50T3BlbmluZ1RhZ0VuZE1hcmtlcihub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q2xvc2luZ1RhZyhub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGNvbmNhdCRhKFtub2RlLmlzU2VsZkNsb3NpbmcgPyBcIlwiIDogcHJpbnRDbG9zaW5nVGFnU3RhcnQobm9kZSwgb3B0aW9ucyksIHByaW50Q2xvc2luZ1RhZ0VuZChub2RlLCBvcHRpb25zKV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDbG9zaW5nVGFnU3RhcnQobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBub2RlLmxhc3RDaGlsZCAmJiBuZWVkc1RvQm9ycm93UGFyZW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyKG5vZGUubGFzdENoaWxkKSA/IFwiXCIgOiBjb25jYXQkYShbcHJpbnRDbG9zaW5nVGFnUHJlZml4KG5vZGUsIG9wdGlvbnMpLCBwcmludENsb3NpbmdUYWdTdGFydE1hcmtlcihub2RlLCBvcHRpb25zKV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDbG9zaW5nVGFnRW5kKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG5vZGUubmV4dCA/IG5lZWRzVG9Cb3Jyb3dQcmV2Q2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlLm5leHQpIDogbmVlZHNUb0JvcnJvd0xhc3RDaGlsZENsb3NpbmdUYWdFbmRNYXJrZXIobm9kZS5wYXJlbnQpKSA/IFwiXCIgOiBjb25jYXQkYShbcHJpbnRDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUsIG9wdGlvbnMpLCBwcmludENsb3NpbmdUYWdTdWZmaXgobm9kZSwgb3B0aW9ucyldKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZWRzVG9Cb3Jyb3dOZXh0T3BlbmluZ1RhZ1N0YXJ0TWFya2VyKG5vZGUpIHtcbiAgICAvKipcbiAgICAgKiAgICAgMTIzPHBcbiAgICAgKiAgICAgICAgXl5cbiAgICAgKiAgICAgPlxuICAgICAqL1xuICAgIHJldHVybiBub2RlLm5leHQgJiYgIWlzVGV4dExpa2VOb2RlJDEobm9kZS5uZXh0KSAmJiBpc1RleHRMaWtlTm9kZSQxKG5vZGUpICYmIG5vZGUuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlICYmICFub2RlLmhhc1RyYWlsaW5nU3BhY2VzO1xuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNUb0JvcnJvd1BhcmVudE9wZW5pbmdUYWdFbmRNYXJrZXIobm9kZSkge1xuICAgIC8qKlxuICAgICAqICAgICA8cFxuICAgICAqICAgICAgID4xMjNcbiAgICAgKiAgICAgICBeXG4gICAgICpcbiAgICAgKiAgICAgPHBcbiAgICAgKiAgICAgICA+PGFcbiAgICAgKiAgICAgICBeXG4gICAgICovXG4gICAgcmV0dXJuICFub2RlLnByZXYgJiYgbm9kZS5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZSAmJiAhbm9kZS5oYXNMZWFkaW5nU3BhY2VzO1xuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNUb0JvcnJvd1ByZXZDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUpIHtcbiAgICAvKipcbiAgICAgKiAgICAgPHA+PC9wXG4gICAgICogICAgID4xMjNcbiAgICAgKiAgICAgXlxuICAgICAqXG4gICAgICogICAgIDxwPjwvcFxuICAgICAqICAgICA+PGFcbiAgICAgKiAgICAgXlxuICAgICAqL1xuICAgIHJldHVybiBub2RlLnByZXYgJiYgIWlzVGV4dExpa2VOb2RlJDEobm9kZS5wcmV2KSAmJiBub2RlLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlICYmICFub2RlLmhhc0xlYWRpbmdTcGFjZXM7XG4gIH1cblxuICBmdW5jdGlvbiBuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlKSB7XG4gICAgLyoqXG4gICAgICogICAgIDxwXG4gICAgICogICAgICAgPjxhPjwvYVxuICAgICAqICAgICAgID48L3BcbiAgICAgKiAgICAgICBeXG4gICAgICogICAgID5cbiAgICAgKi9cbiAgICByZXR1cm4gbm9kZS5sYXN0Q2hpbGQgJiYgbm9kZS5sYXN0Q2hpbGQuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlICYmICFub2RlLmxhc3RDaGlsZC5oYXNUcmFpbGluZ1NwYWNlcyAmJiAhaXNUZXh0TGlrZU5vZGUkMShnZXRMYXN0RGVzY2VuZGFudCQxKG5vZGUubGFzdENoaWxkKSk7XG4gIH1cblxuICBmdW5jdGlvbiBuZWVkc1RvQm9ycm93UGFyZW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyKG5vZGUpIHtcbiAgICAvKipcbiAgICAgKiAgICAgPHA+XG4gICAgICogICAgICAgMTIzPC9wXG4gICAgICogICAgICAgICAgXl5eXG4gICAgICogICAgID5cbiAgICAgKlxuICAgICAqICAgICAgICAgMTIzPC9iXG4gICAgICogICAgICAgPjwvYVxuICAgICAqICAgICAgICBeXl5cbiAgICAgKiAgICAgPlxuICAgICAqL1xuICAgIHJldHVybiAhbm9kZS5uZXh0ICYmICFub2RlLmhhc1RyYWlsaW5nU3BhY2VzICYmIG5vZGUuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlICYmIGlzVGV4dExpa2VOb2RlJDEoZ2V0TGFzdERlc2NlbmRhbnQkMShub2RlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludE9wZW5pbmdUYWdQcmVmaXgobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZWVkc1RvQm9ycm93UGFyZW50T3BlbmluZ1RhZ0VuZE1hcmtlcihub2RlKSA/IHByaW50T3BlbmluZ1RhZ0VuZE1hcmtlcihub2RlLnBhcmVudCkgOiBuZWVkc1RvQm9ycm93UHJldkNsb3NpbmdUYWdFbmRNYXJrZXIobm9kZSkgPyBwcmludENsb3NpbmdUYWdFbmRNYXJrZXIobm9kZS5wcmV2LCBvcHRpb25zKSA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENsb3NpbmdUYWdQcmVmaXgobm9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlKSA/IHByaW50Q2xvc2luZ1RhZ0VuZE1hcmtlcihub2RlLmxhc3RDaGlsZCwgb3B0aW9ucykgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDbG9zaW5nVGFnU3VmZml4KG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmVlZHNUb0JvcnJvd1BhcmVudENsb3NpbmdUYWdTdGFydE1hcmtlcihub2RlKSA/IHByaW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyKG5vZGUucGFyZW50LCBvcHRpb25zKSA6IG5lZWRzVG9Cb3Jyb3dOZXh0T3BlbmluZ1RhZ1N0YXJ0TWFya2VyKG5vZGUpID8gcHJpbnRPcGVuaW5nVGFnU3RhcnRNYXJrZXIobm9kZS5uZXh0KSA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludE9wZW5pbmdUYWdTdGFydE1hcmtlcihub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJpZUNvbmRpdGlvbmFsQ29tbWVudFwiOlxuICAgICAgY2FzZSBcImllQ29uZGl0aW9uYWxTdGFydENvbW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIFwiPCEtLVtpZiBcIi5jb25jYXQobm9kZS5jb25kaXRpb24pO1xuXG4gICAgICBjYXNlIFwiaWVDb25kaXRpb25hbEVuZENvbW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIFwiPCEtLTwhXCI7XG5cbiAgICAgIGNhc2UgXCJpbnRlcnBvbGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBcInt7XCI7XG5cbiAgICAgIGNhc2UgXCJkb2NUeXBlXCI6XG4gICAgICAgIHJldHVybiBcIjwhRE9DVFlQRVwiO1xuXG4gICAgICBjYXNlIFwiZWxlbWVudFwiOlxuICAgICAgICBpZiAobm9kZS5jb25kaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCI8IS0tW2lmIFwiLmNvbmNhdChub2RlLmNvbmRpdGlvbiwgXCJdPjwhLS0+PFwiKS5jb25jYXQobm9kZS5yYXdOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBmYWxsIHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiPFwiLmNvbmNhdChub2RlLnJhd05hbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50T3BlbmluZ1RhZ0VuZE1hcmtlcihub2RlKSB7XG4gICAgYXNzZXJ0KCFub2RlLmlzU2VsZkNsb3NpbmcpO1xuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJpZUNvbmRpdGlvbmFsQ29tbWVudFwiOlxuICAgICAgICByZXR1cm4gXCJdPlwiO1xuXG4gICAgICBjYXNlIFwiZWxlbWVudFwiOlxuICAgICAgICBpZiAobm9kZS5jb25kaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gXCI+PCEtLTwhW2VuZGlmXS0tPlwiO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGwgdGhyb3VnaFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCI+XCI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXIobm9kZSwgb3B0aW9ucykge1xuICAgIGFzc2VydCghbm9kZS5pc1NlbGZDbG9zaW5nKTtcblxuICAgIGlmIChzaG91bGROb3RQcmludENsb3NpbmdUYWckMShub2RlLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJpZUNvbmRpdGlvbmFsQ29tbWVudFwiOlxuICAgICAgICByZXR1cm4gXCI8IVwiO1xuXG4gICAgICBjYXNlIFwiZWxlbWVudFwiOlxuICAgICAgICBpZiAobm9kZS5oYXNIdG1Db21wb25lbnRDbG9zaW5nVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIFwiPC8vXCI7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbCB0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIjwvXCIuY29uY2F0KG5vZGUucmF3TmFtZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDbG9zaW5nVGFnRW5kTWFya2VyKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoc2hvdWxkTm90UHJpbnRDbG9zaW5nVGFnJDEobm9kZSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiaWVDb25kaXRpb25hbENvbW1lbnRcIjpcbiAgICAgIGNhc2UgXCJpZUNvbmRpdGlvbmFsRW5kQ29tbWVudFwiOlxuICAgICAgICByZXR1cm4gXCJbZW5kaWZdLS0+XCI7XG5cbiAgICAgIGNhc2UgXCJpZUNvbmRpdGlvbmFsU3RhcnRDb21tZW50XCI6XG4gICAgICAgIHJldHVybiBcIl0+PCEtLT5cIjtcblxuICAgICAgY2FzZSBcImludGVycG9sYXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwifX1cIjtcblxuICAgICAgY2FzZSBcImVsZW1lbnRcIjpcbiAgICAgICAgaWYgKG5vZGUuaXNTZWxmQ2xvc2luZykge1xuICAgICAgICAgIHJldHVybiBcIi8+XCI7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbCB0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIj5cIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUZXh0VmFsdWVQYXJ0cyhub2RlLCB2YWx1ZSA9IG5vZGUudmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnQuaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlID8gbm9kZS5wYXJlbnQuaXNJbmRlbnRhdGlvblNlbnNpdGl2ZSA/IHJlcGxhY2VFbmRPZkxpbmVXaXRoJDEodmFsdWUsIGxpdGVyYWxsaW5lJDIpIDogcmVwbGFjZUVuZE9mTGluZVdpdGgkMShkZWRlbnRTdHJpbmckMSh2YWx1ZS5yZXBsYWNlKC9eXFxzKj9cXG58XFxuXFxzKj8kL2csIFwiXCIpKSwgaGFyZGxpbmUkNykgOiAvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktd2hpdGVzcGFjZVxuICAgIGpvaW4kNihsaW5lJDYsIHZhbHVlLnNwbGl0KC9bXFx0XFxuXFxmXFxyIF0rLykpLnBhcnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRFbWJlZGRlZEF0dHJpYnV0ZVZhbHVlKG5vZGUsIG9yaWdpbmFsVGV4dFRvRG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaXNLZXlNYXRjaGVkID0gcGF0dGVybnMgPT4gbmV3IFJlZ0V4cChwYXR0ZXJucy5qb2luKFwifFwiKSkudGVzdChub2RlLmZ1bGxOYW1lKTtcblxuICAgIGNvbnN0IGdldFZhbHVlID0gKCkgPT4gdW5lc2NhcGVRdW90ZUVudGl0aWVzJDEobm9kZS52YWx1ZSk7XG5cbiAgICBsZXQgc2hvdWxkSHVnID0gZmFsc2U7XG5cbiAgICBjb25zdCBfX29uSHRtbEJpbmRpbmdSb290ID0gKHJvb3QsIG9wdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHJvb3ROb2RlID0gcm9vdC50eXBlID09PSBcIk5HUm9vdFwiID8gcm9vdC5ub2RlLnR5cGUgPT09IFwiTkdNaWNyb3N5bnRheFwiICYmIHJvb3Qubm9kZS5ib2R5Lmxlbmd0aCA9PT0gMSAmJiByb290Lm5vZGUuYm9keVswXS50eXBlID09PSBcIk5HTWljcm9zeW50YXhFeHByZXNzaW9uXCIgPyByb290Lm5vZGUuYm9keVswXS5leHByZXNzaW9uIDogcm9vdC5ub2RlIDogcm9vdC50eXBlID09PSBcIkpzRXhwcmVzc2lvblJvb3RcIiA/IHJvb3Qubm9kZSA6IHJvb3Q7XG5cbiAgICAgIGlmIChyb290Tm9kZSAmJiAocm9vdE5vZGUudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIgfHwgcm9vdE5vZGUudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIiB8fCBvcHRpb25zLnBhcnNlciA9PT0gXCJfX3Z1ZV9leHByZXNzaW9uXCIgJiYgKHJvb3ROb2RlLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgfHwgcm9vdE5vZGUudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIpKSkge1xuICAgICAgICBzaG91bGRIdWcgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBwcmludEh1ZyA9IGRvYyA9PiBncm91cCQ5KGRvYyk7XG5cbiAgICBjb25zdCBwcmludEV4cGFuZCA9IChkb2MsIGNhbkhhdmVUcmFpbGluZ1doaXRlc3BhY2UgPSB0cnVlKSA9PiBncm91cCQ5KGNvbmNhdCRhKFtpbmRlbnQkNShjb25jYXQkYShbc29mdGxpbmUkNCwgZG9jXSkpLCBjYW5IYXZlVHJhaWxpbmdXaGl0ZXNwYWNlID8gc29mdGxpbmUkNCA6IFwiXCJdKSk7XG5cbiAgICBjb25zdCBwcmludE1heWJlSHVnID0gZG9jID0+IHNob3VsZEh1ZyA/IHByaW50SHVnKGRvYykgOiBwcmludEV4cGFuZChkb2MpO1xuXG4gICAgY29uc3QgdGV4dFRvRG9jID0gKGNvZGUsIG9wdHMpID0+IG9yaWdpbmFsVGV4dFRvRG9jKGNvZGUsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgX19vbkh0bWxCaW5kaW5nUm9vdFxuICAgIH0sIG9wdHMpKTtcblxuICAgIGlmIChub2RlLmZ1bGxOYW1lID09PSBcInNyY3NldFwiICYmIChub2RlLnBhcmVudC5mdWxsTmFtZSA9PT0gXCJpbWdcIiB8fCBub2RlLnBhcmVudC5mdWxsTmFtZSA9PT0gXCJzb3VyY2VcIikpIHtcbiAgICAgIHJldHVybiBwcmludEV4cGFuZChwcmludEltZ1NyY3NldCQxKGdldFZhbHVlKCkpKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5mdWxsTmFtZSA9PT0gXCJjbGFzc1wiICYmICFvcHRpb25zLnBhcmVudFBhcnNlcikge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAoIXZhbHVlLmluY2x1ZGVzKFwie3tcIikpIHtcbiAgICAgICAgcmV0dXJuIHByaW50Q2xhc3NOYW1lcyQxKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9kZS5mdWxsTmFtZSA9PT0gXCJzdHlsZVwiICYmICFvcHRpb25zLnBhcmVudFBhcnNlcikge1xuICAgICAgY29uc3QgdmFsdWUgPSBnZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAoIXZhbHVlLmluY2x1ZGVzKFwie3tcIikpIHtcbiAgICAgICAgcmV0dXJuIHByaW50RXhwYW5kKHRleHRUb0RvYyh2YWx1ZSwge1xuICAgICAgICAgIHBhcnNlcjogXCJjc3NcIixcbiAgICAgICAgICBfX2lzSFRNTFN0eWxlQXR0cmlidXRlOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wYXJzZXIgPT09IFwidnVlXCIpIHtcbiAgICAgIGlmIChub2RlLmZ1bGxOYW1lID09PSBcInYtZm9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHByaW50VnVlRm9yJDEoZ2V0VmFsdWUoKSwgdGV4dFRvRG9jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuZnVsbE5hbWUgPT09IFwic2xvdC1zY29wZVwiKSB7XG4gICAgICAgIHJldHVybiBwcmludFZ1ZVNsb3RTY29wZSQxKGdldFZhbHVlKCksIHRleHRUb0RvYyk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqICAgICBAY2xpY2s9XCJqc1N0YXRlbWVudFwiXG4gICAgICAgKiAgICAgQGNsaWNrPVwianNFeHByZXNzaW9uXCJcbiAgICAgICAqICAgICB2LW9uOmNsaWNrPVwianNTdGF0ZW1lbnRcIlxuICAgICAgICogICAgIHYtb246Y2xpY2s9XCJqc0V4cHJlc3Npb25cIlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgdnVlRXZlbnRCaW5kaW5nUGF0dGVybnMgPSBbXCJeQFwiLCBcIl52LW9uOlwiXTtcbiAgICAgIC8qKlxuICAgICAgICogICAgIDpjbGFzcz1cInZ1ZUV4cHJlc3Npb25cIlxuICAgICAgICogICAgIHYtYmluZDppZD1cInZ1ZUV4cHJlc3Npb25cIlxuICAgICAgICovXG5cbiAgICAgIGNvbnN0IHZ1ZUV4cHJlc3Npb25CaW5kaW5nUGF0dGVybnMgPSBbXCJeOlwiLCBcIl52LWJpbmQ6XCJdO1xuICAgICAgLyoqXG4gICAgICAgKiAgICAgdi1pZj1cImpzRXhwcmVzc2lvblwiXG4gICAgICAgKi9cblxuICAgICAgY29uc3QganNFeHByZXNzaW9uQmluZGluZ1BhdHRlcm5zID0gW1wiXnYtXCJdO1xuXG4gICAgICBpZiAoaXNLZXlNYXRjaGVkKHZ1ZUV2ZW50QmluZGluZ1BhdHRlcm5zKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKCk7XG4gICAgICAgIHJldHVybiBwcmludE1heWJlSHVnKGlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbiQxKHZhbHVlKSA/IHRleHRUb0RvYyh2YWx1ZSwge1xuICAgICAgICAgIHBhcnNlcjogXCJfX2pzX2V4cHJlc3Npb25cIlxuICAgICAgICB9KSA6IHN0cmlwVHJhaWxpbmdIYXJkbGluZSQxKHRleHRUb0RvYyh2YWx1ZSwge1xuICAgICAgICAgIHBhcnNlcjogXCJfX3Z1ZV9ldmVudF9iaW5kaW5nXCJcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzS2V5TWF0Y2hlZCh2dWVFeHByZXNzaW9uQmluZGluZ1BhdHRlcm5zKSkge1xuICAgICAgICByZXR1cm4gcHJpbnRNYXliZUh1Zyh0ZXh0VG9Eb2MoZ2V0VmFsdWUoKSwge1xuICAgICAgICAgIHBhcnNlcjogXCJfX3Z1ZV9leHByZXNzaW9uXCJcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNLZXlNYXRjaGVkKGpzRXhwcmVzc2lvbkJpbmRpbmdQYXR0ZXJucykpIHtcbiAgICAgICAgcmV0dXJuIHByaW50TWF5YmVIdWcodGV4dFRvRG9jKGdldFZhbHVlKCksIHtcbiAgICAgICAgICBwYXJzZXI6IFwiX19qc19leHByZXNzaW9uXCJcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBhcnNlciA9PT0gXCJhbmd1bGFyXCIpIHtcbiAgICAgIGNvbnN0IG5nVGV4dFRvRG9jID0gKGNvZGUsIG9wdHMpID0+IC8vIGFuZ3VsYXIgZG9lcyBub3QgYWxsb3cgdHJhaWxpbmcgY29tbWFcbiAgICAgIHRleHRUb0RvYyhjb2RlLCBPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICAgIHRyYWlsaW5nQ29tbWE6IFwibm9uZVwiXG4gICAgICB9KSk7XG4gICAgICAvKipcbiAgICAgICAqICAgICAqZGlyZWN0aXZlPVwiYW5ndWxhckRpcmVjdGl2ZVwiXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBuZ0RpcmVjdGl2ZUJpbmRpbmdQYXR0ZXJucyA9IFtcIl5cXFxcKlwiXTtcbiAgICAgIC8qKlxuICAgICAgICogICAgIChjbGljayk9XCJhbmd1bGFyU3RhdGVtZW50XCJcbiAgICAgICAqICAgICBvbi1jbGljaz1cImFuZ3VsYXJTdGF0ZW1lbnRcIlxuICAgICAgICovXG5cbiAgICAgIGNvbnN0IG5nU3RhdGVtZW50QmluZGluZ1BhdHRlcm5zID0gW1wiXlxcXFwoLitcXFxcKSRcIiwgXCJeb24tXCJdO1xuICAgICAgLyoqXG4gICAgICAgKiAgICAgW3RhcmdldF09XCJhbmd1bGFyRXhwcmVzc2lvblwiXG4gICAgICAgKiAgICAgYmluZC10YXJnZXQ9XCJhbmd1bGFyRXhwcmVzc2lvblwiXG4gICAgICAgKiAgICAgWyh0YXJnZXQpXT1cImFuZ3VsYXJFeHByZXNzaW9uXCJcbiAgICAgICAqICAgICBiaW5kb24tdGFyZ2V0PVwiYW5ndWxhckV4cHJlc3Npb25cIlxuICAgICAgICovXG5cbiAgICAgIGNvbnN0IG5nRXhwcmVzc2lvbkJpbmRpbmdQYXR0ZXJucyA9IFtcIl5cXFxcWy4rXFxcXF0kXCIsIFwiXmJpbmQob24pPy1cIiwgLy8gVW5vZmZpY2lhbCBydWRpbWVudGFyeSBzdXBwb3J0IGZvciBzb21lIG9mIHRoZSBtb3N0IHVzZWQgZGlyZWN0aXZlcyBvZiBBbmd1bGFySlMgMS54XG4gICAgICBcIl5uZy0oaWZ8c2hvd3xoaWRlfGNsYXNzfHN0eWxlKSRcIl07XG4gICAgICAvKipcbiAgICAgICAqICAgICBpMThuPVwibG9uZ0Rlc2NyaXB0aW9uXCJcbiAgICAgICAqICAgICBpMThuLWF0dHI9XCJsb25nRGVzY3JpcHRpb25cIlxuICAgICAgICovXG5cbiAgICAgIGNvbnN0IG5nSTE4blBhdHRlcm5zID0gW1wiXmkxOG4oLS4rKT8kXCJdO1xuXG4gICAgICBpZiAoaXNLZXlNYXRjaGVkKG5nU3RhdGVtZW50QmluZGluZ1BhdHRlcm5zKSkge1xuICAgICAgICByZXR1cm4gcHJpbnRNYXliZUh1ZyhuZ1RleHRUb0RvYyhnZXRWYWx1ZSgpLCB7XG4gICAgICAgICAgcGFyc2VyOiBcIl9fbmdfYWN0aW9uXCJcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNLZXlNYXRjaGVkKG5nRXhwcmVzc2lvbkJpbmRpbmdQYXR0ZXJucykpIHtcbiAgICAgICAgcmV0dXJuIHByaW50TWF5YmVIdWcobmdUZXh0VG9Eb2MoZ2V0VmFsdWUoKSwge1xuICAgICAgICAgIHBhcnNlcjogXCJfX25nX2JpbmRpbmdcIlxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0tleU1hdGNoZWQobmdJMThuUGF0dGVybnMpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VmFsdWUoKS50cmltKCk7XG4gICAgICAgIHJldHVybiBwcmludEV4cGFuZChmaWxsJDMoZ2V0VGV4dFZhbHVlUGFydHMobm9kZSwgdmFsdWUpKSwgIXZhbHVlLmluY2x1ZGVzKFwiQEBcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNLZXlNYXRjaGVkKG5nRGlyZWN0aXZlQmluZGluZ1BhdHRlcm5zKSkge1xuICAgICAgICByZXR1cm4gcHJpbnRNYXliZUh1ZyhuZ1RleHRUb0RvYyhnZXRWYWx1ZSgpLCB7XG4gICAgICAgICAgcGFyc2VyOiBcIl9fbmdfZGlyZWN0aXZlXCJcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnRlcnBvbGF0aW9uUmVnZXggPSAvXFx7XFx7KFtcXHNcXFNdKz8pXFx9XFx9L2c7XG4gICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKCk7XG5cbiAgICAgIGlmIChpbnRlcnBvbGF0aW9uUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgdmFsdWUuc3BsaXQoaW50ZXJwb2xhdGlvblJlZ2V4KS5mb3JFYWNoKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goY29uY2F0JGEocmVwbGFjZUVuZE9mTGluZVdpdGgkMShwYXJ0LCBsaXRlcmFsbGluZSQyKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJDkoY29uY2F0JGEoW1wie3tcIiwgaW5kZW50JDUoY29uY2F0JGEoW2xpbmUkNiwgbmdUZXh0VG9Eb2MocGFydCwge1xuICAgICAgICAgICAgICAgIHBhcnNlcjogXCJfX25nX2ludGVycG9sYXRpb25cIixcbiAgICAgICAgICAgICAgICBfX2lzSW5IdG1sSW50ZXJwb2xhdGlvbjogdHJ1ZSAvLyB0byBhdm9pZCB1bmV4cGVjdGVkIGB9fWBcblxuICAgICAgICAgICAgICB9KV0pKSwgbGluZSQ2LCBcIn19XCJdKSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwie3tcIiwgY29uY2F0JGEocmVwbGFjZUVuZE9mTGluZVdpdGgkMShwYXJ0LCBsaXRlcmFsbGluZSQyKSksIFwifX1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyb3VwJDkoY29uY2F0JGEocGFydHMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcmludGVySHRtbCA9IHtcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzXzEsXG4gICAgcHJpbnQ6IGdlbmVyaWNQcmludCQyLFxuICAgIGluc2VydFByYWdtYTogaW5zZXJ0UHJhZ21hJDYsXG4gICAgbWFzc2FnZUFzdE5vZGU6IGNsZWFuJDMsXG4gICAgZW1iZWQ6IGVtYmVkJDJcbiAgfTtcblxuICBjb25zdCBDQVRFR09SWV9IVE1MID0gXCJIVE1MXCI7IC8vIGZvcm1hdCBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vcHJldHRpZXIvcHJldHRpZXIvYmxvYi9tYXN0ZXIvc3JjL21haW4vY29yZS1vcHRpb25zLmpzXG5cbiAgdmFyIG9wdGlvbnMkNCA9IHtcbiAgICBodG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5OiB7XG4gICAgICBzaW5jZTogXCIxLjE1LjBcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9IVE1MLFxuICAgICAgdHlwZTogXCJjaG9pY2VcIixcbiAgICAgIGRlZmF1bHQ6IFwiY3NzXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJIb3cgdG8gaGFuZGxlIHdoaXRlc3BhY2VzIGluIEhUTUwuXCIsXG4gICAgICBjaG9pY2VzOiBbe1xuICAgICAgICB2YWx1ZTogXCJjc3NcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUmVzcGVjdCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBDU1MgZGlzcGxheSBwcm9wZXJ0eS5cIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJzdHJpY3RcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiV2hpdGVzcGFjZXMgYXJlIGNvbnNpZGVyZWQgc2Vuc2l0aXZlLlwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImlnbm9yZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJXaGl0ZXNwYWNlcyBhcmUgY29uc2lkZXJlZCBpbnNlbnNpdGl2ZS5cIlxuICAgICAgfV1cbiAgICB9LFxuICAgIHZ1ZUluZGVudFNjcmlwdEFuZFN0eWxlOiB7XG4gICAgICBzaW5jZTogXCIxLjE5LjBcIixcbiAgICAgIGNhdGVnb3J5OiBDQVRFR09SWV9IVE1MLFxuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkluZGVudCBzY3JpcHQgYW5kIHN0eWxlIHRhZ3MgaW4gVnVlIGZpbGVzLlwiXG4gICAgfVxuICB9O1xuXG4gIHZhciBuYW1lJDcgPSBcIkhUTUxcIjtcbiAgdmFyIHR5cGUkNiA9IFwibWFya3VwXCI7XG4gIHZhciB0bVNjb3BlJDYgPSBcInRleHQuaHRtbC5iYXNpY1wiO1xuICB2YXIgYWNlTW9kZSQ2ID0gXCJodG1sXCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSQzID0gXCJodG1sbWl4ZWRcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSQzID0gXCJ0ZXh0L2h0bWxcIjtcbiAgdmFyIGNvbG9yJDEgPSBcIiNlMzRjMjZcIjtcbiAgdmFyIGFsaWFzZXMkMSA9IFtcbiAgXHRcInhodG1sXCJcbiAgXTtcbiAgdmFyIGV4dGVuc2lvbnMkNiA9IFtcbiAgXHRcIi5odG1sXCIsXG4gIFx0XCIuaHRtXCIsXG4gIFx0XCIuaHRtbC5obFwiLFxuICBcdFwiLmluY1wiLFxuICBcdFwiLnN0XCIsXG4gIFx0XCIueGh0XCIsXG4gIFx0XCIueGh0bWxcIlxuICBdO1xuICB2YXIgbGFuZ3VhZ2VJZCQ2ID0gMTQ2O1xuICB2YXIgSFRNTCA9IHtcbiAgXHRuYW1lOiBuYW1lJDcsXG4gIFx0dHlwZTogdHlwZSQ2LFxuICBcdHRtU2NvcGU6IHRtU2NvcGUkNixcbiAgXHRhY2VNb2RlOiBhY2VNb2RlJDYsXG4gIFx0Y29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDMsXG4gIFx0Y29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkMyxcbiAgXHRjb2xvcjogY29sb3IkMSxcbiAgXHRhbGlhc2VzOiBhbGlhc2VzJDEsXG4gIFx0ZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ2LFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkNlxuICB9O1xuXG4gIHZhciBIVE1MJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkNyxcbiAgICB0eXBlOiB0eXBlJDYsXG4gICAgdG1TY29wZTogdG1TY29wZSQ2LFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkNixcbiAgICBjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkMyxcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQzLFxuICAgIGNvbG9yOiBjb2xvciQxLFxuICAgIGFsaWFzZXM6IGFsaWFzZXMkMSxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJDYsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQ2LFxuICAgICdkZWZhdWx0JzogSFRNTFxuICB9KTtcblxuICB2YXIgbmFtZSQ4ID0gXCJWdWVcIjtcbiAgdmFyIHR5cGUkNyA9IFwibWFya3VwXCI7XG4gIHZhciBjb2xvciQyID0gXCIjMmMzZTUwXCI7XG4gIHZhciBleHRlbnNpb25zJDcgPSBbXG4gIFx0XCIudnVlXCJcbiAgXTtcbiAgdmFyIHRtU2NvcGUkNyA9IFwidGV4dC5odG1sLnZ1ZVwiO1xuICB2YXIgYWNlTW9kZSQ3ID0gXCJodG1sXCI7XG4gIHZhciBsYW5ndWFnZUlkJDcgPSAzOTE7XG4gIHZhciBWdWUgPSB7XG4gIFx0bmFtZTogbmFtZSQ4LFxuICBcdHR5cGU6IHR5cGUkNyxcbiAgXHRjb2xvcjogY29sb3IkMixcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJDcsXG4gIFx0dG1TY29wZTogdG1TY29wZSQ3LFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkNyxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDdcbiAgfTtcblxuICB2YXIgVnVlJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkOCxcbiAgICB0eXBlOiB0eXBlJDcsXG4gICAgY29sb3I6IGNvbG9yJDIsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ3LFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkNyxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDcsXG4gICAgbGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCQ3LFxuICAgICdkZWZhdWx0JzogVnVlXG4gIH0pO1xuXG4gIHZhciByZXF1aXJlJCQwJDUgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKEhUTUwkMSk7XG5cbiAgdmFyIHJlcXVpcmUkJDEkMSA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoVnVlJDEpO1xuXG4gIGNvbnN0IGxhbmd1YWdlcyQzID0gW2NyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDAkNSwgKCkgPT4gKHtcbiAgICBuYW1lOiBcIkFuZ3VsYXJcIixcbiAgICBzaW5jZTogXCIxLjE1LjBcIixcbiAgICBwYXJzZXJzOiBbXCJhbmd1bGFyXCJdLFxuICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJodG1sXCJdLFxuICAgIGV4dGVuc2lvbnM6IFtcIi5jb21wb25lbnQuaHRtbFwiXSxcbiAgICBmaWxlbmFtZXM6IFtdXG4gIH0pKSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMCQ1LCBkYXRhID0+ICh7XG4gICAgc2luY2U6IFwiMS4xNS4wXCIsXG4gICAgcGFyc2VyczogW1wiaHRtbFwiXSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wiaHRtbFwiXSxcbiAgICBleHRlbnNpb25zOiBkYXRhLmV4dGVuc2lvbnMuY29uY2F0KFtcIi5tam1sXCIgLy8gTUpNTCBpcyBjb25zaWRlcmVkIFhNTCBpbiBMaW5ndWlzdCBidXQgaXQgc2hvdWxkIGJlIGZvcm1hdHRlZCBhcyBIVE1MXG4gICAgXSlcbiAgfSkpLCBjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQwJDUsICgpID0+ICh7XG4gICAgbmFtZTogXCJMaWdodG5pbmcgV2ViIENvbXBvbmVudHNcIixcbiAgICBzaW5jZTogXCIxLjE3LjBcIixcbiAgICBwYXJzZXJzOiBbXCJsd2NcIl0sXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImh0bWxcIl0sXG4gICAgZXh0ZW5zaW9uczogW10sXG4gICAgZmlsZW5hbWVzOiBbXVxuICB9KSksIGNyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDEkMSwgKCkgPT4gKHtcbiAgICBzaW5jZTogXCIxLjEwLjBcIixcbiAgICBwYXJzZXJzOiBbXCJ2dWVcIl0sXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcInZ1ZVwiXVxuICB9KSldO1xuICBjb25zdCBwcmludGVycyQzID0ge1xuICAgIGh0bWw6IHByaW50ZXJIdG1sXG4gIH07XG4gIHZhciBsYW5ndWFnZUh0bWwgPSB7XG4gICAgbGFuZ3VhZ2VzOiBsYW5ndWFnZXMkMyxcbiAgICBwcmludGVyczogcHJpbnRlcnMkMyxcbiAgICBvcHRpb25zOiBvcHRpb25zJDRcbiAgfTtcblxuICBjb25zdCB7XG4gICAgYWRkTGVhZGluZ0NvbW1lbnQ6IGFkZExlYWRpbmdDb21tZW50JDMsXG4gICAgYWRkVHJhaWxpbmdDb21tZW50OiBhZGRUcmFpbGluZ0NvbW1lbnQkMyxcbiAgICBhZGREYW5nbGluZ0NvbW1lbnQ6IGFkZERhbmdsaW5nQ29tbWVudCQzLFxuICAgIGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleDogZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4JDJcbiAgfSA9IHV0aWxTaGFyZWQ7XG5cbiAgZnVuY3Rpb24gaGFuZGxlT3duTGluZUNvbW1lbnQoY29tbWVudCwgdGV4dCwgb3B0aW9ucywgYXN0LCBpc0xhc3RDb21tZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJlY2VkaW5nTm9kZSxcbiAgICAgIGVuY2xvc2luZ05vZGUsXG4gICAgICBmb2xsb3dpbmdOb2RlXG4gICAgfSA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIGhhbmRsZUxhc3RGdW5jdGlvbkFyZ0NvbW1lbnRzKHRleHQsIHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZU1lbWJlckV4cHJlc3Npb25Db21tZW50cyhlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVJZlN0YXRlbWVudENvbW1lbnRzKHRleHQsIHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZVdoaWxlQ29tbWVudHModGV4dCwgcHJlY2VkaW5nTm9kZSwgZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykgfHwgaGFuZGxlVHJ5U3RhdGVtZW50Q29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlQ2xhc3NDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVJbXBvcnRTcGVjaWZpZXJDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVGb3JDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVVbmlvblR5cGVDb21tZW50cyhwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVPbmx5Q29tbWVudHMoZW5jbG9zaW5nTm9kZSwgYXN0LCBjb21tZW50LCBpc0xhc3RDb21tZW50KSB8fCBoYW5kbGVJbXBvcnREZWNsYXJhdGlvbkNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZUFzc2lnbm1lbnRQYXR0ZXJuQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlTWV0aG9kTmFtZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZUxhYmVsZWRTdGF0ZW1lbnRDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUVuZE9mTGluZUNvbW1lbnQoY29tbWVudCwgdGV4dCwgb3B0aW9ucywgYXN0LCBpc0xhc3RDb21tZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJlY2VkaW5nTm9kZSxcbiAgICAgIGVuY2xvc2luZ05vZGUsXG4gICAgICBmb2xsb3dpbmdOb2RlXG4gICAgfSA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIGhhbmRsZUNsb3N1cmVUeXBlQ2FzdENvbW1lbnRzKGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZUxhc3RGdW5jdGlvbkFyZ0NvbW1lbnRzKHRleHQsIHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZUNvbmRpdGlvbmFsRXhwcmVzc2lvbkNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIHRleHQsIG9wdGlvbnMpIHx8IGhhbmRsZUltcG9ydFNwZWNpZmllckNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZUlmU3RhdGVtZW50Q29tbWVudHModGV4dCwgcHJlY2VkaW5nTm9kZSwgZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykgfHwgaGFuZGxlV2hpbGVDb21tZW50cyh0ZXh0LCBwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSB8fCBoYW5kbGVUcnlTdGF0ZW1lbnRDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVDbGFzc0NvbW1lbnRzKGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZUxhYmVsZWRTdGF0ZW1lbnRDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVDYWxsRXhwcmVzc2lvbkNvbW1lbnRzKHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZVByb3BlcnR5Q29tbWVudHMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlT25seUNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGFzdCwgY29tbWVudCwgaXNMYXN0Q29tbWVudCkgfHwgaGFuZGxlVHlwZUFsaWFzQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlVmFyaWFibGVEZWNsYXJhdG9yQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZW1haW5pbmdDb21tZW50KGNvbW1lbnQsIHRleHQsIG9wdGlvbnMsIGFzdCwgaXNMYXN0Q29tbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHByZWNlZGluZ05vZGUsXG4gICAgICBlbmNsb3NpbmdOb2RlLFxuICAgICAgZm9sbG93aW5nTm9kZVxuICAgIH0gPSBjb21tZW50O1xuXG4gICAgaWYgKGhhbmRsZUlmU3RhdGVtZW50Q29tbWVudHModGV4dCwgcHJlY2VkaW5nTm9kZSwgZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykgfHwgaGFuZGxlV2hpbGVDb21tZW50cyh0ZXh0LCBwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSB8fCBoYW5kbGVPYmplY3RQcm9wZXJ0eUFzc2lnbm1lbnQoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgY29tbWVudCkgfHwgaGFuZGxlQ29tbWVudEluRW1wdHlQYXJlbnModGV4dCwgZW5jbG9zaW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykgfHwgaGFuZGxlTWV0aG9kTmFtZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZU9ubHlDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBhc3QsIGNvbW1lbnQsIGlzTGFzdENvbW1lbnQpIHx8IGhhbmRsZUNvbW1lbnRBZnRlckFycm93UGFyYW1zKHRleHQsIGVuY2xvc2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZUZ1bmN0aW9uTmFtZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHx8IGhhbmRsZVRTTWFwcGVkVHlwZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpIHx8IGhhbmRsZUJyZWFrQW5kQ29udGludWVTdGF0ZW1lbnRDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB8fCBoYW5kbGVUU0Z1bmN0aW9uVHJhaWxpbmdDb21tZW50cyh0ZXh0LCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQmxvY2tTdGF0ZW1lbnRGaXJzdENvbW1lbnQobm9kZSwgY29tbWVudCkge1xuICAgIGNvbnN0IGJvZHkgPSBub2RlLmJvZHkuZmlsdGVyKG4gPT4gbi50eXBlICE9PSBcIkVtcHR5U3RhdGVtZW50XCIpO1xuXG4gICAgaWYgKGJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMyhub2RlLCBjb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMyhib2R5WzBdLCBjb21tZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRCbG9ja09yTm90Q29tbWVudChub2RlLCBjb21tZW50KSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgICBhZGRCbG9ja1N0YXRlbWVudEZpcnN0Q29tbWVudChub2RlLCBjb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMyhub2RlLCBjb21tZW50KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbG9zdXJlVHlwZUNhc3RDb21tZW50cyhmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGZvbGxvd2luZ05vZGUgJiYgaXNUeXBlQ2FzdENvbW1lbnQoY29tbWVudCkpIHtcbiAgICAgIGFkZExlYWRpbmdDb21tZW50JDMoZm9sbG93aW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGhlcmUgYXJlIG9mdGVuIGNvbW1lbnRzIGJlZm9yZSB0aGUgZWxzZSBjbGF1c2Ugb2YgaWYgc3RhdGVtZW50cyBsaWtlXG4gIC8vXG4gIC8vICAgaWYgKDEpIHsgLi4uIH1cbiAgLy8gICAvLyBjb21tZW50XG4gIC8vICAgZWxzZSB7IC4uLiB9XG4gIC8vXG4gIC8vIFRoZXkgYXJlIGJlaW5nIGF0dGFjaGVkIGFzIGxlYWRpbmcgY29tbWVudHMgb2YgdGhlIEJsb2NrRXhwcmVzc2lvbiB3aGljaFxuICAvLyBpcyBub3Qgd2VsbCBwcmludGVkLiBXaGF0IHdlIHdhbnQgaXMgdG8gaW5zdGVhZCBtb3ZlIHRoZSBjb21tZW50IGluc2lkZVxuICAvLyBvZiB0aGUgYmxvY2sgYW5kIG1ha2UgaXQgbGVhZGluZ0NvbW1lbnQgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGJsb2NrXG4gIC8vIG9yIGRhbmdsaW5nIGNvbW1lbnQgb2YgdGhlIGJsb2NrIGlmIHRoZXJlIGlzIG5vdGhpbmcgaW5zaWRlXG4gIC8vXG4gIC8vICAgaWYgKDEpIHsgLi4uIH1cbiAgLy8gICBlbHNlIHtcbiAgLy8gICAgIC8vIGNvbW1lbnRcbiAgLy8gICAgIC4uLlxuICAvLyAgIH1cblxuXG4gIGZ1bmN0aW9uIGhhbmRsZUlmU3RhdGVtZW50Q29tbWVudHModGV4dCwgcHJlY2VkaW5nTm9kZSwgZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghZW5jbG9zaW5nTm9kZSB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgIT09IFwiSWZTdGF0ZW1lbnRcIiB8fCAhZm9sbG93aW5nTm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gV2UgdW5mb3J0dW5hdGVseSBoYXZlIG5vIHdheSB1c2luZyB0aGUgQVNUIG9yIGxvY2F0aW9uIG9mIG5vZGVzIHRvIGtub3dcbiAgICAvLyBpZiB0aGUgY29tbWVudCBpcyBwb3NpdGlvbmVkIGJlZm9yZSB0aGUgY29uZGl0aW9uIHBhcmVudGhlc2lzOlxuICAgIC8vICAgaWYgKGEgLyogY29tbWVudCAqLykge31cbiAgICAvLyBUaGUgb25seSB3b3JrYXJvdW5kIEkgZm91bmQgaXMgdG8gbG9vayBhdCB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gc2VlIGlmXG4gICAgLy8gaXQgaXMgYSApLlxuXG5cbiAgICBjb25zdCBuZXh0Q2hhcmFjdGVyID0gdXRpbCQxLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIodGV4dCwgY29tbWVudCwgb3B0aW9ucy5sb2NFbmQpO1xuXG4gICAgaWYgKG5leHRDaGFyYWN0ZXIgPT09IFwiKVwiKSB7XG4gICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMyhwcmVjZWRpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gQ29tbWVudHMgYmVmb3JlIGBlbHNlYDpcbiAgICAvLyAtIHRyZWF0IGFzIHRyYWlsaW5nIGNvbW1lbnRzIG9mIHRoZSBjb25zZXF1ZW50LCBpZiBpdCdzIGEgQmxvY2tTdGF0ZW1lbnRcbiAgICAvLyAtIHRyZWF0IGFzIGEgZGFuZ2xpbmcgY29tbWVudCBvdGhlcndpc2VcblxuXG4gICAgaWYgKHByZWNlZGluZ05vZGUgPT09IGVuY2xvc2luZ05vZGUuY29uc2VxdWVudCAmJiBmb2xsb3dpbmdOb2RlID09PSBlbmNsb3NpbmdOb2RlLmFsdGVybmF0ZSkge1xuICAgICAgaWYgKHByZWNlZGluZ05vZGUudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQzKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkRGFuZ2xpbmdDb21tZW50JDMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikge1xuICAgICAgYWRkQmxvY2tTdGF0ZW1lbnRGaXJzdENvbW1lbnQoZm9sbG93aW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZm9sbG93aW5nTm9kZS50eXBlID09PSBcIklmU3RhdGVtZW50XCIpIHtcbiAgICAgIGFkZEJsb2NrT3JOb3RDb21tZW50KGZvbGxvd2luZ05vZGUuY29uc2VxdWVudCwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIEZvciBjb21tZW50cyBwb3NpdGlvbmVkIGFmdGVyIHRoZSBjb25kaXRpb24gcGFyZW50aGVzaXMgaW4gYW4gaWYgc3RhdGVtZW50XG4gICAgLy8gYmVmb3JlIHRoZSBjb25zZXF1ZW50IHdpdGhvdXQgYnJhY2tldHMgb24sIHN1Y2ggYXNcbiAgICAvLyBpZiAoYSkgLyogY29tbWVudCAqLyB0cnVlLFxuICAgIC8vIHdlIGxvb2sgYXQgdGhlIG5leHQgY2hhcmFjdGVyIHRvIHNlZSBpZiB0aGUgZm9sbG93aW5nIG5vZGVcbiAgICAvLyBpcyB0aGUgY29uc2VxdWVudCBmb3IgdGhlIGlmIHN0YXRlbWVudFxuXG5cbiAgICBpZiAoZW5jbG9zaW5nTm9kZS5jb25zZXF1ZW50ID09PSBmb2xsb3dpbmdOb2RlKSB7XG4gICAgICBhZGRMZWFkaW5nQ29tbWVudCQzKGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlV2hpbGVDb21tZW50cyh0ZXh0LCBwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKCFlbmNsb3NpbmdOb2RlIHx8IGVuY2xvc2luZ05vZGUudHlwZSAhPT0gXCJXaGlsZVN0YXRlbWVudFwiIHx8ICFmb2xsb3dpbmdOb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBXZSB1bmZvcnR1bmF0ZWx5IGhhdmUgbm8gd2F5IHVzaW5nIHRoZSBBU1Qgb3IgbG9jYXRpb24gb2Ygbm9kZXMgdG8ga25vd1xuICAgIC8vIGlmIHRoZSBjb21tZW50IGlzIHBvc2l0aW9uZWQgYmVmb3JlIHRoZSBjb25kaXRpb24gcGFyZW50aGVzaXM6XG4gICAgLy8gICB3aGlsZSAoYSAvKiBjb21tZW50ICovKSB7fVxuICAgIC8vIFRoZSBvbmx5IHdvcmthcm91bmQgSSBmb3VuZCBpcyB0byBsb29rIGF0IHRoZSBuZXh0IGNoYXJhY3RlciB0byBzZWUgaWZcbiAgICAvLyBpdCBpcyBhICkuXG5cblxuICAgIGNvbnN0IG5leHRDaGFyYWN0ZXIgPSB1dGlsJDEuZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3Rlcih0ZXh0LCBjb21tZW50LCBvcHRpb25zLmxvY0VuZCk7XG5cbiAgICBpZiAobmV4dENoYXJhY3RlciA9PT0gXCIpXCIpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQzKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZvbGxvd2luZ05vZGUudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgICBhZGRCbG9ja1N0YXRlbWVudEZpcnN0Q29tbWVudChmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBTYW1lIGFzIElmU3RhdGVtZW50IGJ1dCBmb3IgVHJ5U3RhdGVtZW50XG5cblxuICBmdW5jdGlvbiBoYW5kbGVUcnlTdGF0ZW1lbnRDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKCFlbmNsb3NpbmdOb2RlIHx8IGVuY2xvc2luZ05vZGUudHlwZSAhPT0gXCJUcnlTdGF0ZW1lbnRcIiAmJiBlbmNsb3NpbmdOb2RlLnR5cGUgIT09IFwiQ2F0Y2hDbGF1c2VcIiB8fCAhZm9sbG93aW5nTm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2F0Y2hDbGF1c2VcIiAmJiBwcmVjZWRpbmdOb2RlKSB7XG4gICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMyhwcmVjZWRpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikge1xuICAgICAgYWRkQmxvY2tTdGF0ZW1lbnRGaXJzdENvbW1lbnQoZm9sbG93aW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZm9sbG93aW5nTm9kZS50eXBlID09PSBcIlRyeVN0YXRlbWVudFwiKSB7XG4gICAgICBhZGRCbG9ja09yTm90Q29tbWVudChmb2xsb3dpbmdOb2RlLmZpbmFsaXplciwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZm9sbG93aW5nTm9kZS50eXBlID09PSBcIkNhdGNoQ2xhdXNlXCIpIHtcbiAgICAgIGFkZEJsb2NrT3JOb3RDb21tZW50KGZvbGxvd2luZ05vZGUuYm9keSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNZW1iZXJFeHByZXNzaW9uQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikgJiYgZm9sbG93aW5nTm9kZSAmJiBmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBhZGRMZWFkaW5nQ29tbWVudCQzKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29uZGl0aW9uYWxFeHByZXNzaW9uQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCwgdGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGlzU2FtZUxpbmVBc1ByZWNlZGluZ05vZGUgPSBwcmVjZWRpbmdOb2RlICYmICF1dGlsJDEuaGFzTmV3bGluZUluUmFuZ2UodGV4dCwgb3B0aW9ucy5sb2NFbmQocHJlY2VkaW5nTm9kZSksIG9wdGlvbnMubG9jU3RhcnQoY29tbWVudCkpO1xuXG4gICAgaWYgKCghcHJlY2VkaW5nTm9kZSB8fCAhaXNTYW1lTGluZUFzUHJlY2VkaW5nTm9kZSkgJiYgZW5jbG9zaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgJiYgZm9sbG93aW5nTm9kZSkge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMyhmb2xsb3dpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9iamVjdFByb3BlcnR5QXNzaWdubWVudChlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgKGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiKSAmJiBlbmNsb3NpbmdOb2RlLnNob3J0aGFuZCAmJiBlbmNsb3NpbmdOb2RlLmtleSA9PT0gcHJlY2VkaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLnZhbHVlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikge1xuICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDMoZW5jbG9zaW5nTm9kZS52YWx1ZS5sZWZ0LCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsYXNzQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikgJiYgZW5jbG9zaW5nTm9kZS5kZWNvcmF0b3JzICYmIGVuY2xvc2luZ05vZGUuZGVjb3JhdG9ycy5sZW5ndGggPiAwICYmICEoZm9sbG93aW5nTm9kZSAmJiBmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiRGVjb3JhdG9yXCIpKSB7XG4gICAgICBpZiAoIWVuY2xvc2luZ05vZGUuZGVjb3JhdG9ycyB8fCBlbmNsb3NpbmdOb2RlLmRlY29yYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFkZExlYWRpbmdDb21tZW50JDMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMyhlbmNsb3NpbmdOb2RlLmRlY29yYXRvcnNbZW5jbG9zaW5nTm9kZS5kZWNvcmF0b3JzLmxlbmd0aCAtIDFdLCBjb21tZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWV0aG9kTmFtZUNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGlzIGlzIG9ubHkgbmVlZGVkIGZvciBlc3RyZWUgcGFyc2VycyAoZmxvdywgdHlwZXNjcmlwdCkgdG8gYXR0YWNoXG4gICAgLy8gYWZ0ZXIgYSBtZXRob2QgbmFtZTpcbiAgICAvLyBvYmogPSB7IGZuIC8qY29tbWVudCovKCkge30gfTtcbiAgICBpZiAoZW5jbG9zaW5nTm9kZSAmJiBwcmVjZWRpbmdOb2RlICYmICggLy8gXCJNZXRob2REZWZpbml0aW9uXCIgaXMgaGFuZGxlZCBpbiBnZXRDb21tZW50Q2hpbGROb2Rlc1xuICAgIGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJUU0RlY2xhcmVNZXRob2RcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiVFNBYnN0cmFjdE1ldGhvZERlZmluaXRpb25cIikgJiYgcHJlY2VkaW5nTm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBlbmNsb3NpbmdOb2RlLmtleSA9PT0gcHJlY2VkaW5nTm9kZSAmJiAvLyBzcGVjaWFsIFByb3BlcnR5IGNhc2U6IHsga2V5OiAvKmNvbW1lbnQqLyh2YWx1ZSkgfTtcbiAgICAvLyBjb21tZW50IHNob3VsZCBiZSBhdHRhY2hlZCB0byB2YWx1ZSBpbnN0ZWFkIG9mIGtleVxuICAgIHV0aWwkMS5nZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVyKHRleHQsIHByZWNlZGluZ05vZGUsIG9wdGlvbnMubG9jRW5kKSAhPT0gXCI6XCIpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQzKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBQcmludCBjb21tZW50cyBiZXR3ZWVuIGRlY29yYXRvcnMgYW5kIGNsYXNzIG1ldGhvZHMgYXMgYSB0cmFpbGluZyBjb21tZW50XG4gICAgLy8gb24gdGhlIGRlY29yYXRvciBub2RlIGluc3RlYWQgb2YgdGhlIG1ldGhvZCBub2RlXG5cblxuICAgIGlmIChwcmVjZWRpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUgJiYgcHJlY2VkaW5nTm9kZS50eXBlID09PSBcIkRlY29yYXRvclwiICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NQcm9wZXJ0eVwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJUU0Fic3RyYWN0Q2xhc3NQcm9wZXJ0eVwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJUU0RlY2xhcmVNZXRob2RcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiKSkge1xuICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDMocHJlY2VkaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVGdW5jdGlvbk5hbWVDb21tZW50cyh0ZXh0LCBlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBjb21tZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKHV0aWwkMS5nZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVyKHRleHQsIGNvbW1lbnQsIG9wdGlvbnMubG9jRW5kKSAhPT0gXCIoXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocHJlY2VkaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIikpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQzKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29tbWVudEFmdGVyQXJyb3dQYXJhbXModGV4dCwgZW5jbG9zaW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghKGVuY2xvc2luZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgkMih0ZXh0LCBjb21tZW50LCBvcHRpb25zLmxvY0VuZCk7XG5cbiAgICBpZiAodGV4dC5zbGljZShpbmRleCwgaW5kZXggKyAyKSA9PT0gXCI9PlwiKSB7XG4gICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNvbW1lbnRJbkVtcHR5UGFyZW5zKHRleHQsIGVuY2xvc2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAodXRpbCQxLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIodGV4dCwgY29tbWVudCwgb3B0aW9ucy5sb2NFbmQpICE9PSBcIilcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gT25seSBhZGQgZGFuZ2xpbmcgY29tbWVudHMgdG8gZml4IHRoZSBjYXNlIHdoZW4gbm8gcGFyYW1zIGFyZSBwcmVzZW50LFxuICAgIC8vIGkuZS4gYSBmdW5jdGlvbiB3aXRob3V0IGFueSBhcmd1bWVudC5cblxuXG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgKGlzUmVhbEZ1bmN0aW9uTGlrZU5vZGUoZW5jbG9zaW5nTm9kZSkgJiYgLy8gYHBhcmFtc2AgdnMgYHBhcmFtZXRlcnNgIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9pc3N1ZXMvOTIzMVxuICAgIChlbmNsb3NpbmdOb2RlLnBhcmFtcyB8fCBlbmNsb3NpbmdOb2RlLnBhcmFtZXRlcnMpLmxlbmd0aCA9PT0gMCB8fCAoZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiTmV3RXhwcmVzc2lvblwiKSAmJiBlbmNsb3NpbmdOb2RlLmFyZ3VtZW50cy5sZW5ndGggPT09IDApKSB7XG4gICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgZW5jbG9zaW5nTm9kZS52YWx1ZS5wYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBhZGREYW5nbGluZ0NvbW1lbnQkMyhlbmNsb3NpbmdOb2RlLnZhbHVlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUxhc3RGdW5jdGlvbkFyZ0NvbW1lbnRzKHRleHQsIHByZWNlZGluZ05vZGUsIGVuY2xvc2luZ05vZGUsIGZvbGxvd2luZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICAvLyBGbG93IGZ1bmN0aW9uIHR5cGUgZGVmaW5pdGlvbnNcbiAgICBpZiAocHJlY2VkaW5nTm9kZSAmJiBwcmVjZWRpbmdOb2RlLnR5cGUgPT09IFwiRnVuY3Rpb25UeXBlUGFyYW1cIiAmJiBlbmNsb3NpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIgJiYgZm9sbG93aW5nTm9kZSAmJiBmb2xsb3dpbmdOb2RlLnR5cGUgIT09IFwiRnVuY3Rpb25UeXBlUGFyYW1cIikge1xuICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDMocHJlY2VkaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFJlYWwgZnVuY3Rpb25zIGFuZCBUeXBlU2NyaXB0IGZ1bmN0aW9uIHR5cGUgZGVmaW5pdGlvbnNcblxuXG4gICAgaWYgKHByZWNlZGluZ05vZGUgJiYgKHByZWNlZGluZ05vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgcHJlY2VkaW5nTm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpICYmIGVuY2xvc2luZ05vZGUgJiYgaXNSZWFsRnVuY3Rpb25MaWtlTm9kZShlbmNsb3NpbmdOb2RlKSAmJiB1dGlsJDEuZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3Rlcih0ZXh0LCBjb21tZW50LCBvcHRpb25zLmxvY0VuZCkgPT09IFwiKVwiKSB7XG4gICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMyhwcmVjZWRpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgJiYgZm9sbG93aW5nTm9kZSAmJiBmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikge1xuICAgICAgY29uc3QgZnVuY3Rpb25QYXJhbVJpZ2h0UGFyZW5JbmRleCA9ICgoKSA9PiB7XG4gICAgICAgIGlmICgoZW5jbG9zaW5nTm9kZS5wYXJhbXMgfHwgZW5jbG9zaW5nTm9kZS5wYXJhbWV0ZXJzKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdXRpbCQxLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4KHRleHQsIG9wdGlvbnMubG9jRW5kKHV0aWwkMS5nZXRMYXN0KGVuY2xvc2luZ05vZGUucGFyYW1zIHx8IGVuY2xvc2luZ05vZGUucGFyYW1ldGVycykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uUGFyYW1MZWZ0UGFyZW5JbmRleCA9IHV0aWwkMS5nZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXhXaXRoU3RhcnRJbmRleCh0ZXh0LCBvcHRpb25zLmxvY0VuZChlbmNsb3NpbmdOb2RlLmlkKSk7XG4gICAgICAgIHJldHVybiB1dGlsJDEuZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4V2l0aFN0YXJ0SW5kZXgodGV4dCwgZnVuY3Rpb25QYXJhbUxlZnRQYXJlbkluZGV4ICsgMSk7XG4gICAgICB9KSgpO1xuXG4gICAgICBpZiAob3B0aW9ucy5sb2NTdGFydChjb21tZW50KSA+IGZ1bmN0aW9uUGFyYW1SaWdodFBhcmVuSW5kZXgpIHtcbiAgICAgICAgYWRkQmxvY2tTdGF0ZW1lbnRGaXJzdENvbW1lbnQoZm9sbG93aW5nTm9kZSwgY29tbWVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUltcG9ydFNwZWNpZmllckNvbW1lbnRzKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpIHtcbiAgICBpZiAoZW5jbG9zaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIpIHtcbiAgICAgIGFkZExlYWRpbmdDb21tZW50JDMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVMYWJlbGVkU3RhdGVtZW50Q29tbWVudHMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJMYWJlbGVkU3RhdGVtZW50XCIpIHtcbiAgICAgIGFkZExlYWRpbmdDb21tZW50JDMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVCcmVha0FuZENvbnRpbnVlU3RhdGVtZW50Q29tbWVudHMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQ29udGludWVTdGF0ZW1lbnRcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiQnJlYWtTdGF0ZW1lbnRcIikgJiYgIWVuY2xvc2luZ05vZGUubGFiZWwpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQzKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2FsbEV4cHJlc3Npb25Db21tZW50cyhwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgKGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpICYmIHByZWNlZGluZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS5jYWxsZWUgPT09IHByZWNlZGluZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS5hcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMyhlbmNsb3NpbmdOb2RlLmFyZ3VtZW50c1swXSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVVbmlvblR5cGVDb21tZW50cyhwcmVjZWRpbmdOb2RlLCBlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgKGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIgfHwgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIlRTVW5pb25UeXBlXCIpKSB7XG4gICAgICBpZiAodXRpbCQxLmlzTm9kZUlnbm9yZUNvbW1lbnQoY29tbWVudCkpIHtcbiAgICAgICAgZm9sbG93aW5nTm9kZS5wcmV0dGllcklnbm9yZSA9IHRydWU7XG4gICAgICAgIGNvbW1lbnQudW5pZ25vcmUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJlY2VkaW5nTm9kZSkge1xuICAgICAgICBhZGRUcmFpbGluZ0NvbW1lbnQkMyhwcmVjZWRpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9sbG93aW5nTm9kZSAmJiAoZm9sbG93aW5nTm9kZS50eXBlID09PSBcIlVuaW9uVHlwZUFubm90YXRpb25cIiB8fCBmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiVFNVbmlvblR5cGVcIikgJiYgdXRpbCQxLmlzTm9kZUlnbm9yZUNvbW1lbnQoY29tbWVudCkpIHtcbiAgICAgIGZvbGxvd2luZ05vZGUudHlwZXNbMF0ucHJldHRpZXJJZ25vcmUgPSB0cnVlO1xuICAgICAgY29tbWVudC51bmlnbm9yZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgKGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiIHx8IGVuY2xvc2luZ05vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiKSkge1xuICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU9ubHlDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBhc3QsIGNvbW1lbnQsIGlzTGFzdENvbW1lbnQpIHtcbiAgICAvLyBXaXRoIEZsb3cgdGhlIGVuY2xvc2luZ05vZGUgaXMgdW5kZWZpbmVkIHNvIHVzZSB0aGUgQVNUIGluc3RlYWQuXG4gICAgaWYgKGFzdCAmJiBhc3QuYm9keSAmJiBhc3QuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc0xhc3RDb21tZW50KSB7XG4gICAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQzKGFzdCwgY29tbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRMZWFkaW5nQ29tbWVudCQzKGFzdCwgY29tbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZW5jbG9zaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiUHJvZ3JhbVwiICYmIGVuY2xvc2luZ05vZGUuYm9keS5sZW5ndGggPT09IDAgJiYgZW5jbG9zaW5nTm9kZS5kaXJlY3RpdmVzICYmIGVuY2xvc2luZ05vZGUuZGlyZWN0aXZlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc0xhc3RDb21tZW50KSB7XG4gICAgICAgIGFkZERhbmdsaW5nQ29tbWVudCQzKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkTGVhZGluZ0NvbW1lbnQkMyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRm9yQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgcHJlY2VkaW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiRm9ySW5TdGF0ZW1lbnRcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiRm9yT2ZTdGF0ZW1lbnRcIikpIHtcbiAgICAgIGFkZExlYWRpbmdDb21tZW50JDMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVJbXBvcnREZWNsYXJhdGlvbkNvbW1lbnRzKHRleHQsIGVuY2xvc2luZ05vZGUsIHByZWNlZGluZ05vZGUsIGNvbW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAocHJlY2VkaW5nTm9kZSAmJiBwcmVjZWRpbmdOb2RlLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIgJiYgZW5jbG9zaW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiSW1wb3J0RGVjbGFyYXRpb25cIiAmJiB1dGlsJDEuaGFzTmV3bGluZSh0ZXh0LCBvcHRpb25zLmxvY0VuZChjb21tZW50KSkpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQzKHByZWNlZGluZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXNzaWdubWVudFBhdHRlcm5Db21tZW50cyhlbmNsb3NpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIGFkZExlYWRpbmdDb21tZW50JDMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVUeXBlQWxpYXNDb21tZW50cyhlbmNsb3NpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIlR5cGVBbGlhc1wiKSB7XG4gICAgICBhZGRMZWFkaW5nQ29tbWVudCQzKGVuY2xvc2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVmFyaWFibGVEZWNsYXJhdG9yQ29tbWVudHMoZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCkge1xuICAgIGlmIChlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIgfHwgZW5jbG9zaW5nTm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpICYmIGZvbGxvd2luZ05vZGUgJiYgKGZvbGxvd2luZ05vZGUudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIgfHwgZm9sbG93aW5nTm9kZS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiIHx8IGZvbGxvd2luZ05vZGUudHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIiB8fCBmb2xsb3dpbmdOb2RlLnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgfHwgaXNCbG9ja0NvbW1lbnQoY29tbWVudCkpKSB7XG4gICAgICBhZGRMZWFkaW5nQ29tbWVudCQzKGZvbGxvd2luZ05vZGUsIGNvbW1lbnQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlVFNGdW5jdGlvblRyYWlsaW5nQ29tbWVudHModGV4dCwgZW5jbG9zaW5nTm9kZSwgZm9sbG93aW5nTm9kZSwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIGlmICghZm9sbG93aW5nTm9kZSAmJiBlbmNsb3NpbmdOb2RlICYmIChlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiVFNNZXRob2RTaWduYXR1cmVcIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiVFNEZWNsYXJlRnVuY3Rpb25cIiB8fCBlbmNsb3NpbmdOb2RlLnR5cGUgPT09IFwiVFNBYnN0cmFjdE1ldGhvZERlZmluaXRpb25cIikgJiYgdXRpbCQxLmdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXIodGV4dCwgY29tbWVudCwgb3B0aW9ucy5sb2NFbmQpID09PSBcIjtcIikge1xuICAgICAgYWRkVHJhaWxpbmdDb21tZW50JDMoZW5jbG9zaW5nTm9kZSwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVUU01hcHBlZFR5cGVDb21tZW50cyh0ZXh0LCBlbmNsb3NpbmdOb2RlLCBwcmVjZWRpbmdOb2RlLCBmb2xsb3dpbmdOb2RlLCBjb21tZW50KSB7XG4gICAgaWYgKCFlbmNsb3NpbmdOb2RlIHx8IGVuY2xvc2luZ05vZGUudHlwZSAhPT0gXCJUU01hcHBlZFR5cGVcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmb2xsb3dpbmdOb2RlICYmIGZvbGxvd2luZ05vZGUudHlwZSA9PT0gXCJUU1R5cGVQYXJhbWV0ZXJcIiAmJiBmb2xsb3dpbmdOb2RlLm5hbWUpIHtcbiAgICAgIGFkZExlYWRpbmdDb21tZW50JDMoZm9sbG93aW5nTm9kZS5uYW1lLCBjb21tZW50KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcmVjZWRpbmdOb2RlICYmIHByZWNlZGluZ05vZGUudHlwZSA9PT0gXCJUU1R5cGVQYXJhbWV0ZXJcIiAmJiBwcmVjZWRpbmdOb2RlLmNvbnN0cmFpbnQpIHtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudCQzKHByZWNlZGluZ05vZGUuY29uc3RyYWludCwgY29tbWVudCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Jsb2NrQ29tbWVudChjb21tZW50KSB7XG4gICAgcmV0dXJuIGNvbW1lbnQudHlwZSA9PT0gXCJCbG9ja1wiIHx8IGNvbW1lbnQudHlwZSA9PT0gXCJDb21tZW50QmxvY2tcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0xlYWRpbmdDb21tZW50KG5vZGUsIGZuID0gKCkgPT4gdHJ1ZSkge1xuICAgIGlmIChub2RlLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgcmV0dXJuIG5vZGUubGVhZGluZ0NvbW1lbnRzLnNvbWUoZm4pO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNvbW1lbnRzKSB7XG4gICAgICByZXR1cm4gbm9kZS5jb21tZW50cy5zb21lKGNvbW1lbnQgPT4gY29tbWVudC5sZWFkaW5nICYmIGZuKGNvbW1lbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlYWxGdW5jdGlvbkxpa2VOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9iamVjdE1ldGhvZFwiIHx8IG5vZGUudHlwZSA9PT0gXCJDbGFzc01ldGhvZFwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0RlY2xhcmVGdW5jdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVFNNZXRob2RTaWduYXR1cmVcIiB8fCBub2RlLnR5cGUgPT09IFwiVFNDb25zdHJ1Y3RvclR5cGVcIiB8fCBub2RlLnR5cGUgPT09IFwiVFNGdW5jdGlvblR5cGVcIiB8fCBub2RlLnR5cGUgPT09IFwiVFNEZWNsYXJlTWV0aG9kXCI7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRHYXBSZWdleChlbmNsb3NpbmdOb2RlKSB7XG4gICAgaWYgKGVuY2xvc2luZ05vZGUgJiYgZW5jbG9zaW5nTm9kZS50eXBlICE9PSBcIkJpbmFyeUV4cHJlc3Npb25cIiAmJiBlbmNsb3NpbmdOb2RlLnR5cGUgIT09IFwiTG9naWNhbEV4cHJlc3Npb25cIikge1xuICAgICAgLy8gU3VwcG9ydCBkZWdlbmVyYXRlIHNpbmdsZS1lbGVtZW50IHVuaW9ucyBhbmQgaW50ZXJzZWN0aW9ucy5cbiAgICAgIC8vIEUuZy46IGB0eXBlIEEgPSAvKiAxICovICYgQmBcbiAgICAgIHJldHVybiAvXltcXHMoJnxdKiQvO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbW1lbnRDaGlsZE5vZGVzKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAvLyBQcmV2ZW50IGF0dGFjaGluZyBjb21tZW50cyB0byBGdW5jdGlvbkV4cHJlc3Npb24gaW4gdGhpcyBjYXNlOlxuICAgIC8vICAgICBjbGFzcyBGb28ge1xuICAgIC8vICAgICAgIGJhcigpIC8vIGNvbW1lbnRcbiAgICAvLyAgICAgICB7XG4gICAgLy8gICAgICAgICBiYXooKTtcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICBpZiAoKG9wdGlvbnMucGFyc2VyID09PSBcInR5cGVzY3JpcHRcIiB8fCBvcHRpb25zLnBhcnNlciA9PT0gXCJmbG93XCIpICYmIG5vZGUudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgbm9kZS52YWx1ZSAmJiBub2RlLnZhbHVlLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgbm9kZS52YWx1ZS5wYXJhbXMubGVuZ3RoID09PSAwICYmICFub2RlLnZhbHVlLnJldHVyblR5cGUgJiYgKCFub2RlLnZhbHVlLnR5cGVQYXJhbWV0ZXJzIHx8IG5vZGUudmFsdWUudHlwZVBhcmFtZXRlcnMubGVuZ3RoID09PSAwKSAmJiBub2RlLnZhbHVlLmJvZHkpIHtcbiAgICAgIHJldHVybiBbLi4uKG5vZGUuZGVjb3JhdG9ycyB8fCBbXSksIG5vZGUua2V5LCBub2RlLnZhbHVlLmJvZHldO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVHlwZUNhc3RDb21tZW50KGNvbW1lbnQpIHtcbiAgICByZXR1cm4gaXNCbG9ja0NvbW1lbnQoY29tbWVudCkgJiYgY29tbWVudC52YWx1ZVswXSA9PT0gXCIqXCIgJiYgLy8gVHlwZVNjcmlwdCBleHBlY3RzIHRoZSB0eXBlIHRvIGJlIGVuY2xvc2VkIGluIGN1cmx5IGJyYWNrZXRzLCBob3dldmVyXG4gICAgLy8gQ2xvc3VyZSBDb21waWxlciBhY2NlcHRzIHR5cGVzIGluIHBhcmVucyBhbmQgZXZlbiB3aXRob3V0IGFueSBkZWxpbWl0ZXJzIGF0IGFsbC5cbiAgICAvLyBUaGF0J3Mgd2h5IHdlIGp1c3Qgc2VhcmNoIGZvciBcIkB0eXBlXCIuXG4gICAgL0B0eXBlXFxiLy50ZXN0KGNvbW1lbnQudmFsdWUpO1xuICB9XG5cbiAgdmFyIGNvbW1lbnRzJDEgPSB7XG4gICAgaGFuZGxlT3duTGluZUNvbW1lbnQsXG4gICAgaGFuZGxlRW5kT2ZMaW5lQ29tbWVudCxcbiAgICBoYW5kbGVSZW1haW5pbmdDb21tZW50LFxuICAgIGhhc0xlYWRpbmdDb21tZW50LFxuICAgIGlzQmxvY2tDb21tZW50LFxuICAgIGlzVHlwZUNhc3RDb21tZW50LFxuICAgIGdldEdhcFJlZ2V4LFxuICAgIGdldENvbW1lbnRDaGlsZE5vZGVzXG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGlzQmxvY2tDb21tZW50OiBpc0Jsb2NrQ29tbWVudCQxLFxuICAgIGhhc0xlYWRpbmdDb21tZW50OiBoYXNMZWFkaW5nQ29tbWVudCQxXG4gIH0gPSBjb21tZW50cyQxO1xuICBjb25zdCB7XG4gICAgYnVpbGRlcnM6IHtcbiAgICAgIGluZGVudDogaW5kZW50JDYsXG4gICAgICBqb2luOiBqb2luJDcsXG4gICAgICBsaW5lOiBsaW5lJDcsXG4gICAgICBoYXJkbGluZTogaGFyZGxpbmUkOCxcbiAgICAgIHNvZnRsaW5lOiBzb2Z0bGluZSQ1LFxuICAgICAgbGl0ZXJhbGxpbmU6IGxpdGVyYWxsaW5lJDMsXG4gICAgICBjb25jYXQ6IGNvbmNhdCRiLFxuICAgICAgZ3JvdXA6IGdyb3VwJGEsXG4gICAgICBkZWRlbnRUb1Jvb3Q6IGRlZGVudFRvUm9vdCQyXG4gICAgfSxcbiAgICB1dGlsczoge1xuICAgICAgbWFwRG9jOiBtYXBEb2MkMyxcbiAgICAgIHN0cmlwVHJhaWxpbmdIYXJkbGluZTogc3RyaXBUcmFpbGluZ0hhcmRsaW5lJDJcbiAgICB9XG4gIH0gPSBkb2N1bWVudDtcblxuICBmdW5jdGlvbiBlbWJlZCQzKHBhdGgsIHByaW50LCB0ZXh0VG9Eb2MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgIGNvbnN0IHBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiVGVtcGxhdGVMaXRlcmFsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBpc0NzcyA9IFtpc1N0eWxlZEpzeCwgaXNTdHlsZWRDb21wb25lbnRzLCBpc0Nzc1Byb3AsIGlzQW5ndWxhckNvbXBvbmVudFN0eWxlc10uc29tZShpc0l0ID0+IGlzSXQocGF0aCkpO1xuXG4gICAgICAgICAgaWYgKGlzQ3NzKSB7XG4gICAgICAgICAgICAvLyBHZXQgZnVsbCB0ZW1wbGF0ZSBsaXRlcmFsIHdpdGggZXhwcmVzc2lvbnMgcmVwbGFjZWQgYnkgcGxhY2Vob2xkZXJzXG4gICAgICAgICAgICBjb25zdCByYXdRdWFzaXMgPSBub2RlLnF1YXNpcy5tYXAocSA9PiBxLnZhbHVlLnJhdyk7XG4gICAgICAgICAgICBsZXQgcGxhY2Vob2xkZXJJRCA9IDA7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gcmF3UXVhc2lzLnJlZHVjZSgocHJldlZhbCwgY3VyclZhbCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBpZHggPT09IDAgPyBjdXJyVmFsIDogcHJldlZhbCArIFwiQHByZXR0aWVyLXBsYWNlaG9sZGVyLVwiICsgcGxhY2Vob2xkZXJJRCsrICsgXCItaWRcIiArIGN1cnJWYWw7XG4gICAgICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IHRleHRUb0RvYyh0ZXh0LCB7XG4gICAgICAgICAgICAgIHBhcnNlcjogXCJzY3NzXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNzc0RvYyhkb2MsIHBhdGgsIHByaW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiByZWFjdC1yZWxheSBhbmQgZ3JhcGhxbC10YWdcbiAgICAgICAgICAgKiBncmFwaHFsYC4uLmBcbiAgICAgICAgICAgKiBncmFwaHFsLmV4cGVyaW1lbnRhbGAuLi5gXG4gICAgICAgICAgICogZ3FsYC4uLmBcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoaXMgaW50ZW50aW9uYWxseSBleGNsdWRlcyBSZWxheSBDbGFzc2ljIHRhZ3MsIGFzIFByZXR0aWVyIGRvZXMgbm90XG4gICAgICAgICAgICogc3VwcG9ydCBSZWxheSBDbGFzc2ljIGZvcm1hdHRpbmcuXG4gICAgICAgICAgICovXG5cblxuICAgICAgICAgIGlmIChpc0dyYXBoUUwocGF0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25Eb2NzID0gbm9kZS5leHByZXNzaW9ucyA/IHBhdGgubWFwKHByaW50LCBcImV4cHJlc3Npb25zXCIpIDogW107XG4gICAgICAgICAgICBjb25zdCBudW1RdWFzaXMgPSBub2RlLnF1YXNpcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChudW1RdWFzaXMgPT09IDEgJiYgbm9kZS5xdWFzaXNbMF0udmFsdWUucmF3LnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gXCJgYFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVF1YXNpczsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlRWxlbWVudCA9IG5vZGUucXVhc2lzW2ldO1xuICAgICAgICAgICAgICBjb25zdCBpc0ZpcnN0ID0gaSA9PT0gMDtcbiAgICAgICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSA9PT0gbnVtUXVhc2lzIC0gMTtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRlbXBsYXRlRWxlbWVudC52YWx1ZS5jb29rZWQ7IC8vIEJhaWwgb3V0IGlmIGFueSBvZiB0aGUgcXVhc2lzIGhhdmUgYW4gaW52YWxpZCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgLy8gKHdoaWNoIHdvdWxkIG1ha2UgdGhlIGBjb29rZWRgIHZhbHVlIGJlIGBudWxsYCBvciBgdW5kZWZpbmVkYClcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRleHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgY29uc3QgbnVtTGluZXMgPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25Eb2MgPSBleHByZXNzaW9uRG9jc1tpXTtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnRzV2l0aEJsYW5rTGluZSA9IG51bUxpbmVzID4gMiAmJiBsaW5lc1swXS50cmltKCkgPT09IFwiXCIgJiYgbGluZXNbMV0udHJpbSgpID09PSBcIlwiO1xuICAgICAgICAgICAgICBjb25zdCBlbmRzV2l0aEJsYW5rTGluZSA9IG51bUxpbmVzID4gMiAmJiBsaW5lc1tudW1MaW5lcyAtIDFdLnRyaW0oKSA9PT0gXCJcIiAmJiBsaW5lc1tudW1MaW5lcyAtIDJdLnRyaW0oKSA9PT0gXCJcIjtcbiAgICAgICAgICAgICAgY29uc3QgY29tbWVudHNBbmRXaGl0ZXNwYWNlT25seSA9IGxpbmVzLmV2ZXJ5KGxpbmUgPT4gL15cXHMqKD86I1teXFxyXFxuXSopPyQvLnRlc3QobGluZSkpOyAvLyBCYWlsIG91dCBpZiBhbiBpbnRlcnBvbGF0aW9uIG9jY3VycyB3aXRoaW4gYSBjb21tZW50LlxuXG4gICAgICAgICAgICAgIGlmICghaXNMYXN0ICYmIC8jW15cXHJcXG5dKiQvLnRlc3QobGluZXNbbnVtTGluZXMgLSAxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxldCBkb2MgPSBudWxsO1xuXG4gICAgICAgICAgICAgIGlmIChjb21tZW50c0FuZFdoaXRlc3BhY2VPbmx5KSB7XG4gICAgICAgICAgICAgICAgZG9jID0gcHJpbnRHcmFwaHFsQ29tbWVudHMobGluZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvYyA9IHN0cmlwVHJhaWxpbmdIYXJkbGluZSQyKHRleHRUb0RvYyh0ZXh0LCB7XG4gICAgICAgICAgICAgICAgICBwYXJzZXI6IFwiZ3JhcGhxbFwiXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgICAgIGRvYyA9IGVzY2FwZVRlbXBsYXRlQ2hhcmFjdGVycyhkb2MsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGlmICghaXNGaXJzdCAmJiBzdGFydHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZG9jKTtcblxuICAgICAgICAgICAgICAgIGlmICghaXNMYXN0ICYmIGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNGaXJzdCAmJiAhaXNMYXN0ICYmIHN0YXJ0c1dpdGhCbGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25Eb2MpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNvbmNhdCRiKFtcIiR7XCIsIGV4cHJlc3Npb25Eb2MsIFwifVwiXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkYihbXCJgXCIsIGluZGVudCQ2KGNvbmNhdCRiKFtoYXJkbGluZSQ4LCBqb2luJDcoaGFyZGxpbmUkOCwgcGFydHMpXSkpLCBoYXJkbGluZSQ4LCBcImBcIl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGh0bWxQYXJzZXIgPSBpc0h0bWwocGF0aCkgPyBcImh0bWxcIiA6IGlzQW5ndWxhckNvbXBvbmVudFRlbXBsYXRlKHBhdGgpID8gXCJhbmd1bGFyXCIgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoaHRtbFBhcnNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50SHRtbFRlbXBsYXRlTGl0ZXJhbChwYXRoLCBwcmludCwgdGV4dFRvRG9jLCBodG1sUGFyc2VyLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVGVtcGxhdGVFbGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBtZGAuLi5gXG4gICAgICAgICAgICogbWFya2Rvd25gLi4uYFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChwYXJlbnRQYXJlbnQgJiYgcGFyZW50UGFyZW50LnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgJiYgcGFyZW50LnF1YXNpcy5sZW5ndGggPT09IDEgJiYgcGFyZW50UGFyZW50LnRhZy50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAocGFyZW50UGFyZW50LnRhZy5uYW1lID09PSBcIm1kXCIgfHwgcGFyZW50UGFyZW50LnRhZy5uYW1lID09PSBcIm1hcmtkb3duXCIpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gcGFyZW50LnF1YXNpc1swXS52YWx1ZS5yYXcucmVwbGFjZSgvKCg/OlxcXFxcXFxcKSopXFxcXGAvZywgKF8sIGJhY2tzbGFzaGVzKSA9PiBcIlxcXFxcIi5yZXBlYXQoYmFja3NsYXNoZXMubGVuZ3RoIC8gMikgKyBcImBcIik7XG4gICAgICAgICAgICBjb25zdCBpbmRlbnRhdGlvbiA9IGdldEluZGVudGF0aW9uKHRleHQpO1xuICAgICAgICAgICAgY29uc3QgaGFzSW5kZW50ID0gaW5kZW50YXRpb24gIT09IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGIoW2hhc0luZGVudCA/IGluZGVudCQ2KGNvbmNhdCRiKFtzb2Z0bGluZSQ1LCBwcmludE1hcmtkb3duKHRleHQucmVwbGFjZShuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChpbmRlbnRhdGlvbiksIFwiZ21cIiksIFwiXCIpKV0pKSA6IGNvbmNhdCRiKFtsaXRlcmFsbGluZSQzLCBkZWRlbnRUb1Jvb3QkMihwcmludE1hcmtkb3duKHRleHQpKV0pLCBzb2Z0bGluZSQ1XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludE1hcmtkb3duKHRleHQpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRleHRUb0RvYyh0ZXh0LCB7XG4gICAgICAgIHBhcnNlcjogXCJtYXJrZG93blwiLFxuICAgICAgICBfX2luSnNUZW1wbGF0ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc3RyaXBUcmFpbGluZ0hhcmRsaW5lJDIoZXNjYXBlVGVtcGxhdGVDaGFyYWN0ZXJzKGRvYywgdHJ1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluZGVudGF0aW9uKHN0cikge1xuICAgIGNvbnN0IGZpcnN0TWF0Y2hlZEluZGVudCA9IHN0ci5tYXRjaCgvXihbXlxcU1xcbl0qKVxcUy9tKTtcbiAgICByZXR1cm4gZmlyc3RNYXRjaGVkSW5kZW50ID09PSBudWxsID8gXCJcIiA6IGZpcnN0TWF0Y2hlZEluZGVudFsxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuY29vayhjb29rZWRWYWx1ZSkge1xuICAgIHJldHVybiBjb29rZWRWYWx1ZS5yZXBsYWNlKC8oW1xcXFxgXXxcXCRcXHspL2csIFwiXFxcXCQxXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlVGVtcGxhdGVDaGFyYWN0ZXJzKGRvYywgcmF3KSB7XG4gICAgcmV0dXJuIG1hcERvYyQzKGRvYywgY3VycmVudERvYyA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnREb2MucGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnREb2M7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICBjdXJyZW50RG9jLnBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHBhcnRzLnB1c2gocmF3ID8gcGFydC5yZXBsYWNlKC8oXFxcXCopYC9nLCBcIiQxJDFcXFxcYFwiKSA6IHVuY29vayhwYXJ0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudERvYywge1xuICAgICAgICBwYXJ0c1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Dc3NEb2MocXVhc2lzRG9jLCBwYXRoLCBwcmludCkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgaXNFbXB0eSA9IHBhcmVudE5vZGUucXVhc2lzLmxlbmd0aCA9PT0gMSAmJiAhcGFyZW50Tm9kZS5xdWFzaXNbMF0udmFsdWUucmF3LnRyaW0oKTtcblxuICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICByZXR1cm4gXCJgYFwiO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cHJlc3Npb25Eb2NzID0gcGFyZW50Tm9kZS5leHByZXNzaW9ucyA/IHBhdGgubWFwKHByaW50LCBcImV4cHJlc3Npb25zXCIpIDogW107XG4gICAgY29uc3QgbmV3RG9jID0gcmVwbGFjZVBsYWNlaG9sZGVycyhxdWFzaXNEb2MsIGV4cHJlc3Npb25Eb2NzKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgIGlmICghbmV3RG9jKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBpbnNlcnQgYWxsIHRoZSBleHByZXNzaW9uc1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JGIoW1wiYFwiLCBpbmRlbnQkNihjb25jYXQkYihbaGFyZGxpbmUkOCwgc3RyaXBUcmFpbGluZ0hhcmRsaW5lJDIobmV3RG9jKV0pKSwgc29mdGxpbmUkNSwgXCJgXCJdKTtcbiAgfSAvLyBTZWFyY2ggYWxsIHRoZSBwbGFjZWhvbGRlcnMgaW4gdGhlIHF1YXNpc0RvYyB0cmVlXG4gIC8vIGFuZCByZXBsYWNlIHRoZW0gd2l0aCB0aGUgZXhwcmVzc2lvbiBkb2NzIG9uZSBieSBvbmVcbiAgLy8gcmV0dXJucyBhIG5ldyBkb2Mgd2l0aCBhbGwgdGhlIHBsYWNlaG9sZGVycyByZXBsYWNlZCxcbiAgLy8gb3IgbnVsbCBpZiBpdCBjb3VsZG4ndCByZXBsYWNlIGFueSBleHByZXNzaW9uXG5cblxuICBmdW5jdGlvbiByZXBsYWNlUGxhY2Vob2xkZXJzKHF1YXNpc0RvYywgZXhwcmVzc2lvbkRvY3MpIHtcbiAgICBpZiAoIWV4cHJlc3Npb25Eb2NzIHx8ICFleHByZXNzaW9uRG9jcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBxdWFzaXNEb2M7XG4gICAgfVxuXG4gICAgY29uc3QgZXhwcmVzc2lvbnMgPSBleHByZXNzaW9uRG9jcy5zbGljZSgpO1xuICAgIGxldCByZXBsYWNlQ291bnRlciA9IDA7XG4gICAgY29uc3QgbmV3RG9jID0gbWFwRG9jJDMocXVhc2lzRG9jLCBkb2MgPT4ge1xuICAgICAgaWYgKCFkb2MgfHwgIWRvYy5wYXJ0cyB8fCAhZG9jLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgfVxuXG4gICAgICBsZXQge1xuICAgICAgICBwYXJ0c1xuICAgICAgfSA9IGRvYztcbiAgICAgIGNvbnN0IGF0SW5kZXggPSBwYXJ0cy5pbmRleE9mKFwiQFwiKTtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVySW5kZXggPSBhdEluZGV4ICsgMTtcblxuICAgICAgaWYgKGF0SW5kZXggPiAtMSAmJiB0eXBlb2YgcGFydHNbcGxhY2Vob2xkZXJJbmRleF0gPT09IFwic3RyaW5nXCIgJiYgcGFydHNbcGxhY2Vob2xkZXJJbmRleF0uc3RhcnRzV2l0aChcInByZXR0aWVyLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgICAgIC8vIElmIHBsYWNlaG9sZGVyIGlzIHNwbGl0LCBqb2luIGl0XG4gICAgICAgIGNvbnN0IGF0ID0gcGFydHNbYXRJbmRleF07XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gcGFydHNbcGxhY2Vob2xkZXJJbmRleF07XG4gICAgICAgIGNvbnN0IHJlc3QgPSBwYXJ0cy5zbGljZShwbGFjZWhvbGRlckluZGV4ICsgMSk7XG4gICAgICAgIHBhcnRzID0gcGFydHMuc2xpY2UoMCwgYXRJbmRleCkuY29uY2F0KFthdCArIHBsYWNlaG9sZGVyXSkuY29uY2F0KHJlc3QpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhdFBsYWNlaG9sZGVySW5kZXggPSBwYXJ0cy5maW5kSW5kZXgocGFydCA9PiB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiBwYXJ0LnN0YXJ0c1dpdGgoXCJAcHJldHRpZXItcGxhY2Vob2xkZXJcIikpO1xuXG4gICAgICBpZiAoYXRQbGFjZWhvbGRlckluZGV4ID4gLTEpIHtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBwYXJ0c1thdFBsYWNlaG9sZGVySW5kZXhdO1xuICAgICAgICBjb25zdCByZXN0ID0gcGFydHMuc2xpY2UoYXRQbGFjZWhvbGRlckluZGV4ICsgMSk7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyTWF0Y2ggPSBwbGFjZWhvbGRlci5tYXRjaCgvQHByZXR0aWVyLXBsYWNlaG9sZGVyLSguKyktaWQoW1xcc1xcU10qKS8pO1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlcklEID0gcGxhY2Vob2xkZXJNYXRjaFsxXTsgLy8gV2hlbiB0aGUgZXhwcmVzc2lvbiBoYXMgYSBzdWZmaXggYXBwZW5kZWQsIGxpa2U6XG4gICAgICAgIC8vIGFuaW1hdGlvbjogbGluZWFyICR7dGltZX1zIGVhc2Utb3V0O1xuXG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IHBsYWNlaG9sZGVyTWF0Y2hbMl07XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBleHByZXNzaW9uc1twbGFjZWhvbGRlcklEXTtcbiAgICAgICAgcmVwbGFjZUNvdW50ZXIrKztcbiAgICAgICAgcGFydHMgPSBwYXJ0cy5zbGljZSgwLCBhdFBsYWNlaG9sZGVySW5kZXgpLmNvbmNhdChbXCIke1wiLCBleHByZXNzaW9uLCBcIn1cIiArIHN1ZmZpeF0pLmNvbmNhdChyZXN0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRvYywge1xuICAgICAgICBwYXJ0c1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gcmVwbGFjZUNvdW50ZXIgPyBuZXdEb2MgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRHcmFwaHFsQ29tbWVudHMobGluZXMpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGxldCBzZWVuQ29tbWVudCA9IGZhbHNlO1xuICAgIGxpbmVzLm1hcCh0ZXh0TGluZSA9PiB0ZXh0TGluZS50cmltKCkpLmZvckVhY2goKHRleHRMaW5lLCBpLCBhcnJheSkgPT4ge1xuICAgICAgLy8gTGluZXMgYXJlIGVpdGhlciB3aGl0ZXNwYWNlIG9ubHksIG9yIGEgY29tbWVudCAod2l0aCBwb3RlbnRpYWwgd2hpdGVzcGFjZVxuICAgICAgLy8gYXJvdW5kIGl0KS4gRHJvcCB3aGl0ZXNwYWNlLW9ubHkgbGluZXMuXG4gICAgICBpZiAodGV4dExpbmUgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJyYXlbaSAtIDFdID09PSBcIlwiICYmIHNlZW5Db21tZW50KSB7XG4gICAgICAgIC8vIElmIGEgbm9uLWZpcnN0IGNvbW1lbnQgaXMgcHJlY2VkZWQgYnkgYSBibGFuayAod2hpdGVzcGFjZSBvbmx5KSBsaW5lLFxuICAgICAgICAvLyBhZGQgaW4gYSBibGFuayBsaW5lLlxuICAgICAgICBwYXJ0cy5wdXNoKGNvbmNhdCRiKFtoYXJkbGluZSQ4LCB0ZXh0TGluZV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2godGV4dExpbmUpO1xuICAgICAgfVxuXG4gICAgICBzZWVuQ29tbWVudCA9IHRydWU7XG4gICAgfSk7IC8vIElmIGBsaW5lc2Agd2FzIHdoaXRlc3BhY2Ugb25seSwgcmV0dXJuIGBudWxsYC5cblxuICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyBudWxsIDogam9pbiQ3KGhhcmRsaW5lJDgsIHBhcnRzKTtcbiAgfVxuICAvKipcbiAgICogVGVtcGxhdGUgbGl0ZXJhbCBpbiB0aGVzZSBjb250ZXh0czpcbiAgICogPHN0eWxlIGpzeD57YGRpdntjb2xvcjpyZWR9YH08L3N0eWxlPlxuICAgKiBjc3NgYFxuICAgKiBjc3MuZ2xvYmFsYGBcbiAgICogY3NzLnJlc29sdmVgYFxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzU3R5bGVkSnN4KHBhdGgpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgIGNvbnN0IHBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcbiAgICByZXR1cm4gcGFyZW50UGFyZW50ICYmIG5vZGUucXVhc2lzICYmIHBhcmVudC50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiAmJiBwYXJlbnRQYXJlbnQudHlwZSA9PT0gXCJKU1hFbGVtZW50XCIgJiYgcGFyZW50UGFyZW50Lm9wZW5pbmdFbGVtZW50Lm5hbWUubmFtZSA9PT0gXCJzdHlsZVwiICYmIHBhcmVudFBhcmVudC5vcGVuaW5nRWxlbWVudC5hdHRyaWJ1dGVzLnNvbWUoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS5uYW1lLm5hbWUgPT09IFwianN4XCIpIHx8IHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiAmJiBwYXJlbnQudGFnLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHBhcmVudC50YWcubmFtZSA9PT0gXCJjc3NcIiB8fCBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgJiYgcGFyZW50LnRhZy50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBwYXJlbnQudGFnLm9iamVjdC5uYW1lID09PSBcImNzc1wiICYmIChwYXJlbnQudGFnLnByb3BlcnR5Lm5hbWUgPT09IFwiZ2xvYmFsXCIgfHwgcGFyZW50LnRhZy5wcm9wZXJ0eS5uYW1lID09PSBcInJlc29sdmVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEFuZ3VsYXIgQ29tcG9uZW50cyBjYW4gaGF2ZTpcbiAgICogLSBJbmxpbmUgSFRNTCB0ZW1wbGF0ZVxuICAgKiAtIElubGluZSBDU1Mgc3R5bGVzXG4gICAqXG4gICAqIC4uLndoaWNoIGFyZSBib3RoIHdpdGhpbiB0ZW1wbGF0ZSBsaXRlcmFscyBzb21ld2hlcmVcbiAgICogaW5zaWRlIG9mIHRoZSBDb21wb25lbnQgZGVjb3JhdG9yIGZhY3RvcnkuXG4gICAqXG4gICAqIEUuZy5cbiAgICogQENvbXBvbmVudCh7XG4gICAqICB0ZW1wbGF0ZTogYDxkaXY+Li4uPC9kaXY+YCxcbiAgICogIHN0eWxlczogW2BoMSB7IGNvbG9yOiBibHVlOyB9YF1cbiAgICogfSlcbiAgICovXG5cblxuICBmdW5jdGlvbiBpc0FuZ3VsYXJDb21wb25lbnRTdHlsZXMocGF0aCkge1xuICAgIHJldHVybiBwYXRoLm1hdGNoKG5vZGUgPT4gbm9kZS50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiLCAobm9kZSwgbmFtZSkgPT4gbm9kZS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiICYmIG5hbWUgPT09IFwiZWxlbWVudHNcIiwgKG5vZGUsIG5hbWUpID0+IChub2RlLnR5cGUgPT09IFwiUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIikgJiYgbm9kZS5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS5rZXkubmFtZSA9PT0gXCJzdHlsZXNcIiAmJiBuYW1lID09PSBcInZhbHVlXCIsIC4uLmFuZ3VsYXJDb21wb25lbnRPYmplY3RFeHByZXNzaW9uUHJlZGljYXRlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0FuZ3VsYXJDb21wb25lbnRUZW1wbGF0ZShwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgubWF0Y2gobm9kZSA9PiBub2RlLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIsIChub2RlLCBuYW1lKSA9PiAobm9kZS50eXBlID09PSBcIlByb3BlcnR5XCIgfHwgbm9kZS50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIpICYmIG5vZGUua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG5vZGUua2V5Lm5hbWUgPT09IFwidGVtcGxhdGVcIiAmJiBuYW1lID09PSBcInZhbHVlXCIsIC4uLmFuZ3VsYXJDb21wb25lbnRPYmplY3RFeHByZXNzaW9uUHJlZGljYXRlcyk7XG4gIH1cblxuICBjb25zdCBhbmd1bGFyQ29tcG9uZW50T2JqZWN0RXhwcmVzc2lvblByZWRpY2F0ZXMgPSBbKG5vZGUsIG5hbWUpID0+IG5vZGUudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIgJiYgbmFtZSA9PT0gXCJwcm9wZXJ0aWVzXCIsIChub2RlLCBuYW1lKSA9PiBub2RlLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiAmJiBub2RlLmNhbGxlZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBub2RlLmNhbGxlZS5uYW1lID09PSBcIkNvbXBvbmVudFwiICYmIG5hbWUgPT09IFwiYXJndW1lbnRzXCIsIChub2RlLCBuYW1lKSA9PiBub2RlLnR5cGUgPT09IFwiRGVjb3JhdG9yXCIgJiYgbmFtZSA9PT0gXCJleHByZXNzaW9uXCJdO1xuICAvKipcbiAgICogc3R5bGVkLWNvbXBvbmVudHMgdGVtcGxhdGUgbGl0ZXJhbHNcbiAgICovXG5cbiAgZnVuY3Rpb24gaXNTdHlsZWRDb21wb25lbnRzKHBhdGgpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgIGlmICghcGFyZW50IHx8IHBhcmVudC50eXBlICE9PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgdGFnXG4gICAgfSA9IHBhcmVudDtcblxuICAgIHN3aXRjaCAodGFnLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAoLy8gc3R5bGVkLmZvb2BgXG4gICAgICAgICAgaXNTdHlsZWRJZGVudGlmaWVyKHRhZy5vYmplY3QpIHx8IC8vIENvbXBvbmVudC5leHRlbmRgYFxuICAgICAgICAgIGlzU3R5bGVkRXh0ZW5kKHRhZylcbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAoLy8gc3R5bGVkKENvbXBvbmVudClgYFxuICAgICAgICAgIGlzU3R5bGVkSWRlbnRpZmllcih0YWcuY2FsbGVlKSB8fCB0YWcuY2FsbGVlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmICh0YWcuY2FsbGVlLm9iamVjdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAoIC8vIHN0eWxlZC5mb28uYXR0cnMoe30pYGBcbiAgICAgICAgICBpc1N0eWxlZElkZW50aWZpZXIodGFnLmNhbGxlZS5vYmplY3Qub2JqZWN0KSB8fCAvLyBDb21wb25lbnQuZXh0ZW5kLmF0dHJzKHt9KWBgXG4gICAgICAgICAgaXNTdHlsZWRFeHRlbmQodGFnLmNhbGxlZS5vYmplY3QpKSB8fCAvLyBzdHlsZWQoQ29tcG9uZW50KS5hdHRycyh7fSlgYFxuICAgICAgICAgIHRhZy5jYWxsZWUub2JqZWN0LnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiAmJiBpc1N0eWxlZElkZW50aWZpZXIodGFnLmNhbGxlZS5vYmplY3QuY2FsbGVlKSlcbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgLy8gY3NzYGBcbiAgICAgICAgcmV0dXJuIHRhZy5uYW1lID09PSBcImNzc1wiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBKU1ggZWxlbWVudCB3aXRoIENTUyBwcm9wXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNDc3NQcm9wKHBhdGgpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICBjb25zdCBwYXJlbnRQYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoMSk7XG4gICAgcmV0dXJuIHBhcmVudFBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIgJiYgcGFyZW50UGFyZW50LnR5cGUgPT09IFwiSlNYQXR0cmlidXRlXCIgJiYgcGFyZW50UGFyZW50Lm5hbWUudHlwZSA9PT0gXCJKU1hJZGVudGlmaWVyXCIgJiYgcGFyZW50UGFyZW50Lm5hbWUubmFtZSA9PT0gXCJjc3NcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3R5bGVkSWRlbnRpZmllcihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS5uYW1lID09PSBcInN0eWxlZFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTdHlsZWRFeHRlbmQobm9kZSkge1xuICAgIHJldHVybiAvXltBLVpdLy50ZXN0KG5vZGUub2JqZWN0Lm5hbWUpICYmIG5vZGUucHJvcGVydHkubmFtZSA9PT0gXCJleHRlbmRcIjtcbiAgfVxuICAvKlxuICAgKiByZWFjdC1yZWxheSBhbmQgZ3JhcGhxbC10YWdcbiAgICogZ3JhcGhxbGAuLi5gXG4gICAqIGdyYXBocWwuZXhwZXJpbWVudGFsYC4uLmBcbiAgICogZ3FsYC4uLmBcbiAgICogR3JhcGhRTCBjb21tZW50IGJsb2NrXG4gICAqXG4gICAqIFRoaXMgaW50ZW50aW9uYWxseSBleGNsdWRlcyBSZWxheSBDbGFzc2ljIHRhZ3MsIGFzIFByZXR0aWVyIGRvZXMgbm90XG4gICAqIHN1cHBvcnQgUmVsYXkgQ2xhc3NpYyBmb3JtYXR0aW5nLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzR3JhcGhRTChwYXRoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICByZXR1cm4gaGFzTGFuZ3VhZ2VDb21tZW50KG5vZGUsIFwiR3JhcGhRTFwiKSB8fCBwYXJlbnQgJiYgKHBhcmVudC50eXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiICYmIChwYXJlbnQudGFnLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIHBhcmVudC50YWcub2JqZWN0Lm5hbWUgPT09IFwiZ3JhcGhxbFwiICYmIHBhcmVudC50YWcucHJvcGVydHkubmFtZSA9PT0gXCJleHBlcmltZW50YWxcIiB8fCBwYXJlbnQudGFnLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChwYXJlbnQudGFnLm5hbWUgPT09IFwiZ3FsXCIgfHwgcGFyZW50LnRhZy5uYW1lID09PSBcImdyYXBocWxcIikpIHx8IHBhcmVudC50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgJiYgcGFyZW50LmNhbGxlZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwYXJlbnQuY2FsbGVlLm5hbWUgPT09IFwiZ3JhcGhxbFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0xhbmd1YWdlQ29tbWVudChub2RlLCBsYW5ndWFnZU5hbWUpIHtcbiAgICAvLyBUaGlzIGNoZWNrcyBmb3IgYSBsZWFkaW5nIGNvbW1lbnQgdGhhdCBpcyBleGFjdGx5IGAvKiBHcmFwaFFMICovYFxuICAgIC8vIEluIG9yZGVyIHRvIGJlIGluIGxpbmUgd2l0aCBvdGhlciBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBjb21tZW50IHRhZ1xuICAgIC8vIHdlIHdpbGwgbm90IHRyaW0gdGhlIGNvbW1lbnQgdmFsdWUgYW5kIHdlIHdpbGwgZXhwZWN0IGV4YWN0bHkgb25lIHNwYWNlIG9uXG4gICAgLy8gZWl0aGVyIHNpZGUgb2YgdGhlIEdyYXBoUUwgc3RyaW5nXG4gICAgLy8gQWxzbyBzZWUgLi9jbGVhbi5qc1xuICAgIHJldHVybiBoYXNMZWFkaW5nQ29tbWVudCQxKG5vZGUsIGNvbW1lbnQgPT4gaXNCbG9ja0NvbW1lbnQkMShjb21tZW50KSAmJiBjb21tZW50LnZhbHVlID09PSBcIiBcIi5jb25jYXQobGFuZ3VhZ2VOYW1lLCBcIiBcIikpO1xuICB9XG4gIC8qKlxuICAgKiAgICAgLSBodG1sYC4uLmBcbiAgICogICAgIC0gSFRNTCBjb21tZW50IGJsb2NrXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNIdG1sKHBhdGgpIHtcbiAgICByZXR1cm4gaGFzTGFuZ3VhZ2VDb21tZW50KHBhdGguZ2V0VmFsdWUoKSwgXCJIVE1MXCIpIHx8IHBhdGgubWF0Y2gobm9kZSA9PiBub2RlLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIsIChub2RlLCBuYW1lKSA9PiBub2RlLnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgJiYgbm9kZS50YWcudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS50YWcubmFtZSA9PT0gXCJodG1sXCIgJiYgbmFtZSA9PT0gXCJxdWFzaVwiKTtcbiAgfSAvLyBUaGUgY291bnRlciBpcyBuZWVkZWQgdG8gZGlzdGluZ3Vpc2ggbmVzdGVkIGVtYmVkcy5cblxuXG4gIGxldCBodG1sVGVtcGxhdGVMaXRlcmFsQ291bnRlciA9IDA7XG5cbiAgZnVuY3Rpb24gcHJpbnRIdG1sVGVtcGxhdGVMaXRlcmFsKHBhdGgsIHByaW50LCB0ZXh0VG9Eb2MsIHBhcnNlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgY291bnRlciA9IGh0bWxUZW1wbGF0ZUxpdGVyYWxDb3VudGVyO1xuICAgIGh0bWxUZW1wbGF0ZUxpdGVyYWxDb3VudGVyID0gaHRtbFRlbXBsYXRlTGl0ZXJhbENvdW50ZXIgKyAxID4+PiAwO1xuXG4gICAgY29uc3QgY29tcG9zZVBsYWNlaG9sZGVyID0gaW5kZXggPT4gXCJQUkVUVElFUl9IVE1MX1BMQUNFSE9MREVSX1wiLmNvbmNhdChpbmRleCwgXCJfXCIpLmNvbmNhdChjb3VudGVyLCBcIl9JTl9KU1wiKTtcblxuICAgIGNvbnN0IHRleHQgPSBub2RlLnF1YXNpcy5tYXAoKHF1YXNpLCBpbmRleCwgcXVhc2lzKSA9PiBpbmRleCA9PT0gcXVhc2lzLmxlbmd0aCAtIDEgPyBxdWFzaS52YWx1ZS5jb29rZWQgOiBxdWFzaS52YWx1ZS5jb29rZWQgKyBjb21wb3NlUGxhY2Vob2xkZXIoaW5kZXgpKS5qb2luKFwiXCIpO1xuICAgIGNvbnN0IGV4cHJlc3Npb25Eb2NzID0gcGF0aC5tYXAocHJpbnQsIFwiZXhwcmVzc2lvbnNcIik7XG5cbiAgICBpZiAoZXhwcmVzc2lvbkRvY3MubGVuZ3RoID09PSAwICYmIHRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiYGBcIjtcbiAgICB9XG5cbiAgICBjb25zdCBwbGFjZWhvbGRlclJlZ2V4ID0gbmV3IFJlZ0V4cChjb21wb3NlUGxhY2Vob2xkZXIoXCIoXFxcXGQrKVwiKSwgXCJnXCIpO1xuICAgIGxldCB0b3BMZXZlbENvdW50ID0gMDtcbiAgICBjb25zdCBjb250ZW50RG9jID0gbWFwRG9jJDMoc3RyaXBUcmFpbGluZ0hhcmRsaW5lJDIodGV4dFRvRG9jKHRleHQsIHtcbiAgICAgIHBhcnNlcixcblxuICAgICAgX19vbkh0bWxSb290KHJvb3QpIHtcbiAgICAgICAgdG9wTGV2ZWxDb3VudCA9IHJvb3QuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgfSkpLCBkb2MgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkb2MgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBkb2Muc3BsaXQocGxhY2Vob2xkZXJSZWdleCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICBjb21wb25lbnQgPSB1bmNvb2soY29tcG9uZW50KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW1iZWRkZWRJbkh0bWwpIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50LnJlcGxhY2UoLzxcXC8oc2NyaXB0KVxcYi9naSwgXCI8XFxcXC8kMVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJJbmRleCA9ICtjb21wb25lbnQ7XG4gICAgICAgIHBhcnRzLnB1c2goY29uY2F0JGIoW1wiJHtcIiwgZ3JvdXAkYShleHByZXNzaW9uRG9jc1twbGFjZWhvbGRlckluZGV4XSksIFwifVwiXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0JGIocGFydHMpO1xuICAgIH0pO1xuICAgIGNvbnN0IGxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMvLnRlc3QodGV4dCkgPyBcIiBcIiA6IFwiXCI7XG4gICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlID0gL1xccyQvLnRlc3QodGV4dCkgPyBcIiBcIiA6IFwiXCI7XG4gICAgY29uc3QgbGluZWJyZWFrID0gb3B0aW9ucy5odG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5ID09PSBcImlnbm9yZVwiID8gaGFyZGxpbmUkOCA6IGxlYWRpbmdXaGl0ZXNwYWNlICYmIHRyYWlsaW5nV2hpdGVzcGFjZSA/IGxpbmUkNyA6IG51bGw7XG5cbiAgICBpZiAobGluZWJyZWFrKSB7XG4gICAgICByZXR1cm4gZ3JvdXAkYShjb25jYXQkYihbXCJgXCIsIGluZGVudCQ2KGNvbmNhdCRiKFtsaW5lYnJlYWssIGdyb3VwJGEoY29udGVudERvYyldKSksIGxpbmVicmVhaywgXCJgXCJdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwJGEoY29uY2F0JGIoW1wiYFwiLCBsZWFkaW5nV2hpdGVzcGFjZSwgdG9wTGV2ZWxDb3VudCA+IDEgPyBpbmRlbnQkNihncm91cCRhKGNvbnRlbnREb2MpKSA6IGdyb3VwJGEoY29udGVudERvYyksIHRyYWlsaW5nV2hpdGVzcGFjZSwgXCJgXCJdKSk7XG4gIH1cblxuICB2YXIgZW1iZWRfMSQxID0gZW1iZWQkMztcblxuICBmdW5jdGlvbiBjbGVhbiQ0KGFzdCwgbmV3T2JqLCBwYXJlbnQpIHtcbiAgICBbXCJyYW5nZVwiLCBcInJhd1wiLCBcImNvbW1lbnRzXCIsIFwibGVhZGluZ0NvbW1lbnRzXCIsIFwidHJhaWxpbmdDb21tZW50c1wiLCBcImlubmVyQ29tbWVudHNcIiwgXCJleHRyYVwiLCBcInN0YXJ0XCIsIFwiZW5kXCIsIFwiZmxhZ3NcIiwgXCJlcnJvcnNcIl0uZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGRlbGV0ZSBuZXdPYmpbbmFtZV07XG4gICAgfSk7XG5cbiAgICBpZiAoYXN0LmxvYyAmJiBhc3QubG9jLnNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlIG5ld09iai5sb2Muc291cmNlO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJCaWdJbnRMaXRlcmFsXCIpIHtcbiAgICAgIG5ld09iai52YWx1ZSA9IG5ld09iai52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0gLy8gV2UgcmVtb3ZlIGV4dHJhIGA7YCBhbmQgYWRkIHRoZW0gd2hlbiBuZWVkZWRcblxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIkVtcHR5U3RhdGVtZW50XCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gV2UgbW92ZSB0ZXh0IGFyb3VuZCwgaW5jbHVkaW5nIHdoaXRlc3BhY2VzIGFuZCBhZGQge1wiIFwifVxuXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiSlNYVGV4dFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiICYmIGFzdC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGFzdC5leHByZXNzaW9uLnZhbHVlID09PSBcIiBcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyAoVHlwZVNjcmlwdCkgSWdub3JlIGBzdGF0aWNgIGluIGBjb25zdHJ1Y3RvcihzdGF0aWMgcCkge31gXG4gICAgLy8gYW5kIGBleHBvcnRgIGluIGBjb25zdHJ1Y3RvcihleHBvcnQgcCkge31gXG5cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJUU1BhcmFtZXRlclByb3BlcnR5XCIgJiYgYXN0LmFjY2Vzc2liaWxpdHkgPT09IG51bGwgJiYgIWFzdC5yZWFkb25seSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgICAgIG5hbWU6IGFzdC5wYXJhbWV0ZXIubmFtZSxcbiAgICAgICAgdHlwZUFubm90YXRpb246IG5ld09iai5wYXJhbWV0ZXIudHlwZUFubm90YXRpb24sXG4gICAgICAgIGRlY29yYXRvcnM6IG5ld09iai5kZWNvcmF0b3JzXG4gICAgICB9O1xuICAgIH0gLy8gKFR5cGVTY3JpcHQpIGlnbm9yZSBlbXB0eSBgc3BlY2lmaWVyc2AgYXJyYXlcblxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIiAmJiBhc3Quc3BlY2lmaWVycyAmJiBhc3Quc3BlY2lmaWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmouc3BlY2lmaWVycztcbiAgICB9IC8vIFdlIGNvbnZlcnQgPGRpdj48L2Rpdj4gdG8gPGRpdiAvPlxuXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiSlNYT3BlbmluZ0VsZW1lbnRcIikge1xuICAgICAgZGVsZXRlIG5ld09iai5zZWxmQ2xvc2luZztcbiAgICB9XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiSlNYRWxlbWVudFwiKSB7XG4gICAgICBkZWxldGUgbmV3T2JqLmNsb3NpbmdFbGVtZW50O1xuICAgIH0gLy8gV2UgY2hhbmdlIHsna2V5JzogdmFsdWV9IGludG8ge2tleTogdmFsdWV9XG5cblxuICAgIGlmICgoYXN0LnR5cGUgPT09IFwiUHJvcGVydHlcIiB8fCBhc3QudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiIHx8IGFzdC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiB8fCBhc3QudHlwZSA9PT0gXCJDbGFzc1Byb3BlcnR5XCIgfHwgYXN0LnR5cGUgPT09IFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiIHx8IGFzdC50eXBlID09PSBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiKSAmJiB0eXBlb2YgYXN0LmtleSA9PT0gXCJvYmplY3RcIiAmJiBhc3Qua2V5ICYmIChhc3Qua2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiIHx8IGFzdC5rZXkudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgfHwgYXN0LmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikpIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmoua2V5O1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiAmJiBhc3Qub3B0aW9uYWwgPT09IGZhbHNlKSB7XG4gICAgICBuZXdPYmoudHlwZSA9IFwiTWVtYmVyRXhwcmVzc2lvblwiO1xuICAgICAgZGVsZXRlIG5ld09iai5vcHRpb25hbDtcbiAgICB9IC8vIFJlbW92ZSByYXcgYW5kIGNvb2tlZCB2YWx1ZXMgZnJvbSBUZW1wbGF0ZUVsZW1lbnQgd2hlbiBpdCdzIENTU1xuICAgIC8vIHN0eWxlZC1qc3hcblxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIkpTWEVsZW1lbnRcIiAmJiBhc3Qub3BlbmluZ0VsZW1lbnQubmFtZS5uYW1lID09PSBcInN0eWxlXCIgJiYgYXN0Lm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMuc29tZShhdHRyID0+IGF0dHIubmFtZS5uYW1lID09PSBcImpzeFwiKSkge1xuICAgICAgY29uc3QgdGVtcGxhdGVMaXRlcmFscyA9IG5ld09iai5jaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gY2hpbGQudHlwZSA9PT0gXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIgJiYgY2hpbGQuZXhwcmVzc2lvbi50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiKS5tYXAoY29udGFpbmVyID0+IGNvbnRhaW5lci5leHByZXNzaW9uKTtcbiAgICAgIGNvbnN0IHF1YXNpcyA9IHRlbXBsYXRlTGl0ZXJhbHMucmVkdWNlKChxdWFzaXMsIHRlbXBsYXRlTGl0ZXJhbCkgPT4gcXVhc2lzLmNvbmNhdCh0ZW1wbGF0ZUxpdGVyYWwucXVhc2lzKSwgW10pO1xuICAgICAgcXVhc2lzLmZvckVhY2gocSA9PiBkZWxldGUgcS52YWx1ZSk7XG4gICAgfSAvLyBDU1MgdGVtcGxhdGUgbGl0ZXJhbHMgaW4gY3NzIHByb3BcblxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIkpTWEF0dHJpYnV0ZVwiICYmIGFzdC5uYW1lLm5hbWUgPT09IFwiY3NzXCIgJiYgYXN0LnZhbHVlLnR5cGUgPT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiICYmIGFzdC52YWx1ZS5leHByZXNzaW9uLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIpIHtcbiAgICAgIG5ld09iai52YWx1ZS5leHByZXNzaW9uLnF1YXNpcy5mb3JFYWNoKHEgPT4gZGVsZXRlIHEudmFsdWUpO1xuICAgIH0gLy8gQW5ndWxhciBDb21wb25lbnRzOiBJbmxpbmUgSFRNTCB0ZW1wbGF0ZSBhbmQgSW5saW5lIENTUyBzdHlsZXNcblxuXG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGFzdC5leHByZXNzaW9uIHx8IGFzdC5jYWxsZWU7XG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiRGVjb3JhdG9yXCIgJiYgZXhwcmVzc2lvbi50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgJiYgZXhwcmVzc2lvbi5jYWxsZWUubmFtZSA9PT0gXCJDb21wb25lbnRcIiAmJiBleHByZXNzaW9uLmFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGFzdFByb3BzID0gYXN0LmV4cHJlc3Npb24uYXJndW1lbnRzWzBdLnByb3BlcnRpZXM7XG4gICAgICBuZXdPYmouZXhwcmVzc2lvbi5hcmd1bWVudHNbMF0ucHJvcGVydGllcy5mb3JFYWNoKChwcm9wLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdGVtcGxhdGVMaXRlcmFsID0gbnVsbDtcblxuICAgICAgICBzd2l0Y2ggKGFzdFByb3BzW2luZGV4XS5rZXkubmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJzdHlsZXNcIjpcbiAgICAgICAgICAgIGlmIChwcm9wLnZhbHVlLnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGVMaXRlcmFsID0gcHJvcC52YWx1ZS5lbGVtZW50c1swXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwidGVtcGxhdGVcIjpcbiAgICAgICAgICAgIGlmIChwcm9wLnZhbHVlLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIpIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGVMaXRlcmFsID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGVtcGxhdGVMaXRlcmFsKSB7XG4gICAgICAgICAgdGVtcGxhdGVMaXRlcmFsLnF1YXNpcy5mb3JFYWNoKHEgPT4gZGVsZXRlIHEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIHN0eWxlZC1jb21wb25lbnRzLCBncmFwaHFsLCBtYXJrZG93blxuXG5cbiAgICBpZiAoYXN0LnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgJiYgKGFzdC50YWcudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgYXN0LnRhZy50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAoYXN0LnRhZy5uYW1lID09PSBcImdxbFwiIHx8IGFzdC50YWcubmFtZSA9PT0gXCJncmFwaHFsXCIgfHwgYXN0LnRhZy5uYW1lID09PSBcImNzc1wiIHx8IGFzdC50YWcubmFtZSA9PT0gXCJtZFwiIHx8IGFzdC50YWcubmFtZSA9PT0gXCJtYXJrZG93blwiIHx8IGFzdC50YWcubmFtZSA9PT0gXCJodG1sXCIpIHx8IGFzdC50YWcudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSkge1xuICAgICAgbmV3T2JqLnF1YXNpLnF1YXNpcy5mb3JFYWNoKHF1YXNpID0+IGRlbGV0ZSBxdWFzaS52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiKSB7XG4gICAgICAvLyBUaGlzIGNoZWNrcyBmb3IgYSBsZWFkaW5nIGNvbW1lbnQgdGhhdCBpcyBleGFjdGx5IGAvKiBHcmFwaFFMICovYFxuICAgICAgLy8gSW4gb3JkZXIgdG8gYmUgaW4gbGluZSB3aXRoIG90aGVyIGltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGNvbW1lbnQgdGFnXG4gICAgICAvLyB3ZSB3aWxsIG5vdCB0cmltIHRoZSBjb21tZW50IHZhbHVlIGFuZCB3ZSB3aWxsIGV4cGVjdCBleGFjdGx5IG9uZSBzcGFjZSBvblxuICAgICAgLy8gZWl0aGVyIHNpZGUgb2YgdGhlIEdyYXBoUUwgc3RyaW5nXG4gICAgICAvLyBBbHNvIHNlZSAuL2VtYmVkLmpzXG4gICAgICBjb25zdCBoYXNMYW5ndWFnZUNvbW1lbnQgPSBhc3QubGVhZGluZ0NvbW1lbnRzICYmIGFzdC5sZWFkaW5nQ29tbWVudHMuc29tZShjb21tZW50ID0+IGNvbW1lbnQudHlwZSA9PT0gXCJDb21tZW50QmxvY2tcIiAmJiBbXCJHcmFwaFFMXCIsIFwiSFRNTFwiXS5zb21lKGxhbmd1YWdlTmFtZSA9PiBjb21tZW50LnZhbHVlID09PSBcIiBcIi5jb25jYXQobGFuZ3VhZ2VOYW1lLCBcIiBcIikpKTtcblxuICAgICAgaWYgKGhhc0xhbmd1YWdlQ29tbWVudCB8fCBwYXJlbnQudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiICYmIHBhcmVudC5jYWxsZWUubmFtZSA9PT0gXCJncmFwaHFsXCIpIHtcbiAgICAgICAgbmV3T2JqLnF1YXNpcy5mb3JFYWNoKHF1YXNpID0+IGRlbGV0ZSBxdWFzaS52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsZWFuXzEkMSA9IGNsZWFuJDQ7XG5cbiAgY29uc3Qge1xuICAgIGdldExhc3Q6IGdldExhc3QkMixcbiAgICBoYXNOZXdsaW5lOiBoYXNOZXdsaW5lJDQsXG4gICAgaGFzTmV3bGluZUluUmFuZ2U6IGhhc05ld2xpbmVJblJhbmdlJDIsXG4gICAgaGFzSWdub3JlQ29tbWVudDogaGFzSWdub3JlQ29tbWVudCQzLFxuICAgIGhhc05vZGVJZ25vcmVDb21tZW50OiBoYXNOb2RlSWdub3JlQ29tbWVudCQxLFxuICAgIHNraXBXaGl0ZXNwYWNlOiBza2lwV2hpdGVzcGFjZSQyXG4gIH0gPSB1dGlsJDE7XG4gIGNvbnN0IGlzSWRlbnRpZmllck5hbWUgPSB1dGlscyQxLmtleXdvcmQuaXNJZGVudGlmaWVyTmFtZUVTNTsgLy8gV2UgbWF0Y2ggYW55IHdoaXRlc3BhY2UgZXhjZXB0IGxpbmUgdGVybWluYXRvcnMgYmVjYXVzZVxuICAvLyBGbG93IGFubm90YXRpb24gY29tbWVudHMgY2Fubm90IGJlIHNwbGl0IGFjcm9zcyBsaW5lcy4gRm9yIGV4YW1wbGU6XG4gIC8vXG4gIC8vICh0aGlzIC8qXG4gIC8vIDogYW55ICovKS5mb28gPSA1O1xuICAvL1xuICAvLyBpcyBub3QgcGlja2VkIHVwIGJ5IEZsb3cgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNzA1MCksIHNvXG4gIC8vIHJlbW92aW5nIHRoZSBuZXdsaW5lIHdvdWxkIGNyZWF0ZSBhIHR5cGUgYW5ub3RhdGlvbiB0aGF0IHRoZSB1c2VyIGRpZCBub3QgaW50ZW5kXG4gIC8vIHRvIGNyZWF0ZS5cblxuICBjb25zdCBOT05fTElORV9URVJNSU5BVElOR19XSElURV9TUEFDRSA9IFwiKD86KD89LilcXFxccylcIjtcbiAgY29uc3QgRkxPV19TSE9SVEhBTkRfQU5OT1RBVElPTiA9IG5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KE5PTl9MSU5FX1RFUk1JTkFUSU5HX1dISVRFX1NQQUNFLCBcIio6XCIpKTtcbiAgY29uc3QgRkxPV19BTk5PVEFUSU9OID0gbmV3IFJlZ0V4cChcIl5cIi5jb25jYXQoTk9OX0xJTkVfVEVSTUlOQVRJTkdfV0hJVEVfU1BBQ0UsIFwiKjo6XCIpKTtcblxuICBmdW5jdGlvbiBoYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQobm9kZSkge1xuICAgIC8vIGh0dHBzOi8vZmxvdy5vcmcvZW4vZG9jcy90eXBlcy9jb21tZW50cy9cbiAgICAvLyBTeW50YXggZXhhbXBsZTogY29uc3QgciA9IG5ldyAod2luZG93LlJlcXVlc3QgLyo6IENsYXNzPFJlcXVlc3Q+ICovKShcIlwiKTtcbiAgICByZXR1cm4gbm9kZS5leHRyYSAmJiBub2RlLmV4dHJhLnBhcmVudGhlc2l6ZWQgJiYgbm9kZS50cmFpbGluZ0NvbW1lbnRzICYmIG5vZGUudHJhaWxpbmdDb21tZW50c1swXS52YWx1ZS5tYXRjaChGTE9XX1NIT1JUSEFORF9BTk5PVEFUSU9OKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudChjb21tZW50cykge1xuICAgIHJldHVybiBjb21tZW50cyAmJiBjb21tZW50c1swXS52YWx1ZS5tYXRjaChGTE9XX0FOTk9UQVRJT04pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzTm9kZShub2RlLCBmbikge1xuICAgIGlmICghbm9kZSB8fCB0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS5zb21lKHZhbHVlID0+IGhhc05vZGUodmFsdWUsIGZuKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gZm4obm9kZSk7XG4gICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT09IFwiYm9vbGVhblwiID8gcmVzdWx0IDogT2JqZWN0LmtleXMobm9kZSkuc29tZShrZXkgPT4gaGFzTm9kZShub2RlW2tleV0sIGZuKSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOYWtlZExlZnRTaWRlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkJpbmFyeUV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiTG9naWNhbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiTkdQaXBlRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkJpbmRFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlVwZGF0ZUV4cHJlc3Npb25cIiAmJiAhbm9kZS5wcmVmaXggfHwgbm9kZS50eXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExlZnRTaWRlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5leHByZXNzaW9ucykge1xuICAgICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbnNbMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUubGVmdCB8fCBub2RlLnRlc3QgfHwgbm9kZS5jYWxsZWUgfHwgbm9kZS5vYmplY3QgfHwgbm9kZS50YWcgfHwgbm9kZS5hcmd1bWVudCB8fCBub2RlLmV4cHJlc3Npb247XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMZWZ0U2lkZVBhdGhOYW1lKHBhdGgsIG5vZGUpIHtcbiAgICBpZiAobm9kZS5leHByZXNzaW9ucykge1xuICAgICAgcmV0dXJuIFtcImV4cHJlc3Npb25zXCIsIDBdO1xuICAgIH1cblxuICAgIGlmIChub2RlLmxlZnQpIHtcbiAgICAgIHJldHVybiBbXCJsZWZ0XCJdO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRlc3QpIHtcbiAgICAgIHJldHVybiBbXCJ0ZXN0XCJdO1xuICAgIH1cblxuICAgIGlmIChub2RlLm9iamVjdCkge1xuICAgICAgcmV0dXJuIFtcIm9iamVjdFwiXTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5jYWxsZWUpIHtcbiAgICAgIHJldHVybiBbXCJjYWxsZWVcIl07XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudGFnKSB7XG4gICAgICByZXR1cm4gW1widGFnXCJdO1xuICAgIH1cblxuICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICByZXR1cm4gW1wiYXJndW1lbnRcIl07XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuZXhwcmVzc2lvbikge1xuICAgICAgcmV0dXJuIFtcImV4cHJlc3Npb25cIl07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBub2RlIGhhcyBubyBsZWZ0IHNpZGVcIiwgbm9kZSk7XG4gIH1cblxuICBjb25zdCBleHBvcnREZWNsYXJhdGlvblR5cGVzID0gbmV3IFNldChbXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCJdKTtcblxuICBmdW5jdGlvbiBpc0V4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBleHBvcnREZWNsYXJhdGlvblR5cGVzLmhhcyhub2RlLnR5cGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50RXhwb3J0RGVjbGFyYXRpb24ocGF0aCkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgIGlmIChwYXRoLmdldE5hbWUoKSA9PT0gXCJkZWNsYXJhdGlvblwiICYmIGlzRXhwb3J0RGVjbGFyYXRpb24ocGFyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMaXRlcmFsKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkJvb2xlYW5MaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIkRpcmVjdGl2ZUxpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJOdWxsTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJOdW1lcmljTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJSZWdFeHBMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIlRTVHlwZUxpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiSlNYVGV4dFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW1lcmljTGl0ZXJhbChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJOdW1lcmljTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgdHlwZW9mIG5vZGUudmFsdWUgPT09IFwibnVtYmVyXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmluZ0xpdGVyYWwobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgdHlwZW9mIG5vZGUudmFsdWUgPT09IFwic3RyaW5nXCI7XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdFR5cGUobikge1xuICAgIHJldHVybiBuLnR5cGUgPT09IFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiB8fCBuLnR5cGUgPT09IFwiVFNUeXBlTGl0ZXJhbFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbk9yQXJyb3dFeHByZXNzaW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbk9yQXJyb3dFeHByZXNzaW9uV2l0aEJvZHkobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgbm9kZS5ib2R5LnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGVtcGxhdGVMaXRlcmFsKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiO1xuICB9IC8vIGBpbmplY3RgIGlzIHVzZWQgaW4gQW5ndWxhckpTIDEueCwgYGFzeW5jYCBpbiBBbmd1bGFyIDIrXG4gIC8vIGV4YW1wbGU6IGh0dHBzOi8vZG9jcy5hbmd1bGFyanMub3JnL2d1aWRlL3VuaXQtdGVzdGluZyN1c2luZy1iZWZvcmVhbGwtXG5cblxuICBmdW5jdGlvbiBpc0FuZ3VsYXJUZXN0V3JhcHBlcihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSAmJiBub2RlLmNhbGxlZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAobm9kZS5jYWxsZWUubmFtZSA9PT0gXCJhc3luY1wiIHx8IG5vZGUuY2FsbGVlLm5hbWUgPT09IFwiaW5qZWN0XCIgfHwgbm9kZS5jYWxsZWUubmFtZSA9PT0gXCJmYWtlQXN5bmNcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0pTWE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiSlNYRWxlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJKU1hGcmFnbWVudFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUaGVPbmx5SlNYRWxlbWVudEluTWFya2Rvd24ob3B0aW9ucywgcGF0aCkge1xuICAgIGlmIChvcHRpb25zLnBhcmVudFBhcnNlciAhPT0gXCJtYXJrZG93blwiICYmIG9wdGlvbnMucGFyZW50UGFyc2VyICE9PSBcIm1keFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKCFub2RlLmV4cHJlc3Npb24gfHwgIWlzSlNYTm9kZShub2RlLmV4cHJlc3Npb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgcmV0dXJuIHBhcmVudC50eXBlID09PSBcIlByb2dyYW1cIiAmJiBwYXJlbnQuYm9keS5sZW5ndGggPT09IDE7XG4gIH0gLy8gRGV0ZWN0IGFuIGV4cHJlc3Npb24gbm9kZSByZXByZXNlbnRpbmcgYHtcIiBcIn1gXG5cblxuICBmdW5jdGlvbiBpc0pTWFdoaXRlc3BhY2VFeHByZXNzaW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiAmJiBpc0xpdGVyYWwobm9kZS5leHByZXNzaW9uKSAmJiBub2RlLmV4cHJlc3Npb24udmFsdWUgPT09IFwiIFwiICYmICFub2RlLmV4cHJlc3Npb24uY29tbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBpc01lbWJlckV4cHJlc3Npb25DaGFpbihub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbm9kZS50eXBlICE9PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUub2JqZWN0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNNZW1iZXJFeHByZXNzaW9uQ2hhaW4obm9kZS5vYmplY3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNHZXR0ZXJPclNldHRlcihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUua2luZCA9PT0gXCJnZXRcIiB8fCBub2RlLmtpbmQgPT09IFwic2V0XCI7XG4gIH1cblxuICBmdW5jdGlvbiBzYW1lTG9jU3RhcnQobm9kZUEsIG5vZGVCLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9jU3RhcnQobm9kZUEpID09PSBvcHRpb25zLmxvY1N0YXJ0KG5vZGVCKTtcbiAgfSAvLyBUT0RPOiBUaGlzIGlzIGEgYmFkIGhhY2sgYW5kIHdlIG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gYXJyb3cgZnVuY3Rpb25zIGFuZCBvdGhlcndpc2VcblxuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb25Ob3RhdGlvbihub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGlzR2V0dGVyT3JTZXR0ZXIobm9kZSkgfHwgc2FtZUxvY1N0YXJ0KG5vZGUsIG5vZGUudmFsdWUsIG9wdGlvbnMpO1xuICB9IC8vIEhhY2sgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSBmb2xsb3dpbmcgdHdvIHdoaWNoIGhhdmUgdGhlIHNhbWUgYXN0XG4gIC8vIHR5cGUgVCA9IHsgbWV0aG9kOiAoKSA9PiB2b2lkIH07XG4gIC8vIHR5cGUgVCA9IHsgbWV0aG9kKCk6IHZvaWQgfTtcblxuXG4gIGZ1bmN0aW9uIGlzT2JqZWN0VHlwZVByb3BlcnR5QUZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG5vZGUudHlwZSA9PT0gXCJPYmplY3RUeXBlUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKSAmJiBub2RlLnZhbHVlLnR5cGUgPT09IFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiICYmICFub2RlLnN0YXRpYyAmJiAhaXNGdW5jdGlvbk5vdGF0aW9uKG5vZGUsIG9wdGlvbnMpO1xuICB9IC8vIEhhY2sgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSBmb2xsb3dpbmcgdHdvIHdoaWNoIGhhdmUgdGhlIHNhbWUgYXN0XG4gIC8vIGRlY2xhcmUgZnVuY3Rpb24gZihhKTogdm9pZDtcbiAgLy8gdmFyIGY6IChhKSA9PiB2b2lkO1xuXG5cbiAgZnVuY3Rpb24gaXNUeXBlQW5ub3RhdGlvbkFGdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIChub2RlLnR5cGUgPT09IFwiVHlwZUFubm90YXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVFNUeXBlQW5ub3RhdGlvblwiKSAmJiBub2RlLnR5cGVBbm5vdGF0aW9uLnR5cGUgPT09IFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiICYmICFub2RlLnN0YXRpYyAmJiAhc2FtZUxvY1N0YXJ0KG5vZGUsIG5vZGUudHlwZUFubm90YXRpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgYmluYXJ5aXNoTm9kZVR5cGVzID0gbmV3IFNldChbXCJCaW5hcnlFeHByZXNzaW9uXCIsIFwiTG9naWNhbEV4cHJlc3Npb25cIiwgXCJOR1BpcGVFeHByZXNzaW9uXCJdKTtcblxuICBmdW5jdGlvbiBpc0JpbmFyeWlzaChub2RlKSB7XG4gICAgcmV0dXJuIGJpbmFyeWlzaE5vZGVUeXBlcy5oYXMobm9kZS50eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTWVtYmVyaXNoKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkJpbmRFeHByZXNzaW9uXCIgJiYgbm9kZS5vYmplY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBpc1NpbXBsZUZsb3dUeXBlKG5vZGUpIHtcbiAgICBjb25zdCBmbG93VHlwZUFubm90YXRpb25zID0gW1wiQW55VHlwZUFubm90YXRpb25cIiwgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIsIFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIsIFwiTnVtYmVyVHlwZUFubm90YXRpb25cIiwgXCJWb2lkVHlwZUFubm90YXRpb25cIiwgXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIsIFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiLCBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiLCBcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiwgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiXTtcbiAgICByZXR1cm4gbm9kZSAmJiBmbG93VHlwZUFubm90YXRpb25zLmluY2x1ZGVzKG5vZGUudHlwZSkgJiYgIShub2RlLnR5cGUgPT09IFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIgJiYgbm9kZS50eXBlUGFyYW1ldGVycyk7XG4gIH1cblxuICBjb25zdCB1bml0VGVzdFJlID0gL14oc2tpcHxbZnhdPyhpdHxkZXNjcmliZXx0ZXN0KSkkLztcblxuICBmdW5jdGlvbiBpc1NraXBPck9ubHlCbG9jayhub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmNhbGxlZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBub2RlLmNhbGxlZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSAmJiBub2RlLmNhbGxlZS5vYmplY3QudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbm9kZS5jYWxsZWUucHJvcGVydHkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdW5pdFRlc3RSZS50ZXN0KG5vZGUuY2FsbGVlLm9iamVjdC5uYW1lKSAmJiAobm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gXCJvbmx5XCIgfHwgbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gXCJza2lwXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNVbml0VGVzdFNldFVwKG4pIHtcbiAgICBjb25zdCB1bml0VGVzdFNldFVwUmUgPSAvXihiZWZvcmV8YWZ0ZXIpKEVhY2h8QWxsKSQvO1xuICAgIHJldHVybiBuLmNhbGxlZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB1bml0VGVzdFNldFVwUmUudGVzdChuLmNhbGxlZS5uYW1lKSAmJiBuLmFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG4gIH0gLy8gZWc7IGBkZXNjcmliZShcInNvbWUgc3RyaW5nXCIsIChkb25lKSA9PiB7fSlgXG5cblxuICBmdW5jdGlvbiBpc1Rlc3RDYWxsKG4sIHBhcmVudCkge1xuICAgIGlmIChuLnR5cGUgIT09IFwiQ2FsbEV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChuLmFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChpc0FuZ3VsYXJUZXN0V3JhcHBlcihuKSAmJiBwYXJlbnQgJiYgaXNUZXN0Q2FsbChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb24obi5hcmd1bWVudHNbMF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNVbml0VGVzdFNldFVwKG4pKSB7XG4gICAgICAgIHJldHVybiBpc0FuZ3VsYXJUZXN0V3JhcHBlcihuLmFyZ3VtZW50c1swXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuLmFyZ3VtZW50cy5sZW5ndGggPT09IDIgfHwgbi5hcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoKG4uY2FsbGVlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHVuaXRUZXN0UmUudGVzdChuLmNhbGxlZS5uYW1lKSB8fCBpc1NraXBPck9ubHlCbG9jayhuKSkgJiYgKGlzVGVtcGxhdGVMaXRlcmFsKG4uYXJndW1lbnRzWzBdKSB8fCBpc1N0cmluZ0xpdGVyYWwobi5hcmd1bWVudHNbMF0pKSkge1xuICAgICAgICAvLyBpdChcIm5hbWVcIiwgKCkgPT4geyAuLi4gfSwgMjUwMClcbiAgICAgICAgaWYgKG4uYXJndW1lbnRzWzJdICYmICFpc051bWVyaWNMaXRlcmFsKG4uYXJndW1lbnRzWzJdKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobi5hcmd1bWVudHMubGVuZ3RoID09PSAyID8gaXNGdW5jdGlvbk9yQXJyb3dFeHByZXNzaW9uKG4uYXJndW1lbnRzWzFdKSA6IGlzRnVuY3Rpb25PckFycm93RXhwcmVzc2lvbldpdGhCb2R5KG4uYXJndW1lbnRzWzFdKSAmJiBuLmFyZ3VtZW50c1sxXS5wYXJhbXMubGVuZ3RoIDw9IDEpIHx8IGlzQW5ndWxhclRlc3RXcmFwcGVyKG4uYXJndW1lbnRzWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNMZWFkaW5nQ29tbWVudCQyKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jb21tZW50cyAmJiBub2RlLmNvbW1lbnRzLnNvbWUoY29tbWVudCA9PiBjb21tZW50LmxlYWRpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzVHJhaWxpbmdDb21tZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jb21tZW50cyAmJiBub2RlLmNvbW1lbnRzLnNvbWUoY29tbWVudCA9PiBjb21tZW50LnRyYWlsaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ2FsbE9yT3B0aW9uYWxDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNEYW5nbGluZ0NvbW1lbnRzKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5jb21tZW50cyAmJiBub2RlLmNvbW1lbnRzLnNvbWUoY29tbWVudCA9PiAhY29tbWVudC5sZWFkaW5nICYmICFjb21tZW50LnRyYWlsaW5nKTtcbiAgfVxuICAvKiogaWRlbnRpZnkgaWYgYW4gYW5ndWxhciBleHByZXNzaW9uIHNlZW1zIHRvIGhhdmUgc2lkZSBlZmZlY3RzICovXG5cblxuICBmdW5jdGlvbiBoYXNOZ1NpZGVFZmZlY3QocGF0aCkge1xuICAgIHJldHVybiBoYXNOb2RlKHBhdGguZ2V0VmFsdWUoKSwgbm9kZSA9PiB7XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOZ0Zvck9mKG5vZGUsIGluZGV4LCBwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJOR01pY3Jvc3ludGF4S2V5ZWRFeHByZXNzaW9uXCIgJiYgbm9kZS5rZXkubmFtZSA9PT0gXCJvZlwiICYmIGluZGV4ID09PSAxICYmIHBhcmVudE5vZGUuYm9keVswXS50eXBlID09PSBcIk5HTWljcm9zeW50YXhMZXRcIiAmJiBwYXJlbnROb2RlLmJvZHlbMF0udmFsdWUgPT09IG51bGw7XG4gIH1cbiAgLyoqIEBwYXJhbSBub2RlIHtpbXBvcnQoXCJlc3RyZWVcIikuVGVtcGxhdGVMaXRlcmFsfSAqL1xuXG5cbiAgZnVuY3Rpb24gaXNTaW1wbGVUZW1wbGF0ZUxpdGVyYWwobm9kZSkge1xuICAgIGlmIChub2RlLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlLmV4cHJlc3Npb25zLmV2ZXJ5KGV4cHIgPT4ge1xuICAgICAgLy8gRGlzYWxsb3cgY29tbWVudHMgc2luY2UgcHJpbnREb2NUb1N0cmluZyBjYW4ndCBwcmludCB0aGVtIGhlcmVcbiAgICAgIGlmIChleHByLmNvbW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gQWxsb3cgYHhgIGFuZCBgdGhpc2BcblxuXG4gICAgICBpZiAoZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCBleHByLnR5cGUgPT09IFwiVGhpc0V4cHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gQWxsb3cgYGEuYi5jYCwgYGEuYltjXWAsIGFuZCBgdGhpcy54LnlgXG5cblxuICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgZXhwci50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGxldCBoZWFkID0gZXhwcjtcblxuICAgICAgICB3aGlsZSAoaGVhZC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBoZWFkLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICBpZiAoaGVhZC5wcm9wZXJ0eS50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBoZWFkLnByb3BlcnR5LnR5cGUgIT09IFwiTGl0ZXJhbFwiICYmIGhlYWQucHJvcGVydHkudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYgaGVhZC5wcm9wZXJ0eS50eXBlICE9PSBcIk51bWVyaWNMaXRlcmFsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoZWFkID0gaGVhZC5vYmplY3Q7XG5cbiAgICAgICAgICBpZiAoaGVhZC5jb21tZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWFkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGhlYWQudHlwZSA9PT0gXCJUaGlzRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZsb3dWYXJpYW5jZShwYXRoKSB7XG4gICAgaWYgKCFwYXRoLnZhcmlhbmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIEJhYmVsIDcuMCBjdXJyZW50bHkgdXNlcyB2YXJpYW5jZSBub2RlIHR5cGUsIGFuZCBmbG93IHNob3VsZFxuICAgIC8vIGZvbGxvdyBzdWl0IHNvb246XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlcy80NzIyXG5cblxuICAgIGNvbnN0IHZhcmlhbmNlID0gcGF0aC52YXJpYW5jZS5raW5kIHx8IHBhdGgudmFyaWFuY2U7XG5cbiAgICBzd2l0Y2ggKHZhcmlhbmNlKSB7XG4gICAgICBjYXNlIFwicGx1c1wiOlxuICAgICAgICByZXR1cm4gXCIrXCI7XG5cbiAgICAgIGNhc2UgXCJtaW51c1wiOlxuICAgICAgICByZXR1cm4gXCItXCI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiB2YXJpYW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGFzc1Byb3BNYXlDYXVzZUFTSVByb2JsZW1zKHBhdGgpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXROb2RlKCk7XG5cbiAgICBpZiAobm9kZS50eXBlICE9PSBcIkNsYXNzUHJvcGVydHlcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBub2RlLmtleSAmJiBub2RlLmtleS5uYW1lOyAvLyB0aGlzIGlzbid0IGFjdHVhbGx5IHBvc3NpYmxlIHlldCB3aXRoIG1vc3QgcGFyc2VycyBhdmFpbGFibGUgdG9kYXlcbiAgICAvLyBzbyBpc24ndCBwcm9wZXJseSB0ZXN0ZWQgeWV0LlxuXG4gICAgaWYgKChuYW1lID09PSBcInN0YXRpY1wiIHx8IG5hbWUgPT09IFwiZ2V0XCIgfHwgbmFtZSA9PT0gXCJzZXRcIikgJiYgIW5vZGUudmFsdWUgJiYgIW5vZGUudHlwZUFubm90YXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzQ2hpbGROZWVkc0FTSVByb3RlY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLmFjY2Vzc2liaWxpdHkgLy8gVHlwZVNjcmlwdFxuICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBpZiAoIW5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLmtleSAmJiBub2RlLmtleS5uYW1lO1xuXG4gICAgICBpZiAobmFtZSA9PT0gXCJpblwiIHx8IG5hbWUgPT09IFwiaW5zdGFuY2VvZlwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiQ2xhc3NQcm9wZXJ0eVwiOlxuICAgICAgY2FzZSBcIlRTQWJzdHJhY3RDbGFzc1Byb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiBub2RlLmNvbXB1dGVkO1xuXG4gICAgICBjYXNlIFwiTWV0aG9kRGVmaW5pdGlvblwiOiAvLyBGbG93XG5cbiAgICAgIGNhc2UgXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiOiAvLyBUeXBlU2NyaXB0XG5cbiAgICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gQmFiZWxcbiAgICAgICAgICBjb25zdCBpc0FzeW5jID0gbm9kZS52YWx1ZSA/IG5vZGUudmFsdWUuYXN5bmMgOiBub2RlLmFzeW5jO1xuICAgICAgICAgIGNvbnN0IGlzR2VuZXJhdG9yID0gbm9kZS52YWx1ZSA/IG5vZGUudmFsdWUuZ2VuZXJhdG9yIDogbm9kZS5nZW5lcmF0b3I7XG5cbiAgICAgICAgICBpZiAoaXNBc3luYyB8fCBub2RlLmtpbmQgPT09IFwiZ2V0XCIgfHwgbm9kZS5raW5kID09PSBcInNldFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGUuY29tcHV0ZWQgfHwgaXNHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVFNJbmRleFNpZ25hdHVyZVwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFR5cGVTY3JpcHRNYXBwZWRUeXBlTW9kaWZpZXIodG9rZW5Ob2RlLCBrZXl3b3JkKSB7XG4gICAgaWYgKHRva2VuTm9kZSA9PT0gXCIrXCIpIHtcbiAgICAgIHJldHVybiBcIitcIiArIGtleXdvcmQ7XG4gICAgfSBlbHNlIGlmICh0b2tlbk5vZGUgPT09IFwiLVwiKSB7XG4gICAgICByZXR1cm4gXCItXCIgKyBrZXl3b3JkO1xuICAgIH1cblxuICAgIHJldHVybiBrZXl3b3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzTmV3bGluZUJldHdlZW5PckFmdGVyRGVjb3JhdG9ycyhub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGhhc05ld2xpbmVJblJhbmdlJDIob3B0aW9ucy5vcmlnaW5hbFRleHQsIG9wdGlvbnMubG9jU3RhcnQobm9kZS5kZWNvcmF0b3JzWzBdKSwgb3B0aW9ucy5sb2NFbmQoZ2V0TGFzdCQyKG5vZGUuZGVjb3JhdG9ycykpKSB8fCBoYXNOZXdsaW5lJDQob3B0aW9ucy5vcmlnaW5hbFRleHQsIG9wdGlvbnMubG9jRW5kKGdldExhc3QkMihub2RlLmRlY29yYXRvcnMpKSk7XG4gIH0gLy8gT25seSBzcGFjZSwgbmV3bGluZSwgY2FycmlhZ2UgcmV0dXJuLCBhbmQgdGFiIGFyZSB0cmVhdGVkIGFzIHdoaXRlc3BhY2VcbiAgLy8gaW5zaWRlIEpTWC5cblxuXG4gIGNvbnN0IGpzeFdoaXRlc3BhY2VDaGFycyA9IFwiIFxcblxcclxcdFwiO1xuICBjb25zdCBtYXRjaEpzeFdoaXRlc3BhY2VSZWdleCA9IG5ldyBSZWdFeHAoXCIoW1wiICsganN4V2hpdGVzcGFjZUNoYXJzICsgXCJdKylcIik7XG4gIGNvbnN0IGNvbnRhaW5zTm9uSnN4V2hpdGVzcGFjZVJlZ2V4ID0gbmV3IFJlZ0V4cChcIlteXCIgKyBqc3hXaGl0ZXNwYWNlQ2hhcnMgKyBcIl1cIik7IC8vIE1lYW5pbmdmdWwgaWYgaXQgY29udGFpbnMgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyxcbiAgLy8gb3IgaXQgY29udGFpbnMgd2hpdGVzcGFjZSB3aXRob3V0IGEgbmV3IGxpbmUuXG5cbiAgZnVuY3Rpb24gaXNNZWFuaW5nZnVsSlNYVGV4dChub2RlKSB7XG4gICAgcmV0dXJuIGlzTGl0ZXJhbChub2RlKSAmJiAoY29udGFpbnNOb25Kc3hXaGl0ZXNwYWNlUmVnZXgudGVzdChyYXdUZXh0KG5vZGUpKSB8fCAhL1xcbi8udGVzdChyYXdUZXh0KG5vZGUpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNKc3hJZ25vcmVDb21tZW50KHBhdGgpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIW5vZGUgfHwgIWlzSlNYTm9kZShub2RlKSB8fCAhaXNKU1hOb2RlKHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIExvb2t1cCB0aGUgcHJldmlvdXMgc2libGluZywgaWdub3JpbmcgYW55IGVtcHR5IEpTWFRleHQgZWxlbWVudHNcblxuXG4gICAgY29uc3QgaW5kZXggPSBwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICBsZXQgcHJldlNpYmxpbmcgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IGluZGV4OyBpID4gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBwYXJlbnQuY2hpbGRyZW5baSAtIDFdO1xuXG4gICAgICBpZiAoY2FuZGlkYXRlLnR5cGUgPT09IFwiSlNYVGV4dFwiICYmICFpc01lYW5pbmdmdWxKU1hUZXh0KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHByZXZTaWJsaW5nID0gY2FuZGlkYXRlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZTaWJsaW5nICYmIHByZXZTaWJsaW5nLnR5cGUgPT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiICYmIHByZXZTaWJsaW5nLmV4cHJlc3Npb24udHlwZSA9PT0gXCJKU1hFbXB0eUV4cHJlc3Npb25cIiAmJiBwcmV2U2libGluZy5leHByZXNzaW9uLmNvbW1lbnRzICYmIHByZXZTaWJsaW5nLmV4cHJlc3Npb24uY29tbWVudHMuZmluZChjb21tZW50ID0+IGNvbW1lbnQudmFsdWUudHJpbSgpID09PSBcInByZXR0aWVyLWlnbm9yZVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRW1wdHlKU1hFbGVtZW50KG5vZGUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGlmIHRoZXJlIGlzIG9uZSB0ZXh0IGNoaWxkIGFuZCBkb2VzIG5vdCBjb250YWluIGFueSBtZWFuaW5nZnVsIHRleHRcbiAgICAvLyB3ZSBjYW4gdHJlYXQgdGhlIGVsZW1lbnQgYXMgZW1wdHkuXG5cblxuICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gaXNMaXRlcmFsKGNoaWxkKSAmJiAhaXNNZWFuaW5nZnVsSlNYVGV4dChjaGlsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQcmV0dGllcklnbm9yZSQ0KHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSWdub3JlQ29tbWVudCQzKHBhdGgpIHx8IGhhc0pzeElnbm9yZUNvbW1lbnQocGF0aCk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xhc3RTdGF0ZW1lbnQocGF0aCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgYm9keSA9IChwYXJlbnQuYm9keSB8fCBwYXJlbnQuY29uc2VxdWVudCkuZmlsdGVyKHN0bXQgPT4gc3RtdC50eXBlICE9PSBcIkVtcHR5U3RhdGVtZW50XCIpO1xuICAgIHJldHVybiBib2R5ICYmIGJvZHlbYm9keS5sZW5ndGggLSAxXSA9PT0gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmxvd0Fubm90YXRpb25Db21tZW50KHRleHQsIHR5cGVBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBvcHRpb25zLmxvY1N0YXJ0KHR5cGVBbm5vdGF0aW9uKTtcbiAgICBjb25zdCBlbmQgPSBza2lwV2hpdGVzcGFjZSQyKHRleHQsIG9wdGlvbnMubG9jRW5kKHR5cGVBbm5vdGF0aW9uKSk7XG4gICAgcmV0dXJuIHRleHQuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgMikgPT09IFwiLypcIiAmJiB0ZXh0LnNsaWNlKGVuZCwgZW5kICsgMikgPT09IFwiKi9cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudCh0ZXh0LCBub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzSlNYTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIGhhc05vZGVJZ25vcmVDb21tZW50JDEobm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gbm9kZS5jb21tZW50cyAmJiBub2RlLmNvbW1lbnRzLnNvbWUoY29tbWVudCA9PiBjb21tZW50LmxlYWRpbmcgJiYgaGFzTmV3bGluZSQ0KHRleHQsIG9wdGlvbnMubG9jRW5kKGNvbW1lbnQpKSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBUaGlzIHJlY3Vyc2VzIHRoZSByZXR1cm4gYXJndW1lbnQsIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCB0b2tlblxuICAvLyAodGhlIGxlZnRtb3N0IGxlYWYgbm9kZSkgYW5kLCBpZiBpdCAob3IgaXRzIHBhcmVudHMpIGhhcyBhbnlcbiAgLy8gbGVhZGluZ0NvbW1lbnRzLCByZXR1cm5zIHRydWUgKHNvIGl0IGNhbiBiZSB3cmFwcGVkIGluIHBhcmVucykuXG5cblxuICBmdW5jdGlvbiByZXR1cm5Bcmd1bWVudEhhc0xlYWRpbmdDb21tZW50KG9wdGlvbnMsIGFyZ3VtZW50KSB7XG4gICAgaWYgKGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudChvcHRpb25zLm9yaWdpbmFsVGV4dCwgYXJndW1lbnQsIG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaGFzTmFrZWRMZWZ0U2lkZShhcmd1bWVudCkpIHtcbiAgICAgIGxldCBsZWZ0TW9zdCA9IGFyZ3VtZW50O1xuICAgICAgbGV0IG5ld0xlZnRNb3N0O1xuXG4gICAgICB3aGlsZSAobmV3TGVmdE1vc3QgPSBnZXRMZWZ0U2lkZShsZWZ0TW9zdCkpIHtcbiAgICAgICAgbGVmdE1vc3QgPSBuZXdMZWZ0TW9zdDtcblxuICAgICAgICBpZiAoaGFzTGVhZGluZ093bkxpbmVDb21tZW50KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBsZWZ0TW9zdCwgb3B0aW9ucykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RyaW5nUHJvcFNhZmVUb0NvZXJjZVRvSWRlbnRpZmllcihub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nTGl0ZXJhbChub2RlLmtleSkgJiYgaXNJZGVudGlmaWVyTmFtZShub2RlLmtleS52YWx1ZSkgJiYgb3B0aW9ucy5wYXJzZXIgIT09IFwianNvblwiICYmIC8vIFdpdGggYC0tc3RyaWN0UHJvcGVydHlJbml0aWFsaXphdGlvbmAsIFRTIHRyZWF0cyBwcm9wZXJ0aWVzIHdpdGggcXVvdGVkIG5hbWVzIGRpZmZlcmVudGx5IHRoYW4gdW5xdW90ZWQgb25lcy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L3B1bGwvMjAwNzVcbiAgICAhKChvcHRpb25zLnBhcnNlciA9PT0gXCJ0eXBlc2NyaXB0XCIgfHwgb3B0aW9ucy5wYXJzZXIgPT09IFwiYmFiZWwtdHNcIikgJiYgbm9kZS50eXBlID09PSBcIkNsYXNzUHJvcGVydHlcIik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0plc3RFYWNoVGVtcGxhdGVMaXRlcmFsKG5vZGUsIHBhcmVudE5vZGUpIHtcbiAgICAvKipcbiAgICAgKiBkZXNjcmliZS5lYWNoYHRhYmxlYChuYW1lLCBmbilcbiAgICAgKiBkZXNjcmliZS5vbmx5LmVhY2hgdGFibGVgKG5hbWUsIGZuKVxuICAgICAqIGRlc2NyaWJlLnNraXAuZWFjaGB0YWJsZWAobmFtZSwgZm4pXG4gICAgICogdGVzdC5lYWNoYHRhYmxlYChuYW1lLCBmbilcbiAgICAgKiB0ZXN0Lm9ubHkuZWFjaGB0YWJsZWAobmFtZSwgZm4pXG4gICAgICogdGVzdC5za2lwLmVhY2hgdGFibGVgKG5hbWUsIGZuKVxuICAgICAqXG4gICAgICogUmVmOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svamVzdC9wdWxsLzYxMDJcbiAgICAgKi9cbiAgICBjb25zdCBqZXN0RWFjaFRyaWdnZXJSZWdleCA9IC9eW3hmXT8oZGVzY3JpYmV8aXR8dGVzdCkkLztcbiAgICByZXR1cm4gcGFyZW50Tm9kZS50eXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiICYmIHBhcmVudE5vZGUucXVhc2kgPT09IG5vZGUgJiYgcGFyZW50Tm9kZS50YWcudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgcGFyZW50Tm9kZS50YWcucHJvcGVydHkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyZW50Tm9kZS50YWcucHJvcGVydHkubmFtZSA9PT0gXCJlYWNoXCIgJiYgKHBhcmVudE5vZGUudGFnLm9iamVjdC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBqZXN0RWFjaFRyaWdnZXJSZWdleC50ZXN0KHBhcmVudE5vZGUudGFnLm9iamVjdC5uYW1lKSB8fCBwYXJlbnROb2RlLnRhZy5vYmplY3QudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgcGFyZW50Tm9kZS50YWcub2JqZWN0LnByb3BlcnR5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChwYXJlbnROb2RlLnRhZy5vYmplY3QucHJvcGVydHkubmFtZSA9PT0gXCJvbmx5XCIgfHwgcGFyZW50Tm9kZS50YWcub2JqZWN0LnByb3BlcnR5Lm5hbWUgPT09IFwic2tpcFwiKSAmJiBwYXJlbnROb2RlLnRhZy5vYmplY3Qub2JqZWN0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGplc3RFYWNoVHJpZ2dlclJlZ2V4LnRlc3QocGFyZW50Tm9kZS50YWcub2JqZWN0Lm9iamVjdC5uYW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0ZW1wbGF0ZUxpdGVyYWxIYXNOZXdMaW5lcyh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZS5xdWFzaXMuc29tZShxdWFzaSA9PiBxdWFzaS52YWx1ZS5yYXcuaW5jbHVkZXMoXCJcXG5cIikpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUZW1wbGF0ZU9uSXRzT3duTGluZShuLCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIChuLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgJiYgdGVtcGxhdGVMaXRlcmFsSGFzTmV3TGluZXMobikgfHwgbi50eXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiICYmIHRlbXBsYXRlTGl0ZXJhbEhhc05ld0xpbmVzKG4ucXVhc2kpKSAmJiAhaGFzTmV3bGluZSQ0KHRleHQsIG9wdGlvbnMubG9jU3RhcnQobiksIHtcbiAgICAgIGJhY2t3YXJkczogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNIYXJkbGluZUFmdGVyRGFuZ2xpbmdDb21tZW50KG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuY29tbWVudHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0RGFuZ2xpbmdDb21tZW50ID0gZ2V0TGFzdCQyKG5vZGUuY29tbWVudHMuZmlsdGVyKGNvbW1lbnQgPT4gIWNvbW1lbnQubGVhZGluZyAmJiAhY29tbWVudC50cmFpbGluZykpO1xuICAgIHJldHVybiBsYXN0RGFuZ2xpbmdDb21tZW50ICYmICFjb21tZW50cyQxLmlzQmxvY2tDb21tZW50KGxhc3REYW5nbGluZ0NvbW1lbnQpO1xuICB9IC8vIElmIHdlIGhhdmUgbmVzdGVkIGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zLCB3ZSB3YW50IHRvIHByaW50IHRoZW0gaW4gSlNYIG1vZGVcbiAgLy8gaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgSlNYRWxlbWVudCBzb21ld2hlcmUgaW4gdGhlIHRyZWUuXG4gIC8vXG4gIC8vIEEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBjaGFpbiBsaWtlIHRoaXMgc2hvdWxkIGJlIHByaW50ZWQgaW4gbm9ybWFsIG1vZGUsXG4gIC8vIGJlY2F1c2UgdGhlcmUgYXJlbid0IEpTWEVsZW1lbnRzIGFueXdoZXJlIGluIGl0OlxuICAvL1xuICAvLyBpc0EgPyBcIkFcIiA6IGlzQiA/IFwiQlwiIDogaXNDID8gXCJDXCIgOiBcIlVua25vd25cIjtcbiAgLy9cbiAgLy8gQnV0IGEgY29uZGl0aW9uYWwgZXhwcmVzc2lvbiBjaGFpbiBsaWtlIHRoaXMgc2hvdWxkIGJlIHByaW50ZWQgaW4gSlNYIG1vZGUsXG4gIC8vIGJlY2F1c2UgdGhlcmUgaXMgYSBKU1hFbGVtZW50IGluIHRoZSBsYXN0IENvbmRpdGlvbmFsRXhwcmVzc2lvbjpcbiAgLy9cbiAgLy8gaXNBID8gXCJBXCIgOiBpc0IgPyBcIkJcIiA6IGlzQyA/IFwiQ1wiIDogPHNwYW4gY2xhc3NOYW1lPVwid2FybmluZ1wiPlVua25vd248L3NwYW4+O1xuICAvL1xuICAvLyBUaGlzIHR5cGUgb2YgQ29uZGl0aW9uYWxFeHByZXNzaW9uIGNoYWluIGlzIHN0cnVjdHVyZWQgbGlrZSB0aGlzIGluIHRoZSBBU1Q6XG4gIC8vXG4gIC8vIENvbmRpdGlvbmFsRXhwcmVzc2lvbiB7XG4gIC8vICAgdGVzdDogLi4uLFxuICAvLyAgIGNvbnNlcXVlbnQ6IC4uLixcbiAgLy8gICBhbHRlcm5hdGU6IENvbmRpdGlvbmFsRXhwcmVzc2lvbiB7XG4gIC8vICAgICB0ZXN0OiAuLi4sXG4gIC8vICAgICBjb25zZXF1ZW50OiAuLi4sXG4gIC8vICAgICBhbHRlcm5hdGU6IENvbmRpdGlvbmFsRXhwcmVzc2lvbiB7XG4gIC8vICAgICAgIHRlc3Q6IC4uLixcbiAgLy8gICAgICAgY29uc2VxdWVudDogLi4uLFxuICAvLyAgICAgICBhbHRlcm5hdGU6IC4uLixcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vIH1cbiAgLy9cbiAgLy8gV2Ugd2FudCB0byB0cmF2ZXJzZSBvdmVyIHRoYXQgc2hhcGUgYW5kIGNvbnZlcnQgaXQgaW50byBhIGZsYXQgc3RydWN0dXJlIHNvXG4gIC8vIHRoYXQgd2UgY2FuIGZpbmQgaWYgdGhlcmUncyBhIEpTWEVsZW1lbnQgc29tZXdoZXJlIGluc2lkZS5cblxuXG4gIGZ1bmN0aW9uIGdldENvbmRpdGlvbmFsQ2hhaW5Db250ZW50cyhub2RlKSB7XG4gICAgLy8gR2l2ZW4gdGhpcyBjb2RlOlxuICAgIC8vXG4gICAgLy8gLy8gVXNpbmcgYSBDb25kaXRpb25hbEV4cHJlc3Npb24gYXMgdGhlIGNvbnNlcXVlbnQgaXMgdW5jb21tb24sIGJ1dCBzaG91bGRcbiAgICAvLyAvLyBiZSBoYW5kbGVkLlxuICAgIC8vIEEgPyBCIDogQyA/IEQgOiBFID8gRiA/IEcgOiBIIDogSVxuICAgIC8vXG4gICAgLy8gd2hpY2ggaGFzIHRoaXMgQVNUOlxuICAgIC8vXG4gICAgLy8gQ29uZGl0aW9uYWxFeHByZXNzaW9uIHtcbiAgICAvLyAgIHRlc3Q6IElkZW50aWZpZXIoQSksXG4gICAgLy8gICBjb25zZXF1ZW50OiBJZGVudGlmaWVyKEIpLFxuICAgIC8vICAgYWx0ZXJuYXRlOiBDb25kaXRpb25hbEV4cHJlc3Npb24ge1xuICAgIC8vICAgICB0ZXN0OiBJZGVudGlmaWVyKEMpLFxuICAgIC8vICAgICBjb25zZXF1ZW50OiBJZGVudGlmaWVyKEQpLFxuICAgIC8vICAgICBhbHRlcm5hdGU6IENvbmRpdGlvbmFsRXhwcmVzc2lvbiB7XG4gICAgLy8gICAgICAgdGVzdDogSWRlbnRpZmllcihFKSxcbiAgICAvLyAgICAgICBjb25zZXF1ZW50OiBDb25kaXRpb25hbEV4cHJlc3Npb24ge1xuICAgIC8vICAgICAgICAgdGVzdDogSWRlbnRpZmllcihGKSxcbiAgICAvLyAgICAgICAgIGNvbnNlcXVlbnQ6IElkZW50aWZpZXIoRyksXG4gICAgLy8gICAgICAgICBhbHRlcm5hdGU6IElkZW50aWZpZXIoSCksXG4gICAgLy8gICAgICAgfSxcbiAgICAvLyAgICAgICBhbHRlcm5hdGU6IElkZW50aWZpZXIoSSksXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgLy9cbiAgICAvLyB3ZSBzaG91bGQgcmV0dXJuIHRoaXMgQXJyYXk6XG4gICAgLy9cbiAgICAvLyBbXG4gICAgLy8gICBJZGVudGlmaWVyKEEpLFxuICAgIC8vICAgSWRlbnRpZmllcihCKSxcbiAgICAvLyAgIElkZW50aWZpZXIoQyksXG4gICAgLy8gICBJZGVudGlmaWVyKEQpLFxuICAgIC8vICAgSWRlbnRpZmllcihFKSxcbiAgICAvLyAgIElkZW50aWZpZXIoRiksXG4gICAgLy8gICBJZGVudGlmaWVyKEcpLFxuICAgIC8vICAgSWRlbnRpZmllcihIKSxcbiAgICAvLyAgIElkZW50aWZpZXIoSSlcbiAgICAvLyBdO1xuICAgIC8vXG4gICAgLy8gVGhpcyBsb3NlcyB0aGUgaW5mb3JtYXRpb24gYWJvdXQgd2hldGhlciBlYWNoIG5vZGUgd2FzIHRoZSB0ZXN0LFxuICAgIC8vIGNvbnNlcXVlbnQsIG9yIGFsdGVybmF0ZSwgYnV0IHdlIGRvbid0IGNhcmUgYWJvdXQgdGhhdCBoZXJlLSB3ZSBhcmUgb25seVxuICAgIC8vIGZsYXR0ZW5pbmcgdGhpcyBzdHJ1Y3R1cmUgdG8gZmluZCBpZiB0aGVyZSdzIGFueSBKU1hFbGVtZW50cyBpbnNpZGUuXG4gICAgY29uc3Qgbm9uQ29uZGl0aW9uYWxFeHByZXNzaW9ucyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gcmVjdXJzZShub2RlKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJlY3Vyc2Uobm9kZS50ZXN0KTtcbiAgICAgICAgcmVjdXJzZShub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICByZWN1cnNlKG5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vbkNvbmRpdGlvbmFsRXhwcmVzc2lvbnMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWN1cnNlKG5vZGUpO1xuICAgIHJldHVybiBub25Db25kaXRpb25hbEV4cHJlc3Npb25zO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZGl0aW9uYWxFeHByZXNzaW9uQ2hhaW5Db250YWluc0pTWChub2RlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZ2V0Q29uZGl0aW9uYWxDaGFpbkNvbnRlbnRzKG5vZGUpLmZpbmQoaXNKU1hOb2RlKSk7XG4gIH0gLy8gTG9naWMgdG8gY2hlY2sgZm9yIGFyZ3Mgd2l0aCBtdWx0aXBsZSBhbm9ueW1vdXMgZnVuY3Rpb25zLiBGb3IgaW5zdGFuY2UsXG4gIC8vIHRoZSBmb2xsb3dpbmcgY2FsbCBzaG91bGQgYmUgc3BsaXQgb24gbXVsdGlwbGUgbGluZXMgZm9yIHJlYWRhYmlsaXR5OlxuICAvLyBzb3VyY2UucGlwZShtYXAoKHgpID0+IHggKyB4KSwgZmlsdGVyKCh4KSA9PiB4ICUgMiA9PT0gMCkpXG5cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uQ29tcG9zaXRpb25BcmdzKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbk9yQXJyb3dFeHByZXNzaW9uKGFyZykpIHtcbiAgICAgICAgY291bnQgKz0gMTtcblxuICAgICAgICBpZiAoY291bnQgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDYWxsT3JPcHRpb25hbENhbGxFeHByZXNzaW9uKGFyZykpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZEFyZyBvZiBhcmcuYXJndW1lbnRzKSB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb25PckFycm93RXhwcmVzc2lvbihjaGlsZEFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBMb2dpYyB0byBkZXRlcm1pbmUgaWYgYSBjYWxsIGlzIGEg4oCcbG9uZyBjdXJyaWVkIGZ1bmN0aW9uIGNhbGzigJ0uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJldHRpZXIvcHJldHRpZXIvaXNzdWVzLzE0MjAuXG4gIC8vXG4gIC8vIGBjb25uZWN0KGEsIGIsIGMpKGQpYFxuICAvLyBJbiB0aGUgYWJvdmUgY2FsbCBleHByZXNzaW9uLCB0aGUgc2Vjb25kIGNhbGwgaXMgdGhlIHBhcmVudCBub2RlIGFuZCB0aGVcbiAgLy8gZmlyc3QgY2FsbCBpcyB0aGUgY3VycmVudCBub2RlLlxuXG5cbiAgZnVuY3Rpb24gaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uKHBhdGgpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgIHJldHVybiBpc0NhbGxPck9wdGlvbmFsQ2FsbEV4cHJlc3Npb24obm9kZSkgJiYgaXNDYWxsT3JPcHRpb25hbENhbGxFeHByZXNzaW9uKHBhcmVudCkgJiYgcGFyZW50LmNhbGxlZSA9PT0gbm9kZSAmJiBub2RlLmFyZ3VtZW50cy5sZW5ndGggPiBwYXJlbnQuYXJndW1lbnRzLmxlbmd0aCAmJiBwYXJlbnQuYXJndW1lbnRzLmxlbmd0aCA+IDA7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7aW1wb3J0KCdlc3RyZWUnKS5Ob2RlfSBub2RlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc1NpbXBsZUNhbGxBcmd1bWVudChub2RlLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaXNDaGlsZFNpbXBsZSA9IGNoaWxkID0+IGlzU2ltcGxlQ2FsbEFyZ3VtZW50KGNoaWxkLCBkZXB0aCArIDEpO1xuXG4gICAgY29uc3QgcmVnZXhwUGF0dGVybiA9IG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgbm9kZS5yZWdleCAmJiBub2RlLnJlZ2V4LnBhdHRlcm4gfHwgbm9kZS50eXBlID09PSBcIlJlZ0V4cExpdGVyYWxcIiAmJiBub2RlLnBhdHRlcm47XG5cbiAgICBpZiAocmVnZXhwUGF0dGVybiAmJiByZWdleHBQYXR0ZXJuLmxlbmd0aCA+IDUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkxpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiQm9vbGVhbkxpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiTnVsbExpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiTnVtZXJpY0xpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiIHx8IG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgbm9kZS50eXBlID09PSBcIlRoaXNFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlN1cGVyXCIgfHwgbm9kZS50eXBlID09PSBcIkJpZ0ludExpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiUHJpdmF0ZU5hbWVcIiB8fCBub2RlLnR5cGUgPT09IFwiQXJndW1lbnRQbGFjZWhvbGRlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJSZWdFeHBMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIkltcG9ydFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiKSB7XG4gICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9ucy5ldmVyeShpc0NoaWxkU2ltcGxlKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIG5vZGUucHJvcGVydGllcy5ldmVyeShwID0+ICFwLmNvbXB1dGVkICYmIChwLnNob3J0aGFuZCB8fCBwLnZhbHVlICYmIGlzQ2hpbGRTaW1wbGUocC52YWx1ZSkpKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gbm9kZS5lbGVtZW50cy5ldmVyeSh4ID0+IHggPT0gbnVsbCB8fCBpc0NoaWxkU2ltcGxlKHgpKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiTmV3RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gaXNTaW1wbGVDYWxsQXJndW1lbnQobm9kZS5jYWxsZWUsIGRlcHRoKSAmJiBub2RlLmFyZ3VtZW50cy5ldmVyeShpc0NoaWxkU2ltcGxlKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiBpc1NpbXBsZUNhbGxBcmd1bWVudChub2RlLm9iamVjdCwgZGVwdGgpICYmIGlzU2ltcGxlQ2FsbEFyZ3VtZW50KG5vZGUucHJvcGVydHksIGRlcHRoKTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiICYmIChub2RlLm9wZXJhdG9yID09PSBcIiFcIiB8fCBub2RlLm9wZXJhdG9yID09PSBcIi1cIikpIHtcbiAgICAgIHJldHVybiBpc1NpbXBsZUNhbGxBcmd1bWVudChub2RlLmFyZ3VtZW50LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJUU05vbk51bGxFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiBpc1NpbXBsZUNhbGxBcmd1bWVudChub2RlLmV4cHJlc3Npb24sIGRlcHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiByYXdUZXh0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5leHRyYSA/IG5vZGUuZXh0cmEucmF3IDogbm9kZS5yYXc7XG4gIH1cblxuICBmdW5jdGlvbiBpZGVudGl0eSQxKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVFNYRmlsZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZmlsZXBhdGggJiYgL1xcLnRzeCQvaS50ZXN0KG9wdGlvbnMuZmlsZXBhdGgpO1xuICB9XG5cbiAgdmFyIHV0aWxzJDUgPSB7XG4gICAgY2xhc3NDaGlsZE5lZWRzQVNJUHJvdGVjdGlvbixcbiAgICBjbGFzc1Byb3BNYXlDYXVzZUFTSVByb2JsZW1zLFxuICAgIGNvbmRpdGlvbmFsRXhwcmVzc2lvbkNoYWluQ29udGFpbnNKU1gsXG4gICAgZ2V0Rmxvd1ZhcmlhbmNlLFxuICAgIGdldExlZnRTaWRlUGF0aE5hbWUsXG4gICAgZ2V0UGFyZW50RXhwb3J0RGVjbGFyYXRpb24sXG4gICAgZ2V0VHlwZVNjcmlwdE1hcHBlZFR5cGVNb2RpZmllcixcbiAgICBoYXNEYW5nbGluZ0NvbW1lbnRzLFxuICAgIGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCxcbiAgICBoYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQsXG4gICAgaGFzTGVhZGluZ0NvbW1lbnQ6IGhhc0xlYWRpbmdDb21tZW50JDIsXG4gICAgaGFzTGVhZGluZ093bkxpbmVDb21tZW50LFxuICAgIGhhc05ha2VkTGVmdFNpZGUsXG4gICAgaGFzTmV3bGluZUJldHdlZW5PckFmdGVyRGVjb3JhdG9ycyxcbiAgICBoYXNOZ1NpZGVFZmZlY3QsXG4gICAgaGFzTm9kZSxcbiAgICBoYXNQcmV0dGllcklnbm9yZTogaGFzUHJldHRpZXJJZ25vcmUkNCxcbiAgICBoYXNUcmFpbGluZ0NvbW1lbnQsXG4gICAgaWRlbnRpdHk6IGlkZW50aXR5JDEsXG4gICAgaXNCaW5hcnlpc2gsXG4gICAgaXNDYWxsT3JPcHRpb25hbENhbGxFeHByZXNzaW9uLFxuICAgIGlzRW1wdHlKU1hFbGVtZW50LFxuICAgIGlzRXhwb3J0RGVjbGFyYXRpb24sXG4gICAgaXNGbG93QW5ub3RhdGlvbkNvbW1lbnQsXG4gICAgaXNGdW5jdGlvbkNvbXBvc2l0aW9uQXJncyxcbiAgICBpc0Z1bmN0aW9uTm90YXRpb24sXG4gICAgaXNGdW5jdGlvbk9yQXJyb3dFeHByZXNzaW9uLFxuICAgIGlzR2V0dGVyT3JTZXR0ZXIsXG4gICAgaXNKZXN0RWFjaFRlbXBsYXRlTGl0ZXJhbCxcbiAgICBpc0pTWE5vZGUsXG4gICAgaXNKU1hXaGl0ZXNwYWNlRXhwcmVzc2lvbixcbiAgICBpc0xhc3RTdGF0ZW1lbnQsXG4gICAgaXNMaXRlcmFsLFxuICAgIGlzTG9uZ0N1cnJpZWRDYWxsRXhwcmVzc2lvbixcbiAgICBpc1NpbXBsZUNhbGxBcmd1bWVudCxcbiAgICBpc01lYW5pbmdmdWxKU1hUZXh0LFxuICAgIGlzTWVtYmVyRXhwcmVzc2lvbkNoYWluLFxuICAgIGlzTWVtYmVyaXNoLFxuICAgIGlzTmdGb3JPZixcbiAgICBpc051bWVyaWNMaXRlcmFsLFxuICAgIGlzT2JqZWN0VHlwZSxcbiAgICBpc09iamVjdFR5cGVQcm9wZXJ0eUFGdW5jdGlvbixcbiAgICBpc1NpbXBsZUZsb3dUeXBlLFxuICAgIGlzU2ltcGxlVGVtcGxhdGVMaXRlcmFsLFxuICAgIGlzU3RyaW5nTGl0ZXJhbCxcbiAgICBpc1N0cmluZ1Byb3BTYWZlVG9Db2VyY2VUb0lkZW50aWZpZXIsXG4gICAgaXNUZW1wbGF0ZU9uSXRzT3duTGluZSxcbiAgICBpc1Rlc3RDYWxsLFxuICAgIGlzVGhlT25seUpTWEVsZW1lbnRJbk1hcmtkb3duLFxuICAgIGlzVFNYRmlsZSxcbiAgICBpc1R5cGVBbm5vdGF0aW9uQUZ1bmN0aW9uLFxuICAgIG1hdGNoSnN4V2hpdGVzcGFjZVJlZ2V4LFxuICAgIG5lZWRzSGFyZGxpbmVBZnRlckRhbmdsaW5nQ29tbWVudCxcbiAgICByYXdUZXh0LFxuICAgIHJldHVybkFyZ3VtZW50SGFzTGVhZGluZ0NvbW1lbnRcbiAgfTtcblxuICBjb25zdCB7XG4gICAgZ2V0TGVmdFNpZGVQYXRoTmFtZTogZ2V0TGVmdFNpZGVQYXRoTmFtZSQxLFxuICAgIGhhc0Zsb3dTaG9ydGhhbmRBbm5vdGF0aW9uQ29tbWVudDogaGFzRmxvd1Nob3J0aGFuZEFubm90YXRpb25Db21tZW50JDEsXG4gICAgaGFzTmFrZWRMZWZ0U2lkZTogaGFzTmFrZWRMZWZ0U2lkZSQxLFxuICAgIGhhc05vZGU6IGhhc05vZGUkMVxuICB9ID0gdXRpbHMkNTtcblxuICBmdW5jdGlvbiBuZWVkc1BhcmVucyhwYXRoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBwYXRoLmdldE5hbWUoKTtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXROb2RlKCk7IC8vIElmIHRoZSB2YWx1ZSBvZiB0aGlzIHBhdGggaXMgc29tZSBjaGlsZCBvZiBhIE5vZGUgYW5kIG5vdCBhIE5vZGVcbiAgICAvLyBpdHNlbGYsIHRoZW4gaXQgZG9lc24ndCBuZWVkIHBhcmVudGhlc2VzLiBPbmx5IE5vZGUgb2JqZWN0cyAoaW5cbiAgICAvLyBmYWN0LCBvbmx5IEV4cHJlc3Npb24gbm9kZXMpIG5lZWQgcGFyZW50aGVzZXMuXG5cbiAgICBpZiAocGF0aC5nZXRWYWx1ZSgpICE9PSBub2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyB0byBhdm9pZCB1bmV4cGVjdGVkIGB9fWAgaW4gSFRNTCBpbnRlcnBvbGF0aW9uc1xuXG5cbiAgICBpZiAob3B0aW9ucy5fX2lzSW5IdG1sSW50ZXJwb2xhdGlvbiAmJiAhb3B0aW9ucy5icmFja2V0U3BhY2luZyAmJiBlbmRzV2l0aFJpZ2h0QnJhY2tldChub2RlKSAmJiBpc0ZvbGxvd2VkQnlSaWdodEJyYWNrZXQocGF0aCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gT25seSBzdGF0ZW1lbnRzIGRvbid0IG5lZWQgcGFyZW50aGVzZXMuXG5cblxuICAgIGlmIChpc1N0YXRlbWVudChub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICggLy8gUHJlc2VydmUgcGFyZW5zIGlmIHdlIGhhdmUgYSBGbG93IGFubm90YXRpb24gY29tbWVudCwgdW5sZXNzIHdlJ3JlIHVzaW5nIHRoZSBGbG93XG4gICAgLy8gcGFyc2VyLiBUaGUgRmxvdyBwYXJzZXIgdHVybnMgRmxvdyBjb21tZW50cyBpbnRvIHR5cGUgYW5ub3RhdGlvbiBub2RlcyBpbiBpdHNcbiAgICAvLyBBU1QsIHdoaWNoIHdlIGhhbmRsZSBzZXBhcmF0ZWx5LlxuICAgIG9wdGlvbnMucGFyc2VyICE9PSBcImZsb3dcIiAmJiBoYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQkMShwYXRoLmdldFZhbHVlKCkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIElkZW50aWZpZXJzIG5ldmVyIG5lZWQgcGFyZW50aGVzZXMuXG5cblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAvLyAuLi51bmxlc3MgdGhvc2UgaWRlbnRpZmllcnMgYXJlIGVtYmVkIHBsYWNlaG9sZGVycy4gVGhleSBtaWdodCBiZSBzdWJzdGl0dXRlZCBieSBjb21wbGV4XG4gICAgICAvLyBleHByZXNzaW9ucywgc28gdGhlIHBhcmVucyBhcm91bmQgdGhlbSBzaG91bGQgbm90IGJlIGRyb3BwZWQuIEV4YW1wbGUgKEpTLWluLUhUTUwtaW4tSlMpOlxuICAgICAgLy8gICAgIGxldCB0cGwgPSBodG1sYDxzY3JpcHQ+IGYoKCR7ZXhwcn0pIC8gMik7IDwvc2NyaXB0PmA7XG4gICAgICAvLyBJZiB0aGUgaW5uZXIgSlMgZm9ybWF0dGVyIHJlbW92ZXMgdGhlIHBhcmVucywgdGhlIGV4cHJlc3Npb24gbWlnaHQgY2hhbmdlIGl0cyBtZWFuaW5nOlxuICAgICAgLy8gICAgIGYoKGEgKyBiKSAvIDIpICB2cyAgZihhICsgYiAvIDIpXG4gICAgICBpZiAobm9kZS5leHRyYSAmJiBub2RlLmV4dHJhLnBhcmVudGhlc2l6ZWQgJiYgL15QUkVUVElFUl9IVE1MX1BMQUNFSE9MREVSX1xcZCtfXFxkK19JTl9KUyQvLnRlc3Qobm9kZS5uYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBBZGQgcGFyZW5zIGFyb3VuZCB0aGUgZXh0ZW5kcyBjbGF1c2Ugb2YgYSBjbGFzcy4gSXQgaXMgbmVlZGVkIGZvciBhbG1vc3RcbiAgICAvLyBhbGwgZXhwcmVzc2lvbnMuXG5cblxuICAgIGlmICgocGFyZW50LnR5cGUgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiIHx8IHBhcmVudC50eXBlID09PSBcIkNsYXNzRXhwcmVzc2lvblwiKSAmJiBwYXJlbnQuc3VwZXJDbGFzcyA9PT0gbm9kZSAmJiAobm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkF3YWl0RXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJMb2dpY2FsRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJOZXdFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVXBkYXRlRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJZaWVsZEV4cHJlc3Npb25cIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIikge1xuICAgICAgcmV0dXJuICgvLyBgZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb25gIG9yIGBleHBvcnQgZGVmYXVsdCBjbGFzc2AgY2FuJ3QgYmUgZm9sbG93ZWQgYnlcbiAgICAgICAgLy8gYW55dGhpbmcgYWZ0ZXIuIFNvIGFuIGV4cHJlc3Npb24gbGlrZSBgZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uKCl7fSkudG9TdHJpbmcoKWBcbiAgICAgICAgLy8gbmVlZHMgdG8gYmUgZm9sbG93ZWQgYnkgYSBwYXJlbnRoZXNlc1xuICAgICAgICBzaG91bGRXcmFwRnVuY3Rpb25Gb3JFeHBvcnREZWZhdWx0KHBhdGgsIG9wdGlvbnMpIHx8IC8vIGBleHBvcnQgZGVmYXVsdCAoZm9vLCBiYXIpYCBhbHNvIG5lZWRzIHBhcmVudGhlc2VzXG4gICAgICAgIG5vZGUudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiRGVjb3JhdG9yXCIgJiYgcGFyZW50LmV4cHJlc3Npb24gPT09IG5vZGUpIHtcbiAgICAgIGxldCBoYXNDYWxsRXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgbGV0IGhhc01lbWJlckV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgIGxldCBjdXJyZW50ID0gbm9kZTtcblxuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgc3dpdGNoIChjdXJyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgaGFzTWVtYmVyRXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vYmplY3Q7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLyoqIEAoeCgpLnkpICovXG4gICAgICAgICAgICBoYXNNZW1iZXJFeHByZXNzaW9uIHx8XG4gICAgICAgICAgICAvKiogQCh4KCkueSgpKSAqL1xuICAgICAgICAgICAgaGFzQ2FsbEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhc0NhbGxFeHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNhbGxlZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBwYXJlbnQuYm9keSA9PT0gbm9kZSAmJiBub2RlLnR5cGUgIT09IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIgJiYgLy8gdGhlc2UgaGF2ZSBwYXJlbnMgYWRkZWQgYW55d2F5XG4gICAgdXRpbCQxLnN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuKG5vZGUsXG4gICAgLyogZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwciAqL1xuICAgIGZhbHNlKSB8fCBwYXJlbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgdXRpbCQxLnN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuKG5vZGUsXG4gICAgLyogZm9yYmlkRnVuY3Rpb25DbGFzc0FuZERvRXhwciAqL1xuICAgIHRydWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIG5hbWUgPT09IFwib2JqZWN0XCIgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcblxuICAgICAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucHJlZml4ICYmIChub2RlLm9wZXJhdG9yID09PSBcIisrXCIgJiYgcGFyZW50Lm9wZXJhdG9yID09PSBcIitcIiB8fCBub2RlLm9wZXJhdG9yID09PSBcIi0tXCIgJiYgcGFyZW50Lm9wZXJhdG9yID09PSBcIi1cIik7XG4gICAgICAgIH1cblxuICAgICAgLy8gZWxzZSBmYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5vcGVyYXRvciA9PT0gcGFyZW50Lm9wZXJhdG9yICYmIChub2RlLm9wZXJhdG9yID09PSBcIitcIiB8fCBub2RlLm9wZXJhdG9yID09PSBcIi1cIik7XG5cbiAgICAgICAgICBjYXNlIFwiQmluZEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJvYmplY3RcIjtcblxuICAgICAgICAgIGNhc2UgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiY2FsbGVlXCI7XG5cbiAgICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5vcGVyYXRvciA9PT0gXCIqKlwiICYmIG5hbWUgPT09IFwibGVmdFwiO1xuXG4gICAgICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcIlVwZGF0ZUV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNMZWZ0T2ZBRm9yU3RhdGVtZW50ID0gbm9kZSA9PiB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZShpKyspO1xuXG4gICAgICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcIkZvclN0YXRlbWVudFwiICYmIHBhcmVudC5pbml0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSBcImluXCIgJiYgaXNMZWZ0T2ZBRm9yU3RhdGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCI7XG5cbiAgICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJjYWxsZWVcIjtcblxuICAgICAgICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwic3VwZXJDbGFzc1wiICYmIHBhcmVudC5zdXBlckNsYXNzID09PSBub2RlO1xuXG4gICAgICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgICAgIGNhc2UgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiOlxuICAgICAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgICAgY2FzZSBcIlNwcmVhZFByb3BlcnR5XCI6XG4gICAgICAgICAgY2FzZSBcIkJpbmRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkF3YWl0RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJvYmplY3RcIjtcblxuICAgICAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5sZWZ0ID09PSBub2RlICYmIChub2RlLnR5cGUgPT09IFwiVFNUeXBlQXNzZXJ0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCIpO1xuXG4gICAgICAgICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5vcGVyYXRvciAhPT0gbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGVsc2UgZmFsbHRocm91Z2hcblxuICAgICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghbm9kZS5vcGVyYXRvciAmJiBub2RlLnR5cGUgIT09IFwiVFNUeXBlQXNzZXJ0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHBvID0gcGFyZW50Lm9wZXJhdG9yO1xuICAgICAgICAgICAgICBjb25zdCBwcCA9IHV0aWwkMS5nZXRQcmVjZWRlbmNlKHBvKTtcbiAgICAgICAgICAgICAgY29uc3Qgbm8gPSBub2RlLm9wZXJhdG9yO1xuICAgICAgICAgICAgICBjb25zdCBucCA9IHV0aWwkMS5nZXRQcmVjZWRlbmNlKG5vKTtcblxuICAgICAgICAgICAgICBpZiAocHAgPiBucCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHBwID09PSBucCAmJiBuYW1lID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwocGFyZW50LnJpZ2h0LCBub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwcCA9PT0gbnAgJiYgIXV0aWwkMS5zaG91bGRGbGF0dGVuKHBvLCBubykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwcCA8IG5wICYmIG5vID09PSBcIiVcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbyA9PT0gXCIrXCIgfHwgcG8gPT09IFwiLVwiO1xuICAgICAgICAgICAgICB9IC8vIEFkZCBwYXJlbnRoZXNpcyB3aGVuIHdvcmtpbmcgd2l0aCBiaXR3aXNlIG9wZXJhdG9yc1xuICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBzdHJpY3RseSBuZWVkZWQgYnV0IGhlbHBzIHdpdGggY29kZSB1bmRlcnN0YW5kaW5nXG5cblxuICAgICAgICAgICAgICBpZiAodXRpbCQxLmlzQml0d2lzZU9wZXJhdG9yKHBvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgICAgICAgICAvLyBBbHRob3VnaCBwYXJlbnRoZXNlcyB3b3VsZG4ndCBodXJ0IGFyb3VuZCBzZXF1ZW5jZVxuICAgICAgICAgICAgLy8gZXhwcmVzc2lvbnMgaW4gdGhlIGhlYWQgb2YgZm9yIGxvb3BzLCB0cmFkaXRpb25hbCBzdHlsZVxuICAgICAgICAgICAgLy8gZGljdGF0ZXMgdGhhdCBlLmcuIGkrKywgaisrIHNob3VsZCBub3QgYmUgd3JhcHBlZCB3aXRoXG4gICAgICAgICAgICAvLyBwYXJlbnRoZXNlcy5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gbmFtZSAhPT0gXCJleHByZXNzaW9uXCI7XG5cbiAgICAgICAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIC8vIFdlIGRvIG5lZWQgcGFyZW50aGVzZXMsIGJ1dCBTZXF1ZW5jZUV4cHJlc3Npb25zIGFyZSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBzcGVjaWFsbHkgd2hlbiBwcmludGluZyBib2RpZXMgb2YgYXJyb3cgZnVuY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgIT09IFwiYm9keVwiO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBlcnIgb24gdGhlIHNpZGUgb2Ygb3ZlcnBhcmVudGhlc2l6YXRpb24sIGFkZGluZ1xuICAgICAgICAgICAgLy8gZXhwbGljaXQgZXhjZXB0aW9ucyBhYm92ZSBpZiB0aGlzIHByb3ZlcyBvdmVyemVhbG91cy5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJZaWVsZEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIkF3YWl0RXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNOb25OdWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gZWxzZSBmYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFwiQXdhaXRFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgICBjYXNlIFwiU3ByZWFkUHJvcGVydHlcIjpcbiAgICAgICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcIm9iamVjdFwiO1xuXG4gICAgICAgICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiY2FsbGVlXCI7XG5cbiAgICAgICAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnRlc3QgPT09IG5vZGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU0pTRG9jRnVuY3Rpb25UeXBlXCI6XG4gICAgICBjYXNlIFwiVFNDb25kaXRpb25hbFR5cGVcIjpcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcIlRTQ29uZGl0aW9uYWxUeXBlXCIgJiYgbm9kZSA9PT0gcGFyZW50LmV4dGVuZHNUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbHRocm91Z2hcblxuICAgICAgY2FzZSBcIlRTRnVuY3Rpb25UeXBlXCI6XG4gICAgICBjYXNlIFwiVFNDb25zdHJ1Y3RvclR5cGVcIjpcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcIlRTQ29uZGl0aW9uYWxUeXBlXCIgJiYgbm9kZSA9PT0gcGFyZW50LmNoZWNrVHlwZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgXCJUU1VuaW9uVHlwZVwiOlxuICAgICAgY2FzZSBcIlRTSW50ZXJzZWN0aW9uVHlwZVwiOlxuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiVFNVbmlvblR5cGVcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJUU0ludGVyc2VjdGlvblR5cGVcIikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgXCJUU1R5cGVPcGVyYXRvclwiOlxuICAgICAgY2FzZSBcIlRTSW5mZXJUeXBlXCI6XG4gICAgICAgIHJldHVybiBwYXJlbnQudHlwZSA9PT0gXCJUU0FycmF5VHlwZVwiIHx8IHBhcmVudC50eXBlID09PSBcIlRTT3B0aW9uYWxUeXBlXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNSZXN0VHlwZVwiIHx8IHBhcmVudC50eXBlID09PSBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIiAmJiBub2RlID09PSBwYXJlbnQub2JqZWN0VHlwZSB8fCBwYXJlbnQudHlwZSA9PT0gXCJUU1R5cGVPcGVyYXRvclwiIHx8IHBhcmVudC50eXBlID09PSBcIlRTVHlwZUFubm90YXRpb25cIiAmJiAvXlRTSlNEb2MvLnRlc3QocGF0aC5nZXRQYXJlbnROb2RlKDEpLnR5cGUpO1xuXG4gICAgICBjYXNlIFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiO1xuXG4gICAgICBjYXNlIFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIjpcbiAgICAgIGNhc2UgXCJVbmlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBwYXJlbnQudHlwZSA9PT0gXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudC50eXBlID09PSBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiO1xuXG4gICAgICBjYXNlIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiO1xuXG4gICAgICBjYXNlIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgYW5jZXN0b3IgPSBwYXJlbnQudHlwZSA9PT0gXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIgPyBwYXRoLmdldFBhcmVudE5vZGUoMSkgOiBwYXJlbnQ7XG4gICAgICAgICAgcmV0dXJuIGFuY2VzdG9yLnR5cGUgPT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiIHx8IGFuY2VzdG9yLnR5cGUgPT09IFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIiB8fCBhbmNlc3Rvci50eXBlID09PSBcIkFycmF5VHlwZUFubm90YXRpb25cIiB8fCAvLyBXZSBzaG91bGQgY2hlY2sgYW5jZXN0b3IncyBwYXJlbnQgdG8ga25vdyB3aGV0aGVyIHRoZSBwYXJlbnRoZXNlc1xuICAgICAgICAgIC8vIGFyZSByZWFsbHkgbmVlZGVkLCBidXQgc2luY2UgPz9UIGRvZXNuJ3QgbWFrZSBzZW5zZSB0aGlzIGNoZWNrXG4gICAgICAgICAgLy8gd2lsbCBhbG1vc3QgbmV2ZXIgYmUgdHJ1ZS5cbiAgICAgICAgICBhbmNlc3Rvci50eXBlID09PSBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFwiOlxuICAgICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICBpZiAodHlwZW9mIG5vZGUudmFsdWUgPT09IFwic3RyaW5nXCIgJiYgcGFyZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiICYmICggLy8gVHlwZVNjcmlwdCB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vSmFtZXNIZW5yeS90eXBlc2NyaXB0LWVzdHJlZS9pc3N1ZXMvMlxuICAgICAgICAvLyBTZWUgY29ycmVzcG9uZGluZyB3b3JrYXJvdW5kIGluIHByaW50ZXIuanMgY2FzZTogXCJMaXRlcmFsXCJcbiAgICAgICAgb3B0aW9ucy5wYXJzZXIgIT09IFwidHlwZXNjcmlwdFwiICYmICFwYXJlbnQuZGlyZWN0aXZlIHx8IG9wdGlvbnMucGFyc2VyID09PSBcInR5cGVzY3JpcHRcIiAmJiBvcHRpb25zLm9yaWdpbmFsVGV4dC5jaGFyQXQob3B0aW9ucy5sb2NTdGFydChub2RlKSAtIDEpID09PSBcIihcIikpIHtcbiAgICAgICAgICAvLyBUbyBhdm9pZCBiZWNvbWluZyBhIGRpcmVjdGl2ZVxuICAgICAgICAgIGNvbnN0IGdyYW5kUGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDEpO1xuICAgICAgICAgIHJldHVybiBncmFuZFBhcmVudC50eXBlID09PSBcIlByb2dyYW1cIiB8fCBncmFuZFBhcmVudC50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIHR5cGVvZiBub2RlLnZhbHVlID09PSBcIm51bWJlclwiICYmIG5hbWUgPT09IFwib2JqZWN0XCIgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcblxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBncmFuZFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcblxuICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHBhcmVudC5ib2R5ID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC50eXBlID09PSBcIkNsYXNzUHJvcGVydHlcIiAmJiBwYXJlbnQua2V5ID09PSBub2RlICYmIHBhcmVudC5jb21wdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50LnR5cGUgPT09IFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiICYmIHBhcmVudC5uYW1lID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gXCJGb3JTdGF0ZW1lbnRcIiAmJiAocGFyZW50LmluaXQgPT09IG5vZGUgfHwgcGFyZW50LnVwZGF0ZSA9PT0gbm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubGVmdC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudC50eXBlID09PSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIiAmJiBwYXJlbnQua2V5ID09PSBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiAmJiBncmFuZFBhcmVudCAmJiBncmFuZFBhcmVudC50eXBlID09PSBcIkZvclN0YXRlbWVudFwiICYmIChncmFuZFBhcmVudC5pbml0ID09PSBwYXJlbnQgfHwgZ3JhbmRQYXJlbnQudXBkYXRlID09PSBwYXJlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIHBhcmVudC52YWx1ZSA9PT0gbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50LnR5cGUgPT09IFwiTkdDaGFpbmVkRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk5HUGlwZUV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkF3YWl0RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIjpcbiAgICAgICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImNhbGxlZVwiO1xuXG4gICAgICAgICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwidGVzdFwiICYmIHBhcmVudC50ZXN0ID09PSBub2RlO1xuXG4gICAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJvYmplY3RcIjtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgLy8gTm90IGFsd2F5cyBuZWNlc3NhcnksIGJ1dCBpdCdzIGNsZWFyZXIgdG8gdGhlIHJlYWRlciBpZiBJSUZFcyBhcmUgd3JhcHBlZCBpbiBwYXJlbnRoZXNlcy5cbiAgICAgICAgICAgIC8vIElzIG5lY2Vzc2FyeSBpZiBpdCBpcyBgZXhwcmVzc2lvbmAgb2YgYEV4cHJlc3Npb25TdGF0ZW1lbnRgLlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiY2FsbGVlXCI7XG5cbiAgICAgICAgICBjYXNlIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAvLyBUaGlzIGlzIGJhc2ljYWxseSBhIGtpbmQgb2YgSUlGRS5cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJjYWxsZWVcIjtcblxuICAgICAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwib2JqZWN0XCI7XG5cbiAgICAgICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiQmluZEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkF3YWl0RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwidGVzdFwiO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQ2xhc3NFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiY2FsbGVlXCIgJiYgcGFyZW50LmNhbGxlZSA9PT0gbm9kZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBuYW1lID09PSBcIm9iamVjdFwiIHx8IChwYXJlbnQudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIk5ld0V4cHJlc3Npb25cIikgJiYgbmFtZSA9PT0gXCJjYWxsZWVcIikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICgocGFyZW50LnR5cGUgPT09IFwiQmluZEV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJOZXdFeHByZXNzaW9uXCIpICYmIG5hbWUgPT09IFwiY2FsbGVlXCIpIHtcbiAgICAgICAgICBsZXQgb2JqZWN0ID0gbm9kZTtcblxuICAgICAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiQmluZEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3Qub2JqZWN0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAvLyB0YWdnZWQgdGVtcGxhdGVzIGFyZSBiYXNpY2FsbHkgbWVtYmVyIGV4cHJlc3Npb25zIGZyb20gYSBncmFtbWFyIHBlcnNwZWN0aXZlXG4gICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3Byb2QtTWVtYmVyRXhwcmVzc2lvblxuXG4gICAgICAgICAgICAgIGNhc2UgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBvYmplY3QudGFnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlIFwiQmluZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIChwYXJlbnQudHlwZSA9PT0gXCJCaW5kRXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIk5ld0V4cHJlc3Npb25cIikgJiYgbmFtZSA9PT0gXCJjYWxsZWVcIiB8fCAocGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSAmJiBuYW1lID09PSBcIm9iamVjdFwiO1xuXG4gICAgICBjYXNlIFwiTkdQaXBlRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiTkdSb290XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiTkdNaWNyb3N5bnRheEV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiIHx8IHBhcmVudC50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiIHx8IChwYXJlbnQudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IHBhcmVudC50eXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIikgJiYgcGFyZW50LmFyZ3VtZW50c1tuYW1lXSA9PT0gbm9kZSB8fCBwYXJlbnQudHlwZSA9PT0gXCJOR1BpcGVFeHByZXNzaW9uXCIgJiYgbmFtZSA9PT0gXCJyaWdodFwiIHx8IHBhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiBuYW1lID09PSBcInByb3BlcnR5XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBjYXNlIFwiSlNYRnJhZ21lbnRcIjpcbiAgICAgIGNhc2UgXCJKU1hFbGVtZW50XCI6XG4gICAgICAgIHJldHVybiBuYW1lID09PSBcImNhbGxlZVwiIHx8IHBhcmVudC50eXBlICE9PSBcIkFycmF5RXhwcmVzc2lvblwiICYmIHBhcmVudC50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJBc3NpZ25tZW50UGF0dGVyblwiICYmIHBhcmVudC50eXBlICE9PSBcIkJpbmFyeUV4cHJlc3Npb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJDYWxsRXhwcmVzc2lvblwiICYmIHBhcmVudC50eXBlICE9PSBcIk5ld0V4cHJlc3Npb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgcGFyZW50LnR5cGUgIT09IFwiSnNFeHByZXNzaW9uUm9vdFwiICYmIHBhcmVudC50eXBlICE9PSBcIkpTWEF0dHJpYnV0ZVwiICYmIHBhcmVudC50eXBlICE9PSBcIkpTWEVsZW1lbnRcIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiSlNYRnJhZ21lbnRcIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJMb2dpY2FsRXhwcmVzc2lvblwiICYmIHBhcmVudC50eXBlICE9PSBcIk9iamVjdFByb3BlcnR5XCIgJiYgcGFyZW50LnR5cGUgIT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiICYmIHBhcmVudC50eXBlICE9PSBcIlByb3BlcnR5XCIgJiYgcGFyZW50LnR5cGUgIT09IFwiUmV0dXJuU3RhdGVtZW50XCIgJiYgcGFyZW50LnR5cGUgIT09IFwiVGhyb3dTdGF0ZW1lbnRcIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJZaWVsZEV4cHJlc3Npb25cIjtcblxuICAgICAgY2FzZSBcIlR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBuYW1lID09PSBcInJldHVyblR5cGVcIiAmJiBwYXJlbnQudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIGluY2x1ZGVzRnVuY3Rpb25UeXBlSW5PYmplY3RUeXBlKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RhdGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkJyZWFrU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzQm9keVwiIHx8IG5vZGUudHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzTWV0aG9kXCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiQ29udGludWVTdGF0ZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiRGVidWdnZXJTdGF0ZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiRGVjbGFyZUNsYXNzXCIgfHwgbm9kZS50eXBlID09PSBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiRGVjbGFyZUZ1bmN0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkRlY2xhcmVJbnRlcmZhY2VcIiB8fCBub2RlLnR5cGUgPT09IFwiRGVjbGFyZU1vZHVsZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiIHx8IG5vZGUudHlwZSA9PT0gXCJEZWNsYXJlVmFyaWFibGVcIiB8fCBub2RlLnR5cGUgPT09IFwiRG9XaGlsZVN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJFbnVtRGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJGb3JJblN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJGb3JPZlN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJGb3JTdGF0ZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJJZlN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJJbXBvcnREZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJMYWJlbGVkU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiUmV0dXJuU3RhdGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIlN3aXRjaFN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJUaHJvd1N0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJUcnlTdGF0ZW1lbnRcIiB8fCBub2RlLnR5cGUgPT09IFwiVFNEZWNsYXJlRnVuY3Rpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVFNFbnVtRGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUeXBlQWxpYXNcIiB8fCBub2RlLnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJXaGlsZVN0YXRlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJXaXRoU3RhdGVtZW50XCI7XG4gIH1cblxuICBmdW5jdGlvbiBpbmNsdWRlc0Z1bmN0aW9uVHlwZUluT2JqZWN0VHlwZShub2RlKSB7XG4gICAgcmV0dXJuIGhhc05vZGUkMShub2RlLCBuMSA9PiBuMS50eXBlID09PSBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIgJiYgaGFzTm9kZSQxKG4xLCBuMiA9PiBuMi50eXBlID09PSBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiB8fCB1bmRlZmluZWQpIHx8IHVuZGVmaW5lZCk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmRzV2l0aFJpZ2h0QnJhY2tldChub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNGb2xsb3dlZEJ5UmlnaHRCcmFja2V0KHBhdGgpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgIGNvbnN0IG5hbWUgPSBwYXRoLmdldE5hbWUoKTtcblxuICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJOR1BpcGVFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJudW1iZXJcIiAmJiBwYXJlbnQuYXJndW1lbnRzW25hbWVdID09PSBub2RlICYmIHBhcmVudC5hcmd1bWVudHMubGVuZ3RoIC0gMSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiBwYXRoLmNhbGxQYXJlbnQoaXNGb2xsb3dlZEJ5UmlnaHRCcmFja2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICAgICAgaWYgKG5hbWUgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgIGNvbnN0IHBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcbiAgICAgICAgICByZXR1cm4gcGFyZW50UGFyZW50LnByb3BlcnRpZXNbcGFyZW50UGFyZW50LnByb3BlcnRpZXMubGVuZ3RoIC0gMV0gPT09IHBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChuYW1lID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5jYWxsUGFyZW50KGlzRm9sbG93ZWRCeVJpZ2h0QnJhY2tldCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAobmFtZSA9PT0gXCJhbHRlcm5hdGVcIikge1xuICAgICAgICAgIHJldHVybiBwYXRoLmNhbGxQYXJlbnQoaXNGb2xsb3dlZEJ5UmlnaHRCcmFja2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChwYXJlbnQucHJlZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGguY2FsbFBhcmVudChpc0ZvbGxvd2VkQnlSaWdodEJyYWNrZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkV3JhcEZ1bmN0aW9uRm9yRXhwb3J0RGVmYXVsdChwYXRoLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzRXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIgfHwgLy8gaW4gc29tZSBjYXNlcyB0aGUgZnVuY3Rpb24gaXMgYWxyZWFkeSB3cmFwcGVkXG4gICAgICAvLyAoZS5nLiBgZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uKCkge30pKCk7YClcbiAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBkb24ndCBuZWVkIHRvIGFkZCBleHRyYSBwYXJlbnNcbiAgICAgICFuZWVkc1BhcmVucyhwYXRoLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoIWhhc05ha2VkTGVmdFNpZGUkMShub2RlKSB8fCBwYXJlbnQudHlwZSAhPT0gXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiAmJiBuZWVkc1BhcmVucyhwYXRoLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLmNhbGwoY2hpbGRQYXRoID0+IHNob3VsZFdyYXBGdW5jdGlvbkZvckV4cG9ydERlZmF1bHQoY2hpbGRQYXRoLCBvcHRpb25zKSwgLi4uZ2V0TGVmdFNpZGVQYXRoTmFtZSQxKHBhdGgsIG5vZGUpKTtcbiAgfVxuXG4gIHZhciBuZWVkc1BhcmVuc18xID0gbmVlZHNQYXJlbnM7XG5cbiAgY29uc3Qge1xuICAgIGJ1aWxkZXJzOiB7XG4gICAgICBjb25jYXQ6IGNvbmNhdCRjLFxuICAgICAgam9pbjogam9pbiQ4LFxuICAgICAgbGluZTogbGluZSQ4XG4gICAgfVxuICB9ID0gZG9jdW1lbnQ7XG5cbiAgZnVuY3Rpb24gcHJpbnRIdG1sQmluZGluZyhwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBpZiAob3B0aW9ucy5fX29uSHRtbEJpbmRpbmdSb290ICYmIHBhdGguZ2V0TmFtZSgpID09PSBudWxsKSB7XG4gICAgICBvcHRpb25zLl9fb25IdG1sQmluZGluZ1Jvb3Qobm9kZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSAhPT0gXCJGaWxlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5fX2lzVnVlRm9yQmluZGluZ0xlZnQpIHtcbiAgICAgIHJldHVybiBwYXRoLmNhbGwoZnVuY3Rpb25EZWNsYXJhdGlvblBhdGggPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcGFyYW1zXG4gICAgICAgIH0gPSBmdW5jdGlvbkRlY2xhcmF0aW9uUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGMoW3BhcmFtcy5sZW5ndGggPiAxID8gXCIoXCIgOiBcIlwiLCBqb2luJDgoY29uY2F0JGMoW1wiLFwiLCBsaW5lJDhdKSwgZnVuY3Rpb25EZWNsYXJhdGlvblBhdGgubWFwKHByaW50LCBcInBhcmFtc1wiKSksIHBhcmFtcy5sZW5ndGggPiAxID8gXCIpXCIgOiBcIlwiXSk7XG4gICAgICB9LCBcInByb2dyYW1cIiwgXCJib2R5XCIsIDApO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLl9faXNWdWVTbG90U2NvcGUpIHtcbiAgICAgIHJldHVybiBwYXRoLmNhbGwoZnVuY3Rpb25EZWNsYXJhdGlvblBhdGggPT4gam9pbiQ4KGNvbmNhdCRjKFtcIixcIiwgbGluZSQ4XSksIGZ1bmN0aW9uRGVjbGFyYXRpb25QYXRoLm1hcChwcmludCwgXCJwYXJhbXNcIikpLCBcInByb2dyYW1cIiwgXCJib2R5XCIsIDApO1xuICAgIH1cbiAgfSAvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vcHJldHRpZXIvcHJldHRpZXIvYmxvYi9tYXN0ZXIvc3JjL2xhbmd1YWdlLWh0bWwvc3ludGF4LXZ1ZS5qcyBpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb24oKVxuXG5cbiAgZnVuY3Rpb24gaXNWdWVFdmVudEJpbmRpbmdFeHByZXNzaW9uJDIobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKG5vZGUucHJvcGVydHkudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgICAgICAgY2FzZSBcIlN0cmluZ0xpdGVyYWxcIjpcbiAgICAgICAgICAgIHJldHVybiBpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb24kMihub2RlLm9iamVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIGh0bWxCaW5kaW5nID0ge1xuICAgIGlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbjogaXNWdWVFdmVudEJpbmRpbmdFeHByZXNzaW9uJDIsXG4gICAgcHJpbnRIdG1sQmluZGluZ1xuICB9O1xuXG4gIGZ1bmN0aW9uIHByZXByb2Nlc3MkMShhc3QsIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMucGFyc2VyKSB7XG4gICAgICBjYXNlIFwianNvblwiOlxuICAgICAgY2FzZSBcImpzb241XCI6XG4gICAgICBjYXNlIFwianNvbi1zdHJpbmdpZnlcIjpcbiAgICAgIGNhc2UgXCJfX2pzX2V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJfX3Z1ZV9leHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhc3QsIHtcbiAgICAgICAgICB0eXBlOiBvcHRpb25zLnBhcnNlci5zdGFydHNXaXRoKFwiX19cIikgPyBcIkpzRXhwcmVzc2lvblJvb3RcIiA6IFwiSnNvblJvb3RcIixcbiAgICAgICAgICBub2RlOiBhc3QsXG4gICAgICAgICAgY29tbWVudHM6IFtdLFxuICAgICAgICAgIHJvb3RNYXJrZXI6IG9wdGlvbnMucm9vdE1hcmtlclxuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJlcHJvY2Vzc18xJDEgPSBwcmVwcm9jZXNzJDE7XG5cbiAgY29uc3Qge1xuICAgIHNob3VsZEZsYXR0ZW46IHNob3VsZEZsYXR0ZW4kMSxcbiAgICBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVyOiBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVyJDEsXG4gICAgaGFzTmV3bGluZTogaGFzTmV3bGluZSQ1LFxuICAgIGhhc05ld2xpbmVJblJhbmdlOiBoYXNOZXdsaW5lSW5SYW5nZSQzLFxuICAgIGdldExhc3Q6IGdldExhc3QkMyxcbiAgICBnZXRTdHJpbmdXaWR0aDogZ2V0U3RyaW5nV2lkdGgkMyxcbiAgICBwcmludFN0cmluZzogcHJpbnRTdHJpbmckMixcbiAgICBwcmludE51bWJlcjogcHJpbnROdW1iZXIkMixcbiAgICBoYXNJZ25vcmVDb21tZW50OiBoYXNJZ25vcmVDb21tZW50JDQsXG4gICAgaGFzTm9kZUlnbm9yZUNvbW1lbnQ6IGhhc05vZGVJZ25vcmVDb21tZW50JDIsXG4gICAgZ2V0UGVudWx0aW1hdGU6IGdldFBlbnVsdGltYXRlJDEsXG4gICAgc3RhcnRzV2l0aE5vTG9va2FoZWFkVG9rZW46IHN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuJDEsXG4gICAgZ2V0SW5kZW50U2l6ZTogZ2V0SW5kZW50U2l6ZSQyLFxuICAgIGdldFByZWZlcnJlZFF1b3RlOiBnZXRQcmVmZXJyZWRRdW90ZSQxXG4gIH0gPSB1dGlsJDE7XG4gIGNvbnN0IHtcbiAgICBpc05leHRMaW5lRW1wdHk6IGlzTmV4dExpbmVFbXB0eSQ0LFxuICAgIGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXg6IGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXgkMixcbiAgICBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXg6IGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleCQzXG4gIH0gPSB1dGlsU2hhcmVkO1xuICBjb25zdCB7XG4gICAgaW5zZXJ0UHJhZ21hOiBpbnNlcnRQcmFnbWEkN1xuICB9ID0gcHJhZ21hO1xuICBjb25zdCB7XG4gICAgcHJpbnRIdG1sQmluZGluZzogcHJpbnRIdG1sQmluZGluZyQxLFxuICAgIGlzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbjogaXNWdWVFdmVudEJpbmRpbmdFeHByZXNzaW9uJDNcbiAgfSA9IGh0bWxCaW5kaW5nO1xuICBjb25zdCB7XG4gICAgY2xhc3NDaGlsZE5lZWRzQVNJUHJvdGVjdGlvbjogY2xhc3NDaGlsZE5lZWRzQVNJUHJvdGVjdGlvbiQxLFxuICAgIGNsYXNzUHJvcE1heUNhdXNlQVNJUHJvYmxlbXM6IGNsYXNzUHJvcE1heUNhdXNlQVNJUHJvYmxlbXMkMSxcbiAgICBjb25kaXRpb25hbEV4cHJlc3Npb25DaGFpbkNvbnRhaW5zSlNYOiBjb25kaXRpb25hbEV4cHJlc3Npb25DaGFpbkNvbnRhaW5zSlNYJDEsXG4gICAgZ2V0Rmxvd1ZhcmlhbmNlOiBnZXRGbG93VmFyaWFuY2UkMSxcbiAgICBnZXRMZWZ0U2lkZVBhdGhOYW1lOiBnZXRMZWZ0U2lkZVBhdGhOYW1lJDIsXG4gICAgZ2V0UGFyZW50RXhwb3J0RGVjbGFyYXRpb246IGdldFBhcmVudEV4cG9ydERlY2xhcmF0aW9uJDEsXG4gICAgZ2V0VHlwZVNjcmlwdE1hcHBlZFR5cGVNb2RpZmllcjogZ2V0VHlwZVNjcmlwdE1hcHBlZFR5cGVNb2RpZmllciQxLFxuICAgIGhhc0RhbmdsaW5nQ29tbWVudHM6IGhhc0RhbmdsaW5nQ29tbWVudHMkMSxcbiAgICBoYXNGbG93QW5ub3RhdGlvbkNvbW1lbnQ6IGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCQxLFxuICAgIGhhc0Zsb3dTaG9ydGhhbmRBbm5vdGF0aW9uQ29tbWVudDogaGFzRmxvd1Nob3J0aGFuZEFubm90YXRpb25Db21tZW50JDIsXG4gICAgaGFzTGVhZGluZ0NvbW1lbnQ6IGhhc0xlYWRpbmdDb21tZW50JDMsXG4gICAgaGFzTGVhZGluZ093bkxpbmVDb21tZW50OiBoYXNMZWFkaW5nT3duTGluZUNvbW1lbnQkMSxcbiAgICBoYXNOYWtlZExlZnRTaWRlOiBoYXNOYWtlZExlZnRTaWRlJDIsXG4gICAgaGFzTmV3bGluZUJldHdlZW5PckFmdGVyRGVjb3JhdG9yczogaGFzTmV3bGluZUJldHdlZW5PckFmdGVyRGVjb3JhdG9ycyQxLFxuICAgIGhhc05nU2lkZUVmZmVjdDogaGFzTmdTaWRlRWZmZWN0JDEsXG4gICAgaGFzUHJldHRpZXJJZ25vcmU6IGhhc1ByZXR0aWVySWdub3JlJDUsXG4gICAgaGFzVHJhaWxpbmdDb21tZW50OiBoYXNUcmFpbGluZ0NvbW1lbnQkMSxcbiAgICBpZGVudGl0eTogaWRlbnRpdHkkMixcbiAgICBpc0JpbmFyeWlzaDogaXNCaW5hcnlpc2gkMSxcbiAgICBpc0NhbGxPck9wdGlvbmFsQ2FsbEV4cHJlc3Npb246IGlzQ2FsbE9yT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiQxLFxuICAgIGlzRW1wdHlKU1hFbGVtZW50OiBpc0VtcHR5SlNYRWxlbWVudCQxLFxuICAgIGlzRXhwb3J0RGVjbGFyYXRpb246IGlzRXhwb3J0RGVjbGFyYXRpb24kMSxcbiAgICBpc0Zsb3dBbm5vdGF0aW9uQ29tbWVudDogaXNGbG93QW5ub3RhdGlvbkNvbW1lbnQkMSxcbiAgICBpc0Z1bmN0aW9uQ29tcG9zaXRpb25BcmdzOiBpc0Z1bmN0aW9uQ29tcG9zaXRpb25BcmdzJDEsXG4gICAgaXNGdW5jdGlvbk5vdGF0aW9uOiBpc0Z1bmN0aW9uTm90YXRpb24kMSxcbiAgICBpc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb246IGlzRnVuY3Rpb25PckFycm93RXhwcmVzc2lvbiQxLFxuICAgIGlzR2V0dGVyT3JTZXR0ZXI6IGlzR2V0dGVyT3JTZXR0ZXIkMSxcbiAgICBpc0plc3RFYWNoVGVtcGxhdGVMaXRlcmFsOiBpc0plc3RFYWNoVGVtcGxhdGVMaXRlcmFsJDEsXG4gICAgaXNKU1hOb2RlOiBpc0pTWE5vZGUkMSxcbiAgICBpc0pTWFdoaXRlc3BhY2VFeHByZXNzaW9uOiBpc0pTWFdoaXRlc3BhY2VFeHByZXNzaW9uJDEsXG4gICAgaXNMYXN0U3RhdGVtZW50OiBpc0xhc3RTdGF0ZW1lbnQkMSxcbiAgICBpc0xpdGVyYWw6IGlzTGl0ZXJhbCQxLFxuICAgIGlzTG9uZ0N1cnJpZWRDYWxsRXhwcmVzc2lvbjogaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uJDEsXG4gICAgaXNNZWFuaW5nZnVsSlNYVGV4dDogaXNNZWFuaW5nZnVsSlNYVGV4dCQxLFxuICAgIGlzTWVtYmVyRXhwcmVzc2lvbkNoYWluOiBpc01lbWJlckV4cHJlc3Npb25DaGFpbiQxLFxuICAgIGlzTWVtYmVyaXNoOiBpc01lbWJlcmlzaCQxLFxuICAgIGlzTmdGb3JPZjogaXNOZ0Zvck9mJDEsXG4gICAgaXNOdW1lcmljTGl0ZXJhbDogaXNOdW1lcmljTGl0ZXJhbCQxLFxuICAgIGlzT2JqZWN0VHlwZTogaXNPYmplY3RUeXBlJDEsXG4gICAgaXNPYmplY3RUeXBlUHJvcGVydHlBRnVuY3Rpb246IGlzT2JqZWN0VHlwZVByb3BlcnR5QUZ1bmN0aW9uJDEsXG4gICAgaXNTaW1wbGVDYWxsQXJndW1lbnQ6IGlzU2ltcGxlQ2FsbEFyZ3VtZW50JDEsXG4gICAgaXNTaW1wbGVGbG93VHlwZTogaXNTaW1wbGVGbG93VHlwZSQxLFxuICAgIGlzU2ltcGxlVGVtcGxhdGVMaXRlcmFsOiBpc1NpbXBsZVRlbXBsYXRlTGl0ZXJhbCQxLFxuICAgIGlzU3RyaW5nTGl0ZXJhbDogaXNTdHJpbmdMaXRlcmFsJDEsXG4gICAgaXNTdHJpbmdQcm9wU2FmZVRvQ29lcmNlVG9JZGVudGlmaWVyOiBpc1N0cmluZ1Byb3BTYWZlVG9Db2VyY2VUb0lkZW50aWZpZXIkMSxcbiAgICBpc1RlbXBsYXRlT25JdHNPd25MaW5lOiBpc1RlbXBsYXRlT25JdHNPd25MaW5lJDEsXG4gICAgaXNUZXN0Q2FsbDogaXNUZXN0Q2FsbCQxLFxuICAgIGlzVGhlT25seUpTWEVsZW1lbnRJbk1hcmtkb3duOiBpc1RoZU9ubHlKU1hFbGVtZW50SW5NYXJrZG93biQxLFxuICAgIGlzVFNYRmlsZTogaXNUU1hGaWxlJDEsXG4gICAgaXNUeXBlQW5ub3RhdGlvbkFGdW5jdGlvbjogaXNUeXBlQW5ub3RhdGlvbkFGdW5jdGlvbiQxLFxuICAgIG1hdGNoSnN4V2hpdGVzcGFjZVJlZ2V4OiBtYXRjaEpzeFdoaXRlc3BhY2VSZWdleCQxLFxuICAgIG5lZWRzSGFyZGxpbmVBZnRlckRhbmdsaW5nQ29tbWVudDogbmVlZHNIYXJkbGluZUFmdGVyRGFuZ2xpbmdDb21tZW50JDEsXG4gICAgcmF3VGV4dDogcmF3VGV4dCQxLFxuICAgIHJldHVybkFyZ3VtZW50SGFzTGVhZGluZ0NvbW1lbnQ6IHJldHVybkFyZ3VtZW50SGFzTGVhZGluZ0NvbW1lbnQkMVxuICB9ID0gdXRpbHMkNTtcbiAgY29uc3QgbmVlZHNRdW90ZVByb3BzID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3Qge1xuICAgIGJ1aWxkZXJzOiB7XG4gICAgICBjb25jYXQ6IGNvbmNhdCRkLFxuICAgICAgam9pbjogam9pbiQ5LFxuICAgICAgbGluZTogbGluZSQ5LFxuICAgICAgaGFyZGxpbmU6IGhhcmRsaW5lJDksXG4gICAgICBzb2Z0bGluZTogc29mdGxpbmUkNixcbiAgICAgIGxpdGVyYWxsaW5lOiBsaXRlcmFsbGluZSQ0LFxuICAgICAgZ3JvdXA6IGdyb3VwJGIsXG4gICAgICBpbmRlbnQ6IGluZGVudCQ3LFxuICAgICAgYWxpZ246IGFsaWduJDEsXG4gICAgICBjb25kaXRpb25hbEdyb3VwOiBjb25kaXRpb25hbEdyb3VwJDEsXG4gICAgICBmaWxsOiBmaWxsJDQsXG4gICAgICBpZkJyZWFrOiBpZkJyZWFrJDYsXG4gICAgICBicmVha1BhcmVudDogYnJlYWtQYXJlbnQkMyxcbiAgICAgIGxpbmVTdWZmaXhCb3VuZGFyeTogbGluZVN1ZmZpeEJvdW5kYXJ5JDEsXG4gICAgICBhZGRBbGlnbm1lbnRUb0RvYzogYWRkQWxpZ25tZW50VG9Eb2MkMixcbiAgICAgIGRlZGVudDogZGVkZW50JDJcbiAgICB9LFxuICAgIHV0aWxzOiB7XG4gICAgICB3aWxsQnJlYWs6IHdpbGxCcmVhayQxLFxuICAgICAgaXNMaW5lTmV4dDogaXNMaW5lTmV4dCQxLFxuICAgICAgaXNFbXB0eTogaXNFbXB0eSQxLFxuICAgICAgcmVtb3ZlTGluZXM6IHJlbW92ZUxpbmVzJDJcbiAgICB9LFxuICAgIHByaW50ZXI6IHtcbiAgICAgIHByaW50RG9jVG9TdHJpbmc6IHByaW50RG9jVG9TdHJpbmckMlxuICAgIH1cbiAgfSA9IGRvY3VtZW50O1xuICBsZXQgdWlkID0gMDtcblxuICBmdW5jdGlvbiBzaG91bGRQcmludENvbW1hJDEob3B0aW9ucywgbGV2ZWwpIHtcbiAgICBsZXZlbCA9IGxldmVsIHx8IFwiZXM1XCI7XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMudHJhaWxpbmdDb21tYSkge1xuICAgICAgY2FzZSBcImFsbFwiOlxuICAgICAgICBpZiAobGV2ZWwgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBmYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFwiZXM1XCI6XG4gICAgICAgIGlmIChsZXZlbCA9PT0gXCJlczVcIikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJpY1ByaW50JDMocGF0aCwgb3B0aW9ucywgcHJpbnRQYXRoLCBhcmdzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBsZXQgbmVlZHNQYXJlbnMgPSBmYWxzZTtcbiAgICBjb25zdCBsaW5lc1dpdGhvdXRQYXJlbnMgPSBwcmludFBhdGhOb1BhcmVucyhwYXRoLCBvcHRpb25zLCBwcmludFBhdGgsIGFyZ3MpO1xuXG4gICAgaWYgKCFub2RlIHx8IGlzRW1wdHkkMShsaW5lc1dpdGhvdXRQYXJlbnMpKSB7XG4gICAgICByZXR1cm4gbGluZXNXaXRob3V0UGFyZW5zO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudEV4cG9ydERlY2wgPSBnZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbiQxKHBhdGgpO1xuICAgIGNvbnN0IGRlY29yYXRvcnMgPSBbXTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQ2xhc3NNZXRob2RcIiB8fCBub2RlLnR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiVFNBYnN0cmFjdENsYXNzUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiB8fCBub2RlLnR5cGUgPT09IFwiTWV0aG9kRGVmaW5pdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJUU0RlY2xhcmVNZXRob2RcIikgOyBlbHNlIGlmIChub2RlLmRlY29yYXRvcnMgJiYgbm9kZS5kZWNvcmF0b3JzLmxlbmd0aCA+IDAgJiYgLy8gSWYgdGhlIHBhcmVudCBub2RlIGlzIGFuIGV4cG9ydCBkZWNsYXJhdGlvbiBhbmQgdGhlIGRlY29yYXRvclxuICAgIC8vIHdhcyB3cml0dGVuIGJlZm9yZSB0aGUgZXhwb3J0LCB0aGUgZXhwb3J0IHdpbGwgYmUgcmVzcG9uc2libGVcbiAgICAvLyBmb3IgcHJpbnRpbmcgdGhlIGRlY29yYXRvcnMuXG4gICAgIShwYXJlbnRFeHBvcnREZWNsICYmIG9wdGlvbnMubG9jU3RhcnQocGFyZW50RXhwb3J0RGVjbCwge1xuICAgICAgaWdub3JlRGVjb3JhdG9yczogdHJ1ZVxuICAgIH0pID4gb3B0aW9ucy5sb2NTdGFydChub2RlLmRlY29yYXRvcnNbMF0pKSkge1xuICAgICAgY29uc3Qgc2hvdWxkQnJlYWsgPSBub2RlLnR5cGUgPT09IFwiQ2xhc3NFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fCBoYXNOZXdsaW5lQmV0d2Vlbk9yQWZ0ZXJEZWNvcmF0b3JzJDEobm9kZSwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBzZXBhcmF0b3IgPSBzaG91bGRCcmVhayA/IGhhcmRsaW5lJDkgOiBsaW5lJDk7XG4gICAgICBwYXRoLmVhY2goZGVjb3JhdG9yUGF0aCA9PiB7XG4gICAgICAgIGxldCBkZWNvcmF0b3IgPSBkZWNvcmF0b3JQYXRoLmdldFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGRlY29yYXRvci5leHByZXNzaW9uKSB7XG4gICAgICAgICAgZGVjb3JhdG9yID0gZGVjb3JhdG9yLmV4cHJlc3Npb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVjb3JhdG9yID0gZGVjb3JhdG9yLmNhbGxlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRvcnMucHVzaChwcmludFBhdGgoZGVjb3JhdG9yUGF0aCksIHNlcGFyYXRvcik7XG4gICAgICB9LCBcImRlY29yYXRvcnNcIik7XG5cbiAgICAgIGlmIChwYXJlbnRFeHBvcnREZWNsKSB7XG4gICAgICAgIGRlY29yYXRvcnMudW5zaGlmdChoYXJkbGluZSQ5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRXhwb3J0RGVjbGFyYXRpb24kMShub2RlKSAmJiBub2RlLmRlY2xhcmF0aW9uICYmIG5vZGUuZGVjbGFyYXRpb24uZGVjb3JhdG9ycyAmJiBub2RlLmRlY2xhcmF0aW9uLmRlY29yYXRvcnMubGVuZ3RoID4gMCAmJiAvLyBPbmx5IHByaW50IGRlY29yYXRvcnMgaGVyZSBpZiB0aGV5IHdlcmUgd3JpdHRlbiBiZWZvcmUgdGhlIGV4cG9ydCxcbiAgICAvLyBvdGhlcndpc2UgdGhleSBhcmUgcHJpbnRlZCBieSB0aGUgbm9kZS5kZWNsYXJhdGlvblxuICAgIG9wdGlvbnMubG9jU3RhcnQobm9kZSwge1xuICAgICAgaWdub3JlRGVjb3JhdG9yczogdHJ1ZVxuICAgIH0pID4gb3B0aW9ucy5sb2NTdGFydChub2RlLmRlY2xhcmF0aW9uLmRlY29yYXRvcnNbMF0pKSB7XG4gICAgICAvLyBFeHBvcnQgZGVjbGFyYXRpb25zIGFyZSByZXNwb25zaWJsZSBmb3IgcHJpbnRpbmcgYW55IGRlY29yYXRvcnNcbiAgICAgIC8vIHRoYXQgbG9naWNhbGx5IGFwcGx5IHRvIG5vZGUuZGVjbGFyYXRpb24uXG4gICAgICBwYXRoLmVhY2goZGVjb3JhdG9yUGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IGRlY29yYXRvciA9IGRlY29yYXRvclBhdGguZ2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gZGVjb3JhdG9yLnR5cGUgPT09IFwiRGVjb3JhdG9yXCIgPyBcIlwiIDogXCJAXCI7XG4gICAgICAgIGRlY29yYXRvcnMucHVzaChwcmVmaXgsIHByaW50UGF0aChkZWNvcmF0b3JQYXRoKSwgaGFyZGxpbmUkOSk7XG4gICAgICB9LCBcImRlY2xhcmF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZXMgd2l0aCBkZWNvcmF0b3JzIGNhbid0IGhhdmUgcGFyZW50aGVzZXMsIHNvIHdlIGNhbiBhdm9pZFxuICAgICAgLy8gY29tcHV0aW5nIHBhdGhOZWVkc1BhcmVucygpIGV4Y2VwdCBpbiB0aGlzIGNhc2UuXG4gICAgICBuZWVkc1BhcmVucyA9IG5lZWRzUGFyZW5zXzEocGF0aCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSBbXTtcblxuICAgIGlmIChuZWVkc1BhcmVucykge1xuICAgICAgcGFydHMudW5zaGlmdChcIihcIik7XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChsaW5lc1dpdGhvdXRQYXJlbnMpO1xuXG4gICAgaWYgKG5lZWRzUGFyZW5zKSB7XG4gICAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAoaGFzRmxvd1Nob3J0aGFuZEFubm90YXRpb25Db21tZW50JDIobm9kZSkpIHtcbiAgICAgICAgcGFydHMucHVzaChcIiAvKlwiKTtcbiAgICAgICAgcGFydHMucHVzaChub2RlLnRyYWlsaW5nQ29tbWVudHNbMF0udmFsdWUudHJpbVN0YXJ0KCkpO1xuICAgICAgICBwYXJ0cy5wdXNoKFwiKi9cIik7XG4gICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50c1swXS5wcmludGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcGFydHMucHVzaChcIilcIik7XG4gICAgfVxuXG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoZGVjb3JhdG9ycy5jb25jYXQocGFydHMpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50RGVjb3JhdG9ycyhwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW2pvaW4kOShsaW5lJDksIHBhdGgubWFwKHByaW50LCBcImRlY29yYXRvcnNcIikpLCBoYXNOZXdsaW5lQmV0d2Vlbk9yQWZ0ZXJEZWNvcmF0b3JzJDEobm9kZSwgb3B0aW9ucykgPyBoYXJkbGluZSQ5IDogbGluZSQ5XSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZm9sbG93aW5nIGlzIHRoZSBzaGFyZWQgbG9naWMgZm9yXG4gICAqIHRlcm5hcnkgb3BlcmF0b3JzLCBuYW1lbHkgQ29uZGl0aW9uYWxFeHByZXNzaW9uXG4gICAqIGFuZCBUU0NvbmRpdGlvbmFsVHlwZVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBPcGVyYXRvck9wdGlvbnNcbiAgICogQHByb3BlcnR5IHsoKSA9PiBBcnJheTxzdHJpbmcgfCBEb2M+fSBiZWZvcmVQYXJ0cyAtIFBhcnRzIHRvIHByaW50IGJlZm9yZSB0aGUgYD9gLlxuICAgKiBAcHJvcGVydHkgeyhicmVha0Nsb3NpbmdQYXJlbjogYm9vbGVhbikgPT4gQXJyYXk8c3RyaW5nIHwgRG9jPn0gYWZ0ZXJQYXJ0cyAtIFBhcnRzIHRvIHByaW50IGFmdGVyIHRoZSBjb25kaXRpb25hbCBleHByZXNzaW9uLlxuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNob3VsZENoZWNrSnN4IC0gV2hldGhlciB0byBjaGVjayBmb3IgYW5kIHByaW50IGluIEpTWCBtb2RlLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29uZGl0aW9uYWxOb2RlVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjb25kaXRpb25hbCBleHByZXNzaW9uIG5vZGUsIGllIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgb3IgXCJUU0NvbmRpdGlvbmFsVHlwZVwiLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gY29uc2VxdWVudE5vZGVQcm9wZXJ0eU5hbWUgLSBUaGUgcHJvcGVydHkgYXQgd2hpY2ggdGhlIGNvbnNlcXVlbnQgbm9kZSBjYW4gYmUgZm91bmQgb24gdGhlIG1haW4gbm9kZSwgZWcgXCJjb25zZXF1ZW50XCIuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhbHRlcm5hdGVOb2RlUHJvcGVydHlOYW1lIC0gVGhlIHByb3BlcnR5IGF0IHdoaWNoIHRoZSBhbHRlcm5hdGUgbm9kZSBjYW4gYmUgZm91bmQgb24gdGhlIG1haW4gbm9kZSwgZWcgXCJhbHRlcm5hdGVcIi5cbiAgICogQHByb3BlcnR5IHtzdHJpbmdbXX0gdGVzdE5vZGVQcm9wZXJ0eU5hbWVzIC0gVGhlIHByb3BlcnRpZXMgYXQgd2hpY2ggdGhlIHRlc3Qgbm9kZXMgY2FuIGJlIGZvdW5kIG9uIHRoZSBtYWluIG5vZGUsIGVnIFwidGVzdFwiLlxuICAgKiBAcGFyYW0ge0Zhc3RQYXRofSBwYXRoIC0gVGhlIHBhdGggdG8gdGhlIENvbmRpdGlvbmFsRXhwcmVzc2lvbi9UU0NvbmRpdGlvbmFsVHlwZSBub2RlLlxuICAgKiBAcGFyYW0ge09wdGlvbnN9IG9wdGlvbnMgLSBQcmV0dGllciBvcHRpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByaW50IC0gUHJpbnQgZnVuY3Rpb24gdG8gY2FsbCByZWN1cnNpdmVseVxuICAgKiBAcGFyYW0ge09wZXJhdG9yT3B0aW9uc30gb3BlcmF0b3JPcHRpb25zXG4gICAqIEByZXR1cm5zIERvY1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHByaW50VGVybmFyeU9wZXJhdG9yKHBhdGgsIG9wdGlvbnMsIHByaW50LCBvcGVyYXRvck9wdGlvbnMpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IGNvbnNlcXVlbnROb2RlID0gbm9kZVtvcGVyYXRvck9wdGlvbnMuY29uc2VxdWVudE5vZGVQcm9wZXJ0eU5hbWVdO1xuICAgIGNvbnN0IGFsdGVybmF0ZU5vZGUgPSBub2RlW29wZXJhdG9yT3B0aW9ucy5hbHRlcm5hdGVOb2RlUHJvcGVydHlOYW1lXTtcbiAgICBjb25zdCBwYXJ0cyA9IFtdOyAvLyBXZSBwcmludCBhIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBpbiBlaXRoZXIgXCJKU1ggbW9kZVwiIG9yIFwibm9ybWFsIG1vZGVcIi5cbiAgICAvLyBTZWUgdGVzdHMvanN4L2NvbmRpdGlvbmFsLWV4cHJlc3Npb24uanMgZm9yIG1vcmUgaW5mby5cblxuICAgIGxldCBqc3hNb2RlID0gZmFsc2U7XG4gICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgY29uc3QgaXNQYXJlbnRUZXN0ID0gcGFyZW50LnR5cGUgPT09IG9wZXJhdG9yT3B0aW9ucy5jb25kaXRpb25hbE5vZGVUeXBlICYmIG9wZXJhdG9yT3B0aW9ucy50ZXN0Tm9kZVByb3BlcnR5TmFtZXMuc29tZShwcm9wID0+IHBhcmVudFtwcm9wXSA9PT0gbm9kZSk7XG4gICAgbGV0IGZvcmNlTm9JbmRlbnQgPSBwYXJlbnQudHlwZSA9PT0gb3BlcmF0b3JPcHRpb25zLmNvbmRpdGlvbmFsTm9kZVR5cGUgJiYgIWlzUGFyZW50VGVzdDsgLy8gRmluZCB0aGUgb3V0ZXJtb3N0IG5vbi1Db25kaXRpb25hbEV4cHJlc3Npb24gcGFyZW50LCBhbmQgdGhlIG91dGVybW9zdFxuICAgIC8vIENvbmRpdGlvbmFsRXhwcmVzc2lvbiBwYXJlbnQuIFdlJ2xsIHVzZSB0aGVzZSB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkXG4gICAgLy8gcHJpbnQgaW4gSlNYIG1vZGUuXG5cbiAgICBsZXQgY3VycmVudFBhcmVudDtcbiAgICBsZXQgcHJldmlvdXNQYXJlbnQ7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgcHJldmlvdXNQYXJlbnQgPSBjdXJyZW50UGFyZW50IHx8IG5vZGU7XG4gICAgICBjdXJyZW50UGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKGkpO1xuICAgICAgaSsrO1xuICAgIH0gd2hpbGUgKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC50eXBlID09PSBvcGVyYXRvck9wdGlvbnMuY29uZGl0aW9uYWxOb2RlVHlwZSAmJiBvcGVyYXRvck9wdGlvbnMudGVzdE5vZGVQcm9wZXJ0eU5hbWVzLmV2ZXJ5KHByb3AgPT4gY3VycmVudFBhcmVudFtwcm9wXSAhPT0gcHJldmlvdXNQYXJlbnQpKTtcblxuICAgIGNvbnN0IGZpcnN0Tm9uQ29uZGl0aW9uYWxQYXJlbnQgPSBjdXJyZW50UGFyZW50IHx8IHBhcmVudDtcbiAgICBjb25zdCBsYXN0Q29uZGl0aW9uYWxQYXJlbnQgPSBwcmV2aW91c1BhcmVudDtcblxuICAgIGlmIChvcGVyYXRvck9wdGlvbnMuc2hvdWxkQ2hlY2tKc3ggJiYgKGlzSlNYTm9kZSQxKG5vZGVbb3BlcmF0b3JPcHRpb25zLnRlc3ROb2RlUHJvcGVydHlOYW1lc1swXV0pIHx8IGlzSlNYTm9kZSQxKGNvbnNlcXVlbnROb2RlKSB8fCBpc0pTWE5vZGUkMShhbHRlcm5hdGVOb2RlKSB8fCBjb25kaXRpb25hbEV4cHJlc3Npb25DaGFpbkNvbnRhaW5zSlNYJDEobGFzdENvbmRpdGlvbmFsUGFyZW50KSkpIHtcbiAgICAgIGpzeE1vZGUgPSB0cnVlO1xuICAgICAgZm9yY2VOb0luZGVudCA9IHRydWU7IC8vIEV2ZW4gdGhvdWdoIHRoZXkgZG9uJ3QgbmVlZCBwYXJlbnMsIHdlIHdyYXAgKGFsbW9zdCkgZXZlcnl0aGluZyBpblxuICAgICAgLy8gcGFyZW5zIHdoZW4gdXNpbmcgPzogd2l0aGluIEpTWCwgYmVjYXVzZSB0aGUgcGFyZW5zIGFyZSBhbmFsb2dvdXMgdG9cbiAgICAgIC8vIGN1cmx5IGJyYWNlcyBpbiBhbiBpZiBzdGF0ZW1lbnQuXG5cbiAgICAgIGNvbnN0IHdyYXAgPSBkb2MgPT4gY29uY2F0JGQoW2lmQnJlYWskNihcIihcIiwgXCJcIiksIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBkb2NdKSksIHNvZnRsaW5lJDYsIGlmQnJlYWskNihcIilcIiwgXCJcIildKTsgLy8gVGhlIG9ubHkgdGhpbmdzIHdlIGRvbid0IHdyYXAgYXJlOlxuICAgICAgLy8gKiBOZXN0ZWQgY29uZGl0aW9uYWwgZXhwcmVzc2lvbnMgaW4gYWx0ZXJuYXRlc1xuICAgICAgLy8gKiBudWxsXG4gICAgICAvLyAqIHVuZGVmaW5lZFxuXG5cbiAgICAgIGNvbnN0IGlzTmlsID0gbm9kZSA9PiBub2RlLnR5cGUgPT09IFwiTnVsbExpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIG5vZGUudmFsdWUgPT09IG51bGwgfHwgbm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBub2RlLm5hbWUgPT09IFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIHBhcnRzLnB1c2goXCIgPyBcIiwgaXNOaWwoY29uc2VxdWVudE5vZGUpID8gcGF0aC5jYWxsKHByaW50LCBvcGVyYXRvck9wdGlvbnMuY29uc2VxdWVudE5vZGVQcm9wZXJ0eU5hbWUpIDogd3JhcChwYXRoLmNhbGwocHJpbnQsIG9wZXJhdG9yT3B0aW9ucy5jb25zZXF1ZW50Tm9kZVByb3BlcnR5TmFtZSkpLCBcIiA6IFwiLCBhbHRlcm5hdGVOb2RlLnR5cGUgPT09IG9wZXJhdG9yT3B0aW9ucy5jb25kaXRpb25hbE5vZGVUeXBlIHx8IGlzTmlsKGFsdGVybmF0ZU5vZGUpID8gcGF0aC5jYWxsKHByaW50LCBvcGVyYXRvck9wdGlvbnMuYWx0ZXJuYXRlTm9kZVByb3BlcnR5TmFtZSkgOiB3cmFwKHBhdGguY2FsbChwcmludCwgb3BlcmF0b3JPcHRpb25zLmFsdGVybmF0ZU5vZGVQcm9wZXJ0eU5hbWUpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbCBtb2RlXG4gICAgICBjb25zdCBwYXJ0ID0gY29uY2F0JGQoW2xpbmUkOSwgXCI/IFwiLCBjb25zZXF1ZW50Tm9kZS50eXBlID09PSBvcGVyYXRvck9wdGlvbnMuY29uZGl0aW9uYWxOb2RlVHlwZSA/IGlmQnJlYWskNihcIlwiLCBcIihcIikgOiBcIlwiLCBhbGlnbiQxKDIsIHBhdGguY2FsbChwcmludCwgb3BlcmF0b3JPcHRpb25zLmNvbnNlcXVlbnROb2RlUHJvcGVydHlOYW1lKSksIGNvbnNlcXVlbnROb2RlLnR5cGUgPT09IG9wZXJhdG9yT3B0aW9ucy5jb25kaXRpb25hbE5vZGVUeXBlID8gaWZCcmVhayQ2KFwiXCIsIFwiKVwiKSA6IFwiXCIsIGxpbmUkOSwgXCI6IFwiLCBhbHRlcm5hdGVOb2RlLnR5cGUgPT09IG9wZXJhdG9yT3B0aW9ucy5jb25kaXRpb25hbE5vZGVUeXBlID8gcGF0aC5jYWxsKHByaW50LCBvcGVyYXRvck9wdGlvbnMuYWx0ZXJuYXRlTm9kZVByb3BlcnR5TmFtZSkgOiBhbGlnbiQxKDIsIHBhdGguY2FsbChwcmludCwgb3BlcmF0b3JPcHRpb25zLmFsdGVybmF0ZU5vZGVQcm9wZXJ0eU5hbWUpKV0pO1xuICAgICAgcGFydHMucHVzaChwYXJlbnQudHlwZSAhPT0gb3BlcmF0b3JPcHRpb25zLmNvbmRpdGlvbmFsTm9kZVR5cGUgfHwgcGFyZW50W29wZXJhdG9yT3B0aW9ucy5hbHRlcm5hdGVOb2RlUHJvcGVydHlOYW1lXSA9PT0gbm9kZSB8fCBpc1BhcmVudFRlc3QgPyBwYXJ0IDogb3B0aW9ucy51c2VUYWJzID8gZGVkZW50JDIoaW5kZW50JDcocGFydCkpIDogYWxpZ24kMShNYXRoLm1heCgwLCBvcHRpb25zLnRhYldpZHRoIC0gMiksIHBhcnQpKTtcbiAgICB9IC8vIFdlIHdhbnQgYSB3aG9sZSBjaGFpbiBvZiBDb25kaXRpb25hbEV4cHJlc3Npb25zIHRvIGFsbFxuICAgIC8vIGJyZWFrIGlmIGFueSBvZiB0aGVtIGJyZWFrLiBUaGF0IG1lYW5zIHdlIHNob3VsZCBvbmx5IGdyb3VwIGFyb3VuZCB0aGVcbiAgICAvLyBvdXRlci1tb3N0IENvbmRpdGlvbmFsRXhwcmVzc2lvbi5cblxuXG4gICAgY29uc3QgbWF5YmVHcm91cCA9IGRvYyA9PiBwYXJlbnQgPT09IGZpcnN0Tm9uQ29uZGl0aW9uYWxQYXJlbnQgPyBncm91cCRiKGRvYykgOiBkb2M7IC8vIEJyZWFrIHRoZSBjbG9zaW5nIHBhcmVuIHRvIGtlZXAgdGhlIGNoYWluIHJpZ2h0IGFmdGVyIGl0OlxuICAgIC8vIChhXG4gICAgLy8gICA/IGJcbiAgICAvLyAgIDogY1xuICAgIC8vICkuY2FsbCgpXG5cblxuICAgIGNvbnN0IGJyZWFrQ2xvc2luZ1BhcmVuID0gIWpzeE1vZGUgJiYgKHBhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJOR1BpcGVFeHByZXNzaW9uXCIgJiYgcGFyZW50LmxlZnQgPT09IG5vZGUpICYmICFwYXJlbnQuY29tcHV0ZWQ7XG4gICAgY29uc3QgcmVzdWx0ID0gbWF5YmVHcm91cChjb25jYXQkZChbXS5jb25jYXQoKHRlc3REb2MgPT5cbiAgICAvKipcbiAgICAgKiAgICAgYVxuICAgICAqICAgICAgID8gYlxuICAgICAqICAgICAgIDogbXVsdGlsaW5lXG4gICAgICogICAgICAgICB0ZXN0XG4gICAgICogICAgICAgICBub2RlXG4gICAgICogICAgICAgXl4gYWxpZ24oMilcbiAgICAgKiAgICAgICA/IGRcbiAgICAgKiAgICAgICA6IGVcbiAgICAgKi9cbiAgICBwYXJlbnQudHlwZSA9PT0gb3BlcmF0b3JPcHRpb25zLmNvbmRpdGlvbmFsTm9kZVR5cGUgJiYgcGFyZW50W29wZXJhdG9yT3B0aW9ucy5hbHRlcm5hdGVOb2RlUHJvcGVydHlOYW1lXSA9PT0gbm9kZSA/IGFsaWduJDEoMiwgdGVzdERvYykgOiB0ZXN0RG9jKShjb25jYXQkZChvcGVyYXRvck9wdGlvbnMuYmVmb3JlUGFydHMoKSkpLCBmb3JjZU5vSW5kZW50ID8gY29uY2F0JGQocGFydHMpIDogaW5kZW50JDcoY29uY2F0JGQocGFydHMpKSwgb3BlcmF0b3JPcHRpb25zLmFmdGVyUGFydHMoYnJlYWtDbG9zaW5nUGFyZW4pKSkpO1xuICAgIHJldHVybiBpc1BhcmVudFRlc3QgPyBncm91cCRiKGNvbmNhdCRkKFtpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcmVzdWx0XSkpLCBzb2Z0bGluZSQ2XSkpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRQYXRoTm9QYXJlbnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIGFyZ3MpIHtcbiAgICBjb25zdCBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHNlbWkgPSBvcHRpb25zLnNlbWkgPyBcIjtcIiA6IFwiXCI7XG5cbiAgICBpZiAoIW4pIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgY29uc3QgaHRtbEJpbmRpbmcgPSBwcmludEh0bWxCaW5kaW5nJDEocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuXG4gICAgaWYgKGh0bWxCaW5kaW5nKSB7XG4gICAgICByZXR1cm4gaHRtbEJpbmRpbmc7XG4gICAgfVxuXG4gICAgbGV0IHBhcnRzID0gW107XG5cbiAgICBzd2l0Y2ggKG4udHlwZSkge1xuICAgICAgY2FzZSBcIkpzRXhwcmVzc2lvblJvb3RcIjpcbiAgICAgICAgcmV0dXJuIHBhdGguY2FsbChwcmludCwgXCJub2RlXCIpO1xuXG4gICAgICBjYXNlIFwiSnNvblJvb3RcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwibm9kZVwiKSwgaGFyZGxpbmUkOV0pO1xuXG4gICAgICBjYXNlIFwiRmlsZVwiOlxuICAgICAgICAvLyBQcmludCBAYmFiZWwvcGFyc2VyJ3MgSW50ZXJwcmV0ZXJEaXJlY3RpdmUgaGVyZSBzbyB0aGF0XG4gICAgICAgIC8vIGxlYWRpbmcgY29tbWVudHMgb24gdGhlIGBQcm9ncmFtYCBub2RlIGdldCBwcmludGVkIGFmdGVyIHRoZSBoYXNoYmFuZy5cbiAgICAgICAgaWYgKG4ucHJvZ3JhbSAmJiBuLnByb2dyYW0uaW50ZXJwcmV0ZXIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcm9ncmFtUGF0aCA9PiBwcm9ncmFtUGF0aC5jYWxsKHByaW50LCBcImludGVycHJldGVyXCIpLCBcInByb2dyYW1cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwicHJvZ3JhbVwiKSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJQcm9ncmFtXCI6XG4gICAgICAgIC8vIEJhYmVsIDZcbiAgICAgICAgaWYgKG4uZGlyZWN0aXZlcykge1xuICAgICAgICAgIHBhdGguZWFjaChjaGlsZFBhdGggPT4ge1xuICAgICAgICAgICAgcGFydHMucHVzaChwcmludChjaGlsZFBhdGgpLCBzZW1pLCBoYXJkbGluZSQ5KTtcblxuICAgICAgICAgICAgaWYgKGlzTmV4dExpbmVFbXB0eSQ0KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBjaGlsZFBhdGguZ2V0VmFsdWUoKSwgb3B0aW9ucy5sb2NFbmQpKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgXCJkaXJlY3RpdmVzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwoYm9keVBhdGggPT4ge1xuICAgICAgICAgIHJldHVybiBwcmludFN0YXRlbWVudFNlcXVlbmNlKGJvZHlQYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgICAgIH0sIFwiYm9keVwiKSk7XG4gICAgICAgIHBhcnRzLnB1c2goY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgICAgdHJ1ZSkpOyAvLyBPbmx5IGZvcmNlIGEgdHJhaWxpbmcgbmV3bGluZSBpZiB0aGVyZSB3ZXJlIGFueSBjb250ZW50cy5cblxuICAgICAgICBpZiAoIW4uYm9keS5ldmVyeSgoe1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSkgPT4gdHlwZSA9PT0gXCJFbXB0eVN0YXRlbWVudFwiKSB8fCBuLmNvbW1lbnRzKSB7XG4gICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSQ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAvLyBCYWJlbCBleHRlbnNpb24uXG5cbiAgICAgIGNhc2UgXCJFbXB0eVN0YXRlbWVudFwiOlxuICAgICAgICByZXR1cm4gXCJcIjtcblxuICAgICAgY2FzZSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpcbiAgICAgICAgLy8gRGV0ZWN0IEZsb3ctcGFyc2VkIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG4uZGlyZWN0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtub2RlU3RyKG4uZXhwcmVzc2lvbiwgb3B0aW9ucywgdHJ1ZSksIHNlbWldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBhcnNlciA9PT0gXCJfX3Z1ZV9ldmVudF9iaW5kaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJQcm9ncmFtXCIgJiYgcGFyZW50LmJvZHkubGVuZ3RoID09PSAxICYmIHBhcmVudC5ib2R5WzBdID09PSBuKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb24kMyhuLmV4cHJlc3Npb24pID8gXCI7XCIgOiBcIlwiXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIERvIG5vdCBhcHBlbmQgc2VtaWNvbG9uIGFmdGVyIHRoZSBvbmx5IEpTWCBlbGVtZW50IGluIGEgcHJvZ3JhbVxuXG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSwgaXNUaGVPbmx5SlNYRWxlbWVudEluTWFya2Rvd24kMShvcHRpb25zLCBwYXRoKSA/IFwiXCIgOiBzZW1pXSk7XG4gICAgICAvLyBCYWJlbCBub24tc3RhbmRhcmQgbm9kZS4gVXNlZCBmb3IgQ2xvc3VyZS1zdHlsZSB0eXBlIGNhc3RzLiBTZWUgcG9zdHByb2Nlc3MuanMuXG5cbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkSHVnID0gIW4uZXhwcmVzc2lvbi5jb21tZW50cztcblxuICAgICAgICAgIGlmIChzaG91bGRIdWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkZChbXCIoXCIsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBcIilcIl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtcIihcIiwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpXSkpLCBzb2Z0bGluZSQ2LCBcIilcIl0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHByaW50QXNzaWdubWVudChuLmxlZnQsIHBhdGguY2FsbChwcmludCwgXCJsZWZ0XCIpLCBjb25jYXQkZChbXCIgXCIsIG4ub3BlcmF0b3JdKSwgbi5yaWdodCwgcGF0aC5jYWxsKHByaW50LCBcInJpZ2h0XCIpLCBvcHRpb25zKTtcblxuICAgICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk5HUGlwZUV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IHBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgxKTtcbiAgICAgICAgICBjb25zdCBpc0luc2lkZVBhcmVudGhlc2lzID0gbiAhPT0gcGFyZW50LmJvZHkgJiYgKHBhcmVudC50eXBlID09PSBcIklmU3RhdGVtZW50XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiV2hpbGVTdGF0ZW1lbnRcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJTd2l0Y2hTdGF0ZW1lbnRcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJEb1doaWxlU3RhdGVtZW50XCIpO1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gcHJpbnRCaW5hcnlpc2hFeHByZXNzaW9ucyhwYXRoLCBwcmludCwgb3B0aW9ucyxcbiAgICAgICAgICAvKiBpc05lc3RlZCAqL1xuICAgICAgICAgIGZhbHNlLCBpc0luc2lkZVBhcmVudGhlc2lzKTsgLy8gICBpZiAoXG4gICAgICAgICAgLy8gICAgIHRoaXMuaGFzUGx1Z2luKFwiZHluYW1pY0ltcG9ydHNcIikgJiYgdGhpcy5sb29rYWhlYWQoKS50eXBlID09PSB0dC5wYXJlbkxlZnRcbiAgICAgICAgICAvLyAgICkge1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gbG9va3Mgc3VwZXIgd2VpcmQsIHdlIHdhbnQgdG8gYnJlYWsgdGhlIGNoaWxkcmVuIGlmIHRoZSBwYXJlbnQgYnJlYWtzXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgIGlmIChcbiAgICAgICAgICAvLyAgICAgdGhpcy5oYXNQbHVnaW4oXCJkeW5hbWljSW1wb3J0c1wiKSAmJlxuICAgICAgICAgIC8vICAgICB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IHR0LnBhcmVuTGVmdFxuICAgICAgICAgIC8vICAgKSB7XG5cbiAgICAgICAgICBpZiAoaXNJbnNpZGVQYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgICB9IC8vIEJyZWFrIGJldHdlZW4gdGhlIHBhcmVucyBpblxuICAgICAgICAgIC8vIHVuYXJpZXMgb3IgaW4gYSBtZW1iZXIgb3Igc3BlY2lmaWMgY2FsbCBleHByZXNzaW9uLCBpLmUuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgIChcbiAgICAgICAgICAvLyAgICAgYSAmJlxuICAgICAgICAgIC8vICAgICBiICYmXG4gICAgICAgICAgLy8gICAgIGNcbiAgICAgICAgICAvLyAgICkuY2FsbCgpXG5cblxuICAgICAgICAgIGlmICgocGFyZW50LnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpICYmIHBhcmVudC5jYWxsZWUgPT09IG4gfHwgcGFyZW50LnR5cGUgPT09IFwiVW5hcnlFeHByZXNzaW9uXCIgfHwgKHBhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikgJiYgIXBhcmVudC5jb21wdXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW2luZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBjb25jYXQkZChwYXJ0cyldKSksIHNvZnRsaW5lJDZdKSk7XG4gICAgICAgICAgfSAvLyBBdm9pZCBpbmRlbnRpbmcgc3ViLWV4cHJlc3Npb25zIGluIHNvbWUgY2FzZXMgd2hlcmUgdGhlIGZpcnN0IHN1Yi1leHByZXNzaW9uIGlzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbmRlbnRlZCBhY2NvcmRpbmdseS4gV2Ugc2hvdWxkIGluZGVudCBzdWItZXhwcmVzc2lvbnMgd2hlcmUgdGhlIGZpcnN0IGNhc2UgaXNuJ3QgaW5kZW50ZWQuXG5cblxuICAgICAgICAgIGNvbnN0IHNob3VsZE5vdEluZGVudCA9IHBhcmVudC50eXBlID09PSBcIlJldHVyblN0YXRlbWVudFwiIHx8IHBhcmVudC50eXBlID09PSBcIlRocm93U3RhdGVtZW50XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiICYmIHBhcmVudFBhcmVudC50eXBlID09PSBcIkpTWEF0dHJpYnV0ZVwiIHx8IG4ub3BlcmF0b3IgIT09IFwifFwiICYmIHBhcmVudC50eXBlID09PSBcIkpzRXhwcmVzc2lvblJvb3RcIiB8fCBuLnR5cGUgIT09IFwiTkdQaXBlRXhwcmVzc2lvblwiICYmIChwYXJlbnQudHlwZSA9PT0gXCJOR1Jvb3RcIiAmJiBvcHRpb25zLnBhcnNlciA9PT0gXCJfX25nX2JpbmRpbmdcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwiICYmIHBhcmVudFBhcmVudC50eXBlID09PSBcIk5HTWljcm9zeW50YXhcIiAmJiBwYXJlbnRQYXJlbnQuYm9keS5sZW5ndGggPT09IDEpIHx8IG4gPT09IHBhcmVudC5ib2R5ICYmIHBhcmVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbiAhPT0gcGFyZW50LmJvZHkgJiYgcGFyZW50LnR5cGUgPT09IFwiRm9yU3RhdGVtZW50XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgJiYgcGFyZW50UGFyZW50LnR5cGUgIT09IFwiUmV0dXJuU3RhdGVtZW50XCIgJiYgcGFyZW50UGFyZW50LnR5cGUgIT09IFwiVGhyb3dTdGF0ZW1lbnRcIiAmJiBwYXJlbnRQYXJlbnQudHlwZSAhPT0gXCJDYWxsRXhwcmVzc2lvblwiICYmIHBhcmVudFBhcmVudC50eXBlICE9PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIjtcbiAgICAgICAgICBjb25zdCBzaG91bGRJbmRlbnRJZklubGluaW5nID0gcGFyZW50LnR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJDbGFzc1Byb3BlcnR5XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNBYnN0cmFjdENsYXNzUHJvcGVydHlcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiIHx8IHBhcmVudC50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiUHJvcGVydHlcIjtcbiAgICAgICAgICBjb25zdCBzYW1lUHJlY2VkZW5jZVN1YkV4cHJlc3Npb24gPSBpc0JpbmFyeWlzaCQxKG4ubGVmdCkgJiYgc2hvdWxkRmxhdHRlbiQxKG4ub3BlcmF0b3IsIG4ubGVmdC5vcGVyYXRvcik7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkTm90SW5kZW50IHx8IHNob3VsZElubGluZUxvZ2ljYWxFeHByZXNzaW9uKG4pICYmICFzYW1lUHJlY2VkZW5jZVN1YkV4cHJlc3Npb24gfHwgIXNob3VsZElubGluZUxvZ2ljYWxFeHByZXNzaW9uKG4pICYmIHNob3VsZEluZGVudElmSW5saW5pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKHBhcnRzKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfSAvLyBJZiB0aGUgcmlnaHQgcGFydCBpcyBhIEpTWCBub2RlLCB3ZSBpbmNsdWRlIGl0IGluIGEgc2VwYXJhdGUgZ3JvdXAgdG9cbiAgICAgICAgICAvLyBwcmV2ZW50IGl0IGJyZWFraW5nIHRoZSB3aG9sZSBjaGFpbiwgc28gd2UgY2FuIHByaW50IHRoZSBleHByZXNzaW9uIGxpa2U6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAgIGZvbyAmJiBiYXIgJiYgKFxuICAgICAgICAgIC8vICAgICA8Rm9vPlxuICAgICAgICAgIC8vICAgICAgIDxCYXIgLz5cbiAgICAgICAgICAvLyAgICAgPC9Gb28+XG4gICAgICAgICAgLy8gICApXG5cblxuICAgICAgICAgIGNvbnN0IGhhc0pTWCA9IGlzSlNYTm9kZSQxKG4ucmlnaHQpO1xuICAgICAgICAgIGNvbnN0IHJlc3QgPSBjb25jYXQkZChoYXNKU1ggPyBwYXJ0cy5zbGljZSgxLCAtMSkgOiBwYXJ0cy5zbGljZSgxKSk7XG4gICAgICAgICAgY29uc3QgZ3JvdXBJZCA9IFN5bWJvbChcImxvZ2ljYWxDaGFpbi1cIiArICsrdWlkKTtcbiAgICAgICAgICBjb25zdCBjaGFpbiA9IGdyb3VwJGIoY29uY2F0JGQoWy8vIERvbid0IGluY2x1ZGUgdGhlIGluaXRpYWwgZXhwcmVzc2lvbiBpbiB0aGUgaW5kZW50YXRpb25cbiAgICAgICAgICAvLyBsZXZlbC4gVGhlIGZpcnN0IGl0ZW0gaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgZmlyc3RcbiAgICAgICAgICAvLyBsZWZ0LW1vc3QgZXhwcmVzc2lvbi5cbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiBcIlwiLCBpbmRlbnQkNyhyZXN0KV0pLCB7XG4gICAgICAgICAgICBpZDogZ3JvdXBJZFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFoYXNKU1gpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBqc3hQYXJ0ID0gZ2V0TGFzdCQzKHBhcnRzKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbY2hhaW4sIGlmQnJlYWskNihpbmRlbnQkNyhqc3hQYXJ0KSwganN4UGFydCwge1xuICAgICAgICAgICAgZ3JvdXBJZFxuICAgICAgICAgIH0pXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJsZWZ0XCIpLCBcIiA9IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwicmlnaHRcIildKTtcblxuICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkQnJlYWtBZnRlckNhc3QgPSAhKG4uZXhwcmVzc2lvbi50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIik7XG4gICAgICAgICAgY29uc3QgY2FzdEdyb3VwID0gZ3JvdXAkYihjb25jYXQkZChbXCI8XCIsIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIildKSksIHNvZnRsaW5lJDYsIFwiPlwiXSkpO1xuICAgICAgICAgIGNvbnN0IGV4cHJDb250ZW50cyA9IGNvbmNhdCRkKFtpZkJyZWFrJDYoXCIoXCIpLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIildKSksIHNvZnRsaW5lJDYsIGlmQnJlYWskNihcIilcIildKTtcblxuICAgICAgICAgIGlmIChzaG91bGRCcmVha0FmdGVyQ2FzdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvbmFsR3JvdXAkMShbY29uY2F0JGQoW2Nhc3RHcm91cCwgcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIildKSwgY29uY2F0JGQoW2Nhc3RHcm91cCwgZ3JvdXAkYihleHByQ29udGVudHMsIHtcbiAgICAgICAgICAgICAgc2hvdWxkQnJlYWs6IHRydWVcbiAgICAgICAgICAgIH0pXSksIGNvbmNhdCRkKFtjYXN0R3JvdXAsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpXSldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbY2FzdEdyb3VwLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKV0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICAgICAgbGV0IGZpcnN0Tm9uTWVtYmVyUGFyZW50O1xuICAgICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGZpcnN0Tm9uTWVtYmVyUGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKGkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH0gd2hpbGUgKGZpcnN0Tm9uTWVtYmVyUGFyZW50ICYmIChmaXJzdE5vbk1lbWJlclBhcmVudC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBmaXJzdE5vbk1lbWJlclBhcmVudC50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiIHx8IGZpcnN0Tm9uTWVtYmVyUGFyZW50LnR5cGUgPT09IFwiVFNOb25OdWxsRXhwcmVzc2lvblwiKSk7XG5cbiAgICAgICAgICBjb25zdCBzaG91bGRJbmxpbmUgPSBmaXJzdE5vbk1lbWJlclBhcmVudCAmJiAoZmlyc3ROb25NZW1iZXJQYXJlbnQudHlwZSA9PT0gXCJOZXdFeHByZXNzaW9uXCIgfHwgZmlyc3ROb25NZW1iZXJQYXJlbnQudHlwZSA9PT0gXCJCaW5kRXhwcmVzc2lvblwiIHx8IGZpcnN0Tm9uTWVtYmVyUGFyZW50LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIgJiYgZmlyc3ROb25NZW1iZXJQYXJlbnQuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgfHwgZmlyc3ROb25NZW1iZXJQYXJlbnQudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiICYmIGZpcnN0Tm9uTWVtYmVyUGFyZW50LmxlZnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHx8IG4uY29tcHV0ZWQgfHwgbi5vYmplY3QudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbi5wcm9wZXJ0eS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwib2JqZWN0XCIpLCBzaG91bGRJbmxpbmUgPyBwcmludE1lbWJlckxvb2t1cChwYXRoLCBvcHRpb25zLCBwcmludCkgOiBncm91cCRiKGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwcmludE1lbWJlckxvb2t1cChwYXRoLCBvcHRpb25zLCBwcmludCldKSkpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIk1ldGFQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJtZXRhXCIpLCBcIi5cIiwgcGF0aC5jYWxsKHByaW50LCBcInByb3BlcnR5XCIpXSk7XG5cbiAgICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAobi5vYmplY3QpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJvYmplY3RcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChncm91cCRiKGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwcmludEJpbmRFeHByZXNzaW9uQ2FsbGVlKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pKSkpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtuLm5hbWUsIHByaW50T3B0aW9uYWxUb2tlbihwYXRoKSwgcHJpbnRUeXBlQW5ub3RhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCldKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCIlXCIsIG4ubmFtZV0pO1xuXG4gICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiU3ByZWFkUHJvcGVydHlcIjpcbiAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgY2FzZSBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiLi4uXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSwgcHJpbnRUeXBlQW5ub3RhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCldKTtcblxuICAgICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgcGFydHMucHVzaChwcmludEZ1bmN0aW9uRGVjbGFyYXRpb24ocGF0aCwgcHJpbnQsIG9wdGlvbnMpKTtcblxuICAgICAgICBpZiAoIW4uYm9keSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChuLmFzeW5jKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiYXN5bmMgXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRQcmludFBhcmFtc1dpdGhvdXRQYXJlbnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInBhcmFtc1wiLCAwKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihjb25jYXQkZChbcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBwcmludCwgb3B0aW9ucyxcbiAgICAgICAgICAgIC8qIGV4cGFuZExhc3QgKi9cbiAgICAgICAgICAgIGFyZ3MgJiYgKGFyZ3MuZXhwYW5kTGFzdEFyZyB8fCBhcmdzLmV4cGFuZEZpcnN0QXJnKSxcbiAgICAgICAgICAgIC8qIHByaW50VHlwZVBhcmFtcyAqL1xuICAgICAgICAgICAgdHJ1ZSksIHByaW50UmV0dXJuVHlwZShwYXRoLCBwcmludCwgb3B0aW9ucyldKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRhbmdsaW5nID0gY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgICAgIHRydWUsIGNvbW1lbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dENoYXJhY3RlciA9IGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleCQzKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBjb21tZW50LCBvcHRpb25zLmxvY0VuZCk7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2UobmV4dENoYXJhY3RlciwgbmV4dENoYXJhY3RlciArIDIpID09PSBcIj0+XCI7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZGFuZ2xpbmcpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIGRhbmdsaW5nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiID0+XCIpO1xuICAgICAgICAgIGNvbnN0IGJvZHkgPSBwYXRoLmNhbGwoYm9keVBhdGggPT4gcHJpbnQoYm9keVBhdGgsIGFyZ3MpLCBcImJvZHlcIik7IC8vIFdlIHdhbnQgdG8gYWx3YXlzIGtlZXAgdGhlc2UgdHlwZXMgb2Ygbm9kZXMgb24gdGhlIHNhbWUgbGluZVxuICAgICAgICAgIC8vIGFzIHRoZSBhcnJvdy5cblxuICAgICAgICAgIGlmICghaGFzTGVhZGluZ093bkxpbmVDb21tZW50JDEob3B0aW9ucy5vcmlnaW5hbFRleHQsIG4uYm9keSwgb3B0aW9ucykgJiYgKG4uYm9keS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiIHx8IG4uYm9keS50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIiB8fCBuLmJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiIHx8IGlzSlNYTm9kZSQxKG4uYm9keSkgfHwgaXNUZW1wbGF0ZU9uSXRzT3duTGluZSQxKG4uYm9keSwgb3B0aW9ucy5vcmlnaW5hbFRleHQsIG9wdGlvbnMpIHx8IG4uYm9keS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbi5ib2R5LnR5cGUgPT09IFwiRG9FeHByZXNzaW9uXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbY29uY2F0JGQocGFydHMpLCBcIiBcIiwgYm9keV0pKTtcbiAgICAgICAgICB9IC8vIFdlIGhhbmRsZSBzZXF1ZW5jZSBleHByZXNzaW9ucyBhcyB0aGUgYm9keSBvZiBhcnJvd3Mgc3BlY2lhbGx5LFxuICAgICAgICAgIC8vIHNvIHRoYXQgdGhlIHJlcXVpcmVkIHBhcmVudGhlc2VzIGVuZCB1cCBvbiB0aGVpciBvd24gbGluZXMuXG5cblxuICAgICAgICAgIGlmIChuLmJvZHkudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW2NvbmNhdCRkKHBhcnRzKSwgZ3JvdXAkYihjb25jYXQkZChbXCIgKFwiLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgYm9keV0pKSwgc29mdGxpbmUkNiwgXCIpXCJdKSldKSk7XG4gICAgICAgICAgfSAvLyBpZiB0aGUgYXJyb3cgZnVuY3Rpb24gaXMgZXhwYW5kZWQgYXMgbGFzdCBhcmd1bWVudCwgd2UgYXJlIGFkZGluZyBhXG4gICAgICAgICAgLy8gbGV2ZWwgb2YgaW5kZW50YXRpb24gYW5kIG5lZWQgdG8gYWRkIGEgc29mdGxpbmUgdG8gYWxpZ24gdGhlIGNsb3NpbmcgKVxuICAgICAgICAgIC8vIHdpdGggdGhlIG9wZW5pbmcgKCwgb3IgaWYgaXQncyBpbnNpZGUgYSBKU1hFeHByZXNzaW9uIChlLmcuIGFuIGF0dHJpYnV0ZSlcbiAgICAgICAgICAvLyB3ZSBzaG91bGQgYWxpZ24gdGhlIGV4cHJlc3Npb24ncyBjbG9zaW5nIH0gd2l0aCB0aGUgbGluZSB3aXRoIHRoZSBvcGVuaW5nIHsuXG5cblxuICAgICAgICAgIGNvbnN0IHNob3VsZEFkZFNvZnRMaW5lID0gKGFyZ3MgJiYgYXJncy5leHBhbmRMYXN0QXJnIHx8IHBhdGguZ2V0UGFyZW50Tm9kZSgpLnR5cGUgPT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiKSAmJiAhKG4uY29tbWVudHMgJiYgbi5jb21tZW50cy5sZW5ndGgpO1xuICAgICAgICAgIGNvbnN0IHByaW50VHJhaWxpbmdDb21tYSA9IGFyZ3MgJiYgYXJncy5leHBhbmRMYXN0QXJnICYmIHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zLCBcImFsbFwiKTsgLy8gSW4gb3JkZXIgdG8gYXZvaWQgY29uZnVzaW9uIGJldHdlZW5cbiAgICAgICAgICAvLyBhID0+IGEgPyBhIDogYVxuICAgICAgICAgIC8vIGEgPD0gYSA/IGEgOiBhXG5cbiAgICAgICAgICBjb25zdCBzaG91bGRBZGRQYXJlbnMgPSBuLmJvZHkudHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiAmJiAhc3RhcnRzV2l0aE5vTG9va2FoZWFkVG9rZW4kMShuLmJvZHksXG4gICAgICAgICAgLyogZm9yYmlkRnVuY3Rpb25BbmRDbGFzcyAqL1xuICAgICAgICAgIGZhbHNlKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbY29uY2F0JGQocGFydHMpLCBncm91cCRiKGNvbmNhdCRkKFtpbmRlbnQkNyhjb25jYXQkZChbbGluZSQ5LCBzaG91bGRBZGRQYXJlbnMgPyBpZkJyZWFrJDYoXCJcIiwgXCIoXCIpIDogXCJcIiwgYm9keSwgc2hvdWxkQWRkUGFyZW5zID8gaWZCcmVhayQ2KFwiXCIsIFwiKVwiKSA6IFwiXCJdKSksIHNob3VsZEFkZFNvZnRMaW5lID8gY29uY2F0JGQoW2lmQnJlYWskNihwcmludFRyYWlsaW5nQ29tbWEgPyBcIixcIiA6IFwiXCIpLCBzb2Z0bGluZSQ2XSkgOiBcIlwiXSkpXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJZaWVsZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcGFydHMucHVzaChcInlpZWxkXCIpO1xuXG4gICAgICAgIGlmIChuLmRlbGVnYXRlKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIipcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5hcmd1bWVudCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiQXdhaXRFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiYXdhaXQgXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSk7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICAgICAgICBpZiAoKHBhcmVudC50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSAmJiBwYXJlbnQuY2FsbGVlID09PSBuIHx8IChwYXJlbnQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpICYmIHBhcmVudC5vYmplY3QgPT09IG4pIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgY29uY2F0JGQocGFydHMpXSkpLCBzb2Z0bGluZSQ2XSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkltcG9ydFNwZWNpZmllclwiOlxuICAgICAgICBpZiAobi5pbXBvcnRLaW5kKSB7XG4gICAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiaW1wb3J0S2luZFwiKSwgXCIgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiaW1wb3J0ZWRcIikpO1xuXG4gICAgICAgIGlmIChuLmxvY2FsICYmIG4ubG9jYWwubmFtZSAhPT0gbi5pbXBvcnRlZC5uYW1lKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIiBhcyBcIiwgcGF0aC5jYWxsKHByaW50LCBcImxvY2FsXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJFeHBvcnRTcGVjaWZpZXJcIjpcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwibG9jYWxcIikpO1xuXG4gICAgICAgIGlmIChuLmV4cG9ydGVkICYmIG4uZXhwb3J0ZWQubmFtZSAhPT0gbi5sb2NhbC5uYW1lKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIiBhcyBcIiwgcGF0aC5jYWxsKHByaW50LCBcImV4cG9ydGVkXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIjpcbiAgICAgICAgcGFydHMucHVzaChcIiogYXMgXCIpO1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJsb2NhbFwiKSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwibG9jYWxcIik7XG5cbiAgICAgIGNhc2UgXCJUU0V4cG9ydEFzc2lnbm1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcImV4cG9ydCA9IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSwgc2VtaV0pO1xuXG4gICAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiOlxuICAgICAgICByZXR1cm4gcHJpbnRFeHBvcnREZWNsYXJhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCk7XG5cbiAgICAgIGNhc2UgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgICAgICBwYXJ0cy5wdXNoKFwiZXhwb3J0IFwiKTtcblxuICAgICAgICBpZiAobi5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJ0eXBlIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2goXCIqIFwiKTtcblxuICAgICAgICBpZiAobi5leHBvcnRlZCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJhcyBcIiwgcGF0aC5jYWxsKHByaW50LCBcImV4cG9ydGVkXCIpLCBcIiBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKFwiZnJvbSBcIiwgcGF0aC5jYWxsKHByaW50LCBcInNvdXJjZVwiKSwgc2VtaSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIjpcbiAgICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwiZXhwb3J0ZWRcIik7XG5cbiAgICAgIGNhc2UgXCJJbXBvcnREZWNsYXJhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgcGFydHMucHVzaChcImltcG9ydCBcIik7XG5cbiAgICAgICAgICBpZiAobi5pbXBvcnRLaW5kICYmIG4uaW1wb3J0S2luZCAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG4uaW1wb3J0S2luZCArIFwiIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBzdGFuZGFsb25lcyA9IFtdO1xuICAgICAgICAgIGNvbnN0IGdyb3VwZWQgPSBbXTtcblxuICAgICAgICAgIGlmIChuLnNwZWNpZmllcnMgJiYgbi5zcGVjaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhdGguZWFjaChzcGVjaWZpZXJQYXRoID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzcGVjaWZpZXJQYXRoLmdldFZhbHVlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiIHx8IHZhbHVlLnR5cGUgPT09IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFsb25lcy5wdXNoKHByaW50KHNwZWNpZmllclBhdGgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cGVkLnB1c2gocHJpbnQoc3BlY2lmaWVyUGF0aCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBcInNwZWNpZmllcnNcIik7XG5cbiAgICAgICAgICAgIGlmIChzdGFuZGFsb25lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goam9pbiQ5KFwiLCBcIiwgc3RhbmRhbG9uZXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YW5kYWxvbmVzLmxlbmd0aCA+IDAgJiYgZ3JvdXBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goXCIsIFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdyb3VwZWQubGVuZ3RoID09PSAxICYmIHN0YW5kYWxvbmVzLmxlbmd0aCA9PT0gMCAmJiBuLnNwZWNpZmllcnMgJiYgIW4uc3BlY2lmaWVycy5zb21lKG5vZGUgPT4gbm9kZS5jb21tZW50cykpIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChjb25jYXQkZChbXCJ7XCIsIG9wdGlvbnMuYnJhY2tldFNwYWNpbmcgPyBcIiBcIiA6IFwiXCIsIGNvbmNhdCRkKGdyb3VwZWQpLCBvcHRpb25zLmJyYWNrZXRTcGFjaW5nID8gXCIgXCIgOiBcIlwiLCBcIn1cIl0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JvdXBlZC5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBpbmRlbnQkNyhjb25jYXQkZChbb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IGxpbmUkOSA6IHNvZnRsaW5lJDYsIGpvaW4kOShjb25jYXQkZChbXCIsXCIsIGxpbmUkOV0pLCBncm91cGVkKV0pKSwgaWZCcmVhayQ2KHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zKSA/IFwiLFwiIDogXCJcIiksIG9wdGlvbnMuYnJhY2tldFNwYWNpbmcgPyBsaW5lJDkgOiBzb2Z0bGluZSQ2LCBcIn1cIl0pKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgZnJvbSBcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChuLmltcG9ydEtpbmQgJiYgbi5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCAvLyBpbXBvcnQge30gZnJvbSAneCdcbiAgICAgICAgICAve1xccyp9Ly50ZXN0KG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG9wdGlvbnMubG9jU3RhcnQobiksIG9wdGlvbnMubG9jU3RhcnQobi5zb3VyY2UpKSkpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJ7fSBmcm9tIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJzb3VyY2VcIiksIHNlbWkpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkltcG9ydFwiOlxuICAgICAgICByZXR1cm4gXCJpbXBvcnRcIjtcblxuICAgICAgY2FzZSBcIlRTTW9kdWxlQmxvY2tcIjpcbiAgICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbmFrZWQgPSBwYXRoLmNhbGwoYm9keVBhdGggPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50U3RhdGVtZW50U2VxdWVuY2UoYm9keVBhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgICB9LCBcImJvZHlcIik7XG4gICAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IG4uYm9keS5maW5kKG5vZGUgPT4gbm9kZS50eXBlICE9PSBcIkVtcHR5U3RhdGVtZW50XCIpO1xuICAgICAgICAgIGNvbnN0IGhhc0RpcmVjdGl2ZXMgPSBuLmRpcmVjdGl2ZXMgJiYgbi5kaXJlY3RpdmVzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICAgICAgY29uc3QgcGFyZW50UGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDEpO1xuXG4gICAgICAgICAgaWYgKCFoYXNDb250ZW50ICYmICFoYXNEaXJlY3RpdmVzICYmICFoYXNEYW5nbGluZ0NvbW1lbnRzJDEobikgJiYgKHBhcmVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IHBhcmVudC50eXBlID09PSBcIk9iamVjdE1ldGhvZFwiIHx8IHBhcmVudC50eXBlID09PSBcIkNsYXNzTWV0aG9kXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiRm9yU3RhdGVtZW50XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiV2hpbGVTdGF0ZW1lbnRcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJEb1doaWxlU3RhdGVtZW50XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiRG9FeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiQ2F0Y2hDbGF1c2VcIiAmJiAhcGFyZW50UGFyZW50LmZpbmFsaXplciB8fCBwYXJlbnQudHlwZSA9PT0gXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ7fVwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2goXCJ7XCIpOyAvLyBCYWJlbCA2XG5cbiAgICAgICAgICBpZiAoaGFzRGlyZWN0aXZlcykge1xuICAgICAgICAgICAgcGF0aC5lYWNoKGNoaWxkUGF0aCA9PiB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goaW5kZW50JDcoY29uY2F0JGQoW2hhcmRsaW5lJDksIHByaW50KGNoaWxkUGF0aCksIHNlbWldKSkpO1xuXG4gICAgICAgICAgICAgIGlmIChpc05leHRMaW5lRW1wdHkkNChvcHRpb25zLm9yaWdpbmFsVGV4dCwgY2hpbGRQYXRoLmdldFZhbHVlKCksIG9wdGlvbnMubG9jRW5kKSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFwiZGlyZWN0aXZlc1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgbmFrZWRdKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2goY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMpKTtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDksIFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcInJldHVyblwiLCBwcmludFJldHVybkFuZFRocm93QXJndW1lbnQocGF0aCwgb3B0aW9ucywgcHJpbnQpXSk7XG5cbiAgICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBpc05ldyA9IG4udHlwZSA9PT0gXCJOZXdFeHByZXNzaW9uXCI7XG4gICAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCk7XG5cbiAgICAgICAgICBpZiAoIC8vIFdlIHdhbnQgdG8ga2VlcCBDb21tb25KUy0gYW5kIEFNRC1zdHlsZSByZXF1aXJlIGNhbGxzLCBhbmQgQU1ELXN0eWxlXG4gICAgICAgICAgLy8gZGVmaW5lIGNhbGxzLCBhcyBhIHVuaXQuXG4gICAgICAgICAgLy8gZS5nLiBgZGVmaW5lKFtcInNvbWUvbGliXCIsIChsaWIpID0+IHtgXG4gICAgICAgICAgIWlzTmV3ICYmIG4uY2FsbGVlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChuLmNhbGxlZS5uYW1lID09PSBcInJlcXVpcmVcIiB8fCBuLmNhbGxlZS5uYW1lID09PSBcImRlZmluZVwiKSB8fCAvLyBUZW1wbGF0ZSBsaXRlcmFscyBhcyBzaW5nbGUgYXJndW1lbnRzXG4gICAgICAgICAgbi5hcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGlzVGVtcGxhdGVPbkl0c093bkxpbmUkMShuLmFyZ3VtZW50c1swXSwgb3B0aW9ucy5vcmlnaW5hbFRleHQsIG9wdGlvbnMpIHx8IC8vIEtlZXAgdGVzdCBkZWNsYXJhdGlvbnMgb24gYSBzaW5nbGUgbGluZVxuICAgICAgICAgIC8vIGUuZy4gYGl0KCdsb25nIG5hbWUnLCAoKSA9PiB7YFxuICAgICAgICAgICFpc05ldyAmJiBpc1Rlc3RDYWxsJDEobiwgcGF0aC5nZXRQYXJlbnROb2RlKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW2lzTmV3ID8gXCJuZXcgXCIgOiBcIlwiLCBwYXRoLmNhbGwocHJpbnQsIFwiY2FsbGVlXCIpLCBvcHRpb25hbCwgcHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgY29uY2F0JGQoW1wiKFwiLCBqb2luJDkoXCIsIFwiLCBwYXRoLm1hcChwcmludCwgXCJhcmd1bWVudHNcIikpLCBcIilcIl0pXSk7XG4gICAgICAgICAgfSAvLyBJbmxpbmUgRmxvdyBhbm5vdGF0aW9uIGNvbW1lbnRzIGZvbGxvd2luZyBJZGVudGlmaWVycyBpbiBDYWxsIG5vZGVzIG5lZWQgdG9cbiAgICAgICAgICAvLyBzdGF5IHdpdGggdGhlIElkZW50aWZpZXIuIEZvciBleGFtcGxlOlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gZm9vIC8qOjogPFNvbWVHZW5lcmljPiAqLyhiYXIpO1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSGVyZSwgd2UgZW5zdXJlIHRoYXQgc3VjaCBjb21tZW50cyBzdGF5IGJldHdlZW4gdGhlIElkZW50aWZpZXIgYW5kIHRoZSBDYWxsZWUuXG5cblxuICAgICAgICAgIGNvbnN0IGlzSWRlbnRpZmllcldpdGhGbG93QW5ub3RhdGlvbiA9IG4uY2FsbGVlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCQxKG4uY2FsbGVlLnRyYWlsaW5nQ29tbWVudHMpO1xuXG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllcldpdGhGbG93QW5ub3RhdGlvbikge1xuICAgICAgICAgICAgbi5jYWxsZWUudHJhaWxpbmdDb21tZW50c1swXS5wcmludGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IC8vIFdlIGRldGVjdCBjYWxscyBvbiBtZW1iZXIgbG9va3VwcyBhbmQgcG9zc2libHkgcHJpbnQgdGhlbSBpbiBhXG4gICAgICAgICAgLy8gc3BlY2lhbCBjaGFpbiBmb3JtYXQuIFNlZSBgcHJpbnRNZW1iZXJDaGFpbmAgZm9yIG1vcmUgaW5mby5cblxuXG4gICAgICAgICAgaWYgKCFpc05ldyAmJiBpc01lbWJlcmlzaCQxKG4uY2FsbGVlKSAmJiAhcGF0aC5jYWxsKHBhdGggPT4gbmVlZHNQYXJlbnNfMShwYXRoLCBvcHRpb25zKSwgXCJjYWxsZWVcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludE1lbWJlckNoYWluKHBhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjb250ZW50cyA9IGNvbmNhdCRkKFtpc05ldyA/IFwibmV3IFwiIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcImNhbGxlZVwiKSwgb3B0aW9uYWwsIGlzSWRlbnRpZmllcldpdGhGbG93QW5ub3RhdGlvbiA/IFwiLyo6OiBcIi5jb25jYXQobi5jYWxsZWUudHJhaWxpbmdDb21tZW50c1swXS52YWx1ZS5zbGljZSgyKS50cmltKCksIFwiICovXCIpIDogXCJcIiwgcHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgcHJpbnRBcmd1bWVudHNMaXN0KHBhdGgsIG9wdGlvbnMsIHByaW50KV0pOyAvLyBXZSBncm91cCBoZXJlIHdoZW4gdGhlIGNhbGxlZSBpcyBpdHNlbGYgYSBjYWxsIGV4cHJlc3Npb24uXG4gICAgICAgICAgLy8gU2VlIGBpc0xvbmdDdXJyaWVkQ2FsbEV4cHJlc3Npb25gIGZvciBtb3JlIGluZm8uXG5cbiAgICAgICAgICBpZiAoaXNDYWxsT3JPcHRpb25hbENhbGxFeHByZXNzaW9uJDEobi5jYWxsZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb250ZW50cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCI6XG4gICAgICAgIGlmIChuLmRlY2xhcmUpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKG4uYWJzdHJhY3QgPyBcImFic3RyYWN0IFwiIDogXCJcIiwgcHJpbnRUeXBlU2NyaXB0TW9kaWZpZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgXCJpbnRlcmZhY2UgXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgbi50eXBlUGFyYW1ldGVycyA/IHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSA6IFwiXCIsIFwiIFwiKTtcblxuICAgICAgICBpZiAobi5leHRlbmRzICYmIG4uZXh0ZW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIFwiZXh0ZW5kcyBcIiwgKG4uZXh0ZW5kcy5sZW5ndGggPT09IDEgPyBpZGVudGl0eSQyIDogaW5kZW50JDcpKGpvaW4kOShjb25jYXQkZChbXCIsXCIsIGxpbmUkOV0pLCBwYXRoLm1hcChwcmludCwgXCJleHRlbmRzXCIpKSksIFwiIFwiXSkpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtuLnN0YXRpYyA/IFwic3RhdGljIFwiIDogXCJcIiwgXCJbW1wiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIFwiXV1cIiwgcHJpbnRPcHRpb25hbFRva2VuKHBhdGgpLCBuLm1ldGhvZCA/IFwiXCIgOiBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKV0pO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgY2FzZSBcIlRTSW50ZXJmYWNlQm9keVwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUxpdGVyYWxcIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCBwcm9wZXJ0aWVzRmllbGQ7XG5cbiAgICAgICAgICBpZiAobi50eXBlID09PSBcIlRTVHlwZUxpdGVyYWxcIikge1xuICAgICAgICAgICAgcHJvcGVydGllc0ZpZWxkID0gXCJtZW1iZXJzXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuLnR5cGUgPT09IFwiVFNJbnRlcmZhY2VCb2R5XCIpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXNGaWVsZCA9IFwiYm9keVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzRmllbGQgPSBcInByb3BlcnRpZXNcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBpc1R5cGVBbm5vdGF0aW9uID0gbi50eXBlID09PSBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCI7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gW107XG5cbiAgICAgICAgICBpZiAoaXNUeXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgZmllbGRzLnB1c2goXCJpbmRleGVyc1wiLCBcImNhbGxQcm9wZXJ0aWVzXCIsIFwiaW50ZXJuYWxTbG90c1wiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWVsZHMucHVzaChwcm9wZXJ0aWVzRmllbGQpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0UHJvcGVydHkgPSBmaWVsZHMubWFwKGZpZWxkID0+IG5bZmllbGRdWzBdKS5zb3J0KChhLCBiKSA9PiBvcHRpb25zLmxvY1N0YXJ0KGEpIC0gb3B0aW9ucy5sb2NTdGFydChiKSlbMF07XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDApO1xuICAgICAgICAgIGNvbnN0IGlzRmxvd0ludGVyZmFjZUxpa2VCb2R5ID0gaXNUeXBlQW5ub3RhdGlvbiAmJiBwYXJlbnQgJiYgKHBhcmVudC50eXBlID09PSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiRGVjbGFyZUludGVyZmFjZVwiIHx8IHBhcmVudC50eXBlID09PSBcIkRlY2xhcmVDbGFzc1wiKSAmJiBwYXRoLmdldE5hbWUoKSA9PT0gXCJib2R5XCI7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkQnJlYWsgPSBuLnR5cGUgPT09IFwiVFNJbnRlcmZhY2VCb2R5XCIgfHwgaXNGbG93SW50ZXJmYWNlTGlrZUJvZHkgfHwgbi50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJPYmplY3RNZXRob2RcIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJDbGFzc01ldGhvZFwiICYmIHBhcmVudC50eXBlICE9PSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiICYmIHBhcmVudC50eXBlICE9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiQ2F0Y2hDbGF1c2VcIiAmJiBuLnByb3BlcnRpZXMuc29tZShwcm9wZXJ0eSA9PiBwcm9wZXJ0eS52YWx1ZSAmJiAocHJvcGVydHkudmFsdWUudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIgfHwgcHJvcGVydHkudmFsdWUudHlwZSA9PT0gXCJBcnJheVBhdHRlcm5cIikpIHx8IG4udHlwZSAhPT0gXCJPYmplY3RQYXR0ZXJuXCIgJiYgZmlyc3RQcm9wZXJ0eSAmJiBoYXNOZXdsaW5lSW5SYW5nZSQzKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY1N0YXJ0KG4pLCBvcHRpb25zLmxvY1N0YXJ0KGZpcnN0UHJvcGVydHkpKTtcbiAgICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBpc0Zsb3dJbnRlcmZhY2VMaWtlQm9keSA/IFwiO1wiIDogbi50eXBlID09PSBcIlRTSW50ZXJmYWNlQm9keVwiIHx8IG4udHlwZSA9PT0gXCJUU1R5cGVMaXRlcmFsXCIgPyBpZkJyZWFrJDYoc2VtaSwgXCI7XCIpIDogXCIsXCI7XG4gICAgICAgICAgY29uc3QgbGVmdEJyYWNlID0gbi5leGFjdCA/IFwie3xcIiA6IFwie1wiO1xuICAgICAgICAgIGNvbnN0IHJpZ2h0QnJhY2UgPSBuLmV4YWN0ID8gXCJ8fVwiIDogXCJ9XCI7IC8vIFVuZm9ydHVuYXRlbHksIHRoaW5ncyBhcmUgZ3JvdXBlZCB0b2dldGhlciBpbiB0aGUgYXN0IGNhbiBiZVxuICAgICAgICAgIC8vIGludGVybGVhdmVkIGluIHRoZSBzb3VyY2UgY29kZS4gU28gd2UgbmVlZCB0byByZW9yZGVyIHRoZW0gYmVmb3JlXG4gICAgICAgICAgLy8gcHJpbnRpbmcgdGhlbS5cblxuICAgICAgICAgIGNvbnN0IHByb3BzQW5kTG9jID0gW107XG4gICAgICAgICAgZmllbGRzLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgcGF0aC5lYWNoKGNoaWxkUGF0aCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZFBhdGguZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgcHJvcHNBbmRMb2MucHVzaCh7XG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBwcmludGVkOiBwcmludChjaGlsZFBhdGgpLFxuICAgICAgICAgICAgICAgIGxvYzogb3B0aW9ucy5sb2NTdGFydChub2RlKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZpZWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgc2VwYXJhdG9yUGFydHMgPSBbXTtcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHByb3BzQW5kTG9jLnNvcnQoKGEsIGIpID0+IGEubG9jIC0gYi5sb2MpLm1hcChwcm9wID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbmNhdCRkKHNlcGFyYXRvclBhcnRzLmNvbmNhdChncm91cCRiKHByb3AucHJpbnRlZCkpKTtcbiAgICAgICAgICAgIHNlcGFyYXRvclBhcnRzID0gW3NlcGFyYXRvciwgbGluZSQ5XTtcblxuICAgICAgICAgICAgaWYgKChwcm9wLm5vZGUudHlwZSA9PT0gXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIgfHwgcHJvcC5ub2RlLnR5cGUgPT09IFwiVFNNZXRob2RTaWduYXR1cmVcIiB8fCBwcm9wLm5vZGUudHlwZSA9PT0gXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIpICYmIGhhc05vZGVJZ25vcmVDb21tZW50JDIocHJvcC5ub2RlKSkge1xuICAgICAgICAgICAgICBzZXBhcmF0b3JQYXJ0cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNOZXh0TGluZUVtcHR5JDQob3B0aW9ucy5vcmlnaW5hbFRleHQsIHByb3Aubm9kZSwgb3B0aW9ucy5sb2NFbmQpKSB7XG4gICAgICAgICAgICAgIHNlcGFyYXRvclBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobi5pbmV4YWN0KSB7XG4gICAgICAgICAgICBsZXQgcHJpbnRlZDtcblxuICAgICAgICAgICAgaWYgKGhhc0RhbmdsaW5nQ29tbWVudHMkMShuKSkge1xuICAgICAgICAgICAgICBjb25zdCBoYXNMaW5lQ29tbWVudHMgPSAhbi5jb21tZW50cy5ldmVyeShjb21tZW50cyQxLmlzQmxvY2tDb21tZW50KTtcbiAgICAgICAgICAgICAgY29uc3QgcHJpbnRlZERhbmdsaW5nQ29tbWVudHMgPSBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyxcbiAgICAgICAgICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgICAgICAgICB0cnVlKTtcbiAgICAgICAgICAgICAgcHJpbnRlZCA9IGNvbmNhdCRkKFtwcmludGVkRGFuZ2xpbmdDb21tZW50cywgaGFzTGluZUNvbW1lbnRzIHx8IGhhc05ld2xpbmUkNShvcHRpb25zLm9yaWdpbmFsVGV4dCwgb3B0aW9ucy5sb2NFbmQobi5jb21tZW50c1tuLmNvbW1lbnRzLmxlbmd0aCAtIDFdKSkgPyBoYXJkbGluZSQ5IDogbGluZSQ5LCBcIi4uLlwiXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcmludGVkID0gXCIuLi5cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcHMucHVzaChjb25jYXQkZChzZXBhcmF0b3JQYXJ0cy5jb25jYXQocHJpbnRlZCkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBsYXN0RWxlbSA9IGdldExhc3QkMyhuW3Byb3BlcnRpZXNGaWVsZF0pO1xuICAgICAgICAgIGNvbnN0IGNhbkhhdmVUcmFpbGluZ1NlcGFyYXRvciA9ICEobi5pbmV4YWN0IHx8IGxhc3RFbGVtICYmIChsYXN0RWxlbS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgfHwgaGFzTm9kZUlnbm9yZUNvbW1lbnQkMihsYXN0RWxlbSkpKTtcbiAgICAgICAgICBsZXQgY29udGVudDtcblxuICAgICAgICAgIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghaGFzRGFuZ2xpbmdDb21tZW50cyQxKG4pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjb25jYXQkZChbbGVmdEJyYWNlLCByaWdodEJyYWNlLCBwcmludFR5cGVBbm5vdGF0aW9uKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZW50ID0gZ3JvdXAkYihjb25jYXQkZChbbGVmdEJyYWNlLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyksIHNvZnRsaW5lJDYsIHJpZ2h0QnJhY2UsIHByaW50T3B0aW9uYWxUb2tlbihwYXRoKSwgcHJpbnRUeXBlQW5ub3RhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCldKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb25jYXQkZChbbGVmdEJyYWNlLCBpbmRlbnQkNyhjb25jYXQkZChbb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IGxpbmUkOSA6IHNvZnRsaW5lJDYsIGNvbmNhdCRkKHByb3BzKV0pKSwgaWZCcmVhayQ2KGNhbkhhdmVUcmFpbGluZ1NlcGFyYXRvciAmJiAoc2VwYXJhdG9yICE9PSBcIixcIiB8fCBzaG91bGRQcmludENvbW1hJDEob3B0aW9ucykpID8gc2VwYXJhdG9yIDogXCJcIiksIGNvbmNhdCRkKFtvcHRpb25zLmJyYWNrZXRTcGFjaW5nID8gbGluZSQ5IDogc29mdGxpbmUkNiwgcmlnaHRCcmFjZV0pLCBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCksIHByaW50VHlwZUFubm90YXRpb24ocGF0aCwgb3B0aW9ucywgcHJpbnQpXSk7XG4gICAgICAgICAgfSAvLyBJZiB3ZSBpbmxpbmUgdGhlIG9iamVjdCBhcyBmaXJzdCBhcmd1bWVudCBvZiB0aGUgcGFyZW50LCB3ZSBkb24ndCB3YW50XG4gICAgICAgICAgLy8gdG8gY3JlYXRlIGFub3RoZXIgZ3JvdXAgc28gdGhhdCB0aGUgb2JqZWN0IGJyZWFrcyBiZWZvcmUgdGhlIHJldHVyblxuICAgICAgICAgIC8vIHR5cGVcblxuXG4gICAgICAgICAgaWYgKHBhdGgubWF0Y2gobm9kZSA9PiBub2RlLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiICYmICFub2RlLmRlY29yYXRvcnMsIChub2RlLCBuYW1lLCBudW1iZXIpID0+IHNob3VsZEh1Z0FyZ3VtZW50cyhub2RlKSAmJiAobmFtZSA9PT0gXCJwYXJhbXNcIiB8fCBuYW1lID09PSBcInBhcmFtZXRlcnNcIikgJiYgbnVtYmVyID09PSAwKSB8fCBwYXRoLm1hdGNoKHNob3VsZEh1Z1R5cGUsIChub2RlLCBuYW1lKSA9PiBuYW1lID09PSBcInR5cGVBbm5vdGF0aW9uXCIsIChub2RlLCBuYW1lKSA9PiBuYW1lID09PSBcInR5cGVBbm5vdGF0aW9uXCIsIChub2RlLCBuYW1lLCBudW1iZXIpID0+IHNob3VsZEh1Z0FyZ3VtZW50cyhub2RlKSAmJiAobmFtZSA9PT0gXCJwYXJhbXNcIiB8fCBuYW1lID09PSBcInBhcmFtZXRlcnNcIikgJiYgbnVtYmVyID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29udGVudCwge1xuICAgICAgICAgICAgc2hvdWxkQnJlYWtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgLy8gQmFiZWwgNlxuXG4gICAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjogLy8gTm9uLXN0YW5kYXJkIEFTVCBub2RlIHR5cGUuXG5cbiAgICAgIGNhc2UgXCJQcm9wZXJ0eVwiOlxuICAgICAgICBpZiAobi5tZXRob2QgfHwgbi5raW5kID09PSBcImdldFwiIHx8IG4ua2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgICAgIHJldHVybiBwcmludE1ldGhvZChwYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5zaG9ydGhhbmQpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMucHVzaChwcmludEFzc2lnbm1lbnQobi5rZXksIHByaW50UHJvcGVydHlLZXkocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBcIjpcIiwgbi52YWx1ZSwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpLCBvcHRpb25zKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgICAgLy8gQmFiZWwgNlxuXG4gICAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICAgIGNhc2UgXCJNZXRob2REZWZpbml0aW9uXCI6XG4gICAgICBjYXNlIFwiVFNBYnN0cmFjdE1ldGhvZERlZmluaXRpb25cIjpcbiAgICAgIGNhc2UgXCJUU0RlY2xhcmVNZXRob2RcIjpcbiAgICAgICAgaWYgKG4uZGVjb3JhdG9ycyAmJiBuLmRlY29yYXRvcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgcGFydHMucHVzaChwcmludERlY29yYXRvcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKG4uYWNjZXNzaWJpbGl0eSArIFwiIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLnN0YXRpYykge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJzdGF0aWMgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4udHlwZSA9PT0gXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiIHx8IG4uYWJzdHJhY3QpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiYWJzdHJhY3QgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChwcmludE1ldGhvZChwYXRoLCBvcHRpb25zLCBwcmludCkpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgICAgIHJldHVybiBwcmludE1ldGhvZChwYXRoLCBvcHRpb25zLCBwcmludCk7XG5cbiAgICAgIGNhc2UgXCJEZWNvcmF0b3JcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIkBcIiwgcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIiksIHBhdGguY2FsbChwcmludCwgXCJjYWxsZWVcIildKTtcblxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgICBpZiAobi5lbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAoIWhhc0RhbmdsaW5nQ29tbWVudHMkMShuKSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIltdXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wiW1wiLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyksIHNvZnRsaW5lJDYsIFwiXVwiXSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGFzdEVsZW0gPSBnZXRMYXN0JDMobi5lbGVtZW50cyk7XG4gICAgICAgICAgY29uc3QgY2FuSGF2ZVRyYWlsaW5nQ29tbWEgPSAhKGxhc3RFbGVtICYmIGxhc3RFbGVtLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIik7IC8vIEphdmFTY3JpcHQgYWxsb3dzIHlvdSB0byBoYXZlIGVtcHR5IGVsZW1lbnRzIGluIGFuIGFycmF5IHdoaWNoXG4gICAgICAgICAgLy8gY2hhbmdlcyBpdHMgbGVuZ3RoIGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgY29tbWFzLiBUaGUgYWxnb3JpdGhtXG4gICAgICAgICAgLy8gaXMgdGhhdCBpZiB0aGUgbGFzdCBhcmd1bWVudCBpcyBudWxsLCB3ZSBuZWVkIHRvIGZvcmNlIGluc2VydFxuICAgICAgICAgIC8vIGEgY29tbWEgdG8gZW5zdXJlIEphdmFTY3JpcHQgcmVjb2duaXplcyBpdC5cbiAgICAgICAgICAvLyAgIFssXS5sZW5ndGggPT09IDFcbiAgICAgICAgICAvLyAgIFsxLF0ubGVuZ3RoID09PSAxXG4gICAgICAgICAgLy8gICBbMSwsXS5sZW5ndGggPT09IDJcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIE5vdGUgdGhhdCBnZXRMYXN0IHJldHVybnMgbnVsbCBpZiB0aGUgYXJyYXkgaXMgZW1wdHksIGJ1dFxuICAgICAgICAgIC8vIHdlIGFscmVhZHkgY2hlY2sgZm9yIGFuIGVtcHR5IGFycmF5IGp1c3QgYWJvdmUgc28gd2UgYXJlIHNhZmVcblxuICAgICAgICAgIGNvbnN0IG5lZWRzRm9yY2VkVHJhaWxpbmdDb21tYSA9IGNhbkhhdmVUcmFpbGluZ0NvbW1hICYmIGxhc3RFbGVtID09PSBudWxsO1xuICAgICAgICAgIGNvbnN0IHNob3VsZEJyZWFrID0gbi5lbGVtZW50cy5sZW5ndGggPiAxICYmIG4uZWxlbWVudHMuZXZlcnkoKGVsZW1lbnQsIGksIGVsZW1lbnRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IGVsZW1lbnQgJiYgZWxlbWVudC50eXBlO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudFR5cGUgIT09IFwiQXJyYXlFeHByZXNzaW9uXCIgJiYgZWxlbWVudFR5cGUgIT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbmV4dEVsZW1lbnQgPSBlbGVtZW50c1tpICsgMV07XG5cbiAgICAgICAgICAgIGlmIChuZXh0RWxlbWVudCAmJiBlbGVtZW50VHlwZSAhPT0gbmV4dEVsZW1lbnQudHlwZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zS2V5ID0gZWxlbWVudFR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIgPyBcImVsZW1lbnRzXCIgOiBcInByb3BlcnRpZXNcIjtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50W2l0ZW1zS2V5XSAmJiBlbGVtZW50W2l0ZW1zS2V5XS5sZW5ndGggPiAxO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihjb25jYXQkZChbXCJbXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwcmludEFycmF5SXRlbXMocGF0aCwgb3B0aW9ucywgXCJlbGVtZW50c1wiLCBwcmludCldKSksIG5lZWRzRm9yY2VkVHJhaWxpbmdDb21tYSA/IFwiLFwiIDogXCJcIiwgaWZCcmVhayQ2KGNhbkhhdmVUcmFpbGluZ0NvbW1hICYmICFuZWVkc0ZvcmNlZFRyYWlsaW5nQ29tbWEgJiYgc2hvdWxkUHJpbnRDb21tYSQxKG9wdGlvbnMpID8gXCIsXCIgOiBcIlwiKSwgY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgICAgIHRydWUpLCBzb2Z0bGluZSQ2LCBcIl1cIl0pLCB7XG4gICAgICAgICAgICBzaG91bGRCcmVha1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gocHJpbnRPcHRpb25hbFRva2VuKHBhdGgpLCBwcmludFR5cGVBbm5vdGF0aW9uKHBhdGgsIG9wdGlvbnMsIHByaW50KSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgwKTtcblxuICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgfHwgcGFyZW50LnR5cGUgPT09IFwiRm9yU3RhdGVtZW50XCIpIHtcbiAgICAgICAgICAgIC8vIEZvciBFeHByZXNzaW9uU3RhdGVtZW50cyBhbmQgZm9yLWxvb3AgaGVhZHMsIHdoaWNoIGFyZSBhbW9uZ1xuICAgICAgICAgICAgLy8gdGhlIGZldyBwbGFjZXMgYSBTZXF1ZW5jZUV4cHJlc3Npb24gYXBwZWFycyB1bnBhcmVudGhlc2l6ZWQsIHdlIHdhbnRcbiAgICAgICAgICAgIC8vIHRvIGluZGVudCBleHByZXNzaW9ucyBhZnRlciB0aGUgZmlyc3QuXG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICAgICAgcGF0aC5lYWNoKHAgPT4ge1xuICAgICAgICAgICAgICBpZiAocC5nZXROYW1lKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHByaW50KHApKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiLFwiLCBpbmRlbnQkNyhjb25jYXQkZChbbGluZSQ5LCBwcmludChwKV0pKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFwiZXhwcmVzc2lvbnNcIik7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChwYXJ0cykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtqb2luJDkoY29uY2F0JGQoW1wiLFwiLCBsaW5lJDldKSwgcGF0aC5tYXAocHJpbnQsIFwiZXhwcmVzc2lvbnNcIikpXSkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUaGlzRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gXCJ0aGlzXCI7XG5cbiAgICAgIGNhc2UgXCJTdXBlclwiOlxuICAgICAgICByZXR1cm4gXCJzdXBlclwiO1xuXG4gICAgICBjYXNlIFwiTnVsbExpdGVyYWxcIjpcbiAgICAgICAgLy8gQmFiZWwgNiBMaXRlcmFsIHNwbGl0XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcblxuICAgICAgY2FzZSBcIlJlZ0V4cExpdGVyYWxcIjpcbiAgICAgICAgLy8gQmFiZWwgNiBMaXRlcmFsIHNwbGl0XG4gICAgICAgIHJldHVybiBwcmludFJlZ2V4KG4pO1xuXG4gICAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICAgICAgLy8gQmFiZWwgNiBMaXRlcmFsIHNwbGl0XG4gICAgICAgIHJldHVybiBwcmludE51bWJlciQyKG4uZXh0cmEucmF3KTtcblxuICAgICAgY2FzZSBcIkJpZ0ludExpdGVyYWxcIjpcbiAgICAgICAgLy8gYmFiZWw6IG4uZXh0cmEucmF3LCB0eXBlc2NyaXB0OiBuLnJhdywgZmxvdzogbi5iaWdpbnRcbiAgICAgICAgcmV0dXJuIChuLmJpZ2ludCB8fCAobi5leHRyYSA/IG4uZXh0cmEucmF3IDogbi5yYXcpKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxcIjogLy8gQmFiZWwgNiBMaXRlcmFsIHNwbGl0XG5cbiAgICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6IC8vIEJhYmVsIDYgTGl0ZXJhbCBzcGxpdFxuXG4gICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG4ucmVnZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludFJlZ2V4KG4ucmVnZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2Ygbi52YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50TnVtYmVyJDIobi5yYXcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2Ygbi52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBuLnZhbHVlO1xuICAgICAgICAgIH0gLy8gVHlwZVNjcmlwdCB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vSmFtZXNIZW5yeS90eXBlc2NyaXB0LWVzdHJlZS9pc3N1ZXMvMlxuICAgICAgICAgIC8vIFNlZSBjb3JyZXNwb25kaW5nIHdvcmthcm91bmQgaW4gbmVlZHMtcGFyZW5zLmpzXG5cblxuICAgICAgICAgIGNvbnN0IGdyYW5kUGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDEpO1xuICAgICAgICAgIGNvbnN0IGlzVHlwZVNjcmlwdERpcmVjdGl2ZSA9IG9wdGlvbnMucGFyc2VyID09PSBcInR5cGVzY3JpcHRcIiAmJiB0eXBlb2Ygbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBncmFuZFBhcmVudCAmJiAoZ3JhbmRQYXJlbnQudHlwZSA9PT0gXCJQcm9ncmFtXCIgfHwgZ3JhbmRQYXJlbnQudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgICAgICAgICByZXR1cm4gbm9kZVN0cihuLCBvcHRpb25zLCBpc1R5cGVTY3JpcHREaXJlY3RpdmUpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJEaXJlY3RpdmVcIjpcbiAgICAgICAgcmV0dXJuIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKTtcbiAgICAgIC8vIEJhYmVsIDZcblxuICAgICAgY2FzZSBcIkRpcmVjdGl2ZUxpdGVyYWxcIjpcbiAgICAgICAgcmV0dXJuIG5vZGVTdHIobiwgb3B0aW9ucyk7XG5cbiAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgcGFydHMucHVzaChuLm9wZXJhdG9yKTtcblxuICAgICAgICBpZiAoL1thLXpdJC8udGVzdChuLm9wZXJhdG9yKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uYXJndW1lbnQuY29tbWVudHMgJiYgbi5hcmd1bWVudC5jb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFydHMucHVzaChncm91cCRiKGNvbmNhdCRkKFtcIihcIiwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKV0pKSwgc29mdGxpbmUkNiwgXCIpXCJdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpLCBuLm9wZXJhdG9yKTtcblxuICAgICAgICBpZiAobi5wcmVmaXgpIHtcbiAgICAgICAgICBwYXJ0cy5yZXZlcnNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBwcmludFRlcm5hcnlPcGVyYXRvcihwYXRoLCBvcHRpb25zLCBwcmludCwge1xuICAgICAgICAgIGJlZm9yZVBhcnRzOiAoKSA9PiBbcGF0aC5jYWxsKHByaW50LCBcInRlc3RcIildLFxuICAgICAgICAgIGFmdGVyUGFydHM6IGJyZWFrQ2xvc2luZ1BhcmVuID0+IFticmVha0Nsb3NpbmdQYXJlbiA/IHNvZnRsaW5lJDYgOiBcIlwiXSxcbiAgICAgICAgICBzaG91bGRDaGVja0pzeDogdHJ1ZSxcbiAgICAgICAgICBjb25kaXRpb25hbE5vZGVUeXBlOiBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLFxuICAgICAgICAgIGNvbnNlcXVlbnROb2RlUHJvcGVydHlOYW1lOiBcImNvbnNlcXVlbnRcIixcbiAgICAgICAgICBhbHRlcm5hdGVOb2RlUHJvcGVydHlOYW1lOiBcImFsdGVybmF0ZVwiLFxuICAgICAgICAgIHRlc3ROb2RlUHJvcGVydHlOYW1lczogW1widGVzdFwiXVxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHByaW50ZWQgPSBwYXRoLm1hcChjaGlsZFBhdGggPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByaW50KGNoaWxkUGF0aCk7XG4gICAgICAgICAgfSwgXCJkZWNsYXJhdGlvbnNcIik7IC8vIFdlIGdlbmVyYWxseSB3YW50IHRvIHRlcm1pbmF0ZSBhbGwgdmFyaWFibGUgZGVjbGFyYXRpb25zIHdpdGggYVxuICAgICAgICAgIC8vIHNlbWljb2xvbiwgZXhjZXB0IHdoZW4gdGhleSBpbiB0aGUgKCkgcGFydCBvZiBmb3IgbG9vcHMuXG5cbiAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICAgICAgY29uc3QgaXNQYXJlbnRGb3JMb29wID0gcGFyZW50Tm9kZS50eXBlID09PSBcIkZvclN0YXRlbWVudFwiIHx8IHBhcmVudE5vZGUudHlwZSA9PT0gXCJGb3JJblN0YXRlbWVudFwiIHx8IHBhcmVudE5vZGUudHlwZSA9PT0gXCJGb3JPZlN0YXRlbWVudFwiO1xuICAgICAgICAgIGNvbnN0IGhhc1ZhbHVlID0gbi5kZWNsYXJhdGlvbnMuc29tZShkZWNsID0+IGRlY2wuaW5pdCk7XG4gICAgICAgICAgbGV0IGZpcnN0VmFyaWFibGU7XG5cbiAgICAgICAgICBpZiAocHJpbnRlZC5sZW5ndGggPT09IDEgJiYgIW4uZGVjbGFyYXRpb25zWzBdLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICBmaXJzdFZhcmlhYmxlID0gcHJpbnRlZFswXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByaW50ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gSW5kZW50IGZpcnN0IHZhciB0byBjb21wbHkgd2l0aCBlc2xpbnQgb25lLXZhciBydWxlXG4gICAgICAgICAgICBmaXJzdFZhcmlhYmxlID0gaW5kZW50JDcocHJpbnRlZFswXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMgPSBbbi5kZWNsYXJlID8gXCJkZWNsYXJlIFwiIDogXCJcIiwgbi5raW5kLCBmaXJzdFZhcmlhYmxlID8gY29uY2F0JGQoW1wiIFwiLCBmaXJzdFZhcmlhYmxlXSkgOiBcIlwiLCBpbmRlbnQkNyhjb25jYXQkZChwcmludGVkLnNsaWNlKDEpLm1hcChwID0+IGNvbmNhdCRkKFtcIixcIiwgaGFzVmFsdWUgJiYgIWlzUGFyZW50Rm9yTG9vcCA/IGhhcmRsaW5lJDkgOiBsaW5lJDksIHBdKSkpKV07XG5cbiAgICAgICAgICBpZiAoIShpc1BhcmVudEZvckxvb3AgJiYgcGFyZW50Tm9kZS5ib2R5ICE9PSBuKSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChzZW1pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChwYXJ0cykpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobi5kZWNsYXJlKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHJpbnRlZCA9IHByaW50QXNzaWdubWVudFJpZ2h0KG4uaWQsIG4udHlwZUFubm90YXRpb24sIG4udHlwZUFubm90YXRpb24gJiYgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpLCBvcHRpb25zKTtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwidHlwZSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIiksIFwiID1cIiwgcHJpbnRlZCwgc2VtaSk7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQocGFydHMpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6XG4gICAgICAgIHJldHVybiBwcmludEFzc2lnbm1lbnQobi5pZCwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBcIiA9XCIsIG4uaW5pdCwgbi5pbml0ICYmIHBhdGguY2FsbChwcmludCwgXCJpbml0XCIpLCBvcHRpb25zKTtcblxuICAgICAgY2FzZSBcIldpdGhTdGF0ZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wid2l0aCAoXCIsIHBhdGguY2FsbChwcmludCwgXCJvYmplY3RcIiksIFwiKVwiLCBhZGp1c3RDbGF1c2Uobi5ib2R5LCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSldKSk7XG5cbiAgICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgY29uID0gYWRqdXN0Q2xhdXNlKG4uY29uc2VxdWVudCwgcGF0aC5jYWxsKHByaW50LCBcImNvbnNlcXVlbnRcIikpO1xuICAgICAgICAgIGNvbnN0IG9wZW5pbmcgPSBncm91cCRiKGNvbmNhdCRkKFtcImlmIChcIiwgZ3JvdXAkYihjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJ0ZXN0XCIpXSkpLCBzb2Z0bGluZSQ2XSkpLCBcIilcIiwgY29uXSkpO1xuICAgICAgICAgIHBhcnRzLnB1c2gob3BlbmluZyk7XG5cbiAgICAgICAgICBpZiAobi5hbHRlcm5hdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRPbk93bkxpbmUgPSBoYXNUcmFpbGluZ0NvbW1lbnQkMShuLmNvbnNlcXVlbnQpICYmIG4uY29uc2VxdWVudC5jb21tZW50cy5zb21lKGNvbW1lbnQgPT4gY29tbWVudC50cmFpbGluZyAmJiAhY29tbWVudHMkMS5pc0Jsb2NrQ29tbWVudChjb21tZW50KSkgfHwgbmVlZHNIYXJkbGluZUFmdGVyRGFuZ2xpbmdDb21tZW50JDEobik7XG4gICAgICAgICAgICBjb25zdCBlbHNlT25TYW1lTGluZSA9IG4uY29uc2VxdWVudC50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgJiYgIWNvbW1lbnRPbk93bkxpbmU7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGVsc2VPblNhbWVMaW5lID8gXCIgXCIgOiBoYXJkbGluZSQ5KTtcblxuICAgICAgICAgICAgaWYgKGhhc0RhbmdsaW5nQ29tbWVudHMkMShuKSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLCB0cnVlKSwgY29tbWVudE9uT3duTGluZSA/IGhhcmRsaW5lJDkgOiBcIiBcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJlbHNlXCIsIGdyb3VwJGIoYWRqdXN0Q2xhdXNlKG4uYWx0ZXJuYXRlLCBwYXRoLmNhbGwocHJpbnQsIFwiYWx0ZXJuYXRlXCIpLCBuLmFsdGVybmF0ZS50eXBlID09PSBcIklmU3RhdGVtZW50XCIpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBib2R5ID0gYWRqdXN0Q2xhdXNlKG4uYm9keSwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpOyAvLyBXZSB3YW50IHRvIGtlZXAgZGFuZ2xpbmcgY29tbWVudHMgYWJvdmUgdGhlIGxvb3AgdG8gc3RheSBjb25zaXN0ZW50LlxuICAgICAgICAgIC8vIEFueSBjb21tZW50IHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgZm9yIHN0YXRlbWVudCBhbmQgdGhlIHBhcmVudGhlc2VzXG4gICAgICAgICAgLy8gaXMgZ29pbmcgdG8gYmUgcHJpbnRlZCBiZWZvcmUgdGhlIHN0YXRlbWVudC5cblxuICAgICAgICAgIGNvbnN0IGRhbmdsaW5nID0gY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAgICAgLyogc2FtZUxpbmUgKi9cbiAgICAgICAgICB0cnVlKTtcbiAgICAgICAgICBjb25zdCBwcmludGVkQ29tbWVudHMgPSBkYW5nbGluZyA/IGNvbmNhdCRkKFtkYW5nbGluZywgc29mdGxpbmUkNl0pIDogXCJcIjtcblxuICAgICAgICAgIGlmICghbi5pbml0ICYmICFuLnRlc3QgJiYgIW4udXBkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW3ByaW50ZWRDb21tZW50cywgZ3JvdXAkYihjb25jYXQkZChbXCJmb3IgKDs7KVwiLCBib2R5XSkpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwcmludGVkQ29tbWVudHMsIGdyb3VwJGIoY29uY2F0JGQoW1wiZm9yIChcIiwgZ3JvdXAkYihjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJpbml0XCIpLCBcIjtcIiwgbGluZSQ5LCBwYXRoLmNhbGwocHJpbnQsIFwidGVzdFwiKSwgXCI7XCIsIGxpbmUkOSwgcGF0aC5jYWxsKHByaW50LCBcInVwZGF0ZVwiKV0pKSwgc29mdGxpbmUkNl0pKSwgXCIpXCIsIGJvZHldKSldKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wid2hpbGUgKFwiLCBncm91cCRiKGNvbmNhdCRkKFtpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcInRlc3RcIildKSksIHNvZnRsaW5lJDZdKSksIFwiKVwiLCBhZGp1c3RDbGF1c2Uobi5ib2R5LCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSldKSk7XG5cbiAgICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOlxuICAgICAgICAvLyBOb3RlOiBlc3ByaW1hIGNhbid0IGFjdHVhbGx5IHBhcnNlIFwiZm9yIGVhY2ggKFwiLlxuICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbbi5lYWNoID8gXCJmb3IgZWFjaCAoXCIgOiBcImZvciAoXCIsIHBhdGguY2FsbChwcmludCwgXCJsZWZ0XCIpLCBcIiBpbiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInJpZ2h0XCIpLCBcIilcIiwgYWRqdXN0Q2xhdXNlKG4uYm9keSwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpXSkpO1xuXG4gICAgICBjYXNlIFwiRm9yT2ZTdGF0ZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wiZm9yXCIsIG4uYXdhaXQgPyBcIiBhd2FpdFwiIDogXCJcIiwgXCIgKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibGVmdFwiKSwgXCIgb2YgXCIsIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKSwgXCIpXCIsIGFkanVzdENsYXVzZShuLmJvZHksIHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKV0pKTtcblxuICAgICAgY2FzZSBcIkRvV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNsYXVzZSA9IGFkanVzdENsYXVzZShuLmJvZHksIHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICAgICAgICBjb25zdCBkb0JvZHkgPSBncm91cCRiKGNvbmNhdCRkKFtcImRvXCIsIGNsYXVzZV0pKTtcbiAgICAgICAgICBwYXJ0cyA9IFtkb0JvZHldO1xuXG4gICAgICAgICAgaWYgKG4uYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2goXCJ3aGlsZSAoXCIpO1xuICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJ0ZXN0XCIpXSkpLCBzb2Z0bGluZSQ2XSkpLCBcIilcIiwgc2VtaSk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRG9FeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJkbyBcIiwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIildKTtcblxuICAgICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgICAgIHBhcnRzLnB1c2goXCJicmVha1wiKTtcblxuICAgICAgICBpZiAobi5sYWJlbCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJsYWJlbFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKHNlbWkpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICAgICAgcGFydHMucHVzaChcImNvbnRpbnVlXCIpO1xuXG4gICAgICAgIGlmIChuLmxhYmVsKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImxhYmVsXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJMYWJlbGVkU3RhdGVtZW50XCI6XG4gICAgICAgIGlmIChuLmJvZHkudHlwZSA9PT0gXCJFbXB0eVN0YXRlbWVudFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwibGFiZWxcIiksIFwiOjtcIl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwibGFiZWxcIiksIFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIildKTtcblxuICAgICAgY2FzZSBcIlRyeVN0YXRlbWVudFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1widHJ5IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYmxvY2tcIiksIG4uaGFuZGxlciA/IGNvbmNhdCRkKFtcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImhhbmRsZXJcIildKSA6IFwiXCIsIG4uZmluYWxpemVyID8gY29uY2F0JGQoW1wiIGZpbmFsbHkgXCIsIHBhdGguY2FsbChwcmludCwgXCJmaW5hbGl6ZXJcIildKSA6IFwiXCJdKTtcblxuICAgICAgY2FzZSBcIkNhdGNoQ2xhdXNlXCI6XG4gICAgICAgIGlmIChuLnBhcmFtKSB7XG4gICAgICAgICAgY29uc3QgaGFzQ29tbWVudHMgPSBuLnBhcmFtLmNvbW1lbnRzICYmIG4ucGFyYW0uY29tbWVudHMuc29tZShjb21tZW50ID0+ICFjb21tZW50cyQxLmlzQmxvY2tDb21tZW50KGNvbW1lbnQpIHx8IGNvbW1lbnQubGVhZGluZyAmJiBoYXNOZXdsaW5lJDUob3B0aW9ucy5vcmlnaW5hbFRleHQsIG9wdGlvbnMubG9jRW5kKGNvbW1lbnQpKSB8fCBjb21tZW50LnRyYWlsaW5nICYmIGhhc05ld2xpbmUkNShvcHRpb25zLm9yaWdpbmFsVGV4dCwgb3B0aW9ucy5sb2NTdGFydChjb21tZW50KSwge1xuICAgICAgICAgICAgYmFja3dhcmRzOiB0cnVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGNvbnN0IHBhcmFtID0gcGF0aC5jYWxsKHByaW50LCBcInBhcmFtXCIpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbXCJjYXRjaCBcIiwgaGFzQ29tbWVudHMgPyBjb25jYXQkZChbXCIoXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwYXJhbV0pKSwgc29mdGxpbmUkNiwgXCIpIFwiXSkgOiBjb25jYXQkZChbXCIoXCIsIHBhcmFtLCBcIikgXCJdKSwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIildKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJjYXRjaCBcIiwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIildKTtcblxuICAgICAgY2FzZSBcIlRocm93U3RhdGVtZW50XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJ0aHJvd1wiLCBwcmludFJldHVybkFuZFRocm93QXJndW1lbnQocGF0aCwgb3B0aW9ucywgcHJpbnQpXSk7XG4gICAgICAvLyBOb3RlOiBpZ25vcmluZyBuLmxleGljYWwgYmVjYXVzZSBpdCBoYXMgbm8gcHJpbnRpbmcgY29uc2VxdWVuY2VzLlxuXG4gICAgICBjYXNlIFwiU3dpdGNoU3RhdGVtZW50XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbZ3JvdXAkYihjb25jYXQkZChbXCJzd2l0Y2ggKFwiLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcImRpc2NyaW1pbmFudFwiKV0pKSwgc29mdGxpbmUkNiwgXCIpXCJdKSksIFwiIHtcIiwgbi5jYXNlcy5sZW5ndGggPiAwID8gaW5kZW50JDcoY29uY2F0JGQoW2hhcmRsaW5lJDksIGpvaW4kOShoYXJkbGluZSQ5LCBwYXRoLm1hcChjYXNlUGF0aCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FzZU5vZGUgPSBjYXNlUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbY2FzZVBhdGguY2FsbChwcmludCksIG4uY2FzZXMuaW5kZXhPZihjYXNlTm9kZSkgIT09IG4uY2FzZXMubGVuZ3RoIC0gMSAmJiBpc05leHRMaW5lRW1wdHkkNChvcHRpb25zLm9yaWdpbmFsVGV4dCwgY2FzZU5vZGUsIG9wdGlvbnMubG9jRW5kKSA/IGhhcmRsaW5lJDkgOiBcIlwiXSk7XG4gICAgICAgIH0sIFwiY2FzZXNcIikpXSkpIDogXCJcIiwgaGFyZGxpbmUkOSwgXCJ9XCJdKTtcblxuICAgICAgY2FzZSBcIlN3aXRjaENhc2VcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChuLnRlc3QpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJjYXNlIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidGVzdFwiKSwgXCI6XCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiZGVmYXVsdDpcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY29uc2VxdWVudCA9IG4uY29uc2VxdWVudC5maWx0ZXIobm9kZSA9PiBub2RlLnR5cGUgIT09IFwiRW1wdHlTdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICBpZiAoY29uc2VxdWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb25zID0gcGF0aC5jYWxsKGNvbnNlcXVlbnRQYXRoID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByaW50U3RhdGVtZW50U2VxdWVuY2UoY29uc2VxdWVudFBhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgICAgIH0sIFwiY29uc2VxdWVudFwiKTtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goY29uc2VxdWVudC5sZW5ndGggPT09IDEgJiYgY29uc2VxdWVudFswXS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgPyBjb25jYXQkZChbXCIgXCIsIGNvbnNdKSA6IGluZGVudCQ3KGNvbmNhdCRkKFtoYXJkbGluZSQ5LCBjb25zXSkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgICAgICB9XG4gICAgICAvLyBKU1ggZXh0ZW5zaW9ucyBiZWxvdy5cblxuICAgICAgY2FzZSBcIkRlYnVnZ2VyU3RhdGVtZW50XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJkZWJ1Z2dlclwiLCBzZW1pXSk7XG5cbiAgICAgIGNhc2UgXCJKU1hBdHRyaWJ1dGVcIjpcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSk7XG5cbiAgICAgICAgaWYgKG4udmFsdWUpIHtcbiAgICAgICAgICBsZXQgcmVzO1xuXG4gICAgICAgICAgaWYgKGlzU3RyaW5nTGl0ZXJhbCQxKG4udmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSByYXdUZXh0JDEobi52YWx1ZSk7IC8vIFVuZXNjYXBlIGFsbCBxdW90ZXMgc28gd2UgZ2V0IGFuIGFjY3VyYXRlIHByZWZlcnJlZCBxdW90ZVxuXG4gICAgICAgICAgICBsZXQgZmluYWwgPSByYXcucmVwbGFjZSgvJmFwb3M7L2csIFwiJ1wiKS5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJyk7XG4gICAgICAgICAgICBjb25zdCBxdW90ZSA9IGdldFByZWZlcnJlZFF1b3RlJDEoZmluYWwsIG9wdGlvbnMuanN4U2luZ2xlUXVvdGUgPyBcIidcIiA6ICdcIicpO1xuICAgICAgICAgICAgY29uc3QgZXNjYXBlID0gcXVvdGUgPT09IFwiJ1wiID8gXCImYXBvcztcIiA6IFwiJnF1b3Q7XCI7XG4gICAgICAgICAgICBmaW5hbCA9IGZpbmFsLnNsaWNlKDEsIC0xKS5yZXBsYWNlKG5ldyBSZWdFeHAocXVvdGUsIFwiZ1wiKSwgZXNjYXBlKTtcbiAgICAgICAgICAgIHJlcyA9IGNvbmNhdCRkKFtxdW90ZSwgZmluYWwsIHF1b3RlXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiPVwiLCByZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIkpTWElkZW50aWZpZXJcIjpcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBuLm5hbWU7XG5cbiAgICAgIGNhc2UgXCJKU1hOYW1lc3BhY2VkTmFtZVwiOlxuICAgICAgICByZXR1cm4gam9pbiQ5KFwiOlwiLCBbcGF0aC5jYWxsKHByaW50LCBcIm5hbWVzcGFjZVwiKSwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIildKTtcblxuICAgICAgY2FzZSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIGpvaW4kOShcIi5cIiwgW3BhdGguY2FsbChwcmludCwgXCJvYmplY3RcIiksIHBhdGguY2FsbChwcmludCwgXCJwcm9wZXJ0eVwiKV0pO1xuXG4gICAgICBjYXNlIFwiVFNRdWFsaWZpZWROYW1lXCI6XG4gICAgICAgIHJldHVybiBqb2luJDkoXCIuXCIsIFtwYXRoLmNhbGwocHJpbnQsIFwibGVmdFwiKSwgcGF0aC5jYWxsKHByaW50LCBcInJpZ2h0XCIpXSk7XG5cbiAgICAgIGNhc2UgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIjpcbiAgICAgIGNhc2UgXCJKU1hTcHJlYWRDaGlsZFwiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIntcIiwgcGF0aC5jYWxsKHAgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJpbnRlZCA9IGNvbmNhdCRkKFtcIi4uLlwiLCBwcmludChwKV0pO1xuICAgICAgICAgICAgY29uc3QgbiA9IHAuZ2V0VmFsdWUoKTtcblxuICAgICAgICAgICAgaWYgKCFuLmNvbW1lbnRzIHx8ICFuLmNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJpbnRlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgY29tbWVudHMucHJpbnRDb21tZW50cyhwLCAoKSA9PiBwcmludGVkLCBvcHRpb25zKV0pKSwgc29mdGxpbmUkNl0pO1xuICAgICAgICAgIH0sIG4udHlwZSA9PT0gXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiA/IFwiYXJndW1lbnRcIiA6IFwiZXhwcmVzc2lvblwiKSwgXCJ9XCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDApO1xuICAgICAgICAgIGNvbnN0IGhhc0NvbW1lbnRzID0gbi5leHByZXNzaW9uLmNvbW1lbnRzICYmIG4uZXhwcmVzc2lvbi5jb21tZW50cy5sZW5ndGggPiAwO1xuICAgICAgICAgIGNvbnN0IHNob3VsZElubGluZSA9IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiIHx8ICFoYXNDb21tZW50cyAmJiAobi5leHByZXNzaW9uLnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIgfHwgbi5leHByZXNzaW9uLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbi50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbi5leHByZXNzaW9uLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBuLmV4cHJlc3Npb24udHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIgfHwgbi5leHByZXNzaW9uLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgbi5leHByZXNzaW9uLnR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgfHwgbi5leHByZXNzaW9uLnR5cGUgPT09IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIgfHwgbi5leHByZXNzaW9uLnR5cGUgPT09IFwiRG9FeHByZXNzaW9uXCIgfHwgaXNKU1hOb2RlJDEocGFyZW50KSAmJiAobi5leHByZXNzaW9uLnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgfHwgaXNCaW5hcnlpc2gkMShuLmV4cHJlc3Npb24pKSk7XG5cbiAgICAgICAgICBpZiAoc2hvdWxkSW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbXCJ7XCIsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBsaW5lU3VmZml4Qm91bmRhcnkkMSwgXCJ9XCJdKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIildKSksIHNvZnRsaW5lJDYsIGxpbmVTdWZmaXhCb3VuZGFyeSQxLCBcIn1cIl0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiSlNYRnJhZ21lbnRcIjpcbiAgICAgIGNhc2UgXCJKU1hFbGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBlbGVtID0gY29tbWVudHMucHJpbnRDb21tZW50cyhwYXRoLCAoKSA9PiBwcmludEpTWEVsZW1lbnQocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBvcHRpb25zKTtcbiAgICAgICAgICByZXR1cm4gbWF5YmVXcmFwSlNYRWxlbWVudEluUGFyZW5zKHBhdGgsIGVsZW0sIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJKU1hPcGVuaW5nRWxlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbiA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICAgICAgICBjb25zdCBuYW1lSGFzQ29tbWVudHMgPSBuLm5hbWUgJiYgbi5uYW1lLmNvbW1lbnRzICYmIG4ubmFtZS5jb21tZW50cy5sZW5ndGggPiAwIHx8IG4udHlwZVBhcmFtZXRlcnMgJiYgbi50eXBlUGFyYW1ldGVycy5jb21tZW50cyAmJiBuLnR5cGVQYXJhbWV0ZXJzLmNvbW1lbnRzLmxlbmd0aCA+IDA7IC8vIERvbid0IGJyZWFrIHNlbGYtY2xvc2luZyBlbGVtZW50cyB3aXRoIG5vIGF0dHJpYnV0ZXMgYW5kIG5vIGNvbW1lbnRzXG5cbiAgICAgICAgICBpZiAobi5zZWxmQ2xvc2luZyAmJiAhbi5hdHRyaWJ1dGVzLmxlbmd0aCAmJiAhbmFtZUhhc0NvbW1lbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiPFwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpLCBcIiAvPlwiXSk7XG4gICAgICAgICAgfSAvLyBkb24ndCBicmVhayB1cCBvcGVuaW5nIGVsZW1lbnRzIHdpdGggYSBzaW5nbGUgbG9uZyB0ZXh0IGF0dHJpYnV0ZVxuXG5cbiAgICAgICAgICBpZiAobi5hdHRyaWJ1dGVzICYmIG4uYXR0cmlidXRlcy5sZW5ndGggPT09IDEgJiYgbi5hdHRyaWJ1dGVzWzBdLnZhbHVlICYmIGlzU3RyaW5nTGl0ZXJhbCQxKG4uYXR0cmlidXRlc1swXS52YWx1ZSkgJiYgIW4uYXR0cmlidXRlc1swXS52YWx1ZS52YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSAmJiAvLyBXZSBzaG91bGQgYnJlYWsgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgICAgLy8gPGRpdlxuICAgICAgICAgIC8vICAgLy8gY29tbWVudFxuICAgICAgICAgIC8vICAgYXR0cj1cInZhbHVlXCJcbiAgICAgICAgICAvLyA+XG4gICAgICAgICAgLy8gPGRpdlxuICAgICAgICAgIC8vICAgYXR0cj1cInZhbHVlXCJcbiAgICAgICAgICAvLyAgIC8vIGNvbW1lbnRcbiAgICAgICAgICAvLyA+XG4gICAgICAgICAgIW5hbWVIYXNDb21tZW50cyAmJiAoIW4uYXR0cmlidXRlc1swXS5jb21tZW50cyB8fCAhbi5hdHRyaWJ1dGVzWzBdLmNvbW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtcIjxcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSwgXCIgXCIsIGNvbmNhdCRkKHBhdGgubWFwKHByaW50LCBcImF0dHJpYnV0ZXNcIikpLCBuLnNlbGZDbG9zaW5nID8gXCIgLz5cIiA6IFwiPlwiXSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGxhc3RBdHRySGFzVHJhaWxpbmdDb21tZW50cyA9IG4uYXR0cmlidXRlcy5sZW5ndGggJiYgaGFzVHJhaWxpbmdDb21tZW50JDEoZ2V0TGFzdCQzKG4uYXR0cmlidXRlcykpO1xuICAgICAgICAgIGNvbnN0IGJyYWNrZXRTYW1lTGluZSA9IC8vIFNpbXBsZSB0YWdzIChubyBhdHRyaWJ1dGVzIGFuZCBubyBjb21tZW50IGluIHRhZyBuYW1lKSBzaG91bGQgYmVcbiAgICAgICAgICAvLyBrZXB0IHVuYnJva2VuIHJlZ2FyZGxlc3Mgb2YgYGpzeEJyYWNrZXRTYW1lTGluZWBcbiAgICAgICAgICAhbi5hdHRyaWJ1dGVzLmxlbmd0aCAmJiAhbmFtZUhhc0NvbW1lbnRzIHx8IG9wdGlvbnMuanN4QnJhY2tldFNhbWVMaW5lICYmICggLy8gV2Ugc2hvdWxkIHByaW50IHRoZSBicmFja2V0IGluIGEgbmV3IGxpbmUgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgICAgICAgLy8gPGRpdlxuICAgICAgICAgIC8vICAgLy8gY29tbWVudFxuICAgICAgICAgIC8vID5cbiAgICAgICAgICAvLyA8ZGl2XG4gICAgICAgICAgLy8gICBhdHRyIC8vIGNvbW1lbnRcbiAgICAgICAgICAvLyA+XG4gICAgICAgICAgIW5hbWVIYXNDb21tZW50cyB8fCBuLmF0dHJpYnV0ZXMubGVuZ3RoKSAmJiAhbGFzdEF0dHJIYXNUcmFpbGluZ0NvbW1lbnRzOyAvLyBXZSBzaG91bGQgcHJpbnQgdGhlIG9wZW5pbmcgZWxlbWVudCBleHBhbmRlZCBpZiBhbnkgcHJvcCB2YWx1ZSBpcyBhXG4gICAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwgd2l0aCBuZXdsaW5lc1xuXG4gICAgICAgICAgY29uc3Qgc2hvdWxkQnJlYWsgPSBuLmF0dHJpYnV0ZXMgJiYgbi5hdHRyaWJ1dGVzLnNvbWUoYXR0ciA9PiBhdHRyLnZhbHVlICYmIGlzU3RyaW5nTGl0ZXJhbCQxKGF0dHIudmFsdWUpICYmIGF0dHIudmFsdWUudmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpO1xuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtcIjxcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSwgY29uY2F0JGQoW2luZGVudCQ3KGNvbmNhdCRkKHBhdGgubWFwKGF0dHIgPT4gY29uY2F0JGQoW2xpbmUkOSwgcHJpbnQoYXR0cildKSwgXCJhdHRyaWJ1dGVzXCIpKSksIG4uc2VsZkNsb3NpbmcgPyBsaW5lJDkgOiBicmFja2V0U2FtZUxpbmUgPyBcIj5cIiA6IHNvZnRsaW5lJDZdKSwgbi5zZWxmQ2xvc2luZyA/IFwiLz5cIiA6IGJyYWNrZXRTYW1lTGluZSA/IFwiXCIgOiBcIj5cIl0pLCB7XG4gICAgICAgICAgICBzaG91bGRCcmVha1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJKU1hDbG9zaW5nRWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiPC9cIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIiksIFwiPlwiXSk7XG5cbiAgICAgIGNhc2UgXCJKU1hPcGVuaW5nRnJhZ21lbnRcIjpcbiAgICAgIGNhc2UgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGhhc0NvbW1lbnQgPSBuLmNvbW1lbnRzICYmIG4uY29tbWVudHMubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGhhc093bkxpbmVDb21tZW50ID0gaGFzQ29tbWVudCAmJiAhbi5jb21tZW50cy5ldmVyeShjb21tZW50cyQxLmlzQmxvY2tDb21tZW50KTtcbiAgICAgICAgICBjb25zdCBpc09wZW5pbmdGcmFnbWVudCA9IG4udHlwZSA9PT0gXCJKU1hPcGVuaW5nRnJhZ21lbnRcIjtcbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW2lzT3BlbmluZ0ZyYWdtZW50ID8gXCI8XCIgOiBcIjwvXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtoYXNPd25MaW5lQ29tbWVudCA/IGhhcmRsaW5lJDkgOiBoYXNDb21tZW50ICYmICFpc09wZW5pbmdGcmFnbWVudCA/IFwiIFwiIDogXCJcIiwgY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsIHRydWUpXSkpLCBoYXNPd25MaW5lQ29tbWVudCA/IGhhcmRsaW5lJDkgOiBcIlwiLCBcIj5cIl0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJKU1hUZXh0XCI6XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTWFRlc3Qgc2hvdWxkIGJlIGhhbmRsZWQgYnkgSlNYRWxlbWVudFwiKTtcblxuICAgICAgY2FzZSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcmVxdWlyZXNIYXJkbGluZSA9IG4uY29tbWVudHMgJiYgIW4uY29tbWVudHMuZXZlcnkoY29tbWVudHMkMS5pc0Jsb2NrQ29tbWVudCk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyxcbiAgICAgICAgICAvKiBzYW1lSW5kZW50ICovXG4gICAgICAgICAgIXJlcXVpcmVzSGFyZGxpbmUpLCByZXF1aXJlc0hhcmRsaW5lID8gaGFyZGxpbmUkOSA6IFwiXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQ2xhc3NCb2R5XCI6XG4gICAgICAgIGlmICghbi5jb21tZW50cyAmJiBuLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIFwie31cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJ7XCIsIG4uYm9keS5sZW5ndGggPiAwID8gaW5kZW50JDcoY29uY2F0JGQoW2hhcmRsaW5lJDksIHBhdGguY2FsbChib2R5UGF0aCA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByaW50U3RhdGVtZW50U2VxdWVuY2UoYm9keVBhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICAgICAgfSwgXCJib2R5XCIpXSkpIDogY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMpLCBoYXJkbGluZSQ5LCBcIn1cIl0pO1xuXG4gICAgICBjYXNlIFwiQ2xhc3NQcm9wZXJ0eVwiOlxuICAgICAgY2FzZSBcIlRTQWJzdHJhY3RDbGFzc1Byb3BlcnR5XCI6XG4gICAgICBjYXNlIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChuLmRlY29yYXRvcnMgJiYgbi5kZWNvcmF0b3JzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChwcmludERlY29yYXRvcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG4uYWNjZXNzaWJpbGl0eSArIFwiIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5kZWNsYXJlKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4uc3RhdGljKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwic3RhdGljIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi50eXBlID09PSBcIlRTQWJzdHJhY3RDbGFzc1Byb3BlcnR5XCIgfHwgbi5hYnN0cmFjdCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcImFic3RyYWN0IFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5yZWFkb25seSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcInJlYWRvbmx5IFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IGdldEZsb3dWYXJpYW5jZSQxKG4pO1xuXG4gICAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHZhcmlhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKHByaW50UHJvcGVydHlLZXkocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCksIHByaW50VHlwZUFubm90YXRpb24ocGF0aCwgb3B0aW9ucywgcHJpbnQpKTtcblxuICAgICAgICAgIGlmIChuLnZhbHVlKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiID1cIiwgcHJpbnRBc3NpZ25tZW50UmlnaHQobi5rZXksIG4udmFsdWUsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKSwgb3B0aW9ucykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQocGFydHMpKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAobi5kZWNsYXJlKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcImRlY2xhcmUgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaChjb25jYXQkZChwcmludENsYXNzKHBhdGgsIG9wdGlvbnMsIHByaW50KSkpO1xuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiVFNJbnRlcmZhY2VIZXJpdGFnZVwiOlxuICAgICAgY2FzZSBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCI6XG4gICAgICAgIC8vIEJhYmVsIEFTVFxuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpKTtcblxuICAgICAgICBpZiAobi50eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJUZW1wbGF0ZUVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGpvaW4kOShsaXRlcmFsbGluZSQ0LCBuLnZhbHVlLnJhdy5zcGxpdCgvXFxyP1xcbi9nKSk7XG5cbiAgICAgIGNhc2UgXCJUZW1wbGF0ZUxpdGVyYWxcIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCBleHByZXNzaW9ucyA9IHBhdGgubWFwKHByaW50LCBcImV4cHJlc3Npb25zXCIpO1xuICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcblxuICAgICAgICAgIGlmIChpc0plc3RFYWNoVGVtcGxhdGVMaXRlcmFsJDEobiwgcGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByaW50ZWQgPSBwcmludEplc3RFYWNoVGVtcGxhdGVMaXRlcmFsKG4sIGV4cHJlc3Npb25zLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgaWYgKHByaW50ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByaW50ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgaXNTaW1wbGUgPSBpc1NpbXBsZVRlbXBsYXRlTGl0ZXJhbCQxKG4pO1xuXG4gICAgICAgICAgaWYgKGlzU2ltcGxlKSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucyA9IGV4cHJlc3Npb25zLm1hcChkb2MgPT4gcHJpbnREb2NUb1N0cmluZyQyKGRvYywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICBwcmludFdpZHRoOiBJbmZpbml0eVxuICAgICAgICAgICAgfSkpLmZvcm1hdHRlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaChsaW5lU3VmZml4Qm91bmRhcnkkMSwgXCJgXCIpO1xuICAgICAgICAgIHBhdGguZWFjaChjaGlsZFBhdGggPT4ge1xuICAgICAgICAgICAgY29uc3QgaSA9IGNoaWxkUGF0aC5nZXROYW1lKCk7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHByaW50KGNoaWxkUGF0aCkpO1xuXG4gICAgICAgICAgICBpZiAoaSA8IGV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBGb3IgYSB0ZW1wbGF0ZSBsaXRlcmFsIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAgICAgICAgICAgICAgLy8gICBgc29tZVF1ZXJ5IHtcbiAgICAgICAgICAgICAgLy8gICAgICR7Y2FsbCh7XG4gICAgICAgICAgICAgIC8vICAgICAgIGEsXG4gICAgICAgICAgICAgIC8vICAgICAgIGIsXG4gICAgICAgICAgICAgIC8vICAgICB9KX1cbiAgICAgICAgICAgICAgLy8gICB9YFxuICAgICAgICAgICAgICAvLyB0aGUgZXhwcmVzc2lvbiBpcyBvbiBpdHMgb3duIGxpbmUgKHRoZXJlIGlzIGEgXFxuIGluIHRoZSBwcmV2aW91c1xuICAgICAgICAgICAgICAvLyBxdWFzaSBsaXRlcmFsKSwgdGhlcmVmb3JlIHdlIHdhbnQgdG8gaW5kZW50IHRoZSBKYXZhU2NyaXB0XG4gICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gaW5zaWRlIGF0IHRoZSBiZWdpbm5pbmcgb2YgJHsgaW5zdGVhZCBvZiB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBgLlxuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFiV2lkdGhcbiAgICAgICAgICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgIGNvbnN0IHF1YXNpID0gY2hpbGRQYXRoLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGVudFNpemUgPSBnZXRJbmRlbnRTaXplJDIocXVhc2kudmFsdWUucmF3LCB0YWJXaWR0aCk7XG4gICAgICAgICAgICAgIGxldCBwcmludGVkID0gZXhwcmVzc2lvbnNbaV07XG5cbiAgICAgICAgICAgICAgaWYgKCFpc1NpbXBsZSkge1xuICAgICAgICAgICAgICAgIC8vIEJyZWFrcyBhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBib3VuZGFyaWVzICgkeyBhbmQgfSkgYXJlIHByZWZlcnJlZCB0byBicmVha2luZ1xuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgYSBNZW1iZXJFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgaWYgKG4uZXhwcmVzc2lvbnNbaV0uY29tbWVudHMgJiYgbi5leHByZXNzaW9uc1tpXS5jb21tZW50cy5sZW5ndGggfHwgbi5leHByZXNzaW9uc1tpXS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBuLmV4cHJlc3Npb25zW2ldLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIgfHwgbi5leHByZXNzaW9uc1tpXS50eXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiIHx8IG4uZXhwcmVzc2lvbnNbaV0udHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiB8fCBuLmV4cHJlc3Npb25zW2ldLnR5cGUgPT09IFwiVFNBc0V4cHJlc3Npb25cIiB8fCBpc0JpbmFyeWlzaCQxKG4uZXhwcmVzc2lvbnNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICBwcmludGVkID0gY29uY2F0JGQoW2luZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwcmludGVkXSkpLCBzb2Z0bGluZSQ2XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgYWxpZ25lZCA9IGluZGVudFNpemUgPT09IDAgJiYgcXVhc2kudmFsdWUucmF3LmVuZHNXaXRoKFwiXFxuXCIpID8gYWxpZ24kMSgtSW5maW5pdHksIHByaW50ZWQpIDogYWRkQWxpZ25tZW50VG9Eb2MkMihwcmludGVkLCBpbmRlbnRTaXplLCB0YWJXaWR0aCk7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihjb25jYXQkZChbXCIke1wiLCBhbGlnbmVkLCBsaW5lU3VmZml4Qm91bmRhcnkkMSwgXCJ9XCJdKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIFwicXVhc2lzXCIpO1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJgXCIpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgIC8vIFRoZXNlIHR5cGVzIGFyZSB1bnByaW50YWJsZSBiZWNhdXNlIHRoZXkgc2VydmUgYXMgYWJzdHJhY3RcbiAgICAgIC8vIHN1cGVydHlwZXMgZm9yIG90aGVyIChwcmludGFibGUpIHR5cGVzLlxuXG4gICAgICBjYXNlIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcInRhZ1wiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwicXVhc2lcIildKTtcblxuICAgICAgY2FzZSBcIk5vZGVcIjpcbiAgICAgIGNhc2UgXCJQcmludGFibGVcIjpcbiAgICAgIGNhc2UgXCJTb3VyY2VMb2NhdGlvblwiOlxuICAgICAgY2FzZSBcIlBvc2l0aW9uXCI6XG4gICAgICBjYXNlIFwiU3RhdGVtZW50XCI6XG4gICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIkRlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiU3BlY2lmaWVyXCI6XG4gICAgICBjYXNlIFwiTmFtZWRTcGVjaWZpZXJcIjpcbiAgICAgIGNhc2UgXCJDb21tZW50XCI6XG4gICAgICBjYXNlIFwiTWVtYmVyVHlwZUFubm90YXRpb25cIjogLy8gRmxvd1xuXG4gICAgICBjYXNlIFwiVHlwZVwiOlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnByaW50YWJsZSB0eXBlOiBcIiArIEpTT04uc3RyaW5naWZ5KG4udHlwZSkpO1xuICAgICAgLy8gVHlwZSBBbm5vdGF0aW9ucyBmb3IgRmFjZWJvb2sgRmxvdywgdHlwaWNhbGx5IHN0cmlwcGVkIG91dCBvclxuICAgICAgLy8gdHJhbnNmb3JtZWQgYXdheSBiZWZvcmUgcHJpbnRpbmcuXG5cbiAgICAgIGNhc2UgXCJUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgaWYgKG4udHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICAgICAgICByZXR1cm4gXCJcIjtcblxuICAgICAgY2FzZSBcIlRTVHVwbGVUeXBlXCI6XG4gICAgICBjYXNlIFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgdHlwZXNGaWVsZCA9IG4udHlwZSA9PT0gXCJUU1R1cGxlVHlwZVwiID8gXCJlbGVtZW50VHlwZXNcIiA6IFwidHlwZXNcIjtcbiAgICAgICAgICBjb25zdCBoYXNSZXN0ID0gblt0eXBlc0ZpZWxkXS5sZW5ndGggPiAwICYmIGdldExhc3QkMyhuW3R5cGVzRmllbGRdKS50eXBlID09PSBcIlRTUmVzdFR5cGVcIjtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbXCJbXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBwcmludEFycmF5SXRlbXMocGF0aCwgb3B0aW9ucywgdHlwZXNGaWVsZCwgcHJpbnQpXSkpLCBpZkJyZWFrJDYoc2hvdWxkUHJpbnRDb21tYSQxKG9wdGlvbnMsIFwiYWxsXCIpICYmICFoYXNSZXN0ID8gXCIsXCIgOiBcIlwiKSwgY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgICAgIHRydWUpLCBzb2Z0bGluZSQ2LCBcIl1cIl0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRXhpc3RzVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwiKlwiO1xuXG4gICAgICBjYXNlIFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gXCJlbXB0eVwiO1xuXG4gICAgICBjYXNlIFwiQW55VHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwiYW55XCI7XG5cbiAgICAgIGNhc2UgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBcIm1peGVkXCI7XG5cbiAgICAgIGNhc2UgXCJBcnJheVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcImVsZW1lbnRUeXBlXCIpLCBcIltdXCJdKTtcblxuICAgICAgY2FzZSBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG5cbiAgICAgIGNhc2UgXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBcIlwiICsgbi52YWx1ZTtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVDbGFzc1wiOlxuICAgICAgICByZXR1cm4gcHJpbnRGbG93RGVjbGFyYXRpb24ocGF0aCwgcHJpbnRDbGFzcyhwYXRoLCBvcHRpb25zLCBwcmludCkpO1xuXG4gICAgICBjYXNlIFwiVFNEZWNsYXJlRnVuY3Rpb25cIjpcbiAgICAgICAgLy8gRm9yIFR5cGVTY3JpcHQgdGhlIFRTRGVjbGFyZUZ1bmN0aW9uIG5vZGUgc2hhcmVzIHRoZSBBU1RcbiAgICAgICAgLy8gc3RydWN0dXJlIHdpdGggRnVuY3Rpb25EZWNsYXJhdGlvblxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW24uZGVjbGFyZSA/IFwiZGVjbGFyZSBcIiA6IFwiXCIsIHByaW50RnVuY3Rpb25EZWNsYXJhdGlvbihwYXRoLCBwcmludCwgb3B0aW9ucyksIHNlbWldKTtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVGdW5jdGlvblwiOlxuICAgICAgICByZXR1cm4gcHJpbnRGbG93RGVjbGFyYXRpb24ocGF0aCwgW1wiZnVuY3Rpb24gXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgbi5wcmVkaWNhdGUgPyBcIiBcIiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJwcmVkaWNhdGVcIiksIHNlbWldKTtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVNb2R1bGVcIjpcbiAgICAgICAgcmV0dXJuIHByaW50Rmxvd0RlY2xhcmF0aW9uKHBhdGgsIFtcIm1vZHVsZSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIildKTtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCI6XG4gICAgICAgIHJldHVybiBwcmludEZsb3dEZWNsYXJhdGlvbihwYXRoLCBbXCJtb2R1bGUuZXhwb3J0c1wiLCBcIjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSwgc2VtaV0pO1xuXG4gICAgICBjYXNlIFwiRGVjbGFyZVZhcmlhYmxlXCI6XG4gICAgICAgIHJldHVybiBwcmludEZsb3dEZWNsYXJhdGlvbihwYXRoLCBbXCJ2YXIgXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgc2VtaV0pO1xuXG4gICAgICBjYXNlIFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJkZWNsYXJlIGV4cG9ydCAqIGZyb20gXCIsIHBhdGguY2FsbChwcmludCwgXCJzb3VyY2VcIildKTtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiZGVjbGFyZSBcIiwgcHJpbnRFeHBvcnREZWNsYXJhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCldKTtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVPcGFxdWVUeXBlXCI6XG4gICAgICBjYXNlIFwiT3BhcXVlVHlwZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgcGFydHMucHVzaChcIm9wYXF1ZSB0eXBlIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSk7XG5cbiAgICAgICAgICBpZiAobi5zdXBlcnR5cGUpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwic3VwZXJ0eXBlXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5pbXBsdHlwZSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIiA9IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaW1wbHR5cGVcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG5cbiAgICAgICAgICBpZiAobi50eXBlID09PSBcIkRlY2xhcmVPcGFxdWVUeXBlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmludEZsb3dEZWNsYXJhdGlvbihwYXRoLCBwYXJ0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiRW51bURlY2xhcmF0aW9uXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJlbnVtIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKV0pO1xuXG4gICAgICBjYXNlIFwiRW51bUJvb2xlYW5Cb2R5XCI6XG4gICAgICBjYXNlIFwiRW51bU51bWJlckJvZHlcIjpcbiAgICAgIGNhc2UgXCJFbnVtU3RyaW5nQm9keVwiOlxuICAgICAgY2FzZSBcIkVudW1TeW1ib2xCb2R5XCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobi50eXBlID09PSBcIkVudW1TeW1ib2xCb2R5XCIgfHwgbi5leHBsaWNpdFR5cGUpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gbnVsbDtcblxuICAgICAgICAgICAgc3dpdGNoIChuLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcIkVudW1Cb29sZWFuQm9keVwiOlxuICAgICAgICAgICAgICAgIHR5cGUgPSBcImJvb2xlYW5cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiRW51bU51bWJlckJvZHlcIjpcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiRW51bVN0cmluZ0JvZHlcIjpcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiRW51bVN5bWJvbEJvZHlcIjpcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJzeW1ib2xcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMucHVzaChcIm9mIFwiLCB0eXBlLCBcIiBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4ubWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goZ3JvdXAkYihjb25jYXQkZChbXCJ7XCIsIGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zKSwgc29mdGxpbmUkNiwgXCJ9XCJdKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgcHJpbnRBcnJheUl0ZW1zKHBhdGgsIG9wdGlvbnMsIFwibWVtYmVyc1wiLCBwcmludCksIHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zKSA/IFwiLFwiIDogXCJcIl0pKSwgY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAgICAgICAvKiBzYW1lSW5kZW50ICovXG4gICAgICAgICAgICB0cnVlKSwgaGFyZGxpbmUkOSwgXCJ9XCJdKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIkVudW1Cb29sZWFuTWVtYmVyXCI6XG4gICAgICBjYXNlIFwiRW51bU51bWJlck1lbWJlclwiOlxuICAgICAgY2FzZSBcIkVudW1TdHJpbmdNZW1iZXJcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIFwiID0gXCIsIHR5cGVvZiBuLmluaXQgPT09IFwib2JqZWN0XCIgPyBwYXRoLmNhbGwocHJpbnQsIFwiaW5pdFwiKSA6IFN0cmluZyhuLmluaXQpXSk7XG5cbiAgICAgIGNhc2UgXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCI6XG4gICAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIik7XG5cbiAgICAgIGNhc2UgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICBjYXNlIFwiVFNGdW5jdGlvblR5cGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEZ1bmN0aW9uVHlwZUFubm90YXRpb24gaXMgYW1iaWd1b3VzOlxuICAgICAgICAgIC8vIGRlY2xhcmUgZnVuY3Rpb24gZm9vKGE6IEIpOiB2b2lkOyBPUlxuICAgICAgICAgIC8vIHZhciBBOiAoYTogQikgPT4gdm9pZDtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoMCk7XG4gICAgICAgICAgY29uc3QgcGFyZW50UGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDEpO1xuICAgICAgICAgIGNvbnN0IHBhcmVudFBhcmVudFBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgyKTtcbiAgICAgICAgICBsZXQgaXNBcnJvd0Z1bmN0aW9uVHlwZUFubm90YXRpb24gPSBuLnR5cGUgPT09IFwiVFNGdW5jdGlvblR5cGVcIiB8fCAhKChwYXJlbnQudHlwZSA9PT0gXCJPYmplY3RUeXBlUHJvcGVydHlcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIpICYmICFnZXRGbG93VmFyaWFuY2UkMShwYXJlbnQpICYmICFwYXJlbnQub3B0aW9uYWwgJiYgb3B0aW9ucy5sb2NTdGFydChwYXJlbnQpID09PSBvcHRpb25zLmxvY1N0YXJ0KG4pIHx8IHBhcmVudC50eXBlID09PSBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiB8fCBwYXJlbnRQYXJlbnRQYXJlbnQgJiYgcGFyZW50UGFyZW50UGFyZW50LnR5cGUgPT09IFwiRGVjbGFyZUZ1bmN0aW9uXCIpO1xuICAgICAgICAgIGxldCBuZWVkc0NvbG9uID0gaXNBcnJvd0Z1bmN0aW9uVHlwZUFubm90YXRpb24gJiYgKHBhcmVudC50eXBlID09PSBcIlR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNUeXBlQW5ub3RhdGlvblwiKTsgLy8gU2FkbHkgd2UgY2FuJ3QgcHV0IGl0IGluc2lkZSBvZiBGYXN0UGF0aDo6bmVlZHNDb2xvbiBiZWNhdXNlIHdlIGFyZVxuICAgICAgICAgIC8vIHByaW50aW5nIFwiOlwiIGFzIHBhcnQgb2YgdGhlIGV4cHJlc3Npb24gYW5kIGl0IHdvdWxkIHB1dCBwYXJlbnRoZXNpc1xuICAgICAgICAgIC8vIGFyb3VuZCA6KFxuXG4gICAgICAgICAgY29uc3QgbmVlZHNQYXJlbnMgPSBuZWVkc0NvbG9uICYmIGlzQXJyb3dGdW5jdGlvblR5cGVBbm5vdGF0aW9uICYmIChwYXJlbnQudHlwZSA9PT0gXCJUeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudC50eXBlID09PSBcIlRTVHlwZUFubm90YXRpb25cIikgJiYgcGFyZW50UGFyZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjtcblxuICAgICAgICAgIGlmIChpc09iamVjdFR5cGVQcm9wZXJ0eUFGdW5jdGlvbiQxKHBhcmVudCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIGlzQXJyb3dGdW5jdGlvblR5cGVBbm5vdGF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIG5lZWRzQ29sb24gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWVkc1BhcmVucykge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIihcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaChwcmludEZ1bmN0aW9uUGFyYW1zKHBhdGgsIHByaW50LCBvcHRpb25zLFxuICAgICAgICAgIC8qIGV4cGFuZEFyZyAqL1xuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIC8qIHByaW50VHlwZVBhcmFtcyAqL1xuICAgICAgICAgIHRydWUpKTsgLy8gVGhlIHJldHVyblR5cGUgaXMgbm90IHdyYXBwZWQgaW4gYSBUeXBlQW5ub3RhdGlvbiwgc28gdGhlIGNvbG9uXG4gICAgICAgICAgLy8gbmVlZHMgdG8gYmUgYWRkZWQgc2VwYXJhdGVseS5cblxuICAgICAgICAgIGlmIChuLnJldHVyblR5cGUgfHwgbi5wcmVkaWNhdGUgfHwgbi50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgcGFydHMucHVzaChpc0Fycm93RnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA/IFwiID0+IFwiIDogXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwicmV0dXJuVHlwZVwiKSwgcGF0aC5jYWxsKHByaW50LCBcInByZWRpY2F0ZVwiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVlZHNQYXJlbnMpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIpXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKHBhcnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlRTUmVzdFR5cGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIi4uLlwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIildKTtcblxuICAgICAgY2FzZSBcIlRTT3B0aW9uYWxUeXBlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpLCBcIj9cIl0pO1xuXG4gICAgICBjYXNlIFwiRnVuY3Rpb25UeXBlUGFyYW1cIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgcHJpbnRPcHRpb25hbFRva2VuKHBhdGgpLCBuLm5hbWUgPyBcIjogXCIgOiBcIlwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIildKTtcblxuICAgICAgY2FzZSBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJpZFwiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJEZWNsYXJlSW50ZXJmYWNlXCI6XG4gICAgICBjYXNlIFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG4udHlwZSA9PT0gXCJEZWNsYXJlSW50ZXJmYWNlXCIgfHwgbi5kZWNsYXJlKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaChcImludGVyZmFjZVwiKTtcblxuICAgICAgICAgIGlmIChuLnR5cGUgPT09IFwiRGVjbGFyZUludGVyZmFjZVwiIHx8IG4udHlwZSA9PT0gXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4uZXh0ZW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoaW5kZW50JDcoY29uY2F0JGQoW2xpbmUkOSwgXCJleHRlbmRzIFwiLCAobi5leHRlbmRzLmxlbmd0aCA9PT0gMSA/IGlkZW50aXR5JDIgOiBpbmRlbnQkNykoam9pbiQ5KGNvbmNhdCRkKFtcIixcIiwgbGluZSQ5XSksIHBhdGgubWFwKHByaW50LCBcImV4dGVuZHNcIikpKV0pKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChwYXJ0cykpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJDbGFzc0ltcGxlbWVudHNcIjpcbiAgICAgIGNhc2UgXCJJbnRlcmZhY2VFeHRlbmRzXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIildKTtcblxuICAgICAgY2FzZSBcIlRTQ2xhc3NJbXBsZW1lbnRzXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIiksIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKV0pO1xuXG4gICAgICBjYXNlIFwiVFNJbnRlcnNlY3Rpb25UeXBlXCI6XG4gICAgICBjYXNlIFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHR5cGVzID0gcGF0aC5tYXAocHJpbnQsIFwidHlwZXNcIik7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgbGV0IHdhc0luZGVudGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCh0eXBlc1tpXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0VHlwZSQxKG4udHlwZXNbaSAtIDFdKSAmJiBpc09iamVjdFR5cGUkMShuLnR5cGVzW2ldKSkge1xuICAgICAgICAgICAgICAvLyBJZiBib3RoIGFyZSBvYmplY3RzLCBkb24ndCBpbmRlbnRcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29uY2F0JGQoW1wiICYgXCIsIHdhc0luZGVudGVkID8gaW5kZW50JDcodHlwZXNbaV0pIDogdHlwZXNbaV1dKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc09iamVjdFR5cGUkMShuLnR5cGVzW2kgLSAxXSkgJiYgIWlzT2JqZWN0VHlwZSQxKG4udHlwZXNbaV0pKSB7XG4gICAgICAgICAgICAgIC8vIElmIG5vIG9iamVjdCBpcyBpbnZvbHZlZCwgZ28gdG8gdGhlIG5leHQgbGluZSBpZiBpdCBicmVha3NcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50JDcoY29uY2F0JGQoW1wiICZcIiwgbGluZSQ5LCB0eXBlc1tpXV0pKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJZiB5b3UgZ28gZnJvbSBvYmplY3QgdG8gbm9uLW9iamVjdCBvciB2aXMtdmVyc2EsIHRoZW4gaW5saW5lIGl0XG4gICAgICAgICAgICAgIGlmIChpID4gMSkge1xuICAgICAgICAgICAgICAgIHdhc0luZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiICYgXCIsIGkgPiAxID8gaW5kZW50JDcodHlwZXNbaV0pIDogdHlwZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKHJlc3VsdCkpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU1VuaW9uVHlwZVwiOlxuICAgICAgY2FzZSBcIlVuaW9uVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIC8vIHNpbmdsZS1saW5lIHZhcmlhdGlvblxuICAgICAgICAgIC8vIEEgfCBCIHwgQ1xuICAgICAgICAgIC8vIG11bHRpLWxpbmUgdmFyaWF0aW9uXG4gICAgICAgICAgLy8gfCBBXG4gICAgICAgICAgLy8gfCBCXG4gICAgICAgICAgLy8gfCBDXG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7IC8vIElmIHRoZXJlJ3MgYSBsZWFkaW5nIGNvbW1lbnQsIHRoZSBwYXJlbnQgaXMgZG9pbmcgdGhlIGluZGVudGF0aW9uXG5cbiAgICAgICAgICBjb25zdCBzaG91bGRJbmRlbnQgPSBwYXJlbnQudHlwZSAhPT0gXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiICYmIHBhcmVudC50eXBlICE9PSBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJHZW5lcmljVHlwZUFubm90YXRpb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJUU1R5cGVSZWZlcmVuY2VcIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJUU1R5cGVBc3NlcnRpb25cIiAmJiBwYXJlbnQudHlwZSAhPT0gXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIgJiYgcGFyZW50LnR5cGUgIT09IFwiVFNUdXBsZVR5cGVcIiAmJiAhKHBhcmVudC50eXBlID09PSBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIgJiYgIXBhcmVudC5uYW1lKSAmJiAhKChwYXJlbnQudHlwZSA9PT0gXCJUeXBlQWxpYXNcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIpICYmIGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudCQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBuLCBvcHRpb25zKSk7IC8vIHtcbiAgICAgICAgICAvLyAgIGE6IHN0cmluZ1xuICAgICAgICAgIC8vIH0gfCBudWxsIHwgdm9pZFxuICAgICAgICAgIC8vIHNob3VsZCBiZSBpbmxpbmVkIGFuZCBub3QgYmUgcHJpbnRlZCBpbiB0aGUgbXVsdGktbGluZSB2YXJpYW50XG5cbiAgICAgICAgICBjb25zdCBzaG91bGRIdWcgPSBzaG91bGRIdWdUeXBlKG4pOyAvLyBXZSB3YW50IHRvIGFsaWduIHRoZSBjaGlsZHJlbiBidXQgd2l0aG91dCBpdHMgY29tbWVudCwgc28gaXQgbG9va3MgbGlrZVxuICAgICAgICAgIC8vIHwgY2hpbGQxXG4gICAgICAgICAgLy8gLy8gY29tbWVudFxuICAgICAgICAgIC8vIHwgY2hpbGQyXG5cbiAgICAgICAgICBjb25zdCBwcmludGVkID0gcGF0aC5tYXAodHlwZVBhdGggPT4ge1xuICAgICAgICAgICAgbGV0IHByaW50ZWRUeXBlID0gdHlwZVBhdGguY2FsbChwcmludCk7XG5cbiAgICAgICAgICAgIGlmICghc2hvdWxkSHVnKSB7XG4gICAgICAgICAgICAgIHByaW50ZWRUeXBlID0gYWxpZ24kMSgyLCBwcmludGVkVHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb21tZW50cy5wcmludENvbW1lbnRzKHR5cGVQYXRoLCAoKSA9PiBwcmludGVkVHlwZSwgb3B0aW9ucyk7XG4gICAgICAgICAgfSwgXCJ0eXBlc1wiKTtcblxuICAgICAgICAgIGlmIChzaG91bGRIdWcpIHtcbiAgICAgICAgICAgIHJldHVybiBqb2luJDkoXCIgfCBcIiwgcHJpbnRlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgc2hvdWxkQWRkU3RhcnRMaW5lID0gc2hvdWxkSW5kZW50ICYmICFoYXNMZWFkaW5nT3duTGluZUNvbW1lbnQkMShvcHRpb25zLm9yaWdpbmFsVGV4dCwgbiwgb3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgY29kZSA9IGNvbmNhdCRkKFtpZkJyZWFrJDYoY29uY2F0JGQoW3Nob3VsZEFkZFN0YXJ0TGluZSA/IGxpbmUkOSA6IFwiXCIsIFwifCBcIl0pKSwgam9pbiQ5KGNvbmNhdCRkKFtsaW5lJDksIFwifCBcIl0pLCBwcmludGVkKV0pO1xuXG4gICAgICAgICAgaWYgKG5lZWRzUGFyZW5zXzEocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtpbmRlbnQkNyhjb2RlKSwgc29mdGxpbmUkNl0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiICYmIHBhcmVudC50eXBlcy5sZW5ndGggPiAxIHx8IHBhcmVudC50eXBlID09PSBcIlRTVHVwbGVUeXBlXCIgJiYgcGFyZW50LmVsZW1lbnRUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQoW2lmQnJlYWskNihjb25jYXQkZChbXCIoXCIsIHNvZnRsaW5lJDZdKSksIGNvZGVdKSksIHNvZnRsaW5lJDYsIGlmQnJlYWskNihcIilcIildKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoc2hvdWxkSW5kZW50ID8gaW5kZW50JDcoY29kZSkgOiBjb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiP1wiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIildKTtcblxuICAgICAgY2FzZSBcIlRTTnVsbEtleXdvcmRcIjpcbiAgICAgIGNhc2UgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcblxuICAgICAgY2FzZSBcIlRoaXNUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gXCJ0aGlzXCI7XG5cbiAgICAgIGNhc2UgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcblxuICAgICAgY2FzZSBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICAgIHJldHVybiBcInN5bWJvbFwiO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiOlxuICAgICAgICBpZiAobi5zdGF0aWMpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwic3RhdGljIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcblxuICAgICAgY2FzZSBcIk9iamVjdFR5cGVJbmRleGVyXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IGdldEZsb3dWYXJpYW5jZSQxKG4pO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbdmFyaWFuY2UgfHwgXCJcIiwgXCJbXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgbi5pZCA/IFwiOiBcIiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJrZXlcIiksIFwiXTogXCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJPYmplY3RUeXBlUHJvcGVydHlcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHZhcmlhbmNlID0gZ2V0Rmxvd1ZhcmlhbmNlJDEobik7XG4gICAgICAgICAgbGV0IG1vZGlmaWVyID0gXCJcIjtcblxuICAgICAgICAgIGlmIChuLnByb3RvKSB7XG4gICAgICAgICAgICBtb2RpZmllciA9IFwicHJvdG8gXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuLnN0YXRpYykge1xuICAgICAgICAgICAgbW9kaWZpZXIgPSBcInN0YXRpYyBcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQoW21vZGlmaWVyLCBpc0dldHRlck9yU2V0dGVyJDEobikgPyBuLmtpbmQgKyBcIiBcIiA6IFwiXCIsIHZhcmlhbmNlIHx8IFwiXCIsIHByaW50UHJvcGVydHlLZXkocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCksIGlzRnVuY3Rpb25Ob3RhdGlvbiQxKG4sIG9wdGlvbnMpID8gXCJcIiA6IFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcInF1YWxpZmljYXRpb25cIiksIFwiLlwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIildKTtcblxuICAgICAgY2FzZSBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gbm9kZVN0cihuLCBvcHRpb25zKTtcblxuICAgICAgY2FzZSBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHlwZW9mIG4udmFsdWUsIFwibnVtYmVyXCIpO1xuXG4gICAgICAgIGlmIChuLmV4dHJhICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcHJpbnROdW1iZXIkMihuLmV4dHJhLnJhdyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJpbnROdW1iZXIkMihuLnJhdyk7XG5cbiAgICAgIGNhc2UgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcblxuICAgICAgY2FzZSBcIkRlY2xhcmVUeXBlQWxpYXNcIjpcbiAgICAgIGNhc2UgXCJUeXBlQWxpYXNcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChuLnR5cGUgPT09IFwiRGVjbGFyZVR5cGVBbGlhc1wiIHx8IG4uZGVjbGFyZSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcImRlY2xhcmUgXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByaW50ZWQgPSBwcmludEFzc2lnbm1lbnRSaWdodChuLmlkLCBuLnJpZ2h0LCBwYXRoLmNhbGwocHJpbnQsIFwicmlnaHRcIiksIG9wdGlvbnMpO1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJ0eXBlIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSwgXCIgPVwiLCBwcmludGVkLCBzZW1pKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChwYXJ0cykpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbXCIoXCIsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBwcmludFR5cGVBbm5vdGF0aW9uKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgXCIpXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICAgIGNvbnN0IGNvbW1lbnRTdGFydCA9IHZhbHVlLnJhbmdlID8gb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2UoMCwgdmFsdWUucmFuZ2VbMF0pLmxhc3RJbmRleE9mKFwiLypcIikgOiAtMTsgLy8gQXMgbm90ZWQgaW4gdGhlIFR5cGVDYXN0RXhwcmVzc2lvbiBjb21tZW50cyBhYm92ZSwgd2UncmUgYWJsZSB0byB1c2UgYSBub3JtYWwgd2hpdGVzcGFjZSByZWdleCBoZXJlXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBrbm93IGZvciBzdXJlIHRoYXQgdGhpcyBpcyBhIHR5cGUgZGVmaW5pdGlvbi5cblxuICAgICAgICAgIGNvbnN0IGNvbW1lbnRTeW50YXggPSBjb21tZW50U3RhcnQgPj0gMCAmJiBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShjb21tZW50U3RhcnQpLm1hdGNoKC9eXFwvXFwqXFxzKjo6Lyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudFN5bnRheCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIi8qOjogXCIsIHByaW50VHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIFwicGFyYW1zXCIpLCBcIiAqL1wiXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHByaW50VHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIFwicGFyYW1zXCIpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjpcbiAgICAgICAgcmV0dXJuIHByaW50VHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIFwicGFyYW1zXCIpO1xuXG4gICAgICBjYXNlIFwiVFNUeXBlUGFyYW1ldGVyXCI6XG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlclwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG5cbiAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiVFNNYXBwZWRUeXBlXCIpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJbXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpKTtcblxuICAgICAgICAgICAgaWYgKG4uY29uc3RyYWludCkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiIGluIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiY29uc3RyYWludFwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJdXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IGdldEZsb3dWYXJpYW5jZSQxKG4pO1xuXG4gICAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHZhcmlhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpKTtcblxuICAgICAgICAgIGlmIChuLmJvdW5kKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiOiBcIik7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJib3VuZFwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4uY29uc3RyYWludCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIiBleHRlbmRzIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiY29uc3RyYWludFwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG4uZGVmYXVsdCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIiA9IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZGVmYXVsdFwiKSk7XG4gICAgICAgICAgfSAvLyBLZWVwIGNvbW1hIGlmIHRoZSBmaWxlIGV4dGVuc2lvbiBpcyAudHN4IGFuZFxuICAgICAgICAgIC8vIGhhcyBvbmUgdHlwZSBwYXJhbWV0ZXIgdGhhdCBpc24ndCBleHRlbmQgd2l0aCBhbnkgdHlwZXMuXG4gICAgICAgICAgLy8gQmVjYXVzZSwgb3RoZXJ3aXNlIGZvcm1hdHRlZCByZXN1bHQgd2lsbCBiZSBpbnZhbGlkIGFzIHRzeC5cblxuXG4gICAgICAgICAgY29uc3QgZ3JhbmRQYXJlbnQgPSBwYXRoLmdldE5vZGUoMik7XG5cbiAgICAgICAgICBpZiAocGFyZW50LnBhcmFtcyAmJiBwYXJlbnQucGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBpc1RTWEZpbGUkMShvcHRpb25zKSAmJiAhbi5jb25zdHJhaW50ICYmIGdyYW5kUGFyZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIixcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVHlwZW9mVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcInR5cGVvZiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpXSk7XG5cbiAgICAgIGNhc2UgXCJWb2lkVHlwZUFubm90YXRpb25cIjpcbiAgICAgICAgcmV0dXJuIFwidm9pZFwiO1xuXG4gICAgICBjYXNlIFwiSW5mZXJyZWRQcmVkaWNhdGVcIjpcbiAgICAgICAgcmV0dXJuIFwiJWNoZWNrc1wiO1xuICAgICAgLy8gVW5oYW5kbGVkIHR5cGVzIGJlbG93LiBJZiBlbmNvdW50ZXJlZCwgbm9kZXMgb2YgdGhlc2UgdHlwZXMgc2hvdWxkXG4gICAgICAvLyBiZSBlaXRoZXIgbGVmdCBhbG9uZSBvciBkZXN1Z2FyZWQgaW50byBBU1QgdHlwZXMgdGhhdCBhcmUgZnVsbHlcbiAgICAgIC8vIHN1cHBvcnRlZCBieSB0aGUgcHJldHR5LXByaW50ZXIuXG5cbiAgICAgIGNhc2UgXCJEZWNsYXJlZFByZWRpY2F0ZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiJWNoZWNrcyhcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpLCBcIilcIl0pO1xuXG4gICAgICBjYXNlIFwiVFNBYnN0cmFjdEtleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwiYWJzdHJhY3RcIjtcblxuICAgICAgY2FzZSBcIlRTQW55S2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJhbnlcIjtcblxuICAgICAgY2FzZSBcIlRTQXN5bmNLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcImFzeW5jXCI7XG5cbiAgICAgIGNhc2UgXCJUU0Jvb2xlYW5LZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcblxuICAgICAgY2FzZSBcIlRTQmlnSW50S2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJiaWdpbnRcIjtcblxuICAgICAgY2FzZSBcIlRTQ29uc3RLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcImNvbnN0XCI7XG5cbiAgICAgIGNhc2UgXCJUU0RlY2xhcmVLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcImRlY2xhcmVcIjtcblxuICAgICAgY2FzZSBcIlRTRXhwb3J0S2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJleHBvcnRcIjtcblxuICAgICAgY2FzZSBcIlRTTmV2ZXJLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcIm5ldmVyXCI7XG5cbiAgICAgIGNhc2UgXCJUU051bWJlcktleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG5cbiAgICAgIGNhc2UgXCJUU09iamVjdEtleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG5cbiAgICAgIGNhc2UgXCJUU1Byb3RlY3RlZEtleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwicHJvdGVjdGVkXCI7XG5cbiAgICAgIGNhc2UgXCJUU1ByaXZhdGVLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcInByaXZhdGVcIjtcblxuICAgICAgY2FzZSBcIlRTUHVibGljS2V5d29yZFwiOlxuICAgICAgICByZXR1cm4gXCJwdWJsaWNcIjtcblxuICAgICAgY2FzZSBcIlRTUmVhZG9ubHlLZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcInJlYWRvbmx5XCI7XG5cbiAgICAgIGNhc2UgXCJUU1N5bWJvbEtleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwic3ltYm9sXCI7XG5cbiAgICAgIGNhc2UgXCJUU1N0YXRpY0tleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwic3RhdGljXCI7XG5cbiAgICAgIGNhc2UgXCJUU1N0cmluZ0tleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG5cbiAgICAgIGNhc2UgXCJUU1VuZGVmaW5lZEtleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG5cbiAgICAgIGNhc2UgXCJUU1Vua25vd25LZXl3b3JkXCI6XG4gICAgICAgIHJldHVybiBcInVua25vd25cIjtcblxuICAgICAgY2FzZSBcIlRTVm9pZEtleXdvcmRcIjpcbiAgICAgICAgcmV0dXJuIFwidm9pZFwiO1xuXG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSwgXCIgYXMgXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKV0pO1xuXG4gICAgICBjYXNlIFwiVFNBcnJheVR5cGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwiZWxlbWVudFR5cGVcIiksIFwiW11cIl0pO1xuXG4gICAgICBjYXNlIFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG4uZXhwb3J0KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiZXhwb3J0IFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG4uYWNjZXNzaWJpbGl0eSArIFwiIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobi5zdGF0aWMpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJzdGF0aWMgXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuLnJlYWRvbmx5KSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwicmVhZG9ubHkgXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnRQcm9wZXJ0eUtleShwYXRoLCBvcHRpb25zLCBwcmludCksIHByaW50T3B0aW9uYWxUb2tlbihwYXRoKSk7XG5cbiAgICAgICAgICBpZiAobi50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIjogXCIpO1xuICAgICAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIikpO1xuICAgICAgICAgIH0gLy8gVGhpcyBpc24ndCB2YWxpZCBzZW1hbnRpY2FsbHksIGJ1dCBpdCdzIGluIHRoZSBBU1Qgc28gd2UgY2FuIHByaW50IGl0LlxuXG5cbiAgICAgICAgICBpZiAobi5pbml0aWFsaXplcikge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIiA9IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaW5pdGlhbGl6ZXJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIjpcbiAgICAgICAgaWYgKG4uYWNjZXNzaWJpbGl0eSkge1xuICAgICAgICAgIHBhcnRzLnB1c2gobi5hY2Nlc3NpYmlsaXR5ICsgXCIgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4uZXhwb3J0KSB7XG4gICAgICAgICAgcGFydHMucHVzaChcImV4cG9ydCBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5zdGF0aWMpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwic3RhdGljIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLnJlYWRvbmx5KSB7XG4gICAgICAgICAgcGFydHMucHVzaChcInJlYWRvbmx5IFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInBhcmFtZXRlclwiKSk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJUU1R5cGVSZWZlcmVuY2VcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwidHlwZU5hbWVcIiksIHByaW50VHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIildKTtcblxuICAgICAgY2FzZSBcIlRTVHlwZVF1ZXJ5XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJ0eXBlb2YgXCIsIHBhdGguY2FsbChwcmludCwgXCJleHByTmFtZVwiKV0pO1xuXG4gICAgICBjYXNlIFwiVFNJbmRleFNpZ25hdHVyZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7IC8vIFRoZSB0eXBlc2NyaXB0IHBhcnNlciBhY2NlcHRzIG11bHRpcGxlIHBhcmFtZXRlcnMgaGVyZS4gSWYgeW91J3JlXG4gICAgICAgICAgLy8gdXNpbmcgdGhlbSwgaXQgbWFrZXMgc2Vuc2UgdG8gaGF2ZSBhIHRyYWlsaW5nIGNvbW1hLiBCdXQgaWYgeW91XG4gICAgICAgICAgLy8gYXJlbid0LCB0aGlzIGlzIG1vcmUgbGlrZSBhIGNvbXB1dGVkIHByb3BlcnR5IG5hbWUgdGhhbiBhbiBhcnJheS5cbiAgICAgICAgICAvLyBTbyB3ZSBsZWF2ZSBvZmYgdGhlIHRyYWlsaW5nIGNvbW1hIHdoZW4gdGhlcmUncyBqdXN0IG9uZSBwYXJhbWV0ZXIuXG5cbiAgICAgICAgICBjb25zdCB0cmFpbGluZ0NvbW1hID0gbi5wYXJhbWV0ZXJzLmxlbmd0aCA+IDEgPyBpZkJyZWFrJDYoc2hvdWxkUHJpbnRDb21tYSQxKG9wdGlvbnMpID8gXCIsXCIgOiBcIlwiKSA6IFwiXCI7XG4gICAgICAgICAgY29uc3QgcGFyYW1ldGVyc0dyb3VwID0gZ3JvdXAkYihjb25jYXQkZChbaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIGpvaW4kOShjb25jYXQkZChbXCIsIFwiLCBzb2Z0bGluZSQ2XSksIHBhdGgubWFwKHByaW50LCBcInBhcmFtZXRlcnNcIikpXSkpLCB0cmFpbGluZ0NvbW1hLCBzb2Z0bGluZSQ2XSkpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbbi5leHBvcnQgPyBcImV4cG9ydCBcIiA6IFwiXCIsIG4uYWNjZXNzaWJpbGl0eSA/IGNvbmNhdCRkKFtuLmFjY2Vzc2liaWxpdHksIFwiIFwiXSkgOiBcIlwiLCBuLnN0YXRpYyA/IFwic3RhdGljIFwiIDogXCJcIiwgbi5yZWFkb25seSA/IFwicmVhZG9ubHkgXCIgOiBcIlwiLCBcIltcIiwgbi5wYXJhbWV0ZXJzID8gcGFyYW1ldGVyc0dyb3VwIDogXCJcIiwgbi50eXBlQW5ub3RhdGlvbiA/IFwiXTogXCIgOiBcIl1cIiwgbi50eXBlQW5ub3RhdGlvbiA/IHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSA6IFwiXCIsIHBhcmVudC50eXBlID09PSBcIkNsYXNzQm9keVwiID8gc2VtaSA6IFwiXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiVFNUeXBlUHJlZGljYXRlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbbi5hc3NlcnRzID8gXCJhc3NlcnRzIFwiIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcInBhcmFtZXRlck5hbWVcIiksIG4udHlwZUFubm90YXRpb24gPyBjb25jYXQkZChbXCIgaXMgXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKV0pIDogXCJcIl0pO1xuXG4gICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBcIiFcIl0pO1xuXG4gICAgICBjYXNlIFwiVFNUaGlzVHlwZVwiOlxuICAgICAgICByZXR1cm4gXCJ0aGlzXCI7XG5cbiAgICAgIGNhc2UgXCJUU0ltcG9ydFR5cGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFshbi5pc1R5cGVPZiA/IFwiXCIgOiBcInR5cGVvZiBcIiwgXCJpbXBvcnQoXCIsIHBhdGguY2FsbChwcmludCwgbi5wYXJhbWV0ZXIgPyBcInBhcmFtZXRlclwiIDogXCJhcmd1bWVudFwiKSwgXCIpXCIsICFuLnF1YWxpZmllciA/IFwiXCIgOiBjb25jYXQkZChbXCIuXCIsIHBhdGguY2FsbChwcmludCwgXCJxdWFsaWZpZXJcIildKSwgcHJpbnRUeXBlUGFyYW1ldGVycyhwYXRoLCBvcHRpb25zLCBwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKV0pO1xuXG4gICAgICBjYXNlIFwiVFNMaXRlcmFsVHlwZVwiOlxuICAgICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcImxpdGVyYWxcIik7XG5cbiAgICAgIGNhc2UgXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcIm9iamVjdFR5cGVcIiksIFwiW1wiLCBwYXRoLmNhbGwocHJpbnQsIFwiaW5kZXhUeXBlXCIpLCBcIl1cIl0pO1xuXG4gICAgICBjYXNlIFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiOlxuICAgICAgY2FzZSBcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiVFNDb25zdHJ1Y3RvclR5cGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChuLnR5cGUgIT09IFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIm5ldyBcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaChncm91cCRiKHByaW50RnVuY3Rpb25QYXJhbXMocGF0aCwgcHJpbnQsIG9wdGlvbnMsXG4gICAgICAgICAgLyogZXhwYW5kQXJnICovXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgLyogcHJpbnRUeXBlUGFyYW1zICovXG4gICAgICAgICAgdHJ1ZSkpKTtcblxuICAgICAgICAgIGlmIChuLnJldHVyblR5cGUgfHwgbi50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgaXNUeXBlID0gbi50eXBlID09PSBcIlRTQ29uc3RydWN0b3JUeXBlXCI7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGlzVHlwZSA/IFwiID0+IFwiIDogXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwicmV0dXJuVHlwZVwiKSwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJUU1R5cGVPcGVyYXRvclwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW24ub3BlcmF0b3IsIFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIildKTtcblxuICAgICAgY2FzZSBcIlRTTWFwcGVkVHlwZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkQnJlYWsgPSBoYXNOZXdsaW5lSW5SYW5nZSQzKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY1N0YXJ0KG4pLCBvcHRpb25zLmxvY0VuZChuKSk7XG4gICAgICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBpbmRlbnQkNyhjb25jYXQkZChbb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IGxpbmUkOSA6IHNvZnRsaW5lJDYsIG4ucmVhZG9ubHkgPyBjb25jYXQkZChbZ2V0VHlwZVNjcmlwdE1hcHBlZFR5cGVNb2RpZmllciQxKG4ucmVhZG9ubHksIFwicmVhZG9ubHlcIiksIFwiIFwiXSkgOiBcIlwiLCBwcmludFR5cGVTY3JpcHRNb2RpZmllcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlclwiKSwgbi5vcHRpb25hbCA/IGdldFR5cGVTY3JpcHRNYXBwZWRUeXBlTW9kaWZpZXIkMShuLm9wdGlvbmFsLCBcIj9cIikgOiBcIlwiLCBuLnR5cGVBbm5vdGF0aW9uID8gXCI6IFwiIDogXCJcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpLCBpZkJyZWFrJDYoc2VtaSwgXCJcIildKSksIGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLFxuICAgICAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgICAgICB0cnVlKSwgb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IGxpbmUkOSA6IHNvZnRsaW5lJDYsIFwifVwiXSksIHtcbiAgICAgICAgICAgIHNob3VsZEJyZWFrXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlRTTWV0aG9kU2lnbmF0dXJlXCI6XG4gICAgICAgIHBhcnRzLnB1c2gobi5hY2Nlc3NpYmlsaXR5ID8gY29uY2F0JGQoW24uYWNjZXNzaWJpbGl0eSwgXCIgXCJdKSA6IFwiXCIsIG4uZXhwb3J0ID8gXCJleHBvcnQgXCIgOiBcIlwiLCBuLnN0YXRpYyA/IFwic3RhdGljIFwiIDogXCJcIiwgbi5yZWFkb25seSA/IFwicmVhZG9ubHkgXCIgOiBcIlwiLCBuLmNvbXB1dGVkID8gXCJbXCIgOiBcIlwiLCBwYXRoLmNhbGwocHJpbnQsIFwia2V5XCIpLCBuLmNvbXB1dGVkID8gXCJdXCIgOiBcIlwiLCBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCksIHByaW50RnVuY3Rpb25QYXJhbXMocGF0aCwgcHJpbnQsIG9wdGlvbnMsXG4gICAgICAgIC8qIGV4cGFuZEFyZyAqL1xuICAgICAgICBmYWxzZSxcbiAgICAgICAgLyogcHJpbnRUeXBlUGFyYW1zICovXG4gICAgICAgIHRydWUpKTtcblxuICAgICAgICBpZiAobi5yZXR1cm5UeXBlIHx8IG4udHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInJldHVyblR5cGVcIiksIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChwYXJ0cykpO1xuXG4gICAgICBjYXNlIFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiOlxuICAgICAgICBwYXJ0cy5wdXNoKFwiZXhwb3J0IGFzIG5hbWVzcGFjZSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5zZW1pKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIjtcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChwYXJ0cykpO1xuXG4gICAgICBjYXNlIFwiVFNFbnVtRGVjbGFyYXRpb25cIjpcbiAgICAgICAgaWYgKG4uZGVjbGFyZSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJkZWNsYXJlIFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuLm1vZGlmaWVycykge1xuICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnRUeXBlU2NyaXB0TW9kaWZpZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobi5jb25zdCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJjb25zdCBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKFwiZW51bSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLCBcIiBcIik7XG5cbiAgICAgICAgaWYgKG4ubWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyksIHNvZnRsaW5lJDYsIFwifVwiXSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW1wie1wiLCBpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgcHJpbnRBcnJheUl0ZW1zKHBhdGgsIG9wdGlvbnMsIFwibWVtYmVyc1wiLCBwcmludCksIHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zLCBcImVzNVwiKSA/IFwiLFwiIDogXCJcIl0pKSwgY29tbWVudHMucHJpbnREYW5nbGluZ0NvbW1lbnRzKHBhdGgsIG9wdGlvbnMsXG4gICAgICAgICAgLyogc2FtZUluZGVudCAqL1xuICAgICAgICAgIHRydWUpLCBoYXJkbGluZSQ5LCBcIn1cIl0pKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiVFNFbnVtTWVtYmVyXCI6XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImlkXCIpKTtcblxuICAgICAgICBpZiAobi5pbml0aWFsaXplcikge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImluaXRpYWxpemVyXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG5cbiAgICAgIGNhc2UgXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCI6XG4gICAgICAgIGlmIChuLmlzRXhwb3J0KSB7XG4gICAgICAgICAgcGFydHMucHVzaChcImV4cG9ydCBcIik7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKFwiaW1wb3J0IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksIFwiID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJtb2R1bGVSZWZlcmVuY2VcIikpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNlbWkpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiO1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKHBhcnRzKSk7XG5cbiAgICAgIGNhc2UgXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJyZXF1aXJlKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSwgXCIpXCJdKTtcblxuICAgICAgY2FzZSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IGlzRXh0ZXJuYWxNb2R1bGUgPSBpc0xpdGVyYWwkMShuLmlkKTtcbiAgICAgICAgICBjb25zdCBwYXJlbnRJc0RlY2xhcmF0aW9uID0gcGFyZW50LnR5cGUgPT09IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiO1xuICAgICAgICAgIGNvbnN0IGJvZHlJc0RlY2xhcmF0aW9uID0gbi5ib2R5ICYmIG4uYm9keS50eXBlID09PSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjtcblxuICAgICAgICAgIGlmIChwYXJlbnRJc0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiLlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG4uZGVjbGFyZSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnRUeXBlU2NyaXB0TW9kaWZpZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QmV0d2Vlbk5vZGVBbmRJdHNJZCA9IG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG9wdGlvbnMubG9jU3RhcnQobiksIG9wdGlvbnMubG9jU3RhcnQobi5pZCkpOyAvLyBHbG9iYWwgZGVjbGFyYXRpb24gbG9va3MgbGlrZSB0aGlzOlxuICAgICAgICAgICAgLy8gKGRlY2xhcmUpPyBnbG9iYWwgeyAuLi4gfVxuXG4gICAgICAgICAgICBjb25zdCBpc0dsb2JhbERlY2xhcmF0aW9uID0gbi5pZC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBuLmlkLm5hbWUgPT09IFwiZ2xvYmFsXCIgJiYgIS9uYW1lc3BhY2V8bW9kdWxlLy50ZXN0KHRleHRCZXR3ZWVuTm9kZUFuZEl0c0lkKTtcblxuICAgICAgICAgICAgaWYgKCFpc0dsb2JhbERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goaXNFeHRlcm5hbE1vZHVsZSB8fCAvKF58XFxzKW1vZHVsZShcXHN8JCkvLnRlc3QodGV4dEJldHdlZW5Ob2RlQW5kSXRzSWQpID8gXCJtb2R1bGUgXCIgOiBcIm5hbWVzcGFjZSBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiaWRcIikpO1xuXG4gICAgICAgICAgaWYgKGJvZHlJc0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4uYm9keSkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIiBcIiwgZ3JvdXAkYihwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHNlbWkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcIlByaXZhdGVOYW1lXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCIjXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKV0pO1xuICAgICAgLy8gVE9ETzogVGVtcG9yYXJ5IGF1dG8tZ2VuZXJhdGVkIG5vZGUgdHlwZS4gVG8gcmVtb3ZlIHdoZW4gdHlwZXNjcmlwdC1lc3RyZWUgaGFzIHByb3BlciBzdXBwb3J0IGZvciBwcml2YXRlIGZpZWxkcy5cblxuICAgICAgY2FzZSBcIlRTUHJpdmF0ZUlkZW50aWZpZXJcIjpcbiAgICAgICAgcmV0dXJuIG4uZXNjYXBlZFRleHQ7XG5cbiAgICAgIGNhc2UgXCJUU0NvbmRpdGlvbmFsVHlwZVwiOlxuICAgICAgICByZXR1cm4gcHJpbnRUZXJuYXJ5T3BlcmF0b3IocGF0aCwgb3B0aW9ucywgcHJpbnQsIHtcbiAgICAgICAgICBiZWZvcmVQYXJ0czogKCkgPT4gW3BhdGguY2FsbChwcmludCwgXCJjaGVja1R5cGVcIiksIFwiIFwiLCBcImV4dGVuZHNcIiwgXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJleHRlbmRzVHlwZVwiKV0sXG4gICAgICAgICAgYWZ0ZXJQYXJ0czogKCkgPT4gW10sXG4gICAgICAgICAgc2hvdWxkQ2hlY2tKc3g6IGZhbHNlLFxuICAgICAgICAgIGNvbmRpdGlvbmFsTm9kZVR5cGU6IFwiVFNDb25kaXRpb25hbFR5cGVcIixcbiAgICAgICAgICBjb25zZXF1ZW50Tm9kZVByb3BlcnR5TmFtZTogXCJ0cnVlVHlwZVwiLFxuICAgICAgICAgIGFsdGVybmF0ZU5vZGVQcm9wZXJ0eU5hbWU6IFwiZmFsc2VUeXBlXCIsXG4gICAgICAgICAgdGVzdE5vZGVQcm9wZXJ0eU5hbWVzOiBbXCJjaGVja1R5cGVcIiwgXCJleHRlbmRzVHlwZVwiXVxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSBcIlRTSW5mZXJUeXBlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJpbmZlclwiLCBcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJcIildKTtcblxuICAgICAgY2FzZSBcIkludGVycHJldGVyRGlyZWN0aXZlXCI6XG4gICAgICAgIHBhcnRzLnB1c2goXCIjIVwiLCBuLnZhbHVlLCBoYXJkbGluZSQ5KTtcblxuICAgICAgICBpZiAoaXNOZXh0TGluZUVtcHR5JDQob3B0aW9ucy5vcmlnaW5hbFRleHQsIG4sIG9wdGlvbnMubG9jRW5kKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuXG4gICAgICBjYXNlIFwiTkdSb290XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXS5jb25jYXQocGF0aC5jYWxsKHByaW50LCBcIm5vZGVcIiksICFuLm5vZGUuY29tbWVudHMgfHwgbi5ub2RlLmNvbW1lbnRzLmxlbmd0aCA9PT0gMCA/IFtdIDogY29uY2F0JGQoW1wiIC8vXCIsIG4ubm9kZS5jb21tZW50c1swXS52YWx1ZS50cmltRW5kKCldKSkpO1xuXG4gICAgICBjYXNlIFwiTkdDaGFpbmVkRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gZ3JvdXAkYihqb2luJDkoY29uY2F0JGQoW1wiO1wiLCBsaW5lJDldKSwgcGF0aC5tYXAoY2hpbGRQYXRoID0+IGhhc05nU2lkZUVmZmVjdCQxKGNoaWxkUGF0aCkgPyBwcmludChjaGlsZFBhdGgpIDogY29uY2F0JGQoW1wiKFwiLCBwcmludChjaGlsZFBhdGgpLCBcIilcIl0pLCBcImV4cHJlc3Npb25zXCIpKSk7XG5cbiAgICAgIGNhc2UgXCJOR0VtcHR5RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gXCJcIjtcblxuICAgICAgY2FzZSBcIk5HUXVvdGVkRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW24ucHJlZml4LCBcIjogXCIsIG4udmFsdWUudHJpbSgpXSk7XG5cbiAgICAgIGNhc2UgXCJOR01pY3Jvc3ludGF4XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChwYXRoLm1hcCgoY2hpbGRQYXRoLCBpbmRleCkgPT4gY29uY2F0JGQoW2luZGV4ID09PSAwID8gXCJcIiA6IGlzTmdGb3JPZiQxKGNoaWxkUGF0aC5nZXRWYWx1ZSgpLCBpbmRleCwgbikgPyBcIiBcIiA6IGNvbmNhdCRkKFtcIjtcIiwgbGluZSQ5XSksIHByaW50KGNoaWxkUGF0aCldKSwgXCJib2R5XCIpKTtcblxuICAgICAgY2FzZSBcIk5HTWljcm9zeW50YXhLZXlcIjpcbiAgICAgICAgcmV0dXJuIC9eW2Etel8kXVthLXowLTlfJF0qKC1bYS16XyRdW2EtejAtOV8kXSkqJC9pLnRlc3Qobi5uYW1lKSA/IG4ubmFtZSA6IEpTT04uc3RyaW5naWZ5KG4ubmFtZSk7XG5cbiAgICAgIGNhc2UgXCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW3BhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBuLmFsaWFzID09PSBudWxsID8gXCJcIiA6IGNvbmNhdCRkKFtcIiBhcyBcIiwgcGF0aC5jYWxsKHByaW50LCBcImFsaWFzXCIpXSldKTtcblxuICAgICAgY2FzZSBcIk5HTWljcm9zeW50YXhLZXllZEV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGF0aC5nZXROYW1lKCk7XG4gICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IHNob3VsZE5vdFByaW50Q29sb24gPSBpc05nRm9yT2YkMShuLCBpbmRleCwgcGFyZW50Tm9kZSkgfHwgKGluZGV4ID09PSAxICYmIChuLmtleS5uYW1lID09PSBcInRoZW5cIiB8fCBuLmtleS5uYW1lID09PSBcImVsc2VcIikgfHwgaW5kZXggPT09IDIgJiYgbi5rZXkubmFtZSA9PT0gXCJlbHNlXCIgJiYgcGFyZW50Tm9kZS5ib2R5W2luZGV4IC0gMV0udHlwZSA9PT0gXCJOR01pY3Jvc3ludGF4S2V5ZWRFeHByZXNzaW9uXCIgJiYgcGFyZW50Tm9kZS5ib2R5W2luZGV4IC0gMV0ua2V5Lm5hbWUgPT09IFwidGhlblwiKSAmJiBwYXJlbnROb2RlLmJvZHlbMF0udHlwZSA9PT0gXCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwiO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcImtleVwiKSwgc2hvdWxkTm90UHJpbnRDb2xvbiA/IFwiIFwiIDogXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJOR01pY3Jvc3ludGF4TGV0XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCJsZXQgXCIsIHBhdGguY2FsbChwcmludCwgXCJrZXlcIiksIG4udmFsdWUgPT09IG51bGwgPyBcIlwiIDogY29uY2F0JGQoW1wiID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKV0pXSk7XG5cbiAgICAgIGNhc2UgXCJOR01pY3Jvc3ludGF4QXNcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtwYXRoLmNhbGwocHJpbnQsIFwia2V5XCIpLCBcIiBhcyBcIiwgcGF0aC5jYWxsKHByaW50LCBcImFsaWFzXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJBcmd1bWVudFBsYWNlaG9sZGVyXCI6XG4gICAgICAgIHJldHVybiBcIj9cIjtcbiAgICAgIC8vIFRoZXNlIGFyZSBub3QgdmFsaWQgVHlwZVNjcmlwdC4gUHJpbnRpbmcgdGhlbSBqdXN0IGZvciB0aGUgc2FrZSBvZiBlcnJvciByZWNvdmVyeS5cblxuICAgICAgY2FzZSBcIlRTSlNEb2NBbGxUeXBlXCI6XG4gICAgICAgIHJldHVybiBcIipcIjtcblxuICAgICAgY2FzZSBcIlRTSlNEb2NVbmtub3duVHlwZVwiOlxuICAgICAgICByZXR1cm4gXCI/XCI7XG5cbiAgICAgIGNhc2UgXCJUU0pTRG9jTnVsbGFibGVUeXBlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZChbXCI/XCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKV0pO1xuXG4gICAgICBjYXNlIFwiVFNKU0RvY05vbk51bGxhYmxlVHlwZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiIVwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIildKTtcblxuICAgICAgY2FzZSBcIlRTSlNEb2NGdW5jdGlvblR5cGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcImZ1bmN0aW9uKFwiLCAvLyBUaGUgcGFyYW1ldGVycyBjb3VsZCBiZSBoZXJlLCBidXQgdHlwZXNjcmlwdC1lc3RyZWUgZG9lc24ndCBjb252ZXJ0IHRoZW0gYW55d2F5ICh0aHJvd3MgYW4gZXJyb3IpLlxuICAgICAgICBcIik6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIildKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIEpTT04uc3RyaW5naWZ5KG4udHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50U3RhdGVtZW50U2VxdWVuY2UocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICBjb25zdCBwcmludGVkID0gW107XG4gICAgY29uc3QgYm9keU5vZGUgPSBwYXRoLmdldE5vZGUoKTtcbiAgICBjb25zdCBpc0NsYXNzID0gYm9keU5vZGUudHlwZSA9PT0gXCJDbGFzc0JvZHlcIjtcbiAgICBwYXRoLm1hcCgoc3RtdFBhdGgsIGkpID0+IHtcbiAgICAgIGNvbnN0IHN0bXQgPSBzdG10UGF0aC5nZXRWYWx1ZSgpOyAvLyBKdXN0IGluIGNhc2UgdGhlIEFTVCBoYXMgYmVlbiBtb2RpZmllZCB0byBjb250YWluIGZhbHN5XG4gICAgICAvLyBcInN0YXRlbWVudHMsXCIgaXQncyBzYWZlciBzaW1wbHkgdG8gc2tpcCB0aGVtLlxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgICAgaWYgKCFzdG10KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gU2tpcCBwcmludGluZyBFbXB0eVN0YXRlbWVudCBub2RlcyB0byBhdm9pZCBsZWF2aW5nIHN0cmF5XG4gICAgICAvLyBzZW1pY29sb25zIGx5aW5nIGFyb3VuZC5cblxuXG4gICAgICBpZiAoc3RtdC50eXBlID09PSBcIkVtcHR5U3RhdGVtZW50XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdG10UHJpbnRlZCA9IHByaW50KHN0bXRQYXRoKTtcbiAgICAgIGNvbnN0IHRleHQgPSBvcHRpb25zLm9yaWdpbmFsVGV4dDtcbiAgICAgIGNvbnN0IHBhcnRzID0gW107IC8vIGluIG5vLXNlbWkgbW9kZSwgcHJlcGVuZCBzdGF0ZW1lbnQgd2l0aCBzZW1pY29sb24gaWYgaXQgbWlnaHQgYnJlYWsgQVNJXG4gICAgICAvLyBkb24ndCBwcmVwZW5kIHRoZSBvbmx5IEpTWCBlbGVtZW50IGluIGEgcHJvZ3JhbSB3aXRoIHNlbWljb2xvblxuXG4gICAgICBpZiAoIW9wdGlvbnMuc2VtaSAmJiAhaXNDbGFzcyAmJiAhaXNUaGVPbmx5SlNYRWxlbWVudEluTWFya2Rvd24kMShvcHRpb25zLCBzdG10UGF0aCkgJiYgc3RtdE5lZWRzQVNJUHJvdGVjdGlvbihzdG10UGF0aCwgb3B0aW9ucykpIHtcbiAgICAgICAgaWYgKHN0bXQuY29tbWVudHMgJiYgc3RtdC5jb21tZW50cy5zb21lKGNvbW1lbnQgPT4gY29tbWVudC5sZWFkaW5nKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnQoc3RtdFBhdGgsIHtcbiAgICAgICAgICAgIG5lZWRzU2VtaTogdHJ1ZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiO1wiLCBzdG10UHJpbnRlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2goc3RtdFByaW50ZWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuc2VtaSAmJiBpc0NsYXNzKSB7XG4gICAgICAgIGlmIChjbGFzc1Byb3BNYXlDYXVzZUFTSVByb2JsZW1zJDEoc3RtdFBhdGgpKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIjtcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RtdC50eXBlID09PSBcIkNsYXNzUHJvcGVydHlcIikge1xuICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IGJvZHlOb2RlLmJvZHlbaSArIDFdO1xuXG4gICAgICAgICAgaWYgKGNsYXNzQ2hpbGROZWVkc0FTSVByb3RlY3Rpb24kMShuZXh0Q2hpbGQpKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiO1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTmV4dExpbmVFbXB0eSQ0KHRleHQsIHN0bXQsIG9wdGlvbnMubG9jRW5kKSAmJiAhaXNMYXN0U3RhdGVtZW50JDEoc3RtdFBhdGgpKSB7XG4gICAgICAgIHBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgICB9XG5cbiAgICAgIHByaW50ZWQucHVzaChjb25jYXQkZChwYXJ0cykpO1xuICAgIH0pO1xuICAgIHJldHVybiBqb2luJDkoaGFyZGxpbmUkOSwgcHJpbnRlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFByb3BlcnR5S2V5KHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHJldHVybiBjb25jYXQkZChbXCJbXCIsIHBhdGguY2FsbChwcmludCwgXCJrZXlcIiksIFwiXVwiXSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgY29uc3Qge1xuICAgICAga2V5XG4gICAgfSA9IG5vZGU7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIgJiYgLy8gZmxvdyBoYXMgYElkZW50aWZpZXJgIGtleSwgYW5kIGJhYmVsIGhhcyBgUHJpdmF0ZU5hbWVgIGtleVxuICAgIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIiNcIiwgcGF0aC5jYWxsKHByaW50LCBcImtleVwiKV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnF1b3RlUHJvcHMgPT09IFwiY29uc2lzdGVudFwiICYmICFuZWVkc1F1b3RlUHJvcHMuaGFzKHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG9iamVjdEhhc1N0cmluZ1Byb3AgPSAocGFyZW50LnByb3BlcnRpZXMgfHwgcGFyZW50LmJvZHkgfHwgcGFyZW50Lm1lbWJlcnMpLnNvbWUocHJvcCA9PiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleSAmJiBpc1N0cmluZ0xpdGVyYWwkMShwcm9wLmtleSkgJiYgIWlzU3RyaW5nUHJvcFNhZmVUb0NvZXJjZVRvSWRlbnRpZmllciQxKHByb3AsIG9wdGlvbnMpKTtcbiAgICAgIG5lZWRzUXVvdGVQcm9wcy5zZXQocGFyZW50LCBvYmplY3RIYXNTdHJpbmdQcm9wKTtcbiAgICB9XG5cbiAgICBpZiAoa2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChvcHRpb25zLnBhcnNlciA9PT0gXCJqc29uXCIgfHwgb3B0aW9ucy5xdW90ZVByb3BzID09PSBcImNvbnNpc3RlbnRcIiAmJiBuZWVkc1F1b3RlUHJvcHMuZ2V0KHBhcmVudCkpKSB7XG4gICAgICAvLyBhIC0+IFwiYVwiXG4gICAgICBjb25zdCBwcm9wID0gcHJpbnRTdHJpbmckMihKU09OLnN0cmluZ2lmeShrZXkubmFtZSksIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhdGguY2FsbChrZXlQYXRoID0+IGNvbW1lbnRzLnByaW50Q29tbWVudHMoa2V5UGF0aCwgKCkgPT4gcHJvcCwgb3B0aW9ucyksIFwia2V5XCIpO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZ1Byb3BTYWZlVG9Db2VyY2VUb0lkZW50aWZpZXIkMShub2RlLCBvcHRpb25zKSAmJiAob3B0aW9ucy5xdW90ZVByb3BzID09PSBcImFzLW5lZWRlZFwiIHx8IG9wdGlvbnMucXVvdGVQcm9wcyA9PT0gXCJjb25zaXN0ZW50XCIgJiYgIW5lZWRzUXVvdGVQcm9wcy5nZXQocGFyZW50KSkpIHtcbiAgICAgIC8vICdhJyAtPiBhXG4gICAgICByZXR1cm4gcGF0aC5jYWxsKGtleVBhdGggPT4gY29tbWVudHMucHJpbnRDb21tZW50cyhrZXlQYXRoLCAoKSA9PiBrZXkudmFsdWUsIG9wdGlvbnMpLCBcImtleVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcImtleVwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50TWV0aG9kKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGtpbmRcbiAgICB9ID0gbm9kZTtcbiAgICBjb25zdCB2YWx1ZSA9IG5vZGUudmFsdWUgfHwgbm9kZTtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgaWYgKCFraW5kIHx8IGtpbmQgPT09IFwiaW5pdFwiIHx8IGtpbmQgPT09IFwibWV0aG9kXCIgfHwga2luZCA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICBpZiAodmFsdWUuYXN5bmMpIHtcbiAgICAgICAgcGFydHMucHVzaChcImFzeW5jIFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmdlbmVyYXRvcikge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiKlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0Lm9rKGtpbmQgPT09IFwiZ2V0XCIgfHwga2luZCA9PT0gXCJzZXRcIik7XG4gICAgICBwYXJ0cy5wdXNoKGtpbmQsIFwiIFwiKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKHByaW50UHJvcGVydHlLZXkocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBub2RlLm9wdGlvbmFsIHx8IG5vZGUua2V5Lm9wdGlvbmFsID8gXCI/XCIgOiBcIlwiLCBub2RlID09PSB2YWx1ZSA/IHByaW50TWV0aG9kSW50ZXJuYWwocGF0aCwgb3B0aW9ucywgcHJpbnQpIDogcGF0aC5jYWxsKHBhdGggPT4gcHJpbnRNZXRob2RJbnRlcm5hbChwYXRoLCBvcHRpb25zLCBwcmludCksIFwidmFsdWVcIikpO1xuICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludE1ldGhvZEludGVybmFsKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3QgcGFydHMgPSBbcHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgZ3JvdXAkYihjb25jYXQkZChbcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBwcmludCwgb3B0aW9ucyksIHByaW50UmV0dXJuVHlwZShwYXRoLCBwcmludCwgb3B0aW9ucyldKSldO1xuXG4gICAgaWYgKHBhdGguZ2V0Tm9kZSgpLmJvZHkpIHtcbiAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMucHVzaChvcHRpb25zLnNlbWkgPyBcIjtcIiA6IFwiXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb3VsZEdyb3VwQXJnKGFyZykge1xuICAgIHJldHVybiBhcmcudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIgJiYgKGFyZy5wcm9wZXJ0aWVzLmxlbmd0aCA+IDAgfHwgYXJnLmNvbW1lbnRzKSB8fCBhcmcudHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIiAmJiAoYXJnLmVsZW1lbnRzLmxlbmd0aCA+IDAgfHwgYXJnLmNvbW1lbnRzKSB8fCBhcmcudHlwZSA9PT0gXCJUU1R5cGVBc3NlcnRpb25cIiAmJiBjb3VsZEdyb3VwQXJnKGFyZy5leHByZXNzaW9uKSB8fCBhcmcudHlwZSA9PT0gXCJUU0FzRXhwcmVzc2lvblwiICYmIGNvdWxkR3JvdXBBcmcoYXJnLmV4cHJlc3Npb24pIHx8IGFyZy50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IGFyZy50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgKCAvLyB3ZSB3YW50IHRvIGF2b2lkIGJyZWFraW5nIGluc2lkZSBjb21wb3NpdGUgcmV0dXJuIHR5cGVzIGJ1dCBub3Qgc2ltcGxlIGtleXdvcmRzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ByZXR0aWVyL3ByZXR0aWVyL2lzc3Vlcy80MDcwXG4gICAgLy8gZXhwb3J0IGNsYXNzIFRoaW5nIGltcGxlbWVudHMgT3RoZXJUaGluZyB7XG4gICAgLy8gICBkbzogKHR5cGU6IFR5cGUpID0+IFByb3ZpZGVyPFByb3A+ID0gbWVtb2l6ZShcbiAgICAvLyAgICAgKHR5cGU6IE9iamVjdFR5cGUpOiBQcm92aWRlcjxPcHRzPiA9PiB7fVxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ByZXR0aWVyL3ByZXR0aWVyL2lzc3Vlcy82MDk5XG4gICAgLy8gYXBwLmdldChcIi9cIiwgKHJlcSwgcmVzKTogdm9pZCA9PiB7XG4gICAgLy8gICByZXMuc2VuZChcIkhlbGxvIFdvcmxkIVwiKTtcbiAgICAvLyB9KTtcbiAgICAhYXJnLnJldHVyblR5cGUgfHwgIWFyZy5yZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uIHx8IGFyZy5yZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uLnR5cGUgIT09IFwiVFNUeXBlUmVmZXJlbmNlXCIpICYmIChhcmcuYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgfHwgYXJnLmJvZHkudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIHx8IGFyZy5ib2R5LnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiIHx8IGFyZy5ib2R5LnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIgfHwgYXJnLmJvZHkudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IGFyZy5ib2R5LnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiIHx8IGFyZy5ib2R5LnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgfHwgaXNKU1hOb2RlJDEoYXJnLmJvZHkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEdyb3VwTGFzdEFyZyhhcmdzKSB7XG4gICAgY29uc3QgbGFzdEFyZyA9IGdldExhc3QkMyhhcmdzKTtcbiAgICBjb25zdCBwZW51bHRpbWF0ZUFyZyA9IGdldFBlbnVsdGltYXRlJDEoYXJncyk7XG4gICAgcmV0dXJuICFoYXNMZWFkaW5nQ29tbWVudCQzKGxhc3RBcmcpICYmICFoYXNUcmFpbGluZ0NvbW1lbnQkMShsYXN0QXJnKSAmJiBjb3VsZEdyb3VwQXJnKGxhc3RBcmcpICYmICggLy8gSWYgdGhlIGxhc3QgdHdvIGFyZ3VtZW50cyBhcmUgb2YgdGhlIHNhbWUgdHlwZSxcbiAgICAvLyBkaXNhYmxlIGxhc3QgZWxlbWVudCBleHBhbnNpb24uXG4gICAgIXBlbnVsdGltYXRlQXJnIHx8IHBlbnVsdGltYXRlQXJnLnR5cGUgIT09IGxhc3RBcmcudHlwZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRHcm91cEZpcnN0QXJnKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBbZmlyc3RBcmcsIHNlY29uZEFyZ10gPSBhcmdzO1xuICAgIHJldHVybiAoIWZpcnN0QXJnLmNvbW1lbnRzIHx8ICFmaXJzdEFyZy5jb21tZW50cy5sZW5ndGgpICYmIChmaXJzdEFyZy50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IGZpcnN0QXJnLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBmaXJzdEFyZy5ib2R5LnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikgJiYgc2Vjb25kQXJnLnR5cGUgIT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgc2Vjb25kQXJnLnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBzZWNvbmRBcmcudHlwZSAhPT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiAmJiAhY291bGRHcm91cEFyZyhzZWNvbmRBcmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRKZXN0RWFjaFRlbXBsYXRlTGl0ZXJhbChub2RlLCBleHByZXNzaW9ucywgb3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIGEgICAgfCBiICAgIHwgZXhwZWN0ZWRcbiAgICAgKiAkezF9IHwgJHsxfSB8ICR7Mn1cbiAgICAgKiAkezF9IHwgJHsyfSB8ICR7M31cbiAgICAgKiAkezJ9IHwgJHsxfSB8ICR7M31cbiAgICAgKi9cbiAgICBjb25zdCBoZWFkZXJOYW1lcyA9IG5vZGUucXVhc2lzWzBdLnZhbHVlLnJhdy50cmltKCkuc3BsaXQoL1xccypcXHxcXHMqLyk7XG5cbiAgICBpZiAoaGVhZGVyTmFtZXMubGVuZ3RoID4gMSB8fCBoZWFkZXJOYW1lcy5zb21lKGhlYWRlck5hbWUgPT4gaGVhZGVyTmFtZS5sZW5ndGggIT09IDApKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgY29uc3Qgc3RyaW5naWZpZWRFeHByZXNzaW9ucyA9IGV4cHJlc3Npb25zLm1hcChkb2MgPT4gXCIke1wiICsgcHJpbnREb2NUb1N0cmluZyQyKGRvYywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBwcmludFdpZHRoOiBJbmZpbml0eSxcbiAgICAgICAgZW5kT2ZMaW5lOiBcImxmXCJcbiAgICAgIH0pKS5mb3JtYXR0ZWQgKyBcIn1cIik7XG4gICAgICBjb25zdCB0YWJsZUJvZHkgPSBbe1xuICAgICAgICBoYXNMaW5lQnJlYWs6IGZhbHNlLFxuICAgICAgICBjZWxsczogW11cbiAgICAgIH1dO1xuXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5vZGUucXVhc2lzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlQm9keVt0YWJsZUJvZHkubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGNvcnJlc3BvbmRpbmdFeHByZXNzaW9uID0gc3RyaW5naWZpZWRFeHByZXNzaW9uc1tpIC0gMV07XG4gICAgICAgIHJvdy5jZWxscy5wdXNoKGNvcnJlc3BvbmRpbmdFeHByZXNzaW9uKTtcblxuICAgICAgICBpZiAoY29ycmVzcG9uZGluZ0V4cHJlc3Npb24uaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICByb3cuaGFzTGluZUJyZWFrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLnF1YXNpc1tpXS52YWx1ZS5yYXcuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICB0YWJsZUJvZHkucHVzaCh7XG4gICAgICAgICAgICBoYXNMaW5lQnJlYWs6IGZhbHNlLFxuICAgICAgICAgICAgY2VsbHM6IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbWF4Q29sdW1uQ291bnQgPSBNYXRoLm1heChoZWFkZXJOYW1lcy5sZW5ndGgsIC4uLnRhYmxlQm9keS5tYXAocm93ID0+IHJvdy5jZWxscy5sZW5ndGgpKTtcbiAgICAgIGNvbnN0IG1heENvbHVtbldpZHRocyA9IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IG1heENvbHVtbkNvdW50XG4gICAgICB9KS5maWxsKDApO1xuICAgICAgY29uc3QgdGFibGUgPSBbe1xuICAgICAgICBjZWxsczogaGVhZGVyTmFtZXNcbiAgICAgIH0sIC4uLnRhYmxlQm9keS5maWx0ZXIocm93ID0+IHJvdy5jZWxscy5sZW5ndGggIT09IDApXTtcblxuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGNlbGxzXG4gICAgICB9IG9mIHRhYmxlLmZpbHRlcihyb3cgPT4gIXJvdy5oYXNMaW5lQnJlYWspKSB7XG4gICAgICAgIGNlbGxzLmZvckVhY2goKGNlbGwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgbWF4Q29sdW1uV2lkdGhzW2luZGV4XSA9IE1hdGgubWF4KG1heENvbHVtbldpZHRoc1tpbmRleF0sIGdldFN0cmluZ1dpZHRoJDMoY2VsbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcGFydHMucHVzaChsaW5lU3VmZml4Qm91bmRhcnkkMSwgXCJgXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtoYXJkbGluZSQ5LCBqb2luJDkoaGFyZGxpbmUkOSwgdGFibGUubWFwKHJvdyA9PiBqb2luJDkoXCIgfCBcIiwgcm93LmNlbGxzLm1hcCgoY2VsbCwgaW5kZXgpID0+IHJvdy5oYXNMaW5lQnJlYWsgPyBjZWxsIDogY2VsbCArIFwiIFwiLnJlcGVhdChtYXhDb2x1bW5XaWR0aHNbaW5kZXhdIC0gZ2V0U3RyaW5nV2lkdGgkMyhjZWxsKSkpKSkpXSkpLCBoYXJkbGluZSQ5LCBcImBcIik7XG4gICAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50QXJndW1lbnRzTGlzdChwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgYXJncyA9IG5vZGUuYXJndW1lbnRzO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW1wiKFwiLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyxcbiAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgIHRydWUpLCBcIilcIl0pO1xuICAgIH0gLy8gdXNlRWZmZWN0KCgpID0+IHsgLi4uIH0sIFtmb28sIGJhciwgYmF6XSlcblxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyICYmIGFyZ3NbMF0udHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIGFyZ3NbMF0ucGFyYW1zLmxlbmd0aCA9PT0gMCAmJiBhcmdzWzBdLmJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiICYmIGFyZ3NbMV0udHlwZSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIiAmJiAhYXJncy5maW5kKGFyZyA9PiBhcmcuY29tbWVudHMpKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW1wiKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYXJndW1lbnRzXCIsIDApLCBcIiwgXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudHNcIiwgMSksIFwiKVwiXSk7XG4gICAgfSAvLyBmdW5jKFxuICAgIC8vICAgKHtcbiAgICAvLyAgICAgYSxcbiAgICAvLyAgICAgYlxuICAgIC8vICAgfSkgPT4ge31cbiAgICAvLyApO1xuXG5cbiAgICBmdW5jdGlvbiBzaG91bGRCcmVha0ZvckFycm93RnVuY3Rpb25JbkFyZ3VtZW50cyhhcmcsIGFyZ1BhdGgpIHtcbiAgICAgIGlmICghYXJnIHx8IGFyZy50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgIWFyZy5ib2R5IHx8IGFyZy5ib2R5LnR5cGUgIT09IFwiQmxvY2tTdGF0ZW1lbnRcIiB8fCAhYXJnLnBhcmFtcyB8fCBhcmcucGFyYW1zLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcbiAgICAgIGFyZ1BhdGguZWFjaChwYXJhbVBhdGggPT4ge1xuICAgICAgICBjb25zdCBwcmludGVkID0gY29uY2F0JGQoW3ByaW50KHBhcmFtUGF0aCldKTtcbiAgICAgICAgc2hvdWxkQnJlYWsgPSBzaG91bGRCcmVhayB8fCB3aWxsQnJlYWskMShwcmludGVkKTtcbiAgICAgIH0sIFwicGFyYW1zXCIpO1xuICAgICAgcmV0dXJuIHNob3VsZEJyZWFrO1xuICAgIH1cblxuICAgIGxldCBhbnlBcmdFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICBsZXQgc2hvdWxkQnJlYWtGb3JBcnJvd0Z1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGhhc0VtcHR5TGluZUZvbGxvd2luZ0ZpcnN0QXJnID0gZmFsc2U7XG4gICAgY29uc3QgbGFzdEFyZ0luZGV4ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IHByaW50ZWRBcmd1bWVudHMgPSBwYXRoLm1hcCgoYXJnUGF0aCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ1BhdGguZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgcGFydHMgPSBbcHJpbnQoYXJnUGF0aCldO1xuXG4gICAgICBpZiAoaW5kZXggPT09IGxhc3RBcmdJbmRleCkgOyBlbHNlIGlmIChpc05leHRMaW5lRW1wdHkkNChvcHRpb25zLm9yaWdpbmFsVGV4dCwgYXJnLCBvcHRpb25zLmxvY0VuZCkpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgaGFzRW1wdHlMaW5lRm9sbG93aW5nRmlyc3RBcmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgYW55QXJnRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgcGFydHMucHVzaChcIixcIiwgaGFyZGxpbmUkOSwgaGFyZGxpbmUkOSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiLFwiLCBsaW5lJDkpO1xuICAgICAgfVxuXG4gICAgICBzaG91bGRCcmVha0ZvckFycm93RnVuY3Rpb24gPSBzaG91bGRCcmVha0ZvckFycm93RnVuY3Rpb25JbkFyZ3VtZW50cyhhcmcsIGFyZ1BhdGgpO1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICB9LCBcImFyZ3VtZW50c1wiKTtcbiAgICBjb25zdCBtYXliZVRyYWlsaW5nQ29tbWEgPSAvLyBEeW5hbWljIGltcG9ydHMgY2Fubm90IGhhdmUgdHJhaWxpbmcgY29tbWFzXG4gICAgIShub2RlLmNhbGxlZSAmJiBub2RlLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiKSAmJiBzaG91bGRQcmludENvbW1hJDEob3B0aW9ucywgXCJhbGxcIikgPyBcIixcIiA6IFwiXCI7XG5cbiAgICBmdW5jdGlvbiBhbGxBcmdzQnJva2VuT3V0KCkge1xuICAgICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW1wiKFwiLCBpbmRlbnQkNyhjb25jYXQkZChbbGluZSQ5LCBjb25jYXQkZChwcmludGVkQXJndW1lbnRzKV0pKSwgbWF5YmVUcmFpbGluZ0NvbW1hLCBsaW5lJDksIFwiKVwiXSksIHtcbiAgICAgICAgc2hvdWxkQnJlYWs6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXRoLmdldFBhcmVudE5vZGUoKS50eXBlICE9PSBcIkRlY29yYXRvclwiICYmIGlzRnVuY3Rpb25Db21wb3NpdGlvbkFyZ3MkMShhcmdzKSkge1xuICAgICAgcmV0dXJuIGFsbEFyZ3NCcm9rZW5PdXQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaG91bGRHcm91cEZpcnN0ID0gc2hvdWxkR3JvdXBGaXJzdEFyZyhhcmdzKTtcbiAgICBjb25zdCBzaG91bGRHcm91cExhc3QgPSBzaG91bGRHcm91cExhc3RBcmcoYXJncyk7XG5cbiAgICBpZiAoc2hvdWxkR3JvdXBGaXJzdCB8fCBzaG91bGRHcm91cExhc3QpIHtcbiAgICAgIGNvbnN0IHNob3VsZEJyZWFrID0gKHNob3VsZEdyb3VwRmlyc3QgPyBwcmludGVkQXJndW1lbnRzLnNsaWNlKDEpLnNvbWUod2lsbEJyZWFrJDEpIDogcHJpbnRlZEFyZ3VtZW50cy5zbGljZSgwLCAtMSkuc29tZSh3aWxsQnJlYWskMSkpIHx8IGFueUFyZ0VtcHR5TGluZSB8fCBzaG91bGRCcmVha0ZvckFycm93RnVuY3Rpb247IC8vIFdlIHdhbnQgdG8gcHJpbnQgdGhlIGxhc3QgYXJndW1lbnQgd2l0aCBhIHNwZWNpYWwgZmxhZ1xuXG4gICAgICBsZXQgcHJpbnRlZEV4cGFuZGVkO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgcGF0aC5lYWNoKGFyZ1BhdGggPT4ge1xuICAgICAgICBpZiAoc2hvdWxkR3JvdXBGaXJzdCAmJiBpID09PSAwKSB7XG4gICAgICAgICAgcHJpbnRlZEV4cGFuZGVkID0gW2NvbmNhdCRkKFthcmdQYXRoLmNhbGwocCA9PiBwcmludChwLCB7XG4gICAgICAgICAgICBleHBhbmRGaXJzdEFyZzogdHJ1ZVxuICAgICAgICAgIH0pKSwgcHJpbnRlZEFyZ3VtZW50cy5sZW5ndGggPiAxID8gXCIsXCIgOiBcIlwiLCBoYXNFbXB0eUxpbmVGb2xsb3dpbmdGaXJzdEFyZyA/IGhhcmRsaW5lJDkgOiBsaW5lJDksIGhhc0VtcHR5TGluZUZvbGxvd2luZ0ZpcnN0QXJnID8gaGFyZGxpbmUkOSA6IFwiXCJdKV0uY29uY2F0KHByaW50ZWRBcmd1bWVudHMuc2xpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEdyb3VwTGFzdCAmJiBpID09PSBhcmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBwcmludGVkRXhwYW5kZWQgPSBwcmludGVkQXJndW1lbnRzLnNsaWNlKDAsIC0xKS5jb25jYXQoYXJnUGF0aC5jYWxsKHAgPT4gcHJpbnQocCwge1xuICAgICAgICAgICAgZXhwYW5kTGFzdEFyZzogdHJ1ZVxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICB9LCBcImFyZ3VtZW50c1wiKTtcbiAgICAgIGNvbnN0IHNvbWVQcmludGVkQXJndW1lbnRzV2lsbEJyZWFrID0gcHJpbnRlZEFyZ3VtZW50cy5zb21lKHdpbGxCcmVhayQxKTtcbiAgICAgIGNvbnN0IHNpbXBsZUNvbmNhdCA9IGNvbmNhdCRkKFtcIihcIiwgY29uY2F0JGQocHJpbnRlZEV4cGFuZGVkKSwgXCIpXCJdKTtcbiAgICAgIHJldHVybiBjb25jYXQkZChbc29tZVByaW50ZWRBcmd1bWVudHNXaWxsQnJlYWsgPyBicmVha1BhcmVudCQzIDogXCJcIiwgY29uZGl0aW9uYWxHcm91cCQxKFshc29tZVByaW50ZWRBcmd1bWVudHNXaWxsQnJlYWsgJiYgIW5vZGUudHlwZUFyZ3VtZW50cyAmJiAhbm9kZS50eXBlUGFyYW1ldGVycyA/IHNpbXBsZUNvbmNhdCA6IGlmQnJlYWskNihhbGxBcmdzQnJva2VuT3V0KCksIHNpbXBsZUNvbmNhdCksIHNob3VsZEdyb3VwRmlyc3QgPyBjb25jYXQkZChbXCIoXCIsIGdyb3VwJGIocHJpbnRlZEV4cGFuZGVkWzBdLCB7XG4gICAgICAgIHNob3VsZEJyZWFrOiB0cnVlXG4gICAgICB9KSwgY29uY2F0JGQocHJpbnRlZEV4cGFuZGVkLnNsaWNlKDEpKSwgXCIpXCJdKSA6IGNvbmNhdCRkKFtcIihcIiwgY29uY2F0JGQocHJpbnRlZEFyZ3VtZW50cy5zbGljZSgwLCAtMSkpLCBncm91cCRiKGdldExhc3QkMyhwcmludGVkRXhwYW5kZWQpLCB7XG4gICAgICAgIHNob3VsZEJyZWFrOiB0cnVlXG4gICAgICB9KSwgXCIpXCJdKSwgYWxsQXJnc0Jyb2tlbk91dCgpXSwge1xuICAgICAgICBzaG91bGRCcmVha1xuICAgICAgfSldKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50cyA9IGNvbmNhdCRkKFtcIihcIiwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIGNvbmNhdCRkKHByaW50ZWRBcmd1bWVudHMpXSkpLCBpZkJyZWFrJDYobWF5YmVUcmFpbGluZ0NvbW1hKSwgc29mdGxpbmUkNiwgXCIpXCJdKTtcblxuICAgIGlmIChpc0xvbmdDdXJyaWVkQ2FsbEV4cHJlc3Npb24kMShwYXRoKSkge1xuICAgICAgLy8gQnkgbm90IHdyYXBwaW5nIHRoZSBhcmd1bWVudHMgaW4gYSBncm91cCwgdGhlIHByaW50ZXIgcHJpb3JpdGl6ZXNcbiAgICAgIC8vIGJyZWFraW5nIHVwIHRoZXNlIGFyZ3VtZW50cyByYXRoZXIgdGhhbiB0aGUgYXJncyBvZiB0aGUgcGFyZW50IGNhbGwuXG4gICAgICByZXR1cm4gY29udGVudHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwJGIoY29udGVudHMsIHtcbiAgICAgIHNob3VsZEJyZWFrOiBwcmludGVkQXJndW1lbnRzLnNvbWUod2lsbEJyZWFrJDEpIHx8IGFueUFyZ0VtcHR5TGluZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRUeXBlQW5ub3RhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBpZiAoIW5vZGUudHlwZUFubm90YXRpb24pIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICBjb25zdCBpc0RlZmluaXRlID0gbm9kZS5kZWZpbml0ZSB8fCBwYXJlbnROb2RlICYmIHBhcmVudE5vZGUudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIiAmJiBwYXJlbnROb2RlLmRlZmluaXRlO1xuICAgIGNvbnN0IGlzRnVuY3Rpb25EZWNsYXJhdGlvbklkZW50aWZpZXIgPSBwYXJlbnROb2RlLnR5cGUgPT09IFwiRGVjbGFyZUZ1bmN0aW9uXCIgJiYgcGFyZW50Tm9kZS5pZCA9PT0gbm9kZTtcblxuICAgIGlmIChpc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBub2RlLnR5cGVBbm5vdGF0aW9uLCBvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIiAvKjogXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSwgXCIgKi9cIl0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb25jYXQkZChbaXNGdW5jdGlvbkRlY2xhcmF0aW9uSWRlbnRpZmllciA/IFwiXCIgOiBpc0RlZmluaXRlID8gXCIhOiBcIiA6IFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludEZ1bmN0aW9uVHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICBjb25zdCBmdW4gPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBpZiAoZnVuLnR5cGVBcmd1bWVudHMpIHtcbiAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFyZ3VtZW50c1wiKTtcbiAgICB9XG5cbiAgICBpZiAoZnVuLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBwcmludCwgb3B0aW9ucywgZXhwYW5kQXJnLCBwcmludFR5cGVQYXJhbXMpIHtcbiAgICBjb25zdCBmdW4gPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgY29uc3QgcGFyYW1zRmllbGQgPSBmdW4ucGFyYW1ldGVycyA/IFwicGFyYW1ldGVyc1wiIDogXCJwYXJhbXNcIjtcbiAgICBjb25zdCBpc1BhcmFtZXRlcnNJblRlc3RDYWxsID0gaXNUZXN0Q2FsbCQxKHBhcmVudCk7XG4gICAgY29uc3Qgc2hvdWxkSHVnUGFyYW1ldGVycyA9IHNob3VsZEh1Z0FyZ3VtZW50cyhmdW4pO1xuICAgIGNvbnN0IHNob3VsZEV4cGFuZFBhcmFtZXRlcnMgPSBleHBhbmRBcmcgJiYgIShmdW5bcGFyYW1zRmllbGRdICYmIGZ1bltwYXJhbXNGaWVsZF0uc29tZShuID0+IG4uY29tbWVudHMpKTtcbiAgICBjb25zdCB0eXBlUGFyYW1zID0gcHJpbnRUeXBlUGFyYW1zID8gcHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSA6IFwiXCI7XG4gICAgbGV0IHByaW50ZWQgPSBbXTtcblxuICAgIGlmIChmdW5bcGFyYW1zRmllbGRdKSB7XG4gICAgICBjb25zdCBsYXN0QXJnSW5kZXggPSBmdW5bcGFyYW1zRmllbGRdLmxlbmd0aCAtIDE7XG4gICAgICBwcmludGVkID0gcGF0aC5tYXAoKGNoaWxkUGF0aCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBjaGlsZFBhdGguZ2V0VmFsdWUoKTtcbiAgICAgICAgcGFydHMucHVzaChwcmludChjaGlsZFBhdGgpKTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IGxhc3RBcmdJbmRleCkge1xuICAgICAgICAgIGlmIChmdW4ucmVzdCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIixcIiwgbGluZSQ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQYXJhbWV0ZXJzSW5UZXN0Q2FsbCB8fCBzaG91bGRIdWdQYXJhbWV0ZXJzIHx8IHNob3VsZEV4cGFuZFBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiLCBcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOZXh0TGluZUVtcHR5JDQob3B0aW9ucy5vcmlnaW5hbFRleHQsIHBhcmFtLCBvcHRpb25zLmxvY0VuZCkpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiLFwiLCBoYXJkbGluZSQ5LCBoYXJkbGluZSQ5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiLFwiLCBsaW5lJDkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgICAgIH0sIHBhcmFtc0ZpZWxkKTtcbiAgICB9XG5cbiAgICBpZiAoZnVuLnJlc3QpIHtcbiAgICAgIHByaW50ZWQucHVzaChjb25jYXQkZChbXCIuLi5cIiwgcGF0aC5jYWxsKHByaW50LCBcInJlc3RcIildKSk7XG4gICAgfVxuXG4gICAgaWYgKHByaW50ZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW3R5cGVQYXJhbXMsIFwiKFwiLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyxcbiAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgIHRydWUsIGNvbW1lbnQgPT4gZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlciQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBjb21tZW50LCBvcHRpb25zLmxvY0VuZCkgPT09IFwiKVwiKSwgXCIpXCJdKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0UGFyYW0gPSBnZXRMYXN0JDMoZnVuW3BhcmFtc0ZpZWxkXSk7IC8vIElmIHRoZSBwYXJlbnQgaXMgYSBjYWxsIHdpdGggdGhlIGZpcnN0L2xhc3QgYXJndW1lbnQgZXhwYW5zaW9uIGFuZCB0aGlzIGlzIHRoZVxuICAgIC8vIHBhcmFtcyBvZiB0aGUgZmlyc3QvbGFzdCBhcmd1bWVudCwgd2UgZG9uJ3Qgd2FudCB0aGUgYXJndW1lbnRzIHRvIGJyZWFrIGFuZCBpbnN0ZWFkXG4gICAgLy8gd2FudCB0aGUgd2hvbGUgZXhwcmVzc2lvbiB0byBiZSBvbiBhIG5ldyBsaW5lLlxuICAgIC8vXG4gICAgLy8gR29vZDogICAgICAgICAgICAgICAgIEJhZDpcbiAgICAvLyAgIHZlcnlsb25nY2FsbCggICAgICAgICB2ZXJ5bG9uZ2NhbGwoKFxuICAgIC8vICAgICAoYSwgYikgPT4geyAgICAgICAgICAgYSxcbiAgICAvLyAgICAgfSAgICAgICAgICAgICAgICAgICAgIGIsXG4gICAgLy8gICB9KSAgICAgICAgICAgICAgICAgICAgKSA9PiB7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgIGlmIChzaG91bGRFeHBhbmRQYXJhbWV0ZXJzKSB7XG4gICAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbcmVtb3ZlTGluZXMkMih0eXBlUGFyYW1zKSwgXCIoXCIsIGNvbmNhdCRkKHByaW50ZWQubWFwKHJlbW92ZUxpbmVzJDIpKSwgXCIpXCJdKSk7XG4gICAgfSAvLyBTaW5nbGUgb2JqZWN0IGRlc3RydWN0dXJpbmcgc2hvdWxkIGh1Z1xuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24oe1xuICAgIC8vICAgYSxcbiAgICAvLyAgIGIsXG4gICAgLy8gICBjXG4gICAgLy8gfSkge31cblxuXG4gICAgY29uc3QgaGFzTm90UGFyYW1ldGVyRGVjb3JhdG9yID0gZnVuW3BhcmFtc0ZpZWxkXS5ldmVyeShwYXJhbSA9PiAhcGFyYW0uZGVjb3JhdG9ycyk7XG5cbiAgICBpZiAoc2hvdWxkSHVnUGFyYW1ldGVycyAmJiBoYXNOb3RQYXJhbWV0ZXJEZWNvcmF0b3IpIHtcbiAgICAgIHJldHVybiBjb25jYXQkZChbdHlwZVBhcmFtcywgXCIoXCIsIGNvbmNhdCRkKHByaW50ZWQpLCBcIilcIl0pO1xuICAgIH0gLy8gZG9uJ3QgYnJlYWsgaW4gc3BlY3MsIGVnOyBgaXQoXCJzaG91bGQgbWFpbnRhaW4gcGFyZW5zIGFyb3VuZCBkb25lIGV2ZW4gd2hlbiBsb25nXCIsIChkb25lKSA9PiB7fSlgXG5cblxuICAgIGlmIChpc1BhcmFtZXRlcnNJblRlc3RDYWxsKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW3R5cGVQYXJhbXMsIFwiKFwiLCBjb25jYXQkZChwcmludGVkKSwgXCIpXCJdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0Zsb3dTaG9ydGhhbmRXaXRoT25lQXJnID0gKGlzT2JqZWN0VHlwZVByb3BlcnR5QUZ1bmN0aW9uJDEocGFyZW50LCBvcHRpb25zKSB8fCBpc1R5cGVBbm5vdGF0aW9uQUZ1bmN0aW9uJDEocGFyZW50LCBvcHRpb25zKSB8fCBwYXJlbnQudHlwZSA9PT0gXCJUeXBlQWxpYXNcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNVbmlvblR5cGVcIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudC50eXBlID09PSBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiAmJiBwYXJlbnQucmV0dXJuVHlwZSA9PT0gZnVuKSAmJiBmdW5bcGFyYW1zRmllbGRdLmxlbmd0aCA9PT0gMSAmJiBmdW5bcGFyYW1zRmllbGRdWzBdLm5hbWUgPT09IG51bGwgJiYgZnVuW3BhcmFtc0ZpZWxkXVswXS50eXBlQW5ub3RhdGlvbiAmJiBmdW4udHlwZVBhcmFtZXRlcnMgPT09IG51bGwgJiYgaXNTaW1wbGVGbG93VHlwZSQxKGZ1bltwYXJhbXNGaWVsZF1bMF0udHlwZUFubm90YXRpb24pICYmICFmdW4ucmVzdDtcblxuICAgIGlmIChpc0Zsb3dTaG9ydGhhbmRXaXRoT25lQXJnKSB7XG4gICAgICBpZiAob3B0aW9ucy5hcnJvd1BhcmVucyA9PT0gXCJhbHdheXNcIikge1xuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiKFwiLCBjb25jYXQkZChwcmludGVkKSwgXCIpXCJdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbmNhdCRkKHByaW50ZWQpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbkhhdmVUcmFpbGluZ0NvbW1hID0gIShsYXN0UGFyYW0gJiYgbGFzdFBhcmFtLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikgJiYgIWZ1bi5yZXN0O1xuICAgIHJldHVybiBjb25jYXQkZChbdHlwZVBhcmFtcywgXCIoXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBjb25jYXQkZChwcmludGVkKV0pKSwgaWZCcmVhayQ2KGNhbkhhdmVUcmFpbGluZ0NvbW1hICYmIHNob3VsZFByaW50Q29tbWEkMShvcHRpb25zLCBcImFsbFwiKSA/IFwiLFwiIDogXCJcIiksIHNvZnRsaW5lJDYsIFwiKVwiXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRQcmludFBhcmFtc1dpdGhvdXRQYXJlbnMocGF0aCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmFycm93UGFyZW5zID09PSBcImFsd2F5c1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXJyb3dQYXJlbnMgPT09IFwiYXZvaWRcIikge1xuICAgICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICAgIHJldHVybiBjYW5QcmludFBhcmFtc1dpdGhvdXRQYXJlbnMobm9kZSk7XG4gICAgfSAvLyBGYWxsYmFjayBkZWZhdWx0OyBzaG91bGQgYmUgdW5yZWFjaGFibGVcblxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuUHJpbnRQYXJhbXNXaXRob3V0UGFyZW5zKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmICFub2RlLnJlc3QgJiYgIW5vZGUudHlwZVBhcmFtZXRlcnMgJiYgIWhhc0RhbmdsaW5nQ29tbWVudHMkMShub2RlKSAmJiBub2RlLnBhcmFtc1swXS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhbm9kZS5wYXJhbXNbMF0udHlwZUFubm90YXRpb24gJiYgIW5vZGUucGFyYW1zWzBdLmNvbW1lbnRzICYmICFub2RlLnBhcmFtc1swXS5vcHRpb25hbCAmJiAhbm9kZS5wcmVkaWNhdGUgJiYgIW5vZGUucmV0dXJuVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50RnVuY3Rpb25EZWNsYXJhdGlvbihwYXRoLCBwcmludCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG4gPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcblxuICAgIGlmIChuLmFzeW5jKSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiYXN5bmMgXCIpO1xuICAgIH1cblxuICAgIGlmIChuLmdlbmVyYXRvcikge1xuICAgICAgcGFydHMucHVzaChcImZ1bmN0aW9uKiBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLnB1c2goXCJmdW5jdGlvbiBcIik7XG4gICAgfVxuXG4gICAgaWYgKG4uaWQpIHtcbiAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImlkXCIpKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKHByaW50RnVuY3Rpb25UeXBlUGFyYW1ldGVycyhwYXRoLCBvcHRpb25zLCBwcmludCksIGdyb3VwJGIoY29uY2F0JGQoW3ByaW50RnVuY3Rpb25QYXJhbXMocGF0aCwgcHJpbnQsIG9wdGlvbnMpLCBwcmludFJldHVyblR5cGUocGF0aCwgcHJpbnQsIG9wdGlvbnMpXSkpLCBuLmJvZHkgPyBcIiBcIiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRSZXR1cm5UeXBlKHBhdGgsIHByaW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbiA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCByZXR1cm5UeXBlID0gcGF0aC5jYWxsKHByaW50LCBcInJldHVyblR5cGVcIik7XG5cbiAgICBpZiAobi5yZXR1cm5UeXBlICYmIGlzRmxvd0Fubm90YXRpb25Db21tZW50JDEob3B0aW9ucy5vcmlnaW5hbFRleHQsIG4ucmV0dXJuVHlwZSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBjb25jYXQkZChbXCIgLyo6IFwiLCByZXR1cm5UeXBlLCBcIiAqL1wiXSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSBbcmV0dXJuVHlwZV07IC8vIHByZXBlbmQgY29sb24gdG8gVHlwZVNjcmlwdCB0eXBlIGFubm90YXRpb25cblxuICAgIGlmIChuLnJldHVyblR5cGUgJiYgbi5yZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KFwiOiBcIik7XG4gICAgfVxuXG4gICAgaWYgKG4ucHJlZGljYXRlKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHR5cGUgd2lsbCBhbHJlYWR5IGFkZCB0aGUgY29sb24sIGJ1dCBvdGhlcndpc2Ugd2VcbiAgICAgIC8vIG5lZWQgdG8gZG8gaXQgb3Vyc2VsdmVzXG4gICAgICBwYXJ0cy5wdXNoKG4ucmV0dXJuVHlwZSA/IFwiIFwiIDogXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwicHJlZGljYXRlXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRFeHBvcnREZWNsYXJhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIGNvbnN0IGRlY2wgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3Qgc2VtaSA9IG9wdGlvbnMuc2VtaSA/IFwiO1wiIDogXCJcIjtcbiAgICBjb25zdCBwYXJ0cyA9IFtcImV4cG9ydCBcIl07XG4gICAgY29uc3QgaXNEZWZhdWx0ID0gZGVjbC5kZWZhdWx0IHx8IGRlY2wudHlwZSA9PT0gXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjtcblxuICAgIGlmIChpc0RlZmF1bHQpIHtcbiAgICAgIHBhcnRzLnB1c2goXCJkZWZhdWx0IFwiKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKGNvbW1lbnRzLnByaW50RGFuZ2xpbmdDb21tZW50cyhwYXRoLCBvcHRpb25zLFxuICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICB0cnVlKSk7XG5cbiAgICBpZiAobmVlZHNIYXJkbGluZUFmdGVyRGFuZ2xpbmdDb21tZW50JDEoZGVjbCkpIHtcbiAgICAgIHBhcnRzLnB1c2goaGFyZGxpbmUkOSk7XG4gICAgfVxuXG4gICAgaWYgKGRlY2wuZGVjbGFyYXRpb24pIHtcbiAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImRlY2xhcmF0aW9uXCIpKTtcblxuICAgICAgaWYgKGlzRGVmYXVsdCAmJiBkZWNsLmRlY2xhcmF0aW9uLnR5cGUgIT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiICYmIGRlY2wuZGVjbGFyYXRpb24udHlwZSAhPT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgJiYgZGVjbC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiAmJiBkZWNsLmRlY2xhcmF0aW9uLnR5cGUgIT09IFwiRGVjbGFyZUNsYXNzXCIgJiYgZGVjbC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIkRlY2xhcmVGdW5jdGlvblwiICYmIGRlY2wuZGVjbGFyYXRpb24udHlwZSAhPT0gXCJUU0RlY2xhcmVGdW5jdGlvblwiKSB7XG4gICAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkZWNsLnNwZWNpZmllcnMgJiYgZGVjbC5zcGVjaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc3BlY2lmaWVycyA9IFtdO1xuICAgICAgICBjb25zdCBkZWZhdWx0U3BlY2lmaWVycyA9IFtdO1xuICAgICAgICBjb25zdCBuYW1lc3BhY2VTcGVjaWZpZXJzID0gW107XG4gICAgICAgIHBhdGguZWFjaChzcGVjaWZpZXJQYXRoID0+IHtcbiAgICAgICAgICBjb25zdCBzcGVjaWZpZXJUeXBlID0gcGF0aC5nZXRWYWx1ZSgpLnR5cGU7XG5cbiAgICAgICAgICBpZiAoc3BlY2lmaWVyVHlwZSA9PT0gXCJFeHBvcnRTcGVjaWZpZXJcIikge1xuICAgICAgICAgICAgc3BlY2lmaWVycy5wdXNoKHByaW50KHNwZWNpZmllclBhdGgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpZmllclR5cGUgPT09IFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgICAgICAgICBkZWZhdWx0U3BlY2lmaWVycy5wdXNoKHByaW50KHNwZWNpZmllclBhdGgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpZmllclR5cGUgPT09IFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICAgIG5hbWVzcGFjZVNwZWNpZmllcnMucHVzaChjb25jYXQkZChbXCIqIGFzIFwiLCBwcmludChzcGVjaWZpZXJQYXRoKV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIFwic3BlY2lmaWVyc1wiKTtcbiAgICAgICAgY29uc3QgaXNOYW1lc3BhY2VGb2xsb3dlZCA9IG5hbWVzcGFjZVNwZWNpZmllcnMubGVuZ3RoICE9PSAwICYmIHNwZWNpZmllcnMubGVuZ3RoICE9PSAwO1xuICAgICAgICBjb25zdCBpc0RlZmF1bHRGb2xsb3dlZCA9IGRlZmF1bHRTcGVjaWZpZXJzLmxlbmd0aCAhPT0gMCAmJiAobmFtZXNwYWNlU3BlY2lmaWVycy5sZW5ndGggIT09IDAgfHwgc3BlY2lmaWVycy5sZW5ndGggIT09IDApO1xuICAgICAgICBjb25zdCBjYW5CcmVhayA9IHNwZWNpZmllcnMubGVuZ3RoID4gMSB8fCBkZWZhdWx0U3BlY2lmaWVycy5sZW5ndGggPiAwIHx8IGRlY2wuc3BlY2lmaWVycyAmJiBkZWNsLnNwZWNpZmllcnMuc29tZShub2RlID0+IG5vZGUuY29tbWVudHMpO1xuICAgICAgICBsZXQgcHJpbnRlZCA9IFwiXCI7XG5cbiAgICAgICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGNhbkJyZWFrKSB7XG4gICAgICAgICAgICBwcmludGVkID0gZ3JvdXAkYihjb25jYXQkZChbXCJ7XCIsIGluZGVudCQ3KGNvbmNhdCRkKFtvcHRpb25zLmJyYWNrZXRTcGFjaW5nID8gbGluZSQ5IDogc29mdGxpbmUkNiwgam9pbiQ5KGNvbmNhdCRkKFtcIixcIiwgbGluZSQ5XSksIHNwZWNpZmllcnMpXSkpLCBpZkJyZWFrJDYoc2hvdWxkUHJpbnRDb21tYSQxKG9wdGlvbnMpID8gXCIsXCIgOiBcIlwiKSwgb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IGxpbmUkOSA6IHNvZnRsaW5lJDYsIFwifVwiXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmludGVkID0gY29uY2F0JGQoW1wie1wiLCBvcHRpb25zLmJyYWNrZXRTcGFjaW5nID8gXCIgXCIgOiBcIlwiLCBjb25jYXQkZChzcGVjaWZpZXJzKSwgb3B0aW9ucy5icmFja2V0U3BhY2luZyA/IFwiIFwiIDogXCJcIiwgXCJ9XCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cy5wdXNoKGRlY2wuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIgPyBcInR5cGUgXCIgOiBcIlwiLCBjb25jYXQkZChkZWZhdWx0U3BlY2lmaWVycyksIGNvbmNhdCRkKFtpc0RlZmF1bHRGb2xsb3dlZCA/IFwiLCBcIiA6IFwiXCJdKSwgY29uY2F0JGQobmFtZXNwYWNlU3BlY2lmaWVycyksIGNvbmNhdCRkKFtpc05hbWVzcGFjZUZvbGxvd2VkID8gXCIsIFwiIDogXCJcIl0pLCBwcmludGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJ7fVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlY2wuc291cmNlKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIgZnJvbSBcIiwgcGF0aC5jYWxsKHByaW50LCBcInNvdXJjZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHBhcnRzLnB1c2goc2VtaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmNhdCRkKHBhcnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Rmxvd0RlY2xhcmF0aW9uKHBhdGgsIHBhcnRzKSB7XG4gICAgY29uc3QgcGFyZW50RXhwb3J0RGVjbCA9IGdldFBhcmVudEV4cG9ydERlY2xhcmF0aW9uJDEocGF0aCk7XG5cbiAgICBpZiAocGFyZW50RXhwb3J0RGVjbCkge1xuICAgICAgYXNzZXJ0LnN0cmljdEVxdWFsKHBhcmVudEV4cG9ydERlY2wudHlwZSwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgbm9kZSBoYXMgdHlwZSBEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24sIHRoZW4gaXRcbiAgICAgIC8vIHdpbGwgYmUgcmVzcG9uc2libGUgZm9yIHByaW50aW5nIHRoZSBcImRlY2xhcmVcIiB0b2tlbi4gT3RoZXJ3aXNlXG4gICAgICAvLyBpdCBuZWVkcyB0byBiZSBwcmludGVkIHdpdGggdGhpcyBub24tZXhwb3J0ZWQgZGVjbGFyYXRpb24gbm9kZS5cbiAgICAgIHBhcnRzLnVuc2hpZnQoXCJkZWNsYXJlIFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JGQocGFydHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRUeXBlU2NyaXB0TW9kaWZpZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3QgbiA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmICghbi5tb2RpZmllcnMgfHwgIW4ubW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmNhdCRkKFtqb2luJDkoXCIgXCIsIHBhdGgubWFwKHByaW50LCBcIm1vZGlmaWVyc1wiKSksIFwiIFwiXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFR5cGVQYXJhbWV0ZXJzKHBhdGgsIG9wdGlvbnMsIHByaW50LCBwYXJhbXNLZXkpIHtcbiAgICBjb25zdCBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKCFuW3BhcmFtc0tleV0pIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH0gLy8gZm9yIFR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiB0eXBlUGFyYW1ldGVycyBpcyBhIHNpbmdsZSBub2RlXG5cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShuW3BhcmFtc0tleV0pKSB7XG4gICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBwYXJhbXNLZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IGdyYW5kcGFyZW50ID0gcGF0aC5nZXROb2RlKDIpO1xuICAgIGNvbnN0IGdyZWF0R3JhbmRQYXJlbnQgPSBwYXRoLmdldE5vZGUoMyk7XG4gICAgY29uc3QgZ3JlYXRHcmVhdEdyYW5kUGFyZW50ID0gcGF0aC5nZXROb2RlKDQpO1xuICAgIGNvbnN0IGlzUGFyYW1ldGVySW5UZXN0Q2FsbCA9IGdyYW5kcGFyZW50ICE9IG51bGwgJiYgaXNUZXN0Q2FsbCQxKGdyYW5kcGFyZW50KTtcbiAgICBjb25zdCBzaG91bGRJbmxpbmUgPSBpc1BhcmFtZXRlckluVGVzdENhbGwgfHwgbltwYXJhbXNLZXldLmxlbmd0aCA9PT0gMCB8fCBuW3BhcmFtc0tleV0ubGVuZ3RoID09PSAxICYmIChzaG91bGRIdWdUeXBlKG5bcGFyYW1zS2V5XVswXSkgfHwgbltwYXJhbXNLZXldWzBdLnR5cGUgPT09IFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIgJiYgc2hvdWxkSHVnVHlwZShuW3BhcmFtc0tleV1bMF0uaWQpIHx8IG5bcGFyYW1zS2V5XVswXS50eXBlID09PSBcIlRTVHlwZVJlZmVyZW5jZVwiICYmIHNob3VsZEh1Z1R5cGUobltwYXJhbXNLZXldWzBdLnR5cGVOYW1lKSB8fCBuW3BhcmFtc0tleV1bMF0udHlwZSA9PT0gXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIgfHwgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9wdWxsLzY0NjcgZm9yIHRoZSBjb250ZXh0LlxuICAgIGdyZWF0R3JlYXRHcmFuZFBhcmVudCAmJiBncmVhdEdyZWF0R3JhbmRQYXJlbnQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIiAmJiBncmFuZHBhcmVudC50eXBlID09PSBcIlRTVHlwZUFubm90YXRpb25cIiAmJiBncmVhdEdyYW5kUGFyZW50LnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBuW3BhcmFtc0tleV1bMF0udHlwZSAhPT0gXCJUU1VuaW9uVHlwZVwiICYmIG5bcGFyYW1zS2V5XVswXS50eXBlICE9PSBcIlVuaW9uVHlwZUFubm90YXRpb25cIiAmJiBuW3BhcmFtc0tleV1bMF0udHlwZSAhPT0gXCJUU0ludGVyc2VjdGlvblR5cGVcIiAmJiBuW3BhcmFtc0tleV1bMF0udHlwZSAhPT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiICYmIG5bcGFyYW1zS2V5XVswXS50eXBlICE9PSBcIlRTQ29uZGl0aW9uYWxUeXBlXCIgJiYgbltwYXJhbXNLZXldWzBdLnR5cGUgIT09IFwiVFNNYXBwZWRUeXBlXCIgJiYgbltwYXJhbXNLZXldWzBdLnR5cGUgIT09IFwiVFNUeXBlT3BlcmF0b3JcIiAmJiBuW3BhcmFtc0tleV1bMF0udHlwZSAhPT0gXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIgJiYgbltwYXJhbXNLZXldWzBdLnR5cGUgIT09IFwiVFNBcnJheVR5cGVcIik7XG5cbiAgICBmdW5jdGlvbiBwcmludERhbmdsaW5nQ29tbWVudHNGb3JJbmxpbmUobikge1xuICAgICAgaWYgKCFoYXNEYW5nbGluZ0NvbW1lbnRzJDEobikpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhhc09ubHlCbG9ja0NvbW1lbnRzID0gbi5jb21tZW50cy5ldmVyeShjb21tZW50cyQxLmlzQmxvY2tDb21tZW50KTtcbiAgICAgIGNvbnN0IHByaW50ZWQgPSBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyxcbiAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgIGhhc09ubHlCbG9ja0NvbW1lbnRzKTtcblxuICAgICAgaWYgKGhhc09ubHlCbG9ja0NvbW1lbnRzKSB7XG4gICAgICAgIHJldHVybiBwcmludGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0JGQoW3ByaW50ZWQsIGhhcmRsaW5lJDldKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkSW5saW5lKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW1wiPFwiLCBqb2luJDkoXCIsIFwiLCBwYXRoLm1hcChwcmludCwgcGFyYW1zS2V5KSksIHByaW50RGFuZ2xpbmdDb21tZW50c0ZvcklubGluZShuKSwgXCI+XCJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXAkYihjb25jYXQkZChbXCI8XCIsIGluZGVudCQ3KGNvbmNhdCRkKFtzb2Z0bGluZSQ2LCBqb2luJDkoY29uY2F0JGQoW1wiLFwiLCBsaW5lJDldKSwgcGF0aC5tYXAocHJpbnQsIHBhcmFtc0tleSkpXSkpLCBpZkJyZWFrJDYob3B0aW9ucy5wYXJzZXIgIT09IFwidHlwZXNjcmlwdFwiICYmIG9wdGlvbnMucGFyc2VyICE9PSBcImJhYmVsLXRzXCIgJiYgc2hvdWxkUHJpbnRDb21tYSQxKG9wdGlvbnMsIFwiYWxsXCIpID8gXCIsXCIgOiBcIlwiKSwgc29mdGxpbmUkNiwgXCI+XCJdKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludENsYXNzKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3QgbiA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgaWYgKG4uYWJzdHJhY3QpIHtcbiAgICAgIHBhcnRzLnB1c2goXCJhYnN0cmFjdCBcIik7XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChcImNsYXNzXCIpO1xuXG4gICAgaWYgKG4uaWQpIHtcbiAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSk7XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIikpO1xuICAgIGNvbnN0IHBhcnRzR3JvdXAgPSBbXTtcblxuICAgIGlmIChuLnN1cGVyQ2xhc3MpIHtcbiAgICAgIGNvbnN0IHByaW50ZWQgPSBjb25jYXQkZChbXCJleHRlbmRzIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwic3VwZXJDbGFzc1wiKSwgcGF0aC5jYWxsKHByaW50LCBcInN1cGVyVHlwZVBhcmFtZXRlcnNcIildKTsgLy8gS2VlcCBvbGQgYmVoYXZpb3VyIG9mIGV4dGVuZHMgaW4gc2FtZSBsaW5lXG4gICAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uIGV4dGVuZHMgYW5kIHRoZXJlIGFyZSBub3QgY29tbWVudHNcblxuICAgICAgaWYgKCghbi5pbXBsZW1lbnRzIHx8IG4uaW1wbGVtZW50cy5sZW5ndGggPT09IDApICYmICghbi5zdXBlckNsYXNzLmNvbW1lbnRzIHx8IG4uc3VwZXJDbGFzcy5jb21tZW50cy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHBhcnRzLnB1c2goY29uY2F0JGQoW1wiIFwiLCBwYXRoLmNhbGwoc3VwZXJDbGFzcyA9PiBjb21tZW50cy5wcmludENvbW1lbnRzKHN1cGVyQ2xhc3MsICgpID0+IHByaW50ZWQsIG9wdGlvbnMpLCBcInN1cGVyQ2xhc3NcIildKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0c0dyb3VwLnB1c2goZ3JvdXAkYihjb25jYXQkZChbbGluZSQ5LCBwYXRoLmNhbGwoc3VwZXJDbGFzcyA9PiBjb21tZW50cy5wcmludENvbW1lbnRzKHN1cGVyQ2xhc3MsICgpID0+IHByaW50ZWQsIG9wdGlvbnMpLCBcInN1cGVyQ2xhc3NcIildKSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobi5leHRlbmRzICYmIG4uZXh0ZW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiIGV4dGVuZHMgXCIsIGpvaW4kOShcIiwgXCIsIHBhdGgubWFwKHByaW50LCBcImV4dGVuZHNcIikpKTtcbiAgICB9XG5cbiAgICBpZiAobi5taXhpbnMgJiYgbi5taXhpbnMubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHNHcm91cC5wdXNoKGxpbmUkOSwgXCJtaXhpbnMgXCIsIGdyb3VwJGIoaW5kZW50JDcoam9pbiQ5KGNvbmNhdCRkKFtcIixcIiwgbGluZSQ5XSksIHBhdGgubWFwKHByaW50LCBcIm1peGluc1wiKSkpKSk7XG4gICAgfVxuXG4gICAgaWYgKG4uaW1wbGVtZW50cyAmJiBuLmltcGxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHNHcm91cC5wdXNoKGxpbmUkOSwgXCJpbXBsZW1lbnRzXCIsIGdyb3VwJGIoaW5kZW50JDcoY29uY2F0JGQoW2xpbmUkOSwgam9pbiQ5KGNvbmNhdCRkKFtcIixcIiwgbGluZSQ5XSksIHBhdGgubWFwKHByaW50LCBcImltcGxlbWVudHNcIikpXSkpKSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzR3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHMucHVzaChncm91cCRiKGluZGVudCQ3KGNvbmNhdCRkKHBhcnRzR3JvdXApKSkpO1xuICAgIH1cblxuICAgIGlmIChuLmJvZHkgJiYgbi5ib2R5LmNvbW1lbnRzICYmIGhhc0xlYWRpbmdPd25MaW5lQ29tbWVudCQxKG9wdGlvbnMub3JpZ2luYWxUZXh0LCBuLmJvZHksIG9wdGlvbnMpKSB7XG4gICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJDkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiIFwiKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludE9wdGlvbmFsVG9rZW4ocGF0aCkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG5cbiAgICBpZiAoIW5vZGUub3B0aW9uYWwgfHwgLy8gSXQncyBhbiBvcHRpb25hbCBjb21wdXRlZCBtZXRob2QgcGFyc2VkIGJ5IHR5cGVzY3JpcHQtZXN0cmVlLlxuICAgIC8vIFwiP1wiIGlzIHByaW50ZWQgaW4gYHByaW50TWV0aG9kYC5cbiAgICBub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIG5vZGUgPT09IHBhdGguZ2V0UGFyZW50Tm9kZSgpLmtleSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiICYmIG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgIHJldHVybiBcIj8uXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiP1wiO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRNZW1iZXJMb29rdXAocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHBhdGguY2FsbChwcmludCwgXCJwcm9wZXJ0eVwiKTtcbiAgICBjb25zdCBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IG9wdGlvbmFsID0gcHJpbnRPcHRpb25hbFRva2VuKHBhdGgpO1xuXG4gICAgaWYgKCFuLmNvbXB1dGVkKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW29wdGlvbmFsLCBcIi5cIiwgcHJvcGVydHldKTtcbiAgICB9XG5cbiAgICBpZiAoIW4ucHJvcGVydHkgfHwgaXNOdW1lcmljTGl0ZXJhbCQxKG4ucHJvcGVydHkpKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGQoW29wdGlvbmFsLCBcIltcIiwgcHJvcGVydHksIFwiXVwiXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW29wdGlvbmFsLCBcIltcIiwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHByb3BlcnR5XSkpLCBzb2Z0bGluZSQ2LCBcIl1cIl0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50QmluZEV4cHJlc3Npb25DYWxsZWUocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgICByZXR1cm4gY29uY2F0JGQoW1wiOjpcIiwgcGF0aC5jYWxsKHByaW50LCBcImNhbGxlZVwiKV0pO1xuICB9IC8vIFdlIGRldGVjdCBjYWxscyBvbiBtZW1iZXIgZXhwcmVzc2lvbnMgc3BlY2lhbGx5IHRvIGZvcm1hdCBhXG4gIC8vIGNvbW1vbiBwYXR0ZXJuIGJldHRlci4gVGhlIHBhdHRlcm4gd2UgYXJlIGxvb2tpbmcgZm9yIGlzIHRoaXM6XG4gIC8vXG4gIC8vIGFyclxuICAvLyAgIC5tYXAoeCA9PiB4ICsgMSlcbiAgLy8gICAuZmlsdGVyKHggPT4geCA+IDEwKVxuICAvLyAgIC5zb21lKHggPT4geCAlIDIpXG4gIC8vXG4gIC8vIFRoZSB3YXkgaXQgaXMgc3RydWN0dXJlZCBpbiB0aGUgQVNUIGlzIHZpYSBhIG5lc3RlZCBzZXF1ZW5jZSBvZlxuICAvLyBNZW1iZXJFeHByZXNzaW9uIGFuZCBDYWxsRXhwcmVzc2lvbi4gV2UgbmVlZCB0byB0cmF2ZXJzZSB0aGUgQVNUXG4gIC8vIGFuZCBtYWtlIGdyb3VwcyBvdXQgb2YgaXQgdG8gcHJpbnQgaXQgaW4gdGhlIGRlc2lyZWQgd2F5LlxuXG5cbiAgZnVuY3Rpb24gcHJpbnRNZW1iZXJDaGFpbihwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIC8vIFRoZSBmaXJzdCBwaGFzZSBpcyB0byBsaW5lYXJpemUgdGhlIEFTVCBieSB0cmF2ZXJzaW5nIGl0IGRvd24uXG4gICAgLy9cbiAgICAvLyAgIGEoKS5iKClcbiAgICAvLyBoYXMgdGhlIGZvbGxvd2luZyBBU1Qgc3RydWN0dXJlOlxuICAgIC8vICAgQ2FsbEV4cHJlc3Npb24oTWVtYmVyRXhwcmVzc2lvbihDYWxsRXhwcmVzc2lvbihJZGVudGlmaWVyKSkpXG4gICAgLy8gYW5kIHdlIHRyYW5zZm9ybSBpdCBpbnRvXG4gICAgLy8gICBbSWRlbnRpZmllciwgQ2FsbEV4cHJlc3Npb24sIE1lbWJlckV4cHJlc3Npb24sIENhbGxFeHByZXNzaW9uXVxuICAgIGNvbnN0IHByaW50ZWROb2RlcyA9IFtdOyAvLyBIZXJlIHdlIHRyeSB0byByZXRhaW4gb25lIHR5cGVkIGVtcHR5IGxpbmUgYWZ0ZXIgZWFjaCBjYWxsIGV4cHJlc3Npb24gb3JcbiAgICAvLyB0aGUgZmlyc3QgZ3JvdXAgd2hldGhlciBpdCBpcyBpbiBwYXJlbnRoZXNlcyBvciBub3RcblxuICAgIGZ1bmN0aW9uIHNob3VsZEluc2VydEVtcHR5TGluZUFmdGVyKG5vZGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3JpZ2luYWxUZXh0XG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IG5leHRDaGFySW5kZXggPSBnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXgkMyhvcmlnaW5hbFRleHQsIG5vZGUsIG9wdGlvbnMubG9jRW5kKTtcbiAgICAgIGNvbnN0IG5leHRDaGFyID0gb3JpZ2luYWxUZXh0LmNoYXJBdChuZXh0Q2hhckluZGV4KTsgLy8gaWYgaXQgaXMgY3V0IG9mZiBieSBhIHBhcmVudGhlc2lzLCB3ZSBvbmx5IGFjY291bnQgZm9yIG9uZSB0eXBlZCBlbXB0eVxuICAgICAgLy8gbGluZSBhZnRlciB0aGF0IHBhcmVudGhlc2lzXG5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gXCIpXCIpIHtcbiAgICAgICAgcmV0dXJuIGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXgkMihvcmlnaW5hbFRleHQsIG5leHRDaGFySW5kZXggKyAxLCBvcHRpb25zLmxvY0VuZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpc05leHRMaW5lRW1wdHkkNChvcmlnaW5hbFRleHQsIG5vZGUsIG9wdGlvbnMubG9jRW5kKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWMocGF0aCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgICAgaWYgKChub2RlLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSAmJiAoaXNNZW1iZXJpc2gkMShub2RlLmNhbGxlZSkgfHwgbm9kZS5jYWxsZWUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSkge1xuICAgICAgICBwcmludGVkTm9kZXMudW5zaGlmdCh7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwcmludGVkOiBjb25jYXQkZChbY29tbWVudHMucHJpbnRDb21tZW50cyhwYXRoLCAoKSA9PiBjb25jYXQkZChbcHJpbnRPcHRpb25hbFRva2VuKHBhdGgpLCBwcmludEZ1bmN0aW9uVHlwZVBhcmFtZXRlcnMocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBwcmludEFyZ3VtZW50c0xpc3QocGF0aCwgb3B0aW9ucywgcHJpbnQpXSksIG9wdGlvbnMpLCBzaG91bGRJbnNlcnRFbXB0eUxpbmVBZnRlcihub2RlKSA/IGhhcmRsaW5lJDkgOiBcIlwiXSlcbiAgICAgICAgfSk7XG4gICAgICAgIHBhdGguY2FsbChjYWxsZWUgPT4gcmVjKGNhbGxlZSksIFwiY2FsbGVlXCIpO1xuICAgICAgfSBlbHNlIGlmIChpc01lbWJlcmlzaCQxKG5vZGUpKSB7XG4gICAgICAgIHByaW50ZWROb2Rlcy51bnNoaWZ0KHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIG5lZWRzUGFyZW5zOiBuZWVkc1BhcmVuc18xKHBhdGgsIG9wdGlvbnMpLFxuICAgICAgICAgIHByaW50ZWQ6IGNvbW1lbnRzLnByaW50Q29tbWVudHMocGF0aCwgKCkgPT4gbm9kZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgPyBwcmludE1lbWJlckxvb2t1cChwYXRoLCBvcHRpb25zLCBwcmludCkgOiBwcmludEJpbmRFeHByZXNzaW9uQ2FsbGVlKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgb3B0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIHBhdGguY2FsbChvYmplY3QgPT4gcmVjKG9iamVjdCksIFwib2JqZWN0XCIpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiVFNOb25OdWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHByaW50ZWROb2Rlcy51bnNoaWZ0KHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHByaW50ZWQ6IGNvbW1lbnRzLnByaW50Q29tbWVudHMocGF0aCwgKCkgPT4gXCIhXCIsIG9wdGlvbnMpXG4gICAgICAgIH0pO1xuICAgICAgICBwYXRoLmNhbGwoZXhwcmVzc2lvbiA9PiByZWMoZXhwcmVzc2lvbiksIFwiZXhwcmVzc2lvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW50ZWROb2Rlcy51bnNoaWZ0KHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIHByaW50ZWQ6IHBhdGguY2FsbChwcmludClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBOb3RlOiB0aGUgY29tbWVudHMgb2YgdGhlIHJvb3Qgbm9kZSBoYXZlIGFscmVhZHkgYmVlbiBwcmludGVkLCBzbyB3ZVxuICAgIC8vIG5lZWQgdG8gZXh0cmFjdCB0aGlzIGZpcnN0IGNhbGwgd2l0aG91dCBwcmludGluZyB0aGVtIGFzIHRoZXkgd291bGRcbiAgICAvLyBpZiBoYW5kbGVkIGluc2lkZSBvZiB0aGUgcmVjdXJzaXZlIGNhbGwuXG5cblxuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgcHJpbnRlZE5vZGVzLnVuc2hpZnQoe1xuICAgICAgbm9kZSxcbiAgICAgIHByaW50ZWQ6IGNvbmNhdCRkKFtwcmludE9wdGlvbmFsVG9rZW4ocGF0aCksIHByaW50RnVuY3Rpb25UeXBlUGFyYW1ldGVycyhwYXRoLCBvcHRpb25zLCBwcmludCksIHByaW50QXJndW1lbnRzTGlzdChwYXRoLCBvcHRpb25zLCBwcmludCldKVxuICAgIH0pO1xuICAgIHBhdGguY2FsbChjYWxsZWUgPT4gcmVjKGNhbGxlZSksIFwiY2FsbGVlXCIpOyAvLyBPbmNlIHdlIGhhdmUgYSBsaW5lYXIgbGlzdCBvZiBwcmludGVkIG5vZGVzLCB3ZSB3YW50IHRvIGNyZWF0ZSBncm91cHMgb3V0XG4gICAgLy8gb2YgaXQuXG4gICAgLy9cbiAgICAvLyAgIGEoKS5iLmMoKS5kKCkuZVxuICAgIC8vIHdpbGwgYmUgZ3JvdXBlZCBhc1xuICAgIC8vICAgW1xuICAgIC8vICAgICBbSWRlbnRpZmllciwgQ2FsbEV4cHJlc3Npb25dLFxuICAgIC8vICAgICBbTWVtYmVyRXhwcmVzc2lvbiwgTWVtYmVyRXhwcmVzc2lvbiwgQ2FsbEV4cHJlc3Npb25dLFxuICAgIC8vICAgICBbTWVtYmVyRXhwcmVzc2lvbiwgQ2FsbEV4cHJlc3Npb25dLFxuICAgIC8vICAgICBbTWVtYmVyRXhwcmVzc2lvbl0sXG4gICAgLy8gICBdXG4gICAgLy8gc28gdGhhdCB3ZSBjYW4gcHJpbnQgaXQgYXNcbiAgICAvLyAgIGEoKVxuICAgIC8vICAgICAuYi5jKClcbiAgICAvLyAgICAgLmQoKVxuICAgIC8vICAgICAuZVxuICAgIC8vIFRoZSBmaXJzdCBncm91cCBpcyB0aGUgZmlyc3Qgbm9kZSBmb2xsb3dlZCBieVxuICAgIC8vICAgLSBhcyBtYW55IENhbGxFeHByZXNzaW9uIGFzIHBvc3NpYmxlXG4gICAgLy8gICAgICAgPCBmbigpKCkoKSA+LnNvbWV0aGluZygpXG4gICAgLy8gICAtIGFzIG1hbnkgYXJyYXkgYWNjZXNzb3JzIGFzIHBvc3NpYmxlXG4gICAgLy8gICAgICAgPCBmbigpWzBdWzFdWzJdID4uc29tZXRoaW5nKClcbiAgICAvLyAgIC0gdGhlbiwgYXMgbWFueSBNZW1iZXJFeHByZXNzaW9uIGFzIHBvc3NpYmxlIGJ1dCB0aGUgbGFzdCBvbmVcbiAgICAvLyAgICAgICA8IHRoaXMuaXRlbXMgPi5zb21ldGhpbmcoKVxuXG4gICAgY29uc3QgZ3JvdXBzID0gW107XG4gICAgbGV0IGN1cnJlbnRHcm91cCA9IFtwcmludGVkTm9kZXNbMF1dO1xuICAgIGxldCBpID0gMTtcblxuICAgIGZvciAoOyBpIDwgcHJpbnRlZE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAocHJpbnRlZE5vZGVzW2ldLm5vZGUudHlwZSA9PT0gXCJUU05vbk51bGxFeHByZXNzaW9uXCIgfHwgcHJpbnRlZE5vZGVzW2ldLm5vZGUudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIgfHwgcHJpbnRlZE5vZGVzW2ldLm5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiIHx8IChwcmludGVkTm9kZXNbaV0ubm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBwcmludGVkTm9kZXNbaV0ubm9kZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSAmJiBwcmludGVkTm9kZXNbaV0ubm9kZS5jb21wdXRlZCAmJiBpc051bWVyaWNMaXRlcmFsJDEocHJpbnRlZE5vZGVzW2ldLm5vZGUucHJvcGVydHkpKSB7XG4gICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKHByaW50ZWROb2Rlc1tpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJpbnRlZE5vZGVzWzBdLm5vZGUudHlwZSAhPT0gXCJDYWxsRXhwcmVzc2lvblwiICYmIHByaW50ZWROb2Rlc1swXS5ub2RlLnR5cGUgIT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICBmb3IgKDsgaSArIDEgPCBwcmludGVkTm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGlzTWVtYmVyaXNoJDEocHJpbnRlZE5vZGVzW2ldLm5vZGUpICYmIGlzTWVtYmVyaXNoJDEocHJpbnRlZE5vZGVzW2kgKyAxXS5ub2RlKSkge1xuICAgICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKHByaW50ZWROb2Rlc1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgIGN1cnJlbnRHcm91cCA9IFtdOyAvLyBUaGVuLCBlYWNoIGZvbGxvd2luZyBncm91cCBpcyBhIHNlcXVlbmNlIG9mIE1lbWJlckV4cHJlc3Npb24gZm9sbG93ZWQgYnlcbiAgICAvLyBhIHNlcXVlbmNlIG9mIENhbGxFeHByZXNzaW9uLiBUbyBjb21wdXRlIGl0LCB3ZSBrZWVwIGFkZGluZyB0aGluZ3MgdG8gdGhlXG4gICAgLy8gZ3JvdXAgdW50aWwgd2UgaGFzIHNlZW4gYSBDYWxsRXhwcmVzc2lvbiBpbiB0aGUgcGFzdCBhbmQgcmVhY2ggYVxuICAgIC8vIE1lbWJlckV4cHJlc3Npb25cblxuICAgIGxldCBoYXNTZWVuQ2FsbEV4cHJlc3Npb24gPSBmYWxzZTtcblxuICAgIGZvciAoOyBpIDwgcHJpbnRlZE5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoaGFzU2VlbkNhbGxFeHByZXNzaW9uICYmIGlzTWVtYmVyaXNoJDEocHJpbnRlZE5vZGVzW2ldLm5vZGUpKSB7XG4gICAgICAgIC8vIFswXSBzaG91bGQgYmUgYXBwZW5kZWQgYXQgdGhlIGVuZCBvZiB0aGUgZ3JvdXAgaW5zdGVhZCBvZiB0aGVcbiAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBuZXh0IG9uZVxuICAgICAgICBpZiAocHJpbnRlZE5vZGVzW2ldLm5vZGUuY29tcHV0ZWQgJiYgaXNOdW1lcmljTGl0ZXJhbCQxKHByaW50ZWROb2Rlc1tpXS5ub2RlLnByb3BlcnR5KSkge1xuICAgICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKHByaW50ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBncm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgICAgICBjdXJyZW50R3JvdXAgPSBbXTtcbiAgICAgICAgaGFzU2VlbkNhbGxFeHByZXNzaW9uID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmludGVkTm9kZXNbaV0ubm9kZS50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgcHJpbnRlZE5vZGVzW2ldLm5vZGUudHlwZSA9PT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaGFzU2VlbkNhbGxFeHByZXNzaW9uID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudEdyb3VwLnB1c2gocHJpbnRlZE5vZGVzW2ldKTtcblxuICAgICAgaWYgKHByaW50ZWROb2Rlc1tpXS5ub2RlLmNvbW1lbnRzICYmIHByaW50ZWROb2Rlc1tpXS5ub2RlLmNvbW1lbnRzLnNvbWUoY29tbWVudCA9PiBjb21tZW50LnRyYWlsaW5nKSkge1xuICAgICAgICBncm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgICAgICBjdXJyZW50R3JvdXAgPSBbXTtcbiAgICAgICAgaGFzU2VlbkNhbGxFeHByZXNzaW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRHcm91cC5sZW5ndGggPiAwKSB7XG4gICAgICBncm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgIH0gLy8gVGhlcmUgYXJlIGNhc2VzIGxpa2UgT2JqZWN0LmtleXMoKSwgT2JzZXJ2YWJsZS5vZigpLCBfLnZhbHVlcygpIHdoZXJlXG4gICAgLy8gdGhleSBhcmUgdGhlIHN1YmplY3Qgb2YgYWxsIHRoZSBjaGFpbmVkIGNhbGxzIGFuZCB0aGVyZWZvcmUgc2hvdWxkXG4gICAgLy8gYmUga2VwdCBvbiB0aGUgc2FtZSBsaW5lOlxuICAgIC8vXG4gICAgLy8gICBPYmplY3Qua2V5cyhpdGVtcylcbiAgICAvLyAgICAgLmZpbHRlcih4ID0+IHgpXG4gICAgLy8gICAgIC5tYXAoeCA9PiB4KVxuICAgIC8vXG4gICAgLy8gSW4gb3JkZXIgdG8gZGV0ZWN0IHRob3NlIGNhc2VzLCB3ZSB1c2UgYW4gaGV1cmlzdGljOiBpZiB0aGUgZmlyc3RcbiAgICAvLyBub2RlIGlzIGFuIGlkZW50aWZpZXIgd2l0aCB0aGUgbmFtZSBzdGFydGluZyB3aXRoIGEgY2FwaXRhbFxuICAgIC8vIGxldHRlciBvciBqdXN0IGEgc2VxdWVuY2Ugb2YgXyQuIFRoZSByYXRpb25hbGUgaXMgdGhhdCB0aGV5IGFyZVxuICAgIC8vIGxpa2VseSB0byBiZSBmYWN0b3JpZXMuXG5cblxuICAgIGZ1bmN0aW9uIGlzRmFjdG9yeShuYW1lKSB7XG4gICAgICByZXR1cm4gL15bQS1aXXxeW18kXSskLy50ZXN0KG5hbWUpO1xuICAgIH0gLy8gSW4gY2FzZSB0aGUgSWRlbnRpZmllciBpcyBzaG9ydGVyIHRoYW4gdGFiIHdpZHRoLCB3ZSBjYW4ga2VlcCB0aGVcbiAgICAvLyBmaXJzdCBjYWxsIGluIGEgc2luZ2xlIGxpbmUsIGlmIGl0J3MgYW4gRXhwcmVzc2lvblN0YXRlbWVudC5cbiAgICAvL1xuICAgIC8vICAgZDMuc2NhbGVMaW5lYXIoKVxuICAgIC8vICAgICAuZG9tYWluKFswLCAxMDBdKVxuICAgIC8vICAgICAucmFuZ2UoWzAsIHdpZHRoXSk7XG4gICAgLy9cblxuXG4gICAgZnVuY3Rpb24gaXNTaG9ydChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZS5sZW5ndGggPD0gb3B0aW9ucy50YWJXaWR0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGROb3RXcmFwKGdyb3Vwcykge1xuICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICBjb25zdCBpc0V4cHJlc3Npb24gPSBwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiO1xuICAgICAgY29uc3QgaGFzQ29tcHV0ZWQgPSBncm91cHNbMV0ubGVuZ3RoICYmIGdyb3Vwc1sxXVswXS5ub2RlLmNvbXB1dGVkO1xuXG4gICAgICBpZiAoZ3JvdXBzWzBdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSBncm91cHNbMF1bMF0ubm9kZTtcbiAgICAgICAgcmV0dXJuIGZpcnN0Tm9kZS50eXBlID09PSBcIlRoaXNFeHByZXNzaW9uXCIgfHwgZmlyc3ROb2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChpc0ZhY3RvcnkoZmlyc3ROb2RlLm5hbWUpIHx8IGlzRXhwcmVzc2lvbiAmJiBpc1Nob3J0KGZpcnN0Tm9kZS5uYW1lKSB8fCBoYXNDb21wdXRlZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhc3ROb2RlID0gZ2V0TGFzdCQzKGdyb3Vwc1swXSkubm9kZTtcbiAgICAgIHJldHVybiAobGFzdE5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgbGFzdE5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikgJiYgbGFzdE5vZGUucHJvcGVydHkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgKGlzRmFjdG9yeShsYXN0Tm9kZS5wcm9wZXJ0eS5uYW1lKSB8fCBoYXNDb21wdXRlZCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2hvdWxkTWVyZ2UgPSBncm91cHMubGVuZ3RoID49IDIgJiYgIWdyb3Vwc1sxXVswXS5ub2RlLmNvbW1lbnRzICYmIHNob3VsZE5vdFdyYXAoZ3JvdXBzKTtcblxuICAgIGZ1bmN0aW9uIHByaW50R3JvdXAocHJpbnRlZEdyb3VwKSB7XG4gICAgICBjb25zdCBwcmludGVkID0gcHJpbnRlZEdyb3VwLm1hcCh0dXBsZSA9PiB0dXBsZS5wcmludGVkKTsgLy8gQ2hlY2tzIGlmIHRoZSBsYXN0IG5vZGUgKGkuZS4gdGhlIHBhcmVudCBub2RlKSBuZWVkcyBwYXJlbnMgYW5kIHByaW50XG4gICAgICAvLyBhY2NvcmRpbmdseVxuXG4gICAgICBpZiAocHJpbnRlZEdyb3VwLmxlbmd0aCA+IDAgJiYgcHJpbnRlZEdyb3VwW3ByaW50ZWRHcm91cC5sZW5ndGggLSAxXS5uZWVkc1BhcmVucykge1xuICAgICAgICByZXR1cm4gY29uY2F0JGQoW1wiKFwiLCAuLi5wcmludGVkLCBcIilcIl0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uY2F0JGQocHJpbnRlZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJpbnRJbmRlbnRlZEdyb3VwKGdyb3Vwcykge1xuICAgICAgaWYgKGdyb3Vwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRlbnQkNyhncm91cCRiKGNvbmNhdCRkKFtoYXJkbGluZSQ5LCBqb2luJDkoaGFyZGxpbmUkOSwgZ3JvdXBzLm1hcChwcmludEdyb3VwKSldKSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHByaW50ZWRHcm91cHMgPSBncm91cHMubWFwKHByaW50R3JvdXApO1xuICAgIGNvbnN0IG9uZUxpbmUgPSBjb25jYXQkZChwcmludGVkR3JvdXBzKTtcbiAgICBjb25zdCBjdXRvZmYgPSBzaG91bGRNZXJnZSA/IDMgOiAyO1xuICAgIGNvbnN0IGZsYXRHcm91cHMgPSBncm91cHMucmVkdWNlKChyZXMsIGdyb3VwKSA9PiByZXMuY29uY2F0KGdyb3VwKSwgW10pO1xuICAgIGNvbnN0IGhhc0NvbW1lbnQgPSBmbGF0R3JvdXBzLnNsaWNlKDEsIC0xKS5zb21lKG5vZGUgPT4gaGFzTGVhZGluZ0NvbW1lbnQkMyhub2RlLm5vZGUpKSB8fCBmbGF0R3JvdXBzLnNsaWNlKDAsIC0xKS5zb21lKG5vZGUgPT4gaGFzVHJhaWxpbmdDb21tZW50JDEobm9kZS5ub2RlKSkgfHwgZ3JvdXBzW2N1dG9mZl0gJiYgaGFzTGVhZGluZ0NvbW1lbnQkMyhncm91cHNbY3V0b2ZmXVswXS5ub2RlKTsgLy8gSWYgd2Ugb25seSBoYXZlIGEgc2luZ2xlIGAuYCwgd2Ugc2hvdWxkbid0IGRvIGFueXRoaW5nIGZhbmN5IGFuZCBqdXN0XG4gICAgLy8gcmVuZGVyIGV2ZXJ5dGhpbmcgY29uY2F0ZW5hdGVkIHRvZ2V0aGVyLlxuXG4gICAgaWYgKGdyb3Vwcy5sZW5ndGggPD0gY3V0b2ZmICYmICFoYXNDb21tZW50KSB7XG4gICAgICBpZiAoaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uJDEocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIG9uZUxpbmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cCRiKG9uZUxpbmUpO1xuICAgIH0gLy8gRmluZCBvdXQgdGhlIGxhc3Qgbm9kZSBpbiB0aGUgZmlyc3QgZ3JvdXAgYW5kIGNoZWNrIGlmIGl0IGhhcyBhblxuICAgIC8vIGVtcHR5IGxpbmUgYWZ0ZXJcblxuXG4gICAgY29uc3QgbGFzdE5vZGVCZWZvcmVJbmRlbnQgPSBnZXRMYXN0JDMoc2hvdWxkTWVyZ2UgPyBncm91cHMuc2xpY2UoMSwgMilbMF0gOiBncm91cHNbMF0pLm5vZGU7XG4gICAgY29uc3Qgc2hvdWxkSGF2ZUVtcHR5TGluZUJlZm9yZUluZGVudCA9IGxhc3ROb2RlQmVmb3JlSW5kZW50LnR5cGUgIT09IFwiQ2FsbEV4cHJlc3Npb25cIiAmJiBsYXN0Tm9kZUJlZm9yZUluZGVudC50eXBlICE9PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiAmJiBzaG91bGRJbnNlcnRFbXB0eUxpbmVBZnRlcihsYXN0Tm9kZUJlZm9yZUluZGVudCk7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBjb25jYXQkZChbcHJpbnRHcm91cChncm91cHNbMF0pLCBzaG91bGRNZXJnZSA/IGNvbmNhdCRkKGdyb3Vwcy5zbGljZSgxLCAyKS5tYXAocHJpbnRHcm91cCkpIDogXCJcIiwgc2hvdWxkSGF2ZUVtcHR5TGluZUJlZm9yZUluZGVudCA/IGhhcmRsaW5lJDkgOiBcIlwiLCBwcmludEluZGVudGVkR3JvdXAoZ3JvdXBzLnNsaWNlKHNob3VsZE1lcmdlID8gMiA6IDEpKV0pO1xuICAgIGNvbnN0IGNhbGxFeHByZXNzaW9ucyA9IHByaW50ZWROb2Rlcy5tYXAoKHtcbiAgICAgIG5vZGVcbiAgICB9KSA9PiBub2RlKS5maWx0ZXIoaXNDYWxsT3JPcHRpb25hbENhbGxFeHByZXNzaW9uJDEpOyAvLyBXZSBkb24ndCB3YW50IHRvIHByaW50IGluIG9uZSBsaW5lIGlmIHRoZSBjaGFpbiBoYXM6XG4gICAgLy8gICogQSBjb21tZW50LlxuICAgIC8vICAqIE5vbi10cml2aWFsIGFyZ3VtZW50cy5cbiAgICAvLyAgKiBBbnkgZ3JvdXAgYnV0IHRoZSBsYXN0IG9uZSBoYXMgYSBoYXJkIGxpbmUuXG4gICAgLy8gSWYgdGhlIGxhc3QgZ3JvdXAgaXMgYSBmdW5jdGlvbiBpdCdzIG9rYXkgdG8gaW5saW5lIGlmIGl0IGZpdHMuXG5cbiAgICBpZiAoaGFzQ29tbWVudCB8fCBjYWxsRXhwcmVzc2lvbnMubGVuZ3RoID4gMiAmJiBjYWxsRXhwcmVzc2lvbnMuc29tZShleHByID0+ICFleHByLmFyZ3VtZW50cy5ldmVyeShhcmcgPT4gaXNTaW1wbGVDYWxsQXJndW1lbnQkMShhcmcsIDApKSkgfHwgcHJpbnRlZEdyb3Vwcy5zbGljZSgwLCAtMSkuc29tZSh3aWxsQnJlYWskMSkgfHxcbiAgICAvKipcbiAgICAgKiAgICAgc2NvcGVzLmZpbHRlcihzY29wZSA9PiBzY29wZS52YWx1ZSAhPT0gJycpLm1hcCgoc2NvcGUsIGkpID0+IHtcbiAgICAgKiAgICAgICAvLyBtdWx0aSBsaW5lIGNvbnRlbnRcbiAgICAgKiAgICAgfSlcbiAgICAgKi9cbiAgICAoKGxhc3RHcm91cERvYywgbGFzdEdyb3VwTm9kZSkgPT4gaXNDYWxsT3JPcHRpb25hbENhbGxFeHByZXNzaW9uJDEobGFzdEdyb3VwTm9kZSkgJiYgd2lsbEJyZWFrJDEobGFzdEdyb3VwRG9jKSkoZ2V0TGFzdCQzKHByaW50ZWRHcm91cHMpLCBnZXRMYXN0JDMoZ2V0TGFzdCQzKGdyb3VwcykpLm5vZGUpICYmIGNhbGxFeHByZXNzaW9ucy5zbGljZSgwLCAtMSkuc29tZShuID0+IG4uYXJndW1lbnRzLnNvbWUoaXNGdW5jdGlvbk9yQXJyb3dFeHByZXNzaW9uJDEpKSkge1xuICAgICAgcmV0dXJuIGdyb3VwJGIoZXhwYW5kZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBjb25jYXQkZChbLy8gV2Ugb25seSBuZWVkIHRvIGNoZWNrIGBvbmVMaW5lYCBiZWNhdXNlIGlmIGBleHBhbmRlZGAgaXMgY2hvc2VuXG4gICAgLy8gdGhhdCBtZWFucyB0aGF0IHRoZSBwYXJlbnQgZ3JvdXAgaGFzIGFscmVhZHkgYmVlbiBicm9rZW5cbiAgICAvLyBuYXR1cmFsbHlcbiAgICB3aWxsQnJlYWskMShvbmVMaW5lKSB8fCBzaG91bGRIYXZlRW1wdHlMaW5lQmVmb3JlSW5kZW50ID8gYnJlYWtQYXJlbnQkMyA6IFwiXCIsIGNvbmRpdGlvbmFsR3JvdXAkMShbb25lTGluZSwgZXhwYW5kZWRdKV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VwYXJhdG9yTm9XaGl0ZXNwYWNlKGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZywgY2hpbGQsIGNoaWxkTm9kZSwgbmV4dE5vZGUpIHtcbiAgICBpZiAoaXNGYWNlYm9va1RyYW5zbGF0aW9uVGFnKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2RlLnR5cGUgPT09IFwiSlNYRWxlbWVudFwiICYmICFjaGlsZE5vZGUuY2xvc2luZ0VsZW1lbnQgfHwgbmV4dE5vZGUgJiYgbmV4dE5vZGUudHlwZSA9PT0gXCJKU1hFbGVtZW50XCIgJiYgIW5leHROb2RlLmNsb3NpbmdFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY2hpbGQubGVuZ3RoID09PSAxID8gc29mdGxpbmUkNiA6IGhhcmRsaW5lJDk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvZnRsaW5lJDY7XG4gIH1cblxuICBmdW5jdGlvbiBzZXBhcmF0b3JXaXRoV2hpdGVzcGFjZShpc0ZhY2Vib29rVHJhbnNsYXRpb25UYWcsIGNoaWxkLCBjaGlsZE5vZGUsIG5leHROb2RlKSB7XG4gICAgaWYgKGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZykge1xuICAgICAgcmV0dXJuIGhhcmRsaW5lJDk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkTm9kZS50eXBlID09PSBcIkpTWEVsZW1lbnRcIiAmJiAhY2hpbGROb2RlLmNsb3NpbmdFbGVtZW50IHx8IG5leHROb2RlICYmIG5leHROb2RlLnR5cGUgPT09IFwiSlNYRWxlbWVudFwiICYmICFuZXh0Tm9kZS5jbG9zaW5nRWxlbWVudCA/IGhhcmRsaW5lJDkgOiBzb2Z0bGluZSQ2O1xuICAgIH1cblxuICAgIHJldHVybiBoYXJkbGluZSQ5O1xuICB9IC8vIEpTWCBDaGlsZHJlbiBhcmUgc3RyYW5nZSwgbW9zdGx5IGZvciB0d28gcmVhc29uczpcbiAgLy8gMS4gSlNYIHJlYWRzIG5ld2xpbmVzIGludG8gc3RyaW5nIHZhbHVlcywgaW5zdGVhZCBvZiBza2lwcGluZyB0aGVtIGxpa2UgSlNcbiAgLy8gMi4gdXAgdG8gb25lIHdoaXRlc3BhY2UgYmV0d2VlbiBlbGVtZW50cyB3aXRoaW4gYSBsaW5lIGlzIHNpZ25pZmljYW50LFxuICAvLyAgICBidXQgbm90IGJldHdlZW4gbGluZXMuXG4gIC8vXG4gIC8vIExlYWRpbmcsIHRyYWlsaW5nLCBhbmQgbG9uZSB3aGl0ZXNwYWNlIGFsbCBuZWVkIHRvXG4gIC8vIHR1cm4gdGhlbXNlbHZlcyBpbnRvIHRoZSByYXRoZXIgdWdseSBgeycgJ31gIHdoZW4gYnJlYWtpbmcuXG4gIC8vXG4gIC8vIFdlIHByaW50IEpTWCB1c2luZyB0aGUgYGZpbGxgIGRvYyBwcmltaXRpdmUuXG4gIC8vIFRoaXMgcmVxdWlyZXMgdGhhdCB3ZSBnaXZlIGl0IGFuIGFycmF5IG9mIGFsdGVybmF0aW5nXG4gIC8vIGNvbnRlbnQgYW5kIHdoaXRlc3BhY2UgZWxlbWVudHMuXG4gIC8vIFRvIGVuc3VyZSB0aGlzIHdlIGFkZCBkdW1teSBgXCJcImAgY29udGVudCBlbGVtZW50cyBhcyBuZWVkZWQuXG5cblxuICBmdW5jdGlvbiBwcmludEpTWENoaWxkcmVuKHBhdGgsIG9wdGlvbnMsIHByaW50LCBqc3hXaGl0ZXNwYWNlLCBpc0ZhY2Vib29rVHJhbnNsYXRpb25UYWcpIHtcbiAgICBjb25zdCBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107IC8vIHVzaW5nIGBtYXBgIGluc3RlYWQgb2YgYGVhY2hgIGJlY2F1c2UgaXQgcHJvdmlkZXMgYGlgXG5cbiAgICBwYXRoLm1hcCgoY2hpbGRQYXRoLCBpKSA9PiB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgICBpZiAoaXNMaXRlcmFsJDEoY2hpbGQpKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSByYXdUZXh0JDEoY2hpbGQpOyAvLyBDb250YWlucyBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlclxuXG4gICAgICAgIGlmIChpc01lYW5pbmdmdWxKU1hUZXh0JDEoY2hpbGQpKSB7XG4gICAgICAgICAgY29uc3Qgd29yZHMgPSB0ZXh0LnNwbGl0KG1hdGNoSnN4V2hpdGVzcGFjZVJlZ2V4JDEpOyAvLyBTdGFydHMgd2l0aCB3aGl0ZXNwYWNlXG5cbiAgICAgICAgICBpZiAod29yZHNbMF0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goXCJcIik7XG4gICAgICAgICAgICB3b3Jkcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICBpZiAoL1xcbi8udGVzdCh3b3Jkc1swXSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG4uY2hpbGRyZW5baSArIDFdO1xuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHNlcGFyYXRvcldpdGhXaGl0ZXNwYWNlKGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZywgd29yZHNbMV0sIGNoaWxkLCBuZXh0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGpzeFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3b3Jkcy5zaGlmdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBlbmRXaGl0ZXNwYWNlOyAvLyBFbmRzIHdpdGggd2hpdGVzcGFjZVxuXG4gICAgICAgICAgaWYgKGdldExhc3QkMyh3b3JkcykgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdvcmRzLnBvcCgpO1xuICAgICAgICAgICAgZW5kV2hpdGVzcGFjZSA9IHdvcmRzLnBvcCgpO1xuICAgICAgICAgIH0gLy8gVGhpcyB3YXMgd2hpdGVzcGFjZSBvbmx5IHdpdGhvdXQgYSBuZXcgbGluZS5cblxuXG4gICAgICAgICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdvcmRzLmZvckVhY2goKHdvcmQsIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGxpbmUkOSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHdvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGVuZFdoaXRlc3BhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKC9cXG4vLnRlc3QoZW5kV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG4uY2hpbGRyZW5baSArIDFdO1xuICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHNlcGFyYXRvcldpdGhXaGl0ZXNwYWNlKGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZywgZ2V0TGFzdCQzKGNoaWxkcmVuKSwgY2hpbGQsIG5leHQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goanN4V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBuLmNoaWxkcmVuW2kgKyAxXTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goc2VwYXJhdG9yTm9XaGl0ZXNwYWNlKGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZywgZ2V0TGFzdCQzKGNoaWxkcmVuKSwgY2hpbGQsIG5leHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoL1xcbi8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgIC8vIEtlZXAgKHVwIHRvIG9uZSkgYmxhbmsgbGluZSBiZXR3ZWVuIHRhZ3MvZXhwcmVzc2lvbnMvdGV4dC5cbiAgICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBrZWVwIGJsYW5rIGxpbmVzIGJldHdlZW4gdGV4dCBlbGVtZW50cy5cbiAgICAgICAgICBpZiAodGV4dC5tYXRjaCgvXFxuL2cpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goXCJcIik7XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGhhcmRsaW5lJDkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKFwiXCIpO1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goanN4V2hpdGVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByaW50ZWRDaGlsZCA9IHByaW50KGNoaWxkUGF0aCk7XG4gICAgICAgIGNoaWxkcmVuLnB1c2gocHJpbnRlZENoaWxkKTtcbiAgICAgICAgY29uc3QgbmV4dCA9IG4uY2hpbGRyZW5baSArIDFdO1xuICAgICAgICBjb25zdCBkaXJlY3RseUZvbGxvd2VkQnlNZWFuaW5nZnVsVGV4dCA9IG5leHQgJiYgaXNNZWFuaW5nZnVsSlNYVGV4dCQxKG5leHQpO1xuXG4gICAgICAgIGlmIChkaXJlY3RseUZvbGxvd2VkQnlNZWFuaW5nZnVsVGV4dCkge1xuICAgICAgICAgIGNvbnN0IGZpcnN0V29yZCA9IHJhd1RleHQkMShuZXh0KS50cmltKCkuc3BsaXQobWF0Y2hKc3hXaGl0ZXNwYWNlUmVnZXgkMSlbMF07XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChzZXBhcmF0b3JOb1doaXRlc3BhY2UoaXNGYWNlYm9va1RyYW5zbGF0aW9uVGFnLCBmaXJzdFdvcmQsIGNoaWxkLCBuZXh0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChoYXJkbGluZSQ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFwiY2hpbGRyZW5cIik7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9IC8vIEpTWCBleHBhbmRzIGNoaWxkcmVuIGZyb20gdGhlIGluc2lkZS1vdXQsIGluc3RlYWQgb2YgdGhlIG91dHNpZGUtaW4uXG4gIC8vIFRoaXMgaXMgYm90aCB0byBicmVhayBjaGlsZHJlbiBiZWZvcmUgYXR0cmlidXRlcyxcbiAgLy8gYW5kIHRvIGVuc3VyZSB0aGF0IHdoZW4gY2hpbGRyZW4gYnJlYWssIHRoZWlyIHBhcmVudHMgZG8gYXMgd2VsbC5cbiAgLy9cbiAgLy8gQW55IGVsZW1lbnQgdGhhdCBpcyB3cml0dGVuIHdpdGhvdXQgYW55IG5ld2xpbmVzIGFuZCBmaXRzIG9uIGEgc2luZ2xlIGxpbmVcbiAgLy8gaXMgbGVmdCB0aGF0IHdheS5cbiAgLy8gTm90IG9ubHkgdGhhdCwgYW55IHVzZXItd3JpdHRlbi1saW5lIGNvbnRhaW5pbmcgbXVsdGlwbGUgSlNYIHNpYmxpbmdzXG4gIC8vIHNob3VsZCBhbHNvIGJlIGtlcHQgb24gb25lIGxpbmUgaWYgcG9zc2libGUsXG4gIC8vIHNvIGVhY2ggdXNlci13cml0dGVuLWxpbmUgaXMgd3JhcHBlZCBpbiBpdHMgb3duIGdyb3VwLlxuICAvL1xuICAvLyBFbGVtZW50cyB0aGF0IGNvbnRhaW4gbmV3bGluZXMgb3IgZG9uJ3QgZml0IG9uIGEgc2luZ2xlIGxpbmUgKHJlY3Vyc2l2ZWx5KVxuICAvLyBhcmUgZnVsbHktc3BsaXQsIHVzaW5nIGhhcmRsaW5lIGFuZCBzaG91bGRCcmVhazogdHJ1ZS5cbiAgLy9cbiAgLy8gVG8gc3VwcG9ydCB0aGF0IGNhc2UgcHJvcGVybHksIGFsbCBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAgLy8gYXJlIHN0cmlwcGVkIGZyb20gdGhlIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZCByZXBsYWNlZCB3aXRoIGEgc2luZ2xlIGhhcmRsaW5lLlxuXG5cbiAgZnVuY3Rpb24gcHJpbnRKU1hFbGVtZW50KHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3QgbiA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmIChuLnR5cGUgPT09IFwiSlNYRWxlbWVudFwiICYmIGlzRW1wdHlKU1hFbGVtZW50JDEobikpIHtcbiAgICAgIHJldHVybiBjb25jYXQkZChbcGF0aC5jYWxsKHByaW50LCBcIm9wZW5pbmdFbGVtZW50XCIpLCBwYXRoLmNhbGwocHJpbnQsIFwiY2xvc2luZ0VsZW1lbnRcIildKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcGVuaW5nTGluZXMgPSBuLnR5cGUgPT09IFwiSlNYRWxlbWVudFwiID8gcGF0aC5jYWxsKHByaW50LCBcIm9wZW5pbmdFbGVtZW50XCIpIDogcGF0aC5jYWxsKHByaW50LCBcIm9wZW5pbmdGcmFnbWVudFwiKTtcbiAgICBjb25zdCBjbG9zaW5nTGluZXMgPSBuLnR5cGUgPT09IFwiSlNYRWxlbWVudFwiID8gcGF0aC5jYWxsKHByaW50LCBcImNsb3NpbmdFbGVtZW50XCIpIDogcGF0aC5jYWxsKHByaW50LCBcImNsb3NpbmdGcmFnbWVudFwiKTtcblxuICAgIGlmIChuLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBuLmNoaWxkcmVuWzBdLnR5cGUgPT09IFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiICYmIChuLmNoaWxkcmVuWzBdLmV4cHJlc3Npb24udHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIiB8fCBuLmNoaWxkcmVuWzBdLmV4cHJlc3Npb24udHlwZSA9PT0gXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIikpIHtcbiAgICAgIHJldHVybiBjb25jYXQkZChbb3BlbmluZ0xpbmVzLCBjb25jYXQkZChwYXRoLm1hcChwcmludCwgXCJjaGlsZHJlblwiKSksIGNsb3NpbmdMaW5lc10pO1xuICAgIH0gLy8gQ29udmVydCBge1wiIFwifWAgdG8gdGV4dCBub2RlcyBjb250YWluaW5nIGEgc3BhY2UuXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIHR1cm4gdGhlbSBpbnRvIGBqc3hXaGl0ZXNwYWNlYCB3aGljaFxuICAgIC8vIGNhbiB0aGVuIHByaW50IGFzIGVpdGhlciBhIHNwYWNlIG9yIGB7XCIgXCJ9YCB3aGVuIGJyZWFraW5nLlxuXG5cbiAgICBuLmNoaWxkcmVuID0gbi5jaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgICAgaWYgKGlzSlNYV2hpdGVzcGFjZUV4cHJlc3Npb24kMShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkpTWFRleHRcIixcbiAgICAgICAgICB2YWx1ZTogXCIgXCIsXG4gICAgICAgICAgcmF3OiBcIiBcIlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG4gICAgY29uc3QgY29udGFpbnNUYWcgPSBuLmNoaWxkcmVuLmZpbHRlcihpc0pTWE5vZGUkMSkubGVuZ3RoID4gMDtcbiAgICBjb25zdCBjb250YWluc011bHRpcGxlRXhwcmVzc2lvbnMgPSBuLmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiBjaGlsZC50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIikubGVuZ3RoID4gMTtcbiAgICBjb25zdCBjb250YWluc011bHRpcGxlQXR0cmlidXRlcyA9IG4udHlwZSA9PT0gXCJKU1hFbGVtZW50XCIgJiYgbi5vcGVuaW5nRWxlbWVudC5hdHRyaWJ1dGVzLmxlbmd0aCA+IDE7IC8vIFJlY29yZCBhbnkgYnJlYWtzLiBTaG91bGQgbmV2ZXIgZ28gZnJvbSB0cnVlIHRvIGZhbHNlLCBvbmx5IGZhbHNlIHRvIHRydWUuXG5cbiAgICBsZXQgZm9yY2VkQnJlYWsgPSB3aWxsQnJlYWskMShvcGVuaW5nTGluZXMpIHx8IGNvbnRhaW5zVGFnIHx8IGNvbnRhaW5zTXVsdGlwbGVBdHRyaWJ1dGVzIHx8IGNvbnRhaW5zTXVsdGlwbGVFeHByZXNzaW9ucztcbiAgICBjb25zdCBpc01keEJsb2NrID0gcGF0aC5nZXRQYXJlbnROb2RlKCkucm9vdE1hcmtlciA9PT0gXCJtZHhcIjtcbiAgICBjb25zdCByYXdKc3hXaGl0ZXNwYWNlID0gb3B0aW9ucy5zaW5nbGVRdW90ZSA/IFwieycgJ31cIiA6ICd7XCIgXCJ9JztcbiAgICBjb25zdCBqc3hXaGl0ZXNwYWNlID0gaXNNZHhCbG9jayA/IGNvbmNhdCRkKFtcIiBcIl0pIDogaWZCcmVhayQ2KGNvbmNhdCRkKFtyYXdKc3hXaGl0ZXNwYWNlLCBzb2Z0bGluZSQ2XSksIFwiIFwiKTtcbiAgICBjb25zdCBpc0ZhY2Vib29rVHJhbnNsYXRpb25UYWcgPSBuLm9wZW5pbmdFbGVtZW50ICYmIG4ub3BlbmluZ0VsZW1lbnQubmFtZSAmJiBuLm9wZW5pbmdFbGVtZW50Lm5hbWUubmFtZSA9PT0gXCJmYnRcIjtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHByaW50SlNYQ2hpbGRyZW4ocGF0aCwgb3B0aW9ucywgcHJpbnQsIGpzeFdoaXRlc3BhY2UsIGlzRmFjZWJvb2tUcmFuc2xhdGlvblRhZyk7XG4gICAgY29uc3QgY29udGFpbnNUZXh0ID0gbi5jaGlsZHJlbi5zb21lKGNoaWxkID0+IGlzTWVhbmluZ2Z1bEpTWFRleHQkMShjaGlsZCkpOyAvLyBXZSBjYW4gZW5kIHVwIHdlIG11bHRpcGxlIHdoaXRlc3BhY2UgZWxlbWVudHMgd2l0aCBlbXB0eSBzdHJpbmdcbiAgICAvLyBjb250ZW50IGJldHdlZW4gdGhlbS5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSBlbXB0eSB3aGl0ZXNwYWNlIGFuZCBzb2Z0bGluZXMgYmVmb3JlIEpTWCB3aGl0ZXNwYWNlXG4gICAgLy8gdG8gZ2V0IHRoZSBjb3JyZWN0IG91dHB1dC5cblxuICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgaXNQYWlyT2ZFbXB0eVN0cmluZ3MgPSBjaGlsZHJlbltpXSA9PT0gXCJcIiAmJiBjaGlsZHJlbltpICsgMV0gPT09IFwiXCI7XG4gICAgICBjb25zdCBpc1BhaXJPZkhhcmRsaW5lcyA9IGNoaWxkcmVuW2ldID09PSBoYXJkbGluZSQ5ICYmIGNoaWxkcmVuW2kgKyAxXSA9PT0gXCJcIiAmJiBjaGlsZHJlbltpICsgMl0gPT09IGhhcmRsaW5lJDk7XG4gICAgICBjb25zdCBpc0xpbmVGb2xsb3dlZEJ5SlNYV2hpdGVzcGFjZSA9IChjaGlsZHJlbltpXSA9PT0gc29mdGxpbmUkNiB8fCBjaGlsZHJlbltpXSA9PT0gaGFyZGxpbmUkOSkgJiYgY2hpbGRyZW5baSArIDFdID09PSBcIlwiICYmIGNoaWxkcmVuW2kgKyAyXSA9PT0ganN4V2hpdGVzcGFjZTtcbiAgICAgIGNvbnN0IGlzSlNYV2hpdGVzcGFjZUZvbGxvd2VkQnlMaW5lID0gY2hpbGRyZW5baV0gPT09IGpzeFdoaXRlc3BhY2UgJiYgY2hpbGRyZW5baSArIDFdID09PSBcIlwiICYmIChjaGlsZHJlbltpICsgMl0gPT09IHNvZnRsaW5lJDYgfHwgY2hpbGRyZW5baSArIDJdID09PSBoYXJkbGluZSQ5KTtcbiAgICAgIGNvbnN0IGlzRG91YmxlSlNYV2hpdGVzcGFjZSA9IGNoaWxkcmVuW2ldID09PSBqc3hXaGl0ZXNwYWNlICYmIGNoaWxkcmVuW2kgKyAxXSA9PT0gXCJcIiAmJiBjaGlsZHJlbltpICsgMl0gPT09IGpzeFdoaXRlc3BhY2U7XG4gICAgICBjb25zdCBpc1BhaXJPZkhhcmRPclNvZnRMaW5lcyA9IGNoaWxkcmVuW2ldID09PSBzb2Z0bGluZSQ2ICYmIGNoaWxkcmVuW2kgKyAxXSA9PT0gXCJcIiAmJiBjaGlsZHJlbltpICsgMl0gPT09IGhhcmRsaW5lJDkgfHwgY2hpbGRyZW5baV0gPT09IGhhcmRsaW5lJDkgJiYgY2hpbGRyZW5baSArIDFdID09PSBcIlwiICYmIGNoaWxkcmVuW2kgKyAyXSA9PT0gc29mdGxpbmUkNjtcblxuICAgICAgaWYgKGlzUGFpck9mSGFyZGxpbmVzICYmIGNvbnRhaW5zVGV4dCB8fCBpc1BhaXJPZkVtcHR5U3RyaW5ncyB8fCBpc0xpbmVGb2xsb3dlZEJ5SlNYV2hpdGVzcGFjZSB8fCBpc0RvdWJsZUpTWFdoaXRlc3BhY2UgfHwgaXNQYWlyT2ZIYXJkT3JTb2Z0TGluZXMpIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc0pTWFdoaXRlc3BhY2VGb2xsb3dlZEJ5TGluZSkge1xuICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSArIDEsIDIpO1xuICAgICAgfVxuICAgIH0gLy8gVHJpbSB0cmFpbGluZyBsaW5lcyAob3IgZW1wdHkgc3RyaW5ncylcblxuXG4gICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCAmJiAoaXNMaW5lTmV4dCQxKGdldExhc3QkMyhjaGlsZHJlbikpIHx8IGlzRW1wdHkkMShnZXRMYXN0JDMoY2hpbGRyZW4pKSkpIHtcbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH0gLy8gVHJpbSBsZWFkaW5nIGxpbmVzIChvciBlbXB0eSBzdHJpbmdzKVxuXG5cbiAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoICYmIChpc0xpbmVOZXh0JDEoY2hpbGRyZW5bMF0pIHx8IGlzRW1wdHkkMShjaGlsZHJlblswXSkpICYmIChpc0xpbmVOZXh0JDEoY2hpbGRyZW5bMV0pIHx8IGlzRW1wdHkkMShjaGlsZHJlblsxXSkpKSB7XG4gICAgICBjaGlsZHJlbi5zaGlmdCgpO1xuICAgICAgY2hpbGRyZW4uc2hpZnQoKTtcbiAgICB9IC8vIFR3ZWFrIGhvdyB3ZSBmb3JtYXQgY2hpbGRyZW4gaWYgb3V0cHV0dGluZyB0aGlzIGVsZW1lbnQgb3ZlciBtdWx0aXBsZSBsaW5lcy5cbiAgICAvLyBBbHNvIGRldGVjdCB3aGV0aGVyIHdlIHdpbGwgZm9yY2UgdGhpcyBlbGVtZW50IHRvIG91dHB1dCBvdmVyIG11bHRpcGxlIGxpbmVzLlxuXG5cbiAgICBjb25zdCBtdWx0aWxpbmVDaGlsZHJlbiA9IFtdO1xuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgICAvLyBUaGVyZSBhcmUgYSBudW1iZXIgb2Ygc2l0dWF0aW9ucyB3aGVyZSB3ZSBuZWVkIHRvIGVuc3VyZSB3ZSBkaXNwbGF5XG4gICAgICAvLyB3aGl0ZXNwYWNlIGFzIGB7XCIgXCJ9YCB3aGVuIG91dHB1dHRpbmcgdGhpcyBlbGVtZW50IG92ZXIgbXVsdGlwbGUgbGluZXMuXG4gICAgICBpZiAoY2hpbGQgPT09IGpzeFdoaXRlc3BhY2UpIHtcbiAgICAgICAgaWYgKGkgPT09IDEgJiYgY2hpbGRyZW5baSAtIDFdID09PSBcIlwiKSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gU29saXRhcnkgd2hpdGVzcGFjZVxuICAgICAgICAgICAgbXVsdGlsaW5lQ2hpbGRyZW4ucHVzaChyYXdKc3hXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIExlYWRpbmcgd2hpdGVzcGFjZVxuXG5cbiAgICAgICAgICBtdWx0aWxpbmVDaGlsZHJlbi5wdXNoKGNvbmNhdCRkKFtyYXdKc3hXaGl0ZXNwYWNlLCBoYXJkbGluZSQ5XSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSBjaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgLy8gVHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgIG11bHRpbGluZUNoaWxkcmVuLnB1c2gocmF3SnN4V2hpdGVzcGFjZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuW2kgLSAxXSA9PT0gXCJcIiAmJiBjaGlsZHJlbltpIC0gMl0gPT09IGhhcmRsaW5lJDkpIHtcbiAgICAgICAgICAvLyBXaGl0ZXNwYWNlIGFmdGVyIGxpbmUgYnJlYWtcbiAgICAgICAgICBtdWx0aWxpbmVDaGlsZHJlbi5wdXNoKHJhd0pzeFdoaXRlc3BhY2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtdWx0aWxpbmVDaGlsZHJlbi5wdXNoKGNoaWxkKTtcblxuICAgICAgaWYgKHdpbGxCcmVhayQxKGNoaWxkKSkge1xuICAgICAgICBmb3JjZWRCcmVhayA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7IC8vIElmIHRoZXJlIGlzIHRleHQgd2UgdXNlIGBmaWxsYCB0byBmaXQgYXMgbXVjaCBvbnRvIGVhY2ggbGluZSBhcyBwb3NzaWJsZS5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHRleHQgKGp1c3QgdGFncyBhbmQgZXhwcmVzc2lvbnMpIHdlIHVzZSBgZ3JvdXBgXG4gICAgLy8gdG8gb3V0cHV0IGVhY2ggb24gYSBzZXBhcmF0ZSBsaW5lLlxuXG4gICAgY29uc3QgY29udGVudCA9IGNvbnRhaW5zVGV4dCA/IGZpbGwkNChtdWx0aWxpbmVDaGlsZHJlbikgOiBncm91cCRiKGNvbmNhdCRkKG11bHRpbGluZUNoaWxkcmVuKSwge1xuICAgICAgc2hvdWxkQnJlYWs6IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChpc01keEJsb2NrKSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICBjb25zdCBtdWx0aUxpbmVFbGVtID0gZ3JvdXAkYihjb25jYXQkZChbb3BlbmluZ0xpbmVzLCBpbmRlbnQkNyhjb25jYXQkZChbaGFyZGxpbmUkOSwgY29udGVudF0pKSwgaGFyZGxpbmUkOSwgY2xvc2luZ0xpbmVzXSkpO1xuXG4gICAgaWYgKGZvcmNlZEJyZWFrKSB7XG4gICAgICByZXR1cm4gbXVsdGlMaW5lRWxlbTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZGl0aW9uYWxHcm91cCQxKFtncm91cCRiKGNvbmNhdCRkKFtvcGVuaW5nTGluZXMsIGNvbmNhdCRkKGNoaWxkcmVuKSwgY2xvc2luZ0xpbmVzXSkpLCBtdWx0aUxpbmVFbGVtXSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZVdyYXBKU1hFbGVtZW50SW5QYXJlbnMocGF0aCwgZWxlbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH1cblxuICAgIGNvbnN0IE5PX1dSQVBfUEFSRU5UUyA9IHtcbiAgICAgIEFycmF5RXhwcmVzc2lvbjogdHJ1ZSxcbiAgICAgIEpTWEF0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIEpTWEVsZW1lbnQ6IHRydWUsXG4gICAgICBKU1hFeHByZXNzaW9uQ29udGFpbmVyOiB0cnVlLFxuICAgICAgSlNYRnJhZ21lbnQ6IHRydWUsXG4gICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiB0cnVlLFxuICAgICAgQ2FsbEV4cHJlc3Npb246IHRydWUsXG4gICAgICBPcHRpb25hbENhbGxFeHByZXNzaW9uOiB0cnVlLFxuICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiB0cnVlLFxuICAgICAgSnNFeHByZXNzaW9uUm9vdDogdHJ1ZVxuICAgIH07XG5cbiAgICBpZiAoTk9fV1JBUF9QQVJFTlRTW3BhcmVudC50eXBlXSkge1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfVxuXG4gICAgY29uc3Qgc2hvdWxkQnJlYWsgPSBwYXRoLm1hdGNoKHVuZGVmaW5lZCwgbm9kZSA9PiBub2RlLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwgaXNDYWxsT3JPcHRpb25hbENhbGxFeHByZXNzaW9uJDEsIG5vZGUgPT4gbm9kZS50eXBlID09PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIik7XG4gICAgY29uc3QgbmVlZHNQYXJlbnMgPSBuZWVkc1BhcmVuc18xKHBhdGgsIG9wdGlvbnMpO1xuICAgIHJldHVybiBncm91cCRiKGNvbmNhdCRkKFtuZWVkc1BhcmVucyA/IFwiXCIgOiBpZkJyZWFrJDYoXCIoXCIpLCBpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgZWxlbV0pKSwgc29mdGxpbmUkNiwgbmVlZHNQYXJlbnMgPyBcIlwiIDogaWZCcmVhayQ2KFwiKVwiKV0pLCB7XG4gICAgICBzaG91bGRCcmVha1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW5saW5lTG9naWNhbEV4cHJlc3Npb24obm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwiTG9naWNhbEV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnJpZ2h0LnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiICYmIG5vZGUucmlnaHQucHJvcGVydGllcy5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnJpZ2h0LnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIgJiYgbm9kZS5yaWdodC5lbGVtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0pTWE5vZGUkMShub2RlLnJpZ2h0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEZvciBiaW5hcnkgZXhwcmVzc2lvbnMgdG8gYmUgY29uc2lzdGVudCwgd2UgbmVlZCB0byBncm91cFxuICAvLyBzdWJzZXF1ZW50IG9wZXJhdG9ycyB3aXRoIHRoZSBzYW1lIHByZWNlZGVuY2UgbGV2ZWwgdW5kZXIgYSBzaW5nbGVcbiAgLy8gZ3JvdXAuIE90aGVyd2lzZSB0aGV5IHdpbGwgYmUgbmVzdGVkIHN1Y2ggdGhhdCBzb21lIG9mIHRoZW0gYnJlYWtcbiAgLy8gb250byBuZXcgbGluZXMgYnV0IG5vdCBhbGwuIE9wZXJhdG9ycyB3aXRoIHRoZSBzYW1lIHByZWNlZGVuY2VcbiAgLy8gbGV2ZWwgc2hvdWxkIGVpdGhlciBhbGwgYnJlYWsgb3Igbm90LiBCZWNhdXNlIHdlIGdyb3VwIHRoZW0gYnlcbiAgLy8gcHJlY2VkZW5jZSBsZXZlbCBhbmQgdGhlIEFTVCBpcyBzdHJ1Y3R1cmVkIGJhc2VkIG9uIHByZWNlZGVuY2VcbiAgLy8gbGV2ZWwsIHRoaW5ncyBhcmUgbmF0dXJhbGx5IGJyb2tlbiB1cCBjb3JyZWN0bHksIGkuZS4gYCYmYCBpc1xuICAvLyBicm9rZW4gYmVmb3JlIGArYC5cblxuXG4gIGZ1bmN0aW9uIHByaW50QmluYXJ5aXNoRXhwcmVzc2lvbnMocGF0aCwgcHJpbnQsIG9wdGlvbnMsIGlzTmVzdGVkLCBpc0luc2lkZVBhcmVudGhlc2lzKSB7XG4gICAgbGV0IHBhcnRzID0gW107XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTsgLy8gV2UgdHJlYXQgQmluYXJ5RXhwcmVzc2lvbiBhbmQgTG9naWNhbEV4cHJlc3Npb24gbm9kZXMgdGhlIHNhbWUuXG5cbiAgICBpZiAoaXNCaW5hcnlpc2gkMShub2RlKSkge1xuICAgICAgLy8gUHV0IGFsbCBvcGVyYXRvcnMgd2l0aCB0aGUgc2FtZSBwcmVjZWRlbmNlIGxldmVsIGluIHRoZSBzYW1lXG4gICAgICAvLyBncm91cC4gVGhlIHJlYXNvbiB3ZSBvbmx5IG5lZWQgdG8gZG8gdGhpcyB3aXRoIHRoZSBgbGVmdGBcbiAgICAgIC8vIGV4cHJlc3Npb24gaXMgYmVjYXVzZSBnaXZlbiBhbiBleHByZXNzaW9uIGxpa2UgYDEgKyAyIC0gM2AsIGl0XG4gICAgICAvLyBpcyBhbHdheXMgcGFyc2VkIGxpa2UgYCgoMSArIDIpIC0gMylgLCBtZWFuaW5nIHRoZSBgbGVmdGAgc2lkZVxuICAgICAgLy8gaXMgd2hlcmUgdGhlIHJlc3Qgb2YgdGhlIGV4cHJlc3Npb24gd2lsbCBleGlzdC4gQmluYXJ5XG4gICAgICAvLyBleHByZXNzaW9ucyBvbiB0aGUgcmlnaHQgc2lkZSBtZWFuIHRoZXkgaGF2ZSBhIGRpZmZlcmVuY2VcbiAgICAgIC8vIHByZWNlZGVuY2UgbGV2ZWwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgc2VwYXJhdGUgZ3JvdXAsIHNvXG4gICAgICAvLyBwcmludCB0aGVtIG5vcm1hbGx5LiAoVGhpcyBkb2Vzbid0IGhvbGQgZm9yIHRoZSBgKipgIG9wZXJhdG9yLFxuICAgICAgLy8gd2hpY2ggaXMgdW5pcXVlIGluIHRoYXQgaXQgaXMgcmlnaHQtYXNzb2NpYXRpdmUuKVxuICAgICAgaWYgKHNob3VsZEZsYXR0ZW4kMShub2RlLm9wZXJhdG9yLCBub2RlLmxlZnQub3BlcmF0b3IpKSB7XG4gICAgICAgIC8vIEZsYXR0ZW4gdGhlbSBvdXQgYnkgcmVjdXJzaXZlbHkgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICBwYXJ0cyA9IHBhcnRzLmNvbmNhdChwYXRoLmNhbGwobGVmdCA9PiBwcmludEJpbmFyeWlzaEV4cHJlc3Npb25zKGxlZnQsIHByaW50LCBvcHRpb25zLFxuICAgICAgICAvKiBpc05lc3RlZCAqL1xuICAgICAgICB0cnVlLCBpc0luc2lkZVBhcmVudGhlc2lzKSwgXCJsZWZ0XCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImxlZnRcIikpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzaG91bGRJbmxpbmUgPSBzaG91bGRJbmxpbmVMb2dpY2FsRXhwcmVzc2lvbihub2RlKTtcbiAgICAgIGNvbnN0IGxpbmVCZWZvcmVPcGVyYXRvciA9IChub2RlLm9wZXJhdG9yID09PSBcInw+XCIgfHwgbm9kZS50eXBlID09PSBcIk5HUGlwZUV4cHJlc3Npb25cIiB8fCBub2RlLm9wZXJhdG9yID09PSBcInxcIiAmJiBvcHRpb25zLnBhcnNlciA9PT0gXCJfX3Z1ZV9leHByZXNzaW9uXCIpICYmICFoYXNMZWFkaW5nT3duTGluZUNvbW1lbnQkMShvcHRpb25zLm9yaWdpbmFsVGV4dCwgbm9kZS5yaWdodCwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IG5vZGUudHlwZSA9PT0gXCJOR1BpcGVFeHByZXNzaW9uXCIgPyBcInxcIiA6IG5vZGUub3BlcmF0b3I7XG4gICAgICBjb25zdCByaWdodFN1ZmZpeCA9IG5vZGUudHlwZSA9PT0gXCJOR1BpcGVFeHByZXNzaW9uXCIgJiYgbm9kZS5hcmd1bWVudHMubGVuZ3RoICE9PSAwID8gZ3JvdXAkYihpbmRlbnQkNyhjb25jYXQkZChbc29mdGxpbmUkNiwgXCI6IFwiLCBqb2luJDkoY29uY2F0JGQoW3NvZnRsaW5lJDYsIFwiOlwiLCBpZkJyZWFrJDYoXCIgXCIpXSksIHBhdGgubWFwKHByaW50LCBcImFyZ3VtZW50c1wiKS5tYXAoYXJnID0+IGFsaWduJDEoMiwgZ3JvdXAkYihhcmcpKSkpXSkpKSA6IFwiXCI7XG4gICAgICBjb25zdCByaWdodCA9IHNob3VsZElubGluZSA/IGNvbmNhdCRkKFtvcGVyYXRvciwgXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKSwgcmlnaHRTdWZmaXhdKSA6IGNvbmNhdCRkKFtsaW5lQmVmb3JlT3BlcmF0b3IgPyBzb2Z0bGluZSQ2IDogXCJcIiwgb3BlcmF0b3IsIGxpbmVCZWZvcmVPcGVyYXRvciA/IFwiIFwiIDogbGluZSQ5LCBwYXRoLmNhbGwocHJpbnQsIFwicmlnaHRcIiksIHJpZ2h0U3VmZml4XSk7IC8vIElmIHRoZXJlJ3Mgb25seSBhIHNpbmdsZSBiaW5hcnkgZXhwcmVzc2lvbiwgd2Ugd2FudCB0byBjcmVhdGUgYSBncm91cFxuICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgaGF2aW5nIGEgc21hbGwgcmlnaHQgcGFydCBsaWtlIC0xIGJlIG9uIGl0cyBvd24gbGluZS5cblxuICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICBjb25zdCBzaG91bGRHcm91cCA9ICEoaXNJbnNpZGVQYXJlbnRoZXNpcyAmJiBub2RlLnR5cGUgPT09IFwiTG9naWNhbEV4cHJlc3Npb25cIikgJiYgcGFyZW50LnR5cGUgIT09IG5vZGUudHlwZSAmJiBub2RlLmxlZnQudHlwZSAhPT0gbm9kZS50eXBlICYmIG5vZGUucmlnaHQudHlwZSAhPT0gbm9kZS50eXBlO1xuICAgICAgcGFydHMucHVzaChcIiBcIiwgc2hvdWxkR3JvdXAgPyBncm91cCRiKHJpZ2h0KSA6IHJpZ2h0KTsgLy8gVGhlIHJvb3QgY29tbWVudHMgYXJlIGFscmVhZHkgcHJpbnRlZCwgYnV0IHdlIG5lZWQgdG8gbWFudWFsbHkgcHJpbnRcbiAgICAgIC8vIHRoZSBvdGhlciBvbmVzIHNpbmNlIHdlIGRvbid0IGNhbGwgdGhlIG5vcm1hbCBwcmludCBvbiBCaW5hcnlFeHByZXNzaW9uLFxuICAgICAgLy8gb25seSBmb3IgdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRzXG5cbiAgICAgIGlmIChpc05lc3RlZCAmJiBub2RlLmNvbW1lbnRzKSB7XG4gICAgICAgIHBhcnRzID0gY29tbWVudHMucHJpbnRDb21tZW50cyhwYXRoLCAoKSA9PiBjb25jYXQkZChwYXJ0cyksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdXIgc3RvcHBpbmcgY2FzZS4gU2ltcGx5IHByaW50IHRoZSBub2RlIG5vcm1hbGx5LlxuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludEFzc2lnbm1lbnRSaWdodChsZWZ0Tm9kZSwgcmlnaHROb2RlLCBwcmludGVkUmlnaHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoaGFzTGVhZGluZ093bkxpbmVDb21tZW50JDEob3B0aW9ucy5vcmlnaW5hbFRleHQsIHJpZ2h0Tm9kZSwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBpbmRlbnQkNyhjb25jYXQkZChbbGluZSQ5LCBwcmludGVkUmlnaHRdKSk7XG4gICAgfVxuXG4gICAgY29uc3QgY2FuQnJlYWsgPSBpc0JpbmFyeWlzaCQxKHJpZ2h0Tm9kZSkgJiYgIXNob3VsZElubGluZUxvZ2ljYWxFeHByZXNzaW9uKHJpZ2h0Tm9kZSkgfHwgcmlnaHROb2RlLnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIgJiYgaXNCaW5hcnlpc2gkMShyaWdodE5vZGUudGVzdCkgJiYgIXNob3VsZElubGluZUxvZ2ljYWxFeHByZXNzaW9uKHJpZ2h0Tm9kZS50ZXN0KSB8fCByaWdodE5vZGUudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiB8fCByaWdodE5vZGUudHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIiAmJiByaWdodE5vZGUuZGVjb3JhdG9ycyAmJiByaWdodE5vZGUuZGVjb3JhdG9ycy5sZW5ndGggfHwgKGxlZnROb2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiIHx8IGlzU3RyaW5nTGl0ZXJhbCQxKGxlZnROb2RlKSB8fCBsZWZ0Tm9kZS50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikgJiYgKGlzU3RyaW5nTGl0ZXJhbCQxKHJpZ2h0Tm9kZSkgfHwgaXNNZW1iZXJFeHByZXNzaW9uQ2hhaW4kMShyaWdodE5vZGUpKSAmJiAvLyBkbyBub3QgcHV0IHZhbHVlcyBvbiBhIHNlcGFyYXRlIGxpbmUgZnJvbSB0aGUga2V5IGluIGpzb25cbiAgICBvcHRpb25zLnBhcnNlciAhPT0gXCJqc29uXCIgJiYgb3B0aW9ucy5wYXJzZXIgIT09IFwianNvbjVcIiB8fCByaWdodE5vZGUudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjtcblxuICAgIGlmIChjYW5CcmVhaykge1xuICAgICAgcmV0dXJuIGdyb3VwJGIoaW5kZW50JDcoY29uY2F0JGQoW2xpbmUkOSwgcHJpbnRlZFJpZ2h0XSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uY2F0JGQoW1wiIFwiLCBwcmludGVkUmlnaHRdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50QXNzaWdubWVudChsZWZ0Tm9kZSwgcHJpbnRlZExlZnQsIG9wZXJhdG9yLCByaWdodE5vZGUsIHByaW50ZWRSaWdodCwgb3B0aW9ucykge1xuICAgIGlmICghcmlnaHROb2RlKSB7XG4gICAgICByZXR1cm4gcHJpbnRlZExlZnQ7XG4gICAgfVxuXG4gICAgY29uc3QgcHJpbnRlZCA9IHByaW50QXNzaWdubWVudFJpZ2h0KGxlZnROb2RlLCByaWdodE5vZGUsIHByaW50ZWRSaWdodCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGdyb3VwJGIoY29uY2F0JGQoW3ByaW50ZWRMZWZ0LCBvcGVyYXRvciwgcHJpbnRlZF0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkanVzdENsYXVzZShub2RlLCBjbGF1c2UsIGZvcmNlU3BhY2UpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkVtcHR5U3RhdGVtZW50XCIpIHtcbiAgICAgIHJldHVybiBcIjtcIjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIgfHwgZm9yY2VTcGFjZSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRkKFtcIiBcIiwgY2xhdXNlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGVudCQ3KGNvbmNhdCRkKFtsaW5lJDksIGNsYXVzZV0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vZGVTdHIobm9kZSwgb3B0aW9ucywgaXNGbG93T3JUeXBlU2NyaXB0RGlyZWN0aXZlTGl0ZXJhbCkge1xuICAgIGNvbnN0IHJhdyA9IHJhd1RleHQkMShub2RlKTtcbiAgICBjb25zdCBpc0RpcmVjdGl2ZUxpdGVyYWwgPSBpc0Zsb3dPclR5cGVTY3JpcHREaXJlY3RpdmVMaXRlcmFsIHx8IG5vZGUudHlwZSA9PT0gXCJEaXJlY3RpdmVMaXRlcmFsXCI7XG4gICAgcmV0dXJuIHByaW50U3RyaW5nJDIocmF3LCBvcHRpb25zLCBpc0RpcmVjdGl2ZUxpdGVyYWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRSZWdleChub2RlKSB7XG4gICAgY29uc3QgZmxhZ3MgPSBub2RlLmZsYWdzLnNwbGl0KFwiXCIpLnNvcnQoKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBcIi9cIi5jb25jYXQobm9kZS5wYXR0ZXJuLCBcIi9cIikuY29uY2F0KGZsYWdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cHJOZWVkc0FTSVByb3RlY3Rpb24ocGF0aCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgbWF5YmVBU0lQcm9ibGVtID0gbmVlZHNQYXJlbnNfMShwYXRoLCBvcHRpb25zKSB8fCBub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgIXNob3VsZFByaW50UGFyYW1zV2l0aG91dFBhcmVucyhwYXRoLCBvcHRpb25zKSB8fCBub2RlLnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IG5vZGUudHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIiAmJiBub2RlLnByZWZpeCAmJiAobm9kZS5vcGVyYXRvciA9PT0gXCIrXCIgfHwgbm9kZS5vcGVyYXRvciA9PT0gXCItXCIpIHx8IG5vZGUudHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIiB8fCBub2RlLnR5cGUgPT09IFwiVGVtcGxhdGVFbGVtZW50XCIgfHwgaXNKU1hOb2RlJDEobm9kZSkgfHwgbm9kZS50eXBlID09PSBcIkJpbmRFeHByZXNzaW9uXCIgJiYgIW5vZGUub2JqZWN0IHx8IG5vZGUudHlwZSA9PT0gXCJSZWdFeHBMaXRlcmFsXCIgfHwgbm9kZS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBub2RlLnBhdHRlcm4gfHwgbm9kZS50eXBlID09PSBcIkxpdGVyYWxcIiAmJiBub2RlLnJlZ2V4O1xuXG4gICAgaWYgKG1heWJlQVNJUHJvYmxlbSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNOYWtlZExlZnRTaWRlJDIobm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aC5jYWxsKGNoaWxkUGF0aCA9PiBleHByTmVlZHNBU0lQcm90ZWN0aW9uKGNoaWxkUGF0aCwgb3B0aW9ucyksIC4uLmdldExlZnRTaWRlUGF0aE5hbWUkMihwYXRoLCBub2RlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG10TmVlZHNBU0lQcm90ZWN0aW9uKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXROb2RlKCk7XG5cbiAgICBpZiAobm9kZS50eXBlICE9PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLmNhbGwoY2hpbGRQYXRoID0+IGV4cHJOZWVkc0FTSVByb3RlY3Rpb24oY2hpbGRQYXRoLCBvcHRpb25zKSwgXCJleHByZXNzaW9uXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSHVnVHlwZShub2RlKSB7XG4gICAgaWYgKGlzU2ltcGxlRmxvd1R5cGUkMShub2RlKSB8fCBpc09iamVjdFR5cGUkMShub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlRTVW5pb25UeXBlXCIpIHtcbiAgICAgIGNvbnN0IHZvaWRDb3VudCA9IG5vZGUudHlwZXMuZmlsdGVyKG4gPT4gbi50eXBlID09PSBcIlZvaWRUeXBlQW5ub3RhdGlvblwiIHx8IG4udHlwZSA9PT0gXCJUU1ZvaWRLZXl3b3JkXCIgfHwgbi50eXBlID09PSBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiB8fCBuLnR5cGUgPT09IFwiVFNOdWxsS2V5d29yZFwiKS5sZW5ndGg7XG4gICAgICBjb25zdCBoYXNPYmplY3QgPSBub2RlLnR5cGVzLnNvbWUobiA9PiBuLnR5cGUgPT09IFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiB8fCBuLnR5cGUgPT09IFwiVFNUeXBlTGl0ZXJhbFwiIHx8IC8vIFRoaXMgaXMgYSBiaXQgYWdncmVzc2l2ZSBidXQgY2FwdHVyZXMgQXJyYXk8e3h9PlxuICAgICAgbi50eXBlID09PSBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiIHx8IG4udHlwZSA9PT0gXCJUU1R5cGVSZWZlcmVuY2VcIik7XG5cbiAgICAgIGlmIChub2RlLnR5cGVzLmxlbmd0aCAtIDEgPT09IHZvaWRDb3VudCAmJiBoYXNPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSHVnQXJndW1lbnRzKGZ1bikge1xuICAgIGlmICghZnVuIHx8IGZ1bi5yZXN0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1zID0gZnVuLnBhcmFtcyB8fCBmdW4ucGFyYW1ldGVycztcblxuICAgIGlmICghcGFyYW1zIHx8IHBhcmFtcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICByZXR1cm4gIXBhcmFtLmNvbW1lbnRzICYmIChwYXJhbS50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIiB8fCBwYXJhbS50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHBhcmFtLnR5cGVBbm5vdGF0aW9uICYmIChwYXJhbS50eXBlQW5ub3RhdGlvbi50eXBlID09PSBcIlR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyYW0udHlwZUFubm90YXRpb24udHlwZSA9PT0gXCJUU1R5cGVBbm5vdGF0aW9uXCIpICYmIGlzT2JqZWN0VHlwZSQxKHBhcmFtLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uKSB8fCBwYXJhbS50eXBlID09PSBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIgJiYgaXNPYmplY3RUeXBlJDEocGFyYW0udHlwZUFubm90YXRpb24pIHx8IHBhcmFtLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiAmJiAocGFyYW0ubGVmdC50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIiB8fCBwYXJhbS5sZWZ0LnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpICYmIChwYXJhbS5yaWdodC50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCBwYXJhbS5yaWdodC50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIiAmJiBwYXJhbS5yaWdodC5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCB8fCBwYXJhbS5yaWdodC50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiICYmIHBhcmFtLnJpZ2h0LmVsZW1lbnRzLmxlbmd0aCA9PT0gMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRBcnJheUl0ZW1zKHBhdGgsIG9wdGlvbnMsIHByaW50UGF0aCwgcHJpbnQpIHtcbiAgICBjb25zdCBwcmludGVkRWxlbWVudHMgPSBbXTtcbiAgICBsZXQgc2VwYXJhdG9yUGFydHMgPSBbXTtcbiAgICBwYXRoLmVhY2goY2hpbGRQYXRoID0+IHtcbiAgICAgIHByaW50ZWRFbGVtZW50cy5wdXNoKGNvbmNhdCRkKHNlcGFyYXRvclBhcnRzKSk7XG4gICAgICBwcmludGVkRWxlbWVudHMucHVzaChncm91cCRiKHByaW50KGNoaWxkUGF0aCkpKTtcbiAgICAgIHNlcGFyYXRvclBhcnRzID0gW1wiLFwiLCBsaW5lJDldO1xuXG4gICAgICBpZiAoY2hpbGRQYXRoLmdldFZhbHVlKCkgJiYgaXNOZXh0TGluZUVtcHR5JDQob3B0aW9ucy5vcmlnaW5hbFRleHQsIGNoaWxkUGF0aC5nZXRWYWx1ZSgpLCBvcHRpb25zLmxvY0VuZCkpIHtcbiAgICAgICAgc2VwYXJhdG9yUGFydHMucHVzaChzb2Z0bGluZSQ2KTtcbiAgICAgIH1cbiAgICB9LCBwcmludFBhdGgpO1xuICAgIHJldHVybiBjb25jYXQkZChwcmludGVkRWxlbWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRSZXR1cm5BbmRUaHJvd0FyZ3VtZW50KHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBzZW1pID0gb3B0aW9ucy5zZW1pID8gXCI7XCIgOiBcIlwiO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG5cbiAgICBpZiAobm9kZS5hcmd1bWVudCkge1xuICAgICAgaWYgKHJldHVybkFyZ3VtZW50SGFzTGVhZGluZ0NvbW1lbnQkMShvcHRpb25zLCBub2RlLmFyZ3VtZW50KSkge1xuICAgICAgICBwYXJ0cy5wdXNoKGNvbmNhdCRkKFtcIiAoXCIsIGluZGVudCQ3KGNvbmNhdCRkKFtoYXJkbGluZSQ5LCBwYXRoLmNhbGwocHJpbnQsIFwiYXJndW1lbnRcIildKSksIGhhcmRsaW5lJDksIFwiKVwiXSkpO1xuICAgICAgfSBlbHNlIGlmIChpc0JpbmFyeWlzaCQxKG5vZGUuYXJndW1lbnQpIHx8IG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIikge1xuICAgICAgICBwYXJ0cy5wdXNoKGdyb3VwJGIoY29uY2F0JGQoW2lmQnJlYWskNihcIiAoXCIsIFwiIFwiKSwgaW5kZW50JDcoY29uY2F0JGQoW3NvZnRsaW5lJDYsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKV0pKSwgc29mdGxpbmUkNiwgaWZCcmVhayQ2KFwiKVwiKV0pKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYXJndW1lbnRcIikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxhc3RDb21tZW50ID0gQXJyYXkuaXNBcnJheShub2RlLmNvbW1lbnRzKSAmJiBub2RlLmNvbW1lbnRzW25vZGUuY29tbWVudHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgaXNMYXN0Q29tbWVudExpbmUgPSBsYXN0Q29tbWVudCAmJiAobGFzdENvbW1lbnQudHlwZSA9PT0gXCJDb21tZW50TGluZVwiIHx8IGxhc3RDb21tZW50LnR5cGUgPT09IFwiTGluZVwiKTtcblxuICAgIGlmIChpc0xhc3RDb21tZW50TGluZSkge1xuICAgICAgcGFydHMucHVzaChzZW1pKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzRGFuZ2xpbmdDb21tZW50cyQxKG5vZGUpKSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBjb21tZW50cy5wcmludERhbmdsaW5nQ29tbWVudHMocGF0aCwgb3B0aW9ucyxcbiAgICAgIC8qIHNhbWVJbmRlbnQgKi9cbiAgICAgIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzTGFzdENvbW1lbnRMaW5lKSB7XG4gICAgICBwYXJ0cy5wdXNoKHNlbWkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb25jYXQkZChwYXJ0cyk7XG4gIH1cblxuICBmdW5jdGlvbiB3aWxsUHJpbnRPd25Db21tZW50cyhwYXRoXG4gIC8qLCBvcHRpb25zICovXG4gICkge1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgcmV0dXJuIChub2RlICYmIChpc0pTWE5vZGUkMShub2RlKSB8fCBoYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQkMihub2RlKSB8fCBwYXJlbnQgJiYgKHBhcmVudC50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSAmJiAoaGFzRmxvd0Fubm90YXRpb25Db21tZW50JDEobm9kZS5sZWFkaW5nQ29tbWVudHMpIHx8IGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudCQxKG5vZGUudHJhaWxpbmdDb21tZW50cykpKSB8fCBwYXJlbnQgJiYgKHBhcmVudC50eXBlID09PSBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiIHx8IHBhcmVudC50eXBlID09PSBcIkpTWFNwcmVhZENoaWxkXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudC50eXBlID09PSBcIlRTVW5pb25UeXBlXCIgfHwgKHBhcmVudC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fCBwYXJlbnQudHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikgJiYgcGFyZW50LnN1cGVyQ2xhc3MgPT09IG5vZGUpKSAmJiAoIWhhc0lnbm9yZUNvbW1lbnQkNChwYXRoKSB8fCBwYXJlbnQudHlwZSA9PT0gXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNVbmlvblR5cGVcIik7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5BdHRhY2hDb21tZW50JDEobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgJiYgbm9kZS50eXBlICE9PSBcIkNvbW1lbnRCbG9ja1wiICYmIG5vZGUudHlwZSAhPT0gXCJDb21tZW50TGluZVwiICYmIG5vZGUudHlwZSAhPT0gXCJMaW5lXCIgJiYgbm9kZS50eXBlICE9PSBcIkJsb2NrXCIgJiYgbm9kZS50eXBlICE9PSBcIkVtcHR5U3RhdGVtZW50XCIgJiYgbm9kZS50eXBlICE9PSBcIlRlbXBsYXRlRWxlbWVudFwiICYmIG5vZGUudHlwZSAhPT0gXCJJbXBvcnRcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Q29tbWVudCQyKGNvbW1lbnRQYXRoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29tbWVudCA9IGNvbW1lbnRQYXRoLmdldFZhbHVlKCk7XG5cbiAgICBzd2l0Y2ggKGNvbW1lbnQudHlwZSkge1xuICAgICAgY2FzZSBcIkNvbW1lbnRCbG9ja1wiOlxuICAgICAgY2FzZSBcIkJsb2NrXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNJbmRlbnRhYmxlQmxvY2tDb21tZW50KGNvbW1lbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBwcmludGVkID0gcHJpbnRJbmRlbnRhYmxlQmxvY2tDb21tZW50KGNvbW1lbnQpOyAvLyBXZSBuZWVkIHRvIHByZXZlbnQgYW4gZWRnZSBjYXNlIG9mIGEgcHJldmlvdXMgdHJhaWxpbmcgY29tbWVudFxuICAgICAgICAgICAgLy8gcHJpbnRlZCBhcyBhIGBsaW5lU3VmZml4YCB3aGljaCBjYXVzZXMgdGhlIGNvbW1lbnRzIHRvIGJlXG4gICAgICAgICAgICAvLyBpbnRlcmxlYXZlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9pc3N1ZXMvNDQxMlxuXG4gICAgICAgICAgICBpZiAoY29tbWVudC50cmFpbGluZyAmJiAhaGFzTmV3bGluZSQ1KG9wdGlvbnMub3JpZ2luYWxUZXh0LCBvcHRpb25zLmxvY1N0YXJ0KGNvbW1lbnQpLCB7XG4gICAgICAgICAgICAgIGJhY2t3YXJkczogdHJ1ZVxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRkKFtoYXJkbGluZSQ5LCBwcmludGVkXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcmludGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGNvbW1lbnRFbmQgPSBvcHRpb25zLmxvY0VuZChjb21tZW50KTtcbiAgICAgICAgICBjb25zdCBpc0luc2lkZUZsb3dDb21tZW50ID0gb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2UoY29tbWVudEVuZCAtIDMsIGNvbW1lbnRFbmQpID09PSBcIiotL1wiO1xuICAgICAgICAgIHJldHVybiBcIi8qXCIgKyBjb21tZW50LnZhbHVlICsgKGlzSW5zaWRlRmxvd0NvbW1lbnQgPyBcIiotL1wiIDogXCIqL1wiKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiQ29tbWVudExpbmVcIjpcbiAgICAgIGNhc2UgXCJMaW5lXCI6XG4gICAgICAgIC8vIFByaW50IHNoZWJhbmdzIHdpdGggdGhlIHByb3BlciBjb21tZW50IGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG9wdGlvbnMubG9jU3RhcnQoY29tbWVudCkpLnN0YXJ0c1dpdGgoXCIjIVwiKSkge1xuICAgICAgICAgIHJldHVybiBcIiMhXCIgKyBjb21tZW50LnZhbHVlLnRyaW1FbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIi8vXCIgKyBjb21tZW50LnZhbHVlLnRyaW1FbmQoKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGEgY29tbWVudDogXCIgKyBKU09OLnN0cmluZ2lmeShjb21tZW50KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNJbmRlbnRhYmxlQmxvY2tDb21tZW50KGNvbW1lbnQpIHtcbiAgICAvLyBJZiB0aGUgY29tbWVudCBoYXMgbXVsdGlwbGUgbGluZXMgYW5kIGV2ZXJ5IGxpbmUgc3RhcnRzIHdpdGggYSBzdGFyXG4gICAgLy8gd2UgY2FuIGZpeCB0aGUgaW5kZW50YXRpb24gb2YgZWFjaCBsaW5lLiBUaGUgc3RhcnMgaW4gdGhlIGAvKmAgYW5kXG4gICAgLy8gYCovYCBkZWxpbWl0ZXJzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIGNvbW1lbnQgdmFsdWUsIHNvIGFkZCB0aGVtXG4gICAgLy8gYmFjayBmaXJzdC5cbiAgICBjb25zdCBsaW5lcyA9IFwiKlwiLmNvbmNhdChjb21tZW50LnZhbHVlLCBcIipcIikuc3BsaXQoXCJcXG5cIik7XG4gICAgcmV0dXJuIGxpbmVzLmxlbmd0aCA+IDEgJiYgbGluZXMuZXZlcnkobGluZSA9PiBsaW5lLnRyaW0oKVswXSA9PT0gXCIqXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRJbmRlbnRhYmxlQmxvY2tDb21tZW50KGNvbW1lbnQpIHtcbiAgICBjb25zdCBsaW5lcyA9IGNvbW1lbnQudmFsdWUuc3BsaXQoXCJcXG5cIik7XG4gICAgcmV0dXJuIGNvbmNhdCRkKFtcIi8qXCIsIGpvaW4kOShoYXJkbGluZSQ5LCBsaW5lcy5tYXAoKGxpbmUsIGluZGV4KSA9PiBpbmRleCA9PT0gMCA/IGxpbmUudHJpbUVuZCgpIDogXCIgXCIgKyAoaW5kZXggPCBsaW5lcy5sZW5ndGggLSAxID8gbGluZS50cmltKCkgOiBsaW5lLnRyaW1TdGFydCgpKSkpLCBcIiovXCJdKTtcbiAgfVxuXG4gIHZhciBwcmludGVyRXN0cmVlID0ge1xuICAgIHByZXByb2Nlc3M6IHByZXByb2Nlc3NfMSQxLFxuICAgIHByaW50OiBnZW5lcmljUHJpbnQkMyxcbiAgICBlbWJlZDogZW1iZWRfMSQxLFxuICAgIGluc2VydFByYWdtYTogaW5zZXJ0UHJhZ21hJDcsXG4gICAgbWFzc2FnZUFzdE5vZGU6IGNsZWFuXzEkMSxcbiAgICBoYXNQcmV0dGllcklnbm9yZTogaGFzUHJldHRpZXJJZ25vcmUkNSxcbiAgICB3aWxsUHJpbnRPd25Db21tZW50cyxcbiAgICBjYW5BdHRhY2hDb21tZW50OiBjYW5BdHRhY2hDb21tZW50JDEsXG4gICAgcHJpbnRDb21tZW50OiBwcmludENvbW1lbnQkMixcbiAgICBpc0Jsb2NrQ29tbWVudDogY29tbWVudHMkMS5pc0Jsb2NrQ29tbWVudCxcbiAgICBoYW5kbGVDb21tZW50czoge1xuICAgICAgb3duTGluZTogY29tbWVudHMkMS5oYW5kbGVPd25MaW5lQ29tbWVudCxcbiAgICAgIGVuZE9mTGluZTogY29tbWVudHMkMS5oYW5kbGVFbmRPZkxpbmVDb21tZW50LFxuICAgICAgcmVtYWluaW5nOiBjb21tZW50cyQxLmhhbmRsZVJlbWFpbmluZ0NvbW1lbnRcbiAgICB9LFxuICAgIGdldEdhcFJlZ2V4OiBjb21tZW50cyQxLmdldEdhcFJlZ2V4LFxuICAgIGdldENvbW1lbnRDaGlsZE5vZGVzOiBjb21tZW50cyQxLmdldENvbW1lbnRDaGlsZE5vZGVzXG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGNvbmNhdDogY29uY2F0JGUsXG4gICAgaGFyZGxpbmU6IGhhcmRsaW5lJGEsXG4gICAgaW5kZW50OiBpbmRlbnQkOCxcbiAgICBqb2luOiBqb2luJGFcbiAgfSA9IGRvY3VtZW50LmJ1aWxkZXJzO1xuXG4gIGZ1bmN0aW9uIGdlbmVyaWNQcmludCQ0KHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSnNvblJvb3RcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRlKFtwYXRoLmNhbGwocHJpbnQsIFwibm9kZVwiKSwgaGFyZGxpbmUkYV0pO1xuXG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnRzLmxlbmd0aCA9PT0gMCA/IFwiW11cIiA6IGNvbmNhdCRlKFtcIltcIiwgaW5kZW50JDgoY29uY2F0JGUoW2hhcmRsaW5lJGEsIGpvaW4kYShjb25jYXQkZShbXCIsXCIsIGhhcmRsaW5lJGFdKSwgcGF0aC5tYXAocHJpbnQsIFwiZWxlbWVudHNcIikpXSkpLCBoYXJkbGluZSRhLCBcIl1cIl0pO1xuXG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCA/IFwie31cIiA6IGNvbmNhdCRlKFtcIntcIiwgaW5kZW50JDgoY29uY2F0JGUoW2hhcmRsaW5lJGEsIGpvaW4kYShjb25jYXQkZShbXCIsXCIsIGhhcmRsaW5lJGFdKSwgcGF0aC5tYXAocHJpbnQsIFwicHJvcGVydGllc1wiKSldKSksIGhhcmRsaW5lJGEsIFwifVwiXSk7XG5cbiAgICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGUoW3BhdGguY2FsbChwcmludCwgXCJrZXlcIiksIFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpXSk7XG5cbiAgICAgIGNhc2UgXCJVbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRlKFtub2RlLm9wZXJhdG9yID09PSBcIitcIiA/IFwiXCIgOiBub2RlLm9wZXJhdG9yLCBwYXRoLmNhbGwocHJpbnQsIFwiYXJndW1lbnRcIildKTtcblxuICAgICAgY2FzZSBcIk51bGxMaXRlcmFsXCI6XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcblxuICAgICAgY2FzZSBcIkJvb2xlYW5MaXRlcmFsXCI6XG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG5cbiAgICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vZGUudmFsdWUpO1xuXG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobm9kZS5uYW1lKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIEpTT04uc3RyaW5naWZ5KG5vZGUudHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFuJDUobm9kZSwgbmV3Tm9kZVxuICAvKiwgcGFyZW50Ki9cbiAgKSB7XG4gICAgZGVsZXRlIG5ld05vZGUuc3RhcnQ7XG4gICAgZGVsZXRlIG5ld05vZGUuZW5kO1xuICAgIGRlbGV0ZSBuZXdOb2RlLmV4dHJhO1xuICAgIGRlbGV0ZSBuZXdOb2RlLmxvYztcbiAgICBkZWxldGUgbmV3Tm9kZS5jb21tZW50cztcbiAgICBkZWxldGUgbmV3Tm9kZS5lcnJvcnM7XG5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJTdHJpbmdMaXRlcmFsXCIsXG4gICAgICAgIHZhbHVlOiBub2RlLm5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIiAmJiBub2RlLm9wZXJhdG9yID09PSBcIitcIikge1xuICAgICAgcmV0dXJuIG5ld05vZGUuYXJndW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByaW50ZXJFc3RyZWVKc29uID0ge1xuICAgIHByZXByb2Nlc3M6IHByZXByb2Nlc3NfMSQxLFxuICAgIHByaW50OiBnZW5lcmljUHJpbnQkNCxcbiAgICBtYXNzYWdlQXN0Tm9kZTogY2xlYW4kNVxuICB9O1xuXG4gIGNvbnN0IENBVEVHT1JZX0pBVkFTQ1JJUFQgPSBcIkphdmFTY3JpcHRcIjsgLy8gZm9ybWF0IGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmV0dGllci9wcmV0dGllci9ibG9iL21hc3Rlci9zcmMvbWFpbi9jb3JlLW9wdGlvbnMuanNcblxuICB2YXIgb3B0aW9ucyQ1ID0ge1xuICAgIGFycm93UGFyZW5zOiB7XG4gICAgICBzaW5jZTogXCIxLjkuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0pBVkFTQ1JJUFQsXG4gICAgICB0eXBlOiBcImNob2ljZVwiLFxuICAgICAgZGVmYXVsdDogW3tcbiAgICAgICAgc2luY2U6IFwiMS45LjBcIixcbiAgICAgICAgdmFsdWU6IFwiYXZvaWRcIlxuICAgICAgfSwge1xuICAgICAgICBzaW5jZTogXCIyLjAuMFwiLFxuICAgICAgICB2YWx1ZTogXCJhbHdheXNcIlxuICAgICAgfV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJJbmNsdWRlIHBhcmVudGhlc2VzIGFyb3VuZCBhIHNvbGUgYXJyb3cgZnVuY3Rpb24gcGFyYW1ldGVyLlwiLFxuICAgICAgY2hvaWNlczogW3tcbiAgICAgICAgdmFsdWU6IFwiYWx3YXlzXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFsd2F5cyBpbmNsdWRlIHBhcmVucy4gRXhhbXBsZTogYCh4KSA9PiB4YFwiXG4gICAgICB9LCB7XG4gICAgICAgIHZhbHVlOiBcImF2b2lkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk9taXQgcGFyZW5zIHdoZW4gcG9zc2libGUuIEV4YW1wbGU6IGB4ID0+IHhgXCJcbiAgICAgIH1dXG4gICAgfSxcbiAgICBicmFja2V0U3BhY2luZzogY29tbW9uT3B0aW9ucy5icmFja2V0U3BhY2luZyxcbiAgICBqc3hCcmFja2V0U2FtZUxpbmU6IHtcbiAgICAgIHNpbmNlOiBcIjAuMTcuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0pBVkFTQ1JJUFQsXG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246IFwiUHV0ID4gb24gdGhlIGxhc3QgbGluZSBpbnN0ZWFkIG9mIGF0IGEgbmV3IGxpbmUuXCJcbiAgICB9LFxuICAgIHNlbWk6IHtcbiAgICAgIHNpbmNlOiBcIjEuMC4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfSkFWQVNDUklQVCxcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlByaW50IHNlbWljb2xvbnMuXCIsXG4gICAgICBvcHBvc2l0ZURlc2NyaXB0aW9uOiBcIkRvIG5vdCBwcmludCBzZW1pY29sb25zLCBleGNlcHQgYXQgdGhlIGJlZ2lubmluZyBvZiBsaW5lcyB3aGljaCBtYXkgbmVlZCB0aGVtLlwiXG4gICAgfSxcbiAgICBzaW5nbGVRdW90ZTogY29tbW9uT3B0aW9ucy5zaW5nbGVRdW90ZSxcbiAgICBqc3hTaW5nbGVRdW90ZToge1xuICAgICAgc2luY2U6IFwiMS4xNS4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfSkFWQVNDUklQVCxcbiAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogXCJVc2Ugc2luZ2xlIHF1b3RlcyBpbiBKU1guXCJcbiAgICB9LFxuICAgIHF1b3RlUHJvcHM6IHtcbiAgICAgIHNpbmNlOiBcIjEuMTcuMFwiLFxuICAgICAgY2F0ZWdvcnk6IENBVEVHT1JZX0pBVkFTQ1JJUFQsXG4gICAgICB0eXBlOiBcImNob2ljZVwiLFxuICAgICAgZGVmYXVsdDogXCJhcy1uZWVkZWRcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkNoYW5nZSB3aGVuIHByb3BlcnRpZXMgaW4gb2JqZWN0cyBhcmUgcXVvdGVkLlwiLFxuICAgICAgY2hvaWNlczogW3tcbiAgICAgICAgdmFsdWU6IFwiYXMtbmVlZGVkXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk9ubHkgYWRkIHF1b3RlcyBhcm91bmQgb2JqZWN0IHByb3BlcnRpZXMgd2hlcmUgcmVxdWlyZWQuXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwiY29uc2lzdGVudFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJZiBhdCBsZWFzdCBvbmUgcHJvcGVydHkgaW4gYW4gb2JqZWN0IHJlcXVpcmVzIHF1b3RlcywgcXVvdGUgYWxsIHByb3BlcnRpZXMuXCJcbiAgICAgIH0sIHtcbiAgICAgICAgdmFsdWU6IFwicHJlc2VydmVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUmVzcGVjdCB0aGUgaW5wdXQgdXNlIG9mIHF1b3RlcyBpbiBvYmplY3QgcHJvcGVydGllcy5cIlxuICAgICAgfV1cbiAgICB9LFxuICAgIHRyYWlsaW5nQ29tbWE6IHtcbiAgICAgIHNpbmNlOiBcIjAuMC4wXCIsXG4gICAgICBjYXRlZ29yeTogQ0FURUdPUllfSkFWQVNDUklQVCxcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBkZWZhdWx0OiBbe1xuICAgICAgICBzaW5jZTogXCIwLjAuMFwiLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgc2luY2U6IFwiMC4xOS4wXCIsXG4gICAgICAgIHZhbHVlOiBcIm5vbmVcIlxuICAgICAgfSwge1xuICAgICAgICBzaW5jZTogXCIyLjAuMFwiLFxuICAgICAgICB2YWx1ZTogXCJlczVcIlxuICAgICAgfV0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJQcmludCB0cmFpbGluZyBjb21tYXMgd2hlcmV2ZXIgcG9zc2libGUgd2hlbiBtdWx0aS1saW5lLlwiLFxuICAgICAgY2hvaWNlczogW3tcbiAgICAgICAgdmFsdWU6IFwiZXM1XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRyYWlsaW5nIGNvbW1hcyB3aGVyZSB2YWxpZCBpbiBFUzUgKG9iamVjdHMsIGFycmF5cywgZXRjLilcIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJub25lXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk5vIHRyYWlsaW5nIGNvbW1hcy5cIlxuICAgICAgfSwge1xuICAgICAgICB2YWx1ZTogXCJhbGxcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVHJhaWxpbmcgY29tbWFzIHdoZXJldmVyIHBvc3NpYmxlIChpbmNsdWRpbmcgZnVuY3Rpb24gYXJndW1lbnRzKS5cIlxuICAgICAgfV1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG5hbWUkOSA9IFwiSmF2YVNjcmlwdFwiO1xuICB2YXIgdHlwZSQ4ID0gXCJwcm9ncmFtbWluZ1wiO1xuICB2YXIgdG1TY29wZSQ4ID0gXCJzb3VyY2UuanNcIjtcbiAgdmFyIGFjZU1vZGUkOCA9IFwiamF2YXNjcmlwdFwiO1xuICB2YXIgY29kZW1pcnJvck1vZGUkNCA9IFwiamF2YXNjcmlwdFwiO1xuICB2YXIgY29kZW1pcnJvck1pbWVUeXBlJDQgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuICB2YXIgY29sb3IkMyA9IFwiI2YxZTA1YVwiO1xuICB2YXIgYWxpYXNlcyQyID0gW1xuICBcdFwianNcIixcbiAgXHRcIm5vZGVcIlxuICBdO1xuICB2YXIgZXh0ZW5zaW9ucyQ4ID0gW1xuICBcdFwiLmpzXCIsXG4gIFx0XCIuX2pzXCIsXG4gIFx0XCIuYm9uZXNcIixcbiAgXHRcIi5janNcIixcbiAgXHRcIi5lc1wiLFxuICBcdFwiLmVzNlwiLFxuICBcdFwiLmZyYWdcIixcbiAgXHRcIi5nc1wiLFxuICBcdFwiLmpha2VcIixcbiAgXHRcIi5qc2JcIixcbiAgXHRcIi5qc2NhZFwiLFxuICBcdFwiLmpzZmxcIixcbiAgXHRcIi5qc21cIixcbiAgXHRcIi5qc3NcIixcbiAgXHRcIi5tanNcIixcbiAgXHRcIi5uanNcIixcbiAgXHRcIi5wYWNcIixcbiAgXHRcIi5zanNcIixcbiAgXHRcIi5zc2pzXCIsXG4gIFx0XCIueHNqc1wiLFxuICBcdFwiLnhzanNsaWJcIlxuICBdO1xuICB2YXIgZmlsZW5hbWVzID0gW1xuICBcdFwiSmFrZWZpbGVcIlxuICBdO1xuICB2YXIgaW50ZXJwcmV0ZXJzID0gW1xuICBcdFwiY2hha3JhXCIsXG4gIFx0XCJkOFwiLFxuICBcdFwiZ2pzXCIsXG4gIFx0XCJqc1wiLFxuICBcdFwibm9kZVwiLFxuICBcdFwicWpzXCIsXG4gIFx0XCJyaGlub1wiLFxuICBcdFwidjhcIixcbiAgXHRcInY4LXNoZWxsXCJcbiAgXTtcbiAgdmFyIGxhbmd1YWdlSWQkOCA9IDE4MztcbiAgdmFyIEphdmFTY3JpcHQgPSB7XG4gIFx0bmFtZTogbmFtZSQ5LFxuICBcdHR5cGU6IHR5cGUkOCxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJDgsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSQ4LFxuICBcdGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQ0LFxuICBcdGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDQsXG4gIFx0Y29sb3I6IGNvbG9yJDMsXG4gIFx0YWxpYXNlczogYWxpYXNlcyQyLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkOCxcbiAgXHRmaWxlbmFtZXM6IGZpbGVuYW1lcyxcbiAgXHRpbnRlcnByZXRlcnM6IGludGVycHJldGVycyxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDhcbiAgfTtcblxuICB2YXIgSmF2YVNjcmlwdCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJDksXG4gICAgdHlwZTogdHlwZSQ4LFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkOCxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDgsXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDQsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkNCxcbiAgICBjb2xvcjogY29sb3IkMyxcbiAgICBhbGlhc2VzOiBhbGlhc2VzJDIsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ4LFxuICAgIGZpbGVuYW1lczogZmlsZW5hbWVzLFxuICAgIGludGVycHJldGVyczogaW50ZXJwcmV0ZXJzLFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkOCxcbiAgICAnZGVmYXVsdCc6IEphdmFTY3JpcHRcbiAgfSk7XG5cbiAgdmFyIG5hbWUkYSA9IFwiSlNYXCI7XG4gIHZhciB0eXBlJDkgPSBcInByb2dyYW1taW5nXCI7XG4gIHZhciBncm91cCRjID0gXCJKYXZhU2NyaXB0XCI7XG4gIHZhciBleHRlbnNpb25zJDkgPSBbXG4gIFx0XCIuanN4XCJcbiAgXTtcbiAgdmFyIHRtU2NvcGUkOSA9IFwic291cmNlLmpzLmpzeFwiO1xuICB2YXIgYWNlTW9kZSQ5ID0gXCJqYXZhc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSQ1ID0gXCJqc3hcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSQ1ID0gXCJ0ZXh0L2pzeFwiO1xuICB2YXIgbGFuZ3VhZ2VJZCQ5ID0gMTc4O1xuICB2YXIgSlNYID0ge1xuICBcdG5hbWU6IG5hbWUkYSxcbiAgXHR0eXBlOiB0eXBlJDksXG4gIFx0Z3JvdXA6IGdyb3VwJGMsXG4gIFx0ZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ5LFxuICBcdHRtU2NvcGU6IHRtU2NvcGUkOSxcbiAgXHRhY2VNb2RlOiBhY2VNb2RlJDksXG4gIFx0Y29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDUsXG4gIFx0Y29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkNSxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDlcbiAgfTtcblxuICB2YXIgSlNYJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkYSxcbiAgICB0eXBlOiB0eXBlJDksXG4gICAgZ3JvdXA6IGdyb3VwJGMsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyQ5LFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkOSxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJDksXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJDUsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkNSxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJDksXG4gICAgJ2RlZmF1bHQnOiBKU1hcbiAgfSk7XG5cbiAgdmFyIG5hbWUkYiA9IFwiVHlwZVNjcmlwdFwiO1xuICB2YXIgdHlwZSRhID0gXCJwcm9ncmFtbWluZ1wiO1xuICB2YXIgY29sb3IkNCA9IFwiIzJiNzQ4OVwiO1xuICB2YXIgYWxpYXNlcyQzID0gW1xuICBcdFwidHNcIlxuICBdO1xuICB2YXIgaW50ZXJwcmV0ZXJzJDEgPSBbXG4gIFx0XCJkZW5vXCIsXG4gIFx0XCJ0cy1ub2RlXCJcbiAgXTtcbiAgdmFyIGV4dGVuc2lvbnMkYSA9IFtcbiAgXHRcIi50c1wiXG4gIF07XG4gIHZhciB0bVNjb3BlJGEgPSBcInNvdXJjZS50c1wiO1xuICB2YXIgYWNlTW9kZSRhID0gXCJ0eXBlc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSQ2ID0gXCJqYXZhc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTWltZVR5cGUkNiA9IFwiYXBwbGljYXRpb24vdHlwZXNjcmlwdFwiO1xuICB2YXIgbGFuZ3VhZ2VJZCRhID0gMzc4O1xuICB2YXIgVHlwZVNjcmlwdCA9IHtcbiAgXHRuYW1lOiBuYW1lJGIsXG4gIFx0dHlwZTogdHlwZSRhLFxuICBcdGNvbG9yOiBjb2xvciQ0LFxuICBcdGFsaWFzZXM6IGFsaWFzZXMkMyxcbiAgXHRpbnRlcnByZXRlcnM6IGludGVycHJldGVycyQxLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkYSxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJGEsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSRhLFxuICBcdGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQ2LFxuICBcdGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDYsXG4gIFx0bGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCRhXG4gIH07XG5cbiAgdmFyIFR5cGVTY3JpcHQkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSRiLFxuICAgIHR5cGU6IHR5cGUkYSxcbiAgICBjb2xvcjogY29sb3IkNCxcbiAgICBhbGlhc2VzOiBhbGlhc2VzJDMsXG4gICAgaW50ZXJwcmV0ZXJzOiBpbnRlcnByZXRlcnMkMSxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJGEsXG4gICAgdG1TY29wZTogdG1TY29wZSRhLFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkYSxcbiAgICBjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkNixcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQ2LFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkYSxcbiAgICAnZGVmYXVsdCc6IFR5cGVTY3JpcHRcbiAgfSk7XG5cbiAgdmFyIG5hbWUkYyA9IFwiVFNYXCI7XG4gIHZhciB0eXBlJGIgPSBcInByb2dyYW1taW5nXCI7XG4gIHZhciBncm91cCRkID0gXCJUeXBlU2NyaXB0XCI7XG4gIHZhciBleHRlbnNpb25zJGIgPSBbXG4gIFx0XCIudHN4XCJcbiAgXTtcbiAgdmFyIHRtU2NvcGUkYiA9IFwic291cmNlLnRzeFwiO1xuICB2YXIgYWNlTW9kZSRiID0gXCJqYXZhc2NyaXB0XCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSQ3ID0gXCJqc3hcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSQ3ID0gXCJ0ZXh0L2pzeFwiO1xuICB2YXIgbGFuZ3VhZ2VJZCRiID0gOTQ5MDE5MjQ7XG4gIHZhciBUU1ggPSB7XG4gIFx0bmFtZTogbmFtZSRjLFxuICBcdHR5cGU6IHR5cGUkYixcbiAgXHRncm91cDogZ3JvdXAkZCxcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJGIsXG4gIFx0dG1TY29wZTogdG1TY29wZSRiLFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkYixcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkNyxcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQ3LFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkYlxuICB9O1xuXG4gIHZhciBUU1gkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSRjLFxuICAgIHR5cGU6IHR5cGUkYixcbiAgICBncm91cDogZ3JvdXAkZCxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJGIsXG4gICAgdG1TY29wZTogdG1TY29wZSRiLFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkYixcbiAgICBjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkNyxcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQ3LFxuICAgIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkYixcbiAgICAnZGVmYXVsdCc6IFRTWFxuICB9KTtcblxuICB2YXIgbmFtZSRkID0gXCJKU09OXCI7XG4gIHZhciB0eXBlJGMgPSBcImRhdGFcIjtcbiAgdmFyIHRtU2NvcGUkYyA9IFwic291cmNlLmpzb25cIjtcbiAgdmFyIGFjZU1vZGUkYyA9IFwianNvblwiO1xuICB2YXIgY29kZW1pcnJvck1vZGUkOCA9IFwiamF2YXNjcmlwdFwiO1xuICB2YXIgY29kZW1pcnJvck1pbWVUeXBlJDggPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgdmFyIHNlYXJjaGFibGUgPSBmYWxzZTtcbiAgdmFyIGV4dGVuc2lvbnMkYyA9IFtcbiAgXHRcIi5qc29uXCIsXG4gIFx0XCIuYXZzY1wiLFxuICBcdFwiLmdlb2pzb25cIixcbiAgXHRcIi5nbHRmXCIsXG4gIFx0XCIuaGFyXCIsXG4gIFx0XCIuaWNlXCIsXG4gIFx0XCIuSlNPTi10bUxhbmd1YWdlXCIsXG4gIFx0XCIuanNvbmxcIixcbiAgXHRcIi5tY21ldGFcIixcbiAgXHRcIi50ZnN0YXRlXCIsXG4gIFx0XCIudGZzdGF0ZS5iYWNrdXBcIixcbiAgXHRcIi50b3BvanNvblwiLFxuICBcdFwiLndlYmFwcFwiLFxuICBcdFwiLndlYm1hbmlmZXN0XCIsXG4gIFx0XCIueXlcIixcbiAgXHRcIi55eXBcIlxuICBdO1xuICB2YXIgZmlsZW5hbWVzJDEgPSBbXG4gIFx0XCIuYXJjY29uZmlnXCIsXG4gIFx0XCIuaHRtbGhpbnRyY1wiLFxuICBcdFwiLnRlcm4tY29uZmlnXCIsXG4gIFx0XCIudGVybi1wcm9qZWN0XCIsXG4gIFx0XCIud2F0Y2htYW5jb25maWdcIixcbiAgXHRcImNvbXBvc2VyLmxvY2tcIixcbiAgXHRcIm1jbW9kLmluZm9cIlxuICBdO1xuICB2YXIgbGFuZ3VhZ2VJZCRjID0gMTc0O1xuICB2YXIgX0pTT04gPSB7XG4gIFx0bmFtZTogbmFtZSRkLFxuICBcdHR5cGU6IHR5cGUkYyxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJGMsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSRjLFxuICBcdGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQ4LFxuICBcdGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDgsXG4gIFx0c2VhcmNoYWJsZTogc2VhcmNoYWJsZSxcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJGMsXG4gIFx0ZmlsZW5hbWVzOiBmaWxlbmFtZXMkMSxcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGNcbiAgfTtcblxuICB2YXIgX0pTT04kMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgbmFtZTogbmFtZSRkLFxuICAgIHR5cGU6IHR5cGUkYyxcbiAgICB0bVNjb3BlOiB0bVNjb3BlJGMsXG4gICAgYWNlTW9kZTogYWNlTW9kZSRjLFxuICAgIGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSQ4LFxuICAgIGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJDgsXG4gICAgc2VhcmNoYWJsZTogc2VhcmNoYWJsZSxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJGMsXG4gICAgZmlsZW5hbWVzOiBmaWxlbmFtZXMkMSxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGMsXG4gICAgJ2RlZmF1bHQnOiBfSlNPTlxuICB9KTtcblxuICB2YXIgbmFtZSRlID0gXCJKU09OIHdpdGggQ29tbWVudHNcIjtcbiAgdmFyIHR5cGUkZCA9IFwiZGF0YVwiO1xuICB2YXIgZ3JvdXAkZSA9IFwiSlNPTlwiO1xuICB2YXIgdG1TY29wZSRkID0gXCJzb3VyY2UuanNcIjtcbiAgdmFyIGFjZU1vZGUkZCA9IFwiamF2YXNjcmlwdFwiO1xuICB2YXIgY29kZW1pcnJvck1vZGUkOSA9IFwiamF2YXNjcmlwdFwiO1xuICB2YXIgY29kZW1pcnJvck1pbWVUeXBlJDkgPSBcInRleHQvamF2YXNjcmlwdFwiO1xuICB2YXIgYWxpYXNlcyQ0ID0gW1xuICBcdFwianNvbmNcIlxuICBdO1xuICB2YXIgZXh0ZW5zaW9ucyRkID0gW1xuICBcdFwiLmpzb25jXCIsXG4gIFx0XCIuc3VibGltZS1idWlsZFwiLFxuICBcdFwiLnN1YmxpbWUtY29tbWFuZHNcIixcbiAgXHRcIi5zdWJsaW1lLWNvbXBsZXRpb25zXCIsXG4gIFx0XCIuc3VibGltZS1rZXltYXBcIixcbiAgXHRcIi5zdWJsaW1lLW1hY3JvXCIsXG4gIFx0XCIuc3VibGltZS1tZW51XCIsXG4gIFx0XCIuc3VibGltZS1tb3VzZW1hcFwiLFxuICBcdFwiLnN1YmxpbWUtcHJvamVjdFwiLFxuICBcdFwiLnN1YmxpbWUtc2V0dGluZ3NcIixcbiAgXHRcIi5zdWJsaW1lLXRoZW1lXCIsXG4gIFx0XCIuc3VibGltZS13b3Jrc3BhY2VcIixcbiAgXHRcIi5zdWJsaW1lX21ldHJpY3NcIixcbiAgXHRcIi5zdWJsaW1lX3Nlc3Npb25cIlxuICBdO1xuICB2YXIgZmlsZW5hbWVzJDIgPSBbXG4gIFx0XCIuYmFiZWxyY1wiLFxuICBcdFwiLmVzbGludHJjLmpzb25cIixcbiAgXHRcIi5qc2NzcmNcIixcbiAgXHRcIi5qc2hpbnRyY1wiLFxuICBcdFwiLmpzbGludHJjXCIsXG4gIFx0XCJqc2NvbmZpZy5qc29uXCIsXG4gIFx0XCJsYW5ndWFnZS1jb25maWd1cmF0aW9uLmpzb25cIixcbiAgXHRcInRzY29uZmlnLmpzb25cIlxuICBdO1xuICB2YXIgbGFuZ3VhZ2VJZCRkID0gNDIzO1xuICB2YXIgSlNPTl93aXRoX0NvbW1lbnRzID0ge1xuICBcdG5hbWU6IG5hbWUkZSxcbiAgXHR0eXBlOiB0eXBlJGQsXG4gIFx0Z3JvdXA6IGdyb3VwJGUsXG4gIFx0dG1TY29wZTogdG1TY29wZSRkLFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkZCxcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkOSxcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQ5LFxuICBcdGFsaWFzZXM6IGFsaWFzZXMkNCxcbiAgXHRleHRlbnNpb25zOiBleHRlbnNpb25zJGQsXG4gIFx0ZmlsZW5hbWVzOiBmaWxlbmFtZXMkMixcbiAgXHRsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGRcbiAgfTtcblxuICB2YXIgSlNPTl93aXRoX0NvbW1lbnRzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkZSxcbiAgICB0eXBlOiB0eXBlJGQsXG4gICAgZ3JvdXA6IGdyb3VwJGUsXG4gICAgdG1TY29wZTogdG1TY29wZSRkLFxuICAgIGFjZU1vZGU6IGFjZU1vZGUkZCxcbiAgICBjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkOSxcbiAgICBjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSQ5LFxuICAgIGFsaWFzZXM6IGFsaWFzZXMkNCxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJGQsXG4gICAgZmlsZW5hbWVzOiBmaWxlbmFtZXMkMixcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGQsXG4gICAgJ2RlZmF1bHQnOiBKU09OX3dpdGhfQ29tbWVudHNcbiAgfSk7XG5cbiAgdmFyIG5hbWUkZiA9IFwiSlNPTjVcIjtcbiAgdmFyIHR5cGUkZSA9IFwiZGF0YVwiO1xuICB2YXIgZXh0ZW5zaW9ucyRlID0gW1xuICBcdFwiLmpzb241XCJcbiAgXTtcbiAgdmFyIHRtU2NvcGUkZSA9IFwic291cmNlLmpzXCI7XG4gIHZhciBhY2VNb2RlJGUgPSBcImphdmFzY3JpcHRcIjtcbiAgdmFyIGNvZGVtaXJyb3JNb2RlJGEgPSBcImphdmFzY3JpcHRcIjtcbiAgdmFyIGNvZGVtaXJyb3JNaW1lVHlwZSRhID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gIHZhciBsYW5ndWFnZUlkJGUgPSAxNzU7XG4gIHZhciBKU09ONSA9IHtcbiAgXHRuYW1lOiBuYW1lJGYsXG4gIFx0dHlwZTogdHlwZSRlLFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkZSxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJGUsXG4gIFx0YWNlTW9kZTogYWNlTW9kZSRlLFxuICBcdGNvZGVtaXJyb3JNb2RlOiBjb2RlbWlycm9yTW9kZSRhLFxuICBcdGNvZGVtaXJyb3JNaW1lVHlwZTogY29kZW1pcnJvck1pbWVUeXBlJGEsXG4gIFx0bGFuZ3VhZ2VJZDogbGFuZ3VhZ2VJZCRlXG4gIH07XG5cbiAgdmFyIEpTT041JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkZixcbiAgICB0eXBlOiB0eXBlJGUsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyRlLFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkZSxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJGUsXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJGEsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkYSxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGUsXG4gICAgJ2RlZmF1bHQnOiBKU09ONVxuICB9KTtcblxuICB2YXIgcmVxdWlyZSQkMCQ2ID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShKYXZhU2NyaXB0JDEpO1xuXG4gIHZhciByZXF1aXJlJCQxJDIgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKEpTWCQxKTtcblxuICB2YXIgcmVxdWlyZSQkMiQxID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShUeXBlU2NyaXB0JDEpO1xuXG4gIHZhciByZXF1aXJlJCQzJDEgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKFRTWCQxKTtcblxuICB2YXIgcmVxdWlyZSQkNCA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoX0pTT04kMSk7XG5cbiAgdmFyIHJlcXVpcmUkJDUgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKEpTT05fd2l0aF9Db21tZW50cyQxKTtcblxuICB2YXIgcmVxdWlyZSQkNiA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoSlNPTjUkMSk7XG5cbiAgY29uc3QgbGFuZ3VhZ2VzJDQgPSBbY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMCQ2LCBkYXRhID0+ICh7XG4gICAgc2luY2U6IFwiMC4wLjBcIixcbiAgICBwYXJzZXJzOiBbXCJiYWJlbFwiLCBcImZsb3dcIl0sXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImphdmFzY3JpcHRcIiwgXCJtb25nb1wiXSxcbiAgICBpbnRlcnByZXRlcnM6IGRhdGEuaW50ZXJwcmV0ZXJzLmNvbmNhdChbXCJub2RlanNcIl0pXG4gIH0pKSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMCQ2LCAoKSA9PiAoe1xuICAgIG5hbWU6IFwiRmxvd1wiLFxuICAgIHNpbmNlOiBcIjAuMC4wXCIsXG4gICAgcGFyc2VyczogW1wiYmFiZWxcIiwgXCJmbG93XCJdLFxuICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJqYXZhc2NyaXB0XCJdLFxuICAgIGFsaWFzZXM6IFtdLFxuICAgIGZpbGVuYW1lczogW10sXG4gICAgZXh0ZW5zaW9uczogW1wiLmpzLmZsb3dcIl1cbiAgfSkpLCBjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQxJDIsICgpID0+ICh7XG4gICAgc2luY2U6IFwiMC4wLjBcIixcbiAgICBwYXJzZXJzOiBbXCJiYWJlbFwiLCBcImZsb3dcIl0sXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImphdmFzY3JpcHRyZWFjdFwiXVxuICB9KSksIGNyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDIkMSwgKCkgPT4gKHtcbiAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgIHBhcnNlcnM6IFtcInR5cGVzY3JpcHRcIiwgXCJiYWJlbC10c1wiXSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1widHlwZXNjcmlwdFwiXVxuICB9KSksIGNyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDMkMSwgKCkgPT4gKHtcbiAgICBzaW5jZTogXCIxLjQuMFwiLFxuICAgIHBhcnNlcnM6IFtcInR5cGVzY3JpcHRcIiwgXCJiYWJlbC10c1wiXSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1widHlwZXNjcmlwdHJlYWN0XCJdXG4gIH0pKSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkNCwgKCkgPT4gKHtcbiAgICBuYW1lOiBcIkpTT04uc3RyaW5naWZ5XCIsXG4gICAgc2luY2U6IFwiMS4xMy4wXCIsXG4gICAgcGFyc2VyczogW1wianNvbi1zdHJpbmdpZnlcIl0sXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImpzb25cIl0sXG4gICAgZXh0ZW5zaW9uczogW10sXG4gICAgLy8gLmpzb24gZmlsZSBkZWZhdWx0cyB0byBqc29uIGluc3RlYWQgb2YganNvbi1zdHJpbmdpZnlcbiAgICBmaWxlbmFtZXM6IFtcInBhY2thZ2UuanNvblwiLCBcInBhY2thZ2UtbG9jay5qc29uXCIsIFwiY29tcG9zZXIuanNvblwiXVxuICB9KSksIGNyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDQsIGRhdGEgPT4gKHtcbiAgICBzaW5jZTogXCIxLjUuMFwiLFxuICAgIHBhcnNlcnM6IFtcImpzb25cIl0sXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImpzb25cIl0sXG4gICAgZmlsZW5hbWVzOiBkYXRhLmZpbGVuYW1lcy5jb25jYXQoW1wiLnByZXR0aWVycmNcIl0pXG4gIH0pKSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkNSwgZGF0YSA9PiAoe1xuICAgIHNpbmNlOiBcIjEuNS4wXCIsXG4gICAgcGFyc2VyczogW1wianNvblwiXSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wianNvbmNcIl0sXG4gICAgZmlsZW5hbWVzOiBkYXRhLmZpbGVuYW1lcy5jb25jYXQoW1wiLmVzbGludHJjXCJdKVxuICB9KSksIGNyZWF0ZUxhbmd1YWdlKHJlcXVpcmUkJDYsICgpID0+ICh7XG4gICAgc2luY2U6IFwiMS4xMy4wXCIsXG4gICAgcGFyc2VyczogW1wianNvbjVcIl0sXG4gICAgdnNjb2RlTGFuZ3VhZ2VJZHM6IFtcImpzb241XCJdXG4gIH0pKV07XG4gIGNvbnN0IHByaW50ZXJzJDQgPSB7XG4gICAgZXN0cmVlOiBwcmludGVyRXN0cmVlLFxuICAgIFwiZXN0cmVlLWpzb25cIjogcHJpbnRlckVzdHJlZUpzb25cbiAgfTtcbiAgdmFyIGxhbmd1YWdlSnMgPSB7XG4gICAgbGFuZ3VhZ2VzOiBsYW5ndWFnZXMkNCxcbiAgICBvcHRpb25zOiBvcHRpb25zJDUsXG4gICAgcHJpbnRlcnM6IHByaW50ZXJzJDRcbiAgfTtcblxuICB2YXIganNvbiQxID0ge1xuICAgIFwiY2prUGF0dGVyblwiOiBcIltcXFxcdTAyZWEtXFxcXHUwMmViXFxcXHUxMTAwLVxcXFx1MTFmZlxcXFx1MmU4MC1cXFxcdTJlOTlcXFxcdTJlOWItXFxcXHUyZWYzXFxcXHUyZjAwLVxcXFx1MmZkNVxcXFx1MzAwMC1cXFxcdTMwM2ZcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDk5LVxcXFx1MzA5ZlxcXFx1MzBhMS1cXFxcdTMwZmFcXFxcdTMwZmMtXFxcXHUzMGZmXFxcXHUzMTA1LVxcXFx1MzEyZlxcXFx1MzEzMS1cXFxcdTMxOGVcXFxcdTMxOTAtXFxcXHUzMTkxXFxcXHUzMTk2LVxcXFx1MzFiYVxcXFx1MzFjMC1cXFxcdTMxZTNcXFxcdTMxZjAtXFxcXHUzMjFlXFxcXHUzMjJhLVxcXFx1MzI0N1xcXFx1MzI2MC1cXFxcdTMyN2VcXFxcdTMyOGEtXFxcXHUzMmIwXFxcXHUzMmMwLVxcXFx1MzJjYlxcXFx1MzJkMC1cXFxcdTMzNzBcXFxcdTMzN2ItXFxcXHUzMzdmXFxcXHUzM2UwLVxcXFx1MzNmZVxcXFx1MzQwMC1cXFxcdTRkYjVcXFxcdTRlMDAtXFxcXHU5ZmVmXFxcXHVhOTYwLVxcXFx1YTk3Y1xcXFx1YWMwMC1cXFxcdWQ3YTNcXFxcdWQ3YjAtXFxcXHVkN2M2XFxcXHVkN2NiLVxcXFx1ZDdmYlxcXFx1ZjkwMC1cXFxcdWZhNmRcXFxcdWZhNzAtXFxcXHVmYWQ5XFxcXHVmZTEwLVxcXFx1ZmUxZlxcXFx1ZmUzMC1cXFxcdWZlNmZcXFxcdWZmMDAtXFxcXHVmZmVmXXxbXFxcXHVkODQwLVxcXFx1ZDg2OFxcXFx1ZDg2YS1cXFxcdWQ4NmNcXFxcdWQ4NmYtXFxcXHVkODcyXFxcXHVkODc0LVxcXFx1ZDg3OV1bXFxcXHVkYzAwLVxcXFx1ZGZmZl18XFxcXHVkODJjW1xcXFx1ZGMwMC1cXFxcdWRkMWVcXFxcdWRkNTAtXFxcXHVkZDUyXFxcXHVkZDY0LVxcXFx1ZGQ2N118XFxcXHVkODNjW1xcXFx1ZGUwMFxcXFx1ZGU1MC1cXFxcdWRlNTFdfFxcXFx1ZDg2OVtcXFxcdWRjMDAtXFxcXHVkZWQ2XFxcXHVkZjAwLVxcXFx1ZGZmZl18XFxcXHVkODZkW1xcXFx1ZGMwMC1cXFxcdWRmMzRcXFxcdWRmNDAtXFxcXHVkZmZmXXxcXFxcdWQ4NmVbXFxcXHVkYzAwLVxcXFx1ZGMxZFxcXFx1ZGMyMC1cXFxcdWRmZmZdfFxcXFx1ZDg3M1tcXFxcdWRjMDAtXFxcXHVkZWExXFxcXHVkZWIwLVxcXFx1ZGZmZl18XFxcXHVkODdhW1xcXFx1ZGMwMC1cXFxcdWRmZTBdfFxcXFx1ZDg3ZVtcXFxcdWRjMDAtXFxcXHVkZTFkXVwiLFxuICAgIFwia1BhdHRlcm5cIjogXCJbXFxcXHUxMTAwLVxcXFx1MTFmZlxcXFx1MzAwMS1cXFxcdTMwMDNcXFxcdTMwMDgtXFxcXHUzMDExXFxcXHUzMDEzLVxcXFx1MzAxZlxcXFx1MzAyZS1cXFxcdTMwMzBcXFxcdTMwMzdcXFxcdTMwZmJcXFxcdTMxMzEtXFxcXHUzMThlXFxcXHUzMjAwLVxcXFx1MzIxZVxcXFx1MzI2MC1cXFxcdTMyN2VcXFxcdWE5NjAtXFxcXHVhOTdjXFxcXHVhYzAwLVxcXFx1ZDdhM1xcXFx1ZDdiMC1cXFxcdWQ3YzZcXFxcdWQ3Y2ItXFxcXHVkN2ZiXFxcXHVmZTQ1LVxcXFx1ZmU0NlxcXFx1ZmY2MS1cXFxcdWZmNjVcXFxcdWZmYTAtXFxcXHVmZmJlXFxcXHVmZmMyLVxcXFx1ZmZjN1xcXFx1ZmZjYS1cXFxcdWZmY2ZcXFxcdWZmZDItXFxcXHVmZmQ3XFxcXHVmZmRhLVxcXFx1ZmZkY11cIixcbiAgICBcInB1bmN0dWF0aW9uUGF0dGVyblwiOiBcIltcXFxcdTAwMjEtXFxcXHUwMDJmXFxcXHUwMDNhLVxcXFx1MDA0MFxcXFx1MDA1Yi1cXFxcdTAwNjBcXFxcdTAwN2ItXFxcXHUwMDdlXFxcXHUwMGExXFxcXHUwMGE3XFxcXHUwMGFiXFxcXHUwMGI2LVxcXFx1MDBiN1xcXFx1MDBiYlxcXFx1MDBiZlxcXFx1MDM3ZVxcXFx1MDM4N1xcXFx1MDU1YS1cXFxcdTA1NWZcXFxcdTA1ODktXFxcXHUwNThhXFxcXHUwNWJlXFxcXHUwNWMwXFxcXHUwNWMzXFxcXHUwNWM2XFxcXHUwNWYzLVxcXFx1MDVmNFxcXFx1MDYwOS1cXFxcdTA2MGFcXFxcdTA2MGMtXFxcXHUwNjBkXFxcXHUwNjFiXFxcXHUwNjFlLVxcXFx1MDYxZlxcXFx1MDY2YS1cXFxcdTA2NmRcXFxcdTA2ZDRcXFxcdTA3MDAtXFxcXHUwNzBkXFxcXHUwN2Y3LVxcXFx1MDdmOVxcXFx1MDgzMC1cXFxcdTA4M2VcXFxcdTA4NWVcXFxcdTA5NjQtXFxcXHUwOTY1XFxcXHUwOTcwXFxcXHUwOWZkXFxcXHUwYTc2XFxcXHUwYWYwXFxcXHUwYzc3XFxcXHUwYzg0XFxcXHUwZGY0XFxcXHUwZTRmXFxcXHUwZTVhLVxcXFx1MGU1YlxcXFx1MGYwNC1cXFxcdTBmMTJcXFxcdTBmMTRcXFxcdTBmM2EtXFxcXHUwZjNkXFxcXHUwZjg1XFxcXHUwZmQwLVxcXFx1MGZkNFxcXFx1MGZkOS1cXFxcdTBmZGFcXFxcdTEwNGEtXFxcXHUxMDRmXFxcXHUxMGZiXFxcXHUxMzYwLVxcXFx1MTM2OFxcXFx1MTQwMFxcXFx1MTY2ZVxcXFx1MTY5Yi1cXFxcdTE2OWNcXFxcdTE2ZWItXFxcXHUxNmVkXFxcXHUxNzM1LVxcXFx1MTczNlxcXFx1MTdkNC1cXFxcdTE3ZDZcXFxcdTE3ZDgtXFxcXHUxN2RhXFxcXHUxODAwLVxcXFx1MTgwYVxcXFx1MTk0NC1cXFxcdTE5NDVcXFxcdTFhMWUtXFxcXHUxYTFmXFxcXHUxYWEwLVxcXFx1MWFhNlxcXFx1MWFhOC1cXFxcdTFhYWRcXFxcdTFiNWEtXFxcXHUxYjYwXFxcXHUxYmZjLVxcXFx1MWJmZlxcXFx1MWMzYi1cXFxcdTFjM2ZcXFxcdTFjN2UtXFxcXHUxYzdmXFxcXHUxY2MwLVxcXFx1MWNjN1xcXFx1MWNkM1xcXFx1MjAxMC1cXFxcdTIwMjdcXFxcdTIwMzAtXFxcXHUyMDQzXFxcXHUyMDQ1LVxcXFx1MjA1MVxcXFx1MjA1My1cXFxcdTIwNWVcXFxcdTIwN2QtXFxcXHUyMDdlXFxcXHUyMDhkLVxcXFx1MjA4ZVxcXFx1MjMwOC1cXFxcdTIzMGJcXFxcdTIzMjktXFxcXHUyMzJhXFxcXHUyNzY4LVxcXFx1Mjc3NVxcXFx1MjdjNS1cXFxcdTI3YzZcXFxcdTI3ZTYtXFxcXHUyN2VmXFxcXHUyOTgzLVxcXFx1Mjk5OFxcXFx1MjlkOC1cXFxcdTI5ZGJcXFxcdTI5ZmMtXFxcXHUyOWZkXFxcXHUyY2Y5LVxcXFx1MmNmY1xcXFx1MmNmZS1cXFxcdTJjZmZcXFxcdTJkNzBcXFxcdTJlMDAtXFxcXHUyZTJlXFxcXHUyZTMwLVxcXFx1MmU0ZlxcXFx1MzAwMS1cXFxcdTMwMDNcXFxcdTMwMDgtXFxcXHUzMDExXFxcXHUzMDE0LVxcXFx1MzAxZlxcXFx1MzAzMFxcXFx1MzAzZFxcXFx1MzBhMFxcXFx1MzBmYlxcXFx1YTRmZS1cXFxcdWE0ZmZcXFxcdWE2MGQtXFxcXHVhNjBmXFxcXHVhNjczXFxcXHVhNjdlXFxcXHVhNmYyLVxcXFx1YTZmN1xcXFx1YTg3NC1cXFxcdWE4NzdcXFxcdWE4Y2UtXFxcXHVhOGNmXFxcXHVhOGY4LVxcXFx1YThmYVxcXFx1YThmY1xcXFx1YTkyZS1cXFxcdWE5MmZcXFxcdWE5NWZcXFxcdWE5YzEtXFxcXHVhOWNkXFxcXHVhOWRlLVxcXFx1YTlkZlxcXFx1YWE1Yy1cXFxcdWFhNWZcXFxcdWFhZGUtXFxcXHVhYWRmXFxcXHVhYWYwLVxcXFx1YWFmMVxcXFx1YWJlYlxcXFx1ZmQzZS1cXFxcdWZkM2ZcXFxcdWZlMTAtXFxcXHVmZTE5XFxcXHVmZTMwLVxcXFx1ZmU1MlxcXFx1ZmU1NC1cXFxcdWZlNjFcXFxcdWZlNjNcXFxcdWZlNjhcXFxcdWZlNmEtXFxcXHVmZTZiXFxcXHVmZjAxLVxcXFx1ZmYwM1xcXFx1ZmYwNS1cXFxcdWZmMGFcXFxcdWZmMGMtXFxcXHVmZjBmXFxcXHVmZjFhLVxcXFx1ZmYxYlxcXFx1ZmYxZi1cXFxcdWZmMjBcXFxcdWZmM2ItXFxcXHVmZjNkXFxcXHVmZjNmXFxcXHVmZjViXFxcXHVmZjVkXFxcXHVmZjVmLVxcXFx1ZmY2NV18XFxcXHVkODAwW1xcXFx1ZGQwMC1cXFxcdWRkMDJcXFxcdWRmOWZcXFxcdWRmZDBdfFxcXFx1ZDgwMVtcXFxcdWRkNmZdfFxcXFx1ZDgwMltcXFxcdWRjNTdcXFxcdWRkMWZcXFxcdWRkM2ZcXFxcdWRlNTAtXFxcXHVkZTU4XFxcXHVkZTdmXFxcXHVkZWYwLVxcXFx1ZGVmNlxcXFx1ZGYzOS1cXFxcdWRmM2ZcXFxcdWRmOTktXFxcXHVkZjljXXxcXFxcdWQ4MDNbXFxcXHVkZjU1LVxcXFx1ZGY1OV18XFxcXHVkODA0W1xcXFx1ZGM0Ny1cXFxcdWRjNGRcXFxcdWRjYmItXFxcXHVkY2JjXFxcXHVkY2JlLVxcXFx1ZGNjMVxcXFx1ZGQ0MC1cXFxcdWRkNDNcXFxcdWRkNzQtXFxcXHVkZDc1XFxcXHVkZGM1LVxcXFx1ZGRjOFxcXFx1ZGRjZFxcXFx1ZGRkYlxcXFx1ZGRkZC1cXFxcdWRkZGZcXFxcdWRlMzgtXFxcXHVkZTNkXFxcXHVkZWE5XXxcXFxcdWQ4MDVbXFxcXHVkYzRiLVxcXFx1ZGM0ZlxcXFx1ZGM1YlxcXFx1ZGM1ZFxcXFx1ZGNjNlxcXFx1ZGRjMS1cXFxcdWRkZDdcXFxcdWRlNDEtXFxcXHVkZTQzXFxcXHVkZTYwLVxcXFx1ZGU2Y1xcXFx1ZGYzYy1cXFxcdWRmM2VdfFxcXFx1ZDgwNltcXFxcdWRjM2JcXFxcdWRkZTJcXFxcdWRlM2YtXFxcXHVkZTQ2XFxcXHVkZTlhLVxcXFx1ZGU5Y1xcXFx1ZGU5ZS1cXFxcdWRlYTJdfFxcXFx1ZDgwN1tcXFxcdWRjNDEtXFxcXHVkYzQ1XFxcXHVkYzcwLVxcXFx1ZGM3MVxcXFx1ZGVmNy1cXFxcdWRlZjhcXFxcdWRmZmZdfFxcXFx1ZDgwOVtcXFxcdWRjNzAtXFxcXHVkYzc0XXxcXFxcdWQ4MWFbXFxcXHVkZTZlLVxcXFx1ZGU2ZlxcXFx1ZGVmNVxcXFx1ZGYzNy1cXFxcdWRmM2JcXFxcdWRmNDRdfFxcXFx1ZDgxYltcXFxcdWRlOTctXFxcXHVkZTlhXFxcXHVkZmUyXXxcXFxcdWQ4MmZbXFxcXHVkYzlmXXxcXFxcdWQ4MzZbXFxcXHVkZTg3LVxcXFx1ZGU4Yl18XFxcXHVkODNhW1xcXFx1ZGQ1ZS1cXFxcdWRkNWZdXCJcbiAgfTtcblxuICBjb25zdCB7XG4gICAgY2prUGF0dGVybixcbiAgICBrUGF0dGVybixcbiAgICBwdW5jdHVhdGlvblBhdHRlcm5cbiAgfSA9IGpzb24kMTtcbiAgY29uc3Qge1xuICAgIGdldExhc3Q6IGdldExhc3QkNFxuICB9ID0gdXRpbCQxO1xuICBjb25zdCBJTkxJTkVfTk9ERV9UWVBFUyA9IFtcImxpcXVpZE5vZGVcIiwgXCJpbmxpbmVDb2RlXCIsIFwiZW1waGFzaXNcIiwgXCJzdHJvbmdcIiwgXCJkZWxldGVcIiwgXCJsaW5rXCIsIFwibGlua1JlZmVyZW5jZVwiLCBcImltYWdlXCIsIFwiaW1hZ2VSZWZlcmVuY2VcIiwgXCJmb290bm90ZVwiLCBcImZvb3Rub3RlUmVmZXJlbmNlXCIsIFwic2VudGVuY2VcIiwgXCJ3aGl0ZXNwYWNlXCIsIFwid29yZFwiLCBcImJyZWFrXCIsIFwiaW5saW5lTWF0aFwiXTtcbiAgY29uc3QgSU5MSU5FX05PREVfV1JBUFBFUl9UWVBFUyA9IElOTElORV9OT0RFX1RZUEVTLmNvbmNhdChbXCJ0YWJsZUNlbGxcIiwgXCJwYXJhZ3JhcGhcIiwgXCJoZWFkaW5nXCJdKTtcbiAgY29uc3Qga1JlZ2V4ID0gbmV3IFJlZ0V4cChrUGF0dGVybik7XG4gIGNvbnN0IHB1bmN0dWF0aW9uUmVnZXggPSBuZXcgUmVnRXhwKHB1bmN0dWF0aW9uUGF0dGVybik7XG4gIC8qKlxuICAgKiBzcGxpdCB0ZXh0IGludG8gd2hpdGVzcGFjZXMgYW5kIHdvcmRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge0FycmF5PHsgdHlwZTogXCJ3aGl0ZXNwYWNlXCIsIHZhbHVlOiBcIiBcIiB8IFwiXFxuXCIgfCBcIlwiIH0gfCB7IHR5cGU6IFwid29yZFwiLCB2YWx1ZTogc3RyaW5nIH0+fVxuICAgKi9cblxuICBmdW5jdGlvbiBzcGxpdFRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IEtJTkRfTk9OX0NKSyA9IFwibm9uLWNqa1wiO1xuICAgIGNvbnN0IEtJTkRfQ0pfTEVUVEVSID0gXCJjai1sZXR0ZXJcIjtcbiAgICBjb25zdCBLSU5EX0tfTEVUVEVSID0gXCJrLWxldHRlclwiO1xuICAgIGNvbnN0IEtJTkRfQ0pLX1BVTkNUVUFUSU9OID0gXCJjamstcHVuY3R1YXRpb25cIjtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIChvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJwcmVzZXJ2ZVwiID8gdGV4dCA6IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKFwiKFwiLmNvbmNhdChjamtQYXR0ZXJuLCBcIilcXG4oXCIpLmNvbmNhdChjamtQYXR0ZXJuLCBcIilcIiksIFwiZ1wiKSwgXCIkMSQyXCIpKS5zcGxpdCgvKFsgXFx0XFxuXSspLykuZm9yRWFjaCgodG9rZW4sIGluZGV4LCB0b2tlbnMpID0+IHtcbiAgICAgIC8vIHdoaXRlc3BhY2VcbiAgICAgIGlmIChpbmRleCAlIDIgPT09IDEpIHtcbiAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ3aGl0ZXNwYWNlXCIsXG4gICAgICAgICAgdmFsdWU6IC9cXG4vLnRlc3QodG9rZW4pID8gXCJcXG5cIiA6IFwiIFwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHdvcmQgc2VwYXJhdGVkIGJ5IHdoaXRlc3BhY2VcblxuXG4gICAgICBpZiAoKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSB0b2tlbnMubGVuZ3RoIC0gMSkgJiYgdG9rZW4gPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5zcGxpdChuZXcgUmVnRXhwKFwiKFwiLmNvbmNhdChjamtQYXR0ZXJuLCBcIilcIikpKS5mb3JFYWNoKChpbm5lclRva2VuLCBpbm5lckluZGV4LCBpbm5lclRva2VucykgPT4ge1xuICAgICAgICBpZiAoKGlubmVySW5kZXggPT09IDAgfHwgaW5uZXJJbmRleCA9PT0gaW5uZXJUb2tlbnMubGVuZ3RoIC0gMSkgJiYgaW5uZXJUb2tlbiA9PT0gXCJcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBub24tQ0pLIHdvcmRcblxuXG4gICAgICAgIGlmIChpbm5lckluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgIGlmIChpbm5lclRva2VuICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBhcHBlbmROb2RlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ3b3JkXCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBpbm5lclRva2VuLFxuICAgICAgICAgICAgICBraW5kOiBLSU5EX05PTl9DSkssXG4gICAgICAgICAgICAgIGhhc0xlYWRpbmdQdW5jdHVhdGlvbjogcHVuY3R1YXRpb25SZWdleC50ZXN0KGlubmVyVG9rZW5bMF0pLFxuICAgICAgICAgICAgICBoYXNUcmFpbGluZ1B1bmN0dWF0aW9uOiBwdW5jdHVhdGlvblJlZ2V4LnRlc3QoZ2V0TGFzdCQ0KGlubmVyVG9rZW4pKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIENKSyBjaGFyYWN0ZXJcblxuXG4gICAgICAgIGFwcGVuZE5vZGUocHVuY3R1YXRpb25SZWdleC50ZXN0KGlubmVyVG9rZW4pID8ge1xuICAgICAgICAgIHR5cGU6IFwid29yZFwiLFxuICAgICAgICAgIHZhbHVlOiBpbm5lclRva2VuLFxuICAgICAgICAgIGtpbmQ6IEtJTkRfQ0pLX1BVTkNUVUFUSU9OLFxuICAgICAgICAgIGhhc0xlYWRpbmdQdW5jdHVhdGlvbjogdHJ1ZSxcbiAgICAgICAgICBoYXNUcmFpbGluZ1B1bmN0dWF0aW9uOiB0cnVlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgdHlwZTogXCJ3b3JkXCIsXG4gICAgICAgICAgdmFsdWU6IGlubmVyVG9rZW4sXG4gICAgICAgICAga2luZDoga1JlZ2V4LnRlc3QoaW5uZXJUb2tlbikgPyBLSU5EX0tfTEVUVEVSIDogS0lORF9DSl9MRVRURVIsXG4gICAgICAgICAgaGFzTGVhZGluZ1B1bmN0dWF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBoYXNUcmFpbGluZ1B1bmN0dWF0aW9uOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBub2RlcztcblxuICAgIGZ1bmN0aW9uIGFwcGVuZE5vZGUobm9kZSkge1xuICAgICAgY29uc3QgbGFzdE5vZGUgPSBnZXRMYXN0JDQobm9kZXMpO1xuXG4gICAgICBpZiAobGFzdE5vZGUgJiYgbGFzdE5vZGUudHlwZSA9PT0gXCJ3b3JkXCIpIHtcbiAgICAgICAgaWYgKGxhc3ROb2RlLmtpbmQgPT09IEtJTkRfTk9OX0NKSyAmJiBub2RlLmtpbmQgPT09IEtJTkRfQ0pfTEVUVEVSICYmICFsYXN0Tm9kZS5oYXNUcmFpbGluZ1B1bmN0dWF0aW9uIHx8IGxhc3ROb2RlLmtpbmQgPT09IEtJTkRfQ0pfTEVUVEVSICYmIG5vZGUua2luZCA9PT0gS0lORF9OT05fQ0pLICYmICFub2RlLmhhc0xlYWRpbmdQdW5jdHVhdGlvbikge1xuICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJ3aGl0ZXNwYWNlXCIsXG4gICAgICAgICAgICB2YWx1ZTogXCIgXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNCZXR3ZWVuKEtJTkRfTk9OX0NKSywgS0lORF9DSktfUFVOQ1RVQVRJT04pICYmIC8vIGRpc2FsbG93IGxlYWRpbmcvdHJhaWxpbmcgZnVsbC13aWR0aCB3aGl0ZXNwYWNlXG4gICAgICAgICFbbGFzdE5vZGUudmFsdWUsIG5vZGUudmFsdWVdLnNvbWUodmFsdWUgPT4gL1xcdTMwMDAvLnRlc3QodmFsdWUpKSkge1xuICAgICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJ3aGl0ZXNwYWNlXCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG5cbiAgICAgIGZ1bmN0aW9uIGlzQmV0d2VlbihraW5kMSwga2luZDIpIHtcbiAgICAgICAgcmV0dXJuIGxhc3ROb2RlLmtpbmQgPT09IGtpbmQxICYmIG5vZGUua2luZCA9PT0ga2luZDIgfHwgbGFzdE5vZGUua2luZCA9PT0ga2luZDIgJiYgbm9kZS5raW5kID09PSBraW5kMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvKG9yZGVyTGlzdEl0ZW0sIG9yaWdpbmFsVGV4dCkge1xuICAgIGNvbnN0IFssIG51bWJlclRleHQsIG1hcmtlciwgbGVhZGluZ1NwYWNlc10gPSBvcmlnaW5hbFRleHQuc2xpY2Uob3JkZXJMaXN0SXRlbS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG9yZGVyTGlzdEl0ZW0ucG9zaXRpb24uZW5kLm9mZnNldCkubWF0Y2goL15cXHMqKFxcZCspKFxcLnxcXCkpKFxccyopLyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlclRleHQsXG4gICAgICBtYXJrZXIsXG4gICAgICBsZWFkaW5nU3BhY2VzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0dpdERpZmZGcmllbmRseU9yZGVyZWRMaXN0KG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW5vZGUub3JkZXJlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdE51bWJlciA9IE51bWJlcihnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvKG5vZGUuY2hpbGRyZW5bMF0sIG9wdGlvbnMub3JpZ2luYWxUZXh0KS5udW1iZXJUZXh0KTtcbiAgICBjb25zdCBzZWNvbmROdW1iZXIgPSBOdW1iZXIoZ2V0T3JkZXJlZExpc3RJdGVtSW5mbyhub2RlLmNoaWxkcmVuWzFdLCBvcHRpb25zLm9yaWdpbmFsVGV4dCkubnVtYmVyVGV4dCk7XG5cbiAgICBpZiAoZmlyc3ROdW1iZXIgPT09IDAgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAyKSB7XG4gICAgICBjb25zdCB0aGlyZE51bWJlciA9IE51bWJlcihnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvKG5vZGUuY2hpbGRyZW5bMl0sIG9wdGlvbnMub3JpZ2luYWxUZXh0KS5udW1iZXJUZXh0KTtcbiAgICAgIHJldHVybiBzZWNvbmROdW1iZXIgPT09IDEgJiYgdGhpcmROdW1iZXIgPT09IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY29uZE51bWJlciA9PT0gMTtcbiAgfSAvLyB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vcmVtYXJranMvcmVtYXJrL2lzc3Vlcy8zNTFcbiAgLy8gbGVhZGluZyBhbmQgdHJhaWxpbmcgbmV3bGluZXMgYXJlIHN0cmlwcGVkIGJ5IHJlbWFya1xuXG5cbiAgZnVuY3Rpb24gZ2V0RmVuY2VkQ29kZUJsb2NrVmFsdWUobm9kZSwgb3JpZ2luYWxUZXh0KSB7XG4gICAgY29uc3QgdGV4dCA9IG9yaWdpbmFsVGV4dC5zbGljZShub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCwgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0KTtcbiAgICBjb25zdCBsZWFkaW5nU3BhY2VDb3VudCA9IHRleHQubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoO1xuICAgIGNvbnN0IHJlcGxhY2VSZWdleCA9IG5ldyBSZWdFeHAoXCJeXFxcXHN7MCxcIi5jb25jYXQobGVhZGluZ1NwYWNlQ291bnQsIFwifVwiKSk7XG4gICAgY29uc3QgbGluZUNvbnRlbnRzID0gdGV4dC5zcGxpdChcIlxcblwiKTtcbiAgICBjb25zdCBtYXJrZXJTdHlsZSA9IHRleHRbbGVhZGluZ1NwYWNlQ291bnRdOyAvLyBgIG9yIH5cblxuICAgIGNvbnN0IG1hcmtlciA9IHRleHQuc2xpY2UobGVhZGluZ1NwYWNlQ291bnQpLm1hdGNoKG5ldyBSZWdFeHAoXCJeW1wiLmNvbmNhdChtYXJrZXJTdHlsZSwgXCJdK1wiKSkpWzBdOyAvLyBodHRwczovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4yOC8jZXhhbXBsZS0xMDQ6IENsb3NpbmcgZmVuY2VzIG1heSBiZSBpbmRlbnRlZCBieSAwLTMgc3BhY2VzXG4gICAgLy8gaHR0cHM6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMjgvI2V4YW1wbGUtOTM6IFRoZSBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIGZlbmNlXG5cbiAgICBjb25zdCBoYXNFbmRNYXJrZXIgPSBuZXcgUmVnRXhwKFwiXlxcXFxzezAsM31cIi5jb25jYXQobWFya2VyKSkudGVzdChsaW5lQ29udGVudHNbbGluZUNvbnRlbnRzLmxlbmd0aCAtIDFdLnNsaWNlKGdldEluZGVudChsaW5lQ29udGVudHMubGVuZ3RoIC0gMSkpKTtcbiAgICByZXR1cm4gbGluZUNvbnRlbnRzLnNsaWNlKDEsIGhhc0VuZE1hcmtlciA/IC0xIDogdW5kZWZpbmVkKS5tYXAoKHgsIGkpID0+IHguc2xpY2UoZ2V0SW5kZW50KGkgKyAxKSkucmVwbGFjZShyZXBsYWNlUmVnZXgsIFwiXCIpKS5qb2luKFwiXFxuXCIpO1xuXG4gICAgZnVuY3Rpb24gZ2V0SW5kZW50KGxpbmVJbmRleCkge1xuICAgICAgcmV0dXJuIG5vZGUucG9zaXRpb24uaW5kZW50W2xpbmVJbmRleCAtIDFdIC0gMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXBBc3QoYXN0LCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHByZW9yZGVyKG5vZGUsIGluZGV4LCBwYXJlbnRTdGFjaykge1xuICAgICAgcGFyZW50U3RhY2sgPSBwYXJlbnRTdGFjayB8fCBbXTtcbiAgICAgIGNvbnN0IG5ld05vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBoYW5kbGVyKG5vZGUsIGluZGV4LCBwYXJlbnRTdGFjaykpO1xuXG4gICAgICBpZiAobmV3Tm9kZS5jaGlsZHJlbikge1xuICAgICAgICBuZXdOb2RlLmNoaWxkcmVuID0gbmV3Tm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBpbmRleCkgPT4ge1xuICAgICAgICAgIHJldHVybiBwcmVvcmRlcihjaGlsZCwgaW5kZXgsIFtuZXdOb2RlXS5jb25jYXQocGFyZW50U3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH0oYXN0LCBudWxsLCBudWxsKTtcbiAgfVxuXG4gIHZhciB1dGlscyQ2ID0ge1xuICAgIG1hcEFzdCxcbiAgICBzcGxpdFRleHQsXG4gICAgcHVuY3R1YXRpb25QYXR0ZXJuLFxuICAgIGdldEZlbmNlZENvZGVCbG9ja1ZhbHVlLFxuICAgIGdldE9yZGVyZWRMaXN0SXRlbUluZm8sXG4gICAgaGFzR2l0RGlmZkZyaWVuZGx5T3JkZXJlZExpc3QsXG4gICAgSU5MSU5FX05PREVfVFlQRVMsXG4gICAgSU5MSU5FX05PREVfV1JBUFBFUl9UWVBFU1xuICB9O1xuXG4gIGNvbnN0IHtcbiAgICBidWlsZGVyczoge1xuICAgICAgaGFyZGxpbmU6IGhhcmRsaW5lJGIsXG4gICAgICBsaXRlcmFsbGluZTogbGl0ZXJhbGxpbmUkNSxcbiAgICAgIGNvbmNhdDogY29uY2F0JGYsXG4gICAgICBtYXJrQXNSb290OiBtYXJrQXNSb290JDNcbiAgICB9LFxuICAgIHV0aWxzOiB7XG4gICAgICBtYXBEb2M6IG1hcERvYyQ0XG4gICAgfVxuICB9ID0gZG9jdW1lbnQ7XG4gIGNvbnN0IHtcbiAgICBnZXRGZW5jZWRDb2RlQmxvY2tWYWx1ZTogZ2V0RmVuY2VkQ29kZUJsb2NrVmFsdWUkMVxuICB9ID0gdXRpbHMkNjtcblxuICBmdW5jdGlvbiBlbWJlZCQ0KHBhdGgsIHByaW50LCB0ZXh0VG9Eb2MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJjb2RlXCIgJiYgbm9kZS5sYW5nICE9PSBudWxsKSB7XG4gICAgICAvLyBvbmx5IGxvb2sgZm9yIHRoZSBmaXJzdCBzdHJpbmcgc28gYXMgdG8gc3VwcG9ydCBbbWFya2Rvd24tcHJldmlldy1lbmhhbmNlZF0oaHR0cHM6Ly9zaGQxMDF3eXkuZ2l0aHViLmlvL21hcmtkb3duLXByZXZpZXctZW5oYW5jZWQvIy9jb2RlLWNodW5rKVxuICAgICAgY29uc3QgbGFuZ01hdGNoID0gbm9kZS5sYW5nLm1hdGNoKC9eW0EtWmEtejAtOV8tXSsvKTtcbiAgICAgIGNvbnN0IGxhbmcgPSBsYW5nTWF0Y2ggPyBsYW5nTWF0Y2hbMF0gOiBcIlwiO1xuICAgICAgY29uc3QgcGFyc2VyID0gZ2V0UGFyc2VyTmFtZShsYW5nKTtcblxuICAgICAgaWYgKHBhcnNlcikge1xuICAgICAgICBjb25zdCBzdHlsZVVuaXQgPSBvcHRpb25zLl9faW5Kc1RlbXBsYXRlID8gXCJ+XCIgOiBcImBcIjtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBzdHlsZVVuaXQucmVwZWF0KE1hdGgubWF4KDMsIHV0aWwkMS5nZXRNYXhDb250aW51b3VzQ291bnQobm9kZS52YWx1ZSwgc3R5bGVVbml0KSArIDEpKTtcbiAgICAgICAgY29uc3QgZG9jID0gdGV4dFRvRG9jKGdldEZlbmNlZENvZGVCbG9ja1ZhbHVlJDEobm9kZSwgb3B0aW9ucy5vcmlnaW5hbFRleHQpLCB7XG4gICAgICAgICAgcGFyc2VyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFya0FzUm9vdCQzKGNvbmNhdCRmKFtzdHlsZSwgbm9kZS5sYW5nLCBoYXJkbGluZSRiLCByZXBsYWNlTmV3bGluZXNXaXRoTGl0ZXJhbGxpbmVzKGRvYyksIHN0eWxlXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwieWFtbFwiKSB7XG4gICAgICByZXR1cm4gbWFya0FzUm9vdCQzKGNvbmNhdCRmKFtcIi0tLVwiLCBoYXJkbGluZSRiLCBub2RlLnZhbHVlICYmIG5vZGUudmFsdWUudHJpbSgpID8gcmVwbGFjZU5ld2xpbmVzV2l0aExpdGVyYWxsaW5lcyh0ZXh0VG9Eb2Mobm9kZS52YWx1ZSwge1xuICAgICAgICBwYXJzZXI6IFwieWFtbFwiXG4gICAgICB9KSkgOiBcIlwiLCBcIi0tLVwiXSkpO1xuICAgIH0gLy8gTURYXG5cblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiaW1wb3J0RXhwb3J0XCI6XG4gICAgICAgIHJldHVybiB0ZXh0VG9Eb2Mobm9kZS52YWx1ZSwge1xuICAgICAgICAgIHBhcnNlcjogXCJiYWJlbFwiXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlIFwianN4XCI6XG4gICAgICAgIHJldHVybiB0ZXh0VG9Eb2MoXCI8JD5cIi5jb25jYXQobm9kZS52YWx1ZSwgXCI8LyQ+XCIpLCB7XG4gICAgICAgICAgcGFyc2VyOiBcIl9fanNfZXhwcmVzc2lvblwiLFxuICAgICAgICAgIHJvb3RNYXJrZXI6IFwibWR4XCJcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZXJOYW1lKGxhbmcpIHtcbiAgICAgIGNvbnN0IHN1cHBvcnRJbmZvID0gc3VwcG9ydC5nZXRTdXBwb3J0SW5mbyh7XG4gICAgICAgIHBsdWdpbnM6IG9wdGlvbnMucGx1Z2luc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBsYW5ndWFnZSA9IHN1cHBvcnRJbmZvLmxhbmd1YWdlcy5maW5kKGxhbmd1YWdlID0+IGxhbmd1YWdlLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbGFuZyB8fCBsYW5ndWFnZS5hbGlhc2VzICYmIGxhbmd1YWdlLmFsaWFzZXMuaW5jbHVkZXMobGFuZykgfHwgbGFuZ3VhZ2UuZXh0ZW5zaW9ucyAmJiBsYW5ndWFnZS5leHRlbnNpb25zLmZpbmQoZXh0ID0+IGV4dCA9PT0gXCIuXCIuY29uY2F0KGxhbmcpKSk7XG5cbiAgICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2UucGFyc2Vyc1swXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmVzV2l0aExpdGVyYWxsaW5lcyhkb2MpIHtcbiAgICAgIHJldHVybiBtYXBEb2MkNChkb2MsIGN1cnJlbnREb2MgPT4gdHlwZW9mIGN1cnJlbnREb2MgPT09IFwic3RyaW5nXCIgJiYgY3VycmVudERvYy5pbmNsdWRlcyhcIlxcblwiKSA/IGNvbmNhdCRmKGN1cnJlbnREb2Muc3BsaXQoLyhcXG4pL2cpLm1hcCgodiwgaSkgPT4gaSAlIDIgPT09IDAgPyB2IDogbGl0ZXJhbGxpbmUkNSkpIDogY3VycmVudERvYyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVtYmVkXzEkMiA9IGVtYmVkJDQ7XG5cbiAgY29uc3QgcHJhZ21hcyA9IFtcImZvcm1hdFwiLCBcInByZXR0aWVyXCJdO1xuXG4gIGZ1bmN0aW9uIHN0YXJ0V2l0aFByYWdtYSh0ZXh0KSB7XG4gICAgY29uc3QgcHJhZ21hID0gXCJAKFwiLmNvbmNhdChwcmFnbWFzLmpvaW4oXCJ8XCIpLCBcIilcIik7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKFtcIjwhLS1cXFxccypcIi5jb25jYXQocHJhZ21hLCBcIlxcXFxzKi0tPlwiKSwgXCI8IS0tLipcXHI/XFxuW1xcXFxzXFxcXFNdKihefFxcbilbXlxcXFxTXFxuXSpcIi5jb25jYXQocHJhZ21hLCBcIlteXFxcXFNcXG5dKigkfFxcbilbXFxcXHNcXFxcU10qXFxuLiotLT5cIildLmpvaW4oXCJ8XCIpLCBcIm1cIik7XG4gICAgY29uc3QgbWF0Y2hlZCA9IHRleHQubWF0Y2gocmVnZXgpO1xuICAgIHJldHVybiBtYXRjaGVkICYmIG1hdGNoZWQuaW5kZXggPT09IDA7XG4gIH1cblxuICB2YXIgcHJhZ21hJDQgPSB7XG4gICAgc3RhcnRXaXRoUHJhZ21hLFxuICAgIGhhc1ByYWdtYTogdGV4dCA9PiBzdGFydFdpdGhQcmFnbWEoZnJvbnRNYXR0ZXIodGV4dCkuY29udGVudC50cmltU3RhcnQoKSksXG4gICAgaW5zZXJ0UHJhZ21hOiB0ZXh0ID0+IHtcbiAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IGZyb250TWF0dGVyKHRleHQpO1xuICAgICAgY29uc3QgcHJhZ21hID0gXCI8IS0tIEBcIi5jb25jYXQocHJhZ21hc1swXSwgXCIgLS0+XCIpO1xuICAgICAgcmV0dXJuIGV4dHJhY3RlZC5mcm9udE1hdHRlciA/IFwiXCIuY29uY2F0KGV4dHJhY3RlZC5mcm9udE1hdHRlci5yYXcsIFwiXFxuXFxuXCIpLmNvbmNhdChwcmFnbWEsIFwiXFxuXFxuXCIpLmNvbmNhdChleHRyYWN0ZWQuY29udGVudCkgOiBcIlwiLmNvbmNhdChwcmFnbWEsIFwiXFxuXFxuXCIpLmNvbmNhdChleHRyYWN0ZWQuY29udGVudCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHtcbiAgICBnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvOiBnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvJDEsXG4gICAgbWFwQXN0OiBtYXBBc3QkMSxcbiAgICBzcGxpdFRleHQ6IHNwbGl0VGV4dCQxXG4gIH0gPSB1dGlscyQ2OyAvLyAweDAgfiAweDEwZmZmZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuXG4gIGNvbnN0IGlzU2luZ2xlQ2hhclJlZ2V4ID0gL14oW1xcdTAwMDAtXFx1ZmZmZl18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSkkLztcblxuICBmdW5jdGlvbiBwcmVwcm9jZXNzJDIoYXN0LCBvcHRpb25zKSB7XG4gICAgYXN0ID0gcmVzdG9yZVVuZXNjYXBlZENoYXJhY3Rlcihhc3QsIG9wdGlvbnMpO1xuICAgIGFzdCA9IG1lcmdlQ29udGludW91c1RleHRzKGFzdCk7XG4gICAgYXN0ID0gdHJhbnNmb3JtSW5saW5lQ29kZShhc3QpO1xuICAgIGFzdCA9IHRyYW5zZm9ybUluZGVudGVkQ29kZWJsb2NrQW5kTWFya0l0c1BhcmVudExpc3QoYXN0LCBvcHRpb25zKTtcbiAgICBhc3QgPSBtYXJrQWxpZ25lZExpc3QoYXN0LCBvcHRpb25zKTtcbiAgICBhc3QgPSBzcGxpdFRleHRJbnRvU2VudGVuY2VzKGFzdCwgb3B0aW9ucyk7XG4gICAgYXN0ID0gdHJhbnNmb3JtSW1wb3J0RXhwb3J0KGFzdCk7XG4gICAgYXN0ID0gbWVyZ2VDb250aW51b3VzSW1wb3J0RXhwb3J0KGFzdCk7XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUltcG9ydEV4cG9ydChhc3QpIHtcbiAgICByZXR1cm4gbWFwQXN0JDEoYXN0LCBub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUgIT09IFwiaW1wb3J0XCIgJiYgbm9kZS50eXBlICE9PSBcImV4cG9ydFwiKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwge1xuICAgICAgICB0eXBlOiBcImltcG9ydEV4cG9ydFwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUlubGluZUNvZGUoYXN0KSB7XG4gICAgcmV0dXJuIG1hcEFzdCQxKGFzdCwgbm9kZSA9PiB7XG4gICAgICBpZiAobm9kZS50eXBlICE9PSBcImlubGluZUNvZGVcIikge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHtcbiAgICAgICAgdmFsdWU6IG5vZGUudmFsdWUucmVwbGFjZSgvXFxzKy9nLCBcIiBcIilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVVuZXNjYXBlZENoYXJhY3Rlcihhc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWFwQXN0JDEoYXN0LCBub2RlID0+IHtcbiAgICAgIHJldHVybiBub2RlLnR5cGUgIT09IFwidGV4dFwiID8gbm9kZSA6IE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHtcbiAgICAgICAgdmFsdWU6IG5vZGUudmFsdWUgIT09IFwiKlwiICYmIG5vZGUudmFsdWUgIT09IFwiX1wiICYmIG5vZGUudmFsdWUgIT09IFwiJFwiICYmIC8vIGhhbmRsZSB0aGVzZSBjYXNlcyBpbiBwcmludGVyXG4gICAgICAgIGlzU2luZ2xlQ2hhclJlZ2V4LnRlc3Qobm9kZS52YWx1ZSkgJiYgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0IC0gbm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQgIT09IG5vZGUudmFsdWUubGVuZ3RoID8gb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCkgOiBub2RlLnZhbHVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQ29udGludW91c0ltcG9ydEV4cG9ydChhc3QpIHtcbiAgICByZXR1cm4gbWVyZ2VDaGlsZHJlbihhc3QsIChwcmV2Tm9kZSwgbm9kZSkgPT4gcHJldk5vZGUudHlwZSA9PT0gXCJpbXBvcnRFeHBvcnRcIiAmJiBub2RlLnR5cGUgPT09IFwiaW1wb3J0RXhwb3J0XCIsIChwcmV2Tm9kZSwgbm9kZSkgPT4gKHtcbiAgICAgIHR5cGU6IFwiaW1wb3J0RXhwb3J0XCIsXG4gICAgICB2YWx1ZTogcHJldk5vZGUudmFsdWUgKyBcIlxcblxcblwiICsgbm9kZS52YWx1ZSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiBwcmV2Tm9kZS5wb3NpdGlvbi5zdGFydCxcbiAgICAgICAgZW5kOiBub2RlLnBvc2l0aW9uLmVuZFxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlQ2hpbGRyZW4oYXN0LCBzaG91bGRNZXJnZSwgbWVyZ2VOb2RlKSB7XG4gICAgcmV0dXJuIG1hcEFzdCQxKGFzdCwgbm9kZSA9PiB7XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5yZWR1Y2UoKGN1cnJlbnQsIGNoaWxkKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IGN1cnJlbnRbY3VycmVudC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAobGFzdENoaWxkICYmIHNob3VsZE1lcmdlKGxhc3RDaGlsZCwgY2hpbGQpKSB7XG4gICAgICAgICAgY3VycmVudC5zcGxpY2UoLTEsIDEsIG1lcmdlTm9kZShsYXN0Q2hpbGQsIGNoaWxkKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfSwgW10pO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHtcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VDb250aW51b3VzVGV4dHMoYXN0KSB7XG4gICAgcmV0dXJuIG1lcmdlQ2hpbGRyZW4oYXN0LCAocHJldk5vZGUsIG5vZGUpID0+IHByZXZOb2RlLnR5cGUgPT09IFwidGV4dFwiICYmIG5vZGUudHlwZSA9PT0gXCJ0ZXh0XCIsIChwcmV2Tm9kZSwgbm9kZSkgPT4gKHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdmFsdWU6IHByZXZOb2RlLnZhbHVlICsgbm9kZS52YWx1ZSxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiBwcmV2Tm9kZS5wb3NpdGlvbi5zdGFydCxcbiAgICAgICAgZW5kOiBub2RlLnBvc2l0aW9uLmVuZFxuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0VGV4dEludG9TZW50ZW5jZXMoYXN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1hcEFzdCQxKGFzdCwgKG5vZGUsIGluZGV4LCBbcGFyZW50Tm9kZV0pID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBsZXQge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IG5vZGU7XG5cbiAgICAgIGlmIChwYXJlbnROb2RlLnR5cGUgPT09IFwicGFyYWdyYXBoXCIpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltU3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzZW50ZW5jZVwiLFxuICAgICAgICBwb3NpdGlvbjogbm9kZS5wb3NpdGlvbixcbiAgICAgICAgY2hpbGRyZW46IHNwbGl0VGV4dCQxKHZhbHVlLCBvcHRpb25zKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybUluZGVudGVkQ29kZWJsb2NrQW5kTWFya0l0c1BhcmVudExpc3QoYXN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1hcEFzdCQxKGFzdCwgKG5vZGUsIGluZGV4LCBwYXJlbnRTdGFjaykgPT4ge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJjb2RlXCIpIHtcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNoYXIgbWF5IHBvaW50IHRvIGBcXG5gLCBlLmcuIGBcXG5cXHRcXHRiYXJgLCBqdXN0IGlnbm9yZSBpdFxuICAgICAgICBjb25zdCBpc0luZGVudGVkID0gL15cXG4/KCB7NCx9fFxcdCkvLnRlc3Qob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCkpO1xuICAgICAgICBub2RlLmlzSW5kZW50ZWQgPSBpc0luZGVudGVkO1xuXG4gICAgICAgIGlmIChpc0luZGVudGVkKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gcGFyZW50U3RhY2tbaV07IC8vIG5vIG5lZWQgdG8gY2hlY2sgY2hlY2tlZCBpdGVtc1xuXG4gICAgICAgICAgICBpZiAocGFyZW50Lmhhc0luZGVudGVkQ29kZWJsb2NrKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwibGlzdFwiKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5oYXNJbmRlbnRlZENvZGVibG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya0FsaWduZWRMaXN0KGFzdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBtYXBBc3QkMShhc3QsIChub2RlLCBpbmRleCwgcGFyZW50U3RhY2spID0+IHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwibGlzdFwiICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIGlmIG9uZSBvZiBpdHMgcGFyZW50cyBpcyBub3QgYWxpZ25lZCwgaXQncyBub3QgcG9zc2libGUgdG8gYmUgYWxpZ25lZCBpbiBzdWItbGlzdHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudFN0YWNrW2ldO1xuXG4gICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcImxpc3RcIiAmJiAhcGFyZW50LmlzQWxpZ25lZCkge1xuICAgICAgICAgICAgbm9kZS5pc0FsaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuaXNBbGlnbmVkID0gaXNBbGlnbmVkKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGdldExpc3RJdGVtU3RhcnQobGlzdEl0ZW0pIHtcbiAgICAgIHJldHVybiBsaXN0SXRlbS5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyAtMSA6IGxpc3RJdGVtLmNoaWxkcmVuWzBdLnBvc2l0aW9uLnN0YXJ0LmNvbHVtbiAtIDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBbGlnbmVkKGxpc3QpIHtcbiAgICAgIGlmICghbGlzdC5vcmRlcmVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAtIDEyM1xuICAgICAgICAgKiAtIDEyM1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtmaXJzdEl0ZW0sIHNlY29uZEl0ZW1dID0gbGlzdC5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IGZpcnN0SW5mbyA9IGdldE9yZGVyZWRMaXN0SXRlbUluZm8kMShmaXJzdEl0ZW0sIG9wdGlvbnMub3JpZ2luYWxUZXh0KTtcblxuICAgICAgaWYgKGZpcnN0SW5mby5sZWFkaW5nU3BhY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDEuICAgMTIzXG4gICAgICAgICAqXG4gICAgICAgICAqIDEuICAgMTIzXG4gICAgICAgICAqIDEuIDEyM1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0U3RhcnQgPSBnZXRMaXN0SXRlbVN0YXJ0KGZpcnN0SXRlbSk7XG5cbiAgICAgIGlmIChmaXJzdFN0YXJ0ID09PSAtMSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogMS5cbiAgICAgICAgICpcbiAgICAgICAgICogMS5cbiAgICAgICAgICogMS5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3QuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbGlnbmVkOlxuICAgICAgICAgKlxuICAgICAgICAgKiAxMS4gMTIzXG4gICAgICAgICAqXG4gICAgICAgICAqIG5vdCBhbGlnbmVkOlxuICAgICAgICAgKlxuICAgICAgICAgKiAxLiAxMjNcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmaXJzdFN0YXJ0ICUgb3B0aW9ucy50YWJXaWR0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2Vjb25kU3RhcnQgPSBnZXRMaXN0SXRlbVN0YXJ0KHNlY29uZEl0ZW0pO1xuXG4gICAgICBpZiAoZmlyc3RTdGFydCAhPT0gc2Vjb25kU3RhcnQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIDExLiAxMjNcbiAgICAgICAgICogMS4gMTIzXG4gICAgICAgICAqXG4gICAgICAgICAqIDEuIDEyM1xuICAgICAgICAgKiAxMS4gMTIzXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdFN0YXJ0ICUgb3B0aW9ucy50YWJXaWR0aCA9PT0gMCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogMTEuIDEyM1xuICAgICAgICAgKiAxMi4gMTIzXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogYWxpZ25lZDpcbiAgICAgICAqXG4gICAgICAgKiAxMS4gMTIzXG4gICAgICAgKiAxLiAgMTIzXG4gICAgICAgKlxuICAgICAgICogbm90IGFsaWduZWQ6XG4gICAgICAgKlxuICAgICAgICogMS4gMTIzXG4gICAgICAgKiAyLiAxMjNcbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHNlY29uZEluZm8gPSBnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvJDEoc2Vjb25kSXRlbSwgb3B0aW9ucy5vcmlnaW5hbFRleHQpO1xuICAgICAgcmV0dXJuIHNlY29uZEluZm8ubGVhZGluZ1NwYWNlcy5sZW5ndGggPiAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcmVwcm9jZXNzXzEkMiA9IHByZXByb2Nlc3MkMjtcblxuICBjb25zdCB7XG4gICAgYnVpbGRlcnM6IHtcbiAgICAgIGJyZWFrUGFyZW50OiBicmVha1BhcmVudCQ0LFxuICAgICAgY29uY2F0OiBjb25jYXQkZyxcbiAgICAgIGpvaW46IGpvaW4kYixcbiAgICAgIGxpbmU6IGxpbmUkYSxcbiAgICAgIGxpdGVyYWxsaW5lOiBsaXRlcmFsbGluZSQ2LFxuICAgICAgbWFya0FzUm9vdDogbWFya0FzUm9vdCQ0LFxuICAgICAgaGFyZGxpbmU6IGhhcmRsaW5lJGMsXG4gICAgICBzb2Z0bGluZTogc29mdGxpbmUkNyxcbiAgICAgIGlmQnJlYWs6IGlmQnJlYWskNyxcbiAgICAgIGZpbGw6IGZpbGwkNSxcbiAgICAgIGFsaWduOiBhbGlnbiQyLFxuICAgICAgaW5kZW50OiBpbmRlbnQkOSxcbiAgICAgIGdyb3VwOiBncm91cCRmXG4gICAgfSxcbiAgICB1dGlsczoge1xuICAgICAgbWFwRG9jOiBtYXBEb2MkNVxuICAgIH0sXG4gICAgcHJpbnRlcjoge1xuICAgICAgcHJpbnREb2NUb1N0cmluZzogcHJpbnREb2NUb1N0cmluZyQzXG4gICAgfVxuICB9ID0gZG9jdW1lbnQ7XG4gIGNvbnN0IHtcbiAgICBnZXRGZW5jZWRDb2RlQmxvY2tWYWx1ZTogZ2V0RmVuY2VkQ29kZUJsb2NrVmFsdWUkMixcbiAgICBoYXNHaXREaWZmRnJpZW5kbHlPcmRlcmVkTGlzdDogaGFzR2l0RGlmZkZyaWVuZGx5T3JkZXJlZExpc3QkMSxcbiAgICBzcGxpdFRleHQ6IHNwbGl0VGV4dCQyLFxuICAgIHB1bmN0dWF0aW9uUGF0dGVybjogcHVuY3R1YXRpb25QYXR0ZXJuJDEsXG4gICAgSU5MSU5FX05PREVfVFlQRVM6IElOTElORV9OT0RFX1RZUEVTJDEsXG4gICAgSU5MSU5FX05PREVfV1JBUFBFUl9UWVBFUzogSU5MSU5FX05PREVfV1JBUFBFUl9UWVBFUyQxXG4gIH0gPSB1dGlscyQ2O1xuICBjb25zdCB7XG4gICAgcmVwbGFjZUVuZE9mTGluZVdpdGg6IHJlcGxhY2VFbmRPZkxpbmVXaXRoJDJcbiAgfSA9IHV0aWwkMTtcbiAgY29uc3QgVFJBSUxJTkdfSEFSRExJTkVfTk9ERVMgPSBbXCJpbXBvcnRFeHBvcnRcIl07XG4gIGNvbnN0IFNJTkdMRV9MSU5FX05PREVfVFlQRVMgPSBbXCJoZWFkaW5nXCIsIFwidGFibGVDZWxsXCIsIFwibGlua1wiXTtcbiAgY29uc3QgU0lCTElOR19OT0RFX1RZUEVTID0gW1wibGlzdEl0ZW1cIiwgXCJkZWZpbml0aW9uXCIsIFwiZm9vdG5vdGVEZWZpbml0aW9uXCJdO1xuXG4gIGZ1bmN0aW9uIGdlbmVyaWNQcmludCQ1KHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmIChzaG91bGRSZW1haW5UaGVTYW1lQ29udGVudChwYXRoKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdCRnKHNwbGl0VGV4dCQyKG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG5vZGUucG9zaXRpb24uc3RhcnQub2Zmc2V0LCBub2RlLnBvc2l0aW9uLmVuZC5vZmZzZXQpLCBvcHRpb25zKS5tYXAobm9kZSA9PiBub2RlLnR5cGUgPT09IFwid29yZFwiID8gbm9kZS52YWx1ZSA6IG5vZGUudmFsdWUgPT09IFwiXCIgPyBcIlwiIDogcHJpbnRMaW5lKHBhdGgsIG5vZGUudmFsdWUsIG9wdGlvbnMpKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtub3JtYWxpemVEb2MocHJpbnRSb290KHBhdGgsIG9wdGlvbnMsIHByaW50KSksICFUUkFJTElOR19IQVJETElORV9OT0RFUy5pbmNsdWRlcyhnZXRMYXN0RGVzY2VuZGFudE5vZGUobm9kZSkudHlwZSkgPyBoYXJkbGluZSRjIDogXCJcIl0pO1xuXG4gICAgICBjYXNlIFwicGFyYWdyYXBoXCI6XG4gICAgICAgIHJldHVybiBwcmludENoaWxkcmVuJDIocGF0aCwgb3B0aW9ucywgcHJpbnQsIHtcbiAgICAgICAgICBwb3N0cHJvY2Vzc29yOiBmaWxsJDVcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgXCJzZW50ZW5jZVwiOlxuICAgICAgICByZXR1cm4gcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KTtcblxuICAgICAgY2FzZSBcIndvcmRcIjpcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWUucmVwbGFjZSgvWyokXS9nLCBcIlxcXFwkJlwiKSAvLyBlc2NhcGUgYWxsIGAqYCBhbmQgYCRgIChtYXRoKVxuICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKFtcIihefFwiLmNvbmNhdChwdW5jdHVhdGlvblBhdHRlcm4kMSwgXCIpKF8rKVwiKSwgXCIoXyspKFwiLmNvbmNhdChwdW5jdHVhdGlvblBhdHRlcm4kMSwgXCJ8JClcIildLmpvaW4oXCJ8XCIpLCBcImdcIiksIChfLCB0ZXh0MSwgdW5kZXJzY29yZTEsIHVuZGVyc2NvcmUyLCB0ZXh0MikgPT4gKHVuZGVyc2NvcmUxID8gXCJcIi5jb25jYXQodGV4dDEpLmNvbmNhdCh1bmRlcnNjb3JlMSkgOiBcIlwiLmNvbmNhdCh1bmRlcnNjb3JlMikuY29uY2F0KHRleHQyKSkucmVwbGFjZSgvXy9nLCBcIlxcXFxfXCIpKTtcbiAgICAgIC8vIGVzY2FwZSBhbGwgYF9gIGV4Y2VwdCBjb25jYXRpbmcgd2l0aCBub24tcHVuY3R1YXRpb24sIGUuZy4gYDFfMl8zYCBpcyBub3QgY29uc2lkZXJlZCBlbXBoYXNpc1xuXG4gICAgICBjYXNlIFwid2hpdGVzcGFjZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gcGFyZW50Tm9kZS5jaGlsZHJlbltpbmRleCArIDFdO1xuICAgICAgICAgIGNvbnN0IHByb3NlV3JhcCA9IC8vIGxlYWRpbmcgY2hhciB0aGF0IG1heSBjYXVzZSBkaWZmZXJlbnQgc3ludGF4XG4gICAgICAgICAgbmV4dE5vZGUgJiYgL14+fF4oWy0rKl18I3sxLDZ9fFswLTldK1suKV0pJC8udGVzdChuZXh0Tm9kZS52YWx1ZSkgPyBcIm5ldmVyXCIgOiBvcHRpb25zLnByb3NlV3JhcDtcbiAgICAgICAgICByZXR1cm4gcHJpbnRMaW5lKHBhdGgsIG5vZGUudmFsdWUsIHtcbiAgICAgICAgICAgIHByb3NlV3JhcFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJlbXBoYXNpc1wiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgIGNvbnN0IHByZXZOb2RlID0gcGFyZW50Tm9kZS5jaGlsZHJlbltpbmRleCAtIDFdO1xuICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gcGFyZW50Tm9kZS5jaGlsZHJlbltpbmRleCArIDFdO1xuICAgICAgICAgIGNvbnN0IGhhc1ByZXZPck5leHRXb3JkID0gLy8gYDEqMiozYCBpcyBjb25zaWRlcmVkIGVtcGhhc2lzIGJ1dCBgMV8yXzNgIGlzIG5vdFxuICAgICAgICAgIHByZXZOb2RlICYmIHByZXZOb2RlLnR5cGUgPT09IFwic2VudGVuY2VcIiAmJiBwcmV2Tm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwICYmIHV0aWwkMS5nZXRMYXN0KHByZXZOb2RlLmNoaWxkcmVuKS50eXBlID09PSBcIndvcmRcIiAmJiAhdXRpbCQxLmdldExhc3QocHJldk5vZGUuY2hpbGRyZW4pLmhhc1RyYWlsaW5nUHVuY3R1YXRpb24gfHwgbmV4dE5vZGUgJiYgbmV4dE5vZGUudHlwZSA9PT0gXCJzZW50ZW5jZVwiICYmIG5leHROb2RlLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgbmV4dE5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJ3b3JkXCIgJiYgIW5leHROb2RlLmNoaWxkcmVuWzBdLmhhc0xlYWRpbmdQdW5jdHVhdGlvbjtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IGhhc1ByZXZPck5leHRXb3JkIHx8IGdldEFuY2VzdG9yTm9kZSQyKHBhdGgsIFwiZW1waGFzaXNcIikgPyBcIipcIiA6IFwiX1wiO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZyhbc3R5bGUsIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCksIHN0eWxlXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInN0cm9uZ1wiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGcoW1wiKipcIiwgcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KSwgXCIqKlwiXSk7XG5cbiAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcIn5+XCIsIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCksIFwifn5cIl0pO1xuXG4gICAgICBjYXNlIFwiaW5saW5lQ29kZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgYmFja3RpY2tDb3VudCA9IHV0aWwkMS5nZXRNaW5Ob3RQcmVzZW50Q29udGludW91c0NvdW50KG5vZGUudmFsdWUsIFwiYFwiKTtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IFwiYFwiLnJlcGVhdChiYWNrdGlja0NvdW50IHx8IDEpO1xuICAgICAgICAgIGNvbnN0IGdhcCA9IGJhY2t0aWNrQ291bnQgPyBcIiBcIiA6IFwiXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtzdHlsZSwgZ2FwLCBub2RlLnZhbHVlLCBnYXAsIHN0eWxlXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLm9yaWdpbmFsVGV4dFtub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldF0pIHtcbiAgICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBtYWlsdG8gPSBcIm1haWx0bzpcIjtcbiAgICAgICAgICAgICAgY29uc3QgdXJsID0gLy8gPGhlbGxvQGV4YW1wbGUuY29tPiBpcyBwYXJzZWQgYXMgeyB1cmw6IFwibWFpbHRvOmhlbGxvQGV4YW1wbGUuY29tXCIgfVxuICAgICAgICAgICAgICBub2RlLnVybC5zdGFydHNXaXRoKG1haWx0bykgJiYgb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQgKyAxLCBub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCArIDEgKyBtYWlsdG8ubGVuZ3RoKSAhPT0gbWFpbHRvID8gbm9kZS51cmwuc2xpY2UobWFpbHRvLmxlbmd0aCkgOiBub2RlLnVybDtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcIjxcIiwgdXJsLCBcIj5cIl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkZyhbXCJbXCIsIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCksIFwiXShcIiwgcHJpbnRVcmwobm9kZS51cmwsIFwiKVwiKSwgcHJpbnRUaXRsZShub2RlLnRpdGxlLCBvcHRpb25zKSwgXCIpXCJdKTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZyhbXCIhW1wiLCBub2RlLmFsdCB8fCBcIlwiLCBcIl0oXCIsIHByaW50VXJsKG5vZGUudXJsLCBcIilcIiksIHByaW50VGl0bGUobm9kZS50aXRsZSwgb3B0aW9ucyksIFwiKVwiXSk7XG5cbiAgICAgIGNhc2UgXCJibG9ja3F1b3RlXCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkZyhbXCI+IFwiLCBhbGlnbiQyKFwiPiBcIiwgcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KSldKTtcblxuICAgICAgY2FzZSBcImhlYWRpbmdcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcIiNcIi5yZXBlYXQobm9kZS5kZXB0aCkgKyBcIiBcIiwgcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pO1xuXG4gICAgICBjYXNlIFwiY29kZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKG5vZGUuaXNJbmRlbnRlZCkge1xuICAgICAgICAgICAgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gXCIgXCIucmVwZWF0KDQpO1xuICAgICAgICAgICAgcmV0dXJuIGFsaWduJDIoYWxpZ25tZW50LCBjb25jYXQkZyhbYWxpZ25tZW50LCBjb25jYXQkZyhyZXBsYWNlRW5kT2ZMaW5lV2l0aCQyKG5vZGUudmFsdWUsIGhhcmRsaW5lJGMpKV0pKTtcbiAgICAgICAgICB9IC8vIGZlbmNlZCBjb2RlIGJsb2NrXG5cblxuICAgICAgICAgIGNvbnN0IHN0eWxlVW5pdCA9IG9wdGlvbnMuX19pbkpzVGVtcGxhdGUgPyBcIn5cIiA6IFwiYFwiO1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVVbml0LnJlcGVhdChNYXRoLm1heCgzLCB1dGlsJDEuZ2V0TWF4Q29udGludW91c0NvdW50KG5vZGUudmFsdWUsIHN0eWxlVW5pdCkgKyAxKSk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtzdHlsZSwgbm9kZS5sYW5nIHx8IFwiXCIsIGhhcmRsaW5lJGMsIGNvbmNhdCRnKHJlcGxhY2VFbmRPZkxpbmVXaXRoJDIoZ2V0RmVuY2VkQ29kZUJsb2NrVmFsdWUkMihub2RlLCBvcHRpb25zLm9yaWdpbmFsVGV4dCksIGhhcmRsaW5lJGMpKSwgaGFyZGxpbmUkYywgc3R5bGVdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwieWFtbFwiOlxuICAgICAgY2FzZSBcInRvbWxcIjpcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG5vZGUucG9zaXRpb24uc3RhcnQub2Zmc2V0LCBub2RlLnBvc2l0aW9uLmVuZC5vZmZzZXQpO1xuXG4gICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyZW50Tm9kZS50eXBlID09PSBcInJvb3RcIiAmJiB1dGlsJDEuZ2V0TGFzdChwYXJlbnROb2RlLmNoaWxkcmVuKSA9PT0gbm9kZSA/IG5vZGUudmFsdWUudHJpbUVuZCgpIDogbm9kZS52YWx1ZTtcbiAgICAgICAgICBjb25zdCBpc0h0bWxDb21tZW50ID0gL148IS0tW1xcc1xcU10qLS0+JC8udGVzdCh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKHJlcGxhY2VFbmRPZkxpbmVXaXRoJDIodmFsdWUsIGlzSHRtbENvbW1lbnQgPyBoYXJkbGluZSRjIDogbWFya0FzUm9vdCQ0KGxpdGVyYWxsaW5lJDYpKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImxpc3RcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG50aFNpYmxpbmdJbmRleCA9IGdldE50aExpc3RTaWJsaW5nSW5kZXgobm9kZSwgcGF0aC5nZXRQYXJlbnROb2RlKCkpO1xuICAgICAgICAgIGNvbnN0IGlzR2l0RGlmZkZyaWVuZGx5T3JkZXJlZExpc3QgPSBoYXNHaXREaWZmRnJpZW5kbHlPcmRlcmVkTGlzdCQxKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBwcmludENoaWxkcmVuJDIocGF0aCwgb3B0aW9ucywgcHJpbnQsIHtcbiAgICAgICAgICAgIHByb2Nlc3NvcjogKGNoaWxkUGF0aCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAyICYmIGNoaWxkTm9kZS5jaGlsZHJlblsxXS50eXBlID09PSBcImh0bWxcIiAmJiBjaGlsZE5vZGUuY2hpbGRyZW5bMF0ucG9zaXRpb24uc3RhcnQuY29sdW1uICE9PSBjaGlsZE5vZGUuY2hpbGRyZW5bMV0ucG9zaXRpb24uc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtwcmVmaXgsIHByaW50TGlzdEl0ZW0oY2hpbGRQYXRoLCBvcHRpb25zLCBwcmludCwgcHJlZml4KV0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtwcmVmaXgsIGFsaWduJDIoXCIgXCIucmVwZWF0KHByZWZpeC5sZW5ndGgpLCBwcmludExpc3RJdGVtKGNoaWxkUGF0aCwgb3B0aW9ucywgcHJpbnQsIHByZWZpeCkpXSk7XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UHJlZml4KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1ByZWZpeCA9IG5vZGUub3JkZXJlZCA/IChpbmRleCA9PT0gMCA/IG5vZGUuc3RhcnQgOiBpc0dpdERpZmZGcmllbmRseU9yZGVyZWRMaXN0ID8gMSA6IG5vZGUuc3RhcnQgKyBpbmRleCkgKyAobnRoU2libGluZ0luZGV4ICUgMiA9PT0gMCA/IFwiLiBcIiA6IFwiKSBcIikgOiBudGhTaWJsaW5nSW5kZXggJSAyID09PSAwID8gXCItIFwiIDogXCIqIFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmlzQWxpZ25lZCB8fFxuICAgICAgICAgICAgICAgIC8qIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1hcmtqcy9yZW1hcmsvaXNzdWVzLzMxNSAqL1xuICAgICAgICAgICAgICAgIG5vZGUuaGFzSW5kZW50ZWRDb2RlYmxvY2sgPyBhbGlnbkxpc3RQcmVmaXgocmF3UHJlZml4LCBvcHRpb25zKSA6IHJhd1ByZWZpeDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJ0aGVtYXRpY0JyZWFrXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBjb3VudGVyID0gZ2V0QW5jZXN0b3JDb3VudGVyJDEocGF0aCwgXCJsaXN0XCIpO1xuXG4gICAgICAgICAgaWYgKGNvdW50ZXIgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gXCItLS1cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBudGhTaWJsaW5nSW5kZXggPSBnZXROdGhMaXN0U2libGluZ0luZGV4KHBhdGguZ2V0UGFyZW50Tm9kZShjb3VudGVyKSwgcGF0aC5nZXRQYXJlbnROb2RlKGNvdW50ZXIgKyAxKSk7XG4gICAgICAgICAgcmV0dXJuIG50aFNpYmxpbmdJbmRleCAlIDIgPT09IDAgPyBcIioqKlwiIDogXCItLS1cIjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwibGlua1JlZmVyZW5jZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGcoW1wiW1wiLCBwcmludENoaWxkcmVuJDIocGF0aCwgb3B0aW9ucywgcHJpbnQpLCBcIl1cIiwgbm9kZS5yZWZlcmVuY2VUeXBlID09PSBcImZ1bGxcIiA/IGNvbmNhdCRnKFtcIltcIiwgbm9kZS5pZGVudGlmaWVyLCBcIl1cIl0pIDogbm9kZS5yZWZlcmVuY2VUeXBlID09PSBcImNvbGxhcHNlZFwiID8gXCJbXVwiIDogXCJcIl0pO1xuXG4gICAgICBjYXNlIFwiaW1hZ2VSZWZlcmVuY2VcIjpcbiAgICAgICAgc3dpdGNoIChub2RlLnJlZmVyZW5jZVR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiZnVsbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcIiFbXCIsIG5vZGUuYWx0IHx8IFwiXCIsIFwiXVtcIiwgbm9kZS5pZGVudGlmaWVyLCBcIl1cIl0pO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkZyhbXCIhW1wiLCBub2RlLmFsdCwgXCJdXCIsIG5vZGUucmVmZXJlbmNlVHlwZSA9PT0gXCJjb2xsYXBzZWRcIiA/IFwiW11cIiA6IFwiXCJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZGVmaW5pdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGluZU9yU3BhY2UgPSBvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJhbHdheXNcIiA/IGxpbmUkYSA6IFwiIFwiO1xuICAgICAgICAgIHJldHVybiBncm91cCRmKGNvbmNhdCRnKFtjb25jYXQkZyhbXCJbXCIsIG5vZGUuaWRlbnRpZmllciwgXCJdOlwiXSksIGluZGVudCQ5KGNvbmNhdCRnKFtsaW5lT3JTcGFjZSwgcHJpbnRVcmwobm9kZS51cmwpLCBub2RlLnRpdGxlID09PSBudWxsID8gXCJcIiA6IGNvbmNhdCRnKFtsaW5lT3JTcGFjZSwgcHJpbnRUaXRsZShub2RlLnRpdGxlLCBvcHRpb25zLCBmYWxzZSldKV0pKV0pKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZm9vdG5vdGVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtcIlteXCIsIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCksIFwiXVwiXSk7XG5cbiAgICAgIGNhc2UgXCJmb290bm90ZVJlZmVyZW5jZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGcoW1wiW15cIiwgbm9kZS5pZGVudGlmaWVyLCBcIl1cIl0pO1xuXG4gICAgICBjYXNlIFwiZm9vdG5vdGVEZWZpbml0aW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpLmNoaWxkcmVuW3BhdGguZ2V0TmFtZSgpICsgMV07XG4gICAgICAgICAgY29uc3Qgc2hvdWxkSW5saW5lRm9vdG5vdGUgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IFwicGFyYWdyYXBoXCIgJiYgKG9wdGlvbnMucHJvc2VXcmFwID09PSBcIm5ldmVyXCIgfHwgb3B0aW9ucy5wcm9zZVdyYXAgPT09IFwicHJlc2VydmVcIiAmJiBub2RlLmNoaWxkcmVuWzBdLnBvc2l0aW9uLnN0YXJ0LmxpbmUgPT09IG5vZGUuY2hpbGRyZW5bMF0ucG9zaXRpb24uZW5kLmxpbmUpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQkZyhbXCJbXlwiLCBub2RlLmlkZW50aWZpZXIsIFwiXTogXCIsIHNob3VsZElubGluZUZvb3Rub3RlID8gcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KSA6IGdyb3VwJGYoY29uY2F0JGcoW2FsaWduJDIoXCIgXCIucmVwZWF0KG9wdGlvbnMudGFiV2lkdGgpLCBwcmludENoaWxkcmVuJDIocGF0aCwgb3B0aW9ucywgcHJpbnQsIHtcbiAgICAgICAgICAgIHByb2Nlc3NvcjogKGNoaWxkUGF0aCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ID09PSAwID8gZ3JvdXAkZihjb25jYXQkZyhbc29mdGxpbmUkNywgY2hpbGRQYXRoLmNhbGwocHJpbnQpXSkpIDogY2hpbGRQYXRoLmNhbGwocHJpbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSwgbmV4dE5vZGUgJiYgbmV4dE5vZGUudHlwZSA9PT0gXCJmb290bm90ZURlZmluaXRpb25cIiA/IHNvZnRsaW5lJDcgOiBcIlwiXSkpXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInRhYmxlXCI6XG4gICAgICAgIHJldHVybiBwcmludFRhYmxlKHBhdGgsIG9wdGlvbnMsIHByaW50KTtcblxuICAgICAgY2FzZSBcInRhYmxlQ2VsbFwiOlxuICAgICAgICByZXR1cm4gcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50KTtcblxuICAgICAgY2FzZSBcImJyZWFrXCI6XG4gICAgICAgIHJldHVybiAvXFxzLy50ZXN0KG9wdGlvbnMub3JpZ2luYWxUZXh0W25vZGUucG9zaXRpb24uc3RhcnQub2Zmc2V0XSkgPyBjb25jYXQkZyhbXCIgIFwiLCBtYXJrQXNSb290JDQobGl0ZXJhbGxpbmUkNildKSA6IGNvbmNhdCRnKFtcIlxcXFxcIiwgaGFyZGxpbmUkY10pO1xuXG4gICAgICBjYXNlIFwibGlxdWlkTm9kZVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGcocmVwbGFjZUVuZE9mTGluZVdpdGgkMihub2RlLnZhbHVlLCBoYXJkbGluZSRjKSk7XG4gICAgICAvLyBNRFhcblxuICAgICAgY2FzZSBcImltcG9ydEV4cG9ydFwiOlxuICAgICAgY2FzZSBcImpzeFwiOlxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgIC8vIGZhbGxiYWNrIHRvIHRoZSBvcmlnaW5hbCB0ZXh0IGlmIG11bHRpcGFyc2VyIGZhaWxlZFxuXG4gICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGcoW1wiJCRcIiwgaGFyZGxpbmUkYywgbm9kZS52YWx1ZSA/IGNvbmNhdCRnKFtjb25jYXQkZyhyZXBsYWNlRW5kT2ZMaW5lV2l0aCQyKG5vZGUudmFsdWUsIGhhcmRsaW5lJGMpKSwgaGFyZGxpbmUkY10pIDogXCJcIiwgXCIkJFwiXSk7XG5cbiAgICAgIGNhc2UgXCJpbmxpbmVNYXRoXCI6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyByZW1hcmstbWF0aCB0cmltcyBjb250ZW50IGJ1dCB3ZSBkb24ndCB3YW50IHRvIHJlbW92ZSB3aGl0ZXNwYWNlc1xuICAgICAgICAgIC8vIHNpbmNlIGl0J3MgdmVyeSBwb3NzaWJsZSB0aGF0IGl0J3MgcmVjb2duaXplZCBhcyBtYXRoIGFjY2lkZW50YWxseVxuICAgICAgICAgIHJldHVybiBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShvcHRpb25zLmxvY1N0YXJ0KG5vZGUpLCBvcHRpb25zLmxvY0VuZChub2RlKSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcInRhYmxlUm93XCI6IC8vIGhhbmRsZWQgaW4gXCJ0YWJsZVwiXG5cbiAgICAgIGNhc2UgXCJsaXN0SXRlbVwiOiAvLyBoYW5kbGVkIGluIFwibGlzdFwiXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbWFya2Rvd24gdHlwZSBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkobm9kZS50eXBlKSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50TGlzdEl0ZW0ocGF0aCwgb3B0aW9ucywgcHJpbnQsIGxpc3RQcmVmaXgpIHtcbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHByZWZpeCA9IG5vZGUuY2hlY2tlZCA9PT0gbnVsbCA/IFwiXCIgOiBub2RlLmNoZWNrZWQgPyBcIlt4XSBcIiA6IFwiWyBdIFwiO1xuICAgIHJldHVybiBjb25jYXQkZyhbcHJlZml4LCBwcmludENoaWxkcmVuJDIocGF0aCwgb3B0aW9ucywgcHJpbnQsIHtcbiAgICAgIHByb2Nlc3NvcjogKGNoaWxkUGF0aCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIGNoaWxkUGF0aC5nZXRWYWx1ZSgpLnR5cGUgIT09IFwibGlzdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGFsaWduJDIoXCIgXCIucmVwZWF0KHByZWZpeC5sZW5ndGgpLCBjaGlsZFBhdGguY2FsbChwcmludCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gXCIgXCIucmVwZWF0KGNsYW1wKG9wdGlvbnMudGFiV2lkdGggLSBsaXN0UHJlZml4Lmxlbmd0aCwgMCwgMykgLy8gNCsgd2lsbCBjYXVzZSBpbmRlbnRlZCBjb2RlIGJsb2NrXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBjb25jYXQkZyhbYWxpZ25tZW50LCBhbGlnbiQyKGFsaWdubWVudCwgY2hpbGRQYXRoLmNhbGwocHJpbnQpKV0pO1xuICAgICAgfVxuICAgIH0pXSk7XG4gIH1cblxuICBmdW5jdGlvbiBhbGlnbkxpc3RQcmVmaXgocHJlZml4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWRkaXRpb25hbFNwYWNlcyA9IGdldEFkZGl0aW9uYWxTcGFjZXMoKTtcbiAgICByZXR1cm4gcHJlZml4ICsgXCIgXCIucmVwZWF0KGFkZGl0aW9uYWxTcGFjZXMgPj0gNCA/IDAgOiBhZGRpdGlvbmFsU3BhY2VzIC8vIDQrIHdpbGwgY2F1c2UgaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICk7XG5cbiAgICBmdW5jdGlvbiBnZXRBZGRpdGlvbmFsU3BhY2VzKCkge1xuICAgICAgY29uc3QgcmVzdFNwYWNlcyA9IHByZWZpeC5sZW5ndGggJSBvcHRpb25zLnRhYldpZHRoO1xuICAgICAgcmV0dXJuIHJlc3RTcGFjZXMgPT09IDAgPyAwIDogb3B0aW9ucy50YWJXaWR0aCAtIHJlc3RTcGFjZXM7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TnRoTGlzdFNpYmxpbmdJbmRleChub2RlLCBwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGdldE50aFNpYmxpbmdJbmRleChub2RlLCBwYXJlbnROb2RlLCBzaWJsaW5nTm9kZSA9PiBzaWJsaW5nTm9kZS5vcmRlcmVkID09PSBub2RlLm9yZGVyZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TnRoU2libGluZ0luZGV4KG5vZGUsIHBhcmVudE5vZGUsIGNvbmRpdGlvbikge1xuICAgIGNvbmRpdGlvbiA9IGNvbmRpdGlvbiB8fCAoKCkgPT4gdHJ1ZSk7XG5cbiAgICBsZXQgaW5kZXggPSAtMTtcblxuICAgIGZvciAoY29uc3QgY2hpbGROb2RlIG9mIHBhcmVudE5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZE5vZGUudHlwZSA9PT0gbm9kZS50eXBlICYmIGNvbmRpdGlvbihjaGlsZE5vZGUpKSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGROb2RlID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBbmNlc3RvckNvdW50ZXIkMShwYXRoLCB0eXBlT3JUeXBlcykge1xuICAgIGNvbnN0IHR5cGVzID0gW10uY29uY2F0KHR5cGVPclR5cGVzKTtcbiAgICBsZXQgY291bnRlciA9IC0xO1xuICAgIGxldCBhbmNlc3Rvck5vZGU7XG5cbiAgICB3aGlsZSAoYW5jZXN0b3JOb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCsrY291bnRlcikpIHtcbiAgICAgIGlmICh0eXBlcy5pbmNsdWRlcyhhbmNlc3Rvck5vZGUudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QW5jZXN0b3JOb2RlJDIocGF0aCwgdHlwZU9yVHlwZXMpIHtcbiAgICBjb25zdCBjb3VudGVyID0gZ2V0QW5jZXN0b3JDb3VudGVyJDEocGF0aCwgdHlwZU9yVHlwZXMpO1xuICAgIHJldHVybiBjb3VudGVyID09PSAtMSA/IG51bGwgOiBwYXRoLmdldFBhcmVudE5vZGUoY291bnRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludExpbmUocGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wcm9zZVdyYXAgPT09IFwicHJlc2VydmVcIiAmJiB2YWx1ZSA9PT0gXCJcXG5cIikge1xuICAgICAgcmV0dXJuIGhhcmRsaW5lJGM7XG4gICAgfVxuXG4gICAgY29uc3QgaXNCcmVha2FibGUgPSBvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJhbHdheXNcIiAmJiAhZ2V0QW5jZXN0b3JOb2RlJDIocGF0aCwgU0lOR0xFX0xJTkVfTk9ERV9UWVBFUyk7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBcIlwiID8gaXNCcmVha2FibGUgPyBsaW5lJGEgOiBcIiBcIiA6IGlzQnJlYWthYmxlID8gc29mdGxpbmUkNyA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFRhYmxlKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3QgaGFyZGxpbmVXaXRob3V0QnJlYWtQYXJlbnQgPSBoYXJkbGluZSRjLnBhcnRzWzBdO1xuICAgIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gICAgY29uc3QgY29udGVudHMgPSBbXTsgLy8geyBbcm93SW5kZXg6IG51bWJlcl06IHsgW2NvbHVtbkluZGV4OiBudW1iZXJdOiBzdHJpbmcgfSB9XG5cbiAgICBwYXRoLm1hcChyb3dQYXRoID0+IHtcbiAgICAgIGNvbnN0IHJvd0NvbnRlbnRzID0gW107XG4gICAgICByb3dQYXRoLm1hcChjZWxsUGF0aCA9PiB7XG4gICAgICAgIHJvd0NvbnRlbnRzLnB1c2gocHJpbnREb2NUb1N0cmluZyQzKGNlbGxQYXRoLmNhbGwocHJpbnQpLCBvcHRpb25zKS5mb3JtYXR0ZWQpO1xuICAgICAgfSwgXCJjaGlsZHJlblwiKTtcbiAgICAgIGNvbnRlbnRzLnB1c2gocm93Q29udGVudHMpO1xuICAgIH0sIFwiY2hpbGRyZW5cIik7IC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW5cblxuICAgIGNvbnN0IGNvbHVtbk1heFdpZHRocyA9IGNvbnRlbnRzLnJlZHVjZSgoY3VycmVudFdpZHRocywgcm93Q29udGVudHMpID0+IGN1cnJlbnRXaWR0aHMubWFwKCh3aWR0aCwgY29sdW1uSW5kZXgpID0+IE1hdGgubWF4KHdpZHRoLCB1dGlsJDEuZ2V0U3RyaW5nV2lkdGgocm93Q29udGVudHNbY29sdW1uSW5kZXhdKSkpLCBjb250ZW50c1swXS5tYXAoKCkgPT4gMykgLy8gbWluaW11bSB3aWR0aCA9IDMgKC0tLSwgOi0tLCA6LTosIC0tOilcbiAgICApO1xuICAgIGNvbnN0IGFsaWduZWRUYWJsZSA9IGpvaW4kYihoYXJkbGluZVdpdGhvdXRCcmVha1BhcmVudCwgW3ByaW50Um93KGNvbnRlbnRzWzBdKSwgcHJpbnRTZXBhcmF0b3IoKSwgam9pbiRiKGhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50LCBjb250ZW50cy5zbGljZSgxKS5tYXAocm93Q29udGVudHMgPT4gcHJpbnRSb3cocm93Q29udGVudHMpKSldKTtcblxuICAgIGlmIChvcHRpb25zLnByb3NlV3JhcCAhPT0gXCJuZXZlclwiKSB7XG4gICAgICByZXR1cm4gY29uY2F0JGcoW2JyZWFrUGFyZW50JDQsIGFsaWduZWRUYWJsZV0pO1xuICAgIH0gLy8gT25seSBpZiB0aGUgLS1wcm9zZS13cmFwIG5ldmVyIGlzIHNldCBhbmQgaXQgZXhjZWVkcyB0aGUgcHJpbnQgd2lkdGguXG5cblxuICAgIGNvbnN0IGNvbXBhY3RUYWJsZSA9IGpvaW4kYihoYXJkbGluZVdpdGhvdXRCcmVha1BhcmVudCwgW3ByaW50Um93KGNvbnRlbnRzWzBdLFxuICAgIC8qIGlzQ29tcGFjdCAqL1xuICAgIHRydWUpLCBwcmludFNlcGFyYXRvcihcbiAgICAvKiBpc0NvbXBhY3QgKi9cbiAgICB0cnVlKSwgam9pbiRiKGhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50LCBjb250ZW50cy5zbGljZSgxKS5tYXAocm93Q29udGVudHMgPT4gcHJpbnRSb3cocm93Q29udGVudHMsXG4gICAgLyogaXNDb21wYWN0ICovXG4gICAgdHJ1ZSkpKV0pO1xuICAgIHJldHVybiBjb25jYXQkZyhbYnJlYWtQYXJlbnQkNCwgZ3JvdXAkZihpZkJyZWFrJDcoY29tcGFjdFRhYmxlLCBhbGlnbmVkVGFibGUpKV0pO1xuXG4gICAgZnVuY3Rpb24gcHJpbnRTZXBhcmF0b3IoaXNDb21wYWN0KSB7XG4gICAgICByZXR1cm4gY29uY2F0JGcoW1wifCBcIiwgam9pbiRiKFwiIHwgXCIsIGNvbHVtbk1heFdpZHRocy5tYXAoKHdpZHRoLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBzcGFjZXMgPSBpc0NvbXBhY3QgPyAzIDogd2lkdGg7XG5cbiAgICAgICAgc3dpdGNoIChub2RlLmFsaWduW2luZGV4XSkge1xuICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCI6XCIgKyBcIi1cIi5yZXBlYXQoc3BhY2VzIC0gMSk7XG5cbiAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgIHJldHVybiBcIi1cIi5yZXBlYXQoc3BhY2VzIC0gMSkgKyBcIjpcIjtcblxuICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBcIjpcIiArIFwiLVwiLnJlcGVhdChzcGFjZXMgLSAyKSArIFwiOlwiO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIi1cIi5yZXBlYXQoc3BhY2VzKTtcbiAgICAgICAgfVxuICAgICAgfSkpLCBcIiB8XCJdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmludFJvdyhyb3dDb250ZW50cywgaXNDb21wYWN0KSB7XG4gICAgICByZXR1cm4gY29uY2F0JGcoW1wifCBcIiwgam9pbiRiKFwiIHwgXCIsIGlzQ29tcGFjdCA/IHJvd0NvbnRlbnRzIDogcm93Q29udGVudHMubWFwKChyb3dDb250ZW50LCBjb2x1bW5JbmRleCkgPT4ge1xuICAgICAgICBzd2l0Y2ggKG5vZGUuYWxpZ25bY29sdW1uSW5kZXhdKSB7XG4gICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICByZXR1cm4gYWxpZ25SaWdodChyb3dDb250ZW50LCBjb2x1bW5NYXhXaWR0aHNbY29sdW1uSW5kZXhdKTtcblxuICAgICAgICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBhbGlnbkNlbnRlcihyb3dDb250ZW50LCBjb2x1bW5NYXhXaWR0aHNbY29sdW1uSW5kZXhdKTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYWxpZ25MZWZ0KHJvd0NvbnRlbnQsIGNvbHVtbk1heFdpZHRoc1tjb2x1bW5JbmRleF0pO1xuICAgICAgICB9XG4gICAgICB9KSksIFwiIHxcIl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsaWduTGVmdCh0ZXh0LCB3aWR0aCkge1xuICAgICAgY29uc3Qgc3BhY2VzID0gd2lkdGggLSB1dGlsJDEuZ2V0U3RyaW5nV2lkdGgodGV4dCk7XG4gICAgICByZXR1cm4gY29uY2F0JGcoW3RleHQsIFwiIFwiLnJlcGVhdChzcGFjZXMpXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxpZ25SaWdodCh0ZXh0LCB3aWR0aCkge1xuICAgICAgY29uc3Qgc3BhY2VzID0gd2lkdGggLSB1dGlsJDEuZ2V0U3RyaW5nV2lkdGgodGV4dCk7XG4gICAgICByZXR1cm4gY29uY2F0JGcoW1wiIFwiLnJlcGVhdChzcGFjZXMpLCB0ZXh0XSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxpZ25DZW50ZXIodGV4dCwgd2lkdGgpIHtcbiAgICAgIGNvbnN0IHNwYWNlcyA9IHdpZHRoIC0gdXRpbCQxLmdldFN0cmluZ1dpZHRoKHRleHQpO1xuICAgICAgY29uc3QgbGVmdCA9IE1hdGguZmxvb3Ioc3BhY2VzIC8gMik7XG4gICAgICBjb25zdCByaWdodCA9IHNwYWNlcyAtIGxlZnQ7XG4gICAgICByZXR1cm4gY29uY2F0JGcoW1wiIFwiLnJlcGVhdChsZWZ0KSwgdGV4dCwgXCIgXCIucmVwZWF0KHJpZ2h0KV0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50Um9vdChwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICAgIC8qKiBAdHlwZWRlZiB7eyBpbmRleDogbnVtYmVyLCBvZmZzZXQ6IG51bWJlciB9fSBJZ25vcmVQb3NpdGlvbiAqL1xuXG4gICAgLyoqIEB0eXBlIHtBcnJheTx7c3RhcnQ6IElnbm9yZVBvc2l0aW9uLCBlbmQ6IElnbm9yZVBvc2l0aW9ufT59ICovXG4gICAgY29uc3QgaWdub3JlUmFuZ2VzID0gW107XG4gICAgLyoqIEB0eXBlIHtJZ25vcmVQb3NpdGlvbiB8IG51bGx9ICovXG5cbiAgICBsZXQgaWdub3JlU3RhcnQgPSBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZE5vZGUsIGluZGV4KSA9PiB7XG4gICAgICBzd2l0Y2ggKGlzUHJldHRpZXJJZ25vcmUkMShjaGlsZE5vZGUpKSB7XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICAgIGlmIChpZ25vcmVTdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWdub3JlU3RhcnQgPSB7XG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBvZmZzZXQ6IGNoaWxkTm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICBpZiAoaWdub3JlU3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlnbm9yZVJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGlnbm9yZVN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGNoaWxkTm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZ25vcmVTdGFydCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByaW50Q2hpbGRyZW4kMihwYXRoLCBvcHRpb25zLCBwcmludCwge1xuICAgICAgcHJvY2Vzc29yOiAoY2hpbGRQYXRoLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlUmFuZ2VzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IGlnbm9yZVJhbmdlID0gaWdub3JlUmFuZ2VzWzBdO1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSBpZ25vcmVSYW5nZS5zdGFydC5pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdCRnKFtjaGlsZHJlbltpZ25vcmVSYW5nZS5zdGFydC5pbmRleF0udmFsdWUsIG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKGlnbm9yZVJhbmdlLnN0YXJ0Lm9mZnNldCwgaWdub3JlUmFuZ2UuZW5kLm9mZnNldCksIGNoaWxkcmVuW2lnbm9yZVJhbmdlLmVuZC5pbmRleF0udmFsdWVdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaWdub3JlUmFuZ2Uuc3RhcnQuaW5kZXggPCBpbmRleCAmJiBpbmRleCA8IGlnbm9yZVJhbmdlLmVuZC5pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gaWdub3JlUmFuZ2UuZW5kLmluZGV4KSB7XG4gICAgICAgICAgICBpZ25vcmVSYW5nZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGRQYXRoLmNhbGwocHJpbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJpbnRDaGlsZHJlbiQyKHBhdGgsIG9wdGlvbnMsIHByaW50LCBldmVudHMpIHtcbiAgICBldmVudHMgPSBldmVudHMgfHwge307XG4gICAgY29uc3QgcG9zdHByb2Nlc3NvciA9IGV2ZW50cy5wb3N0cHJvY2Vzc29yIHx8IGNvbmNhdCRnO1xuXG4gICAgY29uc3QgcHJvY2Vzc29yID0gZXZlbnRzLnByb2Nlc3NvciB8fCAoY2hpbGRQYXRoID0+IGNoaWxkUGF0aC5jYWxsKHByaW50KSk7XG5cbiAgICBjb25zdCBub2RlID0gcGF0aC5nZXRWYWx1ZSgpO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgbGV0IGxhc3RDaGlsZE5vZGU7XG4gICAgcGF0aC5tYXAoKGNoaWxkUGF0aCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzc29yKGNoaWxkUGF0aCwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgIHByZXZOb2RlOiBsYXN0Q2hpbGROb2RlLFxuICAgICAgICAgIHBhcmVudE5vZGU6IG5vZGUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghc2hvdWxkTm90UHJlUHJpbnRIYXJkbGluZShjaGlsZE5vZGUsIGRhdGEpKSB7XG4gICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSRjKTtcblxuICAgICAgICAgIGlmIChsYXN0Q2hpbGROb2RlICYmIFRSQUlMSU5HX0hBUkRMSU5FX05PREVTLmluY2x1ZGVzKGxhc3RDaGlsZE5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRQcmVQcmludFRyaXBsZUhhcmRsaW5lKGNoaWxkTm9kZSwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSRjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNob3VsZFByZVByaW50RG91YmxlSGFyZGxpbmUoY2hpbGROb2RlLCBkYXRhKSB8fCBzaG91bGRQcmVQcmludFRyaXBsZUhhcmRsaW5lKGNoaWxkTm9kZSwgZGF0YSkpIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChoYXJkbGluZSRjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3VsZFByZVByaW50VHJpcGxlSGFyZGxpbmUoY2hpbGROb2RlLCBkYXRhKSkge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGhhcmRsaW5lJGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgbGFzdENoaWxkTm9kZSA9IGNoaWxkTm9kZTtcbiAgICAgIH1cbiAgICB9LCBcImNoaWxkcmVuXCIpO1xuICAgIHJldHVybiBwb3N0cHJvY2Vzc29yKHBhcnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExhc3REZXNjZW5kYW50Tm9kZShub2RlKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBub2RlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQuY2hpbGRyZW4gJiYgY3VycmVudC5jaGlsZHJlbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNoaWxkcmVuW2N1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cbiAgLyoqIEByZXR1cm4ge2ZhbHNlIHwgJ25leHQnIHwgJ3N0YXJ0JyB8ICdlbmQnfSAqL1xuXG5cbiAgZnVuY3Rpb24gaXNQcmV0dGllcklnbm9yZSQxKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlICE9PSBcImh0bWxcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gbm9kZS52YWx1ZS5tYXRjaCgvXjwhLS1cXHMqcHJldHRpZXItaWdub3JlKD86LShzdGFydHxlbmQpKT9cXHMqLS0+JC8pO1xuICAgIHJldHVybiBtYXRjaCA9PT0gbnVsbCA/IGZhbHNlIDogbWF0Y2hbMV0gPyBtYXRjaFsxXSA6IFwibmV4dFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkTm90UHJlUHJpbnRIYXJkbGluZShub2RlLCBkYXRhKSB7XG4gICAgY29uc3QgaXNGaXJzdE5vZGUgPSBkYXRhLnBhcnRzLmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBpc0lubGluZU5vZGUgPSBJTkxJTkVfTk9ERV9UWVBFUyQxLmluY2x1ZGVzKG5vZGUudHlwZSk7XG4gICAgY29uc3QgaXNJbmxpbmVIVE1MID0gbm9kZS50eXBlID09PSBcImh0bWxcIiAmJiBJTkxJTkVfTk9ERV9XUkFQUEVSX1RZUEVTJDEuaW5jbHVkZXMoZGF0YS5wYXJlbnROb2RlLnR5cGUpO1xuICAgIHJldHVybiBpc0ZpcnN0Tm9kZSB8fCBpc0lubGluZU5vZGUgfHwgaXNJbmxpbmVIVE1MO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkUHJlUHJpbnREb3VibGVIYXJkbGluZShub2RlLCBkYXRhKSB7XG4gICAgY29uc3QgaXNTZXF1ZW5jZSA9IChkYXRhLnByZXZOb2RlICYmIGRhdGEucHJldk5vZGUudHlwZSkgPT09IG5vZGUudHlwZTtcbiAgICBjb25zdCBpc1NpYmxpbmdOb2RlID0gaXNTZXF1ZW5jZSAmJiBTSUJMSU5HX05PREVfVFlQRVMuaW5jbHVkZXMobm9kZS50eXBlKTtcbiAgICBjb25zdCBpc0luVGlnaHRMaXN0SXRlbSA9IGRhdGEucGFyZW50Tm9kZS50eXBlID09PSBcImxpc3RJdGVtXCIgJiYgIWRhdGEucGFyZW50Tm9kZS5sb29zZTtcbiAgICBjb25zdCBpc1ByZXZOb2RlTG9vc2VMaXN0SXRlbSA9IGRhdGEucHJldk5vZGUgJiYgZGF0YS5wcmV2Tm9kZS50eXBlID09PSBcImxpc3RJdGVtXCIgJiYgZGF0YS5wcmV2Tm9kZS5sb29zZTtcbiAgICBjb25zdCBpc1ByZXZOb2RlUHJldHRpZXJJZ25vcmUgPSBpc1ByZXR0aWVySWdub3JlJDEoZGF0YS5wcmV2Tm9kZSkgPT09IFwibmV4dFwiO1xuICAgIGNvbnN0IGlzQmxvY2tIdG1sV2l0aG91dEJsYW5rTGluZUJldHdlZW5QcmV2SHRtbCA9IG5vZGUudHlwZSA9PT0gXCJodG1sXCIgJiYgZGF0YS5wcmV2Tm9kZSAmJiBkYXRhLnByZXZOb2RlLnR5cGUgPT09IFwiaHRtbFwiICYmIGRhdGEucHJldk5vZGUucG9zaXRpb24uZW5kLmxpbmUgKyAxID09PSBub2RlLnBvc2l0aW9uLnN0YXJ0LmxpbmU7XG4gICAgY29uc3QgaXNIdG1sRGlyZWN0QWZ0ZXJMaXN0SXRlbSA9IG5vZGUudHlwZSA9PT0gXCJodG1sXCIgJiYgZGF0YS5wYXJlbnROb2RlLnR5cGUgPT09IFwibGlzdEl0ZW1cIiAmJiBkYXRhLnByZXZOb2RlICYmIGRhdGEucHJldk5vZGUudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIiAmJiBkYXRhLnByZXZOb2RlLnBvc2l0aW9uLmVuZC5saW5lICsgMSA9PT0gbm9kZS5wb3NpdGlvbi5zdGFydC5saW5lO1xuICAgIHJldHVybiBpc1ByZXZOb2RlTG9vc2VMaXN0SXRlbSB8fCAhKGlzU2libGluZ05vZGUgfHwgaXNJblRpZ2h0TGlzdEl0ZW0gfHwgaXNQcmV2Tm9kZVByZXR0aWVySWdub3JlIHx8IGlzQmxvY2tIdG1sV2l0aG91dEJsYW5rTGluZUJldHdlZW5QcmV2SHRtbCB8fCBpc0h0bWxEaXJlY3RBZnRlckxpc3RJdGVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZFByZVByaW50VHJpcGxlSGFyZGxpbmUobm9kZSwgZGF0YSkge1xuICAgIGNvbnN0IGlzUHJldk5vZGVMaXN0ID0gZGF0YS5wcmV2Tm9kZSAmJiBkYXRhLnByZXZOb2RlLnR5cGUgPT09IFwibGlzdFwiO1xuICAgIGNvbnN0IGlzSW5kZW50ZWRDb2RlID0gbm9kZS50eXBlID09PSBcImNvZGVcIiAmJiBub2RlLmlzSW5kZW50ZWQ7XG4gICAgcmV0dXJuIGlzUHJldk5vZGVMaXN0ICYmIGlzSW5kZW50ZWRDb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkUmVtYWluVGhlU2FtZUNvbnRlbnQocGF0aCkge1xuICAgIGNvbnN0IGFuY2VzdG9yTm9kZSA9IGdldEFuY2VzdG9yTm9kZSQyKHBhdGgsIFtcImxpbmtSZWZlcmVuY2VcIiwgXCJpbWFnZVJlZmVyZW5jZVwiXSk7XG4gICAgcmV0dXJuIGFuY2VzdG9yTm9kZSAmJiAoYW5jZXN0b3JOb2RlLnR5cGUgIT09IFwibGlua1JlZmVyZW5jZVwiIHx8IGFuY2VzdG9yTm9kZS5yZWZlcmVuY2VUeXBlICE9PSBcImZ1bGxcIik7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVEb2MoZG9jKSB7XG4gICAgcmV0dXJuIG1hcERvYyQ1KGRvYywgY3VycmVudERvYyA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnREb2MucGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnREb2M7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50RG9jLnR5cGUgPT09IFwiY29uY2F0XCIgJiYgY3VycmVudERvYy5wYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnREb2MucGFydHNbMF07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnRzID0gY3VycmVudERvYy5wYXJ0cy5yZWR1Y2UoKHBhcnRzLCBwYXJ0KSA9PiB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiY29uY2F0XCIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKC4uLnBhcnQucGFydHMpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnQgIT09IFwiXCIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSwgW10pO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnREb2MsIHtcbiAgICAgICAgcGFydHM6IG5vcm1hbGl6ZVBhcnRzJDIocGFydHMpXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByaW50VXJsKHVybCwgZGFuZ2Vyb3VzQ2hhck9yQ2hhcnMpIHtcbiAgICBjb25zdCBkYW5nZXJvdXNDaGFycyA9IFtcIiBcIl0uY29uY2F0KGRhbmdlcm91c0NoYXJPckNoYXJzIHx8IFtdKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChkYW5nZXJvdXNDaGFycy5tYXAoeCA9PiBcIlxcXFxcIi5jb25jYXQoeCkpLmpvaW4oXCJ8XCIpKS50ZXN0KHVybCkgPyBcIjxcIi5jb25jYXQodXJsLCBcIj5cIikgOiB1cmw7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludFRpdGxlKHRpdGxlLCBvcHRpb25zLCBwcmludFNwYWNlKSB7XG4gICAgaWYgKHByaW50U3BhY2UgPT0gbnVsbCkge1xuICAgICAgcHJpbnRTcGFjZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aXRsZSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgaWYgKHByaW50U3BhY2UpIHtcbiAgICAgIHJldHVybiBcIiBcIiArIHByaW50VGl0bGUodGl0bGUsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAodGl0bGUuaW5jbHVkZXMoJ1wiJykgJiYgdGl0bGUuaW5jbHVkZXMoXCInXCIpICYmICF0aXRsZS5pbmNsdWRlcyhcIilcIikpIHtcbiAgICAgIHJldHVybiBcIihcIi5jb25jYXQodGl0bGUsIFwiKVwiKTsgLy8gYXZvaWQgZXNjYXBlZCBxdW90ZXNcbiAgICB9IC8vIGZhc3RlciB0aGFuIHVzaW5nIFJlZ0V4cHM6IGh0dHBzOi8vanNwZXJmLmNvbS9wZXJmb3JtYW5jZS1vZi1tYXRjaC12cy1zcGxpdFxuXG5cbiAgICBjb25zdCBzaW5nbGVDb3VudCA9IHRpdGxlLnNwbGl0KFwiJ1wiKS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGRvdWJsZUNvdW50ID0gdGl0bGUuc3BsaXQoJ1wiJykubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBxdW90ZSA9IHNpbmdsZUNvdW50ID4gZG91YmxlQ291bnQgPyAnXCInIDogZG91YmxlQ291bnQgPiBzaW5nbGVDb3VudCA/IFwiJ1wiIDogb3B0aW9ucy5zaW5nbGVRdW90ZSA/IFwiJ1wiIDogJ1wiJztcbiAgICB0aXRsZSA9IHRpdGxlLnJlcGxhY2UobmV3IFJlZ0V4cChcIihcIi5jb25jYXQocXVvdGUsIFwiKVwiKSwgXCJnXCIpLCBcIlxcXFwkMVwiKTtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQocXVvdGUpLmNvbmNhdCh0aXRsZSkuY29uY2F0KHF1b3RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcnRzJDIocGFydHMpIHtcbiAgICByZXR1cm4gcGFydHMucmVkdWNlKChjdXJyZW50LCBwYXJ0KSA9PiB7XG4gICAgICBjb25zdCBsYXN0UGFydCA9IHV0aWwkMS5nZXRMYXN0KGN1cnJlbnQpO1xuXG4gICAgICBpZiAodHlwZW9mIGxhc3RQYXJ0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwYXJ0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGN1cnJlbnQuc3BsaWNlKC0xLCAxLCBsYXN0UGFydCArIHBhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudC5wdXNoKHBhcnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9LCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW4kNihhc3QsIG5ld09iaiwgcGFyZW50KSB7XG4gICAgZGVsZXRlIG5ld09iai5wb3NpdGlvbjtcbiAgICBkZWxldGUgbmV3T2JqLnJhdzsgLy8gZnJvbnQtbWF0dGVyXG4gICAgLy8gZm9yIGNvZGVibG9ja1xuXG4gICAgaWYgKGFzdC50eXBlID09PSBcImNvZGVcIiB8fCBhc3QudHlwZSA9PT0gXCJ5YW1sXCIgfHwgYXN0LnR5cGUgPT09IFwiaW1wb3J0XCIgfHwgYXN0LnR5cGUgPT09IFwiZXhwb3J0XCIgfHwgYXN0LnR5cGUgPT09IFwianN4XCIpIHtcbiAgICAgIGRlbGV0ZSBuZXdPYmoudmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGFzdC50eXBlID09PSBcImxpc3RcIikge1xuICAgICAgZGVsZXRlIG5ld09iai5pc0FsaWduZWQ7XG4gICAgfSAvLyB0ZXh0cyBjYW4gYmUgc3BsaXR0ZWQgb3IgbWVyZ2VkXG5cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChhc3QudHlwZSA9PT0gXCJpbmxpbmVDb2RlXCIpIHtcbiAgICAgIG5ld09iai52YWx1ZSA9IGFzdC52YWx1ZS5yZXBsYWNlKC9bIFxcdFxcbl0rL2csIFwiIFwiKTtcbiAgICB9IC8vIGZvciBpbnNlcnQgcHJhZ21hXG5cblxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnR5cGUgPT09IFwicm9vdFwiICYmIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPiAwICYmIChwYXJlbnQuY2hpbGRyZW5bMF0gPT09IGFzdCB8fCAocGFyZW50LmNoaWxkcmVuWzBdLnR5cGUgPT09IFwieWFtbFwiIHx8IHBhcmVudC5jaGlsZHJlblswXS50eXBlID09PSBcInRvbWxcIikgJiYgcGFyZW50LmNoaWxkcmVuWzFdID09PSBhc3QpICYmIGFzdC50eXBlID09PSBcImh0bWxcIiAmJiBwcmFnbWEkNC5zdGFydFdpdGhQcmFnbWEoYXN0LnZhbHVlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzUHJldHRpZXJJZ25vcmUkNihwYXRoKSB7XG4gICAgY29uc3QgaW5kZXggPSArcGF0aC5nZXROYW1lKCk7XG5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2Tm9kZSA9IHBhdGguZ2V0UGFyZW50Tm9kZSgpLmNoaWxkcmVuW2luZGV4IC0gMV07XG4gICAgcmV0dXJuIGlzUHJldHRpZXJJZ25vcmUkMShwcmV2Tm9kZSkgPT09IFwibmV4dFwiO1xuICB9XG5cbiAgdmFyIHByaW50ZXJNYXJrZG93biA9IHtcbiAgICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzXzEkMixcbiAgICBwcmludDogZ2VuZXJpY1ByaW50JDUsXG4gICAgZW1iZWQ6IGVtYmVkXzEkMixcbiAgICBtYXNzYWdlQXN0Tm9kZTogY2xlYW4kNixcbiAgICBoYXNQcmV0dGllcklnbm9yZTogaGFzUHJldHRpZXJJZ25vcmUkNixcbiAgICBpbnNlcnRQcmFnbWE6IHByYWdtYSQ0Lmluc2VydFByYWdtYVxuICB9O1xuXG4gIHZhciBvcHRpb25zJDYgPSB7XG4gICAgcHJvc2VXcmFwOiBjb21tb25PcHRpb25zLnByb3NlV3JhcCxcbiAgICBzaW5nbGVRdW90ZTogY29tbW9uT3B0aW9ucy5zaW5nbGVRdW90ZVxuICB9O1xuXG4gIHZhciBuYW1lJGcgPSBcIk1hcmtkb3duXCI7XG4gIHZhciB0eXBlJGYgPSBcInByb3NlXCI7XG4gIHZhciBhbGlhc2VzJDUgPSBbXG4gIFx0XCJwYW5kb2NcIlxuICBdO1xuICB2YXIgYWNlTW9kZSRmID0gXCJtYXJrZG93blwiO1xuICB2YXIgY29kZW1pcnJvck1vZGUkYiA9IFwiZ2ZtXCI7XG4gIHZhciBjb2RlbWlycm9yTWltZVR5cGUkYiA9IFwidGV4dC94LWdmbVwiO1xuICB2YXIgd3JhcCA9IHRydWU7XG4gIHZhciBleHRlbnNpb25zJGYgPSBbXG4gIFx0XCIubWRcIixcbiAgXHRcIi5tYXJrZG93blwiLFxuICBcdFwiLm1kb3duXCIsXG4gIFx0XCIubWR3blwiLFxuICBcdFwiLm1keFwiLFxuICBcdFwiLm1rZFwiLFxuICBcdFwiLm1rZG5cIixcbiAgXHRcIi5ta2Rvd25cIixcbiAgXHRcIi5yb25uXCIsXG4gIFx0XCIud29ya2Jvb2tcIlxuICBdO1xuICB2YXIgZmlsZW5hbWVzJDMgPSBbXG4gIFx0XCJjb250ZW50cy5sclwiXG4gIF07XG4gIHZhciB0bVNjb3BlJGYgPSBcInNvdXJjZS5nZm1cIjtcbiAgdmFyIGxhbmd1YWdlSWQkZiA9IDIyMjtcbiAgdmFyIE1hcmtkb3duID0ge1xuICBcdG5hbWU6IG5hbWUkZyxcbiAgXHR0eXBlOiB0eXBlJGYsXG4gIFx0YWxpYXNlczogYWxpYXNlcyQ1LFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkZixcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkYixcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSRiLFxuICBcdHdyYXA6IHdyYXAsXG4gIFx0ZXh0ZW5zaW9uczogZXh0ZW5zaW9ucyRmLFxuICBcdGZpbGVuYW1lczogZmlsZW5hbWVzJDMsXG4gIFx0dG1TY29wZTogdG1TY29wZSRmLFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkZlxuICB9O1xuXG4gIHZhciBNYXJrZG93biQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBuYW1lOiBuYW1lJGcsXG4gICAgdHlwZTogdHlwZSRmLFxuICAgIGFsaWFzZXM6IGFsaWFzZXMkNSxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJGYsXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJGIsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkYixcbiAgICB3cmFwOiB3cmFwLFxuICAgIGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkZixcbiAgICBmaWxlbmFtZXM6IGZpbGVuYW1lcyQzLFxuICAgIHRtU2NvcGU6IHRtU2NvcGUkZixcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGYsXG4gICAgJ2RlZmF1bHQnOiBNYXJrZG93blxuICB9KTtcblxuICB2YXIgcmVxdWlyZSQkMCQ3ID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShNYXJrZG93biQxKTtcblxuICBjb25zdCBsYW5ndWFnZXMkNSA9IFtjcmVhdGVMYW5ndWFnZShyZXF1aXJlJCQwJDcsIGRhdGEgPT4gKHtcbiAgICBzaW5jZTogXCIxLjguMFwiLFxuICAgIHBhcnNlcnM6IFtcIm1hcmtkb3duXCJdLFxuICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJtYXJrZG93blwiXSxcbiAgICBmaWxlbmFtZXM6IGRhdGEuZmlsZW5hbWVzLmNvbmNhdChbXCJSRUFETUVcIl0pLFxuICAgIGV4dGVuc2lvbnM6IGRhdGEuZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbiAhPT0gXCIubWR4XCIpXG4gIH0pKSwgY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMCQ3LCAoKSA9PiAoe1xuICAgIG5hbWU6IFwiTURYXCIsXG4gICAgc2luY2U6IFwiMS4xNS4wXCIsXG4gICAgcGFyc2VyczogW1wibWR4XCJdLFxuICAgIHZzY29kZUxhbmd1YWdlSWRzOiBbXCJtZHhcIl0sXG4gICAgZmlsZW5hbWVzOiBbXSxcbiAgICBleHRlbnNpb25zOiBbXCIubWR4XCJdXG4gIH0pKV07XG4gIGNvbnN0IHByaW50ZXJzJDUgPSB7XG4gICAgbWRhc3Q6IHByaW50ZXJNYXJrZG93blxuICB9O1xuICB2YXIgbGFuZ3VhZ2VNYXJrZG93biA9IHtcbiAgICBsYW5ndWFnZXM6IGxhbmd1YWdlcyQ1LFxuICAgIG9wdGlvbnM6IG9wdGlvbnMkNixcbiAgICBwcmludGVyczogcHJpbnRlcnMkNVxuICB9O1xuXG4gIGZ1bmN0aW9uIGlzUHJhZ21hKHRleHQpIHtcbiAgICByZXR1cm4gL15cXHMqQChwcmV0dGllcnxmb3JtYXQpXFxzKiQvLnRlc3QodGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNQcmFnbWEkNCh0ZXh0KSB7XG4gICAgcmV0dXJuIC9eXFxzKiNbXlxcblxcU10qQChwcmV0dGllcnxmb3JtYXQpXFxzKj8oXFxufCQpLy50ZXN0KHRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0UHJhZ21hJDgodGV4dCkge1xuICAgIHJldHVybiBcIiMgQGZvcm1hdFxcblxcblwiLmNvbmNhdCh0ZXh0KTtcbiAgfVxuXG4gIHZhciBwcmFnbWEkNSA9IHtcbiAgICBpc1ByYWdtYSxcbiAgICBoYXNQcmFnbWE6IGhhc1ByYWdtYSQ0LFxuICAgIGluc2VydFByYWdtYTogaW5zZXJ0UHJhZ21hJDhcbiAgfTtcblxuICBjb25zdCB7XG4gICAgZ2V0TGFzdDogZ2V0TGFzdCQ1XG4gIH0gPSB1dGlsJDE7XG5cbiAgZnVuY3Rpb24gZ2V0QW5jZXN0b3JDb3VudChwYXRoLCBmaWx0ZXIpIHtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgY29uc3QgcGF0aFN0YWNrTGVuZ3RoID0gcGF0aC5zdGFjay5sZW5ndGggLSAxO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoU3RhY2tMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXRoLnN0YWNrW2ldO1xuXG4gICAgICBpZiAoaXNOb2RlKHZhbHVlKSAmJiBmaWx0ZXIodmFsdWUpKSB7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY291bnRlcjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nW109fSB0eXBlc1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSwgdHlwZXMpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCF0eXBlcyB8fCB0eXBlcy5pbmNsdWRlcyh2YWx1ZS50eXBlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBOb2RlKG5vZGUsIGNhbGxiYWNrLCBwYXJlbnQpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soXCJjaGlsZHJlblwiIGluIG5vZGUgPyBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7XG4gICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5tYXAoY2hpbGROb2RlID0+IG1hcE5vZGUoY2hpbGROb2RlLCBjYWxsYmFjaywgbm9kZSkpXG4gICAgfSkgOiBub2RlLCBwYXJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lU2hvcnRjdXQoeCwga2V5LCBnZXR0ZXIpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoeCwga2V5LCB7XG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05leHRMaW5lRW1wdHkkNShub2RlLCB0ZXh0KSB7XG4gICAgbGV0IG5ld2xpbmVDb3VudCA9IDA7XG4gICAgY29uc3QgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCAtIDE7IGkgPCB0ZXh0TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0W2ldO1xuXG4gICAgICBpZiAoY2hhciA9PT0gXCJcXG5cIikge1xuICAgICAgICBuZXdsaW5lQ291bnQrKztcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld2xpbmVDb3VudCA9PT0gMSAmJiAvXFxTLy50ZXN0KGNoYXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld2xpbmVDb3VudCA9PT0gMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xhc3REZXNjZW5kYW50Tm9kZShwYXRoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwidGFnXCI6XG4gICAgICBjYXNlIFwiYW5jaG9yXCI6XG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aFN0YWNrTGVuZ3RoID0gcGF0aC5zdGFjay5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhdGhTdGFja0xlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gcGF0aC5zdGFja1tpXTtcbiAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSBwYXRoLnN0YWNrW2kgLSAxXTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyZW50SXRlbSkgJiYgdHlwZW9mIGl0ZW0gPT09IFwibnVtYmVyXCIgJiYgaXRlbSAhPT0gcGFyZW50SXRlbS5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExhc3REZXNjZW5kYW50Tm9kZSQxKG5vZGUpIHtcbiAgICByZXR1cm4gXCJjaGlsZHJlblwiIGluIG5vZGUgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDAgPyBnZXRMYXN0RGVzY2VuZGFudE5vZGUkMShnZXRMYXN0JDUobm9kZS5jaGlsZHJlbikpIDogbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUHJldHRpZXJJZ25vcmUkMihjb21tZW50KSB7XG4gICAgcmV0dXJuIGNvbW1lbnQudmFsdWUudHJpbSgpID09PSBcInByZXR0aWVyLWlnbm9yZVwiO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzUHJldHRpZXJJZ25vcmUkNyhwYXRoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcblxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiZG9jdW1lbnRCb2R5XCIpIHtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICByZXR1cm4gaGFzRW5kQ29tbWVudHMoZG9jdW1lbnQuaGVhZCkgJiYgaXNQcmV0dGllcklnbm9yZSQyKGdldExhc3QkNShkb2N1bWVudC5oZWFkLmVuZENvbW1lbnRzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc0xlYWRpbmdDb21tZW50cyhub2RlKSAmJiBpc1ByZXR0aWVySWdub3JlJDIoZ2V0TGFzdCQ1KG5vZGUubGVhZGluZ0NvbW1lbnRzKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VtcHR5Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuICghbm9kZS5jaGlsZHJlbiB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgJiYgIWhhc0NvbW1lbnRzKG5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzQ29tbWVudHMobm9kZSkge1xuICAgIHJldHVybiBoYXNMZWFkaW5nQ29tbWVudHMobm9kZSkgfHwgaGFzTWlkZGxlQ29tbWVudHMobm9kZSkgfHwgaGFzSW5kaWNhdG9yQ29tbWVudChub2RlKSB8fCBoYXNUcmFpbGluZ0NvbW1lbnQkMihub2RlKSB8fCBoYXNFbmRDb21tZW50cyhub2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0xlYWRpbmdDb21tZW50cyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMubGVuZ3RoICE9PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzTWlkZGxlQ29tbWVudHMobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUubWlkZGxlQ29tbWVudHMgJiYgbm9kZS5taWRkbGVDb21tZW50cy5sZW5ndGggIT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNJbmRpY2F0b3JDb21tZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLmluZGljYXRvckNvbW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNUcmFpbGluZ0NvbW1lbnQkMihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS50cmFpbGluZ0NvbW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNFbmRDb21tZW50cyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5lbmRDb21tZW50cyAmJiBub2RlLmVuZENvbW1lbnRzLmxlbmd0aCAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogXCIgYSAgIGIgYyAgIGQgZSAgIGYgXCIgLT4gW1wiIGEgICBiXCIsIFwiYyAgIGRcIiwgXCJlICAgZiBcIl1cbiAgICovXG5cblxuICBmdW5jdGlvbiBzcGxpdFdpdGhTaW5nbGVTcGFjZSh0ZXh0KSB7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBsZXQgbGFzdFBhcnQgPSB1bmRlZmluZWQ7XG5cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGV4dC5zcGxpdCgvKCArKS9nKSkge1xuICAgICAgaWYgKHBhcnQgIT09IFwiIFwiKSB7XG4gICAgICAgIGlmIChsYXN0UGFydCA9PT0gXCIgXCIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnB1c2goKHBhcnRzLnBvcCgpIHx8IFwiXCIpICsgcGFydCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGFzdFBhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0cy51bnNoaWZ0KFwiXCIpO1xuICAgICAgfVxuXG4gICAgICBsYXN0UGFydCA9IHBhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RQYXJ0ID09PSBcIiBcIikge1xuICAgICAgcGFydHMucHVzaCgocGFydHMucG9wKCkgfHwgXCJcIikgKyBcIiBcIik7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzWzBdID09PSBcIlwiKSB7XG4gICAgICBwYXJ0cy5zaGlmdCgpO1xuICAgICAgcGFydHMudW5zaGlmdChcIiBcIiArIChwYXJ0cy5zaGlmdCgpIHx8IFwiXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFydHM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGbG93U2NhbGFyTGluZUNvbnRlbnRzKG5vZGVUeXBlLCBjb250ZW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmF3TGluZUNvbnRlbnRzID0gY29udGVudC5zcGxpdChcIlxcblwiKS5tYXAoKGxpbmVDb250ZW50LCBpbmRleCwgbGluZUNvbnRlbnRzKSA9PiBpbmRleCA9PT0gMCAmJiBpbmRleCA9PT0gbGluZUNvbnRlbnRzLmxlbmd0aCAtIDEgPyBsaW5lQ29udGVudCA6IGluZGV4ICE9PSAwICYmIGluZGV4ICE9PSBsaW5lQ29udGVudHMubGVuZ3RoIC0gMSA/IGxpbmVDb250ZW50LnRyaW0oKSA6IGluZGV4ID09PSAwID8gbGluZUNvbnRlbnQudHJpbUVuZCgpIDogbGluZUNvbnRlbnQudHJpbVN0YXJ0KCkpO1xuXG4gICAgaWYgKG9wdGlvbnMucHJvc2VXcmFwID09PSBcInByZXNlcnZlXCIpIHtcbiAgICAgIHJldHVybiByYXdMaW5lQ29udGVudHMubWFwKGxpbmVDb250ZW50ID0+IGxpbmVDb250ZW50Lmxlbmd0aCA9PT0gMCA/IFtdIDogW2xpbmVDb250ZW50XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0xpbmVDb250ZW50cy5tYXAobGluZUNvbnRlbnQgPT4gbGluZUNvbnRlbnQubGVuZ3RoID09PSAwID8gW10gOiBzcGxpdFdpdGhTaW5nbGVTcGFjZShsaW5lQ29udGVudCkpLnJlZHVjZSgocmVkdWNlZCwgbGluZUNvbnRlbnRXb3JkcywgaW5kZXgpID0+IGluZGV4ICE9PSAwICYmIHJhd0xpbmVDb250ZW50c1tpbmRleCAtIDFdLmxlbmd0aCAhPT0gMCAmJiBsaW5lQ29udGVudFdvcmRzLmxlbmd0aCAhPT0gMCAmJiAhKCAvLyB0cmFpbGluZyBiYWNrc2xhc2ggaW4gcXVvdGVEb3VibGUgc2hvdWxkIGJlIHByZXNlcnZlZFxuICAgIG5vZGVUeXBlID09PSBcInF1b3RlRG91YmxlXCIgJiYgZ2V0TGFzdCQ1KGdldExhc3QkNShyZWR1Y2VkKSkuZW5kc1dpdGgoXCJcXFxcXCIpKSA/IHJlZHVjZWQuY29uY2F0KFtyZWR1Y2VkLnBvcCgpLmNvbmNhdChsaW5lQ29udGVudFdvcmRzKV0pIDogcmVkdWNlZC5jb25jYXQoW2xpbmVDb250ZW50V29yZHNdKSwgW10pLm1hcChsaW5lQ29udGVudFdvcmRzID0+IG9wdGlvbnMucHJvc2VXcmFwID09PSBcIm5ldmVyXCIgPyBbbGluZUNvbnRlbnRXb3Jkcy5qb2luKFwiIFwiKV0gOiBsaW5lQ29udGVudFdvcmRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJsb2NrVmFsdWVMaW5lQ29udGVudHMobm9kZSwge1xuICAgIHBhcmVudEluZGVudCxcbiAgICBpc0xhc3REZXNjZW5kYW50LFxuICAgIG9wdGlvbnNcbiAgfSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBub2RlLnBvc2l0aW9uLnN0YXJ0LmxpbmUgPT09IG5vZGUucG9zaXRpb24uZW5kLmxpbmUgPyBcIlwiIDogb3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCkgLy8gZXhjbHVkZSBvcGVuIGxpbmUgYD5gIG9yIGB8YFxuICAgIC5tYXRjaCgvXlteXFxuXSo/XFxuKFtcXHNcXFNdKikkLylbMV07XG4gICAgY29uc3QgbGVhZGluZ1NwYWNlQ291bnQgPSBub2RlLmluZGVudCA9PT0gbnVsbCA/IChtYXRjaCA9PiBtYXRjaCA/IG1hdGNoWzFdLmxlbmd0aCA6IEluZmluaXR5KShjb250ZW50Lm1hdGNoKC9eKCAqKVxcUy9tKSkgOiBub2RlLmluZGVudCAtIDEgKyBwYXJlbnRJbmRlbnQ7XG4gICAgY29uc3QgcmF3TGluZUNvbnRlbnRzID0gY29udGVudC5zcGxpdChcIlxcblwiKS5tYXAobGluZUNvbnRlbnQgPT4gbGluZUNvbnRlbnQuc2xpY2UobGVhZGluZ1NwYWNlQ291bnQpKTtcblxuICAgIGlmIChvcHRpb25zLnByb3NlV3JhcCA9PT0gXCJwcmVzZXJ2ZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJibG9ja0xpdGVyYWxcIikge1xuICAgICAgcmV0dXJuIHJlbW92ZVVubmVjZXNzYXJ5VHJhaWxpbmdOZXdsaW5lcyhyYXdMaW5lQ29udGVudHMubWFwKGxpbmVDb250ZW50ID0+IGxpbmVDb250ZW50Lmxlbmd0aCA9PT0gMCA/IFtdIDogW2xpbmVDb250ZW50XSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVVbm5lY2Vzc2FyeVRyYWlsaW5nTmV3bGluZXMocmF3TGluZUNvbnRlbnRzLm1hcChsaW5lQ29udGVudCA9PiBsaW5lQ29udGVudC5sZW5ndGggPT09IDAgPyBbXSA6IHNwbGl0V2l0aFNpbmdsZVNwYWNlKGxpbmVDb250ZW50KSkucmVkdWNlKChyZWR1Y2VkLCBsaW5lQ29udGVudFdvcmRzLCBpbmRleCkgPT4gaW5kZXggIT09IDAgJiYgcmF3TGluZUNvbnRlbnRzW2luZGV4IC0gMV0ubGVuZ3RoICE9PSAwICYmIGxpbmVDb250ZW50V29yZHMubGVuZ3RoICE9PSAwICYmICEvXlxccy8udGVzdChsaW5lQ29udGVudFdvcmRzWzBdKSAmJiAhL15cXHN8XFxzJC8udGVzdChnZXRMYXN0JDUocmVkdWNlZCkpID8gcmVkdWNlZC5jb25jYXQoW3JlZHVjZWQucG9wKCkuY29uY2F0KGxpbmVDb250ZW50V29yZHMpXSkgOiByZWR1Y2VkLmNvbmNhdChbbGluZUNvbnRlbnRXb3Jkc10pLCBbXSkubWFwKGxpbmVDb250ZW50V29yZHMgPT4gbGluZUNvbnRlbnRXb3Jkcy5yZWR1Y2UoKHJlZHVjZWQsIHdvcmQpID0+IC8vIGRpc2FsbG93IHRyYWlsaW5nIHNwYWNlc1xuICAgIHJlZHVjZWQubGVuZ3RoICE9PSAwICYmIC9cXHMkLy50ZXN0KGdldExhc3QkNShyZWR1Y2VkKSkgPyByZWR1Y2VkLmNvbmNhdChyZWR1Y2VkLnBvcCgpICsgXCIgXCIgKyB3b3JkKSA6IHJlZHVjZWQuY29uY2F0KHdvcmQpLCBbXSkpLm1hcChsaW5lQ29udGVudFdvcmRzID0+IG9wdGlvbnMucHJvc2VXcmFwID09PSBcIm5ldmVyXCIgPyBbbGluZUNvbnRlbnRXb3Jkcy5qb2luKFwiIFwiKV0gOiBsaW5lQ29udGVudFdvcmRzKSk7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVVbm5lY2Vzc2FyeVRyYWlsaW5nTmV3bGluZXMobGluZUNvbnRlbnRzKSB7XG4gICAgICBpZiAobm9kZS5jaG9tcGluZyA9PT0gXCJrZWVwXCIpIHtcbiAgICAgICAgcmV0dXJuIGdldExhc3QkNShsaW5lQ29udGVudHMpLmxlbmd0aCA9PT0gMCA/IGxpbmVDb250ZW50cy5zbGljZSgwLCAtMSkgOiBsaW5lQ29udGVudHM7XG4gICAgICB9XG5cbiAgICAgIGxldCB0cmFpbGluZ05ld2xpbmVDb3VudCA9IDA7XG5cbiAgICAgIGZvciAobGV0IGkgPSBsaW5lQ29udGVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGxpbmVDb250ZW50c1tpXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0cmFpbGluZ05ld2xpbmVDb3VudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFpbGluZ05ld2xpbmVDb3VudCA9PT0gMCA/IGxpbmVDb250ZW50cyA6IHRyYWlsaW5nTmV3bGluZUNvdW50ID49IDIgJiYgIWlzTGFzdERlc2NlbmRhbnQgPyAvLyBuZXh0IGVtcHR5IGxpbmVcbiAgICAgIGxpbmVDb250ZW50cy5zbGljZSgwLCAtKHRyYWlsaW5nTmV3bGluZUNvdW50IC0gMSkpIDogbGluZUNvbnRlbnRzLnNsaWNlKDAsIC10cmFpbGluZ05ld2xpbmVDb3VudCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHV0aWxzJDcgPSB7XG4gICAgZ2V0TGFzdDogZ2V0TGFzdCQ1LFxuICAgIGdldEFuY2VzdG9yQ291bnQsXG4gICAgaXNOb2RlLFxuICAgIGlzRW1wdHlOb2RlLFxuICAgIG1hcE5vZGUsXG4gICAgZGVmaW5lU2hvcnRjdXQsXG4gICAgaXNOZXh0TGluZUVtcHR5OiBpc05leHRMaW5lRW1wdHkkNSxcbiAgICBpc0xhc3REZXNjZW5kYW50Tm9kZSxcbiAgICBnZXRCbG9ja1ZhbHVlTGluZUNvbnRlbnRzLFxuICAgIGdldEZsb3dTY2FsYXJMaW5lQ29udGVudHMsXG4gICAgZ2V0TGFzdERlc2NlbmRhbnROb2RlOiBnZXRMYXN0RGVzY2VuZGFudE5vZGUkMSxcbiAgICBoYXNQcmV0dGllcklnbm9yZTogaGFzUHJldHRpZXJJZ25vcmUkNyxcbiAgICBoYXNMZWFkaW5nQ29tbWVudHMsXG4gICAgaGFzTWlkZGxlQ29tbWVudHMsXG4gICAgaGFzSW5kaWNhdG9yQ29tbWVudCxcbiAgICBoYXNUcmFpbGluZ0NvbW1lbnQ6IGhhc1RyYWlsaW5nQ29tbWVudCQyLFxuICAgIGhhc0VuZENvbW1lbnRzXG4gIH07XG5cbiAgY29uc3Qge1xuICAgIGluc2VydFByYWdtYTogaW5zZXJ0UHJhZ21hJDksXG4gICAgaXNQcmFnbWE6IGlzUHJhZ21hJDFcbiAgfSA9IHByYWdtYSQ1O1xuICBjb25zdCB7XG4gICAgZ2V0QW5jZXN0b3JDb3VudDogZ2V0QW5jZXN0b3JDb3VudCQxLFxuICAgIGdldEJsb2NrVmFsdWVMaW5lQ29udGVudHM6IGdldEJsb2NrVmFsdWVMaW5lQ29udGVudHMkMSxcbiAgICBnZXRGbG93U2NhbGFyTGluZUNvbnRlbnRzOiBnZXRGbG93U2NhbGFyTGluZUNvbnRlbnRzJDEsXG4gICAgZ2V0TGFzdDogZ2V0TGFzdCQ2LFxuICAgIGdldExhc3REZXNjZW5kYW50Tm9kZTogZ2V0TGFzdERlc2NlbmRhbnROb2RlJDIsXG4gICAgaGFzTGVhZGluZ0NvbW1lbnRzOiBoYXNMZWFkaW5nQ29tbWVudHMkMSxcbiAgICBoYXNNaWRkbGVDb21tZW50czogaGFzTWlkZGxlQ29tbWVudHMkMSxcbiAgICBoYXNJbmRpY2F0b3JDb21tZW50OiBoYXNJbmRpY2F0b3JDb21tZW50JDEsXG4gICAgaGFzVHJhaWxpbmdDb21tZW50OiBoYXNUcmFpbGluZ0NvbW1lbnQkMyxcbiAgICBoYXNFbmRDb21tZW50czogaGFzRW5kQ29tbWVudHMkMSxcbiAgICBoYXNQcmV0dGllcklnbm9yZTogaGFzUHJldHRpZXJJZ25vcmUkOCxcbiAgICBpc0xhc3REZXNjZW5kYW50Tm9kZTogaXNMYXN0RGVzY2VuZGFudE5vZGUkMSxcbiAgICBpc05leHRMaW5lRW1wdHk6IGlzTmV4dExpbmVFbXB0eSQ2LFxuICAgIGlzTm9kZTogaXNOb2RlJDEsXG4gICAgaXNFbXB0eU5vZGU6IGlzRW1wdHlOb2RlJDEsXG4gICAgZGVmaW5lU2hvcnRjdXQ6IGRlZmluZVNob3J0Y3V0JDEsXG4gICAgbWFwTm9kZTogbWFwTm9kZSQxXG4gIH0gPSB1dGlscyQ3O1xuICBjb25zdCBkb2NCdWlsZGVycyQyID0gZG9jdW1lbnQuYnVpbGRlcnM7XG4gIGNvbnN0IHtcbiAgICBjb25kaXRpb25hbEdyb3VwOiBjb25kaXRpb25hbEdyb3VwJDIsXG4gICAgYnJlYWtQYXJlbnQ6IGJyZWFrUGFyZW50JDUsXG4gICAgY29uY2F0OiBjb25jYXQkaCxcbiAgICBkZWRlbnQ6IGRlZGVudCQzLFxuICAgIGRlZGVudFRvUm9vdDogZGVkZW50VG9Sb290JDMsXG4gICAgZmlsbDogZmlsbCQ2LFxuICAgIGdyb3VwOiBncm91cCRnLFxuICAgIGhhcmRsaW5lOiBoYXJkbGluZSRkLFxuICAgIGlmQnJlYWs6IGlmQnJlYWskOCxcbiAgICBqb2luOiBqb2luJGMsXG4gICAgbGluZTogbGluZSRiLFxuICAgIGxpbmVTdWZmaXg6IGxpbmVTdWZmaXgkMixcbiAgICBsaXRlcmFsbGluZTogbGl0ZXJhbGxpbmUkNyxcbiAgICBtYXJrQXNSb290OiBtYXJrQXNSb290JDUsXG4gICAgc29mdGxpbmU6IHNvZnRsaW5lJDhcbiAgfSA9IGRvY0J1aWxkZXJzJDI7XG4gIGNvbnN0IHtcbiAgICByZXBsYWNlRW5kT2ZMaW5lV2l0aDogcmVwbGFjZUVuZE9mTGluZVdpdGgkM1xuICB9ID0gdXRpbCQxO1xuXG4gIGZ1bmN0aW9uIHByZXByb2Nlc3MkMyhhc3QpIHtcbiAgICByZXR1cm4gbWFwTm9kZSQxKGFzdCwgZGVmaW5lU2hvcnRjdXRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZVNob3J0Y3V0cyhub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJkb2N1bWVudFwiOlxuICAgICAgICBkZWZpbmVTaG9ydGN1dCQxKG5vZGUsIFwiaGVhZFwiLCAoKSA9PiBub2RlLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgZGVmaW5lU2hvcnRjdXQkMShub2RlLCBcImJvZHlcIiwgKCkgPT4gbm9kZS5jaGlsZHJlblsxXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiZG9jdW1lbnRCb2R5XCI6XG4gICAgICBjYXNlIFwic2VxdWVuY2VJdGVtXCI6XG4gICAgICBjYXNlIFwiZmxvd1NlcXVlbmNlSXRlbVwiOlxuICAgICAgY2FzZSBcIm1hcHBpbmdLZXlcIjpcbiAgICAgIGNhc2UgXCJtYXBwaW5nVmFsdWVcIjpcbiAgICAgICAgZGVmaW5lU2hvcnRjdXQkMShub2RlLCBcImNvbnRlbnRcIiwgKCkgPT4gbm9kZS5jaGlsZHJlblswXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwibWFwcGluZ0l0ZW1cIjpcbiAgICAgIGNhc2UgXCJmbG93TWFwcGluZ0l0ZW1cIjpcbiAgICAgICAgZGVmaW5lU2hvcnRjdXQkMShub2RlLCBcImtleVwiLCAoKSA9PiBub2RlLmNoaWxkcmVuWzBdKTtcbiAgICAgICAgZGVmaW5lU2hvcnRjdXQkMShub2RlLCBcInZhbHVlXCIsICgpID0+IG5vZGUuY2hpbGRyZW5bMV0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyaWNQcmludCQ2KHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgY29uc3QgdGFnID0gIW5vZGUudGFnID8gXCJcIiA6IHBhdGguY2FsbChwcmludCwgXCJ0YWdcIik7XG4gICAgY29uc3QgYW5jaG9yID0gIW5vZGUuYW5jaG9yID8gXCJcIiA6IHBhdGguY2FsbChwcmludCwgXCJhbmNob3JcIik7XG4gICAgY29uc3QgbmV4dEVtcHR5TGluZSA9IGlzTm9kZSQxKG5vZGUsIFtcIm1hcHBpbmdcIiwgXCJzZXF1ZW5jZVwiLCBcImNvbW1lbnRcIiwgXCJkaXJlY3RpdmVcIiwgXCJtYXBwaW5nSXRlbVwiLCBcInNlcXVlbmNlSXRlbVwiXSkgJiYgIWlzTGFzdERlc2NlbmRhbnROb2RlJDEocGF0aCkgPyBwcmludE5leHRFbXB0eUxpbmUocGF0aCwgb3B0aW9ucy5vcmlnaW5hbFRleHQpIDogXCJcIjtcbiAgICByZXR1cm4gY29uY2F0JGgoW25vZGUudHlwZSAhPT0gXCJtYXBwaW5nVmFsdWVcIiAmJiBoYXNMZWFkaW5nQ29tbWVudHMkMShub2RlKSA/IGNvbmNhdCRoKFtqb2luJGMoaGFyZGxpbmUkZCwgcGF0aC5tYXAocHJpbnQsIFwibGVhZGluZ0NvbW1lbnRzXCIpKSwgaGFyZGxpbmUkZF0pIDogXCJcIiwgdGFnLCB0YWcgJiYgYW5jaG9yID8gXCIgXCIgOiBcIlwiLCBhbmNob3IsIHRhZyB8fCBhbmNob3IgPyBpc05vZGUkMShub2RlLCBbXCJzZXF1ZW5jZVwiLCBcIm1hcHBpbmdcIl0pICYmICFoYXNNaWRkbGVDb21tZW50cyQxKG5vZGUpID8gaGFyZGxpbmUkZCA6IFwiIFwiIDogXCJcIiwgaGFzTWlkZGxlQ29tbWVudHMkMShub2RlKSA/IGNvbmNhdCRoKFtub2RlLm1pZGRsZUNvbW1lbnRzLmxlbmd0aCA9PT0gMSA/IFwiXCIgOiBoYXJkbGluZSRkLCBqb2luJGMoaGFyZGxpbmUkZCwgcGF0aC5tYXAocHJpbnQsIFwibWlkZGxlQ29tbWVudHNcIikpLCBoYXJkbGluZSRkXSkgOiBcIlwiLCBoYXNQcmV0dGllcklnbm9yZSQ4KHBhdGgpID8gY29uY2F0JGgocmVwbGFjZUVuZE9mTGluZVdpdGgkMyhvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCwgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0KSwgbGl0ZXJhbGxpbmUkNykpIDogZ3JvdXAkZyhfcHJpbnQobm9kZSwgcGFyZW50Tm9kZSwgcGF0aCwgb3B0aW9ucywgcHJpbnQpKSwgaGFzVHJhaWxpbmdDb21tZW50JDMobm9kZSkgJiYgIWlzTm9kZSQxKG5vZGUsIFtcImRvY3VtZW50XCIsIFwiZG9jdW1lbnRIZWFkXCJdKSA/IGxpbmVTdWZmaXgkMihjb25jYXQkaChbbm9kZS50eXBlID09PSBcIm1hcHBpbmdWYWx1ZVwiICYmICFub2RlLmNvbnRlbnQgPyBcIlwiIDogXCIgXCIsIHBhcmVudE5vZGUudHlwZSA9PT0gXCJtYXBwaW5nS2V5XCIgJiYgcGF0aC5nZXRQYXJlbnROb2RlKDIpLnR5cGUgPT09IFwibWFwcGluZ1wiICYmIGlzSW5saW5lTm9kZShub2RlKSA/IFwiXCIgOiBicmVha1BhcmVudCQ1LCBwYXRoLmNhbGwocHJpbnQsIFwidHJhaWxpbmdDb21tZW50XCIpXSkpIDogXCJcIiwgbmV4dEVtcHR5TGluZSwgaGFzRW5kQ29tbWVudHMkMShub2RlKSAmJiAhaXNOb2RlJDEobm9kZSwgW1wiZG9jdW1lbnRIZWFkXCIsIFwiZG9jdW1lbnRCb2R5XCJdKSA/IGFsaWduJDMobm9kZS50eXBlID09PSBcInNlcXVlbmNlSXRlbVwiID8gMiA6IDAsIGNvbmNhdCRoKFtoYXJkbGluZSRkLCBqb2luJGMoaGFyZGxpbmUkZCwgcGF0aC5tYXAocHJpbnQsIFwiZW5kQ29tbWVudHNcIikpXSkpIDogXCJcIl0pO1xuICB9XG5cbiAgZnVuY3Rpb24gX3ByaW50KG5vZGUsIHBhcmVudE5vZGUsIHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgIHJldHVybiBjb25jYXQkaChbam9pbiRjKGhhcmRsaW5lJGQsIHBhdGgubWFwKChjaGlsZFBhdGgsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBub2RlLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICBjb25zdCBuZXh0RG9jdW1lbnQgPSBub2RlLmNoaWxkcmVuW2luZGV4ICsgMV07XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtwcmludChjaGlsZFBhdGgpLCBzaG91bGRQcmludERvY3VtZW50RW5kTWFya2VyKGRvY3VtZW50LCBuZXh0RG9jdW1lbnQpID8gY29uY2F0JGgoW2hhcmRsaW5lJGQsIFwiLi4uXCIsIGhhc1RyYWlsaW5nQ29tbWVudCQzKGRvY3VtZW50KSA/IGNvbmNhdCRoKFtcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInRyYWlsaW5nQ29tbWVudFwiKV0pIDogXCJcIl0pIDogIW5leHREb2N1bWVudCB8fCBoYXNUcmFpbGluZ0NvbW1lbnQkMyhuZXh0RG9jdW1lbnQuaGVhZCkgPyBcIlwiIDogY29uY2F0JGgoW2hhcmRsaW5lJGQsIFwiLS0tXCJdKV0pO1xuICAgICAgICB9LCBcImNoaWxkcmVuXCIpKSwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgKGxhc3REZXNjZW5kYW50Tm9kZSA9PiBpc05vZGUkMShsYXN0RGVzY2VuZGFudE5vZGUsIFtcImJsb2NrTGl0ZXJhbFwiLCBcImJsb2NrRm9sZGVkXCJdKSAmJiBsYXN0RGVzY2VuZGFudE5vZGUuY2hvbXBpbmcgPT09IFwia2VlcFwiKShnZXRMYXN0RGVzY2VuZGFudE5vZGUkMihub2RlKSkgPyBcIlwiIDogaGFyZGxpbmUkZF0pO1xuXG4gICAgICBjYXNlIFwiZG9jdW1lbnRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5leHREb2N1bWVudCA9IHBhcmVudE5vZGUuY2hpbGRyZW5bcGF0aC5nZXROYW1lKCkgKyAxXTtcbiAgICAgICAgICByZXR1cm4gam9pbiRjKGhhcmRsaW5lJGQsIFtzaG91bGRQcmludERvY3VtZW50SGVhZEVuZE1hcmtlcihub2RlLCBuZXh0RG9jdW1lbnQsIHBhcmVudE5vZGUsIG9wdGlvbnMpID09PSBcImhlYWRcIiA/IGpvaW4kYyhoYXJkbGluZSRkLCBbbm9kZS5oZWFkLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiBub2RlLmhlYWQuZW5kQ29tbWVudHMubGVuZ3RoID09PSAwID8gXCJcIiA6IHBhdGguY2FsbChwcmludCwgXCJoZWFkXCIpLCBjb25jYXQkaChbXCItLS1cIiwgaGFzVHJhaWxpbmdDb21tZW50JDMobm9kZS5oZWFkKSA/IGNvbmNhdCRoKFtcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImhlYWRcIiwgXCJ0cmFpbGluZ0NvbW1lbnRcIildKSA6IFwiXCJdKV0uZmlsdGVyKEJvb2xlYW4pKSA6IFwiXCIsIHNob3VsZFByaW50RG9jdW1lbnRCb2R5KG5vZGUpID8gcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikgOiBcIlwiXS5maWx0ZXIoQm9vbGVhbikpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJkb2N1bWVudEhlYWRcIjpcbiAgICAgICAgcmV0dXJuIGpvaW4kYyhoYXJkbGluZSRkLCBbXS5jb25jYXQocGF0aC5tYXAocHJpbnQsIFwiY2hpbGRyZW5cIiksIHBhdGgubWFwKHByaW50LCBcImVuZENvbW1lbnRzXCIpKSk7XG5cbiAgICAgIGNhc2UgXCJkb2N1bWVudEJvZHlcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gam9pbiRjKGhhcmRsaW5lJGQsIHBhdGgubWFwKHByaW50LCBcImNoaWxkcmVuXCIpKS5wYXJ0cztcbiAgICAgICAgICBjb25zdCBlbmRDb21tZW50cyA9IGpvaW4kYyhoYXJkbGluZSRkLCBwYXRoLm1hcChwcmludCwgXCJlbmRDb21tZW50c1wiKSkucGFydHM7XG4gICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IGVuZENvbW1lbnRzLmxlbmd0aCA9PT0gMCA/IFwiXCIgOiAobGFzdERlc2NlbmRhbnROb2RlID0+IGlzTm9kZSQxKGxhc3REZXNjZW5kYW50Tm9kZSwgW1wiYmxvY2tGb2xkZWRcIiwgXCJibG9ja0xpdGVyYWxcIl0pID8gbGFzdERlc2NlbmRhbnROb2RlLmNob21waW5nID09PSBcImtlZXBcIiA/IC8vIHRoZXJlJ3MgYWxyZWFkeSBhIG5ld2xpbmUgcHJpbnRlZCBhdCB0aGUgZW5kIG9mIGJsb2NrVmFsdWUgKGNob21waW5nPWtlZXAsIGxhc3REZXNjZW5kYW50PXRydWUpXG4gICAgICAgICAgXCJcIiA6IC8vIGFuIGV4dHJhIG5ld2xpbmUgZm9yIGJldHRlciByZWFkYWJpbGl0eVxuICAgICAgICAgIGNvbmNhdCRoKFtoYXJkbGluZSRkLCBoYXJkbGluZSRkXSkgOiBoYXJkbGluZSRkKShnZXRMYXN0RGVzY2VuZGFudE5vZGUkMihub2RlKSk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtdLmNvbmNhdChjaGlsZHJlbiwgc2VwYXJhdG9yLCBlbmRDb21tZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJkaXJlY3RpdmVcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtcIiVcIiwgam9pbiRjKFwiIFwiLCBbbm9kZS5uYW1lXS5jb25jYXQobm9kZS5wYXJhbWV0ZXJzKSldKTtcblxuICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtcIiNcIiwgbm9kZS52YWx1ZV0pO1xuXG4gICAgICBjYXNlIFwiYWxpYXNcIjpcbiAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtcIipcIiwgbm9kZS52YWx1ZV0pO1xuXG4gICAgICBjYXNlIFwidGFnXCI6XG4gICAgICAgIHJldHVybiBvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShub2RlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCwgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0KTtcblxuICAgICAgY2FzZSBcImFuY2hvclwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGgoW1wiJlwiLCBub2RlLnZhbHVlXSk7XG5cbiAgICAgIGNhc2UgXCJwbGFpblwiOlxuICAgICAgICByZXR1cm4gcHJpbnRGbG93U2NhbGFyQ29udGVudChub2RlLnR5cGUsIG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG5vZGUucG9zaXRpb24uc3RhcnQub2Zmc2V0LCBub2RlLnBvc2l0aW9uLmVuZC5vZmZzZXQpLCBvcHRpb25zKTtcblxuICAgICAgY2FzZSBcInF1b3RlRG91YmxlXCI6XG4gICAgICBjYXNlIFwicXVvdGVTaW5nbGVcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHNpbmdsZVF1b3RlID0gXCInXCI7XG4gICAgICAgICAgY29uc3QgZG91YmxlUXVvdGUgPSAnXCInO1xuICAgICAgICAgIGNvbnN0IHJhdyA9IG9wdGlvbnMub3JpZ2luYWxUZXh0LnNsaWNlKG5vZGUucG9zaXRpb24uc3RhcnQub2Zmc2V0ICsgMSwgbm9kZS5wb3NpdGlvbi5lbmQub2Zmc2V0IC0gMSk7XG5cbiAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcInF1b3RlU2luZ2xlXCIgJiYgcmF3LmluY2x1ZGVzKFwiXFxcXFwiKSB8fCBub2RlLnR5cGUgPT09IFwicXVvdGVEb3VibGVcIiAmJiAvXFxcXFteXCJdLy50ZXN0KHJhdykpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcXVvdGVEb3VibGUgY2FuIHVzZSBlc2NhcGUgY2hhcnNcbiAgICAgICAgICAgIC8vIGFuZCBxdW90ZVNpbmdsZSBkbyBub3QgbmVlZCB0byBlc2NhcGUgYmFja3NsYXNoZXNcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUXVvdGUgPSBub2RlLnR5cGUgPT09IFwicXVvdGVEb3VibGVcIiA/IGRvdWJsZVF1b3RlIDogc2luZ2xlUXVvdGU7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGgoW29yaWdpbmFsUXVvdGUsIHByaW50Rmxvd1NjYWxhckNvbnRlbnQobm9kZS50eXBlLCByYXcsIG9wdGlvbnMpLCBvcmlnaW5hbFF1b3RlXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYXcuaW5jbHVkZXMoZG91YmxlUXVvdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGgoW3NpbmdsZVF1b3RlLCBwcmludEZsb3dTY2FsYXJDb250ZW50KG5vZGUudHlwZSwgbm9kZS50eXBlID09PSBcInF1b3RlRG91YmxlXCIgPyByYXcgLy8gZG91YmxlIHF1b3RlIG5lZWRzIHRvIGJlIGVzY2FwZWQgYnkgYmFja3NsYXNoIGluIHF1b3RlRG91YmxlXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csIGRvdWJsZVF1b3RlKS5yZXBsYWNlKC8nL2csIHNpbmdsZVF1b3RlLnJlcGVhdCgyKSkgOiByYXcsIG9wdGlvbnMpLCBzaW5nbGVRdW90ZV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyYXcuaW5jbHVkZXMoc2luZ2xlUXVvdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGgoW2RvdWJsZVF1b3RlLCBwcmludEZsb3dTY2FsYXJDb250ZW50KG5vZGUudHlwZSwgbm9kZS50eXBlID09PSBcInF1b3RlU2luZ2xlXCIgPyAvLyBzaW5nbGUgcXVvdGUgbmVlZHMgdG8gYmUgZXNjYXBlZCBieSAyIHNpbmdsZSBxdW90ZXMgaW4gcXVvdGVTaW5nbGVcbiAgICAgICAgICAgIHJhdy5yZXBsYWNlKC8nJy9nLCBzaW5nbGVRdW90ZSkgOiByYXcsIG9wdGlvbnMpLCBkb3VibGVRdW90ZV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHF1b3RlID0gb3B0aW9ucy5zaW5nbGVRdW90ZSA/IHNpbmdsZVF1b3RlIDogZG91YmxlUXVvdGU7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtxdW90ZSwgcHJpbnRGbG93U2NhbGFyQ29udGVudChub2RlLnR5cGUsIHJhdywgb3B0aW9ucyksIHF1b3RlXSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImJsb2NrRm9sZGVkXCI6XG4gICAgICBjYXNlIFwiYmxvY2tMaXRlcmFsXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRJbmRlbnQgPSBnZXRBbmNlc3RvckNvdW50JDEocGF0aCwgYW5jZXN0b3JOb2RlID0+IGlzTm9kZSQxKGFuY2VzdG9yTm9kZSwgW1wic2VxdWVuY2VcIiwgXCJtYXBwaW5nXCJdKSk7XG4gICAgICAgICAgY29uc3QgaXNMYXN0RGVzY2VuZGFudCA9IGlzTGFzdERlc2NlbmRhbnROb2RlJDEocGF0aCk7XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtub2RlLnR5cGUgPT09IFwiYmxvY2tGb2xkZWRcIiA/IFwiPlwiIDogXCJ8XCIsIG5vZGUuaW5kZW50ID09PSBudWxsID8gXCJcIiA6IG5vZGUuaW5kZW50LnRvU3RyaW5nKCksIG5vZGUuY2hvbXBpbmcgPT09IFwiY2xpcFwiID8gXCJcIiA6IG5vZGUuY2hvbXBpbmcgPT09IFwia2VlcFwiID8gXCIrXCIgOiBcIi1cIiwgaGFzSW5kaWNhdG9yQ29tbWVudCQxKG5vZGUpID8gY29uY2F0JGgoW1wiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaW5kaWNhdG9yQ29tbWVudFwiKV0pIDogXCJcIiwgKG5vZGUuaW5kZW50ID09PSBudWxsID8gZGVkZW50JDMgOiBkZWRlbnRUb1Jvb3QkMykoYWxpZ24kMyhub2RlLmluZGVudCA9PT0gbnVsbCA/IG9wdGlvbnMudGFiV2lkdGggOiBub2RlLmluZGVudCAtIDEgKyBwYXJlbnRJbmRlbnQsIGNvbmNhdCRoKGdldEJsb2NrVmFsdWVMaW5lQ29udGVudHMkMShub2RlLCB7XG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQsXG4gICAgICAgICAgICBpc0xhc3REZXNjZW5kYW50LFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pLnJlZHVjZSgocmVkdWNlZCwgbGluZVdvcmRzLCBpbmRleCwgbGluZUNvbnRlbnRzKSA9PiByZWR1Y2VkLmNvbmNhdChpbmRleCA9PT0gMCA/IGhhcmRsaW5lJGQgOiBcIlwiLCBmaWxsJDYoam9pbiRjKGxpbmUkYiwgbGluZVdvcmRzKS5wYXJ0cyksIGluZGV4ICE9PSBsaW5lQ29udGVudHMubGVuZ3RoIC0gMSA/IGxpbmVXb3Jkcy5sZW5ndGggPT09IDAgPyBoYXJkbGluZSRkIDogbWFya0FzUm9vdCQ1KGxpdGVyYWxsaW5lJDcpIDogbm9kZS5jaG9tcGluZyA9PT0gXCJrZWVwXCIgJiYgaXNMYXN0RGVzY2VuZGFudCA/IGxpbmVXb3Jkcy5sZW5ndGggPT09IDAgPyBkZWRlbnRUb1Jvb3QkMyhoYXJkbGluZSRkKSA6IGRlZGVudFRvUm9vdCQzKGxpdGVyYWxsaW5lJDcpIDogXCJcIiksIFtdKSkpKV0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJzZXF1ZW5jZVwiOlxuICAgICAgICByZXR1cm4gam9pbiRjKGhhcmRsaW5lJGQsIHBhdGgubWFwKHByaW50LCBcImNoaWxkcmVuXCIpKTtcblxuICAgICAgY2FzZSBcInNlcXVlbmNlSXRlbVwiOlxuICAgICAgICByZXR1cm4gY29uY2F0JGgoW1wiLSBcIiwgYWxpZ24kMygyLCAhbm9kZS5jb250ZW50ID8gXCJcIiA6IHBhdGguY2FsbChwcmludCwgXCJjb250ZW50XCIpKV0pO1xuXG4gICAgICBjYXNlIFwibWFwcGluZ0tleVwiOlxuICAgICAgICByZXR1cm4gIW5vZGUuY29udGVudCA/IFwiXCIgOiBwYXRoLmNhbGwocHJpbnQsIFwiY29udGVudFwiKTtcblxuICAgICAgY2FzZSBcIm1hcHBpbmdWYWx1ZVwiOlxuICAgICAgICByZXR1cm4gIW5vZGUuY29udGVudCA/IFwiXCIgOiBwYXRoLmNhbGwocHJpbnQsIFwiY29udGVudFwiKTtcblxuICAgICAgY2FzZSBcIm1hcHBpbmdcIjpcbiAgICAgICAgcmV0dXJuIGpvaW4kYyhoYXJkbGluZSRkLCBwYXRoLm1hcChwcmludCwgXCJjaGlsZHJlblwiKSk7XG5cbiAgICAgIGNhc2UgXCJtYXBwaW5nSXRlbVwiOlxuICAgICAgY2FzZSBcImZsb3dNYXBwaW5nSXRlbVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgaXNFbXB0eU1hcHBpbmdLZXkgPSBpc0VtcHR5Tm9kZSQxKG5vZGUua2V5KTtcbiAgICAgICAgICBjb25zdCBpc0VtcHR5TWFwcGluZ1ZhbHVlID0gaXNFbXB0eU5vZGUkMShub2RlLnZhbHVlKTtcblxuICAgICAgICAgIGlmIChpc0VtcHR5TWFwcGluZ0tleSAmJiBpc0VtcHR5TWFwcGluZ1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0JGgoW1wiOiBcIl0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGtleSA9IHBhdGguY2FsbChwcmludCwgXCJrZXlcIik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIik7XG5cbiAgICAgICAgICBpZiAoaXNFbXB0eU1hcHBpbmdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJmbG93TWFwcGluZ0l0ZW1cIiAmJiBwYXJlbnROb2RlLnR5cGUgPT09IFwiZmxvd01hcHBpbmdcIiA/IGtleSA6IG5vZGUudHlwZSA9PT0gXCJtYXBwaW5nSXRlbVwiICYmIGlzQWJzb2x1dGVseVByaW50ZWRBc1NpbmdsZUxpbmVOb2RlKG5vZGUua2V5LmNvbnRlbnQsIG9wdGlvbnMpICYmICFoYXNUcmFpbGluZ0NvbW1lbnQkMyhub2RlLmtleS5jb250ZW50KSAmJiAoIXBhcmVudE5vZGUudGFnIHx8IHBhcmVudE5vZGUudGFnLnZhbHVlICE9PSBcInRhZzp5YW1sLm9yZywyMDAyOnNldFwiKSA/IGNvbmNhdCRoKFtrZXksIG5lZWRzU3BhY2VJbkZyb250T2ZNYXBwaW5nVmFsdWUobm9kZSkgPyBcIiBcIiA6IFwiXCIsIFwiOlwiXSkgOiBjb25jYXQkaChbXCI/IFwiLCBhbGlnbiQzKDIsIGtleSldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNFbXB0eU1hcHBpbmdLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQkaChbXCI6IFwiLCBhbGlnbiQzKDIsIHZhbHVlKV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGdyb3VwSWQgPSBTeW1ib2woXCJtYXBwaW5nS2V5XCIpO1xuICAgICAgICAgIGNvbnN0IGZvcmNlRXhwbGljaXRLZXkgPSBoYXNMZWFkaW5nQ29tbWVudHMkMShub2RlLnZhbHVlKSB8fCAhaXNJbmxpbmVOb2RlKG5vZGUua2V5LmNvbnRlbnQpO1xuICAgICAgICAgIHJldHVybiBmb3JjZUV4cGxpY2l0S2V5ID8gY29uY2F0JGgoW1wiPyBcIiwgYWxpZ24kMygyLCBrZXkpLCBoYXJkbGluZSRkLCBqb2luJGMoXCJcIiwgcGF0aC5tYXAocHJpbnQsIFwidmFsdWVcIiwgXCJsZWFkaW5nQ29tbWVudHNcIikubWFwKGNvbW1lbnQgPT4gY29uY2F0JGgoW2NvbW1lbnQsIGhhcmRsaW5lJGRdKSkpLCBcIjogXCIsIGFsaWduJDMoMiwgdmFsdWUpXSkgOiAvLyBmb3JjZSBzaW5nbGVsaW5lXG4gICAgICAgICAgaXNTaW5nbGVMaW5lTm9kZShub2RlLmtleS5jb250ZW50KSAmJiAhaGFzTGVhZGluZ0NvbW1lbnRzJDEobm9kZS5rZXkuY29udGVudCkgJiYgIWhhc01pZGRsZUNvbW1lbnRzJDEobm9kZS5rZXkuY29udGVudCkgJiYgIWhhc1RyYWlsaW5nQ29tbWVudCQzKG5vZGUua2V5LmNvbnRlbnQpICYmICFoYXNFbmRDb21tZW50cyQxKG5vZGUua2V5KSAmJiAhaGFzTGVhZGluZ0NvbW1lbnRzJDEobm9kZS52YWx1ZS5jb250ZW50KSAmJiAhaGFzTWlkZGxlQ29tbWVudHMkMShub2RlLnZhbHVlLmNvbnRlbnQpICYmICFoYXNFbmRDb21tZW50cyQxKG5vZGUudmFsdWUpICYmIGlzQWJzb2x1dGVseVByaW50ZWRBc1NpbmdsZUxpbmVOb2RlKG5vZGUudmFsdWUuY29udGVudCwgb3B0aW9ucykgPyBjb25jYXQkaChba2V5LCBuZWVkc1NwYWNlSW5Gcm9udE9mTWFwcGluZ1ZhbHVlKG5vZGUpID8gXCIgXCIgOiBcIlwiLCBcIjogXCIsIHZhbHVlXSkgOiBjb25kaXRpb25hbEdyb3VwJDIoW2NvbmNhdCRoKFtncm91cCRnKGNvbmNhdCRoKFtpZkJyZWFrJDgoXCI/IFwiKSwgZ3JvdXAkZyhhbGlnbiQzKDIsIGtleSksIHtcbiAgICAgICAgICAgIGlkOiBncm91cElkXG4gICAgICAgICAgfSldKSksIGlmQnJlYWskOChjb25jYXQkaChbaGFyZGxpbmUkZCwgXCI6IFwiLCBhbGlnbiQzKDIsIHZhbHVlKV0pLCBpbmRlbnQoY29uY2F0JGgoW25lZWRzU3BhY2VJbkZyb250T2ZNYXBwaW5nVmFsdWUobm9kZSkgPyBcIiBcIiA6IFwiXCIsIFwiOlwiLCBoYXNMZWFkaW5nQ29tbWVudHMkMShub2RlLnZhbHVlLmNvbnRlbnQpIHx8IGhhc0VuZENvbW1lbnRzJDEobm9kZS52YWx1ZSkgJiYgbm9kZS52YWx1ZS5jb250ZW50ICYmICFpc05vZGUkMShub2RlLnZhbHVlLmNvbnRlbnQsIFtcIm1hcHBpbmdcIiwgXCJzZXF1ZW5jZVwiXSkgfHwgcGFyZW50Tm9kZS50eXBlID09PSBcIm1hcHBpbmdcIiAmJiBoYXNUcmFpbGluZ0NvbW1lbnQkMyhub2RlLmtleS5jb250ZW50KSAmJiBpc0lubGluZU5vZGUobm9kZS52YWx1ZS5jb250ZW50KSB8fCBpc05vZGUkMShub2RlLnZhbHVlLmNvbnRlbnQsIFtcIm1hcHBpbmdcIiwgXCJzZXF1ZW5jZVwiXSkgJiYgbm9kZS52YWx1ZS5jb250ZW50LnRhZyA9PT0gbnVsbCAmJiBub2RlLnZhbHVlLmNvbnRlbnQuYW5jaG9yID09PSBudWxsID8gaGFyZGxpbmUkZCA6ICFub2RlLnZhbHVlLmNvbnRlbnQgPyBcIlwiIDogbGluZSRiLCB2YWx1ZV0pKSwge1xuICAgICAgICAgICAgZ3JvdXBJZFxuICAgICAgICAgIH0pXSldKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZmxvd01hcHBpbmdcIjpcbiAgICAgIGNhc2UgXCJmbG93U2VxdWVuY2VcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG9wZW5NYXJrZXIgPSBub2RlLnR5cGUgPT09IFwiZmxvd01hcHBpbmdcIiA/IFwie1wiIDogXCJbXCI7XG4gICAgICAgICAgY29uc3QgY2xvc2VNYXJrZXIgPSBub2RlLnR5cGUgPT09IFwiZmxvd01hcHBpbmdcIiA/IFwifVwiIDogXCJdXCI7XG4gICAgICAgICAgY29uc3QgYnJhY2tldFNwYWNpbmcgPSBub2RlLnR5cGUgPT09IFwiZmxvd01hcHBpbmdcIiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCAmJiBvcHRpb25zLmJyYWNrZXRTcGFjaW5nID8gbGluZSRiIDogc29mdGxpbmUkODtcblxuICAgICAgICAgIGNvbnN0IGlzTGFzdEl0ZW1FbXB0eU1hcHBpbmdJdGVtID0gbm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDAgJiYgKGxhc3RJdGVtID0+IGxhc3RJdGVtLnR5cGUgPT09IFwiZmxvd01hcHBpbmdJdGVtXCIgJiYgaXNFbXB0eU5vZGUkMShsYXN0SXRlbS5rZXkpICYmIGlzRW1wdHlOb2RlJDEobGFzdEl0ZW0udmFsdWUpKShnZXRMYXN0JDYobm9kZS5jaGlsZHJlbikpO1xuXG4gICAgICAgICAgcmV0dXJuIGNvbmNhdCRoKFtvcGVuTWFya2VyLCBpbmRlbnQoY29uY2F0JGgoW2JyYWNrZXRTcGFjaW5nLCBjb25jYXQkaChwYXRoLm1hcCgoY2hpbGRQYXRoLCBpbmRleCkgPT4gY29uY2F0JGgoW3ByaW50KGNoaWxkUGF0aCksIGluZGV4ID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDEgPyBcIlwiIDogY29uY2F0JGgoW1wiLFwiLCBsaW5lJGIsIG5vZGUuY2hpbGRyZW5baW5kZXhdLnBvc2l0aW9uLnN0YXJ0LmxpbmUgIT09IG5vZGUuY2hpbGRyZW5baW5kZXggKyAxXS5wb3NpdGlvbi5zdGFydC5saW5lID8gcHJpbnROZXh0RW1wdHlMaW5lKGNoaWxkUGF0aCwgb3B0aW9ucy5vcmlnaW5hbFRleHQpIDogXCJcIl0pXSksIFwiY2hpbGRyZW5cIikpLCBpZkJyZWFrJDgoXCIsXCIsIFwiXCIpXSkpLCBpc0xhc3RJdGVtRW1wdHlNYXBwaW5nSXRlbSA/IFwiXCIgOiBicmFja2V0U3BhY2luZywgY2xvc2VNYXJrZXJdKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFwiZmxvd1NlcXVlbmNlSXRlbVwiOlxuICAgICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcImNvbnRlbnRcIik7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIi5jb25jYXQobm9kZS50eXBlKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5kZW50KGRvYykge1xuICAgICAgcmV0dXJuIGRvY0J1aWxkZXJzJDIuYWxpZ24oXCIgXCIucmVwZWF0KG9wdGlvbnMudGFiV2lkdGgpLCBkb2MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsaWduJDMobiwgZG9jKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuID09PSBcIm51bWJlclwiICYmIG4gPiAwID8gZG9jQnVpbGRlcnMkMi5hbGlnbihcIiBcIi5yZXBlYXQobiksIGRvYykgOiBkb2NCdWlsZGVycyQyLmFsaWduKG4sIGRvYyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lubGluZU5vZGUobm9kZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJwbGFpblwiOlxuICAgICAgY2FzZSBcInF1b3RlRG91YmxlXCI6XG4gICAgICBjYXNlIFwicXVvdGVTaW5nbGVcIjpcbiAgICAgIGNhc2UgXCJhbGlhc1wiOlxuICAgICAgY2FzZSBcImZsb3dNYXBwaW5nXCI6XG4gICAgICBjYXNlIFwiZmxvd1NlcXVlbmNlXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTaW5nbGVMaW5lTm9kZShub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcInBsYWluXCI6XG4gICAgICBjYXNlIFwicXVvdGVEb3VibGVcIjpcbiAgICAgIGNhc2UgXCJxdW90ZVNpbmdsZVwiOlxuICAgICAgICByZXR1cm4gbm9kZS5wb3NpdGlvbi5zdGFydC5saW5lID09PSBub2RlLnBvc2l0aW9uLmVuZC5saW5lO1xuXG4gICAgICBjYXNlIFwiYWxpYXNcIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRQcmludERvY3VtZW50Qm9keShkb2N1bWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmNoaWxkcmVuLmxlbmd0aCAhPT0gMCB8fCBoYXNFbmRDb21tZW50cyQxKGRvY3VtZW50LmJvZHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkUHJpbnREb2N1bWVudEVuZE1hcmtlcihkb2N1bWVudCwgbmV4dERvY3VtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qKlxuICAgICAgICouLi4gIyB0cmFpbGluZ0NvbW1lbnRcbiAgICAgICAqL1xuICAgICAgaGFzVHJhaWxpbmdDb21tZW50JDMoZG9jdW1lbnQpIHx8IG5leHREb2N1bWVudCAmJiAoXG4gICAgICAvKipcbiAgICAgICAqIC4uLlxuICAgICAgICogJURJUkVDVElWRVxuICAgICAgICogLS0tXG4gICAgICAgKi9cbiAgICAgIG5leHREb2N1bWVudC5oZWFkLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCB8fFxuICAgICAgLyoqXG4gICAgICAgKiAuLi5cbiAgICAgICAqICMgZW5kQ29tbWVudFxuICAgICAgICogLS0tXG4gICAgICAgKi9cbiAgICAgIGhhc0VuZENvbW1lbnRzJDEobmV4dERvY3VtZW50LmhlYWQpKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRQcmludERvY3VtZW50SGVhZEVuZE1hcmtlcihkb2N1bWVudCwgbmV4dERvY3VtZW50LCByb290LCBvcHRpb25zKSB7XG4gICAgaWYgKFxuICAgIC8qKlxuICAgICAqIC0tLVxuICAgICAqIHByZXNlcnZlIHRoZSBmaXJzdCBkb2N1bWVudCBoZWFkIGVuZCBtYXJrZXJcbiAgICAgKi9cbiAgICByb290LmNoaWxkcmVuWzBdID09PSBkb2N1bWVudCAmJiAvLS0tKFxcc3wkKS8udGVzdChvcHRpb25zLm9yaWdpbmFsVGV4dC5zbGljZShvcHRpb25zLmxvY1N0YXJ0KGRvY3VtZW50KSwgb3B0aW9ucy5sb2NTdGFydChkb2N1bWVudCkgKyA0KSkgfHxcbiAgICAvKipcbiAgICAgKiAlRElSRUNUSVZFXG4gICAgICogLS0tXG4gICAgICovXG4gICAgZG9jdW1lbnQuaGVhZC5jaGlsZHJlbi5sZW5ndGggIT09IDAgfHxcbiAgICAvKipcbiAgICAgKiAjIGVuZCBjb21tZW50XG4gICAgICogLS0tXG4gICAgICovXG4gICAgaGFzRW5kQ29tbWVudHMkMShkb2N1bWVudC5oZWFkKSB8fFxuICAgIC8qKlxuICAgICAqIC0tLSAjIHRyYWlsaW5nIGNvbW1lbnRcbiAgICAgKi9cbiAgICBoYXNUcmFpbGluZ0NvbW1lbnQkMyhkb2N1bWVudC5oZWFkKSkge1xuICAgICAgcmV0dXJuIFwiaGVhZFwiO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRQcmludERvY3VtZW50RW5kTWFya2VyKGRvY3VtZW50LCBuZXh0RG9jdW1lbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHREb2N1bWVudCA/IFwicm9vdFwiIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0Fic29sdXRlbHlQcmludGVkQXNTaW5nbGVMaW5lTm9kZShub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcInBsYWluXCI6XG4gICAgICBjYXNlIFwicXVvdGVTaW5nbGVcIjpcbiAgICAgIGNhc2UgXCJxdW90ZURvdWJsZVwiOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImFsaWFzXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucHJvc2VXcmFwID09PSBcInByZXNlcnZlXCIpIHtcbiAgICAgIHJldHVybiBub2RlLnBvc2l0aW9uLnN0YXJ0LmxpbmUgPT09IG5vZGUucG9zaXRpb24uZW5kLmxpbmU7XG4gICAgfVxuXG4gICAgaWYgKCAvLyBiYWNrc2xhc2gtbmV3bGluZVxuICAgIC9cXFxcJC9tLnRlc3Qob3B0aW9ucy5vcmlnaW5hbFRleHQuc2xpY2Uobm9kZS5wb3NpdGlvbi5zdGFydC5vZmZzZXQsIG5vZGUucG9zaXRpb24uZW5kLm9mZnNldCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcHRpb25zLnByb3NlV3JhcCkge1xuICAgICAgY2FzZSBcIm5ldmVyXCI6XG4gICAgICAgIHJldHVybiAhbm9kZS52YWx1ZS5pbmNsdWRlcyhcIlxcblwiKTtcblxuICAgICAgY2FzZSBcImFsd2F5c1wiOlxuICAgICAgICByZXR1cm4gIS9bXFxuIF0vLnRlc3Qobm9kZS52YWx1ZSk7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbmVlZHNTcGFjZUluRnJvbnRPZk1hcHBpbmdWYWx1ZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUua2V5LmNvbnRlbnQgJiYgbm9kZS5rZXkuY29udGVudC50eXBlID09PSBcImFsaWFzXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludE5leHRFbXB0eUxpbmUocGF0aCwgb3JpZ2luYWxUZXh0KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCByb290ID0gcGF0aC5zdGFja1swXTtcbiAgICByb290LmlzTmV4dEVtcHR5TGluZVByaW50ZWRDaGVja2xpc3QgPSByb290LmlzTmV4dEVtcHR5TGluZVByaW50ZWRDaGVja2xpc3QgfHwgW107XG5cbiAgICBpZiAoIXJvb3QuaXNOZXh0RW1wdHlMaW5lUHJpbnRlZENoZWNrbGlzdFtub2RlLnBvc2l0aW9uLmVuZC5saW5lXSkge1xuICAgICAgaWYgKGlzTmV4dExpbmVFbXB0eSQ2KG5vZGUsIG9yaWdpbmFsVGV4dCkpIHtcbiAgICAgICAgcm9vdC5pc05leHRFbXB0eUxpbmVQcmludGVkQ2hlY2tsaXN0W25vZGUucG9zaXRpb24uZW5kLmxpbmVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHNvZnRsaW5lJDg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiBwcmludEZsb3dTY2FsYXJDb250ZW50KG5vZGVUeXBlLCBjb250ZW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGluZUNvbnRlbnRzID0gZ2V0Rmxvd1NjYWxhckxpbmVDb250ZW50cyQxKG5vZGVUeXBlLCBjb250ZW50LCBvcHRpb25zKTtcbiAgICByZXR1cm4gam9pbiRjKGhhcmRsaW5lJGQsIGxpbmVDb250ZW50cy5tYXAobGluZUNvbnRlbnRXb3JkcyA9PiBmaWxsJDYoam9pbiRjKGxpbmUkYiwgbGluZUNvbnRlbnRXb3JkcykucGFydHMpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbiQ3KG5vZGUsIG5ld05vZGVcbiAgLyosIHBhcmVudCAqL1xuICApIHtcbiAgICBpZiAoaXNOb2RlJDEobmV3Tm9kZSkpIHtcbiAgICAgIGRlbGV0ZSBuZXdOb2RlLnBvc2l0aW9uO1xuXG4gICAgICBzd2l0Y2ggKG5ld05vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgIC8vIGluc2VydCBwcmFnbWFcbiAgICAgICAgICBpZiAoaXNQcmFnbWEkMShuZXdOb2RlLnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInF1b3RlRG91YmxlXCI6XG4gICAgICAgIGNhc2UgXCJxdW90ZVNpbmdsZVwiOlxuICAgICAgICAgIG5ld05vZGUudHlwZSA9IFwicXVvdGVcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcHJpbnRlcllhbWwgPSB7XG4gICAgcHJlcHJvY2VzczogcHJlcHJvY2VzcyQzLFxuICAgIHByaW50OiBnZW5lcmljUHJpbnQkNixcbiAgICBtYXNzYWdlQXN0Tm9kZTogY2xlYW4kNyxcbiAgICBpbnNlcnRQcmFnbWE6IGluc2VydFByYWdtYSQ5XG4gIH07XG5cbiAgdmFyIG9wdGlvbnMkNyA9IHtcbiAgICBicmFja2V0U3BhY2luZzogY29tbW9uT3B0aW9ucy5icmFja2V0U3BhY2luZyxcbiAgICBzaW5nbGVRdW90ZTogY29tbW9uT3B0aW9ucy5zaW5nbGVRdW90ZSxcbiAgICBwcm9zZVdyYXA6IGNvbW1vbk9wdGlvbnMucHJvc2VXcmFwXG4gIH07XG5cbiAgdmFyIG5hbWUkaCA9IFwiWUFNTFwiO1xuICB2YXIgdHlwZSRnID0gXCJkYXRhXCI7XG4gIHZhciB0bVNjb3BlJGcgPSBcInNvdXJjZS55YW1sXCI7XG4gIHZhciBhbGlhc2VzJDYgPSBbXG4gIFx0XCJ5bWxcIlxuICBdO1xuICB2YXIgZXh0ZW5zaW9ucyRnID0gW1xuICBcdFwiLnltbFwiLFxuICBcdFwiLm1pclwiLFxuICBcdFwiLnJlZWtcIixcbiAgXHRcIi5ydml6XCIsXG4gIFx0XCIuc3VibGltZS1zeW50YXhcIixcbiAgXHRcIi5zeW50YXhcIixcbiAgXHRcIi55YW1sXCIsXG4gIFx0XCIueWFtbC10bWxhbmd1YWdlXCIsXG4gIFx0XCIueWFtbC5zZWRcIixcbiAgXHRcIi55bWwubXlzcWxcIlxuICBdO1xuICB2YXIgZmlsZW5hbWVzJDQgPSBbXG4gIFx0XCIuY2xhbmctZm9ybWF0XCIsXG4gIFx0XCIuY2xhbmctdGlkeVwiLFxuICBcdFwiLmdlbXJjXCIsXG4gIFx0XCJnbGlkZS5sb2NrXCIsXG4gIFx0XCJ5YXJuLmxvY2tcIlxuICBdO1xuICB2YXIgYWNlTW9kZSRnID0gXCJ5YW1sXCI7XG4gIHZhciBjb2RlbWlycm9yTW9kZSRjID0gXCJ5YW1sXCI7XG4gIHZhciBjb2RlbWlycm9yTWltZVR5cGUkYyA9IFwidGV4dC94LXlhbWxcIjtcbiAgdmFyIGxhbmd1YWdlSWQkZyA9IDQwNztcbiAgdmFyIFlBTUwgPSB7XG4gIFx0bmFtZTogbmFtZSRoLFxuICBcdHR5cGU6IHR5cGUkZyxcbiAgXHR0bVNjb3BlOiB0bVNjb3BlJGcsXG4gIFx0YWxpYXNlczogYWxpYXNlcyQ2LFxuICBcdGV4dGVuc2lvbnM6IGV4dGVuc2lvbnMkZyxcbiAgXHRmaWxlbmFtZXM6IGZpbGVuYW1lcyQ0LFxuICBcdGFjZU1vZGU6IGFjZU1vZGUkZyxcbiAgXHRjb2RlbWlycm9yTW9kZTogY29kZW1pcnJvck1vZGUkYyxcbiAgXHRjb2RlbWlycm9yTWltZVR5cGU6IGNvZGVtaXJyb3JNaW1lVHlwZSRjLFxuICBcdGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQkZ1xuICB9O1xuXG4gIHZhciBZQU1MJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIG5hbWU6IG5hbWUkaCxcbiAgICB0eXBlOiB0eXBlJGcsXG4gICAgdG1TY29wZTogdG1TY29wZSRnLFxuICAgIGFsaWFzZXM6IGFsaWFzZXMkNixcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zJGcsXG4gICAgZmlsZW5hbWVzOiBmaWxlbmFtZXMkNCxcbiAgICBhY2VNb2RlOiBhY2VNb2RlJGcsXG4gICAgY29kZW1pcnJvck1vZGU6IGNvZGVtaXJyb3JNb2RlJGMsXG4gICAgY29kZW1pcnJvck1pbWVUeXBlOiBjb2RlbWlycm9yTWltZVR5cGUkYyxcbiAgICBsYW5ndWFnZUlkOiBsYW5ndWFnZUlkJGcsXG4gICAgJ2RlZmF1bHQnOiBZQU1MXG4gIH0pO1xuXG4gIHZhciByZXF1aXJlJCQwJDggPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKFlBTUwkMSk7XG5cbiAgY29uc3QgbGFuZ3VhZ2VzJDYgPSBbY3JlYXRlTGFuZ3VhZ2UocmVxdWlyZSQkMCQ4LCBkYXRhID0+ICh7XG4gICAgc2luY2U6IFwiMS4xNC4wXCIsXG4gICAgcGFyc2VyczogW1wieWFtbFwiXSxcbiAgICB2c2NvZGVMYW5ndWFnZUlkczogW1wieWFtbFwiXSxcbiAgICAvLyB5YXJuLmxvY2sgaXMgbm90IFlBTUw6IGh0dHBzOi8vZ2l0aHViLmNvbS95YXJucGtnL3lhcm4vaXNzdWVzLzU2MjlcbiAgICBmaWxlbmFtZXM6IGRhdGEuZmlsZW5hbWVzLmZpbHRlcihmaWxlbmFtZSA9PiBmaWxlbmFtZSAhPT0gXCJ5YXJuLmxvY2tcIilcbiAgfSkpXTtcbiAgdmFyIGxhbmd1YWdlWWFtbCA9IHtcbiAgICBsYW5ndWFnZXM6IGxhbmd1YWdlcyQ2LFxuICAgIHByaW50ZXJzOiB7XG4gICAgICB5YW1sOiBwcmludGVyWWFtbFxuICAgIH0sXG4gICAgb3B0aW9uczogb3B0aW9ucyQ3XG4gIH07XG5cbiAgY29uc3Qge1xuICAgIHZlcnNpb246IHZlcnNpb24kMlxuICB9ID0gcmVxdWlyZSQkMDtcbiAgY29uc3Qge1xuICAgIGdldFN1cHBvcnRJbmZvOiBnZXRTdXBwb3J0SW5mbyQyXG4gIH0gPSBzdXBwb3J0O1xuICBjb25zdCBpbnRlcm5hbFBsdWdpbnMgPSBbbGFuZ3VhZ2VDc3MsIGxhbmd1YWdlR3JhcGhxbCwgbGFuZ3VhZ2VIYW5kbGViYXJzLCBsYW5ndWFnZUh0bWwsIGxhbmd1YWdlSnMsIGxhbmd1YWdlTWFya2Rvd24sIGxhbmd1YWdlWWFtbF07XG5cbiAgZnVuY3Rpb24gd2l0aFBsdWdpbnMoZm4sIG9wdHNBcmdJZHggPSAxIC8vIFVzdWFsbHkgYG9wdHNgIGlzIHRoZSAybmQgYXJndW1lbnRcbiAgKSB7XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBvcHRzID0gYXJnc1tvcHRzQXJnSWR4XSB8fCB7fTtcbiAgICAgIGNvbnN0IHBsdWdpbnMgPSBvcHRzLnBsdWdpbnMgfHwgW107XG4gICAgICBhcmdzW29wdHNBcmdJZHhdID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cywge1xuICAgICAgICBwbHVnaW5zOiBbLi4uaW50ZXJuYWxQbHVnaW5zLCAuLi4oQXJyYXkuaXNBcnJheShwbHVnaW5zKSA/IHBsdWdpbnMgOiBPYmplY3QudmFsdWVzKHBsdWdpbnMpKV1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZuKC4uLmFyZ3MpO1xuICAgIH07XG4gIH1cblxuICBjb25zdCBmb3JtYXRXaXRoQ3Vyc29yID0gd2l0aFBsdWdpbnMoY29yZS5mb3JtYXRXaXRoQ3Vyc29yKTtcbiAgdmFyIHN0YW5kYWxvbmUgPSB7XG4gICAgZm9ybWF0V2l0aEN1cnNvcixcblxuICAgIGZvcm1hdCh0ZXh0LCBvcHRzKSB7XG4gICAgICByZXR1cm4gZm9ybWF0V2l0aEN1cnNvcih0ZXh0LCBvcHRzKS5mb3JtYXR0ZWQ7XG4gICAgfSxcblxuICAgIGNoZWNrKHRleHQsIG9wdHMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9ybWF0dGVkXG4gICAgICB9ID0gZm9ybWF0V2l0aEN1cnNvcih0ZXh0LCBvcHRzKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZWQgPT09IHRleHQ7XG4gICAgfSxcblxuICAgIGRvYzogZG9jdW1lbnQsXG4gICAgZ2V0U3VwcG9ydEluZm86IHdpdGhQbHVnaW5zKGdldFN1cHBvcnRJbmZvJDIsIDApLFxuICAgIHZlcnNpb246IHZlcnNpb24kMixcbiAgICB1dGlsOiB1dGlsU2hhcmVkLFxuICAgIF9fZGVidWc6IHtcbiAgICAgIHBhcnNlOiB3aXRoUGx1Z2lucyhjb3JlLnBhcnNlKSxcbiAgICAgIGZvcm1hdEFTVDogd2l0aFBsdWdpbnMoY29yZS5mb3JtYXRBU1QpLFxuICAgICAgZm9ybWF0RG9jOiB3aXRoUGx1Z2lucyhjb3JlLmZvcm1hdERvYyksXG4gICAgICBwcmludFRvRG9jOiB3aXRoUGx1Z2lucyhjb3JlLnByaW50VG9Eb2MpLFxuICAgICAgcHJpbnREb2NUb1N0cmluZzogd2l0aFBsdWdpbnMoY29yZS5wcmludERvY1RvU3RyaW5nKVxuICAgIH1cbiAgfTtcblxuICB2YXIgc3RhbmRhbG9uZSQxID0gc3RhbmRhbG9uZTtcblxuICByZXR1cm4gc3RhbmRhbG9uZSQxO1xuXG59KSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQXNNQTtBQWFBO0FBSUE7QUFPQTtBQVVBO0FBUUE7QUFHQTtBQUNBO0FBR0E7QUFNQTtBQU1BO0FBSUE7QUFNQTtBQUNBO0FBR0E7QUFLQTtBQXlCQTtBQUNBO0FBdUZBO0FBTUE7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUdBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFnQkE7QUFFQTtBQTJCQTtBQUtBO0FBb0ZBO0FBRUE7QUFvQkE7QUFHQTtBQTRGQTtBQUdBO0FBS0E7QUFRQTtBQUdBO0FBR0E7QUFXQTtBQU1BO0FBR0E7QUFpQkE7QUFHQTtBQWlCQTtBQUNBO0FBd0JBO0FBU0E7QUFtQkE7QUFDQTtBQUdBO0FBWUE7QUFHQTtBQVdBO0FBR0E7QUFPQTtBQUVBO0FBbUJBO0FBYUE7QUFDQTtBQVdBO0FBZ0JBO0FBaUJBO0FBR0E7QUFJQTtBQVVBO0FBZ0NBO0FBa0JBO0FBZ0RBO0FBc0JBO0FBYUE7QUFLQTtBQU9BO0FBRUE7QUFJQTtBQUtBO0FBY0E7QUFNQTtBQXNHQTtBQUNBO0FBRUE7QUFPQTtBQU1BO0FBTUE7QUF1QkE7QUFLQTtBQUtBO0FBaUVBO0FBQ0E7QUFXQTtBQUdBO0FBTUE7QUFLQTtBQUtBO0FBR0E7QUFHQTtBQUdBO0FBS0E7QUFLQTtBQVdBO0FBb0VBO0FBMEJBO0FBT0E7QUFFQTtBQThGQTtBQTBJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFFQTtBQStDQTtBQUdBO0FBRUE7QUFLQTtBQWdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUE7QUFJQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQVdBO0FBRUE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE2QkE7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFPQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQW9CQTtBQWtCQTtBQUlBO0FBc0NBO0FBQ0E7QUEwR0E7QUE2QkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUdBO0FBYUE7QUF5Q0E7QUFHQTtBQTJJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUVBO0FBV0E7QUFFQTtBQUlBO0FBU0E7QUFLQTtBQUVBO0FBUUE7QUF1R0E7QUFzQ0E7QUFJQTtBQUlBO0FBV0E7QUFnQ0E7QUFpR0E7QUFDQTtBQUlBO0FBV0E7QUFDQTtBQUdBO0FBT0E7QUFHQTtBQTZGQTtBQUNBO0FBa2NBO0FBT0E7QUFHQTtBQU9BO0FBV0E7QUFLQTtBQVNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUE4QkE7QUE0QkE7QUFHQTtBQUlBO0FBRUE7QUFFQTtBQTJCQTtBQUVBO0FBRUE7QUFFQTtBQUlBO0FBS0E7QUFLQTtBQU9BO0FBR0E7QUFLQTtBQXlCQTtBQXFDQTtBQUNBO0FBQ0E7QUFHQTtBQVNBO0FBcUJBO0FBQ0E7QUFVQTtBQThJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeURBO0FBc0JBO0FBSUE7QUFPQTtBQUlBO0FBR0E7QUFRQTtBQUlBO0FBT0E7QUFJQTtBQUdBO0FBQ0E7QUF3RUE7QUFnQkE7QUEwQkE7QUFLQTtBQUdBO0FBcURBO0FBQ0E7QUFNQTtBQWNBO0FBWUE7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQU1BO0FBRUE7QUFFQTtBQUVBO0FBS0E7QUFFQTtBQU1BO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFvRUE7QUFFQTtBQVNBO0FBaUJBO0FBa0VBO0FBc0RBO0FBR0E7QUFtQkE7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBRUE7QUFlQTtBQU1BO0FBQ0E7QUErQ0E7QUFNQTtBQUlBO0FBQ0E7QUFRQTtBQVVBO0FBY0E7QUFFQTtBQTRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFpbEJBO0FBQ0E7QUFDQTtBQXVFQTtBQXNJQTtBQUNBO0FBcUJBO0FBRUE7QUFtQkE7QUFrSkE7QUFVQTtBQWVBO0FBd0VBO0FBdUZBO0FBaUJBO0FBQ0E7QUFPQTtBQUVBO0FBbUJBO0FBa0JBO0FBMFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBS0E7QUFDQTtBQVNBO0FBSUE7QUFxREE7QUEwQkE7QUFrQkE7QUFDQTtBQUVBO0FBVUE7QUFnREE7QUFtQkE7QUFrQkE7QUFXQTtBQWlGQTtBQWlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE0QkE7QUE0SEE7QUFzQ0E7QUFFQTtBQU1BO0FBT0E7QUFDQTtBQW1CQTtBQXlHQTtBQUNBO0FBRUE7QUFFQTtBQUtBO0FBVUE7QUFRQTtBQUNBO0FBR0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQU9BO0FBQ0E7QUFpQkE7QUFFQTtBQWtFQTtBQUVBO0FBZUE7QUFDQTtBQUNBO0FBR0E7QUFRQTtBQUNBO0FBR0E7QUF3SEE7QUFRQTtBQUtBO0FBbVBBO0FBS0E7QUFjQTtBQTRUQTtBQWlPQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBR0E7QUFrQ0E7QUFTQTtBQThKQTtBQUNBO0FBRUE7QUFzRUE7QUFvSUE7QUFDQTtBQWlCQTtBQUVBO0FBa0JBO0FBMElBO0FBT0E7QUFlQTtBQXdFQTtBQTZFQTtBQWlCQTtBQUNBO0FBT0E7QUFFQTtBQW1CQTtBQWtCQTtBQXlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUtBO0FBQ0E7QUFTQTtBQUlBO0FBcURBO0FBNEJBO0FBb0JBO0FBQ0E7QUFFQTtBQVVBO0FBOEZBO0FBa0JBO0FBbUJBO0FBV0E7QUFxQ0E7QUErRUE7QUFDQTtBQWdDQTtBQXdLQTtBQTBDQTtBQVNBO0FBT0E7QUF5SEE7QUFDQTtBQUVBO0FBR0E7QUEwQkE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUdBO0FBZ0JBO0FBQ0E7QUFvQkE7QUFLQTtBQXdMQTtBQWlDQTtBQThFQTtBQUNBO0FBR0E7QUFFQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUVBO0FBSUE7QUFFQTtBQUtBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQU9BO0FBS0E7QUFjQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXdCQTtBQTJKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWtMQTtBQUNBO0FBQ0E7QUF1RUE7QUFzSUE7QUFDQTtBQXFCQTtBQUVBO0FBbUJBO0FBa0pBO0FBVUE7QUFlQTtBQXdFQTtBQXVGQTtBQWlCQTtBQUNBO0FBT0E7QUFFQTtBQW1CQTtBQWtCQTtBQTBRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUtBO0FBQ0E7QUFTQTtBQUlBO0FBcURBO0FBMEJBO0FBa0JBO0FBQ0E7QUFFQTtBQVVBO0FBZ0RBO0FBbUJBO0FBa0JBO0FBV0E7QUFpRkE7QUFxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNEJBO0FBNEhBO0FBc0NBO0FBRUE7QUFNQTtBQU9BO0FBQ0E7QUFtQkE7QUF5R0E7QUFDQTtBQUVBO0FBRUE7QUFLQTtBQVVBO0FBUUE7QUFDQTtBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFPQTtBQUNBO0FBaUJBO0FBRUE7QUF5WUE7QUFFQTtBQXdCQTtBQXVCQTtBQUVBO0FBNkRBO0FBaUZBO0FBT0E7QUFPQTtBQVNBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFTQTtBQUNBO0FBRUE7QUF5REE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQXlDQTtBQUNBO0FBQ0E7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBS0E7QUFDQTtBQUVBO0FBNkNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFhQTtBQWdCQTtBQUtBO0FBS0E7QUFZQTtBQXVCQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBTUE7QUFFQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFZQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQTJDQTtBQUdBO0FBS0E7QUFLQTtBQUdBO0FBR0E7QUFLQTtBQVVBO0FBQ0E7QUFHQTtBQW1CQTtBQVNBO0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFnQkE7QUFDQTtBQUVBO0FBV0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQU9BO0FBR0E7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUF5Q0E7QUFDQTtBQUNBO0FBU0E7QUF3QkE7QUFDQTtBQUVBO0FBdVFBO0FBZ0JBO0FBRUE7QUFpRkE7QUE2QkE7QUFDQTtBQUVBO0FBK0NBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBb0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBaUZBO0FBQ0E7QUFDQTtBQUNBO0FBOEdBO0FBRUE7QUE2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQWtQQTtBQUNBO0FBQ0E7QUFpQ0E7QUFDQTtBQUdBO0FBU0E7QUFTQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBR0E7QUE4REE7QUFDQTtBQUVBO0FBUUE7QUFNQTtBQUNBO0FBUUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0JBO0FBUUE7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFZQTtBQUNBO0FBNEJBO0FBRUE7QUFTQTtBQU9BO0FBZUE7QUFFQTtBQW1CQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUE0R0E7QUFHQTtBQVdBO0FBRUE7QUFLQTtBQUdBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQTBCQTtBQUNBO0FBQ0E7QUFHQTtBQWlCQTtBQUVBO0FBT0E7QUFDQTtBQUdBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTtBQWlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0JBO0FBR0E7QUFNQTtBQUNBO0FBY0E7QUFDQTtBQWNBO0FBT0E7QUFXQTtBQW1FQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFxQ0E7QUFDQTtBQXFFQTtBQUNBO0FBc0RBO0FBcUNBO0FBR0E7QUF1Q0E7QUFDQTtBQUVBO0FBT0E7QUFFQTtBQUVBO0FBU0E7QUFHQTtBQUlBO0FBMERBO0FBMkZBO0FBMkJBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUE0RUE7QUFLQTtBQXFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBK0JBO0FBY0E7QUErREE7QUFNQTtBQWtCQTtBQWlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5REE7QUFZQTtBQVdBO0FBZ0pBO0FBQ0E7QUFDQTtBQXNHQTtBQU1BO0FBTUE7QUFLQTtBQUtBO0FBNENBO0FBc05BO0FBQ0E7QUFDQTtBQUlBO0FBaUVBO0FBMkVBO0FBS0E7QUFZQTtBQVNBO0FBQ0E7QUFpQ0E7QUFLQTtBQUtBO0FBYUE7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFFQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBSUE7QUFLQTtBQU1BO0FBTUE7QUFNQTtBQVVBO0FBQ0E7QUFHQTtBQU1BO0FBVUE7QUFDQTtBQUNBO0FBR0E7QUFxQ0E7QUEyQ0E7QUF1RkE7QUFjQTtBQXVtQkE7QUFxR0E7QUFDQTtBQUVBO0FBb0ZBO0FBQ0E7QUFFQTtBQTBEQTtBQUVBO0FBdUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQUNBO0FBRUE7QUFxRkE7QUFDQTtBQU9BO0FBMEVBO0FBdUJBO0FBcWlDQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBR0E7QUFDQTtBQUtBO0FBdVNBO0FBaU1BO0FBQ0E7QUFlQTtBQXFGQTtBQW9GQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3QkE7QUFBQTtBQXNEQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQXFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUJBO0FBMENBO0FBQ0E7QUFFQTtBQUVBO0FBdU9BO0FBS0E7QUFTQTtBQTRCQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFlQTtBQWlJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXNDQTtBQW1CQTtBQXVCQTtBQTRCQTtBQU9BO0FBNERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBNEJBO0FBSUE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQXFDQTtBQTJCQTtBQXlIQTtBQXdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFNQTtBQUNBO0FBR0E7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFnQkE7QUF5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQXdDQTtBQUdBO0FBQ0E7QUFlQTtBQU1BO0FBOEZBO0FBb0hBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQWdEQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrQkE7QUFFQTtBQVdBO0FBa0RBO0FBQ0E7QUFDQTtBQW9FQTtBQUNBO0FBQ0E7QUFHQTtBQW9CQTtBQWFBO0FBRUE7QUFrQkE7QUFDQTtBQU1BO0FBQ0E7QUFRQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFDQTtBQWdCQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQU9BO0FBQ0E7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQVFBO0FBbUZBO0FBS0E7QUFPQTtBQUdBO0FBVUE7QUFLQTtBQVNBO0FBUUE7QUFHQTtBQU9BO0FBS0E7QUE4QkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBQ0E7QUErR0E7QUFHQTtBQXdCQTtBQXVCQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBK0JBO0FBZ0JBO0FBd0RBO0FBS0E7QUFLQTtBQThCQTtBQUNBO0FBR0E7QUF1QkE7QUFFQTtBQVVBO0FBb0JBO0FBRUE7QUFJQTtBQW9DQTtBQUdBO0FBR0E7QUFFQTtBQWFBO0FBeUJBO0FBR0E7QUFrQ0E7QUFDQTtBQUdBO0FBdUJBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW1CQTtBQUNBO0FBR0E7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUF5SUE7QUFDQTtBQUVBO0FBS0E7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBR0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQXlDQTtBQW9CQTtBQThEQTtBQTJDQTtBQTJCQTtBQUdBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUlBO0FBQ0E7QUFVQTtBQXFDQTtBQVFBO0FBUUE7QUFrQkE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUVBO0FBMkVBO0FBQ0E7QUFNQTtBQWlEQTtBQW1CQTtBQUVBO0FBNEdBO0FBQ0E7QUFDQTtBQThDQTtBQTZLQTtBQU9BO0FBbUJBO0FBQ0E7QUFDQTtBQXFCQTtBQUNBO0FBSUE7QUFDQTtBQU9BO0FBQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFnQkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrQ0E7QUFDQTtBQVNBO0FBaUJBO0FBU0E7QUFLQTtBQWFBO0FBR0E7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFHQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFrSEE7QUFFQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQThIQTtBQTRCQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFLQTtBQUdBO0FBS0E7QUFFQTtBQXVEQTtBQUNBO0FBRUE7QUF3REE7QUFDQTtBQUdBO0FBVUE7QUFFQTtBQWNBO0FBeUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBaUNBO0FBQ0E7QUFDQTtBQXNCQTtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBRUE7QUFhQTtBQUdBO0FBU0E7QUEyQ0E7QUFFQTtBQVNBO0FBcURBO0FBQ0E7QUFFQTtBQWlCQTtBQXNFQTtBQTJCQTtBQVlBO0FBa0VBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBK0ZBO0FBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBYUE7QUFFQTtBQWlCQTtBQUlBO0FBRUE7QUE4Q0E7QUFDQTtBQWlHQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFnQkE7QUFFQTtBQWdFQTtBQUdBO0FBR0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFnSEE7QUFFQTtBQWlEQTtBQUNBO0FBR0E7QUFrQkE7QUFDQTtBQUVBO0FBa0dBO0FBb0NBO0FBQ0E7QUFDQTtBQUVBO0FBa0pBO0FBRUE7QUF3QkE7QUFpRUE7QUFjQTtBQWNBO0FBRUE7QUFLQTtBQUdBO0FBT0E7QUFFQTtBQThDQTtBQVdBO0FBTUE7QUE2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBK0RBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBb0NBO0FBa0JBO0FBZ0NBO0FBQ0E7QUFvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQU9BO0FBNkJBO0FBdUNBO0FBTUE7QUFDQTtBQWlGQTtBQUNBO0FBQ0E7QUF3QkE7QUFTQTtBQTZDQTtBQUVBO0FBbUNBO0FBQ0E7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU1BO0FBRUE7QUFvQ0E7QUFDQTtBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXdCQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUEwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFzQkE7QUFFQTtBQW9CQTtBQUVBO0FBT0E7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQU1BO0FBR0E7QUFnQkE7QUFNQTtBQXlCQTtBQUNBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQWFBO0FBQ0E7QUFHQTtBQWVBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFnQkE7QUFLQTtBQUlBO0FBR0E7QUFHQTtBQUNBO0FBSUE7QUFLQTtBQUlBO0FBSUE7QUFXQTtBQUNBO0FBRUE7QUFtRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFZQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBS0E7QUFZQTtBQTBFQTtBQWdHQTtBQUNBO0FBRUE7QUFpQkE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQXdHQTtBQXVmQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBU0E7QUFVQTtBQWVBO0FBMkJBO0FBNENBO0FBR0E7QUFPQTtBQUNBO0FBRUE7QUFzREE7QUFxQkE7QUEyREE7QUFFQTtBQTBDQTtBQWtGQTtBQU9BO0FBbUJBO0FBc0JBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0VBO0FBSUE7QUFNQTtBQWFBO0FBeUJBO0FBd0JBO0FBS0E7QUFzR0E7QUFLQTtBQU1BO0FBQ0E7QUFLQTtBQUVBO0FBY0E7QUFTQTtBQWdFQTtBQVFBO0FBQUE7QUFTQTtBQXlRQTtBQUdBO0FBNEJBO0FBRUE7QUFTQTtBQVNBO0FBb0pBO0FBQ0E7QUFDQTtBQWtIQTtBQUNBO0FBeUNBO0FBUUE7QUFVQTtBQWtCQTtBQWtJQTtBQUNBO0FBK0JBO0FBQ0E7QUFHQTtBQU1BO0FBMERBO0FBdUJBO0FBMERBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQW1DQTtBQVlBO0FBc0NBO0FBMkZBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/prettier/standalone.js\n");

/***/ })

}]);