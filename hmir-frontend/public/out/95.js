(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[95],{

/***/ "./node_modules/php-parser/dist/php-parser.js":
/*!****************************************************!*\
  !*** ./node_modules/php-parser/dist/php-parser.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * \n *   Package: php-parser\n *   Parse PHP code from JS and returns its AST\n *   Build: 6da88e7e7acbe4a154b4 - 3/27/2020\n *   Copyright (C) 2020 Glayzzle (BSD-3-Clause)\n *   @authors https://github.com/glayzzle/php-parser/graphs/contributors\n *   @url http://glayzzle.com        \n *       \n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 12);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"statement\";\n/**\n * Any statement.\n * @constructor Statement\n * @extends {Node}\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Statement(kind, docs, location) {\n  Node.apply(this, [kind || KIND, docs, location]);\n});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"expression\";\n/**\n * Any expression node. Since the left-hand side of an assignment may\n * be any expression in general, an expression can also be a pattern.\n * @constructor Expression\n * @extends {Node}\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Expression(kind, docs, location) {\n  Node.apply(this, [kind || KIND, docs, location]);\n});\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * A generic AST node\n * @constructor Node\n * @property {Location|null} loc\n * @property {Comment[]} leadingComments\n * @property {Comment[]?} trailingComments\n * @property {String} kind\n */\n\nvar Node = function Node(kind, docs, location) {\n  this.kind = kind;\n\n  if (docs) {\n    this.leadingComments = docs;\n  }\n\n  if (location) {\n    this.loc = location;\n  }\n};\n/**\n * Attach comments to current node\n * @param {*} docs\n */\n\n\nNode.prototype.setTrailingComments = function (docs) {\n  this.trailingComments = docs;\n};\n/**\n * Destroying an unused node\n */\n\n\nNode.prototype.destroy = function (node) {\n  if (!node) {\n    throw new Error(\"Node already initialized, you must swap with another node\");\n  }\n\n  if (this.leadingComments) {\n    if (node.leadingComments) {\n      node.leadingComments = Array.concat(this.leadingComments, node.leadingComments);\n    } else {\n      node.leadingComments = this.leadingComments;\n    }\n  }\n\n  if (this.trailingComments) {\n    if (node.trailingComments) {\n      node.trailingComments = Array.concat(this.trailingComments, node.trailingComments);\n    } else {\n      node.trailingComments = this.trailingComments;\n    }\n  }\n\n  return node;\n};\n/**\n * Includes current token position of the parser\n * @param {*} parser\n */\n\n\nNode.prototype.includeToken = function (parser) {\n  if (this.loc) {\n    if (this.loc.end) {\n      this.loc.end.line = parser.lexer.yylloc.last_line;\n      this.loc.end.column = parser.lexer.yylloc.last_column;\n      this.loc.end.offset = parser.lexer.offset;\n    }\n\n    if (parser.ast.withSource) {\n      this.loc.source = parser.lexer._input.substring(this.loc.start.offset, parser.lexer.offset);\n    }\n  }\n\n  return this;\n};\n/**\n * Helper for extending the Node class\n * @param {String} type\n * @param {Function} constructor\n * @return {Function}\n */\n\n\nNode[\"extends\"] = function (type, constructor) {\n  constructor.prototype = Object.create(this.prototype);\n  constructor[\"extends\"] = this[\"extends\"];\n  constructor.prototype.constructor = constructor;\n  constructor.kind = type;\n  return constructor;\n};\n\nmodule.exports = Node;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"literal\";\n/**\n * Defines an array structure\n * @constructor Literal\n * @extends {Expression}\n * @property {string} raw\n * @property {Node|string|number|boolean|null} value\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Literal(kind, value, raw, docs, location) {\n  Expression.apply(this, [kind || KIND, docs, location]);\n  this.value = value;\n\n  if (raw) {\n    this.raw = raw;\n  }\n});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expr = __webpack_require__(1);\n\nvar KIND = \"operation\";\n/**\n * Defines binary operations\n * @constructor Operation\n * @extends {Expression}\n */\n\nmodule.exports = Expr[\"extends\"](KIND, function Operation(kind, docs, location) {\n  Expr.apply(this, [kind || KIND, docs, location]);\n});\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"declaration\";\nvar IS_UNDEFINED = \"\";\nvar IS_PUBLIC = \"public\";\nvar IS_PROTECTED = \"protected\";\nvar IS_PRIVATE = \"private\";\n/**\n * A declaration statement (function, class, interface...)\n * @constructor Declaration\n * @extends {Statement}\n * @property {Identifier|string} name\n */\n\nvar Declaration = Statement[\"extends\"](KIND, function Declaration(kind, name, docs, location) {\n  Statement.apply(this, [kind || KIND, docs, location]);\n  this.name = name;\n});\n/**\n * Generic flags parser\n * @param {Integer[]} flags\n * @return {void}\n */\n\nDeclaration.prototype.parseFlags = function (flags) {\n  this.isAbstract = flags[2] === 1;\n  this.isFinal = flags[2] === 2;\n\n  if (this.kind !== \"class\") {\n    if (flags[0] === -1) {\n      this.visibility = IS_UNDEFINED;\n    } else if (flags[0] === null) {\n      this.visibility = null;\n    } else if (flags[0] === 0) {\n      this.visibility = IS_PUBLIC;\n    } else if (flags[0] === 1) {\n      this.visibility = IS_PROTECTED;\n    } else if (flags[0] === 2) {\n      this.visibility = IS_PRIVATE;\n    }\n\n    this.isStatic = flags[1] === 1;\n  }\n};\n\nmodule.exports = Declaration;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"reference\";\n/**\n * Defines a reference node\n * @constructor Reference\n * @extends {Node}\n */\n\nvar Reference = Node[\"extends\"](KIND, function Reference(kind, docs, location) {\n  Node.apply(this, [kind || KIND, docs, location]);\n});\nmodule.exports = Reference;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"block\";\n/**\n * A block statement, i.e., a sequence of statements surrounded by braces.\n * @constructor Block\n * @extends {Statement}\n * @property {Node[]} children\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Block(kind, children, docs, location) {\n  Statement.apply(this, [kind || KIND, docs, location]);\n  this.children = children.filter(Boolean);\n});\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expr = __webpack_require__(1);\n\nvar KIND = \"lookup\";\n/**\n * Lookup on an offset in the specified object\n * @constructor Lookup\n * @extends {Expression}\n * @property {Expression} what\n * @property {Expression} offset\n */\n\nmodule.exports = Expr[\"extends\"](KIND, function Lookup(kind, what, offset, docs, location) {\n  Expr.apply(this, [kind || KIND, docs, location]);\n  this.what = what;\n  this.offset = offset;\n});\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n/**\n * Abstract documentation node (ComentLine or CommentBlock)\n * @constructor Comment\n * @extends {Node}\n * @property {String} value\n */\n\n\nmodule.exports = Node[\"extends\"](\"comment\", function Comment(kind, value, docs, location) {\n  Node.apply(this, [kind, docs, location]);\n  this.value = value;\n});\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"constantstatement\";\n/**\n * Declares a constants into the current scope\n * @constructor ConstantStatement\n * @extends {Statement}\n * @property {Constant[]} constants\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function ConstantStatement(kind, constants, docs, location) {\n  Statement.apply(this, [kind || KIND, docs, location]);\n  this.constants = constants;\n});\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"function\";\n/**\n * Defines a classic function\n * @constructor Function\n * @extends {Declaration}\n * @property {Parameter[]} arguments\n * @property {Identifier} type\n * @property {boolean} byref\n * @property {boolean} nullable\n * @property {Block|null} body\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function _Function(name, args, byref, type, nullable, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.arguments = args;\n  this.byref = byref;\n  this.type = type;\n  this.nullable = nullable;\n  this.body = null;\n});\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2020 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar lexer = __webpack_require__(13);\n\nvar parser = __webpack_require__(23);\n\nvar tokens = __webpack_require__(39);\n\nvar AST = __webpack_require__(40);\n/**\n * @private\n */\n\n\nfunction combine(src, to) {\n  var keys = Object.keys(src);\n  var i = keys.length;\n\n  while (i--) {\n    var k = keys[i];\n    var val = src[k];\n\n    if (val === null) {\n      delete to[k];\n    } else if (typeof val === \"function\") {\n      to[k] = val.bind(to);\n    } else if (Array.isArray(val)) {\n      to[k] = Array.isArray(to[k]) ? to[k].concat(val) : val;\n    } else if (_typeof(val) === \"object\") {\n      to[k] = _typeof(to[k]) === \"object\" ? combine(val, to[k]) : val;\n    } else {\n      to[k] = val;\n    }\n  }\n\n  return to;\n}\n/**\n * Initialise a new parser instance with the specified options\n *\n * @class\n * @tutorial Engine\n * @example\n * var parser = require('php-parser');\n * var instance = new parser({\n *   parser: {\n *     extractDoc: true,\n *     suppressErrors: true,\n *     version: 704 // or '7.4'\n *   },\n *   ast: {\n *     withPositions: true\n *   },\n *   lexer: {\n *     short_tags: true,\n *     asp_tags: true\n *   }\n * });\n *\n * var evalAST = instance.parseEval('some php code');\n * var codeAST = instance.parseCode('<?php some php code', 'foo.php');\n * var tokens = instance.tokenGetAll('<?php some php code');\n *\n * @param {Object} options - List of options\n * @property {Lexer} lexer\n * @property {Parser} parser\n * @property {AST} ast\n * @property {Object} tokens\n */\n\n\nvar engine = function engine(options) {\n  if (typeof this === \"function\") {\n    return new this(options);\n  }\n\n  this.tokens = tokens;\n  this.lexer = new lexer(this);\n  this.ast = new AST();\n  this.parser = new parser(this.lexer, this.ast);\n\n  if (options && _typeof(options) === \"object\") {\n    // disable php7 from lexer if already disabled from parser\n    if (options.parser) {\n      if (!options.lexer) {\n        options.lexer = {};\n      }\n\n      if (options.parser.version) {\n        if (typeof options.parser.version === \"string\") {\n          var version = options.parser.version.split(\".\");\n          version = parseInt(version[0]) * 100 + parseInt(version[1]);\n\n          if (isNaN(version)) {\n            throw new Error(\"Bad version number : \" + options.parser.version);\n          } else {\n            options.parser.version = version;\n          }\n        } else if (typeof options.parser.version !== \"number\") {\n          throw new Error(\"Expecting a number for version\");\n        }\n\n        if (options.parser.version < 500 || options.parser.version > 704) {\n          throw new Error(\"Can only handle versions between 5.x to 7.x\");\n        }\n      }\n    }\n\n    combine(options, this); // same version flags based on parser options\n\n    this.lexer.version = this.parser.version;\n  }\n};\n/**\n * Check if the inpyt is a buffer or a string\n * @param  {Buffer|String} buffer Input value that can be either a buffer or a string\n * @return {String}   Returns the string from input\n */\n\n\nvar getStringBuffer = function getStringBuffer(buffer) {\n  return typeof buffer.write === \"function\" ? buffer.toString() : buffer;\n};\n/**\n * Creates a new instance (Helper)\n * @param {Object} options\n * @return {Engine}\n * @private\n */\n\n\nengine.create = function (options) {\n  return new engine(options);\n};\n/**\n * Evaluate the buffer\n * @private\n */\n\n\nengine.parseEval = function (buffer, options) {\n  var self = new engine(options);\n  return self.parseEval(buffer);\n};\n/**\n * Parse an evaluating mode string (no need to open php tags)\n * @param {String} buffer\n * @return {Program}\n */\n\n\nengine.prototype.parseEval = function (buffer) {\n  this.lexer.mode_eval = true;\n  this.lexer.all_tokens = false;\n  buffer = getStringBuffer(buffer);\n  return this.parser.parse(buffer, \"eval\");\n};\n/**\n * Static function that parse a php code with open/close tags\n * @private\n */\n\n\nengine.parseCode = function (buffer, filename, options) {\n  if (_typeof(filename) === \"object\" && !options) {\n    // retro-compatibility\n    options = filename;\n    filename = \"unknown\";\n  }\n\n  var self = new engine(options);\n  return self.parseCode(buffer, filename);\n};\n/**\n * Function that parse a php code with open/close tags\n *\n * Sample code :\n * ```php\n * <?php $x = 1;\n * ```\n *\n * Usage :\n * ```js\n * var parser = require('php-parser');\n * var phpParser = new parser({\n *   // some options\n * });\n * var ast = phpParser.parseCode('...php code...', 'foo.php');\n * ```\n * @param {String} buffer - The code to be parsed\n * @param {String} filename - Filename\n * @return {Program}\n */\n\n\nengine.prototype.parseCode = function (buffer, filename) {\n  this.lexer.mode_eval = false;\n  this.lexer.all_tokens = false;\n  buffer = getStringBuffer(buffer);\n  return this.parser.parse(buffer, filename);\n};\n/**\n * Split the buffer into tokens\n * @private\n */\n\n\nengine.tokenGetAll = function (buffer, options) {\n  var self = new engine(options);\n  return self.tokenGetAll(buffer);\n};\n/**\n * Extract tokens from the specified buffer.\n * > Note that the output tokens are *STRICLY* similar to PHP function `token_get_all`\n * @param {String} buffer\n * @return {String[]} - Each item can be a string or an array with following informations [token_name, text, line_number]\n */\n\n\nengine.prototype.tokenGetAll = function (buffer) {\n  this.lexer.mode_eval = false;\n  this.lexer.all_tokens = true;\n  buffer = getStringBuffer(buffer);\n  var EOF = this.lexer.EOF;\n  var names = this.tokens.values;\n  this.lexer.setInput(buffer);\n  var token = this.lexer.lex() || EOF;\n  var result = [];\n\n  while (token != EOF) {\n    var entry = this.lexer.yytext;\n\n    if (names.hasOwnProperty(token)) {\n      entry = [names[token], entry, this.lexer.yylloc.first_line];\n    }\n\n    result.push(entry);\n    token = this.lexer.lex() || EOF;\n  }\n\n  return result;\n}; // exports the function\n\n\nmodule.exports = engine; // makes libraries public\n\nmodule.exports.tokens = tokens;\nmodule.exports.lexer = lexer;\nmodule.exports.AST = AST;\nmodule.exports.parser = parser;\nmodule.exports.combine = combine; // allow the default export in index.d.ts\n\nmodule.exports[\"default\"] = engine;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * This is the php lexer. It will tokenize the string for helping the\n * parser to build the AST from its grammar.\n *\n * @class\n * @property {Integer} EOF\n * @property {Boolean} all_tokens defines if all tokens must be retrieved (used by token_get_all only)\n * @property {Boolean} comment_tokens extracts comments tokens\n * @property {Boolean} mode_eval enables the evald mode (ignore opening tags)\n * @property {Boolean} asp_tags disables by default asp tags mode\n * @property {Boolean} short_tags enables by default short tags mode\n * @property {Object} keywords List of php keyword\n * @property {Object} castKeywords List of php keywords for type casting\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar lexer = function lexer(engine) {\n  this.engine = engine;\n  this.tok = this.engine.tokens.names;\n  this.EOF = 1;\n  this.debug = false;\n  this.all_tokens = true;\n  this.comment_tokens = false;\n  this.mode_eval = false;\n  this.asp_tags = false;\n  this.short_tags = false;\n  this.version = 704;\n  this.yyprevcol = 0;\n  this.keywords = {\n    __class__: this.tok.T_CLASS_C,\n    __trait__: this.tok.T_TRAIT_C,\n    __function__: this.tok.T_FUNC_C,\n    __method__: this.tok.T_METHOD_C,\n    __line__: this.tok.T_LINE,\n    __file__: this.tok.T_FILE,\n    __dir__: this.tok.T_DIR,\n    __namespace__: this.tok.T_NS_C,\n    exit: this.tok.T_EXIT,\n    die: this.tok.T_EXIT,\n    \"function\": this.tok.T_FUNCTION,\n    \"const\": this.tok.T_CONST,\n    \"return\": this.tok.T_RETURN,\n    \"try\": this.tok.T_TRY,\n    \"catch\": this.tok.T_CATCH,\n    \"finally\": this.tok.T_FINALLY,\n    \"throw\": this.tok.T_THROW,\n    \"if\": this.tok.T_IF,\n    elseif: this.tok.T_ELSEIF,\n    endif: this.tok.T_ENDIF,\n    \"else\": this.tok.T_ELSE,\n    \"while\": this.tok.T_WHILE,\n    endwhile: this.tok.T_ENDWHILE,\n    \"do\": this.tok.T_DO,\n    \"for\": this.tok.T_FOR,\n    endfor: this.tok.T_ENDFOR,\n    foreach: this.tok.T_FOREACH,\n    endforeach: this.tok.T_ENDFOREACH,\n    declare: this.tok.T_DECLARE,\n    enddeclare: this.tok.T_ENDDECLARE,\n    \"instanceof\": this.tok.T_INSTANCEOF,\n    as: this.tok.T_AS,\n    \"switch\": this.tok.T_SWITCH,\n    endswitch: this.tok.T_ENDSWITCH,\n    \"case\": this.tok.T_CASE,\n    \"default\": this.tok.T_DEFAULT,\n    \"break\": this.tok.T_BREAK,\n    \"continue\": this.tok.T_CONTINUE,\n    \"goto\": this.tok.T_GOTO,\n    echo: this.tok.T_ECHO,\n    print: this.tok.T_PRINT,\n    \"class\": this.tok.T_CLASS,\n    \"interface\": this.tok.T_INTERFACE,\n    trait: this.tok.T_TRAIT,\n    \"extends\": this.tok.T_EXTENDS,\n    \"implements\": this.tok.T_IMPLEMENTS,\n    \"new\": this.tok.T_NEW,\n    clone: this.tok.T_CLONE,\n    \"var\": this.tok.T_VAR,\n    eval: this.tok.T_EVAL,\n    include: this.tok.T_INCLUDE,\n    include_once: this.tok.T_INCLUDE_ONCE,\n    require: this.tok.T_REQUIRE,\n    require_once: this.tok.T_REQUIRE_ONCE,\n    namespace: this.tok.T_NAMESPACE,\n    use: this.tok.T_USE,\n    insteadof: this.tok.T_INSTEADOF,\n    global: this.tok.T_GLOBAL,\n    isset: this.tok.T_ISSET,\n    empty: this.tok.T_EMPTY,\n    __halt_compiler: this.tok.T_HALT_COMPILER,\n    \"static\": this.tok.T_STATIC,\n    \"abstract\": this.tok.T_ABSTRACT,\n    \"final\": this.tok.T_FINAL,\n    \"private\": this.tok.T_PRIVATE,\n    \"protected\": this.tok.T_PROTECTED,\n    \"public\": this.tok.T_PUBLIC,\n    unset: this.tok.T_UNSET,\n    list: this.tok.T_LIST,\n    array: this.tok.T_ARRAY,\n    callable: this.tok.T_CALLABLE,\n    or: this.tok.T_LOGICAL_OR,\n    and: this.tok.T_LOGICAL_AND,\n    xor: this.tok.T_LOGICAL_XOR\n  };\n  this.castKeywords = {\n    \"int\": this.tok.T_INT_CAST,\n    integer: this.tok.T_INT_CAST,\n    real: this.tok.T_DOUBLE_CAST,\n    \"double\": this.tok.T_DOUBLE_CAST,\n    \"float\": this.tok.T_DOUBLE_CAST,\n    string: this.tok.T_STRING_CAST,\n    binary: this.tok.T_STRING_CAST,\n    array: this.tok.T_ARRAY_CAST,\n    object: this.tok.T_OBJECT_CAST,\n    bool: this.tok.T_BOOL_CAST,\n    \"boolean\": this.tok.T_BOOL_CAST,\n    unset: this.tok.T_UNSET_CAST\n  };\n};\n/**\n * Initialize the lexer with the specified input\n */\n\n\nlexer.prototype.setInput = function (input) {\n  this._input = input;\n  this.size = input.length;\n  this.yylineno = 1;\n  this.offset = 0;\n  this.yyprevcol = 0;\n  this.yytext = \"\";\n  this.yylloc = {\n    first_offset: 0,\n    first_line: 1,\n    first_column: 0,\n    prev_offset: 0,\n    prev_line: 1,\n    prev_column: 0,\n    last_line: 1,\n    last_column: 0\n  };\n  this.tokens = [];\n\n  if (this.version > 703) {\n    this.keywords.fn = this.tok.T_FN;\n  } else {\n    delete this.keywords.fn;\n  }\n\n  this.done = this.offset >= this.size;\n\n  if (!this.all_tokens && this.mode_eval) {\n    this.conditionStack = [\"INITIAL\"];\n    this.begin(\"ST_IN_SCRIPTING\");\n  } else {\n    this.conditionStack = [];\n    this.begin(\"INITIAL\");\n  } // https://github.com/php/php-src/blob/999e32b65a8a4bb59e27e538fa68ffae4b99d863/Zend/zend_language_scanner.h#L59\n  // Used for heredoc and nowdoc\n\n\n  this.heredoc_label = {\n    label: \"\",\n    length: 0,\n    indentation: 0,\n    indentation_uses_spaces: false,\n    finished: false,\n\n    /**\n     * this used for parser to detemine the if current node segment is first encaps node.\n     * if ture, the indentation will remove from the begining. and if false, the prev node\n     * might be a variable '}' ,and the leading spaces should not be removed util meet the\n     * first \\n\n     */\n    first_encaps_node: false,\n    // for backward compatible\n    toString: function toString() {\n      this.label;\n    }\n  };\n  return this;\n};\n/**\n * consumes and returns one char from the input\n */\n\n\nlexer.prototype.input = function () {\n  var ch = this._input[this.offset];\n  if (!ch) return \"\";\n  this.yytext += ch;\n  this.offset++;\n\n  if (ch === \"\\r\" && this._input[this.offset] === \"\\n\") {\n    this.yytext += \"\\n\";\n    this.offset++;\n  }\n\n  if (ch === \"\\n\" || ch === \"\\r\") {\n    this.yylloc.last_line = ++this.yylineno;\n    this.yyprevcol = this.yylloc.last_column;\n    this.yylloc.last_column = 0;\n  } else {\n    this.yylloc.last_column++;\n  }\n\n  return ch;\n};\n/**\n * revert eating specified size\n */\n\n\nlexer.prototype.unput = function (size) {\n  if (size === 1) {\n    // 1 char unput (most cases)\n    this.offset--;\n\n    if (this._input[this.offset] === \"\\n\" && this._input[this.offset - 1] === \"\\r\") {\n      this.offset--;\n      size++;\n    }\n\n    if (this._input[this.offset] === \"\\r\" || this._input[this.offset] === \"\\n\") {\n      this.yylloc.last_line--;\n      this.yylineno--;\n      this.yylloc.last_column = this.yyprevcol;\n    } else {\n      this.yylloc.last_column--;\n    }\n\n    this.yytext = this.yytext.substring(0, this.yytext.length - size);\n  } else if (size > 0) {\n    this.offset -= size;\n\n    if (size < this.yytext.length) {\n      this.yytext = this.yytext.substring(0, this.yytext.length - size); // re-calculate position\n\n      this.yylloc.last_line = this.yylloc.first_line;\n      this.yylloc.last_column = this.yyprevcol = this.yylloc.first_column;\n\n      for (var i = 0; i < this.yytext.length; i++) {\n        var c = this.yytext[i];\n\n        if (c === \"\\r\") {\n          c = this.yytext[++i];\n          this.yyprevcol = this.yylloc.last_column;\n          this.yylloc.last_line++;\n          this.yylloc.last_column = 0;\n\n          if (c !== \"\\n\") {\n            if (c === \"\\r\") {\n              this.yylloc.last_line++;\n            } else {\n              this.yylloc.last_column++;\n            }\n          }\n        } else if (c === \"\\n\") {\n          this.yyprevcol = this.yylloc.last_column;\n          this.yylloc.last_line++;\n          this.yylloc.last_column = 0;\n        } else {\n          this.yylloc.last_column++;\n        }\n      }\n\n      this.yylineno = this.yylloc.last_line;\n    } else {\n      // reset full text\n      this.yytext = \"\";\n      this.yylloc.last_line = this.yylineno = this.yylloc.first_line;\n      this.yylloc.last_column = this.yylloc.first_column;\n    }\n  }\n\n  return this;\n}; // check if the text matches\n\n\nlexer.prototype.tryMatch = function (text) {\n  return text === this.ahead(text.length);\n}; // check if the text matches\n\n\nlexer.prototype.tryMatchCaseless = function (text) {\n  return text === this.ahead(text.length).toLowerCase();\n}; // look ahead\n\n\nlexer.prototype.ahead = function (size) {\n  var text = this._input.substring(this.offset, this.offset + size);\n\n  if (text[text.length - 1] === \"\\r\" && this._input[this.offset + size + 1] === \"\\n\") {\n    text += \"\\n\";\n  }\n\n  return text;\n}; // consume the specified size\n\n\nlexer.prototype.consume = function (size) {\n  for (var i = 0; i < size; i++) {\n    var ch = this._input[this.offset];\n    if (!ch) break;\n    this.yytext += ch;\n    this.offset++;\n\n    if (ch === \"\\r\" && this._input[this.offset] === \"\\n\") {\n      this.yytext += \"\\n\";\n      this.offset++;\n      i++;\n    }\n\n    if (ch === \"\\n\" || ch === \"\\r\") {\n      this.yylloc.last_line = ++this.yylineno;\n      this.yyprevcol = this.yylloc.last_column;\n      this.yylloc.last_column = 0;\n    } else {\n      this.yylloc.last_column++;\n    }\n  }\n\n  return this;\n};\n/**\n * Gets the current state\n */\n\n\nlexer.prototype.getState = function () {\n  return {\n    yytext: this.yytext,\n    offset: this.offset,\n    yylineno: this.yylineno,\n    yyprevcol: this.yyprevcol,\n    yylloc: {\n      first_offset: this.yylloc.first_offset,\n      first_line: this.yylloc.first_line,\n      first_column: this.yylloc.first_column,\n      last_line: this.yylloc.last_line,\n      last_column: this.yylloc.last_column\n    },\n    heredoc_label: this.heredoc_label\n  };\n};\n/**\n * Sets the current lexer state\n */\n\n\nlexer.prototype.setState = function (state) {\n  this.yytext = state.yytext;\n  this.offset = state.offset;\n  this.yylineno = state.yylineno;\n  this.yyprevcol = state.yyprevcol;\n  this.yylloc = state.yylloc;\n\n  if (state.heredoc_label) {\n    this.heredoc_label = state.heredoc_label;\n  }\n\n  return this;\n}; // prepend next token\n\n\nlexer.prototype.appendToken = function (value, ahead) {\n  this.tokens.push([value, ahead]);\n  return this;\n}; // return next match that has a token\n\n\nlexer.prototype.lex = function () {\n  this.yylloc.prev_offset = this.offset;\n  this.yylloc.prev_line = this.yylloc.last_line;\n  this.yylloc.prev_column = this.yylloc.last_column;\n  var token = this.next() || this.lex();\n\n  if (!this.all_tokens) {\n    while (token === this.tok.T_WHITESPACE || // ignore white space\n    !this.comment_tokens && (token === this.tok.T_COMMENT || // ignore single lines comments\n    token === this.tok.T_DOC_COMMENT) || // ignore doc comments\n    // ignore open tags\n    token === this.tok.T_OPEN_TAG) {\n      token = this.next() || this.lex();\n    }\n\n    if (token == this.tok.T_OPEN_TAG_WITH_ECHO) {\n      // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1683\n      // open tag with echo statement\n      return this.tok.T_ECHO;\n    } else if (token === this.tok.T_CLOSE_TAG) {\n      // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1680\n      return \";\";\n      /* implicit ; */\n    }\n  }\n\n  if (!this.yylloc.prev_offset) {\n    this.yylloc.prev_offset = this.yylloc.first_offset;\n    this.yylloc.prev_line = this.yylloc.first_line;\n    this.yylloc.prev_column = this.yylloc.first_column;\n  }\n  /*else if (this.yylloc.prev_offset === this.offset && this.offset !== this.size) {\n    throw new Error('Infinite loop @ ' + this.offset + ' / ' + this.size);\n  }*/\n\n\n  return token;\n}; // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n\n\nlexer.prototype.begin = function (condition) {\n  this.conditionStack.push(condition);\n  this.curCondition = condition;\n  this.stateCb = this[\"match\" + condition];\n\n  if (typeof this.stateCb !== \"function\") {\n    throw new Error('Undefined condition state \"' + condition + '\"');\n  }\n\n  return this;\n}; // pop the previously active lexer condition state off the condition stack\n\n\nlexer.prototype.popState = function () {\n  var n = this.conditionStack.length - 1;\n  var condition = n > 0 ? this.conditionStack.pop() : this.conditionStack[0];\n  this.curCondition = this.conditionStack[this.conditionStack.length - 1];\n  this.stateCb = this[\"match\" + this.curCondition];\n\n  if (typeof this.stateCb !== \"function\") {\n    throw new Error('Undefined condition state \"' + this.curCondition + '\"');\n  }\n\n  return condition;\n}; // return next match in input\n\n\nlexer.prototype.next = function () {\n  var token;\n\n  if (!this._input) {\n    this.done = true;\n  }\n\n  this.yylloc.first_offset = this.offset;\n  this.yylloc.first_line = this.yylloc.last_line;\n  this.yylloc.first_column = this.yylloc.last_column;\n  this.yytext = \"\";\n\n  if (this.done) {\n    this.yylloc.prev_offset = this.yylloc.first_offset;\n    this.yylloc.prev_line = this.yylloc.first_line;\n    this.yylloc.prev_column = this.yylloc.first_column;\n    return this.EOF;\n  }\n\n  if (this.tokens.length > 0) {\n    token = this.tokens.shift();\n\n    if (_typeof(token[1]) === \"object\") {\n      this.setState(token[1]);\n    } else {\n      this.consume(token[1]);\n    }\n\n    token = token[0];\n  } else {\n    token = this.stateCb.apply(this, []);\n  }\n\n  if (this.offset >= this.size && this.tokens.length === 0) {\n    this.done = true;\n  }\n\n  if (this.debug) {\n    var tName = token;\n\n    if (typeof tName === \"number\") {\n      tName = this.engine.tokens.values[tName];\n    } else {\n      tName = '\"' + tName + '\"';\n    }\n\n    var e = new Error(tName + \"\\tfrom \" + this.yylloc.first_line + \",\" + this.yylloc.first_column + \"\\t - to \" + this.yylloc.last_line + \",\" + this.yylloc.last_column + '\\t\"' + this.yytext + '\"'); // eslint-disable-next-line no-console\n\n    console.error(e.stack);\n  }\n\n  return token;\n}; // extends the lexer with states\n\n\n[__webpack_require__(14), __webpack_require__(15), __webpack_require__(16), __webpack_require__(18), __webpack_require__(19), __webpack_require__(20), __webpack_require__(21), __webpack_require__(22)].forEach(function (ext) {\n  for (var k in ext) {\n    lexer.prototype[k] = ext[k];\n  }\n});\nmodule.exports = lexer;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a single line comment\n   */\n  T_COMMENT: function T_COMMENT() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (ch === \"\\n\" || ch === \"\\r\") {\n        return this.tok.T_COMMENT;\n      } else if (ch === \"?\" && !this.aspTagMode && this._input[this.offset] === \">\") {\n        this.unput(1);\n        return this.tok.T_COMMENT;\n      } else if (ch === \"%\" && this.aspTagMode && this._input[this.offset] === \">\") {\n        this.unput(1);\n        return this.tok.T_COMMENT;\n      }\n    }\n\n    return this.tok.T_COMMENT;\n  },\n\n  /**\n   * Behaviour : https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1927\n   */\n  T_DOC_COMMENT: function T_DOC_COMMENT() {\n    var ch = this.input();\n    var token = this.tok.T_COMMENT;\n\n    if (ch === \"*\") {\n      // started with '/*' , check is next is '*'\n      ch = this.input();\n\n      if (this.is_WHITESPACE()) {\n        // check if next is WHITESPACE\n        token = this.tok.T_DOC_COMMENT;\n      }\n\n      if (ch === \"/\") {\n        return token;\n      } else {\n        this.unput(1); // reset\n      }\n    }\n\n    while (this.offset < this.size) {\n      ch = this.input();\n\n      if (ch === \"*\" && this._input[this.offset] === \"/\") {\n        this.input();\n        break;\n      }\n    }\n\n    return token;\n  }\n};\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  nextINITIAL: function nextINITIAL() {\n    if (this.conditionStack.length > 1 && this.conditionStack[this.conditionStack.length - 1] === \"INITIAL\") {\n      // Return to HEREDOC/ST_DOUBLE_QUOTES mode\n      this.popState();\n    } else {\n      this.begin(\"ST_IN_SCRIPTING\");\n    }\n\n    return this;\n  },\n  matchINITIAL: function matchINITIAL() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (ch == \"<\") {\n        ch = this.ahead(1);\n\n        if (ch == \"?\") {\n          if (this.tryMatch(\"?=\")) {\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();\n            break;\n          } else if (this.tryMatchCaseless(\"?php\")) {\n            ch = this._input[this.offset + 4];\n\n            if (ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\") {\n              this.unput(1).appendToken(this.tok.T_OPEN_TAG, 6).nextINITIAL();\n              break;\n            }\n          }\n\n          if (this.short_tags) {\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();\n            break;\n          }\n        } else if (this.asp_tags && ch == \"%\") {\n          if (this.tryMatch(\"%=\")) {\n            this.aspTagMode = true;\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();\n            break;\n          } else {\n            this.aspTagMode = true;\n            this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.yytext.length > 0) {\n      return this.tok.T_INLINE_HTML;\n    } else {\n      return false;\n    }\n  }\n};\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/* istanbul ignore else  */\n\nvar MAX_LENGTH_OF_LONG = 10;\nvar long_min_digits = \"2147483648\";\n\nif (process.arch == \"x64\") {\n  MAX_LENGTH_OF_LONG = 19;\n  long_min_digits = \"9223372036854775808\";\n}\n\nmodule.exports = {\n  consume_NUM: function consume_NUM() {\n    var ch = this.yytext[0];\n    var hasPoint = ch === \".\";\n\n    if (ch === \"0\") {\n      ch = this.input(); // check if hexa\n\n      if (ch === \"x\" || ch === \"X\") {\n        ch = this.input();\n\n        if (ch !== \"_\" && this.is_HEX()) {\n          return this.consume_HNUM();\n        } else {\n          this.unput(ch ? 2 : 1);\n        } // check binary notation\n\n      } else if (ch === \"b\" || ch === \"B\") {\n        ch = this.input();\n\n        if (ch !== \"_\" && ch === \"0\" || ch === \"1\") {\n          return this.consume_BNUM();\n        } else {\n          this.unput(ch ? 2 : 1);\n        } // @fixme check octal notation ? not usefull\n\n      } else if (!this.is_NUM()) {\n        if (ch) this.unput(1);\n      }\n    }\n\n    while (this.offset < this.size) {\n      var prev = ch;\n      ch = this.input();\n\n      if (ch === \"_\") {\n        if (prev === \"_\") {\n          // restriction : next to underscore / 1__1;\n          this.unput(2); // keep 1\n\n          break;\n        }\n\n        if (prev === \".\") {\n          // next to decimal point  \"1._0\"\n          this.unput(1); // keep 1.\n\n          break;\n        }\n\n        if (prev === \"e\" || prev === \"E\") {\n          // next to e \"1e_10\"\n          this.unput(2); // keep 1\n\n          break;\n        }\n      } else if (ch === \".\") {\n        if (hasPoint) {\n          // no multiple points \"1.0.5\"\n          this.unput(1); // keep 1.0\n\n          break;\n        }\n\n        if (prev === \"_\") {\n          // next to decimal point  \"1_.0\"\n          this.unput(2); // keep 1\n\n          break;\n        }\n\n        hasPoint = true;\n        continue;\n      } else if (ch === \"e\" || ch === \"E\") {\n        if (prev === \"_\") {\n          // next to e \"1_e10\"\n          this.unput(1);\n          break;\n        }\n\n        var undo = 2;\n        ch = this.input();\n\n        if (ch === \"+\" || ch === \"-\") {\n          // 1e-5\n          undo = 3;\n          ch = this.input();\n        }\n\n        if (this.is_NUM_START()) {\n          this.consume_LNUM();\n          return this.tok.T_DNUMBER;\n        }\n\n        this.unput(ch ? undo : undo - 1); // keep only 1\n\n        break;\n      }\n\n      if (!this.is_NUM()) {\n        // example : 10.0a\n        if (ch) this.unput(1); // keep 10.0\n\n        break;\n      }\n    }\n\n    if (hasPoint) {\n      return this.tok.T_DNUMBER;\n    } else if (this.yytext.length < MAX_LENGTH_OF_LONG - 1) {\n      return this.tok.T_LNUMBER;\n    } else {\n      if (this.yytext.length < MAX_LENGTH_OF_LONG || this.yytext.length == MAX_LENGTH_OF_LONG && this.yytext < long_min_digits) {\n        return this.tok.T_LNUMBER;\n      }\n\n      return this.tok.T_DNUMBER;\n    }\n  },\n  // read hexa\n  consume_HNUM: function consume_HNUM() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (!this.is_HEX()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this.tok.T_LNUMBER;\n  },\n  // read a generic number\n  consume_LNUM: function consume_LNUM() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (!this.is_NUM()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this.tok.T_LNUMBER;\n  },\n  // read binary\n  consume_BNUM: function consume_BNUM() {\n    var ch;\n\n    while (this.offset < this.size) {\n      ch = this.input();\n\n      if (ch !== \"0\" && ch !== \"1\" && ch !== \"_\") {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this.tok.T_LNUMBER;\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(17)))\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  matchST_LOOKING_FOR_PROPERTY: function matchST_LOOKING_FOR_PROPERTY() {\n    var ch = this.input();\n\n    if (ch === \"-\") {\n      ch = this.input();\n\n      if (ch === \">\") {\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1296\n        return this.tok.T_OBJECT_OPERATOR;\n      }\n\n      if (ch) this.unput(1);\n    } else if (this.is_WHITESPACE()) {\n      return this.tok.T_WHITESPACE;\n    } else if (this.is_LABEL_START()) {\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1300\n      this.consume_LABEL();\n      this.popState();\n      return this.tok.T_STRING;\n    } // https://github.com/php/php-src/blob/master/Zend/zend_language_scanner.l#L1306\n\n\n    this.popState();\n    if (ch) this.unput(1);\n    return false;\n  },\n  matchST_LOOKING_FOR_VARNAME: function matchST_LOOKING_FOR_VARNAME() {\n    var ch = this.input(); // SHIFT STATE\n\n    this.popState();\n    this.begin(\"ST_IN_SCRIPTING\");\n\n    if (this.is_LABEL_START()) {\n      this.consume_LABEL();\n      ch = this.input();\n\n      if (ch === \"[\" || ch === \"}\") {\n        this.unput(1);\n        return this.tok.T_STRING_VARNAME;\n      } else {\n        // any char (that's started with a label sequence)\n        this.unput(this.yytext.length);\n      }\n    } else {\n      // any char (thats not a label start sequence)\n      if (ch) this.unput(1);\n    } // stops looking for a varname and starts the scripting mode\n\n\n    return false;\n  },\n  matchST_VAR_OFFSET: function matchST_VAR_OFFSET() {\n    var ch = this.input();\n\n    if (this.is_NUM_START()) {\n      this.consume_NUM();\n      return this.tok.T_NUM_STRING;\n    } else if (ch === \"]\") {\n      this.popState();\n      return \"]\";\n    } else if (ch === \"$\") {\n      this.input();\n\n      if (this.is_LABEL_START()) {\n        this.consume_LABEL();\n        return this.tok.T_VARIABLE;\n      } else {\n        throw new Error(\"Unexpected terminal\");\n      }\n    } else if (this.is_LABEL_START()) {\n      this.consume_LABEL();\n      return this.tok.T_STRING;\n    } else if (this.is_WHITESPACE() || ch === \"\\\\\" || ch === \"'\" || ch === \"#\") {\n      return this.tok.T_ENCAPSED_AND_WHITESPACE;\n    } else if (ch === \"[\" || ch === \"{\" || ch === \"}\" || ch === '\"' || ch === \"`\" || this.is_TOKEN()) {\n      return ch;\n    } else {\n      throw new Error(\"Unexpected terminal\");\n    }\n  }\n};\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  matchST_IN_SCRIPTING: function matchST_IN_SCRIPTING() {\n    var ch = this.input();\n\n    switch (ch) {\n      case \" \":\n      case \"\\t\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\r\\n\":\n        return this.T_WHITESPACE();\n\n      case \"#\":\n        return this.T_COMMENT();\n\n      case \"/\":\n        if (this._input[this.offset] === \"/\") {\n          return this.T_COMMENT();\n        } else if (this._input[this.offset] === \"*\") {\n          this.input();\n          return this.T_DOC_COMMENT();\n        }\n\n        return this.consume_TOKEN();\n\n      case \"'\":\n        return this.T_CONSTANT_ENCAPSED_STRING();\n\n      case '\"':\n        return this.ST_DOUBLE_QUOTES();\n\n      case \"`\":\n        this.begin(\"ST_BACKQUOTE\");\n        return \"`\";\n\n      case \"?\":\n        if (!this.aspTagMode && this.tryMatch(\">\")) {\n          this.input();\n          var nextCH = this._input[this.offset];\n          if (nextCH === \"\\n\" || nextCH === \"\\r\") this.input();\n\n          if (this.conditionStack.length > 1) {\n            this.begin(\"INITIAL\");\n          }\n\n          return this.tok.T_CLOSE_TAG;\n        }\n\n        return this.consume_TOKEN();\n\n      case \"%\":\n        if (this.aspTagMode && this._input[this.offset] === \">\") {\n          this.input(); // consume the '>'\n\n          ch = this._input[this.offset]; // read next\n\n          if (ch === \"\\n\" || ch === \"\\r\") {\n            this.input(); // consume the newline\n          }\n\n          this.aspTagMode = false;\n\n          if (this.conditionStack.length > 1) {\n            this.begin(\"INITIAL\");\n          }\n\n          return this.tok.T_CLOSE_TAG;\n        }\n\n        return this.consume_TOKEN();\n\n      case \"{\":\n        this.begin(\"ST_IN_SCRIPTING\");\n        return \"{\";\n\n      case \"}\":\n        if (this.conditionStack.length > 2) {\n          // Return to HEREDOC/ST_DOUBLE_QUOTES mode\n          this.popState();\n        }\n\n        return \"}\";\n\n      default:\n        if (ch === \".\") {\n          ch = this.input();\n\n          if (this.is_NUM_START()) {\n            return this.consume_NUM();\n          } else {\n            if (ch) this.unput(1);\n          }\n        }\n\n        if (this.is_NUM_START()) {\n          return this.consume_NUM();\n        } else if (this.is_LABEL_START()) {\n          return this.consume_LABEL().T_STRING();\n        } else if (this.is_TOKEN()) {\n          return this.consume_TOKEN();\n        }\n\n    }\n\n    throw new Error('Bad terminal sequence \"' + ch + '\" at line ' + this.yylineno + \" (offset \" + this.offset + \")\");\n  },\n  T_WHITESPACE: function T_WHITESPACE() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\") {\n        continue;\n      }\n\n      if (ch) this.unput(1);\n      break;\n    }\n\n    return this.tok.T_WHITESPACE;\n  }\n};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar newline = [\"\\n\", \"\\r\"];\nvar valid_after_heredoc = [\"\\n\", \"\\r\", \";\"];\nvar valid_after_heredoc_73 = valid_after_heredoc.concat([\"\\t\", \" \", \",\", \"]\", \")\", \"/\", \"=\", \"!\"]);\nmodule.exports = {\n  T_CONSTANT_ENCAPSED_STRING: function T_CONSTANT_ENCAPSED_STRING() {\n    var ch;\n\n    while (this.offset < this.size) {\n      ch = this.input();\n\n      if (ch == \"\\\\\") {\n        this.input();\n      } else if (ch == \"'\") {\n        break;\n      }\n    }\n\n    return this.tok.T_CONSTANT_ENCAPSED_STRING;\n  },\n  // check if matching a HEREDOC state\n  is_HEREDOC: function is_HEREDOC() {\n    var revert = this.offset;\n\n    if (this._input[this.offset - 1] === \"<\" && this._input[this.offset] === \"<\" && this._input[this.offset + 1] === \"<\") {\n      this.offset += 3; // optional tabs / spaces\n\n      if (this.is_TABSPACE()) {\n        while (this.offset < this.size) {\n          this.offset++;\n\n          if (!this.is_TABSPACE()) {\n            break;\n          }\n        }\n      } // optional quotes\n\n\n      var tChar = this._input[this.offset - 1];\n\n      if (tChar === \"'\" || tChar === '\"') {\n        this.offset++;\n      } else {\n        tChar = null;\n      } // required label\n\n\n      if (this.is_LABEL_START()) {\n        var yyoffset = this.offset - 1;\n\n        while (this.offset < this.size) {\n          this.offset++;\n\n          if (!this.is_LABEL()) {\n            break;\n          }\n        }\n\n        var yylabel = this._input.substring(yyoffset, this.offset - 1);\n\n        if (!tChar || tChar === this._input[this.offset - 1]) {\n          // required ending quote\n          if (tChar) this.offset++; // require newline\n\n          if (newline.includes(this._input[this.offset - 1])) {\n            // go go go\n            this.heredoc_label.label = yylabel;\n            this.heredoc_label.length = yylabel.length;\n            this.heredoc_label.finished = false;\n            yyoffset = this.offset - revert;\n            this.offset = revert;\n            this.consume(yyoffset);\n\n            if (tChar === \"'\") {\n              this.begin(\"ST_NOWDOC\");\n            } else {\n              this.begin(\"ST_HEREDOC\");\n            } // prematch to get the indentation information from end of doc\n\n\n            this.prematch_ENDOFDOC();\n            return this.tok.T_START_HEREDOC;\n          }\n        }\n      }\n    }\n\n    this.offset = revert;\n    return false;\n  },\n  ST_DOUBLE_QUOTES: function ST_DOUBLE_QUOTES() {\n    var ch;\n\n    while (this.offset < this.size) {\n      ch = this.input();\n\n      if (ch == \"\\\\\") {\n        this.input();\n      } else if (ch == '\"') {\n        break;\n      } else if (ch == \"$\") {\n        ch = this.input();\n\n        if (ch == \"{\" || this.is_LABEL_START()) {\n          this.unput(2);\n          break;\n        }\n\n        if (ch) this.unput(1);\n      } else if (ch == \"{\") {\n        ch = this.input();\n\n        if (ch == \"$\") {\n          this.unput(2);\n          break;\n        }\n\n        if (ch) this.unput(1);\n      }\n    }\n\n    if (ch == '\"') {\n      return this.tok.T_CONSTANT_ENCAPSED_STRING;\n    } else {\n      var prefix = 1;\n\n      if (this.yytext[0] === \"b\" || this.yytext[0] === \"B\") {\n        prefix = 2;\n      }\n\n      if (this.yytext.length > 2) {\n        this.appendToken(this.tok.T_ENCAPSED_AND_WHITESPACE, this.yytext.length - prefix);\n      }\n\n      this.unput(this.yytext.length - prefix);\n      this.begin(\"ST_DOUBLE_QUOTES\");\n      return this.yytext;\n    }\n  },\n  // check if its a DOC end sequence\n  isDOC_MATCH: function isDOC_MATCH(offset, consumeLeadingSpaces) {\n    // @fixme : check if out of text limits\n    // consumeLeadingSpaces is false happen DOC prematch END HEREDOC stage.\n    // Ensure current state is really after a new line break, not after a such as ${variables}\n    var prev_ch = this._input[offset - 2];\n\n    if (!newline.includes(prev_ch)) {\n      return false;\n    } // skip leading spaces or tabs\n\n\n    var indentation_uses_spaces = false;\n    var indentation_uses_tabs = false; // reset heredoc_label structure\n\n    var indentation = 0;\n    var leading_ch = this._input[offset - 1];\n\n    if (this.version >= 703) {\n      while (leading_ch === \"\\t\" || leading_ch === \" \") {\n        if (leading_ch === \" \") {\n          indentation_uses_spaces = true;\n        } else if (leading_ch === \"\\t\") {\n          indentation_uses_tabs = true;\n        }\n\n        leading_ch = this._input[offset + indentation];\n        indentation++;\n      } // Move offset to skip leading whitespace\n\n\n      offset = offset + indentation; // return out if there was only whitespace on this line\n\n      if (newline.includes(this._input[offset - 1])) {\n        return false;\n      }\n    }\n\n    if (this._input.substring(offset - 1, offset - 1 + this.heredoc_label.length) === this.heredoc_label.label) {\n      var ch = this._input[offset - 1 + this.heredoc_label.length];\n\n      if ((this.version >= 703 ? valid_after_heredoc_73 : valid_after_heredoc).includes(ch)) {\n        if (consumeLeadingSpaces) {\n          this.consume(indentation); // https://wiki.php.net/rfc/flexible_heredoc_nowdoc_syntaxes\n\n          if (indentation_uses_spaces && indentation_uses_tabs) {\n            throw new Error(\"Parse error:  mixing spaces and tabs in ending marker at line \" + this.yylineno + \" (offset \" + this.offset + \")\");\n          }\n        } else {\n          // Called in prematch_ENDOFDOC\n          this.heredoc_label.indentation = indentation;\n          this.heredoc_label.indentation_uses_spaces = indentation_uses_spaces;\n          this.heredoc_label.first_encaps_node = true;\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Prematch the end of HEREDOC/NOWDOC end tag to preset the\n   * context of this.heredoc_label\n   */\n  prematch_ENDOFDOC: function prematch_ENDOFDOC() {\n    // reset heredoc\n    this.heredoc_label.indentation_uses_spaces = false;\n    this.heredoc_label.indentation = 0;\n    this.heredoc_label.first_encaps_node = true;\n    var offset = this.offset + 1;\n\n    while (offset < this._input.length) {\n      // if match heredoc_label structrue will be set\n      if (this.isDOC_MATCH(offset, false)) {\n        return;\n      }\n\n      if (!newline.includes(this._input[offset - 1])) {\n        // skip one line\n        while (!newline.includes(this._input[offset++]) && offset < this._input.length) {// skip\n        }\n      }\n\n      offset++;\n    }\n  },\n  matchST_NOWDOC: function matchST_NOWDOC() {\n    /** edge case : empty now doc **/\n    if (this.isDOC_MATCH(this.offset, true)) {\n      // @fixme : never reached (may be caused by quotes)\n      this.consume(this.heredoc_label.length);\n      this.popState();\n      return this.tok.T_END_HEREDOC;\n    }\n    /** SCANNING CONTENTS **/\n\n\n    var ch = this._input[this.offset - 1];\n\n    while (this.offset < this.size) {\n      if (newline.includes(ch)) {\n        ch = this.input();\n\n        if (this.isDOC_MATCH(this.offset, true)) {\n          this.unput(1).popState();\n          this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length);\n          return this.tok.T_ENCAPSED_AND_WHITESPACE;\n        }\n      } else {\n        ch = this.input();\n      }\n    } // too bad ! reached end of document (will get a parse error)\n\n\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n  matchST_HEREDOC: function matchST_HEREDOC() {\n    /** edge case : empty here doc **/\n    var ch = this.input();\n\n    if (this.isDOC_MATCH(this.offset, true)) {\n      this.consume(this.heredoc_label.length - 1);\n      this.popState();\n      return this.tok.T_END_HEREDOC;\n    }\n    /** SCANNING CONTENTS **/\n\n\n    while (this.offset < this.size) {\n      if (ch === \"\\\\\") {\n        ch = this.input(); // ignore next\n\n        if (!newline.includes(ch)) {\n          ch = this.input();\n        }\n      }\n\n      if (newline.includes(ch)) {\n        ch = this.input();\n\n        if (this.isDOC_MATCH(this.offset, true)) {\n          this.unput(1).popState();\n          this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length);\n          return this.tok.T_ENCAPSED_AND_WHITESPACE;\n        }\n      } else if (ch === \"$\") {\n        ch = this.input();\n\n        if (ch === \"{\") {\n          // start of ${\n          this.begin(\"ST_LOOKING_FOR_VARNAME\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n          }\n        } else if (this.is_LABEL_START()) {\n          // start of $var...\n          var yyoffset = this.offset;\n          var next = this.consume_VARIABLE();\n\n          if (this.yytext.length > this.offset - yyoffset + 2) {\n            this.appendToken(next, this.offset - yyoffset + 2);\n            this.unput(this.offset - yyoffset + 2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return next;\n          } //console.log(this.yytext);\n\n        }\n      } else if (ch === \"{\") {\n        ch = this.input();\n\n        if (ch === \"$\") {\n          // start of {$...\n          this.begin(\"ST_IN_SCRIPTING\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_CURLY_OPEN, 1);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            this.unput(1);\n            return this.tok.T_CURLY_OPEN;\n          }\n        }\n      } else {\n        ch = this.input();\n      }\n    } // too bad ! reached end of document (will get a parse error)\n\n\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n  consume_VARIABLE: function consume_VARIABLE() {\n    this.consume_LABEL();\n    var ch = this.input();\n\n    if (ch == \"[\") {\n      this.unput(1);\n      this.begin(\"ST_VAR_OFFSET\");\n      return this.tok.T_VARIABLE;\n    } else if (ch === \"-\") {\n      if (this.input() === \">\") {\n        this.input();\n\n        if (this.is_LABEL_START()) {\n          this.begin(\"ST_LOOKING_FOR_PROPERTY\");\n        }\n\n        this.unput(3);\n        return this.tok.T_VARIABLE;\n      } else {\n        this.unput(2);\n      }\n    } else {\n      if (ch) this.unput(1);\n    }\n\n    return this.tok.T_VARIABLE;\n  },\n  // HANDLES BACKQUOTES\n  matchST_BACKQUOTE: function matchST_BACKQUOTE() {\n    var ch = this.input();\n\n    if (ch === \"$\") {\n      ch = this.input();\n\n      if (ch === \"{\") {\n        this.begin(\"ST_LOOKING_FOR_VARNAME\");\n        return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n      } else if (this.is_LABEL_START()) {\n        var tok = this.consume_VARIABLE();\n        return tok;\n      }\n    } else if (ch === \"{\") {\n      if (this._input[this.offset] === \"$\") {\n        this.begin(\"ST_IN_SCRIPTING\");\n        return this.tok.T_CURLY_OPEN;\n      }\n    } else if (ch === \"`\") {\n      this.popState();\n      return \"`\";\n    } // any char\n\n\n    while (this.offset < this.size) {\n      if (ch === \"\\\\\") {\n        this.input();\n      } else if (ch === \"`\") {\n        this.unput(1);\n        this.popState();\n        this.appendToken(\"`\", 1);\n        break;\n      } else if (ch === \"$\") {\n        ch = this.input();\n\n        if (ch === \"{\") {\n          this.begin(\"ST_LOOKING_FOR_VARNAME\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n          }\n        } else if (this.is_LABEL_START()) {\n          // start of $var...\n          var yyoffset = this.offset;\n          var next = this.consume_VARIABLE();\n\n          if (this.yytext.length > this.offset - yyoffset + 2) {\n            this.appendToken(next, this.offset - yyoffset + 2);\n            this.unput(this.offset - yyoffset + 2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return next;\n          }\n        }\n\n        continue;\n      } else if (ch === \"{\") {\n        ch = this.input();\n\n        if (ch === \"$\") {\n          // start of {$...\n          this.begin(\"ST_IN_SCRIPTING\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_CURLY_OPEN, 1);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            this.unput(1);\n            return this.tok.T_CURLY_OPEN;\n          }\n        }\n\n        continue;\n      }\n\n      ch = this.input();\n    }\n\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  },\n  matchST_DOUBLE_QUOTES: function matchST_DOUBLE_QUOTES() {\n    var ch = this.input();\n\n    if (ch === \"$\") {\n      ch = this.input();\n\n      if (ch === \"{\") {\n        this.begin(\"ST_LOOKING_FOR_VARNAME\");\n        return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n      } else if (this.is_LABEL_START()) {\n        var tok = this.consume_VARIABLE();\n        return tok;\n      }\n    } else if (ch === \"{\") {\n      if (this._input[this.offset] === \"$\") {\n        this.begin(\"ST_IN_SCRIPTING\");\n        return this.tok.T_CURLY_OPEN;\n      }\n    } else if (ch === '\"') {\n      this.popState();\n      return '\"';\n    } // any char\n\n\n    while (this.offset < this.size) {\n      if (ch === \"\\\\\") {\n        this.input();\n      } else if (ch === '\"') {\n        this.unput(1);\n        this.popState();\n        this.appendToken('\"', 1);\n        break;\n      } else if (ch === \"$\") {\n        ch = this.input();\n\n        if (ch === \"{\") {\n          this.begin(\"ST_LOOKING_FOR_VARNAME\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;\n          }\n        } else if (this.is_LABEL_START()) {\n          // start of $var...\n          var yyoffset = this.offset;\n          var next = this.consume_VARIABLE();\n\n          if (this.yytext.length > this.offset - yyoffset + 2) {\n            this.appendToken(next, this.offset - yyoffset + 2);\n            this.unput(this.offset - yyoffset + 2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            return next;\n          }\n        }\n\n        if (ch) this.unput(1);\n      } else if (ch === \"{\") {\n        ch = this.input();\n\n        if (ch === \"$\") {\n          // start of {$...\n          this.begin(\"ST_IN_SCRIPTING\");\n\n          if (this.yytext.length > 2) {\n            this.appendToken(this.tok.T_CURLY_OPEN, 1);\n            this.unput(2);\n            return this.tok.T_ENCAPSED_AND_WHITESPACE;\n          } else {\n            // @fixme : yytext = '\"{$' (this.yytext.length > 3)\n            this.unput(1);\n            return this.tok.T_CURLY_OPEN;\n          }\n        }\n\n        if (ch) this.unput(1);\n      }\n\n      ch = this.input();\n    }\n\n    return this.tok.T_ENCAPSED_AND_WHITESPACE;\n  }\n};\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  T_STRING: function T_STRING() {\n    var token = this.yytext.toLowerCase();\n    var id = this.keywords[token];\n\n    if (typeof id !== \"number\") {\n      if (token === \"yield\") {\n        if (this.version >= 700 && this.tryMatch(\" from\")) {\n          this.consume(5);\n          id = this.tok.T_YIELD_FROM;\n        } else {\n          id = this.tok.T_YIELD;\n        }\n      } else {\n        id = this.tok.T_STRING;\n\n        if (token === \"b\" || token === \"B\") {\n          var ch = this.input(1);\n\n          if (ch === '\"') {\n            return this.ST_DOUBLE_QUOTES();\n          } else if (ch === \"'\") {\n            return this.T_CONSTANT_ENCAPSED_STRING();\n          } else if (ch) {\n            this.unput(1);\n          }\n        }\n      }\n    }\n\n    return id;\n  },\n  // reads a custom token\n  consume_TOKEN: function consume_TOKEN() {\n    var ch = this._input[this.offset - 1];\n    var fn = this.tokenTerminals[ch];\n\n    if (fn) {\n      return fn.apply(this, []);\n    } else {\n      return this.yytext;\n    }\n  },\n  // list of special char tokens\n  tokenTerminals: {\n    $: function $() {\n      this.offset++;\n\n      if (this.is_LABEL_START()) {\n        this.offset--;\n        this.consume_LABEL();\n        return this.tok.T_VARIABLE;\n      } else {\n        this.offset--;\n        return \"$\";\n      }\n    },\n    \"-\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \">\") {\n        this.begin(\"ST_LOOKING_FOR_PROPERTY\").input();\n        return this.tok.T_OBJECT_OPERATOR;\n      } else if (nchar === \"-\") {\n        this.input();\n        return this.tok.T_DEC;\n      } else if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_MINUS_EQUAL;\n      }\n\n      return \"-\";\n    },\n    \"\\\\\": function _() {\n      return this.tok.T_NS_SEPARATOR;\n    },\n    \"/\": function _() {\n      if (this._input[this.offset] === \"=\") {\n        this.input();\n        return this.tok.T_DIV_EQUAL;\n      }\n\n      return \"/\";\n    },\n    \":\": function _() {\n      if (this._input[this.offset] === \":\") {\n        this.input();\n        return this.tok.T_DOUBLE_COLON;\n      } else {\n        return \":\";\n      }\n    },\n    \"(\": function _() {\n      var initial = this.offset;\n      this.input();\n\n      if (this.is_TABSPACE()) {\n        this.consume_TABSPACE().input();\n      }\n\n      if (this.is_LABEL_START()) {\n        var yylen = this.yytext.length;\n        this.consume_LABEL();\n        var castToken = this.yytext.substring(yylen - 1).toLowerCase();\n        var castId = this.castKeywords[castToken];\n\n        if (typeof castId === \"number\") {\n          this.input();\n\n          if (this.is_TABSPACE()) {\n            this.consume_TABSPACE().input();\n          }\n\n          if (this._input[this.offset - 1] === \")\") {\n            return castId;\n          }\n        }\n      } // revert the check\n\n\n      this.unput(this.offset - initial);\n      return \"(\";\n    },\n    \"=\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \">\") {\n        this.input();\n        return this.tok.T_DOUBLE_ARROW;\n      } else if (nchar === \"=\") {\n        if (this._input[this.offset + 1] === \"=\") {\n          this.consume(2);\n          return this.tok.T_IS_IDENTICAL;\n        } else {\n          this.input();\n          return this.tok.T_IS_EQUAL;\n        }\n      }\n\n      return \"=\";\n    },\n    \"+\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"+\") {\n        this.input();\n        return this.tok.T_INC;\n      } else if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_PLUS_EQUAL;\n      }\n\n      return \"+\";\n    },\n    \"!\": function _() {\n      if (this._input[this.offset] === \"=\") {\n        if (this._input[this.offset + 1] === \"=\") {\n          this.consume(2);\n          return this.tok.T_IS_NOT_IDENTICAL;\n        } else {\n          this.input();\n          return this.tok.T_IS_NOT_EQUAL;\n        }\n      }\n\n      return \"!\";\n    },\n    \"?\": function _() {\n      if (this.version >= 700 && this._input[this.offset] === \"?\") {\n        if (this.version >= 704 && this._input[this.offset + 1] === \"=\") {\n          this.consume(2);\n          return this.tok.T_COALESCE_EQUAL;\n        } else {\n          this.input();\n          return this.tok.T_COALESCE;\n        }\n      }\n\n      return \"?\";\n    },\n    \"<\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"<\") {\n        nchar = this._input[this.offset + 1];\n\n        if (nchar === \"=\") {\n          this.consume(2);\n          return this.tok.T_SL_EQUAL;\n        } else if (nchar === \"<\") {\n          if (this.is_HEREDOC()) {\n            return this.tok.T_START_HEREDOC;\n          }\n        }\n\n        this.input();\n        return this.tok.T_SL;\n      } else if (nchar === \"=\") {\n        this.input();\n\n        if (this.version >= 700 && this._input[this.offset] === \">\") {\n          this.input();\n          return this.tok.T_SPACESHIP;\n        } else {\n          return this.tok.T_IS_SMALLER_OR_EQUAL;\n        }\n      } else if (nchar === \">\") {\n        this.input();\n        return this.tok.T_IS_NOT_EQUAL;\n      }\n\n      return \"<\";\n    },\n    \">\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_IS_GREATER_OR_EQUAL;\n      } else if (nchar === \">\") {\n        nchar = this._input[this.offset + 1];\n\n        if (nchar === \"=\") {\n          this.consume(2);\n          return this.tok.T_SR_EQUAL;\n        } else {\n          this.input();\n          return this.tok.T_SR;\n        }\n      }\n\n      return \">\";\n    },\n    \"*\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_MUL_EQUAL;\n      } else if (nchar === \"*\") {\n        this.input();\n\n        if (this._input[this.offset] === \"=\") {\n          this.input();\n          return this.tok.T_POW_EQUAL;\n        } else {\n          return this.tok.T_POW;\n        }\n      }\n\n      return \"*\";\n    },\n    \".\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_CONCAT_EQUAL;\n      } else if (nchar === \".\" && this._input[this.offset + 1] === \".\") {\n        this.consume(2);\n        return this.tok.T_ELLIPSIS;\n      }\n\n      return \".\";\n    },\n    \"%\": function _() {\n      if (this._input[this.offset] === \"=\") {\n        this.input();\n        return this.tok.T_MOD_EQUAL;\n      }\n\n      return \"%\";\n    },\n    \"&\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_AND_EQUAL;\n      } else if (nchar === \"&\") {\n        this.input();\n        return this.tok.T_BOOLEAN_AND;\n      }\n\n      return \"&\";\n    },\n    \"|\": function _() {\n      var nchar = this._input[this.offset];\n\n      if (nchar === \"=\") {\n        this.input();\n        return this.tok.T_OR_EQUAL;\n      } else if (nchar === \"|\") {\n        this.input();\n        return this.tok.T_BOOLEAN_OR;\n      }\n\n      return \"|\";\n    },\n    \"^\": function _() {\n      if (this._input[this.offset] === \"=\") {\n        this.input();\n        return this.tok.T_XOR_EQUAL;\n      }\n\n      return \"^\";\n    }\n  }\n};\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar tokens = \";:,.\\\\[]()|^&+-/*=%!~$<>?@\";\nmodule.exports = {\n  // check if the char can be a numeric\n  is_NUM: function is_NUM() {\n    var ch = this._input.charCodeAt(this.offset - 1);\n\n    return ch > 47 && ch < 58 || ch === 95;\n  },\n  // check if the char can be a numeric\n  is_NUM_START: function is_NUM_START() {\n    var ch = this._input.charCodeAt(this.offset - 1);\n\n    return ch > 47 && ch < 58;\n  },\n  // check if current char can be a label\n  is_LABEL: function is_LABEL() {\n    var ch = this._input.charCodeAt(this.offset - 1);\n\n    return ch > 96 && ch < 123 || ch > 64 && ch < 91 || ch === 95 || ch > 47 && ch < 58 || ch > 126;\n  },\n  // check if current char can be a label\n  is_LABEL_START: function is_LABEL_START() {\n    var ch = this._input.charCodeAt(this.offset - 1); // A - Z\n\n\n    if (ch > 64 && ch < 91) return true; // a - z\n\n    if (ch > 96 && ch < 123) return true; // _ (95)\n\n    if (ch === 95) return true; // utf8 / extended\n\n    if (ch > 126) return true; // else\n\n    return false;\n  },\n  // reads each char of the label\n  consume_LABEL: function consume_LABEL() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (!this.is_LABEL()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this;\n  },\n  // check if current char is a token char\n  is_TOKEN: function is_TOKEN() {\n    var ch = this._input[this.offset - 1];\n    return tokens.indexOf(ch) !== -1;\n  },\n  // check if current char is a whitespace\n  is_WHITESPACE: function is_WHITESPACE() {\n    var ch = this._input[this.offset - 1];\n    return ch === \" \" || ch === \"\\t\" || ch === \"\\n\" || ch === \"\\r\";\n  },\n  // check if current char is a whitespace (without newlines)\n  is_TABSPACE: function is_TABSPACE() {\n    var ch = this._input[this.offset - 1];\n    return ch === \" \" || ch === \"\\t\";\n  },\n  // consume all whitespaces (excluding newlines)\n  consume_TABSPACE: function consume_TABSPACE() {\n    while (this.offset < this.size) {\n      var ch = this.input();\n\n      if (!this.is_TABSPACE()) {\n        if (ch) this.unput(1);\n        break;\n      }\n    }\n\n    return this;\n  },\n  // check if current char can be a hexadecimal number\n  is_HEX: function is_HEX() {\n    var ch = this._input.charCodeAt(this.offset - 1); // 0 - 9\n\n\n    if (ch > 47 && ch < 58) return true; // A - F\n\n    if (ch > 64 && ch < 71) return true; // a - f\n\n    if (ch > 96 && ch < 103) return true; // _ (code 95)\n\n    if (ch === 95) return true; // else\n\n    return false;\n  }\n};\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * @private\n */\n\nfunction isNumber(n) {\n  return n != \".\" && n != \",\" && !isNaN(parseFloat(n)) && isFinite(n);\n}\n/**\n * The PHP Parser class that build the AST tree from the lexer\n *\n * @class\n * @tutorial Parser\n * @property {Lexer} lexer - current lexer instance\n * @property {AST} ast - the AST factory instance\n * @property {Integer|String} token - current token\n * @property {Boolean} extractDoc - should extract documentation as AST node\n * @property {Boolean} extractTokens - should extract each token\n * @property {Boolean} suppressErrors - should ignore parsing errors and continue\n * @property {Boolean} debug - should output debug informations\n */\n\n\nvar parser = function parser(lexer, ast) {\n  this.lexer = lexer;\n  this.ast = ast;\n  this.tok = lexer.tok;\n  this.EOF = lexer.EOF;\n  this.token = null;\n  this.prev = null;\n  this.debug = false;\n  this.version = 704;\n  this.extractDoc = false;\n  this.extractTokens = false;\n  this.suppressErrors = false;\n\n  var mapIt = function mapIt(item) {\n    return [item, null];\n  };\n\n  this.entries = {\n    // reserved_non_modifiers\n    IDENTIFIER: new Map([this.tok.T_ABSTRACT, this.tok.T_ARRAY, this.tok.T_AS, this.tok.T_BREAK, this.tok.T_CALLABLE, this.tok.T_CASE, this.tok.T_CATCH, this.tok.T_CLASS, this.tok.T_CLASS_C, this.tok.T_CLONE, this.tok.T_CONST, this.tok.T_CONTINUE, this.tok.T_DECLARE, this.tok.T_DEFAULT, this.tok.T_DIR, this.tok.T_DO, this.tok.T_ECHO, this.tok.T_ELSE, this.tok.T_ELSEIF, this.tok.T_EMPTY, this.tok.T_ENDDECLARE, this.tok.T_ENDFOR, this.tok.T_ENDFOREACH, this.tok.T_ENDIF, this.tok.T_ENDSWITCH, this.tok.T_ENDWHILE, this.tok.T_EVAL, this.tok.T_EXIT, this.tok.T_EXTENDS, this.tok.T_FILE, this.tok.T_FINAL, this.tok.T_FINALLY, this.tok.T_FN, this.tok.T_FOR, this.tok.T_FOREACH, this.tok.T_FUNC_C, this.tok.T_FUNCTION, this.tok.T_GLOBAL, this.tok.T_GOTO, this.tok.T_IF, this.tok.T_IMPLEMENTS, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_INSTANCEOF, this.tok.T_INSTEADOF, this.tok.T_INTERFACE, this.tok.T_ISSET, this.tok.T_LINE, this.tok.T_LIST, this.tok.T_LOGICAL_AND, this.tok.T_LOGICAL_OR, this.tok.T_LOGICAL_XOR, this.tok.T_METHOD_C, this.tok.T_NAMESPACE, this.tok.T_NEW, this.tok.T_NS_C, this.tok.T_PRINT, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_PUBLIC, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_RETURN, this.tok.T_STATIC, this.tok.T_SWITCH, this.tok.T_THROW, this.tok.T_TRAIT, this.tok.T_TRY, this.tok.T_UNSET, this.tok.T_USE, this.tok.T_VAR, this.tok.T_WHILE, this.tok.T_YIELD].map(mapIt)),\n    VARIABLE: new Map([this.tok.T_VARIABLE, \"$\", \"&\", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAMESPACE, this.tok.T_STATIC].map(mapIt)),\n    SCALAR: new Map([this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, \"[\", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C, '\"', 'b\"', 'B\"', \"-\", this.tok.T_NS_SEPARATOR].map(mapIt)),\n    T_MAGIC_CONST: new Map([this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C].map(mapIt)),\n    T_MEMBER_FLAGS: new Map([this.tok.T_PUBLIC, this.tok.T_PRIVATE, this.tok.T_PROTECTED, this.tok.T_STATIC, this.tok.T_ABSTRACT, this.tok.T_FINAL].map(mapIt)),\n    EOS: new Map([\";\", this.EOF, this.tok.T_INLINE_HTML].map(mapIt)),\n    EXPR: new Map([\"@\", \"-\", \"+\", \"!\", \"~\", \"(\", \"`\", this.tok.T_LIST, this.tok.T_CLONE, this.tok.T_INC, this.tok.T_DEC, this.tok.T_NEW, this.tok.T_ISSET, this.tok.T_EMPTY, this.tok.T_INCLUDE, this.tok.T_INCLUDE_ONCE, this.tok.T_REQUIRE, this.tok.T_REQUIRE_ONCE, this.tok.T_EVAL, this.tok.T_INT_CAST, this.tok.T_DOUBLE_CAST, this.tok.T_STRING_CAST, this.tok.T_ARRAY_CAST, this.tok.T_OBJECT_CAST, this.tok.T_BOOL_CAST, this.tok.T_UNSET_CAST, this.tok.T_EXIT, this.tok.T_PRINT, this.tok.T_YIELD, this.tok.T_STATIC, this.tok.T_FUNCTION, this.tok.T_FN, // using VARIABLES :\n    this.tok.T_VARIABLE, \"$\", this.tok.T_NS_SEPARATOR, this.tok.T_STRING, // using SCALAR :\n    this.tok.T_STRING, // @see variable.js line 45 > conflict with variable = shift/reduce :)\n    this.tok.T_CONSTANT_ENCAPSED_STRING, this.tok.T_START_HEREDOC, this.tok.T_LNUMBER, this.tok.T_DNUMBER, this.tok.T_ARRAY, \"[\", this.tok.T_CLASS_C, this.tok.T_TRAIT_C, this.tok.T_FUNC_C, this.tok.T_METHOD_C, this.tok.T_LINE, this.tok.T_FILE, this.tok.T_DIR, this.tok.T_NS_C].map(mapIt))\n  };\n};\n/**\n * helper : gets a token name\n */\n\n\nparser.prototype.getTokenName = function (token) {\n  if (!isNumber(token)) {\n    return \"'\" + token + \"'\";\n  } else {\n    if (token == this.EOF) return \"the end of file (EOF)\";\n    return this.lexer.engine.tokens.values[token];\n  }\n};\n/**\n * main entry point : converts a source code to AST\n */\n\n\nparser.prototype.parse = function (code, filename) {\n  this._errors = [];\n  this.filename = filename || \"eval\";\n  this.currentNamespace = [\"\"];\n\n  if (this.extractDoc) {\n    this._docs = [];\n  } else {\n    this._docs = null;\n  }\n\n  if (this.extractTokens) {\n    this._tokens = [];\n  } else {\n    this._tokens = null;\n  }\n\n  this._docIndex = 0;\n  this._lastNode = null;\n  this.lexer.setInput(code);\n  this.lexer.all_tokens = this.extractTokens;\n  this.lexer.comment_tokens = this.extractDoc;\n  this.length = this.lexer._input.length;\n  this.innerList = false;\n  this.innerListForm = false;\n  var program = this.node(\"program\");\n  var childs = [];\n  this.next();\n\n  while (this.token != this.EOF) {\n    childs.push(this.read_start());\n  } // append last comment\n\n\n  if (childs.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n    childs.push(this.node(\"noop\")());\n  } // #176 : register latest position\n\n\n  this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];\n  var result = program(childs, this._errors, this._docs, this._tokens);\n\n  if (this.debug) {\n    var errors = this.ast.checkNodes();\n\n    if (errors.length > 0) {\n      errors.forEach(function (error) {\n        if (error.position) {\n          // eslint-disable-next-line no-console\n          console.log(\"Node at line \" + error.position.line + \", column \" + error.position.column);\n        } // eslint-disable-next-line no-console\n\n\n        console.log(error.stack.join(\"\\n\"));\n      });\n      throw new Error(\"Some nodes are not closed\");\n    }\n  }\n\n  return result;\n};\n/**\n * Raise an error\n */\n\n\nparser.prototype.raiseError = function (message, msgExpect, expect, token) {\n  message += \" on line \" + this.lexer.yylloc.first_line;\n\n  if (!this.suppressErrors) {\n    var err = new SyntaxError(message, this.filename, this.lexer.yylloc.first_line);\n    err.lineNumber = this.lexer.yylloc.first_line;\n    err.fileName = this.filename;\n    err.columnNumber = this.lexer.yylloc.first_column;\n    throw err;\n  } // Error node :\n\n\n  var node = this.ast.prepare(\"error\", null, this)(message, token, this.lexer.yylloc.first_line, expect);\n\n  this._errors.push(node);\n\n  return node;\n};\n/**\n * handling errors\n */\n\n\nparser.prototype.error = function (expect) {\n  var msg = \"Parse Error : syntax error\";\n  var token = this.getTokenName(this.token);\n  var msgExpect = \"\";\n\n  if (this.token !== this.EOF) {\n    if (isNumber(this.token)) {\n      var symbol = this.text();\n\n      if (symbol.length > 10) {\n        symbol = symbol.substring(0, 7) + \"...\";\n      }\n\n      token = \"'\" + symbol + \"' (\" + token + \")\";\n    }\n\n    msg += \", unexpected \" + token;\n  }\n\n  if (expect && !Array.isArray(expect)) {\n    if (isNumber(expect) || expect.length === 1) {\n      msgExpect = \", expecting \" + this.getTokenName(expect);\n    }\n\n    msg += msgExpect;\n  }\n\n  return this.raiseError(msg, msgExpect, expect, token);\n};\n/**\n * Creates a new AST node\n */\n\n\nparser.prototype.node = function (name) {\n  if (this.extractDoc) {\n    var docs = null;\n\n    if (this._docIndex < this._docs.length) {\n      docs = this._docs.slice(this._docIndex);\n      this._docIndex = this._docs.length;\n\n      if (this.debug) {\n        // eslint-disable-next-line no-console\n        console.log(new Error(\"Append docs on \" + name)); // eslint-disable-next-line no-console\n\n        console.log(docs);\n      }\n    }\n\n    var node = this.ast.prepare(name, docs, this);\n    /**\n     * TOKENS :\n     * node1 commentA token commmentB node2 commentC token commentD node3 commentE token\n     *\n     * AST :\n     * structure:S1 [\n     *    left: node1 ( trail: commentA ),\n     *    right: structure:S2 [\n     *       node2 (lead: commentB, trail: commentC),\n     *       node3 (lead: commentD)\n     *    ],\n     *    trail: commentE\n     * ]\n     *\n     * Algorithm :\n     *\n     * Attach the last comments on parent of current node\n     * If a new node is started and the parent has a trailing comment\n     * the move it on previous node\n     *\n     * start S2\n     * start node1\n     * consume node1 & set commentA as trailingComment on S2\n     * start S2\n     * S1 has a trailingComment, attach it on node1\n     * ...\n     * NOTE : As the trailingComment Behavior depends on AST, it will be build on\n     * the AST layer - last child node will keep it's trailingComment nodes\n     */\n\n    node.postBuild = function (self) {\n      if (this._docIndex < this._docs.length) {\n        if (this._lastNode) {\n          var offset = this.prev[2];\n          var max = this._docIndex;\n\n          for (; max < this._docs.length; max++) {\n            if (this._docs[max].offset > offset) {\n              break;\n            }\n          }\n\n          if (max > this._docIndex) {\n            // inject trailing comment on child node\n            this._lastNode.setTrailingComments(this._docs.slice(this._docIndex, max));\n\n            this._docIndex = max;\n          }\n        } else if (this.token === this.EOF) {\n          // end of content\n          self.setTrailingComments(this._docs.slice(this._docIndex));\n          this._docIndex = this._docs.length;\n        }\n      }\n\n      this._lastNode = self;\n    }.bind(this);\n\n    return node;\n  }\n\n  return this.ast.prepare(name, null, this);\n};\n/**\n * expects an end of statement or end of file\n * @return {boolean}\n */\n\n\nparser.prototype.expectEndOfStatement = function (node) {\n  if (this.token === \";\") {\n    // include only real ';' statements\n    // https://github.com/glayzzle/php-parser/issues/164\n    if (node && this.lexer.yytext === \";\") {\n      node.includeToken(this);\n    }\n  } else if (this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF) {\n    this.error(\";\");\n    return false;\n  }\n\n  this.next();\n  return true;\n};\n/** outputs some debug information on current token **/\n\n\nvar ignoreStack = [\"parser.next\", \"parser.node\", \"parser.showlog\"];\n\nparser.prototype.showlog = function () {\n  var stack = new Error().stack.split(\"\\n\");\n  var line;\n\n  for (var offset = 2; offset < stack.length; offset++) {\n    line = stack[offset].trim();\n    var found = false;\n\n    for (var i = 0; i < ignoreStack.length; i++) {\n      if (line.substring(3, 3 + ignoreStack[i].length) === ignoreStack[i]) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      break;\n    }\n  } // eslint-disable-next-line no-console\n\n\n  console.log(\"Line \" + this.lexer.yylloc.first_line + \" : \" + this.getTokenName(this.token) + \">\" + this.lexer.yytext + \"<\" + \" @-->\" + line);\n  return this;\n};\n/**\n * Force the parser to check the current token.\n *\n * If the current token does not match to expected token,\n * the an error will be raised.\n *\n * If the suppressError mode is activated, then the error will\n * be added to the program error stack and this function will return `false`.\n *\n * @param {String|Number} token\n * @return {boolean}\n * @throws Error\n */\n\n\nparser.prototype.expect = function (token) {\n  if (Array.isArray(token)) {\n    if (token.indexOf(this.token) === -1) {\n      this.error(token);\n      return false;\n    }\n  } else if (this.token != token) {\n    this.error(token);\n    return false;\n  }\n\n  return true;\n};\n/**\n * Returns the current token contents\n * @return {String}\n */\n\n\nparser.prototype.text = function () {\n  return this.lexer.yytext;\n};\n/** consume the next token **/\n\n\nparser.prototype.next = function () {\n  // prepare the back command\n  if (this.token !== \";\" || this.lexer.yytext === \";\") {\n    // ignore '?>' from automated resolution\n    // https://github.com/glayzzle/php-parser/issues/168\n    this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];\n  } // eating the token\n\n\n  this.lex(); // showing the debug\n\n  if (this.debug) {\n    this.showlog();\n  } // handling comments\n\n\n  if (this.extractDoc) {\n    while (this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT) {\n      // APPEND COMMENTS\n      if (this.token === this.tok.T_COMMENT) {\n        this._docs.push(this.read_comment());\n      } else {\n        this._docs.push(this.read_doc_comment());\n      }\n    }\n  }\n\n  return this;\n};\n/**\n * Eating a token\n */\n\n\nparser.prototype.lex = function () {\n  // append on token stack\n  if (this.extractTokens) {\n    do {\n      // the token\n      this.token = this.lexer.lex() || this.EOF;\n      if (this.token === this.EOF) return this;\n      var entry = this.lexer.yytext;\n\n      if (this.lexer.engine.tokens.values.hasOwnProperty(this.token)) {\n        entry = [this.lexer.engine.tokens.values[this.token], entry, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset];\n      } else {\n        entry = [null, entry, this.lexer.yylloc.first_line, this.lexer.yylloc.first_offset, this.lexer.offset];\n      }\n\n      this._tokens.push(entry);\n\n      if (this.token === this.tok.T_CLOSE_TAG) {\n        // https://github.com/php/php-src/blob/7ff186434e82ee7be7c59d0db9a976641cf7b09c/Zend/zend_compile.c#L1680\n        this.token = \";\";\n        return this;\n      } else if (this.token === this.tok.T_OPEN_TAG_WITH_ECHO) {\n        this.token = this.tok.T_ECHO;\n        return this;\n      }\n    } while (this.token === this.tok.T_WHITESPACE || // ignore white space\n    !this.extractDoc && (this.token === this.tok.T_COMMENT || // ignore single lines comments\n    this.token === this.tok.T_DOC_COMMENT) || // ignore doc comments\n    // ignore open tags\n    this.token === this.tok.T_OPEN_TAG);\n  } else {\n    this.token = this.lexer.lex() || this.EOF;\n  }\n\n  return this;\n};\n/**\n * Check if token is of specified type\n */\n\n\nparser.prototype.is = function (type) {\n  if (Array.isArray(type)) {\n    return type.indexOf(this.token) !== -1;\n  }\n\n  return this.entries[type].has(this.token);\n}; // extends the parser with syntax files\n\n\n[__webpack_require__(24), __webpack_require__(25), __webpack_require__(26), __webpack_require__(27), __webpack_require__(28), __webpack_require__(29), __webpack_require__(30), __webpack_require__(31), __webpack_require__(32), __webpack_require__(33), __webpack_require__(34), __webpack_require__(35), __webpack_require__(36), __webpack_require__(37), __webpack_require__(38)].forEach(function (ext) {\n  for (var k in ext) {\n    if (parser.prototype.hasOwnProperty(k)) {\n      // @see https://github.com/glayzzle/php-parser/issues/234\n      throw new Error(\"Function \" + k + \" is already defined - collision\");\n    }\n\n    parser.prototype[k] = ext[k];\n  }\n});\nmodule.exports = parser;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Parse an array\n   * ```ebnf\n   * array ::= T_ARRAY '(' array_pair_list ')' |\n   *   '[' array_pair_list ']'\n   * ```\n   */\n  read_array: function read_array() {\n    var expect = null;\n    var shortForm = false;\n    var result = this.node(\"array\");\n\n    if (this.token === this.tok.T_ARRAY) {\n      this.next().expect(\"(\");\n      expect = \")\";\n    } else {\n      shortForm = true;\n      expect = \"]\";\n    }\n\n    var items = [];\n\n    if (this.next().token !== expect) {\n      items = this.read_array_pair_list(shortForm);\n    }\n\n    this.expect(expect);\n    this.next();\n    return result(shortForm, items);\n  },\n\n  /**\n   * Reads an array of items\n   * ```ebnf\n   * array_pair_list ::= array_pair (',' array_pair?)*\n   * ```\n   */\n  read_array_pair_list: function read_array_pair_list(shortForm) {\n    var self = this;\n    return this.read_list(function () {\n      return self.read_array_pair(shortForm);\n    }, \",\", true);\n  },\n\n  /**\n   * Reads an entry\n   * array_pair:\n   *  expr T_DOUBLE_ARROW expr\n   *  | expr\n   *  | expr T_DOUBLE_ARROW '&' variable\n   *  | '&' variable\n   *  | expr T_DOUBLE_ARROW T_LIST '(' array_pair_list ')'\n   *  | T_LIST '(' array_pair_list ')'\n   */\n  read_array_pair: function read_array_pair(shortForm) {\n    if (!shortForm && this.token === \")\" || shortForm && this.token === \"]\") {\n      return;\n    }\n\n    if (this.token === \",\") {\n      return this.node(\"noop\")();\n    }\n\n    var entry = this.node(\"entry\");\n    var key = null;\n    var value = null;\n    var byRef = false;\n    var unpack = false;\n\n    if (this.token === \"&\") {\n      this.next();\n      byRef = true;\n      value = this.read_variable(true, false);\n    } else if (this.token === this.tok.T_ELLIPSIS && this.version >= 704) {\n      this.next();\n\n      if (this.token === \"&\") {\n        this.error();\n      }\n\n      unpack = true;\n      value = this.read_expr();\n    } else {\n      var expr = this.read_expr();\n\n      if (this.token === this.tok.T_DOUBLE_ARROW) {\n        this.next();\n        key = expr;\n\n        if (this.token === \"&\") {\n          this.next();\n          byRef = true;\n          value = this.read_variable(true, false);\n        } else {\n          value = this.read_expr();\n        }\n      } else {\n        value = expr;\n      }\n    }\n\n    return entry(key, value, byRef, unpack);\n  }\n};\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = {\n  /**\n   * reading a class\n   * ```ebnf\n   * class ::= class_scope? T_CLASS T_STRING (T_EXTENDS NAMESPACE_NAME)? (T_IMPLEMENTS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' CLASS_BODY '}'\n   * ```\n   */\n  read_class_declaration_statement: function read_class_declaration_statement() {\n    var result = this.node(\"class\");\n    var flag = this.read_class_modifiers(); // graceful mode : ignore token & go next\n\n    if (this.token !== this.tok.T_CLASS) {\n      this.error(this.tok.T_CLASS);\n      this.next();\n      return null;\n    }\n\n    this.next().expect(this.tok.T_STRING);\n    var propName = this.node(\"identifier\");\n    var name = this.text();\n    this.next();\n    propName = propName(name);\n    var propExtends = this.read_extends_from();\n    var propImplements = this.read_implements_list();\n    this.expect(\"{\");\n    var body = this.next().read_class_body();\n    return result(propName, propExtends, propImplements, body, flag);\n  },\n  read_class_modifiers: function read_class_modifiers() {\n    return [0, 0, this.read_class_modifier()];\n  },\n  read_class_modifier: function read_class_modifier() {\n    var result = 0;\n\n    if (this.token === this.tok.T_ABSTRACT) {\n      this.next();\n      return 1;\n    } else if (this.token === this.tok.T_FINAL) {\n      this.next();\n      return 2;\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a class body\n   * ```ebnf\n   *   class_body ::= (member_flags? (T_VAR | T_STRING | T_FUNCTION))*\n   * ```\n   */\n  read_class_body: function read_class_body() {\n    var result = [];\n\n    while (this.token !== this.EOF && this.token !== \"}\") {\n      if (this.token === this.tok.T_COMMENT) {\n        result.push(this.read_comment());\n        continue;\n      }\n\n      if (this.token === this.tok.T_DOC_COMMENT) {\n        result.push(this.read_doc_comment());\n        continue;\n      } // check T_USE trait\n\n\n      if (this.token === this.tok.T_USE) {\n        result = result.concat(this.read_trait_use_statement());\n        continue;\n      } // read member flags\n\n\n      var flags = this.read_member_flags(false); // check constant\n\n      if (this.token === this.tok.T_CONST) {\n        var constants = this.read_constant_list(flags);\n\n        if (this.expect(\";\")) {\n          this.next();\n        }\n\n        result = result.concat(constants);\n        continue;\n      } // jump over T_VAR then land on T_VARIABLE\n\n\n      if (this.token === this.tok.T_VAR) {\n        this.next().expect(this.tok.T_VARIABLE);\n        flags[0] = null; // public (as null)\n\n        flags[1] = 0; // non static var\n      }\n\n      if (this.token === this.tok.T_FUNCTION) {\n        // reads a function\n        result.push(this.read_function(false, flags));\n      } else if (this.token === this.tok.T_VARIABLE || // support https://wiki.php.net/rfc/typed_properties_v2\n      this.version >= 704 && (this.token === \"?\" || this.token === this.tok.T_CALLABLE || this.token === this.tok.T_ARRAY || this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE)) {\n        // reads a variable\n        var variables = this.read_variable_list(flags);\n        this.expect(\";\");\n        this.next();\n        result = result.concat(variables);\n      } else {\n        // raise an error\n        this.error([this.tok.T_CONST, this.tok.T_VARIABLE, this.tok.T_FUNCTION]); // ignore token\n\n        this.next();\n      }\n    }\n\n    this.expect(\"}\");\n    this.next();\n    return result;\n  },\n\n  /**\n   * Reads variable list\n   * ```ebnf\n   *  variable_list ::= (variable_declaration ',')* variable_declaration\n   * ```\n   */\n  read_variable_list: function read_variable_list(flags) {\n    var result = this.node(\"propertystatement\");\n    var properties = this.read_list(\n    /**\n     * Reads a variable declaration\n     *\n     * ```ebnf\n     *  variable_declaration ::= T_VARIABLE '=' scalar\n     * ```\n     */\n    function read_variable_declaration() {\n      var result = this.node(\"property\");\n\n      var _this$read_optional_t = this.read_optional_type(),\n          _this$read_optional_t2 = _slicedToArray(_this$read_optional_t, 2),\n          nullable = _this$read_optional_t2[0],\n          type = _this$read_optional_t2[1];\n\n      this.expect(this.tok.T_VARIABLE);\n      var propName = this.node(\"identifier\");\n      var name = this.text().substring(1); // ignore $\n\n      this.next();\n      propName = propName(name);\n\n      if (this.token === \";\" || this.token === \",\") {\n        return result(propName, null, nullable, type);\n      } else if (this.token === \"=\") {\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L815\n        return result(propName, this.next().read_expr(), nullable, type);\n      } else {\n        this.expect([\",\", \";\", \"=\"]);\n        return result(propName, null, nullable, type);\n      }\n    }, \",\");\n    return result(null, properties, flags);\n  },\n\n  /**\n   * Reads constant list\n   * ```ebnf\n   *  constant_list ::= T_CONST (constant_declaration ',')* constant_declaration\n   * ```\n   */\n  read_constant_list: function read_constant_list(flags) {\n    if (this.expect(this.tok.T_CONST)) {\n      this.next();\n    }\n\n    var result = this.node(\"classconstant\");\n    var items = this.read_list(\n    /**\n     * Reads a constant declaration\n     *\n     * ```ebnf\n     *  constant_declaration ::= (T_STRING | IDENTIFIER) '=' expr\n     * ```\n     * @return {Constant} [:link:](AST.md#constant)\n     */\n    function read_constant_declaration() {\n      var result = this.node(\"constant\");\n      var constName = null;\n      var value = null;\n\n      if (this.token === this.tok.T_STRING || this.version >= 700 && this.is(\"IDENTIFIER\")) {\n        constName = this.node(\"identifier\");\n        var name = this.text();\n        this.next();\n        constName = constName(name);\n      } else {\n        this.expect(\"IDENTIFIER\");\n      }\n\n      if (this.expect(\"=\")) {\n        value = this.next().read_expr();\n      }\n\n      return result(constName, value);\n    }, \",\");\n    return result(null, items, flags);\n  },\n\n  /**\n   * Read member flags\n   * @return array\n   *  1st index : 0 => public, 1 => protected, 2 => private\n   *  2nd index : 0 => instance member, 1 => static member\n   *  3rd index : 0 => normal, 1 => abstract member, 2 => final member\n   */\n  read_member_flags: function read_member_flags(asInterface) {\n    var result = [-1, -1, -1];\n\n    if (this.is(\"T_MEMBER_FLAGS\")) {\n      var idx = 0,\n          val = 0;\n\n      do {\n        switch (this.token) {\n          case this.tok.T_PUBLIC:\n            idx = 0;\n            val = 0;\n            break;\n\n          case this.tok.T_PROTECTED:\n            idx = 0;\n            val = 1;\n            break;\n\n          case this.tok.T_PRIVATE:\n            idx = 0;\n            val = 2;\n            break;\n\n          case this.tok.T_STATIC:\n            idx = 1;\n            val = 1;\n            break;\n\n          case this.tok.T_ABSTRACT:\n            idx = 2;\n            val = 1;\n            break;\n\n          case this.tok.T_FINAL:\n            idx = 2;\n            val = 2;\n            break;\n        }\n\n        if (asInterface) {\n          if (idx == 0 && val == 2) {\n            // an interface can't be private\n            this.expect([this.tok.T_PUBLIC, this.tok.T_PROTECTED]);\n            val = -1;\n          } else if (idx == 2 && val == 1) {\n            // an interface cant be abstract\n            this.error();\n            val = -1;\n          }\n        }\n\n        if (result[idx] !== -1) {\n          // already defined flag\n          this.error();\n        } else if (val !== -1) {\n          result[idx] = val;\n        }\n      } while (this.next().is(\"T_MEMBER_FLAGS\"));\n    }\n\n    if (result[1] == -1) result[1] = 0;\n    if (result[2] == -1) result[2] = 0;\n    return result;\n  },\n\n  /**\n   * optional_type:\n   *\t  /- empty -/\t{ $$ = NULL; }\n   *   |\ttype_expr\t{ $$ = $1; }\n   * ;\n   *\n   * type_expr:\n   *\t\ttype\t\t{ $$ = $1; }\n   *\t|\t'?' type\t{ $$ = $2; $$->attr |= ZEND_TYPE_NULLABLE; }\n   *\t|\tunion_type\t{ $$ = $1; }\n   * ;\n   *\n   * type:\n   * \t\tT_ARRAY\t\t{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_ARRAY); }\n   * \t|\tT_CALLABLE\t{ $$ = zend_ast_create_ex(ZEND_AST_TYPE, IS_CALLABLE); }\n   * \t|\tname\t\t{ $$ = $1; }\n   * ;\n   *\n   * union_type:\n   * \t\ttype '|' type       { $$ = zend_ast_create_list(2, ZEND_AST_TYPE_UNION, $1, $3); }\n   * \t|\tunion_type '|' type { $$ = zend_ast_list_add($1, $3); }\n   * ;\n   */\n  read_optional_type: function read_optional_type() {\n    var nullable = false;\n\n    if (this.token === \"?\") {\n      nullable = true;\n      this.next();\n    }\n\n    var type = this.read_type();\n\n    if (nullable && !type) {\n      this.raiseError(\"Expecting a type definition combined with nullable operator\");\n    }\n\n    if (!nullable && !type) {\n      return [false, null];\n    }\n\n    if (this.token === \"|\") {\n      type = [type];\n\n      do {\n        this.next();\n        var variant = this.read_type();\n\n        if (!variant) {\n          this.raiseError(\"Expecting a type definition\");\n          break;\n        }\n\n        type.push(variant);\n      } while (this.token === \"|\");\n    }\n\n    return [nullable, type];\n  },\n\n  /**\n   * reading an interface\n   * ```ebnf\n   * interface ::= T_INTERFACE T_STRING (T_EXTENDS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' INTERFACE_BODY '}'\n   * ```\n   */\n  read_interface_declaration_statement: function read_interface_declaration_statement() {\n    var result = this.node(\"interface\");\n\n    if (this.token !== this.tok.T_INTERFACE) {\n      this.error(this.tok.T_INTERFACE);\n      this.next();\n      return null;\n    }\n\n    this.next().expect(this.tok.T_STRING);\n    var propName = this.node(\"identifier\");\n    var name = this.text();\n    this.next();\n    propName = propName(name);\n    var propExtends = this.read_interface_extends_list();\n    this.expect(\"{\");\n    var body = this.next().read_interface_body();\n    return result(propName, propExtends, body);\n  },\n\n  /**\n   * Reads an interface body\n   * ```ebnf\n   *   interface_body ::= (member_flags? (T_CONST | T_FUNCTION))*\n   * ```\n   */\n  read_interface_body: function read_interface_body() {\n    var result = [];\n\n    while (this.token !== this.EOF && this.token !== \"}\") {\n      if (this.token === this.tok.T_COMMENT) {\n        result.push(this.read_comment());\n        continue;\n      }\n\n      if (this.token === this.tok.T_DOC_COMMENT) {\n        result.push(this.read_doc_comment());\n        continue;\n      } // read member flags\n\n\n      var flags = this.read_member_flags(true); // check constant\n\n      if (this.token == this.tok.T_CONST) {\n        var constants = this.read_constant_list(flags);\n\n        if (this.expect(\";\")) {\n          this.next();\n        }\n\n        result = result.concat(constants);\n      } else if (this.token === this.tok.T_FUNCTION) {\n        // reads a function\n        var method = this.read_function_declaration(2, flags);\n        method.parseFlags(flags);\n        result.push(method);\n\n        if (this.expect(\";\")) {\n          this.next();\n        }\n      } else {\n        // raise an error\n        this.error([this.tok.T_CONST, this.tok.T_FUNCTION]);\n        this.next();\n      }\n    }\n\n    if (this.expect(\"}\")) {\n      this.next();\n    }\n\n    return result;\n  },\n\n  /**\n   * reading a trait\n   * ```ebnf\n   * trait ::= T_TRAIT T_STRING (T_EXTENDS (NAMESPACE_NAME ',')* NAMESPACE_NAME)? '{' FUNCTION* '}'\n   * ```\n   */\n  read_trait_declaration_statement: function read_trait_declaration_statement() {\n    var result = this.node(\"trait\"); // graceful mode : ignore token & go next\n\n    if (this.token !== this.tok.T_TRAIT) {\n      this.error(this.tok.T_TRAIT);\n      this.next();\n      return null;\n    }\n\n    this.next().expect(this.tok.T_STRING);\n    var propName = this.node(\"identifier\");\n    var name = this.text();\n    this.next();\n    propName = propName(name);\n    this.expect(\"{\");\n    var body = this.next().read_class_body();\n    return result(propName, body);\n  },\n\n  /**\n   * reading a use statement\n   * ```ebnf\n   * trait_use_statement ::= namespace_name (',' namespace_name)* ('{' trait_use_alias '}')?\n   * ```\n   */\n  read_trait_use_statement: function read_trait_use_statement() {\n    // defines use statements\n    var node = this.node(\"traituse\");\n    this.expect(this.tok.T_USE) && this.next();\n    var traits = [this.read_namespace_name()];\n    var adaptations = null;\n\n    while (this.token === \",\") {\n      traits.push(this.next().read_namespace_name());\n    }\n\n    if (this.token === \"{\") {\n      adaptations = []; // defines alias statements\n\n      while (this.next().token !== this.EOF) {\n        if (this.token === \"}\") break;\n        adaptations.push(this.read_trait_use_alias());\n        this.expect(\";\");\n      }\n\n      if (this.expect(\"}\")) {\n        this.next();\n      }\n    } else {\n      if (this.expect(\";\")) {\n        this.next();\n      }\n    }\n\n    return node(traits, adaptations);\n  },\n\n  /**\n   * Reading trait alias\n   * ```ebnf\n   * trait_use_alias ::= namespace_name ( T_DOUBLE_COLON T_STRING )? (T_INSTEADOF namespace_name) | (T_AS member_flags? T_STRING)\n   * ```\n   * name list : https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L303\n   * trait adaptation : https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L742\n   */\n  read_trait_use_alias: function read_trait_use_alias() {\n    var node = this.node();\n    var trait = null;\n    var method;\n\n    if (this.is(\"IDENTIFIER\")) {\n      method = this.node(\"identifier\");\n      var methodName = this.text();\n      this.next();\n      method = method(methodName);\n    } else {\n      method = this.read_namespace_name();\n\n      if (this.token === this.tok.T_DOUBLE_COLON) {\n        this.next();\n\n        if (this.token === this.tok.T_STRING || this.version >= 700 && this.is(\"IDENTIFIER\")) {\n          trait = method;\n          method = this.node(\"identifier\");\n\n          var _methodName = this.text();\n\n          this.next();\n          method = method(_methodName);\n        } else {\n          this.expect(this.tok.T_STRING);\n        }\n      } else {\n        // convert identifier as string\n        method = method.name;\n      }\n    } // handle trait precedence\n\n\n    if (this.token === this.tok.T_INSTEADOF) {\n      return node(\"traitprecedence\", trait, method, this.next().read_name_list());\n    } else if (this.token === this.tok.T_AS) {\n      // handle trait alias\n      var flags = null;\n      var alias = null;\n\n      if (this.next().is(\"T_MEMBER_FLAGS\")) {\n        flags = this.read_member_flags();\n      }\n\n      if (this.token === this.tok.T_STRING || this.version >= 700 && this.is(\"IDENTIFIER\")) {\n        alias = this.node(\"identifier\");\n        var name = this.text();\n        this.next();\n        alias = alias(name);\n      } else if (flags === false) {\n        // no visibility flags and no name => too bad\n        this.expect(this.tok.T_STRING);\n      }\n\n      return node(\"traitalias\", trait, method, alias, flags);\n    } // handle errors\n\n\n    this.expect([this.tok.T_AS, this.tok.T_INSTEADOF]);\n    return node(\"traitalias\", trait, method, null, null);\n  }\n};\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   *  Comments with // or # or / * ... * /\n   */\n  read_comment: function read_comment() {\n    var text = this.text();\n    var result = this.ast.prepare(text.substring(0, 2) === \"/*\" ? \"commentblock\" : \"commentline\", null, this);\n    var offset = this.lexer.yylloc.first_offset; // handle location on comment\n\n    var prev = this.prev;\n    this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];\n    this.lex();\n    result = result(text);\n    result.offset = offset;\n    this.prev = prev;\n    return result;\n  },\n\n  /**\n   * Comments with / ** ... * /\n   */\n  read_doc_comment: function read_doc_comment() {\n    var result = this.ast.prepare(\"commentblock\", null, this);\n    var offset = this.lexer.yylloc.first_offset;\n    var text = this.text();\n    var prev = this.prev;\n    this.prev = [this.lexer.yylloc.last_line, this.lexer.yylloc.last_column, this.lexer.offset];\n    this.lex();\n    result = result(text);\n    result.offset = offset;\n    this.prev = prev;\n    return result;\n  }\n};\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  read_expr: function read_expr(expr) {\n    var result = this.node();\n\n    if (this.token === \"@\") {\n      if (!expr) {\n        expr = this.next().read_expr();\n      }\n\n      return result(\"silent\", expr);\n    }\n\n    if (!expr) {\n      expr = this.read_expr_item();\n    } // binary operations\n\n\n    if (this.token === \"|\") return result(\"bin\", \"|\", expr, this.next().read_expr());\n    if (this.token === \"&\") return result(\"bin\", \"&\", expr, this.next().read_expr());\n    if (this.token === \"^\") return result(\"bin\", \"^\", expr, this.next().read_expr());\n    if (this.token === \".\") return result(\"bin\", \".\", expr, this.next().read_expr());\n    if (this.token === \"+\") return result(\"bin\", \"+\", expr, this.next().read_expr());\n    if (this.token === \"-\") return result(\"bin\", \"-\", expr, this.next().read_expr());\n    if (this.token === \"*\") return result(\"bin\", \"*\", expr, this.next().read_expr());\n    if (this.token === \"/\") return result(\"bin\", \"/\", expr, this.next().read_expr());\n    if (this.token === \"%\") return result(\"bin\", \"%\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_POW) return result(\"bin\", \"**\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_SL) return result(\"bin\", \"<<\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_SR) return result(\"bin\", \">>\", expr, this.next().read_expr()); // more binary operations (formerly bool)\n\n    if (this.token === this.tok.T_BOOLEAN_OR) return result(\"bin\", \"||\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_LOGICAL_OR) return result(\"bin\", \"or\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_BOOLEAN_AND) return result(\"bin\", \"&&\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_LOGICAL_AND) return result(\"bin\", \"and\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_LOGICAL_XOR) return result(\"bin\", \"xor\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_IDENTICAL) return result(\"bin\", \"===\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_NOT_IDENTICAL) return result(\"bin\", \"!==\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_EQUAL) return result(\"bin\", \"==\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_NOT_EQUAL) return result(\"bin\", \"!=\", expr, this.next().read_expr());\n    if (this.token === \"<\") return result(\"bin\", \"<\", expr, this.next().read_expr());\n    if (this.token === \">\") return result(\"bin\", \">\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_SMALLER_OR_EQUAL) return result(\"bin\", \"<=\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_IS_GREATER_OR_EQUAL) return result(\"bin\", \">=\", expr, this.next().read_expr());\n    if (this.token === this.tok.T_SPACESHIP) return result(\"bin\", \"<=>\", expr, this.next().read_expr());\n\n    if (this.token === this.tok.T_INSTANCEOF) {\n      expr = result(\"bin\", \"instanceof\", expr, this.next().read_class_name_reference());\n\n      if (this.token !== \";\" && this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF) {\n        expr = this.read_expr(expr);\n      }\n    } // extra operations :\n    // $username = $_GET['user'] ?? 'nobody';\n\n\n    if (this.token === this.tok.T_COALESCE) return result(\"bin\", \"??\", expr, this.next().read_expr()); // extra operations :\n    // $username = $_GET['user'] ? true : false;\n\n    if (this.token === \"?\") {\n      var trueArg = null;\n\n      if (this.next().token !== \":\") {\n        trueArg = this.read_expr();\n      }\n\n      this.expect(\":\") && this.next();\n      return result(\"retif\", expr, trueArg, this.read_expr());\n    } else {\n      // see #193\n      result.destroy(expr);\n    }\n\n    return expr;\n  },\n\n  /**\n   * Reads a cast expression\n   */\n  read_expr_cast: function read_expr_cast(type) {\n    return this.node(\"cast\")(type, this.text(), this.next().read_expr());\n  },\n\n  /**\n   * Read a isset variable\n   */\n  read_isset_variable: function read_isset_variable() {\n    return this.read_expr();\n  },\n\n  /**\n   * Reads isset variables\n   */\n  read_isset_variables: function read_isset_variables() {\n    return this.read_function_list(this.read_isset_variable, \",\");\n  },\n\n  /*\n   * Reads internal PHP functions\n   */\n  read_internal_functions_in_yacc: function read_internal_functions_in_yacc() {\n    var result = null;\n\n    switch (this.token) {\n      case this.tok.T_ISSET:\n        {\n          result = this.node(\"isset\");\n\n          if (this.next().expect(\"(\")) {\n            this.next();\n          }\n\n          var variables = this.read_isset_variables();\n\n          if (this.expect(\")\")) {\n            this.next();\n          }\n\n          result = result(variables);\n        }\n        break;\n\n      case this.tok.T_EMPTY:\n        {\n          result = this.node(\"empty\");\n\n          if (this.next().expect(\"(\")) {\n            this.next();\n          }\n\n          var expression = this.read_expr();\n\n          if (this.expect(\")\")) {\n            this.next();\n          }\n\n          result = result(expression);\n        }\n        break;\n\n      case this.tok.T_INCLUDE:\n        result = this.node(\"include\")(false, false, this.next().read_expr());\n        break;\n\n      case this.tok.T_INCLUDE_ONCE:\n        result = this.node(\"include\")(true, false, this.next().read_expr());\n        break;\n\n      case this.tok.T_EVAL:\n        {\n          result = this.node(\"eval\");\n\n          if (this.next().expect(\"(\")) {\n            this.next();\n          }\n\n          var expr = this.read_expr();\n\n          if (this.expect(\")\")) {\n            this.next();\n          }\n\n          result = result(expr);\n        }\n        break;\n\n      case this.tok.T_REQUIRE:\n        result = this.node(\"include\")(false, true, this.next().read_expr());\n        break;\n\n      case this.tok.T_REQUIRE_ONCE:\n        result = this.node(\"include\")(true, true, this.next().read_expr());\n        break;\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads optional expression\n   */\n  read_optional_expr: function read_optional_expr(stopToken) {\n    if (this.token !== stopToken) {\n      return this.read_expr();\n    }\n\n    return null;\n  },\n\n  /**\n   * Reads exit expression\n   */\n  read_exit_expr: function read_exit_expr() {\n    var expression = null;\n\n    if (this.token === \"(\") {\n      this.next();\n      expression = this.read_optional_expr(\")\");\n      this.expect(\")\") && this.next();\n    }\n\n    return expression;\n  },\n\n  /**\n   * ```ebnf\n   * Reads an expression\n   *  expr ::= @todo\n   * ```\n   */\n  read_expr_item: function read_expr_item() {\n    var result, expr;\n    if (this.token === \"+\") return this.node(\"unary\")(\"+\", this.next().read_expr());\n    if (this.token === \"-\") return this.node(\"unary\")(\"-\", this.next().read_expr());\n    if (this.token === \"!\") return this.node(\"unary\")(\"!\", this.next().read_expr());\n    if (this.token === \"~\") return this.node(\"unary\")(\"~\", this.next().read_expr());\n\n    if (this.token === \"(\") {\n      expr = this.next().read_expr();\n      expr.parenthesizedExpression = true;\n      this.expect(\")\") && this.next();\n      return this.handleDereferencable(expr);\n    }\n\n    if (this.token === \"`\") {\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1048\n      return this.read_encapsed_string(\"`\");\n    }\n\n    if (this.token === this.tok.T_LIST) {\n      var assign = null;\n      var isInner = this.innerList;\n      result = this.node(\"list\");\n\n      if (!isInner) {\n        assign = this.node(\"assign\");\n      }\n\n      if (this.next().expect(\"(\")) {\n        this.next();\n      }\n\n      if (!this.innerList) this.innerList = true; // reads inner items\n\n      var assignList = this.read_array_pair_list(false);\n\n      if (this.expect(\")\")) {\n        this.next();\n      } // check if contains at least one assignment statement\n\n\n      var hasItem = false;\n\n      for (var i = 0; i < assignList.length; i++) {\n        if (assignList[i] !== null && assignList[i].kind !== \"noop\") {\n          hasItem = true;\n          break;\n        }\n      }\n\n      if (!hasItem) {\n        this.raiseError(\"Fatal Error :  Cannot use empty list on line \" + this.lexer.yylloc.first_line);\n      } // handles the node resolution\n\n\n      if (!isInner) {\n        this.innerList = false;\n\n        if (this.expect(\"=\")) {\n          return assign(result(assignList, false), this.next().read_expr(), \"=\");\n        } else {\n          // error fallback : list($a, $b);\n          return result(assignList, false);\n        }\n      } else {\n        return result(assignList, false);\n      }\n    }\n\n    if (this.token === this.tok.T_CLONE) return this.node(\"clone\")(this.next().read_expr());\n\n    switch (this.token) {\n      case this.tok.T_INC:\n        return this.node(\"pre\")(\"+\", this.next().read_variable(false, false));\n\n      case this.tok.T_DEC:\n        return this.node(\"pre\")(\"-\", this.next().read_variable(false, false));\n\n      case this.tok.T_NEW:\n        return this.read_new_expr();\n\n      case this.tok.T_ISSET:\n      case this.tok.T_EMPTY:\n      case this.tok.T_INCLUDE:\n      case this.tok.T_INCLUDE_ONCE:\n      case this.tok.T_EVAL:\n      case this.tok.T_REQUIRE:\n      case this.tok.T_REQUIRE_ONCE:\n        return this.read_internal_functions_in_yacc();\n\n      case this.tok.T_INT_CAST:\n        return this.read_expr_cast(\"int\");\n\n      case this.tok.T_DOUBLE_CAST:\n        return this.read_expr_cast(\"float\");\n\n      case this.tok.T_STRING_CAST:\n        return this.read_expr_cast(this.text().indexOf(\"binary\") !== -1 ? \"binary\" : \"string\");\n\n      case this.tok.T_ARRAY_CAST:\n        return this.read_expr_cast(\"array\");\n\n      case this.tok.T_OBJECT_CAST:\n        return this.read_expr_cast(\"object\");\n\n      case this.tok.T_BOOL_CAST:\n        return this.read_expr_cast(\"bool\");\n\n      case this.tok.T_UNSET_CAST:\n        return this.read_expr_cast(\"unset\");\n\n      case this.tok.T_EXIT:\n        {\n          var useDie = this.lexer.yytext.toLowerCase() === \"die\";\n          result = this.node(\"exit\");\n          this.next();\n          var expression = this.read_exit_expr();\n          return result(expression, useDie);\n        }\n\n      case this.tok.T_PRINT:\n        return this.node(\"print\")(this.next().read_expr());\n      // T_YIELD (expr (T_DOUBLE_ARROW expr)?)?\n\n      case this.tok.T_YIELD:\n        {\n          var value = null;\n          var key = null;\n          result = this.node(\"yield\");\n\n          if (this.next().is(\"EXPR\")) {\n            // reads the yield return value\n            value = this.read_expr();\n\n            if (this.token === this.tok.T_DOUBLE_ARROW) {\n              // reads the yield returned key\n              key = value;\n              value = this.next().read_expr();\n            }\n          }\n\n          return result(value, key);\n        }\n      // T_YIELD_FROM expr\n\n      case this.tok.T_YIELD_FROM:\n        result = this.node(\"yieldfrom\");\n        expr = this.next().read_expr();\n        return result(expr);\n\n      case this.tok.T_FN:\n      case this.tok.T_FUNCTION:\n        return this.read_inline_function();\n\n      case this.tok.T_STATIC:\n        {\n          var backup = [this.token, this.lexer.getState()];\n          this.next();\n\n          if (this.token === this.tok.T_FUNCTION || this.version >= 704 && this.token === this.tok.T_FN) {\n            // handles static function\n            return this.read_inline_function([0, 1, 0]);\n          } else {\n            // rollback\n            this.lexer.tokens.push(backup);\n            this.next();\n          }\n        }\n    } // SCALAR | VARIABLE\n\n\n    if (this.is(\"VARIABLE\")) {\n      result = this.node();\n      expr = this.read_variable(false, false); // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L877\n      // should accept only a variable\n\n      var isConst = expr.kind === \"identifier\" || expr.kind === \"staticlookup\" && expr.offset.kind === \"identifier\"; // VARIABLES SPECIFIC OPERATIONS\n\n      switch (this.token) {\n        case \"=\":\n          {\n            if (isConst) this.error(\"VARIABLE\");\n\n            if (this.next().token == \"&\") {\n              return this.read_assignref(result, expr);\n            }\n\n            return result(\"assign\", expr, this.read_expr(), \"=\");\n          }\n        // operations :\n\n        case this.tok.T_PLUS_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"+=\");\n\n        case this.tok.T_MINUS_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"-=\");\n\n        case this.tok.T_MUL_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"*=\");\n\n        case this.tok.T_POW_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"**=\");\n\n        case this.tok.T_DIV_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"/=\");\n\n        case this.tok.T_CONCAT_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \".=\");\n\n        case this.tok.T_MOD_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"%=\");\n\n        case this.tok.T_AND_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"&=\");\n\n        case this.tok.T_OR_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"|=\");\n\n        case this.tok.T_XOR_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"^=\");\n\n        case this.tok.T_SL_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"<<=\");\n\n        case this.tok.T_SR_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \">>=\");\n\n        case this.tok.T_COALESCE_EQUAL:\n          if (isConst) this.error(\"VARIABLE\");\n          return result(\"assign\", expr, this.next().read_expr(), \"??=\");\n\n        case this.tok.T_INC:\n          if (isConst) this.error(\"VARIABLE\");\n          this.next();\n          return result(\"post\", \"+\", expr);\n\n        case this.tok.T_DEC:\n          if (isConst) this.error(\"VARIABLE\");\n          this.next();\n          return result(\"post\", \"-\", expr);\n\n        default:\n          // see #193\n          result.destroy(expr);\n      }\n    } else if (this.is(\"SCALAR\")) {\n      result = this.node();\n      expr = this.read_scalar();\n\n      if (expr.kind === \"array\" && expr.shortForm && this.token === \"=\") {\n        // list assign\n        var list = this.node(\"list\")(expr.items, true);\n        if (expr.loc) list.loc = expr.loc;\n        var right = this.next().read_expr();\n        return result(\"assign\", list, right, \"=\");\n      } else {\n        // see #189 - swap docs on nodes\n        result.destroy(expr);\n      } // classic array\n\n\n      return this.handleDereferencable(expr);\n    } else {\n      this.error(\"EXPR\");\n      this.next();\n    } // returns variable | scalar\n\n\n    return expr;\n  },\n\n  /**\n   * Reads assignment\n   * @param {*} left\n   */\n  read_assignref: function read_assignref(result, left) {\n    this.next();\n    var right;\n\n    if (this.token === this.tok.T_NEW) {\n      if (this.version >= 700) {\n        this.error();\n      }\n\n      right = this.read_new_expr();\n    } else {\n      right = this.read_variable(false, false);\n    }\n\n    return result(\"assignref\", left, right);\n  },\n\n  /**\n   *\n   * inline_function:\n   * \t\tfunction returns_ref backup_doc_comment '(' parameter_list ')' lexical_vars return_type\n   * \t\tbackup_fn_flags '{' inner_statement_list '}' backup_fn_flags\n   * \t\t\t{ $$ = zend_ast_create_decl(ZEND_AST_CLOSURE, $2 | $13, $1, $3,\n   * \t\t\t\t  zend_string_init(\"{closure}\", sizeof(\"{closure}\") - 1, 0),\n   * \t\t\t\t  $5, $7, $11, $8); CG(extra_fn_flags) = $9; }\n   * \t|\tfn returns_ref '(' parameter_list ')' return_type backup_doc_comment T_DOUBLE_ARROW backup_fn_flags backup_lex_pos expr backup_fn_flags\n   * \t\t\t{ $$ = zend_ast_create_decl(ZEND_AST_ARROW_FUNC, $2 | $12, $1, $7,\n   * \t\t\t\t  zend_string_init(\"{closure}\", sizeof(\"{closure}\") - 1, 0), $4, NULL,\n   * \t\t\t\t  zend_ast_create(ZEND_AST_RETURN, $11), $6);\n   * \t\t\t\t  ((zend_ast_decl *) $$)->lex_pos = $10;\n   * \t\t\t\t  CG(extra_fn_flags) = $9; }   *\n   */\n  read_inline_function: function read_inline_function(flags) {\n    if (this.token === this.tok.T_FUNCTION) {\n      return this.read_function(true, flags);\n    } // introduced in PHP 7.4\n\n\n    if (!this.version >= 704) {\n      this.raiseError(\"Arrow Functions are not allowed\");\n    } // as an arrowfunc\n\n\n    var node = this.node(\"arrowfunc\"); // eat T_FN\n\n    if (this.expect(this.tok.T_FN)) this.next(); // check the &\n\n    var isRef = this.is_reference(); // ...\n\n    if (this.expect(\"(\")) this.next();\n    var params = this.read_parameter_list();\n    if (this.expect(\")\")) this.next();\n    var nullable = false;\n    var returnType = null;\n\n    if (this.token === \":\") {\n      if (this.next().token === \"?\") {\n        nullable = true;\n        this.next();\n      }\n\n      returnType = this.read_type();\n    }\n\n    if (this.expect(this.tok.T_DOUBLE_ARROW)) this.next();\n    var body = this.read_expr();\n    return node(params, isRef, body, returnType, nullable, flags ? true : false);\n  },\n\n  /**\n   * ```ebnf\n   *    new_expr ::= T_NEW (namespace_name function_argument_list) | (T_CLASS ... class declaration)\n   * ```\n   * https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L850\n   */\n  read_new_expr: function read_new_expr() {\n    var result = this.node(\"new\");\n    this.expect(this.tok.T_NEW) && this.next();\n    var args = [];\n\n    if (this.token === this.tok.T_CLASS) {\n      var what = this.node(\"class\"); // Annonymous class declaration\n\n      if (this.next().token === \"(\") {\n        args = this.read_argument_list();\n      }\n\n      var propExtends = this.read_extends_from();\n      var propImplements = this.read_implements_list();\n      var body = null;\n\n      if (this.expect(\"{\")) {\n        body = this.next().read_class_body();\n      }\n\n      return result(what(null, propExtends, propImplements, body, [0, 0, 0]), args);\n    } // Already existing class\n\n\n    var name = this.read_new_class_name();\n\n    if (this.token === \"(\") {\n      args = this.read_argument_list();\n    }\n\n    return result(name, args);\n  },\n\n  /**\n   * Reads a class name\n   * ```ebnf\n   * read_new_class_name ::= namespace_name | variable\n   * ```\n   */\n  read_new_class_name: function read_new_class_name() {\n    if (this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE) {\n      var result = this.read_namespace_name(true);\n\n      if (this.token === this.tok.T_DOUBLE_COLON) {\n        result = this.read_static_getter(result);\n      }\n\n      return result;\n    } else if (this.is(\"VARIABLE\")) {\n      return this.read_variable(true, false);\n    } else {\n      this.expect([this.tok.T_STRING, \"VARIABLE\"]);\n    }\n  },\n  handleDereferencable: function handleDereferencable(expr) {\n    while (this.token !== this.EOF) {\n      if (this.token === this.tok.T_OBJECT_OPERATOR || this.token === this.tok.T_DOUBLE_COLON) {\n        expr = this.recursive_variable_chain_scan(expr, false, false, true);\n      } else if (this.token === this.tok.T_CURLY_OPEN || this.token === \"[\") {\n        expr = this.read_dereferencable(expr);\n      } else if (this.token === \"(\") {\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1118\n        expr = this.node(\"call\")(expr, this.read_argument_list());\n      } else {\n        return expr;\n      }\n    }\n\n    return expr;\n  }\n};\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * checks if current token is a reference keyword\n   */\n  is_reference: function is_reference() {\n    if (this.token == \"&\") {\n      this.next();\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * checks if current token is a variadic keyword\n   */\n  is_variadic: function is_variadic() {\n    if (this.token === this.tok.T_ELLIPSIS) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * reading a function\n   * ```ebnf\n   * function ::= function_declaration code_block\n   * ```\n   */\n  read_function: function read_function(closure, flag) {\n    var result = this.read_function_declaration(closure ? 1 : flag ? 2 : 0, flag && flag[1] === 1);\n\n    if (flag && flag[2] == 1) {\n      // abstract function :\n      result.parseFlags(flag);\n\n      if (this.expect(\";\")) {\n        this.next();\n      }\n    } else {\n      if (this.expect(\"{\")) {\n        result.body = this.read_code_block(false);\n\n        if (result.loc && result.body.loc) {\n          result.loc.end = result.body.loc.end;\n        }\n      }\n\n      if (!closure && flag) {\n        result.parseFlags(flag);\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * reads a function declaration (without his body)\n   * ```ebnf\n   * function_declaration ::= T_FUNCTION '&'?  T_STRING '(' parameter_list ')'\n   * ```\n   */\n  read_function_declaration: function read_function_declaration(type, isStatic) {\n    var nodeName = \"function\";\n\n    if (type === 1) {\n      nodeName = \"closure\";\n    } else if (type === 2) {\n      nodeName = \"method\";\n    }\n\n    var result = this.node(nodeName);\n\n    if (this.expect(this.tok.T_FUNCTION)) {\n      this.next();\n    }\n\n    var isRef = this.is_reference();\n    var name = false,\n        use = [],\n        returnType = null,\n        nullable = false;\n\n    if (type !== 1) {\n      var nameNode = this.node(\"identifier\");\n\n      if (type === 2) {\n        if (this.version >= 700) {\n          if (this.token === this.tok.T_STRING || this.is(\"IDENTIFIER\")) {\n            name = this.text();\n            this.next();\n          } else if (this.version < 704) {\n            this.error(\"IDENTIFIER\");\n          }\n        } else if (this.token === this.tok.T_STRING) {\n          name = this.text();\n          this.next();\n        } else {\n          this.error(\"IDENTIFIER\");\n        }\n      } else {\n        if (this.version >= 700) {\n          if (this.token === this.tok.T_STRING) {\n            name = this.text();\n            this.next();\n          } else if (this.version >= 704) {\n            if (!this.expect(\"(\")) {\n              this.next();\n            }\n          } else {\n            this.error(this.tok.T_STRING);\n            this.next();\n          }\n        } else {\n          if (this.expect(this.tok.T_STRING)) {\n            name = this.text();\n          }\n\n          this.next();\n        }\n      }\n\n      name = nameNode(name);\n    }\n\n    if (this.expect(\"(\")) this.next();\n    var params = this.read_parameter_list();\n    if (this.expect(\")\")) this.next();\n\n    if (type === 1) {\n      use = this.read_lexical_vars();\n    }\n\n    if (this.token === \":\") {\n      if (this.next().token === \"?\") {\n        nullable = true;\n        this.next();\n      }\n\n      returnType = this.read_type();\n    }\n\n    if (type === 1) {\n      // closure\n      return result(params, isRef, use, returnType, nullable, isStatic);\n    }\n\n    return result(name, params, isRef, returnType, nullable);\n  },\n  read_lexical_vars: function read_lexical_vars() {\n    var result = [];\n\n    if (this.token === this.tok.T_USE) {\n      this.next();\n      this.expect(\"(\") && this.next();\n      result = this.read_lexical_var_list();\n      this.expect(\")\") && this.next();\n    }\n\n    return result;\n  },\n  read_lexical_var_list: function read_lexical_var_list() {\n    return this.read_list(this.read_lexical_var, \",\");\n  },\n\n  /**\n   * ```ebnf\n   * lexical_var ::= '&'? T_VARIABLE\n   * ```\n   */\n  read_lexical_var: function read_lexical_var() {\n    if (this.token === \"&\") {\n      return this.read_byref(this.read_lexical_var.bind(this));\n    }\n\n    var result = this.node(\"variable\");\n    this.expect(this.tok.T_VARIABLE);\n    var name = this.text().substring(1);\n    this.next();\n    return result(name, false);\n  },\n\n  /**\n   * reads a list of parameters\n   * ```ebnf\n   *  parameter_list ::= (parameter ',')* parameter?\n   * ```\n   */\n  read_parameter_list: function read_parameter_list() {\n    var result = [];\n\n    if (this.token != \")\") {\n      while (this.token != this.EOF) {\n        result.push(this.read_parameter());\n\n        if (this.token == \",\") {\n          this.next();\n        } else if (this.token == \")\") {\n          break;\n        } else {\n          this.error([\",\", \")\"]);\n          break;\n        }\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * ```ebnf\n   *  parameter ::= type? '&'? T_ELLIPSIS? T_VARIABLE ('=' expr)?\n   * ```\n   * @see https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L640\n   */\n  read_parameter: function read_parameter() {\n    var node = this.node(\"parameter\");\n    var parameterName = null;\n    var value = null;\n    var type = null;\n    var nullable = false;\n\n    if (this.token === \"?\") {\n      this.next();\n      nullable = true;\n    }\n\n    type = this.read_type();\n\n    if (nullable && !type) {\n      this.raiseError(\"Expecting a type definition combined with nullable operator\");\n    }\n\n    var isRef = this.is_reference();\n    var isVariadic = this.is_variadic();\n\n    if (this.expect(this.tok.T_VARIABLE)) {\n      parameterName = this.node(\"identifier\");\n      var name = this.text().substring(1);\n      this.next();\n      parameterName = parameterName(name);\n    }\n\n    if (this.token == \"=\") {\n      value = this.next().read_expr();\n    }\n\n    return node(parameterName, type, value, isRef, isVariadic, nullable);\n  },\n\n  /**\n   * Reads a list of arguments\n   * ```ebnf\n   *  function_argument_list ::= '(' (argument_list (',' argument_list)*)? ')'\n   * ```\n   */\n  read_argument_list: function read_argument_list() {\n    var result = [];\n    this.expect(\"(\") && this.next();\n\n    if (this.token !== \")\") {\n      result = this.read_non_empty_argument_list();\n    }\n\n    this.expect(\")\") && this.next();\n    return result;\n  },\n\n  /**\n   * Reads non empty argument list\n   */\n  read_non_empty_argument_list: function read_non_empty_argument_list() {\n    var wasVariadic = false;\n    return this.read_function_list(function () {\n      var argument = this.read_argument();\n\n      if (argument) {\n        if (wasVariadic) {\n          this.raiseError(\"Unexpected argument after a variadic argument\");\n        }\n\n        if (argument.kind === \"variadic\") {\n          wasVariadic = true;\n        }\n      }\n\n      return argument;\n    }.bind(this), \",\");\n  },\n\n  /**\n   * ```ebnf\n   *    argument_list ::= T_ELLIPSIS? expr\n   * ```\n   */\n  read_argument: function read_argument() {\n    if (this.token === this.tok.T_ELLIPSIS) {\n      return this.node(\"variadic\")(this.next().read_expr());\n    }\n\n    return this.read_expr();\n  },\n\n  /**\n   * read type hinting\n   * ```ebnf\n   *  type ::= T_ARRAY | T_CALLABLE | namespace_name\n   * ```\n   */\n  read_type: function read_type() {\n    var result = this.node();\n\n    if (this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE) {\n      var type = this.text();\n      this.next();\n      return result(\"typereference\", type.toLowerCase(), type);\n    } else if (this.token === this.tok.T_STRING) {\n      var _type = this.text();\n\n      var backup = [this.token, this.lexer.getState()];\n      this.next();\n\n      if (this.token !== this.tok.T_NS_SEPARATOR && this.ast.typereference.types.indexOf(_type.toLowerCase()) > -1) {\n        return result(\"typereference\", _type.toLowerCase(), _type);\n      } else {\n        // rollback a classic namespace\n        this.lexer.tokens.push(backup);\n        this.next(); // fix : destroy not consumed node (release comments)\n\n        result.destroy();\n        return this.read_namespace_name();\n      }\n    } else if (this.token === this.tok.T_NAMESPACE || this.token === this.tok.T_NS_SEPARATOR) {\n      // fix : destroy not consumed node (release comments)\n      result.destroy();\n      return this.read_namespace_name();\n    } // fix : destroy not consumed node (release comments)\n\n\n    result.destroy();\n    return null;\n  }\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads an IF statement\n   *\n   * ```ebnf\n   *  if ::= T_IF '(' expr ')' ':' ...\n   * ```\n   */\n  read_if: function read_if() {\n    var result = this.node(\"if\");\n    var test = this.next().read_if_expr();\n    var body = null;\n    var alternate = null;\n    var shortForm = false;\n\n    if (this.token === \":\") {\n      shortForm = true;\n      this.next();\n      body = this.node(\"block\");\n      var items = [];\n\n      while (this.token !== this.EOF && this.token !== this.tok.T_ENDIF) {\n        if (this.token === this.tok.T_ELSEIF) {\n          alternate = this.read_elseif_short();\n          break;\n        } else if (this.token === this.tok.T_ELSE) {\n          alternate = this.read_else_short();\n          break;\n        }\n\n        items.push(this.read_inner_statement());\n      }\n\n      body = body(null, items);\n      this.expect(this.tok.T_ENDIF) && this.next();\n      this.expectEndOfStatement();\n    } else {\n      body = this.read_statement();\n\n      if (this.token === this.tok.T_ELSEIF) {\n        alternate = this.read_if();\n      } else if (this.token === this.tok.T_ELSE) {\n        alternate = this.next().read_statement();\n      }\n    }\n\n    return result(test, body, alternate, shortForm);\n  },\n\n  /**\n   * reads an if expression : '(' expr ')'\n   */\n  read_if_expr: function read_if_expr() {\n    this.expect(\"(\") && this.next();\n    var result = this.read_expr();\n    this.expect(\")\") && this.next();\n    return result;\n  },\n\n  /**\n   * reads an elseif (expr): statements\n   */\n  read_elseif_short: function read_elseif_short() {\n    var alternate = null;\n    var result = this.node(\"if\");\n    var test = this.next().read_if_expr();\n    if (this.expect(\":\")) this.next();\n    var body = this.node(\"block\");\n    var items = [];\n\n    while (this.token != this.EOF && this.token !== this.tok.T_ENDIF) {\n      if (this.token === this.tok.T_ELSEIF) {\n        alternate = this.read_elseif_short();\n        break;\n      } else if (this.token === this.tok.T_ELSE) {\n        alternate = this.read_else_short();\n        break;\n      }\n\n      items.push(this.read_inner_statement());\n    }\n\n    return result(test, body(null, items), alternate, true);\n  },\n\n  /**\n   *\n   */\n  read_else_short: function read_else_short() {\n    if (this.next().expect(\":\")) this.next();\n    var body = this.node(\"block\");\n    var items = [];\n\n    while (this.token != this.EOF && this.token !== this.tok.T_ENDIF) {\n      items.push(this.read_inner_statement());\n    }\n\n    return body(null, items);\n  }\n};\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a while statement\n   * ```ebnf\n   * while ::= T_WHILE (statement | ':' inner_statement_list T_ENDWHILE ';')\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L587\n   * @return {While}\n   */\n  read_while: function read_while() {\n    var result = this.node(\"while\");\n    this.expect(this.tok.T_WHILE) && this.next();\n    var test = null;\n    var body = null;\n    var shortForm = false;\n    if (this.expect(\"(\")) this.next();\n    test = this.read_expr();\n    if (this.expect(\")\")) this.next();\n\n    if (this.token === \":\") {\n      shortForm = true;\n      body = this.read_short_form(this.tok.T_ENDWHILE);\n    } else {\n      body = this.read_statement();\n    }\n\n    return result(test, body, shortForm);\n  },\n\n  /**\n   * Reads a do / while loop\n   * ```ebnf\n   * do ::= T_DO statement T_WHILE '(' expr ')' ';'\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L423\n   * @return {Do}\n   */\n  read_do: function read_do() {\n    var result = this.node(\"do\");\n    this.expect(this.tok.T_DO) && this.next();\n    var test = null;\n    var body = null;\n    body = this.read_statement();\n\n    if (this.expect(this.tok.T_WHILE)) {\n      if (this.next().expect(\"(\")) this.next();\n      test = this.read_expr();\n      if (this.expect(\")\")) this.next();\n      if (this.expect(\";\")) this.next();\n    }\n\n    return result(test, body);\n  },\n\n  /**\n   * Read a for incremental loop\n   * ```ebnf\n   * for ::= T_FOR '(' for_exprs ';' for_exprs ';' for_exprs ')' for_statement\n   * for_statement ::= statement | ':' inner_statement_list T_ENDFOR ';'\n   * for_exprs ::= expr? (',' expr)*\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L425\n   * @return {For}\n   */\n  read_for: function read_for() {\n    var result = this.node(\"for\");\n    this.expect(this.tok.T_FOR) && this.next();\n    var init = [];\n    var test = [];\n    var increment = [];\n    var body = null;\n    var shortForm = false;\n    if (this.expect(\"(\")) this.next();\n\n    if (this.token !== \";\") {\n      init = this.read_list(this.read_expr, \",\");\n      if (this.expect(\";\")) this.next();\n    } else {\n      this.next();\n    }\n\n    if (this.token !== \";\") {\n      test = this.read_list(this.read_expr, \",\");\n      if (this.expect(\";\")) this.next();\n    } else {\n      this.next();\n    }\n\n    if (this.token !== \")\") {\n      increment = this.read_list(this.read_expr, \",\");\n      if (this.expect(\")\")) this.next();\n    } else {\n      this.next();\n    }\n\n    if (this.token === \":\") {\n      shortForm = true;\n      body = this.read_short_form(this.tok.T_ENDFOR);\n    } else {\n      body = this.read_statement();\n    }\n\n    return result(init, test, increment, body, shortForm);\n  },\n\n  /**\n   * Reads a foreach loop\n   * ```ebnf\n   * foreach ::= '(' expr T_AS foreach_variable (T_DOUBLE_ARROW foreach_variable)? ')' statement\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L438\n   * @return {Foreach}\n   */\n  read_foreach: function read_foreach() {\n    var result = this.node(\"foreach\");\n    this.expect(this.tok.T_FOREACH) && this.next();\n    var source = null;\n    var key = null;\n    var value = null;\n    var body = null;\n    var shortForm = false;\n    if (this.expect(\"(\")) this.next();\n    source = this.read_expr();\n\n    if (this.expect(this.tok.T_AS)) {\n      this.next();\n      value = this.read_foreach_variable();\n\n      if (this.token === this.tok.T_DOUBLE_ARROW) {\n        key = value;\n        value = this.next().read_foreach_variable();\n      }\n    } // grammatically correct but not supported by PHP\n\n\n    if (key && key.kind === \"list\") {\n      this.raiseError(\"Fatal Error : Cannot use list as key element\");\n    }\n\n    if (this.expect(\")\")) this.next();\n\n    if (this.token === \":\") {\n      shortForm = true;\n      body = this.read_short_form(this.tok.T_ENDFOREACH);\n    } else {\n      body = this.read_statement();\n    }\n\n    return result(source, key, value, body, shortForm);\n  },\n\n  /**\n   * Reads a foreach variable statement\n   * ```ebnf\n   * foreach_variable =\n   *    variable |\n   *    '&' variable |\n   *    T_LIST '(' assignment_list ')' |\n   *    '[' assignment_list ']'\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L544\n   * @return {Expression}\n   */\n  read_foreach_variable: function read_foreach_variable() {\n    if (this.token === this.tok.T_LIST || this.token === \"[\") {\n      var isShort = this.token === \"[\";\n      var result = this.node(\"list\");\n      this.next();\n      if (!isShort && this.expect(\"(\")) this.next();\n      var assignList = this.read_array_pair_list(isShort);\n      if (this.expect(isShort ? \"]\" : \")\")) this.next();\n      return result(assignList, isShort);\n    } else {\n      return this.read_variable(false, false);\n    }\n  }\n};\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * ```ebnf\n   * start ::= (namespace | top_statement)*\n   * ```\n   */\n  read_start: function read_start() {\n    if (this.token == this.tok.T_NAMESPACE) {\n      return this.read_namespace();\n    } else {\n      return this.read_top_statement();\n    }\n  }\n};\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a namespace declaration block\n   * ```ebnf\n   * namespace ::= T_NAMESPACE namespace_name? '{'\n   *    top_statements\n   * '}'\n   * | T_NAMESPACE namespace_name ';' top_statements\n   * ```\n   * @see http://php.net/manual/en/language.namespaces.php\n   * @return {Namespace}\n   */\n  read_namespace: function read_namespace() {\n    var result = this.node(\"namespace\");\n    var body;\n    this.expect(this.tok.T_NAMESPACE) && this.next();\n    var name;\n\n    if (this.token == \"{\") {\n      name = {\n        name: [\"\"]\n      };\n    } else {\n      name = this.read_namespace_name();\n    }\n\n    this.currentNamespace = name;\n\n    if (this.token == \";\") {\n      this.currentNamespace = name;\n      body = this.next().read_top_statements();\n      this.expect(this.EOF);\n      return result(name.name, body, false);\n    } else if (this.token == \"{\") {\n      this.currentNamespace = name;\n      body = this.next().read_top_statements();\n      this.expect(\"}\") && this.next();\n\n      if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n        body.push(this.node(\"noop\")());\n      }\n\n      return result(name.name, body, true);\n    } else if (this.token === \"(\") {\n      // @fixme after merging #478\n      name.resolution = this.ast.reference.RELATIVE_NAME;\n      name.name = name.name.substring(1);\n      result.destroy();\n      return this.node(\"call\")(name, this.read_argument_list());\n    } else {\n      this.error([\"{\", \";\"]); // graceful mode :\n\n      this.currentNamespace = name;\n      body = this.read_top_statements();\n      this.expect(this.EOF);\n      return result(name, body, false);\n    }\n  },\n\n  /**\n   * Reads a namespace name\n   * ```ebnf\n   *  namespace_name ::= T_NS_SEPARATOR? (T_STRING T_NS_SEPARATOR)* T_STRING\n   * ```\n   * @see http://php.net/manual/en/language.namespaces.rules.php\n   * @return {Reference}\n   */\n  read_namespace_name: function read_namespace_name(resolveReference) {\n    var result = this.node();\n    var relative = false;\n\n    if (this.token === this.tok.T_NAMESPACE) {\n      this.next().expect(this.tok.T_NS_SEPARATOR) && this.next();\n      relative = true;\n    }\n\n    var names = this.read_list(this.tok.T_STRING, this.tok.T_NS_SEPARATOR, true);\n\n    if (!relative && names.length === 1 && (resolveReference || this.token !== \"(\")) {\n      if (names[0].toLowerCase() === \"parent\") {\n        return result(\"parentreference\", names[0]);\n      } else if (names[0].toLowerCase() === \"self\") {\n        return result(\"selfreference\", names[0]);\n      }\n    }\n\n    return result(\"name\", names, relative);\n  },\n\n  /**\n   * Reads a use statement\n   * ```ebnf\n   * use_statement ::= T_USE\n   *   use_type? use_declarations |\n   *   use_type use_statement '{' use_declarations '}' |\n   *   use_statement '{' use_declarations(=>typed) '}'\n   * ';'\n   * ```\n   * @see http://php.net/manual/en/language.namespaces.importing.php\n   * @return {UseGroup}\n   */\n  read_use_statement: function read_use_statement() {\n    var result = this.node(\"usegroup\");\n    var items = [];\n    var name = null;\n    this.expect(this.tok.T_USE) && this.next();\n    var type = this.read_use_type();\n    items.push(this.read_use_declaration(false));\n\n    if (this.token === \",\") {\n      items = items.concat(this.next().read_use_declarations(false));\n    } else if (this.token === \"{\") {\n      name = items[0].name;\n      items = this.next().read_use_declarations(type === null);\n      this.expect(\"}\") && this.next();\n    }\n\n    result = result(name, type, items);\n    this.expect(\";\") && this.next();\n    return result;\n  },\n\n  /**\n   *\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1045\n   */\n  read_class_name_reference: function read_class_name_reference() {\n    // resolved as the same\n    return this.read_variable(true, false);\n  },\n\n  /**\n   * Reads a use declaration\n   * ```ebnf\n   * use_declaration ::= use_type? namespace_name use_alias\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L380\n   * @return {UseItem}\n   */\n  read_use_declaration: function read_use_declaration(typed) {\n    var result = this.node(\"useitem\");\n    var type = null;\n    if (typed) type = this.read_use_type();\n    var name = this.read_namespace_name();\n    var alias = this.read_use_alias();\n    return result(name.name, alias, type);\n  },\n\n  /**\n   * Reads a list of use declarations\n   * ```ebnf\n   * use_declarations ::= use_declaration (',' use_declaration)*\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L380\n   * @return {UseItem[]}\n   */\n  read_use_declarations: function read_use_declarations(typed) {\n    var result = [this.read_use_declaration(typed)];\n\n    while (this.token === \",\") {\n      this.next();\n\n      if (typed) {\n        if (this.token !== this.tok.T_FUNCTION && this.token !== this.tok.T_CONST && this.token !== this.tok.T_STRING) {\n          break;\n        }\n      } else if (this.token !== this.tok.T_STRING && this.token !== this.tok.T_NS_SEPARATOR) {\n        break;\n      }\n\n      result.push(this.read_use_declaration(typed));\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a use statement\n   * ```ebnf\n   * use_alias ::= (T_AS T_STRING)?\n   * ```\n   * @return {String|null}\n   */\n  read_use_alias: function read_use_alias() {\n    var result = null;\n\n    if (this.token === this.tok.T_AS) {\n      if (this.next().expect(this.tok.T_STRING)) {\n        var aliasName = this.node(\"identifier\");\n        var name = this.text();\n        this.next();\n        result = aliasName(name);\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads the namespace type declaration\n   * ```ebnf\n   * use_type ::= (T_FUNCTION | T_CONST)?\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L335\n   * @return {String|null} Possible values : function, const\n   */\n  read_use_type: function read_use_type() {\n    if (this.token === this.tok.T_FUNCTION) {\n      this.next();\n      return this.ast.useitem.TYPE_FUNCTION;\n    } else if (this.token === this.tok.T_CONST) {\n      this.next();\n      return this.ast.useitem.TYPE_CONST;\n    }\n\n    return null;\n  }\n};\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar specialChar = {\n  \"\\\\\": \"\\\\\",\n  $: \"$\",\n  n: \"\\n\",\n  r: \"\\r\",\n  t: \"\\t\",\n  f: String.fromCharCode(12),\n  v: String.fromCharCode(11),\n  e: String.fromCharCode(27)\n};\nmodule.exports = {\n  /**\n   * Unescape special chars\n   */\n  resolve_special_chars: function resolve_special_chars(text, doubleQuote) {\n    if (!doubleQuote) {\n      // single quote fix\n      return text.replace(/\\\\\\\\/g, \"\\\\\").replace(/\\\\'/g, \"'\");\n    }\n\n    return text.replace(/\\\\\"/, '\"').replace(/\\\\([\\\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})/g, function ($match, p1, p2) {\n      if (specialChar[p1]) {\n        return specialChar[p1];\n      } else if (\"x\" === p1[0] || \"X\" === p1[0]) {\n        return String.fromCodePoint(parseInt(p1.substr(1), 16));\n      } else if (\"u\" === p1[0]) {\n        return String.fromCodePoint(parseInt(p2, 16));\n      } else {\n        return String.fromCodePoint(parseInt(p1, 8));\n      }\n    });\n  },\n\n  /**\n   * Remove all leading spaces each line for heredoc text if there is a indentation\n   * @param {string} text\n   * @param {number} indentation\n   * @param {boolean} indentation_uses_spaces\n   * @param {boolean} first_encaps_node if it is behind a variable, the first N spaces should not be removed\n   */\n  remove_heredoc_leading_whitespace_chars: function remove_heredoc_leading_whitespace_chars(text, indentation, indentation_uses_spaces, first_encaps_node) {\n    if (indentation === 0) {\n      return text;\n    }\n\n    this.check_heredoc_indentation_level(text, indentation, indentation_uses_spaces, first_encaps_node);\n    var matchedChar = indentation_uses_spaces ? \" \" : \"\\t\";\n    var removementRegExp = new RegExp(\"\\\\n\".concat(matchedChar, \"{\").concat(indentation, \"}\"), \"g\");\n    var removementFirstEncapsNodeRegExp = new RegExp(\"^\".concat(matchedChar, \"{\").concat(indentation, \"}\")); // Rough replace, need more check\n\n    if (first_encaps_node) {\n      // Remove text leading whitespace\n      text = text.replace(removementFirstEncapsNodeRegExp, \"\");\n    } // Remove leading whitespace after \\n\n\n\n    return text.replace(removementRegExp, \"\\n\");\n  },\n\n  /**\n   * Check indentation level of heredoc in text, if mismatch, raiseError\n   * @param {string} text\n   * @param {number} indentation\n   * @param {boolean} indentation_uses_spaces\n   * @param {boolean} first_encaps_node if it is behind a variable, the first N spaces should not be removed\n   */\n  check_heredoc_indentation_level: function check_heredoc_indentation_level(text, indentation, indentation_uses_spaces, first_encaps_node) {\n    var textSize = text.length;\n    var offset = 0;\n    var leadingWhitespaceCharCount = 0;\n    /**\n     * @var inCoutingState {boolean} reset to true after a new line\n     */\n\n    var inCoutingState = true;\n    var chToCheck = indentation_uses_spaces ? \" \" : \"\\t\";\n    var inCheckState = false;\n\n    if (!first_encaps_node) {\n      // start from first \\n\n      offset = text.indexOf(\"\\n\"); // if no \\n, just return\n\n      if (offset === -1) {\n        return;\n      }\n\n      offset++;\n    }\n\n    while (offset < textSize) {\n      if (inCoutingState) {\n        if (text[offset] === chToCheck) {\n          leadingWhitespaceCharCount++;\n        } else {\n          inCheckState = true;\n        }\n      } else {\n        inCoutingState = false;\n      }\n\n      if (text[offset] !== \"\\n\" && inCheckState && leadingWhitespaceCharCount < indentation) {\n        this.raiseError(\"Invalid body indentation level (expecting an indentation at least \".concat(indentation, \")\"));\n      } else {\n        inCheckState = false;\n      }\n\n      if (text[offset] === \"\\n\") {\n        // Reset counting state\n        inCoutingState = true;\n        leadingWhitespaceCharCount = 0;\n      }\n\n      offset++;\n    }\n  },\n\n  /**\n   * Reads dereferencable scalar\n   */\n  read_dereferencable_scalar: function read_dereferencable_scalar() {\n    var result = null;\n\n    switch (this.token) {\n      case this.tok.T_CONSTANT_ENCAPSED_STRING:\n        {\n          var value = this.node(\"string\");\n          var text = this.text();\n          var offset = 0;\n\n          if (text[0] === \"b\" || text[0] === \"B\") {\n            offset = 1;\n          }\n\n          var isDoubleQuote = text[offset] === '\"';\n          this.next();\n          var textValue = this.resolve_special_chars(text.substring(offset + 1, text.length - 1), isDoubleQuote);\n          value = value(isDoubleQuote, textValue, offset === 1, // unicode flag\n          text);\n\n          if (this.token === this.tok.T_DOUBLE_COLON) {\n            // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1151\n            result = this.read_static_getter(value);\n          } else {\n            // dirrect string\n            result = value;\n          }\n        }\n        break;\n\n      case this.tok.T_ARRAY:\n        // array parser\n        result = this.read_array();\n        break;\n\n      case \"[\":\n        // short array format\n        result = this.read_array();\n        break;\n    }\n\n    return result;\n  },\n\n  /**\n   * ```ebnf\n   *  scalar ::= T_MAGIC_CONST\n   *       | T_LNUMBER | T_DNUMBER\n   *       | T_START_HEREDOC T_ENCAPSED_AND_WHITESPACE? T_END_HEREDOC\n   *       | '\"' encaps_list '\"'\n   *       | T_START_HEREDOC encaps_list T_END_HEREDOC\n   *       | namespace_name (T_DOUBLE_COLON T_STRING)?\n   * ```\n   */\n  read_scalar: function read_scalar() {\n    if (this.is(\"T_MAGIC_CONST\")) {\n      return this.get_magic_constant();\n    } else {\n      var value, node;\n\n      switch (this.token) {\n        // NUMERIC\n        case this.tok.T_LNUMBER: // long\n\n        case this.tok.T_DNUMBER:\n          {\n            // double\n            var result = this.node(\"number\");\n            value = this.text();\n            this.next();\n            return result(value, null);\n          }\n\n        case this.tok.T_START_HEREDOC:\n          if (this.lexer.curCondition === \"ST_NOWDOC\") {\n            var start = this.lexer.yylloc.first_offset;\n            node = this.node(\"nowdoc\");\n            value = this.next().text(); // strip the last line return char\n\n            if (this.lexer.heredoc_label.indentation > 0) {\n              value = value.substring(0, value.length - this.lexer.heredoc_label.indentation);\n            }\n\n            var lastCh = value[value.length - 1];\n\n            if (lastCh === \"\\n\") {\n              if (value[value.length - 2] === \"\\r\") {\n                // windows style\n                value = value.substring(0, value.length - 2);\n              } else {\n                // linux style\n                value = value.substring(0, value.length - 1);\n              }\n            } else if (lastCh === \"\\r\") {\n              // mac style\n              value = value.substring(0, value.length - 1);\n            }\n\n            this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE) && this.next();\n            this.expect(this.tok.T_END_HEREDOC) && this.next();\n\n            var raw = this.lexer._input.substring(start, this.lexer.yylloc.first_offset);\n\n            node = node(this.remove_heredoc_leading_whitespace_chars(value, this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node), raw, this.lexer.heredoc_label.label);\n            return node;\n          } else {\n            return this.read_encapsed_string(this.tok.T_END_HEREDOC);\n          }\n\n        case '\"':\n          return this.read_encapsed_string('\"');\n\n        case 'b\"':\n        case 'B\"':\n          {\n            return this.read_encapsed_string('\"', true);\n          }\n        // TEXTS\n\n        case this.tok.T_CONSTANT_ENCAPSED_STRING:\n        case this.tok.T_ARRAY: // array parser\n\n        case \"[\":\n          // short array format\n          return this.read_dereferencable_scalar();\n\n        default:\n          {\n            var err = this.error(\"SCALAR\"); // graceful mode : ignore token & return error node\n\n            this.next();\n            return err;\n          }\n      }\n    }\n  },\n\n  /**\n   * Handles the dereferencing\n   */\n  read_dereferencable: function read_dereferencable(expr) {\n    var result, offset;\n    var node = this.node(\"offsetlookup\");\n\n    if (this.token === \"[\") {\n      offset = this.next().read_expr();\n      if (this.expect(\"]\")) this.next();\n      result = node(expr, offset);\n    } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {\n      offset = this.read_encapsed_string_item(false);\n      result = node(expr, offset);\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads and extracts an encapsed item\n   * ```ebnf\n   * encapsed_string_item ::= T_ENCAPSED_AND_WHITESPACE\n   *  | T_DOLLAR_OPEN_CURLY_BRACES expr '}'\n   *  | T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '}'\n   *  | T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '[' expr ']' '}'\n   *  | T_CURLY_OPEN variable '}'\n   *  | variable\n   *  | variable '[' expr ']'\n   *  | variable T_OBJECT_OPERATOR T_STRING\n   * ```\n   * @return {String|Variable|Expr|Lookup}\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1219\n   */\n  read_encapsed_string_item: function read_encapsed_string_item(isDoubleQuote) {\n    var encapsedPart = this.node(\"encapsedpart\");\n    var syntax = null;\n    var curly = false;\n    var result = this.node(),\n        offset,\n        node,\n        name; // plain text\n    // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1222\n\n    if (this.token === this.tok.T_ENCAPSED_AND_WHITESPACE) {\n      var text = this.text();\n      this.next(); // if this.lexer.heredoc_label.first_encaps_node -> remove first indents\n\n      result = result(\"string\", false, this.version >= 703 && !this.lexer.heredoc_label.finished ? this.remove_heredoc_leading_whitespace_chars(this.resolve_special_chars(text, isDoubleQuote), this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node) : text, false, text);\n    } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {\n      syntax = \"simple\";\n      curly = true; // dynamic variable name\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1239\n\n      name = null;\n\n      if (this.next().token === this.tok.T_STRING_VARNAME) {\n        name = this.node(\"variable\");\n        var varName = this.text();\n        this.next(); // check if lookup an offset\n        // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1243\n\n        if (this.token === \"[\") {\n          name = name(varName, false);\n          node = this.node(\"offsetlookup\");\n          offset = this.next().read_expr();\n          this.expect(\"]\") && this.next();\n          result = node(name, offset);\n        } else {\n          result = name(varName, false);\n        }\n      } else {\n        result = result(\"variable\", this.read_expr(), false);\n      }\n\n      this.expect(\"}\") && this.next();\n    } else if (this.token === this.tok.T_CURLY_OPEN) {\n      // expression\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1246\n      syntax = \"complex\";\n      result.destroy();\n      result = this.next().read_variable(false, false);\n      this.expect(\"}\") && this.next();\n    } else if (this.token === this.tok.T_VARIABLE) {\n      syntax = \"simple\"; // plain variable\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1231\n\n      result.destroy();\n      result = this.read_simple_variable(); // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1233\n\n      if (this.token === \"[\") {\n        node = this.node(\"offsetlookup\");\n        offset = this.next().read_encaps_var_offset();\n        this.expect(\"]\") && this.next();\n        result = node(result, offset);\n      } // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L1236\n\n\n      if (this.token === this.tok.T_OBJECT_OPERATOR) {\n        node = this.node(\"propertylookup\");\n        this.next().expect(this.tok.T_STRING);\n        var what = this.node(\"identifier\");\n        name = this.text();\n        this.next();\n        result = node(result, what(name));\n      } // error / fallback\n\n    } else {\n      this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE);\n      var value = this.text();\n      this.next(); // consider it as string\n\n      result.destroy();\n      result = result(\"string\", false, value, false, value);\n    } // reset first_encaps_node to false after access any node\n\n\n    this.lexer.heredoc_label.first_encaps_node = false;\n    return encapsedPart(result, syntax, curly);\n  },\n\n  /**\n   * Reads an encapsed string\n   */\n  read_encapsed_string: function read_encapsed_string(expect) {\n    var isBinary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var labelStart = this.lexer.yylloc.first_offset;\n    var node = this.node(\"encapsed\");\n    this.next();\n    var start = this.lexer.yylloc.prev_offset - (isBinary ? 1 : 0);\n    var value = [];\n    var type = null;\n\n    if (expect === \"`\") {\n      type = this.ast.encapsed.TYPE_SHELL;\n    } else if (expect === '\"') {\n      type = this.ast.encapsed.TYPE_STRING;\n    } else {\n      type = this.ast.encapsed.TYPE_HEREDOC;\n    } // reading encapsed parts\n\n\n    while (this.token !== expect && this.token !== this.EOF) {\n      value.push(this.read_encapsed_string_item(true));\n    }\n\n    if (value.length > 0 && value[value.length - 1].kind === \"encapsedpart\" && value[value.length - 1].expression.kind === \"string\") {\n      var _node = value[value.length - 1].expression;\n      var lastCh = _node.value[_node.value.length - 1];\n\n      if (lastCh === \"\\n\") {\n        if (_node.value[_node.value.length - 2] === \"\\r\") {\n          // windows style\n          _node.value = _node.value.substring(0, _node.value.length - 2);\n        } else {\n          // linux style\n          _node.value = _node.value.substring(0, _node.value.length - 1);\n        }\n      } else if (lastCh === \"\\r\") {\n        // mac style\n        _node.value = _node.value.substring(0, _node.value.length - 1);\n      }\n    }\n\n    this.expect(expect) && this.next();\n\n    var raw = this.lexer._input.substring(type === \"heredoc\" ? labelStart : start - 1, this.lexer.yylloc.first_offset);\n\n    node = node(value, raw, type);\n\n    if (expect === this.tok.T_END_HEREDOC) {\n      node.label = this.lexer.heredoc_label.label;\n      this.lexer.heredoc_label.finished = true;\n    }\n\n    return node;\n  },\n\n  /**\n   * Constant token\n   */\n  get_magic_constant: function get_magic_constant() {\n    var result = this.node(\"magic\");\n    var name = this.text();\n    this.next();\n    return result(name.toUpperCase(), name);\n  }\n};\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * reading a list of top statements (helper for top_statement*)\n   * ```ebnf\n   *  top_statements ::= top_statement*\n   * ```\n   */\n  read_top_statements: function read_top_statements() {\n    var result = [];\n\n    while (this.token !== this.EOF && this.token !== \"}\") {\n      var statement = this.read_top_statement();\n\n      if (statement) {\n        if (Array.isArray(statement)) {\n          result = result.concat(statement);\n        } else {\n          result.push(statement);\n        }\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * reading a top statement\n   * ```ebnf\n   *  top_statement ::=\n   *       namespace | function | class\n   *       | interface | trait\n   *       | use_statements | const_list\n   *       | statement\n   * ```\n   */\n  read_top_statement: function read_top_statement() {\n    switch (this.token) {\n      case this.tok.T_FUNCTION:\n        return this.read_function(false, false);\n      // optional flags\n\n      case this.tok.T_ABSTRACT:\n      case this.tok.T_FINAL:\n      case this.tok.T_CLASS:\n        return this.read_class_declaration_statement();\n\n      case this.tok.T_INTERFACE:\n        return this.read_interface_declaration_statement();\n\n      case this.tok.T_TRAIT:\n        return this.read_trait_declaration_statement();\n\n      case this.tok.T_USE:\n        return this.read_use_statement();\n\n      case this.tok.T_CONST:\n        {\n          var result = this.node(\"constantstatement\");\n          var items = this.next().read_const_list();\n          this.expectEndOfStatement();\n          return result(null, items);\n        }\n\n      case this.tok.T_NAMESPACE:\n        return this.read_namespace();\n\n      case this.tok.T_HALT_COMPILER:\n        {\n          var _result = this.node(\"halt\");\n\n          if (this.next().expect(\"(\")) this.next();\n          if (this.expect(\")\")) this.next();\n          this.expect(\";\");\n          this.lexer.done = true;\n          return _result(this.lexer._input.substring(this.lexer.offset));\n        }\n\n      default:\n        return this.read_statement();\n    }\n  },\n\n  /**\n   * reads a list of simple inner statements (helper for inner_statement*)\n   * ```ebnf\n   *  inner_statements ::= inner_statement*\n   * ```\n   */\n  read_inner_statements: function read_inner_statements() {\n    var result = [];\n\n    while (this.token != this.EOF && this.token !== \"}\") {\n      var statement = this.read_inner_statement();\n\n      if (statement) {\n        if (Array.isArray(statement)) {\n          result = result.concat(statement);\n        } else {\n          result.push(statement);\n        }\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a list of constants declaration\n   * ```ebnf\n   *   const_list ::= T_CONST T_STRING '=' expr (',' T_STRING '=' expr)* ';'\n   * ```\n   */\n  read_const_list: function read_const_list() {\n    return this.read_list(function () {\n      this.expect(this.tok.T_STRING);\n      var result = this.node(\"constant\");\n      var constName = this.node(\"identifier\");\n      var name = this.text();\n      this.next();\n      constName = constName(name);\n\n      if (this.expect(\"=\")) {\n        return result(constName, this.next().read_expr());\n      } else {\n        // fallback\n        return result(constName, null);\n      }\n    }, \",\", false);\n  },\n\n  /**\n   * Reads a list of constants declaration\n   * ```ebnf\n   *   declare_list ::= IDENTIFIER '=' expr (',' IDENTIFIER '=' expr)*\n   * ```\n   * @retrurn {Array}\n   */\n  read_declare_list: function read_declare_list() {\n    var result = [];\n\n    while (this.token != this.EOF && this.token !== \")\") {\n      this.expect(this.tok.T_STRING);\n      var directive = this.node(\"declaredirective\");\n      var key = this.node(\"identifier\");\n      var name = this.text();\n      this.next();\n      key = key(name);\n      var value = null;\n\n      if (this.expect(\"=\")) {\n        value = this.next().read_expr();\n      }\n\n      result.push(directive(key, value));\n      if (this.token !== \",\") break;\n      this.next();\n    }\n\n    return result;\n  },\n\n  /**\n   * reads a simple inner statement\n   * ```ebnf\n   *  inner_statement ::= '{' inner_statements '}' | token\n   * ```\n   */\n  read_inner_statement: function read_inner_statement() {\n    switch (this.token) {\n      case this.tok.T_FUNCTION:\n        return this.read_function(false, false);\n      // optional flags\n\n      case this.tok.T_ABSTRACT:\n      case this.tok.T_FINAL:\n      case this.tok.T_CLASS:\n        return this.read_class_declaration_statement();\n\n      case this.tok.T_INTERFACE:\n        return this.read_interface_declaration_statement();\n\n      case this.tok.T_TRAIT:\n        return this.read_trait_declaration_statement();\n\n      case this.tok.T_HALT_COMPILER:\n        {\n          this.raiseError(\"__HALT_COMPILER() can only be used from the outermost scope\"); // fallback : returns a node but does not stop the parsing\n\n          var node = this.node(\"halt\");\n          this.next().expect(\"(\") && this.next();\n          this.expect(\")\") && this.next();\n          node = node(this.lexer._input.substring(this.lexer.offset));\n          this.expect(\";\") && this.next();\n          return node;\n        }\n\n      default:\n        return this.read_statement();\n    }\n  },\n\n  /**\n   * Reads statements\n   */\n  read_statement: function read_statement() {\n    switch (this.token) {\n      case \"{\":\n        return this.read_code_block(false);\n\n      case this.tok.T_IF:\n        return this.read_if();\n\n      case this.tok.T_SWITCH:\n        return this.read_switch();\n\n      case this.tok.T_FOR:\n        return this.read_for();\n\n      case this.tok.T_FOREACH:\n        return this.read_foreach();\n\n      case this.tok.T_WHILE:\n        return this.read_while();\n\n      case this.tok.T_DO:\n        return this.read_do();\n\n      case this.tok.T_COMMENT:\n        return this.read_comment();\n\n      case this.tok.T_DOC_COMMENT:\n        return this.read_doc_comment();\n\n      case this.tok.T_RETURN:\n        {\n          var result = this.node(\"return\");\n          this.next();\n          var expr = this.read_optional_expr(\";\");\n          this.expectEndOfStatement();\n          return result(expr);\n        }\n      // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L429\n\n      case this.tok.T_BREAK:\n      case this.tok.T_CONTINUE:\n        {\n          var _result2 = this.node(this.token === this.tok.T_CONTINUE ? \"continue\" : \"break\");\n\n          this.next();\n          var level = this.read_optional_expr(\";\");\n          this.expectEndOfStatement();\n          return _result2(level);\n        }\n\n      case this.tok.T_GLOBAL:\n        {\n          var _result3 = this.node(\"global\");\n\n          var items = this.next().read_list(this.read_simple_variable, \",\");\n          this.expectEndOfStatement();\n          return _result3(items);\n        }\n\n      case this.tok.T_STATIC:\n        {\n          var current = [this.token, this.lexer.getState()];\n\n          var _result4 = this.node();\n\n          if (this.next().token === this.tok.T_DOUBLE_COLON) {\n            // static keyword for a class\n            this.lexer.tokens.push(current);\n\n            var _expr = this.next().read_expr();\n\n            this.expectEndOfStatement(_expr);\n            return _result4(\"expressionstatement\", _expr);\n          }\n\n          if (this.token === this.tok.T_FUNCTION) {\n            return this.read_function(true, [0, 1, 0]);\n          }\n\n          var _items = this.read_variable_declarations();\n\n          this.expectEndOfStatement();\n          return _result4(\"static\", _items);\n        }\n\n      case this.tok.T_ECHO:\n        {\n          var _result5 = this.node(\"echo\");\n\n          var text = this.text();\n          var shortForm = text === \"<?=\" || text === \"<%=\";\n          var expressions = this.next().read_function_list(this.read_expr, \",\");\n          this.expectEndOfStatement();\n          return _result5(expressions, shortForm);\n        }\n\n      case this.tok.T_INLINE_HTML:\n        {\n          var value = this.text();\n          var prevChar = this.lexer.yylloc.first_offset > 0 ? this.lexer._input[this.lexer.yylloc.first_offset - 1] : null;\n          var fixFirstLine = prevChar === \"\\r\" || prevChar === \"\\n\"; // revert back the first stripped line\n\n          if (fixFirstLine) {\n            if (prevChar === \"\\n\" && this.lexer.yylloc.first_offset > 1 && this.lexer._input[this.lexer.yylloc.first_offset - 2] === \"\\r\") {\n              prevChar = \"\\r\\n\";\n            }\n          }\n\n          var _result6 = this.node(\"inline\");\n\n          this.next();\n          return _result6(value, fixFirstLine ? prevChar + value : value);\n        }\n\n      case this.tok.T_UNSET:\n        {\n          var _result7 = this.node(\"unset\");\n\n          this.next().expect(\"(\") && this.next();\n          var variables = this.read_function_list(this.read_variable, \",\");\n          this.expect(\")\") && this.next();\n          this.expect(\";\") && this.next();\n          return _result7(variables);\n        }\n\n      case this.tok.T_DECLARE:\n        {\n          var _result8 = this.node(\"declare\");\n\n          var body = [];\n          var mode;\n          this.next().expect(\"(\") && this.next();\n          var directives = this.read_declare_list();\n          this.expect(\")\") && this.next();\n\n          if (this.token === \":\") {\n            this.next();\n\n            while (this.token != this.EOF && this.token !== this.tok.T_ENDDECLARE) {\n              // @todo : check declare_statement from php / not valid\n              body.push(this.read_top_statement());\n            }\n\n            if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n              body.push(this.node(\"noop\")());\n            }\n\n            this.expect(this.tok.T_ENDDECLARE) && this.next();\n            this.expectEndOfStatement();\n            mode = this.ast.declare.MODE_SHORT;\n          } else if (this.token === \"{\") {\n            this.next();\n\n            while (this.token != this.EOF && this.token !== \"}\") {\n              // @todo : check declare_statement from php / not valid\n              body.push(this.read_top_statement());\n            }\n\n            if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n              body.push(this.node(\"noop\")());\n            }\n\n            this.expect(\"}\") && this.next();\n            mode = this.ast.declare.MODE_BLOCK;\n          } else {\n            this.expect(\";\") && this.next();\n            mode = this.ast.declare.MODE_NONE;\n          }\n\n          return _result8(directives, body, mode);\n        }\n\n      case this.tok.T_TRY:\n        return this.read_try();\n\n      case this.tok.T_THROW:\n        {\n          var _result9 = this.node(\"throw\");\n\n          var _expr2 = this.next().read_expr();\n\n          this.expectEndOfStatement();\n          return _result9(_expr2);\n        }\n      // ignore this (extra ponctuation)\n\n      case \";\":\n        {\n          this.next();\n          return null;\n        }\n\n      case this.tok.T_STRING:\n        {\n          var _result10 = this.node();\n\n          var _current = [this.token, this.lexer.getState()];\n          var labelNameText = this.text();\n          var labelName = this.node(\"identifier\"); // AST : https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L457\n\n          if (this.next().token === \":\") {\n            labelName = labelName(labelNameText);\n            this.next();\n            return _result10(\"label\", labelName);\n          } else {\n            labelName.destroy();\n          } // default fallback expr / T_STRING '::' (etc...)\n\n\n          _result10.destroy();\n\n          this.lexer.tokens.push(_current);\n          var statement = this.node(\"expressionstatement\");\n\n          var _expr3 = this.next().read_expr();\n\n          this.expectEndOfStatement(_expr3);\n          return statement(_expr3);\n        }\n\n      case this.tok.T_GOTO:\n        {\n          var _result11 = this.node(\"goto\");\n\n          var _labelName = null;\n\n          if (this.next().expect(this.tok.T_STRING)) {\n            _labelName = this.node(\"identifier\");\n            var name = this.text();\n            this.next();\n            _labelName = _labelName(name);\n            this.expectEndOfStatement();\n          }\n\n          return _result11(_labelName);\n        }\n\n      default:\n        {\n          // default fallback expr\n          var _statement = this.node(\"expressionstatement\");\n\n          var _expr4 = this.read_expr();\n\n          this.expectEndOfStatement(_expr4);\n          return _statement(_expr4);\n        }\n    }\n  },\n\n  /**\n   * ```ebnf\n   *  code_block ::= '{' (inner_statements | top_statements) '}'\n   * ```\n   */\n  read_code_block: function read_code_block(top) {\n    var result = this.node(\"block\");\n    this.expect(\"{\") && this.next();\n    var body = top ? this.read_top_statements() : this.read_inner_statements();\n\n    if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n      body.push(this.node(\"noop\")());\n    }\n\n    this.expect(\"}\") && this.next();\n    return result(null, body);\n  }\n};\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a switch statement\n   * ```ebnf\n   *  switch ::= T_SWITCH '(' expr ')' switch_case_list\n   * ```\n   * @return {Switch}\n   * @see http://php.net/manual/en/control-structures.switch.php\n   */\n  read_switch: function read_switch() {\n    var result = this.node(\"switch\");\n    this.expect(this.tok.T_SWITCH) && this.next();\n    this.expect(\"(\") && this.next();\n    var test = this.read_expr();\n    this.expect(\")\") && this.next();\n    var shortForm = this.token === \":\";\n    var body = this.read_switch_case_list();\n    return result(test, body, shortForm);\n  },\n\n  /**\n   * ```ebnf\n   *  switch_case_list ::= '{' ';'? case_list* '}' | ':' ';'? case_list* T_ENDSWITCH ';'\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L566\n   */\n  read_switch_case_list: function read_switch_case_list() {\n    // DETECT SWITCH MODE\n    var expect = null;\n    var result = this.node(\"block\");\n    var items = [];\n\n    if (this.token === \"{\") {\n      expect = \"}\";\n    } else if (this.token === \":\") {\n      expect = this.tok.T_ENDSWITCH;\n    } else {\n      this.expect([\"{\", \":\"]);\n    }\n\n    this.next(); // OPTIONNAL ';'\n    // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L570\n\n    if (this.token === \";\") {\n      this.next();\n    } // EXTRACTING CASES\n\n\n    while (this.token !== this.EOF && this.token !== expect) {\n      items.push(this.read_case_list(expect));\n    }\n\n    if (items.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n      items.push(this.node(\"noop\")());\n    } // CHECK END TOKEN\n\n\n    this.expect(expect) && this.next();\n\n    if (expect === this.tok.T_ENDSWITCH) {\n      this.expectEndOfStatement();\n    }\n\n    return result(null, items);\n  },\n\n  /**\n   * ```ebnf\n   *   case_list ::= ((T_CASE expr) | T_DEFAULT) (':' | ';') inner_statement*\n   * ```\n   */\n  read_case_list: function read_case_list(stopToken) {\n    var result = this.node(\"case\");\n    var test = null;\n\n    if (this.token === this.tok.T_CASE) {\n      test = this.next().read_expr();\n    } else if (this.token === this.tok.T_DEFAULT) {\n      // the default entry - no condition\n      this.next();\n    } else {\n      this.expect([this.tok.T_CASE, this.tok.T_DEFAULT]);\n    } // case_separator\n\n\n    this.expect([\":\", \";\"]) && this.next();\n    var body = this.node(\"block\");\n    var items = [];\n\n    while (this.token !== this.EOF && this.token !== stopToken && this.token !== this.tok.T_CASE && this.token !== this.tok.T_DEFAULT) {\n      items.push(this.read_inner_statement());\n    }\n\n    return result(test, body(null, items));\n  }\n};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * ```ebnf\n   *  try ::= T_TRY '{' inner_statement* '}'\n   *          (\n   *              T_CATCH '(' namespace_name variable ')' '{'  inner_statement* '}'\n   *          )*\n   *          (T_FINALLY '{' inner_statement* '}')?\n   * ```\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L448\n   * @return {Try}\n   */\n  read_try: function read_try() {\n    this.expect(this.tok.T_TRY);\n    var result = this.node(\"try\");\n    var always = null;\n    var catches = [];\n    var body = this.next().read_statement(); // https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L455\n\n    while (this.token === this.tok.T_CATCH) {\n      var item = this.node(\"catch\");\n      this.next().expect(\"(\") && this.next();\n      var what = this.read_list(this.read_namespace_name, \"|\", false);\n      var variable = this.read_variable(true, false);\n      this.expect(\")\");\n      catches.push(item(this.next().read_statement(), what, variable));\n    }\n\n    if (this.token === this.tok.T_FINALLY) {\n      always = this.next().read_statement();\n    }\n\n    return result(body, catches, always);\n  }\n};\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a short form of tokens\n   * @param {Number} token - The ending token\n   * @return {Block}\n   */\n  read_short_form: function read_short_form(token) {\n    var body = this.node(\"block\");\n    var items = [];\n    if (this.expect(\":\")) this.next();\n\n    while (this.token != this.EOF && this.token !== token) {\n      items.push(this.read_inner_statement());\n    }\n\n    if (items.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {\n      items.push(this.node(\"noop\")());\n    }\n\n    if (this.expect(token)) this.next();\n    this.expectEndOfStatement();\n    return body(null, items);\n  },\n\n  /**\n   * https://wiki.php.net/rfc/trailing-comma-function-calls\n   * @param {*} item\n   * @param {*} separator\n   */\n  read_function_list: function read_function_list(item, separator) {\n    var result = [];\n\n    do {\n      if (this.token == separator && this.version >= 703 && result.length > 0) {\n        result.push(this.node(\"noop\")());\n        break;\n      }\n\n      result.push(item.apply(this, []));\n\n      if (this.token != separator) {\n        break;\n      }\n\n      if (this.next().token == \")\" && this.version >= 703) {\n        break;\n      }\n    } while (this.token != this.EOF);\n\n    return result;\n  },\n\n  /**\n   * Helper : reads a list of tokens / sample : T_STRING ',' T_STRING ...\n   * ```ebnf\n   * list ::= separator? ( item separator )* item\n   * ```\n   */\n  read_list: function read_list(item, separator, preserveFirstSeparator) {\n    var result = [];\n\n    if (this.token == separator) {\n      if (preserveFirstSeparator) {\n        result.push(typeof item === \"function\" ? this.node(\"noop\")() : null);\n      }\n\n      this.next();\n    }\n\n    if (typeof item === \"function\") {\n      do {\n        var itemResult = item.apply(this, []);\n\n        if (itemResult) {\n          result.push(itemResult);\n        }\n\n        if (this.token != separator) {\n          break;\n        }\n      } while (this.next().token != this.EOF);\n    } else {\n      if (this.expect(item)) {\n        result.push(this.text());\n      } else {\n        return [];\n      }\n\n      while (this.next().token != this.EOF) {\n        if (this.token != separator) break; // trim current separator & check item\n\n        if (this.next().token != item) break;\n        result.push(this.text());\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a list of names separated by a comma\n   *\n   * ```ebnf\n   * name_list ::= namespace (',' namespace)*\n   * ```\n   *\n   * Sample code :\n   * ```php\n   * <?php class foo extends bar, baz { }\n   * ```\n   *\n   * @see https://github.com/php/php-src/blob/master/Zend/zend_language_parser.y#L726\n   * @return {Reference[]}\n   */\n  read_name_list: function read_name_list() {\n    return this.read_list(this.read_namespace_name, \",\", false);\n  },\n\n  /**\n   * Reads the byref token and assign it to the specified node\n   * @param {*} cb\n   */\n  read_byref: function read_byref(cb) {\n    var byref = this.node(\"byref\");\n    this.next();\n    byref = byref(null);\n    var result = cb();\n\n    if (result) {\n      this.ast.swapLocations(result, byref, result, this);\n      result.byref = true;\n    }\n\n    return result;\n  },\n\n  /**\n   * Reads a list of variables declarations\n   *\n   * ```ebnf\n   * variable_declaration ::= T_VARIABLE ('=' expr)?*\n   * variable_declarations ::= variable_declaration (',' variable_declaration)*\n   * ```\n   *\n   * Sample code :\n   * ```php\n   * <?php static $a = 'hello', $b = 'world';\n   * ```\n   * @return {StaticVariable[]} Returns an array composed by a list of variables, or\n   * assign values\n   */\n  read_variable_declarations: function read_variable_declarations() {\n    return this.read_list(function () {\n      var node = this.node(\"staticvariable\");\n      var variable = this.node(\"variable\"); // plain variable name\n\n      if (this.expect(this.tok.T_VARIABLE)) {\n        var name = this.text().substring(1);\n        this.next();\n        variable = variable(name, false);\n      } else {\n        variable = variable(\"#ERR\", false);\n      }\n\n      if (this.token === \"=\") {\n        return node(variable, this.next().read_expr());\n      } else {\n        return variable;\n      }\n    }, \",\");\n  },\n\n  /*\n   * Reads class extends\n   */\n  read_extends_from: function read_extends_from() {\n    if (this.token === this.tok.T_EXTENDS) {\n      return this.next().read_namespace_name();\n    }\n\n    return null;\n  },\n\n  /*\n   * Reads interface extends list\n   */\n  read_interface_extends_list: function read_interface_extends_list() {\n    if (this.token === this.tok.T_EXTENDS) {\n      return this.next().read_name_list();\n    }\n\n    return null;\n  },\n\n  /*\n   * Reads implements list\n   */\n  read_implements_list: function read_implements_list() {\n    if (this.token === this.tok.T_IMPLEMENTS) {\n      return this.next().read_name_list();\n    }\n\n    return null;\n  }\n};\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nmodule.exports = {\n  /**\n   * Reads a variable\n   *\n   * ```ebnf\n   *   variable ::= &? ...complex @todo\n   * ```\n   *\n   * Some samples of parsed code :\n   * ```php\n   *  &$var                      // simple var\n   *  $var                      // simple var\n   *  classname::CONST_NAME     // dynamic class name with const retrieval\n   *  foo()                     // function call\n   *  $var->func()->property    // chained calls\n   * ```\n   */\n  read_variable: function read_variable(read_only, encapsed) {\n    var result; // check the byref flag\n\n    if (this.token === \"&\") {\n      return this.read_byref(this.read_variable.bind(this, read_only, encapsed));\n    } // reads the entry point\n\n\n    if (this.is([this.tok.T_VARIABLE, \"$\"])) {\n      result = this.read_reference_variable(encapsed);\n    } else if (this.is([this.tok.T_NS_SEPARATOR, this.tok.T_STRING, this.tok.T_NAMESPACE])) {\n      result = this.node();\n      var name = this.read_namespace_name();\n\n      if (this.token != this.tok.T_DOUBLE_COLON && this.token != \"(\" && [\"parentreference\", \"selfreference\"].indexOf(name.kind) === -1) {\n        // @see parser.js line 130 : resolves a conflict with scalar\n        var literal = name.name.toLowerCase();\n\n        if (literal === \"true\") {\n          result = name.destroy(result(\"boolean\", true, name.name));\n        } else if (literal === \"false\") {\n          result = name.destroy(result(\"boolean\", false, name.name));\n        } else if (literal === \"null\") {\n          result = name.destroy(result(\"nullkeyword\", name.name));\n        } else {\n          result.destroy(name);\n          result = name;\n        }\n      } else {\n        // @fixme possible #193 bug\n        result.destroy(name);\n        result = name;\n      }\n    } else if (this.token === this.tok.T_STATIC) {\n      result = this.node(\"staticreference\");\n      var raw = this.text();\n      this.next();\n      result = result(raw);\n    } else {\n      this.expect(\"VARIABLE\");\n    } // static mode\n\n\n    if (this.token === this.tok.T_DOUBLE_COLON) {\n      result = this.read_static_getter(result, encapsed);\n    }\n\n    return this.recursive_variable_chain_scan(result, read_only, encapsed);\n  },\n  // resolves a static call\n  read_static_getter: function read_static_getter(what, encapsed) {\n    var result = this.node(\"staticlookup\");\n    var offset, name;\n\n    if (this.next().is([this.tok.T_VARIABLE, \"$\"])) {\n      offset = this.read_reference_variable(encapsed);\n    } else if (this.token === this.tok.T_STRING || this.token === this.tok.T_CLASS || this.version >= 700 && this.is(\"IDENTIFIER\")) {\n      offset = this.node(\"identifier\");\n      name = this.text();\n      this.next();\n      offset = offset(name);\n    } else if (this.token === \"{\") {\n      offset = this.node(\"literal\");\n      name = this.next().read_expr();\n      this.expect(\"}\") && this.next();\n      offset = offset(\"literal\", name, null);\n      this.expect(\"(\");\n    } else {\n      this.error([this.tok.T_VARIABLE, this.tok.T_STRING]); // graceful mode : set getter as error node and continue\n\n      offset = this.node(\"identifier\");\n      name = this.text();\n      this.next();\n      offset = offset(name);\n    }\n\n    return result(what, offset);\n  },\n  read_what: function read_what() {\n    var is_static_lookup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var what = null;\n    var name = null;\n\n    switch (this.next().token) {\n      case this.tok.T_STRING:\n        what = this.node(\"identifier\");\n        name = this.text();\n        this.next();\n        what = what(name);\n\n        if (is_static_lookup && this.token === this.tok.T_OBJECT_OPERATOR) {\n          this.error();\n        }\n\n        break;\n\n      case this.tok.T_VARIABLE:\n        what = this.node(\"variable\");\n        name = this.text().substring(1);\n        this.next();\n        what = what(name, false);\n        break;\n\n      case \"$\":\n        what = this.node();\n        this.next().expect([\"$\", \"{\", this.tok.T_VARIABLE]);\n\n        if (this.token === \"{\") {\n          // $obj->${$varname}\n          name = this.next().read_expr();\n          this.expect(\"}\") && this.next();\n          what = what(\"variable\", name, true);\n        } else {\n          // $obj->$$varname\n          name = this.read_expr();\n          what = what(\"variable\", name, false);\n        }\n\n        break;\n\n      case \"{\":\n        what = this.node(\"encapsedpart\");\n        name = this.next().read_expr();\n        this.expect(\"}\") && this.next();\n        what = what(name, \"complex\", false);\n        break;\n\n      default:\n        this.error([this.tok.T_STRING, this.tok.T_VARIABLE, \"$\", \"{\"]); // graceful mode : set what as error mode & continue\n\n        what = this.node(\"identifier\");\n        name = this.text();\n        this.next();\n        what = what(name);\n        break;\n    }\n\n    return what;\n  },\n  recursive_variable_chain_scan: function recursive_variable_chain_scan(result, read_only, encapsed) {\n    var node, offset;\n\n    recursive_scan_loop: while (this.token != this.EOF) {\n      switch (this.token) {\n        case \"(\":\n          if (read_only) {\n            // @fixme : add more informations & test\n            return result;\n          } else {\n            result = this.node(\"call\")(result, this.read_argument_list());\n          }\n\n          break;\n\n        case \"[\":\n        case \"{\":\n          {\n            var backet = this.token;\n            var isSquareBracket = backet === \"[\";\n            node = this.node(\"offsetlookup\");\n            this.next();\n            offset = false;\n\n            if (encapsed) {\n              offset = this.read_encaps_var_offset();\n              this.expect(isSquareBracket ? \"]\" : \"}\") && this.next();\n            } else {\n              var isCallableVariable = isSquareBracket ? this.token !== \"]\" : this.token !== \"}\"; // callable_variable : https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L1122\n\n              if (isCallableVariable) {\n                offset = this.read_expr();\n                this.expect(isSquareBracket ? \"]\" : \"}\") && this.next();\n              } else {\n                this.next();\n              }\n            }\n\n            result = node(result, offset);\n            break;\n          }\n\n        case this.tok.T_DOUBLE_COLON:\n          // @see https://github.com/glayzzle/php-parser/issues/107#issuecomment-354104574\n          if (result.kind === \"staticlookup\" && result.offset.kind === \"identifier\") {\n            this.error();\n          }\n\n          node = this.node(\"staticlookup\");\n          result = node(result, this.read_what(true)); // fix 185\n          // static lookup dereferencables are limited to staticlookup over functions\n\n          /*if (dereferencable && this.token !== \"(\") {\n            this.error(\"(\");\n          }*/\n\n          break;\n\n        case this.tok.T_OBJECT_OPERATOR:\n          {\n            node = this.node(\"propertylookup\");\n            result = node(result, this.read_what());\n            break;\n          }\n\n        default:\n          break recursive_scan_loop;\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * https://github.com/php/php-src/blob/493524454d66adde84e00d249d607ecd540de99f/Zend/zend_language_parser.y#L1231\n   */\n  read_encaps_var_offset: function read_encaps_var_offset() {\n    var offset = this.node();\n\n    if (this.token === this.tok.T_STRING) {\n      var text = this.text();\n      this.next();\n      offset = offset(\"identifier\", text);\n    } else if (this.token === this.tok.T_NUM_STRING) {\n      var num = this.text();\n      this.next();\n      offset = offset(\"number\", num, null);\n    } else if (this.token === \"-\") {\n      this.next();\n\n      var _num = -1 * this.text();\n\n      this.expect(this.tok.T_NUM_STRING) && this.next();\n      offset = offset(\"number\", _num, null);\n    } else if (this.token === this.tok.T_VARIABLE) {\n      var name = this.text().substring(1);\n      this.next();\n      offset = offset(\"variable\", name, false);\n    } else {\n      this.expect([this.tok.T_STRING, this.tok.T_NUM_STRING, \"-\", this.tok.T_VARIABLE]); // fallback : consider as identifier\n\n      var _text = this.text();\n\n      this.next();\n      offset = offset(\"identifier\", _text);\n    }\n\n    return offset;\n  },\n\n  /**\n   * ```ebnf\n   *  reference_variable ::=  simple_variable ('[' OFFSET ']')* | '{' EXPR '}'\n   * ```\n   * <code>\n   *  $foo[123];      // foo is an array ==> gets its entry\n   *  $foo{1};        // foo is a string ==> get the 2nd char offset\n   *  ${'foo'}[123];  // get the dynamic var $foo\n   *  $foo[123]{1};   // gets the 2nd char from the 123 array entry\n   * </code>\n   */\n  read_reference_variable: function read_reference_variable(encapsed) {\n    var result = this.read_simple_variable();\n    var offset;\n\n    while (this.token != this.EOF) {\n      var node = this.node();\n\n      if (this.token == \"{\" && !encapsed) {\n        // @fixme check coverage, not sure thats working\n        offset = this.next().read_expr();\n        this.expect(\"}\") && this.next();\n        result = node(\"offsetlookup\", result, offset);\n      } else {\n        node.destroy();\n        break;\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * ```ebnf\n   *  simple_variable ::= T_VARIABLE | '$' '{' expr '}' | '$' simple_variable\n   * ```\n   */\n  read_simple_variable: function read_simple_variable() {\n    var result = this.node(\"variable\");\n    var name;\n\n    if (this.expect([this.tok.T_VARIABLE, \"$\"]) && this.token === this.tok.T_VARIABLE) {\n      // plain variable name\n      name = this.text().substring(1);\n      this.next();\n      result = result(name, false);\n    } else {\n      if (this.token === \"$\") this.next(); // dynamic variable name\n\n      switch (this.token) {\n        case \"{\":\n          {\n            var expr = this.next().read_expr();\n            this.expect(\"}\") && this.next();\n            result = result(expr, true);\n            break;\n          }\n\n        case \"$\":\n          // $$$var\n          result = result(this.read_simple_variable(), false);\n          break;\n\n        case this.tok.T_VARIABLE:\n          {\n            // $$var\n            name = this.text().substring(1);\n            var node = this.node(\"variable\");\n            this.next();\n            result = result(node(name, false), false);\n            break;\n          }\n\n        default:\n          this.error([\"{\", \"$\", this.tok.T_VARIABLE]); // graceful mode\n\n          name = this.text();\n          this.next();\n          result = result(name, false);\n      }\n    }\n\n    return result;\n  }\n};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * PHP AST Tokens\n * @type {Object}\n */\n\nmodule.exports = {\n  values: {\n    101: \"T_HALT_COMPILER\",\n    102: \"T_USE\",\n    103: \"T_ENCAPSED_AND_WHITESPACE\",\n    104: \"T_OBJECT_OPERATOR\",\n    105: \"T_STRING\",\n    106: \"T_DOLLAR_OPEN_CURLY_BRACES\",\n    107: \"T_STRING_VARNAME\",\n    108: \"T_CURLY_OPEN\",\n    109: \"T_NUM_STRING\",\n    110: \"T_ISSET\",\n    111: \"T_EMPTY\",\n    112: \"T_INCLUDE\",\n    113: \"T_INCLUDE_ONCE\",\n    114: \"T_EVAL\",\n    115: \"T_REQUIRE\",\n    116: \"T_REQUIRE_ONCE\",\n    117: \"T_NAMESPACE\",\n    118: \"T_NS_SEPARATOR\",\n    119: \"T_AS\",\n    120: \"T_IF\",\n    121: \"T_ENDIF\",\n    122: \"T_WHILE\",\n    123: \"T_DO\",\n    124: \"T_FOR\",\n    125: \"T_SWITCH\",\n    126: \"T_BREAK\",\n    127: \"T_CONTINUE\",\n    128: \"T_RETURN\",\n    129: \"T_GLOBAL\",\n    130: \"T_STATIC\",\n    131: \"T_ECHO\",\n    132: \"T_INLINE_HTML\",\n    133: \"T_UNSET\",\n    134: \"T_FOREACH\",\n    135: \"T_DECLARE\",\n    136: \"T_TRY\",\n    137: \"T_THROW\",\n    138: \"T_GOTO\",\n    139: \"T_FINALLY\",\n    140: \"T_CATCH\",\n    141: \"T_ENDDECLARE\",\n    142: \"T_LIST\",\n    143: \"T_CLONE\",\n    144: \"T_PLUS_EQUAL\",\n    145: \"T_MINUS_EQUAL\",\n    146: \"T_MUL_EQUAL\",\n    147: \"T_DIV_EQUAL\",\n    148: \"T_CONCAT_EQUAL\",\n    149: \"T_MOD_EQUAL\",\n    150: \"T_AND_EQUAL\",\n    151: \"T_OR_EQUAL\",\n    152: \"T_XOR_EQUAL\",\n    153: \"T_SL_EQUAL\",\n    154: \"T_SR_EQUAL\",\n    155: \"T_INC\",\n    156: \"T_DEC\",\n    157: \"T_BOOLEAN_OR\",\n    158: \"T_BOOLEAN_AND\",\n    159: \"T_LOGICAL_OR\",\n    160: \"T_LOGICAL_AND\",\n    161: \"T_LOGICAL_XOR\",\n    162: \"T_SL\",\n    163: \"T_SR\",\n    164: \"T_IS_IDENTICAL\",\n    165: \"T_IS_NOT_IDENTICAL\",\n    166: \"T_IS_EQUAL\",\n    167: \"T_IS_NOT_EQUAL\",\n    168: \"T_IS_SMALLER_OR_EQUAL\",\n    169: \"T_IS_GREATER_OR_EQUAL\",\n    170: \"T_INSTANCEOF\",\n    171: \"T_INT_CAST\",\n    172: \"T_DOUBLE_CAST\",\n    173: \"T_STRING_CAST\",\n    174: \"T_ARRAY_CAST\",\n    175: \"T_OBJECT_CAST\",\n    176: \"T_BOOL_CAST\",\n    177: \"T_UNSET_CAST\",\n    178: \"T_EXIT\",\n    179: \"T_PRINT\",\n    180: \"T_YIELD\",\n    181: \"T_YIELD_FROM\",\n    182: \"T_FUNCTION\",\n    183: \"T_DOUBLE_ARROW\",\n    184: \"T_DOUBLE_COLON\",\n    185: \"T_ARRAY\",\n    186: \"T_CALLABLE\",\n    187: \"T_CLASS\",\n    188: \"T_ABSTRACT\",\n    189: \"T_TRAIT\",\n    190: \"T_FINAL\",\n    191: \"T_EXTENDS\",\n    192: \"T_INTERFACE\",\n    193: \"T_IMPLEMENTS\",\n    194: \"T_VAR\",\n    195: \"T_PUBLIC\",\n    196: \"T_PROTECTED\",\n    197: \"T_PRIVATE\",\n    198: \"T_CONST\",\n    199: \"T_NEW\",\n    200: \"T_INSTEADOF\",\n    201: \"T_ELSEIF\",\n    202: \"T_ELSE\",\n    203: \"T_ENDSWITCH\",\n    204: \"T_CASE\",\n    205: \"T_DEFAULT\",\n    206: \"T_ENDFOR\",\n    207: \"T_ENDFOREACH\",\n    208: \"T_ENDWHILE\",\n    209: \"T_CONSTANT_ENCAPSED_STRING\",\n    210: \"T_LNUMBER\",\n    211: \"T_DNUMBER\",\n    212: \"T_LINE\",\n    213: \"T_FILE\",\n    214: \"T_DIR\",\n    215: \"T_TRAIT_C\",\n    216: \"T_METHOD_C\",\n    217: \"T_FUNC_C\",\n    218: \"T_NS_C\",\n    219: \"T_START_HEREDOC\",\n    220: \"T_END_HEREDOC\",\n    221: \"T_CLASS_C\",\n    222: \"T_VARIABLE\",\n    223: \"T_OPEN_TAG\",\n    224: \"T_OPEN_TAG_WITH_ECHO\",\n    225: \"T_CLOSE_TAG\",\n    226: \"T_WHITESPACE\",\n    227: \"T_COMMENT\",\n    228: \"T_DOC_COMMENT\",\n    229: \"T_ELLIPSIS\",\n    230: \"T_COALESCE\",\n    231: \"T_POW\",\n    232: \"T_POW_EQUAL\",\n    233: \"T_SPACESHIP\",\n    234: \"T_COALESCE_EQUAL\",\n    235: \"T_FN\"\n  },\n  names: {\n    T_HALT_COMPILER: 101,\n    T_USE: 102,\n    T_ENCAPSED_AND_WHITESPACE: 103,\n    T_OBJECT_OPERATOR: 104,\n    T_STRING: 105,\n    T_DOLLAR_OPEN_CURLY_BRACES: 106,\n    T_STRING_VARNAME: 107,\n    T_CURLY_OPEN: 108,\n    T_NUM_STRING: 109,\n    T_ISSET: 110,\n    T_EMPTY: 111,\n    T_INCLUDE: 112,\n    T_INCLUDE_ONCE: 113,\n    T_EVAL: 114,\n    T_REQUIRE: 115,\n    T_REQUIRE_ONCE: 116,\n    T_NAMESPACE: 117,\n    T_NS_SEPARATOR: 118,\n    T_AS: 119,\n    T_IF: 120,\n    T_ENDIF: 121,\n    T_WHILE: 122,\n    T_DO: 123,\n    T_FOR: 124,\n    T_SWITCH: 125,\n    T_BREAK: 126,\n    T_CONTINUE: 127,\n    T_RETURN: 128,\n    T_GLOBAL: 129,\n    T_STATIC: 130,\n    T_ECHO: 131,\n    T_INLINE_HTML: 132,\n    T_UNSET: 133,\n    T_FOREACH: 134,\n    T_DECLARE: 135,\n    T_TRY: 136,\n    T_THROW: 137,\n    T_GOTO: 138,\n    T_FINALLY: 139,\n    T_CATCH: 140,\n    T_ENDDECLARE: 141,\n    T_LIST: 142,\n    T_CLONE: 143,\n    T_PLUS_EQUAL: 144,\n    T_MINUS_EQUAL: 145,\n    T_MUL_EQUAL: 146,\n    T_DIV_EQUAL: 147,\n    T_CONCAT_EQUAL: 148,\n    T_MOD_EQUAL: 149,\n    T_AND_EQUAL: 150,\n    T_OR_EQUAL: 151,\n    T_XOR_EQUAL: 152,\n    T_SL_EQUAL: 153,\n    T_SR_EQUAL: 154,\n    T_INC: 155,\n    T_DEC: 156,\n    T_BOOLEAN_OR: 157,\n    T_BOOLEAN_AND: 158,\n    T_LOGICAL_OR: 159,\n    T_LOGICAL_AND: 160,\n    T_LOGICAL_XOR: 161,\n    T_SL: 162,\n    T_SR: 163,\n    T_IS_IDENTICAL: 164,\n    T_IS_NOT_IDENTICAL: 165,\n    T_IS_EQUAL: 166,\n    T_IS_NOT_EQUAL: 167,\n    T_IS_SMALLER_OR_EQUAL: 168,\n    T_IS_GREATER_OR_EQUAL: 169,\n    T_INSTANCEOF: 170,\n    T_INT_CAST: 171,\n    T_DOUBLE_CAST: 172,\n    T_STRING_CAST: 173,\n    T_ARRAY_CAST: 174,\n    T_OBJECT_CAST: 175,\n    T_BOOL_CAST: 176,\n    T_UNSET_CAST: 177,\n    T_EXIT: 178,\n    T_PRINT: 179,\n    T_YIELD: 180,\n    T_YIELD_FROM: 181,\n    T_FUNCTION: 182,\n    T_DOUBLE_ARROW: 183,\n    T_DOUBLE_COLON: 184,\n    T_ARRAY: 185,\n    T_CALLABLE: 186,\n    T_CLASS: 187,\n    T_ABSTRACT: 188,\n    T_TRAIT: 189,\n    T_FINAL: 190,\n    T_EXTENDS: 191,\n    T_INTERFACE: 192,\n    T_IMPLEMENTS: 193,\n    T_VAR: 194,\n    T_PUBLIC: 195,\n    T_PROTECTED: 196,\n    T_PRIVATE: 197,\n    T_CONST: 198,\n    T_NEW: 199,\n    T_INSTEADOF: 200,\n    T_ELSEIF: 201,\n    T_ELSE: 202,\n    T_ENDSWITCH: 203,\n    T_CASE: 204,\n    T_DEFAULT: 205,\n    T_ENDFOR: 206,\n    T_ENDFOREACH: 207,\n    T_ENDWHILE: 208,\n    T_CONSTANT_ENCAPSED_STRING: 209,\n    T_LNUMBER: 210,\n    T_DNUMBER: 211,\n    T_LINE: 212,\n    T_FILE: 213,\n    T_DIR: 214,\n    T_TRAIT_C: 215,\n    T_METHOD_C: 216,\n    T_FUNC_C: 217,\n    T_NS_C: 218,\n    T_START_HEREDOC: 219,\n    T_END_HEREDOC: 220,\n    T_CLASS_C: 221,\n    T_VARIABLE: 222,\n    T_OPEN_TAG: 223,\n    T_OPEN_TAG_WITH_ECHO: 224,\n    T_CLOSE_TAG: 225,\n    T_WHITESPACE: 226,\n    T_COMMENT: 227,\n    T_DOC_COMMENT: 228,\n    T_ELLIPSIS: 229,\n    T_COALESCE: 230,\n    T_POW: 231,\n    T_POW_EQUAL: 232,\n    T_SPACESHIP: 233,\n    T_COALESCE_EQUAL: 234,\n    T_FN: 235\n  }\n};\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Location = __webpack_require__(41);\n\nvar Position = __webpack_require__(42);\n/**\n * ## Class hierarchy\n *\n * - [Location](#location)\n * - [Position](#position)\n * - [Node](#node)\n *   - [Noop](#noop)\n *   - [NullKeyword](#nullkeyword)\n *   - [StaticVariable](#staticvariable)\n *   - [EncapsedPart](#encapsedpart)\n *   - [Constant](#constant)\n *   - [Identifier](#identifier)\n *   - [Reference](#reference)\n *     - [TypeReference](#typereference)\n *     - [ParentReference](#parentreference)\n *     - [StaticReference](#staticreference)\n *     - [SelfReference](#selfreference)\n *     - [Name](#name)\n *   - [TraitUse](#traituse)\n *   - [TraitAlias](#traitalias)\n *   - [TraitPrecedence](#traitprecedence)\n *   - [Comment](#comment)\n *     - [CommentLine](#commentline)\n *     - [CommentBlock](#commentblock)\n *   - [Error](#error)\n *   - [Expression](#expression)\n *     - [Entry](#entry)\n *     - [ArrowFunc](#arrowfunc)\n *     - [Closure](#closure)\n *     - [ByRef](#byref)\n *     - [Silent](#silent)\n *     - [RetIf](#retif)\n *     - [New](#new)\n *     - [Include](#include)\n *     - [Call](#call)\n *     - [Eval](#eval)\n *     - [Exit](#exit)\n *     - [Clone](#clone)\n *     - [Assign](#assign)\n *     - [AssignRef](#assignref)\n *     - [Array](#array)\n *     - [List](#list)\n *     - [Variable](#variable)\n *     - [Variadic](#variadic)\n *     - [Yield](#yield)\n *     - [YieldFrom](#yieldfrom)\n *     - [Print](#print)\n *     - [Isset](#isset)\n *     - [Empty](#empty)\n *     - [Lookup](#lookup)\n *       - [PropertyLookup](#propertylookup)\n *       - [StaticLookup](#staticlookup)\n *       - [OffsetLookup](#offsetlookup)\n *     - [Operation](#operation)\n *       - [Pre](#pre)\n *       - [Post](#post)\n *       - [Bin](#bin)\n *       - [Unary](#unary)\n *       - [Cast](#cast)\n *     - [Literal](#literal)\n *       - [Boolean](#boolean)\n *       - [String](#string)\n *       - [Number](#number)\n *       - [Inline](#inline)\n *       - [Magic](#magic)\n *       - [Nowdoc](#nowdoc)\n *       - [Encapsed](#encapsed)\n *   - [Statement](#statement)\n *     - [ConstantStatement](#constantstatement)\n *       - [ClassConstant](#classconstant)\n *     - [Return](#return)\n *     - [Label](#label)\n *     - [Continue](#continue)\n *     - [Case](#case)\n *     - [Break](#break)\n *     - [Echo](#echo)\n *     - [Unset](#unset)\n *     - [Halt](#halt)\n *     - [Declare](#declare)\n *     - [Global](#global)\n *     - [Static](#static)\n *     - [If](#if)\n *     - [Do](#do)\n *     - [While](#while)\n *     - [For](#for)\n *     - [Foreach](#foreach)\n *     - [Switch](#switch)\n *     - [Goto](#goto)\n *     - [Try](#try)\n *     - [Catch](#catch)\n *     - [Throw](#throw)\n *     - [UseGroup](#usegroup)\n *     - [UseItem](#useitem)\n *     - [Block](#block)\n *       - [Program](#program)\n *       - [Namespace](#namespace)\n *     - [PropertyStatement](#propertystatement)\n *     - [Property](#property)\n *     - [Declaration](#declaration)\n *       - [Class](#class)\n *       - [Interface](#interface)\n *       - [Trait](#trait)\n *       - [Function](#function)\n *         - [Method](#method)\n *       - [Parameter](#parameter)\n * ---\n */\n\n/**\n * The AST builder class\n * @constructor AST\n * @tutorial AST\n * @property {Boolean} withPositions - Should locate any node (by default false)\n * @property {Boolean} withSource - Should extract the node original code (by default false)\n */\n\n\nvar AST = function AST(withPositions, withSource) {\n  this.withPositions = withPositions;\n  this.withSource = withSource;\n};\n/**\n * Create a position node from specified parser\n * including it's lexer current state\n * @param {Parser}\n * @return {Position}\n * @private\n */\n\n\nAST.prototype.position = function (parser) {\n  return new Position(parser.lexer.yylloc.first_line, parser.lexer.yylloc.first_column, parser.lexer.yylloc.first_offset);\n}; // operators in ascending order of precedence\n\n\nAST.precedence = {};\n[[\"or\"], [\"xor\"], [\"and\"], [\"=\"], [\"?\"], [\"??\"], [\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"!=\", \"===\", \"!==\",\n/* '<>', */\n\"<=>\"], [\"<\", \"<=\", \">\", \">=\"], [\"<<\", \">>\"], [\"+\", \"-\", \".\"], [\"*\", \"/\", \"%\"], [\"!\"], [\"instanceof\"], [\"cast\", \"silent\"], [\"**\"] // TODO: [ (array)\n// TODO: clone, new\n].forEach(function (list, index) {\n  list.forEach(function (operator) {\n    AST.precedence[operator] = index + 1;\n  });\n});\n\nAST.prototype.isRightAssociative = function (operator) {\n  return operator === \"**\" || operator === \"??\";\n};\n/**\n * Change parent node informations after swapping childs\n */\n\n\nAST.prototype.swapLocations = function (target, first, last, parser) {\n  if (this.withPositions) {\n    target.loc.start = first.loc.start;\n    target.loc.end = last.loc.end;\n\n    if (this.withSource) {\n      target.loc.source = parser.lexer._input.substring(target.loc.start.offset, target.loc.end.offset);\n    }\n  }\n};\n/**\n * Includes locations from first & last into the target\n */\n\n\nAST.prototype.resolveLocations = function (target, first, last, parser) {\n  if (this.withPositions) {\n    if (target.loc.start.offset > first.loc.start.offset) {\n      target.loc.start = first.loc.start;\n    }\n\n    if (target.loc.end.offset < last.loc.end.offset) {\n      target.loc.end = last.loc.end;\n    }\n\n    if (this.withSource) {\n      target.loc.source = parser.lexer._input.substring(target.loc.start.offset, target.loc.end.offset);\n    }\n  }\n};\n/**\n * Check and fix precence, by default using right\n */\n\n\nAST.prototype.resolvePrecedence = function (result, parser) {\n  var buffer, lLevel, rLevel; // handling precendence\n\n  if (result.kind === \"call\") {\n    // including what argument into location\n    this.resolveLocations(result, result.what, result, parser);\n  } else if (result.kind === \"propertylookup\" || result.kind === \"staticlookup\" || result.kind === \"offsetlookup\" && result.offset) {\n    // including what argument into location\n    this.resolveLocations(result, result.what, result.offset, parser);\n  } else if (result.kind === \"bin\") {\n    if (result.right && !result.right.parenthesizedExpression) {\n      if (result.right.kind === \"bin\") {\n        lLevel = AST.precedence[result.type];\n        rLevel = AST.precedence[result.right.type];\n\n        if (lLevel && rLevel && rLevel <= lLevel && !this.isRightAssociative(result.type)) {\n          // https://github.com/glayzzle/php-parser/issues/79\n          // shift precedence\n          buffer = result.right;\n          result.right = result.right.left;\n          this.swapLocations(result, result.left, result.right, parser);\n          buffer.left = this.resolvePrecedence(result, parser);\n          this.swapLocations(buffer, buffer.left, buffer.right, parser);\n          result = buffer;\n        }\n      } else if (result.right.kind === \"retif\") {\n        lLevel = AST.precedence[result.type];\n        rLevel = AST.precedence[\"?\"];\n\n        if (lLevel && rLevel && rLevel <= lLevel) {\n          buffer = result.right;\n          result.right = result.right.test;\n          this.swapLocations(result, result.left, result.right, parser);\n          buffer.test = this.resolvePrecedence(result, parser);\n          this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n          result = buffer;\n        }\n      }\n    }\n  } else if ((result.kind === \"silent\" || result.kind === \"cast\") && result.expr && !result.expr.parenthesizedExpression) {\n    // https://github.com/glayzzle/php-parser/issues/172\n    if (result.expr.kind === \"bin\") {\n      buffer = result.expr;\n      result.expr = result.expr.left;\n      this.swapLocations(result, result, result.expr, parser);\n      buffer.left = this.resolvePrecedence(result, parser);\n      this.swapLocations(buffer, buffer.left, buffer.right, parser);\n      result = buffer;\n    } else if (result.expr.kind === \"retif\") {\n      buffer = result.expr;\n      result.expr = result.expr.test;\n      this.swapLocations(result, result, result.expr, parser);\n      buffer.test = this.resolvePrecedence(result, parser);\n      this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n      result = buffer;\n    }\n  } else if (result.kind === \"unary\") {\n    // https://github.com/glayzzle/php-parser/issues/75\n    if (result.what && !result.what.parenthesizedExpression) {\n      // unary precedence is allways lower\n      if (result.what.kind === \"bin\") {\n        buffer = result.what;\n        result.what = result.what.left;\n        this.swapLocations(result, result, result.what, parser);\n        buffer.left = this.resolvePrecedence(result, parser);\n        this.swapLocations(buffer, buffer.left, buffer.right, parser);\n        result = buffer;\n      } else if (result.what.kind === \"retif\") {\n        buffer = result.what;\n        result.what = result.what.test;\n        this.swapLocations(result, result, result.what, parser);\n        buffer.test = this.resolvePrecedence(result, parser);\n        this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n        result = buffer;\n      }\n    }\n  } else if (result.kind === \"retif\") {\n    // https://github.com/glayzzle/php-parser/issues/77\n    if (result.falseExpr && result.falseExpr.kind === \"retif\" && !result.falseExpr.parenthesizedExpression) {\n      buffer = result.falseExpr;\n      result.falseExpr = buffer.test;\n      this.swapLocations(result, result.test, result.falseExpr, parser);\n      buffer.test = this.resolvePrecedence(result, parser);\n      this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);\n      result = buffer;\n    }\n  } else if (result.kind === \"assign\") {\n    // https://github.com/glayzzle/php-parser/issues/81\n    if (result.right && result.right.kind === \"bin\" && !result.right.parenthesizedExpression) {\n      lLevel = AST.precedence[\"=\"];\n      rLevel = AST.precedence[result.right.type]; // only shifts with and, xor, or\n\n      if (lLevel && rLevel && rLevel < lLevel) {\n        buffer = result.right;\n        result.right = result.right.left;\n        buffer.left = result;\n        this.swapLocations(buffer, buffer.left, result.right, parser);\n        result = buffer;\n      }\n    }\n  } else if (result.kind === \"expressionstatement\") {\n    this.swapLocations(result, result.expression, result, parser);\n  }\n\n  return result;\n};\n/**\n * Prepares an AST node\n * @param {String|null} kind - Defines the node type\n * (if null, the kind must be passed at the function call)\n * @param {Parser} parser - The parser instance (use for extracting locations)\n * @return {Function}\n */\n\n\nAST.prototype.prepare = function (kind, docs, parser) {\n  var start = null;\n\n  if (this.withPositions || this.withSource) {\n    start = this.position(parser);\n  }\n\n  var self = this; // returns the node\n\n  var result = function result() {\n    var location = null;\n    var args = Array.prototype.slice.call(arguments);\n    args.push(docs);\n\n    if (self.withPositions || self.withSource) {\n      var src = null;\n\n      if (self.withSource) {\n        src = parser.lexer._input.substring(start.offset, parser.prev[2]);\n      } // if with source, need location on swapLocations function\n\n\n      location = new Location(src, start, new Position(parser.prev[0], parser.prev[1], parser.prev[2])); // last argument is allways the location\n\n      args.push(location);\n    } // handle lazy kind definitions\n\n\n    if (!kind) {\n      kind = args.shift();\n    } // build the object\n\n\n    var node = self[kind];\n\n    if (typeof node !== \"function\") {\n      throw new Error('Undefined node \"' + kind + '\"');\n    }\n\n    var astNode = Object.create(node.prototype);\n    node.apply(astNode, args);\n    result.instance = astNode;\n\n    if (result.trailingComments) {\n      // buffer of trailingComments\n      astNode.trailingComments = result.trailingComments;\n    }\n\n    if (typeof result.postBuild === \"function\") {\n      result.postBuild(astNode);\n    }\n\n    if (parser.debug) {\n      delete AST.stack[result.stackUid];\n    }\n\n    return self.resolvePrecedence(astNode, parser);\n  };\n\n  if (parser.debug) {\n    if (!AST.stack) {\n      AST.stack = {};\n      AST.stackUid = 1;\n    }\n\n    AST.stack[++AST.stackUid] = {\n      position: start,\n      stack: new Error().stack.split(\"\\n\").slice(3, 5)\n    };\n    result.stackUid = AST.stackUid;\n  }\n  /**\n   * Sets a list of trailing comments\n   * @param {*} docs\n   */\n\n\n  result.setTrailingComments = function (docs) {\n    if (result.instance) {\n      // already created\n      result.instance.setTrailingComments(docs);\n    } else {\n      result.trailingComments = docs;\n    }\n  };\n  /**\n   * Release a node without using it on the AST\n   */\n\n\n  result.destroy = function (target) {\n    if (docs) {\n      // release current docs stack\n      if (target) {\n        if (!target.leadingComments) {\n          target.leadingComments = docs;\n        } else {\n          target.leadingComments = docs.concat(target.leadingComments);\n        }\n      } else {\n        parser._docIndex = parser._docs.length - docs.length;\n      }\n    }\n\n    if (parser.debug) {\n      delete AST.stack[result.stackUid];\n    }\n  };\n\n  return result;\n};\n\nAST.prototype.checkNodes = function () {\n  var errors = [];\n\n  for (var k in AST.stack) {\n    if (AST.stack.hasOwnProperty(k)) {\n      errors.push(AST.stack[k]);\n    }\n  }\n\n  AST.stack = {};\n  return errors;\n}; // Define all AST nodes\n\n\n[__webpack_require__(43), __webpack_require__(44), __webpack_require__(45), __webpack_require__(46), __webpack_require__(47), __webpack_require__(7), __webpack_require__(48), __webpack_require__(49), __webpack_require__(50), __webpack_require__(51), __webpack_require__(52), __webpack_require__(53), __webpack_require__(54), __webpack_require__(55), __webpack_require__(56), __webpack_require__(57), __webpack_require__(58), __webpack_require__(9), __webpack_require__(59), __webpack_require__(60), __webpack_require__(61), __webpack_require__(10), __webpack_require__(62), __webpack_require__(5), __webpack_require__(63), __webpack_require__(64), __webpack_require__(65), __webpack_require__(66), __webpack_require__(67), __webpack_require__(68), __webpack_require__(69), __webpack_require__(70), __webpack_require__(71), __webpack_require__(72), __webpack_require__(73), __webpack_require__(1), __webpack_require__(74), __webpack_require__(75), __webpack_require__(76), __webpack_require__(11), __webpack_require__(77), __webpack_require__(78), __webpack_require__(79), __webpack_require__(80), __webpack_require__(81), __webpack_require__(82), __webpack_require__(83), __webpack_require__(84), __webpack_require__(85), __webpack_require__(86), __webpack_require__(87), __webpack_require__(3), __webpack_require__(8), __webpack_require__(88), __webpack_require__(89), __webpack_require__(90), __webpack_require__(91), __webpack_require__(92), __webpack_require__(2), __webpack_require__(93), __webpack_require__(94), __webpack_require__(95), __webpack_require__(96), __webpack_require__(97), __webpack_require__(4), __webpack_require__(98), __webpack_require__(99), __webpack_require__(100), __webpack_require__(101), __webpack_require__(102), __webpack_require__(103), __webpack_require__(104), __webpack_require__(105), __webpack_require__(106), __webpack_require__(6), __webpack_require__(107), __webpack_require__(108), __webpack_require__(109), __webpack_require__(110), __webpack_require__(0), __webpack_require__(111), __webpack_require__(112), __webpack_require__(113), __webpack_require__(114), __webpack_require__(115), __webpack_require__(116), __webpack_require__(117), __webpack_require__(118), __webpack_require__(119), __webpack_require__(120), __webpack_require__(121), __webpack_require__(122), __webpack_require__(123), __webpack_require__(124), __webpack_require__(125), __webpack_require__(126), __webpack_require__(127), __webpack_require__(128), __webpack_require__(129), __webpack_require__(130), __webpack_require__(131), __webpack_require__(132)].forEach(function (ctor) {\n  AST.prototype[ctor.kind] = ctor;\n});\nmodule.exports = AST;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * Defines the location of the node (with it's source contents as string)\n * @constructor Location\n * @property {String|null} source\n * @property {Position} start\n * @property {Position} end\n */\n\nvar Location = function Location(source, start, end) {\n  this.source = source;\n  this.start = start;\n  this.end = end;\n};\n\nmodule.exports = Location;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n/**\n * Each Position object consists of a line number (1-indexed) and a column number (0-indexed):\n * @constructor Position\n * @property {Number} line\n * @property {Number} column\n * @property {Number} offset\n */\n\nvar Position = function Position(line, column, offset) {\n  this.line = line;\n  this.column = column;\n  this.offset = offset;\n};\n\nmodule.exports = Position;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expr = __webpack_require__(1);\n\nvar KIND = \"array\";\n/**\n * Defines an array structure\n * @constructor Array\n * @example\n * // PHP code :\n * [1, 'foo' => 'bar', 3]\n *\n * // AST structure :\n * {\n *  \"kind\": \"array\",\n *  \"shortForm\": true\n *  \"items\": [\n *    {\"kind\": \"number\", \"value\": \"1\"},\n *    {\n *      \"kind\": \"entry\",\n *      \"key\": {\"kind\": \"string\", \"value\": \"foo\", \"isDoubleQuote\": false},\n *      \"value\": {\"kind\": \"string\", \"value\": \"bar\", \"isDoubleQuote\": false}\n *    },\n *    {\"kind\": \"number\", \"value\": \"3\"}\n *  ]\n * }\n * @extends {Expression}\n * @property {Entry|Expr|Variable} items List of array items\n * @property {boolean} shortForm Indicate if the short array syntax is used, ex `[]` instead `array()`\n */\n\nmodule.exports = Expr[\"extends\"](KIND, function Array(shortForm, items, docs, location) {\n  Expr.apply(this, [KIND, docs, location]);\n  this.items = items;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"arrowfunc\";\n/**\n * Defines an arrow function (it's like a closure)\n * @constructor ArrowFunc\n * @extends {Expression}\n * @property {Parameter[]} arguments\n * @property {Identifier} type\n * @property {Expression} body\n * @property {boolean} byref\n * @property {boolean} nullable\n * @property {boolean} isStatic\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Closure(args, byref, body, type, nullable, isStatic, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.arguments = args;\n  this.byref = byref;\n  this.body = body;\n  this.type = type;\n  this.nullable = nullable;\n  this.isStatic = isStatic || false;\n});\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"assign\";\n/**\n * Assigns a value to the specified target\n * @constructor Assign\n * @extends {Expression}\n * @property {Expression} left\n * @property {Expression} right\n * @property {String} operator\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Assign(left, right, operator, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.left = left;\n  this.right = right;\n  this.operator = operator;\n});\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"assignref\";\n/**\n * Assigns a value to the specified target\n * @constructor Assign\n * @extends {Expression}\n * @property {Expression} left\n * @property {Expression} right\n * @property {String} operator\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function AssignRef(left, right, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.left = left;\n  this.right = right;\n});\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"bin\";\n/**\n * Binary operations\n * @constructor Bin\n * @extends {Operation}\n * @property {String} type\n * @property {Expression} left\n * @property {Expression} right\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Bin(type, left, right, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.left = left;\n  this.right = right;\n});\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"boolean\";\n/**\n * Defines a boolean value (true/false)\n * @constructor Boolean\n * @extends {Literal}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Boolean(value, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"break\";\n/**\n * A break statement\n * @constructor Break\n * @extends {Statement}\n * @property {Number|Null} level\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Break(level, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.level = level;\n});\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"byref\";\n/**\n * Passing by Reference - so the function can modify the variable\n * @constructor ByRef\n * @extends {Expression}\n * @property {expr} what\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function ByRef(what, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"call\";\n/**\n * Executes a call statement\n * @constructor Call\n * @extends {Expression}\n * @property {Identifier|Variable|??} what\n * @property {Arguments[]} arguments\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Call(what, args, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n  this.arguments = args;\n});\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"case\";\n/**\n * A switch case statement\n * @constructor Case\n * @extends {Statement}\n * @property {Expression|null} test - if null, means that the default case\n * @property {Block|null} body\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Case(test, body, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n});\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"cast\";\n/**\n * Binary operations\n * @constructor Cast\n * @extends {Operation}\n * @property {String} type\n * @property {String} raw\n * @property {Expression} expr\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Cast(type, raw, expr, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.raw = raw;\n  this.expr = expr;\n});\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"catch\";\n/**\n * Defines a catch statement\n * @constructor Catch\n * @extends {Statement}\n * @property {Identifier[]} what\n * @property {Variable} variable\n * @property {Statement} body\n * @see http://php.net/manual/en/language.exceptions.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Catch(body, what, variable, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.body = body;\n  this.what = what;\n  this.variable = variable;\n});\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"class\";\n/**\n * A class definition\n * @constructor Class\n * @extends {Declaration}\n * @property {Identifier|null} extends\n * @property {Identifier[]} implements\n * @property {Declaration[]} body\n * @property {boolean} isAnonymous\n * @property {boolean} isAbstract\n * @property {boolean} isFinal\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function Class(name, ext, impl, body, flags, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.isAnonymous = name ? false : true;\n  this[\"extends\"] = ext;\n  this[\"implements\"] = impl;\n  this.body = body;\n  this.parseFlags(flags);\n});\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar ConstantStatement = __webpack_require__(10);\n\nvar KIND = \"classconstant\";\nvar IS_UNDEFINED = \"\";\nvar IS_PUBLIC = \"public\";\nvar IS_PROTECTED = \"protected\";\nvar IS_PRIVATE = \"private\";\n/**\n * Defines a class/interface/trait constant\n * @constructor ClassConstant\n * @extends {ConstantStatement}\n * @property {string} visibility\n */\n\nvar ClassConstant = ConstantStatement[\"extends\"](KIND, function ClassConstant(kind, constants, flags, docs, location) {\n  ConstantStatement.apply(this, [kind || KIND, constants, docs, location]);\n  this.parseFlags(flags);\n});\n/**\n * Generic flags parser\n * @param {Integer[]} flags\n * @return {void}\n */\n\nClassConstant.prototype.parseFlags = function (flags) {\n  if (flags[0] === -1) {\n    this.visibility = IS_UNDEFINED;\n  } else if (flags[0] === null) {\n    this.visibility = null;\n  } else if (flags[0] === 0) {\n    this.visibility = IS_PUBLIC;\n  } else if (flags[0] === 1) {\n    this.visibility = IS_PROTECTED;\n  } else if (flags[0] === 2) {\n    this.visibility = IS_PRIVATE;\n  }\n};\n\nmodule.exports = ClassConstant;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"clone\";\n/**\n * Defines a clone call\n * @constructor Clone\n * @extends {Expression}\n * @property {Expression} what\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Clone(what, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"closure\";\n/**\n * Defines a closure\n * @constructor Closure\n * @extends {Expression}\n * @property {Parameter[]} arguments\n * @property {Variable[]} uses\n * @property {Identifier} type\n * @property {boolean} byref\n * @property {boolean} nullable\n * @property {Block|null} body\n * @property {boolean} isStatic\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Closure(args, byref, uses, type, nullable, isStatic, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.uses = uses;\n  this.arguments = args;\n  this.byref = byref;\n  this.type = type;\n  this.nullable = nullable;\n  this.isStatic = isStatic || false;\n  this.body = null;\n});\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Comment = __webpack_require__(9);\n\nvar KIND = \"commentblock\";\n/**\n * A comment block (multiline)\n * @constructor CommentBlock\n * @extends {Comment}\n */\n\nmodule.exports = Comment[\"extends\"](KIND, function CommentBlock(value, docs, location) {\n  Comment.apply(this, [KIND, value, docs, location]);\n});\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Comment = __webpack_require__(9);\n\nvar KIND = \"commentline\";\n/**\n * A single line comment\n * @constructor CommentLine\n * @extends {Comment}\n */\n\nmodule.exports = Comment[\"extends\"](KIND, function CommentLine(value, docs, location) {\n  Comment.apply(this, [KIND, value, docs, location]);\n});\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"constant\";\n/**\n * Defines a constant\n * @constructor Constant\n * @extends {Node}\n * @property {string} name\n * @property {Node|string|number|boolean|null} value\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Constant(name, value, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.value = value;\n});\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"continue\";\n/**\n * A continue statement\n * @constructor Continue\n * @extends {Statement}\n * @property {Number|Null} level\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Continue(level, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.level = level;\n});\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Block = __webpack_require__(7);\n\nvar KIND = \"declare\";\n/**\n * The declare construct is used to set execution directives for a block of code\n * @constructor Declare\n * @extends {Block}\n * @property {Array[]} directives\n * @property {String} mode\n * @see http://php.net/manual/en/control-structures.declare.php\n */\n\nvar Declare = Block[\"extends\"](KIND, function Declare(directives, body, mode, docs, location) {\n  Block.apply(this, [KIND, body, docs, location]);\n  this.directives = directives;\n  this.mode = mode;\n});\n/**\n * The node is declared as a short tag syntax :\n * ```php\n * <?php\n * declare(ticks=1):\n * // some statements\n * enddeclare;\n * ```\n * @constant {String} MODE_SHORT\n */\n\nDeclare.MODE_SHORT = \"short\";\n/**\n * The node is declared bracket enclosed code :\n * ```php\n * <?php\n * declare(ticks=1) {\n * // some statements\n * }\n * ```\n * @constant {String} MODE_BLOCK\n */\n\nDeclare.MODE_BLOCK = \"block\";\n/**\n * The node is declared as a simple statement. In order to make things simpler\n * children of the node are automatically collected until the next\n * declare statement.\n * ```php\n * <?php\n * declare(ticks=1);\n * // some statements\n * declare(ticks=2);\n * // some statements\n * ```\n * @constant {String} MODE_NONE\n */\n\nDeclare.MODE_NONE = \"none\";\nmodule.exports = Declare;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"declaredirective\";\n/**\n * Defines a constant\n * @constructor DeclareDirective\n * @extends {Node}\n * @property {Identifier} name\n * @property {Node|string|number|boolean|null} value\n */\n\nmodule.exports = Node[\"extends\"](KIND, function DeclareDirective(key, value, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.key = key;\n  this.value = value;\n});\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"do\";\n/**\n * Defines a do/while statement\n * @constructor Do\n * @extends {Statement}\n * @property {Expression} test\n * @property {Statement} body\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Do(test, body, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n});\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"echo\";\n/**\n * Defines system based call\n * @constructor Echo\n * @property {boolean} shortForm\n * @extends {Statement}\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Echo(expressions, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.shortForm = shortForm;\n  this.expressions = expressions;\n});\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"empty\";\n/**\n * Defines an empty check call\n * @constructor Empty\n * @extends {Expression}\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Empty(expression, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n});\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"encapsed\";\n/**\n * Defines an encapsed string (contains expressions)\n * @constructor Encapsed\n * @extends {Literal}\n * @property {String} type - Defines the type of encapsed string (shell, heredoc, string)\n * @property {String|Null} label - The heredoc label, defined only when the type is heredoc\n */\n\nvar Encapsed = Literal[\"extends\"](KIND, function Encapsed(value, raw, type, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n  this.type = type;\n});\n/**\n * The node is a double quote string :\n * ```php\n * <?php\n * echo \"hello $world\";\n * ```\n * @constant {String} TYPE_STRING - `string`\n */\n\nEncapsed.TYPE_STRING = \"string\";\n/**\n * The node is a shell execute string :\n * ```php\n * <?php\n * echo `ls -larth $path`;\n * ```\n * @constant {String} TYPE_SHELL - `shell`\n */\n\nEncapsed.TYPE_SHELL = \"shell\";\n/**\n * The node is a shell execute string :\n * ```php\n * <?php\n * echo <<<STR\n *  Hello $world\n * STR\n * ;\n * ```\n * @constant {String} TYPE_HEREDOC - `heredoc`\n */\n\nEncapsed.TYPE_HEREDOC = \"heredoc\";\n/**\n * The node contains a list of constref / variables / expr :\n * ```php\n * <?php\n * echo $foo->bar_$baz;\n * ```\n * @constant {String} TYPE_OFFSET - `offset`\n */\n\nEncapsed.TYPE_OFFSET = \"offset\";\nmodule.exports = Encapsed;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"encapsedpart\";\n/**\n * Part of `Encapsed` node\n * @constructor EncapsedPart\n * @extends {Expression}\n * @property {Expression} expression\n * @property {String} syntax\n * @property {Boolean} curly\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function EncapsedPart(expression, syntax, curly, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n  this.syntax = syntax;\n  this.curly = curly;\n});\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"entry\";\n/**\n * An array entry - see [Array](#array)\n * @constructor Entry\n * @extends {Expression}\n * @property {Node|null} key The entry key/offset\n * @property {Node} value The entry value\n * @property {Boolean} byRef By reference\n * @property {Boolean} unpack Argument unpacking\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Entry(key, value, byRef, unpack, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.key = key;\n  this.value = value;\n  this.byRef = byRef;\n  this.unpack = unpack;\n});\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"error\";\n/**\n * Defines an error node (used only on silentMode)\n * @constructor Error\n * @extends {Node}\n * @property {string} message\n * @property {number} line\n * @property {number|string} token\n * @property {string|array} expected\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Error(message, token, line, expected, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.message = message;\n  this.token = token;\n  this.line = line;\n  this.expected = expected;\n});\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"eval\";\n/**\n * Defines an eval statement\n * @constructor Eval\n * @extends {Expression}\n * @property {Node} source\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Eval(source, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.source = source;\n});\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"exit\";\n/**\n * Defines an exit / die call\n * @constructor Exit\n * @extends {Expression}\n * @property {Node|null} expression\n * @property {Boolean} useDie\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Exit(expression, useDie, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n  this.useDie = useDie;\n});\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"expressionstatement\";\n/**\n * Defines an expression based statement\n * @constructor ExpressionStatement\n * @extends {Statement}\n * @property {Expression} expression\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function ExpressionStatement(expr, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.expression = expr;\n});\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"for\";\n/**\n * Defines a for iterator\n * @constructor For\n * @extends {Statement}\n * @property {Expression[]} init\n * @property {Expression[]} test\n * @property {Expression[]} increment\n * @property {Statement} body\n * @property {boolean} shortForm\n * @see http://php.net/manual/en/control-structures.for.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function For(init, test, increment, body, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.init = init;\n  this.test = test;\n  this.increment = increment;\n  this.shortForm = shortForm;\n  this.body = body;\n});\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"foreach\";\n/**\n * Defines a foreach iterator\n * @constructor Foreach\n * @extends {Statement}\n * @property {Expression} source\n * @property {Expression|null} key\n * @property {Expression} value\n * @property {Statement} body\n * @property {boolean} shortForm\n * @see http://php.net/manual/en/control-structures.foreach.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Foreach(source, key, value, body, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.source = source;\n  this.key = key;\n  this.value = value;\n  this.shortForm = shortForm;\n  this.body = body;\n});\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"global\";\n/**\n * Imports a variable from the global scope\n * @constructor Global\n * @extends {Statement}\n * @property {Variable[]} items\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Global(items, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.items = items;\n});\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"goto\";\n/**\n * Defines goto statement\n * @constructor Goto\n * @extends {Statement}\n * @property {String} label\n * @see {Label}\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Goto(label, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.label = label;\n});\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"halt\";\n/**\n * Halts the compiler execution\n * @constructor Halt\n * @extends {Statement}\n * @property {String} after - String after the halt statement\n * @see http://php.net/manual/en/function.halt-compiler.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Halt(after, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.after = after;\n});\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"identifier\";\n/**\n * Defines an identifier node\n * @constructor Identifier\n * @extends {Node}\n * @property {string} name\n */\n\nvar Identifier = Node[\"extends\"](KIND, function Identifier(name, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.name = name;\n});\nmodule.exports = Identifier;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"if\";\n/**\n * Defines a if statement\n * @constructor If\n * @extends {Statement}\n * @property {Expression} test\n * @property {Block} body\n * @property {Block|If|null} alternate\n * @property {boolean} shortForm\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function If(test, body, alternate, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n  this.alternate = alternate;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"include\";\n/**\n * Defines system include call\n * @constructor Include\n * @extends {Expression}\n * @property {Node} target\n * @property {boolean} once\n * @property {boolean} require\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Include(once, require, target, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.once = once;\n  this.require = require;\n  this.target = target;\n});\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"inline\";\n/**\n * Defines inline html output (treated as echo output)\n * @constructor Inline\n * @extends {Literal}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Inline(value, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"interface\";\n/**\n * An interface definition\n * @constructor Interface\n * @extends {Declaration}\n * @property {Identifier[]} extends\n * @property {Declaration[]} body\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function Interface(name, ext, body, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this[\"extends\"] = ext;\n  this.body = body;\n});\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"isset\";\n/**\n * Defines an isset call\n * @constructor Isset\n * @extends {Expression}\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Isset(variables, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.variables = variables;\n});\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"label\";\n/**\n * A label statement (referenced by goto)\n * @constructor Label\n * @extends {Statement}\n * @property {String} name\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Label(name, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n});\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"list\";\n/**\n * Defines list assignment\n * @constructor List\n * @extends {Expression}\n * @property {boolean} shortForm\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function List(items, shortForm, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.items = items;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"magic\";\n/**\n * Defines magic constant\n * @constructor Magic\n * @extends {Literal}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Magic(value, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar _Function = __webpack_require__(11);\n\nvar KIND = \"method\";\n/**\n * Defines a class/interface/trait method\n * @constructor Method\n * @extends {_Function}\n * @property {boolean} isAbstract\n * @property {boolean} isFinal\n * @property {boolean} isStatic\n * @property {string} visibility\n */\n\nmodule.exports = _Function[\"extends\"](KIND, function Method() {\n  _Function.apply(this, arguments);\n\n  this.kind = KIND;\n});\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"name\";\n/**\n * Defines a class reference node\n * @constructor Name\n * @extends {Reference}\n * @property {string} name\n * @property {string} resolution\n */\n\nvar Name = Reference[\"extends\"](KIND, function Name(name, isRelative, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n\n  if (isRelative) {\n    this.resolution = Name.RELATIVE_NAME;\n  } else if (name.length === 1) {\n    this.resolution = Name.UNQUALIFIED_NAME;\n  } else if (!name[0]) {\n    this.resolution = Name.FULL_QUALIFIED_NAME;\n  } else {\n    this.resolution = Name.QUALIFIED_NAME;\n  }\n\n  this.name = name.join(\"\\\\\");\n});\n/**\n * This is an identifier without a namespace separator, such as Foo\n * @constant {String} UNQUALIFIED_NAME\n */\n\nName.UNQUALIFIED_NAME = \"uqn\";\n/**\n * This is an identifier with a namespace separator, such as Foo\\Bar\n * @constant {String} QUALIFIED_NAME\n */\n\nName.QUALIFIED_NAME = \"qn\";\n/**\n * This is an identifier with a namespace separator that begins with\n * a namespace separator, such as \\Foo\\Bar. The namespace \\Foo is also\n * a fully qualified name.\n * @constant {String} FULL_QUALIFIED_NAME\n */\n\nName.FULL_QUALIFIED_NAME = \"fqn\";\n/**\n * This is an identifier starting with namespace, such as namespace\\Foo\\Bar.\n * @constant {String} RELATIVE_NAME\n */\n\nName.RELATIVE_NAME = \"rn\";\nmodule.exports = Name;\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Block = __webpack_require__(7);\n\nvar KIND = \"namespace\";\n/**\n * The main program node\n * @constructor Namespace\n * @extends {Block}\n * @property {String} name\n * @property {Boolean} withBrackets\n */\n\nmodule.exports = Block[\"extends\"](KIND, function Namespace(name, children, withBrackets, docs, location) {\n  Block.apply(this, [KIND, children, docs, location]);\n  this.name = name;\n  this.withBrackets = withBrackets || false;\n});\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"new\";\n/**\n * Creates a new instance of the specified class\n * @constructor New\n * @extends {Expression}\n * @property {Identifier|Variable|Class} what\n * @property {Arguments[]} arguments\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function New(what, args, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n  this.arguments = args;\n});\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"noop\";\n/**\n * Ignore this node, it implies a no operation block, for example :\n * [$foo, $bar, /* here a noop node * /]\n * @constructor Noop\n * @extends {Node}\n */\n\nmodule.exports = Node[\"extends\"](KIND, function Noop(docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n});\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"nowdoc\";\n/**\n * Defines a nowdoc string\n * @constructor NowDoc\n * @extends {Literal}\n * @property {String} label\n * @property {String} raw\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Nowdoc(value, raw, label, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n  this.label = label;\n});\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"nullkeyword\";\n/**\n * Represents the null keyword\n * @constructor NullKeyword\n * @extends {Node}\n */\n\nmodule.exports = Node[\"extends\"](KIND, function NullKeyword(raw, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"number\";\n/**\n * Defines a numeric value\n * @constructor Number\n * @extends {Literal}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function Number(value, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n});\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Lookup = __webpack_require__(8);\n\nvar KIND = \"offsetlookup\";\n/**\n * Lookup on an offset in an array\n * @constructor OffsetLookup\n * @extends {Lookup}\n */\n\nmodule.exports = Lookup[\"extends\"](KIND, function OffsetLookup(what, offset, docs, location) {\n  Lookup.apply(this, [KIND, what, offset, docs, location]);\n});\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"parameter\";\n/**\n * Defines a function parameter\n * @constructor Parameter\n * @extends {Declaration}\n * @property {Identifier|null} type\n * @property {Node|null} value\n * @property {boolean} byref\n * @property {boolean} variadic\n * @property {boolean} nullable\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function Parameter(name, type, value, isRef, isVariadic, nullable, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.value = value;\n  this.type = type;\n  this.byref = isRef;\n  this.variadic = isVariadic;\n  this.nullable = nullable;\n});\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"parentreference\";\n/**\n * Defines a class reference node\n * @constructor ParentReference\n * @extends {Reference}\n */\n\nvar ParentReference = Reference[\"extends\"](KIND, function ParentReference(raw, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\nmodule.exports = ParentReference;\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"post\";\n/**\n * Defines a post operation `$i++` or `$i--`\n * @constructor Post\n * @extends {Operation}\n * @property {String} type\n * @property {Variable} what\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Post(type, what, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.what = what;\n});\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"pre\";\n/**\n * Defines a pre operation `++$i` or `--$i`\n * @constructor Pre\n * @extends {Operation}\n * @property {String} type\n * @property {Variable} what\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Pre(type, what, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.what = what;\n});\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"print\";\n/**\n * Outputs\n * @constructor Print\n * @extends {Expression}\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Print(expression, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expression = expression;\n});\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Block = __webpack_require__(7);\n\nvar KIND = \"program\";\n/**\n * The main program node\n * @constructor Program\n * @extends {Block}\n * @property {Error[]} errors\n * @property {Doc[]?} comments\n * @property {String[]?} tokens\n */\n\nmodule.exports = Block[\"extends\"](KIND, function Program(children, errors, comments, tokens, docs, location) {\n  Block.apply(this, [KIND, children, docs, location]);\n  this.errors = errors;\n\n  if (comments) {\n    this.comments = comments;\n  }\n\n  if (tokens) {\n    this.tokens = tokens;\n  }\n});\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"property\";\n/**\n * Defines a class property\n * @constructor Property\n * @extends {Statement}\n * @property {string} name\n * @property {Node|null} value\n * @property {boolean} nullable\n * @property {Identifier|Array<Identifier>|null} type\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Property(name, value, nullable, type, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.value = value;\n  this.nullable = nullable;\n  this.type = type;\n});\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Lookup = __webpack_require__(8);\n\nvar KIND = \"propertylookup\";\n/**\n * Lookup to an object property\n * @constructor PropertyLookup\n * @extends {Lookup}\n */\n\nmodule.exports = Lookup[\"extends\"](KIND, function PropertyLookup(what, offset, docs, location) {\n  Lookup.apply(this, [KIND, what, offset, docs, location]);\n});\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"propertystatement\";\nvar IS_UNDEFINED = \"\";\nvar IS_PUBLIC = \"public\";\nvar IS_PROTECTED = \"protected\";\nvar IS_PRIVATE = \"private\";\n/**\n * Declares a properties into the current scope\n * @constructor PropertyStatement\n * @extends {Statement}\n * @property {Property[]} properties\n */\n\nvar PropertyStatement = Statement[\"extends\"](KIND, function PropertyStatement(kind, properties, flags, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.properties = properties;\n  this.parseFlags(flags);\n});\n/**\n * Generic flags parser\n * @param {Integer[]} flags\n * @return {void}\n */\n\nPropertyStatement.prototype.parseFlags = function (flags) {\n  if (flags[0] === -1) {\n    this.visibility = IS_UNDEFINED;\n  } else if (flags[0] === null) {\n    this.visibility = null;\n  } else if (flags[0] === 0) {\n    this.visibility = IS_PUBLIC;\n  } else if (flags[0] === 1) {\n    this.visibility = IS_PROTECTED;\n  } else if (flags[0] === 2) {\n    this.visibility = IS_PRIVATE;\n  }\n\n  this.isStatic = flags[1] === 1;\n};\n\nmodule.exports = PropertyStatement;\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"retif\";\n/**\n * Defines a short if statement that returns a value\n * @constructor RetIf\n * @extends {Expression}\n * @property {Expression} test\n * @property {Expression} trueExpr\n * @property {Expression} falseExpr\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function RetIf(test, trueExpr, falseExpr, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.trueExpr = trueExpr;\n  this.falseExpr = falseExpr;\n});\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"return\";\n/**\n * A continue statement\n * @constructor Return\n * @extends {Statement}\n * @property {Expression|null} expr\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Return(expr, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.expr = expr;\n});\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"selfreference\";\n/**\n * Defines a class reference node\n * @constructor SelfReference\n * @extends {Reference}\n */\n\nvar SelfReference = Reference[\"extends\"](KIND, function SelfReference(raw, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\nmodule.exports = SelfReference;\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"silent\";\n/**\n * Avoids to show/log warnings & notices from the inner expression\n * @constructor Silent\n * @extends {Expression}\n * @property {Expression} expr\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Silent(expr, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.expr = expr;\n});\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"static\";\n/**\n * Declares a static variable into the current scope\n * @constructor Static\n * @extends {Statement}\n * @property {StaticVariable[]} variables\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Static(variables, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.variables = variables;\n});\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"staticvariable\";\n/**\n * Defines a constant\n * @constructor StaticVariable\n * @extends {Node}\n * @property {Variable} variable\n * @property {Node|string|number|boolean|null} defaultValue\n */\n\nmodule.exports = Node[\"extends\"](KIND, function StaticVariable(variable, defaultValue, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.variable = variable;\n  this.defaultValue = defaultValue;\n});\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Lookup = __webpack_require__(8);\n\nvar KIND = \"staticlookup\";\n/**\n * Lookup to a static property\n * @constructor StaticLookup\n * @extends {Lookup}\n */\n\nmodule.exports = Lookup[\"extends\"](KIND, function StaticLookup(what, offset, docs, location) {\n  Lookup.apply(this, [KIND, what, offset, docs, location]);\n});\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"staticreference\";\n/**\n * Defines a class reference node\n * @constructor StaticReference\n * @extends {Reference}\n */\n\nvar StaticReference = Reference[\"extends\"](KIND, function StaticReference(raw, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.raw = raw;\n});\nmodule.exports = StaticReference;\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Literal = __webpack_require__(3);\n\nvar KIND = \"string\";\n/**\n * Defines a string (simple ou double quoted) - chars are already escaped\n * @constructor String\n * @extends {Literal}\n * @property {boolean} unicode\n * @property {boolean} isDoubleQuote\n * @see {Encapsed}\n */\n\nmodule.exports = Literal[\"extends\"](KIND, function String(isDoubleQuote, value, unicode, raw, docs, location) {\n  Literal.apply(this, [KIND, value, raw, docs, location]);\n  this.unicode = unicode;\n  this.isDoubleQuote = isDoubleQuote;\n});\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"switch\";\n/**\n * Defines a switch statement\n * @constructor Switch\n * @extends {Statement}\n * @property {Expression} test\n * @property {Block} body\n * @property {boolean} shortForm\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Switch(test, body, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"throw\";\n/**\n * Defines a throw statement\n * @constructor Throw\n * @extends {Statement}\n * @property {Expression} what\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Throw(what, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Declaration = __webpack_require__(5);\n\nvar KIND = \"trait\";\n/**\n * A trait definition\n * @constructor Trait\n * @extends {Declaration}\n * @property {Declaration[]} body\n */\n\nmodule.exports = Declaration[\"extends\"](KIND, function Trait(name, body, docs, location) {\n  Declaration.apply(this, [KIND, name, docs, location]);\n  this.body = body;\n});\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"traitalias\";\nvar IS_UNDEFINED = \"\";\nvar IS_PUBLIC = \"public\";\nvar IS_PROTECTED = \"protected\";\nvar IS_PRIVATE = \"private\";\n/**\n * Defines a trait alias\n * @constructor TraitAlias\n * @extends {Node}\n * @property {Identifier|null} trait\n * @property {Identifier} method\n * @property {Identifier|null} as\n * @property {string|null} visibility\n */\n\nmodule.exports = Node[\"extends\"](KIND, function TraitAlias(trait, method, as, flags, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.trait = trait;\n  this.method = method;\n  this.as = as;\n  this.visibility = IS_UNDEFINED;\n\n  if (flags) {\n    if (flags[0] === 0) {\n      this.visibility = IS_PUBLIC;\n    } else if (flags[0] === 1) {\n      this.visibility = IS_PROTECTED;\n    } else if (flags[0] === 2) {\n      this.visibility = IS_PRIVATE;\n    }\n  }\n});\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"traitprecedence\";\n/**\n * Defines a trait alias\n * @constructor TraitPrecedence\n * @extends {Node}\n * @property {Identifier|null} trait\n * @property {Identifier} method\n * @property {Identifier[]} instead\n */\n\nmodule.exports = Node[\"extends\"](KIND, function TraitPrecedence(trait, method, instead, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.trait = trait;\n  this.method = method;\n  this.instead = instead;\n});\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Node = __webpack_require__(2);\n\nvar KIND = \"traituse\";\n/**\n * Defines a trait usage\n * @constructor TraitUse\n * @extends {Node}\n * @property {Identifier[]} traits\n * @property {Node[]|null} adaptations\n */\n\nmodule.exports = Node[\"extends\"](KIND, function TraitUse(traits, adaptations, docs, location) {\n  Node.apply(this, [KIND, docs, location]);\n  this.traits = traits;\n  this.adaptations = adaptations;\n});\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"try\";\n/**\n * Defines a try statement\n * @constructor Try\n * @extends {Statement}\n * @property {Block} body\n * @property {Catch[]} catches\n * @property {Block} allways\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Try(body, catches, always, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.body = body;\n  this.catches = catches;\n  this.always = always;\n});\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Reference = __webpack_require__(6);\n\nvar KIND = \"typereference\";\n/**\n * Defines a class reference node\n * @constructor TypeReference\n * @extends {Reference}\n * @property {string} name\n */\n\nvar TypeReference = Reference[\"extends\"](KIND, function TypeReference(name, raw, docs, location) {\n  Reference.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.raw = raw;\n});\nTypeReference.types = [\"int\", \"float\", \"string\", \"bool\", \"object\", \"array\", \"callable\", \"iterable\", \"void\"];\nmodule.exports = TypeReference;\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Operation = __webpack_require__(4);\n\nvar KIND = \"unary\";\n/**\n * Unary operations\n * @constructor Unary\n * @extends {Operation}\n * @property {String} type\n * @property {Expression} what\n */\n\nmodule.exports = Operation[\"extends\"](KIND, function Unary(type, what, docs, location) {\n  Operation.apply(this, [KIND, docs, location]);\n  this.type = type;\n  this.what = what;\n});\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"unset\";\n/**\n * Deletes references to a list of variables\n * @constructor Unset\n * @extends {Statement}\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function Unset(variables, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.variables = variables;\n});\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"usegroup\";\n/**\n * Defines a use statement (with a list of use items)\n * @constructor UseGroup\n * @extends {Statement}\n * @property {String|null} name\n * @property {String|null} type - Possible value : function, const\n * @property {UseItem[]} item\n * @see {Namespace}\n * @see http://php.net/manual/en/language.namespaces.importing.php\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function UseGroup(name, type, items, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.type = type;\n  this.items = items;\n});\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"useitem\";\n/**\n * Defines a use statement (from namespace)\n * @constructor UseItem\n * @extends {Statement}\n * @property {String} name\n * @property {String|null} type - Possible value : function, const\n * @property {Identifier|null} alias\n * @see {Namespace}\n * @see http://php.net/manual/en/language.namespaces.importing.php\n */\n\nvar UseItem = Statement[\"extends\"](KIND, function UseItem(name, alias, type, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.alias = alias;\n  this.type = type;\n});\n/**\n * Importing a constant\n * @constant {String} TYPE_CONST\n */\n\nUseItem.TYPE_CONST = \"const\";\n/**\n * Importing a function\n * @constant {String} TYPE_FUNC\n */\n\nUseItem.TYPE_FUNCTION = \"function\";\nmodule.exports = UseItem;\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"variable\";\n/**\n * Any expression node. Since the left-hand side of an assignment may\n * be any expression in general, an expression can also be a pattern.\n * @constructor Variable\n * @extends {Expression}\n * @example\n * // PHP code :\n * $foo\n * // AST output\n * {\n *  \"kind\": \"variable\",\n *  \"name\": \"foo\",\n *  \"curly\": false\n * }\n * @property {String|Node} name The variable name (can be a complex expression when the name is resolved dynamically)\n * @property {boolean} curly Indicate if the name is defined between curlies, ex `${foo}`\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Variable(name, curly, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.name = name;\n  this.curly = curly || false;\n});\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"variadic\";\n/**\n * Introduce a list of items into the arguments of the call\n * @constructor variadic\n * @extends {Expression}\n * @property {Array|Expression} what\n * @see https://wiki.php.net/rfc/argument_unpacking\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function variadic(what, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.what = what;\n});\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Statement = __webpack_require__(0);\n\nvar KIND = \"while\";\n/**\n * Defines a while statement\n * @constructor While\n * @extends {Statement}\n * @property {Expression} test\n * @property {Statement} body\n * @property {boolean} shortForm\n */\n\nmodule.exports = Statement[\"extends\"](KIND, function While(test, body, shortForm, docs, location) {\n  Statement.apply(this, [KIND, docs, location]);\n  this.test = test;\n  this.body = body;\n  this.shortForm = shortForm;\n});\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"yield\";\n/**\n * Defines a yield generator statement\n * @constructor Yield\n * @extends {Expression}\n * @property {Expression|Null} value\n * @property {Expression|Null} key\n * @see http://php.net/manual/en/language.generators.syntax.php\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function Yield(value, key, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.value = value;\n  this.key = key;\n});\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * Copyright (C) 2018 Glayzzle (BSD3 License)\n * @authors https://github.com/glayzzle/php-parser/graphs/contributors\n * @url http://glayzzle.com\n */\n\n\nvar Expression = __webpack_require__(1);\n\nvar KIND = \"yieldfrom\";\n/**\n * Defines a yield from generator statement\n * @constructor YieldFrom\n * @extends {Expression}\n * @property {Expression} value\n * @see http://php.net/manual/en/language.generators.syntax.php\n */\n\nmodule.exports = Expression[\"extends\"](KIND, function YieldFrom(value, docs, location) {\n  Expression.apply(this, [KIND, docs, location]);\n  this.value = value;\n});\n\n/***/ })\n/******/ ])[\"default\"];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGhwLXBhcnNlci9kaXN0L3BocC1wYXJzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGhwLXBhcnNlci9kaXN0L3BocC1wYXJzZXIuanM/YTE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFxuICogICBQYWNrYWdlOiBwaHAtcGFyc2VyXG4gKiAgIFBhcnNlIFBIUCBjb2RlIGZyb20gSlMgYW5kIHJldHVybnMgaXRzIEFTVFxuICogICBCdWlsZDogNmRhODhlN2U3YWNiZTRhMTU0YjQgLSAzLzI3LzIwMjBcbiAqICAgQ29weXJpZ2h0IChDKSAyMDIwIEdsYXl6emxlIChCU0QtMy1DbGF1c2UpXG4gKiAgIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqICAgQHVybCBodHRwOi8vZ2xheXp6bGUuY29tICAgICAgICBcbiAqICAgICAgIFxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJQaHBQYXJzZXJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUGhwUGFyc2VyXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEyKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJzdGF0ZW1lbnRcIjtcbi8qKlxuICogQW55IHN0YXRlbWVudC5cbiAqIEBjb25zdHJ1Y3RvciBTdGF0ZW1lbnRcbiAqIEBleHRlbmRzIHtOb2RlfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU3RhdGVtZW50KGtpbmQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW2tpbmQgfHwgS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJleHByZXNzaW9uXCI7XG4vKipcbiAqIEFueSBleHByZXNzaW9uIG5vZGUuIFNpbmNlIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhbiBhc3NpZ25tZW50IG1heVxuICogYmUgYW55IGV4cHJlc3Npb24gaW4gZ2VuZXJhbCwgYW4gZXhwcmVzc2lvbiBjYW4gYWxzbyBiZSBhIHBhdHRlcm4uXG4gKiBAY29uc3RydWN0b3IgRXhwcmVzc2lvblxuICogQGV4dGVuZHMge05vZGV9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBFeHByZXNzaW9uKGtpbmQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW2tpbmQgfHwgS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuLyoqXG4gKiBBIGdlbmVyaWMgQVNUIG5vZGVcbiAqIEBjb25zdHJ1Y3RvciBOb2RlXG4gKiBAcHJvcGVydHkge0xvY2F0aW9ufG51bGx9IGxvY1xuICogQHByb3BlcnR5IHtDb21tZW50W119IGxlYWRpbmdDb21tZW50c1xuICogQHByb3BlcnR5IHtDb21tZW50W10/fSB0cmFpbGluZ0NvbW1lbnRzXG4gKiBAcHJvcGVydHkge1N0cmluZ30ga2luZFxuICovXG5cbnZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShraW5kLCBkb2NzLCBsb2NhdGlvbikge1xuICB0aGlzLmtpbmQgPSBraW5kO1xuXG4gIGlmIChkb2NzKSB7XG4gICAgdGhpcy5sZWFkaW5nQ29tbWVudHMgPSBkb2NzO1xuICB9XG5cbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgdGhpcy5sb2MgPSBsb2NhdGlvbjtcbiAgfVxufTtcbi8qKlxuICogQXR0YWNoIGNvbW1lbnRzIHRvIGN1cnJlbnQgbm9kZVxuICogQHBhcmFtIHsqfSBkb2NzXG4gKi9cblxuXG5Ob2RlLnByb3RvdHlwZS5zZXRUcmFpbGluZ0NvbW1lbnRzID0gZnVuY3Rpb24gKGRvY3MpIHtcbiAgdGhpcy50cmFpbGluZ0NvbW1lbnRzID0gZG9jcztcbn07XG4vKipcbiAqIERlc3Ryb3lpbmcgYW4gdW51c2VkIG5vZGVcbiAqL1xuXG5cbk5vZGUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGFscmVhZHkgaW5pdGlhbGl6ZWQsIHlvdSBtdXN0IHN3YXAgd2l0aCBhbm90aGVyIG5vZGVcIik7XG4gIH1cblxuICBpZiAodGhpcy5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICBpZiAobm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gQXJyYXkuY29uY2F0KHRoaXMubGVhZGluZ0NvbW1lbnRzLCBub2RlLmxlYWRpbmdDb21tZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzID0gdGhpcy5sZWFkaW5nQ29tbWVudHM7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudHJhaWxpbmdDb21tZW50cykge1xuICAgIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IEFycmF5LmNvbmNhdCh0aGlzLnRyYWlsaW5nQ29tbWVudHMsIG5vZGUudHJhaWxpbmdDb21tZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IHRoaXMudHJhaWxpbmdDb21tZW50cztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG4vKipcbiAqIEluY2x1ZGVzIGN1cnJlbnQgdG9rZW4gcG9zaXRpb24gb2YgdGhlIHBhcnNlclxuICogQHBhcmFtIHsqfSBwYXJzZXJcbiAqL1xuXG5cbk5vZGUucHJvdG90eXBlLmluY2x1ZGVUb2tlbiA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgaWYgKHRoaXMubG9jKSB7XG4gICAgaWYgKHRoaXMubG9jLmVuZCkge1xuICAgICAgdGhpcy5sb2MuZW5kLmxpbmUgPSBwYXJzZXIubGV4ZXIueXlsbG9jLmxhc3RfbGluZTtcbiAgICAgIHRoaXMubG9jLmVuZC5jb2x1bW4gPSBwYXJzZXIubGV4ZXIueXlsbG9jLmxhc3RfY29sdW1uO1xuICAgICAgdGhpcy5sb2MuZW5kLm9mZnNldCA9IHBhcnNlci5sZXhlci5vZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5hc3Qud2l0aFNvdXJjZSkge1xuICAgICAgdGhpcy5sb2Muc291cmNlID0gcGFyc2VyLmxleGVyLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5sb2Muc3RhcnQub2Zmc2V0LCBwYXJzZXIubGV4ZXIub2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEhlbHBlciBmb3IgZXh0ZW5kaW5nIHRoZSBOb2RlIGNsYXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuTm9kZVtcImV4dGVuZHNcIl0gPSBmdW5jdGlvbiAodHlwZSwgY29uc3RydWN0b3IpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gIGNvbnN0cnVjdG9yW1wiZXh0ZW5kc1wiXSA9IHRoaXNbXCJleHRlbmRzXCJdO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgY29uc3RydWN0b3Iua2luZCA9IHR5cGU7XG4gIHJldHVybiBjb25zdHJ1Y3Rvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwibGl0ZXJhbFwiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGFycmF5IHN0cnVjdHVyZVxuICogQGNvbnN0cnVjdG9yIExpdGVyYWxcbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJhd1xuICogQHByb3BlcnR5IHtOb2RlfHN0cmluZ3xudW1iZXJ8Ym9vbGVhbnxudWxsfSB2YWx1ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTGl0ZXJhbChraW5kLCB2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtraW5kIHx8IEtJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICBpZiAocmF3KSB7XG4gICAgdGhpcy5yYXcgPSByYXc7XG4gIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJvcGVyYXRpb25cIjtcbi8qKlxuICogRGVmaW5lcyBiaW5hcnkgb3BlcmF0aW9uc1xuICogQGNvbnN0cnVjdG9yIE9wZXJhdGlvblxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBPcGVyYXRpb24oa2luZCwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwci5hcHBseSh0aGlzLCBba2luZCB8fCBLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiZGVjbGFyYXRpb25cIjtcbnZhciBJU19VTkRFRklORUQgPSBcIlwiO1xudmFyIElTX1BVQkxJQyA9IFwicHVibGljXCI7XG52YXIgSVNfUFJPVEVDVEVEID0gXCJwcm90ZWN0ZWRcIjtcbnZhciBJU19QUklWQVRFID0gXCJwcml2YXRlXCI7XG4vKipcbiAqIEEgZGVjbGFyYXRpb24gc3RhdGVtZW50IChmdW5jdGlvbiwgY2xhc3MsIGludGVyZmFjZS4uLilcbiAqIEBjb25zdHJ1Y3RvciBEZWNsYXJhdGlvblxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcnxzdHJpbmd9IG5hbWVcbiAqL1xuXG52YXIgRGVjbGFyYXRpb24gPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIERlY2xhcmF0aW9uKGtpbmQsIG5hbWUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBba2luZCB8fCBLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufSk7XG4vKipcbiAqIEdlbmVyaWMgZmxhZ3MgcGFyc2VyXG4gKiBAcGFyYW0ge0ludGVnZXJbXX0gZmxhZ3NcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cblxuRGVjbGFyYXRpb24ucHJvdG90eXBlLnBhcnNlRmxhZ3MgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgdGhpcy5pc0Fic3RyYWN0ID0gZmxhZ3NbMl0gPT09IDE7XG4gIHRoaXMuaXNGaW5hbCA9IGZsYWdzWzJdID09PSAyO1xuXG4gIGlmICh0aGlzLmtpbmQgIT09IFwiY2xhc3NcIikge1xuICAgIGlmIChmbGFnc1swXSA9PT0gLTEpIHtcbiAgICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1VOREVGSU5FRDtcbiAgICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSBudWxsKSB7XG4gICAgICB0aGlzLnZpc2liaWxpdHkgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoZmxhZ3NbMF0gPT09IDApIHtcbiAgICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BVQkxJQztcbiAgICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAxKSB7XG4gICAgICB0aGlzLnZpc2liaWxpdHkgPSBJU19QUk9URUNURUQ7XG4gICAgfSBlbHNlIGlmIChmbGFnc1swXSA9PT0gMikge1xuICAgICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFJJVkFURTtcbiAgICB9XG5cbiAgICB0aGlzLmlzU3RhdGljID0gZmxhZ3NbMV0gPT09IDE7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb247XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIEtJTkQgPSBcInJlZmVyZW5jZVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgcmVmZXJlbmNlIG5vZGVcbiAqIEBjb25zdHJ1Y3RvciBSZWZlcmVuY2VcbiAqIEBleHRlbmRzIHtOb2RlfVxuICovXG5cbnZhciBSZWZlcmVuY2UgPSBOb2RlW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBSZWZlcmVuY2Uoa2luZCwgZG9jcywgbG9jYXRpb24pIHtcbiAgTm9kZS5hcHBseSh0aGlzLCBba2luZCB8fCBLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmVyZW5jZTtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJibG9ja1wiO1xuLyoqXG4gKiBBIGJsb2NrIHN0YXRlbWVudCwgaS5lLiwgYSBzZXF1ZW5jZSBvZiBzdGF0ZW1lbnRzIHN1cnJvdW5kZWQgYnkgYnJhY2VzLlxuICogQGNvbnN0cnVjdG9yIEJsb2NrXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtOb2RlW119IGNoaWxkcmVuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEJsb2NrKGtpbmQsIGNoaWxkcmVuLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW2tpbmQgfHwgS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihCb29sZWFuKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJsb29rdXBcIjtcbi8qKlxuICogTG9va3VwIG9uIGFuIG9mZnNldCBpbiB0aGUgc3BlY2lmaWVkIG9iamVjdFxuICogQGNvbnN0cnVjdG9yIExvb2t1cFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHdoYXRcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gb2Zmc2V0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBMb29rdXAoa2luZCwgd2hhdCwgb2Zmc2V0LCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByLmFwcGx5KHRoaXMsIFtraW5kIHx8IEtJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMud2hhdCA9IHdoYXQ7XG4gIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xufSk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qKlxuICogQWJzdHJhY3QgZG9jdW1lbnRhdGlvbiBub2RlIChDb21lbnRMaW5lIG9yIENvbW1lbnRCbG9jaylcbiAqIEBjb25zdHJ1Y3RvciBDb21tZW50XG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB2YWx1ZVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlW1wiZXh0ZW5kc1wiXShcImNvbW1lbnRcIiwgZnVuY3Rpb24gQ29tbWVudChraW5kLCB2YWx1ZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgTm9kZS5hcHBseSh0aGlzLCBba2luZCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImNvbnN0YW50c3RhdGVtZW50XCI7XG4vKipcbiAqIERlY2xhcmVzIGEgY29uc3RhbnRzIGludG8gdGhlIGN1cnJlbnQgc2NvcGVcbiAqIEBjb25zdHJ1Y3RvciBDb25zdGFudFN0YXRlbWVudFxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7Q29uc3RhbnRbXX0gY29uc3RhbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENvbnN0YW50U3RhdGVtZW50KGtpbmQsIGNvbnN0YW50cywgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtraW5kIHx8IEtJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRGVjbGFyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgS0lORCA9IFwiZnVuY3Rpb25cIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzaWMgZnVuY3Rpb25cbiAqIEBjb25zdHJ1Y3RvciBGdW5jdGlvblxuICogQGV4dGVuZHMge0RlY2xhcmF0aW9ufVxuICogQHByb3BlcnR5IHtQYXJhbWV0ZXJbXX0gYXJndW1lbnRzXG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYnlyZWZcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbnVsbGFibGVcbiAqIEBwcm9wZXJ0eSB7QmxvY2t8bnVsbH0gYm9keVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRGVjbGFyYXRpb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIF9GdW5jdGlvbihuYW1lLCBhcmdzLCBieXJlZiwgdHlwZSwgbnVsbGFibGUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIERlY2xhcmF0aW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBuYW1lLCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG4gIHRoaXMuYnlyZWYgPSBieXJlZjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5udWxsYWJsZSA9IG51bGxhYmxlO1xuICB0aGlzLmJvZHkgPSBudWxsO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAyMCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBsZXhlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgcGFyc2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciB0b2tlbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxudmFyIEFTVCA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gY29tYmluZShzcmMsIHRvKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgIHZhciB2YWwgPSBzcmNba107XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICBkZWxldGUgdG9ba107XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRvW2tdID0gdmFsLmJpbmQodG8pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB0b1trXSA9IEFycmF5LmlzQXJyYXkodG9ba10pID8gdG9ba10uY29uY2F0KHZhbCkgOiB2YWw7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHZhbCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRvW2tdID0gX3R5cGVvZih0b1trXSkgPT09IFwib2JqZWN0XCIgPyBjb21iaW5lKHZhbCwgdG9ba10pIDogdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1trXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG4vKipcbiAqIEluaXRpYWxpc2UgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBvcHRpb25zXG4gKlxuICogQGNsYXNzXG4gKiBAdHV0b3JpYWwgRW5naW5lXG4gKiBAZXhhbXBsZVxuICogdmFyIHBhcnNlciA9IHJlcXVpcmUoJ3BocC1wYXJzZXInKTtcbiAqIHZhciBpbnN0YW5jZSA9IG5ldyBwYXJzZXIoe1xuICogICBwYXJzZXI6IHtcbiAqICAgICBleHRyYWN0RG9jOiB0cnVlLFxuICogICAgIHN1cHByZXNzRXJyb3JzOiB0cnVlLFxuICogICAgIHZlcnNpb246IDcwNCAvLyBvciAnNy40J1xuICogICB9LFxuICogICBhc3Q6IHtcbiAqICAgICB3aXRoUG9zaXRpb25zOiB0cnVlXG4gKiAgIH0sXG4gKiAgIGxleGVyOiB7XG4gKiAgICAgc2hvcnRfdGFnczogdHJ1ZSxcbiAqICAgICBhc3BfdGFnczogdHJ1ZVxuICogICB9XG4gKiB9KTtcbiAqXG4gKiB2YXIgZXZhbEFTVCA9IGluc3RhbmNlLnBhcnNlRXZhbCgnc29tZSBwaHAgY29kZScpO1xuICogdmFyIGNvZGVBU1QgPSBpbnN0YW5jZS5wYXJzZUNvZGUoJzw/cGhwIHNvbWUgcGhwIGNvZGUnLCAnZm9vLnBocCcpO1xuICogdmFyIHRva2VucyA9IGluc3RhbmNlLnRva2VuR2V0QWxsKCc8P3BocCBzb21lIHBocCBjb2RlJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBMaXN0IG9mIG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7TGV4ZXJ9IGxleGVyXG4gKiBAcHJvcGVydHkge1BhcnNlcn0gcGFyc2VyXG4gKiBAcHJvcGVydHkge0FTVH0gYXN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gdG9rZW5zXG4gKi9cblxuXG52YXIgZW5naW5lID0gZnVuY3Rpb24gZW5naW5lKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB0aGlzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgdGhpcy5sZXhlciA9IG5ldyBsZXhlcih0aGlzKTtcbiAgdGhpcy5hc3QgPSBuZXcgQVNUKCk7XG4gIHRoaXMucGFyc2VyID0gbmV3IHBhcnNlcih0aGlzLmxleGVyLCB0aGlzLmFzdCk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgX3R5cGVvZihvcHRpb25zKSA9PT0gXCJvYmplY3RcIikge1xuICAgIC8vIGRpc2FibGUgcGhwNyBmcm9tIGxleGVyIGlmIGFscmVhZHkgZGlzYWJsZWQgZnJvbSBwYXJzZXJcbiAgICBpZiAob3B0aW9ucy5wYXJzZXIpIHtcbiAgICAgIGlmICghb3B0aW9ucy5sZXhlcikge1xuICAgICAgICBvcHRpb25zLmxleGVyID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnBhcnNlci52ZXJzaW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJzZXIudmVyc2lvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhciB2ZXJzaW9uID0gb3B0aW9ucy5wYXJzZXIudmVyc2lvbi5zcGxpdChcIi5cIik7XG4gICAgICAgICAgdmVyc2lvbiA9IHBhcnNlSW50KHZlcnNpb25bMF0pICogMTAwICsgcGFyc2VJbnQodmVyc2lvblsxXSk7XG5cbiAgICAgICAgICBpZiAoaXNOYU4odmVyc2lvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCB2ZXJzaW9uIG51bWJlciA6IFwiICsgb3B0aW9ucy5wYXJzZXIudmVyc2lvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyc2VyLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5wYXJzZXIudmVyc2lvbiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGluZyBhIG51bWJlciBmb3IgdmVyc2lvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBhcnNlci52ZXJzaW9uIDwgNTAwIHx8IG9wdGlvbnMucGFyc2VyLnZlcnNpb24gPiA3MDQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gb25seSBoYW5kbGUgdmVyc2lvbnMgYmV0d2VlbiA1LnggdG8gNy54XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tYmluZShvcHRpb25zLCB0aGlzKTsgLy8gc2FtZSB2ZXJzaW9uIGZsYWdzIGJhc2VkIG9uIHBhcnNlciBvcHRpb25zXG5cbiAgICB0aGlzLmxleGVyLnZlcnNpb24gPSB0aGlzLnBhcnNlci52ZXJzaW9uO1xuICB9XG59O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgaW5weXQgaXMgYSBidWZmZXIgb3IgYSBzdHJpbmdcbiAqIEBwYXJhbSAge0J1ZmZlcnxTdHJpbmd9IGJ1ZmZlciBJbnB1dCB2YWx1ZSB0aGF0IGNhbiBiZSBlaXRoZXIgYSBidWZmZXIgb3IgYSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gICBSZXR1cm5zIHRoZSBzdHJpbmcgZnJvbSBpbnB1dFxuICovXG5cblxudmFyIGdldFN0cmluZ0J1ZmZlciA9IGZ1bmN0aW9uIGdldFN0cmluZ0J1ZmZlcihidWZmZXIpIHtcbiAgcmV0dXJuIHR5cGVvZiBidWZmZXIud3JpdGUgPT09IFwiZnVuY3Rpb25cIiA/IGJ1ZmZlci50b1N0cmluZygpIDogYnVmZmVyO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSAoSGVscGVyKVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0VuZ2luZX1cbiAqIEBwcml2YXRlXG4gKi9cblxuXG5lbmdpbmUuY3JlYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBlbmdpbmUob3B0aW9ucyk7XG59O1xuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgYnVmZmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cblxuZW5naW5lLnBhcnNlRXZhbCA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSBuZXcgZW5naW5lKG9wdGlvbnMpO1xuICByZXR1cm4gc2VsZi5wYXJzZUV2YWwoYnVmZmVyKTtcbn07XG4vKipcbiAqIFBhcnNlIGFuIGV2YWx1YXRpbmcgbW9kZSBzdHJpbmcgKG5vIG5lZWQgdG8gb3BlbiBwaHAgdGFncylcbiAqIEBwYXJhbSB7U3RyaW5nfSBidWZmZXJcbiAqIEByZXR1cm4ge1Byb2dyYW19XG4gKi9cblxuXG5lbmdpbmUucHJvdG90eXBlLnBhcnNlRXZhbCA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgdGhpcy5sZXhlci5tb2RlX2V2YWwgPSB0cnVlO1xuICB0aGlzLmxleGVyLmFsbF90b2tlbnMgPSBmYWxzZTtcbiAgYnVmZmVyID0gZ2V0U3RyaW5nQnVmZmVyKGJ1ZmZlcik7XG4gIHJldHVybiB0aGlzLnBhcnNlci5wYXJzZShidWZmZXIsIFwiZXZhbFwiKTtcbn07XG4vKipcbiAqIFN0YXRpYyBmdW5jdGlvbiB0aGF0IHBhcnNlIGEgcGhwIGNvZGUgd2l0aCBvcGVuL2Nsb3NlIHRhZ3NcbiAqIEBwcml2YXRlXG4gKi9cblxuXG5lbmdpbmUucGFyc2VDb2RlID0gZnVuY3Rpb24gKGJ1ZmZlciwgZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKF90eXBlb2YoZmlsZW5hbWUpID09PSBcIm9iamVjdFwiICYmICFvcHRpb25zKSB7XG4gICAgLy8gcmV0cm8tY29tcGF0aWJpbGl0eVxuICAgIG9wdGlvbnMgPSBmaWxlbmFtZTtcbiAgICBmaWxlbmFtZSA9IFwidW5rbm93blwiO1xuICB9XG5cbiAgdmFyIHNlbGYgPSBuZXcgZW5naW5lKG9wdGlvbnMpO1xuICByZXR1cm4gc2VsZi5wYXJzZUNvZGUoYnVmZmVyLCBmaWxlbmFtZSk7XG59O1xuLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHBhcnNlIGEgcGhwIGNvZGUgd2l0aCBvcGVuL2Nsb3NlIHRhZ3NcbiAqXG4gKiBTYW1wbGUgY29kZSA6XG4gKiBgYGBwaHBcbiAqIDw/cGhwICR4ID0gMTtcbiAqIGBgYFxuICpcbiAqIFVzYWdlIDpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyc2VyID0gcmVxdWlyZSgncGhwLXBhcnNlcicpO1xuICogdmFyIHBocFBhcnNlciA9IG5ldyBwYXJzZXIoe1xuICogICAvLyBzb21lIG9wdGlvbnNcbiAqIH0pO1xuICogdmFyIGFzdCA9IHBocFBhcnNlci5wYXJzZUNvZGUoJy4uLnBocCBjb2RlLi4uJywgJ2Zvby5waHAnKTtcbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAtIFRoZSBjb2RlIHRvIGJlIHBhcnNlZFxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIC0gRmlsZW5hbWVcbiAqIEByZXR1cm4ge1Byb2dyYW19XG4gKi9cblxuXG5lbmdpbmUucHJvdG90eXBlLnBhcnNlQ29kZSA9IGZ1bmN0aW9uIChidWZmZXIsIGZpbGVuYW1lKSB7XG4gIHRoaXMubGV4ZXIubW9kZV9ldmFsID0gZmFsc2U7XG4gIHRoaXMubGV4ZXIuYWxsX3Rva2VucyA9IGZhbHNlO1xuICBidWZmZXIgPSBnZXRTdHJpbmdCdWZmZXIoYnVmZmVyKTtcbiAgcmV0dXJuIHRoaXMucGFyc2VyLnBhcnNlKGJ1ZmZlciwgZmlsZW5hbWUpO1xufTtcbi8qKlxuICogU3BsaXQgdGhlIGJ1ZmZlciBpbnRvIHRva2Vuc1xuICogQHByaXZhdGVcbiAqL1xuXG5cbmVuZ2luZS50b2tlbkdldEFsbCA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSBuZXcgZW5naW5lKG9wdGlvbnMpO1xuICByZXR1cm4gc2VsZi50b2tlbkdldEFsbChidWZmZXIpO1xufTtcbi8qKlxuICogRXh0cmFjdCB0b2tlbnMgZnJvbSB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqID4gTm90ZSB0aGF0IHRoZSBvdXRwdXQgdG9rZW5zIGFyZSAqU1RSSUNMWSogc2ltaWxhciB0byBQSFAgZnVuY3Rpb24gYHRva2VuX2dldF9hbGxgXG4gKiBAcGFyYW0ge1N0cmluZ30gYnVmZmVyXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX0gLSBFYWNoIGl0ZW0gY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IHdpdGggZm9sbG93aW5nIGluZm9ybWF0aW9ucyBbdG9rZW5fbmFtZSwgdGV4dCwgbGluZV9udW1iZXJdXG4gKi9cblxuXG5lbmdpbmUucHJvdG90eXBlLnRva2VuR2V0QWxsID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICB0aGlzLmxleGVyLm1vZGVfZXZhbCA9IGZhbHNlO1xuICB0aGlzLmxleGVyLmFsbF90b2tlbnMgPSB0cnVlO1xuICBidWZmZXIgPSBnZXRTdHJpbmdCdWZmZXIoYnVmZmVyKTtcbiAgdmFyIEVPRiA9IHRoaXMubGV4ZXIuRU9GO1xuICB2YXIgbmFtZXMgPSB0aGlzLnRva2Vucy52YWx1ZXM7XG4gIHRoaXMubGV4ZXIuc2V0SW5wdXQoYnVmZmVyKTtcbiAgdmFyIHRva2VuID0gdGhpcy5sZXhlci5sZXgoKSB8fCBFT0Y7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAodG9rZW4gIT0gRU9GKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5sZXhlci55eXRleHQ7XG5cbiAgICBpZiAobmFtZXMuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG4gICAgICBlbnRyeSA9IFtuYW1lc1t0b2tlbl0sIGVudHJ5LCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lXTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgdG9rZW4gPSB0aGlzLmxleGVyLmxleCgpIHx8IEVPRjtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59OyAvLyBleHBvcnRzIHRoZSBmdW5jdGlvblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZW5naW5lOyAvLyBtYWtlcyBsaWJyYXJpZXMgcHVibGljXG5cbm1vZHVsZS5leHBvcnRzLnRva2VucyA9IHRva2Vucztcbm1vZHVsZS5leHBvcnRzLmxleGVyID0gbGV4ZXI7XG5tb2R1bGUuZXhwb3J0cy5BU1QgPSBBU1Q7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5tb2R1bGUuZXhwb3J0cy5jb21iaW5lID0gY29tYmluZTsgLy8gYWxsb3cgdGhlIGRlZmF1bHQgZXhwb3J0IGluIGluZGV4LmQudHNcblxubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZW5naW5lO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgcGhwIGxleGVyLiBJdCB3aWxsIHRva2VuaXplIHRoZSBzdHJpbmcgZm9yIGhlbHBpbmcgdGhlXG4gKiBwYXJzZXIgdG8gYnVpbGQgdGhlIEFTVCBmcm9tIGl0cyBncmFtbWFyLlxuICpcbiAqIEBjbGFzc1xuICogQHByb3BlcnR5IHtJbnRlZ2VyfSBFT0ZcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYWxsX3Rva2VucyBkZWZpbmVzIGlmIGFsbCB0b2tlbnMgbXVzdCBiZSByZXRyaWV2ZWQgKHVzZWQgYnkgdG9rZW5fZ2V0X2FsbCBvbmx5KVxuICogQHByb3BlcnR5IHtCb29sZWFufSBjb21tZW50X3Rva2VucyBleHRyYWN0cyBjb21tZW50cyB0b2tlbnNcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gbW9kZV9ldmFsIGVuYWJsZXMgdGhlIGV2YWxkIG1vZGUgKGlnbm9yZSBvcGVuaW5nIHRhZ3MpXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGFzcF90YWdzIGRpc2FibGVzIGJ5IGRlZmF1bHQgYXNwIHRhZ3MgbW9kZVxuICogQHByb3BlcnR5IHtCb29sZWFufSBzaG9ydF90YWdzIGVuYWJsZXMgYnkgZGVmYXVsdCBzaG9ydCB0YWdzIG1vZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBrZXl3b3JkcyBMaXN0IG9mIHBocCBrZXl3b3JkXG4gKiBAcHJvcGVydHkge09iamVjdH0gY2FzdEtleXdvcmRzIExpc3Qgb2YgcGhwIGtleXdvcmRzIGZvciB0eXBlIGNhc3RpbmdcbiAqL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBsZXhlciA9IGZ1bmN0aW9uIGxleGVyKGVuZ2luZSkge1xuICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgdGhpcy50b2sgPSB0aGlzLmVuZ2luZS50b2tlbnMubmFtZXM7XG4gIHRoaXMuRU9GID0gMTtcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICB0aGlzLmFsbF90b2tlbnMgPSB0cnVlO1xuICB0aGlzLmNvbW1lbnRfdG9rZW5zID0gZmFsc2U7XG4gIHRoaXMubW9kZV9ldmFsID0gZmFsc2U7XG4gIHRoaXMuYXNwX3RhZ3MgPSBmYWxzZTtcbiAgdGhpcy5zaG9ydF90YWdzID0gZmFsc2U7XG4gIHRoaXMudmVyc2lvbiA9IDcwNDtcbiAgdGhpcy55eXByZXZjb2wgPSAwO1xuICB0aGlzLmtleXdvcmRzID0ge1xuICAgIF9fY2xhc3NfXzogdGhpcy50b2suVF9DTEFTU19DLFxuICAgIF9fdHJhaXRfXzogdGhpcy50b2suVF9UUkFJVF9DLFxuICAgIF9fZnVuY3Rpb25fXzogdGhpcy50b2suVF9GVU5DX0MsXG4gICAgX19tZXRob2RfXzogdGhpcy50b2suVF9NRVRIT0RfQyxcbiAgICBfX2xpbmVfXzogdGhpcy50b2suVF9MSU5FLFxuICAgIF9fZmlsZV9fOiB0aGlzLnRvay5UX0ZJTEUsXG4gICAgX19kaXJfXzogdGhpcy50b2suVF9ESVIsXG4gICAgX19uYW1lc3BhY2VfXzogdGhpcy50b2suVF9OU19DLFxuICAgIGV4aXQ6IHRoaXMudG9rLlRfRVhJVCxcbiAgICBkaWU6IHRoaXMudG9rLlRfRVhJVCxcbiAgICBcImZ1bmN0aW9uXCI6IHRoaXMudG9rLlRfRlVOQ1RJT04sXG4gICAgXCJjb25zdFwiOiB0aGlzLnRvay5UX0NPTlNULFxuICAgIFwicmV0dXJuXCI6IHRoaXMudG9rLlRfUkVUVVJOLFxuICAgIFwidHJ5XCI6IHRoaXMudG9rLlRfVFJZLFxuICAgIFwiY2F0Y2hcIjogdGhpcy50b2suVF9DQVRDSCxcbiAgICBcImZpbmFsbHlcIjogdGhpcy50b2suVF9GSU5BTExZLFxuICAgIFwidGhyb3dcIjogdGhpcy50b2suVF9USFJPVyxcbiAgICBcImlmXCI6IHRoaXMudG9rLlRfSUYsXG4gICAgZWxzZWlmOiB0aGlzLnRvay5UX0VMU0VJRixcbiAgICBlbmRpZjogdGhpcy50b2suVF9FTkRJRixcbiAgICBcImVsc2VcIjogdGhpcy50b2suVF9FTFNFLFxuICAgIFwid2hpbGVcIjogdGhpcy50b2suVF9XSElMRSxcbiAgICBlbmR3aGlsZTogdGhpcy50b2suVF9FTkRXSElMRSxcbiAgICBcImRvXCI6IHRoaXMudG9rLlRfRE8sXG4gICAgXCJmb3JcIjogdGhpcy50b2suVF9GT1IsXG4gICAgZW5kZm9yOiB0aGlzLnRvay5UX0VOREZPUixcbiAgICBmb3JlYWNoOiB0aGlzLnRvay5UX0ZPUkVBQ0gsXG4gICAgZW5kZm9yZWFjaDogdGhpcy50b2suVF9FTkRGT1JFQUNILFxuICAgIGRlY2xhcmU6IHRoaXMudG9rLlRfREVDTEFSRSxcbiAgICBlbmRkZWNsYXJlOiB0aGlzLnRvay5UX0VORERFQ0xBUkUsXG4gICAgXCJpbnN0YW5jZW9mXCI6IHRoaXMudG9rLlRfSU5TVEFOQ0VPRixcbiAgICBhczogdGhpcy50b2suVF9BUyxcbiAgICBcInN3aXRjaFwiOiB0aGlzLnRvay5UX1NXSVRDSCxcbiAgICBlbmRzd2l0Y2g6IHRoaXMudG9rLlRfRU5EU1dJVENILFxuICAgIFwiY2FzZVwiOiB0aGlzLnRvay5UX0NBU0UsXG4gICAgXCJkZWZhdWx0XCI6IHRoaXMudG9rLlRfREVGQVVMVCxcbiAgICBcImJyZWFrXCI6IHRoaXMudG9rLlRfQlJFQUssXG4gICAgXCJjb250aW51ZVwiOiB0aGlzLnRvay5UX0NPTlRJTlVFLFxuICAgIFwiZ290b1wiOiB0aGlzLnRvay5UX0dPVE8sXG4gICAgZWNobzogdGhpcy50b2suVF9FQ0hPLFxuICAgIHByaW50OiB0aGlzLnRvay5UX1BSSU5ULFxuICAgIFwiY2xhc3NcIjogdGhpcy50b2suVF9DTEFTUyxcbiAgICBcImludGVyZmFjZVwiOiB0aGlzLnRvay5UX0lOVEVSRkFDRSxcbiAgICB0cmFpdDogdGhpcy50b2suVF9UUkFJVCxcbiAgICBcImV4dGVuZHNcIjogdGhpcy50b2suVF9FWFRFTkRTLFxuICAgIFwiaW1wbGVtZW50c1wiOiB0aGlzLnRvay5UX0lNUExFTUVOVFMsXG4gICAgXCJuZXdcIjogdGhpcy50b2suVF9ORVcsXG4gICAgY2xvbmU6IHRoaXMudG9rLlRfQ0xPTkUsXG4gICAgXCJ2YXJcIjogdGhpcy50b2suVF9WQVIsXG4gICAgZXZhbDogdGhpcy50b2suVF9FVkFMLFxuICAgIGluY2x1ZGU6IHRoaXMudG9rLlRfSU5DTFVERSxcbiAgICBpbmNsdWRlX29uY2U6IHRoaXMudG9rLlRfSU5DTFVERV9PTkNFLFxuICAgIHJlcXVpcmU6IHRoaXMudG9rLlRfUkVRVUlSRSxcbiAgICByZXF1aXJlX29uY2U6IHRoaXMudG9rLlRfUkVRVUlSRV9PTkNFLFxuICAgIG5hbWVzcGFjZTogdGhpcy50b2suVF9OQU1FU1BBQ0UsXG4gICAgdXNlOiB0aGlzLnRvay5UX1VTRSxcbiAgICBpbnN0ZWFkb2Y6IHRoaXMudG9rLlRfSU5TVEVBRE9GLFxuICAgIGdsb2JhbDogdGhpcy50b2suVF9HTE9CQUwsXG4gICAgaXNzZXQ6IHRoaXMudG9rLlRfSVNTRVQsXG4gICAgZW1wdHk6IHRoaXMudG9rLlRfRU1QVFksXG4gICAgX19oYWx0X2NvbXBpbGVyOiB0aGlzLnRvay5UX0hBTFRfQ09NUElMRVIsXG4gICAgXCJzdGF0aWNcIjogdGhpcy50b2suVF9TVEFUSUMsXG4gICAgXCJhYnN0cmFjdFwiOiB0aGlzLnRvay5UX0FCU1RSQUNULFxuICAgIFwiZmluYWxcIjogdGhpcy50b2suVF9GSU5BTCxcbiAgICBcInByaXZhdGVcIjogdGhpcy50b2suVF9QUklWQVRFLFxuICAgIFwicHJvdGVjdGVkXCI6IHRoaXMudG9rLlRfUFJPVEVDVEVELFxuICAgIFwicHVibGljXCI6IHRoaXMudG9rLlRfUFVCTElDLFxuICAgIHVuc2V0OiB0aGlzLnRvay5UX1VOU0VULFxuICAgIGxpc3Q6IHRoaXMudG9rLlRfTElTVCxcbiAgICBhcnJheTogdGhpcy50b2suVF9BUlJBWSxcbiAgICBjYWxsYWJsZTogdGhpcy50b2suVF9DQUxMQUJMRSxcbiAgICBvcjogdGhpcy50b2suVF9MT0dJQ0FMX09SLFxuICAgIGFuZDogdGhpcy50b2suVF9MT0dJQ0FMX0FORCxcbiAgICB4b3I6IHRoaXMudG9rLlRfTE9HSUNBTF9YT1JcbiAgfTtcbiAgdGhpcy5jYXN0S2V5d29yZHMgPSB7XG4gICAgXCJpbnRcIjogdGhpcy50b2suVF9JTlRfQ0FTVCxcbiAgICBpbnRlZ2VyOiB0aGlzLnRvay5UX0lOVF9DQVNULFxuICAgIHJlYWw6IHRoaXMudG9rLlRfRE9VQkxFX0NBU1QsXG4gICAgXCJkb3VibGVcIjogdGhpcy50b2suVF9ET1VCTEVfQ0FTVCxcbiAgICBcImZsb2F0XCI6IHRoaXMudG9rLlRfRE9VQkxFX0NBU1QsXG4gICAgc3RyaW5nOiB0aGlzLnRvay5UX1NUUklOR19DQVNULFxuICAgIGJpbmFyeTogdGhpcy50b2suVF9TVFJJTkdfQ0FTVCxcbiAgICBhcnJheTogdGhpcy50b2suVF9BUlJBWV9DQVNULFxuICAgIG9iamVjdDogdGhpcy50b2suVF9PQkpFQ1RfQ0FTVCxcbiAgICBib29sOiB0aGlzLnRvay5UX0JPT0xfQ0FTVCxcbiAgICBcImJvb2xlYW5cIjogdGhpcy50b2suVF9CT09MX0NBU1QsXG4gICAgdW5zZXQ6IHRoaXMudG9rLlRfVU5TRVRfQ0FTVFxuICB9O1xufTtcbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgbGV4ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGlucHV0XG4gKi9cblxuXG5sZXhlci5wcm90b3R5cGUuc2V0SW5wdXQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgdGhpcy5zaXplID0gaW5wdXQubGVuZ3RoO1xuICB0aGlzLnl5bGluZW5vID0gMTtcbiAgdGhpcy5vZmZzZXQgPSAwO1xuICB0aGlzLnl5cHJldmNvbCA9IDA7XG4gIHRoaXMueXl0ZXh0ID0gXCJcIjtcbiAgdGhpcy55eWxsb2MgPSB7XG4gICAgZmlyc3Rfb2Zmc2V0OiAwLFxuICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgZmlyc3RfY29sdW1uOiAwLFxuICAgIHByZXZfb2Zmc2V0OiAwLFxuICAgIHByZXZfbGluZTogMSxcbiAgICBwcmV2X2NvbHVtbjogMCxcbiAgICBsYXN0X2xpbmU6IDEsXG4gICAgbGFzdF9jb2x1bW46IDBcbiAgfTtcbiAgdGhpcy50b2tlbnMgPSBbXTtcblxuICBpZiAodGhpcy52ZXJzaW9uID4gNzAzKSB7XG4gICAgdGhpcy5rZXl3b3Jkcy5mbiA9IHRoaXMudG9rLlRfRk47XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHRoaXMua2V5d29yZHMuZm47XG4gIH1cblxuICB0aGlzLmRvbmUgPSB0aGlzLm9mZnNldCA+PSB0aGlzLnNpemU7XG5cbiAgaWYgKCF0aGlzLmFsbF90b2tlbnMgJiYgdGhpcy5tb2RlX2V2YWwpIHtcbiAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gW1wiSU5JVElBTFwiXTtcbiAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbXTtcbiAgICB0aGlzLmJlZ2luKFwiSU5JVElBTFwiKTtcbiAgfSAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi85OTllMzJiNjVhOGE0YmI1OWUyN2U1MzhmYTY4ZmZhZTRiOTlkODYzL1plbmQvemVuZF9sYW5ndWFnZV9zY2FubmVyLmgjTDU5XG4gIC8vIFVzZWQgZm9yIGhlcmVkb2MgYW5kIG5vd2RvY1xuXG5cbiAgdGhpcy5oZXJlZG9jX2xhYmVsID0ge1xuICAgIGxhYmVsOiBcIlwiLFxuICAgIGxlbmd0aDogMCxcbiAgICBpbmRlbnRhdGlvbjogMCxcbiAgICBpbmRlbnRhdGlvbl91c2VzX3NwYWNlczogZmFsc2UsXG4gICAgZmluaXNoZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogdGhpcyB1c2VkIGZvciBwYXJzZXIgdG8gZGV0ZW1pbmUgdGhlIGlmIGN1cnJlbnQgbm9kZSBzZWdtZW50IGlzIGZpcnN0IGVuY2FwcyBub2RlLlxuICAgICAqIGlmIHR1cmUsIHRoZSBpbmRlbnRhdGlvbiB3aWxsIHJlbW92ZSBmcm9tIHRoZSBiZWdpbmluZy4gYW5kIGlmIGZhbHNlLCB0aGUgcHJldiBub2RlXG4gICAgICogbWlnaHQgYmUgYSB2YXJpYWJsZSAnfScgLGFuZCB0aGUgbGVhZGluZyBzcGFjZXMgc2hvdWxkIG5vdCBiZSByZW1vdmVkIHV0aWwgbWVldCB0aGVcbiAgICAgKiBmaXJzdCBcXG5cbiAgICAgKi9cbiAgICBmaXJzdF9lbmNhcHNfbm9kZTogZmFsc2UsXG4gICAgLy8gZm9yIGJhY2t3YXJkIGNvbXBhdGlibGVcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB0aGlzLmxhYmVsO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuICovXG5cblxubGV4ZXIucHJvdG90eXBlLmlucHV0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2ggPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07XG4gIGlmICghY2gpIHJldHVybiBcIlwiO1xuICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgdGhpcy5vZmZzZXQrKztcblxuICBpZiAoY2ggPT09IFwiXFxyXCIgJiYgdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIlxcblwiKSB7XG4gICAgdGhpcy55eXRleHQgKz0gXCJcXG5cIjtcbiAgICB0aGlzLm9mZnNldCsrO1xuICB9XG5cbiAgaWYgKGNoID09PSBcIlxcblwiIHx8IGNoID09PSBcIlxcclwiKSB7XG4gICAgdGhpcy55eWxsb2MubGFzdF9saW5lID0gKyt0aGlzLnl5bGluZW5vO1xuICAgIHRoaXMueXlwcmV2Y29sID0gdGhpcy55eWxsb2MubGFzdF9jb2x1bW47XG4gICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gIH1cblxuICByZXR1cm4gY2g7XG59O1xuLyoqXG4gKiByZXZlcnQgZWF0aW5nIHNwZWNpZmllZCBzaXplXG4gKi9cblxuXG5sZXhlci5wcm90b3R5cGUudW5wdXQgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAoc2l6ZSA9PT0gMSkge1xuICAgIC8vIDEgY2hhciB1bnB1dCAobW9zdCBjYXNlcylcbiAgICB0aGlzLm9mZnNldC0tO1xuXG4gICAgaWYgKHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCJcXG5cIiAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdID09PSBcIlxcclwiKSB7XG4gICAgICB0aGlzLm9mZnNldC0tO1xuICAgICAgc2l6ZSsrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiXFxyXCIgfHwgdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIlxcblwiKSB7XG4gICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUtLTtcbiAgICAgIHRoaXMueXlsaW5lbm8tLTtcbiAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gdGhpcy55eXByZXZjb2w7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLS07XG4gICAgfVxuXG4gICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHJpbmcoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gc2l6ZSk7XG4gIH0gZWxzZSBpZiAoc2l6ZSA+IDApIHtcbiAgICB0aGlzLm9mZnNldCAtPSBzaXplO1xuXG4gICAgaWYgKHNpemUgPCB0aGlzLnl5dGV4dC5sZW5ndGgpIHtcbiAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyaW5nKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIHNpemUpOyAvLyByZS1jYWxjdWxhdGUgcG9zaXRpb25cblxuICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lID0gdGhpcy55eWxsb2MuZmlyc3RfbGluZTtcbiAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gdGhpcy55eXByZXZjb2wgPSB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy55eXRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLnl5dGV4dFtpXTtcblxuICAgICAgICBpZiAoYyA9PT0gXCJcXHJcIikge1xuICAgICAgICAgIGMgPSB0aGlzLnl5dGV4dFsrK2ldO1xuICAgICAgICAgIHRoaXMueXlwcmV2Y29sID0gdGhpcy55eWxsb2MubGFzdF9jb2x1bW47XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSAwO1xuXG4gICAgICAgICAgaWYgKGMgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmIChjID09PSBcIlxcclwiKSB7XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCJcXG5cIikge1xuICAgICAgICAgIHRoaXMueXlwcmV2Y29sID0gdGhpcy55eWxsb2MubGFzdF9jb2x1bW47XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsbG9jLmxhc3RfbGluZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVzZXQgZnVsbCB0ZXh0XG4gICAgICB0aGlzLnl5dGV4dCA9IFwiXCI7XG4gICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUgPSB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxsb2MuZmlyc3RfbGluZTtcbiAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uID0gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTsgLy8gY2hlY2sgaWYgdGhlIHRleHQgbWF0Y2hlc1xuXG5cbmxleGVyLnByb3RvdHlwZS50cnlNYXRjaCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0ID09PSB0aGlzLmFoZWFkKHRleHQubGVuZ3RoKTtcbn07IC8vIGNoZWNrIGlmIHRoZSB0ZXh0IG1hdGNoZXNcblxuXG5sZXhlci5wcm90b3R5cGUudHJ5TWF0Y2hDYXNlbGVzcyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0ID09PSB0aGlzLmFoZWFkKHRleHQubGVuZ3RoKS50b0xvd2VyQ2FzZSgpO1xufTsgLy8gbG9vayBhaGVhZFxuXG5cbmxleGVyLnByb3RvdHlwZS5haGVhZCA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHZhciB0ZXh0ID0gdGhpcy5faW5wdXQuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIHNpemUpO1xuXG4gIGlmICh0ZXh0W3RleHQubGVuZ3RoIC0gMV0gPT09IFwiXFxyXCIgJiYgdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgKyBzaXplICsgMV0gPT09IFwiXFxuXCIpIHtcbiAgICB0ZXh0ICs9IFwiXFxuXCI7XG4gIH1cblxuICByZXR1cm4gdGV4dDtcbn07IC8vIGNvbnN1bWUgdGhlIHNwZWNpZmllZCBzaXplXG5cblxubGV4ZXIucHJvdG90eXBlLmNvbnN1bWUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHZhciBjaCA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcbiAgICBpZiAoIWNoKSBicmVhaztcbiAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICB0aGlzLm9mZnNldCsrO1xuXG4gICAgaWYgKGNoID09PSBcIlxcclwiICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCJcXG5cIikge1xuICAgICAgdGhpcy55eXRleHQgKz0gXCJcXG5cIjtcbiAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSBcIlxcblwiIHx8IGNoID09PSBcIlxcclwiKSB7XG4gICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUgPSArK3RoaXMueXlsaW5lbm87XG4gICAgICB0aGlzLnl5cHJldmNvbCA9IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uO1xuICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBzdGF0ZVxuICovXG5cblxubGV4ZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcbiAgICB5eXByZXZjb2w6IHRoaXMueXlwcmV2Y29sLFxuICAgIHl5bGxvYzoge1xuICAgICAgZmlyc3Rfb2Zmc2V0OiB0aGlzLnl5bGxvYy5maXJzdF9vZmZzZXQsXG4gICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICBsYXN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtblxuICAgIH0sXG4gICAgaGVyZWRvY19sYWJlbDogdGhpcy5oZXJlZG9jX2xhYmVsXG4gIH07XG59O1xuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IGxleGVyIHN0YXRlXG4gKi9cblxuXG5sZXhlci5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdGhpcy55eXRleHQgPSBzdGF0ZS55eXRleHQ7XG4gIHRoaXMub2Zmc2V0ID0gc3RhdGUub2Zmc2V0O1xuICB0aGlzLnl5bGluZW5vID0gc3RhdGUueXlsaW5lbm87XG4gIHRoaXMueXlwcmV2Y29sID0gc3RhdGUueXlwcmV2Y29sO1xuICB0aGlzLnl5bGxvYyA9IHN0YXRlLnl5bGxvYztcblxuICBpZiAoc3RhdGUuaGVyZWRvY19sYWJlbCkge1xuICAgIHRoaXMuaGVyZWRvY19sYWJlbCA9IHN0YXRlLmhlcmVkb2NfbGFiZWw7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07IC8vIHByZXBlbmQgbmV4dCB0b2tlblxuXG5cbmxleGVyLnByb3RvdHlwZS5hcHBlbmRUb2tlbiA9IGZ1bmN0aW9uICh2YWx1ZSwgYWhlYWQpIHtcbiAgdGhpcy50b2tlbnMucHVzaChbdmFsdWUsIGFoZWFkXSk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxuXG5cbmxleGVyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMueXlsbG9jLnByZXZfb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gIHRoaXMueXlsbG9jLnByZXZfbGluZSA9IHRoaXMueXlsbG9jLmxhc3RfbGluZTtcbiAgdGhpcy55eWxsb2MucHJldl9jb2x1bW4gPSB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbjtcbiAgdmFyIHRva2VuID0gdGhpcy5uZXh0KCkgfHwgdGhpcy5sZXgoKTtcblxuICBpZiAoIXRoaXMuYWxsX3Rva2Vucykge1xuICAgIHdoaWxlICh0b2tlbiA9PT0gdGhpcy50b2suVF9XSElURVNQQUNFIHx8IC8vIGlnbm9yZSB3aGl0ZSBzcGFjZVxuICAgICF0aGlzLmNvbW1lbnRfdG9rZW5zICYmICh0b2tlbiA9PT0gdGhpcy50b2suVF9DT01NRU5UIHx8IC8vIGlnbm9yZSBzaW5nbGUgbGluZXMgY29tbWVudHNcbiAgICB0b2tlbiA9PT0gdGhpcy50b2suVF9ET0NfQ09NTUVOVCkgfHwgLy8gaWdub3JlIGRvYyBjb21tZW50c1xuICAgIC8vIGlnbm9yZSBvcGVuIHRhZ3NcbiAgICB0b2tlbiA9PT0gdGhpcy50b2suVF9PUEVOX1RBRykge1xuICAgICAgdG9rZW4gPSB0aGlzLm5leHQoKSB8fCB0aGlzLmxleCgpO1xuICAgIH1cblxuICAgIGlmICh0b2tlbiA9PSB0aGlzLnRvay5UX09QRU5fVEFHX1dJVEhfRUNITykge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvN2ZmMTg2NDM0ZTgyZWU3YmU3YzU5ZDBkYjlhOTc2NjQxY2Y3YjA5Yy9aZW5kL3plbmRfY29tcGlsZS5jI0wxNjgzXG4gICAgICAvLyBvcGVuIHRhZyB3aXRoIGVjaG8gc3RhdGVtZW50XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9FQ0hPO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09IHRoaXMudG9rLlRfQ0xPU0VfVEFHKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi83ZmYxODY0MzRlODJlZTdiZTdjNTlkMGRiOWE5NzY2NDFjZjdiMDljL1plbmQvemVuZF9jb21waWxlLmMjTDE2ODBcbiAgICAgIHJldHVybiBcIjtcIjtcbiAgICAgIC8qIGltcGxpY2l0IDsgKi9cbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMueXlsbG9jLnByZXZfb2Zmc2V0KSB7XG4gICAgdGhpcy55eWxsb2MucHJldl9vZmZzZXQgPSB0aGlzLnl5bGxvYy5maXJzdF9vZmZzZXQ7XG4gICAgdGhpcy55eWxsb2MucHJldl9saW5lID0gdGhpcy55eWxsb2MuZmlyc3RfbGluZTtcbiAgICB0aGlzLnl5bGxvYy5wcmV2X2NvbHVtbiA9IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbjtcbiAgfVxuICAvKmVsc2UgaWYgKHRoaXMueXlsbG9jLnByZXZfb2Zmc2V0ID09PSB0aGlzLm9mZnNldCAmJiB0aGlzLm9mZnNldCAhPT0gdGhpcy5zaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIEAgJyArIHRoaXMub2Zmc2V0ICsgJyAvICcgKyB0aGlzLnNpemUpO1xuICB9Ki9cblxuXG4gIHJldHVybiB0b2tlbjtcbn07IC8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG5cblxubGV4ZXIucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24gKGNvbmRpdGlvbikge1xuICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgdGhpcy5jdXJDb25kaXRpb24gPSBjb25kaXRpb247XG4gIHRoaXMuc3RhdGVDYiA9IHRoaXNbXCJtYXRjaFwiICsgY29uZGl0aW9uXTtcblxuICBpZiAodHlwZW9mIHRoaXMuc3RhdGVDYiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmRlZmluZWQgY29uZGl0aW9uIHN0YXRlIFwiJyArIGNvbmRpdGlvbiArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvbiBzdGFja1xuXG5cbmxleGVyLnByb3RvdHlwZS5wb3BTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gIHZhciBjb25kaXRpb24gPSBuID4gMCA/IHRoaXMuY29uZGl0aW9uU3RhY2sucG9wKCkgOiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICB0aGlzLmN1ckNvbmRpdGlvbiA9IHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXTtcbiAgdGhpcy5zdGF0ZUNiID0gdGhpc1tcIm1hdGNoXCIgKyB0aGlzLmN1ckNvbmRpdGlvbl07XG5cbiAgaWYgKHR5cGVvZiB0aGlzLnN0YXRlQ2IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIGNvbmRpdGlvbiBzdGF0ZSBcIicgKyB0aGlzLmN1ckNvbmRpdGlvbiArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIGNvbmRpdGlvbjtcbn07IC8vIHJldHVybiBuZXh0IG1hdGNoIGluIGlucHV0XG5cblxubGV4ZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b2tlbjtcblxuICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMueXlsbG9jLmZpcnN0X29mZnNldCA9IHRoaXMub2Zmc2V0O1xuICB0aGlzLnl5bGxvYy5maXJzdF9saW5lID0gdGhpcy55eWxsb2MubGFzdF9saW5lO1xuICB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gPSB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbjtcbiAgdGhpcy55eXRleHQgPSBcIlwiO1xuXG4gIGlmICh0aGlzLmRvbmUpIHtcbiAgICB0aGlzLnl5bGxvYy5wcmV2X29mZnNldCA9IHRoaXMueXlsbG9jLmZpcnN0X29mZnNldDtcbiAgICB0aGlzLnl5bGxvYy5wcmV2X2xpbmUgPSB0aGlzLnl5bGxvYy5maXJzdF9saW5lO1xuICAgIHRoaXMueXlsbG9jLnByZXZfY29sdW1uID0gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uO1xuICAgIHJldHVybiB0aGlzLkVPRjtcbiAgfVxuXG4gIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgdG9rZW4gPSB0aGlzLnRva2Vucy5zaGlmdCgpO1xuXG4gICAgaWYgKF90eXBlb2YodG9rZW5bMV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHRva2VuWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb25zdW1lKHRva2VuWzFdKTtcbiAgICB9XG5cbiAgICB0b2tlbiA9IHRva2VuWzBdO1xuICB9IGVsc2Uge1xuICAgIHRva2VuID0gdGhpcy5zdGF0ZUNiLmFwcGx5KHRoaXMsIFtdKTtcbiAgfVxuXG4gIGlmICh0aGlzLm9mZnNldCA+PSB0aGlzLnNpemUgJiYgdGhpcy50b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgdmFyIHROYW1lID0gdG9rZW47XG5cbiAgICBpZiAodHlwZW9mIHROYW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0TmFtZSA9IHRoaXMuZW5naW5lLnRva2Vucy52YWx1ZXNbdE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0TmFtZSA9ICdcIicgKyB0TmFtZSArICdcIic7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IodE5hbWUgKyBcIlxcdGZyb20gXCIgKyB0aGlzLnl5bGxvYy5maXJzdF9saW5lICsgXCIsXCIgKyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gKyBcIlxcdCAtIHRvIFwiICsgdGhpcy55eWxsb2MubGFzdF9saW5lICsgXCIsXCIgKyB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArICdcXHRcIicgKyB0aGlzLnl5dGV4dCArICdcIicpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG4gICAgY29uc29sZS5lcnJvcihlLnN0YWNrKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07IC8vIGV4dGVuZHMgdGhlIGxleGVyIHdpdGggc3RhdGVzXG5cblxuW19fd2VicGFja19yZXF1aXJlX18oMTQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxNiksIF9fd2VicGFja19yZXF1aXJlX18oMTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyMCksIF9fd2VicGFja19yZXF1aXJlX18oMjEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKV0uZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG4gIGZvciAodmFyIGsgaW4gZXh0KSB7XG4gICAgbGV4ZXIucHJvdG90eXBlW2tdID0gZXh0W2tdO1xuICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gbGV4ZXI7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIFJlYWRzIGEgc2luZ2xlIGxpbmUgY29tbWVudFxuICAgKi9cbiAgVF9DT01NRU5UOiBmdW5jdGlvbiBUX0NPTU1FTlQoKSB7XG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmIChjaCA9PT0gXCJcXG5cIiB8fCBjaCA9PT0gXCJcXHJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DT01NRU5UO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCI/XCIgJiYgIXRoaXMuYXNwVGFnTW9kZSAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPlwiKSB7XG4gICAgICAgIHRoaXMudW5wdXQoMSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NPTU1FTlQ7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIiVcIiAmJiB0aGlzLmFzcFRhZ01vZGUgJiYgdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIj5cIikge1xuICAgICAgICB0aGlzLnVucHV0KDEpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DT01NRU5UO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRvay5UX0NPTU1FTlQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJlaGF2aW91ciA6IGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2Vfc2Nhbm5lci5sI0wxOTI3XG4gICAqL1xuICBUX0RPQ19DT01NRU5UOiBmdW5jdGlvbiBUX0RPQ19DT01NRU5UKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTtcbiAgICB2YXIgdG9rZW4gPSB0aGlzLnRvay5UX0NPTU1FTlQ7XG5cbiAgICBpZiAoY2ggPT09IFwiKlwiKSB7XG4gICAgICAvLyBzdGFydGVkIHdpdGggJy8qJyAsIGNoZWNrIGlzIG5leHQgaXMgJyonXG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNfV0hJVEVTUEFDRSgpKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIG5leHQgaXMgV0hJVEVTUEFDRVxuICAgICAgICB0b2tlbiA9IHRoaXMudG9rLlRfRE9DX0NPTU1FTlQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gXCIvXCIpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bnB1dCgxKTsgLy8gcmVzZXRcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAoY2ggPT09IFwiKlwiICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCIvXCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmV4dElOSVRJQUw6IGZ1bmN0aW9uIG5leHRJTklUSUFMKCkge1xuICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCA+IDEgJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOSVRJQUxcIikge1xuICAgICAgLy8gUmV0dXJuIHRvIEhFUkVET0MvU1RfRE9VQkxFX1FVT1RFUyBtb2RlXG4gICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmVnaW4oXCJTVF9JTl9TQ1JJUFRJTkdcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG1hdGNoSU5JVElBTDogZnVuY3Rpb24gbWF0Y2hJTklUSUFMKCkge1xuICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAoY2ggPT0gXCI8XCIpIHtcbiAgICAgICAgY2ggPSB0aGlzLmFoZWFkKDEpO1xuXG4gICAgICAgIGlmIChjaCA9PSBcIj9cIikge1xuICAgICAgICAgIGlmICh0aGlzLnRyeU1hdGNoKFwiPz1cIikpIHtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMSkuYXBwZW5kVG9rZW4odGhpcy50b2suVF9PUEVOX1RBR19XSVRIX0VDSE8sIDMpLm5leHRJTklUSUFMKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJ5TWF0Y2hDYXNlbGVzcyhcIj9waHBcIikpIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgKyA0XTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSBcIiBcIiB8fCBjaCA9PT0gXCJcXHRcIiB8fCBjaCA9PT0gXCJcXG5cIiB8fCBjaCA9PT0gXCJcXHJcIikge1xuICAgICAgICAgICAgICB0aGlzLnVucHV0KDEpLmFwcGVuZFRva2VuKHRoaXMudG9rLlRfT1BFTl9UQUcsIDYpLm5leHRJTklUSUFMKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnNob3J0X3RhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMSkuYXBwZW5kVG9rZW4odGhpcy50b2suVF9PUEVOX1RBRywgMikubmV4dElOSVRJQUwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFzcF90YWdzICYmIGNoID09IFwiJVwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJ5TWF0Y2goXCIlPVwiKSkge1xuICAgICAgICAgICAgdGhpcy5hc3BUYWdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMSkuYXBwZW5kVG9rZW4odGhpcy50b2suVF9PUEVOX1RBR19XSVRIX0VDSE8sIDMpLm5leHRJTklUSUFMKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3BUYWdNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMSkuYXBwZW5kVG9rZW4odGhpcy50b2suVF9PUEVOX1RBRywgMikubmV4dElOSVRJQUwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnl5dGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9JTkxJTkVfSFRNTDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7LyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuXG52YXIgTUFYX0xFTkdUSF9PRl9MT05HID0gMTA7XG52YXIgbG9uZ19taW5fZGlnaXRzID0gXCIyMTQ3NDgzNjQ4XCI7XG5cbmlmIChwcm9jZXNzLmFyY2ggPT0gXCJ4NjRcIikge1xuICBNQVhfTEVOR1RIX09GX0xPTkcgPSAxOTtcbiAgbG9uZ19taW5fZGlnaXRzID0gXCI5MjIzMzcyMDM2ODU0Nzc1ODA4XCI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25zdW1lX05VTTogZnVuY3Rpb24gY29uc3VtZV9OVU0oKSB7XG4gICAgdmFyIGNoID0gdGhpcy55eXRleHRbMF07XG4gICAgdmFyIGhhc1BvaW50ID0gY2ggPT09IFwiLlwiO1xuXG4gICAgaWYgKGNoID09PSBcIjBcIikge1xuICAgICAgY2ggPSB0aGlzLmlucHV0KCk7IC8vIGNoZWNrIGlmIGhleGFcblxuICAgICAgaWYgKGNoID09PSBcInhcIiB8fCBjaCA9PT0gXCJYXCIpIHtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgICAgaWYgKGNoICE9PSBcIl9cIiAmJiB0aGlzLmlzX0hFWCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZV9ITlVNKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bnB1dChjaCA/IDIgOiAxKTtcbiAgICAgICAgfSAvLyBjaGVjayBiaW5hcnkgbm90YXRpb25cblxuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJiXCIgfHwgY2ggPT09IFwiQlwiKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmIChjaCAhPT0gXCJfXCIgJiYgY2ggPT09IFwiMFwiIHx8IGNoID09PSBcIjFcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVfQk5VTSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudW5wdXQoY2ggPyAyIDogMSk7XG4gICAgICAgIH0gLy8gQGZpeG1lIGNoZWNrIG9jdGFsIG5vdGF0aW9uID8gbm90IHVzZWZ1bGxcblxuICAgICAgfSBlbHNlIGlmICghdGhpcy5pc19OVU0oKSkge1xuICAgICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgcHJldiA9IGNoO1xuICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmIChjaCA9PT0gXCJfXCIpIHtcbiAgICAgICAgaWYgKHByZXYgPT09IFwiX1wiKSB7XG4gICAgICAgICAgLy8gcmVzdHJpY3Rpb24gOiBuZXh0IHRvIHVuZGVyc2NvcmUgLyAxX18xO1xuICAgICAgICAgIHRoaXMudW5wdXQoMik7IC8vIGtlZXAgMVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldiA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAvLyBuZXh0IHRvIGRlY2ltYWwgcG9pbnQgIFwiMS5fMFwiXG4gICAgICAgICAgdGhpcy51bnB1dCgxKTsgLy8ga2VlcCAxLlxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldiA9PT0gXCJlXCIgfHwgcHJldiA9PT0gXCJFXCIpIHtcbiAgICAgICAgICAvLyBuZXh0IHRvIGUgXCIxZV8xMFwiXG4gICAgICAgICAgdGhpcy51bnB1dCgyKTsgLy8ga2VlcCAxXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCIuXCIpIHtcbiAgICAgICAgaWYgKGhhc1BvaW50KSB7XG4gICAgICAgICAgLy8gbm8gbXVsdGlwbGUgcG9pbnRzIFwiMS4wLjVcIlxuICAgICAgICAgIHRoaXMudW5wdXQoMSk7IC8vIGtlZXAgMS4wXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmV2ID09PSBcIl9cIikge1xuICAgICAgICAgIC8vIG5leHQgdG8gZGVjaW1hbCBwb2ludCAgXCIxXy4wXCJcbiAgICAgICAgICB0aGlzLnVucHV0KDIpOyAvLyBrZWVwIDFcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzUG9pbnQgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiZVwiIHx8IGNoID09PSBcIkVcIikge1xuICAgICAgICBpZiAocHJldiA9PT0gXCJfXCIpIHtcbiAgICAgICAgICAvLyBuZXh0IHRvIGUgXCIxX2UxMFwiXG4gICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmRvID0gMjtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgICAgaWYgKGNoID09PSBcIitcIiB8fCBjaCA9PT0gXCItXCIpIHtcbiAgICAgICAgICAvLyAxZS01XG4gICAgICAgICAgdW5kbyA9IDM7XG4gICAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc19OVU1fU1RBUlQoKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZV9MTlVNKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE5VTUJFUjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudW5wdXQoY2ggPyB1bmRvIDogdW5kbyAtIDEpOyAvLyBrZWVwIG9ubHkgMVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNfTlVNKCkpIHtcbiAgICAgICAgLy8gZXhhbXBsZSA6IDEwLjBhXG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTsgLy8ga2VlcCAxMC4wXG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1BvaW50KSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9ETlVNQkVSO1xuICAgIH0gZWxzZSBpZiAodGhpcy55eXRleHQubGVuZ3RoIDwgTUFYX0xFTkdUSF9PRl9MT05HIC0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9rLlRfTE5VTUJFUjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMueXl0ZXh0Lmxlbmd0aCA8IE1BWF9MRU5HVEhfT0ZfTE9ORyB8fCB0aGlzLnl5dGV4dC5sZW5ndGggPT0gTUFYX0xFTkdUSF9PRl9MT05HICYmIHRoaXMueXl0ZXh0IDwgbG9uZ19taW5fZGlnaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0xOVU1CRVI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnRvay5UX0ROVU1CRVI7XG4gICAgfVxuICB9LFxuICAvLyByZWFkIGhleGFcbiAgY29uc3VtZV9ITlVNOiBmdW5jdGlvbiBjb25zdW1lX0hOVU0oKSB7XG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmICghdGhpcy5pc19IRVgoKSkge1xuICAgICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRvay5UX0xOVU1CRVI7XG4gIH0sXG4gIC8vIHJlYWQgYSBnZW5lcmljIG51bWJlclxuICBjb25zdW1lX0xOVU06IGZ1bmN0aW9uIGNvbnN1bWVfTE5VTSgpIHtcbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKCF0aGlzLmlzX05VTSgpKSB7XG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudG9rLlRfTE5VTUJFUjtcbiAgfSxcbiAgLy8gcmVhZCBiaW5hcnlcbiAgY29uc3VtZV9CTlVNOiBmdW5jdGlvbiBjb25zdW1lX0JOVU0oKSB7XG4gICAgdmFyIGNoO1xuXG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKGNoICE9PSBcIjBcIiAmJiBjaCAhPT0gXCIxXCIgJiYgY2ggIT09IFwiX1wiKSB7XG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudG9rLlRfTE5VTUJFUjtcbiAgfVxufTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1hdGNoU1RfTE9PS0lOR19GT1JfUFJPUEVSVFk6IGZ1bmN0aW9uIG1hdGNoU1RfTE9PS0lOR19GT1JfUFJPUEVSVFkoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgaWYgKGNoID09PSBcIi1cIikge1xuICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmIChjaCA9PT0gXCI+XCIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9zY2FubmVyLmwjTDEyOTZcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfT0JKRUNUX09QRVJBVE9SO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzX1dISVRFU1BBQ0UoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9rLlRfV0hJVEVTUEFDRTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNfTEFCRUxfU1RBUlQoKSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9zY2FubmVyLmwjTDEzMDBcbiAgICAgIHRoaXMuY29uc3VtZV9MQUJFTCgpO1xuICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rLlRfU1RSSU5HO1xuICAgIH0gLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9zY2FubmVyLmwjTDEzMDZcblxuXG4gICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIG1hdGNoU1RfTE9PS0lOR19GT1JfVkFSTkFNRTogZnVuY3Rpb24gbWF0Y2hTVF9MT09LSU5HX0ZPUl9WQVJOQU1FKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTsgLy8gU0hJRlQgU1RBVEVcblxuICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuXG4gICAgaWYgKHRoaXMuaXNfTEFCRUxfU1RBUlQoKSkge1xuICAgICAgdGhpcy5jb25zdW1lX0xBQkVMKCk7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKGNoID09PSBcIltcIiB8fCBjaCA9PT0gXCJ9XCIpIHtcbiAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfU1RSSU5HX1ZBUk5BTUU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbnkgY2hhciAodGhhdCdzIHN0YXJ0ZWQgd2l0aCBhIGxhYmVsIHNlcXVlbmNlKVxuICAgICAgICB0aGlzLnVucHV0KHRoaXMueXl0ZXh0Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFueSBjaGFyICh0aGF0cyBub3QgYSBsYWJlbCBzdGFydCBzZXF1ZW5jZSlcbiAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICB9IC8vIHN0b3BzIGxvb2tpbmcgZm9yIGEgdmFybmFtZSBhbmQgc3RhcnRzIHRoZSBzY3JpcHRpbmcgbW9kZVxuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIG1hdGNoU1RfVkFSX09GRlNFVDogZnVuY3Rpb24gbWF0Y2hTVF9WQVJfT0ZGU0VUKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgIGlmICh0aGlzLmlzX05VTV9TVEFSVCgpKSB7XG4gICAgICB0aGlzLmNvbnN1bWVfTlVNKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9OVU1fU1RSSU5HO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXVwiKSB7XG4gICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICByZXR1cm4gXCJdXCI7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gXCIkXCIpIHtcbiAgICAgIHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNfTEFCRUxfU1RBUlQoKSkge1xuICAgICAgICB0aGlzLmNvbnN1bWVfTEFCRUwoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfVkFSSUFCTEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHRlcm1pbmFsXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc19MQUJFTF9TVEFSVCgpKSB7XG4gICAgICB0aGlzLmNvbnN1bWVfTEFCRUwoKTtcbiAgICAgIHJldHVybiB0aGlzLnRvay5UX1NUUklORztcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNfV0hJVEVTUEFDRSgpIHx8IGNoID09PSBcIlxcXFxcIiB8fCBjaCA9PT0gXCInXCIgfHwgY2ggPT09IFwiI1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBcIltcIiB8fCBjaCA9PT0gXCJ7XCIgfHwgY2ggPT09IFwifVwiIHx8IGNoID09PSAnXCInIHx8IGNoID09PSBcImBcIiB8fCB0aGlzLmlzX1RPS0VOKCkpIHtcbiAgICAgIHJldHVybiBjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB0ZXJtaW5hbFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF0Y2hTVF9JTl9TQ1JJUFRJTkc6IGZ1bmN0aW9uIG1hdGNoU1RfSU5fU0NSSVBUSU5HKCkge1xuICAgIHZhciBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgXCIgXCI6XG4gICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICBjYXNlIFwiXFxyXFxuXCI6XG4gICAgICAgIHJldHVybiB0aGlzLlRfV0hJVEVTUEFDRSgpO1xuXG4gICAgICBjYXNlIFwiI1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5UX0NPTU1FTlQoKTtcblxuICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgaWYgKHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5UX0NPTU1FTlQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLlRfRE9DX0NPTU1FTlQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVfVE9LRU4oKTtcblxuICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkcoKTtcblxuICAgICAgY2FzZSAnXCInOlxuICAgICAgICByZXR1cm4gdGhpcy5TVF9ET1VCTEVfUVVPVEVTKCk7XG5cbiAgICAgIGNhc2UgXCJgXCI6XG4gICAgICAgIHRoaXMuYmVnaW4oXCJTVF9CQUNLUVVPVEVcIik7XG4gICAgICAgIHJldHVybiBcImBcIjtcblxuICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgaWYgKCF0aGlzLmFzcFRhZ01vZGUgJiYgdGhpcy50cnlNYXRjaChcIj5cIikpIHtcbiAgICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgICAgdmFyIG5leHRDSCA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcbiAgICAgICAgICBpZiAobmV4dENIID09PSBcIlxcblwiIHx8IG5leHRDSCA9PT0gXCJcXHJcIikgdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5iZWdpbihcIklOSVRJQUxcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfQ0xPU0VfVEFHO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZV9UT0tFTigpO1xuXG4gICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBpZiAodGhpcy5hc3BUYWdNb2RlICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCI+XCIpIHtcbiAgICAgICAgICB0aGlzLmlucHV0KCk7IC8vIGNvbnN1bWUgdGhlICc+J1xuXG4gICAgICAgICAgY2ggPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07IC8vIHJlYWQgbmV4dFxuXG4gICAgICAgICAgaWYgKGNoID09PSBcIlxcblwiIHx8IGNoID09PSBcIlxcclwiKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0KCk7IC8vIGNvbnN1bWUgdGhlIG5ld2xpbmVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmFzcFRhZ01vZGUgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJJTklUSUFMXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NMT1NFX1RBRztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVfVE9LRU4oKTtcblxuICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgdGhpcy5iZWdpbihcIlNUX0lOX1NDUklQVElOR1wiKTtcbiAgICAgICAgcmV0dXJuIFwie1wiO1xuXG4gICAgICBjYXNlIFwifVwiOlxuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgLy8gUmV0dXJuIHRvIEhFUkVET0MvU1RfRE9VQkxFX1FVT1RFUyBtb2RlXG4gICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwifVwiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoY2ggPT09IFwiLlwiKSB7XG4gICAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc19OVU1fU1RBUlQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZV9OVU0oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoKSB0aGlzLnVucHV0KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzX05VTV9TVEFSVCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZV9OVU0oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lX0xBQkVMKCkuVF9TVFJJTkcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX1RPS0VOKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lX1RPS0VOKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignQmFkIHRlcm1pbmFsIHNlcXVlbmNlIFwiJyArIGNoICsgJ1wiIGF0IGxpbmUgJyArIHRoaXMueXlsaW5lbm8gKyBcIiAob2Zmc2V0IFwiICsgdGhpcy5vZmZzZXQgKyBcIilcIik7XG4gIH0sXG4gIFRfV0hJVEVTUEFDRTogZnVuY3Rpb24gVF9XSElURVNQQUNFKCkge1xuICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgdmFyIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAoY2ggPT09IFwiIFwiIHx8IGNoID09PSBcIlxcdFwiIHx8IGNoID09PSBcIlxcblwiIHx8IGNoID09PSBcIlxcclwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2suVF9XSElURVNQQUNFO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIG5ld2xpbmUgPSBbXCJcXG5cIiwgXCJcXHJcIl07XG52YXIgdmFsaWRfYWZ0ZXJfaGVyZWRvYyA9IFtcIlxcblwiLCBcIlxcclwiLCBcIjtcIl07XG52YXIgdmFsaWRfYWZ0ZXJfaGVyZWRvY183MyA9IHZhbGlkX2FmdGVyX2hlcmVkb2MuY29uY2F0KFtcIlxcdFwiLCBcIiBcIiwgXCIsXCIsIFwiXVwiLCBcIilcIiwgXCIvXCIsIFwiPVwiLCBcIiFcIl0pO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HOiBmdW5jdGlvbiBUX0NPTlNUQU5UX0VOQ0FQU0VEX1NUUklORygpIHtcbiAgICB2YXIgY2g7XG5cbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAoY2ggPT0gXCJcXFxcXCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIidcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2suVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkc7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIG1hdGNoaW5nIGEgSEVSRURPQyBzdGF0ZVxuICBpc19IRVJFRE9DOiBmdW5jdGlvbiBpc19IRVJFRE9DKCkge1xuICAgIHZhciByZXZlcnQgPSB0aGlzLm9mZnNldDtcblxuICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdID09PSBcIjxcIiAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPFwiICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0ICsgMV0gPT09IFwiPFwiKSB7XG4gICAgICB0aGlzLm9mZnNldCArPSAzOyAvLyBvcHRpb25hbCB0YWJzIC8gc3BhY2VzXG5cbiAgICAgIGlmICh0aGlzLmlzX1RBQlNQQUNFKCkpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICAgICAgdGhpcy5vZmZzZXQrKztcblxuICAgICAgICAgIGlmICghdGhpcy5pc19UQUJTUEFDRSgpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gb3B0aW9uYWwgcXVvdGVzXG5cblxuICAgICAgdmFyIHRDaGFyID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXTtcblxuICAgICAgaWYgKHRDaGFyID09PSBcIidcIiB8fCB0Q2hhciA9PT0gJ1wiJykge1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdENoYXIgPSBudWxsO1xuICAgICAgfSAvLyByZXF1aXJlZCBsYWJlbFxuXG5cbiAgICAgIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdmFyIHl5b2Zmc2V0ID0gdGhpcy5vZmZzZXQgLSAxO1xuXG4gICAgICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaXNfTEFCRUwoKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHl5bGFiZWwgPSB0aGlzLl9pbnB1dC5zdWJzdHJpbmcoeXlvZmZzZXQsIHRoaXMub2Zmc2V0IC0gMSk7XG5cbiAgICAgICAgaWYgKCF0Q2hhciB8fCB0Q2hhciA9PT0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXSkge1xuICAgICAgICAgIC8vIHJlcXVpcmVkIGVuZGluZyBxdW90ZVxuICAgICAgICAgIGlmICh0Q2hhcikgdGhpcy5vZmZzZXQrKzsgLy8gcmVxdWlyZSBuZXdsaW5lXG5cbiAgICAgICAgICBpZiAobmV3bGluZS5pbmNsdWRlcyh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdKSkge1xuICAgICAgICAgICAgLy8gZ28gZ28gZ29cbiAgICAgICAgICAgIHRoaXMuaGVyZWRvY19sYWJlbC5sYWJlbCA9IHl5bGFiZWw7XG4gICAgICAgICAgICB0aGlzLmhlcmVkb2NfbGFiZWwubGVuZ3RoID0geXlsYWJlbC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmhlcmVkb2NfbGFiZWwuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHl5b2Zmc2V0ID0gdGhpcy5vZmZzZXQgLSByZXZlcnQ7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9IHJldmVydDtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZSh5eW9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmICh0Q2hhciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5iZWdpbihcIlNUX05PV0RPQ1wiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJTVF9IRVJFRE9DXCIpO1xuICAgICAgICAgICAgfSAvLyBwcmVtYXRjaCB0byBnZXQgdGhlIGluZGVudGF0aW9uIGluZm9ybWF0aW9uIGZyb20gZW5kIG9mIGRvY1xuXG5cbiAgICAgICAgICAgIHRoaXMucHJlbWF0Y2hfRU5ET0ZET0MoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1NUQVJUX0hFUkVET0M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vZmZzZXQgPSByZXZlcnQ7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBTVF9ET1VCTEVfUVVPVEVTOiBmdW5jdGlvbiBTVF9ET1VCTEVfUVVPVEVTKCkge1xuICAgIHZhciBjaDtcblxuICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICB9IGVsc2UgaWYgKGNoID09ICdcIicpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNoID09IFwiJFwiKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmIChjaCA9PSBcIntcIiB8fCB0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgICB0aGlzLnVucHV0KDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoKSB0aGlzLnVucHV0KDEpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIntcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT0gXCIkXCIpIHtcbiAgICAgICAgICB0aGlzLnVucHV0KDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoKSB0aGlzLnVucHV0KDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaCA9PSAnXCInKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSAxO1xuXG4gICAgICBpZiAodGhpcy55eXRleHRbMF0gPT09IFwiYlwiIHx8IHRoaXMueXl0ZXh0WzBdID09PSBcIkJcIikge1xuICAgICAgICBwcmVmaXggPSAyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gMikge1xuICAgICAgICB0aGlzLmFwcGVuZFRva2VuKHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0UsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIHByZWZpeCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudW5wdXQodGhpcy55eXRleHQubGVuZ3RoIC0gcHJlZml4KTtcbiAgICAgIHRoaXMuYmVnaW4oXCJTVF9ET1VCTEVfUVVPVEVTXCIpO1xuICAgICAgcmV0dXJuIHRoaXMueXl0ZXh0O1xuICAgIH1cbiAgfSxcbiAgLy8gY2hlY2sgaWYgaXRzIGEgRE9DIGVuZCBzZXF1ZW5jZVxuICBpc0RPQ19NQVRDSDogZnVuY3Rpb24gaXNET0NfTUFUQ0gob2Zmc2V0LCBjb25zdW1lTGVhZGluZ1NwYWNlcykge1xuICAgIC8vIEBmaXhtZSA6IGNoZWNrIGlmIG91dCBvZiB0ZXh0IGxpbWl0c1xuICAgIC8vIGNvbnN1bWVMZWFkaW5nU3BhY2VzIGlzIGZhbHNlIGhhcHBlbiBET0MgcHJlbWF0Y2ggRU5EIEhFUkVET0Mgc3RhZ2UuXG4gICAgLy8gRW5zdXJlIGN1cnJlbnQgc3RhdGUgaXMgcmVhbGx5IGFmdGVyIGEgbmV3IGxpbmUgYnJlYWssIG5vdCBhZnRlciBhIHN1Y2ggYXMgJHt2YXJpYWJsZXN9XG4gICAgdmFyIHByZXZfY2ggPSB0aGlzLl9pbnB1dFtvZmZzZXQgLSAyXTtcblxuICAgIGlmICghbmV3bGluZS5pbmNsdWRlcyhwcmV2X2NoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gc2tpcCBsZWFkaW5nIHNwYWNlcyBvciB0YWJzXG5cblxuICAgIHZhciBpbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA9IGZhbHNlO1xuICAgIHZhciBpbmRlbnRhdGlvbl91c2VzX3RhYnMgPSBmYWxzZTsgLy8gcmVzZXQgaGVyZWRvY19sYWJlbCBzdHJ1Y3R1cmVcblxuICAgIHZhciBpbmRlbnRhdGlvbiA9IDA7XG4gICAgdmFyIGxlYWRpbmdfY2ggPSB0aGlzLl9pbnB1dFtvZmZzZXQgLSAxXTtcblxuICAgIGlmICh0aGlzLnZlcnNpb24gPj0gNzAzKSB7XG4gICAgICB3aGlsZSAobGVhZGluZ19jaCA9PT0gXCJcXHRcIiB8fCBsZWFkaW5nX2NoID09PSBcIiBcIikge1xuICAgICAgICBpZiAobGVhZGluZ19jaCA9PT0gXCIgXCIpIHtcbiAgICAgICAgICBpbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGVhZGluZ19jaCA9PT0gXCJcXHRcIikge1xuICAgICAgICAgIGluZGVudGF0aW9uX3VzZXNfdGFicyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZWFkaW5nX2NoID0gdGhpcy5faW5wdXRbb2Zmc2V0ICsgaW5kZW50YXRpb25dO1xuICAgICAgICBpbmRlbnRhdGlvbisrO1xuICAgICAgfSAvLyBNb3ZlIG9mZnNldCB0byBza2lwIGxlYWRpbmcgd2hpdGVzcGFjZVxuXG5cbiAgICAgIG9mZnNldCA9IG9mZnNldCArIGluZGVudGF0aW9uOyAvLyByZXR1cm4gb3V0IGlmIHRoZXJlIHdhcyBvbmx5IHdoaXRlc3BhY2Ugb24gdGhpcyBsaW5lXG5cbiAgICAgIGlmIChuZXdsaW5lLmluY2x1ZGVzKHRoaXMuX2lucHV0W29mZnNldCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lucHV0LnN1YnN0cmluZyhvZmZzZXQgLSAxLCBvZmZzZXQgLSAxICsgdGhpcy5oZXJlZG9jX2xhYmVsLmxlbmd0aCkgPT09IHRoaXMuaGVyZWRvY19sYWJlbC5sYWJlbCkge1xuICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbb2Zmc2V0IC0gMSArIHRoaXMuaGVyZWRvY19sYWJlbC5sZW5ndGhdO1xuXG4gICAgICBpZiAoKHRoaXMudmVyc2lvbiA+PSA3MDMgPyB2YWxpZF9hZnRlcl9oZXJlZG9jXzczIDogdmFsaWRfYWZ0ZXJfaGVyZWRvYykuaW5jbHVkZXMoY2gpKSB7XG4gICAgICAgIGlmIChjb25zdW1lTGVhZGluZ1NwYWNlcykge1xuICAgICAgICAgIHRoaXMuY29uc3VtZShpbmRlbnRhdGlvbik7IC8vIGh0dHBzOi8vd2lraS5waHAubmV0L3JmYy9mbGV4aWJsZV9oZXJlZG9jX25vd2RvY19zeW50YXhlc1xuXG4gICAgICAgICAgaWYgKGluZGVudGF0aW9uX3VzZXNfc3BhY2VzICYmIGluZGVudGF0aW9uX3VzZXNfdGFicykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2UgZXJyb3I6ICBtaXhpbmcgc3BhY2VzIGFuZCB0YWJzIGluIGVuZGluZyBtYXJrZXIgYXQgbGluZSBcIiArIHRoaXMueXlsaW5lbm8gKyBcIiAob2Zmc2V0IFwiICsgdGhpcy5vZmZzZXQgKyBcIilcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhbGxlZCBpbiBwcmVtYXRjaF9FTkRPRkRPQ1xuICAgICAgICAgIHRoaXMuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uO1xuICAgICAgICAgIHRoaXMuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA9IGluZGVudGF0aW9uX3VzZXNfc3BhY2VzO1xuICAgICAgICAgIHRoaXMuaGVyZWRvY19sYWJlbC5maXJzdF9lbmNhcHNfbm9kZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByZW1hdGNoIHRoZSBlbmQgb2YgSEVSRURPQy9OT1dET0MgZW5kIHRhZyB0byBwcmVzZXQgdGhlXG4gICAqIGNvbnRleHQgb2YgdGhpcy5oZXJlZG9jX2xhYmVsXG4gICAqL1xuICBwcmVtYXRjaF9FTkRPRkRPQzogZnVuY3Rpb24gcHJlbWF0Y2hfRU5ET0ZET0MoKSB7XG4gICAgLy8gcmVzZXQgaGVyZWRvY1xuICAgIHRoaXMuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA9IGZhbHNlO1xuICAgIHRoaXMuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbiA9IDA7XG4gICAgdGhpcy5oZXJlZG9jX2xhYmVsLmZpcnN0X2VuY2Fwc19ub2RlID0gdHJ1ZTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyAxO1xuXG4gICAgd2hpbGUgKG9mZnNldCA8IHRoaXMuX2lucHV0Lmxlbmd0aCkge1xuICAgICAgLy8gaWYgbWF0Y2ggaGVyZWRvY19sYWJlbCBzdHJ1Y3RydWUgd2lsbCBiZSBzZXRcbiAgICAgIGlmICh0aGlzLmlzRE9DX01BVENIKG9mZnNldCwgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXdsaW5lLmluY2x1ZGVzKHRoaXMuX2lucHV0W29mZnNldCAtIDFdKSkge1xuICAgICAgICAvLyBza2lwIG9uZSBsaW5lXG4gICAgICAgIHdoaWxlICghbmV3bGluZS5pbmNsdWRlcyh0aGlzLl9pbnB1dFtvZmZzZXQrK10pICYmIG9mZnNldCA8IHRoaXMuX2lucHV0Lmxlbmd0aCkgey8vIHNraXBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvZmZzZXQrKztcbiAgICB9XG4gIH0sXG4gIG1hdGNoU1RfTk9XRE9DOiBmdW5jdGlvbiBtYXRjaFNUX05PV0RPQygpIHtcbiAgICAvKiogZWRnZSBjYXNlIDogZW1wdHkgbm93IGRvYyAqKi9cbiAgICBpZiAodGhpcy5pc0RPQ19NQVRDSCh0aGlzLm9mZnNldCwgdHJ1ZSkpIHtcbiAgICAgIC8vIEBmaXhtZSA6IG5ldmVyIHJlYWNoZWQgKG1heSBiZSBjYXVzZWQgYnkgcXVvdGVzKVxuICAgICAgdGhpcy5jb25zdW1lKHRoaXMuaGVyZWRvY19sYWJlbC5sZW5ndGgpO1xuICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRU5EX0hFUkVET0M7XG4gICAgfVxuICAgIC8qKiBTQ0FOTklORyBDT05URU5UUyAqKi9cblxuXG4gICAgdmFyIGNoID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXTtcblxuICAgIHdoaWxlICh0aGlzLm9mZnNldCA8IHRoaXMuc2l6ZSkge1xuICAgICAgaWYgKG5ld2xpbmUuaW5jbHVkZXMoY2gpKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRE9DX01BVENIKHRoaXMub2Zmc2V0LCB0cnVlKSkge1xuICAgICAgICAgIHRoaXMudW5wdXQoMSkucG9wU3RhdGUoKTtcbiAgICAgICAgICB0aGlzLmFwcGVuZFRva2VuKHRoaXMudG9rLlRfRU5EX0hFUkVET0MsIHRoaXMuaGVyZWRvY19sYWJlbC5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcbiAgICAgIH1cbiAgICB9IC8vIHRvbyBiYWQgISByZWFjaGVkIGVuZCBvZiBkb2N1bWVudCAod2lsbCBnZXQgYSBwYXJzZSBlcnJvcilcblxuXG4gICAgcmV0dXJuIHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0U7XG4gIH0sXG4gIG1hdGNoU1RfSEVSRURPQzogZnVuY3Rpb24gbWF0Y2hTVF9IRVJFRE9DKCkge1xuICAgIC8qKiBlZGdlIGNhc2UgOiBlbXB0eSBoZXJlIGRvYyAqKi9cbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICBpZiAodGhpcy5pc0RPQ19NQVRDSCh0aGlzLm9mZnNldCwgdHJ1ZSkpIHtcbiAgICAgIHRoaXMuY29uc3VtZSh0aGlzLmhlcmVkb2NfbGFiZWwubGVuZ3RoIC0gMSk7XG4gICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9FTkRfSEVSRURPQztcbiAgICB9XG4gICAgLyoqIFNDQU5OSU5HIENPTlRFTlRTICoqL1xuXG5cbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7IC8vIGlnbm9yZSBuZXh0XG5cbiAgICAgICAgaWYgKCFuZXdsaW5lLmluY2x1ZGVzKGNoKSkge1xuICAgICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdsaW5lLmluY2x1ZGVzKGNoKSkge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAodGhpcy5pc0RPQ19NQVRDSCh0aGlzLm9mZnNldCwgdHJ1ZSkpIHtcbiAgICAgICAgICB0aGlzLnVucHV0KDEpLnBvcFN0YXRlKCk7XG4gICAgICAgICAgdGhpcy5hcHBlbmRUb2tlbih0aGlzLnRvay5UX0VORF9IRVJFRE9DLCB0aGlzLmhlcmVkb2NfbGFiZWwubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCIkXCIpIHtcbiAgICAgICAgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgICAgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICAgIC8vIHN0YXJ0IG9mICR7XG4gICAgICAgICAgdGhpcy5iZWdpbihcIlNUX0xPT0tJTkdfRk9SX1ZBUk5BTUVcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb2tlbih0aGlzLnRvay5UX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUywgMik7XG4gICAgICAgICAgICB0aGlzLnVucHV0KDIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc19MQUJFTF9TVEFSVCgpKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgJHZhci4uLlxuICAgICAgICAgIHZhciB5eW9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5jb25zdW1lX1ZBUklBQkxFKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gdGhpcy5vZmZzZXQgLSB5eW9mZnNldCArIDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4obmV4dCwgdGhpcy5vZmZzZXQgLSB5eW9mZnNldCArIDIpO1xuICAgICAgICAgICAgdGhpcy51bnB1dCh0aGlzLm9mZnNldCAtIHl5b2Zmc2V0ICsgMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfSAvL2NvbnNvbGUubG9nKHRoaXMueXl0ZXh0KTtcblxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgeyQuLi5cbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMueXl0ZXh0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4odGhpcy50b2suVF9DVVJMWV9PUEVOLCAxKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NVUkxZX09QRU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcbiAgICAgIH1cbiAgICB9IC8vIHRvbyBiYWQgISByZWFjaGVkIGVuZCBvZiBkb2N1bWVudCAod2lsbCBnZXQgYSBwYXJzZSBlcnJvcilcblxuXG4gICAgcmV0dXJuIHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0U7XG4gIH0sXG4gIGNvbnN1bWVfVkFSSUFCTEU6IGZ1bmN0aW9uIGNvbnN1bWVfVkFSSUFCTEUoKSB7XG4gICAgdGhpcy5jb25zdW1lX0xBQkVMKCk7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgaWYgKGNoID09IFwiW1wiKSB7XG4gICAgICB0aGlzLnVucHV0KDEpO1xuICAgICAgdGhpcy5iZWdpbihcIlNUX1ZBUl9PRkZTRVRcIik7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9WQVJJQUJMRTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBcIi1cIikge1xuICAgICAgaWYgKHRoaXMuaW5wdXQoKSA9PT0gXCI+XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfTE9PS0lOR19GT1JfUFJPUEVSVFlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVucHV0KDMpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9WQVJJQUJMRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2suVF9WQVJJQUJMRTtcbiAgfSxcbiAgLy8gSEFORExFUyBCQUNLUVVPVEVTXG4gIG1hdGNoU1RfQkFDS1FVT1RFOiBmdW5jdGlvbiBtYXRjaFNUX0JBQ0tRVU9URSgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICB0aGlzLmJlZ2luKFwiU1RfTE9PS0lOR19GT1JfVkFSTkFNRVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdmFyIHRvayA9IHRoaXMuY29uc3VtZV9WQVJJQUJMRSgpO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICBpZiAodGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIiRcIikge1xuICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DVVJMWV9PUEVOO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiYFwiKSB7XG4gICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICByZXR1cm4gXCJgXCI7XG4gICAgfSAvLyBhbnkgY2hhclxuXG5cbiAgICB3aGlsZSAodGhpcy5vZmZzZXQgPCB0aGlzLnNpemUpIHtcbiAgICAgIGlmIChjaCA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJgXCIpIHtcbiAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICB0aGlzLmFwcGVuZFRva2VuKFwiYFwiLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIiRcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICAgICAgdGhpcy5iZWdpbihcIlNUX0xPT0tJTkdfRk9SX1ZBUk5BTUVcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb2tlbih0aGlzLnRvay5UX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUywgMik7XG4gICAgICAgICAgICB0aGlzLnVucHV0KDIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc19MQUJFTF9TVEFSVCgpKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgJHZhci4uLlxuICAgICAgICAgIHZhciB5eW9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5jb25zdW1lX1ZBUklBQkxFKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy55eXRleHQubGVuZ3RoID4gdGhpcy5vZmZzZXQgLSB5eW9mZnNldCArIDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4obmV4dCwgdGhpcy5vZmZzZXQgLSB5eW9mZnNldCArIDIpO1xuICAgICAgICAgICAgdGhpcy51bnB1dCh0aGlzLm9mZnNldCAtIHl5b2Zmc2V0ICsgMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgeyQuLi5cbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMueXl0ZXh0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4odGhpcy50b2suVF9DVVJMWV9PUEVOLCAxKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NVUkxZX09QRU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRvay5UX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFO1xuICB9LFxuICBtYXRjaFNUX0RPVUJMRV9RVU9URVM6IGZ1bmN0aW9uIG1hdGNoU1RfRE9VQkxFX1FVT1RFUygpIHtcbiAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICB0aGlzLmJlZ2luKFwiU1RfTE9PS0lOR19GT1JfVkFSTkFNRVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdmFyIHRvayA9IHRoaXMuY29uc3VtZV9WQVJJQUJMRSgpO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09IFwie1wiKSB7XG4gICAgICBpZiAodGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdID09PSBcIiRcIikge1xuICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DVVJMWV9PUEVOO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgIHJldHVybiAnXCInO1xuICAgIH0gLy8gYW55IGNoYXJcblxuXG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICBpZiAoY2ggPT09IFwiXFxcXFwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICB0aGlzLmFwcGVuZFRva2VuKCdcIicsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgIGNoID0gdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfTE9PS0lOR19GT1JfVkFSTkFNRVwiKTtcblxuICAgICAgICAgIGlmICh0aGlzLnl5dGV4dC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRva2VuKHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTLCAyKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgICAvLyBzdGFydCBvZiAkdmFyLi4uXG4gICAgICAgICAgdmFyIHl5b2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmNvbnN1bWVfVkFSSUFCTEUoKTtcblxuICAgICAgICAgIGlmICh0aGlzLnl5dGV4dC5sZW5ndGggPiB0aGlzLm9mZnNldCAtIHl5b2Zmc2V0ICsgMikge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb2tlbihuZXh0LCB0aGlzLm9mZnNldCAtIHl5b2Zmc2V0ICsgMik7XG4gICAgICAgICAgICB0aGlzLnVucHV0KHRoaXMub2Zmc2V0IC0geXlvZmZzZXQgKyAyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2gpIHRoaXMudW5wdXQoMSk7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSBcIntcIikge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAoY2ggPT09IFwiJFwiKSB7XG4gICAgICAgICAgLy8gc3RhcnQgb2YgeyQuLi5cbiAgICAgICAgICB0aGlzLmJlZ2luKFwiU1RfSU5fU0NSSVBUSU5HXCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMueXl0ZXh0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9rZW4odGhpcy50b2suVF9DVVJMWV9PUEVOLCAxKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXQoMik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQGZpeG1lIDogeXl0ZXh0ID0gJ1wieyQnICh0aGlzLnl5dGV4dC5sZW5ndGggPiAzKVxuICAgICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NVUkxZX09QRU47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoKSB0aGlzLnVucHV0KDEpO1xuICAgICAgfVxuXG4gICAgICBjaCA9IHRoaXMuaW5wdXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50b2suVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUX1NUUklORzogZnVuY3Rpb24gVF9TVFJJTkcoKSB7XG4gICAgdmFyIHRva2VuID0gdGhpcy55eXRleHQudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgaWQgPSB0aGlzLmtleXdvcmRzW3Rva2VuXTtcblxuICAgIGlmICh0eXBlb2YgaWQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICh0b2tlbiA9PT0gXCJ5aWVsZFwiKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gPj0gNzAwICYmIHRoaXMudHJ5TWF0Y2goXCIgZnJvbVwiKSkge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSg1KTtcbiAgICAgICAgICBpZCA9IHRoaXMudG9rLlRfWUlFTERfRlJPTTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZCA9IHRoaXMudG9rLlRfWUlFTEQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gdGhpcy50b2suVF9TVFJJTkc7XG5cbiAgICAgICAgaWYgKHRva2VuID09PSBcImJcIiB8fCB0b2tlbiA9PT0gXCJCXCIpIHtcbiAgICAgICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KDEpO1xuXG4gICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5TVF9ET1VCTEVfUVVPVEVTKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCkge1xuICAgICAgICAgICAgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH0sXG4gIC8vIHJlYWRzIGEgY3VzdG9tIHRva2VuXG4gIGNvbnN1bWVfVE9LRU46IGZ1bmN0aW9uIGNvbnN1bWVfVE9LRU4oKSB7XG4gICAgdmFyIGNoID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXTtcbiAgICB2YXIgZm4gPSB0aGlzLnRva2VuVGVybWluYWxzW2NoXTtcblxuICAgIGlmIChmbikge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMueXl0ZXh0O1xuICAgIH1cbiAgfSxcbiAgLy8gbGlzdCBvZiBzcGVjaWFsIGNoYXIgdG9rZW5zXG4gIHRva2VuVGVybWluYWxzOiB7XG4gICAgJDogZnVuY3Rpb24gJCgpIHtcbiAgICAgIHRoaXMub2Zmc2V0Kys7XG5cbiAgICAgIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQtLTtcbiAgICAgICAgdGhpcy5jb25zdW1lX0xBQkVMKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX1ZBUklBQkxFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vZmZzZXQtLTtcbiAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCItXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICB2YXIgbmNoYXIgPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07XG5cbiAgICAgIGlmIChuY2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgdGhpcy5iZWdpbihcIlNUX0xPT0tJTkdfRk9SX1BST1BFUlRZXCIpLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX09CSkVDVF9PUEVSQVRPUjtcbiAgICAgIH0gZWxzZSBpZiAobmNoYXIgPT09IFwiLVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfREVDO1xuICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9NSU5VU19FUVVBTDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiLVwiO1xuICAgIH0sXG4gICAgXCJcXFxcXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2suVF9OU19TRVBBUkFUT1I7XG4gICAgfSxcbiAgICBcIi9cIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRElWX0VRVUFMO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIvXCI7XG4gICAgfSxcbiAgICBcIjpcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiOlwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfRE9VQkxFX0NPTE9OO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiOlwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCIoXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICB2YXIgaW5pdGlhbCA9IHRoaXMub2Zmc2V0O1xuICAgICAgdGhpcy5pbnB1dCgpO1xuXG4gICAgICBpZiAodGhpcy5pc19UQUJTUEFDRSgpKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZV9UQUJTUEFDRSgpLmlucHV0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzX0xBQkVMX1NUQVJUKCkpIHtcbiAgICAgICAgdmFyIHl5bGVuID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICB0aGlzLmNvbnN1bWVfTEFCRUwoKTtcbiAgICAgICAgdmFyIGNhc3RUb2tlbiA9IHRoaXMueXl0ZXh0LnN1YnN0cmluZyh5eWxlbiAtIDEpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBjYXN0SWQgPSB0aGlzLmNhc3RLZXl3b3Jkc1tjYXN0VG9rZW5dO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FzdElkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNfVEFCU1BBQ0UoKSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lX1RBQlNQQUNFKCkuaW5wdXQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5faW5wdXRbdGhpcy5vZmZzZXQgLSAxXSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYXN0SWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHJldmVydCB0aGUgY2hlY2tcblxuXG4gICAgICB0aGlzLnVucHV0KHRoaXMub2Zmc2V0IC0gaW5pdGlhbCk7XG4gICAgICByZXR1cm4gXCIoXCI7XG4gICAgfSxcbiAgICBcIj1cIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIHZhciBuY2hhciA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcblxuICAgICAgaWYgKG5jaGFyID09PSBcIj5cIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0RPVUJMRV9BUlJPVztcbiAgICAgIH0gZWxzZSBpZiAobmNoYXIgPT09IFwiPVwiKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCArIDFdID09PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19JREVOVElDQUw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0lTX0VRVUFMO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIj1cIjtcbiAgICB9LFxuICAgIFwiK1wiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgdmFyIG5jaGFyID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdO1xuXG4gICAgICBpZiAobmNoYXIgPT09IFwiK1wiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfSU5DO1xuICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9QTFVTX0VRVUFMO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIrXCI7XG4gICAgfSxcbiAgICBcIiFcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPVwiKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCArIDFdID09PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19OT1RfSURFTlRJQ0FMO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19OT1RfRVFVQUw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiIVwiO1xuICAgIH0sXG4gICAgXCI/XCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uID49IDcwMCAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiP1wiKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gPj0gNzA0ICYmIHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0ICsgMV0gPT09IFwiPVwiKSB7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKDIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX0NPQUxFU0NFX0VRVUFMO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DT0FMRVNDRTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCI/XCI7XG4gICAgfSxcbiAgICBcIjxcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIHZhciBuY2hhciA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcblxuICAgICAgaWYgKG5jaGFyID09PSBcIjxcIikge1xuICAgICAgICBuY2hhciA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0ICsgMV07XG5cbiAgICAgICAgaWYgKG5jaGFyID09PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9TTF9FUVVBTDtcbiAgICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCI8XCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc19IRVJFRE9DKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1NUQVJUX0hFUkVET0M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9TTDtcbiAgICAgIH0gZWxzZSBpZiAobmNoYXIgPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcblxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID49IDcwMCAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPlwiKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1NQQUNFU0hJUDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19TTUFMTEVSX09SX0VRVUFMO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5jaGFyID09PSBcIj5cIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0lTX05PVF9FUVVBTDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiPFwiO1xuICAgIH0sXG4gICAgXCI+XCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICB2YXIgbmNoYXIgPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07XG5cbiAgICAgIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9JU19HUkVBVEVSX09SX0VRVUFMO1xuICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgbmNoYXIgPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCArIDFdO1xuXG4gICAgICAgIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfU1JfRVFVQUw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1NSO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIj5cIjtcbiAgICB9LFxuICAgIFwiKlwiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgdmFyIG5jaGFyID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdO1xuXG4gICAgICBpZiAobmNoYXIgPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfTVVMX0VRVUFMO1xuICAgICAgfSBlbHNlIGlmIChuY2hhciA9PT0gXCIqXCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPVwiKSB7XG4gICAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvay5UX1BPV19FUVVBTDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b2suVF9QT1c7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiKlwiO1xuICAgIH0sXG4gICAgXCIuXCI6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICB2YXIgbmNoYXIgPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF07XG5cbiAgICAgIGlmIChuY2hhciA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9DT05DQVRfRVFVQUw7XG4gICAgICB9IGVsc2UgaWYgKG5jaGFyID09PSBcIi5cIiAmJiB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCArIDFdID09PSBcIi5cIikge1xuICAgICAgICB0aGlzLmNvbnN1bWUoMik7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0VMTElQU0lTO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIuXCI7XG4gICAgfSxcbiAgICBcIiVcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIGlmICh0aGlzLl9pbnB1dFt0aGlzLm9mZnNldF0gPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfTU9EX0VRVUFMO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gXCIlXCI7XG4gICAgfSxcbiAgICBcIiZcIjogZnVuY3Rpb24gXygpIHtcbiAgICAgIHZhciBuY2hhciA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XTtcblxuICAgICAgaWYgKG5jaGFyID09PSBcIj1cIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0FORF9FUVVBTDtcbiAgICAgIH0gZWxzZSBpZiAobmNoYXIgPT09IFwiJlwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfQk9PTEVBTl9BTkQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIiZcIjtcbiAgICB9LFxuICAgIFwifFwiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgdmFyIG5jaGFyID0gdGhpcy5faW5wdXRbdGhpcy5vZmZzZXRdO1xuXG4gICAgICBpZiAobmNoYXIgPT09IFwiPVwiKSB7XG4gICAgICAgIHRoaXMuaW5wdXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rLlRfT1JfRVFVQUw7XG4gICAgICB9IGVsc2UgaWYgKG5jaGFyID09PSBcInxcIikge1xuICAgICAgICB0aGlzLmlucHV0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvay5UX0JPT0xFQU5fT1I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcInxcIjtcbiAgICB9LFxuICAgIFwiXlwiOiBmdW5jdGlvbiBfKCkge1xuICAgICAgaWYgKHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0XSA9PT0gXCI9XCIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2suVF9YT1JfRVFVQUw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBcIl5cIjtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgdG9rZW5zID0gXCI7OiwuXFxcXFtdKCl8XiYrLS8qPSUhfiQ8Pj9AXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gY2hlY2sgaWYgdGhlIGNoYXIgY2FuIGJlIGEgbnVtZXJpY1xuICBpc19OVU06IGZ1bmN0aW9uIGlzX05VTSgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMub2Zmc2V0IC0gMSk7XG5cbiAgICByZXR1cm4gY2ggPiA0NyAmJiBjaCA8IDU4IHx8IGNoID09PSA5NTtcbiAgfSxcbiAgLy8gY2hlY2sgaWYgdGhlIGNoYXIgY2FuIGJlIGEgbnVtZXJpY1xuICBpc19OVU1fU1RBUlQ6IGZ1bmN0aW9uIGlzX05VTV9TVEFSVCgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMub2Zmc2V0IC0gMSk7XG5cbiAgICByZXR1cm4gY2ggPiA0NyAmJiBjaCA8IDU4O1xuICB9LFxuICAvLyBjaGVjayBpZiBjdXJyZW50IGNoYXIgY2FuIGJlIGEgbGFiZWxcbiAgaXNfTEFCRUw6IGZ1bmN0aW9uIGlzX0xBQkVMKCkge1xuICAgIHZhciBjaCA9IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5vZmZzZXQgLSAxKTtcblxuICAgIHJldHVybiBjaCA+IDk2ICYmIGNoIDwgMTIzIHx8IGNoID4gNjQgJiYgY2ggPCA5MSB8fCBjaCA9PT0gOTUgfHwgY2ggPiA0NyAmJiBjaCA8IDU4IHx8IGNoID4gMTI2O1xuICB9LFxuICAvLyBjaGVjayBpZiBjdXJyZW50IGNoYXIgY2FuIGJlIGEgbGFiZWxcbiAgaXNfTEFCRUxfU1RBUlQ6IGZ1bmN0aW9uIGlzX0xBQkVMX1NUQVJUKCkge1xuICAgIHZhciBjaCA9IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5vZmZzZXQgLSAxKTsgLy8gQSAtIFpcblxuXG4gICAgaWYgKGNoID4gNjQgJiYgY2ggPCA5MSkgcmV0dXJuIHRydWU7IC8vIGEgLSB6XG5cbiAgICBpZiAoY2ggPiA5NiAmJiBjaCA8IDEyMykgcmV0dXJuIHRydWU7IC8vIF8gKDk1KVxuXG4gICAgaWYgKGNoID09PSA5NSkgcmV0dXJuIHRydWU7IC8vIHV0ZjggLyBleHRlbmRlZFxuXG4gICAgaWYgKGNoID4gMTI2KSByZXR1cm4gdHJ1ZTsgLy8gZWxzZVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICAvLyByZWFkcyBlYWNoIGNoYXIgb2YgdGhlIGxhYmVsXG4gIGNvbnN1bWVfTEFCRUw6IGZ1bmN0aW9uIGNvbnN1bWVfTEFCRUwoKSB7XG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmICghdGhpcy5pc19MQUJFTCgpKSB7XG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgY2hhciBpcyBhIHRva2VuIGNoYXJcbiAgaXNfVE9LRU46IGZ1bmN0aW9uIGlzX1RPS0VOKCkge1xuICAgIHZhciBjaCA9IHRoaXMuX2lucHV0W3RoaXMub2Zmc2V0IC0gMV07XG4gICAgcmV0dXJuIHRva2Vucy5pbmRleE9mKGNoKSAhPT0gLTE7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgY2hhciBpcyBhIHdoaXRlc3BhY2VcbiAgaXNfV0hJVEVTUEFDRTogZnVuY3Rpb24gaXNfV0hJVEVTUEFDRSgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdO1xuICAgIHJldHVybiBjaCA9PT0gXCIgXCIgfHwgY2ggPT09IFwiXFx0XCIgfHwgY2ggPT09IFwiXFxuXCIgfHwgY2ggPT09IFwiXFxyXCI7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgY2hhciBpcyBhIHdoaXRlc3BhY2UgKHdpdGhvdXQgbmV3bGluZXMpXG4gIGlzX1RBQlNQQUNFOiBmdW5jdGlvbiBpc19UQUJTUEFDRSgpIHtcbiAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFt0aGlzLm9mZnNldCAtIDFdO1xuICAgIHJldHVybiBjaCA9PT0gXCIgXCIgfHwgY2ggPT09IFwiXFx0XCI7XG4gIH0sXG4gIC8vIGNvbnN1bWUgYWxsIHdoaXRlc3BhY2VzIChleGNsdWRpbmcgbmV3bGluZXMpXG4gIGNvbnN1bWVfVEFCU1BBQ0U6IGZ1bmN0aW9uIGNvbnN1bWVfVEFCU1BBQ0UoKSB7XG4gICAgd2hpbGUgKHRoaXMub2Zmc2V0IDwgdGhpcy5zaXplKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzLmlucHV0KCk7XG5cbiAgICAgIGlmICghdGhpcy5pc19UQUJTUEFDRSgpKSB7XG4gICAgICAgIGlmIChjaCkgdGhpcy51bnB1dCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGNoZWNrIGlmIGN1cnJlbnQgY2hhciBjYW4gYmUgYSBoZXhhZGVjaW1hbCBudW1iZXJcbiAgaXNfSEVYOiBmdW5jdGlvbiBpc19IRVgoKSB7XG4gICAgdmFyIGNoID0gdGhpcy5faW5wdXQuY2hhckNvZGVBdCh0aGlzLm9mZnNldCAtIDEpOyAvLyAwIC0gOVxuXG5cbiAgICBpZiAoY2ggPiA0NyAmJiBjaCA8IDU4KSByZXR1cm4gdHJ1ZTsgLy8gQSAtIEZcblxuICAgIGlmIChjaCA+IDY0ICYmIGNoIDwgNzEpIHJldHVybiB0cnVlOyAvLyBhIC0gZlxuXG4gICAgaWYgKGNoID4gOTYgJiYgY2ggPCAxMDMpIHJldHVybiB0cnVlOyAvLyBfIChjb2RlIDk1KVxuXG4gICAgaWYgKGNoID09PSA5NSkgcmV0dXJuIHRydWU7IC8vIGVsc2VcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICByZXR1cm4gbiAhPSBcIi5cIiAmJiBuICE9IFwiLFwiICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cbi8qKlxuICogVGhlIFBIUCBQYXJzZXIgY2xhc3MgdGhhdCBidWlsZCB0aGUgQVNUIHRyZWUgZnJvbSB0aGUgbGV4ZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEB0dXRvcmlhbCBQYXJzZXJcbiAqIEBwcm9wZXJ0eSB7TGV4ZXJ9IGxleGVyIC0gY3VycmVudCBsZXhlciBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtBU1R9IGFzdCAtIHRoZSBBU1QgZmFjdG9yeSBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtJbnRlZ2VyfFN0cmluZ30gdG9rZW4gLSBjdXJyZW50IHRva2VuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGV4dHJhY3REb2MgLSBzaG91bGQgZXh0cmFjdCBkb2N1bWVudGF0aW9uIGFzIEFTVCBub2RlXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGV4dHJhY3RUb2tlbnMgLSBzaG91bGQgZXh0cmFjdCBlYWNoIHRva2VuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHN1cHByZXNzRXJyb3JzIC0gc2hvdWxkIGlnbm9yZSBwYXJzaW5nIGVycm9ycyBhbmQgY29udGludWVcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGVidWcgLSBzaG91bGQgb3V0cHV0IGRlYnVnIGluZm9ybWF0aW9uc1xuICovXG5cblxudmFyIHBhcnNlciA9IGZ1bmN0aW9uIHBhcnNlcihsZXhlciwgYXN0KSB7XG4gIHRoaXMubGV4ZXIgPSBsZXhlcjtcbiAgdGhpcy5hc3QgPSBhc3Q7XG4gIHRoaXMudG9rID0gbGV4ZXIudG9rO1xuICB0aGlzLkVPRiA9IGxleGVyLkVPRjtcbiAgdGhpcy50b2tlbiA9IG51bGw7XG4gIHRoaXMucHJldiA9IG51bGw7XG4gIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgdGhpcy52ZXJzaW9uID0gNzA0O1xuICB0aGlzLmV4dHJhY3REb2MgPSBmYWxzZTtcbiAgdGhpcy5leHRyYWN0VG9rZW5zID0gZmFsc2U7XG4gIHRoaXMuc3VwcHJlc3NFcnJvcnMgPSBmYWxzZTtcblxuICB2YXIgbWFwSXQgPSBmdW5jdGlvbiBtYXBJdChpdGVtKSB7XG4gICAgcmV0dXJuIFtpdGVtLCBudWxsXTtcbiAgfTtcblxuICB0aGlzLmVudHJpZXMgPSB7XG4gICAgLy8gcmVzZXJ2ZWRfbm9uX21vZGlmaWVyc1xuICAgIElERU5USUZJRVI6IG5ldyBNYXAoW3RoaXMudG9rLlRfQUJTVFJBQ1QsIHRoaXMudG9rLlRfQVJSQVksIHRoaXMudG9rLlRfQVMsIHRoaXMudG9rLlRfQlJFQUssIHRoaXMudG9rLlRfQ0FMTEFCTEUsIHRoaXMudG9rLlRfQ0FTRSwgdGhpcy50b2suVF9DQVRDSCwgdGhpcy50b2suVF9DTEFTUywgdGhpcy50b2suVF9DTEFTU19DLCB0aGlzLnRvay5UX0NMT05FLCB0aGlzLnRvay5UX0NPTlNULCB0aGlzLnRvay5UX0NPTlRJTlVFLCB0aGlzLnRvay5UX0RFQ0xBUkUsIHRoaXMudG9rLlRfREVGQVVMVCwgdGhpcy50b2suVF9ESVIsIHRoaXMudG9rLlRfRE8sIHRoaXMudG9rLlRfRUNITywgdGhpcy50b2suVF9FTFNFLCB0aGlzLnRvay5UX0VMU0VJRiwgdGhpcy50b2suVF9FTVBUWSwgdGhpcy50b2suVF9FTkRERUNMQVJFLCB0aGlzLnRvay5UX0VOREZPUiwgdGhpcy50b2suVF9FTkRGT1JFQUNILCB0aGlzLnRvay5UX0VORElGLCB0aGlzLnRvay5UX0VORFNXSVRDSCwgdGhpcy50b2suVF9FTkRXSElMRSwgdGhpcy50b2suVF9FVkFMLCB0aGlzLnRvay5UX0VYSVQsIHRoaXMudG9rLlRfRVhURU5EUywgdGhpcy50b2suVF9GSUxFLCB0aGlzLnRvay5UX0ZJTkFMLCB0aGlzLnRvay5UX0ZJTkFMTFksIHRoaXMudG9rLlRfRk4sIHRoaXMudG9rLlRfRk9SLCB0aGlzLnRvay5UX0ZPUkVBQ0gsIHRoaXMudG9rLlRfRlVOQ19DLCB0aGlzLnRvay5UX0ZVTkNUSU9OLCB0aGlzLnRvay5UX0dMT0JBTCwgdGhpcy50b2suVF9HT1RPLCB0aGlzLnRvay5UX0lGLCB0aGlzLnRvay5UX0lNUExFTUVOVFMsIHRoaXMudG9rLlRfSU5DTFVERSwgdGhpcy50b2suVF9JTkNMVURFX09OQ0UsIHRoaXMudG9rLlRfSU5TVEFOQ0VPRiwgdGhpcy50b2suVF9JTlNURUFET0YsIHRoaXMudG9rLlRfSU5URVJGQUNFLCB0aGlzLnRvay5UX0lTU0VULCB0aGlzLnRvay5UX0xJTkUsIHRoaXMudG9rLlRfTElTVCwgdGhpcy50b2suVF9MT0dJQ0FMX0FORCwgdGhpcy50b2suVF9MT0dJQ0FMX09SLCB0aGlzLnRvay5UX0xPR0lDQUxfWE9SLCB0aGlzLnRvay5UX01FVEhPRF9DLCB0aGlzLnRvay5UX05BTUVTUEFDRSwgdGhpcy50b2suVF9ORVcsIHRoaXMudG9rLlRfTlNfQywgdGhpcy50b2suVF9QUklOVCwgdGhpcy50b2suVF9QUklWQVRFLCB0aGlzLnRvay5UX1BST1RFQ1RFRCwgdGhpcy50b2suVF9QVUJMSUMsIHRoaXMudG9rLlRfUkVRVUlSRSwgdGhpcy50b2suVF9SRVFVSVJFX09OQ0UsIHRoaXMudG9rLlRfUkVUVVJOLCB0aGlzLnRvay5UX1NUQVRJQywgdGhpcy50b2suVF9TV0lUQ0gsIHRoaXMudG9rLlRfVEhST1csIHRoaXMudG9rLlRfVFJBSVQsIHRoaXMudG9rLlRfVFJZLCB0aGlzLnRvay5UX1VOU0VULCB0aGlzLnRvay5UX1VTRSwgdGhpcy50b2suVF9WQVIsIHRoaXMudG9rLlRfV0hJTEUsIHRoaXMudG9rLlRfWUlFTERdLm1hcChtYXBJdCkpLFxuICAgIFZBUklBQkxFOiBuZXcgTWFwKFt0aGlzLnRvay5UX1ZBUklBQkxFLCBcIiRcIiwgXCImXCIsIHRoaXMudG9rLlRfTlNfU0VQQVJBVE9SLCB0aGlzLnRvay5UX1NUUklORywgdGhpcy50b2suVF9OQU1FU1BBQ0UsIHRoaXMudG9rLlRfU1RBVElDXS5tYXAobWFwSXQpKSxcbiAgICBTQ0FMQVI6IG5ldyBNYXAoW3RoaXMudG9rLlRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HLCB0aGlzLnRvay5UX1NUQVJUX0hFUkVET0MsIHRoaXMudG9rLlRfTE5VTUJFUiwgdGhpcy50b2suVF9ETlVNQkVSLCB0aGlzLnRvay5UX0FSUkFZLCBcIltcIiwgdGhpcy50b2suVF9DTEFTU19DLCB0aGlzLnRvay5UX1RSQUlUX0MsIHRoaXMudG9rLlRfRlVOQ19DLCB0aGlzLnRvay5UX01FVEhPRF9DLCB0aGlzLnRvay5UX0xJTkUsIHRoaXMudG9rLlRfRklMRSwgdGhpcy50b2suVF9ESVIsIHRoaXMudG9rLlRfTlNfQywgJ1wiJywgJ2JcIicsICdCXCInLCBcIi1cIiwgdGhpcy50b2suVF9OU19TRVBBUkFUT1JdLm1hcChtYXBJdCkpLFxuICAgIFRfTUFHSUNfQ09OU1Q6IG5ldyBNYXAoW3RoaXMudG9rLlRfQ0xBU1NfQywgdGhpcy50b2suVF9UUkFJVF9DLCB0aGlzLnRvay5UX0ZVTkNfQywgdGhpcy50b2suVF9NRVRIT0RfQywgdGhpcy50b2suVF9MSU5FLCB0aGlzLnRvay5UX0ZJTEUsIHRoaXMudG9rLlRfRElSLCB0aGlzLnRvay5UX05TX0NdLm1hcChtYXBJdCkpLFxuICAgIFRfTUVNQkVSX0ZMQUdTOiBuZXcgTWFwKFt0aGlzLnRvay5UX1BVQkxJQywgdGhpcy50b2suVF9QUklWQVRFLCB0aGlzLnRvay5UX1BST1RFQ1RFRCwgdGhpcy50b2suVF9TVEFUSUMsIHRoaXMudG9rLlRfQUJTVFJBQ1QsIHRoaXMudG9rLlRfRklOQUxdLm1hcChtYXBJdCkpLFxuICAgIEVPUzogbmV3IE1hcChbXCI7XCIsIHRoaXMuRU9GLCB0aGlzLnRvay5UX0lOTElORV9IVE1MXS5tYXAobWFwSXQpKSxcbiAgICBFWFBSOiBuZXcgTWFwKFtcIkBcIiwgXCItXCIsIFwiK1wiLCBcIiFcIiwgXCJ+XCIsIFwiKFwiLCBcImBcIiwgdGhpcy50b2suVF9MSVNULCB0aGlzLnRvay5UX0NMT05FLCB0aGlzLnRvay5UX0lOQywgdGhpcy50b2suVF9ERUMsIHRoaXMudG9rLlRfTkVXLCB0aGlzLnRvay5UX0lTU0VULCB0aGlzLnRvay5UX0VNUFRZLCB0aGlzLnRvay5UX0lOQ0xVREUsIHRoaXMudG9rLlRfSU5DTFVERV9PTkNFLCB0aGlzLnRvay5UX1JFUVVJUkUsIHRoaXMudG9rLlRfUkVRVUlSRV9PTkNFLCB0aGlzLnRvay5UX0VWQUwsIHRoaXMudG9rLlRfSU5UX0NBU1QsIHRoaXMudG9rLlRfRE9VQkxFX0NBU1QsIHRoaXMudG9rLlRfU1RSSU5HX0NBU1QsIHRoaXMudG9rLlRfQVJSQVlfQ0FTVCwgdGhpcy50b2suVF9PQkpFQ1RfQ0FTVCwgdGhpcy50b2suVF9CT09MX0NBU1QsIHRoaXMudG9rLlRfVU5TRVRfQ0FTVCwgdGhpcy50b2suVF9FWElULCB0aGlzLnRvay5UX1BSSU5ULCB0aGlzLnRvay5UX1lJRUxELCB0aGlzLnRvay5UX1NUQVRJQywgdGhpcy50b2suVF9GVU5DVElPTiwgdGhpcy50b2suVF9GTiwgLy8gdXNpbmcgVkFSSUFCTEVTIDpcbiAgICB0aGlzLnRvay5UX1ZBUklBQkxFLCBcIiRcIiwgdGhpcy50b2suVF9OU19TRVBBUkFUT1IsIHRoaXMudG9rLlRfU1RSSU5HLCAvLyB1c2luZyBTQ0FMQVIgOlxuICAgIHRoaXMudG9rLlRfU1RSSU5HLCAvLyBAc2VlIHZhcmlhYmxlLmpzIGxpbmUgNDUgPiBjb25mbGljdCB3aXRoIHZhcmlhYmxlID0gc2hpZnQvcmVkdWNlIDopXG4gICAgdGhpcy50b2suVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkcsIHRoaXMudG9rLlRfU1RBUlRfSEVSRURPQywgdGhpcy50b2suVF9MTlVNQkVSLCB0aGlzLnRvay5UX0ROVU1CRVIsIHRoaXMudG9rLlRfQVJSQVksIFwiW1wiLCB0aGlzLnRvay5UX0NMQVNTX0MsIHRoaXMudG9rLlRfVFJBSVRfQywgdGhpcy50b2suVF9GVU5DX0MsIHRoaXMudG9rLlRfTUVUSE9EX0MsIHRoaXMudG9rLlRfTElORSwgdGhpcy50b2suVF9GSUxFLCB0aGlzLnRvay5UX0RJUiwgdGhpcy50b2suVF9OU19DXS5tYXAobWFwSXQpKVxuICB9O1xufTtcbi8qKlxuICogaGVscGVyIDogZ2V0cyBhIHRva2VuIG5hbWVcbiAqL1xuXG5cbnBhcnNlci5wcm90b3R5cGUuZ2V0VG9rZW5OYW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIGlmICghaXNOdW1iZXIodG9rZW4pKSB7XG4gICAgcmV0dXJuIFwiJ1wiICsgdG9rZW4gKyBcIidcIjtcbiAgfSBlbHNlIHtcbiAgICBpZiAodG9rZW4gPT0gdGhpcy5FT0YpIHJldHVybiBcInRoZSBlbmQgb2YgZmlsZSAoRU9GKVwiO1xuICAgIHJldHVybiB0aGlzLmxleGVyLmVuZ2luZS50b2tlbnMudmFsdWVzW3Rva2VuXTtcbiAgfVxufTtcbi8qKlxuICogbWFpbiBlbnRyeSBwb2ludCA6IGNvbnZlcnRzIGEgc291cmNlIGNvZGUgdG8gQVNUXG4gKi9cblxuXG5wYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvZGUsIGZpbGVuYW1lKSB7XG4gIHRoaXMuX2Vycm9ycyA9IFtdO1xuICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWUgfHwgXCJldmFsXCI7XG4gIHRoaXMuY3VycmVudE5hbWVzcGFjZSA9IFtcIlwiXTtcblxuICBpZiAodGhpcy5leHRyYWN0RG9jKSB7XG4gICAgdGhpcy5fZG9jcyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2RvY3MgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZXh0cmFjdFRva2Vucykge1xuICAgIHRoaXMuX3Rva2VucyA9IFtdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3Rva2VucyA9IG51bGw7XG4gIH1cblxuICB0aGlzLl9kb2NJbmRleCA9IDA7XG4gIHRoaXMuX2xhc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5sZXhlci5zZXRJbnB1dChjb2RlKTtcbiAgdGhpcy5sZXhlci5hbGxfdG9rZW5zID0gdGhpcy5leHRyYWN0VG9rZW5zO1xuICB0aGlzLmxleGVyLmNvbW1lbnRfdG9rZW5zID0gdGhpcy5leHRyYWN0RG9jO1xuICB0aGlzLmxlbmd0aCA9IHRoaXMubGV4ZXIuX2lucHV0Lmxlbmd0aDtcbiAgdGhpcy5pbm5lckxpc3QgPSBmYWxzZTtcbiAgdGhpcy5pbm5lckxpc3RGb3JtID0gZmFsc2U7XG4gIHZhciBwcm9ncmFtID0gdGhpcy5ub2RlKFwicHJvZ3JhbVwiKTtcbiAgdmFyIGNoaWxkcyA9IFtdO1xuICB0aGlzLm5leHQoKTtcblxuICB3aGlsZSAodGhpcy50b2tlbiAhPSB0aGlzLkVPRikge1xuICAgIGNoaWxkcy5wdXNoKHRoaXMucmVhZF9zdGFydCgpKTtcbiAgfSAvLyBhcHBlbmQgbGFzdCBjb21tZW50XG5cblxuICBpZiAoY2hpbGRzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmV4dHJhY3REb2MgJiYgdGhpcy5fZG9jcy5sZW5ndGggPiB0aGlzLl9kb2NJbmRleCkge1xuICAgIGNoaWxkcy5wdXNoKHRoaXMubm9kZShcIm5vb3BcIikoKSk7XG4gIH0gLy8gIzE3NiA6IHJlZ2lzdGVyIGxhdGVzdCBwb3NpdGlvblxuXG5cbiAgdGhpcy5wcmV2ID0gW3RoaXMubGV4ZXIueXlsbG9jLmxhc3RfbGluZSwgdGhpcy5sZXhlci55eWxsb2MubGFzdF9jb2x1bW4sIHRoaXMubGV4ZXIub2Zmc2V0XTtcbiAgdmFyIHJlc3VsdCA9IHByb2dyYW0oY2hpbGRzLCB0aGlzLl9lcnJvcnMsIHRoaXMuX2RvY3MsIHRoaXMuX3Rva2Vucyk7XG5cbiAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICB2YXIgZXJyb3JzID0gdGhpcy5hc3QuY2hlY2tOb2RlcygpO1xuXG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICBlcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLnBvc2l0aW9uKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vZGUgYXQgbGluZSBcIiArIGVycm9yLnBvc2l0aW9uLmxpbmUgKyBcIiwgY29sdW1uIFwiICsgZXJyb3IucG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXG5cbiAgICAgICAgY29uc29sZS5sb2coZXJyb3Iuc3RhY2suam9pbihcIlxcblwiKSk7XG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWUgbm9kZXMgYXJlIG5vdCBjbG9zZWRcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4vKipcbiAqIFJhaXNlIGFuIGVycm9yXG4gKi9cblxuXG5wYXJzZXIucHJvdG90eXBlLnJhaXNlRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgbXNnRXhwZWN0LCBleHBlY3QsIHRva2VuKSB7XG4gIG1lc3NhZ2UgKz0gXCIgb24gbGluZSBcIiArIHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X2xpbmU7XG5cbiAgaWYgKCF0aGlzLnN1cHByZXNzRXJyb3JzKSB7XG4gICAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlLCB0aGlzLmZpbGVuYW1lLCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lKTtcbiAgICBlcnIubGluZU51bWJlciA9IHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X2xpbmU7XG4gICAgZXJyLmZpbGVOYW1lID0gdGhpcy5maWxlbmFtZTtcbiAgICBlcnIuY29sdW1uTnVtYmVyID0gdGhpcy5sZXhlci55eWxsb2MuZmlyc3RfY29sdW1uO1xuICAgIHRocm93IGVycjtcbiAgfSAvLyBFcnJvciBub2RlIDpcblxuXG4gIHZhciBub2RlID0gdGhpcy5hc3QucHJlcGFyZShcImVycm9yXCIsIG51bGwsIHRoaXMpKG1lc3NhZ2UsIHRva2VuLCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9saW5lLCBleHBlY3QpO1xuXG4gIHRoaXMuX2Vycm9ycy5wdXNoKG5vZGUpO1xuXG4gIHJldHVybiBub2RlO1xufTtcbi8qKlxuICogaGFuZGxpbmcgZXJyb3JzXG4gKi9cblxuXG5wYXJzZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGV4cGVjdCkge1xuICB2YXIgbXNnID0gXCJQYXJzZSBFcnJvciA6IHN5bnRheCBlcnJvclwiO1xuICB2YXIgdG9rZW4gPSB0aGlzLmdldFRva2VuTmFtZSh0aGlzLnRva2VuKTtcbiAgdmFyIG1zZ0V4cGVjdCA9IFwiXCI7XG5cbiAgaWYgKHRoaXMudG9rZW4gIT09IHRoaXMuRU9GKSB7XG4gICAgaWYgKGlzTnVtYmVyKHRoaXMudG9rZW4pKSB7XG4gICAgICB2YXIgc3ltYm9sID0gdGhpcy50ZXh0KCk7XG5cbiAgICAgIGlmIChzeW1ib2wubGVuZ3RoID4gMTApIHtcbiAgICAgICAgc3ltYm9sID0gc3ltYm9sLnN1YnN0cmluZygwLCA3KSArIFwiLi4uXCI7XG4gICAgICB9XG5cbiAgICAgIHRva2VuID0gXCInXCIgKyBzeW1ib2wgKyBcIicgKFwiICsgdG9rZW4gKyBcIilcIjtcbiAgICB9XG5cbiAgICBtc2cgKz0gXCIsIHVuZXhwZWN0ZWQgXCIgKyB0b2tlbjtcbiAgfVxuXG4gIGlmIChleHBlY3QgJiYgIUFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIGlmIChpc051bWJlcihleHBlY3QpIHx8IGV4cGVjdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIG1zZ0V4cGVjdCA9IFwiLCBleHBlY3RpbmcgXCIgKyB0aGlzLmdldFRva2VuTmFtZShleHBlY3QpO1xuICAgIH1cblxuICAgIG1zZyArPSBtc2dFeHBlY3Q7XG4gIH1cblxuICByZXR1cm4gdGhpcy5yYWlzZUVycm9yKG1zZywgbXNnRXhwZWN0LCBleHBlY3QsIHRva2VuKTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQVNUIG5vZGVcbiAqL1xuXG5cbnBhcnNlci5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICh0aGlzLmV4dHJhY3REb2MpIHtcbiAgICB2YXIgZG9jcyA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5fZG9jSW5kZXggPCB0aGlzLl9kb2NzLmxlbmd0aCkge1xuICAgICAgZG9jcyA9IHRoaXMuX2RvY3Muc2xpY2UodGhpcy5fZG9jSW5kZXgpO1xuICAgICAgdGhpcy5fZG9jSW5kZXggPSB0aGlzLl9kb2NzLmxlbmd0aDtcblxuICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2cobmV3IEVycm9yKFwiQXBwZW5kIGRvY3Mgb24gXCIgKyBuYW1lKSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgICAgICAgY29uc29sZS5sb2coZG9jcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzLmFzdC5wcmVwYXJlKG5hbWUsIGRvY3MsIHRoaXMpO1xuICAgIC8qKlxuICAgICAqIFRPS0VOUyA6XG4gICAgICogbm9kZTEgY29tbWVudEEgdG9rZW4gY29tbW1lbnRCIG5vZGUyIGNvbW1lbnRDIHRva2VuIGNvbW1lbnREIG5vZGUzIGNvbW1lbnRFIHRva2VuXG4gICAgICpcbiAgICAgKiBBU1QgOlxuICAgICAqIHN0cnVjdHVyZTpTMSBbXG4gICAgICogICAgbGVmdDogbm9kZTEgKCB0cmFpbDogY29tbWVudEEgKSxcbiAgICAgKiAgICByaWdodDogc3RydWN0dXJlOlMyIFtcbiAgICAgKiAgICAgICBub2RlMiAobGVhZDogY29tbWVudEIsIHRyYWlsOiBjb21tZW50QyksXG4gICAgICogICAgICAgbm9kZTMgKGxlYWQ6IGNvbW1lbnREKVxuICAgICAqICAgIF0sXG4gICAgICogICAgdHJhaWw6IGNvbW1lbnRFXG4gICAgICogXVxuICAgICAqXG4gICAgICogQWxnb3JpdGhtIDpcbiAgICAgKlxuICAgICAqIEF0dGFjaCB0aGUgbGFzdCBjb21tZW50cyBvbiBwYXJlbnQgb2YgY3VycmVudCBub2RlXG4gICAgICogSWYgYSBuZXcgbm9kZSBpcyBzdGFydGVkIGFuZCB0aGUgcGFyZW50IGhhcyBhIHRyYWlsaW5nIGNvbW1lbnRcbiAgICAgKiB0aGUgbW92ZSBpdCBvbiBwcmV2aW91cyBub2RlXG4gICAgICpcbiAgICAgKiBzdGFydCBTMlxuICAgICAqIHN0YXJ0IG5vZGUxXG4gICAgICogY29uc3VtZSBub2RlMSAmIHNldCBjb21tZW50QSBhcyB0cmFpbGluZ0NvbW1lbnQgb24gUzJcbiAgICAgKiBzdGFydCBTMlxuICAgICAqIFMxIGhhcyBhIHRyYWlsaW5nQ29tbWVudCwgYXR0YWNoIGl0IG9uIG5vZGUxXG4gICAgICogLi4uXG4gICAgICogTk9URSA6IEFzIHRoZSB0cmFpbGluZ0NvbW1lbnQgQmVoYXZpb3IgZGVwZW5kcyBvbiBBU1QsIGl0IHdpbGwgYmUgYnVpbGQgb25cbiAgICAgKiB0aGUgQVNUIGxheWVyIC0gbGFzdCBjaGlsZCBub2RlIHdpbGwga2VlcCBpdCdzIHRyYWlsaW5nQ29tbWVudCBub2Rlc1xuICAgICAqL1xuXG4gICAgbm9kZS5wb3N0QnVpbGQgPSBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgaWYgKHRoaXMuX2RvY0luZGV4IDwgdGhpcy5fZG9jcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3ROb2RlKSB7XG4gICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMucHJldlsyXTtcbiAgICAgICAgICB2YXIgbWF4ID0gdGhpcy5fZG9jSW5kZXg7XG5cbiAgICAgICAgICBmb3IgKDsgbWF4IDwgdGhpcy5fZG9jcy5sZW5ndGg7IG1heCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZG9jc1ttYXhdLm9mZnNldCA+IG9mZnNldCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF4ID4gdGhpcy5fZG9jSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIGluamVjdCB0cmFpbGluZyBjb21tZW50IG9uIGNoaWxkIG5vZGVcbiAgICAgICAgICAgIHRoaXMuX2xhc3ROb2RlLnNldFRyYWlsaW5nQ29tbWVudHModGhpcy5fZG9jcy5zbGljZSh0aGlzLl9kb2NJbmRleCwgbWF4KSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RvY0luZGV4ID0gbWF4O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLkVPRikge1xuICAgICAgICAgIC8vIGVuZCBvZiBjb250ZW50XG4gICAgICAgICAgc2VsZi5zZXRUcmFpbGluZ0NvbW1lbnRzKHRoaXMuX2RvY3Muc2xpY2UodGhpcy5fZG9jSW5kZXgpKTtcbiAgICAgICAgICB0aGlzLl9kb2NJbmRleCA9IHRoaXMuX2RvY3MubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhc3ROb2RlID0gc2VsZjtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFzdC5wcmVwYXJlKG5hbWUsIG51bGwsIHRoaXMpO1xufTtcbi8qKlxuICogZXhwZWN0cyBhbiBlbmQgb2Ygc3RhdGVtZW50IG9yIGVuZCBvZiBmaWxlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxucGFyc2VyLnByb3RvdHlwZS5leHBlY3RFbmRPZlN0YXRlbWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLnRva2VuID09PSBcIjtcIikge1xuICAgIC8vIGluY2x1ZGUgb25seSByZWFsICc7JyBzdGF0ZW1lbnRzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvaXNzdWVzLzE2NFxuICAgIGlmIChub2RlICYmIHRoaXMubGV4ZXIueXl0ZXh0ID09PSBcIjtcIikge1xuICAgICAgbm9kZS5pbmNsdWRlVG9rZW4odGhpcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfSU5MSU5FX0hUTUwgJiYgdGhpcy50b2tlbiAhPT0gdGhpcy5FT0YpIHtcbiAgICB0aGlzLmVycm9yKFwiO1wiKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqIG91dHB1dHMgc29tZSBkZWJ1ZyBpbmZvcm1hdGlvbiBvbiBjdXJyZW50IHRva2VuICoqL1xuXG5cbnZhciBpZ25vcmVTdGFjayA9IFtcInBhcnNlci5uZXh0XCIsIFwicGFyc2VyLm5vZGVcIiwgXCJwYXJzZXIuc2hvd2xvZ1wiXTtcblxucGFyc2VyLnByb3RvdHlwZS5zaG93bG9nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgdmFyIGxpbmU7XG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMjsgb2Zmc2V0IDwgc3RhY2subGVuZ3RoOyBvZmZzZXQrKykge1xuICAgIGxpbmUgPSBzdGFja1tvZmZzZXRdLnRyaW0oKTtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWdub3JlU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaW5lLnN1YnN0cmluZygzLCAzICsgaWdub3JlU3RhY2tbaV0ubGVuZ3RoKSA9PT0gaWdub3JlU3RhY2tbaV0pIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuXG4gIGNvbnNvbGUubG9nKFwiTGluZSBcIiArIHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X2xpbmUgKyBcIiA6IFwiICsgdGhpcy5nZXRUb2tlbk5hbWUodGhpcy50b2tlbikgKyBcIj5cIiArIHRoaXMubGV4ZXIueXl0ZXh0ICsgXCI8XCIgKyBcIiBALS0+XCIgKyBsaW5lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBGb3JjZSB0aGUgcGFyc2VyIHRvIGNoZWNrIHRoZSBjdXJyZW50IHRva2VuLlxuICpcbiAqIElmIHRoZSBjdXJyZW50IHRva2VuIGRvZXMgbm90IG1hdGNoIHRvIGV4cGVjdGVkIHRva2VuLFxuICogdGhlIGFuIGVycm9yIHdpbGwgYmUgcmFpc2VkLlxuICpcbiAqIElmIHRoZSBzdXBwcmVzc0Vycm9yIG1vZGUgaXMgYWN0aXZhdGVkLCB0aGVuIHRoZSBlcnJvciB3aWxsXG4gKiBiZSBhZGRlZCB0byB0aGUgcHJvZ3JhbSBlcnJvciBzdGFjayBhbmQgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBgZmFsc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdG9rZW5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAdGhyb3dzIEVycm9yXG4gKi9cblxuXG5wYXJzZXIucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uICh0b2tlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcbiAgICBpZiAodG9rZW4uaW5kZXhPZih0aGlzLnRva2VuKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuZXJyb3IodG9rZW4pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnRva2VuICE9IHRva2VuKSB7XG4gICAgdGhpcy5lcnJvcih0b2tlbik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRva2VuIGNvbnRlbnRzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuXG5wYXJzZXIucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxleGVyLnl5dGV4dDtcbn07XG4vKiogY29uc3VtZSB0aGUgbmV4dCB0b2tlbiAqKi9cblxuXG5wYXJzZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHByZXBhcmUgdGhlIGJhY2sgY29tbWFuZFxuICBpZiAodGhpcy50b2tlbiAhPT0gXCI7XCIgfHwgdGhpcy5sZXhlci55eXRleHQgPT09IFwiO1wiKSB7XG4gICAgLy8gaWdub3JlICc/PicgZnJvbSBhdXRvbWF0ZWQgcmVzb2x1dGlvblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2lzc3Vlcy8xNjhcbiAgICB0aGlzLnByZXYgPSBbdGhpcy5sZXhlci55eWxsb2MubGFzdF9saW5lLCB0aGlzLmxleGVyLnl5bGxvYy5sYXN0X2NvbHVtbiwgdGhpcy5sZXhlci5vZmZzZXRdO1xuICB9IC8vIGVhdGluZyB0aGUgdG9rZW5cblxuXG4gIHRoaXMubGV4KCk7IC8vIHNob3dpbmcgdGhlIGRlYnVnXG5cbiAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICB0aGlzLnNob3dsb2coKTtcbiAgfSAvLyBoYW5kbGluZyBjb21tZW50c1xuXG5cbiAgaWYgKHRoaXMuZXh0cmFjdERvYykge1xuICAgIHdoaWxlICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NPTU1FTlQgfHwgdGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9ET0NfQ09NTUVOVCkge1xuICAgICAgLy8gQVBQRU5EIENPTU1FTlRTXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DT01NRU5UKSB7XG4gICAgICAgIHRoaXMuX2RvY3MucHVzaCh0aGlzLnJlYWRfY29tbWVudCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2RvY3MucHVzaCh0aGlzLnJlYWRfZG9jX2NvbW1lbnQoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBFYXRpbmcgYSB0b2tlblxuICovXG5cblxucGFyc2VyLnByb3RvdHlwZS5sZXggPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGFwcGVuZCBvbiB0b2tlbiBzdGFja1xuICBpZiAodGhpcy5leHRyYWN0VG9rZW5zKSB7XG4gICAgZG8ge1xuICAgICAgLy8gdGhlIHRva2VuXG4gICAgICB0aGlzLnRva2VuID0gdGhpcy5sZXhlci5sZXgoKSB8fCB0aGlzLkVPRjtcbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLkVPRikgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZW50cnkgPSB0aGlzLmxleGVyLnl5dGV4dDtcblxuICAgICAgaWYgKHRoaXMubGV4ZXIuZW5naW5lLnRva2Vucy52YWx1ZXMuaGFzT3duUHJvcGVydHkodGhpcy50b2tlbikpIHtcbiAgICAgICAgZW50cnkgPSBbdGhpcy5sZXhlci5lbmdpbmUudG9rZW5zLnZhbHVlc1t0aGlzLnRva2VuXSwgZW50cnksIHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X2xpbmUsIHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldCwgdGhpcy5sZXhlci5vZmZzZXRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnkgPSBbbnVsbCwgZW50cnksIHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X2xpbmUsIHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldCwgdGhpcy5sZXhlci5vZmZzZXRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90b2tlbnMucHVzaChlbnRyeSk7XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NMT1NFX1RBRykge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi83ZmYxODY0MzRlODJlZTdiZTdjNTlkMGRiOWE5NzY2NDFjZjdiMDljL1plbmQvemVuZF9jb21waWxlLmMjTDE2ODBcbiAgICAgICAgdGhpcy50b2tlbiA9IFwiO1wiO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9PUEVOX1RBR19XSVRIX0VDSE8pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRoaXMudG9rLlRfRUNITztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSB3aGlsZSAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9XSElURVNQQUNFIHx8IC8vIGlnbm9yZSB3aGl0ZSBzcGFjZVxuICAgICF0aGlzLmV4dHJhY3REb2MgJiYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ09NTUVOVCB8fCAvLyBpZ25vcmUgc2luZ2xlIGxpbmVzIGNvbW1lbnRzXG4gICAgdGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9ET0NfQ09NTUVOVCkgfHwgLy8gaWdub3JlIGRvYyBjb21tZW50c1xuICAgIC8vIGlnbm9yZSBvcGVuIHRhZ3NcbiAgICB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX09QRU5fVEFHKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRva2VuID0gdGhpcy5sZXhlci5sZXgoKSB8fCB0aGlzLkVPRjtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQ2hlY2sgaWYgdG9rZW4gaXMgb2Ygc3BlY2lmaWVkIHR5cGVcbiAqL1xuXG5cbnBhcnNlci5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgIHJldHVybiB0eXBlLmluZGV4T2YodGhpcy50b2tlbikgIT09IC0xO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZW50cmllc1t0eXBlXS5oYXModGhpcy50b2tlbik7XG59OyAvLyBleHRlbmRzIHRoZSBwYXJzZXIgd2l0aCBzeW50YXggZmlsZXNcblxuXG5bX193ZWJwYWNrX3JlcXVpcmVfXygyNCksIF9fd2VicGFja19yZXF1aXJlX18oMjUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNyksIF9fd2VicGFja19yZXF1aXJlX18oMjgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMCksIF9fd2VicGFja19yZXF1aXJlX18oMzEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMyksIF9fd2VicGFja19yZXF1aXJlX18oMzQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzNiksIF9fd2VicGFja19yZXF1aXJlX18oMzcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KV0uZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG4gIGZvciAodmFyIGsgaW4gZXh0KSB7XG4gICAgaWYgKHBhcnNlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvaXNzdWVzLzIzNFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gXCIgKyBrICsgXCIgaXMgYWxyZWFkeSBkZWZpbmVkIC0gY29sbGlzaW9uXCIpO1xuICAgIH1cblxuICAgIHBhcnNlci5wcm90b3R5cGVba10gPSBleHRba107XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBwYXJzZXI7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIFBhcnNlIGFuIGFycmF5XG4gICAqIGBgYGVibmZcbiAgICogYXJyYXkgOjo9IFRfQVJSQVkgJygnIGFycmF5X3BhaXJfbGlzdCAnKScgfFxuICAgKiAgICdbJyBhcnJheV9wYWlyX2xpc3QgJ10nXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9hcnJheTogZnVuY3Rpb24gcmVhZF9hcnJheSgpIHtcbiAgICB2YXIgZXhwZWN0ID0gbnVsbDtcbiAgICB2YXIgc2hvcnRGb3JtID0gZmFsc2U7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImFycmF5XCIpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQVJSQVkpIHtcbiAgICAgIHRoaXMubmV4dCgpLmV4cGVjdChcIihcIik7XG4gICAgICBleHBlY3QgPSBcIilcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvcnRGb3JtID0gdHJ1ZTtcbiAgICAgIGV4cGVjdCA9IFwiXVwiO1xuICAgIH1cblxuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKHRoaXMubmV4dCgpLnRva2VuICE9PSBleHBlY3QpIHtcbiAgICAgIGl0ZW1zID0gdGhpcy5yZWFkX2FycmF5X3BhaXJfbGlzdChzaG9ydEZvcm0pO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KGV4cGVjdCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHJlc3VsdChzaG9ydEZvcm0sIGl0ZW1zKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYW4gYXJyYXkgb2YgaXRlbXNcbiAgICogYGBgZWJuZlxuICAgKiBhcnJheV9wYWlyX2xpc3QgOjo9IGFycmF5X3BhaXIgKCcsJyBhcnJheV9wYWlyPykqXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9hcnJheV9wYWlyX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfYXJyYXlfcGFpcl9saXN0KHNob3J0Rm9ybSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5yZWFkX2xpc3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYucmVhZF9hcnJheV9wYWlyKHNob3J0Rm9ybSk7XG4gICAgfSwgXCIsXCIsIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhbiBlbnRyeVxuICAgKiBhcnJheV9wYWlyOlxuICAgKiAgZXhwciBUX0RPVUJMRV9BUlJPVyBleHByXG4gICAqICB8IGV4cHJcbiAgICogIHwgZXhwciBUX0RPVUJMRV9BUlJPVyAnJicgdmFyaWFibGVcbiAgICogIHwgJyYnIHZhcmlhYmxlXG4gICAqICB8IGV4cHIgVF9ET1VCTEVfQVJST1cgVF9MSVNUICcoJyBhcnJheV9wYWlyX2xpc3QgJyknXG4gICAqICB8IFRfTElTVCAnKCcgYXJyYXlfcGFpcl9saXN0ICcpJ1xuICAgKi9cbiAgcmVhZF9hcnJheV9wYWlyOiBmdW5jdGlvbiByZWFkX2FycmF5X3BhaXIoc2hvcnRGb3JtKSB7XG4gICAgaWYgKCFzaG9ydEZvcm0gJiYgdGhpcy50b2tlbiA9PT0gXCIpXCIgfHwgc2hvcnRGb3JtICYmIHRoaXMudG9rZW4gPT09IFwiXVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiLFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKFwibm9vcFwiKSgpO1xuICAgIH1cblxuICAgIHZhciBlbnRyeSA9IHRoaXMubm9kZShcImVudHJ5XCIpO1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgdmFyIGJ5UmVmID0gZmFsc2U7XG4gICAgdmFyIHVucGFjayA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiJlwiKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGJ5UmVmID0gdHJ1ZTtcbiAgICAgIHZhbHVlID0gdGhpcy5yZWFkX3ZhcmlhYmxlKHRydWUsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRUxMSVBTSVMgJiYgdGhpcy52ZXJzaW9uID49IDcwNCkge1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSBcIiZcIikge1xuICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHVucGFjayA9IHRydWU7XG4gICAgICB2YWx1ZSA9IHRoaXMucmVhZF9leHByKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBleHByID0gdGhpcy5yZWFkX2V4cHIoKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9VQkxFX0FSUk9XKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBrZXkgPSBleHByO1xuXG4gICAgICAgIGlmICh0aGlzLnRva2VuID09PSBcIiZcIikge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGJ5UmVmID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMucmVhZF92YXJpYWJsZSh0cnVlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnJlYWRfZXhwcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGV4cHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5KGtleSwgdmFsdWUsIGJ5UmVmLCB1bnBhY2spO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiByZWFkaW5nIGEgY2xhc3NcbiAgICogYGBgZWJuZlxuICAgKiBjbGFzcyA6Oj0gY2xhc3Nfc2NvcGU/IFRfQ0xBU1MgVF9TVFJJTkcgKFRfRVhURU5EUyBOQU1FU1BBQ0VfTkFNRSk/IChUX0lNUExFTUVOVFMgKE5BTUVTUEFDRV9OQU1FICcsJykqIE5BTUVTUEFDRV9OQU1FKT8gJ3snIENMQVNTX0JPRFkgJ30nXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9jbGFzc19kZWNsYXJhdGlvbl9zdGF0ZW1lbnQ6IGZ1bmN0aW9uIHJlYWRfY2xhc3NfZGVjbGFyYXRpb25fc3RhdGVtZW50KCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJjbGFzc1wiKTtcbiAgICB2YXIgZmxhZyA9IHRoaXMucmVhZF9jbGFzc19tb2RpZmllcnMoKTsgLy8gZ3JhY2VmdWwgbW9kZSA6IGlnbm9yZSB0b2tlbiAmIGdvIG5leHRcblxuICAgIGlmICh0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX0NMQVNTKSB7XG4gICAgICB0aGlzLmVycm9yKHRoaXMudG9rLlRfQ0xBU1MpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKS5leHBlY3QodGhpcy50b2suVF9TVFJJTkcpO1xuICAgIHZhciBwcm9wTmFtZSA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBwcm9wTmFtZSA9IHByb3BOYW1lKG5hbWUpO1xuICAgIHZhciBwcm9wRXh0ZW5kcyA9IHRoaXMucmVhZF9leHRlbmRzX2Zyb20oKTtcbiAgICB2YXIgcHJvcEltcGxlbWVudHMgPSB0aGlzLnJlYWRfaW1wbGVtZW50c19saXN0KCk7XG4gICAgdGhpcy5leHBlY3QoXCJ7XCIpO1xuICAgIHZhciBib2R5ID0gdGhpcy5uZXh0KCkucmVhZF9jbGFzc19ib2R5KCk7XG4gICAgcmV0dXJuIHJlc3VsdChwcm9wTmFtZSwgcHJvcEV4dGVuZHMsIHByb3BJbXBsZW1lbnRzLCBib2R5LCBmbGFnKTtcbiAgfSxcbiAgcmVhZF9jbGFzc19tb2RpZmllcnM6IGZ1bmN0aW9uIHJlYWRfY2xhc3NfbW9kaWZpZXJzKCkge1xuICAgIHJldHVybiBbMCwgMCwgdGhpcy5yZWFkX2NsYXNzX21vZGlmaWVyKCldO1xuICB9LFxuICByZWFkX2NsYXNzX21vZGlmaWVyOiBmdW5jdGlvbiByZWFkX2NsYXNzX21vZGlmaWVyKCkge1xuICAgIHZhciByZXN1bHQgPSAwO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQUJTVFJBQ1QpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0ZJTkFMKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgY2xhc3MgYm9keVxuICAgKiBgYGBlYm5mXG4gICAqICAgY2xhc3NfYm9keSA6Oj0gKG1lbWJlcl9mbGFncz8gKFRfVkFSIHwgVF9TVFJJTkcgfCBUX0ZVTkNUSU9OKSkqXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9jbGFzc19ib2R5OiBmdW5jdGlvbiByZWFkX2NsYXNzX2JvZHkoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKHRoaXMudG9rZW4gIT09IHRoaXMuRU9GICYmIHRoaXMudG9rZW4gIT09IFwifVwiKSB7XG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DT01NRU5UKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmVhZF9jb21tZW50KCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9DX0NPTU1FTlQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5yZWFkX2RvY19jb21tZW50KCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gY2hlY2sgVF9VU0UgdHJhaXRcblxuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9VU0UpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLnJlYWRfdHJhaXRfdXNlX3N0YXRlbWVudCgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHJlYWQgbWVtYmVyIGZsYWdzXG5cblxuICAgICAgdmFyIGZsYWdzID0gdGhpcy5yZWFkX21lbWJlcl9mbGFncyhmYWxzZSk7IC8vIGNoZWNrIGNvbnN0YW50XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NPTlNUKSB7XG4gICAgICAgIHZhciBjb25zdGFudHMgPSB0aGlzLnJlYWRfY29uc3RhbnRfbGlzdChmbGFncyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiO1wiKSkge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChjb25zdGFudHMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8ganVtcCBvdmVyIFRfVkFSIHRoZW4gbGFuZCBvbiBUX1ZBUklBQkxFXG5cblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfVkFSKSB7XG4gICAgICAgIHRoaXMubmV4dCgpLmV4cGVjdCh0aGlzLnRvay5UX1ZBUklBQkxFKTtcbiAgICAgICAgZmxhZ3NbMF0gPSBudWxsOyAvLyBwdWJsaWMgKGFzIG51bGwpXG5cbiAgICAgICAgZmxhZ3NbMV0gPSAwOyAvLyBub24gc3RhdGljIHZhclxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9GVU5DVElPTikge1xuICAgICAgICAvLyByZWFkcyBhIGZ1bmN0aW9uXG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmVhZF9mdW5jdGlvbihmYWxzZSwgZmxhZ3MpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9WQVJJQUJMRSB8fCAvLyBzdXBwb3J0IGh0dHBzOi8vd2lraS5waHAubmV0L3JmYy90eXBlZF9wcm9wZXJ0aWVzX3YyXG4gICAgICB0aGlzLnZlcnNpb24gPj0gNzA0ICYmICh0aGlzLnRva2VuID09PSBcIj9cIiB8fCB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NBTExBQkxFIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQVJSQVkgfHwgdGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9OU19TRVBBUkFUT1IgfHwgdGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9TVFJJTkcgfHwgdGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9OQU1FU1BBQ0UpKSB7XG4gICAgICAgIC8vIHJlYWRzIGEgdmFyaWFibGVcbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IHRoaXMucmVhZF92YXJpYWJsZV9saXN0KGZsYWdzKTtcbiAgICAgICAgdGhpcy5leHBlY3QoXCI7XCIpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh2YXJpYWJsZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmFpc2UgYW4gZXJyb3JcbiAgICAgICAgdGhpcy5lcnJvcihbdGhpcy50b2suVF9DT05TVCwgdGhpcy50b2suVF9WQVJJQUJMRSwgdGhpcy50b2suVF9GVU5DVElPTl0pOyAvLyBpZ25vcmUgdG9rZW5cblxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdChcIn1cIik7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgdmFyaWFibGUgbGlzdFxuICAgKiBgYGBlYm5mXG4gICAqICB2YXJpYWJsZV9saXN0IDo6PSAodmFyaWFibGVfZGVjbGFyYXRpb24gJywnKSogdmFyaWFibGVfZGVjbGFyYXRpb25cbiAgICogYGBgXG4gICAqL1xuICByZWFkX3ZhcmlhYmxlX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfdmFyaWFibGVfbGlzdChmbGFncykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJwcm9wZXJ0eXN0YXRlbWVudFwiKTtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMucmVhZF9saXN0KFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgdmFyaWFibGUgZGVjbGFyYXRpb25cbiAgICAgKlxuICAgICAqIGBgYGVibmZcbiAgICAgKiAgdmFyaWFibGVfZGVjbGFyYXRpb24gOjo9IFRfVkFSSUFCTEUgJz0nIHNjYWxhclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlYWRfdmFyaWFibGVfZGVjbGFyYXRpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwicHJvcGVydHlcIik7XG5cbiAgICAgIHZhciBfdGhpcyRyZWFkX29wdGlvbmFsX3QgPSB0aGlzLnJlYWRfb3B0aW9uYWxfdHlwZSgpLFxuICAgICAgICAgIF90aGlzJHJlYWRfb3B0aW9uYWxfdDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRyZWFkX29wdGlvbmFsX3QsIDIpLFxuICAgICAgICAgIG51bGxhYmxlID0gX3RoaXMkcmVhZF9vcHRpb25hbF90MlswXSxcbiAgICAgICAgICB0eXBlID0gX3RoaXMkcmVhZF9vcHRpb25hbF90MlsxXTtcblxuICAgICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9WQVJJQUJMRSk7XG4gICAgICB2YXIgcHJvcE5hbWUgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKS5zdWJzdHJpbmcoMSk7IC8vIGlnbm9yZSAkXG5cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcHJvcE5hbWUgPSBwcm9wTmFtZShuYW1lKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IFwiO1wiIHx8IHRoaXMudG9rZW4gPT09IFwiLFwiKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQocHJvcE5hbWUsIG51bGwsIG51bGxhYmxlLCB0eXBlKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gXCI9XCIpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMODE1XG4gICAgICAgIHJldHVybiByZXN1bHQocHJvcE5hbWUsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBudWxsYWJsZSwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdChbXCIsXCIsIFwiO1wiLCBcIj1cIl0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHByb3BOYW1lLCBudWxsLCBudWxsYWJsZSwgdHlwZSk7XG4gICAgICB9XG4gICAgfSwgXCIsXCIpO1xuICAgIHJldHVybiByZXN1bHQobnVsbCwgcHJvcGVydGllcywgZmxhZ3MpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBjb25zdGFudCBsaXN0XG4gICAqIGBgYGVibmZcbiAgICogIGNvbnN0YW50X2xpc3QgOjo9IFRfQ09OU1QgKGNvbnN0YW50X2RlY2xhcmF0aW9uICcsJykqIGNvbnN0YW50X2RlY2xhcmF0aW9uXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9jb25zdGFudF9saXN0OiBmdW5jdGlvbiByZWFkX2NvbnN0YW50X2xpc3QoZmxhZ3MpIHtcbiAgICBpZiAodGhpcy5leHBlY3QodGhpcy50b2suVF9DT05TVCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJjbGFzc2NvbnN0YW50XCIpO1xuICAgIHZhciBpdGVtcyA9IHRoaXMucmVhZF9saXN0KFxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgY29uc3RhbnQgZGVjbGFyYXRpb25cbiAgICAgKlxuICAgICAqIGBgYGVibmZcbiAgICAgKiAgY29uc3RhbnRfZGVjbGFyYXRpb24gOjo9IChUX1NUUklORyB8IElERU5USUZJRVIpICc9JyBleHByXG4gICAgICogYGBgXG4gICAgICogQHJldHVybiB7Q29uc3RhbnR9IFs6bGluazpdKEFTVC5tZCNjb25zdGFudClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkX2NvbnN0YW50X2RlY2xhcmF0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImNvbnN0YW50XCIpO1xuICAgICAgdmFyIGNvbnN0TmFtZSA9IG51bGw7XG4gICAgICB2YXIgdmFsdWUgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9TVFJJTkcgfHwgdGhpcy52ZXJzaW9uID49IDcwMCAmJiB0aGlzLmlzKFwiSURFTlRJRklFUlwiKSkge1xuICAgICAgICBjb25zdE5hbWUgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgY29uc3ROYW1lID0gY29uc3ROYW1lKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoXCJJREVOVElGSUVSXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5leHBlY3QoXCI9XCIpKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQoY29uc3ROYW1lLCB2YWx1ZSk7XG4gICAgfSwgXCIsXCIpO1xuICAgIHJldHVybiByZXN1bHQobnVsbCwgaXRlbXMsIGZsYWdzKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZCBtZW1iZXIgZmxhZ3NcbiAgICogQHJldHVybiBhcnJheVxuICAgKiAgMXN0IGluZGV4IDogMCA9PiBwdWJsaWMsIDEgPT4gcHJvdGVjdGVkLCAyID0+IHByaXZhdGVcbiAgICogIDJuZCBpbmRleCA6IDAgPT4gaW5zdGFuY2UgbWVtYmVyLCAxID0+IHN0YXRpYyBtZW1iZXJcbiAgICogIDNyZCBpbmRleCA6IDAgPT4gbm9ybWFsLCAxID0+IGFic3RyYWN0IG1lbWJlciwgMiA9PiBmaW5hbCBtZW1iZXJcbiAgICovXG4gIHJlYWRfbWVtYmVyX2ZsYWdzOiBmdW5jdGlvbiByZWFkX21lbWJlcl9mbGFncyhhc0ludGVyZmFjZSkge1xuICAgIHZhciByZXN1bHQgPSBbLTEsIC0xLCAtMV07XG5cbiAgICBpZiAodGhpcy5pcyhcIlRfTUVNQkVSX0ZMQUdTXCIpKSB7XG4gICAgICB2YXIgaWR4ID0gMCxcbiAgICAgICAgICB2YWwgPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50b2tlbikge1xuICAgICAgICAgIGNhc2UgdGhpcy50b2suVF9QVUJMSUM6XG4gICAgICAgICAgICBpZHggPSAwO1xuICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSB0aGlzLnRvay5UX1BST1RFQ1RFRDpcbiAgICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHRoaXMudG9rLlRfUFJJVkFURTpcbiAgICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgICAgICB2YWwgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHRoaXMudG9rLlRfU1RBVElDOlxuICAgICAgICAgICAgaWR4ID0gMTtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgdGhpcy50b2suVF9BQlNUUkFDVDpcbiAgICAgICAgICAgIGlkeCA9IDI7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIHRoaXMudG9rLlRfRklOQUw6XG4gICAgICAgICAgICBpZHggPSAyO1xuICAgICAgICAgICAgdmFsID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFzSW50ZXJmYWNlKSB7XG4gICAgICAgICAgaWYgKGlkeCA9PSAwICYmIHZhbCA9PSAyKSB7XG4gICAgICAgICAgICAvLyBhbiBpbnRlcmZhY2UgY2FuJ3QgYmUgcHJpdmF0ZVxuICAgICAgICAgICAgdGhpcy5leHBlY3QoW3RoaXMudG9rLlRfUFVCTElDLCB0aGlzLnRvay5UX1BST1RFQ1RFRF0pO1xuICAgICAgICAgICAgdmFsID0gLTE7XG4gICAgICAgICAgfSBlbHNlIGlmIChpZHggPT0gMiAmJiB2YWwgPT0gMSkge1xuICAgICAgICAgICAgLy8gYW4gaW50ZXJmYWNlIGNhbnQgYmUgYWJzdHJhY3RcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgICAgIHZhbCA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHRbaWR4XSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBhbHJlYWR5IGRlZmluZWQgZmxhZ1xuICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgIT09IC0xKSB7XG4gICAgICAgICAgcmVzdWx0W2lkeF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHRoaXMubmV4dCgpLmlzKFwiVF9NRU1CRVJfRkxBR1NcIikpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHRbMV0gPT0gLTEpIHJlc3VsdFsxXSA9IDA7XG4gICAgaWYgKHJlc3VsdFsyXSA9PSAtMSkgcmVzdWx0WzJdID0gMDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBvcHRpb25hbF90eXBlOlxuICAgKlx0ICAvLSBlbXB0eSAtL1x0eyAkJCA9IE5VTEw7IH1cbiAgICogICB8XHR0eXBlX2V4cHJcdHsgJCQgPSAkMTsgfVxuICAgKiA7XG4gICAqXG4gICAqIHR5cGVfZXhwcjpcbiAgICpcdFx0dHlwZVx0XHR7ICQkID0gJDE7IH1cbiAgICpcdHxcdCc/JyB0eXBlXHR7ICQkID0gJDI7ICQkLT5hdHRyIHw9IFpFTkRfVFlQRV9OVUxMQUJMRTsgfVxuICAgKlx0fFx0dW5pb25fdHlwZVx0eyAkJCA9ICQxOyB9XG4gICAqIDtcbiAgICpcbiAgICogdHlwZTpcbiAgICogXHRcdFRfQVJSQVlcdFx0eyAkJCA9IHplbmRfYXN0X2NyZWF0ZV9leChaRU5EX0FTVF9UWVBFLCBJU19BUlJBWSk7IH1cbiAgICogXHR8XHRUX0NBTExBQkxFXHR7ICQkID0gemVuZF9hc3RfY3JlYXRlX2V4KFpFTkRfQVNUX1RZUEUsIElTX0NBTExBQkxFKTsgfVxuICAgKiBcdHxcdG5hbWVcdFx0eyAkJCA9ICQxOyB9XG4gICAqIDtcbiAgICpcbiAgICogdW5pb25fdHlwZTpcbiAgICogXHRcdHR5cGUgJ3wnIHR5cGUgICAgICAgeyAkJCA9IHplbmRfYXN0X2NyZWF0ZV9saXN0KDIsIFpFTkRfQVNUX1RZUEVfVU5JT04sICQxLCAkMyk7IH1cbiAgICogXHR8XHR1bmlvbl90eXBlICd8JyB0eXBlIHsgJCQgPSB6ZW5kX2FzdF9saXN0X2FkZCgkMSwgJDMpOyB9XG4gICAqIDtcbiAgICovXG4gIHJlYWRfb3B0aW9uYWxfdHlwZTogZnVuY3Rpb24gcmVhZF9vcHRpb25hbF90eXBlKCkge1xuICAgIHZhciBudWxsYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiP1wiKSB7XG4gICAgICBudWxsYWJsZSA9IHRydWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHRoaXMucmVhZF90eXBlKCk7XG5cbiAgICBpZiAobnVsbGFibGUgJiYgIXR5cGUpIHtcbiAgICAgIHRoaXMucmFpc2VFcnJvcihcIkV4cGVjdGluZyBhIHR5cGUgZGVmaW5pdGlvbiBjb21iaW5lZCB3aXRoIG51bGxhYmxlIG9wZXJhdG9yXCIpO1xuICAgIH1cblxuICAgIGlmICghbnVsbGFibGUgJiYgIXR5cGUpIHtcbiAgICAgIHJldHVybiBbZmFsc2UsIG51bGxdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcInxcIikge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcblxuICAgICAgZG8ge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdmFyIHZhcmlhbnQgPSB0aGlzLnJlYWRfdHlwZSgpO1xuXG4gICAgICAgIGlmICghdmFyaWFudCkge1xuICAgICAgICAgIHRoaXMucmFpc2VFcnJvcihcIkV4cGVjdGluZyBhIHR5cGUgZGVmaW5pdGlvblwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGUucHVzaCh2YXJpYW50KTtcbiAgICAgIH0gd2hpbGUgKHRoaXMudG9rZW4gPT09IFwifFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW251bGxhYmxlLCB0eXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogcmVhZGluZyBhbiBpbnRlcmZhY2VcbiAgICogYGBgZWJuZlxuICAgKiBpbnRlcmZhY2UgOjo9IFRfSU5URVJGQUNFIFRfU1RSSU5HIChUX0VYVEVORFMgKE5BTUVTUEFDRV9OQU1FICcsJykqIE5BTUVTUEFDRV9OQU1FKT8gJ3snIElOVEVSRkFDRV9CT0RZICd9J1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfaW50ZXJmYWNlX2RlY2xhcmF0aW9uX3N0YXRlbWVudDogZnVuY3Rpb24gcmVhZF9pbnRlcmZhY2VfZGVjbGFyYXRpb25fc3RhdGVtZW50KCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJpbnRlcmZhY2VcIik7XG5cbiAgICBpZiAodGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9JTlRFUkZBQ0UpIHtcbiAgICAgIHRoaXMuZXJyb3IodGhpcy50b2suVF9JTlRFUkZBQ0UpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm5leHQoKS5leHBlY3QodGhpcy50b2suVF9TVFJJTkcpO1xuICAgIHZhciBwcm9wTmFtZSA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBwcm9wTmFtZSA9IHByb3BOYW1lKG5hbWUpO1xuICAgIHZhciBwcm9wRXh0ZW5kcyA9IHRoaXMucmVhZF9pbnRlcmZhY2VfZXh0ZW5kc19saXN0KCk7XG4gICAgdGhpcy5leHBlY3QoXCJ7XCIpO1xuICAgIHZhciBib2R5ID0gdGhpcy5uZXh0KCkucmVhZF9pbnRlcmZhY2VfYm9keSgpO1xuICAgIHJldHVybiByZXN1bHQocHJvcE5hbWUsIHByb3BFeHRlbmRzLCBib2R5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYW4gaW50ZXJmYWNlIGJvZHlcbiAgICogYGBgZWJuZlxuICAgKiAgIGludGVyZmFjZV9ib2R5IDo6PSAobWVtYmVyX2ZsYWdzPyAoVF9DT05TVCB8IFRfRlVOQ1RJT04pKSpcbiAgICogYGBgXG4gICAqL1xuICByZWFkX2ludGVyZmFjZV9ib2R5OiBmdW5jdGlvbiByZWFkX2ludGVyZmFjZV9ib2R5KCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICh0aGlzLnRva2VuICE9PSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSBcIn1cIikge1xuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ09NTUVOVCkge1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnJlYWRfY29tbWVudCgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0RPQ19DT01NRU5UKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmVhZF9kb2NfY29tbWVudCgpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHJlYWQgbWVtYmVyIGZsYWdzXG5cblxuICAgICAgdmFyIGZsYWdzID0gdGhpcy5yZWFkX21lbWJlcl9mbGFncyh0cnVlKTsgLy8gY2hlY2sgY29uc3RhbnRcblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT0gdGhpcy50b2suVF9DT05TVCkge1xuICAgICAgICB2YXIgY29uc3RhbnRzID0gdGhpcy5yZWFkX2NvbnN0YW50X2xpc3QoZmxhZ3MpO1xuXG4gICAgICAgIGlmICh0aGlzLmV4cGVjdChcIjtcIikpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY29uc3RhbnRzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9GVU5DVElPTikge1xuICAgICAgICAvLyByZWFkcyBhIGZ1bmN0aW9uXG4gICAgICAgIHZhciBtZXRob2QgPSB0aGlzLnJlYWRfZnVuY3Rpb25fZGVjbGFyYXRpb24oMiwgZmxhZ3MpO1xuICAgICAgICBtZXRob2QucGFyc2VGbGFncyhmbGFncyk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGhvZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiO1wiKSkge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByYWlzZSBhbiBlcnJvclxuICAgICAgICB0aGlzLmVycm9yKFt0aGlzLnRvay5UX0NPTlNULCB0aGlzLnRvay5UX0ZVTkNUSU9OXSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cGVjdChcIn1cIikpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlYWRpbmcgYSB0cmFpdFxuICAgKiBgYGBlYm5mXG4gICAqIHRyYWl0IDo6PSBUX1RSQUlUIFRfU1RSSU5HIChUX0VYVEVORFMgKE5BTUVTUEFDRV9OQU1FICcsJykqIE5BTUVTUEFDRV9OQU1FKT8gJ3snIEZVTkNUSU9OKiAnfSdcbiAgICogYGBgXG4gICAqL1xuICByZWFkX3RyYWl0X2RlY2xhcmF0aW9uX3N0YXRlbWVudDogZnVuY3Rpb24gcmVhZF90cmFpdF9kZWNsYXJhdGlvbl9zdGF0ZW1lbnQoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcInRyYWl0XCIpOyAvLyBncmFjZWZ1bCBtb2RlIDogaWdub3JlIHRva2VuICYgZ28gbmV4dFxuXG4gICAgaWYgKHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfVFJBSVQpIHtcbiAgICAgIHRoaXMuZXJyb3IodGhpcy50b2suVF9UUkFJVCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMubmV4dCgpLmV4cGVjdCh0aGlzLnRvay5UX1NUUklORyk7XG4gICAgdmFyIHByb3BOYW1lID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICB2YXIgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHByb3BOYW1lID0gcHJvcE5hbWUobmFtZSk7XG4gICAgdGhpcy5leHBlY3QoXCJ7XCIpO1xuICAgIHZhciBib2R5ID0gdGhpcy5uZXh0KCkucmVhZF9jbGFzc19ib2R5KCk7XG4gICAgcmV0dXJuIHJlc3VsdChwcm9wTmFtZSwgYm9keSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlYWRpbmcgYSB1c2Ugc3RhdGVtZW50XG4gICAqIGBgYGVibmZcbiAgICogdHJhaXRfdXNlX3N0YXRlbWVudCA6Oj0gbmFtZXNwYWNlX25hbWUgKCcsJyBuYW1lc3BhY2VfbmFtZSkqICgneycgdHJhaXRfdXNlX2FsaWFzICd9Jyk/XG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF90cmFpdF91c2Vfc3RhdGVtZW50OiBmdW5jdGlvbiByZWFkX3RyYWl0X3VzZV9zdGF0ZW1lbnQoKSB7XG4gICAgLy8gZGVmaW5lcyB1c2Ugc3RhdGVtZW50c1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKFwidHJhaXR1c2VcIik7XG4gICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9VU0UpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciB0cmFpdHMgPSBbdGhpcy5yZWFkX25hbWVzcGFjZV9uYW1lKCldO1xuICAgIHZhciBhZGFwdGF0aW9ucyA9IG51bGw7XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiA9PT0gXCIsXCIpIHtcbiAgICAgIHRyYWl0cy5wdXNoKHRoaXMubmV4dCgpLnJlYWRfbmFtZXNwYWNlX25hbWUoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwie1wiKSB7XG4gICAgICBhZGFwdGF0aW9ucyA9IFtdOyAvLyBkZWZpbmVzIGFsaWFzIHN0YXRlbWVudHNcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnRva2VuICE9PSB0aGlzLkVPRikge1xuICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gXCJ9XCIpIGJyZWFrO1xuICAgICAgICBhZGFwdGF0aW9ucy5wdXNoKHRoaXMucmVhZF90cmFpdF91c2VfYWxpYXMoKSk7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwiO1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwifVwiKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiO1wiKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZSh0cmFpdHMsIGFkYXB0YXRpb25zKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZGluZyB0cmFpdCBhbGlhc1xuICAgKiBgYGBlYm5mXG4gICAqIHRyYWl0X3VzZV9hbGlhcyA6Oj0gbmFtZXNwYWNlX25hbWUgKCBUX0RPVUJMRV9DT0xPTiBUX1NUUklORyApPyAoVF9JTlNURUFET0YgbmFtZXNwYWNlX25hbWUpIHwgKFRfQVMgbWVtYmVyX2ZsYWdzPyBUX1NUUklORylcbiAgICogYGBgXG4gICAqIG5hbWUgbGlzdCA6IGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDMwM1xuICAgKiB0cmFpdCBhZGFwdGF0aW9uIDogaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMNzQyXG4gICAqL1xuICByZWFkX3RyYWl0X3VzZV9hbGlhczogZnVuY3Rpb24gcmVhZF90cmFpdF91c2VfYWxpYXMoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICB2YXIgdHJhaXQgPSBudWxsO1xuICAgIHZhciBtZXRob2Q7XG5cbiAgICBpZiAodGhpcy5pcyhcIklERU5USUZJRVJcIikpIHtcbiAgICAgIG1ldGhvZCA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7XG4gICAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBtZXRob2QgPSBtZXRob2QobWV0aG9kTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1ldGhvZCA9IHRoaXMucmVhZF9uYW1lc3BhY2VfbmFtZSgpO1xuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9ET1VCTEVfQ09MT04pIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RSSU5HIHx8IHRoaXMudmVyc2lvbiA+PSA3MDAgJiYgdGhpcy5pcyhcIklERU5USUZJRVJcIikpIHtcbiAgICAgICAgICB0cmFpdCA9IG1ldGhvZDtcbiAgICAgICAgICBtZXRob2QgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuXG4gICAgICAgICAgdmFyIF9tZXRob2ROYW1lID0gdGhpcy50ZXh0KCk7XG5cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBtZXRob2QgPSBtZXRob2QoX21ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfU1RSSU5HKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udmVydCBpZGVudGlmaWVyIGFzIHN0cmluZ1xuICAgICAgICBtZXRob2QgPSBtZXRob2QubmFtZTtcbiAgICAgIH1cbiAgICB9IC8vIGhhbmRsZSB0cmFpdCBwcmVjZWRlbmNlXG5cblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0lOU1RFQURPRikge1xuICAgICAgcmV0dXJuIG5vZGUoXCJ0cmFpdHByZWNlZGVuY2VcIiwgdHJhaXQsIG1ldGhvZCwgdGhpcy5uZXh0KCkucmVhZF9uYW1lX2xpc3QoKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0FTKSB7XG4gICAgICAvLyBoYW5kbGUgdHJhaXQgYWxpYXNcbiAgICAgIHZhciBmbGFncyA9IG51bGw7XG4gICAgICB2YXIgYWxpYXMgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5uZXh0KCkuaXMoXCJUX01FTUJFUl9GTEFHU1wiKSkge1xuICAgICAgICBmbGFncyA9IHRoaXMucmVhZF9tZW1iZXJfZmxhZ3MoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RSSU5HIHx8IHRoaXMudmVyc2lvbiA+PSA3MDAgJiYgdGhpcy5pcyhcIklERU5USUZJRVJcIikpIHtcbiAgICAgICAgYWxpYXMgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgYWxpYXMgPSBhbGlhcyhuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIG5vIHZpc2liaWxpdHkgZmxhZ3MgYW5kIG5vIG5hbWUgPT4gdG9vIGJhZFxuICAgICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1NUUklORyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlKFwidHJhaXRhbGlhc1wiLCB0cmFpdCwgbWV0aG9kLCBhbGlhcywgZmxhZ3MpO1xuICAgIH0gLy8gaGFuZGxlIGVycm9yc1xuXG5cbiAgICB0aGlzLmV4cGVjdChbdGhpcy50b2suVF9BUywgdGhpcy50b2suVF9JTlNURUFET0ZdKTtcbiAgICByZXR1cm4gbm9kZShcInRyYWl0YWxpYXNcIiwgdHJhaXQsIG1ldGhvZCwgbnVsbCwgbnVsbCk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqICBDb21tZW50cyB3aXRoIC8vIG9yICMgb3IgLyAqIC4uLiAqIC9cbiAgICovXG4gIHJlYWRfY29tbWVudDogZnVuY3Rpb24gcmVhZF9jb21tZW50KCkge1xuICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0KCk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuYXN0LnByZXBhcmUodGV4dC5zdWJzdHJpbmcoMCwgMikgPT09IFwiLypcIiA/IFwiY29tbWVudGJsb2NrXCIgOiBcImNvbW1lbnRsaW5lXCIsIG51bGwsIHRoaXMpO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9vZmZzZXQ7IC8vIGhhbmRsZSBsb2NhdGlvbiBvbiBjb21tZW50XG5cbiAgICB2YXIgcHJldiA9IHRoaXMucHJldjtcbiAgICB0aGlzLnByZXYgPSBbdGhpcy5sZXhlci55eWxsb2MubGFzdF9saW5lLCB0aGlzLmxleGVyLnl5bGxvYy5sYXN0X2NvbHVtbiwgdGhpcy5sZXhlci5vZmZzZXRdO1xuICAgIHRoaXMubGV4KCk7XG4gICAgcmVzdWx0ID0gcmVzdWx0KHRleHQpO1xuICAgIHJlc3VsdC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5wcmV2ID0gcHJldjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb21tZW50cyB3aXRoIC8gKiogLi4uICogL1xuICAgKi9cbiAgcmVhZF9kb2NfY29tbWVudDogZnVuY3Rpb24gcmVhZF9kb2NfY29tbWVudCgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5hc3QucHJlcGFyZShcImNvbW1lbnRibG9ja1wiLCBudWxsLCB0aGlzKTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5sZXhlci55eWxsb2MuZmlyc3Rfb2Zmc2V0O1xuICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0KCk7XG4gICAgdmFyIHByZXYgPSB0aGlzLnByZXY7XG4gICAgdGhpcy5wcmV2ID0gW3RoaXMubGV4ZXIueXlsbG9jLmxhc3RfbGluZSwgdGhpcy5sZXhlci55eWxsb2MubGFzdF9jb2x1bW4sIHRoaXMubGV4ZXIub2Zmc2V0XTtcbiAgICB0aGlzLmxleCgpO1xuICAgIHJlc3VsdCA9IHJlc3VsdCh0ZXh0KTtcbiAgICByZXN1bHQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZWFkX2V4cHI6IGZ1bmN0aW9uIHJlYWRfZXhwcihleHByKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZSgpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiQFwiKSB7XG4gICAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgZXhwciA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0KFwic2lsZW50XCIsIGV4cHIpO1xuICAgIH1cblxuICAgIGlmICghZXhwcikge1xuICAgICAgZXhwciA9IHRoaXMucmVhZF9leHByX2l0ZW0oKTtcbiAgICB9IC8vIGJpbmFyeSBvcGVyYXRpb25zXG5cblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcInxcIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcInxcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIiZcIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIiZcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIl5cIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIl5cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIi5cIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIi5cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIitcIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIitcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIi1cIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIi1cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIipcIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIipcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIi9cIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIi9cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIiVcIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIiVcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1BPVykgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIioqXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9TTCkgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIjw8XCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9TUikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIj4+XCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTsgLy8gbW9yZSBiaW5hcnkgb3BlcmF0aW9ucyAoZm9ybWVybHkgYm9vbClcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0JPT0xFQU5fT1IpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCJ8fFwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTE9HSUNBTF9PUikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIm9yXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9CT09MRUFOX0FORCkgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIiYmXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9MT0dJQ0FMX0FORCkgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcImFuZFwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTE9HSUNBTF9YT1IpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCJ4b3JcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0lTX0lERU5USUNBTCkgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIj09PVwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfSVNfTk9UX0lERU5USUNBTCkgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIiE9PVwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfSVNfRVFVQUwpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI9PVwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfSVNfTk9UX0VRVUFMKSByZXR1cm4gcmVzdWx0KFwiYmluXCIsIFwiIT1cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIjxcIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIjxcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIj5cIikgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIj5cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0lTX1NNQUxMRVJfT1JfRVFVQUwpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI8PVwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfSVNfR1JFQVRFUl9PUl9FUVVBTCkgcmV0dXJuIHJlc3VsdChcImJpblwiLCBcIj49XCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9TUEFDRVNISVApIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI8PT5cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfSU5TVEFOQ0VPRikge1xuICAgICAgZXhwciA9IHJlc3VsdChcImJpblwiLCBcImluc3RhbmNlb2ZcIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9jbGFzc19uYW1lX3JlZmVyZW5jZSgpKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gIT09IFwiO1wiICYmIHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfSU5MSU5FX0hUTUwgJiYgdGhpcy50b2tlbiAhPT0gdGhpcy5FT0YpIHtcbiAgICAgICAgZXhwciA9IHRoaXMucmVhZF9leHByKGV4cHIpO1xuICAgICAgfVxuICAgIH0gLy8gZXh0cmEgb3BlcmF0aW9ucyA6XG4gICAgLy8gJHVzZXJuYW1lID0gJF9HRVRbJ3VzZXInXSA/PyAnbm9ib2R5JztcblxuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ09BTEVTQ0UpIHJldHVybiByZXN1bHQoXCJiaW5cIiwgXCI/P1wiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7IC8vIGV4dHJhIG9wZXJhdGlvbnMgOlxuICAgIC8vICR1c2VybmFtZSA9ICRfR0VUWyd1c2VyJ10gPyB0cnVlIDogZmFsc2U7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI/XCIpIHtcbiAgICAgIHZhciB0cnVlQXJnID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMubmV4dCgpLnRva2VuICE9PSBcIjpcIikge1xuICAgICAgICB0cnVlQXJnID0gdGhpcy5yZWFkX2V4cHIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5leHBlY3QoXCI6XCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdChcInJldGlmXCIsIGV4cHIsIHRydWVBcmcsIHRoaXMucmVhZF9leHByKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZWUgIzE5M1xuICAgICAgcmVzdWx0LmRlc3Ryb3koZXhwcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgY2FzdCBleHByZXNzaW9uXG4gICAqL1xuICByZWFkX2V4cHJfY2FzdDogZnVuY3Rpb24gcmVhZF9leHByX2Nhc3QodHlwZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGUoXCJjYXN0XCIpKHR5cGUsIHRoaXMudGV4dCgpLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWQgYSBpc3NldCB2YXJpYWJsZVxuICAgKi9cbiAgcmVhZF9pc3NldF92YXJpYWJsZTogZnVuY3Rpb24gcmVhZF9pc3NldF92YXJpYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkX2V4cHIoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgaXNzZXQgdmFyaWFibGVzXG4gICAqL1xuICByZWFkX2lzc2V0X3ZhcmlhYmxlczogZnVuY3Rpb24gcmVhZF9pc3NldF92YXJpYWJsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZF9mdW5jdGlvbl9saXN0KHRoaXMucmVhZF9pc3NldF92YXJpYWJsZSwgXCIsXCIpO1xuICB9LFxuXG4gIC8qXG4gICAqIFJlYWRzIGludGVybmFsIFBIUCBmdW5jdGlvbnNcbiAgICovXG4gIHJlYWRfaW50ZXJuYWxfZnVuY3Rpb25zX2luX3lhY2M6IGZ1bmN0aW9uIHJlYWRfaW50ZXJuYWxfZnVuY3Rpb25zX2luX3lhY2MoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgIGNhc2UgdGhpcy50b2suVF9JU1NFVDpcbiAgICAgICAge1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMubm9kZShcImlzc2V0XCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMubmV4dCgpLmV4cGVjdChcIihcIikpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2YXJpYWJsZXMgPSB0aGlzLnJlYWRfaXNzZXRfdmFyaWFibGVzKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5leHBlY3QoXCIpXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQodmFyaWFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0VNUFRZOlxuICAgICAgICB7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKFwiZW1wdHlcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5uZXh0KCkuZXhwZWN0KFwiKFwiKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnJlYWRfZXhwcigpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiKVwiKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0KGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfSU5DTFVERTpcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKFwiaW5jbHVkZVwiKShmYWxzZSwgZmFsc2UsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9JTkNMVURFX09OQ0U6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMubm9kZShcImluY2x1ZGVcIikodHJ1ZSwgZmFsc2UsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9FVkFMOlxuICAgICAgICB7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKFwiZXZhbFwiKTtcblxuICAgICAgICAgIGlmICh0aGlzLm5leHQoKS5leHBlY3QoXCIoXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZXhwciA9IHRoaXMucmVhZF9leHByKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5leHBlY3QoXCIpXCIpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQoZXhwcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9SRVFVSVJFOlxuICAgICAgICByZXN1bHQgPSB0aGlzLm5vZGUoXCJpbmNsdWRlXCIpKGZhbHNlLCB0cnVlLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfUkVRVUlSRV9PTkNFOlxuICAgICAgICByZXN1bHQgPSB0aGlzLm5vZGUoXCJpbmNsdWRlXCIpKHRydWUsIHRydWUsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgb3B0aW9uYWwgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZF9vcHRpb25hbF9leHByOiBmdW5jdGlvbiByZWFkX29wdGlvbmFsX2V4cHIoc3RvcFRva2VuKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gIT09IHN0b3BUb2tlbikge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZF9leHByKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGV4aXQgZXhwcmVzc2lvblxuICAgKi9cbiAgcmVhZF9leGl0X2V4cHI6IGZ1bmN0aW9uIHJlYWRfZXhpdF9leHByKCkge1xuICAgIHZhciBleHByZXNzaW9uID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIihcIikge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBleHByZXNzaW9uID0gdGhpcy5yZWFkX29wdGlvbmFsX2V4cHIoXCIpXCIpO1xuICAgICAgdGhpcy5leHBlY3QoXCIpXCIpICYmIHRoaXMubmV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgYGBlYm5mXG4gICAqIFJlYWRzIGFuIGV4cHJlc3Npb25cbiAgICogIGV4cHIgOjo9IEB0b2RvXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9leHByX2l0ZW06IGZ1bmN0aW9uIHJlYWRfZXhwcl9pdGVtKCkge1xuICAgIHZhciByZXN1bHQsIGV4cHI7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiK1wiKSByZXR1cm4gdGhpcy5ub2RlKFwidW5hcnlcIikoXCIrXCIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCItXCIpIHJldHVybiB0aGlzLm5vZGUoXCJ1bmFyeVwiKShcIi1cIiwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgIGlmICh0aGlzLnRva2VuID09PSBcIiFcIikgcmV0dXJuIHRoaXMubm9kZShcInVuYXJ5XCIpKFwiIVwiLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSk7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiflwiKSByZXR1cm4gdGhpcy5ub2RlKFwidW5hcnlcIikoXCJ+XCIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIihcIikge1xuICAgICAgZXhwciA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgZXhwci5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IHRydWU7XG4gICAgICB0aGlzLmV4cGVjdChcIilcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVEZXJlZmVyZW5jYWJsZShleHByKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCJgXCIpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDEwNDhcbiAgICAgIHJldHVybiB0aGlzLnJlYWRfZW5jYXBzZWRfc3RyaW5nKFwiYFwiKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9MSVNUKSB7XG4gICAgICB2YXIgYXNzaWduID0gbnVsbDtcbiAgICAgIHZhciBpc0lubmVyID0gdGhpcy5pbm5lckxpc3Q7XG4gICAgICByZXN1bHQgPSB0aGlzLm5vZGUoXCJsaXN0XCIpO1xuXG4gICAgICBpZiAoIWlzSW5uZXIpIHtcbiAgICAgICAgYXNzaWduID0gdGhpcy5ub2RlKFwiYXNzaWduXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5uZXh0KCkuZXhwZWN0KFwiKFwiKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlubmVyTGlzdCkgdGhpcy5pbm5lckxpc3QgPSB0cnVlOyAvLyByZWFkcyBpbm5lciBpdGVtc1xuXG4gICAgICB2YXIgYXNzaWduTGlzdCA9IHRoaXMucmVhZF9hcnJheV9wYWlyX2xpc3QoZmFsc2UpO1xuXG4gICAgICBpZiAodGhpcy5leHBlY3QoXCIpXCIpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfSAvLyBjaGVjayBpZiBjb250YWlucyBhdCBsZWFzdCBvbmUgYXNzaWdubWVudCBzdGF0ZW1lbnRcblxuXG4gICAgICB2YXIgaGFzSXRlbSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzc2lnbkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFzc2lnbkxpc3RbaV0gIT09IG51bGwgJiYgYXNzaWduTGlzdFtpXS5raW5kICE9PSBcIm5vb3BcIikge1xuICAgICAgICAgIGhhc0l0ZW0gPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzSXRlbSkge1xuICAgICAgICB0aGlzLnJhaXNlRXJyb3IoXCJGYXRhbCBFcnJvciA6ICBDYW5ub3QgdXNlIGVtcHR5IGxpc3Qgb24gbGluZSBcIiArIHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X2xpbmUpO1xuICAgICAgfSAvLyBoYW5kbGVzIHRoZSBub2RlIHJlc29sdXRpb25cblxuXG4gICAgICBpZiAoIWlzSW5uZXIpIHtcbiAgICAgICAgdGhpcy5pbm5lckxpc3QgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5leHBlY3QoXCI9XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGFzc2lnbihyZXN1bHQoYXNzaWduTGlzdCwgZmFsc2UpLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgXCI9XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVycm9yIGZhbGxiYWNrIDogbGlzdCgkYSwgJGIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoYXNzaWduTGlzdCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzdWx0KGFzc2lnbkxpc3QsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DTE9ORSkgcmV0dXJuIHRoaXMubm9kZShcImNsb25lXCIpKHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcblxuICAgIHN3aXRjaCAodGhpcy50b2tlbikge1xuICAgICAgY2FzZSB0aGlzLnRvay5UX0lOQzpcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShcInByZVwiKShcIitcIiwgdGhpcy5uZXh0KCkucmVhZF92YXJpYWJsZShmYWxzZSwgZmFsc2UpKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0RFQzpcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShcInByZVwiKShcIi1cIiwgdGhpcy5uZXh0KCkucmVhZF92YXJpYWJsZShmYWxzZSwgZmFsc2UpKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX05FVzpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9uZXdfZXhwcigpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfSVNTRVQ6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfRU1QVFk6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfSU5DTFVERTpcbiAgICAgIGNhc2UgdGhpcy50b2suVF9JTkNMVURFX09OQ0U6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfRVZBTDpcbiAgICAgIGNhc2UgdGhpcy50b2suVF9SRVFVSVJFOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX1JFUVVJUkVfT05DRTpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9pbnRlcm5hbF9mdW5jdGlvbnNfaW5feWFjYygpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfSU5UX0NBU1Q6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfZXhwcl9jYXN0KFwiaW50XCIpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfRE9VQkxFX0NBU1Q6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfZXhwcl9jYXN0KFwiZmxvYXRcIik7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9TVFJJTkdfQ0FTVDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9leHByX2Nhc3QodGhpcy50ZXh0KCkuaW5kZXhPZihcImJpbmFyeVwiKSAhPT0gLTEgPyBcImJpbmFyeVwiIDogXCJzdHJpbmdcIik7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9BUlJBWV9DQVNUOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2V4cHJfY2FzdChcImFycmF5XCIpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfT0JKRUNUX0NBU1Q6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfZXhwcl9jYXN0KFwib2JqZWN0XCIpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfQk9PTF9DQVNUOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2V4cHJfY2FzdChcImJvb2xcIik7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9VTlNFVF9DQVNUOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2V4cHJfY2FzdChcInVuc2V0XCIpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfRVhJVDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB1c2VEaWUgPSB0aGlzLmxleGVyLnl5dGV4dC50b0xvd2VyQ2FzZSgpID09PSBcImRpZVwiO1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMubm9kZShcImV4aXRcIik7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnJlYWRfZXhpdF9leHByKCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChleHByZXNzaW9uLCB1c2VEaWUpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9QUklOVDpcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZShcInByaW50XCIpKHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICAgIC8vIFRfWUlFTEQgKGV4cHIgKFRfRE9VQkxFX0FSUk9XIGV4cHIpPyk/XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9ZSUVMRDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgdmFyIGtleSA9IG51bGw7XG4gICAgICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKFwieWllbGRcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5uZXh0KCkuaXMoXCJFWFBSXCIpKSB7XG4gICAgICAgICAgICAvLyByZWFkcyB0aGUgeWllbGQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmVhZF9leHByKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0RPVUJMRV9BUlJPVykge1xuICAgICAgICAgICAgICAvLyByZWFkcyB0aGUgeWllbGQgcmV0dXJuZWQga2V5XG4gICAgICAgICAgICAgIGtleSA9IHZhbHVlO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQodmFsdWUsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIC8vIFRfWUlFTERfRlJPTSBleHByXG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9ZSUVMRF9GUk9NOlxuICAgICAgICByZXN1bHQgPSB0aGlzLm5vZGUoXCJ5aWVsZGZyb21cIik7XG4gICAgICAgIGV4cHIgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChleHByKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0ZOOlxuICAgICAgY2FzZSB0aGlzLnRvay5UX0ZVTkNUSU9OOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2lubGluZV9mdW5jdGlvbigpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfU1RBVElDOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGJhY2t1cCA9IFt0aGlzLnRva2VuLCB0aGlzLmxleGVyLmdldFN0YXRlKCldO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRlVOQ1RJT04gfHwgdGhpcy52ZXJzaW9uID49IDcwNCAmJiB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0ZOKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGVzIHN0YXRpYyBmdW5jdGlvblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9pbmxpbmVfZnVuY3Rpb24oWzAsIDEsIDBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcm9sbGJhY2tcbiAgICAgICAgICAgIHRoaXMubGV4ZXIudG9rZW5zLnB1c2goYmFja3VwKTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gLy8gU0NBTEFSIHwgVkFSSUFCTEVcblxuXG4gICAgaWYgKHRoaXMuaXMoXCJWQVJJQUJMRVwiKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5ub2RlKCk7XG4gICAgICBleHByID0gdGhpcy5yZWFkX3ZhcmlhYmxlKGZhbHNlLCBmYWxzZSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDg3N1xuICAgICAgLy8gc2hvdWxkIGFjY2VwdCBvbmx5IGEgdmFyaWFibGVcblxuICAgICAgdmFyIGlzQ29uc3QgPSBleHByLmtpbmQgPT09IFwiaWRlbnRpZmllclwiIHx8IGV4cHIua2luZCA9PT0gXCJzdGF0aWNsb29rdXBcIiAmJiBleHByLm9mZnNldC5raW5kID09PSBcImlkZW50aWZpZXJcIjsgLy8gVkFSSUFCTEVTIFNQRUNJRklDIE9QRVJBVElPTlNcblxuICAgICAgc3dpdGNoICh0aGlzLnRva2VuKSB7XG4gICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCgpLnRva2VuID09IFwiJlwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRfYXNzaWducmVmKHJlc3VsdCwgZXhwcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgZXhwciwgdGhpcy5yZWFkX2V4cHIoKSwgXCI9XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgLy8gb3BlcmF0aW9ucyA6XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX1BMVVNfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcIis9XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9NSU5VU19FUVVBTDpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCksIFwiLT1cIik7XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX01VTF9FUVVBTDpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCksIFwiKj1cIik7XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX1BPV19FUVVBTDpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCksIFwiKio9XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9ESVZfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcIi89XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9DT05DQVRfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcIi49XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9NT0RfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcIiU9XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9BTkRfRVFVQUw6XG4gICAgICAgICAgaWYgKGlzQ29uc3QpIHRoaXMuZXJyb3IoXCJWQVJJQUJMRVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KFwiYXNzaWduXCIsIGV4cHIsIHRoaXMubmV4dCgpLnJlYWRfZXhwcigpLCBcIiY9XCIpO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9PUl9FUVVBTDpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCksIFwifD1cIik7XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX1hPUl9FUVVBTDpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJhc3NpZ25cIiwgZXhwciwgdGhpcy5uZXh0KCkucmVhZF9leHByKCksIFwiXj1cIik7XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX1NMX0VRVUFMOlxuICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChcImFzc2lnblwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgXCI8PD1cIik7XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX1NSX0VRVUFMOlxuICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChcImFzc2lnblwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgXCI+Pj1cIik7XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX0NPQUxFU0NFX0VRVUFMOlxuICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChcImFzc2lnblwiLCBleHByLCB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKSwgXCI/Pz1cIik7XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX0lOQzpcbiAgICAgICAgICBpZiAoaXNDb25zdCkgdGhpcy5lcnJvcihcIlZBUklBQkxFXCIpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoXCJwb3N0XCIsIFwiK1wiLCBleHByKTtcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfREVDOlxuICAgICAgICAgIGlmIChpc0NvbnN0KSB0aGlzLmVycm9yKFwiVkFSSUFCTEVcIik7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChcInBvc3RcIiwgXCItXCIsIGV4cHIpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gc2VlICMxOTNcbiAgICAgICAgICByZXN1bHQuZGVzdHJveShleHByKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXMoXCJTQ0FMQVJcIikpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMubm9kZSgpO1xuICAgICAgZXhwciA9IHRoaXMucmVhZF9zY2FsYXIoKTtcblxuICAgICAgaWYgKGV4cHIua2luZCA9PT0gXCJhcnJheVwiICYmIGV4cHIuc2hvcnRGb3JtICYmIHRoaXMudG9rZW4gPT09IFwiPVwiKSB7XG4gICAgICAgIC8vIGxpc3QgYXNzaWduXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5ub2RlKFwibGlzdFwiKShleHByLml0ZW1zLCB0cnVlKTtcbiAgICAgICAgaWYgKGV4cHIubG9jKSBsaXN0LmxvYyA9IGV4cHIubG9jO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChcImFzc2lnblwiLCBsaXN0LCByaWdodCwgXCI9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2VlICMxODkgLSBzd2FwIGRvY3Mgb24gbm9kZXNcbiAgICAgICAgcmVzdWx0LmRlc3Ryb3koZXhwcik7XG4gICAgICB9IC8vIGNsYXNzaWMgYXJyYXlcblxuXG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVEZXJlZmVyZW5jYWJsZShleHByKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lcnJvcihcIkVYUFJcIik7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9IC8vIHJldHVybnMgdmFyaWFibGUgfCBzY2FsYXJcblxuXG4gICAgcmV0dXJuIGV4cHI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGFzc2lnbm1lbnRcbiAgICogQHBhcmFtIHsqfSBsZWZ0XG4gICAqL1xuICByZWFkX2Fzc2lnbnJlZjogZnVuY3Rpb24gcmVhZF9hc3NpZ25yZWYocmVzdWx0LCBsZWZ0KSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdmFyIHJpZ2h0O1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTkVXKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uID49IDcwMCkge1xuICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHJpZ2h0ID0gdGhpcy5yZWFkX25ld19leHByKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0ID0gdGhpcy5yZWFkX3ZhcmlhYmxlKGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdChcImFzc2lnbnJlZlwiLCBsZWZ0LCByaWdodCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqXG4gICAqIGlubGluZV9mdW5jdGlvbjpcbiAgICogXHRcdGZ1bmN0aW9uIHJldHVybnNfcmVmIGJhY2t1cF9kb2NfY29tbWVudCAnKCcgcGFyYW1ldGVyX2xpc3QgJyknIGxleGljYWxfdmFycyByZXR1cm5fdHlwZVxuICAgKiBcdFx0YmFja3VwX2ZuX2ZsYWdzICd7JyBpbm5lcl9zdGF0ZW1lbnRfbGlzdCAnfScgYmFja3VwX2ZuX2ZsYWdzXG4gICAqIFx0XHRcdHsgJCQgPSB6ZW5kX2FzdF9jcmVhdGVfZGVjbChaRU5EX0FTVF9DTE9TVVJFLCAkMiB8ICQxMywgJDEsICQzLFxuICAgKiBcdFx0XHRcdCAgemVuZF9zdHJpbmdfaW5pdChcIntjbG9zdXJlfVwiLCBzaXplb2YoXCJ7Y2xvc3VyZX1cIikgLSAxLCAwKSxcbiAgICogXHRcdFx0XHQgICQ1LCAkNywgJDExLCAkOCk7IENHKGV4dHJhX2ZuX2ZsYWdzKSA9ICQ5OyB9XG4gICAqIFx0fFx0Zm4gcmV0dXJuc19yZWYgJygnIHBhcmFtZXRlcl9saXN0ICcpJyByZXR1cm5fdHlwZSBiYWNrdXBfZG9jX2NvbW1lbnQgVF9ET1VCTEVfQVJST1cgYmFja3VwX2ZuX2ZsYWdzIGJhY2t1cF9sZXhfcG9zIGV4cHIgYmFja3VwX2ZuX2ZsYWdzXG4gICAqIFx0XHRcdHsgJCQgPSB6ZW5kX2FzdF9jcmVhdGVfZGVjbChaRU5EX0FTVF9BUlJPV19GVU5DLCAkMiB8ICQxMiwgJDEsICQ3LFxuICAgKiBcdFx0XHRcdCAgemVuZF9zdHJpbmdfaW5pdChcIntjbG9zdXJlfVwiLCBzaXplb2YoXCJ7Y2xvc3VyZX1cIikgLSAxLCAwKSwgJDQsIE5VTEwsXG4gICAqIFx0XHRcdFx0ICB6ZW5kX2FzdF9jcmVhdGUoWkVORF9BU1RfUkVUVVJOLCAkMTEpLCAkNik7XG4gICAqIFx0XHRcdFx0ICAoKHplbmRfYXN0X2RlY2wgKikgJCQpLT5sZXhfcG9zID0gJDEwO1xuICAgKiBcdFx0XHRcdCAgQ0coZXh0cmFfZm5fZmxhZ3MpID0gJDk7IH0gICAqXG4gICAqL1xuICByZWFkX2lubGluZV9mdW5jdGlvbjogZnVuY3Rpb24gcmVhZF9pbmxpbmVfZnVuY3Rpb24oZmxhZ3MpIHtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9GVU5DVElPTikge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZF9mdW5jdGlvbih0cnVlLCBmbGFncyk7XG4gICAgfSAvLyBpbnRyb2R1Y2VkIGluIFBIUCA3LjRcblxuXG4gICAgaWYgKCF0aGlzLnZlcnNpb24gPj0gNzA0KSB7XG4gICAgICB0aGlzLnJhaXNlRXJyb3IoXCJBcnJvdyBGdW5jdGlvbnMgYXJlIG5vdCBhbGxvd2VkXCIpO1xuICAgIH0gLy8gYXMgYW4gYXJyb3dmdW5jXG5cblxuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKFwiYXJyb3dmdW5jXCIpOyAvLyBlYXQgVF9GTlxuXG4gICAgaWYgKHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfRk4pKSB0aGlzLm5leHQoKTsgLy8gY2hlY2sgdGhlICZcblxuICAgIHZhciBpc1JlZiA9IHRoaXMuaXNfcmVmZXJlbmNlKCk7IC8vIC4uLlxuXG4gICAgaWYgKHRoaXMuZXhwZWN0KFwiKFwiKSkgdGhpcy5uZXh0KCk7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMucmVhZF9wYXJhbWV0ZXJfbGlzdCgpO1xuICAgIGlmICh0aGlzLmV4cGVjdChcIilcIikpIHRoaXMubmV4dCgpO1xuICAgIHZhciBudWxsYWJsZSA9IGZhbHNlO1xuICAgIHZhciByZXR1cm5UeXBlID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIjpcIikge1xuICAgICAgaWYgKHRoaXMubmV4dCgpLnRva2VuID09PSBcIj9cIikge1xuICAgICAgICBudWxsYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm5UeXBlID0gdGhpcy5yZWFkX3R5cGUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3QodGhpcy50b2suVF9ET1VCTEVfQVJST1cpKSB0aGlzLm5leHQoKTtcbiAgICB2YXIgYm9keSA9IHRoaXMucmVhZF9leHByKCk7XG4gICAgcmV0dXJuIG5vZGUocGFyYW1zLCBpc1JlZiwgYm9keSwgcmV0dXJuVHlwZSwgbnVsbGFibGUsIGZsYWdzID8gdHJ1ZSA6IGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogYGBgZWJuZlxuICAgKiAgICBuZXdfZXhwciA6Oj0gVF9ORVcgKG5hbWVzcGFjZV9uYW1lIGZ1bmN0aW9uX2FyZ3VtZW50X2xpc3QpIHwgKFRfQ0xBU1MgLi4uIGNsYXNzIGRlY2xhcmF0aW9uKVxuICAgKiBgYGBcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMODUwXG4gICAqL1xuICByZWFkX25ld19leHByOiBmdW5jdGlvbiByZWFkX25ld19leHByKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJuZXdcIik7XG4gICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9ORVcpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciBhcmdzID0gW107XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DTEFTUykge1xuICAgICAgdmFyIHdoYXQgPSB0aGlzLm5vZGUoXCJjbGFzc1wiKTsgLy8gQW5ub255bW91cyBjbGFzcyBkZWNsYXJhdGlvblxuXG4gICAgICBpZiAodGhpcy5uZXh0KCkudG9rZW4gPT09IFwiKFwiKSB7XG4gICAgICAgIGFyZ3MgPSB0aGlzLnJlYWRfYXJndW1lbnRfbGlzdCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcEV4dGVuZHMgPSB0aGlzLnJlYWRfZXh0ZW5kc19mcm9tKCk7XG4gICAgICB2YXIgcHJvcEltcGxlbWVudHMgPSB0aGlzLnJlYWRfaW1wbGVtZW50c19saXN0KCk7XG4gICAgICB2YXIgYm9keSA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIntcIikpIHtcbiAgICAgICAgYm9keSA9IHRoaXMubmV4dCgpLnJlYWRfY2xhc3NfYm9keSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0KHdoYXQobnVsbCwgcHJvcEV4dGVuZHMsIHByb3BJbXBsZW1lbnRzLCBib2R5LCBbMCwgMCwgMF0pLCBhcmdzKTtcbiAgICB9IC8vIEFscmVhZHkgZXhpc3RpbmcgY2xhc3NcblxuXG4gICAgdmFyIG5hbWUgPSB0aGlzLnJlYWRfbmV3X2NsYXNzX25hbWUoKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIihcIikge1xuICAgICAgYXJncyA9IHRoaXMucmVhZF9hcmd1bWVudF9saXN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdChuYW1lLCBhcmdzKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSBjbGFzcyBuYW1lXG4gICAqIGBgYGVibmZcbiAgICogcmVhZF9uZXdfY2xhc3NfbmFtZSA6Oj0gbmFtZXNwYWNlX25hbWUgfCB2YXJpYWJsZVxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfbmV3X2NsYXNzX25hbWU6IGZ1bmN0aW9uIHJlYWRfbmV3X2NsYXNzX25hbWUoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTlNfU0VQQVJBVE9SIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RSSU5HIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTkFNRVNQQUNFKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZWFkX25hbWVzcGFjZV9uYW1lKHRydWUpO1xuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9ET1VCTEVfQ09MT04pIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZWFkX3N0YXRpY19nZXR0ZXIocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXMoXCJWQVJJQUJMRVwiKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZF92YXJpYWJsZSh0cnVlLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0KFt0aGlzLnRvay5UX1NUUklORywgXCJWQVJJQUJMRVwiXSk7XG4gICAgfVxuICB9LFxuICBoYW5kbGVEZXJlZmVyZW5jYWJsZTogZnVuY3Rpb24gaGFuZGxlRGVyZWZlcmVuY2FibGUoZXhwcikge1xuICAgIHdoaWxlICh0aGlzLnRva2VuICE9PSB0aGlzLkVPRikge1xuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfT0JKRUNUX09QRVJBVE9SIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9VQkxFX0NPTE9OKSB7XG4gICAgICAgIGV4cHIgPSB0aGlzLnJlY3Vyc2l2ZV92YXJpYWJsZV9jaGFpbl9zY2FuKGV4cHIsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ1VSTFlfT1BFTiB8fCB0aGlzLnRva2VuID09PSBcIltcIikge1xuICAgICAgICBleHByID0gdGhpcy5yZWFkX2RlcmVmZXJlbmNhYmxlKGV4cHIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSBcIihcIikge1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMTE4XG4gICAgICAgIGV4cHIgPSB0aGlzLm5vZGUoXCJjYWxsXCIpKGV4cHIsIHRoaXMucmVhZF9hcmd1bWVudF9saXN0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIGNoZWNrcyBpZiBjdXJyZW50IHRva2VuIGlzIGEgcmVmZXJlbmNlIGtleXdvcmRcbiAgICovXG4gIGlzX3JlZmVyZW5jZTogZnVuY3Rpb24gaXNfcmVmZXJlbmNlKCkge1xuICAgIGlmICh0aGlzLnRva2VuID09IFwiJlwiKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogY2hlY2tzIGlmIGN1cnJlbnQgdG9rZW4gaXMgYSB2YXJpYWRpYyBrZXl3b3JkXG4gICAqL1xuICBpc192YXJpYWRpYzogZnVuY3Rpb24gaXNfdmFyaWFkaWMoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRUxMSVBTSVMpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWFkaW5nIGEgZnVuY3Rpb25cbiAgICogYGBgZWJuZlxuICAgKiBmdW5jdGlvbiA6Oj0gZnVuY3Rpb25fZGVjbGFyYXRpb24gY29kZV9ibG9ja1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfZnVuY3Rpb246IGZ1bmN0aW9uIHJlYWRfZnVuY3Rpb24oY2xvc3VyZSwgZmxhZykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlYWRfZnVuY3Rpb25fZGVjbGFyYXRpb24oY2xvc3VyZSA/IDEgOiBmbGFnID8gMiA6IDAsIGZsYWcgJiYgZmxhZ1sxXSA9PT0gMSk7XG5cbiAgICBpZiAoZmxhZyAmJiBmbGFnWzJdID09IDEpIHtcbiAgICAgIC8vIGFic3RyYWN0IGZ1bmN0aW9uIDpcbiAgICAgIHJlc3VsdC5wYXJzZUZsYWdzKGZsYWcpO1xuXG4gICAgICBpZiAodGhpcy5leHBlY3QoXCI7XCIpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5leHBlY3QoXCJ7XCIpKSB7XG4gICAgICAgIHJlc3VsdC5ib2R5ID0gdGhpcy5yZWFkX2NvZGVfYmxvY2soZmFsc2UpO1xuXG4gICAgICAgIGlmIChyZXN1bHQubG9jICYmIHJlc3VsdC5ib2R5LmxvYykge1xuICAgICAgICAgIHJlc3VsdC5sb2MuZW5kID0gcmVzdWx0LmJvZHkubG9jLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWNsb3N1cmUgJiYgZmxhZykge1xuICAgICAgICByZXN1bHQucGFyc2VGbGFncyhmbGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWFkcyBhIGZ1bmN0aW9uIGRlY2xhcmF0aW9uICh3aXRob3V0IGhpcyBib2R5KVxuICAgKiBgYGBlYm5mXG4gICAqIGZ1bmN0aW9uX2RlY2xhcmF0aW9uIDo6PSBUX0ZVTkNUSU9OICcmJz8gIFRfU1RSSU5HICcoJyBwYXJhbWV0ZXJfbGlzdCAnKSdcbiAgICogYGBgXG4gICAqL1xuICByZWFkX2Z1bmN0aW9uX2RlY2xhcmF0aW9uOiBmdW5jdGlvbiByZWFkX2Z1bmN0aW9uX2RlY2xhcmF0aW9uKHR5cGUsIGlzU3RhdGljKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gXCJmdW5jdGlvblwiO1xuXG4gICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgIG5vZGVOYW1lID0gXCJjbG9zdXJlXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAyKSB7XG4gICAgICBub2RlTmFtZSA9IFwibWV0aG9kXCI7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShub2RlTmFtZSk7XG5cbiAgICBpZiAodGhpcy5leHBlY3QodGhpcy50b2suVF9GVU5DVElPTikpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cblxuICAgIHZhciBpc1JlZiA9IHRoaXMuaXNfcmVmZXJlbmNlKCk7XG4gICAgdmFyIG5hbWUgPSBmYWxzZSxcbiAgICAgICAgdXNlID0gW10sXG4gICAgICAgIHJldHVyblR5cGUgPSBudWxsLFxuICAgICAgICBudWxsYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGUgIT09IDEpIHtcbiAgICAgIHZhciBuYW1lTm9kZSA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7XG5cbiAgICAgIGlmICh0eXBlID09PSAyKSB7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24gPj0gNzAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RSSU5HIHx8IHRoaXMuaXMoXCJJREVOVElGSUVSXCIpKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmVyc2lvbiA8IDcwNCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIklERU5USUZJRVJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RSSU5HKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZXJyb3IoXCJJREVOVElGSUVSXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uID49IDcwMCkge1xuICAgICAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklORykge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZlcnNpb24gPj0gNzA0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXhwZWN0KFwiKFwiKSkge1xuICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcih0aGlzLnRvay5UX1NUUklORyk7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfU1RSSU5HKSkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5hbWUgPSBuYW1lTm9kZShuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3QoXCIoXCIpKSB0aGlzLm5leHQoKTtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5yZWFkX3BhcmFtZXRlcl9saXN0KCk7XG4gICAgaWYgKHRoaXMuZXhwZWN0KFwiKVwiKSkgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgdXNlID0gdGhpcy5yZWFkX2xleGljYWxfdmFycygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIjpcIikge1xuICAgICAgaWYgKHRoaXMubmV4dCgpLnRva2VuID09PSBcIj9cIikge1xuICAgICAgICBudWxsYWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm5UeXBlID0gdGhpcy5yZWFkX3R5cGUoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgLy8gY2xvc3VyZVxuICAgICAgcmV0dXJuIHJlc3VsdChwYXJhbXMsIGlzUmVmLCB1c2UsIHJldHVyblR5cGUsIG51bGxhYmxlLCBpc1N0YXRpYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdChuYW1lLCBwYXJhbXMsIGlzUmVmLCByZXR1cm5UeXBlLCBudWxsYWJsZSk7XG4gIH0sXG4gIHJlYWRfbGV4aWNhbF92YXJzOiBmdW5jdGlvbiByZWFkX2xleGljYWxfdmFycygpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9VU0UpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3QoXCIoXCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgcmVzdWx0ID0gdGhpcy5yZWFkX2xleGljYWxfdmFyX2xpc3QoKTtcbiAgICAgIHRoaXMuZXhwZWN0KFwiKVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICByZWFkX2xleGljYWxfdmFyX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfbGV4aWNhbF92YXJfbGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkX2xpc3QodGhpcy5yZWFkX2xleGljYWxfdmFyLCBcIixcIik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogbGV4aWNhbF92YXIgOjo9ICcmJz8gVF9WQVJJQUJMRVxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfbGV4aWNhbF92YXI6IGZ1bmN0aW9uIHJlYWRfbGV4aWNhbF92YXIoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiJlwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkX2J5cmVmKHRoaXMucmVhZF9sZXhpY2FsX3Zhci5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwidmFyaWFibGVcIik7XG4gICAgdGhpcy5leHBlY3QodGhpcy50b2suVF9WQVJJQUJMRSk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKS5zdWJzdHJpbmcoMSk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHJlc3VsdChuYW1lLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlYWRzIGEgbGlzdCBvZiBwYXJhbWV0ZXJzXG4gICAqIGBgYGVibmZcbiAgICogIHBhcmFtZXRlcl9saXN0IDo6PSAocGFyYW1ldGVyICcsJykqIHBhcmFtZXRlcj9cbiAgICogYGBgXG4gICAqL1xuICByZWFkX3BhcmFtZXRlcl9saXN0OiBmdW5jdGlvbiByZWFkX3BhcmFtZXRlcl9saXN0KCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGlmICh0aGlzLnRva2VuICE9IFwiKVwiKSB7XG4gICAgICB3aGlsZSAodGhpcy50b2tlbiAhPSB0aGlzLkVPRikge1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLnJlYWRfcGFyYW1ldGVyKCkpO1xuXG4gICAgICAgIGlmICh0aGlzLnRva2VuID09IFwiLFwiKSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PSBcIilcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZXJyb3IoW1wiLFwiLCBcIilcIl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogYGBgZWJuZlxuICAgKiAgcGFyYW1ldGVyIDo6PSB0eXBlPyAnJic/IFRfRUxMSVBTSVM/IFRfVkFSSUFCTEUgKCc9JyBleHByKT9cbiAgICogYGBgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvNDkzNTI0NDU0ZDY2YWRkZTg0ZTAwZDI0OWQ2MDdlY2Q1NDBkZTk5Zi9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDY0MFxuICAgKi9cbiAgcmVhZF9wYXJhbWV0ZXI6IGZ1bmN0aW9uIHJlYWRfcGFyYW1ldGVyKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKFwicGFyYW1ldGVyXCIpO1xuICAgIHZhciBwYXJhbWV0ZXJOYW1lID0gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgIHZhciB0eXBlID0gbnVsbDtcbiAgICB2YXIgbnVsbGFibGUgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIj9cIikge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBudWxsYWJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdHlwZSA9IHRoaXMucmVhZF90eXBlKCk7XG5cbiAgICBpZiAobnVsbGFibGUgJiYgIXR5cGUpIHtcbiAgICAgIHRoaXMucmFpc2VFcnJvcihcIkV4cGVjdGluZyBhIHR5cGUgZGVmaW5pdGlvbiBjb21iaW5lZCB3aXRoIG51bGxhYmxlIG9wZXJhdG9yXCIpO1xuICAgIH1cblxuICAgIHZhciBpc1JlZiA9IHRoaXMuaXNfcmVmZXJlbmNlKCk7XG4gICAgdmFyIGlzVmFyaWFkaWMgPSB0aGlzLmlzX3ZhcmlhZGljKCk7XG5cbiAgICBpZiAodGhpcy5leHBlY3QodGhpcy50b2suVF9WQVJJQUJMRSkpIHtcbiAgICAgIHBhcmFtZXRlck5hbWUgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKS5zdWJzdHJpbmcoMSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHBhcmFtZXRlck5hbWUgPSBwYXJhbWV0ZXJOYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuID09IFwiPVwiKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlKHBhcmFtZXRlck5hbWUsIHR5cGUsIHZhbHVlLCBpc1JlZiwgaXNWYXJpYWRpYywgbnVsbGFibGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIGxpc3Qgb2YgYXJndW1lbnRzXG4gICAqIGBgYGVibmZcbiAgICogIGZ1bmN0aW9uX2FyZ3VtZW50X2xpc3QgOjo9ICcoJyAoYXJndW1lbnRfbGlzdCAoJywnIGFyZ3VtZW50X2xpc3QpKik/ICcpJ1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfYXJndW1lbnRfbGlzdDogZnVuY3Rpb24gcmVhZF9hcmd1bWVudF9saXN0KCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB0aGlzLmV4cGVjdChcIihcIikgJiYgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy50b2tlbiAhPT0gXCIpXCIpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucmVhZF9ub25fZW1wdHlfYXJndW1lbnRfbGlzdCgpO1xuICAgIH1cblxuICAgIHRoaXMuZXhwZWN0KFwiKVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBub24gZW1wdHkgYXJndW1lbnQgbGlzdFxuICAgKi9cbiAgcmVhZF9ub25fZW1wdHlfYXJndW1lbnRfbGlzdDogZnVuY3Rpb24gcmVhZF9ub25fZW1wdHlfYXJndW1lbnRfbGlzdCgpIHtcbiAgICB2YXIgd2FzVmFyaWFkaWMgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5yZWFkX2Z1bmN0aW9uX2xpc3QoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3VtZW50ID0gdGhpcy5yZWFkX2FyZ3VtZW50KCk7XG5cbiAgICAgIGlmIChhcmd1bWVudCkge1xuICAgICAgICBpZiAod2FzVmFyaWFkaWMpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50IGFmdGVyIGEgdmFyaWFkaWMgYXJndW1lbnRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJndW1lbnQua2luZCA9PT0gXCJ2YXJpYWRpY1wiKSB7XG4gICAgICAgICAgd2FzVmFyaWFkaWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcmd1bWVudDtcbiAgICB9LmJpbmQodGhpcyksIFwiLFwiKTtcbiAgfSxcblxuICAvKipcbiAgICogYGBgZWJuZlxuICAgKiAgICBhcmd1bWVudF9saXN0IDo6PSBUX0VMTElQU0lTPyBleHByXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9hcmd1bWVudDogZnVuY3Rpb24gcmVhZF9hcmd1bWVudCgpIHtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9FTExJUFNJUykge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZShcInZhcmlhZGljXCIpKHRoaXMubmV4dCgpLnJlYWRfZXhwcigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWFkX2V4cHIoKTtcbiAgfSxcblxuICAvKipcbiAgICogcmVhZCB0eXBlIGhpbnRpbmdcbiAgICogYGBgZWJuZlxuICAgKiAgdHlwZSA6Oj0gVF9BUlJBWSB8IFRfQ0FMTEFCTEUgfCBuYW1lc3BhY2VfbmFtZVxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfdHlwZTogZnVuY3Rpb24gcmVhZF90eXBlKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0FSUkFZIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ0FMTEFCTEUpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50ZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiByZXN1bHQoXCJ0eXBlcmVmZXJlbmNlXCIsIHR5cGUudG9Mb3dlckNhc2UoKSwgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklORykge1xuICAgICAgdmFyIF90eXBlID0gdGhpcy50ZXh0KCk7XG5cbiAgICAgIHZhciBiYWNrdXAgPSBbdGhpcy50b2tlbiwgdGhpcy5sZXhlci5nZXRTdGF0ZSgpXTtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICBpZiAodGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9OU19TRVBBUkFUT1IgJiYgdGhpcy5hc3QudHlwZXJlZmVyZW5jZS50eXBlcy5pbmRleE9mKF90eXBlLnRvTG93ZXJDYXNlKCkpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdChcInR5cGVyZWZlcmVuY2VcIiwgX3R5cGUudG9Mb3dlckNhc2UoKSwgX3R5cGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcm9sbGJhY2sgYSBjbGFzc2ljIG5hbWVzcGFjZVxuICAgICAgICB0aGlzLmxleGVyLnRva2Vucy5wdXNoKGJhY2t1cCk7XG4gICAgICAgIHRoaXMubmV4dCgpOyAvLyBmaXggOiBkZXN0cm95IG5vdCBjb25zdW1lZCBub2RlIChyZWxlYXNlIGNvbW1lbnRzKVxuXG4gICAgICAgIHJlc3VsdC5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfbmFtZXNwYWNlX25hbWUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTkFNRVNQQUNFIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTlNfU0VQQVJBVE9SKSB7XG4gICAgICAvLyBmaXggOiBkZXN0cm95IG5vdCBjb25zdW1lZCBub2RlIChyZWxlYXNlIGNvbW1lbnRzKVxuICAgICAgcmVzdWx0LmRlc3Ryb3koKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRfbmFtZXNwYWNlX25hbWUoKTtcbiAgICB9IC8vIGZpeCA6IGRlc3Ryb3kgbm90IGNvbnN1bWVkIG5vZGUgKHJlbGVhc2UgY29tbWVudHMpXG5cblxuICAgIHJlc3VsdC5kZXN0cm95KCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIFJlYWRzIGFuIElGIHN0YXRlbWVudFxuICAgKlxuICAgKiBgYGBlYm5mXG4gICAqICBpZiA6Oj0gVF9JRiAnKCcgZXhwciAnKScgJzonIC4uLlxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfaWY6IGZ1bmN0aW9uIHJlYWRfaWYoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImlmXCIpO1xuICAgIHZhciB0ZXN0ID0gdGhpcy5uZXh0KCkucmVhZF9pZl9leHByKCk7XG4gICAgdmFyIGJvZHkgPSBudWxsO1xuICAgIHZhciBhbHRlcm5hdGUgPSBudWxsO1xuICAgIHZhciBzaG9ydEZvcm0gPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIjpcIikge1xuICAgICAgc2hvcnRGb3JtID0gdHJ1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgYm9keSA9IHRoaXMubm9kZShcImJsb2NrXCIpO1xuICAgICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICAgIHdoaWxlICh0aGlzLnRva2VuICE9PSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX0VORElGKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VMU0VJRikge1xuICAgICAgICAgIGFsdGVybmF0ZSA9IHRoaXMucmVhZF9lbHNlaWZfc2hvcnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VMU0UpIHtcbiAgICAgICAgICBhbHRlcm5hdGUgPSB0aGlzLnJlYWRfZWxzZV9zaG9ydCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbXMucHVzaCh0aGlzLnJlYWRfaW5uZXJfc3RhdGVtZW50KCkpO1xuICAgICAgfVxuXG4gICAgICBib2R5ID0gYm9keShudWxsLCBpdGVtcyk7XG4gICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0VORElGKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IHRoaXMucmVhZF9zdGF0ZW1lbnQoKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRUxTRUlGKSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IHRoaXMucmVhZF9pZigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VMU0UpIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdGhpcy5uZXh0KCkucmVhZF9zdGF0ZW1lbnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0KHRlc3QsIGJvZHksIGFsdGVybmF0ZSwgc2hvcnRGb3JtKTtcbiAgfSxcblxuICAvKipcbiAgICogcmVhZHMgYW4gaWYgZXhwcmVzc2lvbiA6ICcoJyBleHByICcpJ1xuICAgKi9cbiAgcmVhZF9pZl9leHByOiBmdW5jdGlvbiByZWFkX2lmX2V4cHIoKSB7XG4gICAgdGhpcy5leHBlY3QoXCIoXCIpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnJlYWRfZXhwcigpO1xuICAgIHRoaXMuZXhwZWN0KFwiKVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWFkcyBhbiBlbHNlaWYgKGV4cHIpOiBzdGF0ZW1lbnRzXG4gICAqL1xuICByZWFkX2Vsc2VpZl9zaG9ydDogZnVuY3Rpb24gcmVhZF9lbHNlaWZfc2hvcnQoKSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IG51bGw7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImlmXCIpO1xuICAgIHZhciB0ZXN0ID0gdGhpcy5uZXh0KCkucmVhZF9pZl9leHByKCk7XG4gICAgaWYgKHRoaXMuZXhwZWN0KFwiOlwiKSkgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGJvZHkgPSB0aGlzLm5vZGUoXCJibG9ja1wiKTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcblxuICAgIHdoaWxlICh0aGlzLnRva2VuICE9IHRoaXMuRU9GICYmIHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfRU5ESUYpIHtcbiAgICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VMU0VJRikge1xuICAgICAgICBhbHRlcm5hdGUgPSB0aGlzLnJlYWRfZWxzZWlmX3Nob3J0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0VMU0UpIHtcbiAgICAgICAgYWx0ZXJuYXRlID0gdGhpcy5yZWFkX2Vsc2Vfc2hvcnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2godGhpcy5yZWFkX2lubmVyX3N0YXRlbWVudCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0KHRlc3QsIGJvZHkobnVsbCwgaXRlbXMpLCBhbHRlcm5hdGUsIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgcmVhZF9lbHNlX3Nob3J0OiBmdW5jdGlvbiByZWFkX2Vsc2Vfc2hvcnQoKSB7XG4gICAgaWYgKHRoaXMubmV4dCgpLmV4cGVjdChcIjpcIikpIHRoaXMubmV4dCgpO1xuICAgIHZhciBib2R5ID0gdGhpcy5ub2RlKFwiYmxvY2tcIik7XG4gICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX0VORElGKSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMucmVhZF9pbm5lcl9zdGF0ZW1lbnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvZHkobnVsbCwgaXRlbXMpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBSZWFkcyBhIHdoaWxlIHN0YXRlbWVudFxuICAgKiBgYGBlYm5mXG4gICAqIHdoaWxlIDo6PSBUX1dISUxFIChzdGF0ZW1lbnQgfCAnOicgaW5uZXJfc3RhdGVtZW50X2xpc3QgVF9FTkRXSElMRSAnOycpXG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDU4N1xuICAgKiBAcmV0dXJuIHtXaGlsZX1cbiAgICovXG4gIHJlYWRfd2hpbGU6IGZ1bmN0aW9uIHJlYWRfd2hpbGUoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcIndoaWxlXCIpO1xuICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfV0hJTEUpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciB0ZXN0ID0gbnVsbDtcbiAgICB2YXIgYm9keSA9IG51bGw7XG4gICAgdmFyIHNob3J0Rm9ybSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmV4cGVjdChcIihcIikpIHRoaXMubmV4dCgpO1xuICAgIHRlc3QgPSB0aGlzLnJlYWRfZXhwcigpO1xuICAgIGlmICh0aGlzLmV4cGVjdChcIilcIikpIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiOlwiKSB7XG4gICAgICBzaG9ydEZvcm0gPSB0cnVlO1xuICAgICAgYm9keSA9IHRoaXMucmVhZF9zaG9ydF9mb3JtKHRoaXMudG9rLlRfRU5EV0hJTEUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gdGhpcy5yZWFkX3N0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQodGVzdCwgYm9keSwgc2hvcnRGb3JtKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSBkbyAvIHdoaWxlIGxvb3BcbiAgICogYGBgZWJuZlxuICAgKiBkbyA6Oj0gVF9ETyBzdGF0ZW1lbnQgVF9XSElMRSAnKCcgZXhwciAnKScgJzsnXG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDQyM1xuICAgKiBAcmV0dXJuIHtEb31cbiAgICovXG4gIHJlYWRfZG86IGZ1bmN0aW9uIHJlYWRfZG8oKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImRvXCIpO1xuICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfRE8pICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciB0ZXN0ID0gbnVsbDtcbiAgICB2YXIgYm9keSA9IG51bGw7XG4gICAgYm9keSA9IHRoaXMucmVhZF9zdGF0ZW1lbnQoKTtcblxuICAgIGlmICh0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1dISUxFKSkge1xuICAgICAgaWYgKHRoaXMubmV4dCgpLmV4cGVjdChcIihcIikpIHRoaXMubmV4dCgpO1xuICAgICAgdGVzdCA9IHRoaXMucmVhZF9leHByKCk7XG4gICAgICBpZiAodGhpcy5leHBlY3QoXCIpXCIpKSB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIjtcIikpIHRoaXMubmV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQodGVzdCwgYm9keSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWQgYSBmb3IgaW5jcmVtZW50YWwgbG9vcFxuICAgKiBgYGBlYm5mXG4gICAqIGZvciA6Oj0gVF9GT1IgJygnIGZvcl9leHBycyAnOycgZm9yX2V4cHJzICc7JyBmb3JfZXhwcnMgJyknIGZvcl9zdGF0ZW1lbnRcbiAgICogZm9yX3N0YXRlbWVudCA6Oj0gc3RhdGVtZW50IHwgJzonIGlubmVyX3N0YXRlbWVudF9saXN0IFRfRU5ERk9SICc7J1xuICAgKiBmb3JfZXhwcnMgOjo9IGV4cHI/ICgnLCcgZXhwcikqXG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDQyNVxuICAgKiBAcmV0dXJuIHtGb3J9XG4gICAqL1xuICByZWFkX2ZvcjogZnVuY3Rpb24gcmVhZF9mb3IoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImZvclwiKTtcbiAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0ZPUikgJiYgdGhpcy5uZXh0KCk7XG4gICAgdmFyIGluaXQgPSBbXTtcbiAgICB2YXIgdGVzdCA9IFtdO1xuICAgIHZhciBpbmNyZW1lbnQgPSBbXTtcbiAgICB2YXIgYm9keSA9IG51bGw7XG4gICAgdmFyIHNob3J0Rm9ybSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmV4cGVjdChcIihcIikpIHRoaXMubmV4dCgpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gIT09IFwiO1wiKSB7XG4gICAgICBpbml0ID0gdGhpcy5yZWFkX2xpc3QodGhpcy5yZWFkX2V4cHIsIFwiLFwiKTtcbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIjtcIikpIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiAhPT0gXCI7XCIpIHtcbiAgICAgIHRlc3QgPSB0aGlzLnJlYWRfbGlzdCh0aGlzLnJlYWRfZXhwciwgXCIsXCIpO1xuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiO1wiKSkgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuICE9PSBcIilcIikge1xuICAgICAgaW5jcmVtZW50ID0gdGhpcy5yZWFkX2xpc3QodGhpcy5yZWFkX2V4cHIsIFwiLFwiKTtcbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIilcIikpIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI6XCIpIHtcbiAgICAgIHNob3J0Rm9ybSA9IHRydWU7XG4gICAgICBib2R5ID0gdGhpcy5yZWFkX3Nob3J0X2Zvcm0odGhpcy50b2suVF9FTkRGT1IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gdGhpcy5yZWFkX3N0YXRlbWVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQoaW5pdCwgdGVzdCwgaW5jcmVtZW50LCBib2R5LCBzaG9ydEZvcm0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIGZvcmVhY2ggbG9vcFxuICAgKiBgYGBlYm5mXG4gICAqIGZvcmVhY2ggOjo9ICcoJyBleHByIFRfQVMgZm9yZWFjaF92YXJpYWJsZSAoVF9ET1VCTEVfQVJST1cgZm9yZWFjaF92YXJpYWJsZSk/ICcpJyBzdGF0ZW1lbnRcbiAgICogYGBgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMNDM4XG4gICAqIEByZXR1cm4ge0ZvcmVhY2h9XG4gICAqL1xuICByZWFkX2ZvcmVhY2g6IGZ1bmN0aW9uIHJlYWRfZm9yZWFjaCgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwiZm9yZWFjaFwiKTtcbiAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0ZPUkVBQ0gpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciBzb3VyY2UgPSBudWxsO1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgdmFyIGJvZHkgPSBudWxsO1xuICAgIHZhciBzaG9ydEZvcm0gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5leHBlY3QoXCIoXCIpKSB0aGlzLm5leHQoKTtcbiAgICBzb3VyY2UgPSB0aGlzLnJlYWRfZXhwcigpO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfQVMpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHZhbHVlID0gdGhpcy5yZWFkX2ZvcmVhY2hfdmFyaWFibGUoKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9VQkxFX0FSUk9XKSB7XG4gICAgICAgIGtleSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHRoaXMubmV4dCgpLnJlYWRfZm9yZWFjaF92YXJpYWJsZSgpO1xuICAgICAgfVxuICAgIH0gLy8gZ3JhbW1hdGljYWxseSBjb3JyZWN0IGJ1dCBub3Qgc3VwcG9ydGVkIGJ5IFBIUFxuXG5cbiAgICBpZiAoa2V5ICYmIGtleS5raW5kID09PSBcImxpc3RcIikge1xuICAgICAgdGhpcy5yYWlzZUVycm9yKFwiRmF0YWwgRXJyb3IgOiBDYW5ub3QgdXNlIGxpc3QgYXMga2V5IGVsZW1lbnRcIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwZWN0KFwiKVwiKSkgdGhpcy5uZXh0KCk7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCI6XCIpIHtcbiAgICAgIHNob3J0Rm9ybSA9IHRydWU7XG4gICAgICBib2R5ID0gdGhpcy5yZWFkX3Nob3J0X2Zvcm0odGhpcy50b2suVF9FTkRGT1JFQUNIKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keSA9IHRoaXMucmVhZF9zdGF0ZW1lbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0KHNvdXJjZSwga2V5LCB2YWx1ZSwgYm9keSwgc2hvcnRGb3JtKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSBmb3JlYWNoIHZhcmlhYmxlIHN0YXRlbWVudFxuICAgKiBgYGBlYm5mXG4gICAqIGZvcmVhY2hfdmFyaWFibGUgPVxuICAgKiAgICB2YXJpYWJsZSB8XG4gICAqICAgICcmJyB2YXJpYWJsZSB8XG4gICAqICAgIFRfTElTVCAnKCcgYXNzaWdubWVudF9saXN0ICcpJyB8XG4gICAqICAgICdbJyBhc3NpZ25tZW50X2xpc3QgJ10nXG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDU0NFxuICAgKiBAcmV0dXJuIHtFeHByZXNzaW9ufVxuICAgKi9cbiAgcmVhZF9mb3JlYWNoX3ZhcmlhYmxlOiBmdW5jdGlvbiByZWFkX2ZvcmVhY2hfdmFyaWFibGUoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTElTVCB8fCB0aGlzLnRva2VuID09PSBcIltcIikge1xuICAgICAgdmFyIGlzU2hvcnQgPSB0aGlzLnRva2VuID09PSBcIltcIjtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJsaXN0XCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoIWlzU2hvcnQgJiYgdGhpcy5leHBlY3QoXCIoXCIpKSB0aGlzLm5leHQoKTtcbiAgICAgIHZhciBhc3NpZ25MaXN0ID0gdGhpcy5yZWFkX2FycmF5X3BhaXJfbGlzdChpc1Nob3J0KTtcbiAgICAgIGlmICh0aGlzLmV4cGVjdChpc1Nob3J0ID8gXCJdXCIgOiBcIilcIikpIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdChhc3NpZ25MaXN0LCBpc1Nob3J0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZF92YXJpYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogYGBgZWJuZlxuICAgKiBzdGFydCA6Oj0gKG5hbWVzcGFjZSB8IHRvcF9zdGF0ZW1lbnQpKlxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfc3RhcnQ6IGZ1bmN0aW9uIHJlYWRfc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT0gdGhpcy50b2suVF9OQU1FU1BBQ0UpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRfbmFtZXNwYWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlYWRfdG9wX3N0YXRlbWVudCgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVhZHMgYSBuYW1lc3BhY2UgZGVjbGFyYXRpb24gYmxvY2tcbiAgICogYGBgZWJuZlxuICAgKiBuYW1lc3BhY2UgOjo9IFRfTkFNRVNQQUNFIG5hbWVzcGFjZV9uYW1lPyAneydcbiAgICogICAgdG9wX3N0YXRlbWVudHNcbiAgICogJ30nXG4gICAqIHwgVF9OQU1FU1BBQ0UgbmFtZXNwYWNlX25hbWUgJzsnIHRvcF9zdGF0ZW1lbnRzXG4gICAqIGBgYFxuICAgKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9sYW5ndWFnZS5uYW1lc3BhY2VzLnBocFxuICAgKiBAcmV0dXJuIHtOYW1lc3BhY2V9XG4gICAqL1xuICByZWFkX25hbWVzcGFjZTogZnVuY3Rpb24gcmVhZF9uYW1lc3BhY2UoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcIm5hbWVzcGFjZVwiKTtcbiAgICB2YXIgYm9keTtcbiAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX05BTUVTUEFDRSkgJiYgdGhpcy5uZXh0KCk7XG4gICAgdmFyIG5hbWU7XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PSBcIntcIikge1xuICAgICAgbmFtZSA9IHtcbiAgICAgICAgbmFtZTogW1wiXCJdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gdGhpcy5yZWFkX25hbWVzcGFjZV9uYW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50TmFtZXNwYWNlID0gbmFtZTtcblxuICAgIGlmICh0aGlzLnRva2VuID09IFwiO1wiKSB7XG4gICAgICB0aGlzLmN1cnJlbnROYW1lc3BhY2UgPSBuYW1lO1xuICAgICAgYm9keSA9IHRoaXMubmV4dCgpLnJlYWRfdG9wX3N0YXRlbWVudHMoKTtcbiAgICAgIHRoaXMuZXhwZWN0KHRoaXMuRU9GKTtcbiAgICAgIHJldHVybiByZXN1bHQobmFtZS5uYW1lLCBib2R5LCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09IFwie1wiKSB7XG4gICAgICB0aGlzLmN1cnJlbnROYW1lc3BhY2UgPSBuYW1lO1xuICAgICAgYm9keSA9IHRoaXMubmV4dCgpLnJlYWRfdG9wX3N0YXRlbWVudHMoKTtcbiAgICAgIHRoaXMuZXhwZWN0KFwifVwiKSAmJiB0aGlzLm5leHQoKTtcblxuICAgICAgaWYgKGJvZHkubGVuZ3RoID09PSAwICYmIHRoaXMuZXh0cmFjdERvYyAmJiB0aGlzLl9kb2NzLmxlbmd0aCA+IHRoaXMuX2RvY0luZGV4KSB7XG4gICAgICAgIGJvZHkucHVzaCh0aGlzLm5vZGUoXCJub29wXCIpKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0KG5hbWUubmFtZSwgYm9keSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSBcIihcIikge1xuICAgICAgLy8gQGZpeG1lIGFmdGVyIG1lcmdpbmcgIzQ3OFxuICAgICAgbmFtZS5yZXNvbHV0aW9uID0gdGhpcy5hc3QucmVmZXJlbmNlLlJFTEFUSVZFX05BTUU7XG4gICAgICBuYW1lLm5hbWUgPSBuYW1lLm5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgcmVzdWx0LmRlc3Ryb3koKTtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUoXCJjYWxsXCIpKG5hbWUsIHRoaXMucmVhZF9hcmd1bWVudF9saXN0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVycm9yKFtcIntcIiwgXCI7XCJdKTsgLy8gZ3JhY2VmdWwgbW9kZSA6XG5cbiAgICAgIHRoaXMuY3VycmVudE5hbWVzcGFjZSA9IG5hbWU7XG4gICAgICBib2R5ID0gdGhpcy5yZWFkX3RvcF9zdGF0ZW1lbnRzKCk7XG4gICAgICB0aGlzLmV4cGVjdCh0aGlzLkVPRik7XG4gICAgICByZXR1cm4gcmVzdWx0KG5hbWUsIGJvZHksIGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgbmFtZXNwYWNlIG5hbWVcbiAgICogYGBgZWJuZlxuICAgKiAgbmFtZXNwYWNlX25hbWUgOjo9IFRfTlNfU0VQQVJBVE9SPyAoVF9TVFJJTkcgVF9OU19TRVBBUkFUT1IpKiBUX1NUUklOR1xuICAgKiBgYGBcbiAgICogQHNlZSBodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vbGFuZ3VhZ2UubmFtZXNwYWNlcy5ydWxlcy5waHBcbiAgICogQHJldHVybiB7UmVmZXJlbmNlfVxuICAgKi9cbiAgcmVhZF9uYW1lc3BhY2VfbmFtZTogZnVuY3Rpb24gcmVhZF9uYW1lc3BhY2VfbmFtZShyZXNvbHZlUmVmZXJlbmNlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZSgpO1xuICAgIHZhciByZWxhdGl2ZSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfTkFNRVNQQUNFKSB7XG4gICAgICB0aGlzLm5leHQoKS5leHBlY3QodGhpcy50b2suVF9OU19TRVBBUkFUT1IpICYmIHRoaXMubmV4dCgpO1xuICAgICAgcmVsYXRpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IHRoaXMucmVhZF9saXN0KHRoaXMudG9rLlRfU1RSSU5HLCB0aGlzLnRvay5UX05TX1NFUEFSQVRPUiwgdHJ1ZSk7XG5cbiAgICBpZiAoIXJlbGF0aXZlICYmIG5hbWVzLmxlbmd0aCA9PT0gMSAmJiAocmVzb2x2ZVJlZmVyZW5jZSB8fCB0aGlzLnRva2VuICE9PSBcIihcIikpIHtcbiAgICAgIGlmIChuYW1lc1swXS50b0xvd2VyQ2FzZSgpID09PSBcInBhcmVudFwiKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQoXCJwYXJlbnRyZWZlcmVuY2VcIiwgbmFtZXNbMF0pO1xuICAgICAgfSBlbHNlIGlmIChuYW1lc1swXS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGZcIikge1xuICAgICAgICByZXR1cm4gcmVzdWx0KFwic2VsZnJlZmVyZW5jZVwiLCBuYW1lc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdChcIm5hbWVcIiwgbmFtZXMsIHJlbGF0aXZlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSB1c2Ugc3RhdGVtZW50XG4gICAqIGBgYGVibmZcbiAgICogdXNlX3N0YXRlbWVudCA6Oj0gVF9VU0VcbiAgICogICB1c2VfdHlwZT8gdXNlX2RlY2xhcmF0aW9ucyB8XG4gICAqICAgdXNlX3R5cGUgdXNlX3N0YXRlbWVudCAneycgdXNlX2RlY2xhcmF0aW9ucyAnfScgfFxuICAgKiAgIHVzZV9zdGF0ZW1lbnQgJ3snIHVzZV9kZWNsYXJhdGlvbnMoPT50eXBlZCkgJ30nXG4gICAqICc7J1xuICAgKiBgYGBcbiAgICogQHNlZSBodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vbGFuZ3VhZ2UubmFtZXNwYWNlcy5pbXBvcnRpbmcucGhwXG4gICAqIEByZXR1cm4ge1VzZUdyb3VwfVxuICAgKi9cbiAgcmVhZF91c2Vfc3RhdGVtZW50OiBmdW5jdGlvbiByZWFkX3VzZV9zdGF0ZW1lbnQoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcInVzZWdyb3VwXCIpO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1VTRSkgJiYgdGhpcy5uZXh0KCk7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnJlYWRfdXNlX3R5cGUoKTtcbiAgICBpdGVtcy5wdXNoKHRoaXMucmVhZF91c2VfZGVjbGFyYXRpb24oZmFsc2UpKTtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIixcIikge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQodGhpcy5uZXh0KCkucmVhZF91c2VfZGVjbGFyYXRpb25zKGZhbHNlKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSBcIntcIikge1xuICAgICAgbmFtZSA9IGl0ZW1zWzBdLm5hbWU7XG4gICAgICBpdGVtcyA9IHRoaXMubmV4dCgpLnJlYWRfdXNlX2RlY2xhcmF0aW9ucyh0eXBlID09PSBudWxsKTtcbiAgICAgIHRoaXMuZXhwZWN0KFwifVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSByZXN1bHQobmFtZSwgdHlwZSwgaXRlbXMpO1xuICAgIHRoaXMuZXhwZWN0KFwiO1wiKSAmJiB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDEwNDVcbiAgICovXG4gIHJlYWRfY2xhc3NfbmFtZV9yZWZlcmVuY2U6IGZ1bmN0aW9uIHJlYWRfY2xhc3NfbmFtZV9yZWZlcmVuY2UoKSB7XG4gICAgLy8gcmVzb2x2ZWQgYXMgdGhlIHNhbWVcbiAgICByZXR1cm4gdGhpcy5yZWFkX3ZhcmlhYmxlKHRydWUsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSB1c2UgZGVjbGFyYXRpb25cbiAgICogYGBgZWJuZlxuICAgKiB1c2VfZGVjbGFyYXRpb24gOjo9IHVzZV90eXBlPyBuYW1lc3BhY2VfbmFtZSB1c2VfYWxpYXNcbiAgICogYGBgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMzgwXG4gICAqIEByZXR1cm4ge1VzZUl0ZW19XG4gICAqL1xuICByZWFkX3VzZV9kZWNsYXJhdGlvbjogZnVuY3Rpb24gcmVhZF91c2VfZGVjbGFyYXRpb24odHlwZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwidXNlaXRlbVwiKTtcbiAgICB2YXIgdHlwZSA9IG51bGw7XG4gICAgaWYgKHR5cGVkKSB0eXBlID0gdGhpcy5yZWFkX3VzZV90eXBlKCk7XG4gICAgdmFyIG5hbWUgPSB0aGlzLnJlYWRfbmFtZXNwYWNlX25hbWUoKTtcbiAgICB2YXIgYWxpYXMgPSB0aGlzLnJlYWRfdXNlX2FsaWFzKCk7XG4gICAgcmV0dXJuIHJlc3VsdChuYW1lLm5hbWUsIGFsaWFzLCB0eXBlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSBsaXN0IG9mIHVzZSBkZWNsYXJhdGlvbnNcbiAgICogYGBgZWJuZlxuICAgKiB1c2VfZGVjbGFyYXRpb25zIDo6PSB1c2VfZGVjbGFyYXRpb24gKCcsJyB1c2VfZGVjbGFyYXRpb24pKlxuICAgKiBgYGBcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wzODBcbiAgICogQHJldHVybiB7VXNlSXRlbVtdfVxuICAgKi9cbiAgcmVhZF91c2VfZGVjbGFyYXRpb25zOiBmdW5jdGlvbiByZWFkX3VzZV9kZWNsYXJhdGlvbnModHlwZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW3RoaXMucmVhZF91c2VfZGVjbGFyYXRpb24odHlwZWQpXTtcblxuICAgIHdoaWxlICh0aGlzLnRva2VuID09PSBcIixcIikge1xuICAgICAgdGhpcy5uZXh0KCk7XG5cbiAgICAgIGlmICh0eXBlZCkge1xuICAgICAgICBpZiAodGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9GVU5DVElPTiAmJiB0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX0NPTlNUICYmIHRoaXMudG9rZW4gIT09IHRoaXMudG9rLlRfU1RSSU5HKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9TVFJJTkcgJiYgdGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9OU19TRVBBUkFUT1IpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmVhZF91c2VfZGVjbGFyYXRpb24odHlwZWQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIHVzZSBzdGF0ZW1lbnRcbiAgICogYGBgZWJuZlxuICAgKiB1c2VfYWxpYXMgOjo9IChUX0FTIFRfU1RSSU5HKT9cbiAgICogYGBgXG4gICAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICAgKi9cbiAgcmVhZF91c2VfYWxpYXM6IGZ1bmN0aW9uIHJlYWRfdXNlX2FsaWFzKCkge1xuICAgIHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQVMpIHtcbiAgICAgIGlmICh0aGlzLm5leHQoKS5leHBlY3QodGhpcy50b2suVF9TVFJJTkcpKSB7XG4gICAgICAgIHZhciBhbGlhc05hbWUgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmVzdWx0ID0gYWxpYXNOYW1lKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBuYW1lc3BhY2UgdHlwZSBkZWNsYXJhdGlvblxuICAgKiBgYGBlYm5mXG4gICAqIHVzZV90eXBlIDo6PSAoVF9GVU5DVElPTiB8IFRfQ09OU1QpP1xuICAgKiBgYGBcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wzMzVcbiAgICogQHJldHVybiB7U3RyaW5nfG51bGx9IFBvc3NpYmxlIHZhbHVlcyA6IGZ1bmN0aW9uLCBjb25zdFxuICAgKi9cbiAgcmVhZF91c2VfdHlwZTogZnVuY3Rpb24gcmVhZF91c2VfdHlwZSgpIHtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9GVU5DVElPTikge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5hc3QudXNlaXRlbS5UWVBFX0ZVTkNUSU9OO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DT05TVCkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5hc3QudXNlaXRlbS5UWVBFX0NPTlNUO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIHNwZWNpYWxDaGFyID0ge1xuICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gICQ6IFwiJFwiLFxuICBuOiBcIlxcblwiLFxuICByOiBcIlxcclwiLFxuICB0OiBcIlxcdFwiLFxuICBmOiBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyKSxcbiAgdjogU3RyaW5nLmZyb21DaGFyQ29kZSgxMSksXG4gIGU6IFN0cmluZy5mcm9tQ2hhckNvZGUoMjcpXG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBVbmVzY2FwZSBzcGVjaWFsIGNoYXJzXG4gICAqL1xuICByZXNvbHZlX3NwZWNpYWxfY2hhcnM6IGZ1bmN0aW9uIHJlc29sdmVfc3BlY2lhbF9jaGFycyh0ZXh0LCBkb3VibGVRdW90ZSkge1xuICAgIGlmICghZG91YmxlUXVvdGUpIHtcbiAgICAgIC8vIHNpbmdsZSBxdW90ZSBmaXhcbiAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcXFxcXFxcL2csIFwiXFxcXFwiKS5yZXBsYWNlKC9cXFxcJy9nLCBcIidcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFxcXFwiLywgJ1wiJykucmVwbGFjZSgvXFxcXChbXFxcXCRucnRmdmVdfFt4WF1bMC05YS1mQS1GXXsxLDJ9fFswLTddezEsM318dXsoWzAtOWEtZkEtRl0rKX0pL2csIGZ1bmN0aW9uICgkbWF0Y2gsIHAxLCBwMikge1xuICAgICAgaWYgKHNwZWNpYWxDaGFyW3AxXSkge1xuICAgICAgICByZXR1cm4gc3BlY2lhbENoYXJbcDFdO1xuICAgICAgfSBlbHNlIGlmIChcInhcIiA9PT0gcDFbMF0gfHwgXCJYXCIgPT09IHAxWzBdKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChwMS5zdWJzdHIoMSksIDE2KSk7XG4gICAgICB9IGVsc2UgaWYgKFwidVwiID09PSBwMVswXSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQocDIsIDE2KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQocGFyc2VJbnQocDEsIDgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBsZWFkaW5nIHNwYWNlcyBlYWNoIGxpbmUgZm9yIGhlcmVkb2MgdGV4dCBpZiB0aGVyZSBpcyBhIGluZGVudGF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZGVudGF0aW9uX3VzZXNfc3BhY2VzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RfZW5jYXBzX25vZGUgaWYgaXQgaXMgYmVoaW5kIGEgdmFyaWFibGUsIHRoZSBmaXJzdCBOIHNwYWNlcyBzaG91bGQgbm90IGJlIHJlbW92ZWRcbiAgICovXG4gIHJlbW92ZV9oZXJlZG9jX2xlYWRpbmdfd2hpdGVzcGFjZV9jaGFyczogZnVuY3Rpb24gcmVtb3ZlX2hlcmVkb2NfbGVhZGluZ193aGl0ZXNwYWNlX2NoYXJzKHRleHQsIGluZGVudGF0aW9uLCBpbmRlbnRhdGlvbl91c2VzX3NwYWNlcywgZmlyc3RfZW5jYXBzX25vZGUpIHtcbiAgICBpZiAoaW5kZW50YXRpb24gPT09IDApIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tfaGVyZWRvY19pbmRlbnRhdGlvbl9sZXZlbCh0ZXh0LCBpbmRlbnRhdGlvbiwgaW5kZW50YXRpb25fdXNlc19zcGFjZXMsIGZpcnN0X2VuY2Fwc19ub2RlKTtcbiAgICB2YXIgbWF0Y2hlZENoYXIgPSBpbmRlbnRhdGlvbl91c2VzX3NwYWNlcyA/IFwiIFwiIDogXCJcXHRcIjtcbiAgICB2YXIgcmVtb3ZlbWVudFJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJcXFxcblwiLmNvbmNhdChtYXRjaGVkQ2hhciwgXCJ7XCIpLmNvbmNhdChpbmRlbnRhdGlvbiwgXCJ9XCIpLCBcImdcIik7XG4gICAgdmFyIHJlbW92ZW1lbnRGaXJzdEVuY2Fwc05vZGVSZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChtYXRjaGVkQ2hhciwgXCJ7XCIpLmNvbmNhdChpbmRlbnRhdGlvbiwgXCJ9XCIpKTsgLy8gUm91Z2ggcmVwbGFjZSwgbmVlZCBtb3JlIGNoZWNrXG5cbiAgICBpZiAoZmlyc3RfZW5jYXBzX25vZGUpIHtcbiAgICAgIC8vIFJlbW92ZSB0ZXh0IGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShyZW1vdmVtZW50Rmlyc3RFbmNhcHNOb2RlUmVnRXhwLCBcIlwiKTtcbiAgICB9IC8vIFJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UgYWZ0ZXIgXFxuXG5cblxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UocmVtb3ZlbWVudFJlZ0V4cCwgXCJcXG5cIik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGluZGVudGF0aW9uIGxldmVsIG9mIGhlcmVkb2MgaW4gdGV4dCwgaWYgbWlzbWF0Y2gsIHJhaXNlRXJyb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGVudGF0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5kZW50YXRpb25fdXNlc19zcGFjZXNcbiAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdF9lbmNhcHNfbm9kZSBpZiBpdCBpcyBiZWhpbmQgYSB2YXJpYWJsZSwgdGhlIGZpcnN0IE4gc3BhY2VzIHNob3VsZCBub3QgYmUgcmVtb3ZlZFxuICAgKi9cbiAgY2hlY2tfaGVyZWRvY19pbmRlbnRhdGlvbl9sZXZlbDogZnVuY3Rpb24gY2hlY2tfaGVyZWRvY19pbmRlbnRhdGlvbl9sZXZlbCh0ZXh0LCBpbmRlbnRhdGlvbiwgaW5kZW50YXRpb25fdXNlc19zcGFjZXMsIGZpcnN0X2VuY2Fwc19ub2RlKSB7XG4gICAgdmFyIHRleHRTaXplID0gdGV4dC5sZW5ndGg7XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIGxlYWRpbmdXaGl0ZXNwYWNlQ2hhckNvdW50ID0gMDtcbiAgICAvKipcbiAgICAgKiBAdmFyIGluQ291dGluZ1N0YXRlIHtib29sZWFufSByZXNldCB0byB0cnVlIGFmdGVyIGEgbmV3IGxpbmVcbiAgICAgKi9cblxuICAgIHZhciBpbkNvdXRpbmdTdGF0ZSA9IHRydWU7XG4gICAgdmFyIGNoVG9DaGVjayA9IGluZGVudGF0aW9uX3VzZXNfc3BhY2VzID8gXCIgXCIgOiBcIlxcdFwiO1xuICAgIHZhciBpbkNoZWNrU3RhdGUgPSBmYWxzZTtcblxuICAgIGlmICghZmlyc3RfZW5jYXBzX25vZGUpIHtcbiAgICAgIC8vIHN0YXJ0IGZyb20gZmlyc3QgXFxuXG4gICAgICBvZmZzZXQgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIik7IC8vIGlmIG5vIFxcbiwganVzdCByZXR1cm5cblxuICAgICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQrKztcbiAgICB9XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dFNpemUpIHtcbiAgICAgIGlmIChpbkNvdXRpbmdTdGF0ZSkge1xuICAgICAgICBpZiAodGV4dFtvZmZzZXRdID09PSBjaFRvQ2hlY2spIHtcbiAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZUNoYXJDb3VudCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluQ2hlY2tTdGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluQ291dGluZ1N0YXRlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0W29mZnNldF0gIT09IFwiXFxuXCIgJiYgaW5DaGVja1N0YXRlICYmIGxlYWRpbmdXaGl0ZXNwYWNlQ2hhckNvdW50IDwgaW5kZW50YXRpb24pIHtcbiAgICAgICAgdGhpcy5yYWlzZUVycm9yKFwiSW52YWxpZCBib2R5IGluZGVudGF0aW9uIGxldmVsIChleHBlY3RpbmcgYW4gaW5kZW50YXRpb24gYXQgbGVhc3QgXCIuY29uY2F0KGluZGVudGF0aW9uLCBcIilcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5DaGVja1N0YXRlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0W29mZnNldF0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgLy8gUmVzZXQgY291bnRpbmcgc3RhdGVcbiAgICAgICAgaW5Db3V0aW5nU3RhdGUgPSB0cnVlO1xuICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZUNoYXJDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIG9mZnNldCsrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgZGVyZWZlcmVuY2FibGUgc2NhbGFyXG4gICAqL1xuICByZWFkX2RlcmVmZXJlbmNhYmxlX3NjYWxhcjogZnVuY3Rpb24gcmVhZF9kZXJlZmVyZW5jYWJsZV9zY2FsYXIoKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgIGNhc2UgdGhpcy50b2suVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm5vZGUoXCJzdHJpbmdcIik7XG4gICAgICAgICAgdmFyIHRleHQgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgICAgIGlmICh0ZXh0WzBdID09PSBcImJcIiB8fCB0ZXh0WzBdID09PSBcIkJcIikge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNEb3VibGVRdW90ZSA9IHRleHRbb2Zmc2V0XSA9PT0gJ1wiJztcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB2YXIgdGV4dFZhbHVlID0gdGhpcy5yZXNvbHZlX3NwZWNpYWxfY2hhcnModGV4dC5zdWJzdHJpbmcob2Zmc2V0ICsgMSwgdGV4dC5sZW5ndGggLSAxKSwgaXNEb3VibGVRdW90ZSk7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZShpc0RvdWJsZVF1b3RlLCB0ZXh0VmFsdWUsIG9mZnNldCA9PT0gMSwgLy8gdW5pY29kZSBmbGFnXG4gICAgICAgICAgdGV4dCk7XG5cbiAgICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9ET1VCTEVfQ09MT04pIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDExNTFcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVhZF9zdGF0aWNfZ2V0dGVyKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGlycmVjdCBzdHJpbmdcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0FSUkFZOlxuICAgICAgICAvLyBhcnJheSBwYXJzZXJcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZWFkX2FycmF5KCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAvLyBzaG9ydCBhcnJheSBmb3JtYXRcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5yZWFkX2FycmF5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogIHNjYWxhciA6Oj0gVF9NQUdJQ19DT05TVFxuICAgKiAgICAgICB8IFRfTE5VTUJFUiB8IFRfRE5VTUJFUlxuICAgKiAgICAgICB8IFRfU1RBUlRfSEVSRURPQyBUX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFPyBUX0VORF9IRVJFRE9DXG4gICAqICAgICAgIHwgJ1wiJyBlbmNhcHNfbGlzdCAnXCInXG4gICAqICAgICAgIHwgVF9TVEFSVF9IRVJFRE9DIGVuY2Fwc19saXN0IFRfRU5EX0hFUkVET0NcbiAgICogICAgICAgfCBuYW1lc3BhY2VfbmFtZSAoVF9ET1VCTEVfQ09MT04gVF9TVFJJTkcpP1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfc2NhbGFyOiBmdW5jdGlvbiByZWFkX3NjYWxhcigpIHtcbiAgICBpZiAodGhpcy5pcyhcIlRfTUFHSUNfQ09OU1RcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldF9tYWdpY19jb25zdGFudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsdWUsIG5vZGU7XG5cbiAgICAgIHN3aXRjaCAodGhpcy50b2tlbikge1xuICAgICAgICAvLyBOVU1FUklDXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9MTlVNQkVSOiAvLyBsb25nXG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX0ROVU1CRVI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gZG91YmxlXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCh2YWx1ZSwgbnVsbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9TVEFSVF9IRVJFRE9DOlxuICAgICAgICAgIGlmICh0aGlzLmxleGVyLmN1ckNvbmRpdGlvbiA9PT0gXCJTVF9OT1dET0NcIikge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5sZXhlci55eWxsb2MuZmlyc3Rfb2Zmc2V0O1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMubm9kZShcIm5vd2RvY1wiKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5uZXh0KCkudGV4dCgpOyAvLyBzdHJpcCB0aGUgbGFzdCBsaW5lIHJldHVybiBjaGFyXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxleGVyLmhlcmVkb2NfbGFiZWwuaW5kZW50YXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIHRoaXMubGV4ZXIuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsYXN0Q2ggPSB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXTtcblxuICAgICAgICAgICAgaWYgKGxhc3RDaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMl0gPT09IFwiXFxyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyB3aW5kb3dzIHN0eWxlXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdmFsdWUubGVuZ3RoIC0gMik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbGludXggc3R5bGVcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsYXN0Q2ggPT09IFwiXFxyXCIpIHtcbiAgICAgICAgICAgICAgLy8gbWFjIHN0eWxlXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfRU5EX0hFUkVET0MpICYmIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgICB2YXIgcmF3ID0gdGhpcy5sZXhlci5faW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9vZmZzZXQpO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZSh0aGlzLnJlbW92ZV9oZXJlZG9jX2xlYWRpbmdfd2hpdGVzcGFjZV9jaGFycyh2YWx1ZSwgdGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmluZGVudGF0aW9uLCB0aGlzLmxleGVyLmhlcmVkb2NfbGFiZWwuaW5kZW50YXRpb25fdXNlc19zcGFjZXMsIHRoaXMubGV4ZXIuaGVyZWRvY19sYWJlbC5maXJzdF9lbmNhcHNfbm9kZSksIHJhdywgdGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmxhYmVsKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2VuY2Fwc2VkX3N0cmluZyh0aGlzLnRvay5UX0VORF9IRVJFRE9DKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRfZW5jYXBzZWRfc3RyaW5nKCdcIicpO1xuXG4gICAgICAgIGNhc2UgJ2JcIic6XG4gICAgICAgIGNhc2UgJ0JcIic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9lbmNhcHNlZF9zdHJpbmcoJ1wiJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAvLyBURVhUU1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkc6XG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9BUlJBWTogLy8gYXJyYXkgcGFyc2VyXG5cbiAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAvLyBzaG9ydCBhcnJheSBmb3JtYXRcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2RlcmVmZXJlbmNhYmxlX3NjYWxhcigpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVyciA9IHRoaXMuZXJyb3IoXCJTQ0FMQVJcIik7IC8vIGdyYWNlZnVsIG1vZGUgOiBpZ25vcmUgdG9rZW4gJiByZXR1cm4gZXJyb3Igbm9kZVxuXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZGVyZWZlcmVuY2luZ1xuICAgKi9cbiAgcmVhZF9kZXJlZmVyZW5jYWJsZTogZnVuY3Rpb24gcmVhZF9kZXJlZmVyZW5jYWJsZShleHByKSB7XG4gICAgdmFyIHJlc3VsdCwgb2Zmc2V0O1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlKFwib2Zmc2V0bG9va3VwXCIpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiW1wiKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgIGlmICh0aGlzLmV4cGVjdChcIl1cIikpIHRoaXMubmV4dCgpO1xuICAgICAgcmVzdWx0ID0gbm9kZShleHByLCBvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9ET0xMQVJfT1BFTl9DVVJMWV9CUkFDRVMpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMucmVhZF9lbmNhcHNlZF9zdHJpbmdfaXRlbShmYWxzZSk7XG4gICAgICByZXN1bHQgPSBub2RlKGV4cHIsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYW5kIGV4dHJhY3RzIGFuIGVuY2Fwc2VkIGl0ZW1cbiAgICogYGBgZWJuZlxuICAgKiBlbmNhcHNlZF9zdHJpbmdfaXRlbSA6Oj0gVF9FTkNBUFNFRF9BTkRfV0hJVEVTUEFDRVxuICAgKiAgfCBUX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUyBleHByICd9J1xuICAgKiAgfCBUX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUyBUX1NUUklOR19WQVJOQU1FICd9J1xuICAgKiAgfCBUX0RPTExBUl9PUEVOX0NVUkxZX0JSQUNFUyBUX1NUUklOR19WQVJOQU1FICdbJyBleHByICddJyAnfSdcbiAgICogIHwgVF9DVVJMWV9PUEVOIHZhcmlhYmxlICd9J1xuICAgKiAgfCB2YXJpYWJsZVxuICAgKiAgfCB2YXJpYWJsZSAnWycgZXhwciAnXSdcbiAgICogIHwgdmFyaWFibGUgVF9PQkpFQ1RfT1BFUkFUT1IgVF9TVFJJTkdcbiAgICogYGBgXG4gICAqIEByZXR1cm4ge1N0cmluZ3xWYXJpYWJsZXxFeHByfExvb2t1cH1cbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMjE5XG4gICAqL1xuICByZWFkX2VuY2Fwc2VkX3N0cmluZ19pdGVtOiBmdW5jdGlvbiByZWFkX2VuY2Fwc2VkX3N0cmluZ19pdGVtKGlzRG91YmxlUXVvdGUpIHtcbiAgICB2YXIgZW5jYXBzZWRQYXJ0ID0gdGhpcy5ub2RlKFwiZW5jYXBzZWRwYXJ0XCIpO1xuICAgIHZhciBzeW50YXggPSBudWxsO1xuICAgIHZhciBjdXJseSA9IGZhbHNlO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoKSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBub2RlLFxuICAgICAgICBuYW1lOyAvLyBwbGFpbiB0ZXh0XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMTIyMlxuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0UpIHtcbiAgICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTsgLy8gaWYgdGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmZpcnN0X2VuY2Fwc19ub2RlIC0+IHJlbW92ZSBmaXJzdCBpbmRlbnRzXG5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdChcInN0cmluZ1wiLCBmYWxzZSwgdGhpcy52ZXJzaW9uID49IDcwMyAmJiAhdGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmZpbmlzaGVkID8gdGhpcy5yZW1vdmVfaGVyZWRvY19sZWFkaW5nX3doaXRlc3BhY2VfY2hhcnModGhpcy5yZXNvbHZlX3NwZWNpYWxfY2hhcnModGV4dCwgaXNEb3VibGVRdW90ZSksIHRoaXMubGV4ZXIuaGVyZWRvY19sYWJlbC5pbmRlbnRhdGlvbiwgdGhpcy5sZXhlci5oZXJlZG9jX2xhYmVsLmluZGVudGF0aW9uX3VzZXNfc3BhY2VzLCB0aGlzLmxleGVyLmhlcmVkb2NfbGFiZWwuZmlyc3RfZW5jYXBzX25vZGUpIDogdGV4dCwgZmFsc2UsIHRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9ET0xMQVJfT1BFTl9DVVJMWV9CUkFDRVMpIHtcbiAgICAgIHN5bnRheCA9IFwic2ltcGxlXCI7XG4gICAgICBjdXJseSA9IHRydWU7IC8vIGR5bmFtaWMgdmFyaWFibGUgbmFtZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMTIzOVxuXG4gICAgICBuYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMubmV4dCgpLnRva2VuID09PSB0aGlzLnRvay5UX1NUUklOR19WQVJOQU1FKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLm5vZGUoXCJ2YXJpYWJsZVwiKTtcbiAgICAgICAgdmFyIHZhck5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7IC8vIGNoZWNrIGlmIGxvb2t1cCBhbiBvZmZzZXRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMTI0M1xuXG4gICAgICAgIGlmICh0aGlzLnRva2VuID09PSBcIltcIikge1xuICAgICAgICAgIG5hbWUgPSBuYW1lKHZhck5hbWUsIGZhbHNlKTtcbiAgICAgICAgICBub2RlID0gdGhpcy5ub2RlKFwib2Zmc2V0bG9va3VwXCIpO1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KFwiXVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXN1bHQgPSBub2RlKG5hbWUsIG9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmFtZSh2YXJOYW1lLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdChcInZhcmlhYmxlXCIsIHRoaXMucmVhZF9leHByKCksIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5leHBlY3QoXCJ9XCIpICYmIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DVVJMWV9PUEVOKSB7XG4gICAgICAvLyBleHByZXNzaW9uXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMjQ2XG4gICAgICBzeW50YXggPSBcImNvbXBsZXhcIjtcbiAgICAgIHJlc3VsdC5kZXN0cm95KCk7XG4gICAgICByZXN1bHQgPSB0aGlzLm5leHQoKS5yZWFkX3ZhcmlhYmxlKGZhbHNlLCBmYWxzZSk7XG4gICAgICB0aGlzLmV4cGVjdChcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1ZBUklBQkxFKSB7XG4gICAgICBzeW50YXggPSBcInNpbXBsZVwiOyAvLyBwbGFpbiB2YXJpYWJsZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMMTIzMVxuXG4gICAgICByZXN1bHQuZGVzdHJveSgpO1xuICAgICAgcmVzdWx0ID0gdGhpcy5yZWFkX3NpbXBsZV92YXJpYWJsZSgpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMjMzXG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSBcIltcIikge1xuICAgICAgICBub2RlID0gdGhpcy5ub2RlKFwib2Zmc2V0bG9va3VwXCIpO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLm5leHQoKS5yZWFkX2VuY2Fwc192YXJfb2Zmc2V0KCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwiXVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgcmVzdWx0ID0gbm9kZShyZXN1bHQsIG9mZnNldCk7XG4gICAgICB9IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDEyMzZcblxuXG4gICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9PQkpFQ1RfT1BFUkFUT1IpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMubm9kZShcInByb3BlcnR5bG9va3VwXCIpO1xuICAgICAgICB0aGlzLm5leHQoKS5leHBlY3QodGhpcy50b2suVF9TVFJJTkcpO1xuICAgICAgICB2YXIgd2hhdCA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7XG4gICAgICAgIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJlc3VsdCA9IG5vZGUocmVzdWx0LCB3aGF0KG5hbWUpKTtcbiAgICAgIH0gLy8gZXJyb3IgLyBmYWxsYmFja1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0UpO1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy50ZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTsgLy8gY29uc2lkZXIgaXQgYXMgc3RyaW5nXG5cbiAgICAgIHJlc3VsdC5kZXN0cm95KCk7XG4gICAgICByZXN1bHQgPSByZXN1bHQoXCJzdHJpbmdcIiwgZmFsc2UsIHZhbHVlLCBmYWxzZSwgdmFsdWUpO1xuICAgIH0gLy8gcmVzZXQgZmlyc3RfZW5jYXBzX25vZGUgdG8gZmFsc2UgYWZ0ZXIgYWNjZXNzIGFueSBub2RlXG5cblxuICAgIHRoaXMubGV4ZXIuaGVyZWRvY19sYWJlbC5maXJzdF9lbmNhcHNfbm9kZSA9IGZhbHNlO1xuICAgIHJldHVybiBlbmNhcHNlZFBhcnQocmVzdWx0LCBzeW50YXgsIGN1cmx5KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYW4gZW5jYXBzZWQgc3RyaW5nXG4gICAqL1xuICByZWFkX2VuY2Fwc2VkX3N0cmluZzogZnVuY3Rpb24gcmVhZF9lbmNhcHNlZF9zdHJpbmcoZXhwZWN0KSB7XG4gICAgdmFyIGlzQmluYXJ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgbGFiZWxTdGFydCA9IHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldDtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZShcImVuY2Fwc2VkXCIpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHZhciBzdGFydCA9IHRoaXMubGV4ZXIueXlsbG9jLnByZXZfb2Zmc2V0IC0gKGlzQmluYXJ5ID8gMSA6IDApO1xuICAgIHZhciB2YWx1ZSA9IFtdO1xuICAgIHZhciB0eXBlID0gbnVsbDtcblxuICAgIGlmIChleHBlY3QgPT09IFwiYFwiKSB7XG4gICAgICB0eXBlID0gdGhpcy5hc3QuZW5jYXBzZWQuVFlQRV9TSEVMTDtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdCA9PT0gJ1wiJykge1xuICAgICAgdHlwZSA9IHRoaXMuYXN0LmVuY2Fwc2VkLlRZUEVfU1RSSU5HO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy5hc3QuZW5jYXBzZWQuVFlQRV9IRVJFRE9DO1xuICAgIH0gLy8gcmVhZGluZyBlbmNhcHNlZCBwYXJ0c1xuXG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPT0gZXhwZWN0ICYmIHRoaXMudG9rZW4gIT09IHRoaXMuRU9GKSB7XG4gICAgICB2YWx1ZS5wdXNoKHRoaXMucmVhZF9lbmNhcHNlZF9zdHJpbmdfaXRlbSh0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgJiYgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0ua2luZCA9PT0gXCJlbmNhcHNlZHBhcnRcIiAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXS5leHByZXNzaW9uLmtpbmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciBfbm9kZSA9IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdLmV4cHJlc3Npb247XG4gICAgICB2YXIgbGFzdENoID0gX25vZGUudmFsdWVbX25vZGUudmFsdWUubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChsYXN0Q2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgaWYgKF9ub2RlLnZhbHVlW19ub2RlLnZhbHVlLmxlbmd0aCAtIDJdID09PSBcIlxcclwiKSB7XG4gICAgICAgICAgLy8gd2luZG93cyBzdHlsZVxuICAgICAgICAgIF9ub2RlLnZhbHVlID0gX25vZGUudmFsdWUuc3Vic3RyaW5nKDAsIF9ub2RlLnZhbHVlLmxlbmd0aCAtIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGxpbnV4IHN0eWxlXG4gICAgICAgICAgX25vZGUudmFsdWUgPSBfbm9kZS52YWx1ZS5zdWJzdHJpbmcoMCwgX25vZGUudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGFzdENoID09PSBcIlxcclwiKSB7XG4gICAgICAgIC8vIG1hYyBzdHlsZVxuICAgICAgICBfbm9kZS52YWx1ZSA9IF9ub2RlLnZhbHVlLnN1YnN0cmluZygwLCBfbm9kZS52YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmV4cGVjdChleHBlY3QpICYmIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIHJhdyA9IHRoaXMubGV4ZXIuX2lucHV0LnN1YnN0cmluZyh0eXBlID09PSBcImhlcmVkb2NcIiA/IGxhYmVsU3RhcnQgOiBzdGFydCAtIDEsIHRoaXMubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldCk7XG5cbiAgICBub2RlID0gbm9kZSh2YWx1ZSwgcmF3LCB0eXBlKTtcblxuICAgIGlmIChleHBlY3QgPT09IHRoaXMudG9rLlRfRU5EX0hFUkVET0MpIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLmxleGVyLmhlcmVkb2NfbGFiZWwubGFiZWw7XG4gICAgICB0aGlzLmxleGVyLmhlcmVkb2NfbGFiZWwuZmluaXNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdGFudCB0b2tlblxuICAgKi9cbiAgZ2V0X21hZ2ljX2NvbnN0YW50OiBmdW5jdGlvbiBnZXRfbWFnaWNfY29uc3RhbnQoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcIm1hZ2ljXCIpO1xuICAgIHZhciBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHJlc3VsdChuYW1lLnRvVXBwZXJDYXNlKCksIG5hbWUpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiByZWFkaW5nIGEgbGlzdCBvZiB0b3Agc3RhdGVtZW50cyAoaGVscGVyIGZvciB0b3Bfc3RhdGVtZW50KilcbiAgICogYGBgZWJuZlxuICAgKiAgdG9wX3N0YXRlbWVudHMgOjo9IHRvcF9zdGF0ZW1lbnQqXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF90b3Bfc3RhdGVtZW50czogZnVuY3Rpb24gcmVhZF90b3Bfc3RhdGVtZW50cygpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPT0gdGhpcy5FT0YgJiYgdGhpcy50b2tlbiAhPT0gXCJ9XCIpIHtcbiAgICAgIHZhciBzdGF0ZW1lbnQgPSB0aGlzLnJlYWRfdG9wX3N0YXRlbWVudCgpO1xuXG4gICAgICBpZiAoc3RhdGVtZW50KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXRlbWVudCkpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHN0YXRlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlYWRpbmcgYSB0b3Agc3RhdGVtZW50XG4gICAqIGBgYGVibmZcbiAgICogIHRvcF9zdGF0ZW1lbnQgOjo9XG4gICAqICAgICAgIG5hbWVzcGFjZSB8IGZ1bmN0aW9uIHwgY2xhc3NcbiAgICogICAgICAgfCBpbnRlcmZhY2UgfCB0cmFpdFxuICAgKiAgICAgICB8IHVzZV9zdGF0ZW1lbnRzIHwgY29uc3RfbGlzdFxuICAgKiAgICAgICB8IHN0YXRlbWVudFxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfdG9wX3N0YXRlbWVudDogZnVuY3Rpb24gcmVhZF90b3Bfc3RhdGVtZW50KCkge1xuICAgIHN3aXRjaCAodGhpcy50b2tlbikge1xuICAgICAgY2FzZSB0aGlzLnRvay5UX0ZVTkNUSU9OOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2Z1bmN0aW9uKGZhbHNlLCBmYWxzZSk7XG4gICAgICAvLyBvcHRpb25hbCBmbGFnc1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfQUJTVFJBQ1Q6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfRklOQUw6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfQ0xBU1M6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfY2xhc3NfZGVjbGFyYXRpb25fc3RhdGVtZW50KCk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9JTlRFUkZBQ0U6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfaW50ZXJmYWNlX2RlY2xhcmF0aW9uX3N0YXRlbWVudCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfVFJBSVQ6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfdHJhaXRfZGVjbGFyYXRpb25fc3RhdGVtZW50KCk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9VU0U6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfdXNlX3N0YXRlbWVudCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfQ09OU1Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwiY29uc3RhbnRzdGF0ZW1lbnRcIik7XG4gICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5uZXh0KCkucmVhZF9jb25zdF9saXN0KCk7XG4gICAgICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQobnVsbCwgaXRlbXMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9OQU1FU1BBQ0U6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfbmFtZXNwYWNlKCk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9IQUxUX0NPTVBJTEVSOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQgPSB0aGlzLm5vZGUoXCJoYWx0XCIpO1xuXG4gICAgICAgICAgaWYgKHRoaXMubmV4dCgpLmV4cGVjdChcIihcIikpIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlmICh0aGlzLmV4cGVjdChcIilcIikpIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KFwiO1wiKTtcbiAgICAgICAgICB0aGlzLmxleGVyLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBfcmVzdWx0KHRoaXMubGV4ZXIuX2lucHV0LnN1YnN0cmluZyh0aGlzLmxleGVyLm9mZnNldCkpO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfc3RhdGVtZW50KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiByZWFkcyBhIGxpc3Qgb2Ygc2ltcGxlIGlubmVyIHN0YXRlbWVudHMgKGhlbHBlciBmb3IgaW5uZXJfc3RhdGVtZW50KilcbiAgICogYGBgZWJuZlxuICAgKiAgaW5uZXJfc3RhdGVtZW50cyA6Oj0gaW5uZXJfc3RhdGVtZW50KlxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfaW5uZXJfc3RhdGVtZW50czogZnVuY3Rpb24gcmVhZF9pbm5lcl9zdGF0ZW1lbnRzKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICh0aGlzLnRva2VuICE9IHRoaXMuRU9GICYmIHRoaXMudG9rZW4gIT09IFwifVwiKSB7XG4gICAgICB2YXIgc3RhdGVtZW50ID0gdGhpcy5yZWFkX2lubmVyX3N0YXRlbWVudCgpO1xuXG4gICAgICBpZiAoc3RhdGVtZW50KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHN0YXRlbWVudCkpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHN0YXRlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgbGlzdCBvZiBjb25zdGFudHMgZGVjbGFyYXRpb25cbiAgICogYGBgZWJuZlxuICAgKiAgIGNvbnN0X2xpc3QgOjo9IFRfQ09OU1QgVF9TVFJJTkcgJz0nIGV4cHIgKCcsJyBUX1NUUklORyAnPScgZXhwcikqICc7J1xuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfY29uc3RfbGlzdDogZnVuY3Rpb24gcmVhZF9jb25zdF9saXN0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRfbGlzdChmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1NUUklORyk7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwiY29uc3RhbnRcIik7XG4gICAgICB2YXIgY29uc3ROYW1lID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgIHZhciBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0TmFtZSA9IGNvbnN0TmFtZShuYW1lKTtcblxuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiPVwiKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0KGNvbnN0TmFtZSwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2tcbiAgICAgICAgcmV0dXJuIHJlc3VsdChjb25zdE5hbWUsIG51bGwpO1xuICAgICAgfVxuICAgIH0sIFwiLFwiLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIGEgbGlzdCBvZiBjb25zdGFudHMgZGVjbGFyYXRpb25cbiAgICogYGBgZWJuZlxuICAgKiAgIGRlY2xhcmVfbGlzdCA6Oj0gSURFTlRJRklFUiAnPScgZXhwciAoJywnIElERU5USUZJRVIgJz0nIGV4cHIpKlxuICAgKiBgYGBcbiAgICogQHJldHJ1cm4ge0FycmF5fVxuICAgKi9cbiAgcmVhZF9kZWNsYXJlX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfZGVjbGFyZV9saXN0KCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICh0aGlzLnRva2VuICE9IHRoaXMuRU9GICYmIHRoaXMudG9rZW4gIT09IFwiKVwiKSB7XG4gICAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1NUUklORyk7XG4gICAgICB2YXIgZGlyZWN0aXZlID0gdGhpcy5ub2RlKFwiZGVjbGFyZWRpcmVjdGl2ZVwiKTtcbiAgICAgIHZhciBrZXkgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAga2V5ID0ga2V5KG5hbWUpO1xuICAgICAgdmFyIHZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuZXhwZWN0KFwiPVwiKSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQucHVzaChkaXJlY3RpdmUoa2V5LCB2YWx1ZSkpO1xuICAgICAgaWYgKHRoaXMudG9rZW4gIT09IFwiLFwiKSBicmVhaztcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHJlYWRzIGEgc2ltcGxlIGlubmVyIHN0YXRlbWVudFxuICAgKiBgYGBlYm5mXG4gICAqICBpbm5lcl9zdGF0ZW1lbnQgOjo9ICd7JyBpbm5lcl9zdGF0ZW1lbnRzICd9JyB8IHRva2VuXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9pbm5lcl9zdGF0ZW1lbnQ6IGZ1bmN0aW9uIHJlYWRfaW5uZXJfc3RhdGVtZW50KCkge1xuICAgIHN3aXRjaCAodGhpcy50b2tlbikge1xuICAgICAgY2FzZSB0aGlzLnRvay5UX0ZVTkNUSU9OOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2Z1bmN0aW9uKGZhbHNlLCBmYWxzZSk7XG4gICAgICAvLyBvcHRpb25hbCBmbGFnc1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfQUJTVFJBQ1Q6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfRklOQUw6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfQ0xBU1M6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfY2xhc3NfZGVjbGFyYXRpb25fc3RhdGVtZW50KCk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9JTlRFUkZBQ0U6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfaW50ZXJmYWNlX2RlY2xhcmF0aW9uX3N0YXRlbWVudCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfVFJBSVQ6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfdHJhaXRfZGVjbGFyYXRpb25fc3RhdGVtZW50KCk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9IQUxUX0NPTVBJTEVSOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5yYWlzZUVycm9yKFwiX19IQUxUX0NPTVBJTEVSKCkgY2FuIG9ubHkgYmUgdXNlZCBmcm9tIHRoZSBvdXRlcm1vc3Qgc2NvcGVcIik7IC8vIGZhbGxiYWNrIDogcmV0dXJucyBhIG5vZGUgYnV0IGRvZXMgbm90IHN0b3AgdGhlIHBhcnNpbmdcblxuICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKFwiaGFsdFwiKTtcbiAgICAgICAgICB0aGlzLm5leHQoKS5leHBlY3QoXCIoXCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KFwiKVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgICBub2RlID0gbm9kZSh0aGlzLmxleGVyLl9pbnB1dC5zdWJzdHJpbmcodGhpcy5sZXhlci5vZmZzZXQpKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdChcIjtcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9zdGF0ZW1lbnQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIHN0YXRlbWVudHNcbiAgICovXG4gIHJlYWRfc3RhdGVtZW50OiBmdW5jdGlvbiByZWFkX3N0YXRlbWVudCgpIHtcbiAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfY29kZV9ibG9jayhmYWxzZSk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9JRjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9pZigpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfU1dJVENIOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX3N3aXRjaCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfRk9SOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkX2ZvcigpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfRk9SRUFDSDpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9mb3JlYWNoKCk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9XSElMRTpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZF93aGlsZSgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfRE86XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfZG8oKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0NPTU1FTlQ6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfY29tbWVudCgpO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfRE9DX0NPTU1FTlQ6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfZG9jX2NvbW1lbnQoKTtcblxuICAgICAgY2FzZSB0aGlzLnRvay5UX1JFVFVSTjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJyZXR1cm5cIik7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdmFyIGV4cHIgPSB0aGlzLnJlYWRfb3B0aW9uYWxfZXhwcihcIjtcIik7XG4gICAgICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQoZXhwcik7XG4gICAgICAgIH1cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iL21hc3Rlci9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDQyOVxuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfQlJFQUs6XG4gICAgICBjYXNlIHRoaXMudG9rLlRfQ09OVElOVUU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Jlc3VsdDIgPSB0aGlzLm5vZGUodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DT05USU5VRSA/IFwiY29udGludWVcIiA6IFwiYnJlYWtcIik7XG5cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSB0aGlzLnJlYWRfb3B0aW9uYWxfZXhwcihcIjtcIik7XG4gICAgICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudCgpO1xuICAgICAgICAgIHJldHVybiBfcmVzdWx0MihsZXZlbCk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0dMT0JBTDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcmVzdWx0MyA9IHRoaXMubm9kZShcImdsb2JhbFwiKTtcblxuICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMubmV4dCgpLnJlYWRfbGlzdCh0aGlzLnJlYWRfc2ltcGxlX3ZhcmlhYmxlLCBcIixcIik7XG4gICAgICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudCgpO1xuICAgICAgICAgIHJldHVybiBfcmVzdWx0MyhpdGVtcyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0aGlzLnRvay5UX1NUQVRJQzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gW3RoaXMudG9rZW4sIHRoaXMubGV4ZXIuZ2V0U3RhdGUoKV07XG5cbiAgICAgICAgICB2YXIgX3Jlc3VsdDQgPSB0aGlzLm5vZGUoKTtcblxuICAgICAgICAgIGlmICh0aGlzLm5leHQoKS50b2tlbiA9PT0gdGhpcy50b2suVF9ET1VCTEVfQ09MT04pIHtcbiAgICAgICAgICAgIC8vIHN0YXRpYyBrZXl3b3JkIGZvciBhIGNsYXNzXG4gICAgICAgICAgICB0aGlzLmxleGVyLnRva2Vucy5wdXNoKGN1cnJlbnQpO1xuXG4gICAgICAgICAgICB2YXIgX2V4cHIgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcblxuICAgICAgICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudChfZXhwcik7XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdDQoXCJleHByZXNzaW9uc3RhdGVtZW50XCIsIF9leHByKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9GVU5DVElPTikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZF9mdW5jdGlvbih0cnVlLCBbMCwgMSwgMF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfaXRlbXMgPSB0aGlzLnJlYWRfdmFyaWFibGVfZGVjbGFyYXRpb25zKCk7XG5cbiAgICAgICAgICB0aGlzLmV4cGVjdEVuZE9mU3RhdGVtZW50KCk7XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHQ0KFwic3RhdGljXCIsIF9pdGVtcyk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0VDSE86XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Jlc3VsdDUgPSB0aGlzLm5vZGUoXCJlY2hvXCIpO1xuXG4gICAgICAgICAgdmFyIHRleHQgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgICB2YXIgc2hvcnRGb3JtID0gdGV4dCA9PT0gXCI8Pz1cIiB8fCB0ZXh0ID09PSBcIjwlPVwiO1xuICAgICAgICAgIHZhciBleHByZXNzaW9ucyA9IHRoaXMubmV4dCgpLnJlYWRfZnVuY3Rpb25fbGlzdCh0aGlzLnJlYWRfZXhwciwgXCIsXCIpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoKTtcbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdDUoZXhwcmVzc2lvbnMsIHNob3J0Rm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0aGlzLnRvay5UX0lOTElORV9IVE1MOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgdmFyIHByZXZDaGFyID0gdGhpcy5sZXhlci55eWxsb2MuZmlyc3Rfb2Zmc2V0ID4gMCA/IHRoaXMubGV4ZXIuX2lucHV0W3RoaXMubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldCAtIDFdIDogbnVsbDtcbiAgICAgICAgICB2YXIgZml4Rmlyc3RMaW5lID0gcHJldkNoYXIgPT09IFwiXFxyXCIgfHwgcHJldkNoYXIgPT09IFwiXFxuXCI7IC8vIHJldmVydCBiYWNrIHRoZSBmaXJzdCBzdHJpcHBlZCBsaW5lXG5cbiAgICAgICAgICBpZiAoZml4Rmlyc3RMaW5lKSB7XG4gICAgICAgICAgICBpZiAocHJldkNoYXIgPT09IFwiXFxuXCIgJiYgdGhpcy5sZXhlci55eWxsb2MuZmlyc3Rfb2Zmc2V0ID4gMSAmJiB0aGlzLmxleGVyLl9pbnB1dFt0aGlzLmxleGVyLnl5bGxvYy5maXJzdF9vZmZzZXQgLSAyXSA9PT0gXCJcXHJcIikge1xuICAgICAgICAgICAgICBwcmV2Q2hhciA9IFwiXFxyXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yZXN1bHQ2ID0gdGhpcy5ub2RlKFwiaW5saW5lXCIpO1xuXG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHQ2KHZhbHVlLCBmaXhGaXJzdExpbmUgPyBwcmV2Q2hhciArIHZhbHVlIDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9VTlNFVDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcmVzdWx0NyA9IHRoaXMubm9kZShcInVuc2V0XCIpO1xuXG4gICAgICAgICAgdGhpcy5uZXh0KCkuZXhwZWN0KFwiKFwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgICB2YXIgdmFyaWFibGVzID0gdGhpcy5yZWFkX2Z1bmN0aW9uX2xpc3QodGhpcy5yZWFkX3ZhcmlhYmxlLCBcIixcIik7XG4gICAgICAgICAgdGhpcy5leHBlY3QoXCIpXCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KFwiO1wiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdDcodmFyaWFibGVzKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfREVDTEFSRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcmVzdWx0OCA9IHRoaXMubm9kZShcImRlY2xhcmVcIik7XG5cbiAgICAgICAgICB2YXIgYm9keSA9IFtdO1xuICAgICAgICAgIHZhciBtb2RlO1xuICAgICAgICAgIHRoaXMubmV4dCgpLmV4cGVjdChcIihcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSB0aGlzLnJlYWRfZGVjbGFyZV9saXN0KCk7XG4gICAgICAgICAgdGhpcy5leHBlY3QoXCIpXCIpICYmIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMudG9rZW4gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcblxuICAgICAgICAgICAgd2hpbGUgKHRoaXMudG9rZW4gIT0gdGhpcy5FT0YgJiYgdGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9FTkRERUNMQVJFKSB7XG4gICAgICAgICAgICAgIC8vIEB0b2RvIDogY2hlY2sgZGVjbGFyZV9zdGF0ZW1lbnQgZnJvbSBwaHAgLyBub3QgdmFsaWRcbiAgICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMucmVhZF90b3Bfc3RhdGVtZW50KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYm9keS5sZW5ndGggPT09IDAgJiYgdGhpcy5leHRyYWN0RG9jICYmIHRoaXMuX2RvY3MubGVuZ3RoID4gdGhpcy5fZG9jSW5kZXgpIHtcbiAgICAgICAgICAgICAgYm9keS5wdXNoKHRoaXMubm9kZShcIm5vb3BcIikoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfRU5EREVDTEFSRSkgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdEVuZE9mU3RhdGVtZW50KCk7XG4gICAgICAgICAgICBtb2RlID0gdGhpcy5hc3QuZGVjbGFyZS5NT0RFX1NIT1JUO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgICB3aGlsZSAodGhpcy50b2tlbiAhPSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSBcIn1cIikge1xuICAgICAgICAgICAgICAvLyBAdG9kbyA6IGNoZWNrIGRlY2xhcmVfc3RhdGVtZW50IGZyb20gcGhwIC8gbm90IHZhbGlkXG4gICAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLnJlYWRfdG9wX3N0YXRlbWVudCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID09PSAwICYmIHRoaXMuZXh0cmFjdERvYyAmJiB0aGlzLl9kb2NzLmxlbmd0aCA+IHRoaXMuX2RvY0luZGV4KSB7XG4gICAgICAgICAgICAgIGJvZHkucHVzaCh0aGlzLm5vZGUoXCJub29wXCIpKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmV4cGVjdChcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICBtb2RlID0gdGhpcy5hc3QuZGVjbGFyZS5NT0RFX0JMT0NLO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdChcIjtcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICBtb2RlID0gdGhpcy5hc3QuZGVjbGFyZS5NT0RFX05PTkU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHQ4KGRpcmVjdGl2ZXMsIGJvZHksIG1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9UUlk6XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRfdHJ5KCk7XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9USFJPVzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcmVzdWx0OSA9IHRoaXMubm9kZShcInRocm93XCIpO1xuXG4gICAgICAgICAgdmFyIF9leHByMiA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuXG4gICAgICAgICAgdGhpcy5leHBlY3RFbmRPZlN0YXRlbWVudCgpO1xuICAgICAgICAgIHJldHVybiBfcmVzdWx0OShfZXhwcjIpO1xuICAgICAgICB9XG4gICAgICAvLyBpZ25vcmUgdGhpcyAoZXh0cmEgcG9uY3R1YXRpb24pXG5cbiAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfU1RSSU5HOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQxMCA9IHRoaXMubm9kZSgpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50ID0gW3RoaXMudG9rZW4sIHRoaXMubGV4ZXIuZ2V0U3RhdGUoKV07XG4gICAgICAgICAgdmFyIGxhYmVsTmFtZVRleHQgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgICB2YXIgbGFiZWxOYW1lID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTsgLy8gQVNUIDogaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMNDU3XG5cbiAgICAgICAgICBpZiAodGhpcy5uZXh0KCkudG9rZW4gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICBsYWJlbE5hbWUgPSBsYWJlbE5hbWUobGFiZWxOYW1lVGV4dCk7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0MTAoXCJsYWJlbFwiLCBsYWJlbE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYWJlbE5hbWUuZGVzdHJveSgpO1xuICAgICAgICAgIH0gLy8gZGVmYXVsdCBmYWxsYmFjayBleHByIC8gVF9TVFJJTkcgJzo6JyAoZXRjLi4uKVxuXG5cbiAgICAgICAgICBfcmVzdWx0MTAuZGVzdHJveSgpO1xuXG4gICAgICAgICAgdGhpcy5sZXhlci50b2tlbnMucHVzaChfY3VycmVudCk7XG4gICAgICAgICAgdmFyIHN0YXRlbWVudCA9IHRoaXMubm9kZShcImV4cHJlc3Npb25zdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICB2YXIgX2V4cHIzID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG5cbiAgICAgICAgICB0aGlzLmV4cGVjdEVuZE9mU3RhdGVtZW50KF9leHByMyk7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlbWVudChfZXhwcjMpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdGhpcy50b2suVF9HT1RPOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQxMSA9IHRoaXMubm9kZShcImdvdG9cIik7XG5cbiAgICAgICAgICB2YXIgX2xhYmVsTmFtZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodGhpcy5uZXh0KCkuZXhwZWN0KHRoaXMudG9rLlRfU1RSSU5HKSkge1xuICAgICAgICAgICAgX2xhYmVsTmFtZSA9IHRoaXMubm9kZShcImlkZW50aWZpZXJcIik7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICBfbGFiZWxOYW1lID0gX2xhYmVsTmFtZShuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdDExKF9sYWJlbE5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBkZWZhdWx0IGZhbGxiYWNrIGV4cHJcbiAgICAgICAgICB2YXIgX3N0YXRlbWVudCA9IHRoaXMubm9kZShcImV4cHJlc3Npb25zdGF0ZW1lbnRcIik7XG5cbiAgICAgICAgICB2YXIgX2V4cHI0ID0gdGhpcy5yZWFkX2V4cHIoKTtcblxuICAgICAgICAgIHRoaXMuZXhwZWN0RW5kT2ZTdGF0ZW1lbnQoX2V4cHI0KTtcbiAgICAgICAgICByZXR1cm4gX3N0YXRlbWVudChfZXhwcjQpO1xuICAgICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBgYGBlYm5mXG4gICAqICBjb2RlX2Jsb2NrIDo6PSAneycgKGlubmVyX3N0YXRlbWVudHMgfCB0b3Bfc3RhdGVtZW50cykgJ30nXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9jb2RlX2Jsb2NrOiBmdW5jdGlvbiByZWFkX2NvZGVfYmxvY2sodG9wKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcImJsb2NrXCIpO1xuICAgIHRoaXMuZXhwZWN0KFwie1wiKSAmJiB0aGlzLm5leHQoKTtcbiAgICB2YXIgYm9keSA9IHRvcCA/IHRoaXMucmVhZF90b3Bfc3RhdGVtZW50cygpIDogdGhpcy5yZWFkX2lubmVyX3N0YXRlbWVudHMoKTtcblxuICAgIGlmIChib2R5Lmxlbmd0aCA9PT0gMCAmJiB0aGlzLmV4dHJhY3REb2MgJiYgdGhpcy5fZG9jcy5sZW5ndGggPiB0aGlzLl9kb2NJbmRleCkge1xuICAgICAgYm9keS5wdXNoKHRoaXMubm9kZShcIm5vb3BcIikoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5leHBlY3QoXCJ9XCIpICYmIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiByZXN1bHQobnVsbCwgYm9keSk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIFJlYWRzIGEgc3dpdGNoIHN0YXRlbWVudFxuICAgKiBgYGBlYm5mXG4gICAqICBzd2l0Y2ggOjo9IFRfU1dJVENIICcoJyBleHByICcpJyBzd2l0Y2hfY2FzZV9saXN0XG4gICAqIGBgYFxuICAgKiBAcmV0dXJuIHtTd2l0Y2h9XG4gICAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2NvbnRyb2wtc3RydWN0dXJlcy5zd2l0Y2gucGhwXG4gICAqL1xuICByZWFkX3N3aXRjaDogZnVuY3Rpb24gcmVhZF9zd2l0Y2goKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcInN3aXRjaFwiKTtcbiAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1NXSVRDSCkgJiYgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHBlY3QoXCIoXCIpICYmIHRoaXMubmV4dCgpO1xuICAgIHZhciB0ZXN0ID0gdGhpcy5yZWFkX2V4cHIoKTtcbiAgICB0aGlzLmV4cGVjdChcIilcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgdmFyIHNob3J0Rm9ybSA9IHRoaXMudG9rZW4gPT09IFwiOlwiO1xuICAgIHZhciBib2R5ID0gdGhpcy5yZWFkX3N3aXRjaF9jYXNlX2xpc3QoKTtcbiAgICByZXR1cm4gcmVzdWx0KHRlc3QsIGJvZHksIHNob3J0Rm9ybSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogIHN3aXRjaF9jYXNlX2xpc3QgOjo9ICd7JyAnOyc/IGNhc2VfbGlzdCogJ30nIHwgJzonICc7Jz8gY2FzZV9saXN0KiBUX0VORFNXSVRDSCAnOydcbiAgICogYGBgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMNTY2XG4gICAqL1xuICByZWFkX3N3aXRjaF9jYXNlX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfc3dpdGNoX2Nhc2VfbGlzdCgpIHtcbiAgICAvLyBERVRFQ1QgU1dJVENIIE1PREVcbiAgICB2YXIgZXhwZWN0ID0gbnVsbDtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ub2RlKFwiYmxvY2tcIik7XG4gICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICBpZiAodGhpcy50b2tlbiA9PT0gXCJ7XCIpIHtcbiAgICAgIGV4cGVjdCA9IFwifVwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gXCI6XCIpIHtcbiAgICAgIGV4cGVjdCA9IHRoaXMudG9rLlRfRU5EU1dJVENIO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdChbXCJ7XCIsIFwiOlwiXSk7XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0KCk7IC8vIE9QVElPTk5BTCAnOydcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhwL3BocC1zcmMvYmxvYi9tYXN0ZXIvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0w1NzBcblxuICAgIGlmICh0aGlzLnRva2VuID09PSBcIjtcIikge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSAvLyBFWFRSQUNUSU5HIENBU0VTXG5cblxuICAgIHdoaWxlICh0aGlzLnRva2VuICE9PSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSBleHBlY3QpIHtcbiAgICAgIGl0ZW1zLnB1c2godGhpcy5yZWFkX2Nhc2VfbGlzdChleHBlY3QpKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwICYmIHRoaXMuZXh0cmFjdERvYyAmJiB0aGlzLl9kb2NzLmxlbmd0aCA+IHRoaXMuX2RvY0luZGV4KSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMubm9kZShcIm5vb3BcIikoKSk7XG4gICAgfSAvLyBDSEVDSyBFTkQgVE9LRU5cblxuXG4gICAgdGhpcy5leHBlY3QoZXhwZWN0KSAmJiB0aGlzLm5leHQoKTtcblxuICAgIGlmIChleHBlY3QgPT09IHRoaXMudG9rLlRfRU5EU1dJVENIKSB7XG4gICAgICB0aGlzLmV4cGVjdEVuZE9mU3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdChudWxsLCBpdGVtcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogICBjYXNlX2xpc3QgOjo9ICgoVF9DQVNFIGV4cHIpIHwgVF9ERUZBVUxUKSAoJzonIHwgJzsnKSBpbm5lcl9zdGF0ZW1lbnQqXG4gICAqIGBgYFxuICAgKi9cbiAgcmVhZF9jYXNlX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfY2FzZV9saXN0KHN0b3BUb2tlbikge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm5vZGUoXCJjYXNlXCIpO1xuICAgIHZhciB0ZXN0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0NBU0UpIHtcbiAgICAgIHRlc3QgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfREVGQVVMVCkge1xuICAgICAgLy8gdGhlIGRlZmF1bHQgZW50cnkgLSBubyBjb25kaXRpb25cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdChbdGhpcy50b2suVF9DQVNFLCB0aGlzLnRvay5UX0RFRkFVTFRdKTtcbiAgICB9IC8vIGNhc2Vfc2VwYXJhdG9yXG5cblxuICAgIHRoaXMuZXhwZWN0KFtcIjpcIiwgXCI7XCJdKSAmJiB0aGlzLm5leHQoKTtcbiAgICB2YXIgYm9keSA9IHRoaXMubm9kZShcImJsb2NrXCIpO1xuICAgIHZhciBpdGVtcyA9IFtdO1xuXG4gICAgd2hpbGUgKHRoaXMudG9rZW4gIT09IHRoaXMuRU9GICYmIHRoaXMudG9rZW4gIT09IHN0b3BUb2tlbiAmJiB0aGlzLnRva2VuICE9PSB0aGlzLnRvay5UX0NBU0UgJiYgdGhpcy50b2tlbiAhPT0gdGhpcy50b2suVF9ERUZBVUxUKSB7XG4gICAgICBpdGVtcy5wdXNoKHRoaXMucmVhZF9pbm5lcl9zdGF0ZW1lbnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCh0ZXN0LCBib2R5KG51bGwsIGl0ZW1zKSk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogIHRyeSA6Oj0gVF9UUlkgJ3snIGlubmVyX3N0YXRlbWVudCogJ30nXG4gICAqICAgICAgICAgIChcbiAgICogICAgICAgICAgICAgIFRfQ0FUQ0ggJygnIG5hbWVzcGFjZV9uYW1lIHZhcmlhYmxlICcpJyAneycgIGlubmVyX3N0YXRlbWVudCogJ30nXG4gICAqICAgICAgICAgICkqXG4gICAqICAgICAgICAgIChUX0ZJTkFMTFkgJ3snIGlubmVyX3N0YXRlbWVudCogJ30nKT9cbiAgICogYGBgXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMNDQ4XG4gICAqIEByZXR1cm4ge1RyeX1cbiAgICovXG4gIHJlYWRfdHJ5OiBmdW5jdGlvbiByZWFkX3RyeSgpIHtcbiAgICB0aGlzLmV4cGVjdCh0aGlzLnRvay5UX1RSWSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcInRyeVwiKTtcbiAgICB2YXIgYWx3YXlzID0gbnVsbDtcbiAgICB2YXIgY2F0Y2hlcyA9IFtdO1xuICAgIHZhciBib2R5ID0gdGhpcy5uZXh0KCkucmVhZF9zdGF0ZW1lbnQoKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMNDU1XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9DQVRDSCkge1xuICAgICAgdmFyIGl0ZW0gPSB0aGlzLm5vZGUoXCJjYXRjaFwiKTtcbiAgICAgIHRoaXMubmV4dCgpLmV4cGVjdChcIihcIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgd2hhdCA9IHRoaXMucmVhZF9saXN0KHRoaXMucmVhZF9uYW1lc3BhY2VfbmFtZSwgXCJ8XCIsIGZhbHNlKTtcbiAgICAgIHZhciB2YXJpYWJsZSA9IHRoaXMucmVhZF92YXJpYWJsZSh0cnVlLCBmYWxzZSk7XG4gICAgICB0aGlzLmV4cGVjdChcIilcIik7XG4gICAgICBjYXRjaGVzLnB1c2goaXRlbSh0aGlzLm5leHQoKS5yZWFkX3N0YXRlbWVudCgpLCB3aGF0LCB2YXJpYWJsZSkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX0ZJTkFMTFkpIHtcbiAgICAgIGFsd2F5cyA9IHRoaXMubmV4dCgpLnJlYWRfc3RhdGVtZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdChib2R5LCBjYXRjaGVzLCBhbHdheXMpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBSZWFkcyBhIHNob3J0IGZvcm0gb2YgdG9rZW5zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b2tlbiAtIFRoZSBlbmRpbmcgdG9rZW5cbiAgICogQHJldHVybiB7QmxvY2t9XG4gICAqL1xuICByZWFkX3Nob3J0X2Zvcm06IGZ1bmN0aW9uIHJlYWRfc2hvcnRfZm9ybSh0b2tlbikge1xuICAgIHZhciBib2R5ID0gdGhpcy5ub2RlKFwiYmxvY2tcIik7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgaWYgKHRoaXMuZXhwZWN0KFwiOlwiKSkgdGhpcy5uZXh0KCk7XG5cbiAgICB3aGlsZSAodGhpcy50b2tlbiAhPSB0aGlzLkVPRiAmJiB0aGlzLnRva2VuICE9PSB0b2tlbikge1xuICAgICAgaXRlbXMucHVzaCh0aGlzLnJlYWRfaW5uZXJfc3RhdGVtZW50KCkpO1xuICAgIH1cblxuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDAgJiYgdGhpcy5leHRyYWN0RG9jICYmIHRoaXMuX2RvY3MubGVuZ3RoID4gdGhpcy5fZG9jSW5kZXgpIHtcbiAgICAgIGl0ZW1zLnB1c2godGhpcy5ub2RlKFwibm9vcFwiKSgpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHBlY3QodG9rZW4pKSB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdEVuZE9mU3RhdGVtZW50KCk7XG4gICAgcmV0dXJuIGJvZHkobnVsbCwgaXRlbXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBodHRwczovL3dpa2kucGhwLm5ldC9yZmMvdHJhaWxpbmctY29tbWEtZnVuY3Rpb24tY2FsbHNcbiAgICogQHBhcmFtIHsqfSBpdGVtXG4gICAqIEBwYXJhbSB7Kn0gc2VwYXJhdG9yXG4gICAqL1xuICByZWFkX2Z1bmN0aW9uX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfZnVuY3Rpb25fbGlzdChpdGVtLCBzZXBhcmF0b3IpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBkbyB7XG4gICAgICBpZiAodGhpcy50b2tlbiA9PSBzZXBhcmF0b3IgJiYgdGhpcy52ZXJzaW9uID49IDcwMyAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLm5vZGUoXCJub29wXCIpKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2goaXRlbS5hcHBseSh0aGlzLCBbXSkpO1xuXG4gICAgICBpZiAodGhpcy50b2tlbiAhPSBzZXBhcmF0b3IpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5leHQoKS50b2tlbiA9PSBcIilcIiAmJiB0aGlzLnZlcnNpb24gPj0gNzAzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRoaXMudG9rZW4gIT0gdGhpcy5FT0YpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIDogcmVhZHMgYSBsaXN0IG9mIHRva2VucyAvIHNhbXBsZSA6IFRfU1RSSU5HICcsJyBUX1NUUklORyAuLi5cbiAgICogYGBgZWJuZlxuICAgKiBsaXN0IDo6PSBzZXBhcmF0b3I/ICggaXRlbSBzZXBhcmF0b3IgKSogaXRlbVxuICAgKiBgYGBcbiAgICovXG4gIHJlYWRfbGlzdDogZnVuY3Rpb24gcmVhZF9saXN0KGl0ZW0sIHNlcGFyYXRvciwgcHJlc2VydmVGaXJzdFNlcGFyYXRvcikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGlmICh0aGlzLnRva2VuID09IHNlcGFyYXRvcikge1xuICAgICAgaWYgKHByZXNlcnZlRmlyc3RTZXBhcmF0b3IpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMubm9kZShcIm5vb3BcIikoKSA6IG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgaXRlbVJlc3VsdCA9IGl0ZW0uYXBwbHkodGhpcywgW10pO1xuXG4gICAgICAgIGlmIChpdGVtUmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbVJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50b2tlbiAhPSBzZXBhcmF0b3IpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAodGhpcy5uZXh0KCkudG9rZW4gIT0gdGhpcy5FT0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5leHBlY3QoaXRlbSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy50ZXh0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodGhpcy5uZXh0KCkudG9rZW4gIT0gdGhpcy5FT0YpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW4gIT0gc2VwYXJhdG9yKSBicmVhazsgLy8gdHJpbSBjdXJyZW50IHNlcGFyYXRvciAmIGNoZWNrIGl0ZW1cblxuICAgICAgICBpZiAodGhpcy5uZXh0KCkudG9rZW4gIT0gaXRlbSkgYnJlYWs7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMudGV4dCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWFkcyBhIGxpc3Qgb2YgbmFtZXMgc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICpcbiAgICogYGBgZWJuZlxuICAgKiBuYW1lX2xpc3QgOjo9IG5hbWVzcGFjZSAoJywnIG5hbWVzcGFjZSkqXG4gICAqIGBgYFxuICAgKlxuICAgKiBTYW1wbGUgY29kZSA6XG4gICAqIGBgYHBocFxuICAgKiA8P3BocCBjbGFzcyBmb28gZXh0ZW5kcyBiYXIsIGJheiB7IH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvbWFzdGVyL1plbmQvemVuZF9sYW5ndWFnZV9wYXJzZXIueSNMNzI2XG4gICAqIEByZXR1cm4ge1JlZmVyZW5jZVtdfVxuICAgKi9cbiAgcmVhZF9uYW1lX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfbmFtZV9saXN0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRfbGlzdCh0aGlzLnJlYWRfbmFtZXNwYWNlX25hbWUsIFwiLFwiLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBieXJlZiB0b2tlbiBhbmQgYXNzaWduIGl0IHRvIHRoZSBzcGVjaWZpZWQgbm9kZVxuICAgKiBAcGFyYW0geyp9IGNiXG4gICAqL1xuICByZWFkX2J5cmVmOiBmdW5jdGlvbiByZWFkX2J5cmVmKGNiKSB7XG4gICAgdmFyIGJ5cmVmID0gdGhpcy5ub2RlKFwiYnlyZWZcIik7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgYnlyZWYgPSBieXJlZihudWxsKTtcbiAgICB2YXIgcmVzdWx0ID0gY2IoKTtcblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRoaXMuYXN0LnN3YXBMb2NhdGlvbnMocmVzdWx0LCBieXJlZiwgcmVzdWx0LCB0aGlzKTtcbiAgICAgIHJlc3VsdC5ieXJlZiA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVhZHMgYSBsaXN0IG9mIHZhcmlhYmxlcyBkZWNsYXJhdGlvbnNcbiAgICpcbiAgICogYGBgZWJuZlxuICAgKiB2YXJpYWJsZV9kZWNsYXJhdGlvbiA6Oj0gVF9WQVJJQUJMRSAoJz0nIGV4cHIpPypcbiAgICogdmFyaWFibGVfZGVjbGFyYXRpb25zIDo6PSB2YXJpYWJsZV9kZWNsYXJhdGlvbiAoJywnIHZhcmlhYmxlX2RlY2xhcmF0aW9uKSpcbiAgICogYGBgXG4gICAqXG4gICAqIFNhbXBsZSBjb2RlIDpcbiAgICogYGBgcGhwXG4gICAqIDw/cGhwIHN0YXRpYyAkYSA9ICdoZWxsbycsICRiID0gJ3dvcmxkJztcbiAgICogYGBgXG4gICAqIEByZXR1cm4ge1N0YXRpY1ZhcmlhYmxlW119IFJldHVybnMgYW4gYXJyYXkgY29tcG9zZWQgYnkgYSBsaXN0IG9mIHZhcmlhYmxlcywgb3JcbiAgICogYXNzaWduIHZhbHVlc1xuICAgKi9cbiAgcmVhZF92YXJpYWJsZV9kZWNsYXJhdGlvbnM6IGZ1bmN0aW9uIHJlYWRfdmFyaWFibGVfZGVjbGFyYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRfbGlzdChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZShcInN0YXRpY3ZhcmlhYmxlXCIpO1xuICAgICAgdmFyIHZhcmlhYmxlID0gdGhpcy5ub2RlKFwidmFyaWFibGVcIik7IC8vIHBsYWluIHZhcmlhYmxlIG5hbWVcblxuICAgICAgaWYgKHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfVkFSSUFCTEUpKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy50ZXh0KCkuc3Vic3RyaW5nKDEpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdmFyaWFibGUgPSB2YXJpYWJsZShuYW1lLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlKFwiI0VSUlwiLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09PSBcIj1cIikge1xuICAgICAgICByZXR1cm4gbm9kZSh2YXJpYWJsZSwgdGhpcy5uZXh0KCkucmVhZF9leHByKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgICAgfVxuICAgIH0sIFwiLFwiKTtcbiAgfSxcblxuICAvKlxuICAgKiBSZWFkcyBjbGFzcyBleHRlbmRzXG4gICAqL1xuICByZWFkX2V4dGVuZHNfZnJvbTogZnVuY3Rpb24gcmVhZF9leHRlbmRzX2Zyb20oKSB7XG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRVhURU5EUykge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dCgpLnJlYWRfbmFtZXNwYWNlX25hbWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKlxuICAgKiBSZWFkcyBpbnRlcmZhY2UgZXh0ZW5kcyBsaXN0XG4gICAqL1xuICByZWFkX2ludGVyZmFjZV9leHRlbmRzX2xpc3Q6IGZ1bmN0aW9uIHJlYWRfaW50ZXJmYWNlX2V4dGVuZHNfbGlzdCgpIHtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9FWFRFTkRTKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0KCkucmVhZF9uYW1lX2xpc3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKlxuICAgKiBSZWFkcyBpbXBsZW1lbnRzIGxpc3RcbiAgICovXG4gIHJlYWRfaW1wbGVtZW50c19saXN0OiBmdW5jdGlvbiByZWFkX2ltcGxlbWVudHNfbGlzdCgpIHtcbiAgICBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9JTVBMRU1FTlRTKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0KCkucmVhZF9uYW1lX2xpc3QoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogUmVhZHMgYSB2YXJpYWJsZVxuICAgKlxuICAgKiBgYGBlYm5mXG4gICAqICAgdmFyaWFibGUgOjo9ICY/IC4uLmNvbXBsZXggQHRvZG9cbiAgICogYGBgXG4gICAqXG4gICAqIFNvbWUgc2FtcGxlcyBvZiBwYXJzZWQgY29kZSA6XG4gICAqIGBgYHBocFxuICAgKiAgJiR2YXIgICAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGxlIHZhclxuICAgKiAgJHZhciAgICAgICAgICAgICAgICAgICAgICAvLyBzaW1wbGUgdmFyXG4gICAqICBjbGFzc25hbWU6OkNPTlNUX05BTUUgICAgIC8vIGR5bmFtaWMgY2xhc3MgbmFtZSB3aXRoIGNvbnN0IHJldHJpZXZhbFxuICAgKiAgZm9vKCkgICAgICAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBjYWxsXG4gICAqICAkdmFyLT5mdW5jKCktPnByb3BlcnR5ICAgIC8vIGNoYWluZWQgY2FsbHNcbiAgICogYGBgXG4gICAqL1xuICByZWFkX3ZhcmlhYmxlOiBmdW5jdGlvbiByZWFkX3ZhcmlhYmxlKHJlYWRfb25seSwgZW5jYXBzZWQpIHtcbiAgICB2YXIgcmVzdWx0OyAvLyBjaGVjayB0aGUgYnlyZWYgZmxhZ1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IFwiJlwiKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkX2J5cmVmKHRoaXMucmVhZF92YXJpYWJsZS5iaW5kKHRoaXMsIHJlYWRfb25seSwgZW5jYXBzZWQpKTtcbiAgICB9IC8vIHJlYWRzIHRoZSBlbnRyeSBwb2ludFxuXG5cbiAgICBpZiAodGhpcy5pcyhbdGhpcy50b2suVF9WQVJJQUJMRSwgXCIkXCJdKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5yZWFkX3JlZmVyZW5jZV92YXJpYWJsZShlbmNhcHNlZCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzKFt0aGlzLnRvay5UX05TX1NFUEFSQVRPUiwgdGhpcy50b2suVF9TVFJJTkcsIHRoaXMudG9rLlRfTkFNRVNQQUNFXSkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMubm9kZSgpO1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLnJlYWRfbmFtZXNwYWNlX25hbWUoKTtcblxuICAgICAgaWYgKHRoaXMudG9rZW4gIT0gdGhpcy50b2suVF9ET1VCTEVfQ09MT04gJiYgdGhpcy50b2tlbiAhPSBcIihcIiAmJiBbXCJwYXJlbnRyZWZlcmVuY2VcIiwgXCJzZWxmcmVmZXJlbmNlXCJdLmluZGV4T2YobmFtZS5raW5kKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gQHNlZSBwYXJzZXIuanMgbGluZSAxMzAgOiByZXNvbHZlcyBhIGNvbmZsaWN0IHdpdGggc2NhbGFyXG4gICAgICAgIHZhciBsaXRlcmFsID0gbmFtZS5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKGxpdGVyYWwgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmFtZS5kZXN0cm95KHJlc3VsdChcImJvb2xlYW5cIiwgdHJ1ZSwgbmFtZS5uYW1lKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGl0ZXJhbCA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmFtZS5kZXN0cm95KHJlc3VsdChcImJvb2xlYW5cIiwgZmFsc2UsIG5hbWUubmFtZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpdGVyYWwgPT09IFwibnVsbFwiKSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmFtZS5kZXN0cm95KHJlc3VsdChcIm51bGxrZXl3b3JkXCIsIG5hbWUubmFtZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5kZXN0cm95KG5hbWUpO1xuICAgICAgICAgIHJlc3VsdCA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEBmaXhtZSBwb3NzaWJsZSAjMTkzIGJ1Z1xuICAgICAgICByZXN1bHQuZGVzdHJveShuYW1lKTtcbiAgICAgICAgcmVzdWx0ID0gbmFtZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RBVElDKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLm5vZGUoXCJzdGF0aWNyZWZlcmVuY2VcIik7XG4gICAgICB2YXIgcmF3ID0gdGhpcy50ZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdChyYXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdChcIlZBUklBQkxFXCIpO1xuICAgIH0gLy8gc3RhdGljIG1vZGVcblxuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfRE9VQkxFX0NPTE9OKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnJlYWRfc3RhdGljX2dldHRlcihyZXN1bHQsIGVuY2Fwc2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVfdmFyaWFibGVfY2hhaW5fc2NhbihyZXN1bHQsIHJlYWRfb25seSwgZW5jYXBzZWQpO1xuICB9LFxuICAvLyByZXNvbHZlcyBhIHN0YXRpYyBjYWxsXG4gIHJlYWRfc3RhdGljX2dldHRlcjogZnVuY3Rpb24gcmVhZF9zdGF0aWNfZ2V0dGVyKHdoYXQsIGVuY2Fwc2VkKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcInN0YXRpY2xvb2t1cFwiKTtcbiAgICB2YXIgb2Zmc2V0LCBuYW1lO1xuXG4gICAgaWYgKHRoaXMubmV4dCgpLmlzKFt0aGlzLnRvay5UX1ZBUklBQkxFLCBcIiRcIl0pKSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLnJlYWRfcmVmZXJlbmNlX3ZhcmlhYmxlKGVuY2Fwc2VkKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RSSU5HIHx8IHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfQ0xBU1MgfHwgdGhpcy52ZXJzaW9uID49IDcwMCAmJiB0aGlzLmlzKFwiSURFTlRJRklFUlwiKSkge1xuICAgICAgb2Zmc2V0ID0gdGhpcy5ub2RlKFwiaWRlbnRpZmllclwiKTtcbiAgICAgIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0KG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gXCJ7XCIpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMubm9kZShcImxpdGVyYWxcIik7XG4gICAgICBuYW1lID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG4gICAgICB0aGlzLmV4cGVjdChcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQoXCJsaXRlcmFsXCIsIG5hbWUsIG51bGwpO1xuICAgICAgdGhpcy5leHBlY3QoXCIoXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVycm9yKFt0aGlzLnRvay5UX1ZBUklBQkxFLCB0aGlzLnRvay5UX1NUUklOR10pOyAvLyBncmFjZWZ1bCBtb2RlIDogc2V0IGdldHRlciBhcyBlcnJvciBub2RlIGFuZCBjb250aW51ZVxuXG4gICAgICBvZmZzZXQgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgbmFtZSA9IHRoaXMudGV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQobmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCh3aGF0LCBvZmZzZXQpO1xuICB9LFxuICByZWFkX3doYXQ6IGZ1bmN0aW9uIHJlYWRfd2hhdCgpIHtcbiAgICB2YXIgaXNfc3RhdGljX2xvb2t1cCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIHdoYXQgPSBudWxsO1xuICAgIHZhciBuYW1lID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGhpcy5uZXh0KCkudG9rZW4pIHtcbiAgICAgIGNhc2UgdGhpcy50b2suVF9TVFJJTkc6XG4gICAgICAgIHdoYXQgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgICBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB3aGF0ID0gd2hhdChuYW1lKTtcblxuICAgICAgICBpZiAoaXNfc3RhdGljX2xvb2t1cCAmJiB0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX09CSkVDVF9PUEVSQVRPUikge1xuICAgICAgICAgIHRoaXMuZXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHRoaXMudG9rLlRfVkFSSUFCTEU6XG4gICAgICAgIHdoYXQgPSB0aGlzLm5vZGUoXCJ2YXJpYWJsZVwiKTtcbiAgICAgICAgbmFtZSA9IHRoaXMudGV4dCgpLnN1YnN0cmluZygxKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHdoYXQgPSB3aGF0KG5hbWUsIGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgIHdoYXQgPSB0aGlzLm5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCkuZXhwZWN0KFtcIiRcIiwgXCJ7XCIsIHRoaXMudG9rLlRfVkFSSUFCTEVdKTtcblxuICAgICAgICBpZiAodGhpcy50b2tlbiA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAvLyAkb2JqLT4keyR2YXJuYW1lfVxuICAgICAgICAgIG5hbWUgPSB0aGlzLm5leHQoKS5yZWFkX2V4cHIoKTtcbiAgICAgICAgICB0aGlzLmV4cGVjdChcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgd2hhdCA9IHdoYXQoXCJ2YXJpYWJsZVwiLCBuYW1lLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAkb2JqLT4kJHZhcm5hbWVcbiAgICAgICAgICBuYW1lID0gdGhpcy5yZWFkX2V4cHIoKTtcbiAgICAgICAgICB3aGF0ID0gd2hhdChcInZhcmlhYmxlXCIsIG5hbWUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwie1wiOlxuICAgICAgICB3aGF0ID0gdGhpcy5ub2RlKFwiZW5jYXBzZWRwYXJ0XCIpO1xuICAgICAgICBuYW1lID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwifVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgd2hhdCA9IHdoYXQobmFtZSwgXCJjb21wbGV4XCIsIGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuZXJyb3IoW3RoaXMudG9rLlRfU1RSSU5HLCB0aGlzLnRvay5UX1ZBUklBQkxFLCBcIiRcIiwgXCJ7XCJdKTsgLy8gZ3JhY2VmdWwgbW9kZSA6IHNldCB3aGF0IGFzIGVycm9yIG1vZGUgJiBjb250aW51ZVxuXG4gICAgICAgIHdoYXQgPSB0aGlzLm5vZGUoXCJpZGVudGlmaWVyXCIpO1xuICAgICAgICBuYW1lID0gdGhpcy50ZXh0KCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB3aGF0ID0gd2hhdChuYW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdoYXQ7XG4gIH0sXG4gIHJlY3Vyc2l2ZV92YXJpYWJsZV9jaGFpbl9zY2FuOiBmdW5jdGlvbiByZWN1cnNpdmVfdmFyaWFibGVfY2hhaW5fc2NhbihyZXN1bHQsIHJlYWRfb25seSwgZW5jYXBzZWQpIHtcbiAgICB2YXIgbm9kZSwgb2Zmc2V0O1xuXG4gICAgcmVjdXJzaXZlX3NjYW5fbG9vcDogd2hpbGUgKHRoaXMudG9rZW4gIT0gdGhpcy5FT0YpIHtcbiAgICAgIHN3aXRjaCAodGhpcy50b2tlbikge1xuICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgIGlmIChyZWFkX29ubHkpIHtcbiAgICAgICAgICAgIC8vIEBmaXhtZSA6IGFkZCBtb3JlIGluZm9ybWF0aW9ucyAmIHRlc3RcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubm9kZShcImNhbGxcIikocmVzdWx0LCB0aGlzLnJlYWRfYXJndW1lbnRfbGlzdCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBiYWNrZXQgPSB0aGlzLnRva2VuO1xuICAgICAgICAgICAgdmFyIGlzU3F1YXJlQnJhY2tldCA9IGJhY2tldCA9PT0gXCJbXCI7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5ub2RlKFwib2Zmc2V0bG9va3VwXCIpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICBvZmZzZXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGVuY2Fwc2VkKSB7XG4gICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMucmVhZF9lbmNhcHNfdmFyX29mZnNldCgpO1xuICAgICAgICAgICAgICB0aGlzLmV4cGVjdChpc1NxdWFyZUJyYWNrZXQgPyBcIl1cIiA6IFwifVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBpc0NhbGxhYmxlVmFyaWFibGUgPSBpc1NxdWFyZUJyYWNrZXQgPyB0aGlzLnRva2VuICE9PSBcIl1cIiA6IHRoaXMudG9rZW4gIT09IFwifVwiOyAvLyBjYWxsYWJsZV92YXJpYWJsZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9waHAvcGhwLXNyYy9ibG9iLzQ5MzUyNDQ1NGQ2NmFkZGU4NGUwMGQyNDlkNjA3ZWNkNTQwZGU5OWYvWmVuZC96ZW5kX2xhbmd1YWdlX3BhcnNlci55I0wxMTIyXG5cbiAgICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGVWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMucmVhZF9leHByKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBlY3QoaXNTcXVhcmVCcmFja2V0ID8gXCJdXCIgOiBcIn1cIikgJiYgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gbm9kZShyZXN1bHQsIG9mZnNldCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSB0aGlzLnRvay5UX0RPVUJMRV9DT0xPTjpcbiAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2lzc3Vlcy8xMDcjaXNzdWVjb21tZW50LTM1NDEwNDU3NFxuICAgICAgICAgIGlmIChyZXN1bHQua2luZCA9PT0gXCJzdGF0aWNsb29rdXBcIiAmJiByZXN1bHQub2Zmc2V0LmtpbmQgPT09IFwiaWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZSA9IHRoaXMubm9kZShcInN0YXRpY2xvb2t1cFwiKTtcbiAgICAgICAgICByZXN1bHQgPSBub2RlKHJlc3VsdCwgdGhpcy5yZWFkX3doYXQodHJ1ZSkpOyAvLyBmaXggMTg1XG4gICAgICAgICAgLy8gc3RhdGljIGxvb2t1cCBkZXJlZmVyZW5jYWJsZXMgYXJlIGxpbWl0ZWQgdG8gc3RhdGljbG9va3VwIG92ZXIgZnVuY3Rpb25zXG5cbiAgICAgICAgICAvKmlmIChkZXJlZmVyZW5jYWJsZSAmJiB0aGlzLnRva2VuICE9PSBcIihcIikge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIihcIik7XG4gICAgICAgICAgfSovXG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRoaXMudG9rLlRfT0JKRUNUX09QRVJBVE9SOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLm5vZGUoXCJwcm9wZXJ0eWxvb2t1cFwiKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUocmVzdWx0LCB0aGlzLnJlYWRfd2hhdCgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrIHJlY3Vyc2l2ZV9zY2FuX2xvb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3BocC9waHAtc3JjL2Jsb2IvNDkzNTI0NDU0ZDY2YWRkZTg0ZTAwZDI0OWQ2MDdlY2Q1NDBkZTk5Zi9aZW5kL3plbmRfbGFuZ3VhZ2VfcGFyc2VyLnkjTDEyMzFcbiAgICovXG4gIHJlYWRfZW5jYXBzX3Zhcl9vZmZzZXQ6IGZ1bmN0aW9uIHJlYWRfZW5jYXBzX3Zhcl9vZmZzZXQoKSB7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMubm9kZSgpO1xuXG4gICAgaWYgKHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfU1RSSU5HKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMudGV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQoXCJpZGVudGlmaWVyXCIsIHRleHQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gdGhpcy50b2suVF9OVU1fU1RSSU5HKSB7XG4gICAgICB2YXIgbnVtID0gdGhpcy50ZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldChcIm51bWJlclwiLCBudW0sIG51bGwpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50b2tlbiA9PT0gXCItXCIpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuXG4gICAgICB2YXIgX251bSA9IC0xICogdGhpcy50ZXh0KCk7XG5cbiAgICAgIHRoaXMuZXhwZWN0KHRoaXMudG9rLlRfTlVNX1NUUklORykgJiYgdGhpcy5uZXh0KCk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQoXCJudW1iZXJcIiwgX251bSwgbnVsbCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRva2VuID09PSB0aGlzLnRvay5UX1ZBUklBQkxFKSB7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMudGV4dCgpLnN1YnN0cmluZygxKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0KFwidmFyaWFibGVcIiwgbmFtZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdChbdGhpcy50b2suVF9TVFJJTkcsIHRoaXMudG9rLlRfTlVNX1NUUklORywgXCItXCIsIHRoaXMudG9rLlRfVkFSSUFCTEVdKTsgLy8gZmFsbGJhY2sgOiBjb25zaWRlciBhcyBpZGVudGlmaWVyXG5cbiAgICAgIHZhciBfdGV4dCA9IHRoaXMudGV4dCgpO1xuXG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldChcImlkZW50aWZpZXJcIiwgX3RleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBgYGVibmZcbiAgICogIHJlZmVyZW5jZV92YXJpYWJsZSA6Oj0gIHNpbXBsZV92YXJpYWJsZSAoJ1snIE9GRlNFVCAnXScpKiB8ICd7JyBFWFBSICd9J1xuICAgKiBgYGBcbiAgICogPGNvZGU+XG4gICAqICAkZm9vWzEyM107ICAgICAgLy8gZm9vIGlzIGFuIGFycmF5ID09PiBnZXRzIGl0cyBlbnRyeVxuICAgKiAgJGZvb3sxfTsgICAgICAgIC8vIGZvbyBpcyBhIHN0cmluZyA9PT4gZ2V0IHRoZSAybmQgY2hhciBvZmZzZXRcbiAgICogICR7J2Zvbyd9WzEyM107ICAvLyBnZXQgdGhlIGR5bmFtaWMgdmFyICRmb29cbiAgICogICRmb29bMTIzXXsxfTsgICAvLyBnZXRzIHRoZSAybmQgY2hhciBmcm9tIHRoZSAxMjMgYXJyYXkgZW50cnlcbiAgICogPC9jb2RlPlxuICAgKi9cbiAgcmVhZF9yZWZlcmVuY2VfdmFyaWFibGU6IGZ1bmN0aW9uIHJlYWRfcmVmZXJlbmNlX3ZhcmlhYmxlKGVuY2Fwc2VkKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucmVhZF9zaW1wbGVfdmFyaWFibGUoKTtcbiAgICB2YXIgb2Zmc2V0O1xuXG4gICAgd2hpbGUgKHRoaXMudG9rZW4gIT0gdGhpcy5FT0YpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG5cbiAgICAgIGlmICh0aGlzLnRva2VuID09IFwie1wiICYmICFlbmNhcHNlZCkge1xuICAgICAgICAvLyBAZml4bWUgY2hlY2sgY292ZXJhZ2UsIG5vdCBzdXJlIHRoYXRzIHdvcmtpbmdcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5uZXh0KCkucmVhZF9leHByKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwifVwiKSAmJiB0aGlzLm5leHQoKTtcbiAgICAgICAgcmVzdWx0ID0gbm9kZShcIm9mZnNldGxvb2t1cFwiLCByZXN1bHQsIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmRlc3Ryb3koKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogYGBgZWJuZlxuICAgKiAgc2ltcGxlX3ZhcmlhYmxlIDo6PSBUX1ZBUklBQkxFIHwgJyQnICd7JyBleHByICd9JyB8ICckJyBzaW1wbGVfdmFyaWFibGVcbiAgICogYGBgXG4gICAqL1xuICByZWFkX3NpbXBsZV92YXJpYWJsZTogZnVuY3Rpb24gcmVhZF9zaW1wbGVfdmFyaWFibGUoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubm9kZShcInZhcmlhYmxlXCIpO1xuICAgIHZhciBuYW1lO1xuXG4gICAgaWYgKHRoaXMuZXhwZWN0KFt0aGlzLnRvay5UX1ZBUklBQkxFLCBcIiRcIl0pICYmIHRoaXMudG9rZW4gPT09IHRoaXMudG9rLlRfVkFSSUFCTEUpIHtcbiAgICAgIC8vIHBsYWluIHZhcmlhYmxlIG5hbWVcbiAgICAgIG5hbWUgPSB0aGlzLnRleHQoKS5zdWJzdHJpbmcoMSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdChuYW1lLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnRva2VuID09PSBcIiRcIikgdGhpcy5uZXh0KCk7IC8vIGR5bmFtaWMgdmFyaWFibGUgbmFtZVxuXG4gICAgICBzd2l0Y2ggKHRoaXMudG9rZW4pIHtcbiAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZXhwciA9IHRoaXMubmV4dCgpLnJlYWRfZXhwcigpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoXCJ9XCIpICYmIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0KGV4cHIsIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgLy8gJCQkdmFyXG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0KHRoaXMucmVhZF9zaW1wbGVfdmFyaWFibGUoKSwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdGhpcy50b2suVF9WQVJJQUJMRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyAkJHZhclxuICAgICAgICAgICAgbmFtZSA9IHRoaXMudGV4dCgpLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKFwidmFyaWFibGVcIik7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdChub2RlKG5hbWUsIGZhbHNlKSwgZmFsc2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5lcnJvcihbXCJ7XCIsIFwiJFwiLCB0aGlzLnRvay5UX1ZBUklBQkxFXSk7IC8vIGdyYWNlZnVsIG1vZGVcblxuICAgICAgICAgIG5hbWUgPSB0aGlzLnRleHQoKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQobmFtZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuLyoqXG4gKiBQSFAgQVNUIFRva2Vuc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdmFsdWVzOiB7XG4gICAgMTAxOiBcIlRfSEFMVF9DT01QSUxFUlwiLFxuICAgIDEwMjogXCJUX1VTRVwiLFxuICAgIDEwMzogXCJUX0VOQ0FQU0VEX0FORF9XSElURVNQQUNFXCIsXG4gICAgMTA0OiBcIlRfT0JKRUNUX09QRVJBVE9SXCIsXG4gICAgMTA1OiBcIlRfU1RSSU5HXCIsXG4gICAgMTA2OiBcIlRfRE9MTEFSX09QRU5fQ1VSTFlfQlJBQ0VTXCIsXG4gICAgMTA3OiBcIlRfU1RSSU5HX1ZBUk5BTUVcIixcbiAgICAxMDg6IFwiVF9DVVJMWV9PUEVOXCIsXG4gICAgMTA5OiBcIlRfTlVNX1NUUklOR1wiLFxuICAgIDExMDogXCJUX0lTU0VUXCIsXG4gICAgMTExOiBcIlRfRU1QVFlcIixcbiAgICAxMTI6IFwiVF9JTkNMVURFXCIsXG4gICAgMTEzOiBcIlRfSU5DTFVERV9PTkNFXCIsXG4gICAgMTE0OiBcIlRfRVZBTFwiLFxuICAgIDExNTogXCJUX1JFUVVJUkVcIixcbiAgICAxMTY6IFwiVF9SRVFVSVJFX09OQ0VcIixcbiAgICAxMTc6IFwiVF9OQU1FU1BBQ0VcIixcbiAgICAxMTg6IFwiVF9OU19TRVBBUkFUT1JcIixcbiAgICAxMTk6IFwiVF9BU1wiLFxuICAgIDEyMDogXCJUX0lGXCIsXG4gICAgMTIxOiBcIlRfRU5ESUZcIixcbiAgICAxMjI6IFwiVF9XSElMRVwiLFxuICAgIDEyMzogXCJUX0RPXCIsXG4gICAgMTI0OiBcIlRfRk9SXCIsXG4gICAgMTI1OiBcIlRfU1dJVENIXCIsXG4gICAgMTI2OiBcIlRfQlJFQUtcIixcbiAgICAxMjc6IFwiVF9DT05USU5VRVwiLFxuICAgIDEyODogXCJUX1JFVFVSTlwiLFxuICAgIDEyOTogXCJUX0dMT0JBTFwiLFxuICAgIDEzMDogXCJUX1NUQVRJQ1wiLFxuICAgIDEzMTogXCJUX0VDSE9cIixcbiAgICAxMzI6IFwiVF9JTkxJTkVfSFRNTFwiLFxuICAgIDEzMzogXCJUX1VOU0VUXCIsXG4gICAgMTM0OiBcIlRfRk9SRUFDSFwiLFxuICAgIDEzNTogXCJUX0RFQ0xBUkVcIixcbiAgICAxMzY6IFwiVF9UUllcIixcbiAgICAxMzc6IFwiVF9USFJPV1wiLFxuICAgIDEzODogXCJUX0dPVE9cIixcbiAgICAxMzk6IFwiVF9GSU5BTExZXCIsXG4gICAgMTQwOiBcIlRfQ0FUQ0hcIixcbiAgICAxNDE6IFwiVF9FTkRERUNMQVJFXCIsXG4gICAgMTQyOiBcIlRfTElTVFwiLFxuICAgIDE0MzogXCJUX0NMT05FXCIsXG4gICAgMTQ0OiBcIlRfUExVU19FUVVBTFwiLFxuICAgIDE0NTogXCJUX01JTlVTX0VRVUFMXCIsXG4gICAgMTQ2OiBcIlRfTVVMX0VRVUFMXCIsXG4gICAgMTQ3OiBcIlRfRElWX0VRVUFMXCIsXG4gICAgMTQ4OiBcIlRfQ09OQ0FUX0VRVUFMXCIsXG4gICAgMTQ5OiBcIlRfTU9EX0VRVUFMXCIsXG4gICAgMTUwOiBcIlRfQU5EX0VRVUFMXCIsXG4gICAgMTUxOiBcIlRfT1JfRVFVQUxcIixcbiAgICAxNTI6IFwiVF9YT1JfRVFVQUxcIixcbiAgICAxNTM6IFwiVF9TTF9FUVVBTFwiLFxuICAgIDE1NDogXCJUX1NSX0VRVUFMXCIsXG4gICAgMTU1OiBcIlRfSU5DXCIsXG4gICAgMTU2OiBcIlRfREVDXCIsXG4gICAgMTU3OiBcIlRfQk9PTEVBTl9PUlwiLFxuICAgIDE1ODogXCJUX0JPT0xFQU5fQU5EXCIsXG4gICAgMTU5OiBcIlRfTE9HSUNBTF9PUlwiLFxuICAgIDE2MDogXCJUX0xPR0lDQUxfQU5EXCIsXG4gICAgMTYxOiBcIlRfTE9HSUNBTF9YT1JcIixcbiAgICAxNjI6IFwiVF9TTFwiLFxuICAgIDE2MzogXCJUX1NSXCIsXG4gICAgMTY0OiBcIlRfSVNfSURFTlRJQ0FMXCIsXG4gICAgMTY1OiBcIlRfSVNfTk9UX0lERU5USUNBTFwiLFxuICAgIDE2NjogXCJUX0lTX0VRVUFMXCIsXG4gICAgMTY3OiBcIlRfSVNfTk9UX0VRVUFMXCIsXG4gICAgMTY4OiBcIlRfSVNfU01BTExFUl9PUl9FUVVBTFwiLFxuICAgIDE2OTogXCJUX0lTX0dSRUFURVJfT1JfRVFVQUxcIixcbiAgICAxNzA6IFwiVF9JTlNUQU5DRU9GXCIsXG4gICAgMTcxOiBcIlRfSU5UX0NBU1RcIixcbiAgICAxNzI6IFwiVF9ET1VCTEVfQ0FTVFwiLFxuICAgIDE3MzogXCJUX1NUUklOR19DQVNUXCIsXG4gICAgMTc0OiBcIlRfQVJSQVlfQ0FTVFwiLFxuICAgIDE3NTogXCJUX09CSkVDVF9DQVNUXCIsXG4gICAgMTc2OiBcIlRfQk9PTF9DQVNUXCIsXG4gICAgMTc3OiBcIlRfVU5TRVRfQ0FTVFwiLFxuICAgIDE3ODogXCJUX0VYSVRcIixcbiAgICAxNzk6IFwiVF9QUklOVFwiLFxuICAgIDE4MDogXCJUX1lJRUxEXCIsXG4gICAgMTgxOiBcIlRfWUlFTERfRlJPTVwiLFxuICAgIDE4MjogXCJUX0ZVTkNUSU9OXCIsXG4gICAgMTgzOiBcIlRfRE9VQkxFX0FSUk9XXCIsXG4gICAgMTg0OiBcIlRfRE9VQkxFX0NPTE9OXCIsXG4gICAgMTg1OiBcIlRfQVJSQVlcIixcbiAgICAxODY6IFwiVF9DQUxMQUJMRVwiLFxuICAgIDE4NzogXCJUX0NMQVNTXCIsXG4gICAgMTg4OiBcIlRfQUJTVFJBQ1RcIixcbiAgICAxODk6IFwiVF9UUkFJVFwiLFxuICAgIDE5MDogXCJUX0ZJTkFMXCIsXG4gICAgMTkxOiBcIlRfRVhURU5EU1wiLFxuICAgIDE5MjogXCJUX0lOVEVSRkFDRVwiLFxuICAgIDE5MzogXCJUX0lNUExFTUVOVFNcIixcbiAgICAxOTQ6IFwiVF9WQVJcIixcbiAgICAxOTU6IFwiVF9QVUJMSUNcIixcbiAgICAxOTY6IFwiVF9QUk9URUNURURcIixcbiAgICAxOTc6IFwiVF9QUklWQVRFXCIsXG4gICAgMTk4OiBcIlRfQ09OU1RcIixcbiAgICAxOTk6IFwiVF9ORVdcIixcbiAgICAyMDA6IFwiVF9JTlNURUFET0ZcIixcbiAgICAyMDE6IFwiVF9FTFNFSUZcIixcbiAgICAyMDI6IFwiVF9FTFNFXCIsXG4gICAgMjAzOiBcIlRfRU5EU1dJVENIXCIsXG4gICAgMjA0OiBcIlRfQ0FTRVwiLFxuICAgIDIwNTogXCJUX0RFRkFVTFRcIixcbiAgICAyMDY6IFwiVF9FTkRGT1JcIixcbiAgICAyMDc6IFwiVF9FTkRGT1JFQUNIXCIsXG4gICAgMjA4OiBcIlRfRU5EV0hJTEVcIixcbiAgICAyMDk6IFwiVF9DT05TVEFOVF9FTkNBUFNFRF9TVFJJTkdcIixcbiAgICAyMTA6IFwiVF9MTlVNQkVSXCIsXG4gICAgMjExOiBcIlRfRE5VTUJFUlwiLFxuICAgIDIxMjogXCJUX0xJTkVcIixcbiAgICAyMTM6IFwiVF9GSUxFXCIsXG4gICAgMjE0OiBcIlRfRElSXCIsXG4gICAgMjE1OiBcIlRfVFJBSVRfQ1wiLFxuICAgIDIxNjogXCJUX01FVEhPRF9DXCIsXG4gICAgMjE3OiBcIlRfRlVOQ19DXCIsXG4gICAgMjE4OiBcIlRfTlNfQ1wiLFxuICAgIDIxOTogXCJUX1NUQVJUX0hFUkVET0NcIixcbiAgICAyMjA6IFwiVF9FTkRfSEVSRURPQ1wiLFxuICAgIDIyMTogXCJUX0NMQVNTX0NcIixcbiAgICAyMjI6IFwiVF9WQVJJQUJMRVwiLFxuICAgIDIyMzogXCJUX09QRU5fVEFHXCIsXG4gICAgMjI0OiBcIlRfT1BFTl9UQUdfV0lUSF9FQ0hPXCIsXG4gICAgMjI1OiBcIlRfQ0xPU0VfVEFHXCIsXG4gICAgMjI2OiBcIlRfV0hJVEVTUEFDRVwiLFxuICAgIDIyNzogXCJUX0NPTU1FTlRcIixcbiAgICAyMjg6IFwiVF9ET0NfQ09NTUVOVFwiLFxuICAgIDIyOTogXCJUX0VMTElQU0lTXCIsXG4gICAgMjMwOiBcIlRfQ09BTEVTQ0VcIixcbiAgICAyMzE6IFwiVF9QT1dcIixcbiAgICAyMzI6IFwiVF9QT1dfRVFVQUxcIixcbiAgICAyMzM6IFwiVF9TUEFDRVNISVBcIixcbiAgICAyMzQ6IFwiVF9DT0FMRVNDRV9FUVVBTFwiLFxuICAgIDIzNTogXCJUX0ZOXCJcbiAgfSxcbiAgbmFtZXM6IHtcbiAgICBUX0hBTFRfQ09NUElMRVI6IDEwMSxcbiAgICBUX1VTRTogMTAyLFxuICAgIFRfRU5DQVBTRURfQU5EX1dISVRFU1BBQ0U6IDEwMyxcbiAgICBUX09CSkVDVF9PUEVSQVRPUjogMTA0LFxuICAgIFRfU1RSSU5HOiAxMDUsXG4gICAgVF9ET0xMQVJfT1BFTl9DVVJMWV9CUkFDRVM6IDEwNixcbiAgICBUX1NUUklOR19WQVJOQU1FOiAxMDcsXG4gICAgVF9DVVJMWV9PUEVOOiAxMDgsXG4gICAgVF9OVU1fU1RSSU5HOiAxMDksXG4gICAgVF9JU1NFVDogMTEwLFxuICAgIFRfRU1QVFk6IDExMSxcbiAgICBUX0lOQ0xVREU6IDExMixcbiAgICBUX0lOQ0xVREVfT05DRTogMTEzLFxuICAgIFRfRVZBTDogMTE0LFxuICAgIFRfUkVRVUlSRTogMTE1LFxuICAgIFRfUkVRVUlSRV9PTkNFOiAxMTYsXG4gICAgVF9OQU1FU1BBQ0U6IDExNyxcbiAgICBUX05TX1NFUEFSQVRPUjogMTE4LFxuICAgIFRfQVM6IDExOSxcbiAgICBUX0lGOiAxMjAsXG4gICAgVF9FTkRJRjogMTIxLFxuICAgIFRfV0hJTEU6IDEyMixcbiAgICBUX0RPOiAxMjMsXG4gICAgVF9GT1I6IDEyNCxcbiAgICBUX1NXSVRDSDogMTI1LFxuICAgIFRfQlJFQUs6IDEyNixcbiAgICBUX0NPTlRJTlVFOiAxMjcsXG4gICAgVF9SRVRVUk46IDEyOCxcbiAgICBUX0dMT0JBTDogMTI5LFxuICAgIFRfU1RBVElDOiAxMzAsXG4gICAgVF9FQ0hPOiAxMzEsXG4gICAgVF9JTkxJTkVfSFRNTDogMTMyLFxuICAgIFRfVU5TRVQ6IDEzMyxcbiAgICBUX0ZPUkVBQ0g6IDEzNCxcbiAgICBUX0RFQ0xBUkU6IDEzNSxcbiAgICBUX1RSWTogMTM2LFxuICAgIFRfVEhST1c6IDEzNyxcbiAgICBUX0dPVE86IDEzOCxcbiAgICBUX0ZJTkFMTFk6IDEzOSxcbiAgICBUX0NBVENIOiAxNDAsXG4gICAgVF9FTkRERUNMQVJFOiAxNDEsXG4gICAgVF9MSVNUOiAxNDIsXG4gICAgVF9DTE9ORTogMTQzLFxuICAgIFRfUExVU19FUVVBTDogMTQ0LFxuICAgIFRfTUlOVVNfRVFVQUw6IDE0NSxcbiAgICBUX01VTF9FUVVBTDogMTQ2LFxuICAgIFRfRElWX0VRVUFMOiAxNDcsXG4gICAgVF9DT05DQVRfRVFVQUw6IDE0OCxcbiAgICBUX01PRF9FUVVBTDogMTQ5LFxuICAgIFRfQU5EX0VRVUFMOiAxNTAsXG4gICAgVF9PUl9FUVVBTDogMTUxLFxuICAgIFRfWE9SX0VRVUFMOiAxNTIsXG4gICAgVF9TTF9FUVVBTDogMTUzLFxuICAgIFRfU1JfRVFVQUw6IDE1NCxcbiAgICBUX0lOQzogMTU1LFxuICAgIFRfREVDOiAxNTYsXG4gICAgVF9CT09MRUFOX09SOiAxNTcsXG4gICAgVF9CT09MRUFOX0FORDogMTU4LFxuICAgIFRfTE9HSUNBTF9PUjogMTU5LFxuICAgIFRfTE9HSUNBTF9BTkQ6IDE2MCxcbiAgICBUX0xPR0lDQUxfWE9SOiAxNjEsXG4gICAgVF9TTDogMTYyLFxuICAgIFRfU1I6IDE2MyxcbiAgICBUX0lTX0lERU5USUNBTDogMTY0LFxuICAgIFRfSVNfTk9UX0lERU5USUNBTDogMTY1LFxuICAgIFRfSVNfRVFVQUw6IDE2NixcbiAgICBUX0lTX05PVF9FUVVBTDogMTY3LFxuICAgIFRfSVNfU01BTExFUl9PUl9FUVVBTDogMTY4LFxuICAgIFRfSVNfR1JFQVRFUl9PUl9FUVVBTDogMTY5LFxuICAgIFRfSU5TVEFOQ0VPRjogMTcwLFxuICAgIFRfSU5UX0NBU1Q6IDE3MSxcbiAgICBUX0RPVUJMRV9DQVNUOiAxNzIsXG4gICAgVF9TVFJJTkdfQ0FTVDogMTczLFxuICAgIFRfQVJSQVlfQ0FTVDogMTc0LFxuICAgIFRfT0JKRUNUX0NBU1Q6IDE3NSxcbiAgICBUX0JPT0xfQ0FTVDogMTc2LFxuICAgIFRfVU5TRVRfQ0FTVDogMTc3LFxuICAgIFRfRVhJVDogMTc4LFxuICAgIFRfUFJJTlQ6IDE3OSxcbiAgICBUX1lJRUxEOiAxODAsXG4gICAgVF9ZSUVMRF9GUk9NOiAxODEsXG4gICAgVF9GVU5DVElPTjogMTgyLFxuICAgIFRfRE9VQkxFX0FSUk9XOiAxODMsXG4gICAgVF9ET1VCTEVfQ09MT046IDE4NCxcbiAgICBUX0FSUkFZOiAxODUsXG4gICAgVF9DQUxMQUJMRTogMTg2LFxuICAgIFRfQ0xBU1M6IDE4NyxcbiAgICBUX0FCU1RSQUNUOiAxODgsXG4gICAgVF9UUkFJVDogMTg5LFxuICAgIFRfRklOQUw6IDE5MCxcbiAgICBUX0VYVEVORFM6IDE5MSxcbiAgICBUX0lOVEVSRkFDRTogMTkyLFxuICAgIFRfSU1QTEVNRU5UUzogMTkzLFxuICAgIFRfVkFSOiAxOTQsXG4gICAgVF9QVUJMSUM6IDE5NSxcbiAgICBUX1BST1RFQ1RFRDogMTk2LFxuICAgIFRfUFJJVkFURTogMTk3LFxuICAgIFRfQ09OU1Q6IDE5OCxcbiAgICBUX05FVzogMTk5LFxuICAgIFRfSU5TVEVBRE9GOiAyMDAsXG4gICAgVF9FTFNFSUY6IDIwMSxcbiAgICBUX0VMU0U6IDIwMixcbiAgICBUX0VORFNXSVRDSDogMjAzLFxuICAgIFRfQ0FTRTogMjA0LFxuICAgIFRfREVGQVVMVDogMjA1LFxuICAgIFRfRU5ERk9SOiAyMDYsXG4gICAgVF9FTkRGT1JFQUNIOiAyMDcsXG4gICAgVF9FTkRXSElMRTogMjA4LFxuICAgIFRfQ09OU1RBTlRfRU5DQVBTRURfU1RSSU5HOiAyMDksXG4gICAgVF9MTlVNQkVSOiAyMTAsXG4gICAgVF9ETlVNQkVSOiAyMTEsXG4gICAgVF9MSU5FOiAyMTIsXG4gICAgVF9GSUxFOiAyMTMsXG4gICAgVF9ESVI6IDIxNCxcbiAgICBUX1RSQUlUX0M6IDIxNSxcbiAgICBUX01FVEhPRF9DOiAyMTYsXG4gICAgVF9GVU5DX0M6IDIxNyxcbiAgICBUX05TX0M6IDIxOCxcbiAgICBUX1NUQVJUX0hFUkVET0M6IDIxOSxcbiAgICBUX0VORF9IRVJFRE9DOiAyMjAsXG4gICAgVF9DTEFTU19DOiAyMjEsXG4gICAgVF9WQVJJQUJMRTogMjIyLFxuICAgIFRfT1BFTl9UQUc6IDIyMyxcbiAgICBUX09QRU5fVEFHX1dJVEhfRUNITzogMjI0LFxuICAgIFRfQ0xPU0VfVEFHOiAyMjUsXG4gICAgVF9XSElURVNQQUNFOiAyMjYsXG4gICAgVF9DT01NRU5UOiAyMjcsXG4gICAgVF9ET0NfQ09NTUVOVDogMjI4LFxuICAgIFRfRUxMSVBTSVM6IDIyOSxcbiAgICBUX0NPQUxFU0NFOiAyMzAsXG4gICAgVF9QT1c6IDIzMSxcbiAgICBUX1BPV19FUVVBTDogMjMyLFxuICAgIFRfU1BBQ0VTSElQOiAyMzMsXG4gICAgVF9DT0FMRVNDRV9FUVVBTDogMjM0LFxuICAgIFRfRk46IDIzNVxuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIExvY2F0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XG5cbnZhciBQb3NpdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xuLyoqXG4gKiAjIyBDbGFzcyBoaWVyYXJjaHlcbiAqXG4gKiAtIFtMb2NhdGlvbl0oI2xvY2F0aW9uKVxuICogLSBbUG9zaXRpb25dKCNwb3NpdGlvbilcbiAqIC0gW05vZGVdKCNub2RlKVxuICogICAtIFtOb29wXSgjbm9vcClcbiAqICAgLSBbTnVsbEtleXdvcmRdKCNudWxsa2V5d29yZClcbiAqICAgLSBbU3RhdGljVmFyaWFibGVdKCNzdGF0aWN2YXJpYWJsZSlcbiAqICAgLSBbRW5jYXBzZWRQYXJ0XSgjZW5jYXBzZWRwYXJ0KVxuICogICAtIFtDb25zdGFudF0oI2NvbnN0YW50KVxuICogICAtIFtJZGVudGlmaWVyXSgjaWRlbnRpZmllcilcbiAqICAgLSBbUmVmZXJlbmNlXSgjcmVmZXJlbmNlKVxuICogICAgIC0gW1R5cGVSZWZlcmVuY2VdKCN0eXBlcmVmZXJlbmNlKVxuICogICAgIC0gW1BhcmVudFJlZmVyZW5jZV0oI3BhcmVudHJlZmVyZW5jZSlcbiAqICAgICAtIFtTdGF0aWNSZWZlcmVuY2VdKCNzdGF0aWNyZWZlcmVuY2UpXG4gKiAgICAgLSBbU2VsZlJlZmVyZW5jZV0oI3NlbGZyZWZlcmVuY2UpXG4gKiAgICAgLSBbTmFtZV0oI25hbWUpXG4gKiAgIC0gW1RyYWl0VXNlXSgjdHJhaXR1c2UpXG4gKiAgIC0gW1RyYWl0QWxpYXNdKCN0cmFpdGFsaWFzKVxuICogICAtIFtUcmFpdFByZWNlZGVuY2VdKCN0cmFpdHByZWNlZGVuY2UpXG4gKiAgIC0gW0NvbW1lbnRdKCNjb21tZW50KVxuICogICAgIC0gW0NvbW1lbnRMaW5lXSgjY29tbWVudGxpbmUpXG4gKiAgICAgLSBbQ29tbWVudEJsb2NrXSgjY29tbWVudGJsb2NrKVxuICogICAtIFtFcnJvcl0oI2Vycm9yKVxuICogICAtIFtFeHByZXNzaW9uXSgjZXhwcmVzc2lvbilcbiAqICAgICAtIFtFbnRyeV0oI2VudHJ5KVxuICogICAgIC0gW0Fycm93RnVuY10oI2Fycm93ZnVuYylcbiAqICAgICAtIFtDbG9zdXJlXSgjY2xvc3VyZSlcbiAqICAgICAtIFtCeVJlZl0oI2J5cmVmKVxuICogICAgIC0gW1NpbGVudF0oI3NpbGVudClcbiAqICAgICAtIFtSZXRJZl0oI3JldGlmKVxuICogICAgIC0gW05ld10oI25ldylcbiAqICAgICAtIFtJbmNsdWRlXSgjaW5jbHVkZSlcbiAqICAgICAtIFtDYWxsXSgjY2FsbClcbiAqICAgICAtIFtFdmFsXSgjZXZhbClcbiAqICAgICAtIFtFeGl0XSgjZXhpdClcbiAqICAgICAtIFtDbG9uZV0oI2Nsb25lKVxuICogICAgIC0gW0Fzc2lnbl0oI2Fzc2lnbilcbiAqICAgICAtIFtBc3NpZ25SZWZdKCNhc3NpZ25yZWYpXG4gKiAgICAgLSBbQXJyYXldKCNhcnJheSlcbiAqICAgICAtIFtMaXN0XSgjbGlzdClcbiAqICAgICAtIFtWYXJpYWJsZV0oI3ZhcmlhYmxlKVxuICogICAgIC0gW1ZhcmlhZGljXSgjdmFyaWFkaWMpXG4gKiAgICAgLSBbWWllbGRdKCN5aWVsZClcbiAqICAgICAtIFtZaWVsZEZyb21dKCN5aWVsZGZyb20pXG4gKiAgICAgLSBbUHJpbnRdKCNwcmludClcbiAqICAgICAtIFtJc3NldF0oI2lzc2V0KVxuICogICAgIC0gW0VtcHR5XSgjZW1wdHkpXG4gKiAgICAgLSBbTG9va3VwXSgjbG9va3VwKVxuICogICAgICAgLSBbUHJvcGVydHlMb29rdXBdKCNwcm9wZXJ0eWxvb2t1cClcbiAqICAgICAgIC0gW1N0YXRpY0xvb2t1cF0oI3N0YXRpY2xvb2t1cClcbiAqICAgICAgIC0gW09mZnNldExvb2t1cF0oI29mZnNldGxvb2t1cClcbiAqICAgICAtIFtPcGVyYXRpb25dKCNvcGVyYXRpb24pXG4gKiAgICAgICAtIFtQcmVdKCNwcmUpXG4gKiAgICAgICAtIFtQb3N0XSgjcG9zdClcbiAqICAgICAgIC0gW0Jpbl0oI2JpbilcbiAqICAgICAgIC0gW1VuYXJ5XSgjdW5hcnkpXG4gKiAgICAgICAtIFtDYXN0XSgjY2FzdClcbiAqICAgICAtIFtMaXRlcmFsXSgjbGl0ZXJhbClcbiAqICAgICAgIC0gW0Jvb2xlYW5dKCNib29sZWFuKVxuICogICAgICAgLSBbU3RyaW5nXSgjc3RyaW5nKVxuICogICAgICAgLSBbTnVtYmVyXSgjbnVtYmVyKVxuICogICAgICAgLSBbSW5saW5lXSgjaW5saW5lKVxuICogICAgICAgLSBbTWFnaWNdKCNtYWdpYylcbiAqICAgICAgIC0gW05vd2RvY10oI25vd2RvYylcbiAqICAgICAgIC0gW0VuY2Fwc2VkXSgjZW5jYXBzZWQpXG4gKiAgIC0gW1N0YXRlbWVudF0oI3N0YXRlbWVudClcbiAqICAgICAtIFtDb25zdGFudFN0YXRlbWVudF0oI2NvbnN0YW50c3RhdGVtZW50KVxuICogICAgICAgLSBbQ2xhc3NDb25zdGFudF0oI2NsYXNzY29uc3RhbnQpXG4gKiAgICAgLSBbUmV0dXJuXSgjcmV0dXJuKVxuICogICAgIC0gW0xhYmVsXSgjbGFiZWwpXG4gKiAgICAgLSBbQ29udGludWVdKCNjb250aW51ZSlcbiAqICAgICAtIFtDYXNlXSgjY2FzZSlcbiAqICAgICAtIFtCcmVha10oI2JyZWFrKVxuICogICAgIC0gW0VjaG9dKCNlY2hvKVxuICogICAgIC0gW1Vuc2V0XSgjdW5zZXQpXG4gKiAgICAgLSBbSGFsdF0oI2hhbHQpXG4gKiAgICAgLSBbRGVjbGFyZV0oI2RlY2xhcmUpXG4gKiAgICAgLSBbR2xvYmFsXSgjZ2xvYmFsKVxuICogICAgIC0gW1N0YXRpY10oI3N0YXRpYylcbiAqICAgICAtIFtJZl0oI2lmKVxuICogICAgIC0gW0RvXSgjZG8pXG4gKiAgICAgLSBbV2hpbGVdKCN3aGlsZSlcbiAqICAgICAtIFtGb3JdKCNmb3IpXG4gKiAgICAgLSBbRm9yZWFjaF0oI2ZvcmVhY2gpXG4gKiAgICAgLSBbU3dpdGNoXSgjc3dpdGNoKVxuICogICAgIC0gW0dvdG9dKCNnb3RvKVxuICogICAgIC0gW1RyeV0oI3RyeSlcbiAqICAgICAtIFtDYXRjaF0oI2NhdGNoKVxuICogICAgIC0gW1Rocm93XSgjdGhyb3cpXG4gKiAgICAgLSBbVXNlR3JvdXBdKCN1c2Vncm91cClcbiAqICAgICAtIFtVc2VJdGVtXSgjdXNlaXRlbSlcbiAqICAgICAtIFtCbG9ja10oI2Jsb2NrKVxuICogICAgICAgLSBbUHJvZ3JhbV0oI3Byb2dyYW0pXG4gKiAgICAgICAtIFtOYW1lc3BhY2VdKCNuYW1lc3BhY2UpXG4gKiAgICAgLSBbUHJvcGVydHlTdGF0ZW1lbnRdKCNwcm9wZXJ0eXN0YXRlbWVudClcbiAqICAgICAtIFtQcm9wZXJ0eV0oI3Byb3BlcnR5KVxuICogICAgIC0gW0RlY2xhcmF0aW9uXSgjZGVjbGFyYXRpb24pXG4gKiAgICAgICAtIFtDbGFzc10oI2NsYXNzKVxuICogICAgICAgLSBbSW50ZXJmYWNlXSgjaW50ZXJmYWNlKVxuICogICAgICAgLSBbVHJhaXRdKCN0cmFpdClcbiAqICAgICAgIC0gW0Z1bmN0aW9uXSgjZnVuY3Rpb24pXG4gKiAgICAgICAgIC0gW01ldGhvZF0oI21ldGhvZClcbiAqICAgICAgIC0gW1BhcmFtZXRlcl0oI3BhcmFtZXRlcilcbiAqIC0tLVxuICovXG5cbi8qKlxuICogVGhlIEFTVCBidWlsZGVyIGNsYXNzXG4gKiBAY29uc3RydWN0b3IgQVNUXG4gKiBAdHV0b3JpYWwgQVNUXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHdpdGhQb3NpdGlvbnMgLSBTaG91bGQgbG9jYXRlIGFueSBub2RlIChieSBkZWZhdWx0IGZhbHNlKVxuICogQHByb3BlcnR5IHtCb29sZWFufSB3aXRoU291cmNlIC0gU2hvdWxkIGV4dHJhY3QgdGhlIG5vZGUgb3JpZ2luYWwgY29kZSAoYnkgZGVmYXVsdCBmYWxzZSlcbiAqL1xuXG5cbnZhciBBU1QgPSBmdW5jdGlvbiBBU1Qod2l0aFBvc2l0aW9ucywgd2l0aFNvdXJjZSkge1xuICB0aGlzLndpdGhQb3NpdGlvbnMgPSB3aXRoUG9zaXRpb25zO1xuICB0aGlzLndpdGhTb3VyY2UgPSB3aXRoU291cmNlO1xufTtcbi8qKlxuICogQ3JlYXRlIGEgcG9zaXRpb24gbm9kZSBmcm9tIHNwZWNpZmllZCBwYXJzZXJcbiAqIGluY2x1ZGluZyBpdCdzIGxleGVyIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7UGFyc2VyfVxuICogQHJldHVybiB7UG9zaXRpb259XG4gKiBAcHJpdmF0ZVxuICovXG5cblxuQVNULnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbihwYXJzZXIubGV4ZXIueXlsbG9jLmZpcnN0X2xpbmUsIHBhcnNlci5sZXhlci55eWxsb2MuZmlyc3RfY29sdW1uLCBwYXJzZXIubGV4ZXIueXlsbG9jLmZpcnN0X29mZnNldCk7XG59OyAvLyBvcGVyYXRvcnMgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHByZWNlZGVuY2VcblxuXG5BU1QucHJlY2VkZW5jZSA9IHt9O1xuW1tcIm9yXCJdLCBbXCJ4b3JcIl0sIFtcImFuZFwiXSwgW1wiPVwiXSwgW1wiP1wiXSwgW1wiPz9cIl0sIFtcInx8XCJdLCBbXCImJlwiXSwgW1wifFwiXSwgW1wiXlwiXSwgW1wiJlwiXSwgW1wiPT1cIiwgXCIhPVwiLCBcIj09PVwiLCBcIiE9PVwiLFxuLyogJzw+JywgKi9cblwiPD0+XCJdLCBbXCI8XCIsIFwiPD1cIiwgXCI+XCIsIFwiPj1cIl0sIFtcIjw8XCIsIFwiPj5cIl0sIFtcIitcIiwgXCItXCIsIFwiLlwiXSwgW1wiKlwiLCBcIi9cIiwgXCIlXCJdLCBbXCIhXCJdLCBbXCJpbnN0YW5jZW9mXCJdLCBbXCJjYXN0XCIsIFwic2lsZW50XCJdLCBbXCIqKlwiXSAvLyBUT0RPOiBbIChhcnJheSlcbi8vIFRPRE86IGNsb25lLCBuZXdcbl0uZm9yRWFjaChmdW5jdGlvbiAobGlzdCwgaW5kZXgpIHtcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgIEFTVC5wcmVjZWRlbmNlW29wZXJhdG9yXSA9IGluZGV4ICsgMTtcbiAgfSk7XG59KTtcblxuQVNULnByb3RvdHlwZS5pc1JpZ2h0QXNzb2NpYXRpdmUgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgcmV0dXJuIG9wZXJhdG9yID09PSBcIioqXCIgfHwgb3BlcmF0b3IgPT09IFwiPz9cIjtcbn07XG4vKipcbiAqIENoYW5nZSBwYXJlbnQgbm9kZSBpbmZvcm1hdGlvbnMgYWZ0ZXIgc3dhcHBpbmcgY2hpbGRzXG4gKi9cblxuXG5BU1QucHJvdG90eXBlLnN3YXBMb2NhdGlvbnMgPSBmdW5jdGlvbiAodGFyZ2V0LCBmaXJzdCwgbGFzdCwgcGFyc2VyKSB7XG4gIGlmICh0aGlzLndpdGhQb3NpdGlvbnMpIHtcbiAgICB0YXJnZXQubG9jLnN0YXJ0ID0gZmlyc3QubG9jLnN0YXJ0O1xuICAgIHRhcmdldC5sb2MuZW5kID0gbGFzdC5sb2MuZW5kO1xuXG4gICAgaWYgKHRoaXMud2l0aFNvdXJjZSkge1xuICAgICAgdGFyZ2V0LmxvYy5zb3VyY2UgPSBwYXJzZXIubGV4ZXIuX2lucHV0LnN1YnN0cmluZyh0YXJnZXQubG9jLnN0YXJ0Lm9mZnNldCwgdGFyZ2V0LmxvYy5lbmQub2Zmc2V0KTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEluY2x1ZGVzIGxvY2F0aW9ucyBmcm9tIGZpcnN0ICYgbGFzdCBpbnRvIHRoZSB0YXJnZXRcbiAqL1xuXG5cbkFTVC5wcm90b3R5cGUucmVzb2x2ZUxvY2F0aW9ucyA9IGZ1bmN0aW9uICh0YXJnZXQsIGZpcnN0LCBsYXN0LCBwYXJzZXIpIHtcbiAgaWYgKHRoaXMud2l0aFBvc2l0aW9ucykge1xuICAgIGlmICh0YXJnZXQubG9jLnN0YXJ0Lm9mZnNldCA+IGZpcnN0LmxvYy5zdGFydC5vZmZzZXQpIHtcbiAgICAgIHRhcmdldC5sb2Muc3RhcnQgPSBmaXJzdC5sb2Muc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5sb2MuZW5kLm9mZnNldCA8IGxhc3QubG9jLmVuZC5vZmZzZXQpIHtcbiAgICAgIHRhcmdldC5sb2MuZW5kID0gbGFzdC5sb2MuZW5kO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpdGhTb3VyY2UpIHtcbiAgICAgIHRhcmdldC5sb2Muc291cmNlID0gcGFyc2VyLmxleGVyLl9pbnB1dC5zdWJzdHJpbmcodGFyZ2V0LmxvYy5zdGFydC5vZmZzZXQsIHRhcmdldC5sb2MuZW5kLm9mZnNldCk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBDaGVjayBhbmQgZml4IHByZWNlbmNlLCBieSBkZWZhdWx0IHVzaW5nIHJpZ2h0XG4gKi9cblxuXG5BU1QucHJvdG90eXBlLnJlc29sdmVQcmVjZWRlbmNlID0gZnVuY3Rpb24gKHJlc3VsdCwgcGFyc2VyKSB7XG4gIHZhciBidWZmZXIsIGxMZXZlbCwgckxldmVsOyAvLyBoYW5kbGluZyBwcmVjZW5kZW5jZVxuXG4gIGlmIChyZXN1bHQua2luZCA9PT0gXCJjYWxsXCIpIHtcbiAgICAvLyBpbmNsdWRpbmcgd2hhdCBhcmd1bWVudCBpbnRvIGxvY2F0aW9uXG4gICAgdGhpcy5yZXNvbHZlTG9jYXRpb25zKHJlc3VsdCwgcmVzdWx0LndoYXQsIHJlc3VsdCwgcGFyc2VyKTtcbiAgfSBlbHNlIGlmIChyZXN1bHQua2luZCA9PT0gXCJwcm9wZXJ0eWxvb2t1cFwiIHx8IHJlc3VsdC5raW5kID09PSBcInN0YXRpY2xvb2t1cFwiIHx8IHJlc3VsdC5raW5kID09PSBcIm9mZnNldGxvb2t1cFwiICYmIHJlc3VsdC5vZmZzZXQpIHtcbiAgICAvLyBpbmNsdWRpbmcgd2hhdCBhcmd1bWVudCBpbnRvIGxvY2F0aW9uXG4gICAgdGhpcy5yZXNvbHZlTG9jYXRpb25zKHJlc3VsdCwgcmVzdWx0LndoYXQsIHJlc3VsdC5vZmZzZXQsIHBhcnNlcik7XG4gIH0gZWxzZSBpZiAocmVzdWx0LmtpbmQgPT09IFwiYmluXCIpIHtcbiAgICBpZiAocmVzdWx0LnJpZ2h0ICYmICFyZXN1bHQucmlnaHQucGFyZW50aGVzaXplZEV4cHJlc3Npb24pIHtcbiAgICAgIGlmIChyZXN1bHQucmlnaHQua2luZCA9PT0gXCJiaW5cIikge1xuICAgICAgICBsTGV2ZWwgPSBBU1QucHJlY2VkZW5jZVtyZXN1bHQudHlwZV07XG4gICAgICAgIHJMZXZlbCA9IEFTVC5wcmVjZWRlbmNlW3Jlc3VsdC5yaWdodC50eXBlXTtcblxuICAgICAgICBpZiAobExldmVsICYmIHJMZXZlbCAmJiByTGV2ZWwgPD0gbExldmVsICYmICF0aGlzLmlzUmlnaHRBc3NvY2lhdGl2ZShyZXN1bHQudHlwZSkpIHtcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9pc3N1ZXMvNzlcbiAgICAgICAgICAvLyBzaGlmdCBwcmVjZWRlbmNlXG4gICAgICAgICAgYnVmZmVyID0gcmVzdWx0LnJpZ2h0O1xuICAgICAgICAgIHJlc3VsdC5yaWdodCA9IHJlc3VsdC5yaWdodC5sZWZ0O1xuICAgICAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdC5sZWZ0LCByZXN1bHQucmlnaHQsIHBhcnNlcik7XG4gICAgICAgICAgYnVmZmVyLmxlZnQgPSB0aGlzLnJlc29sdmVQcmVjZWRlbmNlKHJlc3VsdCwgcGFyc2VyKTtcbiAgICAgICAgICB0aGlzLnN3YXBMb2NhdGlvbnMoYnVmZmVyLCBidWZmZXIubGVmdCwgYnVmZmVyLnJpZ2h0LCBwYXJzZXIpO1xuICAgICAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXN1bHQucmlnaHQua2luZCA9PT0gXCJyZXRpZlwiKSB7XG4gICAgICAgIGxMZXZlbCA9IEFTVC5wcmVjZWRlbmNlW3Jlc3VsdC50eXBlXTtcbiAgICAgICAgckxldmVsID0gQVNULnByZWNlZGVuY2VbXCI/XCJdO1xuXG4gICAgICAgIGlmIChsTGV2ZWwgJiYgckxldmVsICYmIHJMZXZlbCA8PSBsTGV2ZWwpIHtcbiAgICAgICAgICBidWZmZXIgPSByZXN1bHQucmlnaHQ7XG4gICAgICAgICAgcmVzdWx0LnJpZ2h0ID0gcmVzdWx0LnJpZ2h0LnRlc3Q7XG4gICAgICAgICAgdGhpcy5zd2FwTG9jYXRpb25zKHJlc3VsdCwgcmVzdWx0LmxlZnQsIHJlc3VsdC5yaWdodCwgcGFyc2VyKTtcbiAgICAgICAgICBidWZmZXIudGVzdCA9IHRoaXMucmVzb2x2ZVByZWNlZGVuY2UocmVzdWx0LCBwYXJzZXIpO1xuICAgICAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhidWZmZXIsIGJ1ZmZlci50ZXN0LCBidWZmZXIuZmFsc2VFeHByLCBwYXJzZXIpO1xuICAgICAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICgocmVzdWx0LmtpbmQgPT09IFwic2lsZW50XCIgfHwgcmVzdWx0LmtpbmQgPT09IFwiY2FzdFwiKSAmJiByZXN1bHQuZXhwciAmJiAhcmVzdWx0LmV4cHIucGFyZW50aGVzaXplZEV4cHJlc3Npb24pIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9pc3N1ZXMvMTcyXG4gICAgaWYgKHJlc3VsdC5leHByLmtpbmQgPT09IFwiYmluXCIpIHtcbiAgICAgIGJ1ZmZlciA9IHJlc3VsdC5leHByO1xuICAgICAgcmVzdWx0LmV4cHIgPSByZXN1bHQuZXhwci5sZWZ0O1xuICAgICAgdGhpcy5zd2FwTG9jYXRpb25zKHJlc3VsdCwgcmVzdWx0LCByZXN1bHQuZXhwciwgcGFyc2VyKTtcbiAgICAgIGJ1ZmZlci5sZWZ0ID0gdGhpcy5yZXNvbHZlUHJlY2VkZW5jZShyZXN1bHQsIHBhcnNlcik7XG4gICAgICB0aGlzLnN3YXBMb2NhdGlvbnMoYnVmZmVyLCBidWZmZXIubGVmdCwgYnVmZmVyLnJpZ2h0LCBwYXJzZXIpO1xuICAgICAgcmVzdWx0ID0gYnVmZmVyO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LmV4cHIua2luZCA9PT0gXCJyZXRpZlwiKSB7XG4gICAgICBidWZmZXIgPSByZXN1bHQuZXhwcjtcbiAgICAgIHJlc3VsdC5leHByID0gcmVzdWx0LmV4cHIudGVzdDtcbiAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdCwgcmVzdWx0LmV4cHIsIHBhcnNlcik7XG4gICAgICBidWZmZXIudGVzdCA9IHRoaXMucmVzb2x2ZVByZWNlZGVuY2UocmVzdWx0LCBwYXJzZXIpO1xuICAgICAgdGhpcy5zd2FwTG9jYXRpb25zKGJ1ZmZlciwgYnVmZmVyLnRlc3QsIGJ1ZmZlci5mYWxzZUV4cHIsIHBhcnNlcik7XG4gICAgICByZXN1bHQgPSBidWZmZXI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlc3VsdC5raW5kID09PSBcInVuYXJ5XCIpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9pc3N1ZXMvNzVcbiAgICBpZiAocmVzdWx0LndoYXQgJiYgIXJlc3VsdC53aGF0LnBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKSB7XG4gICAgICAvLyB1bmFyeSBwcmVjZWRlbmNlIGlzIGFsbHdheXMgbG93ZXJcbiAgICAgIGlmIChyZXN1bHQud2hhdC5raW5kID09PSBcImJpblwiKSB7XG4gICAgICAgIGJ1ZmZlciA9IHJlc3VsdC53aGF0O1xuICAgICAgICByZXN1bHQud2hhdCA9IHJlc3VsdC53aGF0LmxlZnQ7XG4gICAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdCwgcmVzdWx0LndoYXQsIHBhcnNlcik7XG4gICAgICAgIGJ1ZmZlci5sZWZ0ID0gdGhpcy5yZXNvbHZlUHJlY2VkZW5jZShyZXN1bHQsIHBhcnNlcik7XG4gICAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhidWZmZXIsIGJ1ZmZlci5sZWZ0LCBidWZmZXIucmlnaHQsIHBhcnNlcik7XG4gICAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0LndoYXQua2luZCA9PT0gXCJyZXRpZlwiKSB7XG4gICAgICAgIGJ1ZmZlciA9IHJlc3VsdC53aGF0O1xuICAgICAgICByZXN1bHQud2hhdCA9IHJlc3VsdC53aGF0LnRlc3Q7XG4gICAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdCwgcmVzdWx0LndoYXQsIHBhcnNlcik7XG4gICAgICAgIGJ1ZmZlci50ZXN0ID0gdGhpcy5yZXNvbHZlUHJlY2VkZW5jZShyZXN1bHQsIHBhcnNlcik7XG4gICAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhidWZmZXIsIGJ1ZmZlci50ZXN0LCBidWZmZXIuZmFsc2VFeHByLCBwYXJzZXIpO1xuICAgICAgICByZXN1bHQgPSBidWZmZXI7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlc3VsdC5raW5kID09PSBcInJldGlmXCIpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9pc3N1ZXMvNzdcbiAgICBpZiAocmVzdWx0LmZhbHNlRXhwciAmJiByZXN1bHQuZmFsc2VFeHByLmtpbmQgPT09IFwicmV0aWZcIiAmJiAhcmVzdWx0LmZhbHNlRXhwci5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbikge1xuICAgICAgYnVmZmVyID0gcmVzdWx0LmZhbHNlRXhwcjtcbiAgICAgIHJlc3VsdC5mYWxzZUV4cHIgPSBidWZmZXIudGVzdDtcbiAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhyZXN1bHQsIHJlc3VsdC50ZXN0LCByZXN1bHQuZmFsc2VFeHByLCBwYXJzZXIpO1xuICAgICAgYnVmZmVyLnRlc3QgPSB0aGlzLnJlc29sdmVQcmVjZWRlbmNlKHJlc3VsdCwgcGFyc2VyKTtcbiAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhidWZmZXIsIGJ1ZmZlci50ZXN0LCBidWZmZXIuZmFsc2VFeHByLCBwYXJzZXIpO1xuICAgICAgcmVzdWx0ID0gYnVmZmVyO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZXN1bHQua2luZCA9PT0gXCJhc3NpZ25cIikge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2lzc3Vlcy84MVxuICAgIGlmIChyZXN1bHQucmlnaHQgJiYgcmVzdWx0LnJpZ2h0LmtpbmQgPT09IFwiYmluXCIgJiYgIXJlc3VsdC5yaWdodC5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbikge1xuICAgICAgbExldmVsID0gQVNULnByZWNlZGVuY2VbXCI9XCJdO1xuICAgICAgckxldmVsID0gQVNULnByZWNlZGVuY2VbcmVzdWx0LnJpZ2h0LnR5cGVdOyAvLyBvbmx5IHNoaWZ0cyB3aXRoIGFuZCwgeG9yLCBvclxuXG4gICAgICBpZiAobExldmVsICYmIHJMZXZlbCAmJiByTGV2ZWwgPCBsTGV2ZWwpIHtcbiAgICAgICAgYnVmZmVyID0gcmVzdWx0LnJpZ2h0O1xuICAgICAgICByZXN1bHQucmlnaHQgPSByZXN1bHQucmlnaHQubGVmdDtcbiAgICAgICAgYnVmZmVyLmxlZnQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuc3dhcExvY2F0aW9ucyhidWZmZXIsIGJ1ZmZlci5sZWZ0LCByZXN1bHQucmlnaHQsIHBhcnNlcik7XG4gICAgICAgIHJlc3VsdCA9IGJ1ZmZlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAocmVzdWx0LmtpbmQgPT09IFwiZXhwcmVzc2lvbnN0YXRlbWVudFwiKSB7XG4gICAgdGhpcy5zd2FwTG9jYXRpb25zKHJlc3VsdCwgcmVzdWx0LmV4cHJlc3Npb24sIHJlc3VsdCwgcGFyc2VyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBQcmVwYXJlcyBhbiBBU1Qgbm9kZVxuICogQHBhcmFtIHtTdHJpbmd8bnVsbH0ga2luZCAtIERlZmluZXMgdGhlIG5vZGUgdHlwZVxuICogKGlmIG51bGwsIHRoZSBraW5kIG11c3QgYmUgcGFzc2VkIGF0IHRoZSBmdW5jdGlvbiBjYWxsKVxuICogQHBhcmFtIHtQYXJzZXJ9IHBhcnNlciAtIFRoZSBwYXJzZXIgaW5zdGFuY2UgKHVzZSBmb3IgZXh0cmFjdGluZyBsb2NhdGlvbnMpXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbkFTVC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uIChraW5kLCBkb2NzLCBwYXJzZXIpIHtcbiAgdmFyIHN0YXJ0ID0gbnVsbDtcblxuICBpZiAodGhpcy53aXRoUG9zaXRpb25zIHx8IHRoaXMud2l0aFNvdXJjZSkge1xuICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbihwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzOyAvLyByZXR1cm5zIHRoZSBub2RlXG5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uIHJlc3VsdCgpIHtcbiAgICB2YXIgbG9jYXRpb24gPSBudWxsO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBhcmdzLnB1c2goZG9jcyk7XG5cbiAgICBpZiAoc2VsZi53aXRoUG9zaXRpb25zIHx8IHNlbGYud2l0aFNvdXJjZSkge1xuICAgICAgdmFyIHNyYyA9IG51bGw7XG5cbiAgICAgIGlmIChzZWxmLndpdGhTb3VyY2UpIHtcbiAgICAgICAgc3JjID0gcGFyc2VyLmxleGVyLl9pbnB1dC5zdWJzdHJpbmcoc3RhcnQub2Zmc2V0LCBwYXJzZXIucHJldlsyXSk7XG4gICAgICB9IC8vIGlmIHdpdGggc291cmNlLCBuZWVkIGxvY2F0aW9uIG9uIHN3YXBMb2NhdGlvbnMgZnVuY3Rpb25cblxuXG4gICAgICBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbihzcmMsIHN0YXJ0LCBuZXcgUG9zaXRpb24ocGFyc2VyLnByZXZbMF0sIHBhcnNlci5wcmV2WzFdLCBwYXJzZXIucHJldlsyXSkpOyAvLyBsYXN0IGFyZ3VtZW50IGlzIGFsbHdheXMgdGhlIGxvY2F0aW9uXG5cbiAgICAgIGFyZ3MucHVzaChsb2NhdGlvbik7XG4gICAgfSAvLyBoYW5kbGUgbGF6eSBraW5kIGRlZmluaXRpb25zXG5cblxuICAgIGlmICgha2luZCkge1xuICAgICAga2luZCA9IGFyZ3Muc2hpZnQoKTtcbiAgICB9IC8vIGJ1aWxkIHRoZSBvYmplY3RcblxuXG4gICAgdmFyIG5vZGUgPSBzZWxmW2tpbmRdO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5kZWZpbmVkIG5vZGUgXCInICsga2luZCArICdcIicpO1xuICAgIH1cblxuICAgIHZhciBhc3ROb2RlID0gT2JqZWN0LmNyZWF0ZShub2RlLnByb3RvdHlwZSk7XG4gICAgbm9kZS5hcHBseShhc3ROb2RlLCBhcmdzKTtcbiAgICByZXN1bHQuaW5zdGFuY2UgPSBhc3ROb2RlO1xuXG4gICAgaWYgKHJlc3VsdC50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAvLyBidWZmZXIgb2YgdHJhaWxpbmdDb21tZW50c1xuICAgICAgYXN0Tm9kZS50cmFpbGluZ0NvbW1lbnRzID0gcmVzdWx0LnRyYWlsaW5nQ29tbWVudHM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZXN1bHQucG9zdEJ1aWxkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJlc3VsdC5wb3N0QnVpbGQoYXN0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5kZWJ1Zykge1xuICAgICAgZGVsZXRlIEFTVC5zdGFja1tyZXN1bHQuc3RhY2tVaWRdO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLnJlc29sdmVQcmVjZWRlbmNlKGFzdE5vZGUsIHBhcnNlcik7XG4gIH07XG5cbiAgaWYgKHBhcnNlci5kZWJ1Zykge1xuICAgIGlmICghQVNULnN0YWNrKSB7XG4gICAgICBBU1Quc3RhY2sgPSB7fTtcbiAgICAgIEFTVC5zdGFja1VpZCA9IDE7XG4gICAgfVxuXG4gICAgQVNULnN0YWNrWysrQVNULnN0YWNrVWlkXSA9IHtcbiAgICAgIHBvc2l0aW9uOiBzdGFydCxcbiAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgzLCA1KVxuICAgIH07XG4gICAgcmVzdWx0LnN0YWNrVWlkID0gQVNULnN0YWNrVWlkO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbGlzdCBvZiB0cmFpbGluZyBjb21tZW50c1xuICAgKiBAcGFyYW0geyp9IGRvY3NcbiAgICovXG5cblxuICByZXN1bHQuc2V0VHJhaWxpbmdDb21tZW50cyA9IGZ1bmN0aW9uIChkb2NzKSB7XG4gICAgaWYgKHJlc3VsdC5pbnN0YW5jZSkge1xuICAgICAgLy8gYWxyZWFkeSBjcmVhdGVkXG4gICAgICByZXN1bHQuaW5zdGFuY2Uuc2V0VHJhaWxpbmdDb21tZW50cyhkb2NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnRyYWlsaW5nQ29tbWVudHMgPSBkb2NzO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIFJlbGVhc2UgYSBub2RlIHdpdGhvdXQgdXNpbmcgaXQgb24gdGhlIEFTVFxuICAgKi9cblxuXG4gIHJlc3VsdC5kZXN0cm95ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGlmIChkb2NzKSB7XG4gICAgICAvLyByZWxlYXNlIGN1cnJlbnQgZG9jcyBzdGFja1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBpZiAoIXRhcmdldC5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICB0YXJnZXQubGVhZGluZ0NvbW1lbnRzID0gZG9jcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQubGVhZGluZ0NvbW1lbnRzID0gZG9jcy5jb25jYXQodGFyZ2V0LmxlYWRpbmdDb21tZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlci5fZG9jSW5kZXggPSBwYXJzZXIuX2RvY3MubGVuZ3RoIC0gZG9jcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcnNlci5kZWJ1Zykge1xuICAgICAgZGVsZXRlIEFTVC5zdGFja1tyZXN1bHQuc3RhY2tVaWRdO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuQVNULnByb3RvdHlwZS5jaGVja05vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXJyb3JzID0gW107XG5cbiAgZm9yICh2YXIgayBpbiBBU1Quc3RhY2spIHtcbiAgICBpZiAoQVNULnN0YWNrLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICBlcnJvcnMucHVzaChBU1Quc3RhY2tba10pO1xuICAgIH1cbiAgfVxuXG4gIEFTVC5zdGFjayA9IHt9O1xuICByZXR1cm4gZXJyb3JzO1xufTsgLy8gRGVmaW5lIGFsbCBBU1Qgbm9kZXNcblxuXG5bX193ZWJwYWNrX3JlcXVpcmVfXyg0MyksIF9fd2VicGFja19yZXF1aXJlX18oNDQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NiksIF9fd2VicGFja19yZXF1aXJlX18oNDcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0OSksIF9fd2VicGFja19yZXF1aXJlX18oNTApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1MiksIF9fd2VicGFja19yZXF1aXJlX18oNTMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1NSksIF9fd2VicGFja19yZXF1aXJlX18oNTYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1OCksIF9fd2VicGFja19yZXF1aXJlX18oOSksIF9fd2VicGFja19yZXF1aXJlX18oNTkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2MSksIF9fd2VicGFja19yZXF1aXJlX18oMTApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg1KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2MyksIF9fd2VicGFja19yZXF1aXJlX18oNjQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2NiksIF9fd2VicGFja19yZXF1aXJlX18oNjcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2OSksIF9fd2VicGFja19yZXF1aXJlX18oNzApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3MiksIF9fd2VicGFja19yZXF1aXJlX18oNzMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3NSksIF9fd2VicGFja19yZXF1aXJlX18oNzYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3NyksIF9fd2VicGFja19yZXF1aXJlX18oNzgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4MCksIF9fd2VicGFja19yZXF1aXJlX18oODEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgyKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4MyksIF9fd2VicGFja19yZXF1aXJlX18oODQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4NiksIF9fd2VicGFja19yZXF1aXJlX18oODcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4OSksIF9fd2VicGFja19yZXF1aXJlX18oOTApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg5MiksIF9fd2VicGFja19yZXF1aXJlX18oMiksIF9fd2VicGFja19yZXF1aXJlX18oOTMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg5NSksIF9fd2VicGFja19yZXF1aXJlX18oOTYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg5OCksIF9fd2VicGFja19yZXF1aXJlX18oOTkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCksIF9fd2VicGFja19yZXF1aXJlX18oMTAxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMyksIF9fd2VicGFja19yZXF1aXJlX18oMTA0KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNiksIF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oMTA3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMDgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSksIF9fd2VicGFja19yZXF1aXJlX18oMTEwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMiksIF9fd2VicGFja19yZXF1aXJlX18oMTEzKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNSksIF9fd2VicGFja19yZXF1aXJlX18oMTE2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMTcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExOCksIF9fd2VicGFja19yZXF1aXJlX18oMTE5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMSksIF9fd2VicGFja19yZXF1aXJlX18oMTIyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjMpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNCksIF9fd2VicGFja19yZXF1aXJlX18oMTI1KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyNyksIF9fd2VicGFja19yZXF1aXJlX18oMTI4KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMjkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMCksIF9fd2VicGFja19yZXF1aXJlX18oMTMxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMzIpXS5mb3JFYWNoKGZ1bmN0aW9uIChjdG9yKSB7XG4gIEFTVC5wcm90b3R5cGVbY3Rvci5raW5kXSA9IGN0b3I7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gQVNUO1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cbi8qKlxuICogRGVmaW5lcyB0aGUgbG9jYXRpb24gb2YgdGhlIG5vZGUgKHdpdGggaXQncyBzb3VyY2UgY29udGVudHMgYXMgc3RyaW5nKVxuICogQGNvbnN0cnVjdG9yIExvY2F0aW9uXG4gKiBAcHJvcGVydHkge1N0cmluZ3xudWxsfSBzb3VyY2VcbiAqIEBwcm9wZXJ0eSB7UG9zaXRpb259IHN0YXJ0XG4gKiBAcHJvcGVydHkge1Bvc2l0aW9ufSBlbmRcbiAqL1xuXG52YXIgTG9jYXRpb24gPSBmdW5jdGlvbiBMb2NhdGlvbihzb3VyY2UsIHN0YXJ0LCBlbmQpIHtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5lbmQgPSBlbmQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2F0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cbi8qKlxuICogRWFjaCBQb3NpdGlvbiBvYmplY3QgY29uc2lzdHMgb2YgYSBsaW5lIG51bWJlciAoMS1pbmRleGVkKSBhbmQgYSBjb2x1bW4gbnVtYmVyICgwLWluZGV4ZWQpOlxuICogQGNvbnN0cnVjdG9yIFBvc2l0aW9uXG4gKiBAcHJvcGVydHkge051bWJlcn0gbGluZVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbHVtblxuICogQHByb3BlcnR5IHtOdW1iZXJ9IG9mZnNldFxuICovXG5cbnZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbHVtbiwgb2Zmc2V0KSB7XG4gIHRoaXMubGluZSA9IGxpbmU7XG4gIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9zaXRpb247XG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwciA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJhcnJheVwiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGFycmF5IHN0cnVjdHVyZVxuICogQGNvbnN0cnVjdG9yIEFycmF5XG4gKiBAZXhhbXBsZVxuICogLy8gUEhQIGNvZGUgOlxuICogWzEsICdmb28nID0+ICdiYXInLCAzXVxuICpcbiAqIC8vIEFTVCBzdHJ1Y3R1cmUgOlxuICoge1xuICogIFwia2luZFwiOiBcImFycmF5XCIsXG4gKiAgXCJzaG9ydEZvcm1cIjogdHJ1ZVxuICogIFwiaXRlbXNcIjogW1xuICogICAge1wia2luZFwiOiBcIm51bWJlclwiLCBcInZhbHVlXCI6IFwiMVwifSxcbiAqICAgIHtcbiAqICAgICAgXCJraW5kXCI6IFwiZW50cnlcIixcbiAqICAgICAgXCJrZXlcIjoge1wia2luZFwiOiBcInN0cmluZ1wiLCBcInZhbHVlXCI6IFwiZm9vXCIsIFwiaXNEb3VibGVRdW90ZVwiOiBmYWxzZX0sXG4gKiAgICAgIFwidmFsdWVcIjoge1wia2luZFwiOiBcInN0cmluZ1wiLCBcInZhbHVlXCI6IFwiYmFyXCIsIFwiaXNEb3VibGVRdW90ZVwiOiBmYWxzZX1cbiAqICAgIH0sXG4gKiAgICB7XCJraW5kXCI6IFwibnVtYmVyXCIsIFwidmFsdWVcIjogXCIzXCJ9XG4gKiAgXVxuICogfVxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0VudHJ5fEV4cHJ8VmFyaWFibGV9IGl0ZW1zIExpc3Qgb2YgYXJyYXkgaXRlbXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvcnRGb3JtIEluZGljYXRlIGlmIHRoZSBzaG9ydCBhcnJheSBzeW50YXggaXMgdXNlZCwgZXggYFtdYCBpbnN0ZWFkIGBhcnJheSgpYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQXJyYXkoc2hvcnRGb3JtLCBpdGVtcywgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwci5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICB0aGlzLnNob3J0Rm9ybSA9IHNob3J0Rm9ybTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiYXJyb3dmdW5jXCI7XG4vKipcbiAqIERlZmluZXMgYW4gYXJyb3cgZnVuY3Rpb24gKGl0J3MgbGlrZSBhIGNsb3N1cmUpXG4gKiBAY29uc3RydWN0b3IgQXJyb3dGdW5jXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7UGFyYW1ldGVyW119IGFyZ3VtZW50c1xuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfSB0eXBlXG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IGJvZHlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYnlyZWZcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbnVsbGFibGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNTdGF0aWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENsb3N1cmUoYXJncywgYnlyZWYsIGJvZHksIHR5cGUsIG51bGxhYmxlLCBpc1N0YXRpYywgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xuICB0aGlzLmJ5cmVmID0gYnlyZWY7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMubnVsbGFibGUgPSBudWxsYWJsZTtcbiAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljIHx8IGZhbHNlO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJhc3NpZ25cIjtcbi8qKlxuICogQXNzaWducyBhIHZhbHVlIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0XG4gKiBAY29uc3RydWN0b3IgQXNzaWduXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gbGVmdFxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSByaWdodFxuICogQHByb3BlcnR5IHtTdHJpbmd9IG9wZXJhdG9yXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBBc3NpZ24obGVmdCwgcmlnaHQsIG9wZXJhdG9yLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmxlZnQgPSBsZWZ0O1xuICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiYXNzaWducmVmXCI7XG4vKipcbiAqIEFzc2lnbnMgYSB2YWx1ZSB0byB0aGUgc3BlY2lmaWVkIHRhcmdldFxuICogQGNvbnN0cnVjdG9yIEFzc2lnblxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IGxlZnRcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gcmlnaHRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBvcGVyYXRvclxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQXNzaWduUmVmKGxlZnQsIHJpZ2h0LCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmxlZnQgPSBsZWZ0O1xuICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBPcGVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgS0lORCA9IFwiYmluXCI7XG4vKipcbiAqIEJpbmFyeSBvcGVyYXRpb25zXG4gKiBAY29uc3RydWN0b3IgQmluXG4gKiBAZXh0ZW5kcyB7T3BlcmF0aW9ufVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gbGVmdFxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSByaWdodFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0aW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBCaW4odHlwZSwgbGVmdCwgcmlnaHQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE9wZXJhdGlvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgdGhpcy5yaWdodCA9IHJpZ2h0O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTGl0ZXJhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBLSU5EID0gXCJib29sZWFuXCI7XG4vKipcbiAqIERlZmluZXMgYSBib29sZWFuIHZhbHVlICh0cnVlL2ZhbHNlKVxuICogQGNvbnN0cnVjdG9yIEJvb2xlYW5cbiAqIEBleHRlbmRzIHtMaXRlcmFsfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTGl0ZXJhbFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQm9vbGVhbih2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBMaXRlcmFsLmFwcGx5KHRoaXMsIFtLSU5ELCB2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImJyZWFrXCI7XG4vKipcbiAqIEEgYnJlYWsgc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgQnJlYWtcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge051bWJlcnxOdWxsfSBsZXZlbFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBCcmVhayhsZXZlbCwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmxldmVsID0gbGV2ZWw7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImJ5cmVmXCI7XG4vKipcbiAqIFBhc3NpbmcgYnkgUmVmZXJlbmNlIC0gc28gdGhlIGZ1bmN0aW9uIGNhbiBtb2RpZnkgdGhlIHZhcmlhYmxlXG4gKiBAY29uc3RydWN0b3IgQnlSZWZcbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICogQHByb3BlcnR5IHtleHByfSB3aGF0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBCeVJlZih3aGF0LCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLndoYXQgPSB3aGF0O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJjYWxsXCI7XG4vKipcbiAqIEV4ZWN1dGVzIGEgY2FsbCBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBDYWxsXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcnxWYXJpYWJsZXw/P30gd2hhdFxuICogQHByb3BlcnR5IHtBcmd1bWVudHNbXX0gYXJndW1lbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBDYWxsKHdoYXQsIGFyZ3MsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMud2hhdCA9IHdoYXQ7XG4gIHRoaXMuYXJndW1lbnRzID0gYXJncztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJjYXNlXCI7XG4vKipcbiAqIEEgc3dpdGNoIGNhc2Ugc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgQ2FzZVxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbnxudWxsfSB0ZXN0IC0gaWYgbnVsbCwgbWVhbnMgdGhhdCB0aGUgZGVmYXVsdCBjYXNlXG4gKiBAcHJvcGVydHkge0Jsb2NrfG51bGx9IGJvZHlcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQ2FzZSh0ZXN0LCBib2R5LCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudGVzdCA9IHRlc3Q7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBPcGVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgS0lORCA9IFwiY2FzdFwiO1xuLyoqXG4gKiBCaW5hcnkgb3BlcmF0aW9uc1xuICogQGNvbnN0cnVjdG9yIENhc3RcbiAqIEBleHRlbmRzIHtPcGVyYXRpb259XG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJhd1xuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSBleHByXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRpb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENhc3QodHlwZSwgcmF3LCBleHByLCBkb2NzLCBsb2NhdGlvbikge1xuICBPcGVyYXRpb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMucmF3ID0gcmF3O1xuICB0aGlzLmV4cHIgPSBleHByO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImNhdGNoXCI7XG4vKipcbiAqIERlZmluZXMgYSBjYXRjaCBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBDYXRjaFxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcltdfSB3aGF0XG4gKiBAcHJvcGVydHkge1ZhcmlhYmxlfSB2YXJpYWJsZVxuICogQHByb3BlcnR5IHtTdGF0ZW1lbnR9IGJvZHlcbiAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2xhbmd1YWdlLmV4Y2VwdGlvbnMucGhwXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENhdGNoKGJvZHksIHdoYXQsIHZhcmlhYmxlLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMud2hhdCA9IHdoYXQ7XG4gIHRoaXMudmFyaWFibGUgPSB2YXJpYWJsZTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIERlY2xhcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIEtJTkQgPSBcImNsYXNzXCI7XG4vKipcbiAqIEEgY2xhc3MgZGVmaW5pdGlvblxuICogQGNvbnN0cnVjdG9yIENsYXNzXG4gKiBAZXh0ZW5kcyB7RGVjbGFyYXRpb259XG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ8bnVsbH0gZXh0ZW5kc1xuICogQHByb3BlcnR5IHtJZGVudGlmaWVyW119IGltcGxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7RGVjbGFyYXRpb25bXX0gYm9keVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0Fub255bW91c1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc0Fic3RyYWN0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRmluYWxcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlY2xhcmF0aW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBDbGFzcyhuYW1lLCBleHQsIGltcGwsIGJvZHksIGZsYWdzLCBkb2NzLCBsb2NhdGlvbikge1xuICBEZWNsYXJhdGlvbi5hcHBseSh0aGlzLCBbS0lORCwgbmFtZSwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5pc0Fub255bW91cyA9IG5hbWUgPyBmYWxzZSA6IHRydWU7XG4gIHRoaXNbXCJleHRlbmRzXCJdID0gZXh0O1xuICB0aGlzW1wiaW1wbGVtZW50c1wiXSA9IGltcGw7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMucGFyc2VGbGFncyhmbGFncyk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBDb25zdGFudFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgS0lORCA9IFwiY2xhc3Njb25zdGFudFwiO1xudmFyIElTX1VOREVGSU5FRCA9IFwiXCI7XG52YXIgSVNfUFVCTElDID0gXCJwdWJsaWNcIjtcbnZhciBJU19QUk9URUNURUQgPSBcInByb3RlY3RlZFwiO1xudmFyIElTX1BSSVZBVEUgPSBcInByaXZhdGVcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzL2ludGVyZmFjZS90cmFpdCBjb25zdGFudFxuICogQGNvbnN0cnVjdG9yIENsYXNzQ29uc3RhbnRcbiAqIEBleHRlbmRzIHtDb25zdGFudFN0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2aXNpYmlsaXR5XG4gKi9cblxudmFyIENsYXNzQ29uc3RhbnQgPSBDb25zdGFudFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQ2xhc3NDb25zdGFudChraW5kLCBjb25zdGFudHMsIGZsYWdzLCBkb2NzLCBsb2NhdGlvbikge1xuICBDb25zdGFudFN0YXRlbWVudC5hcHBseSh0aGlzLCBba2luZCB8fCBLSU5ELCBjb25zdGFudHMsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMucGFyc2VGbGFncyhmbGFncyk7XG59KTtcbi8qKlxuICogR2VuZXJpYyBmbGFncyBwYXJzZXJcbiAqIEBwYXJhbSB7SW50ZWdlcltdfSBmbGFnc1xuICogQHJldHVybiB7dm9pZH1cbiAqL1xuXG5DbGFzc0NvbnN0YW50LnByb3RvdHlwZS5wYXJzZUZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XG4gIGlmIChmbGFnc1swXSA9PT0gLTEpIHtcbiAgICB0aGlzLnZpc2liaWxpdHkgPSBJU19VTkRFRklORUQ7XG4gIH0gZWxzZSBpZiAoZmxhZ3NbMF0gPT09IG51bGwpIHtcbiAgICB0aGlzLnZpc2liaWxpdHkgPSBudWxsO1xuICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAwKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFVCTElDO1xuICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAxKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFJPVEVDVEVEO1xuICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAyKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFJJVkFURTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGFzc0NvbnN0YW50O1xuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiY2xvbmVcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsb25lIGNhbGxcbiAqIEBjb25zdHJ1Y3RvciBDbG9uZVxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHdoYXRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIENsb25lKHdoYXQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMud2hhdCA9IHdoYXQ7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImNsb3N1cmVcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsb3N1cmVcbiAqIEBjb25zdHJ1Y3RvciBDbG9zdXJlXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7UGFyYW1ldGVyW119IGFyZ3VtZW50c1xuICogQHByb3BlcnR5IHtWYXJpYWJsZVtdfSB1c2VzXG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYnlyZWZcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbnVsbGFibGVcbiAqIEBwcm9wZXJ0eSB7QmxvY2t8bnVsbH0gYm9keVxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1N0YXRpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQ2xvc3VyZShhcmdzLCBieXJlZiwgdXNlcywgdHlwZSwgbnVsbGFibGUsIGlzU3RhdGljLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnVzZXMgPSB1c2VzO1xuICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG4gIHRoaXMuYnlyZWYgPSBieXJlZjtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5udWxsYWJsZSA9IG51bGxhYmxlO1xuICB0aGlzLmlzU3RhdGljID0gaXNTdGF0aWMgfHwgZmFsc2U7XG4gIHRoaXMuYm9keSA9IG51bGw7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBDb21tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIEtJTkQgPSBcImNvbW1lbnRibG9ja1wiO1xuLyoqXG4gKiBBIGNvbW1lbnQgYmxvY2sgKG11bHRpbGluZSlcbiAqIEBjb25zdHJ1Y3RvciBDb21tZW50QmxvY2tcbiAqIEBleHRlbmRzIHtDb21tZW50fVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQ29tbWVudEJsb2NrKHZhbHVlLCBkb2NzLCBsb2NhdGlvbikge1xuICBDb21tZW50LmFwcGx5KHRoaXMsIFtLSU5ELCB2YWx1ZSwgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIENvbW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgS0lORCA9IFwiY29tbWVudGxpbmVcIjtcbi8qKlxuICogQSBzaW5nbGUgbGluZSBjb21tZW50XG4gKiBAY29uc3RydWN0b3IgQ29tbWVudExpbmVcbiAqIEBleHRlbmRzIHtDb21tZW50fVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQ29tbWVudExpbmUodmFsdWUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIENvbW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIHZhbHVlLCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJjb25zdGFudFwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgY29uc3RhbnRcbiAqIEBjb25zdHJ1Y3RvciBDb25zdGFudFxuICogQGV4dGVuZHMge05vZGV9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICogQHByb3BlcnR5IHtOb2RlfHN0cmluZ3xudW1iZXJ8Ym9vbGVhbnxudWxsfSB2YWx1ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQ29uc3RhbnQobmFtZSwgdmFsdWUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJjb250aW51ZVwiO1xuLyoqXG4gKiBBIGNvbnRpbnVlIHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIENvbnRpbnVlXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtOdW1iZXJ8TnVsbH0gbGV2ZWxcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gQ29udGludWUobGV2ZWwsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5sZXZlbCA9IGxldmVsO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgQmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgS0lORCA9IFwiZGVjbGFyZVwiO1xuLyoqXG4gKiBUaGUgZGVjbGFyZSBjb25zdHJ1Y3QgaXMgdXNlZCB0byBzZXQgZXhlY3V0aW9uIGRpcmVjdGl2ZXMgZm9yIGEgYmxvY2sgb2YgY29kZVxuICogQGNvbnN0cnVjdG9yIERlY2xhcmVcbiAqIEBleHRlbmRzIHtCbG9ja31cbiAqIEBwcm9wZXJ0eSB7QXJyYXlbXX0gZGlyZWN0aXZlc1xuICogQHByb3BlcnR5IHtTdHJpbmd9IG1vZGVcbiAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2NvbnRyb2wtc3RydWN0dXJlcy5kZWNsYXJlLnBocFxuICovXG5cbnZhciBEZWNsYXJlID0gQmxvY2tbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIERlY2xhcmUoZGlyZWN0aXZlcywgYm9keSwgbW9kZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgQmxvY2suYXBwbHkodGhpcywgW0tJTkQsIGJvZHksIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gIHRoaXMubW9kZSA9IG1vZGU7XG59KTtcbi8qKlxuICogVGhlIG5vZGUgaXMgZGVjbGFyZWQgYXMgYSBzaG9ydCB0YWcgc3ludGF4IDpcbiAqIGBgYHBocFxuICogPD9waHBcbiAqIGRlY2xhcmUodGlja3M9MSk6XG4gKiAvLyBzb21lIHN0YXRlbWVudHNcbiAqIGVuZGRlY2xhcmU7XG4gKiBgYGBcbiAqIEBjb25zdGFudCB7U3RyaW5nfSBNT0RFX1NIT1JUXG4gKi9cblxuRGVjbGFyZS5NT0RFX1NIT1JUID0gXCJzaG9ydFwiO1xuLyoqXG4gKiBUaGUgbm9kZSBpcyBkZWNsYXJlZCBicmFja2V0IGVuY2xvc2VkIGNvZGUgOlxuICogYGBgcGhwXG4gKiA8P3BocFxuICogZGVjbGFyZSh0aWNrcz0xKSB7XG4gKiAvLyBzb21lIHN0YXRlbWVudHNcbiAqIH1cbiAqIGBgYFxuICogQGNvbnN0YW50IHtTdHJpbmd9IE1PREVfQkxPQ0tcbiAqL1xuXG5EZWNsYXJlLk1PREVfQkxPQ0sgPSBcImJsb2NrXCI7XG4vKipcbiAqIFRoZSBub2RlIGlzIGRlY2xhcmVkIGFzIGEgc2ltcGxlIHN0YXRlbWVudC4gSW4gb3JkZXIgdG8gbWFrZSB0aGluZ3Mgc2ltcGxlclxuICogY2hpbGRyZW4gb2YgdGhlIG5vZGUgYXJlIGF1dG9tYXRpY2FsbHkgY29sbGVjdGVkIHVudGlsIHRoZSBuZXh0XG4gKiBkZWNsYXJlIHN0YXRlbWVudC5cbiAqIGBgYHBocFxuICogPD9waHBcbiAqIGRlY2xhcmUodGlja3M9MSk7XG4gKiAvLyBzb21lIHN0YXRlbWVudHNcbiAqIGRlY2xhcmUodGlja3M9Mik7XG4gKiAvLyBzb21lIHN0YXRlbWVudHNcbiAqIGBgYFxuICogQGNvbnN0YW50IHtTdHJpbmd9IE1PREVfTk9ORVxuICovXG5cbkRlY2xhcmUuTU9ERV9OT05FID0gXCJub25lXCI7XG5tb2R1bGUuZXhwb3J0cyA9IERlY2xhcmU7XG5cbi8qKiovIH0pLFxuLyogNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJkZWNsYXJlZGlyZWN0aXZlXCI7XG4vKipcbiAqIERlZmluZXMgYSBjb25zdGFudFxuICogQGNvbnN0cnVjdG9yIERlY2xhcmVEaXJlY3RpdmVcbiAqIEBleHRlbmRzIHtOb2RlfVxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfSBuYW1lXG4gKiBAcHJvcGVydHkge05vZGV8c3RyaW5nfG51bWJlcnxib29sZWFufG51bGx9IHZhbHVlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBEZWNsYXJlRGlyZWN0aXZlKGtleSwgdmFsdWUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59KTtcblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiZG9cIjtcbi8qKlxuICogRGVmaW5lcyBhIGRvL3doaWxlIHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIERvXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSB0ZXN0XG4gKiBAcHJvcGVydHkge1N0YXRlbWVudH0gYm9keVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBEbyh0ZXN0LCBib2R5LCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudGVzdCA9IHRlc3Q7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiZWNob1wiO1xuLyoqXG4gKiBEZWZpbmVzIHN5c3RlbSBiYXNlZCBjYWxsXG4gKiBAY29uc3RydWN0b3IgRWNob1xuICogQHByb3BlcnR5IHtib29sZWFufSBzaG9ydEZvcm1cbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEVjaG8oZXhwcmVzc2lvbnMsIHNob3J0Rm9ybSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnNob3J0Rm9ybSA9IHNob3J0Rm9ybTtcbiAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJlbXB0eVwiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGVtcHR5IGNoZWNrIGNhbGxcbiAqIEBjb25zdHJ1Y3RvciBFbXB0eVxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBFbXB0eShleHByZXNzaW9uLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTGl0ZXJhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBLSU5EID0gXCJlbmNhcHNlZFwiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGVuY2Fwc2VkIHN0cmluZyAoY29udGFpbnMgZXhwcmVzc2lvbnMpXG4gKiBAY29uc3RydWN0b3IgRW5jYXBzZWRcbiAqIEBleHRlbmRzIHtMaXRlcmFsfVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgLSBEZWZpbmVzIHRoZSB0eXBlIG9mIGVuY2Fwc2VkIHN0cmluZyAoc2hlbGwsIGhlcmVkb2MsIHN0cmluZylcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfE51bGx9IGxhYmVsIC0gVGhlIGhlcmVkb2MgbGFiZWwsIGRlZmluZWQgb25seSB3aGVuIHRoZSB0eXBlIGlzIGhlcmVkb2NcbiAqL1xuXG52YXIgRW5jYXBzZWQgPSBMaXRlcmFsW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBFbmNhcHNlZCh2YWx1ZSwgcmF3LCB0eXBlLCBkb2NzLCBsb2NhdGlvbikge1xuICBMaXRlcmFsLmFwcGx5KHRoaXMsIFtLSU5ELCB2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xufSk7XG4vKipcbiAqIFRoZSBub2RlIGlzIGEgZG91YmxlIHF1b3RlIHN0cmluZyA6XG4gKiBgYGBwaHBcbiAqIDw/cGhwXG4gKiBlY2hvIFwiaGVsbG8gJHdvcmxkXCI7XG4gKiBgYGBcbiAqIEBjb25zdGFudCB7U3RyaW5nfSBUWVBFX1NUUklORyAtIGBzdHJpbmdgXG4gKi9cblxuRW5jYXBzZWQuVFlQRV9TVFJJTkcgPSBcInN0cmluZ1wiO1xuLyoqXG4gKiBUaGUgbm9kZSBpcyBhIHNoZWxsIGV4ZWN1dGUgc3RyaW5nIDpcbiAqIGBgYHBocFxuICogPD9waHBcbiAqIGVjaG8gYGxzIC1sYXJ0aCAkcGF0aGA7XG4gKiBgYGBcbiAqIEBjb25zdGFudCB7U3RyaW5nfSBUWVBFX1NIRUxMIC0gYHNoZWxsYFxuICovXG5cbkVuY2Fwc2VkLlRZUEVfU0hFTEwgPSBcInNoZWxsXCI7XG4vKipcbiAqIFRoZSBub2RlIGlzIGEgc2hlbGwgZXhlY3V0ZSBzdHJpbmcgOlxuICogYGBgcGhwXG4gKiA8P3BocFxuICogZWNobyA8PDxTVFJcbiAqICBIZWxsbyAkd29ybGRcbiAqIFNUUlxuICogO1xuICogYGBgXG4gKiBAY29uc3RhbnQge1N0cmluZ30gVFlQRV9IRVJFRE9DIC0gYGhlcmVkb2NgXG4gKi9cblxuRW5jYXBzZWQuVFlQRV9IRVJFRE9DID0gXCJoZXJlZG9jXCI7XG4vKipcbiAqIFRoZSBub2RlIGNvbnRhaW5zIGEgbGlzdCBvZiBjb25zdHJlZiAvIHZhcmlhYmxlcyAvIGV4cHIgOlxuICogYGBgcGhwXG4gKiA8P3BocFxuICogZWNobyAkZm9vLT5iYXJfJGJhejtcbiAqIGBgYFxuICogQGNvbnN0YW50IHtTdHJpbmd9IFRZUEVfT0ZGU0VUIC0gYG9mZnNldGBcbiAqL1xuXG5FbmNhcHNlZC5UWVBFX09GRlNFVCA9IFwib2Zmc2V0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEVuY2Fwc2VkO1xuXG4vKioqLyB9KSxcbi8qIDY5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiZW5jYXBzZWRwYXJ0XCI7XG4vKipcbiAqIFBhcnQgb2YgYEVuY2Fwc2VkYCBub2RlXG4gKiBAY29uc3RydWN0b3IgRW5jYXBzZWRQYXJ0XG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gZXhwcmVzc2lvblxuICogQHByb3BlcnR5IHtTdHJpbmd9IHN5bnRheFxuICogQHByb3BlcnR5IHtCb29sZWFufSBjdXJseVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRW5jYXBzZWRQYXJ0KGV4cHJlc3Npb24sIHN5bnRheCwgY3VybHksIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gIHRoaXMuc3ludGF4ID0gc3ludGF4O1xuICB0aGlzLmN1cmx5ID0gY3VybHk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImVudHJ5XCI7XG4vKipcbiAqIEFuIGFycmF5IGVudHJ5IC0gc2VlIFtBcnJheV0oI2FycmF5KVxuICogQGNvbnN0cnVjdG9yIEVudHJ5XG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7Tm9kZXxudWxsfSBrZXkgVGhlIGVudHJ5IGtleS9vZmZzZXRcbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gdmFsdWUgVGhlIGVudHJ5IHZhbHVlXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGJ5UmVmIEJ5IHJlZmVyZW5jZVxuICogQHByb3BlcnR5IHtCb29sZWFufSB1bnBhY2sgQXJndW1lbnQgdW5wYWNraW5nXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBFbnRyeShrZXksIHZhbHVlLCBieVJlZiwgdW5wYWNrLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmJ5UmVmID0gYnlSZWY7XG4gIHRoaXMudW5wYWNrID0gdW5wYWNrO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJlcnJvclwiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGVycm9yIG5vZGUgKHVzZWQgb25seSBvbiBzaWxlbnRNb2RlKVxuICogQGNvbnN0cnVjdG9yIEVycm9yXG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGluZVxuICogQHByb3BlcnR5IHtudW1iZXJ8c3RyaW5nfSB0b2tlblxuICogQHByb3BlcnR5IHtzdHJpbmd8YXJyYXl9IGV4cGVjdGVkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBFcnJvcihtZXNzYWdlLCB0b2tlbiwgbGluZSwgZXhwZWN0ZWQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgdGhpcy5saW5lID0gbGluZTtcbiAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJldmFsXCI7XG4vKipcbiAqIERlZmluZXMgYW4gZXZhbCBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBFdmFsXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gc291cmNlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBFdmFsKHNvdXJjZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG59KTtcblxuLyoqKi8gfSksXG4vKiA3MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImV4aXRcIjtcbi8qKlxuICogRGVmaW5lcyBhbiBleGl0IC8gZGllIGNhbGxcbiAqIEBjb25zdHJ1Y3RvciBFeGl0XG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7Tm9kZXxudWxsfSBleHByZXNzaW9uXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHVzZURpZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRXhpdChleHByZXNzaW9uLCB1c2VEaWUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gIHRoaXMudXNlRGllID0gdXNlRGllO1xufSk7XG5cbi8qKiovIH0pLFxuLyogNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImV4cHJlc3Npb25zdGF0ZW1lbnRcIjtcbi8qKlxuICogRGVmaW5lcyBhbiBleHByZXNzaW9uIGJhc2VkIHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIEV4cHJlc3Npb25TdGF0ZW1lbnRcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IGV4cHJlc3Npb25cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRXhwcmVzc2lvblN0YXRlbWVudChleHByLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHI7XG59KTtcblxuLyoqKi8gfSksXG4vKiA3NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiZm9yXCI7XG4vKipcbiAqIERlZmluZXMgYSBmb3IgaXRlcmF0b3JcbiAqIEBjb25zdHJ1Y3RvciBGb3JcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb25bXX0gaW5pdFxuICogQHByb3BlcnR5IHtFeHByZXNzaW9uW119IHRlc3RcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbltdfSBpbmNyZW1lbnRcbiAqIEBwcm9wZXJ0eSB7U3RhdGVtZW50fSBib2R5XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNob3J0Rm9ybVxuICogQHNlZSBodHRwOi8vcGhwLm5ldC9tYW51YWwvZW4vY29udHJvbC1zdHJ1Y3R1cmVzLmZvci5waHBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gRm9yKGluaXQsIHRlc3QsIGluY3JlbWVudCwgYm9keSwgc2hvcnRGb3JtLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuaW5pdCA9IGluaXQ7XG4gIHRoaXMudGVzdCA9IHRlc3Q7XG4gIHRoaXMuaW5jcmVtZW50ID0gaW5jcmVtZW50O1xuICB0aGlzLnNob3J0Rm9ybSA9IHNob3J0Rm9ybTtcbiAgdGhpcy5ib2R5ID0gYm9keTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDc2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJmb3JlYWNoXCI7XG4vKipcbiAqIERlZmluZXMgYSBmb3JlYWNoIGl0ZXJhdG9yXG4gKiBAY29uc3RydWN0b3IgRm9yZWFjaFxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gc291cmNlXG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb258bnVsbH0ga2V5XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHZhbHVlXG4gKiBAcHJvcGVydHkge1N0YXRlbWVudH0gYm9keVxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG9ydEZvcm1cbiAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2NvbnRyb2wtc3RydWN0dXJlcy5mb3JlYWNoLnBocFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBGb3JlYWNoKHNvdXJjZSwga2V5LCB2YWx1ZSwgYm9keSwgc2hvcnRGb3JtLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLnNob3J0Rm9ybSA9IHNob3J0Rm9ybTtcbiAgdGhpcy5ib2R5ID0gYm9keTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJnbG9iYWxcIjtcbi8qKlxuICogSW1wb3J0cyBhIHZhcmlhYmxlIGZyb20gdGhlIGdsb2JhbCBzY29wZVxuICogQGNvbnN0cnVjdG9yIEdsb2JhbFxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7VmFyaWFibGVbXX0gaXRlbXNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gR2xvYmFsKGl0ZW1zLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuaXRlbXMgPSBpdGVtcztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJnb3RvXCI7XG4vKipcbiAqIERlZmluZXMgZ290byBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBHb3RvXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsXG4gKiBAc2VlIHtMYWJlbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gR290byhsYWJlbCwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLmxhYmVsID0gbGFiZWw7XG59KTtcblxuLyoqKi8gfSksXG4vKiA3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwiaGFsdFwiO1xuLyoqXG4gKiBIYWx0cyB0aGUgY29tcGlsZXIgZXhlY3V0aW9uXG4gKiBAY29uc3RydWN0b3IgSGFsdFxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBhZnRlciAtIFN0cmluZyBhZnRlciB0aGUgaGFsdCBzdGF0ZW1lbnRcbiAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2Z1bmN0aW9uLmhhbHQtY29tcGlsZXIucGhwXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIEhhbHQoYWZ0ZXIsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5hZnRlciA9IGFmdGVyO1xufSk7XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJpZGVudGlmaWVyXCI7XG4vKipcbiAqIERlZmluZXMgYW4gaWRlbnRpZmllciBub2RlXG4gKiBAY29uc3RydWN0b3IgSWRlbnRpZmllclxuICogQGV4dGVuZHMge05vZGV9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZVxuICovXG5cbnZhciBJZGVudGlmaWVyID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gSWRlbnRpZmllcihuYW1lLCBkb2NzLCBsb2NhdGlvbikge1xuICBOb2RlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IElkZW50aWZpZXI7XG5cbi8qKiovIH0pLFxuLyogODEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImlmXCI7XG4vKipcbiAqIERlZmluZXMgYSBpZiBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBJZlxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gdGVzdFxuICogQHByb3BlcnR5IHtCbG9ja30gYm9keVxuICogQHByb3BlcnR5IHtCbG9ja3xJZnxudWxsfSBhbHRlcm5hdGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvcnRGb3JtXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIElmKHRlc3QsIGJvZHksIGFsdGVybmF0ZSwgc2hvcnRGb3JtLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudGVzdCA9IHRlc3Q7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICB0aGlzLnNob3J0Rm9ybSA9IHNob3J0Rm9ybTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwiaW5jbHVkZVwiO1xuLyoqXG4gKiBEZWZpbmVzIHN5c3RlbSBpbmNsdWRlIGNhbGxcbiAqIEBjb25zdHJ1Y3RvciBJbmNsdWRlXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9uY2VcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcmVxdWlyZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gSW5jbHVkZShvbmNlLCByZXF1aXJlLCB0YXJnZXQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMub25jZSA9IG9uY2U7XG4gIHRoaXMucmVxdWlyZSA9IHJlcXVpcmU7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xufSk7XG5cbi8qKiovIH0pLFxuLyogODMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTGl0ZXJhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBLSU5EID0gXCJpbmxpbmVcIjtcbi8qKlxuICogRGVmaW5lcyBpbmxpbmUgaHRtbCBvdXRwdXQgKHRyZWF0ZWQgYXMgZWNobyBvdXRwdXQpXG4gKiBAY29uc3RydWN0b3IgSW5saW5lXG4gKiBAZXh0ZW5kcyB7TGl0ZXJhbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpdGVyYWxbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIElubGluZSh2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBMaXRlcmFsLmFwcGx5KHRoaXMsIFtLSU5ELCB2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRGVjbGFyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG52YXIgS0lORCA9IFwiaW50ZXJmYWNlXCI7XG4vKipcbiAqIEFuIGludGVyZmFjZSBkZWZpbml0aW9uXG4gKiBAY29uc3RydWN0b3IgSW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyB7RGVjbGFyYXRpb259XG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJbXX0gZXh0ZW5kc1xuICogQHByb3BlcnR5IHtEZWNsYXJhdGlvbltdfSBib2R5XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEZWNsYXJhdGlvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gSW50ZXJmYWNlKG5hbWUsIGV4dCwgYm9keSwgZG9jcywgbG9jYXRpb24pIHtcbiAgRGVjbGFyYXRpb24uYXBwbHkodGhpcywgW0tJTkQsIG5hbWUsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXNbXCJleHRlbmRzXCJdID0gZXh0O1xuICB0aGlzLmJvZHkgPSBib2R5O1xufSk7XG5cbi8qKiovIH0pLFxuLyogODUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJpc3NldFwiO1xuLyoqXG4gKiBEZWZpbmVzIGFuIGlzc2V0IGNhbGxcbiAqIEBjb25zdHJ1Y3RvciBJc3NldFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBJc3NldCh2YXJpYWJsZXMsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xufSk7XG5cbi8qKiovIH0pLFxuLyogODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcImxhYmVsXCI7XG4vKipcbiAqIEEgbGFiZWwgc3RhdGVtZW50IChyZWZlcmVuY2VkIGJ5IGdvdG8pXG4gKiBAY29uc3RydWN0b3IgTGFiZWxcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge1N0cmluZ30gbmFtZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBMYWJlbChuYW1lLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG59KTtcblxuLyoqKi8gfSksXG4vKiA4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcImxpc3RcIjtcbi8qKlxuICogRGVmaW5lcyBsaXN0IGFzc2lnbm1lbnRcbiAqIEBjb25zdHJ1Y3RvciBMaXN0XG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvcnRGb3JtXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBMaXN0KGl0ZW1zLCBzaG9ydEZvcm0sIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgdGhpcy5zaG9ydEZvcm0gPSBzaG9ydEZvcm07XG59KTtcblxuLyoqKi8gfSksXG4vKiA4OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBMaXRlcmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIEtJTkQgPSBcIm1hZ2ljXCI7XG4vKipcbiAqIERlZmluZXMgbWFnaWMgY29uc3RhbnRcbiAqIEBjb25zdHJ1Y3RvciBNYWdpY1xuICogQGV4dGVuZHMge0xpdGVyYWx9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBMaXRlcmFsW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBNYWdpYyh2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBMaXRlcmFsLmFwcGx5KHRoaXMsIFtLSU5ELCB2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogODkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgX0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBLSU5EID0gXCJtZXRob2RcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzL2ludGVyZmFjZS90cmFpdCBtZXRob2RcbiAqIEBjb25zdHJ1Y3RvciBNZXRob2RcbiAqIEBleHRlbmRzIHtfRnVuY3Rpb259XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzQWJzdHJhY3RcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNGaW5hbFxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1N0YXRpY1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHZpc2liaWxpdHlcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9GdW5jdGlvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTWV0aG9kKCkge1xuICBfRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLmtpbmQgPSBLSU5EO1xufSk7XG5cbi8qKiovIH0pLFxuLyogOTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgUmVmZXJlbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIEtJTkQgPSBcIm5hbWVcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzIHJlZmVyZW5jZSBub2RlXG4gKiBAY29uc3RydWN0b3IgTmFtZVxuICogQGV4dGVuZHMge1JlZmVyZW5jZX1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVzb2x1dGlvblxuICovXG5cbnZhciBOYW1lID0gUmVmZXJlbmNlW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBOYW1lKG5hbWUsIGlzUmVsYXRpdmUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFJlZmVyZW5jZS5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcblxuICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IE5hbWUuUkVMQVRJVkVfTkFNRTtcbiAgfSBlbHNlIGlmIChuYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IE5hbWUuVU5RVUFMSUZJRURfTkFNRTtcbiAgfSBlbHNlIGlmICghbmFtZVswXSkge1xuICAgIHRoaXMucmVzb2x1dGlvbiA9IE5hbWUuRlVMTF9RVUFMSUZJRURfTkFNRTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlc29sdXRpb24gPSBOYW1lLlFVQUxJRklFRF9OQU1FO1xuICB9XG5cbiAgdGhpcy5uYW1lID0gbmFtZS5qb2luKFwiXFxcXFwiKTtcbn0pO1xuLyoqXG4gKiBUaGlzIGlzIGFuIGlkZW50aWZpZXIgd2l0aG91dCBhIG5hbWVzcGFjZSBzZXBhcmF0b3IsIHN1Y2ggYXMgRm9vXG4gKiBAY29uc3RhbnQge1N0cmluZ30gVU5RVUFMSUZJRURfTkFNRVxuICovXG5cbk5hbWUuVU5RVUFMSUZJRURfTkFNRSA9IFwidXFuXCI7XG4vKipcbiAqIFRoaXMgaXMgYW4gaWRlbnRpZmllciB3aXRoIGEgbmFtZXNwYWNlIHNlcGFyYXRvciwgc3VjaCBhcyBGb29cXEJhclxuICogQGNvbnN0YW50IHtTdHJpbmd9IFFVQUxJRklFRF9OQU1FXG4gKi9cblxuTmFtZS5RVUFMSUZJRURfTkFNRSA9IFwicW5cIjtcbi8qKlxuICogVGhpcyBpcyBhbiBpZGVudGlmaWVyIHdpdGggYSBuYW1lc3BhY2Ugc2VwYXJhdG9yIHRoYXQgYmVnaW5zIHdpdGhcbiAqIGEgbmFtZXNwYWNlIHNlcGFyYXRvciwgc3VjaCBhcyBcXEZvb1xcQmFyLiBUaGUgbmFtZXNwYWNlIFxcRm9vIGlzIGFsc29cbiAqIGEgZnVsbHkgcXVhbGlmaWVkIG5hbWUuXG4gKiBAY29uc3RhbnQge1N0cmluZ30gRlVMTF9RVUFMSUZJRURfTkFNRVxuICovXG5cbk5hbWUuRlVMTF9RVUFMSUZJRURfTkFNRSA9IFwiZnFuXCI7XG4vKipcbiAqIFRoaXMgaXMgYW4gaWRlbnRpZmllciBzdGFydGluZyB3aXRoIG5hbWVzcGFjZSwgc3VjaCBhcyBuYW1lc3BhY2VcXEZvb1xcQmFyLlxuICogQGNvbnN0YW50IHtTdHJpbmd9IFJFTEFUSVZFX05BTUVcbiAqL1xuXG5OYW1lLlJFTEFUSVZFX05BTUUgPSBcInJuXCI7XG5tb2R1bGUuZXhwb3J0cyA9IE5hbWU7XG5cbi8qKiovIH0pLFxuLyogOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgQmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgS0lORCA9IFwibmFtZXNwYWNlXCI7XG4vKipcbiAqIFRoZSBtYWluIHByb2dyYW0gbm9kZVxuICogQGNvbnN0cnVjdG9yIE5hbWVzcGFjZVxuICogQGV4dGVuZHMge0Jsb2NrfVxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gd2l0aEJyYWNrZXRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCbG9ja1tcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTmFtZXNwYWNlKG5hbWUsIGNoaWxkcmVuLCB3aXRoQnJhY2tldHMsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEJsb2NrLmFwcGx5KHRoaXMsIFtLSU5ELCBjaGlsZHJlbiwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy53aXRoQnJhY2tldHMgPSB3aXRoQnJhY2tldHMgfHwgZmFsc2U7XG59KTtcblxuLyoqKi8gfSksXG4vKiA5MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcIm5ld1wiO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3NcbiAqIEBjb25zdHJ1Y3RvciBOZXdcbiAqIEBleHRlbmRzIHtFeHByZXNzaW9ufVxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfFZhcmlhYmxlfENsYXNzfSB3aGF0XG4gKiBAcHJvcGVydHkge0FyZ3VtZW50c1tdfSBhcmd1bWVudHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIE5ldyh3aGF0LCBhcmdzLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLndoYXQgPSB3aGF0O1xuICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG59KTtcblxuLyoqKi8gfSksXG4vKiA5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIEtJTkQgPSBcIm5vb3BcIjtcbi8qKlxuICogSWdub3JlIHRoaXMgbm9kZSwgaXQgaW1wbGllcyBhIG5vIG9wZXJhdGlvbiBibG9jaywgZm9yIGV4YW1wbGUgOlxuICogWyRmb28sICRiYXIsIC8qIGhlcmUgYSBub29wIG5vZGUgKiAvXVxuICogQGNvbnN0cnVjdG9yIE5vb3BcbiAqIEBleHRlbmRzIHtOb2RlfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTm9vcChkb2NzLCBsb2NhdGlvbikge1xuICBOb2RlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTGl0ZXJhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBLSU5EID0gXCJub3dkb2NcIjtcbi8qKlxuICogRGVmaW5lcyBhIG5vd2RvYyBzdHJpbmdcbiAqIEBjb25zdHJ1Y3RvciBOb3dEb2NcbiAqIEBleHRlbmRzIHtMaXRlcmFsfVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmF3XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBMaXRlcmFsW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBOb3dkb2ModmFsdWUsIHJhdywgbGFiZWwsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIExpdGVyYWwuYXBwbHkodGhpcywgW0tJTkQsIHZhbHVlLCByYXcsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMubGFiZWwgPSBsYWJlbDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDk1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgS0lORCA9IFwibnVsbGtleXdvcmRcIjtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbnVsbCBrZXl3b3JkXG4gKiBAY29uc3RydWN0b3IgTnVsbEtleXdvcmRcbiAqIEBleHRlbmRzIHtOb2RlfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gTnVsbEtleXdvcmQocmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBOb2RlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnJhdyA9IHJhdztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIExpdGVyYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgS0lORCA9IFwibnVtYmVyXCI7XG4vKipcbiAqIERlZmluZXMgYSBudW1lcmljIHZhbHVlXG4gKiBAY29uc3RydWN0b3IgTnVtYmVyXG4gKiBAZXh0ZW5kcyB7TGl0ZXJhbH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpdGVyYWxbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIE51bWJlcih2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBMaXRlcmFsLmFwcGx5KHRoaXMsIFtLSU5ELCB2YWx1ZSwgcmF3LCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogOTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTG9va3VwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIEtJTkQgPSBcIm9mZnNldGxvb2t1cFwiO1xuLyoqXG4gKiBMb29rdXAgb24gYW4gb2Zmc2V0IGluIGFuIGFycmF5XG4gKiBAY29uc3RydWN0b3IgT2Zmc2V0TG9va3VwXG4gKiBAZXh0ZW5kcyB7TG9va3VwfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTG9va3VwW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBPZmZzZXRMb29rdXAod2hhdCwgb2Zmc2V0LCBkb2NzLCBsb2NhdGlvbikge1xuICBMb29rdXAuYXBwbHkodGhpcywgW0tJTkQsIHdoYXQsIG9mZnNldCwgZG9jcywgbG9jYXRpb25dKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDk4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIERlY2xhcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxudmFyIEtJTkQgPSBcInBhcmFtZXRlclwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgZnVuY3Rpb24gcGFyYW1ldGVyXG4gKiBAY29uc3RydWN0b3IgUGFyYW1ldGVyXG4gKiBAZXh0ZW5kcyB7RGVjbGFyYXRpb259XG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ8bnVsbH0gdHlwZVxuICogQHByb3BlcnR5IHtOb2RlfG51bGx9IHZhbHVlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGJ5cmVmXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHZhcmlhZGljXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG51bGxhYmxlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEZWNsYXJhdGlvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gUGFyYW1ldGVyKG5hbWUsIHR5cGUsIHZhbHVlLCBpc1JlZiwgaXNWYXJpYWRpYywgbnVsbGFibGUsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIERlY2xhcmF0aW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBuYW1lLCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuYnlyZWYgPSBpc1JlZjtcbiAgdGhpcy52YXJpYWRpYyA9IGlzVmFyaWFkaWM7XG4gIHRoaXMubnVsbGFibGUgPSBudWxsYWJsZTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDk5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFJlZmVyZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBLSU5EID0gXCJwYXJlbnRyZWZlcmVuY2VcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzIHJlZmVyZW5jZSBub2RlXG4gKiBAY29uc3RydWN0b3IgUGFyZW50UmVmZXJlbmNlXG4gKiBAZXh0ZW5kcyB7UmVmZXJlbmNlfVxuICovXG5cbnZhciBQYXJlbnRSZWZlcmVuY2UgPSBSZWZlcmVuY2VbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFBhcmVudFJlZmVyZW5jZShyYXcsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFJlZmVyZW5jZS5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5yYXcgPSByYXc7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gUGFyZW50UmVmZXJlbmNlO1xuXG4vKioqLyB9KSxcbi8qIDEwMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBPcGVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgS0lORCA9IFwicG9zdFwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgcG9zdCBvcGVyYXRpb24gYCRpKytgIG9yIGAkaS0tYFxuICogQGNvbnN0cnVjdG9yIFBvc3RcbiAqIEBleHRlbmRzIHtPcGVyYXRpb259XG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZVxuICogQHByb3BlcnR5IHtWYXJpYWJsZX0gd2hhdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0aW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBQb3N0KHR5cGUsIHdoYXQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE9wZXJhdGlvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy53aGF0ID0gd2hhdDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBPcGVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgS0lORCA9IFwicHJlXCI7XG4vKipcbiAqIERlZmluZXMgYSBwcmUgb3BlcmF0aW9uIGArKyRpYCBvciBgLS0kaWBcbiAqIEBjb25zdHJ1Y3RvciBQcmVcbiAqIEBleHRlbmRzIHtPcGVyYXRpb259XG4gKiBAcHJvcGVydHkge1N0cmluZ30gdHlwZVxuICogQHByb3BlcnR5IHtWYXJpYWJsZX0gd2hhdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0aW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBQcmUodHlwZSwgd2hhdCwgZG9jcywgbG9jYXRpb24pIHtcbiAgT3BlcmF0aW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLndoYXQgPSB3aGF0O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwicHJpbnRcIjtcbi8qKlxuICogT3V0cHV0c1xuICogQGNvbnN0cnVjdG9yIFByaW50XG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFByaW50KGV4cHJlc3Npb24sIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgQmxvY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgS0lORCA9IFwicHJvZ3JhbVwiO1xuLyoqXG4gKiBUaGUgbWFpbiBwcm9ncmFtIG5vZGVcbiAqIEBjb25zdHJ1Y3RvciBQcm9ncmFtXG4gKiBAZXh0ZW5kcyB7QmxvY2t9XG4gKiBAcHJvcGVydHkge0Vycm9yW119IGVycm9yc1xuICogQHByb3BlcnR5IHtEb2NbXT99IGNvbW1lbnRzXG4gKiBAcHJvcGVydHkge1N0cmluZ1tdP30gdG9rZW5zXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCbG9ja1tcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gUHJvZ3JhbShjaGlsZHJlbiwgZXJyb3JzLCBjb21tZW50cywgdG9rZW5zLCBkb2NzLCBsb2NhdGlvbikge1xuICBCbG9jay5hcHBseSh0aGlzLCBbS0lORCwgY2hpbGRyZW4sIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuXG4gIGlmIChjb21tZW50cykge1xuICAgIHRoaXMuY29tbWVudHMgPSBjb21tZW50cztcbiAgfVxuXG4gIGlmICh0b2tlbnMpIHtcbiAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJwcm9wZXJ0eVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgY2xhc3MgcHJvcGVydHlcbiAqIEBjb25zdHJ1Y3RvciBQcm9wZXJ0eVxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKiBAcHJvcGVydHkge05vZGV8bnVsbH0gdmFsdWVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbnVsbGFibGVcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcnxBcnJheTxJZGVudGlmaWVyPnxudWxsfSB0eXBlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFByb3BlcnR5KG5hbWUsIHZhbHVlLCBudWxsYWJsZSwgdHlwZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMubnVsbGFibGUgPSBudWxsYWJsZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBMb29rdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgS0lORCA9IFwicHJvcGVydHlsb29rdXBcIjtcbi8qKlxuICogTG9va3VwIHRvIGFuIG9iamVjdCBwcm9wZXJ0eVxuICogQGNvbnN0cnVjdG9yIFByb3BlcnR5TG9va3VwXG4gKiBAZXh0ZW5kcyB7TG9va3VwfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTG9va3VwW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBQcm9wZXJ0eUxvb2t1cCh3aGF0LCBvZmZzZXQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIExvb2t1cC5hcHBseSh0aGlzLCBbS0lORCwgd2hhdCwgb2Zmc2V0LCBkb2NzLCBsb2NhdGlvbl0pO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJwcm9wZXJ0eXN0YXRlbWVudFwiO1xudmFyIElTX1VOREVGSU5FRCA9IFwiXCI7XG52YXIgSVNfUFVCTElDID0gXCJwdWJsaWNcIjtcbnZhciBJU19QUk9URUNURUQgPSBcInByb3RlY3RlZFwiO1xudmFyIElTX1BSSVZBVEUgPSBcInByaXZhdGVcIjtcbi8qKlxuICogRGVjbGFyZXMgYSBwcm9wZXJ0aWVzIGludG8gdGhlIGN1cnJlbnQgc2NvcGVcbiAqIEBjb25zdHJ1Y3RvciBQcm9wZXJ0eVN0YXRlbWVudFxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7UHJvcGVydHlbXX0gcHJvcGVydGllc1xuICovXG5cbnZhciBQcm9wZXJ0eVN0YXRlbWVudCA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gUHJvcGVydHlTdGF0ZW1lbnQoa2luZCwgcHJvcGVydGllcywgZmxhZ3MsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgdGhpcy5wYXJzZUZsYWdzKGZsYWdzKTtcbn0pO1xuLyoqXG4gKiBHZW5lcmljIGZsYWdzIHBhcnNlclxuICogQHBhcmFtIHtJbnRlZ2VyW119IGZsYWdzXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5cblByb3BlcnR5U3RhdGVtZW50LnByb3RvdHlwZS5wYXJzZUZsYWdzID0gZnVuY3Rpb24gKGZsYWdzKSB7XG4gIGlmIChmbGFnc1swXSA9PT0gLTEpIHtcbiAgICB0aGlzLnZpc2liaWxpdHkgPSBJU19VTkRFRklORUQ7XG4gIH0gZWxzZSBpZiAoZmxhZ3NbMF0gPT09IG51bGwpIHtcbiAgICB0aGlzLnZpc2liaWxpdHkgPSBudWxsO1xuICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAwKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFVCTElDO1xuICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAxKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFJPVEVDVEVEO1xuICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAyKSB7XG4gICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFJJVkFURTtcbiAgfVxuXG4gIHRoaXMuaXNTdGF0aWMgPSBmbGFnc1sxXSA9PT0gMTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvcGVydHlTdGF0ZW1lbnQ7XG5cbi8qKiovIH0pLFxuLyogMTA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwicmV0aWZcIjtcbi8qKlxuICogRGVmaW5lcyBhIHNob3J0IGlmIHN0YXRlbWVudCB0aGF0IHJldHVybnMgYSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yIFJldElmXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gdGVzdFxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSB0cnVlRXhwclxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSBmYWxzZUV4cHJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cHJlc3Npb25bXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFJldElmKHRlc3QsIHRydWVFeHByLCBmYWxzZUV4cHIsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudGVzdCA9IHRlc3Q7XG4gIHRoaXMudHJ1ZUV4cHIgPSB0cnVlRXhwcjtcbiAgdGhpcy5mYWxzZUV4cHIgPSBmYWxzZUV4cHI7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcInJldHVyblwiO1xuLyoqXG4gKiBBIGNvbnRpbnVlIHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIFJldHVyblxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbnxudWxsfSBleHByXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFJldHVybihleHByLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuZXhwciA9IGV4cHI7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgUmVmZXJlbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIEtJTkQgPSBcInNlbGZyZWZlcmVuY2VcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzIHJlZmVyZW5jZSBub2RlXG4gKiBAY29uc3RydWN0b3IgU2VsZlJlZmVyZW5jZVxuICogQGV4dGVuZHMge1JlZmVyZW5jZX1cbiAqL1xuXG52YXIgU2VsZlJlZmVyZW5jZSA9IFJlZmVyZW5jZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU2VsZlJlZmVyZW5jZShyYXcsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFJlZmVyZW5jZS5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5yYXcgPSByYXc7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gU2VsZlJlZmVyZW5jZTtcblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJzaWxlbnRcIjtcbi8qKlxuICogQXZvaWRzIHRvIHNob3cvbG9nIHdhcm5pbmdzICYgbm90aWNlcyBmcm9tIHRoZSBpbm5lciBleHByZXNzaW9uXG4gKiBAY29uc3RydWN0b3IgU2lsZW50XG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gZXhwclxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU2lsZW50KGV4cHIsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIEV4cHJlc3Npb24uYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuZXhwciA9IGV4cHI7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcInN0YXRpY1wiO1xuLyoqXG4gKiBEZWNsYXJlcyBhIHN0YXRpYyB2YXJpYWJsZSBpbnRvIHRoZSBjdXJyZW50IHNjb3BlXG4gKiBAY29uc3RydWN0b3IgU3RhdGljXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtTdGF0aWNWYXJpYWJsZVtdfSB2YXJpYWJsZXNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU3RhdGljKHZhcmlhYmxlcywgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDExMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIEtJTkQgPSBcInN0YXRpY3ZhcmlhYmxlXCI7XG4vKipcbiAqIERlZmluZXMgYSBjb25zdGFudFxuICogQGNvbnN0cnVjdG9yIFN0YXRpY1ZhcmlhYmxlXG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqIEBwcm9wZXJ0eSB7VmFyaWFibGV9IHZhcmlhYmxlXG4gKiBAcHJvcGVydHkge05vZGV8c3RyaW5nfG51bWJlcnxib29sZWFufG51bGx9IGRlZmF1bHRWYWx1ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU3RhdGljVmFyaWFibGUodmFyaWFibGUsIGRlZmF1bHRWYWx1ZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgTm9kZS5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDExMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBMb29rdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgS0lORCA9IFwic3RhdGljbG9va3VwXCI7XG4vKipcbiAqIExvb2t1cCB0byBhIHN0YXRpYyBwcm9wZXJ0eVxuICogQGNvbnN0cnVjdG9yIFN0YXRpY0xvb2t1cFxuICogQGV4dGVuZHMge0xvb2t1cH1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvb2t1cFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU3RhdGljTG9va3VwKHdoYXQsIG9mZnNldCwgZG9jcywgbG9jYXRpb24pIHtcbiAgTG9va3VwLmFwcGx5KHRoaXMsIFtLSU5ELCB3aGF0LCBvZmZzZXQsIGRvY3MsIGxvY2F0aW9uXSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgUmVmZXJlbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIEtJTkQgPSBcInN0YXRpY3JlZmVyZW5jZVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgY2xhc3MgcmVmZXJlbmNlIG5vZGVcbiAqIEBjb25zdHJ1Y3RvciBTdGF0aWNSZWZlcmVuY2VcbiAqIEBleHRlbmRzIHtSZWZlcmVuY2V9XG4gKi9cblxudmFyIFN0YXRpY1JlZmVyZW5jZSA9IFJlZmVyZW5jZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU3RhdGljUmVmZXJlbmNlKHJhdywgZG9jcywgbG9jYXRpb24pIHtcbiAgUmVmZXJlbmNlLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnJhdyA9IHJhdztcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBTdGF0aWNSZWZlcmVuY2U7XG5cbi8qKiovIH0pLFxuLyogMTE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIExpdGVyYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgS0lORCA9IFwic3RyaW5nXCI7XG4vKipcbiAqIERlZmluZXMgYSBzdHJpbmcgKHNpbXBsZSBvdSBkb3VibGUgcXVvdGVkKSAtIGNoYXJzIGFyZSBhbHJlYWR5IGVzY2FwZWRcbiAqIEBjb25zdHJ1Y3RvciBTdHJpbmdcbiAqIEBleHRlbmRzIHtMaXRlcmFsfVxuICogQHByb3BlcnR5IHtib29sZWFufSB1bmljb2RlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzRG91YmxlUXVvdGVcbiAqIEBzZWUge0VuY2Fwc2VkfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTGl0ZXJhbFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU3RyaW5nKGlzRG91YmxlUXVvdGUsIHZhbHVlLCB1bmljb2RlLCByYXcsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIExpdGVyYWwuYXBwbHkodGhpcywgW0tJTkQsIHZhbHVlLCByYXcsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudW5pY29kZSA9IHVuaWNvZGU7XG4gIHRoaXMuaXNEb3VibGVRdW90ZSA9IGlzRG91YmxlUXVvdGU7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcInN3aXRjaFwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgc3dpdGNoIHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIFN3aXRjaFxuICogQGV4dGVuZHMge1N0YXRlbWVudH1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gdGVzdFxuICogQHByb3BlcnR5IHtCbG9ja30gYm9keVxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG9ydEZvcm1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gU3dpdGNoKHRlc3QsIGJvZHksIHNob3J0Rm9ybSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnRlc3QgPSB0ZXN0O1xuICB0aGlzLmJvZHkgPSBib2R5O1xuICB0aGlzLnNob3J0Rm9ybSA9IHNob3J0Rm9ybTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDExNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwidGhyb3dcIjtcbi8qKlxuICogRGVmaW5lcyBhIHRocm93IHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIFRocm93XG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSB3aGF0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFRocm93KHdoYXQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy53aGF0ID0gd2hhdDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDExOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBEZWNsYXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbnZhciBLSU5EID0gXCJ0cmFpdFwiO1xuLyoqXG4gKiBBIHRyYWl0IGRlZmluaXRpb25cbiAqIEBjb25zdHJ1Y3RvciBUcmFpdFxuICogQGV4dGVuZHMge0RlY2xhcmF0aW9ufVxuICogQHByb3BlcnR5IHtEZWNsYXJhdGlvbltdfSBib2R5XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEZWNsYXJhdGlvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gVHJhaXQobmFtZSwgYm9keSwgZG9jcywgbG9jYXRpb24pIHtcbiAgRGVjbGFyYXRpb24uYXBwbHkodGhpcywgW0tJTkQsIG5hbWUsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJ0cmFpdGFsaWFzXCI7XG52YXIgSVNfVU5ERUZJTkVEID0gXCJcIjtcbnZhciBJU19QVUJMSUMgPSBcInB1YmxpY1wiO1xudmFyIElTX1BST1RFQ1RFRCA9IFwicHJvdGVjdGVkXCI7XG52YXIgSVNfUFJJVkFURSA9IFwicHJpdmF0ZVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgdHJhaXQgYWxpYXNcbiAqIEBjb25zdHJ1Y3RvciBUcmFpdEFsaWFzXG4gKiBAZXh0ZW5kcyB7Tm9kZX1cbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcnxudWxsfSB0cmFpdFxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfSBtZXRob2RcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcnxudWxsfSBhc1xuICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gdmlzaWJpbGl0eVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gVHJhaXRBbGlhcyh0cmFpdCwgbWV0aG9kLCBhcywgZmxhZ3MsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudHJhaXQgPSB0cmFpdDtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMuYXMgPSBhcztcbiAgdGhpcy52aXNpYmlsaXR5ID0gSVNfVU5ERUZJTkVEO1xuXG4gIGlmIChmbGFncykge1xuICAgIGlmIChmbGFnc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy52aXNpYmlsaXR5ID0gSVNfUFVCTElDO1xuICAgIH0gZWxzZSBpZiAoZmxhZ3NbMF0gPT09IDEpIHtcbiAgICAgIHRoaXMudmlzaWJpbGl0eSA9IElTX1BST1RFQ1RFRDtcbiAgICB9IGVsc2UgaWYgKGZsYWdzWzBdID09PSAyKSB7XG4gICAgICB0aGlzLnZpc2liaWxpdHkgPSBJU19QUklWQVRFO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgS0lORCA9IFwidHJhaXRwcmVjZWRlbmNlXCI7XG4vKipcbiAqIERlZmluZXMgYSB0cmFpdCBhbGlhc1xuICogQGNvbnN0cnVjdG9yIFRyYWl0UHJlY2VkZW5jZVxuICogQGV4dGVuZHMge05vZGV9XG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJ8bnVsbH0gdHJhaXRcbiAqIEBwcm9wZXJ0eSB7SWRlbnRpZmllcn0gbWV0aG9kXG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJbXX0gaW5zdGVhZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gVHJhaXRQcmVjZWRlbmNlKHRyYWl0LCBtZXRob2QsIGluc3RlYWQsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIE5vZGUuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudHJhaXQgPSB0cmFpdDtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMuaW5zdGVhZCA9IGluc3RlYWQ7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBLSU5EID0gXCJ0cmFpdHVzZVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgdHJhaXQgdXNhZ2VcbiAqIEBjb25zdHJ1Y3RvciBUcmFpdFVzZVxuICogQGV4dGVuZHMge05vZGV9XG4gKiBAcHJvcGVydHkge0lkZW50aWZpZXJbXX0gdHJhaXRzXG4gKiBAcHJvcGVydHkge05vZGVbXXxudWxsfSBhZGFwdGF0aW9uc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZVtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gVHJhaXRVc2UodHJhaXRzLCBhZGFwdGF0aW9ucywgZG9jcywgbG9jYXRpb24pIHtcbiAgTm9kZS5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy50cmFpdHMgPSB0cmFpdHM7XG4gIHRoaXMuYWRhcHRhdGlvbnMgPSBhZGFwdGF0aW9ucztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwidHJ5XCI7XG4vKipcbiAqIERlZmluZXMgYSB0cnkgc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgVHJ5XG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtCbG9ja30gYm9keVxuICogQHByb3BlcnR5IHtDYXRjaFtdfSBjYXRjaGVzXG4gKiBAcHJvcGVydHkge0Jsb2NrfSBhbGx3YXlzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZW1lbnRbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFRyeShib2R5LCBjYXRjaGVzLCBhbHdheXMsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5ib2R5ID0gYm9keTtcbiAgdGhpcy5jYXRjaGVzID0gY2F0Y2hlcztcbiAgdGhpcy5hbHdheXMgPSBhbHdheXM7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgUmVmZXJlbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIEtJTkQgPSBcInR5cGVyZWZlcmVuY2VcIjtcbi8qKlxuICogRGVmaW5lcyBhIGNsYXNzIHJlZmVyZW5jZSBub2RlXG4gKiBAY29uc3RydWN0b3IgVHlwZVJlZmVyZW5jZVxuICogQGV4dGVuZHMge1JlZmVyZW5jZX1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lXG4gKi9cblxudmFyIFR5cGVSZWZlcmVuY2UgPSBSZWZlcmVuY2VbXCJleHRlbmRzXCJdKEtJTkQsIGZ1bmN0aW9uIFR5cGVSZWZlcmVuY2UobmFtZSwgcmF3LCBkb2NzLCBsb2NhdGlvbikge1xuICBSZWZlcmVuY2UuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMucmF3ID0gcmF3O1xufSk7XG5UeXBlUmVmZXJlbmNlLnR5cGVzID0gW1wiaW50XCIsIFwiZmxvYXRcIiwgXCJzdHJpbmdcIiwgXCJib29sXCIsIFwib2JqZWN0XCIsIFwiYXJyYXlcIiwgXCJjYWxsYWJsZVwiLCBcIml0ZXJhYmxlXCIsIFwidm9pZFwiXTtcbm1vZHVsZS5leHBvcnRzID0gVHlwZVJlZmVyZW5jZTtcblxuLyoqKi8gfSksXG4vKiAxMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgT3BlcmF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEtJTkQgPSBcInVuYXJ5XCI7XG4vKipcbiAqIFVuYXJ5IG9wZXJhdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBVbmFyeVxuICogQGV4dGVuZHMge09wZXJhdGlvbn1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlXG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb259IHdoYXRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wZXJhdGlvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gVW5hcnkodHlwZSwgd2hhdCwgZG9jcywgbG9jYXRpb24pIHtcbiAgT3BlcmF0aW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLndoYXQgPSB3aGF0O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJ1bnNldFwiO1xuLyoqXG4gKiBEZWxldGVzIHJlZmVyZW5jZXMgdG8gYSBsaXN0IG9mIHZhcmlhYmxlc1xuICogQGNvbnN0cnVjdG9yIFVuc2V0XG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVtZW50W1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBVbnNldCh2YXJpYWJsZXMsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgU3RhdGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtJTkQgPSBcInVzZWdyb3VwXCI7XG4vKipcbiAqIERlZmluZXMgYSB1c2Ugc3RhdGVtZW50ICh3aXRoIGEgbGlzdCBvZiB1c2UgaXRlbXMpXG4gKiBAY29uc3RydWN0b3IgVXNlR3JvdXBcbiAqIEBleHRlbmRzIHtTdGF0ZW1lbnR9XG4gKiBAcHJvcGVydHkge1N0cmluZ3xudWxsfSBuYW1lXG4gKiBAcHJvcGVydHkge1N0cmluZ3xudWxsfSB0eXBlIC0gUG9zc2libGUgdmFsdWUgOiBmdW5jdGlvbiwgY29uc3RcbiAqIEBwcm9wZXJ0eSB7VXNlSXRlbVtdfSBpdGVtXG4gKiBAc2VlIHtOYW1lc3BhY2V9XG4gKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9sYW5ndWFnZS5uYW1lc3BhY2VzLmltcG9ydGluZy5waHBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gVXNlR3JvdXAobmFtZSwgdHlwZSwgaXRlbXMsIGRvY3MsIGxvY2F0aW9uKSB7XG4gIFN0YXRlbWVudC5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIFN0YXRlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBLSU5EID0gXCJ1c2VpdGVtXCI7XG4vKipcbiAqIERlZmluZXMgYSB1c2Ugc3RhdGVtZW50IChmcm9tIG5hbWVzcGFjZSlcbiAqIEBjb25zdHJ1Y3RvciBVc2VJdGVtXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtTdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfG51bGx9IHR5cGUgLSBQb3NzaWJsZSB2YWx1ZSA6IGZ1bmN0aW9uLCBjb25zdFxuICogQHByb3BlcnR5IHtJZGVudGlmaWVyfG51bGx9IGFsaWFzXG4gKiBAc2VlIHtOYW1lc3BhY2V9XG4gKiBAc2VlIGh0dHA6Ly9waHAubmV0L21hbnVhbC9lbi9sYW5ndWFnZS5uYW1lc3BhY2VzLmltcG9ydGluZy5waHBcbiAqL1xuXG52YXIgVXNlSXRlbSA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gVXNlSXRlbShuYW1lLCBhbGlhcywgdHlwZSwgZG9jcywgbG9jYXRpb24pIHtcbiAgU3RhdGVtZW50LmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmFsaWFzID0gYWxpYXM7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG59KTtcbi8qKlxuICogSW1wb3J0aW5nIGEgY29uc3RhbnRcbiAqIEBjb25zdGFudCB7U3RyaW5nfSBUWVBFX0NPTlNUXG4gKi9cblxuVXNlSXRlbS5UWVBFX0NPTlNUID0gXCJjb25zdFwiO1xuLyoqXG4gKiBJbXBvcnRpbmcgYSBmdW5jdGlvblxuICogQGNvbnN0YW50IHtTdHJpbmd9IFRZUEVfRlVOQ1xuICovXG5cblVzZUl0ZW0uVFlQRV9GVU5DVElPTiA9IFwiZnVuY3Rpb25cIjtcbm1vZHVsZS5leHBvcnRzID0gVXNlSXRlbTtcblxuLyoqKi8gfSksXG4vKiAxMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoQykgMjAxOCBHbGF5enpsZSAoQlNEMyBMaWNlbnNlKVxuICogQGF1dGhvcnMgaHR0cHM6Ly9naXRodWIuY29tL2dsYXl6emxlL3BocC1wYXJzZXIvZ3JhcGhzL2NvbnRyaWJ1dG9yc1xuICogQHVybCBodHRwOi8vZ2xheXp6bGUuY29tXG4gKi9cblxuXG52YXIgRXhwcmVzc2lvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBLSU5EID0gXCJ2YXJpYWJsZVwiO1xuLyoqXG4gKiBBbnkgZXhwcmVzc2lvbiBub2RlLiBTaW5jZSB0aGUgbGVmdC1oYW5kIHNpZGUgb2YgYW4gYXNzaWdubWVudCBtYXlcbiAqIGJlIGFueSBleHByZXNzaW9uIGluIGdlbmVyYWwsIGFuIGV4cHJlc3Npb24gY2FuIGFsc28gYmUgYSBwYXR0ZXJuLlxuICogQGNvbnN0cnVjdG9yIFZhcmlhYmxlXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBleGFtcGxlXG4gKiAvLyBQSFAgY29kZSA6XG4gKiAkZm9vXG4gKiAvLyBBU1Qgb3V0cHV0XG4gKiB7XG4gKiAgXCJraW5kXCI6IFwidmFyaWFibGVcIixcbiAqICBcIm5hbWVcIjogXCJmb29cIixcbiAqICBcImN1cmx5XCI6IGZhbHNlXG4gKiB9XG4gKiBAcHJvcGVydHkge1N0cmluZ3xOb2RlfSBuYW1lIFRoZSB2YXJpYWJsZSBuYW1lIChjYW4gYmUgYSBjb21wbGV4IGV4cHJlc3Npb24gd2hlbiB0aGUgbmFtZSBpcyByZXNvbHZlZCBkeW5hbWljYWxseSlcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY3VybHkgSW5kaWNhdGUgaWYgdGhlIG5hbWUgaXMgZGVmaW5lZCBiZXR3ZWVuIGN1cmxpZXMsIGV4IGAke2Zvb31gXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFeHByZXNzaW9uW1wiZXh0ZW5kc1wiXShLSU5ELCBmdW5jdGlvbiBWYXJpYWJsZShuYW1lLCBjdXJseSwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5jdXJseSA9IGN1cmx5IHx8IGZhbHNlO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwidmFyaWFkaWNcIjtcbi8qKlxuICogSW50cm9kdWNlIGEgbGlzdCBvZiBpdGVtcyBpbnRvIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNhbGxcbiAqIEBjb25zdHJ1Y3RvciB2YXJpYWRpY1xuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0FycmF5fEV4cHJlc3Npb259IHdoYXRcbiAqIEBzZWUgaHR0cHM6Ly93aWtpLnBocC5uZXQvcmZjL2FyZ3VtZW50X3VucGFja2luZ1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gdmFyaWFkaWMod2hhdCwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy53aGF0ID0gd2hhdDtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBTdGF0ZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgS0lORCA9IFwid2hpbGVcIjtcbi8qKlxuICogRGVmaW5lcyBhIHdoaWxlIHN0YXRlbWVudFxuICogQGNvbnN0cnVjdG9yIFdoaWxlXG4gKiBAZXh0ZW5kcyB7U3RhdGVtZW50fVxuICogQHByb3BlcnR5IHtFeHByZXNzaW9ufSB0ZXN0XG4gKiBAcHJvcGVydHkge1N0YXRlbWVudH0gYm9keVxuICogQHByb3BlcnR5IHtib29sZWFufSBzaG9ydEZvcm1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlbWVudFtcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gV2hpbGUodGVzdCwgYm9keSwgc2hvcnRGb3JtLCBkb2NzLCBsb2NhdGlvbikge1xuICBTdGF0ZW1lbnQuYXBwbHkodGhpcywgW0tJTkQsIGRvY3MsIGxvY2F0aW9uXSk7XG4gIHRoaXMudGVzdCA9IHRlc3Q7XG4gIHRoaXMuYm9keSA9IGJvZHk7XG4gIHRoaXMuc2hvcnRGb3JtID0gc2hvcnRGb3JtO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggR2xheXp6bGUgKEJTRDMgTGljZW5zZSlcbiAqIEBhdXRob3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGF5enpsZS9waHAtcGFyc2VyL2dyYXBocy9jb250cmlidXRvcnNcbiAqIEB1cmwgaHR0cDovL2dsYXl6emxlLmNvbVxuICovXG5cblxudmFyIEV4cHJlc3Npb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgS0lORCA9IFwieWllbGRcIjtcbi8qKlxuICogRGVmaW5lcyBhIHlpZWxkIGdlbmVyYXRvciBzdGF0ZW1lbnRcbiAqIEBjb25zdHJ1Y3RvciBZaWVsZFxuICogQGV4dGVuZHMge0V4cHJlc3Npb259XG4gKiBAcHJvcGVydHkge0V4cHJlc3Npb258TnVsbH0gdmFsdWVcbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbnxOdWxsfSBrZXlcbiAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2xhbmd1YWdlLmdlbmVyYXRvcnMuc3ludGF4LnBocFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gWWllbGQodmFsdWUsIGtleSwgZG9jcywgbG9jYXRpb24pIHtcbiAgRXhwcmVzc2lvbi5hcHBseSh0aGlzLCBbS0lORCwgZG9jcywgbG9jYXRpb25dKTtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmtleSA9IGtleTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChDKSAyMDE4IEdsYXl6emxlIChCU0QzIExpY2Vuc2UpXG4gKiBAYXV0aG9ycyBodHRwczovL2dpdGh1Yi5jb20vZ2xheXp6bGUvcGhwLXBhcnNlci9ncmFwaHMvY29udHJpYnV0b3JzXG4gKiBAdXJsIGh0dHA6Ly9nbGF5enpsZS5jb21cbiAqL1xuXG5cbnZhciBFeHByZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIEtJTkQgPSBcInlpZWxkZnJvbVwiO1xuLyoqXG4gKiBEZWZpbmVzIGEgeWllbGQgZnJvbSBnZW5lcmF0b3Igc3RhdGVtZW50XG4gKiBAY29uc3RydWN0b3IgWWllbGRGcm9tXG4gKiBAZXh0ZW5kcyB7RXhwcmVzc2lvbn1cbiAqIEBwcm9wZXJ0eSB7RXhwcmVzc2lvbn0gdmFsdWVcbiAqIEBzZWUgaHR0cDovL3BocC5uZXQvbWFudWFsL2VuL2xhbmd1YWdlLmdlbmVyYXRvcnMuc3ludGF4LnBocFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRXhwcmVzc2lvbltcImV4dGVuZHNcIl0oS0lORCwgZnVuY3Rpb24gWWllbGRGcm9tKHZhbHVlLCBkb2NzLCBsb2NhdGlvbikge1xuICBFeHByZXNzaW9uLmFwcGx5KHRoaXMsIFtLSU5ELCBkb2NzLCBsb2NhdGlvbl0pO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59KTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pW1wiZGVmYXVsdFwiXTtcbn0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/php-parser/dist/php-parser.js\n");

/***/ })

}]);