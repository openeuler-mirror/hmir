(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[80],{

/***/ "./node_modules/@humanwhocodes/momoa/api.js":
/*!**************************************************!*\
  !*** ./node_modules/@humanwhocodes/momoa/api.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\n * @fileoverview JSON syntax helpers\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Predefined Tokens\n//-----------------------------------------------------------------------------\n\nconst LBRACKET = \"[\";\nconst RBRACKET = \"]\";\nconst LBRACE = \"{\";\nconst RBRACE = \"}\";\nconst COLON = \":\";\nconst COMMA = \",\";\n\nconst TRUE = \"true\";\nconst FALSE = \"false\";\nconst NULL = \"null\";\n\nconst QUOTE = \"\\\"\";\n\nconst expectedKeywords = new Map([\n    [\"t\", TRUE],\n    [\"f\", FALSE],\n    [\"n\", NULL]\n]);\n\nconst escapeToChar = new Map([\n    [QUOTE, QUOTE],\n    [\"\\\\\", \"\\\\\"],\n    [\"/\", \"/\"],\n    [\"b\", \"\\b\"],\n    [\"n\", \"\\n\"],\n    [\"f\", \"\\f\"],\n    [\"r\", \"\\r\"],\n    [\"t\", \"\\t\"]\n]);\n\nconst knownTokenTypes = new Map([\n    [LBRACKET, \"Punctuator\"],\n    [RBRACKET, \"Punctuator\"],\n    [LBRACE, \"Punctuator\"],\n    [RBRACE, \"Punctuator\"],\n    [COLON, \"Punctuator\"],\n    [COMMA, \"Punctuator\"],\n    [TRUE, \"Boolean\"],\n    [FALSE, \"Boolean\"],\n    [NULL, \"Null\"]\n]);\n\n/**\n * @fileoverview JSON tokenization/parsing errors\n * @author Nicholas C. Zakas\n */\n\n\n/**\n * Base class that attaches location to an error.\n */\nclass ErrorWithLocation extends Error {\n\n    /**\n     * \n     * @param {string} message The error message to report. \n     * @param {int} loc.line The line on which the error occurred.\n     * @param {int} loc.column The column in the line where the error occurrred.\n     * @param {int} loc.index The index in the string where the error occurred.\n     */\n    constructor(message, { line, column, index }) {\n        super(`${ message } (${ line }:${ column})`);\n\n        /**\n         * The line on which the error occurred.\n         * @type int\n         * @property line\n         */\n        this.line = line;\n\n        /**\n         * The column on which the error occurred.\n         * @type int\n         * @property column\n         */\n        this.column = column;\n        \n        /**\n         * The index into the string where the error occurred.\n         * @type int\n         * @property index\n         */\n        this.index = index;\n    }\n\n}\n\n/**\n * Error thrown when an unexpected character is found during tokenizing.\n */\nclass UnexpectedChar extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(unexpected, loc) {\n        super(`Unexpected character ${ unexpected } found.`, loc);\n    }\n}\n\n/**\n * Error thrown when an unexpected token is found during parsing.\n */\nclass UnexpectedToken extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {string} expected The character that was expected. \n     * @param {string} unexpected The character that was found.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(token) {\n        super(`Unexpected token ${ token.type }(${ token.value }) found.`, token.loc.start);\n    }\n}\n\n/**\n * Error thrown when the end of input is found where it isn't expected.\n */\nclass UnexpectedEOF extends ErrorWithLocation {\n\n    /**\n     * Creates a new instance.\n     * @param {Object} loc The location information for the found character.\n     */\n    constructor(loc) {\n        super(\"Unexpected end of input found.\", loc);\n    }\n}\n\n/**\n * @fileoverview JSON tokenizer\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst QUOTE$1 = \"\\\"\";\nconst SLASH = \"/\";\nconst STAR = \"*\";\n\nconst DEFAULT_OPTIONS = {\n    comments: false,\n    ranges: false\n};\n\nfunction isWhitespace(c) {\n    return /[\\s\\n]/.test(c);\n}\n\nfunction isDigit(c) {\n    return c >= \"0\" && c <= \"9\";\n}\n\nfunction isHexDigit(c) {\n    return isDigit(c) || /[a-f]/i.test(c);\n}\n\nfunction isPositiveDigit(c) {\n    return c >= \"1\" && c <= \"9\";\n}\n\nfunction isKeywordStart(c) {\n    return /[tfn]/.test(c);\n}\n\nfunction isNumberStart(c) {\n    return isDigit(c) || c === \".\" || c === \"-\";\n}\n\n//-----------------------------------------------------------------------------\n// Main\n//-----------------------------------------------------------------------------\n\n/**\n * Creates an iterator over the tokens representing the source text.\n * @param {string} text The source text to tokenize.\n * @returns {Iterator} An iterator over the tokens. \n */\nfunction tokenize(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS,\n        ...options\n    });\n\n    let offset = -1;\n    let line = 1;\n    let column = 0;\n    let newLine = false;\n\n    const tokens = [];\n\n\n    function createToken(tokenType, value, startLoc, endLoc) {\n        \n        const endOffset = startLoc.offset + value.length;\n        let range = options.ranges ? {\n            range: [startLoc.offset, endOffset]\n        } : undefined;\n        \n        return {\n            type: tokenType,\n            value,\n            loc: {\n                start: startLoc,\n                end: endLoc || {\n                    line: startLoc.line,\n                    column: startLoc.column + value.length,\n                    offset: endOffset\n                }\n            },\n            ...range\n        };\n    }\n\n    function next() {\n        let c = text.charAt(++offset);\n    \n        if (newLine) {\n            line++;\n            column = 1;\n            newLine = false;\n        } else {\n            column++;\n        }\n\n        if (c === \"\\r\") {\n            newLine = true;\n\n            // if we already see a \\r, just ignore upcoming \\n\n            if (text.charAt(offset + 1) === \"\\n\") {\n                offset++;\n            }\n        } else if (c === \"\\n\") {\n            newLine = true;\n        }\n\n        return c;\n    }\n\n    function locate() {\n        return {\n            line,\n            column,\n            offset\n        };\n    }\n\n    function readKeyword(c) {\n\n        // get the expected keyword\n        let value = expectedKeywords.get(c);\n\n        // check to see if it actually exists\n        if (text.slice(offset, offset + value.length) === value) {\n            offset += value.length - 1;\n            column += value.length - 1;\n            return { value, c: next() };\n        }\n\n        // find the first unexpected character\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] !== text.charAt(offset + j)) {\n                unexpected(next());\n            }\n        }\n\n    }\n\n    function readString(c) {\n        let value = c;\n        c = next();\n\n        while (c && c !== QUOTE$1) {\n\n            // escapes\n            if (c === \"\\\\\") {\n                value += c;\n                c = next();\n\n                if (escapeToChar.has(c)) {\n                    value += c;\n                } else if (c === \"u\") {\n                    value += c;\n                    for (let i = 0; i < 4; i++) {\n                        c = next();\n                        if (isHexDigit(c)) {\n                            value += c;\n                        } else {\n                            unexpected(c);\n                        }\n                    }\n                } else {\n                    unexpected(c);\n                }\n            } else {\n                value += c;\n            }\n\n            c = next();\n        }\n\n        if (!c) {\n            unexpectedEOF();\n        }\n        \n        value += c;\n\n        return { value, c: next() };\n    }\n\n\n    function readNumber(c) {\n\n        let value = \"\";\n\n        // Number may start with a minus but not a plus\n        if (c === \"-\") {\n\n            value += c;\n\n            c = next();\n\n            // Next digit cannot be zero\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n        }\n\n        // Zero must be followed by a decimal point or nothing\n        if (c === \"0\") {\n\n            value += c;\n\n            c = next();\n            if (isDigit(c)) {\n                unexpected(c);\n            }\n\n        } else {\n            if (!isPositiveDigit(c)) {\n                unexpected(c);\n            }\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Decimal point may be followed by any number of digits\n        if (c === \".\") {\n\n            do {\n                value += c;\n                c = next();\n            } while (isDigit(c));\n        }\n\n        // Exponent is always last\n        if (c === \"e\" || c === \"E\") {\n\n            value += c;\n            c = next();\n\n            if (c === \"+\" || c === \"-\") {\n                value += c;\n                c = next();\n            }\n\n            /*\n             * Must always have a digit in this position to avoid:\n             * 5e\n             * 12E+\n             * 42e-\n             */\n            if (!isDigit(c)) {\n                unexpected(c);\n            }\n\n            while (isDigit(c)) {\n                value += c;\n                c = next();\n            }\n        }\n\n\n        return { value, c };\n    }\n\n    /**\n     * Reads in either a single-line or multi-line comment.\n     * @param {string} c The first character of the comment.\n     * @returns {string} The comment string.\n     * @throws {UnexpectedChar} when the comment cannot be read.\n     * @throws {UnexpectedEOF} when EOF is reached before the comment is\n     *      finalized.\n     */\n    function readComment(c) {\n\n        let value = c;\n\n        // next character determines single- or multi-line\n        c = next();\n\n        // single-line comments\n        if (c === \"/\") {\n            \n            do {\n                value += c;\n                c = next();\n            } while (c && c !== \"\\r\" && c !== \"\\n\");\n\n            return { value, c };\n        }\n\n        // multi-line comments\n        if (c === STAR) {\n\n            while (c) {\n                value += c;\n                c = next();\n\n                // check for end of comment\n                if (c === STAR) {\n                    value += c;\n                    c = next();\n                    \n                    //end of comment\n                    if (c === SLASH) {\n                        value += c;\n\n                        /*\n                         * The single-line comment functionality cues up the\n                         * next character, so we do the same here to avoid\n                         * splitting logic later.\n                         */\n                        c = next();\n                        return { value, c };\n                    }\n                }\n            }\n\n            unexpectedEOF();\n            \n        }\n\n        // if we've made it here, there's an invalid character\n        unexpected(c);        \n    }\n\n\n    /**\n     * Convenience function for throwing unexpected character errors.\n     * @param {string} c The unexpected character.\n     * @returns {void}\n     * @throws {UnexpectedChar} always.\n     */\n    function unexpected(c) {\n        throw new UnexpectedChar(c, locate());\n    }\n\n    /**\n     * Convenience function for throwing unexpected EOF errors.\n     * @returns {void}\n     * @throws {UnexpectedEOF} always.\n     */\n    function unexpectedEOF() {\n        throw new UnexpectedEOF(locate());\n    }\n\n    let c = next();\n\n    while (offset < text.length) {\n\n        while (isWhitespace(c)) {\n            c = next();\n        }\n\n        if (!c) {\n            break;\n        }\n\n        const start = locate();\n\n        // check for easy case\n        if (knownTokenTypes.has(c)) {\n            tokens.push(createToken(knownTokenTypes.get(c), c, start));\n            c = next();\n        } else if (isKeywordStart(c)) {\n            const result = readKeyword(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(knownTokenTypes.get(value), value, start));\n        } else if (isNumberStart(c)) {\n            const result = readNumber(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"Number\", value, start));\n        } else if (c === QUOTE$1) {\n            const result = readString(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(\"String\", value, start));\n        } else if (c === SLASH && options.comments) {\n            const result = readComment(c);\n            let value = result.value;\n            c = result.c;\n            tokens.push(createToken(value.startsWith(\"//\") ? \"LineComment\" : \"BlockComment\", value, start, locate()));\n        } else {\n            unexpected(c);\n        }\n    }\n\n    return tokens;\n\n}\n\n/**\n * @fileoverview Momoa JSON AST types\n * @author Nicholas C. Zakas\n */\n\nconst types = {\n    document(body, parts = {}) {\n        return {\n            type: \"Document\",\n            body,\n            ...parts\n        };\n    },\n    string(value, parts = {}) {\n        return {\n            type: \"String\",\n            value,\n            ...parts\n        };\n    },\n    number(value, parts = {}) {\n        return {\n            type: \"Number\",\n            value,\n            ...parts\n        };\n    },\n    boolean(value, parts = {}) {\n        return {\n            type: \"Boolean\",\n            value,\n            ...parts\n        };\n    },\n    null(parts = {}) {\n        return {\n            type: \"Null\",\n            value: \"null\",\n            ...parts\n        };\n    },\n    array(elements, parts = {}) {\n        return {\n            type: \"Array\",\n            elements,\n            ...parts\n        };\n    },\n    object(members, parts = {}) {\n        return {\n            type: \"Object\",\n            members,\n            ...parts\n        };\n    },\n    member(name, value, parts = {}) {\n        return {\n            type: \"Member\",\n            name,\n            value,\n            ...parts\n        };\n    },\n\n};\n\n/**\n * @fileoverview JSON parser\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst DEFAULT_OPTIONS$1 = {\n    tokens: false,\n    comments: false,\n    ranges: false\n};\n\n/**\n * Converts a JSON-encoded string into a JavaScript string, interpreting each\n * escape sequence.\n * @param {Token} token The string token to convert into a JavaScript string.\n * @returns {string} A JavaScript string.\n */\nfunction getStringValue(token) {\n    \n    // slice off the quotation marks\n    let value = token.value.slice(1, -1);\n    let result = \"\";\n    let escapeIndex = value.indexOf(\"\\\\\");\n    let lastIndex = 0;\n\n    // While there are escapes, interpret them to build up the result\n    while (escapeIndex >= 0) {\n\n        // append the text that happened before the escape\n        result += value.slice(lastIndex, escapeIndex);\n\n        // get the character immediately after the \\\n        const escapeChar = value.charAt(escapeIndex + 1);\n        \n        // check for the non-Unicode escape sequences first\n        if (escapeToChar.has(escapeChar)) {\n            result += escapeToChar.get(escapeChar);\n            lastIndex = escapeIndex + 2;\n        } else if (escapeChar === \"u\") {\n            const hexCode = value.slice(escapeIndex + 2, escapeIndex + 6);\n            if (hexCode.length < 4 || /[^0-9a-f]/i.test(hexCode)) {\n                throw new ErrorWithLocation(\n                    `Invalid unicode escape \\\\u${ hexCode}.`,\n                    {\n                        line: token.loc.start.line,\n                        column: token.loc.start.column + escapeIndex,\n                        offset: token.loc.start.offset + escapeIndex\n                    }\n                );\n            }\n            \n            result += String.fromCharCode(parseInt(hexCode, 16));\n            lastIndex = escapeIndex + 6;\n        } else {\n            throw new ErrorWithLocation(\n                `Invalid escape \\\\${ escapeChar }.`,\n                {\n                    line: token.loc.start.line,\n                    column: token.loc.start.column + escapeIndex,\n                    offset: token.loc.start.offset + escapeIndex\n                }\n            );\n        }\n\n        // find the next escape sequence\n        escapeIndex = value.indexOf(\"\\\\\", lastIndex);\n    }\n\n    // get the last segment of the string value\n    result += value.slice(lastIndex);\n\n    return result;\n}\n\n/**\n * Gets the JavaScript value represented by a JSON token.\n * @param {Token} token The JSON token to get a value for.\n * @returns {*} A number, string, boolean, or `null`. \n */\nfunction getLiteralValue(token) {\n    switch (token.type) {\n    case \"Boolean\":\n        return token.value === \"true\";\n        \n    case \"Number\":\n        return Number(token.value);\n\n    case \"Null\":\n        return null;\n\n    case \"String\":\n        return getStringValue(token);\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main Function\n//-----------------------------------------------------------------------------\n\n/**\n * \n * @param {string} text The text to parse.\n * @param {boolean} [options.tokens=false] Determines if tokens are returned in\n *      the AST. \n * @param {boolean} [options.comments=false] Determines if comments are allowed\n *      in the JSON.\n * @param {boolean} [options.ranges=false] Determines if ranges will be returned\n *      in addition to `loc` properties.\n * @returns {Object} The AST representing the parsed JSON.\n * @throws {Error} When there is a parsing error. \n */\nfunction parse(text, options) {\n\n    options = Object.freeze({\n        ...DEFAULT_OPTIONS$1,\n        ...options\n    });\n\n    const tokens = tokenize(text, {\n        comments: !!options.comments,\n        ranges: !!options.ranges\n    });\n    let tokenIndex = 0;\n\n    function nextNoComments() {\n        return tokens[tokenIndex++];\n    }\n    \n    function nextSkipComments() {\n        const nextToken = tokens[tokenIndex++];\n        if (nextToken && nextToken.type.endsWith(\"Comment\")) {\n            return nextSkipComments();\n        }\n\n        return nextToken;\n\n    }\n\n    // determine correct way to evaluate tokens based on presence of comments\n    const next = options.comments ? nextSkipComments : nextNoComments;\n\n    function assertTokenValue(token, value) {\n        if (!token || token.value !== value) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function assertTokenType(token, type) {\n        if (!token || token.type !== type) {\n            throw new UnexpectedToken(token);\n        }\n    }\n\n    function createRange(start, end) {\n        return options.ranges ? {\n            range: [start.offset, end.offset]\n        } : undefined;\n    }\n\n    function createLiteralNode(token) {\n        const range = createRange(token.loc.start, token.loc.end);\n\n        return {\n            type: token.type,\n            value: getLiteralValue(token),\n            loc: {\n                start: {\n                    ...token.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        };\n    }\n\n\n    function parseProperty(token) {\n        assertTokenType(token, \"String\");\n        const name = createLiteralNode(token);\n\n        token = next();\n        assertTokenValue(token, \":\");\n        const value = parseValue();\n        const range = createRange(name.loc.start, value.loc.end);\n\n        return types.member(name, value, {\n            loc: {\n                start: {\n                    ...name.loc.start\n                },\n                end: {\n                    ...value.loc.end\n                }\n            },\n            ...range\n        });\n    }\n\n    function parseObject(firstToken) {\n\n        // The first token must be a { or else it's an error\n        assertTokenValue(firstToken, \"{\");\n\n        const members = [];\n        let token = next();\n\n        if (token && token.value !== \"}\") {\n            do {\n    \n                // add the value into the array\n                members.push(parseProperty(token));\n    \n                token = next();\n    \n                if (token.value === \",\") {\n                    token = next();\n                } else {\n                    break;\n                }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"}\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.object(members, {\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n    function parseArray(firstToken) {\n\n        // The first token must be a [ or else it's an error\n        assertTokenValue(firstToken, \"[\");\n\n        const elements = [];\n        let token = next();\n        \n        if (token && token.value !== \"]\") {\n\n            do {\n\n              // add the value into the array\n              elements.push(parseValue(token));\n\n              token = next();\n              \n              if (token.value === \",\") {\n                  token = next();\n              } else {\n                  break;\n              }\n            } while (token);\n        }\n\n        assertTokenValue(token, \"]\");\n        const range = createRange(firstToken.loc.start, token.loc.end);\n\n        return types.array(elements, {\n            type: \"Array\",\n            elements,\n            loc: {\n                start: {\n                    ...firstToken.loc.start\n                },\n                end: {\n                    ...token.loc.end\n                }\n            },\n            ...range\n        });\n\n    }\n\n\n\n    function parseValue(token) {\n\n        token = token || next();\n        \n        switch (token.type) {\n        case \"String\":\n        case \"Boolean\":\n        case \"Number\":\n        case \"Null\":\n            return createLiteralNode(token);\n\n        case \"Punctuator\":\n            if (token.value === \"{\") {\n                return parseObject(token);\n            } else if (token.value === \"[\") {\n                return parseArray(token);\n            }\n            /*falls through*/\n\n        default:\n            throw new UnexpectedToken(token);\n        }\n\n    }\n\n    \n    const docBody = parseValue();\n    \n    const unexpectedToken = next();\n    if (unexpectedToken) {\n        throw new UnexpectedToken(unexpectedToken);\n    }\n    \n    \n    const docParts = {\n        loc: {\n            start: {\n                line: 1,\n                column: 1,\n                offset: 0\n            },\n            end: {\n                ...docBody.loc.end\n            }\n        }\n    };\n    \n\n    if (options.tokens) {\n        docParts.tokens = tokens;\n    }\n\n    if (options.ranges) {\n        docParts.range = createRange(docParts.loc.start, docParts.loc.end);\n    }\n\n    return types.document(docBody, docParts);\n\n}\n\n/**\n * @fileoverview Traversal approaches for Momoa JSON AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Data\n//-----------------------------------------------------------------------------\n\nconst childKeys = new Map([\n    [\"Document\", [\"body\"]],\n    [\"Object\", [\"members\"]],\n    [\"Member\", [\"name\", \"value\"]],\n    [\"Array\", [\"elements\"]],\n    [\"String\", []],\n    [\"Number\", []],\n    [\"Boolean\", []],\n    [\"Null\", []]\n]);\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Determines if a given value is an object.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is an object, false if not. \n */\nfunction isObject(value) {\n    return value && (typeof value === \"object\");\n}\n\n/**\n * Determines if a given value is an AST node.\n * @param {*} value The value to check.\n * @returns {boolean} True if the value is a node, false if not. \n */\nfunction isNode(value) {\n    return isObject(value) && (typeof value.type === \"string\");\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Traverses an AST from the given node.\n * @param {Node} root The node to traverse from \n * @param {Object} visitor An object with an `enter` and `exit` method. \n */\nfunction traverse(root, visitor) {\n\n    /**\n     * Recursively visits a node.\n     * @param {Node} node The node to visit.\n     * @param {Node} parent The parent of the node to visit.\n     * @returns {void}\n     */\n    function visitNode(node, parent) {\n\n        if (typeof visitor.enter === \"function\") {\n            visitor.enter(node, parent);\n        }\n\n        for (const key of childKeys.get(node.type)) {\n            const value = node[key];\n\n            if (isObject(value)) {\n                if (Array.isArray(value)) {\n                    value.forEach(child => visitNode(child, node));\n                } else if (isNode(value)) {\n                    visitNode(value, node);\n                }\n            }\n        }\n\n        if (typeof visitor.exit === \"function\") {\n            visitor.exit(node, parent);\n        }\n    }\n\n    visitNode(root);\n}\n\n/**\n * Creates an iterator over the given AST.\n * @param {Node} root The root AST node to traverse. \n * @param {Function} [filter] A filter function to determine which steps to\n *      return;\n * @returns {Iterator} An iterator over the AST.  \n */\nfunction iterator(root, filter = () => true) {\n\n    const traversal = [];\n\n    traverse(root, {\n        enter(node, parent) {\n            traversal.push({ node, parent, phase: \"enter\" });\n        },\n        exit(node, parent) {\n            traversal.push({ node, parent, phase: \"exit\" });\n        }\n    });\n\n    return traversal.filter(filter).values();\n}\n\n/**\n * @fileoverview Evaluator for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Evaluates a Momoa AST node into a JavaScript value.\n * @param {Node} node The node to interpet.\n * @returns {*} The JavaScript value for the node. \n */\nfunction evaluate(node) {\n    switch (node.type) {\n    case \"String\":\n    case \"Number\":\n    case \"Boolean\":\n        return node.value;\n\n    case \"Null\":\n        return null;\n\n    case \"Array\":\n        return node.elements.map(evaluate);\n\n    case \"Object\": {\n\n        const object = {};\n\n        node.members.forEach(member => {\n            object[evaluate(member.name)] = evaluate(member.value);\n        });    \n\n        return object;\n    }    \n\n    case \"Document\":\n        return evaluate(node.body);\n\n    case \"Property\":\n        throw new Error(\"Cannot evaluate object property outside of an object.\");\n\n    default:\n        throw new Error(`Unknown node type ${ node.type }.`);\n    }\n}\n\n/**\n * @fileoverview Printer for Momoa AST.\n * @author Nicholas C. Zakas\n */\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Converts a Momoa AST back into a JSON string.\n * @param {Node} node The node to print.\n * @param {int} [options.indent=0] The number of spaces to indent each line. If\n *      greater than 0, then newlines and indents will be added to output. \n * @returns {string} The JSON representation of the AST.\n */\nfunction print(node, { indent = 0 } = {}) {\n    const value = evaluate(node);\n    return JSON.stringify(value, null, indent);\n}\n\n/**\n * @fileoverview File defining the interface of the package.\n * @author Nicholas C. Zakas\n */\n\nexports.evaluate = evaluate;\nexports.iterator = iterator;\nexports.parse = parse;\nexports.print = print;\nexports.tokenize = tokenize;\nexports.traverse = traverse;\nexports.types = types;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGh1bWFud2hvY29kZXMvbW9tb2EvYXBpLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BodW1hbndob2NvZGVzL21vbW9hL2FwaS5qcz9jM2Y1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEpTT04gc3ludGF4IGhlbHBlcnNcbiAqIEBhdXRob3IgTmljaG9sYXMgQy4gWmFrYXNcbiAqL1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcmVkZWZpbmVkIFRva2Vuc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBMQlJBQ0tFVCA9IFwiW1wiO1xuY29uc3QgUkJSQUNLRVQgPSBcIl1cIjtcbmNvbnN0IExCUkFDRSA9IFwie1wiO1xuY29uc3QgUkJSQUNFID0gXCJ9XCI7XG5jb25zdCBDT0xPTiA9IFwiOlwiO1xuY29uc3QgQ09NTUEgPSBcIixcIjtcblxuY29uc3QgVFJVRSA9IFwidHJ1ZVwiO1xuY29uc3QgRkFMU0UgPSBcImZhbHNlXCI7XG5jb25zdCBOVUxMID0gXCJudWxsXCI7XG5cbmNvbnN0IFFVT1RFID0gXCJcXFwiXCI7XG5cbmNvbnN0IGV4cGVjdGVkS2V5d29yZHMgPSBuZXcgTWFwKFtcbiAgICBbXCJ0XCIsIFRSVUVdLFxuICAgIFtcImZcIiwgRkFMU0VdLFxuICAgIFtcIm5cIiwgTlVMTF1cbl0pO1xuXG5jb25zdCBlc2NhcGVUb0NoYXIgPSBuZXcgTWFwKFtcbiAgICBbUVVPVEUsIFFVT1RFXSxcbiAgICBbXCJcXFxcXCIsIFwiXFxcXFwiXSxcbiAgICBbXCIvXCIsIFwiL1wiXSxcbiAgICBbXCJiXCIsIFwiXFxiXCJdLFxuICAgIFtcIm5cIiwgXCJcXG5cIl0sXG4gICAgW1wiZlwiLCBcIlxcZlwiXSxcbiAgICBbXCJyXCIsIFwiXFxyXCJdLFxuICAgIFtcInRcIiwgXCJcXHRcIl1cbl0pO1xuXG5jb25zdCBrbm93blRva2VuVHlwZXMgPSBuZXcgTWFwKFtcbiAgICBbTEJSQUNLRVQsIFwiUHVuY3R1YXRvclwiXSxcbiAgICBbUkJSQUNLRVQsIFwiUHVuY3R1YXRvclwiXSxcbiAgICBbTEJSQUNFLCBcIlB1bmN0dWF0b3JcIl0sXG4gICAgW1JCUkFDRSwgXCJQdW5jdHVhdG9yXCJdLFxuICAgIFtDT0xPTiwgXCJQdW5jdHVhdG9yXCJdLFxuICAgIFtDT01NQSwgXCJQdW5jdHVhdG9yXCJdLFxuICAgIFtUUlVFLCBcIkJvb2xlYW5cIl0sXG4gICAgW0ZBTFNFLCBcIkJvb2xlYW5cIl0sXG4gICAgW05VTEwsIFwiTnVsbFwiXVxuXSk7XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBKU09OIHRva2VuaXphdGlvbi9wYXJzaW5nIGVycm9yc1xuICogQGF1dGhvciBOaWNob2xhcyBDLiBaYWthc1xuICovXG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRoYXQgYXR0YWNoZXMgbG9jYXRpb24gdG8gYW4gZXJyb3IuXG4gKi9cbmNsYXNzIEVycm9yV2l0aExvY2F0aW9uIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UgdG8gcmVwb3J0LiBcbiAgICAgKiBAcGFyYW0ge2ludH0gbG9jLmxpbmUgVGhlIGxpbmUgb24gd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICAgICAqIEBwYXJhbSB7aW50fSBsb2MuY29sdW1uIFRoZSBjb2x1bW4gaW4gdGhlIGxpbmUgd2hlcmUgdGhlIGVycm9yIG9jY3VycnJlZC5cbiAgICAgKiBAcGFyYW0ge2ludH0gbG9jLmluZGV4IFRoZSBpbmRleCBpbiB0aGUgc3RyaW5nIHdoZXJlIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB7IGxpbmUsIGNvbHVtbiwgaW5kZXggfSkge1xuICAgICAgICBzdXBlcihgJHsgbWVzc2FnZSB9ICgkeyBsaW5lIH06JHsgY29sdW1ufSlgKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpbmUgb24gd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICAgICAgICAgKiBAdHlwZSBpbnRcbiAgICAgICAgICogQHByb3BlcnR5IGxpbmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2x1bW4gb24gd2hpY2ggdGhlIGVycm9yIG9jY3VycmVkLlxuICAgICAgICAgKiBAdHlwZSBpbnRcbiAgICAgICAgICogQHByb3BlcnR5IGNvbHVtblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IGludG8gdGhlIHN0cmluZyB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gICAgICAgICAqIEB0eXBlIGludFxuICAgICAgICAgKiBAcHJvcGVydHkgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhbiB1bmV4cGVjdGVkIGNoYXJhY3RlciBpcyBmb3VuZCBkdXJpbmcgdG9rZW5pemluZy5cbiAqL1xuY2xhc3MgVW5leHBlY3RlZENoYXIgZXh0ZW5kcyBFcnJvcldpdGhMb2NhdGlvbiB7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1bmV4cGVjdGVkIFRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgZm91bmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvYyBUaGUgbG9jYXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBmb3VuZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodW5leHBlY3RlZCwgbG9jKSB7XG4gICAgICAgIHN1cGVyKGBVbmV4cGVjdGVkIGNoYXJhY3RlciAkeyB1bmV4cGVjdGVkIH0gZm91bmQuYCwgbG9jKTtcbiAgICB9XG59XG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYW4gdW5leHBlY3RlZCB0b2tlbiBpcyBmb3VuZCBkdXJpbmcgcGFyc2luZy5cbiAqL1xuY2xhc3MgVW5leHBlY3RlZFRva2VuIGV4dGVuZHMgRXJyb3JXaXRoTG9jYXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWQgVGhlIGNoYXJhY3RlciB0aGF0IHdhcyBleHBlY3RlZC4gXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVuZXhwZWN0ZWQgVGhlIGNoYXJhY3RlciB0aGF0IHdhcyBmb3VuZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbG9jIFRoZSBsb2NhdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGZvdW5kIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbikge1xuICAgICAgICBzdXBlcihgVW5leHBlY3RlZCB0b2tlbiAkeyB0b2tlbi50eXBlIH0oJHsgdG9rZW4udmFsdWUgfSkgZm91bmQuYCwgdG9rZW4ubG9jLnN0YXJ0KTtcbiAgICB9XG59XG5cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIGVuZCBvZiBpbnB1dCBpcyBmb3VuZCB3aGVyZSBpdCBpc24ndCBleHBlY3RlZC5cbiAqL1xuY2xhc3MgVW5leHBlY3RlZEVPRiBleHRlbmRzIEVycm9yV2l0aExvY2F0aW9uIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxvYyBUaGUgbG9jYXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBmb3VuZCBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobG9jKSB7XG4gICAgICAgIHN1cGVyKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQgZm91bmQuXCIsIGxvYyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSlNPTiB0b2tlbml6ZXJcbiAqIEBhdXRob3IgTmljaG9sYXMgQy4gWmFrYXNcbiAqL1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFFVT1RFJDEgPSBcIlxcXCJcIjtcbmNvbnN0IFNMQVNIID0gXCIvXCI7XG5jb25zdCBTVEFSID0gXCIqXCI7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBjb21tZW50czogZmFsc2UsXG4gICAgcmFuZ2VzOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGMpIHtcbiAgICByZXR1cm4gL1tcXHNcXG5dLy50ZXN0KGMpO1xufVxuXG5mdW5jdGlvbiBpc0RpZ2l0KGMpIHtcbiAgICByZXR1cm4gYyA+PSBcIjBcIiAmJiBjIDw9IFwiOVwiO1xufVxuXG5mdW5jdGlvbiBpc0hleERpZ2l0KGMpIHtcbiAgICByZXR1cm4gaXNEaWdpdChjKSB8fCAvW2EtZl0vaS50ZXN0KGMpO1xufVxuXG5mdW5jdGlvbiBpc1Bvc2l0aXZlRGlnaXQoYykge1xuICAgIHJldHVybiBjID49IFwiMVwiICYmIGMgPD0gXCI5XCI7XG59XG5cbmZ1bmN0aW9uIGlzS2V5d29yZFN0YXJ0KGMpIHtcbiAgICByZXR1cm4gL1t0Zm5dLy50ZXN0KGMpO1xufVxuXG5mdW5jdGlvbiBpc051bWJlclN0YXJ0KGMpIHtcbiAgICByZXR1cm4gaXNEaWdpdChjKSB8fCBjID09PSBcIi5cIiB8fCBjID09PSBcIi1cIjtcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTWFpblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgdG9rZW5zIHJlcHJlc2VudGluZyB0aGUgc291cmNlIHRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgc291cmNlIHRleHQgdG8gdG9rZW5pemUuXG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9IEFuIGl0ZXJhdG9yIG92ZXIgdGhlIHRva2Vucy4gXG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplKHRleHQsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4uREVGQVVMVF9PUFRJT05TLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG5cbiAgICBsZXQgb2Zmc2V0ID0gLTE7XG4gICAgbGV0IGxpbmUgPSAxO1xuICAgIGxldCBjb2x1bW4gPSAwO1xuICAgIGxldCBuZXdMaW5lID0gZmFsc2U7XG5cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcblxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9rZW4odG9rZW5UeXBlLCB2YWx1ZSwgc3RhcnRMb2MsIGVuZExvYykge1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gc3RhcnRMb2Mub2Zmc2V0ICsgdmFsdWUubGVuZ3RoO1xuICAgICAgICBsZXQgcmFuZ2UgPSBvcHRpb25zLnJhbmdlcyA/IHtcbiAgICAgICAgICAgIHJhbmdlOiBbc3RhcnRMb2Mub2Zmc2V0LCBlbmRPZmZzZXRdXG4gICAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UeXBlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnRMb2MsXG4gICAgICAgICAgICAgICAgZW5kOiBlbmRMb2MgfHwge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBzdGFydExvYy5saW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0TG9jLmNvbHVtbiArIHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBlbmRPZmZzZXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucmFuZ2VcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBsZXQgYyA9IHRleHQuY2hhckF0KCsrb2Zmc2V0KTtcbiAgICBcbiAgICAgICAgaWYgKG5ld0xpbmUpIHtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICBuZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2x1bW4rKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSBcIlxcclwiKSB7XG4gICAgICAgICAgICBuZXdMaW5lID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBzZWUgYSBcXHIsIGp1c3QgaWdub3JlIHVwY29taW5nIFxcblxuICAgICAgICAgICAgaWYgKHRleHQuY2hhckF0KG9mZnNldCArIDEpID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgbmV3TGluZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgY29sdW1uLFxuICAgICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZEtleXdvcmQoYykge1xuXG4gICAgICAgIC8vIGdldCB0aGUgZXhwZWN0ZWQga2V5d29yZFxuICAgICAgICBsZXQgdmFsdWUgPSBleHBlY3RlZEtleXdvcmRzLmdldChjKTtcblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaXQgYWN0dWFsbHkgZXhpc3RzXG4gICAgICAgIGlmICh0ZXh0LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdmFsdWUubGVuZ3RoKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSB2YWx1ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgY29sdW1uICs9IHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgYzogbmV4dCgpIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCB1bmV4cGVjdGVkIGNoYXJhY3RlclxuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVbal0gIT09IHRleHQuY2hhckF0KG9mZnNldCArIGopKSB7XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZChuZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkU3RyaW5nKGMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gYztcbiAgICAgICAgYyA9IG5leHQoKTtcblxuICAgICAgICB3aGlsZSAoYyAmJiBjICE9PSBRVU9URSQxKSB7XG5cbiAgICAgICAgICAgIC8vIGVzY2FwZXNcbiAgICAgICAgICAgIGlmIChjID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgYyA9IG5leHQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVUb0NoYXIuaGFzKGMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID09PSBcInVcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0hleERpZ2l0KGMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjID0gbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICB1bmV4cGVjdGVkRU9GKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhbHVlICs9IGM7XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGM6IG5leHQoKSB9O1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcmVhZE51bWJlcihjKSB7XG5cbiAgICAgICAgbGV0IHZhbHVlID0gXCJcIjtcblxuICAgICAgICAvLyBOdW1iZXIgbWF5IHN0YXJ0IHdpdGggYSBtaW51cyBidXQgbm90IGEgcGx1c1xuICAgICAgICBpZiAoYyA9PT0gXCItXCIpIHtcblxuICAgICAgICAgICAgdmFsdWUgKz0gYztcblxuICAgICAgICAgICAgYyA9IG5leHQoKTtcblxuICAgICAgICAgICAgLy8gTmV4dCBkaWdpdCBjYW5ub3QgYmUgemVyb1xuICAgICAgICAgICAgaWYgKCFpc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZChjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBtdXN0IGJlIGZvbGxvd2VkIGJ5IGEgZGVjaW1hbCBwb2ludCBvciBub3RoaW5nXG4gICAgICAgIGlmIChjID09PSBcIjBcIikge1xuXG4gICAgICAgICAgICB2YWx1ZSArPSBjO1xuXG4gICAgICAgICAgICBjID0gbmV4dCgpO1xuICAgICAgICAgICAgaWYgKGlzRGlnaXQoYykpIHtcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKGMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWlzUG9zaXRpdmVEaWdpdChjKSkge1xuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgIGMgPSBuZXh0KCk7XG4gICAgICAgICAgICB9IHdoaWxlIChpc0RpZ2l0KGMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQgbWF5IGJlIGZvbGxvd2VkIGJ5IGFueSBudW1iZXIgb2YgZGlnaXRzXG4gICAgICAgIGlmIChjID09PSBcIi5cIikge1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gYztcbiAgICAgICAgICAgICAgICBjID0gbmV4dCgpO1xuICAgICAgICAgICAgfSB3aGlsZSAoaXNEaWdpdChjKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHBvbmVudCBpcyBhbHdheXMgbGFzdFxuICAgICAgICBpZiAoYyA9PT0gXCJlXCIgfHwgYyA9PT0gXCJFXCIpIHtcblxuICAgICAgICAgICAgdmFsdWUgKz0gYztcbiAgICAgICAgICAgIGMgPSBuZXh0KCk7XG5cbiAgICAgICAgICAgIGlmIChjID09PSBcIitcIiB8fCBjID09PSBcIi1cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgYyA9IG5leHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIE11c3QgYWx3YXlzIGhhdmUgYSBkaWdpdCBpbiB0aGlzIHBvc2l0aW9uIHRvIGF2b2lkOlxuICAgICAgICAgICAgICogNWVcbiAgICAgICAgICAgICAqIDEyRStcbiAgICAgICAgICAgICAqIDQyZS1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFpc0RpZ2l0KGMpKSB7XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZChjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKGlzRGlnaXQoYykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgIGMgPSBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBjIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgaW4gZWl0aGVyIGEgc2luZ2xlLWxpbmUgb3IgbXVsdGktbGluZSBjb21tZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjIFRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGNvbW1lbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbW1lbnQgc3RyaW5nLlxuICAgICAqIEB0aHJvd3Mge1VuZXhwZWN0ZWRDaGFyfSB3aGVuIHRoZSBjb21tZW50IGNhbm5vdCBiZSByZWFkLlxuICAgICAqIEB0aHJvd3Mge1VuZXhwZWN0ZWRFT0Z9IHdoZW4gRU9GIGlzIHJlYWNoZWQgYmVmb3JlIHRoZSBjb21tZW50IGlzXG4gICAgICogICAgICBmaW5hbGl6ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhZENvbW1lbnQoYykge1xuXG4gICAgICAgIGxldCB2YWx1ZSA9IGM7XG5cbiAgICAgICAgLy8gbmV4dCBjaGFyYWN0ZXIgZGV0ZXJtaW5lcyBzaW5nbGUtIG9yIG11bHRpLWxpbmVcbiAgICAgICAgYyA9IG5leHQoKTtcblxuICAgICAgICAvLyBzaW5nbGUtbGluZSBjb21tZW50c1xuICAgICAgICBpZiAoYyA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgICAgICAgICAgYyA9IG5leHQoKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGMgJiYgYyAhPT0gXCJcXHJcIiAmJiBjICE9PSBcIlxcblwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG11bHRpLWxpbmUgY29tbWVudHNcbiAgICAgICAgaWYgKGMgPT09IFNUQVIpIHtcblxuICAgICAgICAgICAgd2hpbGUgKGMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgIGMgPSBuZXh0KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZW5kIG9mIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gU1RBUikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBjID0gbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9lbmQgb2YgY29tbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGUgc2luZ2xlLWxpbmUgY29tbWVudCBmdW5jdGlvbmFsaXR5IGN1ZXMgdXAgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBuZXh0IGNoYXJhY3Rlciwgc28gd2UgZG8gdGhlIHNhbWUgaGVyZSB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogc3BsaXR0aW5nIGxvZ2ljIGxhdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdW5leHBlY3RlZEVPRigpO1xuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSd2ZSBtYWRlIGl0IGhlcmUsIHRoZXJlJ3MgYW4gaW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgICAgdW5leHBlY3RlZChjKTsgICAgICAgIFxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIHRocm93aW5nIHVuZXhwZWN0ZWQgY2hhcmFjdGVyIGVycm9ycy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYyBUaGUgdW5leHBlY3RlZCBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICogQHRocm93cyB7VW5leHBlY3RlZENoYXJ9IGFsd2F5cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmV4cGVjdGVkKGMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDaGFyKGMsIGxvY2F0ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgdGhyb3dpbmcgdW5leHBlY3RlZCBFT0YgZXJyb3JzLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqIEB0aHJvd3Mge1VuZXhwZWN0ZWRFT0Z9IGFsd2F5cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmV4cGVjdGVkRU9GKCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEVPRihsb2NhdGUoKSk7XG4gICAgfVxuXG4gICAgbGV0IGMgPSBuZXh0KCk7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgdGV4dC5sZW5ndGgpIHtcblxuICAgICAgICB3aGlsZSAoaXNXaGl0ZXNwYWNlKGMpKSB7XG4gICAgICAgICAgICBjID0gbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9jYXRlKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGVhc3kgY2FzZVxuICAgICAgICBpZiAoa25vd25Ub2tlblR5cGVzLmhhcyhjKSkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goY3JlYXRlVG9rZW4oa25vd25Ub2tlblR5cGVzLmdldChjKSwgYywgc3RhcnQpKTtcbiAgICAgICAgICAgIGMgPSBuZXh0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNLZXl3b3JkU3RhcnQoYykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRLZXl3b3JkKGMpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgYyA9IHJlc3VsdC5jO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goY3JlYXRlVG9rZW4oa25vd25Ub2tlblR5cGVzLmdldCh2YWx1ZSksIHZhbHVlLCBzdGFydCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyU3RhcnQoYykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlYWROdW1iZXIoYyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBjID0gcmVzdWx0LmM7XG4gICAgICAgICAgICB0b2tlbnMucHVzaChjcmVhdGVUb2tlbihcIk51bWJlclwiLCB2YWx1ZSwgc3RhcnQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSBRVU9URSQxKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkU3RyaW5nKGMpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgYyA9IHJlc3VsdC5jO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goY3JlYXRlVG9rZW4oXCJTdHJpbmdcIiwgdmFsdWUsIHN0YXJ0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gU0xBU0ggJiYgb3B0aW9ucy5jb21tZW50cykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZENvbW1lbnQoYyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBjID0gcmVzdWx0LmM7XG4gICAgICAgICAgICB0b2tlbnMucHVzaChjcmVhdGVUb2tlbih2YWx1ZS5zdGFydHNXaXRoKFwiLy9cIikgPyBcIkxpbmVDb21tZW50XCIgOiBcIkJsb2NrQ29tbWVudFwiLCB2YWx1ZSwgc3RhcnQsIGxvY2F0ZSgpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmV4cGVjdGVkKGMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VucztcblxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgTW9tb2EgSlNPTiBBU1QgdHlwZXNcbiAqIEBhdXRob3IgTmljaG9sYXMgQy4gWmFrYXNcbiAqL1xuXG5jb25zdCB0eXBlcyA9IHtcbiAgICBkb2N1bWVudChib2R5LCBwYXJ0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkRvY3VtZW50XCIsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgLi4ucGFydHNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHN0cmluZyh2YWx1ZSwgcGFydHMgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJTdHJpbmdcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgLi4ucGFydHNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG51bWJlcih2YWx1ZSwgcGFydHMgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJOdW1iZXJcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgLi4ucGFydHNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGJvb2xlYW4odmFsdWUsIHBhcnRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQm9vbGVhblwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAuLi5wYXJ0c1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgbnVsbChwYXJ0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIk51bGxcIixcbiAgICAgICAgICAgIHZhbHVlOiBcIm51bGxcIixcbiAgICAgICAgICAgIC4uLnBhcnRzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhcnJheShlbGVtZW50cywgcGFydHMgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJBcnJheVwiLFxuICAgICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgICAuLi5wYXJ0c1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgb2JqZWN0KG1lbWJlcnMsIHBhcnRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiT2JqZWN0XCIsXG4gICAgICAgICAgICBtZW1iZXJzLFxuICAgICAgICAgICAgLi4ucGFydHNcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG1lbWJlcihuYW1lLCB2YWx1ZSwgcGFydHMgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJNZW1iZXJcIixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIC4uLnBhcnRzXG4gICAgICAgIH07XG4gICAgfSxcblxufTtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEpTT04gcGFyc2VyXG4gKiBAYXV0aG9yIE5pY2hvbGFzIEMuIFpha2FzXG4gKi9cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX09QVElPTlMkMSA9IHtcbiAgICB0b2tlbnM6IGZhbHNlLFxuICAgIGNvbW1lbnRzOiBmYWxzZSxcbiAgICByYW5nZXM6IGZhbHNlXG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgSlNPTi1lbmNvZGVkIHN0cmluZyBpbnRvIGEgSmF2YVNjcmlwdCBzdHJpbmcsIGludGVycHJldGluZyBlYWNoXG4gKiBlc2NhcGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0ge1Rva2VufSB0b2tlbiBUaGUgc3RyaW5nIHRva2VuIHRvIGNvbnZlcnQgaW50byBhIEphdmFTY3JpcHQgc3RyaW5nLlxuICogQHJldHVybnMge3N0cmluZ30gQSBKYXZhU2NyaXB0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nVmFsdWUodG9rZW4pIHtcbiAgICBcbiAgICAvLyBzbGljZSBvZmYgdGhlIHF1b3RhdGlvbiBtYXJrc1xuICAgIGxldCB2YWx1ZSA9IHRva2VuLnZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBsZXQgZXNjYXBlSW5kZXggPSB2YWx1ZS5pbmRleE9mKFwiXFxcXFwiKTtcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcblxuICAgIC8vIFdoaWxlIHRoZXJlIGFyZSBlc2NhcGVzLCBpbnRlcnByZXQgdGhlbSB0byBidWlsZCB1cCB0aGUgcmVzdWx0XG4gICAgd2hpbGUgKGVzY2FwZUluZGV4ID49IDApIHtcblxuICAgICAgICAvLyBhcHBlbmQgdGhlIHRleHQgdGhhdCBoYXBwZW5lZCBiZWZvcmUgdGhlIGVzY2FwZVxuICAgICAgICByZXN1bHQgKz0gdmFsdWUuc2xpY2UobGFzdEluZGV4LCBlc2NhcGVJbmRleCk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIFxcXG4gICAgICAgIGNvbnN0IGVzY2FwZUNoYXIgPSB2YWx1ZS5jaGFyQXQoZXNjYXBlSW5kZXggKyAxKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNoZWNrIGZvciB0aGUgbm9uLVVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlcyBmaXJzdFxuICAgICAgICBpZiAoZXNjYXBlVG9DaGFyLmhhcyhlc2NhcGVDaGFyKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZVRvQ2hhci5nZXQoZXNjYXBlQ2hhcik7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBlc2NhcGVJbmRleCArIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoZXNjYXBlQ2hhciA9PT0gXCJ1XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhleENvZGUgPSB2YWx1ZS5zbGljZShlc2NhcGVJbmRleCArIDIsIGVzY2FwZUluZGV4ICsgNik7XG4gICAgICAgICAgICBpZiAoaGV4Q29kZS5sZW5ndGggPCA0IHx8IC9bXjAtOWEtZl0vaS50ZXN0KGhleENvZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yV2l0aExvY2F0aW9uKFxuICAgICAgICAgICAgICAgICAgICBgSW52YWxpZCB1bmljb2RlIGVzY2FwZSBcXFxcdSR7IGhleENvZGV9LmAsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRva2VuLmxvYy5zdGFydC5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0b2tlbi5sb2Muc3RhcnQuY29sdW1uICsgZXNjYXBlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRva2VuLmxvYy5zdGFydC5vZmZzZXQgKyBlc2NhcGVJbmRleFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4Q29kZSwgMTYpKTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IGVzY2FwZUluZGV4ICsgNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcldpdGhMb2NhdGlvbihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCBlc2NhcGUgXFxcXCR7IGVzY2FwZUNoYXIgfS5gLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogdG9rZW4ubG9jLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogdG9rZW4ubG9jLnN0YXJ0LmNvbHVtbiArIGVzY2FwZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRva2VuLmxvYy5zdGFydC5vZmZzZXQgKyBlc2NhcGVJbmRleFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBuZXh0IGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICBlc2NhcGVJbmRleCA9IHZhbHVlLmluZGV4T2YoXCJcXFxcXCIsIGxhc3RJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBsYXN0IHNlZ21lbnQgb2YgdGhlIHN0cmluZyB2YWx1ZVxuICAgIHJlc3VsdCArPSB2YWx1ZS5zbGljZShsYXN0SW5kZXgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBKYXZhU2NyaXB0IHZhbHVlIHJlcHJlc2VudGVkIGJ5IGEgSlNPTiB0b2tlbi5cbiAqIEBwYXJhbSB7VG9rZW59IHRva2VuIFRoZSBKU09OIHRva2VuIHRvIGdldCBhIHZhbHVlIGZvci5cbiAqIEByZXR1cm5zIHsqfSBBIG51bWJlciwgc3RyaW5nLCBib29sZWFuLCBvciBgbnVsbGAuIFxuICovXG5mdW5jdGlvbiBnZXRMaXRlcmFsVmFsdWUodG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICBjYXNlIFwiQm9vbGVhblwiOlxuICAgICAgICByZXR1cm4gdG9rZW4udmFsdWUgPT09IFwidHJ1ZVwiO1xuICAgICAgICBcbiAgICBjYXNlIFwiTnVtYmVyXCI6XG4gICAgICAgIHJldHVybiBOdW1iZXIodG9rZW4udmFsdWUpO1xuXG4gICAgY2FzZSBcIk51bGxcIjpcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIFwiU3RyaW5nXCI6XG4gICAgICAgIHJldHVybiBnZXRTdHJpbmdWYWx1ZSh0b2tlbik7XG4gICAgfVxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBNYWluIEZ1bmN0aW9uXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudG9rZW5zPWZhbHNlXSBEZXRlcm1pbmVzIGlmIHRva2VucyBhcmUgcmV0dXJuZWQgaW5cbiAqICAgICAgdGhlIEFTVC4gXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbW1lbnRzPWZhbHNlXSBEZXRlcm1pbmVzIGlmIGNvbW1lbnRzIGFyZSBhbGxvd2VkXG4gKiAgICAgIGluIHRoZSBKU09OLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yYW5nZXM9ZmFsc2VdIERldGVybWluZXMgaWYgcmFuZ2VzIHdpbGwgYmUgcmV0dXJuZWRcbiAqICAgICAgaW4gYWRkaXRpb24gdG8gYGxvY2AgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBBU1QgcmVwcmVzZW50aW5nIHRoZSBwYXJzZWQgSlNPTi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIHRoZXJlIGlzIGEgcGFyc2luZyBlcnJvci4gXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHRleHQsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4uREVGQVVMVF9PUFRJT05TJDEsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcblxuICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHRleHQsIHtcbiAgICAgICAgY29tbWVudHM6ICEhb3B0aW9ucy5jb21tZW50cyxcbiAgICAgICAgcmFuZ2VzOiAhIW9wdGlvbnMucmFuZ2VzXG4gICAgfSk7XG4gICAgbGV0IHRva2VuSW5kZXggPSAwO1xuXG4gICAgZnVuY3Rpb24gbmV4dE5vQ29tbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0b2tlbnNbdG9rZW5JbmRleCsrXTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gbmV4dFNraXBDb21tZW50cygpIHtcbiAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdG9rZW5zW3Rva2VuSW5kZXgrK107XG4gICAgICAgIGlmIChuZXh0VG9rZW4gJiYgbmV4dFRva2VuLnR5cGUuZW5kc1dpdGgoXCJDb21tZW50XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dFNraXBDb21tZW50cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRUb2tlbjtcblxuICAgIH1cblxuICAgIC8vIGRldGVybWluZSBjb3JyZWN0IHdheSB0byBldmFsdWF0ZSB0b2tlbnMgYmFzZWQgb24gcHJlc2VuY2Ugb2YgY29tbWVudHNcbiAgICBjb25zdCBuZXh0ID0gb3B0aW9ucy5jb21tZW50cyA/IG5leHRTa2lwQ29tbWVudHMgOiBuZXh0Tm9Db21tZW50cztcblxuICAgIGZ1bmN0aW9uIGFzc2VydFRva2VuVmFsdWUodG9rZW4sIHZhbHVlKSB7XG4gICAgICAgIGlmICghdG9rZW4gfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZFRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydFRva2VuVHlwZSh0b2tlbiwgdHlwZSkge1xuICAgICAgICBpZiAoIXRva2VuIHx8IHRva2VuLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5yYW5nZXMgPyB7XG4gICAgICAgICAgICByYW5nZTogW3N0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldF1cbiAgICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMaXRlcmFsTm9kZSh0b2tlbikge1xuICAgICAgICBjb25zdCByYW5nZSA9IGNyZWF0ZVJhbmdlKHRva2VuLmxvYy5zdGFydCwgdG9rZW4ubG9jLmVuZCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuLnR5cGUsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0TGl0ZXJhbFZhbHVlKHRva2VuKSxcbiAgICAgICAgICAgIGxvYzoge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRva2VuLmxvYy5zdGFydFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRva2VuLmxvYy5lbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucmFuZ2VcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydHkodG9rZW4pIHtcbiAgICAgICAgYXNzZXJ0VG9rZW5UeXBlKHRva2VuLCBcIlN0cmluZ1wiKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGNyZWF0ZUxpdGVyYWxOb2RlKHRva2VuKTtcblxuICAgICAgICB0b2tlbiA9IG5leHQoKTtcbiAgICAgICAgYXNzZXJ0VG9rZW5WYWx1ZSh0b2tlbiwgXCI6XCIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlVmFsdWUoKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBjcmVhdGVSYW5nZShuYW1lLmxvYy5zdGFydCwgdmFsdWUubG9jLmVuZCk7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVzLm1lbWJlcihuYW1lLCB2YWx1ZSwge1xuICAgICAgICAgICAgbG9jOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubmFtZS5sb2Muc3RhcnRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZS5sb2MuZW5kXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLnJhbmdlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT2JqZWN0KGZpcnN0VG9rZW4pIHtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdG9rZW4gbXVzdCBiZSBhIHsgb3IgZWxzZSBpdCdzIGFuIGVycm9yXG4gICAgICAgIGFzc2VydFRva2VuVmFsdWUoZmlyc3RUb2tlbiwgXCJ7XCIpO1xuXG4gICAgICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgICAgICAgbGV0IHRva2VuID0gbmV4dCgpO1xuXG4gICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi52YWx1ZSAhPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHZhbHVlIGludG8gdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgbWVtYmVycy5wdXNoKHBhcnNlUHJvcGVydHkodG9rZW4pKTtcbiAgICBcbiAgICAgICAgICAgICAgICB0b2tlbiA9IG5leHQoKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gbmV4dCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzc2VydFRva2VuVmFsdWUodG9rZW4sIFwifVwiKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBjcmVhdGVSYW5nZShmaXJzdFRva2VuLmxvYy5zdGFydCwgdG9rZW4ubG9jLmVuZCk7XG5cbiAgICAgICAgcmV0dXJuIHR5cGVzLm9iamVjdChtZW1iZXJzLCB7XG4gICAgICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAuLi5maXJzdFRva2VuLmxvYy5zdGFydFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRva2VuLmxvYy5lbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucmFuZ2VcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUFycmF5KGZpcnN0VG9rZW4pIHtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdG9rZW4gbXVzdCBiZSBhIFsgb3IgZWxzZSBpdCdzIGFuIGVycm9yXG4gICAgICAgIGFzc2VydFRva2VuVmFsdWUoZmlyc3RUb2tlbiwgXCJbXCIpO1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICAgIGxldCB0b2tlbiA9IG5leHQoKTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi52YWx1ZSAhPT0gXCJdXCIpIHtcblxuICAgICAgICAgICAgZG8ge1xuXG4gICAgICAgICAgICAgIC8vIGFkZCB0aGUgdmFsdWUgaW50byB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZVZhbHVlKHRva2VuKSk7XG5cbiAgICAgICAgICAgICAgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbiA9IG5leHQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICh0b2tlbik7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnRUb2tlblZhbHVlKHRva2VuLCBcIl1cIik7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gY3JlYXRlUmFuZ2UoZmlyc3RUb2tlbi5sb2Muc3RhcnQsIHRva2VuLmxvYy5lbmQpO1xuXG4gICAgICAgIHJldHVybiB0eXBlcy5hcnJheShlbGVtZW50cywge1xuICAgICAgICAgICAgdHlwZTogXCJBcnJheVwiLFxuICAgICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgICBsb2M6IHtcbiAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAuLi5maXJzdFRva2VuLmxvYy5zdGFydFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRva2VuLmxvYy5lbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucmFuZ2VcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cblxuXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSh0b2tlbikge1xuXG4gICAgICAgIHRva2VuID0gdG9rZW4gfHwgbmV4dCgpO1xuICAgICAgICBcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgICAgY2FzZSBcIkJvb2xlYW5cIjpcbiAgICAgICAgY2FzZSBcIk51bWJlclwiOlxuICAgICAgICBjYXNlIFwiTnVsbFwiOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxpdGVyYWxOb2RlKHRva2VuKTtcblxuICAgICAgICBjYXNlIFwiUHVuY3R1YXRvclwiOlxuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdCh0b2tlbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLnZhbHVlID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5KHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qZmFsbHMgdGhyb3VnaCovXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVG9rZW4odG9rZW4pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBcbiAgICBjb25zdCBkb2NCb2R5ID0gcGFyc2VWYWx1ZSgpO1xuICAgIFxuICAgIGNvbnN0IHVuZXhwZWN0ZWRUb2tlbiA9IG5leHQoKTtcbiAgICBpZiAodW5leHBlY3RlZFRva2VuKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkVG9rZW4odW5leHBlY3RlZFRva2VuKTtcbiAgICB9XG4gICAgXG4gICAgXG4gICAgY29uc3QgZG9jUGFydHMgPSB7XG4gICAgICAgIGxvYzoge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogMSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAuLi5kb2NCb2R5LmxvYy5lbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG5cbiAgICBpZiAob3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgZG9jUGFydHMudG9rZW5zID0gdG9rZW5zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnJhbmdlcykge1xuICAgICAgICBkb2NQYXJ0cy5yYW5nZSA9IGNyZWF0ZVJhbmdlKGRvY1BhcnRzLmxvYy5zdGFydCwgZG9jUGFydHMubG9jLmVuZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVzLmRvY3VtZW50KGRvY0JvZHksIGRvY1BhcnRzKTtcblxufVxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVHJhdmVyc2FsIGFwcHJvYWNoZXMgZm9yIE1vbW9hIEpTT04gQVNULlxuICogQGF1dGhvciBOaWNob2xhcyBDLiBaYWthc1xuICovXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERhdGFcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgY2hpbGRLZXlzID0gbmV3IE1hcChbXG4gICAgW1wiRG9jdW1lbnRcIiwgW1wiYm9keVwiXV0sXG4gICAgW1wiT2JqZWN0XCIsIFtcIm1lbWJlcnNcIl1dLFxuICAgIFtcIk1lbWJlclwiLCBbXCJuYW1lXCIsIFwidmFsdWVcIl1dLFxuICAgIFtcIkFycmF5XCIsIFtcImVsZW1lbnRzXCJdXSxcbiAgICBbXCJTdHJpbmdcIiwgW11dLFxuICAgIFtcIk51bWJlclwiLCBbXV0sXG4gICAgW1wiQm9vbGVhblwiLCBbXV0sXG4gICAgW1wiTnVsbFwiLCBbXV1cbl0pO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBIZWxwZXJzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgZmFsc2UgaWYgbm90LiBcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIik7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGFuIEFTVCBub2RlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBub2RlLCBmYWxzZSBpZiBub3QuIFxuICovXG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmICh0eXBlb2YgdmFsdWUudHlwZSA9PT0gXCJzdHJpbmdcIik7XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEV4cG9ydHNcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgYW4gQVNUIGZyb20gdGhlIGdpdmVuIG5vZGUuXG4gKiBAcGFyYW0ge05vZGV9IHJvb3QgVGhlIG5vZGUgdG8gdHJhdmVyc2UgZnJvbSBcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aXNpdG9yIEFuIG9iamVjdCB3aXRoIGFuIGBlbnRlcmAgYW5kIGBleGl0YCBtZXRob2QuIFxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB2aXNpdHMgYSBub2RlLlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byB2aXNpdC5cbiAgICAgKiBAcGFyYW0ge05vZGV9IHBhcmVudCBUaGUgcGFyZW50IG9mIHRoZSBub2RlIHRvIHZpc2l0LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZpc2l0Tm9kZShub2RlLCBwYXJlbnQpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZpc2l0b3IuZW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmlzaXRvci5lbnRlcihub2RlLCBwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGRLZXlzLmdldChub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGVba2V5XTtcblxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGNoaWxkID0+IHZpc2l0Tm9kZShjaGlsZCwgbm9kZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2aXNpdE5vZGUodmFsdWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmlzaXRvci5leGl0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZpc2l0b3IuZXhpdChub2RlLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmlzaXROb2RlKHJvb3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgZ2l2ZW4gQVNULlxuICogQHBhcmFtIHtOb2RlfSByb290IFRoZSByb290IEFTVCBub2RlIHRvIHRyYXZlcnNlLiBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmaWx0ZXJdIEEgZmlsdGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBzdGVwcyB0b1xuICogICAgICByZXR1cm47XG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9IEFuIGl0ZXJhdG9yIG92ZXIgdGhlIEFTVC4gIFxuICovXG5mdW5jdGlvbiBpdGVyYXRvcihyb290LCBmaWx0ZXIgPSAoKSA9PiB0cnVlKSB7XG5cbiAgICBjb25zdCB0cmF2ZXJzYWwgPSBbXTtcblxuICAgIHRyYXZlcnNlKHJvb3QsIHtcbiAgICAgICAgZW50ZXIobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICB0cmF2ZXJzYWwucHVzaCh7IG5vZGUsIHBhcmVudCwgcGhhc2U6IFwiZW50ZXJcIiB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhpdChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRyYXZlcnNhbC5wdXNoKHsgbm9kZSwgcGFyZW50LCBwaGFzZTogXCJleGl0XCIgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0cmF2ZXJzYWwuZmlsdGVyKGZpbHRlcikudmFsdWVzKCk7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBFdmFsdWF0b3IgZm9yIE1vbW9hIEFTVC5cbiAqIEBhdXRob3IgTmljaG9sYXMgQy4gWmFrYXNcbiAqL1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeHBvcnRzXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogRXZhbHVhdGVzIGEgTW9tb2EgQVNUIG5vZGUgaW50byBhIEphdmFTY3JpcHQgdmFsdWUuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gaW50ZXJwZXQuXG4gKiBAcmV0dXJucyB7Kn0gVGhlIEphdmFTY3JpcHQgdmFsdWUgZm9yIHRoZSBub2RlLiBcbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGUobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIlN0cmluZ1wiOlxuICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICBjYXNlIFwiQm9vbGVhblwiOlxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcblxuICAgIGNhc2UgXCJOdWxsXCI6XG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnRzLm1hcChldmFsdWF0ZSk7XG5cbiAgICBjYXNlIFwiT2JqZWN0XCI6IHtcblxuICAgICAgICBjb25zdCBvYmplY3QgPSB7fTtcblxuICAgICAgICBub2RlLm1lbWJlcnMuZm9yRWFjaChtZW1iZXIgPT4ge1xuICAgICAgICAgICAgb2JqZWN0W2V2YWx1YXRlKG1lbWJlci5uYW1lKV0gPSBldmFsdWF0ZShtZW1iZXIudmFsdWUpO1xuICAgICAgICB9KTsgICAgXG5cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9ICAgIFxuXG4gICAgY2FzZSBcIkRvY3VtZW50XCI6XG4gICAgICAgIHJldHVybiBldmFsdWF0ZShub2RlLmJvZHkpO1xuXG4gICAgY2FzZSBcIlByb3BlcnR5XCI6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBldmFsdWF0ZSBvYmplY3QgcHJvcGVydHkgb3V0c2lkZSBvZiBhbiBvYmplY3QuXCIpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG5vZGUgdHlwZSAkeyBub2RlLnR5cGUgfS5gKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBQcmludGVyIGZvciBNb21vYSBBU1QuXG4gKiBAYXV0aG9yIE5pY2hvbGFzIEMuIFpha2FzXG4gKi9cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhwb3J0c1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIENvbnZlcnRzIGEgTW9tb2EgQVNUIGJhY2sgaW50byBhIEpTT04gc3RyaW5nLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHByaW50LlxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmluZGVudD0wXSBUaGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnQgZWFjaCBsaW5lLiBJZlxuICogICAgICBncmVhdGVyIHRoYW4gMCwgdGhlbiBuZXdsaW5lcyBhbmQgaW5kZW50cyB3aWxsIGJlIGFkZGVkIHRvIG91dHB1dC4gXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgQVNULlxuICovXG5mdW5jdGlvbiBwcmludChub2RlLCB7IGluZGVudCA9IDAgfSA9IHt9KSB7XG4gICAgY29uc3QgdmFsdWUgPSBldmFsdWF0ZShub2RlKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIG51bGwsIGluZGVudCk7XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBGaWxlIGRlZmluaW5nIHRoZSBpbnRlcmZhY2Ugb2YgdGhlIHBhY2thZ2UuXG4gKiBAYXV0aG9yIE5pY2hvbGFzIEMuIFpha2FzXG4gKi9cblxuZXhwb3J0cy5ldmFsdWF0ZSA9IGV2YWx1YXRlO1xuZXhwb3J0cy5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wcmludCA9IHByaW50O1xuZXhwb3J0cy50b2tlbml6ZSA9IHRva2VuaXplO1xuZXhwb3J0cy50cmF2ZXJzZSA9IHRyYXZlcnNlO1xuZXhwb3J0cy50eXBlcyA9IHR5cGVzO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@humanwhocodes/momoa/api.js\n");

/***/ })

}]);