(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[78],{

/***/ "./node_modules/pbkit/core/parser/proto.js":
/*!*************************************************!*\
  !*** ./node_modules/pbkit/core/parser/proto.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseConstant = exports.parse = void 0;\nconst recursive_descent_parser_1 = __webpack_require__(/*! ./recursive-descent-parser */ \"./node_modules/pbkit/core/parser/recursive-descent-parser.js\");\nfunction parse(text) {\n    const parser = (0, recursive_descent_parser_1.createRecursiveDescentParser)(text);\n    const statements = acceptStatements(parser, [\n        acceptSyntax,\n        acceptImport,\n        acceptPackage,\n        acceptOption,\n        acceptMessage,\n        acceptEnum,\n        acceptExtend,\n        acceptService,\n        acceptEmpty,\n    ]);\n    const ast = { statements };\n    return { ast, parser };\n}\nexports.parse = parse;\nfunction parseConstant(text) {\n    const parser = (0, recursive_descent_parser_1.createRecursiveDescentParser)(text);\n    const constant = expectConstant(parser);\n    return { ast: constant, parser };\n}\nexports.parseConstant = parseConstant;\nfunction mergeSpans(spans) {\n    let start = Infinity;\n    let end = -Infinity;\n    for (let i = 0; i < spans.length; ++i) {\n        if (spans[i] == null)\n            continue;\n        const span = Array.isArray(spans[i])\n            ? mergeSpans(spans[i])\n            : spans[i];\n        start = Math.min(start, span.start);\n        end = Math.max(end, span.end);\n    }\n    return { start, end };\n}\nfunction acceptPatternAndThen(pattern, then) {\n    return function accept(parser) {\n        const token = parser.accept(pattern);\n        if (!token)\n            return;\n        return then(token);\n    };\n}\nfunction choice(acceptFns) {\n    return function accept(parser) {\n        for (const acceptFn of acceptFns) {\n            const node = acceptFn(parser);\n            if (node)\n                return node;\n        }\n    };\n}\nfunction many(parser, acceptFn) {\n    const nodes = [];\n    let node;\n    while (node = acceptFn(parser))\n        nodes.push(node);\n    return nodes;\n}\nfunction acceptComplexSequence(parser, expectFnSeq, escapePattern) {\n    const result = {};\n    let partial = false;\n    let hasNewline = false;\n    let recoveryPoint;\n    for (const [key, expectFn] of expectFnSeq) {\n        const loc = parser.loc;\n        hasNewline = skipWsAndComments2(parser);\n        if (hasNewline && !recoveryPoint) {\n            recoveryPoint = { loc: parser.loc, result: { ...result } };\n        }\n        try {\n            result[key] = expectFn(parser);\n        }\n        catch {\n            parser.loc = loc;\n            partial = true;\n            if (escapePattern && parser.try(escapePattern))\n                break;\n        }\n    }\n    if (partial && recoveryPoint) {\n        parser.loc = recoveryPoint.loc;\n        return { partial, result: recoveryPoint.result };\n    }\n    return { partial, result };\n}\nfunction acceptStatements(parser, acceptStatementFns) {\n    const statements = [];\n    statements: while (true) {\n        const { commentGroups, trailingNewline } = skipWsAndSweepComments(parser);\n        let leadingComments;\n        let leadingDetachedComments;\n        if (trailingNewline) {\n            leadingComments = [];\n            leadingDetachedComments = commentGroups;\n        }\n        else {\n            if (commentGroups.length < 1) {\n                leadingComments = [];\n                leadingDetachedComments = [];\n            }\n            else {\n                leadingComments = [commentGroups.pop()];\n                leadingDetachedComments = commentGroups;\n            }\n        }\n        for (const acceptStatementFn of acceptStatementFns) {\n            const statement = acceptStatementFn(parser, leadingComments, leadingDetachedComments);\n            if (statement) {\n                statements.push(statement);\n                continue statements;\n            }\n        }\n        break;\n    }\n    return statements;\n}\nconst whitespacePattern = /^\\s+/;\nconst whitespaceWithoutNewlinePattern = /^[ \\f\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/;\nconst newlinePattern = /^\\r?\\n/;\nconst multilineCommentPattern = /^\\/\\*(?:.|\\r?\\n)*?\\*\\//;\nconst singlelineCommentPattern = /^\\/\\/.*(?:\\r?\\n|$)/;\nconst intLitPattern = /^0(?:x[0-9a-f]+|[0-7]*)|^[1-9]\\d*/i;\nconst floatLitPattern = /^\\d+\\.\\d*(?:e[-+]?\\d+)?|^\\d+e[-+]?\\d+|^\\.\\d+(?:e[-+]?\\d+)?|^inf|^nan/i;\nconst boolLitPattern = /^true|^false/;\nconst strLitPattern = /^'(?:\\\\x[0-9a-f]{2}|\\\\[0-7]{3}|\\\\[0-7]|\\\\[abfnrtv\\\\\\?'\"]|[^'\\0\\n\\\\])*'|^\"(?:\\\\x[0-9a-f]{2}|\\\\[0-7]{3}|\\\\[0-7]|\\\\[abfnrtv\\\\\\?'\"]|[^\"\\0\\n\\\\])*\"/i;\nconst identPattern = /^[a-z_][a-z0-9_]*/i;\nconst messageBodyStatementKeywordPattern = /^(?:enum|message|extend|extensions|group|option|oneof|map|reserved)\\b/;\nconst acceptDot = acceptPatternAndThen(\".\", (dot) => ({ type: \"dot\", ...dot }));\nconst acceptComma = acceptPatternAndThen(\",\", (comma) => ({ type: \"comma\", ...comma }));\nconst acceptSemi = acceptPatternAndThen(\";\", (semi) => ({ type: \"semi\", ...semi }));\nfunction expectSemi(parser) {\n    const semi = acceptSemi(parser);\n    if (semi)\n        return semi;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [\";\"]);\n}\nconst acceptIdent = acceptPatternAndThen(identPattern, (ident) => ({ type: \"ident\", ...ident }));\nfunction acceptSpecialToken(parser, type, pattern = identPattern) {\n    const token = parser.accept(pattern);\n    if (!token)\n        return;\n    return { type, ...token };\n}\nfunction acceptKeyword(parser, pattern = identPattern) {\n    return acceptSpecialToken(parser, \"keyword\", pattern);\n}\nfunction acceptCommentGroup(parser) {\n    const loc = parser.loc;\n    const comments = [];\n    while (true) {\n        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);\n        if (whitespace)\n            continue;\n        const multilineComment = acceptSpecialToken(parser, \"multiline-comment\", multilineCommentPattern);\n        if (multilineComment) {\n            comments.push(multilineComment);\n            continue;\n        }\n        const singlelineComment = acceptSpecialToken(parser, \"singleline-comment\", singlelineCommentPattern);\n        if (singlelineComment) {\n            comments.push(singlelineComment);\n            continue;\n        }\n        break;\n    }\n    if (comments.length < 1) {\n        parser.loc = loc;\n        return;\n    }\n    return {\n        ...mergeSpans(comments),\n        type: \"comment-group\",\n        comments,\n    };\n}\nfunction acceptTrailingComments(parser) {\n    const loc = parser.loc;\n    const comments = [];\n    while (true) {\n        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);\n        if (whitespace)\n            continue;\n        const newline = parser.accept(newlinePattern);\n        if (newline)\n            break;\n        const multilineComment = acceptSpecialToken(parser, \"multiline-comment\", multilineCommentPattern);\n        if (multilineComment) {\n            comments.push(multilineComment);\n            continue;\n        }\n        const singlelineComment = acceptSpecialToken(parser, \"singleline-comment\", singlelineCommentPattern);\n        if (singlelineComment) {\n            comments.push(singlelineComment);\n            break;\n        }\n        break;\n    }\n    if (comments.length < 1) {\n        parser.loc = loc;\n        return [];\n    }\n    return [{\n            ...mergeSpans(comments),\n            type: \"comment-group\",\n            comments,\n        }];\n}\nfunction skipWsAndSweepComments(parser) {\n    const commentGroups = [];\n    let trailingNewline = false;\n    parser.accept(whitespacePattern);\n    while (true) {\n        const commentGroup = acceptCommentGroup(parser);\n        if (commentGroup) {\n            commentGroups.push(commentGroup);\n            trailingNewline = false;\n            continue;\n        }\n        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);\n        if (whitespace)\n            continue;\n        const newline = parser.accept(newlinePattern);\n        if (newline) {\n            trailingNewline = true;\n            continue;\n        }\n        break;\n    }\n    return {\n        commentGroups,\n        trailingNewline,\n    };\n}\nfunction skipWsAndComments(parser) {\n    while (true) {\n        const whitespace = parser.accept(whitespacePattern);\n        if (whitespace)\n            continue;\n        const multilineComment = acceptSpecialToken(parser, \"multiline-comment\", multilineCommentPattern);\n        if (multilineComment)\n            continue;\n        const singlelineComment = acceptSpecialToken(parser, \"singleline-comment\", singlelineCommentPattern);\n        if (singlelineComment)\n            continue;\n        break;\n    }\n    return;\n}\nfunction skipWsAndComments2(parser) {\n    let hasNewline = false;\n    while (true) {\n        const whitespace = parser.accept(whitespaceWithoutNewlinePattern);\n        if (whitespace)\n            continue;\n        const newline = parser.accept(newlinePattern);\n        if (newline) {\n            hasNewline = true;\n            continue;\n        }\n        const multilineComment = acceptSpecialToken(parser, \"multiline-comment\", multilineCommentPattern);\n        if (multilineComment)\n            continue;\n        const singlelineComment = acceptSpecialToken(parser, \"singleline-comment\", singlelineCommentPattern);\n        if (singlelineComment) {\n            hasNewline = true;\n            continue;\n        }\n        break;\n    }\n    return hasNewline;\n}\nfunction acceptFullIdent(parser) {\n    const identOrDots = many(parser, choice([\n        acceptDot,\n        acceptIdent,\n    ]));\n    if (identOrDots.length < 1)\n        return;\n    return {\n        ...mergeSpans(identOrDots),\n        type: \"full-ident\",\n        identOrDots,\n    };\n}\nfunction expectFullIdent(parser) {\n    const fullIdent = acceptFullIdent(parser);\n    if (fullIdent)\n        return fullIdent;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [\".\", identPattern]);\n}\nfunction acceptType(parser) {\n    const identOrDots = many(parser, choice([\n        acceptDot,\n        acceptIdent,\n    ]));\n    if (identOrDots.length < 1)\n        return;\n    return {\n        ...mergeSpans(identOrDots),\n        type: \"type\",\n        identOrDots,\n    };\n}\nfunction expectType(parser) {\n    const type = acceptType(parser);\n    if (type)\n        return type;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [\".\", identPattern]);\n}\nfunction acceptIntLit(parser) {\n    const intLit = parser.accept(intLitPattern);\n    if (!intLit)\n        return;\n    return { type: \"int-lit\", ...intLit };\n}\nfunction expectIntLit(parser) {\n    const intLit = acceptIntLit(parser);\n    if (intLit)\n        return intLit;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [intLitPattern]);\n}\nfunction acceptSignedIntLit(parser) {\n    var _a;\n    const loc = parser.loc;\n    const sign = (_a = parser.accept(\"-\")) !== null && _a !== void 0 ? _a : parser.accept(\"+\");\n    const intLit = acceptIntLit(parser);\n    if (!intLit) {\n        parser.loc = loc;\n        return;\n    }\n    return {\n        ...mergeSpans([sign, intLit]),\n        type: \"signed-int-lit\",\n        sign,\n        value: intLit,\n    };\n}\nfunction expectSignedIntLit(parser) {\n    const signedIntLit = acceptSignedIntLit(parser);\n    if (signedIntLit)\n        return signedIntLit;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [\"-\", intLitPattern]);\n}\nfunction acceptFloatLit(parser) {\n    const floatLit = parser.accept(floatLitPattern);\n    if (!floatLit)\n        return;\n    return { type: \"float-lit\", ...floatLit };\n}\nfunction acceptSignedFloatLit(parser) {\n    var _a;\n    const loc = parser.loc;\n    const sign = (_a = parser.accept(\"-\")) !== null && _a !== void 0 ? _a : parser.accept(\"+\");\n    const floatLit = acceptFloatLit(parser);\n    if (!floatLit) {\n        parser.loc = loc;\n        return;\n    }\n    return {\n        ...mergeSpans([sign, floatLit]),\n        type: \"signed-float-lit\",\n        sign,\n        value: floatLit,\n    };\n}\nfunction acceptBoolLit(parser) {\n    const boolLit = parser.accept(boolLitPattern);\n    if (!boolLit)\n        return;\n    return { type: \"bool-lit\", ...boolLit };\n}\nfunction acceptStrLit(parser) {\n    const strLit = parser.accept(strLitPattern);\n    if (!strLit)\n        return;\n    const tokens = [strLit];\n    while (true) {\n        skipWsAndComments(parser);\n        const strLit = parser.accept(strLitPattern);\n        if (!strLit)\n            break;\n        tokens.push(strLit);\n    }\n    return { ...mergeSpans(tokens), type: \"str-lit\", tokens };\n}\nfunction expectStrLit(parser) {\n    const strLit = acceptStrLit(parser);\n    if (strLit)\n        return strLit;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [strLitPattern]);\n}\n// https://github.com/protocolbuffers/protobuf/blob/c2148566c7/src/google/protobuf/compiler/parser.cc#L1429-L1452\nfunction acceptAggregate(parser) {\n    const parenthesisOpen = parser.accept(\"{\");\n    if (!parenthesisOpen)\n        return;\n    let character = parenthesisOpen;\n    let depth = 1;\n    while (character = parser.expect(/^(?:\\s|\\S)/)) {\n        switch (character.text) {\n            case \"{\":\n                ++depth;\n                break;\n            case \"}\":\n                --depth;\n                break;\n        }\n        if (depth === 0) {\n            break;\n        }\n    }\n    return {\n        ...mergeSpans([parenthesisOpen, character]),\n        type: \"aggregate\",\n    };\n}\nfunction acceptConstant(parser) {\n    var _a, _b, _c, _d, _e;\n    return (_e = (_d = (_c = (_b = (_a = acceptSignedFloatLit(parser)) !== null && _a !== void 0 ? _a : acceptSignedIntLit(parser)) !== null && _b !== void 0 ? _b : acceptStrLit(parser)) !== null && _c !== void 0 ? _c : acceptBoolLit(parser)) !== null && _d !== void 0 ? _d : acceptFullIdent(parser)) !== null && _e !== void 0 ? _e : acceptAggregate(parser);\n}\nfunction expectConstant(parser) {\n    const constant = acceptConstant(parser);\n    if (constant)\n        return constant;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [\n        identPattern,\n        \"-\",\n        \"+\",\n        intLitPattern,\n        strLitPattern,\n        boolLitPattern,\n    ]);\n}\nfunction acceptOptionNameSegment(parser) {\n    const bracketOpen = parser.accept(\"(\");\n    const name = acceptFullIdent(parser);\n    if (!name) {\n        if (bracketOpen)\n            throw new recursive_descent_parser_1.SyntaxError(parser, [identPattern]);\n        return;\n    }\n    const bracketClose = parser[bracketOpen ? \"expect\" : \"accept\"](\")\");\n    return {\n        ...mergeSpans([bracketOpen, name, bracketClose]),\n        type: \"option-name-segment\",\n        bracketOpen,\n        name,\n        bracketClose,\n    };\n}\nfunction acceptOptionName(parser) {\n    const optionNameSegmentOrDots = many(parser, choice([\n        acceptDot,\n        acceptOptionNameSegment,\n    ]));\n    if (optionNameSegmentOrDots.length < 1)\n        return;\n    return {\n        ...mergeSpans(optionNameSegmentOrDots),\n        type: \"option-name\",\n        optionNameSegmentOrDots,\n    };\n}\nfunction expectOptionName(parser) {\n    const optionName = acceptOptionName(parser);\n    if (optionName)\n        return optionName;\n    throw new recursive_descent_parser_1.SyntaxError(parser, [\"(\", identPattern]);\n}\nfunction acceptSyntax(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"syntax\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const eq = parser.expect(\"=\");\n    skipWsAndComments(parser);\n    const quoteOpen = parser.expect(/^['\"]/);\n    const syntax = parser.expect(/^[^'\"]+/);\n    const quoteClose = parser.expect(/^['\"]/);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"syntax\",\n        keyword,\n        eq,\n        quoteOpen,\n        syntax,\n        quoteClose,\n        semi,\n    };\n}\nfunction acceptImport(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"import\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const weakOrPublic = parser.accept(/^weak|^public/);\n    skipWsAndComments(parser);\n    const strLit = expectStrLit(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"import\",\n        keyword,\n        weakOrPublic,\n        strLit,\n        semi,\n    };\n}\nfunction acceptPackage(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"package\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const fullIdent = expectFullIdent(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"package\",\n        keyword,\n        fullIdent,\n        semi,\n    };\n}\nfunction acceptOption(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, /^option\\b/);\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const optionName = expectOptionName(parser);\n    skipWsAndComments(parser);\n    const eq = parser.expect(\"=\");\n    skipWsAndComments(parser);\n    const constant = expectConstant(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"option\",\n        keyword,\n        optionName,\n        eq,\n        constant,\n        semi,\n    };\n}\nfunction acceptEmpty(parser, leadingComments, leadingDetachedComments) {\n    const semi = acceptSemi(parser);\n    if (!semi)\n        return;\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"empty\",\n        semi,\n    };\n}\nfunction acceptFieldOption(parser) {\n    const optionName = acceptOptionName(parser);\n    if (!optionName)\n        return;\n    skipWsAndComments(parser);\n    const eq = parser.expect(\"=\");\n    skipWsAndComments(parser);\n    const constant = expectConstant(parser);\n    return {\n        ...mergeSpans([optionName, constant]),\n        type: \"field-option\",\n        optionName,\n        eq,\n        constant,\n    };\n}\nfunction acceptFieldOptions(parser) {\n    const bracketOpen = parser.accept(\"[\");\n    if (!bracketOpen)\n        return;\n    const fieldOptionOrCommas = many(parser, choice([\n        skipWsAndComments,\n        acceptComma,\n        acceptFieldOption,\n    ]));\n    const bracketClose = parser.expect(\"]\");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: \"field-options\",\n        bracketOpen,\n        fieldOptionOrCommas,\n        bracketClose,\n    };\n}\nfunction acceptEnumField(parser, leadingComments, leadingDetachedComments) {\n    const fieldName = parser.accept(identPattern);\n    if (!fieldName)\n        return;\n    skipWsAndComments(parser);\n    const eq = parser.expect(\"=\");\n    skipWsAndComments(parser);\n    const fieldNumber = expectSignedIntLit(parser);\n    skipWsAndComments(parser);\n    const fieldOptions = acceptFieldOptions(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            fieldName,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"enum-field\",\n        fieldName,\n        eq,\n        fieldNumber,\n        fieldOptions,\n        semi,\n    };\n}\nfunction expectEnumBody(parser) {\n    const bracketOpen = parser.expect(\"{\");\n    const statements = acceptStatements(parser, [\n        acceptOption,\n        acceptReserved,\n        acceptEnumField,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect(\"}\");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: \"enum-body\",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptEnum(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"enum\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const enumName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const enumBody = expectEnumBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            enumBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"enum\",\n        keyword,\n        enumName,\n        enumBody,\n    };\n}\nfunction acceptField(parser, leadingComments, leadingDetachedComments) {\n    const loc = parser.loc;\n    const fieldLabel = acceptKeyword(parser, /^required|^optional|^repeated/);\n    skipWsAndComments(parser);\n    const fieldType = acceptType(parser);\n    if (!fieldType) {\n        parser.loc = loc;\n        return;\n    }\n    const rest = acceptComplexSequence(parser, [\n        [\"fieldName\", (parser) => parser.expect(identPattern)],\n        [\"eq\", (parser) => parser.expect(\"=\")],\n        [\"fieldNumber\", expectIntLit],\n        [\"fieldOptions\", acceptFieldOptions],\n        [\"semi\", expectSemi],\n    ], messageBodyStatementKeywordPattern);\n    const trailingComments = rest.result.semi\n        ? acceptTrailingComments(parser)\n        : [];\n    const type = rest.partial ? \"malformed-field\" : \"field\";\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            fieldLabel,\n            fieldType,\n            rest.result.semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: type,\n        fieldLabel,\n        fieldType,\n        ...rest.result,\n    };\n}\nfunction acceptOneofField(parser, leadingComments, leadingDetachedComments) {\n    const fieldType = acceptType(parser);\n    if (!fieldType)\n        return;\n    skipWsAndComments(parser);\n    const fieldName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const eq = parser.expect(\"=\");\n    skipWsAndComments(parser);\n    const fieldNumber = expectIntLit(parser);\n    skipWsAndComments(parser);\n    const fieldOptions = acceptFieldOptions(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            fieldType,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"oneof-field\",\n        fieldType,\n        fieldName,\n        eq,\n        fieldNumber,\n        fieldOptions,\n        semi,\n    };\n}\nfunction acceptMapField(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"map\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const typeBracketOpen = parser.expect(\"<\");\n    skipWsAndComments(parser);\n    const keyType = expectType(parser);\n    skipWsAndComments(parser);\n    const typeSep = parser.expect(\",\");\n    skipWsAndComments(parser);\n    const valueType = expectType(parser);\n    skipWsAndComments(parser);\n    const typeBracketClose = parser.expect(\">\");\n    skipWsAndComments(parser);\n    const mapName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const eq = parser.expect(\"=\");\n    skipWsAndComments(parser);\n    const fieldNumber = expectIntLit(parser);\n    skipWsAndComments(parser);\n    const fieldOptions = acceptFieldOptions(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"map-field\",\n        keyword,\n        typeBracketOpen,\n        keyType,\n        typeSep,\n        valueType,\n        typeBracketClose,\n        mapName,\n        eq,\n        fieldNumber,\n        fieldOptions,\n        semi,\n    };\n}\nfunction expectOneofBody(parser) {\n    const bracketOpen = parser.expect(\"{\");\n    const statements = acceptStatements(parser, [\n        acceptOneofGroup,\n        acceptOption,\n        acceptOneofField,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect(\"}\");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: \"oneof-body\",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptOneof(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"oneof\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const oneofName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const oneofBody = expectOneofBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            oneofBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"oneof\",\n        keyword,\n        oneofName,\n        oneofBody,\n    };\n}\nconst acceptMax = acceptPatternAndThen(\"max\", (max) => ({ type: \"max\", ...max }));\nfunction acceptRange(parser) {\n    var _a;\n    const rangeStart = acceptIntLit(parser);\n    if (!rangeStart)\n        return;\n    skipWsAndComments(parser);\n    const to = acceptKeyword(parser, \"to\");\n    if (!to) {\n        return {\n            start: rangeStart.start,\n            end: rangeStart.end,\n            type: \"range\",\n            rangeStart,\n        };\n    }\n    skipWsAndComments(parser);\n    const rangeEnd = (_a = acceptIntLit(parser)) !== null && _a !== void 0 ? _a : acceptMax(parser);\n    if (!rangeEnd)\n        throw new recursive_descent_parser_1.SyntaxError(parser, [intLitPattern, \"max\"]);\n    return {\n        ...mergeSpans([rangeStart, rangeEnd]),\n        type: \"range\",\n        rangeStart,\n        to,\n        rangeEnd,\n    };\n}\nfunction expectRanges(parser) {\n    const rangeOrCommas = many(parser, choice([\n        skipWsAndComments,\n        acceptComma,\n        acceptRange,\n    ]));\n    return {\n        ...mergeSpans(rangeOrCommas),\n        type: \"ranges\",\n        rangeOrCommas,\n    };\n}\nfunction acceptExtensions(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"extensions\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const ranges = expectRanges(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"extensions\",\n        keyword,\n        ranges,\n        semi,\n    };\n}\nfunction expectFieldNames(parser) {\n    const strLitOrCommas = many(parser, choice([\n        skipWsAndComments,\n        acceptComma,\n        acceptStrLit,\n    ]));\n    return {\n        ...mergeSpans(strLitOrCommas),\n        type: \"field-names\",\n        strLitOrCommas,\n    };\n}\nfunction acceptReserved(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"reserved\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const reserved = parser.try(intLitPattern)\n        ? expectRanges(parser)\n        : expectFieldNames(parser);\n    skipWsAndComments(parser);\n    const semi = expectSemi(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semi,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"reserved\",\n        keyword,\n        reserved,\n        semi,\n    };\n}\nfunction expectExtendBody(parser) {\n    const bracketOpen = parser.expect(\"{\");\n    const statements = acceptStatements(parser, [\n        acceptGroup,\n        acceptField,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect(\"}\");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: \"extend-body\",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptExtend(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"extend\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const messageType = expectType(parser);\n    skipWsAndComments(parser);\n    const extendBody = expectExtendBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            extendBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"extend\",\n        keyword,\n        messageType,\n        extendBody,\n    };\n}\nfunction acceptGroup(parser, leadingComments, leadingDetachedComments) {\n    const loc = parser.loc;\n    const groupLabel = acceptKeyword(parser, /^required|^optional|^repeated/);\n    if (!groupLabel) {\n        parser.loc = loc;\n        return;\n    }\n    skipWsAndComments(parser);\n    const keyword = acceptKeyword(parser, \"group\");\n    if (!keyword) {\n        parser.loc = loc;\n        return;\n    }\n    skipWsAndComments(parser);\n    const groupName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const eq = parser.expect(\"=\");\n    skipWsAndComments(parser);\n    const fieldNumber = expectIntLit(parser);\n    skipWsAndComments(parser);\n    const messageBody = expectMessageBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            groupLabel,\n            messageBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"group\",\n        groupLabel,\n        keyword,\n        groupName,\n        eq,\n        fieldNumber,\n        messageBody,\n    };\n}\nfunction acceptOneofGroup(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"group\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const groupName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const eq = parser.expect(\"=\");\n    skipWsAndComments(parser);\n    const fieldNumber = expectIntLit(parser);\n    skipWsAndComments(parser);\n    const messageBody = expectMessageBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            messageBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"oneof-group\",\n        keyword,\n        groupName,\n        eq,\n        fieldNumber,\n        messageBody,\n    };\n}\nfunction expectMessageBody(parser) {\n    const bracketOpen = parser.expect(\"{\");\n    const statements = acceptStatements(parser, [\n        acceptGroup,\n        acceptEnum,\n        acceptMessage,\n        acceptExtend,\n        acceptExtensions,\n        acceptOption,\n        acceptOneof,\n        acceptMapField,\n        acceptReserved,\n        acceptField,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect(\"}\");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: \"message-body\",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptMessage(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"message\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const messageName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const messageBody = expectMessageBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            messageBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"message\",\n        keyword,\n        messageName,\n        messageBody,\n    };\n}\nfunction expectRpcType(parser) {\n    const bracketOpen = parser.expect(\"(\");\n    skipWsAndComments(parser);\n    const stream = acceptKeyword(parser, \"stream\");\n    skipWsAndComments(parser);\n    const messageType = expectType(parser);\n    skipWsAndComments(parser);\n    const bracketClose = parser.expect(\")\");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        bracketOpen,\n        stream,\n        messageType,\n        bracketClose,\n    };\n}\nfunction acceptRpc(parser, leadingComments, leadingDetachedComments) {\n    var _a;\n    const keyword = acceptKeyword(parser, \"rpc\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const rpcName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const reqType = expectRpcType(parser);\n    skipWsAndComments(parser);\n    const returns = parser.expect(\"returns\");\n    skipWsAndComments(parser);\n    const resType = expectRpcType(parser);\n    skipWsAndComments(parser);\n    const semiOrRpcBody = (_a = acceptSemi(parser)) !== null && _a !== void 0 ? _a : expectRpcBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            semiOrRpcBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"rpc\",\n        keyword,\n        rpcName,\n        reqType,\n        returns,\n        resType,\n        semiOrRpcBody,\n    };\n}\nfunction expectRpcBody(parser) {\n    const bracketOpen = parser.expect(\"{\");\n    const statements = acceptStatements(parser, [\n        acceptOption,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect(\"}\");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: \"rpc-body\",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction expectServiceBody(parser) {\n    const bracketOpen = parser.expect(\"{\");\n    const statements = acceptStatements(parser, [\n        acceptOption,\n        acceptRpc,\n        acceptEmpty,\n    ]);\n    const bracketClose = parser.expect(\"}\");\n    return {\n        ...mergeSpans([bracketOpen, bracketClose]),\n        type: \"service-body\",\n        bracketOpen,\n        statements,\n        bracketClose,\n    };\n}\nfunction acceptService(parser, leadingComments, leadingDetachedComments) {\n    const keyword = acceptKeyword(parser, \"service\");\n    if (!keyword)\n        return;\n    skipWsAndComments(parser);\n    const serviceName = parser.expect(identPattern);\n    skipWsAndComments(parser);\n    const serviceBody = expectServiceBody(parser);\n    const trailingComments = acceptTrailingComments(parser);\n    return {\n        ...mergeSpans([\n            leadingDetachedComments,\n            leadingComments,\n            keyword,\n            serviceBody,\n            trailingComments,\n        ]),\n        leadingComments,\n        trailingComments,\n        leadingDetachedComments,\n        type: \"service\",\n        keyword,\n        serviceName,\n        serviceBody,\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGJraXQvY29yZS9wYXJzZXIvcHJvdG8uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGJraXQvY29yZS9wYXJzZXIvcHJvdG8uanM/MDEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VDb25zdGFudCA9IGV4cG9ydHMucGFyc2UgPSB2b2lkIDA7XG5jb25zdCByZWN1cnNpdmVfZGVzY2VudF9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3JlY3Vyc2l2ZS1kZXNjZW50LXBhcnNlclwiKTtcbmZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgICBjb25zdCBwYXJzZXIgPSAoMCwgcmVjdXJzaXZlX2Rlc2NlbnRfcGFyc2VyXzEuY3JlYXRlUmVjdXJzaXZlRGVzY2VudFBhcnNlcikodGV4dCk7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IGFjY2VwdFN0YXRlbWVudHMocGFyc2VyLCBbXG4gICAgICAgIGFjY2VwdFN5bnRheCxcbiAgICAgICAgYWNjZXB0SW1wb3J0LFxuICAgICAgICBhY2NlcHRQYWNrYWdlLFxuICAgICAgICBhY2NlcHRPcHRpb24sXG4gICAgICAgIGFjY2VwdE1lc3NhZ2UsXG4gICAgICAgIGFjY2VwdEVudW0sXG4gICAgICAgIGFjY2VwdEV4dGVuZCxcbiAgICAgICAgYWNjZXB0U2VydmljZSxcbiAgICAgICAgYWNjZXB0RW1wdHksXG4gICAgXSk7XG4gICAgY29uc3QgYXN0ID0geyBzdGF0ZW1lbnRzIH07XG4gICAgcmV0dXJuIHsgYXN0LCBwYXJzZXIgfTtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmZ1bmN0aW9uIHBhcnNlQ29uc3RhbnQodGV4dCkge1xuICAgIGNvbnN0IHBhcnNlciA9ICgwLCByZWN1cnNpdmVfZGVzY2VudF9wYXJzZXJfMS5jcmVhdGVSZWN1cnNpdmVEZXNjZW50UGFyc2VyKSh0ZXh0KTtcbiAgICBjb25zdCBjb25zdGFudCA9IGV4cGVjdENvbnN0YW50KHBhcnNlcik7XG4gICAgcmV0dXJuIHsgYXN0OiBjb25zdGFudCwgcGFyc2VyIH07XG59XG5leHBvcnRzLnBhcnNlQ29uc3RhbnQgPSBwYXJzZUNvbnN0YW50O1xuZnVuY3Rpb24gbWVyZ2VTcGFucyhzcGFucykge1xuICAgIGxldCBzdGFydCA9IEluZmluaXR5O1xuICAgIGxldCBlbmQgPSAtSW5maW5pdHk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc3BhbnNbaV0gPT0gbnVsbClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzcGFuID0gQXJyYXkuaXNBcnJheShzcGFuc1tpXSlcbiAgICAgICAgICAgID8gbWVyZ2VTcGFucyhzcGFuc1tpXSlcbiAgICAgICAgICAgIDogc3BhbnNbaV07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5taW4oc3RhcnQsIHNwYW4uc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1heChlbmQsIHNwYW4uZW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xufVxuZnVuY3Rpb24gYWNjZXB0UGF0dGVybkFuZFRoZW4ocGF0dGVybiwgdGhlbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBhY2NlcHQocGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFyc2VyLmFjY2VwdChwYXR0ZXJuKTtcbiAgICAgICAgaWYgKCF0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHRoZW4odG9rZW4pO1xuICAgIH07XG59XG5mdW5jdGlvbiBjaG9pY2UoYWNjZXB0Rm5zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFjY2VwdChwYXJzZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBhY2NlcHRGbiBvZiBhY2NlcHRGbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBhY2NlcHRGbihwYXJzZXIpO1xuICAgICAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbWFueShwYXJzZXIsIGFjY2VwdEZuKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBsZXQgbm9kZTtcbiAgICB3aGlsZSAobm9kZSA9IGFjY2VwdEZuKHBhcnNlcikpXG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgcmV0dXJuIG5vZGVzO1xufVxuZnVuY3Rpb24gYWNjZXB0Q29tcGxleFNlcXVlbmNlKHBhcnNlciwgZXhwZWN0Rm5TZXEsIGVzY2FwZVBhdHRlcm4pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBsZXQgcGFydGlhbCA9IGZhbHNlO1xuICAgIGxldCBoYXNOZXdsaW5lID0gZmFsc2U7XG4gICAgbGV0IHJlY292ZXJ5UG9pbnQ7XG4gICAgZm9yIChjb25zdCBba2V5LCBleHBlY3RGbl0gb2YgZXhwZWN0Rm5TZXEpIHtcbiAgICAgICAgY29uc3QgbG9jID0gcGFyc2VyLmxvYztcbiAgICAgICAgaGFzTmV3bGluZSA9IHNraXBXc0FuZENvbW1lbnRzMihwYXJzZXIpO1xuICAgICAgICBpZiAoaGFzTmV3bGluZSAmJiAhcmVjb3ZlcnlQb2ludCkge1xuICAgICAgICAgICAgcmVjb3ZlcnlQb2ludCA9IHsgbG9jOiBwYXJzZXIubG9jLCByZXN1bHQ6IHsgLi4ucmVzdWx0IH0gfTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBleHBlY3RGbihwYXJzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHBhcnNlci5sb2MgPSBsb2M7XG4gICAgICAgICAgICBwYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlc2NhcGVQYXR0ZXJuICYmIHBhcnNlci50cnkoZXNjYXBlUGF0dGVybikpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnRpYWwgJiYgcmVjb3ZlcnlQb2ludCkge1xuICAgICAgICBwYXJzZXIubG9jID0gcmVjb3ZlcnlQb2ludC5sb2M7XG4gICAgICAgIHJldHVybiB7IHBhcnRpYWwsIHJlc3VsdDogcmVjb3ZlcnlQb2ludC5yZXN1bHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcGFydGlhbCwgcmVzdWx0IH07XG59XG5mdW5jdGlvbiBhY2NlcHRTdGF0ZW1lbnRzKHBhcnNlciwgYWNjZXB0U3RhdGVtZW50Rm5zKSB7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xuICAgIHN0YXRlbWVudHM6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgY29tbWVudEdyb3VwcywgdHJhaWxpbmdOZXdsaW5lIH0gPSBza2lwV3NBbmRTd2VlcENvbW1lbnRzKHBhcnNlcik7XG4gICAgICAgIGxldCBsZWFkaW5nQ29tbWVudHM7XG4gICAgICAgIGxldCBsZWFkaW5nRGV0YWNoZWRDb21tZW50cztcbiAgICAgICAgaWYgKHRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyA9IGNvbW1lbnRHcm91cHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29tbWVudEdyb3Vwcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyA9IFtjb21tZW50R3JvdXBzLnBvcCgpXTtcbiAgICAgICAgICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyA9IGNvbW1lbnRHcm91cHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhY2NlcHRTdGF0ZW1lbnRGbiBvZiBhY2NlcHRTdGF0ZW1lbnRGbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlbWVudCA9IGFjY2VwdFN0YXRlbWVudEZuKHBhcnNlciwgbGVhZGluZ0NvbW1lbnRzLCBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyk7XG4gICAgICAgICAgICBpZiAoc3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gICAgICAgICAgICAgICAgY29udGludWUgc3RhdGVtZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG5jb25zdCB3aGl0ZXNwYWNlUGF0dGVybiA9IC9eXFxzKy87XG5jb25zdCB3aGl0ZXNwYWNlV2l0aG91dE5ld2xpbmVQYXR0ZXJuID0gL15bIFxcZlxcdFxcdlxcdTAwYTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBhXFx1MjAyOFxcdTIwMjlcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXSsvO1xuY29uc3QgbmV3bGluZVBhdHRlcm4gPSAvXlxccj9cXG4vO1xuY29uc3QgbXVsdGlsaW5lQ29tbWVudFBhdHRlcm4gPSAvXlxcL1xcKig/Oi58XFxyP1xcbikqP1xcKlxcLy87XG5jb25zdCBzaW5nbGVsaW5lQ29tbWVudFBhdHRlcm4gPSAvXlxcL1xcLy4qKD86XFxyP1xcbnwkKS87XG5jb25zdCBpbnRMaXRQYXR0ZXJuID0gL14wKD86eFswLTlhLWZdK3xbMC03XSopfF5bMS05XVxcZCovaTtcbmNvbnN0IGZsb2F0TGl0UGF0dGVybiA9IC9eXFxkK1xcLlxcZCooPzplWy0rXT9cXGQrKT98XlxcZCtlWy0rXT9cXGQrfF5cXC5cXGQrKD86ZVstK10/XFxkKyk/fF5pbmZ8Xm5hbi9pO1xuY29uc3QgYm9vbExpdFBhdHRlcm4gPSAvXnRydWV8XmZhbHNlLztcbmNvbnN0IHN0ckxpdFBhdHRlcm4gPSAvXicoPzpcXFxceFswLTlhLWZdezJ9fFxcXFxbMC03XXszfXxcXFxcWzAtN118XFxcXFthYmZucnR2XFxcXFxcPydcIl18W14nXFwwXFxuXFxcXF0pKid8XlwiKD86XFxcXHhbMC05YS1mXXsyfXxcXFxcWzAtN117M318XFxcXFswLTddfFxcXFxbYWJmbnJ0dlxcXFxcXD8nXCJdfFteXCJcXDBcXG5cXFxcXSkqXCIvaTtcbmNvbnN0IGlkZW50UGF0dGVybiA9IC9eW2Etel9dW2EtejAtOV9dKi9pO1xuY29uc3QgbWVzc2FnZUJvZHlTdGF0ZW1lbnRLZXl3b3JkUGF0dGVybiA9IC9eKD86ZW51bXxtZXNzYWdlfGV4dGVuZHxleHRlbnNpb25zfGdyb3VwfG9wdGlvbnxvbmVvZnxtYXB8cmVzZXJ2ZWQpXFxiLztcbmNvbnN0IGFjY2VwdERvdCA9IGFjY2VwdFBhdHRlcm5BbmRUaGVuKFwiLlwiLCAoZG90KSA9PiAoeyB0eXBlOiBcImRvdFwiLCAuLi5kb3QgfSkpO1xuY29uc3QgYWNjZXB0Q29tbWEgPSBhY2NlcHRQYXR0ZXJuQW5kVGhlbihcIixcIiwgKGNvbW1hKSA9PiAoeyB0eXBlOiBcImNvbW1hXCIsIC4uLmNvbW1hIH0pKTtcbmNvbnN0IGFjY2VwdFNlbWkgPSBhY2NlcHRQYXR0ZXJuQW5kVGhlbihcIjtcIiwgKHNlbWkpID0+ICh7IHR5cGU6IFwic2VtaVwiLCAuLi5zZW1pIH0pKTtcbmZ1bmN0aW9uIGV4cGVjdFNlbWkocGFyc2VyKSB7XG4gICAgY29uc3Qgc2VtaSA9IGFjY2VwdFNlbWkocGFyc2VyKTtcbiAgICBpZiAoc2VtaSlcbiAgICAgICAgcmV0dXJuIHNlbWk7XG4gICAgdGhyb3cgbmV3IHJlY3Vyc2l2ZV9kZXNjZW50X3BhcnNlcl8xLlN5bnRheEVycm9yKHBhcnNlciwgW1wiO1wiXSk7XG59XG5jb25zdCBhY2NlcHRJZGVudCA9IGFjY2VwdFBhdHRlcm5BbmRUaGVuKGlkZW50UGF0dGVybiwgKGlkZW50KSA9PiAoeyB0eXBlOiBcImlkZW50XCIsIC4uLmlkZW50IH0pKTtcbmZ1bmN0aW9uIGFjY2VwdFNwZWNpYWxUb2tlbihwYXJzZXIsIHR5cGUsIHBhdHRlcm4gPSBpZGVudFBhdHRlcm4pIHtcbiAgICBjb25zdCB0b2tlbiA9IHBhcnNlci5hY2NlcHQocGF0dGVybik7XG4gICAgaWYgKCF0b2tlbilcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB7IHR5cGUsIC4uLnRva2VuIH07XG59XG5mdW5jdGlvbiBhY2NlcHRLZXl3b3JkKHBhcnNlciwgcGF0dGVybiA9IGlkZW50UGF0dGVybikge1xuICAgIHJldHVybiBhY2NlcHRTcGVjaWFsVG9rZW4ocGFyc2VyLCBcImtleXdvcmRcIiwgcGF0dGVybik7XG59XG5mdW5jdGlvbiBhY2NlcHRDb21tZW50R3JvdXAocGFyc2VyKSB7XG4gICAgY29uc3QgbG9jID0gcGFyc2VyLmxvYztcbiAgICBjb25zdCBjb21tZW50cyA9IFtdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHdoaXRlc3BhY2UgPSBwYXJzZXIuYWNjZXB0KHdoaXRlc3BhY2VXaXRob3V0TmV3bGluZVBhdHRlcm4pO1xuICAgICAgICBpZiAod2hpdGVzcGFjZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtdWx0aWxpbmVDb21tZW50ID0gYWNjZXB0U3BlY2lhbFRva2VuKHBhcnNlciwgXCJtdWx0aWxpbmUtY29tbWVudFwiLCBtdWx0aWxpbmVDb21tZW50UGF0dGVybik7XG4gICAgICAgIGlmIChtdWx0aWxpbmVDb21tZW50KSB7XG4gICAgICAgICAgICBjb21tZW50cy5wdXNoKG11bHRpbGluZUNvbW1lbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2luZ2xlbGluZUNvbW1lbnQgPSBhY2NlcHRTcGVjaWFsVG9rZW4ocGFyc2VyLCBcInNpbmdsZWxpbmUtY29tbWVudFwiLCBzaW5nbGVsaW5lQ29tbWVudFBhdHRlcm4pO1xuICAgICAgICBpZiAoc2luZ2xlbGluZUNvbW1lbnQpIHtcbiAgICAgICAgICAgIGNvbW1lbnRzLnB1c2goc2luZ2xlbGluZUNvbW1lbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChjb21tZW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHBhcnNlci5sb2MgPSBsb2M7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhjb21tZW50cyksXG4gICAgICAgIHR5cGU6IFwiY29tbWVudC1ncm91cFwiLFxuICAgICAgICBjb21tZW50cyxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWNjZXB0VHJhaWxpbmdDb21tZW50cyhwYXJzZXIpIHtcbiAgICBjb25zdCBsb2MgPSBwYXJzZXIubG9jO1xuICAgIGNvbnN0IGNvbW1lbnRzID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qgd2hpdGVzcGFjZSA9IHBhcnNlci5hY2NlcHQod2hpdGVzcGFjZVdpdGhvdXROZXdsaW5lUGF0dGVybik7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IG5ld2xpbmUgPSBwYXJzZXIuYWNjZXB0KG5ld2xpbmVQYXR0ZXJuKTtcbiAgICAgICAgaWYgKG5ld2xpbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY29uc3QgbXVsdGlsaW5lQ29tbWVudCA9IGFjY2VwdFNwZWNpYWxUb2tlbihwYXJzZXIsIFwibXVsdGlsaW5lLWNvbW1lbnRcIiwgbXVsdGlsaW5lQ29tbWVudFBhdHRlcm4pO1xuICAgICAgICBpZiAobXVsdGlsaW5lQ29tbWVudCkge1xuICAgICAgICAgICAgY29tbWVudHMucHVzaChtdWx0aWxpbmVDb21tZW50KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpbmdsZWxpbmVDb21tZW50ID0gYWNjZXB0U3BlY2lhbFRva2VuKHBhcnNlciwgXCJzaW5nbGVsaW5lLWNvbW1lbnRcIiwgc2luZ2xlbGluZUNvbW1lbnRQYXR0ZXJuKTtcbiAgICAgICAgaWYgKHNpbmdsZWxpbmVDb21tZW50KSB7XG4gICAgICAgICAgICBjb21tZW50cy5wdXNoKHNpbmdsZWxpbmVDb21tZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoY29tbWVudHMubGVuZ3RoIDwgMSkge1xuICAgICAgICBwYXJzZXIubG9jID0gbG9jO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgICAgICAgLi4ubWVyZ2VTcGFucyhjb21tZW50cyksXG4gICAgICAgICAgICB0eXBlOiBcImNvbW1lbnQtZ3JvdXBcIixcbiAgICAgICAgICAgIGNvbW1lbnRzLFxuICAgICAgICB9XTtcbn1cbmZ1bmN0aW9uIHNraXBXc0FuZFN3ZWVwQ29tbWVudHMocGFyc2VyKSB7XG4gICAgY29uc3QgY29tbWVudEdyb3VwcyA9IFtdO1xuICAgIGxldCB0cmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgICBwYXJzZXIuYWNjZXB0KHdoaXRlc3BhY2VQYXR0ZXJuKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBjb21tZW50R3JvdXAgPSBhY2NlcHRDb21tZW50R3JvdXAocGFyc2VyKTtcbiAgICAgICAgaWYgKGNvbW1lbnRHcm91cCkge1xuICAgICAgICAgICAgY29tbWVudEdyb3Vwcy5wdXNoKGNvbW1lbnRHcm91cCk7XG4gICAgICAgICAgICB0cmFpbGluZ05ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdoaXRlc3BhY2UgPSBwYXJzZXIuYWNjZXB0KHdoaXRlc3BhY2VXaXRob3V0TmV3bGluZVBhdHRlcm4pO1xuICAgICAgICBpZiAod2hpdGVzcGFjZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBuZXdsaW5lID0gcGFyc2VyLmFjY2VwdChuZXdsaW5lUGF0dGVybik7XG4gICAgICAgIGlmIChuZXdsaW5lKSB7XG4gICAgICAgICAgICB0cmFpbGluZ05ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1lbnRHcm91cHMsXG4gICAgICAgIHRyYWlsaW5nTmV3bGluZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3Qgd2hpdGVzcGFjZSA9IHBhcnNlci5hY2NlcHQod2hpdGVzcGFjZVBhdHRlcm4pO1xuICAgICAgICBpZiAod2hpdGVzcGFjZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtdWx0aWxpbmVDb21tZW50ID0gYWNjZXB0U3BlY2lhbFRva2VuKHBhcnNlciwgXCJtdWx0aWxpbmUtY29tbWVudFwiLCBtdWx0aWxpbmVDb21tZW50UGF0dGVybik7XG4gICAgICAgIGlmIChtdWx0aWxpbmVDb21tZW50KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNpbmdsZWxpbmVDb21tZW50ID0gYWNjZXB0U3BlY2lhbFRva2VuKHBhcnNlciwgXCJzaW5nbGVsaW5lLWNvbW1lbnRcIiwgc2luZ2xlbGluZUNvbW1lbnRQYXR0ZXJuKTtcbiAgICAgICAgaWYgKHNpbmdsZWxpbmVDb21tZW50KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBza2lwV3NBbmRDb21tZW50czIocGFyc2VyKSB7XG4gICAgbGV0IGhhc05ld2xpbmUgPSBmYWxzZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB3aGl0ZXNwYWNlID0gcGFyc2VyLmFjY2VwdCh3aGl0ZXNwYWNlV2l0aG91dE5ld2xpbmVQYXR0ZXJuKTtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2UpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbmV3bGluZSA9IHBhcnNlci5hY2NlcHQobmV3bGluZVBhdHRlcm4pO1xuICAgICAgICBpZiAobmV3bGluZSkge1xuICAgICAgICAgICAgaGFzTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtdWx0aWxpbmVDb21tZW50ID0gYWNjZXB0U3BlY2lhbFRva2VuKHBhcnNlciwgXCJtdWx0aWxpbmUtY29tbWVudFwiLCBtdWx0aWxpbmVDb21tZW50UGF0dGVybik7XG4gICAgICAgIGlmIChtdWx0aWxpbmVDb21tZW50KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNpbmdsZWxpbmVDb21tZW50ID0gYWNjZXB0U3BlY2lhbFRva2VuKHBhcnNlciwgXCJzaW5nbGVsaW5lLWNvbW1lbnRcIiwgc2luZ2xlbGluZUNvbW1lbnRQYXR0ZXJuKTtcbiAgICAgICAgaWYgKHNpbmdsZWxpbmVDb21tZW50KSB7XG4gICAgICAgICAgICBoYXNOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gaGFzTmV3bGluZTtcbn1cbmZ1bmN0aW9uIGFjY2VwdEZ1bGxJZGVudChwYXJzZXIpIHtcbiAgICBjb25zdCBpZGVudE9yRG90cyA9IG1hbnkocGFyc2VyLCBjaG9pY2UoW1xuICAgICAgICBhY2NlcHREb3QsXG4gICAgICAgIGFjY2VwdElkZW50LFxuICAgIF0pKTtcbiAgICBpZiAoaWRlbnRPckRvdHMubGVuZ3RoIDwgMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoaWRlbnRPckRvdHMpLFxuICAgICAgICB0eXBlOiBcImZ1bGwtaWRlbnRcIixcbiAgICAgICAgaWRlbnRPckRvdHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4cGVjdEZ1bGxJZGVudChwYXJzZXIpIHtcbiAgICBjb25zdCBmdWxsSWRlbnQgPSBhY2NlcHRGdWxsSWRlbnQocGFyc2VyKTtcbiAgICBpZiAoZnVsbElkZW50KVxuICAgICAgICByZXR1cm4gZnVsbElkZW50O1xuICAgIHRocm93IG5ldyByZWN1cnNpdmVfZGVzY2VudF9wYXJzZXJfMS5TeW50YXhFcnJvcihwYXJzZXIsIFtcIi5cIiwgaWRlbnRQYXR0ZXJuXSk7XG59XG5mdW5jdGlvbiBhY2NlcHRUeXBlKHBhcnNlcikge1xuICAgIGNvbnN0IGlkZW50T3JEb3RzID0gbWFueShwYXJzZXIsIGNob2ljZShbXG4gICAgICAgIGFjY2VwdERvdCxcbiAgICAgICAgYWNjZXB0SWRlbnQsXG4gICAgXSkpO1xuICAgIGlmIChpZGVudE9yRG90cy5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm47XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhpZGVudE9yRG90cyksXG4gICAgICAgIHR5cGU6IFwidHlwZVwiLFxuICAgICAgICBpZGVudE9yRG90cyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXhwZWN0VHlwZShwYXJzZXIpIHtcbiAgICBjb25zdCB0eXBlID0gYWNjZXB0VHlwZShwYXJzZXIpO1xuICAgIGlmICh0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB0aHJvdyBuZXcgcmVjdXJzaXZlX2Rlc2NlbnRfcGFyc2VyXzEuU3ludGF4RXJyb3IocGFyc2VyLCBbXCIuXCIsIGlkZW50UGF0dGVybl0pO1xufVxuZnVuY3Rpb24gYWNjZXB0SW50TGl0KHBhcnNlcikge1xuICAgIGNvbnN0IGludExpdCA9IHBhcnNlci5hY2NlcHQoaW50TGl0UGF0dGVybik7XG4gICAgaWYgKCFpbnRMaXQpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4geyB0eXBlOiBcImludC1saXRcIiwgLi4uaW50TGl0IH07XG59XG5mdW5jdGlvbiBleHBlY3RJbnRMaXQocGFyc2VyKSB7XG4gICAgY29uc3QgaW50TGl0ID0gYWNjZXB0SW50TGl0KHBhcnNlcik7XG4gICAgaWYgKGludExpdClcbiAgICAgICAgcmV0dXJuIGludExpdDtcbiAgICB0aHJvdyBuZXcgcmVjdXJzaXZlX2Rlc2NlbnRfcGFyc2VyXzEuU3ludGF4RXJyb3IocGFyc2VyLCBbaW50TGl0UGF0dGVybl0pO1xufVxuZnVuY3Rpb24gYWNjZXB0U2lnbmVkSW50TGl0KHBhcnNlcikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb2MgPSBwYXJzZXIubG9jO1xuICAgIGNvbnN0IHNpZ24gPSAoX2EgPSBwYXJzZXIuYWNjZXB0KFwiLVwiKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcGFyc2VyLmFjY2VwdChcIitcIik7XG4gICAgY29uc3QgaW50TGl0ID0gYWNjZXB0SW50TGl0KHBhcnNlcik7XG4gICAgaWYgKCFpbnRMaXQpIHtcbiAgICAgICAgcGFyc2VyLmxvYyA9IGxvYztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtzaWduLCBpbnRMaXRdKSxcbiAgICAgICAgdHlwZTogXCJzaWduZWQtaW50LWxpdFwiLFxuICAgICAgICBzaWduLFxuICAgICAgICB2YWx1ZTogaW50TGl0LFxuICAgIH07XG59XG5mdW5jdGlvbiBleHBlY3RTaWduZWRJbnRMaXQocGFyc2VyKSB7XG4gICAgY29uc3Qgc2lnbmVkSW50TGl0ID0gYWNjZXB0U2lnbmVkSW50TGl0KHBhcnNlcik7XG4gICAgaWYgKHNpZ25lZEludExpdClcbiAgICAgICAgcmV0dXJuIHNpZ25lZEludExpdDtcbiAgICB0aHJvdyBuZXcgcmVjdXJzaXZlX2Rlc2NlbnRfcGFyc2VyXzEuU3ludGF4RXJyb3IocGFyc2VyLCBbXCItXCIsIGludExpdFBhdHRlcm5dKTtcbn1cbmZ1bmN0aW9uIGFjY2VwdEZsb2F0TGl0KHBhcnNlcikge1xuICAgIGNvbnN0IGZsb2F0TGl0ID0gcGFyc2VyLmFjY2VwdChmbG9hdExpdFBhdHRlcm4pO1xuICAgIGlmICghZmxvYXRMaXQpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4geyB0eXBlOiBcImZsb2F0LWxpdFwiLCAuLi5mbG9hdExpdCB9O1xufVxuZnVuY3Rpb24gYWNjZXB0U2lnbmVkRmxvYXRMaXQocGFyc2VyKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGxvYyA9IHBhcnNlci5sb2M7XG4gICAgY29uc3Qgc2lnbiA9IChfYSA9IHBhcnNlci5hY2NlcHQoXCItXCIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwYXJzZXIuYWNjZXB0KFwiK1wiKTtcbiAgICBjb25zdCBmbG9hdExpdCA9IGFjY2VwdEZsb2F0TGl0KHBhcnNlcik7XG4gICAgaWYgKCFmbG9hdExpdCkge1xuICAgICAgICBwYXJzZXIubG9jID0gbG9jO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW3NpZ24sIGZsb2F0TGl0XSksXG4gICAgICAgIHR5cGU6IFwic2lnbmVkLWZsb2F0LWxpdFwiLFxuICAgICAgICBzaWduLFxuICAgICAgICB2YWx1ZTogZmxvYXRMaXQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdEJvb2xMaXQocGFyc2VyKSB7XG4gICAgY29uc3QgYm9vbExpdCA9IHBhcnNlci5hY2NlcHQoYm9vbExpdFBhdHRlcm4pO1xuICAgIGlmICghYm9vbExpdClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiB7IHR5cGU6IFwiYm9vbC1saXRcIiwgLi4uYm9vbExpdCB9O1xufVxuZnVuY3Rpb24gYWNjZXB0U3RyTGl0KHBhcnNlcikge1xuICAgIGNvbnN0IHN0ckxpdCA9IHBhcnNlci5hY2NlcHQoc3RyTGl0UGF0dGVybik7XG4gICAgaWYgKCFzdHJMaXQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB0b2tlbnMgPSBbc3RyTGl0XTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgICAgICBjb25zdCBzdHJMaXQgPSBwYXJzZXIuYWNjZXB0KHN0ckxpdFBhdHRlcm4pO1xuICAgICAgICBpZiAoIXN0ckxpdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0b2tlbnMucHVzaChzdHJMaXQpO1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5tZXJnZVNwYW5zKHRva2VucyksIHR5cGU6IFwic3RyLWxpdFwiLCB0b2tlbnMgfTtcbn1cbmZ1bmN0aW9uIGV4cGVjdFN0ckxpdChwYXJzZXIpIHtcbiAgICBjb25zdCBzdHJMaXQgPSBhY2NlcHRTdHJMaXQocGFyc2VyKTtcbiAgICBpZiAoc3RyTGl0KVxuICAgICAgICByZXR1cm4gc3RyTGl0O1xuICAgIHRocm93IG5ldyByZWN1cnNpdmVfZGVzY2VudF9wYXJzZXJfMS5TeW50YXhFcnJvcihwYXJzZXIsIFtzdHJMaXRQYXR0ZXJuXSk7XG59XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvYzIxNDg1NjZjNy9zcmMvZ29vZ2xlL3Byb3RvYnVmL2NvbXBpbGVyL3BhcnNlci5jYyNMMTQyOS1MMTQ1MlxuZnVuY3Rpb24gYWNjZXB0QWdncmVnYXRlKHBhcnNlcikge1xuICAgIGNvbnN0IHBhcmVudGhlc2lzT3BlbiA9IHBhcnNlci5hY2NlcHQoXCJ7XCIpO1xuICAgIGlmICghcGFyZW50aGVzaXNPcGVuKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGNoYXJhY3RlciA9IHBhcmVudGhlc2lzT3BlbjtcbiAgICBsZXQgZGVwdGggPSAxO1xuICAgIHdoaWxlIChjaGFyYWN0ZXIgPSBwYXJzZXIuZXhwZWN0KC9eKD86XFxzfFxcUykvKSkge1xuICAgICAgICBzd2l0Y2ggKGNoYXJhY3Rlci50ZXh0KSB7XG4gICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgICsrZGVwdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwifVwiOlxuICAgICAgICAgICAgICAgIC0tZGVwdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtwYXJlbnRoZXNpc09wZW4sIGNoYXJhY3Rlcl0pLFxuICAgICAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIH07XG59XG5mdW5jdGlvbiBhY2NlcHRDb25zdGFudChwYXJzZXIpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIHJldHVybiAoX2UgPSAoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSBhY2NlcHRTaWduZWRGbG9hdExpdChwYXJzZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBhY2NlcHRTaWduZWRJbnRMaXQocGFyc2VyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogYWNjZXB0U3RyTGl0KHBhcnNlcikpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGFjY2VwdEJvb2xMaXQocGFyc2VyKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogYWNjZXB0RnVsbElkZW50KHBhcnNlcikpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGFjY2VwdEFnZ3JlZ2F0ZShwYXJzZXIpO1xufVxuZnVuY3Rpb24gZXhwZWN0Q29uc3RhbnQocGFyc2VyKSB7XG4gICAgY29uc3QgY29uc3RhbnQgPSBhY2NlcHRDb25zdGFudChwYXJzZXIpO1xuICAgIGlmIChjb25zdGFudClcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIHRocm93IG5ldyByZWN1cnNpdmVfZGVzY2VudF9wYXJzZXJfMS5TeW50YXhFcnJvcihwYXJzZXIsIFtcbiAgICAgICAgaWRlbnRQYXR0ZXJuLFxuICAgICAgICBcIi1cIixcbiAgICAgICAgXCIrXCIsXG4gICAgICAgIGludExpdFBhdHRlcm4sXG4gICAgICAgIHN0ckxpdFBhdHRlcm4sXG4gICAgICAgIGJvb2xMaXRQYXR0ZXJuLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gYWNjZXB0T3B0aW9uTmFtZVNlZ21lbnQocGFyc2VyKSB7XG4gICAgY29uc3QgYnJhY2tldE9wZW4gPSBwYXJzZXIuYWNjZXB0KFwiKFwiKTtcbiAgICBjb25zdCBuYW1lID0gYWNjZXB0RnVsbElkZW50KHBhcnNlcik7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIGlmIChicmFja2V0T3BlbilcbiAgICAgICAgICAgIHRocm93IG5ldyByZWN1cnNpdmVfZGVzY2VudF9wYXJzZXJfMS5TeW50YXhFcnJvcihwYXJzZXIsIFtpZGVudFBhdHRlcm5dKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBicmFja2V0Q2xvc2UgPSBwYXJzZXJbYnJhY2tldE9wZW4gPyBcImV4cGVjdFwiIDogXCJhY2NlcHRcIl0oXCIpXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW2JyYWNrZXRPcGVuLCBuYW1lLCBicmFja2V0Q2xvc2VdKSxcbiAgICAgICAgdHlwZTogXCJvcHRpb24tbmFtZS1zZWdtZW50XCIsXG4gICAgICAgIGJyYWNrZXRPcGVuLFxuICAgICAgICBuYW1lLFxuICAgICAgICBicmFja2V0Q2xvc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdE9wdGlvbk5hbWUocGFyc2VyKSB7XG4gICAgY29uc3Qgb3B0aW9uTmFtZVNlZ21lbnRPckRvdHMgPSBtYW55KHBhcnNlciwgY2hvaWNlKFtcbiAgICAgICAgYWNjZXB0RG90LFxuICAgICAgICBhY2NlcHRPcHRpb25OYW1lU2VnbWVudCxcbiAgICBdKSk7XG4gICAgaWYgKG9wdGlvbk5hbWVTZWdtZW50T3JEb3RzLmxlbmd0aCA8IDEpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKG9wdGlvbk5hbWVTZWdtZW50T3JEb3RzKSxcbiAgICAgICAgdHlwZTogXCJvcHRpb24tbmFtZVwiLFxuICAgICAgICBvcHRpb25OYW1lU2VnbWVudE9yRG90cyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXhwZWN0T3B0aW9uTmFtZShwYXJzZXIpIHtcbiAgICBjb25zdCBvcHRpb25OYW1lID0gYWNjZXB0T3B0aW9uTmFtZShwYXJzZXIpO1xuICAgIGlmIChvcHRpb25OYW1lKVxuICAgICAgICByZXR1cm4gb3B0aW9uTmFtZTtcbiAgICB0aHJvdyBuZXcgcmVjdXJzaXZlX2Rlc2NlbnRfcGFyc2VyXzEuU3ludGF4RXJyb3IocGFyc2VyLCBbXCIoXCIsIGlkZW50UGF0dGVybl0pO1xufVxuZnVuY3Rpb24gYWNjZXB0U3ludGF4KHBhcnNlciwgbGVhZGluZ0NvbW1lbnRzLCBsZWFkaW5nRGV0YWNoZWRDb21tZW50cykge1xuICAgIGNvbnN0IGtleXdvcmQgPSBhY2NlcHRLZXl3b3JkKHBhcnNlciwgXCJzeW50YXhcIik7XG4gICAgaWYgKCFrZXl3b3JkKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBlcSA9IHBhcnNlci5leHBlY3QoXCI9XCIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgcXVvdGVPcGVuID0gcGFyc2VyLmV4cGVjdCgvXlsnXCJdLyk7XG4gICAgY29uc3Qgc3ludGF4ID0gcGFyc2VyLmV4cGVjdCgvXlteJ1wiXSsvKTtcbiAgICBjb25zdCBxdW90ZUNsb3NlID0gcGFyc2VyLmV4cGVjdCgvXlsnXCJdLyk7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBzZW1pID0gZXhwZWN0U2VtaShwYXJzZXIpO1xuICAgIGNvbnN0IHRyYWlsaW5nQ29tbWVudHMgPSBhY2NlcHRUcmFpbGluZ0NvbW1lbnRzKHBhcnNlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhbXG4gICAgICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBzZW1pLFxuICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyxcbiAgICAgICAgXSksXG4gICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgdHJhaWxpbmdDb21tZW50cyxcbiAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgIHR5cGU6IFwic3ludGF4XCIsXG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIGVxLFxuICAgICAgICBxdW90ZU9wZW4sXG4gICAgICAgIHN5bnRheCxcbiAgICAgICAgcXVvdGVDbG9zZSxcbiAgICAgICAgc2VtaSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWNjZXB0SW1wb3J0KHBhcnNlciwgbGVhZGluZ0NvbW1lbnRzLCBsZWFkaW5nRGV0YWNoZWRDb21tZW50cykge1xuICAgIGNvbnN0IGtleXdvcmQgPSBhY2NlcHRLZXl3b3JkKHBhcnNlciwgXCJpbXBvcnRcIik7XG4gICAgaWYgKCFrZXl3b3JkKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCB3ZWFrT3JQdWJsaWMgPSBwYXJzZXIuYWNjZXB0KC9ed2Vha3xecHVibGljLyk7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBzdHJMaXQgPSBleHBlY3RTdHJMaXQocGFyc2VyKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHNlbWkgPSBleHBlY3RTZW1pKHBhcnNlcik7XG4gICAgY29uc3QgdHJhaWxpbmdDb21tZW50cyA9IGFjY2VwdFRyYWlsaW5nQ29tbWVudHMocGFyc2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtcbiAgICAgICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNlbWksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogXCJpbXBvcnRcIixcbiAgICAgICAga2V5d29yZCxcbiAgICAgICAgd2Vha09yUHVibGljLFxuICAgICAgICBzdHJMaXQsXG4gICAgICAgIHNlbWksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdFBhY2thZ2UocGFyc2VyLCBsZWFkaW5nQ29tbWVudHMsIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzKSB7XG4gICAgY29uc3Qga2V5d29yZCA9IGFjY2VwdEtleXdvcmQocGFyc2VyLCBcInBhY2thZ2VcIik7XG4gICAgaWYgKCFrZXl3b3JkKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBmdWxsSWRlbnQgPSBleHBlY3RGdWxsSWRlbnQocGFyc2VyKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHNlbWkgPSBleHBlY3RTZW1pKHBhcnNlcik7XG4gICAgY29uc3QgdHJhaWxpbmdDb21tZW50cyA9IGFjY2VwdFRyYWlsaW5nQ29tbWVudHMocGFyc2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtcbiAgICAgICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNlbWksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogXCJwYWNrYWdlXCIsXG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIGZ1bGxJZGVudCxcbiAgICAgICAgc2VtaSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWNjZXB0T3B0aW9uKHBhcnNlciwgbGVhZGluZ0NvbW1lbnRzLCBsZWFkaW5nRGV0YWNoZWRDb21tZW50cykge1xuICAgIGNvbnN0IGtleXdvcmQgPSBhY2NlcHRLZXl3b3JkKHBhcnNlciwgL15vcHRpb25cXGIvKTtcbiAgICBpZiAoIWtleXdvcmQpXG4gICAgICAgIHJldHVybjtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IG9wdGlvbk5hbWUgPSBleHBlY3RPcHRpb25OYW1lKHBhcnNlcik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBlcSA9IHBhcnNlci5leHBlY3QoXCI9XCIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgY29uc3RhbnQgPSBleHBlY3RDb25zdGFudChwYXJzZXIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3Qgc2VtaSA9IGV4cGVjdFNlbWkocGFyc2VyKTtcbiAgICBjb25zdCB0cmFpbGluZ0NvbW1lbnRzID0gYWNjZXB0VHJhaWxpbmdDb21tZW50cyhwYXJzZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2VtaSxcbiAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIF0pLFxuICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICB0eXBlOiBcIm9wdGlvblwiLFxuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBvcHRpb25OYW1lLFxuICAgICAgICBlcSxcbiAgICAgICAgY29uc3RhbnQsXG4gICAgICAgIHNlbWksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdEVtcHR5KHBhcnNlciwgbGVhZGluZ0NvbW1lbnRzLCBsZWFkaW5nRGV0YWNoZWRDb21tZW50cykge1xuICAgIGNvbnN0IHNlbWkgPSBhY2NlcHRTZW1pKHBhcnNlcik7XG4gICAgaWYgKCFzZW1pKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgdHJhaWxpbmdDb21tZW50cyA9IGFjY2VwdFRyYWlsaW5nQ29tbWVudHMocGFyc2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtcbiAgICAgICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgc2VtaSxcbiAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIF0pLFxuICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICB0eXBlOiBcImVtcHR5XCIsXG4gICAgICAgIHNlbWksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdEZpZWxkT3B0aW9uKHBhcnNlcikge1xuICAgIGNvbnN0IG9wdGlvbk5hbWUgPSBhY2NlcHRPcHRpb25OYW1lKHBhcnNlcik7XG4gICAgaWYgKCFvcHRpb25OYW1lKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBlcSA9IHBhcnNlci5leHBlY3QoXCI9XCIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgY29uc3RhbnQgPSBleHBlY3RDb25zdGFudChwYXJzZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW29wdGlvbk5hbWUsIGNvbnN0YW50XSksXG4gICAgICAgIHR5cGU6IFwiZmllbGQtb3B0aW9uXCIsXG4gICAgICAgIG9wdGlvbk5hbWUsXG4gICAgICAgIGVxLFxuICAgICAgICBjb25zdGFudCxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWNjZXB0RmllbGRPcHRpb25zKHBhcnNlcikge1xuICAgIGNvbnN0IGJyYWNrZXRPcGVuID0gcGFyc2VyLmFjY2VwdChcIltcIik7XG4gICAgaWYgKCFicmFja2V0T3BlbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGZpZWxkT3B0aW9uT3JDb21tYXMgPSBtYW55KHBhcnNlciwgY2hvaWNlKFtcbiAgICAgICAgc2tpcFdzQW5kQ29tbWVudHMsXG4gICAgICAgIGFjY2VwdENvbW1hLFxuICAgICAgICBhY2NlcHRGaWVsZE9wdGlvbixcbiAgICBdKSk7XG4gICAgY29uc3QgYnJhY2tldENsb3NlID0gcGFyc2VyLmV4cGVjdChcIl1cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhbYnJhY2tldE9wZW4sIGJyYWNrZXRDbG9zZV0pLFxuICAgICAgICB0eXBlOiBcImZpZWxkLW9wdGlvbnNcIixcbiAgICAgICAgYnJhY2tldE9wZW4sXG4gICAgICAgIGZpZWxkT3B0aW9uT3JDb21tYXMsXG4gICAgICAgIGJyYWNrZXRDbG9zZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWNjZXB0RW51bUZpZWxkKHBhcnNlciwgbGVhZGluZ0NvbW1lbnRzLCBsZWFkaW5nRGV0YWNoZWRDb21tZW50cykge1xuICAgIGNvbnN0IGZpZWxkTmFtZSA9IHBhcnNlci5hY2NlcHQoaWRlbnRQYXR0ZXJuKTtcbiAgICBpZiAoIWZpZWxkTmFtZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgZXEgPSBwYXJzZXIuZXhwZWN0KFwiPVwiKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IGZpZWxkTnVtYmVyID0gZXhwZWN0U2lnbmVkSW50TGl0KHBhcnNlcik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBmaWVsZE9wdGlvbnMgPSBhY2NlcHRGaWVsZE9wdGlvbnMocGFyc2VyKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHNlbWkgPSBleHBlY3RTZW1pKHBhcnNlcik7XG4gICAgY29uc3QgdHJhaWxpbmdDb21tZW50cyA9IGFjY2VwdFRyYWlsaW5nQ29tbWVudHMocGFyc2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtcbiAgICAgICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgICAgc2VtaSxcbiAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIF0pLFxuICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICB0eXBlOiBcImVudW0tZmllbGRcIixcbiAgICAgICAgZmllbGROYW1lLFxuICAgICAgICBlcSxcbiAgICAgICAgZmllbGROdW1iZXIsXG4gICAgICAgIGZpZWxkT3B0aW9ucyxcbiAgICAgICAgc2VtaSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXhwZWN0RW51bUJvZHkocGFyc2VyKSB7XG4gICAgY29uc3QgYnJhY2tldE9wZW4gPSBwYXJzZXIuZXhwZWN0KFwie1wiKTtcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gYWNjZXB0U3RhdGVtZW50cyhwYXJzZXIsIFtcbiAgICAgICAgYWNjZXB0T3B0aW9uLFxuICAgICAgICBhY2NlcHRSZXNlcnZlZCxcbiAgICAgICAgYWNjZXB0RW51bUZpZWxkLFxuICAgICAgICBhY2NlcHRFbXB0eSxcbiAgICBdKTtcbiAgICBjb25zdCBicmFja2V0Q2xvc2UgPSBwYXJzZXIuZXhwZWN0KFwifVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFticmFja2V0T3BlbiwgYnJhY2tldENsb3NlXSksXG4gICAgICAgIHR5cGU6IFwiZW51bS1ib2R5XCIsXG4gICAgICAgIGJyYWNrZXRPcGVuLFxuICAgICAgICBzdGF0ZW1lbnRzLFxuICAgICAgICBicmFja2V0Q2xvc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdEVudW0ocGFyc2VyLCBsZWFkaW5nQ29tbWVudHMsIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzKSB7XG4gICAgY29uc3Qga2V5d29yZCA9IGFjY2VwdEtleXdvcmQocGFyc2VyLCBcImVudW1cIik7XG4gICAgaWYgKCFrZXl3b3JkKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBlbnVtTmFtZSA9IHBhcnNlci5leHBlY3QoaWRlbnRQYXR0ZXJuKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IGVudW1Cb2R5ID0gZXhwZWN0RW51bUJvZHkocGFyc2VyKTtcbiAgICBjb25zdCB0cmFpbGluZ0NvbW1lbnRzID0gYWNjZXB0VHJhaWxpbmdDb21tZW50cyhwYXJzZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgZW51bUJvZHksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIGVudW1OYW1lLFxuICAgICAgICBlbnVtQm9keSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWNjZXB0RmllbGQocGFyc2VyLCBsZWFkaW5nQ29tbWVudHMsIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzKSB7XG4gICAgY29uc3QgbG9jID0gcGFyc2VyLmxvYztcbiAgICBjb25zdCBmaWVsZExhYmVsID0gYWNjZXB0S2V5d29yZChwYXJzZXIsIC9ecmVxdWlyZWR8Xm9wdGlvbmFsfF5yZXBlYXRlZC8pO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgZmllbGRUeXBlID0gYWNjZXB0VHlwZShwYXJzZXIpO1xuICAgIGlmICghZmllbGRUeXBlKSB7XG4gICAgICAgIHBhcnNlci5sb2MgPSBsb2M7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdCA9IGFjY2VwdENvbXBsZXhTZXF1ZW5jZShwYXJzZXIsIFtcbiAgICAgICAgW1wiZmllbGROYW1lXCIsIChwYXJzZXIpID0+IHBhcnNlci5leHBlY3QoaWRlbnRQYXR0ZXJuKV0sXG4gICAgICAgIFtcImVxXCIsIChwYXJzZXIpID0+IHBhcnNlci5leHBlY3QoXCI9XCIpXSxcbiAgICAgICAgW1wiZmllbGROdW1iZXJcIiwgZXhwZWN0SW50TGl0XSxcbiAgICAgICAgW1wiZmllbGRPcHRpb25zXCIsIGFjY2VwdEZpZWxkT3B0aW9uc10sXG4gICAgICAgIFtcInNlbWlcIiwgZXhwZWN0U2VtaV0sXG4gICAgXSwgbWVzc2FnZUJvZHlTdGF0ZW1lbnRLZXl3b3JkUGF0dGVybik7XG4gICAgY29uc3QgdHJhaWxpbmdDb21tZW50cyA9IHJlc3QucmVzdWx0LnNlbWlcbiAgICAgICAgPyBhY2NlcHRUcmFpbGluZ0NvbW1lbnRzKHBhcnNlcilcbiAgICAgICAgOiBbXTtcbiAgICBjb25zdCB0eXBlID0gcmVzdC5wYXJ0aWFsID8gXCJtYWxmb3JtZWQtZmllbGRcIiA6IFwiZmllbGRcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtcbiAgICAgICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAgZmllbGRMYWJlbCxcbiAgICAgICAgICAgIGZpZWxkVHlwZSxcbiAgICAgICAgICAgIHJlc3QucmVzdWx0LnNlbWksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgZmllbGRMYWJlbCxcbiAgICAgICAgZmllbGRUeXBlLFxuICAgICAgICAuLi5yZXN0LnJlc3VsdCxcbiAgICB9O1xufVxuZnVuY3Rpb24gYWNjZXB0T25lb2ZGaWVsZChwYXJzZXIsIGxlYWRpbmdDb21tZW50cywgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMpIHtcbiAgICBjb25zdCBmaWVsZFR5cGUgPSBhY2NlcHRUeXBlKHBhcnNlcik7XG4gICAgaWYgKCFmaWVsZFR5cGUpXG4gICAgICAgIHJldHVybjtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IGZpZWxkTmFtZSA9IHBhcnNlci5leHBlY3QoaWRlbnRQYXR0ZXJuKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IGVxID0gcGFyc2VyLmV4cGVjdChcIj1cIik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBmaWVsZE51bWJlciA9IGV4cGVjdEludExpdChwYXJzZXIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgZmllbGRPcHRpb25zID0gYWNjZXB0RmllbGRPcHRpb25zKHBhcnNlcik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBzZW1pID0gZXhwZWN0U2VtaShwYXJzZXIpO1xuICAgIGNvbnN0IHRyYWlsaW5nQ29tbWVudHMgPSBhY2NlcHRUcmFpbGluZ0NvbW1lbnRzKHBhcnNlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhbXG4gICAgICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgICAgIGZpZWxkVHlwZSxcbiAgICAgICAgICAgIHNlbWksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogXCJvbmVvZi1maWVsZFwiLFxuICAgICAgICBmaWVsZFR5cGUsXG4gICAgICAgIGZpZWxkTmFtZSxcbiAgICAgICAgZXEsXG4gICAgICAgIGZpZWxkTnVtYmVyLFxuICAgICAgICBmaWVsZE9wdGlvbnMsXG4gICAgICAgIHNlbWksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdE1hcEZpZWxkKHBhcnNlciwgbGVhZGluZ0NvbW1lbnRzLCBsZWFkaW5nRGV0YWNoZWRDb21tZW50cykge1xuICAgIGNvbnN0IGtleXdvcmQgPSBhY2NlcHRLZXl3b3JkKHBhcnNlciwgXCJtYXBcIik7XG4gICAgaWYgKCFrZXl3b3JkKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCB0eXBlQnJhY2tldE9wZW4gPSBwYXJzZXIuZXhwZWN0KFwiPFwiKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IGtleVR5cGUgPSBleHBlY3RUeXBlKHBhcnNlcik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCB0eXBlU2VwID0gcGFyc2VyLmV4cGVjdChcIixcIik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSBleHBlY3RUeXBlKHBhcnNlcik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCB0eXBlQnJhY2tldENsb3NlID0gcGFyc2VyLmV4cGVjdChcIj5cIik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBtYXBOYW1lID0gcGFyc2VyLmV4cGVjdChpZGVudFBhdHRlcm4pO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgZXEgPSBwYXJzZXIuZXhwZWN0KFwiPVwiKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IGZpZWxkTnVtYmVyID0gZXhwZWN0SW50TGl0KHBhcnNlcik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBmaWVsZE9wdGlvbnMgPSBhY2NlcHRGaWVsZE9wdGlvbnMocGFyc2VyKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHNlbWkgPSBleHBlY3RTZW1pKHBhcnNlcik7XG4gICAgY29uc3QgdHJhaWxpbmdDb21tZW50cyA9IGFjY2VwdFRyYWlsaW5nQ29tbWVudHMocGFyc2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtcbiAgICAgICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNlbWksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogXCJtYXAtZmllbGRcIixcbiAgICAgICAga2V5d29yZCxcbiAgICAgICAgdHlwZUJyYWNrZXRPcGVuLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB0eXBlU2VwLFxuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIHR5cGVCcmFja2V0Q2xvc2UsXG4gICAgICAgIG1hcE5hbWUsXG4gICAgICAgIGVxLFxuICAgICAgICBmaWVsZE51bWJlcixcbiAgICAgICAgZmllbGRPcHRpb25zLFxuICAgICAgICBzZW1pLFxuICAgIH07XG59XG5mdW5jdGlvbiBleHBlY3RPbmVvZkJvZHkocGFyc2VyKSB7XG4gICAgY29uc3QgYnJhY2tldE9wZW4gPSBwYXJzZXIuZXhwZWN0KFwie1wiKTtcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gYWNjZXB0U3RhdGVtZW50cyhwYXJzZXIsIFtcbiAgICAgICAgYWNjZXB0T25lb2ZHcm91cCxcbiAgICAgICAgYWNjZXB0T3B0aW9uLFxuICAgICAgICBhY2NlcHRPbmVvZkZpZWxkLFxuICAgICAgICBhY2NlcHRFbXB0eSxcbiAgICBdKTtcbiAgICBjb25zdCBicmFja2V0Q2xvc2UgPSBwYXJzZXIuZXhwZWN0KFwifVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFticmFja2V0T3BlbiwgYnJhY2tldENsb3NlXSksXG4gICAgICAgIHR5cGU6IFwib25lb2YtYm9keVwiLFxuICAgICAgICBicmFja2V0T3BlbixcbiAgICAgICAgc3RhdGVtZW50cyxcbiAgICAgICAgYnJhY2tldENsb3NlLFxuICAgIH07XG59XG5mdW5jdGlvbiBhY2NlcHRPbmVvZihwYXJzZXIsIGxlYWRpbmdDb21tZW50cywgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMpIHtcbiAgICBjb25zdCBrZXl3b3JkID0gYWNjZXB0S2V5d29yZChwYXJzZXIsIFwib25lb2ZcIik7XG4gICAgaWYgKCFrZXl3b3JkKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBvbmVvZk5hbWUgPSBwYXJzZXIuZXhwZWN0KGlkZW50UGF0dGVybik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBvbmVvZkJvZHkgPSBleHBlY3RPbmVvZkJvZHkocGFyc2VyKTtcbiAgICBjb25zdCB0cmFpbGluZ0NvbW1lbnRzID0gYWNjZXB0VHJhaWxpbmdDb21tZW50cyhwYXJzZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgb25lb2ZCb2R5LFxuICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyxcbiAgICAgICAgXSksXG4gICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgdHJhaWxpbmdDb21tZW50cyxcbiAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgIHR5cGU6IFwib25lb2ZcIixcbiAgICAgICAga2V5d29yZCxcbiAgICAgICAgb25lb2ZOYW1lLFxuICAgICAgICBvbmVvZkJvZHksXG4gICAgfTtcbn1cbmNvbnN0IGFjY2VwdE1heCA9IGFjY2VwdFBhdHRlcm5BbmRUaGVuKFwibWF4XCIsIChtYXgpID0+ICh7IHR5cGU6IFwibWF4XCIsIC4uLm1heCB9KSk7XG5mdW5jdGlvbiBhY2NlcHRSYW5nZShwYXJzZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmFuZ2VTdGFydCA9IGFjY2VwdEludExpdChwYXJzZXIpO1xuICAgIGlmICghcmFuZ2VTdGFydClcbiAgICAgICAgcmV0dXJuO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgdG8gPSBhY2NlcHRLZXl3b3JkKHBhcnNlciwgXCJ0b1wiKTtcbiAgICBpZiAoIXRvKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogcmFuZ2VTdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcmFuZ2VTdGFydC5lbmQsXG4gICAgICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgICAgICByYW5nZVN0YXJ0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHJhbmdlRW5kID0gKF9hID0gYWNjZXB0SW50TGl0KHBhcnNlcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGFjY2VwdE1heChwYXJzZXIpO1xuICAgIGlmICghcmFuZ2VFbmQpXG4gICAgICAgIHRocm93IG5ldyByZWN1cnNpdmVfZGVzY2VudF9wYXJzZXJfMS5TeW50YXhFcnJvcihwYXJzZXIsIFtpbnRMaXRQYXR0ZXJuLCBcIm1heFwiXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhbcmFuZ2VTdGFydCwgcmFuZ2VFbmRdKSxcbiAgICAgICAgdHlwZTogXCJyYW5nZVwiLFxuICAgICAgICByYW5nZVN0YXJ0LFxuICAgICAgICB0byxcbiAgICAgICAgcmFuZ2VFbmQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4cGVjdFJhbmdlcyhwYXJzZXIpIHtcbiAgICBjb25zdCByYW5nZU9yQ29tbWFzID0gbWFueShwYXJzZXIsIGNob2ljZShbXG4gICAgICAgIHNraXBXc0FuZENvbW1lbnRzLFxuICAgICAgICBhY2NlcHRDb21tYSxcbiAgICAgICAgYWNjZXB0UmFuZ2UsXG4gICAgXSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMocmFuZ2VPckNvbW1hcyksXG4gICAgICAgIHR5cGU6IFwicmFuZ2VzXCIsXG4gICAgICAgIHJhbmdlT3JDb21tYXMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdEV4dGVuc2lvbnMocGFyc2VyLCBsZWFkaW5nQ29tbWVudHMsIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzKSB7XG4gICAgY29uc3Qga2V5d29yZCA9IGFjY2VwdEtleXdvcmQocGFyc2VyLCBcImV4dGVuc2lvbnNcIik7XG4gICAgaWYgKCFrZXl3b3JkKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCByYW5nZXMgPSBleHBlY3RSYW5nZXMocGFyc2VyKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHNlbWkgPSBleHBlY3RTZW1pKHBhcnNlcik7XG4gICAgY29uc3QgdHJhaWxpbmdDb21tZW50cyA9IGFjY2VwdFRyYWlsaW5nQ29tbWVudHMocGFyc2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtcbiAgICAgICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIHNlbWksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogXCJleHRlbnNpb25zXCIsXG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIHJhbmdlcyxcbiAgICAgICAgc2VtaSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXhwZWN0RmllbGROYW1lcyhwYXJzZXIpIHtcbiAgICBjb25zdCBzdHJMaXRPckNvbW1hcyA9IG1hbnkocGFyc2VyLCBjaG9pY2UoW1xuICAgICAgICBza2lwV3NBbmRDb21tZW50cyxcbiAgICAgICAgYWNjZXB0Q29tbWEsXG4gICAgICAgIGFjY2VwdFN0ckxpdCxcbiAgICBdKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhzdHJMaXRPckNvbW1hcyksXG4gICAgICAgIHR5cGU6IFwiZmllbGQtbmFtZXNcIixcbiAgICAgICAgc3RyTGl0T3JDb21tYXMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdFJlc2VydmVkKHBhcnNlciwgbGVhZGluZ0NvbW1lbnRzLCBsZWFkaW5nRGV0YWNoZWRDb21tZW50cykge1xuICAgIGNvbnN0IGtleXdvcmQgPSBhY2NlcHRLZXl3b3JkKHBhcnNlciwgXCJyZXNlcnZlZFwiKTtcbiAgICBpZiAoIWtleXdvcmQpXG4gICAgICAgIHJldHVybjtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHJlc2VydmVkID0gcGFyc2VyLnRyeShpbnRMaXRQYXR0ZXJuKVxuICAgICAgICA/IGV4cGVjdFJhbmdlcyhwYXJzZXIpXG4gICAgICAgIDogZXhwZWN0RmllbGROYW1lcyhwYXJzZXIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3Qgc2VtaSA9IGV4cGVjdFNlbWkocGFyc2VyKTtcbiAgICBjb25zdCB0cmFpbGluZ0NvbW1lbnRzID0gYWNjZXB0VHJhaWxpbmdDb21tZW50cyhwYXJzZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2VtaSxcbiAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIF0pLFxuICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICB0eXBlOiBcInJlc2VydmVkXCIsXG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIHJlc2VydmVkLFxuICAgICAgICBzZW1pLFxuICAgIH07XG59XG5mdW5jdGlvbiBleHBlY3RFeHRlbmRCb2R5KHBhcnNlcikge1xuICAgIGNvbnN0IGJyYWNrZXRPcGVuID0gcGFyc2VyLmV4cGVjdChcIntcIik7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IGFjY2VwdFN0YXRlbWVudHMocGFyc2VyLCBbXG4gICAgICAgIGFjY2VwdEdyb3VwLFxuICAgICAgICBhY2NlcHRGaWVsZCxcbiAgICAgICAgYWNjZXB0RW1wdHksXG4gICAgXSk7XG4gICAgY29uc3QgYnJhY2tldENsb3NlID0gcGFyc2VyLmV4cGVjdChcIn1cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhbYnJhY2tldE9wZW4sIGJyYWNrZXRDbG9zZV0pLFxuICAgICAgICB0eXBlOiBcImV4dGVuZC1ib2R5XCIsXG4gICAgICAgIGJyYWNrZXRPcGVuLFxuICAgICAgICBzdGF0ZW1lbnRzLFxuICAgICAgICBicmFja2V0Q2xvc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdEV4dGVuZChwYXJzZXIsIGxlYWRpbmdDb21tZW50cywgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMpIHtcbiAgICBjb25zdCBrZXl3b3JkID0gYWNjZXB0S2V5d29yZChwYXJzZXIsIFwiZXh0ZW5kXCIpO1xuICAgIGlmICgha2V5d29yZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgbWVzc2FnZVR5cGUgPSBleHBlY3RUeXBlKHBhcnNlcik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBleHRlbmRCb2R5ID0gZXhwZWN0RXh0ZW5kQm9keShwYXJzZXIpO1xuICAgIGNvbnN0IHRyYWlsaW5nQ29tbWVudHMgPSBhY2NlcHRUcmFpbGluZ0NvbW1lbnRzKHBhcnNlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhbXG4gICAgICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgICBleHRlbmRCb2R5LFxuICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyxcbiAgICAgICAgXSksXG4gICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgdHJhaWxpbmdDb21tZW50cyxcbiAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgIHR5cGU6IFwiZXh0ZW5kXCIsXG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIG1lc3NhZ2VUeXBlLFxuICAgICAgICBleHRlbmRCb2R5LFxuICAgIH07XG59XG5mdW5jdGlvbiBhY2NlcHRHcm91cChwYXJzZXIsIGxlYWRpbmdDb21tZW50cywgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMpIHtcbiAgICBjb25zdCBsb2MgPSBwYXJzZXIubG9jO1xuICAgIGNvbnN0IGdyb3VwTGFiZWwgPSBhY2NlcHRLZXl3b3JkKHBhcnNlciwgL15yZXF1aXJlZHxeb3B0aW9uYWx8XnJlcGVhdGVkLyk7XG4gICAgaWYgKCFncm91cExhYmVsKSB7XG4gICAgICAgIHBhcnNlci5sb2MgPSBsb2M7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBrZXl3b3JkID0gYWNjZXB0S2V5d29yZChwYXJzZXIsIFwiZ3JvdXBcIik7XG4gICAgaWYgKCFrZXl3b3JkKSB7XG4gICAgICAgIHBhcnNlci5sb2MgPSBsb2M7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBncm91cE5hbWUgPSBwYXJzZXIuZXhwZWN0KGlkZW50UGF0dGVybik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBlcSA9IHBhcnNlci5leHBlY3QoXCI9XCIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgZmllbGROdW1iZXIgPSBleHBlY3RJbnRMaXQocGFyc2VyKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IG1lc3NhZ2VCb2R5ID0gZXhwZWN0TWVzc2FnZUJvZHkocGFyc2VyKTtcbiAgICBjb25zdCB0cmFpbGluZ0NvbW1lbnRzID0gYWNjZXB0VHJhaWxpbmdDb21tZW50cyhwYXJzZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgICAgICBncm91cExhYmVsLFxuICAgICAgICAgICAgbWVzc2FnZUJvZHksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogXCJncm91cFwiLFxuICAgICAgICBncm91cExhYmVsLFxuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBncm91cE5hbWUsXG4gICAgICAgIGVxLFxuICAgICAgICBmaWVsZE51bWJlcixcbiAgICAgICAgbWVzc2FnZUJvZHksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdE9uZW9mR3JvdXAocGFyc2VyLCBsZWFkaW5nQ29tbWVudHMsIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzKSB7XG4gICAgY29uc3Qga2V5d29yZCA9IGFjY2VwdEtleXdvcmQocGFyc2VyLCBcImdyb3VwXCIpO1xuICAgIGlmICgha2V5d29yZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgZ3JvdXBOYW1lID0gcGFyc2VyLmV4cGVjdChpZGVudFBhdHRlcm4pO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgZXEgPSBwYXJzZXIuZXhwZWN0KFwiPVwiKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IGZpZWxkTnVtYmVyID0gZXhwZWN0SW50TGl0KHBhcnNlcik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBtZXNzYWdlQm9keSA9IGV4cGVjdE1lc3NhZ2VCb2R5KHBhcnNlcik7XG4gICAgY29uc3QgdHJhaWxpbmdDb21tZW50cyA9IGFjY2VwdFRyYWlsaW5nQ29tbWVudHMocGFyc2VyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFtcbiAgICAgICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICAgIG1lc3NhZ2VCb2R5LFxuICAgICAgICAgICAgdHJhaWxpbmdDb21tZW50cyxcbiAgICAgICAgXSksXG4gICAgICAgIGxlYWRpbmdDb21tZW50cyxcbiAgICAgICAgdHJhaWxpbmdDb21tZW50cyxcbiAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgIHR5cGU6IFwib25lb2YtZ3JvdXBcIixcbiAgICAgICAga2V5d29yZCxcbiAgICAgICAgZ3JvdXBOYW1lLFxuICAgICAgICBlcSxcbiAgICAgICAgZmllbGROdW1iZXIsXG4gICAgICAgIG1lc3NhZ2VCb2R5LFxuICAgIH07XG59XG5mdW5jdGlvbiBleHBlY3RNZXNzYWdlQm9keShwYXJzZXIpIHtcbiAgICBjb25zdCBicmFja2V0T3BlbiA9IHBhcnNlci5leHBlY3QoXCJ7XCIpO1xuICAgIGNvbnN0IHN0YXRlbWVudHMgPSBhY2NlcHRTdGF0ZW1lbnRzKHBhcnNlciwgW1xuICAgICAgICBhY2NlcHRHcm91cCxcbiAgICAgICAgYWNjZXB0RW51bSxcbiAgICAgICAgYWNjZXB0TWVzc2FnZSxcbiAgICAgICAgYWNjZXB0RXh0ZW5kLFxuICAgICAgICBhY2NlcHRFeHRlbnNpb25zLFxuICAgICAgICBhY2NlcHRPcHRpb24sXG4gICAgICAgIGFjY2VwdE9uZW9mLFxuICAgICAgICBhY2NlcHRNYXBGaWVsZCxcbiAgICAgICAgYWNjZXB0UmVzZXJ2ZWQsXG4gICAgICAgIGFjY2VwdEZpZWxkLFxuICAgICAgICBhY2NlcHRFbXB0eSxcbiAgICBdKTtcbiAgICBjb25zdCBicmFja2V0Q2xvc2UgPSBwYXJzZXIuZXhwZWN0KFwifVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFticmFja2V0T3BlbiwgYnJhY2tldENsb3NlXSksXG4gICAgICAgIHR5cGU6IFwibWVzc2FnZS1ib2R5XCIsXG4gICAgICAgIGJyYWNrZXRPcGVuLFxuICAgICAgICBzdGF0ZW1lbnRzLFxuICAgICAgICBicmFja2V0Q2xvc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdE1lc3NhZ2UocGFyc2VyLCBsZWFkaW5nQ29tbWVudHMsIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzKSB7XG4gICAgY29uc3Qga2V5d29yZCA9IGFjY2VwdEtleXdvcmQocGFyc2VyLCBcIm1lc3NhZ2VcIik7XG4gICAgaWYgKCFrZXl3b3JkKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBtZXNzYWdlTmFtZSA9IHBhcnNlci5leHBlY3QoaWRlbnRQYXR0ZXJuKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IG1lc3NhZ2VCb2R5ID0gZXhwZWN0TWVzc2FnZUJvZHkocGFyc2VyKTtcbiAgICBjb25zdCB0cmFpbGluZ0NvbW1lbnRzID0gYWNjZXB0VHJhaWxpbmdDb21tZW50cyhwYXJzZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgbWVzc2FnZUJvZHksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogXCJtZXNzYWdlXCIsXG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIG1lc3NhZ2VOYW1lLFxuICAgICAgICBtZXNzYWdlQm9keSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXhwZWN0UnBjVHlwZShwYXJzZXIpIHtcbiAgICBjb25zdCBicmFja2V0T3BlbiA9IHBhcnNlci5leHBlY3QoXCIoXCIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3Qgc3RyZWFtID0gYWNjZXB0S2V5d29yZChwYXJzZXIsIFwic3RyZWFtXCIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgbWVzc2FnZVR5cGUgPSBleHBlY3RUeXBlKHBhcnNlcik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBicmFja2V0Q2xvc2UgPSBwYXJzZXIuZXhwZWN0KFwiKVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFticmFja2V0T3BlbiwgYnJhY2tldENsb3NlXSksXG4gICAgICAgIGJyYWNrZXRPcGVuLFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIG1lc3NhZ2VUeXBlLFxuICAgICAgICBicmFja2V0Q2xvc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdFJwYyhwYXJzZXIsIGxlYWRpbmdDb21tZW50cywgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qga2V5d29yZCA9IGFjY2VwdEtleXdvcmQocGFyc2VyLCBcInJwY1wiKTtcbiAgICBpZiAoIWtleXdvcmQpXG4gICAgICAgIHJldHVybjtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHJwY05hbWUgPSBwYXJzZXIuZXhwZWN0KGlkZW50UGF0dGVybik7XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCByZXFUeXBlID0gZXhwZWN0UnBjVHlwZShwYXJzZXIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgcmV0dXJucyA9IHBhcnNlci5leHBlY3QoXCJyZXR1cm5zXCIpO1xuICAgIHNraXBXc0FuZENvbW1lbnRzKHBhcnNlcik7XG4gICAgY29uc3QgcmVzVHlwZSA9IGV4cGVjdFJwY1R5cGUocGFyc2VyKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHNlbWlPclJwY0JvZHkgPSAoX2EgPSBhY2NlcHRTZW1pKHBhcnNlcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4cGVjdFJwY0JvZHkocGFyc2VyKTtcbiAgICBjb25zdCB0cmFpbGluZ0NvbW1lbnRzID0gYWNjZXB0VHJhaWxpbmdDb21tZW50cyhwYXJzZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2VtaU9yUnBjQm9keSxcbiAgICAgICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIF0pLFxuICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgIHRyYWlsaW5nQ29tbWVudHMsXG4gICAgICAgIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzLFxuICAgICAgICB0eXBlOiBcInJwY1wiLFxuICAgICAgICBrZXl3b3JkLFxuICAgICAgICBycGNOYW1lLFxuICAgICAgICByZXFUeXBlLFxuICAgICAgICByZXR1cm5zLFxuICAgICAgICByZXNUeXBlLFxuICAgICAgICBzZW1pT3JScGNCb2R5LFxuICAgIH07XG59XG5mdW5jdGlvbiBleHBlY3RScGNCb2R5KHBhcnNlcikge1xuICAgIGNvbnN0IGJyYWNrZXRPcGVuID0gcGFyc2VyLmV4cGVjdChcIntcIik7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IGFjY2VwdFN0YXRlbWVudHMocGFyc2VyLCBbXG4gICAgICAgIGFjY2VwdE9wdGlvbixcbiAgICAgICAgYWNjZXB0RW1wdHksXG4gICAgXSk7XG4gICAgY29uc3QgYnJhY2tldENsb3NlID0gcGFyc2VyLmV4cGVjdChcIn1cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWVyZ2VTcGFucyhbYnJhY2tldE9wZW4sIGJyYWNrZXRDbG9zZV0pLFxuICAgICAgICB0eXBlOiBcInJwYy1ib2R5XCIsXG4gICAgICAgIGJyYWNrZXRPcGVuLFxuICAgICAgICBzdGF0ZW1lbnRzLFxuICAgICAgICBicmFja2V0Q2xvc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4cGVjdFNlcnZpY2VCb2R5KHBhcnNlcikge1xuICAgIGNvbnN0IGJyYWNrZXRPcGVuID0gcGFyc2VyLmV4cGVjdChcIntcIik7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IGFjY2VwdFN0YXRlbWVudHMocGFyc2VyLCBbXG4gICAgICAgIGFjY2VwdE9wdGlvbixcbiAgICAgICAgYWNjZXB0UnBjLFxuICAgICAgICBhY2NlcHRFbXB0eSxcbiAgICBdKTtcbiAgICBjb25zdCBicmFja2V0Q2xvc2UgPSBwYXJzZXIuZXhwZWN0KFwifVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXJnZVNwYW5zKFticmFja2V0T3BlbiwgYnJhY2tldENsb3NlXSksXG4gICAgICAgIHR5cGU6IFwic2VydmljZS1ib2R5XCIsXG4gICAgICAgIGJyYWNrZXRPcGVuLFxuICAgICAgICBzdGF0ZW1lbnRzLFxuICAgICAgICBicmFja2V0Q2xvc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFjY2VwdFNlcnZpY2UocGFyc2VyLCBsZWFkaW5nQ29tbWVudHMsIGxlYWRpbmdEZXRhY2hlZENvbW1lbnRzKSB7XG4gICAgY29uc3Qga2V5d29yZCA9IGFjY2VwdEtleXdvcmQocGFyc2VyLCBcInNlcnZpY2VcIik7XG4gICAgaWYgKCFrZXl3b3JkKVxuICAgICAgICByZXR1cm47XG4gICAgc2tpcFdzQW5kQ29tbWVudHMocGFyc2VyKTtcbiAgICBjb25zdCBzZXJ2aWNlTmFtZSA9IHBhcnNlci5leHBlY3QoaWRlbnRQYXR0ZXJuKTtcbiAgICBza2lwV3NBbmRDb21tZW50cyhwYXJzZXIpO1xuICAgIGNvbnN0IHNlcnZpY2VCb2R5ID0gZXhwZWN0U2VydmljZUJvZHkocGFyc2VyKTtcbiAgICBjb25zdCB0cmFpbGluZ0NvbW1lbnRzID0gYWNjZXB0VHJhaWxpbmdDb21tZW50cyhwYXJzZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1lcmdlU3BhbnMoW1xuICAgICAgICAgICAgbGVhZGluZ0RldGFjaGVkQ29tbWVudHMsXG4gICAgICAgICAgICBsZWFkaW5nQ29tbWVudHMsXG4gICAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgICAgc2VydmljZUJvZHksXG4gICAgICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBdKSxcbiAgICAgICAgbGVhZGluZ0NvbW1lbnRzLFxuICAgICAgICB0cmFpbGluZ0NvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nRGV0YWNoZWRDb21tZW50cyxcbiAgICAgICAgdHlwZTogXCJzZXJ2aWNlXCIsXG4gICAgICAgIGtleXdvcmQsXG4gICAgICAgIHNlcnZpY2VOYW1lLFxuICAgICAgICBzZXJ2aWNlQm9keSxcbiAgICB9O1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pbkit/core/parser/proto.js\n");

/***/ }),

/***/ "./node_modules/pbkit/core/parser/recursive-descent-parser.js":
/*!********************************************************************!*\
  !*** ./node_modules/pbkit/core/parser/recursive-descent-parser.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyntaxError = exports.createRecursiveDescentParser = exports.eof = void 0;\nexports.eof = Symbol(\"<EOF>\");\nfunction createRecursiveDescentParser(input, config) {\n    const debug = !!(config === null || config === void 0 ? void 0 : config.debug);\n    let cnt = 0;\n    const lines = input.split(\"\\n\");\n    const parser = {\n        input,\n        loc: 0,\n        offsetToColRow: (offset) => offsetToColRow(lines, offset),\n        getAroundText: (loc, length, window) => getAroundText(lines, loc, length, window),\n        try(pattern) {\n            const loc = parser.loc;\n            try {\n                return parser.accept(pattern);\n            }\n            finally {\n                parser.loc = loc;\n            }\n        },\n        accept(pattern) {\n            cnt++;\n            if (cnt > input.length * 5)\n                throw `infinite loop`;\n            if (pattern === exports.eof)\n                return acceptEof();\n            if (typeof pattern === \"string\")\n                return acceptString(pattern);\n            return acceptRegex(pattern);\n        },\n        expect(acceptPattern, expectedPatterns, mistakePatterns) {\n            const result = parser.accept(acceptPattern);\n            const _expectedPatterns = (expectedPatterns\n                ? [acceptPattern, ...expectedPatterns]\n                : [acceptPattern]);\n            if (result == null) {\n                throw new SyntaxError(parser, _expectedPatterns, mistakePatterns);\n            }\n            else {\n                return result;\n            }\n        },\n    };\n    function acceptEof() {\n        if (parser.loc < input.length)\n            return;\n        return { start: parser.loc, end: parser.loc, text: \"\" };\n    }\n    function acceptString(pattern) {\n        const start = parser.loc;\n        const end = start + pattern.length;\n        const text = input.slice(start, end);\n        if (text !== pattern)\n            return;\n        parser.loc = end;\n        debug && console.log(text);\n        return { start, end, text };\n    }\n    function acceptRegex(pattern) {\n        pattern.lastIndex = 0;\n        const execArray = pattern.exec(input.substr(parser.loc));\n        if (execArray == null)\n            return;\n        const text = execArray[0];\n        const start = parser.loc + execArray.index;\n        const end = start + text.length;\n        parser.loc = end;\n        debug && console.log(text);\n        return { start, end, text };\n    }\n    return parser;\n}\nexports.createRecursiveDescentParser = createRecursiveDescentParser;\nclass SyntaxError extends Error {\n    constructor(parser, expectedPatterns, mistakePatterns = []) {\n        super();\n        this.parser = parser;\n        this.expectedPatterns = expectedPatterns;\n        this.mistakePatterns = mistakePatterns;\n        const colRow = this.colRow;\n        const got = this.got;\n        const length = got === exports.eof ? 1 : got.length;\n        const expectedPatternsText = expectedPatterns.map(patternToString).join(\" or \");\n        this.message = (`at line ${colRow.row + 1}, column ${colRow.col + 1}:\\n\\n` +\n            `expected ${expectedPatternsText}, got ${patternToString(got)}\\n\\n` +\n            parser.getAroundText(parser.loc, length));\n    }\n    get got() {\n        const parser = this.parser;\n        for (const mistakePattern of this.mistakePatterns) {\n            const token = parser.try(mistakePattern);\n            if (token)\n                return token.text;\n        }\n        return parser.input.charAt(parser.loc) || exports.eof;\n    }\n    get colRow() {\n        return this.parser.offsetToColRow(this.parser.loc);\n    }\n}\nexports.SyntaxError = SyntaxError;\nfunction patternToString(pattern) {\n    if (pattern === exports.eof)\n        return \"<EOF>\";\n    if (typeof pattern === \"string\")\n        return JSON.stringify(pattern);\n    return pattern.toString();\n}\nfunction offsetToColRow(lines, offset) {\n    let col = offset;\n    let row = 0;\n    for (const line of lines) {\n        const len = line.length + 1;\n        if (len < col) {\n            col -= len;\n            row++;\n            continue;\n        }\n        return { col, row };\n    }\n    return { col: 0, row };\n}\nfunction getAroundText(lines, loc, length = 1, window = 5) {\n    const colRow = offsetToColRow(lines, loc);\n    const headCount = Math.min(1, (window >> 1) + (window % 2));\n    const tailCount = window >> 1;\n    const headStart = Math.max(0, colRow.row - headCount - 1);\n    const headEnd = colRow.row + 1;\n    const tailStart = colRow.row + 1;\n    const tailEnd = colRow.row + tailCount + 1;\n    const heads = lines.slice(headStart, headEnd);\n    const tails = lines.slice(tailStart, tailEnd);\n    const lineNumberDigitCount = tailEnd.toString().length;\n    const headTexts = heads.map((line, index) => {\n        const lineNumber = index + headStart + 1;\n        const lineNumberText = lineNumber.toString().padStart(lineNumberDigitCount + 1);\n        return lineNumberText + \" | \" + line;\n    }).join(\"\\n\");\n    const tailTexts = tails.map((line, index) => {\n        const lineNumber = index + tailStart + 1;\n        const lineNumberText = lineNumber.toString().padStart(lineNumberDigitCount + 1);\n        return lineNumberText + \" | \" + line;\n    }).join(\"\\n\");\n    return [\n        headTexts,\n        (new Array(lineNumberDigitCount + 1 + 1)).join(\" \") + \" | \" +\n            (new Array(colRow.col + 1)).join(\" \") +\n            (new Array(length + 1)).join(\"^\"),\n        tailTexts,\n    ].join(\"\\n\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGJraXQvY29yZS9wYXJzZXIvcmVjdXJzaXZlLWRlc2NlbnQtcGFyc2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Bia2l0L2NvcmUvcGFyc2VyL3JlY3Vyc2l2ZS1kZXNjZW50LXBhcnNlci5qcz9iM2EzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TeW50YXhFcnJvciA9IGV4cG9ydHMuY3JlYXRlUmVjdXJzaXZlRGVzY2VudFBhcnNlciA9IGV4cG9ydHMuZW9mID0gdm9pZCAwO1xuZXhwb3J0cy5lb2YgPSBTeW1ib2woXCI8RU9GPlwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVJlY3Vyc2l2ZURlc2NlbnRQYXJzZXIoaW5wdXQsIGNvbmZpZykge1xuICAgIGNvbnN0IGRlYnVnID0gISEoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmRlYnVnKTtcbiAgICBsZXQgY250ID0gMDtcbiAgICBjb25zdCBsaW5lcyA9IGlucHV0LnNwbGl0KFwiXFxuXCIpO1xuICAgIGNvbnN0IHBhcnNlciA9IHtcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGxvYzogMCxcbiAgICAgICAgb2Zmc2V0VG9Db2xSb3c6IChvZmZzZXQpID0+IG9mZnNldFRvQ29sUm93KGxpbmVzLCBvZmZzZXQpLFxuICAgICAgICBnZXRBcm91bmRUZXh0OiAobG9jLCBsZW5ndGgsIHdpbmRvdykgPT4gZ2V0QXJvdW5kVGV4dChsaW5lcywgbG9jLCBsZW5ndGgsIHdpbmRvdyksXG4gICAgICAgIHRyeShwYXR0ZXJuKSB7XG4gICAgICAgICAgICBjb25zdCBsb2MgPSBwYXJzZXIubG9jO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VyLmFjY2VwdChwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHBhcnNlci5sb2MgPSBsb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFjY2VwdChwYXR0ZXJuKSB7XG4gICAgICAgICAgICBjbnQrKztcbiAgICAgICAgICAgIGlmIChjbnQgPiBpbnB1dC5sZW5ndGggKiA1KVxuICAgICAgICAgICAgICAgIHRocm93IGBpbmZpbml0ZSBsb29wYDtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuID09PSBleHBvcnRzLmVvZilcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXB0RW9mKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2VwdFN0cmluZyhwYXR0ZXJuKTtcbiAgICAgICAgICAgIHJldHVybiBhY2NlcHRSZWdleChwYXR0ZXJuKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXhwZWN0KGFjY2VwdFBhdHRlcm4sIGV4cGVjdGVkUGF0dGVybnMsIG1pc3Rha2VQYXR0ZXJucykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyLmFjY2VwdChhY2NlcHRQYXR0ZXJuKTtcbiAgICAgICAgICAgIGNvbnN0IF9leHBlY3RlZFBhdHRlcm5zID0gKGV4cGVjdGVkUGF0dGVybnNcbiAgICAgICAgICAgICAgICA/IFthY2NlcHRQYXR0ZXJuLCAuLi5leHBlY3RlZFBhdHRlcm5zXVxuICAgICAgICAgICAgICAgIDogW2FjY2VwdFBhdHRlcm5dKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihwYXJzZXIsIF9leHBlY3RlZFBhdHRlcm5zLCBtaXN0YWtlUGF0dGVybnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGFjY2VwdEVvZigpIHtcbiAgICAgICAgaWYgKHBhcnNlci5sb2MgPCBpbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBwYXJzZXIubG9jLCBlbmQ6IHBhcnNlci5sb2MsIHRleHQ6IFwiXCIgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWNjZXB0U3RyaW5nKHBhdHRlcm4pIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwYXJzZXIubG9jO1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICBjb25zdCB0ZXh0ID0gaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmICh0ZXh0ICE9PSBwYXR0ZXJuKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXJzZXIubG9jID0gZW5kO1xuICAgICAgICBkZWJ1ZyAmJiBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgdGV4dCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY2NlcHRSZWdleChwYXR0ZXJuKSB7XG4gICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgZXhlY0FycmF5ID0gcGF0dGVybi5leGVjKGlucHV0LnN1YnN0cihwYXJzZXIubG9jKSk7XG4gICAgICAgIGlmIChleGVjQXJyYXkgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdGV4dCA9IGV4ZWNBcnJheVswXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwYXJzZXIubG9jICsgZXhlY0FycmF5LmluZGV4O1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuICAgICAgICBwYXJzZXIubG9jID0gZW5kO1xuICAgICAgICBkZWJ1ZyAmJiBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCwgdGV4dCB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyO1xufVxuZXhwb3J0cy5jcmVhdGVSZWN1cnNpdmVEZXNjZW50UGFyc2VyID0gY3JlYXRlUmVjdXJzaXZlRGVzY2VudFBhcnNlcjtcbmNsYXNzIFN5bnRheEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgZXhwZWN0ZWRQYXR0ZXJucywgbWlzdGFrZVBhdHRlcm5zID0gW10pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuZXhwZWN0ZWRQYXR0ZXJucyA9IGV4cGVjdGVkUGF0dGVybnM7XG4gICAgICAgIHRoaXMubWlzdGFrZVBhdHRlcm5zID0gbWlzdGFrZVBhdHRlcm5zO1xuICAgICAgICBjb25zdCBjb2xSb3cgPSB0aGlzLmNvbFJvdztcbiAgICAgICAgY29uc3QgZ290ID0gdGhpcy5nb3Q7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGdvdCA9PT0gZXhwb3J0cy5lb2YgPyAxIDogZ290Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRQYXR0ZXJuc1RleHQgPSBleHBlY3RlZFBhdHRlcm5zLm1hcChwYXR0ZXJuVG9TdHJpbmcpLmpvaW4oXCIgb3IgXCIpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAoYGF0IGxpbmUgJHtjb2xSb3cucm93ICsgMX0sIGNvbHVtbiAke2NvbFJvdy5jb2wgKyAxfTpcXG5cXG5gICtcbiAgICAgICAgICAgIGBleHBlY3RlZCAke2V4cGVjdGVkUGF0dGVybnNUZXh0fSwgZ290ICR7cGF0dGVyblRvU3RyaW5nKGdvdCl9XFxuXFxuYCArXG4gICAgICAgICAgICBwYXJzZXIuZ2V0QXJvdW5kVGV4dChwYXJzZXIubG9jLCBsZW5ndGgpKTtcbiAgICB9XG4gICAgZ2V0IGdvdCgpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgICAgIGZvciAoY29uc3QgbWlzdGFrZVBhdHRlcm4gb2YgdGhpcy5taXN0YWtlUGF0dGVybnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gcGFyc2VyLnRyeShtaXN0YWtlUGF0dGVybik7XG4gICAgICAgICAgICBpZiAodG9rZW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlci5pbnB1dC5jaGFyQXQocGFyc2VyLmxvYykgfHwgZXhwb3J0cy5lb2Y7XG4gICAgfVxuICAgIGdldCBjb2xSb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5vZmZzZXRUb0NvbFJvdyh0aGlzLnBhcnNlci5sb2MpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbmZ1bmN0aW9uIHBhdHRlcm5Ub1N0cmluZyhwYXR0ZXJuKSB7XG4gICAgaWYgKHBhdHRlcm4gPT09IGV4cG9ydHMuZW9mKVxuICAgICAgICByZXR1cm4gXCI8RU9GPlwiO1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhdHRlcm4pO1xuICAgIHJldHVybiBwYXR0ZXJuLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBvZmZzZXRUb0NvbFJvdyhsaW5lcywgb2Zmc2V0KSB7XG4gICAgbGV0IGNvbCA9IG9mZnNldDtcbiAgICBsZXQgcm93ID0gMDtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbGluZS5sZW5ndGggKyAxO1xuICAgICAgICBpZiAobGVuIDwgY29sKSB7XG4gICAgICAgICAgICBjb2wgLT0gbGVuO1xuICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjb2wsIHJvdyB9O1xuICAgIH1cbiAgICByZXR1cm4geyBjb2w6IDAsIHJvdyB9O1xufVxuZnVuY3Rpb24gZ2V0QXJvdW5kVGV4dChsaW5lcywgbG9jLCBsZW5ndGggPSAxLCB3aW5kb3cgPSA1KSB7XG4gICAgY29uc3QgY29sUm93ID0gb2Zmc2V0VG9Db2xSb3cobGluZXMsIGxvYyk7XG4gICAgY29uc3QgaGVhZENvdW50ID0gTWF0aC5taW4oMSwgKHdpbmRvdyA+PiAxKSArICh3aW5kb3cgJSAyKSk7XG4gICAgY29uc3QgdGFpbENvdW50ID0gd2luZG93ID4+IDE7XG4gICAgY29uc3QgaGVhZFN0YXJ0ID0gTWF0aC5tYXgoMCwgY29sUm93LnJvdyAtIGhlYWRDb3VudCAtIDEpO1xuICAgIGNvbnN0IGhlYWRFbmQgPSBjb2xSb3cucm93ICsgMTtcbiAgICBjb25zdCB0YWlsU3RhcnQgPSBjb2xSb3cucm93ICsgMTtcbiAgICBjb25zdCB0YWlsRW5kID0gY29sUm93LnJvdyArIHRhaWxDb3VudCArIDE7XG4gICAgY29uc3QgaGVhZHMgPSBsaW5lcy5zbGljZShoZWFkU3RhcnQsIGhlYWRFbmQpO1xuICAgIGNvbnN0IHRhaWxzID0gbGluZXMuc2xpY2UodGFpbFN0YXJ0LCB0YWlsRW5kKTtcbiAgICBjb25zdCBsaW5lTnVtYmVyRGlnaXRDb3VudCA9IHRhaWxFbmQudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgY29uc3QgaGVhZFRleHRzID0gaGVhZHMubWFwKChsaW5lLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsaW5lTnVtYmVyID0gaW5kZXggKyBoZWFkU3RhcnQgKyAxO1xuICAgICAgICBjb25zdCBsaW5lTnVtYmVyVGV4dCA9IGxpbmVOdW1iZXIudG9TdHJpbmcoKS5wYWRTdGFydChsaW5lTnVtYmVyRGlnaXRDb3VudCArIDEpO1xuICAgICAgICByZXR1cm4gbGluZU51bWJlclRleHQgKyBcIiB8IFwiICsgbGluZTtcbiAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIGNvbnN0IHRhaWxUZXh0cyA9IHRhaWxzLm1hcCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGluZU51bWJlciA9IGluZGV4ICsgdGFpbFN0YXJ0ICsgMTtcbiAgICAgICAgY29uc3QgbGluZU51bWJlclRleHQgPSBsaW5lTnVtYmVyLnRvU3RyaW5nKCkucGFkU3RhcnQobGluZU51bWJlckRpZ2l0Q291bnQgKyAxKTtcbiAgICAgICAgcmV0dXJuIGxpbmVOdW1iZXJUZXh0ICsgXCIgfCBcIiArIGxpbmU7XG4gICAgfSkuam9pbihcIlxcblwiKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBoZWFkVGV4dHMsXG4gICAgICAgIChuZXcgQXJyYXkobGluZU51bWJlckRpZ2l0Q291bnQgKyAxICsgMSkpLmpvaW4oXCIgXCIpICsgXCIgfCBcIiArXG4gICAgICAgICAgICAobmV3IEFycmF5KGNvbFJvdy5jb2wgKyAxKSkuam9pbihcIiBcIikgK1xuICAgICAgICAgICAgKG5ldyBBcnJheShsZW5ndGggKyAxKSkuam9pbihcIl5cIiksXG4gICAgICAgIHRhaWxUZXh0cyxcbiAgICBdLmpvaW4oXCJcXG5cIik7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pbkit/core/parser/recursive-descent-parser.js\n");

/***/ })

}]);