(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[79],{

/***/ "./node_modules/@angular/compiler/fesm2015/compiler.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@angular/compiler/fesm2015/compiler.mjs ***!
  \**************************************************************/
/*! exports provided: AST, ASTWithName, ASTWithSource, AbsoluteSourceSpan, ArrayType, AstMemoryEfficientTransformer, AstTransformer, Attribute, Binary, BinaryOperator, BinaryOperatorExpr, BindingPipe, BoundElementProperty, BuiltinType, BuiltinTypeName, CUSTOM_ELEMENTS_SCHEMA, Call, Chain, ChangeDetectionStrategy, CommaExpr, Comment, CompilerConfig, Conditional, ConditionalExpr, ConstantPool, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DYNAMIC_TYPE, DeclareFunctionStmt, DeclareVarStmt, DomElementSchemaRegistry, EOF, Element, ElementSchemaRegistry, EmitterVisitorContext, EmptyExpr, Expansion, ExpansionCase, Expression, ExpressionBinding, ExpressionStatement, ExpressionType, ExternalExpr, ExternalReference, FactoryTarget, FunctionExpr, HtmlParser, HtmlTagDefinition, I18NHtmlParser, Identifiers, IfStmt, ImplicitReceiver, InstantiateExpr, Interpolation, InterpolationConfig, InvokeFunctionExpr, JSDocComment, JitEvaluator, KeyedRead, KeyedWrite, LeadingComment, Lexer, LiteralArray, LiteralArrayExpr, LiteralExpr, LiteralMap, LiteralMapExpr, LiteralPrimitive, LocalizedString, MapType, MessageBundle, NONE_TYPE, NO_ERRORS_SCHEMA, NodeWithI18n, NonNullAssert, NotExpr, ParseError, ParseErrorLevel, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseSpan, ParseTreeResult, ParsedEvent, ParsedProperty, ParsedPropertyType, ParsedVariable, Parser, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, R3BoundTarget, R3Identifiers, R3TargetBinder, ReadKeyExpr, ReadPropExpr, ReadVarExpr, RecursiveAstVisitor, RecursiveVisitor, ResourceLoader, ReturnStatement, STRING_TYPE, SafeKeyedRead, SafePropertyRead, SelectorContext, SelectorListContext, SelectorMatcher, Serializer, SplitInterpolation, Statement, StmtModifier, TagContentType, TaggedTemplateExpr, TemplateBindingParseResult, TemplateLiteral, TemplateLiteralElement, Text, ThisReceiver, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstContent, TmplAstElement, TmplAstIcu, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstText, TmplAstTextAttribute, TmplAstVariable, Token, TokenType, TreeError, Type, TypeModifier, TypeofExpr, Unary, UnaryOperator, UnaryOperatorExpr, VERSION, VariableBinding, Version, ViewEncapsulation, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, Xliff, Xliff2, Xmb, XmlParser, Xtb, _ParseAST, compileClassMetadata, compileComponentFromMetadata, compileDeclareClassMetadata, compileDeclareComponentFromMetadata, compileDeclareDirectiveFromMetadata, compileDeclareFactoryFunction, compileDeclareInjectableFromMetadata, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileDeclarePipeFromMetadata, compileDirectiveFromMetadata, compileFactoryFunction, compileInjectable, compileInjector, compileNgModule, compilePipeFromMetadata, computeMsgId, core, createInjectableType, createMayBeForwardRefExpression, devOnlyGuardedExpression, emitDistinctChangesOnlyDefaultValue, getHtmlTagDefinition, getNsPrefix, getSafePropertyAccessString, identifierName, isIdentifier, isNgContainer, isNgContent, isNgTemplate, jsDocComment, leadingComment, literalMap, makeBindingParser, mergeNsAndName, outputAst, parseHostBindings, parseTemplate, preserveWhitespacesDefault, publishFacade, r3JitTypeSourceSpan, sanitizeIdentifier, splitNsName, verifyHostBindings, visitAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AST\", function() { return AST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ASTWithName\", function() { return ASTWithName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ASTWithSource\", function() { return ASTWithSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbsoluteSourceSpan\", function() { return AbsoluteSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArrayType\", function() { return ArrayType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AstMemoryEfficientTransformer\", function() { return AstMemoryEfficientTransformer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AstTransformer\", function() { return AstTransformer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Attribute\", function() { return Attribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Binary\", function() { return Binary; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryOperator\", function() { return BinaryOperator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BinaryOperatorExpr\", function() { return BinaryOperatorExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BindingPipe\", function() { return BindingPipe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoundElementProperty\", function() { return BoundElementProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinType\", function() { return BuiltinType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinTypeName\", function() { return BuiltinTypeName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CUSTOM_ELEMENTS_SCHEMA\", function() { return CUSTOM_ELEMENTS_SCHEMA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Call\", function() { return Call; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Chain\", function() { return Chain; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ChangeDetectionStrategy\", function() { return ChangeDetectionStrategy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommaExpr\", function() { return CommaExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Comment\", function() { return Comment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CompilerConfig\", function() { return CompilerConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Conditional\", function() { return Conditional; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConditionalExpr\", function() { return ConditionalExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConstantPool\", function() { return ConstantPool; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CssSelector\", function() { return CssSelector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_INTERPOLATION_CONFIG\", function() { return DEFAULT_INTERPOLATION_CONFIG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DYNAMIC_TYPE\", function() { return DYNAMIC_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeclareFunctionStmt\", function() { return DeclareFunctionStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeclareVarStmt\", function() { return DeclareVarStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DomElementSchemaRegistry\", function() { return DomElementSchemaRegistry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EOF\", function() { return EOF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Element\", function() { return Element; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementSchemaRegistry\", function() { return ElementSchemaRegistry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmitterVisitorContext\", function() { return EmitterVisitorContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmptyExpr\", function() { return EmptyExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Expansion\", function() { return Expansion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpansionCase\", function() { return ExpansionCase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Expression\", function() { return Expression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpressionBinding\", function() { return ExpressionBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpressionStatement\", function() { return ExpressionStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExpressionType\", function() { return ExpressionType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExternalExpr\", function() { return ExternalExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExternalReference\", function() { return ExternalReference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FactoryTarget\", function() { return FactoryTarget$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionExpr\", function() { return FunctionExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HtmlParser\", function() { return HtmlParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HtmlTagDefinition\", function() { return HtmlTagDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"I18NHtmlParser\", function() { return I18NHtmlParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Identifiers\", function() { return Identifiers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IfStmt\", function() { return IfStmt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImplicitReceiver\", function() { return ImplicitReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstantiateExpr\", function() { return InstantiateExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Interpolation\", function() { return Interpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InterpolationConfig\", function() { return InterpolationConfig; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InvokeFunctionExpr\", function() { return InvokeFunctionExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JSDocComment\", function() { return JSDocComment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"JitEvaluator\", function() { return JitEvaluator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyedRead\", function() { return KeyedRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KeyedWrite\", function() { return KeyedWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LeadingComment\", function() { return LeadingComment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lexer\", function() { return Lexer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralArray\", function() { return LiteralArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralArrayExpr\", function() { return LiteralArrayExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralExpr\", function() { return LiteralExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralMap\", function() { return LiteralMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralMapExpr\", function() { return LiteralMapExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LiteralPrimitive\", function() { return LiteralPrimitive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LocalizedString\", function() { return LocalizedString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MapType\", function() { return MapType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageBundle\", function() { return MessageBundle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NONE_TYPE\", function() { return NONE_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NO_ERRORS_SCHEMA\", function() { return NO_ERRORS_SCHEMA; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NodeWithI18n\", function() { return NodeWithI18n; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NonNullAssert\", function() { return NonNullAssert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotExpr\", function() { return NotExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseError\", function() { return ParseError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseErrorLevel\", function() { return ParseErrorLevel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseLocation\", function() { return ParseLocation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseSourceFile\", function() { return ParseSourceFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseSourceSpan\", function() { return ParseSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseSpan\", function() { return ParseSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParseTreeResult\", function() { return ParseTreeResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedEvent\", function() { return ParsedEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedProperty\", function() { return ParsedProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedPropertyType\", function() { return ParsedPropertyType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParsedVariable\", function() { return ParsedVariable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Parser\", function() { return Parser$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParserError\", function() { return ParserError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrefixNot\", function() { return PrefixNot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyRead\", function() { return PropertyRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PropertyWrite\", function() { return PropertyWrite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Quote\", function() { return Quote; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3BoundTarget\", function() { return R3BoundTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3Identifiers\", function() { return Identifiers$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"R3TargetBinder\", function() { return R3TargetBinder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadKeyExpr\", function() { return ReadKeyExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadPropExpr\", function() { return ReadPropExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadVarExpr\", function() { return ReadVarExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecursiveAstVisitor\", function() { return RecursiveAstVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RecursiveVisitor\", function() { return RecursiveVisitor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ResourceLoader\", function() { return ResourceLoader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReturnStatement\", function() { return ReturnStatement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STRING_TYPE\", function() { return STRING_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SafeKeyedRead\", function() { return SafeKeyedRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SafePropertyRead\", function() { return SafePropertyRead; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectorContext\", function() { return SelectorContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectorListContext\", function() { return SelectorListContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SelectorMatcher\", function() { return SelectorMatcher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Serializer\", function() { return Serializer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SplitInterpolation\", function() { return SplitInterpolation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Statement\", function() { return Statement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StmtModifier\", function() { return StmtModifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TagContentType\", function() { return TagContentType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TaggedTemplateExpr\", function() { return TaggedTemplateExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateBindingParseResult\", function() { return TemplateBindingParseResult; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateLiteral\", function() { return TemplateLiteral; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TemplateLiteralElement\", function() { return TemplateLiteralElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Text\", function() { return Text; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ThisReceiver\", function() { return ThisReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstBoundAttribute\", function() { return BoundAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstBoundEvent\", function() { return BoundEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstBoundText\", function() { return BoundText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstContent\", function() { return Content; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstElement\", function() { return Element$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstIcu\", function() { return Icu$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstRecursiveVisitor\", function() { return RecursiveVisitor$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstReference\", function() { return Reference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstTemplate\", function() { return Template; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstText\", function() { return Text$3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstTextAttribute\", function() { return TextAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TmplAstVariable\", function() { return Variable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Token\", function() { return Token; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TokenType\", function() { return TokenType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TreeError\", function() { return TreeError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Type\", function() { return Type; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeModifier\", function() { return TypeModifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeofExpr\", function() { return TypeofExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Unary\", function() { return Unary; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnaryOperator\", function() { return UnaryOperator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnaryOperatorExpr\", function() { return UnaryOperatorExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VERSION\", function() { return VERSION; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VariableBinding\", function() { return VariableBinding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Version\", function() { return Version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ViewEncapsulation\", function() { return ViewEncapsulation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WrappedNodeExpr\", function() { return WrappedNodeExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WriteKeyExpr\", function() { return WriteKeyExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WritePropExpr\", function() { return WritePropExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WriteVarExpr\", function() { return WriteVarExpr; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xliff\", function() { return Xliff; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xliff2\", function() { return Xliff2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xmb\", function() { return Xmb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XmlParser\", function() { return XmlParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xtb\", function() { return Xtb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"_ParseAST\", function() { return _ParseAST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileClassMetadata\", function() { return compileClassMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileComponentFromMetadata\", function() { return compileComponentFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDeclareClassMetadata\", function() { return compileDeclareClassMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDeclareComponentFromMetadata\", function() { return compileDeclareComponentFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDeclareDirectiveFromMetadata\", function() { return compileDeclareDirectiveFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDeclareFactoryFunction\", function() { return compileDeclareFactoryFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDeclareInjectableFromMetadata\", function() { return compileDeclareInjectableFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDeclareInjectorFromMetadata\", function() { return compileDeclareInjectorFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDeclareNgModuleFromMetadata\", function() { return compileDeclareNgModuleFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDeclarePipeFromMetadata\", function() { return compileDeclarePipeFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileDirectiveFromMetadata\", function() { return compileDirectiveFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileFactoryFunction\", function() { return compileFactoryFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileInjectable\", function() { return compileInjectable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileInjector\", function() { return compileInjector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compileNgModule\", function() { return compileNgModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compilePipeFromMetadata\", function() { return compilePipeFromMetadata; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeMsgId\", function() { return computeMsgId; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"core\", function() { return core; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createInjectableType\", function() { return createInjectableType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createMayBeForwardRefExpression\", function() { return createMayBeForwardRefExpression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"devOnlyGuardedExpression\", function() { return devOnlyGuardedExpression; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"emitDistinctChangesOnlyDefaultValue\", function() { return emitDistinctChangesOnlyDefaultValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHtmlTagDefinition\", function() { return getHtmlTagDefinition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getNsPrefix\", function() { return getNsPrefix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSafePropertyAccessString\", function() { return getSafePropertyAccessString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identifierName\", function() { return identifierName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIdentifier\", function() { return isIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNgContainer\", function() { return isNgContainer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNgContent\", function() { return isNgContent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNgTemplate\", function() { return isNgTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"jsDocComment\", function() { return jsDocComment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"leadingComment\", function() { return leadingComment; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"literalMap\", function() { return literalMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"makeBindingParser\", function() { return makeBindingParser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeNsAndName\", function() { return mergeNsAndName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"outputAst\", function() { return output_ast; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseHostBindings\", function() { return parseHostBindings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseTemplate\", function() { return parseTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"preserveWhitespacesDefault\", function() { return preserveWhitespacesDefault; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"publishFacade\", function() { return publishFacade; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r3JitTypeSourceSpan\", function() { return r3JitTypeSourceSpan; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sanitizeIdentifier\", function() { return sanitizeIdentifier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"splitNsName\", function() { return splitNsName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"verifyHostBindings\", function() { return verifyHostBindings; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"visitAll\", function() { return visitAll; });\n/**\n * @license Angular v13.1.3\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TagContentType;\n(function (TagContentType) {\n    TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n    TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n    TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n})(TagContentType || (TagContentType = {}));\nfunction splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    const colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex === -1) {\n        throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n// `<ng-container>` tags work the same regardless the namespace\nfunction isNgContainer(tagName) {\n    return splitNsName(tagName)[1] === 'ng-container';\n}\n// `<ng-content>` tags work the same regardless the namespace\nfunction isNgContent(tagName) {\n    return splitNsName(tagName)[1] === 'ng-content';\n}\n// `<ng-template>` tags work the same regardless the namespace\nfunction isNgTemplate(tagName) {\n    return splitNsName(tagName)[1] === 'ng-template';\n}\nfunction getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\nfunction mergeNsAndName(prefix, localName) {\n    return prefix ? `:${prefix}:${localName}` : localName;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass HtmlTagDefinition {\n    constructor({ closedByChildren, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false, preventNamespaceInheritance = false } = {}) {\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        this.canSelfClose = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n        this.preventNamespaceInheritance = preventNamespaceInheritance;\n    }\n    isClosedByChild(name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    }\n    getContentType(prefix) {\n        if (typeof this.contentType === 'object') {\n            const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n            return overrideType !== null && overrideType !== void 0 ? overrideType : this.contentType.default;\n        }\n        return this.contentType;\n    }\n}\nlet _DEFAULT_TAG_DEFINITION;\n// see https://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nlet TAG_DEFINITIONS;\nfunction getHtmlTagDefinition(tagName) {\n    var _a, _b;\n    if (!TAG_DEFINITIONS) {\n        _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n        TAG_DEFINITIONS = {\n            'base': new HtmlTagDefinition({ isVoid: true }),\n            'meta': new HtmlTagDefinition({ isVoid: true }),\n            'area': new HtmlTagDefinition({ isVoid: true }),\n            'embed': new HtmlTagDefinition({ isVoid: true }),\n            'link': new HtmlTagDefinition({ isVoid: true }),\n            'img': new HtmlTagDefinition({ isVoid: true }),\n            'input': new HtmlTagDefinition({ isVoid: true }),\n            'param': new HtmlTagDefinition({ isVoid: true }),\n            'hr': new HtmlTagDefinition({ isVoid: true }),\n            'br': new HtmlTagDefinition({ isVoid: true }),\n            'source': new HtmlTagDefinition({ isVoid: true }),\n            'track': new HtmlTagDefinition({ isVoid: true }),\n            'wbr': new HtmlTagDefinition({ isVoid: true }),\n            'p': new HtmlTagDefinition({\n                closedByChildren: [\n                    'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',\n                    'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',\n                    'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',\n                    'p', 'pre', 'section', 'table', 'ul'\n                ],\n                closedByParent: true\n            }),\n            'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n            'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n            'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n            'tr': new HtmlTagDefinition({ closedByChildren: ['tr'], closedByParent: true }),\n            'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'col': new HtmlTagDefinition({ isVoid: true }),\n            'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n            'foreignObject': new HtmlTagDefinition({\n                // Usually the implicit namespace here would be redundant since it will be inherited from\n                // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser\n                // works is that the parent node of an end tag is its own start tag which means that\n                // the `preventNamespaceInheritance` on `foreignObject` would have it default to the\n                // implicit namespace which is `html`, unless specified otherwise.\n                implicitNamespacePrefix: 'svg',\n                // We want to prevent children of foreignObject from inheriting its namespace, because\n                // the point of the element is to allow nodes from other namespaces to be inserted.\n                preventNamespaceInheritance: true,\n            }),\n            'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n            'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n            'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n            'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n            'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n            'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n            'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n            'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n            'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n            'title': new HtmlTagDefinition({\n                // The browser supports two separate `title` tags which have to use\n                // a different content type: `HTMLTitleElement` and `SVGTitleElement`\n                contentType: { default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA }\n            }),\n            'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n        };\n    }\n    // We have to make both a case-sensitive and a case-insensitive lookup, because\n    // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.\n    return (_b = (_a = TAG_DEFINITIONS[tagName]) !== null && _a !== void 0 ? _a : TAG_DEFINITIONS[tagName.toLowerCase()]) !== null && _b !== void 0 ? _b : _DEFAULT_TAG_DEFINITION;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + // 1: \":not(\"\n    '(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    // 4: attribute; 5: attribute_string; 6: attribute_value\n    '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' + // 7: \")\"\n    '(\\\\s*,\\\\s*)', // 8: \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nclass CssSelector {\n    constructor() {\n        this.element = null;\n        this.classNames = [];\n        /**\n         * The selectors are encoded in pairs where:\n         * - even locations are attribute names\n         * - odd locations are attribute values.\n         *\n         * Example:\n         * Selector: `[key1=value1][key2]` would parse to:\n         * ```\n         * ['key1', 'value1', 'key2', '']\n         * ```\n         */\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    static parse(selector) {\n        const results = [];\n        const _addResult = (res, cssSel) => {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        let cssSelector = new CssSelector();\n        let match;\n        let current = cssSelector;\n        let inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1 /* NOT */]) {\n                if (inNot) {\n                    throw new Error('Nesting :not in a selector is not allowed');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            const tag = match[2 /* TAG */];\n            if (tag) {\n                const prefix = match[3 /* PREFIX */];\n                if (prefix === '#') {\n                    // #hash\n                    current.addAttribute('id', tag.substr(1));\n                }\n                else if (prefix === '.') {\n                    // Class\n                    current.addClassName(tag.substr(1));\n                }\n                else {\n                    // Element\n                    current.setElement(tag);\n                }\n            }\n            const attribute = match[4 /* ATTRIBUTE */];\n            if (attribute) {\n                current.addAttribute(current.unescapeAttribute(attribute), match[6 /* ATTRIBUTE_VALUE */]);\n            }\n            if (match[7 /* NOT_END */]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8 /* SEPARATOR */]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    }\n    /**\n     * Unescape `\\$` sequences from the CSS attribute selector.\n     *\n     * This is needed because `$` can have a special meaning in CSS selectors,\n     * but we might want to match an attribute that contains `$`.\n     * [MDN web link for more\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n     * @param attr the attribute to unescape.\n     * @returns the unescaped string.\n     */\n    unescapeAttribute(attr) {\n        let result = '';\n        let escaping = false;\n        for (let i = 0; i < attr.length; i++) {\n            const char = attr.charAt(i);\n            if (char === '\\\\') {\n                escaping = true;\n                continue;\n            }\n            if (char === '$' && !escaping) {\n                throw new Error(`Error in attribute selector \"${attr}\". ` +\n                    `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n            }\n            escaping = false;\n            result += char;\n        }\n        return result;\n    }\n    /**\n     * Escape `$` sequences from the CSS attribute selector.\n     *\n     * This is needed because `$` can have a special meaning in CSS selectors,\n     * with this method we are escaping `$` with `\\$'.\n     * [MDN web link for more\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n     * @param attr the attribute to escape.\n     * @returns the escaped string.\n     */\n    escapeAttribute(attr) {\n        return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n    }\n    isElementSelector() {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    }\n    hasElementSelector() {\n        return !!this.element;\n    }\n    setElement(element = null) {\n        this.element = element;\n    }\n    /** Gets a template string for an element that matches the selector. */\n    getMatchingElementTemplate() {\n        const tagName = this.element || 'div';\n        const classAttr = this.classNames.length > 0 ? ` class=\"${this.classNames.join(' ')}\"` : '';\n        let attrs = '';\n        for (let i = 0; i < this.attrs.length; i += 2) {\n            const attrName = this.attrs[i];\n            const attrValue = this.attrs[i + 1] !== '' ? `=\"${this.attrs[i + 1]}\"` : '';\n            attrs += ` ${attrName}${attrValue}`;\n        }\n        return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :\n            `<${tagName}${classAttr}${attrs}></${tagName}>`;\n    }\n    getAttrs() {\n        const result = [];\n        if (this.classNames.length > 0) {\n            result.push('class', this.classNames.join(' '));\n        }\n        return result.concat(this.attrs);\n    }\n    addAttribute(name, value = '') {\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    }\n    addClassName(name) {\n        this.classNames.push(name.toLowerCase());\n    }\n    toString() {\n        let res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(klass => res += `.${klass}`);\n        }\n        if (this.attrs) {\n            for (let i = 0; i < this.attrs.length; i += 2) {\n                const name = this.escapeAttribute(this.attrs[i]);\n                const value = this.attrs[i + 1];\n                res += `[${name}${value ? '=' + value : ''}]`;\n            }\n        }\n        this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n        return res;\n    }\n}\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nclass SelectorMatcher {\n    constructor() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    static createNotMatcher(notSelectors) {\n        const notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    }\n    addSelectables(cssSelectors, callbackCtxt) {\n        let listContext = null;\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (let i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    }\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param cssSelector A css selector\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n     */\n    _addSelectable(cssSelector, callbackCtxt, listContext) {\n        let matcher = this;\n        const element = cssSelector.element;\n        const classNames = cssSelector.classNames;\n        const attrs = cssSelector.attrs;\n        const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            const isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (let i = 0; i < classNames.length; i++) {\n                const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                const className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (let i = 0; i < attrs.length; i += 2) {\n                const isTerminal = i === attrs.length - 2;\n                const name = attrs[i];\n                const value = attrs[i + 1];\n                if (isTerminal) {\n                    const terminalMap = matcher._attrValueMap;\n                    let terminalValuesMap = terminalMap.get(name);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    const partialMap = matcher._attrValuePartialMap;\n                    let partialValuesMap = partialMap.get(name);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    }\n    _addTerminal(map, name, selectable) {\n        let terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    }\n    _addPartial(map, name) {\n        let matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    }\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param cssSelector A css selector\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return boolean true if a match was found\n     */\n    match(cssSelector, matchedCallback) {\n        let result = false;\n        const element = cssSelector.element;\n        const classNames = cssSelector.classNames;\n        const attrs = cssSelector.attrs;\n        for (let i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (let i = 0; i < classNames.length; i++) {\n                const className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (let i = 0; i < attrs.length; i += 2) {\n                const name = attrs[i];\n                const value = attrs[i + 1];\n                const terminalValuesMap = this._attrValueMap.get(name);\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                const partialValuesMap = this._attrValuePartialMap.get(name);\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    }\n    /** @internal */\n    _matchTerminal(map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        let selectables = map.get(name) || [];\n        const starSelectables = map.get('*');\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        let selectable;\n        let result = false;\n        for (let i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    }\n    /** @internal */\n    _matchPartial(map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        const nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    }\n}\nclass SelectorListContext {\n    constructor(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n}\n// Store context to pass back selector and context when a selector is matched\nclass SelectorContext {\n    constructor(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    finalize(cssSelector, callback) {\n        let result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nconst emitDistinctChangesOnlyDefaultValue = true;\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\nconst CUSTOM_ELEMENTS_SCHEMA = {\n    name: 'custom-elements'\n};\nconst NO_ERRORS_SCHEMA = {\n    name: 'no-errors-schema'\n};\nconst Type$1 = Function;\nvar SecurityContext;\n(function (SecurityContext) {\n    SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n    SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n    SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n    SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n    SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\nvar MissingTranslationStrategy;\n(function (MissingTranslationStrategy) {\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\nfunction parserSelectorToSimpleSelector(selector) {\n    const classes = selector.classNames && selector.classNames.length ?\n        [8 /* CLASS */, ...selector.classNames] :\n        [];\n    const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n    return [elementName, ...selector.attrs, ...classes];\n}\nfunction parserSelectorToNegativeSelector(selector) {\n    const classes = selector.classNames && selector.classNames.length ?\n        [8 /* CLASS */, ...selector.classNames] :\n        [];\n    if (selector.element) {\n        return [\n            1 /* NOT */ | 4 /* ELEMENT */, selector.element, ...selector.attrs, ...classes\n        ];\n    }\n    else if (selector.attrs.length) {\n        return [1 /* NOT */ | 2 /* ATTRIBUTE */, ...selector.attrs, ...classes];\n    }\n    else {\n        return selector.classNames && selector.classNames.length ?\n            [1 /* NOT */ | 8 /* CLASS */, ...selector.classNames] :\n            [];\n    }\n}\nfunction parserSelectorToR3Selector(selector) {\n    const positive = parserSelectorToSimpleSelector(selector);\n    const negative = selector.notSelectors && selector.notSelectors.length ?\n        selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :\n        [];\n    return positive.concat(...negative);\n}\nfunction parseSelectorToR3Selector(selector) {\n    return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\nvar core = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue,\n    get ViewEncapsulation () { return ViewEncapsulation; },\n    get ChangeDetectionStrategy () { return ChangeDetectionStrategy; },\n    CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n    NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n    Type: Type$1,\n    get SecurityContext () { return SecurityContext; },\n    get MissingTranslationStrategy () { return MissingTranslationStrategy; },\n    parseSelectorToR3Selector: parseSelectorToR3Selector\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\n}\nfunction splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\nfunction splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\nfunction _splitAt(input, character, defaultValues) {\n    const characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\nfunction noUndefined(val) {\n    return val === undefined ? null : val;\n}\nfunction error(msg) {\n    throw new Error(`Internal Error: ${msg}`);\n}\n// Escape characters that have a special meaning in Regular Expressions\nfunction escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nfunction utf8Encode(str) {\n    let encoded = [];\n    for (let index = 0; index < str.length; index++) {\n        let codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            const low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded.push(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded.push((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded.push(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (Array.isArray(token)) {\n        return '[' + token.map(stringify).join(', ') + ']';\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n    if (token.name) {\n        return `${token.name}`;\n    }\n    if (!token.toString) {\n        return 'object';\n    }\n    // WARNING: do not try to `JSON.stringify(token)` here\n    // see https://github.com/angular/angular/issues/23440\n    const res = token.toString();\n    if (res == null) {\n        return '' + res;\n    }\n    const newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\nclass Version {\n    constructor(full) {\n        this.full = full;\n        const splits = full.split('.');\n        this.major = splits[0];\n        this.minor = splits[1];\n        this.patch = splits.slice(2).join('.');\n    }\n}\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n// Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\nconst _global = __global || __window || __self;\nfunction newArray(size, value) {\n    const list = [];\n    for (let i = 0; i < size; i++) {\n        list.push(value);\n    }\n    return list;\n}\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nfunction partitionArray(arr, conditionFn) {\n    const truthy = [];\n    const falsy = [];\n    for (const item of arr) {\n        (conditionFn(item) ? truthy : falsy).push(item);\n    }\n    return [truthy, falsy];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents a big integer using a buffer of its individual digits, with the least significant\n * digit stored at the beginning of the array (little endian).\n *\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\n * to reduce memory pressure of allocation for the digits array.\n */\nclass BigInteger {\n    /**\n     * Creates a big integer using its individual digits in little endian storage.\n     */\n    constructor(digits) {\n        this.digits = digits;\n    }\n    static zero() {\n        return new BigInteger([0]);\n    }\n    static one() {\n        return new BigInteger([1]);\n    }\n    /**\n     * Creates a clone of this instance.\n     */\n    clone() {\n        return new BigInteger(this.digits.slice());\n    }\n    /**\n     * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n     * `this` but instead returns a new instance, unlike `addToSelf`.\n     */\n    add(other) {\n        const result = this.clone();\n        result.addToSelf(other);\n        return result;\n    }\n    /**\n     * Adds `other` to the instance itself, thereby mutating its value.\n     */\n    addToSelf(other) {\n        const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n        let carry = 0;\n        for (let i = 0; i < maxNrOfDigits; i++) {\n            let digitSum = carry;\n            if (i < this.digits.length) {\n                digitSum += this.digits[i];\n            }\n            if (i < other.digits.length) {\n                digitSum += other.digits[i];\n            }\n            if (digitSum >= 10) {\n                this.digits[i] = digitSum - 10;\n                carry = 1;\n            }\n            else {\n                this.digits[i] = digitSum;\n                carry = 0;\n            }\n        }\n        // Apply a remaining carry if needed.\n        if (carry > 0) {\n            this.digits[maxNrOfDigits] = 1;\n        }\n    }\n    /**\n     * Builds the decimal string representation of the big integer. As this is stored in\n     * little endian, the digits are concatenated in reverse order.\n     */\n    toString() {\n        let res = '';\n        for (let i = this.digits.length - 1; i >= 0; i--) {\n            res += this.digits[i];\n        }\n        return res;\n    }\n}\n/**\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n */\nclass BigIntForMultiplication {\n    constructor(value) {\n        this.powerOfTwos = [value];\n    }\n    /**\n     * Returns the big integer itself.\n     */\n    getValue() {\n        return this.powerOfTwos[0];\n    }\n    /**\n     * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n     * value for `b` is represented by a storage model that is optimized for this computation.\n     *\n     * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n     * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n     * used as exponent into the power-of-two multiplication of `b`.\n     *\n     * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n     * algorithm unrolls into the following iterations:\n     *\n     *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n     * -----------|------------|------|------------|------|--------\n     *  0         | 0b00101010 | 0    | 1337       | No   | 0\n     *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n     *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n     *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n     *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n     *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n     *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n     *\n     * The computed product of 56154 is indeed the correct result.\n     *\n     * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n     * power-of-two values to reduce the workload in computing those values.\n     */\n    multiplyBy(num) {\n        const product = BigInteger.zero();\n        this.multiplyByAndAddTo(num, product);\n        return product;\n    }\n    /**\n     * See `multiplyBy()` for details. This function allows for the computed product to be added\n     * directly to the provided result big integer.\n     */\n    multiplyByAndAddTo(num, result) {\n        for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n            if (num & 1) {\n                const value = this.getMultipliedByPowerOfTwo(exponent);\n                result.addToSelf(value);\n            }\n        }\n    }\n    /**\n     * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n     */\n    getMultipliedByPowerOfTwo(exponent) {\n        // Compute the powers up until the requested exponent, where each value is computed from its\n        // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n        // added to itself) to reach `this.number * 2^exponent`.\n        for (let i = this.powerOfTwos.length; i <= exponent; i++) {\n            const previousPower = this.powerOfTwos[i - 1];\n            this.powerOfTwos[i] = previousPower.add(previousPower);\n        }\n        return this.powerOfTwos[exponent];\n    }\n}\n/**\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n * representation that is lazily computed upon request.\n */\nclass BigIntExponentiation {\n    constructor(base) {\n        this.base = base;\n        this.exponents = [new BigIntForMultiplication(BigInteger.one())];\n    }\n    /**\n     * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n     * further multiplication operations.\n     */\n    toThePowerOf(exponent) {\n        // Compute the results up until the requested exponent, where every value is computed from its\n        // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n        // to reach `this.base^exponent`.\n        for (let i = this.exponents.length; i <= exponent; i++) {\n            const value = this.exponents[i - 1].multiplyBy(this.base);\n            this.exponents[i] = new BigIntForMultiplication(value);\n        }\n        return this.exponents[exponent];\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nfunction digest$1(message) {\n    return message.id || computeDigest(message);\n}\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nfunction computeDigest(message) {\n    return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nfunction decimalDigest(message) {\n    return message.id || computeDecimalDigest(message);\n}\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nfunction computeDecimalDigest(message) {\n    const visitor = new _SerializerIgnoreIcuExpVisitor();\n    const parts = message.nodes.map(a => a.visit(visitor, null));\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor {\n    visitText(text, context) {\n        return text.value;\n    }\n    visitContainer(container, context) {\n        return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n    }\n    visitIcu(icu, context) {\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n    }\n    visitTagPlaceholder(ph, context) {\n        return ph.isVoid ?\n            `<ph tag name=\"${ph.startName}\"/>` :\n            `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n    }\n    visitPlaceholder(ph, context) {\n        return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n    }\n    visitIcuPlaceholder(ph, context) {\n        return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n    }\n}\nconst serializerVisitor$1 = new _SerializerVisitor();\nfunction serializeNodes(nodes) {\n    return nodes.map(a => a.visit(serializerVisitor$1, null));\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n    visitIcu(icu, context) {\n        let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        // Do not take the expression into account\n        return `{${icu.type}, ${strCases.join(', ')}}`;\n    }\n}\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nfunction sha1(str) {\n    const utf8 = utf8Encode(str);\n    const words32 = bytesToWords32(utf8, Endian.Big);\n    const len = utf8.length * 8;\n    const w = newArray(80);\n    let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (let i = 0; i < words32.length; i += 16) {\n        const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\n        for (let j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            const fkVal = fk(j, b, c, d);\n            const f = fkVal[0];\n            const k = fkVal[1];\n            const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            e = d;\n            d = c;\n            c = rol32(b, 30);\n            b = a;\n            a = temp;\n        }\n        a = add32(a, h0);\n        b = add32(b, h1);\n        c = add32(c, h2);\n        d = add32(d, h3);\n        e = add32(e, h4);\n    }\n    return bytesToHexString(words32ToByteString([a, b, c, d, e]));\n}\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nfunction fingerprint(str) {\n    const utf8 = utf8Encode(str);\n    let hi = hash32(utf8, 0);\n    let lo = hash32(utf8, 102072);\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\nfunction computeMsgId(msg, meaning = '') {\n    let msgFingerprint = fingerprint(msg);\n    if (meaning) {\n        const meaningFingerprint = fingerprint(meaning);\n        msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n    }\n    const hi = msgFingerprint[0];\n    const lo = msgFingerprint[1];\n    return wordsToDecimalString(hi & 0x7fffffff, lo);\n}\nfunction hash32(bytes, c) {\n    let a = 0x9e3779b9, b = 0x9e3779b9;\n    let i;\n    const len = bytes.length;\n    for (i = 0; i + 12 <= len; i += 12) {\n        a = add32(a, wordAt(bytes, i, Endian.Little));\n        b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n        c = add32(c, wordAt(bytes, i + 8, Endian.Little));\n        const res = mix(a, b, c);\n        a = res[0], b = res[1], c = res[2];\n    }\n    a = add32(a, wordAt(bytes, i, Endian.Little));\n    b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n    // the first byte of c is reserved for the length\n    c = add32(c, len);\n    c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);\n    return mix(a, b, c)[2];\n}\n// clang-format off\nfunction mix(a, b, c) {\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 13;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 8;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 13;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 12;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 16;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 5;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 3;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 10;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 15;\n    return [a, b, c];\n}\n// clang-format on\n// Utils\nvar Endian;\n(function (Endian) {\n    Endian[Endian[\"Little\"] = 0] = \"Little\";\n    Endian[Endian[\"Big\"] = 1] = \"Big\";\n})(Endian || (Endian = {}));\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\nfunction add32to64(a, b) {\n    const low = (a & 0xffff) + (b & 0xffff);\n    const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\nfunction add64(a, b) {\n    const ah = a[0], al = a[1];\n    const bh = b[0], bl = b[1];\n    const result = add32to64(al, bl);\n    const carry = result[0];\n    const l = result[1];\n    const h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\nfunction sub32(a, b) {\n    const low = (a & 0xffff) - (b & 0xffff);\n    const high = (a >> 16) - (b >> 16) + (low >> 16);\n    return (high << 16) | (low & 0xffff);\n}\n// Rotate a 32b number left `count` position\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n// Rotate a 64b number left `count` position\nfunction rol64(num, count) {\n    const hi = num[0], lo = num[1];\n    const h = (hi << count) | (lo >>> (32 - count));\n    const l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\nfunction bytesToWords32(bytes, endian) {\n    const size = (bytes.length + 3) >>> 2;\n    const words32 = [];\n    for (let i = 0; i < size; i++) {\n        words32[i] = wordAt(bytes, i * 4, endian);\n    }\n    return words32;\n}\nfunction byteAt(bytes, index) {\n    return index >= bytes.length ? 0 : bytes[index];\n}\nfunction wordAt(bytes, index, endian) {\n    let word = 0;\n    if (endian === Endian.Big) {\n        for (let i = 0; i < 4; i++) {\n            word += byteAt(bytes, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (let i = 0; i < 4; i++) {\n            word += byteAt(bytes, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\nfunction words32ToByteString(words32) {\n    return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), []);\n}\nfunction word32ToByteString(word) {\n    let bytes = [];\n    for (let i = 0; i < 4; i++) {\n        bytes.push((word >>> 8 * (3 - i)) & 0xff);\n    }\n    return bytes;\n}\nfunction bytesToHexString(bytes) {\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        const b = byteAt(bytes, i);\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n    }\n    return hex.toLowerCase();\n}\n/**\n * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\n * power-of-256 results with memoized power-of-two computations for efficient multiplication.\n *\n * For our purposes, this can be safely stored as a global without memory concerns. The reason is\n * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\n * exponent.\n */\nconst base256 = new BigIntExponentiation(256);\n/**\n * Represents two 32-bit words as a single decimal number. This requires a big integer storage\n * model as JS numbers are not accurate enough to represent the 64-bit number.\n *\n * Based on https://www.danvk.org/hex2dec.html\n */\nfunction wordsToDecimalString(hi, lo) {\n    // Encode the four bytes in lo in the lower digits of the decimal number.\n    // Note: the multiplication results in lo itself but represented by a big integer using its\n    // decimal digits.\n    const decimal = base256.toThePowerOf(0).multiplyBy(lo);\n    // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\n    // this multiplication factor is applied.\n    base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\n    return decimal.toString();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n//// Types\nvar TypeModifier;\n(function (TypeModifier) {\n    TypeModifier[TypeModifier[\"None\"] = 0] = \"None\";\n    TypeModifier[TypeModifier[\"Const\"] = 1] = \"Const\";\n})(TypeModifier || (TypeModifier = {}));\nclass Type {\n    constructor(modifiers = TypeModifier.None) {\n        this.modifiers = modifiers;\n    }\n    hasModifier(modifier) {\n        return (this.modifiers & modifier) !== 0;\n    }\n}\nvar BuiltinTypeName;\n(function (BuiltinTypeName) {\n    BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n    BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n    BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n    BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n    BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n    BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n    BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n    BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n})(BuiltinTypeName || (BuiltinTypeName = {}));\nclass BuiltinType extends Type {\n    constructor(name, modifiers) {\n        super(modifiers);\n        this.name = name;\n    }\n    visitType(visitor, context) {\n        return visitor.visitBuiltinType(this, context);\n    }\n}\nclass ExpressionType extends Type {\n    constructor(value, modifiers, typeParams = null) {\n        super(modifiers);\n        this.value = value;\n        this.typeParams = typeParams;\n    }\n    visitType(visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    }\n}\nclass ArrayType extends Type {\n    constructor(of, modifiers) {\n        super(modifiers);\n        this.of = of;\n    }\n    visitType(visitor, context) {\n        return visitor.visitArrayType(this, context);\n    }\n}\nclass MapType extends Type {\n    constructor(valueType, modifiers) {\n        super(modifiers);\n        this.valueType = valueType || null;\n    }\n    visitType(visitor, context) {\n        return visitor.visitMapType(this, context);\n    }\n}\nconst DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nconst INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nconst BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nconst INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nconst NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nconst STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nconst FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nconst NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n///// Expressions\nvar UnaryOperator;\n(function (UnaryOperator) {\n    UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n    UnaryOperator[UnaryOperator[\"Plus\"] = 1] = \"Plus\";\n})(UnaryOperator || (UnaryOperator = {}));\nvar BinaryOperator;\n(function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n    BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n    BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\n    BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\n    BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\n    BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\n    BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\n    BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\n    BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 11] = \"BitwiseAnd\";\n    BinaryOperator[BinaryOperator[\"Lower\"] = 12] = \"Lower\";\n    BinaryOperator[BinaryOperator[\"LowerEquals\"] = 13] = \"LowerEquals\";\n    BinaryOperator[BinaryOperator[\"Bigger\"] = 14] = \"Bigger\";\n    BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 15] = \"BiggerEquals\";\n    BinaryOperator[BinaryOperator[\"NullishCoalesce\"] = 16] = \"NullishCoalesce\";\n})(BinaryOperator || (BinaryOperator = {}));\nfunction nullSafeIsEquivalent(base, other) {\n    if (base == null || other == null) {\n        return base == other;\n    }\n    return base.isEquivalent(other);\n}\nfunction areAllEquivalentPredicate(base, other, equivalentPredicate) {\n    const len = base.length;\n    if (len !== other.length) {\n        return false;\n    }\n    for (let i = 0; i < len; i++) {\n        if (!equivalentPredicate(base[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction areAllEquivalent(base, other) {\n    return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));\n}\nclass Expression {\n    constructor(type, sourceSpan) {\n        this.type = type || null;\n        this.sourceSpan = sourceSpan || null;\n    }\n    prop(name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    }\n    key(index, type, sourceSpan) {\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    }\n    callFn(params, sourceSpan, pure) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n    }\n    instantiate(params, type, sourceSpan) {\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    }\n    conditional(trueCase, falseCase = null, sourceSpan) {\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    }\n    equals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    }\n    notEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    }\n    identical(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    }\n    notIdentical(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    }\n    minus(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    }\n    plus(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    }\n    divide(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    }\n    multiply(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    }\n    modulo(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    }\n    and(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    }\n    bitwiseAnd(rhs, sourceSpan, parens = true) {\n        return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n    }\n    or(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    }\n    lower(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    }\n    lowerEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    }\n    bigger(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    }\n    biggerEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    }\n    isBlank(sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    }\n    nullishCoalesce(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n    }\n    toStmt() {\n        return new ExpressionStatement(this, null);\n    }\n}\nclass ReadVarExpr extends Expression {\n    constructor(name, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.name = name;\n    }\n    isEquivalent(e) {\n        return e instanceof ReadVarExpr && this.name === e.name;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    }\n    set(value) {\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    }\n}\nclass TypeofExpr extends Expression {\n    constructor(expr, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.expr = expr;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitTypeofExpr(this, context);\n    }\n    isEquivalent(e) {\n        return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n    }\n    isConstant() {\n        return this.expr.isConstant();\n    }\n}\nclass WrappedNodeExpr extends Expression {\n    constructor(node, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.node = node;\n    }\n    isEquivalent(e) {\n        return e instanceof WrappedNodeExpr && this.node === e.node;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWrappedNodeExpr(this, context);\n    }\n}\nclass WriteVarExpr extends Expression {\n    constructor(name, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.name = name;\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    }\n    toDeclStmt(type, modifiers) {\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    }\n    toConstDecl() {\n        return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);\n    }\n}\nclass WriteKeyExpr extends Expression {\n    constructor(receiver, index, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.receiver = receiver;\n        this.index = index;\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    }\n}\nclass WritePropExpr extends Expression {\n    constructor(receiver, name, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.receiver = receiver;\n        this.name = name;\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name && this.value.isEquivalent(e.value);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    }\n}\nclass InvokeFunctionExpr extends Expression {\n    constructor(fn, args, type, sourceSpan, pure = false) {\n        super(type, sourceSpan);\n        this.fn = fn;\n        this.args = args;\n        this.pure = pure;\n    }\n    isEquivalent(e) {\n        return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n            areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    }\n}\nclass TaggedTemplateExpr extends Expression {\n    constructor(tag, template, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.tag = tag;\n        this.template = template;\n    }\n    isEquivalent(e) {\n        return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&\n            areAllEquivalentPredicate(this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&\n            areAllEquivalent(this.template.expressions, e.template.expressions);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitTaggedTemplateExpr(this, context);\n    }\n}\nclass InstantiateExpr extends Expression {\n    constructor(classExpr, args, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.classExpr = classExpr;\n        this.args = args;\n    }\n    isEquivalent(e) {\n        return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n            areAllEquivalent(this.args, e.args);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    }\n}\nclass LiteralExpr extends Expression {\n    constructor(value, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof LiteralExpr && this.value === e.value;\n    }\n    isConstant() {\n        return true;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    }\n}\nclass TemplateLiteral {\n    constructor(elements, expressions) {\n        this.elements = elements;\n        this.expressions = expressions;\n    }\n}\nclass TemplateLiteralElement {\n    constructor(text, sourceSpan, rawText) {\n        var _a;\n        this.text = text;\n        this.sourceSpan = sourceSpan;\n        // If `rawText` is not provided, try to extract the raw string from its\n        // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n        // string instead by escaping the following control sequences:\n        // - \"\\\" would otherwise indicate that the next character is a control character.\n        // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n        // indicate the end of the template literal element.\n        this.rawText =\n            (_a = rawText !== null && rawText !== void 0 ? rawText : sourceSpan === null || sourceSpan === void 0 ? void 0 : sourceSpan.toString()) !== null && _a !== void 0 ? _a : escapeForTemplateLiteral(escapeSlashes(text));\n    }\n}\nclass LiteralPiece {\n    constructor(text, sourceSpan) {\n        this.text = text;\n        this.sourceSpan = sourceSpan;\n    }\n}\nclass PlaceholderPiece {\n    /**\n     * Create a new instance of a `PlaceholderPiece`.\n     *\n     * @param text the name of this placeholder (e.g. `PH_1`).\n     * @param sourceSpan the location of this placeholder in its localized message the source code.\n     * @param associatedMessage reference to another message that this placeholder is associated with.\n     * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n     * been extracted out from the message containing the placeholder.\n     */\n    constructor(text, sourceSpan, associatedMessage) {\n        this.text = text;\n        this.sourceSpan = sourceSpan;\n        this.associatedMessage = associatedMessage;\n    }\n}\nconst MEANING_SEPARATOR$1 = '|';\nconst ID_SEPARATOR$1 = '@@';\nconst LEGACY_ID_INDICATOR = '';\nclass LocalizedString extends Expression {\n    constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n        super(STRING_TYPE, sourceSpan);\n        this.metaBlock = metaBlock;\n        this.messageParts = messageParts;\n        this.placeHolderNames = placeHolderNames;\n        this.expressions = expressions;\n    }\n    isEquivalent(e) {\n        // return e instanceof LocalizedString && this.message === e.message;\n        return false;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLocalizedString(this, context);\n    }\n    /**\n     * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n     * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n     * `parseI18nMeta()`.\n     *\n     * @param meta The metadata to serialize\n     * @param messagePart The first part of the tagged string\n     */\n    serializeI18nHead() {\n        let metaBlock = this.metaBlock.description || '';\n        if (this.metaBlock.meaning) {\n            metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR$1}${metaBlock}`;\n        }\n        if (this.metaBlock.customId) {\n            metaBlock = `${metaBlock}${ID_SEPARATOR$1}${this.metaBlock.customId}`;\n        }\n        if (this.metaBlock.legacyIds) {\n            this.metaBlock.legacyIds.forEach(legacyId => {\n                metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n            });\n        }\n        return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n    }\n    getMessagePartSourceSpan(i) {\n        var _a, _b;\n        return (_b = (_a = this.messageParts[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : this.sourceSpan;\n    }\n    getPlaceholderSourceSpan(i) {\n        var _a, _b, _c, _d;\n        return (_d = (_b = (_a = this.placeHolderNames[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : (_c = this.expressions[i]) === null || _c === void 0 ? void 0 : _c.sourceSpan) !== null && _d !== void 0 ? _d : this.sourceSpan;\n    }\n    /**\n     * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n     * can be used in a `$localize` tagged string.\n     *\n     * The format is `:<placeholder-name>[@@<associated-id>]:`.\n     *\n     * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n     * refers.\n     *\n     * @param partIndex The index of the message part to serialize.\n     */\n    serializeI18nTemplatePart(partIndex) {\n        var _a;\n        const placeholder = this.placeHolderNames[partIndex - 1];\n        const messagePart = this.messageParts[partIndex];\n        let metaBlock = placeholder.text;\n        if (((_a = placeholder.associatedMessage) === null || _a === void 0 ? void 0 : _a.legacyIds.length) === 0) {\n            metaBlock += `${ID_SEPARATOR$1}${computeMsgId(placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n        }\n        return createCookedRawString(metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n    }\n}\nconst escapeSlashes = (str) => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str) => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str) => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str) => str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(metaBlock, messagePart, range) {\n    if (metaBlock === '') {\n        return {\n            cooked: messagePart,\n            raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n            range,\n        };\n    }\n    else {\n        return {\n            cooked: `:${metaBlock}:${messagePart}`,\n            raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n            range,\n        };\n    }\n}\nclass ExternalExpr extends Expression {\n    constructor(value, type, typeParams = null, sourceSpan) {\n        super(type, sourceSpan);\n        this.value = value;\n        this.typeParams = typeParams;\n    }\n    isEquivalent(e) {\n        return e instanceof ExternalExpr && this.value.name === e.value.name &&\n            this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    }\n}\nclass ExternalReference {\n    constructor(moduleName, name, runtime) {\n        this.moduleName = moduleName;\n        this.name = name;\n        this.runtime = runtime;\n    }\n}\nclass ConditionalExpr extends Expression {\n    constructor(condition, trueCase, falseCase = null, type, sourceSpan) {\n        super(type || trueCase.type, sourceSpan);\n        this.condition = condition;\n        this.falseCase = falseCase;\n        this.trueCase = trueCase;\n    }\n    isEquivalent(e) {\n        return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n            this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    }\n}\nclass NotExpr extends Expression {\n    constructor(condition, sourceSpan) {\n        super(BOOL_TYPE, sourceSpan);\n        this.condition = condition;\n    }\n    isEquivalent(e) {\n        return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    }\n}\nclass FnParam {\n    constructor(name, type = null) {\n        this.name = name;\n        this.type = type;\n    }\n    isEquivalent(param) {\n        return this.name === param.name;\n    }\n}\nclass FunctionExpr extends Expression {\n    constructor(params, statements, type, sourceSpan, name) {\n        super(type, sourceSpan);\n        this.params = params;\n        this.statements = statements;\n        this.name = name;\n    }\n    isEquivalent(e) {\n        return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n            areAllEquivalent(this.statements, e.statements);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    }\n    toDeclStmt(name, modifiers) {\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    }\n}\nclass UnaryOperatorExpr extends Expression {\n    constructor(operator, expr, type, sourceSpan, parens = true) {\n        super(type || NUMBER_TYPE, sourceSpan);\n        this.operator = operator;\n        this.expr = expr;\n        this.parens = parens;\n    }\n    isEquivalent(e) {\n        return e instanceof UnaryOperatorExpr && this.operator === e.operator &&\n            this.expr.isEquivalent(e.expr);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitUnaryOperatorExpr(this, context);\n    }\n}\nclass BinaryOperatorExpr extends Expression {\n    constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {\n        super(type || lhs.type, sourceSpan);\n        this.operator = operator;\n        this.rhs = rhs;\n        this.parens = parens;\n        this.lhs = lhs;\n    }\n    isEquivalent(e) {\n        return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n            this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    }\n}\nclass ReadPropExpr extends Expression {\n    constructor(receiver, name, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    isEquivalent(e) {\n        return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    }\n    set(value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    }\n}\nclass ReadKeyExpr extends Expression {\n    constructor(receiver, index, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.receiver = receiver;\n        this.index = index;\n    }\n    isEquivalent(e) {\n        return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    }\n    set(value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    }\n}\nclass LiteralArrayExpr extends Expression {\n    constructor(entries, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.entries = entries;\n    }\n    isConstant() {\n        return this.entries.every(e => e.isConstant());\n    }\n    isEquivalent(e) {\n        return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    }\n}\nclass LiteralMapEntry {\n    constructor(key, value, quoted) {\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    isEquivalent(e) {\n        return this.key === e.key && this.value.isEquivalent(e.value);\n    }\n}\nclass LiteralMapExpr extends Expression {\n    constructor(entries, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.entries = entries;\n        this.valueType = null;\n        if (type) {\n            this.valueType = type.valueType;\n        }\n    }\n    isEquivalent(e) {\n        return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n    }\n    isConstant() {\n        return this.entries.every(e => e.value.isConstant());\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    }\n}\nclass CommaExpr extends Expression {\n    constructor(parts, sourceSpan) {\n        super(parts[parts.length - 1].type, sourceSpan);\n        this.parts = parts;\n    }\n    isEquivalent(e) {\n        return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    }\n}\nconst NULL_EXPR = new LiteralExpr(null, null, null);\nconst TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n//// Statements\nvar StmtModifier;\n(function (StmtModifier) {\n    StmtModifier[StmtModifier[\"None\"] = 0] = \"None\";\n    StmtModifier[StmtModifier[\"Final\"] = 1] = \"Final\";\n    StmtModifier[StmtModifier[\"Private\"] = 2] = \"Private\";\n    StmtModifier[StmtModifier[\"Exported\"] = 4] = \"Exported\";\n    StmtModifier[StmtModifier[\"Static\"] = 8] = \"Static\";\n})(StmtModifier || (StmtModifier = {}));\nclass LeadingComment {\n    constructor(text, multiline, trailingNewline) {\n        this.text = text;\n        this.multiline = multiline;\n        this.trailingNewline = trailingNewline;\n    }\n    toString() {\n        return this.multiline ? ` ${this.text} ` : this.text;\n    }\n}\nclass JSDocComment extends LeadingComment {\n    constructor(tags) {\n        super('', /* multiline */ true, /* trailingNewline */ true);\n        this.tags = tags;\n    }\n    toString() {\n        return serializeTags(this.tags);\n    }\n}\nclass Statement {\n    constructor(modifiers = StmtModifier.None, sourceSpan = null, leadingComments) {\n        this.modifiers = modifiers;\n        this.sourceSpan = sourceSpan;\n        this.leadingComments = leadingComments;\n    }\n    hasModifier(modifier) {\n        return (this.modifiers & modifier) !== 0;\n    }\n    addLeadingComment(leadingComment) {\n        var _a;\n        this.leadingComments = (_a = this.leadingComments) !== null && _a !== void 0 ? _a : [];\n        this.leadingComments.push(leadingComment);\n    }\n}\nclass DeclareVarStmt extends Statement {\n    constructor(name, value, type, modifiers, sourceSpan, leadingComments) {\n        super(modifiers, sourceSpan, leadingComments);\n        this.name = name;\n        this.value = value;\n        this.type = type || (value && value.type) || null;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n            (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    }\n}\nclass DeclareFunctionStmt extends Statement {\n    constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {\n        super(modifiers, sourceSpan, leadingComments);\n        this.name = name;\n        this.params = params;\n        this.statements = statements;\n        this.type = type || null;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n            areAllEquivalent(this.statements, stmt.statements);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    }\n}\nclass ExpressionStatement extends Statement {\n    constructor(expr, sourceSpan, leadingComments) {\n        super(StmtModifier.None, sourceSpan, leadingComments);\n        this.expr = expr;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    }\n}\nclass ReturnStatement extends Statement {\n    constructor(value, sourceSpan = null, leadingComments) {\n        super(StmtModifier.None, sourceSpan, leadingComments);\n        this.value = value;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    }\n}\nclass IfStmt extends Statement {\n    constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {\n        super(StmtModifier.None, sourceSpan, leadingComments);\n        this.condition = condition;\n        this.trueCase = trueCase;\n        this.falseCase = falseCase;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n            areAllEquivalent(this.trueCase, stmt.trueCase) &&\n            areAllEquivalent(this.falseCase, stmt.falseCase);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    }\n}\nclass RecursiveAstVisitor$1 {\n    visitType(ast, context) {\n        return ast;\n    }\n    visitExpression(ast, context) {\n        if (ast.type) {\n            ast.type.visitType(this, context);\n        }\n        return ast;\n    }\n    visitBuiltinType(type, context) {\n        return this.visitType(type, context);\n    }\n    visitExpressionType(type, context) {\n        type.value.visitExpression(this, context);\n        if (type.typeParams !== null) {\n            type.typeParams.forEach(param => this.visitType(param, context));\n        }\n        return this.visitType(type, context);\n    }\n    visitArrayType(type, context) {\n        return this.visitType(type, context);\n    }\n    visitMapType(type, context) {\n        return this.visitType(type, context);\n    }\n    visitWrappedNodeExpr(ast, context) {\n        return ast;\n    }\n    visitTypeofExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitReadVarExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitWriteVarExpr(ast, context) {\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitWriteKeyExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitWritePropExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitInvokeFunctionExpr(ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    }\n    visitTaggedTemplateExpr(ast, context) {\n        ast.tag.visitExpression(this, context);\n        this.visitAllExpressions(ast.template.expressions, context);\n        return this.visitExpression(ast, context);\n    }\n    visitInstantiateExpr(ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    }\n    visitLiteralExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitLocalizedString(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitExternalExpr(ast, context) {\n        if (ast.typeParams) {\n            ast.typeParams.forEach(type => type.visitType(this, context));\n        }\n        return this.visitExpression(ast, context);\n    }\n    visitConditionalExpr(ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context);\n        ast.falseCase.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitNotExpr(ast, context) {\n        ast.condition.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitFunctionExpr(ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return this.visitExpression(ast, context);\n    }\n    visitUnaryOperatorExpr(ast, context) {\n        ast.expr.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitBinaryOperatorExpr(ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitReadPropExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitReadKeyExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitLiteralArrayExpr(ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return this.visitExpression(ast, context);\n    }\n    visitLiteralMapExpr(ast, context) {\n        ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n        return this.visitExpression(ast, context);\n    }\n    visitCommaExpr(ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n        return this.visitExpression(ast, context);\n    }\n    visitAllExpressions(exprs, context) {\n        exprs.forEach(expr => expr.visitExpression(this, context));\n    }\n    visitDeclareVarStmt(stmt, context) {\n        if (stmt.value) {\n            stmt.value.visitExpression(this, context);\n        }\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    }\n    visitDeclareFunctionStmt(stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    }\n    visitExpressionStmt(stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    }\n    visitReturnStmt(stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    }\n    visitIfStmt(stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    }\n    visitAllStatements(stmts, context) {\n        stmts.forEach(stmt => stmt.visitStatement(this, context));\n    }\n}\nfunction leadingComment(text, multiline = false, trailingNewline = true) {\n    return new LeadingComment(text, multiline, trailingNewline);\n}\nfunction jsDocComment(tags = []) {\n    return new JSDocComment(tags);\n}\nfunction variable(name, type, sourceSpan) {\n    return new ReadVarExpr(name, type, sourceSpan);\n}\nfunction importExpr(id, typeParams = null, sourceSpan) {\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\nfunction importType(id, typeParams, typeModifiers) {\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\nfunction expressionType(expr, typeModifiers, typeParams) {\n    return new ExpressionType(expr, typeModifiers, typeParams);\n}\nfunction typeofExpr(expr) {\n    return new TypeofExpr(expr);\n}\nfunction literalArr(values, type, sourceSpan) {\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\nfunction literalMap(values, type = null) {\n    return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\nfunction unary(operator, expr, type, sourceSpan) {\n    return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\nfunction not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\nfunction fn(params, body, type, sourceSpan, name) {\n    return new FunctionExpr(params, body, type, sourceSpan, name);\n}\nfunction ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {\n    return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\nfunction taggedTemplate(tag, template, type, sourceSpan) {\n    return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n}\nfunction literal(value, type, sourceSpan) {\n    return new LiteralExpr(value, type, sourceSpan);\n}\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n    return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\nfunction isNull(exp) {\n    return exp instanceof LiteralExpr && exp.value === null;\n}\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag) {\n    let out = '';\n    if (tag.tagName) {\n        out += ` @${tag.tagName}`;\n    }\n    if (tag.text) {\n        if (tag.text.match(/\\/\\*|\\*\\//)) {\n            throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n        }\n        out += ' ' + tag.text.replace(/@/g, '\\\\@');\n    }\n    return out;\n}\nfunction serializeTags(tags) {\n    if (tags.length === 0)\n        return '';\n    if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n        // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n        return `*${tagToString(tags[0])} `;\n    }\n    let out = '*\\n';\n    for (const tag of tags) {\n        out += ' *';\n        // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n        out += tagToString(tag).replace(/\\n/g, '\\n * ');\n        out += '\\n';\n    }\n    out += ' ';\n    return out;\n}\n\nvar output_ast = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get TypeModifier () { return TypeModifier; },\n    Type: Type,\n    get BuiltinTypeName () { return BuiltinTypeName; },\n    BuiltinType: BuiltinType,\n    ExpressionType: ExpressionType,\n    ArrayType: ArrayType,\n    MapType: MapType,\n    DYNAMIC_TYPE: DYNAMIC_TYPE,\n    INFERRED_TYPE: INFERRED_TYPE,\n    BOOL_TYPE: BOOL_TYPE,\n    INT_TYPE: INT_TYPE,\n    NUMBER_TYPE: NUMBER_TYPE,\n    STRING_TYPE: STRING_TYPE,\n    FUNCTION_TYPE: FUNCTION_TYPE,\n    NONE_TYPE: NONE_TYPE,\n    get UnaryOperator () { return UnaryOperator; },\n    get BinaryOperator () { return BinaryOperator; },\n    nullSafeIsEquivalent: nullSafeIsEquivalent,\n    areAllEquivalent: areAllEquivalent,\n    Expression: Expression,\n    ReadVarExpr: ReadVarExpr,\n    TypeofExpr: TypeofExpr,\n    WrappedNodeExpr: WrappedNodeExpr,\n    WriteVarExpr: WriteVarExpr,\n    WriteKeyExpr: WriteKeyExpr,\n    WritePropExpr: WritePropExpr,\n    InvokeFunctionExpr: InvokeFunctionExpr,\n    TaggedTemplateExpr: TaggedTemplateExpr,\n    InstantiateExpr: InstantiateExpr,\n    LiteralExpr: LiteralExpr,\n    TemplateLiteral: TemplateLiteral,\n    TemplateLiteralElement: TemplateLiteralElement,\n    LiteralPiece: LiteralPiece,\n    PlaceholderPiece: PlaceholderPiece,\n    LocalizedString: LocalizedString,\n    ExternalExpr: ExternalExpr,\n    ExternalReference: ExternalReference,\n    ConditionalExpr: ConditionalExpr,\n    NotExpr: NotExpr,\n    FnParam: FnParam,\n    FunctionExpr: FunctionExpr,\n    UnaryOperatorExpr: UnaryOperatorExpr,\n    BinaryOperatorExpr: BinaryOperatorExpr,\n    ReadPropExpr: ReadPropExpr,\n    ReadKeyExpr: ReadKeyExpr,\n    LiteralArrayExpr: LiteralArrayExpr,\n    LiteralMapEntry: LiteralMapEntry,\n    LiteralMapExpr: LiteralMapExpr,\n    CommaExpr: CommaExpr,\n    NULL_EXPR: NULL_EXPR,\n    TYPED_NULL_EXPR: TYPED_NULL_EXPR,\n    get StmtModifier () { return StmtModifier; },\n    LeadingComment: LeadingComment,\n    JSDocComment: JSDocComment,\n    Statement: Statement,\n    DeclareVarStmt: DeclareVarStmt,\n    DeclareFunctionStmt: DeclareFunctionStmt,\n    ExpressionStatement: ExpressionStatement,\n    ReturnStatement: ReturnStatement,\n    IfStmt: IfStmt,\n    RecursiveAstVisitor: RecursiveAstVisitor$1,\n    leadingComment: leadingComment,\n    jsDocComment: jsDocComment,\n    variable: variable,\n    importExpr: importExpr,\n    importType: importType,\n    expressionType: expressionType,\n    typeofExpr: typeofExpr,\n    literalArr: literalArr,\n    literalMap: literalMap,\n    unary: unary,\n    not: not,\n    fn: fn,\n    ifStmt: ifStmt,\n    taggedTemplate: taggedTemplate,\n    literal: literal,\n    localizedString: localizedString,\n    isNull: isNull\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst CONSTANT_PREFIX = '_c';\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = variable('<unknown>');\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends Expression {\n    constructor(resolved) {\n        super(resolved.type);\n        this.resolved = resolved;\n        this.original = resolved;\n    }\n    visitExpression(visitor, context) {\n        if (context === KEY_CONTEXT) {\n            // When producing a key we want to traverse the constant not the\n            // variable used to refer to it.\n            return this.original.visitExpression(visitor, context);\n        }\n        else {\n            return this.resolved.visitExpression(visitor, context);\n        }\n    }\n    isEquivalent(e) {\n        return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n    }\n    isConstant() {\n        return true;\n    }\n    fixup(expression) {\n        this.resolved = expression;\n        this.shared = true;\n    }\n}\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nclass ConstantPool {\n    constructor(isClosureCompilerEnabled = false) {\n        this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n        this.statements = [];\n        this.literals = new Map();\n        this.literalFactories = new Map();\n        this.nextNameIndex = 0;\n    }\n    getConstLiteral(literal, forceShared) {\n        if ((literal instanceof LiteralExpr && !isLongStringLiteral(literal)) ||\n            literal instanceof FixupExpression) {\n            // Do no put simple literals into the constant pool or try to produce a constant for a\n            // reference to a constant.\n            return literal;\n        }\n        const key = this.keyOf(literal);\n        let fixup = this.literals.get(key);\n        let newValue = false;\n        if (!fixup) {\n            fixup = new FixupExpression(literal);\n            this.literals.set(key, fixup);\n            newValue = true;\n        }\n        if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n            // Replace the expression with a variable\n            const name = this.freshName();\n            let definition;\n            let usage;\n            if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n                // For string literals, Closure will **always** inline the string at\n                // **all** usages, duplicating it each time. For large strings, this\n                // unnecessarily bloats bundle size. To work around this restriction, we\n                // wrap the string in a function, and call that function for each usage.\n                // This tricks Closure into using inline logic for functions instead of\n                // string literals. Function calls are only inlined if the body is small\n                // enough to be worth it. By doing this, very large strings will be\n                // shared across multiple usages, rather than duplicating the string at\n                // each usage site.\n                //\n                // const myStr = function() { return \"very very very long string\"; };\n                // const usage1 = myStr();\n                // const usage2 = myStr();\n                definition = variable(name).set(new FunctionExpr([], // Params.\n                [\n                    // Statements.\n                    new ReturnStatement(literal),\n                ]));\n                usage = variable(name).callFn([]);\n            }\n            else {\n                // Just declare and use the variable directly, without a function call\n                // indirection. This saves a few bytes and avoids an unncessary call.\n                definition = variable(name).set(literal);\n                usage = variable(name);\n            }\n            this.statements.push(definition.toDeclStmt(INFERRED_TYPE, StmtModifier.Final));\n            fixup.fixup(usage);\n        }\n        return fixup;\n    }\n    getLiteralFactory(literal) {\n        // Create a pure function that builds an array of a mix of constant and variable expressions\n        if (literal instanceof LiteralArrayExpr) {\n            const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n            const key = this.keyOf(literalArr(argumentsForKey));\n            return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));\n        }\n        else {\n            const expressionForKey = literalMap(literal.entries.map(e => ({\n                key: e.key,\n                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n                quoted: e.quoted\n            })));\n            const key = this.keyOf(expressionForKey);\n            return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({\n                key: literal.entries[index].key,\n                value,\n                quoted: literal.entries[index].quoted\n            }))));\n        }\n    }\n    _getLiteralFactory(key, values, resultMap) {\n        let literalFactory = this.literalFactories.get(key);\n        const literalFactoryArguments = values.filter((e => !e.isConstant()));\n        if (!literalFactory) {\n            const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));\n            const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));\n            const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);\n            const name = this.freshName();\n            this.statements.push(variable(name)\n                .set(pureFunctionDeclaration)\n                .toDeclStmt(INFERRED_TYPE, StmtModifier.Final));\n            literalFactory = variable(name);\n            this.literalFactories.set(key, literalFactory);\n        }\n        return { literalFactory, literalFactoryArguments };\n    }\n    /**\n     * Produce a unique name.\n     *\n     * The name might be unique among different prefixes if any of the prefixes end in\n     * a digit so the prefix should be a constant string (not based on user input) and\n     * must not end in a digit.\n     */\n    uniqueName(prefix) {\n        return `${prefix}${this.nextNameIndex++}`;\n    }\n    freshName() {\n        return this.uniqueName(CONSTANT_PREFIX);\n    }\n    keyOf(expression) {\n        return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n    }\n}\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor {\n    constructor() {\n        this.visitWrappedNodeExpr = invalid$1;\n        this.visitWriteVarExpr = invalid$1;\n        this.visitWriteKeyExpr = invalid$1;\n        this.visitWritePropExpr = invalid$1;\n        this.visitInvokeFunctionExpr = invalid$1;\n        this.visitTaggedTemplateExpr = invalid$1;\n        this.visitInstantiateExpr = invalid$1;\n        this.visitConditionalExpr = invalid$1;\n        this.visitNotExpr = invalid$1;\n        this.visitAssertNotNullExpr = invalid$1;\n        this.visitCastExpr = invalid$1;\n        this.visitFunctionExpr = invalid$1;\n        this.visitUnaryOperatorExpr = invalid$1;\n        this.visitBinaryOperatorExpr = invalid$1;\n        this.visitReadPropExpr = invalid$1;\n        this.visitReadKeyExpr = invalid$1;\n        this.visitCommaExpr = invalid$1;\n        this.visitLocalizedString = invalid$1;\n    }\n    visitLiteralExpr(ast) {\n        return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n    }\n    visitLiteralArrayExpr(ast, context) {\n        return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n    }\n    visitLiteralMapExpr(ast, context) {\n        const mapKey = (entry) => {\n            const quote = entry.quoted ? '\"' : '';\n            return `${quote}${entry.key}${quote}`;\n        };\n        const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n        return `{${ast.entries.map(mapEntry).join(',')}`;\n    }\n    visitExternalExpr(ast) {\n        return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n            `EX:${ast.value.runtime.name}`;\n    }\n    visitReadVarExpr(node) {\n        return `VAR:${node.name}`;\n    }\n    visitTypeofExpr(node, context) {\n        return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n    }\n}\nfunction invalid$1(arg) {\n    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\nfunction isVariable(e) {\n    return e instanceof ReadVarExpr;\n}\nfunction isLongStringLiteral(expr) {\n    return expr instanceof LiteralExpr && typeof expr.value === 'string' &&\n        expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst CORE$1 = '@angular/core';\nclass Identifiers$1 {\n}\n/* Methods */\nIdentifiers$1.NEW_METHOD = 'factory';\nIdentifiers$1.TRANSFORM_METHOD = 'transform';\nIdentifiers$1.PATCH_DEPS = 'patchedDeps';\nIdentifiers$1.core = { name: null, moduleName: CORE$1 };\n/* Instructions */\nIdentifiers$1.namespaceHTML = { name: 'namespaceHTML', moduleName: CORE$1 };\nIdentifiers$1.namespaceMathML = { name: 'namespaceMathML', moduleName: CORE$1 };\nIdentifiers$1.namespaceSVG = { name: 'namespaceSVG', moduleName: CORE$1 };\nIdentifiers$1.element = { name: 'element', moduleName: CORE$1 };\nIdentifiers$1.elementStart = { name: 'elementStart', moduleName: CORE$1 };\nIdentifiers$1.elementEnd = { name: 'elementEnd', moduleName: CORE$1 };\nIdentifiers$1.advance = { name: 'advance', moduleName: CORE$1 };\nIdentifiers$1.syntheticHostProperty = { name: 'syntheticHostProperty', moduleName: CORE$1 };\nIdentifiers$1.syntheticHostListener = { name: 'syntheticHostListener', moduleName: CORE$1 };\nIdentifiers$1.attribute = { name: 'attribute', moduleName: CORE$1 };\nIdentifiers$1.attributeInterpolate1 = { name: 'attributeInterpolate1', moduleName: CORE$1 };\nIdentifiers$1.attributeInterpolate2 = { name: 'attributeInterpolate2', moduleName: CORE$1 };\nIdentifiers$1.attributeInterpolate3 = { name: 'attributeInterpolate3', moduleName: CORE$1 };\nIdentifiers$1.attributeInterpolate4 = { name: 'attributeInterpolate4', moduleName: CORE$1 };\nIdentifiers$1.attributeInterpolate5 = { name: 'attributeInterpolate5', moduleName: CORE$1 };\nIdentifiers$1.attributeInterpolate6 = { name: 'attributeInterpolate6', moduleName: CORE$1 };\nIdentifiers$1.attributeInterpolate7 = { name: 'attributeInterpolate7', moduleName: CORE$1 };\nIdentifiers$1.attributeInterpolate8 = { name: 'attributeInterpolate8', moduleName: CORE$1 };\nIdentifiers$1.attributeInterpolateV = { name: 'attributeInterpolateV', moduleName: CORE$1 };\nIdentifiers$1.classProp = { name: 'classProp', moduleName: CORE$1 };\nIdentifiers$1.elementContainerStart = { name: 'elementContainerStart', moduleName: CORE$1 };\nIdentifiers$1.elementContainerEnd = { name: 'elementContainerEnd', moduleName: CORE$1 };\nIdentifiers$1.elementContainer = { name: 'elementContainer', moduleName: CORE$1 };\nIdentifiers$1.styleMap = { name: 'styleMap', moduleName: CORE$1 };\nIdentifiers$1.styleMapInterpolate1 = { name: 'styleMapInterpolate1', moduleName: CORE$1 };\nIdentifiers$1.styleMapInterpolate2 = { name: 'styleMapInterpolate2', moduleName: CORE$1 };\nIdentifiers$1.styleMapInterpolate3 = { name: 'styleMapInterpolate3', moduleName: CORE$1 };\nIdentifiers$1.styleMapInterpolate4 = { name: 'styleMapInterpolate4', moduleName: CORE$1 };\nIdentifiers$1.styleMapInterpolate5 = { name: 'styleMapInterpolate5', moduleName: CORE$1 };\nIdentifiers$1.styleMapInterpolate6 = { name: 'styleMapInterpolate6', moduleName: CORE$1 };\nIdentifiers$1.styleMapInterpolate7 = { name: 'styleMapInterpolate7', moduleName: CORE$1 };\nIdentifiers$1.styleMapInterpolate8 = { name: 'styleMapInterpolate8', moduleName: CORE$1 };\nIdentifiers$1.styleMapInterpolateV = { name: 'styleMapInterpolateV', moduleName: CORE$1 };\nIdentifiers$1.classMap = { name: 'classMap', moduleName: CORE$1 };\nIdentifiers$1.classMapInterpolate1 = { name: 'classMapInterpolate1', moduleName: CORE$1 };\nIdentifiers$1.classMapInterpolate2 = { name: 'classMapInterpolate2', moduleName: CORE$1 };\nIdentifiers$1.classMapInterpolate3 = { name: 'classMapInterpolate3', moduleName: CORE$1 };\nIdentifiers$1.classMapInterpolate4 = { name: 'classMapInterpolate4', moduleName: CORE$1 };\nIdentifiers$1.classMapInterpolate5 = { name: 'classMapInterpolate5', moduleName: CORE$1 };\nIdentifiers$1.classMapInterpolate6 = { name: 'classMapInterpolate6', moduleName: CORE$1 };\nIdentifiers$1.classMapInterpolate7 = { name: 'classMapInterpolate7', moduleName: CORE$1 };\nIdentifiers$1.classMapInterpolate8 = { name: 'classMapInterpolate8', moduleName: CORE$1 };\nIdentifiers$1.classMapInterpolateV = { name: 'classMapInterpolateV', moduleName: CORE$1 };\nIdentifiers$1.styleProp = { name: 'styleProp', moduleName: CORE$1 };\nIdentifiers$1.stylePropInterpolate1 = { name: 'stylePropInterpolate1', moduleName: CORE$1 };\nIdentifiers$1.stylePropInterpolate2 = { name: 'stylePropInterpolate2', moduleName: CORE$1 };\nIdentifiers$1.stylePropInterpolate3 = { name: 'stylePropInterpolate3', moduleName: CORE$1 };\nIdentifiers$1.stylePropInterpolate4 = { name: 'stylePropInterpolate4', moduleName: CORE$1 };\nIdentifiers$1.stylePropInterpolate5 = { name: 'stylePropInterpolate5', moduleName: CORE$1 };\nIdentifiers$1.stylePropInterpolate6 = { name: 'stylePropInterpolate6', moduleName: CORE$1 };\nIdentifiers$1.stylePropInterpolate7 = { name: 'stylePropInterpolate7', moduleName: CORE$1 };\nIdentifiers$1.stylePropInterpolate8 = { name: 'stylePropInterpolate8', moduleName: CORE$1 };\nIdentifiers$1.stylePropInterpolateV = { name: 'stylePropInterpolateV', moduleName: CORE$1 };\nIdentifiers$1.nextContext = { name: 'nextContext', moduleName: CORE$1 };\nIdentifiers$1.templateCreate = { name: 'template', moduleName: CORE$1 };\nIdentifiers$1.text = { name: 'text', moduleName: CORE$1 };\nIdentifiers$1.enableBindings = { name: 'enableBindings', moduleName: CORE$1 };\nIdentifiers$1.disableBindings = { name: 'disableBindings', moduleName: CORE$1 };\nIdentifiers$1.getCurrentView = { name: 'getCurrentView', moduleName: CORE$1 };\nIdentifiers$1.textInterpolate = { name: 'textInterpolate', moduleName: CORE$1 };\nIdentifiers$1.textInterpolate1 = { name: 'textInterpolate1', moduleName: CORE$1 };\nIdentifiers$1.textInterpolate2 = { name: 'textInterpolate2', moduleName: CORE$1 };\nIdentifiers$1.textInterpolate3 = { name: 'textInterpolate3', moduleName: CORE$1 };\nIdentifiers$1.textInterpolate4 = { name: 'textInterpolate4', moduleName: CORE$1 };\nIdentifiers$1.textInterpolate5 = { name: 'textInterpolate5', moduleName: CORE$1 };\nIdentifiers$1.textInterpolate6 = { name: 'textInterpolate6', moduleName: CORE$1 };\nIdentifiers$1.textInterpolate7 = { name: 'textInterpolate7', moduleName: CORE$1 };\nIdentifiers$1.textInterpolate8 = { name: 'textInterpolate8', moduleName: CORE$1 };\nIdentifiers$1.textInterpolateV = { name: 'textInterpolateV', moduleName: CORE$1 };\nIdentifiers$1.restoreView = { name: 'restoreView', moduleName: CORE$1 };\nIdentifiers$1.pureFunction0 = { name: 'pureFunction0', moduleName: CORE$1 };\nIdentifiers$1.pureFunction1 = { name: 'pureFunction1', moduleName: CORE$1 };\nIdentifiers$1.pureFunction2 = { name: 'pureFunction2', moduleName: CORE$1 };\nIdentifiers$1.pureFunction3 = { name: 'pureFunction3', moduleName: CORE$1 };\nIdentifiers$1.pureFunction4 = { name: 'pureFunction4', moduleName: CORE$1 };\nIdentifiers$1.pureFunction5 = { name: 'pureFunction5', moduleName: CORE$1 };\nIdentifiers$1.pureFunction6 = { name: 'pureFunction6', moduleName: CORE$1 };\nIdentifiers$1.pureFunction7 = { name: 'pureFunction7', moduleName: CORE$1 };\nIdentifiers$1.pureFunction8 = { name: 'pureFunction8', moduleName: CORE$1 };\nIdentifiers$1.pureFunctionV = { name: 'pureFunctionV', moduleName: CORE$1 };\nIdentifiers$1.pipeBind1 = { name: 'pipeBind1', moduleName: CORE$1 };\nIdentifiers$1.pipeBind2 = { name: 'pipeBind2', moduleName: CORE$1 };\nIdentifiers$1.pipeBind3 = { name: 'pipeBind3', moduleName: CORE$1 };\nIdentifiers$1.pipeBind4 = { name: 'pipeBind4', moduleName: CORE$1 };\nIdentifiers$1.pipeBindV = { name: 'pipeBindV', moduleName: CORE$1 };\nIdentifiers$1.hostProperty = { name: 'hostProperty', moduleName: CORE$1 };\nIdentifiers$1.property = { name: 'property', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolate = { name: 'propertyInterpolate', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolate1 = { name: 'propertyInterpolate1', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolate2 = { name: 'propertyInterpolate2', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolate3 = { name: 'propertyInterpolate3', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolate4 = { name: 'propertyInterpolate4', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolate5 = { name: 'propertyInterpolate5', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolate6 = { name: 'propertyInterpolate6', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolate7 = { name: 'propertyInterpolate7', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolate8 = { name: 'propertyInterpolate8', moduleName: CORE$1 };\nIdentifiers$1.propertyInterpolateV = { name: 'propertyInterpolateV', moduleName: CORE$1 };\nIdentifiers$1.i18n = { name: 'i18n', moduleName: CORE$1 };\nIdentifiers$1.i18nAttributes = { name: 'i18nAttributes', moduleName: CORE$1 };\nIdentifiers$1.i18nExp = { name: 'i18nExp', moduleName: CORE$1 };\nIdentifiers$1.i18nStart = { name: 'i18nStart', moduleName: CORE$1 };\nIdentifiers$1.i18nEnd = { name: 'i18nEnd', moduleName: CORE$1 };\nIdentifiers$1.i18nApply = { name: 'i18nApply', moduleName: CORE$1 };\nIdentifiers$1.i18nPostprocess = { name: 'i18nPostprocess', moduleName: CORE$1 };\nIdentifiers$1.pipe = { name: 'pipe', moduleName: CORE$1 };\nIdentifiers$1.projection = { name: 'projection', moduleName: CORE$1 };\nIdentifiers$1.projectionDef = { name: 'projectionDef', moduleName: CORE$1 };\nIdentifiers$1.reference = { name: 'reference', moduleName: CORE$1 };\nIdentifiers$1.inject = { name: 'inject', moduleName: CORE$1 };\nIdentifiers$1.injectAttribute = { name: 'injectAttribute', moduleName: CORE$1 };\nIdentifiers$1.directiveInject = { name: 'directiveInject', moduleName: CORE$1 };\nIdentifiers$1.invalidFactory = { name: 'invalidFactory', moduleName: CORE$1 };\nIdentifiers$1.invalidFactoryDep = { name: 'invalidFactoryDep', moduleName: CORE$1 };\nIdentifiers$1.templateRefExtractor = { name: 'templateRefExtractor', moduleName: CORE$1 };\nIdentifiers$1.forwardRef = { name: 'forwardRef', moduleName: CORE$1 };\nIdentifiers$1.resolveForwardRef = { name: 'resolveForwardRef', moduleName: CORE$1 };\nIdentifiers$1.defineInjectable = { name: 'defineInjectable', moduleName: CORE$1 };\nIdentifiers$1.declareInjectable = { name: 'ngDeclareInjectable', moduleName: CORE$1 };\nIdentifiers$1.InjectableDeclaration = { name: 'InjectableDeclaration', moduleName: CORE$1 };\nIdentifiers$1.resolveWindow = { name: 'resolveWindow', moduleName: CORE$1 };\nIdentifiers$1.resolveDocument = { name: 'resolveDocument', moduleName: CORE$1 };\nIdentifiers$1.resolveBody = { name: 'resolveBody', moduleName: CORE$1 };\nIdentifiers$1.defineComponent = { name: 'defineComponent', moduleName: CORE$1 };\nIdentifiers$1.declareComponent = { name: 'ngDeclareComponent', moduleName: CORE$1 };\nIdentifiers$1.setComponentScope = { name: 'setComponentScope', moduleName: CORE$1 };\nIdentifiers$1.ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE$1,\n};\nIdentifiers$1.ViewEncapsulation = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE$1,\n};\nIdentifiers$1.ComponentDeclaration = {\n    name: 'ComponentDeclaration',\n    moduleName: CORE$1,\n};\nIdentifiers$1.FactoryDeclaration = {\n    name: 'FactoryDeclaration',\n    moduleName: CORE$1,\n};\nIdentifiers$1.declareFactory = { name: 'ngDeclareFactory', moduleName: CORE$1 };\nIdentifiers$1.FactoryTarget = { name: 'FactoryTarget', moduleName: CORE$1 };\nIdentifiers$1.defineDirective = { name: 'defineDirective', moduleName: CORE$1 };\nIdentifiers$1.declareDirective = { name: 'ngDeclareDirective', moduleName: CORE$1 };\nIdentifiers$1.DirectiveDeclaration = {\n    name: 'DirectiveDeclaration',\n    moduleName: CORE$1,\n};\nIdentifiers$1.InjectorDef = { name: 'InjectorDef', moduleName: CORE$1 };\nIdentifiers$1.InjectorDeclaration = { name: 'InjectorDeclaration', moduleName: CORE$1 };\nIdentifiers$1.defineInjector = { name: 'defineInjector', moduleName: CORE$1 };\nIdentifiers$1.declareInjector = { name: 'ngDeclareInjector', moduleName: CORE$1 };\nIdentifiers$1.NgModuleDeclaration = {\n    name: 'NgModuleDeclaration',\n    moduleName: CORE$1,\n};\nIdentifiers$1.ModuleWithProviders = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE$1,\n};\nIdentifiers$1.defineNgModule = { name: 'defineNgModule', moduleName: CORE$1 };\nIdentifiers$1.declareNgModule = { name: 'ngDeclareNgModule', moduleName: CORE$1 };\nIdentifiers$1.setNgModuleScope = { name: 'setNgModuleScope', moduleName: CORE$1 };\nIdentifiers$1.PipeDeclaration = { name: 'PipeDeclaration', moduleName: CORE$1 };\nIdentifiers$1.definePipe = { name: 'definePipe', moduleName: CORE$1 };\nIdentifiers$1.declarePipe = { name: 'ngDeclarePipe', moduleName: CORE$1 };\nIdentifiers$1.declareClassMetadata = { name: 'ngDeclareClassMetadata', moduleName: CORE$1 };\nIdentifiers$1.setClassMetadata = { name: 'setClassMetadata', moduleName: CORE$1 };\nIdentifiers$1.queryRefresh = { name: 'queryRefresh', moduleName: CORE$1 };\nIdentifiers$1.viewQuery = { name: 'viewQuery', moduleName: CORE$1 };\nIdentifiers$1.loadQuery = { name: 'loadQuery', moduleName: CORE$1 };\nIdentifiers$1.contentQuery = { name: 'contentQuery', moduleName: CORE$1 };\nIdentifiers$1.NgOnChangesFeature = { name: 'NgOnChangesFeature', moduleName: CORE$1 };\nIdentifiers$1.InheritDefinitionFeature = { name: 'InheritDefinitionFeature', moduleName: CORE$1 };\nIdentifiers$1.CopyDefinitionFeature = { name: 'CopyDefinitionFeature', moduleName: CORE$1 };\nIdentifiers$1.ProvidersFeature = { name: 'ProvidersFeature', moduleName: CORE$1 };\nIdentifiers$1.listener = { name: 'listener', moduleName: CORE$1 };\nIdentifiers$1.getInheritedFactory = {\n    name: 'getInheritedFactory',\n    moduleName: CORE$1,\n};\n// sanitization-related functions\nIdentifiers$1.sanitizeHtml = { name: 'sanitizeHtml', moduleName: CORE$1 };\nIdentifiers$1.sanitizeStyle = { name: 'sanitizeStyle', moduleName: CORE$1 };\nIdentifiers$1.sanitizeResourceUrl = { name: 'sanitizeResourceUrl', moduleName: CORE$1 };\nIdentifiers$1.sanitizeScript = { name: 'sanitizeScript', moduleName: CORE$1 };\nIdentifiers$1.sanitizeUrl = { name: 'sanitizeUrl', moduleName: CORE$1 };\nIdentifiers$1.sanitizeUrlOrResourceUrl = { name: 'sanitizeUrlOrResourceUrl', moduleName: CORE$1 };\nIdentifiers$1.trustConstantHtml = { name: 'trustConstantHtml', moduleName: CORE$1 };\nIdentifiers$1.trustConstantResourceUrl = { name: 'trustConstantResourceUrl', moduleName: CORE$1 };\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION$1 = 3;\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nclass SourceMapGenerator {\n    constructor(file = null) {\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    // The content is `null` when the content is expected to be loaded using the URL\n    addSource(url, content = null) {\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    }\n    addLine() {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    }\n    addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(`A line must be added before mappings can be added`);\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(`Unknown source file \"${sourceUrl}\"`);\n        }\n        if (col0 == null) {\n            throw new Error(`The column in the generated code must be provided`);\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(`Mapping should be added in output order`);\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(`The source location must be provided when a source url is provided`);\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });\n        return this;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get currentLine() {\n        return this.lines.slice(-1)[0];\n    }\n    toJSON() {\n        if (!this.hasMappings) {\n            return null;\n        }\n        const sourcesIndex = new Map();\n        const sources = [];\n        const sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach((url, i) => {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(this.sourcesContent.get(url) || null);\n        });\n        let mappings = '';\n        let lastCol0 = 0;\n        let lastSourceIndex = 0;\n        let lastSourceLine0 = 0;\n        let lastSourceCol0 = 0;\n        this.lines.forEach(segments => {\n            lastCol0 = 0;\n            mappings += segments\n                .map(segment => {\n                // zero-based starting column of the line in the generated code\n                let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the sources list\n                    segAsStr +=\n                        toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n                    lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n                    lastSourceLine0 = segment.sourceLine0;\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n                    lastSourceCol0 = segment.sourceCol0;\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION$1,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    }\n    toJsComment() {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    }\n}\nfunction toBase64String(value) {\n    let b64 = '';\n    const encoded = utf8Encode(value);\n    for (let i = 0; i < encoded.length;) {\n        const i1 = encoded[i++];\n        const i2 = i < encoded.length ? encoded[i++] : null;\n        const i3 = i < encoded.length ? encoded[i++] : null;\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n        b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n        b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    let out = '';\n    do {\n        let digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(`Can only encode value in the range [0, 63]`);\n    }\n    return B64_DIGITS[value];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nclass _EmittedLine {\n    constructor(indent) {\n        this.indent = indent;\n        this.partsLength = 0;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n}\nclass EmitterVisitorContext {\n    constructor(_indent) {\n        this._indent = _indent;\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    static createRoot() {\n        return new EmitterVisitorContext(0);\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get _currentLine() {\n        return this._lines[this._lines.length - 1];\n    }\n    println(from, lastPart = '') {\n        this.print(from || null, lastPart, true);\n    }\n    lineIsEmpty() {\n        return this._currentLine.parts.length === 0;\n    }\n    lineLength() {\n        return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    }\n    print(from, part, newLine = false) {\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.partsLength += part.length;\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    }\n    removeEmptyLastLine() {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    }\n    incIndent() {\n        this._indent++;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    }\n    decIndent() {\n        this._indent--;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    }\n    toSource() {\n        return this.sourceLines\n            .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n            .join('\\n');\n    }\n    toSourceMapGenerator(genFilePath, startsAtLine = 0) {\n        const map = new SourceMapGenerator(genFilePath);\n        let firstOffsetMapped = false;\n        const mapFirstOffsetIfNeeded = () => {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (let i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach((line, lineIdx) => {\n            map.addLine();\n            const spans = line.srcSpans;\n            const parts = line.parts;\n            let col0 = line.indent * _INDENT_WITH.length;\n            let spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                const span = spans[spanIdx];\n                const source = span.start.file;\n                const sourceLine = span.start.line;\n                const sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    }\n    spanOf(line, column) {\n        const emittedLine = this._lines[line];\n        if (emittedLine) {\n            let columnsLeft = column - _createIndent(emittedLine.indent).length;\n            for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n                const part = emittedLine.parts[partIndex];\n                if (part.length > columnsLeft) {\n                    return emittedLine.srcSpans[partIndex];\n                }\n                columnsLeft -= part.length;\n            }\n        }\n        return null;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get sourceLines() {\n        if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n            return this._lines.slice(0, -1);\n        }\n        return this._lines;\n    }\n}\nclass AbstractEmitterVisitor {\n    constructor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    printLeadingComments(stmt, ctx) {\n        if (stmt.leadingComments === undefined) {\n            return;\n        }\n        for (const comment of stmt.leadingComments) {\n            if (comment instanceof JSDocComment) {\n                ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n            }\n            else {\n                if (comment.multiline) {\n                    ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n                }\n                else {\n                    comment.text.split('\\n').forEach((line) => {\n                        ctx.println(stmt, `// ${line}`);\n                    });\n                }\n            }\n        }\n    }\n    visitExpressionStmt(stmt, ctx) {\n        this.printLeadingComments(stmt, ctx);\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    }\n    visitReturnStmt(stmt, ctx) {\n        this.printLeadingComments(stmt, ctx);\n        ctx.print(stmt, `return `);\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    }\n    visitIfStmt(stmt, ctx) {\n        this.printLeadingComments(stmt, ctx);\n        ctx.print(stmt, `if (`);\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, `) {`);\n        const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, ` `);\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, ` `);\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, `} else {`);\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    visitWriteVarExpr(expr, ctx) {\n        const lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, `${expr.name} = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    visitWriteKeyExpr(expr, ctx) {\n        const lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, `[`);\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, `] = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    visitWritePropExpr(expr, ctx) {\n        const lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, `.${expr.name} = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    visitInvokeFunctionExpr(expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, `(`);\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, `)`);\n        return null;\n    }\n    visitTaggedTemplateExpr(expr, ctx) {\n        expr.tag.visitExpression(this, ctx);\n        ctx.print(expr, '`' + expr.template.elements[0].rawText);\n        for (let i = 1; i < expr.template.elements.length; i++) {\n            ctx.print(expr, '${');\n            expr.template.expressions[i - 1].visitExpression(this, ctx);\n            ctx.print(expr, `}${expr.template.elements[i].rawText}`);\n        }\n        ctx.print(expr, '`');\n        return null;\n    }\n    visitWrappedNodeExpr(ast, ctx) {\n        throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n    }\n    visitTypeofExpr(expr, ctx) {\n        ctx.print(expr, 'typeof ');\n        expr.expr.visitExpression(this, ctx);\n    }\n    visitReadVarExpr(ast, ctx) {\n        ctx.print(ast, ast.name);\n        return null;\n    }\n    visitInstantiateExpr(ast, ctx) {\n        ctx.print(ast, `new `);\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, `(`);\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, `)`);\n        return null;\n    }\n    visitLiteralExpr(ast, ctx) {\n        const value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, `${value}`);\n        }\n        return null;\n    }\n    visitLocalizedString(ast, ctx) {\n        const head = ast.serializeI18nHead();\n        ctx.print(ast, '$localize `' + head.raw);\n        for (let i = 1; i < ast.messageParts.length; i++) {\n            ctx.print(ast, '${');\n            ast.expressions[i - 1].visitExpression(this, ctx);\n            ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n        }\n        ctx.print(ast, '`');\n        return null;\n    }\n    visitConditionalExpr(ast, ctx) {\n        ctx.print(ast, `(`);\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': ');\n        ast.falseCase.visitExpression(this, ctx);\n        ctx.print(ast, `)`);\n        return null;\n    }\n    visitNotExpr(ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    }\n    visitUnaryOperatorExpr(ast, ctx) {\n        let opStr;\n        switch (ast.operator) {\n            case UnaryOperator.Plus:\n                opStr = '+';\n                break;\n            case UnaryOperator.Minus:\n                opStr = '-';\n                break;\n            default:\n                throw new Error(`Unknown operator ${ast.operator}`);\n        }\n        if (ast.parens)\n            ctx.print(ast, `(`);\n        ctx.print(ast, opStr);\n        ast.expr.visitExpression(this, ctx);\n        if (ast.parens)\n            ctx.print(ast, `)`);\n        return null;\n    }\n    visitBinaryOperatorExpr(ast, ctx) {\n        let opStr;\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case BinaryOperator.BitwiseAnd:\n                opStr = '&';\n                break;\n            case BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            case BinaryOperator.NullishCoalesce:\n                opStr = '??';\n                break;\n            default:\n                throw new Error(`Unknown operator ${ast.operator}`);\n        }\n        if (ast.parens)\n            ctx.print(ast, `(`);\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, ` ${opStr} `);\n        ast.rhs.visitExpression(this, ctx);\n        if (ast.parens)\n            ctx.print(ast, `)`);\n        return null;\n    }\n    visitReadPropExpr(ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, `.`);\n        ctx.print(ast, ast.name);\n        return null;\n    }\n    visitReadKeyExpr(ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, `[`);\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, `]`);\n        return null;\n    }\n    visitLiteralArrayExpr(ast, ctx) {\n        ctx.print(ast, `[`);\n        this.visitAllExpressions(ast.entries, ctx, ',');\n        ctx.print(ast, `]`);\n        return null;\n    }\n    visitLiteralMapExpr(ast, ctx) {\n        ctx.print(ast, `{`);\n        this.visitAllObjects(entry => {\n            ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n            entry.value.visitExpression(this, ctx);\n        }, ast.entries, ctx, ',');\n        ctx.print(ast, `}`);\n        return null;\n    }\n    visitCommaExpr(ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    }\n    visitAllExpressions(expressions, ctx, separator) {\n        this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n    }\n    visitAllObjects(handler, expressions, ctx, separator) {\n        let incrementedIndent = false;\n        for (let i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                if (ctx.lineLength() > 80) {\n                    ctx.print(null, separator, true);\n                    if (!incrementedIndent) {\n                        // continuation are marked with double indent.\n                        ctx.incIndent();\n                        ctx.incIndent();\n                        incrementedIndent = true;\n                    }\n                }\n                else {\n                    ctx.print(null, separator, false);\n                }\n            }\n            handler(expressions[i]);\n        }\n        if (incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.decIndent();\n            ctx.decIndent();\n        }\n    }\n    visitAllStatements(statements, ctx) {\n        statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n    }\n}\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote = true) {\n    if (input == null) {\n        return null;\n    }\n    const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return `\\\\${match[0]}`;\n        }\n    });\n    const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? `'${body}'` : body;\n}\nfunction _createIndent(count) {\n    let res = '';\n    for (let i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction typeWithParameters(type, numParams) {\n    if (numParams === 0) {\n        return expressionType(type);\n    }\n    const params = [];\n    for (let i = 0; i < numParams; i++) {\n        params.push(DYNAMIC_TYPE);\n    }\n    return expressionType(type, undefined, params);\n}\nconst ANIMATE_SYMBOL_PREFIX = '@';\nfunction prepareSyntheticPropertyName(name) {\n    return `${ANIMATE_SYMBOL_PREFIX}${name}`;\n}\nfunction prepareSyntheticListenerName(name, phase) {\n    return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\nfunction getSafePropertyAccessString(accessor, name) {\n    const escapedName = escapeIdentifier(name, false, false);\n    return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\nfunction prepareSyntheticListenerFunctionName(name, phase) {\n    return `animation_${name}_${phase}`;\n}\nfunction jitOnlyGuardedExpression(expr) {\n    return guardedExpression('ngJitMode', expr);\n}\nfunction devOnlyGuardedExpression(expr) {\n    return guardedExpression('ngDevMode', expr);\n}\nfunction guardedExpression(guard, expr) {\n    const guardExpr = new ExternalExpr({ name: guard, moduleName: null });\n    const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));\n    const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined, \n    /* sourceSpan */ undefined, true);\n    return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\nfunction wrapReference(value) {\n    const wrapped = new WrappedNodeExpr(value);\n    return { value: wrapped, type: wrapped };\n}\nfunction refsToArray(refs, shouldForwardDeclare) {\n    const values = literalArr(refs.map(ref => ref.value));\n    return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;\n}\nfunction createMayBeForwardRefExpression(expression, forwardRef) {\n    return { expression, forwardRef };\n}\n/**\n * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n * `forwardRef()` call.\n *\n * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression\n * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated\n * in the code.\n *\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n */\nfunction convertFromMaybeForwardRefExpression({ expression, forwardRef }) {\n    switch (forwardRef) {\n        case 0 /* None */:\n        case 1 /* Wrapped */:\n            return expression;\n        case 2 /* Unwrapped */:\n            return generateForwardRef(expression);\n    }\n}\n/**\n * Generate an expression that has the given `expr` wrapped in the following form:\n *\n * ```\n * forwardRef(() => expr)\n * ```\n */\nfunction generateForwardRef(expr) {\n    return importExpr(Identifiers$1.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);\n}\n\nvar R3FactoryDelegateType;\n(function (R3FactoryDelegateType) {\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\nvar FactoryTarget$1;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget$1 || (FactoryTarget$1 = {}));\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nfunction compileFactoryFunction(meta) {\n    const t = variable('t');\n    let baseFactoryVar = null;\n    // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n    // this type is always created by constructor invocation, then this is the type-to-create\n    // parameter provided by the user (t) if specified, or the current type if not. If there is a\n    // delegated factory (which is used to create the current type) then this is only the type-to-\n    // create parameter (t).\n    const typeForCtor = !isDelegatedFactoryMetadata(meta) ?\n        new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) :\n        t;\n    let ctorExpr = null;\n    if (meta.deps !== null) {\n        // There is a constructor (either explicitly or implicitly defined).\n        if (meta.deps !== 'invalid') {\n            ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n        }\n    }\n    else {\n        // There is no constructor, use the base class' factory to construct typeForCtor.\n        baseFactoryVar = variable(`${meta.name}_BaseFactory`);\n        ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n    }\n    const body = [];\n    let retExpr = null;\n    function makeConditionalFactory(nonCtorExpr) {\n        const r = variable('r');\n        body.push(r.set(NULL_EXPR).toDeclStmt());\n        const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :\n            importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt();\n        body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n        return r;\n    }\n    if (isDelegatedFactoryMetadata(meta)) {\n        // This type is created with a delegated factory. If a type parameter is not specified, call\n        // the factory instead.\n        const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n        // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n        const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?\n            InstantiateExpr :\n            InvokeFunctionExpr)(meta.delegate, delegateArgs);\n        retExpr = makeConditionalFactory(factoryExpr);\n    }\n    else if (isExpressionFactoryMetadata(meta)) {\n        // TODO(alxhub): decide whether to lower the value here or in the caller\n        retExpr = makeConditionalFactory(meta.expression);\n    }\n    else {\n        retExpr = ctorExpr;\n    }\n    if (retExpr === null) {\n        // The expression cannot be formed so render an `invalidFactory()` call.\n        body.push(importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt());\n    }\n    else if (baseFactoryVar !== null) {\n        // This factory uses a base factory, so call `getInheritedFactory()` to compute it.\n        const getInheritedFactoryCall = importExpr(Identifiers$1.getInheritedFactory).callFn([meta.internalType]);\n        // Memoize the base factoryFn: `baseFactory || (baseFactory = getInheritedFactory(...))`\n        const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n        body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));\n    }\n    else {\n        // This is straightforward factory, just return it.\n        body.push(new ReturnStatement(retExpr));\n    }\n    let factoryFn = fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`);\n    if (baseFactoryVar !== null) {\n        // There is a base factory variable so wrap its declaration along with the factory function into\n        // an IIFE.\n        factoryFn = fn([], [\n            new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)\n        ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);\n    }\n    return {\n        expression: factoryFn,\n        statements: [],\n        type: createFactoryType(meta),\n    };\n}\nfunction createFactoryType(meta) {\n    const ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;\n    return expressionType(importExpr(Identifiers$1.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\nfunction injectDependencies(deps, target) {\n    return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\nfunction compileInjectDependency(dep, target, index) {\n    // Interpret the dependency according to its resolved type.\n    if (dep.token === null) {\n        return importExpr(Identifiers$1.invalidFactoryDep).callFn([literal(index)]);\n    }\n    else if (dep.attributeNameType === null) {\n        // Build up the injection flags according to the metadata.\n        const flags = 0 /* Default */ | (dep.self ? 2 /* Self */ : 0) |\n            (dep.skipSelf ? 4 /* SkipSelf */ : 0) | (dep.host ? 1 /* Host */ : 0) |\n            (dep.optional ? 8 /* Optional */ : 0) |\n            (target === FactoryTarget$1.Pipe ? 16 /* ForPipe */ : 0);\n        // If this dependency is optional or otherwise has non-default flags, then additional\n        // parameters describing how to inject the dependency must be passed to the inject function\n        // that's being used.\n        let flagsParam = (flags !== 0 /* Default */ || dep.optional) ? literal(flags) : null;\n        // Build up the arguments to the injectFn call.\n        const injectArgs = [dep.token];\n        if (flagsParam) {\n            injectArgs.push(flagsParam);\n        }\n        const injectFn = getInjectFn(target);\n        return importExpr(injectFn).callFn(injectArgs);\n    }\n    else {\n        // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n        // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n        // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n        // we want to generate `injectAttribute(foo())`.\n        //\n        // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n        // typings.\n        return importExpr(Identifiers$1.injectAttribute).callFn([dep.token]);\n    }\n}\nfunction createCtorDepsType(deps) {\n    let hasTypes = false;\n    const attributeTypes = deps.map(dep => {\n        const type = createCtorDepType(dep);\n        if (type !== null) {\n            hasTypes = true;\n            return type;\n        }\n        else {\n            return literal(null);\n        }\n    });\n    if (hasTypes) {\n        return expressionType(literalArr(attributeTypes));\n    }\n    else {\n        return NONE_TYPE;\n    }\n}\nfunction createCtorDepType(dep) {\n    const entries = [];\n    if (dep.attributeNameType !== null) {\n        entries.push({ key: 'attribute', value: dep.attributeNameType, quoted: false });\n    }\n    if (dep.optional) {\n        entries.push({ key: 'optional', value: literal(true), quoted: false });\n    }\n    if (dep.host) {\n        entries.push({ key: 'host', value: literal(true), quoted: false });\n    }\n    if (dep.self) {\n        entries.push({ key: 'self', value: literal(true), quoted: false });\n    }\n    if (dep.skipSelf) {\n        entries.push({ key: 'skipSelf', value: literal(true), quoted: false });\n    }\n    return entries.length > 0 ? literalMap(entries) : null;\n}\nfunction isDelegatedFactoryMetadata(meta) {\n    return meta.delegateType !== undefined;\n}\nfunction isExpressionFactoryMetadata(meta) {\n    return meta.expression !== undefined;\n}\nfunction getInjectFn(target) {\n    switch (target) {\n        case FactoryTarget$1.Component:\n        case FactoryTarget$1.Directive:\n        case FactoryTarget$1.Pipe:\n            return Identifiers$1.directiveInject;\n        case FactoryTarget$1.NgModule:\n        case FactoryTarget$1.Injectable:\n        default:\n            return Identifiers$1.inject;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\n * require the implementation of a visitor for Comments as they are only collected at\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\n * is true.\n */\nclass Comment$1 {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(_visitor) {\n        throw new Error('visit() not implemented for Comment');\n    }\n}\nclass Text$3 {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor) {\n        return visitor.visitText(this);\n    }\n}\nclass BoundText {\n    constructor(value, sourceSpan, i18n) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitBoundText(this);\n    }\n}\n/**\n * Represents a text attribute in the template.\n *\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\n */\nclass TextAttribute {\n    constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitTextAttribute(this);\n    }\n}\nclass BoundAttribute {\n    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    static fromBoundElementProperty(prop, i18n) {\n        if (prop.keySpan === undefined) {\n            throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);\n        }\n        return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);\n    }\n    visit(visitor) {\n        return visitor.visitBoundAttribute(this);\n    }\n}\nclass BoundEvent {\n    constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {\n        this.name = name;\n        this.type = type;\n        this.handler = handler;\n        this.target = target;\n        this.phase = phase;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n        this.keySpan = keySpan;\n    }\n    static fromParsedEvent(event) {\n        const target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;\n        const phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;\n        if (event.keySpan === undefined) {\n            throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);\n        }\n        return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);\n    }\n    visit(visitor) {\n        return visitor.visitBoundEvent(this);\n    }\n}\nclass Element$1 {\n    constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.name = name;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.children = children;\n        this.references = references;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitElement(this);\n    }\n}\nclass Template {\n    constructor(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.tagName = tagName;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.templateAttrs = templateAttrs;\n        this.children = children;\n        this.references = references;\n        this.variables = variables;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitTemplate(this);\n    }\n}\nclass Content {\n    constructor(selector, attributes, sourceSpan, i18n) {\n        this.selector = selector;\n        this.attributes = attributes;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n        this.name = 'ng-content';\n    }\n    visit(visitor) {\n        return visitor.visitContent(this);\n    }\n}\nclass Variable {\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n    visit(visitor) {\n        return visitor.visitVariable(this);\n    }\n}\nclass Reference {\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n    visit(visitor) {\n        return visitor.visitReference(this);\n    }\n}\nclass Icu$1 {\n    constructor(vars, placeholders, sourceSpan, i18n) {\n        this.vars = vars;\n        this.placeholders = placeholders;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitIcu(this);\n    }\n}\nclass NullVisitor {\n    visitElement(element) { }\n    visitTemplate(template) { }\n    visitContent(content) { }\n    visitVariable(variable) { }\n    visitReference(reference) { }\n    visitTextAttribute(attribute) { }\n    visitBoundAttribute(attribute) { }\n    visitBoundEvent(attribute) { }\n    visitText(text) { }\n    visitBoundText(text) { }\n    visitIcu(icu) { }\n}\nclass RecursiveVisitor$1 {\n    visitElement(element) {\n        visitAll$1(this, element.attributes);\n        visitAll$1(this, element.inputs);\n        visitAll$1(this, element.outputs);\n        visitAll$1(this, element.children);\n        visitAll$1(this, element.references);\n    }\n    visitTemplate(template) {\n        visitAll$1(this, template.attributes);\n        visitAll$1(this, template.inputs);\n        visitAll$1(this, template.outputs);\n        visitAll$1(this, template.children);\n        visitAll$1(this, template.references);\n        visitAll$1(this, template.variables);\n    }\n    visitContent(content) { }\n    visitVariable(variable) { }\n    visitReference(reference) { }\n    visitTextAttribute(attribute) { }\n    visitBoundAttribute(attribute) { }\n    visitBoundEvent(attribute) { }\n    visitText(text) { }\n    visitBoundText(text) { }\n    visitIcu(icu) { }\n}\nclass TransformVisitor {\n    visitElement(element) {\n        const newAttributes = transformAll(this, element.attributes);\n        const newInputs = transformAll(this, element.inputs);\n        const newOutputs = transformAll(this, element.outputs);\n        const newChildren = transformAll(this, element.children);\n        const newReferences = transformAll(this, element.references);\n        if (newAttributes != element.attributes || newInputs != element.inputs ||\n            newOutputs != element.outputs || newChildren != element.children ||\n            newReferences != element.references) {\n            return new Element$1(element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n        }\n        return element;\n    }\n    visitTemplate(template) {\n        const newAttributes = transformAll(this, template.attributes);\n        const newInputs = transformAll(this, template.inputs);\n        const newOutputs = transformAll(this, template.outputs);\n        const newTemplateAttrs = transformAll(this, template.templateAttrs);\n        const newChildren = transformAll(this, template.children);\n        const newReferences = transformAll(this, template.references);\n        const newVariables = transformAll(this, template.variables);\n        if (newAttributes != template.attributes || newInputs != template.inputs ||\n            newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs ||\n            newChildren != template.children || newReferences != template.references ||\n            newVariables != template.variables) {\n            return new Template(template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren, newReferences, newVariables, template.sourceSpan, template.startSourceSpan, template.endSourceSpan);\n        }\n        return template;\n    }\n    visitContent(content) {\n        return content;\n    }\n    visitVariable(variable) {\n        return variable;\n    }\n    visitReference(reference) {\n        return reference;\n    }\n    visitTextAttribute(attribute) {\n        return attribute;\n    }\n    visitBoundAttribute(attribute) {\n        return attribute;\n    }\n    visitBoundEvent(attribute) {\n        return attribute;\n    }\n    visitText(text) {\n        return text;\n    }\n    visitBoundText(text) {\n        return text;\n    }\n    visitIcu(icu) {\n        return icu;\n    }\n}\nfunction visitAll$1(visitor, nodes) {\n    const result = [];\n    if (visitor.visit) {\n        for (const node of nodes) {\n            const newNode = visitor.visit(node) || node.visit(visitor);\n        }\n    }\n    else {\n        for (const node of nodes) {\n            const newNode = node.visit(visitor);\n            if (newNode) {\n                result.push(newNode);\n            }\n        }\n    }\n    return result;\n}\nfunction transformAll(visitor, nodes) {\n    const result = [];\n    let changed = false;\n    for (const node of nodes) {\n        const newNode = node.visit(visitor);\n        if (newNode) {\n            result.push(newNode);\n        }\n        changed = changed || newNode != node;\n    }\n    return changed ? result : nodes;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass Message {\n    /**\n     * @param nodes message AST\n     * @param placeholders maps placeholder names to static content and their source spans\n     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param meaning\n     * @param description\n     * @param customId\n     */\n    constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.customId = customId;\n        this.id = this.customId;\n        /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n        this.legacyIds = [];\n        this.messageString = serializeMessage(this.nodes);\n        if (nodes.length) {\n            this.sources = [{\n                    filePath: nodes[0].sourceSpan.start.file.url,\n                    startLine: nodes[0].sourceSpan.start.line + 1,\n                    startCol: nodes[0].sourceSpan.start.col + 1,\n                    endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n                    endCol: nodes[0].sourceSpan.start.col + 1\n                }];\n        }\n        else {\n            this.sources = [];\n        }\n    }\n}\nclass Text$2 {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitText(this, context);\n    }\n}\n// TODO(vicb): do we really need this node (vs an array) ?\nclass Container {\n    constructor(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitContainer(this, context);\n    }\n}\nclass Icu {\n    constructor(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitIcu(this, context);\n    }\n}\nclass TagPlaceholder {\n    constructor(tag, attrs, startName, closeName, children, isVoid, \n    // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n    sourceSpan, startSourceSpan, endSourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitTagPlaceholder(this, context);\n    }\n}\nclass Placeholder {\n    constructor(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitPlaceholder(this, context);\n    }\n}\nclass IcuPlaceholder {\n    constructor(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitIcuPlaceholder(this, context);\n    }\n}\n// Clone the AST\nclass CloneVisitor {\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitContainer(container, context) {\n        const children = container.children.map(n => n.visit(this, context));\n        return new Container(children, container.sourceSpan);\n    }\n    visitIcu(icu, context) {\n        const cases = {};\n        Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n        const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    }\n    visitTagPlaceholder(ph, context) {\n        const children = ph.children.map(n => n.visit(this, context));\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n    }\n    visitPlaceholder(ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    }\n    visitIcuPlaceholder(ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    }\n}\n// Visit all the nodes recursively\nclass RecurseVisitor {\n    visitText(text, context) { }\n    visitContainer(container, context) {\n        container.children.forEach(child => child.visit(this));\n    }\n    visitIcu(icu, context) {\n        Object.keys(icu.cases).forEach(k => {\n            icu.cases[k].visit(this);\n        });\n    }\n    visitTagPlaceholder(ph, context) {\n        ph.children.forEach(child => child.visit(this));\n    }\n    visitPlaceholder(ph, context) { }\n    visitIcuPlaceholder(ph, context) { }\n}\n/**\n * Serialize the message to the Localize backtick string format that would appear in compiled code.\n */\nfunction serializeMessage(messageNodes) {\n    const visitor = new LocalizeMessageStringVisitor();\n    const str = messageNodes.map(n => n.visit(visitor)).join('');\n    return str;\n}\nclass LocalizeMessageStringVisitor {\n    visitText(text) {\n        return text.value;\n    }\n    visitContainer(container) {\n        return container.children.map(child => child.visit(this)).join('');\n    }\n    visitIcu(icu) {\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n    }\n    visitTagPlaceholder(ph) {\n        const children = ph.children.map(child => child.visit(this)).join('');\n        return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n    }\n    visitPlaceholder(ph) {\n        return `{$${ph.name}}`;\n    }\n    visitIcuPlaceholder(ph) {\n        return `{$${ph.name}}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass Serializer {\n    // Creates a name mapper, see `PlaceholderMapper`\n    // Returning `null` means that no name mapping is used.\n    createNameMapper(message) {\n        return null;\n    }\n}\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nclass SimplePlaceholderMapper extends RecurseVisitor {\n    // create a mapping from the message\n    constructor(message, mapName) {\n        super();\n        this.mapName = mapName;\n        this.internalToPublic = {};\n        this.publicToNextId = {};\n        this.publicToInternal = {};\n        message.nodes.forEach(node => node.visit(this));\n    }\n    toPublicName(internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    }\n    toInternalName(publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    }\n    visitText(text, context) {\n        return null;\n    }\n    visitTagPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        super.visitTagPlaceholder(ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    }\n    visitPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.name);\n    }\n    visitIcuPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.name);\n    }\n    // XMB placeholders could only contains A-Z, 0-9 and _\n    visitPlaceholderName(internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        let publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            const nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = `${publicName}_${nextId}`;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass _Visitor$2 {\n    visitTag(tag) {\n        const strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return `<${tag.name}${strAttrs}/>`;\n        }\n        const strChildren = tag.children.map(node => node.visit(this));\n        return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n    }\n    visitText(text) {\n        return text.value;\n    }\n    visitDeclaration(decl) {\n        return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n    }\n    _serializeAttributes(attrs) {\n        const strAttrs = Object.keys(attrs).map((name) => `${name}=\"${attrs[name]}\"`).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    }\n    visitDoctype(doctype) {\n        return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n    }\n}\nconst _visitor = new _Visitor$2();\nfunction serialize(nodes) {\n    return nodes.map((node) => node.visit(_visitor)).join('');\n}\nclass Declaration {\n    constructor(unescapedAttrs) {\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach((k) => {\n            this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    visit(visitor) {\n        return visitor.visitDeclaration(this);\n    }\n}\nclass Doctype {\n    constructor(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    visit(visitor) {\n        return visitor.visitDoctype(this);\n    }\n}\nclass Tag {\n    constructor(name, unescapedAttrs = {}, children = []) {\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach((k) => {\n            this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    visit(visitor) {\n        return visitor.visitTag(this);\n    }\n}\nclass Text$1 {\n    constructor(unescapedValue) {\n        this.value = escapeXml(unescapedValue);\n    }\n    visit(visitor) {\n        return visitor.visitText(this);\n    }\n}\nclass CR extends Text$1 {\n    constructor(ws = 0) {\n        super(`\\n${new Array(ws + 1).join(' ')}`);\n    }\n}\nconst _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nfunction escapeXml(text) {\n    return _ESCAPED_CHARS.reduce((text, entry) => text.replace(entry[0], entry[1]), text);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG$3 = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG$2 = 'source';\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\nclass Xmb extends Serializer {\n    write(messages, locale) {\n        const exampleVisitor = new ExampleVisitor();\n        const visitor = new _Visitor$1();\n        let rootNode = new Tag(_MESSAGES_TAG);\n        messages.forEach(message => {\n            const attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            let sourceTags = [];\n            message.sources.forEach((source) => {\n                sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n            });\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n        });\n        rootNode.children.push(new CR());\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new CR(),\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new CR(),\n        ]);\n    }\n    load(content, url) {\n        throw new Error('Unsupported');\n    }\n    digest(message) {\n        return digest(message);\n    }\n    createNameMapper(message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    }\n}\nclass _Visitor$1 {\n    visitText(text, context) {\n        return [new Text$1(text.value)];\n    }\n    visitContainer(container, context) {\n        const nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    visitIcu(icu, context) {\n        const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n        });\n        nodes.push(new Text$1(`}`));\n        return nodes;\n    }\n    visitTagPlaceholder(ph, context) {\n        const startTagAsText = new Text$1(`<${ph.tag}>`);\n        const startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        const startTagPh = new Tag(_PLACEHOLDER_TAG$3, { name: ph.startName }, [startEx, startTagAsText]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        const closeTagAsText = new Text$1(`</${ph.tag}>`);\n        const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        const closeTagPh = new Tag(_PLACEHOLDER_TAG$3, { name: ph.closeName }, [closeEx, closeTagAsText]);\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n    }\n    visitPlaceholder(ph, context) {\n        const interpolationAsText = new Text$1(`{{${ph.value}}}`);\n        // Example tag needs to be not-empty for TC.\n        const exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG$3, { name: ph.name }, [exTag, interpolationAsText])\n        ];\n    }\n    visitIcuPlaceholder(ph, context) {\n        const icuExpression = ph.value.expression;\n        const icuType = ph.value.type;\n        const icuCases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');\n        const icuAsText = new Text$1(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n        const exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG$3, { name: ph.name }, [exTag, icuAsText])\n        ];\n    }\n    serialize(nodes) {\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\nfunction digest(message) {\n    return decimalDigest(message);\n}\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor {\n    addDefaultExamples(node) {\n        node.visit(this);\n        return node;\n    }\n    visitTag(tag) {\n        if (tag.name === _PLACEHOLDER_TAG$3) {\n            if (!tag.children || tag.children.length == 0) {\n                const exText = new Text$1(tag.attrs['name'] || '...');\n                tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(node => node.visit(this));\n        }\n    }\n    visitText(text) { }\n    visitDeclaration(decl) { }\n    visitDoctype(doctype) { }\n}\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nfunction toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nconst TRANSLATION_VAR_PREFIX = 'i18n_';\n/** Name of the i18n attributes **/\nconst I18N_ATTR = 'i18n';\nconst I18N_ATTR_PREFIX = 'i18n-';\n/** Prefix of var expressions used in ICUs */\nconst I18N_ICU_VAR_PREFIX = 'VAR_';\n/** Prefix of ICU expressions for post processing */\nconst I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n/** Placeholder wrapper for i18n expressions **/\nconst I18N_PLACEHOLDER_SYMBOL = '';\nfunction isI18nAttribute(name) {\n    return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\nfunction isI18nRootNode(meta) {\n    return meta instanceof Message;\n}\nfunction isSingleI18nIcu(meta) {\n    return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;\n}\nfunction hasI18nMeta(node) {\n    return !!node.i18n;\n}\nfunction hasI18nAttrs(element) {\n    return element.attrs.some((attr) => isI18nAttribute(attr.name));\n}\nfunction icuFromI18nMessage(message) {\n    return message.nodes[0];\n}\nfunction wrapI18nPlaceholder(content, contextId = 0) {\n    const blockId = contextId > 0 ? `:${contextId}` : '';\n    return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\n}\nfunction assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {\n    if (!strings.length)\n        return '';\n    let acc = '';\n    const lastIdx = strings.length - 1;\n    for (let i = 0; i < lastIdx; i++) {\n        acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\n    }\n    acc += strings[lastIdx];\n    return acc;\n}\nfunction getSeqNumberGenerator(startsAt = 0) {\n    let current = startsAt;\n    return () => current++;\n}\nfunction placeholdersToParams(placeholders) {\n    const params = {};\n    placeholders.forEach((values, key) => {\n        params[key] = literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n    });\n    return params;\n}\nfunction updatePlaceholderMap(map, name, ...values) {\n    const current = map.get(name) || [];\n    current.push(...values);\n    map.set(name, current);\n}\nfunction assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {\n    const startIdx = bindingStartIndex;\n    const placeholders = new Map();\n    const node = meta instanceof Message ? meta.nodes.find(node => node instanceof Container) : meta;\n    if (node) {\n        node\n            .children\n            .filter((child) => child instanceof Placeholder)\n            .forEach((child, idx) => {\n            const content = wrapI18nPlaceholder(startIdx + idx, contextId);\n            updatePlaceholderMap(placeholders, child.name, content);\n        });\n    }\n    return placeholders;\n}\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nfunction i18nFormatPlaceholderNames(params = {}, useCamelCase) {\n    const _params = {};\n    if (params && Object.keys(params).length) {\n        Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n    }\n    return _params;\n}\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nfunction formatI18nPlaceholderName(name, useCamelCase = true) {\n    const publicName = toPublicName(name);\n    if (!useCamelCase) {\n        return publicName;\n    }\n    const chunks = publicName.split('_');\n    if (chunks.length === 1) {\n        // if no \"_\" found - just lowercase the value\n        return name.toLowerCase();\n    }\n    let postfix;\n    // eject last element if it's a number\n    if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n        postfix = chunks.pop();\n    }\n    let raw = chunks.shift().toLowerCase();\n    if (chunks.length) {\n        raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n    }\n    return postfix ? `${raw}_${postfix}` : raw;\n}\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nfunction getTranslationConstPrefix(extra) {\n    return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nfunction declareI18nVariable(variable) {\n    return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n/** Name of the temporary to use during data binding */\nconst TEMPORARY_NAME = '_t';\n/** Name of the context parameter passed into a template function */\nconst CONTEXT_NAME = 'ctx';\n/** Name of the RenderFlag passed into a template function */\nconst RENDER_FLAGS = 'rf';\n/** The prefix reference variables */\nconst REFERENCE_PREFIX = '_r';\n/** The name of the implicit context reference */\nconst IMPLICIT_REFERENCE = '$implicit';\n/** Non bindable attribute name **/\nconst NON_BINDABLE_ATTR = 'ngNonBindable';\n/** Name for the variable keeping track of the context returned by `restoreView`. */\nconst RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nfunction temporaryAllocator(statements, name) {\n    let temp = null;\n    return () => {\n        if (!temp) {\n            statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n            temp = variable(name);\n        }\n        return temp;\n    };\n}\nfunction invalid(arg) {\n    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\nfunction asLiteral(value) {\n    if (Array.isArray(value)) {\n        return literalArr(value.map(asLiteral));\n    }\n    return literal(value, INFERRED_TYPE);\n}\nfunction conditionallyCreateMapObjectLiteral(keys, keepDeclared) {\n    if (Object.getOwnPropertyNames(keys).length > 0) {\n        return mapToExpression(keys, keepDeclared);\n    }\n    return null;\n}\nfunction mapToExpression(map, keepDeclared) {\n    return literalMap(Object.getOwnPropertyNames(map).map(key => {\n        // canonical syntax: `dirProp: publicProp`\n        // if there is no `:`, use dirProp = elProp\n        const value = map[key];\n        let declaredName;\n        let publicName;\n        let minifiedName;\n        let needsDeclaredName;\n        if (Array.isArray(value)) {\n            [publicName, declaredName] = value;\n            minifiedName = key;\n            needsDeclaredName = publicName !== declaredName;\n        }\n        else {\n            [declaredName, publicName] = splitAtColon(key, [key, value]);\n            minifiedName = declaredName;\n            // Only include the declared name if extracted from the key, i.e. the key contains a colon.\n            // Otherwise the declared name should be omitted even if it is different from the public name,\n            // as it may have already been minified.\n            needsDeclaredName = publicName !== declaredName && key.includes(':');\n        }\n        return {\n            key: minifiedName,\n            // put quotes around keys that contain potentially unsafe characters\n            quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n            value: (keepDeclared && needsDeclaredName) ?\n                literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n                asLiteral(publicName)\n        };\n    }));\n}\n/**\n *  Remove trailing null nodes as they are implied.\n */\nfunction trimTrailingNulls(parameters) {\n    while (isNull(parameters[parameters.length - 1])) {\n        parameters.pop();\n    }\n    return parameters;\n}\nfunction getQueryPredicate(query, constantPool) {\n    if (Array.isArray(query.predicate)) {\n        let predicate = [];\n        query.predicate.forEach((selector) => {\n            // Each item in predicates array may contain strings with comma-separated refs\n            // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n            // as separate array entities\n            const selectors = selector.split(',').map(token => literal(token.trim()));\n            predicate.push(...selectors);\n        });\n        return constantPool.getConstLiteral(literalArr(predicate), true);\n    }\n    else {\n        // The original predicate may have been wrapped in a `forwardRef()` call.\n        switch (query.predicate.forwardRef) {\n            case 0 /* None */:\n            case 2 /* Unwrapped */:\n                return query.predicate.expression;\n            case 1 /* Wrapped */:\n                return importExpr(Identifiers$1.resolveForwardRef).callFn([query.predicate.expression]);\n        }\n    }\n}\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nclass DefinitionMap {\n    constructor() {\n        this.values = [];\n    }\n    set(key, value) {\n        if (value) {\n            this.values.push({ key: key, value, quoted: false });\n        }\n    }\n    toLiteralMap() {\n        return literalMap(this.values);\n    }\n}\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n    const attributesMap = {};\n    if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n        elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n    }\n    else {\n        elOrTpl.attributes.forEach(a => {\n            if (!isI18nAttribute(a.name)) {\n                attributesMap[a.name] = a.value;\n            }\n        });\n        elOrTpl.inputs.forEach(i => {\n            attributesMap[i.name] = '';\n        });\n        elOrTpl.outputs.forEach(o => {\n            attributesMap[o.name] = '';\n        });\n    }\n    return attributesMap;\n}\n/** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\nfunction chainedInstruction(reference, calls, span) {\n    let expression = importExpr(reference, null, span);\n    if (calls.length > 0) {\n        for (let i = 0; i < calls.length; i++) {\n            expression = expression.callFn(calls[i], span);\n        }\n    }\n    else {\n        // Add a blank invocation, in case the `calls` array is empty.\n        expression = expression.callFn([], span);\n    }\n    return expression;\n}\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nfunction getInterpolationArgsLength(interpolation) {\n    const { expressions, strings } = interpolation;\n    if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n        // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n        // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n        // `textInterpolate`.\n        return 1;\n    }\n    else {\n        return expressions.length + strings.length;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compileInjectable(meta, resolveForwardRefs) {\n    let result = null;\n    const factoryMeta = {\n        name: meta.name,\n        type: meta.type,\n        internalType: meta.internalType,\n        typeArgumentCount: meta.typeArgumentCount,\n        deps: [],\n        target: FactoryTarget$1.Injectable,\n    };\n    if (meta.useClass !== undefined) {\n        // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n        // used to instantiate the class with dependencies injected, or deps are not specified and\n        // the factory of the class is used to instantiate it.\n        //\n        // A special case exists for useClass: Type where Type is the injectable type itself and no\n        // deps are specified, in which case 'useClass' is effectively ignored.\n        const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);\n        let deps = undefined;\n        if (meta.deps !== undefined) {\n            deps = meta.deps;\n        }\n        if (deps !== undefined) {\n            // factory: () => new meta.useClass(...deps)\n            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useClass.expression, delegateDeps: deps, delegateType: R3FactoryDelegateType.Class }));\n        }\n        else if (useClassOnSelf) {\n            result = compileFactoryFunction(factoryMeta);\n        }\n        else {\n            result = {\n                statements: [],\n                expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)\n            };\n        }\n    }\n    else if (meta.useFactory !== undefined) {\n        if (meta.deps !== undefined) {\n            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useFactory, delegateDeps: meta.deps || [], delegateType: R3FactoryDelegateType.Function }));\n        }\n        else {\n            result = {\n                statements: [],\n                expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])\n            };\n        }\n    }\n    else if (meta.useValue !== undefined) {\n        // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n        // client code because meta.useValue is an Expression which will be defined even if the actual\n        // value is undefined.\n        result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: meta.useValue.expression }));\n    }\n    else if (meta.useExisting !== undefined) {\n        // useExisting is an `inject` call on the existing token.\n        result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: importExpr(Identifiers$1.inject).callFn([meta.useExisting.expression]) }));\n    }\n    else {\n        result = {\n            statements: [],\n            expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)\n        };\n    }\n    const token = meta.internalType;\n    const injectableProps = new DefinitionMap();\n    injectableProps.set('token', token);\n    injectableProps.set('factory', result.expression);\n    // Only generate providedIn property if it has a non-null value\n    if (meta.providedIn.expression.value !== null) {\n        injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n    }\n    const expression = importExpr(Identifiers$1.defineInjectable)\n        .callFn([injectableProps.toLiteralMap()], undefined, true);\n    return {\n        expression,\n        type: createInjectableType(meta),\n        statements: result.statements,\n    };\n}\nfunction createInjectableType(meta) {\n    return new ExpressionType(importExpr(Identifiers$1.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\nfunction delegateToFactory(type, internalType, unwrapForwardRefs) {\n    if (type.node === internalType.node) {\n        // The types are the same, so we can simply delegate directly to the type's factory.\n        // ```\n        // factory: type.fac\n        // ```\n        return internalType.prop('fac');\n    }\n    if (!unwrapForwardRefs) {\n        // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\n        // accepts a sub-type as an argument.\n        // ```\n        // factory: function(t) { return internalType.fac(t); }\n        // ```\n        return createFactoryFunction(internalType);\n    }\n    // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before\n    // calling its factory.\n    // ```\n    // factory: function(t) { return core.resolveForwardRef(type).fac(t); }\n    // ```\n    const unwrappedType = importExpr(Identifiers$1.resolveForwardRef).callFn([internalType]);\n    return createFactoryFunction(unwrappedType);\n}\nfunction createFactoryFunction(type) {\n    return fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(type.prop('fac').callFn([variable('t')]))]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//, // comment\n];\nfunction assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n    }\n    else if (value != null) {\n        const start = value[0];\n        const end = value[1];\n        // Check for unusable interpolation symbols\n        UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n            if (regexp.test(start) || regexp.test(end)) {\n                throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n            }\n        });\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass InterpolationConfig {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    static fromArray(markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    }\n}\nconst DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst $EOF = 0;\nconst $BSPACE = 8;\nconst $TAB = 9;\nconst $LF = 10;\nconst $VTAB = 11;\nconst $FF = 12;\nconst $CR = 13;\nconst $SPACE = 32;\nconst $BANG = 33;\nconst $DQ = 34;\nconst $HASH = 35;\nconst $$ = 36;\nconst $PERCENT = 37;\nconst $AMPERSAND = 38;\nconst $SQ = 39;\nconst $LPAREN = 40;\nconst $RPAREN = 41;\nconst $STAR = 42;\nconst $PLUS = 43;\nconst $COMMA = 44;\nconst $MINUS = 45;\nconst $PERIOD = 46;\nconst $SLASH = 47;\nconst $COLON = 58;\nconst $SEMICOLON = 59;\nconst $LT = 60;\nconst $EQ = 61;\nconst $GT = 62;\nconst $QUESTION = 63;\nconst $0 = 48;\nconst $7 = 55;\nconst $9 = 57;\nconst $A = 65;\nconst $E = 69;\nconst $F = 70;\nconst $X = 88;\nconst $Z = 90;\nconst $LBRACKET = 91;\nconst $BACKSLASH = 92;\nconst $RBRACKET = 93;\nconst $CARET = 94;\nconst $_ = 95;\nconst $a = 97;\nconst $b = 98;\nconst $e = 101;\nconst $f = 102;\nconst $n = 110;\nconst $r = 114;\nconst $t = 116;\nconst $u = 117;\nconst $v = 118;\nconst $x = 120;\nconst $z = 122;\nconst $LBRACE = 123;\nconst $BAR = 124;\nconst $RBRACE = 125;\nconst $NBSP = 160;\nconst $PIPE = 124;\nconst $TILDA = 126;\nconst $AT = 64;\nconst $BT = 96;\nfunction isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\nfunction isDigit(code) {\n    return $0 <= code && code <= $9;\n}\nfunction isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\nfunction isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\nfunction isNewLine(code) {\n    return code === $LF || code === $CR;\n}\nfunction isOctalDigit(code) {\n    return $0 <= code && code <= $7;\n}\nfunction isQuote(code) {\n    return code === $SQ || code === $DQ || code === $BT;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ParseLocation {\n    constructor(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    toString() {\n        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n    }\n    moveBy(delta) {\n        const source = this.file.content;\n        const len = source.length;\n        let offset = this.offset;\n        let line = this.line;\n        let col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            const ch = source.charCodeAt(offset);\n            if (ch == $LF) {\n                line--;\n                const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            const ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == $LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    }\n    // Return the source around the location\n    // Up to `maxChars` or `maxLines` on each side of the location\n    getContext(maxChars, maxLines) {\n        const content = this.file.content;\n        let startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            let endOffset = startOffset;\n            let ctxChars = 0;\n            let ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    }\n}\nclass ParseSourceFile {\n    constructor(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n}\nclass ParseSourceSpan {\n    /**\n     * Create an object that holds information about spans of tokens/nodes captured during\n     * lexing/parsing of text.\n     *\n     * @param start\n     * The location of the start of the span (having skipped leading trivia).\n     * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n     * elements will appear to begin at the start of the opening tag, rather than at the start of any\n     * leading trivia, which could include newlines.\n     *\n     * @param end\n     * The location of the end of the span.\n     *\n     * @param fullStart\n     * The start of the token without skipping the leading trivia.\n     * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n     * from text tokens. Such tooling creates new source-spans relative to the original token's\n     * source-span. If leading trivia characters have been skipped then the new source-spans may be\n     * incorrectly offset.\n     *\n     * @param details\n     * Additional information (such as identifier names) that should be associated with the span.\n     */\n    constructor(start, end, fullStart = start, details = null) {\n        this.start = start;\n        this.end = end;\n        this.fullStart = fullStart;\n        this.details = details;\n    }\n    toString() {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    }\n}\nvar ParseErrorLevel;\n(function (ParseErrorLevel) {\n    ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n    ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n})(ParseErrorLevel || (ParseErrorLevel = {}));\nclass ParseError {\n    constructor(span, msg, level = ParseErrorLevel.ERROR) {\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    contextualMessage() {\n        const ctx = this.span.start.getContext(100, 3);\n        return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n            this.msg;\n    }\n    toString() {\n        const details = this.span.details ? `, ${this.span.details}` : '';\n        return `${this.contextualMessage()}: ${this.span.start}${details}`;\n    }\n}\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n    const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n    const sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\nlet _anonymousTypeIndex = 0;\nfunction identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    const ref = compileIdentifier.reference;\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    if (ref['__forward_ref__']) {\n        // We do not want to try to stringify a `forwardRef()` function because that would cause the\n        // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n        return '__forward_ref__';\n    }\n    let identifier = stringify(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = `anonymous_${_anonymousTypeIndex++}`;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\nfunction sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\n * be available in all environments.\n *\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\n * creates an inline helper with the same functionality.\n *\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\n * array.\n */\nconst makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\nclass AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n    constructor() {\n        super(false);\n    }\n    visitWrappedNodeExpr(ast, ctx) {\n        throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n    }\n    visitDeclareVarStmt(stmt, ctx) {\n        ctx.print(stmt, `var ${stmt.name}`);\n        if (stmt.value) {\n            ctx.print(stmt, ' = ');\n            stmt.value.visitExpression(this, ctx);\n        }\n        ctx.println(stmt, `;`);\n        return null;\n    }\n    visitTaggedTemplateExpr(ast, ctx) {\n        // The following convoluted piece of code is effectively the downlevelled equivalent of\n        // ```\n        // tag`...`\n        // ```\n        // which is effectively like:\n        // ```\n        // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n        // ```\n        const elements = ast.template.elements;\n        ast.tag.visitExpression(this, ctx);\n        ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n        ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n        ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n        ast.template.expressions.forEach(expression => {\n            ctx.print(ast, ', ');\n            expression.visitExpression(this, ctx);\n        });\n        ctx.print(ast, ')');\n        return null;\n    }\n    visitFunctionExpr(ast, ctx) {\n        ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, `) {`);\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, `}`);\n        return null;\n    }\n    visitDeclareFunctionStmt(stmt, ctx) {\n        ctx.print(stmt, `function ${stmt.name}(`);\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, `) {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    visitLocalizedString(ast, ctx) {\n        // The following convoluted piece of code is effectively the downlevelled equivalent of\n        // ```\n        // $localize `...`\n        // ```\n        // which is effectively like:\n        // ```\n        // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n        // ```\n        ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n        const parts = [ast.serializeI18nHead()];\n        for (let i = 1; i < ast.messageParts.length; i++) {\n            parts.push(ast.serializeI18nTemplatePart(i));\n        }\n        ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n        ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n        ast.expressions.forEach(expression => {\n            ctx.print(ast, ', ');\n            expression.visitExpression(this, ctx);\n        });\n        ctx.print(ast, ')');\n        return null;\n    }\n    _visitParams(params, ctx) {\n        this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n    if (policy === undefined) {\n        policy = null;\n        if (_global.trustedTypes) {\n            try {\n                policy =\n                    _global.trustedTypes.createPolicy('angular#unsafe-jit', {\n                        createScript: (s) => s,\n                    });\n            }\n            catch (_a) {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script) {\n    var _a;\n    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;\n}\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nfunction newTrustedFunctionForJIT(...args) {\n    if (!_global.trustedTypes) {\n        // In environments that don't support Trusted Types, fall back to the most\n        // straightforward implementation:\n        return new Function(...args);\n    }\n    // Chrome currently does not support passing TrustedScript to the Function\n    // constructor. The following implements the workaround proposed on the page\n    // below, where the Chromium bug is also referenced:\n    // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n    const fnArgs = args.slice(0, -1).join(',');\n    const fnBody = args[args.length - 1];\n    const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n    // Using eval directly confuses the compiler and prevents this module from\n    // being stripped out of JS binaries even if not used. The global['eval']\n    // indirection fixes that.\n    const fn = _global['eval'](trustedScriptFromString(body));\n    if (fn.bind === undefined) {\n        // Workaround for a browser bug that only exists in Chrome 83, where passing\n        // a TrustedScript to eval just returns the TrustedScript back without\n        // evaluating it. In that case, fall back to the most straightforward\n        // implementation:\n        return new Function(...args);\n    }\n    // To completely mimic the behavior of calling \"new Function\", two more\n    // things need to happen:\n    // 1. Stringifying the resulting function should return its source code\n    fn.toString = () => body;\n    // 2. When calling the resulting function, `this` should refer to `global`\n    return fn.bind(_global);\n    // When Trusted Types support in Function constructors is widely available,\n    // the implementation of this function can be simplified to:\n    // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nclass JitEvaluator {\n    /**\n     *\n     * @param sourceUrl The URL of the generated code.\n     * @param statements An array of Angular statement AST nodes to be evaluated.\n     * @param refResolver Resolves `o.ExternalReference`s into values.\n     * @param createSourceMaps If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns A map of all the variables in the generated code.\n     */\n    evaluateStatements(sourceUrl, statements, refResolver, createSourceMaps) {\n        const converter = new JitEmitterVisitor(refResolver);\n        const ctx = EmitterVisitorContext.createRoot();\n        // Ensure generated code is in strict mode\n        if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n            statements = [\n                literal('use strict').toStmt(),\n                ...statements,\n            ];\n        }\n        converter.visitAllStatements(statements, ctx);\n        converter.createReturnStmt(ctx);\n        return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n    }\n    /**\n     * Evaluate a piece of JIT generated code.\n     * @param sourceUrl The URL of this generated code.\n     * @param ctx A context object that contains an AST of the code to be evaluated.\n     * @param vars A map containing the names and values of variables that the evaluated code might\n     * reference.\n     * @param createSourceMap If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns The result of evaluating the code.\n     */\n    evaluateCode(sourceUrl, ctx, vars, createSourceMap) {\n        let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n        const fnArgNames = [];\n        const fnArgValues = [];\n        for (const argName in vars) {\n            fnArgValues.push(vars[argName]);\n            fnArgNames.push(argName);\n        }\n        if (createSourceMap) {\n            // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n            // E.g. ```\n            // function anonymous(a,b,c\n            // /**/) { ... }```\n            // We don't want to hard code this fact, so we auto detect it via an empty function first.\n            const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n            const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n            fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n        }\n        const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n        return this.executeFunction(fn, fnArgValues);\n    }\n    /**\n     * Execute a JIT generated function by calling it.\n     *\n     * This method can be overridden in tests to capture the functions that are generated\n     * by this `JitEvaluator` class.\n     *\n     * @param fn A function to execute.\n     * @param args The arguments to pass to the function being executed.\n     * @returns The return value of the executed function.\n     */\n    executeFunction(fn, args) {\n        return fn(...args);\n    }\n}\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nclass JitEmitterVisitor extends AbstractJsEmitterVisitor {\n    constructor(refResolver) {\n        super();\n        this.refResolver = refResolver;\n        this._evalArgNames = [];\n        this._evalArgValues = [];\n        this._evalExportedVars = [];\n    }\n    createReturnStmt(ctx) {\n        const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));\n        stmt.visitStatement(this, ctx);\n    }\n    getArgs() {\n        const result = {};\n        for (let i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    }\n    visitExternalExpr(ast, ctx) {\n        this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n        return null;\n    }\n    visitWrappedNodeExpr(ast, ctx) {\n        this._emitReferenceToExternal(ast, ast.node, ctx);\n        return null;\n    }\n    visitDeclareVarStmt(stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return super.visitDeclareVarStmt(stmt, ctx);\n    }\n    visitDeclareFunctionStmt(stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return super.visitDeclareFunctionStmt(stmt, ctx);\n    }\n    _emitReferenceToExternal(ast, value, ctx) {\n        let id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            const name = identifierName({ reference: value }) || 'val';\n            this._evalArgNames.push(`jit_${name}_${id}`);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n    }\n}\nfunction isUseStrictStatement(statement) {\n    return statement.isEquivalent(literal('use strict').toStmt());\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compileInjector(meta) {\n    const definitionMap = new DefinitionMap();\n    if (meta.providers !== null) {\n        definitionMap.set('providers', meta.providers);\n    }\n    if (meta.imports.length > 0) {\n        definitionMap.set('imports', literalArr(meta.imports));\n    }\n    const expression = importExpr(Identifiers$1.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createInjectorType(meta);\n    return { expression, type, statements: [] };\n}\nfunction createInjectorType(meta) {\n    return new ExpressionType(importExpr(Identifiers$1.InjectorDeclaration, [new ExpressionType(meta.type.type)]));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nclass R3JitReflector {\n    constructor(context) {\n        this.context = context;\n    }\n    resolveExternalReference(ref) {\n        // This reflector only handles @angular/core imports.\n        if (ref.moduleName !== '@angular/core') {\n            throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);\n        }\n        if (!this.context.hasOwnProperty(ref.name)) {\n            throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);\n        }\n        return this.context[ref.name];\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nfunction compileNgModule(meta) {\n    const { internalType, bootstrap, declarations, imports, exports, schemas, containsForwardDecls, emitInline, id } = meta;\n    const statements = [];\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('type', internalType);\n    if (bootstrap.length > 0) {\n        definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\n    }\n    // If requested to emit scope information inline, pass the `declarations`, `imports` and `exports`\n    // to the `defineNgModule()` call. The JIT compilation uses this.\n    if (emitInline) {\n        if (declarations.length > 0) {\n            definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n        }\n        if (imports.length > 0) {\n            definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\n        }\n        if (exports.length > 0) {\n            definitionMap.set('exports', refsToArray(exports, containsForwardDecls));\n        }\n    }\n    // If not emitting inline, the scope information is not passed into `defineNgModule` as it would\n    // prevent tree-shaking of the declarations, imports and exports references.\n    else {\n        const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n        if (setNgModuleScopeCall !== null) {\n            statements.push(setNgModuleScopeCall);\n        }\n    }\n    if (schemas !== null && schemas.length > 0) {\n        definitionMap.set('schemas', literalArr(schemas.map(ref => ref.value)));\n    }\n    if (id !== null) {\n        definitionMap.set('id', id);\n    }\n    const expression = importExpr(Identifiers$1.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createNgModuleType(meta);\n    return { expression, type, statements };\n}\n/**\n * This function is used in JIT mode to generate the call to `defineNgModule()` from a call to\n * `ngDeclareNgModule()`.\n */\nfunction compileNgModuleDeclarationExpression(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('type', new WrappedNodeExpr(meta.type));\n    if (meta.bootstrap !== undefined) {\n        definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));\n    }\n    if (meta.declarations !== undefined) {\n        definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));\n    }\n    if (meta.imports !== undefined) {\n        definitionMap.set('imports', new WrappedNodeExpr(meta.imports));\n    }\n    if (meta.exports !== undefined) {\n        definitionMap.set('exports', new WrappedNodeExpr(meta.exports));\n    }\n    if (meta.schemas !== undefined) {\n        definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));\n    }\n    if (meta.id !== undefined) {\n        definitionMap.set('id', new WrappedNodeExpr(meta.id));\n    }\n    return importExpr(Identifiers$1.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\nfunction createNgModuleType({ type: moduleType, declarations, imports, exports }) {\n    return new ExpressionType(importExpr(Identifiers$1.NgModuleDeclaration, [\n        new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),\n        tupleTypeOf(exports)\n    ]));\n}\n/**\n * Generates a function call to `setNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta) {\n    const { adjacentType: moduleType, declarations, imports, exports, containsForwardDecls } = meta;\n    const scopeMap = new DefinitionMap();\n    if (declarations.length > 0) {\n        scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n    }\n    if (imports.length > 0) {\n        scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\n    }\n    if (exports.length > 0) {\n        scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\n    }\n    if (Object.keys(scopeMap.values).length === 0) {\n        return null;\n    }\n    // setNgModuleScope(...)\n    const fnCall = new InvokeFunctionExpr(\n    /* fn */ importExpr(Identifiers$1.setNgModuleScope), \n    /* args */ [moduleType, scopeMap.toLiteralMap()]);\n    // (ngJitMode guard) && setNgModuleScope(...)\n    const guardedCall = jitOnlyGuardedExpression(fnCall);\n    // function() { (ngJitMode guard) && setNgModuleScope(...); }\n    const iife = new FunctionExpr(\n    /* params */ [], \n    /* statements */ [guardedCall.toStmt()]);\n    // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n    const iifeCall = new InvokeFunctionExpr(\n    /* fn */ iife, \n    /* args */ []);\n    return iifeCall.toStmt();\n}\nfunction tupleTypeOf(exp) {\n    const types = exp.map(ref => typeofExpr(ref.type));\n    return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compilePipeFromMetadata(metadata) {\n    const definitionMapValues = [];\n    // e.g. `name: 'myPipe'`\n    definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });\n    // e.g. `type: MyPipe`\n    definitionMapValues.push({ key: 'type', value: metadata.type.value, quoted: false });\n    // e.g. `pure: true`\n    definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });\n    const expression = importExpr(Identifiers$1.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);\n    const type = createPipeType(metadata);\n    return { expression, type, statements: [] };\n}\nfunction createPipeType(metadata) {\n    return new ExpressionType(importExpr(Identifiers$1.PipeDeclaration, [\n        typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n        new ExpressionType(new LiteralExpr(metadata.pipeName)),\n    ]));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ParserError {\n    constructor(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n    }\n}\nclass ParseSpan {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    toAbsolute(absoluteOffset) {\n        return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n    }\n}\nclass AST {\n    constructor(span, \n    /**\n     * Absolute location of the expression AST in a source code file.\n     */\n    sourceSpan) {\n        this.span = span;\n        this.sourceSpan = sourceSpan;\n    }\n    toString() {\n        return 'AST';\n    }\n}\nclass ASTWithName extends AST {\n    constructor(span, sourceSpan, nameSpan) {\n        super(span, sourceSpan);\n        this.nameSpan = nameSpan;\n    }\n}\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nclass Quote extends AST {\n    constructor(span, sourceSpan, prefix, uninterpretedExpression, location) {\n        super(span, sourceSpan);\n        this.prefix = prefix;\n        this.uninterpretedExpression = uninterpretedExpression;\n        this.location = location;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitQuote(this, context);\n    }\n    toString() {\n        return 'Quote';\n    }\n}\nclass EmptyExpr extends AST {\n    visit(visitor, context = null) {\n        // do nothing\n    }\n}\nclass ImplicitReceiver extends AST {\n    visit(visitor, context = null) {\n        return visitor.visitImplicitReceiver(this, context);\n    }\n}\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nclass ThisReceiver extends ImplicitReceiver {\n    visit(visitor, context = null) {\n        var _a;\n        return (_a = visitor.visitThisReceiver) === null || _a === void 0 ? void 0 : _a.call(visitor, this, context);\n    }\n}\n/**\n * Multiple expressions separated by a semicolon.\n */\nclass Chain extends AST {\n    constructor(span, sourceSpan, expressions) {\n        super(span, sourceSpan);\n        this.expressions = expressions;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitChain(this, context);\n    }\n}\nclass Conditional extends AST {\n    constructor(span, sourceSpan, condition, trueExp, falseExp) {\n        super(span, sourceSpan);\n        this.condition = condition;\n        this.trueExp = trueExp;\n        this.falseExp = falseExp;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitConditional(this, context);\n    }\n}\nclass PropertyRead extends ASTWithName {\n    constructor(span, sourceSpan, nameSpan, receiver, name) {\n        super(span, sourceSpan, nameSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPropertyRead(this, context);\n    }\n}\nclass PropertyWrite extends ASTWithName {\n    constructor(span, sourceSpan, nameSpan, receiver, name, value) {\n        super(span, sourceSpan, nameSpan);\n        this.receiver = receiver;\n        this.name = name;\n        this.value = value;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPropertyWrite(this, context);\n    }\n}\nclass SafePropertyRead extends ASTWithName {\n    constructor(span, sourceSpan, nameSpan, receiver, name) {\n        super(span, sourceSpan, nameSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitSafePropertyRead(this, context);\n    }\n}\nclass KeyedRead extends AST {\n    constructor(span, sourceSpan, receiver, key) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.key = key;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitKeyedRead(this, context);\n    }\n}\nclass SafeKeyedRead extends AST {\n    constructor(span, sourceSpan, receiver, key) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.key = key;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitSafeKeyedRead(this, context);\n    }\n}\nclass KeyedWrite extends AST {\n    constructor(span, sourceSpan, receiver, key, value) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.key = key;\n        this.value = value;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitKeyedWrite(this, context);\n    }\n}\nclass BindingPipe extends ASTWithName {\n    constructor(span, sourceSpan, exp, name, args, nameSpan) {\n        super(span, sourceSpan, nameSpan);\n        this.exp = exp;\n        this.name = name;\n        this.args = args;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPipe(this, context);\n    }\n}\nclass LiteralPrimitive extends AST {\n    constructor(span, sourceSpan, value) {\n        super(span, sourceSpan);\n        this.value = value;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitLiteralPrimitive(this, context);\n    }\n}\nclass LiteralArray extends AST {\n    constructor(span, sourceSpan, expressions) {\n        super(span, sourceSpan);\n        this.expressions = expressions;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitLiteralArray(this, context);\n    }\n}\nclass LiteralMap extends AST {\n    constructor(span, sourceSpan, keys, values) {\n        super(span, sourceSpan);\n        this.keys = keys;\n        this.values = values;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitLiteralMap(this, context);\n    }\n}\nclass Interpolation extends AST {\n    constructor(span, sourceSpan, strings, expressions) {\n        super(span, sourceSpan);\n        this.strings = strings;\n        this.expressions = expressions;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitInterpolation(this, context);\n    }\n}\nclass Binary extends AST {\n    constructor(span, sourceSpan, operation, left, right) {\n        super(span, sourceSpan);\n        this.operation = operation;\n        this.left = left;\n        this.right = right;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitBinary(this, context);\n    }\n}\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nclass Unary extends Binary {\n    /**\n     * During the deprecation period this constructor is private, to avoid consumers from creating\n     * a `Unary` with the fallback properties for `Binary`.\n     */\n    constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {\n        super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n        this.operator = operator;\n        this.expr = expr;\n        // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n        // depend on these fields when operating on `Unary`.\n        this.left = null;\n        this.right = null;\n        this.operation = null;\n    }\n    /**\n     * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n     */\n    static createMinus(span, sourceSpan, expr) {\n        return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n    }\n    /**\n     * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n     */\n    static createPlus(span, sourceSpan, expr) {\n        return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n    }\n    visit(visitor, context = null) {\n        if (visitor.visitUnary !== undefined) {\n            return visitor.visitUnary(this, context);\n        }\n        return visitor.visitBinary(this, context);\n    }\n}\nclass PrefixNot extends AST {\n    constructor(span, sourceSpan, expression) {\n        super(span, sourceSpan);\n        this.expression = expression;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPrefixNot(this, context);\n    }\n}\nclass NonNullAssert extends AST {\n    constructor(span, sourceSpan, expression) {\n        super(span, sourceSpan);\n        this.expression = expression;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitNonNullAssert(this, context);\n    }\n}\nclass Call extends AST {\n    constructor(span, sourceSpan, receiver, args, argumentSpan) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.args = args;\n        this.argumentSpan = argumentSpan;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitCall(this, context);\n    }\n}\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nclass AbsoluteSourceSpan {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n}\nclass ASTWithSource extends AST {\n    constructor(ast, source, location, absoluteOffset, errors) {\n        super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n        this.ast = ast;\n        this.source = source;\n        this.location = location;\n        this.errors = errors;\n    }\n    visit(visitor, context = null) {\n        if (visitor.visitASTWithSource) {\n            return visitor.visitASTWithSource(this, context);\n        }\n        return this.ast.visit(visitor, context);\n    }\n    toString() {\n        return `${this.source} in ${this.location}`;\n    }\n}\nclass VariableBinding {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key name of the LHS along with its span.\n     * @param value optional value for the RHS along with its span.\n     */\n    constructor(sourceSpan, key, value) {\n        this.sourceSpan = sourceSpan;\n        this.key = key;\n        this.value = value;\n    }\n}\nclass ExpressionBinding {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n     * span. Note that the length of the span may not be the same as\n     * `key.source.length`. For example,\n     * 1. key.source = ngFor, key.span is for \"ngFor\"\n     * 2. key.source = ngForOf, key.span is for \"of\"\n     * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n     * @param value optional expression for the RHS.\n     */\n    constructor(sourceSpan, key, value) {\n        this.sourceSpan = sourceSpan;\n        this.key = key;\n        this.value = value;\n    }\n}\nclass RecursiveAstVisitor {\n    visit(ast, context) {\n        // The default implementation just visits every node.\n        // Classes that extend RecursiveAstVisitor should override this function\n        // to selectively visit the specified node.\n        ast.visit(this, context);\n    }\n    visitUnary(ast, context) {\n        this.visit(ast.expr, context);\n    }\n    visitBinary(ast, context) {\n        this.visit(ast.left, context);\n        this.visit(ast.right, context);\n    }\n    visitChain(ast, context) {\n        this.visitAll(ast.expressions, context);\n    }\n    visitConditional(ast, context) {\n        this.visit(ast.condition, context);\n        this.visit(ast.trueExp, context);\n        this.visit(ast.falseExp, context);\n    }\n    visitPipe(ast, context) {\n        this.visit(ast.exp, context);\n        this.visitAll(ast.args, context);\n    }\n    visitImplicitReceiver(ast, context) { }\n    visitThisReceiver(ast, context) { }\n    visitInterpolation(ast, context) {\n        this.visitAll(ast.expressions, context);\n    }\n    visitKeyedRead(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.key, context);\n    }\n    visitKeyedWrite(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.key, context);\n        this.visit(ast.value, context);\n    }\n    visitLiteralArray(ast, context) {\n        this.visitAll(ast.expressions, context);\n    }\n    visitLiteralMap(ast, context) {\n        this.visitAll(ast.values, context);\n    }\n    visitLiteralPrimitive(ast, context) { }\n    visitPrefixNot(ast, context) {\n        this.visit(ast.expression, context);\n    }\n    visitNonNullAssert(ast, context) {\n        this.visit(ast.expression, context);\n    }\n    visitPropertyRead(ast, context) {\n        this.visit(ast.receiver, context);\n    }\n    visitPropertyWrite(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.value, context);\n    }\n    visitSafePropertyRead(ast, context) {\n        this.visit(ast.receiver, context);\n    }\n    visitSafeKeyedRead(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.key, context);\n    }\n    visitCall(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visitAll(ast.args, context);\n    }\n    visitQuote(ast, context) { }\n    // This is not part of the AstVisitor interface, just a helper method\n    visitAll(asts, context) {\n        for (const ast of asts) {\n            this.visit(ast, context);\n        }\n    }\n}\nclass AstTransformer {\n    visitImplicitReceiver(ast, context) {\n        return ast;\n    }\n    visitThisReceiver(ast, context) {\n        return ast;\n    }\n    visitInterpolation(ast, context) {\n        return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n    }\n    visitLiteralPrimitive(ast, context) {\n        return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n    }\n    visitPropertyRead(ast, context) {\n        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n    visitPropertyWrite(ast, context) {\n        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    }\n    visitSafePropertyRead(ast, context) {\n        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n    visitLiteralArray(ast, context) {\n        return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n    visitLiteralMap(ast, context) {\n        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n    }\n    visitUnary(ast, context) {\n        switch (ast.operator) {\n            case '+':\n                return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n            case '-':\n                return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n            default:\n                throw new Error(`Unknown unary operator ${ast.operator}`);\n        }\n    }\n    visitBinary(ast, context) {\n        return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    }\n    visitPrefixNot(ast, context) {\n        return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n    visitNonNullAssert(ast, context) {\n        return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n    visitConditional(ast, context) {\n        return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    }\n    visitPipe(ast, context) {\n        return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);\n    }\n    visitKeyedRead(ast, context) {\n        return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n    }\n    visitKeyedWrite(ast, context) {\n        return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));\n    }\n    visitCall(ast, context) {\n        return new Call(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);\n    }\n    visitAll(asts) {\n        const res = [];\n        for (let i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    }\n    visitChain(ast, context) {\n        return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n    visitQuote(ast, context) {\n        return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);\n    }\n    visitSafeKeyedRead(ast, context) {\n        return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n    }\n}\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nclass AstMemoryEfficientTransformer {\n    visitImplicitReceiver(ast, context) {\n        return ast;\n    }\n    visitThisReceiver(ast, context) {\n        return ast;\n    }\n    visitInterpolation(ast, context) {\n        const expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions)\n            return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n        return ast;\n    }\n    visitLiteralPrimitive(ast, context) {\n        return ast;\n    }\n    visitPropertyRead(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n        }\n        return ast;\n    }\n    visitPropertyWrite(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        const value = ast.value.visit(this);\n        if (receiver !== ast.receiver || value !== ast.value) {\n            return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n        }\n        return ast;\n    }\n    visitSafePropertyRead(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n        }\n        return ast;\n    }\n    visitLiteralArray(ast, context) {\n        const expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n        }\n        return ast;\n    }\n    visitLiteralMap(ast, context) {\n        const values = this.visitAll(ast.values);\n        if (values !== ast.values) {\n            return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n        }\n        return ast;\n    }\n    visitUnary(ast, context) {\n        const expr = ast.expr.visit(this);\n        if (expr !== ast.expr) {\n            switch (ast.operator) {\n                case '+':\n                    return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n                case '-':\n                    return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n                default:\n                    throw new Error(`Unknown unary operator ${ast.operator}`);\n            }\n        }\n        return ast;\n    }\n    visitBinary(ast, context) {\n        const left = ast.left.visit(this);\n        const right = ast.right.visit(this);\n        if (left !== ast.left || right !== ast.right) {\n            return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n        }\n        return ast;\n    }\n    visitPrefixNot(ast, context) {\n        const expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new PrefixNot(ast.span, ast.sourceSpan, expression);\n        }\n        return ast;\n    }\n    visitNonNullAssert(ast, context) {\n        const expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n        }\n        return ast;\n    }\n    visitConditional(ast, context) {\n        const condition = ast.condition.visit(this);\n        const trueExp = ast.trueExp.visit(this);\n        const falseExp = ast.falseExp.visit(this);\n        if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n            return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n        }\n        return ast;\n    }\n    visitPipe(ast, context) {\n        const exp = ast.exp.visit(this);\n        const args = this.visitAll(ast.args);\n        if (exp !== ast.exp || args !== ast.args) {\n            return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n        }\n        return ast;\n    }\n    visitKeyedRead(ast, context) {\n        const obj = ast.receiver.visit(this);\n        const key = ast.key.visit(this);\n        if (obj !== ast.receiver || key !== ast.key) {\n            return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n        }\n        return ast;\n    }\n    visitKeyedWrite(ast, context) {\n        const obj = ast.receiver.visit(this);\n        const key = ast.key.visit(this);\n        const value = ast.value.visit(this);\n        if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {\n            return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n        }\n        return ast;\n    }\n    visitAll(asts) {\n        const res = [];\n        let modified = false;\n        for (let i = 0; i < asts.length; ++i) {\n            const original = asts[i];\n            const value = original.visit(this);\n            res[i] = value;\n            modified = modified || value !== original;\n        }\n        return modified ? res : asts;\n    }\n    visitChain(ast, context) {\n        const expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new Chain(ast.span, ast.sourceSpan, expressions);\n        }\n        return ast;\n    }\n    visitCall(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        const args = this.visitAll(ast.args);\n        if (receiver !== ast.receiver || args !== ast.args) {\n            return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n        }\n        return ast;\n    }\n    visitQuote(ast, context) {\n        return ast;\n    }\n    visitSafeKeyedRead(ast, context) {\n        const obj = ast.receiver.visit(this);\n        const key = ast.key.visit(this);\n        if (obj !== ast.receiver || key !== ast.key) {\n            return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);\n        }\n        return ast;\n    }\n}\n// Bindings\nclass ParsedProperty {\n    constructor(name, expression, type, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n        this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n    }\n}\nvar ParsedPropertyType;\n(function (ParsedPropertyType) {\n    ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n    ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\n})(ParsedPropertyType || (ParsedPropertyType = {}));\nclass ParsedEvent {\n    // Regular events have a target\n    // Animation events have a phase\n    constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {\n        this.name = name;\n        this.targetOrPhase = targetOrPhase;\n        this.type = type;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n        this.keySpan = keySpan;\n    }\n}\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nclass ParsedVariable {\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n}\nclass BoundElementProperty {\n    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst CORE = '@angular/core';\nclass Identifiers {\n}\nIdentifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n    name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n    moduleName: CORE,\n};\nIdentifiers.ElementRef = { name: 'ElementRef', moduleName: CORE };\nIdentifiers.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE };\nIdentifiers.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE };\nIdentifiers.ChangeDetectorRef = {\n    name: 'ChangeDetectorRef',\n    moduleName: CORE,\n};\nIdentifiers.QueryList = { name: 'QueryList', moduleName: CORE };\nIdentifiers.TemplateRef = { name: 'TemplateRef', moduleName: CORE };\nIdentifiers.Renderer2 = { name: 'Renderer2', moduleName: CORE };\nIdentifiers.CodegenComponentFactoryResolver = {\n    name: 'CodegenComponentFactoryResolver',\n    moduleName: CORE,\n};\nIdentifiers.ComponentFactoryResolver = {\n    name: 'ComponentFactoryResolver',\n    moduleName: CORE,\n};\nIdentifiers.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE };\nIdentifiers.ComponentRef = { name: 'ComponentRef', moduleName: CORE };\nIdentifiers.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE };\nIdentifiers.createModuleFactory = {\n    name: 'cmf',\n    moduleName: CORE,\n};\nIdentifiers.moduleDef = {\n    name: 'mod',\n    moduleName: CORE,\n};\nIdentifiers.moduleProviderDef = {\n    name: 'mpd',\n    moduleName: CORE,\n};\nIdentifiers.RegisterModuleFactoryFn = {\n    name: 'registerModuleFactory',\n    moduleName: CORE,\n};\nIdentifiers.inject = { name: 'inject', moduleName: CORE };\nIdentifiers.directiveInject = { name: 'directiveInject', moduleName: CORE };\nIdentifiers.INJECTOR = { name: 'INJECTOR', moduleName: CORE };\nIdentifiers.Injector = { name: 'Injector', moduleName: CORE };\nIdentifiers.ViewEncapsulation = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n};\nIdentifiers.ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n};\nIdentifiers.SecurityContext = {\n    name: 'SecurityContext',\n    moduleName: CORE,\n};\nIdentifiers.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE };\nIdentifiers.TRANSLATIONS_FORMAT = {\n    name: 'TRANSLATIONS_FORMAT',\n    moduleName: CORE,\n};\nIdentifiers.inlineInterpolate = {\n    name: 'inlineInterpolate',\n    moduleName: CORE,\n};\nIdentifiers.interpolate = { name: 'interpolate', moduleName: CORE };\nIdentifiers.EMPTY_ARRAY = { name: 'EMPTY_ARRAY', moduleName: CORE };\nIdentifiers.EMPTY_MAP = { name: 'EMPTY_MAP', moduleName: CORE };\nIdentifiers.Renderer = { name: 'Renderer', moduleName: CORE };\n// type only\nIdentifiers.RendererType2 = {\n    name: 'RendererType2',\n    moduleName: CORE,\n};\n// type only\nIdentifiers.ViewDefinition = {\n    name: 'ViewDefinition',\n    moduleName: CORE,\n};\nIdentifiers.createComponentFactory = { name: 'ccf', moduleName: CORE };\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass EventHandlerVars {\n}\nEventHandlerVars.event = variable('$event');\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses, globals) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver(globals);\n    }\n    const actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: (argCount) => {\n            // Note: no caching for literal arrays in actions.\n            return (args) => literalArr(args);\n        },\n        createLiteralMapConverter: (keys) => {\n            // Note: no caching for literal maps in actions.\n            return (values) => {\n                const entries = keys.map((k, i) => ({\n                    key: k.key,\n                    value: values[i],\n                    quoted: k.quoted,\n                }));\n                return literalMap(entries);\n            };\n        },\n        createPipeConverter: (name) => {\n            throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n    }, action);\n    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);\n    const actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    const lastIndex = actionStmts.length - 1;\n    if (lastIndex >= 0) {\n        const lastStatement = actionStmts[lastIndex];\n        // Ensure that the value of the last expression statement is returned\n        if (lastStatement instanceof ExpressionStatement) {\n            actionStmts[lastIndex] = new ReturnStatement(lastStatement.expr);\n        }\n    }\n    return actionStmts;\n}\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nclass ConvertPropertyBindingResult {\n    constructor(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n}\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, interpolationFunction) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n    const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    const stmts = getStatementsFromVisitor(visitor, bindingId);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    return new ConvertPropertyBindingResult(stmts, outputExpr);\n}\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nfunction convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {\n    const visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);\n    const outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    const stmts = getStatementsFromVisitor(visitor, bindingId);\n    // Removing the first argument, because it was a length for ViewEngine, not Ivy.\n    let args = outputExpr.args.slice(1);\n    if (expressionWithArgumentsToExtract instanceof Interpolation) {\n        // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n        // args returned to just the value, because we're going to pass it to a special instruction.\n        const strings = expressionWithArgumentsToExtract.strings;\n        if (args.length === 3 && strings[0] === '' && strings[1] === '') {\n            // Single argument interpolate instructions.\n            args = [args[1]];\n        }\n        else if (args.length >= 19) {\n            // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n            // an array of arguments\n            args = [literalArr(args)];\n        }\n    }\n    return { stmts, args };\n}\nfunction getStatementsFromVisitor(visitor, bindingId) {\n    const stmts = [];\n    for (let i = 0; i < visitor.temporaryCount; i++) {\n        stmts.push(temporaryDeclaration(bindingId, i));\n    }\n    return stmts;\n}\nfunction convertBuiltins(converterFactory, ast) {\n    const visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\nfunction temporaryName(bindingId, temporaryNumber) {\n    return `tmp_${bindingId}_${temporaryNumber}`;\n}\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));\n}\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (let i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\nvar _Mode;\n(function (_Mode) {\n    _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\n    _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\n})(_Mode || (_Mode = {}));\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(`Expected a statement, but saw ${ast}`);\n    }\n}\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(`Expected an expression, but saw ${ast}`);\n    }\n}\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nclass _BuiltinAstConverter extends AstTransformer {\n    constructor(_converterFactory) {\n        super();\n        this._converterFactory = _converterFactory;\n    }\n    visitPipe(ast, context) {\n        const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    }\n    visitLiteralArray(ast, context) {\n        const args = ast.expressions.map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    }\n    visitLiteralMap(ast, context) {\n        const args = ast.values.map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    }\n}\nclass _AstToIrVisitor {\n    constructor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this.interpolationFunction = interpolationFunction;\n        this.baseSourceSpan = baseSourceSpan;\n        this.implicitReceiverAccesses = implicitReceiverAccesses;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n        this.usesImplicitReceiver = false;\n    }\n    visitUnary(ast, mode) {\n        let op;\n        switch (ast.operator) {\n            case '+':\n                op = UnaryOperator.Plus;\n                break;\n            case '-':\n                op = UnaryOperator.Minus;\n                break;\n            default:\n                throw new Error(`Unsupported operator ${ast.operator}`);\n        }\n        return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    }\n    visitBinary(ast, mode) {\n        let op;\n        switch (ast.operation) {\n            case '+':\n                op = BinaryOperator.Plus;\n                break;\n            case '-':\n                op = BinaryOperator.Minus;\n                break;\n            case '*':\n                op = BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = BinaryOperator.Divide;\n                break;\n            case '%':\n                op = BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = BinaryOperator.And;\n                break;\n            case '||':\n                op = BinaryOperator.Or;\n                break;\n            case '==':\n                op = BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = BinaryOperator.Lower;\n                break;\n            case '>':\n                op = BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = BinaryOperator.BiggerEquals;\n                break;\n            case '??':\n                return this.convertNullishCoalesce(ast, mode);\n            default:\n                throw new Error(`Unsupported operation ${ast.operation}`);\n        }\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    }\n    visitChain(ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    }\n    visitConditional(ast, mode) {\n        const value = this._visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\n    }\n    visitPipe(ast, mode) {\n        throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n    }\n    visitImplicitReceiver(ast, mode) {\n        ensureExpressionMode(mode, ast);\n        this.usesImplicitReceiver = true;\n        return this._implicitReceiver;\n    }\n    visitThisReceiver(ast, mode) {\n        return this.visitImplicitReceiver(ast, mode);\n    }\n    visitInterpolation(ast, mode) {\n        ensureExpressionMode(mode, ast);\n        const args = [literal(ast.expressions.length)];\n        for (let i = 0; i < ast.strings.length - 1; i++) {\n            args.push(literal(ast.strings[i]));\n            args.push(this._visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(literal(ast.strings[ast.strings.length - 1]));\n        if (this.interpolationFunction) {\n            return this.interpolationFunction(args);\n        }\n        return ast.expressions.length <= 9 ?\n            importExpr(Identifiers.inlineInterpolate).callFn(args) :\n            importExpr(Identifiers.interpolate).callFn([\n                args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))\n            ]);\n    }\n    visitKeyedRead(ast, mode) {\n        const leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n        }\n    }\n    visitKeyedWrite(ast, mode) {\n        const obj = this._visit(ast.receiver, _Mode.Expression);\n        const key = this._visit(ast.key, _Mode.Expression);\n        const value = this._visit(ast.value, _Mode.Expression);\n        if (obj === this._implicitReceiver) {\n            this._localResolver.maybeRestoreView();\n        }\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    }\n    visitLiteralArray(ast, mode) {\n        throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n    }\n    visitLiteralMap(ast, mode) {\n        throw new Error(`Illegal State: literal maps should have been converted into functions`);\n    }\n    visitLiteralPrimitive(ast, mode) {\n        // For literal values of null, undefined, true, or false allow type interference\n        // to infer the type.\n        const type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n            INFERRED_TYPE :\n            undefined;\n        return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));\n    }\n    _getLocal(name, receiver) {\n        var _a;\n        if (((_a = this._localResolver.globals) === null || _a === void 0 ? void 0 : _a.has(name)) && receiver instanceof ThisReceiver) {\n            return null;\n        }\n        return this._localResolver.getLocal(name);\n    }\n    visitPrefixNot(ast, mode) {\n        return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));\n    }\n    visitNonNullAssert(ast, mode) {\n        return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));\n    }\n    visitPropertyRead(ast, mode) {\n        const leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            let result = null;\n            const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n            const receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name, ast.receiver);\n                if (result) {\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                    this.addImplicitReceiverAccess(ast.name);\n                }\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    }\n    visitPropertyWrite(ast, mode) {\n        const receiver = this._visit(ast.receiver, _Mode.Expression);\n        const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n        let varExpr = null;\n        if (receiver === this._implicitReceiver) {\n            const localExpr = this._getLocal(ast.name, ast.receiver);\n            if (localExpr) {\n                if (localExpr instanceof ReadPropExpr) {\n                    // If the local variable is a property read expression, it's a reference\n                    // to a 'context.property' value and will be used as the target of the\n                    // write expression.\n                    varExpr = localExpr;\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                    this.addImplicitReceiverAccess(ast.name);\n                }\n                else {\n                    // Otherwise it's an error.\n                    const receiver = ast.name;\n                    const value = (ast.value instanceof PropertyRead) ? ast.value.name : undefined;\n                    throw new Error(`Cannot assign value \"${value}\" to template variable \"${receiver}\". Template variables are read-only.`);\n                }\n            }\n        }\n        // If no local expression could be produced, use the original receiver's\n        // property as the target.\n        if (varExpr === null) {\n            varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n        }\n        return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n    }\n    visitSafePropertyRead(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    visitSafeKeyedRead(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    visitAll(asts, mode) {\n        return asts.map(ast => this._visit(ast, mode));\n    }\n    visitQuote(ast, mode) {\n        throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n    }\n    visitCall(ast, mode) {\n        const leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        if (ast instanceof BuiltinFunctionCall) {\n            return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));\n        }\n        const receiver = ast.receiver;\n        if (receiver instanceof PropertyRead &&\n            receiver.receiver instanceof ImplicitReceiver &&\n            !(receiver.receiver instanceof ThisReceiver) && receiver.name === '$any') {\n            if (convertedArgs.length !== 1) {\n                throw new Error(`Invalid call to $any, expected 1 argument but received ${convertedArgs.length || 'none'}`);\n            }\n            return convertToStatementIfNeeded(mode, convertedArgs[0]);\n        }\n        const call = this._visit(receiver, _Mode.Expression)\n            .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n        return convertToStatementIfNeeded(mode, call);\n    }\n    _visit(ast, mode) {\n        const result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    }\n    convertSafeAccess(ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  .   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n        let temporary = undefined;\n        if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        const condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof SafeKeyedRead) {\n            this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        const access = this._visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));\n    }\n    convertNullishCoalesce(ast, mode) {\n        const left = this._visit(ast.left, _Mode.Expression);\n        const right = this._visit(ast.right, _Mode.Expression);\n        const temporary = this.allocateTemporary();\n        this.releaseTemporary(temporary);\n        // Generate the following expression. It is identical to how TS\n        // transpiles binary expressions with a nullish coalescing operator.\n        // let temp;\n        // (temp = a) !== null && temp !== undefined ? temp : b;\n        return convertToStatementIfNeeded(mode, temporary.set(left)\n            .notIdentical(NULL_EXPR)\n            .and(temporary.notIdentical(literal(undefined)))\n            .conditional(temporary, right));\n    }\n    // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n    // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n    // safe method call as this needs to be transformed initially to:\n    //   a == null ? null : a.c.b.c?.d.e\n    // then to:\n    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n    leftMostSafeNode(ast) {\n        const visit = (visitor, ast) => {\n            return (this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            visitUnary(ast) {\n                return null;\n            },\n            visitBinary(ast) {\n                return null;\n            },\n            visitChain(ast) {\n                return null;\n            },\n            visitConditional(ast) {\n                return null;\n            },\n            visitCall(ast) {\n                return visit(this, ast.receiver);\n            },\n            visitImplicitReceiver(ast) {\n                return null;\n            },\n            visitThisReceiver(ast) {\n                return null;\n            },\n            visitInterpolation(ast) {\n                return null;\n            },\n            visitKeyedRead(ast) {\n                return visit(this, ast.receiver);\n            },\n            visitKeyedWrite(ast) {\n                return null;\n            },\n            visitLiteralArray(ast) {\n                return null;\n            },\n            visitLiteralMap(ast) {\n                return null;\n            },\n            visitLiteralPrimitive(ast) {\n                return null;\n            },\n            visitPipe(ast) {\n                return null;\n            },\n            visitPrefixNot(ast) {\n                return null;\n            },\n            visitNonNullAssert(ast) {\n                return null;\n            },\n            visitPropertyRead(ast) {\n                return visit(this, ast.receiver);\n            },\n            visitPropertyWrite(ast) {\n                return null;\n            },\n            visitQuote(ast) {\n                return null;\n            },\n            visitSafePropertyRead(ast) {\n                return visit(this, ast.receiver) || ast;\n            },\n            visitSafeKeyedRead(ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    }\n    // Returns true of the AST includes a method or a pipe indicating that, if the\n    // expression is used as the target of a safe property or method access then\n    // the expression should be stored into a temporary variable.\n    needsTemporaryInSafeAccess(ast) {\n        const visit = (visitor, ast) => {\n            return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        const visitSome = (visitor, ast) => {\n            return ast.some(ast => visit(visitor, ast));\n        };\n        return ast.visit({\n            visitUnary(ast) {\n                return visit(this, ast.expr);\n            },\n            visitBinary(ast) {\n                return visit(this, ast.left) || visit(this, ast.right);\n            },\n            visitChain(ast) {\n                return false;\n            },\n            visitConditional(ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n            },\n            visitCall(ast) {\n                return true;\n            },\n            visitImplicitReceiver(ast) {\n                return false;\n            },\n            visitThisReceiver(ast) {\n                return false;\n            },\n            visitInterpolation(ast) {\n                return visitSome(this, ast.expressions);\n            },\n            visitKeyedRead(ast) {\n                return false;\n            },\n            visitKeyedWrite(ast) {\n                return false;\n            },\n            visitLiteralArray(ast) {\n                return true;\n            },\n            visitLiteralMap(ast) {\n                return true;\n            },\n            visitLiteralPrimitive(ast) {\n                return false;\n            },\n            visitPipe(ast) {\n                return true;\n            },\n            visitPrefixNot(ast) {\n                return visit(this, ast.expression);\n            },\n            visitNonNullAssert(ast) {\n                return visit(this, ast.expression);\n            },\n            visitPropertyRead(ast) {\n                return false;\n            },\n            visitPropertyWrite(ast) {\n                return false;\n            },\n            visitQuote(ast) {\n                return false;\n            },\n            visitSafePropertyRead(ast) {\n                return false;\n            },\n            visitSafeKeyedRead(ast) {\n                return false;\n            }\n        });\n    }\n    allocateTemporary() {\n        const tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    }\n    releaseTemporary(temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(`Temporary ${temporary.name} released out of order`);\n        }\n    }\n    /**\n     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n     *\n     * `ParseSpan` objects are relative to the start of the expression.\n     * This method converts these to full `ParseSourceSpan` objects that\n     * show where the span is within the overall source file.\n     *\n     * @param span the relative span to convert.\n     * @returns a `ParseSourceSpan` for the given span or null if no\n     * `baseSourceSpan` was provided to this class.\n     */\n    convertSourceSpan(span) {\n        if (this.baseSourceSpan) {\n            const start = this.baseSourceSpan.start.moveBy(span.start);\n            const end = this.baseSourceSpan.start.moveBy(span.end);\n            const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n            return new ParseSourceSpan(start, end, fullStart);\n        }\n        else {\n            return null;\n        }\n    }\n    /** Adds the name of an AST to the list of implicit receiver accesses. */\n    addImplicitReceiverAccess(name) {\n        if (this.implicitReceiverAccesses) {\n            this.implicitReceiverAccesses.add(name);\n        }\n    }\n}\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        arg.forEach((entry) => flattenStatements(entry, output));\n    }\n    else {\n        output.push(arg);\n    }\n}\nclass DefaultLocalResolver {\n    constructor(globals) {\n        this.globals = globals;\n    }\n    notifyImplicitReceiverUse() { }\n    maybeRestoreView() { }\n    getLocal(name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    }\n}\nclass BuiltinFunctionCall extends Call {\n    constructor(span, sourceSpan, args, converter) {\n        super(span, sourceSpan, new EmptyExpr(span, sourceSpan), args, null);\n        this.converter = converter;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n *\n * Please make sure to keep to edits in sync with the source file.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\n  this feature.\n\n  By default, rules are prefixed with the host element tag name\n  as a descendant selector. This ensures styling does not leak out of the 'top'\n  of the element's ShadowDOM. For example,\n\n  div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n  x-foo div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\n  selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\nclass ShadowCss {\n    constructor() {\n        this.strictStyling = true;\n    }\n    /*\n     * Shim some cssText with the given selector. Returns cssText that can\n     * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\n     *\n     * When strictStyling is true:\n     * - selector is the attribute added to all elements inside the host,\n     * - hostSelector is the attribute added to the host itself.\n     */\n    shimCssText(cssText, selector, hostSelector = '') {\n        const commentsWithHash = extractCommentsWithHash(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n        return [scopedCssText, ...commentsWithHash].join('\\n');\n    }\n    _insertDirectives(cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    }\n    /*\n     * Process styles to convert native ShadowDOM rules that will trip\n     * up the css parser; we rely on decorating the stylesheet with inert rules.\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-next-selector { content: ':host menu-item'; }\n     * ::content menu-item {\n     *\n     * to this:\n     *\n     * scopeName menu-item {\n     *\n     **/\n    _insertPolyfillDirectivesInCssText(cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentNextSelectorRe, function (...m) {\n            return m[2] + '{';\n        });\n    }\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-rule {\n     *   content: ':host menu-item';\n     * ...\n     * }\n     *\n     * to this:\n     *\n     * scopeName menu-item {...}\n     *\n     **/\n    _insertPolyfillRulesInCssText(cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentRuleRe, (...m) => {\n            const rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    }\n    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n     *\n     *  .foo {... }\n     *\n     *  and converts this to\n     *\n     *  scopeName .foo { ... }\n     */\n    _scopeCssText(cssText, scopeSelector, hostSelector) {\n        const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    }\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n     * occasions, e.g. -webkit-calc on Safari.)\n     * For example, we convert this rule:\n     *\n     * @polyfill-unscoped-rule {\n     *   content: 'menu-item';\n     * ... }\n     *\n     * to this:\n     *\n     * menu-item {...}\n     *\n     **/\n    _extractUnscopedRulesFromCssText(cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        let r = '';\n        let m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    }\n    /*\n     * convert a rule like :host(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar\n     */\n    _convertColonHost(cssText) {\n        return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {\n            if (hostSelectors) {\n                const convertedSelectors = [];\n                const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());\n                for (const hostSelector of hostSelectorArray) {\n                    if (!hostSelector)\n                        break;\n                    const convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n                    convertedSelectors.push(convertedSelector);\n                }\n                return convertedSelectors.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + otherSelectors;\n            }\n        });\n    }\n    /*\n     * convert a rule like :host-context(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n     *\n     * and\n     *\n     * :host-context(.foo:host) .bar { ... }\n     *\n     * to\n     *\n     * .foo<scopeName> .bar { ... }\n     */\n    _convertColonHostContext(cssText) {\n        return cssText.replace(_cssColonHostContextReGlobal, selectorText => {\n            var _a;\n            // We have captured a selector that contains a `:host-context` rule.\n            // For backward compatibility `:host-context` may contain a comma separated list of selectors.\n            // Each context selector group will contain a list of host-context selectors that must match\n            // an ancestor of the host.\n            // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\n            const contextSelectorGroups = [[]];\n            // There may be more than `:host-context` in this selector so `selectorText` could look like:\n            // `:host-context(.one):host-context(.two)`.\n            // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n            // `:host-context` selectors from this selector.\n            let match;\n            while (match = _cssColonHostContextRe.exec(selectorText)) {\n                // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n                // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\n                const newContextSelectors = ((_a = match[1]) !== null && _a !== void 0 ? _a : '').trim().split(',').map(m => m.trim()).filter(m => m !== '');\n                // We must duplicate the current selector group for each of these new selectors.\n                // For example if the current groups are:\n                // ```\n                // [\n                //   ['a', 'b', 'c'],\n                //   ['x', 'y', 'z'],\n                // ]\n                // ```\n                // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\n                // groups are:\n                // ```\n                // [\n                //   ['a', 'b', 'c', 'm'],\n                //   ['x', 'y', 'z', 'm'],\n                //   ['a', 'b', 'c', 'n'],\n                //   ['x', 'y', 'z', 'n'],\n                // ]\n                // ```\n                const contextSelectorGroupsLength = contextSelectorGroups.length;\n                repeatGroups(contextSelectorGroups, newContextSelectors.length);\n                for (let i = 0; i < newContextSelectors.length; i++) {\n                    for (let j = 0; j < contextSelectorGroupsLength; j++) {\n                        contextSelectorGroups[j + (i * contextSelectorGroupsLength)].push(newContextSelectors[i]);\n                    }\n                }\n                // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\n                selectorText = match[2];\n            }\n            // The context selectors now must be combined with each other to capture all the possible\n            // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more\n            // info about how this is done.\n            return contextSelectorGroups\n                .map(contextSelectors => combineHostContextSelectors(contextSelectors, selectorText))\n                .join(', ');\n        });\n    }\n    /*\n     * Convert combinators like ::shadow and pseudo-elements like ::content\n     * by replacing with space.\n     */\n    _convertShadowDOMSelectors(cssText) {\n        return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n    }\n    // change a selector like 'div' to 'name div'\n    _scopeSelectors(cssText, scopeSelector, hostSelector) {\n        return processRules(cssText, (rule) => {\n            let selector = rule.selector;\n            let content = rule.content;\n            if (rule.selector[0] !== '@') {\n                selector =\n                    this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@document')) {\n                content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n                content = this._stripScopingSelectors(rule.content);\n            }\n            return new CssRule(selector, content);\n        });\n    }\n    /**\n     * Handle a css text that is within a rule that should not contain scope selectors by simply\n     * removing them! An example of such a rule is `@font-face`.\n     *\n     * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\n     * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\n     * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\n     * can end up with broken css if the imported styles happen to contain @font-face rules.\n     *\n     * For example:\n     *\n     * ```\n     * :host ::ng-deep {\n     *   import 'some/lib/containing/font-face';\n     * }\n     *\n     * Similar logic applies to `@page` rules which can contain a particular set of properties,\n     * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\n     * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\n     * ```\n     */\n    _stripScopingSelectors(cssText) {\n        return processRules(cssText, rule => {\n            const selector = rule.selector.replace(_shadowDeepSelectors, ' ')\n                .replace(_polyfillHostNoCombinatorRe, ' ');\n            return new CssRule(selector, rule.content);\n        });\n    }\n    _scopeSelector(selector, scopeSelector, hostSelector, strict) {\n        return selector.split(',')\n            .map(part => part.trim().split(_shadowDeepSelectors))\n            .map((deepParts) => {\n            const [shallowPart, ...otherParts] = deepParts;\n            const applyScope = (shallowPart) => {\n                if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return strict ?\n                        this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                        this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return [applyScope(shallowPart), ...otherParts].join(' ');\n        })\n            .join(', ');\n    }\n    _selectorNeedsScoping(selector, scopeSelector) {\n        const re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    }\n    _makeScopeMatcher(scopeSelector) {\n        const lre = /\\[/g;\n        const rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    }\n    _applySelectorScope(selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    }\n    // scope via name and [is=name]\n    _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, (hnc, selector) => {\n                return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {\n                    return before + replaceBy + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    }\n    // return a selector with [name] suffix on each simple selector\n    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n    _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {\n        const isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);\n        const attrName = '[' + scopeSelector + ']';\n        const _scopeSelectorPart = (p) => {\n            let scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                const t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    const matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        const safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        let scopedSelector = '';\n        let startIndex = 0;\n        let res;\n        const sep = /( |>|\\+|~(?!=))\\s*/g;\n        // If a selector appears before :host it should not be shimmed as it\n        // matches on ancestor elements and not on elements in the host's shadow\n        // `:host-context(div)` is transformed to\n        // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n        // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n        // Historically `component-tag:host` was matching the component so we also want to preserve\n        // this behavior to avoid breaking legacy apps (it should not match).\n        // The behavior should be:\n        // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n        // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n        //   `:host-context(tag)`)\n        const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n        // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n        let shouldScope = !hasHost;\n        while ((res = sep.exec(selector)) !== null) {\n            const separator = res[1];\n            const part = selector.slice(startIndex, res.index).trim();\n            shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n            const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n            scopedSelector += `${scopedPart} ${separator} `;\n            startIndex = sep.lastIndex;\n        }\n        const part = selector.substring(startIndex);\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    }\n    _insertPolyfillHostInCssText(selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    }\n}\nclass SafeSelector {\n    constructor(selector) {\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n        // CSS allows for certain special characters to be used in selectors if they're escaped.\n        // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\n        // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\n        // Replace all escape sequences (`\\` followed by a character) with a placeholder so\n        // that our handling of pseudo-selectors doesn't mess with them.\n        selector = this._escapeRegexMatches(selector, /(\\\\.)/g);\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n            const replaceBy = `__ph-${this.index}__`;\n            this.placeholders.push(exp);\n            this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    restore(content) {\n        return content.replace(/__ph-(\\d+)__/g, (_ph, index) => this.placeholders[+index]);\n    }\n    content() {\n        return this._content;\n    }\n    /**\n     * Replaces all of the substrings that match a regex within a\n     * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\n     */\n    _escapeRegexMatches(content, pattern) {\n        return content.replace(pattern, (_, keep) => {\n            const replaceBy = `__ph-${this.index}__`;\n            this.placeholders.push(keep);\n            this.index++;\n            return replaceBy;\n        });\n    }\n}\nconst _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _parenSuffix = '(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\nconst _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\nconst _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    // Deprecated selectors\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nfunction extractCommentsWithHash(input) {\n    return input.match(_commentWithHashRe) || [];\n}\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst QUOTE_PLACEHOLDER = '%QUOTED%';\nconst _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nconst _quotedRe = /%QUOTED%/g;\nconst CONTENT_PAIRS = new Map([['{', '}']]);\nconst QUOTE_PAIRS = new Map([[`\"`, `\"`], [`'`, `'`]]);\nclass CssRule {\n    constructor(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n}\nfunction processRules(input, ruleCallback) {\n    const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);\n    const inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n    let nextBlockIndex = 0;\n    let nextQuoteIndex = 0;\n    return inputWithEscapedBlocks.escapedString\n        .replace(_ruleRe, (...m) => {\n        const selector = m[2];\n        let content = '';\n        let suffix = m[4];\n        let contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        const rule = ruleCallback(new CssRule(selector, content));\n        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n    })\n        .replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);\n}\nclass StringWithEscapedBlocks {\n    constructor(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n}\nfunction escapeBlocks(input, charPairs, placeholder) {\n    const resultParts = [];\n    const escapedBlocks = [];\n    let openCharCount = 0;\n    let nonBlockStartIndex = 0;\n    let blockStartIndex = -1;\n    let openChar;\n    let closeChar;\n    for (let i = 0; i < input.length; i++) {\n        const char = input[i];\n        if (char === '\\\\') {\n            i++;\n        }\n        else if (char === closeChar) {\n            openCharCount--;\n            if (openCharCount === 0) {\n                escapedBlocks.push(input.substring(blockStartIndex, i));\n                resultParts.push(placeholder);\n                nonBlockStartIndex = i;\n                blockStartIndex = -1;\n                openChar = closeChar = undefined;\n            }\n        }\n        else if (char === openChar) {\n            openCharCount++;\n        }\n        else if (openCharCount === 0 && charPairs.has(char)) {\n            openChar = char;\n            closeChar = charPairs.get(char);\n            openCharCount = 1;\n            blockStartIndex = i + 1;\n            resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n        }\n    }\n    if (blockStartIndex !== -1) {\n        escapedBlocks.push(input.substring(blockStartIndex));\n        resultParts.push(placeholder);\n    }\n    else {\n        resultParts.push(input.substring(nonBlockStartIndex));\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n/**\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n * to create a selector that matches the same as `:host-context()`.\n *\n * Given a single context selector `A` we need to output selectors that match on the host and as an\n * ancestor of the host:\n *\n * ```\n * A <hostMarker>, A<hostMarker> {}\n * ```\n *\n * When there is more than one context selector we also have to create combinations of those\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\n *\n * ```\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n * ```\n *\n * And so on...\n *\n * @param hostMarker the string that selects the host element.\n * @param contextSelectors an array of context selectors that will be combined.\n * @param otherSelectors the rest of the selectors that are not context selectors.\n */\nfunction combineHostContextSelectors(contextSelectors, otherSelectors) {\n    const hostMarker = _polyfillHostNoCombinator;\n    _polyfillHostRe.lastIndex = 0; // reset the regex to ensure we get an accurate test\n    const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n    // If there are no context selectors then just output a host marker\n    if (contextSelectors.length === 0) {\n        return hostMarker + otherSelectors;\n    }\n    const combined = [contextSelectors.pop() || ''];\n    while (contextSelectors.length > 0) {\n        const length = combined.length;\n        const contextSelector = contextSelectors.pop();\n        for (let i = 0; i < length; i++) {\n            const previousSelectors = combined[i];\n            // Add the new selector as a descendant of the previous selectors\n            combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n            // Add the new selector as an ancestor of the previous selectors\n            combined[length + i] = contextSelector + ' ' + previousSelectors;\n            // Add the new selector to act on the same element as the previous selectors\n            combined[i] = contextSelector + previousSelectors;\n        }\n    }\n    // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n    // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n    return combined\n        .map(s => otherSelectorsHasHost ?\n        `${s}${otherSelectors}` :\n        `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\n        .join(',');\n}\n/**\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\n * stored.\n *\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\n * newly added groups will be clones of the original.\n *\n * @param groups An array of groups of strings that will be repeated. This array is mutated\n *     in-place.\n * @param multiples The number of times the current groups should appear.\n */\nfunction repeatGroups(groups, multiples) {\n    const length = groups.length;\n    for (let i = 1; i < multiples; i++) {\n        for (let j = 0; j < length; j++) {\n            groups[j + (i * length)] = groups[j].slice(0);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nfunction parse(value) {\n    // we use a string array here instead of a string map\n    // because a string-map is not guaranteed to retain the\n    // order of the entries whereas a string array can be\n    // constructed in a [key, value, key, value] format.\n    const styles = [];\n    let i = 0;\n    let parenDepth = 0;\n    let quote = 0 /* QuoteNone */;\n    let valueStart = 0;\n    let propStart = 0;\n    let currentProp = null;\n    let valueHasQuotes = false;\n    while (i < value.length) {\n        const token = value.charCodeAt(i++);\n        switch (token) {\n            case 40 /* OpenParen */:\n                parenDepth++;\n                break;\n            case 41 /* CloseParen */:\n                parenDepth--;\n                break;\n            case 39 /* QuoteSingle */:\n                // valueStart needs to be there since prop values don't\n                // have quotes in CSS\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\n                if (quote === 0 /* QuoteNone */) {\n                    quote = 39 /* QuoteSingle */;\n                }\n                else if (quote === 39 /* QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {\n                    quote = 0 /* QuoteNone */;\n                }\n                break;\n            case 34 /* QuoteDouble */:\n                // same logic as above\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\n                if (quote === 0 /* QuoteNone */) {\n                    quote = 34 /* QuoteDouble */;\n                }\n                else if (quote === 34 /* QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {\n                    quote = 0 /* QuoteNone */;\n                }\n                break;\n            case 58 /* Colon */:\n                if (!currentProp && parenDepth === 0 && quote === 0 /* QuoteNone */) {\n                    currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n                    valueStart = i;\n                }\n                break;\n            case 59 /* Semicolon */:\n                if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* QuoteNone */) {\n                    const styleVal = value.substring(valueStart, i - 1).trim();\n                    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n                    propStart = i;\n                    valueStart = 0;\n                    currentProp = null;\n                    valueHasQuotes = false;\n                }\n                break;\n        }\n    }\n    if (currentProp && valueStart) {\n        const styleVal = value.substr(valueStart).trim();\n        styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n    }\n    return styles;\n}\nfunction stripUnnecessaryQuotes(value) {\n    const qS = value.charCodeAt(0);\n    const qE = value.charCodeAt(value.length - 1);\n    if (qS == qE && (qS == 39 /* QuoteSingle */ || qS == 34 /* QuoteDouble */)) {\n        const tempValue = value.substring(1, value.length - 1);\n        // special case to avoid using a multi-quoted string that was just chomped\n        // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n        if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n            value = tempValue;\n        }\n    }\n    return value;\n}\nfunction hyphenate(value) {\n    return value\n        .replace(/[a-z][A-Z]/g, v => {\n        return v.charAt(0) + '-' + v.charAt(1);\n    })\n        .toLowerCase();\n}\n\nconst IMPORTANT_FLAG = '!important';\n/**\n * Minimum amount of binding slots required in the runtime for style/class bindings.\n *\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n * record binding data, property information and metadata.\n *\n * When a binding is registered it will place the following information in the `LView`:\n *\n * slot 1) binding value\n * slot 2) cached value (all other values collected before it in string form)\n *\n * When a binding is registered it will place the following information in the `TData`:\n *\n * slot 1) prop name\n * slot 2) binding index that points to the previous style/class binding (and some extra config\n * values)\n *\n * Let's imagine we have a binding that looks like so:\n *\n * ```\n * <div [style.width]=\"x\" [style.height]=\"y\">\n * ```\n *\n * Our `LView` and `TData` data-structures look like so:\n *\n * ```typescript\n * LView = [\n *   // ...\n *   x, // value of x\n *   \"width: x\",\n *\n *   y, // value of y\n *   \"width: x; height: y\",\n *   // ...\n * ];\n *\n * TData = [\n *   // ...\n *   \"width\", // binding slot 20\n *   0,\n *\n *   \"height\",\n *   20,\n *   // ...\n * ];\n * ```\n *\n * */\nconst MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nclass StylingBuilder {\n    constructor(_directiveExpr) {\n        this._directiveExpr = _directiveExpr;\n        /** Whether or not there are any static styling values present */\n        this._hasInitialValues = false;\n        /**\n         *  Whether or not there are any styling bindings present\n         *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n         */\n        this.hasBindings = false;\n        this.hasBindingsWithPipes = false;\n        /** the input for [class] (if it exists) */\n        this._classMapInput = null;\n        /** the input for [style] (if it exists) */\n        this._styleMapInput = null;\n        /** an array of each [style.prop] input */\n        this._singleStyleInputs = null;\n        /** an array of each [class.name] input */\n        this._singleClassInputs = null;\n        this._lastStylingInput = null;\n        this._firstStylingInput = null;\n        // maps are used instead of hash maps because a Map will\n        // retain the ordering of the keys\n        /**\n         * Represents the location of each style binding in the template\n         * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n         * that `width=0` and `height=1`)\n         */\n        this._stylesIndex = new Map();\n        /**\n         * Represents the location of each class binding in the template\n         * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n         * that `big=0` and `hidden=1`)\n         */\n        this._classesIndex = new Map();\n        this._initialStyleValues = [];\n        this._initialClassValues = [];\n    }\n    /**\n     * Registers a given input to the styling builder to be later used when producing AOT code.\n     *\n     * The code below will only accept the input if it is somehow tied to styling (whether it be\n     * style/class bindings or static style/class attributes).\n     */\n    registerBoundInput(input) {\n        // [attr.style] or [attr.class] are skipped in the code below,\n        // they should not be treated as styling-based bindings since\n        // they are intended to be written directly to the attr and\n        // will therefore skip all style/class resolution that is present\n        // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n        // [class.prop]=\"\". [class]=\"\" assignments\n        let binding = null;\n        let name = input.name;\n        switch (input.type) {\n            case 0 /* Property */:\n                binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n                break;\n            case 3 /* Style */:\n                binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n                break;\n            case 2 /* Class */:\n                binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n                break;\n        }\n        return binding ? true : false;\n    }\n    registerInputBasedOnName(name, expression, sourceSpan) {\n        let binding = null;\n        const prefix = name.substring(0, 6);\n        const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n        const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n        if (isStyle || isClass) {\n            const isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no\n            const property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1\n            if (isStyle) {\n                binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n            }\n            else {\n                binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n            }\n        }\n        return binding;\n    }\n    registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        // CSS custom properties are case-sensitive so we shouldn't normalize them.\n        // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n        if (!isCssCustomProperty(name)) {\n            name = hyphenate(name);\n        }\n        const { property, hasOverrideFlag, suffix: bindingSuffix } = parseProperty(name);\n        suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n        const entry = { name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag };\n        if (isMapBased) {\n            this._styleMapInput = entry;\n        }\n        else {\n            (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n            registerIntoMap(this._stylesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this._checkForPipes(value);\n        this.hasBindings = true;\n        return entry;\n    }\n    registerClassInput(name, isMapBased, value, sourceSpan) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        const { property, hasOverrideFlag } = parseProperty(name);\n        const entry = { name: property, value, sourceSpan, hasOverrideFlag, suffix: null };\n        if (isMapBased) {\n            this._classMapInput = entry;\n        }\n        else {\n            (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n            registerIntoMap(this._classesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this._checkForPipes(value);\n        this.hasBindings = true;\n        return entry;\n    }\n    _checkForPipes(value) {\n        if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {\n            this.hasBindingsWithPipes = true;\n        }\n    }\n    /**\n     * Registers the element's static style string value to the builder.\n     *\n     * @param value the style string (e.g. `width:100px; height:200px;`)\n     */\n    registerStyleAttr(value) {\n        this._initialStyleValues = parse(value);\n        this._hasInitialValues = true;\n    }\n    /**\n     * Registers the element's static class string value to the builder.\n     *\n     * @param value the className string (e.g. `disabled gold zoom`)\n     */\n    registerClassAttr(value) {\n        this._initialClassValues = value.trim().split(/\\s+/g);\n        this._hasInitialValues = true;\n    }\n    /**\n     * Appends all styling-related expressions to the provided attrs array.\n     *\n     * @param attrs an existing array where each of the styling expressions\n     * will be inserted into.\n     */\n    populateInitialStylingAttrs(attrs) {\n        // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n        if (this._initialClassValues.length) {\n            attrs.push(literal(1 /* Classes */));\n            for (let i = 0; i < this._initialClassValues.length; i++) {\n                attrs.push(literal(this._initialClassValues[i]));\n            }\n        }\n        // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n        if (this._initialStyleValues.length) {\n            attrs.push(literal(2 /* Styles */));\n            for (let i = 0; i < this._initialStyleValues.length; i += 2) {\n                attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));\n            }\n        }\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n     *\n     * The instruction generation code below is used for producing the AOT statement code which is\n     * responsible for registering initial styles (within a directive hostBindings' creation block),\n     * as well as any of the provided attribute values, to the directive host element.\n     */\n    assignHostAttrs(attrs, definitionMap) {\n        if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n            this.populateInitialStylingAttrs(attrs);\n            definitionMap.set('hostAttrs', literalArr(attrs));\n        }\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `classMap`.\n     *\n     * The instruction data will contain all expressions for `classMap` to function\n     * which includes the `[class]` expression params.\n     */\n    buildClassMapInstruction(valueConverter) {\n        if (this._classMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n        }\n        return null;\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `styleMap`.\n     *\n     * The instruction data will contain all expressions for `styleMap` to function\n     * which includes the `[style]` expression params.\n     */\n    buildStyleMapInstruction(valueConverter) {\n        if (this._styleMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n        }\n        return null;\n    }\n    _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {\n        // each styling binding value is stored in the LView\n        // map-based bindings allocate two slots: one for the\n        // previous binding value and another for the previous\n        // className or style attribute value.\n        let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n        // these values must be outside of the update block so that they can\n        // be evaluated (the AST visit call) during creation time so that any\n        // pipes can be picked up in time before the template is built\n        const mapValue = stylingInput.value.visit(valueConverter);\n        let reference;\n        if (mapValue instanceof Interpolation) {\n            totalBindingSlotsRequired += mapValue.expressions.length;\n            reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :\n                getStyleMapInterpolationExpression(mapValue);\n        }\n        else {\n            reference = isClassBased ? Identifiers$1.classMap : Identifiers$1.styleMap;\n        }\n        return {\n            reference,\n            calls: [{\n                    supportsInterpolation: true,\n                    sourceSpan: stylingInput.sourceSpan,\n                    allocateBindingSlots: totalBindingSlotsRequired,\n                    params: (convertFn) => {\n                        const convertResult = convertFn(mapValue);\n                        const params = Array.isArray(convertResult) ? convertResult : [convertResult];\n                        return params;\n                    }\n                }]\n        };\n    }\n    _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {\n        const instructions = [];\n        inputs.forEach(input => {\n            const previousInstruction = instructions[instructions.length - 1];\n            const value = input.value.visit(valueConverter);\n            let referenceForCall = reference;\n            // each styling binding value is stored in the LView\n            // but there are two values stored for each binding:\n            //   1) the value itself\n            //   2) an intermediate value (concatenation of style up to this point).\n            //      We need to store the intermediate value so that we don't allocate\n            //      the strings on each CD.\n            let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n            if (value instanceof Interpolation) {\n                totalBindingSlotsRequired += value.expressions.length;\n                if (getInterpolationExpressionFn) {\n                    referenceForCall = getInterpolationExpressionFn(value);\n                }\n            }\n            const call = {\n                sourceSpan: input.sourceSpan,\n                allocateBindingSlots: totalBindingSlotsRequired,\n                supportsInterpolation: !!getInterpolationExpressionFn,\n                params: (convertFn) => {\n                    // params => stylingProp(propName, value, suffix)\n                    const params = [];\n                    params.push(literal(input.name));\n                    const convertResult = convertFn(value);\n                    if (Array.isArray(convertResult)) {\n                        params.push(...convertResult);\n                    }\n                    else {\n                        params.push(convertResult);\n                    }\n                    // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n                    // if that is detected then we need to pass that in as an optional param.\n                    if (!isClassBased && input.suffix !== null) {\n                        params.push(literal(input.suffix));\n                    }\n                    return params;\n                }\n            };\n            // If we ended up generating a call to the same instruction as the previous styling property\n            // we can chain the calls together safely to save some bytes, otherwise we have to generate\n            // a separate instruction call. This is primarily a concern with interpolation instructions\n            // where we may start off with one `reference`, but end up using another based on the\n            // number of interpolations.\n            if (previousInstruction && previousInstruction.reference === referenceForCall) {\n                previousInstruction.calls.push(call);\n            }\n            else {\n                instructions.push({ reference: referenceForCall, calls: [call] });\n            }\n        });\n        return instructions;\n    }\n    _buildClassInputs(valueConverter) {\n        if (this._singleClassInputs) {\n            return this._buildSingleInputs(Identifiers$1.classProp, this._singleClassInputs, valueConverter, null, true);\n        }\n        return [];\n    }\n    _buildStyleInputs(valueConverter) {\n        if (this._singleStyleInputs) {\n            return this._buildSingleInputs(Identifiers$1.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);\n        }\n        return [];\n    }\n    /**\n     * Constructs all instructions which contain the expressions that will be placed\n     * into the update block of a template function or a directive hostBindings function.\n     */\n    buildUpdateLevelInstructions(valueConverter) {\n        const instructions = [];\n        if (this.hasBindings) {\n            const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n            if (styleMapInstruction) {\n                instructions.push(styleMapInstruction);\n            }\n            const classMapInstruction = this.buildClassMapInstruction(valueConverter);\n            if (classMapInstruction) {\n                instructions.push(classMapInstruction);\n            }\n            instructions.push(...this._buildStyleInputs(valueConverter));\n            instructions.push(...this._buildClassInputs(valueConverter));\n        }\n        return instructions;\n    }\n}\nfunction registerIntoMap(map, key) {\n    if (!map.has(key)) {\n        map.set(key, map.size);\n    }\n}\nfunction parseProperty(name) {\n    let hasOverrideFlag = false;\n    const overrideIndex = name.indexOf(IMPORTANT_FLAG);\n    if (overrideIndex !== -1) {\n        name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n        hasOverrideFlag = true;\n    }\n    let suffix = null;\n    let property = name;\n    const unitIndex = name.lastIndexOf('.');\n    if (unitIndex > 0) {\n        suffix = name.substr(unitIndex + 1);\n        property = name.substring(0, unitIndex);\n    }\n    return { property, suffix, hasOverrideFlag };\n}\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\nfunction getClassMapInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.classMap;\n        case 3:\n            return Identifiers$1.classMapInterpolate1;\n        case 5:\n            return Identifiers$1.classMapInterpolate2;\n        case 7:\n            return Identifiers$1.classMapInterpolate3;\n        case 9:\n            return Identifiers$1.classMapInterpolate4;\n        case 11:\n            return Identifiers$1.classMapInterpolate5;\n        case 13:\n            return Identifiers$1.classMapInterpolate6;\n        case 15:\n            return Identifiers$1.classMapInterpolate7;\n        case 17:\n            return Identifiers$1.classMapInterpolate8;\n        default:\n            return Identifiers$1.classMapInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated style map.\n * @param interpolation An Interpolation AST\n */\nfunction getStyleMapInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.styleMap;\n        case 3:\n            return Identifiers$1.styleMapInterpolate1;\n        case 5:\n            return Identifiers$1.styleMapInterpolate2;\n        case 7:\n            return Identifiers$1.styleMapInterpolate3;\n        case 9:\n            return Identifiers$1.styleMapInterpolate4;\n        case 11:\n            return Identifiers$1.styleMapInterpolate5;\n        case 13:\n            return Identifiers$1.styleMapInterpolate6;\n        case 15:\n            return Identifiers$1.styleMapInterpolate7;\n        case 17:\n            return Identifiers$1.styleMapInterpolate8;\n        default:\n            return Identifiers$1.styleMapInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\nfunction getStylePropInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.styleProp;\n        case 3:\n            return Identifiers$1.stylePropInterpolate1;\n        case 5:\n            return Identifiers$1.stylePropInterpolate2;\n        case 7:\n            return Identifiers$1.stylePropInterpolate3;\n        case 9:\n            return Identifiers$1.stylePropInterpolate4;\n        case 11:\n            return Identifiers$1.stylePropInterpolate5;\n        case 13:\n            return Identifiers$1.stylePropInterpolate6;\n        case 15:\n            return Identifiers$1.stylePropInterpolate7;\n        case 17:\n            return Identifiers$1.stylePropInterpolate8;\n        default:\n            return Identifiers$1.stylePropInterpolateV;\n    }\n}\n/**\n * Checks whether property name is a custom CSS property.\n * See: https://www.w3.org/TR/css-variables-1\n */\nfunction isCssCustomProperty(name) {\n    return name.startsWith('--');\n}\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TokenType;\n(function (TokenType) {\n    TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n    TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n    TokenType[TokenType[\"PrivateIdentifier\"] = 2] = \"PrivateIdentifier\";\n    TokenType[TokenType[\"Keyword\"] = 3] = \"Keyword\";\n    TokenType[TokenType[\"String\"] = 4] = \"String\";\n    TokenType[TokenType[\"Operator\"] = 5] = \"Operator\";\n    TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n    TokenType[TokenType[\"Error\"] = 7] = \"Error\";\n})(TokenType || (TokenType = {}));\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nclass Lexer {\n    tokenize(text) {\n        const scanner = new _Scanner(text);\n        const tokens = [];\n        let token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    }\n}\nclass Token {\n    constructor(index, end, type, numValue, strValue) {\n        this.index = index;\n        this.end = end;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    isCharacter(code) {\n        return this.type == TokenType.Character && this.numValue == code;\n    }\n    isNumber() {\n        return this.type == TokenType.Number;\n    }\n    isString() {\n        return this.type == TokenType.String;\n    }\n    isOperator(operator) {\n        return this.type == TokenType.Operator && this.strValue == operator;\n    }\n    isIdentifier() {\n        return this.type == TokenType.Identifier;\n    }\n    isPrivateIdentifier() {\n        return this.type == TokenType.PrivateIdentifier;\n    }\n    isKeyword() {\n        return this.type == TokenType.Keyword;\n    }\n    isKeywordLet() {\n        return this.type == TokenType.Keyword && this.strValue == 'let';\n    }\n    isKeywordAs() {\n        return this.type == TokenType.Keyword && this.strValue == 'as';\n    }\n    isKeywordNull() {\n        return this.type == TokenType.Keyword && this.strValue == 'null';\n    }\n    isKeywordUndefined() {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    }\n    isKeywordTrue() {\n        return this.type == TokenType.Keyword && this.strValue == 'true';\n    }\n    isKeywordFalse() {\n        return this.type == TokenType.Keyword && this.strValue == 'false';\n    }\n    isKeywordThis() {\n        return this.type == TokenType.Keyword && this.strValue == 'this';\n    }\n    isError() {\n        return this.type == TokenType.Error;\n    }\n    toNumber() {\n        return this.type == TokenType.Number ? this.numValue : -1;\n    }\n    toString() {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.PrivateIdentifier:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    }\n}\nfunction newCharacterToken(index, end, code) {\n    return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\nfunction newIdentifierToken(index, end, text) {\n    return new Token(index, end, TokenType.Identifier, 0, text);\n}\nfunction newPrivateIdentifierToken(index, end, text) {\n    return new Token(index, end, TokenType.PrivateIdentifier, 0, text);\n}\nfunction newKeywordToken(index, end, text) {\n    return new Token(index, end, TokenType.Keyword, 0, text);\n}\nfunction newOperatorToken(index, end, text) {\n    return new Token(index, end, TokenType.Operator, 0, text);\n}\nfunction newStringToken(index, end, text) {\n    return new Token(index, end, TokenType.String, 0, text);\n}\nfunction newNumberToken(index, end, n) {\n    return new Token(index, end, TokenType.Number, n, '');\n}\nfunction newErrorToken(index, end, message) {\n    return new Token(index, end, TokenType.Error, 0, message);\n}\nconst EOF = new Token(-1, -1, TokenType.Character, 0, '');\nclass _Scanner {\n    constructor(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    advance() {\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    }\n    scanToken() {\n        const input = this.input, length = this.length;\n        let peek = this.peek, index = this.index;\n        // Skip whitespace.\n        while (peek <= $SPACE) {\n            if (++index >= length) {\n                peek = $EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (isDigit(peek))\n            return this.scanNumber(index);\n        const start = index;\n        switch (peek) {\n            case $PERIOD:\n                this.advance();\n                return isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, this.index, $PERIOD);\n            case $LPAREN:\n            case $RPAREN:\n            case $LBRACE:\n            case $RBRACE:\n            case $LBRACKET:\n            case $RBRACKET:\n            case $COMMA:\n            case $COLON:\n            case $SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case $SQ:\n            case $DQ:\n                return this.scanString();\n            case $HASH:\n                return this.scanPrivateIdentifier();\n            case $PLUS:\n            case $MINUS:\n            case $STAR:\n            case $SLASH:\n            case $PERCENT:\n            case $CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case $QUESTION:\n                return this.scanQuestion(start);\n            case $LT:\n            case $GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n            case $BANG:\n            case $EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n            case $AMPERSAND:\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n            case $BAR:\n                return this.scanComplexOperator(start, '|', $BAR, '|');\n            case $NBSP:\n                while (isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n    }\n    scanCharacter(start, code) {\n        this.advance();\n        return newCharacterToken(start, this.index, code);\n    }\n    scanOperator(start, str) {\n        this.advance();\n        return newOperatorToken(start, this.index, str);\n    }\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     */\n    scanComplexOperator(start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        let str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, this.index, str);\n    }\n    scanIdentifier() {\n        const start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        const str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :\n            newIdentifierToken(start, this.index, str);\n    }\n    /** Scans an ECMAScript private identifier. */\n    scanPrivateIdentifier() {\n        const start = this.index;\n        this.advance();\n        if (!isIdentifierStart(this.peek)) {\n            return this.error('Invalid character [#]', -1);\n        }\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        const identifierName = this.input.substring(start, this.index);\n        return newPrivateIdentifierToken(start, this.index, identifierName);\n    }\n    scanNumber(start) {\n        let simple = (this.index === start);\n        let hasSeparators = false;\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (isDigit(this.peek)) {\n                // Do nothing.\n            }\n            else if (this.peek === $_) {\n                // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is\n                // valid while `_101` and `101_` are not. The separator can't be next to the decimal\n                // point or another separator either. Note that it's unlikely that we'll hit a case where\n                // the underscore is at the start, because that's a valid identifier and it will be picked\n                // up earlier in the parsing. We validate for it anyway just in case.\n                if (!isDigit(this.input.charCodeAt(this.index - 1)) ||\n                    !isDigit(this.input.charCodeAt(this.index + 1))) {\n                    return this.error('Invalid numeric separator', 0);\n                }\n                hasSeparators = true;\n            }\n            else if (this.peek === $PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        let str = this.input.substring(start, this.index);\n        if (hasSeparators) {\n            str = str.replace(/_/g, '');\n        }\n        const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, this.index, value);\n    }\n    scanString() {\n        const start = this.index;\n        const quote = this.peek;\n        this.advance(); // Skip initial quote.\n        let buffer = '';\n        let marker = this.index;\n        const input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == $BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                let unescapedCode;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == $u) {\n                    // 4 character hex code for unicode character.\n                    const hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n                    }\n                    for (let i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == $EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        const last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, this.index, buffer + last);\n    }\n    scanQuestion(start) {\n        this.advance();\n        let str = '?';\n        // Either `a ?? b` or 'a?.b'.\n        if (this.peek === $QUESTION || this.peek === $PERIOD) {\n            str += this.peek === $PERIOD ? '.' : '?';\n            this.advance();\n        }\n        return newOperatorToken(start, this.index, str);\n    }\n    error(message, offset) {\n        const position = this.index + offset;\n        return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n    }\n}\nfunction isIdentifierStart(code) {\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n        (code == $_) || (code == $$);\n}\nfunction isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    const scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== $EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\nfunction isIdentifierPart(code) {\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n        (code == $$);\n}\nfunction isExponentStart(code) {\n    return code == $e || code == $E;\n}\nfunction isExponentSign(code) {\n    return code == $MINUS || code == $PLUS;\n}\nfunction unescape(code) {\n    switch (code) {\n        case $n:\n            return $LF;\n        case $f:\n            return $FF;\n        case $r:\n            return $CR;\n        case $t:\n            return $TAB;\n        case $v:\n            return $VTAB;\n        default:\n            return code;\n    }\n}\nfunction parseIntAutoRadix(text) {\n    const result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass SplitInterpolation {\n    constructor(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n}\nclass TemplateBindingParseResult {\n    constructor(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n}\nclass Parser$1 {\n    constructor(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n    }\n    parseAction(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, 0)\n            .parseChain();\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n    parseBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n    checkSimpleExpression(ast) {\n        const checker = new SimpleExpressionChecker();\n        ast.visit(checker);\n        return checker.errors;\n    }\n    parseSimpleBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        const errors = this.checkSimpleExpression(ast);\n        if (errors.length > 0) {\n            this._reportError(`Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n        }\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n    _reportError(message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    }\n    _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {\n        // Quotes expressions use 3rd-party expression language. We don't want to use\n        // our lexer or parser for that, so we check for that ahead of time.\n        const quote = this._parseQuote(input, location, absoluteOffset);\n        if (quote != null) {\n            return quote;\n        }\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, 0)\n            .parseChain();\n    }\n    _parseQuote(input, location, absoluteOffset) {\n        if (input == null)\n            return null;\n        const prefixSeparatorIndex = input.indexOf(':');\n        if (prefixSeparatorIndex == -1)\n            return null;\n        const prefix = input.substring(0, prefixSeparatorIndex).trim();\n        if (!isIdentifier(prefix))\n            return null;\n        const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n        const span = new ParseSpan(0, input.length);\n        return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);\n    }\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items\">\n     *         ^      ^ absoluteValueOffset for `templateValue`\n     *         absoluteKeyOffset for `templateKey`\n     * ```\n     * contains three bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     *\n     * This is apparent from the de-sugared template:\n     * ```\n     *   <ng-template ngFor let-item [ngForOf]=\"items\">\n     * ```\n     *\n     * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n     * @param templateValue RHS of the microsyntax attribute\n     * @param templateUrl template filename if it's external, component filename if it's inline\n     * @param absoluteKeyOffset start of the `templateKey`\n     * @param absoluteValueOffset start of the `templateValue`\n     */\n    parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {\n        const tokens = this._lexer.tokenize(templateValue);\n        const parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false /* parseAction */, this.errors, 0 /* relative offset */);\n        return parser.parseTemplateBindings({\n            source: templateKey,\n            span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n        });\n    }\n    parseInterpolation(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const { strings, expressions, offsets } = this.splitInterpolation(input, location, interpolationConfig);\n        if (expressions.length === 0)\n            return null;\n        const expressionNodes = [];\n        for (let i = 0; i < expressions.length; ++i) {\n            const expressionText = expressions[i].text;\n            const sourceToLex = this._stripComments(expressionText);\n            const tokens = this._lexer.tokenize(sourceToLex);\n            const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, offsets[i])\n                .parseChain();\n            expressionNodes.push(ast);\n        }\n        return this.createInterpolationAst(strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);\n    }\n    /**\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n     * This is used for parsing the switch expression in ICUs.\n     */\n    parseInterpolationExpression(expression, location, absoluteOffset) {\n        const sourceToLex = this._stripComments(expression);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        const ast = new _ParseAST(expression, location, absoluteOffset, tokens, sourceToLex.length, \n        /* parseAction */ false, this.errors, 0)\n            .parseChain();\n        const strings = ['', '']; // The prefix and suffix strings are both empty\n        return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\n    }\n    createInterpolationAst(strings, expressions, input, location, absoluteOffset) {\n        const span = new ParseSpan(0, input.length);\n        const interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\n        return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\n    }\n    /**\n     * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n     * the string.\n     * Returns `null` if there are no interpolations, otherwise a\n     * `SplitInterpolation` with splits that look like\n     *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n     */\n    splitInterpolation(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const strings = [];\n        const expressions = [];\n        const offsets = [];\n        let i = 0;\n        let atInterpolation = false;\n        let extendLastString = false;\n        let { start: interpStart, end: interpEnd } = interpolationConfig;\n        while (i < input.length) {\n            if (!atInterpolation) {\n                // parse until starting {{\n                const start = i;\n                i = input.indexOf(interpStart, i);\n                if (i === -1) {\n                    i = input.length;\n                }\n                const text = input.substring(start, i);\n                strings.push({ text, start, end: i });\n                atInterpolation = true;\n            }\n            else {\n                // parse from starting {{ to ending }} while ignoring content inside quotes.\n                const fullStart = i;\n                const exprStart = fullStart + interpStart.length;\n                const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n                if (exprEnd === -1) {\n                    // Could not find the end of the interpolation; do not parse an expression.\n                    // Instead we should extend the content on the last raw string.\n                    atInterpolation = false;\n                    extendLastString = true;\n                    break;\n                }\n                const fullEnd = exprEnd + interpEnd.length;\n                const text = input.substring(exprStart, exprEnd);\n                if (text.trim().length === 0) {\n                    this._reportError('Blank expressions are not allowed in interpolated strings', input, `at column ${i} in`, location);\n                }\n                expressions.push({ text, start: fullStart, end: fullEnd });\n                offsets.push(exprStart);\n                i = fullEnd;\n                atInterpolation = false;\n            }\n        }\n        if (!atInterpolation) {\n            // If we are now at a text section, add the remaining content as a raw string.\n            if (extendLastString) {\n                const piece = strings[strings.length - 1];\n                piece.text += input.substring(i);\n                piece.end = input.length;\n            }\n            else {\n                strings.push({ text: input.substring(i), start: i, end: input.length });\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    }\n    wrapLiteralPrimitive(input, location, absoluteOffset) {\n        const span = new ParseSpan(0, input == null ? 0 : input.length);\n        return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);\n    }\n    _stripComments(input) {\n        const i = this._commentStart(input);\n        return i != null ? input.substring(0, i).trim() : input;\n    }\n    _commentStart(input) {\n        let outerQuote = null;\n        for (let i = 0; i < input.length - 1; i++) {\n            const char = input.charCodeAt(i);\n            const nextChar = input.charCodeAt(i + 1);\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    }\n    _checkNoInterpolation(input, location, { start, end }) {\n        let startIndex = -1;\n        let endIndex = -1;\n        for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n            if (startIndex === -1) {\n                if (input.startsWith(start)) {\n                    startIndex = charIndex;\n                }\n            }\n            else {\n                endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n                if (endIndex > -1) {\n                    break;\n                }\n            }\n        }\n        if (startIndex > -1 && endIndex > -1) {\n            this._reportError(`Got interpolation (${start}${end}) where expression was expected`, input, `at column ${startIndex} in`, location);\n        }\n    }\n    /**\n     * Finds the index of the end of an interpolation expression\n     * while ignoring comments and quoted content.\n     */\n    _getInterpolationEndIndex(input, expressionEnd, start) {\n        for (const charIndex of this._forEachUnquotedChar(input, start)) {\n            if (input.startsWith(expressionEnd, charIndex)) {\n                return charIndex;\n            }\n            // Nothing else in the expression matters after we've\n            // hit a comment so look directly for the end token.\n            if (input.startsWith('//', charIndex)) {\n                return input.indexOf(expressionEnd, charIndex);\n            }\n        }\n        return -1;\n    }\n    /**\n     * Generator used to iterate over the character indexes of a string that are outside of quotes.\n     * @param input String to loop through.\n     * @param start Index within the string at which to start.\n     */\n    *_forEachUnquotedChar(input, start) {\n        let currentQuote = null;\n        let escapeCount = 0;\n        for (let i = start; i < input.length; i++) {\n            const char = input[i];\n            // Skip the characters inside quotes. Note that we only care about the outer-most\n            // quotes matching up and we need to account for escape characters.\n            if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\n                escapeCount % 2 === 0) {\n                currentQuote = currentQuote === null ? char : null;\n            }\n            else if (currentQuote === null) {\n                yield i;\n            }\n            escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n        }\n    }\n}\n/** Describes a stateful context an expression parser is in. */\nvar ParseContextFlags;\n(function (ParseContextFlags) {\n    ParseContextFlags[ParseContextFlags[\"None\"] = 0] = \"None\";\n    /**\n     * A Writable context is one in which a value may be written to an lvalue.\n     * For example, after we see a property access, we may expect a write to the\n     * property via the \"=\" operator.\n     *   prop\n     *        ^ possible \"=\" after\n     */\n    ParseContextFlags[ParseContextFlags[\"Writable\"] = 1] = \"Writable\";\n})(ParseContextFlags || (ParseContextFlags = {}));\nclass _ParseAST {\n    constructor(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.absoluteOffset = absoluteOffset;\n        this.tokens = tokens;\n        this.inputLength = inputLength;\n        this.parseAction = parseAction;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        this.context = ParseContextFlags.None;\n        // Cache of expression start and input indeces to the absolute source span they map to, used to\n        // prevent creating superfluous source spans in `sourceSpan`.\n        // A serial of the expression start and input index is used for mapping because both are stateful\n        // and may change for subsequent expressions visited by the parser.\n        this.sourceSpanCache = new Map();\n        this.index = 0;\n    }\n    peek(offset) {\n        const i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    }\n    get next() {\n        return this.peek(0);\n    }\n    /** Whether all the parser input has been processed. */\n    get atEOF() {\n        return this.index >= this.tokens.length;\n    }\n    /**\n     * Index of the next token to be processed, or the end of the last token if all have been\n     * processed.\n     */\n    get inputIndex() {\n        return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n    }\n    /**\n     * End index of the last processed token, or the start of the first token if none have been\n     * processed.\n     */\n    get currentEndIndex() {\n        if (this.index > 0) {\n            const curToken = this.peek(-1);\n            return curToken.end + this.offset;\n        }\n        // No tokens have been processed yet; return the next token's start or the length of the input\n        // if there is no token.\n        if (this.tokens.length === 0) {\n            return this.inputLength + this.offset;\n        }\n        return this.next.index + this.offset;\n    }\n    /**\n     * Returns the absolute offset of the start of the current token.\n     */\n    get currentAbsoluteOffset() {\n        return this.absoluteOffset + this.inputIndex;\n    }\n    /**\n     * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n     * provided).\n     *\n     * @param start Position from which the `ParseSpan` will start.\n     * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n     *     natural ending index)\n     */\n    span(start, artificialEndIndex) {\n        let endIndex = this.currentEndIndex;\n        if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n            endIndex = artificialEndIndex;\n        }\n        // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n        // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n        // appears to be a deep-seated parser bug.\n        //\n        // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n        // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n        if (start > endIndex) {\n            const tmp = endIndex;\n            endIndex = start;\n            start = tmp;\n        }\n        return new ParseSpan(start, endIndex);\n    }\n    sourceSpan(start, artificialEndIndex) {\n        const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n        if (!this.sourceSpanCache.has(serial)) {\n            this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n        }\n        return this.sourceSpanCache.get(serial);\n    }\n    advance() {\n        this.index++;\n    }\n    /**\n     * Executes a callback in the provided context.\n     */\n    withContext(context, cb) {\n        this.context |= context;\n        const ret = cb();\n        this.context ^= context;\n        return ret;\n    }\n    consumeOptionalCharacter(code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    peekKeywordLet() {\n        return this.next.isKeywordLet();\n    }\n    peekKeywordAs() {\n        return this.next.isKeywordAs();\n    }\n    /**\n     * Consumes an expected character, otherwise emits an error about the missing expected character\n     * and skips over the token stream until reaching a recoverable point.\n     *\n     * See `this.error` and `this.skip` for more details.\n     */\n    expectCharacter(code) {\n        if (this.consumeOptionalCharacter(code))\n            return;\n        this.error(`Missing expected ${String.fromCharCode(code)}`);\n    }\n    consumeOptionalOperator(op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    expectOperator(operator) {\n        if (this.consumeOptionalOperator(operator))\n            return;\n        this.error(`Missing expected operator ${operator}`);\n    }\n    prettyPrintToken(tok) {\n        return tok === EOF ? 'end of input' : `token ${tok}`;\n    }\n    expectIdentifierOrKeyword() {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            if (n.isPrivateIdentifier()) {\n                this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n            }\n            else {\n                this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n            }\n            return null;\n        }\n        this.advance();\n        return n.toString();\n    }\n    expectIdentifierOrKeywordOrString() {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            if (n.isPrivateIdentifier()) {\n                this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n            }\n            else {\n                this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n            }\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    }\n    parseChain() {\n        const exprs = [];\n        const start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            const expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.consumeOptionalCharacter($SEMICOLON)) {\n                if (!this.parseAction) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.consumeOptionalCharacter($SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                this.error(`Unexpected token '${this.next}'`);\n            }\n        }\n        if (exprs.length == 0) {\n            // We have no expressions so create an empty expression that spans the entire input length\n            const artificialStart = this.offset;\n            const artificialEnd = this.offset + this.inputLength;\n            return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));\n        }\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), this.sourceSpan(start), exprs);\n    }\n    parsePipe() {\n        const start = this.inputIndex;\n        let result = this.parseExpression();\n        if (this.consumeOptionalOperator('|')) {\n            if (this.parseAction) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                const nameStart = this.inputIndex;\n                let nameId = this.expectIdentifierOrKeyword();\n                let nameSpan;\n                let fullSpanEnd = undefined;\n                if (nameId !== null) {\n                    nameSpan = this.sourceSpan(nameStart);\n                }\n                else {\n                    // No valid identifier was found, so we'll assume an empty pipe name ('').\n                    nameId = '';\n                    // However, there may have been whitespace present between the pipe character and the next\n                    // token in the sequence (or the end of input). We want to track this whitespace so that\n                    // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n                    // whitespace beyond it. Another way of thinking about this is that the zero-length name\n                    // is assumed to be at the end of any whitespace beyond the pipe character.\n                    //\n                    // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n                    // beginning of the next token, or until the end of input if the next token is EOF.\n                    fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset;\n                    // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n                    // beyond the pipe character.\n                    nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n                }\n                const args = [];\n                while (this.consumeOptionalCharacter($COLON)) {\n                    args.push(this.parseExpression());\n                    // If there are additional expressions beyond the name, then the artificial end for the\n                    // name is no longer relevant.\n                }\n                result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n            } while (this.consumeOptionalOperator('|'));\n        }\n        return result;\n    }\n    parseExpression() {\n        return this.parseConditional();\n    }\n    parseConditional() {\n        const start = this.inputIndex;\n        const result = this.parseLogicalOr();\n        if (this.consumeOptionalOperator('?')) {\n            const yes = this.parsePipe();\n            let no;\n            if (!this.consumeOptionalCharacter($COLON)) {\n                const end = this.inputIndex;\n                const expression = this.input.substring(start, end);\n                this.error(`Conditional expression ${expression} requires all 3 expressions`);\n                no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    }\n    parseLogicalOr() {\n        // '||'\n        const start = this.inputIndex;\n        let result = this.parseLogicalAnd();\n        while (this.consumeOptionalOperator('||')) {\n            const right = this.parseLogicalAnd();\n            result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n        }\n        return result;\n    }\n    parseLogicalAnd() {\n        // '&&'\n        const start = this.inputIndex;\n        let result = this.parseNullishCoalescing();\n        while (this.consumeOptionalOperator('&&')) {\n            const right = this.parseNullishCoalescing();\n            result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n        }\n        return result;\n    }\n    parseNullishCoalescing() {\n        // '??'\n        const start = this.inputIndex;\n        let result = this.parseEquality();\n        while (this.consumeOptionalOperator('??')) {\n            const right = this.parseEquality();\n            result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n        }\n        return result;\n    }\n    parseEquality() {\n        // '==','!=','===','!=='\n        const start = this.inputIndex;\n        let result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    const right = this.parseRelational();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parseRelational() {\n        // '<', '>', '<=', '>='\n        const start = this.inputIndex;\n        let result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    const right = this.parseAdditive();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parseAdditive() {\n        // '+', '-'\n        const start = this.inputIndex;\n        let result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    let right = this.parseMultiplicative();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parseMultiplicative() {\n        // '*', '%', '/'\n        const start = this.inputIndex;\n        let result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    let right = this.parsePrefix();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parsePrefix() {\n        if (this.next.type == TokenType.Operator) {\n            const start = this.inputIndex;\n            const operator = this.next.strValue;\n            let result;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n            }\n        }\n        return this.parseCallChain();\n    }\n    parseCallChain() {\n        const start = this.inputIndex;\n        let result = this.parsePrimary();\n        while (true) {\n            if (this.consumeOptionalCharacter($PERIOD)) {\n                result = this.parseAccessMemberOrCall(result, start, false);\n            }\n            else if (this.consumeOptionalOperator('?.')) {\n                result = this.consumeOptionalCharacter($LBRACKET) ?\n                    this.parseKeyedReadOrWrite(result, start, true) :\n                    this.parseAccessMemberOrCall(result, start, true);\n            }\n            else if (this.consumeOptionalCharacter($LBRACKET)) {\n                result = this.parseKeyedReadOrWrite(result, start, false);\n            }\n            else if (this.consumeOptionalCharacter($LPAREN)) {\n                const argumentStart = this.inputIndex;\n                this.rparensExpected++;\n                const args = this.parseCallArguments();\n                const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n                this.rparensExpected--;\n                this.expectCharacter($RPAREN);\n                result = new Call(this.span(start), this.sourceSpan(start), result, args, argumentSpan);\n            }\n            else if (this.consumeOptionalOperator('!')) {\n                result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n            }\n            else {\n                return result;\n            }\n        }\n    }\n    parsePrimary() {\n        const start = this.inputIndex;\n        if (this.consumeOptionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            const result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter($RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ThisReceiver(this.span(start), this.sourceSpan(start));\n        }\n        else if (this.consumeOptionalCharacter($LBRACKET)) {\n            this.rbracketsExpected++;\n            const elements = this.parseExpressionList($RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n        }\n        else if (this.next.isCharacter($LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMemberOrCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n        }\n        else if (this.next.isNumber()) {\n            const value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n        }\n        else if (this.next.isString()) {\n            const literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n        }\n        else if (this.next.isPrivateIdentifier()) {\n            this._reportErrorForPrivateIdentifier(this.next, null);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(`Unexpected end of expression: ${this.input}`);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n        else {\n            this.error(`Unexpected token ${this.next}`);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n    }\n    parseExpressionList(terminator) {\n        const result = [];\n        do {\n            if (!this.next.isCharacter(terminator)) {\n                result.push(this.parsePipe());\n            }\n            else {\n                break;\n            }\n        } while (this.consumeOptionalCharacter($COMMA));\n        return result;\n    }\n    parseLiteralMap() {\n        const keys = [];\n        const values = [];\n        const start = this.inputIndex;\n        this.expectCharacter($LBRACE);\n        if (!this.consumeOptionalCharacter($RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                const keyStart = this.inputIndex;\n                const quoted = this.next.isString();\n                const key = this.expectIdentifierOrKeywordOrString();\n                keys.push({ key, quoted });\n                // Properties with quoted keys can't use the shorthand syntax.\n                if (quoted) {\n                    this.expectCharacter($COLON);\n                    values.push(this.parsePipe());\n                }\n                else if (this.consumeOptionalCharacter($COLON)) {\n                    values.push(this.parsePipe());\n                }\n                else {\n                    const span = this.span(keyStart);\n                    const sourceSpan = this.sourceSpan(keyStart);\n                    values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n                }\n            } while (this.consumeOptionalCharacter($COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter($RBRACE);\n        }\n        return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n    }\n    parseAccessMemberOrCall(readReceiver, start, isSafe) {\n        const nameStart = this.inputIndex;\n        const id = this.withContext(ParseContextFlags.Writable, () => {\n            var _a;\n            const id = (_a = this.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : '';\n            if (id.length === 0) {\n                this.error(`Expected identifier for property access`, readReceiver.span.end);\n            }\n            return id;\n        });\n        const nameSpan = this.sourceSpan(nameStart);\n        let receiver;\n        if (isSafe) {\n            if (this.consumeOptionalOperator('=')) {\n                this.error('The \\'?.\\' operator cannot be used in the assignment');\n                receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n            else {\n                receiver = new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n            }\n        }\n        else {\n            if (this.consumeOptionalOperator('=')) {\n                if (!this.parseAction) {\n                    this.error('Bindings cannot contain assignments');\n                    return new EmptyExpr(this.span(start), this.sourceSpan(start));\n                }\n                const value = this.parseConditional();\n                receiver = new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);\n            }\n            else {\n                receiver =\n                    new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n            }\n        }\n        if (this.consumeOptionalCharacter($LPAREN)) {\n            const argumentStart = this.inputIndex;\n            this.rparensExpected++;\n            const args = this.parseCallArguments();\n            const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n            this.expectCharacter($RPAREN);\n            this.rparensExpected--;\n            const span = this.span(start);\n            const sourceSpan = this.sourceSpan(start);\n            return new Call(span, sourceSpan, receiver, args, argumentSpan);\n        }\n        return receiver;\n    }\n    parseCallArguments() {\n        if (this.next.isCharacter($RPAREN))\n            return [];\n        const positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.consumeOptionalCharacter($COMMA));\n        return positionals;\n    }\n    /**\n     * Parses an identifier, a keyword, a string with an optional `-` in between,\n     * and returns the string along with its absolute source span.\n     */\n    expectTemplateBindingKey() {\n        let result = '';\n        let operatorFound = false;\n        const start = this.currentAbsoluteOffset;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.consumeOptionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return {\n            source: result,\n            span: new AbsoluteSourceSpan(start, start + result.length),\n        };\n    }\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n     * ```\n     * contains five bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     * 4. i -> NgForOfContext.index\n     * 5. ngForTrackBy -> func\n     *\n     * For a full description of the microsyntax grammar, see\n     * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n     *\n     * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n     * without the *, along with its absolute span.\n     */\n    parseTemplateBindings(templateKey) {\n        const bindings = [];\n        // The first binding is for the template key itself\n        // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n        // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n        bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n        while (this.index < this.tokens.length) {\n            // If it starts with 'let', then this must be variable declaration\n            const letBinding = this.parseLetBinding();\n            if (letBinding) {\n                bindings.push(letBinding);\n            }\n            else {\n                // Two possible cases here, either `value \"as\" key` or\n                // \"directive-keyword expression\". We don't know which case, but both\n                // \"value\" and \"directive-keyword\" are template binding key, so consume\n                // the key first.\n                const key = this.expectTemplateBindingKey();\n                // Peek at the next token, if it is \"as\" then this must be variable\n                // declaration.\n                const binding = this.parseAsBinding(key);\n                if (binding) {\n                    bindings.push(binding);\n                }\n                else {\n                    // Otherwise the key must be a directive keyword, like \"of\". Transform\n                    // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n                    key.source =\n                        templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n                    bindings.push(...this.parseDirectiveKeywordBindings(key));\n                }\n            }\n            this.consumeStatementTerminator();\n        }\n        return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n    }\n    parseKeyedReadOrWrite(receiver, start, isSafe) {\n        return this.withContext(ParseContextFlags.Writable, () => {\n            this.rbracketsExpected++;\n            const key = this.parsePipe();\n            if (key instanceof EmptyExpr) {\n                this.error(`Key access cannot be empty`);\n            }\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            if (this.consumeOptionalOperator('=')) {\n                if (isSafe) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                }\n                else {\n                    const value = this.parseConditional();\n                    return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);\n                }\n            }\n            else {\n                return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) :\n                    new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n            }\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        });\n    }\n    /**\n     * Parse a directive keyword, followed by a mandatory expression.\n     * For example, \"of items\", \"trackBy: func\".\n     * The bindings are: ngForOf -> items, ngForTrackBy -> func\n     * There could be an optional \"as\" binding that follows the expression.\n     * For example,\n     * ```\n     *   *ngFor=\"let item of items | slice:0:1 as collection\".\n     *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n     *               keyword    bound target   optional 'as' binding\n     * ```\n     *\n     * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n     * absolute span.\n     */\n    parseDirectiveKeywordBindings(key) {\n        const bindings = [];\n        this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction\n        const value = this.getDirectiveBoundTarget();\n        let spanEnd = this.currentAbsoluteOffset;\n        // The binding could optionally be followed by \"as\". For example,\n        // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n        // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n        // 'key' in the current context now becomes the \"value\" in the next binding.\n        const asBinding = this.parseAsBinding(key);\n        if (!asBinding) {\n            this.consumeStatementTerminator();\n            spanEnd = this.currentAbsoluteOffset;\n        }\n        const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n        bindings.push(new ExpressionBinding(sourceSpan, key, value));\n        if (asBinding) {\n            bindings.push(asBinding);\n        }\n        return bindings;\n    }\n    /**\n     * Return the expression AST for the bound target of a directive keyword\n     * binding. For example,\n     * ```\n     *   *ngIf=\"condition | pipe\"\n     *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n     *   *ngFor=\"let item of items\"\n     *                       ^^^^^ bound target for \"ngForOf\"\n     * ```\n     */\n    getDirectiveBoundTarget() {\n        if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n            return null;\n        }\n        const ast = this.parsePipe(); // example: \"condition | async\"\n        const { start, end } = ast.span;\n        const value = this.input.substring(start, end);\n        return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n    }\n    /**\n     * Return the binding for a variable declared using `as`. Note that the order\n     * of the key-value pair in this declaration is reversed. For example,\n     * ```\n     *   *ngFor=\"let item of items; index as i\"\n     *                              ^^^^^    ^\n     *                              value    key\n     * ```\n     *\n     * @param value name of the value in the declaration, \"ngIf\" in the example\n     * above, along with its absolute span.\n     */\n    parseAsBinding(value) {\n        if (!this.peekKeywordAs()) {\n            return null;\n        }\n        this.advance(); // consume the 'as' keyword\n        const key = this.expectTemplateBindingKey();\n        this.consumeStatementTerminator();\n        const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n        return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\n     * Return the binding for a variable declared using `let`. For example,\n     * ```\n     *   *ngFor=\"let item of items; let i=index;\"\n     *           ^^^^^^^^           ^^^^^^^^^^^\n     * ```\n     * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n     * In the second binding, `i` is bound to `NgForOfContext.index`.\n     */\n    parseLetBinding() {\n        if (!this.peekKeywordLet()) {\n            return null;\n        }\n        const spanStart = this.currentAbsoluteOffset;\n        this.advance(); // consume the 'let' keyword\n        const key = this.expectTemplateBindingKey();\n        let value = null;\n        if (this.consumeOptionalOperator('=')) {\n            value = this.expectTemplateBindingKey();\n        }\n        this.consumeStatementTerminator();\n        const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n        return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\n     * Consume the optional statement terminator: semicolon or comma.\n     */\n    consumeStatementTerminator() {\n        this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\n    }\n    /**\n     * Records an error and skips over the token stream until reaching a recoverable point. See\n     * `this.skip` for more details on token skipping.\n     */\n    error(message, index = null) {\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    }\n    locationText(index = null) {\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n            `at the end of the expression`;\n    }\n    /**\n     * Records an error for an unexpected private identifier being discovered.\n     * @param token Token representing a private identifier.\n     * @param extraMessage Optional additional message being appended to the error.\n     */\n    _reportErrorForPrivateIdentifier(token, extraMessage) {\n        let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n        if (extraMessage !== null) {\n            errorMessage += `, ${extraMessage}`;\n        }\n        this.error(errorMessage);\n    }\n    /**\n     * Error recovery should skip tokens until it encounters a recovery point.\n     *\n     * The following are treated as unconditional recovery points:\n     *   - end of input\n     *   - ';' (parseChain() is always the root production, and it expects a ';')\n     *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n     *\n     * The following are conditional recovery points:\n     *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n     *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n     *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n     *       an '(' <expr> ')' production).\n     *       The recovery points of grouping symbols must be conditional as they must be skipped if\n     *       none of the calling productions are not expecting the closing token else we will never\n     *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n     *       That is, we skip a closing symbol if we are not in a grouping production.\n     *   - '=' in a `Writable` context\n     *     - In this context, we are able to recover after seeing the `=` operator, which\n     *       signals the presence of an independent rvalue expression following the `=` operator.\n     *\n     * If a production expects one of these token it increments the corresponding nesting count,\n     * and then decrements it just prior to checking if the token is in the input.\n     */\n    skip() {\n        let n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n            !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) &&\n            (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    }\n}\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.errors = [];\n    }\n    visitPipe() {\n        this.errors.push('pipes');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass NodeWithI18n {\n    constructor(sourceSpan, i18n) {\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n}\nclass Text extends NodeWithI18n {\n    constructor(value, sourceSpan, tokens, i18n) {\n        super(sourceSpan, i18n);\n        this.value = value;\n        this.tokens = tokens;\n    }\n    visit(visitor, context) {\n        return visitor.visitText(this, context);\n    }\n}\nclass Expansion extends NodeWithI18n {\n    constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n        super(sourceSpan, i18n);\n        this.switchValue = switchValue;\n        this.type = type;\n        this.cases = cases;\n        this.switchValueSourceSpan = switchValueSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitExpansion(this, context);\n    }\n}\nclass ExpansionCase {\n    constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitExpansionCase(this, context);\n    }\n}\nclass Attribute extends NodeWithI18n {\n    constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {\n        super(sourceSpan, i18n);\n        this.name = name;\n        this.value = value;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.valueTokens = valueTokens;\n    }\n    visit(visitor, context) {\n        return visitor.visitAttribute(this, context);\n    }\n}\nclass Element extends NodeWithI18n {\n    constructor(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {\n        super(sourceSpan, i18n);\n        this.name = name;\n        this.attrs = attrs;\n        this.children = children;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitElement(this, context);\n    }\n}\nclass Comment {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitComment(this, context);\n    }\n}\nfunction visitAll(visitor, nodes, context = null) {\n    const result = [];\n    const visit = visitor.visit ?\n        (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :\n        (ast) => ast.visit(visitor, context);\n    nodes.forEach(ast => {\n        const astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\nclass RecursiveVisitor {\n    constructor() { }\n    visitElement(ast, context) {\n        this.visitChildren(context, visit => {\n            visit(ast.attrs);\n            visit(ast.children);\n        });\n    }\n    visitAttribute(ast, context) { }\n    visitText(ast, context) { }\n    visitComment(ast, context) { }\n    visitExpansion(ast, context) {\n        return this.visitChildren(context, visit => {\n            visit(ast.cases);\n        });\n    }\n    visitExpansionCase(ast, context) { }\n    visitChildren(context, cb) {\n        let results = [];\n        let t = this;\n        function visit(children) {\n            if (children)\n                results.push(visitAll(t, children, context));\n        }\n        cb(visit);\n        return Array.prototype.concat.apply([], results);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Mapping between all HTML entity names and their unicode representation.\n// Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping\n// the `&` and `;` from the keys and removing the duplicates.\n// see https://www.w3.org/TR/html51/syntax.html#named-character-references\nconst NAMED_ENTITIES = {\n    'AElig': '\\u00C6',\n    'AMP': '\\u0026',\n    'amp': '\\u0026',\n    'Aacute': '\\u00C1',\n    'Abreve': '\\u0102',\n    'Acirc': '\\u00C2',\n    'Acy': '\\u0410',\n    'Afr': '\\uD835\\uDD04',\n    'Agrave': '\\u00C0',\n    'Alpha': '\\u0391',\n    'Amacr': '\\u0100',\n    'And': '\\u2A53',\n    'Aogon': '\\u0104',\n    'Aopf': '\\uD835\\uDD38',\n    'ApplyFunction': '\\u2061',\n    'af': '\\u2061',\n    'Aring': '\\u00C5',\n    'angst': '\\u00C5',\n    'Ascr': '\\uD835\\uDC9C',\n    'Assign': '\\u2254',\n    'colone': '\\u2254',\n    'coloneq': '\\u2254',\n    'Atilde': '\\u00C3',\n    'Auml': '\\u00C4',\n    'Backslash': '\\u2216',\n    'setminus': '\\u2216',\n    'setmn': '\\u2216',\n    'smallsetminus': '\\u2216',\n    'ssetmn': '\\u2216',\n    'Barv': '\\u2AE7',\n    'Barwed': '\\u2306',\n    'doublebarwedge': '\\u2306',\n    'Bcy': '\\u0411',\n    'Because': '\\u2235',\n    'becaus': '\\u2235',\n    'because': '\\u2235',\n    'Bernoullis': '\\u212C',\n    'Bscr': '\\u212C',\n    'bernou': '\\u212C',\n    'Beta': '\\u0392',\n    'Bfr': '\\uD835\\uDD05',\n    'Bopf': '\\uD835\\uDD39',\n    'Breve': '\\u02D8',\n    'breve': '\\u02D8',\n    'Bumpeq': '\\u224E',\n    'HumpDownHump': '\\u224E',\n    'bump': '\\u224E',\n    'CHcy': '\\u0427',\n    'COPY': '\\u00A9',\n    'copy': '\\u00A9',\n    'Cacute': '\\u0106',\n    'Cap': '\\u22D2',\n    'CapitalDifferentialD': '\\u2145',\n    'DD': '\\u2145',\n    'Cayleys': '\\u212D',\n    'Cfr': '\\u212D',\n    'Ccaron': '\\u010C',\n    'Ccedil': '\\u00C7',\n    'Ccirc': '\\u0108',\n    'Cconint': '\\u2230',\n    'Cdot': '\\u010A',\n    'Cedilla': '\\u00B8',\n    'cedil': '\\u00B8',\n    'CenterDot': '\\u00B7',\n    'centerdot': '\\u00B7',\n    'middot': '\\u00B7',\n    'Chi': '\\u03A7',\n    'CircleDot': '\\u2299',\n    'odot': '\\u2299',\n    'CircleMinus': '\\u2296',\n    'ominus': '\\u2296',\n    'CirclePlus': '\\u2295',\n    'oplus': '\\u2295',\n    'CircleTimes': '\\u2297',\n    'otimes': '\\u2297',\n    'ClockwiseContourIntegral': '\\u2232',\n    'cwconint': '\\u2232',\n    'CloseCurlyDoubleQuote': '\\u201D',\n    'rdquo': '\\u201D',\n    'rdquor': '\\u201D',\n    'CloseCurlyQuote': '\\u2019',\n    'rsquo': '\\u2019',\n    'rsquor': '\\u2019',\n    'Colon': '\\u2237',\n    'Proportion': '\\u2237',\n    'Colone': '\\u2A74',\n    'Congruent': '\\u2261',\n    'equiv': '\\u2261',\n    'Conint': '\\u222F',\n    'DoubleContourIntegral': '\\u222F',\n    'ContourIntegral': '\\u222E',\n    'conint': '\\u222E',\n    'oint': '\\u222E',\n    'Copf': '\\u2102',\n    'complexes': '\\u2102',\n    'Coproduct': '\\u2210',\n    'coprod': '\\u2210',\n    'CounterClockwiseContourIntegral': '\\u2233',\n    'awconint': '\\u2233',\n    'Cross': '\\u2A2F',\n    'Cscr': '\\uD835\\uDC9E',\n    'Cup': '\\u22D3',\n    'CupCap': '\\u224D',\n    'asympeq': '\\u224D',\n    'DDotrahd': '\\u2911',\n    'DJcy': '\\u0402',\n    'DScy': '\\u0405',\n    'DZcy': '\\u040F',\n    'Dagger': '\\u2021',\n    'ddagger': '\\u2021',\n    'Darr': '\\u21A1',\n    'Dashv': '\\u2AE4',\n    'DoubleLeftTee': '\\u2AE4',\n    'Dcaron': '\\u010E',\n    'Dcy': '\\u0414',\n    'Del': '\\u2207',\n    'nabla': '\\u2207',\n    'Delta': '\\u0394',\n    'Dfr': '\\uD835\\uDD07',\n    'DiacriticalAcute': '\\u00B4',\n    'acute': '\\u00B4',\n    'DiacriticalDot': '\\u02D9',\n    'dot': '\\u02D9',\n    'DiacriticalDoubleAcute': '\\u02DD',\n    'dblac': '\\u02DD',\n    'DiacriticalGrave': '\\u0060',\n    'grave': '\\u0060',\n    'DiacriticalTilde': '\\u02DC',\n    'tilde': '\\u02DC',\n    'Diamond': '\\u22C4',\n    'diam': '\\u22C4',\n    'diamond': '\\u22C4',\n    'DifferentialD': '\\u2146',\n    'dd': '\\u2146',\n    'Dopf': '\\uD835\\uDD3B',\n    'Dot': '\\u00A8',\n    'DoubleDot': '\\u00A8',\n    'die': '\\u00A8',\n    'uml': '\\u00A8',\n    'DotDot': '\\u20DC',\n    'DotEqual': '\\u2250',\n    'doteq': '\\u2250',\n    'esdot': '\\u2250',\n    'DoubleDownArrow': '\\u21D3',\n    'Downarrow': '\\u21D3',\n    'dArr': '\\u21D3',\n    'DoubleLeftArrow': '\\u21D0',\n    'Leftarrow': '\\u21D0',\n    'lArr': '\\u21D0',\n    'DoubleLeftRightArrow': '\\u21D4',\n    'Leftrightarrow': '\\u21D4',\n    'hArr': '\\u21D4',\n    'iff': '\\u21D4',\n    'DoubleLongLeftArrow': '\\u27F8',\n    'Longleftarrow': '\\u27F8',\n    'xlArr': '\\u27F8',\n    'DoubleLongLeftRightArrow': '\\u27FA',\n    'Longleftrightarrow': '\\u27FA',\n    'xhArr': '\\u27FA',\n    'DoubleLongRightArrow': '\\u27F9',\n    'Longrightarrow': '\\u27F9',\n    'xrArr': '\\u27F9',\n    'DoubleRightArrow': '\\u21D2',\n    'Implies': '\\u21D2',\n    'Rightarrow': '\\u21D2',\n    'rArr': '\\u21D2',\n    'DoubleRightTee': '\\u22A8',\n    'vDash': '\\u22A8',\n    'DoubleUpArrow': '\\u21D1',\n    'Uparrow': '\\u21D1',\n    'uArr': '\\u21D1',\n    'DoubleUpDownArrow': '\\u21D5',\n    'Updownarrow': '\\u21D5',\n    'vArr': '\\u21D5',\n    'DoubleVerticalBar': '\\u2225',\n    'par': '\\u2225',\n    'parallel': '\\u2225',\n    'shortparallel': '\\u2225',\n    'spar': '\\u2225',\n    'DownArrow': '\\u2193',\n    'ShortDownArrow': '\\u2193',\n    'darr': '\\u2193',\n    'downarrow': '\\u2193',\n    'DownArrowBar': '\\u2913',\n    'DownArrowUpArrow': '\\u21F5',\n    'duarr': '\\u21F5',\n    'DownBreve': '\\u0311',\n    'DownLeftRightVector': '\\u2950',\n    'DownLeftTeeVector': '\\u295E',\n    'DownLeftVector': '\\u21BD',\n    'leftharpoondown': '\\u21BD',\n    'lhard': '\\u21BD',\n    'DownLeftVectorBar': '\\u2956',\n    'DownRightTeeVector': '\\u295F',\n    'DownRightVector': '\\u21C1',\n    'rhard': '\\u21C1',\n    'rightharpoondown': '\\u21C1',\n    'DownRightVectorBar': '\\u2957',\n    'DownTee': '\\u22A4',\n    'top': '\\u22A4',\n    'DownTeeArrow': '\\u21A7',\n    'mapstodown': '\\u21A7',\n    'Dscr': '\\uD835\\uDC9F',\n    'Dstrok': '\\u0110',\n    'ENG': '\\u014A',\n    'ETH': '\\u00D0',\n    'Eacute': '\\u00C9',\n    'Ecaron': '\\u011A',\n    'Ecirc': '\\u00CA',\n    'Ecy': '\\u042D',\n    'Edot': '\\u0116',\n    'Efr': '\\uD835\\uDD08',\n    'Egrave': '\\u00C8',\n    'Element': '\\u2208',\n    'in': '\\u2208',\n    'isin': '\\u2208',\n    'isinv': '\\u2208',\n    'Emacr': '\\u0112',\n    'EmptySmallSquare': '\\u25FB',\n    'EmptyVerySmallSquare': '\\u25AB',\n    'Eogon': '\\u0118',\n    'Eopf': '\\uD835\\uDD3C',\n    'Epsilon': '\\u0395',\n    'Equal': '\\u2A75',\n    'EqualTilde': '\\u2242',\n    'eqsim': '\\u2242',\n    'esim': '\\u2242',\n    'Equilibrium': '\\u21CC',\n    'rightleftharpoons': '\\u21CC',\n    'rlhar': '\\u21CC',\n    'Escr': '\\u2130',\n    'expectation': '\\u2130',\n    'Esim': '\\u2A73',\n    'Eta': '\\u0397',\n    'Euml': '\\u00CB',\n    'Exists': '\\u2203',\n    'exist': '\\u2203',\n    'ExponentialE': '\\u2147',\n    'ee': '\\u2147',\n    'exponentiale': '\\u2147',\n    'Fcy': '\\u0424',\n    'Ffr': '\\uD835\\uDD09',\n    'FilledSmallSquare': '\\u25FC',\n    'FilledVerySmallSquare': '\\u25AA',\n    'blacksquare': '\\u25AA',\n    'squarf': '\\u25AA',\n    'squf': '\\u25AA',\n    'Fopf': '\\uD835\\uDD3D',\n    'ForAll': '\\u2200',\n    'forall': '\\u2200',\n    'Fouriertrf': '\\u2131',\n    'Fscr': '\\u2131',\n    'GJcy': '\\u0403',\n    'GT': '\\u003E',\n    'gt': '\\u003E',\n    'Gamma': '\\u0393',\n    'Gammad': '\\u03DC',\n    'Gbreve': '\\u011E',\n    'Gcedil': '\\u0122',\n    'Gcirc': '\\u011C',\n    'Gcy': '\\u0413',\n    'Gdot': '\\u0120',\n    'Gfr': '\\uD835\\uDD0A',\n    'Gg': '\\u22D9',\n    'ggg': '\\u22D9',\n    'Gopf': '\\uD835\\uDD3E',\n    'GreaterEqual': '\\u2265',\n    'ge': '\\u2265',\n    'geq': '\\u2265',\n    'GreaterEqualLess': '\\u22DB',\n    'gel': '\\u22DB',\n    'gtreqless': '\\u22DB',\n    'GreaterFullEqual': '\\u2267',\n    'gE': '\\u2267',\n    'geqq': '\\u2267',\n    'GreaterGreater': '\\u2AA2',\n    'GreaterLess': '\\u2277',\n    'gl': '\\u2277',\n    'gtrless': '\\u2277',\n    'GreaterSlantEqual': '\\u2A7E',\n    'geqslant': '\\u2A7E',\n    'ges': '\\u2A7E',\n    'GreaterTilde': '\\u2273',\n    'gsim': '\\u2273',\n    'gtrsim': '\\u2273',\n    'Gscr': '\\uD835\\uDCA2',\n    'Gt': '\\u226B',\n    'NestedGreaterGreater': '\\u226B',\n    'gg': '\\u226B',\n    'HARDcy': '\\u042A',\n    'Hacek': '\\u02C7',\n    'caron': '\\u02C7',\n    'Hat': '\\u005E',\n    'Hcirc': '\\u0124',\n    'Hfr': '\\u210C',\n    'Poincareplane': '\\u210C',\n    'HilbertSpace': '\\u210B',\n    'Hscr': '\\u210B',\n    'hamilt': '\\u210B',\n    'Hopf': '\\u210D',\n    'quaternions': '\\u210D',\n    'HorizontalLine': '\\u2500',\n    'boxh': '\\u2500',\n    'Hstrok': '\\u0126',\n    'HumpEqual': '\\u224F',\n    'bumpe': '\\u224F',\n    'bumpeq': '\\u224F',\n    'IEcy': '\\u0415',\n    'IJlig': '\\u0132',\n    'IOcy': '\\u0401',\n    'Iacute': '\\u00CD',\n    'Icirc': '\\u00CE',\n    'Icy': '\\u0418',\n    'Idot': '\\u0130',\n    'Ifr': '\\u2111',\n    'Im': '\\u2111',\n    'image': '\\u2111',\n    'imagpart': '\\u2111',\n    'Igrave': '\\u00CC',\n    'Imacr': '\\u012A',\n    'ImaginaryI': '\\u2148',\n    'ii': '\\u2148',\n    'Int': '\\u222C',\n    'Integral': '\\u222B',\n    'int': '\\u222B',\n    'Intersection': '\\u22C2',\n    'bigcap': '\\u22C2',\n    'xcap': '\\u22C2',\n    'InvisibleComma': '\\u2063',\n    'ic': '\\u2063',\n    'InvisibleTimes': '\\u2062',\n    'it': '\\u2062',\n    'Iogon': '\\u012E',\n    'Iopf': '\\uD835\\uDD40',\n    'Iota': '\\u0399',\n    'Iscr': '\\u2110',\n    'imagline': '\\u2110',\n    'Itilde': '\\u0128',\n    'Iukcy': '\\u0406',\n    'Iuml': '\\u00CF',\n    'Jcirc': '\\u0134',\n    'Jcy': '\\u0419',\n    'Jfr': '\\uD835\\uDD0D',\n    'Jopf': '\\uD835\\uDD41',\n    'Jscr': '\\uD835\\uDCA5',\n    'Jsercy': '\\u0408',\n    'Jukcy': '\\u0404',\n    'KHcy': '\\u0425',\n    'KJcy': '\\u040C',\n    'Kappa': '\\u039A',\n    'Kcedil': '\\u0136',\n    'Kcy': '\\u041A',\n    'Kfr': '\\uD835\\uDD0E',\n    'Kopf': '\\uD835\\uDD42',\n    'Kscr': '\\uD835\\uDCA6',\n    'LJcy': '\\u0409',\n    'LT': '\\u003C',\n    'lt': '\\u003C',\n    'Lacute': '\\u0139',\n    'Lambda': '\\u039B',\n    'Lang': '\\u27EA',\n    'Laplacetrf': '\\u2112',\n    'Lscr': '\\u2112',\n    'lagran': '\\u2112',\n    'Larr': '\\u219E',\n    'twoheadleftarrow': '\\u219E',\n    'Lcaron': '\\u013D',\n    'Lcedil': '\\u013B',\n    'Lcy': '\\u041B',\n    'LeftAngleBracket': '\\u27E8',\n    'lang': '\\u27E8',\n    'langle': '\\u27E8',\n    'LeftArrow': '\\u2190',\n    'ShortLeftArrow': '\\u2190',\n    'larr': '\\u2190',\n    'leftarrow': '\\u2190',\n    'slarr': '\\u2190',\n    'LeftArrowBar': '\\u21E4',\n    'larrb': '\\u21E4',\n    'LeftArrowRightArrow': '\\u21C6',\n    'leftrightarrows': '\\u21C6',\n    'lrarr': '\\u21C6',\n    'LeftCeiling': '\\u2308',\n    'lceil': '\\u2308',\n    'LeftDoubleBracket': '\\u27E6',\n    'lobrk': '\\u27E6',\n    'LeftDownTeeVector': '\\u2961',\n    'LeftDownVector': '\\u21C3',\n    'dharl': '\\u21C3',\n    'downharpoonleft': '\\u21C3',\n    'LeftDownVectorBar': '\\u2959',\n    'LeftFloor': '\\u230A',\n    'lfloor': '\\u230A',\n    'LeftRightArrow': '\\u2194',\n    'harr': '\\u2194',\n    'leftrightarrow': '\\u2194',\n    'LeftRightVector': '\\u294E',\n    'LeftTee': '\\u22A3',\n    'dashv': '\\u22A3',\n    'LeftTeeArrow': '\\u21A4',\n    'mapstoleft': '\\u21A4',\n    'LeftTeeVector': '\\u295A',\n    'LeftTriangle': '\\u22B2',\n    'vartriangleleft': '\\u22B2',\n    'vltri': '\\u22B2',\n    'LeftTriangleBar': '\\u29CF',\n    'LeftTriangleEqual': '\\u22B4',\n    'ltrie': '\\u22B4',\n    'trianglelefteq': '\\u22B4',\n    'LeftUpDownVector': '\\u2951',\n    'LeftUpTeeVector': '\\u2960',\n    'LeftUpVector': '\\u21BF',\n    'uharl': '\\u21BF',\n    'upharpoonleft': '\\u21BF',\n    'LeftUpVectorBar': '\\u2958',\n    'LeftVector': '\\u21BC',\n    'leftharpoonup': '\\u21BC',\n    'lharu': '\\u21BC',\n    'LeftVectorBar': '\\u2952',\n    'LessEqualGreater': '\\u22DA',\n    'leg': '\\u22DA',\n    'lesseqgtr': '\\u22DA',\n    'LessFullEqual': '\\u2266',\n    'lE': '\\u2266',\n    'leqq': '\\u2266',\n    'LessGreater': '\\u2276',\n    'lessgtr': '\\u2276',\n    'lg': '\\u2276',\n    'LessLess': '\\u2AA1',\n    'LessSlantEqual': '\\u2A7D',\n    'leqslant': '\\u2A7D',\n    'les': '\\u2A7D',\n    'LessTilde': '\\u2272',\n    'lesssim': '\\u2272',\n    'lsim': '\\u2272',\n    'Lfr': '\\uD835\\uDD0F',\n    'Ll': '\\u22D8',\n    'Lleftarrow': '\\u21DA',\n    'lAarr': '\\u21DA',\n    'Lmidot': '\\u013F',\n    'LongLeftArrow': '\\u27F5',\n    'longleftarrow': '\\u27F5',\n    'xlarr': '\\u27F5',\n    'LongLeftRightArrow': '\\u27F7',\n    'longleftrightarrow': '\\u27F7',\n    'xharr': '\\u27F7',\n    'LongRightArrow': '\\u27F6',\n    'longrightarrow': '\\u27F6',\n    'xrarr': '\\u27F6',\n    'Lopf': '\\uD835\\uDD43',\n    'LowerLeftArrow': '\\u2199',\n    'swarr': '\\u2199',\n    'swarrow': '\\u2199',\n    'LowerRightArrow': '\\u2198',\n    'searr': '\\u2198',\n    'searrow': '\\u2198',\n    'Lsh': '\\u21B0',\n    'lsh': '\\u21B0',\n    'Lstrok': '\\u0141',\n    'Lt': '\\u226A',\n    'NestedLessLess': '\\u226A',\n    'll': '\\u226A',\n    'Map': '\\u2905',\n    'Mcy': '\\u041C',\n    'MediumSpace': '\\u205F',\n    'Mellintrf': '\\u2133',\n    'Mscr': '\\u2133',\n    'phmmat': '\\u2133',\n    'Mfr': '\\uD835\\uDD10',\n    'MinusPlus': '\\u2213',\n    'mnplus': '\\u2213',\n    'mp': '\\u2213',\n    'Mopf': '\\uD835\\uDD44',\n    'Mu': '\\u039C',\n    'NJcy': '\\u040A',\n    'Nacute': '\\u0143',\n    'Ncaron': '\\u0147',\n    'Ncedil': '\\u0145',\n    'Ncy': '\\u041D',\n    'NegativeMediumSpace': '\\u200B',\n    'NegativeThickSpace': '\\u200B',\n    'NegativeThinSpace': '\\u200B',\n    'NegativeVeryThinSpace': '\\u200B',\n    'ZeroWidthSpace': '\\u200B',\n    'NewLine': '\\u000A',\n    'Nfr': '\\uD835\\uDD11',\n    'NoBreak': '\\u2060',\n    'NonBreakingSpace': '\\u00A0',\n    'nbsp': '\\u00A0',\n    'Nopf': '\\u2115',\n    'naturals': '\\u2115',\n    'Not': '\\u2AEC',\n    'NotCongruent': '\\u2262',\n    'nequiv': '\\u2262',\n    'NotCupCap': '\\u226D',\n    'NotDoubleVerticalBar': '\\u2226',\n    'npar': '\\u2226',\n    'nparallel': '\\u2226',\n    'nshortparallel': '\\u2226',\n    'nspar': '\\u2226',\n    'NotElement': '\\u2209',\n    'notin': '\\u2209',\n    'notinva': '\\u2209',\n    'NotEqual': '\\u2260',\n    'ne': '\\u2260',\n    'NotEqualTilde': '\\u2242\\u0338',\n    'nesim': '\\u2242\\u0338',\n    'NotExists': '\\u2204',\n    'nexist': '\\u2204',\n    'nexists': '\\u2204',\n    'NotGreater': '\\u226F',\n    'ngt': '\\u226F',\n    'ngtr': '\\u226F',\n    'NotGreaterEqual': '\\u2271',\n    'nge': '\\u2271',\n    'ngeq': '\\u2271',\n    'NotGreaterFullEqual': '\\u2267\\u0338',\n    'ngE': '\\u2267\\u0338',\n    'ngeqq': '\\u2267\\u0338',\n    'NotGreaterGreater': '\\u226B\\u0338',\n    'nGtv': '\\u226B\\u0338',\n    'NotGreaterLess': '\\u2279',\n    'ntgl': '\\u2279',\n    'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n    'ngeqslant': '\\u2A7E\\u0338',\n    'nges': '\\u2A7E\\u0338',\n    'NotGreaterTilde': '\\u2275',\n    'ngsim': '\\u2275',\n    'NotHumpDownHump': '\\u224E\\u0338',\n    'nbump': '\\u224E\\u0338',\n    'NotHumpEqual': '\\u224F\\u0338',\n    'nbumpe': '\\u224F\\u0338',\n    'NotLeftTriangle': '\\u22EA',\n    'nltri': '\\u22EA',\n    'ntriangleleft': '\\u22EA',\n    'NotLeftTriangleBar': '\\u29CF\\u0338',\n    'NotLeftTriangleEqual': '\\u22EC',\n    'nltrie': '\\u22EC',\n    'ntrianglelefteq': '\\u22EC',\n    'NotLess': '\\u226E',\n    'nless': '\\u226E',\n    'nlt': '\\u226E',\n    'NotLessEqual': '\\u2270',\n    'nle': '\\u2270',\n    'nleq': '\\u2270',\n    'NotLessGreater': '\\u2278',\n    'ntlg': '\\u2278',\n    'NotLessLess': '\\u226A\\u0338',\n    'nLtv': '\\u226A\\u0338',\n    'NotLessSlantEqual': '\\u2A7D\\u0338',\n    'nleqslant': '\\u2A7D\\u0338',\n    'nles': '\\u2A7D\\u0338',\n    'NotLessTilde': '\\u2274',\n    'nlsim': '\\u2274',\n    'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n    'NotNestedLessLess': '\\u2AA1\\u0338',\n    'NotPrecedes': '\\u2280',\n    'npr': '\\u2280',\n    'nprec': '\\u2280',\n    'NotPrecedesEqual': '\\u2AAF\\u0338',\n    'npre': '\\u2AAF\\u0338',\n    'npreceq': '\\u2AAF\\u0338',\n    'NotPrecedesSlantEqual': '\\u22E0',\n    'nprcue': '\\u22E0',\n    'NotReverseElement': '\\u220C',\n    'notni': '\\u220C',\n    'notniva': '\\u220C',\n    'NotRightTriangle': '\\u22EB',\n    'nrtri': '\\u22EB',\n    'ntriangleright': '\\u22EB',\n    'NotRightTriangleBar': '\\u29D0\\u0338',\n    'NotRightTriangleEqual': '\\u22ED',\n    'nrtrie': '\\u22ED',\n    'ntrianglerighteq': '\\u22ED',\n    'NotSquareSubset': '\\u228F\\u0338',\n    'NotSquareSubsetEqual': '\\u22E2',\n    'nsqsube': '\\u22E2',\n    'NotSquareSuperset': '\\u2290\\u0338',\n    'NotSquareSupersetEqual': '\\u22E3',\n    'nsqsupe': '\\u22E3',\n    'NotSubset': '\\u2282\\u20D2',\n    'nsubset': '\\u2282\\u20D2',\n    'vnsub': '\\u2282\\u20D2',\n    'NotSubsetEqual': '\\u2288',\n    'nsube': '\\u2288',\n    'nsubseteq': '\\u2288',\n    'NotSucceeds': '\\u2281',\n    'nsc': '\\u2281',\n    'nsucc': '\\u2281',\n    'NotSucceedsEqual': '\\u2AB0\\u0338',\n    'nsce': '\\u2AB0\\u0338',\n    'nsucceq': '\\u2AB0\\u0338',\n    'NotSucceedsSlantEqual': '\\u22E1',\n    'nsccue': '\\u22E1',\n    'NotSucceedsTilde': '\\u227F\\u0338',\n    'NotSuperset': '\\u2283\\u20D2',\n    'nsupset': '\\u2283\\u20D2',\n    'vnsup': '\\u2283\\u20D2',\n    'NotSupersetEqual': '\\u2289',\n    'nsupe': '\\u2289',\n    'nsupseteq': '\\u2289',\n    'NotTilde': '\\u2241',\n    'nsim': '\\u2241',\n    'NotTildeEqual': '\\u2244',\n    'nsime': '\\u2244',\n    'nsimeq': '\\u2244',\n    'NotTildeFullEqual': '\\u2247',\n    'ncong': '\\u2247',\n    'NotTildeTilde': '\\u2249',\n    'nap': '\\u2249',\n    'napprox': '\\u2249',\n    'NotVerticalBar': '\\u2224',\n    'nmid': '\\u2224',\n    'nshortmid': '\\u2224',\n    'nsmid': '\\u2224',\n    'Nscr': '\\uD835\\uDCA9',\n    'Ntilde': '\\u00D1',\n    'Nu': '\\u039D',\n    'OElig': '\\u0152',\n    'Oacute': '\\u00D3',\n    'Ocirc': '\\u00D4',\n    'Ocy': '\\u041E',\n    'Odblac': '\\u0150',\n    'Ofr': '\\uD835\\uDD12',\n    'Ograve': '\\u00D2',\n    'Omacr': '\\u014C',\n    'Omega': '\\u03A9',\n    'ohm': '\\u03A9',\n    'Omicron': '\\u039F',\n    'Oopf': '\\uD835\\uDD46',\n    'OpenCurlyDoubleQuote': '\\u201C',\n    'ldquo': '\\u201C',\n    'OpenCurlyQuote': '\\u2018',\n    'lsquo': '\\u2018',\n    'Or': '\\u2A54',\n    'Oscr': '\\uD835\\uDCAA',\n    'Oslash': '\\u00D8',\n    'Otilde': '\\u00D5',\n    'Otimes': '\\u2A37',\n    'Ouml': '\\u00D6',\n    'OverBar': '\\u203E',\n    'oline': '\\u203E',\n    'OverBrace': '\\u23DE',\n    'OverBracket': '\\u23B4',\n    'tbrk': '\\u23B4',\n    'OverParenthesis': '\\u23DC',\n    'PartialD': '\\u2202',\n    'part': '\\u2202',\n    'Pcy': '\\u041F',\n    'Pfr': '\\uD835\\uDD13',\n    'Phi': '\\u03A6',\n    'Pi': '\\u03A0',\n    'PlusMinus': '\\u00B1',\n    'plusmn': '\\u00B1',\n    'pm': '\\u00B1',\n    'Popf': '\\u2119',\n    'primes': '\\u2119',\n    'Pr': '\\u2ABB',\n    'Precedes': '\\u227A',\n    'pr': '\\u227A',\n    'prec': '\\u227A',\n    'PrecedesEqual': '\\u2AAF',\n    'pre': '\\u2AAF',\n    'preceq': '\\u2AAF',\n    'PrecedesSlantEqual': '\\u227C',\n    'prcue': '\\u227C',\n    'preccurlyeq': '\\u227C',\n    'PrecedesTilde': '\\u227E',\n    'precsim': '\\u227E',\n    'prsim': '\\u227E',\n    'Prime': '\\u2033',\n    'Product': '\\u220F',\n    'prod': '\\u220F',\n    'Proportional': '\\u221D',\n    'prop': '\\u221D',\n    'propto': '\\u221D',\n    'varpropto': '\\u221D',\n    'vprop': '\\u221D',\n    'Pscr': '\\uD835\\uDCAB',\n    'Psi': '\\u03A8',\n    'QUOT': '\\u0022',\n    'quot': '\\u0022',\n    'Qfr': '\\uD835\\uDD14',\n    'Qopf': '\\u211A',\n    'rationals': '\\u211A',\n    'Qscr': '\\uD835\\uDCAC',\n    'RBarr': '\\u2910',\n    'drbkarow': '\\u2910',\n    'REG': '\\u00AE',\n    'circledR': '\\u00AE',\n    'reg': '\\u00AE',\n    'Racute': '\\u0154',\n    'Rang': '\\u27EB',\n    'Rarr': '\\u21A0',\n    'twoheadrightarrow': '\\u21A0',\n    'Rarrtl': '\\u2916',\n    'Rcaron': '\\u0158',\n    'Rcedil': '\\u0156',\n    'Rcy': '\\u0420',\n    'Re': '\\u211C',\n    'Rfr': '\\u211C',\n    'real': '\\u211C',\n    'realpart': '\\u211C',\n    'ReverseElement': '\\u220B',\n    'SuchThat': '\\u220B',\n    'ni': '\\u220B',\n    'niv': '\\u220B',\n    'ReverseEquilibrium': '\\u21CB',\n    'leftrightharpoons': '\\u21CB',\n    'lrhar': '\\u21CB',\n    'ReverseUpEquilibrium': '\\u296F',\n    'duhar': '\\u296F',\n    'Rho': '\\u03A1',\n    'RightAngleBracket': '\\u27E9',\n    'rang': '\\u27E9',\n    'rangle': '\\u27E9',\n    'RightArrow': '\\u2192',\n    'ShortRightArrow': '\\u2192',\n    'rarr': '\\u2192',\n    'rightarrow': '\\u2192',\n    'srarr': '\\u2192',\n    'RightArrowBar': '\\u21E5',\n    'rarrb': '\\u21E5',\n    'RightArrowLeftArrow': '\\u21C4',\n    'rightleftarrows': '\\u21C4',\n    'rlarr': '\\u21C4',\n    'RightCeiling': '\\u2309',\n    'rceil': '\\u2309',\n    'RightDoubleBracket': '\\u27E7',\n    'robrk': '\\u27E7',\n    'RightDownTeeVector': '\\u295D',\n    'RightDownVector': '\\u21C2',\n    'dharr': '\\u21C2',\n    'downharpoonright': '\\u21C2',\n    'RightDownVectorBar': '\\u2955',\n    'RightFloor': '\\u230B',\n    'rfloor': '\\u230B',\n    'RightTee': '\\u22A2',\n    'vdash': '\\u22A2',\n    'RightTeeArrow': '\\u21A6',\n    'map': '\\u21A6',\n    'mapsto': '\\u21A6',\n    'RightTeeVector': '\\u295B',\n    'RightTriangle': '\\u22B3',\n    'vartriangleright': '\\u22B3',\n    'vrtri': '\\u22B3',\n    'RightTriangleBar': '\\u29D0',\n    'RightTriangleEqual': '\\u22B5',\n    'rtrie': '\\u22B5',\n    'trianglerighteq': '\\u22B5',\n    'RightUpDownVector': '\\u294F',\n    'RightUpTeeVector': '\\u295C',\n    'RightUpVector': '\\u21BE',\n    'uharr': '\\u21BE',\n    'upharpoonright': '\\u21BE',\n    'RightUpVectorBar': '\\u2954',\n    'RightVector': '\\u21C0',\n    'rharu': '\\u21C0',\n    'rightharpoonup': '\\u21C0',\n    'RightVectorBar': '\\u2953',\n    'Ropf': '\\u211D',\n    'reals': '\\u211D',\n    'RoundImplies': '\\u2970',\n    'Rrightarrow': '\\u21DB',\n    'rAarr': '\\u21DB',\n    'Rscr': '\\u211B',\n    'realine': '\\u211B',\n    'Rsh': '\\u21B1',\n    'rsh': '\\u21B1',\n    'RuleDelayed': '\\u29F4',\n    'SHCHcy': '\\u0429',\n    'SHcy': '\\u0428',\n    'SOFTcy': '\\u042C',\n    'Sacute': '\\u015A',\n    'Sc': '\\u2ABC',\n    'Scaron': '\\u0160',\n    'Scedil': '\\u015E',\n    'Scirc': '\\u015C',\n    'Scy': '\\u0421',\n    'Sfr': '\\uD835\\uDD16',\n    'ShortUpArrow': '\\u2191',\n    'UpArrow': '\\u2191',\n    'uarr': '\\u2191',\n    'uparrow': '\\u2191',\n    'Sigma': '\\u03A3',\n    'SmallCircle': '\\u2218',\n    'compfn': '\\u2218',\n    'Sopf': '\\uD835\\uDD4A',\n    'Sqrt': '\\u221A',\n    'radic': '\\u221A',\n    'Square': '\\u25A1',\n    'squ': '\\u25A1',\n    'square': '\\u25A1',\n    'SquareIntersection': '\\u2293',\n    'sqcap': '\\u2293',\n    'SquareSubset': '\\u228F',\n    'sqsub': '\\u228F',\n    'sqsubset': '\\u228F',\n    'SquareSubsetEqual': '\\u2291',\n    'sqsube': '\\u2291',\n    'sqsubseteq': '\\u2291',\n    'SquareSuperset': '\\u2290',\n    'sqsup': '\\u2290',\n    'sqsupset': '\\u2290',\n    'SquareSupersetEqual': '\\u2292',\n    'sqsupe': '\\u2292',\n    'sqsupseteq': '\\u2292',\n    'SquareUnion': '\\u2294',\n    'sqcup': '\\u2294',\n    'Sscr': '\\uD835\\uDCAE',\n    'Star': '\\u22C6',\n    'sstarf': '\\u22C6',\n    'Sub': '\\u22D0',\n    'Subset': '\\u22D0',\n    'SubsetEqual': '\\u2286',\n    'sube': '\\u2286',\n    'subseteq': '\\u2286',\n    'Succeeds': '\\u227B',\n    'sc': '\\u227B',\n    'succ': '\\u227B',\n    'SucceedsEqual': '\\u2AB0',\n    'sce': '\\u2AB0',\n    'succeq': '\\u2AB0',\n    'SucceedsSlantEqual': '\\u227D',\n    'sccue': '\\u227D',\n    'succcurlyeq': '\\u227D',\n    'SucceedsTilde': '\\u227F',\n    'scsim': '\\u227F',\n    'succsim': '\\u227F',\n    'Sum': '\\u2211',\n    'sum': '\\u2211',\n    'Sup': '\\u22D1',\n    'Supset': '\\u22D1',\n    'Superset': '\\u2283',\n    'sup': '\\u2283',\n    'supset': '\\u2283',\n    'SupersetEqual': '\\u2287',\n    'supe': '\\u2287',\n    'supseteq': '\\u2287',\n    'THORN': '\\u00DE',\n    'TRADE': '\\u2122',\n    'trade': '\\u2122',\n    'TSHcy': '\\u040B',\n    'TScy': '\\u0426',\n    'Tab': '\\u0009',\n    'Tau': '\\u03A4',\n    'Tcaron': '\\u0164',\n    'Tcedil': '\\u0162',\n    'Tcy': '\\u0422',\n    'Tfr': '\\uD835\\uDD17',\n    'Therefore': '\\u2234',\n    'there4': '\\u2234',\n    'therefore': '\\u2234',\n    'Theta': '\\u0398',\n    'ThickSpace': '\\u205F\\u200A',\n    'ThinSpace': '\\u2009',\n    'thinsp': '\\u2009',\n    'Tilde': '\\u223C',\n    'sim': '\\u223C',\n    'thicksim': '\\u223C',\n    'thksim': '\\u223C',\n    'TildeEqual': '\\u2243',\n    'sime': '\\u2243',\n    'simeq': '\\u2243',\n    'TildeFullEqual': '\\u2245',\n    'cong': '\\u2245',\n    'TildeTilde': '\\u2248',\n    'ap': '\\u2248',\n    'approx': '\\u2248',\n    'asymp': '\\u2248',\n    'thickapprox': '\\u2248',\n    'thkap': '\\u2248',\n    'Topf': '\\uD835\\uDD4B',\n    'TripleDot': '\\u20DB',\n    'tdot': '\\u20DB',\n    'Tscr': '\\uD835\\uDCAF',\n    'Tstrok': '\\u0166',\n    'Uacute': '\\u00DA',\n    'Uarr': '\\u219F',\n    'Uarrocir': '\\u2949',\n    'Ubrcy': '\\u040E',\n    'Ubreve': '\\u016C',\n    'Ucirc': '\\u00DB',\n    'Ucy': '\\u0423',\n    'Udblac': '\\u0170',\n    'Ufr': '\\uD835\\uDD18',\n    'Ugrave': '\\u00D9',\n    'Umacr': '\\u016A',\n    'UnderBar': '\\u005F',\n    'lowbar': '\\u005F',\n    'UnderBrace': '\\u23DF',\n    'UnderBracket': '\\u23B5',\n    'bbrk': '\\u23B5',\n    'UnderParenthesis': '\\u23DD',\n    'Union': '\\u22C3',\n    'bigcup': '\\u22C3',\n    'xcup': '\\u22C3',\n    'UnionPlus': '\\u228E',\n    'uplus': '\\u228E',\n    'Uogon': '\\u0172',\n    'Uopf': '\\uD835\\uDD4C',\n    'UpArrowBar': '\\u2912',\n    'UpArrowDownArrow': '\\u21C5',\n    'udarr': '\\u21C5',\n    'UpDownArrow': '\\u2195',\n    'updownarrow': '\\u2195',\n    'varr': '\\u2195',\n    'UpEquilibrium': '\\u296E',\n    'udhar': '\\u296E',\n    'UpTee': '\\u22A5',\n    'bot': '\\u22A5',\n    'bottom': '\\u22A5',\n    'perp': '\\u22A5',\n    'UpTeeArrow': '\\u21A5',\n    'mapstoup': '\\u21A5',\n    'UpperLeftArrow': '\\u2196',\n    'nwarr': '\\u2196',\n    'nwarrow': '\\u2196',\n    'UpperRightArrow': '\\u2197',\n    'nearr': '\\u2197',\n    'nearrow': '\\u2197',\n    'Upsi': '\\u03D2',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'Uring': '\\u016E',\n    'Uscr': '\\uD835\\uDCB0',\n    'Utilde': '\\u0168',\n    'Uuml': '\\u00DC',\n    'VDash': '\\u22AB',\n    'Vbar': '\\u2AEB',\n    'Vcy': '\\u0412',\n    'Vdash': '\\u22A9',\n    'Vdashl': '\\u2AE6',\n    'Vee': '\\u22C1',\n    'bigvee': '\\u22C1',\n    'xvee': '\\u22C1',\n    'Verbar': '\\u2016',\n    'Vert': '\\u2016',\n    'VerticalBar': '\\u2223',\n    'mid': '\\u2223',\n    'shortmid': '\\u2223',\n    'smid': '\\u2223',\n    'VerticalLine': '\\u007C',\n    'verbar': '\\u007C',\n    'vert': '\\u007C',\n    'VerticalSeparator': '\\u2758',\n    'VerticalTilde': '\\u2240',\n    'wr': '\\u2240',\n    'wreath': '\\u2240',\n    'VeryThinSpace': '\\u200A',\n    'hairsp': '\\u200A',\n    'Vfr': '\\uD835\\uDD19',\n    'Vopf': '\\uD835\\uDD4D',\n    'Vscr': '\\uD835\\uDCB1',\n    'Vvdash': '\\u22AA',\n    'Wcirc': '\\u0174',\n    'Wedge': '\\u22C0',\n    'bigwedge': '\\u22C0',\n    'xwedge': '\\u22C0',\n    'Wfr': '\\uD835\\uDD1A',\n    'Wopf': '\\uD835\\uDD4E',\n    'Wscr': '\\uD835\\uDCB2',\n    'Xfr': '\\uD835\\uDD1B',\n    'Xi': '\\u039E',\n    'Xopf': '\\uD835\\uDD4F',\n    'Xscr': '\\uD835\\uDCB3',\n    'YAcy': '\\u042F',\n    'YIcy': '\\u0407',\n    'YUcy': '\\u042E',\n    'Yacute': '\\u00DD',\n    'Ycirc': '\\u0176',\n    'Ycy': '\\u042B',\n    'Yfr': '\\uD835\\uDD1C',\n    'Yopf': '\\uD835\\uDD50',\n    'Yscr': '\\uD835\\uDCB4',\n    'Yuml': '\\u0178',\n    'ZHcy': '\\u0416',\n    'Zacute': '\\u0179',\n    'Zcaron': '\\u017D',\n    'Zcy': '\\u0417',\n    'Zdot': '\\u017B',\n    'Zeta': '\\u0396',\n    'Zfr': '\\u2128',\n    'zeetrf': '\\u2128',\n    'Zopf': '\\u2124',\n    'integers': '\\u2124',\n    'Zscr': '\\uD835\\uDCB5',\n    'aacute': '\\u00E1',\n    'abreve': '\\u0103',\n    'ac': '\\u223E',\n    'mstpos': '\\u223E',\n    'acE': '\\u223E\\u0333',\n    'acd': '\\u223F',\n    'acirc': '\\u00E2',\n    'acy': '\\u0430',\n    'aelig': '\\u00E6',\n    'afr': '\\uD835\\uDD1E',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'aleph': '\\u2135',\n    'alpha': '\\u03B1',\n    'amacr': '\\u0101',\n    'amalg': '\\u2A3F',\n    'and': '\\u2227',\n    'wedge': '\\u2227',\n    'andand': '\\u2A55',\n    'andd': '\\u2A5C',\n    'andslope': '\\u2A58',\n    'andv': '\\u2A5A',\n    'ang': '\\u2220',\n    'angle': '\\u2220',\n    'ange': '\\u29A4',\n    'angmsd': '\\u2221',\n    'measuredangle': '\\u2221',\n    'angmsdaa': '\\u29A8',\n    'angmsdab': '\\u29A9',\n    'angmsdac': '\\u29AA',\n    'angmsdad': '\\u29AB',\n    'angmsdae': '\\u29AC',\n    'angmsdaf': '\\u29AD',\n    'angmsdag': '\\u29AE',\n    'angmsdah': '\\u29AF',\n    'angrt': '\\u221F',\n    'angrtvb': '\\u22BE',\n    'angrtvbd': '\\u299D',\n    'angsph': '\\u2222',\n    'angzarr': '\\u237C',\n    'aogon': '\\u0105',\n    'aopf': '\\uD835\\uDD52',\n    'apE': '\\u2A70',\n    'apacir': '\\u2A6F',\n    'ape': '\\u224A',\n    'approxeq': '\\u224A',\n    'apid': '\\u224B',\n    'apos': '\\u0027',\n    'aring': '\\u00E5',\n    'ascr': '\\uD835\\uDCB6',\n    'ast': '\\u002A',\n    'midast': '\\u002A',\n    'atilde': '\\u00E3',\n    'auml': '\\u00E4',\n    'awint': '\\u2A11',\n    'bNot': '\\u2AED',\n    'backcong': '\\u224C',\n    'bcong': '\\u224C',\n    'backepsilon': '\\u03F6',\n    'bepsi': '\\u03F6',\n    'backprime': '\\u2035',\n    'bprime': '\\u2035',\n    'backsim': '\\u223D',\n    'bsim': '\\u223D',\n    'backsimeq': '\\u22CD',\n    'bsime': '\\u22CD',\n    'barvee': '\\u22BD',\n    'barwed': '\\u2305',\n    'barwedge': '\\u2305',\n    'bbrktbrk': '\\u23B6',\n    'bcy': '\\u0431',\n    'bdquo': '\\u201E',\n    'ldquor': '\\u201E',\n    'bemptyv': '\\u29B0',\n    'beta': '\\u03B2',\n    'beth': '\\u2136',\n    'between': '\\u226C',\n    'twixt': '\\u226C',\n    'bfr': '\\uD835\\uDD1F',\n    'bigcirc': '\\u25EF',\n    'xcirc': '\\u25EF',\n    'bigodot': '\\u2A00',\n    'xodot': '\\u2A00',\n    'bigoplus': '\\u2A01',\n    'xoplus': '\\u2A01',\n    'bigotimes': '\\u2A02',\n    'xotime': '\\u2A02',\n    'bigsqcup': '\\u2A06',\n    'xsqcup': '\\u2A06',\n    'bigstar': '\\u2605',\n    'starf': '\\u2605',\n    'bigtriangledown': '\\u25BD',\n    'xdtri': '\\u25BD',\n    'bigtriangleup': '\\u25B3',\n    'xutri': '\\u25B3',\n    'biguplus': '\\u2A04',\n    'xuplus': '\\u2A04',\n    'bkarow': '\\u290D',\n    'rbarr': '\\u290D',\n    'blacklozenge': '\\u29EB',\n    'lozf': '\\u29EB',\n    'blacktriangle': '\\u25B4',\n    'utrif': '\\u25B4',\n    'blacktriangledown': '\\u25BE',\n    'dtrif': '\\u25BE',\n    'blacktriangleleft': '\\u25C2',\n    'ltrif': '\\u25C2',\n    'blacktriangleright': '\\u25B8',\n    'rtrif': '\\u25B8',\n    'blank': '\\u2423',\n    'blk12': '\\u2592',\n    'blk14': '\\u2591',\n    'blk34': '\\u2593',\n    'block': '\\u2588',\n    'bne': '\\u003D\\u20E5',\n    'bnequiv': '\\u2261\\u20E5',\n    'bnot': '\\u2310',\n    'bopf': '\\uD835\\uDD53',\n    'bowtie': '\\u22C8',\n    'boxDL': '\\u2557',\n    'boxDR': '\\u2554',\n    'boxDl': '\\u2556',\n    'boxDr': '\\u2553',\n    'boxH': '\\u2550',\n    'boxHD': '\\u2566',\n    'boxHU': '\\u2569',\n    'boxHd': '\\u2564',\n    'boxHu': '\\u2567',\n    'boxUL': '\\u255D',\n    'boxUR': '\\u255A',\n    'boxUl': '\\u255C',\n    'boxUr': '\\u2559',\n    'boxV': '\\u2551',\n    'boxVH': '\\u256C',\n    'boxVL': '\\u2563',\n    'boxVR': '\\u2560',\n    'boxVh': '\\u256B',\n    'boxVl': '\\u2562',\n    'boxVr': '\\u255F',\n    'boxbox': '\\u29C9',\n    'boxdL': '\\u2555',\n    'boxdR': '\\u2552',\n    'boxdl': '\\u2510',\n    'boxdr': '\\u250C',\n    'boxhD': '\\u2565',\n    'boxhU': '\\u2568',\n    'boxhd': '\\u252C',\n    'boxhu': '\\u2534',\n    'boxminus': '\\u229F',\n    'minusb': '\\u229F',\n    'boxplus': '\\u229E',\n    'plusb': '\\u229E',\n    'boxtimes': '\\u22A0',\n    'timesb': '\\u22A0',\n    'boxuL': '\\u255B',\n    'boxuR': '\\u2558',\n    'boxul': '\\u2518',\n    'boxur': '\\u2514',\n    'boxv': '\\u2502',\n    'boxvH': '\\u256A',\n    'boxvL': '\\u2561',\n    'boxvR': '\\u255E',\n    'boxvh': '\\u253C',\n    'boxvl': '\\u2524',\n    'boxvr': '\\u251C',\n    'brvbar': '\\u00A6',\n    'bscr': '\\uD835\\uDCB7',\n    'bsemi': '\\u204F',\n    'bsol': '\\u005C',\n    'bsolb': '\\u29C5',\n    'bsolhsub': '\\u27C8',\n    'bull': '\\u2022',\n    'bullet': '\\u2022',\n    'bumpE': '\\u2AAE',\n    'cacute': '\\u0107',\n    'cap': '\\u2229',\n    'capand': '\\u2A44',\n    'capbrcup': '\\u2A49',\n    'capcap': '\\u2A4B',\n    'capcup': '\\u2A47',\n    'capdot': '\\u2A40',\n    'caps': '\\u2229\\uFE00',\n    'caret': '\\u2041',\n    'ccaps': '\\u2A4D',\n    'ccaron': '\\u010D',\n    'ccedil': '\\u00E7',\n    'ccirc': '\\u0109',\n    'ccups': '\\u2A4C',\n    'ccupssm': '\\u2A50',\n    'cdot': '\\u010B',\n    'cemptyv': '\\u29B2',\n    'cent': '\\u00A2',\n    'cfr': '\\uD835\\uDD20',\n    'chcy': '\\u0447',\n    'check': '\\u2713',\n    'checkmark': '\\u2713',\n    'chi': '\\u03C7',\n    'cir': '\\u25CB',\n    'cirE': '\\u29C3',\n    'circ': '\\u02C6',\n    'circeq': '\\u2257',\n    'cire': '\\u2257',\n    'circlearrowleft': '\\u21BA',\n    'olarr': '\\u21BA',\n    'circlearrowright': '\\u21BB',\n    'orarr': '\\u21BB',\n    'circledS': '\\u24C8',\n    'oS': '\\u24C8',\n    'circledast': '\\u229B',\n    'oast': '\\u229B',\n    'circledcirc': '\\u229A',\n    'ocir': '\\u229A',\n    'circleddash': '\\u229D',\n    'odash': '\\u229D',\n    'cirfnint': '\\u2A10',\n    'cirmid': '\\u2AEF',\n    'cirscir': '\\u29C2',\n    'clubs': '\\u2663',\n    'clubsuit': '\\u2663',\n    'colon': '\\u003A',\n    'comma': '\\u002C',\n    'commat': '\\u0040',\n    'comp': '\\u2201',\n    'complement': '\\u2201',\n    'congdot': '\\u2A6D',\n    'copf': '\\uD835\\uDD54',\n    'copysr': '\\u2117',\n    'crarr': '\\u21B5',\n    'cross': '\\u2717',\n    'cscr': '\\uD835\\uDCB8',\n    'csub': '\\u2ACF',\n    'csube': '\\u2AD1',\n    'csup': '\\u2AD0',\n    'csupe': '\\u2AD2',\n    'ctdot': '\\u22EF',\n    'cudarrl': '\\u2938',\n    'cudarrr': '\\u2935',\n    'cuepr': '\\u22DE',\n    'curlyeqprec': '\\u22DE',\n    'cuesc': '\\u22DF',\n    'curlyeqsucc': '\\u22DF',\n    'cularr': '\\u21B6',\n    'curvearrowleft': '\\u21B6',\n    'cularrp': '\\u293D',\n    'cup': '\\u222A',\n    'cupbrcap': '\\u2A48',\n    'cupcap': '\\u2A46',\n    'cupcup': '\\u2A4A',\n    'cupdot': '\\u228D',\n    'cupor': '\\u2A45',\n    'cups': '\\u222A\\uFE00',\n    'curarr': '\\u21B7',\n    'curvearrowright': '\\u21B7',\n    'curarrm': '\\u293C',\n    'curlyvee': '\\u22CE',\n    'cuvee': '\\u22CE',\n    'curlywedge': '\\u22CF',\n    'cuwed': '\\u22CF',\n    'curren': '\\u00A4',\n    'cwint': '\\u2231',\n    'cylcty': '\\u232D',\n    'dHar': '\\u2965',\n    'dagger': '\\u2020',\n    'daleth': '\\u2138',\n    'dash': '\\u2010',\n    'hyphen': '\\u2010',\n    'dbkarow': '\\u290F',\n    'rBarr': '\\u290F',\n    'dcaron': '\\u010F',\n    'dcy': '\\u0434',\n    'ddarr': '\\u21CA',\n    'downdownarrows': '\\u21CA',\n    'ddotseq': '\\u2A77',\n    'eDDot': '\\u2A77',\n    'deg': '\\u00B0',\n    'delta': '\\u03B4',\n    'demptyv': '\\u29B1',\n    'dfisht': '\\u297F',\n    'dfr': '\\uD835\\uDD21',\n    'diamondsuit': '\\u2666',\n    'diams': '\\u2666',\n    'digamma': '\\u03DD',\n    'gammad': '\\u03DD',\n    'disin': '\\u22F2',\n    'div': '\\u00F7',\n    'divide': '\\u00F7',\n    'divideontimes': '\\u22C7',\n    'divonx': '\\u22C7',\n    'djcy': '\\u0452',\n    'dlcorn': '\\u231E',\n    'llcorner': '\\u231E',\n    'dlcrop': '\\u230D',\n    'dollar': '\\u0024',\n    'dopf': '\\uD835\\uDD55',\n    'doteqdot': '\\u2251',\n    'eDot': '\\u2251',\n    'dotminus': '\\u2238',\n    'minusd': '\\u2238',\n    'dotplus': '\\u2214',\n    'plusdo': '\\u2214',\n    'dotsquare': '\\u22A1',\n    'sdotb': '\\u22A1',\n    'drcorn': '\\u231F',\n    'lrcorner': '\\u231F',\n    'drcrop': '\\u230C',\n    'dscr': '\\uD835\\uDCB9',\n    'dscy': '\\u0455',\n    'dsol': '\\u29F6',\n    'dstrok': '\\u0111',\n    'dtdot': '\\u22F1',\n    'dtri': '\\u25BF',\n    'triangledown': '\\u25BF',\n    'dwangle': '\\u29A6',\n    'dzcy': '\\u045F',\n    'dzigrarr': '\\u27FF',\n    'eacute': '\\u00E9',\n    'easter': '\\u2A6E',\n    'ecaron': '\\u011B',\n    'ecir': '\\u2256',\n    'eqcirc': '\\u2256',\n    'ecirc': '\\u00EA',\n    'ecolon': '\\u2255',\n    'eqcolon': '\\u2255',\n    'ecy': '\\u044D',\n    'edot': '\\u0117',\n    'efDot': '\\u2252',\n    'fallingdotseq': '\\u2252',\n    'efr': '\\uD835\\uDD22',\n    'eg': '\\u2A9A',\n    'egrave': '\\u00E8',\n    'egs': '\\u2A96',\n    'eqslantgtr': '\\u2A96',\n    'egsdot': '\\u2A98',\n    'el': '\\u2A99',\n    'elinters': '\\u23E7',\n    'ell': '\\u2113',\n    'els': '\\u2A95',\n    'eqslantless': '\\u2A95',\n    'elsdot': '\\u2A97',\n    'emacr': '\\u0113',\n    'empty': '\\u2205',\n    'emptyset': '\\u2205',\n    'emptyv': '\\u2205',\n    'varnothing': '\\u2205',\n    'emsp13': '\\u2004',\n    'emsp14': '\\u2005',\n    'emsp': '\\u2003',\n    'eng': '\\u014B',\n    'ensp': '\\u2002',\n    'eogon': '\\u0119',\n    'eopf': '\\uD835\\uDD56',\n    'epar': '\\u22D5',\n    'eparsl': '\\u29E3',\n    'eplus': '\\u2A71',\n    'epsi': '\\u03B5',\n    'epsilon': '\\u03B5',\n    'epsiv': '\\u03F5',\n    'straightepsilon': '\\u03F5',\n    'varepsilon': '\\u03F5',\n    'equals': '\\u003D',\n    'equest': '\\u225F',\n    'questeq': '\\u225F',\n    'equivDD': '\\u2A78',\n    'eqvparsl': '\\u29E5',\n    'erDot': '\\u2253',\n    'risingdotseq': '\\u2253',\n    'erarr': '\\u2971',\n    'escr': '\\u212F',\n    'eta': '\\u03B7',\n    'eth': '\\u00F0',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'excl': '\\u0021',\n    'fcy': '\\u0444',\n    'female': '\\u2640',\n    'ffilig': '\\uFB03',\n    'fflig': '\\uFB00',\n    'ffllig': '\\uFB04',\n    'ffr': '\\uD835\\uDD23',\n    'filig': '\\uFB01',\n    'fjlig': '\\u0066\\u006A',\n    'flat': '\\u266D',\n    'fllig': '\\uFB02',\n    'fltns': '\\u25B1',\n    'fnof': '\\u0192',\n    'fopf': '\\uD835\\uDD57',\n    'fork': '\\u22D4',\n    'pitchfork': '\\u22D4',\n    'forkv': '\\u2AD9',\n    'fpartint': '\\u2A0D',\n    'frac12': '\\u00BD',\n    'half': '\\u00BD',\n    'frac13': '\\u2153',\n    'frac14': '\\u00BC',\n    'frac15': '\\u2155',\n    'frac16': '\\u2159',\n    'frac18': '\\u215B',\n    'frac23': '\\u2154',\n    'frac25': '\\u2156',\n    'frac34': '\\u00BE',\n    'frac35': '\\u2157',\n    'frac38': '\\u215C',\n    'frac45': '\\u2158',\n    'frac56': '\\u215A',\n    'frac58': '\\u215D',\n    'frac78': '\\u215E',\n    'frasl': '\\u2044',\n    'frown': '\\u2322',\n    'sfrown': '\\u2322',\n    'fscr': '\\uD835\\uDCBB',\n    'gEl': '\\u2A8C',\n    'gtreqqless': '\\u2A8C',\n    'gacute': '\\u01F5',\n    'gamma': '\\u03B3',\n    'gap': '\\u2A86',\n    'gtrapprox': '\\u2A86',\n    'gbreve': '\\u011F',\n    'gcirc': '\\u011D',\n    'gcy': '\\u0433',\n    'gdot': '\\u0121',\n    'gescc': '\\u2AA9',\n    'gesdot': '\\u2A80',\n    'gesdoto': '\\u2A82',\n    'gesdotol': '\\u2A84',\n    'gesl': '\\u22DB\\uFE00',\n    'gesles': '\\u2A94',\n    'gfr': '\\uD835\\uDD24',\n    'gimel': '\\u2137',\n    'gjcy': '\\u0453',\n    'glE': '\\u2A92',\n    'gla': '\\u2AA5',\n    'glj': '\\u2AA4',\n    'gnE': '\\u2269',\n    'gneqq': '\\u2269',\n    'gnap': '\\u2A8A',\n    'gnapprox': '\\u2A8A',\n    'gne': '\\u2A88',\n    'gneq': '\\u2A88',\n    'gnsim': '\\u22E7',\n    'gopf': '\\uD835\\uDD58',\n    'gscr': '\\u210A',\n    'gsime': '\\u2A8E',\n    'gsiml': '\\u2A90',\n    'gtcc': '\\u2AA7',\n    'gtcir': '\\u2A7A',\n    'gtdot': '\\u22D7',\n    'gtrdot': '\\u22D7',\n    'gtlPar': '\\u2995',\n    'gtquest': '\\u2A7C',\n    'gtrarr': '\\u2978',\n    'gvertneqq': '\\u2269\\uFE00',\n    'gvnE': '\\u2269\\uFE00',\n    'hardcy': '\\u044A',\n    'harrcir': '\\u2948',\n    'harrw': '\\u21AD',\n    'leftrightsquigarrow': '\\u21AD',\n    'hbar': '\\u210F',\n    'hslash': '\\u210F',\n    'planck': '\\u210F',\n    'plankv': '\\u210F',\n    'hcirc': '\\u0125',\n    'hearts': '\\u2665',\n    'heartsuit': '\\u2665',\n    'hellip': '\\u2026',\n    'mldr': '\\u2026',\n    'hercon': '\\u22B9',\n    'hfr': '\\uD835\\uDD25',\n    'hksearow': '\\u2925',\n    'searhk': '\\u2925',\n    'hkswarow': '\\u2926',\n    'swarhk': '\\u2926',\n    'hoarr': '\\u21FF',\n    'homtht': '\\u223B',\n    'hookleftarrow': '\\u21A9',\n    'larrhk': '\\u21A9',\n    'hookrightarrow': '\\u21AA',\n    'rarrhk': '\\u21AA',\n    'hopf': '\\uD835\\uDD59',\n    'horbar': '\\u2015',\n    'hscr': '\\uD835\\uDCBD',\n    'hstrok': '\\u0127',\n    'hybull': '\\u2043',\n    'iacute': '\\u00ED',\n    'icirc': '\\u00EE',\n    'icy': '\\u0438',\n    'iecy': '\\u0435',\n    'iexcl': '\\u00A1',\n    'ifr': '\\uD835\\uDD26',\n    'igrave': '\\u00EC',\n    'iiiint': '\\u2A0C',\n    'qint': '\\u2A0C',\n    'iiint': '\\u222D',\n    'tint': '\\u222D',\n    'iinfin': '\\u29DC',\n    'iiota': '\\u2129',\n    'ijlig': '\\u0133',\n    'imacr': '\\u012B',\n    'imath': '\\u0131',\n    'inodot': '\\u0131',\n    'imof': '\\u22B7',\n    'imped': '\\u01B5',\n    'incare': '\\u2105',\n    'infin': '\\u221E',\n    'infintie': '\\u29DD',\n    'intcal': '\\u22BA',\n    'intercal': '\\u22BA',\n    'intlarhk': '\\u2A17',\n    'intprod': '\\u2A3C',\n    'iprod': '\\u2A3C',\n    'iocy': '\\u0451',\n    'iogon': '\\u012F',\n    'iopf': '\\uD835\\uDD5A',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'iscr': '\\uD835\\uDCBE',\n    'isinE': '\\u22F9',\n    'isindot': '\\u22F5',\n    'isins': '\\u22F4',\n    'isinsv': '\\u22F3',\n    'itilde': '\\u0129',\n    'iukcy': '\\u0456',\n    'iuml': '\\u00EF',\n    'jcirc': '\\u0135',\n    'jcy': '\\u0439',\n    'jfr': '\\uD835\\uDD27',\n    'jmath': '\\u0237',\n    'jopf': '\\uD835\\uDD5B',\n    'jscr': '\\uD835\\uDCBF',\n    'jsercy': '\\u0458',\n    'jukcy': '\\u0454',\n    'kappa': '\\u03BA',\n    'kappav': '\\u03F0',\n    'varkappa': '\\u03F0',\n    'kcedil': '\\u0137',\n    'kcy': '\\u043A',\n    'kfr': '\\uD835\\uDD28',\n    'kgreen': '\\u0138',\n    'khcy': '\\u0445',\n    'kjcy': '\\u045C',\n    'kopf': '\\uD835\\uDD5C',\n    'kscr': '\\uD835\\uDCC0',\n    'lAtail': '\\u291B',\n    'lBarr': '\\u290E',\n    'lEg': '\\u2A8B',\n    'lesseqqgtr': '\\u2A8B',\n    'lHar': '\\u2962',\n    'lacute': '\\u013A',\n    'laemptyv': '\\u29B4',\n    'lambda': '\\u03BB',\n    'langd': '\\u2991',\n    'lap': '\\u2A85',\n    'lessapprox': '\\u2A85',\n    'laquo': '\\u00AB',\n    'larrbfs': '\\u291F',\n    'larrfs': '\\u291D',\n    'larrlp': '\\u21AB',\n    'looparrowleft': '\\u21AB',\n    'larrpl': '\\u2939',\n    'larrsim': '\\u2973',\n    'larrtl': '\\u21A2',\n    'leftarrowtail': '\\u21A2',\n    'lat': '\\u2AAB',\n    'latail': '\\u2919',\n    'late': '\\u2AAD',\n    'lates': '\\u2AAD\\uFE00',\n    'lbarr': '\\u290C',\n    'lbbrk': '\\u2772',\n    'lbrace': '\\u007B',\n    'lcub': '\\u007B',\n    'lbrack': '\\u005B',\n    'lsqb': '\\u005B',\n    'lbrke': '\\u298B',\n    'lbrksld': '\\u298F',\n    'lbrkslu': '\\u298D',\n    'lcaron': '\\u013E',\n    'lcedil': '\\u013C',\n    'lcy': '\\u043B',\n    'ldca': '\\u2936',\n    'ldrdhar': '\\u2967',\n    'ldrushar': '\\u294B',\n    'ldsh': '\\u21B2',\n    'le': '\\u2264',\n    'leq': '\\u2264',\n    'leftleftarrows': '\\u21C7',\n    'llarr': '\\u21C7',\n    'leftthreetimes': '\\u22CB',\n    'lthree': '\\u22CB',\n    'lescc': '\\u2AA8',\n    'lesdot': '\\u2A7F',\n    'lesdoto': '\\u2A81',\n    'lesdotor': '\\u2A83',\n    'lesg': '\\u22DA\\uFE00',\n    'lesges': '\\u2A93',\n    'lessdot': '\\u22D6',\n    'ltdot': '\\u22D6',\n    'lfisht': '\\u297C',\n    'lfr': '\\uD835\\uDD29',\n    'lgE': '\\u2A91',\n    'lharul': '\\u296A',\n    'lhblk': '\\u2584',\n    'ljcy': '\\u0459',\n    'llhard': '\\u296B',\n    'lltri': '\\u25FA',\n    'lmidot': '\\u0140',\n    'lmoust': '\\u23B0',\n    'lmoustache': '\\u23B0',\n    'lnE': '\\u2268',\n    'lneqq': '\\u2268',\n    'lnap': '\\u2A89',\n    'lnapprox': '\\u2A89',\n    'lne': '\\u2A87',\n    'lneq': '\\u2A87',\n    'lnsim': '\\u22E6',\n    'loang': '\\u27EC',\n    'loarr': '\\u21FD',\n    'longmapsto': '\\u27FC',\n    'xmap': '\\u27FC',\n    'looparrowright': '\\u21AC',\n    'rarrlp': '\\u21AC',\n    'lopar': '\\u2985',\n    'lopf': '\\uD835\\uDD5D',\n    'loplus': '\\u2A2D',\n    'lotimes': '\\u2A34',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lozenge': '\\u25CA',\n    'lpar': '\\u0028',\n    'lparlt': '\\u2993',\n    'lrhard': '\\u296D',\n    'lrm': '\\u200E',\n    'lrtri': '\\u22BF',\n    'lsaquo': '\\u2039',\n    'lscr': '\\uD835\\uDCC1',\n    'lsime': '\\u2A8D',\n    'lsimg': '\\u2A8F',\n    'lsquor': '\\u201A',\n    'sbquo': '\\u201A',\n    'lstrok': '\\u0142',\n    'ltcc': '\\u2AA6',\n    'ltcir': '\\u2A79',\n    'ltimes': '\\u22C9',\n    'ltlarr': '\\u2976',\n    'ltquest': '\\u2A7B',\n    'ltrPar': '\\u2996',\n    'ltri': '\\u25C3',\n    'triangleleft': '\\u25C3',\n    'lurdshar': '\\u294A',\n    'luruhar': '\\u2966',\n    'lvertneqq': '\\u2268\\uFE00',\n    'lvnE': '\\u2268\\uFE00',\n    'mDDot': '\\u223A',\n    'macr': '\\u00AF',\n    'strns': '\\u00AF',\n    'male': '\\u2642',\n    'malt': '\\u2720',\n    'maltese': '\\u2720',\n    'marker': '\\u25AE',\n    'mcomma': '\\u2A29',\n    'mcy': '\\u043C',\n    'mdash': '\\u2014',\n    'mfr': '\\uD835\\uDD2A',\n    'mho': '\\u2127',\n    'micro': '\\u00B5',\n    'midcir': '\\u2AF0',\n    'minus': '\\u2212',\n    'minusdu': '\\u2A2A',\n    'mlcp': '\\u2ADB',\n    'models': '\\u22A7',\n    'mopf': '\\uD835\\uDD5E',\n    'mscr': '\\uD835\\uDCC2',\n    'mu': '\\u03BC',\n    'multimap': '\\u22B8',\n    'mumap': '\\u22B8',\n    'nGg': '\\u22D9\\u0338',\n    'nGt': '\\u226B\\u20D2',\n    'nLeftarrow': '\\u21CD',\n    'nlArr': '\\u21CD',\n    'nLeftrightarrow': '\\u21CE',\n    'nhArr': '\\u21CE',\n    'nLl': '\\u22D8\\u0338',\n    'nLt': '\\u226A\\u20D2',\n    'nRightarrow': '\\u21CF',\n    'nrArr': '\\u21CF',\n    'nVDash': '\\u22AF',\n    'nVdash': '\\u22AE',\n    'nacute': '\\u0144',\n    'nang': '\\u2220\\u20D2',\n    'napE': '\\u2A70\\u0338',\n    'napid': '\\u224B\\u0338',\n    'napos': '\\u0149',\n    'natur': '\\u266E',\n    'natural': '\\u266E',\n    'ncap': '\\u2A43',\n    'ncaron': '\\u0148',\n    'ncedil': '\\u0146',\n    'ncongdot': '\\u2A6D\\u0338',\n    'ncup': '\\u2A42',\n    'ncy': '\\u043D',\n    'ndash': '\\u2013',\n    'neArr': '\\u21D7',\n    'nearhk': '\\u2924',\n    'nedot': '\\u2250\\u0338',\n    'nesear': '\\u2928',\n    'toea': '\\u2928',\n    'nfr': '\\uD835\\uDD2B',\n    'nharr': '\\u21AE',\n    'nleftrightarrow': '\\u21AE',\n    'nhpar': '\\u2AF2',\n    'nis': '\\u22FC',\n    'nisd': '\\u22FA',\n    'njcy': '\\u045A',\n    'nlE': '\\u2266\\u0338',\n    'nleqq': '\\u2266\\u0338',\n    'nlarr': '\\u219A',\n    'nleftarrow': '\\u219A',\n    'nldr': '\\u2025',\n    'nopf': '\\uD835\\uDD5F',\n    'not': '\\u00AC',\n    'notinE': '\\u22F9\\u0338',\n    'notindot': '\\u22F5\\u0338',\n    'notinvb': '\\u22F7',\n    'notinvc': '\\u22F6',\n    'notnivb': '\\u22FE',\n    'notnivc': '\\u22FD',\n    'nparsl': '\\u2AFD\\u20E5',\n    'npart': '\\u2202\\u0338',\n    'npolint': '\\u2A14',\n    'nrarr': '\\u219B',\n    'nrightarrow': '\\u219B',\n    'nrarrc': '\\u2933\\u0338',\n    'nrarrw': '\\u219D\\u0338',\n    'nscr': '\\uD835\\uDCC3',\n    'nsub': '\\u2284',\n    'nsubE': '\\u2AC5\\u0338',\n    'nsubseteqq': '\\u2AC5\\u0338',\n    'nsup': '\\u2285',\n    'nsupE': '\\u2AC6\\u0338',\n    'nsupseteqq': '\\u2AC6\\u0338',\n    'ntilde': '\\u00F1',\n    'nu': '\\u03BD',\n    'num': '\\u0023',\n    'numero': '\\u2116',\n    'numsp': '\\u2007',\n    'nvDash': '\\u22AD',\n    'nvHarr': '\\u2904',\n    'nvap': '\\u224D\\u20D2',\n    'nvdash': '\\u22AC',\n    'nvge': '\\u2265\\u20D2',\n    'nvgt': '\\u003E\\u20D2',\n    'nvinfin': '\\u29DE',\n    'nvlArr': '\\u2902',\n    'nvle': '\\u2264\\u20D2',\n    'nvlt': '\\u003C\\u20D2',\n    'nvltrie': '\\u22B4\\u20D2',\n    'nvrArr': '\\u2903',\n    'nvrtrie': '\\u22B5\\u20D2',\n    'nvsim': '\\u223C\\u20D2',\n    'nwArr': '\\u21D6',\n    'nwarhk': '\\u2923',\n    'nwnear': '\\u2927',\n    'oacute': '\\u00F3',\n    'ocirc': '\\u00F4',\n    'ocy': '\\u043E',\n    'odblac': '\\u0151',\n    'odiv': '\\u2A38',\n    'odsold': '\\u29BC',\n    'oelig': '\\u0153',\n    'ofcir': '\\u29BF',\n    'ofr': '\\uD835\\uDD2C',\n    'ogon': '\\u02DB',\n    'ograve': '\\u00F2',\n    'ogt': '\\u29C1',\n    'ohbar': '\\u29B5',\n    'olcir': '\\u29BE',\n    'olcross': '\\u29BB',\n    'olt': '\\u29C0',\n    'omacr': '\\u014D',\n    'omega': '\\u03C9',\n    'omicron': '\\u03BF',\n    'omid': '\\u29B6',\n    'oopf': '\\uD835\\uDD60',\n    'opar': '\\u29B7',\n    'operp': '\\u29B9',\n    'or': '\\u2228',\n    'vee': '\\u2228',\n    'ord': '\\u2A5D',\n    'order': '\\u2134',\n    'orderof': '\\u2134',\n    'oscr': '\\u2134',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'origof': '\\u22B6',\n    'oror': '\\u2A56',\n    'orslope': '\\u2A57',\n    'orv': '\\u2A5B',\n    'oslash': '\\u00F8',\n    'osol': '\\u2298',\n    'otilde': '\\u00F5',\n    'otimesas': '\\u2A36',\n    'ouml': '\\u00F6',\n    'ovbar': '\\u233D',\n    'para': '\\u00B6',\n    'parsim': '\\u2AF3',\n    'parsl': '\\u2AFD',\n    'pcy': '\\u043F',\n    'percnt': '\\u0025',\n    'period': '\\u002E',\n    'permil': '\\u2030',\n    'pertenk': '\\u2031',\n    'pfr': '\\uD835\\uDD2D',\n    'phi': '\\u03C6',\n    'phiv': '\\u03D5',\n    'straightphi': '\\u03D5',\n    'varphi': '\\u03D5',\n    'phone': '\\u260E',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'varpi': '\\u03D6',\n    'planckh': '\\u210E',\n    'plus': '\\u002B',\n    'plusacir': '\\u2A23',\n    'pluscir': '\\u2A22',\n    'plusdu': '\\u2A25',\n    'pluse': '\\u2A72',\n    'plussim': '\\u2A26',\n    'plustwo': '\\u2A27',\n    'pointint': '\\u2A15',\n    'popf': '\\uD835\\uDD61',\n    'pound': '\\u00A3',\n    'prE': '\\u2AB3',\n    'prap': '\\u2AB7',\n    'precapprox': '\\u2AB7',\n    'precnapprox': '\\u2AB9',\n    'prnap': '\\u2AB9',\n    'precneqq': '\\u2AB5',\n    'prnE': '\\u2AB5',\n    'precnsim': '\\u22E8',\n    'prnsim': '\\u22E8',\n    'prime': '\\u2032',\n    'profalar': '\\u232E',\n    'profline': '\\u2312',\n    'profsurf': '\\u2313',\n    'prurel': '\\u22B0',\n    'pscr': '\\uD835\\uDCC5',\n    'psi': '\\u03C8',\n    'puncsp': '\\u2008',\n    'qfr': '\\uD835\\uDD2E',\n    'qopf': '\\uD835\\uDD62',\n    'qprime': '\\u2057',\n    'qscr': '\\uD835\\uDCC6',\n    'quatint': '\\u2A16',\n    'quest': '\\u003F',\n    'rAtail': '\\u291C',\n    'rHar': '\\u2964',\n    'race': '\\u223D\\u0331',\n    'racute': '\\u0155',\n    'raemptyv': '\\u29B3',\n    'rangd': '\\u2992',\n    'range': '\\u29A5',\n    'raquo': '\\u00BB',\n    'rarrap': '\\u2975',\n    'rarrbfs': '\\u2920',\n    'rarrc': '\\u2933',\n    'rarrfs': '\\u291E',\n    'rarrpl': '\\u2945',\n    'rarrsim': '\\u2974',\n    'rarrtl': '\\u21A3',\n    'rightarrowtail': '\\u21A3',\n    'rarrw': '\\u219D',\n    'rightsquigarrow': '\\u219D',\n    'ratail': '\\u291A',\n    'ratio': '\\u2236',\n    'rbbrk': '\\u2773',\n    'rbrace': '\\u007D',\n    'rcub': '\\u007D',\n    'rbrack': '\\u005D',\n    'rsqb': '\\u005D',\n    'rbrke': '\\u298C',\n    'rbrksld': '\\u298E',\n    'rbrkslu': '\\u2990',\n    'rcaron': '\\u0159',\n    'rcedil': '\\u0157',\n    'rcy': '\\u0440',\n    'rdca': '\\u2937',\n    'rdldhar': '\\u2969',\n    'rdsh': '\\u21B3',\n    'rect': '\\u25AD',\n    'rfisht': '\\u297D',\n    'rfr': '\\uD835\\uDD2F',\n    'rharul': '\\u296C',\n    'rho': '\\u03C1',\n    'rhov': '\\u03F1',\n    'varrho': '\\u03F1',\n    'rightrightarrows': '\\u21C9',\n    'rrarr': '\\u21C9',\n    'rightthreetimes': '\\u22CC',\n    'rthree': '\\u22CC',\n    'ring': '\\u02DA',\n    'rlm': '\\u200F',\n    'rmoust': '\\u23B1',\n    'rmoustache': '\\u23B1',\n    'rnmid': '\\u2AEE',\n    'roang': '\\u27ED',\n    'roarr': '\\u21FE',\n    'ropar': '\\u2986',\n    'ropf': '\\uD835\\uDD63',\n    'roplus': '\\u2A2E',\n    'rotimes': '\\u2A35',\n    'rpar': '\\u0029',\n    'rpargt': '\\u2994',\n    'rppolint': '\\u2A12',\n    'rsaquo': '\\u203A',\n    'rscr': '\\uD835\\uDCC7',\n    'rtimes': '\\u22CA',\n    'rtri': '\\u25B9',\n    'triangleright': '\\u25B9',\n    'rtriltri': '\\u29CE',\n    'ruluhar': '\\u2968',\n    'rx': '\\u211E',\n    'sacute': '\\u015B',\n    'scE': '\\u2AB4',\n    'scap': '\\u2AB8',\n    'succapprox': '\\u2AB8',\n    'scaron': '\\u0161',\n    'scedil': '\\u015F',\n    'scirc': '\\u015D',\n    'scnE': '\\u2AB6',\n    'succneqq': '\\u2AB6',\n    'scnap': '\\u2ABA',\n    'succnapprox': '\\u2ABA',\n    'scnsim': '\\u22E9',\n    'succnsim': '\\u22E9',\n    'scpolint': '\\u2A13',\n    'scy': '\\u0441',\n    'sdot': '\\u22C5',\n    'sdote': '\\u2A66',\n    'seArr': '\\u21D8',\n    'sect': '\\u00A7',\n    'semi': '\\u003B',\n    'seswar': '\\u2929',\n    'tosa': '\\u2929',\n    'sext': '\\u2736',\n    'sfr': '\\uD835\\uDD30',\n    'sharp': '\\u266F',\n    'shchcy': '\\u0449',\n    'shcy': '\\u0448',\n    'shy': '\\u00AD',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sigmav': '\\u03C2',\n    'varsigma': '\\u03C2',\n    'simdot': '\\u2A6A',\n    'simg': '\\u2A9E',\n    'simgE': '\\u2AA0',\n    'siml': '\\u2A9D',\n    'simlE': '\\u2A9F',\n    'simne': '\\u2246',\n    'simplus': '\\u2A24',\n    'simrarr': '\\u2972',\n    'smashp': '\\u2A33',\n    'smeparsl': '\\u29E4',\n    'smile': '\\u2323',\n    'ssmile': '\\u2323',\n    'smt': '\\u2AAA',\n    'smte': '\\u2AAC',\n    'smtes': '\\u2AAC\\uFE00',\n    'softcy': '\\u044C',\n    'sol': '\\u002F',\n    'solb': '\\u29C4',\n    'solbar': '\\u233F',\n    'sopf': '\\uD835\\uDD64',\n    'spades': '\\u2660',\n    'spadesuit': '\\u2660',\n    'sqcaps': '\\u2293\\uFE00',\n    'sqcups': '\\u2294\\uFE00',\n    'sscr': '\\uD835\\uDCC8',\n    'star': '\\u2606',\n    'sub': '\\u2282',\n    'subset': '\\u2282',\n    'subE': '\\u2AC5',\n    'subseteqq': '\\u2AC5',\n    'subdot': '\\u2ABD',\n    'subedot': '\\u2AC3',\n    'submult': '\\u2AC1',\n    'subnE': '\\u2ACB',\n    'subsetneqq': '\\u2ACB',\n    'subne': '\\u228A',\n    'subsetneq': '\\u228A',\n    'subplus': '\\u2ABF',\n    'subrarr': '\\u2979',\n    'subsim': '\\u2AC7',\n    'subsub': '\\u2AD5',\n    'subsup': '\\u2AD3',\n    'sung': '\\u266A',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supE': '\\u2AC6',\n    'supseteqq': '\\u2AC6',\n    'supdot': '\\u2ABE',\n    'supdsub': '\\u2AD8',\n    'supedot': '\\u2AC4',\n    'suphsol': '\\u27C9',\n    'suphsub': '\\u2AD7',\n    'suplarr': '\\u297B',\n    'supmult': '\\u2AC2',\n    'supnE': '\\u2ACC',\n    'supsetneqq': '\\u2ACC',\n    'supne': '\\u228B',\n    'supsetneq': '\\u228B',\n    'supplus': '\\u2AC0',\n    'supsim': '\\u2AC8',\n    'supsub': '\\u2AD4',\n    'supsup': '\\u2AD6',\n    'swArr': '\\u21D9',\n    'swnwar': '\\u292A',\n    'szlig': '\\u00DF',\n    'target': '\\u2316',\n    'tau': '\\u03C4',\n    'tcaron': '\\u0165',\n    'tcedil': '\\u0163',\n    'tcy': '\\u0442',\n    'telrec': '\\u2315',\n    'tfr': '\\uD835\\uDD31',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thetav': '\\u03D1',\n    'vartheta': '\\u03D1',\n    'thorn': '\\u00FE',\n    'times': '\\u00D7',\n    'timesbar': '\\u2A31',\n    'timesd': '\\u2A30',\n    'topbot': '\\u2336',\n    'topcir': '\\u2AF1',\n    'topf': '\\uD835\\uDD65',\n    'topfork': '\\u2ADA',\n    'tprime': '\\u2034',\n    'triangle': '\\u25B5',\n    'utri': '\\u25B5',\n    'triangleq': '\\u225C',\n    'trie': '\\u225C',\n    'tridot': '\\u25EC',\n    'triminus': '\\u2A3A',\n    'triplus': '\\u2A39',\n    'trisb': '\\u29CD',\n    'tritime': '\\u2A3B',\n    'trpezium': '\\u23E2',\n    'tscr': '\\uD835\\uDCC9',\n    'tscy': '\\u0446',\n    'tshcy': '\\u045B',\n    'tstrok': '\\u0167',\n    'uHar': '\\u2963',\n    'uacute': '\\u00FA',\n    'ubrcy': '\\u045E',\n    'ubreve': '\\u016D',\n    'ucirc': '\\u00FB',\n    'ucy': '\\u0443',\n    'udblac': '\\u0171',\n    'ufisht': '\\u297E',\n    'ufr': '\\uD835\\uDD32',\n    'ugrave': '\\u00F9',\n    'uhblk': '\\u2580',\n    'ulcorn': '\\u231C',\n    'ulcorner': '\\u231C',\n    'ulcrop': '\\u230F',\n    'ultri': '\\u25F8',\n    'umacr': '\\u016B',\n    'uogon': '\\u0173',\n    'uopf': '\\uD835\\uDD66',\n    'upsi': '\\u03C5',\n    'upsilon': '\\u03C5',\n    'upuparrows': '\\u21C8',\n    'uuarr': '\\u21C8',\n    'urcorn': '\\u231D',\n    'urcorner': '\\u231D',\n    'urcrop': '\\u230E',\n    'uring': '\\u016F',\n    'urtri': '\\u25F9',\n    'uscr': '\\uD835\\uDCCA',\n    'utdot': '\\u22F0',\n    'utilde': '\\u0169',\n    'uuml': '\\u00FC',\n    'uwangle': '\\u29A7',\n    'vBar': '\\u2AE8',\n    'vBarv': '\\u2AE9',\n    'vangrt': '\\u299C',\n    'varsubsetneq': '\\u228A\\uFE00',\n    'vsubne': '\\u228A\\uFE00',\n    'varsubsetneqq': '\\u2ACB\\uFE00',\n    'vsubnE': '\\u2ACB\\uFE00',\n    'varsupsetneq': '\\u228B\\uFE00',\n    'vsupne': '\\u228B\\uFE00',\n    'varsupsetneqq': '\\u2ACC\\uFE00',\n    'vsupnE': '\\u2ACC\\uFE00',\n    'vcy': '\\u0432',\n    'veebar': '\\u22BB',\n    'veeeq': '\\u225A',\n    'vellip': '\\u22EE',\n    'vfr': '\\uD835\\uDD33',\n    'vopf': '\\uD835\\uDD67',\n    'vscr': '\\uD835\\uDCCB',\n    'vzigzag': '\\u299A',\n    'wcirc': '\\u0175',\n    'wedbar': '\\u2A5F',\n    'wedgeq': '\\u2259',\n    'weierp': '\\u2118',\n    'wp': '\\u2118',\n    'wfr': '\\uD835\\uDD34',\n    'wopf': '\\uD835\\uDD68',\n    'wscr': '\\uD835\\uDCCC',\n    'xfr': '\\uD835\\uDD35',\n    'xi': '\\u03BE',\n    'xnis': '\\u22FB',\n    'xopf': '\\uD835\\uDD69',\n    'xscr': '\\uD835\\uDCCD',\n    'yacute': '\\u00FD',\n    'yacy': '\\u044F',\n    'ycirc': '\\u0177',\n    'ycy': '\\u044B',\n    'yen': '\\u00A5',\n    'yfr': '\\uD835\\uDD36',\n    'yicy': '\\u0457',\n    'yopf': '\\uD835\\uDD6A',\n    'yscr': '\\uD835\\uDCCE',\n    'yucy': '\\u044E',\n    'yuml': '\\u00FF',\n    'zacute': '\\u017A',\n    'zcaron': '\\u017E',\n    'zcy': '\\u0437',\n    'zdot': '\\u017C',\n    'zeta': '\\u03B6',\n    'zfr': '\\uD835\\uDD37',\n    'zhcy': '\\u0436',\n    'zigrarr': '\\u21DD',\n    'zopf': '\\uD835\\uDD6B',\n    'zscr': '\\uD835\\uDCCF',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C'\n};\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nconst NGSP_UNICODE = '\\uE500';\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass TokenError extends ParseError {\n    constructor(errorMsg, tokenType, span) {\n        super(span, errorMsg);\n        this.tokenType = tokenType;\n    }\n}\nclass TokenizeResult {\n    constructor(tokens, errors, nonNormalizedIcuExpressions) {\n        this.tokens = tokens;\n        this.errors = errors;\n        this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\n    }\n}\nfunction tokenize(source, url, getTagDefinition, options = {}) {\n    const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n    tokenizer.tokenize();\n    return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n    return `Unexpected character \"${char}\"`;\n}\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\nfunction _unparsableEntityErrorMsg(type, entityStr) {\n    return `Unable to parse entity \"${entityStr}\" - ${type} character reference entities must end with \";\"`;\n}\nvar CharacterReferenceType;\n(function (CharacterReferenceType) {\n    CharacterReferenceType[\"HEX\"] = \"hexadecimal\";\n    CharacterReferenceType[\"DEC\"] = \"decimal\";\n})(CharacterReferenceType || (CharacterReferenceType = {}));\nclass _ControlFlowError {\n    constructor(error) {\n        this.error = error;\n    }\n}\n// See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\nclass _Tokenizer {\n    /**\n     * @param _file The html source file being tokenized.\n     * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n     * @param options Configuration of the tokenization.\n     */\n    constructor(_file, _getTagDefinition, options) {\n        this._getTagDefinition = _getTagDefinition;\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this.nonNormalizedIcuExpressions = [];\n        this._tokenizeIcu = options.tokenizeExpansionForms || false;\n        this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        this._leadingTriviaCodePoints =\n            options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n        const range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };\n        this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\n            new PlainCharacterCursor(_file, range);\n        this._preserveLineEndings = options.preserveLineEndings || false;\n        this._escapedString = options.escapedString || false;\n        this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n        try {\n            this._cursor.init();\n        }\n        catch (e) {\n            this.handleError(e);\n        }\n    }\n    _processCarriageReturns(content) {\n        if (this._preserveLineEndings) {\n            return content;\n        }\n        // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    }\n    tokenize() {\n        while (this._cursor.peek() !== $EOF) {\n            const start = this._cursor.clone();\n            try {\n                if (this._attemptCharCode($LT)) {\n                    if (this._attemptCharCode($BANG)) {\n                        if (this._attemptCharCode($LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode($MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode($SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while\n                    // the premature end of an interpolation is given by the start of a new HTML element.\n                    this._consumeWithInterpolation(5 /* TEXT */, 8 /* INTERPOLATION */, () => this._isTextEnd(), () => this._isTagStart());\n                }\n            }\n            catch (e) {\n                this.handleError(e);\n            }\n        }\n        this._beginToken(24 /* EOF */);\n        this._endToken([]);\n    }\n    /**\n     * @returns whether an ICU token has been created\n     * @internal\n     */\n    _tokenizeExpansionForm() {\n        if (this.isExpansionFormStart()) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._cursor.peek() === $RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    }\n    _beginToken(type, start = this._cursor.clone()) {\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    }\n    _endToken(parts, end) {\n        if (this._currentTokenStart === null) {\n            throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));\n        }\n        if (this._currentTokenType === null) {\n            throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));\n        }\n        const token = {\n            type: this._currentTokenType,\n            parts,\n            sourceSpan: (end !== null && end !== void 0 ? end : this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints),\n        };\n        this.tokens.push(token);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return token;\n    }\n    _createError(msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n        }\n        const error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return new _ControlFlowError(error);\n    }\n    handleError(e) {\n        if (e instanceof CursorError) {\n            e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n        }\n        if (e instanceof _ControlFlowError) {\n            this.errors.push(e.error);\n        }\n        else {\n            throw e;\n        }\n    }\n    _attemptCharCode(charCode) {\n        if (this._cursor.peek() === charCode) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    }\n    _attemptCharCodeCaseInsensitive(charCode) {\n        if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    }\n    _requireCharCode(charCode) {\n        const location = this._cursor.clone();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    }\n    _attemptStr(chars) {\n        const len = chars.length;\n        if (this._cursor.charsLeft() < len) {\n            return false;\n        }\n        const initialPosition = this._cursor.clone();\n        for (let i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._cursor = initialPosition;\n                return false;\n            }\n        }\n        return true;\n    }\n    _attemptStrCaseInsensitive(chars) {\n        for (let i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _requireStr(chars) {\n        const location = this._cursor.clone();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    }\n    _attemptCharCodeUntilFn(predicate) {\n        while (!predicate(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n    }\n    _requireCharCodeUntilFn(predicate, len) {\n        const start = this._cursor.clone();\n        this._attemptCharCodeUntilFn(predicate);\n        if (this._cursor.diff(start) < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n    }\n    _attemptUntilChar(char) {\n        while (this._cursor.peek() !== char) {\n            this._cursor.advance();\n        }\n    }\n    _readChar() {\n        // Don't rely upon reading directly from `_input` as the actual char value\n        // may have been generated from an escape sequence.\n        const char = String.fromCodePoint(this._cursor.peek());\n        this._cursor.advance();\n        return char;\n    }\n    _consumeEntity(textTokenType) {\n        this._beginToken(9 /* ENCODED_ENTITY */);\n        const start = this._cursor.clone();\n        this._cursor.advance();\n        if (this._attemptCharCode($HASH)) {\n            const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n            const codeStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                // Advance cursor to include the peeked character in the string provided to the error\n                // message.\n                this._cursor.advance();\n                const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n                throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());\n            }\n            const strNum = this._cursor.getChars(codeStart);\n            this._cursor.advance();\n            try {\n                const charCode = parseInt(strNum, isHex ? 16 : 10);\n                this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);\n            }\n            catch (_a) {\n                throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n            }\n        }\n        else {\n            const nameStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                // No semicolon was found so abort the encoded entity token that was in progress, and treat\n                // this as a text token\n                this._beginToken(textTokenType, start);\n                this._cursor = nameStart;\n                this._endToken(['&']);\n            }\n            else {\n                const name = this._cursor.getChars(nameStart);\n                this._cursor.advance();\n                const char = NAMED_ENTITIES[name];\n                if (!char) {\n                    throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n                }\n                this._endToken([char, `&${name};`]);\n            }\n        }\n    }\n    _consumeRawText(consumeEntities, endMarkerPredicate) {\n        this._beginToken(consumeEntities ? 6 /* ESCAPABLE_RAW_TEXT */ : 7 /* RAW_TEXT */);\n        const parts = [];\n        while (true) {\n            const tagCloseStart = this._cursor.clone();\n            const foundEndMarker = endMarkerPredicate();\n            this._cursor = tagCloseStart;\n            if (foundEndMarker) {\n                break;\n            }\n            if (consumeEntities && this._cursor.peek() === $AMPERSAND) {\n                this._endToken([this._processCarriageReturns(parts.join(''))]);\n                parts.length = 0;\n                this._consumeEntity(6 /* ESCAPABLE_RAW_TEXT */);\n                this._beginToken(6 /* ESCAPABLE_RAW_TEXT */);\n            }\n            else {\n                parts.push(this._readChar());\n            }\n        }\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n    _consumeComment(start) {\n        this._beginToken(10 /* COMMENT_START */, start);\n        this._requireCharCode($MINUS);\n        this._endToken([]);\n        this._consumeRawText(false, () => this._attemptStr('-->'));\n        this._beginToken(11 /* COMMENT_END */);\n        this._requireStr('-->');\n        this._endToken([]);\n    }\n    _consumeCdata(start) {\n        this._beginToken(12 /* CDATA_START */, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        this._consumeRawText(false, () => this._attemptStr(']]>'));\n        this._beginToken(13 /* CDATA_END */);\n        this._requireStr(']]>');\n        this._endToken([]);\n    }\n    _consumeDocType(start) {\n        this._beginToken(18 /* DOC_TYPE */, start);\n        const contentStart = this._cursor.clone();\n        this._attemptUntilChar($GT);\n        const content = this._cursor.getChars(contentStart);\n        this._cursor.advance();\n        this._endToken([content]);\n    }\n    _consumePrefixAndName() {\n        const nameOrPrefixStart = this._cursor.clone();\n        let prefix = '';\n        while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n        let nameStart;\n        if (this._cursor.peek() === $COLON) {\n            prefix = this._cursor.getChars(nameOrPrefixStart);\n            this._cursor.advance();\n            nameStart = this._cursor.clone();\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n        const name = this._cursor.getChars(nameStart);\n        return [prefix, name];\n    }\n    _consumeTagOpen(start) {\n        let tagName;\n        let prefix;\n        let openTagToken;\n        try {\n            if (!isAsciiLetter(this._cursor.peek())) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n            }\n            openTagToken = this._consumeTagOpenStart(start);\n            prefix = openTagToken.parts[0];\n            tagName = openTagToken.parts[1];\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT &&\n                this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode($EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (e) {\n            if (e instanceof _ControlFlowError) {\n                if (openTagToken) {\n                    // We errored before we could close the opening tag, so it is incomplete.\n                    openTagToken.type = 4 /* INCOMPLETE_TAG_OPEN */;\n                }\n                else {\n                    // When the start tag is invalid, assume we want a \"<\" as text.\n                    // Back to back text tokens are merged at the end.\n                    this._beginToken(5 /* TEXT */, start);\n                    this._endToken(['<']);\n                }\n                return;\n            }\n            throw e;\n        }\n        const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n        if (contentTokenType === TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, false);\n        }\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, true);\n        }\n    }\n    _consumeRawTextWithTagClose(prefix, tagName, consumeEntities) {\n        this._consumeRawText(consumeEntities, () => {\n            if (!this._attemptCharCode($LT))\n                return false;\n            if (!this._attemptCharCode($SLASH))\n                return false;\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!this._attemptStrCaseInsensitive(tagName))\n                return false;\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            return this._attemptCharCode($GT);\n        });\n        this._beginToken(3 /* TAG_CLOSE */);\n        this._requireCharCodeUntilFn(code => code === $GT, 3);\n        this._cursor.advance(); // Consume the `>`\n        this._endToken([prefix, tagName]);\n    }\n    _consumeTagOpenStart(start) {\n        this._beginToken(0 /* TAG_OPEN_START */, start);\n        const parts = this._consumePrefixAndName();\n        return this._endToken(parts);\n    }\n    _consumeAttributeName() {\n        const attrNameStart = this._cursor.peek();\n        if (attrNameStart === $SQ || attrNameStart === $DQ) {\n            throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n        }\n        this._beginToken(14 /* ATTR_NAME */);\n        const prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    }\n    _consumeAttributeValue() {\n        let value;\n        if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n            const quoteChar = this._cursor.peek();\n            this._consumeQuote(quoteChar);\n            // In an attribute then end of the attribute value and the premature end to an interpolation\n            // are both triggered by the `quoteChar`.\n            const endPredicate = () => this._cursor.peek() === quoteChar;\n            this._consumeWithInterpolation(16 /* ATTR_VALUE_TEXT */, 17 /* ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);\n            this._consumeQuote(quoteChar);\n        }\n        else {\n            const endPredicate = () => isNameEnd(this._cursor.peek());\n            this._consumeWithInterpolation(16 /* ATTR_VALUE_TEXT */, 17 /* ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);\n        }\n    }\n    _consumeQuote(quoteChar) {\n        this._beginToken(15 /* ATTR_QUOTE */);\n        this._requireCharCode(quoteChar);\n        this._endToken([String.fromCodePoint(quoteChar)]);\n    }\n    _consumeTagOpenEnd() {\n        const tokenType = this._attemptCharCode($SLASH) ? 2 /* TAG_OPEN_END_VOID */ : 1 /* TAG_OPEN_END */;\n        this._beginToken(tokenType);\n        this._requireCharCode($GT);\n        this._endToken([]);\n    }\n    _consumeTagClose(start) {\n        this._beginToken(3 /* TAG_CLOSE */, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        const prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(prefixAndName);\n    }\n    _consumeExpansionFormStart() {\n        this._beginToken(19 /* EXPANSION_FORM_START */);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(19 /* EXPANSION_FORM_START */);\n        this._beginToken(7 /* RAW_TEXT */);\n        const condition = this._readUntil($COMMA);\n        const normalizedCondition = this._processCarriageReturns(condition);\n        if (this._i18nNormalizeLineEndingsInICUs) {\n            // We explicitly want to normalize line endings for this text.\n            this._endToken([normalizedCondition]);\n        }\n        else {\n            // We are not normalizing line endings.\n            const conditionToken = this._endToken([condition]);\n            if (normalizedCondition !== condition) {\n                this.nonNormalizedIcuExpressions.push(conditionToken);\n            }\n        }\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(7 /* RAW_TEXT */);\n        const type = this._readUntil($COMMA);\n        this._endToken([type]);\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    }\n    _consumeExpansionCaseStart() {\n        this._beginToken(20 /* EXPANSION_CASE_VALUE */);\n        const value = this._readUntil($LBRACE).trim();\n        this._endToken([value]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(21 /* EXPANSION_CASE_EXP_START */);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(21 /* EXPANSION_CASE_EXP_START */);\n    }\n    _consumeExpansionCaseEnd() {\n        this._beginToken(22 /* EXPANSION_CASE_EXP_END */);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    }\n    _consumeExpansionFormEnd() {\n        this._beginToken(23 /* EXPANSION_FORM_END */);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    }\n    /**\n     * Consume a string that may contain interpolation expressions.\n     *\n     * The first token consumed will be of `tokenType` and then there will be alternating\n     * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.\n     *\n     * If an interpolation token ends prematurely it will have no end marker in its `parts` array.\n     *\n     * @param textTokenType the kind of tokens to interleave around interpolation tokens.\n     * @param interpolationTokenType the kind of tokens that contain interpolation.\n     * @param endPredicate a function that should return true when we should stop consuming.\n     * @param endInterpolation a function that should return true if there is a premature end to an\n     *     interpolation expression - i.e. before we get to the normal interpolation closing marker.\n     */\n    _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {\n        this._beginToken(textTokenType);\n        const parts = [];\n        while (!endPredicate()) {\n            const current = this._cursor.clone();\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                this._endToken([this._processCarriageReturns(parts.join(''))], current);\n                parts.length = 0;\n                this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n                this._beginToken(textTokenType);\n            }\n            else if (this._cursor.peek() === $AMPERSAND) {\n                this._endToken([this._processCarriageReturns(parts.join(''))]);\n                parts.length = 0;\n                this._consumeEntity(textTokenType);\n                this._beginToken(textTokenType);\n            }\n            else {\n                parts.push(this._readChar());\n            }\n        }\n        // It is possible that an interpolation was started but not ended inside this text token.\n        // Make sure that we reset the state of the lexer correctly.\n        this._inInterpolation = false;\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n    /**\n     * Consume a block of text that has been interpreted as an Angular interpolation.\n     *\n     * @param interpolationTokenType the type of the interpolation token to generate.\n     * @param interpolationStart a cursor that points to the start of this interpolation.\n     * @param prematureEndPredicate a function that should return true if the next characters indicate\n     *     an end to the interpolation before its normal closing marker.\n     */\n    _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {\n        const parts = [];\n        this._beginToken(interpolationTokenType, interpolationStart);\n        parts.push(this._interpolationConfig.start);\n        // Find the end of the interpolation, ignoring content inside quotes.\n        const expressionStart = this._cursor.clone();\n        let inQuote = null;\n        let inComment = false;\n        while (this._cursor.peek() !== $EOF &&\n            (prematureEndPredicate === null || !prematureEndPredicate())) {\n            const current = this._cursor.clone();\n            if (this._isTagStart()) {\n                // We are starting what looks like an HTML element in the middle of this interpolation.\n                // Reset the cursor to before the `<` character and end the interpolation token.\n                // (This is actually wrong but here for backward compatibility).\n                this._cursor = current;\n                parts.push(this._getProcessedChars(expressionStart, current));\n                this._endToken(parts);\n                return;\n            }\n            if (inQuote === null) {\n                if (this._attemptStr(this._interpolationConfig.end)) {\n                    // We are not in a string, and we hit the end interpolation marker\n                    parts.push(this._getProcessedChars(expressionStart, current));\n                    parts.push(this._interpolationConfig.end);\n                    this._endToken(parts);\n                    return;\n                }\n                else if (this._attemptStr('//')) {\n                    // Once we are in a comment we ignore any quotes\n                    inComment = true;\n                }\n            }\n            const char = this._cursor.peek();\n            this._cursor.advance();\n            if (char === $BACKSLASH) {\n                // Skip the next character because it was escaped.\n                this._cursor.advance();\n            }\n            else if (char === inQuote) {\n                // Exiting the current quoted string\n                inQuote = null;\n            }\n            else if (!inComment && inQuote === null && isQuote(char)) {\n                // Entering a new quoted string\n                inQuote = char;\n            }\n        }\n        // We hit EOF without finding a closing interpolation marker\n        parts.push(this._getProcessedChars(expressionStart, this._cursor));\n        this._endToken(parts);\n    }\n    _getProcessedChars(start, end) {\n        return this._processCarriageReturns(end.getChars(start));\n    }\n    _isTextEnd() {\n        if (this._isTagStart() || this._cursor.peek() === $EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (this.isExpansionFormStart()) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns true if the current cursor is pointing to the start of a tag\n     * (opening/closing/comments/cdata/etc).\n     */\n    _isTagStart() {\n        if (this._cursor.peek() === $LT) {\n            // We assume that `<` followed by whitespace is not the start of an HTML element.\n            const tmp = this._cursor.clone();\n            tmp.advance();\n            // If the next character is alphabetic, ! nor / then it is a tag start\n            const code = tmp.peek();\n            if (($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n                code === $SLASH || code === $BANG) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _readUntil(char) {\n        const start = this._cursor.clone();\n        this._attemptUntilChar(char);\n        return this._cursor.getChars(start);\n    }\n    _isInExpansionCase() {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                21 /* EXPANSION_CASE_EXP_START */;\n    }\n    _isInExpansionForm() {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                19 /* EXPANSION_FORM_START */;\n    }\n    isExpansionFormStart() {\n        if (this._cursor.peek() !== $LBRACE) {\n            return false;\n        }\n        if (this._interpolationConfig) {\n            const start = this._cursor.clone();\n            const isInterpolation = this._attemptStr(this._interpolationConfig.start);\n            this._cursor = start;\n            return !isInterpolation;\n        }\n        return true;\n    }\n}\nfunction isNotWhitespace(code) {\n    return !isWhitespace(code) || code === $EOF;\n}\nfunction isNameEnd(code) {\n    return isWhitespace(code) || code === $GT || code === $LT ||\n        code === $SLASH || code === $SQ || code === $DQ || code === $EQ ||\n        code === $EOF;\n}\nfunction isPrefixEnd(code) {\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\n        (code < $0 || code > $9);\n}\nfunction isDigitEntityEnd(code) {\n    return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);\n}\nfunction isNamedEntityEnd(code) {\n    return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);\n}\nfunction isExpansionCaseStart(peek) {\n    return peek !== $RBRACE;\n}\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\nfunction toUpperCaseCharCode(code) {\n    return code >= $a && code <= $z ? code - $a + $A : code;\n}\nfunction mergeTextTokens(srcTokens) {\n    const dstTokens = [];\n    let lastDstToken = undefined;\n    for (let i = 0; i < srcTokens.length; i++) {\n        const token = srcTokens[i];\n        if ((lastDstToken && lastDstToken.type === 5 /* TEXT */ && token.type === 5 /* TEXT */) ||\n            (lastDstToken && lastDstToken.type === 16 /* ATTR_VALUE_TEXT */ &&\n                token.type === 16 /* ATTR_VALUE_TEXT */)) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\nclass PlainCharacterCursor {\n    constructor(fileOrCursor, range) {\n        if (fileOrCursor instanceof PlainCharacterCursor) {\n            this.file = fileOrCursor.file;\n            this.input = fileOrCursor.input;\n            this.end = fileOrCursor.end;\n            const state = fileOrCursor.state;\n            // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n            // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n            // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n            // called in tight loops, this difference matters.\n            this.state = {\n                peek: state.peek,\n                offset: state.offset,\n                line: state.line,\n                column: state.column,\n            };\n        }\n        else {\n            if (!range) {\n                throw new Error('Programming error: the range argument must be provided with a file argument.');\n            }\n            this.file = fileOrCursor;\n            this.input = fileOrCursor.content;\n            this.end = range.endPos;\n            this.state = {\n                peek: -1,\n                offset: range.startPos,\n                line: range.startLine,\n                column: range.startCol,\n            };\n        }\n    }\n    clone() {\n        return new PlainCharacterCursor(this);\n    }\n    peek() {\n        return this.state.peek;\n    }\n    charsLeft() {\n        return this.end - this.state.offset;\n    }\n    diff(other) {\n        return this.state.offset - other.state.offset;\n    }\n    advance() {\n        this.advanceState(this.state);\n    }\n    init() {\n        this.updatePeek(this.state);\n    }\n    getSpan(start, leadingTriviaCodePoints) {\n        start = start || this;\n        let fullStart = start;\n        if (leadingTriviaCodePoints) {\n            while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n                if (fullStart === start) {\n                    start = start.clone();\n                }\n                start.advance();\n            }\n        }\n        const startLocation = this.locationFromCursor(start);\n        const endLocation = this.locationFromCursor(this);\n        const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n        return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n    }\n    getChars(start) {\n        return this.input.substring(start.state.offset, this.state.offset);\n    }\n    charAt(pos) {\n        return this.input.charCodeAt(pos);\n    }\n    advanceState(state) {\n        if (state.offset >= this.end) {\n            this.state = state;\n            throw new CursorError('Unexpected character \"EOF\"', this);\n        }\n        const currentChar = this.charAt(state.offset);\n        if (currentChar === $LF) {\n            state.line++;\n            state.column = 0;\n        }\n        else if (!isNewLine(currentChar)) {\n            state.column++;\n        }\n        state.offset++;\n        this.updatePeek(state);\n    }\n    updatePeek(state) {\n        state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n    }\n    locationFromCursor(cursor) {\n        return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n    }\n}\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n    constructor(fileOrCursor, range) {\n        if (fileOrCursor instanceof EscapedCharacterCursor) {\n            super(fileOrCursor);\n            this.internalState = Object.assign({}, fileOrCursor.internalState);\n        }\n        else {\n            super(fileOrCursor, range);\n            this.internalState = this.state;\n        }\n    }\n    advance() {\n        this.state = this.internalState;\n        super.advance();\n        this.processEscapeSequence();\n    }\n    init() {\n        super.init();\n        this.processEscapeSequence();\n    }\n    clone() {\n        return new EscapedCharacterCursor(this);\n    }\n    getChars(start) {\n        const cursor = start.clone();\n        let chars = '';\n        while (cursor.internalState.offset < this.internalState.offset) {\n            chars += String.fromCodePoint(cursor.peek());\n            cursor.advance();\n        }\n        return chars;\n    }\n    /**\n     * Process the escape sequence that starts at the current position in the text.\n     *\n     * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n     */\n    processEscapeSequence() {\n        const peek = () => this.internalState.peek;\n        if (peek() === $BACKSLASH) {\n            // We have hit an escape sequence so we need the internal state to become independent\n            // of the external state.\n            this.internalState = Object.assign({}, this.state);\n            // Move past the backslash\n            this.advanceState(this.internalState);\n            // First check for standard control char sequences\n            if (peek() === $n) {\n                this.state.peek = $LF;\n            }\n            else if (peek() === $r) {\n                this.state.peek = $CR;\n            }\n            else if (peek() === $v) {\n                this.state.peek = $VTAB;\n            }\n            else if (peek() === $t) {\n                this.state.peek = $TAB;\n            }\n            else if (peek() === $b) {\n                this.state.peek = $BSPACE;\n            }\n            else if (peek() === $f) {\n                this.state.peek = $FF;\n            }\n            // Now consider more complex sequences\n            else if (peek() === $u) {\n                // Unicode code-point sequence\n                this.advanceState(this.internalState); // advance past the `u` char\n                if (peek() === $LBRACE) {\n                    // Variable length Unicode, e.g. `\\x{123}`\n                    this.advanceState(this.internalState); // advance past the `{` char\n                    // Advance past the variable number of hex digits until we hit a `}` char\n                    const digitStart = this.clone();\n                    let length = 0;\n                    while (peek() !== $RBRACE) {\n                        this.advanceState(this.internalState);\n                        length++;\n                    }\n                    this.state.peek = this.decodeHexDigits(digitStart, length);\n                }\n                else {\n                    // Fixed length Unicode, e.g. `\\u1234`\n                    const digitStart = this.clone();\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.state.peek = this.decodeHexDigits(digitStart, 4);\n                }\n            }\n            else if (peek() === $x) {\n                // Hex char code, e.g. `\\x2F`\n                this.advanceState(this.internalState); // advance past the `x` char\n                const digitStart = this.clone();\n                this.advanceState(this.internalState);\n                this.state.peek = this.decodeHexDigits(digitStart, 2);\n            }\n            else if (isOctalDigit(peek())) {\n                // Octal char code, e.g. `\\012`,\n                let octal = '';\n                let length = 0;\n                let previous = this.clone();\n                while (isOctalDigit(peek()) && length < 3) {\n                    previous = this.clone();\n                    octal += String.fromCodePoint(peek());\n                    this.advanceState(this.internalState);\n                    length++;\n                }\n                this.state.peek = parseInt(octal, 8);\n                // Backup one char\n                this.internalState = previous.internalState;\n            }\n            else if (isNewLine(this.internalState.peek)) {\n                // Line continuation `\\` followed by a new line\n                this.advanceState(this.internalState); // advance over the newline\n                this.state = this.internalState;\n            }\n            else {\n                // If none of the `if` blocks were executed then we just have an escaped normal character.\n                // In that case we just, effectively, skip the backslash from the character.\n                this.state.peek = this.internalState.peek;\n            }\n        }\n    }\n    decodeHexDigits(start, length) {\n        const hex = this.input.substr(start.internalState.offset, length);\n        const charCode = parseInt(hex, 16);\n        if (!isNaN(charCode)) {\n            return charCode;\n        }\n        else {\n            start.state = start.internalState;\n            throw new CursorError('Invalid hexadecimal escape sequence', start);\n        }\n    }\n}\nclass CursorError {\n    constructor(msg, cursor) {\n        this.msg = msg;\n        this.cursor = cursor;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass TreeError extends ParseError {\n    constructor(elementName, span, msg) {\n        super(span, msg);\n        this.elementName = elementName;\n    }\n    static create(elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    }\n}\nclass ParseTreeResult {\n    constructor(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n}\nclass Parser {\n    constructor(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    parse(source, url, options) {\n        const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n        const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n        parser.build();\n        return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));\n    }\n}\nclass _TreeBuilder {\n    constructor(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._elementStack = [];\n        this.rootNodes = [];\n        this.errors = [];\n        this._advance();\n    }\n    build() {\n        while (this._peek.type !== 24 /* EOF */) {\n            if (this._peek.type === 0 /* TAG_OPEN_START */ ||\n                this._peek.type === 4 /* INCOMPLETE_TAG_OPEN */) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === 3 /* TAG_CLOSE */) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === 12 /* CDATA_START */) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === 10 /* COMMENT_START */) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === 5 /* TEXT */ || this._peek.type === 7 /* RAW_TEXT */ ||\n                this._peek.type === 6 /* ESCAPABLE_RAW_TEXT */) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === 19 /* EXPANSION_FORM_START */) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n    }\n    _advance() {\n        const prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    }\n    _advanceIf(type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    }\n    _consumeCdata(_startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(13 /* CDATA_END */);\n    }\n    _consumeComment(token) {\n        const text = this._advanceIf(7 /* RAW_TEXT */);\n        this._advanceIf(11 /* COMMENT_END */);\n        const value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new Comment(value, token.sourceSpan));\n    }\n    _consumeExpansion(token) {\n        const switchValue = this._advance();\n        const type = this._advance();\n        const cases = [];\n        // read =\n        while (this._peek.type === 20 /* EXPANSION_CASE_VALUE */) {\n            const expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== 23 /* EXPANSION_FORM_END */) {\n            this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n            return;\n        }\n        const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    }\n    _parseExpansionCase() {\n        const value = this._advance();\n        // read {\n        if (this._peek.type !== 21 /* EXPANSION_CASE_EXP_START */) {\n            this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n            return null;\n        }\n        // read until }\n        const start = this._advance();\n        const exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        const end = this._advance();\n        exp.push({ type: 24 /* EOF */, parts: [], sourceSpan: end.sourceSpan });\n        // parse everything in between { and }\n        const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);\n        expansionCaseParser.build();\n        if (expansionCaseParser.errors.length > 0) {\n            this.errors = this.errors.concat(expansionCaseParser.errors);\n            return null;\n        }\n        const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\n        const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\n        return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    }\n    _collectExpansionExpTokens(start) {\n        const exp = [];\n        const expansionFormStack = [21 /* EXPANSION_CASE_EXP_START */];\n        while (true) {\n            if (this._peek.type === 19 /* EXPANSION_FORM_START */ ||\n                this._peek.type === 21 /* EXPANSION_CASE_EXP_START */) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === 22 /* EXPANSION_CASE_EXP_END */) {\n                if (lastOnStack(expansionFormStack, 21 /* EXPANSION_CASE_EXP_START */)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length === 0)\n                        return exp;\n                }\n                else {\n                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                    return null;\n                }\n            }\n            if (this._peek.type === 23 /* EXPANSION_FORM_END */) {\n                if (lastOnStack(expansionFormStack, 19 /* EXPANSION_FORM_START */)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                    return null;\n                }\n            }\n            if (this._peek.type === 24 /* EOF */) {\n                this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    }\n    _consumeText(token) {\n        const tokens = [token];\n        const startSpan = token.sourceSpan;\n        let text = token.parts[0];\n        if (text.length > 0 && text[0] === '\\n') {\n            const parent = this._getParentElement();\n            if (parent != null && parent.children.length === 0 &&\n                this.getTagDefinition(parent.name).ignoreFirstLf) {\n                text = text.substring(1);\n                tokens[0] = { type: token.type, sourceSpan: token.sourceSpan, parts: [text] };\n            }\n        }\n        while (this._peek.type === 8 /* INTERPOLATION */ || this._peek.type === 5 /* TEXT */ ||\n            this._peek.type === 9 /* ENCODED_ENTITY */) {\n            token = this._advance();\n            tokens.push(token);\n            if (token.type === 8 /* INTERPOLATION */) {\n                // For backward compatibility we decode HTML entities that appear in interpolation\n                // expressions. This is arguably a bug, but it could be a considerable breaking change to\n                // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n                // chain after View Engine has been removed.\n                text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n            }\n            else if (token.type === 9 /* ENCODED_ENTITY */) {\n                text += token.parts[0];\n            }\n            else {\n                text += token.parts.join('');\n            }\n        }\n        if (text.length > 0) {\n            const endSpan = token.sourceSpan;\n            this._addToParent(new Text(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));\n        }\n    }\n    _closeVoidElement() {\n        const el = this._getParentElement();\n        if (el && this.getTagDefinition(el.name).isVoid) {\n            this._elementStack.pop();\n        }\n    }\n    _consumeStartTag(startTagToken) {\n        const [prefix, name] = startTagToken.parts;\n        const attrs = [];\n        while (this._peek.type === 14 /* ATTR_NAME */) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        const fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        let selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === 2 /* TAG_OPEN_END_VOID */) {\n            this._advance();\n            selfClosing = true;\n            const tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\n            }\n        }\n        else if (this._peek.type === 1 /* TAG_OPEN_END */) {\n            this._advance();\n            selfClosing = false;\n        }\n        const end = this._peek.sourceSpan.fullStart;\n        const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n        // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n        const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n        const el = new Element(fullName, attrs, [], span, startSpan, undefined);\n        this._pushElement(el);\n        if (selfClosing) {\n            // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n            // element start tag also represents the end tag.\n            this._popElement(fullName, span);\n        }\n        else if (startTagToken.type === 4 /* INCOMPLETE_TAG_OPEN */) {\n            // We already know the opening tag is not complete, so it is unlikely it has a corresponding\n            // close tag. Let's optimistically parse it as a full element and emit an error.\n            this._popElement(fullName, null);\n            this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n        }\n    }\n    _pushElement(el) {\n        const parentEl = this._getParentElement();\n        if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n            this._elementStack.pop();\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    }\n    _consumeEndTag(endTagToken) {\n        const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this.getTagDefinition(fullName).isVoid) {\n            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n        }\n        else if (!this._popElement(fullName, endTagToken.sourceSpan)) {\n            const errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    }\n    /**\n     * Closes the nearest element with the tag name `fullName` in the parse tree.\n     * `endSourceSpan` is the span of the closing tag, or null if the element does\n     * not have a closing tag (for example, this happens when an incomplete\n     * opening tag is recovered).\n     */\n    _popElement(fullName, endSourceSpan) {\n        let unexpectedCloseTagDetected = false;\n        for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            const el = this._elementStack[stackIndex];\n            if (el.name === fullName) {\n                // Record the parse span with the element that is being closed. Any elements that are\n                // removed from the element stack at this point are closed implicitly, so they won't get\n                // an end source span (as there is no explicit closing element).\n                el.endSourceSpan = endSourceSpan;\n                el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return !unexpectedCloseTagDetected;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                // Note that we encountered an unexpected close tag but continue processing the element\n                // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\n                // end tag in the stack.\n                unexpectedCloseTagDetected = true;\n            }\n        }\n        return false;\n    }\n    _consumeAttr(attrName) {\n        const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        let attrEnd = attrName.sourceSpan.end;\n        // Consume any quote\n        if (this._peek.type === 15 /* ATTR_QUOTE */) {\n            this._advance();\n        }\n        // Consume the attribute value\n        let value = '';\n        const valueTokens = [];\n        let valueStartSpan = undefined;\n        let valueEnd = undefined;\n        // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of\n        // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from\n        // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not\n        // able to see that `_advance()` will actually mutate `_peek`.\n        const nextTokenType = this._peek.type;\n        if (nextTokenType === 16 /* ATTR_VALUE_TEXT */) {\n            valueStartSpan = this._peek.sourceSpan;\n            valueEnd = this._peek.sourceSpan.end;\n            while (this._peek.type === 16 /* ATTR_VALUE_TEXT */ ||\n                this._peek.type === 17 /* ATTR_VALUE_INTERPOLATION */ ||\n                this._peek.type === 9 /* ENCODED_ENTITY */) {\n                const valueToken = this._advance();\n                valueTokens.push(valueToken);\n                if (valueToken.type === 17 /* ATTR_VALUE_INTERPOLATION */) {\n                    // For backward compatibility we decode HTML entities that appear in interpolation\n                    // expressions. This is arguably a bug, but it could be a considerable breaking change to\n                    // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n                    // chain after View Engine has been removed.\n                    value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n                }\n                else if (valueToken.type === 9 /* ENCODED_ENTITY */) {\n                    value += valueToken.parts[0];\n                }\n                else {\n                    value += valueToken.parts.join('');\n                }\n                valueEnd = attrEnd = valueToken.sourceSpan.end;\n            }\n        }\n        // Consume any quote\n        if (this._peek.type === 15 /* ATTR_QUOTE */) {\n            const quoteToken = this._advance();\n            attrEnd = quoteToken.sourceSpan.end;\n        }\n        const valueSpan = valueStartSpan && valueEnd &&\n            new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n        return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);\n    }\n    _getParentElement() {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    }\n    _addToParent(node) {\n        const parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this.rootNodes.push(node);\n        }\n    }\n    _getElementFullName(prefix, localName, parentElement) {\n        if (prefix === '') {\n            prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n            if (prefix === '' && parentElement != null) {\n                const parentTagName = splitNsName(parentElement.name)[1];\n                const parentTagDefinition = this.getTagDefinition(parentTagName);\n                if (!parentTagDefinition.preventNamespaceInheritance) {\n                    prefix = getNsPrefix(parentElement.name);\n                }\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    }\n}\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n/**\n * Decode the `entity` string, which we believe is the contents of an HTML entity.\n *\n * If the string is not actually a valid/known entity then just return the original `match` string.\n */\nfunction decodeEntity(match, entity) {\n    if (NAMED_ENTITIES[entity] !== undefined) {\n        return NAMED_ENTITIES[entity] || match;\n    }\n    if (/^#x[a-f0-9]+$/i.test(entity)) {\n        return String.fromCodePoint(parseInt(entity.slice(2), 16));\n    }\n    if (/^#\\d+$/.test(entity)) {\n        return String.fromCodePoint(parseInt(entity.slice(1), 10));\n    }\n    return match;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass HtmlParser extends Parser {\n    constructor() {\n        super(getHtmlTagDefinition);\n    }\n    parse(source, url, options) {\n        return super.parse(source, url, options);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\nfunction hasPreserveWhitespacesAttr(attrs) {\n    return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);\n}\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here.\n */\nfunction replaceNgsp(value) {\n    // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n    return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\nclass WhitespaceVisitor {\n    visitElement(element, context) {\n        if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n            // don't descent into elements where we need to preserve whitespaces\n            // but still visit all attributes to eliminate one used as a market to preserve WS\n            return new Element(element.name, visitAll(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        return new Element(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n    visitAttribute(attribute, context) {\n        return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n    }\n    visitText(text, context) {\n        const isNotBlank = text.value.match(NO_WS_REGEXP);\n        const hasExpansionSibling = context &&\n            (context.prev instanceof Expansion || context.next instanceof Expansion);\n        if (isNotBlank || hasExpansionSibling) {\n            // Process the whitespace in the tokens of this Text node\n            const tokens = text.tokens.map(token => token.type === 5 /* TEXT */ ? createWhitespaceProcessedTextToken(token) : token);\n            // Process the whitespace of the value of this Text node\n            const value = processWhitespace(text.value);\n            return new Text(value, text.sourceSpan, tokens, text.i18n);\n        }\n        return null;\n    }\n    visitComment(comment, context) {\n        return comment;\n    }\n    visitExpansion(expansion, context) {\n        return expansion;\n    }\n    visitExpansionCase(expansionCase, context) {\n        return expansionCase;\n    }\n}\nfunction createWhitespaceProcessedTextToken({ type, parts, sourceSpan }) {\n    return { type, parts: [processWhitespace(parts[0])], sourceSpan };\n}\nfunction processWhitespace(text) {\n    return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');\n}\nfunction removeWhitespaces(htmlAstWithErrors) {\n    return new ParseTreeResult(visitAll(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);\n}\nfunction visitAllWithSiblings(visitor, nodes) {\n    const result = [];\n    nodes.forEach((ast, i) => {\n        const context = { prev: nodes[i - 1], next: nodes[i + 1] };\n        const astResult = ast.visit(visitor, context);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mapEntry(key, value) {\n    return { key, value, quoted: false };\n}\nfunction mapLiteral(obj, quoted = false) {\n    return literalMap(Object.keys(obj).map(key => ({\n        key,\n        quoted,\n        value: obj[key],\n    })));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */\nlet _SECURITY_SCHEMA;\nfunction SECURITY_SCHEMA() {\n    if (!_SECURITY_SCHEMA) {\n        _SECURITY_SCHEMA = {};\n        // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n        registerContext(SecurityContext.HTML, [\n            'iframe|srcdoc',\n            '*|innerHTML',\n            '*|outerHTML',\n        ]);\n        registerContext(SecurityContext.STYLE, ['*|style']);\n        // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n        registerContext(SecurityContext.URL, [\n            '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n            'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n            'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n            'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n        ]);\n        registerContext(SecurityContext.RESOURCE_URL, [\n            'applet|code',\n            'applet|codebase',\n            'base|href',\n            'embed|src',\n            'frame|src',\n            'head|profile',\n            'html|manifest',\n            'iframe|src',\n            'link|href',\n            'media|src',\n            'object|codebase',\n            'object|data',\n            'script|src',\n        ]);\n    }\n    return _SECURITY_SCHEMA;\n}\nfunction registerContext(ctx, specs) {\n    for (const spec of specs)\n        _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ElementSchemaRegistry {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst EVENT = 'event';\nconst BOOLEAN = 'boolean';\nconst NUMBER = 'number';\nconst STRING = 'string';\nconst OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\nconst SCHEMA = [\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\n        /* added manually to avoid breaking changes */\n        ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n    'select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'shadow^[HTMLElement]|',\n    'slot^[HTMLElement]|name',\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|#height,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n    ':svg:cursor^:svg:|',\n];\nconst _ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n};\n// Invert _ATTR_TO_PROP.\nconst _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce((inverted, attr) => {\n    inverted[_ATTR_TO_PROP[attr]] = attr;\n    return inverted;\n}, {});\nclass DomElementSchemaRegistry extends ElementSchemaRegistry {\n    constructor() {\n        super();\n        this._schema = {};\n        // We don't allow binding to events for security reasons. Allowing event bindings would almost\n        // certainly introduce bad XSS vulnerabilities. Instead, we store events in a separate schema.\n        this._eventSchema = {};\n        SCHEMA.forEach(encodedType => {\n            const type = {};\n            const events = new Set();\n            const [strType, strProperties] = encodedType.split('|');\n            const properties = strProperties.split(',');\n            const [typeNames, superName] = strType.split('^');\n            typeNames.split(',').forEach(tag => {\n                this._schema[tag.toLowerCase()] = type;\n                this._eventSchema[tag.toLowerCase()] = events;\n            });\n            const superType = superName && this._schema[superName.toLowerCase()];\n            if (superType) {\n                Object.keys(superType).forEach((prop) => {\n                    type[prop] = superType[prop];\n                });\n                for (const superEvent of this._eventSchema[superName.toLowerCase()]) {\n                    events.add(superEvent);\n                }\n            }\n            properties.forEach((property) => {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            events.add(property.substring(1));\n                            break;\n                        case '!':\n                            type[property.substring(1)] = BOOLEAN;\n                            break;\n                        case '#':\n                            type[property.substring(1)] = NUMBER;\n                            break;\n                        case '%':\n                            type[property.substring(1)] = OBJECT;\n                            break;\n                        default:\n                            type[property] = STRING;\n                    }\n                }\n            });\n        });\n    }\n    hasProperty(tagName, propName, schemaMetas) {\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return false;\n            }\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        return !!elementProperties[propName];\n    }\n    hasElement(tagName, schemaMetas) {\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return true;\n            }\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return !!this._schema[tagName.toLowerCase()];\n    }\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\n     * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\n     * string values. Only specific well known attack vectors are assigned their appropriate context.\n     */\n    securityContext(tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA()['*|' + propName];\n        return ctx ? ctx : SecurityContext.NONE;\n    }\n    getMappedPropName(propName) {\n        return _ATTR_TO_PROP[propName] || propName;\n    }\n    getDefaultComponentElementName() {\n        return 'ng-component';\n    }\n    validateProperty(name) {\n        if (name.toLowerCase().startsWith('on')) {\n            const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +\n                `please use (${name.slice(2)})=...` +\n                `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n                ` current module.`;\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    }\n    validateAttribute(name) {\n        if (name.toLowerCase().startsWith('on')) {\n            const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n                `please use (${name.slice(2)})=...`;\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    }\n    allKnownElementNames() {\n        return Object.keys(this._schema);\n    }\n    allKnownAttributesOfElement(tagName) {\n        const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        // Convert properties to attributes.\n        return Object.keys(elementProperties).map(prop => { var _a; return (_a = _PROP_TO_ATTR[prop]) !== null && _a !== void 0 ? _a : prop; });\n    }\n    allKnownEventsOfElement(tagName) {\n        var _a;\n        return Array.from((_a = this._eventSchema[tagName.toLowerCase()]) !== null && _a !== void 0 ? _a : []);\n    }\n    normalizeAnimationStyleProperty(propName) {\n        return dashCaseToCamelCase(propName);\n    }\n    normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\n        let unit = '';\n        const strVal = val.toString().trim();\n        let errorMsg = null;\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    }\n}\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all\n * tags use '*'.\n *\n * Extracted from, and should be kept in sync with\n * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations\n */\nconst TRUSTED_TYPES_SINKS = new Set([\n    // NOTE: All strings in this set *must* be lowercase!\n    // TrustedHTML\n    'iframe|srcdoc',\n    '*|innerhtml',\n    '*|outerhtml',\n    // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.\n    // TrustedScriptURL\n    'embed|src',\n    'object|codebase',\n    'object|data',\n]);\n/**\n * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types\n * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular\n * Trusted Type is required for values passed to the sink:\n * - SecurityContext.HTML corresponds to TrustedHTML\n * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL\n */\nfunction isTrustedTypesSink(tagName, propName) {\n    // Make sure comparisons are case insensitive, so that case differences between attribute and\n    // property names do not have a security impact.\n    tagName = tagName.toLowerCase();\n    propName = propName.toLowerCase();\n    return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) ||\n        TRUSTED_TYPES_SINKS.has('*|' + propName);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX$1 = '*';\nconst ANIMATE_PROP_PREFIX = 'animate-';\n/**\n * Parses bindings in templates and in the directive host area.\n */\nclass BindingParser {\n    constructor(_exprParser, _interpolationConfig, _schemaRegistry, errors) {\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this.errors = errors;\n    }\n    get interpolationConfig() {\n        return this._interpolationConfig;\n    }\n    createBoundHostProperties(properties, sourceSpan) {\n        const boundProps = [];\n        for (const propName of Object.keys(properties)) {\n            const expression = properties[propName];\n            if (typeof expression === 'string') {\n                this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], \n                // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n                // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n                // source of the host binding (which doesn't exist in the template). Regardless,\n                // neither of these values are used in Ivy but are only here to satisfy the function\n                // signature. This should likely be refactored in the future so that `sourceSpan`\n                // isn't being used inaccurately.\n                boundProps, sourceSpan);\n            }\n            else {\n                this._reportError(`Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n            }\n        }\n        return boundProps;\n    }\n    createDirectiveHostEventAsts(hostListeners, sourceSpan) {\n        const targetEvents = [];\n        for (const propName of Object.keys(hostListeners)) {\n            const expression = hostListeners[propName];\n            if (typeof expression === 'string') {\n                // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n                // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n                // rather than the source of the host binding (which doesn't exist in the template).\n                // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n                // function signature. This should likely be refactored in the future so that `sourceSpan`\n                // isn't being used inaccurately.\n                this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n            }\n            else {\n                this._reportError(`Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n            }\n        }\n        return targetEvents;\n    }\n    parseInterpolation(value, sourceSpan) {\n        const sourceInfo = sourceSpan.start.toString();\n        const absoluteOffset = sourceSpan.fullStart.offset;\n        try {\n            const ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    /**\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n     * This is used for parsing the switch expression in ICUs.\n     */\n    parseInterpolationExpression(expression, sourceSpan) {\n        const sourceInfo = sourceSpan.start.toString();\n        const absoluteOffset = sourceSpan.start.offset;\n        try {\n            const ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    /**\n     * Parses the bindings in a microsyntax expression, and converts them to\n     * `ParsedProperty` or `ParsedVariable`.\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteValueOffset start of the tplValue relative to the entire template\n     * @param targetMatchableAttrs potential attributes to match in the template\n     * @param targetProps target property bindings in the template\n     * @param targetVars target variables in the template\n     */\n    parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {\n        const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$1.length;\n        const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n        for (const binding of bindings) {\n            // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n            // binding within the microsyntax expression so it's more narrow than sourceSpan.\n            const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n            const key = binding.key.source;\n            const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n            if (binding instanceof VariableBinding) {\n                const value = binding.value ? binding.value.source : '$implicit';\n                const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n                targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n            }\n            else if (binding.value) {\n                const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n                const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n                this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n            }\n            else {\n                targetMatchableAttrs.push([key, '' /* value */]);\n                // Since this is a literal attribute with no RHS, source span should be\n                // just the key span.\n                this.parseLiteralAttr(key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */, targetMatchableAttrs, targetProps, keySpan);\n            }\n        }\n    }\n    /**\n     * Parses the bindings in a microsyntax expression, e.g.\n     * ```\n     *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n     * ```\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteKeyOffset start of the `tplKey`\n     * @param absoluteValueOffset start of the `tplValue`\n     */\n    _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n        const sourceInfo = sourceSpan.start.toString();\n        try {\n            const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.warnings.forEach((warning) => {\n                this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n            });\n            return bindingsResult.templateBindings;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return [];\n        }\n    }\n    parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n        if (isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n            }\n            if (value) {\n                this._reportError(`Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                    ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n        }\n    }\n    parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n        if (name.length === 0) {\n            this._reportError(`Property name is missing in binding`, sourceSpan);\n        }\n        let isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n            }\n        }\n        else if (isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n            }\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n    }\n    parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n        const expr = this.parseInterpolation(value, valueSpan || sourceSpan);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    }\n    _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n    }\n    _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n        if (name.length === 0) {\n            this._reportError('Animation trigger is missing', sourceSpan);\n        }\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        const ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n    }\n    _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {\n        const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n        try {\n            const ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {\n        if (boundProp.isAnimation) {\n            return new BoundElementProperty(boundProp.name, 4 /* Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n        }\n        let unit = null;\n        let bindingType = undefined;\n        let boundPropertyName = null;\n        const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        let securityContexts = undefined;\n        // Check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n                if (!skipValidation) {\n                    this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                }\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                const nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name);\n                }\n                bindingType = 1 /* Attribute */;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = 2 /* Class */;\n                securityContexts = [SecurityContext.NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = 3 /* Style */;\n                securityContexts = [SecurityContext.STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n            bindingType = 0 /* Property */;\n            if (!skipValidation) {\n                this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n            }\n        }\n        return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }\n    // TODO: keySpan should be required but was made optional to avoid changing VE parser.\n    parseEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n        if (name.length === 0) {\n            this._reportError(`Event name is missing in binding`, sourceSpan);\n        }\n        if (isAnimationLabel(name)) {\n            name = name.substr(1);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n            }\n            this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);\n        }\n        else {\n            this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\n        }\n    }\n    calcPossibleSecurityContexts(selector, propName, isAttribute) {\n        const prop = this._schemaRegistry.getMappedPropName(propName);\n        return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n    }\n    _parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {\n        const matches = splitAtPeriod(name, [name, '']);\n        const eventName = matches[0];\n        const phase = matches[1].toLowerCase();\n        const ast = this._parseAction(expression, handlerSpan);\n        targetEvents.push(new ParsedEvent(eventName, phase, 1 /* Animation */, ast, sourceSpan, handlerSpan, keySpan));\n        if (eventName.length === 0) {\n            this._reportError(`Animation event name is missing in binding`, sourceSpan);\n        }\n        if (phase) {\n            if (phase !== 'start' && phase !== 'done') {\n                this._reportError(`The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`, sourceSpan);\n            }\n        }\n        else {\n            this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);\n        }\n    }\n    _parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n        // long format: 'target: eventName'\n        const [target, eventName] = splitAtColon(name, [null, name]);\n        const ast = this._parseAction(expression, handlerSpan);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetEvents.push(new ParsedEvent(eventName, target, 0 /* Regular */, ast, sourceSpan, handlerSpan, keySpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    }\n    _parseAction(value, sourceSpan) {\n        const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n        const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\n        try {\n            const ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(`Empty expressions are not allowed`, sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n            }\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n    _reportExpressionParserErrors(errors, sourceSpan) {\n        for (const error of errors) {\n            this._reportError(error.message, sourceSpan);\n        }\n    }\n    /**\n     * @param propName the name of the property / attribute\n     * @param sourceSpan\n     * @param isAttr true when binding to an attribute\n     */\n    _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\n        const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n        }\n    }\n}\nclass PipeCollector extends RecursiveAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.pipes = new Map();\n    }\n    visitPipe(ast, context) {\n        this.pipes.set(ast.name, ast);\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n}\nfunction isAnimationLabel(name) {\n    return name[0] == '@';\n}\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    const ctxs = [];\n    CssSelector.parse(selector).forEach((selector) => {\n        const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n            .map((selector) => selector.element));\n        const possibleElementNames = elementNames.filter(elementName => !notElementNames.has(elementName));\n        ctxs.push(...possibleElementNames.map(elementName => registry.securityContext(elementName, propName, isAttribute)));\n    });\n    return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\n    // The difference of two absolute offsets provide the relative offset\n    const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n    const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n    return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Some of the code comes from WebComponents.JS\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js\nfunction isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst NG_CONTENT_SELECT_ATTR$1 = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\nfunction preparseElement(ast) {\n    let selectAttr = null;\n    let hrefAttr = null;\n    let relAttr = null;\n    let nonBindable = false;\n    let projectAs = '';\n    ast.attrs.forEach(attr => {\n        const lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR$1) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    const nodeName = ast.name.toLowerCase();\n    let type = PreparsedElementType.OTHER;\n    if (isNgContent(nodeName)) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType;\n(function (PreparsedElementType) {\n    PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n    PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n    PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n    PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n})(PreparsedElementType || (PreparsedElementType = {}));\nclass PreparsedElement {\n    constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n}\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\nconst BINDING_DELIMS = {\n    BANANA_BOX: { start: '[(', end: ')]' },\n    PROPERTY: { start: '[', end: ']' },\n    EVENT: { start: '(', end: ')' },\n};\nconst TEMPLATE_ATTR_PREFIX = '*';\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser, options) {\n    const transformer = new HtmlAstToIvyAst(bindingParser, options);\n    const ivyNodes = visitAll(transformer, htmlNodes);\n    // Errors might originate in either the binding parser or the html to ivy transformer\n    const allErrors = bindingParser.errors.concat(transformer.errors);\n    const result = {\n        nodes: ivyNodes,\n        errors: allErrors,\n        styleUrls: transformer.styleUrls,\n        styles: transformer.styles,\n        ngContentSelectors: transformer.ngContentSelectors\n    };\n    if (options.collectCommentNodes) {\n        result.commentNodes = transformer.commentNodes;\n    }\n    return result;\n}\nclass HtmlAstToIvyAst {\n    constructor(bindingParser, options) {\n        this.bindingParser = bindingParser;\n        this.options = options;\n        this.errors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngContentSelectors = [];\n        // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\n        this.commentNodes = [];\n        this.inI18nBlock = false;\n    }\n    // HTML visitor\n    visitElement(element) {\n        const isI18nRootElement = isI18nRootNode(element.i18n);\n        if (isI18nRootElement) {\n            if (this.inI18nBlock) {\n                this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n            }\n            this.inI18nBlock = true;\n        }\n        const preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLE) {\n            const contents = textContents(element);\n            if (contents !== null) {\n                this.styles.push(contents);\n            }\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            this.styleUrls.push(preparsedElement.hrefAttr);\n            return null;\n        }\n        // Whether the element is a `<ng-template>`\n        const isTemplateElement = isNgTemplate(element.name);\n        const parsedProperties = [];\n        const boundEvents = [];\n        const variables = [];\n        const references = [];\n        const attributes = [];\n        const i18nAttrsMeta = {};\n        const templateParsedProperties = [];\n        const templateVariables = [];\n        // Whether the element has any *-attribute\n        let elementHasInlineTemplate = false;\n        for (const attribute of element.attrs) {\n            let hasBinding = false;\n            const normalizedName = normalizeAttributeName(attribute.name);\n            // `*attr` defines template bindings\n            let isTemplateBinding = false;\n            if (attribute.i18n) {\n                i18nAttrsMeta[attribute.name] = attribute.i18n;\n            }\n            if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                // *-attributes\n                if (elementHasInlineTemplate) {\n                    this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);\n                }\n                isTemplateBinding = true;\n                elementHasInlineTemplate = true;\n                const templateValue = attribute.value;\n                const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n                const parsedVariables = [];\n                const absoluteValueOffset = attribute.valueSpan ?\n                    attribute.valueSpan.start.offset :\n                    // If there is no value span the attribute does not have a value, like `attr` in\n                    //`<div attr></div>`. In this case, point to one character beyond the last character of\n                    // the attribute name.\n                    attribute.sourceSpan.start.offset + attribute.name.length;\n                this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true /* isIvyAst */);\n                templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\n            }\n            else {\n                // Check for variables, events, property bindings, interpolation\n                hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n            }\n            if (!hasBinding && !isTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attributes.push(this.visitAttribute(attribute));\n            }\n        }\n        const children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);\n        let parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            // `<ng-content>`\n            if (element.children &&\n                !element.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {\n                this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\n            }\n            const selector = preparsedElement.selectAttr;\n            const attrs = element.attrs.map(attr => this.visitAttribute(attr));\n            parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);\n            this.ngContentSelectors.push(selector);\n        }\n        else if (isTemplateElement) {\n            // `<ng-template>`\n            const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [ /* no template attributes */], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        else {\n            const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Element$1(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        if (elementHasInlineTemplate) {\n            // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n            // node that contains this node.\n            // Moreover, if the node is an element, then we need to hoist its attributes to the template\n            // node for matching against content projection selectors.\n            const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n            const templateAttrs = [];\n            attrs.literal.forEach(attr => templateAttrs.push(attr));\n            attrs.bound.forEach(attr => templateAttrs.push(attr));\n            const hoistedAttrs = parsedElement instanceof Element$1 ?\n                {\n                    attributes: parsedElement.attributes,\n                    inputs: parsedElement.inputs,\n                    outputs: parsedElement.outputs,\n                } :\n                { attributes: [], inputs: [], outputs: [] };\n            // For <ng-template>s with structural directives on them, avoid passing i18n information to\n            // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n            // necessary i18n meta information will be extracted from child elements.\n            const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;\n            // TODO(pk): test for this case\n            parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [ /* no references */], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);\n        }\n        if (isI18nRootElement) {\n            this.inI18nBlock = false;\n        }\n        return parsedElement;\n    }\n    visitAttribute(attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    }\n    visitText(text) {\n        return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);\n    }\n    visitExpansion(expansion) {\n        if (!expansion.i18n) {\n            // do not generate Icu in case it was created\n            // outside of i18n block in a template\n            return null;\n        }\n        if (!isI18nRootNode(expansion.i18n)) {\n            throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${expansion.sourceSpan.toString()}. Expected a \"Message\"`);\n        }\n        const message = expansion.i18n;\n        const vars = {};\n        const placeholders = {};\n        // extract VARs from ICUs - we process them separately while\n        // assembling resulting message via goog.getMsg function, since\n        // we need to pass them to top-level goog.getMsg call\n        Object.keys(message.placeholders).forEach(key => {\n            const value = message.placeholders[key];\n            if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n                // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\n                // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\n                // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\n                // converted into `_` symbols while normalizing placeholder names, which might lead to\n                // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\n                const formattedKey = key.trim();\n                const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n                vars[formattedKey] = new BoundText(ast, value.sourceSpan);\n            }\n            else {\n                placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan);\n            }\n        });\n        return new Icu$1(vars, placeholders, expansion.sourceSpan, message);\n    }\n    visitExpansionCase(expansionCase) {\n        return null;\n    }\n    visitComment(comment) {\n        if (this.options.collectCommentNodes) {\n            this.commentNodes.push(new Comment$1(comment.value || '', comment.sourceSpan));\n        }\n        return null;\n    }\n    // convert view engine `ParsedProperty` to a format suitable for IVY\n    extractAttributes(elementName, properties, i18nPropsMeta) {\n        const bound = [];\n        const literal = [];\n        properties.forEach(prop => {\n            const i18n = i18nPropsMeta[prop.name];\n            if (prop.isLiteral) {\n                literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));\n            }\n            else {\n                // Note that validation is skipped and property mapping is disabled\n                // due to the fact that we need to make sure a given prop is not an\n                // input of a directive and directive matching happens at runtime.\n                const bep = this.bindingParser.createBoundElementProperty(elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);\n                bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n            }\n        });\n        return { bound, literal };\n    }\n    parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n        const name = normalizeAttributeName(attribute.name);\n        const value = attribute.value;\n        const srcSpan = attribute.sourceSpan;\n        const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n        function createKeySpan(srcSpan, prefix, identifier) {\n            // We need to adjust the start location for the keySpan to account for the removed 'data-'\n            // prefix from `normalizeAttributeName`.\n            const normalizationAdjustment = attribute.name.length - name.length;\n            const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n            const keySpanEnd = keySpanStart.moveBy(identifier.length);\n            return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n        }\n        const bindParts = name.match(BIND_NAME_REGEXP);\n        if (bindParts) {\n            if (bindParts[KW_BIND_IDX] != null) {\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    const identifier = bindParts[IDENT_KW_IDX];\n                    const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n                    this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n                }\n                else {\n                    this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n                this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                const events = [];\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n                this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n                addEvents(events, boundEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                const keySpan = createKeySpan(srcSpan, '', name);\n                this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n            }\n            return true;\n        }\n        // We didn't see a kw-prefixed property binding, but we have not yet checked\n        // for the []/()/[()] syntax.\n        let delims = null;\n        if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n            delims = BINDING_DELIMS.BANANA_BOX;\n        }\n        else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n            delims = BINDING_DELIMS.PROPERTY;\n        }\n        else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n            delims = BINDING_DELIMS.EVENT;\n        }\n        if (delims !== null &&\n            // NOTE: older versions of the parser would match a start/end delimited\n            // binding iff the property name was terminated by the ending delimiter\n            // and the identifier in the binding was non-empty.\n            // TODO(ayazhafiz): update this to handle malformed bindings.\n            name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n            const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n            const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n            if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);\n            }\n            else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n            }\n            else {\n                const events = [];\n                this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n                addEvents(events, boundEvents);\n            }\n            return true;\n        }\n        // No explicit binding found.\n        const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n        const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n        return hasBinding;\n    }\n    _visitTextWithInterpolation(value, sourceSpan, i18n) {\n        const valueNoNgsp = replaceNgsp(value);\n        const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);\n        return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);\n    }\n    parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this.reportError(`Variable does not have a name`, sourceSpan);\n        }\n        variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n    }\n    parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this.reportError(`Reference does not have a name`, sourceSpan);\n        }\n        else if (references.some(reference => reference.name === identifier)) {\n            this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n        }\n        references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n    }\n    parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {\n        const events = [];\n        this.bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n        addEvents(events, boundEvents);\n    }\n    reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n}\nclass NonBindableVisitor {\n    visitElement(ast) {\n        const preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        const children = visitAll(this, ast.children, null);\n        return new Element$1(ast.name, visitAll(this, ast.attrs), \n        /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);\n    }\n    visitComment(comment) {\n        return null;\n    }\n    visitAttribute(attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    }\n    visitText(text) {\n        return new Text$3(text.value, text.sourceSpan);\n    }\n    visitExpansion(expansion) {\n        return null;\n    }\n    visitExpansionCase(expansionCase) {\n        return null;\n    }\n}\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\nfunction normalizeAttributeName(attrName) {\n    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\nfunction addEvents(events, boundEvents) {\n    boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));\n}\nfunction isEmptyTextNode(node) {\n    return node instanceof Text && node.value.trim().length == 0;\n}\nfunction isCommentNode(node) {\n    return node instanceof Comment;\n}\nfunction textContents(node) {\n    if (node.children.length !== 1 || !(node.children[0] instanceof Text)) {\n        return null;\n    }\n    else {\n        return node.children[0].value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TagType;\n(function (TagType) {\n    TagType[TagType[\"ELEMENT\"] = 0] = \"ELEMENT\";\n    TagType[TagType[\"TEMPLATE\"] = 1] = \"TEMPLATE\";\n})(TagType || (TagType = {}));\n/**\n * Generates an object that is used as a shared state between parent and all child contexts.\n */\nfunction setupRegistry() {\n    return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };\n}\n/**\n * I18nContext is a helper class which keeps track of all i18n-related aspects\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n *\n * When we enter a nested template, the top-level context is being passed down\n * to the nested component, which uses this context to generate a child instance\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\n * with the parent context.\n *\n * @param index Instruction index of i18nStart, which initiates this context\n * @param ref Reference to a translation const that represents the content if thus context\n * @param level Nestng level defined for child contexts\n * @param templateIndex Instruction index of a template which this context belongs to\n * @param meta Meta information (id, meaning, description, etc) associated with this context\n */\nclass I18nContext {\n    constructor(index, ref, level = 0, templateIndex = null, meta, registry) {\n        this.index = index;\n        this.ref = ref;\n        this.level = level;\n        this.templateIndex = templateIndex;\n        this.meta = meta;\n        this.registry = registry;\n        this.bindings = new Set();\n        this.placeholders = new Map();\n        this.isEmitted = false;\n        this._unresolvedCtxCount = 0;\n        this._registry = registry || setupRegistry();\n        this.id = this._registry.getUniqueId();\n    }\n    appendTag(type, node, index, closed) {\n        if (node.isVoid && closed) {\n            return; // ignore \"close\" for void tags\n        }\n        const ph = node.isVoid || !closed ? node.startName : node.closeName;\n        const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };\n        updatePlaceholderMap(this.placeholders, ph, content);\n    }\n    get icus() {\n        return this._registry.icus;\n    }\n    get isRoot() {\n        return this.level === 0;\n    }\n    get isResolved() {\n        return this._unresolvedCtxCount === 0;\n    }\n    getSerializedPlaceholders() {\n        const result = new Map();\n        this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));\n        return result;\n    }\n    // public API to accumulate i18n-related content\n    appendBinding(binding) {\n        this.bindings.add(binding);\n    }\n    appendIcu(name, ref) {\n        updatePlaceholderMap(this._registry.icus, name, ref);\n    }\n    appendBoundText(node) {\n        const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n        phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));\n    }\n    appendTemplate(node, index) {\n        // add open and close tags at the same time,\n        // since we process nested templates separately\n        this.appendTag(TagType.TEMPLATE, node, index, false);\n        this.appendTag(TagType.TEMPLATE, node, index, true);\n        this._unresolvedCtxCount++;\n    }\n    appendElement(node, index, closed) {\n        this.appendTag(TagType.ELEMENT, node, index, closed);\n    }\n    appendProjection(node, index) {\n        // Add open and close tags at the same time, since `<ng-content>` has no content,\n        // so when we come across `<ng-content>` we can register both open and close tags.\n        // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and\n        // regular element tag placeholders, so we generate element placeholders for both types.\n        this.appendTag(TagType.ELEMENT, node, index, false);\n        this.appendTag(TagType.ELEMENT, node, index, true);\n    }\n    /**\n     * Generates an instance of a child context based on the root one,\n     * when we enter a nested template within I18n section.\n     *\n     * @param index Instruction index of corresponding i18nStart, which initiates this context\n     * @param templateIndex Instruction index of a template which this context belongs to\n     * @param meta Meta information (id, meaning, description, etc) associated with this context\n     *\n     * @returns I18nContext instance\n     */\n    forkChildContext(index, templateIndex, meta) {\n        return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n    }\n    /**\n     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n     *\n     * @param context Child I18nContext instance to be reconciled with parent context.\n     */\n    reconcileChildContext(context) {\n        // set the right context id for open and close\n        // template tags, so we can use it as sub-block ids\n        ['start', 'close'].forEach((op) => {\n            const key = context.meta[`${op}Name`];\n            const phs = this.placeholders.get(key) || [];\n            const tag = phs.find(findTemplateFn(this.id, context.templateIndex));\n            if (tag) {\n                tag.ctx = context.id;\n            }\n        });\n        // reconcile placeholders\n        const childPhs = context.placeholders;\n        childPhs.forEach((values, key) => {\n            const phs = this.placeholders.get(key);\n            if (!phs) {\n                this.placeholders.set(key, values);\n                return;\n            }\n            // try to find matching template...\n            const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n            if (tmplIdx >= 0) {\n                // ... if found - replace it with nested template content\n                const isCloseTag = key.startsWith('CLOSE');\n                const isTemplateTag = key.endsWith('NG-TEMPLATE');\n                if (isTemplateTag) {\n                    // current template's content is placed before or after\n                    // parent template tag, depending on the open/close atrribute\n                    phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);\n                }\n                else {\n                    const idx = isCloseTag ? values.length - 1 : 0;\n                    values[idx].tmpl = phs[tmplIdx];\n                    phs.splice(tmplIdx, 1, ...values);\n                }\n            }\n            else {\n                // ... otherwise just append content to placeholder value\n                phs.push(...values);\n            }\n            this.placeholders.set(key, phs);\n        });\n        this._unresolvedCtxCount--;\n    }\n}\n//\n// Helper methods\n//\nfunction wrap(symbol, index, contextId, closed) {\n    const state = closed ? '/' : '';\n    return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);\n}\nfunction wrapTag(symbol, { index, ctx, isVoid }, closed) {\n    return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :\n        wrap(symbol, index, ctx, closed);\n}\nfunction findTemplateFn(ctx, templateIndex) {\n    return (token) => typeof token === 'object' && token.type === TagType.TEMPLATE &&\n        token.index === templateIndex && token.ctx === ctx;\n}\nfunction serializePlaceholderValue(value) {\n    const element = (data, closed) => wrapTag('#', data, closed);\n    const template = (data, closed) => wrapTag('*', data, closed);\n    const projection = (data, closed) => wrapTag('!', data, closed);\n    switch (value.type) {\n        case TagType.ELEMENT:\n            // close element tag\n            if (value.closed) {\n                return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n            }\n            // open element tag that also initiates a template\n            if (value.tmpl) {\n                return template(value.tmpl) + element(value) +\n                    (value.isVoid ? template(value.tmpl, true) : '');\n            }\n            return element(value);\n        case TagType.TEMPLATE:\n            return template(value, value.closed);\n        default:\n            return value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass IcuSerializerVisitor {\n    visitText(text) {\n        return text.value;\n    }\n    visitContainer(container) {\n        return container.children.map(child => child.visit(this)).join('');\n    }\n    visitIcu(icu) {\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n        return result;\n    }\n    visitTagPlaceholder(ph) {\n        return ph.isVoid ?\n            this.formatPh(ph.startName) :\n            `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n    }\n    visitPlaceholder(ph) {\n        return this.formatPh(ph.name);\n    }\n    visitIcuPlaceholder(ph, context) {\n        return this.formatPh(ph.name);\n    }\n    formatPh(value) {\n        return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;\n    }\n}\nconst serializer = new IcuSerializerVisitor();\nfunction serializeIcuNode(icu) {\n    return icu.visit(serializer);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n */\nclass PlaceholderRegistry {\n    constructor() {\n        // Count the occurrence of the base name top generate a unique name\n        this._placeHolderNameCounts = {};\n        // Maps signature to placeholder names\n        this._signatureToName = {};\n    }\n    getStartTagPlaceholderName(tag, attrs, isVoid) {\n        const signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const upperTag = tag.toUpperCase();\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n        const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n        this._signatureToName[signature] = name;\n        return name;\n    }\n    getCloseTagPlaceholderName(tag) {\n        const signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const upperTag = tag.toUpperCase();\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n        const name = this._generateUniqueName(`CLOSE_${baseName}`);\n        this._signatureToName[signature] = name;\n        return name;\n    }\n    getPlaceholderName(name, content) {\n        const upperName = name.toUpperCase();\n        const signature = `PH: ${upperName}=${content}`;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    }\n    getUniquePlaceholder(name) {\n        return this._generateUniqueName(name.toUpperCase());\n    }\n    // Generate a hash for a tag - does not take attribute order into account\n    _hashTag(tag, attrs, isVoid) {\n        const start = `<${tag}`;\n        const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\n        const end = isVoid ? '/>' : `></${tag}>`;\n        return start + strAttrs + end;\n    }\n    _hashClosingTag(tag) {\n        return this._hashTag(`/${tag}`, {}, false);\n    }\n    _generateUniqueName(base) {\n        const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        const id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return `${base}_${id}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _expParser = new Parser$1(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nfunction createI18nMessageFactory(interpolationConfig) {\n    const visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\nfunction noopVisitNodeFn(_html, i18n) {\n    return i18n;\n}\nclass _I18nVisitor {\n    constructor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {\n        const context = {\n            isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\n            icuDepth: 0,\n            placeholderRegistry: new PlaceholderRegistry(),\n            placeholderToContent: {},\n            placeholderToMessage: {},\n            visitNodeFn: visitNodeFn || noopVisitNodeFn,\n        };\n        const i18nodes = visitAll(this, nodes, context);\n        return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n    }\n    visitElement(el, context) {\n        var _a;\n        const children = visitAll(this, el.children, context);\n        const attrs = {};\n        el.attrs.forEach(attr => {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        const isVoid = getHtmlTagDefinition(el.name).isVoid;\n        const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        context.placeholderToContent[startPhName] = {\n            text: el.startSourceSpan.toString(),\n            sourceSpan: el.startSourceSpan,\n        };\n        let closePhName = '';\n        if (!isVoid) {\n            closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            context.placeholderToContent[closePhName] = {\n                text: `</${el.name}>`,\n                sourceSpan: (_a = el.endSourceSpan) !== null && _a !== void 0 ? _a : el.sourceSpan,\n            };\n        }\n        const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        return context.visitNodeFn(el, node);\n    }\n    visitAttribute(attribute, context) {\n        const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ?\n            new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) :\n            this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\n        return context.visitNodeFn(attribute, node);\n    }\n    visitText(text, context) {\n        const node = text.tokens.length === 1 ?\n            new Text$2(text.value, text.sourceSpan) :\n            this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n        return context.visitNodeFn(text, node);\n    }\n    visitComment(comment, context) {\n        return null;\n    }\n    visitExpansion(icu, context) {\n        context.icuDepth++;\n        const i18nIcuCases = {};\n        const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach((caze) => {\n            i18nIcuCases[caze.value] = new Container(caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);\n        });\n        context.icuDepth--;\n        if (context.isIcu || context.icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n            i18nIcu.expressionPlaceholder = expPh;\n            context.placeholderToContent[expPh] = {\n                text: icu.switchValue,\n                sourceSpan: icu.switchValueSourceSpan,\n            };\n            return context.visitNodeFn(icu, i18nIcu);\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n        const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n        return context.visitNodeFn(icu, node);\n    }\n    visitExpansionCase(_icuCase, _context) {\n        throw new Error('Unreachable code');\n    }\n    /**\n     * Convert, text and interpolated tokens up into text and placeholder pieces.\n     *\n     * @param tokens The text and interpolated tokens.\n     * @param sourceSpan The span of the whole of the `text` string.\n     * @param context The current context of the visitor, used to compute and store placeholders.\n     * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n     */\n    _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {\n        // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n        const nodes = [];\n        // We will only create a container if there are actually interpolations,\n        // so this flag tracks that.\n        let hasInterpolation = false;\n        for (const token of tokens) {\n            switch (token.type) {\n                case 8 /* INTERPOLATION */:\n                case 17 /* ATTR_VALUE_INTERPOLATION */:\n                    hasInterpolation = true;\n                    const expression = token.parts[1];\n                    const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n                    const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n                    context.placeholderToContent[phName] = {\n                        text: token.parts.join(''),\n                        sourceSpan: token.sourceSpan\n                    };\n                    nodes.push(new Placeholder(expression, phName, token.sourceSpan));\n                    break;\n                default:\n                    if (token.parts[0].length > 0) {\n                        // This token is text or an encoded entity.\n                        // If it is following on from a previous text node then merge it into that node\n                        // Otherwise, if it is following an interpolation, then add a new node.\n                        const previous = nodes[nodes.length - 1];\n                        if (previous instanceof Text$2) {\n                            previous.value += token.parts[0];\n                            previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);\n                        }\n                        else {\n                            nodes.push(new Text$2(token.parts[0], token.sourceSpan));\n                        }\n                    }\n                    break;\n            }\n        }\n        if (hasInterpolation) {\n            // Whitespace removal may have invalidated the interpolation source-spans.\n            reusePreviousSourceSpans(nodes, previousI18n);\n            return new Container(nodes, sourceSpan);\n        }\n        else {\n            return nodes[0];\n        }\n    }\n}\n/**\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n *\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n * reuse the source-span stored from a previous pass before the whitespace was removed.\n *\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n */\nfunction reusePreviousSourceSpans(nodes, previousI18n) {\n    if (previousI18n instanceof Message) {\n        // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n        // metadata. The `Message` should consist only of a single `Container` that contains the\n        // parts (`Text` and `Placeholder`) to process.\n        assertSingleContainerMessage(previousI18n);\n        previousI18n = previousI18n.nodes[0];\n    }\n    if (previousI18n instanceof Container) {\n        // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n        // after whitespace has been removed from the AST nodes.\n        assertEquivalentNodes(previousI18n.children, nodes);\n        // Reuse the source-spans from the first pass.\n        for (let i = 0; i < nodes.length; i++) {\n            nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n        }\n    }\n}\n/**\n * Asserts that the `message` contains exactly one `Container` node.\n */\nfunction assertSingleContainerMessage(message) {\n    const nodes = message.nodes;\n    if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {\n        throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n    }\n}\n/**\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n * corresponding elements have the same node type.\n */\nfunction assertEquivalentNodes(previousNodes, nodes) {\n    if (previousNodes.length !== nodes.length) {\n        throw new Error('The number of i18n message children changed between first and second pass.');\n    }\n    if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n        throw new Error('The types of the i18n message children changed between first and second pass.');\n    }\n}\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\nfunction extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An i18n error.\n */\nclass I18nError extends ParseError {\n    constructor(span, msg) {\n        super(span, msg);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst setI18nRefs = (htmlNode, i18nNode) => {\n    if (htmlNode instanceof NodeWithI18n) {\n        if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {\n            // This html node represents an ICU but this is a second processing pass, and the legacy id\n            // was computed in the previous pass and stored in the `i18n` property as a message.\n            // We are about to wipe out that property so capture the previous message to be reused when\n            // generating the message for this ICU later. See `_generateI18nMessage()`.\n            i18nNode.previousMessage = htmlNode.i18n;\n        }\n        htmlNode.i18n = i18nNode;\n    }\n    return i18nNode;\n};\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\nclass I18nMetaVisitor {\n    constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {\n        this.interpolationConfig = interpolationConfig;\n        this.keepI18nAttrs = keepI18nAttrs;\n        this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n        // whether visited nodes contain i18n information\n        this.hasI18nMeta = false;\n        this._errors = [];\n        // i18n message generation factory\n        this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\n    }\n    _generateI18nMessage(nodes, meta = '', visitNodeFn) {\n        const { meaning, description, customId } = this._parseMetadata(meta);\n        const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n        this._setMessageId(message, meta);\n        this._setLegacyIds(message, meta);\n        return message;\n    }\n    visitAllWithErrors(nodes) {\n        const result = nodes.map(node => node.visit(this, null));\n        return new ParseTreeResult(result, this._errors);\n    }\n    visitElement(element) {\n        let message = undefined;\n        if (hasI18nAttrs(element)) {\n            this.hasI18nMeta = true;\n            const attrs = [];\n            const attrsMeta = {};\n            for (const attr of element.attrs) {\n                if (attr.name === I18N_ATTR) {\n                    // root 'i18n' node attribute\n                    const i18n = element.i18n || attr.value;\n                    message = this._generateI18nMessage(element.children, i18n, setI18nRefs);\n                    if (message.nodes.length === 0) {\n                        // Ignore the message if it is empty.\n                        message = undefined;\n                    }\n                    // Store the message on the element\n                    element.i18n = message;\n                }\n                else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n                    // 'i18n-*' attributes\n                    const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n                    if (isTrustedTypesSink(element.name, name)) {\n                        this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);\n                    }\n                    else {\n                        attrsMeta[name] = attr.value;\n                    }\n                }\n                else {\n                    // non-i18n attributes\n                    attrs.push(attr);\n                }\n            }\n            // set i18n meta for attributes\n            if (Object.keys(attrsMeta).length) {\n                for (const attr of attrs) {\n                    const meta = attrsMeta[attr.name];\n                    // do not create translation for empty attributes\n                    if (meta !== undefined && attr.value) {\n                        attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n                    }\n                }\n            }\n            if (!this.keepI18nAttrs) {\n                // update element's attributes,\n                // keeping only non-i18n related ones\n                element.attrs = attrs;\n            }\n        }\n        visitAll(this, element.children, message);\n        return element;\n    }\n    visitExpansion(expansion, currentMessage) {\n        let message;\n        const meta = expansion.i18n;\n        this.hasI18nMeta = true;\n        if (meta instanceof IcuPlaceholder) {\n            // set ICU placeholder name (e.g. \"ICU_1\"),\n            // generated while processing root element contents,\n            // so we can reference it when we output translation\n            const name = meta.name;\n            message = this._generateI18nMessage([expansion], meta);\n            const icu = icuFromI18nMessage(message);\n            icu.name = name;\n            if (currentMessage !== null) {\n                // Also update the placeholderToMessage map with this new message\n                currentMessage.placeholderToMessage[name] = message;\n            }\n        }\n        else {\n            // ICU is a top level message, try to use metadata from container element if provided via\n            // `context` argument. Note: context may not be available for standalone ICUs (without\n            // wrapping element), so fallback to ICU metadata in this case.\n            message = this._generateI18nMessage([expansion], currentMessage || meta);\n        }\n        expansion.i18n = message;\n        return expansion;\n    }\n    visitText(text) {\n        return text;\n    }\n    visitAttribute(attribute) {\n        return attribute;\n    }\n    visitComment(comment) {\n        return comment;\n    }\n    visitExpansionCase(expansionCase) {\n        return expansionCase;\n    }\n    /**\n     * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n     * `Message`.\n     *\n     * There are three possibilities for the `meta` variable\n     * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n     * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n     * 4) other: ignore this and just process the message metadata as normal\n     *\n     * @param meta the bucket that holds information about the message\n     * @returns the parsed metadata.\n     */\n    _parseMetadata(meta) {\n        return typeof meta === 'string' ? parseI18nMeta(meta) :\n            meta instanceof Message ? meta : {};\n    }\n    /**\n     * Generate (or restore) message id if not specified already.\n     */\n    _setMessageId(message, meta) {\n        if (!message.id) {\n            message.id = meta instanceof Message && meta.id || decimalDigest(message);\n        }\n    }\n    /**\n     * Update the `message` with a `legacyId` if necessary.\n     *\n     * @param message the message whose legacy id should be set\n     * @param meta information about the message being processed\n     */\n    _setLegacyIds(message, meta) {\n        if (this.enableI18nLegacyMessageIdFormat) {\n            message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n        }\n        else if (typeof meta !== 'string') {\n            // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n            // `packages/compiler/src/render3/view/template.ts`).\n            // In that case we want to reuse the legacy message generated in the 1st pass (see\n            // `setI18nRefs()`).\n            const previousMessage = meta instanceof Message ?\n                meta :\n                meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;\n            message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n        }\n    }\n    _reportError(node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    }\n}\n/** I18n separators for metadata **/\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\nfunction parseI18nMeta(meta = '') {\n    let customId;\n    let meaning;\n    let description;\n    meta = meta.trim();\n    if (meta) {\n        const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n        const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n        let meaningAndDesc;\n        [meaningAndDesc, customId] =\n            (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n        [meaning, description] = (descIndex > -1) ?\n            [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n            ['', meaningAndDesc];\n    }\n    return { customId, meaning, description };\n}\n// Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nfunction i18nMetaToJSDoc(meta) {\n    const tags = [];\n    if (meta.description) {\n        tags.push({ tagName: \"desc\" /* Desc */, text: meta.description });\n    }\n    if (meta.meaning) {\n        tags.push({ tagName: \"meaning\" /* Meaning */, text: meta.meaning });\n    }\n    return tags.length == 0 ? null : jsDocComment(tags);\n}\n\n/** Closure uses `goog.getMsg(message)` to lookup translations */\nconst GOOG_GET_MSG = 'goog.getMsg';\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, params) {\n    const messageString = serializeI18nMessageForGetMsg(message);\n    const args = [literal(messageString)];\n    if (Object.keys(params).length) {\n        args.push(mapLiteral(params, true));\n    }\n    // /**\n    //  * @desc description of message\n    //  * @meaning meaning of message\n    //  */\n    // const MSG_... = goog.getMsg(..);\n    // I18N_X = MSG_...;\n    const googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();\n    const metaComment = i18nMetaToJSDoc(message);\n    if (metaComment !== null) {\n        googGetMsgStmt.addLeadingComment(metaComment);\n    }\n    const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));\n    return [googGetMsgStmt, i18nAssignmentStmt];\n}\n/**\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\n */\nclass GetMsgSerializerVisitor {\n    formatPh(value) {\n        return `{$${formatI18nPlaceholderName(value)}}`;\n    }\n    visitText(text) {\n        return text.value;\n    }\n    visitContainer(container) {\n        return container.children.map(child => child.visit(this)).join('');\n    }\n    visitIcu(icu) {\n        return serializeIcuNode(icu);\n    }\n    visitTagPlaceholder(ph) {\n        return ph.isVoid ?\n            this.formatPh(ph.startName) :\n            `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n    }\n    visitPlaceholder(ph) {\n        return this.formatPh(ph.name);\n    }\n    visitIcuPlaceholder(ph, context) {\n        return this.formatPh(ph.name);\n    }\n}\nconst serializerVisitor = new GetMsgSerializerVisitor();\nfunction serializeI18nMessageForGetMsg(message) {\n    return message.nodes.map(node => node.visit(serializerVisitor, null)).join('');\n}\n\nfunction createLocalizeStatements(variable, message, params) {\n    const { messageParts, placeHolders } = serializeI18nMessageForLocalize(message);\n    const sourceSpan = getSourceSpan(message);\n    const expressions = placeHolders.map(ph => params[ph.text]);\n    const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n    const variableInitialization = variable.set(localizedString$1);\n    return [new ExpressionStatement(variableInitialization)];\n}\n/**\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n *\n * The result can be used for generating the `$localize` tagged template literals.\n */\nclass LocalizeSerializerVisitor {\n    constructor(placeholderToMessage, pieces) {\n        this.placeholderToMessage = placeholderToMessage;\n        this.pieces = pieces;\n    }\n    visitText(text) {\n        if (this.pieces[this.pieces.length - 1] instanceof LiteralPiece) {\n            // Two literal pieces in a row means that there was some comment node in-between.\n            this.pieces[this.pieces.length - 1].text += text.value;\n        }\n        else {\n            const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);\n            this.pieces.push(new LiteralPiece(text.value, sourceSpan));\n        }\n    }\n    visitContainer(container) {\n        container.children.forEach(child => child.visit(this));\n    }\n    visitIcu(icu) {\n        this.pieces.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n    }\n    visitTagPlaceholder(ph) {\n        var _a, _b;\n        this.pieces.push(this.createPlaceholderPiece(ph.startName, (_a = ph.startSourceSpan) !== null && _a !== void 0 ? _a : ph.sourceSpan));\n        if (!ph.isVoid) {\n            ph.children.forEach(child => child.visit(this));\n            this.pieces.push(this.createPlaceholderPiece(ph.closeName, (_b = ph.endSourceSpan) !== null && _b !== void 0 ? _b : ph.sourceSpan));\n        }\n    }\n    visitPlaceholder(ph) {\n        this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n    }\n    visitIcuPlaceholder(ph) {\n        this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));\n    }\n    createPlaceholderPiece(name, sourceSpan, associatedMessage) {\n        return new PlaceholderPiece(formatI18nPlaceholderName(name, /* useCamelCase */ false), sourceSpan, associatedMessage);\n    }\n}\n/**\n * Serialize an i18n message into two arrays: messageParts and placeholders.\n *\n * These arrays will be used to generate `$localize` tagged template literals.\n *\n * @param message The message to be serialized.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction serializeI18nMessageForLocalize(message) {\n    const pieces = [];\n    const serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);\n    message.nodes.forEach(node => node.visit(serializerVisitor));\n    return processMessagePieces(pieces);\n}\nfunction getSourceSpan(message) {\n    const startNode = message.nodes[0];\n    const endNode = message.nodes[message.nodes.length - 1];\n    return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);\n}\n/**\n * Convert the list of serialized MessagePieces into two arrays.\n *\n * One contains the literal string pieces and the other the placeholders that will be replaced by\n * expressions when rendering `$localize` tagged template literals.\n *\n * @param pieces The pieces to process.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction processMessagePieces(pieces) {\n    const messageParts = [];\n    const placeHolders = [];\n    if (pieces[0] instanceof PlaceholderPiece) {\n        // The first piece was a placeholder so we need to add an initial empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n    }\n    for (let i = 0; i < pieces.length; i++) {\n        const part = pieces[i];\n        if (part instanceof LiteralPiece) {\n            messageParts.push(part);\n        }\n        else {\n            placeHolders.push(part);\n            if (pieces[i - 1] instanceof PlaceholderPiece) {\n                // There were two placeholders in a row, so we need to add an empty message part.\n                messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n            }\n        }\n    }\n    if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\n        // The last piece was a placeholder so we need to add a final empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n    }\n    return { messageParts, placeHolders };\n}\nfunction createEmptyMessagePart(location) {\n    return new LiteralPiece('', new ParseSourceSpan(location, location));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Selector attribute name of `<ng-content>`\nconst NG_CONTENT_SELECT_ATTR = 'select';\n// Attribute name of `ngProjectAs`.\nconst NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n// Global symbols available only inside event bindings.\nconst EVENT_BINDING_SCOPE_GLOBALS = new Set(['$event']);\n// List of supported global targets for event listeners\nconst GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers$1.resolveWindow], ['document', Identifiers$1.resolveDocument], ['body', Identifiers$1.resolveBody]]);\nconst LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n//  if (rf & flags) { .. }\nfunction renderFlagCheckIfStmt(flags, statements) {\n    return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);\n}\nfunction prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {\n    const { type, name, target, phase, handler } = eventAst;\n    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n        throw new Error(`Unexpected global target '${target}' defined for '${name}' event.\n        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);\n    }\n    const eventArgumentName = '$event';\n    const implicitReceiverAccesses = new Set();\n    const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\n        variable(CONTEXT_NAME) :\n        scope.getOrCreateSharedContextVar(0);\n    const bindingStatements = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', () => error('Unexpected interpolation'), eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);\n    const statements = [];\n    if (scope) {\n        // `variableDeclarations` needs to run first, because\n        // `restoreViewStatement` depends on the result.\n        statements.push(...scope.variableDeclarations());\n        statements.unshift(...scope.restoreViewStatement());\n    }\n    statements.push(...bindingStatements);\n    const eventName = type === 1 /* Animation */ ? prepareSyntheticListenerName(name, phase) : name;\n    const fnName = handlerName && sanitizeIdentifier(handlerName);\n    const fnArgs = [];\n    if (implicitReceiverAccesses.has(eventArgumentName)) {\n        fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));\n    }\n    const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);\n    const params = [literal(eventName), handlerFn];\n    if (target) {\n        params.push(literal(false), // `useCapture` flag, defaults to `false`\n        importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));\n    }\n    return params;\n}\nfunction createComponentDefConsts() {\n    return {\n        prepareStatements: [],\n        constExpressions: [],\n        i18nVarRefsCache: new Map(),\n    };\n}\nclass TemplateDefinitionBuilder {\n    constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = createComponentDefConsts()) {\n        this.constantPool = constantPool;\n        this.level = level;\n        this.contextName = contextName;\n        this.i18nContext = i18nContext;\n        this.templateIndex = templateIndex;\n        this.templateName = templateName;\n        this._namespace = _namespace;\n        this.i18nUseExternalIds = i18nUseExternalIds;\n        this._constants = _constants;\n        this._dataIndex = 0;\n        this._bindingContext = 0;\n        this._prefixCode = [];\n        /**\n         * List of callbacks to generate creation mode instructions. We store them here as we process\n         * the template so bindings in listeners are resolved only once all nodes have been visited.\n         * This ensures all local refs and context variables are available for matching.\n         */\n        this._creationCodeFns = [];\n        /**\n         * List of callbacks to generate update mode instructions. We store them here as we process\n         * the template so bindings are resolved only once all nodes have been visited. This ensures\n         * all local refs and context variables are available for matching.\n         */\n        this._updateCodeFns = [];\n        /** Index of the currently-selected node. */\n        this._currentIndex = 0;\n        /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n        this._tempVariables = [];\n        /**\n         * List of callbacks to build nested templates. Nested templates must not be visited until\n         * after the parent template has finished visiting all of its nodes. This ensures that all\n         * local ref bindings in nested templates are able to find local ref values if the refs\n         * are defined after the template declaration.\n         */\n        this._nestedTemplateFns = [];\n        // i18n context local to this template\n        this.i18n = null;\n        // Number of slots to reserve for pureFunctions\n        this._pureFunctionSlots = 0;\n        // Number of binding slots\n        this._bindingSlots = 0;\n        // Projection slots found in the template. Projection slots can distribute projected\n        // nodes based on a selector, or can just use the wildcard selector to match\n        // all nodes which aren't matching any selector.\n        this._ngContentReservedSlots = [];\n        // Number of non-default selectors found in all parent templates of this template. We need to\n        // track it to properly adjust projection slot index in the `projection` instruction.\n        this._ngContentSelectorsOffset = 0;\n        // Expression that should be used as implicit receiver when converting template\n        // expressions to output AST.\n        this._implicitReceiverExpr = null;\n        // These should be handled in the template or element directly.\n        this.visitReference = invalid;\n        this.visitVariable = invalid;\n        this.visitTextAttribute = invalid;\n        this.visitBoundAttribute = invalid;\n        this.visitBoundEvent = invalid;\n        this._bindingScope = parentBindingScope.nestedScope(level);\n        // Turn the relative context file path into an identifier by replacing non-alphanumeric\n        // characters with underscores.\n        this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n        this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {\n            this._bindingScope.set(this.level, localName, value);\n            this.creationInstruction(null, Identifiers$1.pipe, [literal(slot), literal(name)]);\n        });\n    }\n    buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {\n        this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n        if (this._namespace !== Identifiers$1.namespaceHTML) {\n            this.creationInstruction(null, this._namespace);\n        }\n        // Create variable bindings\n        variables.forEach(v => this.registerContextVariables(v));\n        // Initiate i18n context in case:\n        // - this template has parent i18n context\n        // - or the template has i18n meta associated with it,\n        //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n        const initI18nContext = this.i18nContext ||\n            (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&\n                !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));\n        const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n        if (initI18nContext) {\n            this.i18nStart(null, i18n, selfClosingI18nInstruction);\n        }\n        // This is the initial pass through the nodes of this template. In this pass, we\n        // queue all creation mode and update mode instructions for generation in the second\n        // pass. It's necessary to separate the passes to ensure local refs are defined before\n        // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n        visitAll$1(this, nodes);\n        // Add total binding count to pure function count so pure function instructions are\n        // generated with the correct slot offset when update instructions are processed.\n        this._pureFunctionSlots += this._bindingSlots;\n        // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n        // `pipeBind` update instructions), so we have to update the slot offsets manually\n        // to account for bindings.\n        this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\n        // Nested templates must be processed before creation instructions so template()\n        // instructions can be generated with the correct internal const count.\n        this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());\n        // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n        // The `projectionDef` instruction is only emitted for the component template and\n        // is skipped for nested templates (<ng-template> tags).\n        if (this.level === 0 && this._ngContentReservedSlots.length) {\n            const parameters = [];\n            // By default the `projectionDef` instructions creates one slot for the wildcard\n            // selector if no parameters are passed. Therefore we only want to allocate a new\n            // array for the projection slots if the default projection slot is not sufficient.\n            if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n                const r3ReservedSlots = this._ngContentReservedSlots.map(s => s !== '*' ? parseSelectorToR3Selector(s) : s);\n                parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n            }\n            // Since we accumulate ngContent selectors while processing template elements,\n            // we *prepend* `projectionDef` to creation instructions block, to put it before\n            // any `projection` instructions\n            this.creationInstruction(null, Identifiers$1.projectionDef, parameters, /* prepend */ true);\n        }\n        if (initI18nContext) {\n            this.i18nEnd(null, selfClosingI18nInstruction);\n        }\n        // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n        const creationStatements = this._creationCodeFns.map((fn) => fn());\n        // Generate all the update mode instructions (e.g. resolve property or text bindings)\n        const updateStatements = this._updateCodeFns.map((fn) => fn());\n        //  Variable declaration must occur after binding resolution so we can generate context\n        //  instructions that build on each other.\n        // e.g. const b = nextContext().$implicit(); const b = nextContext();\n        const creationVariables = this._bindingScope.viewSnapshotStatements();\n        const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n        const creationBlock = creationStatements.length > 0 ?\n            [renderFlagCheckIfStmt(1 /* Create */, creationVariables.concat(creationStatements))] :\n            [];\n        const updateBlock = updateStatements.length > 0 ?\n            [renderFlagCheckIfStmt(2 /* Update */, updateVariables.concat(updateStatements))] :\n            [];\n        return fn(\n        // i.e. (rf: RenderFlags, ctx: any)\n        [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\n            // Temporary variable declarations for query refresh (i.e. let _t: any;)\n            ...this._prefixCode,\n            // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })\n            ...creationBlock,\n            // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})\n            ...updateBlock,\n        ], INFERRED_TYPE, null, this.templateName);\n    }\n    // LocalResolver\n    getLocal(name) {\n        return this._bindingScope.get(name);\n    }\n    // LocalResolver\n    notifyImplicitReceiverUse() {\n        this._bindingScope.notifyImplicitReceiverUse();\n    }\n    // LocalResolver\n    maybeRestoreView() {\n        this._bindingScope.maybeRestoreView();\n    }\n    i18nTranslate(message, params = {}, ref, transformFn) {\n        const _ref = ref || this.i18nGenerateMainBlockVar();\n        // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n        // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n        const closureVar = this.i18nGenerateClosureVar(message.id);\n        const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n        this._constants.prepareStatements.push(...statements);\n        return _ref;\n    }\n    registerContextVariables(variable$1) {\n        const scopedName = this._bindingScope.freshReferenceName();\n        const retrievalLevel = this.level;\n        const lhs = variable(variable$1.name + scopedName);\n        this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1 /* CONTEXT */, (scope, relativeLevel) => {\n            let rhs;\n            if (scope.bindingLevel === retrievalLevel) {\n                if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {\n                    // e.g. restoredCtx.\n                    // We have to get the context from a view reference, if one is available, because\n                    // the context that was passed in during creation may not be correct anymore.\n                    // For more information see: https://github.com/angular/angular/pull/40360.\n                    rhs = variable(RESTORED_VIEW_CONTEXT_NAME);\n                    scope.notifyRestoredViewContextUse();\n                }\n                else {\n                    // e.g. ctx\n                    rhs = variable(CONTEXT_NAME);\n                }\n            }\n            else {\n                const sharedCtxVar = scope.getSharedContextName(retrievalLevel);\n                // e.g. ctx_r0   OR  x(2);\n                rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n            }\n            // e.g. const $item$ = x(2).$implicit;\n            return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];\n        });\n    }\n    i18nAppendBindings(expressions) {\n        if (expressions.length > 0) {\n            expressions.forEach(expression => this.i18n.appendBinding(expression));\n        }\n    }\n    i18nBindProps(props) {\n        const bound = {};\n        Object.keys(props).forEach(key => {\n            const prop = props[key];\n            if (prop instanceof Text$3) {\n                bound[key] = literal(prop.value);\n            }\n            else {\n                const value = prop.value.visit(this._valueConverter);\n                this.allocateBindingSlots(value);\n                if (value instanceof Interpolation) {\n                    const { strings, expressions } = value;\n                    const { id, bindings } = this.i18n;\n                    const label = assembleI18nBoundString(strings, bindings.size, id);\n                    this.i18nAppendBindings(expressions);\n                    bound[key] = literal(label);\n                }\n            }\n        });\n        return bound;\n    }\n    // Generates top level vars for i18n blocks (i.e. `i18n_N`).\n    i18nGenerateMainBlockVar() {\n        return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));\n    }\n    // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n    i18nGenerateClosureVar(messageId) {\n        let name;\n        const suffix = this.fileBasedI18nSuffix.toUpperCase();\n        if (this.i18nUseExternalIds) {\n            const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n            const uniqueSuffix = this.constantPool.uniqueName(suffix);\n            name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n        }\n        else {\n            const prefix = getTranslationConstPrefix(suffix);\n            name = this.constantPool.uniqueName(prefix);\n        }\n        return variable(name);\n    }\n    i18nUpdateRef(context) {\n        const { icus, meta, isRoot, isResolved, isEmitted } = context;\n        if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n            context.isEmitted = true;\n            const placeholders = context.getSerializedPlaceholders();\n            let icuMapping = {};\n            let params = placeholders.size ? placeholdersToParams(placeholders) : {};\n            if (icus.size) {\n                icus.forEach((refs, key) => {\n                    if (refs.length === 1) {\n                        // if we have one ICU defined for a given\n                        // placeholder - just output its reference\n                        params[key] = refs[0];\n                    }\n                    else {\n                        // ... otherwise we need to activate post-processing\n                        // to replace ICU placeholders with proper values\n                        const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);\n                        params[key] = literal(placeholder);\n                        icuMapping[key] = literalArr(refs);\n                    }\n                });\n            }\n            // translation requires post processing in 2 cases:\n            // - if we have placeholders with multiple values (ex. `START_DIV`: [#1, #2, ...])\n            // - if we have multiple ICUs that refer to the same placeholder name\n            const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) ||\n                Object.keys(icuMapping).length;\n            let transformFn;\n            if (needsPostprocessing) {\n                transformFn = (raw) => {\n                    const args = [raw];\n                    if (Object.keys(icuMapping).length) {\n                        args.push(mapLiteral(icuMapping, true));\n                    }\n                    return instruction(null, Identifiers$1.i18nPostprocess, args);\n                };\n            }\n            this.i18nTranslate(meta, params, context.ref, transformFn);\n        }\n    }\n    i18nStart(span = null, meta, selfClosing) {\n        const index = this.allocateDataSlot();\n        this.i18n = this.i18nContext ?\n            this.i18nContext.forkChildContext(index, this.templateIndex, meta) :\n            new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);\n        // generate i18nStart instruction\n        const { id, ref } = this.i18n;\n        const params = [literal(index), this.addToConsts(ref)];\n        if (id > 0) {\n            // do not push 3rd argument (sub-block id)\n            // into i18nStart call for top level i18n context\n            params.push(literal(id));\n        }\n        this.creationInstruction(span, selfClosing ? Identifiers$1.i18n : Identifiers$1.i18nStart, params);\n    }\n    i18nEnd(span = null, selfClosing) {\n        if (!this.i18n) {\n            throw new Error('i18nEnd is executed with no i18n context present');\n        }\n        if (this.i18nContext) {\n            this.i18nContext.reconcileChildContext(this.i18n);\n            this.i18nUpdateRef(this.i18nContext);\n        }\n        else {\n            this.i18nUpdateRef(this.i18n);\n        }\n        // setup accumulated bindings\n        const { index, bindings } = this.i18n;\n        if (bindings.size) {\n            const chainBindings = [];\n            bindings.forEach(binding => {\n                chainBindings.push({ sourceSpan: span, value: () => this.convertPropertyBinding(binding) });\n            });\n            // for i18n block, advance to the most recent element index (by taking the current number of\n            // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n            // necessary lifecycle hooks of components/directives are properly flushed.\n            this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers$1.i18nExp, chainBindings);\n            this.updateInstruction(span, Identifiers$1.i18nApply, [literal(index)]);\n        }\n        if (!selfClosing) {\n            this.creationInstruction(span, Identifiers$1.i18nEnd);\n        }\n        this.i18n = null; // reset local i18n context\n    }\n    i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {\n        let hasBindings = false;\n        const i18nAttrArgs = [];\n        const bindings = [];\n        attrs.forEach(attr => {\n            const message = attr.i18n;\n            const converted = attr.value.visit(this._valueConverter);\n            this.allocateBindingSlots(converted);\n            if (converted instanceof Interpolation) {\n                const placeholders = assembleBoundTextPlaceholders(message);\n                const params = placeholdersToParams(placeholders);\n                i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));\n                converted.expressions.forEach(expression => {\n                    hasBindings = true;\n                    bindings.push({\n                        sourceSpan,\n                        value: () => this.convertPropertyBinding(expression),\n                    });\n                });\n            }\n        });\n        if (bindings.length > 0) {\n            this.updateInstructionChainWithAdvance(nodeIndex, Identifiers$1.i18nExp, bindings);\n        }\n        if (i18nAttrArgs.length > 0) {\n            const index = literal(this.allocateDataSlot());\n            const constIndex = this.addToConsts(literalArr(i18nAttrArgs));\n            this.creationInstruction(sourceSpan, Identifiers$1.i18nAttributes, [index, constIndex]);\n            if (hasBindings) {\n                this.updateInstruction(sourceSpan, Identifiers$1.i18nApply, [index]);\n            }\n        }\n    }\n    getNamespaceInstruction(namespaceKey) {\n        switch (namespaceKey) {\n            case 'math':\n                return Identifiers$1.namespaceMathML;\n            case 'svg':\n                return Identifiers$1.namespaceSVG;\n            default:\n                return Identifiers$1.namespaceHTML;\n        }\n    }\n    addNamespaceInstruction(nsInstruction, element) {\n        this._namespace = nsInstruction;\n        this.creationInstruction(element.startSourceSpan, nsInstruction);\n    }\n    /**\n     * Adds an update instruction for an interpolated property or attribute, such as\n     * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n     */\n    interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {\n        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);\n    }\n    visitContent(ngContent) {\n        const slot = this.allocateDataSlot();\n        const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n        const parameters = [literal(slot)];\n        this._ngContentReservedSlots.push(ngContent.selector);\n        const nonContentSelectAttributes = ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR);\n        const attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);\n        if (attributes.length > 0) {\n            parameters.push(literal(projectionSlotIdx), literalArr(attributes));\n        }\n        else if (projectionSlotIdx !== 0) {\n            parameters.push(literal(projectionSlotIdx));\n        }\n        this.creationInstruction(ngContent.sourceSpan, Identifiers$1.projection, parameters);\n        if (this.i18n) {\n            this.i18n.appendProjection(ngContent.i18n, slot);\n        }\n    }\n    visitElement(element) {\n        var _a, _b;\n        const elementIndex = this.allocateDataSlot();\n        const stylingBuilder = new StylingBuilder(null);\n        let isNonBindableMode = false;\n        const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n        const outputAttrs = [];\n        const [namespaceKey, elementName] = splitNsName(element.name);\n        const isNgContainer$1 = isNgContainer(element.name);\n        // Handle styling, i18n, ngNonBindable attributes\n        for (const attr of element.attributes) {\n            const { name, value } = attr;\n            if (name === NON_BINDABLE_ATTR) {\n                isNonBindableMode = true;\n            }\n            else if (name === 'style') {\n                stylingBuilder.registerStyleAttr(value);\n            }\n            else if (name === 'class') {\n                stylingBuilder.registerClassAttr(value);\n            }\n            else {\n                outputAttrs.push(attr);\n            }\n        }\n        // Regular element or ng-container creation mode\n        const parameters = [literal(elementIndex)];\n        if (!isNgContainer$1) {\n            parameters.push(literal(elementName));\n        }\n        // Add the attributes\n        const allOtherInputs = [];\n        const boundI18nAttrs = [];\n        element.inputs.forEach(input => {\n            const stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n            if (!stylingInputWasSet) {\n                if (input.type === 0 /* Property */ && input.i18n) {\n                    boundI18nAttrs.push(input);\n                }\n                else {\n                    allOtherInputs.push(input);\n                }\n            }\n        });\n        // add attributes for directive and projection matching purposes\n        const attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);\n        parameters.push(this.addAttrsToConsts(attributes));\n        // local refs (ex.: <div #foo #bar=\"baz\">)\n        const refs = this.prepareRefsArray(element.references);\n        parameters.push(this.addToConsts(refs));\n        const wasInNamespace = this._namespace;\n        const currentNamespace = this.getNamespaceInstruction(namespaceKey);\n        // If the namespace is changing now, include an instruction to change it\n        // during element creation.\n        if (currentNamespace !== wasInNamespace) {\n            this.addNamespaceInstruction(currentNamespace, element);\n        }\n        if (this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex);\n        }\n        // Note that we do not append text node instructions and ICUs inside i18n section,\n        // so we exclude them while calculating whether current element has children\n        const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :\n            element.children.length > 0;\n        const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&\n            element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;\n        const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n        if (createSelfClosingInstruction) {\n            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainer : Identifiers$1.element, trimTrailingNulls(parameters));\n        }\n        else {\n            this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers$1.elementContainerStart : Identifiers$1.elementStart, trimTrailingNulls(parameters));\n            if (isNonBindableMode) {\n                this.creationInstruction(element.startSourceSpan, Identifiers$1.disableBindings);\n            }\n            if (boundI18nAttrs.length > 0) {\n                this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan);\n            }\n            // Generate Listeners (outputs)\n            if (element.outputs.length > 0) {\n                const listeners = element.outputs.map((outputAst) => ({\n                    sourceSpan: outputAst.sourceSpan,\n                    params: this.prepareListenerParameter(element.name, outputAst, elementIndex)\n                }));\n                this.creationInstructionChain(Identifiers$1.listener, listeners);\n            }\n            // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n            // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n            if (isI18nRootElement) {\n                this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);\n            }\n        }\n        // the code here will collect all update-level styling instructions and add them to the\n        // update block of the template function AOT code. Instructions like `styleProp`,\n        // `styleMap`, `classMap`, `classProp`\n        // are all generated and assigned in the code below.\n        const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n        const limit = stylingInstructions.length - 1;\n        for (let i = 0; i <= limit; i++) {\n            const instruction = stylingInstructions[i];\n            this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);\n        }\n        // the reason why `undefined` is used is because the renderer understands this as a\n        // special value to symbolize that there is no RHS to this binding\n        // TODO (matsko): revisit this once FW-959 is approached\n        const emptyValueBindInstruction = literal(undefined);\n        const propertyBindings = [];\n        const attributeBindings = [];\n        // Generate element input bindings\n        allOtherInputs.forEach(input => {\n            const inputType = input.type;\n            if (inputType === 4 /* Animation */) {\n                const value = input.value.visit(this._valueConverter);\n                // animation bindings can be presented in the following formats:\n                // 1. [@binding]=\"fooExp\"\n                // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n                // 3. [@binding]\n                // 4. @binding\n                // All formats will be valid for when a synthetic binding is created.\n                // The reasoning for this is because the renderer should get each\n                // synthetic binding value in the order of the array that they are\n                // defined in...\n                const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;\n                this.allocateBindingSlots(value);\n                propertyBindings.push({\n                    name: prepareSyntheticPropertyName(input.name),\n                    sourceSpan: input.sourceSpan,\n                    value: () => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction\n                });\n            }\n            else {\n                // we must skip attributes with associated i18n context, since these attributes are handled\n                // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n                if (input.i18n)\n                    return;\n                const value = input.value.visit(this._valueConverter);\n                if (value !== undefined) {\n                    const params = [];\n                    const [attrNamespace, attrName] = splitNsName(input.name);\n                    const isAttributeBinding = inputType === 1 /* Attribute */;\n                    const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n                    if (sanitizationRef)\n                        params.push(sanitizationRef);\n                    if (attrNamespace) {\n                        const namespaceLiteral = literal(attrNamespace);\n                        if (sanitizationRef) {\n                            params.push(namespaceLiteral);\n                        }\n                        else {\n                            // If there wasn't a sanitization ref, we need to add\n                            // an extra param so that we can pass in the namespace.\n                            params.push(literal(null), namespaceLiteral);\n                        }\n                    }\n                    this.allocateBindingSlots(value);\n                    if (inputType === 0 /* Property */) {\n                        if (value instanceof Interpolation) {\n                            // prop=\"{{value}}\" and friends\n                            this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);\n                        }\n                        else {\n                            // [prop]=\"value\"\n                            // Collect all the properties so that we can chain into a single function at the end.\n                            propertyBindings.push({\n                                name: attrName,\n                                sourceSpan: input.sourceSpan,\n                                value: () => this.convertPropertyBinding(value),\n                                params\n                            });\n                        }\n                    }\n                    else if (inputType === 1 /* Attribute */) {\n                        if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {\n                            // attr.name=\"text{{value}}\" and friends\n                            this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);\n                        }\n                        else {\n                            const boundValue = value instanceof Interpolation ? value.expressions[0] : value;\n                            // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n                            // Collect the attribute bindings so that they can be chained at the end.\n                            attributeBindings.push({\n                                name: attrName,\n                                sourceSpan: input.sourceSpan,\n                                value: () => this.convertPropertyBinding(boundValue),\n                                params\n                            });\n                        }\n                    }\n                    else {\n                        // class prop\n                        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers$1.classProp, () => {\n                            return [\n                                literal(elementIndex), literal(attrName), this.convertPropertyBinding(value),\n                                ...params\n                            ];\n                        });\n                    }\n                }\n            }\n        });\n        if (propertyBindings.length > 0) {\n            this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.property, propertyBindings);\n        }\n        if (attributeBindings.length > 0) {\n            this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.attribute, attributeBindings);\n        }\n        // Traverse element child nodes\n        visitAll$1(this, element.children);\n        if (!isI18nRootElement && this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex, true);\n        }\n        if (!createSelfClosingInstruction) {\n            // Finish element construction mode.\n            const span = (_b = element.endSourceSpan) !== null && _b !== void 0 ? _b : element.sourceSpan;\n            if (isI18nRootElement) {\n                this.i18nEnd(span, createSelfClosingI18nInstruction);\n            }\n            if (isNonBindableMode) {\n                this.creationInstruction(span, Identifiers$1.enableBindings);\n            }\n            this.creationInstruction(span, isNgContainer$1 ? Identifiers$1.elementContainerEnd : Identifiers$1.elementEnd);\n        }\n    }\n    visitTemplate(template) {\n        var _a;\n        const NG_TEMPLATE_TAG_NAME = 'ng-template';\n        const templateIndex = this.allocateDataSlot();\n        if (this.i18n) {\n            this.i18n.appendTemplate(template.i18n, templateIndex);\n        }\n        const tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;\n        const contextName = `${this.contextName}${template.tagName ? '_' + sanitizeIdentifier(template.tagName) : ''}_${templateIndex}`;\n        const templateName = `${contextName}_Template`;\n        const parameters = [\n            literal(templateIndex),\n            variable(templateName),\n            // We don't care about the tag's namespace here, because we infer\n            // it based on the parent nodes inside the template instruction.\n            literal(tagNameWithoutNamespace),\n        ];\n        // prepare attributes parameter (including attributes used for directive matching)\n        const attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, undefined /* styles */, template.templateAttrs);\n        parameters.push(this.addAttrsToConsts(attrsExprs));\n        // local refs (ex.: <ng-template #foo>)\n        if (template.references && template.references.length) {\n            const refs = this.prepareRefsArray(template.references);\n            parameters.push(this.addToConsts(refs));\n            parameters.push(importExpr(Identifiers$1.templateRefExtractor));\n        }\n        // Create the template function\n        const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);\n        // Nested templates must not be visited until after their parent templates have completed\n        // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n        // be able to support bindings in nested templates to local refs that occur after the\n        // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n        this._nestedTemplateFns.push(() => {\n            const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);\n            this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\n            if (templateVisitor._ngContentReservedSlots.length) {\n                this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);\n            }\n        });\n        // e.g. template(1, MyComp_Template_1)\n        this.creationInstruction(template.sourceSpan, Identifiers$1.templateCreate, () => {\n            parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));\n            return trimTrailingNulls(parameters);\n        });\n        // handle property bindings e.g. property('ngForOf', ctx.items), et al;\n        this.templatePropertyBindings(templateIndex, template.templateAttrs);\n        // Only add normal input/output binding instructions on explicit <ng-template> elements.\n        if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {\n            const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);\n            // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n            // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n            // elements, in case of inline templates, corresponding instructions will be generated in the\n            // nested template function.\n            if (i18nInputs.length > 0) {\n                this.i18nAttributesInstruction(templateIndex, i18nInputs, (_a = template.startSourceSpan) !== null && _a !== void 0 ? _a : template.sourceSpan);\n            }\n            // Add the input bindings\n            if (inputs.length > 0) {\n                this.templatePropertyBindings(templateIndex, inputs);\n            }\n            // Generate listeners for directive output\n            if (template.outputs.length > 0) {\n                const listeners = template.outputs.map((outputAst) => ({\n                    sourceSpan: outputAst.sourceSpan,\n                    params: this.prepareListenerParameter('ng_template', outputAst, templateIndex)\n                }));\n                this.creationInstructionChain(Identifiers$1.listener, listeners);\n            }\n        }\n    }\n    visitBoundText(text) {\n        if (this.i18n) {\n            const value = text.value.visit(this._valueConverter);\n            this.allocateBindingSlots(value);\n            if (value instanceof Interpolation) {\n                this.i18n.appendBoundText(text.i18n);\n                this.i18nAppendBindings(value.expressions);\n            }\n            return;\n        }\n        const nodeIndex = this.allocateDataSlot();\n        this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(nodeIndex)]);\n        const value = text.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value);\n        if (value instanceof Interpolation) {\n            this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));\n        }\n        else {\n            error('Text nodes should be interpolated and never bound directly.');\n        }\n    }\n    visitText(text) {\n        // when a text element is located within a translatable\n        // block, we exclude this text element from instructions set,\n        // since it will be captured in i18n content and processed at runtime\n        if (!this.i18n) {\n            this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(this.allocateDataSlot()), literal(text.value)]);\n        }\n    }\n    visitIcu(icu) {\n        let initWasInvoked = false;\n        // if an ICU was created outside of i18n block, we still treat\n        // it as a translatable entity and invoke i18nStart and i18nEnd\n        // to generate i18n context and the necessary instructions\n        if (!this.i18n) {\n            initWasInvoked = true;\n            this.i18nStart(null, icu.i18n, true);\n        }\n        const i18n = this.i18n;\n        const vars = this.i18nBindProps(icu.vars);\n        const placeholders = this.i18nBindProps(icu.placeholders);\n        // output ICU directly and keep ICU reference in context\n        const message = icu.i18n;\n        // we always need post-processing function for ICUs, to make sure that:\n        // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n        // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n        // inside ICUs)\n        // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n        const transformFn = (raw) => {\n            const params = Object.assign(Object.assign({}, vars), placeholders);\n            const formatted = i18nFormatPlaceholderNames(params, /* useCamelCase */ false);\n            return instruction(null, Identifiers$1.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n        };\n        // in case the whole i18n message is a single ICU - we do not need to\n        // create a separate top-level translation, we can use the root ref instead\n        // and make this ICU a top-level translation\n        // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n        // separately, so we do not pass placeholders into `i18nTranslate` function.\n        if (isSingleI18nIcu(i18n.meta)) {\n            this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);\n        }\n        else {\n            // output ICU directly and keep ICU reference in context\n            const ref = this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);\n            i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n        }\n        if (initWasInvoked) {\n            this.i18nEnd(null, true);\n        }\n        return null;\n    }\n    allocateDataSlot() {\n        return this._dataIndex++;\n    }\n    getConstCount() {\n        return this._dataIndex;\n    }\n    getVarCount() {\n        return this._pureFunctionSlots;\n    }\n    getConsts() {\n        return this._constants;\n    }\n    getNgContentSelectors() {\n        return this._ngContentReservedSlots.length ?\n            this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :\n            null;\n    }\n    bindingContext() {\n        return `${this._bindingContext++}`;\n    }\n    templatePropertyBindings(templateIndex, attrs) {\n        const propertyBindings = [];\n        attrs.forEach(input => {\n            if (input instanceof BoundAttribute) {\n                const value = input.value.visit(this._valueConverter);\n                if (value !== undefined) {\n                    this.allocateBindingSlots(value);\n                    if (value instanceof Interpolation) {\n                        // Params typically contain attribute namespace and value sanitizer, which is applicable\n                        // for regular HTML elements, but not applicable for <ng-template> (since props act as\n                        // inputs to directives), so keep params array empty.\n                        const params = [];\n                        // prop=\"{{value}}\" case\n                        this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);\n                    }\n                    else {\n                        // [prop]=\"value\" case\n                        propertyBindings.push({\n                            name: input.name,\n                            sourceSpan: input.sourceSpan,\n                            value: () => this.convertPropertyBinding(value)\n                        });\n                    }\n                }\n            }\n        });\n        if (propertyBindings.length > 0) {\n            this.updateInstructionChainWithAdvance(templateIndex, Identifiers$1.property, propertyBindings);\n        }\n    }\n    // Bindings must only be resolved after all local refs have been visited, so all\n    // instructions are queued in callbacks that execute once the initial pass has completed.\n    // Otherwise, we wouldn't be able to support local refs that are defined after their\n    // bindings. e.g. {{ foo }} <div #foo></div>\n    instructionFn(fns, span, reference, paramsOrFn, prepend = false) {\n        fns[prepend ? 'unshift' : 'push'](() => {\n            const params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();\n            return instruction(span, reference, params).toStmt();\n        });\n    }\n    processStylingUpdateInstruction(elementIndex, instruction) {\n        let allocateBindingSlots = 0;\n        if (instruction) {\n            const calls = [];\n            instruction.calls.forEach(call => {\n                allocateBindingSlots += call.allocateBindingSlots;\n                calls.push({\n                    sourceSpan: call.sourceSpan,\n                    value: () => {\n                        return call.params(value => (call.supportsInterpolation && value instanceof Interpolation) ?\n                            this.getUpdateInstructionArguments(value) :\n                            this.convertPropertyBinding(value));\n                    }\n                });\n            });\n            this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls);\n        }\n        return allocateBindingSlots;\n    }\n    creationInstruction(span, reference, paramsOrFn, prepend) {\n        this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n    }\n    creationInstructionChain(reference, calls) {\n        const span = calls.length ? calls[0].sourceSpan : null;\n        this._creationCodeFns.push(() => {\n            return chainedInstruction(reference, calls.map(call => call.params()), span).toStmt();\n        });\n    }\n    updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {\n        this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n        this.updateInstruction(span, reference, paramsOrFn);\n    }\n    updateInstruction(span, reference, paramsOrFn) {\n        this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n    }\n    updateInstructionChain(reference, bindings) {\n        const span = bindings.length ? bindings[0].sourceSpan : null;\n        this._updateCodeFns.push(() => {\n            const calls = bindings.map(property => {\n                const value = property.value();\n                const fnParams = Array.isArray(value) ? value : [value];\n                if (property.params) {\n                    fnParams.push(...property.params);\n                }\n                if (property.name) {\n                    // We want the property name to always be the first function parameter.\n                    fnParams.unshift(literal(property.name));\n                }\n                return fnParams;\n            });\n            return chainedInstruction(reference, calls, span).toStmt();\n        });\n    }\n    updateInstructionChainWithAdvance(nodeIndex, reference, bindings) {\n        this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);\n        this.updateInstructionChain(reference, bindings);\n    }\n    addAdvanceInstructionIfNecessary(nodeIndex, span) {\n        if (nodeIndex !== this._currentIndex) {\n            const delta = nodeIndex - this._currentIndex;\n            if (delta < 1) {\n                throw new Error('advance instruction can only go forwards');\n            }\n            this.instructionFn(this._updateCodeFns, span, Identifiers$1.advance, [literal(delta)]);\n            this._currentIndex = nodeIndex;\n        }\n    }\n    allocatePureFunctionSlots(numSlots) {\n        const originalSlots = this._pureFunctionSlots;\n        this._pureFunctionSlots += numSlots;\n        return originalSlots;\n    }\n    allocateBindingSlots(value) {\n        this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n    }\n    /**\n     * Gets an expression that refers to the implicit receiver. The implicit\n     * receiver is always the root level context.\n     */\n    getImplicitReceiverExpr() {\n        if (this._implicitReceiverExpr) {\n            return this._implicitReceiverExpr;\n        }\n        return this._implicitReceiverExpr = this.level === 0 ?\n            variable(CONTEXT_NAME) :\n            this._bindingScope.getOrCreateSharedContextVar(0);\n    }\n    convertPropertyBinding(value) {\n        const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), () => error('Unexpected interpolation'));\n        const valExpr = convertedPropertyBinding.currValExpr;\n        this._tempVariables.push(...convertedPropertyBinding.stmts);\n        return valExpr;\n    }\n    /**\n     * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n     * the temp variables state with temp variables that were identified as needing to be created\n     * while visiting the arguments.\n     * @param value The original expression we will be resolving an arguments list from.\n     */\n    getUpdateInstructionArguments(value) {\n        const { args, stmts } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n        this._tempVariables.push(...stmts);\n        return args;\n    }\n    /**\n     * Prepares all attribute expression values for the `TAttributes` array.\n     *\n     * The purpose of this function is to properly construct an attributes array that\n     * is passed into the `elementStart` (or just `element`) functions. Because there\n     * are many different types of attributes, the array needs to be constructed in a\n     * special way so that `elementStart` can properly evaluate them.\n     *\n     * The format looks like this:\n     *\n     * ```\n     * attrs = [prop, value, prop2, value2,\n     *   PROJECT_AS, selector,\n     *   CLASSES, class1, class2,\n     *   STYLES, style1, value1, style2, value2,\n     *   BINDINGS, name1, name2, name3,\n     *   TEMPLATE, name4, name5, name6,\n     *   I18N, name7, name8, ...]\n     * ```\n     *\n     * Note that this function will fully ignore all synthetic (@foo) attribute values\n     * because those values are intended to always be generated as property instructions.\n     */\n    getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles, templateAttrs = [], boundI18nAttrs = []) {\n        const alreadySeen = new Set();\n        const attrExprs = [];\n        let ngProjectAsAttr;\n        for (const attr of renderAttributes) {\n            if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n                ngProjectAsAttr = attr;\n            }\n            // Note that static i18n attributes aren't in the i18n array,\n            // because they're treated in the same way as regular attributes.\n            if (attr.i18n) {\n                // When i18n attributes are present on elements with structural directives\n                // (e.g. `<div *ngIf title=\"Hello\" i18n-title>`), we want to avoid generating\n                // duplicate i18n translation blocks for `template` and `element` instruction\n                // attributes. So we do a cache lookup to see if suitable i18n translation block\n                // already exists.\n                const { i18nVarRefsCache } = this._constants;\n                let i18nVarRef;\n                if (i18nVarRefsCache.has(attr.i18n)) {\n                    i18nVarRef = i18nVarRefsCache.get(attr.i18n);\n                }\n                else {\n                    i18nVarRef = this.i18nTranslate(attr.i18n);\n                    i18nVarRefsCache.set(attr.i18n, i18nVarRef);\n                }\n                attrExprs.push(literal(attr.name), i18nVarRef);\n            }\n            else {\n                attrExprs.push(...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));\n            }\n        }\n        // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n        // ngProjectAs marker in the attribute name slot.\n        if (ngProjectAsAttr) {\n            attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));\n        }\n        function addAttrExpr(key, value) {\n            if (typeof key === 'string') {\n                if (!alreadySeen.has(key)) {\n                    attrExprs.push(...getAttributeNameLiterals(key));\n                    value !== undefined && attrExprs.push(value);\n                    alreadySeen.add(key);\n                }\n            }\n            else {\n                attrExprs.push(literal(key));\n            }\n        }\n        // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n        // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n        // as single property value cell by cell.\n        if (styles) {\n            styles.populateInitialStylingAttrs(attrExprs);\n        }\n        if (inputs.length || outputs.length) {\n            const attrsLengthBeforeInputs = attrExprs.length;\n            for (let i = 0; i < inputs.length; i++) {\n                const input = inputs[i];\n                // We don't want the animation and attribute bindings in the\n                // attributes array since they aren't used for directive matching.\n                if (input.type !== 4 /* Animation */ && input.type !== 1 /* Attribute */) {\n                    addAttrExpr(input.name);\n                }\n            }\n            for (let i = 0; i < outputs.length; i++) {\n                const output = outputs[i];\n                if (output.type !== 1 /* Animation */) {\n                    addAttrExpr(output.name);\n                }\n            }\n            // this is a cheap way of adding the marker only after all the input/output\n            // values have been filtered (by not including the animation ones) and added\n            // to the expressions. The marker is important because it tells the runtime\n            // code that this is where attributes without values start...\n            if (attrExprs.length !== attrsLengthBeforeInputs) {\n                attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3 /* Bindings */));\n            }\n        }\n        if (templateAttrs.length) {\n            attrExprs.push(literal(4 /* Template */));\n            templateAttrs.forEach(attr => addAttrExpr(attr.name));\n        }\n        if (boundI18nAttrs.length) {\n            attrExprs.push(literal(6 /* I18n */));\n            boundI18nAttrs.forEach(attr => addAttrExpr(attr.name));\n        }\n        return attrExprs;\n    }\n    addToConsts(expression) {\n        if (isNull(expression)) {\n            return TYPED_NULL_EXPR;\n        }\n        const consts = this._constants.constExpressions;\n        // Try to reuse a literal that's already in the array, if possible.\n        for (let i = 0; i < consts.length; i++) {\n            if (consts[i].isEquivalent(expression)) {\n                return literal(i);\n            }\n        }\n        return literal(consts.push(expression) - 1);\n    }\n    addAttrsToConsts(attrs) {\n        return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;\n    }\n    prepareRefsArray(references) {\n        if (!references || references.length === 0) {\n            return TYPED_NULL_EXPR;\n        }\n        const refsParam = flatten(references.map(reference => {\n            const slot = this.allocateDataSlot();\n            // Generate the update temporary.\n            const variableName = this._bindingScope.freshReferenceName();\n            const retrievalLevel = this.level;\n            const lhs = variable(variableName);\n            this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DEFAULT */, (scope, relativeLevel) => {\n                // e.g. nextContext(2);\n                const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\n                // e.g. const $foo$ = reference(1);\n                const refExpr = lhs.set(importExpr(Identifiers$1.reference).callFn([literal(slot)]));\n                return nextContextStmt.concat(refExpr.toConstDecl());\n            }, true);\n            return [reference.name, reference.value];\n        }));\n        return asLiteral(refsParam);\n    }\n    prepareListenerParameter(tagName, outputAst, index) {\n        return () => {\n            const eventName = outputAst.name;\n            const bindingFnName = outputAst.type === 1 /* Animation */ ?\n                // synthetic @listener.foo values are treated the exact same as are standard listeners\n                prepareSyntheticListenerFunctionName(eventName, outputAst.phase) :\n                sanitizeIdentifier(eventName);\n            const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;\n            const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);\n            return prepareEventListenerParameters(outputAst, handlerName, scope);\n        };\n    }\n}\nclass ValueConverter extends AstMemoryEfficientTransformer {\n    constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {\n        super();\n        this.constantPool = constantPool;\n        this.allocateSlot = allocateSlot;\n        this.allocatePureFunctionSlots = allocatePureFunctionSlots;\n        this.definePipe = definePipe;\n        this._pipeBindExprs = [];\n    }\n    // AstMemoryEfficientTransformer\n    visitPipe(pipe, context) {\n        // Allocate a slot to create the pipe\n        const slot = this.allocateSlot();\n        const slotPseudoLocal = `PIPE:${slot}`;\n        // Allocate one slot for the result plus one slot per pipe argument\n        const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n        const target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);\n        const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);\n        this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));\n        const args = [pipe.exp, ...pipe.args];\n        const convertedArgs = isVarLength ?\n            this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :\n            this.visitAll(args);\n        const pipeBindExpr = new Call(pipe.span, pipe.sourceSpan, target, [\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),\n            ...convertedArgs,\n        ], null);\n        this._pipeBindExprs.push(pipeBindExpr);\n        return pipeBindExpr;\n    }\n    updatePipeSlotOffsets(bindingSlots) {\n        this._pipeBindExprs.forEach((pipe) => {\n            // update the slot offset arg (index 1) to account for binding slots\n            const slotOffset = pipe.args[1];\n            slotOffset.value += bindingSlots;\n        });\n    }\n    visitLiteralArray(array, context) {\n        return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), values => {\n            // If the literal has calculated (non-literal) elements transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values.\n            const literal = literalArr(values);\n            return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n        });\n    }\n    visitLiteralMap(map, context) {\n        return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {\n            // If the literal has calculated (non-literal) elements  transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values.\n            const literal = literalMap(values.map((value, index) => ({ key: map.keys[index].key, value, quoted: map.keys[index].quoted })));\n            return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n        });\n    }\n}\n// Pipes always have at least one parameter, the value they operate on\nconst pipeBindingIdentifiers = [Identifiers$1.pipeBind1, Identifiers$1.pipeBind2, Identifiers$1.pipeBind3, Identifiers$1.pipeBind4];\nfunction pipeBindingCallInfo(args) {\n    const identifier = pipeBindingIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers$1.pipeBindV,\n        isVarLength: !identifier,\n    };\n}\nconst pureFunctionIdentifiers = [\n    Identifiers$1.pureFunction0, Identifiers$1.pureFunction1, Identifiers$1.pureFunction2, Identifiers$1.pureFunction3, Identifiers$1.pureFunction4,\n    Identifiers$1.pureFunction5, Identifiers$1.pureFunction6, Identifiers$1.pureFunction7, Identifiers$1.pureFunction8\n];\nfunction pureFunctionCallInfo(args) {\n    const identifier = pureFunctionIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers$1.pureFunctionV,\n        isVarLength: !identifier,\n    };\n}\nfunction instruction(span, reference, params) {\n    return importExpr(reference, null, span).callFn(params, span);\n}\n// e.g. x(2);\nfunction generateNextContextExpr(relativeLevelDiff) {\n    return importExpr(Identifiers$1.nextContext)\n        .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);\n}\nfunction getLiteralFactory(constantPool, literal$1, allocateSlots) {\n    const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$1);\n    // Allocate 1 slot for the result plus 1 per argument\n    const startSlot = allocateSlots(1 + literalFactoryArguments.length);\n    const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);\n    // Literal factories are pure functions that only need to be re-invoked when the parameters\n    // change.\n    const args = [literal(startSlot), literalFactory];\n    if (isVarLength) {\n        args.push(literalArr(literalFactoryArguments));\n    }\n    else {\n        args.push(...literalFactoryArguments);\n    }\n    return importExpr(identifier).callFn(args);\n}\n/**\n * Gets an array of literals that can be added to an expression\n * to represent the name and namespace of an attribute. E.g.\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n *\n * @param name Name of the attribute, including the namespace.\n */\nfunction getAttributeNameLiterals(name) {\n    const [attributeNamespace, attributeName] = splitNsName(name);\n    const nameLiteral = literal(attributeName);\n    if (attributeNamespace) {\n        return [\n            literal(0 /* NamespaceURI */), literal(attributeNamespace), nameLiteral\n        ];\n    }\n    return [nameLiteral];\n}\n/** The prefix used to get a shared context in BindingScope's map. */\nconst SHARED_CONTEXT_KEY = '$$shared_ctx$$';\nclass BindingScope {\n    constructor(bindingLevel = 0, parent = null, globals) {\n        this.bindingLevel = bindingLevel;\n        this.parent = parent;\n        this.globals = globals;\n        /** Keeps a map from local variables to their BindingData. */\n        this.map = new Map();\n        this.referenceNameIndex = 0;\n        this.restoreViewVariable = null;\n        this.usesRestoredViewContext = false;\n        if (globals !== undefined) {\n            for (const name of globals) {\n                this.set(0, name, variable(name));\n            }\n        }\n    }\n    static createRootScope() {\n        return new BindingScope();\n    }\n    get(name) {\n        let current = this;\n        while (current) {\n            let value = current.map.get(name);\n            if (value != null) {\n                if (current !== this) {\n                    // make a local copy and reset the `declare` state\n                    value = {\n                        retrievalLevel: value.retrievalLevel,\n                        lhs: value.lhs,\n                        declareLocalCallback: value.declareLocalCallback,\n                        declare: false,\n                        priority: value.priority\n                    };\n                    // Cache the value locally.\n                    this.map.set(name, value);\n                    // Possibly generate a shared context var\n                    this.maybeGenerateSharedContextVar(value);\n                    this.maybeRestoreView();\n                }\n                if (value.declareLocalCallback && !value.declare) {\n                    value.declare = true;\n                }\n                return value.lhs;\n            }\n            current = current.parent;\n        }\n        // If we get to this point, we are looking for a property on the top level component\n        // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n        // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n        // local var we used to store the component context, e.g. const $comp$ = x();\n        return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n    }\n    /**\n     * Create a local variable for later reference.\n     *\n     * @param retrievalLevel The level from which this value can be retrieved\n     * @param name Name of the variable.\n     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n     * @param priority The sorting priority of this var\n     * @param declareLocalCallback The callback to invoke when declaring this local var\n     * @param localRef Whether or not this is a local ref\n     */\n    set(retrievalLevel, name, lhs, priority = 0 /* DEFAULT */, declareLocalCallback, localRef) {\n        if (this.map.has(name)) {\n            if (localRef) {\n                // Do not throw an error if it's a local ref and do not update existing value,\n                // so the first defined ref is always returned.\n                return this;\n            }\n            error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);\n        }\n        this.map.set(name, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declare: false,\n            declareLocalCallback: declareLocalCallback,\n            priority: priority,\n        });\n        return this;\n    }\n    // Implemented as part of LocalResolver.\n    getLocal(name) {\n        return this.get(name);\n    }\n    // Implemented as part of LocalResolver.\n    notifyImplicitReceiverUse() {\n        if (this.bindingLevel !== 0) {\n            // Since the implicit receiver is accessed in an embedded view, we need to\n            // ensure that we declare a shared context variable for the current template\n            // in the update variables.\n            this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;\n        }\n    }\n    nestedScope(level, globals) {\n        const newScope = new BindingScope(level, this, globals);\n        if (level > 0)\n            newScope.generateSharedContextVar(0);\n        return newScope;\n    }\n    /**\n     * Gets or creates a shared context variable and returns its expression. Note that\n     * this does not mean that the shared variable will be declared. Variables in the\n     * binding scope will be only declared if they are used.\n     */\n    getOrCreateSharedContextVar(retrievalLevel) {\n        const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n        if (!this.map.has(bindingKey)) {\n            this.generateSharedContextVar(retrievalLevel);\n        }\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return this.map.get(bindingKey).lhs;\n    }\n    getSharedContextName(retrievalLevel) {\n        const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;\n    }\n    maybeGenerateSharedContextVar(value) {\n        if (value.priority === 1 /* CONTEXT */ &&\n            value.retrievalLevel < this.bindingLevel) {\n            const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n            if (sharedCtxObj) {\n                sharedCtxObj.declare = true;\n            }\n            else {\n                this.generateSharedContextVar(value.retrievalLevel);\n            }\n        }\n    }\n    generateSharedContextVar(retrievalLevel) {\n        const lhs = variable(CONTEXT_NAME + this.freshReferenceName());\n        this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declareLocalCallback: (scope, relativeLevel) => {\n                // const ctx_r0 = nextContext(2);\n                return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n            },\n            declare: false,\n            priority: 2 /* SHARED_CONTEXT */,\n        });\n    }\n    getComponentProperty(name) {\n        const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);\n        componentValue.declare = true;\n        this.maybeRestoreView();\n        return componentValue.lhs.prop(name);\n    }\n    maybeRestoreView() {\n        // View restoration is required for listener instructions inside embedded views, because\n        // they only run in creation mode and they can have references to the context object.\n        // If the context object changes in update mode, the reference will be incorrect, because\n        // it was established during creation.\n        if (this.isListenerScope()) {\n            if (!this.parent.restoreViewVariable) {\n                // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n                this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());\n            }\n            this.restoreViewVariable = this.parent.restoreViewVariable;\n        }\n    }\n    restoreViewStatement() {\n        const statements = [];\n        if (this.restoreViewVariable) {\n            const restoreCall = instruction(null, Identifiers$1.restoreView, [this.restoreViewVariable]);\n            // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`\n            // depending on whether it is being used.\n            statements.push(this.usesRestoredViewContext ?\n                variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() :\n                restoreCall.toStmt());\n        }\n        return statements;\n    }\n    viewSnapshotStatements() {\n        // const $state$ = getCurrentView();\n        return this.restoreViewVariable ?\n            [this.restoreViewVariable.set(instruction(null, Identifiers$1.getCurrentView, [])).toConstDecl()] :\n            [];\n    }\n    isListenerScope() {\n        return this.parent && this.parent.bindingLevel === this.bindingLevel;\n    }\n    variableDeclarations() {\n        let currentContextLevel = 0;\n        return Array.from(this.map.values())\n            .filter(value => value.declare)\n            .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)\n            .reduce((stmts, value) => {\n            const levelDiff = this.bindingLevel - value.retrievalLevel;\n            const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);\n            currentContextLevel = levelDiff;\n            return stmts.concat(currStmts);\n        }, []);\n    }\n    freshReferenceName() {\n        let current = this;\n        // Find the top scope as it maintains the global reference count\n        while (current.parent)\n            current = current.parent;\n        const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;\n        return ref;\n    }\n    hasRestoreViewVariable() {\n        return !!this.restoreViewVariable;\n    }\n    notifyRestoredViewContextUse() {\n        this.usesRestoredViewContext = true;\n    }\n}\n/**\n * Creates a `CssSelector` given a tag name and a map of attributes\n */\nfunction createCssSelector(elementName, attributes) {\n    const cssSelector = new CssSelector();\n    const elementNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elementNameNoNs);\n    Object.getOwnPropertyNames(attributes).forEach((name) => {\n        const nameNoNs = splitNsName(name)[1];\n        const value = attributes[name];\n        cssSelector.addAttribute(nameNoNs, value);\n        if (name.toLowerCase() === 'class') {\n            const classes = value.trim().split(/\\s+/);\n            classes.forEach(className => cssSelector.addClassName(className));\n        }\n    });\n    return cssSelector;\n}\n/**\n * Creates an array of expressions out of an `ngProjectAs` attributes\n * which can be added to the instruction parameters.\n */\nfunction getNgProjectAsLiteral(attribute) {\n    // Parse the attribute value into a CssSelectorList. Note that we only take the\n    // first selector, because we don't support multiple selectors in ngProjectAs.\n    const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];\n    return [literal(5 /* ProjectAs */), asLiteral(parsedR3Selector)];\n}\n/**\n * Gets the instruction to generate for an interpolated property\n * @param interpolation An Interpolation AST\n */\nfunction getPropertyInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.propertyInterpolate;\n        case 3:\n            return Identifiers$1.propertyInterpolate1;\n        case 5:\n            return Identifiers$1.propertyInterpolate2;\n        case 7:\n            return Identifiers$1.propertyInterpolate3;\n        case 9:\n            return Identifiers$1.propertyInterpolate4;\n        case 11:\n            return Identifiers$1.propertyInterpolate5;\n        case 13:\n            return Identifiers$1.propertyInterpolate6;\n        case 15:\n            return Identifiers$1.propertyInterpolate7;\n        case 17:\n            return Identifiers$1.propertyInterpolate8;\n        default:\n            return Identifiers$1.propertyInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated attribute\n * @param interpolation An Interpolation AST\n */\nfunction getAttributeInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 3:\n            return Identifiers$1.attributeInterpolate1;\n        case 5:\n            return Identifiers$1.attributeInterpolate2;\n        case 7:\n            return Identifiers$1.attributeInterpolate3;\n        case 9:\n            return Identifiers$1.attributeInterpolate4;\n        case 11:\n            return Identifiers$1.attributeInterpolate5;\n        case 13:\n            return Identifiers$1.attributeInterpolate6;\n        case 15:\n            return Identifiers$1.attributeInterpolate7;\n        case 17:\n            return Identifiers$1.attributeInterpolate8;\n        default:\n            return Identifiers$1.attributeInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for interpolated text.\n * @param interpolation An Interpolation AST\n */\nfunction getTextInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers$1.textInterpolate;\n        case 3:\n            return Identifiers$1.textInterpolate1;\n        case 5:\n            return Identifiers$1.textInterpolate2;\n        case 7:\n            return Identifiers$1.textInterpolate3;\n        case 9:\n            return Identifiers$1.textInterpolate4;\n        case 11:\n            return Identifiers$1.textInterpolate5;\n        case 13:\n            return Identifiers$1.textInterpolate6;\n        case 15:\n            return Identifiers$1.textInterpolate7;\n        case 17:\n            return Identifiers$1.textInterpolate8;\n        default:\n            return Identifiers$1.textInterpolateV;\n    }\n}\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nfunction parseTemplate(template, templateUrl, options = {}) {\n    const { interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat } = options;\n    const bindingParser = makeBindingParser(interpolationConfig);\n    const htmlParser = new HtmlParser();\n    const parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({ leadingTriviaChars: LEADING_TRIVIA_CHARS }, options), { tokenizeExpansionForms: true }));\n    if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors &&\n        parseResult.errors.length > 0) {\n        const parsedTemplate = {\n            interpolationConfig,\n            preserveWhitespaces,\n            errors: parseResult.errors,\n            nodes: [],\n            styleUrls: [],\n            styles: [],\n            ngContentSelectors: []\n        };\n        if (options.collectCommentNodes) {\n            parsedTemplate.commentNodes = [];\n        }\n        return parsedTemplate;\n    }\n    let rootNodes = parseResult.rootNodes;\n    // process i18n meta information (scan attributes, generate ids)\n    // before we run whitespace removal process, because existing i18n\n    // extraction process (ng extract-i18n) relies on a raw content to generate\n    // message ids\n    const i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces, enableI18nLegacyMessageIdFormat);\n    const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n    if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors &&\n        i18nMetaResult.errors.length > 0) {\n        const parsedTemplate = {\n            interpolationConfig,\n            preserveWhitespaces,\n            errors: i18nMetaResult.errors,\n            nodes: [],\n            styleUrls: [],\n            styles: [],\n            ngContentSelectors: []\n        };\n        if (options.collectCommentNodes) {\n            parsedTemplate.commentNodes = [];\n        }\n        return parsedTemplate;\n    }\n    rootNodes = i18nMetaResult.rootNodes;\n    if (!preserveWhitespaces) {\n        rootNodes = visitAll(new WhitespaceVisitor(), rootNodes);\n        // run i18n meta visitor again in case whitespaces are removed (because that might affect\n        // generated i18n message content) and first pass indicated that i18n content is present in a\n        // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n        // mimic existing extraction process (ng extract-i18n)\n        if (i18nMetaVisitor.hasI18nMeta) {\n            rootNodes = visitAll(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);\n        }\n    }\n    const { nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes } = htmlAstToRender3Ast(rootNodes, bindingParser, { collectCommentNodes: !!options.collectCommentNodes });\n    errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n    const parsedTemplate = {\n        interpolationConfig,\n        preserveWhitespaces,\n        errors: errors.length > 0 ? errors : null,\n        nodes,\n        styleUrls,\n        styles,\n        ngContentSelectors\n    };\n    if (options.collectCommentNodes) {\n        parsedTemplate.commentNodes = commentNodes;\n    }\n    return parsedTemplate;\n}\nconst elementRegistry = new DomElementSchemaRegistry();\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nfunction makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n    return new BindingParser(new Parser$1(new Lexer()), interpolationConfig, elementRegistry, []);\n}\nfunction resolveSanitizationFn(context, isAttribute) {\n    switch (context) {\n        case SecurityContext.HTML:\n            return importExpr(Identifiers$1.sanitizeHtml);\n        case SecurityContext.SCRIPT:\n            return importExpr(Identifiers$1.sanitizeScript);\n        case SecurityContext.STYLE:\n            // the compiler does not fill in an instruction for [style.prop?] binding\n            // values because the style algorithm knows internally what props are subject\n            // to sanitization (only [attr.style] values are explicitly sanitized)\n            return isAttribute ? importExpr(Identifiers$1.sanitizeStyle) : null;\n        case SecurityContext.URL:\n            return importExpr(Identifiers$1.sanitizeUrl);\n        case SecurityContext.RESOURCE_URL:\n            return importExpr(Identifiers$1.sanitizeResourceUrl);\n        default:\n            return null;\n    }\n}\nfunction trustedConstAttribute(tagName, attr) {\n    const value = asLiteral(attr.value);\n    if (isTrustedTypesSink(tagName, attr.name)) {\n        switch (elementRegistry.securityContext(tagName, attr.name, /* isAttribute */ true)) {\n            case SecurityContext.HTML:\n                return taggedTemplate(importExpr(Identifiers$1.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n            // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.\n            case SecurityContext.RESOURCE_URL:\n                return taggedTemplate(importExpr(Identifiers$1.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n            default:\n                return value;\n        }\n    }\n    else {\n        return value;\n    }\n}\nfunction isSingleElementTemplate(children) {\n    return children.length === 1 && children[0] instanceof Element$1;\n}\nfunction isTextNode(node) {\n    return node instanceof Text$3 || node instanceof BoundText || node instanceof Icu$1;\n}\nfunction hasTextChildrenOnly(children) {\n    return children.every(isTextNode);\n}\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n/**\n * Generate statements that define a given translation message.\n *\n * ```\n * var I18N_1;\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\n *          \"Some message with {$interpolation}!\",\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n *     );\n *     I18N_1 = MSG_EXTERNAL_XXX;\n * }\n * else {\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n * }\n * ```\n *\n * @param message The original i18n AST message node\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n * @param params Object mapping placeholder names to their values (e.g.\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n * @param transformFn Optional transformation function that will be applied to the translation (e.g.\n * post-processing).\n * @returns An array of statements that defined a given translation.\n */\nfunction getTranslationDeclStmts(message, variable, closureVar, params = {}, transformFn) {\n    const statements = [\n        declareI18nVariable(variable),\n        ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, i18nFormatPlaceholderNames(params, /* useCamelCase */ true)), createLocalizeStatements(variable, message, i18nFormatPlaceholderNames(params, /* useCamelCase */ false))),\n    ];\n    if (transformFn) {\n        statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\n    }\n    return statements;\n}\n/**\n * Create the expression that will be used to guard the closure mode block\n * It is equivalent to:\n *\n * ```\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n * ```\n */\nfunction createClosureModeGuard() {\n    return typeofExpr(variable(NG_I18N_CLOSURE_MODE))\n        .notIdentical(literal('undefined', STRING_TYPE))\n        .and(variable(NG_I18N_CLOSURE_MODE));\n}\nfunction flatten(list) {\n    return list.reduce((flat, item) => {\n        const flatItem = Array.isArray(item) ? flatten(item) : item;\n        return flat.concat(flatItem);\n    }, []);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n// If there is a match, the first matching group will contain the attribute name to bind.\nconst ATTR_REGEX = /attr\\.([^\\]]+)/;\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\n    const definitionMap = new DefinitionMap();\n    const selectors = parseSelectorToR3Selector(meta.selector);\n    // e.g. `type: MyDirective`\n    definitionMap.set('type', meta.internalType);\n    // e.g. `selectors: [['', 'someDir', '']]`\n    if (selectors.length > 0) {\n        definitionMap.set('selectors', asLiteral(selectors));\n    }\n    if (meta.queries.length > 0) {\n        // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n        definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n    }\n    if (meta.viewQueries.length) {\n        definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n    }\n    // e.g. `hostBindings: (rf, ctx) => { ... }\n    definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));\n    // e.g 'inputs: {a: 'a'}`\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n    // e.g 'outputs: {a: 'a'}`\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n    if (meta.exportAs !== null) {\n        definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));\n    }\n    return definitionMap;\n}\n/**\n * Add features to the definition map.\n */\nfunction addFeatures(definitionMap, meta) {\n    // e.g. `features: [NgOnChangesFeature]`\n    const features = [];\n    const providers = meta.providers;\n    const viewProviders = meta.viewProviders;\n    if (providers || viewProviders) {\n        const args = [providers || new LiteralArrayExpr([])];\n        if (viewProviders) {\n            args.push(viewProviders);\n        }\n        features.push(importExpr(Identifiers$1.ProvidersFeature).callFn(args));\n    }\n    if (meta.usesInheritance) {\n        features.push(importExpr(Identifiers$1.InheritDefinitionFeature));\n    }\n    if (meta.fullInheritance) {\n        features.push(importExpr(Identifiers$1.CopyDefinitionFeature));\n    }\n    if (meta.lifecycle.usesOnChanges) {\n        features.push(importExpr(Identifiers$1.NgOnChangesFeature));\n    }\n    if (features.length) {\n        definitionMap.set('features', literalArr(features));\n    }\n}\n/**\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n */\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    const expression = importExpr(Identifiers$1.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createDirectiveType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n */\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\n    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    const selector = meta.selector && CssSelector.parse(meta.selector);\n    const firstSelector = selector && selector[0];\n    // e.g. `attr: [\"class\", \".my.app\"]`\n    // This is optional an only included if the first selector of a component specifies attributes.\n    if (firstSelector) {\n        const selectorAttributes = firstSelector.getAttrs();\n        if (selectorAttributes.length) {\n            definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), \n            /* forceShared */ true));\n        }\n    }\n    // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n    const templateTypeName = meta.name;\n    const templateName = templateTypeName ? `${templateTypeName}_Template` : null;\n    const changeDetection = meta.changeDetection;\n    const template = meta.template;\n    const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, Identifiers$1.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n    const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\n    // We need to provide this so that dynamically generated components know what\n    // projected content blocks to pass through to the component when it is instantiated.\n    const ngContentSelectors = templateBuilder.getNgContentSelectors();\n    if (ngContentSelectors) {\n        definitionMap.set('ngContentSelectors', ngContentSelectors);\n    }\n    // e.g. `decls: 2`\n    definitionMap.set('decls', literal(templateBuilder.getConstCount()));\n    // e.g. `vars: 2`\n    definitionMap.set('vars', literal(templateBuilder.getVarCount()));\n    // Generate `consts` section of ComponentDef:\n    // - either as an array:\n    //   `consts: [['one', 'two'], ['three', 'four']]`\n    // - or as a factory function in case additional statements are present (to support i18n):\n    //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`\n    const { constExpressions, prepareStatements } = templateBuilder.getConsts();\n    if (constExpressions.length > 0) {\n        let constsExpr = literalArr(constExpressions);\n        // Prepare statements are present - turn `consts` into a function.\n        if (prepareStatements.length > 0) {\n            constsExpr = fn([], [...prepareStatements, new ReturnStatement(constsExpr)]);\n        }\n        definitionMap.set('consts', constsExpr);\n    }\n    definitionMap.set('template', templateFunctionExpression);\n    // e.g. `directives: [MyDirective]`\n    if (meta.directives.length > 0) {\n        const directivesList = literalArr(meta.directives.map(dir => dir.type));\n        const directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);\n        definitionMap.set('directives', directivesExpr);\n    }\n    // e.g. `pipes: [MyPipe]`\n    if (meta.pipes.size > 0) {\n        const pipesList = literalArr(Array.from(meta.pipes.values()));\n        const pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);\n        definitionMap.set('pipes', pipesExpr);\n    }\n    if (meta.encapsulation === null) {\n        meta.encapsulation = ViewEncapsulation.Emulated;\n    }\n    // e.g. `styles: [str1, str2]`\n    if (meta.styles && meta.styles.length) {\n        const styleValues = meta.encapsulation == ViewEncapsulation.Emulated ?\n            compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :\n            meta.styles;\n        const strings = styleValues.map(str => constantPool.getConstLiteral(literal(str)));\n        definitionMap.set('styles', literalArr(strings));\n    }\n    else if (meta.encapsulation === ViewEncapsulation.Emulated) {\n        // If there is no style, don't generate css selectors on elements\n        meta.encapsulation = ViewEncapsulation.None;\n    }\n    // Only set view encapsulation if it's not the default value\n    if (meta.encapsulation !== ViewEncapsulation.Emulated) {\n        definitionMap.set('encapsulation', literal(meta.encapsulation));\n    }\n    // e.g. `animation: [trigger('123', [])]`\n    if (meta.animations !== null) {\n        definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));\n    }\n    // Only set the change detection flag if it's defined and it's not the default.\n    if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {\n        definitionMap.set('changeDetection', literal(changeDetection));\n    }\n    const expression = importExpr(Identifiers$1.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createComponentType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Creates the type specification from the component meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nfunction createComponentType(meta) {\n    const typeParams = createDirectiveTypeParams(meta);\n    typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n    return expressionType(importExpr(Identifiers$1.ComponentDeclaration, typeParams));\n}\n/**\n * Compiles the array literal of declarations into an expression according to the provided emit\n * mode.\n */\nfunction compileDeclarationList(list, mode) {\n    switch (mode) {\n        case 0 /* Direct */:\n            // directives: [MyDir],\n            return list;\n        case 1 /* Closure */:\n            // directives: function () { return [MyDir]; }\n            return fn([], [new ReturnStatement(list)]);\n        case 2 /* ClosureResolved */:\n            // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n            const resolvedList = list.prop('map').callFn([importExpr(Identifiers$1.resolveForwardRef)]);\n            return fn([], [new ReturnStatement(resolvedList)]);\n    }\n}\nfunction prepareQueryParams(query, constantPool) {\n    const parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];\n    if (query.read) {\n        parameters.push(query.read);\n    }\n    return parameters;\n}\n/**\n * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts\n * @param query\n */\nfunction toQueryFlags(query) {\n    return (query.descendants ? 1 /* descendants */ : 0 /* none */) |\n        (query.static ? 2 /* isStatic */ : 0 /* none */) |\n        (query.emitDistinctChangesOnly ? 4 /* emitDistinctChangesOnly */ : 0 /* none */);\n}\nfunction convertAttributesToExpressions(attributes) {\n    const values = [];\n    for (let key of Object.getOwnPropertyNames(attributes)) {\n        const value = attributes[key];\n        values.push(literal(key), value);\n    }\n    return values;\n}\n// Define and update any content queries\nfunction createContentQueriesFunction(queries, constantPool, name) {\n    const createStatements = [];\n    const updateStatements = [];\n    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    for (const query of queries) {\n        // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n        createStatements.push(importExpr(Identifiers$1.contentQuery)\n            .callFn([variable('dirIndex'), ...prepareQueryParams(query, constantPool)])\n            .toStmt());\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n        const temporary = tempAllocator();\n        const getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);\n        const refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);\n        const updateDirective = variable(CONTEXT_NAME)\n            .prop(query.propertyName)\n            .set(query.first ? temporary.prop('first') : temporary);\n        updateStatements.push(refresh.and(updateDirective).toStmt());\n    }\n    const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n    return fn([\n        new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),\n        new FnParam('dirIndex', null)\n    ], [\n        renderFlagCheckIfStmt(1 /* Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* Update */, updateStatements)\n    ], INFERRED_TYPE, null, contentQueriesFnName);\n}\nfunction stringAsType(str) {\n    return expressionType(literal(str));\n}\nfunction stringMapAsType(map) {\n    const mapValues = Object.keys(map).map(key => {\n        const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n        return {\n            key,\n            value: literal(value),\n            quoted: true,\n        };\n    });\n    return expressionType(literalMap(mapValues));\n}\nfunction stringArrayAsType(arr) {\n    return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) :\n        NONE_TYPE;\n}\nfunction createDirectiveTypeParams(meta) {\n    // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n    // string literal, which must be on one line.\n    const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n    return [\n        typeWithParameters(meta.type.type, meta.typeArgumentCount),\n        selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,\n        meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,\n        stringMapAsType(meta.inputs),\n        stringMapAsType(meta.outputs),\n        stringArrayAsType(meta.queries.map(q => q.propertyName)),\n    ];\n}\n/**\n * Creates the type specification from the directive meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nfunction createDirectiveType(meta) {\n    const typeParams = createDirectiveTypeParams(meta);\n    return expressionType(importExpr(Identifiers$1.DirectiveDeclaration, typeParams));\n}\n// Define and update any view queries\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\n    const createStatements = [];\n    const updateStatements = [];\n    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    viewQueries.forEach((query) => {\n        // creation, e.g. r3.viewQuery(somePredicate, true);\n        const queryDefinition = importExpr(Identifiers$1.viewQuery).callFn(prepareQueryParams(query, constantPool));\n        createStatements.push(queryDefinition.toStmt());\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n        const temporary = tempAllocator();\n        const getQueryList = importExpr(Identifiers$1.loadQuery).callFn([]);\n        const refresh = importExpr(Identifiers$1.queryRefresh).callFn([temporary.set(getQueryList)]);\n        const updateDirective = variable(CONTEXT_NAME)\n            .prop(query.propertyName)\n            .set(query.first ? temporary.prop('first') : temporary);\n        updateStatements.push(refresh.and(updateDirective).toStmt());\n    });\n    const viewQueryFnName = name ? `${name}_Query` : null;\n    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\n        renderFlagCheckIfStmt(1 /* Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* Update */, updateStatements)\n    ], INFERRED_TYPE, null, viewQueryFnName);\n}\n// Return a host binding function or null if one is not necessary.\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\n    const bindingContext = variable(CONTEXT_NAME);\n    const styleBuilder = new StylingBuilder(bindingContext);\n    const { styleAttr, classAttr } = hostBindingsMetadata.specialAttributes;\n    if (styleAttr !== undefined) {\n        styleBuilder.registerStyleAttr(styleAttr);\n    }\n    if (classAttr !== undefined) {\n        styleBuilder.registerClassAttr(classAttr);\n    }\n    const createStatements = [];\n    const updateStatements = [];\n    const hostBindingSourceSpan = typeSourceSpan;\n    // Calculate host event bindings\n    const eventBindings = bindingParser.createDirectiveHostEventAsts(hostBindingsMetadata.listeners, hostBindingSourceSpan);\n    if (eventBindings && eventBindings.length) {\n        const listeners = createHostListeners(eventBindings, name);\n        createStatements.push(...listeners);\n    }\n    // Calculate the host property bindings\n    const bindings = bindingParser.createBoundHostProperties(hostBindingsMetadata.properties, hostBindingSourceSpan);\n    const allOtherBindings = [];\n    // We need to calculate the total amount of binding slots required by\n    // all the instructions together before any value conversions happen.\n    // Value conversions may require additional slots for interpolation and\n    // bindings with pipes. These calculates happen after this block.\n    let totalHostVarsCount = 0;\n    bindings && bindings.forEach((binding) => {\n        const stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);\n        if (stylingInputWasSet) {\n            totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\n        }\n        else {\n            allOtherBindings.push(binding);\n            totalHostVarsCount++;\n        }\n    });\n    let valueConverter;\n    const getValueConverter = () => {\n        if (!valueConverter) {\n            const hostVarsCountFn = (numSlots) => {\n                const originalVarsCount = totalHostVarsCount;\n                totalHostVarsCount += numSlots;\n                return originalVarsCount;\n            };\n            valueConverter = new ValueConverter(constantPool, () => error('Unexpected node'), // new nodes are illegal here\n            hostVarsCountFn, () => error('Unexpected pipe')); // pipes are illegal here\n        }\n        return valueConverter;\n    };\n    const propertyBindings = [];\n    const attributeBindings = [];\n    const syntheticHostBindings = [];\n    allOtherBindings.forEach((binding) => {\n        // resolve literal arrays and literal objects\n        const value = binding.expression.visit(getValueConverter());\n        const bindingExpr = bindingFn(bindingContext, value);\n        const { bindingName, instruction, isAttribute } = getBindingNameAndInstruction(binding);\n        const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)\n            .filter(context => context !== SecurityContext.NONE);\n        let sanitizerFn = null;\n        if (securityContexts.length) {\n            if (securityContexts.length === 2 &&\n                securityContexts.indexOf(SecurityContext.URL) > -1 &&\n                securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {\n                // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n                // of different security contexts. In this case we use special sanitization function and\n                // select the actual sanitizer at runtime based on a tag name that is provided while\n                // invoking sanitization function.\n                sanitizerFn = importExpr(Identifiers$1.sanitizeUrlOrResourceUrl);\n            }\n            else {\n                sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\n            }\n        }\n        const instructionParams = [literal(bindingName), bindingExpr.currValExpr];\n        if (sanitizerFn) {\n            instructionParams.push(sanitizerFn);\n        }\n        updateStatements.push(...bindingExpr.stmts);\n        if (instruction === Identifiers$1.hostProperty) {\n            propertyBindings.push(instructionParams);\n        }\n        else if (instruction === Identifiers$1.attribute) {\n            attributeBindings.push(instructionParams);\n        }\n        else if (instruction === Identifiers$1.syntheticHostProperty) {\n            syntheticHostBindings.push(instructionParams);\n        }\n        else {\n            updateStatements.push(importExpr(instruction).callFn(instructionParams).toStmt());\n        }\n    });\n    if (propertyBindings.length > 0) {\n        updateStatements.push(chainedInstruction(Identifiers$1.hostProperty, propertyBindings).toStmt());\n    }\n    if (attributeBindings.length > 0) {\n        updateStatements.push(chainedInstruction(Identifiers$1.attribute, attributeBindings).toStmt());\n    }\n    if (syntheticHostBindings.length > 0) {\n        updateStatements.push(chainedInstruction(Identifiers$1.syntheticHostProperty, syntheticHostBindings).toStmt());\n    }\n    // since we're dealing with directives/components and both have hostBinding\n    // functions, we need to generate a special hostAttrs instruction that deals\n    // with both the assignment of styling as well as static attributes to the host\n    // element. The instruction below will instruct all initial styling (styling\n    // that is inside of a host binding within a directive/component) to be attached\n    // to the host element alongside any of the provided host attributes that were\n    // collected earlier.\n    const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n    styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\n    if (styleBuilder.hasBindings) {\n        // finally each binding that was registered in the statement above will need to be added to\n        // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n        // are evaluated and updated for the element.\n        styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {\n            if (instruction.calls.length > 0) {\n                const calls = [];\n                instruction.calls.forEach(call => {\n                    // we subtract a value of `1` here because the binding slot was already allocated\n                    // at the top of this method when all the input bindings were counted.\n                    totalHostVarsCount +=\n                        Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\n                    calls.push(convertStylingCall(call, bindingContext, bindingFn));\n                });\n                updateStatements.push(chainedInstruction(instruction.reference, calls).toStmt());\n            }\n        });\n    }\n    if (totalHostVarsCount) {\n        definitionMap.set('hostVars', literal(totalHostVarsCount));\n    }\n    if (createStatements.length > 0 || updateStatements.length > 0) {\n        const hostBindingsFnName = name ? `${name}_HostBindings` : null;\n        const statements = [];\n        if (createStatements.length > 0) {\n            statements.push(renderFlagCheckIfStmt(1 /* Create */, createStatements));\n        }\n        if (updateStatements.length > 0) {\n            statements.push(renderFlagCheckIfStmt(2 /* Update */, updateStatements));\n        }\n        return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);\n    }\n    return null;\n}\nfunction bindingFn(implicit, value) {\n    return convertPropertyBinding(null, implicit, value, 'b', () => error('Unexpected interpolation'));\n}\nfunction convertStylingCall(call, bindingContext, bindingFn) {\n    return call.params(value => bindingFn(bindingContext, value).currValExpr);\n}\nfunction getBindingNameAndInstruction(binding) {\n    let bindingName = binding.name;\n    let instruction;\n    // Check to see if this is an attr binding or a property binding\n    const attrMatches = bindingName.match(ATTR_REGEX);\n    if (attrMatches) {\n        bindingName = attrMatches[1];\n        instruction = Identifiers$1.attribute;\n    }\n    else {\n        if (binding.isAnimation) {\n            bindingName = prepareSyntheticPropertyName(bindingName);\n            // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n            // in the context of the component and not the parent. Therefore there is a special\n            // compatibility instruction available for this purpose.\n            instruction = Identifiers$1.syntheticHostProperty;\n        }\n        else {\n            instruction = Identifiers$1.hostProperty;\n        }\n    }\n    return { bindingName, instruction, isAttribute: !!attrMatches };\n}\nfunction createHostListeners(eventBindings, name) {\n    const listeners = [];\n    const syntheticListeners = [];\n    const instructions = [];\n    eventBindings.forEach(binding => {\n        let bindingName = binding.name && sanitizeIdentifier(binding.name);\n        const bindingFnName = binding.type === 1 /* Animation */ ?\n            prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :\n            bindingName;\n        const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;\n        const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\n        if (binding.type == 1 /* Animation */) {\n            syntheticListeners.push(params);\n        }\n        else {\n            listeners.push(params);\n        }\n    });\n    if (syntheticListeners.length > 0) {\n        instructions.push(chainedInstruction(Identifiers$1.syntheticHostListener, syntheticListeners).toStmt());\n    }\n    if (listeners.length > 0) {\n        instructions.push(chainedInstruction(Identifiers$1.listener, listeners).toStmt());\n    }\n    return instructions;\n}\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\nfunction parseHostBindings(host) {\n    const attributes = {};\n    const listeners = {};\n    const properties = {};\n    const specialAttributes = {};\n    for (const key of Object.keys(host)) {\n        const value = host[key];\n        const matches = key.match(HOST_REG_EXP);\n        if (matches === null) {\n            switch (key) {\n                case 'class':\n                    if (typeof value !== 'string') {\n                        // TODO(alxhub): make this a diagnostic.\n                        throw new Error(`Class binding must be string`);\n                    }\n                    specialAttributes.classAttr = value;\n                    break;\n                case 'style':\n                    if (typeof value !== 'string') {\n                        // TODO(alxhub): make this a diagnostic.\n                        throw new Error(`Style binding must be string`);\n                    }\n                    specialAttributes.styleAttr = value;\n                    break;\n                default:\n                    if (typeof value === 'string') {\n                        attributes[key] = literal(value);\n                    }\n                    else {\n                        attributes[key] = value;\n                    }\n            }\n        }\n        else if (matches[1 /* Binding */] != null) {\n            if (typeof value !== 'string') {\n                // TODO(alxhub): make this a diagnostic.\n                throw new Error(`Property binding must be string`);\n            }\n            // synthetic properties (the ones that have a `@` as a prefix)\n            // are still treated the same as regular properties. Therefore\n            // there is no point in storing them in a separate map.\n            properties[matches[1 /* Binding */]] = value;\n        }\n        else if (matches[2 /* Event */] != null) {\n            if (typeof value !== 'string') {\n                // TODO(alxhub): make this a diagnostic.\n                throw new Error(`Event binding must be string`);\n            }\n            listeners[matches[2 /* Event */]] = value;\n        }\n    }\n    return { attributes, listeners, properties, specialAttributes };\n}\n/**\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n * given set of host bindings has no errors.\n *\n * @param bindings set of host bindings to verify.\n * @param sourceSpan source span where host bindings were defined.\n * @returns array of errors associated with a given set of host bindings.\n */\nfunction verifyHostBindings(bindings, sourceSpan) {\n    // TODO: abstract out host bindings verification logic and use it instead of\n    // creating events and properties ASTs to detect errors (FW-996)\n    const bindingParser = makeBindingParser();\n    bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n    bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n    return bindingParser.errors;\n}\nfunction compileStyles(styles, selector, hostSelector) {\n    const shadowCss = new ShadowCss();\n    return styles.map(style => {\n        return shadowCss.shimCssText(style, selector, hostSelector);\n    });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An interface for retrieving documents by URL that the compiler uses to\n * load templates.\n *\n * This is an abstract class, rather than an interface, so that it can be used\n * as injection token.\n */\nclass ResourceLoader {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass CompilerFacadeImpl {\n    constructor(jitEvaluator = new JitEvaluator()) {\n        this.jitEvaluator = jitEvaluator;\n        this.FactoryTarget = FactoryTarget$1;\n        this.ResourceLoader = ResourceLoader;\n        this.elementSchemaRegistry = new DomElementSchemaRegistry();\n    }\n    compilePipe(angularCoreEnv, sourceMapUrl, facade) {\n        const metadata = {\n            name: facade.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: 0,\n            deps: null,\n            pipeName: facade.pipeName,\n            pure: facade.pure,\n        };\n        const res = compilePipeFromMetadata(metadata);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const meta = convertDeclarePipeFacadeToMetadata(declaration);\n        const res = compilePipeFromMetadata(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileInjectable(angularCoreEnv, sourceMapUrl, facade) {\n        var _a;\n        const { expression, statements } = compileInjectable({\n            name: facade.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: facade.typeArgumentCount,\n            providedIn: computeProvidedIn(facade.providedIn),\n            useClass: convertToProviderExpression(facade, USE_CLASS),\n            useFactory: wrapExpression(facade, USE_FACTORY),\n            useValue: convertToProviderExpression(facade, USE_VALUE),\n            useExisting: convertToProviderExpression(facade, USE_EXISTING),\n            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DependencyMetadata),\n        }, \n        /* resolveForwardRefs */ true);\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    }\n    compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {\n        var _a;\n        const { expression, statements } = compileInjectable({\n            name: facade.type.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: 0,\n            providedIn: computeProvidedIn(facade.providedIn),\n            useClass: convertToProviderExpression(facade, USE_CLASS),\n            useFactory: wrapExpression(facade, USE_FACTORY),\n            useValue: convertToProviderExpression(facade, USE_VALUE),\n            useExisting: convertToProviderExpression(facade, USE_EXISTING),\n            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DeclareDependencyMetadata),\n        }, \n        /* resolveForwardRefs */ true);\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    }\n    compileInjector(angularCoreEnv, sourceMapUrl, facade) {\n        const meta = {\n            name: facade.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            providers: new WrappedNodeExpr(facade.providers),\n            imports: facade.imports.map(i => new WrappedNodeExpr(i)),\n        };\n        const res = compileInjector(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const meta = convertDeclareInjectorFacadeToMetadata(declaration);\n        const res = compileInjector(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileNgModule(angularCoreEnv, sourceMapUrl, facade) {\n        const meta = {\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            adjacentType: new WrappedNodeExpr(facade.type),\n            bootstrap: facade.bootstrap.map(wrapReference),\n            declarations: facade.declarations.map(wrapReference),\n            imports: facade.imports.map(wrapReference),\n            exports: facade.exports.map(wrapReference),\n            emitInline: true,\n            containsForwardDecls: false,\n            schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n            id: facade.id ? new WrappedNodeExpr(facade.id) : null,\n        };\n        const res = compileNgModule(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const expression = compileNgModuleDeclarationExpression(declaration);\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileDirective(angularCoreEnv, sourceMapUrl, facade) {\n        const meta = convertDirectiveFacadeToMetadata(facade);\n        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n    compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n        const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n    compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n        const constantPool = new ConstantPool();\n        const bindingParser = makeBindingParser();\n        const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    }\n    compileComponent(angularCoreEnv, sourceMapUrl, facade) {\n        // Parse the template and check for errors.\n        const { template, interpolation } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation);\n        // Compile the component metadata, including template, into an expression.\n        const meta = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template, declarationListEmitMode: 0 /* Direct */, styles: [...facade.styles, ...template.styles], encapsulation: facade.encapsulation, interpolation, changeDetection: facade.changeDetection, animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :\n                null, relativeContextFilePath: '', i18nUseExternalIds: true });\n        const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n        return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n    }\n    compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n        const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n        return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n    compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n        const constantPool = new ConstantPool();\n        const bindingParser = makeBindingParser(meta.interpolation);\n        const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    }\n    compileFactory(angularCoreEnv, sourceMapUrl, meta) {\n        const factoryRes = compileFactoryFunction({\n            name: meta.name,\n            type: wrapReference(meta.type),\n            internalType: new WrappedNodeExpr(meta.type),\n            typeArgumentCount: meta.typeArgumentCount,\n            deps: convertR3DependencyMetadataArray(meta.deps),\n            target: meta.target,\n        });\n        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    }\n    compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {\n        const factoryRes = compileFactoryFunction({\n            name: meta.type.name,\n            type: wrapReference(meta.type),\n            internalType: new WrappedNodeExpr(meta.type),\n            typeArgumentCount: 0,\n            deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) :\n                meta.deps,\n            target: meta.target,\n        });\n        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    }\n    createParseSourceSpan(kind, typeName, sourceUrl) {\n        return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n    }\n    /**\n     * JIT compiles an expression and returns the result of executing that expression.\n     *\n     * @param def the definition which will be compiled and executed to get the value to patch\n     * @param context an object map of @angular/core symbol names to symbols which will be available\n     * in the context of the compiled expression\n     * @param sourceUrl a URL to use for the source map of the compiled expression\n     * @param preStatements a collection of statements that should be evaluated before the expression.\n     */\n    jitExpression(def, context, sourceUrl, preStatements) {\n        // The ConstantPool may contain Statements which declare variables used in the final expression.\n        // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n        // declaration of $def which is set to the expression being compiled.\n        const statements = [\n            ...preStatements,\n            new DeclareVarStmt('$def', def, undefined, StmtModifier.Exported),\n        ];\n        const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);\n        return res['$def'];\n    }\n}\nconst USE_CLASS = Object.keys({ useClass: null })[0];\nconst USE_FACTORY = Object.keys({ useFactory: null })[0];\nconst USE_VALUE = Object.keys({ useValue: null })[0];\nconst USE_EXISTING = Object.keys({ useExisting: null })[0];\nfunction convertToR3QueryMetadata(facade) {\n    return Object.assign(Object.assign({}, facade), { predicate: convertQueryPredicate(facade.predicate), read: facade.read ? new WrappedNodeExpr(facade.read) : null, static: facade.static, emitDistinctChangesOnly: facade.emitDistinctChangesOnly });\n}\nfunction convertQueryDeclarationToMetadata(declaration) {\n    var _a, _b, _c, _d;\n    return {\n        propertyName: declaration.propertyName,\n        first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,\n        predicate: convertQueryPredicate(declaration.predicate),\n        descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,\n        read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n        static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,\n        emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true,\n    };\n}\nfunction convertQueryPredicate(predicate) {\n    return Array.isArray(predicate) ?\n        // The predicate is an array of strings so pass it through.\n        predicate :\n        // The predicate is a type - assume that we will need to unwrap any `forwardRef()` calls.\n        createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), 1 /* Wrapped */);\n}\nfunction convertDirectiveFacadeToMetadata(facade) {\n    const inputsFromMetadata = parseInputOutputs(facade.inputs || []);\n    const outputsFromMetadata = parseInputOutputs(facade.outputs || []);\n    const propMetadata = facade.propMetadata;\n    const inputsFromType = {};\n    const outputsFromType = {};\n    for (const field in propMetadata) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(ann => {\n                if (isInput(ann)) {\n                    inputsFromType[field] =\n                        ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\n                }\n                else if (isOutput(ann)) {\n                    outputsFromType[field] = ann.bindingPropertyName || field;\n                }\n            });\n        }\n    }\n    return Object.assign(Object.assign({}, facade), { typeArgumentCount: 0, typeSourceSpan: facade.typeSourceSpan, type: wrapReference(facade.type), internalType: new WrappedNodeExpr(facade.type), deps: null, host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host), inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType), outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata), fullInheritance: false });\n}\nfunction convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    return {\n        name: declaration.type.name,\n        type: wrapReference(declaration.type),\n        typeSourceSpan,\n        internalType: new WrappedNodeExpr(declaration.type),\n        selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,\n        inputs: (_b = declaration.inputs) !== null && _b !== void 0 ? _b : {},\n        outputs: (_c = declaration.outputs) !== null && _c !== void 0 ? _c : {},\n        host: convertHostDeclarationToMetadata(declaration.host),\n        queries: ((_d = declaration.queries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),\n        viewQueries: ((_e = declaration.viewQueries) !== null && _e !== void 0 ? _e : []).map(convertQueryDeclarationToMetadata),\n        providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\n            null,\n        exportAs: (_f = declaration.exportAs) !== null && _f !== void 0 ? _f : null,\n        usesInheritance: (_g = declaration.usesInheritance) !== null && _g !== void 0 ? _g : false,\n        lifecycle: { usesOnChanges: (_h = declaration.usesOnChanges) !== null && _h !== void 0 ? _h : false },\n        deps: null,\n        typeArgumentCount: 0,\n        fullInheritance: false,\n    };\n}\nfunction convertHostDeclarationToMetadata(host = {}) {\n    var _a, _b, _c;\n    return {\n        attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),\n        listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},\n        properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},\n        specialAttributes: {\n            classAttr: host.classAttribute,\n            styleAttr: host.styleAttribute,\n        },\n    };\n}\nfunction convertOpaqueValuesToExpressions(obj) {\n    const result = {};\n    for (const key of Object.keys(obj)) {\n        result[key] = new WrappedNodeExpr(obj[key]);\n    }\n    return result;\n}\nfunction convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl) {\n    var _a, _b, _c, _d, _e, _f;\n    const { template, interpolation } = parseJitTemplate(declaration.template, declaration.type.name, sourceMapUrl, (_a = declaration.preserveWhitespaces) !== null && _a !== void 0 ? _a : false, declaration.interpolation);\n    return Object.assign(Object.assign({}, convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan)), { template, styles: (_b = declaration.styles) !== null && _b !== void 0 ? _b : [], directives: ((_c = declaration.components) !== null && _c !== void 0 ? _c : [])\n            .concat((_d = declaration.directives) !== null && _d !== void 0 ? _d : [])\n            .map(convertUsedDirectiveDeclarationToMetadata), pipes: convertUsedPipesToMetadata(declaration.pipes), viewProviders: declaration.viewProviders !== undefined ?\n            new WrappedNodeExpr(declaration.viewProviders) :\n            null, animations: declaration.animations !== undefined ? new WrappedNodeExpr(declaration.animations) :\n            null, changeDetection: (_e = declaration.changeDetection) !== null && _e !== void 0 ? _e : ChangeDetectionStrategy.Default, encapsulation: (_f = declaration.encapsulation) !== null && _f !== void 0 ? _f : ViewEncapsulation.Emulated, interpolation, declarationListEmitMode: 2 /* ClosureResolved */, relativeContextFilePath: '', i18nUseExternalIds: true });\n}\nfunction convertUsedDirectiveDeclarationToMetadata(declaration) {\n    var _a, _b, _c;\n    return {\n        selector: declaration.selector,\n        type: new WrappedNodeExpr(declaration.type),\n        inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],\n        outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],\n        exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null,\n    };\n}\nfunction convertUsedPipesToMetadata(declaredPipes) {\n    const pipes = new Map();\n    if (declaredPipes === undefined) {\n        return pipes;\n    }\n    for (const pipeName of Object.keys(declaredPipes)) {\n        const pipeType = declaredPipes[pipeName];\n        pipes.set(pipeName, new WrappedNodeExpr(pipeType));\n    }\n    return pipes;\n}\nfunction parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {\n    const interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;\n    // Parse the template and check for errors.\n    const parsed = parseTemplate(template, sourceMapUrl, { preserveWhitespaces, interpolationConfig });\n    if (parsed.errors !== null) {\n        const errors = parsed.errors.map(err => err.toString()).join(', ');\n        throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n    }\n    return { template: parsed, interpolation: interpolationConfig };\n}\n/**\n * Convert the expression, if present to an `R3ProviderExpression`.\n *\n * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,\n * if it is referencing a type that has not yet been defined, it will have already been wrapped in\n * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can\n * use `ForwardRefHandling.None`.\n */\nfunction convertToProviderExpression(obj, property) {\n    if (obj.hasOwnProperty(property)) {\n        return createMayBeForwardRefExpression(new WrappedNodeExpr(obj[property]), 0 /* None */);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction wrapExpression(obj, property) {\n    if (obj.hasOwnProperty(property)) {\n        return new WrappedNodeExpr(obj[property]);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction computeProvidedIn(providedIn) {\n    const expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) :\n        new LiteralExpr(providedIn !== null && providedIn !== void 0 ? providedIn : null);\n    // See `convertToProviderExpression()` for why this uses `ForwardRefHandling.None`.\n    return createMayBeForwardRefExpression(expression, 0 /* None */);\n}\nfunction convertR3DependencyMetadataArray(facades) {\n    return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\nfunction convertR3DependencyMetadata(facade) {\n    const isAttributeDep = facade.attribute != null; // both `null` and `undefined`\n    const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n    // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in\n    // `attribute` rather than the `token`.\n    const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n    return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\n}\nfunction convertR3DeclareDependencyMetadata(facade) {\n    var _a, _b, _c, _d, _e;\n    const isAttributeDep = (_a = facade.attribute) !== null && _a !== void 0 ? _a : false;\n    const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n    return createR3DependencyMetadata(token, isAttributeDep, (_b = facade.host) !== null && _b !== void 0 ? _b : false, (_c = facade.optional) !== null && _c !== void 0 ? _c : false, (_d = facade.self) !== null && _d !== void 0 ? _d : false, (_e = facade.skipSelf) !== null && _e !== void 0 ? _e : false);\n}\nfunction createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {\n    // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.\n    // But types are not available at runtime so we just use a literal `\"<unknown>\"` string as a dummy\n    // marker.\n    const attributeNameType = isAttributeDep ? literal('unknown') : null;\n    return { token, attributeNameType, host, optional, self, skipSelf };\n}\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\n    // First parse the declarations from the metadata.\n    const bindings = parseHostBindings(host || {});\n    // After that check host bindings for errors\n    const errors = verifyHostBindings(bindings, sourceSpan);\n    if (errors.length) {\n        throw new Error(errors.map((error) => error.msg).join('\\n'));\n    }\n    // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n    for (const field in propMetadata) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(ann => {\n                if (isHostBinding(ann)) {\n                    // Since this is a decorator, we know that the value is a class member. Always access it\n                    // through `this` so that further down the line it can't be confused for a literal value\n                    // (e.g. if there's a property called `true`).\n                    bindings.properties[ann.hostPropertyName || field] =\n                        getSafePropertyAccessString('this', field);\n                }\n                else if (isHostListener(ann)) {\n                    bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n                }\n            });\n        }\n    }\n    return bindings;\n}\nfunction isHostBinding(value) {\n    return value.ngMetadataName === 'HostBinding';\n}\nfunction isHostListener(value) {\n    return value.ngMetadataName === 'HostListener';\n}\nfunction isInput(value) {\n    return value.ngMetadataName === 'Input';\n}\nfunction isOutput(value) {\n    return value.ngMetadataName === 'Output';\n}\nfunction parseInputOutputs(values) {\n    return values.reduce((map, value) => {\n        const [field, property] = value.split(',').map(piece => piece.trim());\n        map[field] = property || field;\n        return map;\n    }, {});\n}\nfunction convertDeclarePipeFacadeToMetadata(declaration) {\n    var _a;\n    return {\n        name: declaration.type.name,\n        type: wrapReference(declaration.type),\n        internalType: new WrappedNodeExpr(declaration.type),\n        typeArgumentCount: 0,\n        pipeName: declaration.name,\n        deps: null,\n        pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true,\n    };\n}\nfunction convertDeclareInjectorFacadeToMetadata(declaration) {\n    return {\n        name: declaration.type.name,\n        type: wrapReference(declaration.type),\n        internalType: new WrappedNodeExpr(declaration.type),\n        providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\n            null,\n        imports: declaration.imports !== undefined ?\n            declaration.imports.map(i => new WrappedNodeExpr(i)) :\n            [],\n    };\n}\nfunction publishFacade(global) {\n    const ng = global.ng || (global.ng = {});\n    ng.compilerFacade = new CompilerFacadeImpl();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst VERSION = new Version('13.1.3');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass CompilerConfig {\n    constructor({ defaultEncapsulation = ViewEncapsulation.Emulated, useJit = true, jitDevMode = false, missingTranslation = null, preserveWhitespaces, strictInjectionParameters } = {}) {\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = !!useJit;\n        this.jitDevMode = !!jitDevMode;\n        this.missingTranslation = missingTranslation;\n        this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n        this.strictInjectionParameters = strictInjectionParameters === true;\n    }\n}\nfunction preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {\n    return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\n/**\n * Extract translatable messages from an html AST\n */\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    const visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    const visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nclass ExtractionResult {\n    constructor(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n}\nvar _VisitorMode;\n(function (_VisitorMode) {\n    _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n    _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n})(_VisitorMode || (_VisitorMode = {}));\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass _Visitor {\n    constructor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     */\n    extract(nodes, interpolationConfig) {\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(node => node.visit(this, null));\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    }\n    /**\n     * Returns a tree where all translatable nodes are translated\n     */\n    merge(nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        const wrapper = new Element('wrapper', [], nodes, undefined, undefined, undefined);\n        const translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    }\n    visitExpansionCase(icuCase, context) {\n        // Parse cases for translatable html attributes\n        const expression = visitAll(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    }\n    visitExpansion(icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        const wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        const cases = visitAll(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    }\n    visitComment(comment, context) {\n        const isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        const isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n                    if (!i18nCommentsWarned && console && console.warn) {\n                        i18nCommentsWarned = true;\n                        const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n                        // TODO(ocombe): use a log service once there is a public one available\n                        console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`);\n                    }\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc =\n                        comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n                        // merge attributes in sections\n                        const nodes = this._translateMessage(comment, message);\n                        return visitAll(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    visitText(text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    }\n    visitElement(el, context) {\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        const wasInI18nNode = this._inI18nNode;\n        const wasInImplicitNode = this._inImplicitNode;\n        let childNodes = [];\n        let translatedChildNodes = undefined;\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        const i18nAttr = _getI18nAttr(el);\n        const i18nMeta = i18nAttr ? i18nAttr.value : '';\n        const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                const message = this._addMessage(el.children, i18nMeta);\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                const isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                visitAll(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                visitAll(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            const visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(child => {\n                const visited = child.visit(this, context);\n                if (visited && !this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            const translatedAttrs = this._translateAttributes(el);\n            return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n        return null;\n    }\n    visitAttribute(attribute, context) {\n        throw new Error('unreachable code');\n    }\n    _init(mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = undefined;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    }\n    // looks for translatable attributes\n    _visitAttributesOf(el) {\n        const explicitAttrNameToValue = {};\n        const implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(attr => attr.name.startsWith(_I18N_ATTR_PREFIX))\n            .forEach(attr => explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value);\n        el.attrs.forEach(attr => {\n            if (attr.name in explicitAttrNameToValue) {\n                this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(name => attr.name === name)) {\n                this._addMessage([attr]);\n            }\n        });\n    }\n    // add a translatable message\n    _addMessage(ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {\n            // Do not create empty messages\n            return null;\n        }\n        const { meaning, description, id } = _parseMessageMeta(msgMeta);\n        const message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    }\n    // Translates the given message given the `TranslationBundle`\n    // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n    // no-op when called in extraction mode (returns [])\n    _translateMessage(el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            const nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n        }\n        return [];\n    }\n    // translate the attributes of an element and remove i18n specific attributes\n    _translateAttributes(el) {\n        const attributes = el.attrs;\n        const i18nParsedMessageMeta = {};\n        attributes.forEach(attr => {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        const translatedAttributes = [];\n        attributes.forEach((attr) => {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                const { meaning, description, id } = i18nParsedMessageMeta[attr.name];\n                const message = this._createI18nMessage([attr], meaning, description, id);\n                const nodes = this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */));\n                    }\n                    else if (nodes[0] instanceof Text) {\n                        const value = nodes[0].value;\n                        translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */));\n                    }\n                    else {\n                        this._reportError(el, `Unexpected translation for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n                    }\n                }\n                else {\n                    this._reportError(el, `Translation unavailable for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    }\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     */\n    _mayBeAddBlockChildren(node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    }\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     */\n    _openTranslatableSection(node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    }\n    /**\n     * A translatable section could be:\n     * - the content of translatable element,\n     * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n     */\n    get _isInTranslatableSection() {\n        return this._msgCountAtSectionStart !== void 0;\n    }\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     */\n    _closeTranslatableSection(node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        const startIndex = this._msgCountAtSectionStart;\n        const significantChildren = directChildren.reduce((count, node) => count + (node instanceof Comment ? 0 : 1), 0);\n        if (significantChildren == 1) {\n            for (let i = this._messages.length - 1; i >= startIndex; i--) {\n                const ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof Text$2)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = undefined;\n    }\n    _reportError(node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    }\n}\nfunction _isOpeningComment(n) {\n    return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\nfunction _isClosingComment(n) {\n    return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\nfunction _getI18nAttr(p) {\n    return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    const idIndex = i18n.indexOf(ID_SEPARATOR);\n    const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    const [meaningAndDesc, id] = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n    const [meaning, description] = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc];\n    return { meaning, description, id: id.trim() };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass XmlTagDefinition {\n    constructor() {\n        this.closedByParent = false;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n        this.preventNamespaceInheritance = false;\n    }\n    requireExtraParent(currentParent) {\n        return false;\n    }\n    isClosedByChild(name) {\n        return false;\n    }\n    getContentType() {\n        return TagContentType.PARSABLE_DATA;\n    }\n}\nconst _TAG_DEFINITION = new XmlTagDefinition();\nfunction getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass XmlParser extends Parser {\n    constructor() {\n        super(getXmlTagDefinition);\n    }\n    parse(source, url, options) {\n        return super.parse(source, url, options);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _VERSION$1 = '1.2';\nconst _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG$1 = 'en';\nconst _PLACEHOLDER_TAG$2 = 'x';\nconst _MARKER_TAG$1 = 'mrk';\nconst _FILE_TAG = 'file';\nconst _SOURCE_TAG$1 = 'source';\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\nconst _ALT_TRANS_TAG = 'alt-trans';\nconst _TARGET_TAG$1 = 'target';\nconst _UNIT_TAG$1 = 'trans-unit';\nconst _CONTEXT_GROUP_TAG = 'context-group';\nconst _CONTEXT_TAG = 'context';\n// https://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// https://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nclass Xliff extends Serializer {\n    write(messages, locale) {\n        const visitor = new _WriteVisitor$1();\n        const transUnits = [];\n        messages.forEach(message => {\n            let contextTags = [];\n            message.sources.forEach((source) => {\n                let contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });\n                contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new Text$1(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new Text$1(`${source.startLine}`)]), new CR(8));\n                contextTags.push(new CR(8), contextGroupTag);\n            });\n            const transUnit = new Tag(_UNIT_TAG$1, { id: message.id, datatype: 'html' });\n            transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), ...contextTags);\n            if (message.description) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$1(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$1(message.meaning)]));\n            }\n            transUnit.children.push(new CR(6));\n            transUnits.push(new CR(6), transUnit);\n        });\n        const body = new Tag('body', {}, [...transUnits, new CR(4)]);\n        const file = new Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG$1,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new CR(4), body, new CR(2)]);\n        const xliff = new Tag('xliff', { version: _VERSION$1, xmlns: _XMLNS$1 }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    }\n    load(content, url) {\n        // xliff to xml nodes\n        const xliffParser = new XliffParser();\n        const { locale, msgIdToHtml, errors } = xliffParser.parse(content, url);\n        // xml nodes to i18n nodes\n        const i18nNodesByMsgId = {};\n        const converter = new XmlToI18n$2();\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\n            errors.push(...e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: locale, i18nNodesByMsgId };\n    }\n    digest(message) {\n        return digest$1(message);\n    }\n}\nclass _WriteVisitor$1 {\n    visitText(text, context) {\n        return [new Text$1(text.value)];\n    }\n    visitContainer(container, context) {\n        const nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    visitIcu(icu, context) {\n        const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n        });\n        nodes.push(new Text$1(`}`));\n        return nodes;\n    }\n    visitTagPlaceholder(ph, context) {\n        const ctype = getCtypeForTag(ph.tag);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [new Tag(_PLACEHOLDER_TAG$2, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}/>` })];\n        }\n        const startTagPh = new Tag(_PLACEHOLDER_TAG$2, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}>` });\n        const closeTagPh = new Tag(_PLACEHOLDER_TAG$2, { id: ph.closeName, ctype, 'equiv-text': `</${ph.tag}>` });\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n    }\n    visitPlaceholder(ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$2, { id: ph.name, 'equiv-text': `{{${ph.value}}}` })];\n    }\n    visitIcuPlaceholder(ph, context) {\n        const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ')}}`;\n        return [new Tag(_PLACEHOLDER_TAG$2, { id: ph.name, 'equiv-text': equivText })];\n    }\n    serialize(nodes) {\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\n// TODO(vicb): add error management (structure)\n// Extract messages as xml nodes from the xliff file\nclass XliffParser {\n    constructor() {\n        this._locale = null;\n    }\n    parse(xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        const xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    visitElement(element, context) {\n        switch (element.name) {\n            case _UNIT_TAG$1:\n                this._unitMlString = null;\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_UNIT_TAG$1}> misses the \"id\" attribute`);\n                }\n                else {\n                    const id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, `Message ${id} misses a translation`);\n                        }\n                    }\n                }\n                break;\n            // ignore those tags\n            case _SOURCE_TAG$1:\n            case _SEGMENT_SOURCE_TAG:\n            case _ALT_TRANS_TAG:\n                break;\n            case _TARGET_TAG$1:\n                const innerTextStart = element.startSourceSpan.end.offset;\n                const innerTextEnd = element.endSourceSpan.start.offset;\n                const content = element.startSourceSpan.start.file.content;\n                const innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _FILE_TAG:\n                const localeAttr = element.attrs.find((attr) => attr.name === 'target-language');\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                visitAll(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                visitAll(this, element.children, null);\n        }\n    }\n    visitAttribute(attribute, context) { }\n    visitText(text, context) { }\n    visitComment(comment, context) { }\n    visitExpansion(expansion, context) { }\n    visitExpansionCase(expansionCase, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n$2 {\n    convert(message, url) {\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            [].concat(...visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    }\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitElement(el, context) {\n        if (el.name === _PLACEHOLDER_TAG$2) {\n            const nameAttr = el.attrs.find((attr) => attr.name === 'id');\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the \"id\" attribute`);\n            return null;\n        }\n        if (el.name === _MARKER_TAG$1) {\n            return [].concat(...visitAll(this, el.children));\n        }\n        this._addError(el, `Unexpected tag`);\n        return null;\n    }\n    visitExpansion(icu, context) {\n        const caseMap = {};\n        visitAll(this, icu.cases).forEach((c) => {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    }\n    visitComment(comment, context) { }\n    visitAttribute(attribute, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return `x-${tag}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _VERSION = '2.0';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG$1 = 'ph';\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst _MARKER_TAG = 'mrk';\nconst _XLIFF_TAG = 'xliff';\nconst _SOURCE_TAG = 'source';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'unit';\n// https://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nclass Xliff2 extends Serializer {\n    write(messages, locale) {\n        const visitor = new _WriteVisitor();\n        const units = [];\n        messages.forEach(message => {\n            const unit = new Tag(_UNIT_TAG, { id: message.id });\n            const notes = new Tag('notes');\n            if (message.description || message.meaning) {\n                if (message.description) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$1(message.description)]));\n                }\n                if (message.meaning) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$1(message.meaning)]));\n                }\n            }\n            message.sources.forEach((source) => {\n                notes.children.push(new CR(8), new Tag('note', { category: 'location' }, [\n                    new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)\n                ]));\n            });\n            notes.children.push(new CR(6));\n            unit.children.push(new CR(6), notes);\n            const segment = new Tag('segment');\n            segment.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(6));\n            unit.children.push(new CR(6), segment, new CR(4));\n            units.push(new CR(4), unit);\n        });\n        const file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, [...units, new CR(2)]);\n        const xliff = new Tag(_XLIFF_TAG, { version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    }\n    load(content, url) {\n        // xliff to xml nodes\n        const xliff2Parser = new Xliff2Parser();\n        const { locale, msgIdToHtml, errors } = xliff2Parser.parse(content, url);\n        // xml nodes to i18n nodes\n        const i18nNodesByMsgId = {};\n        const converter = new XmlToI18n$1();\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\n            errors.push(...e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: locale, i18nNodesByMsgId };\n    }\n    digest(message) {\n        return decimalDigest(message);\n    }\n}\nclass _WriteVisitor {\n    visitText(text, context) {\n        return [new Text$1(text.value)];\n    }\n    visitContainer(container, context) {\n        const nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    visitIcu(icu, context) {\n        const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n        });\n        nodes.push(new Text$1(`}`));\n        return nodes;\n    }\n    visitTagPlaceholder(ph, context) {\n        const type = getTypeForTag(ph.tag);\n        if (ph.isVoid) {\n            const tagPh = new Tag(_PLACEHOLDER_TAG$1, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.startName,\n                type: type,\n                disp: `<${ph.tag}/>`,\n            });\n            return [tagPh];\n        }\n        const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n            id: (this._nextPlaceholderId++).toString(),\n            equivStart: ph.startName,\n            equivEnd: ph.closeName,\n            type: type,\n            dispStart: `<${ph.tag}>`,\n            dispEnd: `</${ph.tag}>`,\n        });\n        const nodes = [].concat(...ph.children.map(node => node.visit(this)));\n        if (nodes.length) {\n            nodes.forEach((node) => tagPc.children.push(node));\n        }\n        else {\n            tagPc.children.push(new Text$1(''));\n        }\n        return [tagPc];\n    }\n    visitPlaceholder(ph, context) {\n        const idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$1, {\n                id: idStr,\n                equiv: ph.name,\n                disp: `{{${ph.value}}}`,\n            })];\n    }\n    visitIcuPlaceholder(ph, context) {\n        const cases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');\n        const idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: idStr, equiv: ph.name, disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}` })];\n    }\n    serialize(nodes) {\n        this._nextPlaceholderId = 0;\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\n// Extract messages as xml nodes from the xliff file\nclass Xliff2Parser {\n    constructor() {\n        this._locale = null;\n    }\n    parse(xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        const xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    visitElement(element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlString = null;\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n                }\n                else {\n                    const id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, `Message ${id} misses a translation`);\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG:\n                // ignore source message\n                break;\n            case _TARGET_TAG:\n                const innerTextStart = element.startSourceSpan.end.offset;\n                const innerTextEnd = element.endSourceSpan.start.offset;\n                const content = element.startSourceSpan.start.file.content;\n                const innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _XLIFF_TAG:\n                const localeAttr = element.attrs.find((attr) => attr.name === 'trgLang');\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                const versionAttr = element.attrs.find((attr) => attr.name === 'version');\n                if (versionAttr) {\n                    const version = versionAttr.value;\n                    if (version !== '2.0') {\n                        this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                    }\n                }\n                break;\n            default:\n                visitAll(this, element.children, null);\n        }\n    }\n    visitAttribute(attribute, context) { }\n    visitText(text, context) { }\n    visitComment(comment, context) { }\n    visitExpansion(expansion, context) { }\n    visitExpansionCase(expansionCase, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n$1 {\n    convert(message, url) {\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            [].concat(...visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes,\n            errors: this._errors,\n        };\n    }\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitElement(el, context) {\n        switch (el.name) {\n            case _PLACEHOLDER_TAG$1:\n                const nameAttr = el.attrs.find((attr) => attr.name === 'equiv');\n                if (nameAttr) {\n                    return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n                }\n                this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equiv\" attribute`);\n                break;\n            case _PLACEHOLDER_SPANNING_TAG:\n                const startAttr = el.attrs.find((attr) => attr.name === 'equivStart');\n                const endAttr = el.attrs.find((attr) => attr.name === 'equivEnd');\n                if (!startAttr) {\n                    this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivStart\" attribute`);\n                }\n                else if (!endAttr) {\n                    this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivEnd\" attribute`);\n                }\n                else {\n                    const startId = startAttr.value;\n                    const endId = endAttr.value;\n                    const nodes = [];\n                    return nodes.concat(new Placeholder('', startId, el.sourceSpan), ...el.children.map(node => node.visit(this, null)), new Placeholder('', endId, el.sourceSpan));\n                }\n                break;\n            case _MARKER_TAG:\n                return [].concat(...visitAll(this, el.children));\n            default:\n                this._addError(el, `Unexpected tag`);\n        }\n        return null;\n    }\n    visitExpansion(icu, context) {\n        const caseMap = {};\n        visitAll(this, icu.cases).forEach((c) => {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: [].concat(...visitAll(this, icuCase.expression)),\n        };\n    }\n    visitComment(comment, context) { }\n    visitAttribute(attribute, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\nfunction getTypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n        case 'b':\n        case 'i':\n        case 'u':\n            return 'fmt';\n        case 'img':\n            return 'image';\n        case 'a':\n            return 'link';\n        default:\n            return 'other';\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _TRANSLATIONS_TAG = 'translationbundle';\nconst _TRANSLATION_TAG = 'translation';\nconst _PLACEHOLDER_TAG = 'ph';\nclass Xtb extends Serializer {\n    write(messages, locale) {\n        throw new Error('Unsupported');\n    }\n    load(content, url) {\n        // xtb to xml nodes\n        const xtbParser = new XtbParser();\n        const { locale, msgIdToHtml, errors } = xtbParser.parse(content, url);\n        // xml nodes to i18n nodes\n        const i18nNodesByMsgId = {};\n        const converter = new XmlToI18n();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const valueFn = function () {\n                const { i18nNodes, errors } = converter.convert(msgIdToHtml[msgId], url);\n                if (errors.length) {\n                    throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: locale, i18nNodesByMsgId };\n    }\n    digest(message) {\n        return digest(message);\n    }\n    createNameMapper(message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    }\n}\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            const value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value });\n            return value;\n        },\n        set: _ => {\n            throw new Error('Could not overwrite an XTB translation');\n        },\n    });\n}\n// Extract messages as xml nodes from the xtb file\nclass XtbParser {\n    constructor() {\n        this._locale = null;\n    }\n    parse(xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        const xml = new XmlParser().parse(xtb, url);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    visitElement(element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n                }\n                const langAttr = element.attrs.find((attr) => attr.name === 'lang');\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                visitAll(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n                }\n                else {\n                    const id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        const innerTextStart = element.startSourceSpan.end.offset;\n                        const innerTextEnd = element.endSourceSpan.start.offset;\n                        const content = element.startSourceSpan.start.file.content;\n                        const innerText = content.slice(innerTextStart, innerTextEnd);\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    }\n    visitAttribute(attribute, context) { }\n    visitText(text, context) { }\n    visitComment(comment, context) { }\n    visitExpansion(expansion, context) { }\n    visitExpansionCase(expansionCase, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n// Convert ml nodes (xtb syntax) to i18n nodes\nclass XmlToI18n {\n    convert(message, url) {\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes,\n            errors: this._errors,\n        };\n    }\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitExpansion(icu, context) {\n        const caseMap = {};\n        visitAll(this, icu.cases).forEach(c => {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    }\n    visitElement(el, context) {\n        if (el.name === _PLACEHOLDER_TAG) {\n            const nameAttr = el.attrs.find((attr) => attr.name === 'name');\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n        }\n        else {\n            this._addError(el, `Unexpected tag`);\n        }\n        return null;\n    }\n    visitComment(comment, context) { }\n    visitAttribute(attribute, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for translated messages\n */\nclass TranslationBundle {\n    constructor(_i18nNodesByMsgId = {}, locale, digest, mapperFactory, missingTranslationStrategy = MissingTranslationStrategy.Warning, console) {\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    }\n    // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n    static load(content, url, serializer, missingTranslationStrategy, console) {\n        const { locale, i18nNodesByMsgId } = serializer.load(content, url);\n        const digestFn = (m) => serializer.digest(m);\n        const mapperFactory = (m) => serializer.createNameMapper(m);\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    }\n    // Returns the translation as HTML nodes from the given source message.\n    get(srcMsg) {\n        const html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    }\n    has(srcMsg) {\n        return this.digest(srcMsg) in this._i18nNodesByMsgId;\n    }\n}\nclass I18nToHtmlVisitor {\n    constructor(_i18nNodesByMsgId = {}, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    convert(srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        const text = this._convertToText(srcMsg);\n        // text to html\n        const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        const html = new HtmlParser().parse(text, url, { tokenizeExpansionForms: true });\n        return {\n            nodes: html.rootNodes,\n            errors: [...this._errors, ...html.errors],\n        };\n    }\n    visitText(text, context) {\n        // `convert()` uses an `HtmlParser` to return `html.Node`s\n        // we should then make sure that any special characters are escaped\n        return escapeXml(text.value);\n    }\n    visitContainer(container, context) {\n        return container.children.map(n => n.visit(this)).join('');\n    }\n    visitIcu(icu, context) {\n        const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression].text :\n            icu.expression;\n        return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n    }\n    visitPlaceholder(ph, context) {\n        const phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName].text;\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n        return '';\n    }\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    visitTagPlaceholder(ph, context) {\n        const tag = `${ph.tag}`;\n        const attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\n        if (ph.isVoid) {\n            return `<${tag} ${attrs}/>`;\n        }\n        const children = ph.children.map((c) => c.visit(this)).join('');\n        return `<${tag} ${attrs}>${children}</${tag}>`;\n    }\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    visitIcuPlaceholder(ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    }\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     */\n    _convertToText(srcMsg) {\n        const id = this._digest(srcMsg);\n        const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        let nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = (name) => mapper ? mapper.toInternalName(name) : name;\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n                const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n                this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n                const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n                this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = (name) => name;\n        }\n        const text = nodes.map(node => node.visit(this)).join('');\n        const context = this._contextStack.pop();\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    }\n    _addError(el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass I18NHtmlParser {\n    constructor(_htmlParser, translations, translationsFormat, missingTranslation = MissingTranslationStrategy.Warning, console) {\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            const serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n        else {\n            this._translationBundle =\n                new TranslationBundle({}, null, digest$1, undefined, missingTranslation, console);\n        }\n    }\n    parse(source, url, options = {}) {\n        const interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        const parseResult = this._htmlParser.parse(source, url, Object.assign({ interpolationConfig }, options));\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    }\n}\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff2':\n        case 'xlf2':\n            return new Xliff2();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for message extracted from the templates.\n */\nclass MessageBundle {\n    constructor(_htmlParser, _implicitTags, _implicitAttrs, _locale = null) {\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    updateFromTemplate(html, url, interpolationConfig) {\n        const htmlParserResult = this._htmlParser.parse(html, url, { tokenizeExpansionForms: true, interpolationConfig });\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        const i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        this._messages.push(...i18nParserResult.messages);\n        return [];\n    }\n    // Return the message in the internal format\n    // The public (serialized) format might be different, see the `write` method.\n    getMessages() {\n        return this._messages;\n    }\n    write(serializer, filterSources) {\n        const messages = {};\n        const mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(message => {\n            const id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n            else {\n                messages[id].sources.push(...message.sources);\n            }\n        });\n        // Transform placeholder names using the serializer mapping\n        const msgList = Object.keys(messages).map(id => {\n            const mapper = serializer.createNameMapper(messages[id]);\n            const src = messages[id];\n            const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            let transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n            transformedMessage.sources = src.sources;\n            if (filterSources) {\n                transformedMessage.sources.forEach((source) => source.filePath = filterSources(source.filePath));\n            }\n            return transformedMessage;\n        });\n        return serializer.write(msgList, this._locale);\n    }\n}\n// Transform an i18n AST by renaming the placeholder nodes with the given mapper\nclass MapPlaceholderNames extends CloneVisitor {\n    convert(nodes, mapper) {\n        return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\n    }\n    visitTagPlaceholder(ph, mapper) {\n        const startName = mapper.toPublicName(ph.startName);\n        const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n        const children = ph.children.map(n => n.visit(this, mapper));\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n    }\n    visitPlaceholder(ph, mapper) {\n        return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    }\n    visitIcuPlaceholder(ph, mapper) {\n        return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar FactoryTarget;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nclass R3TargetBinder {\n    constructor(directiveMatcher) {\n        this.directiveMatcher = directiveMatcher;\n    }\n    /**\n     * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n     * metadata about the types referenced in the template.\n     */\n    bind(target) {\n        if (!target.template) {\n            // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n            throw new Error('Binding without a template not yet supported');\n        }\n        // First, parse the template into a `Scope` structure. This operation captures the syntactic\n        // scopes in the template and makes them available for later use.\n        const scope = Scope.apply(target.template);\n        // Use the `Scope` to extract the entities present at every level of the template.\n        const templateEntities = extractTemplateEntities(scope);\n        // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n        //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n        //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n        //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n        //   - references: Map of #references to their targets.\n        const { directives, bindings, references } = DirectiveBinder.apply(target.template, this.directiveMatcher);\n        // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n        // template. This extracts all the metadata that doesn't depend on directive matching.\n        const { expressions, symbols, nestingLevel, usedPipes } = TemplateBinder.applyWithScope(target.template, scope);\n        return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, templateEntities, usedPipes);\n    }\n}\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nclass Scope {\n    constructor(parentScope, template) {\n        this.parentScope = parentScope;\n        this.template = template;\n        /**\n         * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n         */\n        this.namedEntities = new Map();\n        /**\n         * Child `Scope`s for immediately nested `Template`s.\n         */\n        this.childScopes = new Map();\n    }\n    static newRootScope() {\n        return new Scope(null, null);\n    }\n    /**\n     * Process a template (either as a `Template` sub-template with variables, or a plain array of\n     * template `Node`s) and construct its `Scope`.\n     */\n    static apply(template) {\n        const scope = Scope.newRootScope();\n        scope.ingest(template);\n        return scope;\n    }\n    /**\n     * Internal method to process the template and populate the `Scope`.\n     */\n    ingest(template) {\n        if (template instanceof Template) {\n            // Variables on an <ng-template> are defined in the inner scope.\n            template.variables.forEach(node => this.visitVariable(node));\n            // Process the nodes of the template.\n            template.children.forEach(node => node.visit(this));\n        }\n        else {\n            // No overarching `Template` instance, so process the nodes directly.\n            template.forEach(node => node.visit(this));\n        }\n    }\n    visitElement(element) {\n        // `Element`s in the template may have `Reference`s which are captured in the scope.\n        element.references.forEach(node => this.visitReference(node));\n        // Recurse into the `Element`'s children.\n        element.children.forEach(node => node.visit(this));\n    }\n    visitTemplate(template) {\n        // References on a <ng-template> are defined in the outer scope, so capture them before\n        // processing the template's child scope.\n        template.references.forEach(node => this.visitReference(node));\n        // Next, create an inner scope and process the template within it.\n        const scope = new Scope(this, template);\n        scope.ingest(template);\n        this.childScopes.set(template, scope);\n    }\n    visitVariable(variable) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(variable);\n    }\n    visitReference(reference) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(reference);\n    }\n    // Unused visitors.\n    visitContent(content) { }\n    visitBoundAttribute(attr) { }\n    visitBoundEvent(event) { }\n    visitBoundText(text) { }\n    visitText(text) { }\n    visitTextAttribute(attr) { }\n    visitIcu(icu) { }\n    maybeDeclare(thing) {\n        // Declare something with a name, as long as that name isn't taken.\n        if (!this.namedEntities.has(thing.name)) {\n            this.namedEntities.set(thing.name, thing);\n        }\n    }\n    /**\n     * Look up a variable within this `Scope`.\n     *\n     * This can recurse into a parent `Scope` if it's available.\n     */\n    lookup(name) {\n        if (this.namedEntities.has(name)) {\n            // Found in the local scope.\n            return this.namedEntities.get(name);\n        }\n        else if (this.parentScope !== null) {\n            // Not in the local scope, but there's a parent scope so check there.\n            return this.parentScope.lookup(name);\n        }\n        else {\n            // At the top level and it wasn't found.\n            return null;\n        }\n    }\n    /**\n     * Get the child scope for a `Template`.\n     *\n     * This should always be defined.\n     */\n    getChildScope(template) {\n        const res = this.childScopes.get(template);\n        if (res === undefined) {\n            throw new Error(`Assertion error: child scope for ${template} not found`);\n        }\n        return res;\n    }\n}\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nclass DirectiveBinder {\n    constructor(matcher, directives, bindings, references) {\n        this.matcher = matcher;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n    }\n    /**\n     * Process a template (list of `Node`s) and perform directive matching against each node.\n     *\n     * @param template the list of template `Node`s to match (recursively).\n     * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n     * this template.\n     * @returns three maps which contain information about directives in the template: the\n     * `directives` map which lists directives matched on each node, the `bindings` map which\n     * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n     * map which resolves #references (`Reference`s) within the template to the named directive or\n     * template node.\n     */\n    static apply(template, selectorMatcher) {\n        const directives = new Map();\n        const bindings = new Map();\n        const references = new Map();\n        const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n        matcher.ingest(template);\n        return { directives, bindings, references };\n    }\n    ingest(template) {\n        template.forEach(node => node.visit(this));\n    }\n    visitElement(element) {\n        this.visitElementOrTemplate(element.name, element);\n    }\n    visitTemplate(template) {\n        this.visitElementOrTemplate('ng-template', template);\n    }\n    visitElementOrTemplate(elementName, node) {\n        // First, determine the HTML shape of the node for the purpose of directive matching.\n        // Do this by building up a `CssSelector` for the node.\n        const cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));\n        // Next, use the `SelectorMatcher` to get the list of directives on the node.\n        const directives = [];\n        this.matcher.match(cssSelector, (_, directive) => directives.push(directive));\n        if (directives.length > 0) {\n            this.directives.set(node, directives);\n        }\n        // Resolve any references that are created on this node.\n        node.references.forEach(ref => {\n            let dirTarget = null;\n            // If the reference expression is empty, then it matches the \"primary\" directive on the node\n            // (if there is one). Otherwise it matches the host node itself (either an element or\n            // <ng-template> node).\n            if (ref.value.trim() === '') {\n                // This could be a reference to a component if there is one.\n                dirTarget = directives.find(dir => dir.isComponent) || null;\n            }\n            else {\n                // This should be a reference to a directive exported via exportAs.\n                dirTarget =\n                    directives.find(dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) ||\n                        null;\n                // Check if a matching directive was found.\n                if (dirTarget === null) {\n                    // No matching directive was found - this reference points to an unknown target. Leave it\n                    // unmapped.\n                    return;\n                }\n            }\n            if (dirTarget !== null) {\n                // This reference points to a directive.\n                this.references.set(ref, { directive: dirTarget, node });\n            }\n            else {\n                // This reference points to the node itself.\n                this.references.set(ref, node);\n            }\n        });\n        const setAttributeBinding = (attribute, ioType) => {\n            const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n            const binding = dir !== undefined ? dir : node;\n            this.bindings.set(attribute, binding);\n        };\n        // Node inputs (bound attributes) and text attributes can be bound to an\n        // input on a directive.\n        node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\n        node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\n        if (node instanceof Template) {\n            node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\n        }\n        // Node outputs (bound events) can be bound to an output on a directive.\n        node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\n        // Recurse into the node's children.\n        node.children.forEach(child => child.visit(this));\n    }\n    // Unused visitors.\n    visitContent(content) { }\n    visitVariable(variable) { }\n    visitReference(reference) { }\n    visitTextAttribute(attribute) { }\n    visitBoundAttribute(attribute) { }\n    visitBoundEvent(attribute) { }\n    visitBoundAttributeOrEvent(node) { }\n    visitText(text) { }\n    visitBoundText(text) { }\n    visitIcu(icu) { }\n}\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nclass TemplateBinder extends RecursiveAstVisitor {\n    constructor(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {\n        super();\n        this.bindings = bindings;\n        this.symbols = symbols;\n        this.usedPipes = usedPipes;\n        this.nestingLevel = nestingLevel;\n        this.scope = scope;\n        this.template = template;\n        this.level = level;\n        this.pipesUsed = [];\n        // Save a bit of processing time by constructing this closure in advance.\n        this.visitNode = (node) => node.visit(this);\n    }\n    // This method is defined to reconcile the type of TemplateBinder since both\n    // RecursiveAstVisitor and Visitor define the visit() method in their\n    // interfaces.\n    visit(node, context) {\n        if (node instanceof AST) {\n            node.visit(this, context);\n        }\n        else {\n            node.visit(this);\n        }\n    }\n    /**\n     * Process a template and extract metadata about expressions and symbols within.\n     *\n     * @param template the nodes of the template to process\n     * @param scope the `Scope` of the template being processed.\n     * @returns three maps which contain metadata about the template: `expressions` which interprets\n     * special `AST` nodes in expressions as pointing to references or variables declared within the\n     * template, `symbols` which maps those variables and references to the nested `Template` which\n     * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n     * nesting level (how many levels deep within the template structure the `Template` is), starting\n     * at 1.\n     */\n    static applyWithScope(template, scope) {\n        const expressions = new Map();\n        const symbols = new Map();\n        const nestingLevel = new Map();\n        const usedPipes = new Set();\n        // The top-level template has nesting level 0.\n        const binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);\n        binder.ingest(template);\n        return { expressions, symbols, nestingLevel, usedPipes };\n    }\n    ingest(template) {\n        if (template instanceof Template) {\n            // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n            // and references were all processed in the scope of the containing template.\n            template.variables.forEach(this.visitNode);\n            template.children.forEach(this.visitNode);\n            // Set the nesting level.\n            this.nestingLevel.set(template, this.level);\n        }\n        else {\n            // Visit each node from the top-level template.\n            template.forEach(this.visitNode);\n        }\n    }\n    visitElement(element) {\n        // Visit the inputs, outputs, and children of the element.\n        element.inputs.forEach(this.visitNode);\n        element.outputs.forEach(this.visitNode);\n        element.children.forEach(this.visitNode);\n    }\n    visitTemplate(template) {\n        // First, visit inputs, outputs and template attributes of the template node.\n        template.inputs.forEach(this.visitNode);\n        template.outputs.forEach(this.visitNode);\n        template.templateAttrs.forEach(this.visitNode);\n        // References are also evaluated in the outer context.\n        template.references.forEach(this.visitNode);\n        // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n        const childScope = this.scope.getChildScope(template);\n        const binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);\n        binder.ingest(template);\n    }\n    visitVariable(variable) {\n        // Register the `Variable` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(variable, this.template);\n        }\n    }\n    visitReference(reference) {\n        // Register the `Reference` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(reference, this.template);\n        }\n    }\n    // Unused template visitors\n    visitText(text) { }\n    visitContent(content) { }\n    visitTextAttribute(attribute) { }\n    visitIcu(icu) {\n        Object.keys(icu.vars).forEach(key => icu.vars[key].visit(this));\n        Object.keys(icu.placeholders).forEach(key => icu.placeholders[key].visit(this));\n    }\n    // The remaining visitors are concerned with processing AST expressions within template bindings\n    visitBoundAttribute(attribute) {\n        attribute.value.visit(this);\n    }\n    visitBoundEvent(event) {\n        event.handler.visit(this);\n    }\n    visitBoundText(text) {\n        text.value.visit(this);\n    }\n    visitPipe(ast, context) {\n        this.usedPipes.add(ast.name);\n        return super.visitPipe(ast, context);\n    }\n    // These five types of AST expressions can refer to expression roots, which could be variables\n    // or references in the current scope.\n    visitPropertyRead(ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return super.visitPropertyRead(ast, context);\n    }\n    visitSafePropertyRead(ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return super.visitSafePropertyRead(ast, context);\n    }\n    visitPropertyWrite(ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return super.visitPropertyWrite(ast, context);\n    }\n    maybeMap(scope, ast, name) {\n        // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n        // `AST` expression that maps to a `Variable` or `Reference`.\n        if (!(ast.receiver instanceof ImplicitReceiver)) {\n            return;\n        }\n        // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n        // probably a property on the top-level component context.\n        let target = this.scope.lookup(name);\n        if (target !== null) {\n            this.bindings.set(ast, target);\n        }\n    }\n}\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nclass R3BoundTarget {\n    constructor(target, directives, bindings, references, exprTargets, symbols, nestingLevel, templateEntities, usedPipes) {\n        this.target = target;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n        this.exprTargets = exprTargets;\n        this.symbols = symbols;\n        this.nestingLevel = nestingLevel;\n        this.templateEntities = templateEntities;\n        this.usedPipes = usedPipes;\n    }\n    getEntitiesInTemplateScope(template) {\n        var _a;\n        return (_a = this.templateEntities.get(template)) !== null && _a !== void 0 ? _a : new Set();\n    }\n    getDirectivesOfNode(node) {\n        return this.directives.get(node) || null;\n    }\n    getReferenceTarget(ref) {\n        return this.references.get(ref) || null;\n    }\n    getConsumerOfBinding(binding) {\n        return this.bindings.get(binding) || null;\n    }\n    getExpressionTarget(expr) {\n        return this.exprTargets.get(expr) || null;\n    }\n    getTemplateOfSymbol(symbol) {\n        return this.symbols.get(symbol) || null;\n    }\n    getNestingLevel(template) {\n        return this.nestingLevel.get(template) || 0;\n    }\n    getUsedDirectives() {\n        const set = new Set();\n        this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n        return Array.from(set.values());\n    }\n    getUsedPipes() {\n        return Array.from(this.usedPipes);\n    }\n}\nfunction extractTemplateEntities(rootScope) {\n    const entityMap = new Map();\n    function extractScopeEntities(scope) {\n        if (entityMap.has(scope.template)) {\n            return entityMap.get(scope.template);\n        }\n        const currentEntities = scope.namedEntities;\n        let templateEntities;\n        if (scope.parentScope !== null) {\n            templateEntities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n        }\n        else {\n            templateEntities = new Map(currentEntities);\n        }\n        entityMap.set(scope.template, templateEntities);\n        return templateEntities;\n    }\n    const scopesToProcess = [rootScope];\n    while (scopesToProcess.length > 0) {\n        const scope = scopesToProcess.pop();\n        for (const childScope of scope.childScopes.values()) {\n            scopesToProcess.push(childScope);\n        }\n        extractScopeEntities(scope);\n    }\n    const templateEntities = new Map();\n    for (const [template, entities] of entityMap) {\n        templateEntities.set(template, new Set(entities.values()));\n    }\n    return templateEntities;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compileClassMetadata(metadata) {\n    var _a, _b;\n    // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its\n    // metadata.\n    const fnCall = importExpr(Identifiers$1.setClassMetadata).callFn([\n        metadata.type,\n        metadata.decorators,\n        (_a = metadata.ctorParameters) !== null && _a !== void 0 ? _a : literal(null),\n        (_b = metadata.propDecorators) !== null && _b !== void 0 ? _b : literal(null),\n    ]);\n    const iife = fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n    return iife.callFn([]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$6 = '12.0.0';\nfunction compileDeclareClassMetadata(metadata) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$6));\n    definitionMap.set('version', literal('13.1.3'));\n    definitionMap.set('ngImport', importExpr(Identifiers$1.core));\n    definitionMap.set('type', metadata.type);\n    definitionMap.set('decorators', metadata.decorators);\n    definitionMap.set('ctorParameters', metadata.ctorParameters);\n    definitionMap.set('propDecorators', metadata.propDecorators);\n    return importExpr(Identifiers$1.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates an array literal expression from the given array, mapping all values to an expression\n * using the provided mapping function. If the array is empty or null, then null is returned.\n *\n * @param values The array to transfer into literal array expression.\n * @param mapper The logic to use for creating an expression for the array's values.\n * @returns An array literal expression representing `values`, or null if `values` is empty or\n * is itself null.\n */\nfunction toOptionalLiteralArray(values, mapper) {\n    if (values === null || values.length === 0) {\n        return null;\n    }\n    return literalArr(values.map(value => mapper(value)));\n}\n/**\n * Creates an object literal expression from the given object, mapping all values to an expression\n * using the provided mapping function. If the object has no keys, then null is returned.\n *\n * @param object The object to transfer into an object literal expression.\n * @param mapper The logic to use for creating an expression for the object's values.\n * @returns An object literal expression representing `object`, or null if `object` does not have\n * any keys.\n */\nfunction toOptionalLiteralMap(object, mapper) {\n    const entries = Object.keys(object).map(key => {\n        const value = object[key];\n        return { key, value: mapper(value), quoted: true };\n    });\n    if (entries.length > 0) {\n        return literalMap(entries);\n    }\n    else {\n        return null;\n    }\n}\nfunction compileDependencies(deps) {\n    if (deps === 'invalid') {\n        // The `deps` can be set to the string \"invalid\"  by the `unwrapConstructorDependencies()`\n        // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.\n        return literal('invalid');\n    }\n    else if (deps === null) {\n        return literal(null);\n    }\n    else {\n        return literalArr(deps.map(compileDependency));\n    }\n}\nfunction compileDependency(dep) {\n    const depMeta = new DefinitionMap();\n    depMeta.set('token', dep.token);\n    if (dep.attributeNameType !== null) {\n        depMeta.set('attribute', literal(true));\n    }\n    if (dep.host) {\n        depMeta.set('host', literal(true));\n    }\n    if (dep.optional) {\n        depMeta.set('optional', literal(true));\n    }\n    if (dep.self) {\n        depMeta.set('self', literal(true));\n    }\n    if (dep.skipSelf) {\n        depMeta.set('skipSelf', literal(true));\n    }\n    return depMeta.toLiteralMap();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$5 = '12.0.0';\n/**\n * Compile a directive declaration defined by the `R3DirectiveMetadata`.\n */\nfunction compileDeclareDirectiveFromMetadata(meta) {\n    const definitionMap = createDirectiveDefinitionMap(meta);\n    const expression = importExpr(Identifiers$1.declareDirective).callFn([definitionMap.toLiteralMap()]);\n    const type = createDirectiveType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing\n * this logic for components, as they extend the directive metadata.\n */\nfunction createDirectiveDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));\n    definitionMap.set('version', literal('13.1.3'));\n    // e.g. `type: MyDirective`\n    definitionMap.set('type', meta.internalType);\n    // e.g. `selector: 'some-dir'`\n    if (meta.selector !== null) {\n        definitionMap.set('selector', literal(meta.selector));\n    }\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n    definitionMap.set('host', compileHostMetadata(meta.host));\n    definitionMap.set('providers', meta.providers);\n    if (meta.queries.length > 0) {\n        definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));\n    }\n    if (meta.viewQueries.length > 0) {\n        definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));\n    }\n    if (meta.exportAs !== null) {\n        definitionMap.set('exportAs', asLiteral(meta.exportAs));\n    }\n    if (meta.usesInheritance) {\n        definitionMap.set('usesInheritance', literal(true));\n    }\n    if (meta.lifecycle.usesOnChanges) {\n        definitionMap.set('usesOnChanges', literal(true));\n    }\n    definitionMap.set('ngImport', importExpr(Identifiers$1.core));\n    return definitionMap;\n}\n/**\n * Compiles the metadata of a single query into its partial declaration form as declared\n * by `R3DeclareQueryMetadata`.\n */\nfunction compileQuery(query) {\n    const meta = new DefinitionMap();\n    meta.set('propertyName', literal(query.propertyName));\n    if (query.first) {\n        meta.set('first', literal(true));\n    }\n    meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) :\n        convertFromMaybeForwardRefExpression(query.predicate));\n    if (!query.emitDistinctChangesOnly) {\n        // `emitDistinctChangesOnly` is special because we expect it to be `true`.\n        // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.\n        meta.set('emitDistinctChangesOnly', literal(false));\n    }\n    else {\n        // The linker will assume that an absent `emitDistinctChangesOnly` flag is by default `true`.\n    }\n    if (query.descendants) {\n        meta.set('descendants', literal(true));\n    }\n    meta.set('read', query.read);\n    if (query.static) {\n        meta.set('static', literal(true));\n    }\n    return meta.toLiteralMap();\n}\n/**\n * Compiles the host metadata into its partial declaration form as declared\n * in `R3DeclareDirectiveMetadata['host']`\n */\nfunction compileHostMetadata(meta) {\n    const hostMetadata = new DefinitionMap();\n    hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\n    hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));\n    hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));\n    if (meta.specialAttributes.styleAttr) {\n        hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));\n    }\n    if (meta.specialAttributes.classAttr) {\n        hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));\n    }\n    if (hostMetadata.values.length > 0) {\n        return hostMetadata.toLiteralMap();\n    }\n    else {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Compile a component declaration defined by the `R3ComponentMetadata`.\n */\nfunction compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {\n    const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n    const expression = importExpr(Identifiers$1.declareComponent).callFn([definitionMap.toLiteralMap()]);\n    const type = createComponentType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a component into a `DefinitionMap`.\n */\nfunction createComponentDefinitionMap(meta, template, templateInfo) {\n    const definitionMap = createDirectiveDefinitionMap(meta);\n    definitionMap.set('template', getTemplateExpression(template, templateInfo));\n    if (templateInfo.isInline) {\n        definitionMap.set('isInline', literal(true));\n    }\n    definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));\n    definitionMap.set('components', compileUsedDirectiveMetadata(meta, directive => directive.isComponent === true));\n    definitionMap.set('directives', compileUsedDirectiveMetadata(meta, directive => directive.isComponent !== true));\n    definitionMap.set('pipes', compileUsedPipeMetadata(meta));\n    definitionMap.set('viewProviders', meta.viewProviders);\n    definitionMap.set('animations', meta.animations);\n    if (meta.changeDetection !== undefined) {\n        definitionMap.set('changeDetection', importExpr(Identifiers$1.ChangeDetectionStrategy)\n            .prop(ChangeDetectionStrategy[meta.changeDetection]));\n    }\n    if (meta.encapsulation !== ViewEncapsulation.Emulated) {\n        definitionMap.set('encapsulation', importExpr(Identifiers$1.ViewEncapsulation).prop(ViewEncapsulation[meta.encapsulation]));\n    }\n    if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n        definitionMap.set('interpolation', literalArr([literal(meta.interpolation.start), literal(meta.interpolation.end)]));\n    }\n    if (template.preserveWhitespaces === true) {\n        definitionMap.set('preserveWhitespaces', literal(true));\n    }\n    return definitionMap;\n}\nfunction getTemplateExpression(template, templateInfo) {\n    // If the template has been defined using a direct literal, we use that expression directly\n    // without any modifications. This is ensures proper source mapping from the partially\n    // compiled code to the source file declaring the template. Note that this does not capture\n    // template literals referenced indirectly through an identifier.\n    if (templateInfo.inlineTemplateLiteralExpression !== null) {\n        return templateInfo.inlineTemplateLiteralExpression;\n    }\n    // If the template is defined inline but not through a literal, the template has been resolved\n    // through static interpretation. We create a literal but cannot provide any source span. Note\n    // that we cannot use the expression defining the template because the linker expects the template\n    // to be defined as a literal in the declaration.\n    if (templateInfo.isInline) {\n        return literal(templateInfo.content, null, null);\n    }\n    // The template is external so we must synthesize an expression node with\n    // the appropriate source-span.\n    const contents = templateInfo.content;\n    const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n    const start = new ParseLocation(file, 0, 0, 0);\n    const end = computeEndLocation(file, contents);\n    const span = new ParseSourceSpan(start, end);\n    return literal(contents, null, span);\n}\nfunction computeEndLocation(file, contents) {\n    const length = contents.length;\n    let lineStart = 0;\n    let lastLineStart = 0;\n    let line = 0;\n    do {\n        lineStart = contents.indexOf('\\n', lastLineStart);\n        if (lineStart !== -1) {\n            lastLineStart = lineStart + 1;\n            line++;\n        }\n    } while (lineStart !== -1);\n    return new ParseLocation(file, length, line, length - lastLineStart);\n}\n/**\n * Compiles the directives as registered in the component metadata into an array literal of the\n * individual directives. If the component does not use any directives, then null is returned.\n */\nfunction compileUsedDirectiveMetadata(meta, predicate) {\n    const wrapType = meta.declarationListEmitMode !== 0 /* Direct */ ?\n        generateForwardRef :\n        (expr) => expr;\n    const directives = meta.directives.filter(predicate);\n    return toOptionalLiteralArray(directives, directive => {\n        const dirMeta = new DefinitionMap();\n        dirMeta.set('type', wrapType(directive.type));\n        dirMeta.set('selector', literal(directive.selector));\n        dirMeta.set('inputs', toOptionalLiteralArray(directive.inputs, literal));\n        dirMeta.set('outputs', toOptionalLiteralArray(directive.outputs, literal));\n        dirMeta.set('exportAs', toOptionalLiteralArray(directive.exportAs, literal));\n        return dirMeta.toLiteralMap();\n    });\n}\n/**\n * Compiles the pipes as registered in the component metadata into an object literal, where the\n * pipe's name is used as key and a reference to its type as value. If the component does not use\n * any pipes, then null is returned.\n */\nfunction compileUsedPipeMetadata(meta) {\n    if (meta.pipes.size === 0) {\n        return null;\n    }\n    const wrapType = meta.declarationListEmitMode !== 0 /* Direct */ ?\n        generateForwardRef :\n        (expr) => expr;\n    const entries = [];\n    for (const [name, pipe] of meta.pipes) {\n        entries.push({ key: name, value: wrapType(pipe), quoted: true });\n    }\n    return literalMap(entries);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';\nfunction compileDeclareFactoryFunction(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));\n    definitionMap.set('version', literal('13.1.3'));\n    definitionMap.set('ngImport', importExpr(Identifiers$1.core));\n    definitionMap.set('type', meta.internalType);\n    definitionMap.set('deps', compileDependencies(meta.deps));\n    definitionMap.set('target', importExpr(Identifiers$1.FactoryTarget).prop(FactoryTarget$1[meta.target]));\n    return {\n        expression: importExpr(Identifiers$1.declareFactory).callFn([definitionMap.toLiteralMap()]),\n        statements: [],\n        type: createFactoryType(meta),\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';\n/**\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\n */\nfunction compileDeclareInjectableFromMetadata(meta) {\n    const definitionMap = createInjectableDefinitionMap(meta);\n    const expression = importExpr(Identifiers$1.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n    const type = createInjectableType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\n */\nfunction createInjectableDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));\n    definitionMap.set('version', literal('13.1.3'));\n    definitionMap.set('ngImport', importExpr(Identifiers$1.core));\n    definitionMap.set('type', meta.internalType);\n    // Only generate providedIn property if it has a non-null value\n    if (meta.providedIn !== undefined) {\n        const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n        if (providedIn.value !== null) {\n            definitionMap.set('providedIn', providedIn);\n        }\n    }\n    if (meta.useClass !== undefined) {\n        definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n    }\n    if (meta.useExisting !== undefined) {\n        definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n    }\n    if (meta.useValue !== undefined) {\n        definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n    }\n    // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n    // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n    // with `convertFromProviderExpression()`.\n    if (meta.useFactory !== undefined) {\n        definitionMap.set('useFactory', meta.useFactory);\n    }\n    if (meta.deps !== undefined) {\n        definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));\n    }\n    return definitionMap;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';\nfunction compileDeclareInjectorFromMetadata(meta) {\n    const definitionMap = createInjectorDefinitionMap(meta);\n    const expression = importExpr(Identifiers$1.declareInjector).callFn([definitionMap.toLiteralMap()]);\n    const type = createInjectorType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for an Injector into a `DefinitionMap`.\n */\nfunction createInjectorDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));\n    definitionMap.set('version', literal('13.1.3'));\n    definitionMap.set('ngImport', importExpr(Identifiers$1.core));\n    definitionMap.set('type', meta.internalType);\n    definitionMap.set('providers', meta.providers);\n    if (meta.imports.length > 0) {\n        definitionMap.set('imports', literalArr(meta.imports));\n    }\n    return definitionMap;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$1 = '12.0.0';\nfunction compileDeclareNgModuleFromMetadata(meta) {\n    const definitionMap = createNgModuleDefinitionMap(meta);\n    const expression = importExpr(Identifiers$1.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n    const type = createNgModuleType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for an NgModule into a `DefinitionMap`.\n */\nfunction createNgModuleDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));\n    definitionMap.set('version', literal('13.1.3'));\n    definitionMap.set('ngImport', importExpr(Identifiers$1.core));\n    definitionMap.set('type', meta.internalType);\n    // We only generate the keys in the metadata if the arrays contain values.\n    // We must wrap the arrays inside a function if any of the values are a forward reference to a\n    // not-yet-declared class. This is to support JIT execution of the `ngDeclareNgModule()` call.\n    // In the linker these wrappers are stripped and then reapplied for the `defineNgModule()` call.\n    if (meta.bootstrap.length > 0) {\n        definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n    }\n    if (meta.declarations.length > 0) {\n        definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n    if (meta.imports.length > 0) {\n        definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n    if (meta.exports.length > 0) {\n        definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n    if (meta.schemas !== null && meta.schemas.length > 0) {\n        definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\n    }\n    if (meta.id !== null) {\n        definitionMap.set('id', meta.id);\n    }\n    return definitionMap;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n/**\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\n */\nfunction compileDeclarePipeFromMetadata(meta) {\n    const definitionMap = createPipeDefinitionMap(meta);\n    const expression = importExpr(Identifiers$1.declarePipe).callFn([definitionMap.toLiteralMap()]);\n    const type = createPipeType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`.\n */\nfunction createPipeDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));\n    definitionMap.set('version', literal('13.1.3'));\n    definitionMap.set('ngImport', importExpr(Identifiers$1.core));\n    // e.g. `type: MyPipe`\n    definitionMap.set('type', meta.internalType);\n    // e.g. `name: \"myPipe\"`\n    definitionMap.set('name', literal(meta.pipeName));\n    if (meta.pure === false) {\n        // e.g. `pure: false`\n        definitionMap.set('pure', literal(meta.pure));\n    }\n    return definitionMap;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\npublishFacade(_global);\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n//# sourceMappingURL=compiler.mjs.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvZmVzbTIwMTUvY29tcGlsZXIubWpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2NvbXBpbGVyL2Zlc20yMDE1L2NvbXBpbGVyLm1qcz85NmY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2MTMuMS4zXG4gKiAoYykgMjAxMC0yMDIyIEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFRhZ0NvbnRlbnRUeXBlO1xuKGZ1bmN0aW9uIChUYWdDb250ZW50VHlwZSkge1xuICAgIFRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlW1wiUkFXX1RFWFRcIl0gPSAwXSA9IFwiUkFXX1RFWFRcIjtcbiAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiXSA9IDFdID0gXCJFU0NBUEFCTEVfUkFXX1RFWFRcIjtcbiAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIlBBUlNBQkxFX0RBVEFcIl0gPSAyXSA9IFwiUEFSU0FCTEVfREFUQVwiO1xufSkoVGFnQ29udGVudFR5cGUgfHwgKFRhZ0NvbnRlbnRUeXBlID0ge30pKTtcbmZ1bmN0aW9uIHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKSB7XG4gICAgaWYgKGVsZW1lbnROYW1lWzBdICE9ICc6Jykge1xuICAgICAgICByZXR1cm4gW251bGwsIGVsZW1lbnROYW1lXTtcbiAgICB9XG4gICAgY29uc3QgY29sb25JbmRleCA9IGVsZW1lbnROYW1lLmluZGV4T2YoJzonLCAxKTtcbiAgICBpZiAoY29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBmb3JtYXQgXCIke2VsZW1lbnROYW1lfVwiIGV4cGVjdGluZyBcIjpuYW1lc3BhY2U6bmFtZVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBbZWxlbWVudE5hbWUuc2xpY2UoMSwgY29sb25JbmRleCksIGVsZW1lbnROYW1lLnNsaWNlKGNvbG9uSW5kZXggKyAxKV07XG59XG4vLyBgPG5nLWNvbnRhaW5lcj5gIHRhZ3Mgd29yayB0aGUgc2FtZSByZWdhcmRsZXNzIHRoZSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGlzTmdDb250YWluZXIodGFnTmFtZSkge1xuICAgIHJldHVybiBzcGxpdE5zTmFtZSh0YWdOYW1lKVsxXSA9PT0gJ25nLWNvbnRhaW5lcic7XG59XG4vLyBgPG5nLWNvbnRlbnQ+YCB0YWdzIHdvcmsgdGhlIHNhbWUgcmVnYXJkbGVzcyB0aGUgbmFtZXNwYWNlXG5mdW5jdGlvbiBpc05nQ29udGVudCh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIHNwbGl0TnNOYW1lKHRhZ05hbWUpWzFdID09PSAnbmctY29udGVudCc7XG59XG4vLyBgPG5nLXRlbXBsYXRlPmAgdGFncyB3b3JrIHRoZSBzYW1lIHJlZ2FyZGxlc3MgdGhlIG5hbWVzcGFjZVxuZnVuY3Rpb24gaXNOZ1RlbXBsYXRlKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gc3BsaXROc05hbWUodGFnTmFtZSlbMV0gPT09ICduZy10ZW1wbGF0ZSc7XG59XG5mdW5jdGlvbiBnZXROc1ByZWZpeChmdWxsTmFtZSkge1xuICAgIHJldHVybiBmdWxsTmFtZSA9PT0gbnVsbCA/IG51bGwgOiBzcGxpdE5zTmFtZShmdWxsTmFtZSlbMF07XG59XG5mdW5jdGlvbiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSkge1xuICAgIHJldHVybiBwcmVmaXggPyBgOiR7cHJlZml4fToke2xvY2FsTmFtZX1gIDogbG9jYWxOYW1lO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIEh0bWxUYWdEZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNsb3NlZEJ5Q2hpbGRyZW4sIGltcGxpY2l0TmFtZXNwYWNlUHJlZml4LCBjb250ZW50VHlwZSA9IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEsIGNsb3NlZEJ5UGFyZW50ID0gZmFsc2UsIGlzVm9pZCA9IGZhbHNlLCBpZ25vcmVGaXJzdExmID0gZmFsc2UsIHByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW4gPSB7fTtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblNlbGZDbG9zZSA9IGZhbHNlO1xuICAgICAgICBpZiAoY2xvc2VkQnlDaGlsZHJlbiAmJiBjbG9zZWRCeUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW4uZm9yRWFjaCh0YWdOYW1lID0+IHRoaXMuY2xvc2VkQnlDaGlsZHJlblt0YWdOYW1lXSA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNWb2lkID0gaXNWb2lkO1xuICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gY2xvc2VkQnlQYXJlbnQgfHwgaXNWb2lkO1xuICAgICAgICB0aGlzLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gaW1wbGljaXROYW1lc3BhY2VQcmVmaXggfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBpZ25vcmVGaXJzdExmO1xuICAgICAgICB0aGlzLnByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZSA9IHByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZTtcbiAgICB9XG4gICAgaXNDbG9zZWRCeUNoaWxkKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWb2lkIHx8IG5hbWUudG9Mb3dlckNhc2UoKSBpbiB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW47XG4gICAgfVxuICAgIGdldENvbnRlbnRUeXBlKHByZWZpeCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBvdmVycmlkZVR5cGUgPSBwcmVmaXggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMuY29udGVudFR5cGVbcHJlZml4XTtcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZVR5cGUgIT09IG51bGwgJiYgb3ZlcnJpZGVUeXBlICE9PSB2b2lkIDAgPyBvdmVycmlkZVR5cGUgOiB0aGlzLmNvbnRlbnRUeXBlLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFR5cGU7XG4gICAgfVxufVxubGV0IF9ERUZBVUxUX1RBR19ERUZJTklUSU9OO1xuLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjb3B0aW9uYWwtdGFnc1xuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBmdWxseSBjb25mb3JtIHRvIHRoZSBIVE1MNSBzcGVjLlxubGV0IFRBR19ERUZJTklUSU9OUztcbmZ1bmN0aW9uIGdldEh0bWxUYWdEZWZpbml0aW9uKHRhZ05hbWUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghVEFHX0RFRklOSVRJT05TKSB7XG4gICAgICAgIF9ERUZBVUxUX1RBR19ERUZJTklUSU9OID0gbmV3IEh0bWxUYWdEZWZpbml0aW9uKCk7XG4gICAgICAgIFRBR19ERUZJTklUSU9OUyA9IHtcbiAgICAgICAgICAgICdiYXNlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ21ldGEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnYXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdlbWJlZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdsaW5rJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2ltZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdpbnB1dCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdwYXJhbSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdocic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdzb3VyY2UnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAndHJhY2snOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnd2JyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3AnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgJ2FkZHJlc3MnLCAnYXJ0aWNsZScsICdhc2lkZScsICdibG9ja3F1b3RlJywgJ2RpdicsICdkbCcsICdmaWVsZHNldCcsXG4gICAgICAgICAgICAgICAgICAgICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsXG4gICAgICAgICAgICAgICAgICAgICdoNicsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ21haW4nLCAnbmF2JywgJ29sJyxcbiAgICAgICAgICAgICAgICAgICAgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndWwnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAndGhlYWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5JywgJ3Rmb290J10gfSksXG4gICAgICAgICAgICAndGJvZHknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5JywgJ3Rmb290J10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3Rmb290JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICd0cic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndHInXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAndGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RkJywgJ3RoJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3RoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdjb2wnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnc3ZnJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdzdmcnIH0pLFxuICAgICAgICAgICAgJ2ZvcmVpZ25PYmplY3QnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICAgICAgICAgIC8vIFVzdWFsbHkgdGhlIGltcGxpY2l0IG5hbWVzcGFjZSBoZXJlIHdvdWxkIGJlIHJlZHVuZGFudCBzaW5jZSBpdCB3aWxsIGJlIGluaGVyaXRlZCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcmVudCBgc3ZnYCwgYnV0IHdlIGhhdmUgdG8gZG8gaXQgZm9yIGBmb3JlaWduT2JqZWN0YCwgYmVjYXVzZSB0aGUgd2F5IHRoZSBwYXJzZXJcbiAgICAgICAgICAgICAgICAvLyB3b3JrcyBpcyB0aGF0IHRoZSBwYXJlbnQgbm9kZSBvZiBhbiBlbmQgdGFnIGlzIGl0cyBvd24gc3RhcnQgdGFnIHdoaWNoIG1lYW5zIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgYHByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZWAgb24gYGZvcmVpZ25PYmplY3RgIHdvdWxkIGhhdmUgaXQgZGVmYXVsdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBpbXBsaWNpdCBuYW1lc3BhY2Ugd2hpY2ggaXMgYGh0bWxgLCB1bmxlc3Mgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgICBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ3N2ZycsXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBwcmV2ZW50IGNoaWxkcmVuIG9mIGZvcmVpZ25PYmplY3QgZnJvbSBpbmhlcml0aW5nIGl0cyBuYW1lc3BhY2UsIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgcG9pbnQgb2YgdGhlIGVsZW1lbnQgaXMgdG8gYWxsb3cgbm9kZXMgZnJvbSBvdGhlciBuYW1lc3BhY2VzIHRvIGJlIGluc2VydGVkLlxuICAgICAgICAgICAgICAgIHByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgJ21hdGgnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ21hdGgnIH0pLFxuICAgICAgICAgICAgJ2xpJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydsaSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdkdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSB9KSxcbiAgICAgICAgICAgICdkZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAncmInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdydCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3J0Yyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3JwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAnb3B0Z3JvdXAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ29wdGlvbic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnb3B0aW9uJywgJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3ByZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAgICAgICAnbGlzdGluZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAgICAgICAnc3R5bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgICAgICAgICAnc2NyaXB0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUIH0pLFxuICAgICAgICAgICAgJ3RpdGxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYnJvd3NlciBzdXBwb3J0cyB0d28gc2VwYXJhdGUgYHRpdGxlYCB0YWdzIHdoaWNoIGhhdmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgLy8gYSBkaWZmZXJlbnQgY29udGVudCB0eXBlOiBgSFRNTFRpdGxlRWxlbWVudGAgYW5kIGBTVkdUaXRsZUVsZW1lbnRgXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHsgZGVmYXVsdDogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhULCBzdmc6IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAndGV4dGFyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhULCBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBXZSBoYXZlIHRvIG1ha2UgYm90aCBhIGNhc2Utc2Vuc2l0aXZlIGFuZCBhIGNhc2UtaW5zZW5zaXRpdmUgbG9va3VwLCBiZWNhdXNlXG4gICAgLy8gSFRNTCB0YWcgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIHdoZXJlYXMgc29tZSBTVkcgdGFncyBhcmUgY2FzZSBzZW5zaXRpdmUuXG4gICAgcmV0dXJuIChfYiA9IChfYSA9IFRBR19ERUZJTklUSU9OU1t0YWdOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVEFHX0RFRklOSVRJT05TW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IF9ERUZBVUxUX1RBR19ERUZJTklUSU9OO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IF9TRUxFQ1RPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKCcoXFxcXDpub3RcXFxcKCl8JyArIC8vIDE6IFwiOm5vdChcIlxuICAgICcoKFtcXFxcLlxcXFwjXT8pWy1cXFxcd10rKXwnICsgLy8gMjogXCJ0YWdcIjsgMzogXCIuXCIvXCIjXCI7XG4gICAgLy8gXCItXCIgc2hvdWxkIGFwcGVhciBmaXJzdCBpbiB0aGUgcmVnZXhwIGJlbG93IGFzIEZGMzEgcGFyc2VzIFwiWy4tXFx3XVwiIGFzIGEgcmFuZ2VcbiAgICAvLyA0OiBhdHRyaWJ1dGU7IDU6IGF0dHJpYnV0ZV9zdHJpbmc7IDY6IGF0dHJpYnV0ZV92YWx1ZVxuICAgICcoPzpcXFxcWyhbLS5cXFxcdypcXFxcXFxcXCRdKykoPzo9KFtcXFwiXFwnXT8pKFteXFxcXF1cXFwiXFwnXSopXFxcXDUpP1xcXFxdKXwnICsgLy8gXCJbbmFtZV1cIiwgXCJbbmFtZT12YWx1ZV1cIixcbiAgICAvLyBcIltuYW1lPVwidmFsdWVcIl1cIixcbiAgICAvLyBcIltuYW1lPSd2YWx1ZSddXCJcbiAgICAnKFxcXFwpKXwnICsgLy8gNzogXCIpXCJcbiAgICAnKFxcXFxzKixcXFxccyopJywgLy8gODogXCIsXCJcbidnJyk7XG4vKipcbiAqIEEgY3NzIHNlbGVjdG9yIGNvbnRhaW5zIGFuIGVsZW1lbnQgbmFtZSxcbiAqIGNzcyBjbGFzc2VzIGFuZCBhdHRyaWJ1dGUvdmFsdWUgcGFpcnMgd2l0aCB0aGUgcHVycG9zZVxuICogb2Ygc2VsZWN0aW5nIHN1YnNldHMgb3V0IG9mIHRoZW0uXG4gKi9cbmNsYXNzIENzc1NlbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2VsZWN0b3JzIGFyZSBlbmNvZGVkIGluIHBhaXJzIHdoZXJlOlxuICAgICAgICAgKiAtIGV2ZW4gbG9jYXRpb25zIGFyZSBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgICAgICogLSBvZGQgbG9jYXRpb25zIGFyZSBhdHRyaWJ1dGUgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgKiBTZWxlY3RvcjogYFtrZXkxPXZhbHVlMV1ba2V5Ml1gIHdvdWxkIHBhcnNlIHRvOlxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICogWydrZXkxJywgJ3ZhbHVlMScsICdrZXkyJywgJyddXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdHRycyA9IFtdO1xuICAgICAgICB0aGlzLm5vdFNlbGVjdG9ycyA9IFtdO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2Uoc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBfYWRkUmVzdWx0ID0gKHJlcywgY3NzU2VsKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3NzU2VsLm5vdFNlbGVjdG9ycy5sZW5ndGggPiAwICYmICFjc3NTZWwuZWxlbWVudCAmJiBjc3NTZWwuY2xhc3NOYW1lcy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgIGNzc1NlbC5hdHRycy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGNzc1NlbC5lbGVtZW50ID0gJyonO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnB1c2goY3NzU2VsKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBjc3NTZWxlY3RvcjtcbiAgICAgICAgbGV0IGluTm90ID0gZmFsc2U7XG4gICAgICAgIF9TRUxFQ1RPUl9SRUdFWFAubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKG1hdGNoID0gX1NFTEVDVE9SX1JFR0VYUC5leGVjKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgaWYgKG1hdGNoWzEgLyogTk9UICovXSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RpbmcgOm5vdCBpbiBhIHNlbGVjdG9yIGlzIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluTm90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgICAgICAgICAgICAgY3NzU2VsZWN0b3Iubm90U2VsZWN0b3JzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBtYXRjaFsyIC8qIFRBRyAqL107XG4gICAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gbWF0Y2hbMyAvKiBQUkVGSVggKi9dO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAvLyAjaGFzaFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmFkZEF0dHJpYnV0ZSgnaWQnLCB0YWcuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJlZml4ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5hZGRDbGFzc05hbWUodGFnLnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0RWxlbWVudCh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG1hdGNoWzQgLyogQVRUUklCVVRFICovXTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmFkZEF0dHJpYnV0ZShjdXJyZW50LnVuZXNjYXBlQXR0cmlidXRlKGF0dHJpYnV0ZSksIG1hdGNoWzYgLyogQVRUUklCVVRFX1ZBTFVFICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNyAvKiBOT1RfRU5EICovXSkge1xuICAgICAgICAgICAgICAgIGluTm90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzggLyogU0VQQVJBVE9SICovXSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNlbGVjdG9ycyBpbiA6bm90IGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yID0gY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5lc2NhcGUgYFxcJGAgc2VxdWVuY2VzIGZyb20gdGhlIENTUyBhdHRyaWJ1dGUgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGAkYCBjYW4gaGF2ZSBhIHNwZWNpYWwgbWVhbmluZyBpbiBDU1Mgc2VsZWN0b3JzLFxuICAgICAqIGJ1dCB3ZSBtaWdodCB3YW50IHRvIG1hdGNoIGFuIGF0dHJpYnV0ZSB0aGF0IGNvbnRhaW5zIGAkYC5cbiAgICAgKiBbTUROIHdlYiBsaW5rIGZvciBtb3JlXG4gICAgICogaW5mb10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0F0dHJpYnV0ZV9zZWxlY3RvcnMpLlxuICAgICAqIEBwYXJhbSBhdHRyIHRoZSBhdHRyaWJ1dGUgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICovXG4gICAgdW5lc2NhcGVBdHRyaWJ1dGUoYXR0cikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBhdHRyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJyQnICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gYXR0cmlidXRlIHNlbGVjdG9yIFwiJHthdHRyfVwiLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFVuZXNjYXBlZCBcIiRcIiBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgZXNjYXBlIHdpdGggXCJcXFxcJFwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzY2FwZSBgJGAgc2VxdWVuY2VzIGZyb20gdGhlIENTUyBhdHRyaWJ1dGUgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGAkYCBjYW4gaGF2ZSBhIHNwZWNpYWwgbWVhbmluZyBpbiBDU1Mgc2VsZWN0b3JzLFxuICAgICAqIHdpdGggdGhpcyBtZXRob2Qgd2UgYXJlIGVzY2FwaW5nIGAkYCB3aXRoIGBcXCQnLlxuICAgICAqIFtNRE4gd2ViIGxpbmsgZm9yIG1vcmVcbiAgICAgKiBpbmZvXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQXR0cmlidXRlX3NlbGVjdG9ycykuXG4gICAgICogQHBhcmFtIGF0dHIgdGhlIGF0dHJpYnV0ZSB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGVzY2FwZUF0dHJpYnV0ZShhdHRyKSB7XG4gICAgICAgIHJldHVybiBhdHRyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFwkL2csICdcXFxcJCcpO1xuICAgIH1cbiAgICBpc0VsZW1lbnRTZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzRWxlbWVudFNlbGVjdG9yKCkgJiYgdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmIHRoaXMuYXR0cnMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgIHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaGFzRWxlbWVudFNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmVsZW1lbnQ7XG4gICAgfVxuICAgIHNldEVsZW1lbnQoZWxlbWVudCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9XG4gICAgLyoqIEdldHMgYSB0ZW1wbGF0ZSBzdHJpbmcgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci4gKi9cbiAgICBnZXRNYXRjaGluZ0VsZW1lbnRUZW1wbGF0ZSgpIHtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRoaXMuZWxlbWVudCB8fCAnZGl2JztcbiAgICAgICAgY29uc3QgY2xhc3NBdHRyID0gdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA+IDAgPyBgIGNsYXNzPVwiJHt0aGlzLmNsYXNzTmFtZXMuam9pbignICcpfVwiYCA6ICcnO1xuICAgICAgICBsZXQgYXR0cnMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICBjb25zdCBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXSAhPT0gJycgPyBgPVwiJHt0aGlzLmF0dHJzW2kgKyAxXX1cImAgOiAnJztcbiAgICAgICAgICAgIGF0dHJzICs9IGAgJHthdHRyTmFtZX0ke2F0dHJWYWx1ZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKS5pc1ZvaWQgPyBgPCR7dGFnTmFtZX0ke2NsYXNzQXR0cn0ke2F0dHJzfS8+YCA6XG4gICAgICAgICAgICBgPCR7dGFnTmFtZX0ke2NsYXNzQXR0cn0ke2F0dHJzfT48LyR7dGFnTmFtZX0+YDtcbiAgICB9XG4gICAgZ2V0QXR0cnMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdjbGFzcycsIHRoaXMuY2xhc3NOYW1lcy5qb2luKCcgJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KHRoaXMuYXR0cnMpO1xuICAgIH1cbiAgICBhZGRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPSAnJykge1xuICAgICAgICB0aGlzLmF0dHJzLnB1c2gobmFtZSwgdmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSB8fCAnJyk7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZShuYW1lKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5lbGVtZW50IHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZXMuZm9yRWFjaChrbGFzcyA9PiByZXMgKz0gYC4ke2tsYXNzfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5lc2NhcGVBdHRyaWJ1dGUodGhpcy5hdHRyc1tpXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICByZXMgKz0gYFske25hbWV9JHt2YWx1ZSA/ICc9JyArIHZhbHVlIDogJyd9XWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMuZm9yRWFjaChub3RTZWxlY3RvciA9PiByZXMgKz0gYDpub3QoJHtub3RTZWxlY3Rvcn0pYCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkcyBhIGxpc3Qgb2YgQ3NzU2VsZWN0b3JzIGFuZCBhbGxvd3MgdG8gY2FsY3VsYXRlIHdoaWNoIG9uZXNcbiAqIGFyZSBjb250YWluZWQgaW4gYSBnaXZlbiBDc3NTZWxlY3Rvci5cbiAqL1xuY2xhc3MgU2VsZWN0b3JNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFBhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NsYXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jbGFzc1BhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJWYWx1ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVOb3RNYXRjaGVyKG5vdFNlbGVjdG9ycykge1xuICAgICAgICBjb25zdCBub3RNYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICBub3RNYXRjaGVyLmFkZFNlbGVjdGFibGVzKG5vdFNlbGVjdG9ycywgbnVsbCk7XG4gICAgICAgIHJldHVybiBub3RNYXRjaGVyO1xuICAgIH1cbiAgICBhZGRTZWxlY3RhYmxlcyhjc3NTZWxlY3RvcnMsIGNhbGxiYWNrQ3R4dCkge1xuICAgICAgICBsZXQgbGlzdENvbnRleHQgPSBudWxsO1xuICAgICAgICBpZiAoY3NzU2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxpc3RDb250ZXh0ID0gbmV3IFNlbGVjdG9yTGlzdENvbnRleHQoY3NzU2VsZWN0b3JzKTtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RDb250ZXh0cy5wdXNoKGxpc3RDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkU2VsZWN0YWJsZShjc3NTZWxlY3RvcnNbaV0sIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvYmplY3QgdGhhdCBjYW4gYmUgZm91bmQgbGF0ZXIgb24gYnkgY2FsbGluZyBgbWF0Y2hgLlxuICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICovXG4gICAgX2FkZFNlbGVjdGFibGUoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgbGV0IG1hdGNoZXIgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IGNzc1NlbGVjdG9yLmNsYXNzTmFtZXM7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gY3NzU2VsZWN0b3IuYXR0cnM7XG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGUgPSBuZXcgU2VsZWN0b3JDb250ZXh0KGNzc1NlbGVjdG9yLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVGVybWluYWwgPSBhdHRycy5sZW5ndGggPT09IDAgJiYgY2xhc3NOYW1lcy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2VsZW1lbnRNYXAsIGVsZW1lbnQsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fZWxlbWVudFBhcnRpYWxNYXAsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGkgPT09IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2NsYXNzTWFwLCBjbGFzc05hbWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Rlcm1pbmFsID0gaSA9PT0gYXR0cnMubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtaW5hbFZhbHVlc01hcCA9IHRlcm1pbmFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbFZhbHVlc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxWYWx1ZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbE1hcC5zZXQobmFtZSwgdGVybWluYWxWYWx1ZXNNYXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlUGFydGlhbE1hcDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRpYWxWYWx1ZXNNYXAgPSBwYXJ0aWFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsVmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE1hcC5zZXQobmFtZSwgcGFydGlhbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkVGVybWluYWwobWFwLCBuYW1lLCBzZWxlY3RhYmxlKSB7XG4gICAgICAgIGxldCB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgfVxuICAgIF9hZGRQYXJ0aWFsKG1hcCwgbmFtZSkge1xuICAgICAgICBsZXQgbWF0Y2hlciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdmlhIGBhZGRTZWxlY3RhYmxlYFxuICAgICAqIHdob3NlIGNzcyBzZWxlY3RvciBpcyBjb250YWluZWQgaW4gdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cbiAgICAgKiBAcGFyYW0gY3NzU2VsZWN0b3IgQSBjc3Mgc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gbWF0Y2hlZENhbGxiYWNrIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IGhhbmRlZCBpbnRvIGBhZGRTZWxlY3RhYmxlYFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICovXG4gICAgbWF0Y2goY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcbiAgICAgICAgY29uc3QgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saXN0Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RDb250ZXh0c1tpXS5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fZWxlbWVudE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fZWxlbWVudFBhcnRpYWxNYXAsIGVsZW1lbnQsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVNYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgJycsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsVmFsdWVzTWFwID0gdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX21hdGNoVGVybWluYWwobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3RhYmxlcyA9IG1hcC5nZXQobmFtZSkgfHwgW107XG4gICAgICAgIGNvbnN0IHN0YXJTZWxlY3RhYmxlcyA9IG1hcC5nZXQoJyonKTtcbiAgICAgICAgaWYgKHN0YXJTZWxlY3RhYmxlcykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZXMgPSBzZWxlY3RhYmxlcy5jb25jYXQoc3RhclNlbGVjdGFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0YWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGFibGU7XG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2ldO1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZWN0YWJsZS5maW5hbGl6ZShjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9tYXRjaFBhcnRpYWwobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lc3RlZFNlbGVjdG9yID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFuZXN0ZWRTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGdldCByaWQgb2YgcmVjdXJzaW9uIGFuZCBtZWFzdXJlIGFnYWluXG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGRvbid0IHBhc3MgdGhlIHdob2xlIHNlbGVjdG9yIGludG8gdGhlIHJlY3Vyc2lvbixcbiAgICAgICAgLy8gYnV0IG9ubHkgdGhlIG5vdCBwcm9jZXNzZWQgcGFydHNcbiAgICAgICAgcmV0dXJuIG5lc3RlZFNlbGVjdG9yLm1hdGNoKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spO1xuICAgIH1cbn1cbmNsYXNzIFNlbGVjdG9yTGlzdENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9ycykge1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vIFN0b3JlIGNvbnRleHQgdG8gcGFzcyBiYWNrIHNlbGVjdG9yIGFuZCBjb250ZXh0IHdoZW4gYSBzZWxlY3RvciBpcyBtYXRjaGVkXG5jbGFzcyBTZWxlY3RvckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBjYkNvbnRleHQsIGxpc3RDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jYkNvbnRleHQgPSBjYkNvbnRleHQ7XG4gICAgICAgIHRoaXMubGlzdENvbnRleHQgPSBsaXN0Q29udGV4dDtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBzZWxlY3Rvci5ub3RTZWxlY3RvcnM7XG4gICAgfVxuICAgIGZpbmFsaXplKGNzc1NlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgKCF0aGlzLmxpc3RDb250ZXh0IHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xuICAgICAgICAgICAgY29uc3Qgbm90TWF0Y2hlciA9IFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyKHRoaXMubm90U2VsZWN0b3JzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICFub3RNYXRjaGVyLm1hdGNoKGNzc1NlbGVjdG9yLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIGNhbGxiYWNrICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLnNlbGVjdG9yLCB0aGlzLmNiQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gU3RvcmVzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBlbWl0RGlzdGluY3RDaGFuZ2VzT25seWAgd2hlbiB0aGUgYGVtaXREaXN0aW5jdENoYW5nZXNPbmx5YCBpcyBub3Rcbi8vIGV4cGxpY2l0bHkgc2V0LlxuY29uc3QgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlEZWZhdWx0VmFsdWUgPSB0cnVlO1xudmFyIFZpZXdFbmNhcHN1bGF0aW9uO1xuKGZ1bmN0aW9uIChWaWV3RW5jYXBzdWxhdGlvbikge1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiRW11bGF0ZWRcIl0gPSAwXSA9IFwiRW11bGF0ZWRcIjtcbiAgICAvLyBIaXN0b3JpY2FsbHkgdGhlIDEgdmFsdWUgd2FzIGZvciBgTmF0aXZlYCBlbmNhcHN1bGF0aW9uIHdoaWNoIGhhcyBiZWVuIHJlbW92ZWQgYXMgb2YgdjExLlxuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiTm9uZVwiXSA9IDJdID0gXCJOb25lXCI7XG4gICAgVmlld0VuY2Fwc3VsYXRpb25bVmlld0VuY2Fwc3VsYXRpb25bXCJTaGFkb3dEb21cIl0gPSAzXSA9IFwiU2hhZG93RG9tXCI7XG59KShWaWV3RW5jYXBzdWxhdGlvbiB8fCAoVmlld0VuY2Fwc3VsYXRpb24gPSB7fSkpO1xudmFyIENoYW5nZURldGVjdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiT25QdXNoXCJdID0gMF0gPSBcIk9uUHVzaFwiO1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiRGVmYXVsdFwiXSA9IDFdID0gXCJEZWZhdWx0XCI7XG59KShDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB8fCAoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7fSkpO1xuY29uc3QgQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQSA9IHtcbiAgICBuYW1lOiAnY3VzdG9tLWVsZW1lbnRzJ1xufTtcbmNvbnN0IE5PX0VSUk9SU19TQ0hFTUEgPSB7XG4gICAgbmFtZTogJ25vLWVycm9ycy1zY2hlbWEnXG59O1xuY29uc3QgVHlwZSQxID0gRnVuY3Rpb247XG52YXIgU2VjdXJpdHlDb250ZXh0O1xuKGZ1bmN0aW9uIChTZWN1cml0eUNvbnRleHQpIHtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIkhUTUxcIl0gPSAxXSA9IFwiSFRNTFwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJTVFlMRVwiXSA9IDJdID0gXCJTVFlMRVwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJTQ1JJUFRcIl0gPSAzXSA9IFwiU0NSSVBUXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlVSTFwiXSA9IDRdID0gXCJVUkxcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiUkVTT1VSQ0VfVVJMXCJdID0gNV0gPSBcIlJFU09VUkNFX1VSTFwiO1xufSkoU2VjdXJpdHlDb250ZXh0IHx8IChTZWN1cml0eUNvbnRleHQgPSB7fSkpO1xudmFyIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSkge1xuICAgIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5W01pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5W1wiRXJyb3JcIl0gPSAwXSA9IFwiRXJyb3JcIjtcbiAgICBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtcIldhcm5pbmdcIl0gPSAxXSA9IFwiV2FybmluZ1wiO1xuICAgIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5W01pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5W1wiSWdub3JlXCJdID0gMl0gPSBcIklnbm9yZVwiO1xufSkoTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgfHwgKE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0ge30pKTtcbmZ1bmN0aW9uIHBhcnNlclNlbGVjdG9yVG9TaW1wbGVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBzZWxlY3Rvci5jbGFzc05hbWVzICYmIHNlbGVjdG9yLmNsYXNzTmFtZXMubGVuZ3RoID9cbiAgICAgICAgWzggLyogQ0xBU1MgKi8sIC4uLnNlbGVjdG9yLmNsYXNzTmFtZXNdIDpcbiAgICAgICAgW107XG4gICAgY29uc3QgZWxlbWVudE5hbWUgPSBzZWxlY3Rvci5lbGVtZW50ICYmIHNlbGVjdG9yLmVsZW1lbnQgIT09ICcqJyA/IHNlbGVjdG9yLmVsZW1lbnQgOiAnJztcbiAgICByZXR1cm4gW2VsZW1lbnROYW1lLCAuLi5zZWxlY3Rvci5hdHRycywgLi4uY2xhc3Nlc107XG59XG5mdW5jdGlvbiBwYXJzZXJTZWxlY3RvclRvTmVnYXRpdmVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBzZWxlY3Rvci5jbGFzc05hbWVzICYmIHNlbGVjdG9yLmNsYXNzTmFtZXMubGVuZ3RoID9cbiAgICAgICAgWzggLyogQ0xBU1MgKi8sIC4uLnNlbGVjdG9yLmNsYXNzTmFtZXNdIDpcbiAgICAgICAgW107XG4gICAgaWYgKHNlbGVjdG9yLmVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDEgLyogTk9UICovIHwgNCAvKiBFTEVNRU5UICovLCBzZWxlY3Rvci5lbGVtZW50LCAuLi5zZWxlY3Rvci5hdHRycywgLi4uY2xhc3Nlc1xuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3Rvci5hdHRycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFsxIC8qIE5PVCAqLyB8IDIgLyogQVRUUklCVVRFICovLCAuLi5zZWxlY3Rvci5hdHRycywgLi4uY2xhc3Nlc107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IuY2xhc3NOYW1lcyAmJiBzZWxlY3Rvci5jbGFzc05hbWVzLmxlbmd0aCA/XG4gICAgICAgICAgICBbMSAvKiBOT1QgKi8gfCA4IC8qIENMQVNTICovLCAuLi5zZWxlY3Rvci5jbGFzc05hbWVzXSA6XG4gICAgICAgICAgICBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZXJTZWxlY3RvclRvUjNTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGNvbnN0IHBvc2l0aXZlID0gcGFyc2VyU2VsZWN0b3JUb1NpbXBsZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBjb25zdCBuZWdhdGl2ZSA9IHNlbGVjdG9yLm5vdFNlbGVjdG9ycyAmJiBzZWxlY3Rvci5ub3RTZWxlY3RvcnMubGVuZ3RoID9cbiAgICAgICAgc2VsZWN0b3Iubm90U2VsZWN0b3JzLm1hcChub3RTZWxlY3RvciA9PiBwYXJzZXJTZWxlY3RvclRvTmVnYXRpdmVTZWxlY3Rvcihub3RTZWxlY3RvcikpIDpcbiAgICAgICAgW107XG4gICAgcmV0dXJuIHBvc2l0aXZlLmNvbmNhdCguLi5uZWdhdGl2ZSk7XG59XG5mdW5jdGlvbiBwYXJzZVNlbGVjdG9yVG9SM1NlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yID8gQ3NzU2VsZWN0b3IucGFyc2Uoc2VsZWN0b3IpLm1hcChwYXJzZXJTZWxlY3RvclRvUjNTZWxlY3RvcikgOiBbXTtcbn1cblxudmFyIGNvcmUgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGVtaXREaXN0aW5jdENoYW5nZXNPbmx5RGVmYXVsdFZhbHVlOiBlbWl0RGlzdGluY3RDaGFuZ2VzT25seURlZmF1bHRWYWx1ZSxcbiAgICBnZXQgVmlld0VuY2Fwc3VsYXRpb24gKCkgeyByZXR1cm4gVmlld0VuY2Fwc3VsYXRpb247IH0sXG4gICAgZ2V0IENoYW5nZURldGVjdGlvblN0cmF0ZWd5ICgpIHsgcmV0dXJuIENoYW5nZURldGVjdGlvblN0cmF0ZWd5OyB9LFxuICAgIENVU1RPTV9FTEVNRU5UU19TQ0hFTUE6IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsXG4gICAgTk9fRVJST1JTX1NDSEVNQTogTk9fRVJST1JTX1NDSEVNQSxcbiAgICBUeXBlOiBUeXBlJDEsXG4gICAgZ2V0IFNlY3VyaXR5Q29udGV4dCAoKSB7IHJldHVybiBTZWN1cml0eUNvbnRleHQ7IH0sXG4gICAgZ2V0IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ICgpIHsgcmV0dXJuIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5OyB9LFxuICAgIHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3I6IHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3Jcbn0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IERBU0hfQ0FTRV9SRUdFWFAgPSAvLSsoW2EtejAtOV0pL2c7XG5mdW5jdGlvbiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoREFTSF9DQVNFX1JFR0VYUCwgKC4uLm0pID0+IG1bMV0udG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBzcGxpdEF0Q29sb24oaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICByZXR1cm4gX3NwbGl0QXQoaW5wdXQsICc6JywgZGVmYXVsdFZhbHVlcyk7XG59XG5mdW5jdGlvbiBzcGxpdEF0UGVyaW9kKGlucHV0LCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgcmV0dXJuIF9zcGxpdEF0KGlucHV0LCAnLicsIGRlZmF1bHRWYWx1ZXMpO1xufVxuZnVuY3Rpb24gX3NwbGl0QXQoaW5wdXQsIGNoYXJhY3RlciwgZGVmYXVsdFZhbHVlcykge1xuICAgIGNvbnN0IGNoYXJhY3RlckluZGV4ID0gaW5wdXQuaW5kZXhPZihjaGFyYWN0ZXIpO1xuICAgIGlmIChjaGFyYWN0ZXJJbmRleCA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG4gICAgcmV0dXJuIFtpbnB1dC5zbGljZSgwLCBjaGFyYWN0ZXJJbmRleCkudHJpbSgpLCBpbnB1dC5zbGljZShjaGFyYWN0ZXJJbmRleCArIDEpLnRyaW0oKV07XG59XG5mdW5jdGlvbiBub1VuZGVmaW5lZCh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsO1xufVxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBFcnJvcjogJHttc2d9YCk7XG59XG4vLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYSBzcGVjaWFsIG1lYW5pbmcgaW4gUmVndWxhciBFeHByZXNzaW9uc1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xcXVxcL1xcXFxdKS9nLCAnXFxcXCQxJyk7XG59XG5mdW5jdGlvbiB1dGY4RW5jb2RlKHN0cikge1xuICAgIGxldCBlbmNvZGVkID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgbGV0IGNvZGVQb2ludCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgLy8gZGVjb2RlIHN1cnJvZ2F0ZVxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMHhkODAwICYmIGNvZGVQb2ludCA8PSAweGRiZmYgJiYgc3RyLmxlbmd0aCA+IChpbmRleCArIDEpKSB7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKGxvdyA+PSAweGRjMDAgJiYgbG93IDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gKChjb2RlUG9pbnQgLSAweGQ4MDApIDw8IDEwKSArIGxvdyAtIDB4ZGMwMCArIDB4MTAwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweDdmKSB7XG4gICAgICAgICAgICBlbmNvZGVkLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHg3ZmYpIHtcbiAgICAgICAgICAgIGVuY29kZWQucHVzaCgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhjMCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgZW5jb2RlZC5wdXNoKChjb2RlUG9pbnQgPj4gMTIpIHwgMHhlMCwgKChjb2RlUG9pbnQgPj4gNikgJiAweDNmKSB8IDB4ODAsIChjb2RlUG9pbnQgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDFmZmZmZikge1xuICAgICAgICAgICAgZW5jb2RlZC5wdXNoKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhmMCwgKChjb2RlUG9pbnQgPj4gMTIpICYgMHgzZikgfCAweDgwLCAoKGNvZGVQb2ludCA+PiA2KSAmIDB4M2YpIHwgMHg4MCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgICByZXR1cm4gJ1snICsgdG9rZW4ubWFwKHN0cmluZ2lmeSkuam9pbignLCAnKSArICddJztcbiAgICB9XG4gICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XG4gICAgfVxuICAgIGlmICh0b2tlbi5vdmVycmlkZGVuTmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7dG9rZW4ub3ZlcnJpZGRlbk5hbWV9YDtcbiAgICB9XG4gICAgaWYgKHRva2VuLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3Rva2VuLm5hbWV9YDtcbiAgICB9XG4gICAgaWYgKCF0b2tlbi50b1N0cmluZykge1xuICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIC8vIFdBUk5JTkc6IGRvIG5vdCB0cnkgdG8gYEpTT04uc3RyaW5naWZ5KHRva2VuKWAgaGVyZVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMzQ0MFxuICAgIGNvbnN0IHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHJlcztcbiAgICB9XG4gICAgY29uc3QgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoJ1xcbicpO1xuICAgIHJldHVybiBuZXdMaW5lSW5kZXggPT09IC0xID8gcmVzIDogcmVzLnN1YnN0cmluZygwLCBuZXdMaW5lSW5kZXgpO1xufVxuY2xhc3MgVmVyc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZnVsbCkge1xuICAgICAgICB0aGlzLmZ1bGwgPSBmdWxsO1xuICAgICAgICBjb25zdCBzcGxpdHMgPSBmdWxsLnNwbGl0KCcuJyk7XG4gICAgICAgIHRoaXMubWFqb3IgPSBzcGxpdHNbMF07XG4gICAgICAgIHRoaXMubWlub3IgPSBzcGxpdHNbMV07XG4gICAgICAgIHRoaXMucGF0Y2ggPSBzcGxpdHMuc2xpY2UoMikuam9pbignLicpO1xuICAgIH1cbn1cbmNvbnN0IF9fd2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93O1xuY29uc3QgX19zZWxmID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiYgc2VsZjtcbmNvbnN0IF9fZ2xvYmFsID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsO1xuLy8gQ2hlY2sgX19nbG9iYWwgZmlyc3QsIGJlY2F1c2UgaW4gTm9kZSB0ZXN0cyBib3RoIF9fZ2xvYmFsIGFuZCBfX3dpbmRvdyBtYXkgYmUgZGVmaW5lZCBhbmQgX2dsb2JhbFxuLy8gc2hvdWxkIGJlIF9fZ2xvYmFsIGluIHRoYXQgY2FzZS5cbmNvbnN0IF9nbG9iYWwgPSBfX2dsb2JhbCB8fCBfX3dpbmRvdyB8fCBfX3NlbGY7XG5mdW5jdGlvbiBuZXdBcnJheShzaXplLCB2YWx1ZSkge1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBsaXN0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogUGFydGl0aW9ucyBhIGdpdmVuIGFycmF5IGludG8gMiBhcnJheXMsIGJhc2VkIG9uIGEgYm9vbGVhbiB2YWx1ZSByZXR1cm5lZCBieSB0aGUgY29uZGl0aW9uXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gYXJyIElucHV0IGFycmF5IHRoYXQgc2hvdWxkIGJlIHBhcnRpdGlvbmVkXG4gKiBAcGFyYW0gY29uZGl0aW9uRm4gQ29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBlYWNoIGl0ZW0gaW4gYSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJ0aXRpb25BcnJheShhcnIsIGNvbmRpdGlvbkZuKSB7XG4gICAgY29uc3QgdHJ1dGh5ID0gW107XG4gICAgY29uc3QgZmFsc3kgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICAgIChjb25kaXRpb25GbihpdGVtKSA/IHRydXRoeSA6IGZhbHN5KS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gW3RydXRoeSwgZmFsc3ldO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhIGJpZyBpbnRlZ2VyIHVzaW5nIGEgYnVmZmVyIG9mIGl0cyBpbmRpdmlkdWFsIGRpZ2l0cywgd2l0aCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnRcbiAqIGRpZ2l0IHN0b3JlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSAobGl0dGxlIGVuZGlhbikuXG4gKlxuICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGVhY2ggaW5zdGFuY2UgaXMgbXV0YWJsZS4gVGhlIGFkZGl0aW9uIG9wZXJhdGlvbiBjYW4gYmUgZG9uZSBpbi1wbGFjZVxuICogdG8gcmVkdWNlIG1lbW9yeSBwcmVzc3VyZSBvZiBhbGxvY2F0aW9uIGZvciB0aGUgZGlnaXRzIGFycmF5LlxuICovXG5jbGFzcyBCaWdJbnRlZ2VyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmlnIGludGVnZXIgdXNpbmcgaXRzIGluZGl2aWR1YWwgZGlnaXRzIGluIGxpdHRsZSBlbmRpYW4gc3RvcmFnZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkaWdpdHMpIHtcbiAgICAgICAgdGhpcy5kaWdpdHMgPSBkaWdpdHM7XG4gICAgfVxuICAgIHN0YXRpYyB6ZXJvKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoWzBdKTtcbiAgICB9XG4gICAgc3RhdGljIG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFsxXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy5kaWdpdHMuc2xpY2UoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYmlnIGludGVnZXIgd2l0aCB0aGUgc3VtIG9mIGB0aGlzYCBhbmQgYG90aGVyYCBhcyBpdHMgdmFsdWUuIFRoaXMgZG9lcyBub3QgbXV0YXRlXG4gICAgICogYHRoaXNgIGJ1dCBpbnN0ZWFkIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIHVubGlrZSBgYWRkVG9TZWxmYC5cbiAgICAgKi9cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuYWRkVG9TZWxmKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBgb3RoZXJgIHRvIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHRoZXJlYnkgbXV0YXRpbmcgaXRzIHZhbHVlLlxuICAgICAqL1xuICAgIGFkZFRvU2VsZihvdGhlcikge1xuICAgICAgICBjb25zdCBtYXhOck9mRGlnaXRzID0gTWF0aC5tYXgodGhpcy5kaWdpdHMubGVuZ3RoLCBvdGhlci5kaWdpdHMubGVuZ3RoKTtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhOck9mRGlnaXRzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkaWdpdFN1bSA9IGNhcnJ5O1xuICAgICAgICAgICAgaWYgKGkgPCB0aGlzLmRpZ2l0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkaWdpdFN1bSArPSB0aGlzLmRpZ2l0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgb3RoZXIuZGlnaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0U3VtICs9IG90aGVyLmRpZ2l0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWdpdFN1bSA+PSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlnaXRzW2ldID0gZGlnaXRTdW0gLSAxMDtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpZ2l0c1tpXSA9IGRpZ2l0U3VtO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBseSBhIHJlbWFpbmluZyBjYXJyeSBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGlnaXRzW21heE5yT2ZEaWdpdHNdID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIGRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWcgaW50ZWdlci4gQXMgdGhpcyBpcyBzdG9yZWQgaW5cbiAgICAgKiBsaXR0bGUgZW5kaWFuLCB0aGUgZGlnaXRzIGFyZSBjb25jYXRlbmF0ZWQgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlcyArPSB0aGlzLmRpZ2l0c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGJpZyBpbnRlZ2VyIHdoaWNoIGlzIG9wdGltaXplZCBmb3IgbXVsdGlwbGljYXRpb24gb3BlcmF0aW9ucywgYXMgaXRzIHBvd2VyLW9mLXR3b3NcbiAqIGFyZSBtZW1vaXplZC4gU2VlIGBtdWx0aXBseUJ5KClgIGZvciBkZXRhaWxzIG9uIHRoZSBtdWx0aXBsaWNhdGlvbiBhbGdvcml0aG0uXG4gKi9cbmNsYXNzIEJpZ0ludEZvck11bHRpcGxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnBvd2VyT2ZUd29zID0gW3ZhbHVlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmlnIGludGVnZXIgaXRzZWxmLlxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3dlck9mVHdvc1swXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHZhbHVlIGZvciBgbnVtICogYmAsIHdoZXJlIGBudW1gIGlzIGEgSlMgbnVtYmVyIGFuZCBgYmAgaXMgYSBiaWcgaW50ZWdlci4gVGhlXG4gICAgICogdmFsdWUgZm9yIGBiYCBpcyByZXByZXNlbnRlZCBieSBhIHN0b3JhZ2UgbW9kZWwgdGhhdCBpcyBvcHRpbWl6ZWQgZm9yIHRoaXMgY29tcHV0YXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBpbiBOKGxvZzIobnVtKSkgYnkgY29udGludW91cyBoYWx2aW5nIG9mIHRoZSBudW1iZXIsIHdoZXJlIHRoZVxuICAgICAqIGxlYXN0LXNpZ25pZmljYW50IGJpdCAoTFNCKSBpcyB0ZXN0ZWQgaW4gZWFjaCBpdGVyYXRpb24uIElmIHRoZSBiaXQgaXMgc2V0LCB0aGUgYml0J3MgaW5kZXggaXNcbiAgICAgKiB1c2VkIGFzIGV4cG9uZW50IGludG8gdGhlIHBvd2VyLW9mLXR3byBtdWx0aXBsaWNhdGlvbiBvZiBgYmAuXG4gICAgICpcbiAgICAgKiBBcyBhbiBleGFtcGxlLCBjb25zaWRlciB0aGUgbXVsdGlwbGljYXRpb24gbnVtPTQyLCBiPTEzMzcuIEluIGJpbmFyeSA0MiBpcyAwYjAwMTAxMDEwIGFuZCB0aGVcbiAgICAgKiBhbGdvcml0aG0gdW5yb2xscyBpbnRvIHRoZSBmb2xsb3dpbmcgaXRlcmF0aW9uczpcbiAgICAgKlxuICAgICAqICBJdGVyYXRpb24gfCBudW0gICAgICAgIHwgTFNCICB8IGIgKiAyXml0ZXIgfCBBZGQ/IHwgcHJvZHVjdFxuICAgICAqIC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLXwtLS0tLS18LS0tLS0tLS0tLS0tfC0tLS0tLXwtLS0tLS0tLVxuICAgICAqICAwICAgICAgICAgfCAwYjAwMTAxMDEwIHwgMCAgICB8IDEzMzcgICAgICAgfCBObyAgIHwgMFxuICAgICAqICAxICAgICAgICAgfCAwYjAwMDEwMTAxIHwgMSAgICB8IDI2NzQgICAgICAgfCBZZXMgIHwgMjY3NFxuICAgICAqICAyICAgICAgICAgfCAwYjAwMDAxMDEwIHwgMCAgICB8IDUzNDggICAgICAgfCBObyAgIHwgMjY3NFxuICAgICAqICAzICAgICAgICAgfCAwYjAwMDAwMTAxIHwgMSAgICB8IDEwNjk2ICAgICAgfCBZZXMgIHwgMTMzNzBcbiAgICAgKiAgNCAgICAgICAgIHwgMGIwMDAwMDAxMCB8IDAgICAgfCAyMTM5MiAgICAgIHwgTm8gICB8IDEzMzcwXG4gICAgICogIDUgICAgICAgICB8IDBiMDAwMDAwMDEgfCAxICAgIHwgNDI3ODQgICAgICB8IFllcyAgfCA1NjE1NFxuICAgICAqICA2ICAgICAgICAgfCAwYjAwMDAwMDAwIHwgMCAgICB8IDg1NTY4ICAgICAgfCBObyAgIHwgNTYxNTRcbiAgICAgKlxuICAgICAqIFRoZSBjb21wdXRlZCBwcm9kdWN0IG9mIDU2MTU0IGlzIGluZGVlZCB0aGUgY29ycmVjdCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBUaGUgYEJpZ0ludEZvck11bHRpcGxpY2F0aW9uYCByZXByZXNlbnRhdGlvbiBmb3IgYSBiaWcgaW50ZWdlciBwcm92aWRlcyBtZW1vaXplZCBhY2Nlc3MgdG8gdGhlXG4gICAgICogcG93ZXItb2YtdHdvIHZhbHVlcyB0byByZWR1Y2UgdGhlIHdvcmtsb2FkIGluIGNvbXB1dGluZyB0aG9zZSB2YWx1ZXMuXG4gICAgICovXG4gICAgbXVsdGlwbHlCeShudW0pIHtcbiAgICAgICAgY29uc3QgcHJvZHVjdCA9IEJpZ0ludGVnZXIuemVybygpO1xuICAgICAgICB0aGlzLm11bHRpcGx5QnlBbmRBZGRUbyhudW0sIHByb2R1Y3QpO1xuICAgICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VlIGBtdWx0aXBseUJ5KClgIGZvciBkZXRhaWxzLiBUaGlzIGZ1bmN0aW9uIGFsbG93cyBmb3IgdGhlIGNvbXB1dGVkIHByb2R1Y3QgdG8gYmUgYWRkZWRcbiAgICAgKiBkaXJlY3RseSB0byB0aGUgcHJvdmlkZWQgcmVzdWx0IGJpZyBpbnRlZ2VyLlxuICAgICAqL1xuICAgIG11bHRpcGx5QnlBbmRBZGRUbyhudW0sIHJlc3VsdCkge1xuICAgICAgICBmb3IgKGxldCBleHBvbmVudCA9IDA7IG51bSAhPT0gMDsgbnVtID0gbnVtID4+PiAxLCBleHBvbmVudCsrKSB7XG4gICAgICAgICAgICBpZiAobnVtICYgMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRNdWx0aXBsaWVkQnlQb3dlck9mVHdvKGV4cG9uZW50KTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkVG9TZWxmKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhbmQgbWVtb2l6ZXMgdGhlIGJpZyBpbnRlZ2VyIHZhbHVlIGZvciBgdGhpcy5udW1iZXIgKiAyXmV4cG9uZW50YC5cbiAgICAgKi9cbiAgICBnZXRNdWx0aXBsaWVkQnlQb3dlck9mVHdvKGV4cG9uZW50KSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBvd2VycyB1cCB1bnRpbCB0aGUgcmVxdWVzdGVkIGV4cG9uZW50LCB3aGVyZSBlYWNoIHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gaXRzXG4gICAgICAgIC8vIHByZWRlY2Vzc29yLiBUaGlzIGlzIHNpbXBsZSBhcyBgdGhpcy5udW1iZXIgKiAyXihleHBvbmVudCAtIDEpYCBvbmx5IGhhcyB0byBiZSBkb3VibGVkIChpLmUuXG4gICAgICAgIC8vIGFkZGVkIHRvIGl0c2VsZikgdG8gcmVhY2ggYHRoaXMubnVtYmVyICogMl5leHBvbmVudGAuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBvd2VyT2ZUd29zLmxlbmd0aDsgaSA8PSBleHBvbmVudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1Bvd2VyID0gdGhpcy5wb3dlck9mVHdvc1tpIC0gMV07XG4gICAgICAgICAgICB0aGlzLnBvd2VyT2ZUd29zW2ldID0gcHJldmlvdXNQb3dlci5hZGQocHJldmlvdXNQb3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG93ZXJPZlR3b3NbZXhwb25lbnRdO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleHBvbmVudGlhdGlvbiBvcGVyYXRpb24gZm9yIHRoZSBwcm92aWRlZCBiYXNlLCBvZiB3aGljaCBleHBvbmVudHMgYXJlIGNvbXB1dGVkIGFuZFxuICogbWVtb2l6ZWQuIFRoZSByZXN1bHRzIGFyZSByZXByZXNlbnRlZCBieSBhIGBCaWdJbnRGb3JNdWx0aXBsaWNhdGlvbmAgd2hpY2ggaXMgdGFpbG9yZWQgZm9yXG4gKiBtdWx0aXBsaWNhdGlvbiBvcGVyYXRpb25zIGJ5IG1lbW9pemluZyB0aGUgcG93ZXItb2YtdHdvcy4gVGhpcyBlZmZlY3RpdmVseSByZXN1bHRzIGluIGEgbWF0cml4XG4gKiByZXByZXNlbnRhdGlvbiB0aGF0IGlzIGxhemlseSBjb21wdXRlZCB1cG9uIHJlcXVlc3QuXG4gKi9cbmNsYXNzIEJpZ0ludEV4cG9uZW50aWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlKSB7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMuZXhwb25lbnRzID0gW25ldyBCaWdJbnRGb3JNdWx0aXBsaWNhdGlvbihCaWdJbnRlZ2VyLm9uZSgpKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHZhbHVlIGZvciBgdGhpcy5iYXNlXmV4cG9uZW50YCwgcmVzdWx0aW5nIGluIGEgYmlnIGludGVnZXIgdGhhdCBpcyBvcHRpbWl6ZWQgZm9yXG4gICAgICogZnVydGhlciBtdWx0aXBsaWNhdGlvbiBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIHRvVGhlUG93ZXJPZihleHBvbmVudCkge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSByZXN1bHRzIHVwIHVudGlsIHRoZSByZXF1ZXN0ZWQgZXhwb25lbnQsIHdoZXJlIGV2ZXJ5IHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gaXRzXG4gICAgICAgIC8vIHByZWRlY2Vzc29yLiBUaGlzIGlzIGJlY2F1c2UgYHRoaXMuYmFzZV4oZXhwb25lbnQgLSAxKWAgb25seSBoYXMgdG8gYmUgbXVsdGlwbGllZCBieSBgYmFzZWBcbiAgICAgICAgLy8gdG8gcmVhY2ggYHRoaXMuYmFzZV5leHBvbmVudGAuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmV4cG9uZW50cy5sZW5ndGg7IGkgPD0gZXhwb25lbnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmV4cG9uZW50c1tpIC0gMV0ubXVsdGlwbHlCeSh0aGlzLmJhc2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvbmVudHNbaV0gPSBuZXcgQmlnSW50Rm9yTXVsdGlwbGljYXRpb24odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9uZW50c1tleHBvbmVudF07XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogUmV0dXJuIHRoZSBtZXNzYWdlIGlkIG9yIGNvbXB1dGUgaXQgdXNpbmcgdGhlIFhMSUZGMSBkaWdlc3QuXG4gKi9cbmZ1bmN0aW9uIGRpZ2VzdCQxKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5pZCB8fCBjb21wdXRlRGlnZXN0KG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBtZXNzYWdlIGlkIHVzaW5nIHRoZSBYTElGRjEgZGlnZXN0LlxuICovXG5mdW5jdGlvbiBjb21wdXRlRGlnZXN0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gc2hhMShzZXJpYWxpemVOb2RlcyhtZXNzYWdlLm5vZGVzKS5qb2luKCcnKSArIGBbJHttZXNzYWdlLm1lYW5pbmd9XWApO1xufVxuLyoqXG4gKiBSZXR1cm4gdGhlIG1lc3NhZ2UgaWQgb3IgY29tcHV0ZSBpdCB1c2luZyB0aGUgWExJRkYyL1hNQi8kbG9jYWxpemUgZGlnZXN0LlxuICovXG5mdW5jdGlvbiBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5pZCB8fCBjb21wdXRlRGVjaW1hbERpZ2VzdChtZXNzYWdlKTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWVzc2FnZSBpZCB1c2luZyB0aGUgWExJRkYyL1hNQi8kbG9jYWxpemUgZGlnZXN0LlxuICovXG5mdW5jdGlvbiBjb21wdXRlRGVjaW1hbERpZ2VzdChtZXNzYWdlKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IoKTtcbiAgICBjb25zdCBwYXJ0cyA9IG1lc3NhZ2Uubm9kZXMubWFwKGEgPT4gYS52aXNpdCh2aXNpdG9yLCBudWxsKSk7XG4gICAgcmV0dXJuIGNvbXB1dGVNc2dJZChwYXJ0cy5qb2luKCcnKSwgbWVzc2FnZS5tZWFuaW5nKTtcbn1cbi8qKlxuICogU2VyaWFsaXplIHRoZSBpMThuIGFzdCB0byBzb21ldGhpbmcgeG1sLWxpa2UgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgYW4gVUlELlxuICpcbiAqIFRoZSB2aXNpdG9yIGlzIGFsc28gdXNlZCBpbiB0aGUgaTE4biBwYXJzZXIgdGVzdHNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgX1NlcmlhbGl6ZXJWaXNpdG9yIHtcbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBgWyR7Y29udGFpbmVyLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSkuam9pbignLCAnKX1dYDtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoKGspID0+IGAke2t9IHske2ljdS5jYXNlc1trXS52aXNpdCh0aGlzKX19YCk7XG4gICAgICAgIHJldHVybiBgeyR7aWN1LmV4cHJlc3Npb259LCAke2ljdS50eXBlfSwgJHtzdHJDYXNlcy5qb2luKCcsICcpfX1gO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBwaC5pc1ZvaWQgP1xuICAgICAgICAgICAgYDxwaCB0YWcgbmFtZT1cIiR7cGguc3RhcnROYW1lfVwiLz5gIDpcbiAgICAgICAgICAgIGA8cGggdGFnIG5hbWU9XCIke3BoLnN0YXJ0TmFtZX1cIj4ke3BoLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSkuam9pbignLCAnKX08L3BoIG5hbWU9XCIke3BoLmNsb3NlTmFtZX1cIj5gO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBwaC52YWx1ZSA/IGA8cGggbmFtZT1cIiR7cGgubmFtZX1cIj4ke3BoLnZhbHVlfTwvcGg+YCA6IGA8cGggbmFtZT1cIiR7cGgubmFtZX1cIi8+YDtcbiAgICB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYDxwaCBpY3UgbmFtZT1cIiR7cGgubmFtZX1cIj4ke3BoLnZhbHVlLnZpc2l0KHRoaXMpfTwvcGg+YDtcbiAgICB9XG59XG5jb25zdCBzZXJpYWxpemVyVmlzaXRvciQxID0gbmV3IF9TZXJpYWxpemVyVmlzaXRvcigpO1xuZnVuY3Rpb24gc2VyaWFsaXplTm9kZXMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKGEgPT4gYS52aXNpdChzZXJpYWxpemVyVmlzaXRvciQxLCBudWxsKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgaTE4biBhc3QgdG8gc29tZXRoaW5nIHhtbC1saWtlIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIFVJRC5cbiAqXG4gKiBJZ25vcmUgdGhlIElDVSBleHByZXNzaW9ucyBzbyB0aGF0IG1lc3NhZ2UgSURzIHN0YXlzIGlkZW50aWNhbCBpZiBvbmx5IHRoZSBleHByZXNzaW9uIGNoYW5nZXMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvciBleHRlbmRzIF9TZXJpYWxpemVyVmlzaXRvciB7XG4gICAgdmlzaXRJY3UoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKChrKSA9PiBgJHtrfSB7JHtpY3UuY2FzZXNba10udmlzaXQodGhpcyl9fWApO1xuICAgICAgICAvLyBEbyBub3QgdGFrZSB0aGUgZXhwcmVzc2lvbiBpbnRvIGFjY291bnRcbiAgICAgICAgcmV0dXJuIGB7JHtpY3UudHlwZX0sICR7c3RyQ2FzZXMuam9pbignLCAnKX19YDtcbiAgICB9XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIFNIQTEgb2YgdGhlIGdpdmVuIHN0cmluZ1xuICpcbiAqIHNlZSBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC00L2ZpcHMtMTgwLTQucGRmXG4gKlxuICogV0FSTklORzogdGhpcyBmdW5jdGlvbiBoYXMgbm90IGJlZW4gZGVzaWduZWQgbm90IHRlc3RlZCB3aXRoIHNlY3VyaXR5IGluIG1pbmQuXG4gKiAgICAgICAgICBETyBOT1QgVVNFIElUIElOIEEgU0VDVVJJVFkgU0VOU0lUSVZFIENPTlRFWFQuXG4gKi9cbmZ1bmN0aW9uIHNoYTEoc3RyKSB7XG4gICAgY29uc3QgdXRmOCA9IHV0ZjhFbmNvZGUoc3RyKTtcbiAgICBjb25zdCB3b3JkczMyID0gYnl0ZXNUb1dvcmRzMzIodXRmOCwgRW5kaWFuLkJpZyk7XG4gICAgY29uc3QgbGVuID0gdXRmOC5sZW5ndGggKiA4O1xuICAgIGNvbnN0IHcgPSBuZXdBcnJheSg4MCk7XG4gICAgbGV0IGEgPSAweDY3NDUyMzAxLCBiID0gMHhlZmNkYWI4OSwgYyA9IDB4OThiYWRjZmUsIGQgPSAweDEwMzI1NDc2LCBlID0gMHhjM2QyZTFmMDtcbiAgICB3b3JkczMyW2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgICB3b3JkczMyWygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkczMyLmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICBjb25zdCBoMCA9IGEsIGgxID0gYiwgaDIgPSBjLCBoMyA9IGQsIGg0ID0gZTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaiA8IDE2KSB7XG4gICAgICAgICAgICAgICAgd1tqXSA9IHdvcmRzMzJbaSArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd1tqXSA9IHJvbDMyKHdbaiAtIDNdIF4gd1tqIC0gOF0gXiB3W2ogLSAxNF0gXiB3W2ogLSAxNl0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmtWYWwgPSBmayhqLCBiLCBjLCBkKTtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBma1ZhbFswXTtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBma1ZhbFsxXTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBbcm9sMzIoYSwgNSksIGYsIGUsIGssIHdbal1dLnJlZHVjZShhZGQzMik7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9IHJvbDMyKGIsIDMwKTtcbiAgICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgICAgYSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGFkZDMyKGEsIGgwKTtcbiAgICAgICAgYiA9IGFkZDMyKGIsIGgxKTtcbiAgICAgICAgYyA9IGFkZDMyKGMsIGgyKTtcbiAgICAgICAgZCA9IGFkZDMyKGQsIGgzKTtcbiAgICAgICAgZSA9IGFkZDMyKGUsIGg0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXhTdHJpbmcod29yZHMzMlRvQnl0ZVN0cmluZyhbYSwgYiwgYywgZCwgZV0pKTtcbn1cbmZ1bmN0aW9uIGZrKGluZGV4LCBiLCBjLCBkKSB7XG4gICAgaWYgKGluZGV4IDwgMjApIHtcbiAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKH5iICYgZCksIDB4NWE4Mjc5OTldO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCA0MCkge1xuICAgICAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHg2ZWQ5ZWJhMV07XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDYwKSB7XG4gICAgICAgIHJldHVybiBbKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpLCAweDhmMWJiY2RjXTtcbiAgICB9XG4gICAgcmV0dXJuIFtiIF4gYyBeIGQsIDB4Y2E2MmMxZDZdO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBmaW5nZXJwcmludCBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKlxuICogVGhlIG91dHB1dCBpcyA2NCBiaXQgbnVtYmVyIGVuY29kZWQgYXMgYSBkZWNpbWFsIHN0cmluZ1xuICpcbiAqIGJhc2VkIG9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2Jsb2IvbWFzdGVyL3NyYy9jb20vZ29vZ2xlL2phdmFzY3JpcHQvanNjb21wL0dvb2dsZUpzTWVzc2FnZUlkR2VuZXJhdG9yLmphdmFcbiAqL1xuZnVuY3Rpb24gZmluZ2VycHJpbnQoc3RyKSB7XG4gICAgY29uc3QgdXRmOCA9IHV0ZjhFbmNvZGUoc3RyKTtcbiAgICBsZXQgaGkgPSBoYXNoMzIodXRmOCwgMCk7XG4gICAgbGV0IGxvID0gaGFzaDMyKHV0ZjgsIDEwMjA3Mik7XG4gICAgaWYgKGhpID09IDAgJiYgKGxvID09IDAgfHwgbG8gPT0gMSkpIHtcbiAgICAgICAgaGkgPSBoaSBeIDB4MTMwZjliZWY7XG4gICAgICAgIGxvID0gbG8gXiAtMHg2YjVmNTZkODtcbiAgICB9XG4gICAgcmV0dXJuIFtoaSwgbG9dO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1zZ0lkKG1zZywgbWVhbmluZyA9ICcnKSB7XG4gICAgbGV0IG1zZ0ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQobXNnKTtcbiAgICBpZiAobWVhbmluZykge1xuICAgICAgICBjb25zdCBtZWFuaW5nRmluZ2VycHJpbnQgPSBmaW5nZXJwcmludChtZWFuaW5nKTtcbiAgICAgICAgbXNnRmluZ2VycHJpbnQgPSBhZGQ2NChyb2w2NChtc2dGaW5nZXJwcmludCwgMSksIG1lYW5pbmdGaW5nZXJwcmludCk7XG4gICAgfVxuICAgIGNvbnN0IGhpID0gbXNnRmluZ2VycHJpbnRbMF07XG4gICAgY29uc3QgbG8gPSBtc2dGaW5nZXJwcmludFsxXTtcbiAgICByZXR1cm4gd29yZHNUb0RlY2ltYWxTdHJpbmcoaGkgJiAweDdmZmZmZmZmLCBsbyk7XG59XG5mdW5jdGlvbiBoYXNoMzIoYnl0ZXMsIGMpIHtcbiAgICBsZXQgYSA9IDB4OWUzNzc5YjksIGIgPSAweDllMzc3OWI5O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpICsgMTIgPD0gbGVuOyBpICs9IDEyKSB7XG4gICAgICAgIGEgPSBhZGQzMihhLCB3b3JkQXQoYnl0ZXMsIGksIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAgICAgYiA9IGFkZDMyKGIsIHdvcmRBdChieXRlcywgaSArIDQsIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAgICAgYyA9IGFkZDMyKGMsIHdvcmRBdChieXRlcywgaSArIDgsIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAgICAgY29uc3QgcmVzID0gbWl4KGEsIGIsIGMpO1xuICAgICAgICBhID0gcmVzWzBdLCBiID0gcmVzWzFdLCBjID0gcmVzWzJdO1xuICAgIH1cbiAgICBhID0gYWRkMzIoYSwgd29yZEF0KGJ5dGVzLCBpLCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgYiA9IGFkZDMyKGIsIHdvcmRBdChieXRlcywgaSArIDQsIEVuZGlhbi5MaXR0bGUpKTtcbiAgICAvLyB0aGUgZmlyc3QgYnl0ZSBvZiBjIGlzIHJlc2VydmVkIGZvciB0aGUgbGVuZ3RoXG4gICAgYyA9IGFkZDMyKGMsIGxlbik7XG4gICAgYyA9IGFkZDMyKGMsIHdvcmRBdChieXRlcywgaSArIDgsIEVuZGlhbi5MaXR0bGUpIDw8IDgpO1xuICAgIHJldHVybiBtaXgoYSwgYiwgYylbMl07XG59XG4vLyBjbGFuZy1mb3JtYXQgb2ZmXG5mdW5jdGlvbiBtaXgoYSwgYiwgYykge1xuICAgIGEgPSBzdWIzMihhLCBiKTtcbiAgICBhID0gc3ViMzIoYSwgYyk7XG4gICAgYSBePSBjID4+PiAxMztcbiAgICBiID0gc3ViMzIoYiwgYyk7XG4gICAgYiA9IHN1YjMyKGIsIGEpO1xuICAgIGIgXj0gYSA8PCA4O1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiAxMztcbiAgICBhID0gc3ViMzIoYSwgYik7XG4gICAgYSA9IHN1YjMyKGEsIGMpO1xuICAgIGEgXj0gYyA+Pj4gMTI7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgMTY7XG4gICAgYyA9IHN1YjMyKGMsIGEpO1xuICAgIGMgPSBzdWIzMihjLCBiKTtcbiAgICBjIF49IGIgPj4+IDU7XG4gICAgYSA9IHN1YjMyKGEsIGIpO1xuICAgIGEgPSBzdWIzMihhLCBjKTtcbiAgICBhIF49IGMgPj4+IDM7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgMTA7XG4gICAgYyA9IHN1YjMyKGMsIGEpO1xuICAgIGMgPSBzdWIzMihjLCBiKTtcbiAgICBjIF49IGIgPj4+IDE1O1xuICAgIHJldHVybiBbYSwgYiwgY107XG59XG4vLyBjbGFuZy1mb3JtYXQgb25cbi8vIFV0aWxzXG52YXIgRW5kaWFuO1xuKGZ1bmN0aW9uIChFbmRpYW4pIHtcbiAgICBFbmRpYW5bRW5kaWFuW1wiTGl0dGxlXCJdID0gMF0gPSBcIkxpdHRsZVwiO1xuICAgIEVuZGlhbltFbmRpYW5bXCJCaWdcIl0gPSAxXSA9IFwiQmlnXCI7XG59KShFbmRpYW4gfHwgKEVuZGlhbiA9IHt9KSk7XG5mdW5jdGlvbiBhZGQzMihhLCBiKSB7XG4gICAgcmV0dXJuIGFkZDMydG82NChhLCBiKVsxXTtcbn1cbmZ1bmN0aW9uIGFkZDMydG82NChhLCBiKSB7XG4gICAgY29uc3QgbG93ID0gKGEgJiAweGZmZmYpICsgKGIgJiAweGZmZmYpO1xuICAgIGNvbnN0IGhpZ2ggPSAoYSA+Pj4gMTYpICsgKGIgPj4+IDE2KSArIChsb3cgPj4+IDE2KTtcbiAgICByZXR1cm4gW2hpZ2ggPj4+IDE2LCAoaGlnaCA8PCAxNikgfCAobG93ICYgMHhmZmZmKV07XG59XG5mdW5jdGlvbiBhZGQ2NChhLCBiKSB7XG4gICAgY29uc3QgYWggPSBhWzBdLCBhbCA9IGFbMV07XG4gICAgY29uc3QgYmggPSBiWzBdLCBibCA9IGJbMV07XG4gICAgY29uc3QgcmVzdWx0ID0gYWRkMzJ0bzY0KGFsLCBibCk7XG4gICAgY29uc3QgY2FycnkgPSByZXN1bHRbMF07XG4gICAgY29uc3QgbCA9IHJlc3VsdFsxXTtcbiAgICBjb25zdCBoID0gYWRkMzIoYWRkMzIoYWgsIGJoKSwgY2FycnkpO1xuICAgIHJldHVybiBbaCwgbF07XG59XG5mdW5jdGlvbiBzdWIzMihhLCBiKSB7XG4gICAgY29uc3QgbG93ID0gKGEgJiAweGZmZmYpIC0gKGIgJiAweGZmZmYpO1xuICAgIGNvbnN0IGhpZ2ggPSAoYSA+PiAxNikgLSAoYiA+PiAxNikgKyAobG93ID4+IDE2KTtcbiAgICByZXR1cm4gKGhpZ2ggPDwgMTYpIHwgKGxvdyAmIDB4ZmZmZik7XG59XG4vLyBSb3RhdGUgYSAzMmIgbnVtYmVyIGxlZnQgYGNvdW50YCBwb3NpdGlvblxuZnVuY3Rpb24gcm9sMzIoYSwgY291bnQpIHtcbiAgICByZXR1cm4gKGEgPDwgY291bnQpIHwgKGEgPj4+ICgzMiAtIGNvdW50KSk7XG59XG4vLyBSb3RhdGUgYSA2NGIgbnVtYmVyIGxlZnQgYGNvdW50YCBwb3NpdGlvblxuZnVuY3Rpb24gcm9sNjQobnVtLCBjb3VudCkge1xuICAgIGNvbnN0IGhpID0gbnVtWzBdLCBsbyA9IG51bVsxXTtcbiAgICBjb25zdCBoID0gKGhpIDw8IGNvdW50KSB8IChsbyA+Pj4gKDMyIC0gY291bnQpKTtcbiAgICBjb25zdCBsID0gKGxvIDw8IGNvdW50KSB8IChoaSA+Pj4gKDMyIC0gY291bnQpKTtcbiAgICByZXR1cm4gW2gsIGxdO1xufVxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzMzIoYnl0ZXMsIGVuZGlhbikge1xuICAgIGNvbnN0IHNpemUgPSAoYnl0ZXMubGVuZ3RoICsgMykgPj4+IDI7XG4gICAgY29uc3Qgd29yZHMzMiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHdvcmRzMzJbaV0gPSB3b3JkQXQoYnl0ZXMsIGkgKiA0LCBlbmRpYW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29yZHMzMjtcbn1cbmZ1bmN0aW9uIGJ5dGVBdChieXRlcywgaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gYnl0ZXMubGVuZ3RoID8gMCA6IGJ5dGVzW2luZGV4XTtcbn1cbmZ1bmN0aW9uIHdvcmRBdChieXRlcywgaW5kZXgsIGVuZGlhbikge1xuICAgIGxldCB3b3JkID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSBFbmRpYW4uQmlnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChieXRlcywgaW5kZXggKyBpKSA8PCAoMjQgLSA4ICogaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChieXRlcywgaW5kZXggKyBpKSA8PCA4ICogaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29yZDtcbn1cbmZ1bmN0aW9uIHdvcmRzMzJUb0J5dGVTdHJpbmcod29yZHMzMikge1xuICAgIHJldHVybiB3b3JkczMyLnJlZHVjZSgoYnl0ZXMsIHdvcmQpID0+IGJ5dGVzLmNvbmNhdCh3b3JkMzJUb0J5dGVTdHJpbmcod29yZCkpLCBbXSk7XG59XG5mdW5jdGlvbiB3b3JkMzJUb0J5dGVTdHJpbmcod29yZCkge1xuICAgIGxldCBieXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goKHdvcmQgPj4+IDggKiAoMyAtIGkpKSAmIDB4ZmYpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBieXRlc1RvSGV4U3RyaW5nKGJ5dGVzKSB7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYiA9IGJ5dGVBdChieXRlcywgaSk7XG4gICAgICAgIGhleCArPSAoYiA+Pj4gNCkudG9TdHJpbmcoMTYpICsgKGIgJiAweDBmKS50b1N0cmluZygxNik7XG4gICAgfVxuICAgIHJldHVybiBoZXgudG9Mb3dlckNhc2UoKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc2hhcmVkIGV4cG9uZW50aWF0aW9uIHBvb2wgZm9yIGJhc2UtMjU2IGNvbXB1dGF0aW9ucy4gVGhpcyBzaGFyZWQgcG9vbCBwcm92aWRlcyBtZW1vaXplZFxuICogcG93ZXItb2YtMjU2IHJlc3VsdHMgd2l0aCBtZW1vaXplZCBwb3dlci1vZi10d28gY29tcHV0YXRpb25zIGZvciBlZmZpY2llbnQgbXVsdGlwbGljYXRpb24uXG4gKlxuICogRm9yIG91ciBwdXJwb3NlcywgdGhpcyBjYW4gYmUgc2FmZWx5IHN0b3JlZCBhcyBhIGdsb2JhbCB3aXRob3V0IG1lbW9yeSBjb25jZXJucy4gVGhlIHJlYXNvbiBpc1xuICogdGhhdCB3ZSBlbmNvZGUgdHdvIHdvcmRzLCBzbyBvbmx5IG5lZWQgdGhlIDB0aCAoZm9yIHRoZSBsb3cgd29yZCkgYW5kIDR0aCAoZm9yIHRoZSBoaWdoIHdvcmQpXG4gKiBleHBvbmVudC5cbiAqL1xuY29uc3QgYmFzZTI1NiA9IG5ldyBCaWdJbnRFeHBvbmVudGlhdGlvbigyNTYpO1xuLyoqXG4gKiBSZXByZXNlbnRzIHR3byAzMi1iaXQgd29yZHMgYXMgYSBzaW5nbGUgZGVjaW1hbCBudW1iZXIuIFRoaXMgcmVxdWlyZXMgYSBiaWcgaW50ZWdlciBzdG9yYWdlXG4gKiBtb2RlbCBhcyBKUyBudW1iZXJzIGFyZSBub3QgYWNjdXJhdGUgZW5vdWdoIHRvIHJlcHJlc2VudCB0aGUgNjQtYml0IG51bWJlci5cbiAqXG4gKiBCYXNlZCBvbiBodHRwczovL3d3dy5kYW52ay5vcmcvaGV4MmRlYy5odG1sXG4gKi9cbmZ1bmN0aW9uIHdvcmRzVG9EZWNpbWFsU3RyaW5nKGhpLCBsbykge1xuICAgIC8vIEVuY29kZSB0aGUgZm91ciBieXRlcyBpbiBsbyBpbiB0aGUgbG93ZXIgZGlnaXRzIG9mIHRoZSBkZWNpbWFsIG51bWJlci5cbiAgICAvLyBOb3RlOiB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0cyBpbiBsbyBpdHNlbGYgYnV0IHJlcHJlc2VudGVkIGJ5IGEgYmlnIGludGVnZXIgdXNpbmcgaXRzXG4gICAgLy8gZGVjaW1hbCBkaWdpdHMuXG4gICAgY29uc3QgZGVjaW1hbCA9IGJhc2UyNTYudG9UaGVQb3dlck9mKDApLm11bHRpcGx5QnkobG8pO1xuICAgIC8vIEVuY29kZSB0aGUgZm91ciBieXRlcyBpbiBoaSBhYm92ZSB0aGUgZm91ciBsbyBieXRlcy4gbG8gaXMgYSBtYXhpbXVtIG9mICgyXjgpXjQsIHdoaWNoIGlzIHdoeVxuICAgIC8vIHRoaXMgbXVsdGlwbGljYXRpb24gZmFjdG9yIGlzIGFwcGxpZWQuXG4gICAgYmFzZTI1Ni50b1RoZVBvd2VyT2YoNCkubXVsdGlwbHlCeUFuZEFkZFRvKGhpLCBkZWNpbWFsKTtcbiAgICByZXR1cm4gZGVjaW1hbC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vLy8gVHlwZXNcbnZhciBUeXBlTW9kaWZpZXI7XG4oZnVuY3Rpb24gKFR5cGVNb2RpZmllcikge1xuICAgIFR5cGVNb2RpZmllcltUeXBlTW9kaWZpZXJbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBUeXBlTW9kaWZpZXJbVHlwZU1vZGlmaWVyW1wiQ29uc3RcIl0gPSAxXSA9IFwiQ29uc3RcIjtcbn0pKFR5cGVNb2RpZmllciB8fCAoVHlwZU1vZGlmaWVyID0ge30pKTtcbmNsYXNzIFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1vZGlmaWVycyA9IFR5cGVNb2RpZmllci5Ob25lKSB7XG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgIH1cbiAgICBoYXNNb2RpZmllcihtb2RpZmllcikge1xuICAgICAgICByZXR1cm4gKHRoaXMubW9kaWZpZXJzICYgbW9kaWZpZXIpICE9PSAwO1xuICAgIH1cbn1cbnZhciBCdWlsdGluVHlwZU5hbWU7XG4oZnVuY3Rpb24gKEJ1aWx0aW5UeXBlTmFtZSkge1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJEeW5hbWljXCJdID0gMF0gPSBcIkR5bmFtaWNcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiQm9vbFwiXSA9IDFdID0gXCJCb29sXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIlN0cmluZ1wiXSA9IDJdID0gXCJTdHJpbmdcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiSW50XCJdID0gM10gPSBcIkludFwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJOdW1iZXJcIl0gPSA0XSA9IFwiTnVtYmVyXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkZ1bmN0aW9uXCJdID0gNV0gPSBcIkZ1bmN0aW9uXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkluZmVycmVkXCJdID0gNl0gPSBcIkluZmVycmVkXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIk5vbmVcIl0gPSA3XSA9IFwiTm9uZVwiO1xufSkoQnVpbHRpblR5cGVOYW1lIHx8IChCdWlsdGluVHlwZU5hbWUgPSB7fSkpO1xuY2xhc3MgQnVpbHRpblR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgc3VwZXIobW9kaWZpZXJzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgdmlzaXRUeXBlKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCdWlsdGluVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBFeHByZXNzaW9uVHlwZSBleHRlbmRzIFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBtb2RpZmllcnMsIHR5cGVQYXJhbXMgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICB9XG4gICAgdmlzaXRUeXBlKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHByZXNzaW9uVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBBcnJheVR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihvZiwgbW9kaWZpZXJzKSB7XG4gICAgICAgIHN1cGVyKG1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMub2YgPSBvZjtcbiAgICB9XG4gICAgdmlzaXRUeXBlKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBcnJheVR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgTWFwVHlwZSBleHRlbmRzIFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlVHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIHN1cGVyKG1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMudmFsdWVUeXBlID0gdmFsdWVUeXBlIHx8IG51bGw7XG4gICAgfVxuICAgIHZpc2l0VHlwZSh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TWFwVHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jb25zdCBEWU5BTUlDX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkR5bmFtaWMpO1xuY29uc3QgSU5GRVJSRURfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuSW5mZXJyZWQpO1xuY29uc3QgQk9PTF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5Cb29sKTtcbmNvbnN0IElOVF9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5JbnQpO1xuY29uc3QgTlVNQkVSX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLk51bWJlcik7XG5jb25zdCBTVFJJTkdfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuU3RyaW5nKTtcbmNvbnN0IEZVTkNUSU9OX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uKTtcbmNvbnN0IE5PTkVfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuTm9uZSk7XG4vLy8vLyBFeHByZXNzaW9uc1xudmFyIFVuYXJ5T3BlcmF0b3I7XG4oZnVuY3Rpb24gKFVuYXJ5T3BlcmF0b3IpIHtcbiAgICBVbmFyeU9wZXJhdG9yW1VuYXJ5T3BlcmF0b3JbXCJNaW51c1wiXSA9IDBdID0gXCJNaW51c1wiO1xuICAgIFVuYXJ5T3BlcmF0b3JbVW5hcnlPcGVyYXRvcltcIlBsdXNcIl0gPSAxXSA9IFwiUGx1c1wiO1xufSkoVW5hcnlPcGVyYXRvciB8fCAoVW5hcnlPcGVyYXRvciA9IHt9KSk7XG52YXIgQmluYXJ5T3BlcmF0b3I7XG4oZnVuY3Rpb24gKEJpbmFyeU9wZXJhdG9yKSB7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJFcXVhbHNcIl0gPSAwXSA9IFwiRXF1YWxzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOb3RFcXVhbHNcIl0gPSAxXSA9IFwiTm90RXF1YWxzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJJZGVudGljYWxcIl0gPSAyXSA9IFwiSWRlbnRpY2FsXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOb3RJZGVudGljYWxcIl0gPSAzXSA9IFwiTm90SWRlbnRpY2FsXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNaW51c1wiXSA9IDRdID0gXCJNaW51c1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiUGx1c1wiXSA9IDVdID0gXCJQbHVzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJEaXZpZGVcIl0gPSA2XSA9IFwiRGl2aWRlXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNdWx0aXBseVwiXSA9IDddID0gXCJNdWx0aXBseVwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTW9kdWxvXCJdID0gOF0gPSBcIk1vZHVsb1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQW5kXCJdID0gOV0gPSBcIkFuZFwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiT3JcIl0gPSAxMF0gPSBcIk9yXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaXR3aXNlQW5kXCJdID0gMTFdID0gXCJCaXR3aXNlQW5kXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJMb3dlclwiXSA9IDEyXSA9IFwiTG93ZXJcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkxvd2VyRXF1YWxzXCJdID0gMTNdID0gXCJMb3dlckVxdWFsc1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQmlnZ2VyXCJdID0gMTRdID0gXCJCaWdnZXJcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkJpZ2dlckVxdWFsc1wiXSA9IDE1XSA9IFwiQmlnZ2VyRXF1YWxzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJOdWxsaXNoQ29hbGVzY2VcIl0gPSAxNl0gPSBcIk51bGxpc2hDb2FsZXNjZVwiO1xufSkoQmluYXJ5T3BlcmF0b3IgfHwgKEJpbmFyeU9wZXJhdG9yID0ge30pKTtcbmZ1bmN0aW9uIG51bGxTYWZlSXNFcXVpdmFsZW50KGJhc2UsIG90aGVyKSB7XG4gICAgaWYgKGJhc2UgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiYXNlID09IG90aGVyO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZS5pc0VxdWl2YWxlbnQob3RoZXIpO1xufVxuZnVuY3Rpb24gYXJlQWxsRXF1aXZhbGVudFByZWRpY2F0ZShiYXNlLCBvdGhlciwgZXF1aXZhbGVudFByZWRpY2F0ZSkge1xuICAgIGNvbnN0IGxlbiA9IGJhc2UubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFlcXVpdmFsZW50UHJlZGljYXRlKGJhc2VbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXJlQWxsRXF1aXZhbGVudChiYXNlLCBvdGhlcikge1xuICAgIHJldHVybiBhcmVBbGxFcXVpdmFsZW50UHJlZGljYXRlKGJhc2UsIG90aGVyLCAoYmFzZUVsZW1lbnQsIG90aGVyRWxlbWVudCkgPT4gYmFzZUVsZW1lbnQuaXNFcXVpdmFsZW50KG90aGVyRWxlbWVudCkpO1xufVxuY2xhc3MgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW4gfHwgbnVsbDtcbiAgICB9XG4gICAgcHJvcChuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBrZXkoaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkS2V5RXhwcih0aGlzLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGNhbGxGbihwYXJhbXMsIHNvdXJjZVNwYW4sIHB1cmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZva2VGdW5jdGlvbkV4cHIodGhpcywgcGFyYW1zLCBudWxsLCBzb3VyY2VTcGFuLCBwdXJlKTtcbiAgICB9XG4gICAgaW5zdGFudGlhdGUocGFyYW1zLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudGlhdGVFeHByKHRoaXMsIHBhcmFtcywgdHlwZSwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGNvbmRpdGlvbmFsKHRydWVDYXNlLCBmYWxzZUNhc2UgPSBudWxsLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByKHRoaXMsIHRydWVDYXNlLCBmYWxzZUNhc2UsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBlcXVhbHMocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgbm90RXF1YWxzKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGlkZW50aWNhbChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBub3RJZGVudGljYWwocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbCwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgbWludXMocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1pbnVzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBwbHVzKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5QbHVzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBkaXZpZGUocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkRpdmlkZSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgbXVsdGlwbHkocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5LCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBtb2R1bG8ocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk1vZHVsbywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgYW5kKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5BbmQsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGJpdHdpc2VBbmQocmhzLCBzb3VyY2VTcGFuLCBwYXJlbnMgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpdHdpc2VBbmQsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3BhbiwgcGFyZW5zKTtcbiAgICB9XG4gICAgb3IocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk9yLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBsb3dlcihyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXIsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGxvd2VyRXF1YWxzKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgYmlnZ2VyKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5CaWdnZXIsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGJpZ2dlckVxdWFscyhyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBpc0JsYW5rKHNvdXJjZVNwYW4pIHtcbiAgICAgICAgLy8gTm90ZTogV2UgdXNlIGVxdWFscyBieSBwdXJwb3NlIGhlcmUgdG8gY29tcGFyZSB0byBudWxsIGFuZCB1bmRlZmluZWQgaW4gSlMuXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgdHlwZWQgbnVsbCB0byBhbGxvdyBzdHJpY3ROdWxsQ2hlY2tzIHRvIG5hcnJvdyB0eXBlcy5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFRZUEVEX05VTExfRVhQUiwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIG51bGxpc2hDb2FsZXNjZShyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTnVsbGlzaENvYWxlc2NlLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB0b1N0bXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh0aGlzLCBudWxsKTtcbiAgICB9XG59XG5jbGFzcyBSZWFkVmFyRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIodHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgUmVhZFZhckV4cHIgJiYgdGhpcy5uYW1lID09PSBlLm5hbWU7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkVmFyRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVWYXJFeHByKHRoaXMubmFtZSwgdmFsdWUsIG51bGwsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfVxufVxuY2xhc3MgVHlwZW9mRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGV4cHIsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIodHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VHlwZW9mRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBUeXBlb2ZFeHByICYmIGUuZXhwci5pc0VxdWl2YWxlbnQodGhpcy5leHByKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwci5pc0NvbnN0YW50KCk7XG4gICAgfVxufVxuY2xhc3MgV3JhcHBlZE5vZGVFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Iobm9kZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBXcmFwcGVkTm9kZUV4cHIgJiYgdGhpcy5ub2RlID09PSBlLm5vZGU7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcmFwcGVkTm9kZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgV3JpdGVWYXJFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIodHlwZSB8fCB2YWx1ZS50eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFdyaXRlVmFyRXhwciAmJiB0aGlzLm5hbWUgPT09IGUubmFtZSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChlLnZhbHVlKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlVmFyRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdG9EZWNsU3RtdCh0eXBlLCBtb2RpZmllcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJlVmFyU3RtdCh0aGlzLm5hbWUsIHRoaXMudmFsdWUsIHR5cGUsIG1vZGlmaWVycywgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdG9Db25zdERlY2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvRGVjbFN0bXQoSU5GRVJSRURfVFlQRSwgU3RtdE1vZGlmaWVyLkZpbmFsKTtcbiAgICB9XG59XG5jbGFzcyBXcml0ZUtleUV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZWNlaXZlciwgaW5kZXgsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgV3JpdGVLZXlFeHByICYmIHRoaXMucmVjZWl2ZXIuaXNFcXVpdmFsZW50KGUucmVjZWl2ZXIpICYmXG4gICAgICAgICAgICB0aGlzLmluZGV4LmlzRXF1aXZhbGVudChlLmluZGV4KSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChlLnZhbHVlKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBXcml0ZVByb3BFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocmVjZWl2ZXIsIG5hbWUsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFdyaXRlUHJvcEV4cHIgJiYgdGhpcy5yZWNlaXZlci5pc0VxdWl2YWxlbnQoZS5yZWNlaXZlcikgJiZcbiAgICAgICAgICAgIHRoaXMubmFtZSA9PT0gZS5uYW1lICYmIHRoaXMudmFsdWUuaXNFcXVpdmFsZW50KGUudmFsdWUpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVQcm9wRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBJbnZva2VGdW5jdGlvbkV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmbiwgYXJncywgdHlwZSwgc291cmNlU3BhbiwgcHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMucHVyZSA9IHB1cmU7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSW52b2tlRnVuY3Rpb25FeHByICYmIHRoaXMuZm4uaXNFcXVpdmFsZW50KGUuZm4pICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuYXJncywgZS5hcmdzKSAmJiB0aGlzLnB1cmUgPT09IGUucHVyZTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZUZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBUYWdnZWRUZW1wbGF0ZUV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIHRlbXBsYXRlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFRhZ2dlZFRlbXBsYXRlRXhwciAmJiB0aGlzLnRhZy5pc0VxdWl2YWxlbnQoZS50YWcpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50UHJlZGljYXRlKHRoaXMudGVtcGxhdGUuZWxlbWVudHMsIGUudGVtcGxhdGUuZWxlbWVudHMsIChhLCBiKSA9PiBhLnRleHQgPT09IGIudGV4dCkgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy50ZW1wbGF0ZS5leHByZXNzaW9ucywgZS50ZW1wbGF0ZS5leHByZXNzaW9ucyk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdnZWRUZW1wbGF0ZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgSW5zdGFudGlhdGVFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY2xhc3NFeHByLCBhcmdzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmNsYXNzRXhwciA9IGNsYXNzRXhwcjtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0ZUV4cHIgJiYgdGhpcy5jbGFzc0V4cHIuaXNFcXVpdmFsZW50KGUuY2xhc3NFeHByKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmFyZ3MsIGUuYXJncyk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnN0YW50aWF0ZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIExpdGVyYWxFeHByICYmIHRoaXMudmFsdWUgPT09IGUudmFsdWU7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFRlbXBsYXRlTGl0ZXJhbCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMsIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgIH1cbn1cbmNsYXNzIFRlbXBsYXRlTGl0ZXJhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHNvdXJjZVNwYW4sIHJhd1RleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAvLyBJZiBgcmF3VGV4dGAgaXMgbm90IHByb3ZpZGVkLCB0cnkgdG8gZXh0cmFjdCB0aGUgcmF3IHN0cmluZyBmcm9tIGl0c1xuICAgICAgICAvLyBhc3NvY2lhdGVkIGBzb3VyY2VTcGFuYC4gSWYgdGhhdCBpcyBhbHNvIG5vdCBhdmFpbGFibGUsIFwiZmFrZVwiIHRoZSByYXdcbiAgICAgICAgLy8gc3RyaW5nIGluc3RlYWQgYnkgZXNjYXBpbmcgdGhlIGZvbGxvd2luZyBjb250cm9sIHNlcXVlbmNlczpcbiAgICAgICAgLy8gLSBcIlxcXCIgd291bGQgb3RoZXJ3aXNlIGluZGljYXRlIHRoYXQgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIuXG4gICAgICAgIC8vIC0gXCJgXCIgYW5kIFwiJHtcIiBhcmUgdGVtcGxhdGUgc3RyaW5nIGNvbnRyb2wgc2VxdWVuY2VzIHRoYXQgd291bGQgb3RoZXJ3aXNlIHByZW1hdHVyZWx5XG4gICAgICAgIC8vIGluZGljYXRlIHRoZSBlbmQgb2YgdGhlIHRlbXBsYXRlIGxpdGVyYWwgZWxlbWVudC5cbiAgICAgICAgdGhpcy5yYXdUZXh0ID1cbiAgICAgICAgICAgIChfYSA9IHJhd1RleHQgIT09IG51bGwgJiYgcmF3VGV4dCAhPT0gdm9pZCAwID8gcmF3VGV4dCA6IHNvdXJjZVNwYW4gPT09IG51bGwgfHwgc291cmNlU3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlU3Bhbi50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlc2NhcGVGb3JUZW1wbGF0ZUxpdGVyYWwoZXNjYXBlU2xhc2hlcyh0ZXh0KSk7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbFBpZWNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxufVxuY2xhc3MgUGxhY2Vob2xkZXJQaWVjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgYFBsYWNlaG9sZGVyUGllY2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRleHQgdGhlIG5hbWUgb2YgdGhpcyBwbGFjZWhvbGRlciAoZS5nLiBgUEhfMWApLlxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuIHRoZSBsb2NhdGlvbiBvZiB0aGlzIHBsYWNlaG9sZGVyIGluIGl0cyBsb2NhbGl6ZWQgbWVzc2FnZSB0aGUgc291cmNlIGNvZGUuXG4gICAgICogQHBhcmFtIGFzc29jaWF0ZWRNZXNzYWdlIHJlZmVyZW5jZSB0byBhbm90aGVyIG1lc3NhZ2UgdGhhdCB0aGlzIHBsYWNlaG9sZGVyIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAgKiBUaGUgYGFzc29jaWF0ZWRNZXNzYWdlYCBpcyBtYWlubHkgdXNlZCB0byBwcm92aWRlIGEgcmVsYXRpb25zaGlwIHRvIGFuIElDVSBtZXNzYWdlIHRoYXQgaGFzXG4gICAgICogYmVlbiBleHRyYWN0ZWQgb3V0IGZyb20gdGhlIG1lc3NhZ2UgY29udGFpbmluZyB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgc291cmNlU3BhbiwgYXNzb2NpYXRlZE1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGVkTWVzc2FnZSA9IGFzc29jaWF0ZWRNZXNzYWdlO1xuICAgIH1cbn1cbmNvbnN0IE1FQU5JTkdfU0VQQVJBVE9SJDEgPSAnfCc7XG5jb25zdCBJRF9TRVBBUkFUT1IkMSA9ICdAQCc7XG5jb25zdCBMRUdBQ1lfSURfSU5ESUNBVE9SID0gJ+KQnyc7XG5jbGFzcyBMb2NhbGl6ZWRTdHJpbmcgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhQmxvY2ssIG1lc3NhZ2VQYXJ0cywgcGxhY2VIb2xkZXJOYW1lcywgZXhwcmVzc2lvbnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIoU1RSSU5HX1RZUEUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLm1ldGFCbG9jayA9IG1ldGFCbG9jaztcbiAgICAgICAgdGhpcy5tZXNzYWdlUGFydHMgPSBtZXNzYWdlUGFydHM7XG4gICAgICAgIHRoaXMucGxhY2VIb2xkZXJOYW1lcyA9IHBsYWNlSG9sZGVyTmFtZXM7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgLy8gcmV0dXJuIGUgaW5zdGFuY2VvZiBMb2NhbGl6ZWRTdHJpbmcgJiYgdGhpcy5tZXNzYWdlID09PSBlLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExvY2FsaXplZFN0cmluZyh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBnaXZlbiBgbWV0YWAgYW5kIGBtZXNzYWdlUGFydGAgaW50byBcImNvb2tlZFwiIGFuZCBcInJhd1wiIHN0cmluZ3MgdGhhdCBjYW4gYmUgdXNlZFxuICAgICAqIGluIGEgYCRsb2NhbGl6ZWAgdGFnZ2VkIHN0cmluZy4gVGhlIGZvcm1hdCBvZiB0aGUgbWV0YWRhdGEgaXMgdGhlIHNhbWUgYXMgdGhhdCBwYXJzZWQgYnlcbiAgICAgKiBgcGFyc2VJMThuTWV0YSgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRhIFRoZSBtZXRhZGF0YSB0byBzZXJpYWxpemVcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcnQgVGhlIGZpcnN0IHBhcnQgb2YgdGhlIHRhZ2dlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBzZXJpYWxpemVJMThuSGVhZCgpIHtcbiAgICAgICAgbGV0IG1ldGFCbG9jayA9IHRoaXMubWV0YUJsb2NrLmRlc2NyaXB0aW9uIHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5tZXRhQmxvY2subWVhbmluZykge1xuICAgICAgICAgICAgbWV0YUJsb2NrID0gYCR7dGhpcy5tZXRhQmxvY2subWVhbmluZ30ke01FQU5JTkdfU0VQQVJBVE9SJDF9JHttZXRhQmxvY2t9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhQmxvY2suY3VzdG9tSWQpIHtcbiAgICAgICAgICAgIG1ldGFCbG9jayA9IGAke21ldGFCbG9ja30ke0lEX1NFUEFSQVRPUiQxfSR7dGhpcy5tZXRhQmxvY2suY3VzdG9tSWR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhQmxvY2subGVnYWN5SWRzKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFCbG9jay5sZWdhY3lJZHMuZm9yRWFjaChsZWdhY3lJZCA9PiB7XG4gICAgICAgICAgICAgICAgbWV0YUJsb2NrID0gYCR7bWV0YUJsb2NrfSR7TEVHQUNZX0lEX0lORElDQVRPUn0ke2xlZ2FjeUlkfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQ29va2VkUmF3U3RyaW5nKG1ldGFCbG9jaywgdGhpcy5tZXNzYWdlUGFydHNbMF0udGV4dCwgdGhpcy5nZXRNZXNzYWdlUGFydFNvdXJjZVNwYW4oMCkpO1xuICAgIH1cbiAgICBnZXRNZXNzYWdlUGFydFNvdXJjZVNwYW4oaSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5tZXNzYWdlUGFydHNbaV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnNvdXJjZVNwYW47XG4gICAgfVxuICAgIGdldFBsYWNlaG9sZGVyU291cmNlU3BhbihpKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuIChfZCA9IChfYiA9IChfYSA9IHRoaXMucGxhY2VIb2xkZXJOYW1lc1tpXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvdXJjZVNwYW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IHRoaXMuZXhwcmVzc2lvbnNbaV0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLnNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYHBsYWNlaG9sZGVyTmFtZWAgYW5kIGBtZXNzYWdlUGFydGAgaW50byBcImNvb2tlZFwiIGFuZCBcInJhd1wiIHN0cmluZ3MgdGhhdFxuICAgICAqIGNhbiBiZSB1c2VkIGluIGEgYCRsb2NhbGl6ZWAgdGFnZ2VkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgaXMgYDo8cGxhY2Vob2xkZXItbmFtZT5bQEA8YXNzb2NpYXRlZC1pZD5dOmAuXG4gICAgICpcbiAgICAgKiBUaGUgYGFzc29jaWF0ZWQtaWRgIGlzIHRoZSBtZXNzYWdlIGlkIG9mIHRoZSAodXN1YWxseSBhbiBJQ1UpIG1lc3NhZ2UgdG8gd2hpY2ggdGhpcyBwbGFjZWhvbGRlclxuICAgICAqIHJlZmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJ0SW5kZXggVGhlIGluZGV4IG9mIHRoZSBtZXNzYWdlIHBhcnQgdG8gc2VyaWFsaXplLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZUkxOG5UZW1wbGF0ZVBhcnQocGFydEluZGV4KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlSG9sZGVyTmFtZXNbcGFydEluZGV4IC0gMV07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJ0ID0gdGhpcy5tZXNzYWdlUGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgbGV0IG1ldGFCbG9jayA9IHBsYWNlaG9sZGVyLnRleHQ7XG4gICAgICAgIGlmICgoKF9hID0gcGxhY2Vob2xkZXIuYXNzb2NpYXRlZE1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZWdhY3lJZHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgbWV0YUJsb2NrICs9IGAke0lEX1NFUEFSQVRPUiQxfSR7Y29tcHV0ZU1zZ0lkKHBsYWNlaG9sZGVyLmFzc29jaWF0ZWRNZXNzYWdlLm1lc3NhZ2VTdHJpbmcsIHBsYWNlaG9sZGVyLmFzc29jaWF0ZWRNZXNzYWdlLm1lYW5pbmcpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvb2tlZFJhd1N0cmluZyhtZXRhQmxvY2ssIG1lc3NhZ2VQYXJ0LnRleHQsIHRoaXMuZ2V0TWVzc2FnZVBhcnRTb3VyY2VTcGFuKHBhcnRJbmRleCkpO1xuICAgIH1cbn1cbmNvbnN0IGVzY2FwZVNsYXNoZXMgPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKTtcbmNvbnN0IGVzY2FwZVN0YXJ0aW5nQ29sb24gPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvXjovLCAnXFxcXDonKTtcbmNvbnN0IGVzY2FwZUNvbG9ucyA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC86L2csICdcXFxcOicpO1xuY29uc3QgZXNjYXBlRm9yVGVtcGxhdGVMaXRlcmFsID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL2AvZywgJ1xcXFxgJykucmVwbGFjZSgvXFwkey9nLCAnJFxcXFx7Jyk7XG4vKipcbiAqIENyZWF0ZXMgYSBge2Nvb2tlZCwgcmF3fWAgb2JqZWN0IGZyb20gdGhlIGBtZXRhQmxvY2tgIGFuZCBgbWVzc2FnZVBhcnRgLlxuICpcbiAqIFRoZSBgcmF3YCB0ZXh0IG11c3QgaGF2ZSB2YXJpb3VzIGNoYXJhY3RlciBzZXF1ZW5jZXMgZXNjYXBlZDpcbiAqICogXCJcXFwiIHdvdWxkIG90aGVyd2lzZSBpbmRpY2F0ZSB0aGF0IHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLlxuICogKiBcImBcIiBhbmQgXCIke1wiIGFyZSB0ZW1wbGF0ZSBzdHJpbmcgY29udHJvbCBzZXF1ZW5jZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgcHJlbWF0dXJlbHkgaW5kaWNhdGVcbiAqICAgdGhlIGVuZCBvZiBhIG1lc3NhZ2UgcGFydC5cbiAqICogXCI6XCIgaW5zaWRlIGEgbWV0YWJsb2NrIHdvdWxkIHByZW1hdHVyZWx5IGluZGljYXRlIHRoZSBlbmQgb2YgdGhlIG1ldGFibG9jay5cbiAqICogXCI6XCIgYXQgdGhlIHN0YXJ0IG9mIGEgbWVzc2FnZVBhcnQgd2l0aCBubyBtZXRhYmxvY2sgd291bGQgZXJyb25lb3VzbHkgaW5kaWNhdGUgdGhlIHN0YXJ0IG9mIGFcbiAqICAgbWV0YWJsb2NrLlxuICpcbiAqIEBwYXJhbSBtZXRhQmxvY2sgQW55IG1ldGFkYXRhIHRoYXQgc2hvdWxkIGJlIHByZXBlbmRlZCB0byB0aGUgc3RyaW5nXG4gKiBAcGFyYW0gbWVzc2FnZVBhcnQgVGhlIG1lc3NhZ2UgcGFydCBvZiB0aGUgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvb2tlZFJhd1N0cmluZyhtZXRhQmxvY2ssIG1lc3NhZ2VQYXJ0LCByYW5nZSkge1xuICAgIGlmIChtZXRhQmxvY2sgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb29rZWQ6IG1lc3NhZ2VQYXJ0LFxuICAgICAgICAgICAgcmF3OiBlc2NhcGVGb3JUZW1wbGF0ZUxpdGVyYWwoZXNjYXBlU3RhcnRpbmdDb2xvbihlc2NhcGVTbGFzaGVzKG1lc3NhZ2VQYXJ0KSkpLFxuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29va2VkOiBgOiR7bWV0YUJsb2NrfToke21lc3NhZ2VQYXJ0fWAsXG4gICAgICAgICAgICByYXc6IGVzY2FwZUZvclRlbXBsYXRlTGl0ZXJhbChgOiR7ZXNjYXBlQ29sb25zKGVzY2FwZVNsYXNoZXMobWV0YUJsb2NrKSl9OiR7ZXNjYXBlU2xhc2hlcyhtZXNzYWdlUGFydCl9YCksXG4gICAgICAgICAgICByYW5nZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBFeHRlcm5hbEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdHlwZSwgdHlwZVBhcmFtcyA9IG51bGwsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIodHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBFeHRlcm5hbEV4cHIgJiYgdGhpcy52YWx1ZS5uYW1lID09PSBlLnZhbHVlLm5hbWUgJiZcbiAgICAgICAgICAgIHRoaXMudmFsdWUubW9kdWxlTmFtZSA9PT0gZS52YWx1ZS5tb2R1bGVOYW1lICYmIHRoaXMudmFsdWUucnVudGltZSA9PT0gZS52YWx1ZS5ydW50aW1lO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXh0ZXJuYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEV4dGVybmFsUmVmZXJlbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2R1bGVOYW1lLCBuYW1lLCBydW50aW1lKSB7XG4gICAgICAgIHRoaXMubW9kdWxlTmFtZSA9IG1vZHVsZU5hbWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gICAgfVxufVxuY2xhc3MgQ29uZGl0aW9uYWxFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlID0gbnVsbCwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlIHx8IHRydWVDYXNlLnR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICAgIHRoaXMudHJ1ZUNhc2UgPSB0cnVlQ2FzZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDb25kaXRpb25hbEV4cHIgJiYgdGhpcy5jb25kaXRpb24uaXNFcXVpdmFsZW50KGUuY29uZGl0aW9uKSAmJlxuICAgICAgICAgICAgdGhpcy50cnVlQ2FzZS5pc0VxdWl2YWxlbnQoZS50cnVlQ2FzZSkgJiYgbnVsbFNhZmVJc0VxdWl2YWxlbnQodGhpcy5mYWxzZUNhc2UsIGUuZmFsc2VDYXNlKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBOb3RFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKEJPT0xfVFlQRSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIE5vdEV4cHIgJiYgdGhpcy5jb25kaXRpb24uaXNFcXVpdmFsZW50KGUuY29uZGl0aW9uKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5vdEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRm5QYXJhbSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KHBhcmFtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT09IHBhcmFtLm5hbWU7XG4gICAgfVxufVxuY2xhc3MgRnVuY3Rpb25FeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBzb3VyY2VTcGFuLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBGdW5jdGlvbkV4cHIgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLnBhcmFtcywgZS5wYXJhbXMpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuc3RhdGVtZW50cywgZS5zdGF0ZW1lbnRzKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdG9EZWNsU3RtdChuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJlRnVuY3Rpb25TdG10KG5hbWUsIHRoaXMucGFyYW1zLCB0aGlzLnN0YXRlbWVudHMsIHRoaXMudHlwZSwgbW9kaWZpZXJzLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH1cbn1cbmNsYXNzIFVuYXJ5T3BlcmF0b3JFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0b3IsIGV4cHIsIHR5cGUsIHNvdXJjZVNwYW4sIHBhcmVucyA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSB8fCBOVU1CRVJfVFlQRSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5leHByID0gZXhwcjtcbiAgICAgICAgdGhpcy5wYXJlbnMgPSBwYXJlbnM7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgVW5hcnlPcGVyYXRvckV4cHIgJiYgdGhpcy5vcGVyYXRvciA9PT0gZS5vcGVyYXRvciAmJlxuICAgICAgICAgICAgdGhpcy5leHByLmlzRXF1aXZhbGVudChlLmV4cHIpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VW5hcnlPcGVyYXRvckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQmluYXJ5T3BlcmF0b3JFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0b3IsIGxocywgcmhzLCB0eXBlLCBzb3VyY2VTcGFuLCBwYXJlbnMgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKHR5cGUgfHwgbGhzLnR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICB0aGlzLnBhcmVucyA9IHBhcmVucztcbiAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQmluYXJ5T3BlcmF0b3JFeHByICYmIHRoaXMub3BlcmF0b3IgPT09IGUub3BlcmF0b3IgJiZcbiAgICAgICAgICAgIHRoaXMubGhzLmlzRXF1aXZhbGVudChlLmxocykgJiYgdGhpcy5yaHMuaXNFcXVpdmFsZW50KGUucmhzKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeU9wZXJhdG9yRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBSZWFkUHJvcEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZWNlaXZlciwgbmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFJlYWRQcm9wRXhwciAmJiB0aGlzLnJlY2VpdmVyLmlzRXF1aXZhbGVudChlLnJlY2VpdmVyKSAmJlxuICAgICAgICAgICAgdGhpcy5uYW1lID09PSBlLm5hbWU7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkUHJvcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlUHJvcEV4cHIodGhpcy5yZWNlaXZlciwgdGhpcy5uYW1lLCB2YWx1ZSwgbnVsbCwgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9XG59XG5jbGFzcyBSZWFkS2V5RXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHJlY2VpdmVyLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgUmVhZEtleUV4cHIgJiYgdGhpcy5yZWNlaXZlci5pc0VxdWl2YWxlbnQoZS5yZWNlaXZlcikgJiZcbiAgICAgICAgICAgIHRoaXMuaW5kZXguaXNFcXVpdmFsZW50KGUuaW5kZXgpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZEtleUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlS2V5RXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLmluZGV4LCB2YWx1ZSwgbnVsbCwgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9XG59XG5jbGFzcyBMaXRlcmFsQXJyYXlFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZW50cmllcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5ldmVyeShlID0+IGUuaXNDb25zdGFudCgpKTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBMaXRlcmFsQXJyYXlFeHByICYmIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5lbnRyaWVzLCBlLmVudHJpZXMpO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxBcnJheUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbE1hcEVudHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBxdW90ZWQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5xdW90ZWQgPSBxdW90ZWQ7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleSA9PT0gZS5rZXkgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoZS52YWx1ZSk7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbE1hcEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IHR5cGUudmFsdWVUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgTGl0ZXJhbE1hcEV4cHIgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmVudHJpZXMsIGUuZW50cmllcyk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMuZXZlcnkoZSA9PiBlLnZhbHVlLmlzQ29uc3RhbnQoKSk7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQ29tbWFFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocGFydHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIocGFydHNbcGFydHMubGVuZ3RoIC0gMV0udHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDb21tYUV4cHIgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLnBhcnRzLCBlLnBhcnRzKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbW1hRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jb25zdCBOVUxMX0VYUFIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCwgbnVsbCwgbnVsbCk7XG5jb25zdCBUWVBFRF9OVUxMX0VYUFIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCwgSU5GRVJSRURfVFlQRSwgbnVsbCk7XG4vLy8vIFN0YXRlbWVudHNcbnZhciBTdG10TW9kaWZpZXI7XG4oZnVuY3Rpb24gKFN0bXRNb2RpZmllcikge1xuICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiRmluYWxcIl0gPSAxXSA9IFwiRmluYWxcIjtcbiAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiUHJpdmF0ZVwiXSA9IDJdID0gXCJQcml2YXRlXCI7XG4gICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIkV4cG9ydGVkXCJdID0gNF0gPSBcIkV4cG9ydGVkXCI7XG4gICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIlN0YXRpY1wiXSA9IDhdID0gXCJTdGF0aWNcIjtcbn0pKFN0bXRNb2RpZmllciB8fCAoU3RtdE1vZGlmaWVyID0ge30pKTtcbmNsYXNzIExlYWRpbmdDb21tZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBtdWx0aWxpbmUsIHRyYWlsaW5nTmV3bGluZSkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLm11bHRpbGluZSA9IG11bHRpbGluZTtcbiAgICAgICAgdGhpcy50cmFpbGluZ05ld2xpbmUgPSB0cmFpbGluZ05ld2xpbmU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aWxpbmUgPyBgICR7dGhpcy50ZXh0fSBgIDogdGhpcy50ZXh0O1xuICAgIH1cbn1cbmNsYXNzIEpTRG9jQ29tbWVudCBleHRlbmRzIExlYWRpbmdDb21tZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdzKSB7XG4gICAgICAgIHN1cGVyKCcnLCAvKiBtdWx0aWxpbmUgKi8gdHJ1ZSwgLyogdHJhaWxpbmdOZXdsaW5lICovIHRydWUpO1xuICAgICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVRhZ3ModGhpcy50YWdzKTtcbiAgICB9XG59XG5jbGFzcyBTdGF0ZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG1vZGlmaWVycyA9IFN0bXRNb2RpZmllci5Ob25lLCBzb3VyY2VTcGFuID0gbnVsbCwgbGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgIHRoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmxlYWRpbmdDb21tZW50cyA9IGxlYWRpbmdDb21tZW50cztcbiAgICB9XG4gICAgaGFzTW9kaWZpZXIobW9kaWZpZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGlmaWVycyAmIG1vZGlmaWVyKSAhPT0gMDtcbiAgICB9XG4gICAgYWRkTGVhZGluZ0NvbW1lbnQobGVhZGluZ0NvbW1lbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmxlYWRpbmdDb21tZW50cyA9IChfYSA9IHRoaXMubGVhZGluZ0NvbW1lbnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgdGhpcy5sZWFkaW5nQ29tbWVudHMucHVzaChsZWFkaW5nQ29tbWVudCk7XG4gICAgfVxufVxuY2xhc3MgRGVjbGFyZVZhclN0bXQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZhbHVlLCB0eXBlLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cykge1xuICAgICAgICBzdXBlcihtb2RpZmllcnMsIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCAodmFsdWUgJiYgdmFsdWUudHlwZSkgfHwgbnVsbDtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBEZWNsYXJlVmFyU3RtdCAmJiB0aGlzLm5hbWUgPT09IHN0bXQubmFtZSAmJlxuICAgICAgICAgICAgKHRoaXMudmFsdWUgPyAhIXN0bXQudmFsdWUgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoc3RtdC52YWx1ZSkgOiAhc3RtdC52YWx1ZSk7XG4gICAgfVxuICAgIHZpc2l0U3RhdGVtZW50KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlVmFyU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBEZWNsYXJlRnVuY3Rpb25TdG10IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwYXJhbXMsIHN0YXRlbWVudHMsIHR5cGUsIG1vZGlmaWVycywgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKG1vZGlmaWVycywgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IHN0YXRlbWVudHM7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBEZWNsYXJlRnVuY3Rpb25TdG10ICYmIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5wYXJhbXMsIHN0bXQucGFyYW1zKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLnN0YXRlbWVudHMsIHN0bXQuc3RhdGVtZW50cyk7XG4gICAgfVxuICAgIHZpc2l0U3RhdGVtZW50KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEV4cHJlc3Npb25TdGF0ZW1lbnQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKGV4cHIsIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cykge1xuICAgICAgICBzdXBlcihTdG10TW9kaWZpZXIuTm9uZSwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKTtcbiAgICAgICAgdGhpcy5leHByID0gZXhwcjtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBFeHByZXNzaW9uU3RhdGVtZW50ICYmIHRoaXMuZXhwci5pc0VxdWl2YWxlbnQoc3RtdC5leHByKTtcbiAgICB9XG4gICAgdmlzaXRTdGF0ZW1lbnQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFJldHVyblN0YXRlbWVudCBleHRlbmRzIFN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNvdXJjZVNwYW4gPSBudWxsLCBsZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgc3VwZXIoU3RtdE1vZGlmaWVyLk5vbmUsIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBSZXR1cm5TdGF0ZW1lbnQgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoc3RtdC52YWx1ZSk7XG4gICAgfVxuICAgIHZpc2l0U3RhdGVtZW50KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZXR1cm5TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIElmU3RtdCBleHRlbmRzIFN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlID0gW10sIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cykge1xuICAgICAgICBzdXBlcihTdG10TW9kaWZpZXIuTm9uZSwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudHJ1ZUNhc2UgPSB0cnVlQ2FzZTtcbiAgICAgICAgdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChzdG10KSB7XG4gICAgICAgIHJldHVybiBzdG10IGluc3RhbmNlb2YgSWZTdG10ICYmIHRoaXMuY29uZGl0aW9uLmlzRXF1aXZhbGVudChzdG10LmNvbmRpdGlvbikgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy50cnVlQ2FzZSwgc3RtdC50cnVlQ2FzZSkgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5mYWxzZUNhc2UsIHN0bXQuZmFsc2VDYXNlKTtcbiAgICB9XG4gICAgdmlzaXRTdGF0ZW1lbnQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdElmU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBSZWN1cnNpdmVBc3RWaXNpdG9yJDEge1xuICAgIHZpc2l0VHlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCkge1xuICAgICAgICBpZiAoYXN0LnR5cGUpIHtcbiAgICAgICAgICAgIGFzdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdEJ1aWx0aW5UeXBlKHR5cGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRUeXBlKHR5cGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb25UeXBlKHR5cGUsIGNvbnRleHQpIHtcbiAgICAgICAgdHlwZS52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGlmICh0eXBlLnR5cGVQYXJhbXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHR5cGUudHlwZVBhcmFtcy5mb3JFYWNoKHBhcmFtID0+IHRoaXMudmlzaXRUeXBlKHBhcmFtLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRUeXBlKHR5cGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEFycmF5VHlwZSh0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRNYXBUeXBlKHR5cGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRUeXBlKHR5cGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFdyYXBwZWROb2RlRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRUeXBlb2ZFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRSZWFkVmFyRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0V3JpdGVWYXJFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRXcml0ZUtleUV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFdyaXRlUHJvcEV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEludm9rZUZ1bmN0aW9uRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0VGFnZ2VkVGVtcGxhdGVFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QudGFnLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC50ZW1wbGF0ZS5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEluc3RhbnRpYXRlRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRMb2NhbGl6ZWRTdHJpbmcoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEV4dGVybmFsRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFzdC50eXBlUGFyYW1zKSB7XG4gICAgICAgICAgICBhc3QudHlwZVBhcmFtcy5mb3JFYWNoKHR5cGUgPT4gdHlwZS52aXNpdFR5cGUodGhpcywgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdENvbmRpdGlvbmFsRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXROb3RFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0RnVuY3Rpb25FeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhhc3Quc3RhdGVtZW50cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFVuYXJ5T3BlcmF0b3JFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEJpbmFyeU9wZXJhdG9yRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRSZWFkUHJvcEV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFJlYWRLZXlFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsQXJyYXlFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsTWFwRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdENvbW1hRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEFsbEV4cHJlc3Npb25zKGV4cHJzLCBjb250ZXh0KSB7XG4gICAgICAgIGV4cHJzLmZvckVhY2goZXhwciA9PiBleHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIHZpc2l0RGVjbGFyZVZhclN0bXQoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBpZiAoc3RtdC52YWx1ZSkge1xuICAgICAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0bXQudHlwZSkge1xuICAgICAgICAgICAgc3RtdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG4gICAgdmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHN0bXQudHlwZSkge1xuICAgICAgICAgICAgc3RtdC50eXBlLnZpc2l0VHlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uU3RtdChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH1cbiAgICB2aXNpdFJldHVyblN0bXQoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuICAgIHZpc2l0SWZTdG10KHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG4gICAgdmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXRzLCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXRzLmZvckVhY2goc3RtdCA9PiBzdG10LnZpc2l0U3RhdGVtZW50KHRoaXMsIGNvbnRleHQpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsZWFkaW5nQ29tbWVudCh0ZXh0LCBtdWx0aWxpbmUgPSBmYWxzZSwgdHJhaWxpbmdOZXdsaW5lID0gdHJ1ZSkge1xuICAgIHJldHVybiBuZXcgTGVhZGluZ0NvbW1lbnQodGV4dCwgbXVsdGlsaW5lLCB0cmFpbGluZ05ld2xpbmUpO1xufVxuZnVuY3Rpb24ganNEb2NDb21tZW50KHRhZ3MgPSBbXSkge1xuICAgIHJldHVybiBuZXcgSlNEb2NDb21tZW50KHRhZ3MpO1xufVxuZnVuY3Rpb24gdmFyaWFibGUobmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIobmFtZSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBpbXBvcnRFeHByKGlkLCB0eXBlUGFyYW1zID0gbnVsbCwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgRXh0ZXJuYWxFeHByKGlkLCBudWxsLCB0eXBlUGFyYW1zLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIGltcG9ydFR5cGUoaWQsIHR5cGVQYXJhbXMsIHR5cGVNb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaWQgIT0gbnVsbCA/IGV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMsIG51bGwpLCB0eXBlTW9kaWZpZXJzKSA6IG51bGw7XG59XG5mdW5jdGlvbiBleHByZXNzaW9uVHlwZShleHByLCB0eXBlTW9kaWZpZXJzLCB0eXBlUGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uVHlwZShleHByLCB0eXBlTW9kaWZpZXJzLCB0eXBlUGFyYW1zKTtcbn1cbmZ1bmN0aW9uIHR5cGVvZkV4cHIoZXhwcikge1xuICAgIHJldHVybiBuZXcgVHlwZW9mRXhwcihleHByKTtcbn1cbmZ1bmN0aW9uIGxpdGVyYWxBcnIodmFsdWVzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXlFeHByKHZhbHVlcywgdHlwZSwgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBsaXRlcmFsTWFwKHZhbHVlcywgdHlwZSA9IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IExpdGVyYWxNYXBFeHByKHZhbHVlcy5tYXAoZSA9PiBuZXcgTGl0ZXJhbE1hcEVudHJ5KGUua2V5LCBlLnZhbHVlLCBlLnF1b3RlZCkpLCB0eXBlLCBudWxsKTtcbn1cbmZ1bmN0aW9uIHVuYXJ5KG9wZXJhdG9yLCBleHByLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBVbmFyeU9wZXJhdG9yRXhwcihvcGVyYXRvciwgZXhwciwgdHlwZSwgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBub3QoZXhwciwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTm90RXhwcihleHByLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIGZuKHBhcmFtcywgYm9keSwgdHlwZSwgc291cmNlU3BhbiwgbmFtZSkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb25FeHByKHBhcmFtcywgYm9keSwgdHlwZSwgc291cmNlU3BhbiwgbmFtZSk7XG59XG5mdW5jdGlvbiBpZlN0bXQoY29uZGl0aW9uLCB0aGVuQ2xhdXNlLCBlbHNlQ2xhdXNlLCBzb3VyY2VTcGFuLCBsZWFkaW5nQ29tbWVudHMpIHtcbiAgICByZXR1cm4gbmV3IElmU3RtdChjb25kaXRpb24sIHRoZW5DbGF1c2UsIGVsc2VDbGF1c2UsIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cyk7XG59XG5mdW5jdGlvbiB0YWdnZWRUZW1wbGF0ZSh0YWcsIHRlbXBsYXRlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBUYWdnZWRUZW1wbGF0ZUV4cHIodGFnLCB0ZW1wbGF0ZSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBsaXRlcmFsKHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsRXhwcih2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBsb2NhbGl6ZWRTdHJpbmcobWV0YUJsb2NrLCBtZXNzYWdlUGFydHMsIHBsYWNlaG9sZGVyTmFtZXMsIGV4cHJlc3Npb25zLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBMb2NhbGl6ZWRTdHJpbmcobWV0YUJsb2NrLCBtZXNzYWdlUGFydHMsIHBsYWNlaG9sZGVyTmFtZXMsIGV4cHJlc3Npb25zLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIGlzTnVsbChleHApIHtcbiAgICByZXR1cm4gZXhwIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHIgJiYgZXhwLnZhbHVlID09PSBudWxsO1xufVxuLypcbiAqIFNlcmlhbGl6ZXMgYSBgVGFnYCBpbnRvIGEgc3RyaW5nLlxuICogUmV0dXJucyBhIHN0cmluZyBsaWtlIFwiIEBmb28ge2Jhcn0gYmF6XCIgKG5vdGUgdGhlIGxlYWRpbmcgd2hpdGVzcGFjZSBiZWZvcmUgYEBmb29gKS5cbiAqL1xuZnVuY3Rpb24gdGFnVG9TdHJpbmcodGFnKSB7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGlmICh0YWcudGFnTmFtZSkge1xuICAgICAgICBvdXQgKz0gYCBAJHt0YWcudGFnTmFtZX1gO1xuICAgIH1cbiAgICBpZiAodGFnLnRleHQpIHtcbiAgICAgICAgaWYgKHRhZy50ZXh0Lm1hdGNoKC9cXC9cXCp8XFwqXFwvLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNEb2MgdGV4dCBjYW5ub3QgY29udGFpbiBcIi8qXCIgYW5kIFwiKi9cIicpO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSAnICcgKyB0YWcudGV4dC5yZXBsYWNlKC9AL2csICdcXFxcQCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVGFncyh0YWdzKSB7XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAxICYmIHRhZ3NbMF0udGFnTmFtZSAmJiAhdGFnc1swXS50ZXh0KSB7XG4gICAgICAgIC8vIFRoZSBKU0RPQyBjb21tZW50IGlzIGEgc2luZ2xlIHNpbXBsZSB0YWc6IGUuZyBgLyoqIEB0YWduYW1lICovYC5cbiAgICAgICAgcmV0dXJuIGAqJHt0YWdUb1N0cmluZyh0YWdzWzBdKX0gYDtcbiAgICB9XG4gICAgbGV0IG91dCA9ICcqXFxuJztcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgIG91dCArPSAnIConO1xuICAgICAgICAvLyBJZiB0aGUgdGFnVG9TdHJpbmcgaXMgbXVsdGktbGluZSwgaW5zZXJ0IFwiICogXCIgcHJlZml4ZXMgb24gbGluZXMuXG4gICAgICAgIG91dCArPSB0YWdUb1N0cmluZyh0YWcpLnJlcGxhY2UoL1xcbi9nLCAnXFxuICogJyk7XG4gICAgICAgIG91dCArPSAnXFxuJztcbiAgICB9XG4gICAgb3V0ICs9ICcgJztcbiAgICByZXR1cm4gb3V0O1xufVxuXG52YXIgb3V0cHV0X2FzdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZ2V0IFR5cGVNb2RpZmllciAoKSB7IHJldHVybiBUeXBlTW9kaWZpZXI7IH0sXG4gICAgVHlwZTogVHlwZSxcbiAgICBnZXQgQnVpbHRpblR5cGVOYW1lICgpIHsgcmV0dXJuIEJ1aWx0aW5UeXBlTmFtZTsgfSxcbiAgICBCdWlsdGluVHlwZTogQnVpbHRpblR5cGUsXG4gICAgRXhwcmVzc2lvblR5cGU6IEV4cHJlc3Npb25UeXBlLFxuICAgIEFycmF5VHlwZTogQXJyYXlUeXBlLFxuICAgIE1hcFR5cGU6IE1hcFR5cGUsXG4gICAgRFlOQU1JQ19UWVBFOiBEWU5BTUlDX1RZUEUsXG4gICAgSU5GRVJSRURfVFlQRTogSU5GRVJSRURfVFlQRSxcbiAgICBCT09MX1RZUEU6IEJPT0xfVFlQRSxcbiAgICBJTlRfVFlQRTogSU5UX1RZUEUsXG4gICAgTlVNQkVSX1RZUEU6IE5VTUJFUl9UWVBFLFxuICAgIFNUUklOR19UWVBFOiBTVFJJTkdfVFlQRSxcbiAgICBGVU5DVElPTl9UWVBFOiBGVU5DVElPTl9UWVBFLFxuICAgIE5PTkVfVFlQRTogTk9ORV9UWVBFLFxuICAgIGdldCBVbmFyeU9wZXJhdG9yICgpIHsgcmV0dXJuIFVuYXJ5T3BlcmF0b3I7IH0sXG4gICAgZ2V0IEJpbmFyeU9wZXJhdG9yICgpIHsgcmV0dXJuIEJpbmFyeU9wZXJhdG9yOyB9LFxuICAgIG51bGxTYWZlSXNFcXVpdmFsZW50OiBudWxsU2FmZUlzRXF1aXZhbGVudCxcbiAgICBhcmVBbGxFcXVpdmFsZW50OiBhcmVBbGxFcXVpdmFsZW50LFxuICAgIEV4cHJlc3Npb246IEV4cHJlc3Npb24sXG4gICAgUmVhZFZhckV4cHI6IFJlYWRWYXJFeHByLFxuICAgIFR5cGVvZkV4cHI6IFR5cGVvZkV4cHIsXG4gICAgV3JhcHBlZE5vZGVFeHByOiBXcmFwcGVkTm9kZUV4cHIsXG4gICAgV3JpdGVWYXJFeHByOiBXcml0ZVZhckV4cHIsXG4gICAgV3JpdGVLZXlFeHByOiBXcml0ZUtleUV4cHIsXG4gICAgV3JpdGVQcm9wRXhwcjogV3JpdGVQcm9wRXhwcixcbiAgICBJbnZva2VGdW5jdGlvbkV4cHI6IEludm9rZUZ1bmN0aW9uRXhwcixcbiAgICBUYWdnZWRUZW1wbGF0ZUV4cHI6IFRhZ2dlZFRlbXBsYXRlRXhwcixcbiAgICBJbnN0YW50aWF0ZUV4cHI6IEluc3RhbnRpYXRlRXhwcixcbiAgICBMaXRlcmFsRXhwcjogTGl0ZXJhbEV4cHIsXG4gICAgVGVtcGxhdGVMaXRlcmFsOiBUZW1wbGF0ZUxpdGVyYWwsXG4gICAgVGVtcGxhdGVMaXRlcmFsRWxlbWVudDogVGVtcGxhdGVMaXRlcmFsRWxlbWVudCxcbiAgICBMaXRlcmFsUGllY2U6IExpdGVyYWxQaWVjZSxcbiAgICBQbGFjZWhvbGRlclBpZWNlOiBQbGFjZWhvbGRlclBpZWNlLFxuICAgIExvY2FsaXplZFN0cmluZzogTG9jYWxpemVkU3RyaW5nLFxuICAgIEV4dGVybmFsRXhwcjogRXh0ZXJuYWxFeHByLFxuICAgIEV4dGVybmFsUmVmZXJlbmNlOiBFeHRlcm5hbFJlZmVyZW5jZSxcbiAgICBDb25kaXRpb25hbEV4cHI6IENvbmRpdGlvbmFsRXhwcixcbiAgICBOb3RFeHByOiBOb3RFeHByLFxuICAgIEZuUGFyYW06IEZuUGFyYW0sXG4gICAgRnVuY3Rpb25FeHByOiBGdW5jdGlvbkV4cHIsXG4gICAgVW5hcnlPcGVyYXRvckV4cHI6IFVuYXJ5T3BlcmF0b3JFeHByLFxuICAgIEJpbmFyeU9wZXJhdG9yRXhwcjogQmluYXJ5T3BlcmF0b3JFeHByLFxuICAgIFJlYWRQcm9wRXhwcjogUmVhZFByb3BFeHByLFxuICAgIFJlYWRLZXlFeHByOiBSZWFkS2V5RXhwcixcbiAgICBMaXRlcmFsQXJyYXlFeHByOiBMaXRlcmFsQXJyYXlFeHByLFxuICAgIExpdGVyYWxNYXBFbnRyeTogTGl0ZXJhbE1hcEVudHJ5LFxuICAgIExpdGVyYWxNYXBFeHByOiBMaXRlcmFsTWFwRXhwcixcbiAgICBDb21tYUV4cHI6IENvbW1hRXhwcixcbiAgICBOVUxMX0VYUFI6IE5VTExfRVhQUixcbiAgICBUWVBFRF9OVUxMX0VYUFI6IFRZUEVEX05VTExfRVhQUixcbiAgICBnZXQgU3RtdE1vZGlmaWVyICgpIHsgcmV0dXJuIFN0bXRNb2RpZmllcjsgfSxcbiAgICBMZWFkaW5nQ29tbWVudDogTGVhZGluZ0NvbW1lbnQsXG4gICAgSlNEb2NDb21tZW50OiBKU0RvY0NvbW1lbnQsXG4gICAgU3RhdGVtZW50OiBTdGF0ZW1lbnQsXG4gICAgRGVjbGFyZVZhclN0bXQ6IERlY2xhcmVWYXJTdG10LFxuICAgIERlY2xhcmVGdW5jdGlvblN0bXQ6IERlY2xhcmVGdW5jdGlvblN0bXQsXG4gICAgRXhwcmVzc2lvblN0YXRlbWVudDogRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgICBSZXR1cm5TdGF0ZW1lbnQ6IFJldHVyblN0YXRlbWVudCxcbiAgICBJZlN0bXQ6IElmU3RtdCxcbiAgICBSZWN1cnNpdmVBc3RWaXNpdG9yOiBSZWN1cnNpdmVBc3RWaXNpdG9yJDEsXG4gICAgbGVhZGluZ0NvbW1lbnQ6IGxlYWRpbmdDb21tZW50LFxuICAgIGpzRG9jQ29tbWVudDoganNEb2NDb21tZW50LFxuICAgIHZhcmlhYmxlOiB2YXJpYWJsZSxcbiAgICBpbXBvcnRFeHByOiBpbXBvcnRFeHByLFxuICAgIGltcG9ydFR5cGU6IGltcG9ydFR5cGUsXG4gICAgZXhwcmVzc2lvblR5cGU6IGV4cHJlc3Npb25UeXBlLFxuICAgIHR5cGVvZkV4cHI6IHR5cGVvZkV4cHIsXG4gICAgbGl0ZXJhbEFycjogbGl0ZXJhbEFycixcbiAgICBsaXRlcmFsTWFwOiBsaXRlcmFsTWFwLFxuICAgIHVuYXJ5OiB1bmFyeSxcbiAgICBub3Q6IG5vdCxcbiAgICBmbjogZm4sXG4gICAgaWZTdG10OiBpZlN0bXQsXG4gICAgdGFnZ2VkVGVtcGxhdGU6IHRhZ2dlZFRlbXBsYXRlLFxuICAgIGxpdGVyYWw6IGxpdGVyYWwsXG4gICAgbG9jYWxpemVkU3RyaW5nOiBsb2NhbGl6ZWRTdHJpbmcsXG4gICAgaXNOdWxsOiBpc051bGxcbn0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IENPTlNUQU5UX1BSRUZJWCA9ICdfYyc7XG4vKipcbiAqIGBDb25zdGFudFBvb2xgIHRyaWVzIHRvIHJldXNlIGxpdGVyYWwgZmFjdG9yaWVzIHdoZW4gdHdvIG9yIG1vcmUgbGl0ZXJhbHMgYXJlIGlkZW50aWNhbC5cbiAqIFdlIGRldGVybWluZSB3aGV0aGVyIGxpdGVyYWxzIGFyZSBpZGVudGljYWwgYnkgY3JlYXRpbmcgYSBrZXkgb3V0IG9mIHRoZWlyIEFTVCB1c2luZyB0aGVcbiAqIGBLZXlWaXNpdG9yYC4gVGhpcyBjb25zdGFudCBpcyB1c2VkIHRvIHJlcGxhY2UgZHluYW1pYyBleHByZXNzaW9ucyB3aGljaCBjYW4ndCBiZSBzYWZlbHlcbiAqIGNvbnZlcnRlZCBpbnRvIGEga2V5LiBFLmcuIGdpdmVuIGFuIGV4cHJlc3Npb24gYHtmb286IGJhcigpfWAsIHNpbmNlIHdlIGRvbid0IGtub3cgd2hhdFxuICogdGhlIHJlc3VsdCBvZiBgYmFyYCB3aWxsIGJlLCB3ZSBjcmVhdGUgYSBrZXkgdGhhdCBsb29rcyBsaWtlIGB7Zm9vOiA8dW5rbm93bj59YC4gTm90ZVxuICogdGhhdCB3ZSB1c2UgYSB2YXJpYWJsZSwgcmF0aGVyIHRoYW4gc29tZXRoaW5nIGxpa2UgYG51bGxgIGluIG9yZGVyIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gKi9cbmNvbnN0IFVOS05PV05fVkFMVUVfS0VZID0gdmFyaWFibGUoJzx1bmtub3duPicpO1xuLyoqXG4gKiBDb250ZXh0IHRvIHVzZSB3aGVuIHByb2R1Y2luZyBhIGtleS5cbiAqXG4gKiBUaGlzIGVuc3VyZXMgd2Ugc2VlIHRoZSBjb25zdGFudCBub3QgdGhlIHJlZmVyZW5jZSB2YXJpYWJsZSB3aGVuIHByb2R1Y2luZ1xuICogYSBrZXkuXG4gKi9cbmNvbnN0IEtFWV9DT05URVhUID0ge307XG4vKipcbiAqIEdlbmVyYWxseSBhbGwgcHJpbWl0aXZlIHZhbHVlcyBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgYENvbnN0YW50UG9vbGAsIGJ1dCB0aGVyZSBpcyBhbiBleGNsdXNpb25cbiAqIGZvciBzdHJpbmdzIHRoYXQgcmVhY2ggYSBjZXJ0YWluIGxlbmd0aCB0aHJlc2hvbGQuIFRoaXMgY29uc3RhbnQgZGVmaW5lcyB0aGUgbGVuZ3RoIHRocmVzaG9sZCBmb3JcbiAqIHN0cmluZ3MuXG4gKi9cbmNvbnN0IFBPT0xfSU5DTFVTSU9OX0xFTkdUSF9USFJFU0hPTERfRk9SX1NUUklOR1MgPSA1MDtcbi8qKlxuICogQSBub2RlIHRoYXQgaXMgYSBwbGFjZS1ob2xkZXIgdGhhdCBhbGxvd3MgdGhlIG5vZGUgdG8gYmUgcmVwbGFjZWQgd2hlbiB0aGUgYWN0dWFsXG4gKiBub2RlIGlzIGtub3duLlxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSBjb25zdGFudCBwb29sIHRvIGNoYW5nZSBhbiBleHByZXNzaW9uIGZyb20gYSBkaXJlY3QgcmVmZXJlbmNlIHRvXG4gKiBhIGNvbnN0YW50IHRvIGEgc2hhcmVkIGNvbnN0YW50LiBJdCByZXR1cm5zIGEgZml4LXVwIG5vZGUgdGhhdCBpcyBsYXRlciBhbGxvd2VkIHRvXG4gKiBjaGFuZ2UgdGhlIHJlZmVyZW5jZWQgZXhwcmVzc2lvbi5cbiAqL1xuY2xhc3MgRml4dXBFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocmVzb2x2ZWQpIHtcbiAgICAgICAgc3VwZXIocmVzb2x2ZWQudHlwZSk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSByZXNvbHZlZDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbCA9IHJlc29sdmVkO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gS0VZX0NPTlRFWFQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcHJvZHVjaW5nIGEga2V5IHdlIHdhbnQgdG8gdHJhdmVyc2UgdGhlIGNvbnN0YW50IG5vdCB0aGVcbiAgICAgICAgICAgIC8vIHZhcmlhYmxlIHVzZWQgdG8gcmVmZXIgdG8gaXQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbC52aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZC52aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBGaXh1cEV4cHJlc3Npb24gJiYgdGhpcy5yZXNvbHZlZC5pc0VxdWl2YWxlbnQoZS5yZXNvbHZlZCk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaXh1cChleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnNoYXJlZCA9IHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNvbnN0YW50IHBvb2wgYWxsb3dzIGEgY29kZSBlbWl0dGVyIHRvIHNoYXJlIGNvbnN0YW50IGluIGFuIG91dHB1dCBjb250ZXh0LlxuICpcbiAqIFRoZSBjb25zdGFudCBwb29sIGFsc28gc3VwcG9ydHMgc2hhcmluZyBhY2Nlc3MgdG8gaXZ5IGRlZmluaXRpb25zIHJlZmVyZW5jZXMuXG4gKi9cbmNsYXNzIENvbnN0YW50UG9vbCB7XG4gICAgY29uc3RydWN0b3IoaXNDbG9zdXJlQ29tcGlsZXJFbmFibGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5pc0Nsb3N1cmVDb21waWxlckVuYWJsZWQgPSBpc0Nsb3N1cmVDb21waWxlckVuYWJsZWQ7XG4gICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmxpdGVyYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpdGVyYWxGYWN0b3JpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmV4dE5hbWVJbmRleCA9IDA7XG4gICAgfVxuICAgIGdldENvbnN0TGl0ZXJhbChsaXRlcmFsLCBmb3JjZVNoYXJlZCkge1xuICAgICAgICBpZiAoKGxpdGVyYWwgaW5zdGFuY2VvZiBMaXRlcmFsRXhwciAmJiAhaXNMb25nU3RyaW5nTGl0ZXJhbChsaXRlcmFsKSkgfHxcbiAgICAgICAgICAgIGxpdGVyYWwgaW5zdGFuY2VvZiBGaXh1cEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIERvIG5vIHB1dCBzaW1wbGUgbGl0ZXJhbHMgaW50byB0aGUgY29uc3RhbnQgcG9vbCBvciB0cnkgdG8gcHJvZHVjZSBhIGNvbnN0YW50IGZvciBhXG4gICAgICAgICAgICAvLyByZWZlcmVuY2UgdG8gYSBjb25zdGFudC5cbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5T2YobGl0ZXJhbCk7XG4gICAgICAgIGxldCBmaXh1cCA9IHRoaXMubGl0ZXJhbHMuZ2V0KGtleSk7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIWZpeHVwKSB7XG4gICAgICAgICAgICBmaXh1cCA9IG5ldyBGaXh1cEV4cHJlc3Npb24obGl0ZXJhbCk7XG4gICAgICAgICAgICB0aGlzLmxpdGVyYWxzLnNldChrZXksIGZpeHVwKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFuZXdWYWx1ZSAmJiAhZml4dXAuc2hhcmVkKSB8fCAobmV3VmFsdWUgJiYgZm9yY2VTaGFyZWQpKSB7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBleHByZXNzaW9uIHdpdGggYSB2YXJpYWJsZVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZnJlc2hOYW1lKCk7XG4gICAgICAgICAgICBsZXQgZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGxldCB1c2FnZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2xvc3VyZUNvbXBpbGVyRW5hYmxlZCAmJiBpc0xvbmdTdHJpbmdMaXRlcmFsKGxpdGVyYWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHN0cmluZyBsaXRlcmFscywgQ2xvc3VyZSB3aWxsICoqYWx3YXlzKiogaW5saW5lIHRoZSBzdHJpbmcgYXRcbiAgICAgICAgICAgICAgICAvLyAqKmFsbCoqIHVzYWdlcywgZHVwbGljYXRpbmcgaXQgZWFjaCB0aW1lLiBGb3IgbGFyZ2Ugc3RyaW5ncywgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJpbHkgYmxvYXRzIGJ1bmRsZSBzaXplLiBUbyB3b3JrIGFyb3VuZCB0aGlzIHJlc3RyaWN0aW9uLCB3ZVxuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlIHN0cmluZyBpbiBhIGZ1bmN0aW9uLCBhbmQgY2FsbCB0aGF0IGZ1bmN0aW9uIGZvciBlYWNoIHVzYWdlLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgdHJpY2tzIENsb3N1cmUgaW50byB1c2luZyBpbmxpbmUgbG9naWMgZm9yIGZ1bmN0aW9ucyBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWxzLiBGdW5jdGlvbiBjYWxscyBhcmUgb25seSBpbmxpbmVkIGlmIHRoZSBib2R5IGlzIHNtYWxsXG4gICAgICAgICAgICAgICAgLy8gZW5vdWdoIHRvIGJlIHdvcnRoIGl0LiBCeSBkb2luZyB0aGlzLCB2ZXJ5IGxhcmdlIHN0cmluZ3Mgd2lsbCBiZVxuICAgICAgICAgICAgICAgIC8vIHNoYXJlZCBhY3Jvc3MgbXVsdGlwbGUgdXNhZ2VzLCByYXRoZXIgdGhhbiBkdXBsaWNhdGluZyB0aGUgc3RyaW5nIGF0XG4gICAgICAgICAgICAgICAgLy8gZWFjaCB1c2FnZSBzaXRlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgbXlTdHIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwidmVyeSB2ZXJ5IHZlcnkgbG9uZyBzdHJpbmdcIjsgfTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCB1c2FnZTEgPSBteVN0cigpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHVzYWdlMiA9IG15U3RyKCk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHZhcmlhYmxlKG5hbWUpLnNldChuZXcgRnVuY3Rpb25FeHByKFtdLCAvLyBQYXJhbXMuXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGF0ZW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KGxpdGVyYWwpLFxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICB1c2FnZSA9IHZhcmlhYmxlKG5hbWUpLmNhbGxGbihbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IGRlY2xhcmUgYW5kIHVzZSB0aGUgdmFyaWFibGUgZGlyZWN0bHksIHdpdGhvdXQgYSBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAgICAgLy8gaW5kaXJlY3Rpb24uIFRoaXMgc2F2ZXMgYSBmZXcgYnl0ZXMgYW5kIGF2b2lkcyBhbiB1bm5jZXNzYXJ5IGNhbGwuXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHZhcmlhYmxlKG5hbWUpLnNldChsaXRlcmFsKTtcbiAgICAgICAgICAgICAgICB1c2FnZSA9IHZhcmlhYmxlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZW1lbnRzLnB1c2goZGVmaW5pdGlvbi50b0RlY2xTdG10KElORkVSUkVEX1RZUEUsIFN0bXRNb2RpZmllci5GaW5hbCkpO1xuICAgICAgICAgICAgZml4dXAuZml4dXAodXNhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXh1cDtcbiAgICB9XG4gICAgZ2V0TGl0ZXJhbEZhY3RvcnkobGl0ZXJhbCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBwdXJlIGZ1bmN0aW9uIHRoYXQgYnVpbGRzIGFuIGFycmF5IG9mIGEgbWl4IG9mIGNvbnN0YW50IGFuZCB2YXJpYWJsZSBleHByZXNzaW9uc1xuICAgICAgICBpZiAobGl0ZXJhbCBpbnN0YW5jZW9mIExpdGVyYWxBcnJheUV4cHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c0ZvcktleSA9IGxpdGVyYWwuZW50cmllcy5tYXAoZSA9PiBlLmlzQ29uc3RhbnQoKSA/IGUgOiBVTktOT1dOX1ZBTFVFX0tFWSk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmtleU9mKGxpdGVyYWxBcnIoYXJndW1lbnRzRm9yS2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGl0ZXJhbEZhY3Rvcnkoa2V5LCBsaXRlcmFsLmVudHJpZXMsIGVudHJpZXMgPT4gbGl0ZXJhbEFycihlbnRyaWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uRm9yS2V5ID0gbGl0ZXJhbE1hcChsaXRlcmFsLmVudHJpZXMubWFwKGUgPT4gKHtcbiAgICAgICAgICAgICAgICBrZXk6IGUua2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBlLnZhbHVlLmlzQ29uc3RhbnQoKSA/IGUudmFsdWUgOiBVTktOT1dOX1ZBTFVFX0tFWSxcbiAgICAgICAgICAgICAgICBxdW90ZWQ6IGUucXVvdGVkXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlPZihleHByZXNzaW9uRm9yS2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRMaXRlcmFsRmFjdG9yeShrZXksIGxpdGVyYWwuZW50cmllcy5tYXAoZSA9PiBlLnZhbHVlKSwgZW50cmllcyA9PiBsaXRlcmFsTWFwKGVudHJpZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAga2V5OiBsaXRlcmFsLmVudHJpZXNbaW5kZXhdLmtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBxdW90ZWQ6IGxpdGVyYWwuZW50cmllc1tpbmRleF0ucXVvdGVkXG4gICAgICAgICAgICB9KSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0TGl0ZXJhbEZhY3Rvcnkoa2V5LCB2YWx1ZXMsIHJlc3VsdE1hcCkge1xuICAgICAgICBsZXQgbGl0ZXJhbEZhY3RvcnkgPSB0aGlzLmxpdGVyYWxGYWN0b3JpZXMuZ2V0KGtleSk7XG4gICAgICAgIGNvbnN0IGxpdGVyYWxGYWN0b3J5QXJndW1lbnRzID0gdmFsdWVzLmZpbHRlcigoZSA9PiAhZS5pc0NvbnN0YW50KCkpKTtcbiAgICAgICAgaWYgKCFsaXRlcmFsRmFjdG9yeSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0RXhwcmVzc2lvbnMgPSB2YWx1ZXMubWFwKChlLCBpbmRleCkgPT4gZS5pc0NvbnN0YW50KCkgPyB0aGlzLmdldENvbnN0TGl0ZXJhbChlLCB0cnVlKSA6IHZhcmlhYmxlKGBhJHtpbmRleH1gKSk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gcmVzdWx0RXhwcmVzc2lvbnMuZmlsdGVyKGlzVmFyaWFibGUpLm1hcChlID0+IG5ldyBGblBhcmFtKGUubmFtZSwgRFlOQU1JQ19UWVBFKSk7XG4gICAgICAgICAgICBjb25zdCBwdXJlRnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZuKHBhcmFtZXRlcnMsIFtuZXcgUmV0dXJuU3RhdGVtZW50KHJlc3VsdE1hcChyZXN1bHRFeHByZXNzaW9ucykpXSwgSU5GRVJSRURfVFlQRSk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5mcmVzaE5hbWUoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKHZhcmlhYmxlKG5hbWUpXG4gICAgICAgICAgICAgICAgLnNldChwdXJlRnVuY3Rpb25EZWNsYXJhdGlvbilcbiAgICAgICAgICAgICAgICAudG9EZWNsU3RtdChJTkZFUlJFRF9UWVBFLCBTdG10TW9kaWZpZXIuRmluYWwpKTtcbiAgICAgICAgICAgIGxpdGVyYWxGYWN0b3J5ID0gdmFyaWFibGUobmFtZSk7XG4gICAgICAgICAgICB0aGlzLmxpdGVyYWxGYWN0b3JpZXMuc2V0KGtleSwgbGl0ZXJhbEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpdGVyYWxGYWN0b3J5LCBsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlIGEgdW5pcXVlIG5hbWUuXG4gICAgICpcbiAgICAgKiBUaGUgbmFtZSBtaWdodCBiZSB1bmlxdWUgYW1vbmcgZGlmZmVyZW50IHByZWZpeGVzIGlmIGFueSBvZiB0aGUgcHJlZml4ZXMgZW5kIGluXG4gICAgICogYSBkaWdpdCBzbyB0aGUgcHJlZml4IHNob3VsZCBiZSBhIGNvbnN0YW50IHN0cmluZyAobm90IGJhc2VkIG9uIHVzZXIgaW5wdXQpIGFuZFxuICAgICAqIG11c3Qgbm90IGVuZCBpbiBhIGRpZ2l0LlxuICAgICAqL1xuICAgIHVuaXF1ZU5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHt0aGlzLm5leHROYW1lSW5kZXgrK31gO1xuICAgIH1cbiAgICBmcmVzaE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaXF1ZU5hbWUoQ09OU1RBTlRfUFJFRklYKTtcbiAgICB9XG4gICAga2V5T2YoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi52aXNpdEV4cHJlc3Npb24obmV3IEtleVZpc2l0b3IoKSwgS0VZX0NPTlRFWFQpO1xuICAgIH1cbn1cbi8qKlxuICogVmlzaXRvciB1c2VkIHRvIGRldGVybWluZSBpZiAyIGV4cHJlc3Npb25zIGFyZSBlcXVpdmFsZW50IGFuZCBjYW4gYmUgc2hhcmVkIGluIHRoZVxuICogYENvbnN0YW50UG9vbGAuXG4gKlxuICogV2hlbiB0aGUgaWQgKHN0cmluZykgZ2VuZXJhdGVkIGJ5IHRoZSB2aXNpdG9yIGlzIGVxdWFsLCBleHByZXNzaW9ucyBhcmUgY29uc2lkZXJlZCBlcXVpdmFsZW50LlxuICovXG5jbGFzcyBLZXlWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aXNpdFdyYXBwZWROb2RlRXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFdyaXRlVmFyRXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFdyaXRlS2V5RXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFdyaXRlUHJvcEV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRUYWdnZWRUZW1wbGF0ZUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRDb25kaXRpb25hbEV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXROb3RFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRDYXN0RXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uRXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFVuYXJ5T3BlcmF0b3JFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0UmVhZFByb3BFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0UmVhZEtleUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRDb21tYUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRMb2NhbGl6ZWRTdHJpbmcgPSBpbnZhbGlkJDE7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEV4cHIoYXN0KSB7XG4gICAgICAgIHJldHVybiBgJHt0eXBlb2YgYXN0LnZhbHVlID09PSAnc3RyaW5nJyA/ICdcIicgKyBhc3QudmFsdWUgKyAnXCInIDogYXN0LnZhbHVlfWA7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5RXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGBbJHthc3QuZW50cmllcy5tYXAoZW50cnkgPT4gZW50cnkudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKS5qb2luKCcsJyl9XWA7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcEV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG1hcEtleSA9IChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVvdGUgPSBlbnRyeS5xdW90ZWQgPyAnXCInIDogJyc7XG4gICAgICAgICAgICByZXR1cm4gYCR7cXVvdGV9JHtlbnRyeS5rZXl9JHtxdW90ZX1gO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXBFbnRyeSA9IChlbnRyeSkgPT4gYCR7bWFwS2V5KGVudHJ5KX06JHtlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCl9YDtcbiAgICAgICAgcmV0dXJuIGB7JHthc3QuZW50cmllcy5tYXAobWFwRW50cnkpLmpvaW4oJywnKX1gO1xuICAgIH1cbiAgICB2aXNpdEV4dGVybmFsRXhwcihhc3QpIHtcbiAgICAgICAgcmV0dXJuIGFzdC52YWx1ZS5tb2R1bGVOYW1lID8gYEVYOiR7YXN0LnZhbHVlLm1vZHVsZU5hbWV9OiR7YXN0LnZhbHVlLm5hbWV9YCA6XG4gICAgICAgICAgICBgRVg6JHthc3QudmFsdWUucnVudGltZS5uYW1lfWA7XG4gICAgfVxuICAgIHZpc2l0UmVhZFZhckV4cHIobm9kZSkge1xuICAgICAgICByZXR1cm4gYFZBUjoke25vZGUubmFtZX1gO1xuICAgIH1cbiAgICB2aXNpdFR5cGVvZkV4cHIobm9kZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYFRZUEVPRjoke25vZGUuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCl9YDtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnZhbGlkJDEoYXJnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlOiBWaXNpdG9yICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBkb2Vzbid0IGhhbmRsZSAke2FyZy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xufVxuZnVuY3Rpb24gaXNWYXJpYWJsZShlKSB7XG4gICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBSZWFkVmFyRXhwcjtcbn1cbmZ1bmN0aW9uIGlzTG9uZ1N0cmluZ0xpdGVyYWwoZXhwcikge1xuICAgIHJldHVybiBleHByIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHIgJiYgdHlwZW9mIGV4cHIudmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGV4cHIudmFsdWUubGVuZ3RoID49IFBPT0xfSU5DTFVTSU9OX0xFTkdUSF9USFJFU0hPTERfRk9SX1NUUklOR1M7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgQ09SRSQxID0gJ0Bhbmd1bGFyL2NvcmUnO1xuY2xhc3MgSWRlbnRpZmllcnMkMSB7XG59XG4vKiBNZXRob2RzICovXG5JZGVudGlmaWVycyQxLk5FV19NRVRIT0QgPSAnZmFjdG9yeSc7XG5JZGVudGlmaWVycyQxLlRSQU5TRk9STV9NRVRIT0QgPSAndHJhbnNmb3JtJztcbklkZW50aWZpZXJzJDEuUEFUQ0hfREVQUyA9ICdwYXRjaGVkRGVwcyc7XG5JZGVudGlmaWVycyQxLmNvcmUgPSB7IG5hbWU6IG51bGwsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuLyogSW5zdHJ1Y3Rpb25zICovXG5JZGVudGlmaWVycyQxLm5hbWVzcGFjZUhUTUwgPSB7IG5hbWU6ICfJtcm1bmFtZXNwYWNlSFRNTCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5uYW1lc3BhY2VNYXRoTUwgPSB7IG5hbWU6ICfJtcm1bmFtZXNwYWNlTWF0aE1MJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLm5hbWVzcGFjZVNWRyA9IHsgbmFtZTogJ8m1ybVuYW1lc3BhY2VTVkcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuZWxlbWVudCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmVsZW1lbnRTdGFydCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50U3RhcnQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuZWxlbWVudEVuZCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50RW5kJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmFkdmFuY2UgPSB7IG5hbWU6ICfJtcm1YWR2YW5jZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zeW50aGV0aWNIb3N0UHJvcGVydHkgPSB7IG5hbWU6ICfJtcm1c3ludGhldGljSG9zdFByb3BlcnR5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnN5bnRoZXRpY0hvc3RMaXN0ZW5lciA9IHsgbmFtZTogJ8m1ybVzeW50aGV0aWNIb3N0TGlzdGVuZXInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuYXR0cmlidXRlID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTEgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmF0dHJpYnV0ZUludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuYXR0cmlidXRlSW50ZXJwb2xhdGUzID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTQgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmF0dHJpYnV0ZUludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuYXR0cmlidXRlSW50ZXJwb2xhdGU2ID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTcgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmF0dHJpYnV0ZUludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTgnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuYXR0cmlidXRlSW50ZXJwb2xhdGVWID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc1Byb3AgPSB7IG5hbWU6ICfJtcm1Y2xhc3NQcm9wJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmVsZW1lbnRDb250YWluZXJTdGFydCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50Q29udGFpbmVyU3RhcnQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuZWxlbWVudENvbnRhaW5lckVuZCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50Q29udGFpbmVyRW5kJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmVsZW1lbnRDb250YWluZXIgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudENvbnRhaW5lcicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcCA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcCA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZVByb3AgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnN0eWxlUHJvcEludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTEnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGUyID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTMgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnN0eWxlUHJvcEludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGU1ID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTYgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnN0eWxlUHJvcEludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGU4ID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZVYgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLm5leHRDb250ZXh0ID0geyBuYW1lOiAnybXJtW5leHRDb250ZXh0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnRlbXBsYXRlQ3JlYXRlID0geyBuYW1lOiAnybXJtXRlbXBsYXRlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnRleHQgPSB7IG5hbWU6ICfJtcm1dGV4dCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5lbmFibGVCaW5kaW5ncyA9IHsgbmFtZTogJ8m1ybVlbmFibGVCaW5kaW5ncycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5kaXNhYmxlQmluZGluZ3MgPSB7IG5hbWU6ICfJtcm1ZGlzYWJsZUJpbmRpbmdzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmdldEN1cnJlbnRWaWV3ID0geyBuYW1lOiAnybXJtWdldEN1cnJlbnRWaWV3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZSA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZTIgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUzID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTMnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZTUgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGU2ID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZTggPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGVWID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZVYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucmVzdG9yZVZpZXcgPSB7IG5hbWU6ICfJtcm1cmVzdG9yZVZpZXcnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uMCA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb24wJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnB1cmVGdW5jdGlvbjEgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uMScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb24yID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uMyA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb24zJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnB1cmVGdW5jdGlvbjQgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uNCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb241ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uNiA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb242JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnB1cmVGdW5jdGlvbjcgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uNycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb244ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjgnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uViA9IHsgbmFtZTogJ8m1ybVwdXJlRnVuY3Rpb25WJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnBpcGVCaW5kMSA9IHsgbmFtZTogJ8m1ybVwaXBlQmluZDEnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucGlwZUJpbmQyID0geyBuYW1lOiAnybXJtXBpcGVCaW5kMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5waXBlQmluZDMgPSB7IG5hbWU6ICfJtcm1cGlwZUJpbmQzJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnBpcGVCaW5kNCA9IHsgbmFtZTogJ8m1ybVwaXBlQmluZDQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucGlwZUJpbmRWID0geyBuYW1lOiAnybXJtXBpcGVCaW5kVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5ob3N0UHJvcGVydHkgPSB7IG5hbWU6ICfJtcm1aG9zdFByb3BlcnR5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnByb3BlcnR5ID0geyBuYW1lOiAnybXJtXByb3BlcnR5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGUgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5pMThuID0geyBuYW1lOiAnybXJtWkxOG4nLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuaTE4bkF0dHJpYnV0ZXMgPSB7IG5hbWU6ICfJtcm1aTE4bkF0dHJpYnV0ZXMnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuaTE4bkV4cCA9IHsgbmFtZTogJ8m1ybVpMThuRXhwJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmkxOG5TdGFydCA9IHsgbmFtZTogJ8m1ybVpMThuU3RhcnQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuaTE4bkVuZCA9IHsgbmFtZTogJ8m1ybVpMThuRW5kJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmkxOG5BcHBseSA9IHsgbmFtZTogJ8m1ybVpMThuQXBwbHknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuaTE4blBvc3Rwcm9jZXNzID0geyBuYW1lOiAnybXJtWkxOG5Qb3N0cHJvY2VzcycsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5waXBlID0geyBuYW1lOiAnybXJtXBpcGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucHJvamVjdGlvbiA9IHsgbmFtZTogJ8m1ybVwcm9qZWN0aW9uJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnByb2plY3Rpb25EZWYgPSB7IG5hbWU6ICfJtcm1cHJvamVjdGlvbkRlZicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5yZWZlcmVuY2UgPSB7IG5hbWU6ICfJtcm1cmVmZXJlbmNlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmluamVjdCA9IHsgbmFtZTogJ8m1ybVpbmplY3QnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuaW5qZWN0QXR0cmlidXRlID0geyBuYW1lOiAnybXJtWluamVjdEF0dHJpYnV0ZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5kaXJlY3RpdmVJbmplY3QgPSB7IG5hbWU6ICfJtcm1ZGlyZWN0aXZlSW5qZWN0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmludmFsaWRGYWN0b3J5ID0geyBuYW1lOiAnybXJtWludmFsaWRGYWN0b3J5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmludmFsaWRGYWN0b3J5RGVwID0geyBuYW1lOiAnybXJtWludmFsaWRGYWN0b3J5RGVwJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnRlbXBsYXRlUmVmRXh0cmFjdG9yID0geyBuYW1lOiAnybXJtXRlbXBsYXRlUmVmRXh0cmFjdG9yJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmZvcndhcmRSZWYgPSB7IG5hbWU6ICdmb3J3YXJkUmVmJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnJlc29sdmVGb3J3YXJkUmVmID0geyBuYW1lOiAncmVzb2x2ZUZvcndhcmRSZWYnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuybXJtWRlZmluZUluamVjdGFibGUgPSB7IG5hbWU6ICfJtcm1ZGVmaW5lSW5qZWN0YWJsZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5kZWNsYXJlSW5qZWN0YWJsZSA9IHsgbmFtZTogJ8m1ybVuZ0RlY2xhcmVJbmplY3RhYmxlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLkluamVjdGFibGVEZWNsYXJhdGlvbiA9IHsgbmFtZTogJ8m1ybVJbmplY3RhYmxlRGVjbGFyYXRpb24nLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucmVzb2x2ZVdpbmRvdyA9IHsgbmFtZTogJ8m1ybVyZXNvbHZlV2luZG93JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnJlc29sdmVEb2N1bWVudCA9IHsgbmFtZTogJ8m1ybVyZXNvbHZlRG9jdW1lbnQnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucmVzb2x2ZUJvZHkgPSB7IG5hbWU6ICfJtcm1cmVzb2x2ZUJvZHknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuZGVmaW5lQ29tcG9uZW50ID0geyBuYW1lOiAnybXJtWRlZmluZUNvbXBvbmVudCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5kZWNsYXJlQ29tcG9uZW50ID0geyBuYW1lOiAnybXJtW5nRGVjbGFyZUNvbXBvbmVudCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zZXRDb21wb25lbnRTY29wZSA9IHsgbmFtZTogJ8m1ybVzZXRDb21wb25lbnRTY29wZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHtcbiAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3knLFxuICAgIG1vZHVsZU5hbWU6IENPUkUkMSxcbn07XG5JZGVudGlmaWVycyQxLlZpZXdFbmNhcHN1bGF0aW9uID0ge1xuICAgIG5hbWU6ICdWaWV3RW5jYXBzdWxhdGlvbicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSQxLFxufTtcbklkZW50aWZpZXJzJDEuQ29tcG9uZW50RGVjbGFyYXRpb24gPSB7XG4gICAgbmFtZTogJ8m1ybVDb21wb25lbnREZWNsYXJhdGlvbicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSQxLFxufTtcbklkZW50aWZpZXJzJDEuRmFjdG9yeURlY2xhcmF0aW9uID0ge1xuICAgIG5hbWU6ICfJtcm1RmFjdG9yeURlY2xhcmF0aW9uJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFJDEsXG59O1xuSWRlbnRpZmllcnMkMS5kZWNsYXJlRmFjdG9yeSA9IHsgbmFtZTogJ8m1ybVuZ0RlY2xhcmVGYWN0b3J5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLkZhY3RvcnlUYXJnZXQgPSB7IG5hbWU6ICfJtcm1RmFjdG9yeVRhcmdldCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5kZWZpbmVEaXJlY3RpdmUgPSB7IG5hbWU6ICfJtcm1ZGVmaW5lRGlyZWN0aXZlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmRlY2xhcmVEaXJlY3RpdmUgPSB7IG5hbWU6ICfJtcm1bmdEZWNsYXJlRGlyZWN0aXZlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLkRpcmVjdGl2ZURlY2xhcmF0aW9uID0ge1xuICAgIG5hbWU6ICfJtcm1RGlyZWN0aXZlRGVjbGFyYXRpb24nLFxuICAgIG1vZHVsZU5hbWU6IENPUkUkMSxcbn07XG5JZGVudGlmaWVycyQxLkluamVjdG9yRGVmID0geyBuYW1lOiAnybXJtUluamVjdG9yRGVmJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLkluamVjdG9yRGVjbGFyYXRpb24gPSB7IG5hbWU6ICfJtcm1SW5qZWN0b3JEZWNsYXJhdGlvbicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5kZWZpbmVJbmplY3RvciA9IHsgbmFtZTogJ8m1ybVkZWZpbmVJbmplY3RvcicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5kZWNsYXJlSW5qZWN0b3IgPSB7IG5hbWU6ICfJtcm1bmdEZWNsYXJlSW5qZWN0b3InLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuTmdNb2R1bGVEZWNsYXJhdGlvbiA9IHtcbiAgICBuYW1lOiAnybXJtU5nTW9kdWxlRGVjbGFyYXRpb24nLFxuICAgIG1vZHVsZU5hbWU6IENPUkUkMSxcbn07XG5JZGVudGlmaWVycyQxLk1vZHVsZVdpdGhQcm92aWRlcnMgPSB7XG4gICAgbmFtZTogJ01vZHVsZVdpdGhQcm92aWRlcnMnLFxuICAgIG1vZHVsZU5hbWU6IENPUkUkMSxcbn07XG5JZGVudGlmaWVycyQxLmRlZmluZU5nTW9kdWxlID0geyBuYW1lOiAnybXJtWRlZmluZU5nTW9kdWxlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmRlY2xhcmVOZ01vZHVsZSA9IHsgbmFtZTogJ8m1ybVuZ0RlY2xhcmVOZ01vZHVsZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zZXROZ01vZHVsZVNjb3BlID0geyBuYW1lOiAnybXJtXNldE5nTW9kdWxlU2NvcGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuUGlwZURlY2xhcmF0aW9uID0geyBuYW1lOiAnybXJtVBpcGVEZWNsYXJhdGlvbicsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5kZWZpbmVQaXBlID0geyBuYW1lOiAnybXJtWRlZmluZVBpcGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuZGVjbGFyZVBpcGUgPSB7IG5hbWU6ICfJtcm1bmdEZWNsYXJlUGlwZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5kZWNsYXJlQ2xhc3NNZXRhZGF0YSA9IHsgbmFtZTogJ8m1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnNldENsYXNzTWV0YWRhdGEgPSB7IG5hbWU6ICfJtXNldENsYXNzTWV0YWRhdGEnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEucXVlcnlSZWZyZXNoID0geyBuYW1lOiAnybXJtXF1ZXJ5UmVmcmVzaCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS52aWV3UXVlcnkgPSB7IG5hbWU6ICfJtcm1dmlld1F1ZXJ5JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLmxvYWRRdWVyeSA9IHsgbmFtZTogJ8m1ybVsb2FkUXVlcnknLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuY29udGVudFF1ZXJ5ID0geyBuYW1lOiAnybXJtWNvbnRlbnRRdWVyeScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5OZ09uQ2hhbmdlc0ZlYXR1cmUgPSB7IG5hbWU6ICfJtcm1TmdPbkNoYW5nZXNGZWF0dXJlJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLkluaGVyaXREZWZpbml0aW9uRmVhdHVyZSA9IHsgbmFtZTogJ8m1ybVJbmhlcml0RGVmaW5pdGlvbkZlYXR1cmUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuQ29weURlZmluaXRpb25GZWF0dXJlID0geyBuYW1lOiAnybXJtUNvcHlEZWZpbml0aW9uRmVhdHVyZScsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5Qcm92aWRlcnNGZWF0dXJlID0geyBuYW1lOiAnybXJtVByb3ZpZGVyc0ZlYXR1cmUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEubGlzdGVuZXIgPSB7IG5hbWU6ICfJtcm1bGlzdGVuZXInLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuZ2V0SW5oZXJpdGVkRmFjdG9yeSA9IHtcbiAgICBuYW1lOiAnybXJtWdldEluaGVyaXRlZEZhY3RvcnknLFxuICAgIG1vZHVsZU5hbWU6IENPUkUkMSxcbn07XG4vLyBzYW5pdGl6YXRpb24tcmVsYXRlZCBmdW5jdGlvbnNcbklkZW50aWZpZXJzJDEuc2FuaXRpemVIdG1sID0geyBuYW1lOiAnybXJtXNhbml0aXplSHRtbCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuSWRlbnRpZmllcnMkMS5zYW5pdGl6ZVN0eWxlID0geyBuYW1lOiAnybXJtXNhbml0aXplU3R5bGUnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEuc2FuaXRpemVSZXNvdXJjZVVybCA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVJlc291cmNlVXJsJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnNhbml0aXplU2NyaXB0ID0geyBuYW1lOiAnybXJtXNhbml0aXplU2NyaXB0JywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnNhbml0aXplVXJsID0geyBuYW1lOiAnybXJtXNhbml0aXplVXJsJywgbW9kdWxlTmFtZTogQ09SRSQxIH07XG5JZGVudGlmaWVycyQxLnNhbml0aXplVXJsT3JSZXNvdXJjZVVybCA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVVybE9yUmVzb3VyY2VVcmwnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEudHJ1c3RDb25zdGFudEh0bWwgPSB7IG5hbWU6ICfJtcm1dHJ1c3RDb25zdGFudEh0bWwnLCBtb2R1bGVOYW1lOiBDT1JFJDEgfTtcbklkZW50aWZpZXJzJDEudHJ1c3RDb25zdGFudFJlc291cmNlVXJsID0geyBuYW1lOiAnybXJtXRydXN0Q29uc3RhbnRSZXNvdXJjZVVybCcsIG1vZHVsZU5hbWU6IENPUkUkMSB9O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdFxuY29uc3QgVkVSU0lPTiQxID0gMztcbmNvbnN0IEpTX0I2NF9QUkVGSVggPSAnIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJztcbmNsYXNzIFNvdXJjZU1hcEdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoZmlsZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICAgICAgdGhpcy5zb3VyY2VzQ29udGVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5saW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmxhc3RDb2wwID0gMDtcbiAgICAgICAgdGhpcy5oYXNNYXBwaW5ncyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBUaGUgY29udGVudCBpcyBgbnVsbGAgd2hlbiB0aGUgY29udGVudCBpcyBleHBlY3RlZCB0byBiZSBsb2FkZWQgdXNpbmcgdGhlIFVSTFxuICAgIGFkZFNvdXJjZSh1cmwsIGNvbnRlbnQgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudC5oYXModXJsKSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzQ29udGVudC5zZXQodXJsLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkTGluZSgpIHtcbiAgICAgICAgdGhpcy5saW5lcy5wdXNoKFtdKTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRNYXBwaW5nKGNvbDAsIHNvdXJjZVVybCwgc291cmNlTGluZTAsIHNvdXJjZUNvbDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRMaW5lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgbGluZSBtdXN0IGJlIGFkZGVkIGJlZm9yZSBtYXBwaW5ncyBjYW4gYmUgYWRkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlVXJsICE9IG51bGwgJiYgIXRoaXMuc291cmNlc0NvbnRlbnQuaGFzKHNvdXJjZVVybCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzb3VyY2UgZmlsZSBcIiR7c291cmNlVXJsfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbDAgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgY29sdW1uIGluIHRoZSBnZW5lcmF0ZWQgY29kZSBtdXN0IGJlIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbDAgPCB0aGlzLmxhc3RDb2wwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hcHBpbmcgc2hvdWxkIGJlIGFkZGVkIGluIG91dHB1dCBvcmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VVcmwgJiYgKHNvdXJjZUxpbmUwID09IG51bGwgfHwgc291cmNlQ29sMCA9PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc291cmNlIGxvY2F0aW9uIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBhIHNvdXJjZSB1cmwgaXMgcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc01hcHBpbmdzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IGNvbDA7XG4gICAgICAgIHRoaXMuY3VycmVudExpbmUucHVzaCh7IGNvbDAsIHNvdXJjZVVybCwgc291cmNlTGluZTAsIHNvdXJjZUNvbDAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgc3RyaXAgdGhpcyBmcm9tIHB1Ymxpc2hlZCBkLnRzIGZpbGVzIGR1ZSB0b1xuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzYyMTZcbiAgICAgKi9cbiAgICBnZXQgY3VycmVudExpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVzLnNsaWNlKC0xKVswXTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzTWFwcGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZXNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgICAgICBjb25zdCBzb3VyY2VzQ29udGVudCA9IFtdO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuc291cmNlc0NvbnRlbnQua2V5cygpKS5mb3JFYWNoKCh1cmwsIGkpID0+IHtcbiAgICAgICAgICAgIHNvdXJjZXNJbmRleC5zZXQodXJsLCBpKTtcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaCh1cmwpO1xuICAgICAgICAgICAgc291cmNlc0NvbnRlbnQucHVzaCh0aGlzLnNvdXJjZXNDb250ZW50LmdldCh1cmwpIHx8IG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IG1hcHBpbmdzID0gJyc7XG4gICAgICAgIGxldCBsYXN0Q29sMCA9IDA7XG4gICAgICAgIGxldCBsYXN0U291cmNlSW5kZXggPSAwO1xuICAgICAgICBsZXQgbGFzdFNvdXJjZUxpbmUwID0gMDtcbiAgICAgICAgbGV0IGxhc3RTb3VyY2VDb2wwID0gMDtcbiAgICAgICAgdGhpcy5saW5lcy5mb3JFYWNoKHNlZ21lbnRzID0+IHtcbiAgICAgICAgICAgIGxhc3RDb2wwID0gMDtcbiAgICAgICAgICAgIG1hcHBpbmdzICs9IHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgLm1hcChzZWdtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAvLyB6ZXJvLWJhc2VkIHN0YXJ0aW5nIGNvbHVtbiBvZiB0aGUgbGluZSBpbiB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAgICAgICAgICAgICBsZXQgc2VnQXNTdHIgPSB0b0Jhc2U2NFZMUShzZWdtZW50LmNvbDAgLSBsYXN0Q29sMCk7XG4gICAgICAgICAgICAgICAgbGFzdENvbDAgPSBzZWdtZW50LmNvbDA7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQuc291cmNlVXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBpbmRleCBpbnRvIHRoZSDigJxzb3VyY2Vz4oCdIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQmFzZTY0VkxRKHNvdXJjZXNJbmRleC5nZXQoc2VnbWVudC5zb3VyY2VVcmwpIC0gbGFzdFNvdXJjZUluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUluZGV4ID0gc291cmNlc0luZGV4LmdldChzZWdtZW50LnNvdXJjZVVybCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB6ZXJvLWJhc2VkIHN0YXJ0aW5nIGxpbmUgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICBzZWdBc1N0ciArPSB0b0Jhc2U2NFZMUShzZWdtZW50LnNvdXJjZUxpbmUwIC0gbGFzdFNvdXJjZUxpbmUwKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUxpbmUwID0gc2VnbWVudC5zb3VyY2VMaW5lMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHplcm8tYmFzZWQgc3RhcnRpbmcgY29sdW1uIGluIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz0gdG9CYXNlNjRWTFEoc2VnbWVudC5zb3VyY2VDb2wwIC0gbGFzdFNvdXJjZUNvbDApO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U291cmNlQ29sMCA9IHNlZ21lbnQuc291cmNlQ29sMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZ0FzU3RyO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gJzsnO1xuICAgICAgICB9KTtcbiAgICAgICAgbWFwcGluZ3MgPSBtYXBwaW5ncy5zbGljZSgwLCAtMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZmlsZSc6IHRoaXMuZmlsZSB8fCAnJyxcbiAgICAgICAgICAgICd2ZXJzaW9uJzogVkVSU0lPTiQxLFxuICAgICAgICAgICAgJ3NvdXJjZVJvb3QnOiAnJyxcbiAgICAgICAgICAgICdzb3VyY2VzJzogc291cmNlcyxcbiAgICAgICAgICAgICdzb3VyY2VzQ29udGVudCc6IHNvdXJjZXNDb250ZW50LFxuICAgICAgICAgICAgJ21hcHBpbmdzJzogbWFwcGluZ3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvSnNDb21tZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNNYXBwaW5ncyA/ICcvLycgKyBKU19CNjRfUFJFRklYICsgdG9CYXNlNjRTdHJpbmcoSlNPTi5zdHJpbmdpZnkodGhpcywgbnVsbCwgMCkpIDpcbiAgICAgICAgICAgICcnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQmFzZTY0U3RyaW5nKHZhbHVlKSB7XG4gICAgbGV0IGI2NCA9ICcnO1xuICAgIGNvbnN0IGVuY29kZWQgPSB1dGY4RW5jb2RlKHZhbHVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOykge1xuICAgICAgICBjb25zdCBpMSA9IGVuY29kZWRbaSsrXTtcbiAgICAgICAgY29uc3QgaTIgPSBpIDwgZW5jb2RlZC5sZW5ndGggPyBlbmNvZGVkW2krK10gOiBudWxsO1xuICAgICAgICBjb25zdCBpMyA9IGkgPCBlbmNvZGVkLmxlbmd0aCA/IGVuY29kZWRbaSsrXSA6IG51bGw7XG4gICAgICAgIGI2NCArPSB0b0Jhc2U2NERpZ2l0KGkxID4+IDIpO1xuICAgICAgICBiNjQgKz0gdG9CYXNlNjREaWdpdCgoKGkxICYgMykgPDwgNCkgfCAoaTIgPT09IG51bGwgPyAwIDogaTIgPj4gNCkpO1xuICAgICAgICBiNjQgKz0gaTIgPT09IG51bGwgPyAnPScgOiB0b0Jhc2U2NERpZ2l0KCgoaTIgJiAxNSkgPDwgMikgfCAoaTMgPT09IG51bGwgPyAwIDogaTMgPj4gNikpO1xuICAgICAgICBiNjQgKz0gaTIgPT09IG51bGwgfHwgaTMgPT09IG51bGwgPyAnPScgOiB0b0Jhc2U2NERpZ2l0KGkzICYgNjMpO1xuICAgIH1cbiAgICByZXR1cm4gYjY0O1xufVxuZnVuY3Rpb24gdG9CYXNlNjRWTFEodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlIDwgMCA/ICgoLXZhbHVlKSA8PCAxKSArIDEgOiB2YWx1ZSA8PCAxO1xuICAgIGxldCBvdXQgPSAnJztcbiAgICBkbyB7XG4gICAgICAgIGxldCBkaWdpdCA9IHZhbHVlICYgMzE7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPj4gNTtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgZGlnaXQgPSBkaWdpdCB8IDMyO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSB0b0Jhc2U2NERpZ2l0KGRpZ2l0KTtcbiAgICB9IHdoaWxlICh2YWx1ZSA+IDApO1xuICAgIHJldHVybiBvdXQ7XG59XG5jb25zdCBCNjRfRElHSVRTID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuZnVuY3Rpb24gdG9CYXNlNjREaWdpdCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gb25seSBlbmNvZGUgdmFsdWUgaW4gdGhlIHJhbmdlIFswLCA2M11gKTtcbiAgICB9XG4gICAgcmV0dXJuIEI2NF9ESUdJVFNbdmFsdWVdO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSA9IC8nfFxcXFx8XFxufFxccnxcXCQvZztcbmNvbnN0IF9MRUdBTF9JREVOVElGSUVSX1JFID0gL15bJEEtWl9dWzAtOUEtWl8kXSokL2k7XG5jb25zdCBfSU5ERU5UX1dJVEggPSAnICAnO1xuY2xhc3MgX0VtaXR0ZWRMaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihpbmRlbnQpIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgIHRoaXMucGFydHNMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIHRoaXMuc3JjU3BhbnMgPSBbXTtcbiAgICB9XG59XG5jbGFzcyBFbWl0dGVyVmlzaXRvckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKF9pbmRlbnQpIHtcbiAgICAgICAgdGhpcy5faW5kZW50ID0gX2luZGVudDtcbiAgICAgICAgdGhpcy5fbGluZXMgPSBbbmV3IF9FbWl0dGVkTGluZShfaW5kZW50KV07XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVSb290KCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtaXR0ZXJWaXNpdG9yQ29udGV4dCgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIHN0cmlwIHRoaXMgZnJvbSBwdWJsaXNoZWQgZC50cyBmaWxlcyBkdWUgdG9cbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM2MjE2XG4gICAgICovXG4gICAgZ2V0IF9jdXJyZW50TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzW3RoaXMuX2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBwcmludGxuKGZyb20sIGxhc3RQYXJ0ID0gJycpIHtcbiAgICAgICAgdGhpcy5wcmludChmcm9tIHx8IG51bGwsIGxhc3RQYXJ0LCB0cnVlKTtcbiAgICB9XG4gICAgbGluZUlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50TGluZS5wYXJ0cy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGxpbmVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgKiBfSU5ERU5UX1dJVEgubGVuZ3RoICsgdGhpcy5fY3VycmVudExpbmUucGFydHNMZW5ndGg7XG4gICAgfVxuICAgIHByaW50KGZyb20sIHBhcnQsIG5ld0xpbmUgPSBmYWxzZSkge1xuICAgICAgICBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUucGFydHNMZW5ndGggKz0gcGFydC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5zcmNTcGFucy5wdXNoKGZyb20gJiYgZnJvbS5zb3VyY2VTcGFuIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wdXNoKG5ldyBfRW1pdHRlZExpbmUodGhpcy5faW5kZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRW1wdHlMYXN0TGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZUlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fbGluZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5jSW5kZW50KCkge1xuICAgICAgICB0aGlzLl9pbmRlbnQrKztcbiAgICAgICAgaWYgKHRoaXMubGluZUlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUuaW5kZW50ID0gdGhpcy5faW5kZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY0luZGVudCgpIHtcbiAgICAgICAgdGhpcy5faW5kZW50LS07XG4gICAgICAgIGlmICh0aGlzLmxpbmVJc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCA9IHRoaXMuX2luZGVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1NvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlTGluZXNcbiAgICAgICAgICAgIC5tYXAobCA9PiBsLnBhcnRzLmxlbmd0aCA+IDAgPyBfY3JlYXRlSW5kZW50KGwuaW5kZW50KSArIGwucGFydHMuam9pbignJykgOiAnJylcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgdG9Tb3VyY2VNYXBHZW5lcmF0b3IoZ2VuRmlsZVBhdGgsIHN0YXJ0c0F0TGluZSA9IDApIHtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihnZW5GaWxlUGF0aCk7XG4gICAgICAgIGxldCBmaXJzdE9mZnNldE1hcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtYXBGaXJzdE9mZnNldElmTmVlZGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmaXJzdE9mZnNldE1hcHBlZCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBhIHNpbmdsZSBzcGFjZSBzbyB0aGF0IHRvb2xzIHdvbid0IHRyeSB0byBsb2FkIHRoZSBmaWxlIGZyb20gZGlzay5cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBXZSBhcmUgdXNpbmcgdmlydHVhbCB1cmxzIGxpa2UgYG5nOi8vL2AsIHNvIHdlIGhhdmUgdG9cbiAgICAgICAgICAgICAgICAvLyBwcm92aWRlIGEgY29udGVudCBoZXJlLlxuICAgICAgICAgICAgICAgIG1hcC5hZGRTb3VyY2UoZ2VuRmlsZVBhdGgsICcgJykuYWRkTWFwcGluZygwLCBnZW5GaWxlUGF0aCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgZmlyc3RPZmZzZXRNYXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJ0c0F0TGluZTsgaSsrKSB7XG4gICAgICAgICAgICBtYXAuYWRkTGluZSgpO1xuICAgICAgICAgICAgbWFwRmlyc3RPZmZzZXRJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlTGluZXMuZm9yRWFjaCgobGluZSwgbGluZUlkeCkgPT4ge1xuICAgICAgICAgICAgbWFwLmFkZExpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYW5zID0gbGluZS5zcmNTcGFucztcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5wYXJ0cztcbiAgICAgICAgICAgIGxldCBjb2wwID0gbGluZS5pbmRlbnQgKiBfSU5ERU5UX1dJVEgubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHNwYW5JZHggPSAwO1xuICAgICAgICAgICAgLy8gc2tpcCBsZWFkaW5nIHBhcnRzIHdpdGhvdXQgc291cmNlIHNwYW5zXG4gICAgICAgICAgICB3aGlsZSAoc3BhbklkeCA8IHNwYW5zLmxlbmd0aCAmJiAhc3BhbnNbc3BhbklkeF0pIHtcbiAgICAgICAgICAgICAgICBjb2wwICs9IHBhcnRzW3NwYW5JZHhdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBzcGFuSWR4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BhbklkeCA8IHNwYW5zLmxlbmd0aCAmJiBsaW5lSWR4ID09PSAwICYmIGNvbDAgPT09IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdE9mZnNldE1hcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXBGaXJzdE9mZnNldElmTmVlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoc3BhbklkeCA8IHNwYW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBzcGFuc1tzcGFuSWR4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBzcGFuLnN0YXJ0LmZpbGU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlTGluZSA9IHNwYW4uc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VDb2wgPSBzcGFuLnN0YXJ0LmNvbDtcbiAgICAgICAgICAgICAgICBtYXAuYWRkU291cmNlKHNvdXJjZS51cmwsIHNvdXJjZS5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAuYWRkTWFwcGluZyhjb2wwLCBzb3VyY2UudXJsLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2wpO1xuICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gcGFydHMgd2l0aG91dCBzcGFuIG9yIHRoZSBzYW1lIHNwYW4gdG8gdGhlIHByZXZpb3VzIHNlZ21lbnRcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3BhbklkeCA8IHNwYW5zLmxlbmd0aCAmJiAoc3BhbiA9PT0gc3BhbnNbc3BhbklkeF0gfHwgIXNwYW5zW3NwYW5JZHhdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2wwICs9IHBhcnRzW3NwYW5JZHhdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgc3BhbklkeCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHNwYW5PZihsaW5lLCBjb2x1bW4pIHtcbiAgICAgICAgY29uc3QgZW1pdHRlZExpbmUgPSB0aGlzLl9saW5lc1tsaW5lXTtcbiAgICAgICAgaWYgKGVtaXR0ZWRMaW5lKSB7XG4gICAgICAgICAgICBsZXQgY29sdW1uc0xlZnQgPSBjb2x1bW4gLSBfY3JlYXRlSW5kZW50KGVtaXR0ZWRMaW5lLmluZGVudCkubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgcGFydEluZGV4ID0gMDsgcGFydEluZGV4IDwgZW1pdHRlZExpbmUucGFydHMubGVuZ3RoOyBwYXJ0SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBlbWl0dGVkTGluZS5wYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA+IGNvbHVtbnNMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbWl0dGVkTGluZS5zcmNTcGFuc1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2x1bW5zTGVmdCAtPSBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIHN0cmlwIHRoaXMgZnJvbSBwdWJsaXNoZWQgZC50cyBmaWxlcyBkdWUgdG9cbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM2MjE2XG4gICAgICovXG4gICAgZ2V0IHNvdXJjZUxpbmVzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZXMubGVuZ3RoICYmIHRoaXMuX2xpbmVzW3RoaXMuX2xpbmVzLmxlbmd0aCAtIDFdLnBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXM7XG4gICAgfVxufVxuY2xhc3MgQWJzdHJhY3RFbWl0dGVyVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoX2VzY2FwZURvbGxhckluU3RyaW5ncykge1xuICAgICAgICB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MgPSBfZXNjYXBlRG9sbGFySW5TdHJpbmdzO1xuICAgIH1cbiAgICBwcmludExlYWRpbmdDb21tZW50cyhzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKHN0bXQubGVhZGluZ0NvbW1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNvbW1lbnQgb2Ygc3RtdC5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChjb21tZW50IGluc3RhbmNlb2YgSlNEb2NDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIGAvKiR7Y29tbWVudC50b1N0cmluZygpfSovYCwgY29tbWVudC50cmFpbGluZ05ld2xpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBgLyogJHtjb21tZW50LnRleHR9ICovYCwgY29tbWVudC50cmFpbGluZ05ld2xpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudC50ZXh0LnNwbGl0KCdcXG4nKS5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBgLy8gJHtsaW5lfWApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uU3RtdChzdG10LCBjdHgpIHtcbiAgICAgICAgdGhpcy5wcmludExlYWRpbmdDb21tZW50cyhzdG10LCBjdHgpO1xuICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsICc7Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFJldHVyblN0bXQoc3RtdCwgY3R4KSB7XG4gICAgICAgIHRoaXMucHJpbnRMZWFkaW5nQ29tbWVudHMoc3RtdCwgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIGByZXR1cm4gYCk7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsICc7Jyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdElmU3RtdChzdG10LCBjdHgpIHtcbiAgICAgICAgdGhpcy5wcmludExlYWRpbmdDb21tZW50cyhzdG10LCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgYGlmIChgKTtcbiAgICAgICAgc3RtdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBgKSB7YCk7XG4gICAgICAgIGNvbnN0IGhhc0Vsc2VDYXNlID0gc3RtdC5mYWxzZUNhc2UgIT0gbnVsbCAmJiBzdG10LmZhbHNlQ2FzZS5sZW5ndGggPiAwO1xuICAgICAgICBpZiAoc3RtdC50cnVlQ2FzZS5sZW5ndGggPD0gMSAmJiAhaGFzRWxzZUNhc2UpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBgIGApO1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY3R4KTtcbiAgICAgICAgICAgIGN0eC5yZW1vdmVFbXB0eUxhc3RMaW5lKCk7XG4gICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgYCBgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludGxuKCk7XG4gICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgaWYgKGhhc0Vsc2VDYXNlKSB7XG4gICAgICAgICAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgYH0gZWxzZSB7YCk7XG4gICAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjdHgpO1xuICAgICAgICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBgfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRXcml0ZVZhckV4cHIoZXhwciwgY3R4KSB7XG4gICAgICAgIGNvbnN0IGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGV4cHIsIGAke2V4cHIubmFtZX0gPSBgKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFdyaXRlS2V5RXhwcihleHByLCBjdHgpIHtcbiAgICAgICAgY29uc3QgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJygnKTtcbiAgICAgICAgfVxuICAgICAgICBleHByLnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgYFtgKTtcbiAgICAgICAgZXhwci5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIGBdID0gYCk7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRXcml0ZVByb3BFeHByKGV4cHIsIGN0eCkge1xuICAgICAgICBjb25zdCBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBgLiR7ZXhwci5uYW1lfSA9IGApO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0SW52b2tlRnVuY3Rpb25FeHByKGV4cHIsIGN0eCkge1xuICAgICAgICBleHByLmZuLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgYChgKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGV4cHIuYXJncywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgYClgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0VGFnZ2VkVGVtcGxhdGVFeHByKGV4cHIsIGN0eCkge1xuICAgICAgICBleHByLnRhZy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsICdgJyArIGV4cHIudGVtcGxhdGUuZWxlbWVudHNbMF0ucmF3VGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZXhwci50ZW1wbGF0ZS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICckeycpO1xuICAgICAgICAgICAgZXhwci50ZW1wbGF0ZS5leHByZXNzaW9uc1tpIC0gMV0udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgYH0ke2V4cHIudGVtcGxhdGUuZWxlbWVudHNbaV0ucmF3VGV4dH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoZXhwciwgJ2AnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0V3JhcHBlZE5vZGVFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWJzdHJhY3QgZW1pdHRlciBjYW5ub3QgdmlzaXQgV3JhcHBlZE5vZGVFeHByLicpO1xuICAgIH1cbiAgICB2aXNpdFR5cGVvZkV4cHIoZXhwciwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChleHByLCAndHlwZW9mICcpO1xuICAgICAgICBleHByLmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgfVxuICAgIHZpc2l0UmVhZFZhckV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRJbnN0YW50aWF0ZUV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYG5ldyBgKTtcbiAgICAgICAgYXN0LmNsYXNzRXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYChgKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGApYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXN0LnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgZXNjYXBlSWRlbnRpZmllcih2YWx1ZSwgdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBgJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRMb2NhbGl6ZWRTdHJpbmcoYXN0LCBjdHgpIHtcbiAgICAgICAgY29uc3QgaGVhZCA9IGFzdC5zZXJpYWxpemVJMThuSGVhZCgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnJGxvY2FsaXplIGAnICsgaGVhZC5yYXcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFzdC5tZXNzYWdlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICckeycpO1xuICAgICAgICAgICAgYXN0LmV4cHJlc3Npb25zW2kgLSAxXS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGB9JHthc3Quc2VyaWFsaXplSTE4blRlbXBsYXRlUGFydChpKS5yYXd9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGFzdCwgJ2AnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0Q29uZGl0aW9uYWxFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGAoYCk7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICc/ICcpO1xuICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICc6ICcpO1xuICAgICAgICBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgKWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXROb3RFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsICchJyk7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFVuYXJ5T3BlcmF0b3JFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGxldCBvcFN0cjtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgVW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJysnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBVbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3IgJHthc3Qub3BlcmF0b3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdC5wYXJlbnMpXG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBgKGApO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBvcFN0cik7XG4gICAgICAgIGFzdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoYXN0LnBhcmVucylcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGApYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEJpbmFyeU9wZXJhdG9yRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBsZXQgb3BTdHI7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc9PT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQW5kOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyYmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQml0d2lzZUFuZDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuT3I6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnfHwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5QbHVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJysnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICctJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRGl2aWRlOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5NdWx0aXBseTpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcqJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPD0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc+PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk51bGxpc2hDb2FsZXNjZTpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc/Pyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcGVyYXRvciAke2FzdC5vcGVyYXRvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0LnBhcmVucylcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGAoYCk7XG4gICAgICAgIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGAgJHtvcFN0cn0gYCk7XG4gICAgICAgIGFzdC5yaHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmIChhc3QucGFyZW5zKVxuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgYClgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0UmVhZFByb3BFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYC5gKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRSZWFkS2V5RXhwcihhc3QsIGN0eCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGBbYCk7XG4gICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYF1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5RXhwcihhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgW2ApO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmVudHJpZXMsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYF1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcEV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYHtgKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZW50cnkgPT4ge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgYCR7ZXNjYXBlSWRlbnRpZmllcihlbnRyeS5rZXksIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncywgZW50cnkucXVvdGVkKX06YCk7XG4gICAgICAgICAgICBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfSwgYXN0LmVudHJpZXMsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYH1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0Q29tbWFFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcoJyk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QucGFydHMsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJyknKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwcmVzc2lvbnMsIGN0eCwgc2VwYXJhdG9yKSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGV4cHIgPT4gZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KSwgZXhwcmVzc2lvbnMsIGN0eCwgc2VwYXJhdG9yKTtcbiAgICB9XG4gICAgdmlzaXRBbGxPYmplY3RzKGhhbmRsZXIsIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvcikge1xuICAgICAgICBsZXQgaW5jcmVtZW50ZWRJbmRlbnQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5saW5lTGVuZ3RoKCkgPiA4MCkge1xuICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgc2VwYXJhdG9yLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmNyZW1lbnRlZEluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWF0aW9uIGFyZSBtYXJrZWQgd2l0aCBkb3VibGUgaW5kZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmluY0luZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50ZWRJbmRlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHgucHJpbnQobnVsbCwgc2VwYXJhdG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlcihleHByZXNzaW9uc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY3JlbWVudGVkSW5kZW50KSB7XG4gICAgICAgICAgICAvLyBjb250aW51YXRpb24gYXJlIG1hcmtlZCB3aXRoIGRvdWJsZSBpbmRlbnQuXG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRBbGxTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIGN0eCkge1xuICAgICAgICBzdGF0ZW1lbnRzLmZvckVhY2goKHN0bXQpID0+IHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNjYXBlSWRlbnRpZmllcihpbnB1dCwgZXNjYXBlRG9sbGFyLCBhbHdheXNRdW90ZSA9IHRydWUpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGlucHV0LnJlcGxhY2UoX1NJTkdMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFLCAoLi4ubWF0Y2gpID0+IHtcbiAgICAgICAgaWYgKG1hdGNoWzBdID09ICckJykge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZURvbGxhciA/ICdcXFxcJCcgOiAnJCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXHInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgXFxcXCR7bWF0Y2hbMF19YDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHJlcXVpcmVzUXVvdGVzID0gYWx3YXlzUXVvdGUgfHwgIV9MRUdBTF9JREVOVElGSUVSX1JFLnRlc3QoYm9keSk7XG4gICAgcmV0dXJuIHJlcXVpcmVzUXVvdGVzID8gYCcke2JvZHl9J2AgOiBib2R5O1xufVxuZnVuY3Rpb24gX2NyZWF0ZUluZGVudChjb3VudCkge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcmVzICs9IF9JTkRFTlRfV0lUSDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiB0eXBlV2l0aFBhcmFtZXRlcnModHlwZSwgbnVtUGFyYW1zKSB7XG4gICAgaWYgKG51bVBhcmFtcyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUodHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGFyYW1zOyBpKyspIHtcbiAgICAgICAgcGFyYW1zLnB1c2goRFlOQU1JQ19UWVBFKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb25UeXBlKHR5cGUsIHVuZGVmaW5lZCwgcGFyYW1zKTtcbn1cbmNvbnN0IEFOSU1BVEVfU1lNQk9MX1BSRUZJWCA9ICdAJztcbmZ1bmN0aW9uIHByZXBhcmVTeW50aGV0aWNQcm9wZXJ0eU5hbWUobmFtZSkge1xuICAgIHJldHVybiBgJHtBTklNQVRFX1NZTUJPTF9QUkVGSVh9JHtuYW1lfWA7XG59XG5mdW5jdGlvbiBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJOYW1lKG5hbWUsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGAke0FOSU1BVEVfU1lNQk9MX1BSRUZJWH0ke25hbWV9LiR7cGhhc2V9YDtcbn1cbmZ1bmN0aW9uIGdldFNhZmVQcm9wZXJ0eUFjY2Vzc1N0cmluZyhhY2Nlc3NvciwgbmFtZSkge1xuICAgIGNvbnN0IGVzY2FwZWROYW1lID0gZXNjYXBlSWRlbnRpZmllcihuYW1lLCBmYWxzZSwgZmFsc2UpO1xuICAgIHJldHVybiBlc2NhcGVkTmFtZSAhPT0gbmFtZSA/IGAke2FjY2Vzc29yfVske2VzY2FwZWROYW1lfV1gIDogYCR7YWNjZXNzb3J9LiR7bmFtZX1gO1xufVxuZnVuY3Rpb24gcHJlcGFyZVN5bnRoZXRpY0xpc3RlbmVyRnVuY3Rpb25OYW1lKG5hbWUsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGBhbmltYXRpb25fJHtuYW1lfV8ke3BoYXNlfWA7XG59XG5mdW5jdGlvbiBqaXRPbmx5R3VhcmRlZEV4cHJlc3Npb24oZXhwcikge1xuICAgIHJldHVybiBndWFyZGVkRXhwcmVzc2lvbignbmdKaXRNb2RlJywgZXhwcik7XG59XG5mdW5jdGlvbiBkZXZPbmx5R3VhcmRlZEV4cHJlc3Npb24oZXhwcikge1xuICAgIHJldHVybiBndWFyZGVkRXhwcmVzc2lvbignbmdEZXZNb2RlJywgZXhwcik7XG59XG5mdW5jdGlvbiBndWFyZGVkRXhwcmVzc2lvbihndWFyZCwgZXhwcikge1xuICAgIGNvbnN0IGd1YXJkRXhwciA9IG5ldyBFeHRlcm5hbEV4cHIoeyBuYW1lOiBndWFyZCwgbW9kdWxlTmFtZTogbnVsbCB9KTtcbiAgICBjb25zdCBndWFyZE5vdERlZmluZWQgPSBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbCwgbmV3IFR5cGVvZkV4cHIoZ3VhcmRFeHByKSwgbGl0ZXJhbCgndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGd1YXJkVW5kZWZpbmVkT3JUcnVlID0gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgZ3VhcmROb3REZWZpbmVkLCBndWFyZEV4cHIsIC8qIHR5cGUgKi8gdW5kZWZpbmVkLCBcbiAgICAvKiBzb3VyY2VTcGFuICovIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQW5kLCBndWFyZFVuZGVmaW5lZE9yVHJ1ZSwgZXhwcik7XG59XG5mdW5jdGlvbiB3cmFwUmVmZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBXcmFwcGVkTm9kZUV4cHIodmFsdWUpO1xuICAgIHJldHVybiB7IHZhbHVlOiB3cmFwcGVkLCB0eXBlOiB3cmFwcGVkIH07XG59XG5mdW5jdGlvbiByZWZzVG9BcnJheShyZWZzLCBzaG91bGRGb3J3YXJkRGVjbGFyZSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IGxpdGVyYWxBcnIocmVmcy5tYXAocmVmID0+IHJlZi52YWx1ZSkpO1xuICAgIHJldHVybiBzaG91bGRGb3J3YXJkRGVjbGFyZSA/IGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudCh2YWx1ZXMpXSkgOiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXlCZUZvcndhcmRSZWZFeHByZXNzaW9uKGV4cHJlc3Npb24sIGZvcndhcmRSZWYpIHtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCBmb3J3YXJkUmVmIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSBgTWF5YmVGb3J3YXJkUmVmRXhwcmVzc2lvbmAgdG8gYW4gYEV4cHJlc3Npb25gLCBwb3NzaWJseSB3cmFwcGluZyBpdHMgZXhwcmVzc2lvbiBpbiBhXG4gKiBgZm9yd2FyZFJlZigpYCBjYWxsLlxuICpcbiAqIElmIGBNYXliZUZvcndhcmRSZWZFeHByZXNzaW9uLmZvcndhcmRSZWZgIGlzIGBGb3J3YXJkUmVmSGFuZGxpbmcuVW53cmFwcGVkYCB0aGVuIHRoZSBleHByZXNzaW9uXG4gKiB3YXMgb3JpZ2luYWxseSB3cmFwcGVkIGluIGEgYGZvcndhcmRSZWYoKWAgY2FsbCB0byBwcmV2ZW50IHRoZSB2YWx1ZSBmcm9tIGJlaW5nIGVhZ2VybHkgZXZhbHVhdGVkXG4gKiBpbiB0aGUgY29kZS5cbiAqXG4gKiBTZWUgYHBhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvbmd0c2MvYW5ub3RhdGlvbnMvc3JjL2luamVjdGFibGUudHNgIGFuZFxuICogYHBhY2thZ2VzL2NvbXBpbGVyL3NyYy9qaXRfY29tcGlsZXJfZmFjYWRlLnRzYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29udmVydEZyb21NYXliZUZvcndhcmRSZWZFeHByZXNzaW9uKHsgZXhwcmVzc2lvbiwgZm9yd2FyZFJlZiB9KSB7XG4gICAgc3dpdGNoIChmb3J3YXJkUmVmKSB7XG4gICAgICAgIGNhc2UgMCAvKiBOb25lICovOlxuICAgICAgICBjYXNlIDEgLyogV3JhcHBlZCAqLzpcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICBjYXNlIDIgLyogVW53cmFwcGVkICovOlxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlRm9yd2FyZFJlZihleHByZXNzaW9uKTtcbiAgICB9XG59XG4vKipcbiAqIEdlbmVyYXRlIGFuIGV4cHJlc3Npb24gdGhhdCBoYXMgdGhlIGdpdmVuIGBleHByYCB3cmFwcGVkIGluIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAqXG4gKiBgYGBcbiAqIGZvcndhcmRSZWYoKCkgPT4gZXhwcilcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUZvcndhcmRSZWYoZXhwcikge1xuICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuZm9yd2FyZFJlZikuY2FsbEZuKFtmbihbXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQoZXhwcildKV0pO1xufVxuXG52YXIgUjNGYWN0b3J5RGVsZWdhdGVUeXBlO1xuKGZ1bmN0aW9uIChSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGUpIHtcbiAgICBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbUjNGYWN0b3J5RGVsZWdhdGVUeXBlW1wiQ2xhc3NcIl0gPSAwXSA9IFwiQ2xhc3NcIjtcbiAgICBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbUjNGYWN0b3J5RGVsZWdhdGVUeXBlW1wiRnVuY3Rpb25cIl0gPSAxXSA9IFwiRnVuY3Rpb25cIjtcbn0pKFIzRmFjdG9yeURlbGVnYXRlVHlwZSB8fCAoUjNGYWN0b3J5RGVsZWdhdGVUeXBlID0ge30pKTtcbnZhciBGYWN0b3J5VGFyZ2V0JDE7XG4oZnVuY3Rpb24gKEZhY3RvcnlUYXJnZXQpIHtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJEaXJlY3RpdmVcIl0gPSAwXSA9IFwiRGlyZWN0aXZlXCI7XG4gICAgRmFjdG9yeVRhcmdldFtGYWN0b3J5VGFyZ2V0W1wiQ29tcG9uZW50XCJdID0gMV0gPSBcIkNvbXBvbmVudFwiO1xuICAgIEZhY3RvcnlUYXJnZXRbRmFjdG9yeVRhcmdldFtcIkluamVjdGFibGVcIl0gPSAyXSA9IFwiSW5qZWN0YWJsZVwiO1xuICAgIEZhY3RvcnlUYXJnZXRbRmFjdG9yeVRhcmdldFtcIlBpcGVcIl0gPSAzXSA9IFwiUGlwZVwiO1xuICAgIEZhY3RvcnlUYXJnZXRbRmFjdG9yeVRhcmdldFtcIk5nTW9kdWxlXCJdID0gNF0gPSBcIk5nTW9kdWxlXCI7XG59KShGYWN0b3J5VGFyZ2V0JDEgfHwgKEZhY3RvcnlUYXJnZXQkMSA9IHt9KSk7XG4vKipcbiAqIENvbnN0cnVjdCBhIGZhY3RvcnkgZnVuY3Rpb24gZXhwcmVzc2lvbiBmb3IgdGhlIGdpdmVuIGBSM0ZhY3RvcnlNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24obWV0YSkge1xuICAgIGNvbnN0IHQgPSB2YXJpYWJsZSgndCcpO1xuICAgIGxldCBiYXNlRmFjdG9yeVZhciA9IG51bGw7XG4gICAgLy8gVGhlIHR5cGUgdG8gaW5zdGFudGlhdGUgdmlhIGNvbnN0cnVjdG9yIGludm9jYXRpb24uIElmIHRoZXJlIGlzIG5vIGRlbGVnYXRlZCBmYWN0b3J5LCBtZWFuaW5nXG4gICAgLy8gdGhpcyB0eXBlIGlzIGFsd2F5cyBjcmVhdGVkIGJ5IGNvbnN0cnVjdG9yIGludm9jYXRpb24sIHRoZW4gdGhpcyBpcyB0aGUgdHlwZS10by1jcmVhdGVcbiAgICAvLyBwYXJhbWV0ZXIgcHJvdmlkZWQgYnkgdGhlIHVzZXIgKHQpIGlmIHNwZWNpZmllZCwgb3IgdGhlIGN1cnJlbnQgdHlwZSBpZiBub3QuIElmIHRoZXJlIGlzIGFcbiAgICAvLyBkZWxlZ2F0ZWQgZmFjdG9yeSAod2hpY2ggaXMgdXNlZCB0byBjcmVhdGUgdGhlIGN1cnJlbnQgdHlwZSkgdGhlbiB0aGlzIGlzIG9ubHkgdGhlIHR5cGUtdG8tXG4gICAgLy8gY3JlYXRlIHBhcmFtZXRlciAodCkuXG4gICAgY29uc3QgdHlwZUZvckN0b3IgPSAhaXNEZWxlZ2F0ZWRGYWN0b3J5TWV0YWRhdGEobWV0YSkgP1xuICAgICAgICBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk9yLCB0LCBtZXRhLmludGVybmFsVHlwZSkgOlxuICAgICAgICB0O1xuICAgIGxldCBjdG9yRXhwciA9IG51bGw7XG4gICAgaWYgKG1ldGEuZGVwcyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGVyZSBpcyBhIGNvbnN0cnVjdG9yIChlaXRoZXIgZXhwbGljaXRseSBvciBpbXBsaWNpdGx5IGRlZmluZWQpLlxuICAgICAgICBpZiAobWV0YS5kZXBzICE9PSAnaW52YWxpZCcpIHtcbiAgICAgICAgICAgIGN0b3JFeHByID0gbmV3IEluc3RhbnRpYXRlRXhwcih0eXBlRm9yQ3RvciwgaW5qZWN0RGVwZW5kZW5jaWVzKG1ldGEuZGVwcywgbWV0YS50YXJnZXQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gY29uc3RydWN0b3IsIHVzZSB0aGUgYmFzZSBjbGFzcycgZmFjdG9yeSB0byBjb25zdHJ1Y3QgdHlwZUZvckN0b3IuXG4gICAgICAgIGJhc2VGYWN0b3J5VmFyID0gdmFyaWFibGUoYMm1JHttZXRhLm5hbWV9X0Jhc2VGYWN0b3J5YCk7XG4gICAgICAgIGN0b3JFeHByID0gYmFzZUZhY3RvcnlWYXIuY2FsbEZuKFt0eXBlRm9yQ3Rvcl0pO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgbGV0IHJldEV4cHIgPSBudWxsO1xuICAgIGZ1bmN0aW9uIG1ha2VDb25kaXRpb25hbEZhY3Rvcnkobm9uQ3RvckV4cHIpIHtcbiAgICAgICAgY29uc3QgciA9IHZhcmlhYmxlKCdyJyk7XG4gICAgICAgIGJvZHkucHVzaChyLnNldChOVUxMX0VYUFIpLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgIGNvbnN0IGN0b3JTdG10ID0gY3RvckV4cHIgIT09IG51bGwgPyByLnNldChjdG9yRXhwcikudG9TdG10KCkgOlxuICAgICAgICAgICAgaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmludmFsaWRGYWN0b3J5KS5jYWxsRm4oW10pLnRvU3RtdCgpO1xuICAgICAgICBib2R5LnB1c2goaWZTdG10KHQsIFtjdG9yU3RtdF0sIFtyLnNldChub25DdG9yRXhwcikudG9TdG10KCldKSk7XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBpZiAoaXNEZWxlZ2F0ZWRGYWN0b3J5TWV0YWRhdGEobWV0YSkpIHtcbiAgICAgICAgLy8gVGhpcyB0eXBlIGlzIGNyZWF0ZWQgd2l0aCBhIGRlbGVnYXRlZCBmYWN0b3J5LiBJZiBhIHR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzcGVjaWZpZWQsIGNhbGxcbiAgICAgICAgLy8gdGhlIGZhY3RvcnkgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgZGVsZWdhdGVBcmdzID0gaW5qZWN0RGVwZW5kZW5jaWVzKG1ldGEuZGVsZWdhdGVEZXBzLCBtZXRhLnRhcmdldCk7XG4gICAgICAgIC8vIEVpdGhlciBjYWxsIGBuZXcgZGVsZWdhdGUoLi4uKWAgb3IgYGRlbGVnYXRlKC4uLilgIGRlcGVuZGluZyBvbiBtZXRhLmRlbGVnYXRlVHlwZS5cbiAgICAgICAgY29uc3QgZmFjdG9yeUV4cHIgPSBuZXcgKG1ldGEuZGVsZWdhdGVUeXBlID09PSBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGUuQ2xhc3MgP1xuICAgICAgICAgICAgSW5zdGFudGlhdGVFeHByIDpcbiAgICAgICAgICAgIEludm9rZUZ1bmN0aW9uRXhwcikobWV0YS5kZWxlZ2F0ZSwgZGVsZWdhdGVBcmdzKTtcbiAgICAgICAgcmV0RXhwciA9IG1ha2VDb25kaXRpb25hbEZhY3RvcnkoZmFjdG9yeUV4cHIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0V4cHJlc3Npb25GYWN0b3J5TWV0YWRhdGEobWV0YSkpIHtcbiAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBkZWNpZGUgd2hldGhlciB0byBsb3dlciB0aGUgdmFsdWUgaGVyZSBvciBpbiB0aGUgY2FsbGVyXG4gICAgICAgIHJldEV4cHIgPSBtYWtlQ29uZGl0aW9uYWxGYWN0b3J5KG1ldGEuZXhwcmVzc2lvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXRFeHByID0gY3RvckV4cHI7XG4gICAgfVxuICAgIGlmIChyZXRFeHByID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBleHByZXNzaW9uIGNhbm5vdCBiZSBmb3JtZWQgc28gcmVuZGVyIGFuIGDJtcm1aW52YWxpZEZhY3RvcnkoKWAgY2FsbC5cbiAgICAgICAgYm9keS5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5pbnZhbGlkRmFjdG9yeSkuY2FsbEZuKFtdKS50b1N0bXQoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhc2VGYWN0b3J5VmFyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgZmFjdG9yeSB1c2VzIGEgYmFzZSBmYWN0b3J5LCBzbyBjYWxsIGDJtcm1Z2V0SW5oZXJpdGVkRmFjdG9yeSgpYCB0byBjb21wdXRlIGl0LlxuICAgICAgICBjb25zdCBnZXRJbmhlcml0ZWRGYWN0b3J5Q2FsbCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5nZXRJbmhlcml0ZWRGYWN0b3J5KS5jYWxsRm4oW21ldGEuaW50ZXJuYWxUeXBlXSk7XG4gICAgICAgIC8vIE1lbW9pemUgdGhlIGJhc2UgZmFjdG9yeUZuOiBgYmFzZUZhY3RvcnkgfHwgKGJhc2VGYWN0b3J5ID0gybXJtWdldEluaGVyaXRlZEZhY3RvcnkoLi4uKSlgXG4gICAgICAgIGNvbnN0IGJhc2VGYWN0b3J5ID0gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgYmFzZUZhY3RvcnlWYXIsIGJhc2VGYWN0b3J5VmFyLnNldChnZXRJbmhlcml0ZWRGYWN0b3J5Q2FsbCkpO1xuICAgICAgICBib2R5LnB1c2gobmV3IFJldHVyblN0YXRlbWVudChiYXNlRmFjdG9yeS5jYWxsRm4oW3R5cGVGb3JDdG9yXSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgc3RyYWlnaHRmb3J3YXJkIGZhY3RvcnksIGp1c3QgcmV0dXJuIGl0LlxuICAgICAgICBib2R5LnB1c2gobmV3IFJldHVyblN0YXRlbWVudChyZXRFeHByKSk7XG4gICAgfVxuICAgIGxldCBmYWN0b3J5Rm4gPSBmbihbbmV3IEZuUGFyYW0oJ3QnLCBEWU5BTUlDX1RZUEUpXSwgYm9keSwgSU5GRVJSRURfVFlQRSwgdW5kZWZpbmVkLCBgJHttZXRhLm5hbWV9X0ZhY3RvcnlgKTtcbiAgICBpZiAoYmFzZUZhY3RvcnlWYXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgYSBiYXNlIGZhY3RvcnkgdmFyaWFibGUgc28gd3JhcCBpdHMgZGVjbGFyYXRpb24gYWxvbmcgd2l0aCB0aGUgZmFjdG9yeSBmdW5jdGlvbiBpbnRvXG4gICAgICAgIC8vIGFuIElJRkUuXG4gICAgICAgIGZhY3RvcnlGbiA9IGZuKFtdLCBbXG4gICAgICAgICAgICBuZXcgRGVjbGFyZVZhclN0bXQoYmFzZUZhY3RvcnlWYXIubmFtZSksIG5ldyBSZXR1cm5TdGF0ZW1lbnQoZmFjdG9yeUZuKVxuICAgICAgICBdKS5jYWxsRm4oW10sIC8qIHNvdXJjZVNwYW4gKi8gdW5kZWZpbmVkLCAvKiBwdXJlICovIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBleHByZXNzaW9uOiBmYWN0b3J5Rm4sXG4gICAgICAgIHN0YXRlbWVudHM6IFtdLFxuICAgICAgICB0eXBlOiBjcmVhdGVGYWN0b3J5VHlwZShtZXRhKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVR5cGUobWV0YSkge1xuICAgIGNvbnN0IGN0b3JEZXBzVHlwZSA9IG1ldGEuZGVwcyAhPT0gbnVsbCAmJiBtZXRhLmRlcHMgIT09ICdpbnZhbGlkJyA/IGNyZWF0ZUN0b3JEZXBzVHlwZShtZXRhLmRlcHMpIDogTk9ORV9UWVBFO1xuICAgIHJldHVybiBleHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuRmFjdG9yeURlY2xhcmF0aW9uLCBbdHlwZVdpdGhQYXJhbWV0ZXJzKG1ldGEudHlwZS50eXBlLCBtZXRhLnR5cGVBcmd1bWVudENvdW50KSwgY3RvckRlcHNUeXBlXSkpO1xufVxuZnVuY3Rpb24gaW5qZWN0RGVwZW5kZW5jaWVzKGRlcHMsIHRhcmdldCkge1xuICAgIHJldHVybiBkZXBzLm1hcCgoZGVwLCBpbmRleCkgPT4gY29tcGlsZUluamVjdERlcGVuZGVuY3koZGVwLCB0YXJnZXQsIGluZGV4KSk7XG59XG5mdW5jdGlvbiBjb21waWxlSW5qZWN0RGVwZW5kZW5jeShkZXAsIHRhcmdldCwgaW5kZXgpIHtcbiAgICAvLyBJbnRlcnByZXQgdGhlIGRlcGVuZGVuY3kgYWNjb3JkaW5nIHRvIGl0cyByZXNvbHZlZCB0eXBlLlxuICAgIGlmIChkZXAudG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5pbnZhbGlkRmFjdG9yeURlcCkuY2FsbEZuKFtsaXRlcmFsKGluZGV4KV0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZXAuYXR0cmlidXRlTmFtZVR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQnVpbGQgdXAgdGhlIGluamVjdGlvbiBmbGFncyBhY2NvcmRpbmcgdG8gdGhlIG1ldGFkYXRhLlxuICAgICAgICBjb25zdCBmbGFncyA9IDAgLyogRGVmYXVsdCAqLyB8IChkZXAuc2VsZiA/IDIgLyogU2VsZiAqLyA6IDApIHxcbiAgICAgICAgICAgIChkZXAuc2tpcFNlbGYgPyA0IC8qIFNraXBTZWxmICovIDogMCkgfCAoZGVwLmhvc3QgPyAxIC8qIEhvc3QgKi8gOiAwKSB8XG4gICAgICAgICAgICAoZGVwLm9wdGlvbmFsID8gOCAvKiBPcHRpb25hbCAqLyA6IDApIHxcbiAgICAgICAgICAgICh0YXJnZXQgPT09IEZhY3RvcnlUYXJnZXQkMS5QaXBlID8gMTYgLyogRm9yUGlwZSAqLyA6IDApO1xuICAgICAgICAvLyBJZiB0aGlzIGRlcGVuZGVuY3kgaXMgb3B0aW9uYWwgb3Igb3RoZXJ3aXNlIGhhcyBub24tZGVmYXVsdCBmbGFncywgdGhlbiBhZGRpdGlvbmFsXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgZGVzY3JpYmluZyBob3cgdG8gaW5qZWN0IHRoZSBkZXBlbmRlbmN5IG11c3QgYmUgcGFzc2VkIHRvIHRoZSBpbmplY3QgZnVuY3Rpb25cbiAgICAgICAgLy8gdGhhdCdzIGJlaW5nIHVzZWQuXG4gICAgICAgIGxldCBmbGFnc1BhcmFtID0gKGZsYWdzICE9PSAwIC8qIERlZmF1bHQgKi8gfHwgZGVwLm9wdGlvbmFsKSA/IGxpdGVyYWwoZmxhZ3MpIDogbnVsbDtcbiAgICAgICAgLy8gQnVpbGQgdXAgdGhlIGFyZ3VtZW50cyB0byB0aGUgaW5qZWN0Rm4gY2FsbC5cbiAgICAgICAgY29uc3QgaW5qZWN0QXJncyA9IFtkZXAudG9rZW5dO1xuICAgICAgICBpZiAoZmxhZ3NQYXJhbSkge1xuICAgICAgICAgICAgaW5qZWN0QXJncy5wdXNoKGZsYWdzUGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluamVjdEZuID0gZ2V0SW5qZWN0Rm4odGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoaW5qZWN0Rm4pLmNhbGxGbihpbmplY3RBcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZSBgZGVwLmF0dHJpYnV0ZVR5cGVOYW1lYCB2YWx1ZSBpcyBkZWZpbmVkLCB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGlzIGFuIGBAQXR0cmlidXRlKClgXG4gICAgICAgIC8vIHR5cGUgZGVwZW5kZW5jeS4gRm9yIHRoZSBnZW5lcmF0ZWQgSlMgd2Ugc3RpbGwgd2FudCB0byB1c2UgdGhlIGBkZXAudG9rZW5gIHZhbHVlIGluIGNhc2UgdGhlXG4gICAgICAgIC8vIG5hbWUgZ2l2ZW4gZm9yIHRoZSBhdHRyaWJ1dGUgaXMgbm90IGEgc3RyaW5nIGxpdGVyYWwuIEZvciBleGFtcGxlIGdpdmVuIGBAQXR0cmlidXRlKGZvbygpKWAsXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gZ2VuZXJhdGUgYMm1ybVpbmplY3RBdHRyaWJ1dGUoZm9vKCkpYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGBkZXAuYXR0cmlidXRlVHlwZU5hbWVgIGlzIG9ubHkgYWN0dWFsbHkgdXNlZCAoaW4gYGNyZWF0ZUN0b3JEZXBUeXBlKClgKSB0byBnZW5lcmF0ZVxuICAgICAgICAvLyB0eXBpbmdzLlxuICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmluamVjdEF0dHJpYnV0ZSkuY2FsbEZuKFtkZXAudG9rZW5dKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDdG9yRGVwc1R5cGUoZGVwcykge1xuICAgIGxldCBoYXNUeXBlcyA9IGZhbHNlO1xuICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGVzID0gZGVwcy5tYXAoZGVwID0+IHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGNyZWF0ZUN0b3JEZXBUeXBlKGRlcCk7XG4gICAgICAgIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBoYXNUeXBlcyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsKG51bGwpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGhhc1R5cGVzKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uVHlwZShsaXRlcmFsQXJyKGF0dHJpYnV0ZVR5cGVzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gTk9ORV9UWVBFO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUN0b3JEZXBUeXBlKGRlcCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICBpZiAoZGVwLmF0dHJpYnV0ZU5hbWVUeXBlICE9PSBudWxsKSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IGtleTogJ2F0dHJpYnV0ZScsIHZhbHVlOiBkZXAuYXR0cmlidXRlTmFtZVR5cGUsIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGlmIChkZXAub3B0aW9uYWwpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiAnb3B0aW9uYWwnLCB2YWx1ZTogbGl0ZXJhbCh0cnVlKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKGRlcC5ob3N0KSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IGtleTogJ2hvc3QnLCB2YWx1ZTogbGl0ZXJhbCh0cnVlKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKGRlcC5zZWxmKSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IGtleTogJ3NlbGYnLCB2YWx1ZTogbGl0ZXJhbCh0cnVlKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKGRlcC5za2lwU2VsZikge1xuICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6ICdza2lwU2VsZicsIHZhbHVlOiBsaXRlcmFsKHRydWUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZW50cmllcy5sZW5ndGggPiAwID8gbGl0ZXJhbE1hcChlbnRyaWVzKSA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0RlbGVnYXRlZEZhY3RvcnlNZXRhZGF0YShtZXRhKSB7XG4gICAgcmV0dXJuIG1ldGEuZGVsZWdhdGVUeXBlICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0V4cHJlc3Npb25GYWN0b3J5TWV0YWRhdGEobWV0YSkge1xuICAgIHJldHVybiBtZXRhLmV4cHJlc3Npb24gIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEluamVjdEZuKHRhcmdldCkge1xuICAgIHN3aXRjaCAodGFyZ2V0KSB7XG4gICAgICAgIGNhc2UgRmFjdG9yeVRhcmdldCQxLkNvbXBvbmVudDpcbiAgICAgICAgY2FzZSBGYWN0b3J5VGFyZ2V0JDEuRGlyZWN0aXZlOlxuICAgICAgICBjYXNlIEZhY3RvcnlUYXJnZXQkMS5QaXBlOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuZGlyZWN0aXZlSW5qZWN0O1xuICAgICAgICBjYXNlIEZhY3RvcnlUYXJnZXQkMS5OZ01vZHVsZTpcbiAgICAgICAgY2FzZSBGYWN0b3J5VGFyZ2V0JDEuSW5qZWN0YWJsZTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmluamVjdDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGlzIGlzIGFuIFIzIGBOb2RlYC1saWtlIHdyYXBwZXIgZm9yIGEgcmF3IGBodG1sLkNvbW1lbnRgIG5vZGUuIFdlIGRvIG5vdCBjdXJyZW50bHlcbiAqIHJlcXVpcmUgdGhlIGltcGxlbWVudGF0aW9uIG9mIGEgdmlzaXRvciBmb3IgQ29tbWVudHMgYXMgdGhleSBhcmUgb25seSBjb2xsZWN0ZWQgYXRcbiAqIHRoZSB0b3AtbGV2ZWwgb2YgdGhlIFIzIEFTVCwgYW5kIG9ubHkgaWYgYFJlbmRlcjNQYXJzZU9wdGlvbnNbJ2NvbGxlY3RDb21tZW50Tm9kZXMnXWBcbiAqIGlzIHRydWUuXG4gKi9cbmNsYXNzIENvbW1lbnQkMSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdChfdmlzaXRvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Zpc2l0KCkgbm90IGltcGxlbWVudGVkIGZvciBDb21tZW50Jyk7XG4gICAgfVxufVxuY2xhc3MgVGV4dCQzIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIEJvdW5kVGV4dCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNvdXJjZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Qm91bmRUZXh0KHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHRleHQgYXR0cmlidXRlIGluIHRoZSB0ZW1wbGF0ZS5cbiAqXG4gKiBgdmFsdWVTcGFuYCBtYXkgbm90IGJlIHByZXNlbnQgaW4gY2FzZXMgd2hlcmUgdGhlcmUgaXMgbm8gdmFsdWUgYDxkaXYgYT48L2Rpdj5gLlxuICogYGtleVNwYW5gIG1heSBhbHNvIG5vdCBiZSBwcmVzZW50IGZvciBzeW50aGV0aWMgYXR0cmlidXRlcyBmcm9tIElDVSBleHBhbnNpb25zLlxuICovXG5jbGFzcyBUZXh0QXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0QXR0cmlidXRlKHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIEJvdW5kQXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBzZWN1cml0eUNvbnRleHQsIHZhbHVlLCB1bml0LCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zZWN1cml0eUNvbnRleHQgPSBzZWN1cml0eUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQm91bmRFbGVtZW50UHJvcGVydHkocHJvcCwgaTE4bikge1xuICAgICAgICBpZiAocHJvcC5rZXlTcGFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBzdGF0ZToga2V5U3BhbiBtdXN0IGJlIGRlZmluZWQgZm9yIGJvdW5kIGF0dHJpYnV0ZXMgYnV0IHdhcyBub3QgZm9yICR7cHJvcC5uYW1lfTogJHtwcm9wLnNvdXJjZVNwYW59YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEF0dHJpYnV0ZShwcm9wLm5hbWUsIHByb3AudHlwZSwgcHJvcC5zZWN1cml0eUNvbnRleHQsIHByb3AudmFsdWUsIHByb3AudW5pdCwgcHJvcC5zb3VyY2VTcGFuLCBwcm9wLmtleVNwYW4sIHByb3AudmFsdWVTcGFuLCBpMThuKTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJvdW5kQXR0cmlidXRlKHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIEJvdW5kRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGhhbmRsZXIsIHRhcmdldCwgcGhhc2UsIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCBrZXlTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnBoYXNlID0gcGhhc2U7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaGFuZGxlclNwYW4gPSBoYW5kbGVyU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICB9XG4gICAgc3RhdGljIGZyb21QYXJzZWRFdmVudChldmVudCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50eXBlID09PSAwIC8qIFJlZ3VsYXIgKi8gPyBldmVudC50YXJnZXRPclBoYXNlIDogbnVsbDtcbiAgICAgICAgY29uc3QgcGhhc2UgPSBldmVudC50eXBlID09PSAxIC8qIEFuaW1hdGlvbiAqLyA/IGV2ZW50LnRhcmdldE9yUGhhc2UgOiBudWxsO1xuICAgICAgICBpZiAoZXZlbnQua2V5U3BhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc3RhdGU6IGtleVNwYW4gbXVzdCBiZSBkZWZpbmVkIGZvciBib3VuZCBldmVudCBidXQgd2FzIG5vdCBmb3IgJHtldmVudC5uYW1lfTogJHtldmVudC5zb3VyY2VTcGFufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRFdmVudChldmVudC5uYW1lLCBldmVudC50eXBlLCBldmVudC5oYW5kbGVyLCB0YXJnZXQsIHBoYXNlLCBldmVudC5zb3VyY2VTcGFuLCBldmVudC5oYW5kbGVyU3BhbiwgZXZlbnQua2V5U3Bhbik7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZEV2ZW50KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIEVsZW1lbnQkMSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXR0cmlidXRlcywgaW5wdXRzLCBvdXRwdXRzLCBjaGlsZHJlbiwgcmVmZXJlbmNlcywgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IodGFnTmFtZSwgYXR0cmlidXRlcywgaW5wdXRzLCBvdXRwdXRzLCB0ZW1wbGF0ZUF0dHJzLCBjaGlsZHJlbiwgcmVmZXJlbmNlcywgdmFyaWFibGVzLCBzb3VyY2VTcGFuLCBzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgdGhpcy50YWdOYW1lID0gdGFnTmFtZTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgICAgIHRoaXMudGVtcGxhdGVBdHRycyA9IHRlbXBsYXRlQXR0cnM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGVtcGxhdGUodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgQ29udGVudCB7XG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIHNvdXJjZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbmctY29udGVudCc7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb250ZW50KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIFZhcmlhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRWYXJpYWJsZSh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBSZWZlcmVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmtleVNwYW4gPSBrZXlTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlZmVyZW5jZSh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBJY3UkMSB7XG4gICAgY29uc3RydWN0b3IodmFycywgcGxhY2Vob2xkZXJzLCBzb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gcGxhY2Vob2xkZXJzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SWN1KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIE51bGxWaXNpdG9yIHtcbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkgeyB9XG4gICAgdmlzaXRUZW1wbGF0ZSh0ZW1wbGF0ZSkgeyB9XG4gICAgdmlzaXRDb250ZW50KGNvbnRlbnQpIHsgfVxuICAgIHZpc2l0VmFyaWFibGUodmFyaWFibGUpIHsgfVxuICAgIHZpc2l0UmVmZXJlbmNlKHJlZmVyZW5jZSkgeyB9XG4gICAgdmlzaXRUZXh0QXR0cmlidXRlKGF0dHJpYnV0ZSkgeyB9XG4gICAgdmlzaXRCb3VuZEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0Qm91bmRFdmVudChhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdEJvdW5kVGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdEljdShpY3UpIHsgfVxufVxuY2xhc3MgUmVjdXJzaXZlVmlzaXRvciQxIHtcbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuYXR0cmlidXRlcyk7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5pbnB1dHMpO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQub3V0cHV0cyk7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5yZWZlcmVuY2VzKTtcbiAgICB9XG4gICAgdmlzaXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIHRlbXBsYXRlLmF0dHJpYnV0ZXMpO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIHRlbXBsYXRlLmlucHV0cyk7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgdGVtcGxhdGUub3V0cHV0cyk7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgdGVtcGxhdGUuY2hpbGRyZW4pO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIHRlbXBsYXRlLnJlZmVyZW5jZXMpO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIHRlbXBsYXRlLnZhcmlhYmxlcyk7XG4gICAgfVxuICAgIHZpc2l0Q29udGVudChjb250ZW50KSB7IH1cbiAgICB2aXNpdFZhcmlhYmxlKHZhcmlhYmxlKSB7IH1cbiAgICB2aXNpdFJlZmVyZW5jZShyZWZlcmVuY2UpIHsgfVxuICAgIHZpc2l0VGV4dEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0Qm91bmRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdEJvdW5kRXZlbnQoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRCb3VuZFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRJY3UoaWN1KSB7IH1cbn1cbmNsYXNzIFRyYW5zZm9ybVZpc2l0b3Ige1xuICAgIHZpc2l0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB0cmFuc2Zvcm1BbGwodGhpcywgZWxlbWVudC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgY29uc3QgbmV3SW5wdXRzID0gdHJhbnNmb3JtQWxsKHRoaXMsIGVsZW1lbnQuaW5wdXRzKTtcbiAgICAgICAgY29uc3QgbmV3T3V0cHV0cyA9IHRyYW5zZm9ybUFsbCh0aGlzLCBlbGVtZW50Lm91dHB1dHMpO1xuICAgICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IHRyYW5zZm9ybUFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgbmV3UmVmZXJlbmNlcyA9IHRyYW5zZm9ybUFsbCh0aGlzLCBlbGVtZW50LnJlZmVyZW5jZXMpO1xuICAgICAgICBpZiAobmV3QXR0cmlidXRlcyAhPSBlbGVtZW50LmF0dHJpYnV0ZXMgfHwgbmV3SW5wdXRzICE9IGVsZW1lbnQuaW5wdXRzIHx8XG4gICAgICAgICAgICBuZXdPdXRwdXRzICE9IGVsZW1lbnQub3V0cHV0cyB8fCBuZXdDaGlsZHJlbiAhPSBlbGVtZW50LmNoaWxkcmVuIHx8XG4gICAgICAgICAgICBuZXdSZWZlcmVuY2VzICE9IGVsZW1lbnQucmVmZXJlbmNlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50JDEoZWxlbWVudC5uYW1lLCBuZXdBdHRyaWJ1dGVzLCBuZXdJbnB1dHMsIG5ld091dHB1dHMsIG5ld0NoaWxkcmVuLCBuZXdSZWZlcmVuY2VzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICB2aXNpdFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUuYXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IG5ld0lucHV0cyA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS5pbnB1dHMpO1xuICAgICAgICBjb25zdCBuZXdPdXRwdXRzID0gdHJhbnNmb3JtQWxsKHRoaXMsIHRlbXBsYXRlLm91dHB1dHMpO1xuICAgICAgICBjb25zdCBuZXdUZW1wbGF0ZUF0dHJzID0gdHJhbnNmb3JtQWxsKHRoaXMsIHRlbXBsYXRlLnRlbXBsYXRlQXR0cnMpO1xuICAgICAgICBjb25zdCBuZXdDaGlsZHJlbiA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS5jaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IG5ld1JlZmVyZW5jZXMgPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUucmVmZXJlbmNlcyk7XG4gICAgICAgIGNvbnN0IG5ld1ZhcmlhYmxlcyA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS52YXJpYWJsZXMpO1xuICAgICAgICBpZiAobmV3QXR0cmlidXRlcyAhPSB0ZW1wbGF0ZS5hdHRyaWJ1dGVzIHx8IG5ld0lucHV0cyAhPSB0ZW1wbGF0ZS5pbnB1dHMgfHxcbiAgICAgICAgICAgIG5ld091dHB1dHMgIT0gdGVtcGxhdGUub3V0cHV0cyB8fCBuZXdUZW1wbGF0ZUF0dHJzICE9IHRlbXBsYXRlLnRlbXBsYXRlQXR0cnMgfHxcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuICE9IHRlbXBsYXRlLmNoaWxkcmVuIHx8IG5ld1JlZmVyZW5jZXMgIT0gdGVtcGxhdGUucmVmZXJlbmNlcyB8fFxuICAgICAgICAgICAgbmV3VmFyaWFibGVzICE9IHRlbXBsYXRlLnZhcmlhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZSh0ZW1wbGF0ZS50YWdOYW1lLCBuZXdBdHRyaWJ1dGVzLCBuZXdJbnB1dHMsIG5ld091dHB1dHMsIG5ld1RlbXBsYXRlQXR0cnMsIG5ld0NoaWxkcmVuLCBuZXdSZWZlcmVuY2VzLCBuZXdWYXJpYWJsZXMsIHRlbXBsYXRlLnNvdXJjZVNwYW4sIHRlbXBsYXRlLnN0YXJ0U291cmNlU3BhbiwgdGVtcGxhdGUuZW5kU291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICB2aXNpdENvbnRlbnQoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgdmlzaXRWYXJpYWJsZSh2YXJpYWJsZSkge1xuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgfVxuICAgIHZpc2l0UmVmZXJlbmNlKHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlO1xuICAgIH1cbiAgICB2aXNpdFRleHRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgfVxuICAgIHZpc2l0Qm91bmRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgfVxuICAgIHZpc2l0Qm91bmRFdmVudChhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHZpc2l0Qm91bmRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSkge1xuICAgICAgICByZXR1cm4gaWN1O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZpc2l0QWxsJDEodmlzaXRvciwgbm9kZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlzaXRvci52aXNpdCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB2aXNpdG9yLnZpc2l0KG5vZGUpIHx8IG5vZGUudmlzaXQodmlzaXRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IG5vZGUudmlzaXQodmlzaXRvcik7XG4gICAgICAgICAgICBpZiAobmV3Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1BbGwodmlzaXRvciwgbm9kZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBjb25zdCBuZXdOb2RlID0gbm9kZS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG5ld05vZGUgIT0gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQgPyByZXN1bHQgOiBub2Rlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbm9kZXMgbWVzc2FnZSBBU1RcbiAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXJzIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gc3RhdGljIGNvbnRlbnQgYW5kIHRoZWlyIHNvdXJjZSBzcGFuc1xuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlclRvTWVzc2FnZSBtYXBzIHBsYWNlaG9sZGVyIG5hbWVzIHRvIG1lc3NhZ2VzICh1c2VkIGZvciBuZXN0ZWQgSUNVIG1lc3NhZ2VzKVxuICAgICAqIEBwYXJhbSBtZWFuaW5nXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgICogQHBhcmFtIGN1c3RvbUlkXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZXMsIHBsYWNlaG9sZGVycywgcGxhY2Vob2xkZXJUb01lc3NhZ2UsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBjdXN0b21JZCkge1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gcGxhY2Vob2xkZXJzO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyVG9NZXNzYWdlID0gcGxhY2Vob2xkZXJUb01lc3NhZ2U7XG4gICAgICAgIHRoaXMubWVhbmluZyA9IG1lYW5pbmc7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jdXN0b21JZCA9IGN1c3RvbUlkO1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5jdXN0b21JZDtcbiAgICAgICAgLyoqIFRoZSBpZHMgdG8gdXNlIGlmIHRoZXJlIGFyZSBubyBjdXN0b20gaWQgYW5kIGlmIGBpMThuTGVnYWN5TWVzc2FnZUlkRm9ybWF0YCBpcyBub3QgZW1wdHkgKi9cbiAgICAgICAgdGhpcy5sZWdhY3lJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXNzYWdlU3RyaW5nID0gc2VyaWFsaXplTWVzc2FnZSh0aGlzLm5vZGVzKTtcbiAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhdGg6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuZmlsZS51cmwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGluZTogbm9kZXNbMF0uc291cmNlU3Bhbi5zdGFydC5saW5lICsgMSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2w6IG5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuY29sICsgMSxcbiAgICAgICAgICAgICAgICAgICAgZW5kTGluZTogbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uc291cmNlU3Bhbi5lbmQubGluZSArIDEsXG4gICAgICAgICAgICAgICAgICAgIGVuZENvbDogbm9kZXNbMF0uc291cmNlU3Bhbi5zdGFydC5jb2wgKyAxXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFRleHQkMiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG4vLyBUT0RPKHZpY2IpOiBkbyB3ZSByZWFsbHkgbmVlZCB0aGlzIG5vZGUgKHZzIGFuIGFycmF5KSA/XG5jbGFzcyBDb250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbnRhaW5lcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBJY3Uge1xuICAgIGNvbnN0cnVjdG9yKGV4cHJlc3Npb24sIHR5cGUsIGNhc2VzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEljdSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBUYWdQbGFjZWhvbGRlciB7XG4gICAgY29uc3RydWN0b3IodGFnLCBhdHRycywgc3RhcnROYW1lLCBjbG9zZU5hbWUsIGNoaWxkcmVuLCBpc1ZvaWQsIFxuICAgIC8vIFRPRE8gc291cmNlU3BhbiBzaG91bGQgY292ZXIgYWxsICh3ZSBuZWVkIGEgc3RhcnRTb3VyY2VTcGFuIGFuZCBlbmRTb3VyY2VTcGFuKVxuICAgIHNvdXJjZVNwYW4sIHN0YXJ0U291cmNlU3BhbiwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnN0YXJ0TmFtZSA9IHN0YXJ0TmFtZTtcbiAgICAgICAgdGhpcy5jbG9zZU5hbWUgPSBjbG9zZU5hbWU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5pc1ZvaWQgPSBpc1ZvaWQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGFnUGxhY2Vob2xkZXIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgUGxhY2Vob2xkZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEljdVBsYWNlaG9sZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgbmFtZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJY3VQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG4vLyBDbG9uZSB0aGUgQVNUXG5jbGFzcyBDbG9uZVZpc2l0b3Ige1xuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dCQyKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGNvbnRhaW5lci5jaGlsZHJlbi5tYXAobiA9PiBuLnZpc2l0KHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXIoY2hpbGRyZW4sIGNvbnRhaW5lci5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNhc2VzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaChrZXkgPT4gY2FzZXNba2V5XSA9IGljdS5jYXNlc1trZXldLnZpc2l0KHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgY29uc3QgbXNnID0gbmV3IEljdShpY3UuZXhwcmVzc2lvbiwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIG1zZy5leHByZXNzaW9uUGxhY2Vob2xkZXIgPSBpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGguY2hpbGRyZW4ubWFwKG4gPT4gbi52aXNpdCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICAgIHJldHVybiBuZXcgVGFnUGxhY2Vob2xkZXIocGgudGFnLCBwaC5hdHRycywgcGguc3RhcnROYW1lLCBwaC5jbG9zZU5hbWUsIGNoaWxkcmVuLCBwaC5pc1ZvaWQsIHBoLnNvdXJjZVNwYW4sIHBoLnN0YXJ0U291cmNlU3BhbiwgcGguZW5kU291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcihwaC52YWx1ZSwgcGgubmFtZSwgcGguc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3VQbGFjZWhvbGRlcihwaC52YWx1ZSwgcGgubmFtZSwgcGguc291cmNlU3Bhbik7XG4gICAgfVxufVxuLy8gVmlzaXQgYWxsIHRoZSBub2RlcyByZWN1cnNpdmVseVxuY2xhc3MgUmVjdXJzZVZpc2l0b3Ige1xuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdENvbnRhaW5lcihjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdEljdShpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWN1LmNhc2VzW2tdLnZpc2l0KHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICBwaC5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkgeyB9XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgbWVzc2FnZSB0byB0aGUgTG9jYWxpemUgYmFja3RpY2sgc3RyaW5nIGZvcm1hdCB0aGF0IHdvdWxkIGFwcGVhciBpbiBjb21waWxlZCBjb2RlLlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVNZXNzYWdlKG1lc3NhZ2VOb2Rlcykge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgTG9jYWxpemVNZXNzYWdlU3RyaW5nVmlzaXRvcigpO1xuICAgIGNvbnN0IHN0ciA9IG1lc3NhZ2VOb2Rlcy5tYXAobiA9PiBuLnZpc2l0KHZpc2l0b3IpKS5qb2luKCcnKTtcbiAgICByZXR1cm4gc3RyO1xufVxuY2xhc3MgTG9jYWxpemVNZXNzYWdlU3RyaW5nVmlzaXRvciB7XG4gICAgdmlzaXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQudmFsdWU7XG4gICAgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSkuam9pbignJyk7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSkge1xuICAgICAgICBjb25zdCBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKChrKSA9PiBgJHtrfSB7JHtpY3UuY2FzZXNba10udmlzaXQodGhpcyl9fWApO1xuICAgICAgICByZXR1cm4gYHske2ljdS5leHByZXNzaW9uUGxhY2Vob2xkZXJ9LCAke2ljdS50eXBlfSwgJHtzdHJDYXNlcy5qb2luKCcgJyl9fWA7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gYHskJHtwaC5zdGFydE5hbWV9fSR7Y2hpbGRyZW59eyQke3BoLmNsb3NlTmFtZX19YDtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCkge1xuICAgICAgICByZXR1cm4gYHskJHtwaC5uYW1lfX1gO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHJldHVybiBgeyQke3BoLm5hbWV9fWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIFNlcmlhbGl6ZXIge1xuICAgIC8vIENyZWF0ZXMgYSBuYW1lIG1hcHBlciwgc2VlIGBQbGFjZWhvbGRlck1hcHBlcmBcbiAgICAvLyBSZXR1cm5pbmcgYG51bGxgIG1lYW5zIHRoYXQgbm8gbmFtZSBtYXBwaW5nIGlzIHVzZWQuXG4gICAgY3JlYXRlTmFtZU1hcHBlcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQSBzaW1wbGUgbWFwcGVyIHRoYXQgdGFrZSBhIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhbiBpbnRlcm5hbCBuYW1lIHRvIGEgcHVibGljIG5hbWVcbiAqL1xuY2xhc3MgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIgZXh0ZW5kcyBSZWN1cnNlVmlzaXRvciB7XG4gICAgLy8gY3JlYXRlIGEgbWFwcGluZyBmcm9tIHRoZSBtZXNzYWdlXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbWFwTmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hcE5hbWUgPSBtYXBOYW1lO1xuICAgICAgICB0aGlzLmludGVybmFsVG9QdWJsaWMgPSB7fTtcbiAgICAgICAgdGhpcy5wdWJsaWNUb05leHRJZCA9IHt9O1xuICAgICAgICB0aGlzLnB1YmxpY1RvSW50ZXJuYWwgPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHRvUHVibGljTmFtZShpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxUb1B1YmxpYy5oYXNPd25Qcm9wZXJ0eShpbnRlcm5hbE5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIHRvSW50ZXJuYWxOYW1lKHB1YmxpY05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljVG9JbnRlcm5hbC5oYXNPd25Qcm9wZXJ0eShwdWJsaWNOYW1lKSA/IHRoaXMucHVibGljVG9JbnRlcm5hbFtwdWJsaWNOYW1lXSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLnN0YXJ0TmFtZSk7XG4gICAgICAgIHN1cGVyLnZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLmNsb3NlTmFtZSk7XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdFBsYWNlaG9sZGVyTmFtZShwaC5uYW1lKTtcbiAgICB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpO1xuICAgIH1cbiAgICAvLyBYTUIgcGxhY2Vob2xkZXJzIGNvdWxkIG9ubHkgY29udGFpbnMgQS1aLCAwLTkgYW5kIF9cbiAgICB2aXNpdFBsYWNlaG9sZGVyTmFtZShpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgaWYgKCFpbnRlcm5hbE5hbWUgfHwgdGhpcy5pbnRlcm5hbFRvUHVibGljLmhhc093blByb3BlcnR5KGludGVybmFsTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHVibGljTmFtZSA9IHRoaXMubWFwTmFtZShpbnRlcm5hbE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5wdWJsaWNUb0ludGVybmFsLmhhc093blByb3BlcnR5KHB1YmxpY05hbWUpKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgWE1CIHdoZW4gaXQgaGFzIGFscmVhZHkgYmVlbiB1c2VkXG4gICAgICAgICAgICBjb25zdCBuZXh0SWQgPSB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdO1xuICAgICAgICAgICAgdGhpcy5wdWJsaWNUb05leHRJZFtwdWJsaWNOYW1lXSA9IG5leHRJZCArIDE7XG4gICAgICAgICAgICBwdWJsaWNOYW1lID0gYCR7cHVibGljTmFtZX1fJHtuZXh0SWR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdID0gcHVibGljTmFtZTtcbiAgICAgICAgdGhpcy5wdWJsaWNUb0ludGVybmFsW3B1YmxpY05hbWVdID0gaW50ZXJuYWxOYW1lO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBfVmlzaXRvciQyIHtcbiAgICB2aXNpdFRhZyh0YWcpIHtcbiAgICAgICAgY29uc3Qgc3RyQXR0cnMgPSB0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKHRhZy5hdHRycyk7XG4gICAgICAgIGlmICh0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgPCR7dGFnLm5hbWV9JHtzdHJBdHRyc30vPmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyQ2hpbGRyZW4gPSB0YWcuY2hpbGRyZW4ubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgICAgIHJldHVybiBgPCR7dGFnLm5hbWV9JHtzdHJBdHRyc30+JHtzdHJDaGlsZHJlbi5qb2luKCcnKX08LyR7dGFnLm5hbWV9PmA7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnZhbHVlO1xuICAgIH1cbiAgICB2aXNpdERlY2xhcmF0aW9uKGRlY2wpIHtcbiAgICAgICAgcmV0dXJuIGA8P3htbCR7dGhpcy5fc2VyaWFsaXplQXR0cmlidXRlcyhkZWNsLmF0dHJzKX0gPz5gO1xuICAgIH1cbiAgICBfc2VyaWFsaXplQXR0cmlidXRlcyhhdHRycykge1xuICAgICAgICBjb25zdCBzdHJBdHRycyA9IE9iamVjdC5rZXlzKGF0dHJzKS5tYXAoKG5hbWUpID0+IGAke25hbWV9PVwiJHthdHRyc1tuYW1lXX1cImApLmpvaW4oJyAnKTtcbiAgICAgICAgcmV0dXJuIHN0ckF0dHJzLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJBdHRycyA6ICcnO1xuICAgIH1cbiAgICB2aXNpdERvY3R5cGUoZG9jdHlwZSkge1xuICAgICAgICByZXR1cm4gYDwhRE9DVFlQRSAke2RvY3R5cGUucm9vdFRhZ30gW1xcbiR7ZG9jdHlwZS5kdGR9XFxuXT5gO1xuICAgIH1cbn1cbmNvbnN0IF92aXNpdG9yID0gbmV3IF9WaXNpdG9yJDIoKTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZShub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUudmlzaXQoX3Zpc2l0b3IpKS5qb2luKCcnKTtcbn1cbmNsYXNzIERlY2xhcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih1bmVzY2FwZWRBdHRycykge1xuICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHVuZXNjYXBlZEF0dHJzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF0dHJzW2tdID0gZXNjYXBlWG1sKHVuZXNjYXBlZEF0dHJzW2tdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREZWNsYXJhdGlvbih0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBEb2N0eXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290VGFnLCBkdGQpIHtcbiAgICAgICAgdGhpcy5yb290VGFnID0gcm9vdFRhZztcbiAgICAgICAgdGhpcy5kdGQgPSBkdGQ7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXREb2N0eXBlKHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIFRhZyB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdW5lc2NhcGVkQXR0cnMgPSB7fSwgY2hpbGRyZW4gPSBbXSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXR0cnNba10gPSBlc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRhZyh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBUZXh0JDEge1xuICAgIGNvbnN0cnVjdG9yKHVuZXNjYXBlZFZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlc2NhcGVYbWwodW5lc2NhcGVkVmFsdWUpO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBDUiBleHRlbmRzIFRleHQkMSB7XG4gICAgY29uc3RydWN0b3Iod3MgPSAwKSB7XG4gICAgICAgIHN1cGVyKGBcXG4ke25ldyBBcnJheSh3cyArIDEpLmpvaW4oJyAnKX1gKTtcbiAgICB9XG59XG5jb25zdCBfRVNDQVBFRF9DSEFSUyA9IFtcbiAgICBbLyYvZywgJyZhbXA7J10sXG4gICAgWy9cIi9nLCAnJnF1b3Q7J10sXG4gICAgWy8nL2csICcmYXBvczsnXSxcbiAgICBbLzwvZywgJyZsdDsnXSxcbiAgICBbLz4vZywgJyZndDsnXSxcbl07XG4vLyBFc2NhcGUgYF9FU0NBUEVEX0NIQVJTYCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiB0ZXh0IHdpdGggZW5jb2RlZCBlbnRpdGllc1xuZnVuY3Rpb24gZXNjYXBlWG1sKHRleHQpIHtcbiAgICByZXR1cm4gX0VTQ0FQRURfQ0hBUlMucmVkdWNlKCh0ZXh0LCBlbnRyeSkgPT4gdGV4dC5yZXBsYWNlKGVudHJ5WzBdLCBlbnRyeVsxXSksIHRleHQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IF9NRVNTQUdFU19UQUcgPSAnbWVzc2FnZWJ1bmRsZSc7XG5jb25zdCBfTUVTU0FHRV9UQUcgPSAnbXNnJztcbmNvbnN0IF9QTEFDRUhPTERFUl9UQUckMyA9ICdwaCc7XG5jb25zdCBfRVhBTVBMRV9UQUcgPSAnZXgnO1xuY29uc3QgX1NPVVJDRV9UQUckMiA9ICdzb3VyY2UnO1xuY29uc3QgX0RPQ1RZUEUgPSBgPCFFTEVNRU5UIG1lc3NhZ2VidW5kbGUgKG1zZykqPlxuPCFBVFRMSVNUIG1lc3NhZ2VidW5kbGUgY2xhc3MgQ0RBVEEgI0lNUExJRUQ+XG5cbjwhRUxFTUVOVCBtc2cgKCNQQ0RBVEF8cGh8c291cmNlKSo+XG48IUFUVExJU1QgbXNnIGlkIENEQVRBICNJTVBMSUVEPlxuPCFBVFRMSVNUIG1zZyBzZXEgQ0RBVEEgI0lNUExJRUQ+XG48IUFUVExJU1QgbXNnIG5hbWUgQ0RBVEEgI0lNUExJRUQ+XG48IUFUVExJU1QgbXNnIGRlc2MgQ0RBVEEgI0lNUExJRUQ+XG48IUFUVExJU1QgbXNnIG1lYW5pbmcgQ0RBVEEgI0lNUExJRUQ+XG48IUFUVExJU1QgbXNnIG9ic29sZXRlIChvYnNvbGV0ZSkgI0lNUExJRUQ+XG48IUFUVExJU1QgbXNnIHhtbDpzcGFjZSAoZGVmYXVsdHxwcmVzZXJ2ZSkgXCJkZWZhdWx0XCI+XG48IUFUVExJU1QgbXNnIGlzX2hpZGRlbiBDREFUQSAjSU1QTElFRD5cblxuPCFFTEVNRU5UIHNvdXJjZSAoI1BDREFUQSk+XG5cbjwhRUxFTUVOVCBwaCAoI1BDREFUQXxleCkqPlxuPCFBVFRMSVNUIHBoIG5hbWUgQ0RBVEEgI1JFUVVJUkVEPlxuXG48IUVMRU1FTlQgZXggKCNQQ0RBVEEpPmA7XG5jbGFzcyBYbWIgZXh0ZW5kcyBTZXJpYWxpemVyIHtcbiAgICB3cml0ZShtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIGNvbnN0IGV4YW1wbGVWaXNpdG9yID0gbmV3IEV4YW1wbGVWaXNpdG9yKCk7XG4gICAgICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMSgpO1xuICAgICAgICBsZXQgcm9vdE5vZGUgPSBuZXcgVGFnKF9NRVNTQUdFU19UQUcpO1xuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSB7IGlkOiBtZXNzYWdlLmlkIH07XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIGF0dHJzWydkZXNjJ10gPSBtZXNzYWdlLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWVhbmluZykge1xuICAgICAgICAgICAgICAgIGF0dHJzWydtZWFuaW5nJ10gPSBtZXNzYWdlLm1lYW5pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc291cmNlVGFncyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgICAgIHNvdXJjZVRhZ3MucHVzaChuZXcgVGFnKF9TT1VSQ0VfVEFHJDIsIHt9LCBbbmV3IFRleHQkMShgJHtzb3VyY2UuZmlsZVBhdGh9OiR7c291cmNlLnN0YXJ0TGluZX0ke3NvdXJjZS5lbmRMaW5lICE9PSBzb3VyY2Uuc3RhcnRMaW5lID8gJywnICsgc291cmNlLmVuZExpbmUgOiAnJ31gKV0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4ucHVzaChuZXcgQ1IoMiksIG5ldyBUYWcoX01FU1NBR0VfVEFHLCBhdHRycywgWy4uLnNvdXJjZVRhZ3MsIC4uLnZpc2l0b3Iuc2VyaWFsaXplKG1lc3NhZ2Uubm9kZXMpXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW4ucHVzaChuZXcgQ1IoKSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uKHsgdmVyc2lvbjogJzEuMCcsIGVuY29kaW5nOiAnVVRGLTgnIH0pLFxuICAgICAgICAgICAgbmV3IENSKCksXG4gICAgICAgICAgICBuZXcgRG9jdHlwZShfTUVTU0FHRVNfVEFHLCBfRE9DVFlQRSksXG4gICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgICAgIGV4YW1wbGVWaXNpdG9yLmFkZERlZmF1bHRFeGFtcGxlcyhyb290Tm9kZSksXG4gICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGxvYWQoY29udGVudCwgdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgZGlnZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRpZ2VzdChtZXNzYWdlKTtcbiAgICB9XG4gICAgY3JlYXRlTmFtZU1hcHBlcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIobWVzc2FnZSwgdG9QdWJsaWNOYW1lKTtcbiAgICB9XG59XG5jbGFzcyBfVmlzaXRvciQxIHtcbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUZXh0JDEodGV4dC52YWx1ZSldO1xuICAgIH1cbiAgICB2aXNpdENvbnRhaW5lcihjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goKG5vZGUpID0+IG5vZGVzLnB1c2goLi4ubm9kZS52aXNpdCh0aGlzKSkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtuZXcgVGV4dCQxKGB7JHtpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyfSwgJHtpY3UudHlwZX0sIGApXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoYCR7Y30ge2ApLCAuLi5pY3UuY2FzZXNbY10udmlzaXQodGhpcyksIG5ldyBUZXh0JDEoYH0gYCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKGB9YCkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUYWdBc1RleHQgPSBuZXcgVGV4dCQxKGA8JHtwaC50YWd9PmApO1xuICAgICAgICBjb25zdCBzdGFydEV4ID0gbmV3IFRhZyhfRVhBTVBMRV9UQUcsIHt9LCBbc3RhcnRUYWdBc1RleHRdKTtcbiAgICAgICAgLy8gVEMgcmVxdWlyZXMgUEggdG8gaGF2ZSBhIG5vbiBlbXB0eSBFWCwgYW5kIHVzZXMgdGhlIHRleHQgbm9kZSB0byBzaG93IHRoZSBcIm9yaWdpbmFsXCIgdmFsdWUuXG4gICAgICAgIGNvbnN0IHN0YXJ0VGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMywgeyBuYW1lOiBwaC5zdGFydE5hbWUgfSwgW3N0YXJ0RXgsIHN0YXJ0VGFnQXNUZXh0XSk7XG4gICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgIC8vIHZvaWQgdGFncyBoYXZlIG5vIGNoaWxkcmVuIG5vciBjbG9zaW5nIHRhZ3NcbiAgICAgICAgICAgIHJldHVybiBbc3RhcnRUYWdQaF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xvc2VUYWdBc1RleHQgPSBuZXcgVGV4dCQxKGA8LyR7cGgudGFnfT5gKTtcbiAgICAgICAgY29uc3QgY2xvc2VFeCA9IG5ldyBUYWcoX0VYQU1QTEVfVEFHLCB7fSwgW2Nsb3NlVGFnQXNUZXh0XSk7XG4gICAgICAgIC8vIFRDIHJlcXVpcmVzIFBIIHRvIGhhdmUgYSBub24gZW1wdHkgRVgsIGFuZCB1c2VzIHRoZSB0ZXh0IG5vZGUgdG8gc2hvdyB0aGUgXCJvcmlnaW5hbFwiIHZhbHVlLlxuICAgICAgICBjb25zdCBjbG9zZVRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDMsIHsgbmFtZTogcGguY2xvc2VOYW1lIH0sIFtjbG9zZUV4LCBjbG9zZVRhZ0FzVGV4dF0pO1xuICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGgsIC4uLnRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgY2xvc2VUYWdQaF07XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbkFzVGV4dCA9IG5ldyBUZXh0JDEoYHt7JHtwaC52YWx1ZX19fWApO1xuICAgICAgICAvLyBFeGFtcGxlIHRhZyBuZWVkcyB0byBiZSBub3QtZW1wdHkgZm9yIFRDLlxuICAgICAgICBjb25zdCBleFRhZyA9IG5ldyBUYWcoX0VYQU1QTEVfVEFHLCB7fSwgW2ludGVycG9sYXRpb25Bc1RleHRdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFRDIHJlcXVpcmVzIFBIIHRvIGhhdmUgYSBub24gZW1wdHkgRVgsIGFuZCB1c2VzIHRoZSB0ZXh0IG5vZGUgdG8gc2hvdyB0aGUgXCJvcmlnaW5hbFwiIHZhbHVlLlxuICAgICAgICAgICAgbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDMsIHsgbmFtZTogcGgubmFtZSB9LCBbZXhUYWcsIGludGVycG9sYXRpb25Bc1RleHRdKVxuICAgICAgICBdO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGljdUV4cHJlc3Npb24gPSBwaC52YWx1ZS5leHByZXNzaW9uO1xuICAgICAgICBjb25zdCBpY3VUeXBlID0gcGgudmFsdWUudHlwZTtcbiAgICAgICAgY29uc3QgaWN1Q2FzZXMgPSBPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKyAnIHsuLi59Jykuam9pbignICcpO1xuICAgICAgICBjb25zdCBpY3VBc1RleHQgPSBuZXcgVGV4dCQxKGB7JHtpY3VFeHByZXNzaW9ufSwgJHtpY3VUeXBlfSwgJHtpY3VDYXNlc319YCk7XG4gICAgICAgIGNvbnN0IGV4VGFnID0gbmV3IFRhZyhfRVhBTVBMRV9UQUcsIHt9LCBbaWN1QXNUZXh0XSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAvLyBUQyByZXF1aXJlcyBQSCB0byBoYXZlIGEgbm9uIGVtcHR5IEVYLCBhbmQgdXNlcyB0aGUgdGV4dCBub2RlIHRvIHNob3cgdGhlIFwib3JpZ2luYWxcIiB2YWx1ZS5cbiAgICAgICAgICAgIG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQzLCB7IG5hbWU6IHBoLm5hbWUgfSwgW2V4VGFnLCBpY3VBc1RleHRdKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBzZXJpYWxpemUobm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi5ub2Rlcy5tYXAobm9kZSA9PiBub2RlLnZpc2l0KHRoaXMpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGlnZXN0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZGVjaW1hbERpZ2VzdChtZXNzYWdlKTtcbn1cbi8vIFRDIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBub24tZW1wdHkgZXhhbXBsZSBvbiBwbGFjZWhvbGRlcnNcbmNsYXNzIEV4YW1wbGVWaXNpdG9yIHtcbiAgICBhZGREZWZhdWx0RXhhbXBsZXMobm9kZSkge1xuICAgICAgICBub2RlLnZpc2l0KHRoaXMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgdmlzaXRUYWcodGFnKSB7XG4gICAgICAgIGlmICh0YWcubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRyQzKSB7XG4gICAgICAgICAgICBpZiAoIXRhZy5jaGlsZHJlbiB8fCB0YWcuY2hpbGRyZW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleFRleHQgPSBuZXcgVGV4dCQxKHRhZy5hdHRyc1snbmFtZSddIHx8ICcuLi4nKTtcbiAgICAgICAgICAgICAgICB0YWcuY2hpbGRyZW4gPSBbbmV3IFRhZyhfRVhBTVBMRV9UQUcsIHt9LCBbZXhUZXh0XSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhZy5jaGlsZHJlbikge1xuICAgICAgICAgICAgdGFnLmNoaWxkcmVuLmZvckVhY2gobm9kZSA9PiBub2RlLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXREZWNsYXJhdGlvbihkZWNsKSB7IH1cbiAgICB2aXNpdERvY3R5cGUoZG9jdHlwZSkgeyB9XG59XG4vLyBYTUIvWFRCIHBsYWNlaG9sZGVycyBjYW4gb25seSBjb250YWluIEEtWiwgMC05IGFuZCBfXG5mdW5jdGlvbiB0b1B1YmxpY05hbWUoaW50ZXJuYWxOYW1lKSB7XG4gICAgcmV0dXJuIGludGVybmFsTmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1teQS1aMC05X10vZywgJ18nKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiBDbG9zdXJlIHZhcmlhYmxlcyBob2xkaW5nIG1lc3NhZ2VzIG11c3QgYmUgbmFtZWQgYE1TR19bQS1aMC05XStgICovXG5jb25zdCBDTE9TVVJFX1RSQU5TTEFUSU9OX1ZBUl9QUkVGSVggPSAnTVNHXyc7XG4vKipcbiAqIFByZWZpeCBmb3Igbm9uLWBnb29nLmdldE1zZ2AgaTE4bi1yZWxhdGVkIHZhcnMuXG4gKiBOb3RlOiB0aGUgcHJlZml4IHVzZXMgbG93ZXJjYXNlIGNoYXJhY3RlcnMgaW50ZW50aW9uYWxseSBkdWUgdG8gYSBDbG9zdXJlIGJlaGF2aW9yIHRoYXRcbiAqIGNvbnNpZGVycyB2YXJpYWJsZXMgbGlrZSBgSTE4Tl8wYCBhcyBjb25zdGFudHMgYW5kIHRocm93cyBhbiBlcnJvciB3aGVuIHRoZWlyIHZhbHVlIGNoYW5nZXMuXG4gKi9cbmNvbnN0IFRSQU5TTEFUSU9OX1ZBUl9QUkVGSVggPSAnaTE4bl8nO1xuLyoqIE5hbWUgb2YgdGhlIGkxOG4gYXR0cmlidXRlcyAqKi9cbmNvbnN0IEkxOE5fQVRUUiA9ICdpMThuJztcbmNvbnN0IEkxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xuLyoqIFByZWZpeCBvZiB2YXIgZXhwcmVzc2lvbnMgdXNlZCBpbiBJQ1VzICovXG5jb25zdCBJMThOX0lDVV9WQVJfUFJFRklYID0gJ1ZBUl8nO1xuLyoqIFByZWZpeCBvZiBJQ1UgZXhwcmVzc2lvbnMgZm9yIHBvc3QgcHJvY2Vzc2luZyAqL1xuY29uc3QgSTE4Tl9JQ1VfTUFQUElOR19QUkVGSVggPSAnSTE4Tl9FWFBfJztcbi8qKiBQbGFjZWhvbGRlciB3cmFwcGVyIGZvciBpMThuIGV4cHJlc3Npb25zICoqL1xuY29uc3QgSTE4Tl9QTEFDRUhPTERFUl9TWU1CT0wgPSAn77+9JztcbmZ1bmN0aW9uIGlzSTE4bkF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgPT09IEkxOE5fQVRUUiB8fCBuYW1lLnN0YXJ0c1dpdGgoSTE4Tl9BVFRSX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBpc0kxOG5Sb290Tm9kZShtZXRhKSB7XG4gICAgcmV0dXJuIG1ldGEgaW5zdGFuY2VvZiBNZXNzYWdlO1xufVxuZnVuY3Rpb24gaXNTaW5nbGVJMThuSWN1KG1ldGEpIHtcbiAgICByZXR1cm4gaXNJMThuUm9vdE5vZGUobWV0YSkgJiYgbWV0YS5ub2Rlcy5sZW5ndGggPT09IDEgJiYgbWV0YS5ub2Rlc1swXSBpbnN0YW5jZW9mIEljdTtcbn1cbmZ1bmN0aW9uIGhhc0kxOG5NZXRhKG5vZGUpIHtcbiAgICByZXR1cm4gISFub2RlLmkxOG47XG59XG5mdW5jdGlvbiBoYXNJMThuQXR0cnMoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmF0dHJzLnNvbWUoKGF0dHIpID0+IGlzSTE4bkF0dHJpYnV0ZShhdHRyLm5hbWUpKTtcbn1cbmZ1bmN0aW9uIGljdUZyb21JMThuTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2Uubm9kZXNbMF07XG59XG5mdW5jdGlvbiB3cmFwSTE4blBsYWNlaG9sZGVyKGNvbnRlbnQsIGNvbnRleHRJZCA9IDApIHtcbiAgICBjb25zdCBibG9ja0lkID0gY29udGV4dElkID4gMCA/IGA6JHtjb250ZXh0SWR9YCA6ICcnO1xuICAgIHJldHVybiBgJHtJMThOX1BMQUNFSE9MREVSX1NZTUJPTH0ke2NvbnRlbnR9JHtibG9ja0lkfSR7STE4Tl9QTEFDRUhPTERFUl9TWU1CT0x9YDtcbn1cbmZ1bmN0aW9uIGFzc2VtYmxlSTE4bkJvdW5kU3RyaW5nKHN0cmluZ3MsIGJpbmRpbmdTdGFydEluZGV4ID0gMCwgY29udGV4dElkID0gMCkge1xuICAgIGlmICghc3RyaW5ncy5sZW5ndGgpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBsZXQgYWNjID0gJyc7XG4gICAgY29uc3QgbGFzdElkeCA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJZHg7IGkrKykge1xuICAgICAgICBhY2MgKz0gYCR7c3RyaW5nc1tpXX0ke3dyYXBJMThuUGxhY2Vob2xkZXIoYmluZGluZ1N0YXJ0SW5kZXggKyBpLCBjb250ZXh0SWQpfWA7XG4gICAgfVxuICAgIGFjYyArPSBzdHJpbmdzW2xhc3RJZHhdO1xuICAgIHJldHVybiBhY2M7XG59XG5mdW5jdGlvbiBnZXRTZXFOdW1iZXJHZW5lcmF0b3Ioc3RhcnRzQXQgPSAwKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBzdGFydHNBdDtcbiAgICByZXR1cm4gKCkgPT4gY3VycmVudCsrO1xufVxuZnVuY3Rpb24gcGxhY2Vob2xkZXJzVG9QYXJhbXMocGxhY2Vob2xkZXJzKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgcGxhY2Vob2xkZXJzLmZvckVhY2goKHZhbHVlcywga2V5KSA9PiB7XG4gICAgICAgIHBhcmFtc1trZXldID0gbGl0ZXJhbCh2YWx1ZXMubGVuZ3RoID4gMSA/IGBbJHt2YWx1ZXMuam9pbignfCcpfV1gIDogdmFsdWVzWzBdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gdXBkYXRlUGxhY2Vob2xkZXJNYXAobWFwLCBuYW1lLCAuLi52YWx1ZXMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gbWFwLmdldChuYW1lKSB8fCBbXTtcbiAgICBjdXJyZW50LnB1c2goLi4udmFsdWVzKTtcbiAgICBtYXAuc2V0KG5hbWUsIGN1cnJlbnQpO1xufVxuZnVuY3Rpb24gYXNzZW1ibGVCb3VuZFRleHRQbGFjZWhvbGRlcnMobWV0YSwgYmluZGluZ1N0YXJ0SW5kZXggPSAwLCBjb250ZXh0SWQgPSAwKSB7XG4gICAgY29uc3Qgc3RhcnRJZHggPSBiaW5kaW5nU3RhcnRJbmRleDtcbiAgICBjb25zdCBwbGFjZWhvbGRlcnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgbm9kZSA9IG1ldGEgaW5zdGFuY2VvZiBNZXNzYWdlID8gbWV0YS5ub2Rlcy5maW5kKG5vZGUgPT4gbm9kZSBpbnN0YW5jZW9mIENvbnRhaW5lcikgOiBtZXRhO1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGVcbiAgICAgICAgICAgIC5jaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkIGluc3RhbmNlb2YgUGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAuZm9yRWFjaCgoY2hpbGQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHdyYXBJMThuUGxhY2Vob2xkZXIoc3RhcnRJZHggKyBpZHgsIGNvbnRleHRJZCk7XG4gICAgICAgICAgICB1cGRhdGVQbGFjZWhvbGRlck1hcChwbGFjZWhvbGRlcnMsIGNoaWxkLm5hbWUsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVycztcbn1cbi8qKlxuICogRm9ybWF0IHRoZSBwbGFjZWhvbGRlciBuYW1lcyBpbiBhIG1hcCBvZiBwbGFjZWhvbGRlcnMgdG8gZXhwcmVzc2lvbnMuXG4gKlxuICogVGhlIHBsYWNlaG9sZGVyIG5hbWVzIGFyZSBjb252ZXJ0ZWQgZnJvbSBcImludGVybmFsXCIgZm9ybWF0IChlLmcuIGBTVEFSVF9UQUdfRElWXzFgKSB0byBcImV4dGVybmFsXCJcbiAqIGZvcm1hdCAoZS5nLiBgc3RhcnRUYWdEaXZfMWApLlxuICpcbiAqIEBwYXJhbSBwYXJhbXMgQSBtYXAgb2YgcGxhY2Vob2xkZXIgbmFtZXMgdG8gZXhwcmVzc2lvbnMuXG4gKiBAcGFyYW0gdXNlQ2FtZWxDYXNlIHdoZXRoZXIgdG8gY2FtZWxDYXNlIHRoZSBwbGFjZWhvbGRlciBuYW1lIHdoZW4gZm9ybWF0dGluZy5cbiAqIEByZXR1cm5zIEEgbmV3IG1hcCBvZiBmb3JtYXR0ZWQgcGxhY2Vob2xkZXIgbmFtZXMgdG8gZXhwcmVzc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIGkxOG5Gb3JtYXRQbGFjZWhvbGRlck5hbWVzKHBhcmFtcyA9IHt9LCB1c2VDYW1lbENhc2UpIHtcbiAgICBjb25zdCBfcGFyYW1zID0ge307XG4gICAgaWYgKHBhcmFtcyAmJiBPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goa2V5ID0+IF9wYXJhbXNbZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZShrZXksIHVzZUNhbWVsQ2FzZSldID0gcGFyYW1zW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gX3BhcmFtcztcbn1cbi8qKlxuICogQ29udmVydHMgaW50ZXJuYWwgcGxhY2Vob2xkZXIgbmFtZXMgdG8gcHVibGljLWZhY2luZyBmb3JtYXRcbiAqIChmb3IgZXhhbXBsZSB0byB1c2UgaW4gZ29vZy5nZXRNc2cgY2FsbCkuXG4gKiBFeGFtcGxlOiBgU1RBUlRfVEFHX0RJVl8xYCBpcyBjb252ZXJ0ZWQgdG8gYHN0YXJ0VGFnRGl2XzFgLlxuICpcbiAqIEBwYXJhbSBuYW1lIFRoZSBwbGFjZWhvbGRlciBuYW1lIHRoYXQgc2hvdWxkIGJlIGZvcm1hdHRlZFxuICogQHJldHVybnMgRm9ybWF0dGVkIHBsYWNlaG9sZGVyIG5hbWVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZShuYW1lLCB1c2VDYW1lbENhc2UgPSB0cnVlKSB7XG4gICAgY29uc3QgcHVibGljTmFtZSA9IHRvUHVibGljTmFtZShuYW1lKTtcbiAgICBpZiAoIXVzZUNhbWVsQ2FzZSkge1xuICAgICAgICByZXR1cm4gcHVibGljTmFtZTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gcHVibGljTmFtZS5zcGxpdCgnXycpO1xuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGlmIG5vIFwiX1wiIGZvdW5kIC0ganVzdCBsb3dlcmNhc2UgdGhlIHZhbHVlXG4gICAgICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGxldCBwb3N0Zml4O1xuICAgIC8vIGVqZWN0IGxhc3QgZWxlbWVudCBpZiBpdCdzIGEgbnVtYmVyXG4gICAgaWYgKC9eXFxkKyQvLnRlc3QoY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcG9zdGZpeCA9IGNodW5rcy5wb3AoKTtcbiAgICB9XG4gICAgbGV0IHJhdyA9IGNodW5rcy5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgcmF3ICs9IGNodW5rcy5tYXAoYyA9PiBjLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgYy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3RmaXggPyBgJHtyYXd9XyR7cG9zdGZpeH1gIDogcmF3O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwcmVmaXggZm9yIHRyYW5zbGF0aW9uIGNvbnN0IG5hbWUuXG4gKlxuICogQHBhcmFtIGV4dHJhIEFkZGl0aW9uYWwgbG9jYWwgcHJlZml4IHRoYXQgc2hvdWxkIGJlIGluamVjdGVkIGludG8gdHJhbnNsYXRpb24gdmFyIG5hbWVcbiAqIEByZXR1cm5zIENvbXBsZXRlIHRyYW5zbGF0aW9uIGNvbnN0IHByZWZpeFxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbkNvbnN0UHJlZml4KGV4dHJhKSB7XG4gICAgcmV0dXJuIGAke0NMT1NVUkVfVFJBTlNMQVRJT05fVkFSX1BSRUZJWH0ke2V4dHJhfWAudG9VcHBlckNhc2UoKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgQVNUIHRvIGRlY2xhcmUgYSB2YXJpYWJsZS4gRS5nLiBgdmFyIEkxOE5fMTtgLlxuICogQHBhcmFtIHZhcmlhYmxlIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBkZWNsYXJlLlxuICovXG5mdW5jdGlvbiBkZWNsYXJlSTE4blZhcmlhYmxlKHZhcmlhYmxlKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJlVmFyU3RtdCh2YXJpYWJsZS5uYW1lLCB1bmRlZmluZWQsIElORkVSUkVEX1RZUEUsIHVuZGVmaW5lZCwgdmFyaWFibGUuc291cmNlU3Bhbik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3Qga2V5IGNvbnRhaW5zIHBvdGVudGlhbGx5IHVuc2FmZSBjaGFycywgdGh1cyB0aGUga2V5IHNob3VsZCBiZSB3cmFwcGVkIGluXG4gKiBxdW90ZXMuIE5vdGU6IHdlIGRvIG5vdCB3cmFwIGFsbCBrZXlzIGludG8gcXVvdGVzLCBhcyBpdCBtYXkgaGF2ZSBpbXBhY3Qgb24gbWluaWZpY2F0aW9uIGFuZCBtYXlcbiAqIGJvdCB3b3JrIGluIHNvbWUgY2FzZXMgd2hlbiBvYmplY3Qga2V5cyBhcmUgbWFuZ2xlZCBieSBtaW5pZmllci5cbiAqXG4gKiBUT0RPKEZXLTExMzYpOiB0aGlzIGlzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uLCB3ZSBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhIGJldHRlciB3YXkgb2Ygd29ya2luZyB3aXRoXG4gKiBpbnB1dHMgdGhhdCBjb250YWluIHBvdGVudGlhbGx5IHVuc2FmZSBjaGFycy5cbiAqL1xuY29uc3QgVU5TQUZFX09CSkVDVF9LRVlfTkFNRV9SRUdFWFAgPSAvWy0uXS87XG4vKiogTmFtZSBvZiB0aGUgdGVtcG9yYXJ5IHRvIHVzZSBkdXJpbmcgZGF0YSBiaW5kaW5nICovXG5jb25zdCBURU1QT1JBUllfTkFNRSA9ICdfdCc7XG4vKiogTmFtZSBvZiB0aGUgY29udGV4dCBwYXJhbWV0ZXIgcGFzc2VkIGludG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiAqL1xuY29uc3QgQ09OVEVYVF9OQU1FID0gJ2N0eCc7XG4vKiogTmFtZSBvZiB0aGUgUmVuZGVyRmxhZyBwYXNzZWQgaW50byBhIHRlbXBsYXRlIGZ1bmN0aW9uICovXG5jb25zdCBSRU5ERVJfRkxBR1MgPSAncmYnO1xuLyoqIFRoZSBwcmVmaXggcmVmZXJlbmNlIHZhcmlhYmxlcyAqL1xuY29uc3QgUkVGRVJFTkNFX1BSRUZJWCA9ICdfcic7XG4vKiogVGhlIG5hbWUgb2YgdGhlIGltcGxpY2l0IGNvbnRleHQgcmVmZXJlbmNlICovXG5jb25zdCBJTVBMSUNJVF9SRUZFUkVOQ0UgPSAnJGltcGxpY2l0Jztcbi8qKiBOb24gYmluZGFibGUgYXR0cmlidXRlIG5hbWUgKiovXG5jb25zdCBOT05fQklOREFCTEVfQVRUUiA9ICduZ05vbkJpbmRhYmxlJztcbi8qKiBOYW1lIGZvciB0aGUgdmFyaWFibGUga2VlcGluZyB0cmFjayBvZiB0aGUgY29udGV4dCByZXR1cm5lZCBieSBgybXJtXJlc3RvcmVWaWV3YC4gKi9cbmNvbnN0IFJFU1RPUkVEX1ZJRVdfQ09OVEVYVF9OQU1FID0gJ3Jlc3RvcmVkQ3R4Jztcbi8qKlxuICogQ3JlYXRlcyBhbiBhbGxvY2F0b3IgZm9yIGEgdGVtcG9yYXJ5IHZhcmlhYmxlLlxuICpcbiAqIEEgdmFyaWFibGUgZGVjbGFyYXRpb24gaXMgYWRkZWQgdG8gdGhlIHN0YXRlbWVudHMgdGhlIGZpcnN0IHRpbWUgdGhlIGFsbG9jYXRvciBpcyBpbnZva2VkLlxuICovXG5mdW5jdGlvbiB0ZW1wb3JhcnlBbGxvY2F0b3Ioc3RhdGVtZW50cywgbmFtZSkge1xuICAgIGxldCB0ZW1wID0gbnVsbDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgRGVjbGFyZVZhclN0bXQoVEVNUE9SQVJZX05BTUUsIHVuZGVmaW5lZCwgRFlOQU1JQ19UWVBFKSk7XG4gICAgICAgICAgICB0ZW1wID0gdmFyaWFibGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludmFsaWQoYXJnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlOiBWaXNpdG9yICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBkb2Vzbid0IGhhbmRsZSAke2FyZy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xufVxuZnVuY3Rpb24gYXNMaXRlcmFsKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKHZhbHVlLm1hcChhc0xpdGVyYWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdGVyYWwodmFsdWUsIElORkVSUkVEX1RZUEUpO1xufVxuZnVuY3Rpb24gY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwoa2V5cywga2VlcERlY2xhcmVkKSB7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGtleXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG1hcFRvRXhwcmVzc2lvbihrZXlzLCBrZWVwRGVjbGFyZWQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1hcFRvRXhwcmVzc2lvbihtYXAsIGtlZXBEZWNsYXJlZCkge1xuICAgIHJldHVybiBsaXRlcmFsTWFwKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1hcCkubWFwKGtleSA9PiB7XG4gICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBwdWJsaWNQcm9wYFxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBgOmAsIHVzZSBkaXJQcm9wID0gZWxQcm9wXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWFwW2tleV07XG4gICAgICAgIGxldCBkZWNsYXJlZE5hbWU7XG4gICAgICAgIGxldCBwdWJsaWNOYW1lO1xuICAgICAgICBsZXQgbWluaWZpZWROYW1lO1xuICAgICAgICBsZXQgbmVlZHNEZWNsYXJlZE5hbWU7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgW3B1YmxpY05hbWUsIGRlY2xhcmVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIG1pbmlmaWVkTmFtZSA9IGtleTtcbiAgICAgICAgICAgIG5lZWRzRGVjbGFyZWROYW1lID0gcHVibGljTmFtZSAhPT0gZGVjbGFyZWROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgW2RlY2xhcmVkTmFtZSwgcHVibGljTmFtZV0gPSBzcGxpdEF0Q29sb24oa2V5LCBba2V5LCB2YWx1ZV0pO1xuICAgICAgICAgICAgbWluaWZpZWROYW1lID0gZGVjbGFyZWROYW1lO1xuICAgICAgICAgICAgLy8gT25seSBpbmNsdWRlIHRoZSBkZWNsYXJlZCBuYW1lIGlmIGV4dHJhY3RlZCBmcm9tIHRoZSBrZXksIGkuZS4gdGhlIGtleSBjb250YWlucyBhIGNvbG9uLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBkZWNsYXJlZCBuYW1lIHNob3VsZCBiZSBvbWl0dGVkIGV2ZW4gaWYgaXQgaXMgZGlmZmVyZW50IGZyb20gdGhlIHB1YmxpYyBuYW1lLFxuICAgICAgICAgICAgLy8gYXMgaXQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIG1pbmlmaWVkLlxuICAgICAgICAgICAgbmVlZHNEZWNsYXJlZE5hbWUgPSBwdWJsaWNOYW1lICE9PSBkZWNsYXJlZE5hbWUgJiYga2V5LmluY2x1ZGVzKCc6Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogbWluaWZpZWROYW1lLFxuICAgICAgICAgICAgLy8gcHV0IHF1b3RlcyBhcm91bmQga2V5cyB0aGF0IGNvbnRhaW4gcG90ZW50aWFsbHkgdW5zYWZlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIHF1b3RlZDogVU5TQUZFX09CSkVDVF9LRVlfTkFNRV9SRUdFWFAudGVzdChtaW5pZmllZE5hbWUpLFxuICAgICAgICAgICAgdmFsdWU6IChrZWVwRGVjbGFyZWQgJiYgbmVlZHNEZWNsYXJlZE5hbWUpID9cbiAgICAgICAgICAgICAgICBsaXRlcmFsQXJyKFthc0xpdGVyYWwocHVibGljTmFtZSksIGFzTGl0ZXJhbChkZWNsYXJlZE5hbWUpXSkgOlxuICAgICAgICAgICAgICAgIGFzTGl0ZXJhbChwdWJsaWNOYW1lKVxuICAgICAgICB9O1xuICAgIH0pKTtcbn1cbi8qKlxuICogIFJlbW92ZSB0cmFpbGluZyBudWxsIG5vZGVzIGFzIHRoZXkgYXJlIGltcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIHRyaW1UcmFpbGluZ051bGxzKHBhcmFtZXRlcnMpIHtcbiAgICB3aGlsZSAoaXNOdWxsKHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcGFyYW1ldGVycy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG5mdW5jdGlvbiBnZXRRdWVyeVByZWRpY2F0ZShxdWVyeSwgY29uc3RhbnRQb29sKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnkucHJlZGljYXRlKSkge1xuICAgICAgICBsZXQgcHJlZGljYXRlID0gW107XG4gICAgICAgIHF1ZXJ5LnByZWRpY2F0ZS5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgLy8gRWFjaCBpdGVtIGluIHByZWRpY2F0ZXMgYXJyYXkgbWF5IGNvbnRhaW4gc3RyaW5ncyB3aXRoIGNvbW1hLXNlcGFyYXRlZCByZWZzXG4gICAgICAgICAgICAvLyAoZm9yIGV4LiAncmVmLCByZWYxLCAuLi4sIHJlZk4nKSwgdGh1cyB3ZSBleHRyYWN0IGluZGl2aWR1YWwgcmVmcyBhbmQgc3RvcmUgdGhlbVxuICAgICAgICAgICAgLy8gYXMgc2VwYXJhdGUgYXJyYXkgZW50aXRpZXNcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHNlbGVjdG9yLnNwbGl0KCcsJykubWFwKHRva2VuID0+IGxpdGVyYWwodG9rZW4udHJpbSgpKSk7XG4gICAgICAgICAgICBwcmVkaWNhdGUucHVzaCguLi5zZWxlY3RvcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwobGl0ZXJhbEFycihwcmVkaWNhdGUpLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZSBvcmlnaW5hbCBwcmVkaWNhdGUgbWF5IGhhdmUgYmVlbiB3cmFwcGVkIGluIGEgYGZvcndhcmRSZWYoKWAgY2FsbC5cbiAgICAgICAgc3dpdGNoIChxdWVyeS5wcmVkaWNhdGUuZm9yd2FyZFJlZikge1xuICAgICAgICAgICAgY2FzZSAwIC8qIE5vbmUgKi86XG4gICAgICAgICAgICBjYXNlIDIgLyogVW53cmFwcGVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeS5wcmVkaWNhdGUuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBXcmFwcGVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEucmVzb2x2ZUZvcndhcmRSZWYpLmNhbGxGbihbcXVlcnkucHJlZGljYXRlLmV4cHJlc3Npb25dKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBmb3IgYW4gb2JqZWN0IGxpdGVyYWwgdXNlZCBkdXJpbmcgY29kZWdlbiBvZiBkZWZpbml0aW9uIG9iamVjdHMuIFRoZSBnZW5lcmljXG4gKiB0eXBlIGBUYCBhbGxvd3MgdG8gcmVmZXJlbmNlIGEgZG9jdW1lbnRlZCB0eXBlIG9mIHRoZSBnZW5lcmF0ZWQgc3RydWN0dXJlLCBzdWNoIHRoYXQgdGhlXG4gKiBwcm9wZXJ0eSBuYW1lcyB0aGF0IGFyZSBzZXQgY2FuIGJlIHJlc29sdmVkIHRvIHRoZWlyIGRvY3VtZW50ZWQgZGVjbGFyYXRpb24uXG4gKi9cbmNsYXNzIERlZmluaXRpb25NYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2goeyBrZXk6IGtleSwgdmFsdWUsIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9MaXRlcmFsTWFwKCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbE1hcCh0aGlzLnZhbHVlcyk7XG4gICAgfVxufVxuLyoqXG4gKiBFeHRyYWN0IGEgbWFwIG9mIHByb3BlcnRpZXMgdG8gdmFsdWVzIGZvciBhIGdpdmVuIGVsZW1lbnQgb3IgdGVtcGxhdGUgbm9kZSwgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIGJ5IHRoZSBkaXJlY3RpdmUgbWF0Y2hpbmcgbWFjaGluZXJ5LlxuICpcbiAqIEBwYXJhbSBlbE9yVHBsIHRoZSBlbGVtZW50IG9yIHRlbXBsYXRlIGluIHF1ZXN0aW9uXG4gKiBAcmV0dXJuIGFuIG9iamVjdCBzZXQgdXAgZm9yIGRpcmVjdGl2ZSBtYXRjaGluZy4gRm9yIGF0dHJpYnV0ZXMgb24gdGhlIGVsZW1lbnQvdGVtcGxhdGUsIHRoaXNcbiAqIG9iamVjdCBtYXBzIGEgcHJvcGVydHkgbmFtZSB0byBpdHMgKHN0YXRpYykgdmFsdWUuIEZvciBhbnkgYmluZGluZ3MsIHRoaXMgbWFwIHNpbXBseSBtYXBzIHRoZVxuICogcHJvcGVydHkgbmFtZSB0byBhbiBlbXB0eSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJzRm9yRGlyZWN0aXZlTWF0Y2hpbmcoZWxPclRwbCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXNNYXAgPSB7fTtcbiAgICBpZiAoZWxPclRwbCBpbnN0YW5jZW9mIFRlbXBsYXRlICYmIGVsT3JUcGwudGFnTmFtZSAhPT0gJ25nLXRlbXBsYXRlJykge1xuICAgICAgICBlbE9yVHBsLnRlbXBsYXRlQXR0cnMuZm9yRWFjaChhID0+IGF0dHJpYnV0ZXNNYXBbYS5uYW1lXSA9ICcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsT3JUcGwuYXR0cmlidXRlcy5mb3JFYWNoKGEgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc0kxOG5BdHRyaWJ1dGUoYS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNNYXBbYS5uYW1lXSA9IGEudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbE9yVHBsLmlucHV0cy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgYXR0cmlidXRlc01hcFtpLm5hbWVdID0gJyc7XG4gICAgICAgIH0pO1xuICAgICAgICBlbE9yVHBsLm91dHB1dHMuZm9yRWFjaChvID0+IHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNNYXBbby5uYW1lXSA9ICcnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNNYXA7XG59XG4vKiogUmV0dXJucyBhIGNhbGwgZXhwcmVzc2lvbiB0byBhIGNoYWluZWQgaW5zdHJ1Y3Rpb24sIGUuZy4gYHByb3BlcnR5KHBhcmFtc1swXSkocGFyYW1zWzFdKWAuICovXG5mdW5jdGlvbiBjaGFpbmVkSW5zdHJ1Y3Rpb24ocmVmZXJlbmNlLCBjYWxscywgc3Bhbikge1xuICAgIGxldCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihyZWZlcmVuY2UsIG51bGwsIHNwYW4pO1xuICAgIGlmIChjYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLmNhbGxGbihjYWxsc1tpXSwgc3Bhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhIGJsYW5rIGludm9jYXRpb24sIGluIGNhc2UgdGhlIGBjYWxsc2AgYXJyYXkgaXMgZW1wdHkuXG4gICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLmNhbGxGbihbXSwgc3Bhbik7XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9uO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkIHRvIGJlIHBhc3NlZCB0byBhIGdlbmVyYXRlZCBpbnN0cnVjdGlvbiBpbiB0aGUgY2FzZSBvZlxuICogaW50ZXJwb2xhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBpbnRlcnBvbGF0aW9uIGFzdFxuICovXG5mdW5jdGlvbiBnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSB7XG4gICAgY29uc3QgeyBleHByZXNzaW9ucywgc3RyaW5ncyB9ID0gaW50ZXJwb2xhdGlvbjtcbiAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxICYmIHN0cmluZ3MubGVuZ3RoID09PSAyICYmIHN0cmluZ3NbMF0gPT09ICcnICYmIHN0cmluZ3NbMV0gPT09ICcnKSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnRlcnBvbGF0aW9uIGhhcyBvbmUgaW50ZXJwb2xhdGVkIHZhbHVlLCBidXQgdGhlIHByZWZpeCBhbmQgc3VmZml4IGFyZSBib3RoIGVtcHR5XG4gICAgICAgIC8vIHN0cmluZ3MsIHdlIG9ubHkgcGFzcyBvbmUgYXJndW1lbnQsIHRvIGEgc3BlY2lhbCBpbnN0cnVjdGlvbiBsaWtlIGBwcm9wZXJ0eUludGVycG9sYXRlYCBvclxuICAgICAgICAvLyBgdGV4dEludGVycG9sYXRlYC5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnMubGVuZ3RoICsgc3RyaW5ncy5sZW5ndGg7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVJbmplY3RhYmxlKG1ldGEsIHJlc29sdmVGb3J3YXJkUmVmcykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGNvbnN0IGZhY3RvcnlNZXRhID0ge1xuICAgICAgICBuYW1lOiBtZXRhLm5hbWUsXG4gICAgICAgIHR5cGU6IG1ldGEudHlwZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBtZXRhLmludGVybmFsVHlwZSxcbiAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IG1ldGEudHlwZUFyZ3VtZW50Q291bnQsXG4gICAgICAgIGRlcHM6IFtdLFxuICAgICAgICB0YXJnZXQ6IEZhY3RvcnlUYXJnZXQkMS5JbmplY3RhYmxlLFxuICAgIH07XG4gICAgaWYgKG1ldGEudXNlQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBtZXRhLnVzZUNsYXNzIGhhcyB0d28gbW9kZXMgb2Ygb3BlcmF0aW9uLiBFaXRoZXIgZGVwcyBhcmUgc3BlY2lmaWVkLCBpbiB3aGljaCBjYXNlIGBuZXdgIGlzXG4gICAgICAgIC8vIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIGNsYXNzIHdpdGggZGVwZW5kZW5jaWVzIGluamVjdGVkLCBvciBkZXBzIGFyZSBub3Qgc3BlY2lmaWVkIGFuZFxuICAgICAgICAvLyB0aGUgZmFjdG9yeSBvZiB0aGUgY2xhc3MgaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBpdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQSBzcGVjaWFsIGNhc2UgZXhpc3RzIGZvciB1c2VDbGFzczogVHlwZSB3aGVyZSBUeXBlIGlzIHRoZSBpbmplY3RhYmxlIHR5cGUgaXRzZWxmIGFuZCBub1xuICAgICAgICAvLyBkZXBzIGFyZSBzcGVjaWZpZWQsIGluIHdoaWNoIGNhc2UgJ3VzZUNsYXNzJyBpcyBlZmZlY3RpdmVseSBpZ25vcmVkLlxuICAgICAgICBjb25zdCB1c2VDbGFzc09uU2VsZiA9IG1ldGEudXNlQ2xhc3MuZXhwcmVzc2lvbi5pc0VxdWl2YWxlbnQobWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgICAgICBsZXQgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1ldGEuZGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZXBzID0gbWV0YS5kZXBzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZhY3Rvcnk6ICgpID0+IG5ldyBtZXRhLnVzZUNsYXNzKC4uLmRlcHMpXG4gICAgICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmFjdG9yeU1ldGEpLCB7IGRlbGVnYXRlOiBtZXRhLnVzZUNsYXNzLmV4cHJlc3Npb24sIGRlbGVnYXRlRGVwczogZGVwcywgZGVsZWdhdGVUeXBlOiBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGUuQ2xhc3MgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVzZUNsYXNzT25TZWxmKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKGZhY3RvcnlNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBkZWxlZ2F0ZVRvRmFjdG9yeShtZXRhLnR5cGUudmFsdWUsIG1ldGEudXNlQ2xhc3MuZXhwcmVzc2lvbiwgcmVzb2x2ZUZvcndhcmRSZWZzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChtZXRhLnVzZUZhY3RvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobWV0YS5kZXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmYWN0b3J5TWV0YSksIHsgZGVsZWdhdGU6IG1ldGEudXNlRmFjdG9yeSwgZGVsZWdhdGVEZXBzOiBtZXRhLmRlcHMgfHwgW10sIGRlbGVnYXRlVHlwZTogUjNGYWN0b3J5RGVsZWdhdGVUeXBlLkZ1bmN0aW9uIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmbihbXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQobWV0YS51c2VGYWN0b3J5LmNhbGxGbihbXSkpXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS51c2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5vdGU6IGl0J3Mgc2FmZSB0byB1c2UgYG1ldGEudXNlVmFsdWVgIGluc3RlYWQgb2YgdGhlIGBVU0VfVkFMVUUgaW4gbWV0YWAgY2hlY2sgdXNlZCBmb3JcbiAgICAgICAgLy8gY2xpZW50IGNvZGUgYmVjYXVzZSBtZXRhLnVzZVZhbHVlIGlzIGFuIEV4cHJlc3Npb24gd2hpY2ggd2lsbCBiZSBkZWZpbmVkIGV2ZW4gaWYgdGhlIGFjdHVhbFxuICAgICAgICAvLyB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gICAgICAgIHJlc3VsdCA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmYWN0b3J5TWV0YSksIHsgZXhwcmVzc2lvbjogbWV0YS51c2VWYWx1ZS5leHByZXNzaW9uIH0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS51c2VFeGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVzZUV4aXN0aW5nIGlzIGFuIGBpbmplY3RgIGNhbGwgb24gdGhlIGV4aXN0aW5nIHRva2VuLlxuICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmFjdG9yeU1ldGEpLCB7IGV4cHJlc3Npb246IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5pbmplY3QpLmNhbGxGbihbbWV0YS51c2VFeGlzdGluZy5leHByZXNzaW9uXSkgfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgc3RhdGVtZW50czogW10sXG4gICAgICAgICAgICBleHByZXNzaW9uOiBkZWxlZ2F0ZVRvRmFjdG9yeShtZXRhLnR5cGUudmFsdWUsIG1ldGEuaW50ZXJuYWxUeXBlLCByZXNvbHZlRm9yd2FyZFJlZnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRva2VuID0gbWV0YS5pbnRlcm5hbFR5cGU7XG4gICAgY29uc3QgaW5qZWN0YWJsZVByb3BzID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBpbmplY3RhYmxlUHJvcHMuc2V0KCd0b2tlbicsIHRva2VuKTtcbiAgICBpbmplY3RhYmxlUHJvcHMuc2V0KCdmYWN0b3J5JywgcmVzdWx0LmV4cHJlc3Npb24pO1xuICAgIC8vIE9ubHkgZ2VuZXJhdGUgcHJvdmlkZWRJbiBwcm9wZXJ0eSBpZiBpdCBoYXMgYSBub24tbnVsbCB2YWx1ZVxuICAgIGlmIChtZXRhLnByb3ZpZGVkSW4uZXhwcmVzc2lvbi52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpbmplY3RhYmxlUHJvcHMuc2V0KCdwcm92aWRlZEluJywgY29udmVydEZyb21NYXliZUZvcndhcmRSZWZFeHByZXNzaW9uKG1ldGEucHJvdmlkZWRJbikpO1xuICAgIH1cbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLsm1ybVkZWZpbmVJbmplY3RhYmxlKVxuICAgICAgICAuY2FsbEZuKFtpbmplY3RhYmxlUHJvcHMudG9MaXRlcmFsTWFwKCldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgIHR5cGU6IGNyZWF0ZUluamVjdGFibGVUeXBlKG1ldGEpLFxuICAgICAgICBzdGF0ZW1lbnRzOiByZXN1bHQuc3RhdGVtZW50cyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5qZWN0YWJsZVR5cGUobWV0YSkge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLkluamVjdGFibGVEZWNsYXJhdGlvbiwgW3R5cGVXaXRoUGFyYW1ldGVycyhtZXRhLnR5cGUudHlwZSwgbWV0YS50eXBlQXJndW1lbnRDb3VudCldKSk7XG59XG5mdW5jdGlvbiBkZWxlZ2F0ZVRvRmFjdG9yeSh0eXBlLCBpbnRlcm5hbFR5cGUsIHVud3JhcEZvcndhcmRSZWZzKSB7XG4gICAgaWYgKHR5cGUubm9kZSA9PT0gaW50ZXJuYWxUeXBlLm5vZGUpIHtcbiAgICAgICAgLy8gVGhlIHR5cGVzIGFyZSB0aGUgc2FtZSwgc28gd2UgY2FuIHNpbXBseSBkZWxlZ2F0ZSBkaXJlY3RseSB0byB0aGUgdHlwZSdzIGZhY3RvcnkuXG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBmYWN0b3J5OiB0eXBlLsm1ZmFjXG4gICAgICAgIC8vIGBgYFxuICAgICAgICByZXR1cm4gaW50ZXJuYWxUeXBlLnByb3AoJ8m1ZmFjJyk7XG4gICAgfVxuICAgIGlmICghdW53cmFwRm9yd2FyZFJlZnMpIHtcbiAgICAgICAgLy8gVGhlIHR5cGUgaXMgbm90IHdyYXBwZWQgaW4gYSBgZm9yd2FyZFJlZigpYCwgc28gd2UgY3JlYXRlIGEgc2ltcGxlIGZhY3RvcnkgZnVuY3Rpb24gdGhhdFxuICAgICAgICAvLyBhY2NlcHRzIGEgc3ViLXR5cGUgYXMgYW4gYXJndW1lbnQuXG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBmYWN0b3J5OiBmdW5jdGlvbih0KSB7IHJldHVybiBpbnRlcm5hbFR5cGUuybVmYWModCk7IH1cbiAgICAgICAgLy8gYGBgXG4gICAgICAgIHJldHVybiBjcmVhdGVGYWN0b3J5RnVuY3Rpb24oaW50ZXJuYWxUeXBlKTtcbiAgICB9XG4gICAgLy8gVGhlIGludGVybmFsVHlwZSBpcyBhY3R1YWxseSB3cmFwcGVkIGluIGEgYGZvcndhcmRSZWYoKWAgc28gd2UgbmVlZCB0byByZXNvbHZlIHRoYXQgYmVmb3JlXG4gICAgLy8gY2FsbGluZyBpdHMgZmFjdG9yeS5cbiAgICAvLyBgYGBcbiAgICAvLyBmYWN0b3J5OiBmdW5jdGlvbih0KSB7IHJldHVybiBjb3JlLnJlc29sdmVGb3J3YXJkUmVmKHR5cGUpLsm1ZmFjKHQpOyB9XG4gICAgLy8gYGBgXG4gICAgY29uc3QgdW53cmFwcGVkVHlwZSA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5yZXNvbHZlRm9yd2FyZFJlZikuY2FsbEZuKFtpbnRlcm5hbFR5cGVdKTtcbiAgICByZXR1cm4gY3JlYXRlRmFjdG9yeUZ1bmN0aW9uKHVud3JhcHBlZFR5cGUpO1xufVxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeUZ1bmN0aW9uKHR5cGUpIHtcbiAgICByZXR1cm4gZm4oW25ldyBGblBhcmFtKCd0JywgRFlOQU1JQ19UWVBFKV0sIFtuZXcgUmV0dXJuU3RhdGVtZW50KHR5cGUucHJvcCgnybVmYWMnKS5jYWxsRm4oW3ZhcmlhYmxlKCd0JyldKSldKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBVTlVTQUJMRV9JTlRFUlBPTEFUSU9OX1JFR0VYUFMgPSBbXG4gICAgL15cXHMqJC8sXG4gICAgL1s8Pl0vLFxuICAgIC9eW3t9XSQvLFxuICAgIC8mKCN8W2Etel0pL2ksXG4gICAgL15cXC9cXC8vLCAvLyBjb21tZW50XG5dO1xuZnVuY3Rpb24gYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAhKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PSAyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICcke2lkZW50aWZpZXJ9JyB0byBiZSBhbiBhcnJheSwgW3N0YXJ0LCBlbmRdLmApO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWVbMF07XG4gICAgICAgIGNvbnN0IGVuZCA9IHZhbHVlWzFdO1xuICAgICAgICAvLyBDaGVjayBmb3IgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2xzXG4gICAgICAgIFVOVVNBQkxFX0lOVEVSUE9MQVRJT05fUkVHRVhQUy5mb3JFYWNoKHJlZ2V4cCA9PiB7XG4gICAgICAgICAgICBpZiAocmVnZXhwLnRlc3Qoc3RhcnQpIHx8IHJlZ2V4cC50ZXN0KGVuZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFsnJHtzdGFydH0nLCAnJHtlbmR9J10gY29udGFpbnMgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2wuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBJbnRlcnBvbGF0aW9uQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQXJyYXkobWFya2Vycykge1xuICAgICAgICBpZiAoIW1hcmtlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydEludGVycG9sYXRpb25TeW1ib2xzKCdpbnRlcnBvbGF0aW9uJywgbWFya2Vycyk7XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZyhtYXJrZXJzWzBdLCBtYXJrZXJzWzFdKTtcbiAgICB9XG59XG5jb25zdCBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHID0gbmV3IEludGVycG9sYXRpb25Db25maWcoJ3t7JywgJ319Jyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgJEVPRiA9IDA7XG5jb25zdCAkQlNQQUNFID0gODtcbmNvbnN0ICRUQUIgPSA5O1xuY29uc3QgJExGID0gMTA7XG5jb25zdCAkVlRBQiA9IDExO1xuY29uc3QgJEZGID0gMTI7XG5jb25zdCAkQ1IgPSAxMztcbmNvbnN0ICRTUEFDRSA9IDMyO1xuY29uc3QgJEJBTkcgPSAzMztcbmNvbnN0ICREUSA9IDM0O1xuY29uc3QgJEhBU0ggPSAzNTtcbmNvbnN0ICQkID0gMzY7XG5jb25zdCAkUEVSQ0VOVCA9IDM3O1xuY29uc3QgJEFNUEVSU0FORCA9IDM4O1xuY29uc3QgJFNRID0gMzk7XG5jb25zdCAkTFBBUkVOID0gNDA7XG5jb25zdCAkUlBBUkVOID0gNDE7XG5jb25zdCAkU1RBUiA9IDQyO1xuY29uc3QgJFBMVVMgPSA0MztcbmNvbnN0ICRDT01NQSA9IDQ0O1xuY29uc3QgJE1JTlVTID0gNDU7XG5jb25zdCAkUEVSSU9EID0gNDY7XG5jb25zdCAkU0xBU0ggPSA0NztcbmNvbnN0ICRDT0xPTiA9IDU4O1xuY29uc3QgJFNFTUlDT0xPTiA9IDU5O1xuY29uc3QgJExUID0gNjA7XG5jb25zdCAkRVEgPSA2MTtcbmNvbnN0ICRHVCA9IDYyO1xuY29uc3QgJFFVRVNUSU9OID0gNjM7XG5jb25zdCAkMCA9IDQ4O1xuY29uc3QgJDcgPSA1NTtcbmNvbnN0ICQ5ID0gNTc7XG5jb25zdCAkQSA9IDY1O1xuY29uc3QgJEUgPSA2OTtcbmNvbnN0ICRGID0gNzA7XG5jb25zdCAkWCA9IDg4O1xuY29uc3QgJFogPSA5MDtcbmNvbnN0ICRMQlJBQ0tFVCA9IDkxO1xuY29uc3QgJEJBQ0tTTEFTSCA9IDkyO1xuY29uc3QgJFJCUkFDS0VUID0gOTM7XG5jb25zdCAkQ0FSRVQgPSA5NDtcbmNvbnN0ICRfID0gOTU7XG5jb25zdCAkYSA9IDk3O1xuY29uc3QgJGIgPSA5ODtcbmNvbnN0ICRlID0gMTAxO1xuY29uc3QgJGYgPSAxMDI7XG5jb25zdCAkbiA9IDExMDtcbmNvbnN0ICRyID0gMTE0O1xuY29uc3QgJHQgPSAxMTY7XG5jb25zdCAkdSA9IDExNztcbmNvbnN0ICR2ID0gMTE4O1xuY29uc3QgJHggPSAxMjA7XG5jb25zdCAkeiA9IDEyMjtcbmNvbnN0ICRMQlJBQ0UgPSAxMjM7XG5jb25zdCAkQkFSID0gMTI0O1xuY29uc3QgJFJCUkFDRSA9IDEyNTtcbmNvbnN0ICROQlNQID0gMTYwO1xuY29uc3QgJFBJUEUgPSAxMjQ7XG5jb25zdCAkVElMREEgPSAxMjY7XG5jb25zdCAkQVQgPSA2NDtcbmNvbnN0ICRCVCA9IDk2O1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPj0gJFRBQiAmJiBjb2RlIDw9ICRTUEFDRSkgfHwgKGNvZGUgPT0gJE5CU1ApO1xufVxuZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuICQwIDw9IGNvZGUgJiYgY29kZSA8PSAkOTtcbn1cbmZ1bmN0aW9uIGlzQXNjaWlMZXR0ZXIoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRaO1xufVxuZnVuY3Rpb24gaXNBc2NpaUhleERpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAkYSAmJiBjb2RlIDw9ICRmIHx8IGNvZGUgPj0gJEEgJiYgY29kZSA8PSAkRiB8fCBpc0RpZ2l0KGNvZGUpO1xufVxuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gJExGIHx8IGNvZGUgPT09ICRDUjtcbn1cbmZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuICQwIDw9IGNvZGUgJiYgY29kZSA8PSAkNztcbn1cbmZ1bmN0aW9uIGlzUXVvdGUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRCVDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBQYXJzZUxvY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWxlLCBvZmZzZXQsIGxpbmUsIGNvbCkge1xuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQgIT0gbnVsbCA/IGAke3RoaXMuZmlsZS51cmx9QCR7dGhpcy5saW5lfToke3RoaXMuY29sfWAgOiB0aGlzLmZpbGUudXJsO1xuICAgIH1cbiAgICBtb3ZlQnkoZGVsdGEpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5maWxlLmNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgICAgIGxldCBjb2wgPSB0aGlzLmNvbDtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA+IDAgJiYgZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIGRlbHRhKys7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoY2ggPT0gJExGKSB7XG4gICAgICAgICAgICAgICAgbGluZS0tO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaW9yTGluZSA9IHNvdXJjZS5zdWJzdHIoMCwgb2Zmc2V0IC0gMSkubGFzdEluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZSgkTEYpKTtcbiAgICAgICAgICAgICAgICBjb2wgPSBwcmlvckxpbmUgPiAwID8gb2Zmc2V0IC0gcHJpb3JMaW5lIDogb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbiAmJiBkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgZGVsdGEtLTtcbiAgICAgICAgICAgIGlmIChjaCA9PSAkTEYpIHtcbiAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgY29sID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbih0aGlzLmZpbGUsIG9mZnNldCwgbGluZSwgY29sKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBzb3VyY2UgYXJvdW5kIHRoZSBsb2NhdGlvblxuICAgIC8vIFVwIHRvIGBtYXhDaGFyc2Agb3IgYG1heExpbmVzYCBvbiBlYWNoIHNpZGUgb2YgdGhlIGxvY2F0aW9uXG4gICAgZ2V0Q29udGV4dChtYXhDaGFycywgbWF4TGluZXMpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuZmlsZS5jb250ZW50O1xuICAgICAgICBsZXQgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdGFydE9mZnNldCA+IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gY29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGN0eENoYXJzID0gMDtcbiAgICAgICAgICAgIGxldCBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY3R4Q2hhcnMgPCBtYXhDaGFycyAmJiBzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldC0tO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbc3RhcnRPZmZzZXRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IG1heExpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eENoYXJzID0gMDtcbiAgICAgICAgICAgIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdHhDaGFycyA8IG1heENoYXJzICYmIGVuZE9mZnNldCA8IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCsrO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbZW5kT2Zmc2V0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKytjdHhMaW5lcyA9PSBtYXhMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udGVudC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIHRoaXMub2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBhZnRlcjogY29udGVudC5zdWJzdHJpbmcodGhpcy5vZmZzZXQsIGVuZE9mZnNldCArIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBQYXJzZVNvdXJjZUZpbGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQsIHVybCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG59XG5jbGFzcyBQYXJzZVNvdXJjZVNwYW4ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvYmplY3QgdGhhdCBob2xkcyBpbmZvcm1hdGlvbiBhYm91dCBzcGFucyBvZiB0b2tlbnMvbm9kZXMgY2FwdHVyZWQgZHVyaW5nXG4gICAgICogbGV4aW5nL3BhcnNpbmcgb2YgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydFxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIHNwYW4gKGhhdmluZyBza2lwcGVkIGxlYWRpbmcgdHJpdmlhKS5cbiAgICAgKiBTa2lwcGluZyBsZWFkaW5nIHRyaXZpYSBtYWtlcyBzb3VyY2Utc3BhbnMgbW9yZSBcInVzZXIgZnJpZW5kbHlcIiwgc2luY2UgdGhpbmdzIGxpa2UgSFRNTFxuICAgICAqIGVsZW1lbnRzIHdpbGwgYXBwZWFyIHRvIGJlZ2luIGF0IHRoZSBzdGFydCBvZiB0aGUgb3BlbmluZyB0YWcsIHJhdGhlciB0aGFuIGF0IHRoZSBzdGFydCBvZiBhbnlcbiAgICAgKiBsZWFkaW5nIHRyaXZpYSwgd2hpY2ggY291bGQgaW5jbHVkZSBuZXdsaW5lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmRcbiAgICAgKiBUaGUgbG9jYXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc3Bhbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmdWxsU3RhcnRcbiAgICAgKiBUaGUgc3RhcnQgb2YgdGhlIHRva2VuIHdpdGhvdXQgc2tpcHBpbmcgdGhlIGxlYWRpbmcgdHJpdmlhLlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSB0b29saW5nIHRoYXQgc3BsaXRzIHRva2VucyBmdXJ0aGVyLCBzdWNoIGFzIGV4dHJhY3RpbmcgQW5ndWxhciBpbnRlcnBvbGF0aW9uc1xuICAgICAqIGZyb20gdGV4dCB0b2tlbnMuIFN1Y2ggdG9vbGluZyBjcmVhdGVzIG5ldyBzb3VyY2Utc3BhbnMgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIHRva2VuJ3NcbiAgICAgKiBzb3VyY2Utc3Bhbi4gSWYgbGVhZGluZyB0cml2aWEgY2hhcmFjdGVycyBoYXZlIGJlZW4gc2tpcHBlZCB0aGVuIHRoZSBuZXcgc291cmNlLXNwYW5zIG1heSBiZVxuICAgICAqIGluY29ycmVjdGx5IG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXRhaWxzXG4gICAgICogQWRkaXRpb25hbCBpbmZvcm1hdGlvbiAoc3VjaCBhcyBpZGVudGlmaWVyIG5hbWVzKSB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwYW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgZnVsbFN0YXJ0ID0gc3RhcnQsIGRldGFpbHMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuZnVsbFN0YXJ0ID0gZnVsbFN0YXJ0O1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuZmlsZS5jb250ZW50LnN1YnN0cmluZyh0aGlzLnN0YXJ0Lm9mZnNldCwgdGhpcy5lbmQub2Zmc2V0KTtcbiAgICB9XG59XG52YXIgUGFyc2VFcnJvckxldmVsO1xuKGZ1bmN0aW9uIChQYXJzZUVycm9yTGV2ZWwpIHtcbiAgICBQYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsW1wiV0FSTklOR1wiXSA9IDBdID0gXCJXQVJOSU5HXCI7XG4gICAgUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbFtcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG59KShQYXJzZUVycm9yTGV2ZWwgfHwgKFBhcnNlRXJyb3JMZXZlbCA9IHt9KSk7XG5jbGFzcyBQYXJzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBtc2csIGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SKSB7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIGNvbnRleHR1YWxNZXNzYWdlKCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLnNwYW4uc3RhcnQuZ2V0Q29udGV4dCgxMDAsIDMpO1xuICAgICAgICByZXR1cm4gY3R4ID8gYCR7dGhpcy5tc2d9IChcIiR7Y3R4LmJlZm9yZX1bJHtQYXJzZUVycm9yTGV2ZWxbdGhpcy5sZXZlbF19IC0+XSR7Y3R4LmFmdGVyfVwiKWAgOlxuICAgICAgICAgICAgdGhpcy5tc2c7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5zcGFuLmRldGFpbHMgPyBgLCAke3RoaXMuc3Bhbi5kZXRhaWxzfWAgOiAnJztcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29udGV4dHVhbE1lc3NhZ2UoKX06ICR7dGhpcy5zcGFuLnN0YXJ0fSR7ZGV0YWlsc31gO1xuICAgIH1cbn1cbi8qKlxuICogR2VuZXJhdGVzIFNvdXJjZSBTcGFuIG9iamVjdCBmb3IgYSBnaXZlbiBSMyBUeXBlIGZvciBKSVQgbW9kZS5cbiAqXG4gKiBAcGFyYW0ga2luZCBDb21wb25lbnQgb3IgRGlyZWN0aXZlLlxuICogQHBhcmFtIHR5cGVOYW1lIG5hbWUgb2YgdGhlIENvbXBvbmVudCBvciBEaXJlY3RpdmUuXG4gKiBAcGFyYW0gc291cmNlVXJsIHJlZmVyZW5jZSB0byBDb21wb25lbnQgb3IgRGlyZWN0aXZlIHNvdXJjZS5cbiAqIEByZXR1cm5zIGluc3RhbmNlIG9mIFBhcnNlU291cmNlU3BhbiB0aGF0IHJlcHJlc2VudCBhIGdpdmVuIENvbXBvbmVudCBvciBEaXJlY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIHIzSml0VHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZU5hbWUsIHNvdXJjZVVybCkge1xuICAgIGNvbnN0IHNvdXJjZUZpbGVOYW1lID0gYGluICR7a2luZH0gJHt0eXBlTmFtZX0gaW4gJHtzb3VyY2VVcmx9YDtcbiAgICBjb25zdCBzb3VyY2VGaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZSgnJywgc291cmNlRmlsZU5hbWUpO1xuICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIC0xLCAtMSwgLTEpLCBuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCAtMSwgLTEsIC0xKSk7XG59XG5sZXQgX2Fub255bW91c1R5cGVJbmRleCA9IDA7XG5mdW5jdGlvbiBpZGVudGlmaWVyTmFtZShjb21waWxlSWRlbnRpZmllcikge1xuICAgIGlmICghY29tcGlsZUlkZW50aWZpZXIgfHwgIWNvbXBpbGVJZGVudGlmaWVyLnJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVmID0gY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgIGlmIChyZWZbJ19fYW5vbnltb3VzVHlwZSddKSB7XG4gICAgICAgIHJldHVybiByZWZbJ19fYW5vbnltb3VzVHlwZSddO1xuICAgIH1cbiAgICBpZiAocmVmWydfX2ZvcndhcmRfcmVmX18nXSkge1xuICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byB0cnkgdG8gc3RyaW5naWZ5IGEgYGZvcndhcmRSZWYoKWAgZnVuY3Rpb24gYmVjYXVzZSB0aGF0IHdvdWxkIGNhdXNlIHRoZVxuICAgICAgICAvLyBpbm5lciBmdW5jdGlvbiB0byBiZSBldmFsdWF0ZWQgdG9vIGVhcmx5LCBkZWZlYXRpbmcgdGhlIHdob2xlIHBvaW50IG9mIHRoZSBgZm9yd2FyZFJlZmAuXG4gICAgICAgIHJldHVybiAnX19mb3J3YXJkX3JlZl9fJztcbiAgICB9XG4gICAgbGV0IGlkZW50aWZpZXIgPSBzdHJpbmdpZnkocmVmKTtcbiAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAvLyBjYXNlOiBhbm9ueW1vdXMgZnVuY3Rpb25zIVxuICAgICAgICBpZGVudGlmaWVyID0gYGFub255bW91c18ke19hbm9ueW1vdXNUeXBlSW5kZXgrK31gO1xuICAgICAgICByZWZbJ19fYW5vbnltb3VzVHlwZSddID0gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlkZW50aWZpZXIgPSBzYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyO1xufVxuZnVuY3Rpb24gc2FuaXRpemVJZGVudGlmaWVyKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9cXFcvZywgJ18nKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEluIFR5cGVTY3JpcHQsIHRhZ2dlZCB0ZW1wbGF0ZSBmdW5jdGlvbnMgZXhwZWN0IGEgXCJ0ZW1wbGF0ZSBvYmplY3RcIiwgd2hpY2ggaXMgYW4gYXJyYXkgb2ZcbiAqIFwiY29va2VkXCIgc3RyaW5ncyBwbHVzIGEgYHJhd2AgcHJvcGVydHkgdGhhdCBjb250YWlucyBhbiBhcnJheSBvZiBcInJhd1wiIHN0cmluZ3MuIFRoaXMgaXNcbiAqIHR5cGljYWxseSBjb25zdHJ1Y3RlZCB3aXRoIGEgZnVuY3Rpb24gY2FsbGVkIGBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdylgLCBidXQgaXQgbWF5IG5vdFxuICogYmUgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuXG4gKlxuICogVGhpcyBpcyBhIEphdmFTY3JpcHQgcG9seWZpbGwgdGhhdCB1c2VzIF9fbWFrZVRlbXBsYXRlT2JqZWN0IHdoZW4gaXQncyBhdmFpbGFibGUsIGJ1dCBvdGhlcndpc2VcbiAqIGNyZWF0ZXMgYW4gaW5saW5lIGhlbHBlciB3aXRoIHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogSW4gdGhlIGlubGluZSBmdW5jdGlvbiwgaWYgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgaXMgYXZhaWxhYmxlIHdlIHVzZSB0aGF0IHRvIGF0dGFjaCB0aGUgYHJhd2BcbiAqIGFycmF5LlxuICovXG5jb25zdCBtYWtlVGVtcGxhdGVPYmplY3RQb2x5ZmlsbCA9ICcodGhpcyYmdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdHx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5P09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOnR9KTplLnJhdz10LGV9KSc7XG5jbGFzcyBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3IgZXh0ZW5kcyBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZmFsc2UpO1xuICAgIH1cbiAgICB2aXNpdFdyYXBwZWROb2RlRXhwcihhc3QsIGN0eCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbWl0IGEgV3JhcHBlZE5vZGVFeHByIGluIEphdmFzY3JpcHQuJyk7XG4gICAgfVxuICAgIHZpc2l0RGVjbGFyZVZhclN0bXQoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBgdmFyICR7c3RtdC5uYW1lfWApO1xuICAgICAgICBpZiAoc3RtdC52YWx1ZSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsICcgPSAnKTtcbiAgICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgYDtgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0VGFnZ2VkVGVtcGxhdGVFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29udm9sdXRlZCBwaWVjZSBvZiBjb2RlIGlzIGVmZmVjdGl2ZWx5IHRoZSBkb3dubGV2ZWxsZWQgZXF1aXZhbGVudCBvZlxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gdGFnYC4uLmBcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGxpa2U6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyB0YWcoX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpLCBleHByZXNzaW9uMSwgZXhwcmVzc2lvbjIsIC4uLik7XG4gICAgICAgIC8vIGBgYFxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGFzdC50ZW1wbGF0ZS5lbGVtZW50cztcbiAgICAgICAgYXN0LnRhZy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYCgke21ha2VUZW1wbGF0ZU9iamVjdFBvbHlmaWxsfShgKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYFske2VsZW1lbnRzLm1hcChwYXJ0ID0+IGVzY2FwZUlkZW50aWZpZXIocGFydC50ZXh0LCBmYWxzZSkpLmpvaW4oJywgJyl9XSwgYCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGBbJHtlbGVtZW50cy5tYXAocGFydCA9PiBlc2NhcGVJZGVudGlmaWVyKHBhcnQucmF3VGV4dCwgZmFsc2UpKS5qb2luKCcsICcpfV0pYCk7XG4gICAgICAgIGFzdC50ZW1wbGF0ZS5leHByZXNzaW9ucy5mb3JFYWNoKGV4cHJlc3Npb24gPT4ge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJywgJyk7XG4gICAgICAgICAgICBleHByZXNzaW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJyknKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0RnVuY3Rpb25FeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGBmdW5jdGlvbiR7YXN0Lm5hbWUgPyAnICcgKyBhc3QubmFtZSA6ICcnfShgKTtcbiAgICAgICAgdGhpcy5fdmlzaXRQYXJhbXMoYXN0LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oYXN0LCBgKSB7YCk7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGN0eCk7XG4gICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYH1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdChzdG10LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIGBmdW5jdGlvbiAke3N0bXQubmFtZX0oYCk7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKHN0bXQucGFyYW1zLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBgKSB7YCk7XG4gICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIGB9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdExvY2FsaXplZFN0cmluZyhhc3QsIGN0eCkge1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvbnZvbHV0ZWQgcGllY2Ugb2YgY29kZSBpcyBlZmZlY3RpdmVseSB0aGUgZG93bmxldmVsbGVkIGVxdWl2YWxlbnQgb2ZcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vICRsb2NhbGl6ZSBgLi4uYFxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gd2hpY2ggaXMgZWZmZWN0aXZlbHkgbGlrZTpcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vICRsb2NhbGl6ZShfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdyksIGV4cHJlc3Npb24xLCBleHByZXNzaW9uMiwgLi4uKTtcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIGN0eC5wcmludChhc3QsIGAkbG9jYWxpemUoJHttYWtlVGVtcGxhdGVPYmplY3RQb2x5ZmlsbH0oYCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW2FzdC5zZXJpYWxpemVJMThuSGVhZCgpXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhc3QubWVzc2FnZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGFzdC5zZXJpYWxpemVJMThuVGVtcGxhdGVQYXJ0KGkpKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoYXN0LCBgWyR7cGFydHMubWFwKHBhcnQgPT4gZXNjYXBlSWRlbnRpZmllcihwYXJ0LmNvb2tlZCwgZmFsc2UpKS5qb2luKCcsICcpfV0sIGApO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgWyR7cGFydHMubWFwKHBhcnQgPT4gZXNjYXBlSWRlbnRpZmllcihwYXJ0LnJhdywgZmFsc2UpKS5qb2luKCcsICcpfV0pYCk7XG4gICAgICAgIGFzdC5leHByZXNzaW9ucy5mb3JFYWNoKGV4cHJlc3Npb24gPT4ge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJywgJyk7XG4gICAgICAgICAgICBleHByZXNzaW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJyknKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF92aXNpdFBhcmFtcyhwYXJhbXMsIGN0eCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhwYXJhbSA9PiBjdHgucHJpbnQobnVsbCwgcGFyYW0ubmFtZSksIHBhcmFtcywgY3R4LCAnLCcpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRoZSBUcnVzdGVkIFR5cGVzIHBvbGljeSwgb3IgbnVsbCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBub3RcbiAqIGVuYWJsZWQvc3VwcG9ydGVkLCBvciB1bmRlZmluZWQgaWYgdGhlIHBvbGljeSBoYXMgbm90IGJlZW4gY3JlYXRlZCB5ZXQuXG4gKi9cbmxldCBwb2xpY3k7XG4vKipcbiAqIFJldHVybnMgdGhlIFRydXN0ZWQgVHlwZXMgcG9saWN5LCBvciBudWxsIGlmIFRydXN0ZWQgVHlwZXMgYXJlIG5vdFxuICogZW5hYmxlZC9zdXBwb3J0ZWQuIFRoZSBmaXJzdCBjYWxsIHRvIHRoaXMgZnVuY3Rpb24gd2lsbCBjcmVhdGUgdGhlIHBvbGljeS5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9saWN5KCkge1xuICAgIGlmIChwb2xpY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2xpY3kgPSBudWxsO1xuICAgICAgICBpZiAoX2dsb2JhbC50cnVzdGVkVHlwZXMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcG9saWN5ID1cbiAgICAgICAgICAgICAgICAgICAgX2dsb2JhbC50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KCdhbmd1bGFyI3Vuc2FmZS1qaXQnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVTY3JpcHQ6IChzKSA9PiBzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kgdGhyb3dzIGlmIGNhbGxlZCB3aXRoIGEgbmFtZSB0aGF0IGlzXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkLCBldmVuIGluIHJlcG9ydC1vbmx5IG1vZGUuIFVudGlsIHRoZSBBUEkgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICAvLyBjYXRjaCB0aGUgZXJyb3Igbm90IHRvIGJyZWFrIHRoZSBhcHBsaWNhdGlvbnMgZnVuY3Rpb25hbGx5LiBJbiBzdWNoXG4gICAgICAgICAgICAgICAgLy8gY2FzZXMsIHRoZSBjb2RlIHdpbGwgZmFsbCBiYWNrIHRvIHVzaW5nIHN0cmluZ3MuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvbGljeTtcbn1cbi8qKlxuICogVW5zYWZlbHkgcHJvbW90ZSBhIHN0cmluZyB0byBhIFRydXN0ZWRTY3JpcHQsIGZhbGxpbmcgYmFjayB0byBzdHJpbmdzIHdoZW5cbiAqIFRydXN0ZWQgVHlwZXMgYXJlIG5vdCBhdmFpbGFibGUuXG4gKiBAc2VjdXJpdHkgSW4gcGFydGljdWxhciwgaXQgbXVzdCBiZSBhc3N1cmVkIHRoYXQgdGhlIHByb3ZpZGVkIHN0cmluZyB3aWxsXG4gKiBuZXZlciBjYXVzZSBhbiBYU1MgdnVsbmVyYWJpbGl0eSBpZiB1c2VkIGluIGEgY29udGV4dCB0aGF0IHdpbGwgYmVcbiAqIGludGVycHJldGVkIGFuZCBleGVjdXRlZCBhcyBhIHNjcmlwdCBieSBhIGJyb3dzZXIsIGUuZy4gd2hlbiBjYWxsaW5nIGV2YWwuXG4gKi9cbmZ1bmN0aW9uIHRydXN0ZWRTY3JpcHRGcm9tU3RyaW5nKHNjcmlwdCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IGdldFBvbGljeSgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlU2NyaXB0KHNjcmlwdCkpIHx8IHNjcmlwdDtcbn1cbi8qKlxuICogVW5zYWZlbHkgY2FsbCB0aGUgRnVuY3Rpb24gY29uc3RydWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc3RyaW5nIGFyZ3VtZW50cy5cbiAqIEBzZWN1cml0eSBUaGlzIGlzIGEgc2VjdXJpdHktc2Vuc2l0aXZlIGZ1bmN0aW9uOyBhbnkgdXNlIG9mIHRoaXMgZnVuY3Rpb25cbiAqIG11c3QgZ28gdGhyb3VnaCBzZWN1cml0eSByZXZpZXcuIEluIHBhcnRpY3VsYXIsIGl0IG11c3QgYmUgYXNzdXJlZCB0aGF0IGl0XG4gKiBpcyBvbmx5IGNhbGxlZCBmcm9tIHRoZSBKSVQgY29tcGlsZXIsIGFzIHVzZSBpbiBvdGhlciBjb2RlIGNhbiBsZWFkIHRvIFhTU1xuICogdnVsbmVyYWJpbGl0aWVzLlxuICovXG5mdW5jdGlvbiBuZXdUcnVzdGVkRnVuY3Rpb25Gb3JKSVQoLi4uYXJncykge1xuICAgIGlmICghX2dsb2JhbC50cnVzdGVkVHlwZXMpIHtcbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBUcnVzdGVkIFR5cGVzLCBmYWxsIGJhY2sgdG8gdGhlIG1vc3RcbiAgICAgICAgLy8gc3RyYWlnaHRmb3J3YXJkIGltcGxlbWVudGF0aW9uOlxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvLyBDaHJvbWUgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgcGFzc2luZyBUcnVzdGVkU2NyaXB0IHRvIHRoZSBGdW5jdGlvblxuICAgIC8vIGNvbnN0cnVjdG9yLiBUaGUgZm9sbG93aW5nIGltcGxlbWVudHMgdGhlIHdvcmthcm91bmQgcHJvcG9zZWQgb24gdGhlIHBhZ2VcbiAgICAvLyBiZWxvdywgd2hlcmUgdGhlIENocm9taXVtIGJ1ZyBpcyBhbHNvIHJlZmVyZW5jZWQ6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJhcHBzZWMtdHJ1c3RlZC10eXBlcy93aWtpL1RydXN0ZWQtVHlwZXMtZm9yLWZ1bmN0aW9uLWNvbnN0cnVjdG9yXG4gICAgY29uc3QgZm5BcmdzID0gYXJncy5zbGljZSgwLCAtMSkuam9pbignLCcpO1xuICAgIGNvbnN0IGZuQm9keSA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBib2R5ID0gYChmdW5jdGlvbiBhbm9ueW1vdXMoJHtmbkFyZ3N9XG4pIHsgJHtmbkJvZHl9XG59KWA7XG4gICAgLy8gVXNpbmcgZXZhbCBkaXJlY3RseSBjb25mdXNlcyB0aGUgY29tcGlsZXIgYW5kIHByZXZlbnRzIHRoaXMgbW9kdWxlIGZyb21cbiAgICAvLyBiZWluZyBzdHJpcHBlZCBvdXQgb2YgSlMgYmluYXJpZXMgZXZlbiBpZiBub3QgdXNlZC4gVGhlIGdsb2JhbFsnZXZhbCddXG4gICAgLy8gaW5kaXJlY3Rpb24gZml4ZXMgdGhhdC5cbiAgICBjb25zdCBmbiA9IF9nbG9iYWxbJ2V2YWwnXSh0cnVzdGVkU2NyaXB0RnJvbVN0cmluZyhib2R5KSk7XG4gICAgaWYgKGZuLmJpbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBhIGJyb3dzZXIgYnVnIHRoYXQgb25seSBleGlzdHMgaW4gQ2hyb21lIDgzLCB3aGVyZSBwYXNzaW5nXG4gICAgICAgIC8vIGEgVHJ1c3RlZFNjcmlwdCB0byBldmFsIGp1c3QgcmV0dXJucyB0aGUgVHJ1c3RlZFNjcmlwdCBiYWNrIHdpdGhvdXRcbiAgICAgICAgLy8gZXZhbHVhdGluZyBpdC4gSW4gdGhhdCBjYXNlLCBmYWxsIGJhY2sgdG8gdGhlIG1vc3Qgc3RyYWlnaHRmb3J3YXJkXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uOlxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvLyBUbyBjb21wbGV0ZWx5IG1pbWljIHRoZSBiZWhhdmlvciBvZiBjYWxsaW5nIFwibmV3IEZ1bmN0aW9uXCIsIHR3byBtb3JlXG4gICAgLy8gdGhpbmdzIG5lZWQgdG8gaGFwcGVuOlxuICAgIC8vIDEuIFN0cmluZ2lmeWluZyB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gaXRzIHNvdXJjZSBjb2RlXG4gICAgZm4udG9TdHJpbmcgPSAoKSA9PiBib2R5O1xuICAgIC8vIDIuIFdoZW4gY2FsbGluZyB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uLCBgdGhpc2Agc2hvdWxkIHJlZmVyIHRvIGBnbG9iYWxgXG4gICAgcmV0dXJuIGZuLmJpbmQoX2dsb2JhbCk7XG4gICAgLy8gV2hlbiBUcnVzdGVkIFR5cGVzIHN1cHBvcnQgaW4gRnVuY3Rpb24gY29uc3RydWN0b3JzIGlzIHdpZGVseSBhdmFpbGFibGUsXG4gICAgLy8gdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gY2FuIGJlIHNpbXBsaWZpZWQgdG86XG4gICAgLy8gcmV0dXJuIG5ldyBGdW5jdGlvbiguLi5hcmdzLm1hcChhID0+IHRydXN0ZWRTY3JpcHRGcm9tU3RyaW5nKGEpKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyB0byBtYW5hZ2UgdGhlIGV2YWx1YXRpb24gb2YgSklUIGdlbmVyYXRlZCBjb2RlLlxuICovXG5jbGFzcyBKaXRFdmFsdWF0b3Ige1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZVVybCBUaGUgVVJMIG9mIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKiBAcGFyYW0gc3RhdGVtZW50cyBBbiBhcnJheSBvZiBBbmd1bGFyIHN0YXRlbWVudCBBU1Qgbm9kZXMgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAqIEBwYXJhbSByZWZSZXNvbHZlciBSZXNvbHZlcyBgby5FeHRlcm5hbFJlZmVyZW5jZWBzIGludG8gdmFsdWVzLlxuICAgICAqIEBwYXJhbSBjcmVhdGVTb3VyY2VNYXBzIElmIHRydWUgdGhlbiBjcmVhdGUgYSBzb3VyY2UtbWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGUgYW5kIGluY2x1ZGUgaXRcbiAgICAgKiBpbmxpbmUgYXMgYSBzb3VyY2UtbWFwIGNvbW1lbnQuXG4gICAgICogQHJldHVybnMgQSBtYXAgb2YgYWxsIHRoZSB2YXJpYWJsZXMgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgICAqL1xuICAgIGV2YWx1YXRlU3RhdGVtZW50cyhzb3VyY2VVcmwsIHN0YXRlbWVudHMsIHJlZlJlc29sdmVyLCBjcmVhdGVTb3VyY2VNYXBzKSB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG5ldyBKaXRFbWl0dGVyVmlzaXRvcihyZWZSZXNvbHZlcik7XG4gICAgICAgIGNvbnN0IGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KCk7XG4gICAgICAgIC8vIEVuc3VyZSBnZW5lcmF0ZWQgY29kZSBpcyBpbiBzdHJpY3QgbW9kZVxuICAgICAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPiAwICYmICFpc1VzZVN0cmljdFN0YXRlbWVudChzdGF0ZW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgc3RhdGVtZW50cyA9IFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKCd1c2Ugc3RyaWN0JykudG9TdG10KCksXG4gICAgICAgICAgICAgICAgLi4uc3RhdGVtZW50cyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjb252ZXJ0ZXIuY3JlYXRlUmV0dXJuU3RtdChjdHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZUNvZGUoc291cmNlVXJsLCBjdHgsIGNvbnZlcnRlci5nZXRBcmdzKCksIGNyZWF0ZVNvdXJjZU1hcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBhIHBpZWNlIG9mIEpJVCBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKiBAcGFyYW0gc291cmNlVXJsIFRoZSBVUkwgb2YgdGhpcyBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKiBAcGFyYW0gY3R4IEEgY29udGV4dCBvYmplY3QgdGhhdCBjb250YWlucyBhbiBBU1Qgb2YgdGhlIGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAqIEBwYXJhbSB2YXJzIEEgbWFwIGNvbnRhaW5pbmcgdGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgdmFyaWFibGVzIHRoYXQgdGhlIGV2YWx1YXRlZCBjb2RlIG1pZ2h0XG4gICAgICogcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSBjcmVhdGVTb3VyY2VNYXAgSWYgdHJ1ZSB0aGVuIGNyZWF0ZSBhIHNvdXJjZS1tYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZSBhbmQgaW5jbHVkZSBpdFxuICAgICAqIGlubGluZSBhcyBhIHNvdXJjZS1tYXAgY29tbWVudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgdGhlIGNvZGUuXG4gICAgICovXG4gICAgZXZhbHVhdGVDb2RlKHNvdXJjZVVybCwgY3R4LCB2YXJzLCBjcmVhdGVTb3VyY2VNYXApIHtcbiAgICAgICAgbGV0IGZuQm9keSA9IGBcInVzZSBzdHJpY3RcIjske2N0eC50b1NvdXJjZSgpfVxcbi8vIyBzb3VyY2VVUkw9JHtzb3VyY2VVcmx9YDtcbiAgICAgICAgY29uc3QgZm5BcmdOYW1lcyA9IFtdO1xuICAgICAgICBjb25zdCBmbkFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGFyZ05hbWUgaW4gdmFycykge1xuICAgICAgICAgICAgZm5BcmdWYWx1ZXMucHVzaCh2YXJzW2FyZ05hbWVdKTtcbiAgICAgICAgICAgIGZuQXJnTmFtZXMucHVzaChhcmdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3JlYXRlU291cmNlTWFwKSB7XG4gICAgICAgICAgICAvLyB1c2luZyBgbmV3IEZ1bmN0aW9uKC4uLilgIGdlbmVyYXRlcyBhIGhlYWRlciwgMSBsaW5lIG9mIG5vIGFyZ3VtZW50cywgMiBsaW5lcyBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEUuZy4gYGBgXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBhbm9ueW1vdXMoYSxiLGNcbiAgICAgICAgICAgIC8vIC8qKi8pIHsgLi4uIH1gYGBcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gaGFyZCBjb2RlIHRoaXMgZmFjdCwgc28gd2UgYXV0byBkZXRlY3QgaXQgdmlhIGFuIGVtcHR5IGZ1bmN0aW9uIGZpcnN0LlxuICAgICAgICAgICAgY29uc3QgZW1wdHlGbiA9IG5ld1RydXN0ZWRGdW5jdGlvbkZvckpJVCguLi5mbkFyZ05hbWVzLmNvbmNhdCgncmV0dXJuIG51bGw7JykpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJMaW5lcyA9IGVtcHR5Rm4uc2xpY2UoMCwgZW1wdHlGbi5pbmRleE9mKCdyZXR1cm4gbnVsbDsnKSkuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmbkJvZHkgKz0gYFxcbiR7Y3R4LnRvU291cmNlTWFwR2VuZXJhdG9yKHNvdXJjZVVybCwgaGVhZGVyTGluZXMpLnRvSnNDb21tZW50KCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbiA9IG5ld1RydXN0ZWRGdW5jdGlvbkZvckpJVCguLi5mbkFyZ05hbWVzLmNvbmNhdChmbkJvZHkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZUZ1bmN0aW9uKGZuLCBmbkFyZ1ZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBKSVQgZ2VuZXJhdGVkIGZ1bmN0aW9uIGJ5IGNhbGxpbmcgaXQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiB0ZXN0cyB0byBjYXB0dXJlIHRoZSBmdW5jdGlvbnMgdGhhdCBhcmUgZ2VuZXJhdGVkXG4gICAgICogYnkgdGhpcyBgSml0RXZhbHVhdG9yYCBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBiZWluZyBleGVjdXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBleGVjdXRlRnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuKC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogQW4gQW5ndWxhciBBU1QgdmlzaXRvciB0aGF0IGNvbnZlcnRzIEFTVCBub2RlcyBpbnRvIGV4ZWN1dGFibGUgSmF2YVNjcmlwdCBjb2RlLlxuICovXG5jbGFzcyBKaXRFbWl0dGVyVmlzaXRvciBleHRlbmRzIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IocmVmUmVzb2x2ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZWZSZXNvbHZlciA9IHJlZlJlc29sdmVyO1xuICAgICAgICB0aGlzLl9ldmFsQXJnTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZXZhbEFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzID0gW107XG4gICAgfVxuICAgIGNyZWF0ZVJldHVyblN0bXQoY3R4KSB7XG4gICAgICAgIGNvbnN0IHN0bXQgPSBuZXcgUmV0dXJuU3RhdGVtZW50KG5ldyBMaXRlcmFsTWFwRXhwcih0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzLm1hcChyZXN1bHRWYXIgPT4gbmV3IExpdGVyYWxNYXBFbnRyeShyZXN1bHRWYXIsIHZhcmlhYmxlKHJlc3VsdFZhciksIGZhbHNlKSkpKTtcbiAgICAgICAgc3RtdC52aXNpdFN0YXRlbWVudCh0aGlzLCBjdHgpO1xuICAgIH1cbiAgICBnZXRBcmdzKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ldmFsQXJnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFt0aGlzLl9ldmFsQXJnTmFtZXNbaV1dID0gdGhpcy5fZXZhbEFyZ1ZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2aXNpdEV4dGVybmFsRXhwcihhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIHRoaXMucmVmUmVzb2x2ZXIucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKGFzdC52YWx1ZSksIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFdyYXBwZWROb2RlRXhwcihhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIGFzdC5ub2RlLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXREZWNsYXJlVmFyU3RtdChzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgdGhpcy5fZXZhbEV4cG9ydGVkVmFycy5wdXNoKHN0bXQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0RGVjbGFyZVZhclN0bXQoc3RtdCwgY3R4KTtcbiAgICB9XG4gICAgdmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHN0bXQsIGN0eCk7XG4gICAgfVxuICAgIF9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIHZhbHVlLCBjdHgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGlkID09PSAtMSkge1xuICAgICAgICAgICAgaWQgPSB0aGlzLl9ldmFsQXJnVmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2V2YWxBcmdWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IHZhbHVlIH0pIHx8ICd2YWwnO1xuICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goYGppdF8ke25hbWV9XyR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGFzdCwgdGhpcy5fZXZhbEFyZ05hbWVzW2lkXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNVc2VTdHJpY3RTdGF0ZW1lbnQoc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIHN0YXRlbWVudC5pc0VxdWl2YWxlbnQobGl0ZXJhbCgndXNlIHN0cmljdCcpLnRvU3RtdCgpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjb21waWxlSW5qZWN0b3IobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGlmIChtZXRhLnByb3ZpZGVycyAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgncHJvdmlkZXJzJywgbWV0YS5wcm92aWRlcnMpO1xuICAgIH1cbiAgICBpZiAobWV0YS5pbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2ltcG9ydHMnLCBsaXRlcmFsQXJyKG1ldGEuaW1wb3J0cykpO1xuICAgIH1cbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlZmluZUluamVjdG9yKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVJbmplY3RvclR5cGUobWV0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50czogW10gfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluamVjdG9yVHlwZShtZXRhKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuSW5qZWN0b3JEZWNsYXJhdGlvbiwgW25ldyBFeHByZXNzaW9uVHlwZShtZXRhLnR5cGUudHlwZSldKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBgQ29tcGlsZVJlZmxlY3RvcmAgd2hpY2ggcmVzb2x2ZXMgcmVmZXJlbmNlcyB0byBAYW5ndWxhci9jb3JlXG4gKiBzeW1ib2xzIGF0IHJ1bnRpbWUsIGFjY29yZGluZyB0byBhIGNvbnN1bWVyLXByb3ZpZGVkIG1hcHBpbmcuXG4gKlxuICogT25seSBzdXBwb3J0cyBgcmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlYCwgYWxsIG90aGVyIG1ldGhvZHMgdGhyb3cuXG4gKi9cbmNsYXNzIFIzSml0UmVmbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIHJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShyZWYpIHtcbiAgICAgICAgLy8gVGhpcyByZWZsZWN0b3Igb25seSBoYW5kbGVzIEBhbmd1bGFyL2NvcmUgaW1wb3J0cy5cbiAgICAgICAgaWYgKHJlZi5tb2R1bGVOYW1lICE9PSAnQGFuZ3VsYXIvY29yZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgZXh0ZXJuYWwgcmVmZXJlbmNlIHRvICR7cmVmLm1vZHVsZU5hbWV9LCBvbmx5IHJlZmVyZW5jZXMgdG8gQGFuZ3VsYXIvY29yZSBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0Lmhhc093blByb3BlcnR5KHJlZi5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB2YWx1ZSBwcm92aWRlZCBmb3IgQGFuZ3VsYXIvY29yZSBzeW1ib2wgJyR7cmVmLm5hbWV9Jy5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0W3JlZi5uYW1lXTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gYFIzTmdNb2R1bGVEZWZgIGZvciB0aGUgZ2l2ZW4gYFIzTmdNb2R1bGVNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVOZ01vZHVsZShtZXRhKSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbFR5cGUsIGJvb3RzdHJhcCwgZGVjbGFyYXRpb25zLCBpbXBvcnRzLCBleHBvcnRzLCBzY2hlbWFzLCBjb250YWluc0ZvcndhcmREZWNscywgZW1pdElubGluZSwgaWQgfSA9IG1ldGE7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgaW50ZXJuYWxUeXBlKTtcbiAgICBpZiAoYm9vdHN0cmFwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2Jvb3RzdHJhcCcsIHJlZnNUb0FycmF5KGJvb3RzdHJhcCwgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgLy8gSWYgcmVxdWVzdGVkIHRvIGVtaXQgc2NvcGUgaW5mb3JtYXRpb24gaW5saW5lLCBwYXNzIHRoZSBgZGVjbGFyYXRpb25zYCwgYGltcG9ydHNgIGFuZCBgZXhwb3J0c2BcbiAgICAvLyB0byB0aGUgYMm1ybVkZWZpbmVOZ01vZHVsZSgpYCBjYWxsLiBUaGUgSklUIGNvbXBpbGF0aW9uIHVzZXMgdGhpcy5cbiAgICBpZiAoZW1pdElubGluZSkge1xuICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZWNsYXJhdGlvbnMnLCByZWZzVG9BcnJheShkZWNsYXJhdGlvbnMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2ltcG9ydHMnLCByZWZzVG9BcnJheShpbXBvcnRzLCBjb250YWluc0ZvcndhcmREZWNscykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdleHBvcnRzJywgcmVmc1RvQXJyYXkoZXhwb3J0cywgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBub3QgZW1pdHRpbmcgaW5saW5lLCB0aGUgc2NvcGUgaW5mb3JtYXRpb24gaXMgbm90IHBhc3NlZCBpbnRvIGDJtcm1ZGVmaW5lTmdNb2R1bGVgIGFzIGl0IHdvdWxkXG4gICAgLy8gcHJldmVudCB0cmVlLXNoYWtpbmcgb2YgdGhlIGRlY2xhcmF0aW9ucywgaW1wb3J0cyBhbmQgZXhwb3J0cyByZWZlcmVuY2VzLlxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzZXROZ01vZHVsZVNjb3BlQ2FsbCA9IGdlbmVyYXRlU2V0TmdNb2R1bGVTY29wZUNhbGwobWV0YSk7XG4gICAgICAgIGlmIChzZXROZ01vZHVsZVNjb3BlQ2FsbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHNldE5nTW9kdWxlU2NvcGVDYWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2NoZW1hcyAhPT0gbnVsbCAmJiBzY2hlbWFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3NjaGVtYXMnLCBsaXRlcmFsQXJyKHNjaGVtYXMubWFwKHJlZiA9PiByZWYudmFsdWUpKSk7XG4gICAgfVxuICAgIGlmIChpZCAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaWQnLCBpZCk7XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuZGVmaW5lTmdNb2R1bGUpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgY29uc3QgdHlwZSA9IGNyZWF0ZU5nTW9kdWxlVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzIH07XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBpbiBKSVQgbW9kZSB0byBnZW5lcmF0ZSB0aGUgY2FsbCB0byBgybXJtWRlZmluZU5nTW9kdWxlKClgIGZyb20gYSBjYWxsIHRvXG4gKiBgybXJtW5nRGVjbGFyZU5nTW9kdWxlKClgLlxuICovXG5mdW5jdGlvbiBjb21waWxlTmdNb2R1bGVEZWNsYXJhdGlvbkV4cHJlc3Npb24obWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbmV3IFdyYXBwZWROb2RlRXhwcihtZXRhLnR5cGUpKTtcbiAgICBpZiAobWV0YS5ib290c3RyYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnYm9vdHN0cmFwJywgbmV3IFdyYXBwZWROb2RlRXhwcihtZXRhLmJvb3RzdHJhcCkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5kZWNsYXJhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZGVjbGFyYXRpb25zJywgbmV3IFdyYXBwZWROb2RlRXhwcihtZXRhLmRlY2xhcmF0aW9ucykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5pbXBvcnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2ltcG9ydHMnLCBuZXcgV3JhcHBlZE5vZGVFeHByKG1ldGEuaW1wb3J0cykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5leHBvcnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2V4cG9ydHMnLCBuZXcgV3JhcHBlZE5vZGVFeHByKG1ldGEuZXhwb3J0cykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5zY2hlbWFzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3NjaGVtYXMnLCBuZXcgV3JhcHBlZE5vZGVFeHByKG1ldGEuc2NoZW1hcykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdpZCcsIG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS5pZCkpO1xuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlZmluZU5nTW9kdWxlKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5nTW9kdWxlVHlwZSh7IHR5cGU6IG1vZHVsZVR5cGUsIGRlY2xhcmF0aW9ucywgaW1wb3J0cywgZXhwb3J0cyB9KSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuTmdNb2R1bGVEZWNsYXJhdGlvbiwgW1xuICAgICAgICBuZXcgRXhwcmVzc2lvblR5cGUobW9kdWxlVHlwZS50eXBlKSwgdHVwbGVUeXBlT2YoZGVjbGFyYXRpb25zKSwgdHVwbGVUeXBlT2YoaW1wb3J0cyksXG4gICAgICAgIHR1cGxlVHlwZU9mKGV4cG9ydHMpXG4gICAgXSkpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBjYWxsIHRvIGDJtcm1c2V0TmdNb2R1bGVTY29wZWAgd2l0aCBhbGwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIHNvIHRoYXQgdGhlXG4gKiB0cmFuc2l0aXZlIG1vZHVsZSBzY29wZSBjYW4gYmUgY29tcHV0ZWQgZHVyaW5nIHJ1bnRpbWUgaW4gSklUIG1vZGUuIFRoaXMgY2FsbCBpcyBtYXJrZWQgcHVyZVxuICogc3VjaCB0aGF0IHRoZSByZWZlcmVuY2VzIHRvIGRlY2xhcmF0aW9ucywgaW1wb3J0cyBhbmQgZXhwb3J0cyBtYXkgYmUgZWxpZGVkIGNhdXNpbmcgdGhlc2VcbiAqIHN5bWJvbHMgdG8gYmVjb21lIHRyZWUtc2hha2VhYmxlLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNldE5nTW9kdWxlU2NvcGVDYWxsKG1ldGEpIHtcbiAgICBjb25zdCB7IGFkamFjZW50VHlwZTogbW9kdWxlVHlwZSwgZGVjbGFyYXRpb25zLCBpbXBvcnRzLCBleHBvcnRzLCBjb250YWluc0ZvcndhcmREZWNscyB9ID0gbWV0YTtcbiAgICBjb25zdCBzY29wZU1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgaWYgKGRlY2xhcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNjb3BlTWFwLnNldCgnZGVjbGFyYXRpb25zJywgcmVmc1RvQXJyYXkoZGVjbGFyYXRpb25zLCBjb250YWluc0ZvcndhcmREZWNscykpO1xuICAgIH1cbiAgICBpZiAoaW1wb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNjb3BlTWFwLnNldCgnaW1wb3J0cycsIHJlZnNUb0FycmF5KGltcG9ydHMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2NvcGVNYXAuc2V0KCdleHBvcnRzJywgcmVmc1RvQXJyYXkoZXhwb3J0cywgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHNjb3BlTWFwLnZhbHVlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBzZXROZ01vZHVsZVNjb3BlKC4uLilcbiAgICBjb25zdCBmbkNhbGwgPSBuZXcgSW52b2tlRnVuY3Rpb25FeHByKFxuICAgIC8qIGZuICovIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5zZXROZ01vZHVsZVNjb3BlKSwgXG4gICAgLyogYXJncyAqLyBbbW9kdWxlVHlwZSwgc2NvcGVNYXAudG9MaXRlcmFsTWFwKCldKTtcbiAgICAvLyAobmdKaXRNb2RlIGd1YXJkKSAmJiBzZXROZ01vZHVsZVNjb3BlKC4uLilcbiAgICBjb25zdCBndWFyZGVkQ2FsbCA9IGppdE9ubHlHdWFyZGVkRXhwcmVzc2lvbihmbkNhbGwpO1xuICAgIC8vIGZ1bmN0aW9uKCkgeyAobmdKaXRNb2RlIGd1YXJkKSAmJiBzZXROZ01vZHVsZVNjb3BlKC4uLik7IH1cbiAgICBjb25zdCBpaWZlID0gbmV3IEZ1bmN0aW9uRXhwcihcbiAgICAvKiBwYXJhbXMgKi8gW10sIFxuICAgIC8qIHN0YXRlbWVudHMgKi8gW2d1YXJkZWRDYWxsLnRvU3RtdCgpXSk7XG4gICAgLy8gKGZ1bmN0aW9uKCkgeyAobmdKaXRNb2RlIGd1YXJkKSAmJiBzZXROZ01vZHVsZVNjb3BlKC4uLik7IH0pKClcbiAgICBjb25zdCBpaWZlQ2FsbCA9IG5ldyBJbnZva2VGdW5jdGlvbkV4cHIoXG4gICAgLyogZm4gKi8gaWlmZSwgXG4gICAgLyogYXJncyAqLyBbXSk7XG4gICAgcmV0dXJuIGlpZmVDYWxsLnRvU3RtdCgpO1xufVxuZnVuY3Rpb24gdHVwbGVUeXBlT2YoZXhwKSB7XG4gICAgY29uc3QgdHlwZXMgPSBleHAubWFwKHJlZiA9PiB0eXBlb2ZFeHByKHJlZi50eXBlKSk7XG4gICAgcmV0dXJuIGV4cC5sZW5ndGggPiAwID8gZXhwcmVzc2lvblR5cGUobGl0ZXJhbEFycih0eXBlcykpIDogTk9ORV9UWVBFO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVQaXBlRnJvbU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcFZhbHVlcyA9IFtdO1xuICAgIC8vIGUuZy4gYG5hbWU6ICdteVBpcGUnYFxuICAgIGRlZmluaXRpb25NYXBWYWx1ZXMucHVzaCh7IGtleTogJ25hbWUnLCB2YWx1ZTogbGl0ZXJhbChtZXRhZGF0YS5waXBlTmFtZSksIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgLy8gZS5nLiBgdHlwZTogTXlQaXBlYFxuICAgIGRlZmluaXRpb25NYXBWYWx1ZXMucHVzaCh7IGtleTogJ3R5cGUnLCB2YWx1ZTogbWV0YWRhdGEudHlwZS52YWx1ZSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICAvLyBlLmcuIGBwdXJlOiB0cnVlYFxuICAgIGRlZmluaXRpb25NYXBWYWx1ZXMucHVzaCh7IGtleTogJ3B1cmUnLCB2YWx1ZTogbGl0ZXJhbChtZXRhZGF0YS5wdXJlKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlZmluZVBpcGUpLmNhbGxGbihbbGl0ZXJhbE1hcChkZWZpbml0aW9uTWFwVmFsdWVzKV0sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgY29uc3QgdHlwZSA9IGNyZWF0ZVBpcGVUeXBlKG1ldGFkYXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGlwZVR5cGUobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5QaXBlRGVjbGFyYXRpb24sIFtcbiAgICAgICAgdHlwZVdpdGhQYXJhbWV0ZXJzKG1ldGFkYXRhLnR5cGUudHlwZSwgbWV0YWRhdGEudHlwZUFyZ3VtZW50Q291bnQpLFxuICAgICAgICBuZXcgRXhwcmVzc2lvblR5cGUobmV3IExpdGVyYWxFeHByKG1ldGFkYXRhLnBpcGVOYW1lKSksXG4gICAgXSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIFBhcnNlckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5lcnJMb2NhdGlvbiA9IGVyckxvY2F0aW9uO1xuICAgICAgICB0aGlzLmN0eExvY2F0aW9uID0gY3R4TG9jYXRpb247XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBQYXJzZXIgRXJyb3I6ICR7bWVzc2FnZX0gJHtlcnJMb2NhdGlvbn0gWyR7aW5wdXR9XSBpbiAke2N0eExvY2F0aW9ufWA7XG4gICAgfVxufVxuY2xhc3MgUGFyc2VTcGFuIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIHRvQWJzb2x1dGUoYWJzb2x1dGVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oYWJzb2x1dGVPZmZzZXQgKyB0aGlzLnN0YXJ0LCBhYnNvbHV0ZU9mZnNldCArIHRoaXMuZW5kKTtcbiAgICB9XG59XG5jbGFzcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIFxuICAgIC8qKlxuICAgICAqIEFic29sdXRlIGxvY2F0aW9uIG9mIHRoZSBleHByZXNzaW9uIEFTVCBpbiBhIHNvdXJjZSBjb2RlIGZpbGUuXG4gICAgICovXG4gICAgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnNwYW4gPSBzcGFuO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdBU1QnO1xuICAgIH1cbn1cbmNsYXNzIEFTVFdpdGhOYW1lIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBuYW1lU3Bhbikge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5uYW1lU3BhbiA9IG5hbWVTcGFuO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHF1b3RlZCBleHByZXNzaW9uIG9mIHRoZSBmb3JtOlxuICpcbiAqIHF1b3RlID0gcHJlZml4IGA6YCB1bmludGVycHJldGVkRXhwcmVzc2lvblxuICogcHJlZml4ID0gaWRlbnRpZmllclxuICogdW5pbnRlcnByZXRlZEV4cHJlc3Npb24gPSBhcmJpdHJhcnkgc3RyaW5nXG4gKlxuICogQSBxdW90ZWQgZXhwcmVzc2lvbiBpcyBtZWFudCB0byBiZSBwcmUtcHJvY2Vzc2VkIGJ5IGFuIEFTVCB0cmFuc2Zvcm1lciB0aGF0XG4gKiBjb252ZXJ0cyBpdCBpbnRvIGFub3RoZXIgQVNUIHRoYXQgbm8gbG9uZ2VyIGNvbnRhaW5zIHF1b3RlZCBleHByZXNzaW9ucy5cbiAqIEl0IGlzIG1lYW50IHRvIGFsbG93IHRoaXJkLXBhcnR5IGRldmVsb3BlcnMgdG8gZXh0ZW5kIEFuZ3VsYXIgdGVtcGxhdGVcbiAqIGV4cHJlc3Npb24gbGFuZ3VhZ2UuIFRoZSBgdW5pbnRlcnByZXRlZEV4cHJlc3Npb25gIHBhcnQgb2YgdGhlIHF1b3RlIGlzXG4gKiB0aGVyZWZvcmUgbm90IGludGVycHJldGVkIGJ5IHRoZSBBbmd1bGFyJ3Mgb3duIGV4cHJlc3Npb24gcGFyc2VyLlxuICovXG5jbGFzcyBRdW90ZSBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgcHJlZml4LCB1bmludGVycHJldGVkRXhwcmVzc2lvbiwgbG9jYXRpb24pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLnVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gdW5pbnRlcnByZXRlZEV4cHJlc3Npb247XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRRdW90ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnUXVvdGUnO1xuICAgIH1cbn1cbmNsYXNzIEVtcHR5RXhwciBleHRlbmRzIEFTVCB7XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbn1cbmNsYXNzIEltcGxpY2l0UmVjZWl2ZXIgZXh0ZW5kcyBBU1Qge1xuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW1wbGljaXRSZWNlaXZlcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG4vKipcbiAqIFJlY2VpdmVyIHdoZW4gc29tZXRoaW5nIGlzIGFjY2Vzc2VkIHRocm91Z2ggYHRoaXNgIChlLmcuIGB0aGlzLmZvb2ApLiBOb3RlIHRoYXQgdGhpcyBjbGFzc1xuICogaW5oZXJpdHMgZnJvbSBgSW1wbGljaXRSZWNlaXZlcmAsIGJlY2F1c2UgYWNjZXNzaW5nIHNvbWV0aGluZyB0aHJvdWdoIGB0aGlzYCBpcyB0cmVhdGVkIHRoZVxuICogc2FtZSBhcyBhY2Nlc3NpbmcgaXQgaW1wbGljaXRseSBpbnNpZGUgb2YgYW4gQW5ndWxhciB0ZW1wbGF0ZSAoZS5nLiBgW2F0dHIudGl0bGVdPVwidGhpcy50aXRsZVwiYFxuICogaXMgdGhlIHNhbWUgYXMgYFthdHRyLnRpdGxlXT1cInRpdGxlXCJgLikuIEluaGVyaXRpbmcgYWxsb3dzIGZvciB0aGUgYHRoaXNgIGFjY2Vzc2VzIHRvIGJlIHRyZWF0ZWRcbiAqIHRoZSBzYW1lIGFzIGltcGxpY2l0IG9uZXMsIGV4Y2VwdCBmb3IgYSBjb3VwbGUgb2YgZXhjZXB0aW9ucyBsaWtlIGAkZXZlbnRgIGFuZCBgJGFueWAuXG4gKiBUT0RPOiB3ZSBzaG91bGQgZmluZCBhIHdheSBmb3IgdGhpcyBjbGFzcyBub3QgdG8gZXh0ZW5kIGZyb20gYEltcGxpY2l0UmVjZWl2ZXJgIGluIHRoZSBmdXR1cmUuXG4gKi9cbmNsYXNzIFRoaXNSZWNlaXZlciBleHRlbmRzIEltcGxpY2l0UmVjZWl2ZXIge1xuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHZpc2l0b3IudmlzaXRUaGlzUmVjZWl2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZpc2l0b3IsIHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8qKlxuICogTXVsdGlwbGUgZXhwcmVzc2lvbnMgc2VwYXJhdGVkIGJ5IGEgc2VtaWNvbG9uLlxuICovXG5jbGFzcyBDaGFpbiBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGFpbih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBDb25kaXRpb25hbCBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgY29uZGl0aW9uLCB0cnVlRXhwLCBmYWxzZUV4cCkge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudHJ1ZUV4cCA9IHRydWVFeHA7XG4gICAgICAgIHRoaXMuZmFsc2VFeHAgPSBmYWxzZUV4cDtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBQcm9wZXJ0eVJlYWQgZXh0ZW5kcyBBU1RXaXRoTmFtZSB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByb3BlcnR5UmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBQcm9wZXJ0eVdyaXRlIGV4dGVuZHMgQVNUV2l0aE5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuLCByZWNlaXZlciwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFNhZmVQcm9wZXJ0eVJlYWQgZXh0ZW5kcyBBU1RXaXRoTmFtZSB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgS2V5ZWRSZWFkIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCByZWNlaXZlciwga2V5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkUmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBTYWZlS2V5ZWRSZWFkIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCByZWNlaXZlciwga2V5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgS2V5ZWRXcml0ZSBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgcmVjZWl2ZXIsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEJpbmRpbmdQaXBlIGV4dGVuZHMgQVNUV2l0aE5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGV4cCwgbmFtZSwgYXJncywgbmFtZVNwYW4pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pO1xuICAgICAgICB0aGlzLmV4cCA9IGV4cDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQaXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIExpdGVyYWxQcmltaXRpdmUgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBMaXRlcmFsQXJyYXkgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIExpdGVyYWxNYXAgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGtleXMsIHZhbHVlcykge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBJbnRlcnBvbGF0aW9uIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludGVycG9sYXRpb24odGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQmluYXJ5IGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBvcGVyYXRpb24sIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG4vKipcbiAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zLCBgVW5hcnlgIGluaGVyaXRzIGZyb20gYEJpbmFyeWAgYW5kIG1pbWljcyB0aGUgYmluYXJ5IEFTVFxuICogbm9kZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHVzZWQuIFRoaXMgaW5oZXJpdGFuY2UgcmVsYXRpb24gY2FuIGJlIGRlbGV0ZWQgaW4gc29tZSBmdXR1cmUgbWFqb3IsXG4gKiBhZnRlciBjb25zdW1lcnMgaGF2ZSBiZWVuIGdpdmVuIGEgY2hhbmNlIHRvIGZ1bGx5IHN1cHBvcnQgVW5hcnkuXG4gKi9cbmNsYXNzIFVuYXJ5IGV4dGVuZHMgQmluYXJ5IHtcbiAgICAvKipcbiAgICAgKiBEdXJpbmcgdGhlIGRlcHJlY2F0aW9uIHBlcmlvZCB0aGlzIGNvbnN0cnVjdG9yIGlzIHByaXZhdGUsIHRvIGF2b2lkIGNvbnN1bWVycyBmcm9tIGNyZWF0aW5nXG4gICAgICogYSBgVW5hcnlgIHdpdGggdGhlIGZhbGxiYWNrIHByb3BlcnRpZXMgZm9yIGBCaW5hcnlgLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIG9wZXJhdG9yLCBleHByLCBiaW5hcnlPcCwgYmluYXJ5TGVmdCwgYmluYXJ5UmlnaHQpIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3BhbiwgYmluYXJ5T3AsIGJpbmFyeUxlZnQsIGJpbmFyeVJpZ2h0KTtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgICAgICAvLyBSZWRlY2xhcmUgdGhlIHByb3BlcnRpZXMgdGhhdCBhcmUgaW5oZXJpdGVkIGZyb20gYEJpbmFyeWAgYXMgYG5ldmVyYCwgYXMgY29uc3VtZXJzIHNob3VsZCBub3RcbiAgICAgICAgLy8gZGVwZW5kIG9uIHRoZXNlIGZpZWxkcyB3aGVuIG9wZXJhdGluZyBvbiBgVW5hcnlgLlxuICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdW5hcnkgbWludXMgZXhwcmVzc2lvbiBcIi14XCIsIHJlcHJlc2VudGVkIGFzIGBCaW5hcnlgIHVzaW5nIFwiMCAtIHhcIi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTWludXMoc3Bhbiwgc291cmNlU3BhbiwgZXhwcikge1xuICAgICAgICByZXR1cm4gbmV3IFVuYXJ5KHNwYW4sIHNvdXJjZVNwYW4sICctJywgZXhwciwgJy0nLCBuZXcgTGl0ZXJhbFByaW1pdGl2ZShzcGFuLCBzb3VyY2VTcGFuLCAwKSwgZXhwcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB1bmFyeSBwbHVzIGV4cHJlc3Npb24gXCIreFwiLCByZXByZXNlbnRlZCBhcyBgQmluYXJ5YCB1c2luZyBcInggLSAwXCIuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVBsdXMoc3Bhbiwgc291cmNlU3BhbiwgZXhwcikge1xuICAgICAgICByZXR1cm4gbmV3IFVuYXJ5KHNwYW4sIHNvdXJjZVNwYW4sICcrJywgZXhwciwgJy0nLCBleHByLCBuZXcgTGl0ZXJhbFByaW1pdGl2ZShzcGFuLCBzb3VyY2VTcGFuLCAwKSk7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIGlmICh2aXNpdG9yLnZpc2l0VW5hcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRVbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBQcmVmaXhOb3QgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGV4cHJlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJlZml4Tm90KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIE5vbk51bGxBc3NlcnQgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGV4cHJlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Tm9uTnVsbEFzc2VydCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBDYWxsIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCByZWNlaXZlciwgYXJncywgYXJndW1lbnRTcGFuKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuYXJndW1lbnRTcGFuID0gYXJndW1lbnRTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhbGwodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWNvcmRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhIHRleHQgc3BhbiBpbiBhIHNvdXJjZSBmaWxlLCB3aGVyZSBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgdGhlXG4gKiBzdGFydGluZyBhbmQgZW5kaW5nIGJ5dGUgb2Zmc2V0cywgcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdGV4dCBzcGFuIGluIGEgc291cmNlIGZpbGUuXG4gKi9cbmNsYXNzIEFic29sdXRlU291cmNlU3BhbiB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbn1cbmNsYXNzIEFTVFdpdGhTb3VyY2UgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKGFzdCwgc291cmNlLCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGVycm9ycykge1xuICAgICAgICBzdXBlcihuZXcgUGFyc2VTcGFuKDAsIHNvdXJjZSA9PT0gbnVsbCA/IDAgOiBzb3VyY2UubGVuZ3RoKSwgbmV3IEFic29sdXRlU291cmNlU3BhbihhYnNvbHV0ZU9mZnNldCwgc291cmNlID09PSBudWxsID8gYWJzb2x1dGVPZmZzZXQgOiBhYnNvbHV0ZU9mZnNldCArIHNvdXJjZS5sZW5ndGgpKTtcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICBpZiAodmlzaXRvci52aXNpdEFTVFdpdGhTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QVNUV2l0aFNvdXJjZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5zb3VyY2V9IGluICR7dGhpcy5sb2NhdGlvbn1gO1xuICAgIH1cbn1cbmNsYXNzIFZhcmlhYmxlQmluZGluZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNvdXJjZVNwYW4gZW50aXJlIHNwYW4gb2YgdGhlIGJpbmRpbmcuXG4gICAgICogQHBhcmFtIGtleSBuYW1lIG9mIHRoZSBMSFMgYWxvbmcgd2l0aCBpdHMgc3Bhbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgb3B0aW9uYWwgdmFsdWUgZm9yIHRoZSBSSFMgYWxvbmcgd2l0aCBpdHMgc3Bhbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VTcGFuLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgRXhwcmVzc2lvbkJpbmRpbmcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuIGVudGlyZSBzcGFuIG9mIHRoZSBiaW5kaW5nLlxuICAgICAqIEBwYXJhbSBrZXkgYmluZGluZyBuYW1lLCBsaWtlIG5nRm9yT2YsIG5nRm9yVHJhY2tCeSwgbmdJZiwgYWxvbmcgd2l0aCBpdHNcbiAgICAgKiBzcGFuLiBOb3RlIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGUgc3BhbiBtYXkgbm90IGJlIHRoZSBzYW1lIGFzXG4gICAgICogYGtleS5zb3VyY2UubGVuZ3RoYC4gRm9yIGV4YW1wbGUsXG4gICAgICogMS4ga2V5LnNvdXJjZSA9IG5nRm9yLCBrZXkuc3BhbiBpcyBmb3IgXCJuZ0ZvclwiXG4gICAgICogMi4ga2V5LnNvdXJjZSA9IG5nRm9yT2YsIGtleS5zcGFuIGlzIGZvciBcIm9mXCJcbiAgICAgKiAzLiBrZXkuc291cmNlID0gbmdGb3JUcmFja0J5LCBrZXkuc3BhbiBpcyBmb3IgXCJ0cmFja0J5XCJcbiAgICAgKiBAcGFyYW0gdmFsdWUgb3B0aW9uYWwgZXhwcmVzc2lvbiBmb3IgdGhlIFJIUy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VTcGFuLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgUmVjdXJzaXZlQXN0VmlzaXRvciB7XG4gICAgdmlzaXQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3QgdmlzaXRzIGV2ZXJ5IG5vZGUuXG4gICAgICAgIC8vIENsYXNzZXMgdGhhdCBleHRlbmQgUmVjdXJzaXZlQXN0VmlzaXRvciBzaG91bGQgb3ZlcnJpZGUgdGhpcyBmdW5jdGlvblxuICAgICAgICAvLyB0byBzZWxlY3RpdmVseSB2aXNpdCB0aGUgc3BlY2lmaWVkIG5vZGUuXG4gICAgICAgIGFzdC52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRVbmFyeShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QuZXhwciwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0QmluYXJ5KGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5sZWZ0LCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmlnaHQsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdENoYWluKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0Q29uZGl0aW9uYWwoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmNvbmRpdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnRydWVFeHAsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5mYWxzZUV4cCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QuZXhwLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcihhc3QsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0VGhpc1JlY2VpdmVyKGFzdCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRJbnRlcnBvbGF0aW9uKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0S2V5ZWRSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmtleSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0S2V5ZWRXcml0ZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5rZXksIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC52YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlKGFzdCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRQcmVmaXhOb3QoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdE5vbk51bGxBc3NlcnQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdChhc3QudmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRTYWZlS2V5ZWRSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmtleSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0Q2FsbChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRRdW90ZShhc3QsIGNvbnRleHQpIHsgfVxuICAgIC8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIEFzdFZpc2l0b3IgaW50ZXJmYWNlLCBqdXN0IGEgaGVscGVyIG1ldGhvZFxuICAgIHZpc2l0QWxsKGFzdHMsIGNvbnRleHQpIHtcbiAgICAgICAgZm9yIChjb25zdCBhc3Qgb2YgYXN0cykge1xuICAgICAgICAgICAgdGhpcy52aXNpdChhc3QsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQXN0VHJhbnNmb3JtZXIge1xuICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRUaGlzUmVjZWl2ZXIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0SW50ZXJwb2xhdGlvbihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnN0cmluZ3MsIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnZhbHVlKTtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lKTtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVdyaXRlKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QubmFtZVNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIGFzdC52YWx1ZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lKTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsQXJyYXkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsTWFwKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Qua2V5cywgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKSk7XG4gICAgfVxuICAgIHZpc2l0VW5hcnkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVW5hcnkuY3JlYXRlUGx1cyhhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5leHByLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeS5jcmVhdGVNaW51cyhhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5leHByLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHVuYXJ5IG9wZXJhdG9yICR7YXN0Lm9wZXJhdG9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0QmluYXJ5KGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5vcGVyYXRpb24sIGFzdC5sZWZ0LnZpc2l0KHRoaXMpLCBhc3QucmlnaHQudmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdFByZWZpeE5vdChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhOb3QoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0Tm9uTnVsbEFzc2VydChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb25OdWxsQXNzZXJ0KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdENvbmRpdGlvbmFsKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKSwgYXN0LnRydWVFeHAudmlzaXQodGhpcyksIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUGlwZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5leHAudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSwgYXN0Lm5hbWVTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRLZXllZFJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3Qua2V5LnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgdmlzaXRLZXllZFdyaXRlKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEtleWVkV3JpdGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5rZXkudmlzaXQodGhpcyksIGFzdC52YWx1ZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0Q2FsbChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSwgYXN0LmFyZ3VtZW50U3Bhbik7XG4gICAgfVxuICAgIHZpc2l0QWxsKGFzdHMpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzW2ldID0gYXN0c1tpXS52aXNpdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICB2aXNpdENoYWluKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYWluKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9XG4gICAgdmlzaXRRdW90ZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBRdW90ZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5wcmVmaXgsIGFzdC51bmludGVycHJldGVkRXhwcmVzc2lvbiwgYXN0LmxvY2F0aW9uKTtcbiAgICB9XG4gICAgdmlzaXRTYWZlS2V5ZWRSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVLZXllZFJlYWQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5rZXkudmlzaXQodGhpcykpO1xuICAgIH1cbn1cbi8vIEEgdHJhbnNmb3JtZXIgdGhhdCBvbmx5IGNyZWF0ZXMgbmV3IG5vZGVzIGlmIHRoZSB0cmFuc2Zvcm1lciBtYWtlcyBhIGNoYW5nZSBvclxuLy8gYSBjaGFuZ2UgaXMgbWFkZSBhIGNoaWxkIG5vZGUuXG5jbGFzcyBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lciB7XG4gICAgdmlzaXRJbXBsaWNpdFJlY2VpdmVyKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFRoaXNSZWNlaXZlcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRJbnRlcnBvbGF0aW9uKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICE9PSBhc3QuZXhwcmVzc2lvbnMpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb24oYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc3RyaW5ncywgZXhwcmVzc2lvbnMpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxQcmltaXRpdmUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0UHJvcGVydHlSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBhc3QucmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCByZWNlaXZlciwgYXN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0UHJvcGVydHlXcml0ZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgIT09IGFzdC5yZWNlaXZlciB8fCB2YWx1ZSAhPT0gYXN0LnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QubmFtZVNwYW4sIHJlY2VpdmVyLCBhc3QubmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gYXN0LnJlY2VpdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNhZmVQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QubmFtZVNwYW4sIHJlY2VpdmVyLCBhc3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsQXJyYXkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMgIT09IGFzdC5leHByZXNzaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXkoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBleHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsTWFwKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWVzICE9PSBhc3QudmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Qua2V5cywgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFVuYXJ5KGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBleHByID0gYXN0LmV4cHIudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChleHByICE9PSBhc3QuZXhwcikge1xuICAgICAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFVuYXJ5LmNyZWF0ZVBsdXMoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBleHByKTtcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFVuYXJ5LmNyZWF0ZU1pbnVzKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgZXhwcik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHVuYXJ5IG9wZXJhdG9yICR7YXN0Lm9wZXJhdG9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0QmluYXJ5KGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gYXN0LmxlZnQudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gYXN0LnJpZ2h0LnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAobGVmdCAhPT0gYXN0LmxlZnQgfHwgcmlnaHQgIT09IGFzdC5yaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Qub3BlcmF0aW9uLCBsZWZ0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRQcmVmaXhOb3QoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gIT09IGFzdC5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0Tm9uTnVsbEFzc2VydChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiAhPT0gYXN0LmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9uTnVsbEFzc2VydChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGV4cHJlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0Q29uZGl0aW9uYWwoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGFzdC5jb25kaXRpb24udmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IHRydWVFeHAgPSBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3QgZmFsc2VFeHAgPSBhc3QuZmFsc2VFeHAudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChjb25kaXRpb24gIT09IGFzdC5jb25kaXRpb24gfHwgdHJ1ZUV4cCAhPT0gYXN0LnRydWVFeHAgfHwgZmFsc2VFeHAgIT09IGFzdC5mYWxzZUV4cCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZXhwID0gYXN0LmV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpO1xuICAgICAgICBpZiAoZXhwICE9PSBhc3QuZXhwIHx8IGFyZ3MgIT09IGFzdC5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdQaXBlKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgZXhwLCBhc3QubmFtZSwgYXJncywgYXN0Lm5hbWVTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdEtleWVkUmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCBrZXkgPSBhc3Qua2V5LnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAob2JqICE9PSBhc3QucmVjZWl2ZXIgfHwga2V5ICE9PSBhc3Qua2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleWVkUmVhZChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIG9iaiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdEtleWVkV3JpdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3Qga2V5ID0gYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhc3QudmFsdWUudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChvYmogIT09IGFzdC5yZWNlaXZlciB8fCBrZXkgIT09IGFzdC5rZXkgfHwgdmFsdWUgIT09IGFzdC52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXllZFdyaXRlKGFzdC5zcGFuLCBhc3Quc291cmNlU3Bhbiwgb2JqLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdEFsbChhc3RzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGFzdHNbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9yaWdpbmFsLnZpc2l0KHRoaXMpO1xuICAgICAgICAgICAgcmVzW2ldID0gdmFsdWU7XG4gICAgICAgICAgICBtb2RpZmllZCA9IG1vZGlmaWVkIHx8IHZhbHVlICE9PSBvcmlnaW5hbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kaWZpZWQgPyByZXMgOiBhc3RzO1xuICAgIH1cbiAgICB2aXNpdENoYWluKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICE9PSBhc3QuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhaW4oYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBleHByZXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRDYWxsKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgIT09IGFzdC5yZWNlaXZlciB8fCBhcmdzICE9PSBhc3QuYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgcmVjZWl2ZXIsIGFyZ3MsIGFzdC5hcmd1bWVudFNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0UXVvdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0U2FmZUtleWVkUmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCBrZXkgPSBhc3Qua2V5LnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAob2JqICE9PSBhc3QucmVjZWl2ZXIgfHwga2V5ICE9PSBhc3Qua2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNhZmVLZXllZFJlYWQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBvYmosIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG59XG4vLyBCaW5kaW5nc1xuY2xhc3MgUGFyc2VkUHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGV4cHJlc3Npb24sIHR5cGUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmtleVNwYW4gPSBrZXlTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICAgICAgdGhpcy5pc0xpdGVyYWwgPSB0aGlzLnR5cGUgPT09IFBhcnNlZFByb3BlcnR5VHlwZS5MSVRFUkFMX0FUVFI7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpb24gPSB0aGlzLnR5cGUgPT09IFBhcnNlZFByb3BlcnR5VHlwZS5BTklNQVRJT047XG4gICAgfVxufVxudmFyIFBhcnNlZFByb3BlcnR5VHlwZTtcbihmdW5jdGlvbiAoUGFyc2VkUHJvcGVydHlUeXBlKSB7XG4gICAgUGFyc2VkUHJvcGVydHlUeXBlW1BhcnNlZFByb3BlcnR5VHlwZVtcIkRFRkFVTFRcIl0gPSAwXSA9IFwiREVGQVVMVFwiO1xuICAgIFBhcnNlZFByb3BlcnR5VHlwZVtQYXJzZWRQcm9wZXJ0eVR5cGVbXCJMSVRFUkFMX0FUVFJcIl0gPSAxXSA9IFwiTElURVJBTF9BVFRSXCI7XG4gICAgUGFyc2VkUHJvcGVydHlUeXBlW1BhcnNlZFByb3BlcnR5VHlwZVtcIkFOSU1BVElPTlwiXSA9IDJdID0gXCJBTklNQVRJT05cIjtcbn0pKFBhcnNlZFByb3BlcnR5VHlwZSB8fCAoUGFyc2VkUHJvcGVydHlUeXBlID0ge30pKTtcbmNsYXNzIFBhcnNlZEV2ZW50IHtcbiAgICAvLyBSZWd1bGFyIGV2ZW50cyBoYXZlIGEgdGFyZ2V0XG4gICAgLy8gQW5pbWF0aW9uIGV2ZW50cyBoYXZlIGEgcGhhc2VcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0YXJnZXRPclBoYXNlLCB0eXBlLCBoYW5kbGVyLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3Bhbiwga2V5U3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnRhcmdldE9yUGhhc2UgPSB0YXJnZXRPclBoYXNlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmhhbmRsZXJTcGFuID0gaGFuZGxlclNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZWRWYXJpYWJsZSByZXByZXNlbnRzIGEgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gYSBtaWNyb3N5bnRheCBleHByZXNzaW9uLlxuICovXG5jbGFzcyBQYXJzZWRWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgIH1cbn1cbmNsYXNzIEJvdW5kRWxlbWVudFByb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBzZWN1cml0eUNvbnRleHQsIHZhbHVlLCB1bml0LCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zZWN1cml0eUNvbnRleHQgPSBzZWN1cml0eUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IENPUkUgPSAnQGFuZ3VsYXIvY29yZSc7XG5jbGFzcyBJZGVudGlmaWVycyB7XG59XG5JZGVudGlmaWVycy5BTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTID0ge1xuICAgIG5hbWU6ICdBTkFMWVpFX0ZPUl9FTlRSWV9DT01QT05FTlRTJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxufTtcbklkZW50aWZpZXJzLkVsZW1lbnRSZWYgPSB7IG5hbWU6ICdFbGVtZW50UmVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuTmdNb2R1bGVSZWYgPSB7IG5hbWU6ICdOZ01vZHVsZVJlZicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLlZpZXdDb250YWluZXJSZWYgPSB7IG5hbWU6ICdWaWV3Q29udGFpbmVyUmVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0b3JSZWYgPSB7XG4gICAgbmFtZTogJ0NoYW5nZURldGVjdG9yUmVmJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxufTtcbklkZW50aWZpZXJzLlF1ZXJ5TGlzdCA9IHsgbmFtZTogJ1F1ZXJ5TGlzdCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLlRlbXBsYXRlUmVmID0geyBuYW1lOiAnVGVtcGxhdGVSZWYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5SZW5kZXJlcjIgPSB7IG5hbWU6ICdSZW5kZXJlcjInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5Db2RlZ2VuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgIG5hbWU6ICfJtUNvZGVnZW5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXInLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0ge1xuICAgIG5hbWU6ICdDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXInLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuSWRlbnRpZmllcnMuQ29tcG9uZW50RmFjdG9yeSA9IHsgbmFtZTogJ0NvbXBvbmVudEZhY3RvcnknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5Db21wb25lbnRSZWYgPSB7IG5hbWU6ICdDb21wb25lbnRSZWYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5OZ01vZHVsZUZhY3RvcnkgPSB7IG5hbWU6ICdOZ01vZHVsZUZhY3RvcnknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5jcmVhdGVNb2R1bGVGYWN0b3J5ID0ge1xuICAgIG5hbWU6ICfJtWNtZicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5tb2R1bGVEZWYgPSB7XG4gICAgbmFtZTogJ8m1bW9kJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxufTtcbklkZW50aWZpZXJzLm1vZHVsZVByb3ZpZGVyRGVmID0ge1xuICAgIG5hbWU6ICfJtW1wZCcsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5SZWdpc3Rlck1vZHVsZUZhY3RvcnlGbiA9IHtcbiAgICBuYW1lOiAnybVyZWdpc3Rlck1vZHVsZUZhY3RvcnknLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuSWRlbnRpZmllcnMuaW5qZWN0ID0geyBuYW1lOiAnybXJtWluamVjdCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRpcmVjdGl2ZUluamVjdCA9IHsgbmFtZTogJ8m1ybVkaXJlY3RpdmVJbmplY3QnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5JTkpFQ1RPUiA9IHsgbmFtZTogJ0lOSkVDVE9SJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuSW5qZWN0b3IgPSB7IG5hbWU6ICdJbmplY3RvcicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLlZpZXdFbmNhcHN1bGF0aW9uID0ge1xuICAgIG5hbWU6ICdWaWV3RW5jYXBzdWxhdGlvbicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHtcbiAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3knLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuSWRlbnRpZmllcnMuU2VjdXJpdHlDb250ZXh0ID0ge1xuICAgIG5hbWU6ICdTZWN1cml0eUNvbnRleHQnLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuSWRlbnRpZmllcnMuTE9DQUxFX0lEID0geyBuYW1lOiAnTE9DQUxFX0lEJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuVFJBTlNMQVRJT05TX0ZPUk1BVCA9IHtcbiAgICBuYW1lOiAnVFJBTlNMQVRJT05TX0ZPUk1BVCcsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5pbmxpbmVJbnRlcnBvbGF0ZSA9IHtcbiAgICBuYW1lOiAnybVpbmxpbmVJbnRlcnBvbGF0ZScsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5pbnRlcnBvbGF0ZSA9IHsgbmFtZTogJ8m1aW50ZXJwb2xhdGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5FTVBUWV9BUlJBWSA9IHsgbmFtZTogJ8m1RU1QVFlfQVJSQVknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5FTVBUWV9NQVAgPSB7IG5hbWU6ICfJtUVNUFRZX01BUCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLlJlbmRlcmVyID0geyBuYW1lOiAnUmVuZGVyZXInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG4vLyB0eXBlIG9ubHlcbklkZW50aWZpZXJzLlJlbmRlcmVyVHlwZTIgPSB7XG4gICAgbmFtZTogJ1JlbmRlcmVyVHlwZTInLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuLy8gdHlwZSBvbmx5XG5JZGVudGlmaWVycy5WaWV3RGVmaW5pdGlvbiA9IHtcbiAgICBuYW1lOiAnybVWaWV3RGVmaW5pdGlvbicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5jcmVhdGVDb21wb25lbnRGYWN0b3J5ID0geyBuYW1lOiAnybVjY2YnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgRXZlbnRIYW5kbGVyVmFycyB7XG59XG5FdmVudEhhbmRsZXJWYXJzLmV2ZW50ID0gdmFyaWFibGUoJyRldmVudCcpO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBBU1QgaW50byBhbiBleGVjdXRhYmxlIG91dHB1dCBBU1QsIGFzc3VtaW5nIHRoZSBleHByZXNzaW9uIGlzXG4gKiB1c2VkIGluIGFuIGFjdGlvbiBiaW5kaW5nIChlLmcuIGFuIGV2ZW50IGhhbmRsZXIpLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0QWN0aW9uQmluZGluZyhsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBhY3Rpb24sIGJpbmRpbmdJZCwgaW50ZXJwb2xhdGlvbkZ1bmN0aW9uLCBiYXNlU291cmNlU3BhbiwgaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzLCBnbG9iYWxzKSB7XG4gICAgaWYgKCFsb2NhbFJlc29sdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIgPSBuZXcgRGVmYXVsdExvY2FsUmVzb2x2ZXIoZ2xvYmFscyk7XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbldpdGhvdXRCdWlsdGlucyA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmdCdWlsdGlucyh7XG4gICAgICAgIGNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlcjogKGFyZ0NvdW50KSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlOiBubyBjYWNoaW5nIGZvciBsaXRlcmFsIGFycmF5cyBpbiBhY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBsaXRlcmFsQXJyKGFyZ3MpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyOiAoa2V5cykgPT4ge1xuICAgICAgICAgICAgLy8gTm90ZTogbm8gY2FjaGluZyBmb3IgbGl0ZXJhbCBtYXBzIGluIGFjdGlvbnMuXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBrZXlzLm1hcCgoaywgaSkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrLmtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVkOiBrLnF1b3RlZCxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxNYXAoZW50cmllcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVQaXBlQ29udmVydGVyOiAobmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIFN0YXRlOiBBY3Rpb25zIGFyZSBub3QgYWxsb3dlZCB0byBjb250YWluIHBpcGVzLiBQaXBlOiAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICB9LCBhY3Rpb24pO1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCwgaW50ZXJwb2xhdGlvbkZ1bmN0aW9uLCBiYXNlU291cmNlU3BhbiwgaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzKTtcbiAgICBjb25zdCBhY3Rpb25TdG10cyA9IFtdO1xuICAgIGZsYXR0ZW5TdGF0ZW1lbnRzKGFjdGlvbldpdGhvdXRCdWlsdGlucy52aXNpdCh2aXNpdG9yLCBfTW9kZS5TdGF0ZW1lbnQpLCBhY3Rpb25TdG10cyk7XG4gICAgcHJlcGVuZFRlbXBvcmFyeURlY2xzKHZpc2l0b3IudGVtcG9yYXJ5Q291bnQsIGJpbmRpbmdJZCwgYWN0aW9uU3RtdHMpO1xuICAgIGlmICh2aXNpdG9yLnVzZXNJbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SW5kZXggPSBhY3Rpb25TdG10cy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBsYXN0U3RhdGVtZW50ID0gYWN0aW9uU3RtdHNbbGFzdEluZGV4XTtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IGV4cHJlc3Npb24gc3RhdGVtZW50IGlzIHJldHVybmVkXG4gICAgICAgIGlmIChsYXN0U3RhdGVtZW50IGluc3RhbmNlb2YgRXhwcmVzc2lvblN0YXRlbWVudCkge1xuICAgICAgICAgICAgYWN0aW9uU3RtdHNbbGFzdEluZGV4XSA9IG5ldyBSZXR1cm5TdGF0ZW1lbnQobGFzdFN0YXRlbWVudC5leHByKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0aW9uU3RtdHM7XG59XG5mdW5jdGlvbiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCdWlsdGlucyhjb252ZXJ0ZXJGYWN0b3J5LCBhc3QpO1xufVxuY2xhc3MgQ29udmVydFByb3BlcnR5QmluZGluZ1Jlc3VsdCB7XG4gICAgY29uc3RydWN0b3Ioc3RtdHMsIGN1cnJWYWxFeHByKSB7XG4gICAgICAgIHRoaXMuc3RtdHMgPSBzdG10cztcbiAgICAgICAgdGhpcy5jdXJyVmFsRXhwciA9IGN1cnJWYWxFeHByO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGV4cHJlc3Npb24gQVNUIGludG8gYW4gZXhlY3V0YWJsZSBvdXRwdXQgQVNULCBhc3N1bWluZyB0aGUgZXhwcmVzc2lvblxuICogaXMgdXNlZCBpbiBwcm9wZXJ0eSBiaW5kaW5nLiBUaGUgZXhwcmVzc2lvbiBoYXMgdG8gYmUgcHJlcHJvY2Vzc2VkIHZpYVxuICogYGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmdCdWlsdGluc2AuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobG9jYWxSZXNvbHZlciwgaW1wbGljaXRSZWNlaXZlciwgZXhwcmVzc2lvbldpdGhvdXRCdWlsdGlucywgYmluZGluZ0lkLCBpbnRlcnBvbGF0aW9uRnVuY3Rpb24pIHtcbiAgICBpZiAoIWxvY2FsUmVzb2x2ZXIpIHtcbiAgICAgICAgbG9jYWxSZXNvbHZlciA9IG5ldyBEZWZhdWx0TG9jYWxSZXNvbHZlcigpO1xuICAgIH1cbiAgICBjb25zdCB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBiaW5kaW5nSWQsIGludGVycG9sYXRpb25GdW5jdGlvbik7XG4gICAgY29uc3Qgb3V0cHV0RXhwciA9IGV4cHJlc3Npb25XaXRob3V0QnVpbHRpbnMudmlzaXQodmlzaXRvciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgY29uc3Qgc3RtdHMgPSBnZXRTdGF0ZW1lbnRzRnJvbVZpc2l0b3IodmlzaXRvciwgYmluZGluZ0lkKTtcbiAgICBpZiAodmlzaXRvci51c2VzSW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBDb252ZXJ0UHJvcGVydHlCaW5kaW5nUmVzdWx0KHN0bXRzLCBvdXRwdXRFeHByKTtcbn1cbi8qKlxuICogR2l2ZW4gc29tZSBleHByZXNzaW9uLCBzdWNoIGFzIGEgYmluZGluZyBvciBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb24sIGFuZCBhIGNvbnRleHQgZXhwcmVzc2lvbiB0b1xuICogbG9vayB2YWx1ZXMgdXAgb24sIHZpc2l0IGVhY2ggZmFjZXQgb2YgdGhlIGdpdmVuIGV4cHJlc3Npb24gcmVzb2x2aW5nIHZhbHVlcyBmcm9tIHRoZSBjb250ZXh0XG4gKiBleHByZXNzaW9uIHN1Y2ggdGhhdCBhIGxpc3Qgb2YgYXJndW1lbnRzIGNhbiBiZSBkZXJpdmVkIGZyb20gdGhlIGZvdW5kIHZhbHVlcyB0aGF0IGNhbiBiZSB1c2VkIGFzXG4gKiBhcmd1bWVudHMgdG8gYW4gZXh0ZXJuYWwgdXBkYXRlIGluc3RydWN0aW9uLlxuICpcbiAqIEBwYXJhbSBsb2NhbFJlc29sdmVyIFRoZSByZXNvbHZlciB0byB1c2UgdG8gbG9vayB1cCBleHByZXNzaW9ucyBieSBuYW1lIGFwcHJvcHJpYXRlbHlcbiAqIEBwYXJhbSBjb250ZXh0VmFyaWFibGVFeHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHJlcHJlc2VudGluZyB0aGUgY29udGV4dCB2YXJpYWJsZSB1c2VkIHRvIGNyZWF0ZVxuICogdGhlIGZpbmFsIGFyZ3VtZW50IGV4cHJlc3Npb25zXG4gKiBAcGFyYW0gZXhwcmVzc2lvbldpdGhBcmd1bWVudHNUb0V4dHJhY3QgVGhlIGV4cHJlc3Npb24gdG8gdmlzaXQgdG8gZmlndXJlIG91dCB3aGF0IHZhbHVlcyBuZWVkIHRvXG4gKiBiZSByZXNvbHZlZCBhbmQgd2hhdCBhcmd1bWVudHMgbGlzdCB0byBidWlsZC5cbiAqIEBwYXJhbSBiaW5kaW5nSWQgQSBuYW1lIHByZWZpeCB1c2VkIHRvIGNyZWF0ZSB0ZW1wb3JhcnkgdmFyaWFibGUgbmFtZXMgaWYgdGhleSdyZSBuZWVkZWQgZm9yIHRoZVxuICogYXJndW1lbnRzIGdlbmVyYXRlZFxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgZXhwcmVzc2lvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIGFzIGFyZ3VtZW50cyB0byBpbnN0cnVjdGlvbiBleHByZXNzaW9ucyBsaWtlXG4gKiBgby5pbXBvcnRFeHByKFIzLnByb3BlcnR5SW50ZXJwb2xhdGUpLmNhbGxGbihyZXN1bHQpYFxuICovXG5mdW5jdGlvbiBjb252ZXJ0VXBkYXRlQXJndW1lbnRzKGxvY2FsUmVzb2x2ZXIsIGNvbnRleHRWYXJpYWJsZUV4cHJlc3Npb24sIGV4cHJlc3Npb25XaXRoQXJndW1lbnRzVG9FeHRyYWN0LCBiaW5kaW5nSWQpIHtcbiAgICBjb25zdCB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBjb250ZXh0VmFyaWFibGVFeHByZXNzaW9uLCBiaW5kaW5nSWQsIHVuZGVmaW5lZCk7XG4gICAgY29uc3Qgb3V0cHV0RXhwciA9IGV4cHJlc3Npb25XaXRoQXJndW1lbnRzVG9FeHRyYWN0LnZpc2l0KHZpc2l0b3IsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgIGlmICh2aXNpdG9yLnVzZXNJbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpO1xuICAgIH1cbiAgICBjb25zdCBzdG10cyA9IGdldFN0YXRlbWVudHNGcm9tVmlzaXRvcih2aXNpdG9yLCBiaW5kaW5nSWQpO1xuICAgIC8vIFJlbW92aW5nIHRoZSBmaXJzdCBhcmd1bWVudCwgYmVjYXVzZSBpdCB3YXMgYSBsZW5ndGggZm9yIFZpZXdFbmdpbmUsIG5vdCBJdnkuXG4gICAgbGV0IGFyZ3MgPSBvdXRwdXRFeHByLmFyZ3Muc2xpY2UoMSk7XG4gICAgaWYgKGV4cHJlc3Npb25XaXRoQXJndW1lbnRzVG9FeHRyYWN0IGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAvLyBJZiB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gaW50ZXJwb2xhdGlvbiBvZiAxIHZhbHVlIHdpdGggYW4gZW1wdHkgcHJlZml4IGFuZCBzdWZmaXgsIHJlZHVjZSB0aGVcbiAgICAgICAgLy8gYXJncyByZXR1cm5lZCB0byBqdXN0IHRoZSB2YWx1ZSwgYmVjYXVzZSB3ZSdyZSBnb2luZyB0byBwYXNzIGl0IHRvIGEgc3BlY2lhbCBpbnN0cnVjdGlvbi5cbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IGV4cHJlc3Npb25XaXRoQXJndW1lbnRzVG9FeHRyYWN0LnN0cmluZ3M7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMyAmJiBzdHJpbmdzWzBdID09PSAnJyAmJiBzdHJpbmdzWzFdID09PSAnJykge1xuICAgICAgICAgICAgLy8gU2luZ2xlIGFyZ3VtZW50IGludGVycG9sYXRlIGluc3RydWN0aW9ucy5cbiAgICAgICAgICAgIGFyZ3MgPSBbYXJnc1sxXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPj0gMTkpIHtcbiAgICAgICAgICAgIC8vIDE5IG9yIG1vcmUgYXJndW1lbnRzIG11c3QgYmUgcGFzc2VkIHRvIHRoZSBgaW50ZXJwb2xhdGVWYC1zdHlsZSBpbnN0cnVjdGlvbnMsIHdoaWNoIGFjY2VwdFxuICAgICAgICAgICAgLy8gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICAgICAgICBhcmdzID0gW2xpdGVyYWxBcnIoYXJncyldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN0bXRzLCBhcmdzIH07XG59XG5mdW5jdGlvbiBnZXRTdGF0ZW1lbnRzRnJvbVZpc2l0b3IodmlzaXRvciwgYmluZGluZ0lkKSB7XG4gICAgY29uc3Qgc3RtdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2l0b3IudGVtcG9yYXJ5Q291bnQ7IGkrKykge1xuICAgICAgICBzdG10cy5wdXNoKHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJZCwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RtdHM7XG59XG5mdW5jdGlvbiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBfQnVpbHRpbkFzdENvbnZlcnRlcihjb252ZXJ0ZXJGYWN0b3J5KTtcbiAgICByZXR1cm4gYXN0LnZpc2l0KHZpc2l0b3IpO1xufVxuZnVuY3Rpb24gdGVtcG9yYXJ5TmFtZShiaW5kaW5nSWQsIHRlbXBvcmFyeU51bWJlcikge1xuICAgIHJldHVybiBgdG1wXyR7YmluZGluZ0lkfV8ke3RlbXBvcmFyeU51bWJlcn1gO1xufVxuZnVuY3Rpb24gdGVtcG9yYXJ5RGVjbGFyYXRpb24oYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHRlbXBvcmFyeU5hbWUoYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpKTtcbn1cbmZ1bmN0aW9uIHByZXBlbmRUZW1wb3JhcnlEZWNscyh0ZW1wb3JhcnlDb3VudCwgYmluZGluZ0lkLCBzdGF0ZW1lbnRzKSB7XG4gICAgZm9yIChsZXQgaSA9IHRlbXBvcmFyeUNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgc3RhdGVtZW50cy51bnNoaWZ0KHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJZCwgaSkpO1xuICAgIH1cbn1cbnZhciBfTW9kZTtcbihmdW5jdGlvbiAoX01vZGUpIHtcbiAgICBfTW9kZVtfTW9kZVtcIlN0YXRlbWVudFwiXSA9IDBdID0gXCJTdGF0ZW1lbnRcIjtcbiAgICBfTW9kZVtfTW9kZVtcIkV4cHJlc3Npb25cIl0gPSAxXSA9IFwiRXhwcmVzc2lvblwiO1xufSkoX01vZGUgfHwgKF9Nb2RlID0ge30pKTtcbmZ1bmN0aW9uIGVuc3VyZVN0YXRlbWVudE1vZGUobW9kZSwgYXN0KSB7XG4gICAgaWYgKG1vZGUgIT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgc3RhdGVtZW50LCBidXQgc2F3ICR7YXN0fWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCkge1xuICAgIGlmIChtb2RlICE9PSBfTW9kZS5FeHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYW4gZXhwcmVzc2lvbiwgYnV0IHNhdyAke2FzdH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBleHByKSB7XG4gICAgaWYgKG1vZGUgPT09IF9Nb2RlLlN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gZXhwci50b1N0bXQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbn1cbmNsYXNzIF9CdWlsdGluQXN0Q29udmVydGVyIGV4dGVuZHMgQXN0VHJhbnNmb3JtZXIge1xuICAgIGNvbnN0cnVjdG9yKF9jb252ZXJ0ZXJGYWN0b3J5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkgPSBfY29udmVydGVyRmFjdG9yeTtcbiAgICB9XG4gICAgdmlzaXRQaXBlKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBhcmdzID0gW2FzdC5leHAsIC4uLmFzdC5hcmdzXS5tYXAoYXN0ID0+IGFzdC52aXNpdCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICAgIHJldHVybiBuZXcgQnVpbHRpbkZ1bmN0aW9uQ2FsbChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFyZ3MsIHRoaXMuX2NvbnZlcnRlckZhY3RvcnkuY3JlYXRlUGlwZUNvbnZlcnRlcihhc3QubmFtZSwgYXJncy5sZW5ndGgpKTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsQXJyYXkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBhc3QuZXhwcmVzc2lvbnMubWFwKGFzdCA9PiBhc3QudmlzaXQodGhpcywgY29udGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhcmdzLCB0aGlzLl9jb252ZXJ0ZXJGYWN0b3J5LmNyZWF0ZUxpdGVyYWxBcnJheUNvbnZlcnRlcihhc3QuZXhwcmVzc2lvbnMubGVuZ3RoKSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGFzdC52YWx1ZXMubWFwKGFzdCA9PiBhc3QudmlzaXQodGhpcywgY29udGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhcmdzLCB0aGlzLl9jb252ZXJ0ZXJGYWN0b3J5LmNyZWF0ZUxpdGVyYWxNYXBDb252ZXJ0ZXIoYXN0LmtleXMpKTtcbiAgICB9XG59XG5jbGFzcyBfQXN0VG9JclZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKF9sb2NhbFJlc29sdmVyLCBfaW1wbGljaXRSZWNlaXZlciwgYmluZGluZ0lkLCBpbnRlcnBvbGF0aW9uRnVuY3Rpb24sIGJhc2VTb3VyY2VTcGFuLCBpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxSZXNvbHZlciA9IF9sb2NhbFJlc29sdmVyO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyID0gX2ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuYmluZGluZ0lkID0gYmluZGluZ0lkO1xuICAgICAgICB0aGlzLmludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVycG9sYXRpb25GdW5jdGlvbjtcbiAgICAgICAgdGhpcy5iYXNlU291cmNlU3BhbiA9IGJhc2VTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmltcGxpY2l0UmVjZWl2ZXJBY2Nlc3NlcyA9IGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3NlcztcbiAgICAgICAgdGhpcy5fbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVzdWx0TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5ID0gMDtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRVbmFyeShhc3QsIG1vZGUpIHtcbiAgICAgICAgbGV0IG9wO1xuICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgb3AgPSBVbmFyeU9wZXJhdG9yLlBsdXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICBvcCA9IFVuYXJ5T3BlcmF0b3IuTWludXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3BlcmF0b3IgJHthc3Qub3BlcmF0b3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5ldyBVbmFyeU9wZXJhdG9yRXhwcihvcCwgdGhpcy5fdmlzaXQoYXN0LmV4cHIsIF9Nb2RlLkV4cHJlc3Npb24pLCB1bmRlZmluZWQsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKSk7XG4gICAgfVxuICAgIHZpc2l0QmluYXJ5KGFzdCwgbW9kZSkge1xuICAgICAgICBsZXQgb3A7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5QbHVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5NaW51cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkRpdmlkZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTW9kdWxvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQW5kO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnfHwnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuT3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5FcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTG93ZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPz8nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnROdWxsaXNoQ29hbGVzY2UoYXN0LCBtb2RlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRpb24gJHthc3Qub3BlcmF0aW9ufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKG9wLCB0aGlzLl92aXNpdChhc3QubGVmdCwgX01vZGUuRXhwcmVzc2lvbiksIHRoaXMuX3Zpc2l0KGFzdC5yaWdodCwgX01vZGUuRXhwcmVzc2lvbiksIHVuZGVmaW5lZCwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpKTtcbiAgICB9XG4gICAgdmlzaXRDaGFpbihhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlU3RhdGVtZW50TW9kZShtb2RlLCBhc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIG1vZGUpO1xuICAgIH1cbiAgICB2aXNpdENvbmRpdGlvbmFsKGFzdCwgbW9kZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3Zpc2l0KGFzdC5jb25kaXRpb24sIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdmFsdWUuY29uZGl0aW9uYWwodGhpcy5fdmlzaXQoYXN0LnRydWVFeHAsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLl92aXNpdChhc3QuZmFsc2VFeHAsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLmNvbnZlcnRTb3VyY2VTcGFuKGFzdC5zcGFuKSkpO1xuICAgIH1cbiAgICB2aXNpdFBpcGUoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBzdGF0ZTogUGlwZXMgc2hvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBmdW5jdGlvbnMuIFBpcGU6ICR7YXN0Lm5hbWV9YCk7XG4gICAgfVxuICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcihhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgdGhpcy51c2VzSW1wbGljaXRSZWNlaXZlciA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyO1xuICAgIH1cbiAgICB2aXNpdFRoaXNSZWNlaXZlcihhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRJbXBsaWNpdFJlY2VpdmVyKGFzdCwgbW9kZSk7XG4gICAgfVxuICAgIHZpc2l0SW50ZXJwb2xhdGlvbihhc3QsIG1vZGUpIHtcbiAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgY29uc3QgYXJncyA9IFtsaXRlcmFsKGFzdC5leHByZXNzaW9ucy5sZW5ndGgpXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3Quc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2ldKSk7XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5fdmlzaXQoYXN0LmV4cHJlc3Npb25zW2ldLCBfTW9kZS5FeHByZXNzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKGxpdGVyYWwoYXN0LnN0cmluZ3NbYXN0LnN0cmluZ3MubGVuZ3RoIC0gMV0pKTtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnBvbGF0aW9uRnVuY3Rpb24oYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdC5leHByZXNzaW9ucy5sZW5ndGggPD0gOSA/XG4gICAgICAgICAgICBpbXBvcnRFeHByKElkZW50aWZpZXJzLmlubGluZUludGVycG9sYXRlKS5jYWxsRm4oYXJncykgOlxuICAgICAgICAgICAgaW1wb3J0RXhwcihJZGVudGlmaWVycy5pbnRlcnBvbGF0ZSkuY2FsbEZuKFtcbiAgICAgICAgICAgICAgICBhcmdzWzBdLCBsaXRlcmFsQXJyKGFyZ3Muc2xpY2UoMSksIHVuZGVmaW5lZCwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpXG4gICAgICAgICAgICBdKTtcbiAgICB9XG4gICAgdmlzaXRLZXllZFJlYWQoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy5fdmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKS5rZXkodGhpcy5fdmlzaXQoYXN0LmtleSwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEtleWVkV3JpdGUoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Zpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuX3Zpc2l0KGFzdC5rZXksIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3Zpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChvYmogPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsUmVzb2x2ZXIubWF5YmVSZXN0b3JlVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBvYmoua2V5KGtleSkuc2V0KHZhbHVlKSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgU3RhdGU6IGxpdGVyYWwgYXJyYXlzIHNob3VsZCBoYXZlIGJlZW4gY29udmVydGVkIGludG8gZnVuY3Rpb25zYCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIFN0YXRlOiBsaXRlcmFsIG1hcHMgc2hvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBmdW5jdGlvbnNgKTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlKGFzdCwgbW9kZSkge1xuICAgICAgICAvLyBGb3IgbGl0ZXJhbCB2YWx1ZXMgb2YgbnVsbCwgdW5kZWZpbmVkLCB0cnVlLCBvciBmYWxzZSBhbGxvdyB0eXBlIGludGVyZmVyZW5jZVxuICAgICAgICAvLyB0byBpbmZlciB0aGUgdHlwZS5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFzdC52YWx1ZSA9PT0gbnVsbCB8fCBhc3QudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBhc3QudmFsdWUgPT09IHRydWUgfHwgYXN0LnZhbHVlID09PSB0cnVlID9cbiAgICAgICAgICAgIElORkVSUkVEX1RZUEUgOlxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbGl0ZXJhbChhc3QudmFsdWUsIHR5cGUsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKSk7XG4gICAgfVxuICAgIF9nZXRMb2NhbChuYW1lLCByZWNlaXZlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5fbG9jYWxSZXNvbHZlci5nbG9iYWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzKG5hbWUpKSAmJiByZWNlaXZlciBpbnN0YW5jZW9mIFRoaXNSZWNlaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsUmVzb2x2ZXIuZ2V0TG9jYWwobmFtZSk7XG4gICAgfVxuICAgIHZpc2l0UHJlZml4Tm90KGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbm90KHRoaXMuX3Zpc2l0KGFzdC5leHByZXNzaW9uLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH1cbiAgICB2aXNpdE5vbk51bGxBc3NlcnQoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0aGlzLl92aXNpdChhc3QuZXhwcmVzc2lvbiwgX01vZGUuRXhwcmVzc2lvbikpO1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcHJldlVzZXNJbXBsaWNpdFJlY2VpdmVyID0gdGhpcy51c2VzSW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVyID0gdGhpcy5fdmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PT0gdGhpcy5faW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lLCBhc3QucmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgXCJ1c2VzSW1wbGljaXRSZWNlaXZlclwiIHN0YXRlIHNpbmNlIHRoZSBpbXBsaWNpdFxuICAgICAgICAgICAgICAgICAgICAvLyByZWNlaXZlciBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGEgcmVzb2x2ZWQgbG9jYWwgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VzSW1wbGljaXRSZWNlaXZlciA9IHByZXZVc2VzSW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJbXBsaWNpdFJlY2VpdmVyQWNjZXNzKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZWNlaXZlci5wcm9wKGFzdC5uYW1lLCB0aGlzLmNvbnZlcnRTb3VyY2VTcGFuKGFzdC5zcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVyID0gdGhpcy5fdmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgY29uc3QgcHJldlVzZXNJbXBsaWNpdFJlY2VpdmVyID0gdGhpcy51c2VzSW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgbGV0IHZhckV4cHIgPSBudWxsO1xuICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsRXhwciA9IHRoaXMuX2dldExvY2FsKGFzdC5uYW1lLCBhc3QucmVjZWl2ZXIpO1xuICAgICAgICAgICAgaWYgKGxvY2FsRXhwcikge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEV4cHIgaW5zdGFuY2VvZiBSZWFkUHJvcEV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxvY2FsIHZhcmlhYmxlIGlzIGEgcHJvcGVydHkgcmVhZCBleHByZXNzaW9uLCBpdCdzIGEgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGEgJ2NvbnRleHQucHJvcGVydHknIHZhbHVlIGFuZCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRhcmdldCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGUgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgdmFyRXhwciA9IGxvY2FsRXhwcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgXCJ1c2VzSW1wbGljaXRSZWNlaXZlclwiIHN0YXRlIHNpbmNlIHRoZSBpbXBsaWNpdFxuICAgICAgICAgICAgICAgICAgICAvLyByZWNlaXZlciBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGEgcmVzb2x2ZWQgbG9jYWwgZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VzSW1wbGljaXRSZWNlaXZlciA9IHByZXZVc2VzSW1wbGljaXRSZWNlaXZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJbXBsaWNpdFJlY2VpdmVyQWNjZXNzKGFzdC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCdzIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXZlciA9IGFzdC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChhc3QudmFsdWUgaW5zdGFuY2VvZiBQcm9wZXJ0eVJlYWQpID8gYXN0LnZhbHVlLm5hbWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFzc2lnbiB2YWx1ZSBcIiR7dmFsdWV9XCIgdG8gdGVtcGxhdGUgdmFyaWFibGUgXCIke3JlY2VpdmVyfVwiLiBUZW1wbGF0ZSB2YXJpYWJsZXMgYXJlIHJlYWQtb25seS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gbG9jYWwgZXhwcmVzc2lvbiBjb3VsZCBiZSBwcm9kdWNlZCwgdXNlIHRoZSBvcmlnaW5hbCByZWNlaXZlcidzXG4gICAgICAgIC8vIHByb3BlcnR5IGFzIHRoZSB0YXJnZXQuXG4gICAgICAgIGlmICh2YXJFeHByID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXJFeHByID0gcmVjZWl2ZXIucHJvcChhc3QubmFtZSwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB2YXJFeHByLnNldCh0aGlzLl92aXNpdChhc3QudmFsdWUsIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgfVxuICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KSwgbW9kZSk7XG4gICAgfVxuICAgIHZpc2l0U2FmZUtleWVkUmVhZChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KSwgbW9kZSk7XG4gICAgfVxuICAgIHZpc2l0QWxsKGFzdHMsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGFzdHMubWFwKGFzdCA9PiB0aGlzLl92aXNpdChhc3QsIG1vZGUpKTtcbiAgICB9XG4gICAgdmlzaXRRdW90ZShhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBRdW90ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGV2YWx1YXRpb24hXG4gICAgICAgIFN0YXRlbWVudDogJHthc3QudW5pbnRlcnByZXRlZEV4cHJlc3Npb259IGxvY2F0ZWQgYXQgJHthc3QubG9jYXRpb259YCk7XG4gICAgfVxuICAgIHZpc2l0Q2FsbChhc3QsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRBcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBCdWlsdGluRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgYXN0LmNvbnZlcnRlcihjb252ZXJ0ZWRBcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXI7XG4gICAgICAgIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3BlcnR5UmVhZCAmJlxuICAgICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZXIgaW5zdGFuY2VvZiBJbXBsaWNpdFJlY2VpdmVyICYmXG4gICAgICAgICAgICAhKHJlY2VpdmVyLnJlY2VpdmVyIGluc3RhbmNlb2YgVGhpc1JlY2VpdmVyKSAmJiByZWNlaXZlci5uYW1lID09PSAnJGFueScpIHtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0ZWRBcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjYWxsIHRvICRhbnksIGV4cGVjdGVkIDEgYXJndW1lbnQgYnV0IHJlY2VpdmVkICR7Y29udmVydGVkQXJncy5sZW5ndGggfHwgJ25vbmUnfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGNvbnZlcnRlZEFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzLl92aXNpdChyZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbilcbiAgICAgICAgICAgIC5jYWxsRm4oY29udmVydGVkQXJncywgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY2FsbCk7XG4gICAgfVxuICAgIF92aXNpdChhc3QsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcmVzdWx0TWFwLmdldChhc3QpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodGhpcywgbW9kZSk7XG4gICAgfVxuICAgIGNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKSB7XG4gICAgICAgIC8vIElmIHRoZSBleHByZXNzaW9uIGNvbnRhaW5zIGEgc2FmZSBhY2Nlc3Mgbm9kZSBvbiB0aGUgbGVmdCBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG9cbiAgICAgICAgLy8gYW4gZXhwcmVzc2lvbiB0aGF0IGd1YXJkcyB0aGUgYWNjZXNzIHRvIHRoZSBtZW1iZXIgYnkgY2hlY2tpbmcgdGhlIHJlY2VpdmVyIGZvciBibGFuay4gQXNcbiAgICAgICAgLy8gZXhlY3V0aW9uIHByb2NlZWRzIGZyb20gbGVmdCB0byByaWdodCwgdGhlIGxlZnQgbW9zdCBwYXJ0IG9mIHRoZSBleHByZXNzaW9uIG11c3QgYmUgZ3VhcmRlZFxuICAgICAgICAvLyBmaXJzdCBidXQsIGJlY2F1c2UgbWVtYmVyIGFjY2VzcyBpcyBsZWZ0IGFzc29jaWF0aXZlLCB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZXhwcmVzc2lvbiBpcyBhdFxuICAgICAgICAvLyB0aGUgdG9wIG9mIHRoZSBBU1QuIFRoZSBkZXNpcmVkIHJlc3VsdCByZXF1aXJlcyBsaWZ0aW5nIGEgY29weSBvZiB0aGUgbGVmdCBwYXJ0IG9mIHRoZVxuICAgICAgICAvLyBleHByZXNzaW9uIHVwIHRvIHRlc3QgaXQgZm9yIGJsYW5rIGJlZm9yZSBnZW5lcmF0aW5nIHRoZSB1bmd1YXJkZWQgdmVyc2lvbi5cbiAgICAgICAgLy8gQ29uc2lkZXIsIGZvciBleGFtcGxlIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbjogYT8uYi5jPy5kLmVcbiAgICAgICAgLy8gVGhpcyByZXN1bHRzIGluIHRoZSBhc3Q6XG4gICAgICAgIC8vICAgICAgICAgLlxuICAgICAgICAvLyAgICAgICAgLyBcXFxuICAgICAgICAvLyAgICAgICA/LiAgIGVcbiAgICAgICAgLy8gICAgICAvICBcXFxuICAgICAgICAvLyAgICAgLiAgICBkXG4gICAgICAgIC8vICAgIC8gXFxcbiAgICAgICAgLy8gICA/LiAgY1xuICAgICAgICAvLyAgLyAgXFxcbiAgICAgICAgLy8gYSAgICBiXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHJlZSBzaG91bGQgYmUgZ2VuZXJhdGVkOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgLy0tLS0gPyAtLS0tXFxcbiAgICAgICAgLy8gICAgICAgLyAgICAgIHwgICAgICBcXFxuICAgICAgICAvLyAgICAgYSAgIC8tLS0gPyAtLS1cXCAgbnVsbFxuICAgICAgICAvLyAgICAgICAgLyAgICAgfCAgICAgXFxcbiAgICAgICAgLy8gICAgICAgLiAgICAgIC4gICAgIG51bGxcbiAgICAgICAgLy8gICAgICAvIFxcICAgIC8gXFxcbiAgICAgICAgLy8gICAgIC4gIGMgICAuICAgZVxuICAgICAgICAvLyAgICAvIFxcICAgIC8gXFxcbiAgICAgICAgLy8gICBhICAgYiAgLiAgIGRcbiAgICAgICAgLy8gICAgICAgICAvIFxcXG4gICAgICAgIC8vICAgICAgICAuICAgY1xuICAgICAgICAvLyAgICAgICAvIFxcXG4gICAgICAgIC8vICAgICAgYSAgIGJcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90aWNlIHRoYXQgdGhlIGZpcnN0IGd1YXJkIGNvbmRpdGlvbiBpcyB0aGUgbGVmdCBoYW5kIG9mIHRoZSBsZWZ0IG1vc3Qgc2FmZSBhY2Nlc3Mgbm9kZVxuICAgICAgICAvLyB3aGljaCBjb21lcyBpbiBhcyBsZWZ0TW9zdFNhZmUgdG8gdGhpcyByb3V0aW5lLlxuICAgICAgICBsZXQgZ3VhcmRlZEV4cHJlc3Npb24gPSB0aGlzLl92aXNpdChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICBsZXQgdGVtcG9yYXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5uZWVkc1RlbXBvcmFyeUluU2FmZUFjY2VzcyhsZWZ0TW9zdFNhZmUucmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBoYXMgbWV0aG9kIGNhbGxzIG9yIHBpcGVzIHRoZW4gd2UgbmVlZCB0byBzYXZlIHRoZSByZXN1bHQgaW50byBhXG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFyaWFibGUgdG8gYXZvaWQgY2FsbGluZyBzdGF0ZWZ1bCBvciBpbXB1cmUgY29kZSBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgICAgIHRlbXBvcmFyeSA9IHRoaXMuYWxsb2NhdGVUZW1wb3JhcnkoKTtcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSByZXN1bHQgaW4gdGhlIHRlbXBvcmFyeSB2YXJpYWJsZVxuICAgICAgICAgICAgZ3VhcmRlZEV4cHJlc3Npb24gPSB0ZW1wb3Jhcnkuc2V0KGd1YXJkZWRFeHByZXNzaW9uKTtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgZnVydGhlciByZWZlcmVuY2VzIHRvIHRoZSBndWFyZGVkIGV4cHJlc3Npb24gcmVmZXIgdG8gdGhlIHRlbXBvcmFyeSBpbnN0ZWFkLlxuICAgICAgICAgICAgdGhpcy5fcmVzdWx0TWFwLnNldChsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIHRlbXBvcmFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZGl0aW9uID0gZ3VhcmRlZEV4cHJlc3Npb24uaXNCbGFuaygpO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBhc3QgdG8gYW4gdW5ndWFyZGVkIGFjY2VzcyB0byB0aGUgcmVjZWl2ZXIncyBtZW1iZXIuIFRoZSBtYXAgd2lsbCBzdWJzdGl0dXRlXG4gICAgICAgIC8vIGxlZnRNb3N0Tm9kZSB3aXRoIGl0cyB1bmd1YXJkZWQgdmVyc2lvbiBpbiB0aGUgY2FsbCB0byBgdGhpcy52aXNpdCgpYC5cbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSBpbnN0YW5jZW9mIFNhZmVLZXllZFJlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVNYXAuc2V0KGxlZnRNb3N0U2FmZSwgbmV3IEtleWVkUmVhZChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnNvdXJjZVNwYW4sIGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgbGVmdE1vc3RTYWZlLmtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgUHJvcGVydHlSZWFkKGxlZnRNb3N0U2FmZS5zcGFuLCBsZWZ0TW9zdFNhZmUuc291cmNlU3BhbiwgbGVmdE1vc3RTYWZlLm5hbWVTcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB0aGUgbm9kZSBub3cgd2l0aG91dCB0aGUgZ3VhcmRlZCBtZW1iZXIgYWNjZXNzLlxuICAgICAgICBjb25zdCBhY2Nlc3MgPSB0aGlzLl92aXNpdChhc3QsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG1hcHBpbmcuIFRoaXMgaXMgbm90IHN0cmljdGx5IHJlcXVpcmVkIGFzIHRoZSBjb252ZXJ0ZXIgb25seSB0cmF2ZXJzZXMgZWFjaCBub2RlXG4gICAgICAgIC8vIG9uY2UgYnV0IGlzIHNhZmVyIGlmIHRoZSBjb252ZXJzaW9uIGlzIGNoYW5nZWQgdG8gdHJhdmVyc2UgdGhlIG5vZGVzIG1vcmUgdGhhbiBvbmNlLlxuICAgICAgICB0aGlzLl9ub2RlTWFwLmRlbGV0ZShsZWZ0TW9zdFNhZmUpO1xuICAgICAgICAvLyBJZiB3ZSBhbGxvY2F0ZWQgYSB0ZW1wb3JhcnksIHJlbGVhc2UgaXQuXG4gICAgICAgIGlmICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZVRlbXBvcmFyeSh0ZW1wb3JhcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2R1Y2UgdGhlIGNvbmRpdGlvbmFsXG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBjb25kaXRpb24uY29uZGl0aW9uYWwoTlVMTF9FWFBSLCBhY2Nlc3MpKTtcbiAgICB9XG4gICAgY29udmVydE51bGxpc2hDb2FsZXNjZShhc3QsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMuX3Zpc2l0KGFzdC5sZWZ0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLl92aXNpdChhc3QucmlnaHQsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICBjb25zdCB0ZW1wb3JhcnkgPSB0aGlzLmFsbG9jYXRlVGVtcG9yYXJ5KCk7XG4gICAgICAgIHRoaXMucmVsZWFzZVRlbXBvcmFyeSh0ZW1wb3JhcnkpO1xuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb24uIEl0IGlzIGlkZW50aWNhbCB0byBob3cgVFNcbiAgICAgICAgLy8gdHJhbnNwaWxlcyBiaW5hcnkgZXhwcmVzc2lvbnMgd2l0aCBhIG51bGxpc2ggY29hbGVzY2luZyBvcGVyYXRvci5cbiAgICAgICAgLy8gbGV0IHRlbXA7XG4gICAgICAgIC8vICh0ZW1wID0gYSkgIT09IG51bGwgJiYgdGVtcCAhPT0gdW5kZWZpbmVkID8gdGVtcCA6IGI7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB0ZW1wb3Jhcnkuc2V0KGxlZnQpXG4gICAgICAgICAgICAubm90SWRlbnRpY2FsKE5VTExfRVhQUilcbiAgICAgICAgICAgIC5hbmQodGVtcG9yYXJ5Lm5vdElkZW50aWNhbChsaXRlcmFsKHVuZGVmaW5lZCkpKVxuICAgICAgICAgICAgLmNvbmRpdGlvbmFsKHRlbXBvcmFyeSwgcmlnaHQpKTtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYW4gZXhwcmVzc2lvbiBvZiB0aGUgZm9ybSBhPy5iLmM/LmQuZSB0aGVuIHRoZSBsZWZ0IG1vc3Qgc2FmZSBub2RlIGlzXG4gICAgLy8gdGhlIChhPy5iKS4gVGhlIC4gYW5kID8uIGFyZSBsZWZ0IGFzc29jaWF0aXZlIHRodXMgY2FuIGJlIHJld3JpdHRlbiBhczpcbiAgICAvLyAoKCgoYT8uYykuYikuYyk/LmQpLmUuIFRoaXMgcmV0dXJucyB0aGUgbW9zdCBkZWVwbHkgbmVzdGVkIHNhZmUgcmVhZCBvclxuICAgIC8vIHNhZmUgbWV0aG9kIGNhbGwgYXMgdGhpcyBuZWVkcyB0byBiZSB0cmFuc2Zvcm1lZCBpbml0aWFsbHkgdG86XG4gICAgLy8gICBhID09IG51bGwgPyBudWxsIDogYS5jLmIuYz8uZC5lXG4gICAgLy8gdGhlbiB0bzpcbiAgICAvLyAgIGEgPT0gbnVsbCA/IG51bGwgOiBhLmIuYyA9PSBudWxsID8gbnVsbCA6IGEuYi5jLmQuZVxuICAgIGxlZnRNb3N0U2FmZU5vZGUoYXN0KSB7XG4gICAgICAgIGNvbnN0IHZpc2l0ID0gKHZpc2l0b3IsIGFzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhc3QudmlzaXQoe1xuICAgICAgICAgICAgdmlzaXRVbmFyeShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEJpbmFyeShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdENoYWluKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWwoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRDYWxsKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcihhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFRoaXNSZWNlaXZlcihhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEludGVycG9sYXRpb24oYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRLZXllZFJlYWQoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRLZXllZFdyaXRlKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxQcmltaXRpdmUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRQaXBlKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0UHJlZml4Tm90KGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Tm9uTnVsbEFzc2VydChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRRdW90ZShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0U2FmZUtleWVkUmVhZChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKSB8fCBhc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRydWUgb2YgdGhlIEFTVCBpbmNsdWRlcyBhIG1ldGhvZCBvciBhIHBpcGUgaW5kaWNhdGluZyB0aGF0LCBpZiB0aGVcbiAgICAvLyBleHByZXNzaW9uIGlzIHVzZWQgYXMgdGhlIHRhcmdldCBvZiBhIHNhZmUgcHJvcGVydHkgb3IgbWV0aG9kIGFjY2VzcyB0aGVuXG4gICAgLy8gdGhlIGV4cHJlc3Npb24gc2hvdWxkIGJlIHN0b3JlZCBpbnRvIGEgdGVtcG9yYXJ5IHZhcmlhYmxlLlxuICAgIG5lZWRzVGVtcG9yYXJ5SW5TYWZlQWNjZXNzKGFzdCkge1xuICAgICAgICBjb25zdCB2aXNpdCA9ICh2aXNpdG9yLCBhc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhc3QgJiYgKHRoaXMuX25vZGVNYXAuZ2V0KGFzdCkgfHwgYXN0KS52aXNpdCh2aXNpdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmlzaXRTb21lID0gKHZpc2l0b3IsIGFzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFzdC5zb21lKGFzdCA9PiB2aXNpdCh2aXNpdG9yLCBhc3QpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFzdC52aXNpdCh7XG4gICAgICAgICAgICB2aXNpdFVuYXJ5KGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QuZXhwcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRCaW5hcnkoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5sZWZ0KSB8fCB2aXNpdCh0aGlzLCBhc3QucmlnaHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Q2hhaW4oYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Q29uZGl0aW9uYWwoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5jb25kaXRpb24pIHx8IHZpc2l0KHRoaXMsIGFzdC50cnVlRXhwKSB8fCB2aXNpdCh0aGlzLCBhc3QuZmFsc2VFeHApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Q2FsbChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXIoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0VGhpc1JlY2VpdmVyKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEludGVycG9sYXRpb24oYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0U29tZSh0aGlzLCBhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEtleWVkV3JpdGUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxQcmltaXRpdmUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0UGlwZShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Tm9uTnVsbEFzc2VydChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0UXVvdGUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRTYWZlS2V5ZWRSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFsbG9jYXRlVGVtcG9yYXJ5KCkge1xuICAgICAgICBjb25zdCB0ZW1wTnVtYmVyID0gdGhpcy5fY3VycmVudFRlbXBvcmFyeSsrO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gTWF0aC5tYXgodGhpcy5fY3VycmVudFRlbXBvcmFyeSwgdGhpcy50ZW1wb3JhcnlDb3VudCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIodGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGVtcE51bWJlcikpO1xuICAgIH1cbiAgICByZWxlYXNlVGVtcG9yYXJ5KHRlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5LS07XG4gICAgICAgIGlmICh0ZW1wb3JhcnkubmFtZSAhPSB0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW1wb3JhcnkgJHt0ZW1wb3JhcnkubmFtZX0gcmVsZWFzZWQgb3V0IG9mIG9yZGVyYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhYnNvbHV0ZSBgUGFyc2VTb3VyY2VTcGFuYCBmcm9tIHRoZSByZWxhdGl2ZSBgUGFyc2VTcGFuYC5cbiAgICAgKlxuICAgICAqIGBQYXJzZVNwYW5gIG9iamVjdHMgYXJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgZXhwcmVzc2lvbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBjb252ZXJ0cyB0aGVzZSB0byBmdWxsIGBQYXJzZVNvdXJjZVNwYW5gIG9iamVjdHMgdGhhdFxuICAgICAqIHNob3cgd2hlcmUgdGhlIHNwYW4gaXMgd2l0aGluIHRoZSBvdmVyYWxsIHNvdXJjZSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNwYW4gdGhlIHJlbGF0aXZlIHNwYW4gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyBhIGBQYXJzZVNvdXJjZVNwYW5gIGZvciB0aGUgZ2l2ZW4gc3BhbiBvciBudWxsIGlmIG5vXG4gICAgICogYGJhc2VTb3VyY2VTcGFuYCB3YXMgcHJvdmlkZWQgdG8gdGhpcyBjbGFzcy5cbiAgICAgKi9cbiAgICBjb252ZXJ0U291cmNlU3BhbihzcGFuKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuYmFzZVNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KHNwYW4uc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5iYXNlU291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoc3Bhbi5lbmQpO1xuICAgICAgICAgICAgY29uc3QgZnVsbFN0YXJ0ID0gdGhpcy5iYXNlU291cmNlU3Bhbi5mdWxsU3RhcnQubW92ZUJ5KHNwYW4uc3RhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnQsIGVuZCwgZnVsbFN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBBZGRzIHRoZSBuYW1lIG9mIGFuIEFTVCB0byB0aGUgbGlzdCBvZiBpbXBsaWNpdCByZWNlaXZlciBhY2Nlc3Nlcy4gKi9cbiAgICBhZGRJbXBsaWNpdFJlY2VpdmVyQWNjZXNzKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmltcGxpY2l0UmVjZWl2ZXJBY2Nlc3Nlcy5hZGQobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmbGF0dGVuU3RhdGVtZW50cyhhcmcsIG91dHB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgYXJnLmZvckVhY2goKGVudHJ5KSA9PiBmbGF0dGVuU3RhdGVtZW50cyhlbnRyeSwgb3V0cHV0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChhcmcpO1xuICAgIH1cbn1cbmNsYXNzIERlZmF1bHRMb2NhbFJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3RvcihnbG9iYWxzKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgfVxuICAgIG5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKSB7IH1cbiAgICBtYXliZVJlc3RvcmVWaWV3KCkgeyB9XG4gICAgZ2V0TG9jYWwobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycy5ldmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBCdWlsdGluRnVuY3Rpb25DYWxsIGV4dGVuZHMgQ2FsbCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgYXJncywgY29udmVydGVyKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4sIG5ldyBFbXB0eUV4cHIoc3Bhbiwgc291cmNlU3BhbiksIGFyZ3MsIG51bGwpO1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlcjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGlzIGZpbGUgaXMgYSBwb3J0IG9mIHNoYWRvd0NTUyBmcm9tIHdlYmNvbXBvbmVudHMuanMgdG8gVHlwZVNjcmlwdC5cbiAqXG4gKiBQbGVhc2UgbWFrZSBzdXJlIHRvIGtlZXAgdG8gZWRpdHMgaW4gc3luYyB3aXRoIHRoZSBzb3VyY2UgZmlsZS5cbiAqXG4gKiBTb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvYmxvYi80ZWZlY2Q3ZTBlL3NyYy9TaGFkb3dDU1MvU2hhZG93Q1NTLmpzXG4gKlxuICogVGhlIG9yaWdpbmFsIGZpbGUgbGV2ZWwgY29tbWVudCBpcyByZXByb2R1Y2VkIGJlbG93XG4gKi9cbi8qXG4gIFRoaXMgaXMgYSBsaW1pdGVkIHNoaW0gZm9yIFNoYWRvd0RPTSBjc3Mgc3R5bGluZy5cbiAgaHR0cHM6Ly9kdmNzLnczLm9yZy9oZy93ZWJjb21wb25lbnRzL3Jhdy1maWxlL3RpcC9zcGVjL3NoYWRvdy9pbmRleC5odG1sI3N0eWxlc1xuXG4gIFRoZSBpbnRlbnRpb24gaGVyZSBpcyB0byBzdXBwb3J0IG9ubHkgdGhlIHN0eWxpbmcgZmVhdHVyZXMgd2hpY2ggY2FuIGJlXG4gIHJlbGF0aXZlbHkgc2ltcGx5IGltcGxlbWVudGVkLiBUaGUgZ29hbCBpcyB0byBhbGxvdyB1c2VycyB0byBhdm9pZCB0aGVcbiAgbW9zdCBvYnZpb3VzIHBpdGZhbGxzIGFuZCBkbyBzbyB3aXRob3V0IGNvbXByb21pc2luZyBwZXJmb3JtYW5jZSBzaWduaWZpY2FudGx5LlxuICBGb3IgU2hhZG93RE9NIHN0eWxpbmcgdGhhdCdzIG5vdCBjb3ZlcmVkIGhlcmUsIGEgc2V0IG9mIGJlc3QgcHJhY3RpY2VzXG4gIGNhbiBiZSBwcm92aWRlZCB0aGF0IHNob3VsZCBhbGxvdyB1c2VycyB0byBhY2NvbXBsaXNoIG1vcmUgY29tcGxleCBzdHlsaW5nLlxuXG4gIFRoZSBmb2xsb3dpbmcgaXMgYSBsaXN0IG9mIHNwZWNpZmljIFNoYWRvd0RPTSBzdHlsaW5nIGZlYXR1cmVzIGFuZCBhIGJyaWVmXG4gIGRpc2N1c3Npb24gb2YgdGhlIGFwcHJvYWNoIHVzZWQgdG8gc2hpbS5cblxuICBTaGltbWVkIGZlYXR1cmVzOlxuXG4gICogOmhvc3QsIDpob3N0LWNvbnRleHQ6IFNoYWRvd0RPTSBhbGxvd3Mgc3R5bGluZyBvZiB0aGUgc2hhZG93Um9vdCdzIGhvc3RcbiAgZWxlbWVudCB1c2luZyB0aGUgOmhvc3QgcnVsZS4gVG8gc2hpbSB0aGlzIGZlYXR1cmUsIHRoZSA6aG9zdCBzdHlsZXMgYXJlXG4gIHJlZm9ybWF0dGVkIGFuZCBwcmVmaXhlZCB3aXRoIGEgZ2l2ZW4gc2NvcGUgbmFtZSBhbmQgcHJvbW90ZWQgdG8gYVxuICBkb2N1bWVudCBsZXZlbCBzdHlsZXNoZWV0LlxuICBGb3IgZXhhbXBsZSwgZ2l2ZW4gYSBzY29wZSBuYW1lIG9mIC5mb28sIGEgcnVsZSBsaWtlIHRoaXM6XG5cbiAgICA6aG9zdCB7XG4gICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgYmVjb21lczpcblxuICAgIC5mb28ge1xuICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgIH1cblxuICAqIGVuY2Fwc3VsYXRpb246IFN0eWxlcyBkZWZpbmVkIHdpdGhpbiBTaGFkb3dET00sIGFwcGx5IG9ubHkgdG9cbiAgZG9tIGluc2lkZSB0aGUgU2hhZG93RE9NLiBQb2x5bWVyIHVzZXMgb25lIG9mIHR3byB0ZWNobmlxdWVzIHRvIGltcGxlbWVudFxuICB0aGlzIGZlYXR1cmUuXG5cbiAgQnkgZGVmYXVsdCwgcnVsZXMgYXJlIHByZWZpeGVkIHdpdGggdGhlIGhvc3QgZWxlbWVudCB0YWcgbmFtZVxuICBhcyBhIGRlc2NlbmRhbnQgc2VsZWN0b3IuIFRoaXMgZW5zdXJlcyBzdHlsaW5nIGRvZXMgbm90IGxlYWsgb3V0IG9mIHRoZSAndG9wJ1xuICBvZiB0aGUgZWxlbWVudCdzIFNoYWRvd0RPTS4gRm9yIGV4YW1wbGUsXG5cbiAgZGl2IHtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cblxuICBiZWNvbWVzOlxuXG4gIHgtZm9vIGRpdiB7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5cbiAgYmVjb21lczpcblxuXG4gIEFsdGVybmF0aXZlbHksIGlmIFdlYkNvbXBvbmVudHMuU2hhZG93Q1NTLnN0cmljdFN0eWxpbmcgaXMgc2V0IHRvIHRydWUgdGhlblxuICBzZWxlY3RvcnMgYXJlIHNjb3BlZCBieSBhZGRpbmcgYW4gYXR0cmlidXRlIHNlbGVjdG9yIHN1ZmZpeCB0byBlYWNoXG4gIHNpbXBsZSBzZWxlY3RvciB0aGF0IGNvbnRhaW5zIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWUuIEVhY2ggZWxlbWVudFxuICBpbiB0aGUgZWxlbWVudCdzIFNoYWRvd0RPTSB0ZW1wbGF0ZSBpcyBhbHNvIGdpdmVuIHRoZSBzY29wZSBhdHRyaWJ1dGUuXG4gIFRodXMsIHRoZXNlIHJ1bGVzIG1hdGNoIG9ubHkgZWxlbWVudHMgdGhhdCBoYXZlIHRoZSBzY29wZSBhdHRyaWJ1dGUuXG4gIEZvciBleGFtcGxlLCBnaXZlbiBhIHNjb3BlIG5hbWUgb2YgeC1mb28sIGEgcnVsZSBsaWtlIHRoaXM6XG5cbiAgICBkaXYge1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG4gIGJlY29tZXM6XG5cbiAgICBkaXZbeC1mb29dIHtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cblxuICBOb3RlIHRoYXQgZWxlbWVudHMgdGhhdCBhcmUgZHluYW1pY2FsbHkgYWRkZWQgdG8gYSBzY29wZSBtdXN0IGhhdmUgdGhlIHNjb3BlXG4gIHNlbGVjdG9yIGFkZGVkIHRvIHRoZW0gbWFudWFsbHkuXG5cbiAgKiB1cHBlci9sb3dlciBib3VuZCBlbmNhcHN1bGF0aW9uOiBTdHlsZXMgd2hpY2ggYXJlIGRlZmluZWQgb3V0c2lkZSBhXG4gIHNoYWRvd1Jvb3Qgc2hvdWxkIG5vdCBjcm9zcyB0aGUgU2hhZG93RE9NIGJvdW5kYXJ5IGFuZCBzaG91bGQgbm90IGFwcGx5XG4gIGluc2lkZSBhIHNoYWRvd1Jvb3QuXG5cbiAgVGhpcyBzdHlsaW5nIGJlaGF2aW9yIGlzIG5vdCBlbXVsYXRlZC4gU29tZSBwb3NzaWJsZSB3YXlzIHRvIGRvIHRoaXMgdGhhdFxuICB3ZXJlIHJlamVjdGVkIGR1ZSB0byBjb21wbGV4aXR5IGFuZC9vciBwZXJmb3JtYW5jZSBjb25jZXJucyBpbmNsdWRlOiAoMSkgcmVzZXRcbiAgZXZlcnkgcG9zc2libGUgcHJvcGVydHkgZm9yIGV2ZXJ5IHBvc3NpYmxlIHNlbGVjdG9yIGZvciBhIGdpdmVuIHNjb3BlIG5hbWU7XG4gICgyKSByZS1pbXBsZW1lbnQgY3NzIGluIGphdmFzY3JpcHQuXG5cbiAgQXMgYW4gYWx0ZXJuYXRpdmUsIHVzZXJzIHNob3VsZCBtYWtlIHN1cmUgdG8gdXNlIHNlbGVjdG9yc1xuICBzcGVjaWZpYyB0byB0aGUgc2NvcGUgaW4gd2hpY2ggdGhleSBhcmUgd29ya2luZy5cblxuICAqIDo6ZGlzdHJpYnV0ZWQ6IFRoaXMgYmVoYXZpb3IgaXMgbm90IGVtdWxhdGVkLiBJdCdzIG9mdGVuIG5vdCBuZWNlc3NhcnlcbiAgdG8gc3R5bGUgdGhlIGNvbnRlbnRzIG9mIGEgc3BlY2lmaWMgaW5zZXJ0aW9uIHBvaW50IGFuZCBpbnN0ZWFkLCBkZXNjZW5kYW50c1xuICBvZiB0aGUgaG9zdCBlbGVtZW50IGNhbiBiZSBzdHlsZWQgc2VsZWN0aXZlbHkuIFVzZXJzIGNhbiBhbHNvIGNyZWF0ZSBhblxuICBleHRyYSBub2RlIGFyb3VuZCBhbiBpbnNlcnRpb24gcG9pbnQgYW5kIHN0eWxlIHRoYXQgbm9kZSdzIGNvbnRlbnRzXG4gIHZpYSBkZXNjZW5kZW50IHNlbGVjdG9ycy4gRm9yIGV4YW1wbGUsIHdpdGggYSBzaGFkb3dSb290IGxpa2UgdGhpczpcblxuICAgIDxzdHlsZT5cbiAgICAgIDo6Y29udGVudChkaXYpIHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG4gICAgPGNvbnRlbnQ+PC9jb250ZW50PlxuXG4gIGNvdWxkIGJlY29tZTpcblxuICAgIDxzdHlsZT5cbiAgICAgIC8gKkBwb2x5ZmlsbCAuY29udGVudC1jb250YWluZXIgZGl2ICogL1xuICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGVudC1jb250YWluZXJcIj5cbiAgICAgIDxjb250ZW50PjwvY29udGVudD5cbiAgICA8L2Rpdj5cblxuICBOb3RlIHRoZSB1c2Ugb2YgQHBvbHlmaWxsIGluIHRoZSBjb21tZW50IGFib3ZlIGEgU2hhZG93RE9NIHNwZWNpZmljIHN0eWxlXG4gIGRlY2xhcmF0aW9uLiBUaGlzIGlzIGEgZGlyZWN0aXZlIHRvIHRoZSBzdHlsaW5nIHNoaW0gdG8gdXNlIHRoZSBzZWxlY3RvclxuICBpbiBjb21tZW50cyBpbiBsaWV1IG9mIHRoZSBuZXh0IHNlbGVjdG9yIHdoZW4gcnVubmluZyB1bmRlciBwb2x5ZmlsbC5cbiovXG5jbGFzcyBTaGFkb3dDc3Mge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0cmljdFN0eWxpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFNoaW0gc29tZSBjc3NUZXh0IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yLiBSZXR1cm5zIGNzc1RleHQgdGhhdCBjYW5cbiAgICAgKiBiZSBpbmNsdWRlZCBpbiB0aGUgZG9jdW1lbnQgdmlhIFdlYkNvbXBvbmVudHMuU2hhZG93Q1NTLmFkZENzc1RvRG9jdW1lbnQoY3NzKS5cbiAgICAgKlxuICAgICAqIFdoZW4gc3RyaWN0U3R5bGluZyBpcyB0cnVlOlxuICAgICAqIC0gc2VsZWN0b3IgaXMgdGhlIGF0dHJpYnV0ZSBhZGRlZCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIHRoZSBob3N0LFxuICAgICAqIC0gaG9zdFNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gdGhlIGhvc3QgaXRzZWxmLlxuICAgICAqL1xuICAgIHNoaW1Dc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IgPSAnJykge1xuICAgICAgICBjb25zdCBjb21tZW50c1dpdGhIYXNoID0gZXh0cmFjdENvbW1lbnRzV2l0aEhhc2goY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSBzdHJpcENvbW1lbnRzKGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0RGlyZWN0aXZlcyhjc3NUZXh0KTtcbiAgICAgICAgY29uc3Qgc2NvcGVkQ3NzVGV4dCA9IHRoaXMuX3Njb3BlQ3NzVGV4dChjc3NUZXh0LCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIFtzY29wZWRDc3NUZXh0LCAuLi5jb21tZW50c1dpdGhIYXNoXS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgX2luc2VydERpcmVjdGl2ZXMoY3NzVGV4dCkge1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5faW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0UG9seWZpbGxSdWxlc0luQ3NzVGV4dChjc3NUZXh0KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBjb252ZXJ0IG5hdGl2ZSBTaGFkb3dET00gcnVsZXMgdGhhdCB3aWxsIHRyaXBcbiAgICAgKiB1cCB0aGUgY3NzIHBhcnNlcjsgd2UgcmVseSBvbiBkZWNvcmF0aW5nIHRoZSBzdHlsZXNoZWV0IHdpdGggaW5lcnQgcnVsZXMuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XG4gICAgICpcbiAgICAgKiBwb2x5ZmlsbC1uZXh0LXNlbGVjdG9yIHsgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7IH1cbiAgICAgKiA6OmNvbnRlbnQgbWVudS1pdGVtIHtcbiAgICAgKlxuICAgICAqIHRvIHRoaXM6XG4gICAgICpcbiAgICAgKiBzY29wZU5hbWUgbWVudS1pdGVtIHtcbiAgICAgKlxuICAgICAqKi9cbiAgICBfaW5zZXJ0UG9seWZpbGxEaXJlY3RpdmVzSW5Dc3NUZXh0KGNzc1RleHQpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSB3aXRoIHdlYmNvbXBvbmVudHMuanM6IGRvZXMgbm90IGhhbmRsZSBjb21tZW50c1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb250ZW50TmV4dFNlbGVjdG9yUmUsIGZ1bmN0aW9uICguLi5tKSB7XG4gICAgICAgICAgICByZXR1cm4gbVsyXSArICd7JztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogUHJvY2VzcyBzdHlsZXMgdG8gYWRkIHJ1bGVzIHdoaWNoIHdpbGwgb25seSBhcHBseSB1bmRlciB0aGUgcG9seWZpbGxcbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgKlxuICAgICAqIHBvbHlmaWxsLXJ1bGUge1xuICAgICAqICAgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7XG4gICAgICogLi4uXG4gICAgICogfVxuICAgICAqXG4gICAgICogdG8gdGhpczpcbiAgICAgKlxuICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0gey4uLn1cbiAgICAgKlxuICAgICAqKi9cbiAgICBfaW5zZXJ0UG9seWZpbGxSdWxlc0luQ3NzVGV4dChjc3NUZXh0KSB7XG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShfY3NzQ29udGVudFJ1bGVSZSwgKC4uLm0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBtWzBdLnJlcGxhY2UobVsxXSwgJycpLnJlcGxhY2UobVsyXSwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIG1bNF0gKyBydWxlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyogRW5zdXJlIHN0eWxlcyBhcmUgc2NvcGVkLiBQc2V1ZG8tc2NvcGluZyB0YWtlcyBhIHJ1bGUgbGlrZTpcbiAgICAgKlxuICAgICAqICAuZm9vIHsuLi4gfVxuICAgICAqXG4gICAgICogIGFuZCBjb252ZXJ0cyB0aGlzIHRvXG4gICAgICpcbiAgICAgKiAgc2NvcGVOYW1lIC5mb28geyAuLi4gfVxuICAgICAqL1xuICAgIF9zY29wZUNzc1RleHQoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHVuc2NvcGVkUnVsZXMgPSB0aGlzLl9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0KGNzc1RleHQpO1xuICAgICAgICAvLyByZXBsYWNlIDpob3N0IGFuZCA6aG9zdC1jb250ZXh0IC1zaGFkb3djc3Nob3N0IGFuZCAtc2hhZG93Y3NzaG9zdCByZXNwZWN0aXZlbHlcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0Q29sb25Ib3N0Q29udGV4dChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2NvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMoY3NzVGV4dCk7XG4gICAgICAgIGlmIChzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICBjc3NUZXh0ID0gdGhpcy5fc2NvcGVTZWxlY3RvcnMoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dCArICdcXG4nICsgdW5zY29wZWRSdWxlcztcbiAgICAgICAgcmV0dXJuIGNzc1RleHQudHJpbSgpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXG4gICAgICogYW5kIGRvIG5vdCBwcm9jZXNzIHZpYSBDU1NPTS4gKENTU09NIGlzIGRlc3RydWN0aXZlIHRvIHJ1bGVzIG9uIHJhcmVcbiAgICAgKiBvY2Nhc2lvbnMsIGUuZy4gLXdlYmtpdC1jYWxjIG9uIFNhZmFyaS4pXG4gICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAqXG4gICAgICogQHBvbHlmaWxsLXVuc2NvcGVkLXJ1bGUge1xuICAgICAqICAgY29udGVudDogJ21lbnUtaXRlbSc7XG4gICAgICogLi4uIH1cbiAgICAgKlxuICAgICAqIHRvIHRoaXM6XG4gICAgICpcbiAgICAgKiBtZW51LWl0ZW0gey4uLn1cbiAgICAgKlxuICAgICAqKi9cbiAgICBfZXh0cmFjdFVuc2NvcGVkUnVsZXNGcm9tQ3NzVGV4dChjc3NUZXh0KSB7XG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgbGV0IHIgPSAnJztcbiAgICAgICAgbGV0IG07XG4gICAgICAgIF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKChtID0gX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZS5leGVjKGNzc1RleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IG1bMF0ucmVwbGFjZShtWzJdLCAnJykucmVwbGFjZShtWzFdLCBtWzRdKTtcbiAgICAgICAgICAgIHIgKz0gcnVsZSArICdcXG5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICAvKlxuICAgICAqIGNvbnZlcnQgYSBydWxlIGxpa2UgOmhvc3QoLmZvbykgPiAuYmFyIHsgfVxuICAgICAqXG4gICAgICogdG9cbiAgICAgKlxuICAgICAqIC5mb288c2NvcGVOYW1lPiA+IC5iYXJcbiAgICAgKi9cbiAgICBfY29udmVydENvbG9uSG9zdChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbG9uSG9zdFJlLCAoXywgaG9zdFNlbGVjdG9ycywgb3RoZXJTZWxlY3RvcnMpID0+IHtcbiAgICAgICAgICAgIGlmIChob3N0U2VsZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVkU2VsZWN0b3JzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgaG9zdFNlbGVjdG9yQXJyYXkgPSBob3N0U2VsZWN0b3JzLnNwbGl0KCcsJykubWFwKHAgPT4gcC50cmltKCkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaG9zdFNlbGVjdG9yIG9mIGhvc3RTZWxlY3RvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaG9zdFNlbGVjdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZFNlbGVjdG9yID0gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIGhvc3RTZWxlY3Rvci5yZXBsYWNlKF9wb2x5ZmlsbEhvc3QsICcnKSArIG90aGVyU2VsZWN0b3JzO1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZWRTZWxlY3RvcnMucHVzaChjb252ZXJ0ZWRTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZWRTZWxlY3RvcnMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgKyBvdGhlclNlbGVjdG9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogY29udmVydCBhIHJ1bGUgbGlrZSA6aG9zdC1jb250ZXh0KC5mb28pID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIHRvXG4gICAgICpcbiAgICAgKiAuZm9vPHNjb3BlTmFtZT4gPiAuYmFyLCAuZm9vIDxzY29wZU5hbWU+ID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIGFuZFxuICAgICAqXG4gICAgICogOmhvc3QtY29udGV4dCguZm9vOmhvc3QpIC5iYXIgeyAuLi4gfVxuICAgICAqXG4gICAgICogdG9cbiAgICAgKlxuICAgICAqIC5mb288c2NvcGVOYW1lPiAuYmFyIHsgLi4uIH1cbiAgICAgKi9cbiAgICBfY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb2xvbkhvc3RDb250ZXh0UmVHbG9iYWwsIHNlbGVjdG9yVGV4dCA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGNhcHR1cmVkIGEgc2VsZWN0b3IgdGhhdCBjb250YWlucyBhIGA6aG9zdC1jb250ZXh0YCBydWxlLlxuICAgICAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYDpob3N0LWNvbnRleHRgIG1heSBjb250YWluIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2Ygc2VsZWN0b3JzLlxuICAgICAgICAgICAgLy8gRWFjaCBjb250ZXh0IHNlbGVjdG9yIGdyb3VwIHdpbGwgY29udGFpbiBhIGxpc3Qgb2YgaG9zdC1jb250ZXh0IHNlbGVjdG9ycyB0aGF0IG11c3QgbWF0Y2hcbiAgICAgICAgICAgIC8vIGFuIGFuY2VzdG9yIG9mIHRoZSBob3N0LlxuICAgICAgICAgICAgLy8gKE5vcm1hbGx5IGBjb250ZXh0U2VsZWN0b3JHcm91cHNgIHdpbGwgb25seSBjb250YWluIGEgc2luZ2xlIGFycmF5IG9mIGNvbnRleHQgc2VsZWN0b3JzLilcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRTZWxlY3Rvckdyb3VwcyA9IFtbXV07XG4gICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIGA6aG9zdC1jb250ZXh0YCBpbiB0aGlzIHNlbGVjdG9yIHNvIGBzZWxlY3RvclRleHRgIGNvdWxkIGxvb2sgbGlrZTpcbiAgICAgICAgICAgIC8vIGA6aG9zdC1jb250ZXh0KC5vbmUpOmhvc3QtY29udGV4dCgudHdvKWAuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIGBfY3NzQ29sb25Ib3N0Q29udGV4dFJlYCBvdmVyIGFuZCBvdmVyIHVudGlsIHdlIGhhdmUgZXh0cmFjdGVkIGFsbCB0aGVcbiAgICAgICAgICAgIC8vIGA6aG9zdC1jb250ZXh0YCBzZWxlY3RvcnMgZnJvbSB0aGlzIHNlbGVjdG9yLlxuICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gX2Nzc0NvbG9uSG9zdENvbnRleHRSZS5leGVjKHNlbGVjdG9yVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBgbWF0Y2hgID0gWyc6aG9zdC1jb250ZXh0KDxzZWxlY3RvcnM+KTxyZXN0PicsIDxzZWxlY3RvcnM+LCA8cmVzdD5dXG4gICAgICAgICAgICAgICAgLy8gVGhlIGA8c2VsZWN0b3JzPmAgY291bGQgYWN0dWFsbHkgYmUgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdDogYDpob3N0LWNvbnRleHQoLm9uZSwgLnR3bylgLlxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHRTZWxlY3RvcnMgPSAoKF9hID0gbWF0Y2hbMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS50cmltKCkuc3BsaXQoJywnKS5tYXAobSA9PiBtLnRyaW0oKSkuZmlsdGVyKG0gPT4gbSAhPT0gJycpO1xuICAgICAgICAgICAgICAgIC8vIFdlIG11c3QgZHVwbGljYXRlIHRoZSBjdXJyZW50IHNlbGVjdG9yIGdyb3VwIGZvciBlYWNoIG9mIHRoZXNlIG5ldyBzZWxlY3RvcnMuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUgaWYgdGhlIGN1cnJlbnQgZ3JvdXBzIGFyZTpcbiAgICAgICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgICAgICAgICAgLy8gICBbJ2EnLCAnYicsICdjJ10sXG4gICAgICAgICAgICAgICAgLy8gICBbJ3gnLCAneScsICd6J10sXG4gICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgICAgIC8vIEFuZCB3ZSBoYXZlIGEgbmV3IHNldCBvZiBjb21tYSBzZXBhcmF0ZWQgc2VsZWN0b3JzOiBgOmhvc3QtY29udGV4dChtLG4pYCB0aGVuIHRoZSBuZXdcbiAgICAgICAgICAgICAgICAvLyBncm91cHMgYXJlOlxuICAgICAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgICAgICAgICAvLyAgIFsnYScsICdiJywgJ2MnLCAnbSddLFxuICAgICAgICAgICAgICAgIC8vICAgWyd4JywgJ3knLCAneicsICdtJ10sXG4gICAgICAgICAgICAgICAgLy8gICBbJ2EnLCAnYicsICdjJywgJ24nXSxcbiAgICAgICAgICAgICAgICAvLyAgIFsneCcsICd5JywgJ3onLCAnbiddLFxuICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0U2VsZWN0b3JHcm91cHNMZW5ndGggPSBjb250ZXh0U2VsZWN0b3JHcm91cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlcGVhdEdyb3Vwcyhjb250ZXh0U2VsZWN0b3JHcm91cHMsIG5ld0NvbnRleHRTZWxlY3RvcnMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0NvbnRleHRTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb250ZXh0U2VsZWN0b3JHcm91cHNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFNlbGVjdG9yR3JvdXBzW2ogKyAoaSAqIGNvbnRleHRTZWxlY3Rvckdyb3Vwc0xlbmd0aCldLnB1c2gobmV3Q29udGV4dFNlbGVjdG9yc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBgc2VsZWN0b3JUZXh0YCBhbmQgc2VlIHJlcGVhdCB0byBzZWUgaWYgdGhlcmUgYXJlIG1vcmUgYDpob3N0LWNvbnRleHRgcy5cbiAgICAgICAgICAgICAgICBzZWxlY3RvclRleHQgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBjb250ZXh0IHNlbGVjdG9ycyBub3cgbXVzdCBiZSBjb21iaW5lZCB3aXRoIGVhY2ggb3RoZXIgdG8gY2FwdHVyZSBhbGwgdGhlIHBvc3NpYmxlXG4gICAgICAgICAgICAvLyBzZWxlY3RvcnMgdGhhdCBgOmhvc3QtY29udGV4dGAgY2FuIG1hdGNoLiBTZWUgYGNvbWJpbmVIb3N0Q29udGV4dFNlbGVjdG9ycygpYCBmb3IgbW9yZVxuICAgICAgICAgICAgLy8gaW5mbyBhYm91dCBob3cgdGhpcyBpcyBkb25lLlxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRTZWxlY3Rvckdyb3Vwc1xuICAgICAgICAgICAgICAgIC5tYXAoY29udGV4dFNlbGVjdG9ycyA9PiBjb21iaW5lSG9zdENvbnRleHRTZWxlY3RvcnMoY29udGV4dFNlbGVjdG9ycywgc2VsZWN0b3JUZXh0KSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogQ29udmVydCBjb21iaW5hdG9ycyBsaWtlIDo6c2hhZG93IGFuZCBwc2V1ZG8tZWxlbWVudHMgbGlrZSA6OmNvbnRlbnRcbiAgICAgKiBieSByZXBsYWNpbmcgd2l0aCBzcGFjZS5cbiAgICAgKi9cbiAgICBfY29udmVydFNoYWRvd0RPTVNlbGVjdG9ycyhjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiBfc2hhZG93RE9NU2VsZWN0b3JzUmUucmVkdWNlKChyZXN1bHQsIHBhdHRlcm4pID0+IHJlc3VsdC5yZXBsYWNlKHBhdHRlcm4sICcgJyksIGNzc1RleHQpO1xuICAgIH1cbiAgICAvLyBjaGFuZ2UgYSBzZWxlY3RvciBsaWtlICdkaXYnIHRvICduYW1lIGRpdidcbiAgICBfc2NvcGVTZWxlY3RvcnMoY3NzVGV4dCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzUnVsZXMoY3NzVGV4dCwgKHJ1bGUpID0+IHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RvciA9IHJ1bGUuc2VsZWN0b3I7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHJ1bGUuY29udGVudDtcbiAgICAgICAgICAgIGlmIChydWxlLnNlbGVjdG9yWzBdICE9PSAnQCcpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njb3BlU2VsZWN0b3IocnVsZS5zZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCB0aGlzLnN0cmljdFN0eWxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAbWVkaWEnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BzdXBwb3J0cycpIHx8XG4gICAgICAgICAgICAgICAgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAZG9jdW1lbnQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLl9zY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0Bmb250LWZhY2UnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BwYWdlJykpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5fc3RyaXBTY29waW5nU2VsZWN0b3JzKHJ1bGUuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgY3NzIHRleHQgdGhhdCBpcyB3aXRoaW4gYSBydWxlIHRoYXQgc2hvdWxkIG5vdCBjb250YWluIHNjb3BlIHNlbGVjdG9ycyBieSBzaW1wbHlcbiAgICAgKiByZW1vdmluZyB0aGVtISBBbiBleGFtcGxlIG9mIHN1Y2ggYSBydWxlIGlzIGBAZm9udC1mYWNlYC5cbiAgICAgKlxuICAgICAqIGBAZm9udC1mYWNlYCBydWxlcyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgc2VsZWN0b3JzLiBOb3IgY2FuIHRoZXkgYmUgbmVzdGVkIHVuZGVyIGEgc2VsZWN0b3IuXG4gICAgICogTm9ybWFsbHkgdGhpcyB3b3VsZCBiZSBhIHN5bnRheCBlcnJvciBieSB0aGUgYXV0aG9yIG9mIHRoZSBzdHlsZXMuIEJ1dCBpbiBzb21lIHJhcmUgY2FzZXMsIHN1Y2hcbiAgICAgKiBhcyBpbXBvcnRpbmcgc3R5bGVzIGZyb20gYSBsaWJyYXJ5LCBhbmQgYXBwbHlpbmcgYDpob3N0IDo6bmctZGVlcGAgdG8gdGhlIGltcG9ydGVkIHN0eWxlcywgd2VcbiAgICAgKiBjYW4gZW5kIHVwIHdpdGggYnJva2VuIGNzcyBpZiB0aGUgaW1wb3J0ZWQgc3R5bGVzIGhhcHBlbiB0byBjb250YWluIEBmb250LWZhY2UgcnVsZXMuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDpob3N0IDo6bmctZGVlcCB7XG4gICAgICogICBpbXBvcnQgJ3NvbWUvbGliL2NvbnRhaW5pbmcvZm9udC1mYWNlJztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaW1pbGFyIGxvZ2ljIGFwcGxpZXMgdG8gYEBwYWdlYCBydWxlcyB3aGljaCBjYW4gY29udGFpbiBhIHBhcnRpY3VsYXIgc2V0IG9mIHByb3BlcnRpZXMsXG4gICAgICogYXMgd2VsbCBhcyBzb21lIHNwZWNpZmljIGF0LXJ1bGVzLiBTaW5jZSB0aGV5IGNhbid0IGJlIGVuY2Fwc3VsYXRlZCwgd2UgaGF2ZSB0byBzdHJpcFxuICAgICAqIGFueSBzY29waW5nIHNlbGVjdG9ycyBmcm9tIHRoZW0uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXBhZ2UtM1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIF9zdHJpcFNjb3BpbmdTZWxlY3RvcnMoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1J1bGVzKGNzc1RleHQsIHJ1bGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yLnJlcGxhY2UoX3NoYWRvd0RlZXBTZWxlY3RvcnMsICcgJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUsICcgJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIHJ1bGUuY29udGVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2NvcGVTZWxlY3RvcihzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KCcsJylcbiAgICAgICAgICAgIC5tYXAocGFydCA9PiBwYXJ0LnRyaW0oKS5zcGxpdChfc2hhZG93RGVlcFNlbGVjdG9ycykpXG4gICAgICAgICAgICAubWFwKChkZWVwUGFydHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtzaGFsbG93UGFydCwgLi4ub3RoZXJQYXJ0c10gPSBkZWVwUGFydHM7XG4gICAgICAgICAgICBjb25zdCBhcHBseVNjb3BlID0gKHNoYWxsb3dQYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdG9yTmVlZHNTY29waW5nKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaWN0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVNlbGVjdG9yU2NvcGUoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1BhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBbYXBwbHlTY29wZShzaGFsbG93UGFydCksIC4uLm90aGVyUGFydHNdLmpvaW4oJyAnKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgIH1cbiAgICBfc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmUgPSB0aGlzLl9tYWtlU2NvcGVNYXRjaGVyKHNjb3BlU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gIXJlLnRlc3Qoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBfbWFrZVNjb3BlTWF0Y2hlcihzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGxyZSA9IC9cXFsvZztcbiAgICAgICAgY29uc3QgcnJlID0gL1xcXS9nO1xuICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGxyZSwgJ1xcXFxbJykucmVwbGFjZShycmUsICdcXFxcXScpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgc2NvcGVTZWxlY3RvciArICcpJyArIF9zZWxlY3RvclJlU3VmZml4LCAnbScpO1xuICAgIH1cbiAgICBfYXBwbHlTZWxlY3RvclNjb3BlKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSBmcm9tIHdlYmNvbXBvbmVudHMuanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgfVxuICAgIC8vIHNjb3BlIHZpYSBuYW1lIGFuZCBbaXM9bmFtZV1cbiAgICBfYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgLy8gSW4gQW5kcm9pZCBicm93c2VyLCB0aGUgbGFzdEluZGV4IGlzIG5vdCByZXNldCB3aGVuIHRoZSByZWdleCBpcyB1c2VkIGluIFN0cmluZy5yZXBsYWNlKClcbiAgICAgICAgX3BvbHlmaWxsSG9zdFJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmIChfcG9seWZpbGxIb3N0UmUudGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VCeSA9IHRoaXMuc3RyaWN0U3R5bGluZyA/IGBbJHtob3N0U2VsZWN0b3J9XWAgOiBzY29wZVNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCAoaG5jLCBzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKC8oW146XSopKDoqKSguKikvLCAoXywgYmVmb3JlLCBjb2xvbiwgYWZ0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSArIHJlcGxhY2VCeSArIGNvbG9uICsgYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgcmVwbGFjZUJ5ICsgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVTZWxlY3RvciArICcgJyArIHNlbGVjdG9yO1xuICAgIH1cbiAgICAvLyByZXR1cm4gYSBzZWxlY3RvciB3aXRoIFtuYW1lXSBzdWZmaXggb24gZWFjaCBzaW1wbGUgc2VsZWN0b3JcbiAgICAvLyBlLmcuIC5mb28uYmFyID4gLnpvdCBiZWNvbWVzIC5mb29bbmFtZV0uYmFyW25hbWVdID4gLnpvdFtuYW1lXSAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBpc1JlID0gL1xcW2lzPShbXlxcXV0qKVxcXS9nO1xuICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGlzUmUsIChfLCAuLi5wYXJ0cykgPT4gcGFydHNbMF0pO1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9ICdbJyArIHNjb3BlU2VsZWN0b3IgKyAnXSc7XG4gICAgICAgIGNvbnN0IF9zY29wZVNlbGVjdG9yUGFydCA9IChwKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFzY29wZWRQKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVkUCA9IHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShwLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIDpob3N0IHNpbmNlIGl0IHNob3VsZCBiZSB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwLnJlcGxhY2UoX3BvbHlmaWxsSG9zdFJlLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdC5tYXRjaCgvKFteOl0qKSg6KikoLiopLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZWRQID0gbWF0Y2hlc1sxXSArIGF0dHJOYW1lICsgbWF0Y2hlc1syXSArIG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVkUDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2FmZUNvbnRlbnQgPSBuZXcgU2FmZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzYWZlQ29udGVudC5jb250ZW50KCk7XG4gICAgICAgIGxldCBzY29wZWRTZWxlY3RvciA9ICcnO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGNvbnN0IHNlcCA9IC8oIHw+fFxcK3x+KD8hPSkpXFxzKi9nO1xuICAgICAgICAvLyBJZiBhIHNlbGVjdG9yIGFwcGVhcnMgYmVmb3JlIDpob3N0IGl0IHNob3VsZCBub3QgYmUgc2hpbW1lZCBhcyBpdFxuICAgICAgICAvLyBtYXRjaGVzIG9uIGFuY2VzdG9yIGVsZW1lbnRzIGFuZCBub3Qgb24gZWxlbWVudHMgaW4gdGhlIGhvc3QncyBzaGFkb3dcbiAgICAgICAgLy8gYDpob3N0LWNvbnRleHQoZGl2KWAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAgICAgLy8gYC1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3JkaXYsIGRpdiAtc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yYFxuICAgICAgICAvLyB0aGUgYGRpdmAgaXMgbm90IHBhcnQgb2YgdGhlIGNvbXBvbmVudCBpbiB0aGUgMm5kIHNlbGVjdG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBzY29wZWQuXG4gICAgICAgIC8vIEhpc3RvcmljYWxseSBgY29tcG9uZW50LXRhZzpob3N0YCB3YXMgbWF0Y2hpbmcgdGhlIGNvbXBvbmVudCBzbyB3ZSBhbHNvIHdhbnQgdG8gcHJlc2VydmVcbiAgICAgICAgLy8gdGhpcyBiZWhhdmlvciB0byBhdm9pZCBicmVha2luZyBsZWdhY3kgYXBwcyAoaXQgc2hvdWxkIG5vdCBtYXRjaCkuXG4gICAgICAgIC8vIFRoZSBiZWhhdmlvciBzaG91bGQgYmU6XG4gICAgICAgIC8vIC0gYHRhZzpob3N0YCAtPiBgdGFnW2hdYCAodGhpcyBpcyB0byBhdm9pZCBicmVha2luZyBsZWdhY3kgYXBwcywgc2hvdWxkIG5vdCBtYXRjaCBhbnl0aGluZylcbiAgICAgICAgLy8gLSBgdGFnIDpob3N0YCAtPiBgdGFnIFtoXWAgKGB0YWdgIGlzIG5vdCBzY29wZWQgYmVjYXVzZSBpdCdzIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgICAgIC8vICAgYDpob3N0LWNvbnRleHQodGFnKWApXG4gICAgICAgIGNvbnN0IGhhc0hvc3QgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgICAgIC8vIE9ubHkgc2NvcGUgcGFydHMgYWZ0ZXIgdGhlIGZpcnN0IGAtc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yYCB3aGVuIGl0IGlzIHByZXNlbnRcbiAgICAgICAgbGV0IHNob3VsZFNjb3BlID0gIWhhc0hvc3Q7XG4gICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gcmVzWzFdO1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHNlbGVjdG9yLnNsaWNlKHN0YXJ0SW5kZXgsIHJlcy5pbmRleCkudHJpbSgpO1xuICAgICAgICAgICAgc2hvdWxkU2NvcGUgPSBzaG91bGRTY29wZSB8fCBwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlZFBhcnQgPSBzaG91bGRTY29wZSA/IF9zY29wZVNlbGVjdG9yUGFydChwYXJ0KSA6IHBhcnQ7XG4gICAgICAgICAgICBzY29wZWRTZWxlY3RvciArPSBgJHtzY29wZWRQYXJ0fSAke3NlcGFyYXRvcn0gYDtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBzZXAubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnQgPSBzZWxlY3Rvci5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XG4gICAgICAgIHNob3VsZFNjb3BlID0gc2hvdWxkU2NvcGUgfHwgcGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNob3VsZFNjb3BlID8gX3Njb3BlU2VsZWN0b3JQYXJ0KHBhcnQpIDogcGFydDtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXJzIHdpdGggdGhlaXIgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgIHJldHVybiBzYWZlQ29udGVudC5yZXN0b3JlKHNjb3BlZFNlbGVjdG9yKTtcbiAgICB9XG4gICAgX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShfY29sb25Ib3N0Q29udGV4dFJlLCBfcG9seWZpbGxIb3N0Q29udGV4dClcbiAgICAgICAgICAgIC5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdCk7XG4gICAgfVxufVxuY2xhc3MgU2FmZVNlbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLy8gUmVwbGFjZXMgYXR0cmlidXRlIHNlbGVjdG9ycyB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgICAgLy8gVGhlIFdTIGluIFthdHRyPVwidmEgbHVlXCJdIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBhIHNlbGVjdG9yIHNlcGFyYXRvci5cbiAgICAgICAgc2VsZWN0b3IgPSB0aGlzLl9lc2NhcGVSZWdleE1hdGNoZXMoc2VsZWN0b3IsIC8oXFxbW15cXF1dKlxcXSkvZyk7XG4gICAgICAgIC8vIENTUyBhbGxvd3MgZm9yIGNlcnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzIHRvIGJlIHVzZWQgaW4gc2VsZWN0b3JzIGlmIHRoZXkncmUgZXNjYXBlZC5cbiAgICAgICAgLy8gRS5nLiBgLmZvbzpibHVlYCB3b24ndCBtYXRjaCBhIGNsYXNzIGNhbGxlZCBgZm9vOmJsdWVgLCBiZWNhdXNlIHRoZSBjb2xvbiBkZW5vdGVzIGFcbiAgICAgICAgLy8gcHNldWRvLWNsYXNzLCBidXQgd3JpdGluZyBgLmZvb1xcOmJsdWVgIHdpbGwgbWF0Y2gsIGJlY2F1c2UgdGhlIGNvbG9uIHdhcyBlc2NhcGVkLlxuICAgICAgICAvLyBSZXBsYWNlIGFsbCBlc2NhcGUgc2VxdWVuY2VzIChgXFxgIGZvbGxvd2VkIGJ5IGEgY2hhcmFjdGVyKSB3aXRoIGEgcGxhY2Vob2xkZXIgc29cbiAgICAgICAgLy8gdGhhdCBvdXIgaGFuZGxpbmcgb2YgcHNldWRvLXNlbGVjdG9ycyBkb2Vzbid0IG1lc3Mgd2l0aCB0aGVtLlxuICAgICAgICBzZWxlY3RvciA9IHRoaXMuX2VzY2FwZVJlZ2V4TWF0Y2hlcyhzZWxlY3RvciwgLyhcXFxcLikvZyk7XG4gICAgICAgIC8vIFJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluIGA6bnRoLWNoaWxkKDJuICsgMSlgIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICAgICAgLy8gV1MgYW5kIFwiK1wiIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBzZWxlY3RvciBzZXBhcmF0b3JzLlxuICAgICAgICB0aGlzLl9jb250ZW50ID0gc2VsZWN0b3IucmVwbGFjZSgvKDpudGgtWy1cXHddKykoXFwoW14pXStcXCkpL2csIChfLCBwc2V1ZG8sIGV4cCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZUJ5ID0gYF9fcGgtJHt0aGlzLmluZGV4fV9fYDtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJzLnB1c2goZXhwKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiBwc2V1ZG8gKyByZXBsYWNlQnk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN0b3JlKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvX19waC0oXFxkKylfXy9nLCAoX3BoLCBpbmRleCkgPT4gdGhpcy5wbGFjZWhvbGRlcnNbK2luZGV4XSk7XG4gICAgfVxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN1YnN0cmluZ3MgdGhhdCBtYXRjaCBhIHJlZ2V4IHdpdGhpbiBhXG4gICAgICogc3BlY2lhbCBzdHJpbmcgKGUuZy4gYF9fcGgtMF9fYCwgYF9fcGgtMV9fYCwgZXRjKS5cbiAgICAgKi9cbiAgICBfZXNjYXBlUmVnZXhNYXRjaGVzKGNvbnRlbnQsIHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZShwYXR0ZXJuLCAoXywga2VlcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZUJ5ID0gYF9fcGgtJHt0aGlzLmluZGV4fV9fYDtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJzLnB1c2goa2VlcCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZUJ5O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBfY3NzQ29udGVudE5leHRTZWxlY3RvclJlID0gL3BvbHlmaWxsLW5leHQtc2VsZWN0b3JbXn1dKmNvbnRlbnQ6W1xcc10qPyhbJ1wiXSkoLio/KVxcMVs7XFxzXSp9KFtee10qPyl7L2dpbTtcbmNvbnN0IF9jc3NDb250ZW50UnVsZVJlID0gLyhwb2x5ZmlsbC1ydWxlKVtefV0qKGNvbnRlbnQ6W1xcc10qKFsnXCJdKSguKj8pXFwzKVs7XFxzXSpbXn1dKn0vZ2ltO1xuY29uc3QgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZSA9IC8ocG9seWZpbGwtdW5zY29wZWQtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbmNvbnN0IF9wb2x5ZmlsbEhvc3QgPSAnLXNoYWRvd2Nzc2hvc3QnO1xuLy8gbm90ZTogOmhvc3QtY29udGV4dCBwcmUtcHJvY2Vzc2VkIHRvIC1zaGFkb3djc3Nob3N0Y29udGV4dC5cbmNvbnN0IF9wb2x5ZmlsbEhvc3RDb250ZXh0ID0gJy1zaGFkb3djc3Njb250ZXh0JztcbmNvbnN0IF9wYXJlblN1ZmZpeCA9ICcoPzpcXFxcKCgnICtcbiAgICAnKD86XFxcXChbXikoXSpcXFxcKXxbXikoXSopKz8nICtcbiAgICAnKVxcXFwpKT8oW14se10qKSc7XG5jb25zdCBfY3NzQ29sb25Ib3N0UmUgPSBuZXcgUmVnRXhwKF9wb2x5ZmlsbEhvc3QgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbmNvbnN0IF9jc3NDb2xvbkhvc3RDb250ZXh0UmVHbG9iYWwgPSBuZXcgUmVnRXhwKF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG5jb25zdCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlID0gbmV3IFJlZ0V4cChfcG9seWZpbGxIb3N0Q29udGV4dCArIF9wYXJlblN1ZmZpeCwgJ2ltJyk7XG5jb25zdCBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yID0gX3BvbHlmaWxsSG9zdCArICctbm8tY29tYmluYXRvcic7XG5jb25zdCBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUgPSAvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcihbXlxcc10qKS87XG5jb25zdCBfc2hhZG93RE9NU2VsZWN0b3JzUmUgPSBbXG4gICAgLzo6c2hhZG93L2csXG4gICAgLzo6Y29udGVudC9nLFxuICAgIC8vIERlcHJlY2F0ZWQgc2VsZWN0b3JzXG4gICAgL1xcL3NoYWRvdy1kZWVwXFwvL2csXG4gICAgL1xcL3NoYWRvd1xcLy9nLFxuXTtcbi8vIFRoZSBkZWVwIGNvbWJpbmF0b3IgaXMgZGVwcmVjYXRlZCBpbiB0aGUgQ1NTIHNwZWNcbi8vIFN1cHBvcnQgZm9yIGA+Pj5gLCBgZGVlcGAsIGA6Om5nLWRlZXBgIGlzIHRoZW4gYWxzbyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvMTc2NzdcbmNvbnN0IF9zaGFkb3dEZWVwU2VsZWN0b3JzID0gLyg/Oj4+Pil8KD86XFwvZGVlcFxcLyl8KD86OjpuZy1kZWVwKS9nO1xuY29uc3QgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1suLHs6XVtcXFxcc1xcXFxTXSopPyQnO1xuY29uc3QgX3BvbHlmaWxsSG9zdFJlID0gLy1zaGFkb3djc3Nob3N0L2dpbTtcbmNvbnN0IF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XG5jb25zdCBfY29sb25Ib3N0Q29udGV4dFJlID0gLzpob3N0LWNvbnRleHQvZ2ltO1xuY29uc3QgX2NvbW1lbnRSZSA9IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBzdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoX2NvbW1lbnRSZSwgJycpO1xufVxuY29uc3QgX2NvbW1lbnRXaXRoSGFzaFJlID0gL1xcL1xcKlxccyojXFxzKnNvdXJjZShNYXBwaW5nKT9VUkw9W1xcc1xcU10rP1xcKlxcLy9nO1xuZnVuY3Rpb24gZXh0cmFjdENvbW1lbnRzV2l0aEhhc2goaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQubWF0Y2goX2NvbW1lbnRXaXRoSGFzaFJlKSB8fCBbXTtcbn1cbmNvbnN0IEJMT0NLX1BMQUNFSE9MREVSID0gJyVCTE9DSyUnO1xuY29uc3QgUVVPVEVfUExBQ0VIT0xERVIgPSAnJVFVT1RFRCUnO1xuY29uc3QgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG5jb25zdCBfcXVvdGVkUmUgPSAvJVFVT1RFRCUvZztcbmNvbnN0IENPTlRFTlRfUEFJUlMgPSBuZXcgTWFwKFtbJ3snLCAnfSddXSk7XG5jb25zdCBRVU9URV9QQUlSUyA9IG5ldyBNYXAoW1tgXCJgLCBgXCJgXSwgW2AnYCwgYCdgXV0pO1xuY2xhc3MgQ3NzUnVsZSB7XG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NSdWxlcyhpbnB1dCwgcnVsZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5wdXRXaXRoRXNjYXBlZFF1b3RlcyA9IGVzY2FwZUJsb2NrcyhpbnB1dCwgUVVPVEVfUEFJUlMsIFFVT1RFX1BMQUNFSE9MREVSKTtcbiAgICBjb25zdCBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzID0gZXNjYXBlQmxvY2tzKGlucHV0V2l0aEVzY2FwZWRRdW90ZXMuZXNjYXBlZFN0cmluZywgQ09OVEVOVF9QQUlSUywgQkxPQ0tfUExBQ0VIT0xERVIpO1xuICAgIGxldCBuZXh0QmxvY2tJbmRleCA9IDA7XG4gICAgbGV0IG5leHRRdW90ZUluZGV4ID0gMDtcbiAgICByZXR1cm4gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKF9ydWxlUmUsICguLi5tKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gbVsyXTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICAgICAgbGV0IHN1ZmZpeCA9IG1bNF07XG4gICAgICAgIGxldCBjb250ZW50UHJlZml4ID0gJyc7XG4gICAgICAgIGlmIChzdWZmaXggJiYgc3VmZml4LnN0YXJ0c1dpdGgoJ3snICsgQkxPQ0tfUExBQ0VIT0xERVIpKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5ibG9ja3NbbmV4dEJsb2NrSW5kZXgrK107XG4gICAgICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgY29udGVudFByZWZpeCA9ICd7JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydWxlID0gcnVsZUNhbGxiYWNrKG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSk7XG4gICAgICAgIHJldHVybiBgJHttWzFdfSR7cnVsZS5zZWxlY3Rvcn0ke21bM119JHtjb250ZW50UHJlZml4fSR7cnVsZS5jb250ZW50fSR7c3VmZml4fWA7XG4gICAgfSlcbiAgICAgICAgLnJlcGxhY2UoX3F1b3RlZFJlLCAoKSA9PiBpbnB1dFdpdGhFc2NhcGVkUXVvdGVzLmJsb2Nrc1tuZXh0UXVvdGVJbmRleCsrXSk7XG59XG5jbGFzcyBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyB7XG4gICAgY29uc3RydWN0b3IoZXNjYXBlZFN0cmluZywgYmxvY2tzKSB7XG4gICAgICAgIHRoaXMuZXNjYXBlZFN0cmluZyA9IGVzY2FwZWRTdHJpbmc7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZUJsb2NrcyhpbnB1dCwgY2hhclBhaXJzLCBwbGFjZWhvbGRlcikge1xuICAgIGNvbnN0IHJlc3VsdFBhcnRzID0gW107XG4gICAgY29uc3QgZXNjYXBlZEJsb2NrcyA9IFtdO1xuICAgIGxldCBvcGVuQ2hhckNvdW50ID0gMDtcbiAgICBsZXQgbm9uQmxvY2tTdGFydEluZGV4ID0gMDtcbiAgICBsZXQgYmxvY2tTdGFydEluZGV4ID0gLTE7XG4gICAgbGV0IG9wZW5DaGFyO1xuICAgIGxldCBjbG9zZUNoYXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyID09PSBjbG9zZUNoYXIpIHtcbiAgICAgICAgICAgIG9wZW5DaGFyQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChvcGVuQ2hhckNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGlucHV0LnN1YnN0cmluZyhibG9ja1N0YXJ0SW5kZXgsIGkpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICBub25CbG9ja1N0YXJ0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJsb2NrU3RhcnRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIG9wZW5DaGFyID0gY2xvc2VDaGFyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IG9wZW5DaGFyKSB7XG4gICAgICAgICAgICBvcGVuQ2hhckNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlbkNoYXJDb3VudCA9PT0gMCAmJiBjaGFyUGFpcnMuaGFzKGNoYXIpKSB7XG4gICAgICAgICAgICBvcGVuQ2hhciA9IGNoYXI7XG4gICAgICAgICAgICBjbG9zZUNoYXIgPSBjaGFyUGFpcnMuZ2V0KGNoYXIpO1xuICAgICAgICAgICAgb3BlbkNoYXJDb3VudCA9IDE7XG4gICAgICAgICAgICBibG9ja1N0YXJ0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIHJlc3VsdFBhcnRzLnB1c2goaW5wdXQuc3Vic3RyaW5nKG5vbkJsb2NrU3RhcnRJbmRleCwgYmxvY2tTdGFydEluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJsb2NrU3RhcnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGlucHV0LnN1YnN0cmluZyhibG9ja1N0YXJ0SW5kZXgpKTtcbiAgICAgICAgcmVzdWx0UGFydHMucHVzaChwbGFjZWhvbGRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKGlucHV0LnN1YnN0cmluZyhub25CbG9ja1N0YXJ0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyhyZXN1bHRQYXJ0cy5qb2luKCcnKSwgZXNjYXBlZEJsb2Nrcyk7XG59XG4vKipcbiAqIENvbWJpbmUgdGhlIGBjb250ZXh0U2VsZWN0b3JzYCB3aXRoIHRoZSBgaG9zdE1hcmtlcmAgYW5kIHRoZSBgb3RoZXJTZWxlY3RvcnNgXG4gKiB0byBjcmVhdGUgYSBzZWxlY3RvciB0aGF0IG1hdGNoZXMgdGhlIHNhbWUgYXMgYDpob3N0LWNvbnRleHQoKWAuXG4gKlxuICogR2l2ZW4gYSBzaW5nbGUgY29udGV4dCBzZWxlY3RvciBgQWAgd2UgbmVlZCB0byBvdXRwdXQgc2VsZWN0b3JzIHRoYXQgbWF0Y2ggb24gdGhlIGhvc3QgYW5kIGFzIGFuXG4gKiBhbmNlc3RvciBvZiB0aGUgaG9zdDpcbiAqXG4gKiBgYGBcbiAqIEEgPGhvc3RNYXJrZXI+LCBBPGhvc3RNYXJrZXI+IHt9XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY29udGV4dCBzZWxlY3RvciB3ZSBhbHNvIGhhdmUgdG8gY3JlYXRlIGNvbWJpbmF0aW9ucyBvZiB0aG9zZVxuICogc2VsZWN0b3JzIHdpdGggZWFjaCBvdGhlci4gRm9yIGV4YW1wbGUgaWYgdGhlcmUgYXJlIGBBYCBhbmQgYEJgIHNlbGVjdG9ycyB0aGUgb3V0cHV0IGlzOlxuICpcbiAqIGBgYFxuICogQUI8aG9zdE1hcmtlcj4sIEFCIDxob3N0TWFya2VyPiwgQSBCPGhvc3RNYXJrZXI+LFxuICogQiBBPGhvc3RNYXJrZXI+LCBBIEIgPGhvc3RNYXJrZXI+LCBCIEEgPGhvc3RNYXJrZXI+IHt9XG4gKiBgYGBcbiAqXG4gKiBBbmQgc28gb24uLi5cbiAqXG4gKiBAcGFyYW0gaG9zdE1hcmtlciB0aGUgc3RyaW5nIHRoYXQgc2VsZWN0cyB0aGUgaG9zdCBlbGVtZW50LlxuICogQHBhcmFtIGNvbnRleHRTZWxlY3RvcnMgYW4gYXJyYXkgb2YgY29udGV4dCBzZWxlY3RvcnMgdGhhdCB3aWxsIGJlIGNvbWJpbmVkLlxuICogQHBhcmFtIG90aGVyU2VsZWN0b3JzIHRoZSByZXN0IG9mIHRoZSBzZWxlY3RvcnMgdGhhdCBhcmUgbm90IGNvbnRleHQgc2VsZWN0b3JzLlxuICovXG5mdW5jdGlvbiBjb21iaW5lSG9zdENvbnRleHRTZWxlY3RvcnMoY29udGV4dFNlbGVjdG9ycywgb3RoZXJTZWxlY3RvcnMpIHtcbiAgICBjb25zdCBob3N0TWFya2VyID0gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcjtcbiAgICBfcG9seWZpbGxIb3N0UmUubGFzdEluZGV4ID0gMDsgLy8gcmVzZXQgdGhlIHJlZ2V4IHRvIGVuc3VyZSB3ZSBnZXQgYW4gYWNjdXJhdGUgdGVzdFxuICAgIGNvbnN0IG90aGVyU2VsZWN0b3JzSGFzSG9zdCA9IF9wb2x5ZmlsbEhvc3RSZS50ZXN0KG90aGVyU2VsZWN0b3JzKTtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY29udGV4dCBzZWxlY3RvcnMgdGhlbiBqdXN0IG91dHB1dCBhIGhvc3QgbWFya2VyXG4gICAgaWYgKGNvbnRleHRTZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBob3N0TWFya2VyICsgb3RoZXJTZWxlY3RvcnM7XG4gICAgfVxuICAgIGNvbnN0IGNvbWJpbmVkID0gW2NvbnRleHRTZWxlY3RvcnMucG9wKCkgfHwgJyddO1xuICAgIHdoaWxlIChjb250ZXh0U2VsZWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY29tYmluZWQubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb250ZXh0U2VsZWN0b3IgPSBjb250ZXh0U2VsZWN0b3JzLnBvcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1NlbGVjdG9ycyA9IGNvbWJpbmVkW2ldO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgc2VsZWN0b3IgYXMgYSBkZXNjZW5kYW50IG9mIHRoZSBwcmV2aW91cyBzZWxlY3RvcnNcbiAgICAgICAgICAgIGNvbWJpbmVkW2xlbmd0aCAqIDIgKyBpXSA9IHByZXZpb3VzU2VsZWN0b3JzICsgJyAnICsgY29udGV4dFNlbGVjdG9yO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgc2VsZWN0b3IgYXMgYW4gYW5jZXN0b3Igb2YgdGhlIHByZXZpb3VzIHNlbGVjdG9yc1xuICAgICAgICAgICAgY29tYmluZWRbbGVuZ3RoICsgaV0gPSBjb250ZXh0U2VsZWN0b3IgKyAnICcgKyBwcmV2aW91c1NlbGVjdG9ycztcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV3IHNlbGVjdG9yIHRvIGFjdCBvbiB0aGUgc2FtZSBlbGVtZW50IGFzIHRoZSBwcmV2aW91cyBzZWxlY3RvcnNcbiAgICAgICAgICAgIGNvbWJpbmVkW2ldID0gY29udGV4dFNlbGVjdG9yICsgcHJldmlvdXNTZWxlY3RvcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluYWxseSBjb25uZWN0IHRoZSBzZWxlY3RvciB0byB0aGUgYGhvc3RNYXJrZXJgczogZWl0aGVyIGFjdGluZyBkaXJlY3RseSBvbiB0aGUgaG9zdFxuICAgIC8vIChBPGhvc3RNYXJrZXI+KSBvciBhcyBhbiBhbmNlc3RvciAoQSA8aG9zdE1hcmtlcj4pLlxuICAgIHJldHVybiBjb21iaW5lZFxuICAgICAgICAubWFwKHMgPT4gb3RoZXJTZWxlY3RvcnNIYXNIb3N0ID9cbiAgICAgICAgYCR7c30ke290aGVyU2VsZWN0b3JzfWAgOlxuICAgICAgICBgJHtzfSR7aG9zdE1hcmtlcn0ke290aGVyU2VsZWN0b3JzfSwgJHtzfSAke2hvc3RNYXJrZXJ9JHtvdGhlclNlbGVjdG9yc31gKVxuICAgICAgICAuam9pbignLCcpO1xufVxuLyoqXG4gKiBNdXRhdGUgdGhlIGdpdmVuIGBncm91cHNgIGFycmF5IHNvIHRoYXQgdGhlcmUgYXJlIGBtdWx0aXBsZXNgIGNsb25lcyBvZiB0aGUgb3JpZ2luYWwgYXJyYXlcbiAqIHN0b3JlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBgcmVwZWF0R3JvdXBzKFthLCBiXSwgMylgIHdpbGwgcmVzdWx0IGluIGBbYSwgYiwgYSwgYiwgYSwgYl1gIC0gYnV0IGltcG9ydGFudGx5IHRoZVxuICogbmV3bHkgYWRkZWQgZ3JvdXBzIHdpbGwgYmUgY2xvbmVzIG9mIHRoZSBvcmlnaW5hbC5cbiAqXG4gKiBAcGFyYW0gZ3JvdXBzIEFuIGFycmF5IG9mIGdyb3VwcyBvZiBzdHJpbmdzIHRoYXQgd2lsbCBiZSByZXBlYXRlZC4gVGhpcyBhcnJheSBpcyBtdXRhdGVkXG4gKiAgICAgaW4tcGxhY2UuXG4gKiBAcGFyYW0gbXVsdGlwbGVzIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGN1cnJlbnQgZ3JvdXBzIHNob3VsZCBhcHBlYXIuXG4gKi9cbmZ1bmN0aW9uIHJlcGVhdEdyb3Vwcyhncm91cHMsIG11bHRpcGxlcykge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdyb3Vwcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtdWx0aXBsZXM7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBncm91cHNbaiArIChpICogbGVuZ3RoKV0gPSBncm91cHNbal0uc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBQYXJzZXMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgc3R5bGUgYW5kIGNvbnZlcnRzIGl0IGludG8gb2JqZWN0IGxpdGVyYWwuXG4gKlxuICogQHBhcmFtIHZhbHVlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBzdHlsZSBhcyB1c2VkIGluIHRoZSBgc3R5bGVgIGF0dHJpYnV0ZSBpbiBIVE1MLlxuICogICBFeGFtcGxlOiBgY29sb3I6IHJlZDsgaGVpZ2h0OiBhdXRvYC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0eWxlIHByb3BlcnR5IG5hbWUgYW5kIHZhbHVlIHBhaXJzLCBlLmcuIGBbJ2NvbG9yJywgJ3JlZCcsICdoZWlnaHQnLFxuICogJ2F1dG8nXWBcbiAqL1xuZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcbiAgICAvLyB3ZSB1c2UgYSBzdHJpbmcgYXJyYXkgaGVyZSBpbnN0ZWFkIG9mIGEgc3RyaW5nIG1hcFxuICAgIC8vIGJlY2F1c2UgYSBzdHJpbmctbWFwIGlzIG5vdCBndWFyYW50ZWVkIHRvIHJldGFpbiB0aGVcbiAgICAvLyBvcmRlciBvZiB0aGUgZW50cmllcyB3aGVyZWFzIGEgc3RyaW5nIGFycmF5IGNhbiBiZVxuICAgIC8vIGNvbnN0cnVjdGVkIGluIGEgW2tleSwgdmFsdWUsIGtleSwgdmFsdWVdIGZvcm1hdC5cbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHBhcmVuRGVwdGggPSAwO1xuICAgIGxldCBxdW90ZSA9IDAgLyogUXVvdGVOb25lICovO1xuICAgIGxldCB2YWx1ZVN0YXJ0ID0gMDtcbiAgICBsZXQgcHJvcFN0YXJ0ID0gMDtcbiAgICBsZXQgY3VycmVudFByb3AgPSBudWxsO1xuICAgIGxldCB2YWx1ZUhhc1F1b3RlcyA9IGZhbHNlO1xuICAgIHdoaWxlIChpIDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdmFsdWUuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIDQwIC8qIE9wZW5QYXJlbiAqLzpcbiAgICAgICAgICAgICAgICBwYXJlbkRlcHRoKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQxIC8qIENsb3NlUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgcGFyZW5EZXB0aC0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOSAvKiBRdW90ZVNpbmdsZSAqLzpcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZVN0YXJ0IG5lZWRzIHRvIGJlIHRoZXJlIHNpbmNlIHByb3AgdmFsdWVzIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBxdW90ZXMgaW4gQ1NTXG4gICAgICAgICAgICAgICAgdmFsdWVIYXNRdW90ZXMgPSB2YWx1ZUhhc1F1b3RlcyB8fCB2YWx1ZVN0YXJ0ID4gMDtcbiAgICAgICAgICAgICAgICBpZiAocXVvdGUgPT09IDAgLyogUXVvdGVOb25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gMzkgLyogUXVvdGVTaW5nbGUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1b3RlID09PSAzOSAvKiBRdW90ZVNpbmdsZSAqLyAmJiB2YWx1ZS5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gOTIgLyogQmFja1NsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gMCAvKiBRdW90ZU5vbmUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzNCAvKiBRdW90ZURvdWJsZSAqLzpcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGxvZ2ljIGFzIGFib3ZlXG4gICAgICAgICAgICAgICAgdmFsdWVIYXNRdW90ZXMgPSB2YWx1ZUhhc1F1b3RlcyB8fCB2YWx1ZVN0YXJ0ID4gMDtcbiAgICAgICAgICAgICAgICBpZiAocXVvdGUgPT09IDAgLyogUXVvdGVOb25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gMzQgLyogUXVvdGVEb3VibGUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1b3RlID09PSAzNCAvKiBRdW90ZURvdWJsZSAqLyAmJiB2YWx1ZS5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gOTIgLyogQmFja1NsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gMCAvKiBRdW90ZU5vbmUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OCAvKiBDb2xvbiAqLzpcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRQcm9wICYmIHBhcmVuRGVwdGggPT09IDAgJiYgcXVvdGUgPT09IDAgLyogUXVvdGVOb25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wID0gaHlwaGVuYXRlKHZhbHVlLnN1YnN0cmluZyhwcm9wU3RhcnQsIGkgLSAxKS50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU5IC8qIFNlbWljb2xvbiAqLzpcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb3AgJiYgdmFsdWVTdGFydCA+IDAgJiYgcGFyZW5EZXB0aCA9PT0gMCAmJiBxdW90ZSA9PT0gMCAvKiBRdW90ZU5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3R5bGVWYWwgPSB2YWx1ZS5zdWJzdHJpbmcodmFsdWVTdGFydCwgaSAtIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goY3VycmVudFByb3AsIHZhbHVlSGFzUXVvdGVzID8gc3RyaXBVbm5lY2Vzc2FyeVF1b3RlcyhzdHlsZVZhbCkgOiBzdHlsZVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzUXVvdGVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50UHJvcCAmJiB2YWx1ZVN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IHN0eWxlVmFsID0gdmFsdWUuc3Vic3RyKHZhbHVlU3RhcnQpLnRyaW0oKTtcbiAgICAgICAgc3R5bGVzLnB1c2goY3VycmVudFByb3AsIHZhbHVlSGFzUXVvdGVzID8gc3RyaXBVbm5lY2Vzc2FyeVF1b3RlcyhzdHlsZVZhbCkgOiBzdHlsZVZhbCk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG59XG5mdW5jdGlvbiBzdHJpcFVubmVjZXNzYXJ5UXVvdGVzKHZhbHVlKSB7XG4gICAgY29uc3QgcVMgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IHFFID0gdmFsdWUuY2hhckNvZGVBdCh2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICBpZiAocVMgPT0gcUUgJiYgKHFTID09IDM5IC8qIFF1b3RlU2luZ2xlICovIHx8IHFTID09IDM0IC8qIFF1b3RlRG91YmxlICovKSkge1xuICAgICAgICBjb25zdCB0ZW1wVmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB1c2luZyBhIG11bHRpLXF1b3RlZCBzdHJpbmcgdGhhdCB3YXMganVzdCBjaG9tcGVkXG4gICAgICAgIC8vIChlLmcuIGBmb250LWZhbWlseTogXCJWZXJkYW5hXCIsIFwic2Fucy1zZXJpZlwiYClcbiAgICAgICAgaWYgKHRlbXBWYWx1ZS5pbmRleE9mKCdcXCcnKSA9PSAtMSAmJiB0ZW1wVmFsdWUuaW5kZXhPZignXCInKSA9PSAtMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0ZW1wVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaHlwaGVuYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKC9bYS16XVtBLVpdL2csIHYgPT4ge1xuICAgICAgICByZXR1cm4gdi5jaGFyQXQoMCkgKyAnLScgKyB2LmNoYXJBdCgxKTtcbiAgICB9KVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbn1cblxuY29uc3QgSU1QT1JUQU5UX0ZMQUcgPSAnIWltcG9ydGFudCc7XG4vKipcbiAqIE1pbmltdW0gYW1vdW50IG9mIGJpbmRpbmcgc2xvdHMgcmVxdWlyZWQgaW4gdGhlIHJ1bnRpbWUgZm9yIHN0eWxlL2NsYXNzIGJpbmRpbmdzLlxuICpcbiAqIFN0eWxpbmcgaW4gQW5ndWxhciB1c2VzIHVwIHR3byBzbG90cyBpbiB0aGUgcnVudGltZSBMVmlldy9URGF0YSBkYXRhIHN0cnVjdHVyZXMgdG9cbiAqIHJlY29yZCBiaW5kaW5nIGRhdGEsIHByb3BlcnR5IGluZm9ybWF0aW9uIGFuZCBtZXRhZGF0YS5cbiAqXG4gKiBXaGVuIGEgYmluZGluZyBpcyByZWdpc3RlcmVkIGl0IHdpbGwgcGxhY2UgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgYExWaWV3YDpcbiAqXG4gKiBzbG90IDEpIGJpbmRpbmcgdmFsdWVcbiAqIHNsb3QgMikgY2FjaGVkIHZhbHVlIChhbGwgb3RoZXIgdmFsdWVzIGNvbGxlY3RlZCBiZWZvcmUgaXQgaW4gc3RyaW5nIGZvcm0pXG4gKlxuICogV2hlbiBhIGJpbmRpbmcgaXMgcmVnaXN0ZXJlZCBpdCB3aWxsIHBsYWNlIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb24gaW4gdGhlIGBURGF0YWA6XG4gKlxuICogc2xvdCAxKSBwcm9wIG5hbWVcbiAqIHNsb3QgMikgYmluZGluZyBpbmRleCB0aGF0IHBvaW50cyB0byB0aGUgcHJldmlvdXMgc3R5bGUvY2xhc3MgYmluZGluZyAoYW5kIHNvbWUgZXh0cmEgY29uZmlnXG4gKiB2YWx1ZXMpXG4gKlxuICogTGV0J3MgaW1hZ2luZSB3ZSBoYXZlIGEgYmluZGluZyB0aGF0IGxvb2tzIGxpa2Ugc286XG4gKlxuICogYGBgXG4gKiA8ZGl2IFtzdHlsZS53aWR0aF09XCJ4XCIgW3N0eWxlLmhlaWdodF09XCJ5XCI+XG4gKiBgYGBcbiAqXG4gKiBPdXIgYExWaWV3YCBhbmQgYFREYXRhYCBkYXRhLXN0cnVjdHVyZXMgbG9vayBsaWtlIHNvOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIExWaWV3ID0gW1xuICogICAvLyAuLi5cbiAqICAgeCwgLy8gdmFsdWUgb2YgeFxuICogICBcIndpZHRoOiB4XCIsXG4gKlxuICogICB5LCAvLyB2YWx1ZSBvZiB5XG4gKiAgIFwid2lkdGg6IHg7IGhlaWdodDogeVwiLFxuICogICAvLyAuLi5cbiAqIF07XG4gKlxuICogVERhdGEgPSBbXG4gKiAgIC8vIC4uLlxuICogICBcIndpZHRoXCIsIC8vIGJpbmRpbmcgc2xvdCAyMFxuICogICAwLFxuICpcbiAqICAgXCJoZWlnaHRcIixcbiAqICAgMjAsXG4gKiAgIC8vIC4uLlxuICogXTtcbiAqIGBgYFxuICpcbiAqICovXG5jb25zdCBNSU5fU1RZTElOR19CSU5ESU5HX1NMT1RTX1JFUVVJUkVEID0gMjtcbi8qKlxuICogUHJvZHVjZXMgY3JlYXRpb24vdXBkYXRlIGluc3RydWN0aW9ucyBmb3IgYWxsIHN0eWxpbmcgYmluZGluZ3MgKGNsYXNzIGFuZCBzdHlsZSlcbiAqXG4gKiBJdCBhbHNvIHByb2R1Y2VzIHRoZSBjcmVhdGlvbiBpbnN0cnVjdGlvbiB0byByZWdpc3RlciBhbGwgaW5pdGlhbCBzdHlsaW5nIHZhbHVlc1xuICogKHdoaWNoIGFyZSBhbGwgdGhlIHN0YXRpYyBjbGFzcz1cIi4uLlwiIGFuZCBzdHlsZT1cIi4uLlwiIGF0dHJpYnV0ZSB2YWx1ZXMgdGhhdCBleGlzdFxuICogb24gYW4gZWxlbWVudCB3aXRoaW4gYSB0ZW1wbGF0ZSkuXG4gKlxuICogVGhlIGJ1aWxkZXIgY2xhc3MgYmVsb3cgaGFuZGxlcyBwcm9kdWNpbmcgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICpcbiAqIC0gU3RhdGljIHN0eWxlL2NsYXNzIGF0dHJpYnV0ZXMgKHN0eWxlPVwiLi4uXCIgYW5kIGNsYXNzPVwiLi4uXCIpXG4gKiAtIER5bmFtaWMgc3R5bGUvY2xhc3MgbWFwIGJpbmRpbmdzIChbc3R5bGVdPVwibWFwXCIgYW5kIFtjbGFzc109XCJtYXB8c3RyaW5nXCIpXG4gKiAtIER5bmFtaWMgc3R5bGUvY2xhc3MgcHJvcGVydHkgYmluZGluZ3MgKFtzdHlsZS5wcm9wXT1cImV4cFwiIGFuZCBbY2xhc3MubmFtZV09XCJleHBcIilcbiAqXG4gKiBEdWUgdG8gdGhlIGNvbXBsZXggcmVsYXRpb25zaGlwIG9mIGFsbCBvZiB0aGVzZSBjYXNlcywgdGhlIGluc3RydWN0aW9ucyBnZW5lcmF0ZWRcbiAqIGZvciB0aGVzZSBhdHRyaWJ1dGVzL3Byb3BlcnRpZXMvYmluZGluZ3MgbXVzdCBiZSBkb25lIHNvIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBUaGVcbiAqIG9yZGVyIHdoaWNoIHRoZXNlIG11c3QgYmUgZ2VuZXJhdGVkIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogaWYgKGNyZWF0ZU1vZGUpIHtcbiAqICAgc3R5bGluZyguLi4pXG4gKiB9XG4gKiBpZiAodXBkYXRlTW9kZSkge1xuICogICBzdHlsZU1hcCguLi4pXG4gKiAgIGNsYXNzTWFwKC4uLilcbiAqICAgc3R5bGVQcm9wKC4uLilcbiAqICAgY2xhc3NQcm9wKC4uLilcbiAqIH1cbiAqXG4gKiBUaGUgY3JlYXRpb24vdXBkYXRlIG1ldGhvZHMgd2l0aGluIHRoZSBidWlsZGVyIGNsYXNzIHByb2R1Y2UgdGhlc2UgaW5zdHJ1Y3Rpb25zLlxuICovXG5jbGFzcyBTdHlsaW5nQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoX2RpcmVjdGl2ZUV4cHIpIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlRXhwciA9IF9kaXJlY3RpdmVFeHByO1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBzdGF0aWMgc3R5bGluZyB2YWx1ZXMgcHJlc2VudCAqL1xuICAgICAgICB0aGlzLl9oYXNJbml0aWFsVmFsdWVzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgV2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBzdHlsaW5nIGJpbmRpbmdzIHByZXNlbnRcbiAgICAgICAgICogIChpLmUuIGBbc3R5bGVdYCwgYFtjbGFzc11gLCBgW3N0eWxlLnByb3BdYCBvciBgW2NsYXNzLm5hbWVdYClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQmluZGluZ3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNCaW5kaW5nc1dpdGhQaXBlcyA9IGZhbHNlO1xuICAgICAgICAvKiogdGhlIGlucHV0IGZvciBbY2xhc3NdIChpZiBpdCBleGlzdHMpICovXG4gICAgICAgIHRoaXMuX2NsYXNzTWFwSW5wdXQgPSBudWxsO1xuICAgICAgICAvKiogdGhlIGlucHV0IGZvciBbc3R5bGVdIChpZiBpdCBleGlzdHMpICovXG4gICAgICAgIHRoaXMuX3N0eWxlTWFwSW5wdXQgPSBudWxsO1xuICAgICAgICAvKiogYW4gYXJyYXkgb2YgZWFjaCBbc3R5bGUucHJvcF0gaW5wdXQgKi9cbiAgICAgICAgdGhpcy5fc2luZ2xlU3R5bGVJbnB1dHMgPSBudWxsO1xuICAgICAgICAvKiogYW4gYXJyYXkgb2YgZWFjaCBbY2xhc3MubmFtZV0gaW5wdXQgKi9cbiAgICAgICAgdGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0U3R5bGluZ0lucHV0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQgPSBudWxsO1xuICAgICAgICAvLyBtYXBzIGFyZSB1c2VkIGluc3RlYWQgb2YgaGFzaCBtYXBzIGJlY2F1c2UgYSBNYXAgd2lsbFxuICAgICAgICAvLyByZXRhaW4gdGhlIG9yZGVyaW5nIG9mIHRoZSBrZXlzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSBsb2NhdGlvbiBvZiBlYWNoIHN0eWxlIGJpbmRpbmcgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAgICAqIChlLmcuIGA8ZGl2IFtzdHlsZS53aWR0aF09XCJ3XCIgW3N0eWxlLmhlaWdodF09XCJoXCI+YCBpbXBsaWVzXG4gICAgICAgICAqIHRoYXQgYHdpZHRoPTBgIGFuZCBgaGVpZ2h0PTFgKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3R5bGVzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSBsb2NhdGlvbiBvZiBlYWNoIGNsYXNzIGJpbmRpbmcgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAgICAqIChlLmcuIGA8ZGl2IFtjbGFzcy5iaWddPVwiYlwiIFtjbGFzcy5oaWRkZW5dPVwiaFwiPmAgaW1wbGllc1xuICAgICAgICAgKiB0aGF0IGBiaWc9MGAgYW5kIGBoaWRkZW49MWApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jbGFzc2VzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NWYWx1ZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZ2l2ZW4gaW5wdXQgdG8gdGhlIHN0eWxpbmcgYnVpbGRlciB0byBiZSBsYXRlciB1c2VkIHdoZW4gcHJvZHVjaW5nIEFPVCBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIGNvZGUgYmVsb3cgd2lsbCBvbmx5IGFjY2VwdCB0aGUgaW5wdXQgaWYgaXQgaXMgc29tZWhvdyB0aWVkIHRvIHN0eWxpbmcgKHdoZXRoZXIgaXQgYmVcbiAgICAgKiBzdHlsZS9jbGFzcyBiaW5kaW5ncyBvciBzdGF0aWMgc3R5bGUvY2xhc3MgYXR0cmlidXRlcykuXG4gICAgICovXG4gICAgcmVnaXN0ZXJCb3VuZElucHV0KGlucHV0KSB7XG4gICAgICAgIC8vIFthdHRyLnN0eWxlXSBvciBbYXR0ci5jbGFzc10gYXJlIHNraXBwZWQgaW4gdGhlIGNvZGUgYmVsb3csXG4gICAgICAgIC8vIHRoZXkgc2hvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIHN0eWxpbmctYmFzZWQgYmluZGluZ3Mgc2luY2VcbiAgICAgICAgLy8gdGhleSBhcmUgaW50ZW5kZWQgdG8gYmUgd3JpdHRlbiBkaXJlY3RseSB0byB0aGUgYXR0ciBhbmRcbiAgICAgICAgLy8gd2lsbCB0aGVyZWZvcmUgc2tpcCBhbGwgc3R5bGUvY2xhc3MgcmVzb2x1dGlvbiB0aGF0IGlzIHByZXNlbnRcbiAgICAgICAgLy8gd2l0aCBzdHlsZT1cIlwiLCBbc3R5bGVdPVwiXCIgYW5kIFtzdHlsZS5wcm9wXT1cIlwiLCBjbGFzcz1cIlwiLFxuICAgICAgICAvLyBbY2xhc3MucHJvcF09XCJcIi4gW2NsYXNzXT1cIlwiIGFzc2lnbm1lbnRzXG4gICAgICAgIGxldCBiaW5kaW5nID0gbnVsbDtcbiAgICAgICAgbGV0IG5hbWUgPSBpbnB1dC5uYW1lO1xuICAgICAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBQcm9wZXJ0eSAqLzpcbiAgICAgICAgICAgICAgICBiaW5kaW5nID0gdGhpcy5yZWdpc3RlcklucHV0QmFzZWRPbk5hbWUobmFtZSwgaW5wdXQudmFsdWUsIGlucHV0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFN0eWxlICovOlxuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVyU3R5bGVJbnB1dChuYW1lLCBmYWxzZSwgaW5wdXQudmFsdWUsIGlucHV0LnNvdXJjZVNwYW4sIGlucHV0LnVuaXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIENsYXNzICovOlxuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVyQ2xhc3NJbnB1dChuYW1lLCBmYWxzZSwgaW5wdXQudmFsdWUsIGlucHV0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICByZWdpc3RlcklucHV0QmFzZWRPbk5hbWUobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3Bhbikge1xuICAgICAgICBsZXQgYmluZGluZyA9IG51bGw7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWUuc3Vic3RyaW5nKDAsIDYpO1xuICAgICAgICBjb25zdCBpc1N0eWxlID0gbmFtZSA9PT0gJ3N0eWxlJyB8fCBwcmVmaXggPT09ICdzdHlsZS4nIHx8IHByZWZpeCA9PT0gJ3N0eWxlISc7XG4gICAgICAgIGNvbnN0IGlzQ2xhc3MgPSAhaXNTdHlsZSAmJiAobmFtZSA9PT0gJ2NsYXNzJyB8fCBwcmVmaXggPT09ICdjbGFzcy4nIHx8IHByZWZpeCA9PT0gJ2NsYXNzIScpO1xuICAgICAgICBpZiAoaXNTdHlsZSB8fCBpc0NsYXNzKSB7XG4gICAgICAgICAgICBjb25zdCBpc01hcEJhc2VkID0gbmFtZS5jaGFyQXQoNSkgIT09ICcuJzsgLy8gc3R5bGUucHJvcCBvciBjbGFzcy5wcm9wIG1ha2VzIHRoaXMgYSBub1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBuYW1lLnN1YnN0cihpc01hcEJhc2VkID8gNSA6IDYpOyAvLyB0aGUgZG90IGV4cGxhaW5zIHdoeSB0aGVyZSdzIGEgKzFcbiAgICAgICAgICAgIGlmIChpc1N0eWxlKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMucmVnaXN0ZXJTdHlsZUlucHV0KHByb3BlcnR5LCBpc01hcEJhc2VkLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVyQ2xhc3NJbnB1dChwcm9wZXJ0eSwgaXNNYXBCYXNlZCwgZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbmRpbmc7XG4gICAgfVxuICAgIHJlZ2lzdGVyU3R5bGVJbnB1dChuYW1lLCBpc01hcEJhc2VkLCB2YWx1ZSwgc291cmNlU3Bhbiwgc3VmZml4KSB7XG4gICAgICAgIGlmIChpc0VtcHR5RXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENTUyBjdXN0b20gcHJvcGVydGllcyBhcmUgY2FzZS1zZW5zaXRpdmUgc28gd2Ugc2hvdWxkbid0IG5vcm1hbGl6ZSB0aGVtLlxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtdmFyaWFibGVzLTEvI2RlZmluaW5nLXZhcmlhYmxlc1xuICAgICAgICBpZiAoIWlzQ3NzQ3VzdG9tUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBoeXBoZW5hdGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0eSwgaGFzT3ZlcnJpZGVGbGFnLCBzdWZmaXg6IGJpbmRpbmdTdWZmaXggfSA9IHBhcnNlUHJvcGVydHkobmFtZSk7XG4gICAgICAgIHN1ZmZpeCA9IHR5cGVvZiBzdWZmaXggPT09ICdzdHJpbmcnICYmIHN1ZmZpeC5sZW5ndGggIT09IDAgPyBzdWZmaXggOiBiaW5kaW5nU3VmZml4O1xuICAgICAgICBjb25zdCBlbnRyeSA9IHsgbmFtZTogcHJvcGVydHksIHN1ZmZpeDogc3VmZml4LCB2YWx1ZSwgc291cmNlU3BhbiwgaGFzT3ZlcnJpZGVGbGFnIH07XG4gICAgICAgIGlmIChpc01hcEJhc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZU1hcElucHV0ID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAodGhpcy5fc2luZ2xlU3R5bGVJbnB1dHMgPSB0aGlzLl9zaW5nbGVTdHlsZUlucHV0cyB8fCBbXSkucHVzaChlbnRyeSk7XG4gICAgICAgICAgICByZWdpc3RlckludG9NYXAodGhpcy5fc3R5bGVzSW5kZXgsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U3R5bGluZ0lucHV0ID0gZW50cnk7XG4gICAgICAgIHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0ID0gdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQgfHwgZW50cnk7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9yUGlwZXModmFsdWUpO1xuICAgICAgICB0aGlzLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgICByZWdpc3RlckNsYXNzSW5wdXQobmFtZSwgaXNNYXBCYXNlZCwgdmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgaWYgKGlzRW1wdHlFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0eSwgaGFzT3ZlcnJpZGVGbGFnIH0gPSBwYXJzZVByb3BlcnR5KG5hbWUpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHsgbmFtZTogcHJvcGVydHksIHZhbHVlLCBzb3VyY2VTcGFuLCBoYXNPdmVycmlkZUZsYWcsIHN1ZmZpeDogbnVsbCB9O1xuICAgICAgICBpZiAoaXNNYXBCYXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2xhc3NNYXBJbnB1dCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHRoaXMuX3NpbmdsZUNsYXNzSW5wdXRzID0gdGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMgfHwgW10pLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgcmVnaXN0ZXJJbnRvTWFwKHRoaXMuX2NsYXNzZXNJbmRleCwgcHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RTdHlsaW5nSW5wdXQgPSBlbnRyeTtcbiAgICAgICAgdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQgPSB0aGlzLl9maXJzdFN0eWxpbmdJbnB1dCB8fCBlbnRyeTtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JQaXBlcyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIF9jaGVja0ZvclBpcGVzKHZhbHVlKSB7XG4gICAgICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBBU1RXaXRoU291cmNlKSAmJiAodmFsdWUuYXN0IGluc3RhbmNlb2YgQmluZGluZ1BpcGUpKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0JpbmRpbmdzV2l0aFBpcGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGVsZW1lbnQncyBzdGF0aWMgc3R5bGUgc3RyaW5nIHZhbHVlIHRvIHRoZSBidWlsZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSBzdHlsZSBzdHJpbmcgKGUuZy4gYHdpZHRoOjEwMHB4OyBoZWlnaHQ6MjAwcHg7YClcbiAgICAgKi9cbiAgICByZWdpc3RlclN0eWxlQXR0cih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXMgPSBwYXJzZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2hhc0luaXRpYWxWYWx1ZXMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGVsZW1lbnQncyBzdGF0aWMgY2xhc3Mgc3RyaW5nIHZhbHVlIHRvIHRoZSBidWlsZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSBjbGFzc05hbWUgc3RyaW5nIChlLmcuIGBkaXNhYmxlZCBnb2xkIHpvb21gKVxuICAgICAqL1xuICAgIHJlZ2lzdGVyQ2xhc3NBdHRyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlcyA9IHZhbHVlLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbiAgICAgICAgdGhpcy5faGFzSW5pdGlhbFZhbHVlcyA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYWxsIHN0eWxpbmctcmVsYXRlZCBleHByZXNzaW9ucyB0byB0aGUgcHJvdmlkZWQgYXR0cnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXR0cnMgYW4gZXhpc3RpbmcgYXJyYXkgd2hlcmUgZWFjaCBvZiB0aGUgc3R5bGluZyBleHByZXNzaW9uc1xuICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQgaW50by5cbiAgICAgKi9cbiAgICBwb3B1bGF0ZUluaXRpYWxTdHlsaW5nQXR0cnMoYXR0cnMpIHtcbiAgICAgICAgLy8gW0NMQVNTX01BUktFUiwgJ2ZvbycsICdiYXInLCAnYmF6JyAuLi5dXG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsQ2xhc3NWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRycy5wdXNoKGxpdGVyYWwoMSAvKiBDbGFzc2VzICovKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2gobGl0ZXJhbCh0aGlzLl9pbml0aWFsQ2xhc3NWYWx1ZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBbU1RZTEVfTUFSS0VSLCAnd2lkdGgnLCAnMjAwcHgnLCAnaGVpZ2h0JywgJzEwMHB4JywgLi4uXVxuICAgICAgICBpZiAodGhpcy5faW5pdGlhbFN0eWxlVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXR0cnMucHVzaChsaXRlcmFsKDIgLyogU3R5bGVzICovKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2gobGl0ZXJhbCh0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXNbaV0pLCBsaXRlcmFsKHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlc1tpICsgMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gaW5zdHJ1Y3Rpb24gd2l0aCBhbGwgdGhlIGV4cHJlc3Npb25zIGFuZCBwYXJhbWV0ZXJzIGZvciBgZWxlbWVudEhvc3RBdHRyc2AuXG4gICAgICpcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gZ2VuZXJhdGlvbiBjb2RlIGJlbG93IGlzIHVzZWQgZm9yIHByb2R1Y2luZyB0aGUgQU9UIHN0YXRlbWVudCBjb2RlIHdoaWNoIGlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIHJlZ2lzdGVyaW5nIGluaXRpYWwgc3R5bGVzICh3aXRoaW4gYSBkaXJlY3RpdmUgaG9zdEJpbmRpbmdzJyBjcmVhdGlvbiBibG9jayksXG4gICAgICogYXMgd2VsbCBhcyBhbnkgb2YgdGhlIHByb3ZpZGVkIGF0dHJpYnV0ZSB2YWx1ZXMsIHRvIHRoZSBkaXJlY3RpdmUgaG9zdCBlbGVtZW50LlxuICAgICAqL1xuICAgIGFzc2lnbkhvc3RBdHRycyhhdHRycywgZGVmaW5pdGlvbk1hcCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aXZlRXhwciAmJiAoYXR0cnMubGVuZ3RoIHx8IHRoaXMuX2hhc0luaXRpYWxWYWx1ZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVsYXRlSW5pdGlhbFN0eWxpbmdBdHRycyhhdHRycyk7XG4gICAgICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaG9zdEF0dHJzJywgbGl0ZXJhbEFycihhdHRycykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiBpbnN0cnVjdGlvbiB3aXRoIGFsbCB0aGUgZXhwcmVzc2lvbnMgYW5kIHBhcmFtZXRlcnMgZm9yIGBjbGFzc01hcGAuXG4gICAgICpcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gZGF0YSB3aWxsIGNvbnRhaW4gYWxsIGV4cHJlc3Npb25zIGZvciBgY2xhc3NNYXBgIHRvIGZ1bmN0aW9uXG4gICAgICogd2hpY2ggaW5jbHVkZXMgdGhlIGBbY2xhc3NdYCBleHByZXNzaW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgICBidWlsZENsYXNzTWFwSW5zdHJ1Y3Rpb24odmFsdWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NsYXNzTWFwSW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZE1hcEJhc2VkSW5zdHJ1Y3Rpb24odmFsdWVDb252ZXJ0ZXIsIHRydWUsIHRoaXMuX2NsYXNzTWFwSW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gaW5zdHJ1Y3Rpb24gd2l0aCBhbGwgdGhlIGV4cHJlc3Npb25zIGFuZCBwYXJhbWV0ZXJzIGZvciBgc3R5bGVNYXBgLlxuICAgICAqXG4gICAgICogVGhlIGluc3RydWN0aW9uIGRhdGEgd2lsbCBjb250YWluIGFsbCBleHByZXNzaW9ucyBmb3IgYHN0eWxlTWFwYCB0byBmdW5jdGlvblxuICAgICAqIHdoaWNoIGluY2x1ZGVzIHRoZSBgW3N0eWxlXWAgZXhwcmVzc2lvbiBwYXJhbXMuXG4gICAgICovXG4gICAgYnVpbGRTdHlsZU1hcEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZU1hcElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRNYXBCYXNlZEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyLCBmYWxzZSwgdGhpcy5fc3R5bGVNYXBJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9idWlsZE1hcEJhc2VkSW5zdHJ1Y3Rpb24odmFsdWVDb252ZXJ0ZXIsIGlzQ2xhc3NCYXNlZCwgc3R5bGluZ0lucHV0KSB7XG4gICAgICAgIC8vIGVhY2ggc3R5bGluZyBiaW5kaW5nIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgTFZpZXdcbiAgICAgICAgLy8gbWFwLWJhc2VkIGJpbmRpbmdzIGFsbG9jYXRlIHR3byBzbG90czogb25lIGZvciB0aGVcbiAgICAgICAgLy8gcHJldmlvdXMgYmluZGluZyB2YWx1ZSBhbmQgYW5vdGhlciBmb3IgdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIGNsYXNzTmFtZSBvciBzdHlsZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgIGxldCB0b3RhbEJpbmRpbmdTbG90c1JlcXVpcmVkID0gTUlOX1NUWUxJTkdfQklORElOR19TTE9UU19SRVFVSVJFRDtcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIG11c3QgYmUgb3V0c2lkZSBvZiB0aGUgdXBkYXRlIGJsb2NrIHNvIHRoYXQgdGhleSBjYW5cbiAgICAgICAgLy8gYmUgZXZhbHVhdGVkICh0aGUgQVNUIHZpc2l0IGNhbGwpIGR1cmluZyBjcmVhdGlvbiB0aW1lIHNvIHRoYXQgYW55XG4gICAgICAgIC8vIHBpcGVzIGNhbiBiZSBwaWNrZWQgdXAgaW4gdGltZSBiZWZvcmUgdGhlIHRlbXBsYXRlIGlzIGJ1aWx0XG4gICAgICAgIGNvbnN0IG1hcFZhbHVlID0gc3R5bGluZ0lucHV0LnZhbHVlLnZpc2l0KHZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgbGV0IHJlZmVyZW5jZTtcbiAgICAgICAgaWYgKG1hcFZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCArPSBtYXBWYWx1ZS5leHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICByZWZlcmVuY2UgPSBpc0NsYXNzQmFzZWQgPyBnZXRDbGFzc01hcEludGVycG9sYXRpb25FeHByZXNzaW9uKG1hcFZhbHVlKSA6XG4gICAgICAgICAgICAgICAgZ2V0U3R5bGVNYXBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihtYXBWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWZlcmVuY2UgPSBpc0NsYXNzQmFzZWQgPyBJZGVudGlmaWVycyQxLmNsYXNzTWFwIDogSWRlbnRpZmllcnMkMS5zdHlsZU1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgY2FsbHM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRzSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3Bhbjogc3R5bGluZ0lucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgIGFsbG9jYXRlQmluZGluZ1Nsb3RzOiB0b3RhbEJpbmRpbmdTbG90c1JlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IChjb252ZXJ0Rm4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRSZXN1bHQgPSBjb252ZXJ0Rm4obWFwVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gQXJyYXkuaXNBcnJheShjb252ZXJ0UmVzdWx0KSA/IGNvbnZlcnRSZXN1bHQgOiBbY29udmVydFJlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2J1aWxkU2luZ2xlSW5wdXRzKHJlZmVyZW5jZSwgaW5wdXRzLCB2YWx1ZUNvbnZlcnRlciwgZ2V0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb25GbiwgaXNDbGFzc0Jhc2VkKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0luc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2luc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQudmFsdWUudmlzaXQodmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZUZvckNhbGwgPSByZWZlcmVuY2U7XG4gICAgICAgICAgICAvLyBlYWNoIHN0eWxpbmcgYmluZGluZyB2YWx1ZSBpcyBzdG9yZWQgaW4gdGhlIExWaWV3XG4gICAgICAgICAgICAvLyBidXQgdGhlcmUgYXJlIHR3byB2YWx1ZXMgc3RvcmVkIGZvciBlYWNoIGJpbmRpbmc6XG4gICAgICAgICAgICAvLyAgIDEpIHRoZSB2YWx1ZSBpdHNlbGZcbiAgICAgICAgICAgIC8vICAgMikgYW4gaW50ZXJtZWRpYXRlIHZhbHVlIChjb25jYXRlbmF0aW9uIG9mIHN0eWxlIHVwIHRvIHRoaXMgcG9pbnQpLlxuICAgICAgICAgICAgLy8gICAgICBXZSBuZWVkIHRvIHN0b3JlIHRoZSBpbnRlcm1lZGlhdGUgdmFsdWUgc28gdGhhdCB3ZSBkb24ndCBhbGxvY2F0ZVxuICAgICAgICAgICAgLy8gICAgICB0aGUgc3RyaW5ncyBvbiBlYWNoIENELlxuICAgICAgICAgICAgbGV0IHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQgPSBNSU5fU1RZTElOR19CSU5ESU5HX1NMT1RTX1JFUVVJUkVEO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQgKz0gdmFsdWUuZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChnZXRJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbkZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZUZvckNhbGwgPSBnZXRJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbkZuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWxsID0ge1xuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgYWxsb2NhdGVCaW5kaW5nU2xvdHM6IHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNJbnRlcnBvbGF0aW9uOiAhIWdldEludGVycG9sYXRpb25FeHByZXNzaW9uRm4sXG4gICAgICAgICAgICAgICAgcGFyYW1zOiAoY29udmVydEZuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmFtcyA9PiBzdHlsaW5nUHJvcChwcm9wTmFtZSwgdmFsdWUsIHN1ZmZpeClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoaW5wdXQubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0UmVzdWx0ID0gY29udmVydEZuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udmVydFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKC4uLmNvbnZlcnRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goY29udmVydFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gW3N0eWxlLnByb3BdIGJpbmRpbmdzIG1heSB1c2Ugc3VmZml4IHZhbHVlcyAoZS5nLiBweCwgZW0sIGV0Yy4uLiksIHRoZXJlZm9yZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhhdCBpcyBkZXRlY3RlZCB0aGVuIHdlIG5lZWQgdG8gcGFzcyB0aGF0IGluIGFzIGFuIG9wdGlvbmFsIHBhcmFtLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2xhc3NCYXNlZCAmJiBpbnB1dC5zdWZmaXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoaW5wdXQuc3VmZml4KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gSWYgd2UgZW5kZWQgdXAgZ2VuZXJhdGluZyBhIGNhbGwgdG8gdGhlIHNhbWUgaW5zdHJ1Y3Rpb24gYXMgdGhlIHByZXZpb3VzIHN0eWxpbmcgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjaGFpbiB0aGUgY2FsbHMgdG9nZXRoZXIgc2FmZWx5IHRvIHNhdmUgc29tZSBieXRlcywgb3RoZXJ3aXNlIHdlIGhhdmUgdG8gZ2VuZXJhdGVcbiAgICAgICAgICAgIC8vIGEgc2VwYXJhdGUgaW5zdHJ1Y3Rpb24gY2FsbC4gVGhpcyBpcyBwcmltYXJpbHkgYSBjb25jZXJuIHdpdGggaW50ZXJwb2xhdGlvbiBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAgIC8vIHdoZXJlIHdlIG1heSBzdGFydCBvZmYgd2l0aCBvbmUgYHJlZmVyZW5jZWAsIGJ1dCBlbmQgdXAgdXNpbmcgYW5vdGhlciBiYXNlZCBvbiB0aGVcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBpbnRlcnBvbGF0aW9ucy5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c0luc3RydWN0aW9uICYmIHByZXZpb3VzSW5zdHJ1Y3Rpb24ucmVmZXJlbmNlID09PSByZWZlcmVuY2VGb3JDYWxsKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNJbnN0cnVjdGlvbi5jYWxscy5wdXNoKGNhbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goeyByZWZlcmVuY2U6IHJlZmVyZW5jZUZvckNhbGwsIGNhbGxzOiBbY2FsbF0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBfYnVpbGRDbGFzc0lucHV0cyh2YWx1ZUNvbnZlcnRlcikge1xuICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZFNpbmdsZUlucHV0cyhJZGVudGlmaWVycyQxLmNsYXNzUHJvcCwgdGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMsIHZhbHVlQ29udmVydGVyLCBudWxsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIF9idWlsZFN0eWxlSW5wdXRzKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaW5nbGVTdHlsZUlucHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2luZ2xlSW5wdXRzKElkZW50aWZpZXJzJDEuc3R5bGVQcm9wLCB0aGlzLl9zaW5nbGVTdHlsZUlucHV0cywgdmFsdWVDb252ZXJ0ZXIsIGdldFN0eWxlUHJvcEludGVycG9sYXRpb25FeHByZXNzaW9uLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFsbCBpbnN0cnVjdGlvbnMgd2hpY2ggY29udGFpbiB0aGUgZXhwcmVzc2lvbnMgdGhhdCB3aWxsIGJlIHBsYWNlZFxuICAgICAqIGludG8gdGhlIHVwZGF0ZSBibG9jayBvZiBhIHRlbXBsYXRlIGZ1bmN0aW9uIG9yIGEgZGlyZWN0aXZlIGhvc3RCaW5kaW5ncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBidWlsZFVwZGF0ZUxldmVsSW5zdHJ1Y3Rpb25zKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5oYXNCaW5kaW5ncykge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVNYXBJbnN0cnVjdGlvbiA9IHRoaXMuYnVpbGRTdHlsZU1hcEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgIGlmIChzdHlsZU1hcEluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goc3R5bGVNYXBJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbGFzc01hcEluc3RydWN0aW9uID0gdGhpcy5idWlsZENsYXNzTWFwSW5zdHJ1Y3Rpb24odmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTWFwSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaChjbGFzc01hcEluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKC4uLnRoaXMuX2J1aWxkU3R5bGVJbnB1dHModmFsdWVDb252ZXJ0ZXIpKTtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKC4uLnRoaXMuX2J1aWxkQ2xhc3NJbnB1dHModmFsdWVDb252ZXJ0ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVySW50b01hcChtYXAsIGtleSkge1xuICAgIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBtYXAuc2l6ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eShuYW1lKSB7XG4gICAgbGV0IGhhc092ZXJyaWRlRmxhZyA9IGZhbHNlO1xuICAgIGNvbnN0IG92ZXJyaWRlSW5kZXggPSBuYW1lLmluZGV4T2YoSU1QT1JUQU5UX0ZMQUcpO1xuICAgIGlmIChvdmVycmlkZUluZGV4ICE9PSAtMSkge1xuICAgICAgICBuYW1lID0gb3ZlcnJpZGVJbmRleCA+IDAgPyBuYW1lLnN1YnN0cmluZygwLCBvdmVycmlkZUluZGV4KSA6ICcnO1xuICAgICAgICBoYXNPdmVycmlkZUZsYWcgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgc3VmZml4ID0gbnVsbDtcbiAgICBsZXQgcHJvcGVydHkgPSBuYW1lO1xuICAgIGNvbnN0IHVuaXRJbmRleCA9IG5hbWUubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAodW5pdEluZGV4ID4gMCkge1xuICAgICAgICBzdWZmaXggPSBuYW1lLnN1YnN0cih1bml0SW5kZXggKyAxKTtcbiAgICAgICAgcHJvcGVydHkgPSBuYW1lLnN1YnN0cmluZygwLCB1bml0SW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4geyBwcm9wZXJ0eSwgc3VmZml4LCBoYXNPdmVycmlkZUZsYWcgfTtcbn1cbi8qKlxuICogR2V0cyB0aGUgaW5zdHJ1Y3Rpb24gdG8gZ2VuZXJhdGUgZm9yIGFuIGludGVycG9sYXRlZCBjbGFzcyBtYXAuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRDbGFzc01hcEludGVycG9sYXRpb25FeHByZXNzaW9uKGludGVycG9sYXRpb24pIHtcbiAgICBzd2l0Y2ggKGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlMTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXBJbnRlcnBvbGF0ZTI7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwSW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlNDtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwSW50ZXJwb2xhdGU1O1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXBJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5jbGFzc01hcEludGVycG9sYXRlNztcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmNsYXNzTWFwSW50ZXJwb2xhdGU4O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuY2xhc3NNYXBJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgYW4gaW50ZXJwb2xhdGVkIHN0eWxlIG1hcC5cbiAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uIEFuIEludGVycG9sYXRpb24gQVNUXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlTWFwSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVNYXA7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlTWFwSW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVNYXBJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlTWFwSW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVNYXBJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlTWFwSW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVNYXBJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZU1hcEludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgc3R5bGUgcHJvcC5cbiAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uIEFuIEludGVycG9sYXRpb24gQVNUXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlUHJvcEludGVycG9sYXRpb25FeHByZXNzaW9uKGludGVycG9sYXRpb24pIHtcbiAgICBzd2l0Y2ggKGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlUHJvcDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5zdHlsZVByb3BJbnRlcnBvbGF0ZTI7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnN0eWxlUHJvcEludGVycG9sYXRlMztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGU1O1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGU2O1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGU4O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuc3R5bGVQcm9wSW50ZXJwb2xhdGVWO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgcHJvcGVydHkgbmFtZSBpcyBhIGN1c3RvbSBDU1MgcHJvcGVydHkuXG4gKiBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtdmFyaWFibGVzLTFcbiAqL1xuZnVuY3Rpb24gaXNDc3NDdXN0b21Qcm9wZXJ0eShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aCgnLS0nKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlFeHByZXNzaW9uKGFzdCkge1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBBU1RXaXRoU291cmNlKSB7XG4gICAgICAgIGFzdCA9IGFzdC5hc3Q7XG4gICAgfVxuICAgIHJldHVybiBhc3QgaW5zdGFuY2VvZiBFbXB0eUV4cHI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFRva2VuVHlwZTtcbihmdW5jdGlvbiAoVG9rZW5UeXBlKSB7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkNoYXJhY3RlclwiXSA9IDBdID0gXCJDaGFyYWN0ZXJcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiSWRlbnRpZmllclwiXSA9IDFdID0gXCJJZGVudGlmaWVyXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlByaXZhdGVJZGVudGlmaWVyXCJdID0gMl0gPSBcIlByaXZhdGVJZGVudGlmaWVyXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIktleXdvcmRcIl0gPSAzXSA9IFwiS2V5d29yZFwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJTdHJpbmdcIl0gPSA0XSA9IFwiU3RyaW5nXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk9wZXJhdG9yXCJdID0gNV0gPSBcIk9wZXJhdG9yXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIk51bWJlclwiXSA9IDZdID0gXCJOdW1iZXJcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiRXJyb3JcIl0gPSA3XSA9IFwiRXJyb3JcIjtcbn0pKFRva2VuVHlwZSB8fCAoVG9rZW5UeXBlID0ge30pKTtcbmNvbnN0IEtFWVdPUkRTID0gWyd2YXInLCAnbGV0JywgJ2FzJywgJ251bGwnLCAndW5kZWZpbmVkJywgJ3RydWUnLCAnZmFsc2UnLCAnaWYnLCAnZWxzZScsICd0aGlzJ107XG5jbGFzcyBMZXhlciB7XG4gICAgdG9rZW5pemUodGV4dCkge1xuICAgICAgICBjb25zdCBzY2FubmVyID0gbmV3IF9TY2FubmVyKHRleHQpO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgICAgbGV0IHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgd2hpbGUgKHRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cbmNsYXNzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihpbmRleCwgZW5kLCB0eXBlLCBudW1WYWx1ZSwgc3RyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5udW1WYWx1ZSA9IG51bVZhbHVlO1xuICAgICAgICB0aGlzLnN0clZhbHVlID0gc3RyVmFsdWU7XG4gICAgfVxuICAgIGlzQ2hhcmFjdGVyKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuQ2hhcmFjdGVyICYmIHRoaXMubnVtVmFsdWUgPT0gY29kZTtcbiAgICB9XG4gICAgaXNOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk51bWJlcjtcbiAgICB9XG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLlN0cmluZztcbiAgICB9XG4gICAgaXNPcGVyYXRvcihvcGVyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvciAmJiB0aGlzLnN0clZhbHVlID09IG9wZXJhdG9yO1xuICAgIH1cbiAgICBpc0lkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLklkZW50aWZpZXI7XG4gICAgfVxuICAgIGlzUHJpdmF0ZUlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLlByaXZhdGVJZGVudGlmaWVyO1xuICAgIH1cbiAgICBpc0tleXdvcmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQ7XG4gICAgfVxuICAgIGlzS2V5d29yZExldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdsZXQnO1xuICAgIH1cbiAgICBpc0tleXdvcmRBcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdhcyc7XG4gICAgfVxuICAgIGlzS2V5d29yZE51bGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnbnVsbCc7XG4gICAgfVxuICAgIGlzS2V5d29yZFVuZGVmaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBpc0tleXdvcmRUcnVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3RydWUnO1xuICAgIH1cbiAgICBpc0tleXdvcmRGYWxzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdmYWxzZSc7XG4gICAgfVxuICAgIGlzS2V5d29yZFRoaXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndGhpcyc7XG4gICAgfVxuICAgIGlzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLkVycm9yO1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuTnVtYmVyID8gdGhpcy5udW1WYWx1ZSA6IC0xO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLkNoYXJhY3RlcjpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLklkZW50aWZpZXI6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5LZXl3b3JkOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuT3BlcmF0b3I6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5Qcml2YXRlSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLlN0cmluZzpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLkVycm9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuTnVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3Q2hhcmFjdGVyVG9rZW4oaW5kZXgsIGVuZCwgY29kZSkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGVuZCwgVG9rZW5UeXBlLkNoYXJhY3RlciwgY29kZSwgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG59XG5mdW5jdGlvbiBuZXdJZGVudGlmaWVyVG9rZW4oaW5kZXgsIGVuZCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGVuZCwgVG9rZW5UeXBlLklkZW50aWZpZXIsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3UHJpdmF0ZUlkZW50aWZpZXJUb2tlbihpbmRleCwgZW5kLCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZW5kLCBUb2tlblR5cGUuUHJpdmF0ZUlkZW50aWZpZXIsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3S2V5d29yZFRva2VuKGluZGV4LCBlbmQsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBlbmQsIFRva2VuVHlwZS5LZXl3b3JkLCAwLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5ld09wZXJhdG9yVG9rZW4oaW5kZXgsIGVuZCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGVuZCwgVG9rZW5UeXBlLk9wZXJhdG9yLCAwLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5ld1N0cmluZ1Rva2VuKGluZGV4LCBlbmQsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBlbmQsIFRva2VuVHlwZS5TdHJpbmcsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3TnVtYmVyVG9rZW4oaW5kZXgsIGVuZCwgbikge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGVuZCwgVG9rZW5UeXBlLk51bWJlciwgbiwgJycpO1xufVxuZnVuY3Rpb24gbmV3RXJyb3JUb2tlbihpbmRleCwgZW5kLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZW5kLCBUb2tlblR5cGUuRXJyb3IsIDAsIG1lc3NhZ2UpO1xufVxuY29uc3QgRU9GID0gbmV3IFRva2VuKC0xLCAtMSwgVG9rZW5UeXBlLkNoYXJhY3RlciwgMCwgJycpO1xuY2xhc3MgX1NjYW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5wZWVrID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIHRoaXMucGVlayA9ICsrdGhpcy5pbmRleCA+PSB0aGlzLmxlbmd0aCA/ICRFT0YgOiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG4gICAgfVxuICAgIHNjYW5Ub2tlbigpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0LCBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgbGV0IHBlZWsgPSB0aGlzLnBlZWssIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlLlxuICAgICAgICB3aGlsZSAocGVlayA8PSAkU1BBQ0UpIHtcbiAgICAgICAgICAgIGlmICgrK2luZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBlZWsgPSAkRU9GO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVlayA9IGlucHV0LmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVlayA9IHBlZWs7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGlkZW50aWZpZXJzIGFuZCBudW1iZXJzLlxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQocGVlaykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuSWRlbnRpZmllcigpO1xuICAgICAgICBpZiAoaXNEaWdpdChwZWVrKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5OdW1iZXIoaW5kZXgpO1xuICAgICAgICBjb25zdCBzdGFydCA9IGluZGV4O1xuICAgICAgICBzd2l0Y2ggKHBlZWspIHtcbiAgICAgICAgICAgIGNhc2UgJFBFUklPRDpcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEaWdpdCh0aGlzLnBlZWspID8gdGhpcy5zY2FuTnVtYmVyKHN0YXJ0KSA6XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCAkUEVSSU9EKTtcbiAgICAgICAgICAgIGNhc2UgJExQQVJFTjpcbiAgICAgICAgICAgIGNhc2UgJFJQQVJFTjpcbiAgICAgICAgICAgIGNhc2UgJExCUkFDRTpcbiAgICAgICAgICAgIGNhc2UgJFJCUkFDRTpcbiAgICAgICAgICAgIGNhc2UgJExCUkFDS0VUOlxuICAgICAgICAgICAgY2FzZSAkUkJSQUNLRVQ6XG4gICAgICAgICAgICBjYXNlICRDT01NQTpcbiAgICAgICAgICAgIGNhc2UgJENPTE9OOlxuICAgICAgICAgICAgY2FzZSAkU0VNSUNPTE9OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5DaGFyYWN0ZXIoc3RhcnQsIHBlZWspO1xuICAgICAgICAgICAgY2FzZSAkU1E6XG4gICAgICAgICAgICBjYXNlICREUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlICRIQVNIOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Qcml2YXRlSWRlbnRpZmllcigpO1xuICAgICAgICAgICAgY2FzZSAkUExVUzpcbiAgICAgICAgICAgIGNhc2UgJE1JTlVTOlxuICAgICAgICAgICAgY2FzZSAkU1RBUjpcbiAgICAgICAgICAgIGNhc2UgJFNMQVNIOlxuICAgICAgICAgICAgY2FzZSAkUEVSQ0VOVDpcbiAgICAgICAgICAgIGNhc2UgJENBUkVUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5PcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSk7XG4gICAgICAgICAgICBjYXNlICRRVUVTVElPTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuUXVlc3Rpb24oc3RhcnQpO1xuICAgICAgICAgICAgY2FzZSAkTFQ6XG4gICAgICAgICAgICBjYXNlICRHVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9Jyk7XG4gICAgICAgICAgICBjYXNlICRCQU5HOlxuICAgICAgICAgICAgY2FzZSAkRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgU3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKSwgJEVRLCAnPScsICRFUSwgJz0nKTtcbiAgICAgICAgICAgIGNhc2UgJEFNUEVSU0FORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnJicsICRBTVBFUlNBTkQsICcmJyk7XG4gICAgICAgICAgICBjYXNlICRCQVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgJ3wnLCAkQkFSLCAnfCcpO1xuICAgICAgICAgICAgY2FzZSAkTkJTUDpcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNXaGl0ZXNwYWNlKHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Ub2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgWyR7U3RyaW5nLmZyb21DaGFyQ29kZShwZWVrKX1dYCwgMCk7XG4gICAgfVxuICAgIHNjYW5DaGFyYWN0ZXIoc3RhcnQsIGNvZGUpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuZXdDaGFyYWN0ZXJUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgY29kZSk7XG4gICAgfVxuICAgIHNjYW5PcGVyYXRvcihzdGFydCwgc3RyKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgc3RyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9rZW5pemUgYSAyLzMgY2hhciBsb25nIG9wZXJhdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQgc3RhcnQgaW5kZXggaW4gdGhlIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gb25lIGZpcnN0IHN5bWJvbCAoYWx3YXlzIHBhcnQgb2YgdGhlIG9wZXJhdG9yKVxuICAgICAqIEBwYXJhbSB0d29Db2RlIGNvZGUgcG9pbnQgZm9yIHRoZSBzZWNvbmQgc3ltYm9sXG4gICAgICogQHBhcmFtIHR3byBzZWNvbmQgc3ltYm9sIChwYXJ0IG9mIHRoZSBvcGVyYXRvciB3aGVuIHRoZSBzZWNvbmQgY29kZSBwb2ludCBtYXRjaGVzKVxuICAgICAqIEBwYXJhbSB0aHJlZUNvZGUgY29kZSBwb2ludCBmb3IgdGhlIHRoaXJkIHN5bWJvbFxuICAgICAqIEBwYXJhbSB0aHJlZSB0aGlyZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gcHJvdmlkZWQgYW5kIG1hdGNoZXMgc291cmNlIGV4cHJlc3Npb24pXG4gICAgICovXG4gICAgc2NhbkNvbXBsZXhPcGVyYXRvcihzdGFydCwgb25lLCB0d29Db2RlLCB0d28sIHRocmVlQ29kZSwgdGhyZWUpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGxldCBzdHIgPSBvbmU7XG4gICAgICAgIGlmICh0aGlzLnBlZWsgPT0gdHdvQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICBzdHIgKz0gdHdvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aHJlZUNvZGUgIT0gbnVsbCAmJiB0aGlzLnBlZWsgPT0gdGhyZWVDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHN0ciArPSB0aHJlZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgc3RyKTtcbiAgICB9XG4gICAgc2NhbklkZW50aWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHdoaWxlIChpc0lkZW50aWZpZXJQYXJ0KHRoaXMucGVlaykpXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgY29uc3Qgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gS0VZV09SRFMuaW5kZXhPZihzdHIpID4gLTEgPyBuZXdLZXl3b3JkVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIHN0cikgOlxuICAgICAgICAgICAgbmV3SWRlbnRpZmllclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCBzdHIpO1xuICAgIH1cbiAgICAvKiogU2NhbnMgYW4gRUNNQVNjcmlwdCBwcml2YXRlIGlkZW50aWZpZXIuICovXG4gICAgc2NhblByaXZhdGVJZGVudGlmaWVyKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KHRoaXMucGVlaykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBbI10nLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGlzSWRlbnRpZmllclBhcnQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyTmFtZSA9IHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgcmV0dXJuIG5ld1ByaXZhdGVJZGVudGlmaWVyVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIGlkZW50aWZpZXJOYW1lKTtcbiAgICB9XG4gICAgc2Nhbk51bWJlcihzdGFydCkge1xuICAgICAgICBsZXQgc2ltcGxlID0gKHRoaXMuaW5kZXggPT09IHN0YXJ0KTtcbiAgICAgICAgbGV0IGhhc1NlcGFyYXRvcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBkaWdpdC5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChpc0RpZ2l0KHRoaXMucGVlaykpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09PSAkXykge1xuICAgICAgICAgICAgICAgIC8vIFNlcGFyYXRvcnMgYXJlIG9ubHkgdmFsaWQgd2hlbiB0aGV5J3JlIHN1cnJvdW5kZWQgYnkgZGlnaXRzLiBFLmcuIGAxXzBfMWAgaXNcbiAgICAgICAgICAgICAgICAvLyB2YWxpZCB3aGlsZSBgXzEwMWAgYW5kIGAxMDFfYCBhcmUgbm90LiBUaGUgc2VwYXJhdG9yIGNhbid0IGJlIG5leHQgdG8gdGhlIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAvLyBwb2ludCBvciBhbm90aGVyIHNlcGFyYXRvciBlaXRoZXIuIE5vdGUgdGhhdCBpdCdzIHVubGlrZWx5IHRoYXQgd2UnbGwgaGl0IGEgY2FzZSB3aGVyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB1bmRlcnNjb3JlIGlzIGF0IHRoZSBzdGFydCwgYmVjYXVzZSB0aGF0J3MgYSB2YWxpZCBpZGVudGlmaWVyIGFuZCBpdCB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAgICAgICAgIC8vIHVwIGVhcmxpZXIgaW4gdGhlIHBhcnNpbmcuIFdlIHZhbGlkYXRlIGZvciBpdCBhbnl3YXkganVzdCBpbiBjYXNlLlxuICAgICAgICAgICAgICAgIGlmICghaXNEaWdpdCh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCAtIDEpKSB8fFxuICAgICAgICAgICAgICAgICAgICAhaXNEaWdpdCh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignSW52YWxpZCBudW1lcmljIHNlcGFyYXRvcicsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNTZXBhcmF0b3JzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVlayA9PT0gJFBFUklPRCkge1xuICAgICAgICAgICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHBvbmVudFN0YXJ0KHRoaXMucGVlaykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFeHBvbmVudFNpZ24odGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RpZ2l0KHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdJbnZhbGlkIGV4cG9uZW50JywgLTEpO1xuICAgICAgICAgICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICBpZiAoaGFzU2VwYXJhdG9ycykge1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2ltcGxlID8gcGFyc2VJbnRBdXRvUmFkaXgoc3RyKSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgICAgcmV0dXJuIG5ld051bWJlclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIHNjYW5TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgY29uc3QgcXVvdGUgPSB0aGlzLnBlZWs7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgcXVvdGUuXG4gICAgICAgIGxldCBidWZmZXIgPSAnJztcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlayAhPSBxdW90ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PSAkQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGxldCB1bmVzY2FwZWRDb2RlO1xuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFRTMi4xLWludHJvZHVjZWQgdHlwZSBzdHJpY3RuZXNzXG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrID0gdGhpcy5wZWVrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJHUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gNCBjaGFyYWN0ZXIgaGV4IGNvZGUgZm9yIHVuaWNvZGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZXggPSBpbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eWzAtOWEtZl0rJC9pLnRlc3QoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYEludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1JHtoZXh9XWAsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHVuZXNjYXBlKHRoaXMucGVlayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmVzY2FwZWRDb2RlKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRFT0YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignVW50ZXJtaW5hdGVkIHF1b3RlJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0ID0gaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIHRlcm1pbmF0aW5nIHF1b3RlLlxuICAgICAgICByZXR1cm4gbmV3U3RyaW5nVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIGJ1ZmZlciArIGxhc3QpO1xuICAgIH1cbiAgICBzY2FuUXVlc3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGxldCBzdHIgPSAnPyc7XG4gICAgICAgIC8vIEVpdGhlciBgYSA/PyBiYCBvciAnYT8uYicuXG4gICAgICAgIGlmICh0aGlzLnBlZWsgPT09ICRRVUVTVElPTiB8fCB0aGlzLnBlZWsgPT09ICRQRVJJT0QpIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnBlZWsgPT09ICRQRVJJT0QgPyAnLicgOiAnPyc7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgc3RyKTtcbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZSwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5ld0Vycm9yVG9rZW4ocG9zaXRpb24sIHRoaXMuaW5kZXgsIGBMZXhlciBFcnJvcjogJHttZXNzYWdlfSBhdCBjb2x1bW4gJHtwb3NpdGlvbn0gaW4gZXhwcmVzc2lvbiBbJHt0aGlzLmlucHV0fV1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuICgkYSA8PSBjb2RlICYmIGNvZGUgPD0gJHopIHx8ICgkQSA8PSBjb2RlICYmIGNvZGUgPD0gJFopIHx8XG4gICAgICAgIChjb2RlID09ICRfKSB8fCAoY29kZSA9PSAkJCk7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzY2FubmVyID0gbmV3IF9TY2FubmVyKGlucHV0KTtcbiAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB3aGlsZSAoc2Nhbm5lci5wZWVrICE9PSAkRU9GKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gaXNBc2NpaUxldHRlcihjb2RlKSB8fCBpc0RpZ2l0KGNvZGUpIHx8IChjb2RlID09ICRfKSB8fFxuICAgICAgICAoY29kZSA9PSAkJCk7XG59XG5mdW5jdGlvbiBpc0V4cG9uZW50U3RhcnQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09ICRlIHx8IGNvZGUgPT0gJEU7XG59XG5mdW5jdGlvbiBpc0V4cG9uZW50U2lnbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJE1JTlVTIHx8IGNvZGUgPT0gJFBMVVM7XG59XG5mdW5jdGlvbiB1bmVzY2FwZShjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgJG46XG4gICAgICAgICAgICByZXR1cm4gJExGO1xuICAgICAgICBjYXNlICRmOlxuICAgICAgICAgICAgcmV0dXJuICRGRjtcbiAgICAgICAgY2FzZSAkcjpcbiAgICAgICAgICAgIHJldHVybiAkQ1I7XG4gICAgICAgIGNhc2UgJHQ6XG4gICAgICAgICAgICByZXR1cm4gJFRBQjtcbiAgICAgICAgY2FzZSAkdjpcbiAgICAgICAgICAgIHJldHVybiAkVlRBQjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW50QXV0b1JhZGl4KHRleHQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZUludCh0ZXh0KTtcbiAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgU3BsaXRJbnRlcnBvbGF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cykge1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XG4gICAgfVxufVxuY2xhc3MgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlQmluZGluZ3MsIHdhcm5pbmdzLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdzID0gdGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG59XG5jbGFzcyBQYXJzZXIkMSB7XG4gICAgY29uc3RydWN0b3IoX2xleGVyKSB7XG4gICAgICAgIHRoaXMuX2xleGVyID0gX2xleGVyO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICBwYXJzZUFjdGlvbihpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRykge1xuICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBjb25zdCBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoaW5wdXQpO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShzb3VyY2VUb0xleCk7XG4gICAgICAgIGNvbnN0IGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdG9rZW5zLCBzb3VyY2VUb0xleC5sZW5ndGgsIHRydWUsIHRoaXMuZXJyb3JzLCAwKVxuICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICBwYXJzZUJpbmRpbmcoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcpIHtcbiAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICAgIGNoZWNrU2ltcGxlRXhwcmVzc2lvbihhc3QpIHtcbiAgICAgICAgY29uc3QgY2hlY2tlciA9IG5ldyBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICBhc3QudmlzaXQoY2hlY2tlcik7XG4gICAgICAgIHJldHVybiBjaGVja2VyLmVycm9ycztcbiAgICB9XG4gICAgcGFyc2VTaW1wbGVCaW5kaW5nKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHKSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gdGhpcy5jaGVja1NpbXBsZUV4cHJlc3Npb24oYXN0KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgSG9zdCBiaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gJHtlcnJvcnMuam9pbignICcpfWAsIGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICBfcmVwb3J0RXJyb3IobWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcihtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSk7XG4gICAgfVxuICAgIF9wYXJzZUJpbmRpbmdBc3QoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAvLyBRdW90ZXMgZXhwcmVzc2lvbnMgdXNlIDNyZC1wYXJ0eSBleHByZXNzaW9uIGxhbmd1YWdlLiBXZSBkb24ndCB3YW50IHRvIHVzZVxuICAgICAgICAvLyBvdXIgbGV4ZXIgb3IgcGFyc2VyIGZvciB0aGF0LCBzbyB3ZSBjaGVjayBmb3IgdGhhdCBhaGVhZCBvZiB0aW1lLlxuICAgICAgICBjb25zdCBxdW90ZSA9IHRoaXMuX3BhcnNlUXVvdGUoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIGlmIChxdW90ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgY29uc3Qgc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICByZXR1cm4gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0b2tlbnMsIHNvdXJjZVRvTGV4Lmxlbmd0aCwgZmFsc2UsIHRoaXMuZXJyb3JzLCAwKVxuICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICB9XG4gICAgX3BhcnNlUXVvdGUoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCkge1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBwcmVmaXhTZXBhcmF0b3JJbmRleCA9IGlucHV0LmluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKHByZWZpeFNlcGFyYXRvckluZGV4ID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGlucHV0LnN1YnN0cmluZygwLCBwcmVmaXhTZXBhcmF0b3JJbmRleCkudHJpbSgpO1xuICAgICAgICBpZiAoIWlzSWRlbnRpZmllcihwcmVmaXgpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IHVuaW50ZXJwcmV0ZWRFeHByZXNzaW9uID0gaW5wdXQuc3Vic3RyaW5nKHByZWZpeFNlcGFyYXRvckluZGV4ICsgMSk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBuZXcgUGFyc2VTcGFuKDAsIGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgUXVvdGUoc3Bhbiwgc3Bhbi50b0Fic29sdXRlKGFic29sdXRlT2Zmc2V0KSwgcHJlZml4LCB1bmludGVycHJldGVkRXhwcmVzc2lvbiwgbG9jYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWNyb3N5bnRheCB0ZW1wbGF0ZSBleHByZXNzaW9uIGFuZCByZXR1cm4gYSBsaXN0IG9mIGJpbmRpbmdzIG9yXG4gICAgICogcGFyc2luZyBlcnJvcnMgaW4gY2FzZSB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsXG4gICAgICogYGBgXG4gICAgICogICA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+XG4gICAgICogICAgICAgICBeICAgICAgXiBhYnNvbHV0ZVZhbHVlT2Zmc2V0IGZvciBgdGVtcGxhdGVWYWx1ZWBcbiAgICAgKiAgICAgICAgIGFic29sdXRlS2V5T2Zmc2V0IGZvciBgdGVtcGxhdGVLZXlgXG4gICAgICogYGBgXG4gICAgICogY29udGFpbnMgdGhyZWUgYmluZGluZ3M6XG4gICAgICogMS4gbmdGb3IgLT4gbnVsbFxuICAgICAqIDIuIGl0ZW0gLT4gTmdGb3JPZkNvbnRleHQuJGltcGxpY2l0XG4gICAgICogMy4gbmdGb3JPZiAtPiBpdGVtc1xuICAgICAqXG4gICAgICogVGhpcyBpcyBhcHBhcmVudCBmcm9tIHRoZSBkZS1zdWdhcmVkIHRlbXBsYXRlOlxuICAgICAqIGBgYFxuICAgICAqICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIml0ZW1zXCI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVLZXkgbmFtZSBvZiBkaXJlY3RpdmUsIHdpdGhvdXQgdGhlICogcHJlZml4LiBGb3IgZXhhbXBsZTogbmdJZiwgbmdGb3JcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVWYWx1ZSBSSFMgb2YgdGhlIG1pY3Jvc3ludGF4IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZVVybCB0ZW1wbGF0ZSBmaWxlbmFtZSBpZiBpdCdzIGV4dGVybmFsLCBjb21wb25lbnQgZmlsZW5hbWUgaWYgaXQncyBpbmxpbmVcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVLZXlPZmZzZXQgc3RhcnQgb2YgdGhlIGB0ZW1wbGF0ZUtleWBcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVWYWx1ZU9mZnNldCBzdGFydCBvZiB0aGUgYHRlbXBsYXRlVmFsdWVgXG4gICAgICovXG4gICAgcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRlbXBsYXRlS2V5LCB0ZW1wbGF0ZVZhbHVlLCB0ZW1wbGF0ZVVybCwgYWJzb2x1dGVLZXlPZmZzZXQsIGFic29sdXRlVmFsdWVPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGVtcGxhdGVWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfUGFyc2VBU1QodGVtcGxhdGVWYWx1ZSwgdGVtcGxhdGVVcmwsIGFic29sdXRlVmFsdWVPZmZzZXQsIHRva2VucywgdGVtcGxhdGVWYWx1ZS5sZW5ndGgsIGZhbHNlIC8qIHBhcnNlQWN0aW9uICovLCB0aGlzLmVycm9ycywgMCAvKiByZWxhdGl2ZSBvZmZzZXQgKi8pO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyh7XG4gICAgICAgICAgICBzb3VyY2U6IHRlbXBsYXRlS2V5LFxuICAgICAgICAgICAgc3BhbjogbmV3IEFic29sdXRlU291cmNlU3BhbihhYnNvbHV0ZUtleU9mZnNldCwgYWJzb2x1dGVLZXlPZmZzZXQgKyB0ZW1wbGF0ZUtleS5sZW5ndGgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VJbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHKSB7XG4gICAgICAgIGNvbnN0IHsgc3RyaW5ncywgZXhwcmVzc2lvbnMsIG9mZnNldHMgfSA9IHRoaXMuc3BsaXRJbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbk5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25UZXh0ID0gZXhwcmVzc2lvbnNbaV0udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhleHByZXNzaW9uVGV4dCk7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShzb3VyY2VUb0xleCk7XG4gICAgICAgICAgICBjb25zdCBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCBmYWxzZSwgdGhpcy5lcnJvcnMsIG9mZnNldHNbaV0pXG4gICAgICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgICAgIGV4cHJlc3Npb25Ob2Rlcy5wdXNoKGFzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW50ZXJwb2xhdGlvbkFzdChzdHJpbmdzLm1hcChzID0+IHMudGV4dCksIGV4cHJlc3Npb25Ob2RlcywgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gYHBhcnNlSW50ZXJwb2xhdGlvbmAsIGJ1dCB0cmVhdHMgdGhlIHByb3ZpZGVkIHN0cmluZyBhcyBhIHNpbmdsZSBleHByZXNzaW9uXG4gICAgICogZWxlbWVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGFwcGVhciB3aXRoaW4gdGhlIGludGVycG9sYXRpb24gcHJlZml4IGFuZCBzdWZmaXggKGB7e2AgYW5kIGB9fWApLlxuICAgICAqIFRoaXMgaXMgdXNlZCBmb3IgcGFyc2luZyB0aGUgc3dpdGNoIGV4cHJlc3Npb24gaW4gSUNVcy5cbiAgICAgKi9cbiAgICBwYXJzZUludGVycG9sYXRpb25FeHByZXNzaW9uKGV4cHJlc3Npb24sIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoZXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHNvdXJjZVRvTGV4KTtcbiAgICAgICAgY29uc3QgYXN0ID0gbmV3IF9QYXJzZUFTVChleHByZXNzaW9uLCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRva2Vucywgc291cmNlVG9MZXgubGVuZ3RoLCBcbiAgICAgICAgLyogcGFyc2VBY3Rpb24gKi8gZmFsc2UsIHRoaXMuZXJyb3JzLCAwKVxuICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IFsnJywgJyddOyAvLyBUaGUgcHJlZml4IGFuZCBzdWZmaXggc3RyaW5ncyBhcmUgYm90aCBlbXB0eVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnRlcnBvbGF0aW9uQXN0KHN0cmluZ3MsIFthc3RdLCBleHByZXNzaW9uLCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQpO1xuICAgIH1cbiAgICBjcmVhdGVJbnRlcnBvbGF0aW9uQXN0KHN0cmluZ3MsIGV4cHJlc3Npb25zLCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBuZXcgUGFyc2VTcGFuKDAsIGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpb24gPSBuZXcgSW50ZXJwb2xhdGlvbihzcGFuLCBzcGFuLnRvQWJzb2x1dGUoYWJzb2x1dGVPZmZzZXQpLCBzdHJpbmdzLCBleHByZXNzaW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShpbnRlcnBvbGF0aW9uLCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIHN0cmluZyBvZiB0ZXh0IGludG8gXCJyYXdcIiB0ZXh0IHNlZ21lbnRzIGFuZCBleHByZXNzaW9ucyBwcmVzZW50IGluIGludGVycG9sYXRpb25zIGluXG4gICAgICogdGhlIHN0cmluZy5cbiAgICAgKiBSZXR1cm5zIGBudWxsYCBpZiB0aGVyZSBhcmUgbm8gaW50ZXJwb2xhdGlvbnMsIG90aGVyd2lzZSBhXG4gICAgICogYFNwbGl0SW50ZXJwb2xhdGlvbmAgd2l0aCBzcGxpdHMgdGhhdCBsb29rIGxpa2VcbiAgICAgKiAgIDxyYXcgdGV4dD4gPGV4cHJlc3Npb24+IDxyYXcgdGV4dD4gLi4uIDxyYXcgdGV4dD4gPGV4cHJlc3Npb24+IDxyYXcgdGV4dD5cbiAgICAgKi9cbiAgICBzcGxpdEludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRykge1xuICAgICAgICBjb25zdCBzdHJpbmdzID0gW107XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGNvbnN0IG9mZnNldHMgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgYXRJbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBleHRlbmRMYXN0U3RyaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCB7IHN0YXJ0OiBpbnRlcnBTdGFydCwgZW5kOiBpbnRlcnBFbmQgfSA9IGludGVycG9sYXRpb25Db25maWc7XG4gICAgICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWF0SW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHVudGlsIHN0YXJ0aW5nIHt7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgIGkgPSBpbnB1dC5pbmRleE9mKGludGVycFN0YXJ0LCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGlucHV0LnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKHsgdGV4dCwgc3RhcnQsIGVuZDogaSB9KTtcbiAgICAgICAgICAgICAgICBhdEludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgZnJvbSBzdGFydGluZyB7eyB0byBlbmRpbmcgfX0gd2hpbGUgaWdub3JpbmcgY29udGVudCBpbnNpZGUgcXVvdGVzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwclN0YXJ0ID0gZnVsbFN0YXJ0ICsgaW50ZXJwU3RhcnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJFbmQgPSB0aGlzLl9nZXRJbnRlcnBvbGF0aW9uRW5kSW5kZXgoaW5wdXQsIGludGVycEVuZCwgZXhwclN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwckVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bGQgbm90IGZpbmQgdGhlIGVuZCBvZiB0aGUgaW50ZXJwb2xhdGlvbjsgZG8gbm90IHBhcnNlIGFuIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgd2Ugc2hvdWxkIGV4dGVuZCB0aGUgY29udGVudCBvbiB0aGUgbGFzdCByYXcgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICBhdEludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kTGFzdFN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsRW5kID0gZXhwckVuZCArIGludGVycEVuZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGlucHV0LnN1YnN0cmluZyhleHByU3RhcnQsIGV4cHJFbmQpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoJ0JsYW5rIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBpbnRlcnBvbGF0ZWQgc3RyaW5ncycsIGlucHV0LCBgYXQgY29sdW1uICR7aX0gaW5gLCBsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goeyB0ZXh0LCBzdGFydDogZnVsbFN0YXJ0LCBlbmQ6IGZ1bGxFbmQgfSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKGV4cHJTdGFydCk7XG4gICAgICAgICAgICAgICAgaSA9IGZ1bGxFbmQ7XG4gICAgICAgICAgICAgICAgYXRJbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhdEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBub3cgYXQgYSB0ZXh0IHNlY3Rpb24sIGFkZCB0aGUgcmVtYWluaW5nIGNvbnRlbnQgYXMgYSByYXcgc3RyaW5nLlxuICAgICAgICAgICAgaWYgKGV4dGVuZExhc3RTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaWVjZSA9IHN0cmluZ3Nbc3RyaW5ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBwaWVjZS50ZXh0ICs9IGlucHV0LnN1YnN0cmluZyhpKTtcbiAgICAgICAgICAgICAgICBwaWVjZS5lbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goeyB0ZXh0OiBpbnB1dC5zdWJzdHJpbmcoaSksIHN0YXJ0OiBpLCBlbmQ6IGlucHV0Lmxlbmd0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNwbGl0SW50ZXJwb2xhdGlvbihzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cyk7XG4gICAgfVxuICAgIHdyYXBMaXRlcmFsUHJpbWl0aXZlKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQgPT0gbnVsbCA/IDAgOiBpbnB1dC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UobmV3IExpdGVyYWxQcmltaXRpdmUoc3Bhbiwgc3Bhbi50b0Fic29sdXRlKGFic29sdXRlT2Zmc2V0KSwgaW5wdXQpLCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICAgIF9zdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9jb21tZW50U3RhcnQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gaSAhPSBudWxsID8gaW5wdXQuc3Vic3RyaW5nKDAsIGkpLnRyaW0oKSA6IGlucHV0O1xuICAgIH1cbiAgICBfY29tbWVudFN0YXJ0KGlucHV0KSB7XG4gICAgICAgIGxldCBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBpbnB1dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAkU0xBU0ggJiYgbmV4dENoYXIgPT0gJFNMQVNIICYmIG91dGVyUXVvdGUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIGlmIChvdXRlclF1b3RlID09PSBjaGFyKSB7XG4gICAgICAgICAgICAgICAgb3V0ZXJRdW90ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdXRlclF1b3RlID09IG51bGwgJiYgaXNRdW90ZShjaGFyKSkge1xuICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBjaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCB7IHN0YXJ0LCBlbmQgfSkge1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IC0xO1xuICAgICAgICBsZXQgZW5kSW5kZXggPSAtMTtcbiAgICAgICAgZm9yIChjb25zdCBjaGFySW5kZXggb2YgdGhpcy5fZm9yRWFjaFVucXVvdGVkQ2hhcihpbnB1dCwgMCkpIHtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gY2hhckluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gdGhpcy5fZ2V0SW50ZXJwb2xhdGlvbkVuZEluZGV4KGlucHV0LCBlbmQsIGNoYXJJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEluZGV4ID4gLTEgJiYgZW5kSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYEdvdCBpbnRlcnBvbGF0aW9uICgke3N0YXJ0fSR7ZW5kfSkgd2hlcmUgZXhwcmVzc2lvbiB3YXMgZXhwZWN0ZWRgLCBpbnB1dCwgYGF0IGNvbHVtbiAke3N0YXJ0SW5kZXh9IGluYCwgbG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZW5kIG9mIGFuIGludGVycG9sYXRpb24gZXhwcmVzc2lvblxuICAgICAqIHdoaWxlIGlnbm9yaW5nIGNvbW1lbnRzIGFuZCBxdW90ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBfZ2V0SW50ZXJwb2xhdGlvbkVuZEluZGV4KGlucHV0LCBleHByZXNzaW9uRW5kLCBzdGFydCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoYXJJbmRleCBvZiB0aGlzLl9mb3JFYWNoVW5xdW90ZWRDaGFyKGlucHV0LCBzdGFydCkpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKGV4cHJlc3Npb25FbmQsIGNoYXJJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhckluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90aGluZyBlbHNlIGluIHRoZSBleHByZXNzaW9uIG1hdHRlcnMgYWZ0ZXIgd2UndmVcbiAgICAgICAgICAgIC8vIGhpdCBhIGNvbW1lbnQgc28gbG9vayBkaXJlY3RseSBmb3IgdGhlIGVuZCB0b2tlbi5cbiAgICAgICAgICAgIGlmIChpbnB1dC5zdGFydHNXaXRoKCcvLycsIGNoYXJJbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQuaW5kZXhPZihleHByZXNzaW9uRW5kLCBjaGFySW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdG9yIHVzZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBjaGFyYWN0ZXIgaW5kZXhlcyBvZiBhIHN0cmluZyB0aGF0IGFyZSBvdXRzaWRlIG9mIHF1b3Rlcy5cbiAgICAgKiBAcGFyYW0gaW5wdXQgU3RyaW5nIHRvIGxvb3AgdGhyb3VnaC5cbiAgICAgKiBAcGFyYW0gc3RhcnQgSW5kZXggd2l0aGluIHRoZSBzdHJpbmcgYXQgd2hpY2ggdG8gc3RhcnQuXG4gICAgICovXG4gICAgKl9mb3JFYWNoVW5xdW90ZWRDaGFyKGlucHV0LCBzdGFydCkge1xuICAgICAgICBsZXQgY3VycmVudFF1b3RlID0gbnVsbDtcbiAgICAgICAgbGV0IGVzY2FwZUNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIGNoYXJhY3RlcnMgaW5zaWRlIHF1b3Rlcy4gTm90ZSB0aGF0IHdlIG9ubHkgY2FyZSBhYm91dCB0aGUgb3V0ZXItbW9zdFxuICAgICAgICAgICAgLy8gcXVvdGVzIG1hdGNoaW5nIHVwIGFuZCB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGVzY2FwZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgaWYgKGlzUXVvdGUoaW5wdXQuY2hhckNvZGVBdChpKSkgJiYgKGN1cnJlbnRRdW90ZSA9PT0gbnVsbCB8fCBjdXJyZW50UXVvdGUgPT09IGNoYXIpICYmXG4gICAgICAgICAgICAgICAgZXNjYXBlQ291bnQgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1b3RlID0gY3VycmVudFF1b3RlID09PSBudWxsID8gY2hhciA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50UXVvdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBlQ291bnQgPSBjaGFyID09PSAnXFxcXCcgPyBlc2NhcGVDb3VudCArIDEgOiAwO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqIERlc2NyaWJlcyBhIHN0YXRlZnVsIGNvbnRleHQgYW4gZXhwcmVzc2lvbiBwYXJzZXIgaXMgaW4uICovXG52YXIgUGFyc2VDb250ZXh0RmxhZ3M7XG4oZnVuY3Rpb24gKFBhcnNlQ29udGV4dEZsYWdzKSB7XG4gICAgUGFyc2VDb250ZXh0RmxhZ3NbUGFyc2VDb250ZXh0RmxhZ3NbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBBIFdyaXRhYmxlIGNvbnRleHQgaXMgb25lIGluIHdoaWNoIGEgdmFsdWUgbWF5IGJlIHdyaXR0ZW4gdG8gYW4gbHZhbHVlLlxuICAgICAqIEZvciBleGFtcGxlLCBhZnRlciB3ZSBzZWUgYSBwcm9wZXJ0eSBhY2Nlc3MsIHdlIG1heSBleHBlY3QgYSB3cml0ZSB0byB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2aWEgdGhlIFwiPVwiIG9wZXJhdG9yLlxuICAgICAqICAgcHJvcFxuICAgICAqICAgICAgICBeIHBvc3NpYmxlIFwiPVwiIGFmdGVyXG4gICAgICovXG4gICAgUGFyc2VDb250ZXh0RmxhZ3NbUGFyc2VDb250ZXh0RmxhZ3NbXCJXcml0YWJsZVwiXSA9IDFdID0gXCJXcml0YWJsZVwiO1xufSkoUGFyc2VDb250ZXh0RmxhZ3MgfHwgKFBhcnNlQ29udGV4dEZsYWdzID0ge30pKTtcbmNsYXNzIF9QYXJzZUFTVCB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdG9rZW5zLCBpbnB1dExlbmd0aCwgcGFyc2VBY3Rpb24sIGVycm9ycywgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmFic29sdXRlT2Zmc2V0ID0gYWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmlucHV0TGVuZ3RoID0gaW5wdXRMZW5ndGg7XG4gICAgICAgIHRoaXMucGFyc2VBY3Rpb24gPSBwYXJzZUFjdGlvbjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPSAwO1xuICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IFBhcnNlQ29udGV4dEZsYWdzLk5vbmU7XG4gICAgICAgIC8vIENhY2hlIG9mIGV4cHJlc3Npb24gc3RhcnQgYW5kIGlucHV0IGluZGVjZXMgdG8gdGhlIGFic29sdXRlIHNvdXJjZSBzcGFuIHRoZXkgbWFwIHRvLCB1c2VkIHRvXG4gICAgICAgIC8vIHByZXZlbnQgY3JlYXRpbmcgc3VwZXJmbHVvdXMgc291cmNlIHNwYW5zIGluIGBzb3VyY2VTcGFuYC5cbiAgICAgICAgLy8gQSBzZXJpYWwgb2YgdGhlIGV4cHJlc3Npb24gc3RhcnQgYW5kIGlucHV0IGluZGV4IGlzIHVzZWQgZm9yIG1hcHBpbmcgYmVjYXVzZSBib3RoIGFyZSBzdGF0ZWZ1bFxuICAgICAgICAvLyBhbmQgbWF5IGNoYW5nZSBmb3Igc3Vic2VxdWVudCBleHByZXNzaW9ucyB2aXNpdGVkIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgIHRoaXMuc291cmNlU3BhbkNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgcGVlayhvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuaW5kZXggKyBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBpIDwgdGhpcy50b2tlbnMubGVuZ3RoID8gdGhpcy50b2tlbnNbaV0gOiBFT0Y7XG4gICAgfVxuICAgIGdldCBuZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVrKDApO1xuICAgIH1cbiAgICAvKiogV2hldGhlciBhbGwgdGhlIHBhcnNlciBpbnB1dCBoYXMgYmVlbiBwcm9jZXNzZWQuICovXG4gICAgZ2V0IGF0RU9GKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBuZXh0IHRva2VuIHRvIGJlIHByb2Nlc3NlZCwgb3IgdGhlIGVuZCBvZiB0aGUgbGFzdCB0b2tlbiBpZiBhbGwgaGF2ZSBiZWVuXG4gICAgICogcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGdldCBpbnB1dEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdEVPRiA/IHRoaXMuY3VycmVudEVuZEluZGV4IDogdGhpcy5uZXh0LmluZGV4ICsgdGhpcy5vZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuZCBpbmRleCBvZiB0aGUgbGFzdCBwcm9jZXNzZWQgdG9rZW4sIG9yIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgdG9rZW4gaWYgbm9uZSBoYXZlIGJlZW5cbiAgICAgKiBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRFbmRJbmRleCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJUb2tlbiA9IHRoaXMucGVlaygtMSk7XG4gICAgICAgICAgICByZXR1cm4gY3VyVG9rZW4uZW5kICsgdGhpcy5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gdG9rZW5zIGhhdmUgYmVlbiBwcm9jZXNzZWQgeWV0OyByZXR1cm4gdGhlIG5leHQgdG9rZW4ncyBzdGFydCBvciB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dFxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyB0b2tlbi5cbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRMZW5ndGggKyB0aGlzLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0LmluZGV4ICsgdGhpcy5vZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFic29sdXRlIG9mZnNldCBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRBYnNvbHV0ZU9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVPZmZzZXQgKyB0aGlzLmlucHV0SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgYFBhcnNlU3BhbmAgZnJvbSBgc3RhcnRgIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIChvciB0byBgYXJ0aWZpY2lhbEVuZEluZGV4YCBpZlxuICAgICAqIHByb3ZpZGVkKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCBQb3NpdGlvbiBmcm9tIHdoaWNoIHRoZSBgUGFyc2VTcGFuYCB3aWxsIHN0YXJ0LlxuICAgICAqIEBwYXJhbSBhcnRpZmljaWFsRW5kSW5kZXggT3B0aW9uYWwgZW5kaW5nIGluZGV4IHRvIGJlIHVzZWQgaWYgcHJvdmlkZWQgKGFuZCBpZiBncmVhdGVyIHRoYW4gdGhlXG4gICAgICogICAgIG5hdHVyYWwgZW5kaW5nIGluZGV4KVxuICAgICAqL1xuICAgIHNwYW4oc3RhcnQsIGFydGlmaWNpYWxFbmRJbmRleCkge1xuICAgICAgICBsZXQgZW5kSW5kZXggPSB0aGlzLmN1cnJlbnRFbmRJbmRleDtcbiAgICAgICAgaWYgKGFydGlmaWNpYWxFbmRJbmRleCAhPT0gdW5kZWZpbmVkICYmIGFydGlmaWNpYWxFbmRJbmRleCA+IHRoaXMuY3VycmVudEVuZEluZGV4KSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IGFydGlmaWNpYWxFbmRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBzb21lIHVudXN1YWwgcGFyc2luZyBzY2VuYXJpb3MgKGxpa2Ugd2hlbiBjZXJ0YWluIHRva2VucyBhcmUgbWlzc2luZyBhbmQgYW4gYEVtcHR5RXhwcmAgaXNcbiAgICAgICAgLy8gYmVpbmcgY3JlYXRlZCksIHRoZSBjdXJyZW50IHRva2VuIG1heSBhbHJlYWR5IGJlIGFkdmFuY2VkIGJleW9uZCB0aGUgYGN1cnJlbnRFbmRJbmRleGAuIFRoaXNcbiAgICAgICAgLy8gYXBwZWFycyB0byBiZSBhIGRlZXAtc2VhdGVkIHBhcnNlciBidWcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFzIGEgd29ya2Fyb3VuZCBmb3Igbm93LCBzd2FwIHRoZSBzdGFydCBhbmQgZW5kIGluZGljZXMgdG8gZW5zdXJlIGEgdmFsaWQgYFBhcnNlU3BhbmAuXG4gICAgICAgIC8vIFRPRE8oYWx4aHViKTogZml4IHRoZSBidWcgdXBzdHJlYW0gaW4gdGhlIHBhcnNlciBzdGF0ZSwgYW5kIHJlbW92ZSB0aGlzIHdvcmthcm91bmQuXG4gICAgICAgIGlmIChzdGFydCA+IGVuZEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmRleDtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlU3BhbihzdGFydCwgZW5kSW5kZXgpO1xuICAgIH1cbiAgICBzb3VyY2VTcGFuKHN0YXJ0LCBhcnRpZmljaWFsRW5kSW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsID0gYCR7c3RhcnR9QCR7dGhpcy5pbnB1dEluZGV4fToke2FydGlmaWNpYWxFbmRJbmRleH1gO1xuICAgICAgICBpZiAoIXRoaXMuc291cmNlU3BhbkNhY2hlLmhhcyhzZXJpYWwpKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVNwYW5DYWNoZS5zZXQoc2VyaWFsLCB0aGlzLnNwYW4oc3RhcnQsIGFydGlmaWNpYWxFbmRJbmRleCkudG9BYnNvbHV0ZSh0aGlzLmFic29sdXRlT2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlU3BhbkNhY2hlLmdldChzZXJpYWwpO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgaW4gdGhlIHByb3ZpZGVkIGNvbnRleHQuXG4gICAgICovXG4gICAgd2l0aENvbnRleHQoY29udGV4dCwgY2IpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0IHw9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHJldCA9IGNiKCk7XG4gICAgICAgIHRoaXMuY29udGV4dCBePSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBjb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGNvZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlZWtLZXl3b3JkTGV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0LmlzS2V5d29yZExldCgpO1xuICAgIH1cbiAgICBwZWVrS2V5d29yZEFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0LmlzS2V5d29yZEFzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN1bWVzIGFuIGV4cGVjdGVkIGNoYXJhY3Rlciwgb3RoZXJ3aXNlIGVtaXRzIGFuIGVycm9yIGFib3V0IHRoZSBtaXNzaW5nIGV4cGVjdGVkIGNoYXJhY3RlclxuICAgICAqIGFuZCBza2lwcyBvdmVyIHRoZSB0b2tlbiBzdHJlYW0gdW50aWwgcmVhY2hpbmcgYSByZWNvdmVyYWJsZSBwb2ludC5cbiAgICAgKlxuICAgICAqIFNlZSBgdGhpcy5lcnJvcmAgYW5kIGB0aGlzLnNraXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgZXhwZWN0Q2hhcmFjdGVyKGNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKGNvZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVycm9yKGBNaXNzaW5nIGV4cGVjdGVkICR7U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKX1gKTtcbiAgICB9XG4gICAgY29uc3VtZU9wdGlvbmFsT3BlcmF0b3Iob3ApIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc09wZXJhdG9yKG9wKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBlY3RPcGVyYXRvcihvcGVyYXRvcikge1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcihvcGVyYXRvcikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZXJyb3IoYE1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3IgJHtvcGVyYXRvcn1gKTtcbiAgICB9XG4gICAgcHJldHR5UHJpbnRUb2tlbih0b2spIHtcbiAgICAgICAgcmV0dXJuIHRvayA9PT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiBgdG9rZW4gJHt0b2t9YDtcbiAgICB9XG4gICAgZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpKSB7XG4gICAgICAgICAgICBpZiAobi5pc1ByaXZhdGVJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvckZvclByaXZhdGVJZGVudGlmaWVyKG4sICdleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoYFVuZXhwZWN0ZWQgJHt0aGlzLnByZXR0eVByaW50VG9rZW4obil9LCBleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgIH1cbiAgICBleHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLm5leHQ7XG4gICAgICAgIGlmICghbi5pc0lkZW50aWZpZXIoKSAmJiAhbi5pc0tleXdvcmQoKSAmJiAhbi5pc1N0cmluZygpKSB7XG4gICAgICAgICAgICBpZiAobi5pc1ByaXZhdGVJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvckZvclByaXZhdGVJZGVudGlmaWVyKG4sICdleHBlY3RlZCBpZGVudGlmaWVyLCBrZXl3b3JkIG9yIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgVW5leHBlY3RlZCAke3RoaXMucHJldHR5UHJpbnRUb2tlbihuKX0sIGV4cGVjdGVkIGlkZW50aWZpZXIsIGtleXdvcmQsIG9yIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgIH1cbiAgICBwYXJzZUNoYWluKCkge1xuICAgICAgICBjb25zdCBleHBycyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgZXhwcnMucHVzaChleHByKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdCaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gY2hhaW5lZCBleHByZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIH0gLy8gcmVhZCBhbGwgc2VtaWNvbG9uc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoYFVuZXhwZWN0ZWQgdG9rZW4gJyR7dGhpcy5uZXh0fSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgbm8gZXhwcmVzc2lvbnMgc28gY3JlYXRlIGFuIGVtcHR5IGV4cHJlc3Npb24gdGhhdCBzcGFucyB0aGUgZW50aXJlIGlucHV0IGxlbmd0aFxuICAgICAgICAgICAgY29uc3QgYXJ0aWZpY2lhbFN0YXJ0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBhcnRpZmljaWFsRW5kID0gdGhpcy5vZmZzZXQgKyB0aGlzLmlucHV0TGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKGFydGlmaWNpYWxTdGFydCwgYXJ0aWZpY2lhbEVuZCksIHRoaXMuc291cmNlU3BhbihhcnRpZmljaWFsU3RhcnQsIGFydGlmaWNpYWxFbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gZXhwcnNbMF07XG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW4odGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgZXhwcnMpO1xuICAgIH1cbiAgICBwYXJzZVBpcGUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJ3wnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdDYW5ub3QgaGF2ZSBhIHBpcGUgaW4gYW4gYWN0aW9uIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lU3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWVJZCA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICAgICAgICAgIGxldCBuYW1lU3BhbjtcbiAgICAgICAgICAgICAgICBsZXQgZnVsbFNwYW5FbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lU3BhbiA9IHRoaXMuc291cmNlU3BhbihuYW1lU3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gdmFsaWQgaWRlbnRpZmllciB3YXMgZm91bmQsIHNvIHdlJ2xsIGFzc3VtZSBhbiBlbXB0eSBwaXBlIG5hbWUgKCcnKS5cbiAgICAgICAgICAgICAgICAgICAgbmFtZUlkID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZXJlIG1heSBoYXZlIGJlZW4gd2hpdGVzcGFjZSBwcmVzZW50IGJldHdlZW4gdGhlIHBpcGUgY2hhcmFjdGVyIGFuZCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAvLyB0b2tlbiBpbiB0aGUgc2VxdWVuY2UgKG9yIHRoZSBlbmQgb2YgaW5wdXQpLiBXZSB3YW50IHRvIHRyYWNrIHRoaXMgd2hpdGVzcGFjZSBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgQmluZGluZ1BpcGVgIHdlIHByb2R1Y2UgY292ZXJzIG5vdCBqdXN0IHRoZSBwaXBlIGNoYXJhY3RlciwgYnV0IGFueSB0cmFpbGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGl0ZXNwYWNlIGJleW9uZCBpdC4gQW5vdGhlciB3YXkgb2YgdGhpbmtpbmcgYWJvdXQgdGhpcyBpcyB0aGF0IHRoZSB6ZXJvLWxlbmd0aCBuYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFzc3VtZWQgdG8gYmUgYXQgdGhlIGVuZCBvZiBhbnkgd2hpdGVzcGFjZSBiZXlvbmQgdGhlIHBpcGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHdlIHB1c2ggdGhlIGVuZCBvZiB0aGUgYFBhcnNlU3BhbmAgZm9yIHRoaXMgcGlwZSBhbGwgdGhlIHdheSB1cCB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBuZXh0IHRva2VuLCBvciB1bnRpbCB0aGUgZW5kIG9mIGlucHV0IGlmIHRoZSBuZXh0IHRva2VuIGlzIEVPRi5cbiAgICAgICAgICAgICAgICAgICAgZnVsbFNwYW5FbmQgPSB0aGlzLm5leHQuaW5kZXggIT09IC0xID8gdGhpcy5uZXh0LmluZGV4IDogdGhpcy5pbnB1dExlbmd0aCArIHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYG5hbWVTcGFuYCBmb3IgYW4gZW1wdHkgcGlwZSBuYW1lIGlzIHplcm8tbGVuZ3RoIGF0IHRoZSBlbmQgb2YgYW55IHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYmV5b25kIHRoZSBwaXBlIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgbmFtZVNwYW4gPSBuZXcgUGFyc2VTcGFuKGZ1bGxTcGFuRW5kLCBmdWxsU3BhbkVuZCkudG9BYnNvbHV0ZSh0aGlzLmFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFkZGl0aW9uYWwgZXhwcmVzc2lvbnMgYmV5b25kIHRoZSBuYW1lLCB0aGVuIHRoZSBhcnRpZmljaWFsIGVuZCBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgaXMgbm8gbG9uZ2VyIHJlbGV2YW50LlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluZGluZ1BpcGUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0LCBmdWxsU3BhbkVuZCksIHJlc3VsdCwgbmFtZUlkLCBhcmdzLCBuYW1lU3Bhbik7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCd8JykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgIH1cbiAgICBwYXJzZUNvbmRpdGlvbmFsKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxPcigpO1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignPycpKSB7XG4gICAgICAgICAgICBjb25zdCB5ZXMgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgbGV0IG5vO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGBDb25kaXRpb25hbCBleHByZXNzaW9uICR7ZXhwcmVzc2lvbn0gcmVxdWlyZXMgYWxsIDMgZXhwcmVzc2lvbnNgKTtcbiAgICAgICAgICAgICAgICBubyA9IG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBubyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlc3VsdCwgeWVzLCBubyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlTG9naWNhbE9yKCkge1xuICAgICAgICAvLyAnfHwnXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJ3x8JykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgJ3x8JywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VMb2dpY2FsQW5kKCkge1xuICAgICAgICAvLyAnJiYnXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU51bGxpc2hDb2FsZXNjaW5nKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCcmJicpKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucGFyc2VOdWxsaXNoQ29hbGVzY2luZygpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCAnJiYnLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZU51bGxpc2hDb2FsZXNjaW5nKCkge1xuICAgICAgICAvLyAnPz8nXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc/PycpKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCAnPz8nLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZUVxdWFsaXR5KCkge1xuICAgICAgICAvLyAnPT0nLCchPScsJz09PScsJyE9PSdcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICc9PSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5wYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VSZWxhdGlvbmFsKCkge1xuICAgICAgICAvLyAnPCcsICc+JywgJzw9JywgJz49J1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VBZGRpdGl2ZSgpO1xuICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VBZGRpdGl2ZSgpIHtcbiAgICAgICAgLy8gJysnLCAnLSdcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VNdWx0aXBsaWNhdGl2ZSgpIHtcbiAgICAgICAgLy8gJyonLCAnJScsICcvJ1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlUHJlZml4KCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFVuYXJ5LmNyZWF0ZVBsdXModGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFVuYXJ5LmNyZWF0ZU1pbnVzKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJlZml4Tm90KHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDYWxsQ2hhaW4oKTtcbiAgICB9XG4gICAgcGFyc2VDYWxsQ2hhaW4oKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkUEVSSU9EKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPckNhbGwocmVzdWx0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignPy4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRMQlJBQ0tFVCkgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlS2V5ZWRSZWFkT3JXcml0ZShyZXN1bHQsIHN0YXJ0LCB0cnVlKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXJPckNhbGwocmVzdWx0LCBzdGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUtleWVkUmVhZE9yV3JpdGUocmVzdWx0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmd1bWVudFN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkKys7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucGFyc2VDYWxsQXJndW1lbnRzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJndW1lbnRTcGFuID0gdGhpcy5zcGFuKGFyZ3VtZW50U3RhcnQsIHRoaXMuaW5wdXRJbmRleCkudG9BYnNvbHV0ZSh0aGlzLmFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSUEFSRU4pO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDYWxsKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlc3VsdCwgYXJncywgYXJndW1lbnRTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJyEnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBOb25OdWxsQXNzZXJ0KHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlUHJpbWFyeSgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTFBBUkVOKSkge1xuICAgICAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmROdWxsKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRVbmRlZmluZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgdm9pZCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkVHJ1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNLZXl3b3JkRmFsc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUaGlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUaGlzUmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbkxpc3QoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKCRMQlJBQ0UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWxNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyT3JDYWxsKG5ldyBJbXBsaWNpdFJlY2VpdmVyKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpLCBzdGFydCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc051bWJlcigpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMubmV4dC50b051bWJlcigpO1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc1N0cmluZygpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXRlcmFsVmFsdWUgPSB0aGlzLm5leHQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIGxpdGVyYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzUHJpdmF0ZUlkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3JGb3JQcml2YXRlSWRlbnRpZmllcih0aGlzLm5leHQsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoYFVuZXhwZWN0ZWQgZW5kIG9mIGV4cHJlc3Npb246ICR7dGhpcy5pbnB1dH1gKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihgVW5leHBlY3RlZCB0b2tlbiAke3RoaXMubmV4dH1gKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlRXhwcmVzc2lvbkxpc3QodGVybWluYXRvcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5leHQuaXNDaGFyYWN0ZXIodGVybWluYXRvcikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkQ09NTUEpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VMaXRlcmFsTWFwKCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJExCUkFDRSk7XG4gICAgICAgIGlmICghdGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJFJCUkFDRSkpIHtcbiAgICAgICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkKys7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5U3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVvdGVkID0gdGhpcy5uZXh0LmlzU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goeyBrZXksIHF1b3RlZCB9KTtcbiAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0aWVzIHdpdGggcXVvdGVkIGtleXMgY2FuJ3QgdXNlIHRoZSBzaG9ydGhhbmQgc3ludGF4LlxuICAgICAgICAgICAgICAgIGlmIChxdW90ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJENPTE9OKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRDT0xPTikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5wYXJzZVBpcGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5zcGFuKGtleVN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IHRoaXMuc291cmNlU3BhbihrZXlTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKG5ldyBQcm9wZXJ0eVJlYWQoc3Bhbiwgc291cmNlU3Bhbiwgc291cmNlU3BhbiwgbmV3IEltcGxpY2l0UmVjZWl2ZXIoc3Bhbiwgc291cmNlU3BhbiksIGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBrZXlzLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBwYXJzZUFjY2Vzc01lbWJlck9yQ2FsbChyZWFkUmVjZWl2ZXIsIHN0YXJ0LCBpc1NhZmUpIHtcbiAgICAgICAgY29uc3QgbmFtZVN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMud2l0aENvbnRleHQoUGFyc2VDb250ZXh0RmxhZ3MuV3JpdGFibGUsICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gKF9hID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoYEV4cGVjdGVkIGlkZW50aWZpZXIgZm9yIHByb3BlcnR5IGFjY2Vzc2AsIHJlYWRSZWNlaXZlci5zcGFuLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBuYW1lU3BhbiA9IHRoaXMuc291cmNlU3BhbihuYW1lU3RhcnQpO1xuICAgICAgICBsZXQgcmVjZWl2ZXI7XG4gICAgICAgIGlmIChpc1NhZmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdUaGUgXFwnPy5cXCcgb3BlcmF0b3IgY2Fubm90IGJlIHVzZWQgaW4gdGhlIGFzc2lnbm1lbnQnKTtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IG5ldyBTYWZlUHJvcGVydHlSZWFkKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIG5hbWVTcGFuLCByZWFkUmVjZWl2ZXIsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyc2VBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQmluZGluZ3MgY2Fubm90IGNvbnRhaW4gYXNzaWdubWVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSBuZXcgUHJvcGVydHlXcml0ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBuYW1lU3BhbiwgcmVhZFJlY2VpdmVyLCBpZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPVxuICAgICAgICAgICAgICAgICAgICBuZXcgUHJvcGVydHlSZWFkKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIG5hbWVTcGFuLCByZWFkUmVjZWl2ZXIsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50U3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMucGFyc2VDYWxsQXJndW1lbnRzKCk7XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudFNwYW4gPSB0aGlzLnNwYW4oYXJndW1lbnRTdGFydCwgdGhpcy5pbnB1dEluZGV4KS50b0Fic29sdXRlKHRoaXMuYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJQQVJFTik7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuc3BhbihzdGFydCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VTcGFuID0gdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbChzcGFuLCBzb3VyY2VTcGFuLCByZWNlaXZlciwgYXJncywgYXJndW1lbnRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjZWl2ZXI7XG4gICAgfVxuICAgIHBhcnNlQ2FsbEFyZ3VtZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkUlBBUkVOKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25hbHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbmFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIGlkZW50aWZpZXIsIGEga2V5d29yZCwgYSBzdHJpbmcgd2l0aCBhbiBvcHRpb25hbCBgLWAgaW4gYmV0d2VlbixcbiAgICAgKiBhbmQgcmV0dXJucyB0aGUgc3RyaW5nIGFsb25nIHdpdGggaXRzIGFic29sdXRlIHNvdXJjZSBzcGFuLlxuICAgICAqL1xuICAgIGV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBsZXQgb3BlcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuY3VycmVudEFic29sdXRlT2Zmc2V0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgIG9wZXJhdG9yRm91bmQgPSB0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCctJyk7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JGb3VuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG9wZXJhdG9yRm91bmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiByZXN1bHQsXG4gICAgICAgICAgICBzcGFuOiBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKHN0YXJ0LCBzdGFydCArIHJlc3VsdC5sZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWNyb3N5bnRheCB0ZW1wbGF0ZSBleHByZXNzaW9uIGFuZCByZXR1cm4gYSBsaXN0IG9mIGJpbmRpbmdzIG9yXG4gICAgICogcGFyc2luZyBlcnJvcnMgaW4gY2FzZSB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsXG4gICAgICogYGBgXG4gICAgICogICA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBpbmRleCBhcyBpOyB0cmFja0J5OiBmdW5jXCI+XG4gICAgICogYGBgXG4gICAgICogY29udGFpbnMgZml2ZSBiaW5kaW5nczpcbiAgICAgKiAxLiBuZ0ZvciAtPiBudWxsXG4gICAgICogMi4gaXRlbSAtPiBOZ0Zvck9mQ29udGV4dC4kaW1wbGljaXRcbiAgICAgKiAzLiBuZ0Zvck9mIC0+IGl0ZW1zXG4gICAgICogNC4gaSAtPiBOZ0Zvck9mQ29udGV4dC5pbmRleFxuICAgICAqIDUuIG5nRm9yVHJhY2tCeSAtPiBmdW5jXG4gICAgICpcbiAgICAgKiBGb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBtaWNyb3N5bnRheCBncmFtbWFyLCBzZWVcbiAgICAgKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9taGV2ZXJ5L2QzNTMwMjk0Y2ZmMmU0YTFiM2ZlMTVmZjc1ZDA4ODU1XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVLZXkgbmFtZSBvZiB0aGUgbWljcm9zeW50YXggZGlyZWN0aXZlLCBsaWtlIG5nSWYsIG5nRm9yLFxuICAgICAqIHdpdGhvdXQgdGhlICosIGFsb25nIHdpdGggaXRzIGFic29sdXRlIHNwYW4uXG4gICAgICovXG4gICAgcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRlbXBsYXRlS2V5KSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gW107XG4gICAgICAgIC8vIFRoZSBmaXJzdCBiaW5kaW5nIGlzIGZvciB0aGUgdGVtcGxhdGUga2V5IGl0c2VsZlxuICAgICAgICAvLyBJbiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiLCBrZXkgPSBcIm5nRm9yXCIsIHZhbHVlID0gbnVsbFxuICAgICAgICAvLyBJbiAqbmdJZj1cImNvbmQgfCBwaXBlXCIsIGtleSA9IFwibmdJZlwiLCB2YWx1ZSA9IFwiY29uZCB8IHBpcGVcIlxuICAgICAgICBiaW5kaW5ncy5wdXNoKC4uLnRoaXMucGFyc2VEaXJlY3RpdmVLZXl3b3JkQmluZGluZ3ModGVtcGxhdGVLZXkpKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IHN0YXJ0cyB3aXRoICdsZXQnLCB0aGVuIHRoaXMgbXVzdCBiZSB2YXJpYWJsZSBkZWNsYXJhdGlvblxuICAgICAgICAgICAgY29uc3QgbGV0QmluZGluZyA9IHRoaXMucGFyc2VMZXRCaW5kaW5nKCk7XG4gICAgICAgICAgICBpZiAobGV0QmluZGluZykge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobGV0QmluZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUd28gcG9zc2libGUgY2FzZXMgaGVyZSwgZWl0aGVyIGB2YWx1ZSBcImFzXCIga2V5YCBvclxuICAgICAgICAgICAgICAgIC8vIFwiZGlyZWN0aXZlLWtleXdvcmQgZXhwcmVzc2lvblwiLiBXZSBkb24ndCBrbm93IHdoaWNoIGNhc2UsIGJ1dCBib3RoXG4gICAgICAgICAgICAgICAgLy8gXCJ2YWx1ZVwiIGFuZCBcImRpcmVjdGl2ZS1rZXl3b3JkXCIgYXJlIHRlbXBsYXRlIGJpbmRpbmcga2V5LCBzbyBjb25zdW1lXG4gICAgICAgICAgICAgICAgLy8gdGhlIGtleSBmaXJzdC5cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICAgICAgICAgIC8vIFBlZWsgYXQgdGhlIG5leHQgdG9rZW4sIGlmIGl0IGlzIFwiYXNcIiB0aGVuIHRoaXMgbXVzdCBiZSB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIC8vIGRlY2xhcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLnBhcnNlQXNCaW5kaW5nKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUga2V5IG11c3QgYmUgYSBkaXJlY3RpdmUga2V5d29yZCwgbGlrZSBcIm9mXCIuIFRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUga2V5IHRvIGFjdHVhbCBrZXkuIEVnLiBvZiAtPiBuZ0Zvck9mLCB0cmFja0J5IC0+IG5nRm9yVHJhY2tCeVxuICAgICAgICAgICAgICAgICAgICBrZXkuc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlS2V5LnNvdXJjZSArIGtleS5zb3VyY2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MucHVzaCguLi50aGlzLnBhcnNlRGlyZWN0aXZlS2V5d29yZEJpbmRpbmdzKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29uc3VtZVN0YXRlbWVudFRlcm1pbmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KGJpbmRpbmdzLCBbXSAvKiB3YXJuaW5ncyAqLywgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICBwYXJzZUtleWVkUmVhZE9yV3JpdGUocmVjZWl2ZXIsIHN0YXJ0LCBpc1NhZmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbnRleHQoUGFyc2VDb250ZXh0RmxhZ3MuV3JpdGFibGUsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgRW1wdHlFeHByKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgS2V5IGFjY2VzcyBjYW5ub3QgYmUgZW1wdHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2FmZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdUaGUgXFwnPy5cXCcgb3BlcmF0b3IgY2Fubm90IGJlIHVzZWQgaW4gdGhlIGFzc2lnbm1lbnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS2V5ZWRXcml0ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZWNlaXZlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FmZSA/IG5ldyBTYWZlS2V5ZWRSZWFkKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlY2VpdmVyLCBrZXkpIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3IEtleWVkUmVhZCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZWNlaXZlciwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBkaXJlY3RpdmUga2V5d29yZCwgZm9sbG93ZWQgYnkgYSBtYW5kYXRvcnkgZXhwcmVzc2lvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSwgXCJvZiBpdGVtc1wiLCBcInRyYWNrQnk6IGZ1bmNcIi5cbiAgICAgKiBUaGUgYmluZGluZ3MgYXJlOiBuZ0Zvck9mIC0+IGl0ZW1zLCBuZ0ZvclRyYWNrQnkgLT4gZnVuY1xuICAgICAqIFRoZXJlIGNvdWxkIGJlIGFuIG9wdGlvbmFsIFwiYXNcIiBiaW5kaW5nIHRoYXQgZm9sbG93cyB0aGUgZXhwcmVzc2lvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zIHwgc2xpY2U6MDoxIGFzIGNvbGxlY3Rpb25cIi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgXl4gXl5eXl5eXl5eXl5eXl5eXl4gXl5eXl5eXl5eXl5eXlxuICAgICAqICAgICAgICAgICAgICAga2V5d29yZCAgICBib3VuZCB0YXJnZXQgICBvcHRpb25hbCAnYXMnIGJpbmRpbmdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgYmluZGluZyBrZXksIGZvciBleGFtcGxlLCBuZ0ZvciwgbmdJZiwgbmdGb3JPZiwgYWxvbmcgd2l0aCBpdHNcbiAgICAgKiBhYnNvbHV0ZSBzcGFuLlxuICAgICAqL1xuICAgIHBhcnNlRGlyZWN0aXZlS2V5d29yZEJpbmRpbmdzKGtleSkge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkQ09MT04pOyAvLyB0cmFja0J5OiB0cmFja0J5RnVuY3Rpb25cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldERpcmVjdGl2ZUJvdW5kVGFyZ2V0KCk7XG4gICAgICAgIGxldCBzcGFuRW5kID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIC8vIFRoZSBiaW5kaW5nIGNvdWxkIG9wdGlvbmFsbHkgYmUgZm9sbG93ZWQgYnkgXCJhc1wiLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgLy8gKm5nSWY9XCJjb25kIHwgcGlwZSBhcyB4XCIuIEluIHRoaXMgY2FzZSwgdGhlIGtleSBpbiB0aGUgXCJhc1wiIGJpbmRpbmdcbiAgICAgICAgLy8gaXMgXCJ4XCIgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgdGVtcGxhdGUga2V5IGl0c2VsZiAoXCJuZ0lmXCIpLiBOb3RlIHRoYXQgdGhlXG4gICAgICAgIC8vICdrZXknIGluIHRoZSBjdXJyZW50IGNvbnRleHQgbm93IGJlY29tZXMgdGhlIFwidmFsdWVcIiBpbiB0aGUgbmV4dCBiaW5kaW5nLlxuICAgICAgICBjb25zdCBhc0JpbmRpbmcgPSB0aGlzLnBhcnNlQXNCaW5kaW5nKGtleSk7XG4gICAgICAgIGlmICghYXNCaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yKCk7XG4gICAgICAgICAgICBzcGFuRW5kID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oa2V5LnNwYW4uc3RhcnQsIHNwYW5FbmQpO1xuICAgICAgICBiaW5kaW5ncy5wdXNoKG5ldyBFeHByZXNzaW9uQmluZGluZyhzb3VyY2VTcGFuLCBrZXksIHZhbHVlKSk7XG4gICAgICAgIGlmIChhc0JpbmRpbmcpIHtcbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goYXNCaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZXhwcmVzc2lvbiBBU1QgZm9yIHRoZSBib3VuZCB0YXJnZXQgb2YgYSBkaXJlY3RpdmUga2V5d29yZFxuICAgICAqIGJpbmRpbmcuIEZvciBleGFtcGxlLFxuICAgICAqIGBgYFxuICAgICAqICAgKm5nSWY9XCJjb25kaXRpb24gfCBwaXBlXCJcbiAgICAgKiAgICAgICAgICBeXl5eXl5eXl5eXl5eXl5eIGJvdW5kIHRhcmdldCBmb3IgXCJuZ0lmXCJcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgXl5eXl4gYm91bmQgdGFyZ2V0IGZvciBcIm5nRm9yT2ZcIlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldERpcmVjdGl2ZUJvdW5kVGFyZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0ID09PSBFT0YgfHwgdGhpcy5wZWVrS2V5d29yZEFzKCkgfHwgdGhpcy5wZWVrS2V5d29yZExldCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3QgPSB0aGlzLnBhcnNlUGlwZSgpOyAvLyBleGFtcGxlOiBcImNvbmRpdGlvbiB8IGFzeW5jXCJcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBhc3Quc3BhbjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgdmFsdWUsIHRoaXMubG9jYXRpb24sIHRoaXMuYWJzb2x1dGVPZmZzZXQgKyBzdGFydCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGJpbmRpbmcgZm9yIGEgdmFyaWFibGUgZGVjbGFyZWQgdXNpbmcgYGFzYC4gTm90ZSB0aGF0IHRoZSBvcmRlclxuICAgICAqIG9mIHRoZSBrZXktdmFsdWUgcGFpciBpbiB0aGlzIGRlY2xhcmF0aW9uIGlzIHJldmVyc2VkLiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBpbmRleCBhcyBpXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eICAgIF5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIGtleVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIG5hbWUgb2YgdGhlIHZhbHVlIGluIHRoZSBkZWNsYXJhdGlvbiwgXCJuZ0lmXCIgaW4gdGhlIGV4YW1wbGVcbiAgICAgKiBhYm92ZSwgYWxvbmcgd2l0aCBpdHMgYWJzb2x1dGUgc3Bhbi5cbiAgICAgKi9cbiAgICBwYXJzZUFzQmluZGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMucGVla0tleXdvcmRBcygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSB0aGUgJ2FzJyBrZXl3b3JkXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgIHRoaXMuY29uc3VtZVN0YXRlbWVudFRlcm1pbmF0b3IoKTtcbiAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4odmFsdWUuc3Bhbi5zdGFydCwgdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlQmluZGluZyhzb3VyY2VTcGFuLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaW5kaW5nIGZvciBhIHZhcmlhYmxlIGRlY2xhcmVkIHVzaW5nIGBsZXRgLiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaT1pbmRleDtcIlxuICAgICAqICAgICAgICAgICBeXl5eXl5eXiAgICAgICAgICAgXl5eXl5eXl5eXl5cbiAgICAgKiBgYGBcbiAgICAgKiBJbiB0aGUgZmlyc3QgYmluZGluZywgYGl0ZW1gIGlzIGJvdW5kIHRvIGBOZ0Zvck9mQ29udGV4dC4kaW1wbGljaXRgLlxuICAgICAqIEluIHRoZSBzZWNvbmQgYmluZGluZywgYGlgIGlzIGJvdW5kIHRvIGBOZ0Zvck9mQ29udGV4dC5pbmRleGAuXG4gICAgICovXG4gICAgcGFyc2VMZXRCaW5kaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMucGVla0tleXdvcmRMZXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BhblN0YXJ0ID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIHRoZSAnbGV0JyBrZXl3b3JkXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yKCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVNwYW4gPSBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKHNwYW5TdGFydCwgdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlQmluZGluZyhzb3VyY2VTcGFuLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZSB0aGUgb3B0aW9uYWwgc3RhdGVtZW50IHRlcm1pbmF0b3I6IHNlbWljb2xvbiBvciBjb21tYS5cbiAgICAgKi9cbiAgICBjb25zdW1lU3RhdGVtZW50VGVybWluYXRvcigpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikgfHwgdGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyBhbiBlcnJvciBhbmQgc2tpcHMgb3ZlciB0aGUgdG9rZW4gc3RyZWFtIHVudGlsIHJlYWNoaW5nIGEgcmVjb3ZlcmFibGUgcG9pbnQuIFNlZVxuICAgICAqIGB0aGlzLnNraXBgIGZvciBtb3JlIGRldGFpbHMgb24gdG9rZW4gc2tpcHBpbmcuXG4gICAgICovXG4gICAgZXJyb3IobWVzc2FnZSwgaW5kZXggPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KGluZGV4KSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICB9XG4gICAgbG9jYXRpb25UZXh0KGluZGV4ID0gbnVsbCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gbnVsbClcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgcmV0dXJuIChpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyBgYXQgY29sdW1uICR7dGhpcy50b2tlbnNbaW5kZXhdLmluZGV4ICsgMX0gaW5gIDpcbiAgICAgICAgICAgIGBhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyBhbiBlcnJvciBmb3IgYW4gdW5leHBlY3RlZCBwcml2YXRlIGlkZW50aWZpZXIgYmVpbmcgZGlzY292ZXJlZC5cbiAgICAgKiBAcGFyYW0gdG9rZW4gVG9rZW4gcmVwcmVzZW50aW5nIGEgcHJpdmF0ZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSBleHRyYU1lc3NhZ2UgT3B0aW9uYWwgYWRkaXRpb25hbCBtZXNzYWdlIGJlaW5nIGFwcGVuZGVkIHRvIHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBfcmVwb3J0RXJyb3JGb3JQcml2YXRlSWRlbnRpZmllcih0b2tlbiwgZXh0cmFNZXNzYWdlKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgUHJpdmF0ZSBpZGVudGlmaWVycyBhcmUgbm90IHN1cHBvcnRlZC4gVW5leHBlY3RlZCBwcml2YXRlIGlkZW50aWZpZXI6ICR7dG9rZW59YDtcbiAgICAgICAgaWYgKGV4dHJhTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGAsICR7ZXh0cmFNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcnJvciByZWNvdmVyeSBzaG91bGQgc2tpcCB0b2tlbnMgdW50aWwgaXQgZW5jb3VudGVycyBhIHJlY292ZXJ5IHBvaW50LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBhcmUgdHJlYXRlZCBhcyB1bmNvbmRpdGlvbmFsIHJlY292ZXJ5IHBvaW50czpcbiAgICAgKiAgIC0gZW5kIG9mIGlucHV0XG4gICAgICogICAtICc7JyAocGFyc2VDaGFpbigpIGlzIGFsd2F5cyB0aGUgcm9vdCBwcm9kdWN0aW9uLCBhbmQgaXQgZXhwZWN0cyBhICc7JylcbiAgICAgKiAgIC0gJ3wnIChzaW5jZSBwaXBlcyBtYXkgYmUgY2hhaW5lZCBhbmQgZWFjaCBwaXBlIGV4cHJlc3Npb24gbWF5IGJlIHRyZWF0ZWQgaW5kZXBlbmRlbnRseSlcbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgYXJlIGNvbmRpdGlvbmFsIHJlY292ZXJ5IHBvaW50czpcbiAgICAgKiAgIC0gJyknLCAnfScsICddJyBpZiBvbmUgb2YgY2FsbGluZyBwcm9kdWN0aW9ucyBpcyBleHBlY3Rpbmcgb25lIG9mIHRoZXNlIHN5bWJvbHNcbiAgICAgKiAgICAgLSBUaGlzIGFsbG93cyBza2lwKCkgdG8gcmVjb3ZlciBmcm9tIGVycm9ycyBzdWNoIGFzICcoYS4pICsgMScgYWxsb3dpbmcgbW9yZSBvZiB0aGUgQVNUIHRvXG4gICAgICogICAgICAgYmUgcmV0YWluZWQgKGl0IGRvZXNuJ3Qgc2tpcCBhbnkgdG9rZW5zIGFzIHRoZSAnKScgaXMgcmV0YWluZWQgYmVjYXVzZSBvZiB0aGUgJygnIGJlZ2luc1xuICAgICAqICAgICAgIGFuICcoJyA8ZXhwcj4gJyknIHByb2R1Y3Rpb24pLlxuICAgICAqICAgICAgIFRoZSByZWNvdmVyeSBwb2ludHMgb2YgZ3JvdXBpbmcgc3ltYm9scyBtdXN0IGJlIGNvbmRpdGlvbmFsIGFzIHRoZXkgbXVzdCBiZSBza2lwcGVkIGlmXG4gICAgICogICAgICAgbm9uZSBvZiB0aGUgY2FsbGluZyBwcm9kdWN0aW9ucyBhcmUgbm90IGV4cGVjdGluZyB0aGUgY2xvc2luZyB0b2tlbiBlbHNlIHdlIHdpbGwgbmV2ZXJcbiAgICAgKiAgICAgICBtYWtlIHByb2dyZXNzIGluIHRoZSBjYXNlIG9mIGFuIGV4dHJhbmVvdXMgZ3JvdXAgY2xvc2luZyBzeW1ib2wgKHN1Y2ggYXMgYSBzdHJheSAnKScpLlxuICAgICAqICAgICAgIFRoYXQgaXMsIHdlIHNraXAgYSBjbG9zaW5nIHN5bWJvbCBpZiB3ZSBhcmUgbm90IGluIGEgZ3JvdXBpbmcgcHJvZHVjdGlvbi5cbiAgICAgKiAgIC0gJz0nIGluIGEgYFdyaXRhYmxlYCBjb250ZXh0XG4gICAgICogICAgIC0gSW4gdGhpcyBjb250ZXh0LCB3ZSBhcmUgYWJsZSB0byByZWNvdmVyIGFmdGVyIHNlZWluZyB0aGUgYD1gIG9wZXJhdG9yLCB3aGljaFxuICAgICAqICAgICAgIHNpZ25hbHMgdGhlIHByZXNlbmNlIG9mIGFuIGluZGVwZW5kZW50IHJ2YWx1ZSBleHByZXNzaW9uIGZvbGxvd2luZyB0aGUgYD1gIG9wZXJhdG9yLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9kdWN0aW9uIGV4cGVjdHMgb25lIG9mIHRoZXNlIHRva2VuIGl0IGluY3JlbWVudHMgdGhlIGNvcnJlc3BvbmRpbmcgbmVzdGluZyBjb3VudCxcbiAgICAgKiBhbmQgdGhlbiBkZWNyZW1lbnRzIGl0IGp1c3QgcHJpb3IgdG8gY2hlY2tpbmcgaWYgdGhlIHRva2VuIGlzIGluIHRoZSBpbnB1dC5cbiAgICAgKi9cbiAgICBza2lwKCkge1xuICAgICAgICBsZXQgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggJiYgIW4uaXNDaGFyYWN0ZXIoJFNFTUlDT0xPTikgJiZcbiAgICAgICAgICAgICFuLmlzT3BlcmF0b3IoJ3wnKSAmJiAodGhpcy5ycGFyZW5zRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUlBBUkVOKSkgJiZcbiAgICAgICAgICAgICh0aGlzLnJicmFjZXNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSQlJBQ0UpKSAmJlxuICAgICAgICAgICAgKHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNLRVQpKSAmJlxuICAgICAgICAgICAgKCEodGhpcy5jb250ZXh0ICYgUGFyc2VDb250ZXh0RmxhZ3MuV3JpdGFibGUpIHx8ICFuLmlzT3BlcmF0b3IoJz0nKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNFcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IodGhpcy5uZXh0LnRvU3RyaW5nKCksIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KCksIHRoaXMubG9jYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyIGV4dGVuZHMgUmVjdXJzaXZlQXN0VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHZpc2l0UGlwZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCgncGlwZXMnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgTm9kZVdpdGhJMThuIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaTE4biA9IGkxOG47XG4gICAgfVxufVxuY2xhc3MgVGV4dCBleHRlbmRzIE5vZGVXaXRoSTE4biB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNvdXJjZVNwYW4sIHRva2VucywgaTE4bikge1xuICAgICAgICBzdXBlcihzb3VyY2VTcGFuLCBpMThuKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRXhwYW5zaW9uIGV4dGVuZHMgTm9kZVdpdGhJMThuIHtcbiAgICBjb25zdHJ1Y3Rvcihzd2l0Y2hWYWx1ZSwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4sIHN3aXRjaFZhbHVlU291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICBzdXBlcihzb3VyY2VTcGFuLCBpMThuKTtcbiAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZSA9IHN3aXRjaFZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNhc2VzID0gY2FzZXM7XG4gICAgICAgIHRoaXMuc3dpdGNoVmFsdWVTb3VyY2VTcGFuID0gc3dpdGNoVmFsdWVTb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEV4cGFuc2lvbkNhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB2YWx1ZVNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU291cmNlU3BhbiA9IHZhbHVlU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5leHBTb3VyY2VTcGFuID0gZXhwU291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cGFuc2lvbkNhc2UodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQXR0cmlidXRlIGV4dGVuZHMgTm9kZVdpdGhJMThuIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCB2YWx1ZVRva2VucywgaTE4bikge1xuICAgICAgICBzdXBlcihzb3VyY2VTcGFuLCBpMThuKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmtleVNwYW4gPSBrZXlTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVRva2VucyA9IHZhbHVlVG9rZW5zO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXR0cmlidXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEVsZW1lbnQgZXh0ZW5kcyBOb2RlV2l0aEkxOG4ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGF0dHJzLCBjaGlsZHJlbiwgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuID0gbnVsbCwgaTE4bikge1xuICAgICAgICBzdXBlcihzb3VyY2VTcGFuLCBpMThuKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBDb21tZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb21tZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZpc2l0QWxsKHZpc2l0b3IsIG5vZGVzLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHZpc2l0ID0gdmlzaXRvci52aXNpdCA/XG4gICAgICAgIChhc3QpID0+IHZpc2l0b3IudmlzaXQoYXN0LCBjb250ZXh0KSB8fCBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCkgOlxuICAgICAgICAoYXN0KSA9PiBhc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7XG4gICAgbm9kZXMuZm9yRWFjaChhc3QgPT4ge1xuICAgICAgICBjb25zdCBhc3RSZXN1bHQgPSB2aXNpdChhc3QpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIFJlY3Vyc2l2ZVZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgdmlzaXRFbGVtZW50KGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4oY29udGV4dCwgdmlzaXQgPT4ge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmF0dHJzKTtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5jaGlsZHJlbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhc3QsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0VGV4dChhc3QsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0Q29tbWVudChhc3QsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0RXhwYW5zaW9uKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdENoaWxkcmVuKGNvbnRleHQsIHZpc2l0ID0+IHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5jYXNlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoYXN0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdENoaWxkcmVuKGNvbnRleHQsIGNiKSB7XG4gICAgICAgIGxldCByZXN1bHRzID0gW107XG4gICAgICAgIGxldCB0ID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gdmlzaXQoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godmlzaXRBbGwodCwgY2hpbGRyZW4sIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYih2aXNpdCk7XG4gICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCByZXN1bHRzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gTWFwcGluZyBiZXR3ZWVuIGFsbCBIVE1MIGVudGl0eSBuYW1lcyBhbmQgdGhlaXIgdW5pY29kZSByZXByZXNlbnRhdGlvbi5cbi8vIEdlbmVyYXRlZCBmcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VudGl0aWVzLmpzb24gYnkgc3RyaXBwaW5nXG4vLyB0aGUgYCZgIGFuZCBgO2AgZnJvbSB0aGUga2V5cyBhbmQgcmVtb3ZpbmcgdGhlIGR1cGxpY2F0ZXMuXG4vLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNuYW1lZC1jaGFyYWN0ZXItcmVmZXJlbmNlc1xuY29uc3QgTkFNRURfRU5USVRJRVMgPSB7XG4gICAgJ0FFbGlnJzogJ1xcdTAwQzYnLFxuICAgICdBTVAnOiAnXFx1MDAyNicsXG4gICAgJ2FtcCc6ICdcXHUwMDI2JyxcbiAgICAnQWFjdXRlJzogJ1xcdTAwQzEnLFxuICAgICdBYnJldmUnOiAnXFx1MDEwMicsXG4gICAgJ0FjaXJjJzogJ1xcdTAwQzInLFxuICAgICdBY3knOiAnXFx1MDQxMCcsXG4gICAgJ0Fmcic6ICdcXHVEODM1XFx1REQwNCcsXG4gICAgJ0FncmF2ZSc6ICdcXHUwMEMwJyxcbiAgICAnQWxwaGEnOiAnXFx1MDM5MScsXG4gICAgJ0FtYWNyJzogJ1xcdTAxMDAnLFxuICAgICdBbmQnOiAnXFx1MkE1MycsXG4gICAgJ0FvZ29uJzogJ1xcdTAxMDQnLFxuICAgICdBb3BmJzogJ1xcdUQ4MzVcXHVERDM4JyxcbiAgICAnQXBwbHlGdW5jdGlvbic6ICdcXHUyMDYxJyxcbiAgICAnYWYnOiAnXFx1MjA2MScsXG4gICAgJ0FyaW5nJzogJ1xcdTAwQzUnLFxuICAgICdhbmdzdCc6ICdcXHUwMEM1JyxcbiAgICAnQXNjcic6ICdcXHVEODM1XFx1REM5QycsXG4gICAgJ0Fzc2lnbic6ICdcXHUyMjU0JyxcbiAgICAnY29sb25lJzogJ1xcdTIyNTQnLFxuICAgICdjb2xvbmVxJzogJ1xcdTIyNTQnLFxuICAgICdBdGlsZGUnOiAnXFx1MDBDMycsXG4gICAgJ0F1bWwnOiAnXFx1MDBDNCcsXG4gICAgJ0JhY2tzbGFzaCc6ICdcXHUyMjE2JyxcbiAgICAnc2V0bWludXMnOiAnXFx1MjIxNicsXG4gICAgJ3NldG1uJzogJ1xcdTIyMTYnLFxuICAgICdzbWFsbHNldG1pbnVzJzogJ1xcdTIyMTYnLFxuICAgICdzc2V0bW4nOiAnXFx1MjIxNicsXG4gICAgJ0JhcnYnOiAnXFx1MkFFNycsXG4gICAgJ0JhcndlZCc6ICdcXHUyMzA2JyxcbiAgICAnZG91YmxlYmFyd2VkZ2UnOiAnXFx1MjMwNicsXG4gICAgJ0JjeSc6ICdcXHUwNDExJyxcbiAgICAnQmVjYXVzZSc6ICdcXHUyMjM1JyxcbiAgICAnYmVjYXVzJzogJ1xcdTIyMzUnLFxuICAgICdiZWNhdXNlJzogJ1xcdTIyMzUnLFxuICAgICdCZXJub3VsbGlzJzogJ1xcdTIxMkMnLFxuICAgICdCc2NyJzogJ1xcdTIxMkMnLFxuICAgICdiZXJub3UnOiAnXFx1MjEyQycsXG4gICAgJ0JldGEnOiAnXFx1MDM5MicsXG4gICAgJ0Jmcic6ICdcXHVEODM1XFx1REQwNScsXG4gICAgJ0JvcGYnOiAnXFx1RDgzNVxcdUREMzknLFxuICAgICdCcmV2ZSc6ICdcXHUwMkQ4JyxcbiAgICAnYnJldmUnOiAnXFx1MDJEOCcsXG4gICAgJ0J1bXBlcSc6ICdcXHUyMjRFJyxcbiAgICAnSHVtcERvd25IdW1wJzogJ1xcdTIyNEUnLFxuICAgICdidW1wJzogJ1xcdTIyNEUnLFxuICAgICdDSGN5JzogJ1xcdTA0MjcnLFxuICAgICdDT1BZJzogJ1xcdTAwQTknLFxuICAgICdjb3B5JzogJ1xcdTAwQTknLFxuICAgICdDYWN1dGUnOiAnXFx1MDEwNicsXG4gICAgJ0NhcCc6ICdcXHUyMkQyJyxcbiAgICAnQ2FwaXRhbERpZmZlcmVudGlhbEQnOiAnXFx1MjE0NScsXG4gICAgJ0REJzogJ1xcdTIxNDUnLFxuICAgICdDYXlsZXlzJzogJ1xcdTIxMkQnLFxuICAgICdDZnInOiAnXFx1MjEyRCcsXG4gICAgJ0NjYXJvbic6ICdcXHUwMTBDJyxcbiAgICAnQ2NlZGlsJzogJ1xcdTAwQzcnLFxuICAgICdDY2lyYyc6ICdcXHUwMTA4JyxcbiAgICAnQ2NvbmludCc6ICdcXHUyMjMwJyxcbiAgICAnQ2RvdCc6ICdcXHUwMTBBJyxcbiAgICAnQ2VkaWxsYSc6ICdcXHUwMEI4JyxcbiAgICAnY2VkaWwnOiAnXFx1MDBCOCcsXG4gICAgJ0NlbnRlckRvdCc6ICdcXHUwMEI3JyxcbiAgICAnY2VudGVyZG90JzogJ1xcdTAwQjcnLFxuICAgICdtaWRkb3QnOiAnXFx1MDBCNycsXG4gICAgJ0NoaSc6ICdcXHUwM0E3JyxcbiAgICAnQ2lyY2xlRG90JzogJ1xcdTIyOTknLFxuICAgICdvZG90JzogJ1xcdTIyOTknLFxuICAgICdDaXJjbGVNaW51cyc6ICdcXHUyMjk2JyxcbiAgICAnb21pbnVzJzogJ1xcdTIyOTYnLFxuICAgICdDaXJjbGVQbHVzJzogJ1xcdTIyOTUnLFxuICAgICdvcGx1cyc6ICdcXHUyMjk1JyxcbiAgICAnQ2lyY2xlVGltZXMnOiAnXFx1MjI5NycsXG4gICAgJ290aW1lcyc6ICdcXHUyMjk3JyxcbiAgICAnQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzogJ1xcdTIyMzInLFxuICAgICdjd2NvbmludCc6ICdcXHUyMjMyJyxcbiAgICAnQ2xvc2VDdXJseURvdWJsZVF1b3RlJzogJ1xcdTIwMUQnLFxuICAgICdyZHF1byc6ICdcXHUyMDFEJyxcbiAgICAncmRxdW9yJzogJ1xcdTIwMUQnLFxuICAgICdDbG9zZUN1cmx5UXVvdGUnOiAnXFx1MjAxOScsXG4gICAgJ3JzcXVvJzogJ1xcdTIwMTknLFxuICAgICdyc3F1b3InOiAnXFx1MjAxOScsXG4gICAgJ0NvbG9uJzogJ1xcdTIyMzcnLFxuICAgICdQcm9wb3J0aW9uJzogJ1xcdTIyMzcnLFxuICAgICdDb2xvbmUnOiAnXFx1MkE3NCcsXG4gICAgJ0NvbmdydWVudCc6ICdcXHUyMjYxJyxcbiAgICAnZXF1aXYnOiAnXFx1MjI2MScsXG4gICAgJ0NvbmludCc6ICdcXHUyMjJGJyxcbiAgICAnRG91YmxlQ29udG91ckludGVncmFsJzogJ1xcdTIyMkYnLFxuICAgICdDb250b3VySW50ZWdyYWwnOiAnXFx1MjIyRScsXG4gICAgJ2NvbmludCc6ICdcXHUyMjJFJyxcbiAgICAnb2ludCc6ICdcXHUyMjJFJyxcbiAgICAnQ29wZic6ICdcXHUyMTAyJyxcbiAgICAnY29tcGxleGVzJzogJ1xcdTIxMDInLFxuICAgICdDb3Byb2R1Y3QnOiAnXFx1MjIxMCcsXG4gICAgJ2NvcHJvZCc6ICdcXHUyMjEwJyxcbiAgICAnQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCc6ICdcXHUyMjMzJyxcbiAgICAnYXdjb25pbnQnOiAnXFx1MjIzMycsXG4gICAgJ0Nyb3NzJzogJ1xcdTJBMkYnLFxuICAgICdDc2NyJzogJ1xcdUQ4MzVcXHVEQzlFJyxcbiAgICAnQ3VwJzogJ1xcdTIyRDMnLFxuICAgICdDdXBDYXAnOiAnXFx1MjI0RCcsXG4gICAgJ2FzeW1wZXEnOiAnXFx1MjI0RCcsXG4gICAgJ0REb3RyYWhkJzogJ1xcdTI5MTEnLFxuICAgICdESmN5JzogJ1xcdTA0MDInLFxuICAgICdEU2N5JzogJ1xcdTA0MDUnLFxuICAgICdEWmN5JzogJ1xcdTA0MEYnLFxuICAgICdEYWdnZXInOiAnXFx1MjAyMScsXG4gICAgJ2RkYWdnZXInOiAnXFx1MjAyMScsXG4gICAgJ0RhcnInOiAnXFx1MjFBMScsXG4gICAgJ0Rhc2h2JzogJ1xcdTJBRTQnLFxuICAgICdEb3VibGVMZWZ0VGVlJzogJ1xcdTJBRTQnLFxuICAgICdEY2Fyb24nOiAnXFx1MDEwRScsXG4gICAgJ0RjeSc6ICdcXHUwNDE0JyxcbiAgICAnRGVsJzogJ1xcdTIyMDcnLFxuICAgICduYWJsYSc6ICdcXHUyMjA3JyxcbiAgICAnRGVsdGEnOiAnXFx1MDM5NCcsXG4gICAgJ0Rmcic6ICdcXHVEODM1XFx1REQwNycsXG4gICAgJ0RpYWNyaXRpY2FsQWN1dGUnOiAnXFx1MDBCNCcsXG4gICAgJ2FjdXRlJzogJ1xcdTAwQjQnLFxuICAgICdEaWFjcml0aWNhbERvdCc6ICdcXHUwMkQ5JyxcbiAgICAnZG90JzogJ1xcdTAyRDknLFxuICAgICdEaWFjcml0aWNhbERvdWJsZUFjdXRlJzogJ1xcdTAyREQnLFxuICAgICdkYmxhYyc6ICdcXHUwMkREJyxcbiAgICAnRGlhY3JpdGljYWxHcmF2ZSc6ICdcXHUwMDYwJyxcbiAgICAnZ3JhdmUnOiAnXFx1MDA2MCcsXG4gICAgJ0RpYWNyaXRpY2FsVGlsZGUnOiAnXFx1MDJEQycsXG4gICAgJ3RpbGRlJzogJ1xcdTAyREMnLFxuICAgICdEaWFtb25kJzogJ1xcdTIyQzQnLFxuICAgICdkaWFtJzogJ1xcdTIyQzQnLFxuICAgICdkaWFtb25kJzogJ1xcdTIyQzQnLFxuICAgICdEaWZmZXJlbnRpYWxEJzogJ1xcdTIxNDYnLFxuICAgICdkZCc6ICdcXHUyMTQ2JyxcbiAgICAnRG9wZic6ICdcXHVEODM1XFx1REQzQicsXG4gICAgJ0RvdCc6ICdcXHUwMEE4JyxcbiAgICAnRG91YmxlRG90JzogJ1xcdTAwQTgnLFxuICAgICdkaWUnOiAnXFx1MDBBOCcsXG4gICAgJ3VtbCc6ICdcXHUwMEE4JyxcbiAgICAnRG90RG90JzogJ1xcdTIwREMnLFxuICAgICdEb3RFcXVhbCc6ICdcXHUyMjUwJyxcbiAgICAnZG90ZXEnOiAnXFx1MjI1MCcsXG4gICAgJ2VzZG90JzogJ1xcdTIyNTAnLFxuICAgICdEb3VibGVEb3duQXJyb3cnOiAnXFx1MjFEMycsXG4gICAgJ0Rvd25hcnJvdyc6ICdcXHUyMUQzJyxcbiAgICAnZEFycic6ICdcXHUyMUQzJyxcbiAgICAnRG91YmxlTGVmdEFycm93JzogJ1xcdTIxRDAnLFxuICAgICdMZWZ0YXJyb3cnOiAnXFx1MjFEMCcsXG4gICAgJ2xBcnInOiAnXFx1MjFEMCcsXG4gICAgJ0RvdWJsZUxlZnRSaWdodEFycm93JzogJ1xcdTIxRDQnLFxuICAgICdMZWZ0cmlnaHRhcnJvdyc6ICdcXHUyMUQ0JyxcbiAgICAnaEFycic6ICdcXHUyMUQ0JyxcbiAgICAnaWZmJzogJ1xcdTIxRDQnLFxuICAgICdEb3VibGVMb25nTGVmdEFycm93JzogJ1xcdTI3RjgnLFxuICAgICdMb25nbGVmdGFycm93JzogJ1xcdTI3RjgnLFxuICAgICd4bEFycic6ICdcXHUyN0Y4JyxcbiAgICAnRG91YmxlTG9uZ0xlZnRSaWdodEFycm93JzogJ1xcdTI3RkEnLFxuICAgICdMb25nbGVmdHJpZ2h0YXJyb3cnOiAnXFx1MjdGQScsXG4gICAgJ3hoQXJyJzogJ1xcdTI3RkEnLFxuICAgICdEb3VibGVMb25nUmlnaHRBcnJvdyc6ICdcXHUyN0Y5JyxcbiAgICAnTG9uZ3JpZ2h0YXJyb3cnOiAnXFx1MjdGOScsXG4gICAgJ3hyQXJyJzogJ1xcdTI3RjknLFxuICAgICdEb3VibGVSaWdodEFycm93JzogJ1xcdTIxRDInLFxuICAgICdJbXBsaWVzJzogJ1xcdTIxRDInLFxuICAgICdSaWdodGFycm93JzogJ1xcdTIxRDInLFxuICAgICdyQXJyJzogJ1xcdTIxRDInLFxuICAgICdEb3VibGVSaWdodFRlZSc6ICdcXHUyMkE4JyxcbiAgICAndkRhc2gnOiAnXFx1MjJBOCcsXG4gICAgJ0RvdWJsZVVwQXJyb3cnOiAnXFx1MjFEMScsXG4gICAgJ1VwYXJyb3cnOiAnXFx1MjFEMScsXG4gICAgJ3VBcnInOiAnXFx1MjFEMScsXG4gICAgJ0RvdWJsZVVwRG93bkFycm93JzogJ1xcdTIxRDUnLFxuICAgICdVcGRvd25hcnJvdyc6ICdcXHUyMUQ1JyxcbiAgICAndkFycic6ICdcXHUyMUQ1JyxcbiAgICAnRG91YmxlVmVydGljYWxCYXInOiAnXFx1MjIyNScsXG4gICAgJ3Bhcic6ICdcXHUyMjI1JyxcbiAgICAncGFyYWxsZWwnOiAnXFx1MjIyNScsXG4gICAgJ3Nob3J0cGFyYWxsZWwnOiAnXFx1MjIyNScsXG4gICAgJ3NwYXInOiAnXFx1MjIyNScsXG4gICAgJ0Rvd25BcnJvdyc6ICdcXHUyMTkzJyxcbiAgICAnU2hvcnREb3duQXJyb3cnOiAnXFx1MjE5MycsXG4gICAgJ2RhcnInOiAnXFx1MjE5MycsXG4gICAgJ2Rvd25hcnJvdyc6ICdcXHUyMTkzJyxcbiAgICAnRG93bkFycm93QmFyJzogJ1xcdTI5MTMnLFxuICAgICdEb3duQXJyb3dVcEFycm93JzogJ1xcdTIxRjUnLFxuICAgICdkdWFycic6ICdcXHUyMUY1JyxcbiAgICAnRG93bkJyZXZlJzogJ1xcdTAzMTEnLFxuICAgICdEb3duTGVmdFJpZ2h0VmVjdG9yJzogJ1xcdTI5NTAnLFxuICAgICdEb3duTGVmdFRlZVZlY3Rvcic6ICdcXHUyOTVFJyxcbiAgICAnRG93bkxlZnRWZWN0b3InOiAnXFx1MjFCRCcsXG4gICAgJ2xlZnRoYXJwb29uZG93bic6ICdcXHUyMUJEJyxcbiAgICAnbGhhcmQnOiAnXFx1MjFCRCcsXG4gICAgJ0Rvd25MZWZ0VmVjdG9yQmFyJzogJ1xcdTI5NTYnLFxuICAgICdEb3duUmlnaHRUZWVWZWN0b3InOiAnXFx1Mjk1RicsXG4gICAgJ0Rvd25SaWdodFZlY3Rvcic6ICdcXHUyMUMxJyxcbiAgICAncmhhcmQnOiAnXFx1MjFDMScsXG4gICAgJ3JpZ2h0aGFycG9vbmRvd24nOiAnXFx1MjFDMScsXG4gICAgJ0Rvd25SaWdodFZlY3RvckJhcic6ICdcXHUyOTU3JyxcbiAgICAnRG93blRlZSc6ICdcXHUyMkE0JyxcbiAgICAndG9wJzogJ1xcdTIyQTQnLFxuICAgICdEb3duVGVlQXJyb3cnOiAnXFx1MjFBNycsXG4gICAgJ21hcHN0b2Rvd24nOiAnXFx1MjFBNycsXG4gICAgJ0RzY3InOiAnXFx1RDgzNVxcdURDOUYnLFxuICAgICdEc3Ryb2snOiAnXFx1MDExMCcsXG4gICAgJ0VORyc6ICdcXHUwMTRBJyxcbiAgICAnRVRIJzogJ1xcdTAwRDAnLFxuICAgICdFYWN1dGUnOiAnXFx1MDBDOScsXG4gICAgJ0VjYXJvbic6ICdcXHUwMTFBJyxcbiAgICAnRWNpcmMnOiAnXFx1MDBDQScsXG4gICAgJ0VjeSc6ICdcXHUwNDJEJyxcbiAgICAnRWRvdCc6ICdcXHUwMTE2JyxcbiAgICAnRWZyJzogJ1xcdUQ4MzVcXHVERDA4JyxcbiAgICAnRWdyYXZlJzogJ1xcdTAwQzgnLFxuICAgICdFbGVtZW50JzogJ1xcdTIyMDgnLFxuICAgICdpbic6ICdcXHUyMjA4JyxcbiAgICAnaXNpbic6ICdcXHUyMjA4JyxcbiAgICAnaXNpbnYnOiAnXFx1MjIwOCcsXG4gICAgJ0VtYWNyJzogJ1xcdTAxMTInLFxuICAgICdFbXB0eVNtYWxsU3F1YXJlJzogJ1xcdTI1RkInLFxuICAgICdFbXB0eVZlcnlTbWFsbFNxdWFyZSc6ICdcXHUyNUFCJyxcbiAgICAnRW9nb24nOiAnXFx1MDExOCcsXG4gICAgJ0VvcGYnOiAnXFx1RDgzNVxcdUREM0MnLFxuICAgICdFcHNpbG9uJzogJ1xcdTAzOTUnLFxuICAgICdFcXVhbCc6ICdcXHUyQTc1JyxcbiAgICAnRXF1YWxUaWxkZSc6ICdcXHUyMjQyJyxcbiAgICAnZXFzaW0nOiAnXFx1MjI0MicsXG4gICAgJ2VzaW0nOiAnXFx1MjI0MicsXG4gICAgJ0VxdWlsaWJyaXVtJzogJ1xcdTIxQ0MnLFxuICAgICdyaWdodGxlZnRoYXJwb29ucyc6ICdcXHUyMUNDJyxcbiAgICAncmxoYXInOiAnXFx1MjFDQycsXG4gICAgJ0VzY3InOiAnXFx1MjEzMCcsXG4gICAgJ2V4cGVjdGF0aW9uJzogJ1xcdTIxMzAnLFxuICAgICdFc2ltJzogJ1xcdTJBNzMnLFxuICAgICdFdGEnOiAnXFx1MDM5NycsXG4gICAgJ0V1bWwnOiAnXFx1MDBDQicsXG4gICAgJ0V4aXN0cyc6ICdcXHUyMjAzJyxcbiAgICAnZXhpc3QnOiAnXFx1MjIwMycsXG4gICAgJ0V4cG9uZW50aWFsRSc6ICdcXHUyMTQ3JyxcbiAgICAnZWUnOiAnXFx1MjE0NycsXG4gICAgJ2V4cG9uZW50aWFsZSc6ICdcXHUyMTQ3JyxcbiAgICAnRmN5JzogJ1xcdTA0MjQnLFxuICAgICdGZnInOiAnXFx1RDgzNVxcdUREMDknLFxuICAgICdGaWxsZWRTbWFsbFNxdWFyZSc6ICdcXHUyNUZDJyxcbiAgICAnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJzogJ1xcdTI1QUEnLFxuICAgICdibGFja3NxdWFyZSc6ICdcXHUyNUFBJyxcbiAgICAnc3F1YXJmJzogJ1xcdTI1QUEnLFxuICAgICdzcXVmJzogJ1xcdTI1QUEnLFxuICAgICdGb3BmJzogJ1xcdUQ4MzVcXHVERDNEJyxcbiAgICAnRm9yQWxsJzogJ1xcdTIyMDAnLFxuICAgICdmb3JhbGwnOiAnXFx1MjIwMCcsXG4gICAgJ0ZvdXJpZXJ0cmYnOiAnXFx1MjEzMScsXG4gICAgJ0ZzY3InOiAnXFx1MjEzMScsXG4gICAgJ0dKY3knOiAnXFx1MDQwMycsXG4gICAgJ0dUJzogJ1xcdTAwM0UnLFxuICAgICdndCc6ICdcXHUwMDNFJyxcbiAgICAnR2FtbWEnOiAnXFx1MDM5MycsXG4gICAgJ0dhbW1hZCc6ICdcXHUwM0RDJyxcbiAgICAnR2JyZXZlJzogJ1xcdTAxMUUnLFxuICAgICdHY2VkaWwnOiAnXFx1MDEyMicsXG4gICAgJ0djaXJjJzogJ1xcdTAxMUMnLFxuICAgICdHY3knOiAnXFx1MDQxMycsXG4gICAgJ0dkb3QnOiAnXFx1MDEyMCcsXG4gICAgJ0dmcic6ICdcXHVEODM1XFx1REQwQScsXG4gICAgJ0dnJzogJ1xcdTIyRDknLFxuICAgICdnZ2cnOiAnXFx1MjJEOScsXG4gICAgJ0dvcGYnOiAnXFx1RDgzNVxcdUREM0UnLFxuICAgICdHcmVhdGVyRXF1YWwnOiAnXFx1MjI2NScsXG4gICAgJ2dlJzogJ1xcdTIyNjUnLFxuICAgICdnZXEnOiAnXFx1MjI2NScsXG4gICAgJ0dyZWF0ZXJFcXVhbExlc3MnOiAnXFx1MjJEQicsXG4gICAgJ2dlbCc6ICdcXHUyMkRCJyxcbiAgICAnZ3RyZXFsZXNzJzogJ1xcdTIyREInLFxuICAgICdHcmVhdGVyRnVsbEVxdWFsJzogJ1xcdTIyNjcnLFxuICAgICdnRSc6ICdcXHUyMjY3JyxcbiAgICAnZ2VxcSc6ICdcXHUyMjY3JyxcbiAgICAnR3JlYXRlckdyZWF0ZXInOiAnXFx1MkFBMicsXG4gICAgJ0dyZWF0ZXJMZXNzJzogJ1xcdTIyNzcnLFxuICAgICdnbCc6ICdcXHUyMjc3JyxcbiAgICAnZ3RybGVzcyc6ICdcXHUyMjc3JyxcbiAgICAnR3JlYXRlclNsYW50RXF1YWwnOiAnXFx1MkE3RScsXG4gICAgJ2dlcXNsYW50JzogJ1xcdTJBN0UnLFxuICAgICdnZXMnOiAnXFx1MkE3RScsXG4gICAgJ0dyZWF0ZXJUaWxkZSc6ICdcXHUyMjczJyxcbiAgICAnZ3NpbSc6ICdcXHUyMjczJyxcbiAgICAnZ3Ryc2ltJzogJ1xcdTIyNzMnLFxuICAgICdHc2NyJzogJ1xcdUQ4MzVcXHVEQ0EyJyxcbiAgICAnR3QnOiAnXFx1MjI2QicsXG4gICAgJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJzogJ1xcdTIyNkInLFxuICAgICdnZyc6ICdcXHUyMjZCJyxcbiAgICAnSEFSRGN5JzogJ1xcdTA0MkEnLFxuICAgICdIYWNlayc6ICdcXHUwMkM3JyxcbiAgICAnY2Fyb24nOiAnXFx1MDJDNycsXG4gICAgJ0hhdCc6ICdcXHUwMDVFJyxcbiAgICAnSGNpcmMnOiAnXFx1MDEyNCcsXG4gICAgJ0hmcic6ICdcXHUyMTBDJyxcbiAgICAnUG9pbmNhcmVwbGFuZSc6ICdcXHUyMTBDJyxcbiAgICAnSGlsYmVydFNwYWNlJzogJ1xcdTIxMEInLFxuICAgICdIc2NyJzogJ1xcdTIxMEInLFxuICAgICdoYW1pbHQnOiAnXFx1MjEwQicsXG4gICAgJ0hvcGYnOiAnXFx1MjEwRCcsXG4gICAgJ3F1YXRlcm5pb25zJzogJ1xcdTIxMEQnLFxuICAgICdIb3Jpem9udGFsTGluZSc6ICdcXHUyNTAwJyxcbiAgICAnYm94aCc6ICdcXHUyNTAwJyxcbiAgICAnSHN0cm9rJzogJ1xcdTAxMjYnLFxuICAgICdIdW1wRXF1YWwnOiAnXFx1MjI0RicsXG4gICAgJ2J1bXBlJzogJ1xcdTIyNEYnLFxuICAgICdidW1wZXEnOiAnXFx1MjI0RicsXG4gICAgJ0lFY3knOiAnXFx1MDQxNScsXG4gICAgJ0lKbGlnJzogJ1xcdTAxMzInLFxuICAgICdJT2N5JzogJ1xcdTA0MDEnLFxuICAgICdJYWN1dGUnOiAnXFx1MDBDRCcsXG4gICAgJ0ljaXJjJzogJ1xcdTAwQ0UnLFxuICAgICdJY3knOiAnXFx1MDQxOCcsXG4gICAgJ0lkb3QnOiAnXFx1MDEzMCcsXG4gICAgJ0lmcic6ICdcXHUyMTExJyxcbiAgICAnSW0nOiAnXFx1MjExMScsXG4gICAgJ2ltYWdlJzogJ1xcdTIxMTEnLFxuICAgICdpbWFncGFydCc6ICdcXHUyMTExJyxcbiAgICAnSWdyYXZlJzogJ1xcdTAwQ0MnLFxuICAgICdJbWFjcic6ICdcXHUwMTJBJyxcbiAgICAnSW1hZ2luYXJ5SSc6ICdcXHUyMTQ4JyxcbiAgICAnaWknOiAnXFx1MjE0OCcsXG4gICAgJ0ludCc6ICdcXHUyMjJDJyxcbiAgICAnSW50ZWdyYWwnOiAnXFx1MjIyQicsXG4gICAgJ2ludCc6ICdcXHUyMjJCJyxcbiAgICAnSW50ZXJzZWN0aW9uJzogJ1xcdTIyQzInLFxuICAgICdiaWdjYXAnOiAnXFx1MjJDMicsXG4gICAgJ3hjYXAnOiAnXFx1MjJDMicsXG4gICAgJ0ludmlzaWJsZUNvbW1hJzogJ1xcdTIwNjMnLFxuICAgICdpYyc6ICdcXHUyMDYzJyxcbiAgICAnSW52aXNpYmxlVGltZXMnOiAnXFx1MjA2MicsXG4gICAgJ2l0JzogJ1xcdTIwNjInLFxuICAgICdJb2dvbic6ICdcXHUwMTJFJyxcbiAgICAnSW9wZic6ICdcXHVEODM1XFx1REQ0MCcsXG4gICAgJ0lvdGEnOiAnXFx1MDM5OScsXG4gICAgJ0lzY3InOiAnXFx1MjExMCcsXG4gICAgJ2ltYWdsaW5lJzogJ1xcdTIxMTAnLFxuICAgICdJdGlsZGUnOiAnXFx1MDEyOCcsXG4gICAgJ0l1a2N5JzogJ1xcdTA0MDYnLFxuICAgICdJdW1sJzogJ1xcdTAwQ0YnLFxuICAgICdKY2lyYyc6ICdcXHUwMTM0JyxcbiAgICAnSmN5JzogJ1xcdTA0MTknLFxuICAgICdKZnInOiAnXFx1RDgzNVxcdUREMEQnLFxuICAgICdKb3BmJzogJ1xcdUQ4MzVcXHVERDQxJyxcbiAgICAnSnNjcic6ICdcXHVEODM1XFx1RENBNScsXG4gICAgJ0pzZXJjeSc6ICdcXHUwNDA4JyxcbiAgICAnSnVrY3knOiAnXFx1MDQwNCcsXG4gICAgJ0tIY3knOiAnXFx1MDQyNScsXG4gICAgJ0tKY3knOiAnXFx1MDQwQycsXG4gICAgJ0thcHBhJzogJ1xcdTAzOUEnLFxuICAgICdLY2VkaWwnOiAnXFx1MDEzNicsXG4gICAgJ0tjeSc6ICdcXHUwNDFBJyxcbiAgICAnS2ZyJzogJ1xcdUQ4MzVcXHVERDBFJyxcbiAgICAnS29wZic6ICdcXHVEODM1XFx1REQ0MicsXG4gICAgJ0tzY3InOiAnXFx1RDgzNVxcdURDQTYnLFxuICAgICdMSmN5JzogJ1xcdTA0MDknLFxuICAgICdMVCc6ICdcXHUwMDNDJyxcbiAgICAnbHQnOiAnXFx1MDAzQycsXG4gICAgJ0xhY3V0ZSc6ICdcXHUwMTM5JyxcbiAgICAnTGFtYmRhJzogJ1xcdTAzOUInLFxuICAgICdMYW5nJzogJ1xcdTI3RUEnLFxuICAgICdMYXBsYWNldHJmJzogJ1xcdTIxMTInLFxuICAgICdMc2NyJzogJ1xcdTIxMTInLFxuICAgICdsYWdyYW4nOiAnXFx1MjExMicsXG4gICAgJ0xhcnInOiAnXFx1MjE5RScsXG4gICAgJ3R3b2hlYWRsZWZ0YXJyb3cnOiAnXFx1MjE5RScsXG4gICAgJ0xjYXJvbic6ICdcXHUwMTNEJyxcbiAgICAnTGNlZGlsJzogJ1xcdTAxM0InLFxuICAgICdMY3knOiAnXFx1MDQxQicsXG4gICAgJ0xlZnRBbmdsZUJyYWNrZXQnOiAnXFx1MjdFOCcsXG4gICAgJ2xhbmcnOiAnXFx1MjdFOCcsXG4gICAgJ2xhbmdsZSc6ICdcXHUyN0U4JyxcbiAgICAnTGVmdEFycm93JzogJ1xcdTIxOTAnLFxuICAgICdTaG9ydExlZnRBcnJvdyc6ICdcXHUyMTkwJyxcbiAgICAnbGFycic6ICdcXHUyMTkwJyxcbiAgICAnbGVmdGFycm93JzogJ1xcdTIxOTAnLFxuICAgICdzbGFycic6ICdcXHUyMTkwJyxcbiAgICAnTGVmdEFycm93QmFyJzogJ1xcdTIxRTQnLFxuICAgICdsYXJyYic6ICdcXHUyMUU0JyxcbiAgICAnTGVmdEFycm93UmlnaHRBcnJvdyc6ICdcXHUyMUM2JyxcbiAgICAnbGVmdHJpZ2h0YXJyb3dzJzogJ1xcdTIxQzYnLFxuICAgICdscmFycic6ICdcXHUyMUM2JyxcbiAgICAnTGVmdENlaWxpbmcnOiAnXFx1MjMwOCcsXG4gICAgJ2xjZWlsJzogJ1xcdTIzMDgnLFxuICAgICdMZWZ0RG91YmxlQnJhY2tldCc6ICdcXHUyN0U2JyxcbiAgICAnbG9icmsnOiAnXFx1MjdFNicsXG4gICAgJ0xlZnREb3duVGVlVmVjdG9yJzogJ1xcdTI5NjEnLFxuICAgICdMZWZ0RG93blZlY3Rvcic6ICdcXHUyMUMzJyxcbiAgICAnZGhhcmwnOiAnXFx1MjFDMycsXG4gICAgJ2Rvd25oYXJwb29ubGVmdCc6ICdcXHUyMUMzJyxcbiAgICAnTGVmdERvd25WZWN0b3JCYXInOiAnXFx1Mjk1OScsXG4gICAgJ0xlZnRGbG9vcic6ICdcXHUyMzBBJyxcbiAgICAnbGZsb29yJzogJ1xcdTIzMEEnLFxuICAgICdMZWZ0UmlnaHRBcnJvdyc6ICdcXHUyMTk0JyxcbiAgICAnaGFycic6ICdcXHUyMTk0JyxcbiAgICAnbGVmdHJpZ2h0YXJyb3cnOiAnXFx1MjE5NCcsXG4gICAgJ0xlZnRSaWdodFZlY3Rvcic6ICdcXHUyOTRFJyxcbiAgICAnTGVmdFRlZSc6ICdcXHUyMkEzJyxcbiAgICAnZGFzaHYnOiAnXFx1MjJBMycsXG4gICAgJ0xlZnRUZWVBcnJvdyc6ICdcXHUyMUE0JyxcbiAgICAnbWFwc3RvbGVmdCc6ICdcXHUyMUE0JyxcbiAgICAnTGVmdFRlZVZlY3Rvcic6ICdcXHUyOTVBJyxcbiAgICAnTGVmdFRyaWFuZ2xlJzogJ1xcdTIyQjInLFxuICAgICd2YXJ0cmlhbmdsZWxlZnQnOiAnXFx1MjJCMicsXG4gICAgJ3ZsdHJpJzogJ1xcdTIyQjInLFxuICAgICdMZWZ0VHJpYW5nbGVCYXInOiAnXFx1MjlDRicsXG4gICAgJ0xlZnRUcmlhbmdsZUVxdWFsJzogJ1xcdTIyQjQnLFxuICAgICdsdHJpZSc6ICdcXHUyMkI0JyxcbiAgICAndHJpYW5nbGVsZWZ0ZXEnOiAnXFx1MjJCNCcsXG4gICAgJ0xlZnRVcERvd25WZWN0b3InOiAnXFx1Mjk1MScsXG4gICAgJ0xlZnRVcFRlZVZlY3Rvcic6ICdcXHUyOTYwJyxcbiAgICAnTGVmdFVwVmVjdG9yJzogJ1xcdTIxQkYnLFxuICAgICd1aGFybCc6ICdcXHUyMUJGJyxcbiAgICAndXBoYXJwb29ubGVmdCc6ICdcXHUyMUJGJyxcbiAgICAnTGVmdFVwVmVjdG9yQmFyJzogJ1xcdTI5NTgnLFxuICAgICdMZWZ0VmVjdG9yJzogJ1xcdTIxQkMnLFxuICAgICdsZWZ0aGFycG9vbnVwJzogJ1xcdTIxQkMnLFxuICAgICdsaGFydSc6ICdcXHUyMUJDJyxcbiAgICAnTGVmdFZlY3RvckJhcic6ICdcXHUyOTUyJyxcbiAgICAnTGVzc0VxdWFsR3JlYXRlcic6ICdcXHUyMkRBJyxcbiAgICAnbGVnJzogJ1xcdTIyREEnLFxuICAgICdsZXNzZXFndHInOiAnXFx1MjJEQScsXG4gICAgJ0xlc3NGdWxsRXF1YWwnOiAnXFx1MjI2NicsXG4gICAgJ2xFJzogJ1xcdTIyNjYnLFxuICAgICdsZXFxJzogJ1xcdTIyNjYnLFxuICAgICdMZXNzR3JlYXRlcic6ICdcXHUyMjc2JyxcbiAgICAnbGVzc2d0cic6ICdcXHUyMjc2JyxcbiAgICAnbGcnOiAnXFx1MjI3NicsXG4gICAgJ0xlc3NMZXNzJzogJ1xcdTJBQTEnLFxuICAgICdMZXNzU2xhbnRFcXVhbCc6ICdcXHUyQTdEJyxcbiAgICAnbGVxc2xhbnQnOiAnXFx1MkE3RCcsXG4gICAgJ2xlcyc6ICdcXHUyQTdEJyxcbiAgICAnTGVzc1RpbGRlJzogJ1xcdTIyNzInLFxuICAgICdsZXNzc2ltJzogJ1xcdTIyNzInLFxuICAgICdsc2ltJzogJ1xcdTIyNzInLFxuICAgICdMZnInOiAnXFx1RDgzNVxcdUREMEYnLFxuICAgICdMbCc6ICdcXHUyMkQ4JyxcbiAgICAnTGxlZnRhcnJvdyc6ICdcXHUyMURBJyxcbiAgICAnbEFhcnInOiAnXFx1MjFEQScsXG4gICAgJ0xtaWRvdCc6ICdcXHUwMTNGJyxcbiAgICAnTG9uZ0xlZnRBcnJvdyc6ICdcXHUyN0Y1JyxcbiAgICAnbG9uZ2xlZnRhcnJvdyc6ICdcXHUyN0Y1JyxcbiAgICAneGxhcnInOiAnXFx1MjdGNScsXG4gICAgJ0xvbmdMZWZ0UmlnaHRBcnJvdyc6ICdcXHUyN0Y3JyxcbiAgICAnbG9uZ2xlZnRyaWdodGFycm93JzogJ1xcdTI3RjcnLFxuICAgICd4aGFycic6ICdcXHUyN0Y3JyxcbiAgICAnTG9uZ1JpZ2h0QXJyb3cnOiAnXFx1MjdGNicsXG4gICAgJ2xvbmdyaWdodGFycm93JzogJ1xcdTI3RjYnLFxuICAgICd4cmFycic6ICdcXHUyN0Y2JyxcbiAgICAnTG9wZic6ICdcXHVEODM1XFx1REQ0MycsXG4gICAgJ0xvd2VyTGVmdEFycm93JzogJ1xcdTIxOTknLFxuICAgICdzd2Fycic6ICdcXHUyMTk5JyxcbiAgICAnc3dhcnJvdyc6ICdcXHUyMTk5JyxcbiAgICAnTG93ZXJSaWdodEFycm93JzogJ1xcdTIxOTgnLFxuICAgICdzZWFycic6ICdcXHUyMTk4JyxcbiAgICAnc2VhcnJvdyc6ICdcXHUyMTk4JyxcbiAgICAnTHNoJzogJ1xcdTIxQjAnLFxuICAgICdsc2gnOiAnXFx1MjFCMCcsXG4gICAgJ0xzdHJvayc6ICdcXHUwMTQxJyxcbiAgICAnTHQnOiAnXFx1MjI2QScsXG4gICAgJ05lc3RlZExlc3NMZXNzJzogJ1xcdTIyNkEnLFxuICAgICdsbCc6ICdcXHUyMjZBJyxcbiAgICAnTWFwJzogJ1xcdTI5MDUnLFxuICAgICdNY3knOiAnXFx1MDQxQycsXG4gICAgJ01lZGl1bVNwYWNlJzogJ1xcdTIwNUYnLFxuICAgICdNZWxsaW50cmYnOiAnXFx1MjEzMycsXG4gICAgJ01zY3InOiAnXFx1MjEzMycsXG4gICAgJ3BobW1hdCc6ICdcXHUyMTMzJyxcbiAgICAnTWZyJzogJ1xcdUQ4MzVcXHVERDEwJyxcbiAgICAnTWludXNQbHVzJzogJ1xcdTIyMTMnLFxuICAgICdtbnBsdXMnOiAnXFx1MjIxMycsXG4gICAgJ21wJzogJ1xcdTIyMTMnLFxuICAgICdNb3BmJzogJ1xcdUQ4MzVcXHVERDQ0JyxcbiAgICAnTXUnOiAnXFx1MDM5QycsXG4gICAgJ05KY3knOiAnXFx1MDQwQScsXG4gICAgJ05hY3V0ZSc6ICdcXHUwMTQzJyxcbiAgICAnTmNhcm9uJzogJ1xcdTAxNDcnLFxuICAgICdOY2VkaWwnOiAnXFx1MDE0NScsXG4gICAgJ05jeSc6ICdcXHUwNDFEJyxcbiAgICAnTmVnYXRpdmVNZWRpdW1TcGFjZSc6ICdcXHUyMDBCJyxcbiAgICAnTmVnYXRpdmVUaGlja1NwYWNlJzogJ1xcdTIwMEInLFxuICAgICdOZWdhdGl2ZVRoaW5TcGFjZSc6ICdcXHUyMDBCJyxcbiAgICAnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJzogJ1xcdTIwMEInLFxuICAgICdaZXJvV2lkdGhTcGFjZSc6ICdcXHUyMDBCJyxcbiAgICAnTmV3TGluZSc6ICdcXHUwMDBBJyxcbiAgICAnTmZyJzogJ1xcdUQ4MzVcXHVERDExJyxcbiAgICAnTm9CcmVhayc6ICdcXHUyMDYwJyxcbiAgICAnTm9uQnJlYWtpbmdTcGFjZSc6ICdcXHUwMEEwJyxcbiAgICAnbmJzcCc6ICdcXHUwMEEwJyxcbiAgICAnTm9wZic6ICdcXHUyMTE1JyxcbiAgICAnbmF0dXJhbHMnOiAnXFx1MjExNScsXG4gICAgJ05vdCc6ICdcXHUyQUVDJyxcbiAgICAnTm90Q29uZ3J1ZW50JzogJ1xcdTIyNjInLFxuICAgICduZXF1aXYnOiAnXFx1MjI2MicsXG4gICAgJ05vdEN1cENhcCc6ICdcXHUyMjZEJyxcbiAgICAnTm90RG91YmxlVmVydGljYWxCYXInOiAnXFx1MjIyNicsXG4gICAgJ25wYXInOiAnXFx1MjIyNicsXG4gICAgJ25wYXJhbGxlbCc6ICdcXHUyMjI2JyxcbiAgICAnbnNob3J0cGFyYWxsZWwnOiAnXFx1MjIyNicsXG4gICAgJ25zcGFyJzogJ1xcdTIyMjYnLFxuICAgICdOb3RFbGVtZW50JzogJ1xcdTIyMDknLFxuICAgICdub3Rpbic6ICdcXHUyMjA5JyxcbiAgICAnbm90aW52YSc6ICdcXHUyMjA5JyxcbiAgICAnTm90RXF1YWwnOiAnXFx1MjI2MCcsXG4gICAgJ25lJzogJ1xcdTIyNjAnLFxuICAgICdOb3RFcXVhbFRpbGRlJzogJ1xcdTIyNDJcXHUwMzM4JyxcbiAgICAnbmVzaW0nOiAnXFx1MjI0MlxcdTAzMzgnLFxuICAgICdOb3RFeGlzdHMnOiAnXFx1MjIwNCcsXG4gICAgJ25leGlzdCc6ICdcXHUyMjA0JyxcbiAgICAnbmV4aXN0cyc6ICdcXHUyMjA0JyxcbiAgICAnTm90R3JlYXRlcic6ICdcXHUyMjZGJyxcbiAgICAnbmd0JzogJ1xcdTIyNkYnLFxuICAgICduZ3RyJzogJ1xcdTIyNkYnLFxuICAgICdOb3RHcmVhdGVyRXF1YWwnOiAnXFx1MjI3MScsXG4gICAgJ25nZSc6ICdcXHUyMjcxJyxcbiAgICAnbmdlcSc6ICdcXHUyMjcxJyxcbiAgICAnTm90R3JlYXRlckZ1bGxFcXVhbCc6ICdcXHUyMjY3XFx1MDMzOCcsXG4gICAgJ25nRSc6ICdcXHUyMjY3XFx1MDMzOCcsXG4gICAgJ25nZXFxJzogJ1xcdTIyNjdcXHUwMzM4JyxcbiAgICAnTm90R3JlYXRlckdyZWF0ZXInOiAnXFx1MjI2QlxcdTAzMzgnLFxuICAgICduR3R2JzogJ1xcdTIyNkJcXHUwMzM4JyxcbiAgICAnTm90R3JlYXRlckxlc3MnOiAnXFx1MjI3OScsXG4gICAgJ250Z2wnOiAnXFx1MjI3OScsXG4gICAgJ05vdEdyZWF0ZXJTbGFudEVxdWFsJzogJ1xcdTJBN0VcXHUwMzM4JyxcbiAgICAnbmdlcXNsYW50JzogJ1xcdTJBN0VcXHUwMzM4JyxcbiAgICAnbmdlcyc6ICdcXHUyQTdFXFx1MDMzOCcsXG4gICAgJ05vdEdyZWF0ZXJUaWxkZSc6ICdcXHUyMjc1JyxcbiAgICAnbmdzaW0nOiAnXFx1MjI3NScsXG4gICAgJ05vdEh1bXBEb3duSHVtcCc6ICdcXHUyMjRFXFx1MDMzOCcsXG4gICAgJ25idW1wJzogJ1xcdTIyNEVcXHUwMzM4JyxcbiAgICAnTm90SHVtcEVxdWFsJzogJ1xcdTIyNEZcXHUwMzM4JyxcbiAgICAnbmJ1bXBlJzogJ1xcdTIyNEZcXHUwMzM4JyxcbiAgICAnTm90TGVmdFRyaWFuZ2xlJzogJ1xcdTIyRUEnLFxuICAgICdubHRyaSc6ICdcXHUyMkVBJyxcbiAgICAnbnRyaWFuZ2xlbGVmdCc6ICdcXHUyMkVBJyxcbiAgICAnTm90TGVmdFRyaWFuZ2xlQmFyJzogJ1xcdTI5Q0ZcXHUwMzM4JyxcbiAgICAnTm90TGVmdFRyaWFuZ2xlRXF1YWwnOiAnXFx1MjJFQycsXG4gICAgJ25sdHJpZSc6ICdcXHUyMkVDJyxcbiAgICAnbnRyaWFuZ2xlbGVmdGVxJzogJ1xcdTIyRUMnLFxuICAgICdOb3RMZXNzJzogJ1xcdTIyNkUnLFxuICAgICdubGVzcyc6ICdcXHUyMjZFJyxcbiAgICAnbmx0JzogJ1xcdTIyNkUnLFxuICAgICdOb3RMZXNzRXF1YWwnOiAnXFx1MjI3MCcsXG4gICAgJ25sZSc6ICdcXHUyMjcwJyxcbiAgICAnbmxlcSc6ICdcXHUyMjcwJyxcbiAgICAnTm90TGVzc0dyZWF0ZXInOiAnXFx1MjI3OCcsXG4gICAgJ250bGcnOiAnXFx1MjI3OCcsXG4gICAgJ05vdExlc3NMZXNzJzogJ1xcdTIyNkFcXHUwMzM4JyxcbiAgICAnbkx0dic6ICdcXHUyMjZBXFx1MDMzOCcsXG4gICAgJ05vdExlc3NTbGFudEVxdWFsJzogJ1xcdTJBN0RcXHUwMzM4JyxcbiAgICAnbmxlcXNsYW50JzogJ1xcdTJBN0RcXHUwMzM4JyxcbiAgICAnbmxlcyc6ICdcXHUyQTdEXFx1MDMzOCcsXG4gICAgJ05vdExlc3NUaWxkZSc6ICdcXHUyMjc0JyxcbiAgICAnbmxzaW0nOiAnXFx1MjI3NCcsXG4gICAgJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJzogJ1xcdTJBQTJcXHUwMzM4JyxcbiAgICAnTm90TmVzdGVkTGVzc0xlc3MnOiAnXFx1MkFBMVxcdTAzMzgnLFxuICAgICdOb3RQcmVjZWRlcyc6ICdcXHUyMjgwJyxcbiAgICAnbnByJzogJ1xcdTIyODAnLFxuICAgICducHJlYyc6ICdcXHUyMjgwJyxcbiAgICAnTm90UHJlY2VkZXNFcXVhbCc6ICdcXHUyQUFGXFx1MDMzOCcsXG4gICAgJ25wcmUnOiAnXFx1MkFBRlxcdTAzMzgnLFxuICAgICducHJlY2VxJzogJ1xcdTJBQUZcXHUwMzM4JyxcbiAgICAnTm90UHJlY2VkZXNTbGFudEVxdWFsJzogJ1xcdTIyRTAnLFxuICAgICducHJjdWUnOiAnXFx1MjJFMCcsXG4gICAgJ05vdFJldmVyc2VFbGVtZW50JzogJ1xcdTIyMEMnLFxuICAgICdub3RuaSc6ICdcXHUyMjBDJyxcbiAgICAnbm90bml2YSc6ICdcXHUyMjBDJyxcbiAgICAnTm90UmlnaHRUcmlhbmdsZSc6ICdcXHUyMkVCJyxcbiAgICAnbnJ0cmknOiAnXFx1MjJFQicsXG4gICAgJ250cmlhbmdsZXJpZ2h0JzogJ1xcdTIyRUInLFxuICAgICdOb3RSaWdodFRyaWFuZ2xlQmFyJzogJ1xcdTI5RDBcXHUwMzM4JyxcbiAgICAnTm90UmlnaHRUcmlhbmdsZUVxdWFsJzogJ1xcdTIyRUQnLFxuICAgICducnRyaWUnOiAnXFx1MjJFRCcsXG4gICAgJ250cmlhbmdsZXJpZ2h0ZXEnOiAnXFx1MjJFRCcsXG4gICAgJ05vdFNxdWFyZVN1YnNldCc6ICdcXHUyMjhGXFx1MDMzOCcsXG4gICAgJ05vdFNxdWFyZVN1YnNldEVxdWFsJzogJ1xcdTIyRTInLFxuICAgICduc3FzdWJlJzogJ1xcdTIyRTInLFxuICAgICdOb3RTcXVhcmVTdXBlcnNldCc6ICdcXHUyMjkwXFx1MDMzOCcsXG4gICAgJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnOiAnXFx1MjJFMycsXG4gICAgJ25zcXN1cGUnOiAnXFx1MjJFMycsXG4gICAgJ05vdFN1YnNldCc6ICdcXHUyMjgyXFx1MjBEMicsXG4gICAgJ25zdWJzZXQnOiAnXFx1MjI4MlxcdTIwRDInLFxuICAgICd2bnN1Yic6ICdcXHUyMjgyXFx1MjBEMicsXG4gICAgJ05vdFN1YnNldEVxdWFsJzogJ1xcdTIyODgnLFxuICAgICduc3ViZSc6ICdcXHUyMjg4JyxcbiAgICAnbnN1YnNldGVxJzogJ1xcdTIyODgnLFxuICAgICdOb3RTdWNjZWVkcyc6ICdcXHUyMjgxJyxcbiAgICAnbnNjJzogJ1xcdTIyODEnLFxuICAgICduc3VjYyc6ICdcXHUyMjgxJyxcbiAgICAnTm90U3VjY2VlZHNFcXVhbCc6ICdcXHUyQUIwXFx1MDMzOCcsXG4gICAgJ25zY2UnOiAnXFx1MkFCMFxcdTAzMzgnLFxuICAgICduc3VjY2VxJzogJ1xcdTJBQjBcXHUwMzM4JyxcbiAgICAnTm90U3VjY2VlZHNTbGFudEVxdWFsJzogJ1xcdTIyRTEnLFxuICAgICduc2NjdWUnOiAnXFx1MjJFMScsXG4gICAgJ05vdFN1Y2NlZWRzVGlsZGUnOiAnXFx1MjI3RlxcdTAzMzgnLFxuICAgICdOb3RTdXBlcnNldCc6ICdcXHUyMjgzXFx1MjBEMicsXG4gICAgJ25zdXBzZXQnOiAnXFx1MjI4M1xcdTIwRDInLFxuICAgICd2bnN1cCc6ICdcXHUyMjgzXFx1MjBEMicsXG4gICAgJ05vdFN1cGVyc2V0RXF1YWwnOiAnXFx1MjI4OScsXG4gICAgJ25zdXBlJzogJ1xcdTIyODknLFxuICAgICduc3Vwc2V0ZXEnOiAnXFx1MjI4OScsXG4gICAgJ05vdFRpbGRlJzogJ1xcdTIyNDEnLFxuICAgICduc2ltJzogJ1xcdTIyNDEnLFxuICAgICdOb3RUaWxkZUVxdWFsJzogJ1xcdTIyNDQnLFxuICAgICduc2ltZSc6ICdcXHUyMjQ0JyxcbiAgICAnbnNpbWVxJzogJ1xcdTIyNDQnLFxuICAgICdOb3RUaWxkZUZ1bGxFcXVhbCc6ICdcXHUyMjQ3JyxcbiAgICAnbmNvbmcnOiAnXFx1MjI0NycsXG4gICAgJ05vdFRpbGRlVGlsZGUnOiAnXFx1MjI0OScsXG4gICAgJ25hcCc6ICdcXHUyMjQ5JyxcbiAgICAnbmFwcHJveCc6ICdcXHUyMjQ5JyxcbiAgICAnTm90VmVydGljYWxCYXInOiAnXFx1MjIyNCcsXG4gICAgJ25taWQnOiAnXFx1MjIyNCcsXG4gICAgJ25zaG9ydG1pZCc6ICdcXHUyMjI0JyxcbiAgICAnbnNtaWQnOiAnXFx1MjIyNCcsXG4gICAgJ05zY3InOiAnXFx1RDgzNVxcdURDQTknLFxuICAgICdOdGlsZGUnOiAnXFx1MDBEMScsXG4gICAgJ051JzogJ1xcdTAzOUQnLFxuICAgICdPRWxpZyc6ICdcXHUwMTUyJyxcbiAgICAnT2FjdXRlJzogJ1xcdTAwRDMnLFxuICAgICdPY2lyYyc6ICdcXHUwMEQ0JyxcbiAgICAnT2N5JzogJ1xcdTA0MUUnLFxuICAgICdPZGJsYWMnOiAnXFx1MDE1MCcsXG4gICAgJ09mcic6ICdcXHVEODM1XFx1REQxMicsXG4gICAgJ09ncmF2ZSc6ICdcXHUwMEQyJyxcbiAgICAnT21hY3InOiAnXFx1MDE0QycsXG4gICAgJ09tZWdhJzogJ1xcdTAzQTknLFxuICAgICdvaG0nOiAnXFx1MDNBOScsXG4gICAgJ09taWNyb24nOiAnXFx1MDM5RicsXG4gICAgJ09vcGYnOiAnXFx1RDgzNVxcdURENDYnLFxuICAgICdPcGVuQ3VybHlEb3VibGVRdW90ZSc6ICdcXHUyMDFDJyxcbiAgICAnbGRxdW8nOiAnXFx1MjAxQycsXG4gICAgJ09wZW5DdXJseVF1b3RlJzogJ1xcdTIwMTgnLFxuICAgICdsc3F1byc6ICdcXHUyMDE4JyxcbiAgICAnT3InOiAnXFx1MkE1NCcsXG4gICAgJ09zY3InOiAnXFx1RDgzNVxcdURDQUEnLFxuICAgICdPc2xhc2gnOiAnXFx1MDBEOCcsXG4gICAgJ090aWxkZSc6ICdcXHUwMEQ1JyxcbiAgICAnT3RpbWVzJzogJ1xcdTJBMzcnLFxuICAgICdPdW1sJzogJ1xcdTAwRDYnLFxuICAgICdPdmVyQmFyJzogJ1xcdTIwM0UnLFxuICAgICdvbGluZSc6ICdcXHUyMDNFJyxcbiAgICAnT3ZlckJyYWNlJzogJ1xcdTIzREUnLFxuICAgICdPdmVyQnJhY2tldCc6ICdcXHUyM0I0JyxcbiAgICAndGJyayc6ICdcXHUyM0I0JyxcbiAgICAnT3ZlclBhcmVudGhlc2lzJzogJ1xcdTIzREMnLFxuICAgICdQYXJ0aWFsRCc6ICdcXHUyMjAyJyxcbiAgICAncGFydCc6ICdcXHUyMjAyJyxcbiAgICAnUGN5JzogJ1xcdTA0MUYnLFxuICAgICdQZnInOiAnXFx1RDgzNVxcdUREMTMnLFxuICAgICdQaGknOiAnXFx1MDNBNicsXG4gICAgJ1BpJzogJ1xcdTAzQTAnLFxuICAgICdQbHVzTWludXMnOiAnXFx1MDBCMScsXG4gICAgJ3BsdXNtbic6ICdcXHUwMEIxJyxcbiAgICAncG0nOiAnXFx1MDBCMScsXG4gICAgJ1BvcGYnOiAnXFx1MjExOScsXG4gICAgJ3ByaW1lcyc6ICdcXHUyMTE5JyxcbiAgICAnUHInOiAnXFx1MkFCQicsXG4gICAgJ1ByZWNlZGVzJzogJ1xcdTIyN0EnLFxuICAgICdwcic6ICdcXHUyMjdBJyxcbiAgICAncHJlYyc6ICdcXHUyMjdBJyxcbiAgICAnUHJlY2VkZXNFcXVhbCc6ICdcXHUyQUFGJyxcbiAgICAncHJlJzogJ1xcdTJBQUYnLFxuICAgICdwcmVjZXEnOiAnXFx1MkFBRicsXG4gICAgJ1ByZWNlZGVzU2xhbnRFcXVhbCc6ICdcXHUyMjdDJyxcbiAgICAncHJjdWUnOiAnXFx1MjI3QycsXG4gICAgJ3ByZWNjdXJseWVxJzogJ1xcdTIyN0MnLFxuICAgICdQcmVjZWRlc1RpbGRlJzogJ1xcdTIyN0UnLFxuICAgICdwcmVjc2ltJzogJ1xcdTIyN0UnLFxuICAgICdwcnNpbSc6ICdcXHUyMjdFJyxcbiAgICAnUHJpbWUnOiAnXFx1MjAzMycsXG4gICAgJ1Byb2R1Y3QnOiAnXFx1MjIwRicsXG4gICAgJ3Byb2QnOiAnXFx1MjIwRicsXG4gICAgJ1Byb3BvcnRpb25hbCc6ICdcXHUyMjFEJyxcbiAgICAncHJvcCc6ICdcXHUyMjFEJyxcbiAgICAncHJvcHRvJzogJ1xcdTIyMUQnLFxuICAgICd2YXJwcm9wdG8nOiAnXFx1MjIxRCcsXG4gICAgJ3Zwcm9wJzogJ1xcdTIyMUQnLFxuICAgICdQc2NyJzogJ1xcdUQ4MzVcXHVEQ0FCJyxcbiAgICAnUHNpJzogJ1xcdTAzQTgnLFxuICAgICdRVU9UJzogJ1xcdTAwMjInLFxuICAgICdxdW90JzogJ1xcdTAwMjInLFxuICAgICdRZnInOiAnXFx1RDgzNVxcdUREMTQnLFxuICAgICdRb3BmJzogJ1xcdTIxMUEnLFxuICAgICdyYXRpb25hbHMnOiAnXFx1MjExQScsXG4gICAgJ1FzY3InOiAnXFx1RDgzNVxcdURDQUMnLFxuICAgICdSQmFycic6ICdcXHUyOTEwJyxcbiAgICAnZHJia2Fyb3cnOiAnXFx1MjkxMCcsXG4gICAgJ1JFRyc6ICdcXHUwMEFFJyxcbiAgICAnY2lyY2xlZFInOiAnXFx1MDBBRScsXG4gICAgJ3JlZyc6ICdcXHUwMEFFJyxcbiAgICAnUmFjdXRlJzogJ1xcdTAxNTQnLFxuICAgICdSYW5nJzogJ1xcdTI3RUInLFxuICAgICdSYXJyJzogJ1xcdTIxQTAnLFxuICAgICd0d29oZWFkcmlnaHRhcnJvdyc6ICdcXHUyMUEwJyxcbiAgICAnUmFycnRsJzogJ1xcdTI5MTYnLFxuICAgICdSY2Fyb24nOiAnXFx1MDE1OCcsXG4gICAgJ1JjZWRpbCc6ICdcXHUwMTU2JyxcbiAgICAnUmN5JzogJ1xcdTA0MjAnLFxuICAgICdSZSc6ICdcXHUyMTFDJyxcbiAgICAnUmZyJzogJ1xcdTIxMUMnLFxuICAgICdyZWFsJzogJ1xcdTIxMUMnLFxuICAgICdyZWFscGFydCc6ICdcXHUyMTFDJyxcbiAgICAnUmV2ZXJzZUVsZW1lbnQnOiAnXFx1MjIwQicsXG4gICAgJ1N1Y2hUaGF0JzogJ1xcdTIyMEInLFxuICAgICduaSc6ICdcXHUyMjBCJyxcbiAgICAnbml2JzogJ1xcdTIyMEInLFxuICAgICdSZXZlcnNlRXF1aWxpYnJpdW0nOiAnXFx1MjFDQicsXG4gICAgJ2xlZnRyaWdodGhhcnBvb25zJzogJ1xcdTIxQ0InLFxuICAgICdscmhhcic6ICdcXHUyMUNCJyxcbiAgICAnUmV2ZXJzZVVwRXF1aWxpYnJpdW0nOiAnXFx1Mjk2RicsXG4gICAgJ2R1aGFyJzogJ1xcdTI5NkYnLFxuICAgICdSaG8nOiAnXFx1MDNBMScsXG4gICAgJ1JpZ2h0QW5nbGVCcmFja2V0JzogJ1xcdTI3RTknLFxuICAgICdyYW5nJzogJ1xcdTI3RTknLFxuICAgICdyYW5nbGUnOiAnXFx1MjdFOScsXG4gICAgJ1JpZ2h0QXJyb3cnOiAnXFx1MjE5MicsXG4gICAgJ1Nob3J0UmlnaHRBcnJvdyc6ICdcXHUyMTkyJyxcbiAgICAncmFycic6ICdcXHUyMTkyJyxcbiAgICAncmlnaHRhcnJvdyc6ICdcXHUyMTkyJyxcbiAgICAnc3JhcnInOiAnXFx1MjE5MicsXG4gICAgJ1JpZ2h0QXJyb3dCYXInOiAnXFx1MjFFNScsXG4gICAgJ3JhcnJiJzogJ1xcdTIxRTUnLFxuICAgICdSaWdodEFycm93TGVmdEFycm93JzogJ1xcdTIxQzQnLFxuICAgICdyaWdodGxlZnRhcnJvd3MnOiAnXFx1MjFDNCcsXG4gICAgJ3JsYXJyJzogJ1xcdTIxQzQnLFxuICAgICdSaWdodENlaWxpbmcnOiAnXFx1MjMwOScsXG4gICAgJ3JjZWlsJzogJ1xcdTIzMDknLFxuICAgICdSaWdodERvdWJsZUJyYWNrZXQnOiAnXFx1MjdFNycsXG4gICAgJ3JvYnJrJzogJ1xcdTI3RTcnLFxuICAgICdSaWdodERvd25UZWVWZWN0b3InOiAnXFx1Mjk1RCcsXG4gICAgJ1JpZ2h0RG93blZlY3Rvcic6ICdcXHUyMUMyJyxcbiAgICAnZGhhcnInOiAnXFx1MjFDMicsXG4gICAgJ2Rvd25oYXJwb29ucmlnaHQnOiAnXFx1MjFDMicsXG4gICAgJ1JpZ2h0RG93blZlY3RvckJhcic6ICdcXHUyOTU1JyxcbiAgICAnUmlnaHRGbG9vcic6ICdcXHUyMzBCJyxcbiAgICAncmZsb29yJzogJ1xcdTIzMEInLFxuICAgICdSaWdodFRlZSc6ICdcXHUyMkEyJyxcbiAgICAndmRhc2gnOiAnXFx1MjJBMicsXG4gICAgJ1JpZ2h0VGVlQXJyb3cnOiAnXFx1MjFBNicsXG4gICAgJ21hcCc6ICdcXHUyMUE2JyxcbiAgICAnbWFwc3RvJzogJ1xcdTIxQTYnLFxuICAgICdSaWdodFRlZVZlY3Rvcic6ICdcXHUyOTVCJyxcbiAgICAnUmlnaHRUcmlhbmdsZSc6ICdcXHUyMkIzJyxcbiAgICAndmFydHJpYW5nbGVyaWdodCc6ICdcXHUyMkIzJyxcbiAgICAndnJ0cmknOiAnXFx1MjJCMycsXG4gICAgJ1JpZ2h0VHJpYW5nbGVCYXInOiAnXFx1MjlEMCcsXG4gICAgJ1JpZ2h0VHJpYW5nbGVFcXVhbCc6ICdcXHUyMkI1JyxcbiAgICAncnRyaWUnOiAnXFx1MjJCNScsXG4gICAgJ3RyaWFuZ2xlcmlnaHRlcSc6ICdcXHUyMkI1JyxcbiAgICAnUmlnaHRVcERvd25WZWN0b3InOiAnXFx1Mjk0RicsXG4gICAgJ1JpZ2h0VXBUZWVWZWN0b3InOiAnXFx1Mjk1QycsXG4gICAgJ1JpZ2h0VXBWZWN0b3InOiAnXFx1MjFCRScsXG4gICAgJ3VoYXJyJzogJ1xcdTIxQkUnLFxuICAgICd1cGhhcnBvb25yaWdodCc6ICdcXHUyMUJFJyxcbiAgICAnUmlnaHRVcFZlY3RvckJhcic6ICdcXHUyOTU0JyxcbiAgICAnUmlnaHRWZWN0b3InOiAnXFx1MjFDMCcsXG4gICAgJ3JoYXJ1JzogJ1xcdTIxQzAnLFxuICAgICdyaWdodGhhcnBvb251cCc6ICdcXHUyMUMwJyxcbiAgICAnUmlnaHRWZWN0b3JCYXInOiAnXFx1Mjk1MycsXG4gICAgJ1JvcGYnOiAnXFx1MjExRCcsXG4gICAgJ3JlYWxzJzogJ1xcdTIxMUQnLFxuICAgICdSb3VuZEltcGxpZXMnOiAnXFx1Mjk3MCcsXG4gICAgJ1JyaWdodGFycm93JzogJ1xcdTIxREInLFxuICAgICdyQWFycic6ICdcXHUyMURCJyxcbiAgICAnUnNjcic6ICdcXHUyMTFCJyxcbiAgICAncmVhbGluZSc6ICdcXHUyMTFCJyxcbiAgICAnUnNoJzogJ1xcdTIxQjEnLFxuICAgICdyc2gnOiAnXFx1MjFCMScsXG4gICAgJ1J1bGVEZWxheWVkJzogJ1xcdTI5RjQnLFxuICAgICdTSENIY3knOiAnXFx1MDQyOScsXG4gICAgJ1NIY3knOiAnXFx1MDQyOCcsXG4gICAgJ1NPRlRjeSc6ICdcXHUwNDJDJyxcbiAgICAnU2FjdXRlJzogJ1xcdTAxNUEnLFxuICAgICdTYyc6ICdcXHUyQUJDJyxcbiAgICAnU2Nhcm9uJzogJ1xcdTAxNjAnLFxuICAgICdTY2VkaWwnOiAnXFx1MDE1RScsXG4gICAgJ1NjaXJjJzogJ1xcdTAxNUMnLFxuICAgICdTY3knOiAnXFx1MDQyMScsXG4gICAgJ1Nmcic6ICdcXHVEODM1XFx1REQxNicsXG4gICAgJ1Nob3J0VXBBcnJvdyc6ICdcXHUyMTkxJyxcbiAgICAnVXBBcnJvdyc6ICdcXHUyMTkxJyxcbiAgICAndWFycic6ICdcXHUyMTkxJyxcbiAgICAndXBhcnJvdyc6ICdcXHUyMTkxJyxcbiAgICAnU2lnbWEnOiAnXFx1MDNBMycsXG4gICAgJ1NtYWxsQ2lyY2xlJzogJ1xcdTIyMTgnLFxuICAgICdjb21wZm4nOiAnXFx1MjIxOCcsXG4gICAgJ1NvcGYnOiAnXFx1RDgzNVxcdURENEEnLFxuICAgICdTcXJ0JzogJ1xcdTIyMUEnLFxuICAgICdyYWRpYyc6ICdcXHUyMjFBJyxcbiAgICAnU3F1YXJlJzogJ1xcdTI1QTEnLFxuICAgICdzcXUnOiAnXFx1MjVBMScsXG4gICAgJ3NxdWFyZSc6ICdcXHUyNUExJyxcbiAgICAnU3F1YXJlSW50ZXJzZWN0aW9uJzogJ1xcdTIyOTMnLFxuICAgICdzcWNhcCc6ICdcXHUyMjkzJyxcbiAgICAnU3F1YXJlU3Vic2V0JzogJ1xcdTIyOEYnLFxuICAgICdzcXN1Yic6ICdcXHUyMjhGJyxcbiAgICAnc3FzdWJzZXQnOiAnXFx1MjI4RicsXG4gICAgJ1NxdWFyZVN1YnNldEVxdWFsJzogJ1xcdTIyOTEnLFxuICAgICdzcXN1YmUnOiAnXFx1MjI5MScsXG4gICAgJ3Nxc3Vic2V0ZXEnOiAnXFx1MjI5MScsXG4gICAgJ1NxdWFyZVN1cGVyc2V0JzogJ1xcdTIyOTAnLFxuICAgICdzcXN1cCc6ICdcXHUyMjkwJyxcbiAgICAnc3FzdXBzZXQnOiAnXFx1MjI5MCcsXG4gICAgJ1NxdWFyZVN1cGVyc2V0RXF1YWwnOiAnXFx1MjI5MicsXG4gICAgJ3Nxc3VwZSc6ICdcXHUyMjkyJyxcbiAgICAnc3FzdXBzZXRlcSc6ICdcXHUyMjkyJyxcbiAgICAnU3F1YXJlVW5pb24nOiAnXFx1MjI5NCcsXG4gICAgJ3NxY3VwJzogJ1xcdTIyOTQnLFxuICAgICdTc2NyJzogJ1xcdUQ4MzVcXHVEQ0FFJyxcbiAgICAnU3Rhcic6ICdcXHUyMkM2JyxcbiAgICAnc3N0YXJmJzogJ1xcdTIyQzYnLFxuICAgICdTdWInOiAnXFx1MjJEMCcsXG4gICAgJ1N1YnNldCc6ICdcXHUyMkQwJyxcbiAgICAnU3Vic2V0RXF1YWwnOiAnXFx1MjI4NicsXG4gICAgJ3N1YmUnOiAnXFx1MjI4NicsXG4gICAgJ3N1YnNldGVxJzogJ1xcdTIyODYnLFxuICAgICdTdWNjZWVkcyc6ICdcXHUyMjdCJyxcbiAgICAnc2MnOiAnXFx1MjI3QicsXG4gICAgJ3N1Y2MnOiAnXFx1MjI3QicsXG4gICAgJ1N1Y2NlZWRzRXF1YWwnOiAnXFx1MkFCMCcsXG4gICAgJ3NjZSc6ICdcXHUyQUIwJyxcbiAgICAnc3VjY2VxJzogJ1xcdTJBQjAnLFxuICAgICdTdWNjZWVkc1NsYW50RXF1YWwnOiAnXFx1MjI3RCcsXG4gICAgJ3NjY3VlJzogJ1xcdTIyN0QnLFxuICAgICdzdWNjY3VybHllcSc6ICdcXHUyMjdEJyxcbiAgICAnU3VjY2VlZHNUaWxkZSc6ICdcXHUyMjdGJyxcbiAgICAnc2NzaW0nOiAnXFx1MjI3RicsXG4gICAgJ3N1Y2NzaW0nOiAnXFx1MjI3RicsXG4gICAgJ1N1bSc6ICdcXHUyMjExJyxcbiAgICAnc3VtJzogJ1xcdTIyMTEnLFxuICAgICdTdXAnOiAnXFx1MjJEMScsXG4gICAgJ1N1cHNldCc6ICdcXHUyMkQxJyxcbiAgICAnU3VwZXJzZXQnOiAnXFx1MjI4MycsXG4gICAgJ3N1cCc6ICdcXHUyMjgzJyxcbiAgICAnc3Vwc2V0JzogJ1xcdTIyODMnLFxuICAgICdTdXBlcnNldEVxdWFsJzogJ1xcdTIyODcnLFxuICAgICdzdXBlJzogJ1xcdTIyODcnLFxuICAgICdzdXBzZXRlcSc6ICdcXHUyMjg3JyxcbiAgICAnVEhPUk4nOiAnXFx1MDBERScsXG4gICAgJ1RSQURFJzogJ1xcdTIxMjInLFxuICAgICd0cmFkZSc6ICdcXHUyMTIyJyxcbiAgICAnVFNIY3knOiAnXFx1MDQwQicsXG4gICAgJ1RTY3knOiAnXFx1MDQyNicsXG4gICAgJ1RhYic6ICdcXHUwMDA5JyxcbiAgICAnVGF1JzogJ1xcdTAzQTQnLFxuICAgICdUY2Fyb24nOiAnXFx1MDE2NCcsXG4gICAgJ1RjZWRpbCc6ICdcXHUwMTYyJyxcbiAgICAnVGN5JzogJ1xcdTA0MjInLFxuICAgICdUZnInOiAnXFx1RDgzNVxcdUREMTcnLFxuICAgICdUaGVyZWZvcmUnOiAnXFx1MjIzNCcsXG4gICAgJ3RoZXJlNCc6ICdcXHUyMjM0JyxcbiAgICAndGhlcmVmb3JlJzogJ1xcdTIyMzQnLFxuICAgICdUaGV0YSc6ICdcXHUwMzk4JyxcbiAgICAnVGhpY2tTcGFjZSc6ICdcXHUyMDVGXFx1MjAwQScsXG4gICAgJ1RoaW5TcGFjZSc6ICdcXHUyMDA5JyxcbiAgICAndGhpbnNwJzogJ1xcdTIwMDknLFxuICAgICdUaWxkZSc6ICdcXHUyMjNDJyxcbiAgICAnc2ltJzogJ1xcdTIyM0MnLFxuICAgICd0aGlja3NpbSc6ICdcXHUyMjNDJyxcbiAgICAndGhrc2ltJzogJ1xcdTIyM0MnLFxuICAgICdUaWxkZUVxdWFsJzogJ1xcdTIyNDMnLFxuICAgICdzaW1lJzogJ1xcdTIyNDMnLFxuICAgICdzaW1lcSc6ICdcXHUyMjQzJyxcbiAgICAnVGlsZGVGdWxsRXF1YWwnOiAnXFx1MjI0NScsXG4gICAgJ2NvbmcnOiAnXFx1MjI0NScsXG4gICAgJ1RpbGRlVGlsZGUnOiAnXFx1MjI0OCcsXG4gICAgJ2FwJzogJ1xcdTIyNDgnLFxuICAgICdhcHByb3gnOiAnXFx1MjI0OCcsXG4gICAgJ2FzeW1wJzogJ1xcdTIyNDgnLFxuICAgICd0aGlja2FwcHJveCc6ICdcXHUyMjQ4JyxcbiAgICAndGhrYXAnOiAnXFx1MjI0OCcsXG4gICAgJ1RvcGYnOiAnXFx1RDgzNVxcdURENEInLFxuICAgICdUcmlwbGVEb3QnOiAnXFx1MjBEQicsXG4gICAgJ3Rkb3QnOiAnXFx1MjBEQicsXG4gICAgJ1RzY3InOiAnXFx1RDgzNVxcdURDQUYnLFxuICAgICdUc3Ryb2snOiAnXFx1MDE2NicsXG4gICAgJ1VhY3V0ZSc6ICdcXHUwMERBJyxcbiAgICAnVWFycic6ICdcXHUyMTlGJyxcbiAgICAnVWFycm9jaXInOiAnXFx1Mjk0OScsXG4gICAgJ1VicmN5JzogJ1xcdTA0MEUnLFxuICAgICdVYnJldmUnOiAnXFx1MDE2QycsXG4gICAgJ1VjaXJjJzogJ1xcdTAwREInLFxuICAgICdVY3knOiAnXFx1MDQyMycsXG4gICAgJ1VkYmxhYyc6ICdcXHUwMTcwJyxcbiAgICAnVWZyJzogJ1xcdUQ4MzVcXHVERDE4JyxcbiAgICAnVWdyYXZlJzogJ1xcdTAwRDknLFxuICAgICdVbWFjcic6ICdcXHUwMTZBJyxcbiAgICAnVW5kZXJCYXInOiAnXFx1MDA1RicsXG4gICAgJ2xvd2Jhcic6ICdcXHUwMDVGJyxcbiAgICAnVW5kZXJCcmFjZSc6ICdcXHUyM0RGJyxcbiAgICAnVW5kZXJCcmFja2V0JzogJ1xcdTIzQjUnLFxuICAgICdiYnJrJzogJ1xcdTIzQjUnLFxuICAgICdVbmRlclBhcmVudGhlc2lzJzogJ1xcdTIzREQnLFxuICAgICdVbmlvbic6ICdcXHUyMkMzJyxcbiAgICAnYmlnY3VwJzogJ1xcdTIyQzMnLFxuICAgICd4Y3VwJzogJ1xcdTIyQzMnLFxuICAgICdVbmlvblBsdXMnOiAnXFx1MjI4RScsXG4gICAgJ3VwbHVzJzogJ1xcdTIyOEUnLFxuICAgICdVb2dvbic6ICdcXHUwMTcyJyxcbiAgICAnVW9wZic6ICdcXHVEODM1XFx1REQ0QycsXG4gICAgJ1VwQXJyb3dCYXInOiAnXFx1MjkxMicsXG4gICAgJ1VwQXJyb3dEb3duQXJyb3cnOiAnXFx1MjFDNScsXG4gICAgJ3VkYXJyJzogJ1xcdTIxQzUnLFxuICAgICdVcERvd25BcnJvdyc6ICdcXHUyMTk1JyxcbiAgICAndXBkb3duYXJyb3cnOiAnXFx1MjE5NScsXG4gICAgJ3ZhcnInOiAnXFx1MjE5NScsXG4gICAgJ1VwRXF1aWxpYnJpdW0nOiAnXFx1Mjk2RScsXG4gICAgJ3VkaGFyJzogJ1xcdTI5NkUnLFxuICAgICdVcFRlZSc6ICdcXHUyMkE1JyxcbiAgICAnYm90JzogJ1xcdTIyQTUnLFxuICAgICdib3R0b20nOiAnXFx1MjJBNScsXG4gICAgJ3BlcnAnOiAnXFx1MjJBNScsXG4gICAgJ1VwVGVlQXJyb3cnOiAnXFx1MjFBNScsXG4gICAgJ21hcHN0b3VwJzogJ1xcdTIxQTUnLFxuICAgICdVcHBlckxlZnRBcnJvdyc6ICdcXHUyMTk2JyxcbiAgICAnbndhcnInOiAnXFx1MjE5NicsXG4gICAgJ253YXJyb3cnOiAnXFx1MjE5NicsXG4gICAgJ1VwcGVyUmlnaHRBcnJvdyc6ICdcXHUyMTk3JyxcbiAgICAnbmVhcnInOiAnXFx1MjE5NycsXG4gICAgJ25lYXJyb3cnOiAnXFx1MjE5NycsXG4gICAgJ1Vwc2knOiAnXFx1MDNEMicsXG4gICAgJ3Vwc2loJzogJ1xcdTAzRDInLFxuICAgICdVcHNpbG9uJzogJ1xcdTAzQTUnLFxuICAgICdVcmluZyc6ICdcXHUwMTZFJyxcbiAgICAnVXNjcic6ICdcXHVEODM1XFx1RENCMCcsXG4gICAgJ1V0aWxkZSc6ICdcXHUwMTY4JyxcbiAgICAnVXVtbCc6ICdcXHUwMERDJyxcbiAgICAnVkRhc2gnOiAnXFx1MjJBQicsXG4gICAgJ1ZiYXInOiAnXFx1MkFFQicsXG4gICAgJ1ZjeSc6ICdcXHUwNDEyJyxcbiAgICAnVmRhc2gnOiAnXFx1MjJBOScsXG4gICAgJ1ZkYXNobCc6ICdcXHUyQUU2JyxcbiAgICAnVmVlJzogJ1xcdTIyQzEnLFxuICAgICdiaWd2ZWUnOiAnXFx1MjJDMScsXG4gICAgJ3h2ZWUnOiAnXFx1MjJDMScsXG4gICAgJ1ZlcmJhcic6ICdcXHUyMDE2JyxcbiAgICAnVmVydCc6ICdcXHUyMDE2JyxcbiAgICAnVmVydGljYWxCYXInOiAnXFx1MjIyMycsXG4gICAgJ21pZCc6ICdcXHUyMjIzJyxcbiAgICAnc2hvcnRtaWQnOiAnXFx1MjIyMycsXG4gICAgJ3NtaWQnOiAnXFx1MjIyMycsXG4gICAgJ1ZlcnRpY2FsTGluZSc6ICdcXHUwMDdDJyxcbiAgICAndmVyYmFyJzogJ1xcdTAwN0MnLFxuICAgICd2ZXJ0JzogJ1xcdTAwN0MnLFxuICAgICdWZXJ0aWNhbFNlcGFyYXRvcic6ICdcXHUyNzU4JyxcbiAgICAnVmVydGljYWxUaWxkZSc6ICdcXHUyMjQwJyxcbiAgICAnd3InOiAnXFx1MjI0MCcsXG4gICAgJ3dyZWF0aCc6ICdcXHUyMjQwJyxcbiAgICAnVmVyeVRoaW5TcGFjZSc6ICdcXHUyMDBBJyxcbiAgICAnaGFpcnNwJzogJ1xcdTIwMEEnLFxuICAgICdWZnInOiAnXFx1RDgzNVxcdUREMTknLFxuICAgICdWb3BmJzogJ1xcdUQ4MzVcXHVERDREJyxcbiAgICAnVnNjcic6ICdcXHVEODM1XFx1RENCMScsXG4gICAgJ1Z2ZGFzaCc6ICdcXHUyMkFBJyxcbiAgICAnV2NpcmMnOiAnXFx1MDE3NCcsXG4gICAgJ1dlZGdlJzogJ1xcdTIyQzAnLFxuICAgICdiaWd3ZWRnZSc6ICdcXHUyMkMwJyxcbiAgICAneHdlZGdlJzogJ1xcdTIyQzAnLFxuICAgICdXZnInOiAnXFx1RDgzNVxcdUREMUEnLFxuICAgICdXb3BmJzogJ1xcdUQ4MzVcXHVERDRFJyxcbiAgICAnV3Njcic6ICdcXHVEODM1XFx1RENCMicsXG4gICAgJ1hmcic6ICdcXHVEODM1XFx1REQxQicsXG4gICAgJ1hpJzogJ1xcdTAzOUUnLFxuICAgICdYb3BmJzogJ1xcdUQ4MzVcXHVERDRGJyxcbiAgICAnWHNjcic6ICdcXHVEODM1XFx1RENCMycsXG4gICAgJ1lBY3knOiAnXFx1MDQyRicsXG4gICAgJ1lJY3knOiAnXFx1MDQwNycsXG4gICAgJ1lVY3knOiAnXFx1MDQyRScsXG4gICAgJ1lhY3V0ZSc6ICdcXHUwMEREJyxcbiAgICAnWWNpcmMnOiAnXFx1MDE3NicsXG4gICAgJ1ljeSc6ICdcXHUwNDJCJyxcbiAgICAnWWZyJzogJ1xcdUQ4MzVcXHVERDFDJyxcbiAgICAnWW9wZic6ICdcXHVEODM1XFx1REQ1MCcsXG4gICAgJ1lzY3InOiAnXFx1RDgzNVxcdURDQjQnLFxuICAgICdZdW1sJzogJ1xcdTAxNzgnLFxuICAgICdaSGN5JzogJ1xcdTA0MTYnLFxuICAgICdaYWN1dGUnOiAnXFx1MDE3OScsXG4gICAgJ1pjYXJvbic6ICdcXHUwMTdEJyxcbiAgICAnWmN5JzogJ1xcdTA0MTcnLFxuICAgICdaZG90JzogJ1xcdTAxN0InLFxuICAgICdaZXRhJzogJ1xcdTAzOTYnLFxuICAgICdaZnInOiAnXFx1MjEyOCcsXG4gICAgJ3plZXRyZic6ICdcXHUyMTI4JyxcbiAgICAnWm9wZic6ICdcXHUyMTI0JyxcbiAgICAnaW50ZWdlcnMnOiAnXFx1MjEyNCcsXG4gICAgJ1pzY3InOiAnXFx1RDgzNVxcdURDQjUnLFxuICAgICdhYWN1dGUnOiAnXFx1MDBFMScsXG4gICAgJ2FicmV2ZSc6ICdcXHUwMTAzJyxcbiAgICAnYWMnOiAnXFx1MjIzRScsXG4gICAgJ21zdHBvcyc6ICdcXHUyMjNFJyxcbiAgICAnYWNFJzogJ1xcdTIyM0VcXHUwMzMzJyxcbiAgICAnYWNkJzogJ1xcdTIyM0YnLFxuICAgICdhY2lyYyc6ICdcXHUwMEUyJyxcbiAgICAnYWN5JzogJ1xcdTA0MzAnLFxuICAgICdhZWxpZyc6ICdcXHUwMEU2JyxcbiAgICAnYWZyJzogJ1xcdUQ4MzVcXHVERDFFJyxcbiAgICAnYWdyYXZlJzogJ1xcdTAwRTAnLFxuICAgICdhbGVmc3ltJzogJ1xcdTIxMzUnLFxuICAgICdhbGVwaCc6ICdcXHUyMTM1JyxcbiAgICAnYWxwaGEnOiAnXFx1MDNCMScsXG4gICAgJ2FtYWNyJzogJ1xcdTAxMDEnLFxuICAgICdhbWFsZyc6ICdcXHUyQTNGJyxcbiAgICAnYW5kJzogJ1xcdTIyMjcnLFxuICAgICd3ZWRnZSc6ICdcXHUyMjI3JyxcbiAgICAnYW5kYW5kJzogJ1xcdTJBNTUnLFxuICAgICdhbmRkJzogJ1xcdTJBNUMnLFxuICAgICdhbmRzbG9wZSc6ICdcXHUyQTU4JyxcbiAgICAnYW5kdic6ICdcXHUyQTVBJyxcbiAgICAnYW5nJzogJ1xcdTIyMjAnLFxuICAgICdhbmdsZSc6ICdcXHUyMjIwJyxcbiAgICAnYW5nZSc6ICdcXHUyOUE0JyxcbiAgICAnYW5nbXNkJzogJ1xcdTIyMjEnLFxuICAgICdtZWFzdXJlZGFuZ2xlJzogJ1xcdTIyMjEnLFxuICAgICdhbmdtc2RhYSc6ICdcXHUyOUE4JyxcbiAgICAnYW5nbXNkYWInOiAnXFx1MjlBOScsXG4gICAgJ2FuZ21zZGFjJzogJ1xcdTI5QUEnLFxuICAgICdhbmdtc2RhZCc6ICdcXHUyOUFCJyxcbiAgICAnYW5nbXNkYWUnOiAnXFx1MjlBQycsXG4gICAgJ2FuZ21zZGFmJzogJ1xcdTI5QUQnLFxuICAgICdhbmdtc2RhZyc6ICdcXHUyOUFFJyxcbiAgICAnYW5nbXNkYWgnOiAnXFx1MjlBRicsXG4gICAgJ2FuZ3J0JzogJ1xcdTIyMUYnLFxuICAgICdhbmdydHZiJzogJ1xcdTIyQkUnLFxuICAgICdhbmdydHZiZCc6ICdcXHUyOTlEJyxcbiAgICAnYW5nc3BoJzogJ1xcdTIyMjInLFxuICAgICdhbmd6YXJyJzogJ1xcdTIzN0MnLFxuICAgICdhb2dvbic6ICdcXHUwMTA1JyxcbiAgICAnYW9wZic6ICdcXHVEODM1XFx1REQ1MicsXG4gICAgJ2FwRSc6ICdcXHUyQTcwJyxcbiAgICAnYXBhY2lyJzogJ1xcdTJBNkYnLFxuICAgICdhcGUnOiAnXFx1MjI0QScsXG4gICAgJ2FwcHJveGVxJzogJ1xcdTIyNEEnLFxuICAgICdhcGlkJzogJ1xcdTIyNEInLFxuICAgICdhcG9zJzogJ1xcdTAwMjcnLFxuICAgICdhcmluZyc6ICdcXHUwMEU1JyxcbiAgICAnYXNjcic6ICdcXHVEODM1XFx1RENCNicsXG4gICAgJ2FzdCc6ICdcXHUwMDJBJyxcbiAgICAnbWlkYXN0JzogJ1xcdTAwMkEnLFxuICAgICdhdGlsZGUnOiAnXFx1MDBFMycsXG4gICAgJ2F1bWwnOiAnXFx1MDBFNCcsXG4gICAgJ2F3aW50JzogJ1xcdTJBMTEnLFxuICAgICdiTm90JzogJ1xcdTJBRUQnLFxuICAgICdiYWNrY29uZyc6ICdcXHUyMjRDJyxcbiAgICAnYmNvbmcnOiAnXFx1MjI0QycsXG4gICAgJ2JhY2tlcHNpbG9uJzogJ1xcdTAzRjYnLFxuICAgICdiZXBzaSc6ICdcXHUwM0Y2JyxcbiAgICAnYmFja3ByaW1lJzogJ1xcdTIwMzUnLFxuICAgICdicHJpbWUnOiAnXFx1MjAzNScsXG4gICAgJ2JhY2tzaW0nOiAnXFx1MjIzRCcsXG4gICAgJ2JzaW0nOiAnXFx1MjIzRCcsXG4gICAgJ2JhY2tzaW1lcSc6ICdcXHUyMkNEJyxcbiAgICAnYnNpbWUnOiAnXFx1MjJDRCcsXG4gICAgJ2JhcnZlZSc6ICdcXHUyMkJEJyxcbiAgICAnYmFyd2VkJzogJ1xcdTIzMDUnLFxuICAgICdiYXJ3ZWRnZSc6ICdcXHUyMzA1JyxcbiAgICAnYmJya3RicmsnOiAnXFx1MjNCNicsXG4gICAgJ2JjeSc6ICdcXHUwNDMxJyxcbiAgICAnYmRxdW8nOiAnXFx1MjAxRScsXG4gICAgJ2xkcXVvcic6ICdcXHUyMDFFJyxcbiAgICAnYmVtcHR5dic6ICdcXHUyOUIwJyxcbiAgICAnYmV0YSc6ICdcXHUwM0IyJyxcbiAgICAnYmV0aCc6ICdcXHUyMTM2JyxcbiAgICAnYmV0d2Vlbic6ICdcXHUyMjZDJyxcbiAgICAndHdpeHQnOiAnXFx1MjI2QycsXG4gICAgJ2Jmcic6ICdcXHVEODM1XFx1REQxRicsXG4gICAgJ2JpZ2NpcmMnOiAnXFx1MjVFRicsXG4gICAgJ3hjaXJjJzogJ1xcdTI1RUYnLFxuICAgICdiaWdvZG90JzogJ1xcdTJBMDAnLFxuICAgICd4b2RvdCc6ICdcXHUyQTAwJyxcbiAgICAnYmlnb3BsdXMnOiAnXFx1MkEwMScsXG4gICAgJ3hvcGx1cyc6ICdcXHUyQTAxJyxcbiAgICAnYmlnb3RpbWVzJzogJ1xcdTJBMDInLFxuICAgICd4b3RpbWUnOiAnXFx1MkEwMicsXG4gICAgJ2JpZ3NxY3VwJzogJ1xcdTJBMDYnLFxuICAgICd4c3FjdXAnOiAnXFx1MkEwNicsXG4gICAgJ2JpZ3N0YXInOiAnXFx1MjYwNScsXG4gICAgJ3N0YXJmJzogJ1xcdTI2MDUnLFxuICAgICdiaWd0cmlhbmdsZWRvd24nOiAnXFx1MjVCRCcsXG4gICAgJ3hkdHJpJzogJ1xcdTI1QkQnLFxuICAgICdiaWd0cmlhbmdsZXVwJzogJ1xcdTI1QjMnLFxuICAgICd4dXRyaSc6ICdcXHUyNUIzJyxcbiAgICAnYmlndXBsdXMnOiAnXFx1MkEwNCcsXG4gICAgJ3h1cGx1cyc6ICdcXHUyQTA0JyxcbiAgICAnYmthcm93JzogJ1xcdTI5MEQnLFxuICAgICdyYmFycic6ICdcXHUyOTBEJyxcbiAgICAnYmxhY2tsb3plbmdlJzogJ1xcdTI5RUInLFxuICAgICdsb3pmJzogJ1xcdTI5RUInLFxuICAgICdibGFja3RyaWFuZ2xlJzogJ1xcdTI1QjQnLFxuICAgICd1dHJpZic6ICdcXHUyNUI0JyxcbiAgICAnYmxhY2t0cmlhbmdsZWRvd24nOiAnXFx1MjVCRScsXG4gICAgJ2R0cmlmJzogJ1xcdTI1QkUnLFxuICAgICdibGFja3RyaWFuZ2xlbGVmdCc6ICdcXHUyNUMyJyxcbiAgICAnbHRyaWYnOiAnXFx1MjVDMicsXG4gICAgJ2JsYWNrdHJpYW5nbGVyaWdodCc6ICdcXHUyNUI4JyxcbiAgICAncnRyaWYnOiAnXFx1MjVCOCcsXG4gICAgJ2JsYW5rJzogJ1xcdTI0MjMnLFxuICAgICdibGsxMic6ICdcXHUyNTkyJyxcbiAgICAnYmxrMTQnOiAnXFx1MjU5MScsXG4gICAgJ2JsazM0JzogJ1xcdTI1OTMnLFxuICAgICdibG9jayc6ICdcXHUyNTg4JyxcbiAgICAnYm5lJzogJ1xcdTAwM0RcXHUyMEU1JyxcbiAgICAnYm5lcXVpdic6ICdcXHUyMjYxXFx1MjBFNScsXG4gICAgJ2Jub3QnOiAnXFx1MjMxMCcsXG4gICAgJ2JvcGYnOiAnXFx1RDgzNVxcdURENTMnLFxuICAgICdib3d0aWUnOiAnXFx1MjJDOCcsXG4gICAgJ2JveERMJzogJ1xcdTI1NTcnLFxuICAgICdib3hEUic6ICdcXHUyNTU0JyxcbiAgICAnYm94RGwnOiAnXFx1MjU1NicsXG4gICAgJ2JveERyJzogJ1xcdTI1NTMnLFxuICAgICdib3hIJzogJ1xcdTI1NTAnLFxuICAgICdib3hIRCc6ICdcXHUyNTY2JyxcbiAgICAnYm94SFUnOiAnXFx1MjU2OScsXG4gICAgJ2JveEhkJzogJ1xcdTI1NjQnLFxuICAgICdib3hIdSc6ICdcXHUyNTY3JyxcbiAgICAnYm94VUwnOiAnXFx1MjU1RCcsXG4gICAgJ2JveFVSJzogJ1xcdTI1NUEnLFxuICAgICdib3hVbCc6ICdcXHUyNTVDJyxcbiAgICAnYm94VXInOiAnXFx1MjU1OScsXG4gICAgJ2JveFYnOiAnXFx1MjU1MScsXG4gICAgJ2JveFZIJzogJ1xcdTI1NkMnLFxuICAgICdib3hWTCc6ICdcXHUyNTYzJyxcbiAgICAnYm94VlInOiAnXFx1MjU2MCcsXG4gICAgJ2JveFZoJzogJ1xcdTI1NkInLFxuICAgICdib3hWbCc6ICdcXHUyNTYyJyxcbiAgICAnYm94VnInOiAnXFx1MjU1RicsXG4gICAgJ2JveGJveCc6ICdcXHUyOUM5JyxcbiAgICAnYm94ZEwnOiAnXFx1MjU1NScsXG4gICAgJ2JveGRSJzogJ1xcdTI1NTInLFxuICAgICdib3hkbCc6ICdcXHUyNTEwJyxcbiAgICAnYm94ZHInOiAnXFx1MjUwQycsXG4gICAgJ2JveGhEJzogJ1xcdTI1NjUnLFxuICAgICdib3hoVSc6ICdcXHUyNTY4JyxcbiAgICAnYm94aGQnOiAnXFx1MjUyQycsXG4gICAgJ2JveGh1JzogJ1xcdTI1MzQnLFxuICAgICdib3htaW51cyc6ICdcXHUyMjlGJyxcbiAgICAnbWludXNiJzogJ1xcdTIyOUYnLFxuICAgICdib3hwbHVzJzogJ1xcdTIyOUUnLFxuICAgICdwbHVzYic6ICdcXHUyMjlFJyxcbiAgICAnYm94dGltZXMnOiAnXFx1MjJBMCcsXG4gICAgJ3RpbWVzYic6ICdcXHUyMkEwJyxcbiAgICAnYm94dUwnOiAnXFx1MjU1QicsXG4gICAgJ2JveHVSJzogJ1xcdTI1NTgnLFxuICAgICdib3h1bCc6ICdcXHUyNTE4JyxcbiAgICAnYm94dXInOiAnXFx1MjUxNCcsXG4gICAgJ2JveHYnOiAnXFx1MjUwMicsXG4gICAgJ2JveHZIJzogJ1xcdTI1NkEnLFxuICAgICdib3h2TCc6ICdcXHUyNTYxJyxcbiAgICAnYm94dlInOiAnXFx1MjU1RScsXG4gICAgJ2JveHZoJzogJ1xcdTI1M0MnLFxuICAgICdib3h2bCc6ICdcXHUyNTI0JyxcbiAgICAnYm94dnInOiAnXFx1MjUxQycsXG4gICAgJ2JydmJhcic6ICdcXHUwMEE2JyxcbiAgICAnYnNjcic6ICdcXHVEODM1XFx1RENCNycsXG4gICAgJ2JzZW1pJzogJ1xcdTIwNEYnLFxuICAgICdic29sJzogJ1xcdTAwNUMnLFxuICAgICdic29sYic6ICdcXHUyOUM1JyxcbiAgICAnYnNvbGhzdWInOiAnXFx1MjdDOCcsXG4gICAgJ2J1bGwnOiAnXFx1MjAyMicsXG4gICAgJ2J1bGxldCc6ICdcXHUyMDIyJyxcbiAgICAnYnVtcEUnOiAnXFx1MkFBRScsXG4gICAgJ2NhY3V0ZSc6ICdcXHUwMTA3JyxcbiAgICAnY2FwJzogJ1xcdTIyMjknLFxuICAgICdjYXBhbmQnOiAnXFx1MkE0NCcsXG4gICAgJ2NhcGJyY3VwJzogJ1xcdTJBNDknLFxuICAgICdjYXBjYXAnOiAnXFx1MkE0QicsXG4gICAgJ2NhcGN1cCc6ICdcXHUyQTQ3JyxcbiAgICAnY2FwZG90JzogJ1xcdTJBNDAnLFxuICAgICdjYXBzJzogJ1xcdTIyMjlcXHVGRTAwJyxcbiAgICAnY2FyZXQnOiAnXFx1MjA0MScsXG4gICAgJ2NjYXBzJzogJ1xcdTJBNEQnLFxuICAgICdjY2Fyb24nOiAnXFx1MDEwRCcsXG4gICAgJ2NjZWRpbCc6ICdcXHUwMEU3JyxcbiAgICAnY2NpcmMnOiAnXFx1MDEwOScsXG4gICAgJ2NjdXBzJzogJ1xcdTJBNEMnLFxuICAgICdjY3Vwc3NtJzogJ1xcdTJBNTAnLFxuICAgICdjZG90JzogJ1xcdTAxMEInLFxuICAgICdjZW1wdHl2JzogJ1xcdTI5QjInLFxuICAgICdjZW50JzogJ1xcdTAwQTInLFxuICAgICdjZnInOiAnXFx1RDgzNVxcdUREMjAnLFxuICAgICdjaGN5JzogJ1xcdTA0NDcnLFxuICAgICdjaGVjayc6ICdcXHUyNzEzJyxcbiAgICAnY2hlY2ttYXJrJzogJ1xcdTI3MTMnLFxuICAgICdjaGknOiAnXFx1MDNDNycsXG4gICAgJ2Npcic6ICdcXHUyNUNCJyxcbiAgICAnY2lyRSc6ICdcXHUyOUMzJyxcbiAgICAnY2lyYyc6ICdcXHUwMkM2JyxcbiAgICAnY2lyY2VxJzogJ1xcdTIyNTcnLFxuICAgICdjaXJlJzogJ1xcdTIyNTcnLFxuICAgICdjaXJjbGVhcnJvd2xlZnQnOiAnXFx1MjFCQScsXG4gICAgJ29sYXJyJzogJ1xcdTIxQkEnLFxuICAgICdjaXJjbGVhcnJvd3JpZ2h0JzogJ1xcdTIxQkInLFxuICAgICdvcmFycic6ICdcXHUyMUJCJyxcbiAgICAnY2lyY2xlZFMnOiAnXFx1MjRDOCcsXG4gICAgJ29TJzogJ1xcdTI0QzgnLFxuICAgICdjaXJjbGVkYXN0JzogJ1xcdTIyOUInLFxuICAgICdvYXN0JzogJ1xcdTIyOUInLFxuICAgICdjaXJjbGVkY2lyYyc6ICdcXHUyMjlBJyxcbiAgICAnb2Npcic6ICdcXHUyMjlBJyxcbiAgICAnY2lyY2xlZGRhc2gnOiAnXFx1MjI5RCcsXG4gICAgJ29kYXNoJzogJ1xcdTIyOUQnLFxuICAgICdjaXJmbmludCc6ICdcXHUyQTEwJyxcbiAgICAnY2lybWlkJzogJ1xcdTJBRUYnLFxuICAgICdjaXJzY2lyJzogJ1xcdTI5QzInLFxuICAgICdjbHVicyc6ICdcXHUyNjYzJyxcbiAgICAnY2x1YnN1aXQnOiAnXFx1MjY2MycsXG4gICAgJ2NvbG9uJzogJ1xcdTAwM0EnLFxuICAgICdjb21tYSc6ICdcXHUwMDJDJyxcbiAgICAnY29tbWF0JzogJ1xcdTAwNDAnLFxuICAgICdjb21wJzogJ1xcdTIyMDEnLFxuICAgICdjb21wbGVtZW50JzogJ1xcdTIyMDEnLFxuICAgICdjb25nZG90JzogJ1xcdTJBNkQnLFxuICAgICdjb3BmJzogJ1xcdUQ4MzVcXHVERDU0JyxcbiAgICAnY29weXNyJzogJ1xcdTIxMTcnLFxuICAgICdjcmFycic6ICdcXHUyMUI1JyxcbiAgICAnY3Jvc3MnOiAnXFx1MjcxNycsXG4gICAgJ2NzY3InOiAnXFx1RDgzNVxcdURDQjgnLFxuICAgICdjc3ViJzogJ1xcdTJBQ0YnLFxuICAgICdjc3ViZSc6ICdcXHUyQUQxJyxcbiAgICAnY3N1cCc6ICdcXHUyQUQwJyxcbiAgICAnY3N1cGUnOiAnXFx1MkFEMicsXG4gICAgJ2N0ZG90JzogJ1xcdTIyRUYnLFxuICAgICdjdWRhcnJsJzogJ1xcdTI5MzgnLFxuICAgICdjdWRhcnJyJzogJ1xcdTI5MzUnLFxuICAgICdjdWVwcic6ICdcXHUyMkRFJyxcbiAgICAnY3VybHllcXByZWMnOiAnXFx1MjJERScsXG4gICAgJ2N1ZXNjJzogJ1xcdTIyREYnLFxuICAgICdjdXJseWVxc3VjYyc6ICdcXHUyMkRGJyxcbiAgICAnY3VsYXJyJzogJ1xcdTIxQjYnLFxuICAgICdjdXJ2ZWFycm93bGVmdCc6ICdcXHUyMUI2JyxcbiAgICAnY3VsYXJycCc6ICdcXHUyOTNEJyxcbiAgICAnY3VwJzogJ1xcdTIyMkEnLFxuICAgICdjdXBicmNhcCc6ICdcXHUyQTQ4JyxcbiAgICAnY3VwY2FwJzogJ1xcdTJBNDYnLFxuICAgICdjdXBjdXAnOiAnXFx1MkE0QScsXG4gICAgJ2N1cGRvdCc6ICdcXHUyMjhEJyxcbiAgICAnY3Vwb3InOiAnXFx1MkE0NScsXG4gICAgJ2N1cHMnOiAnXFx1MjIyQVxcdUZFMDAnLFxuICAgICdjdXJhcnInOiAnXFx1MjFCNycsXG4gICAgJ2N1cnZlYXJyb3dyaWdodCc6ICdcXHUyMUI3JyxcbiAgICAnY3VyYXJybSc6ICdcXHUyOTNDJyxcbiAgICAnY3VybHl2ZWUnOiAnXFx1MjJDRScsXG4gICAgJ2N1dmVlJzogJ1xcdTIyQ0UnLFxuICAgICdjdXJseXdlZGdlJzogJ1xcdTIyQ0YnLFxuICAgICdjdXdlZCc6ICdcXHUyMkNGJyxcbiAgICAnY3VycmVuJzogJ1xcdTAwQTQnLFxuICAgICdjd2ludCc6ICdcXHUyMjMxJyxcbiAgICAnY3lsY3R5JzogJ1xcdTIzMkQnLFxuICAgICdkSGFyJzogJ1xcdTI5NjUnLFxuICAgICdkYWdnZXInOiAnXFx1MjAyMCcsXG4gICAgJ2RhbGV0aCc6ICdcXHUyMTM4JyxcbiAgICAnZGFzaCc6ICdcXHUyMDEwJyxcbiAgICAnaHlwaGVuJzogJ1xcdTIwMTAnLFxuICAgICdkYmthcm93JzogJ1xcdTI5MEYnLFxuICAgICdyQmFycic6ICdcXHUyOTBGJyxcbiAgICAnZGNhcm9uJzogJ1xcdTAxMEYnLFxuICAgICdkY3knOiAnXFx1MDQzNCcsXG4gICAgJ2RkYXJyJzogJ1xcdTIxQ0EnLFxuICAgICdkb3duZG93bmFycm93cyc6ICdcXHUyMUNBJyxcbiAgICAnZGRvdHNlcSc6ICdcXHUyQTc3JyxcbiAgICAnZUREb3QnOiAnXFx1MkE3NycsXG4gICAgJ2RlZyc6ICdcXHUwMEIwJyxcbiAgICAnZGVsdGEnOiAnXFx1MDNCNCcsXG4gICAgJ2RlbXB0eXYnOiAnXFx1MjlCMScsXG4gICAgJ2RmaXNodCc6ICdcXHUyOTdGJyxcbiAgICAnZGZyJzogJ1xcdUQ4MzVcXHVERDIxJyxcbiAgICAnZGlhbW9uZHN1aXQnOiAnXFx1MjY2NicsXG4gICAgJ2RpYW1zJzogJ1xcdTI2NjYnLFxuICAgICdkaWdhbW1hJzogJ1xcdTAzREQnLFxuICAgICdnYW1tYWQnOiAnXFx1MDNERCcsXG4gICAgJ2Rpc2luJzogJ1xcdTIyRjInLFxuICAgICdkaXYnOiAnXFx1MDBGNycsXG4gICAgJ2RpdmlkZSc6ICdcXHUwMEY3JyxcbiAgICAnZGl2aWRlb250aW1lcyc6ICdcXHUyMkM3JyxcbiAgICAnZGl2b254JzogJ1xcdTIyQzcnLFxuICAgICdkamN5JzogJ1xcdTA0NTInLFxuICAgICdkbGNvcm4nOiAnXFx1MjMxRScsXG4gICAgJ2xsY29ybmVyJzogJ1xcdTIzMUUnLFxuICAgICdkbGNyb3AnOiAnXFx1MjMwRCcsXG4gICAgJ2RvbGxhcic6ICdcXHUwMDI0JyxcbiAgICAnZG9wZic6ICdcXHVEODM1XFx1REQ1NScsXG4gICAgJ2RvdGVxZG90JzogJ1xcdTIyNTEnLFxuICAgICdlRG90JzogJ1xcdTIyNTEnLFxuICAgICdkb3RtaW51cyc6ICdcXHUyMjM4JyxcbiAgICAnbWludXNkJzogJ1xcdTIyMzgnLFxuICAgICdkb3RwbHVzJzogJ1xcdTIyMTQnLFxuICAgICdwbHVzZG8nOiAnXFx1MjIxNCcsXG4gICAgJ2RvdHNxdWFyZSc6ICdcXHUyMkExJyxcbiAgICAnc2RvdGInOiAnXFx1MjJBMScsXG4gICAgJ2RyY29ybic6ICdcXHUyMzFGJyxcbiAgICAnbHJjb3JuZXInOiAnXFx1MjMxRicsXG4gICAgJ2RyY3JvcCc6ICdcXHUyMzBDJyxcbiAgICAnZHNjcic6ICdcXHVEODM1XFx1RENCOScsXG4gICAgJ2RzY3knOiAnXFx1MDQ1NScsXG4gICAgJ2Rzb2wnOiAnXFx1MjlGNicsXG4gICAgJ2RzdHJvayc6ICdcXHUwMTExJyxcbiAgICAnZHRkb3QnOiAnXFx1MjJGMScsXG4gICAgJ2R0cmknOiAnXFx1MjVCRicsXG4gICAgJ3RyaWFuZ2xlZG93bic6ICdcXHUyNUJGJyxcbiAgICAnZHdhbmdsZSc6ICdcXHUyOUE2JyxcbiAgICAnZHpjeSc6ICdcXHUwNDVGJyxcbiAgICAnZHppZ3JhcnInOiAnXFx1MjdGRicsXG4gICAgJ2VhY3V0ZSc6ICdcXHUwMEU5JyxcbiAgICAnZWFzdGVyJzogJ1xcdTJBNkUnLFxuICAgICdlY2Fyb24nOiAnXFx1MDExQicsXG4gICAgJ2VjaXInOiAnXFx1MjI1NicsXG4gICAgJ2VxY2lyYyc6ICdcXHUyMjU2JyxcbiAgICAnZWNpcmMnOiAnXFx1MDBFQScsXG4gICAgJ2Vjb2xvbic6ICdcXHUyMjU1JyxcbiAgICAnZXFjb2xvbic6ICdcXHUyMjU1JyxcbiAgICAnZWN5JzogJ1xcdTA0NEQnLFxuICAgICdlZG90JzogJ1xcdTAxMTcnLFxuICAgICdlZkRvdCc6ICdcXHUyMjUyJyxcbiAgICAnZmFsbGluZ2RvdHNlcSc6ICdcXHUyMjUyJyxcbiAgICAnZWZyJzogJ1xcdUQ4MzVcXHVERDIyJyxcbiAgICAnZWcnOiAnXFx1MkE5QScsXG4gICAgJ2VncmF2ZSc6ICdcXHUwMEU4JyxcbiAgICAnZWdzJzogJ1xcdTJBOTYnLFxuICAgICdlcXNsYW50Z3RyJzogJ1xcdTJBOTYnLFxuICAgICdlZ3Nkb3QnOiAnXFx1MkE5OCcsXG4gICAgJ2VsJzogJ1xcdTJBOTknLFxuICAgICdlbGludGVycyc6ICdcXHUyM0U3JyxcbiAgICAnZWxsJzogJ1xcdTIxMTMnLFxuICAgICdlbHMnOiAnXFx1MkE5NScsXG4gICAgJ2Vxc2xhbnRsZXNzJzogJ1xcdTJBOTUnLFxuICAgICdlbHNkb3QnOiAnXFx1MkE5NycsXG4gICAgJ2VtYWNyJzogJ1xcdTAxMTMnLFxuICAgICdlbXB0eSc6ICdcXHUyMjA1JyxcbiAgICAnZW1wdHlzZXQnOiAnXFx1MjIwNScsXG4gICAgJ2VtcHR5dic6ICdcXHUyMjA1JyxcbiAgICAndmFybm90aGluZyc6ICdcXHUyMjA1JyxcbiAgICAnZW1zcDEzJzogJ1xcdTIwMDQnLFxuICAgICdlbXNwMTQnOiAnXFx1MjAwNScsXG4gICAgJ2Vtc3AnOiAnXFx1MjAwMycsXG4gICAgJ2VuZyc6ICdcXHUwMTRCJyxcbiAgICAnZW5zcCc6ICdcXHUyMDAyJyxcbiAgICAnZW9nb24nOiAnXFx1MDExOScsXG4gICAgJ2VvcGYnOiAnXFx1RDgzNVxcdURENTYnLFxuICAgICdlcGFyJzogJ1xcdTIyRDUnLFxuICAgICdlcGFyc2wnOiAnXFx1MjlFMycsXG4gICAgJ2VwbHVzJzogJ1xcdTJBNzEnLFxuICAgICdlcHNpJzogJ1xcdTAzQjUnLFxuICAgICdlcHNpbG9uJzogJ1xcdTAzQjUnLFxuICAgICdlcHNpdic6ICdcXHUwM0Y1JyxcbiAgICAnc3RyYWlnaHRlcHNpbG9uJzogJ1xcdTAzRjUnLFxuICAgICd2YXJlcHNpbG9uJzogJ1xcdTAzRjUnLFxuICAgICdlcXVhbHMnOiAnXFx1MDAzRCcsXG4gICAgJ2VxdWVzdCc6ICdcXHUyMjVGJyxcbiAgICAncXVlc3RlcSc6ICdcXHUyMjVGJyxcbiAgICAnZXF1aXZERCc6ICdcXHUyQTc4JyxcbiAgICAnZXF2cGFyc2wnOiAnXFx1MjlFNScsXG4gICAgJ2VyRG90JzogJ1xcdTIyNTMnLFxuICAgICdyaXNpbmdkb3RzZXEnOiAnXFx1MjI1MycsXG4gICAgJ2VyYXJyJzogJ1xcdTI5NzEnLFxuICAgICdlc2NyJzogJ1xcdTIxMkYnLFxuICAgICdldGEnOiAnXFx1MDNCNycsXG4gICAgJ2V0aCc6ICdcXHUwMEYwJyxcbiAgICAnZXVtbCc6ICdcXHUwMEVCJyxcbiAgICAnZXVybyc6ICdcXHUyMEFDJyxcbiAgICAnZXhjbCc6ICdcXHUwMDIxJyxcbiAgICAnZmN5JzogJ1xcdTA0NDQnLFxuICAgICdmZW1hbGUnOiAnXFx1MjY0MCcsXG4gICAgJ2ZmaWxpZyc6ICdcXHVGQjAzJyxcbiAgICAnZmZsaWcnOiAnXFx1RkIwMCcsXG4gICAgJ2ZmbGxpZyc6ICdcXHVGQjA0JyxcbiAgICAnZmZyJzogJ1xcdUQ4MzVcXHVERDIzJyxcbiAgICAnZmlsaWcnOiAnXFx1RkIwMScsXG4gICAgJ2ZqbGlnJzogJ1xcdTAwNjZcXHUwMDZBJyxcbiAgICAnZmxhdCc6ICdcXHUyNjZEJyxcbiAgICAnZmxsaWcnOiAnXFx1RkIwMicsXG4gICAgJ2ZsdG5zJzogJ1xcdTI1QjEnLFxuICAgICdmbm9mJzogJ1xcdTAxOTInLFxuICAgICdmb3BmJzogJ1xcdUQ4MzVcXHVERDU3JyxcbiAgICAnZm9yayc6ICdcXHUyMkQ0JyxcbiAgICAncGl0Y2hmb3JrJzogJ1xcdTIyRDQnLFxuICAgICdmb3Jrdic6ICdcXHUyQUQ5JyxcbiAgICAnZnBhcnRpbnQnOiAnXFx1MkEwRCcsXG4gICAgJ2ZyYWMxMic6ICdcXHUwMEJEJyxcbiAgICAnaGFsZic6ICdcXHUwMEJEJyxcbiAgICAnZnJhYzEzJzogJ1xcdTIxNTMnLFxuICAgICdmcmFjMTQnOiAnXFx1MDBCQycsXG4gICAgJ2ZyYWMxNSc6ICdcXHUyMTU1JyxcbiAgICAnZnJhYzE2JzogJ1xcdTIxNTknLFxuICAgICdmcmFjMTgnOiAnXFx1MjE1QicsXG4gICAgJ2ZyYWMyMyc6ICdcXHUyMTU0JyxcbiAgICAnZnJhYzI1JzogJ1xcdTIxNTYnLFxuICAgICdmcmFjMzQnOiAnXFx1MDBCRScsXG4gICAgJ2ZyYWMzNSc6ICdcXHUyMTU3JyxcbiAgICAnZnJhYzM4JzogJ1xcdTIxNUMnLFxuICAgICdmcmFjNDUnOiAnXFx1MjE1OCcsXG4gICAgJ2ZyYWM1Nic6ICdcXHUyMTVBJyxcbiAgICAnZnJhYzU4JzogJ1xcdTIxNUQnLFxuICAgICdmcmFjNzgnOiAnXFx1MjE1RScsXG4gICAgJ2ZyYXNsJzogJ1xcdTIwNDQnLFxuICAgICdmcm93bic6ICdcXHUyMzIyJyxcbiAgICAnc2Zyb3duJzogJ1xcdTIzMjInLFxuICAgICdmc2NyJzogJ1xcdUQ4MzVcXHVEQ0JCJyxcbiAgICAnZ0VsJzogJ1xcdTJBOEMnLFxuICAgICdndHJlcXFsZXNzJzogJ1xcdTJBOEMnLFxuICAgICdnYWN1dGUnOiAnXFx1MDFGNScsXG4gICAgJ2dhbW1hJzogJ1xcdTAzQjMnLFxuICAgICdnYXAnOiAnXFx1MkE4NicsXG4gICAgJ2d0cmFwcHJveCc6ICdcXHUyQTg2JyxcbiAgICAnZ2JyZXZlJzogJ1xcdTAxMUYnLFxuICAgICdnY2lyYyc6ICdcXHUwMTFEJyxcbiAgICAnZ2N5JzogJ1xcdTA0MzMnLFxuICAgICdnZG90JzogJ1xcdTAxMjEnLFxuICAgICdnZXNjYyc6ICdcXHUyQUE5JyxcbiAgICAnZ2VzZG90JzogJ1xcdTJBODAnLFxuICAgICdnZXNkb3RvJzogJ1xcdTJBODInLFxuICAgICdnZXNkb3RvbCc6ICdcXHUyQTg0JyxcbiAgICAnZ2VzbCc6ICdcXHUyMkRCXFx1RkUwMCcsXG4gICAgJ2dlc2xlcyc6ICdcXHUyQTk0JyxcbiAgICAnZ2ZyJzogJ1xcdUQ4MzVcXHVERDI0JyxcbiAgICAnZ2ltZWwnOiAnXFx1MjEzNycsXG4gICAgJ2dqY3knOiAnXFx1MDQ1MycsXG4gICAgJ2dsRSc6ICdcXHUyQTkyJyxcbiAgICAnZ2xhJzogJ1xcdTJBQTUnLFxuICAgICdnbGonOiAnXFx1MkFBNCcsXG4gICAgJ2duRSc6ICdcXHUyMjY5JyxcbiAgICAnZ25lcXEnOiAnXFx1MjI2OScsXG4gICAgJ2duYXAnOiAnXFx1MkE4QScsXG4gICAgJ2duYXBwcm94JzogJ1xcdTJBOEEnLFxuICAgICdnbmUnOiAnXFx1MkE4OCcsXG4gICAgJ2duZXEnOiAnXFx1MkE4OCcsXG4gICAgJ2duc2ltJzogJ1xcdTIyRTcnLFxuICAgICdnb3BmJzogJ1xcdUQ4MzVcXHVERDU4JyxcbiAgICAnZ3Njcic6ICdcXHUyMTBBJyxcbiAgICAnZ3NpbWUnOiAnXFx1MkE4RScsXG4gICAgJ2dzaW1sJzogJ1xcdTJBOTAnLFxuICAgICdndGNjJzogJ1xcdTJBQTcnLFxuICAgICdndGNpcic6ICdcXHUyQTdBJyxcbiAgICAnZ3Rkb3QnOiAnXFx1MjJENycsXG4gICAgJ2d0cmRvdCc6ICdcXHUyMkQ3JyxcbiAgICAnZ3RsUGFyJzogJ1xcdTI5OTUnLFxuICAgICdndHF1ZXN0JzogJ1xcdTJBN0MnLFxuICAgICdndHJhcnInOiAnXFx1Mjk3OCcsXG4gICAgJ2d2ZXJ0bmVxcSc6ICdcXHUyMjY5XFx1RkUwMCcsXG4gICAgJ2d2bkUnOiAnXFx1MjI2OVxcdUZFMDAnLFxuICAgICdoYXJkY3knOiAnXFx1MDQ0QScsXG4gICAgJ2hhcnJjaXInOiAnXFx1Mjk0OCcsXG4gICAgJ2hhcnJ3JzogJ1xcdTIxQUQnLFxuICAgICdsZWZ0cmlnaHRzcXVpZ2Fycm93JzogJ1xcdTIxQUQnLFxuICAgICdoYmFyJzogJ1xcdTIxMEYnLFxuICAgICdoc2xhc2gnOiAnXFx1MjEwRicsXG4gICAgJ3BsYW5jayc6ICdcXHUyMTBGJyxcbiAgICAncGxhbmt2JzogJ1xcdTIxMEYnLFxuICAgICdoY2lyYyc6ICdcXHUwMTI1JyxcbiAgICAnaGVhcnRzJzogJ1xcdTI2NjUnLFxuICAgICdoZWFydHN1aXQnOiAnXFx1MjY2NScsXG4gICAgJ2hlbGxpcCc6ICdcXHUyMDI2JyxcbiAgICAnbWxkcic6ICdcXHUyMDI2JyxcbiAgICAnaGVyY29uJzogJ1xcdTIyQjknLFxuICAgICdoZnInOiAnXFx1RDgzNVxcdUREMjUnLFxuICAgICdoa3NlYXJvdyc6ICdcXHUyOTI1JyxcbiAgICAnc2VhcmhrJzogJ1xcdTI5MjUnLFxuICAgICdoa3N3YXJvdyc6ICdcXHUyOTI2JyxcbiAgICAnc3dhcmhrJzogJ1xcdTI5MjYnLFxuICAgICdob2Fycic6ICdcXHUyMUZGJyxcbiAgICAnaG9tdGh0JzogJ1xcdTIyM0InLFxuICAgICdob29rbGVmdGFycm93JzogJ1xcdTIxQTknLFxuICAgICdsYXJyaGsnOiAnXFx1MjFBOScsXG4gICAgJ2hvb2tyaWdodGFycm93JzogJ1xcdTIxQUEnLFxuICAgICdyYXJyaGsnOiAnXFx1MjFBQScsXG4gICAgJ2hvcGYnOiAnXFx1RDgzNVxcdURENTknLFxuICAgICdob3JiYXInOiAnXFx1MjAxNScsXG4gICAgJ2hzY3InOiAnXFx1RDgzNVxcdURDQkQnLFxuICAgICdoc3Ryb2snOiAnXFx1MDEyNycsXG4gICAgJ2h5YnVsbCc6ICdcXHUyMDQzJyxcbiAgICAnaWFjdXRlJzogJ1xcdTAwRUQnLFxuICAgICdpY2lyYyc6ICdcXHUwMEVFJyxcbiAgICAnaWN5JzogJ1xcdTA0MzgnLFxuICAgICdpZWN5JzogJ1xcdTA0MzUnLFxuICAgICdpZXhjbCc6ICdcXHUwMEExJyxcbiAgICAnaWZyJzogJ1xcdUQ4MzVcXHVERDI2JyxcbiAgICAnaWdyYXZlJzogJ1xcdTAwRUMnLFxuICAgICdpaWlpbnQnOiAnXFx1MkEwQycsXG4gICAgJ3FpbnQnOiAnXFx1MkEwQycsXG4gICAgJ2lpaW50JzogJ1xcdTIyMkQnLFxuICAgICd0aW50JzogJ1xcdTIyMkQnLFxuICAgICdpaW5maW4nOiAnXFx1MjlEQycsXG4gICAgJ2lpb3RhJzogJ1xcdTIxMjknLFxuICAgICdpamxpZyc6ICdcXHUwMTMzJyxcbiAgICAnaW1hY3InOiAnXFx1MDEyQicsXG4gICAgJ2ltYXRoJzogJ1xcdTAxMzEnLFxuICAgICdpbm9kb3QnOiAnXFx1MDEzMScsXG4gICAgJ2ltb2YnOiAnXFx1MjJCNycsXG4gICAgJ2ltcGVkJzogJ1xcdTAxQjUnLFxuICAgICdpbmNhcmUnOiAnXFx1MjEwNScsXG4gICAgJ2luZmluJzogJ1xcdTIyMUUnLFxuICAgICdpbmZpbnRpZSc6ICdcXHUyOUREJyxcbiAgICAnaW50Y2FsJzogJ1xcdTIyQkEnLFxuICAgICdpbnRlcmNhbCc6ICdcXHUyMkJBJyxcbiAgICAnaW50bGFyaGsnOiAnXFx1MkExNycsXG4gICAgJ2ludHByb2QnOiAnXFx1MkEzQycsXG4gICAgJ2lwcm9kJzogJ1xcdTJBM0MnLFxuICAgICdpb2N5JzogJ1xcdTA0NTEnLFxuICAgICdpb2dvbic6ICdcXHUwMTJGJyxcbiAgICAnaW9wZic6ICdcXHVEODM1XFx1REQ1QScsXG4gICAgJ2lvdGEnOiAnXFx1MDNCOScsXG4gICAgJ2lxdWVzdCc6ICdcXHUwMEJGJyxcbiAgICAnaXNjcic6ICdcXHVEODM1XFx1RENCRScsXG4gICAgJ2lzaW5FJzogJ1xcdTIyRjknLFxuICAgICdpc2luZG90JzogJ1xcdTIyRjUnLFxuICAgICdpc2lucyc6ICdcXHUyMkY0JyxcbiAgICAnaXNpbnN2JzogJ1xcdTIyRjMnLFxuICAgICdpdGlsZGUnOiAnXFx1MDEyOScsXG4gICAgJ2l1a2N5JzogJ1xcdTA0NTYnLFxuICAgICdpdW1sJzogJ1xcdTAwRUYnLFxuICAgICdqY2lyYyc6ICdcXHUwMTM1JyxcbiAgICAnamN5JzogJ1xcdTA0MzknLFxuICAgICdqZnInOiAnXFx1RDgzNVxcdUREMjcnLFxuICAgICdqbWF0aCc6ICdcXHUwMjM3JyxcbiAgICAnam9wZic6ICdcXHVEODM1XFx1REQ1QicsXG4gICAgJ2pzY3InOiAnXFx1RDgzNVxcdURDQkYnLFxuICAgICdqc2VyY3knOiAnXFx1MDQ1OCcsXG4gICAgJ2p1a2N5JzogJ1xcdTA0NTQnLFxuICAgICdrYXBwYSc6ICdcXHUwM0JBJyxcbiAgICAna2FwcGF2JzogJ1xcdTAzRjAnLFxuICAgICd2YXJrYXBwYSc6ICdcXHUwM0YwJyxcbiAgICAna2NlZGlsJzogJ1xcdTAxMzcnLFxuICAgICdrY3knOiAnXFx1MDQzQScsXG4gICAgJ2tmcic6ICdcXHVEODM1XFx1REQyOCcsXG4gICAgJ2tncmVlbic6ICdcXHUwMTM4JyxcbiAgICAna2hjeSc6ICdcXHUwNDQ1JyxcbiAgICAna2pjeSc6ICdcXHUwNDVDJyxcbiAgICAna29wZic6ICdcXHVEODM1XFx1REQ1QycsXG4gICAgJ2tzY3InOiAnXFx1RDgzNVxcdURDQzAnLFxuICAgICdsQXRhaWwnOiAnXFx1MjkxQicsXG4gICAgJ2xCYXJyJzogJ1xcdTI5MEUnLFxuICAgICdsRWcnOiAnXFx1MkE4QicsXG4gICAgJ2xlc3NlcXFndHInOiAnXFx1MkE4QicsXG4gICAgJ2xIYXInOiAnXFx1Mjk2MicsXG4gICAgJ2xhY3V0ZSc6ICdcXHUwMTNBJyxcbiAgICAnbGFlbXB0eXYnOiAnXFx1MjlCNCcsXG4gICAgJ2xhbWJkYSc6ICdcXHUwM0JCJyxcbiAgICAnbGFuZ2QnOiAnXFx1Mjk5MScsXG4gICAgJ2xhcCc6ICdcXHUyQTg1JyxcbiAgICAnbGVzc2FwcHJveCc6ICdcXHUyQTg1JyxcbiAgICAnbGFxdW8nOiAnXFx1MDBBQicsXG4gICAgJ2xhcnJiZnMnOiAnXFx1MjkxRicsXG4gICAgJ2xhcnJmcyc6ICdcXHUyOTFEJyxcbiAgICAnbGFycmxwJzogJ1xcdTIxQUInLFxuICAgICdsb29wYXJyb3dsZWZ0JzogJ1xcdTIxQUInLFxuICAgICdsYXJycGwnOiAnXFx1MjkzOScsXG4gICAgJ2xhcnJzaW0nOiAnXFx1Mjk3MycsXG4gICAgJ2xhcnJ0bCc6ICdcXHUyMUEyJyxcbiAgICAnbGVmdGFycm93dGFpbCc6ICdcXHUyMUEyJyxcbiAgICAnbGF0JzogJ1xcdTJBQUInLFxuICAgICdsYXRhaWwnOiAnXFx1MjkxOScsXG4gICAgJ2xhdGUnOiAnXFx1MkFBRCcsXG4gICAgJ2xhdGVzJzogJ1xcdTJBQURcXHVGRTAwJyxcbiAgICAnbGJhcnInOiAnXFx1MjkwQycsXG4gICAgJ2xiYnJrJzogJ1xcdTI3NzInLFxuICAgICdsYnJhY2UnOiAnXFx1MDA3QicsXG4gICAgJ2xjdWInOiAnXFx1MDA3QicsXG4gICAgJ2xicmFjayc6ICdcXHUwMDVCJyxcbiAgICAnbHNxYic6ICdcXHUwMDVCJyxcbiAgICAnbGJya2UnOiAnXFx1Mjk4QicsXG4gICAgJ2xicmtzbGQnOiAnXFx1Mjk4RicsXG4gICAgJ2xicmtzbHUnOiAnXFx1Mjk4RCcsXG4gICAgJ2xjYXJvbic6ICdcXHUwMTNFJyxcbiAgICAnbGNlZGlsJzogJ1xcdTAxM0MnLFxuICAgICdsY3knOiAnXFx1MDQzQicsXG4gICAgJ2xkY2EnOiAnXFx1MjkzNicsXG4gICAgJ2xkcmRoYXInOiAnXFx1Mjk2NycsXG4gICAgJ2xkcnVzaGFyJzogJ1xcdTI5NEInLFxuICAgICdsZHNoJzogJ1xcdTIxQjInLFxuICAgICdsZSc6ICdcXHUyMjY0JyxcbiAgICAnbGVxJzogJ1xcdTIyNjQnLFxuICAgICdsZWZ0bGVmdGFycm93cyc6ICdcXHUyMUM3JyxcbiAgICAnbGxhcnInOiAnXFx1MjFDNycsXG4gICAgJ2xlZnR0aHJlZXRpbWVzJzogJ1xcdTIyQ0InLFxuICAgICdsdGhyZWUnOiAnXFx1MjJDQicsXG4gICAgJ2xlc2NjJzogJ1xcdTJBQTgnLFxuICAgICdsZXNkb3QnOiAnXFx1MkE3RicsXG4gICAgJ2xlc2RvdG8nOiAnXFx1MkE4MScsXG4gICAgJ2xlc2RvdG9yJzogJ1xcdTJBODMnLFxuICAgICdsZXNnJzogJ1xcdTIyREFcXHVGRTAwJyxcbiAgICAnbGVzZ2VzJzogJ1xcdTJBOTMnLFxuICAgICdsZXNzZG90JzogJ1xcdTIyRDYnLFxuICAgICdsdGRvdCc6ICdcXHUyMkQ2JyxcbiAgICAnbGZpc2h0JzogJ1xcdTI5N0MnLFxuICAgICdsZnInOiAnXFx1RDgzNVxcdUREMjknLFxuICAgICdsZ0UnOiAnXFx1MkE5MScsXG4gICAgJ2xoYXJ1bCc6ICdcXHUyOTZBJyxcbiAgICAnbGhibGsnOiAnXFx1MjU4NCcsXG4gICAgJ2xqY3knOiAnXFx1MDQ1OScsXG4gICAgJ2xsaGFyZCc6ICdcXHUyOTZCJyxcbiAgICAnbGx0cmknOiAnXFx1MjVGQScsXG4gICAgJ2xtaWRvdCc6ICdcXHUwMTQwJyxcbiAgICAnbG1vdXN0JzogJ1xcdTIzQjAnLFxuICAgICdsbW91c3RhY2hlJzogJ1xcdTIzQjAnLFxuICAgICdsbkUnOiAnXFx1MjI2OCcsXG4gICAgJ2xuZXFxJzogJ1xcdTIyNjgnLFxuICAgICdsbmFwJzogJ1xcdTJBODknLFxuICAgICdsbmFwcHJveCc6ICdcXHUyQTg5JyxcbiAgICAnbG5lJzogJ1xcdTJBODcnLFxuICAgICdsbmVxJzogJ1xcdTJBODcnLFxuICAgICdsbnNpbSc6ICdcXHUyMkU2JyxcbiAgICAnbG9hbmcnOiAnXFx1MjdFQycsXG4gICAgJ2xvYXJyJzogJ1xcdTIxRkQnLFxuICAgICdsb25nbWFwc3RvJzogJ1xcdTI3RkMnLFxuICAgICd4bWFwJzogJ1xcdTI3RkMnLFxuICAgICdsb29wYXJyb3dyaWdodCc6ICdcXHUyMUFDJyxcbiAgICAncmFycmxwJzogJ1xcdTIxQUMnLFxuICAgICdsb3Bhcic6ICdcXHUyOTg1JyxcbiAgICAnbG9wZic6ICdcXHVEODM1XFx1REQ1RCcsXG4gICAgJ2xvcGx1cyc6ICdcXHUyQTJEJyxcbiAgICAnbG90aW1lcyc6ICdcXHUyQTM0JyxcbiAgICAnbG93YXN0JzogJ1xcdTIyMTcnLFxuICAgICdsb3onOiAnXFx1MjVDQScsXG4gICAgJ2xvemVuZ2UnOiAnXFx1MjVDQScsXG4gICAgJ2xwYXInOiAnXFx1MDAyOCcsXG4gICAgJ2xwYXJsdCc6ICdcXHUyOTkzJyxcbiAgICAnbHJoYXJkJzogJ1xcdTI5NkQnLFxuICAgICdscm0nOiAnXFx1MjAwRScsXG4gICAgJ2xydHJpJzogJ1xcdTIyQkYnLFxuICAgICdsc2FxdW8nOiAnXFx1MjAzOScsXG4gICAgJ2xzY3InOiAnXFx1RDgzNVxcdURDQzEnLFxuICAgICdsc2ltZSc6ICdcXHUyQThEJyxcbiAgICAnbHNpbWcnOiAnXFx1MkE4RicsXG4gICAgJ2xzcXVvcic6ICdcXHUyMDFBJyxcbiAgICAnc2JxdW8nOiAnXFx1MjAxQScsXG4gICAgJ2xzdHJvayc6ICdcXHUwMTQyJyxcbiAgICAnbHRjYyc6ICdcXHUyQUE2JyxcbiAgICAnbHRjaXInOiAnXFx1MkE3OScsXG4gICAgJ2x0aW1lcyc6ICdcXHUyMkM5JyxcbiAgICAnbHRsYXJyJzogJ1xcdTI5NzYnLFxuICAgICdsdHF1ZXN0JzogJ1xcdTJBN0InLFxuICAgICdsdHJQYXInOiAnXFx1Mjk5NicsXG4gICAgJ2x0cmknOiAnXFx1MjVDMycsXG4gICAgJ3RyaWFuZ2xlbGVmdCc6ICdcXHUyNUMzJyxcbiAgICAnbHVyZHNoYXInOiAnXFx1Mjk0QScsXG4gICAgJ2x1cnVoYXInOiAnXFx1Mjk2NicsXG4gICAgJ2x2ZXJ0bmVxcSc6ICdcXHUyMjY4XFx1RkUwMCcsXG4gICAgJ2x2bkUnOiAnXFx1MjI2OFxcdUZFMDAnLFxuICAgICdtRERvdCc6ICdcXHUyMjNBJyxcbiAgICAnbWFjcic6ICdcXHUwMEFGJyxcbiAgICAnc3RybnMnOiAnXFx1MDBBRicsXG4gICAgJ21hbGUnOiAnXFx1MjY0MicsXG4gICAgJ21hbHQnOiAnXFx1MjcyMCcsXG4gICAgJ21hbHRlc2UnOiAnXFx1MjcyMCcsXG4gICAgJ21hcmtlcic6ICdcXHUyNUFFJyxcbiAgICAnbWNvbW1hJzogJ1xcdTJBMjknLFxuICAgICdtY3knOiAnXFx1MDQzQycsXG4gICAgJ21kYXNoJzogJ1xcdTIwMTQnLFxuICAgICdtZnInOiAnXFx1RDgzNVxcdUREMkEnLFxuICAgICdtaG8nOiAnXFx1MjEyNycsXG4gICAgJ21pY3JvJzogJ1xcdTAwQjUnLFxuICAgICdtaWRjaXInOiAnXFx1MkFGMCcsXG4gICAgJ21pbnVzJzogJ1xcdTIyMTInLFxuICAgICdtaW51c2R1JzogJ1xcdTJBMkEnLFxuICAgICdtbGNwJzogJ1xcdTJBREInLFxuICAgICdtb2RlbHMnOiAnXFx1MjJBNycsXG4gICAgJ21vcGYnOiAnXFx1RDgzNVxcdURENUUnLFxuICAgICdtc2NyJzogJ1xcdUQ4MzVcXHVEQ0MyJyxcbiAgICAnbXUnOiAnXFx1MDNCQycsXG4gICAgJ211bHRpbWFwJzogJ1xcdTIyQjgnLFxuICAgICdtdW1hcCc6ICdcXHUyMkI4JyxcbiAgICAnbkdnJzogJ1xcdTIyRDlcXHUwMzM4JyxcbiAgICAnbkd0JzogJ1xcdTIyNkJcXHUyMEQyJyxcbiAgICAnbkxlZnRhcnJvdyc6ICdcXHUyMUNEJyxcbiAgICAnbmxBcnInOiAnXFx1MjFDRCcsXG4gICAgJ25MZWZ0cmlnaHRhcnJvdyc6ICdcXHUyMUNFJyxcbiAgICAnbmhBcnInOiAnXFx1MjFDRScsXG4gICAgJ25MbCc6ICdcXHUyMkQ4XFx1MDMzOCcsXG4gICAgJ25MdCc6ICdcXHUyMjZBXFx1MjBEMicsXG4gICAgJ25SaWdodGFycm93JzogJ1xcdTIxQ0YnLFxuICAgICduckFycic6ICdcXHUyMUNGJyxcbiAgICAnblZEYXNoJzogJ1xcdTIyQUYnLFxuICAgICduVmRhc2gnOiAnXFx1MjJBRScsXG4gICAgJ25hY3V0ZSc6ICdcXHUwMTQ0JyxcbiAgICAnbmFuZyc6ICdcXHUyMjIwXFx1MjBEMicsXG4gICAgJ25hcEUnOiAnXFx1MkE3MFxcdTAzMzgnLFxuICAgICduYXBpZCc6ICdcXHUyMjRCXFx1MDMzOCcsXG4gICAgJ25hcG9zJzogJ1xcdTAxNDknLFxuICAgICduYXR1cic6ICdcXHUyNjZFJyxcbiAgICAnbmF0dXJhbCc6ICdcXHUyNjZFJyxcbiAgICAnbmNhcCc6ICdcXHUyQTQzJyxcbiAgICAnbmNhcm9uJzogJ1xcdTAxNDgnLFxuICAgICduY2VkaWwnOiAnXFx1MDE0NicsXG4gICAgJ25jb25nZG90JzogJ1xcdTJBNkRcXHUwMzM4JyxcbiAgICAnbmN1cCc6ICdcXHUyQTQyJyxcbiAgICAnbmN5JzogJ1xcdTA0M0QnLFxuICAgICduZGFzaCc6ICdcXHUyMDEzJyxcbiAgICAnbmVBcnInOiAnXFx1MjFENycsXG4gICAgJ25lYXJoayc6ICdcXHUyOTI0JyxcbiAgICAnbmVkb3QnOiAnXFx1MjI1MFxcdTAzMzgnLFxuICAgICduZXNlYXInOiAnXFx1MjkyOCcsXG4gICAgJ3RvZWEnOiAnXFx1MjkyOCcsXG4gICAgJ25mcic6ICdcXHVEODM1XFx1REQyQicsXG4gICAgJ25oYXJyJzogJ1xcdTIxQUUnLFxuICAgICdubGVmdHJpZ2h0YXJyb3cnOiAnXFx1MjFBRScsXG4gICAgJ25ocGFyJzogJ1xcdTJBRjInLFxuICAgICduaXMnOiAnXFx1MjJGQycsXG4gICAgJ25pc2QnOiAnXFx1MjJGQScsXG4gICAgJ25qY3knOiAnXFx1MDQ1QScsXG4gICAgJ25sRSc6ICdcXHUyMjY2XFx1MDMzOCcsXG4gICAgJ25sZXFxJzogJ1xcdTIyNjZcXHUwMzM4JyxcbiAgICAnbmxhcnInOiAnXFx1MjE5QScsXG4gICAgJ25sZWZ0YXJyb3cnOiAnXFx1MjE5QScsXG4gICAgJ25sZHInOiAnXFx1MjAyNScsXG4gICAgJ25vcGYnOiAnXFx1RDgzNVxcdURENUYnLFxuICAgICdub3QnOiAnXFx1MDBBQycsXG4gICAgJ25vdGluRSc6ICdcXHUyMkY5XFx1MDMzOCcsXG4gICAgJ25vdGluZG90JzogJ1xcdTIyRjVcXHUwMzM4JyxcbiAgICAnbm90aW52Yic6ICdcXHUyMkY3JyxcbiAgICAnbm90aW52Yyc6ICdcXHUyMkY2JyxcbiAgICAnbm90bml2Yic6ICdcXHUyMkZFJyxcbiAgICAnbm90bml2Yyc6ICdcXHUyMkZEJyxcbiAgICAnbnBhcnNsJzogJ1xcdTJBRkRcXHUyMEU1JyxcbiAgICAnbnBhcnQnOiAnXFx1MjIwMlxcdTAzMzgnLFxuICAgICducG9saW50JzogJ1xcdTJBMTQnLFxuICAgICducmFycic6ICdcXHUyMTlCJyxcbiAgICAnbnJpZ2h0YXJyb3cnOiAnXFx1MjE5QicsXG4gICAgJ25yYXJyYyc6ICdcXHUyOTMzXFx1MDMzOCcsXG4gICAgJ25yYXJydyc6ICdcXHUyMTlEXFx1MDMzOCcsXG4gICAgJ25zY3InOiAnXFx1RDgzNVxcdURDQzMnLFxuICAgICduc3ViJzogJ1xcdTIyODQnLFxuICAgICduc3ViRSc6ICdcXHUyQUM1XFx1MDMzOCcsXG4gICAgJ25zdWJzZXRlcXEnOiAnXFx1MkFDNVxcdTAzMzgnLFxuICAgICduc3VwJzogJ1xcdTIyODUnLFxuICAgICduc3VwRSc6ICdcXHUyQUM2XFx1MDMzOCcsXG4gICAgJ25zdXBzZXRlcXEnOiAnXFx1MkFDNlxcdTAzMzgnLFxuICAgICdudGlsZGUnOiAnXFx1MDBGMScsXG4gICAgJ251JzogJ1xcdTAzQkQnLFxuICAgICdudW0nOiAnXFx1MDAyMycsXG4gICAgJ251bWVybyc6ICdcXHUyMTE2JyxcbiAgICAnbnVtc3AnOiAnXFx1MjAwNycsXG4gICAgJ252RGFzaCc6ICdcXHUyMkFEJyxcbiAgICAnbnZIYXJyJzogJ1xcdTI5MDQnLFxuICAgICdudmFwJzogJ1xcdTIyNERcXHUyMEQyJyxcbiAgICAnbnZkYXNoJzogJ1xcdTIyQUMnLFxuICAgICdudmdlJzogJ1xcdTIyNjVcXHUyMEQyJyxcbiAgICAnbnZndCc6ICdcXHUwMDNFXFx1MjBEMicsXG4gICAgJ252aW5maW4nOiAnXFx1MjlERScsXG4gICAgJ252bEFycic6ICdcXHUyOTAyJyxcbiAgICAnbnZsZSc6ICdcXHUyMjY0XFx1MjBEMicsXG4gICAgJ252bHQnOiAnXFx1MDAzQ1xcdTIwRDInLFxuICAgICdudmx0cmllJzogJ1xcdTIyQjRcXHUyMEQyJyxcbiAgICAnbnZyQXJyJzogJ1xcdTI5MDMnLFxuICAgICdudnJ0cmllJzogJ1xcdTIyQjVcXHUyMEQyJyxcbiAgICAnbnZzaW0nOiAnXFx1MjIzQ1xcdTIwRDInLFxuICAgICdud0Fycic6ICdcXHUyMUQ2JyxcbiAgICAnbndhcmhrJzogJ1xcdTI5MjMnLFxuICAgICdud25lYXInOiAnXFx1MjkyNycsXG4gICAgJ29hY3V0ZSc6ICdcXHUwMEYzJyxcbiAgICAnb2NpcmMnOiAnXFx1MDBGNCcsXG4gICAgJ29jeSc6ICdcXHUwNDNFJyxcbiAgICAnb2RibGFjJzogJ1xcdTAxNTEnLFxuICAgICdvZGl2JzogJ1xcdTJBMzgnLFxuICAgICdvZHNvbGQnOiAnXFx1MjlCQycsXG4gICAgJ29lbGlnJzogJ1xcdTAxNTMnLFxuICAgICdvZmNpcic6ICdcXHUyOUJGJyxcbiAgICAnb2ZyJzogJ1xcdUQ4MzVcXHVERDJDJyxcbiAgICAnb2dvbic6ICdcXHUwMkRCJyxcbiAgICAnb2dyYXZlJzogJ1xcdTAwRjInLFxuICAgICdvZ3QnOiAnXFx1MjlDMScsXG4gICAgJ29oYmFyJzogJ1xcdTI5QjUnLFxuICAgICdvbGNpcic6ICdcXHUyOUJFJyxcbiAgICAnb2xjcm9zcyc6ICdcXHUyOUJCJyxcbiAgICAnb2x0JzogJ1xcdTI5QzAnLFxuICAgICdvbWFjcic6ICdcXHUwMTREJyxcbiAgICAnb21lZ2EnOiAnXFx1MDNDOScsXG4gICAgJ29taWNyb24nOiAnXFx1MDNCRicsXG4gICAgJ29taWQnOiAnXFx1MjlCNicsXG4gICAgJ29vcGYnOiAnXFx1RDgzNVxcdURENjAnLFxuICAgICdvcGFyJzogJ1xcdTI5QjcnLFxuICAgICdvcGVycCc6ICdcXHUyOUI5JyxcbiAgICAnb3InOiAnXFx1MjIyOCcsXG4gICAgJ3ZlZSc6ICdcXHUyMjI4JyxcbiAgICAnb3JkJzogJ1xcdTJBNUQnLFxuICAgICdvcmRlcic6ICdcXHUyMTM0JyxcbiAgICAnb3JkZXJvZic6ICdcXHUyMTM0JyxcbiAgICAnb3Njcic6ICdcXHUyMTM0JyxcbiAgICAnb3JkZic6ICdcXHUwMEFBJyxcbiAgICAnb3JkbSc6ICdcXHUwMEJBJyxcbiAgICAnb3JpZ29mJzogJ1xcdTIyQjYnLFxuICAgICdvcm9yJzogJ1xcdTJBNTYnLFxuICAgICdvcnNsb3BlJzogJ1xcdTJBNTcnLFxuICAgICdvcnYnOiAnXFx1MkE1QicsXG4gICAgJ29zbGFzaCc6ICdcXHUwMEY4JyxcbiAgICAnb3NvbCc6ICdcXHUyMjk4JyxcbiAgICAnb3RpbGRlJzogJ1xcdTAwRjUnLFxuICAgICdvdGltZXNhcyc6ICdcXHUyQTM2JyxcbiAgICAnb3VtbCc6ICdcXHUwMEY2JyxcbiAgICAnb3ZiYXInOiAnXFx1MjMzRCcsXG4gICAgJ3BhcmEnOiAnXFx1MDBCNicsXG4gICAgJ3BhcnNpbSc6ICdcXHUyQUYzJyxcbiAgICAncGFyc2wnOiAnXFx1MkFGRCcsXG4gICAgJ3BjeSc6ICdcXHUwNDNGJyxcbiAgICAncGVyY250JzogJ1xcdTAwMjUnLFxuICAgICdwZXJpb2QnOiAnXFx1MDAyRScsXG4gICAgJ3Blcm1pbCc6ICdcXHUyMDMwJyxcbiAgICAncGVydGVuayc6ICdcXHUyMDMxJyxcbiAgICAncGZyJzogJ1xcdUQ4MzVcXHVERDJEJyxcbiAgICAncGhpJzogJ1xcdTAzQzYnLFxuICAgICdwaGl2JzogJ1xcdTAzRDUnLFxuICAgICdzdHJhaWdodHBoaSc6ICdcXHUwM0Q1JyxcbiAgICAndmFycGhpJzogJ1xcdTAzRDUnLFxuICAgICdwaG9uZSc6ICdcXHUyNjBFJyxcbiAgICAncGknOiAnXFx1MDNDMCcsXG4gICAgJ3Bpdic6ICdcXHUwM0Q2JyxcbiAgICAndmFycGknOiAnXFx1MDNENicsXG4gICAgJ3BsYW5ja2gnOiAnXFx1MjEwRScsXG4gICAgJ3BsdXMnOiAnXFx1MDAyQicsXG4gICAgJ3BsdXNhY2lyJzogJ1xcdTJBMjMnLFxuICAgICdwbHVzY2lyJzogJ1xcdTJBMjInLFxuICAgICdwbHVzZHUnOiAnXFx1MkEyNScsXG4gICAgJ3BsdXNlJzogJ1xcdTJBNzInLFxuICAgICdwbHVzc2ltJzogJ1xcdTJBMjYnLFxuICAgICdwbHVzdHdvJzogJ1xcdTJBMjcnLFxuICAgICdwb2ludGludCc6ICdcXHUyQTE1JyxcbiAgICAncG9wZic6ICdcXHVEODM1XFx1REQ2MScsXG4gICAgJ3BvdW5kJzogJ1xcdTAwQTMnLFxuICAgICdwckUnOiAnXFx1MkFCMycsXG4gICAgJ3ByYXAnOiAnXFx1MkFCNycsXG4gICAgJ3ByZWNhcHByb3gnOiAnXFx1MkFCNycsXG4gICAgJ3ByZWNuYXBwcm94JzogJ1xcdTJBQjknLFxuICAgICdwcm5hcCc6ICdcXHUyQUI5JyxcbiAgICAncHJlY25lcXEnOiAnXFx1MkFCNScsXG4gICAgJ3BybkUnOiAnXFx1MkFCNScsXG4gICAgJ3ByZWNuc2ltJzogJ1xcdTIyRTgnLFxuICAgICdwcm5zaW0nOiAnXFx1MjJFOCcsXG4gICAgJ3ByaW1lJzogJ1xcdTIwMzInLFxuICAgICdwcm9mYWxhcic6ICdcXHUyMzJFJyxcbiAgICAncHJvZmxpbmUnOiAnXFx1MjMxMicsXG4gICAgJ3Byb2ZzdXJmJzogJ1xcdTIzMTMnLFxuICAgICdwcnVyZWwnOiAnXFx1MjJCMCcsXG4gICAgJ3BzY3InOiAnXFx1RDgzNVxcdURDQzUnLFxuICAgICdwc2knOiAnXFx1MDNDOCcsXG4gICAgJ3B1bmNzcCc6ICdcXHUyMDA4JyxcbiAgICAncWZyJzogJ1xcdUQ4MzVcXHVERDJFJyxcbiAgICAncW9wZic6ICdcXHVEODM1XFx1REQ2MicsXG4gICAgJ3FwcmltZSc6ICdcXHUyMDU3JyxcbiAgICAncXNjcic6ICdcXHVEODM1XFx1RENDNicsXG4gICAgJ3F1YXRpbnQnOiAnXFx1MkExNicsXG4gICAgJ3F1ZXN0JzogJ1xcdTAwM0YnLFxuICAgICdyQXRhaWwnOiAnXFx1MjkxQycsXG4gICAgJ3JIYXInOiAnXFx1Mjk2NCcsXG4gICAgJ3JhY2UnOiAnXFx1MjIzRFxcdTAzMzEnLFxuICAgICdyYWN1dGUnOiAnXFx1MDE1NScsXG4gICAgJ3JhZW1wdHl2JzogJ1xcdTI5QjMnLFxuICAgICdyYW5nZCc6ICdcXHUyOTkyJyxcbiAgICAncmFuZ2UnOiAnXFx1MjlBNScsXG4gICAgJ3JhcXVvJzogJ1xcdTAwQkInLFxuICAgICdyYXJyYXAnOiAnXFx1Mjk3NScsXG4gICAgJ3JhcnJiZnMnOiAnXFx1MjkyMCcsXG4gICAgJ3JhcnJjJzogJ1xcdTI5MzMnLFxuICAgICdyYXJyZnMnOiAnXFx1MjkxRScsXG4gICAgJ3JhcnJwbCc6ICdcXHUyOTQ1JyxcbiAgICAncmFycnNpbSc6ICdcXHUyOTc0JyxcbiAgICAncmFycnRsJzogJ1xcdTIxQTMnLFxuICAgICdyaWdodGFycm93dGFpbCc6ICdcXHUyMUEzJyxcbiAgICAncmFycncnOiAnXFx1MjE5RCcsXG4gICAgJ3JpZ2h0c3F1aWdhcnJvdyc6ICdcXHUyMTlEJyxcbiAgICAncmF0YWlsJzogJ1xcdTI5MUEnLFxuICAgICdyYXRpbyc6ICdcXHUyMjM2JyxcbiAgICAncmJicmsnOiAnXFx1Mjc3MycsXG4gICAgJ3JicmFjZSc6ICdcXHUwMDdEJyxcbiAgICAncmN1Yic6ICdcXHUwMDdEJyxcbiAgICAncmJyYWNrJzogJ1xcdTAwNUQnLFxuICAgICdyc3FiJzogJ1xcdTAwNUQnLFxuICAgICdyYnJrZSc6ICdcXHUyOThDJyxcbiAgICAncmJya3NsZCc6ICdcXHUyOThFJyxcbiAgICAncmJya3NsdSc6ICdcXHUyOTkwJyxcbiAgICAncmNhcm9uJzogJ1xcdTAxNTknLFxuICAgICdyY2VkaWwnOiAnXFx1MDE1NycsXG4gICAgJ3JjeSc6ICdcXHUwNDQwJyxcbiAgICAncmRjYSc6ICdcXHUyOTM3JyxcbiAgICAncmRsZGhhcic6ICdcXHUyOTY5JyxcbiAgICAncmRzaCc6ICdcXHUyMUIzJyxcbiAgICAncmVjdCc6ICdcXHUyNUFEJyxcbiAgICAncmZpc2h0JzogJ1xcdTI5N0QnLFxuICAgICdyZnInOiAnXFx1RDgzNVxcdUREMkYnLFxuICAgICdyaGFydWwnOiAnXFx1Mjk2QycsXG4gICAgJ3Jobyc6ICdcXHUwM0MxJyxcbiAgICAncmhvdic6ICdcXHUwM0YxJyxcbiAgICAndmFycmhvJzogJ1xcdTAzRjEnLFxuICAgICdyaWdodHJpZ2h0YXJyb3dzJzogJ1xcdTIxQzknLFxuICAgICdycmFycic6ICdcXHUyMUM5JyxcbiAgICAncmlnaHR0aHJlZXRpbWVzJzogJ1xcdTIyQ0MnLFxuICAgICdydGhyZWUnOiAnXFx1MjJDQycsXG4gICAgJ3JpbmcnOiAnXFx1MDJEQScsXG4gICAgJ3JsbSc6ICdcXHUyMDBGJyxcbiAgICAncm1vdXN0JzogJ1xcdTIzQjEnLFxuICAgICdybW91c3RhY2hlJzogJ1xcdTIzQjEnLFxuICAgICdybm1pZCc6ICdcXHUyQUVFJyxcbiAgICAncm9hbmcnOiAnXFx1MjdFRCcsXG4gICAgJ3JvYXJyJzogJ1xcdTIxRkUnLFxuICAgICdyb3Bhcic6ICdcXHUyOTg2JyxcbiAgICAncm9wZic6ICdcXHVEODM1XFx1REQ2MycsXG4gICAgJ3JvcGx1cyc6ICdcXHUyQTJFJyxcbiAgICAncm90aW1lcyc6ICdcXHUyQTM1JyxcbiAgICAncnBhcic6ICdcXHUwMDI5JyxcbiAgICAncnBhcmd0JzogJ1xcdTI5OTQnLFxuICAgICdycHBvbGludCc6ICdcXHUyQTEyJyxcbiAgICAncnNhcXVvJzogJ1xcdTIwM0EnLFxuICAgICdyc2NyJzogJ1xcdUQ4MzVcXHVEQ0M3JyxcbiAgICAncnRpbWVzJzogJ1xcdTIyQ0EnLFxuICAgICdydHJpJzogJ1xcdTI1QjknLFxuICAgICd0cmlhbmdsZXJpZ2h0JzogJ1xcdTI1QjknLFxuICAgICdydHJpbHRyaSc6ICdcXHUyOUNFJyxcbiAgICAncnVsdWhhcic6ICdcXHUyOTY4JyxcbiAgICAncngnOiAnXFx1MjExRScsXG4gICAgJ3NhY3V0ZSc6ICdcXHUwMTVCJyxcbiAgICAnc2NFJzogJ1xcdTJBQjQnLFxuICAgICdzY2FwJzogJ1xcdTJBQjgnLFxuICAgICdzdWNjYXBwcm94JzogJ1xcdTJBQjgnLFxuICAgICdzY2Fyb24nOiAnXFx1MDE2MScsXG4gICAgJ3NjZWRpbCc6ICdcXHUwMTVGJyxcbiAgICAnc2NpcmMnOiAnXFx1MDE1RCcsXG4gICAgJ3NjbkUnOiAnXFx1MkFCNicsXG4gICAgJ3N1Y2NuZXFxJzogJ1xcdTJBQjYnLFxuICAgICdzY25hcCc6ICdcXHUyQUJBJyxcbiAgICAnc3VjY25hcHByb3gnOiAnXFx1MkFCQScsXG4gICAgJ3NjbnNpbSc6ICdcXHUyMkU5JyxcbiAgICAnc3VjY25zaW0nOiAnXFx1MjJFOScsXG4gICAgJ3NjcG9saW50JzogJ1xcdTJBMTMnLFxuICAgICdzY3knOiAnXFx1MDQ0MScsXG4gICAgJ3Nkb3QnOiAnXFx1MjJDNScsXG4gICAgJ3Nkb3RlJzogJ1xcdTJBNjYnLFxuICAgICdzZUFycic6ICdcXHUyMUQ4JyxcbiAgICAnc2VjdCc6ICdcXHUwMEE3JyxcbiAgICAnc2VtaSc6ICdcXHUwMDNCJyxcbiAgICAnc2Vzd2FyJzogJ1xcdTI5MjknLFxuICAgICd0b3NhJzogJ1xcdTI5MjknLFxuICAgICdzZXh0JzogJ1xcdTI3MzYnLFxuICAgICdzZnInOiAnXFx1RDgzNVxcdUREMzAnLFxuICAgICdzaGFycCc6ICdcXHUyNjZGJyxcbiAgICAnc2hjaGN5JzogJ1xcdTA0NDknLFxuICAgICdzaGN5JzogJ1xcdTA0NDgnLFxuICAgICdzaHknOiAnXFx1MDBBRCcsXG4gICAgJ3NpZ21hJzogJ1xcdTAzQzMnLFxuICAgICdzaWdtYWYnOiAnXFx1MDNDMicsXG4gICAgJ3NpZ21hdic6ICdcXHUwM0MyJyxcbiAgICAndmFyc2lnbWEnOiAnXFx1MDNDMicsXG4gICAgJ3NpbWRvdCc6ICdcXHUyQTZBJyxcbiAgICAnc2ltZyc6ICdcXHUyQTlFJyxcbiAgICAnc2ltZ0UnOiAnXFx1MkFBMCcsXG4gICAgJ3NpbWwnOiAnXFx1MkE5RCcsXG4gICAgJ3NpbWxFJzogJ1xcdTJBOUYnLFxuICAgICdzaW1uZSc6ICdcXHUyMjQ2JyxcbiAgICAnc2ltcGx1cyc6ICdcXHUyQTI0JyxcbiAgICAnc2ltcmFycic6ICdcXHUyOTcyJyxcbiAgICAnc21hc2hwJzogJ1xcdTJBMzMnLFxuICAgICdzbWVwYXJzbCc6ICdcXHUyOUU0JyxcbiAgICAnc21pbGUnOiAnXFx1MjMyMycsXG4gICAgJ3NzbWlsZSc6ICdcXHUyMzIzJyxcbiAgICAnc210JzogJ1xcdTJBQUEnLFxuICAgICdzbXRlJzogJ1xcdTJBQUMnLFxuICAgICdzbXRlcyc6ICdcXHUyQUFDXFx1RkUwMCcsXG4gICAgJ3NvZnRjeSc6ICdcXHUwNDRDJyxcbiAgICAnc29sJzogJ1xcdTAwMkYnLFxuICAgICdzb2xiJzogJ1xcdTI5QzQnLFxuICAgICdzb2xiYXInOiAnXFx1MjMzRicsXG4gICAgJ3NvcGYnOiAnXFx1RDgzNVxcdURENjQnLFxuICAgICdzcGFkZXMnOiAnXFx1MjY2MCcsXG4gICAgJ3NwYWRlc3VpdCc6ICdcXHUyNjYwJyxcbiAgICAnc3FjYXBzJzogJ1xcdTIyOTNcXHVGRTAwJyxcbiAgICAnc3FjdXBzJzogJ1xcdTIyOTRcXHVGRTAwJyxcbiAgICAnc3Njcic6ICdcXHVEODM1XFx1RENDOCcsXG4gICAgJ3N0YXInOiAnXFx1MjYwNicsXG4gICAgJ3N1Yic6ICdcXHUyMjgyJyxcbiAgICAnc3Vic2V0JzogJ1xcdTIyODInLFxuICAgICdzdWJFJzogJ1xcdTJBQzUnLFxuICAgICdzdWJzZXRlcXEnOiAnXFx1MkFDNScsXG4gICAgJ3N1YmRvdCc6ICdcXHUyQUJEJyxcbiAgICAnc3ViZWRvdCc6ICdcXHUyQUMzJyxcbiAgICAnc3VibXVsdCc6ICdcXHUyQUMxJyxcbiAgICAnc3VibkUnOiAnXFx1MkFDQicsXG4gICAgJ3N1YnNldG5lcXEnOiAnXFx1MkFDQicsXG4gICAgJ3N1Ym5lJzogJ1xcdTIyOEEnLFxuICAgICdzdWJzZXRuZXEnOiAnXFx1MjI4QScsXG4gICAgJ3N1YnBsdXMnOiAnXFx1MkFCRicsXG4gICAgJ3N1YnJhcnInOiAnXFx1Mjk3OScsXG4gICAgJ3N1YnNpbSc6ICdcXHUyQUM3JyxcbiAgICAnc3Vic3ViJzogJ1xcdTJBRDUnLFxuICAgICdzdWJzdXAnOiAnXFx1MkFEMycsXG4gICAgJ3N1bmcnOiAnXFx1MjY2QScsXG4gICAgJ3N1cDEnOiAnXFx1MDBCOScsXG4gICAgJ3N1cDInOiAnXFx1MDBCMicsXG4gICAgJ3N1cDMnOiAnXFx1MDBCMycsXG4gICAgJ3N1cEUnOiAnXFx1MkFDNicsXG4gICAgJ3N1cHNldGVxcSc6ICdcXHUyQUM2JyxcbiAgICAnc3VwZG90JzogJ1xcdTJBQkUnLFxuICAgICdzdXBkc3ViJzogJ1xcdTJBRDgnLFxuICAgICdzdXBlZG90JzogJ1xcdTJBQzQnLFxuICAgICdzdXBoc29sJzogJ1xcdTI3QzknLFxuICAgICdzdXBoc3ViJzogJ1xcdTJBRDcnLFxuICAgICdzdXBsYXJyJzogJ1xcdTI5N0InLFxuICAgICdzdXBtdWx0JzogJ1xcdTJBQzInLFxuICAgICdzdXBuRSc6ICdcXHUyQUNDJyxcbiAgICAnc3Vwc2V0bmVxcSc6ICdcXHUyQUNDJyxcbiAgICAnc3VwbmUnOiAnXFx1MjI4QicsXG4gICAgJ3N1cHNldG5lcSc6ICdcXHUyMjhCJyxcbiAgICAnc3VwcGx1cyc6ICdcXHUyQUMwJyxcbiAgICAnc3Vwc2ltJzogJ1xcdTJBQzgnLFxuICAgICdzdXBzdWInOiAnXFx1MkFENCcsXG4gICAgJ3N1cHN1cCc6ICdcXHUyQUQ2JyxcbiAgICAnc3dBcnInOiAnXFx1MjFEOScsXG4gICAgJ3N3bndhcic6ICdcXHUyOTJBJyxcbiAgICAnc3psaWcnOiAnXFx1MDBERicsXG4gICAgJ3RhcmdldCc6ICdcXHUyMzE2JyxcbiAgICAndGF1JzogJ1xcdTAzQzQnLFxuICAgICd0Y2Fyb24nOiAnXFx1MDE2NScsXG4gICAgJ3RjZWRpbCc6ICdcXHUwMTYzJyxcbiAgICAndGN5JzogJ1xcdTA0NDInLFxuICAgICd0ZWxyZWMnOiAnXFx1MjMxNScsXG4gICAgJ3Rmcic6ICdcXHVEODM1XFx1REQzMScsXG4gICAgJ3RoZXRhJzogJ1xcdTAzQjgnLFxuICAgICd0aGV0YXN5bSc6ICdcXHUwM0QxJyxcbiAgICAndGhldGF2JzogJ1xcdTAzRDEnLFxuICAgICd2YXJ0aGV0YSc6ICdcXHUwM0QxJyxcbiAgICAndGhvcm4nOiAnXFx1MDBGRScsXG4gICAgJ3RpbWVzJzogJ1xcdTAwRDcnLFxuICAgICd0aW1lc2Jhcic6ICdcXHUyQTMxJyxcbiAgICAndGltZXNkJzogJ1xcdTJBMzAnLFxuICAgICd0b3Bib3QnOiAnXFx1MjMzNicsXG4gICAgJ3RvcGNpcic6ICdcXHUyQUYxJyxcbiAgICAndG9wZic6ICdcXHVEODM1XFx1REQ2NScsXG4gICAgJ3RvcGZvcmsnOiAnXFx1MkFEQScsXG4gICAgJ3RwcmltZSc6ICdcXHUyMDM0JyxcbiAgICAndHJpYW5nbGUnOiAnXFx1MjVCNScsXG4gICAgJ3V0cmknOiAnXFx1MjVCNScsXG4gICAgJ3RyaWFuZ2xlcSc6ICdcXHUyMjVDJyxcbiAgICAndHJpZSc6ICdcXHUyMjVDJyxcbiAgICAndHJpZG90JzogJ1xcdTI1RUMnLFxuICAgICd0cmltaW51cyc6ICdcXHUyQTNBJyxcbiAgICAndHJpcGx1cyc6ICdcXHUyQTM5JyxcbiAgICAndHJpc2InOiAnXFx1MjlDRCcsXG4gICAgJ3RyaXRpbWUnOiAnXFx1MkEzQicsXG4gICAgJ3RycGV6aXVtJzogJ1xcdTIzRTInLFxuICAgICd0c2NyJzogJ1xcdUQ4MzVcXHVEQ0M5JyxcbiAgICAndHNjeSc6ICdcXHUwNDQ2JyxcbiAgICAndHNoY3knOiAnXFx1MDQ1QicsXG4gICAgJ3RzdHJvayc6ICdcXHUwMTY3JyxcbiAgICAndUhhcic6ICdcXHUyOTYzJyxcbiAgICAndWFjdXRlJzogJ1xcdTAwRkEnLFxuICAgICd1YnJjeSc6ICdcXHUwNDVFJyxcbiAgICAndWJyZXZlJzogJ1xcdTAxNkQnLFxuICAgICd1Y2lyYyc6ICdcXHUwMEZCJyxcbiAgICAndWN5JzogJ1xcdTA0NDMnLFxuICAgICd1ZGJsYWMnOiAnXFx1MDE3MScsXG4gICAgJ3VmaXNodCc6ICdcXHUyOTdFJyxcbiAgICAndWZyJzogJ1xcdUQ4MzVcXHVERDMyJyxcbiAgICAndWdyYXZlJzogJ1xcdTAwRjknLFxuICAgICd1aGJsayc6ICdcXHUyNTgwJyxcbiAgICAndWxjb3JuJzogJ1xcdTIzMUMnLFxuICAgICd1bGNvcm5lcic6ICdcXHUyMzFDJyxcbiAgICAndWxjcm9wJzogJ1xcdTIzMEYnLFxuICAgICd1bHRyaSc6ICdcXHUyNUY4JyxcbiAgICAndW1hY3InOiAnXFx1MDE2QicsXG4gICAgJ3VvZ29uJzogJ1xcdTAxNzMnLFxuICAgICd1b3BmJzogJ1xcdUQ4MzVcXHVERDY2JyxcbiAgICAndXBzaSc6ICdcXHUwM0M1JyxcbiAgICAndXBzaWxvbic6ICdcXHUwM0M1JyxcbiAgICAndXB1cGFycm93cyc6ICdcXHUyMUM4JyxcbiAgICAndXVhcnInOiAnXFx1MjFDOCcsXG4gICAgJ3VyY29ybic6ICdcXHUyMzFEJyxcbiAgICAndXJjb3JuZXInOiAnXFx1MjMxRCcsXG4gICAgJ3VyY3JvcCc6ICdcXHUyMzBFJyxcbiAgICAndXJpbmcnOiAnXFx1MDE2RicsXG4gICAgJ3VydHJpJzogJ1xcdTI1RjknLFxuICAgICd1c2NyJzogJ1xcdUQ4MzVcXHVEQ0NBJyxcbiAgICAndXRkb3QnOiAnXFx1MjJGMCcsXG4gICAgJ3V0aWxkZSc6ICdcXHUwMTY5JyxcbiAgICAndXVtbCc6ICdcXHUwMEZDJyxcbiAgICAndXdhbmdsZSc6ICdcXHUyOUE3JyxcbiAgICAndkJhcic6ICdcXHUyQUU4JyxcbiAgICAndkJhcnYnOiAnXFx1MkFFOScsXG4gICAgJ3ZhbmdydCc6ICdcXHUyOTlDJyxcbiAgICAndmFyc3Vic2V0bmVxJzogJ1xcdTIyOEFcXHVGRTAwJyxcbiAgICAndnN1Ym5lJzogJ1xcdTIyOEFcXHVGRTAwJyxcbiAgICAndmFyc3Vic2V0bmVxcSc6ICdcXHUyQUNCXFx1RkUwMCcsXG4gICAgJ3ZzdWJuRSc6ICdcXHUyQUNCXFx1RkUwMCcsXG4gICAgJ3ZhcnN1cHNldG5lcSc6ICdcXHUyMjhCXFx1RkUwMCcsXG4gICAgJ3ZzdXBuZSc6ICdcXHUyMjhCXFx1RkUwMCcsXG4gICAgJ3ZhcnN1cHNldG5lcXEnOiAnXFx1MkFDQ1xcdUZFMDAnLFxuICAgICd2c3VwbkUnOiAnXFx1MkFDQ1xcdUZFMDAnLFxuICAgICd2Y3knOiAnXFx1MDQzMicsXG4gICAgJ3ZlZWJhcic6ICdcXHUyMkJCJyxcbiAgICAndmVlZXEnOiAnXFx1MjI1QScsXG4gICAgJ3ZlbGxpcCc6ICdcXHUyMkVFJyxcbiAgICAndmZyJzogJ1xcdUQ4MzVcXHVERDMzJyxcbiAgICAndm9wZic6ICdcXHVEODM1XFx1REQ2NycsXG4gICAgJ3ZzY3InOiAnXFx1RDgzNVxcdURDQ0InLFxuICAgICd2emlnemFnJzogJ1xcdTI5OUEnLFxuICAgICd3Y2lyYyc6ICdcXHUwMTc1JyxcbiAgICAnd2VkYmFyJzogJ1xcdTJBNUYnLFxuICAgICd3ZWRnZXEnOiAnXFx1MjI1OScsXG4gICAgJ3dlaWVycCc6ICdcXHUyMTE4JyxcbiAgICAnd3AnOiAnXFx1MjExOCcsXG4gICAgJ3dmcic6ICdcXHVEODM1XFx1REQzNCcsXG4gICAgJ3dvcGYnOiAnXFx1RDgzNVxcdURENjgnLFxuICAgICd3c2NyJzogJ1xcdUQ4MzVcXHVEQ0NDJyxcbiAgICAneGZyJzogJ1xcdUQ4MzVcXHVERDM1JyxcbiAgICAneGknOiAnXFx1MDNCRScsXG4gICAgJ3huaXMnOiAnXFx1MjJGQicsXG4gICAgJ3hvcGYnOiAnXFx1RDgzNVxcdURENjknLFxuICAgICd4c2NyJzogJ1xcdUQ4MzVcXHVEQ0NEJyxcbiAgICAneWFjdXRlJzogJ1xcdTAwRkQnLFxuICAgICd5YWN5JzogJ1xcdTA0NEYnLFxuICAgICd5Y2lyYyc6ICdcXHUwMTc3JyxcbiAgICAneWN5JzogJ1xcdTA0NEInLFxuICAgICd5ZW4nOiAnXFx1MDBBNScsXG4gICAgJ3lmcic6ICdcXHVEODM1XFx1REQzNicsXG4gICAgJ3lpY3knOiAnXFx1MDQ1NycsXG4gICAgJ3lvcGYnOiAnXFx1RDgzNVxcdURENkEnLFxuICAgICd5c2NyJzogJ1xcdUQ4MzVcXHVEQ0NFJyxcbiAgICAneXVjeSc6ICdcXHUwNDRFJyxcbiAgICAneXVtbCc6ICdcXHUwMEZGJyxcbiAgICAnemFjdXRlJzogJ1xcdTAxN0EnLFxuICAgICd6Y2Fyb24nOiAnXFx1MDE3RScsXG4gICAgJ3pjeSc6ICdcXHUwNDM3JyxcbiAgICAnemRvdCc6ICdcXHUwMTdDJyxcbiAgICAnemV0YSc6ICdcXHUwM0I2JyxcbiAgICAnemZyJzogJ1xcdUQ4MzVcXHVERDM3JyxcbiAgICAnemhjeSc6ICdcXHUwNDM2JyxcbiAgICAnemlncmFycic6ICdcXHUyMUREJyxcbiAgICAnem9wZic6ICdcXHVEODM1XFx1REQ2QicsXG4gICAgJ3pzY3InOiAnXFx1RDgzNVxcdURDQ0YnLFxuICAgICd6d2onOiAnXFx1MjAwRCcsXG4gICAgJ3p3bmonOiAnXFx1MjAwQydcbn07XG4vLyBUaGUgJm5nc3A7IHBzZXVkby1lbnRpdHkgaXMgZGVub3RpbmcgYSBzcGFjZS4gc2VlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RhcnQtbGFuZy9hbmd1bGFyL2Jsb2IvMGJiNjExMzg3ZDI5ZDY1YjVhZjdmOWQyNTE1YWI1NzFmZDNmYmVlNC9fdGVzdHMvdGVzdC9jb21waWxlci9wcmVzZXJ2ZV93aGl0ZXNwYWNlX3Rlc3QuZGFydFxuY29uc3QgTkdTUF9VTklDT0RFID0gJ1xcdUU1MDAnO1xuTkFNRURfRU5USVRJRVNbJ25nc3AnXSA9IE5HU1BfVU5JQ09ERTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBUb2tlbkVycm9yIGV4dGVuZHMgUGFyc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JNc2csIHRva2VuVHlwZSwgc3Bhbikge1xuICAgICAgICBzdXBlcihzcGFuLCBlcnJvck1zZyk7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgIH1cbn1cbmNsYXNzIFRva2VuaXplUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMsIGVycm9ycywgbm9uTm9ybWFsaXplZEljdUV4cHJlc3Npb25zKSB7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5ub25Ob3JtYWxpemVkSWN1RXhwcmVzc2lvbnMgPSBub25Ob3JtYWxpemVkSWN1RXhwcmVzc2lvbnM7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCB1cmwsIGdldFRhZ0RlZmluaXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRva2VuaXplciA9IG5ldyBfVG9rZW5pemVyKG5ldyBQYXJzZVNvdXJjZUZpbGUoc291cmNlLCB1cmwpLCBnZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICB0b2tlbml6ZXIudG9rZW5pemUoKTtcbiAgICByZXR1cm4gbmV3IFRva2VuaXplUmVzdWx0KG1lcmdlVGV4dFRva2Vucyh0b2tlbml6ZXIudG9rZW5zKSwgdG9rZW5pemVyLmVycm9ycywgdG9rZW5pemVyLm5vbk5vcm1hbGl6ZWRJY3VFeHByZXNzaW9ucyk7XG59XG5jb25zdCBfQ1JfT1JfQ1JMRl9SRUdFWFAgPSAvXFxyXFxuPy9nO1xuZnVuY3Rpb24gX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyhjaGFyQ29kZSkge1xuICAgIGNvbnN0IGNoYXIgPSBjaGFyQ29kZSA9PT0gJEVPRiA/ICdFT0YnIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgcmV0dXJuIGBVbmV4cGVjdGVkIGNoYXJhY3RlciBcIiR7Y2hhcn1cImA7XG59XG5mdW5jdGlvbiBfdW5rbm93bkVudGl0eUVycm9yTXNnKGVudGl0eVNyYykge1xuICAgIHJldHVybiBgVW5rbm93biBlbnRpdHkgXCIke2VudGl0eVNyY31cIiAtIHVzZSB0aGUgXCImIzxkZWNpbWFsPjtcIiBvciAgXCImI3g8aGV4PjtcIiBzeW50YXhgO1xufVxuZnVuY3Rpb24gX3VucGFyc2FibGVFbnRpdHlFcnJvck1zZyh0eXBlLCBlbnRpdHlTdHIpIHtcbiAgICByZXR1cm4gYFVuYWJsZSB0byBwYXJzZSBlbnRpdHkgXCIke2VudGl0eVN0cn1cIiAtICR7dHlwZX0gY2hhcmFjdGVyIHJlZmVyZW5jZSBlbnRpdGllcyBtdXN0IGVuZCB3aXRoIFwiO1wiYDtcbn1cbnZhciBDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlKSB7XG4gICAgQ2hhcmFjdGVyUmVmZXJlbmNlVHlwZVtcIkhFWFwiXSA9IFwiaGV4YWRlY2ltYWxcIjtcbiAgICBDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlW1wiREVDXCJdID0gXCJkZWNpbWFsXCI7XG59KShDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlIHx8IChDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlID0ge30pKTtcbmNsYXNzIF9Db250cm9sRmxvd0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxufVxuLy8gU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjd3JpdGluZy1odG1sLWRvY3VtZW50c1xuY2xhc3MgX1Rva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIF9maWxlIFRoZSBodG1sIHNvdXJjZSBmaWxlIGJlaW5nIHRva2VuaXplZC5cbiAgICAgKiBAcGFyYW0gX2dldFRhZ0RlZmluaXRpb24gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0cmlldmUgYSB0YWcgZGVmaW5pdGlvbiBmb3IgYSBnaXZlbiB0YWcgbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9mIHRoZSB0b2tlbml6YXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2ZpbGUsIF9nZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2dldFRhZ0RlZmluaXRpb24gPSBfZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLm5vbk5vcm1hbGl6ZWRJY3VFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl90b2tlbml6ZUljdSA9IG9wdGlvbnMudG9rZW5pemVFeHBhbnNpb25Gb3JtcyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbkNvbmZpZyB8fCBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgICAgICB0aGlzLl9sZWFkaW5nVHJpdmlhQ29kZVBvaW50cyA9XG4gICAgICAgICAgICBvcHRpb25zLmxlYWRpbmdUcml2aWFDaGFycyAmJiBvcHRpb25zLmxlYWRpbmdUcml2aWFDaGFycy5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApIHx8IDApO1xuICAgICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMucmFuZ2UgfHwgeyBlbmRQb3M6IF9maWxlLmNvbnRlbnQubGVuZ3RoLCBzdGFydFBvczogMCwgc3RhcnRMaW5lOiAwLCBzdGFydENvbDogMCB9O1xuICAgICAgICB0aGlzLl9jdXJzb3IgPSBvcHRpb25zLmVzY2FwZWRTdHJpbmcgPyBuZXcgRXNjYXBlZENoYXJhY3RlckN1cnNvcihfZmlsZSwgcmFuZ2UpIDpcbiAgICAgICAgICAgIG5ldyBQbGFpbkNoYXJhY3RlckN1cnNvcihfZmlsZSwgcmFuZ2UpO1xuICAgICAgICB0aGlzLl9wcmVzZXJ2ZUxpbmVFbmRpbmdzID0gb3B0aW9ucy5wcmVzZXJ2ZUxpbmVFbmRpbmdzIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLl9lc2NhcGVkU3RyaW5nID0gb3B0aW9ucy5lc2NhcGVkU3RyaW5nIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLl9pMThuTm9ybWFsaXplTGluZUVuZGluZ3NJbklDVXMgPSBvcHRpb25zLmkxOG5Ob3JtYWxpemVMaW5lRW5kaW5nc0luSUNVcyB8fCBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMoY29udGVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJlc2VydmVMaW5lRW5kaW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgICAgICAgLy8gSW4gb3JkZXIgdG8ga2VlcCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSwgd2UgY2FuIG5vdFxuICAgICAgICAvLyBwcmUtcHJvY2VzcyBpdC5cbiAgICAgICAgLy8gSW5zdGVhZCBDUnMgYXJlIHByb2Nlc3NlZCByaWdodCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgdG9rZW5zLlxuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKF9DUl9PUl9DUkxGX1JFR0VYUCwgJ1xcbicpO1xuICAgIH1cbiAgICB0b2tlbml6ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRFT0YpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExUKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRCQU5HKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNkYXRhKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTUlOVVMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZURvY1R5cGUoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnQ2xvc2Uoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW4oc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fdG9rZW5pemVJY3UgJiYgdGhpcy5fdG9rZW5pemVFeHBhbnNpb25Gb3JtKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIChwb3NzaWJseSBpbnRlcnBvbGF0ZWQpIHRleHQgdGhlIGVuZCBvZiB0aGUgdGV4dCBpcyBnaXZlbiBieSBgaXNUZXh0RW5kKClgLCB3aGlsZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJlbWF0dXJlIGVuZCBvZiBhbiBpbnRlcnBvbGF0aW9uIGlzIGdpdmVuIGJ5IHRoZSBzdGFydCBvZiBhIG5ldyBIVE1MIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVXaXRoSW50ZXJwb2xhdGlvbig1IC8qIFRFWFQgKi8sIDggLyogSU5URVJQT0xBVElPTiAqLywgKCkgPT4gdGhpcy5faXNUZXh0RW5kKCksICgpID0+IHRoaXMuX2lzVGFnU3RhcnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMjQgLyogRU9GICovKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB3aGV0aGVyIGFuIElDVSB0b2tlbiBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3Rva2VuaXplRXhwYW5zaW9uRm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFeHBhbnNpb25Gb3JtU3RhcnQoKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXhwYW5zaW9uQ2FzZVN0YXJ0KHRoaXMuX2N1cnNvci5wZWVrKCkpICYmIHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkUkJSQUNFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfYmVnaW5Ub2tlbih0eXBlLCBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBfZW5kVG9rZW4ocGFydHMsIGVuZCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFRva2VuU3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb2tlbkVycm9yKCdQcm9ncmFtbWluZyBlcnJvciAtIGF0dGVtcHRlZCB0byBlbmQgYSB0b2tlbiB3aGVuIHRoZXJlIHdhcyBubyBzdGFydCB0byB0aGUgdG9rZW4nLCB0aGlzLl9jdXJyZW50VG9rZW5UeXBlLCB0aGlzLl9jdXJzb3IuZ2V0U3BhbihlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFRva2VuVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRva2VuRXJyb3IoJ1Byb2dyYW1taW5nIGVycm9yIC0gYXR0ZW1wdGVkIHRvIGVuZCBhIHRva2VuIHdoaWNoIGhhcyBubyB0b2tlbiB0eXBlJywgbnVsbCwgdGhpcy5fY3Vyc29yLmdldFNwYW4odGhpcy5fY3VycmVudFRva2VuU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IChlbmQgIT09IG51bGwgJiYgZW5kICE9PSB2b2lkIDAgPyBlbmQgOiB0aGlzLl9jdXJzb3IpLmdldFNwYW4odGhpcy5fY3VycmVudFRva2VuU3RhcnQsIHRoaXMuX2xlYWRpbmdUcml2aWFDb2RlUG9pbnRzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgX2NyZWF0ZUVycm9yKG1zZywgc3Bhbikge1xuICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgbXNnICs9IGAgKERvIHlvdSBoYXZlIGFuIHVuZXNjYXBlZCBcIntcIiBpbiB5b3VyIHRlbXBsYXRlPyBVc2UgXCJ7eyAneycgfX1cIikgdG8gZXNjYXBlIGl0LilgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFRva2VuRXJyb3IobXNnLCB0aGlzLl9jdXJyZW50VG9rZW5UeXBlLCBzcGFuKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29udHJvbEZsb3dFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDdXJzb3JFcnJvcikge1xuICAgICAgICAgICAgZSA9IHRoaXMuX2NyZWF0ZUVycm9yKGUubXNnLCB0aGlzLl9jdXJzb3IuZ2V0U3BhbihlLmN1cnNvcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hdHRlbXB0Q2hhckNvZGUoY2hhckNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfYXR0ZW1wdENoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmIChjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUodGhpcy5fY3Vyc29yLnBlZWsoKSwgY2hhckNvZGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfcmVxdWlyZUNoYXJDb2RlKGNoYXJDb2RlKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9jdXJzb3IucGVlaygpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4obG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXR0ZW1wdFN0cihjaGFycykge1xuICAgICAgICBjb25zdCBsZW4gPSBjaGFycy5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IuY2hhcnNMZWZ0KCkgPCBsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbml0aWFsUG9zaXRpb24gPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhdHRlbXB0aW5nIHRvIHBhcnNlIHRoZSBzdHJpbmcgZmFpbHMsIHdlIHdhbnQgdG8gcmVzZXQgdGhlIHBhcnNlclxuICAgICAgICAgICAgICAgIC8vIHRvIHdoZXJlIGl0IHdhcyBiZWZvcmUgdGhlIGF0dGVtcHRcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBpbml0aWFsUG9zaXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZShjaGFycykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjaGFycy5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX3JlcXVpcmVTdHIoY2hhcnMpIHtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0U3RyKGNoYXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9jdXJzb3IucGVlaygpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4obG9jYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXR0ZW1wdENoYXJDb2RlVW50aWxGbihwcmVkaWNhdGUpIHtcbiAgICAgICAgd2hpbGUgKCFwcmVkaWNhdGUodGhpcy5fY3Vyc29yLnBlZWsoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4ocHJlZGljYXRlLCBsZW4pIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihwcmVkaWNhdGUpO1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLmRpZmYoc3RhcnQpIDwgbGVuKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKHRoaXMuX2N1cnNvci5wZWVrKCkpLCB0aGlzLl9jdXJzb3IuZ2V0U3BhbihzdGFydCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hdHRlbXB0VW50aWxDaGFyKGNoYXIpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlYWRDaGFyKCkge1xuICAgICAgICAvLyBEb24ndCByZWx5IHVwb24gcmVhZGluZyBkaXJlY3RseSBmcm9tIGBfaW5wdXRgIGFzIHRoZSBhY3R1YWwgY2hhciB2YWx1ZVxuICAgICAgICAvLyBtYXkgaGF2ZSBiZWVuIGdlbmVyYXRlZCBmcm9tIGFuIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgY29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMuX2N1cnNvci5wZWVrKCkpO1xuICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gY2hhcjtcbiAgICB9XG4gICAgX2NvbnN1bWVFbnRpdHkodGV4dFRva2VuVHlwZSkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDkgLyogRU5DT0RFRF9FTlRJVFkgKi8pO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRIQVNIKSkge1xuICAgICAgICAgICAgY29uc3QgaXNIZXggPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJHgpIHx8IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkWCk7XG4gICAgICAgICAgICBjb25zdCBjb2RlU3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNEaWdpdEVudGl0eUVuZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSAhPSAkU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBjdXJzb3IgdG8gaW5jbHVkZSB0aGUgcGVla2VkIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIHByb3ZpZGVkIHRvIHRoZSBlcnJvclxuICAgICAgICAgICAgICAgIC8vIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRpdHlUeXBlID0gaXNIZXggPyBDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlLkhFWCA6IENoYXJhY3RlclJlZmVyZW5jZVR5cGUuREVDO1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bnBhcnNhYmxlRW50aXR5RXJyb3JNc2coZW50aXR5VHlwZSwgdGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyTnVtID0gdGhpcy5fY3Vyc29yLmdldENoYXJzKGNvZGVTdGFydCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ck51bSwgaXNIZXggPyAxNiA6IDEwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSksIHRoaXMuX2N1cnNvci5nZXRDaGFycyhzdGFydCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2codGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmFtZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTmFtZWRFbnRpdHlFbmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT0gJFNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgIC8vIE5vIHNlbWljb2xvbiB3YXMgZm91bmQgc28gYWJvcnQgdGhlIGVuY29kZWQgZW50aXR5IHRva2VuIHRoYXQgd2FzIGluIHByb2dyZXNzLCBhbmQgdHJlYXRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGFzIGEgdGV4dCB0b2tlblxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odGV4dFRva2VuVHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG5hbWVTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbJyYnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fY3Vyc29yLmdldENoYXJzKG5hbWVTdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gTkFNRURfRU5USVRJRVNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2cobmFtZSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtjaGFyLCBgJiR7bmFtZX07YF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jb25zdW1lUmF3VGV4dChjb25zdW1lRW50aXRpZXMsIGVuZE1hcmtlclByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKGNvbnN1bWVFbnRpdGllcyA/IDYgLyogRVNDQVBBQkxFX1JBV19URVhUICovIDogNyAvKiBSQVdfVEVYVCAqLyk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdDbG9zZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBmb3VuZEVuZE1hcmtlciA9IGVuZE1hcmtlclByZWRpY2F0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gdGFnQ2xvc2VTdGFydDtcbiAgICAgICAgICAgIGlmIChmb3VuZEVuZE1hcmtlcikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnN1bWVFbnRpdGllcyAmJiB0aGlzLl9jdXJzb3IucGVlaygpID09PSAkQU1QRVJTQU5EKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRW50aXR5KDYgLyogRVNDQVBBQkxFX1JBV19URVhUICovKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKDYgLyogRVNDQVBBQkxFX1JBV19URVhUICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgfVxuICAgIF9jb25zdW1lQ29tbWVudChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDEwIC8qIENPTU1FTlRfU1RBUlQgKi8sIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRNSU5VUyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdGhpcy5fY29uc3VtZVJhd1RleHQoZmFsc2UsICgpID0+IHRoaXMuX2F0dGVtcHRTdHIoJy0tPicpKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxMSAvKiBDT01NRU5UX0VORCAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVTdHIoJy0tPicpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfVxuICAgIF9jb25zdW1lQ2RhdGEoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxMiAvKiBDREFUQV9TVEFSVCAqLywgc3RhcnQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCdDREFUQVsnKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgKCkgPT4gdGhpcy5fYXR0ZW1wdFN0cignXV0+JykpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDEzIC8qIENEQVRBX0VORCAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVTdHIoJ11dPicpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfVxuICAgIF9jb25zdW1lRG9jVHlwZShzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDE4IC8qIERPQ19UWVBFICovLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKCRHVCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoY29udGVudFN0YXJ0KTtcbiAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbnRlbnRdKTtcbiAgICB9XG4gICAgX2NvbnN1bWVQcmVmaXhBbmROYW1lKCkge1xuICAgICAgICBjb25zdCBuYW1lT3JQcmVmaXhTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkQ09MT04gJiYgIWlzUHJlZml4RW5kKHRoaXMuX2N1cnNvci5wZWVrKCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lU3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkQ09MT04pIHtcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyhuYW1lT3JQcmVmaXhTdGFydCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgbmFtZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lU3RhcnQgPSBuYW1lT3JQcmVmaXhTdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuKGlzTmFtZUVuZCwgcHJlZml4ID09PSAnJyA/IDAgOiAxKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyhuYW1lU3RhcnQpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgfVxuICAgIF9jb25zdW1lVGFnT3BlbihzdGFydCkge1xuICAgICAgICBsZXQgdGFnTmFtZTtcbiAgICAgICAgbGV0IHByZWZpeDtcbiAgICAgICAgbGV0IG9wZW5UYWdUb2tlbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghaXNBc2NpaUxldHRlcih0aGlzLl9jdXJzb3IucGVlaygpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuVGFnVG9rZW4gPSB0aGlzLl9jb25zdW1lVGFnT3BlblN0YXJ0KHN0YXJ0KTtcbiAgICAgICAgICAgIHByZWZpeCA9IG9wZW5UYWdUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgIHRhZ05hbWUgPSBvcGVuVGFnVG9rZW4ucGFydHNbMV07XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fY3Vyc29yLnBlZWsoKSAhPT0gJFNMQVNIICYmIHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRHVCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRMVCAmJiB0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkRU9GKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZU5hbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkRVEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlblRhZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGVycm9yZWQgYmVmb3JlIHdlIGNvdWxkIGNsb3NlIHRoZSBvcGVuaW5nIHRhZywgc28gaXQgaXMgaW5jb21wbGV0ZS5cbiAgICAgICAgICAgICAgICAgICAgb3BlblRhZ1Rva2VuLnR5cGUgPSA0IC8qIElOQ09NUExFVEVfVEFHX09QRU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBzdGFydCB0YWcgaXMgaW52YWxpZCwgYXNzdW1lIHdlIHdhbnQgYSBcIjxcIiBhcyB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrIHRvIGJhY2sgdGV4dCB0b2tlbnMgYXJlIG1lcmdlZCBhdCB0aGUgZW5kLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKDUgLyogVEVYVCAqLywgc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbJzwnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudFRva2VuVHlwZSA9IHRoaXMuX2dldFRhZ0RlZmluaXRpb24odGFnTmFtZSkuZ2V0Q29udGVudFR5cGUocHJlZml4KTtcbiAgICAgICAgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShwcmVmaXgsIHRhZ05hbWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50VG9rZW5UeXBlID09PSBUYWdDb250ZW50VHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKHByZWZpeCwgdGFnTmFtZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKHByZWZpeCwgdGFnTmFtZSwgY29uc3VtZUVudGl0aWVzKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0KGNvbnN1bWVFbnRpdGllcywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExUKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdFN0ckNhc2VJbnNlbnNpdGl2ZSh0YWdOYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRHVCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDMgLyogVEFHX0NMT1NFICovKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihjb2RlID0+IGNvZGUgPT09ICRHVCwgMyk7XG4gICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7IC8vIENvbnN1bWUgdGhlIGA+YFxuICAgICAgICB0aGlzLl9lbmRUb2tlbihbcHJlZml4LCB0YWdOYW1lXSk7XG4gICAgfVxuICAgIF9jb25zdW1lVGFnT3BlblN0YXJ0KHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMCAvKiBUQUdfT1BFTl9TVEFSVCAqLywgc3RhcnQpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmRUb2tlbihwYXJ0cyk7XG4gICAgfVxuICAgIF9jb25zdW1lQXR0cmlidXRlTmFtZSgpIHtcbiAgICAgICAgY29uc3QgYXR0ck5hbWVTdGFydCA9IHRoaXMuX2N1cnNvci5wZWVrKCk7XG4gICAgICAgIGlmIChhdHRyTmFtZVN0YXJ0ID09PSAkU1EgfHwgYXR0ck5hbWVTdGFydCA9PT0gJERRKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLl9jcmVhdGVFcnJvcihfdW5leHBlY3RlZENoYXJhY3RlckVycm9yTXNnKGF0dHJOYW1lU3RhcnQpLCB0aGlzLl9jdXJzb3IuZ2V0U3BhbigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDE0IC8qIEFUVFJfTkFNRSAqLyk7XG4gICAgICAgIGNvbnN0IHByZWZpeEFuZE5hbWUgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihwcmVmaXhBbmROYW1lKTtcbiAgICB9XG4gICAgX2NvbnN1bWVBdHRyaWJ1dGVWYWx1ZSgpIHtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJFNRIHx8IHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICREUSkge1xuICAgICAgICAgICAgY29uc3QgcXVvdGVDaGFyID0gdGhpcy5fY3Vyc29yLnBlZWsoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVRdW90ZShxdW90ZUNoYXIpO1xuICAgICAgICAgICAgLy8gSW4gYW4gYXR0cmlidXRlIHRoZW4gZW5kIG9mIHRoZSBhdHRyaWJ1dGUgdmFsdWUgYW5kIHRoZSBwcmVtYXR1cmUgZW5kIHRvIGFuIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIC8vIGFyZSBib3RoIHRyaWdnZXJlZCBieSB0aGUgYHF1b3RlQ2hhcmAuXG4gICAgICAgICAgICBjb25zdCBlbmRQcmVkaWNhdGUgPSAoKSA9PiB0aGlzLl9jdXJzb3IucGVlaygpID09PSBxdW90ZUNoYXI7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lV2l0aEludGVycG9sYXRpb24oMTYgLyogQVRUUl9WQUxVRV9URVhUICovLCAxNyAvKiBBVFRSX1ZBTFVFX0lOVEVSUE9MQVRJT04gKi8sIGVuZFByZWRpY2F0ZSwgZW5kUHJlZGljYXRlKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVRdW90ZShxdW90ZUNoYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZW5kUHJlZGljYXRlID0gKCkgPT4gaXNOYW1lRW5kKHRoaXMuX2N1cnNvci5wZWVrKCkpO1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVdpdGhJbnRlcnBvbGF0aW9uKDE2IC8qIEFUVFJfVkFMVUVfVEVYVCAqLywgMTcgLyogQVRUUl9WQUxVRV9JTlRFUlBPTEFUSU9OICovLCBlbmRQcmVkaWNhdGUsIGVuZFByZWRpY2F0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnN1bWVRdW90ZShxdW90ZUNoYXIpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxNSAvKiBBVFRSX1FVT1RFICovKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKHF1b3RlQ2hhcik7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtTdHJpbmcuZnJvbUNvZGVQb2ludChxdW90ZUNoYXIpXSk7XG4gICAgfVxuICAgIF9jb25zdW1lVGFnT3BlbkVuZCgpIHtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkgPyAyIC8qIFRBR19PUEVOX0VORF9WT0lEICovIDogMSAvKiBUQUdfT1BFTl9FTkQgKi87XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odG9rZW5UeXBlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9XG4gICAgX2NvbnN1bWVUYWdDbG9zZShzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDMgLyogVEFHX0NMT1NFICovLCBzdGFydCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgY29uc3QgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH1cbiAgICBfY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxOSAvKiBFWFBBTlNJT05fRk9STV9TVEFSVCAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaCgxOSAvKiBFWFBBTlNJT05fRk9STV9TVEFSVCAqLyk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oNyAvKiBSQVdfVEVYVCAqLyk7XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkQ29uZGl0aW9uID0gdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhjb25kaXRpb24pO1xuICAgICAgICBpZiAodGhpcy5faTE4bk5vcm1hbGl6ZUxpbmVFbmRpbmdzSW5JQ1VzKSB7XG4gICAgICAgICAgICAvLyBXZSBleHBsaWNpdGx5IHdhbnQgdG8gbm9ybWFsaXplIGxpbmUgZW5kaW5ncyBmb3IgdGhpcyB0ZXh0LlxuICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW25vcm1hbGl6ZWRDb25kaXRpb25dKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBub3Qgbm9ybWFsaXppbmcgbGluZSBlbmRpbmdzLlxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uVG9rZW4gPSB0aGlzLl9lbmRUb2tlbihbY29uZGl0aW9uXSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZENvbmRpdGlvbiAhPT0gY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub25Ob3JtYWxpemVkSWN1RXhwcmVzc2lvbnMucHVzaChjb25kaXRpb25Ub2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRDT01NQSk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbig3IC8qIFJBV19URVhUICovKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdHlwZV0pO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgIH1cbiAgICBfY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigyMCAvKiBFWFBBTlNJT05fQ0FTRV9WQUxVRSAqLyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fcmVhZFVudGlsKCRMQlJBQ0UpLnRyaW0oKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3ZhbHVlXSk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigyMSAvKiBFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgKi8pO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJExCUkFDRSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaCgyMSAvKiBFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgKi8pO1xuICAgIH1cbiAgICBfY29uc3VtZUV4cGFuc2lvbkNhc2VFbmQoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMjIgLyogRVhQQU5TSU9OX0NBU0VfRVhQX0VORCAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDIzIC8qIEVYUEFOU0lPTl9GT1JNX0VORCAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN1bWUgYSBzdHJpbmcgdGhhdCBtYXkgY29udGFpbiBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb25zLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHRva2VuIGNvbnN1bWVkIHdpbGwgYmUgb2YgYHRva2VuVHlwZWAgYW5kIHRoZW4gdGhlcmUgd2lsbCBiZSBhbHRlcm5hdGluZ1xuICAgICAqIGBpbnRlcnBvbGF0aW9uVG9rZW5UeXBlYCBhbmQgYHRva2VuVHlwZWAgdG9rZW5zIHVudGlsIHRoZSBgZW5kUHJlZGljYXRlKClgIHJldHVybnMgdHJ1ZS5cbiAgICAgKlxuICAgICAqIElmIGFuIGludGVycG9sYXRpb24gdG9rZW4gZW5kcyBwcmVtYXR1cmVseSBpdCB3aWxsIGhhdmUgbm8gZW5kIG1hcmtlciBpbiBpdHMgYHBhcnRzYCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0VG9rZW5UeXBlIHRoZSBraW5kIG9mIHRva2VucyB0byBpbnRlcmxlYXZlIGFyb3VuZCBpbnRlcnBvbGF0aW9uIHRva2Vucy5cbiAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGlvblRva2VuVHlwZSB0aGUga2luZCBvZiB0b2tlbnMgdGhhdCBjb250YWluIGludGVycG9sYXRpb24uXG4gICAgICogQHBhcmFtIGVuZFByZWRpY2F0ZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gd2Ugc2hvdWxkIHN0b3AgY29uc3VtaW5nLlxuICAgICAqIEBwYXJhbSBlbmRJbnRlcnBvbGF0aW9uIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgYSBwcmVtYXR1cmUgZW5kIHRvIGFuXG4gICAgICogICAgIGludGVycG9sYXRpb24gZXhwcmVzc2lvbiAtIGkuZS4gYmVmb3JlIHdlIGdldCB0byB0aGUgbm9ybWFsIGludGVycG9sYXRpb24gY2xvc2luZyBtYXJrZXIuXG4gICAgICovXG4gICAgX2NvbnN1bWVXaXRoSW50ZXJwb2xhdGlvbih0ZXh0VG9rZW5UeXBlLCBpbnRlcnBvbGF0aW9uVG9rZW5UeXBlLCBlbmRQcmVkaWNhdGUsIGVuZEludGVycG9sYXRpb24pIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbih0ZXh0VG9rZW5UeXBlKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFlbmRQcmVkaWNhdGUoKSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgJiYgdGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0sIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvblRva2VuVHlwZSwgY3VycmVudCwgZW5kSW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbih0ZXh0VG9rZW5UeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRBTVBFUlNBTkQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldKTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFbnRpdHkodGV4dFRva2VuVHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbih0ZXh0VG9rZW5UeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCBhbiBpbnRlcnBvbGF0aW9uIHdhcyBzdGFydGVkIGJ1dCBub3QgZW5kZWQgaW5zaWRlIHRoaXMgdGV4dCB0b2tlbi5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgcmVzZXQgdGhlIHN0YXRlIG9mIHRoZSBsZXhlciBjb3JyZWN0bHkuXG4gICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZSBhIGJsb2NrIG9mIHRleHQgdGhhdCBoYXMgYmVlbiBpbnRlcnByZXRlZCBhcyBhbiBBbmd1bGFyIGludGVycG9sYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGlvblRva2VuVHlwZSB0aGUgdHlwZSBvZiB0aGUgaW50ZXJwb2xhdGlvbiB0b2tlbiB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0gaW50ZXJwb2xhdGlvblN0YXJ0IGEgY3Vyc29yIHRoYXQgcG9pbnRzIHRvIHRoZSBzdGFydCBvZiB0aGlzIGludGVycG9sYXRpb24uXG4gICAgICogQHBhcmFtIHByZW1hdHVyZUVuZFByZWRpY2F0ZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHJldHVybiB0cnVlIGlmIHRoZSBuZXh0IGNoYXJhY3RlcnMgaW5kaWNhdGVcbiAgICAgKiAgICAgYW4gZW5kIHRvIHRoZSBpbnRlcnBvbGF0aW9uIGJlZm9yZSBpdHMgbm9ybWFsIGNsb3NpbmcgbWFya2VyLlxuICAgICAqL1xuICAgIF9jb25zdW1lSW50ZXJwb2xhdGlvbihpbnRlcnBvbGF0aW9uVG9rZW5UeXBlLCBpbnRlcnBvbGF0aW9uU3RhcnQsIHByZW1hdHVyZUVuZFByZWRpY2F0ZSkge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKGludGVycG9sYXRpb25Ub2tlblR5cGUsIGludGVycG9sYXRpb25TdGFydCk7XG4gICAgICAgIHBhcnRzLnB1c2godGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGVuZCBvZiB0aGUgaW50ZXJwb2xhdGlvbiwgaWdub3JpbmcgY29udGVudCBpbnNpZGUgcXVvdGVzLlxuICAgICAgICBjb25zdCBleHByZXNzaW9uU3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgbGV0IGluUXVvdGUgPSBudWxsO1xuICAgICAgICBsZXQgaW5Db21tZW50ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkRU9GICYmXG4gICAgICAgICAgICAocHJlbWF0dXJlRW5kUHJlZGljYXRlID09PSBudWxsIHx8ICFwcmVtYXR1cmVFbmRQcmVkaWNhdGUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1RhZ1N0YXJ0KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc3RhcnRpbmcgd2hhdCBsb29rcyBsaWtlIGFuIEhUTUwgZWxlbWVudCBpbiB0aGUgbWlkZGxlIG9mIHRoaXMgaW50ZXJwb2xhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgY3Vyc29yIHRvIGJlZm9yZSB0aGUgYDxgIGNoYXJhY3RlciBhbmQgZW5kIHRoZSBpbnRlcnBvbGF0aW9uIHRva2VuLlxuICAgICAgICAgICAgICAgIC8vIChUaGlzIGlzIGFjdHVhbGx5IHdyb25nIGJ1dCBoZXJlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KS5cbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fZ2V0UHJvY2Vzc2VkQ2hhcnMoZXhwcmVzc2lvblN0YXJ0LCBjdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpblF1b3RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBub3QgaW4gYSBzdHJpbmcsIGFuZCB3ZSBoaXQgdGhlIGVuZCBpbnRlcnBvbGF0aW9uIG1hcmtlclxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2dldFByb2Nlc3NlZENoYXJzKGV4cHJlc3Npb25TdGFydCwgY3VycmVudCkpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRTdHIoJy8vJykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25jZSB3ZSBhcmUgaW4gYSBjb21tZW50IHdlIGlnbm9yZSBhbnkgcXVvdGVzXG4gICAgICAgICAgICAgICAgICAgIGluQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhciA9IHRoaXMuX2N1cnNvci5wZWVrKCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICRCQUNLU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBuZXh0IGNoYXJhY3RlciBiZWNhdXNlIGl0IHdhcyBlc2NhcGVkLlxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSBpblF1b3RlKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhpdGluZyB0aGUgY3VycmVudCBxdW90ZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgaW5RdW90ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaW5Db21tZW50ICYmIGluUXVvdGUgPT09IG51bGwgJiYgaXNRdW90ZShjaGFyKSkge1xuICAgICAgICAgICAgICAgIC8vIEVudGVyaW5nIGEgbmV3IHF1b3RlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICBpblF1b3RlID0gY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoaXQgRU9GIHdpdGhvdXQgZmluZGluZyBhIGNsb3NpbmcgaW50ZXJwb2xhdGlvbiBtYXJrZXJcbiAgICAgICAgcGFydHMucHVzaCh0aGlzLl9nZXRQcm9jZXNzZWRDaGFycyhleHByZXNzaW9uU3RhcnQsIHRoaXMuX2N1cnNvcikpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihwYXJ0cyk7XG4gICAgfVxuICAgIF9nZXRQcm9jZXNzZWRDaGFycyhzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKGVuZC5nZXRDaGFycyhzdGFydCkpO1xuICAgIH1cbiAgICBfaXNUZXh0RW5kKCkge1xuICAgICAgICBpZiAodGhpcy5faXNUYWdTdGFydCgpIHx8IHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRFT0YpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90b2tlbml6ZUljdSAmJiAhdGhpcy5faW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0V4cGFuc2lvbkZvcm1TdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgb2YgYW4gZXhwYW5zaW9uIGZvcm1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkUkJSQUNFICYmIHRoaXMuX2lzSW5FeHBhbnNpb25DYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBlbmQgb2YgYW5kIGV4cGFuc2lvbiBjYXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgY3Vyc29yIGlzIHBvaW50aW5nIHRvIHRoZSBzdGFydCBvZiBhIHRhZ1xuICAgICAqIChvcGVuaW5nL2Nsb3NpbmcvY29tbWVudHMvY2RhdGEvZXRjKS5cbiAgICAgKi9cbiAgICBfaXNUYWdTdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRMVCkge1xuICAgICAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgYDxgIGZvbGxvd2VkIGJ5IHdoaXRlc3BhY2UgaXMgbm90IHRoZSBzdGFydCBvZiBhbiBIVE1MIGVsZW1lbnQuXG4gICAgICAgICAgICBjb25zdCB0bXAgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRtcC5hZHZhbmNlKCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYWxwaGFiZXRpYywgISBub3IgLyB0aGVuIGl0IGlzIGEgdGFnIHN0YXJ0XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gdG1wLnBlZWsoKTtcbiAgICAgICAgICAgIGlmICgoJGEgPD0gY29kZSAmJiBjb2RlIDw9ICR6KSB8fCAoJEEgPD0gY29kZSAmJiBjb2RlIDw9ICRaKSB8fFxuICAgICAgICAgICAgICAgIGNvZGUgPT09ICRTTEFTSCB8fCBjb2RlID09PSAkQkFORykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX3JlYWRVbnRpbChjaGFyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoY2hhcik7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoc3RhcnQpO1xuICAgIH1cbiAgICBfaXNJbkV4cGFuc2lvbkNhc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrW3RoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggLSAxXSA9PT1cbiAgICAgICAgICAgICAgICAyMSAvKiBFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgKi87XG4gICAgfVxuICAgIF9pc0luRXhwYW5zaW9uRm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIDE5IC8qIEVYUEFOU0lPTl9GT1JNX1NUQVJUICovO1xuICAgIH1cbiAgICBpc0V4cGFuc2lvbkZvcm1TdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRMQlJBQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW50ZXJwb2xhdGlvbiA9IHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiAhaXNJbnRlcnBvbGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTm90V2hpdGVzcGFjZShjb2RlKSB7XG4gICAgcmV0dXJuICFpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEVPRjtcbn1cbmZ1bmN0aW9uIGlzTmFtZUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGlzV2hpdGVzcGFjZShjb2RlKSB8fCBjb2RlID09PSAkR1QgfHwgY29kZSA9PT0gJExUIHx8XG4gICAgICAgIGNvZGUgPT09ICRTTEFTSCB8fCBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRFUSB8fFxuICAgICAgICBjb2RlID09PSAkRU9GO1xufVxuZnVuY3Rpb24gaXNQcmVmaXhFbmQoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA8ICRhIHx8ICR6IDwgY29kZSkgJiYgKGNvZGUgPCAkQSB8fCAkWiA8IGNvZGUpICYmXG4gICAgICAgIChjb2RlIDwgJDAgfHwgY29kZSA+ICQ5KTtcbn1cbmZ1bmN0aW9uIGlzRGlnaXRFbnRpdHlFbmQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT09ICRFT0YgfHwgIWlzQXNjaWlIZXhEaWdpdChjb2RlKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZWRFbnRpdHlFbmQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT09ICRFT0YgfHwgIWlzQXNjaWlMZXR0ZXIoY29kZSk7XG59XG5mdW5jdGlvbiBpc0V4cGFuc2lvbkNhc2VTdGFydChwZWVrKSB7XG4gICAgcmV0dXJuIHBlZWsgIT09ICRSQlJBQ0U7XG59XG5mdW5jdGlvbiBjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY29kZTEsIGNvZGUyKSB7XG4gICAgcmV0dXJuIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTEpID09PSB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUyKTtcbn1cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogPyBjb2RlIC0gJGEgKyAkQSA6IGNvZGU7XG59XG5mdW5jdGlvbiBtZXJnZVRleHRUb2tlbnMoc3JjVG9rZW5zKSB7XG4gICAgY29uc3QgZHN0VG9rZW5zID0gW107XG4gICAgbGV0IGxhc3REc3RUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyY1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHNyY1Rva2Vuc1tpXTtcbiAgICAgICAgaWYgKChsYXN0RHN0VG9rZW4gJiYgbGFzdERzdFRva2VuLnR5cGUgPT09IDUgLyogVEVYVCAqLyAmJiB0b2tlbi50eXBlID09PSA1IC8qIFRFWFQgKi8pIHx8XG4gICAgICAgICAgICAobGFzdERzdFRva2VuICYmIGxhc3REc3RUb2tlbi50eXBlID09PSAxNiAvKiBBVFRSX1ZBTFVFX1RFWFQgKi8gJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID09PSAxNiAvKiBBVFRSX1ZBTFVFX1RFWFQgKi8pKSB7XG4gICAgICAgICAgICBsYXN0RHN0VG9rZW4ucGFydHNbMF0gKz0gdG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgICBsYXN0RHN0VG9rZW4uc291cmNlU3Bhbi5lbmQgPSB0b2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3REc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgZHN0VG9rZW5zLnB1c2gobGFzdERzdFRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHN0VG9rZW5zO1xufVxuY2xhc3MgUGxhaW5DaGFyYWN0ZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpbGVPckN1cnNvciwgcmFuZ2UpIHtcbiAgICAgICAgaWYgKGZpbGVPckN1cnNvciBpbnN0YW5jZW9mIFBsYWluQ2hhcmFjdGVyQ3Vyc29yKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGUgPSBmaWxlT3JDdXJzb3IuZmlsZTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBmaWxlT3JDdXJzb3IuaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IGZpbGVPckN1cnNvci5lbmQ7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGZpbGVPckN1cnNvci5zdGF0ZTtcbiAgICAgICAgICAgIC8vIE5vdGU6IGF2b2lkIHVzaW5nIGB7Li4uZmlsZU9yQ3Vyc29yLnN0YXRlfWAgaGVyZSBhcyB0aGF0IGhhcyBhIHNldmVyZSBwZXJmb3JtYW5jZSBwZW5hbHR5LlxuICAgICAgICAgICAgLy8gSW4gRVM1IGJ1bmRsZXMgdGhlIG9iamVjdCBzcHJlYWQgb3BlcmF0b3IgaXMgdHJhbnNsYXRlZCBpbnRvIHRoZSBgX19hc3NpZ25gIGhlbHBlciwgd2hpY2hcbiAgICAgICAgICAgIC8vIGlzIG5vdCBvcHRpbWl6ZWQgYnkgVk1zIGFzIGVmZmljaWVudGx5IGFzIGEgcmF3IG9iamVjdCBsaXRlcmFsLiBTaW5jZSB0aGlzIGNvbnN0cnVjdG9yIGlzXG4gICAgICAgICAgICAvLyBjYWxsZWQgaW4gdGlnaHQgbG9vcHMsIHRoaXMgZGlmZmVyZW5jZSBtYXR0ZXJzLlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBwZWVrOiBzdGF0ZS5wZWVrLFxuICAgICAgICAgICAgICAgIG9mZnNldDogc3RhdGUub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXRlLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGF0ZS5jb2x1bW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvZ3JhbW1pbmcgZXJyb3I6IHRoZSByYW5nZSBhcmd1bWVudCBtdXN0IGJlIHByb3ZpZGVkIHdpdGggYSBmaWxlIGFyZ3VtZW50LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maWxlID0gZmlsZU9yQ3Vyc29yO1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IGZpbGVPckN1cnNvci5jb250ZW50O1xuICAgICAgICAgICAgdGhpcy5lbmQgPSByYW5nZS5lbmRQb3M7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHBlZWs6IC0xLFxuICAgICAgICAgICAgICAgIG9mZnNldDogcmFuZ2Uuc3RhcnRQb3MsXG4gICAgICAgICAgICAgICAgbGluZTogcmFuZ2Uuc3RhcnRMaW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogcmFuZ2Uuc3RhcnRDb2wsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWluQ2hhcmFjdGVyQ3Vyc29yKHRoaXMpO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wZWVrO1xuICAgIH1cbiAgICBjaGFyc0xlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZCAtIHRoaXMuc3RhdGUub2Zmc2V0O1xuICAgIH1cbiAgICBkaWZmKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLm9mZnNldCAtIG90aGVyLnN0YXRlLm9mZnNldDtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGVlayh0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAgZ2V0U3BhbihzdGFydCwgbGVhZGluZ1RyaXZpYUNvZGVQb2ludHMpIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCB8fCB0aGlzO1xuICAgICAgICBsZXQgZnVsbFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIGlmIChsZWFkaW5nVHJpdmlhQ29kZVBvaW50cykge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuZGlmZihzdGFydCkgPiAwICYmIGxlYWRpbmdUcml2aWFDb2RlUG9pbnRzLmluZGV4T2Yoc3RhcnQucGVlaygpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbFN0YXJ0ID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydExvY2F0aW9uID0gdGhpcy5sb2NhdGlvbkZyb21DdXJzb3Ioc3RhcnQpO1xuICAgICAgICBjb25zdCBlbmRMb2NhdGlvbiA9IHRoaXMubG9jYXRpb25Gcm9tQ3Vyc29yKHRoaXMpO1xuICAgICAgICBjb25zdCBmdWxsU3RhcnRMb2NhdGlvbiA9IGZ1bGxTdGFydCAhPT0gc3RhcnQgPyB0aGlzLmxvY2F0aW9uRnJvbUN1cnNvcihmdWxsU3RhcnQpIDogc3RhcnRMb2NhdGlvbjtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnRMb2NhdGlvbiwgZW5kTG9jYXRpb24sIGZ1bGxTdGFydExvY2F0aW9uKTtcbiAgICB9XG4gICAgZ2V0Q2hhcnMoc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LnN0YXRlLm9mZnNldCwgdGhpcy5zdGF0ZS5vZmZzZXQpO1xuICAgIH1cbiAgICBjaGFyQXQocG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICB9XG4gICAgYWR2YW5jZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPj0gdGhpcy5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBDdXJzb3JFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXIgXCJFT0ZcIicsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGFyID0gdGhpcy5jaGFyQXQoc3RhdGUub2Zmc2V0KTtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAkTEYpIHtcbiAgICAgICAgICAgIHN0YXRlLmxpbmUrKztcbiAgICAgICAgICAgIHN0YXRlLmNvbHVtbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzTmV3TGluZShjdXJyZW50Q2hhcikpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCsrO1xuICAgICAgICB0aGlzLnVwZGF0ZVBlZWsoc3RhdGUpO1xuICAgIH1cbiAgICB1cGRhdGVQZWVrKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnBlZWsgPSBzdGF0ZS5vZmZzZXQgPj0gdGhpcy5lbmQgPyAkRU9GIDogdGhpcy5jaGFyQXQoc3RhdGUub2Zmc2V0KTtcbiAgICB9XG4gICAgbG9jYXRpb25Gcm9tQ3Vyc29yKGN1cnNvcikge1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTG9jYXRpb24oY3Vyc29yLmZpbGUsIGN1cnNvci5zdGF0ZS5vZmZzZXQsIGN1cnNvci5zdGF0ZS5saW5lLCBjdXJzb3Iuc3RhdGUuY29sdW1uKTtcbiAgICB9XG59XG5jbGFzcyBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yIGV4dGVuZHMgUGxhaW5DaGFyYWN0ZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpbGVPckN1cnNvciwgcmFuZ2UpIHtcbiAgICAgICAgaWYgKGZpbGVPckN1cnNvciBpbnN0YW5jZW9mIEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IpIHtcbiAgICAgICAgICAgIHN1cGVyKGZpbGVPckN1cnNvcik7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBmaWxlT3JDdXJzb3IuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihmaWxlT3JDdXJzb3IsIHJhbmdlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgc3VwZXIuYWR2YW5jZSgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NFc2NhcGVTZXF1ZW5jZSgpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBzdXBlci5pbml0KCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0VzY2FwZVNlcXVlbmNlKCk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IodGhpcyk7XG4gICAgfVxuICAgIGdldENoYXJzKHN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGN1cnNvciA9IHN0YXJ0LmNsb25lKCk7XG4gICAgICAgIGxldCBjaGFycyA9ICcnO1xuICAgICAgICB3aGlsZSAoY3Vyc29yLmludGVybmFsU3RhdGUub2Zmc2V0IDwgdGhpcy5pbnRlcm5hbFN0YXRlLm9mZnNldCkge1xuICAgICAgICAgICAgY2hhcnMgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY3Vyc29yLnBlZWsoKSk7XG4gICAgICAgICAgICBjdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgZXNjYXBlIHNlcXVlbmNlIHRoYXQgc3RhcnRzIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSB0ZXh0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHRvIGVuc3VyZSB0aGF0IGBwZWVrYCBoYXMgdGhlIHVuZXNjYXBlZCB2YWx1ZSBvZiBlc2NhcGUgc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIHByb2Nlc3NFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICAgICAgY29uc3QgcGVlayA9ICgpID0+IHRoaXMuaW50ZXJuYWxTdGF0ZS5wZWVrO1xuICAgICAgICBpZiAocGVlaygpID09PSAkQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGhpdCBhbiBlc2NhcGUgc2VxdWVuY2Ugc28gd2UgbmVlZCB0aGUgaW50ZXJuYWwgc3RhdGUgdG8gYmVjb21lIGluZGVwZW5kZW50XG4gICAgICAgICAgICAvLyBvZiB0aGUgZXh0ZXJuYWwgc3RhdGUuXG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIC8vIE1vdmUgcGFzdCB0aGUgYmFja3NsYXNoXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgZm9yIHN0YW5kYXJkIGNvbnRyb2wgY2hhciBzZXF1ZW5jZXNcbiAgICAgICAgICAgIGlmIChwZWVrKCkgPT09ICRuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJExGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRDUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJHYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkVlRBQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkVEFCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkYikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRCU1BBQ0U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICRmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJEZGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IGNvbnNpZGVyIG1vcmUgY29tcGxleCBzZXF1ZW5jZXNcbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJHUpIHtcbiAgICAgICAgICAgICAgICAvLyBVbmljb2RlIGNvZGUtcG9pbnQgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGB1YCBjaGFyXG4gICAgICAgICAgICAgICAgaWYgKHBlZWsoKSA9PT0gJExCUkFDRSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBWYXJpYWJsZSBsZW5ndGggVW5pY29kZSwgZS5nLiBgXFx4ezEyM31gXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7IC8vIGFkdmFuY2UgcGFzdCB0aGUgYHtgIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSB2YXJpYWJsZSBudW1iZXIgb2YgaGV4IGRpZ2l0cyB1bnRpbCB3ZSBoaXQgYSBgfWAgY2hhclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWdpdFN0YXJ0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBlZWsoKSAhPT0gJFJCUkFDRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9IHRoaXMuZGVjb2RlSGV4RGlnaXRzKGRpZ2l0U3RhcnQsIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXhlZCBsZW5ndGggVW5pY29kZSwgZS5nLiBgXFx1MTIzNGBcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnaXRTdGFydCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gdGhpcy5kZWNvZGVIZXhEaWdpdHMoZGlnaXRTdGFydCwgNCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkeCkge1xuICAgICAgICAgICAgICAgIC8vIEhleCBjaGFyIGNvZGUsIGUuZy4gYFxceDJGYFxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7IC8vIGFkdmFuY2UgcGFzdCB0aGUgYHhgIGNoYXJcbiAgICAgICAgICAgICAgICBjb25zdCBkaWdpdFN0YXJ0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gdGhpcy5kZWNvZGVIZXhEaWdpdHMoZGlnaXRTdGFydCwgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09jdGFsRGlnaXQocGVlaygpKSkge1xuICAgICAgICAgICAgICAgIC8vIE9jdGFsIGNoYXIgY29kZSwgZS5nLiBgXFwwMTJgLFxuICAgICAgICAgICAgICAgIGxldCBvY3RhbCA9ICcnO1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwcmV2aW91cyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNPY3RhbERpZ2l0KHBlZWsoKSkgJiYgbGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgb2N0YWwgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQocGVlaygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9IHBhcnNlSW50KG9jdGFsLCA4KTtcbiAgICAgICAgICAgICAgICAvLyBCYWNrdXAgb25lIGNoYXJcbiAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSBwcmV2aW91cy5pbnRlcm5hbFN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOZXdMaW5lKHRoaXMuaW50ZXJuYWxTdGF0ZS5wZWVrKSkge1xuICAgICAgICAgICAgICAgIC8vIExpbmUgY29udGludWF0aW9uIGBcXGAgZm9sbG93ZWQgYnkgYSBuZXcgbGluZVxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7IC8vIGFkdmFuY2Ugb3ZlciB0aGUgbmV3bGluZVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmludGVybmFsU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBgaWZgIGJsb2NrcyB3ZXJlIGV4ZWN1dGVkIHRoZW4gd2UganVzdCBoYXZlIGFuIGVzY2FwZWQgbm9ybWFsIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2Ugd2UganVzdCwgZWZmZWN0aXZlbHksIHNraXAgdGhlIGJhY2tzbGFzaCBmcm9tIHRoZSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gdGhpcy5pbnRlcm5hbFN0YXRlLnBlZWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjb2RlSGV4RGlnaXRzKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaGV4ID0gdGhpcy5pbnB1dC5zdWJzdHIoc3RhcnQuaW50ZXJuYWxTdGF0ZS5vZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgIGlmICghaXNOYU4oY2hhckNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydC5zdGF0ZSA9IHN0YXJ0LmludGVybmFsU3RhdGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3Vyc29yRXJyb3IoJ0ludmFsaWQgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlJywgc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ3Vyc29yRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZywgY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgVHJlZUVycm9yIGV4dGVuZHMgUGFyc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICBzdXBlcihzcGFuLCBtc2cpO1xuICAgICAgICB0aGlzLmVsZW1lbnROYW1lID0gZWxlbWVudE5hbWU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZVRyZWVSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHJvb3ROb2RlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gcm9vdE5vZGVzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG59XG5jbGFzcyBQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKGdldFRhZ0RlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICB9XG4gICAgcGFyc2Uoc291cmNlLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdG9rZW5pemVSZXN1bHQgPSB0b2tlbml6ZShzb3VyY2UsIHVybCwgdGhpcy5nZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9UcmVlQnVpbGRlcih0b2tlbml6ZVJlc3VsdC50b2tlbnMsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbik7XG4gICAgICAgIHBhcnNlci5idWlsZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZXIucm9vdE5vZGVzLCB0b2tlbml6ZVJlc3VsdC5lcnJvcnMuY29uY2F0KHBhcnNlci5lcnJvcnMpKTtcbiAgICB9XG59XG5jbGFzcyBfVHJlZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHRva2VucywgZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgIT09IDI0IC8qIEVPRiAqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMCAvKiBUQUdfT1BFTl9TVEFSVCAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gNCAvKiBJTkNPTVBMRVRFX1RBR19PUEVOICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVN0YXJ0VGFnKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDMgLyogVEFHX0NMT1NFICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUVuZFRhZyh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSAxMiAvKiBDREFUQV9TVEFSVCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ2RhdGEodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMTAgLyogQ09NTUVOVF9TVEFSVCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSA1IC8qIFRFWFQgKi8gfHwgdGhpcy5fcGVlay50eXBlID09PSA3IC8qIFJBV19URVhUICovIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSA2IC8qIEVTQ0FQQUJMRV9SQVdfVEVYVCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSAxOSAvKiBFWFBBTlNJT05fRk9STV9TVEFSVCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb24odGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgYWxsIG90aGVyIHRva2Vucy4uLlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWR2YW5jZSgpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3BlZWs7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFsd2F5cyBhbiBFT0YgdG9rZW4gYXQgdGhlIGVuZFxuICAgICAgICAgICAgdGhpcy5faW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZWVrID0gdGhpcy50b2tlbnNbdGhpcy5faW5kZXhdO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9XG4gICAgX2FkdmFuY2VJZih0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9jb25zdW1lQ2RhdGEoX3N0YXJ0VG9rZW4pIHtcbiAgICAgICAgdGhpcy5fY29uc3VtZVRleHQodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgdGhpcy5fYWR2YW5jZUlmKDEzIC8qIENEQVRBX0VORCAqLyk7XG4gICAgfVxuICAgIF9jb25zdW1lQ29tbWVudCh0b2tlbikge1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5fYWR2YW5jZUlmKDcgLyogUkFXX1RFWFQgKi8pO1xuICAgICAgICB0aGlzLl9hZHZhbmNlSWYoMTEgLyogQ09NTUVOVF9FTkQgKi8pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRleHQgIT0gbnVsbCA/IHRleHQucGFydHNbMF0udHJpbSgpIDogbnVsbDtcbiAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQobmV3IENvbW1lbnQodmFsdWUsIHRva2VuLnNvdXJjZVNwYW4pKTtcbiAgICB9XG4gICAgX2NvbnN1bWVFeHBhbnNpb24odG9rZW4pIHtcbiAgICAgICAgY29uc3Qgc3dpdGNoVmFsdWUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIGNvbnN0IGNhc2VzID0gW107XG4gICAgICAgIC8vIHJlYWQgPVxuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSAyMCAvKiBFWFBBTlNJT05fQ0FTRV9WQUxVRSAqLykge1xuICAgICAgICAgICAgY29uc3QgZXhwQ2FzZSA9IHRoaXMuX3BhcnNlRXhwYW5zaW9uQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCFleHBDYXNlKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gZXJyb3JcbiAgICAgICAgICAgIGNhc2VzLnB1c2goZXhwQ2FzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZCB0aGUgZmluYWwgfVxuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlICE9PSAyMyAvKiBFWFBBTlNJT05fRk9STV9FTkQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4sIGBJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5gKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odG9rZW4uc291cmNlU3Bhbi5zdGFydCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLmVuZCwgdG9rZW4uc291cmNlU3Bhbi5mdWxsU3RhcnQpO1xuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgRXhwYW5zaW9uKHN3aXRjaFZhbHVlLnBhcnRzWzBdLCB0eXBlLnBhcnRzWzBdLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWUuc291cmNlU3BhbikpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfVxuICAgIF9wYXJzZUV4cGFuc2lvbkNhc2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAvLyByZWFkIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gMjEgLyogRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUICovKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLCBgSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAneycuYCkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZCB1bnRpbCB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICBjb25zdCBleHAgPSB0aGlzLl9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zKHN0YXJ0KTtcbiAgICAgICAgaWYgKCFleHApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICBleHAucHVzaCh7IHR5cGU6IDI0IC8qIEVPRiAqLywgcGFydHM6IFtdLCBzb3VyY2VTcGFuOiBlbmQuc291cmNlU3BhbiB9KTtcbiAgICAgICAgLy8gcGFyc2UgZXZlcnl0aGluZyBpbiBiZXR3ZWVuIHsgYW5kIH1cbiAgICAgICAgY29uc3QgZXhwYW5zaW9uQ2FzZVBhcnNlciA9IG5ldyBfVHJlZUJ1aWxkZXIoZXhwLCB0aGlzLmdldFRhZ0RlZmluaXRpb24pO1xuICAgICAgICBleHBhbnNpb25DYXNlUGFyc2VyLmJ1aWxkKCk7XG4gICAgICAgIGlmIChleHBhbnNpb25DYXNlUGFyc2VyLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IHRoaXMuZXJyb3JzLmNvbmNhdChleHBhbnNpb25DYXNlUGFyc2VyLmVycm9ycyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3Bhbih2YWx1ZS5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQuc291cmNlU3Bhbi5lbmQsIHZhbHVlLnNvdXJjZVNwYW4uZnVsbFN0YXJ0KTtcbiAgICAgICAgY29uc3QgZXhwU291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnQuc291cmNlU3Bhbi5zdGFydCwgZW5kLnNvdXJjZVNwYW4uZW5kLCBzdGFydC5zb3VyY2VTcGFuLmZ1bGxTdGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgRXhwYW5zaW9uQ2FzZSh2YWx1ZS5wYXJ0c1swXSwgZXhwYW5zaW9uQ2FzZVBhcnNlci5yb290Tm9kZXMsIHNvdXJjZVNwYW4sIHZhbHVlLnNvdXJjZVNwYW4sIGV4cFNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBfY29sbGVjdEV4cGFuc2lvbkV4cFRva2VucyhzdGFydCkge1xuICAgICAgICBjb25zdCBleHAgPSBbXTtcbiAgICAgICAgY29uc3QgZXhwYW5zaW9uRm9ybVN0YWNrID0gWzIxIC8qIEVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCAqL107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSAxOSAvKiBFWFBBTlNJT05fRk9STV9TVEFSVCAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gMjEgLyogRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUICovKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5zaW9uRm9ybVN0YWNrLnB1c2godGhpcy5fcGVlay50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDIyIC8qIEVYUEFOU0lPTl9DQVNFX0VYUF9FTkQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCAyMSAvKiBFWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvbkZvcm1TdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGFuc2lvbkZvcm1TdGFjay5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIGBJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5gKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDIzIC8qIEVYUEFOU0lPTl9GT1JNX0VORCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0T25TdGFjayhleHBhbnNpb25Gb3JtU3RhY2ssIDE5IC8qIEVYUEFOU0lPTl9GT1JNX1NUQVJUICovKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgYEludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLmApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMjQgLyogRU9GICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHN0YXJ0LnNvdXJjZVNwYW4sIGBJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5gKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHAucHVzaCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb25zdW1lVGV4dCh0b2tlbikge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBbdG9rZW5dO1xuICAgICAgICBjb25zdCBzdGFydFNwYW4gPSB0b2tlbi5zb3VyY2VTcGFuO1xuICAgICAgICBsZXQgdGV4dCA9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAwICYmIHRleHRbMF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnQubmFtZSkuaWdub3JlRmlyc3RMZikge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB0b2tlbnNbMF0gPSB7IHR5cGU6IHRva2VuLnR5cGUsIHNvdXJjZVNwYW46IHRva2VuLnNvdXJjZVNwYW4sIHBhcnRzOiBbdGV4dF0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSA4IC8qIElOVEVSUE9MQVRJT04gKi8gfHwgdGhpcy5fcGVlay50eXBlID09PSA1IC8qIFRFWFQgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gOSAvKiBFTkNPREVEX0VOVElUWSAqLykge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gOCAvKiBJTlRFUlBPTEFUSU9OICovKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2UgZGVjb2RlIEhUTUwgZW50aXRpZXMgdGhhdCBhcHBlYXIgaW4gaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb25zLiBUaGlzIGlzIGFyZ3VhYmx5IGEgYnVnLCBidXQgaXQgY291bGQgYmUgYSBjb25zaWRlcmFibGUgYnJlYWtpbmcgY2hhbmdlIHRvXG4gICAgICAgICAgICAgICAgLy8gZml4IGl0LiBJdCBzaG91bGQgYmUgYWRkcmVzc2VkIGluIGEgbGFyZ2VyIHByb2plY3QgdG8gcmVmYWN0b3IgdGhlIGVudGlyZSBwYXJzZXIvbGV4ZXJcbiAgICAgICAgICAgICAgICAvLyBjaGFpbiBhZnRlciBWaWV3IEVuZ2luZSBoYXMgYmVlbiByZW1vdmVkLlxuICAgICAgICAgICAgICAgIHRleHQgKz0gdG9rZW4ucGFydHMuam9pbignJykucmVwbGFjZSgvJihbXjtdKyk7L2csIGRlY29kZUVudGl0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSA5IC8qIEVOQ09ERURfRU5USVRZICovKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gdG9rZW4ucGFydHMuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZW5kU3BhbiA9IHRva2VuLnNvdXJjZVNwYW47XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgVGV4dCh0ZXh0LCBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0U3Bhbi5zdGFydCwgZW5kU3Bhbi5lbmQsIHN0YXJ0U3Bhbi5mdWxsU3RhcnQsIHN0YXJ0U3Bhbi5kZXRhaWxzKSwgdG9rZW5zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Nsb3NlVm9pZEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAoZWwgJiYgdGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb25zdW1lU3RhcnRUYWcoc3RhcnRUYWdUb2tlbikge1xuICAgICAgICBjb25zdCBbcHJlZml4LCBuYW1lXSA9IHN0YXJ0VGFnVG9rZW4ucGFydHM7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IDE0IC8qIEFUVFJfTkFNRSAqLykge1xuICAgICAgICAgICAgYXR0cnMucHVzaCh0aGlzLl9jb25zdW1lQXR0cih0aGlzLl9hZHZhbmNlKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdWxsTmFtZSA9IHRoaXMuX2dldEVsZW1lbnRGdWxsTmFtZShwcmVmaXgsIG5hbWUsIHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgIGxldCBzZWxmQ2xvc2luZyA9IGZhbHNlO1xuICAgICAgICAvLyBOb3RlOiBUaGVyZSBjb3VsZCBoYXZlIGJlZW4gYSB0b2tlbml6ZXIgZXJyb3JcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBnZXQgYSB0b2tlbiBmb3IgdGhlIGVuZCB0YWcuLi5cbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMiAvKiBUQUdfT1BFTl9FTkRfVk9JRCAqLykge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgc2VsZkNsb3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdGFnRGVmID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKTtcbiAgICAgICAgICAgIGlmICghKHRhZ0RlZi5jYW5TZWxmQ2xvc2UgfHwgZ2V0TnNQcmVmaXgoZnVsbE5hbWUpICE9PSBudWxsIHx8IHRhZ0RlZi5pc1ZvaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4sIGBPbmx5IHZvaWQgYW5kIGZvcmVpZ24gZWxlbWVudHMgY2FuIGJlIHNlbGYgY2xvc2VkIFwiJHtzdGFydFRhZ1Rva2VuLnBhcnRzWzFdfVwiYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMSAvKiBUQUdfT1BFTl9FTkQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcGVlay5zb3VyY2VTcGFuLmZ1bGxTdGFydDtcbiAgICAgICAgY29uc3Qgc3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQsIHN0YXJ0VGFnVG9rZW4uc291cmNlU3Bhbi5mdWxsU3RhcnQpO1xuICAgICAgICAvLyBDcmVhdGUgYSBzZXBhcmF0ZSBgc3RhcnRTcGFuYCBiZWNhdXNlIGBzcGFuYCB3aWxsIGJlIG1vZGlmaWVkIHdoZW4gdGhlcmUgaXMgYW4gYGVuZGAgc3Bhbi5cbiAgICAgICAgY29uc3Qgc3RhcnRTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCwgc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLmZ1bGxTdGFydCk7XG4gICAgICAgIGNvbnN0IGVsID0gbmV3IEVsZW1lbnQoZnVsbE5hbWUsIGF0dHJzLCBbXSwgc3Bhbiwgc3RhcnRTcGFuLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9wdXNoRWxlbWVudChlbCk7XG4gICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgLy8gRWxlbWVudHMgdGhhdCBhcmUgc2VsZi1jbG9zZWQgaGF2ZSB0aGVpciBgZW5kU291cmNlU3BhbmAgc2V0IHRvIHRoZSBmdWxsIHNwYW4sIGFzIHRoZVxuICAgICAgICAgICAgLy8gZWxlbWVudCBzdGFydCB0YWcgYWxzbyByZXByZXNlbnRzIHRoZSBlbmQgdGFnLlxuICAgICAgICAgICAgdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSwgc3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnRUYWdUb2tlbi50eXBlID09PSA0IC8qIElOQ09NUExFVEVfVEFHX09QRU4gKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGFscmVhZHkga25vdyB0aGUgb3BlbmluZyB0YWcgaXMgbm90IGNvbXBsZXRlLCBzbyBpdCBpcyB1bmxpa2VseSBpdCBoYXMgYSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAvLyBjbG9zZSB0YWcuIExldCdzIG9wdGltaXN0aWNhbGx5IHBhcnNlIGl0IGFzIGEgZnVsbCBlbGVtZW50IGFuZCBlbWl0IGFuIGVycm9yLlxuICAgICAgICAgICAgdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIHNwYW4sIGBPcGVuaW5nIHRhZyBcIiR7ZnVsbE5hbWV9XCIgbm90IHRlcm1pbmF0ZWQuYCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wdXNoRWxlbWVudChlbCkge1xuICAgICAgICBjb25zdCBwYXJlbnRFbCA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudEVsICYmIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnRFbC5uYW1lKS5pc0Nsb3NlZEJ5Q2hpbGQoZWwubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChlbCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wdXNoKGVsKTtcbiAgICB9XG4gICAgX2NvbnN1bWVFbmRUYWcoZW5kVGFnVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUoZW5kVGFnVG9rZW4ucGFydHNbMF0sIGVuZFRhZ1Rva2VuLnBhcnRzWzFdLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKS5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgYFZvaWQgZWxlbWVudHMgZG8gbm90IGhhdmUgZW5kIHRhZ3MgXCIke2VuZFRhZ1Rva2VuLnBhcnRzWzFdfVwiYCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9wb3BFbGVtZW50KGZ1bGxOYW1lLCBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gYFVuZXhwZWN0ZWQgY2xvc2luZyB0YWcgXCIke2Z1bGxOYW1lfVwiLiBJdCBtYXkgaGFwcGVuIHdoZW4gdGhlIHRhZyBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBieSBhbm90aGVyIHRhZy4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2Nsb3NpbmctZWxlbWVudHMtdGhhdC1oYXZlLWltcGxpZWQtZW5kLXRhZ3NgO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuLCBlcnJNc2cpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG5lYXJlc3QgZWxlbWVudCB3aXRoIHRoZSB0YWcgbmFtZSBgZnVsbE5hbWVgIGluIHRoZSBwYXJzZSB0cmVlLlxuICAgICAqIGBlbmRTb3VyY2VTcGFuYCBpcyB0aGUgc3BhbiBvZiB0aGUgY2xvc2luZyB0YWcsIG9yIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc1xuICAgICAqIG5vdCBoYXZlIGEgY2xvc2luZyB0YWcgKGZvciBleGFtcGxlLCB0aGlzIGhhcHBlbnMgd2hlbiBhbiBpbmNvbXBsZXRlXG4gICAgICogb3BlbmluZyB0YWcgaXMgcmVjb3ZlcmVkKS5cbiAgICAgKi9cbiAgICBfcG9wRWxlbWVudChmdWxsTmFtZSwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICBsZXQgdW5leHBlY3RlZENsb3NlVGFnRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgc3RhY2tJbmRleCA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBzdGFja0luZGV4ID49IDA7IHN0YWNrSW5kZXgtLSkge1xuICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLl9lbGVtZW50U3RhY2tbc3RhY2tJbmRleF07XG4gICAgICAgICAgICBpZiAoZWwubmFtZSA9PT0gZnVsbE5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhlIHBhcnNlIHNwYW4gd2l0aCB0aGUgZWxlbWVudCB0aGF0IGlzIGJlaW5nIGNsb3NlZC4gQW55IGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50IHN0YWNrIGF0IHRoaXMgcG9pbnQgYXJlIGNsb3NlZCBpbXBsaWNpdGx5LCBzbyB0aGV5IHdvbid0IGdldFxuICAgICAgICAgICAgICAgIC8vIGFuIGVuZCBzb3VyY2Ugc3BhbiAoYXMgdGhlcmUgaXMgbm8gZXhwbGljaXQgY2xvc2luZyBlbGVtZW50KS5cbiAgICAgICAgICAgICAgICBlbC5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICAgICAgICAgICAgICBlbC5zb3VyY2VTcGFuLmVuZCA9IGVuZFNvdXJjZVNwYW4gIT09IG51bGwgPyBlbmRTb3VyY2VTcGFuLmVuZCA6IGVsLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5zcGxpY2Uoc3RhY2tJbmRleCwgdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIHN0YWNrSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdW5leHBlY3RlZENsb3NlVGFnRGV0ZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKS5jbG9zZWRCeVBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBlbmNvdW50ZXJlZCBhbiB1bmV4cGVjdGVkIGNsb3NlIHRhZyBidXQgY29udGludWUgcHJvY2Vzc2luZyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHN0YWNrIHNvIHdlIGNhbiBhc3NpZ24gYW4gYGVuZFNvdXJjZVNwYW5gIGlmIHRoZXJlIGlzIGEgY29ycmVzcG9uZGluZyBzdGFydCB0YWcgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbmQgdGFnIGluIHRoZSBzdGFjay5cbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkQ2xvc2VUYWdEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfY29uc3VtZUF0dHIoYXR0ck5hbWUpIHtcbiAgICAgICAgY29uc3QgZnVsbE5hbWUgPSBtZXJnZU5zQW5kTmFtZShhdHRyTmFtZS5wYXJ0c1swXSwgYXR0ck5hbWUucGFydHNbMV0pO1xuICAgICAgICBsZXQgYXR0ckVuZCA9IGF0dHJOYW1lLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAvLyBDb25zdW1lIGFueSBxdW90ZVxuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSAxNSAvKiBBVFRSX1FVT1RFICovKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uc3VtZSB0aGUgYXR0cmlidXRlIHZhbHVlXG4gICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICBjb25zdCB2YWx1ZVRva2VucyA9IFtdO1xuICAgICAgICBsZXQgdmFsdWVTdGFydFNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB2YWx1ZUVuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gTk9URTogV2UgbmVlZCB0byB1c2UgYSBuZXcgdmFyaWFibGUgYG5leHRUb2tlblR5cGVgIGhlcmUgdG8gaGlkZSB0aGUgYWN0dWFsIHR5cGUgb2ZcbiAgICAgICAgLy8gYF9wZWVrLnR5cGVgIGZyb20gVFMuIE90aGVyd2lzZSBUUyB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiBgX3BlZWsudHlwZWAgcHJldmVudGluZyBpdCBmcm9tXG4gICAgICAgIC8vIGJlaW5nIGFibGUgdG8gY29uc2lkZXIgYEFUVFJfVkFMVUVfSU5URVJQT0xBVElPTmAgYXMgYW4gb3B0aW9uLiBUaGlzIGlzIGJlY2F1c2UgVFMgaXMgbm90XG4gICAgICAgIC8vIGFibGUgdG8gc2VlIHRoYXQgYF9hZHZhbmNlKClgIHdpbGwgYWN0dWFsbHkgbXV0YXRlIGBfcGVla2AuXG4gICAgICAgIGNvbnN0IG5leHRUb2tlblR5cGUgPSB0aGlzLl9wZWVrLnR5cGU7XG4gICAgICAgIGlmIChuZXh0VG9rZW5UeXBlID09PSAxNiAvKiBBVFRSX1ZBTFVFX1RFWFQgKi8pIHtcbiAgICAgICAgICAgIHZhbHVlU3RhcnRTcGFuID0gdGhpcy5fcGVlay5zb3VyY2VTcGFuO1xuICAgICAgICAgICAgdmFsdWVFbmQgPSB0aGlzLl9wZWVrLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gMTYgLyogQVRUUl9WQUxVRV9URVhUICovIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSAxNyAvKiBBVFRSX1ZBTFVFX0lOVEVSUE9MQVRJT04gKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9wZWVrLnR5cGUgPT09IDkgLyogRU5DT0RFRF9FTlRJVFkgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVRva2VuID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlVG9rZW5zLnB1c2godmFsdWVUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlVG9rZW4udHlwZSA9PT0gMTcgLyogQVRUUl9WQUxVRV9JTlRFUlBPTEFUSU9OICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdlIGRlY29kZSBIVE1MIGVudGl0aWVzIHRoYXQgYXBwZWFyIGluIGludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbnMuIFRoaXMgaXMgYXJndWFibHkgYSBidWcsIGJ1dCBpdCBjb3VsZCBiZSBhIGNvbnNpZGVyYWJsZSBicmVha2luZyBjaGFuZ2UgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gZml4IGl0LiBJdCBzaG91bGQgYmUgYWRkcmVzc2VkIGluIGEgbGFyZ2VyIHByb2plY3QgdG8gcmVmYWN0b3IgdGhlIGVudGlyZSBwYXJzZXIvbGV4ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhaW4gYWZ0ZXIgVmlldyBFbmdpbmUgaGFzIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdmFsdWVUb2tlbi5wYXJ0cy5qb2luKCcnKS5yZXBsYWNlKC8mKFteO10rKTsvZywgZGVjb2RlRW50aXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVUb2tlbi50eXBlID09PSA5IC8qIEVOQ09ERURfRU5USVRZICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHZhbHVlVG9rZW4ucGFydHNbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB2YWx1ZVRva2VuLnBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZUVuZCA9IGF0dHJFbmQgPSB2YWx1ZVRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN1bWUgYW55IHF1b3RlXG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDE1IC8qIEFUVFJfUVVPVEUgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHF1b3RlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBhdHRyRW5kID0gcXVvdGVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVNwYW4gPSB2YWx1ZVN0YXJ0U3BhbiAmJiB2YWx1ZUVuZCAmJlxuICAgICAgICAgICAgbmV3IFBhcnNlU291cmNlU3Bhbih2YWx1ZVN0YXJ0U3Bhbi5zdGFydCwgdmFsdWVFbmQsIHZhbHVlU3RhcnRTcGFuLmZ1bGxTdGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlKGZ1bGxOYW1lLCB2YWx1ZSwgbmV3IFBhcnNlU291cmNlU3BhbihhdHRyTmFtZS5zb3VyY2VTcGFuLnN0YXJ0LCBhdHRyRW5kLCBhdHRyTmFtZS5zb3VyY2VTcGFuLmZ1bGxTdGFydCksIGF0dHJOYW1lLnNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdmFsdWVUb2tlbnMubGVuZ3RoID4gMCA/IHZhbHVlVG9rZW5zIDogdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBfZ2V0UGFyZW50RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwID8gdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgfVxuICAgIF9hZGRUb1BhcmVudChub2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldEVsZW1lbnRGdWxsTmFtZShwcmVmaXgsIGxvY2FsTmFtZSwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICBpZiAocHJlZml4ID09PSAnJykge1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGxvY2FsTmFtZSkuaW1wbGljaXROYW1lc3BhY2VQcmVmaXggfHwgJyc7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSAnJyAmJiBwYXJlbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUYWdOYW1lID0gc3BsaXROc05hbWUocGFyZW50RWxlbWVudC5uYW1lKVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUYWdEZWZpbml0aW9uID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKHBhcmVudFRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50VGFnRGVmaW5pdGlvbi5wcmV2ZW50TmFtZXNwYWNlSW5oZXJpdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gZ2V0TnNQcmVmaXgocGFyZW50RWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlTnNBbmROYW1lKHByZWZpeCwgbG9jYWxOYW1lKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsYXN0T25TdGFjayhzdGFjaywgZWxlbWVudCkge1xuICAgIHJldHVybiBzdGFjay5sZW5ndGggPiAwICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBlbGVtZW50O1xufVxuLyoqXG4gKiBEZWNvZGUgdGhlIGBlbnRpdHlgIHN0cmluZywgd2hpY2ggd2UgYmVsaWV2ZSBpcyB0aGUgY29udGVudHMgb2YgYW4gSFRNTCBlbnRpdHkuXG4gKlxuICogSWYgdGhlIHN0cmluZyBpcyBub3QgYWN0dWFsbHkgYSB2YWxpZC9rbm93biBlbnRpdHkgdGhlbiBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWwgYG1hdGNoYCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUVudGl0eShtYXRjaCwgZW50aXR5KSB7XG4gICAgaWYgKE5BTUVEX0VOVElUSUVTW2VudGl0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gTkFNRURfRU5USVRJRVNbZW50aXR5XSB8fCBtYXRjaDtcbiAgICB9XG4gICAgaWYgKC9eI3hbYS1mMC05XSskL2kudGVzdChlbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChlbnRpdHkuc2xpY2UoMiksIDE2KSk7XG4gICAgfVxuICAgIGlmICgvXiNcXGQrJC8udGVzdChlbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChlbnRpdHkuc2xpY2UoMSksIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBIdG1sUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZ2V0SHRtbFRhZ0RlZmluaXRpb24pO1xuICAgIH1cbiAgICBwYXJzZShzb3VyY2UsIHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2Uoc291cmNlLCB1cmwsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBQUkVTRVJWRV9XU19BVFRSX05BTUUgPSAnbmdQcmVzZXJ2ZVdoaXRlc3BhY2VzJztcbmNvbnN0IFNLSVBfV1NfVFJJTV9UQUdTID0gbmV3IFNldChbJ3ByZScsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICdzY3JpcHQnLCAnc3R5bGUnXSk7XG4vLyBFcXVpdmFsZW50IHRvIFxccyB3aXRoIFxcdTAwYTAgKG5vbi1icmVha2luZyBzcGFjZSkgZXhjbHVkZWQuXG4vLyBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHBcbmNvbnN0IFdTX0NIQVJTID0gJyBcXGZcXG5cXHJcXHRcXHZcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZic7XG5jb25zdCBOT19XU19SRUdFWFAgPSBuZXcgUmVnRXhwKGBbXiR7V1NfQ0hBUlN9XWApO1xuY29uc3QgV1NfUkVQTEFDRV9SRUdFWFAgPSBuZXcgUmVnRXhwKGBbJHtXU19DSEFSU31dezIsfWAsICdnJyk7XG5mdW5jdGlvbiBoYXNQcmVzZXJ2ZVdoaXRlc3BhY2VzQXR0cihhdHRycykge1xuICAgIHJldHVybiBhdHRycy5zb21lKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09IFBSRVNFUlZFX1dTX0FUVFJfTkFNRSk7XG59XG4vKipcbiAqIEFuZ3VsYXIgRGFydCBpbnRyb2R1Y2VkICZuZ3NwOyBhcyBhIHBsYWNlaG9sZGVyIGZvciBub24tcmVtb3ZhYmxlIHNwYWNlLCBzZWU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGFydC1sYW5nL2FuZ3VsYXIvYmxvYi8wYmI2MTEzODdkMjlkNjViNWFmN2Y5ZDI1MTVhYjU3MWZkM2ZiZWU0L190ZXN0cy90ZXN0L2NvbXBpbGVyL3ByZXNlcnZlX3doaXRlc3BhY2VfdGVzdC5kYXJ0I0wyNS1MMzJcbiAqIEluIEFuZ3VsYXIgRGFydCAmbmdzcDsgaXMgY29udmVydGVkIHRvIHRoZSAweEU1MDAgUFVBIChQcml2YXRlIFVzZSBBcmVhcykgdW5pY29kZSBjaGFyYWN0ZXJcbiAqIGFuZCBsYXRlciBvbiByZXBsYWNlZCBieSBhIHNwYWNlLiBXZSBhcmUgcmUtaW1wbGVtZW50aW5nIHRoZSBzYW1lIGlkZWEgaGVyZS5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZU5nc3AodmFsdWUpIHtcbiAgICAvLyBsZXhlciBpcyByZXBsYWNpbmcgdGhlICZuZ3NwOyBwc2V1ZG8tZW50aXR5IHdpdGggTkdTUF9VTklDT0RFXG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cChOR1NQX1VOSUNPREUsICdnJyksICcgJyk7XG59XG4vKipcbiAqIFRoaXMgdmlzaXRvciBjYW4gd2FsayBIVE1MIHBhcnNlIHRyZWUgYW5kIHJlbW92ZSAvIHRyaW0gdGV4dCBub2RlcyB1c2luZyB0aGUgZm9sbG93aW5nIHJ1bGVzOlxuICogLSBjb25zaWRlciBzcGFjZXMsIHRhYnMgYW5kIG5ldyBsaW5lcyBhcyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnM7XG4gKiAtIGRyb3AgdGV4dCBub2RlcyBjb25zaXN0aW5nIG9mIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBvbmx5O1xuICogLSBmb3IgYWxsIG90aGVyIHRleHQgbm9kZXMgcmVwbGFjZSBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgd2l0aCBvbmUgc3BhY2U7XG4gKiAtIGNvbnZlcnQgJm5nc3A7IHBzZXVkby1lbnRpdHkgdG8gYSBzaW5nbGUgc3BhY2U7XG4gKlxuICogUmVtb3ZhbCBhbmQgdHJpbW1pbmcgb2Ygd2hpdGVzcGFjZXMgaGF2ZSBwb3NpdGl2ZSBwZXJmb3JtYW5jZSBpbXBhY3QgKGxlc3MgY29kZSB0byBnZW5lcmF0ZVxuICogd2hpbGUgY29tcGlsaW5nIHRlbXBsYXRlcywgZmFzdGVyIHZpZXcgY3JlYXRpb24pLiBBdCB0aGUgc2FtZSB0aW1lIGl0IGNhbiBiZSBcImRlc3RydWN0aXZlXCJcbiAqIGluIHNvbWUgY2FzZXMgKHdoaXRlc3BhY2VzIGNhbiBpbmZsdWVuY2UgbGF5b3V0KS4gQmVjYXVzZSBvZiB0aGUgcG90ZW50aWFsIG9mIGJyZWFraW5nIGxheW91dFxuICogdGhpcyB2aXNpdG9yIGlzIG5vdCBhY3RpdmF0ZWQgYnkgZGVmYXVsdCBpbiBBbmd1bGFyIDUgYW5kIHBlb3BsZSBuZWVkIHRvIGV4cGxpY2l0bHkgb3B0LWluIGZvclxuICogd2hpdGVzcGFjZSByZW1vdmFsLiBUaGUgZGVmYXVsdCBvcHRpb24gZm9yIHdoaXRlc3BhY2UgcmVtb3ZhbCB3aWxsIGJlIHJldmlzaXRlZCBpbiBBbmd1bGFyIDZcbiAqIGFuZCBtaWdodCBiZSBjaGFuZ2VkIHRvIFwib25cIiBieSBkZWZhdWx0LlxuICovXG5jbGFzcyBXaGl0ZXNwYWNlVmlzaXRvciB7XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKFNLSVBfV1NfVFJJTV9UQUdTLmhhcyhlbGVtZW50Lm5hbWUpIHx8IGhhc1ByZXNlcnZlV2hpdGVzcGFjZXNBdHRyKGVsZW1lbnQuYXR0cnMpKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBkZXNjZW50IGludG8gZWxlbWVudHMgd2hlcmUgd2UgbmVlZCB0byBwcmVzZXJ2ZSB3aGl0ZXNwYWNlc1xuICAgICAgICAgICAgLy8gYnV0IHN0aWxsIHZpc2l0IGFsbCBhdHRyaWJ1dGVzIHRvIGVsaW1pbmF0ZSBvbmUgdXNlZCBhcyBhIG1hcmtldCB0byBwcmVzZXJ2ZSBXU1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsZW1lbnQubmFtZSwgdmlzaXRBbGwodGhpcywgZWxlbWVudC5hdHRycyksIGVsZW1lbnQuY2hpbGRyZW4sIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3BhbiwgZWxlbWVudC5pMThuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWxlbWVudC5uYW1lLCBlbGVtZW50LmF0dHJzLCB2aXNpdEFsbFdpdGhTaWJsaW5ncyh0aGlzLCBlbGVtZW50LmNoaWxkcmVuKSwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuLCBlbGVtZW50LmkxOG4pO1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lICE9PSBQUkVTRVJWRV9XU19BVFRSX05BTUUgPyBhdHRyaWJ1dGUgOiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBpc05vdEJsYW5rID0gdGV4dC52YWx1ZS5tYXRjaChOT19XU19SRUdFWFApO1xuICAgICAgICBjb25zdCBoYXNFeHBhbnNpb25TaWJsaW5nID0gY29udGV4dCAmJlxuICAgICAgICAgICAgKGNvbnRleHQucHJldiBpbnN0YW5jZW9mIEV4cGFuc2lvbiB8fCBjb250ZXh0Lm5leHQgaW5zdGFuY2VvZiBFeHBhbnNpb24pO1xuICAgICAgICBpZiAoaXNOb3RCbGFuayB8fCBoYXNFeHBhbnNpb25TaWJsaW5nKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSB3aGl0ZXNwYWNlIGluIHRoZSB0b2tlbnMgb2YgdGhpcyBUZXh0IG5vZGVcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IHRleHQudG9rZW5zLm1hcCh0b2tlbiA9PiB0b2tlbi50eXBlID09PSA1IC8qIFRFWFQgKi8gPyBjcmVhdGVXaGl0ZXNwYWNlUHJvY2Vzc2VkVGV4dFRva2VuKHRva2VuKSA6IHRva2VuKTtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHdoaXRlc3BhY2Ugb2YgdGhlIHZhbHVlIG9mIHRoaXMgVGV4dCBub2RlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb2Nlc3NXaGl0ZXNwYWNlKHRleHQudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0KHZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4sIHRva2VucywgdGV4dC5pMThuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRDb21tZW50KGNvbW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uKGV4cGFuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZXhwYW5zaW9uO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZXhwYW5zaW9uQ2FzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVXaGl0ZXNwYWNlUHJvY2Vzc2VkVGV4dFRva2VuKHsgdHlwZSwgcGFydHMsIHNvdXJjZVNwYW4gfSkge1xuICAgIHJldHVybiB7IHR5cGUsIHBhcnRzOiBbcHJvY2Vzc1doaXRlc3BhY2UocGFydHNbMF0pXSwgc291cmNlU3BhbiB9O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1doaXRlc3BhY2UodGV4dCkge1xuICAgIHJldHVybiByZXBsYWNlTmdzcCh0ZXh0KS5yZXBsYWNlKFdTX1JFUExBQ0VfUkVHRVhQLCAnICcpO1xufVxuZnVuY3Rpb24gcmVtb3ZlV2hpdGVzcGFjZXMoaHRtbEFzdFdpdGhFcnJvcnMpIHtcbiAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh2aXNpdEFsbChuZXcgV2hpdGVzcGFjZVZpc2l0b3IoKSwgaHRtbEFzdFdpdGhFcnJvcnMucm9vdE5vZGVzKSwgaHRtbEFzdFdpdGhFcnJvcnMuZXJyb3JzKTtcbn1cbmZ1bmN0aW9uIHZpc2l0QWxsV2l0aFNpYmxpbmdzKHZpc2l0b3IsIG5vZGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbm9kZXMuZm9yRWFjaCgoYXN0LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IHByZXY6IG5vZGVzW2kgLSAxXSwgbmV4dDogbm9kZXNbaSArIDFdIH07XG4gICAgICAgIGNvbnN0IGFzdFJlc3VsdCA9IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gbWFwRW50cnkoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB7IGtleSwgdmFsdWUsIHF1b3RlZDogZmFsc2UgfTtcbn1cbmZ1bmN0aW9uIG1hcExpdGVyYWwob2JqLCBxdW90ZWQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXRlcmFsTWFwKE9iamVjdC5rZXlzKG9iaikubWFwKGtleSA9PiAoe1xuICAgICAgICBrZXksXG4gICAgICAgIHF1b3RlZCxcbiAgICAgICAgdmFsdWU6IG9ialtrZXldLFxuICAgIH0pKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vICAgICAgICBETyBOT1QgRURJVCBUSElTIExJU1QgT0YgU0VDVVJJVFkgU0VOU0lUSVZFIFBST1BFUlRJRVMgV0lUSE9VVCBBIFNFQ1VSSVRZIFJFVklFVyFcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWNoIG91dCB0byBtcHJvYnN0IGZvciBkZXRhaWxzLlxuLy9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKiBNYXAgZnJvbSB0YWdOYW1lfHByb3BlcnR5TmFtZSB0byBTZWN1cml0eUNvbnRleHQuIFByb3BlcnRpZXMgYXBwbHlpbmcgdG8gYWxsIHRhZ3MgdXNlICcqJy4gKi9cbmxldCBfU0VDVVJJVFlfU0NIRU1BO1xuZnVuY3Rpb24gU0VDVVJJVFlfU0NIRU1BKCkge1xuICAgIGlmICghX1NFQ1VSSVRZX1NDSEVNQSkge1xuICAgICAgICBfU0VDVVJJVFlfU0NIRU1BID0ge307XG4gICAgICAgIC8vIENhc2UgaXMgaW5zaWduaWZpY2FudCBiZWxvdywgYWxsIGVsZW1lbnQgYW5kIGF0dHJpYnV0ZSBuYW1lcyBhcmUgbG93ZXItY2FzZWQgZm9yIGxvb2t1cC5cbiAgICAgICAgcmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5IVE1MLCBbXG4gICAgICAgICAgICAnaWZyYW1lfHNyY2RvYycsXG4gICAgICAgICAgICAnKnxpbm5lckhUTUwnLFxuICAgICAgICAgICAgJyp8b3V0ZXJIVE1MJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuU1RZTEUsIFsnKnxzdHlsZSddKTtcbiAgICAgICAgLy8gTkI6IG5vIFNDUklQVCBjb250ZXh0cyBoZXJlLCB0aGV5IGFyZSBuZXZlciBhbGxvd2VkIGR1ZSB0byB0aGUgcGFyc2VyIHN0cmlwcGluZyB0aGVtLlxuICAgICAgICByZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlVSTCwgW1xuICAgICAgICAgICAgJyp8Zm9ybUFjdGlvbicsICdhcmVhfGhyZWYnLCAnYXJlYXxwaW5nJywgJ2F1ZGlvfHNyYycsICdhfGhyZWYnLFxuICAgICAgICAgICAgJ2F8cGluZycsICdibG9ja3F1b3RlfGNpdGUnLCAnYm9keXxiYWNrZ3JvdW5kJywgJ2RlbHxjaXRlJywgJ2Zvcm18YWN0aW9uJyxcbiAgICAgICAgICAgICdpbWd8c3JjJywgJ2ltZ3xzcmNzZXQnLCAnaW5wdXR8c3JjJywgJ2luc3xjaXRlJywgJ3F8Y2l0ZScsXG4gICAgICAgICAgICAnc291cmNlfHNyYycsICdzb3VyY2V8c3Jjc2V0JywgJ3RyYWNrfHNyYycsICd2aWRlb3xwb3N0ZXInLCAndmlkZW98c3JjJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMLCBbXG4gICAgICAgICAgICAnYXBwbGV0fGNvZGUnLFxuICAgICAgICAgICAgJ2FwcGxldHxjb2RlYmFzZScsXG4gICAgICAgICAgICAnYmFzZXxocmVmJyxcbiAgICAgICAgICAgICdlbWJlZHxzcmMnLFxuICAgICAgICAgICAgJ2ZyYW1lfHNyYycsXG4gICAgICAgICAgICAnaGVhZHxwcm9maWxlJyxcbiAgICAgICAgICAgICdodG1sfG1hbmlmZXN0JyxcbiAgICAgICAgICAgICdpZnJhbWV8c3JjJyxcbiAgICAgICAgICAgICdsaW5rfGhyZWYnLFxuICAgICAgICAgICAgJ21lZGlhfHNyYycsXG4gICAgICAgICAgICAnb2JqZWN0fGNvZGViYXNlJyxcbiAgICAgICAgICAgICdvYmplY3R8ZGF0YScsXG4gICAgICAgICAgICAnc2NyaXB0fHNyYycsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gX1NFQ1VSSVRZX1NDSEVNQTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29udGV4dChjdHgsIHNwZWNzKSB7XG4gICAgZm9yIChjb25zdCBzcGVjIG9mIHNwZWNzKVxuICAgICAgICBfU0VDVVJJVFlfU0NIRU1BW3NwZWMudG9Mb3dlckNhc2UoKV0gPSBjdHg7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5IHtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBFVkVOVCA9ICdldmVudCc7XG5jb25zdCBCT09MRUFOID0gJ2Jvb2xlYW4nO1xuY29uc3QgTlVNQkVSID0gJ251bWJlcic7XG5jb25zdCBTVFJJTkcgPSAnc3RyaW5nJztcbmNvbnN0IE9CSkVDVCA9ICdvYmplY3QnO1xuLyoqXG4gKiBUaGlzIGFycmF5IHJlcHJlc2VudHMgdGhlIERPTSBzY2hlbWEuIEl0IGVuY29kZXMgaW5oZXJpdGFuY2UsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gKlxuICogIyMgT3ZlcnZpZXdcbiAqXG4gKiBFYWNoIGxpbmUgcmVwcmVzZW50cyBvbmUga2luZCBvZiBlbGVtZW50LiBUaGUgYGVsZW1lbnRfaW5oZXJpdGFuY2VgIGFuZCBwcm9wZXJ0aWVzIGFyZSBqb2luZWRcbiAqIHVzaW5nIGBlbGVtZW50X2luaGVyaXRhbmNlfHByb3BlcnRpZXNgIHN5bnRheC5cbiAqXG4gKiAjIyBFbGVtZW50IEluaGVyaXRhbmNlXG4gKlxuICogVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBjYW4gYmUgZnVydGhlciBzdWJkaXZpZGVkIGFzIGBlbGVtZW50MSxlbGVtZW50MiwuLi5ecGFyZW50RWxlbWVudGAuXG4gKiBIZXJlIHRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFdmVyeSBlbGVtZW50IGluIHRoZSBsaXN0XG4gKiBoYXMgaWRlbnRpY2FsIHByb3BlcnRpZXMuXG4gKlxuICogQW4gYGVsZW1lbnRgIG1heSBpbmhlcml0IGFkZGl0aW9uYWwgcHJvcGVydGllcyBmcm9tIGBwYXJlbnRFbGVtZW50YCBJZiBubyBgXnBhcmVudEVsZW1lbnRgIGlzXG4gKiBzcGVjaWZpZWQgdGhlbiBgXCJcImAgKGJsYW5rKSBlbGVtZW50IGlzIGFzc3VtZWQuXG4gKlxuICogTk9URTogVGhlIGJsYW5rIGVsZW1lbnQgaW5oZXJpdHMgZnJvbSByb290IGBbRWxlbWVudF1gIGVsZW1lbnQsIHRoZSBzdXBlciBlbGVtZW50IG9mIGFsbFxuICogZWxlbWVudHMuXG4gKlxuICogTk9URSBhbiBlbGVtZW50IHByZWZpeCBzdWNoIGFzIGA6c3ZnOmAgaGFzIG5vIHNwZWNpYWwgbWVhbmluZyB0byB0aGUgc2NoZW1hLlxuICpcbiAqICMjIFByb3BlcnRpZXNcbiAqXG4gKiBFYWNoIGVsZW1lbnQgaGFzIGEgc2V0IG9mIHByb3BlcnRpZXMgc2VwYXJhdGVkIGJ5IGAsYCAoY29tbWFzKS4gRWFjaCBwcm9wZXJ0eSBjYW4gYmUgcHJlZml4ZWRcbiAqIGJ5IGEgc3BlY2lhbCBjaGFyYWN0ZXIgZGVzaWduYXRpbmcgaXRzIHR5cGU6XG4gKlxuICogLSAobm8gcHJlZml4KTogcHJvcGVydHkgaXMgYSBzdHJpbmcuXG4gKiAtIGAqYDogcHJvcGVydHkgcmVwcmVzZW50cyBhbiBldmVudC5cbiAqIC0gYCFgOiBwcm9wZXJ0eSBpcyBhIGJvb2xlYW4uXG4gKiAtIGAjYDogcHJvcGVydHkgaXMgYSBudW1iZXIuXG4gKiAtIGAlYDogcHJvcGVydHkgaXMgYW4gb2JqZWN0LlxuICpcbiAqICMjIFF1ZXJ5XG4gKlxuICogVGhlIGNsYXNzIGNyZWF0ZXMgYW4gaW50ZXJuYWwgc3F1YXMgcmVwcmVzZW50YXRpb24gd2hpY2ggYWxsb3dzIHRvIGVhc2lseSBhbnN3ZXIgdGhlIHF1ZXJ5IG9mXG4gKiBpZiBhIGdpdmVuIHByb3BlcnR5IGV4aXN0IG9uIGEgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCB5ZXQgc3VwcG9ydCBxdWVyeWluZyBmb3IgdHlwZXMgb3IgZXZlbnRzLlxuICogTk9URTogVGhpcyBzY2hlbWEgaXMgYXV0byBleHRyYWN0ZWQgZnJvbSBgc2NoZW1hX2V4dHJhY3Rvci50c2AgbG9jYXRlZCBpbiB0aGUgdGVzdCBmb2xkZXIsXG4gKiAgICAgICBzZWUgZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5X3NwZWMudHNcbiAqL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICBETyBOT1QgRURJVCBUSElTIERPTSBTQ0hFTUEgV0lUSE9VVCBBIFNFQ1VSSVRZIFJFVklFVyFcbi8vXG4vLyBOZXdseSBhZGRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgc2VjdXJpdHkgcmV2aWV3ZWQgYW5kIGFzc2lnbmVkIGFuIGFwcHJvcHJpYXRlIFNlY3VyaXR5Q29udGV4dCBpblxuLy8gZG9tX3NlY3VyaXR5X3NjaGVtYS50cy4gUmVhY2ggb3V0IHRvIG1wcm9ic3QgJiByamFtZXQgZm9yIGRldGFpbHMuXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgU0NIRU1BID0gW1xuICAgICdbRWxlbWVudF18dGV4dENvbnRlbnQsJWNsYXNzTGlzdCxjbGFzc05hbWUsaWQsaW5uZXJIVE1MLCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpjb3B5LCpjdXQsKnBhc3RlLCpzZWFyY2gsKnNlbGVjdHN0YXJ0LCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVySFRNTCwjc2Nyb2xsTGVmdCwjc2Nyb2xsVG9wLHNsb3QnICtcbiAgICAgICAgLyogYWRkZWQgbWFudWFsbHkgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlcyAqL1xuICAgICAgICAnLCptZXNzYWdlLCptb3pmdWxsc2NyZWVuY2hhbmdlLCptb3pmdWxsc2NyZWVuZXJyb3IsKm1venBvaW50ZXJsb2NrY2hhbmdlLCptb3pwb2ludGVybG9ja2Vycm9yLCp3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yLCp3ZWJnbGNvbnRleHRsb3N0LCp3ZWJnbGNvbnRleHRyZXN0b3JlZCcsXG4gICAgJ1tIVE1MRWxlbWVudF1eW0VsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmF1eGNsaWNrLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwb2ludGVyY2FuY2VsLCpwb2ludGVyZG93biwqcG9pbnRlcmVudGVyLCpwb2ludGVybGVhdmUsKnBvaW50ZXJtb3ZlLCpwb2ludGVyb3V0LCpwb2ludGVyb3ZlciwqcG9pbnRlcnVwLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZyxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnYWJicixhZGRyZXNzLGFydGljbGUsYXNpZGUsYixiZGksYmRvLGNpdGUsY29kZSxkZCxkZm4sZHQsZW0sZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixpLGtiZCxtYWluLG1hcmssbmF2LG5vc2NyaXB0LHJiLHJwLHJ0LHJ0YyxydWJ5LHMsc2FtcCxzZWN0aW9uLHNtYWxsLHN0cm9uZyxzdWIsc3VwLHUsdmFyLHdicl5bSFRNTEVsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmF1eGNsaWNrLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwb2ludGVyY2FuY2VsLCpwb2ludGVyZG93biwqcG9pbnRlcmVudGVyLCpwb2ludGVybGVhdmUsKnBvaW50ZXJtb3ZlLCpwb2ludGVyb3V0LCpwb2ludGVyb3ZlciwqcG9pbnRlcnVwLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZyxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnbWVkaWFeW0hUTUxFbGVtZW50XXwhYXV0b3BsYXksIWNvbnRyb2xzLCVjb250cm9sc0xpc3QsJWNyb3NzT3JpZ2luLCNjdXJyZW50VGltZSwhZGVmYXVsdE11dGVkLCNkZWZhdWx0UGxheWJhY2tSYXRlLCFkaXNhYmxlUmVtb3RlUGxheWJhY2ssIWxvb3AsIW11dGVkLCplbmNyeXB0ZWQsKndhaXRpbmdmb3JrZXksI3BsYXliYWNrUmF0ZSxwcmVsb2FkLHNyYywlc3JjT2JqZWN0LCN2b2x1bWUnLFxuICAgICc6c3ZnOl5bSFRNTEVsZW1lbnRdfCphYm9ydCwqYXV4Y2xpY2ssKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY3VlY2hhbmdlLCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCpnb3Rwb2ludGVyY2FwdHVyZSwqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbG9zdHBvaW50ZXJjYXB0dXJlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnBvaW50ZXJjYW5jZWwsKnBvaW50ZXJkb3duLCpwb2ludGVyZW50ZXIsKnBvaW50ZXJsZWF2ZSwqcG9pbnRlcm1vdmUsKnBvaW50ZXJvdXQsKnBvaW50ZXJvdmVyLCpwb2ludGVydXAsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCVzdHlsZSwjdGFiSW5kZXgnLFxuICAgICc6c3ZnOmdyYXBoaWNzXjpzdmc6fCcsXG4gICAgJzpzdmc6YW5pbWF0aW9uXjpzdmc6fCpiZWdpbiwqZW5kLCpyZXBlYXQnLFxuICAgICc6c3ZnOmdlb21ldHJ5Xjpzdmc6fCcsXG4gICAgJzpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbl46c3ZnOnwnLFxuICAgICc6c3ZnOmdyYWRpZW50Xjpzdmc6fCcsXG4gICAgJzpzdmc6dGV4dENvbnRlbnReOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOnRleHRQb3NpdGlvbmluZ146c3ZnOnRleHRDb250ZW50fCcsXG4gICAgJ2FeW0hUTUxFbGVtZW50XXxjaGFyc2V0LGNvb3Jkcyxkb3dubG9hZCxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZixocmVmbGFuZyxuYW1lLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxyZWwscmV2LHNlYXJjaCxzaGFwZSx0YXJnZXQsdGV4dCx0eXBlLHVzZXJuYW1lJyxcbiAgICAnYXJlYV5bSFRNTEVsZW1lbnRdfGFsdCxjb29yZHMsZG93bmxvYWQsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsIW5vSHJlZixwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3kscmVsLHNlYXJjaCxzaGFwZSx0YXJnZXQsdXNlcm5hbWUnLFxuICAgICdhdWRpb15tZWRpYXwnLFxuICAgICdicl5bSFRNTEVsZW1lbnRdfGNsZWFyJyxcbiAgICAnYmFzZV5bSFRNTEVsZW1lbnRdfGhyZWYsdGFyZ2V0JyxcbiAgICAnYm9keV5bSFRNTEVsZW1lbnRdfGFMaW5rLGJhY2tncm91bmQsYmdDb2xvcixsaW5rLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHRleHQsdkxpbmsnLFxuICAgICdidXR0b25eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsbmFtZSx0eXBlLHZhbHVlJyxcbiAgICAnY2FudmFzXltIVE1MRWxlbWVudF18I2hlaWdodCwjd2lkdGgnLFxuICAgICdjb250ZW50XltIVE1MRWxlbWVudF18c2VsZWN0JyxcbiAgICAnZGxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2RhdGFsaXN0XltIVE1MRWxlbWVudF18JyxcbiAgICAnZGV0YWlsc15bSFRNTEVsZW1lbnRdfCFvcGVuJyxcbiAgICAnZGlhbG9nXltIVE1MRWxlbWVudF18IW9wZW4scmV0dXJuVmFsdWUnLFxuICAgICdkaXJeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2Rpdl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnZW1iZWReW0hUTUxFbGVtZW50XXxhbGlnbixoZWlnaHQsbmFtZSxzcmMsdHlwZSx3aWR0aCcsXG4gICAgJ2ZpZWxkc2V0XltIVE1MRWxlbWVudF18IWRpc2FibGVkLG5hbWUnLFxuICAgICdmb250XltIVE1MRWxlbWVudF18Y29sb3IsZmFjZSxzaXplJyxcbiAgICAnZm9ybV5bSFRNTEVsZW1lbnRdfGFjY2VwdENoYXJzZXQsYWN0aW9uLGF1dG9jb21wbGV0ZSxlbmNvZGluZyxlbmN0eXBlLG1ldGhvZCxuYW1lLCFub1ZhbGlkYXRlLHRhcmdldCcsXG4gICAgJ2ZyYW1lXltIVE1MRWxlbWVudF18ZnJhbWVCb3JkZXIsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUsIW5vUmVzaXplLHNjcm9sbGluZyxzcmMnLFxuICAgICdmcmFtZXNldF5bSFRNTEVsZW1lbnRdfGNvbHMsKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQscm93cycsXG4gICAgJ2hyXltIVE1MRWxlbWVudF18YWxpZ24sY29sb3IsIW5vU2hhZGUsc2l6ZSx3aWR0aCcsXG4gICAgJ2hlYWReW0hUTUxFbGVtZW50XXwnLFxuICAgICdoMSxoMixoMyxoNCxoNSxoNl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnaHRtbF5bSFRNTEVsZW1lbnRdfHZlcnNpb24nLFxuICAgICdpZnJhbWVeW0hUTUxFbGVtZW50XXxhbGlnbiwhYWxsb3dGdWxsc2NyZWVuLGZyYW1lQm9yZGVyLGhlaWdodCxsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSxyZWZlcnJlclBvbGljeSwlc2FuZGJveCxzY3JvbGxpbmcsc3JjLHNyY2RvYyx3aWR0aCcsXG4gICAgJ2ltZ15bSFRNTEVsZW1lbnRdfGFsaWduLGFsdCxib3JkZXIsJWNyb3NzT3JpZ2luLCNoZWlnaHQsI2hzcGFjZSwhaXNNYXAsbG9uZ0Rlc2MsbG93c3JjLG5hbWUscmVmZXJyZXJQb2xpY3ksc2l6ZXMsc3JjLHNyY3NldCx1c2VNYXAsI3ZzcGFjZSwjd2lkdGgnLFxuICAgICdpbnB1dF5bSFRNTEVsZW1lbnRdfGFjY2VwdCxhbGlnbixhbHQsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLCFhdXRvZm9jdXMsIWNoZWNrZWQsIWRlZmF1bHRDaGVja2VkLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwlZmlsZXMsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LCNoZWlnaHQsIWluY3JlbWVudGFsLCFpbmRldGVybWluYXRlLG1heCwjbWF4TGVuZ3RoLG1pbiwjbWluTGVuZ3RoLCFtdWx0aXBsZSxuYW1lLHBhdHRlcm4scGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsI3NpemUsc3JjLHN0ZXAsdHlwZSx1c2VNYXAsdmFsdWUsJXZhbHVlQXNEYXRlLCN2YWx1ZUFzTnVtYmVyLCN3aWR0aCcsXG4gICAgJ2xpXltIVE1MRWxlbWVudF18dHlwZSwjdmFsdWUnLFxuICAgICdsYWJlbF5bSFRNTEVsZW1lbnRdfGh0bWxGb3InLFxuICAgICdsZWdlbmReW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ2xpbmteW0hUTUxFbGVtZW50XXxhcyxjaGFyc2V0LCVjcm9zc09yaWdpbiwhZGlzYWJsZWQsaHJlZixocmVmbGFuZyxpbnRlZ3JpdHksbWVkaWEscmVmZXJyZXJQb2xpY3kscmVsLCVyZWxMaXN0LHJldiwlc2l6ZXMsdGFyZ2V0LHR5cGUnLFxuICAgICdtYXBeW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAnbWFycXVlZV5bSFRNTEVsZW1lbnRdfGJlaGF2aW9yLGJnQ29sb3IsZGlyZWN0aW9uLGhlaWdodCwjaHNwYWNlLCNsb29wLCNzY3JvbGxBbW91bnQsI3Njcm9sbERlbGF5LCF0cnVlU3BlZWQsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ21lbnVeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ21ldGFeW0hUTUxFbGVtZW50XXxjb250ZW50LGh0dHBFcXVpdixuYW1lLHNjaGVtZScsXG4gICAgJ21ldGVyXltIVE1MRWxlbWVudF18I2hpZ2gsI2xvdywjbWF4LCNtaW4sI29wdGltdW0sI3ZhbHVlJyxcbiAgICAnaW5zLGRlbF5bSFRNTEVsZW1lbnRdfGNpdGUsZGF0ZVRpbWUnLFxuICAgICdvbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LCFyZXZlcnNlZCwjc3RhcnQsdHlwZScsXG4gICAgJ29iamVjdF5bSFRNTEVsZW1lbnRdfGFsaWduLGFyY2hpdmUsYm9yZGVyLGNvZGUsY29kZUJhc2UsY29kZVR5cGUsZGF0YSwhZGVjbGFyZSxoZWlnaHQsI2hzcGFjZSxuYW1lLHN0YW5kYnksdHlwZSx1c2VNYXAsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ29wdGdyb3VwXltIVE1MRWxlbWVudF18IWRpc2FibGVkLGxhYmVsJyxcbiAgICAnb3B0aW9uXltIVE1MRWxlbWVudF18IWRlZmF1bHRTZWxlY3RlZCwhZGlzYWJsZWQsbGFiZWwsIXNlbGVjdGVkLHRleHQsdmFsdWUnLFxuICAgICdvdXRwdXReW0hUTUxFbGVtZW50XXxkZWZhdWx0VmFsdWUsJWh0bWxGb3IsbmFtZSx2YWx1ZScsXG4gICAgJ3BeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ3BhcmFtXltIVE1MRWxlbWVudF18bmFtZSx0eXBlLHZhbHVlLHZhbHVlVHlwZScsXG4gICAgJ3BpY3R1cmVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdwcmVeW0hUTUxFbGVtZW50XXwjd2lkdGgnLFxuICAgICdwcm9ncmVzc15bSFRNTEVsZW1lbnRdfCNtYXgsI3ZhbHVlJyxcbiAgICAncSxibG9ja3F1b3RlLGNpdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdzY3JpcHReW0hUTUxFbGVtZW50XXwhYXN5bmMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRlZmVyLGV2ZW50LGh0bWxGb3IsaW50ZWdyaXR5LHNyYyx0ZXh0LHR5cGUnLFxuICAgICdzZWxlY3ReW0hUTUxFbGVtZW50XXxhdXRvY29tcGxldGUsIWF1dG9mb2N1cywhZGlzYWJsZWQsI2xlbmd0aCwhbXVsdGlwbGUsbmFtZSwhcmVxdWlyZWQsI3NlbGVjdGVkSW5kZXgsI3NpemUsdmFsdWUnLFxuICAgICdzaGFkb3deW0hUTUxFbGVtZW50XXwnLFxuICAgICdzbG90XltIVE1MRWxlbWVudF18bmFtZScsXG4gICAgJ3NvdXJjZV5bSFRNTEVsZW1lbnRdfG1lZGlhLHNpemVzLHNyYyxzcmNzZXQsdHlwZScsXG4gICAgJ3NwYW5eW0hUTUxFbGVtZW50XXwnLFxuICAgICdzdHlsZV5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxtZWRpYSx0eXBlJyxcbiAgICAnY2FwdGlvbl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAndGgsdGReW0hUTUxFbGVtZW50XXxhYmJyLGFsaWduLGF4aXMsYmdDb2xvcixjaCxjaE9mZiwjY29sU3BhbixoZWFkZXJzLGhlaWdodCwhbm9XcmFwLCNyb3dTcGFuLHNjb3BlLHZBbGlnbix3aWR0aCcsXG4gICAgJ2NvbCxjb2xncm91cF5bSFRNTEVsZW1lbnRdfGFsaWduLGNoLGNoT2ZmLCNzcGFuLHZBbGlnbix3aWR0aCcsXG4gICAgJ3RhYmxlXltIVE1MRWxlbWVudF18YWxpZ24sYmdDb2xvcixib3JkZXIsJWNhcHRpb24sY2VsbFBhZGRpbmcsY2VsbFNwYWNpbmcsZnJhbWUscnVsZXMsc3VtbWFyeSwldEZvb3QsJXRIZWFkLHdpZHRoJyxcbiAgICAndHJeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGNoLGNoT2ZmLHZBbGlnbicsXG4gICAgJ3Rmb290LHRoZWFkLHRib2R5XltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsdkFsaWduJyxcbiAgICAndGVtcGxhdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICd0ZXh0YXJlYV5bSFRNTEVsZW1lbnRdfGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSwhYXV0b2ZvY3VzLCNjb2xzLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwjbWF4TGVuZ3RoLCNtaW5MZW5ndGgsbmFtZSxwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLCNyb3dzLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCx2YWx1ZSx3cmFwJyxcbiAgICAndGl0bGVeW0hUTUxFbGVtZW50XXx0ZXh0JyxcbiAgICAndHJhY2teW0hUTUxFbGVtZW50XXwhZGVmYXVsdCxraW5kLGxhYmVsLHNyYyxzcmNsYW5nJyxcbiAgICAndWxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCx0eXBlJyxcbiAgICAndW5rbm93bl5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3ZpZGVvXm1lZGlhfCNoZWlnaHQscG9zdGVyLCN3aWR0aCcsXG4gICAgJzpzdmc6YV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6YW5pbWF0ZV46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOmFuaW1hdGVNb3Rpb25eOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzphbmltYXRlVHJhbnNmb3JtXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6Y2lyY2xlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpjbGlwUGF0aF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6ZGVmc146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6ZGVzY146c3ZnOnwnLFxuICAgICc6c3ZnOmRpc2NhcmReOnN2Zzp8JyxcbiAgICAnOnN2ZzplbGxpcHNlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpmZUJsZW5kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb2xvck1hdHJpeF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29tcG9uZW50VHJhbnNmZXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbXBvc2l0ZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29udm9sdmVNYXRyaXheOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURpZmZ1c2VMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlRGlzcGxhY2VtZW50TWFwXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEaXN0YW50TGlnaHReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURyb3BTaGFkb3deOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUZsb29kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVGdW5jQV46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUZ1bmNCXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlRnVuY0deOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVGdW5jUl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUdhdXNzaWFuQmx1cl46c3ZnOnwnLFxuICAgICc6c3ZnOmZlSW1hZ2VeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1lcmdlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNZXJnZU5vZGVeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1vcnBob2xvZ3leOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU9mZnNldF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlUG9pbnRMaWdodF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BlY3VsYXJMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BvdExpZ2h0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUaWxlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUdXJidWxlbmNlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmlsdGVyXjpzdmc6fCcsXG4gICAgJzpzdmc6Zm9yZWlnbk9iamVjdF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6Z146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6aW1hZ2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOmxpbmVhckdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAnOnN2ZzptcGF0aF46c3ZnOnwnLFxuICAgICc6c3ZnOm1hcmtlcl46c3ZnOnwnLFxuICAgICc6c3ZnOm1hc2teOnN2Zzp8JyxcbiAgICAnOnN2ZzptZXRhZGF0YV46c3ZnOnwnLFxuICAgICc6c3ZnOnBhdGheOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnBhdHRlcm5eOnN2Zzp8JyxcbiAgICAnOnN2Zzpwb2x5Z29uXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2Zzpwb2x5bGluZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6cmFkaWFsR3JhZGllbnReOnN2ZzpncmFkaWVudHwnLFxuICAgICc6c3ZnOnJlY3ReOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnN2Z146c3ZnOmdyYXBoaWNzfCNjdXJyZW50U2NhbGUsI3pvb21BbmRQYW4nLFxuICAgICc6c3ZnOnNjcmlwdF46c3ZnOnx0eXBlJyxcbiAgICAnOnN2ZzpzZXReOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzpzdG9wXjpzdmc6fCcsXG4gICAgJzpzdmc6c3R5bGVeOnN2Zzp8IWRpc2FibGVkLG1lZGlhLHRpdGxlLHR5cGUnLFxuICAgICc6c3ZnOnN3aXRjaF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6c3ltYm9sXjpzdmc6fCcsXG4gICAgJzpzdmc6dHNwYW5eOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAnOnN2Zzp0ZXh0Xjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgJzpzdmc6dGV4dFBhdGheOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICc6c3ZnOnRpdGxlXjpzdmc6fCcsXG4gICAgJzpzdmc6dXNlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2Zzp2aWV3Xjpzdmc6fCN6b29tQW5kUGFuJyxcbiAgICAnZGF0YV5bSFRNTEVsZW1lbnRdfHZhbHVlJyxcbiAgICAna2V5Z2VuXltIVE1MRWxlbWVudF18IWF1dG9mb2N1cyxjaGFsbGVuZ2UsIWRpc2FibGVkLGZvcm0sa2V5dHlwZSxuYW1lJyxcbiAgICAnbWVudWl0ZW1eW0hUTUxFbGVtZW50XXx0eXBlLGxhYmVsLGljb24sIWRpc2FibGVkLCFjaGVja2VkLHJhZGlvZ3JvdXAsIWRlZmF1bHQnLFxuICAgICdzdW1tYXJ5XltIVE1MRWxlbWVudF18JyxcbiAgICAndGltZV5bSFRNTEVsZW1lbnRdfGRhdGVUaW1lJyxcbiAgICAnOnN2ZzpjdXJzb3JeOnN2Zzp8Jyxcbl07XG5jb25zdCBfQVRUUl9UT19QUk9QID0ge1xuICAgICdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICAgICdmb3InOiAnaHRtbEZvcicsXG4gICAgJ2Zvcm1hY3Rpb24nOiAnZm9ybUFjdGlvbicsXG4gICAgJ2lubmVySHRtbCc6ICdpbm5lckhUTUwnLFxuICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4Jyxcbn07XG4vLyBJbnZlcnQgX0FUVFJfVE9fUFJPUC5cbmNvbnN0IF9QUk9QX1RPX0FUVFIgPSBPYmplY3Qua2V5cyhfQVRUUl9UT19QUk9QKS5yZWR1Y2UoKGludmVydGVkLCBhdHRyKSA9PiB7XG4gICAgaW52ZXJ0ZWRbX0FUVFJfVE9fUFJPUFthdHRyXV0gPSBhdHRyO1xuICAgIHJldHVybiBpbnZlcnRlZDtcbn0sIHt9KTtcbmNsYXNzIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSBleHRlbmRzIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3NjaGVtYSA9IHt9O1xuICAgICAgICAvLyBXZSBkb24ndCBhbGxvdyBiaW5kaW5nIHRvIGV2ZW50cyBmb3Igc2VjdXJpdHkgcmVhc29ucy4gQWxsb3dpbmcgZXZlbnQgYmluZGluZ3Mgd291bGQgYWxtb3N0XG4gICAgICAgIC8vIGNlcnRhaW5seSBpbnRyb2R1Y2UgYmFkIFhTUyB2dWxuZXJhYmlsaXRpZXMuIEluc3RlYWQsIHdlIHN0b3JlIGV2ZW50cyBpbiBhIHNlcGFyYXRlIHNjaGVtYS5cbiAgICAgICAgdGhpcy5fZXZlbnRTY2hlbWEgPSB7fTtcbiAgICAgICAgU0NIRU1BLmZvckVhY2goZW5jb2RlZFR5cGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHt9O1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3QgW3N0clR5cGUsIHN0clByb3BlcnRpZXNdID0gZW5jb2RlZFR5cGUuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBzdHJQcm9wZXJ0aWVzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBjb25zdCBbdHlwZU5hbWVzLCBzdXBlck5hbWVdID0gc3RyVHlwZS5zcGxpdCgnXicpO1xuICAgICAgICAgICAgdHlwZU5hbWVzLnNwbGl0KCcsJykuZm9yRWFjaCh0YWcgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVtYVt0YWcudG9Mb3dlckNhc2UoKV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50U2NoZW1hW3RhZy50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50cztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3VwZXJUeXBlID0gc3VwZXJOYW1lICYmIHRoaXMuX3NjaGVtYVtzdXBlck5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAoc3VwZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3VwZXJUeXBlKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcF0gPSBzdXBlclR5cGVbcHJvcF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdXBlckV2ZW50IG9mIHRoaXMuX2V2ZW50U2NoZW1hW3N1cGVyTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKHN1cGVyRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKHByb3BlcnR5LnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBCT09MRUFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gTlVNQkVSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gT0JKRUNUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5XSA9IFNUUklORztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFzUHJvcGVydHkodGFnTmFtZSwgcHJvcE5hbWUsIHNjaGVtYU1ldGFzKSB7XG4gICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKChzY2hlbWEpID0+IHNjaGVtYS5uYW1lID09PSBOT19FUlJPUlNfU0NIRU1BLm5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgaWYgKGlzTmdDb250YWluZXIodGFnTmFtZSkgfHwgaXNOZ0NvbnRlbnQodGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZSgoc2NoZW1hKSA9PiBzY2hlbWEubmFtZSA9PT0gQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIENhbid0IHRlbGwgbm93IGFzIHdlIGRvbid0IGtub3cgd2hpY2ggcHJvcGVydGllcyBhIGN1c3RvbSBlbGVtZW50IHdpbGwgZ2V0XG4gICAgICAgICAgICAgICAgLy8gb25jZSBpdCBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50UHJvcGVydGllcyA9IHRoaXMuX3NjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IHRoaXMuX3NjaGVtYVsndW5rbm93biddO1xuICAgICAgICByZXR1cm4gISFlbGVtZW50UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgfVxuICAgIGhhc0VsZW1lbnQodGFnTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoKHNjaGVtYSkgPT4gc2NoZW1hLm5hbWUgPT09IE5PX0VSUk9SU19TQ0hFTUEubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNOZ0NvbnRhaW5lcih0YWdOYW1lKSB8fCBpc05nQ29udGVudCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoKHNjaGVtYSkgPT4gc2NoZW1hLm5hbWUgPT09IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbnkgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhdGhpcy5fc2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNlY3VyaXR5Q29udGV4dCByZXR1cm5zIHRoZSBzZWN1cml0eSBjb250ZXh0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgb24gdGhlIGdpdmVuIERPTSB0YWcuXG4gICAgICpcbiAgICAgKiBUYWcgYW5kIHByb3BlcnR5IG5hbWUgYXJlIHN0YXRpY2FsbHkga25vd24gYW5kIGNhbm5vdCBjaGFuZ2UgYXQgcnVudGltZSwgaS5lLiBpdCBpcyBub3RcbiAgICAgKiBwb3NzaWJsZSB0byBiaW5kIGEgdmFsdWUgaW50byBhIGNoYW5naW5nIGF0dHJpYnV0ZSBvciB0YWcgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSBmaWx0ZXJpbmcgaXMgYmFzZWQgb24gYSBsaXN0IG9mIGFsbG93ZWQgdGFnc3xhdHRyaWJ1dGVzLiBBbGwgYXR0cmlidXRlcyBpbiB0aGUgc2NoZW1hXG4gICAgICogYWJvdmUgYXJlIGFzc3VtZWQgdG8gaGF2ZSB0aGUgJ05PTkUnIHNlY3VyaXR5IGNvbnRleHQsIGkuZS4gdGhhdCB0aGV5IGFyZSBzYWZlIGluZXJ0XG4gICAgICogc3RyaW5nIHZhbHVlcy4gT25seSBzcGVjaWZpYyB3ZWxsIGtub3duIGF0dGFjayB2ZWN0b3JzIGFyZSBhc3NpZ25lZCB0aGVpciBhcHByb3ByaWF0ZSBjb250ZXh0LlxuICAgICAqL1xuICAgIHNlY3VyaXR5Q29udGV4dCh0YWdOYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAvLyBOQjogRm9yIHNlY3VyaXR5IHB1cnBvc2VzLCB1c2UgdGhlIG1hcHBlZCBwcm9wZXJ0eSBuYW1lLCBub3QgdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAgICAgICAgcHJvcE5hbWUgPSB0aGlzLmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgY29tcGFyaXNvbnMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIHNvIHRoYXQgY2FzZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGF0dHJpYnV0ZSBhbmRcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IGN0eCA9IFNFQ1VSSVRZX1NDSEVNQSgpW3RhZ05hbWUgKyAnfCcgKyBwcm9wTmFtZV07XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gU0VDVVJJVFlfU0NIRU1BKClbJyp8JyArIHByb3BOYW1lXTtcbiAgICAgICAgcmV0dXJuIGN0eCA/IGN0eCA6IFNlY3VyaXR5Q29udGV4dC5OT05FO1xuICAgIH1cbiAgICBnZXRNYXBwZWRQcm9wTmFtZShwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gX0FUVFJfVE9fUFJPUFtwcm9wTmFtZV0gfHwgcHJvcE5hbWU7XG4gICAgfVxuICAgIGdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICduZy1jb21wb25lbnQnO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BlcnR5KG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgQmluZGluZyB0byBldmVudCBwcm9wZXJ0eSAnJHtuYW1lfScgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgYCArXG4gICAgICAgICAgICAgICAgYHBsZWFzZSB1c2UgKCR7bmFtZS5zbGljZSgyKX0pPS4uLmAgK1xuICAgICAgICAgICAgICAgIGBcXG5JZiAnJHtuYW1lfScgaXMgYSBkaXJlY3RpdmUgaW5wdXQsIG1ha2Ugc3VyZSB0aGUgZGlyZWN0aXZlIGlzIGltcG9ydGVkIGJ5IHRoZWAgK1xuICAgICAgICAgICAgICAgIGAgY3VycmVudCBtb2R1bGUuYDtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBCaW5kaW5nIHRvIGV2ZW50IGF0dHJpYnV0ZSAnJHtuYW1lfScgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgYCArXG4gICAgICAgICAgICAgICAgYHBsZWFzZSB1c2UgKCR7bmFtZS5zbGljZSgyKX0pPS4uLmA7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFsbEtub3duRWxlbWVudE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc2NoZW1hKTtcbiAgICB9XG4gICAgYWxsS25vd25BdHRyaWJ1dGVzT2ZFbGVtZW50KHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BlcnRpZXMgPSB0aGlzLl9zY2hlbWFbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCB0aGlzLl9zY2hlbWFbJ3Vua25vd24nXTtcbiAgICAgICAgLy8gQ29udmVydCBwcm9wZXJ0aWVzIHRvIGF0dHJpYnV0ZXMuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlbGVtZW50UHJvcGVydGllcykubWFwKHByb3AgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBfUFJPUF9UT19BVFRSW3Byb3BdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm9wOyB9KTtcbiAgICB9XG4gICAgYWxsS25vd25FdmVudHNPZkVsZW1lbnQodGFnTmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKChfYSA9IHRoaXMuX2V2ZW50U2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcbiAgICB9XG4gICAgbm9ybWFsaXplQW5pbWF0aW9uU3R5bGVQcm9wZXJ0eShwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wTmFtZSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlVmFsdWUoY2FtZWxDYXNlUHJvcCwgdXNlclByb3ZpZGVkUHJvcCwgdmFsKSB7XG4gICAgICAgIGxldCB1bml0ID0gJyc7XG4gICAgICAgIGNvbnN0IHN0clZhbCA9IHZhbC50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgbGV0IGVycm9yTXNnID0gbnVsbDtcbiAgICAgICAgaWYgKF9pc1BpeGVsRGltZW5zaW9uU3R5bGUoY2FtZWxDYXNlUHJvcCkgJiYgdmFsICE9PSAwICYmIHZhbCAhPT0gJzAnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbEFuZFN1ZmZpeE1hdGNoID0gdmFsLm1hdGNoKC9eWystXT9bXFxkXFwuXSsoW2Etel0qKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsQW5kU3VmZml4TWF0Y2ggJiYgdmFsQW5kU3VmZml4TWF0Y2hbMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgPSBgUGxlYXNlIHByb3ZpZGUgYSBDU1MgdW5pdCB2YWx1ZSBmb3IgJHt1c2VyUHJvdmlkZWRQcm9wfToke3ZhbH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyb3JNc2csIHZhbHVlOiBzdHJWYWwgKyB1bml0IH07XG4gICAgfVxufVxuZnVuY3Rpb24gX2lzUGl4ZWxEaW1lbnNpb25TdHlsZShwcm9wKSB7XG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWluV2lkdGgnOlxuICAgICAgICBjYXNlICdtaW5IZWlnaHQnOlxuICAgICAgICBjYXNlICdtYXhXaWR0aCc6XG4gICAgICAgIGNhc2UgJ21heEhlaWdodCc6XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNhc2UgJ2ZvbnRTaXplJzpcbiAgICAgICAgY2FzZSAnb3V0bGluZVdpZHRoJzpcbiAgICAgICAgY2FzZSAnb3V0bGluZU9mZnNldCc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdUb3AnOlxuICAgICAgICBjYXNlICdwYWRkaW5nTGVmdCc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdCb3R0b20nOlxuICAgICAgICBjYXNlICdwYWRkaW5nUmlnaHQnOlxuICAgICAgICBjYXNlICdtYXJnaW5Ub3AnOlxuICAgICAgICBjYXNlICdtYXJnaW5MZWZ0JzpcbiAgICAgICAgY2FzZSAnbWFyZ2luQm90dG9tJzpcbiAgICAgICAgY2FzZSAnbWFyZ2luUmlnaHQnOlxuICAgICAgICBjYXNlICdib3JkZXJSYWRpdXMnOlxuICAgICAgICBjYXNlICdib3JkZXJXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlclRvcFdpZHRoJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyTGVmdFdpZHRoJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyUmlnaHRXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlckJvdHRvbVdpZHRoJzpcbiAgICAgICAgY2FzZSAndGV4dEluZGVudCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBTZXQgb2YgdGFnTmFtZXxwcm9wZXJ0eU5hbWUgY29ycmVzcG9uZGluZyB0byBUcnVzdGVkIFR5cGVzIHNpbmtzLiBQcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIGFsbFxuICogdGFncyB1c2UgJyonLlxuICpcbiAqIEV4dHJhY3RlZCBmcm9tLCBhbmQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoXG4gKiBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXRydXN0ZWQtdHlwZXMvZGlzdC9zcGVjLyNpbnRlZ3JhdGlvbnNcbiAqL1xuY29uc3QgVFJVU1RFRF9UWVBFU19TSU5LUyA9IG5ldyBTZXQoW1xuICAgIC8vIE5PVEU6IEFsbCBzdHJpbmdzIGluIHRoaXMgc2V0ICptdXN0KiBiZSBsb3dlcmNhc2UhXG4gICAgLy8gVHJ1c3RlZEhUTUxcbiAgICAnaWZyYW1lfHNyY2RvYycsXG4gICAgJyp8aW5uZXJodG1sJyxcbiAgICAnKnxvdXRlcmh0bWwnLFxuICAgIC8vIE5COiBubyBUcnVzdGVkU2NyaXB0IGhlcmUsIGFzIHRoZSBjb3JyZXNwb25kaW5nIHRhZ3MgYXJlIHN0cmlwcGVkIGJ5IHRoZSBjb21waWxlci5cbiAgICAvLyBUcnVzdGVkU2NyaXB0VVJMXG4gICAgJ2VtYmVkfHNyYycsXG4gICAgJ29iamVjdHxjb2RlYmFzZScsXG4gICAgJ29iamVjdHxkYXRhJyxcbl0pO1xuLyoqXG4gKiBpc1RydXN0ZWRUeXBlc1NpbmsgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gRE9NIHRhZyBpcyBhIFRydXN0ZWQgVHlwZXNcbiAqIHNpbmsuIEluIHRoYXQgY2FzZSwgdXNlIGBFbGVtZW50U2NoZW1hUmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0YCB0byBkZXRlcm1pbmUgd2hpY2ggcGFydGljdWxhclxuICogVHJ1c3RlZCBUeXBlIGlzIHJlcXVpcmVkIGZvciB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBzaW5rOlxuICogLSBTZWN1cml0eUNvbnRleHQuSFRNTCBjb3JyZXNwb25kcyB0byBUcnVzdGVkSFRNTFxuICogLSBTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMIGNvcnJlc3BvbmRzIHRvIFRydXN0ZWRTY3JpcHRVUkxcbiAqL1xuZnVuY3Rpb24gaXNUcnVzdGVkVHlwZXNTaW5rKHRhZ05hbWUsIHByb3BOYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIGNvbXBhcmlzb25zIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBzbyB0aGF0IGNhc2UgZGlmZmVyZW5jZXMgYmV0d2VlbiBhdHRyaWJ1dGUgYW5kXG4gICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgdGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwcm9wTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIFRSVVNURURfVFlQRVNfU0lOS1MuaGFzKHRhZ05hbWUgKyAnfCcgKyBwcm9wTmFtZSkgfHxcbiAgICAgICAgVFJVU1RFRF9UWVBFU19TSU5LUy5oYXMoJyp8JyArIHByb3BOYW1lKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IgPSAnLic7XG5jb25zdCBBVFRSSUJVVEVfUFJFRklYID0gJ2F0dHInO1xuY29uc3QgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbmNvbnN0IFNUWUxFX1BSRUZJWCA9ICdzdHlsZSc7XG5jb25zdCBURU1QTEFURV9BVFRSX1BSRUZJWCQxID0gJyonO1xuY29uc3QgQU5JTUFURV9QUk9QX1BSRUZJWCA9ICdhbmltYXRlLSc7XG4vKipcbiAqIFBhcnNlcyBiaW5kaW5ncyBpbiB0ZW1wbGF0ZXMgYW5kIGluIHRoZSBkaXJlY3RpdmUgaG9zdCBhcmVhLlxuICovXG5jbGFzcyBCaW5kaW5nUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihfZXhwclBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcsIF9zY2hlbWFSZWdpc3RyeSwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIGdldCBpbnRlcnBvbGF0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICB9XG4gICAgY3JlYXRlQm91bmRIb3N0UHJvcGVydGllcyhwcm9wZXJ0aWVzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eUJpbmRpbmcocHJvcE5hbWUsIGV4cHJlc3Npb24sIHRydWUsIHNvdXJjZVNwYW4sIHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0LCB1bmRlZmluZWQsIFtdLCBcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGBzb3VyY2VTcGFuYCBmb3IgIGBrZXlTcGFuYC4gVGhpcyBpc24ndCByZWFsbHkgYWNjdXJhdGUsIGJ1dCBuZWl0aGVyIGlzIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNvdXJjZVNwYW4sIGFzIGl0IHJlcHJlc2VudHMgdGhlIHNvdXJjZVNwYW4gb2YgdGhlIGhvc3QgaXRzZWxmIHJhdGhlciB0aGFuIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNvdXJjZSBvZiB0aGUgaG9zdCBiaW5kaW5nICh3aGljaCBkb2Vzbid0IGV4aXN0IGluIHRoZSB0ZW1wbGF0ZSkuIFJlZ2FyZGxlc3MsXG4gICAgICAgICAgICAgICAgLy8gbmVpdGhlciBvZiB0aGVzZSB2YWx1ZXMgYXJlIHVzZWQgaW4gSXZ5IGJ1dCBhcmUgb25seSBoZXJlIHRvIHNhdGlzZnkgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gc2lnbmF0dXJlLiBUaGlzIHNob3VsZCBsaWtlbHkgYmUgcmVmYWN0b3JlZCBpbiB0aGUgZnV0dXJlIHNvIHRoYXQgYHNvdXJjZVNwYW5gXG4gICAgICAgICAgICAgICAgLy8gaXNuJ3QgYmVpbmcgdXNlZCBpbmFjY3VyYXRlbHkuXG4gICAgICAgICAgICAgICAgYm91bmRQcm9wcywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgVmFsdWUgb2YgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZyBcIiR7cHJvcE5hbWV9XCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcIiR7ZXhwcmVzc2lvbn1cIiAoJHt0eXBlb2YgZXhwcmVzc2lvbn0pYCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kUHJvcHM7XG4gICAgfVxuICAgIGNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoaG9zdExpc3RlbmVycywgc291cmNlU3Bhbikge1xuICAgICAgICBjb25zdCB0YXJnZXRFdmVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBPYmplY3Qua2V5cyhob3N0TGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGhvc3RMaXN0ZW5lcnNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgYHNvdXJjZVNwYW5gIGZvciAgYGtleVNwYW5gIGFuZCBgaGFuZGxlclNwYW5gLiBUaGlzIGlzbid0IHJlYWxseSBhY2N1cmF0ZSwgYnV0XG4gICAgICAgICAgICAgICAgLy8gbmVpdGhlciBpcyB0aGUgYHNvdXJjZVNwYW5gLCBhcyBpdCByZXByZXNlbnRzIHRoZSBgc291cmNlU3BhbmAgb2YgdGhlIGhvc3QgaXRzZWxmXG4gICAgICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gdGhlIHNvdXJjZSBvZiB0aGUgaG9zdCBiaW5kaW5nICh3aGljaCBkb2Vzbid0IGV4aXN0IGluIHRoZSB0ZW1wbGF0ZSkuXG4gICAgICAgICAgICAgICAgLy8gUmVnYXJkbGVzcywgbmVpdGhlciBvZiB0aGVzZSB2YWx1ZXMgYXJlIHVzZWQgaW4gSXZ5IGJ1dCBhcmUgb25seSBoZXJlIHRvIHNhdGlzZnkgdGhlXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gc2lnbmF0dXJlLiBUaGlzIHNob3VsZCBsaWtlbHkgYmUgcmVmYWN0b3JlZCBpbiB0aGUgZnV0dXJlIHNvIHRoYXQgYHNvdXJjZVNwYW5gXG4gICAgICAgICAgICAgICAgLy8gaXNuJ3QgYmVpbmcgdXNlZCBpbmFjY3VyYXRlbHkuXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUV2ZW50KHByb3BOYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBzb3VyY2VTcGFuLCBbXSwgdGFyZ2V0RXZlbnRzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBWYWx1ZSBvZiB0aGUgaG9zdCBsaXN0ZW5lciBcIiR7cHJvcE5hbWV9XCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcIiR7ZXhwcmVzc2lvbn1cIiAoJHt0eXBlb2YgZXhwcmVzc2lvbn0pYCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldEV2ZW50cztcbiAgICB9XG4gICAgcGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGFic29sdXRlT2Zmc2V0ID0gc291cmNlU3Bhbi5mdWxsU3RhcnQub2Zmc2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGAke2V9YCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBgcGFyc2VJbnRlcnBvbGF0aW9uYCwgYnV0IHRyZWF0cyB0aGUgcHJvdmlkZWQgc3RyaW5nIGFzIGEgc2luZ2xlIGV4cHJlc3Npb25cbiAgICAgKiBlbGVtZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYXBwZWFyIHdpdGhpbiB0aGUgaW50ZXJwb2xhdGlvbiBwcmVmaXggYW5kIHN1ZmZpeCAoYHt7YCBhbmQgYH19YCkuXG4gICAgICogVGhpcyBpcyB1c2VkIGZvciBwYXJzaW5nIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiBpbiBJQ1VzLlxuICAgICAqL1xuICAgIHBhcnNlSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oZXhwcmVzc2lvbiwgc291cmNlU3Bhbikge1xuICAgICAgICBjb25zdCBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBhYnNvbHV0ZU9mZnNldCA9IHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUludGVycG9sYXRpb25FeHByZXNzaW9uKGV4cHJlc3Npb24sIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGAke2V9YCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBiaW5kaW5ncyBpbiBhIG1pY3Jvc3ludGF4IGV4cHJlc3Npb24sIGFuZCBjb252ZXJ0cyB0aGVtIHRvXG4gICAgICogYFBhcnNlZFByb3BlcnR5YCBvciBgUGFyc2VkVmFyaWFibGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRwbEtleSB0ZW1wbGF0ZSBiaW5kaW5nIG5hbWVcbiAgICAgKiBAcGFyYW0gdHBsVmFsdWUgdGVtcGxhdGUgYmluZGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuIHNwYW4gb2YgdGVtcGxhdGUgYmluZGluZyByZWxhdGl2ZSB0byBlbnRpcmUgdGhlIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIGFic29sdXRlVmFsdWVPZmZzZXQgc3RhcnQgb2YgdGhlIHRwbFZhbHVlIHJlbGF0aXZlIHRvIHRoZSBlbnRpcmUgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TWF0Y2hhYmxlQXR0cnMgcG90ZW50aWFsIGF0dHJpYnV0ZXMgdG8gbWF0Y2ggaW4gdGhlIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHRhcmdldFByb3BzIHRhcmdldCBwcm9wZXJ0eSBiaW5kaW5ncyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gdGFyZ2V0VmFycyB0YXJnZXQgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAqL1xuICAgIHBhcnNlSW5saW5lVGVtcGxhdGVCaW5kaW5nKHRwbEtleSwgdHBsVmFsdWUsIHNvdXJjZVNwYW4sIGFic29sdXRlVmFsdWVPZmZzZXQsIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywgdGFyZ2V0VmFycywgaXNJdnlBc3QpIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVLZXlPZmZzZXQgPSBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCArIFRFTVBMQVRFX0FUVFJfUFJFRklYJDEubGVuZ3RoO1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IHRoaXMuX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyh0cGxLZXksIHRwbFZhbHVlLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZUtleU9mZnNldCwgYWJzb2x1dGVWYWx1ZU9mZnNldCk7XG4gICAgICAgIGZvciAoY29uc3QgYmluZGluZyBvZiBiaW5kaW5ncykge1xuICAgICAgICAgICAgLy8gc291cmNlU3BhbiBpcyBmb3IgdGhlIGVudGlyZSBIVE1MIGF0dHJpYnV0ZS4gYmluZGluZ1NwYW4gaXMgZm9yIGEgcGFydGljdWxhclxuICAgICAgICAgICAgLy8gYmluZGluZyB3aXRoaW4gdGhlIG1pY3Jvc3ludGF4IGV4cHJlc3Npb24gc28gaXQncyBtb3JlIG5hcnJvdyB0aGFuIHNvdXJjZVNwYW4uXG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nU3BhbiA9IG1vdmVQYXJzZVNvdXJjZVNwYW4oc291cmNlU3BhbiwgYmluZGluZy5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGJpbmRpbmcua2V5LnNvdXJjZTtcbiAgICAgICAgICAgIGNvbnN0IGtleVNwYW4gPSBtb3ZlUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4sIGJpbmRpbmcua2V5LnNwYW4pO1xuICAgICAgICAgICAgaWYgKGJpbmRpbmcgaW5zdGFuY2VvZiBWYXJpYWJsZUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGJpbmRpbmcudmFsdWUgPyBiaW5kaW5nLnZhbHVlLnNvdXJjZSA6ICckaW1wbGljaXQnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlU3BhbiA9IGJpbmRpbmcudmFsdWUgPyBtb3ZlUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4sIGJpbmRpbmcudmFsdWUuc3BhbikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFycy5wdXNoKG5ldyBQYXJzZWRWYXJpYWJsZShrZXksIHZhbHVlLCBiaW5kaW5nU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kaW5nLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3JjU3BhbiA9IGlzSXZ5QXN0ID8gYmluZGluZ1NwYW4gOiBzb3VyY2VTcGFuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlU3BhbiA9IG1vdmVQYXJzZVNvdXJjZVNwYW4oc291cmNlU3BhbiwgYmluZGluZy52YWx1ZS5hc3Quc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChrZXksIGJpbmRpbmcudmFsdWUsIHNyY1NwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW2tleSwgJycgLyogdmFsdWUgKi9dKTtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgbGl0ZXJhbCBhdHRyaWJ1dGUgd2l0aCBubyBSSFMsIHNvdXJjZSBzcGFuIHNob3VsZCBiZVxuICAgICAgICAgICAgICAgIC8vIGp1c3QgdGhlIGtleSBzcGFuLlxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VMaXRlcmFsQXR0cihrZXksIG51bGwgLyogdmFsdWUgKi8sIGtleVNwYW4sIGFic29sdXRlVmFsdWVPZmZzZXQsIHVuZGVmaW5lZCAvKiB2YWx1ZVNwYW4gKi8sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywga2V5U3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBiaW5kaW5ncyBpbiBhIG1pY3Jvc3ludGF4IGV4cHJlc3Npb24sIGUuZy5cbiAgICAgKiBgYGBcbiAgICAgKiAgICA8dGFnICp0cGxLZXk9XCJsZXQgdmFsdWUxID0gcHJvcDsgbGV0IHZhbHVlMiA9IGxvY2FsVmFyXCI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHBsS2V5IHRlbXBsYXRlIGJpbmRpbmcgbmFtZVxuICAgICAqIEBwYXJhbSB0cGxWYWx1ZSB0ZW1wbGF0ZSBiaW5kaW5nIHZhbHVlXG4gICAgICogQHBhcmFtIHNvdXJjZVNwYW4gc3BhbiBvZiB0ZW1wbGF0ZSBiaW5kaW5nIHJlbGF0aXZlIHRvIGVudGlyZSB0aGUgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVLZXlPZmZzZXQgc3RhcnQgb2YgdGhlIGB0cGxLZXlgXG4gICAgICogQHBhcmFtIGFic29sdXRlVmFsdWVPZmZzZXQgc3RhcnQgb2YgdGhlIGB0cGxWYWx1ZWBcbiAgICAgKi9cbiAgICBfcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRwbEtleSwgdHBsVmFsdWUsIHNvdXJjZVNwYW4sIGFic29sdXRlS2V5T2Zmc2V0LCBhYnNvbHV0ZVZhbHVlT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nc1Jlc3VsdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRwbEtleSwgdHBsVmFsdWUsIHNvdXJjZUluZm8sIGFic29sdXRlS2V5T2Zmc2V0LCBhYnNvbHV0ZVZhbHVlT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYmluZGluZ3NSZXN1bHQuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIGJpbmRpbmdzUmVzdWx0Lndhcm5pbmdzLmZvckVhY2goKHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcih3YXJuaW5nLCBzb3VyY2VTcGFuLCBQYXJzZUVycm9yTGV2ZWwuV0FSTklORyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBiaW5kaW5nc1Jlc3VsdC50ZW1wbGF0ZUJpbmRpbmdzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgJHtlfWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlTGl0ZXJhbEF0dHIobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywga2V5U3Bhbikge1xuICAgICAgICBpZiAoaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKGtleVNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGtleVNwYW4gPSBtb3ZlUGFyc2VTb3VyY2VTcGFuKGtleVNwYW4sIG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oa2V5U3Bhbi5zdGFydC5vZmZzZXQgKyAxLCBrZXlTcGFuLmVuZC5vZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBBc3NpZ25pbmcgYW5pbWF0aW9uIHRyaWdnZXJzIHZpYSBAcHJvcD1cImV4cFwiIGF0dHJpYnV0ZXMgd2l0aCBhbiBleHByZXNzaW9uIGlzIGludmFsaWQuYCArXG4gICAgICAgICAgICAgICAgICAgIGAgVXNlIHByb3BlcnR5IGJpbmRpbmdzIChlLmcuIFtAcHJvcF09XCJleHBcIikgb3IgdXNlIGFuIGF0dHJpYnV0ZSB3aXRob3V0IGEgdmFsdWUgKGUuZy4gQHByb3ApIGluc3RlYWQuYCwgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLkVSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwga2V5U3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgUGFyc2VkUHJvcGVydHkobmFtZSwgdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSh2YWx1ZSwgJycsIGFic29sdXRlT2Zmc2V0KSwgUGFyc2VkUHJvcGVydHlUeXBlLkxJVEVSQUxfQVRUUiwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VQcm9wZXJ0eUJpbmRpbmcobmFtZSwgZXhwcmVzc2lvbiwgaXNIb3N0LCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIGtleVNwYW4pIHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgUHJvcGVydHkgbmFtZSBpcyBtaXNzaW5nIGluIGJpbmRpbmdgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNBbmltYXRpb25Qcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoQU5JTUFURV9QUk9QX1BSRUZJWCkpIHtcbiAgICAgICAgICAgIGlzQW5pbWF0aW9uUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoQU5JTUFURV9QUk9QX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGtleVNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGtleVNwYW4gPSBtb3ZlUGFyc2VTb3VyY2VTcGFuKGtleVNwYW4sIG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oa2V5U3Bhbi5zdGFydC5vZmZzZXQgKyBBTklNQVRFX1BST1BfUFJFRklYLmxlbmd0aCwga2V5U3Bhbi5lbmQub2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBbmltYXRpb25MYWJlbChuYW1lKSkge1xuICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGlmIChrZXlTcGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrZXlTcGFuID0gbW92ZVBhcnNlU291cmNlU3BhbihrZXlTcGFuLCBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGtleVNwYW4uc3RhcnQub2Zmc2V0ICsgMSwga2V5U3Bhbi5lbmQub2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uUHJvcCkge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb24obmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGtleVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24sIGlzSG9zdCwgdmFsdWVTcGFuIHx8IHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0KSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywga2V5U3Bhbikge1xuICAgICAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHZhbHVlU3BhbiB8fCBzb3VyY2VTcGFuKTtcbiAgICAgICAgaWYgKGV4cHIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgZXhwciwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCBhc3QsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgUGFyc2VkUHJvcGVydHkobmFtZSwgYXN0LCBQYXJzZWRQcm9wZXJ0eVR5cGUuREVGQVVMVCwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgfVxuICAgIF9wYXJzZUFuaW1hdGlvbihuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwga2V5U3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcignQW5pbWF0aW9uIHRyaWdnZXIgaXMgbWlzc2luZycsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgd2lsbCBvY2N1ciB3aGVuIGEgQHRyaWdnZXIgaXMgbm90IHBhaXJlZCB3aXRoIGFuIGV4cHJlc3Npb24uXG4gICAgICAgIC8vIEZvciBhbmltYXRpb25zIGl0IGlzIHZhbGlkIHRvIG5vdCBoYXZlIGFuIGV4cHJlc3Npb24gc2luY2UgKi92b2lkXG4gICAgICAgIC8vIHN0YXRlcyB3aWxsIGJlIGFwcGxpZWQgYnkgYW5ndWxhciB3aGVuIHRoZSBlbGVtZW50IGlzIGF0dGFjaGVkL2RldGFjaGVkXG4gICAgICAgIGNvbnN0IGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uIHx8ICd1bmRlZmluZWQnLCBmYWxzZSwgdmFsdWVTcGFuIHx8IHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBQYXJzZWRQcm9wZXJ0eShuYW1lLCBhc3QsIFBhcnNlZFByb3BlcnR5VHlwZS5BTklNQVRJT04sIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbikpO1xuICAgIH1cbiAgICBfcGFyc2VCaW5kaW5nKHZhbHVlLCBpc0hvc3RCaW5kaW5nLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBzb3VyY2VJbmZvID0gKHNvdXJjZVNwYW4gJiYgc291cmNlU3Bhbi5zdGFydCB8fCAnKHVua25vd24pJykudG9TdHJpbmcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IGlzSG9zdEJpbmRpbmcgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VTaW1wbGVCaW5kaW5nKHZhbHVlLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykgOlxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJQYXJzZXIucGFyc2VCaW5kaW5nKHZhbHVlLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoYXN0KVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgJHtlfWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUJvdW5kRWxlbWVudFByb3BlcnR5KGVsZW1lbnRTZWxlY3RvciwgYm91bmRQcm9wLCBza2lwVmFsaWRhdGlvbiA9IGZhbHNlLCBtYXBQcm9wZXJ0eU5hbWUgPSB0cnVlKSB7XG4gICAgICAgIGlmIChib3VuZFByb3AuaXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQm91bmRFbGVtZW50UHJvcGVydHkoYm91bmRQcm9wLm5hbWUsIDQgLyogQW5pbWF0aW9uICovLCBTZWN1cml0eUNvbnRleHQuTk9ORSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIG51bGwsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCBib3VuZFByb3Aua2V5U3BhbiwgYm91bmRQcm9wLnZhbHVlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVuaXQgPSBudWxsO1xuICAgICAgICBsZXQgYmluZGluZ1R5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBib3VuZFByb3BlcnR5TmFtZSA9IG51bGw7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYm91bmRQcm9wLm5hbWUuc3BsaXQoUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SKTtcbiAgICAgICAgbGV0IHNlY3VyaXR5Q29udGV4dHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIENoZWNrIGZvciBzcGVjaWFsIGNhc2VzIChwcmVmaXggc3R5bGUsIGF0dHIsIGNsYXNzKVxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHBhcnRzWzBdID09IEFUVFJJQlVURV9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oUFJPUEVSVFlfUEFSVFNfU0VQQVJBVE9SKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUoYm91bmRQcm9wZXJ0eU5hbWUsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIGVsZW1lbnRTZWxlY3RvciwgYm91bmRQcm9wZXJ0eU5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5zU2VwYXJhdG9ySWR4ID0gYm91bmRQcm9wZXJ0eU5hbWUuaW5kZXhPZignOicpO1xuICAgICAgICAgICAgICAgIGlmIChuc1NlcGFyYXRvcklkeCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5zID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKDAsIG5zU2VwYXJhdG9ySWR4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGJvdW5kUHJvcGVydHlOYW1lLnN1YnN0cmluZyhuc1NlcGFyYXRvcklkeCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IG1lcmdlTnNBbmROYW1lKG5zLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSAxIC8qIEF0dHJpYnV0ZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IENMQVNTX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSAyIC8qIENsYXNzICovO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBbU2VjdXJpdHlDb250ZXh0Lk5PTkVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydHNbMF0gPT0gU1RZTEVfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9IHBhcnRzLmxlbmd0aCA+IDIgPyBwYXJ0c1syXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IDMgLyogU3R5bGUgKi87XG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IFtTZWN1cml0eUNvbnRleHQuU1RZTEVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vdCBhIHNwZWNpYWwgY2FzZSwgdXNlIHRoZSBmdWxsIHByb3BlcnR5IG5hbWVcbiAgICAgICAgaWYgKGJvdW5kUHJvcGVydHlOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWRQcm9wTmFtZSA9IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LmdldE1hcHBlZFByb3BOYW1lKGJvdW5kUHJvcC5uYW1lKTtcbiAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gbWFwUHJvcGVydHlOYW1lID8gbWFwcGVkUHJvcE5hbWUgOiBib3VuZFByb3AubmFtZTtcbiAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCBlbGVtZW50U2VsZWN0b3IsIG1hcHBlZFByb3BOYW1lLCBmYWxzZSk7XG4gICAgICAgICAgICBiaW5kaW5nVHlwZSA9IDAgLyogUHJvcGVydHkgKi87XG4gICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShtYXBwZWRQcm9wTmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kRWxlbWVudFByb3BlcnR5KGJvdW5kUHJvcGVydHlOYW1lLCBiaW5kaW5nVHlwZSwgc2VjdXJpdHlDb250ZXh0c1swXSwgYm91bmRQcm9wLmV4cHJlc3Npb24sIHVuaXQsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCBib3VuZFByb3Aua2V5U3BhbiwgYm91bmRQcm9wLnZhbHVlU3Bhbik7XG4gICAgfVxuICAgIC8vIFRPRE86IGtleVNwYW4gc2hvdWxkIGJlIHJlcXVpcmVkIGJ1dCB3YXMgbWFkZSBvcHRpb25hbCB0byBhdm9pZCBjaGFuZ2luZyBWRSBwYXJzZXIuXG4gICAgcGFyc2VFdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cywga2V5U3Bhbikge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBFdmVudCBuYW1lIGlzIG1pc3NpbmcgaW4gYmluZGluZ2AsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkxhYmVsKG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICBpZiAoa2V5U3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAga2V5U3BhbiA9IG1vdmVQYXJzZVNvdXJjZVNwYW4oa2V5U3BhbiwgbmV3IEFic29sdXRlU291cmNlU3BhbihrZXlTcGFuLnN0YXJ0Lm9mZnNldCArIDEsIGtleVNwYW4uZW5kLm9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyc2VBbmltYXRpb25FdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0RXZlbnRzLCBrZXlTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUmVndWxhckV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzLCBrZXlTcGFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHNlbGVjdG9yLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgcmV0dXJuIGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIHNlbGVjdG9yLCBwcm9wLCBpc0F0dHJpYnV0ZSk7XG4gICAgfVxuICAgIF9wYXJzZUFuaW1hdGlvbkV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCB0YXJnZXRFdmVudHMsIGtleVNwYW4pIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNwbGl0QXRQZXJpb2QobmFtZSwgW25hbWUsICcnXSk7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IG1hdGNoZXNbMF07XG4gICAgICAgIGNvbnN0IHBoYXNlID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBhc3QgPSB0aGlzLl9wYXJzZUFjdGlvbihleHByZXNzaW9uLCBoYW5kbGVyU3Bhbik7XG4gICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBQYXJzZWRFdmVudChldmVudE5hbWUsIHBoYXNlLCAxIC8qIEFuaW1hdGlvbiAqLywgYXN0LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3Bhbiwga2V5U3BhbikpO1xuICAgICAgICBpZiAoZXZlbnROYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYEFuaW1hdGlvbiBldmVudCBuYW1lIGlzIG1pc3NpbmcgaW4gYmluZGluZ2AsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaGFzZSkge1xuICAgICAgICAgICAgaWYgKHBoYXNlICE9PSAnc3RhcnQnICYmIHBoYXNlICE9PSAnZG9uZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgVGhlIHByb3ZpZGVkIGFuaW1hdGlvbiBvdXRwdXQgcGhhc2UgdmFsdWUgXCIke3BoYXNlfVwiIGZvciBcIkAke2V2ZW50TmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkICh1c2Ugc3RhcnQgb3IgZG9uZSlgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBUaGUgYW5pbWF0aW9uIHRyaWdnZXIgb3V0cHV0IGV2ZW50IChAJHtldmVudE5hbWV9KSBpcyBtaXNzaW5nIGl0cyBwaGFzZSB2YWx1ZSBuYW1lIChzdGFydCBvciBkb25lIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkKWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wYXJzZVJlZ3VsYXJFdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cywga2V5U3Bhbikge1xuICAgICAgICAvLyBsb25nIGZvcm1hdDogJ3RhcmdldDogZXZlbnROYW1lJ1xuICAgICAgICBjb25zdCBbdGFyZ2V0LCBldmVudE5hbWVdID0gc3BsaXRBdENvbG9uKG5hbWUsIFtudWxsLCBuYW1lXSk7XG4gICAgICAgIGNvbnN0IGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIGhhbmRsZXJTcGFuKTtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICB0YXJnZXRFdmVudHMucHVzaChuZXcgUGFyc2VkRXZlbnQoZXZlbnROYW1lLCB0YXJnZXQsIDAgLyogUmVndWxhciAqLywgYXN0LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3Bhbiwga2V5U3BhbikpO1xuICAgICAgICAvLyBEb24ndCBkZXRlY3QgZGlyZWN0aXZlcyBmb3IgZXZlbnQgbmFtZXMgZm9yIG5vdyxcbiAgICAgICAgLy8gc28gZG9uJ3QgYWRkIHRoZSBldmVudCBuYW1lIHRvIHRoZSBtYXRjaGFibGVBdHRyc1xuICAgIH1cbiAgICBfcGFyc2VBY3Rpb24odmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgY29uc3Qgc291cmNlSW5mbyA9IChzb3VyY2VTcGFuICYmIHNvdXJjZVNwYW4uc3RhcnQgfHwgJyh1bmtub3duJykudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVPZmZzZXQgPSAoc291cmNlU3BhbiAmJiBzb3VyY2VTcGFuLnN0YXJ0KSA/IHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0IDogMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VBY3Rpb24odmFsdWUsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChhc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhc3QgfHwgYXN0LmFzdCBpbnN0YW5jZW9mIEVtcHR5RXhwcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBFbXB0eSBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWRgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgJHtlfWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZXBvcnRFcnJvcihtZXNzYWdlLCBzb3VyY2VTcGFuLCBsZXZlbCA9IFBhcnNlRXJyb3JMZXZlbC5FUlJPUikge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfVxuICAgIF9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGVycm9ycywgc291cmNlU3Bhbikge1xuICAgICAgICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3IubWVzc2FnZSwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHByb3BOYW1lIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSAvIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIGlzQXR0ciB0cnVlIHdoZW4gYmluZGluZyB0byBhbiBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBfdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShwcm9wTmFtZSwgc291cmNlU3BhbiwgaXNBdHRyKSB7XG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IGlzQXR0ciA/IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeS52YWxpZGF0ZVByb3BlcnR5KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHJlcG9ydC5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IocmVwb3J0Lm1zZywgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLkVSUk9SKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFBpcGVDb2xsZWN0b3IgZXh0ZW5kcyBSZWN1cnNpdmVBc3RWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5waXBlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdmlzaXRQaXBlKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnBpcGVzLnNldChhc3QubmFtZSwgYXN0KTtcbiAgICAgICAgYXN0LmV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQW5pbWF0aW9uTGFiZWwobmFtZSkge1xuICAgIHJldHVybiBuYW1lWzBdID09ICdAJztcbn1cbmZ1bmN0aW9uIGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHMocmVnaXN0cnksIHNlbGVjdG9yLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBjdHhzID0gW107XG4gICAgQ3NzU2VsZWN0b3IucGFyc2Uoc2VsZWN0b3IpLmZvckVhY2goKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnROYW1lcyA9IHNlbGVjdG9yLmVsZW1lbnQgPyBbc2VsZWN0b3IuZWxlbWVudF0gOiByZWdpc3RyeS5hbGxLbm93bkVsZW1lbnROYW1lcygpO1xuICAgICAgICBjb25zdCBub3RFbGVtZW50TmFtZXMgPSBuZXcgU2V0KHNlbGVjdG9yLm5vdFNlbGVjdG9ycy5maWx0ZXIoc2VsZWN0b3IgPT4gc2VsZWN0b3IuaXNFbGVtZW50U2VsZWN0b3IoKSlcbiAgICAgICAgICAgIC5tYXAoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5lbGVtZW50KSk7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlRWxlbWVudE5hbWVzID0gZWxlbWVudE5hbWVzLmZpbHRlcihlbGVtZW50TmFtZSA9PiAhbm90RWxlbWVudE5hbWVzLmhhcyhlbGVtZW50TmFtZSkpO1xuICAgICAgICBjdHhzLnB1c2goLi4ucG9zc2libGVFbGVtZW50TmFtZXMubWFwKGVsZW1lbnROYW1lID0+IHJlZ2lzdHJ5LnNlY3VyaXR5Q29udGV4dChlbGVtZW50TmFtZSwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjdHhzLmxlbmd0aCA9PT0gMCA/IFtTZWN1cml0eUNvbnRleHQuTk9ORV0gOiBBcnJheS5mcm9tKG5ldyBTZXQoY3R4cykpLnNvcnQoKTtcbn1cbi8qKlxuICogQ29tcHV0ZSBhIG5ldyBQYXJzZVNvdXJjZVNwYW4gYmFzZWQgb2ZmIGFuIG9yaWdpbmFsIGBzb3VyY2VTcGFuYCBieSB1c2luZ1xuICogYWJzb2x1dGUgb2Zmc2V0cyBmcm9tIHRoZSBzcGVjaWZpZWQgYGFic29sdXRlU3BhbmAuXG4gKlxuICogQHBhcmFtIHNvdXJjZVNwYW4gb3JpZ2luYWwgc291cmNlIHNwYW5cbiAqIEBwYXJhbSBhYnNvbHV0ZVNwYW4gYWJzb2x1dGUgc291cmNlIHNwYW4gdG8gbW92ZSB0b1xuICovXG5mdW5jdGlvbiBtb3ZlUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4sIGFic29sdXRlU3Bhbikge1xuICAgIC8vIFRoZSBkaWZmZXJlbmNlIG9mIHR3byBhYnNvbHV0ZSBvZmZzZXRzIHByb3ZpZGUgdGhlIHJlbGF0aXZlIG9mZnNldFxuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGFic29sdXRlU3Bhbi5zdGFydCAtIHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgIGNvbnN0IGVuZERpZmYgPSBhYnNvbHV0ZVNwYW4uZW5kIC0gc291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KHN0YXJ0RGlmZiksIHNvdXJjZVNwYW4uZW5kLm1vdmVCeShlbmREaWZmKSwgc291cmNlU3Bhbi5mdWxsU3RhcnQubW92ZUJ5KHN0YXJ0RGlmZiksIHNvdXJjZVNwYW4uZGV0YWlscyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gU29tZSBvZiB0aGUgY29kZSBjb21lcyBmcm9tIFdlYkNvbXBvbmVudHMuSlNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iL21hc3Rlci9zcmMvSFRNTEltcG9ydHMvcGF0aC5qc1xuZnVuY3Rpb24gaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSB7XG4gICAgaWYgKHVybCA9PSBudWxsIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09ICcvJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHNjaGVtZU1hdGNoID0gdXJsLm1hdGNoKFVSTF9XSVRIX1NDSEVNQV9SRUdFWFApO1xuICAgIHJldHVybiBzY2hlbWVNYXRjaCA9PT0gbnVsbCB8fCBzY2hlbWVNYXRjaFsxXSA9PSAncGFja2FnZScgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ2Fzc2V0Jztcbn1cbmNvbnN0IFVSTF9XSVRIX1NDSEVNQV9SRUdFWFAgPSAvXihbXjovPyNdKyk6LztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBOR19DT05URU5UX1NFTEVDVF9BVFRSJDEgPSAnc2VsZWN0JztcbmNvbnN0IExJTktfRUxFTUVOVCA9ICdsaW5rJztcbmNvbnN0IExJTktfU1RZTEVfUkVMX0FUVFIgPSAncmVsJztcbmNvbnN0IExJTktfU1RZTEVfSFJFRl9BVFRSID0gJ2hyZWYnO1xuY29uc3QgTElOS19TVFlMRV9SRUxfVkFMVUUgPSAnc3R5bGVzaGVldCc7XG5jb25zdCBTVFlMRV9FTEVNRU5UID0gJ3N0eWxlJztcbmNvbnN0IFNDUklQVF9FTEVNRU5UID0gJ3NjcmlwdCc7XG5jb25zdCBOR19OT05fQklOREFCTEVfQVRUUiA9ICduZ05vbkJpbmRhYmxlJztcbmNvbnN0IE5HX1BST0pFQ1RfQVMgPSAnbmdQcm9qZWN0QXMnO1xuZnVuY3Rpb24gcHJlcGFyc2VFbGVtZW50KGFzdCkge1xuICAgIGxldCBzZWxlY3RBdHRyID0gbnVsbDtcbiAgICBsZXQgaHJlZkF0dHIgPSBudWxsO1xuICAgIGxldCByZWxBdHRyID0gbnVsbDtcbiAgICBsZXQgbm9uQmluZGFibGUgPSBmYWxzZTtcbiAgICBsZXQgcHJvamVjdEFzID0gJyc7XG4gICAgYXN0LmF0dHJzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgIGNvbnN0IGxjQXR0ck5hbWUgPSBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxjQXR0ck5hbWUgPT0gTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUiQxKSB7XG4gICAgICAgICAgICBzZWxlY3RBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfSFJFRl9BVFRSKSB7XG4gICAgICAgICAgICBocmVmQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGNBdHRyTmFtZSA9PSBMSU5LX1NUWUxFX1JFTF9BVFRSKSB7XG4gICAgICAgICAgICByZWxBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfTk9OX0JJTkRBQkxFX0FUVFIpIHtcbiAgICAgICAgICAgIG5vbkJpbmRhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfUFJPSkVDVF9BUykge1xuICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHByb2plY3RBcyA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxlY3RBdHRyID0gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpO1xuICAgIGNvbnN0IG5vZGVOYW1lID0gYXN0Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk9USEVSO1xuICAgIGlmIChpc05nQ29udGVudChub2RlTmFtZSkpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNUWUxFX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTQ1JJUFRfRUxFTUVOVCkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBMSU5LX0VMRU1FTlQgJiYgcmVsQXR0ciA9PSBMSU5LX1NUWUxFX1JFTF9WQUxVRSkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKTtcbn1cbnZhciBQcmVwYXJzZWRFbGVtZW50VHlwZTtcbihmdW5jdGlvbiAoUHJlcGFyc2VkRWxlbWVudFR5cGUpIHtcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIk5HX0NPTlRFTlRcIl0gPSAwXSA9IFwiTkdfQ09OVEVOVFwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU1RZTEVcIl0gPSAxXSA9IFwiU1RZTEVcIjtcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIlNUWUxFU0hFRVRcIl0gPSAyXSA9IFwiU1RZTEVTSEVFVFwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU0NSSVBUXCJdID0gM10gPSBcIlNDUklQVFwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiT1RIRVJcIl0gPSA0XSA9IFwiT1RIRVJcIjtcbn0pKFByZXBhcnNlZEVsZW1lbnRUeXBlIHx8IChQcmVwYXJzZWRFbGVtZW50VHlwZSA9IHt9KSk7XG5jbGFzcyBQcmVwYXJzZWRFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlbGVjdEF0dHIgPSBzZWxlY3RBdHRyO1xuICAgICAgICB0aGlzLmhyZWZBdHRyID0gaHJlZkF0dHI7XG4gICAgICAgIHRoaXMubm9uQmluZGFibGUgPSBub25CaW5kYWJsZTtcbiAgICAgICAgdGhpcy5wcm9qZWN0QXMgPSBwcm9qZWN0QXM7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpIHtcbiAgICBpZiAoc2VsZWN0QXR0ciA9PT0gbnVsbCB8fCBzZWxlY3RBdHRyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyonO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0QXR0cjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBCSU5EX05BTUVfUkVHRVhQID0gL14oPzooYmluZC0pfChsZXQtKXwocmVmLXwjKXwob24tKXwoYmluZG9uLSl8KEApKSguKikkLztcbi8vIEdyb3VwIDEgPSBcImJpbmQtXCJcbmNvbnN0IEtXX0JJTkRfSURYID0gMTtcbi8vIEdyb3VwIDIgPSBcImxldC1cIlxuY29uc3QgS1dfTEVUX0lEWCA9IDI7XG4vLyBHcm91cCAzID0gXCJyZWYtLyNcIlxuY29uc3QgS1dfUkVGX0lEWCA9IDM7XG4vLyBHcm91cCA0ID0gXCJvbi1cIlxuY29uc3QgS1dfT05fSURYID0gNDtcbi8vIEdyb3VwIDUgPSBcImJpbmRvbi1cIlxuY29uc3QgS1dfQklORE9OX0lEWCA9IDU7XG4vLyBHcm91cCA2ID0gXCJAXCJcbmNvbnN0IEtXX0FUX0lEWCA9IDY7XG4vLyBHcm91cCA3ID0gdGhlIGlkZW50aWZpZXIgYWZ0ZXIgXCJiaW5kLVwiLCBcImxldC1cIiwgXCJyZWYtLyNcIiwgXCJvbi1cIiwgXCJiaW5kb24tXCIgb3IgXCJAXCJcbmNvbnN0IElERU5UX0tXX0lEWCA9IDc7XG5jb25zdCBCSU5ESU5HX0RFTElNUyA9IHtcbiAgICBCQU5BTkFfQk9YOiB7IHN0YXJ0OiAnWygnLCBlbmQ6ICcpXScgfSxcbiAgICBQUk9QRVJUWTogeyBzdGFydDogJ1snLCBlbmQ6ICddJyB9LFxuICAgIEVWRU5UOiB7IHN0YXJ0OiAnKCcsIGVuZDogJyknIH0sXG59O1xuY29uc3QgVEVNUExBVEVfQVRUUl9QUkVGSVggPSAnKic7XG5mdW5jdGlvbiBodG1sQXN0VG9SZW5kZXIzQXN0KGh0bWxOb2RlcywgYmluZGluZ1BhcnNlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gbmV3IEh0bWxBc3RUb0l2eUFzdChiaW5kaW5nUGFyc2VyLCBvcHRpb25zKTtcbiAgICBjb25zdCBpdnlOb2RlcyA9IHZpc2l0QWxsKHRyYW5zZm9ybWVyLCBodG1sTm9kZXMpO1xuICAgIC8vIEVycm9ycyBtaWdodCBvcmlnaW5hdGUgaW4gZWl0aGVyIHRoZSBiaW5kaW5nIHBhcnNlciBvciB0aGUgaHRtbCB0byBpdnkgdHJhbnNmb3JtZXJcbiAgICBjb25zdCBhbGxFcnJvcnMgPSBiaW5kaW5nUGFyc2VyLmVycm9ycy5jb25jYXQodHJhbnNmb3JtZXIuZXJyb3JzKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5vZGVzOiBpdnlOb2RlcyxcbiAgICAgICAgZXJyb3JzOiBhbGxFcnJvcnMsXG4gICAgICAgIHN0eWxlVXJsczogdHJhbnNmb3JtZXIuc3R5bGVVcmxzLFxuICAgICAgICBzdHlsZXM6IHRyYW5zZm9ybWVyLnN0eWxlcyxcbiAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB0cmFuc2Zvcm1lci5uZ0NvbnRlbnRTZWxlY3RvcnNcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMpIHtcbiAgICAgICAgcmVzdWx0LmNvbW1lbnROb2RlcyA9IHRyYW5zZm9ybWVyLmNvbW1lbnROb2RlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIEh0bWxBc3RUb0l2eUFzdCB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZ1BhcnNlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIgPSBiaW5kaW5nUGFyc2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICAvLyBUaGlzIGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIGlmIGBSZW5kZXIzUGFyc2VPcHRpb25zWydjb2xsZWN0Q29tbWVudE5vZGVzJ11gIGlzIHRydWVcbiAgICAgICAgdGhpcy5jb21tZW50Tm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBIVE1MIHZpc2l0b3JcbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBpc0kxOG5Sb290RWxlbWVudCA9IGlzSTE4blJvb3ROb2RlKGVsZW1lbnQuaTE4bik7XG4gICAgICAgIGlmIChpc0kxOG5Sb290RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdDYW5ub3QgbWFyayBhbiBlbGVtZW50IGFzIHRyYW5zbGF0YWJsZSBpbnNpZGUgb2YgYSB0cmFuc2xhdGFibGUgc2VjdGlvbi4gUGxlYXNlIHJlbW92ZSB0aGUgbmVzdGVkIGkxOG4gbWFya2VyLicsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluSTE4bkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGV4dENvbnRlbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaChjb250ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQgJiZcbiAgICAgICAgICAgIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlVXJscy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hldGhlciB0aGUgZWxlbWVudCBpcyBhIGA8bmctdGVtcGxhdGU+YFxuICAgICAgICBjb25zdCBpc1RlbXBsYXRlRWxlbWVudCA9IGlzTmdUZW1wbGF0ZShlbGVtZW50Lm5hbWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRQcm9wZXJ0aWVzID0gW107XG4gICAgICAgIGNvbnN0IGJvdW5kRXZlbnRzID0gW107XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtdO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gW107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgaTE4bkF0dHJzTWV0YSA9IHt9O1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZVBhcnNlZFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgLy8gV2hldGhlciB0aGUgZWxlbWVudCBoYXMgYW55ICotYXR0cmlidXRlXG4gICAgICAgIGxldCBlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgZWxlbWVudC5hdHRycykge1xuICAgICAgICAgICAgbGV0IGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAvLyBgKmF0dHJgIGRlZmluZXMgdGVtcGxhdGUgYmluZGluZ3NcbiAgICAgICAgICAgIGxldCBpc1RlbXBsYXRlQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pMThuKSB7XG4gICAgICAgICAgICAgICAgaTE4bkF0dHJzTWV0YVthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUuaTE4bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkTmFtZS5zdGFydHNXaXRoKFRFTVBMQVRFX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIC8vICotYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgQ2FuJ3QgaGF2ZSBtdWx0aXBsZSB0ZW1wbGF0ZSBiaW5kaW5ncyBvbiBvbmUgZWxlbWVudC4gVXNlIG9ubHkgb25lIGF0dHJpYnV0ZSBwcmVmaXhlZCB3aXRoICpgLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzVGVtcGxhdGVCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVLZXkgPSBub3JtYWxpemVkTmFtZS5zdWJzdHJpbmcoVEVNUExBVEVfQVRUUl9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBhYnNvbHV0ZVZhbHVlT2Zmc2V0ID0gYXR0cmlidXRlLnZhbHVlU3BhbiA/XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0IDpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdmFsdWUgc3BhbiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGhhdmUgYSB2YWx1ZSwgbGlrZSBgYXR0cmAgaW5cbiAgICAgICAgICAgICAgICAgICAgLy9gPGRpdiBhdHRyPjwvZGl2PmAuIEluIHRoaXMgY2FzZSwgcG9pbnQgdG8gb25lIGNoYXJhY3RlciBiZXlvbmQgdGhlIGxhc3QgY2hhcmFjdGVyIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0ICsgYXR0cmlidXRlLm5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyh0ZW1wbGF0ZUtleSwgdGVtcGxhdGVWYWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4sIGFic29sdXRlVmFsdWVPZmZzZXQsIFtdLCB0ZW1wbGF0ZVBhcnNlZFByb3BlcnRpZXMsIHBhcnNlZFZhcmlhYmxlcywgdHJ1ZSAvKiBpc0l2eUFzdCAqLyk7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVWYXJpYWJsZXMucHVzaCguLi5wYXJzZWRWYXJpYWJsZXMubWFwKHYgPT4gbmV3IFZhcmlhYmxlKHYubmFtZSwgdi52YWx1ZSwgdi5zb3VyY2VTcGFuLCB2LmtleVNwYW4sIHYudmFsdWVTcGFuKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHZhcmlhYmxlcywgZXZlbnRzLCBwcm9wZXJ0eSBiaW5kaW5ncywgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLnBhcnNlQXR0cmlidXRlKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyaWJ1dGUsIFtdLCBwYXJzZWRQcm9wZXJ0aWVzLCBib3VuZEV2ZW50cywgdmFyaWFibGVzLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaXNUZW1wbGF0ZUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaCh0aGlzLnZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdmlzaXRBbGwocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSA/IE5PTl9CSU5EQUJMRV9WSVNJVE9SIDogdGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGxldCBwYXJzZWRFbGVtZW50O1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UKSB7XG4gICAgICAgICAgICAvLyBgPG5nLWNvbnRlbnQ+YFxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4gJiZcbiAgICAgICAgICAgICAgICAhZWxlbWVudC5jaGlsZHJlbi5ldmVyeSgobm9kZSkgPT4gaXNFbXB0eVRleHROb2RlKG5vZGUpIHx8IGlzQ29tbWVudE5vZGUobm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgPG5nLWNvbnRlbnQ+IGVsZW1lbnQgY2Fubm90IGhhdmUgY29udGVudC5gLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBwcmVwYXJzZWRFbGVtZW50LnNlbGVjdEF0dHI7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IGVsZW1lbnQuYXR0cnMubWFwKGF0dHIgPT4gdGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IENvbnRlbnQoc2VsZWN0b3IsIGF0dHJzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gYDxuZy10ZW1wbGF0ZT5gXG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHRoaXMuZXh0cmFjdEF0dHJpYnV0ZXMoZWxlbWVudC5uYW1lLCBwYXJzZWRQcm9wZXJ0aWVzLCBpMThuQXR0cnNNZXRhKTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgVGVtcGxhdGUoZWxlbWVudC5uYW1lLCBhdHRyaWJ1dGVzLCBhdHRycy5ib3VuZCwgYm91bmRFdmVudHMsIFsgLyogbm8gdGVtcGxhdGUgYXR0cmlidXRlcyAqL10sIGNoaWxkcmVuLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3BhbiwgZWxlbWVudC5pMThuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gdGhpcy5leHRyYWN0QXR0cmlidXRlcyhlbGVtZW50Lm5hbWUsIHBhcnNlZFByb3BlcnRpZXMsIGkxOG5BdHRyc01ldGEpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50JDEoZWxlbWVudC5uYW1lLCBhdHRyaWJ1dGVzLCBhdHRycy5ib3VuZCwgYm91bmRFdmVudHMsIGNoaWxkcmVuLCByZWZlcmVuY2VzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRIYXNJbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBub2RlIGlzIGFuIGlubGluZS10ZW1wbGF0ZSAoZS5nLiBoYXMgKm5nRm9yKSB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlIGEgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIG5vZGUgdGhhdCBjb250YWlucyB0aGlzIG5vZGUuXG4gICAgICAgICAgICAvLyBNb3Jlb3ZlciwgaWYgdGhlIG5vZGUgaXMgYW4gZWxlbWVudCwgdGhlbiB3ZSBuZWVkIHRvIGhvaXN0IGl0cyBhdHRyaWJ1dGVzIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gbm9kZSBmb3IgbWF0Y2hpbmcgYWdhaW5zdCBjb250ZW50IHByb2plY3Rpb24gc2VsZWN0b3JzLlxuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSB0aGlzLmV4dHJhY3RBdHRyaWJ1dGVzKCduZy10ZW1wbGF0ZScsIHRlbXBsYXRlUGFyc2VkUHJvcGVydGllcywgaTE4bkF0dHJzTWV0YSk7XG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZUF0dHJzID0gW107XG4gICAgICAgICAgICBhdHRycy5saXRlcmFsLmZvckVhY2goYXR0ciA9PiB0ZW1wbGF0ZUF0dHJzLnB1c2goYXR0cikpO1xuICAgICAgICAgICAgYXR0cnMuYm91bmQuZm9yRWFjaChhdHRyID0+IHRlbXBsYXRlQXR0cnMucHVzaChhdHRyKSk7XG4gICAgICAgICAgICBjb25zdCBob2lzdGVkQXR0cnMgPSBwYXJzZWRFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCQxID9cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHBhcnNlZEVsZW1lbnQuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBwYXJzZWRFbGVtZW50LmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogcGFyc2VkRWxlbWVudC5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIHsgYXR0cmlidXRlczogW10sIGlucHV0czogW10sIG91dHB1dHM6IFtdIH07XG4gICAgICAgICAgICAvLyBGb3IgPG5nLXRlbXBsYXRlPnMgd2l0aCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgb24gdGhlbSwgYXZvaWQgcGFzc2luZyBpMThuIGluZm9ybWF0aW9uIHRvXG4gICAgICAgICAgICAvLyB0aGUgd3JhcHBpbmcgdGVtcGxhdGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBpMThuIGluc3RydWN0aW9ucyBmcm9tIGJlaW5nIGdlbmVyYXRlZC4gVGhlXG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgaTE4biBtZXRhIGluZm9ybWF0aW9uIHdpbGwgYmUgZXh0cmFjdGVkIGZyb20gY2hpbGQgZWxlbWVudHMuXG4gICAgICAgICAgICBjb25zdCBpMThuID0gaXNUZW1wbGF0ZUVsZW1lbnQgJiYgaXNJMThuUm9vdEVsZW1lbnQgPyB1bmRlZmluZWQgOiBlbGVtZW50LmkxOG47XG4gICAgICAgICAgICAvLyBUT0RPKHBrKTogdGVzdCBmb3IgdGhpcyBjYXNlXG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IFRlbXBsYXRlKHBhcnNlZEVsZW1lbnQubmFtZSwgaG9pc3RlZEF0dHJzLmF0dHJpYnV0ZXMsIGhvaXN0ZWRBdHRycy5pbnB1dHMsIGhvaXN0ZWRBdHRycy5vdXRwdXRzLCB0ZW1wbGF0ZUF0dHJzLCBbcGFyc2VkRWxlbWVudF0sIFsgLyogbm8gcmVmZXJlbmNlcyAqL10sIHRlbXBsYXRlVmFyaWFibGVzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0kxOG5Sb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRFbGVtZW50O1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuLCBhdHRyaWJ1dGUua2V5U3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgYXR0cmlidXRlLmkxOG4pO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuLCB0ZXh0LmkxOG4pO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihleHBhbnNpb24pIHtcbiAgICAgICAgaWYgKCFleHBhbnNpb24uaTE4bikge1xuICAgICAgICAgICAgLy8gZG8gbm90IGdlbmVyYXRlIEljdSBpbiBjYXNlIGl0IHdhcyBjcmVhdGVkXG4gICAgICAgICAgICAvLyBvdXRzaWRlIG9mIGkxOG4gYmxvY2sgaW4gYSB0ZW1wbGF0ZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0kxOG5Sb290Tm9kZShleHBhbnNpb24uaTE4bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0eXBlIFwiJHtleHBhbnNpb24uaTE4bi5jb25zdHJ1Y3Rvcn1cIiBmb3IgXCJpMThuXCIgcHJvcGVydHkgb2YgJHtleHBhbnNpb24uc291cmNlU3Bhbi50b1N0cmluZygpfS4gRXhwZWN0ZWQgYSBcIk1lc3NhZ2VcImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBleHBhbnNpb24uaTE4bjtcbiAgICAgICAgY29uc3QgdmFycyA9IHt9O1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlcnMgPSB7fTtcbiAgICAgICAgLy8gZXh0cmFjdCBWQVJzIGZyb20gSUNVcyAtIHdlIHByb2Nlc3MgdGhlbSBzZXBhcmF0ZWx5IHdoaWxlXG4gICAgICAgIC8vIGFzc2VtYmxpbmcgcmVzdWx0aW5nIG1lc3NhZ2UgdmlhIGdvb2cuZ2V0TXNnIGZ1bmN0aW9uLCBzaW5jZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHBhc3MgdGhlbSB0byB0b3AtbGV2ZWwgZ29vZy5nZXRNc2cgY2FsbFxuICAgICAgICBPYmplY3Qua2V5cyhtZXNzYWdlLnBsYWNlaG9sZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtZXNzYWdlLnBsYWNlaG9sZGVyc1trZXldO1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKEkxOE5fSUNVX1ZBUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3VycmVudGx5IHdoZW4gdGhlIGBwbHVyYWxgIG9yIGBzZWxlY3RgIGtleXdvcmRzIGluIGFuIElDVSBjb250YWluIHRyYWlsaW5nIHNwYWNlcyAoZS5nLlxuICAgICAgICAgICAgICAgIC8vIGB7Y291bnQsIHNlbGVjdCAsIC4uLn1gKSwgdGhlc2Ugc3BhY2VzIGFyZSBhbHNvIGluY2x1ZGVkIGludG8gdGhlIGtleSBuYW1lcyBpbiBJQ1UgdmFyc1xuICAgICAgICAgICAgICAgIC8vIChlLmcuIFwiVkFSX1NFTEVDVCBcIikuIFRoZXNlIHRyYWlsaW5nIHNwYWNlcyBhcmUgbm90IGRlc2lyYWJsZSwgc2luY2UgdGhleSB3aWxsIGxhdGVyIGJlXG4gICAgICAgICAgICAgICAgLy8gY29udmVydGVkIGludG8gYF9gIHN5bWJvbHMgd2hpbGUgbm9ybWFsaXppbmcgcGxhY2Vob2xkZXIgbmFtZXMsIHdoaWNoIG1pZ2h0IGxlYWQgdG9cbiAgICAgICAgICAgICAgICAvLyBtaXNtYXRjaGVzIGF0IHJ1bnRpbWUgKGkuZS4gcGxhY2Vob2xkZXIgd2lsbCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0aGUgY29ycmVjdCB2YWx1ZSkuXG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkS2V5ID0ga2V5LnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3QgPSB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbih2YWx1ZS50ZXh0LCB2YWx1ZS5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB2YXJzW2Zvcm1hdHRlZEtleV0gPSBuZXcgQm91bmRUZXh0KGFzdCwgdmFsdWUuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcnNba2V5XSA9IHRoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHZhbHVlLnRleHQsIHZhbHVlLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UkMSh2YXJzLCBwbGFjZWhvbGRlcnMsIGV4cGFuc2lvbi5zb3VyY2VTcGFuLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGV4cGFuc2lvbkNhc2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29sbGVjdENvbW1lbnROb2Rlcykge1xuICAgICAgICAgICAgdGhpcy5jb21tZW50Tm9kZXMucHVzaChuZXcgQ29tbWVudCQxKGNvbW1lbnQudmFsdWUgfHwgJycsIGNvbW1lbnQuc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBjb252ZXJ0IHZpZXcgZW5naW5lIGBQYXJzZWRQcm9wZXJ0eWAgdG8gYSBmb3JtYXQgc3VpdGFibGUgZm9yIElWWVxuICAgIGV4dHJhY3RBdHRyaWJ1dGVzKGVsZW1lbnROYW1lLCBwcm9wZXJ0aWVzLCBpMThuUHJvcHNNZXRhKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kID0gW107XG4gICAgICAgIGNvbnN0IGxpdGVyYWwgPSBbXTtcbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgY29uc3QgaTE4biA9IGkxOG5Qcm9wc01ldGFbcHJvcC5uYW1lXTtcbiAgICAgICAgICAgIGlmIChwcm9wLmlzTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGxpdGVyYWwucHVzaChuZXcgVGV4dEF0dHJpYnV0ZShwcm9wLm5hbWUsIHByb3AuZXhwcmVzc2lvbi5zb3VyY2UgfHwgJycsIHByb3Auc291cmNlU3BhbiwgcHJvcC5rZXlTcGFuLCBwcm9wLnZhbHVlU3BhbiwgaTE4bikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHZhbGlkYXRpb24gaXMgc2tpcHBlZCBhbmQgcHJvcGVydHkgbWFwcGluZyBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIC8vIGR1ZSB0byB0aGUgZmFjdCB0aGF0IHdlIG5lZWQgdG8gbWFrZSBzdXJlIGEgZ2l2ZW4gcHJvcCBpcyBub3QgYW5cbiAgICAgICAgICAgICAgICAvLyBpbnB1dCBvZiBhIGRpcmVjdGl2ZSBhbmQgZGlyZWN0aXZlIG1hdGNoaW5nIGhhcHBlbnMgYXQgcnVudGltZS5cbiAgICAgICAgICAgICAgICBjb25zdCBiZXAgPSB0aGlzLmJpbmRpbmdQYXJzZXIuY3JlYXRlQm91bmRFbGVtZW50UHJvcGVydHkoZWxlbWVudE5hbWUsIHByb3AsIC8qIHNraXBWYWxpZGF0aW9uICovIHRydWUsIC8qIG1hcFByb3BlcnR5TmFtZSAqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYm91bmQucHVzaChCb3VuZEF0dHJpYnV0ZS5mcm9tQm91bmRFbGVtZW50UHJvcGVydHkoYmVwLCBpMThuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBib3VuZCwgbGl0ZXJhbCB9O1xuICAgIH1cbiAgICBwYXJzZUF0dHJpYnV0ZShpc1RlbXBsYXRlRWxlbWVudCwgYXR0cmlidXRlLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzLCBib3VuZEV2ZW50cywgdmFyaWFibGVzLCByZWZlcmVuY2VzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgIGNvbnN0IHNyY1NwYW4gPSBhdHRyaWJ1dGUuc291cmNlU3BhbjtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVPZmZzZXQgPSBhdHRyaWJ1dGUudmFsdWVTcGFuID8gYXR0cmlidXRlLnZhbHVlU3Bhbi5zdGFydC5vZmZzZXQgOiBzcmNTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCBwcmVmaXgsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYWRqdXN0IHRoZSBzdGFydCBsb2NhdGlvbiBmb3IgdGhlIGtleVNwYW4gdG8gYWNjb3VudCBmb3IgdGhlIHJlbW92ZWQgJ2RhdGEtJ1xuICAgICAgICAgICAgLy8gcHJlZml4IGZyb20gYG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWVgLlxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXphdGlvbkFkanVzdG1lbnQgPSBhdHRyaWJ1dGUubmFtZS5sZW5ndGggLSBuYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGtleVNwYW5TdGFydCA9IHNyY1NwYW4uc3RhcnQubW92ZUJ5KHByZWZpeC5sZW5ndGggKyBub3JtYWxpemF0aW9uQWRqdXN0bWVudCk7XG4gICAgICAgICAgICBjb25zdCBrZXlTcGFuRW5kID0ga2V5U3BhblN0YXJ0Lm1vdmVCeShpZGVudGlmaWVyLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihrZXlTcGFuU3RhcnQsIGtleVNwYW5FbmQsIGtleVNwYW5TdGFydCwgaWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmluZFBhcnRzID0gbmFtZS5tYXRjaChCSU5EX05BTUVfUkVHRVhQKTtcbiAgICAgICAgaWYgKGJpbmRQYXJ0cykge1xuICAgICAgICAgICAgaWYgKGJpbmRQYXJ0c1tLV19CSU5EX0lEWF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTcGFuID0gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCBiaW5kUGFydHNbS1dfQklORF9JRFhdLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoaWRlbnRpZmllciwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywga2V5U3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfTEVUX0lEWF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlTcGFuID0gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCBiaW5kUGFydHNbS1dfTEVUX0lEWF0sIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIGtleVNwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGBcImxldC1cIiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBuZy10ZW1wbGF0ZSBlbGVtZW50cy5gLCBzcmNTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfUkVGX0lEWF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5U3BhbiA9IGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgYmluZFBhcnRzW0tXX1JFRl9JRFhdLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlUmVmZXJlbmNlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCBrZXlTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19PTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVNwYW4gPSBjcmVhdGVLZXlTcGFuKHNyY1NwYW4sIGJpbmRQYXJ0c1tLV19PTl9JRFhdLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VFdmVudChpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiB8fCBzcmNTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBldmVudHMsIGtleVNwYW4pO1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50cyhldmVudHMsIGJvdW5kRXZlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19CSU5ET05fSURYXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTcGFuID0gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCBiaW5kUGFydHNbS1dfQklORE9OX0lEWF0sIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhpZGVudGlmaWVyLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzLCBrZXlTcGFuKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQXNzaWdubWVudEV2ZW50KGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBib3VuZEV2ZW50cywga2V5U3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQVRfSURYXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVNwYW4gPSBjcmVhdGVLZXlTcGFuKHNyY1NwYW4sICcnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VMaXRlcmFsQXR0cihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIHBhcnNlZFByb3BlcnRpZXMsIGtleVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZGlkbid0IHNlZSBhIGt3LXByZWZpeGVkIHByb3BlcnR5IGJpbmRpbmcsIGJ1dCB3ZSBoYXZlIG5vdCB5ZXQgY2hlY2tlZFxuICAgICAgICAvLyBmb3IgdGhlIFtdLygpL1soKV0gc3ludGF4LlxuICAgICAgICBsZXQgZGVsaW1zID0gbnVsbDtcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChCSU5ESU5HX0RFTElNUy5CQU5BTkFfQk9YLnN0YXJ0KSkge1xuICAgICAgICAgICAgZGVsaW1zID0gQklORElOR19ERUxJTVMuQkFOQU5BX0JPWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoQklORElOR19ERUxJTVMuUFJPUEVSVFkuc3RhcnQpKSB7XG4gICAgICAgICAgICBkZWxpbXMgPSBCSU5ESU5HX0RFTElNUy5QUk9QRVJUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoQklORElOR19ERUxJTVMuRVZFTlQuc3RhcnQpKSB7XG4gICAgICAgICAgICBkZWxpbXMgPSBCSU5ESU5HX0RFTElNUy5FVkVOVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsaW1zICE9PSBudWxsICYmXG4gICAgICAgICAgICAvLyBOT1RFOiBvbGRlciB2ZXJzaW9ucyBvZiB0aGUgcGFyc2VyIHdvdWxkIG1hdGNoIGEgc3RhcnQvZW5kIGRlbGltaXRlZFxuICAgICAgICAgICAgLy8gYmluZGluZyBpZmYgdGhlIHByb3BlcnR5IG5hbWUgd2FzIHRlcm1pbmF0ZWQgYnkgdGhlIGVuZGluZyBkZWxpbWl0ZXJcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgaWRlbnRpZmllciBpbiB0aGUgYmluZGluZyB3YXMgbm9uLWVtcHR5LlxuICAgICAgICAgICAgLy8gVE9ETyhheWF6aGFmaXopOiB1cGRhdGUgdGhpcyB0byBoYW5kbGUgbWFsZm9ybWVkIGJpbmRpbmdzLlxuICAgICAgICAgICAgbmFtZS5lbmRzV2l0aChkZWxpbXMuZW5kKSAmJiBuYW1lLmxlbmd0aCA+IGRlbGltcy5zdGFydC5sZW5ndGggKyBkZWxpbXMuZW5kLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IG5hbWUuc3Vic3RyaW5nKGRlbGltcy5zdGFydC5sZW5ndGgsIG5hbWUubGVuZ3RoIC0gZGVsaW1zLmVuZC5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3Qga2V5U3BhbiA9IGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgZGVsaW1zLnN0YXJ0LCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGlmIChkZWxpbXMuc3RhcnQgPT09IEJJTkRJTkdfREVMSU1TLkJBTkFOQV9CT1guc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoaWRlbnRpZmllciwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywga2V5U3Bhbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFzc2lnbm1lbnRFdmVudChpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgYm91bmRFdmVudHMsIGtleVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVsaW1zLnN0YXJ0ID09PSBCSU5ESU5HX0RFTElNUy5QUk9QRVJUWS5zdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhpZGVudGlmaWVyLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzLCBrZXlTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZUV2ZW50KGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuIHx8IHNyY1NwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIGV2ZW50cywga2V5U3Bhbik7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRzKGV2ZW50cywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gZXhwbGljaXQgYmluZGluZyBmb3VuZC5cbiAgICAgICAgY29uc3Qga2V5U3BhbiA9IGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgJycgLyogcHJlZml4ICovLCBuYW1lKTtcbiAgICAgICAgY29uc3QgaGFzQmluZGluZyA9IHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywga2V5U3Bhbik7XG4gICAgICAgIHJldHVybiBoYXNCaW5kaW5nO1xuICAgIH1cbiAgICBfdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odmFsdWUsIHNvdXJjZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgY29uc3QgdmFsdWVOb05nc3AgPSByZXBsYWNlTmdzcCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlTm9OZ3NwLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgcmV0dXJuIGV4cHIgPyBuZXcgQm91bmRUZXh0KGV4cHIsIHNvdXJjZVNwYW4sIGkxOG4pIDogbmV3IFRleHQkMyh2YWx1ZU5vTmdzcCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHBhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgdmFyaWFibGVzKSB7XG4gICAgICAgIGlmIChpZGVudGlmaWVyLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGBcIi1cIiBpcyBub3QgYWxsb3dlZCBpbiB2YXJpYWJsZSBuYW1lc2AsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlkZW50aWZpZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGBWYXJpYWJsZSBkb2VzIG5vdCBoYXZlIGEgbmFtZWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhcmlhYmxlcy5wdXNoKG5ldyBWYXJpYWJsZShpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgfVxuICAgIHBhcnNlUmVmZXJlbmNlKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4sIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoYFwiLVwiIGlzIG5vdCBhbGxvd2VkIGluIHJlZmVyZW5jZSBuYW1lc2AsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlkZW50aWZpZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGBSZWZlcmVuY2UgZG9lcyBub3QgaGF2ZSBhIG5hbWVgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWZlcmVuY2VzLnNvbWUocmVmZXJlbmNlID0+IHJlZmVyZW5jZS5uYW1lID09PSBpZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgUmVmZXJlbmNlIFwiIyR7aWRlbnRpZmllcn1cIiBpcyBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlYCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmVmZXJlbmNlcy5wdXNoKG5ldyBSZWZlcmVuY2UoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbikpO1xuICAgIH1cbiAgICBwYXJzZUFzc2lnbm1lbnRFdmVudChuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCBib3VuZEV2ZW50cywga2V5U3Bhbikge1xuICAgICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoYCR7bmFtZX1DaGFuZ2VgLCBgJHtleHByZXNzaW9ufT0kZXZlbnRgLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4gfHwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIGV2ZW50cywga2V5U3Bhbik7XG4gICAgICAgIGFkZEV2ZW50cyhldmVudHMsIGJvdW5kRXZlbnRzKTtcbiAgICB9XG4gICAgcmVwb3J0RXJyb3IobWVzc2FnZSwgc291cmNlU3BhbiwgbGV2ZWwgPSBQYXJzZUVycm9yTGV2ZWwuRVJST1IpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VFcnJvcihzb3VyY2VTcGFuLCBtZXNzYWdlLCBsZXZlbCkpO1xuICAgIH1cbn1cbmNsYXNzIE5vbkJpbmRhYmxlVmlzaXRvciB7XG4gICAgdmlzaXRFbGVtZW50KGFzdCkge1xuICAgICAgICBjb25zdCBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50JDEoYXN0Lm5hbWUsIHZpc2l0QWxsKHRoaXMsIGFzdC5hdHRycyksIFxuICAgICAgICAvKiBpbnB1dHMgKi8gW10sIC8qIG91dHB1dHMgKi8gW10sIGNoaWxkcmVuLCAvKiByZWZlcmVuY2VzICovIFtdLCBhc3Quc291cmNlU3BhbiwgYXN0LnN0YXJ0U291cmNlU3BhbiwgYXN0LmVuZFNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEF0dHJpYnV0ZShhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3BhbiwgYXR0cmlidXRlLmtleVNwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIGF0dHJpYnV0ZS5pMThuKTtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDModGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jb25zdCBOT05fQklOREFCTEVfVklTSVRPUiA9IG5ldyBOb25CaW5kYWJsZVZpc2l0b3IoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gL15kYXRhLS9pLnRlc3QoYXR0ck5hbWUpID8gYXR0ck5hbWUuc3Vic3RyaW5nKDUpIDogYXR0ck5hbWU7XG59XG5mdW5jdGlvbiBhZGRFdmVudHMoZXZlbnRzLCBib3VuZEV2ZW50cykge1xuICAgIGJvdW5kRXZlbnRzLnB1c2goLi4uZXZlbnRzLm1hcChlID0+IEJvdW5kRXZlbnQuZnJvbVBhcnNlZEV2ZW50KGUpKSk7XG59XG5mdW5jdGlvbiBpc0VtcHR5VGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dCAmJiBub2RlLnZhbHVlLnRyaW0oKS5sZW5ndGggPT0gMDtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29tbWVudDtcbn1cbmZ1bmN0aW9uIHRleHRDb250ZW50cyhub2RlKSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICEobm9kZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRleHQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW5bMF0udmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbnZhciBUYWdUeXBlO1xuKGZ1bmN0aW9uIChUYWdUeXBlKSB7XG4gICAgVGFnVHlwZVtUYWdUeXBlW1wiRUxFTUVOVFwiXSA9IDBdID0gXCJFTEVNRU5UXCI7XG4gICAgVGFnVHlwZVtUYWdUeXBlW1wiVEVNUExBVEVcIl0gPSAxXSA9IFwiVEVNUExBVEVcIjtcbn0pKFRhZ1R5cGUgfHwgKFRhZ1R5cGUgPSB7fSkpO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gb2JqZWN0IHRoYXQgaXMgdXNlZCBhcyBhIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIHBhcmVudCBhbmQgYWxsIGNoaWxkIGNvbnRleHRzLlxuICovXG5mdW5jdGlvbiBzZXR1cFJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiB7IGdldFVuaXF1ZUlkOiBnZXRTZXFOdW1iZXJHZW5lcmF0b3IoKSwgaWN1czogbmV3IE1hcCgpIH07XG59XG4vKipcbiAqIEkxOG5Db250ZXh0IGlzIGEgaGVscGVyIGNsYXNzIHdoaWNoIGtlZXBzIHRyYWNrIG9mIGFsbCBpMThuLXJlbGF0ZWQgYXNwZWN0c1xuICogKGFjY3VtdWxhdGVzIHBsYWNlaG9sZGVycywgYmluZGluZ3MsIGV0YykgYmV0d2VlbiBpMThuU3RhcnQgYW5kIGkxOG5FbmQgaW5zdHJ1Y3Rpb25zLlxuICpcbiAqIFdoZW4gd2UgZW50ZXIgYSBuZXN0ZWQgdGVtcGxhdGUsIHRoZSB0b3AtbGV2ZWwgY29udGV4dCBpcyBiZWluZyBwYXNzZWQgZG93blxuICogdG8gdGhlIG5lc3RlZCBjb21wb25lbnQsIHdoaWNoIHVzZXMgdGhpcyBjb250ZXh0IHRvIGdlbmVyYXRlIGEgY2hpbGQgaW5zdGFuY2VcbiAqIG9mIEkxOG5Db250ZXh0IGNsYXNzICh0byBoYW5kbGUgbmVzdGVkIHRlbXBsYXRlKSBhbmQgYXQgdGhlIGVuZCwgcmVjb25jaWxlcyBpdCBiYWNrXG4gKiB3aXRoIHRoZSBwYXJlbnQgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0gaW5kZXggSW5zdHJ1Y3Rpb24gaW5kZXggb2YgaTE4blN0YXJ0LCB3aGljaCBpbml0aWF0ZXMgdGhpcyBjb250ZXh0XG4gKiBAcGFyYW0gcmVmIFJlZmVyZW5jZSB0byBhIHRyYW5zbGF0aW9uIGNvbnN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudCBpZiB0aHVzIGNvbnRleHRcbiAqIEBwYXJhbSBsZXZlbCBOZXN0bmcgbGV2ZWwgZGVmaW5lZCBmb3IgY2hpbGQgY29udGV4dHNcbiAqIEBwYXJhbSB0ZW1wbGF0ZUluZGV4IEluc3RydWN0aW9uIGluZGV4IG9mIGEgdGVtcGxhdGUgd2hpY2ggdGhpcyBjb250ZXh0IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBtZXRhIE1ldGEgaW5mb3JtYXRpb24gKGlkLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgZXRjKSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb250ZXh0XG4gKi9cbmNsYXNzIEkxOG5Db250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihpbmRleCwgcmVmLCBsZXZlbCA9IDAsIHRlbXBsYXRlSW5kZXggPSBudWxsLCBtZXRhLCByZWdpc3RyeSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIHRoaXMudGVtcGxhdGVJbmRleCA9IHRlbXBsYXRlSW5kZXg7XG4gICAgICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaXNFbWl0dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3JlZ2lzdHJ5ID0gcmVnaXN0cnkgfHwgc2V0dXBSZWdpc3RyeSgpO1xuICAgICAgICB0aGlzLmlkID0gdGhpcy5fcmVnaXN0cnkuZ2V0VW5pcXVlSWQoKTtcbiAgICB9XG4gICAgYXBwZW5kVGFnKHR5cGUsIG5vZGUsIGluZGV4LCBjbG9zZWQpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNWb2lkICYmIGNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBpZ25vcmUgXCJjbG9zZVwiIGZvciB2b2lkIHRhZ3NcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwaCA9IG5vZGUuaXNWb2lkIHx8ICFjbG9zZWQgPyBub2RlLnN0YXJ0TmFtZSA6IG5vZGUuY2xvc2VOYW1lO1xuICAgICAgICBjb25zdCBjb250ZW50ID0geyB0eXBlLCBpbmRleCwgY3R4OiB0aGlzLmlkLCBpc1ZvaWQ6IG5vZGUuaXNWb2lkLCBjbG9zZWQgfTtcbiAgICAgICAgdXBkYXRlUGxhY2Vob2xkZXJNYXAodGhpcy5wbGFjZWhvbGRlcnMsIHBoLCBjb250ZW50KTtcbiAgICB9XG4gICAgZ2V0IGljdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RyeS5pY3VzO1xuICAgIH1cbiAgICBnZXQgaXNSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbCA9PT0gMDtcbiAgICB9XG4gICAgZ2V0IGlzUmVzb2x2ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnJlc29sdmVkQ3R4Q291bnQgPT09IDA7XG4gICAgfVxuICAgIGdldFNlcmlhbGl6ZWRQbGFjZWhvbGRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMuZm9yRWFjaCgodmFsdWVzLCBrZXkpID0+IHJlc3VsdC5zZXQoa2V5LCB2YWx1ZXMubWFwKHNlcmlhbGl6ZVBsYWNlaG9sZGVyVmFsdWUpKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBBUEkgdG8gYWNjdW11bGF0ZSBpMThuLXJlbGF0ZWQgY29udGVudFxuICAgIGFwcGVuZEJpbmRpbmcoYmluZGluZykge1xuICAgICAgICB0aGlzLmJpbmRpbmdzLmFkZChiaW5kaW5nKTtcbiAgICB9XG4gICAgYXBwZW5kSWN1KG5hbWUsIHJlZikge1xuICAgICAgICB1cGRhdGVQbGFjZWhvbGRlck1hcCh0aGlzLl9yZWdpc3RyeS5pY3VzLCBuYW1lLCByZWYpO1xuICAgIH1cbiAgICBhcHBlbmRCb3VuZFRleHQobm9kZSkge1xuICAgICAgICBjb25zdCBwaHMgPSBhc3NlbWJsZUJvdW5kVGV4dFBsYWNlaG9sZGVycyhub2RlLCB0aGlzLmJpbmRpbmdzLnNpemUsIHRoaXMuaWQpO1xuICAgICAgICBwaHMuZm9yRWFjaCgodmFsdWVzLCBrZXkpID0+IHVwZGF0ZVBsYWNlaG9sZGVyTWFwKHRoaXMucGxhY2Vob2xkZXJzLCBrZXksIC4uLnZhbHVlcykpO1xuICAgIH1cbiAgICBhcHBlbmRUZW1wbGF0ZShub2RlLCBpbmRleCkge1xuICAgICAgICAvLyBhZGQgb3BlbiBhbmQgY2xvc2UgdGFncyBhdCB0aGUgc2FtZSB0aW1lLFxuICAgICAgICAvLyBzaW5jZSB3ZSBwcm9jZXNzIG5lc3RlZCB0ZW1wbGF0ZXMgc2VwYXJhdGVseVxuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLlRFTVBMQVRFLCBub2RlLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLlRFTVBMQVRFLCBub2RlLCBpbmRleCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudCsrO1xuICAgIH1cbiAgICBhcHBlbmRFbGVtZW50KG5vZGUsIGluZGV4LCBjbG9zZWQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRUYWcoVGFnVHlwZS5FTEVNRU5ULCBub2RlLCBpbmRleCwgY2xvc2VkKTtcbiAgICB9XG4gICAgYXBwZW5kUHJvamVjdGlvbihub2RlLCBpbmRleCkge1xuICAgICAgICAvLyBBZGQgb3BlbiBhbmQgY2xvc2UgdGFncyBhdCB0aGUgc2FtZSB0aW1lLCBzaW5jZSBgPG5nLWNvbnRlbnQ+YCBoYXMgbm8gY29udGVudCxcbiAgICAgICAgLy8gc28gd2hlbiB3ZSBjb21lIGFjcm9zcyBgPG5nLWNvbnRlbnQ+YCB3ZSBjYW4gcmVnaXN0ZXIgYm90aCBvcGVuIGFuZCBjbG9zZSB0YWdzLlxuICAgICAgICAvLyBOb3RlOiBydW50aW1lIGkxOG4gbG9naWMgZG9lc24ndCBkaXN0aW5ndWlzaCBgPG5nLWNvbnRlbnQ+YCB0YWcgcGxhY2Vob2xkZXJzIGFuZFxuICAgICAgICAvLyByZWd1bGFyIGVsZW1lbnQgdGFnIHBsYWNlaG9sZGVycywgc28gd2UgZ2VuZXJhdGUgZWxlbWVudCBwbGFjZWhvbGRlcnMgZm9yIGJvdGggdHlwZXMuXG4gICAgICAgIHRoaXMuYXBwZW5kVGFnKFRhZ1R5cGUuRUxFTUVOVCwgbm9kZSwgaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5hcHBlbmRUYWcoVGFnVHlwZS5FTEVNRU5ULCBub2RlLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbiBpbnN0YW5jZSBvZiBhIGNoaWxkIGNvbnRleHQgYmFzZWQgb24gdGhlIHJvb3Qgb25lLFxuICAgICAqIHdoZW4gd2UgZW50ZXIgYSBuZXN0ZWQgdGVtcGxhdGUgd2l0aGluIEkxOG4gc2VjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCBJbnN0cnVjdGlvbiBpbmRleCBvZiBjb3JyZXNwb25kaW5nIGkxOG5TdGFydCwgd2hpY2ggaW5pdGlhdGVzIHRoaXMgY29udGV4dFxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZUluZGV4IEluc3RydWN0aW9uIGluZGV4IG9mIGEgdGVtcGxhdGUgd2hpY2ggdGhpcyBjb250ZXh0IGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0gbWV0YSBNZXRhIGluZm9ybWF0aW9uIChpZCwgbWVhbmluZywgZGVzY3JpcHRpb24sIGV0YykgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29udGV4dFxuICAgICAqXG4gICAgICogQHJldHVybnMgSTE4bkNvbnRleHQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmb3JrQ2hpbGRDb250ZXh0KGluZGV4LCB0ZW1wbGF0ZUluZGV4LCBtZXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcgSTE4bkNvbnRleHQoaW5kZXgsIHRoaXMucmVmLCB0aGlzLmxldmVsICsgMSwgdGVtcGxhdGVJbmRleCwgbWV0YSwgdGhpcy5fcmVnaXN0cnkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbmNpbGVzIGNoaWxkIGNvbnRleHQgaW50byBwYXJlbnQgb25lIG9uY2UgdGhlIGVuZCBvZiB0aGUgaTE4biBibG9jayBpcyByZWFjaGVkIChpMThuRW5kKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IENoaWxkIEkxOG5Db250ZXh0IGluc3RhbmNlIHRvIGJlIHJlY29uY2lsZWQgd2l0aCBwYXJlbnQgY29udGV4dC5cbiAgICAgKi9cbiAgICByZWNvbmNpbGVDaGlsZENvbnRleHQoY29udGV4dCkge1xuICAgICAgICAvLyBzZXQgdGhlIHJpZ2h0IGNvbnRleHQgaWQgZm9yIG9wZW4gYW5kIGNsb3NlXG4gICAgICAgIC8vIHRlbXBsYXRlIHRhZ3MsIHNvIHdlIGNhbiB1c2UgaXQgYXMgc3ViLWJsb2NrIGlkc1xuICAgICAgICBbJ3N0YXJ0JywgJ2Nsb3NlJ10uZm9yRWFjaCgob3ApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGNvbnRleHQubWV0YVtgJHtvcH1OYW1lYF07XG4gICAgICAgICAgICBjb25zdCBwaHMgPSB0aGlzLnBsYWNlaG9sZGVycy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHBocy5maW5kKGZpbmRUZW1wbGF0ZUZuKHRoaXMuaWQsIGNvbnRleHQudGVtcGxhdGVJbmRleCkpO1xuICAgICAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgICAgIHRhZy5jdHggPSBjb250ZXh0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gcmVjb25jaWxlIHBsYWNlaG9sZGVyc1xuICAgICAgICBjb25zdCBjaGlsZFBocyA9IGNvbnRleHQucGxhY2Vob2xkZXJzO1xuICAgICAgICBjaGlsZFBocy5mb3JFYWNoKCh2YWx1ZXMsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGhzID0gdGhpcy5wbGFjZWhvbGRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoIXBocykge1xuICAgICAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJzLnNldChrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJ5IHRvIGZpbmQgbWF0Y2hpbmcgdGVtcGxhdGUuLi5cbiAgICAgICAgICAgIGNvbnN0IHRtcGxJZHggPSBwaHMuZmluZEluZGV4KGZpbmRUZW1wbGF0ZUZuKGNvbnRleHQuaWQsIGNvbnRleHQudGVtcGxhdGVJbmRleCkpO1xuICAgICAgICAgICAgaWYgKHRtcGxJZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBpZiBmb3VuZCAtIHJlcGxhY2UgaXQgd2l0aCBuZXN0ZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ2xvc2VUYWcgPSBrZXkuc3RhcnRzV2l0aCgnQ0xPU0UnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1RlbXBsYXRlVGFnID0ga2V5LmVuZHNXaXRoKCdORy1URU1QTEFURScpO1xuICAgICAgICAgICAgICAgIGlmIChpc1RlbXBsYXRlVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgdGVtcGxhdGUncyBjb250ZW50IGlzIHBsYWNlZCBiZWZvcmUgb3IgYWZ0ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IHRlbXBsYXRlIHRhZywgZGVwZW5kaW5nIG9uIHRoZSBvcGVuL2Nsb3NlIGF0cnJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICBwaHMuc3BsaWNlKHRtcGxJZHggKyAoaXNDbG9zZVRhZyA/IDAgOiAxKSwgMCwgLi4udmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGlzQ2xvc2VUYWcgPyB2YWx1ZXMubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpZHhdLnRtcGwgPSBwaHNbdG1wbElkeF07XG4gICAgICAgICAgICAgICAgICAgIHBocy5zcGxpY2UodG1wbElkeCwgMSwgLi4udmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAuLi4gb3RoZXJ3aXNlIGp1c3QgYXBwZW5kIGNvbnRlbnQgdG8gcGxhY2Vob2xkZXIgdmFsdWVcbiAgICAgICAgICAgICAgICBwaHMucHVzaCguLi52YWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMuc2V0KGtleSwgcGhzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudC0tO1xuICAgIH1cbn1cbi8vXG4vLyBIZWxwZXIgbWV0aG9kc1xuLy9cbmZ1bmN0aW9uIHdyYXAoc3ltYm9sLCBpbmRleCwgY29udGV4dElkLCBjbG9zZWQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGNsb3NlZCA/ICcvJyA6ICcnO1xuICAgIHJldHVybiB3cmFwSTE4blBsYWNlaG9sZGVyKGAke3N0YXRlfSR7c3ltYm9sfSR7aW5kZXh9YCwgY29udGV4dElkKTtcbn1cbmZ1bmN0aW9uIHdyYXBUYWcoc3ltYm9sLCB7IGluZGV4LCBjdHgsIGlzVm9pZCB9LCBjbG9zZWQpIHtcbiAgICByZXR1cm4gaXNWb2lkID8gd3JhcChzeW1ib2wsIGluZGV4LCBjdHgpICsgd3JhcChzeW1ib2wsIGluZGV4LCBjdHgsIHRydWUpIDpcbiAgICAgICAgd3JhcChzeW1ib2wsIGluZGV4LCBjdHgsIGNsb3NlZCk7XG59XG5mdW5jdGlvbiBmaW5kVGVtcGxhdGVGbihjdHgsIHRlbXBsYXRlSW5kZXgpIHtcbiAgICByZXR1cm4gKHRva2VuKSA9PiB0eXBlb2YgdG9rZW4gPT09ICdvYmplY3QnICYmIHRva2VuLnR5cGUgPT09IFRhZ1R5cGUuVEVNUExBVEUgJiZcbiAgICAgICAgdG9rZW4uaW5kZXggPT09IHRlbXBsYXRlSW5kZXggJiYgdG9rZW4uY3R4ID09PSBjdHg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVQbGFjZWhvbGRlclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IChkYXRhLCBjbG9zZWQpID0+IHdyYXBUYWcoJyMnLCBkYXRhLCBjbG9zZWQpO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gKGRhdGEsIGNsb3NlZCkgPT4gd3JhcFRhZygnKicsIGRhdGEsIGNsb3NlZCk7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IChkYXRhLCBjbG9zZWQpID0+IHdyYXBUYWcoJyEnLCBkYXRhLCBjbG9zZWQpO1xuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICBjYXNlIFRhZ1R5cGUuRUxFTUVOVDpcbiAgICAgICAgICAgIC8vIGNsb3NlIGVsZW1lbnQgdGFnXG4gICAgICAgICAgICBpZiAodmFsdWUuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQodmFsdWUsIHRydWUpICsgKHZhbHVlLnRtcGwgPyB0ZW1wbGF0ZSh2YWx1ZS50bXBsLCB0cnVlKSA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9wZW4gZWxlbWVudCB0YWcgdGhhdCBhbHNvIGluaXRpYXRlcyBhIHRlbXBsYXRlXG4gICAgICAgICAgICBpZiAodmFsdWUudG1wbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZSh2YWx1ZS50bXBsKSArIGVsZW1lbnQodmFsdWUpICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLmlzVm9pZCA/IHRlbXBsYXRlKHZhbHVlLnRtcGwsIHRydWUpIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQodmFsdWUpO1xuICAgICAgICBjYXNlIFRhZ1R5cGUuVEVNUExBVEU6XG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUodmFsdWUsIHZhbHVlLmNsb3NlZCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIEljdVNlcmlhbGl6ZXJWaXNpdG9yIHtcbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1KSB7XG4gICAgICAgIGNvbnN0IHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoKGspID0+IGAke2t9IHske2ljdS5jYXNlc1trXS52aXNpdCh0aGlzKX19YCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGB7JHtpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyfSwgJHtpY3UudHlwZX0sICR7c3RyQ2FzZXMuam9pbignICcpfX1gO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHJldHVybiBwaC5pc1ZvaWQgP1xuICAgICAgICAgICAgdGhpcy5mb3JtYXRQaChwaC5zdGFydE5hbWUpIDpcbiAgICAgICAgICAgIGAke3RoaXMuZm9ybWF0UGgocGguc3RhcnROYW1lKX0ke3BoLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSkuam9pbignJyl9JHt0aGlzLmZvcm1hdFBoKHBoLmNsb3NlTmFtZSl9YDtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRQaChwaC5uYW1lKTtcbiAgICB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRQaChwaC5uYW1lKTtcbiAgICB9XG4gICAgZm9ybWF0UGgodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGB7JHtmb3JtYXRJMThuUGxhY2Vob2xkZXJOYW1lKHZhbHVlLCAvKiB1c2VDYW1lbENhc2UgKi8gZmFsc2UpfX1gO1xuICAgIH1cbn1cbmNvbnN0IHNlcmlhbGl6ZXIgPSBuZXcgSWN1U2VyaWFsaXplclZpc2l0b3IoKTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUljdU5vZGUoaWN1KSB7XG4gICAgcmV0dXJuIGljdS52aXNpdChzZXJpYWxpemVyKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVMgPSB7XG4gICAgJ0EnOiAnTElOSycsXG4gICAgJ0InOiAnQk9MRF9URVhUJyxcbiAgICAnQlInOiAnTElORV9CUkVBSycsXG4gICAgJ0VNJzogJ0VNUEhBU0lTRURfVEVYVCcsXG4gICAgJ0gxJzogJ0hFQURJTkdfTEVWRUwxJyxcbiAgICAnSDInOiAnSEVBRElOR19MRVZFTDInLFxuICAgICdIMyc6ICdIRUFESU5HX0xFVkVMMycsXG4gICAgJ0g0JzogJ0hFQURJTkdfTEVWRUw0JyxcbiAgICAnSDUnOiAnSEVBRElOR19MRVZFTDUnLFxuICAgICdINic6ICdIRUFESU5HX0xFVkVMNicsXG4gICAgJ0hSJzogJ0hPUklaT05UQUxfUlVMRScsXG4gICAgJ0knOiAnSVRBTElDX1RFWFQnLFxuICAgICdMSSc6ICdMSVNUX0lURU0nLFxuICAgICdMSU5LJzogJ01FRElBX0xJTksnLFxuICAgICdPTCc6ICdPUkRFUkVEX0xJU1QnLFxuICAgICdQJzogJ1BBUkFHUkFQSCcsXG4gICAgJ1EnOiAnUVVPVEFUSU9OJyxcbiAgICAnUyc6ICdTVFJJS0VUSFJPVUdIX1RFWFQnLFxuICAgICdTTUFMTCc6ICdTTUFMTF9URVhUJyxcbiAgICAnU1VCJzogJ1NVQlNUUklQVCcsXG4gICAgJ1NVUCc6ICdTVVBFUlNDUklQVCcsXG4gICAgJ1RCT0RZJzogJ1RBQkxFX0JPRFknLFxuICAgICdURCc6ICdUQUJMRV9DRUxMJyxcbiAgICAnVEZPT1QnOiAnVEFCTEVfRk9PVEVSJyxcbiAgICAnVEgnOiAnVEFCTEVfSEVBREVSX0NFTEwnLFxuICAgICdUSEVBRCc6ICdUQUJMRV9IRUFERVInLFxuICAgICdUUic6ICdUQUJMRV9ST1cnLFxuICAgICdUVCc6ICdNT05PU1BBQ0VEX1RFWFQnLFxuICAgICdVJzogJ1VOREVSTElORURfVEVYVCcsXG4gICAgJ1VMJzogJ1VOT1JERVJFRF9MSVNUJyxcbn07XG4vKipcbiAqIENyZWF0ZXMgdW5pcXVlIG5hbWVzIGZvciBwbGFjZWhvbGRlciB3aXRoIGRpZmZlcmVudCBjb250ZW50LlxuICpcbiAqIFJldHVybnMgdGhlIHNhbWUgcGxhY2Vob2xkZXIgbmFtZSB3aGVuIHRoZSBjb250ZW50IGlzIGlkZW50aWNhbC5cbiAqL1xuY2xhc3MgUGxhY2Vob2xkZXJSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIENvdW50IHRoZSBvY2N1cnJlbmNlIG9mIHRoZSBiYXNlIG5hbWUgdG9wIGdlbmVyYXRlIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzID0ge307XG4gICAgICAgIC8vIE1hcHMgc2lnbmF0dXJlIHRvIHBsYWNlaG9sZGVyIG5hbWVzXG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZSA9IHt9O1xuICAgIH1cbiAgICBnZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZSh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5faGFzaFRhZyh0YWcsIGF0dHJzLCBpc1ZvaWQpO1xuICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cHBlclRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjb25zdCBiYXNlTmFtZSA9IFRBR19UT19QTEFDRUhPTERFUl9OQU1FU1t1cHBlclRhZ10gfHwgYFRBR18ke3VwcGVyVGFnfWA7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoaXNWb2lkID8gYmFzZU5hbWUgOiBgU1RBUlRfJHtiYXNlTmFtZX1gKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0Q2xvc2VUYWdQbGFjZWhvbGRlck5hbWUodGFnKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuX2hhc2hDbG9zaW5nVGFnKHRhZyk7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwcGVyVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBgVEFHXyR7dXBwZXJUYWd9YDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZShgQ0xPU0VfJHtiYXNlTmFtZX1gKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0UGxhY2Vob2xkZXJOYW1lKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBgUEg6ICR7dXBwZXJOYW1lfT0ke2NvbnRlbnR9YDtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZSh1cHBlck5hbWUpO1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IHVuaXF1ZU5hbWU7XG4gICAgICAgIHJldHVybiB1bmlxdWVOYW1lO1xuICAgIH1cbiAgICBnZXRVbmlxdWVQbGFjZWhvbGRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUobmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgYSBoYXNoIGZvciBhIHRhZyAtIGRvZXMgbm90IHRha2UgYXR0cmlidXRlIG9yZGVyIGludG8gYWNjb3VudFxuICAgIF9oYXNoVGFnKHRhZywgYXR0cnMsIGlzVm9pZCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGA8JHt0YWd9YDtcbiAgICAgICAgY29uc3Qgc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykuc29ydCgpLm1hcCgobmFtZSkgPT4gYCAke25hbWV9PSR7YXR0cnNbbmFtZV19YCkuam9pbignJyk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGlzVm9pZCA/ICcvPicgOiBgPjwvJHt0YWd9PmA7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ckF0dHJzICsgZW5kO1xuICAgIH1cbiAgICBfaGFzaENsb3NpbmdUYWcodGFnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNoVGFnKGAvJHt0YWd9YCwge30sIGZhbHNlKTtcbiAgICB9XG4gICAgX2dlbmVyYXRlVW5pcXVlTmFtZShiYXNlKSB7XG4gICAgICAgIGNvbnN0IHNlZW4gPSB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHMuaGFzT3duUHJvcGVydHkoYmFzZSk7XG4gICAgICAgIGlmICghc2Vlbikge1xuICAgICAgICAgICAgdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW2Jhc2VdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW2Jhc2VdO1xuICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV0gPSBpZCArIDE7XG4gICAgICAgIHJldHVybiBgJHtiYXNlfV8ke2lkfWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IF9leHBQYXJzZXIgPSBuZXcgUGFyc2VyJDEobmV3IExleGVyKCkpO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gY29udmVydGluZyBodG1sIG5vZGVzIHRvIGFuIGkxOG4gTWVzc2FnZSBnaXZlbiBhbiBpbnRlcnBvbGF0aW9uQ29uZmlnXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBfSTE4blZpc2l0b3IoX2V4cFBhcnNlciwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgcmV0dXJuIChub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGN1c3RvbUlkLCB2aXNpdE5vZGVGbikgPT4gdmlzaXRvci50b0kxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgY3VzdG9tSWQsIHZpc2l0Tm9kZUZuKTtcbn1cbmZ1bmN0aW9uIG5vb3BWaXNpdE5vZGVGbihfaHRtbCwgaTE4bikge1xuICAgIHJldHVybiBpMThuO1xufVxuY2xhc3MgX0kxOG5WaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihfZXhwcmVzc2lvblBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdGhpcy5fZXhwcmVzc2lvblBhcnNlciA9IF9leHByZXNzaW9uUGFyc2VyO1xuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnID0gX2ludGVycG9sYXRpb25Db25maWc7XG4gICAgfVxuICAgIHRvSTE4bk1lc3NhZ2Uobm9kZXMsIG1lYW5pbmcgPSAnJywgZGVzY3JpcHRpb24gPSAnJywgY3VzdG9tSWQgPSAnJywgdmlzaXROb2RlRm4pIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGlzSWN1OiBub2Rlcy5sZW5ndGggPT0gMSAmJiBub2Rlc1swXSBpbnN0YW5jZW9mIEV4cGFuc2lvbixcbiAgICAgICAgICAgIGljdURlcHRoOiAwLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXJSZWdpc3RyeTogbmV3IFBsYWNlaG9sZGVyUmVnaXN0cnkoKSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyVG9Db250ZW50OiB7fSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyVG9NZXNzYWdlOiB7fSxcbiAgICAgICAgICAgIHZpc2l0Tm9kZUZuOiB2aXNpdE5vZGVGbiB8fCBub29wVmlzaXROb2RlRm4sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGkxOG5vZGVzID0gdmlzaXRBbGwodGhpcywgbm9kZXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2UoaTE4bm9kZXMsIGNvbnRleHQucGxhY2Vob2xkZXJUb0NvbnRlbnQsIGNvbnRleHQucGxhY2Vob2xkZXJUb01lc3NhZ2UsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBjdXN0b21JZCk7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbCwgY29udGV4dCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4sIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBhdHRycyA9IHt9O1xuICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgICAgLy8gRG8gbm90IHZpc2l0IHRoZSBhdHRyaWJ1dGVzLCB0cmFuc2xhdGFibGUgb25lcyBhcmUgdG9wLWxldmVsIEFTVHNcbiAgICAgICAgICAgIGF0dHJzW2F0dHIubmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaXNWb2lkID0gZ2V0SHRtbFRhZ0RlZmluaXRpb24oZWwubmFtZSkuaXNWb2lkO1xuICAgICAgICBjb25zdCBzdGFydFBoTmFtZSA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lLCBhdHRycywgaXNWb2lkKTtcbiAgICAgICAgY29udGV4dC5wbGFjZWhvbGRlclRvQ29udGVudFtzdGFydFBoTmFtZV0gPSB7XG4gICAgICAgICAgICB0ZXh0OiBlbC5zdGFydFNvdXJjZVNwYW4udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IGVsLnN0YXJ0U291cmNlU3BhbixcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNsb3NlUGhOYW1lID0gJyc7XG4gICAgICAgIGlmICghaXNWb2lkKSB7XG4gICAgICAgICAgICBjbG9zZVBoTmFtZSA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRDbG9zZVRhZ1BsYWNlaG9sZGVyTmFtZShlbC5uYW1lKTtcbiAgICAgICAgICAgIGNvbnRleHQucGxhY2Vob2xkZXJUb0NvbnRlbnRbY2xvc2VQaE5hbWVdID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGA8LyR7ZWwubmFtZX0+YCxcbiAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiAoX2EgPSBlbC5lbmRTb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlbC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlID0gbmV3IFRhZ1BsYWNlaG9sZGVyKGVsLm5hbWUsIGF0dHJzLCBzdGFydFBoTmFtZSwgY2xvc2VQaE5hbWUsIGNoaWxkcmVuLCBpc1ZvaWQsIGVsLnNvdXJjZVNwYW4sIGVsLnN0YXJ0U291cmNlU3BhbiwgZWwuZW5kU291cmNlU3Bhbik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKGVsLCBub2RlKTtcbiAgICB9XG4gICAgdmlzaXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhdHRyaWJ1dGUudmFsdWVUb2tlbnMgPT09IHVuZGVmaW5lZCB8fCBhdHRyaWJ1dGUudmFsdWVUb2tlbnMubGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgIG5ldyBUZXh0JDIoYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUudmFsdWVTcGFuIHx8IGF0dHJpYnV0ZS5zb3VyY2VTcGFuKSA6XG4gICAgICAgICAgICB0aGlzLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbihhdHRyaWJ1dGUudmFsdWVUb2tlbnMsIGF0dHJpYnV0ZS52YWx1ZVNwYW4gfHwgYXR0cmlidXRlLnNvdXJjZVNwYW4sIGNvbnRleHQsIGF0dHJpYnV0ZS5pMThuKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQudmlzaXROb2RlRm4oYXR0cmlidXRlLCBub2RlKTtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRleHQudG9rZW5zLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICBuZXcgVGV4dCQyKHRleHQudmFsdWUsIHRleHQuc291cmNlU3BhbikgOlxuICAgICAgICAgICAgdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odGV4dC50b2tlbnMsIHRleHQuc291cmNlU3BhbiwgY29udGV4dCwgdGV4dC5pMThuKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQudmlzaXROb2RlRm4odGV4dCwgbm9kZSk7XG4gICAgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5pY3VEZXB0aCsrO1xuICAgICAgICBjb25zdCBpMThuSWN1Q2FzZXMgPSB7fTtcbiAgICAgICAgY29uc3QgaTE4bkljdSA9IG5ldyBJY3UoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgaTE4bkljdUNhc2VzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIGljdS5jYXNlcy5mb3JFYWNoKChjYXplKSA9PiB7XG4gICAgICAgICAgICBpMThuSWN1Q2FzZXNbY2F6ZS52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGNhemUuZXhwcmVzc2lvbi5tYXAoKG5vZGUpID0+IG5vZGUudmlzaXQodGhpcywgY29udGV4dCkpLCBjYXplLmV4cFNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5pY3VEZXB0aC0tO1xuICAgICAgICBpZiAoY29udGV4dC5pc0ljdSB8fCBjb250ZXh0LmljdURlcHRoID4gMCkge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBhbiBJQ1Ugbm9kZSB3aGVuOlxuICAgICAgICAgICAgLy8gLSB0aGUgbWVzc2FnZSAodnMgYSBwYXJ0IG9mIHRoZSBtZXNzYWdlKSBpcyBhbiBJQ1UgbWVzc2FnZSwgb3JcbiAgICAgICAgICAgIC8vIC0gdGhlIElDVSBtZXNzYWdlIGlzIG5lc3RlZC5cbiAgICAgICAgICAgIGNvbnN0IGV4cFBoID0gY29udGV4dC5wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFVuaXF1ZVBsYWNlaG9sZGVyKGBWQVJfJHtpY3UudHlwZX1gKTtcbiAgICAgICAgICAgIGkxOG5JY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyID0gZXhwUGg7XG4gICAgICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50W2V4cFBoXSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBpY3Uuc3dpdGNoVmFsdWUsXG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogaWN1LnN3aXRjaFZhbHVlU291cmNlU3BhbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC52aXNpdE5vZGVGbihpY3UsIGkxOG5JY3UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVsc2UgcmV0dXJucyBhIHBsYWNlaG9sZGVyXG4gICAgICAgIC8vIElDVSBwbGFjZWhvbGRlcnMgc2hvdWxkIG5vdCBiZSByZXBsYWNlZCB3aXRoIHRoZWlyIG9yaWdpbmFsIGNvbnRlbnQgYnV0IHdpdGggdGhlIHRoZWlyXG4gICAgICAgIC8vIHRyYW5zbGF0aW9ucy5cbiAgICAgICAgLy8gVE9ETyh2aWNiKTogYWRkIGEgaHRtbC5Ob2RlIC0+IGkxOG4uTWVzc2FnZSBjYWNoZSB0byBhdm9pZCBoYXZpbmcgdG8gcmUtY3JlYXRlIHRoZSBtc2dcbiAgICAgICAgY29uc3QgcGhOYW1lID0gY29udGV4dC5wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFBsYWNlaG9sZGVyTmFtZSgnSUNVJywgaWN1LnNvdXJjZVNwYW4udG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnRleHQucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGhOYW1lXSA9IHRoaXMudG9JMThuTWVzc2FnZShbaWN1XSwgJycsICcnLCAnJywgdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBJY3VQbGFjZWhvbGRlcihpMThuSWN1LCBwaE5hbWUsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQudmlzaXROb2RlRm4oaWN1LCBub2RlKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKF9pY3VDYXNlLCBfY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCwgdGV4dCBhbmQgaW50ZXJwb2xhdGVkIHRva2VucyB1cCBpbnRvIHRleHQgYW5kIHBsYWNlaG9sZGVyIHBpZWNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbnMgVGhlIHRleHQgYW5kIGludGVycG9sYXRlZCB0b2tlbnMuXG4gICAgICogQHBhcmFtIHNvdXJjZVNwYW4gVGhlIHNwYW4gb2YgdGhlIHdob2xlIG9mIHRoZSBgdGV4dGAgc3RyaW5nLlxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2YgdGhlIHZpc2l0b3IsIHVzZWQgdG8gY29tcHV0ZSBhbmQgc3RvcmUgcGxhY2Vob2xkZXJzLlxuICAgICAqIEBwYXJhbSBwcmV2aW91c0kxOG4gQW55IGkxOG4gbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYHRleHRgIGZyb20gYSBwcmV2aW91cyBwYXNzLlxuICAgICAqL1xuICAgIF92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbih0b2tlbnMsIHNvdXJjZVNwYW4sIGNvbnRleHQsIHByZXZpb3VzSTE4bikge1xuICAgICAgICAvLyBSZXR1cm4gYSBzZXF1ZW5jZSBvZiBgVGV4dGAgYW5kIGBQbGFjZWhvbGRlcmAgbm9kZXMgZ3JvdXBlZCBpbiBhIGBDb250YWluZXJgLlxuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICAvLyBXZSB3aWxsIG9ubHkgY3JlYXRlIGEgY29udGFpbmVyIGlmIHRoZXJlIGFyZSBhY3R1YWxseSBpbnRlcnBvbGF0aW9ucyxcbiAgICAgICAgLy8gc28gdGhpcyBmbGFnIHRyYWNrcyB0aGF0LlxuICAgICAgICBsZXQgaGFzSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA4IC8qIElOVEVSUE9MQVRJT04gKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxNyAvKiBBVFRSX1ZBTFVFX0lOVEVSUE9MQVRJT04gKi86XG4gICAgICAgICAgICAgICAgICAgIGhhc0ludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdG9rZW4ucGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VOYW1lID0gZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShleHByZXNzaW9uKSB8fCAnSU5URVJQT0xBVElPTic7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBoTmFtZSA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoYmFzZU5hbWUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50W3BoTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0b2tlbi5wYXJ0cy5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IHRva2VuLnNvdXJjZVNwYW5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgUGxhY2Vob2xkZXIoZXhwcmVzc2lvbiwgcGhOYW1lLCB0b2tlbi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5wYXJ0c1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHRva2VuIGlzIHRleHQgb3IgYW4gZW5jb2RlZCBlbnRpdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBmb2xsb3dpbmcgb24gZnJvbSBhIHByZXZpb3VzIHRleHQgbm9kZSB0aGVuIG1lcmdlIGl0IGludG8gdGhhdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGl0IGlzIGZvbGxvd2luZyBhbiBpbnRlcnBvbGF0aW9uLCB0aGVuIGFkZCBhIG5ldyBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIFRleHQkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLnZhbHVlICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLnNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHByZXZpb3VzLnNvdXJjZVNwYW4uc3RhcnQsIHRva2VuLnNvdXJjZVNwYW4uZW5kLCBwcmV2aW91cy5zb3VyY2VTcGFuLmZ1bGxTdGFydCwgcHJldmlvdXMuc291cmNlU3Bhbi5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMih0b2tlbi5wYXJ0c1swXSwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBXaGl0ZXNwYWNlIHJlbW92YWwgbWF5IGhhdmUgaW52YWxpZGF0ZWQgdGhlIGludGVycG9sYXRpb24gc291cmNlLXNwYW5zLlxuICAgICAgICAgICAgcmV1c2VQcmV2aW91c1NvdXJjZVNwYW5zKG5vZGVzLCBwcmV2aW91c0kxOG4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXIobm9kZXMsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZS11c2UgdGhlIHNvdXJjZS1zcGFucyBmcm9tIGBwcmV2aW91c0kxOG5gIG1ldGFkYXRhIGZvciB0aGUgYG5vZGVzYC5cbiAqXG4gKiBXaGl0ZXNwYWNlIHJlbW92YWwgY2FuIGludmFsaWRhdGUgdGhlIHNvdXJjZS1zcGFucyBvZiBpbnRlcnBvbGF0aW9uIG5vZGVzLCBzbyB3ZVxuICogcmV1c2UgdGhlIHNvdXJjZS1zcGFuIHN0b3JlZCBmcm9tIGEgcHJldmlvdXMgcGFzcyBiZWZvcmUgdGhlIHdoaXRlc3BhY2Ugd2FzIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIG5vZGVzIFRoZSBgVGV4dGAgYW5kIGBQbGFjZWhvbGRlcmAgbm9kZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHByZXZpb3VzSTE4biBBbnkgaTE4biBtZXRhZGF0YSBmb3IgdGhlc2UgYG5vZGVzYCBzdG9yZWQgZnJvbSBhIHByZXZpb3VzIHBhc3MuXG4gKi9cbmZ1bmN0aW9uIHJldXNlUHJldmlvdXNTb3VyY2VTcGFucyhub2RlcywgcHJldmlvdXNJMThuKSB7XG4gICAgaWYgKHByZXZpb3VzSTE4biBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVGhlIGBwcmV2aW91c0kxOG5gIGlzIGFuIGkxOG4gYE1lc3NhZ2VgLCBzbyB3ZSBhcmUgcHJvY2Vzc2luZyBhbiBgQXR0cmlidXRlYCB3aXRoIGkxOG5cbiAgICAgICAgLy8gbWV0YWRhdGEuIFRoZSBgTWVzc2FnZWAgc2hvdWxkIGNvbnNpc3Qgb25seSBvZiBhIHNpbmdsZSBgQ29udGFpbmVyYCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICAvLyBwYXJ0cyAoYFRleHRgIGFuZCBgUGxhY2Vob2xkZXJgKSB0byBwcm9jZXNzLlxuICAgICAgICBhc3NlcnRTaW5nbGVDb250YWluZXJNZXNzYWdlKHByZXZpb3VzSTE4bik7XG4gICAgICAgIHByZXZpb3VzSTE4biA9IHByZXZpb3VzSTE4bi5ub2Rlc1swXTtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzSTE4biBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgICAvLyBUaGUgYHByZXZpb3VzSTE4bmAgaXMgYSBgQ29udGFpbmVyYCwgd2hpY2ggbWVhbnMgdGhhdCB0aGlzIGlzIGEgc2Vjb25kIGkxOG4gZXh0cmFjdGlvbiBwYXNzXG4gICAgICAgIC8vIGFmdGVyIHdoaXRlc3BhY2UgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBBU1Qgbm9kZXMuXG4gICAgICAgIGFzc2VydEVxdWl2YWxlbnROb2RlcyhwcmV2aW91c0kxOG4uY2hpbGRyZW4sIG5vZGVzKTtcbiAgICAgICAgLy8gUmV1c2UgdGhlIHNvdXJjZS1zcGFucyBmcm9tIHRoZSBmaXJzdCBwYXNzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2Rlc1tpXS5zb3VyY2VTcGFuID0gcHJldmlvdXNJMThuLmNoaWxkcmVuW2ldLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgYG1lc3NhZ2VgIGNvbnRhaW5zIGV4YWN0bHkgb25lIGBDb250YWluZXJgIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFNpbmdsZUNvbnRhaW5lck1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IG5vZGVzID0gbWVzc2FnZS5ub2RlcztcbiAgICBpZiAobm9kZXMubGVuZ3RoICE9PSAxIHx8ICEobm9kZXNbMF0gaW5zdGFuY2VvZiBDb250YWluZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwcmV2aW91cyBpMThuIG1lc3NhZ2UgLSBleHBlY3RlZCBpdCB0byBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgYENvbnRhaW5lcmAgbm9kZS4nKTtcbiAgICB9XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgYHByZXZpb3VzTm9kZXNgIGFuZCBgbm9kZWAgY29sbGVjdGlvbnMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYW5kXG4gKiBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIGhhdmUgdGhlIHNhbWUgbm9kZSB0eXBlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRFcXVpdmFsZW50Tm9kZXMocHJldmlvdXNOb2Rlcywgbm9kZXMpIHtcbiAgICBpZiAocHJldmlvdXNOb2Rlcy5sZW5ndGggIT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBudW1iZXIgb2YgaTE4biBtZXNzYWdlIGNoaWxkcmVuIGNoYW5nZWQgYmV0d2VlbiBmaXJzdCBhbmQgc2Vjb25kIHBhc3MuJyk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c05vZGVzLnNvbWUoKG5vZGUsIGkpID0+IG5vZGVzW2ldLmNvbnN0cnVjdG9yICE9PSBub2RlLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0eXBlcyBvZiB0aGUgaTE4biBtZXNzYWdlIGNoaWxkcmVuIGNoYW5nZWQgYmV0d2VlbiBmaXJzdCBhbmQgc2Vjb25kIHBhc3MuJyk7XG4gICAgfVxufVxuY29uc3QgX0NVU1RPTV9QSF9FWFAgPSAvXFwvXFwvW1xcc1xcU10qaTE4bltcXHNcXFNdKlxcKFtcXHNcXFNdKnBoW1xcc1xcU10qPVtcXHNcXFNdKihcInwnKShbXFxzXFxTXSo/KVxcMVtcXHNcXFNdKlxcKS9nO1xuZnVuY3Rpb24gZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5zcGxpdChfQ1VTVE9NX1BIX0VYUClbMl07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBbiBpMThuIGVycm9yLlxuICovXG5jbGFzcyBJMThuRXJyb3IgZXh0ZW5kcyBQYXJzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBtc2cpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgbXNnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3Qgc2V0STE4blJlZnMgPSAoaHRtbE5vZGUsIGkxOG5Ob2RlKSA9PiB7XG4gICAgaWYgKGh0bWxOb2RlIGluc3RhbmNlb2YgTm9kZVdpdGhJMThuKSB7XG4gICAgICAgIGlmIChpMThuTm9kZSBpbnN0YW5jZW9mIEljdVBsYWNlaG9sZGVyICYmIGh0bWxOb2RlLmkxOG4gaW5zdGFuY2VvZiBNZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGh0bWwgbm9kZSByZXByZXNlbnRzIGFuIElDVSBidXQgdGhpcyBpcyBhIHNlY29uZCBwcm9jZXNzaW5nIHBhc3MsIGFuZCB0aGUgbGVnYWN5IGlkXG4gICAgICAgICAgICAvLyB3YXMgY29tcHV0ZWQgaW4gdGhlIHByZXZpb3VzIHBhc3MgYW5kIHN0b3JlZCBpbiB0aGUgYGkxOG5gIHByb3BlcnR5IGFzIGEgbWVzc2FnZS5cbiAgICAgICAgICAgIC8vIFdlIGFyZSBhYm91dCB0byB3aXBlIG91dCB0aGF0IHByb3BlcnR5IHNvIGNhcHR1cmUgdGhlIHByZXZpb3VzIG1lc3NhZ2UgdG8gYmUgcmV1c2VkIHdoZW5cbiAgICAgICAgICAgIC8vIGdlbmVyYXRpbmcgdGhlIG1lc3NhZ2UgZm9yIHRoaXMgSUNVIGxhdGVyLiBTZWUgYF9nZW5lcmF0ZUkxOG5NZXNzYWdlKClgLlxuICAgICAgICAgICAgaTE4bk5vZGUucHJldmlvdXNNZXNzYWdlID0gaHRtbE5vZGUuaTE4bjtcbiAgICAgICAgfVxuICAgICAgICBodG1sTm9kZS5pMThuID0gaTE4bk5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpMThuTm9kZTtcbn07XG4vKipcbiAqIFRoaXMgdmlzaXRvciB3YWxrcyBvdmVyIEhUTUwgcGFyc2UgdHJlZSBhbmQgY29udmVydHMgaW5mb3JtYXRpb24gc3RvcmVkIGluXG4gKiBpMThuLXJlbGF0ZWQgYXR0cmlidXRlcyAoXCJpMThuXCIgYW5kIFwiaTE4bi0qXCIpIGludG8gaTE4biBtZXRhIG9iamVjdCB0aGF0IGlzXG4gKiBzdG9yZWQgd2l0aCBvdGhlciBlbGVtZW50J3MgYW5kIGF0dHJpYnV0ZSdzIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBJMThuTWV0YVZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHLCBrZWVwSTE4bkF0dHJzID0gZmFsc2UsIGVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmludGVycG9sYXRpb25Db25maWcgPSBpbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLmtlZXBJMThuQXR0cnMgPSBrZWVwSTE4bkF0dHJzO1xuICAgICAgICB0aGlzLmVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQgPSBlbmFibGVJMThuTGVnYWN5TWVzc2FnZUlkRm9ybWF0O1xuICAgICAgICAvLyB3aGV0aGVyIHZpc2l0ZWQgbm9kZXMgY29udGFpbiBpMThuIGluZm9ybWF0aW9uXG4gICAgICAgIHRoaXMuaGFzSTE4bk1ldGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgIC8vIGkxOG4gbWVzc2FnZSBnZW5lcmF0aW9uIGZhY3RvcnlcbiAgICAgICAgdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UgPSBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkodGhpcy5pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgX2dlbmVyYXRlSTE4bk1lc3NhZ2Uobm9kZXMsIG1ldGEgPSAnJywgdmlzaXROb2RlRm4pIHtcbiAgICAgICAgY29uc3QgeyBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgY3VzdG9tSWQgfSA9IHRoaXMuX3BhcnNlTWV0YWRhdGEobWV0YSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZShub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGN1c3RvbUlkLCB2aXNpdE5vZGVGbik7XG4gICAgICAgIHRoaXMuX3NldE1lc3NhZ2VJZChtZXNzYWdlLCBtZXRhKTtcbiAgICAgICAgdGhpcy5fc2V0TGVnYWN5SWRzKG1lc3NhZ2UsIG1ldGEpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgdmlzaXRBbGxXaXRoRXJyb3JzKG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5vZGVzLm1hcChub2RlID0+IG5vZGUudmlzaXQodGhpcywgbnVsbCkpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChyZXN1bHQsIHRoaXMuX2Vycm9ycyk7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaGFzSTE4bkF0dHJzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0kxOG5NZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgICAgICBjb25zdCBhdHRyc01ldGEgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBlbGVtZW50LmF0dHJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIubmFtZSA9PT0gSTE4Tl9BVFRSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJvb3QgJ2kxOG4nIG5vZGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkxOG4gPSBlbGVtZW50LmkxOG4gfHwgYXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoZWxlbWVudC5jaGlsZHJlbiwgaTE4biwgc2V0STE4blJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgbWVzc2FnZSBpZiBpdCBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIG1lc3NhZ2Ugb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pMThuID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lLnN0YXJ0c1dpdGgoSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2kxOG4tKicgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0ci5uYW1lLnNsaWNlKEkxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHJ1c3RlZFR5cGVzU2luayhlbGVtZW50Lm5hbWUsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihhdHRyLCBgVHJhbnNsYXRpbmcgYXR0cmlidXRlICcke25hbWV9JyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNNZXRhW25hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9uLWkxOG4gYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBpMThuIG1ldGEgZm9yIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyc01ldGEpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gYXR0cnNNZXRhW2F0dHIubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgdHJhbnNsYXRpb24gZm9yIGVtcHR5IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGEgIT09IHVuZGVmaW5lZCAmJiBhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmkxOG4gPSB0aGlzLl9nZW5lcmF0ZUkxOG5NZXNzYWdlKFthdHRyXSwgYXR0ci5pMThuIHx8IG1ldGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBJMThuQXR0cnMpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZWxlbWVudCdzIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8ga2VlcGluZyBvbmx5IG5vbi1pMThuIHJlbGF0ZWQgb25lc1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uKGV4cGFuc2lvbiwgY3VycmVudE1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBleHBhbnNpb24uaTE4bjtcbiAgICAgICAgdGhpcy5oYXNJMThuTWV0YSA9IHRydWU7XG4gICAgICAgIGlmIChtZXRhIGluc3RhbmNlb2YgSWN1UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIC8vIHNldCBJQ1UgcGxhY2Vob2xkZXIgbmFtZSAoZS5nLiBcIklDVV8xXCIpLFxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIHdoaWxlIHByb2Nlc3Npbmcgcm9vdCBlbGVtZW50IGNvbnRlbnRzLFxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIHJlZmVyZW5jZSBpdCB3aGVuIHdlIG91dHB1dCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG1ldGEubmFtZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9nZW5lcmF0ZUkxOG5NZXNzYWdlKFtleHBhbnNpb25dLCBtZXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGljdSA9IGljdUZyb21JMThuTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGljdS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEFsc28gdXBkYXRlIHRoZSBwbGFjZWhvbGRlclRvTWVzc2FnZSBtYXAgd2l0aCB0aGlzIG5ldyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgY3VycmVudE1lc3NhZ2UucGxhY2Vob2xkZXJUb01lc3NhZ2VbbmFtZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSUNVIGlzIGEgdG9wIGxldmVsIG1lc3NhZ2UsIHRyeSB0byB1c2UgbWV0YWRhdGEgZnJvbSBjb250YWluZXIgZWxlbWVudCBpZiBwcm92aWRlZCB2aWFcbiAgICAgICAgICAgIC8vIGBjb250ZXh0YCBhcmd1bWVudC4gTm90ZTogY29udGV4dCBtYXkgbm90IGJlIGF2YWlsYWJsZSBmb3Igc3RhbmRhbG9uZSBJQ1VzICh3aXRob3V0XG4gICAgICAgICAgICAvLyB3cmFwcGluZyBlbGVtZW50KSwgc28gZmFsbGJhY2sgdG8gSUNVIG1ldGFkYXRhIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9nZW5lcmF0ZUkxOG5NZXNzYWdlKFtleHBhbnNpb25dLCBjdXJyZW50TWVzc2FnZSB8fCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBleHBhbnNpb24uaTE4biA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBleHBhbnNpb247XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9XG4gICAgdmlzaXRDb21tZW50KGNvbW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShleHBhbnNpb25DYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBhbnNpb25DYXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgZ2VuZXJhbCBmb3JtIGBtZXRhYCBwYXNzZWQgaW50byBleHRyYWN0IHRoZSBleHBsaWNpdCBtZXRhZGF0YSBuZWVkZWQgdG8gY3JlYXRlIGFcbiAgICAgKiBgTWVzc2FnZWAuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdGhyZWUgcG9zc2liaWxpdGllcyBmb3IgdGhlIGBtZXRhYCB2YXJpYWJsZVxuICAgICAqIDEpIGEgc3RyaW5nIGZyb20gYW4gYGkxOG5gIHRlbXBsYXRlIGF0dHJpYnV0ZTogcGFyc2UgaXQgdG8gZXh0cmFjdCB0aGUgbWV0YWRhdGEgdmFsdWVzLlxuICAgICAqIDIpIGEgYE1lc3NhZ2VgIGZyb20gYSBwcmV2aW91cyBwcm9jZXNzaW5nIHBhc3M6IHJldXNlIHRoZSBtZXRhZGF0YSB2YWx1ZXMgaW4gdGhlIG1lc3NhZ2UuXG4gICAgICogNCkgb3RoZXI6IGlnbm9yZSB0aGlzIGFuZCBqdXN0IHByb2Nlc3MgdGhlIG1lc3NhZ2UgbWV0YWRhdGEgYXMgbm9ybWFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0YSB0aGUgYnVja2V0IHRoYXQgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB0aGUgcGFyc2VkIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIF9wYXJzZU1ldGFkYXRhKG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyA/IHBhcnNlSTE4bk1ldGEobWV0YSkgOlxuICAgICAgICAgICAgbWV0YSBpbnN0YW5jZW9mIE1lc3NhZ2UgPyBtZXRhIDoge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIChvciByZXN0b3JlKSBtZXNzYWdlIGlkIGlmIG5vdCBzcGVjaWZpZWQgYWxyZWFkeS5cbiAgICAgKi9cbiAgICBfc2V0TWVzc2FnZUlkKG1lc3NhZ2UsIG1ldGEpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmlkKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmlkID0gbWV0YSBpbnN0YW5jZW9mIE1lc3NhZ2UgJiYgbWV0YS5pZCB8fCBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYG1lc3NhZ2VgIHdpdGggYSBgbGVnYWN5SWRgIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIHRoZSBtZXNzYWdlIHdob3NlIGxlZ2FjeSBpZCBzaG91bGQgYmUgc2V0XG4gICAgICogQHBhcmFtIG1ldGEgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1lc3NhZ2UgYmVpbmcgcHJvY2Vzc2VkXG4gICAgICovXG4gICAgX3NldExlZ2FjeUlkcyhtZXNzYWdlLCBtZXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UubGVnYWN5SWRzID0gW2NvbXB1dGVEaWdlc3QobWVzc2FnZSksIGNvbXB1dGVEZWNpbWFsRGlnZXN0KG1lc3NhZ2UpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWV0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgb2NjdXJzIGlmIHdlIGFyZSBkb2luZyB0aGUgMm5kIHBhc3MgYWZ0ZXIgd2hpdGVzcGFjZSByZW1vdmFsIChzZWUgYHBhcnNlVGVtcGxhdGUoKWAgaW5cbiAgICAgICAgICAgIC8vIGBwYWNrYWdlcy9jb21waWxlci9zcmMvcmVuZGVyMy92aWV3L3RlbXBsYXRlLnRzYCkuXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2Ugd2Ugd2FudCB0byByZXVzZSB0aGUgbGVnYWN5IG1lc3NhZ2UgZ2VuZXJhdGVkIGluIHRoZSAxc3QgcGFzcyAoc2VlXG4gICAgICAgICAgICAvLyBgc2V0STE4blJlZnMoKWApLlxuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNNZXNzYWdlID0gbWV0YSBpbnN0YW5jZW9mIE1lc3NhZ2UgP1xuICAgICAgICAgICAgICAgIG1ldGEgOlxuICAgICAgICAgICAgICAgIG1ldGEgaW5zdGFuY2VvZiBJY3VQbGFjZWhvbGRlciA/IG1ldGEucHJldmlvdXNNZXNzYWdlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbWVzc2FnZS5sZWdhY3lJZHMgPSBwcmV2aW91c01lc3NhZ2UgPyBwcmV2aW91c01lc3NhZ2UubGVnYWN5SWRzIDogW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlcG9ydEVycm9yKG5vZGUsIG1zZykge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbXNnKSk7XG4gICAgfVxufVxuLyoqIEkxOG4gc2VwYXJhdG9ycyBmb3IgbWV0YWRhdGEgKiovXG5jb25zdCBJMThOX01FQU5JTkdfU0VQQVJBVE9SID0gJ3wnO1xuY29uc3QgSTE4Tl9JRF9TRVBBUkFUT1IgPSAnQEAnO1xuLyoqXG4gKiBQYXJzZXMgaTE4biBtZXRhcyBsaWtlOlxuICogIC0gXCJAQGlkXCIsXG4gKiAgLSBcImRlc2NyaXB0aW9uW0BAaWRdXCIsXG4gKiAgLSBcIm1lYW5pbmd8ZGVzY3JpcHRpb25bQEBpZF1cIlxuICogYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFyc2VkIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gbWV0YSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIGkxOG4gbWV0YVxuICogQHJldHVybnMgT2JqZWN0IHdpdGggaWQsIG1lYW5pbmcgYW5kIGRlc2NyaXB0aW9uIGZpZWxkc1xuICovXG5mdW5jdGlvbiBwYXJzZUkxOG5NZXRhKG1ldGEgPSAnJykge1xuICAgIGxldCBjdXN0b21JZDtcbiAgICBsZXQgbWVhbmluZztcbiAgICBsZXQgZGVzY3JpcHRpb247XG4gICAgbWV0YSA9IG1ldGEudHJpbSgpO1xuICAgIGlmIChtZXRhKSB7XG4gICAgICAgIGNvbnN0IGlkSW5kZXggPSBtZXRhLmluZGV4T2YoSTE4Tl9JRF9TRVBBUkFUT1IpO1xuICAgICAgICBjb25zdCBkZXNjSW5kZXggPSBtZXRhLmluZGV4T2YoSTE4Tl9NRUFOSU5HX1NFUEFSQVRPUik7XG4gICAgICAgIGxldCBtZWFuaW5nQW5kRGVzYztcbiAgICAgICAgW21lYW5pbmdBbmREZXNjLCBjdXN0b21JZF0gPVxuICAgICAgICAgICAgKGlkSW5kZXggPiAtMSkgPyBbbWV0YS5zbGljZSgwLCBpZEluZGV4KSwgbWV0YS5zbGljZShpZEluZGV4ICsgMildIDogW21ldGEsICcnXTtcbiAgICAgICAgW21lYW5pbmcsIGRlc2NyaXB0aW9uXSA9IChkZXNjSW5kZXggPiAtMSkgP1xuICAgICAgICAgICAgW21lYW5pbmdBbmREZXNjLnNsaWNlKDAsIGRlc2NJbmRleCksIG1lYW5pbmdBbmREZXNjLnNsaWNlKGRlc2NJbmRleCArIDEpXSA6XG4gICAgICAgICAgICBbJycsIG1lYW5pbmdBbmREZXNjXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY3VzdG9tSWQsIG1lYW5pbmcsIGRlc2NyaXB0aW9uIH07XG59XG4vLyBDb252ZXJ0cyBpMThuIG1ldGEgaW5mb3JtYXRpb24gZm9yIGEgbWVzc2FnZSAoaWQsIGRlc2NyaXB0aW9uLCBtZWFuaW5nKVxuLy8gdG8gYSBKc0RvYyBzdGF0ZW1lbnQgZm9ybWF0dGVkIGFzIGV4cGVjdGVkIGJ5IHRoZSBDbG9zdXJlIGNvbXBpbGVyLlxuZnVuY3Rpb24gaTE4bk1ldGFUb0pTRG9jKG1ldGEpIHtcbiAgICBjb25zdCB0YWdzID0gW107XG4gICAgaWYgKG1ldGEuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdGFncy5wdXNoKHsgdGFnTmFtZTogXCJkZXNjXCIgLyogRGVzYyAqLywgdGV4dDogbWV0YS5kZXNjcmlwdGlvbiB9KTtcbiAgICB9XG4gICAgaWYgKG1ldGEubWVhbmluZykge1xuICAgICAgICB0YWdzLnB1c2goeyB0YWdOYW1lOiBcIm1lYW5pbmdcIiAvKiBNZWFuaW5nICovLCB0ZXh0OiBtZXRhLm1lYW5pbmcgfSk7XG4gICAgfVxuICAgIHJldHVybiB0YWdzLmxlbmd0aCA9PSAwID8gbnVsbCA6IGpzRG9jQ29tbWVudCh0YWdzKTtcbn1cblxuLyoqIENsb3N1cmUgdXNlcyBgZ29vZy5nZXRNc2cobWVzc2FnZSlgIHRvIGxvb2t1cCB0cmFuc2xhdGlvbnMgKi9cbmNvbnN0IEdPT0dfR0VUX01TRyA9ICdnb29nLmdldE1zZyc7XG5mdW5jdGlvbiBjcmVhdGVHb29nbGVHZXRNc2dTdGF0ZW1lbnRzKHZhcmlhYmxlJDEsIG1lc3NhZ2UsIGNsb3N1cmVWYXIsIHBhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2VTdHJpbmcgPSBzZXJpYWxpemVJMThuTWVzc2FnZUZvckdldE1zZyhtZXNzYWdlKTtcbiAgICBjb25zdCBhcmdzID0gW2xpdGVyYWwobWVzc2FnZVN0cmluZyldO1xuICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICBhcmdzLnB1c2gobWFwTGl0ZXJhbChwYXJhbXMsIHRydWUpKTtcbiAgICB9XG4gICAgLy8gLyoqXG4gICAgLy8gICogQGRlc2MgZGVzY3JpcHRpb24gb2YgbWVzc2FnZVxuICAgIC8vICAqIEBtZWFuaW5nIG1lYW5pbmcgb2YgbWVzc2FnZVxuICAgIC8vICAqL1xuICAgIC8vIGNvbnN0IE1TR18uLi4gPSBnb29nLmdldE1zZyguLik7XG4gICAgLy8gSTE4Tl9YID0gTVNHXy4uLjtcbiAgICBjb25zdCBnb29nR2V0TXNnU3RtdCA9IGNsb3N1cmVWYXIuc2V0KHZhcmlhYmxlKEdPT0dfR0VUX01TRykuY2FsbEZuKGFyZ3MpKS50b0NvbnN0RGVjbCgpO1xuICAgIGNvbnN0IG1ldGFDb21tZW50ID0gaTE4bk1ldGFUb0pTRG9jKG1lc3NhZ2UpO1xuICAgIGlmIChtZXRhQ29tbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBnb29nR2V0TXNnU3RtdC5hZGRMZWFkaW5nQ29tbWVudChtZXRhQ29tbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGkxOG5Bc3NpZ25tZW50U3RtdCA9IG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHZhcmlhYmxlJDEuc2V0KGNsb3N1cmVWYXIpKTtcbiAgICByZXR1cm4gW2dvb2dHZXRNc2dTdG10LCBpMThuQXNzaWdubWVudFN0bXRdO1xufVxuLyoqXG4gKiBUaGlzIHZpc2l0b3Igd2Fsa3Mgb3ZlciBpMThuIHRyZWUgYW5kIGdlbmVyYXRlcyBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCBpbmNsdWRpbmcgSUNVcyBhbmRcbiAqIHBsYWNlaG9sZGVycyBpbiBgeyRwbGFjZWhvbGRlcn1gIChmb3IgcGxhaW4gbWVzc2FnZXMpIG9yIGB7UExBQ0VIT0xERVJ9YCAoaW5zaWRlIElDVXMpIGZvcm1hdC5cbiAqL1xuY2xhc3MgR2V0TXNnU2VyaWFsaXplclZpc2l0b3Ige1xuICAgIGZvcm1hdFBoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBgeyQke2Zvcm1hdEkxOG5QbGFjZWhvbGRlck5hbWUodmFsdWUpfX1gO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1KSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVJY3VOb2RlKGljdSk7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgcmV0dXJuIHBoLmlzVm9pZCA/XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBoKHBoLnN0YXJ0TmFtZSkgOlxuICAgICAgICAgICAgYCR7dGhpcy5mb3JtYXRQaChwaC5zdGFydE5hbWUpfSR7cGguY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKS5qb2luKCcnKX0ke3RoaXMuZm9ybWF0UGgocGguY2xvc2VOYW1lKX1gO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFBoKHBoLm5hbWUpO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFBoKHBoLm5hbWUpO1xuICAgIH1cbn1cbmNvbnN0IHNlcmlhbGl6ZXJWaXNpdG9yID0gbmV3IEdldE1zZ1NlcmlhbGl6ZXJWaXNpdG9yKCk7XG5mdW5jdGlvbiBzZXJpYWxpemVJMThuTWVzc2FnZUZvckdldE1zZyhtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2Uubm9kZXMubWFwKG5vZGUgPT4gbm9kZS52aXNpdChzZXJpYWxpemVyVmlzaXRvciwgbnVsbCkpLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbGl6ZVN0YXRlbWVudHModmFyaWFibGUsIG1lc3NhZ2UsIHBhcmFtcykge1xuICAgIGNvbnN0IHsgbWVzc2FnZVBhcnRzLCBwbGFjZUhvbGRlcnMgfSA9IHNlcmlhbGl6ZUkxOG5NZXNzYWdlRm9yTG9jYWxpemUobWVzc2FnZSk7XG4gICAgY29uc3Qgc291cmNlU3BhbiA9IGdldFNvdXJjZVNwYW4obWVzc2FnZSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbnMgPSBwbGFjZUhvbGRlcnMubWFwKHBoID0+IHBhcmFtc1twaC50ZXh0XSk7XG4gICAgY29uc3QgbG9jYWxpemVkU3RyaW5nJDEgPSBsb2NhbGl6ZWRTdHJpbmcobWVzc2FnZSwgbWVzc2FnZVBhcnRzLCBwbGFjZUhvbGRlcnMsIGV4cHJlc3Npb25zLCBzb3VyY2VTcGFuKTtcbiAgICBjb25zdCB2YXJpYWJsZUluaXRpYWxpemF0aW9uID0gdmFyaWFibGUuc2V0KGxvY2FsaXplZFN0cmluZyQxKTtcbiAgICByZXR1cm4gW25ldyBFeHByZXNzaW9uU3RhdGVtZW50KHZhcmlhYmxlSW5pdGlhbGl6YXRpb24pXTtcbn1cbi8qKlxuICogVGhpcyB2aXNpdG9yIHdhbGtzIG92ZXIgYW4gaTE4biB0cmVlLCBjYXB0dXJpbmcgbGl0ZXJhbCBzdHJpbmdzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKlxuICogVGhlIHJlc3VsdCBjYW4gYmUgdXNlZCBmb3IgZ2VuZXJhdGluZyB0aGUgYCRsb2NhbGl6ZWAgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxzLlxuICovXG5jbGFzcyBMb2NhbGl6ZVNlcmlhbGl6ZXJWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclRvTWVzc2FnZSwgcGllY2VzKSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2UgPSBwbGFjZWhvbGRlclRvTWVzc2FnZTtcbiAgICAgICAgdGhpcy5waWVjZXMgPSBwaWVjZXM7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlc1t0aGlzLnBpZWNlcy5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIExpdGVyYWxQaWVjZSkge1xuICAgICAgICAgICAgLy8gVHdvIGxpdGVyYWwgcGllY2VzIGluIGEgcm93IG1lYW5zIHRoYXQgdGhlcmUgd2FzIHNvbWUgY29tbWVudCBub2RlIGluLWJldHdlZW4uXG4gICAgICAgICAgICB0aGlzLnBpZWNlc1t0aGlzLnBpZWNlcy5sZW5ndGggLSAxXS50ZXh0ICs9IHRleHQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3Bhbih0ZXh0LnNvdXJjZVNwYW4uZnVsbFN0YXJ0LCB0ZXh0LnNvdXJjZVNwYW4uZW5kLCB0ZXh0LnNvdXJjZVNwYW4uZnVsbFN0YXJ0LCB0ZXh0LnNvdXJjZVNwYW4uZGV0YWlscyk7XG4gICAgICAgICAgICB0aGlzLnBpZWNlcy5wdXNoKG5ldyBMaXRlcmFsUGllY2UodGV4dC52YWx1ZSwgc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSkge1xuICAgICAgICB0aGlzLnBpZWNlcy5wdXNoKG5ldyBMaXRlcmFsUGllY2Uoc2VyaWFsaXplSWN1Tm9kZShpY3UpLCBpY3Uuc291cmNlU3BhbikpO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMucGllY2VzLnB1c2godGhpcy5jcmVhdGVQbGFjZWhvbGRlclBpZWNlKHBoLnN0YXJ0TmFtZSwgKF9hID0gcGguc3RhcnRTb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwaC5zb3VyY2VTcGFuKSk7XG4gICAgICAgIGlmICghcGguaXNWb2lkKSB7XG4gICAgICAgICAgICBwaC5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMucGllY2VzLnB1c2godGhpcy5jcmVhdGVQbGFjZWhvbGRlclBpZWNlKHBoLmNsb3NlTmFtZSwgKF9iID0gcGguZW5kU291cmNlU3BhbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcGguc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgdGhpcy5waWVjZXMucHVzaCh0aGlzLmNyZWF0ZVBsYWNlaG9sZGVyUGllY2UocGgubmFtZSwgcGguc291cmNlU3BhbikpO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHRoaXMucGllY2VzLnB1c2godGhpcy5jcmVhdGVQbGFjZWhvbGRlclBpZWNlKHBoLm5hbWUsIHBoLnNvdXJjZVNwYW4sIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGgubmFtZV0pKTtcbiAgICB9XG4gICAgY3JlYXRlUGxhY2Vob2xkZXJQaWVjZShuYW1lLCBzb3VyY2VTcGFuLCBhc3NvY2lhdGVkTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyUGllY2UoZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZShuYW1lLCAvKiB1c2VDYW1lbENhc2UgKi8gZmFsc2UpLCBzb3VyY2VTcGFuLCBhc3NvY2lhdGVkTWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXJpYWxpemUgYW4gaTE4biBtZXNzYWdlIGludG8gdHdvIGFycmF5czogbWVzc2FnZVBhcnRzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKlxuICogVGhlc2UgYXJyYXlzIHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSBgJGxvY2FsaXplYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgc2VyaWFsaXplZC5cbiAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtZXNzYWdlUGFydHMgYW5kIHBsYWNlaG9sZGVycy5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplSTE4bk1lc3NhZ2VGb3JMb2NhbGl6ZShtZXNzYWdlKSB7XG4gICAgY29uc3QgcGllY2VzID0gW107XG4gICAgY29uc3Qgc2VyaWFsaXplclZpc2l0b3IgPSBuZXcgTG9jYWxpemVTZXJpYWxpemVyVmlzaXRvcihtZXNzYWdlLnBsYWNlaG9sZGVyVG9NZXNzYWdlLCBwaWVjZXMpO1xuICAgIG1lc3NhZ2Uubm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUudmlzaXQoc2VyaWFsaXplclZpc2l0b3IpKTtcbiAgICByZXR1cm4gcHJvY2Vzc01lc3NhZ2VQaWVjZXMocGllY2VzKTtcbn1cbmZ1bmN0aW9uIGdldFNvdXJjZVNwYW4obWVzc2FnZSkge1xuICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IG1lc3NhZ2Uubm9kZXNbMF07XG4gICAgY29uc3QgZW5kTm9kZSA9IG1lc3NhZ2Uubm9kZXNbbWVzc2FnZS5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydE5vZGUuc291cmNlU3Bhbi5mdWxsU3RhcnQsIGVuZE5vZGUuc291cmNlU3Bhbi5lbmQsIHN0YXJ0Tm9kZS5zb3VyY2VTcGFuLmZ1bGxTdGFydCwgc3RhcnROb2RlLnNvdXJjZVNwYW4uZGV0YWlscyk7XG59XG4vKipcbiAqIENvbnZlcnQgdGhlIGxpc3Qgb2Ygc2VyaWFsaXplZCBNZXNzYWdlUGllY2VzIGludG8gdHdvIGFycmF5cy5cbiAqXG4gKiBPbmUgY29udGFpbnMgdGhlIGxpdGVyYWwgc3RyaW5nIHBpZWNlcyBhbmQgdGhlIG90aGVyIHRoZSBwbGFjZWhvbGRlcnMgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5XG4gKiBleHByZXNzaW9ucyB3aGVuIHJlbmRlcmluZyBgJGxvY2FsaXplYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gKlxuICogQHBhcmFtIHBpZWNlcyBUaGUgcGllY2VzIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWVzc2FnZVBhcnRzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUGllY2VzKHBpZWNlcykge1xuICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHBsYWNlSG9sZGVycyA9IFtdO1xuICAgIGlmIChwaWVjZXNbMF0gaW5zdGFuY2VvZiBQbGFjZWhvbGRlclBpZWNlKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwaWVjZSB3YXMgYSBwbGFjZWhvbGRlciBzbyB3ZSBuZWVkIHRvIGFkZCBhbiBpbml0aWFsIGVtcHR5IG1lc3NhZ2UgcGFydC5cbiAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY3JlYXRlRW1wdHlNZXNzYWdlUGFydChwaWVjZXNbMF0uc291cmNlU3Bhbi5zdGFydCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGllY2VzW2ldO1xuICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIExpdGVyYWxQaWVjZSkge1xuICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbGFjZUhvbGRlcnMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIGlmIChwaWVjZXNbaSAtIDFdIGluc3RhbmNlb2YgUGxhY2Vob2xkZXJQaWVjZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdlcmUgdHdvIHBsYWNlaG9sZGVycyBpbiBhIHJvdywgc28gd2UgbmVlZCB0byBhZGQgYW4gZW1wdHkgbWVzc2FnZSBwYXJ0LlxuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGNyZWF0ZUVtcHR5TWVzc2FnZVBhcnQocGllY2VzW2kgLSAxXS5zb3VyY2VTcGFuLmVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgUGxhY2Vob2xkZXJQaWVjZSkge1xuICAgICAgICAvLyBUaGUgbGFzdCBwaWVjZSB3YXMgYSBwbGFjZWhvbGRlciBzbyB3ZSBuZWVkIHRvIGFkZCBhIGZpbmFsIGVtcHR5IG1lc3NhZ2UgcGFydC5cbiAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY3JlYXRlRW1wdHlNZXNzYWdlUGFydChwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdLnNvdXJjZVNwYW4uZW5kKSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2VQYXJ0cywgcGxhY2VIb2xkZXJzIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eU1lc3NhZ2VQYXJ0KGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsUGllY2UoJycsIG5ldyBQYXJzZVNvdXJjZVNwYW4obG9jYXRpb24sIGxvY2F0aW9uKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gU2VsZWN0b3IgYXR0cmlidXRlIG5hbWUgb2YgYDxuZy1jb250ZW50PmBcbmNvbnN0IE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIgPSAnc2VsZWN0Jztcbi8vIEF0dHJpYnV0ZSBuYW1lIG9mIGBuZ1Byb2plY3RBc2AuXG5jb25zdCBOR19QUk9KRUNUX0FTX0FUVFJfTkFNRSA9ICduZ1Byb2plY3RBcyc7XG4vLyBHbG9iYWwgc3ltYm9scyBhdmFpbGFibGUgb25seSBpbnNpZGUgZXZlbnQgYmluZGluZ3MuXG5jb25zdCBFVkVOVF9CSU5ESU5HX1NDT1BFX0dMT0JBTFMgPSBuZXcgU2V0KFsnJGV2ZW50J10pO1xuLy8gTGlzdCBvZiBzdXBwb3J0ZWQgZ2xvYmFsIHRhcmdldHMgZm9yIGV2ZW50IGxpc3RlbmVyc1xuY29uc3QgR0xPQkFMX1RBUkdFVF9SRVNPTFZFUlMgPSBuZXcgTWFwKFtbJ3dpbmRvdycsIElkZW50aWZpZXJzJDEucmVzb2x2ZVdpbmRvd10sIFsnZG9jdW1lbnQnLCBJZGVudGlmaWVycyQxLnJlc29sdmVEb2N1bWVudF0sIFsnYm9keScsIElkZW50aWZpZXJzJDEucmVzb2x2ZUJvZHldXSk7XG5jb25zdCBMRUFESU5HX1RSSVZJQV9DSEFSUyA9IFsnICcsICdcXG4nLCAnXFxyJywgJ1xcdCddO1xuLy8gIGlmIChyZiAmIGZsYWdzKSB7IC4uIH1cbmZ1bmN0aW9uIHJlbmRlckZsYWdDaGVja0lmU3RtdChmbGFncywgc3RhdGVtZW50cykge1xuICAgIHJldHVybiBpZlN0bXQodmFyaWFibGUoUkVOREVSX0ZMQUdTKS5iaXR3aXNlQW5kKGxpdGVyYWwoZmxhZ3MpLCBudWxsLCBmYWxzZSksIHN0YXRlbWVudHMpO1xufVxuZnVuY3Rpb24gcHJlcGFyZUV2ZW50TGlzdGVuZXJQYXJhbWV0ZXJzKGV2ZW50QXN0LCBoYW5kbGVyTmFtZSA9IG51bGwsIHNjb3BlID0gbnVsbCkge1xuICAgIGNvbnN0IHsgdHlwZSwgbmFtZSwgdGFyZ2V0LCBwaGFzZSwgaGFuZGxlciB9ID0gZXZlbnRBc3Q7XG4gICAgaWYgKHRhcmdldCAmJiAhR0xPQkFMX1RBUkdFVF9SRVNPTFZFUlMuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGdsb2JhbCB0YXJnZXQgJyR7dGFyZ2V0fScgZGVmaW5lZCBmb3IgJyR7bmFtZX0nIGV2ZW50LlxuICAgICAgICBTdXBwb3J0ZWQgbGlzdCBvZiBnbG9iYWwgdGFyZ2V0czogJHtBcnJheS5mcm9tKEdMT0JBTF9UQVJHRVRfUkVTT0xWRVJTLmtleXMoKSl9LmApO1xuICAgIH1cbiAgICBjb25zdCBldmVudEFyZ3VtZW50TmFtZSA9ICckZXZlbnQnO1xuICAgIGNvbnN0IGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3NlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbXBsaWNpdFJlY2VpdmVyRXhwciA9IChzY29wZSA9PT0gbnVsbCB8fCBzY29wZS5iaW5kaW5nTGV2ZWwgPT09IDApID9cbiAgICAgICAgdmFyaWFibGUoQ09OVEVYVF9OQU1FKSA6XG4gICAgICAgIHNjb3BlLmdldE9yQ3JlYXRlU2hhcmVkQ29udGV4dFZhcigwKTtcbiAgICBjb25zdCBiaW5kaW5nU3RhdGVtZW50cyA9IGNvbnZlcnRBY3Rpb25CaW5kaW5nKHNjb3BlLCBpbXBsaWNpdFJlY2VpdmVyRXhwciwgaGFuZGxlciwgJ2InLCAoKSA9PiBlcnJvcignVW5leHBlY3RlZCBpbnRlcnBvbGF0aW9uJyksIGV2ZW50QXN0LmhhbmRsZXJTcGFuLCBpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMsIEVWRU5UX0JJTkRJTkdfU0NPUEVfR0xPQkFMUyk7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgICAvLyBgdmFyaWFibGVEZWNsYXJhdGlvbnNgIG5lZWRzIHRvIHJ1biBmaXJzdCwgYmVjYXVzZVxuICAgICAgICAvLyBgcmVzdG9yZVZpZXdTdGF0ZW1lbnRgIGRlcGVuZHMgb24gdGhlIHJlc3VsdC5cbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKC4uLnNjb3BlLnZhcmlhYmxlRGVjbGFyYXRpb25zKCkpO1xuICAgICAgICBzdGF0ZW1lbnRzLnVuc2hpZnQoLi4uc2NvcGUucmVzdG9yZVZpZXdTdGF0ZW1lbnQoKSk7XG4gICAgfVxuICAgIHN0YXRlbWVudHMucHVzaCguLi5iaW5kaW5nU3RhdGVtZW50cyk7XG4gICAgY29uc3QgZXZlbnROYW1lID0gdHlwZSA9PT0gMSAvKiBBbmltYXRpb24gKi8gPyBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJOYW1lKG5hbWUsIHBoYXNlKSA6IG5hbWU7XG4gICAgY29uc3QgZm5OYW1lID0gaGFuZGxlck5hbWUgJiYgc2FuaXRpemVJZGVudGlmaWVyKGhhbmRsZXJOYW1lKTtcbiAgICBjb25zdCBmbkFyZ3MgPSBbXTtcbiAgICBpZiAoaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzLmhhcyhldmVudEFyZ3VtZW50TmFtZSkpIHtcbiAgICAgICAgZm5BcmdzLnB1c2gobmV3IEZuUGFyYW0oZXZlbnRBcmd1bWVudE5hbWUsIERZTkFNSUNfVFlQRSkpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVyRm4gPSBmbihmbkFyZ3MsIHN0YXRlbWVudHMsIElORkVSUkVEX1RZUEUsIG51bGwsIGZuTmFtZSk7XG4gICAgY29uc3QgcGFyYW1zID0gW2xpdGVyYWwoZXZlbnROYW1lKSwgaGFuZGxlckZuXTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoZmFsc2UpLCAvLyBgdXNlQ2FwdHVyZWAgZmxhZywgZGVmYXVsdHMgdG8gYGZhbHNlYFxuICAgICAgICBpbXBvcnRFeHByKEdMT0JBTF9UQVJHRVRfUkVTT0xWRVJTLmdldCh0YXJnZXQpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnREZWZDb25zdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlcGFyZVN0YXRlbWVudHM6IFtdLFxuICAgICAgICBjb25zdEV4cHJlc3Npb25zOiBbXSxcbiAgICAgICAgaTE4blZhclJlZnNDYWNoZTogbmV3IE1hcCgpLFxuICAgIH07XG59XG5jbGFzcyBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdGFudFBvb2wsIHBhcmVudEJpbmRpbmdTY29wZSwgbGV2ZWwgPSAwLCBjb250ZXh0TmFtZSwgaTE4bkNvbnRleHQsIHRlbXBsYXRlSW5kZXgsIHRlbXBsYXRlTmFtZSwgX25hbWVzcGFjZSwgcmVsYXRpdmVDb250ZXh0RmlsZVBhdGgsIGkxOG5Vc2VFeHRlcm5hbElkcywgX2NvbnN0YW50cyA9IGNyZWF0ZUNvbXBvbmVudERlZkNvbnN0cygpKSB7XG4gICAgICAgIHRoaXMuY29uc3RhbnRQb29sID0gY29uc3RhbnRQb29sO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIHRoaXMuY29udGV4dE5hbWUgPSBjb250ZXh0TmFtZTtcbiAgICAgICAgdGhpcy5pMThuQ29udGV4dCA9IGkxOG5Db250ZXh0O1xuICAgICAgICB0aGlzLnRlbXBsYXRlSW5kZXggPSB0ZW1wbGF0ZUluZGV4O1xuICAgICAgICB0aGlzLnRlbXBsYXRlTmFtZSA9IHRlbXBsYXRlTmFtZTtcbiAgICAgICAgdGhpcy5fbmFtZXNwYWNlID0gX25hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5pMThuVXNlRXh0ZXJuYWxJZHMgPSBpMThuVXNlRXh0ZXJuYWxJZHM7XG4gICAgICAgIHRoaXMuX2NvbnN0YW50cyA9IF9jb25zdGFudHM7XG4gICAgICAgIHRoaXMuX2RhdGFJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdDb250ZXh0ID0gMDtcbiAgICAgICAgdGhpcy5fcHJlZml4Q29kZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBjYWxsYmFja3MgdG8gZ2VuZXJhdGUgY3JlYXRpb24gbW9kZSBpbnN0cnVjdGlvbnMuIFdlIHN0b3JlIHRoZW0gaGVyZSBhcyB3ZSBwcm9jZXNzXG4gICAgICAgICAqIHRoZSB0ZW1wbGF0ZSBzbyBiaW5kaW5ncyBpbiBsaXN0ZW5lcnMgYXJlIHJlc29sdmVkIG9ubHkgb25jZSBhbGwgbm9kZXMgaGF2ZSBiZWVuIHZpc2l0ZWQuXG4gICAgICAgICAqIFRoaXMgZW5zdXJlcyBhbGwgbG9jYWwgcmVmcyBhbmQgY29udGV4dCB2YXJpYWJsZXMgYXJlIGF2YWlsYWJsZSBmb3IgbWF0Y2hpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jcmVhdGlvbkNvZGVGbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgY2FsbGJhY2tzIHRvIGdlbmVyYXRlIHVwZGF0ZSBtb2RlIGluc3RydWN0aW9ucy4gV2Ugc3RvcmUgdGhlbSBoZXJlIGFzIHdlIHByb2Nlc3NcbiAgICAgICAgICogdGhlIHRlbXBsYXRlIHNvIGJpbmRpbmdzIGFyZSByZXNvbHZlZCBvbmx5IG9uY2UgYWxsIG5vZGVzIGhhdmUgYmVlbiB2aXNpdGVkLiBUaGlzIGVuc3VyZXNcbiAgICAgICAgICogYWxsIGxvY2FsIHJlZnMgYW5kIGNvbnRleHQgdmFyaWFibGVzIGFyZSBhdmFpbGFibGUgZm9yIG1hdGNoaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdXBkYXRlQ29kZUZucyA9IFtdO1xuICAgICAgICAvKiogSW5kZXggb2YgdGhlIGN1cnJlbnRseS1zZWxlY3RlZCBub2RlLiAqL1xuICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICAvKiogVGVtcG9yYXJ5IHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBnZW5lcmF0ZWQgZnJvbSB2aXNpdGluZyBwaXBlcywgbGl0ZXJhbHMsIGV0Yy4gKi9cbiAgICAgICAgdGhpcy5fdGVtcFZhcmlhYmxlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBjYWxsYmFja3MgdG8gYnVpbGQgbmVzdGVkIHRlbXBsYXRlcy4gTmVzdGVkIHRlbXBsYXRlcyBtdXN0IG5vdCBiZSB2aXNpdGVkIHVudGlsXG4gICAgICAgICAqIGFmdGVyIHRoZSBwYXJlbnQgdGVtcGxhdGUgaGFzIGZpbmlzaGVkIHZpc2l0aW5nIGFsbCBvZiBpdHMgbm9kZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGFsbFxuICAgICAgICAgKiBsb2NhbCByZWYgYmluZGluZ3MgaW4gbmVzdGVkIHRlbXBsYXRlcyBhcmUgYWJsZSB0byBmaW5kIGxvY2FsIHJlZiB2YWx1ZXMgaWYgdGhlIHJlZnNcbiAgICAgICAgICogYXJlIGRlZmluZWQgYWZ0ZXIgdGhlIHRlbXBsYXRlIGRlY2xhcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVzdGVkVGVtcGxhdGVGbnMgPSBbXTtcbiAgICAgICAgLy8gaTE4biBjb250ZXh0IGxvY2FsIHRvIHRoaXMgdGVtcGxhdGVcbiAgICAgICAgdGhpcy5pMThuID0gbnVsbDtcbiAgICAgICAgLy8gTnVtYmVyIG9mIHNsb3RzIHRvIHJlc2VydmUgZm9yIHB1cmVGdW5jdGlvbnNcbiAgICAgICAgdGhpcy5fcHVyZUZ1bmN0aW9uU2xvdHMgPSAwO1xuICAgICAgICAvLyBOdW1iZXIgb2YgYmluZGluZyBzbG90c1xuICAgICAgICB0aGlzLl9iaW5kaW5nU2xvdHMgPSAwO1xuICAgICAgICAvLyBQcm9qZWN0aW9uIHNsb3RzIGZvdW5kIGluIHRoZSB0ZW1wbGF0ZS4gUHJvamVjdGlvbiBzbG90cyBjYW4gZGlzdHJpYnV0ZSBwcm9qZWN0ZWRcbiAgICAgICAgLy8gbm9kZXMgYmFzZWQgb24gYSBzZWxlY3Rvciwgb3IgY2FuIGp1c3QgdXNlIHRoZSB3aWxkY2FyZCBzZWxlY3RvciB0byBtYXRjaFxuICAgICAgICAvLyBhbGwgbm9kZXMgd2hpY2ggYXJlbid0IG1hdGNoaW5nIGFueSBzZWxlY3Rvci5cbiAgICAgICAgdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cyA9IFtdO1xuICAgICAgICAvLyBOdW1iZXIgb2Ygbm9uLWRlZmF1bHQgc2VsZWN0b3JzIGZvdW5kIGluIGFsbCBwYXJlbnQgdGVtcGxhdGVzIG9mIHRoaXMgdGVtcGxhdGUuIFdlIG5lZWQgdG9cbiAgICAgICAgLy8gdHJhY2sgaXQgdG8gcHJvcGVybHkgYWRqdXN0IHByb2plY3Rpb24gc2xvdCBpbmRleCBpbiB0aGUgYHByb2plY3Rpb25gIGluc3RydWN0aW9uLlxuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRTZWxlY3RvcnNPZmZzZXQgPSAwO1xuICAgICAgICAvLyBFeHByZXNzaW9uIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgaW1wbGljaXQgcmVjZWl2ZXIgd2hlbiBjb252ZXJ0aW5nIHRlbXBsYXRlXG4gICAgICAgIC8vIGV4cHJlc3Npb25zIHRvIG91dHB1dCBBU1QuXG4gICAgICAgIHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXJFeHByID0gbnVsbDtcbiAgICAgICAgLy8gVGhlc2Ugc2hvdWxkIGJlIGhhbmRsZWQgaW4gdGhlIHRlbXBsYXRlIG9yIGVsZW1lbnQgZGlyZWN0bHkuXG4gICAgICAgIHRoaXMudmlzaXRSZWZlcmVuY2UgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0VmFyaWFibGUgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0VGV4dEF0dHJpYnV0ZSA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRCb3VuZEF0dHJpYnV0ZSA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRCb3VuZEV2ZW50ID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlID0gcGFyZW50QmluZGluZ1Njb3BlLm5lc3RlZFNjb3BlKGxldmVsKTtcbiAgICAgICAgLy8gVHVybiB0aGUgcmVsYXRpdmUgY29udGV4dCBmaWxlIHBhdGggaW50byBhbiBpZGVudGlmaWVyIGJ5IHJlcGxhY2luZyBub24tYWxwaGFudW1lcmljXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgd2l0aCB1bmRlcnNjb3Jlcy5cbiAgICAgICAgdGhpcy5maWxlQmFzZWRJMThuU3VmZml4ID0gcmVsYXRpdmVDb250ZXh0RmlsZVBhdGgucmVwbGFjZSgvW15BLVphLXowLTldL2csICdfJykgKyAnXyc7XG4gICAgICAgIHRoaXMuX3ZhbHVlQ29udmVydGVyID0gbmV3IFZhbHVlQ29udmVydGVyKGNvbnN0YW50UG9vbCwgKCkgPT4gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCksIChudW1TbG90cykgPT4gdGhpcy5hbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzKG51bVNsb3RzKSwgKG5hbWUsIGxvY2FsTmFtZSwgc2xvdCwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdTY29wZS5zZXQodGhpcy5sZXZlbCwgbG9jYWxOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMkMS5waXBlLCBbbGl0ZXJhbChzbG90KSwgbGl0ZXJhbChuYW1lKV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVpbGRUZW1wbGF0ZUZ1bmN0aW9uKG5vZGVzLCB2YXJpYWJsZXMsIG5nQ29udGVudFNlbGVjdG9yc09mZnNldCA9IDAsIGkxOG4pIHtcbiAgICAgICAgdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0ID0gbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0O1xuICAgICAgICBpZiAodGhpcy5fbmFtZXNwYWNlICE9PSBJZGVudGlmaWVycyQxLm5hbWVzcGFjZUhUTUwpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihudWxsLCB0aGlzLl9uYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB2YXJpYWJsZSBiaW5kaW5nc1xuICAgICAgICB2YXJpYWJsZXMuZm9yRWFjaCh2ID0+IHRoaXMucmVnaXN0ZXJDb250ZXh0VmFyaWFibGVzKHYpKTtcbiAgICAgICAgLy8gSW5pdGlhdGUgaTE4biBjb250ZXh0IGluIGNhc2U6XG4gICAgICAgIC8vIC0gdGhpcyB0ZW1wbGF0ZSBoYXMgcGFyZW50IGkxOG4gY29udGV4dFxuICAgICAgICAvLyAtIG9yIHRoZSB0ZW1wbGF0ZSBoYXMgaTE4biBtZXRhIGFzc29jaWF0ZWQgd2l0aCBpdCxcbiAgICAgICAgLy8gICBidXQgaXQncyBub3QgaW5pdGlhdGVkIGJ5IHRoZSBFbGVtZW50IChlLmcuIDxuZy10ZW1wbGF0ZSBpMThuPilcbiAgICAgICAgY29uc3QgaW5pdEkxOG5Db250ZXh0ID0gdGhpcy5pMThuQ29udGV4dCB8fFxuICAgICAgICAgICAgKGlzSTE4blJvb3ROb2RlKGkxOG4pICYmICFpc1NpbmdsZUkxOG5JY3UoaTE4bikgJiZcbiAgICAgICAgICAgICAgICAhKGlzU2luZ2xlRWxlbWVudFRlbXBsYXRlKG5vZGVzKSAmJiBub2Rlc1swXS5pMThuID09PSBpMThuKSk7XG4gICAgICAgIGNvbnN0IHNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uID0gaGFzVGV4dENoaWxkcmVuT25seShub2Rlcyk7XG4gICAgICAgIGlmIChpbml0STE4bkNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4blN0YXJ0KG51bGwsIGkxOG4sIHNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBpbml0aWFsIHBhc3MgdGhyb3VnaCB0aGUgbm9kZXMgb2YgdGhpcyB0ZW1wbGF0ZS4gSW4gdGhpcyBwYXNzLCB3ZVxuICAgICAgICAvLyBxdWV1ZSBhbGwgY3JlYXRpb24gbW9kZSBhbmQgdXBkYXRlIG1vZGUgaW5zdHJ1Y3Rpb25zIGZvciBnZW5lcmF0aW9uIGluIHRoZSBzZWNvbmRcbiAgICAgICAgLy8gcGFzcy4gSXQncyBuZWNlc3NhcnkgdG8gc2VwYXJhdGUgdGhlIHBhc3NlcyB0byBlbnN1cmUgbG9jYWwgcmVmcyBhcmUgZGVmaW5lZCBiZWZvcmVcbiAgICAgICAgLy8gcmVzb2x2aW5nIGJpbmRpbmdzLiBXZSBhbHNvIGNvdW50IGJpbmRpbmdzIGluIHRoaXMgcGFzcyBhcyB3ZSB3YWxrIGJvdW5kIGV4cHJlc3Npb25zLlxuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIG5vZGVzKTtcbiAgICAgICAgLy8gQWRkIHRvdGFsIGJpbmRpbmcgY291bnQgdG8gcHVyZSBmdW5jdGlvbiBjb3VudCBzbyBwdXJlIGZ1bmN0aW9uIGluc3RydWN0aW9ucyBhcmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHdpdGggdGhlIGNvcnJlY3Qgc2xvdCBvZmZzZXQgd2hlbiB1cGRhdGUgaW5zdHJ1Y3Rpb25zIGFyZSBwcm9jZXNzZWQuXG4gICAgICAgIHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzICs9IHRoaXMuX2JpbmRpbmdTbG90cztcbiAgICAgICAgLy8gUGlwZXMgYXJlIHdhbGtlZCBpbiB0aGUgZmlyc3QgcGFzcyAodG8gZW5xdWV1ZSBgcGlwZSgpYCBjcmVhdGlvbiBpbnN0cnVjdGlvbnMgYW5kXG4gICAgICAgIC8vIGBwaXBlQmluZGAgdXBkYXRlIGluc3RydWN0aW9ucyksIHNvIHdlIGhhdmUgdG8gdXBkYXRlIHRoZSBzbG90IG9mZnNldHMgbWFudWFsbHlcbiAgICAgICAgLy8gdG8gYWNjb3VudCBmb3IgYmluZGluZ3MuXG4gICAgICAgIHRoaXMuX3ZhbHVlQ29udmVydGVyLnVwZGF0ZVBpcGVTbG90T2Zmc2V0cyh0aGlzLl9iaW5kaW5nU2xvdHMpO1xuICAgICAgICAvLyBOZXN0ZWQgdGVtcGxhdGVzIG11c3QgYmUgcHJvY2Vzc2VkIGJlZm9yZSBjcmVhdGlvbiBpbnN0cnVjdGlvbnMgc28gdGVtcGxhdGUoKVxuICAgICAgICAvLyBpbnN0cnVjdGlvbnMgY2FuIGJlIGdlbmVyYXRlZCB3aXRoIHRoZSBjb3JyZWN0IGludGVybmFsIGNvbnN0IGNvdW50LlxuICAgICAgICB0aGlzLl9uZXN0ZWRUZW1wbGF0ZUZucy5mb3JFYWNoKGJ1aWxkVGVtcGxhdGVGbiA9PiBidWlsZFRlbXBsYXRlRm4oKSk7XG4gICAgICAgIC8vIE91dHB1dCB0aGUgYHByb2plY3Rpb25EZWZgIGluc3RydWN0aW9uIHdoZW4gc29tZSBgPG5nLWNvbnRlbnQ+YCB0YWdzIGFyZSBwcmVzZW50LlxuICAgICAgICAvLyBUaGUgYHByb2plY3Rpb25EZWZgIGluc3RydWN0aW9uIGlzIG9ubHkgZW1pdHRlZCBmb3IgdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZSBhbmRcbiAgICAgICAgLy8gaXMgc2tpcHBlZCBmb3IgbmVzdGVkIHRlbXBsYXRlcyAoPG5nLXRlbXBsYXRlPiB0YWdzKS5cbiAgICAgICAgaWYgKHRoaXMubGV2ZWwgPT09IDAgJiYgdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQgdGhlIGBwcm9qZWN0aW9uRGVmYCBpbnN0cnVjdGlvbnMgY3JlYXRlcyBvbmUgc2xvdCBmb3IgdGhlIHdpbGRjYXJkXG4gICAgICAgICAgICAvLyBzZWxlY3RvciBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuIFRoZXJlZm9yZSB3ZSBvbmx5IHdhbnQgdG8gYWxsb2NhdGUgYSBuZXdcbiAgICAgICAgICAgIC8vIGFycmF5IGZvciB0aGUgcHJvamVjdGlvbiBzbG90cyBpZiB0aGUgZGVmYXVsdCBwcm9qZWN0aW9uIHNsb3QgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGggPiAxIHx8IHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHNbMF0gIT09ICcqJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIzUmVzZXJ2ZWRTbG90cyA9IHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubWFwKHMgPT4gcyAhPT0gJyonID8gcGFyc2VTZWxlY3RvclRvUjNTZWxlY3RvcihzKSA6IHMpO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLmNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwoYXNMaXRlcmFsKHIzUmVzZXJ2ZWRTbG90cyksIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGFjY3VtdWxhdGUgbmdDb250ZW50IHNlbGVjdG9ycyB3aGlsZSBwcm9jZXNzaW5nIHRlbXBsYXRlIGVsZW1lbnRzLFxuICAgICAgICAgICAgLy8gd2UgKnByZXBlbmQqIGBwcm9qZWN0aW9uRGVmYCB0byBjcmVhdGlvbiBpbnN0cnVjdGlvbnMgYmxvY2ssIHRvIHB1dCBpdCBiZWZvcmVcbiAgICAgICAgICAgIC8vIGFueSBgcHJvamVjdGlvbmAgaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMkMS5wcm9qZWN0aW9uRGVmLCBwYXJhbWV0ZXJzLCAvKiBwcmVwZW5kICovIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0STE4bkNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bkVuZChudWxsLCBzZWxmQ2xvc2luZ0kxOG5JbnN0cnVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2VuZXJhdGUgYWxsIHRoZSBjcmVhdGlvbiBtb2RlIGluc3RydWN0aW9ucyAoZS5nLiByZXNvbHZlIGJpbmRpbmdzIGluIGxpc3RlbmVycylcbiAgICAgICAgY29uc3QgY3JlYXRpb25TdGF0ZW1lbnRzID0gdGhpcy5fY3JlYXRpb25Db2RlRm5zLm1hcCgoZm4pID0+IGZuKCkpO1xuICAgICAgICAvLyBHZW5lcmF0ZSBhbGwgdGhlIHVwZGF0ZSBtb2RlIGluc3RydWN0aW9ucyAoZS5nLiByZXNvbHZlIHByb3BlcnR5IG9yIHRleHQgYmluZGluZ3MpXG4gICAgICAgIGNvbnN0IHVwZGF0ZVN0YXRlbWVudHMgPSB0aGlzLl91cGRhdGVDb2RlRm5zLm1hcCgoZm4pID0+IGZuKCkpO1xuICAgICAgICAvLyAgVmFyaWFibGUgZGVjbGFyYXRpb24gbXVzdCBvY2N1ciBhZnRlciBiaW5kaW5nIHJlc29sdXRpb24gc28gd2UgY2FuIGdlbmVyYXRlIGNvbnRleHRcbiAgICAgICAgLy8gIGluc3RydWN0aW9ucyB0aGF0IGJ1aWxkIG9uIGVhY2ggb3RoZXIuXG4gICAgICAgIC8vIGUuZy4gY29uc3QgYiA9IG5leHRDb250ZXh0KCkuJGltcGxpY2l0KCk7IGNvbnN0IGIgPSBuZXh0Q29udGV4dCgpO1xuICAgICAgICBjb25zdCBjcmVhdGlvblZhcmlhYmxlcyA9IHRoaXMuX2JpbmRpbmdTY29wZS52aWV3U25hcHNob3RTdGF0ZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVZhcmlhYmxlcyA9IHRoaXMuX2JpbmRpbmdTY29wZS52YXJpYWJsZURlY2xhcmF0aW9ucygpLmNvbmNhdCh0aGlzLl90ZW1wVmFyaWFibGVzKTtcbiAgICAgICAgY29uc3QgY3JlYXRpb25CbG9jayA9IGNyZWF0aW9uU3RhdGVtZW50cy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgIFtyZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBDcmVhdGUgKi8sIGNyZWF0aW9uVmFyaWFibGVzLmNvbmNhdChjcmVhdGlvblN0YXRlbWVudHMpKV0gOlxuICAgICAgICAgICAgW107XG4gICAgICAgIGNvbnN0IHVwZGF0ZUJsb2NrID0gdXBkYXRlU3RhdGVtZW50cy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgIFtyZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMiAvKiBVcGRhdGUgKi8sIHVwZGF0ZVZhcmlhYmxlcy5jb25jYXQodXBkYXRlU3RhdGVtZW50cykpXSA6XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIGZuKFxuICAgICAgICAvLyBpLmUuIChyZjogUmVuZGVyRmxhZ3MsIGN0eDogYW55KVxuICAgICAgICBbbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCldLCBbXG4gICAgICAgICAgICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgZGVjbGFyYXRpb25zIGZvciBxdWVyeSByZWZyZXNoIChpLmUuIGxldCBfdDogYW55OylcbiAgICAgICAgICAgIC4uLnRoaXMuX3ByZWZpeENvZGUsXG4gICAgICAgICAgICAvLyBDcmVhdGluZyBtb2RlIChpLmUuIGlmIChyZiAmIFJlbmRlckZsYWdzLkNyZWF0ZSkgeyAuLi4gfSlcbiAgICAgICAgICAgIC4uLmNyZWF0aW9uQmxvY2ssXG4gICAgICAgICAgICAvLyBCaW5kaW5nIGFuZCByZWZyZXNoIG1vZGUgKGkuZS4gaWYgKHJmICYgUmVuZGVyRmxhZ3MuVXBkYXRlKSB7Li4ufSlcbiAgICAgICAgICAgIC4uLnVwZGF0ZUJsb2NrLFxuICAgICAgICBdLCBJTkZFUlJFRF9UWVBFLCBudWxsLCB0aGlzLnRlbXBsYXRlTmFtZSk7XG4gICAgfVxuICAgIC8vIExvY2FsUmVzb2x2ZXJcbiAgICBnZXRMb2NhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nU2NvcGUuZ2V0KG5hbWUpO1xuICAgIH1cbiAgICAvLyBMb2NhbFJlc29sdmVyXG4gICAgbm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKTtcbiAgICB9XG4gICAgLy8gTG9jYWxSZXNvbHZlclxuICAgIG1heWJlUmVzdG9yZVZpZXcoKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdTY29wZS5tYXliZVJlc3RvcmVWaWV3KCk7XG4gICAgfVxuICAgIGkxOG5UcmFuc2xhdGUobWVzc2FnZSwgcGFyYW1zID0ge30sIHJlZiwgdHJhbnNmb3JtRm4pIHtcbiAgICAgICAgY29uc3QgX3JlZiA9IHJlZiB8fCB0aGlzLmkxOG5HZW5lcmF0ZU1haW5CbG9ja1ZhcigpO1xuICAgICAgICAvLyBDbG9zdXJlIENvbXBpbGVyIHJlcXVpcmVzIGNvbnN0IG5hbWVzIHRvIHN0YXJ0IHdpdGggYE1TR19gIGJ1dCBkaXNhbGxvd3MgYW55IG90aGVyIGNvbnN0IHRvXG4gICAgICAgIC8vIHN0YXJ0IHdpdGggYE1TR19gLiBXZSBkZWZpbmUgYSB2YXJpYWJsZSBzdGFydGluZyB3aXRoIGBNU0dfYCBqdXN0IGZvciB0aGUgYGdvb2cuZ2V0TXNnYCBjYWxsXG4gICAgICAgIGNvbnN0IGNsb3N1cmVWYXIgPSB0aGlzLmkxOG5HZW5lcmF0ZUNsb3N1cmVWYXIobWVzc2FnZS5pZCk7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSBnZXRUcmFuc2xhdGlvbkRlY2xTdG10cyhtZXNzYWdlLCBfcmVmLCBjbG9zdXJlVmFyLCBwYXJhbXMsIHRyYW5zZm9ybUZuKTtcbiAgICAgICAgdGhpcy5fY29uc3RhbnRzLnByZXBhcmVTdGF0ZW1lbnRzLnB1c2goLi4uc3RhdGVtZW50cyk7XG4gICAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cbiAgICByZWdpc3RlckNvbnRleHRWYXJpYWJsZXModmFyaWFibGUkMSkge1xuICAgICAgICBjb25zdCBzY29wZWROYW1lID0gdGhpcy5fYmluZGluZ1Njb3BlLmZyZXNoUmVmZXJlbmNlTmFtZSgpO1xuICAgICAgICBjb25zdCByZXRyaWV2YWxMZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgIGNvbnN0IGxocyA9IHZhcmlhYmxlKHZhcmlhYmxlJDEubmFtZSArIHNjb3BlZE5hbWUpO1xuICAgICAgICB0aGlzLl9iaW5kaW5nU2NvcGUuc2V0KHJldHJpZXZhbExldmVsLCB2YXJpYWJsZSQxLm5hbWUsIGxocywgMSAvKiBDT05URVhUICovLCAoc2NvcGUsIHJlbGF0aXZlTGV2ZWwpID0+IHtcbiAgICAgICAgICAgIGxldCByaHM7XG4gICAgICAgICAgICBpZiAoc2NvcGUuYmluZGluZ0xldmVsID09PSByZXRyaWV2YWxMZXZlbCkge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZS5pc0xpc3RlbmVyU2NvcGUoKSAmJiBzY29wZS5oYXNSZXN0b3JlVmlld1ZhcmlhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiByZXN0b3JlZEN0eC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIGNvbnRleHQgZnJvbSBhIHZpZXcgcmVmZXJlbmNlLCBpZiBvbmUgaXMgYXZhaWxhYmxlLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb250ZXh0IHRoYXQgd2FzIHBhc3NlZCBpbiBkdXJpbmcgY3JlYXRpb24gbWF5IG5vdCBiZSBjb3JyZWN0IGFueW1vcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9wdWxsLzQwMzYwLlxuICAgICAgICAgICAgICAgICAgICByaHMgPSB2YXJpYWJsZShSRVNUT1JFRF9WSUVXX0NPTlRFWFRfTkFNRSk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm5vdGlmeVJlc3RvcmVkVmlld0NvbnRleHRVc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gY3R4XG4gICAgICAgICAgICAgICAgICAgIHJocyA9IHZhcmlhYmxlKENPTlRFWFRfTkFNRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkQ3R4VmFyID0gc2NvcGUuZ2V0U2hhcmVkQ29udGV4dE5hbWUocmV0cmlldmFsTGV2ZWwpO1xuICAgICAgICAgICAgICAgIC8vIGUuZy4gY3R4X3IwICAgT1IgIHgoMik7XG4gICAgICAgICAgICAgICAgcmhzID0gc2hhcmVkQ3R4VmFyID8gc2hhcmVkQ3R4VmFyIDogZ2VuZXJhdGVOZXh0Q29udGV4dEV4cHIocmVsYXRpdmVMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlLmcuIGNvbnN0ICRpdGVtJCA9IHgoMikuJGltcGxpY2l0O1xuICAgICAgICAgICAgcmV0dXJuIFtsaHMuc2V0KHJocy5wcm9wKHZhcmlhYmxlJDEudmFsdWUgfHwgSU1QTElDSVRfUkVGRVJFTkNFKSkudG9Db25zdERlY2woKV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpMThuQXBwZW5kQmluZGluZ3MoZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLmZvckVhY2goZXhwcmVzc2lvbiA9PiB0aGlzLmkxOG4uYXBwZW5kQmluZGluZyhleHByZXNzaW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaTE4bkJpbmRQcm9wcyhwcm9wcykge1xuICAgICAgICBjb25zdCBib3VuZCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIFRleHQkMykge1xuICAgICAgICAgICAgICAgIGJvdW5kW2tleV0gPSBsaXRlcmFsKHByb3AudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wLnZhbHVlLnZpc2l0KHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RyaW5ncywgZXhwcmVzc2lvbnMgfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBiaW5kaW5ncyB9ID0gdGhpcy5pMThuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGFzc2VtYmxlSTE4bkJvdW5kU3RyaW5nKHN0cmluZ3MsIGJpbmRpbmdzLnNpemUsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pMThuQXBwZW5kQmluZGluZ3MoZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICBib3VuZFtrZXldID0gbGl0ZXJhbChsYWJlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZXMgdG9wIGxldmVsIHZhcnMgZm9yIGkxOG4gYmxvY2tzIChpLmUuIGBpMThuX05gKS5cbiAgICBpMThuR2VuZXJhdGVNYWluQmxvY2tWYXIoKSB7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZSh0aGlzLmNvbnN0YW50UG9vbC51bmlxdWVOYW1lKFRSQU5TTEFUSU9OX1ZBUl9QUkVGSVgpKTtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGVzIHZhcnMgd2l0aCBDbG9zdXJlLXNwZWNpZmljIG5hbWVzIGZvciBpMThuIGJsb2NrcyAoaS5lLiBgTVNHX1hYWGApLlxuICAgIGkxOG5HZW5lcmF0ZUNsb3N1cmVWYXIobWVzc2FnZUlkKSB7XG4gICAgICAgIGxldCBuYW1lO1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0aGlzLmZpbGVCYXNlZEkxOG5TdWZmaXgudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuaTE4blVzZUV4dGVybmFsSWRzKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSBnZXRUcmFuc2xhdGlvbkNvbnN0UHJlZml4KGBFWFRFUk5BTF9gKTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVN1ZmZpeCA9IHRoaXMuY29uc3RhbnRQb29sLnVuaXF1ZU5hbWUoc3VmZml4KTtcbiAgICAgICAgICAgIG5hbWUgPSBgJHtwcmVmaXh9JHtzYW5pdGl6ZUlkZW50aWZpZXIobWVzc2FnZUlkKX0kJCR7dW5pcXVlU3VmZml4fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSBnZXRUcmFuc2xhdGlvbkNvbnN0UHJlZml4KHN1ZmZpeCk7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5jb25zdGFudFBvb2wudW5pcXVlTmFtZShwcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZShuYW1lKTtcbiAgICB9XG4gICAgaTE4blVwZGF0ZVJlZihjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHsgaWN1cywgbWV0YSwgaXNSb290LCBpc1Jlc29sdmVkLCBpc0VtaXR0ZWQgfSA9IGNvbnRleHQ7XG4gICAgICAgIGlmIChpc1Jvb3QgJiYgaXNSZXNvbHZlZCAmJiAhaXNFbWl0dGVkICYmICFpc1NpbmdsZUkxOG5JY3UobWV0YSkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaXNFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IGNvbnRleHQuZ2V0U2VyaWFsaXplZFBsYWNlaG9sZGVycygpO1xuICAgICAgICAgICAgbGV0IGljdU1hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBwbGFjZWhvbGRlcnMuc2l6ZSA/IHBsYWNlaG9sZGVyc1RvUGFyYW1zKHBsYWNlaG9sZGVycykgOiB7fTtcbiAgICAgICAgICAgIGlmIChpY3VzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBpY3VzLmZvckVhY2goKHJlZnMsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgb25lIElDVSBkZWZpbmVkIGZvciBhIGdpdmVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlciAtIGp1c3Qgb3V0cHV0IGl0cyByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1trZXldID0gcmVmc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2Ugd2UgbmVlZCB0byBhY3RpdmF0ZSBwb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHJlcGxhY2UgSUNVIHBsYWNlaG9sZGVycyB3aXRoIHByb3BlciB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gd3JhcEkxOG5QbGFjZWhvbGRlcihgJHtJMThOX0lDVV9NQVBQSU5HX1BSRUZJWH0ke2tleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1trZXldID0gbGl0ZXJhbChwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpY3VNYXBwaW5nW2tleV0gPSBsaXRlcmFsQXJyKHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmFuc2xhdGlvbiByZXF1aXJlcyBwb3N0IHByb2Nlc3NpbmcgaW4gMiBjYXNlczpcbiAgICAgICAgICAgIC8vIC0gaWYgd2UgaGF2ZSBwbGFjZWhvbGRlcnMgd2l0aCBtdWx0aXBsZSB2YWx1ZXMgKGV4LiBgU1RBUlRfRElWYDogW++/vSMx77+9LCDvv70jMu+/vSwgLi4uXSlcbiAgICAgICAgICAgIC8vIC0gaWYgd2UgaGF2ZSBtdWx0aXBsZSBJQ1VzIHRoYXQgcmVmZXIgdG8gdGhlIHNhbWUgcGxhY2Vob2xkZXIgbmFtZVxuICAgICAgICAgICAgY29uc3QgbmVlZHNQb3N0cHJvY2Vzc2luZyA9IEFycmF5LmZyb20ocGxhY2Vob2xkZXJzLnZhbHVlcygpKS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUubGVuZ3RoID4gMSkgfHxcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhpY3VNYXBwaW5nKS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgdHJhbnNmb3JtRm47XG4gICAgICAgICAgICBpZiAobmVlZHNQb3N0cHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUZuID0gKHJhdykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW3Jhd107XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhpY3VNYXBwaW5nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChtYXBMaXRlcmFsKGljdU1hcHBpbmcsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMkMS5pMThuUG9zdHByb2Nlc3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmkxOG5UcmFuc2xhdGUobWV0YSwgcGFyYW1zLCBjb250ZXh0LnJlZiwgdHJhbnNmb3JtRm4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkxOG5TdGFydChzcGFuID0gbnVsbCwgbWV0YSwgc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgdGhpcy5pMThuID0gdGhpcy5pMThuQ29udGV4dCA/XG4gICAgICAgICAgICB0aGlzLmkxOG5Db250ZXh0LmZvcmtDaGlsZENvbnRleHQoaW5kZXgsIHRoaXMudGVtcGxhdGVJbmRleCwgbWV0YSkgOlxuICAgICAgICAgICAgbmV3IEkxOG5Db250ZXh0KGluZGV4LCB0aGlzLmkxOG5HZW5lcmF0ZU1haW5CbG9ja1ZhcigpLCAwLCB0aGlzLnRlbXBsYXRlSW5kZXgsIG1ldGEpO1xuICAgICAgICAvLyBnZW5lcmF0ZSBpMThuU3RhcnQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgY29uc3QgeyBpZCwgcmVmIH0gPSB0aGlzLmkxOG47XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtsaXRlcmFsKGluZGV4KSwgdGhpcy5hZGRUb0NvbnN0cyhyZWYpXTtcbiAgICAgICAgaWYgKGlkID4gMCkge1xuICAgICAgICAgICAgLy8gZG8gbm90IHB1c2ggM3JkIGFyZ3VtZW50IChzdWItYmxvY2sgaWQpXG4gICAgICAgICAgICAvLyBpbnRvIGkxOG5TdGFydCBjYWxsIGZvciB0b3AgbGV2ZWwgaTE4biBjb250ZXh0XG4gICAgICAgICAgICBwYXJhbXMucHVzaChsaXRlcmFsKGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHNwYW4sIHNlbGZDbG9zaW5nID8gSWRlbnRpZmllcnMkMS5pMThuIDogSWRlbnRpZmllcnMkMS5pMThuU3RhcnQsIHBhcmFtcyk7XG4gICAgfVxuICAgIGkxOG5FbmQoc3BhbiA9IG51bGwsIHNlbGZDbG9zaW5nKSB7XG4gICAgICAgIGlmICghdGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2kxOG5FbmQgaXMgZXhlY3V0ZWQgd2l0aCBubyBpMThuIGNvbnRleHQgcHJlc2VudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmkxOG5Db250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5Db250ZXh0LnJlY29uY2lsZUNoaWxkQ29udGV4dCh0aGlzLmkxOG4pO1xuICAgICAgICAgICAgdGhpcy5pMThuVXBkYXRlUmVmKHRoaXMuaTE4bkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pMThuVXBkYXRlUmVmKHRoaXMuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0dXAgYWNjdW11bGF0ZWQgYmluZGluZ3NcbiAgICAgICAgY29uc3QgeyBpbmRleCwgYmluZGluZ3MgfSA9IHRoaXMuaTE4bjtcbiAgICAgICAgaWYgKGJpbmRpbmdzLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluQmluZGluZ3MgPSBbXTtcbiAgICAgICAgICAgIGJpbmRpbmdzLmZvckVhY2goYmluZGluZyA9PiB7XG4gICAgICAgICAgICAgICAgY2hhaW5CaW5kaW5ncy5wdXNoKHsgc291cmNlU3Bhbjogc3BhbiwgdmFsdWU6ICgpID0+IHRoaXMuY29udmVydFByb3BlcnR5QmluZGluZyhiaW5kaW5nKSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZm9yIGkxOG4gYmxvY2ssIGFkdmFuY2UgdG8gdGhlIG1vc3QgcmVjZW50IGVsZW1lbnQgaW5kZXggKGJ5IHRha2luZyB0aGUgY3VycmVudCBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzIGFuZCBzdWJ0cmFjdGluZyBvbmUpIGJlZm9yZSBpbnZva2luZyBgaTE4bkV4cGAgaW5zdHJ1Y3Rpb25zLCB0byBtYWtlIHN1cmUgdGhlXG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgbGlmZWN5Y2xlIGhvb2tzIG9mIGNvbXBvbmVudHMvZGlyZWN0aXZlcyBhcmUgcHJvcGVybHkgZmx1c2hlZC5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbldpdGhBZHZhbmNlKHRoaXMuZ2V0Q29uc3RDb3VudCgpIC0gMSwgSWRlbnRpZmllcnMkMS5pMThuRXhwLCBjaGFpbkJpbmRpbmdzKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb24oc3BhbiwgSWRlbnRpZmllcnMkMS5pMThuQXBwbHksIFtsaXRlcmFsKGluZGV4KV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihzcGFuLCBJZGVudGlmaWVycyQxLmkxOG5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaTE4biA9IG51bGw7IC8vIHJlc2V0IGxvY2FsIGkxOG4gY29udGV4dFxuICAgIH1cbiAgICBpMThuQXR0cmlidXRlc0luc3RydWN0aW9uKG5vZGVJbmRleCwgYXR0cnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgbGV0IGhhc0JpbmRpbmdzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGkxOG5BdHRyQXJncyA9IFtdO1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IFtdO1xuICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF0dHIuaTE4bjtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZCA9IGF0dHIudmFsdWUudmlzaXQodGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyhjb252ZXJ0ZWQpO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnRlZCBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlcnMgPSBhc3NlbWJsZUJvdW5kVGV4dFBsYWNlaG9sZGVycyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBwbGFjZWhvbGRlcnNUb1BhcmFtcyhwbGFjZWhvbGRlcnMpO1xuICAgICAgICAgICAgICAgIGkxOG5BdHRyQXJncy5wdXNoKGxpdGVyYWwoYXR0ci5uYW1lKSwgdGhpcy5pMThuVHJhbnNsYXRlKG1lc3NhZ2UsIHBhcmFtcykpO1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZC5leHByZXNzaW9ucy5mb3JFYWNoKGV4cHJlc3Npb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB0aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcoZXhwcmVzc2lvbiksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbldpdGhBZHZhbmNlKG5vZGVJbmRleCwgSWRlbnRpZmllcnMkMS5pMThuRXhwLCBiaW5kaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkxOG5BdHRyQXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGxpdGVyYWwodGhpcy5hbGxvY2F0ZURhdGFTbG90KCkpO1xuICAgICAgICAgICAgY29uc3QgY29uc3RJbmRleCA9IHRoaXMuYWRkVG9Db25zdHMobGl0ZXJhbEFycihpMThuQXR0ckFyZ3MpKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihzb3VyY2VTcGFuLCBJZGVudGlmaWVycyQxLmkxOG5BdHRyaWJ1dGVzLCBbaW5kZXgsIGNvbnN0SW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChoYXNCaW5kaW5ncykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb24oc291cmNlU3BhbiwgSWRlbnRpZmllcnMkMS5pMThuQXBwbHksIFtpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE5hbWVzcGFjZUluc3RydWN0aW9uKG5hbWVzcGFjZUtleSkge1xuICAgICAgICBzd2l0Y2ggKG5hbWVzcGFjZUtleSkge1xuICAgICAgICAgICAgY2FzZSAnbWF0aCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEubmFtZXNwYWNlTWF0aE1MO1xuICAgICAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5uYW1lc3BhY2VTVkc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLm5hbWVzcGFjZUhUTUw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTmFtZXNwYWNlSW5zdHJ1Y3Rpb24obnNJbnN0cnVjdGlvbiwgZWxlbWVudCkge1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBuc0luc3RydWN0aW9uO1xuICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIG5zSW5zdHJ1Y3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIHVwZGF0ZSBpbnN0cnVjdGlvbiBmb3IgYW4gaW50ZXJwb2xhdGVkIHByb3BlcnR5IG9yIGF0dHJpYnV0ZSwgc3VjaCBhc1xuICAgICAqIGBwcm9wPVwie3t2YWx1ZX19XCJgIG9yIGBhdHRyLnRpdGxlPVwie3t2YWx1ZX19XCJgXG4gICAgICovXG4gICAgaW50ZXJwb2xhdGVkVXBkYXRlSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb24sIGVsZW1lbnRJbmRleCwgYXR0ck5hbWUsIGlucHV0LCB2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25XaXRoQWR2YW5jZShlbGVtZW50SW5kZXgsIGlucHV0LnNvdXJjZVNwYW4sIGluc3RydWN0aW9uLCAoKSA9PiBbbGl0ZXJhbChhdHRyTmFtZSksIC4uLnRoaXMuZ2V0VXBkYXRlSW5zdHJ1Y3Rpb25Bcmd1bWVudHModmFsdWUpLCAuLi5wYXJhbXNdKTtcbiAgICB9XG4gICAgdmlzaXRDb250ZW50KG5nQ29udGVudCkge1xuICAgICAgICBjb25zdCBzbG90ID0gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25TbG90SWR4ID0gdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0ICsgdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbbGl0ZXJhbChzbG90KV07XG4gICAgICAgIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMucHVzaChuZ0NvbnRlbnQuc2VsZWN0b3IpO1xuICAgICAgICBjb25zdCBub25Db250ZW50U2VsZWN0QXR0cmlidXRlcyA9IG5nQ29udGVudC5hdHRyaWJ1dGVzLmZpbHRlcihhdHRyID0+IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpICE9PSBOR19DT05URU5UX1NFTEVDVF9BVFRSKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMuZ2V0QXR0cmlidXRlRXhwcmVzc2lvbnMobmdDb250ZW50Lm5hbWUsIG5vbkNvbnRlbnRTZWxlY3RBdHRyaWJ1dGVzLCBbXSwgW10pO1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobGl0ZXJhbChwcm9qZWN0aW9uU2xvdElkeCksIGxpdGVyYWxBcnIoYXR0cmlidXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3Rpb25TbG90SWR4ICE9PSAwKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobGl0ZXJhbChwcm9qZWN0aW9uU2xvdElkeCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihuZ0NvbnRlbnQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMkMS5wcm9qZWN0aW9uLCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuaTE4bikge1xuICAgICAgICAgICAgdGhpcy5pMThuLmFwcGVuZFByb2plY3Rpb24obmdDb250ZW50LmkxOG4sIHNsb3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRJbmRleCA9IHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpO1xuICAgICAgICBjb25zdCBzdHlsaW5nQnVpbGRlciA9IG5ldyBTdHlsaW5nQnVpbGRlcihudWxsKTtcbiAgICAgICAgbGV0IGlzTm9uQmluZGFibGVNb2RlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlzSTE4blJvb3RFbGVtZW50ID0gaXNJMThuUm9vdE5vZGUoZWxlbWVudC5pMThuKSAmJiAhaXNTaW5nbGVJMThuSWN1KGVsZW1lbnQuaTE4bik7XG4gICAgICAgIGNvbnN0IG91dHB1dEF0dHJzID0gW107XG4gICAgICAgIGNvbnN0IFtuYW1lc3BhY2VLZXksIGVsZW1lbnROYW1lXSA9IHNwbGl0TnNOYW1lKGVsZW1lbnQubmFtZSk7XG4gICAgICAgIGNvbnN0IGlzTmdDb250YWluZXIkMSA9IGlzTmdDb250YWluZXIoZWxlbWVudC5uYW1lKTtcbiAgICAgICAgLy8gSGFuZGxlIHN0eWxpbmcsIGkxOG4sIG5nTm9uQmluZGFibGUgYXR0cmlidXRlc1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgZWxlbWVudC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIHZhbHVlIH0gPSBhdHRyO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IE5PTl9CSU5EQUJMRV9BVFRSKSB7XG4gICAgICAgICAgICAgICAgaXNOb25CaW5kYWJsZU1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIHN0eWxpbmdCdWlsZGVyLnJlZ2lzdGVyU3R5bGVBdHRyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICBzdHlsaW5nQnVpbGRlci5yZWdpc3RlckNsYXNzQXR0cih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRBdHRycy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlZ3VsYXIgZWxlbWVudCBvciBuZy1jb250YWluZXIgY3JlYXRpb24gbW9kZVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gW2xpdGVyYWwoZWxlbWVudEluZGV4KV07XG4gICAgICAgIGlmICghaXNOZ0NvbnRhaW5lciQxKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobGl0ZXJhbChlbGVtZW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICAgICAgICBjb25zdCBhbGxPdGhlcklucHV0cyA9IFtdO1xuICAgICAgICBjb25zdCBib3VuZEkxOG5BdHRycyA9IFtdO1xuICAgICAgICBlbGVtZW50LmlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxpbmdJbnB1dFdhc1NldCA9IHN0eWxpbmdCdWlsZGVyLnJlZ2lzdGVyQm91bmRJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICBpZiAoIXN0eWxpbmdJbnB1dFdhc1NldCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAwIC8qIFByb3BlcnR5ICovICYmIGlucHV0LmkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRJMThuQXR0cnMucHVzaChpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGxPdGhlcklucHV0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZGQgYXR0cmlidXRlcyBmb3IgZGlyZWN0aXZlIGFuZCBwcm9qZWN0aW9uIG1hdGNoaW5nIHB1cnBvc2VzXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmdldEF0dHJpYnV0ZUV4cHJlc3Npb25zKGVsZW1lbnQubmFtZSwgb3V0cHV0QXR0cnMsIGFsbE90aGVySW5wdXRzLCBlbGVtZW50Lm91dHB1dHMsIHN0eWxpbmdCdWlsZGVyLCBbXSwgYm91bmRJMThuQXR0cnMpO1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5hZGRBdHRyc1RvQ29uc3RzKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgLy8gbG9jYWwgcmVmcyAoZXguOiA8ZGl2ICNmb28gI2Jhcj1cImJhelwiPilcbiAgICAgICAgY29uc3QgcmVmcyA9IHRoaXMucHJlcGFyZVJlZnNBcnJheShlbGVtZW50LnJlZmVyZW5jZXMpO1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5hZGRUb0NvbnN0cyhyZWZzKSk7XG4gICAgICAgIGNvbnN0IHdhc0luTmFtZXNwYWNlID0gdGhpcy5fbmFtZXNwYWNlO1xuICAgICAgICBjb25zdCBjdXJyZW50TmFtZXNwYWNlID0gdGhpcy5nZXROYW1lc3BhY2VJbnN0cnVjdGlvbihuYW1lc3BhY2VLZXkpO1xuICAgICAgICAvLyBJZiB0aGUgbmFtZXNwYWNlIGlzIGNoYW5naW5nIG5vdywgaW5jbHVkZSBhbiBpbnN0cnVjdGlvbiB0byBjaGFuZ2UgaXRcbiAgICAgICAgLy8gZHVyaW5nIGVsZW1lbnQgY3JlYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50TmFtZXNwYWNlICE9PSB3YXNJbk5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5hZGROYW1lc3BhY2VJbnN0cnVjdGlvbihjdXJyZW50TmFtZXNwYWNlLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kRWxlbWVudChlbGVtZW50LmkxOG4sIGVsZW1lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvIG5vdCBhcHBlbmQgdGV4dCBub2RlIGluc3RydWN0aW9ucyBhbmQgSUNVcyBpbnNpZGUgaTE4biBzZWN0aW9uLFxuICAgICAgICAvLyBzbyB3ZSBleGNsdWRlIHRoZW0gd2hpbGUgY2FsY3VsYXRpbmcgd2hldGhlciBjdXJyZW50IGVsZW1lbnQgaGFzIGNoaWxkcmVuXG4gICAgICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gKCFpc0kxOG5Sb290RWxlbWVudCAmJiB0aGlzLmkxOG4pID8gIWhhc1RleHRDaGlsZHJlbk9ubHkoZWxlbWVudC5jaGlsZHJlbikgOlxuICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBjcmVhdGVTZWxmQ2xvc2luZ0luc3RydWN0aW9uID0gIXN0eWxpbmdCdWlsZGVyLmhhc0JpbmRpbmdzV2l0aFBpcGVzICYmXG4gICAgICAgICAgICBlbGVtZW50Lm91dHB1dHMubGVuZ3RoID09PSAwICYmIGJvdW5kSTE4bkF0dHJzLmxlbmd0aCA9PT0gMCAmJiAhaGFzQ2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGNyZWF0ZVNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uID0gIWNyZWF0ZVNlbGZDbG9zaW5nSW5zdHJ1Y3Rpb24gJiYgaGFzVGV4dENoaWxkcmVuT25seShlbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKGNyZWF0ZVNlbGZDbG9zaW5nSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihlbGVtZW50LnNvdXJjZVNwYW4sIGlzTmdDb250YWluZXIkMSA/IElkZW50aWZpZXJzJDEuZWxlbWVudENvbnRhaW5lciA6IElkZW50aWZpZXJzJDEuZWxlbWVudCwgdHJpbVRyYWlsaW5nTnVsbHMocGFyYW1ldGVycykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBpc05nQ29udGFpbmVyJDEgPyBJZGVudGlmaWVycyQxLmVsZW1lbnRDb250YWluZXJTdGFydCA6IElkZW50aWZpZXJzJDEuZWxlbWVudFN0YXJ0LCB0cmltVHJhaWxpbmdOdWxscyhwYXJhbWV0ZXJzKSk7XG4gICAgICAgICAgICBpZiAoaXNOb25CaW5kYWJsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEuZGlzYWJsZUJpbmRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib3VuZEkxOG5BdHRycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuQXR0cmlidXRlc0luc3RydWN0aW9uKGVsZW1lbnRJbmRleCwgYm91bmRJMThuQXR0cnMsIChfYSA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgTGlzdGVuZXJzIChvdXRwdXRzKVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQub3V0cHV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZWxlbWVudC5vdXRwdXRzLm1hcCgob3V0cHV0QXN0KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBvdXRwdXRBc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnByZXBhcmVMaXN0ZW5lclBhcmFtZXRlcihlbGVtZW50Lm5hbWUsIG91dHB1dEFzdCwgZWxlbWVudEluZGV4KVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb25DaGFpbihJZGVudGlmaWVycyQxLmxpc3RlbmVyLCBsaXN0ZW5lcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogaXQncyBpbXBvcnRhbnQgdG8ga2VlcCBpMThuL2kxOG5TdGFydCBpbnN0cnVjdGlvbnMgYWZ0ZXIgaTE4bkF0dHJpYnV0ZXMgYW5kXG4gICAgICAgICAgICAvLyBsaXN0ZW5lcnMsIHRvIG1ha2Ugc3VyZSBpMThuQXR0cmlidXRlcyBpbnN0cnVjdGlvbiB0YXJnZXRzIGN1cnJlbnQgZWxlbWVudCBhdCBydW50aW1lLlxuICAgICAgICAgICAgaWYgKGlzSTE4blJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuU3RhcnQoZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4biwgY3JlYXRlU2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBjb2RlIGhlcmUgd2lsbCBjb2xsZWN0IGFsbCB1cGRhdGUtbGV2ZWwgc3R5bGluZyBpbnN0cnVjdGlvbnMgYW5kIGFkZCB0aGVtIHRvIHRoZVxuICAgICAgICAvLyB1cGRhdGUgYmxvY2sgb2YgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uIEFPVCBjb2RlLiBJbnN0cnVjdGlvbnMgbGlrZSBgc3R5bGVQcm9wYCxcbiAgICAgICAgLy8gYHN0eWxlTWFwYCwgYGNsYXNzTWFwYCwgYGNsYXNzUHJvcGBcbiAgICAgICAgLy8gYXJlIGFsbCBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGluIHRoZSBjb2RlIGJlbG93LlxuICAgICAgICBjb25zdCBzdHlsaW5nSW5zdHJ1Y3Rpb25zID0gc3R5bGluZ0J1aWxkZXIuYnVpbGRVcGRhdGVMZXZlbEluc3RydWN0aW9ucyh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gc3R5bGluZ0luc3RydWN0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHN0eWxpbmdJbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nU2xvdHMgKz0gdGhpcy5wcm9jZXNzU3R5bGluZ1VwZGF0ZUluc3RydWN0aW9uKGVsZW1lbnRJbmRleCwgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSByZWFzb24gd2h5IGB1bmRlZmluZWRgIGlzIHVzZWQgaXMgYmVjYXVzZSB0aGUgcmVuZGVyZXIgdW5kZXJzdGFuZHMgdGhpcyBhcyBhXG4gICAgICAgIC8vIHNwZWNpYWwgdmFsdWUgdG8gc3ltYm9saXplIHRoYXQgdGhlcmUgaXMgbm8gUkhTIHRvIHRoaXMgYmluZGluZ1xuICAgICAgICAvLyBUT0RPIChtYXRza28pOiByZXZpc2l0IHRoaXMgb25jZSBGVy05NTkgaXMgYXBwcm9hY2hlZFxuICAgICAgICBjb25zdCBlbXB0eVZhbHVlQmluZEluc3RydWN0aW9uID0gbGl0ZXJhbCh1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eUJpbmRpbmdzID0gW107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZUJpbmRpbmdzID0gW107XG4gICAgICAgIC8vIEdlbmVyYXRlIGVsZW1lbnQgaW5wdXQgYmluZGluZ3NcbiAgICAgICAgYWxsT3RoZXJJbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dC50eXBlO1xuICAgICAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gNCAvKiBBbmltYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlLnZpc2l0KHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24gYmluZGluZ3MgY2FuIGJlIHByZXNlbnRlZCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6XG4gICAgICAgICAgICAgICAgLy8gMS4gW0BiaW5kaW5nXT1cImZvb0V4cFwiXG4gICAgICAgICAgICAgICAgLy8gMi4gW0BiaW5kaW5nXT1cInt2YWx1ZTpmb29FeHAsIHBhcmFtczp7Li4ufX1cIlxuICAgICAgICAgICAgICAgIC8vIDMuIFtAYmluZGluZ11cbiAgICAgICAgICAgICAgICAvLyA0LiBAYmluZGluZ1xuICAgICAgICAgICAgICAgIC8vIEFsbCBmb3JtYXRzIHdpbGwgYmUgdmFsaWQgZm9yIHdoZW4gYSBzeW50aGV0aWMgYmluZGluZyBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb25pbmcgZm9yIHRoaXMgaXMgYmVjYXVzZSB0aGUgcmVuZGVyZXIgc2hvdWxkIGdldCBlYWNoXG4gICAgICAgICAgICAgICAgLy8gc3ludGhldGljIGJpbmRpbmcgdmFsdWUgaW4gdGhlIG9yZGVyIG9mIHRoZSBhcnJheSB0aGF0IHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lZCBpbi4uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1ZhbHVlID0gdmFsdWUgaW5zdGFuY2VvZiBMaXRlcmFsUHJpbWl0aXZlID8gISF2YWx1ZS52YWx1ZSA6IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJlcGFyZVN5bnRoZXRpY1Byb3BlcnR5TmFtZShpbnB1dC5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICgpID0+IGhhc1ZhbHVlID8gdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSA6IGVtcHR5VmFsdWVCaW5kSW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIG11c3Qgc2tpcCBhdHRyaWJ1dGVzIHdpdGggYXNzb2NpYXRlZCBpMThuIGNvbnRleHQsIHNpbmNlIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIGhhbmRsZWRcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0ZWx5IGFuZCBjb3JyZXNwb25kaW5nIGBpMThuRXhwYCBhbmQgYGkxOG5BcHBseWAgaW5zdHJ1Y3Rpb25zIHdpbGwgYmUgZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmkxOG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlLnZpc2l0KHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2F0dHJOYW1lc3BhY2UsIGF0dHJOYW1lXSA9IHNwbGl0TnNOYW1lKGlucHV0Lm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0F0dHJpYnV0ZUJpbmRpbmcgPSBpbnB1dFR5cGUgPT09IDEgLyogQXR0cmlidXRlICovO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzYW5pdGl6YXRpb25SZWYgPSByZXNvbHZlU2FuaXRpemF0aW9uRm4oaW5wdXQuc2VjdXJpdHlDb250ZXh0LCBpc0F0dHJpYnV0ZUJpbmRpbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2FuaXRpemF0aW9uUmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goc2FuaXRpemF0aW9uUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZUxpdGVyYWwgPSBsaXRlcmFsKGF0dHJOYW1lc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNhbml0aXphdGlvblJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKG5hbWVzcGFjZUxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2Fzbid0IGEgc2FuaXRpemF0aW9uIHJlZiwgd2UgbmVlZCB0byBhZGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbiBleHRyYSBwYXJhbSBzbyB0aGF0IHdlIGNhbiBwYXNzIGluIHRoZSBuYW1lc3BhY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gobGl0ZXJhbChudWxsKSwgbmFtZXNwYWNlTGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFR5cGUgPT09IDAgLyogUHJvcGVydHkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wPVwie3t2YWx1ZX19XCIgYW5kIGZyaWVuZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRlZFVwZGF0ZUluc3RydWN0aW9uKGdldFByb3BlcnR5SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24odmFsdWUpLCBlbGVtZW50SW5kZXgsIGF0dHJOYW1lLCBpbnB1dCwgdmFsdWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbcHJvcF09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCBhbGwgdGhlIHByb3BlcnRpZXMgc28gdGhhdCB3ZSBjYW4gY2hhaW4gaW50byBhIHNpbmdsZSBmdW5jdGlvbiBhdCB0aGUgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5QmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKCkgPT4gdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXRUeXBlID09PSAxIC8qIEF0dHJpYnV0ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbiAmJiBnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aCh2YWx1ZSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXR0ci5uYW1lPVwidGV4dHt7dmFsdWV9fVwiIGFuZCBmcmllbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZWRVcGRhdGVJbnN0cnVjdGlvbihnZXRBdHRyaWJ1dGVJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbih2YWx1ZSksIGVsZW1lbnRJbmRleCwgYXR0ck5hbWUsIGlucHV0LCB2YWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kVmFsdWUgPSB2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24gPyB2YWx1ZS5leHByZXNzaW9uc1swXSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFthdHRyLm5hbWVdPVwidmFsdWVcIiBvciBhdHRyLm5hbWU9XCJ7e3ZhbHVlfX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbGxlY3QgdGhlIGF0dHJpYnV0ZSBiaW5kaW5ncyBzbyB0aGF0IHRoZXkgY2FuIGJlIGNoYWluZWQgYXQgdGhlIGVuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYXR0ck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB0aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcoYm91bmRWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xhc3MgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgaW5wdXQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMkMS5jbGFzc1Byb3AsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKGVsZW1lbnRJbmRleCksIGxpdGVyYWwoYXR0ck5hbWUpLCB0aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvcGVydHlCaW5kaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uQ2hhaW5XaXRoQWR2YW5jZShlbGVtZW50SW5kZXgsIElkZW50aWZpZXJzJDEucHJvcGVydHksIHByb3BlcnR5QmluZGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRyaWJ1dGVCaW5kaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uQ2hhaW5XaXRoQWR2YW5jZShlbGVtZW50SW5kZXgsIElkZW50aWZpZXJzJDEuYXR0cmlidXRlLCBhdHRyaWJ1dGVCaW5kaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhdmVyc2UgZWxlbWVudCBjaGlsZCBub2Rlc1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICBpZiAoIWlzSTE4blJvb3RFbGVtZW50ICYmIHRoaXMuaTE4bikge1xuICAgICAgICAgICAgdGhpcy5pMThuLmFwcGVuZEVsZW1lbnQoZWxlbWVudC5pMThuLCBlbGVtZW50SW5kZXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3JlYXRlU2VsZkNsb3NpbmdJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgLy8gRmluaXNoIGVsZW1lbnQgY29uc3RydWN0aW9uIG1vZGUuXG4gICAgICAgICAgICBjb25zdCBzcGFuID0gKF9iID0gZWxlbWVudC5lbmRTb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBlbGVtZW50LnNvdXJjZVNwYW47XG4gICAgICAgICAgICBpZiAoaXNJMThuUm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmkxOG5FbmQoc3BhbiwgY3JlYXRlU2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTm9uQmluZGFibGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHNwYW4sIElkZW50aWZpZXJzJDEuZW5hYmxlQmluZGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHNwYW4sIGlzTmdDb250YWluZXIkMSA/IElkZW50aWZpZXJzJDEuZWxlbWVudENvbnRhaW5lckVuZCA6IElkZW50aWZpZXJzJDEuZWxlbWVudEVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IE5HX1RFTVBMQVRFX1RBR19OQU1FID0gJ25nLXRlbXBsYXRlJztcbiAgICAgICAgY29uc3QgdGVtcGxhdGVJbmRleCA9IHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpO1xuICAgICAgICBpZiAodGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kVGVtcGxhdGUodGVtcGxhdGUuaTE4biwgdGVtcGxhdGVJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTmFtZVdpdGhvdXROYW1lc3BhY2UgPSB0ZW1wbGF0ZS50YWdOYW1lID8gc3BsaXROc05hbWUodGVtcGxhdGUudGFnTmFtZSlbMV0gOiB0ZW1wbGF0ZS50YWdOYW1lO1xuICAgICAgICBjb25zdCBjb250ZXh0TmFtZSA9IGAke3RoaXMuY29udGV4dE5hbWV9JHt0ZW1wbGF0ZS50YWdOYW1lID8gJ18nICsgc2FuaXRpemVJZGVudGlmaWVyKHRlbXBsYXRlLnRhZ05hbWUpIDogJyd9XyR7dGVtcGxhdGVJbmRleH1gO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZU5hbWUgPSBgJHtjb250ZXh0TmFtZX1fVGVtcGxhdGVgO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgbGl0ZXJhbCh0ZW1wbGF0ZUluZGV4KSxcbiAgICAgICAgICAgIHZhcmlhYmxlKHRlbXBsYXRlTmFtZSksXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRoZSB0YWcncyBuYW1lc3BhY2UgaGVyZSwgYmVjYXVzZSB3ZSBpbmZlclxuICAgICAgICAgICAgLy8gaXQgYmFzZWQgb24gdGhlIHBhcmVudCBub2RlcyBpbnNpZGUgdGhlIHRlbXBsYXRlIGluc3RydWN0aW9uLlxuICAgICAgICAgICAgbGl0ZXJhbCh0YWdOYW1lV2l0aG91dE5hbWVzcGFjZSksXG4gICAgICAgIF07XG4gICAgICAgIC8vIHByZXBhcmUgYXR0cmlidXRlcyBwYXJhbWV0ZXIgKGluY2x1ZGluZyBhdHRyaWJ1dGVzIHVzZWQgZm9yIGRpcmVjdGl2ZSBtYXRjaGluZylcbiAgICAgICAgY29uc3QgYXR0cnNFeHBycyA9IHRoaXMuZ2V0QXR0cmlidXRlRXhwcmVzc2lvbnMoTkdfVEVNUExBVEVfVEFHX05BTUUsIHRlbXBsYXRlLmF0dHJpYnV0ZXMsIHRlbXBsYXRlLmlucHV0cywgdGVtcGxhdGUub3V0cHV0cywgdW5kZWZpbmVkIC8qIHN0eWxlcyAqLywgdGVtcGxhdGUudGVtcGxhdGVBdHRycyk7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLmFkZEF0dHJzVG9Db25zdHMoYXR0cnNFeHBycykpO1xuICAgICAgICAvLyBsb2NhbCByZWZzIChleC46IDxuZy10ZW1wbGF0ZSAjZm9vPilcbiAgICAgICAgaWYgKHRlbXBsYXRlLnJlZmVyZW5jZXMgJiYgdGVtcGxhdGUucmVmZXJlbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZnMgPSB0aGlzLnByZXBhcmVSZWZzQXJyYXkodGVtcGxhdGUucmVmZXJlbmNlcyk7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5hZGRUb0NvbnN0cyhyZWZzKSk7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnRlbXBsYXRlUmVmRXh0cmFjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZVZpc2l0b3IgPSBuZXcgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlcih0aGlzLmNvbnN0YW50UG9vbCwgdGhpcy5fYmluZGluZ1Njb3BlLCB0aGlzLmxldmVsICsgMSwgY29udGV4dE5hbWUsIHRoaXMuaTE4biwgdGVtcGxhdGVJbmRleCwgdGVtcGxhdGVOYW1lLCB0aGlzLl9uYW1lc3BhY2UsIHRoaXMuZmlsZUJhc2VkSTE4blN1ZmZpeCwgdGhpcy5pMThuVXNlRXh0ZXJuYWxJZHMsIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgICAgIC8vIE5lc3RlZCB0ZW1wbGF0ZXMgbXVzdCBub3QgYmUgdmlzaXRlZCB1bnRpbCBhZnRlciB0aGVpciBwYXJlbnQgdGVtcGxhdGVzIGhhdmUgY29tcGxldGVkXG4gICAgICAgIC8vIHByb2Nlc3NpbmcsIHNvIHRoZXkgYXJlIHF1ZXVlZCBoZXJlIHVudGlsIGFmdGVyIHRoZSBpbml0aWFsIHBhc3MuIE90aGVyd2lzZSwgd2Ugd291bGRuJ3RcbiAgICAgICAgLy8gYmUgYWJsZSB0byBzdXBwb3J0IGJpbmRpbmdzIGluIG5lc3RlZCB0ZW1wbGF0ZXMgdG8gbG9jYWwgcmVmcyB0aGF0IG9jY3VyIGFmdGVyIHRoZVxuICAgICAgICAvLyB0ZW1wbGF0ZSBkZWZpbml0aW9uLiBlLmcuIDxkaXYgKm5nSWY9XCJzaG93aW5nXCI+e3sgZm9vIH19PC9kaXY+ICA8ZGl2ICNmb28+PC9kaXY+XG4gICAgICAgIHRoaXMuX25lc3RlZFRlbXBsYXRlRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVGdW5jdGlvbkV4cHIgPSB0ZW1wbGF0ZVZpc2l0b3IuYnVpbGRUZW1wbGF0ZUZ1bmN0aW9uKHRlbXBsYXRlLmNoaWxkcmVuLCB0ZW1wbGF0ZS52YXJpYWJsZXMsIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoICsgdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0LCB0ZW1wbGF0ZS5pMThuKTtcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRQb29sLnN0YXRlbWVudHMucHVzaCh0ZW1wbGF0ZUZ1bmN0aW9uRXhwci50b0RlY2xTdG10KHRlbXBsYXRlTmFtZSkpO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlVmlzaXRvci5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLnB1c2goLi4udGVtcGxhdGVWaXNpdG9yLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGUuZy4gdGVtcGxhdGUoMSwgTXlDb21wX1RlbXBsYXRlXzEpXG4gICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbih0ZW1wbGF0ZS5zb3VyY2VTcGFuLCBJZGVudGlmaWVycyQxLnRlbXBsYXRlQ3JlYXRlLCAoKSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnNwbGljZSgyLCAwLCBsaXRlcmFsKHRlbXBsYXRlVmlzaXRvci5nZXRDb25zdENvdW50KCkpLCBsaXRlcmFsKHRlbXBsYXRlVmlzaXRvci5nZXRWYXJDb3VudCgpKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJpbVRyYWlsaW5nTnVsbHMocGFyYW1ldGVycyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBoYW5kbGUgcHJvcGVydHkgYmluZGluZ3MgZS5nLiDJtcm1cHJvcGVydHkoJ25nRm9yT2YnLCBjdHguaXRlbXMpLCBldCBhbDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVByb3BlcnR5QmluZGluZ3ModGVtcGxhdGVJbmRleCwgdGVtcGxhdGUudGVtcGxhdGVBdHRycyk7XG4gICAgICAgIC8vIE9ubHkgYWRkIG5vcm1hbCBpbnB1dC9vdXRwdXQgYmluZGluZyBpbnN0cnVjdGlvbnMgb24gZXhwbGljaXQgPG5nLXRlbXBsYXRlPiBlbGVtZW50cy5cbiAgICAgICAgaWYgKHRhZ05hbWVXaXRob3V0TmFtZXNwYWNlID09PSBOR19URU1QTEFURV9UQUdfTkFNRSkge1xuICAgICAgICAgICAgY29uc3QgW2kxOG5JbnB1dHMsIGlucHV0c10gPSBwYXJ0aXRpb25BcnJheSh0ZW1wbGF0ZS5pbnB1dHMsIGhhc0kxOG5NZXRhKTtcbiAgICAgICAgICAgIC8vIEFkZCBpMThuIGF0dHJpYnV0ZXMgdGhhdCBtYXkgYWN0IGFzIGlucHV0cyB0byBkaXJlY3RpdmVzLiBJZiBzdWNoIGF0dHJpYnV0ZXMgYXJlIHByZXNlbnQsXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBgaTE4bkF0dHJpYnV0ZXNgIGluc3RydWN0aW9uLiBOb3RlOiB3ZSBnZW5lcmF0ZSBpdCBvbmx5IGZvciBleHBsaWNpdCA8bmctdGVtcGxhdGU+XG4gICAgICAgICAgICAvLyBlbGVtZW50cywgaW4gY2FzZSBvZiBpbmxpbmUgdGVtcGxhdGVzLCBjb3JyZXNwb25kaW5nIGluc3RydWN0aW9ucyB3aWxsIGJlIGdlbmVyYXRlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIG5lc3RlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgICAgICAgIGlmIChpMThuSW5wdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmkxOG5BdHRyaWJ1dGVzSW5zdHJ1Y3Rpb24odGVtcGxhdGVJbmRleCwgaTE4bklucHV0cywgKF9hID0gdGVtcGxhdGUuc3RhcnRTb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0ZW1wbGF0ZS5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgaW5wdXQgYmluZGluZ3NcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGVQcm9wZXJ0eUJpbmRpbmdzKHRlbXBsYXRlSW5kZXgsIGlucHV0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBsaXN0ZW5lcnMgZm9yIGRpcmVjdGl2ZSBvdXRwdXRcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZS5vdXRwdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0ZW1wbGF0ZS5vdXRwdXRzLm1hcCgob3V0cHV0QXN0KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBvdXRwdXRBc3Quc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB0aGlzLnByZXBhcmVMaXN0ZW5lclBhcmFtZXRlcignbmdfdGVtcGxhdGUnLCBvdXRwdXRBc3QsIHRlbXBsYXRlSW5kZXgpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbkNoYWluKElkZW50aWZpZXJzJDEubGlzdGVuZXIsIGxpc3RlbmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRCb3VuZFRleHQodGV4dCkge1xuICAgICAgICBpZiAodGhpcy5pMThuKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRleHQudmFsdWUudmlzaXQodGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuLmFwcGVuZEJvdW5kVGV4dCh0ZXh0LmkxOG4pO1xuICAgICAgICAgICAgICAgIHRoaXMuaTE4bkFwcGVuZEJpbmRpbmdzKHZhbHVlLmV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlSW5kZXggPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHRleHQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMkMS50ZXh0LCBbbGl0ZXJhbChub2RlSW5kZXgpXSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dC52YWx1ZS52aXNpdCh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2Uobm9kZUluZGV4LCB0ZXh0LnNvdXJjZVNwYW4sIGdldFRleHRJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbih2YWx1ZSksICgpID0+IHRoaXMuZ2V0VXBkYXRlSW5zdHJ1Y3Rpb25Bcmd1bWVudHModmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdUZXh0IG5vZGVzIHNob3VsZCBiZSBpbnRlcnBvbGF0ZWQgYW5kIG5ldmVyIGJvdW5kIGRpcmVjdGx5LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIC8vIHdoZW4gYSB0ZXh0IGVsZW1lbnQgaXMgbG9jYXRlZCB3aXRoaW4gYSB0cmFuc2xhdGFibGVcbiAgICAgICAgLy8gYmxvY2ssIHdlIGV4Y2x1ZGUgdGhpcyB0ZXh0IGVsZW1lbnQgZnJvbSBpbnN0cnVjdGlvbnMgc2V0LFxuICAgICAgICAvLyBzaW5jZSBpdCB3aWxsIGJlIGNhcHR1cmVkIGluIGkxOG4gY29udGVudCBhbmQgcHJvY2Vzc2VkIGF0IHJ1bnRpbWVcbiAgICAgICAgaWYgKCF0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbih0ZXh0LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzJDEudGV4dCwgW2xpdGVyYWwodGhpcy5hbGxvY2F0ZURhdGFTbG90KCkpLCBsaXRlcmFsKHRleHQudmFsdWUpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1KSB7XG4gICAgICAgIGxldCBpbml0V2FzSW52b2tlZCA9IGZhbHNlO1xuICAgICAgICAvLyBpZiBhbiBJQ1Ugd2FzIGNyZWF0ZWQgb3V0c2lkZSBvZiBpMThuIGJsb2NrLCB3ZSBzdGlsbCB0cmVhdFxuICAgICAgICAvLyBpdCBhcyBhIHRyYW5zbGF0YWJsZSBlbnRpdHkgYW5kIGludm9rZSBpMThuU3RhcnQgYW5kIGkxOG5FbmRcbiAgICAgICAgLy8gdG8gZ2VuZXJhdGUgaTE4biBjb250ZXh0IGFuZCB0aGUgbmVjZXNzYXJ5IGluc3RydWN0aW9uc1xuICAgICAgICBpZiAoIXRoaXMuaTE4bikge1xuICAgICAgICAgICAgaW5pdFdhc0ludm9rZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5pMThuU3RhcnQobnVsbCwgaWN1LmkxOG4sIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkxOG4gPSB0aGlzLmkxOG47XG4gICAgICAgIGNvbnN0IHZhcnMgPSB0aGlzLmkxOG5CaW5kUHJvcHMoaWN1LnZhcnMpO1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlcnMgPSB0aGlzLmkxOG5CaW5kUHJvcHMoaWN1LnBsYWNlaG9sZGVycyk7XG4gICAgICAgIC8vIG91dHB1dCBJQ1UgZGlyZWN0bHkgYW5kIGtlZXAgSUNVIHJlZmVyZW5jZSBpbiBjb250ZXh0XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpY3UuaTE4bjtcbiAgICAgICAgLy8gd2UgYWx3YXlzIG5lZWQgcG9zdC1wcm9jZXNzaW5nIGZ1bmN0aW9uIGZvciBJQ1VzLCB0byBtYWtlIHN1cmUgdGhhdDpcbiAgICAgICAgLy8gLSBhbGwgcGxhY2Vob2xkZXJzIGluIGEgZm9ybSBvZiB7UExBQ0VIT0xERVJ9IGFyZSByZXBsYWNlZCB3aXRoIGFjdHVhbCB2YWx1ZXMgKG5vdGU6XG4gICAgICAgIC8vIGBnb29nLmdldE1zZ2AgZG9lcyBub3QgcHJvY2VzcyBJQ1VzIGFuZCB1c2VzIHRoZSBge1BMQUNFSE9MREVSfWAgZm9ybWF0IGZvciBwbGFjZWhvbGRlcnNcbiAgICAgICAgLy8gaW5zaWRlIElDVXMpXG4gICAgICAgIC8vIC0gYWxsIElDVSB2YXJzIChzdWNoIGFzIGBWQVJfU0VMRUNUYCBvciBgVkFSX1BMVVJBTGApIGFyZSByZXBsYWNlZCB3aXRoIGNvcnJlY3QgdmFsdWVzXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybUZuID0gKHJhdykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YXJzKSwgcGxhY2Vob2xkZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IGkxOG5Gb3JtYXRQbGFjZWhvbGRlck5hbWVzKHBhcmFtcywgLyogdXNlQ2FtZWxDYXNlICovIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0cnVjdGlvbihudWxsLCBJZGVudGlmaWVycyQxLmkxOG5Qb3N0cHJvY2VzcywgW3JhdywgbWFwTGl0ZXJhbChmb3JtYXR0ZWQsIHRydWUpXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIHdob2xlIGkxOG4gbWVzc2FnZSBpcyBhIHNpbmdsZSBJQ1UgLSB3ZSBkbyBub3QgbmVlZCB0b1xuICAgICAgICAvLyBjcmVhdGUgYSBzZXBhcmF0ZSB0b3AtbGV2ZWwgdHJhbnNsYXRpb24sIHdlIGNhbiB1c2UgdGhlIHJvb3QgcmVmIGluc3RlYWRcbiAgICAgICAgLy8gYW5kIG1ha2UgdGhpcyBJQ1UgYSB0b3AtbGV2ZWwgdHJhbnNsYXRpb25cbiAgICAgICAgLy8gbm90ZTogSUNVIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgd2l0aCBhY3R1YWwgdmFsdWVzIGluIGBpMThuUG9zdHByb2Nlc3NgIGZ1bmN0aW9uXG4gICAgICAgIC8vIHNlcGFyYXRlbHksIHNvIHdlIGRvIG5vdCBwYXNzIHBsYWNlaG9sZGVycyBpbnRvIGBpMThuVHJhbnNsYXRlYCBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGlzU2luZ2xlSTE4bkljdShpMThuLm1ldGEpKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5UcmFuc2xhdGUobWVzc2FnZSwgLyogcGxhY2Vob2xkZXJzICovIHt9LCBpMThuLnJlZiwgdHJhbnNmb3JtRm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gb3V0cHV0IElDVSBkaXJlY3RseSBhbmQga2VlcCBJQ1UgcmVmZXJlbmNlIGluIGNvbnRleHRcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuaTE4blRyYW5zbGF0ZShtZXNzYWdlLCAvKiBwbGFjZWhvbGRlcnMgKi8ge30sIC8qIHJlZiAqLyB1bmRlZmluZWQsIHRyYW5zZm9ybUZuKTtcbiAgICAgICAgICAgIGkxOG4uYXBwZW5kSWN1KGljdUZyb21JMThuTWVzc2FnZShtZXNzYWdlKS5uYW1lLCByZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0V2FzSW52b2tlZCkge1xuICAgICAgICAgICAgdGhpcy5pMThuRW5kKG51bGwsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhbGxvY2F0ZURhdGFTbG90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUluZGV4Kys7XG4gICAgfVxuICAgIGdldENvbnN0Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhSW5kZXg7XG4gICAgfVxuICAgIGdldFZhckNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVyZUZ1bmN0aW9uU2xvdHM7XG4gICAgfVxuICAgIGdldENvbnN0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0YW50cztcbiAgICB9XG4gICAgZ2V0TmdDb250ZW50U2VsZWN0b3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGggP1xuICAgICAgICAgICAgdGhpcy5jb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGFzTGl0ZXJhbCh0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzKSwgdHJ1ZSkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgYmluZGluZ0NvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLl9iaW5kaW5nQ29udGV4dCsrfWA7XG4gICAgfVxuICAgIHRlbXBsYXRlUHJvcGVydHlCaW5kaW5ncyh0ZW1wbGF0ZUluZGV4LCBhdHRycykge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eUJpbmRpbmdzID0gW107XG4gICAgICAgIGF0dHJzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQm91bmRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlLnZpc2l0KHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFyYW1zIHR5cGljYWxseSBjb250YWluIGF0dHJpYnV0ZSBuYW1lc3BhY2UgYW5kIHZhbHVlIHNhbml0aXplciwgd2hpY2ggaXMgYXBwbGljYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHJlZ3VsYXIgSFRNTCBlbGVtZW50cywgYnV0IG5vdCBhcHBsaWNhYmxlIGZvciA8bmctdGVtcGxhdGU+IChzaW5jZSBwcm9wcyBhY3QgYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlucHV0cyB0byBkaXJlY3RpdmVzKSwgc28ga2VlcCBwYXJhbXMgYXJyYXkgZW1wdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3A9XCJ7e3ZhbHVlfX1cIiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRlZFVwZGF0ZUluc3RydWN0aW9uKGdldFByb3BlcnR5SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24odmFsdWUpLCB0ZW1wbGF0ZUluZGV4LCBpbnB1dC5uYW1lLCBpbnB1dCwgdmFsdWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBbcHJvcF09XCJ2YWx1ZVwiIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5QmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaW5wdXQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAoKSA9PiB0aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eUJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbldpdGhBZHZhbmNlKHRlbXBsYXRlSW5kZXgsIElkZW50aWZpZXJzJDEucHJvcGVydHksIHByb3BlcnR5QmluZGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJpbmRpbmdzIG11c3Qgb25seSBiZSByZXNvbHZlZCBhZnRlciBhbGwgbG9jYWwgcmVmcyBoYXZlIGJlZW4gdmlzaXRlZCwgc28gYWxsXG4gICAgLy8gaW5zdHJ1Y3Rpb25zIGFyZSBxdWV1ZWQgaW4gY2FsbGJhY2tzIHRoYXQgZXhlY3V0ZSBvbmNlIHRoZSBpbml0aWFsIHBhc3MgaGFzIGNvbXBsZXRlZC5cbiAgICAvLyBPdGhlcndpc2UsIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gc3VwcG9ydCBsb2NhbCByZWZzIHRoYXQgYXJlIGRlZmluZWQgYWZ0ZXIgdGhlaXJcbiAgICAvLyBiaW5kaW5ncy4gZS5nLiB7eyBmb28gfX0gPGRpdiAjZm9vPjwvZGl2PlxuICAgIGluc3RydWN0aW9uRm4oZm5zLCBzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4sIHByZXBlbmQgPSBmYWxzZSkge1xuICAgICAgICBmbnNbcHJlcGVuZCA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gQXJyYXkuaXNBcnJheShwYXJhbXNPckZuKSA/IHBhcmFtc09yRm4gOiBwYXJhbXNPckZuKCk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24oc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXMpLnRvU3RtdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0eWxpbmdVcGRhdGVJbnN0cnVjdGlvbihlbGVtZW50SW5kZXgsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGxldCBhbGxvY2F0ZUJpbmRpbmdTbG90cyA9IDA7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgY2FsbHMgPSBbXTtcbiAgICAgICAgICAgIGluc3RydWN0aW9uLmNhbGxzLmZvckVhY2goY2FsbCA9PiB7XG4gICAgICAgICAgICAgICAgYWxsb2NhdGVCaW5kaW5nU2xvdHMgKz0gY2FsbC5hbGxvY2F0ZUJpbmRpbmdTbG90cztcbiAgICAgICAgICAgICAgICBjYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3BhbjogY2FsbC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGwucGFyYW1zKHZhbHVlID0+IChjYWxsLnN1cHBvcnRzSW50ZXJwb2xhdGlvbiAmJiB2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFVwZGF0ZUluc3RydWN0aW9uQXJndW1lbnRzKHZhbHVlKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbkNoYWluV2l0aEFkdmFuY2UoZWxlbWVudEluZGV4LCBpbnN0cnVjdGlvbi5yZWZlcmVuY2UsIGNhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsb2NhdGVCaW5kaW5nU2xvdHM7XG4gICAgfVxuICAgIGNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuLCBwcmVwZW5kKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25Gbih0aGlzLl9jcmVhdGlvbkNvZGVGbnMsIHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zT3JGbiB8fCBbXSwgcHJlcGVuZCk7XG4gICAgfVxuICAgIGNyZWF0aW9uSW5zdHJ1Y3Rpb25DaGFpbihyZWZlcmVuY2UsIGNhbGxzKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBjYWxscy5sZW5ndGggPyBjYWxsc1swXS5zb3VyY2VTcGFuIDogbnVsbDtcbiAgICAgICAgdGhpcy5fY3JlYXRpb25Db2RlRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluZWRJbnN0cnVjdGlvbihyZWZlcmVuY2UsIGNhbGxzLm1hcChjYWxsID0+IGNhbGwucGFyYW1zKCkpLCBzcGFuKS50b1N0bXQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2Uobm9kZUluZGV4LCBzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4pIHtcbiAgICAgICAgdGhpcy5hZGRBZHZhbmNlSW5zdHJ1Y3Rpb25JZk5lY2Vzc2FyeShub2RlSW5kZXgsIHNwYW4pO1xuICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uKHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zT3JGbik7XG4gICAgfVxuICAgIHVwZGF0ZUluc3RydWN0aW9uKHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zT3JGbikge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uRm4odGhpcy5fdXBkYXRlQ29kZUZucywgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuIHx8IFtdKTtcbiAgICB9XG4gICAgdXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbihyZWZlcmVuY2UsIGJpbmRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBiaW5kaW5ncy5sZW5ndGggPyBiaW5kaW5nc1swXS5zb3VyY2VTcGFuIDogbnVsbDtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29kZUZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxzID0gYmluZGluZ3MubWFwKHByb3BlcnR5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnR5LnZhbHVlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZm5QYXJhbXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkucGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuUGFyYW1zLnB1c2goLi4ucHJvcGVydHkucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0aGUgcHJvcGVydHkgbmFtZSB0byBhbHdheXMgYmUgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhcmFtZXRlci5cbiAgICAgICAgICAgICAgICAgICAgZm5QYXJhbXMudW5zaGlmdChsaXRlcmFsKHByb3BlcnR5Lm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuUGFyYW1zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5lZEluc3RydWN0aW9uKHJlZmVyZW5jZSwgY2FsbHMsIHNwYW4pLnRvU3RtdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlSW5zdHJ1Y3Rpb25DaGFpbldpdGhBZHZhbmNlKG5vZGVJbmRleCwgcmVmZXJlbmNlLCBiaW5kaW5ncykge1xuICAgICAgICB0aGlzLmFkZEFkdmFuY2VJbnN0cnVjdGlvbklmTmVjZXNzYXJ5KG5vZGVJbmRleCwgYmluZGluZ3MubGVuZ3RoID8gYmluZGluZ3NbMF0uc291cmNlU3BhbiA6IG51bGwpO1xuICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uQ2hhaW4ocmVmZXJlbmNlLCBiaW5kaW5ncyk7XG4gICAgfVxuICAgIGFkZEFkdmFuY2VJbnN0cnVjdGlvbklmTmVjZXNzYXJ5KG5vZGVJbmRleCwgc3Bhbikge1xuICAgICAgICBpZiAobm9kZUluZGV4ICE9PSB0aGlzLl9jdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gbm9kZUluZGV4IC0gdGhpcy5fY3VycmVudEluZGV4O1xuICAgICAgICAgICAgaWYgKGRlbHRhIDwgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWR2YW5jZSBpbnN0cnVjdGlvbiBjYW4gb25seSBnbyBmb3J3YXJkcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnN0cnVjdGlvbkZuKHRoaXMuX3VwZGF0ZUNvZGVGbnMsIHNwYW4sIElkZW50aWZpZXJzJDEuYWR2YW5jZSwgW2xpdGVyYWwoZGVsdGEpXSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSBub2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cyhudW1TbG90cykge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFNsb3RzID0gdGhpcy5fcHVyZUZ1bmN0aW9uU2xvdHM7XG4gICAgICAgIHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzICs9IG51bVNsb3RzO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxTbG90cztcbiAgICB9XG4gICAgYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ1Nsb3RzICs9IHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbiA/IHZhbHVlLmV4cHJlc3Npb25zLmxlbmd0aCA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gZXhwcmVzc2lvbiB0aGF0IHJlZmVycyB0byB0aGUgaW1wbGljaXQgcmVjZWl2ZXIuIFRoZSBpbXBsaWNpdFxuICAgICAqIHJlY2VpdmVyIGlzIGFsd2F5cyB0aGUgcm9vdCBsZXZlbCBjb250ZXh0LlxuICAgICAqL1xuICAgIGdldEltcGxpY2l0UmVjZWl2ZXJFeHByKCkge1xuICAgICAgICBpZiAodGhpcy5faW1wbGljaXRSZWNlaXZlckV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyRXhwcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlckV4cHIgPSB0aGlzLmxldmVsID09PSAwID9cbiAgICAgICAgICAgIHZhcmlhYmxlKENPTlRFWFRfTkFNRSkgOlxuICAgICAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlLmdldE9yQ3JlYXRlU2hhcmVkQ29udGV4dFZhcigwKTtcbiAgICB9XG4gICAgY29udmVydFByb3BlcnR5QmluZGluZyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRQcm9wZXJ0eUJpbmRpbmcgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKHRoaXMsIHRoaXMuZ2V0SW1wbGljaXRSZWNlaXZlckV4cHIoKSwgdmFsdWUsIHRoaXMuYmluZGluZ0NvbnRleHQoKSwgKCkgPT4gZXJyb3IoJ1VuZXhwZWN0ZWQgaW50ZXJwb2xhdGlvbicpKTtcbiAgICAgICAgY29uc3QgdmFsRXhwciA9IGNvbnZlcnRlZFByb3BlcnR5QmluZGluZy5jdXJyVmFsRXhwcjtcbiAgICAgICAgdGhpcy5fdGVtcFZhcmlhYmxlcy5wdXNoKC4uLmNvbnZlcnRlZFByb3BlcnR5QmluZGluZy5zdG10cyk7XG4gICAgICAgIHJldHVybiB2YWxFeHByO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBhcmd1bWVudCBleHByZXNzaW9ucyB0byBwYXNzIHRvIGFuIHVwZGF0ZSBpbnN0cnVjdGlvbiBleHByZXNzaW9uLiBBbHNvIHVwZGF0ZXNcbiAgICAgKiB0aGUgdGVtcCB2YXJpYWJsZXMgc3RhdGUgd2l0aCB0ZW1wIHZhcmlhYmxlcyB0aGF0IHdlcmUgaWRlbnRpZmllZCBhcyBuZWVkaW5nIHRvIGJlIGNyZWF0ZWRcbiAgICAgKiB3aGlsZSB2aXNpdGluZyB0aGUgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgb3JpZ2luYWwgZXhwcmVzc2lvbiB3ZSB3aWxsIGJlIHJlc29sdmluZyBhbiBhcmd1bWVudHMgbGlzdCBmcm9tLlxuICAgICAqL1xuICAgIGdldFVwZGF0ZUluc3RydWN0aW9uQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgYXJncywgc3RtdHMgfSA9IGNvbnZlcnRVcGRhdGVBcmd1bWVudHModGhpcywgdGhpcy5nZXRJbXBsaWNpdFJlY2VpdmVyRXhwcigpLCB2YWx1ZSwgdGhpcy5iaW5kaW5nQ29udGV4dCgpKTtcbiAgICAgICAgdGhpcy5fdGVtcFZhcmlhYmxlcy5wdXNoKC4uLnN0bXRzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGFsbCBhdHRyaWJ1dGUgZXhwcmVzc2lvbiB2YWx1ZXMgZm9yIHRoZSBgVEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBwcm9wZXJseSBjb25zdHJ1Y3QgYW4gYXR0cmlidXRlcyBhcnJheSB0aGF0XG4gICAgICogaXMgcGFzc2VkIGludG8gdGhlIGBlbGVtZW50U3RhcnRgIChvciBqdXN0IGBlbGVtZW50YCkgZnVuY3Rpb25zLiBCZWNhdXNlIHRoZXJlXG4gICAgICogYXJlIG1hbnkgZGlmZmVyZW50IHR5cGVzIG9mIGF0dHJpYnV0ZXMsIHRoZSBhcnJheSBuZWVkcyB0byBiZSBjb25zdHJ1Y3RlZCBpbiBhXG4gICAgICogc3BlY2lhbCB3YXkgc28gdGhhdCBgZWxlbWVudFN0YXJ0YCBjYW4gcHJvcGVybHkgZXZhbHVhdGUgdGhlbS5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogYXR0cnMgPSBbcHJvcCwgdmFsdWUsIHByb3AyLCB2YWx1ZTIsXG4gICAgICogICBQUk9KRUNUX0FTLCBzZWxlY3RvcixcbiAgICAgKiAgIENMQVNTRVMsIGNsYXNzMSwgY2xhc3MyLFxuICAgICAqICAgU1RZTEVTLCBzdHlsZTEsIHZhbHVlMSwgc3R5bGUyLCB2YWx1ZTIsXG4gICAgICogICBCSU5ESU5HUywgbmFtZTEsIG5hbWUyLCBuYW1lMyxcbiAgICAgKiAgIFRFTVBMQVRFLCBuYW1lNCwgbmFtZTUsIG5hbWU2LFxuICAgICAqICAgSTE4TiwgbmFtZTcsIG5hbWU4LCAuLi5dXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIGZ1bGx5IGlnbm9yZSBhbGwgc3ludGhldGljIChAZm9vKSBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICogYmVjYXVzZSB0aG9zZSB2YWx1ZXMgYXJlIGludGVuZGVkIHRvIGFsd2F5cyBiZSBnZW5lcmF0ZWQgYXMgcHJvcGVydHkgaW5zdHJ1Y3Rpb25zLlxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZUV4cHJlc3Npb25zKGVsZW1lbnROYW1lLCByZW5kZXJBdHRyaWJ1dGVzLCBpbnB1dHMsIG91dHB1dHMsIHN0eWxlcywgdGVtcGxhdGVBdHRycyA9IFtdLCBib3VuZEkxOG5BdHRycyA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGFscmVhZHlTZWVuID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBhdHRyRXhwcnMgPSBbXTtcbiAgICAgICAgbGV0IG5nUHJvamVjdEFzQXR0cjtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIHJlbmRlckF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IE5HX1BST0pFQ1RfQVNfQVRUUl9OQU1FKSB7XG4gICAgICAgICAgICAgICAgbmdQcm9qZWN0QXNBdHRyID0gYXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBzdGF0aWMgaTE4biBhdHRyaWJ1dGVzIGFyZW4ndCBpbiB0aGUgaTE4biBhcnJheSxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSB0cmVhdGVkIGluIHRoZSBzYW1lIHdheSBhcyByZWd1bGFyIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICBpZiAoYXR0ci5pMThuKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpMThuIGF0dHJpYnV0ZXMgYXJlIHByZXNlbnQgb24gZWxlbWVudHMgd2l0aCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBgPGRpdiAqbmdJZiB0aXRsZT1cIkhlbGxvXCIgaTE4bi10aXRsZT5gKSwgd2Ugd2FudCB0byBhdm9pZCBnZW5lcmF0aW5nXG4gICAgICAgICAgICAgICAgLy8gZHVwbGljYXRlIGkxOG4gdHJhbnNsYXRpb24gYmxvY2tzIGZvciBgybXJtXRlbXBsYXRlYCBhbmQgYMm1ybVlbGVtZW50YCBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMuIFNvIHdlIGRvIGEgY2FjaGUgbG9va3VwIHRvIHNlZSBpZiBzdWl0YWJsZSBpMThuIHRyYW5zbGF0aW9uIGJsb2NrXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBleGlzdHMuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpMThuVmFyUmVmc0NhY2hlIH0gPSB0aGlzLl9jb25zdGFudHM7XG4gICAgICAgICAgICAgICAgbGV0IGkxOG5WYXJSZWY7XG4gICAgICAgICAgICAgICAgaWYgKGkxOG5WYXJSZWZzQ2FjaGUuaGFzKGF0dHIuaTE4bikpIHtcbiAgICAgICAgICAgICAgICAgICAgaTE4blZhclJlZiA9IGkxOG5WYXJSZWZzQ2FjaGUuZ2V0KGF0dHIuaTE4bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpMThuVmFyUmVmID0gdGhpcy5pMThuVHJhbnNsYXRlKGF0dHIuaTE4bik7XG4gICAgICAgICAgICAgICAgICAgIGkxOG5WYXJSZWZzQ2FjaGUuc2V0KGF0dHIuaTE4biwgaTE4blZhclJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHJFeHBycy5wdXNoKGxpdGVyYWwoYXR0ci5uYW1lKSwgaTE4blZhclJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyRXhwcnMucHVzaCguLi5nZXRBdHRyaWJ1dGVOYW1lTGl0ZXJhbHMoYXR0ci5uYW1lKSwgdHJ1c3RlZENvbnN0QXR0cmlidXRlKGVsZW1lbnROYW1lLCBhdHRyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBuZ1Byb2plY3RBcyBuZXh0IHRvIHRoZSBvdGhlciBuYW1lLCB2YWx1ZSBwYWlycyBzbyB3ZSBjYW4gdmVyaWZ5IHRoYXQgd2UgbWF0Y2hcbiAgICAgICAgLy8gbmdQcm9qZWN0QXMgbWFya2VyIGluIHRoZSBhdHRyaWJ1dGUgbmFtZSBzbG90LlxuICAgICAgICBpZiAobmdQcm9qZWN0QXNBdHRyKSB7XG4gICAgICAgICAgICBhdHRyRXhwcnMucHVzaCguLi5nZXROZ1Byb2plY3RBc0xpdGVyYWwobmdQcm9qZWN0QXNBdHRyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkQXR0ckV4cHIoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5U2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyRXhwcnMucHVzaCguLi5nZXRBdHRyaWJ1dGVOYW1lTGl0ZXJhbHMoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgYXR0ckV4cHJzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5U2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyRXhwcnMucHVzaChsaXRlcmFsKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBvY2N1cnMgYmVmb3JlIEJJTkRJTkdTIGFuZCBURU1QTEFURSBiZWNhdXNlIG9uY2UgYGVsZW1lbnRTdGFydGBcbiAgICAgICAgLy8gY29tZXMgYWNyb3NzIHRoZSBCSU5ESU5HUyBvciBURU1QTEFURSBtYXJrZXJzIHRoZW4gaXQgd2lsbCBjb250aW51ZSByZWFkaW5nIGVhY2ggdmFsdWUgYXNcbiAgICAgICAgLy8gYXMgc2luZ2xlIHByb3BlcnR5IHZhbHVlIGNlbGwgYnkgY2VsbC5cbiAgICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICAgICAgc3R5bGVzLnBvcHVsYXRlSW5pdGlhbFN0eWxpbmdBdHRycyhhdHRyRXhwcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dHMubGVuZ3RoIHx8IG91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyc0xlbmd0aEJlZm9yZUlucHV0cyA9IGF0dHJFeHBycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdGhlIGFuaW1hdGlvbiBhbmQgYXR0cmlidXRlIGJpbmRpbmdzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMgYXJyYXkgc2luY2UgdGhleSBhcmVuJ3QgdXNlZCBmb3IgZGlyZWN0aXZlIG1hdGNoaW5nLlxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC50eXBlICE9PSA0IC8qIEFuaW1hdGlvbiAqLyAmJiBpbnB1dC50eXBlICE9PSAxIC8qIEF0dHJpYnV0ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBhZGRBdHRyRXhwcihpbnB1dC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQudHlwZSAhPT0gMSAvKiBBbmltYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQXR0ckV4cHIob3V0cHV0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBjaGVhcCB3YXkgb2YgYWRkaW5nIHRoZSBtYXJrZXIgb25seSBhZnRlciBhbGwgdGhlIGlucHV0L291dHB1dFxuICAgICAgICAgICAgLy8gdmFsdWVzIGhhdmUgYmVlbiBmaWx0ZXJlZCAoYnkgbm90IGluY2x1ZGluZyB0aGUgYW5pbWF0aW9uIG9uZXMpIGFuZCBhZGRlZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGV4cHJlc3Npb25zLiBUaGUgbWFya2VyIGlzIGltcG9ydGFudCBiZWNhdXNlIGl0IHRlbGxzIHRoZSBydW50aW1lXG4gICAgICAgICAgICAvLyBjb2RlIHRoYXQgdGhpcyBpcyB3aGVyZSBhdHRyaWJ1dGVzIHdpdGhvdXQgdmFsdWVzIHN0YXJ0Li4uXG4gICAgICAgICAgICBpZiAoYXR0ckV4cHJzLmxlbmd0aCAhPT0gYXR0cnNMZW5ndGhCZWZvcmVJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBhdHRyRXhwcnMuc3BsaWNlKGF0dHJzTGVuZ3RoQmVmb3JlSW5wdXRzLCAwLCBsaXRlcmFsKDMgLyogQmluZGluZ3MgKi8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGVtcGxhdGVBdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF0dHJFeHBycy5wdXNoKGxpdGVyYWwoNCAvKiBUZW1wbGF0ZSAqLykpO1xuICAgICAgICAgICAgdGVtcGxhdGVBdHRycy5mb3JFYWNoKGF0dHIgPT4gYWRkQXR0ckV4cHIoYXR0ci5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvdW5kSTE4bkF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXR0ckV4cHJzLnB1c2gobGl0ZXJhbCg2IC8qIEkxOG4gKi8pKTtcbiAgICAgICAgICAgIGJvdW5kSTE4bkF0dHJzLmZvckVhY2goYXR0ciA9PiBhZGRBdHRyRXhwcihhdHRyLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0ckV4cHJzO1xuICAgIH1cbiAgICBhZGRUb0NvbnN0cyhleHByZXNzaW9uKSB7XG4gICAgICAgIGlmIChpc051bGwoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBUWVBFRF9OVUxMX0VYUFI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uc3RzID0gdGhpcy5fY29uc3RhbnRzLmNvbnN0RXhwcmVzc2lvbnM7XG4gICAgICAgIC8vIFRyeSB0byByZXVzZSBhIGxpdGVyYWwgdGhhdCdzIGFscmVhZHkgaW4gdGhlIGFycmF5LCBpZiBwb3NzaWJsZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25zdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb25zdHNbaV0uaXNFcXVpdmFsZW50KGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWwoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpdGVyYWwoY29uc3RzLnB1c2goZXhwcmVzc2lvbikgLSAxKTtcbiAgICB9XG4gICAgYWRkQXR0cnNUb0NvbnN0cyhhdHRycykge1xuICAgICAgICByZXR1cm4gYXR0cnMubGVuZ3RoID4gMCA/IHRoaXMuYWRkVG9Db25zdHMobGl0ZXJhbEFycihhdHRycykpIDogVFlQRURfTlVMTF9FWFBSO1xuICAgIH1cbiAgICBwcmVwYXJlUmVmc0FycmF5KHJlZmVyZW5jZXMpIHtcbiAgICAgICAgaWYgKCFyZWZlcmVuY2VzIHx8IHJlZmVyZW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gVFlQRURfTlVMTF9FWFBSO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZnNQYXJhbSA9IGZsYXR0ZW4ocmVmZXJlbmNlcy5tYXAocmVmZXJlbmNlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSB1cGRhdGUgdGVtcG9yYXJ5LlxuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gdGhpcy5fYmluZGluZ1Njb3BlLmZyZXNoUmVmZXJlbmNlTmFtZSgpO1xuICAgICAgICAgICAgY29uc3QgcmV0cmlldmFsTGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICAgICAgY29uc3QgbGhzID0gdmFyaWFibGUodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdTY29wZS5zZXQocmV0cmlldmFsTGV2ZWwsIHJlZmVyZW5jZS5uYW1lLCBsaHMsIDAgLyogREVGQVVMVCAqLywgKHNjb3BlLCByZWxhdGl2ZUxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZS5nLiBuZXh0Q29udGV4dCgyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q29udGV4dFN0bXQgPSByZWxhdGl2ZUxldmVsID4gMCA/IFtnZW5lcmF0ZU5leHRDb250ZXh0RXhwcihyZWxhdGl2ZUxldmVsKS50b1N0bXQoKV0gOiBbXTtcbiAgICAgICAgICAgICAgICAvLyBlLmcuIGNvbnN0ICRmb28kID0gcmVmZXJlbmNlKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZkV4cHIgPSBsaHMuc2V0KGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5yZWZlcmVuY2UpLmNhbGxGbihbbGl0ZXJhbChzbG90KV0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENvbnRleHRTdG10LmNvbmNhdChyZWZFeHByLnRvQ29uc3REZWNsKCkpO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gW3JlZmVyZW5jZS5uYW1lLCByZWZlcmVuY2UudmFsdWVdO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBhc0xpdGVyYWwocmVmc1BhcmFtKTtcbiAgICB9XG4gICAgcHJlcGFyZUxpc3RlbmVyUGFyYW1ldGVyKHRhZ05hbWUsIG91dHB1dEFzdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IG91dHB1dEFzdC5uYW1lO1xuICAgICAgICAgICAgY29uc3QgYmluZGluZ0ZuTmFtZSA9IG91dHB1dEFzdC50eXBlID09PSAxIC8qIEFuaW1hdGlvbiAqLyA/XG4gICAgICAgICAgICAgICAgLy8gc3ludGhldGljIEBsaXN0ZW5lci5mb28gdmFsdWVzIGFyZSB0cmVhdGVkIHRoZSBleGFjdCBzYW1lIGFzIGFyZSBzdGFuZGFyZCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJGdW5jdGlvbk5hbWUoZXZlbnROYW1lLCBvdXRwdXRBc3QucGhhc2UpIDpcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZUlkZW50aWZpZXIoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJOYW1lID0gYCR7dGhpcy50ZW1wbGF0ZU5hbWV9XyR7dGFnTmFtZX1fJHtiaW5kaW5nRm5OYW1lfV8ke2luZGV4fV9saXN0ZW5lcmA7XG4gICAgICAgICAgICBjb25zdCBzY29wZSA9IHRoaXMuX2JpbmRpbmdTY29wZS5uZXN0ZWRTY29wZSh0aGlzLl9iaW5kaW5nU2NvcGUuYmluZGluZ0xldmVsLCBFVkVOVF9CSU5ESU5HX1NDT1BFX0dMT0JBTFMpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVFdmVudExpc3RlbmVyUGFyYW1ldGVycyhvdXRwdXRBc3QsIGhhbmRsZXJOYW1lLCBzY29wZSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgVmFsdWVDb252ZXJ0ZXIgZXh0ZW5kcyBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lciB7XG4gICAgY29uc3RydWN0b3IoY29uc3RhbnRQb29sLCBhbGxvY2F0ZVNsb3QsIGFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMsIGRlZmluZVBpcGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25zdGFudFBvb2wgPSBjb25zdGFudFBvb2w7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVTbG90ID0gYWxsb2NhdGVTbG90O1xuICAgICAgICB0aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMgPSBhbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzO1xuICAgICAgICB0aGlzLmRlZmluZVBpcGUgPSBkZWZpbmVQaXBlO1xuICAgICAgICB0aGlzLl9waXBlQmluZEV4cHJzID0gW107XG4gICAgfVxuICAgIC8vIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyXG4gICAgdmlzaXRQaXBlKHBpcGUsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gQWxsb2NhdGUgYSBzbG90IHRvIGNyZWF0ZSB0aGUgcGlwZVxuICAgICAgICBjb25zdCBzbG90ID0gdGhpcy5hbGxvY2F0ZVNsb3QoKTtcbiAgICAgICAgY29uc3Qgc2xvdFBzZXVkb0xvY2FsID0gYFBJUEU6JHtzbG90fWA7XG4gICAgICAgIC8vIEFsbG9jYXRlIG9uZSBzbG90IGZvciB0aGUgcmVzdWx0IHBsdXMgb25lIHNsb3QgcGVyIHBpcGUgYXJndW1lbnRcbiAgICAgICAgY29uc3QgcHVyZUZ1bmN0aW9uU2xvdCA9IHRoaXMuYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cygyICsgcGlwZS5hcmdzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG5ldyBQcm9wZXJ0eVJlYWQocGlwZS5zcGFuLCBwaXBlLnNvdXJjZVNwYW4sIHBpcGUubmFtZVNwYW4sIG5ldyBJbXBsaWNpdFJlY2VpdmVyKHBpcGUuc3BhbiwgcGlwZS5zb3VyY2VTcGFuKSwgc2xvdFBzZXVkb0xvY2FsKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGlmaWVyLCBpc1Zhckxlbmd0aCB9ID0gcGlwZUJpbmRpbmdDYWxsSW5mbyhwaXBlLmFyZ3MpO1xuICAgICAgICB0aGlzLmRlZmluZVBpcGUocGlwZS5uYW1lLCBzbG90UHNldWRvTG9jYWwsIHNsb3QsIGltcG9ydEV4cHIoaWRlbnRpZmllcikpO1xuICAgICAgICBjb25zdCBhcmdzID0gW3BpcGUuZXhwLCAuLi5waXBlLmFyZ3NdO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRBcmdzID0gaXNWYXJMZW5ndGggP1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbChbbmV3IExpdGVyYWxBcnJheShwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiwgYXJncyldKSA6XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsKGFyZ3MpO1xuICAgICAgICBjb25zdCBwaXBlQmluZEV4cHIgPSBuZXcgQ2FsbChwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiwgdGFyZ2V0LCBbXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbFByaW1pdGl2ZShwaXBlLnNwYW4sIHBpcGUuc291cmNlU3Bhbiwgc2xvdCksXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbFByaW1pdGl2ZShwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiwgcHVyZUZ1bmN0aW9uU2xvdCksXG4gICAgICAgICAgICAuLi5jb252ZXJ0ZWRBcmdzLFxuICAgICAgICBdLCBudWxsKTtcbiAgICAgICAgdGhpcy5fcGlwZUJpbmRFeHBycy5wdXNoKHBpcGVCaW5kRXhwcik7XG4gICAgICAgIHJldHVybiBwaXBlQmluZEV4cHI7XG4gICAgfVxuICAgIHVwZGF0ZVBpcGVTbG90T2Zmc2V0cyhiaW5kaW5nU2xvdHMpIHtcbiAgICAgICAgdGhpcy5fcGlwZUJpbmRFeHBycy5mb3JFYWNoKChwaXBlKSA9PiB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNsb3Qgb2Zmc2V0IGFyZyAoaW5kZXggMSkgdG8gYWNjb3VudCBmb3IgYmluZGluZyBzbG90c1xuICAgICAgICAgICAgY29uc3Qgc2xvdE9mZnNldCA9IHBpcGUuYXJnc1sxXTtcbiAgICAgICAgICAgIHNsb3RPZmZzZXQudmFsdWUgKz0gYmluZGluZ1Nsb3RzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsQXJyYXkoYXJyYXksIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFycmF5LnNwYW4sIGFycmF5LnNvdXJjZVNwYW4sIHRoaXMudmlzaXRBbGwoYXJyYXkuZXhwcmVzc2lvbnMpLCB2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGxpdGVyYWwgaGFzIGNhbGN1bGF0ZWQgKG5vbi1saXRlcmFsKSBlbGVtZW50cyB0cmFuc2Zvcm0gaXQgaW50b1xuICAgICAgICAgICAgLy8gY2FsbHMgdG8gbGl0ZXJhbCBmYWN0b3JpZXMgdGhhdCBjb21wb3NlIHRoZSBsaXRlcmFsIGFuZCB3aWxsIGNhY2hlIGludGVybWVkaWF0ZVxuICAgICAgICAgICAgLy8gdmFsdWVzLlxuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbCA9IGxpdGVyYWxBcnIodmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRMaXRlcmFsRmFjdG9yeSh0aGlzLmNvbnN0YW50UG9vbCwgbGl0ZXJhbCwgdGhpcy5hbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKG1hcC5zcGFuLCBtYXAuc291cmNlU3BhbiwgdGhpcy52aXNpdEFsbChtYXAudmFsdWVzKSwgdmFsdWVzID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBsaXRlcmFsIGhhcyBjYWxjdWxhdGVkIChub24tbGl0ZXJhbCkgZWxlbWVudHMgIHRyYW5zZm9ybSBpdCBpbnRvXG4gICAgICAgICAgICAvLyBjYWxscyB0byBsaXRlcmFsIGZhY3RvcmllcyB0aGF0IGNvbXBvc2UgdGhlIGxpdGVyYWwgYW5kIHdpbGwgY2FjaGUgaW50ZXJtZWRpYXRlXG4gICAgICAgICAgICAvLyB2YWx1ZXMuXG4gICAgICAgICAgICBjb25zdCBsaXRlcmFsID0gbGl0ZXJhbE1hcCh2YWx1ZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7IGtleTogbWFwLmtleXNbaW5kZXhdLmtleSwgdmFsdWUsIHF1b3RlZDogbWFwLmtleXNbaW5kZXhdLnF1b3RlZCB9KSkpO1xuICAgICAgICAgICAgcmV0dXJuIGdldExpdGVyYWxGYWN0b3J5KHRoaXMuY29uc3RhbnRQb29sLCBsaXRlcmFsLCB0aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyBQaXBlcyBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgcGFyYW1ldGVyLCB0aGUgdmFsdWUgdGhleSBvcGVyYXRlIG9uXG5jb25zdCBwaXBlQmluZGluZ0lkZW50aWZpZXJzID0gW0lkZW50aWZpZXJzJDEucGlwZUJpbmQxLCBJZGVudGlmaWVycyQxLnBpcGVCaW5kMiwgSWRlbnRpZmllcnMkMS5waXBlQmluZDMsIElkZW50aWZpZXJzJDEucGlwZUJpbmQ0XTtcbmZ1bmN0aW9uIHBpcGVCaW5kaW5nQ2FsbEluZm8oYXJncykge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBwaXBlQmluZGluZ0lkZW50aWZpZXJzW2FyZ3MubGVuZ3RoXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyIHx8IElkZW50aWZpZXJzJDEucGlwZUJpbmRWLFxuICAgICAgICBpc1Zhckxlbmd0aDogIWlkZW50aWZpZXIsXG4gICAgfTtcbn1cbmNvbnN0IHB1cmVGdW5jdGlvbklkZW50aWZpZXJzID0gW1xuICAgIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uMCwgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb24xLCBJZGVudGlmaWVycyQxLnB1cmVGdW5jdGlvbjIsIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uMywgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb240LFxuICAgIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uNSwgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb242LCBJZGVudGlmaWVycyQxLnB1cmVGdW5jdGlvbjcsIElkZW50aWZpZXJzJDEucHVyZUZ1bmN0aW9uOFxuXTtcbmZ1bmN0aW9uIHB1cmVGdW5jdGlvbkNhbGxJbmZvKGFyZ3MpIHtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gcHVyZUZ1bmN0aW9uSWRlbnRpZmllcnNbYXJncy5sZW5ndGhdO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIgfHwgSWRlbnRpZmllcnMkMS5wdXJlRnVuY3Rpb25WLFxuICAgICAgICBpc1Zhckxlbmd0aDogIWlkZW50aWZpZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluc3RydWN0aW9uKHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGltcG9ydEV4cHIocmVmZXJlbmNlLCBudWxsLCBzcGFuKS5jYWxsRm4ocGFyYW1zLCBzcGFuKTtcbn1cbi8vIGUuZy4geCgyKTtcbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dENvbnRleHRFeHByKHJlbGF0aXZlTGV2ZWxEaWZmKSB7XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5uZXh0Q29udGV4dClcbiAgICAgICAgLmNhbGxGbihyZWxhdGl2ZUxldmVsRGlmZiA+IDEgPyBbbGl0ZXJhbChyZWxhdGl2ZUxldmVsRGlmZildIDogW10pO1xufVxuZnVuY3Rpb24gZ2V0TGl0ZXJhbEZhY3RvcnkoY29uc3RhbnRQb29sLCBsaXRlcmFsJDEsIGFsbG9jYXRlU2xvdHMpIHtcbiAgICBjb25zdCB7IGxpdGVyYWxGYWN0b3J5LCBsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cyB9ID0gY29uc3RhbnRQb29sLmdldExpdGVyYWxGYWN0b3J5KGxpdGVyYWwkMSk7XG4gICAgLy8gQWxsb2NhdGUgMSBzbG90IGZvciB0aGUgcmVzdWx0IHBsdXMgMSBwZXIgYXJndW1lbnRcbiAgICBjb25zdCBzdGFydFNsb3QgPSBhbGxvY2F0ZVNsb3RzKDEgKyBsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGNvbnN0IHsgaWRlbnRpZmllciwgaXNWYXJMZW5ndGggfSA9IHB1cmVGdW5jdGlvbkNhbGxJbmZvKGxpdGVyYWxGYWN0b3J5QXJndW1lbnRzKTtcbiAgICAvLyBMaXRlcmFsIGZhY3RvcmllcyBhcmUgcHVyZSBmdW5jdGlvbnMgdGhhdCBvbmx5IG5lZWQgdG8gYmUgcmUtaW52b2tlZCB3aGVuIHRoZSBwYXJhbWV0ZXJzXG4gICAgLy8gY2hhbmdlLlxuICAgIGNvbnN0IGFyZ3MgPSBbbGl0ZXJhbChzdGFydFNsb3QpLCBsaXRlcmFsRmFjdG9yeV07XG4gICAgaWYgKGlzVmFyTGVuZ3RoKSB7XG4gICAgICAgIGFyZ3MucHVzaChsaXRlcmFsQXJyKGxpdGVyYWxGYWN0b3J5QXJndW1lbnRzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcmdzLnB1c2goLi4ubGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0RXhwcihpZGVudGlmaWVyKS5jYWxsRm4oYXJncyk7XG59XG4vKipcbiAqIEdldHMgYW4gYXJyYXkgb2YgbGl0ZXJhbHMgdGhhdCBjYW4gYmUgYWRkZWQgdG8gYW4gZXhwcmVzc2lvblxuICogdG8gcmVwcmVzZW50IHRoZSBuYW1lIGFuZCBuYW1lc3BhY2Ugb2YgYW4gYXR0cmlidXRlLiBFLmcuXG4gKiBgOnhsaW5rOmhyZWZgIHR1cm5zIGludG8gYFtBdHRyaWJ1dGVNYXJrZXIuTmFtZXNwYWNlVVJJLCAneGxpbmsnLCAnaHJlZiddYC5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUsIGluY2x1ZGluZyB0aGUgbmFtZXNwYWNlLlxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVOYW1lTGl0ZXJhbHMobmFtZSkge1xuICAgIGNvbnN0IFthdHRyaWJ1dGVOYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWVdID0gc3BsaXROc05hbWUobmFtZSk7XG4gICAgY29uc3QgbmFtZUxpdGVyYWwgPSBsaXRlcmFsKGF0dHJpYnV0ZU5hbWUpO1xuICAgIGlmIChhdHRyaWJ1dGVOYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxpdGVyYWwoMCAvKiBOYW1lc3BhY2VVUkkgKi8pLCBsaXRlcmFsKGF0dHJpYnV0ZU5hbWVzcGFjZSksIG5hbWVMaXRlcmFsXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbbmFtZUxpdGVyYWxdO1xufVxuLyoqIFRoZSBwcmVmaXggdXNlZCB0byBnZXQgYSBzaGFyZWQgY29udGV4dCBpbiBCaW5kaW5nU2NvcGUncyBtYXAuICovXG5jb25zdCBTSEFSRURfQ09OVEVYVF9LRVkgPSAnJCRzaGFyZWRfY3R4JCQnO1xuY2xhc3MgQmluZGluZ1Njb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5nTGV2ZWwgPSAwLCBwYXJlbnQgPSBudWxsLCBnbG9iYWxzKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ0xldmVsID0gYmluZGluZ0xldmVsO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5nbG9iYWxzID0gZ2xvYmFscztcbiAgICAgICAgLyoqIEtlZXBzIGEgbWFwIGZyb20gbG9jYWwgdmFyaWFibGVzIHRvIHRoZWlyIEJpbmRpbmdEYXRhLiAqL1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VOYW1lSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGUgPSBudWxsO1xuICAgICAgICB0aGlzLnVzZXNSZXN0b3JlZFZpZXdDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGlmIChnbG9iYWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBnbG9iYWxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoMCwgbmFtZSwgdmFyaWFibGUobmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVSb290U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluZGluZ1Njb3BlKCk7XG4gICAgfVxuICAgIGdldChuYW1lKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGN1cnJlbnQubWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBhIGxvY2FsIGNvcHkgYW5kIHJlc2V0IHRoZSBgZGVjbGFyZWAgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyaWV2YWxMZXZlbDogdmFsdWUucmV0cmlldmFsTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaHM6IHZhbHVlLmxocyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmVMb2NhbENhbGxiYWNrOiB2YWx1ZS5kZWNsYXJlTG9jYWxDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHZhbHVlLnByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSB2YWx1ZSBsb2NhbGx5LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQb3NzaWJseSBnZW5lcmF0ZSBhIHNoYXJlZCBjb250ZXh0IHZhclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heWJlR2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZVJlc3RvcmVWaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5kZWNsYXJlTG9jYWxDYWxsYmFjayAmJiAhdmFsdWUuZGVjbGFyZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxocztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnZXQgdG8gdGhpcyBwb2ludCwgd2UgYXJlIGxvb2tpbmcgZm9yIGEgcHJvcGVydHkgb24gdGhlIHRvcCBsZXZlbCBjb21wb25lbnRcbiAgICAgICAgLy8gLSBJZiBsZXZlbCA9PT0gMCwgd2UgYXJlIG9uIHRoZSB0b3AgYW5kIGRvbid0IG5lZWQgdG8gcmUtZGVjbGFyZSBgY3R4YC5cbiAgICAgICAgLy8gLSBJZiBsZXZlbCA+IDAsIHdlIGFyZSBpbiBhbiBlbWJlZGRlZCB2aWV3LiBXZSBuZWVkIHRvIHJldHJpZXZlIHRoZSBuYW1lIG9mIHRoZVxuICAgICAgICAvLyBsb2NhbCB2YXIgd2UgdXNlZCB0byBzdG9yZSB0aGUgY29tcG9uZW50IGNvbnRleHQsIGUuZy4gY29uc3QgJGNvbXAkID0geCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5nTGV2ZWwgPT09IDAgPyBudWxsIDogdGhpcy5nZXRDb21wb25lbnRQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbG9jYWwgdmFyaWFibGUgZm9yIGxhdGVyIHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXRyaWV2YWxMZXZlbCBUaGUgbGV2ZWwgZnJvbSB3aGljaCB0aGlzIHZhbHVlIGNhbiBiZSByZXRyaWV2ZWRcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAgICAgKiBAcGFyYW0gbGhzIEFTVCByZXByZXNlbnRpbmcgdGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBgbGV0IGxocyA9IHJocztgLlxuICAgICAqIEBwYXJhbSBwcmlvcml0eSBUaGUgc29ydGluZyBwcmlvcml0eSBvZiB0aGlzIHZhclxuICAgICAqIEBwYXJhbSBkZWNsYXJlTG9jYWxDYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gZGVjbGFyaW5nIHRoaXMgbG9jYWwgdmFyXG4gICAgICogQHBhcmFtIGxvY2FsUmVmIFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYSBsb2NhbCByZWZcbiAgICAgKi9cbiAgICBzZXQocmV0cmlldmFsTGV2ZWwsIG5hbWUsIGxocywgcHJpb3JpdHkgPSAwIC8qIERFRkFVTFQgKi8sIGRlY2xhcmVMb2NhbENhbGxiYWNrLCBsb2NhbFJlZikge1xuICAgICAgICBpZiAodGhpcy5tYXAuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxSZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBhIGxvY2FsIHJlZiBhbmQgZG8gbm90IHVwZGF0ZSBleGlzdGluZyB2YWx1ZSxcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGUgZmlyc3QgZGVmaW5lZCByZWYgaXMgYWx3YXlzIHJldHVybmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoYFRoZSBuYW1lICR7bmFtZX0gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHNjb3BlIHRvIGJlICR7dGhpcy5tYXAuZ2V0KG5hbWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwLnNldChuYW1lLCB7XG4gICAgICAgICAgICByZXRyaWV2YWxMZXZlbDogcmV0cmlldmFsTGV2ZWwsXG4gICAgICAgICAgICBsaHM6IGxocyxcbiAgICAgICAgICAgIGRlY2xhcmU6IGZhbHNlLFxuICAgICAgICAgICAgZGVjbGFyZUxvY2FsQ2FsbGJhY2s6IGRlY2xhcmVMb2NhbENhbGxiYWNrLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgTG9jYWxSZXNvbHZlci5cbiAgICBnZXRMb2NhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcbiAgICB9XG4gICAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBMb2NhbFJlc29sdmVyLlxuICAgIG5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdMZXZlbCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIGltcGxpY2l0IHJlY2VpdmVyIGlzIGFjY2Vzc2VkIGluIGFuIGVtYmVkZGVkIHZpZXcsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHdlIGRlY2xhcmUgYSBzaGFyZWQgY29udGV4dCB2YXJpYWJsZSBmb3IgdGhlIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIGluIHRoZSB1cGRhdGUgdmFyaWFibGVzLlxuICAgICAgICAgICAgdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIDApLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5lc3RlZFNjb3BlKGxldmVsLCBnbG9iYWxzKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gbmV3IEJpbmRpbmdTY29wZShsZXZlbCwgdGhpcywgZ2xvYmFscyk7XG4gICAgICAgIGlmIChsZXZlbCA+IDApXG4gICAgICAgICAgICBuZXdTY29wZS5nZW5lcmF0ZVNoYXJlZENvbnRleHRWYXIoMCk7XG4gICAgICAgIHJldHVybiBuZXdTY29wZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBjcmVhdGVzIGEgc2hhcmVkIGNvbnRleHQgdmFyaWFibGUgYW5kIHJldHVybnMgaXRzIGV4cHJlc3Npb24uIE5vdGUgdGhhdFxuICAgICAqIHRoaXMgZG9lcyBub3QgbWVhbiB0aGF0IHRoZSBzaGFyZWQgdmFyaWFibGUgd2lsbCBiZSBkZWNsYXJlZC4gVmFyaWFibGVzIGluIHRoZVxuICAgICAqIGJpbmRpbmcgc2NvcGUgd2lsbCBiZSBvbmx5IGRlY2xhcmVkIGlmIHRoZXkgYXJlIHVzZWQuXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVTaGFyZWRDb250ZXh0VmFyKHJldHJpZXZhbExldmVsKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdLZXkgPSBTSEFSRURfQ09OVEVYVF9LRVkgKyByZXRyaWV2YWxMZXZlbDtcbiAgICAgICAgaWYgKCF0aGlzLm1hcC5oYXMoYmluZGluZ0tleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyKHJldHJpZXZhbExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFyZWQgY29udGV4dCB2YXJpYWJsZXMgYXJlIGFsd2F5cyBnZW5lcmF0ZWQgYXMgXCJSZWFkVmFyRXhwclwiLlxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGJpbmRpbmdLZXkpLmxocztcbiAgICB9XG4gICAgZ2V0U2hhcmVkQ29udGV4dE5hbWUocmV0cmlldmFsTGV2ZWwpIHtcbiAgICAgICAgY29uc3Qgc2hhcmVkQ3R4T2JqID0gdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIHJldHJpZXZhbExldmVsKTtcbiAgICAgICAgLy8gU2hhcmVkIGNvbnRleHQgdmFyaWFibGVzIGFyZSBhbHdheXMgZ2VuZXJhdGVkIGFzIFwiUmVhZFZhckV4cHJcIi5cbiAgICAgICAgcmV0dXJuIHNoYXJlZEN0eE9iaiAmJiBzaGFyZWRDdHhPYmouZGVjbGFyZSA/IHNoYXJlZEN0eE9iai5saHMgOiBudWxsO1xuICAgIH1cbiAgICBtYXliZUdlbmVyYXRlU2hhcmVkQ29udGV4dFZhcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUucHJpb3JpdHkgPT09IDEgLyogQ09OVEVYVCAqLyAmJlxuICAgICAgICAgICAgdmFsdWUucmV0cmlldmFsTGV2ZWwgPCB0aGlzLmJpbmRpbmdMZXZlbCkge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkQ3R4T2JqID0gdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIHZhbHVlLnJldHJpZXZhbExldmVsKTtcbiAgICAgICAgICAgIGlmIChzaGFyZWRDdHhPYmopIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRDdHhPYmouZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlU2hhcmVkQ29udGV4dFZhcih2YWx1ZS5yZXRyaWV2YWxMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyKHJldHJpZXZhbExldmVsKSB7XG4gICAgICAgIGNvbnN0IGxocyA9IHZhcmlhYmxlKENPTlRFWFRfTkFNRSArIHRoaXMuZnJlc2hSZWZlcmVuY2VOYW1lKCkpO1xuICAgICAgICB0aGlzLm1hcC5zZXQoU0hBUkVEX0NPTlRFWFRfS0VZICsgcmV0cmlldmFsTGV2ZWwsIHtcbiAgICAgICAgICAgIHJldHJpZXZhbExldmVsOiByZXRyaWV2YWxMZXZlbCxcbiAgICAgICAgICAgIGxoczogbGhzLFxuICAgICAgICAgICAgZGVjbGFyZUxvY2FsQ2FsbGJhY2s6IChzY29wZSwgcmVsYXRpdmVMZXZlbCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGN0eF9yMCA9IG5leHRDb250ZXh0KDIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbGhzLnNldChnZW5lcmF0ZU5leHRDb250ZXh0RXhwcihyZWxhdGl2ZUxldmVsKSkudG9Db25zdERlY2woKV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjbGFyZTogZmFsc2UsXG4gICAgICAgICAgICBwcmlvcml0eTogMiAvKiBTSEFSRURfQ09OVEVYVCAqLyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbXBvbmVudFByb3BlcnR5KG5hbWUpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VmFsdWUgPSB0aGlzLm1hcC5nZXQoU0hBUkVEX0NPTlRFWFRfS0VZICsgMCk7XG4gICAgICAgIGNvbXBvbmVudFZhbHVlLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICB0aGlzLm1heWJlUmVzdG9yZVZpZXcoKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFZhbHVlLmxocy5wcm9wKG5hbWUpO1xuICAgIH1cbiAgICBtYXliZVJlc3RvcmVWaWV3KCkge1xuICAgICAgICAvLyBWaWV3IHJlc3RvcmF0aW9uIGlzIHJlcXVpcmVkIGZvciBsaXN0ZW5lciBpbnN0cnVjdGlvbnMgaW5zaWRlIGVtYmVkZGVkIHZpZXdzLCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZXkgb25seSBydW4gaW4gY3JlYXRpb24gbW9kZSBhbmQgdGhleSBjYW4gaGF2ZSByZWZlcmVuY2VzIHRvIHRoZSBjb250ZXh0IG9iamVjdC5cbiAgICAgICAgLy8gSWYgdGhlIGNvbnRleHQgb2JqZWN0IGNoYW5nZXMgaW4gdXBkYXRlIG1vZGUsIHRoZSByZWZlcmVuY2Ugd2lsbCBiZSBpbmNvcnJlY3QsIGJlY2F1c2VcbiAgICAgICAgLy8gaXQgd2FzIGVzdGFibGlzaGVkIGR1cmluZyBjcmVhdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuaXNMaXN0ZW5lclNjb3BlKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQucmVzdG9yZVZpZXdWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIHBhcmVudCBzYXZlcyB2YXJpYWJsZSB0byBnZW5lcmF0ZSBhIHNoYXJlZCBgY29uc3QgJHMkID0gZ2V0Q3VycmVudFZpZXcoKTtgIGluc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVzdG9yZVZpZXdWYXJpYWJsZSA9IHZhcmlhYmxlKHRoaXMucGFyZW50LmZyZXNoUmVmZXJlbmNlTmFtZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzdG9yZVZpZXdWYXJpYWJsZSA9IHRoaXMucGFyZW50LnJlc3RvcmVWaWV3VmFyaWFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdG9yZVZpZXdTdGF0ZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMucmVzdG9yZVZpZXdWYXJpYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdG9yZUNhbGwgPSBpbnN0cnVjdGlvbihudWxsLCBJZGVudGlmaWVycyQxLnJlc3RvcmVWaWV3LCBbdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlXSk7XG4gICAgICAgICAgICAvLyBFaXRoZXIgYGNvbnN0IHJlc3RvcmVkQ3R4ID0gcmVzdG9yZVZpZXcoJHN0YXRlJCk7YCBvciBgcmVzdG9yZVZpZXcoJHN0YXRlJCk7YFxuICAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYmVpbmcgdXNlZC5cbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaCh0aGlzLnVzZXNSZXN0b3JlZFZpZXdDb250ZXh0ID9cbiAgICAgICAgICAgICAgICB2YXJpYWJsZShSRVNUT1JFRF9WSUVXX0NPTlRFWFRfTkFNRSkuc2V0KHJlc3RvcmVDYWxsKS50b0NvbnN0RGVjbCgpIDpcbiAgICAgICAgICAgICAgICByZXN0b3JlQ2FsbC50b1N0bXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgfVxuICAgIHZpZXdTbmFwc2hvdFN0YXRlbWVudHMoKSB7XG4gICAgICAgIC8vIGNvbnN0ICRzdGF0ZSQgPSBnZXRDdXJyZW50VmlldygpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlID9cbiAgICAgICAgICAgIFt0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGUuc2V0KGluc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzJDEuZ2V0Q3VycmVudFZpZXcsIFtdKSkudG9Db25zdERlY2woKV0gOlxuICAgICAgICAgICAgW107XG4gICAgfVxuICAgIGlzTGlzdGVuZXJTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmJpbmRpbmdMZXZlbCA9PT0gdGhpcy5iaW5kaW5nTGV2ZWw7XG4gICAgfVxuICAgIHZhcmlhYmxlRGVjbGFyYXRpb25zKCkge1xuICAgICAgICBsZXQgY3VycmVudENvbnRleHRMZXZlbCA9IDA7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubWFwLnZhbHVlcygpKVxuICAgICAgICAgICAgLmZpbHRlcih2YWx1ZSA9PiB2YWx1ZS5kZWNsYXJlKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIucmV0cmlldmFsTGV2ZWwgLSBhLnJldHJpZXZhbExldmVsIHx8IGIucHJpb3JpdHkgLSBhLnByaW9yaXR5KVxuICAgICAgICAgICAgLnJlZHVjZSgoc3RtdHMsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZXZlbERpZmYgPSB0aGlzLmJpbmRpbmdMZXZlbCAtIHZhbHVlLnJldHJpZXZhbExldmVsO1xuICAgICAgICAgICAgY29uc3QgY3VyclN0bXRzID0gdmFsdWUuZGVjbGFyZUxvY2FsQ2FsbGJhY2sodGhpcywgbGV2ZWxEaWZmIC0gY3VycmVudENvbnRleHRMZXZlbCk7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dExldmVsID0gbGV2ZWxEaWZmO1xuICAgICAgICAgICAgcmV0dXJuIHN0bXRzLmNvbmNhdChjdXJyU3RtdHMpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGZyZXNoUmVmZXJlbmNlTmFtZSgpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICAvLyBGaW5kIHRoZSB0b3Agc2NvcGUgYXMgaXQgbWFpbnRhaW5zIHRoZSBnbG9iYWwgcmVmZXJlbmNlIGNvdW50XG4gICAgICAgIHdoaWxlIChjdXJyZW50LnBhcmVudClcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgY29uc3QgcmVmID0gYCR7UkVGRVJFTkNFX1BSRUZJWH0ke2N1cnJlbnQucmVmZXJlbmNlTmFtZUluZGV4Kyt9YDtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgaGFzUmVzdG9yZVZpZXdWYXJpYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlO1xuICAgIH1cbiAgICBub3RpZnlSZXN0b3JlZFZpZXdDb250ZXh0VXNlKCkge1xuICAgICAgICB0aGlzLnVzZXNSZXN0b3JlZFZpZXdDb250ZXh0ID0gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBgQ3NzU2VsZWN0b3JgIGdpdmVuIGEgdGFnIG5hbWUgYW5kIGEgbWFwIG9mIGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3NzU2VsZWN0b3IoZWxlbWVudE5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBjc3NTZWxlY3RvciA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgIGNvbnN0IGVsZW1lbnROYW1lTm9OcyA9IHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKVsxXTtcbiAgICBjc3NTZWxlY3Rvci5zZXRFbGVtZW50KGVsZW1lbnROYW1lTm9Ocyk7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBuYW1lTm9OcyA9IHNwbGl0TnNOYW1lKG5hbWUpWzFdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNzc1NlbGVjdG9yLmFkZEF0dHJpYnV0ZShuYW1lTm9OcywgdmFsdWUpO1xuICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gdmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICBjbGFzc2VzLmZvckVhY2goY2xhc3NOYW1lID0+IGNzc1NlbGVjdG9yLmFkZENsYXNzTmFtZShjbGFzc05hbWUpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjc3NTZWxlY3Rvcjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBleHByZXNzaW9ucyBvdXQgb2YgYW4gYG5nUHJvamVjdEFzYCBhdHRyaWJ1dGVzXG4gKiB3aGljaCBjYW4gYmUgYWRkZWQgdG8gdGhlIGluc3RydWN0aW9uIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGdldE5nUHJvamVjdEFzTGl0ZXJhbChhdHRyaWJ1dGUpIHtcbiAgICAvLyBQYXJzZSB0aGUgYXR0cmlidXRlIHZhbHVlIGludG8gYSBDc3NTZWxlY3Rvckxpc3QuIE5vdGUgdGhhdCB3ZSBvbmx5IHRha2UgdGhlXG4gICAgLy8gZmlyc3Qgc2VsZWN0b3IsIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBtdWx0aXBsZSBzZWxlY3RvcnMgaW4gbmdQcm9qZWN0QXMuXG4gICAgY29uc3QgcGFyc2VkUjNTZWxlY3RvciA9IHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3IoYXR0cmlidXRlLnZhbHVlKVswXTtcbiAgICByZXR1cm4gW2xpdGVyYWwoNSAvKiBQcm9qZWN0QXMgKi8pLCBhc0xpdGVyYWwocGFyc2VkUjNTZWxlY3RvcildO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgYW4gaW50ZXJwb2xhdGVkIHByb3BlcnR5XG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUludGVycG9sYXRpb25FeHByZXNzaW9uKGludGVycG9sYXRpb24pIHtcbiAgICBzd2l0Y2ggKGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGU7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEucHJvcGVydHlJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEucHJvcGVydHlJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnByb3BlcnR5SW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEucHJvcGVydHlJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5wcm9wZXJ0eUludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgYXR0cmlidXRlXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihpbnRlcnBvbGF0aW9uKSB7XG4gICAgc3dpdGNoIChnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSkge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLmF0dHJpYnV0ZUludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEuYXR0cmlidXRlSW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS5hdHRyaWJ1dGVJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgaW50ZXJwb2xhdGVkIHRleHQuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRUZXh0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMkMS50ZXh0SW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzJDEudGV4dEludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycyQxLnRleHRJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuLyoqXG4gKiBQYXJzZSBhIHRlbXBsYXRlIGludG8gcmVuZGVyMyBgTm9kZWBzIGFuZCBhZGRpdGlvbmFsIG1ldGFkYXRhLCB3aXRoIG5vIG90aGVyIGRlcGVuZGVuY2llcy5cbiAqXG4gKiBAcGFyYW0gdGVtcGxhdGUgdGV4dCBvZiB0aGUgdGVtcGxhdGUgdG8gcGFyc2VcbiAqIEBwYXJhbSB0ZW1wbGF0ZVVybCBVUkwgdG8gdXNlIGZvciBzb3VyY2UgbWFwcGluZyBvZiB0aGUgcGFyc2VkIHRlbXBsYXRlXG4gKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIHRvIG1vZGlmeSBob3cgdGhlIHRlbXBsYXRlIGlzIHBhcnNlZFxuICovXG5mdW5jdGlvbiBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBpbnRlcnBvbGF0aW9uQ29uZmlnLCBwcmVzZXJ2ZVdoaXRlc3BhY2VzLCBlbmFibGVJMThuTGVnYWN5TWVzc2FnZUlkRm9ybWF0IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJpbmRpbmdQYXJzZXIgPSBtYWtlQmluZGluZ1BhcnNlcihpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICBjb25zdCBodG1sUGFyc2VyID0gbmV3IEh0bWxQYXJzZXIoKTtcbiAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGh0bWxQYXJzZXIucGFyc2UodGVtcGxhdGUsIHRlbXBsYXRlVXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBsZWFkaW5nVHJpdmlhQ2hhcnM6IExFQURJTkdfVFJJVklBX0NIQVJTIH0sIG9wdGlvbnMpLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUgfSkpO1xuICAgIGlmICghb3B0aW9ucy5hbHdheXNBdHRlbXB0SHRtbFRvUjNBc3RDb252ZXJzaW9uICYmIHBhcnNlUmVzdWx0LmVycm9ycyAmJlxuICAgICAgICBwYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUZW1wbGF0ZSA9IHtcbiAgICAgICAgICAgIGludGVycG9sYXRpb25Db25maWcsXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzLFxuICAgICAgICAgICAgZXJyb3JzOiBwYXJzZVJlc3VsdC5lcnJvcnMsXG4gICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgc3R5bGVzOiBbXSxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29sbGVjdENvbW1lbnROb2Rlcykge1xuICAgICAgICAgICAgcGFyc2VkVGVtcGxhdGUuY29tbWVudE5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZFRlbXBsYXRlO1xuICAgIH1cbiAgICBsZXQgcm9vdE5vZGVzID0gcGFyc2VSZXN1bHQucm9vdE5vZGVzO1xuICAgIC8vIHByb2Nlc3MgaTE4biBtZXRhIGluZm9ybWF0aW9uIChzY2FuIGF0dHJpYnV0ZXMsIGdlbmVyYXRlIGlkcylcbiAgICAvLyBiZWZvcmUgd2UgcnVuIHdoaXRlc3BhY2UgcmVtb3ZhbCBwcm9jZXNzLCBiZWNhdXNlIGV4aXN0aW5nIGkxOG5cbiAgICAvLyBleHRyYWN0aW9uIHByb2Nlc3MgKG5nIGV4dHJhY3QtaTE4bikgcmVsaWVzIG9uIGEgcmF3IGNvbnRlbnQgdG8gZ2VuZXJhdGVcbiAgICAvLyBtZXNzYWdlIGlkc1xuICAgIGNvbnN0IGkxOG5NZXRhVmlzaXRvciA9IG5ldyBJMThuTWV0YVZpc2l0b3IoaW50ZXJwb2xhdGlvbkNvbmZpZywgLyoga2VlcEkxOG5BdHRycyAqLyAhcHJlc2VydmVXaGl0ZXNwYWNlcywgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCk7XG4gICAgY29uc3QgaTE4bk1ldGFSZXN1bHQgPSBpMThuTWV0YVZpc2l0b3IudmlzaXRBbGxXaXRoRXJyb3JzKHJvb3ROb2Rlcyk7XG4gICAgaWYgKCFvcHRpb25zLmFsd2F5c0F0dGVtcHRIdG1sVG9SM0FzdENvbnZlcnNpb24gJiYgaTE4bk1ldGFSZXN1bHQuZXJyb3JzICYmXG4gICAgICAgIGkxOG5NZXRhUmVzdWx0LmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFRlbXBsYXRlID0ge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkNvbmZpZyxcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZXMsXG4gICAgICAgICAgICBlcnJvcnM6IGkxOG5NZXRhUmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICAgIHN0eWxlVXJsczogW10sXG4gICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5jb2xsZWN0Q29tbWVudE5vZGVzKSB7XG4gICAgICAgICAgICBwYXJzZWRUZW1wbGF0ZS5jb21tZW50Tm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkVGVtcGxhdGU7XG4gICAgfVxuICAgIHJvb3ROb2RlcyA9IGkxOG5NZXRhUmVzdWx0LnJvb3ROb2RlcztcbiAgICBpZiAoIXByZXNlcnZlV2hpdGVzcGFjZXMpIHtcbiAgICAgICAgcm9vdE5vZGVzID0gdmlzaXRBbGwobmV3IFdoaXRlc3BhY2VWaXNpdG9yKCksIHJvb3ROb2Rlcyk7XG4gICAgICAgIC8vIHJ1biBpMThuIG1ldGEgdmlzaXRvciBhZ2FpbiBpbiBjYXNlIHdoaXRlc3BhY2VzIGFyZSByZW1vdmVkIChiZWNhdXNlIHRoYXQgbWlnaHQgYWZmZWN0XG4gICAgICAgIC8vIGdlbmVyYXRlZCBpMThuIG1lc3NhZ2UgY29udGVudCkgYW5kIGZpcnN0IHBhc3MgaW5kaWNhdGVkIHRoYXQgaTE4biBjb250ZW50IGlzIHByZXNlbnQgaW4gYVxuICAgICAgICAvLyB0ZW1wbGF0ZS4gRHVyaW5nIHRoaXMgcGFzcyBpMThuIElEcyBnZW5lcmF0ZWQgYXQgdGhlIGZpcnN0IHBhc3Mgd2lsbCBiZSBwcmVzZXJ2ZWQsIHNvIHdlIGNhblxuICAgICAgICAvLyBtaW1pYyBleGlzdGluZyBleHRyYWN0aW9uIHByb2Nlc3MgKG5nIGV4dHJhY3QtaTE4bilcbiAgICAgICAgaWYgKGkxOG5NZXRhVmlzaXRvci5oYXNJMThuTWV0YSkge1xuICAgICAgICAgICAgcm9vdE5vZGVzID0gdmlzaXRBbGwobmV3IEkxOG5NZXRhVmlzaXRvcihpbnRlcnBvbGF0aW9uQ29uZmlnLCAvKiBrZWVwSTE4bkF0dHJzICovIGZhbHNlKSwgcm9vdE5vZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IG5vZGVzLCBlcnJvcnMsIHN0eWxlVXJscywgc3R5bGVzLCBuZ0NvbnRlbnRTZWxlY3RvcnMsIGNvbW1lbnROb2RlcyB9ID0gaHRtbEFzdFRvUmVuZGVyM0FzdChyb290Tm9kZXMsIGJpbmRpbmdQYXJzZXIsIHsgY29sbGVjdENvbW1lbnROb2RlczogISFvcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMgfSk7XG4gICAgZXJyb3JzLnB1c2goLi4ucGFyc2VSZXN1bHQuZXJyb3JzLCAuLi5pMThuTWV0YVJlc3VsdC5lcnJvcnMpO1xuICAgIGNvbnN0IHBhcnNlZFRlbXBsYXRlID0ge1xuICAgICAgICBpbnRlcnBvbGF0aW9uQ29uZmlnLFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzLFxuICAgICAgICBlcnJvcnM6IGVycm9ycy5sZW5ndGggPiAwID8gZXJyb3JzIDogbnVsbCxcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIHN0eWxlVXJscyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnNcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMpIHtcbiAgICAgICAgcGFyc2VkVGVtcGxhdGUuY29tbWVudE5vZGVzID0gY29tbWVudE5vZGVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkVGVtcGxhdGU7XG59XG5jb25zdCBlbGVtZW50UmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4vKipcbiAqIENvbnN0cnVjdCBhIGBCaW5kaW5nUGFyc2VyYCB3aXRoIGEgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxuICovXG5mdW5jdGlvbiBtYWtlQmluZGluZ1BhcnNlcihpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRykge1xuICAgIHJldHVybiBuZXcgQmluZGluZ1BhcnNlcihuZXcgUGFyc2VyJDEobmV3IExleGVyKCkpLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBlbGVtZW50UmVnaXN0cnksIFtdKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTYW5pdGl6YXRpb25Gbihjb250ZXh0LCBpc0F0dHJpYnV0ZSkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5IVE1MOlxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5zYW5pdGl6ZUh0bWwpO1xuICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5TQ1JJUFQ6XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnNhbml0aXplU2NyaXB0KTtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuU1RZTEU6XG4gICAgICAgICAgICAvLyB0aGUgY29tcGlsZXIgZG9lcyBub3QgZmlsbCBpbiBhbiBpbnN0cnVjdGlvbiBmb3IgW3N0eWxlLnByb3A/XSBiaW5kaW5nXG4gICAgICAgICAgICAvLyB2YWx1ZXMgYmVjYXVzZSB0aGUgc3R5bGUgYWxnb3JpdGhtIGtub3dzIGludGVybmFsbHkgd2hhdCBwcm9wcyBhcmUgc3ViamVjdFxuICAgICAgICAgICAgLy8gdG8gc2FuaXRpemF0aW9uIChvbmx5IFthdHRyLnN0eWxlXSB2YWx1ZXMgYXJlIGV4cGxpY2l0bHkgc2FuaXRpemVkKVxuICAgICAgICAgICAgcmV0dXJuIGlzQXR0cmlidXRlID8gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnNhbml0aXplU3R5bGUpIDogbnVsbDtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuVVJMOlxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5zYW5pdGl6ZVVybCk7XG4gICAgICAgIGNhc2UgU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTDpcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuc2FuaXRpemVSZXNvdXJjZVVybCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnVzdGVkQ29uc3RBdHRyaWJ1dGUodGFnTmFtZSwgYXR0cikge1xuICAgIGNvbnN0IHZhbHVlID0gYXNMaXRlcmFsKGF0dHIudmFsdWUpO1xuICAgIGlmIChpc1RydXN0ZWRUeXBlc1NpbmsodGFnTmFtZSwgYXR0ci5uYW1lKSkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnRSZWdpc3RyeS5zZWN1cml0eUNvbnRleHQodGFnTmFtZSwgYXR0ci5uYW1lLCAvKiBpc0F0dHJpYnV0ZSAqLyB0cnVlKSkge1xuICAgICAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuSFRNTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnZ2VkVGVtcGxhdGUoaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnRydXN0Q29uc3RhbnRIdG1sKSwgbmV3IFRlbXBsYXRlTGl0ZXJhbChbbmV3IFRlbXBsYXRlTGl0ZXJhbEVsZW1lbnQoYXR0ci52YWx1ZSldLCBbXSksIHVuZGVmaW5lZCwgYXR0ci52YWx1ZVNwYW4pO1xuICAgICAgICAgICAgLy8gTkI6IG5vIFNlY3VyaXR5Q29udGV4dC5TQ1JJUFQgaGVyZSwgYXMgdGhlIGNvcnJlc3BvbmRpbmcgdGFncyBhcmUgc3RyaXBwZWQgYnkgdGhlIGNvbXBpbGVyLlxuICAgICAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YWdnZWRUZW1wbGF0ZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEudHJ1c3RDb25zdGFudFJlc291cmNlVXJsKSwgbmV3IFRlbXBsYXRlTGl0ZXJhbChbbmV3IFRlbXBsYXRlTGl0ZXJhbEVsZW1lbnQoYXR0ci52YWx1ZSldLCBbXSksIHVuZGVmaW5lZCwgYXR0ci52YWx1ZVNwYW4pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NpbmdsZUVsZW1lbnRUZW1wbGF0ZShjaGlsZHJlbikge1xuICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBFbGVtZW50JDE7XG59XG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRleHQkMyB8fCBub2RlIGluc3RhbmNlb2YgQm91bmRUZXh0IHx8IG5vZGUgaW5zdGFuY2VvZiBJY3UkMTtcbn1cbmZ1bmN0aW9uIGhhc1RleHRDaGlsZHJlbk9ubHkoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gY2hpbGRyZW4uZXZlcnkoaXNUZXh0Tm9kZSk7XG59XG4vKiogTmFtZSBvZiB0aGUgZ2xvYmFsIHZhcmlhYmxlIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UgdXNlIENsb3N1cmUgdHJhbnNsYXRpb25zIG9yIG5vdCAqL1xuY29uc3QgTkdfSTE4Tl9DTE9TVVJFX01PREUgPSAnbmdJMThuQ2xvc3VyZU1vZGUnO1xuLyoqXG4gKiBHZW5lcmF0ZSBzdGF0ZW1lbnRzIHRoYXQgZGVmaW5lIGEgZ2l2ZW4gdHJhbnNsYXRpb24gbWVzc2FnZS5cbiAqXG4gKiBgYGBcbiAqIHZhciBJMThOXzE7XG4gKiBpZiAodHlwZW9mIG5nSTE4bkNsb3N1cmVNb2RlICE9PSB1bmRlZmluZWQgJiYgbmdJMThuQ2xvc3VyZU1vZGUpIHtcbiAqICAgICB2YXIgTVNHX0VYVEVSTkFMX1hYWCA9IGdvb2cuZ2V0TXNnKFxuICogICAgICAgICAgXCJTb21lIG1lc3NhZ2Ugd2l0aCB7JGludGVycG9sYXRpb259IVwiLFxuICogICAgICAgICAgeyBcImludGVycG9sYXRpb25cIjogXCJcXHVGRkZEMFxcdUZGRkRcIiB9XG4gKiAgICAgKTtcbiAqICAgICBJMThOXzEgPSBNU0dfRVhURVJOQUxfWFhYO1xuICogfVxuICogZWxzZSB7XG4gKiAgICAgSTE4Tl8xID0gJGxvY2FsaXplYFNvbWUgbWVzc2FnZSB3aXRoICR7J1xcdUZGRkQwXFx1RkZGRCd9IWA7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUaGUgb3JpZ2luYWwgaTE4biBBU1QgbWVzc2FnZSBub2RlXG4gKiBAcGFyYW0gdmFyaWFibGUgVGhlIHZhcmlhYmxlIHRoYXQgd2lsbCBiZSBhc3NpZ25lZCB0aGUgdHJhbnNsYXRpb24sIGUuZy4gYEkxOE5fMWAuXG4gKiBAcGFyYW0gY2xvc3VyZVZhciBUaGUgdmFyaWFibGUgZm9yIENsb3N1cmUgYGdvb2cuZ2V0TXNnYCBjYWxscywgZS5nLiBgTVNHX0VYVEVSTkFMX1hYWGAuXG4gKiBAcGFyYW0gcGFyYW1zIE9iamVjdCBtYXBwaW5nIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHRoZWlyIHZhbHVlcyAoZS5nLlxuICogYHsgXCJpbnRlcnBvbGF0aW9uXCI6IFwiXFx1RkZGRDBcXHVGRkZEXCIgfWApLlxuICogQHBhcmFtIHRyYW5zZm9ybUZuIE9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSB0cmFuc2xhdGlvbiAoZS5nLlxuICogcG9zdC1wcm9jZXNzaW5nKS5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0YXRlbWVudHMgdGhhdCBkZWZpbmVkIGEgZ2l2ZW4gdHJhbnNsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uRGVjbFN0bXRzKG1lc3NhZ2UsIHZhcmlhYmxlLCBjbG9zdXJlVmFyLCBwYXJhbXMgPSB7fSwgdHJhbnNmb3JtRm4pIHtcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gW1xuICAgICAgICBkZWNsYXJlSTE4blZhcmlhYmxlKHZhcmlhYmxlKSxcbiAgICAgICAgaWZTdG10KGNyZWF0ZUNsb3N1cmVNb2RlR3VhcmQoKSwgY3JlYXRlR29vZ2xlR2V0TXNnU3RhdGVtZW50cyh2YXJpYWJsZSwgbWVzc2FnZSwgY2xvc3VyZVZhciwgaTE4bkZvcm1hdFBsYWNlaG9sZGVyTmFtZXMocGFyYW1zLCAvKiB1c2VDYW1lbENhc2UgKi8gdHJ1ZSkpLCBjcmVhdGVMb2NhbGl6ZVN0YXRlbWVudHModmFyaWFibGUsIG1lc3NhZ2UsIGkxOG5Gb3JtYXRQbGFjZWhvbGRlck5hbWVzKHBhcmFtcywgLyogdXNlQ2FtZWxDYXNlICovIGZhbHNlKSkpLFxuICAgIF07XG4gICAgaWYgKHRyYW5zZm9ybUZuKSB7XG4gICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgRXhwcmVzc2lvblN0YXRlbWVudCh2YXJpYWJsZS5zZXQodHJhbnNmb3JtRm4odmFyaWFibGUpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVtZW50cztcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBleHByZXNzaW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGd1YXJkIHRoZSBjbG9zdXJlIG1vZGUgYmxvY2tcbiAqIEl0IGlzIGVxdWl2YWxlbnQgdG86XG4gKlxuICogYGBgXG4gKiB0eXBlb2YgbmdJMThuQ2xvc3VyZU1vZGUgIT09IHVuZGVmaW5lZCAmJiBuZ0kxOG5DbG9zdXJlTW9kZVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNsb3N1cmVNb2RlR3VhcmQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZkV4cHIodmFyaWFibGUoTkdfSTE4Tl9DTE9TVVJFX01PREUpKVxuICAgICAgICAubm90SWRlbnRpY2FsKGxpdGVyYWwoJ3VuZGVmaW5lZCcsIFNUUklOR19UWVBFKSlcbiAgICAgICAgLmFuZCh2YXJpYWJsZShOR19JMThOX0NMT1NVUkVfTU9ERSkpO1xufVxuZnVuY3Rpb24gZmxhdHRlbihsaXN0KSB7XG4gICAgcmV0dXJuIGxpc3QucmVkdWNlKChmbGF0LCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGZsYXRJdGVtID0gQXJyYXkuaXNBcnJheShpdGVtKSA/IGZsYXR0ZW4oaXRlbSkgOiBpdGVtO1xuICAgICAgICByZXR1cm4gZmxhdC5jb25jYXQoZmxhdEl0ZW0pO1xuICAgIH0sIFtdKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBUaGlzIHJlZ2V4IG1hdGNoZXMgYW55IGJpbmRpbmcgbmFtZXMgdGhhdCBjb250YWluIHRoZSBcImF0dHIuXCIgcHJlZml4LCBlLmcuIFwiYXR0ci5yZXF1aXJlZFwiXG4vLyBJZiB0aGVyZSBpcyBhIG1hdGNoLCB0aGUgZmlyc3QgbWF0Y2hpbmcgZ3JvdXAgd2lsbCBjb250YWluIHRoZSBhdHRyaWJ1dGUgbmFtZSB0byBiaW5kLlxuY29uc3QgQVRUUl9SRUdFWCA9IC9hdHRyXFwuKFteXFxdXSspLztcbmNvbnN0IENPTVBPTkVOVF9WQVJJQUJMRSA9ICclQ09NUCUnO1xuY29uc3QgSE9TVF9BVFRSID0gYF9uZ2hvc3QtJHtDT01QT05FTlRfVkFSSUFCTEV9YDtcbmNvbnN0IENPTlRFTlRfQVRUUiA9IGBfbmdjb250ZW50LSR7Q09NUE9ORU5UX1ZBUklBQkxFfWA7XG5mdW5jdGlvbiBiYXNlRGlyZWN0aXZlRmllbGRzKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcikge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGNvbnN0IHNlbGVjdG9ycyA9IHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3IobWV0YS5zZWxlY3Rvcik7XG4gICAgLy8gZS5nLiBgdHlwZTogTXlEaXJlY3RpdmVgXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3R5cGUnLCBtZXRhLmludGVybmFsVHlwZSk7XG4gICAgLy8gZS5nLiBgc2VsZWN0b3JzOiBbWycnLCAnc29tZURpcicsICcnXV1gXG4gICAgaWYgKHNlbGVjdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdzZWxlY3RvcnMnLCBhc0xpdGVyYWwoc2VsZWN0b3JzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnF1ZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBlLmcuIGBjb250ZW50UXVlcmllczogKHJmLCBjdHgsIGRpckluZGV4KSA9PiB7IC4uLiB9XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdjb250ZW50UXVlcmllcycsIGNyZWF0ZUNvbnRlbnRRdWVyaWVzRnVuY3Rpb24obWV0YS5xdWVyaWVzLCBjb25zdGFudFBvb2wsIG1ldGEubmFtZSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS52aWV3UXVlcmllcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZpZXdRdWVyeScsIGNyZWF0ZVZpZXdRdWVyaWVzRnVuY3Rpb24obWV0YS52aWV3UXVlcmllcywgY29uc3RhbnRQb29sLCBtZXRhLm5hbWUpKTtcbiAgICB9XG4gICAgLy8gZS5nLiBgaG9zdEJpbmRpbmdzOiAocmYsIGN0eCkgPT4geyAuLi4gfVxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdob3N0QmluZGluZ3MnLCBjcmVhdGVIb3N0QmluZGluZ3NGdW5jdGlvbihtZXRhLmhvc3QsIG1ldGEudHlwZVNvdXJjZVNwYW4sIGJpbmRpbmdQYXJzZXIsIGNvbnN0YW50UG9vbCwgbWV0YS5zZWxlY3RvciB8fCAnJywgbWV0YS5uYW1lLCBkZWZpbml0aW9uTWFwKSk7XG4gICAgLy8gZS5nICdpbnB1dHM6IHthOiAnYSd9YFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdpbnB1dHMnLCBjb25kaXRpb25hbGx5Q3JlYXRlTWFwT2JqZWN0TGl0ZXJhbChtZXRhLmlucHV0cywgdHJ1ZSkpO1xuICAgIC8vIGUuZyAnb3V0cHV0czoge2E6ICdhJ31gXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ291dHB1dHMnLCBjb25kaXRpb25hbGx5Q3JlYXRlTWFwT2JqZWN0TGl0ZXJhbChtZXRhLm91dHB1dHMpKTtcbiAgICBpZiAobWV0YS5leHBvcnRBcyAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZXhwb3J0QXMnLCBsaXRlcmFsQXJyKG1ldGEuZXhwb3J0QXMubWFwKGUgPT4gbGl0ZXJhbChlKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb25NYXA7XG59XG4vKipcbiAqIEFkZCBmZWF0dXJlcyB0byB0aGUgZGVmaW5pdGlvbiBtYXAuXG4gKi9cbmZ1bmN0aW9uIGFkZEZlYXR1cmVzKGRlZmluaXRpb25NYXAsIG1ldGEpIHtcbiAgICAvLyBlLmcuIGBmZWF0dXJlczogW05nT25DaGFuZ2VzRmVhdHVyZV1gXG4gICAgY29uc3QgZmVhdHVyZXMgPSBbXTtcbiAgICBjb25zdCBwcm92aWRlcnMgPSBtZXRhLnByb3ZpZGVycztcbiAgICBjb25zdCB2aWV3UHJvdmlkZXJzID0gbWV0YS52aWV3UHJvdmlkZXJzO1xuICAgIGlmIChwcm92aWRlcnMgfHwgdmlld1Byb3ZpZGVycykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3Byb3ZpZGVycyB8fCBuZXcgTGl0ZXJhbEFycmF5RXhwcihbXSldO1xuICAgICAgICBpZiAodmlld1Byb3ZpZGVycykge1xuICAgICAgICAgICAgYXJncy5wdXNoKHZpZXdQcm92aWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLlByb3ZpZGVyc0ZlYXR1cmUpLmNhbGxGbihhcmdzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnVzZXNJbmhlcml0YW5jZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5Jbmhlcml0RGVmaW5pdGlvbkZlYXR1cmUpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZnVsbEluaGVyaXRhbmNlKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLkNvcHlEZWZpbml0aW9uRmVhdHVyZSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5saWZlY3ljbGUudXNlc09uQ2hhbmdlcykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5OZ09uQ2hhbmdlc0ZlYXR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZmVhdHVyZXMnLCBsaXRlcmFsQXJyKGZlYXR1cmVzKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDb21waWxlIGEgZGlyZWN0aXZlIGZvciB0aGUgcmVuZGVyMyBydW50aW1lIGFzIGRlZmluZWQgYnkgdGhlIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURpcmVjdGl2ZUZyb21NZXRhZGF0YShtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gYmFzZURpcmVjdGl2ZUZpZWxkcyhtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpO1xuICAgIGFkZEZlYXR1cmVzKGRlZmluaXRpb25NYXAsIG1ldGEpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuZGVmaW5lRGlyZWN0aXZlKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVEaXJlY3RpdmVUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIENvbXBpbGUgYSBjb21wb25lbnQgZm9yIHRoZSByZW5kZXIzIHJ1bnRpbWUgYXMgZGVmaW5lZCBieSB0aGUgYFIzQ29tcG9uZW50TWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlQ29tcG9uZW50RnJvbU1ldGFkYXRhKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcikge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBiYXNlRGlyZWN0aXZlRmllbGRzKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcik7XG4gICAgYWRkRmVhdHVyZXMoZGVmaW5pdGlvbk1hcCwgbWV0YSk7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBtZXRhLnNlbGVjdG9yICYmIENzc1NlbGVjdG9yLnBhcnNlKG1ldGEuc2VsZWN0b3IpO1xuICAgIGNvbnN0IGZpcnN0U2VsZWN0b3IgPSBzZWxlY3RvciAmJiBzZWxlY3RvclswXTtcbiAgICAvLyBlLmcuIGBhdHRyOiBbXCJjbGFzc1wiLCBcIi5teS5hcHBcIl1gXG4gICAgLy8gVGhpcyBpcyBvcHRpb25hbCBhbiBvbmx5IGluY2x1ZGVkIGlmIHRoZSBmaXJzdCBzZWxlY3RvciBvZiBhIGNvbXBvbmVudCBzcGVjaWZpZXMgYXR0cmlidXRlcy5cbiAgICBpZiAoZmlyc3RTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBzZWxlY3RvckF0dHJpYnV0ZXMgPSBmaXJzdFNlbGVjdG9yLmdldEF0dHJzKCk7XG4gICAgICAgIGlmIChzZWxlY3RvckF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnYXR0cnMnLCBjb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGxpdGVyYWxBcnIoc2VsZWN0b3JBdHRyaWJ1dGVzLm1hcCh2YWx1ZSA9PiB2YWx1ZSAhPSBudWxsID8gbGl0ZXJhbCh2YWx1ZSkgOiBsaXRlcmFsKHVuZGVmaW5lZCkpKSwgXG4gICAgICAgICAgICAvKiBmb3JjZVNoYXJlZCAqLyB0cnVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZS5nLiBgdGVtcGxhdGU6IGZ1bmN0aW9uIE15Q29tcG9uZW50X1RlbXBsYXRlKF9jdHgsIF9jbSkgey4uLn1gXG4gICAgY29uc3QgdGVtcGxhdGVUeXBlTmFtZSA9IG1ldGEubmFtZTtcbiAgICBjb25zdCB0ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZVR5cGVOYW1lID8gYCR7dGVtcGxhdGVUeXBlTmFtZX1fVGVtcGxhdGVgIDogbnVsbDtcbiAgICBjb25zdCBjaGFuZ2VEZXRlY3Rpb24gPSBtZXRhLmNoYW5nZURldGVjdGlvbjtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IG1ldGEudGVtcGxhdGU7XG4gICAgY29uc3QgdGVtcGxhdGVCdWlsZGVyID0gbmV3IFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIoY29uc3RhbnRQb29sLCBCaW5kaW5nU2NvcGUuY3JlYXRlUm9vdFNjb3BlKCksIDAsIHRlbXBsYXRlVHlwZU5hbWUsIG51bGwsIG51bGwsIHRlbXBsYXRlTmFtZSwgSWRlbnRpZmllcnMkMS5uYW1lc3BhY2VIVE1MLCBtZXRhLnJlbGF0aXZlQ29udGV4dEZpbGVQYXRoLCBtZXRhLmkxOG5Vc2VFeHRlcm5hbElkcyk7XG4gICAgY29uc3QgdGVtcGxhdGVGdW5jdGlvbkV4cHJlc3Npb24gPSB0ZW1wbGF0ZUJ1aWxkZXIuYnVpbGRUZW1wbGF0ZUZ1bmN0aW9uKHRlbXBsYXRlLm5vZGVzLCBbXSk7XG4gICAgLy8gV2UgbmVlZCB0byBwcm92aWRlIHRoaXMgc28gdGhhdCBkeW5hbWljYWxseSBnZW5lcmF0ZWQgY29tcG9uZW50cyBrbm93IHdoYXRcbiAgICAvLyBwcm9qZWN0ZWQgY29udGVudCBibG9ja3MgdG8gcGFzcyB0aHJvdWdoIHRvIHRoZSBjb21wb25lbnQgd2hlbiBpdCBpcyBpbnN0YW50aWF0ZWQuXG4gICAgY29uc3QgbmdDb250ZW50U2VsZWN0b3JzID0gdGVtcGxhdGVCdWlsZGVyLmdldE5nQ29udGVudFNlbGVjdG9ycygpO1xuICAgIGlmIChuZ0NvbnRlbnRTZWxlY3RvcnMpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nQ29udGVudFNlbGVjdG9ycycsIG5nQ29udGVudFNlbGVjdG9ycyk7XG4gICAgfVxuICAgIC8vIGUuZy4gYGRlY2xzOiAyYFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZWNscycsIGxpdGVyYWwodGVtcGxhdGVCdWlsZGVyLmdldENvbnN0Q291bnQoKSkpO1xuICAgIC8vIGUuZy4gYHZhcnM6IDJgXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZhcnMnLCBsaXRlcmFsKHRlbXBsYXRlQnVpbGRlci5nZXRWYXJDb3VudCgpKSk7XG4gICAgLy8gR2VuZXJhdGUgYGNvbnN0c2Agc2VjdGlvbiBvZiBDb21wb25lbnREZWY6XG4gICAgLy8gLSBlaXRoZXIgYXMgYW4gYXJyYXk6XG4gICAgLy8gICBgY29uc3RzOiBbWydvbmUnLCAndHdvJ10sIFsndGhyZWUnLCAnZm91ciddXWBcbiAgICAvLyAtIG9yIGFzIGEgZmFjdG9yeSBmdW5jdGlvbiBpbiBjYXNlIGFkZGl0aW9uYWwgc3RhdGVtZW50cyBhcmUgcHJlc2VudCAodG8gc3VwcG9ydCBpMThuKTpcbiAgICAvLyAgIGBjb25zdHM6IGZ1bmN0aW9uKCkgeyB2YXIgaTE4bl8wOyBpZiAobmdJMThuQ2xvc3VyZU1vZGUpIHsuLi59IGVsc2Ugey4uLn0gcmV0dXJuIFtpMThuXzBdOyB9YFxuICAgIGNvbnN0IHsgY29uc3RFeHByZXNzaW9ucywgcHJlcGFyZVN0YXRlbWVudHMgfSA9IHRlbXBsYXRlQnVpbGRlci5nZXRDb25zdHMoKTtcbiAgICBpZiAoY29uc3RFeHByZXNzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBjb25zdHNFeHByID0gbGl0ZXJhbEFycihjb25zdEV4cHJlc3Npb25zKTtcbiAgICAgICAgLy8gUHJlcGFyZSBzdGF0ZW1lbnRzIGFyZSBwcmVzZW50IC0gdHVybiBgY29uc3RzYCBpbnRvIGEgZnVuY3Rpb24uXG4gICAgICAgIGlmIChwcmVwYXJlU3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdHNFeHByID0gZm4oW10sIFsuLi5wcmVwYXJlU3RhdGVtZW50cywgbmV3IFJldHVyblN0YXRlbWVudChjb25zdHNFeHByKV0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdjb25zdHMnLCBjb25zdHNFeHByKTtcbiAgICB9XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3RlbXBsYXRlJywgdGVtcGxhdGVGdW5jdGlvbkV4cHJlc3Npb24pO1xuICAgIC8vIGUuZy4gYGRpcmVjdGl2ZXM6IFtNeURpcmVjdGl2ZV1gXG4gICAgaWYgKG1ldGEuZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGl2ZXNMaXN0ID0gbGl0ZXJhbEFycihtZXRhLmRpcmVjdGl2ZXMubWFwKGRpciA9PiBkaXIudHlwZSkpO1xuICAgICAgICBjb25zdCBkaXJlY3RpdmVzRXhwciA9IGNvbXBpbGVEZWNsYXJhdGlvbkxpc3QoZGlyZWN0aXZlc0xpc3QsIG1ldGEuZGVjbGFyYXRpb25MaXN0RW1pdE1vZGUpO1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZGlyZWN0aXZlcycsIGRpcmVjdGl2ZXNFeHByKTtcbiAgICB9XG4gICAgLy8gZS5nLiBgcGlwZXM6IFtNeVBpcGVdYFxuICAgIGlmIChtZXRhLnBpcGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHBpcGVzTGlzdCA9IGxpdGVyYWxBcnIoQXJyYXkuZnJvbShtZXRhLnBpcGVzLnZhbHVlcygpKSk7XG4gICAgICAgIGNvbnN0IHBpcGVzRXhwciA9IGNvbXBpbGVEZWNsYXJhdGlvbkxpc3QocGlwZXNMaXN0LCBtZXRhLmRlY2xhcmF0aW9uTGlzdEVtaXRNb2RlKTtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3BpcGVzJywgcGlwZXNFeHByKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZW5jYXBzdWxhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICBtZXRhLmVuY2Fwc3VsYXRpb24gPSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZDtcbiAgICB9XG4gICAgLy8gZS5nLiBgc3R5bGVzOiBbc3RyMSwgc3RyMl1gXG4gICAgaWYgKG1ldGEuc3R5bGVzICYmIG1ldGEuc3R5bGVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBzdHlsZVZhbHVlcyA9IG1ldGEuZW5jYXBzdWxhdGlvbiA9PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCA/XG4gICAgICAgICAgICBjb21waWxlU3R5bGVzKG1ldGEuc3R5bGVzLCBDT05URU5UX0FUVFIsIEhPU1RfQVRUUikgOlxuICAgICAgICAgICAgbWV0YS5zdHlsZXM7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBzdHlsZVZhbHVlcy5tYXAoc3RyID0+IGNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwobGl0ZXJhbChzdHIpKSk7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdzdHlsZXMnLCBsaXRlcmFsQXJyKHN0cmluZ3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS5lbmNhcHN1bGF0aW9uID09PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdHlsZSwgZG9uJ3QgZ2VuZXJhdGUgY3NzIHNlbGVjdG9ycyBvbiBlbGVtZW50c1xuICAgICAgICBtZXRhLmVuY2Fwc3VsYXRpb24gPSBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lO1xuICAgIH1cbiAgICAvLyBPbmx5IHNldCB2aWV3IGVuY2Fwc3VsYXRpb24gaWYgaXQncyBub3QgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAobWV0YS5lbmNhcHN1bGF0aW9uICE9PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZW5jYXBzdWxhdGlvbicsIGxpdGVyYWwobWV0YS5lbmNhcHN1bGF0aW9uKSk7XG4gICAgfVxuICAgIC8vIGUuZy4gYGFuaW1hdGlvbjogW3RyaWdnZXIoJzEyMycsIFtdKV1gXG4gICAgaWYgKG1ldGEuYW5pbWF0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZGF0YScsIGxpdGVyYWxNYXAoW3sga2V5OiAnYW5pbWF0aW9uJywgdmFsdWU6IG1ldGEuYW5pbWF0aW9ucywgcXVvdGVkOiBmYWxzZSB9XSkpO1xuICAgIH1cbiAgICAvLyBPbmx5IHNldCB0aGUgY2hhbmdlIGRldGVjdGlvbiBmbGFnIGlmIGl0J3MgZGVmaW5lZCBhbmQgaXQncyBub3QgdGhlIGRlZmF1bHQuXG4gICAgaWYgKGNoYW5nZURldGVjdGlvbiAhPSBudWxsICYmIGNoYW5nZURldGVjdGlvbiAhPT0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnY2hhbmdlRGV0ZWN0aW9uJywgbGl0ZXJhbChjaGFuZ2VEZXRlY3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5kZWZpbmVDb21wb25lbnQpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgY29uc3QgdHlwZSA9IGNyZWF0ZUNvbXBvbmVudFR5cGUobWV0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50czogW10gfTtcbn1cbi8qKlxuICogQ3JlYXRlcyB0aGUgdHlwZSBzcGVjaWZpY2F0aW9uIGZyb20gdGhlIGNvbXBvbmVudCBtZXRhLiBUaGlzIHR5cGUgaXMgaW5zZXJ0ZWQgaW50byAuZC50cyBmaWxlc1xuICogdG8gYmUgY29uc3VtZWQgYnkgdXBzdHJlYW0gY29tcGlsYXRpb25zLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRUeXBlKG1ldGEpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1zID0gY3JlYXRlRGlyZWN0aXZlVHlwZVBhcmFtcyhtZXRhKTtcbiAgICB0eXBlUGFyYW1zLnB1c2goc3RyaW5nQXJyYXlBc1R5cGUobWV0YS50ZW1wbGF0ZS5uZ0NvbnRlbnRTZWxlY3RvcnMpKTtcbiAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLkNvbXBvbmVudERlY2xhcmF0aW9uLCB0eXBlUGFyYW1zKSk7XG59XG4vKipcbiAqIENvbXBpbGVzIHRoZSBhcnJheSBsaXRlcmFsIG9mIGRlY2xhcmF0aW9ucyBpbnRvIGFuIGV4cHJlc3Npb24gYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBlbWl0XG4gKiBtb2RlLlxuICovXG5mdW5jdGlvbiBjb21waWxlRGVjbGFyYXRpb25MaXN0KGxpc3QsIG1vZGUpIHtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIERpcmVjdCAqLzpcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZXM6IFtNeURpcl0sXG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgY2FzZSAxIC8qIENsb3N1cmUgKi86XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbTXlEaXJdOyB9XG4gICAgICAgICAgICByZXR1cm4gZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KGxpc3QpXSk7XG4gICAgICAgIGNhc2UgMiAvKiBDbG9zdXJlUmVzb2x2ZWQgKi86XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbTXlEaXJdLm1hcChuZy5yZXNvbHZlRm9yd2FyZFJlZik7IH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkTGlzdCA9IGxpc3QucHJvcCgnbWFwJykuY2FsbEZuKFtpbXBvcnRFeHByKElkZW50aWZpZXJzJDEucmVzb2x2ZUZvcndhcmRSZWYpXSk7XG4gICAgICAgICAgICByZXR1cm4gZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KHJlc29sdmVkTGlzdCldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlUXVlcnlQYXJhbXMocXVlcnksIGNvbnN0YW50UG9vbCkge1xuICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbZ2V0UXVlcnlQcmVkaWNhdGUocXVlcnksIGNvbnN0YW50UG9vbCksIGxpdGVyYWwodG9RdWVyeUZsYWdzKHF1ZXJ5KSldO1xuICAgIGlmIChxdWVyeS5yZWFkKSB7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaChxdWVyeS5yZWFkKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG4vKipcbiAqIFRyYW5zbGF0ZXMgcXVlcnkgZmxhZ3MgaW50byBgVFF1ZXJ5RmxhZ3NgIHR5cGUgaW4gcGFja2FnZXMvY29yZS9zcmMvcmVuZGVyMy9pbnRlcmZhY2VzL3F1ZXJ5LnRzXG4gKiBAcGFyYW0gcXVlcnlcbiAqL1xuZnVuY3Rpb24gdG9RdWVyeUZsYWdzKHF1ZXJ5KSB7XG4gICAgcmV0dXJuIChxdWVyeS5kZXNjZW5kYW50cyA/IDEgLyogZGVzY2VuZGFudHMgKi8gOiAwIC8qIG5vbmUgKi8pIHxcbiAgICAgICAgKHF1ZXJ5LnN0YXRpYyA/IDIgLyogaXNTdGF0aWMgKi8gOiAwIC8qIG5vbmUgKi8pIHxcbiAgICAgICAgKHF1ZXJ5LmVtaXREaXN0aW5jdENoYW5nZXNPbmx5ID8gNCAvKiBlbWl0RGlzdGluY3RDaGFuZ2VzT25seSAqLyA6IDAgLyogbm9uZSAqLyk7XG59XG5mdW5jdGlvbiBjb252ZXJ0QXR0cmlidXRlc1RvRXhwcmVzc2lvbnMoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgdmFsdWVzLnB1c2gobGl0ZXJhbChrZXkpLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vLyBEZWZpbmUgYW5kIHVwZGF0ZSBhbnkgY29udGVudCBxdWVyaWVzXG5mdW5jdGlvbiBjcmVhdGVDb250ZW50UXVlcmllc0Z1bmN0aW9uKHF1ZXJpZXMsIGNvbnN0YW50UG9vbCwgbmFtZSkge1xuICAgIGNvbnN0IGNyZWF0ZVN0YXRlbWVudHMgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgY29uc3QgdGVtcEFsbG9jYXRvciA9IHRlbXBvcmFyeUFsbG9jYXRvcih1cGRhdGVTdGF0ZW1lbnRzLCBURU1QT1JBUllfTkFNRSk7XG4gICAgZm9yIChjb25zdCBxdWVyeSBvZiBxdWVyaWVzKSB7XG4gICAgICAgIC8vIGNyZWF0aW9uLCBlLmcuIHIzLmNvbnRlbnRRdWVyeShkaXJJbmRleCwgc29tZVByZWRpY2F0ZSwgdHJ1ZSwgbnVsbCk7XG4gICAgICAgIGNyZWF0ZVN0YXRlbWVudHMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuY29udGVudFF1ZXJ5KVxuICAgICAgICAgICAgLmNhbGxGbihbdmFyaWFibGUoJ2RpckluZGV4JyksIC4uLnByZXBhcmVRdWVyeVBhcmFtcyhxdWVyeSwgY29uc3RhbnRQb29sKV0pXG4gICAgICAgICAgICAudG9TdG10KCkpO1xuICAgICAgICAvLyB1cGRhdGUsIGUuZy4gKHIzLnF1ZXJ5UmVmcmVzaCh0bXAgPSByMy5sb2FkUXVlcnkoKSkgJiYgKGN0eC5zb21lRGlyID0gdG1wKSk7XG4gICAgICAgIGNvbnN0IHRlbXBvcmFyeSA9IHRlbXBBbGxvY2F0b3IoKTtcbiAgICAgICAgY29uc3QgZ2V0UXVlcnlMaXN0ID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmxvYWRRdWVyeSkuY2FsbEZuKFtdKTtcbiAgICAgICAgY29uc3QgcmVmcmVzaCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5xdWVyeVJlZnJlc2gpLmNhbGxGbihbdGVtcG9yYXJ5LnNldChnZXRRdWVyeUxpc3QpXSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZURpcmVjdGl2ZSA9IHZhcmlhYmxlKENPTlRFWFRfTkFNRSlcbiAgICAgICAgICAgIC5wcm9wKHF1ZXJ5LnByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgIC5zZXQocXVlcnkuZmlyc3QgPyB0ZW1wb3JhcnkucHJvcCgnZmlyc3QnKSA6IHRlbXBvcmFyeSk7XG4gICAgICAgIHVwZGF0ZVN0YXRlbWVudHMucHVzaChyZWZyZXNoLmFuZCh1cGRhdGVEaXJlY3RpdmUpLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgY29uc3QgY29udGVudFF1ZXJpZXNGbk5hbWUgPSBuYW1lID8gYCR7bmFtZX1fQ29udGVudFF1ZXJpZXNgIDogbnVsbDtcbiAgICByZXR1cm4gZm4oW1xuICAgICAgICBuZXcgRm5QYXJhbShSRU5ERVJfRkxBR1MsIE5VTUJFUl9UWVBFKSwgbmV3IEZuUGFyYW0oQ09OVEVYVF9OQU1FLCBudWxsKSxcbiAgICAgICAgbmV3IEZuUGFyYW0oJ2RpckluZGV4JywgbnVsbClcbiAgICBdLCBbXG4gICAgICAgIHJlbmRlckZsYWdDaGVja0lmU3RtdCgxIC8qIENyZWF0ZSAqLywgY3JlYXRlU3RhdGVtZW50cyksXG4gICAgICAgIHJlbmRlckZsYWdDaGVja0lmU3RtdCgyIC8qIFVwZGF0ZSAqLywgdXBkYXRlU3RhdGVtZW50cylcbiAgICBdLCBJTkZFUlJFRF9UWVBFLCBudWxsLCBjb250ZW50UXVlcmllc0ZuTmFtZSk7XG59XG5mdW5jdGlvbiBzdHJpbmdBc1R5cGUoc3RyKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25UeXBlKGxpdGVyYWwoc3RyKSk7XG59XG5mdW5jdGlvbiBzdHJpbmdNYXBBc1R5cGUobWFwKSB7XG4gICAgY29uc3QgbWFwVmFsdWVzID0gT2JqZWN0LmtleXMobWFwKS5tYXAoa2V5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBBcnJheS5pc0FycmF5KG1hcFtrZXldKSA/IG1hcFtrZXldWzBdIDogbWFwW2tleV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbCh2YWx1ZSksXG4gICAgICAgICAgICBxdW90ZWQ6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25UeXBlKGxpdGVyYWxNYXAobWFwVmFsdWVzKSk7XG59XG5mdW5jdGlvbiBzdHJpbmdBcnJheUFzVHlwZShhcnIpIHtcbiAgICByZXR1cm4gYXJyLmxlbmd0aCA+IDAgPyBleHByZXNzaW9uVHlwZShsaXRlcmFsQXJyKGFyci5tYXAodmFsdWUgPT4gbGl0ZXJhbCh2YWx1ZSkpKSkgOlxuICAgICAgICBOT05FX1RZUEU7XG59XG5mdW5jdGlvbiBjcmVhdGVEaXJlY3RpdmVUeXBlUGFyYW1zKG1ldGEpIHtcbiAgICAvLyBPbiB0aGUgdHlwZSBzaWRlLCByZW1vdmUgbmV3bGluZXMgZnJvbSB0aGUgc2VsZWN0b3IgYXMgaXQgd2lsbCBuZWVkIHRvIGZpdCBpbnRvIGEgVHlwZVNjcmlwdFxuICAgIC8vIHN0cmluZyBsaXRlcmFsLCB3aGljaCBtdXN0IGJlIG9uIG9uZSBsaW5lLlxuICAgIGNvbnN0IHNlbGVjdG9yRm9yVHlwZSA9IG1ldGEuc2VsZWN0b3IgIT09IG51bGwgPyBtZXRhLnNlbGVjdG9yLnJlcGxhY2UoL1xcbi9nLCAnJykgOiBudWxsO1xuICAgIHJldHVybiBbXG4gICAgICAgIHR5cGVXaXRoUGFyYW1ldGVycyhtZXRhLnR5cGUudHlwZSwgbWV0YS50eXBlQXJndW1lbnRDb3VudCksXG4gICAgICAgIHNlbGVjdG9yRm9yVHlwZSAhPT0gbnVsbCA/IHN0cmluZ0FzVHlwZShzZWxlY3RvckZvclR5cGUpIDogTk9ORV9UWVBFLFxuICAgICAgICBtZXRhLmV4cG9ydEFzICE9PSBudWxsID8gc3RyaW5nQXJyYXlBc1R5cGUobWV0YS5leHBvcnRBcykgOiBOT05FX1RZUEUsXG4gICAgICAgIHN0cmluZ01hcEFzVHlwZShtZXRhLmlucHV0cyksXG4gICAgICAgIHN0cmluZ01hcEFzVHlwZShtZXRhLm91dHB1dHMpLFxuICAgICAgICBzdHJpbmdBcnJheUFzVHlwZShtZXRhLnF1ZXJpZXMubWFwKHEgPT4gcS5wcm9wZXJ0eU5hbWUpKSxcbiAgICBdO1xufVxuLyoqXG4gKiBDcmVhdGVzIHRoZSB0eXBlIHNwZWNpZmljYXRpb24gZnJvbSB0aGUgZGlyZWN0aXZlIG1ldGEuIFRoaXMgdHlwZSBpcyBpbnNlcnRlZCBpbnRvIC5kLnRzIGZpbGVzXG4gKiB0byBiZSBjb25zdW1lZCBieSB1cHN0cmVhbSBjb21waWxhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpcmVjdGl2ZVR5cGUobWV0YSkge1xuICAgIGNvbnN0IHR5cGVQYXJhbXMgPSBjcmVhdGVEaXJlY3RpdmVUeXBlUGFyYW1zKG1ldGEpO1xuICAgIHJldHVybiBleHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuRGlyZWN0aXZlRGVjbGFyYXRpb24sIHR5cGVQYXJhbXMpKTtcbn1cbi8vIERlZmluZSBhbmQgdXBkYXRlIGFueSB2aWV3IHF1ZXJpZXNcbmZ1bmN0aW9uIGNyZWF0ZVZpZXdRdWVyaWVzRnVuY3Rpb24odmlld1F1ZXJpZXMsIGNvbnN0YW50UG9vbCwgbmFtZSkge1xuICAgIGNvbnN0IGNyZWF0ZVN0YXRlbWVudHMgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgY29uc3QgdGVtcEFsbG9jYXRvciA9IHRlbXBvcmFyeUFsbG9jYXRvcih1cGRhdGVTdGF0ZW1lbnRzLCBURU1QT1JBUllfTkFNRSk7XG4gICAgdmlld1F1ZXJpZXMuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgLy8gY3JlYXRpb24sIGUuZy4gcjMudmlld1F1ZXJ5KHNvbWVQcmVkaWNhdGUsIHRydWUpO1xuICAgICAgICBjb25zdCBxdWVyeURlZmluaXRpb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEudmlld1F1ZXJ5KS5jYWxsRm4ocHJlcGFyZVF1ZXJ5UGFyYW1zKHF1ZXJ5LCBjb25zdGFudFBvb2wpKTtcbiAgICAgICAgY3JlYXRlU3RhdGVtZW50cy5wdXNoKHF1ZXJ5RGVmaW5pdGlvbi50b1N0bXQoKSk7XG4gICAgICAgIC8vIHVwZGF0ZSwgZS5nLiAocjMucXVlcnlSZWZyZXNoKHRtcCA9IHIzLmxvYWRRdWVyeSgpKSAmJiAoY3R4LnNvbWVEaXIgPSB0bXApKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5ID0gdGVtcEFsbG9jYXRvcigpO1xuICAgICAgICBjb25zdCBnZXRRdWVyeUxpc3QgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEubG9hZFF1ZXJ5KS5jYWxsRm4oW10pO1xuICAgICAgICBjb25zdCByZWZyZXNoID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLnF1ZXJ5UmVmcmVzaCkuY2FsbEZuKFt0ZW1wb3Jhcnkuc2V0KGdldFF1ZXJ5TGlzdCldKTtcbiAgICAgICAgY29uc3QgdXBkYXRlRGlyZWN0aXZlID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FKVxuICAgICAgICAgICAgLnByb3AocXVlcnkucHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgLnNldChxdWVyeS5maXJzdCA/IHRlbXBvcmFyeS5wcm9wKCdmaXJzdCcpIDogdGVtcG9yYXJ5KTtcbiAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKHJlZnJlc2guYW5kKHVwZGF0ZURpcmVjdGl2ZSkudG9TdG10KCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IHZpZXdRdWVyeUZuTmFtZSA9IG5hbWUgPyBgJHtuYW1lfV9RdWVyeWAgOiBudWxsO1xuICAgIHJldHVybiBmbihbbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCldLCBbXG4gICAgICAgIHJlbmRlckZsYWdDaGVja0lmU3RtdCgxIC8qIENyZWF0ZSAqLywgY3JlYXRlU3RhdGVtZW50cyksXG4gICAgICAgIHJlbmRlckZsYWdDaGVja0lmU3RtdCgyIC8qIFVwZGF0ZSAqLywgdXBkYXRlU3RhdGVtZW50cylcbiAgICBdLCBJTkZFUlJFRF9UWVBFLCBudWxsLCB2aWV3UXVlcnlGbk5hbWUpO1xufVxuLy8gUmV0dXJuIGEgaG9zdCBiaW5kaW5nIGZ1bmN0aW9uIG9yIG51bGwgaWYgb25lIGlzIG5vdCBuZWNlc3NhcnkuXG5mdW5jdGlvbiBjcmVhdGVIb3N0QmluZGluZ3NGdW5jdGlvbihob3N0QmluZGluZ3NNZXRhZGF0YSwgdHlwZVNvdXJjZVNwYW4sIGJpbmRpbmdQYXJzZXIsIGNvbnN0YW50UG9vbCwgc2VsZWN0b3IsIG5hbWUsIGRlZmluaXRpb25NYXApIHtcbiAgICBjb25zdCBiaW5kaW5nQ29udGV4dCA9IHZhcmlhYmxlKENPTlRFWFRfTkFNRSk7XG4gICAgY29uc3Qgc3R5bGVCdWlsZGVyID0gbmV3IFN0eWxpbmdCdWlsZGVyKGJpbmRpbmdDb250ZXh0KTtcbiAgICBjb25zdCB7IHN0eWxlQXR0ciwgY2xhc3NBdHRyIH0gPSBob3N0QmluZGluZ3NNZXRhZGF0YS5zcGVjaWFsQXR0cmlidXRlcztcbiAgICBpZiAoc3R5bGVBdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3R5bGVCdWlsZGVyLnJlZ2lzdGVyU3R5bGVBdHRyKHN0eWxlQXR0cik7XG4gICAgfVxuICAgIGlmIChjbGFzc0F0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZUJ1aWxkZXIucmVnaXN0ZXJDbGFzc0F0dHIoY2xhc3NBdHRyKTtcbiAgICB9XG4gICAgY29uc3QgY3JlYXRlU3RhdGVtZW50cyA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZVN0YXRlbWVudHMgPSBbXTtcbiAgICBjb25zdCBob3N0QmluZGluZ1NvdXJjZVNwYW4gPSB0eXBlU291cmNlU3BhbjtcbiAgICAvLyBDYWxjdWxhdGUgaG9zdCBldmVudCBiaW5kaW5nc1xuICAgIGNvbnN0IGV2ZW50QmluZGluZ3MgPSBiaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoaG9zdEJpbmRpbmdzTWV0YWRhdGEubGlzdGVuZXJzLCBob3N0QmluZGluZ1NvdXJjZVNwYW4pO1xuICAgIGlmIChldmVudEJpbmRpbmdzICYmIGV2ZW50QmluZGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IGNyZWF0ZUhvc3RMaXN0ZW5lcnMoZXZlbnRCaW5kaW5ncywgbmFtZSk7XG4gICAgICAgIGNyZWF0ZVN0YXRlbWVudHMucHVzaCguLi5saXN0ZW5lcnMpO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZ3NcbiAgICBjb25zdCBiaW5kaW5ncyA9IGJpbmRpbmdQYXJzZXIuY3JlYXRlQm91bmRIb3N0UHJvcGVydGllcyhob3N0QmluZGluZ3NNZXRhZGF0YS5wcm9wZXJ0aWVzLCBob3N0QmluZGluZ1NvdXJjZVNwYW4pO1xuICAgIGNvbnN0IGFsbE90aGVyQmluZGluZ3MgPSBbXTtcbiAgICAvLyBXZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgdG90YWwgYW1vdW50IG9mIGJpbmRpbmcgc2xvdHMgcmVxdWlyZWQgYnlcbiAgICAvLyBhbGwgdGhlIGluc3RydWN0aW9ucyB0b2dldGhlciBiZWZvcmUgYW55IHZhbHVlIGNvbnZlcnNpb25zIGhhcHBlbi5cbiAgICAvLyBWYWx1ZSBjb252ZXJzaW9ucyBtYXkgcmVxdWlyZSBhZGRpdGlvbmFsIHNsb3RzIGZvciBpbnRlcnBvbGF0aW9uIGFuZFxuICAgIC8vIGJpbmRpbmdzIHdpdGggcGlwZXMuIFRoZXNlIGNhbGN1bGF0ZXMgaGFwcGVuIGFmdGVyIHRoaXMgYmxvY2suXG4gICAgbGV0IHRvdGFsSG9zdFZhcnNDb3VudCA9IDA7XG4gICAgYmluZGluZ3MgJiYgYmluZGluZ3MuZm9yRWFjaCgoYmluZGluZykgPT4ge1xuICAgICAgICBjb25zdCBzdHlsaW5nSW5wdXRXYXNTZXQgPSBzdHlsZUJ1aWxkZXIucmVnaXN0ZXJJbnB1dEJhc2VkT25OYW1lKGJpbmRpbmcubmFtZSwgYmluZGluZy5leHByZXNzaW9uLCBob3N0QmluZGluZ1NvdXJjZVNwYW4pO1xuICAgICAgICBpZiAoc3R5bGluZ0lucHV0V2FzU2V0KSB7XG4gICAgICAgICAgICB0b3RhbEhvc3RWYXJzQ291bnQgKz0gTUlOX1NUWUxJTkdfQklORElOR19TTE9UU19SRVFVSVJFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsbE90aGVyQmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgICAgICAgICAgIHRvdGFsSG9zdFZhcnNDb3VudCsrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHZhbHVlQ29udmVydGVyO1xuICAgIGNvbnN0IGdldFZhbHVlQ29udmVydGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgICAgICBjb25zdCBob3N0VmFyc0NvdW50Rm4gPSAobnVtU2xvdHMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFZhcnNDb3VudCA9IHRvdGFsSG9zdFZhcnNDb3VudDtcbiAgICAgICAgICAgICAgICB0b3RhbEhvc3RWYXJzQ291bnQgKz0gbnVtU2xvdHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsVmFyc0NvdW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlQ29udmVydGVyID0gbmV3IFZhbHVlQ29udmVydGVyKGNvbnN0YW50UG9vbCwgKCkgPT4gZXJyb3IoJ1VuZXhwZWN0ZWQgbm9kZScpLCAvLyBuZXcgbm9kZXMgYXJlIGlsbGVnYWwgaGVyZVxuICAgICAgICAgICAgaG9zdFZhcnNDb3VudEZuLCAoKSA9PiBlcnJvcignVW5leHBlY3RlZCBwaXBlJykpOyAvLyBwaXBlcyBhcmUgaWxsZWdhbCBoZXJlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlQ29udmVydGVyO1xuICAgIH07XG4gICAgY29uc3QgcHJvcGVydHlCaW5kaW5ncyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZUJpbmRpbmdzID0gW107XG4gICAgY29uc3Qgc3ludGhldGljSG9zdEJpbmRpbmdzID0gW107XG4gICAgYWxsT3RoZXJCaW5kaW5ncy5mb3JFYWNoKChiaW5kaW5nKSA9PiB7XG4gICAgICAgIC8vIHJlc29sdmUgbGl0ZXJhbCBhcnJheXMgYW5kIGxpdGVyYWwgb2JqZWN0c1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGJpbmRpbmcuZXhwcmVzc2lvbi52aXNpdChnZXRWYWx1ZUNvbnZlcnRlcigpKTtcbiAgICAgICAgY29uc3QgYmluZGluZ0V4cHIgPSBiaW5kaW5nRm4oYmluZGluZ0NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgeyBiaW5kaW5nTmFtZSwgaW5zdHJ1Y3Rpb24sIGlzQXR0cmlidXRlIH0gPSBnZXRCaW5kaW5nTmFtZUFuZEluc3RydWN0aW9uKGJpbmRpbmcpO1xuICAgICAgICBjb25zdCBzZWN1cml0eUNvbnRleHRzID0gYmluZGluZ1BhcnNlci5jYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHNlbGVjdG9yLCBiaW5kaW5nTmFtZSwgaXNBdHRyaWJ1dGUpXG4gICAgICAgICAgICAuZmlsdGVyKGNvbnRleHQgPT4gY29udGV4dCAhPT0gU2VjdXJpdHlDb250ZXh0Lk5PTkUpO1xuICAgICAgICBsZXQgc2FuaXRpemVyRm4gPSBudWxsO1xuICAgICAgICBpZiAoc2VjdXJpdHlDb250ZXh0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChzZWN1cml0eUNvbnRleHRzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMuaW5kZXhPZihTZWN1cml0eUNvbnRleHQuVVJMKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cy5pbmRleE9mKFNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHNvbWUgVVJMIGF0dHJpYnV0ZXMgKHN1Y2ggYXMgXCJzcmNcIiBhbmQgXCJocmVmXCIpIHRoYXQgbWF5IGJlIGEgcGFydFxuICAgICAgICAgICAgICAgIC8vIG9mIGRpZmZlcmVudCBzZWN1cml0eSBjb250ZXh0cy4gSW4gdGhpcyBjYXNlIHdlIHVzZSBzcGVjaWFsIHNhbml0aXphdGlvbiBmdW5jdGlvbiBhbmRcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3QgdGhlIGFjdHVhbCBzYW5pdGl6ZXIgYXQgcnVudGltZSBiYXNlZCBvbiBhIHRhZyBuYW1lIHRoYXQgaXMgcHJvdmlkZWQgd2hpbGVcbiAgICAgICAgICAgICAgICAvLyBpbnZva2luZyBzYW5pdGl6YXRpb24gZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgc2FuaXRpemVyRm4gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuc2FuaXRpemVVcmxPclJlc291cmNlVXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbml0aXplckZuID0gcmVzb2x2ZVNhbml0aXphdGlvbkZuKHNlY3VyaXR5Q29udGV4dHNbMF0sIGlzQXR0cmlidXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnN0cnVjdGlvblBhcmFtcyA9IFtsaXRlcmFsKGJpbmRpbmdOYW1lKSwgYmluZGluZ0V4cHIuY3VyclZhbEV4cHJdO1xuICAgICAgICBpZiAoc2FuaXRpemVyRm4pIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9uUGFyYW1zLnB1c2goc2FuaXRpemVyRm4pO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVN0YXRlbWVudHMucHVzaCguLi5iaW5kaW5nRXhwci5zdG10cyk7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbiA9PT0gSWRlbnRpZmllcnMkMS5ob3N0UHJvcGVydHkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5QmluZGluZ3MucHVzaChpbnN0cnVjdGlvblBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb24gPT09IElkZW50aWZpZXJzJDEuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVCaW5kaW5ncy5wdXNoKGluc3RydWN0aW9uUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbiA9PT0gSWRlbnRpZmllcnMkMS5zeW50aGV0aWNIb3N0UHJvcGVydHkpIHtcbiAgICAgICAgICAgIHN5bnRoZXRpY0hvc3RCaW5kaW5ncy5wdXNoKGluc3RydWN0aW9uUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlbWVudHMucHVzaChpbXBvcnRFeHByKGluc3RydWN0aW9uKS5jYWxsRm4oaW5zdHJ1Y3Rpb25QYXJhbXMpLnRvU3RtdCgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChwcm9wZXJ0eUJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKGNoYWluZWRJbnN0cnVjdGlvbihJZGVudGlmaWVycyQxLmhvc3RQcm9wZXJ0eSwgcHJvcGVydHlCaW5kaW5ncykudG9TdG10KCkpO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlQmluZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2goY2hhaW5lZEluc3RydWN0aW9uKElkZW50aWZpZXJzJDEuYXR0cmlidXRlLCBhdHRyaWJ1dGVCaW5kaW5ncykudG9TdG10KCkpO1xuICAgIH1cbiAgICBpZiAoc3ludGhldGljSG9zdEJpbmRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKGNoYWluZWRJbnN0cnVjdGlvbihJZGVudGlmaWVycyQxLnN5bnRoZXRpY0hvc3RQcm9wZXJ0eSwgc3ludGhldGljSG9zdEJpbmRpbmdzKS50b1N0bXQoKSk7XG4gICAgfVxuICAgIC8vIHNpbmNlIHdlJ3JlIGRlYWxpbmcgd2l0aCBkaXJlY3RpdmVzL2NvbXBvbmVudHMgYW5kIGJvdGggaGF2ZSBob3N0QmluZGluZ1xuICAgIC8vIGZ1bmN0aW9ucywgd2UgbmVlZCB0byBnZW5lcmF0ZSBhIHNwZWNpYWwgaG9zdEF0dHJzIGluc3RydWN0aW9uIHRoYXQgZGVhbHNcbiAgICAvLyB3aXRoIGJvdGggdGhlIGFzc2lnbm1lbnQgb2Ygc3R5bGluZyBhcyB3ZWxsIGFzIHN0YXRpYyBhdHRyaWJ1dGVzIHRvIHRoZSBob3N0XG4gICAgLy8gZWxlbWVudC4gVGhlIGluc3RydWN0aW9uIGJlbG93IHdpbGwgaW5zdHJ1Y3QgYWxsIGluaXRpYWwgc3R5bGluZyAoc3R5bGluZ1xuICAgIC8vIHRoYXQgaXMgaW5zaWRlIG9mIGEgaG9zdCBiaW5kaW5nIHdpdGhpbiBhIGRpcmVjdGl2ZS9jb21wb25lbnQpIHRvIGJlIGF0dGFjaGVkXG4gICAgLy8gdG8gdGhlIGhvc3QgZWxlbWVudCBhbG9uZ3NpZGUgYW55IG9mIHRoZSBwcm92aWRlZCBob3N0IGF0dHJpYnV0ZXMgdGhhdCB3ZXJlXG4gICAgLy8gY29sbGVjdGVkIGVhcmxpZXIuXG4gICAgY29uc3QgaG9zdEF0dHJzID0gY29udmVydEF0dHJpYnV0ZXNUb0V4cHJlc3Npb25zKGhvc3RCaW5kaW5nc01ldGFkYXRhLmF0dHJpYnV0ZXMpO1xuICAgIHN0eWxlQnVpbGRlci5hc3NpZ25Ib3N0QXR0cnMoaG9zdEF0dHJzLCBkZWZpbml0aW9uTWFwKTtcbiAgICBpZiAoc3R5bGVCdWlsZGVyLmhhc0JpbmRpbmdzKSB7XG4gICAgICAgIC8vIGZpbmFsbHkgZWFjaCBiaW5kaW5nIHRoYXQgd2FzIHJlZ2lzdGVyZWQgaW4gdGhlIHN0YXRlbWVudCBhYm92ZSB3aWxsIG5lZWQgdG8gYmUgYWRkZWQgdG9cbiAgICAgICAgLy8gdGhlIHVwZGF0ZSBibG9jayBvZiBhIGNvbXBvbmVudC9kaXJlY3RpdmUgdGVtcGxhdGVGbi9ob3N0QmluZGluZ3NGbiBzbyB0aGF0IHRoZSBiaW5kaW5nc1xuICAgICAgICAvLyBhcmUgZXZhbHVhdGVkIGFuZCB1cGRhdGVkIGZvciB0aGUgZWxlbWVudC5cbiAgICAgICAgc3R5bGVCdWlsZGVyLmJ1aWxkVXBkYXRlTGV2ZWxJbnN0cnVjdGlvbnMoZ2V0VmFsdWVDb252ZXJ0ZXIoKSkuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uY2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxzID0gW107XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24uY2FsbHMuZm9yRWFjaChjYWxsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc3VidHJhY3QgYSB2YWx1ZSBvZiBgMWAgaGVyZSBiZWNhdXNlIHRoZSBiaW5kaW5nIHNsb3Qgd2FzIGFscmVhZHkgYWxsb2NhdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoZSB0b3Agb2YgdGhpcyBtZXRob2Qgd2hlbiBhbGwgdGhlIGlucHV0IGJpbmRpbmdzIHdlcmUgY291bnRlZC5cbiAgICAgICAgICAgICAgICAgICAgdG90YWxIb3N0VmFyc0NvdW50ICs9XG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChjYWxsLmFsbG9jYXRlQmluZGluZ1Nsb3RzIC0gTUlOX1NUWUxJTkdfQklORElOR19TTE9UU19SRVFVSVJFRCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxzLnB1c2goY29udmVydFN0eWxpbmdDYWxsKGNhbGwsIGJpbmRpbmdDb250ZXh0LCBiaW5kaW5nRm4pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2goY2hhaW5lZEluc3RydWN0aW9uKGluc3RydWN0aW9uLnJlZmVyZW5jZSwgY2FsbHMpLnRvU3RtdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0b3RhbEhvc3RWYXJzQ291bnQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2hvc3RWYXJzJywgbGl0ZXJhbCh0b3RhbEhvc3RWYXJzQ291bnQpKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZVN0YXRlbWVudHMubGVuZ3RoID4gMCB8fCB1cGRhdGVTdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaG9zdEJpbmRpbmdzRm5OYW1lID0gbmFtZSA/IGAke25hbWV9X0hvc3RCaW5kaW5nc2AgOiBudWxsO1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIGlmIChjcmVhdGVTdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChyZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBDcmVhdGUgKi8sIGNyZWF0ZVN0YXRlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlU3RhdGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVuZGVyRmxhZ0NoZWNrSWZTdG10KDIgLyogVXBkYXRlICovLCB1cGRhdGVTdGF0ZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKFtuZXcgRm5QYXJhbShSRU5ERVJfRkxBR1MsIE5VTUJFUl9UWVBFKSwgbmV3IEZuUGFyYW0oQ09OVEVYVF9OQU1FLCBudWxsKV0sIHN0YXRlbWVudHMsIElORkVSUkVEX1RZUEUsIG51bGwsIGhvc3RCaW5kaW5nc0ZuTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYmluZGluZ0ZuKGltcGxpY2l0LCB2YWx1ZSkge1xuICAgIHJldHVybiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKG51bGwsIGltcGxpY2l0LCB2YWx1ZSwgJ2InLCAoKSA9PiBlcnJvcignVW5leHBlY3RlZCBpbnRlcnBvbGF0aW9uJykpO1xufVxuZnVuY3Rpb24gY29udmVydFN0eWxpbmdDYWxsKGNhbGwsIGJpbmRpbmdDb250ZXh0LCBiaW5kaW5nRm4pIHtcbiAgICByZXR1cm4gY2FsbC5wYXJhbXModmFsdWUgPT4gYmluZGluZ0ZuKGJpbmRpbmdDb250ZXh0LCB2YWx1ZSkuY3VyclZhbEV4cHIpO1xufVxuZnVuY3Rpb24gZ2V0QmluZGluZ05hbWVBbmRJbnN0cnVjdGlvbihiaW5kaW5nKSB7XG4gICAgbGV0IGJpbmRpbmdOYW1lID0gYmluZGluZy5uYW1lO1xuICAgIGxldCBpbnN0cnVjdGlvbjtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhbiBhdHRyIGJpbmRpbmcgb3IgYSBwcm9wZXJ0eSBiaW5kaW5nXG4gICAgY29uc3QgYXR0ck1hdGNoZXMgPSBiaW5kaW5nTmFtZS5tYXRjaChBVFRSX1JFR0VYKTtcbiAgICBpZiAoYXR0ck1hdGNoZXMpIHtcbiAgICAgICAgYmluZGluZ05hbWUgPSBhdHRyTWF0Y2hlc1sxXTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24gPSBJZGVudGlmaWVycyQxLmF0dHJpYnV0ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChiaW5kaW5nLmlzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBiaW5kaW5nTmFtZSA9IHByZXBhcmVTeW50aGV0aWNQcm9wZXJ0eU5hbWUoYmluZGluZ05hbWUpO1xuICAgICAgICAgICAgLy8gaG9zdCBiaW5kaW5ncyB0aGF0IGhhdmUgYSBzeW50aGV0aWMgcHJvcGVydHkgKGUuZy4gQGZvbykgc2hvdWxkIGFsd2F5cyBiZSByZW5kZXJlZFxuICAgICAgICAgICAgLy8gaW4gdGhlIGNvbnRleHQgb2YgdGhlIGNvbXBvbmVudCBhbmQgbm90IHRoZSBwYXJlbnQuIFRoZXJlZm9yZSB0aGVyZSBpcyBhIHNwZWNpYWxcbiAgICAgICAgICAgIC8vIGNvbXBhdGliaWxpdHkgaW5zdHJ1Y3Rpb24gYXZhaWxhYmxlIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IElkZW50aWZpZXJzJDEuc3ludGhldGljSG9zdFByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBJZGVudGlmaWVycyQxLmhvc3RQcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiaW5kaW5nTmFtZSwgaW5zdHJ1Y3Rpb24sIGlzQXR0cmlidXRlOiAhIWF0dHJNYXRjaGVzIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIb3N0TGlzdGVuZXJzKGV2ZW50QmluZGluZ3MsIG5hbWUpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICBjb25zdCBzeW50aGV0aWNMaXN0ZW5lcnMgPSBbXTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBldmVudEJpbmRpbmdzLmZvckVhY2goYmluZGluZyA9PiB7XG4gICAgICAgIGxldCBiaW5kaW5nTmFtZSA9IGJpbmRpbmcubmFtZSAmJiBzYW5pdGl6ZUlkZW50aWZpZXIoYmluZGluZy5uYW1lKTtcbiAgICAgICAgY29uc3QgYmluZGluZ0ZuTmFtZSA9IGJpbmRpbmcudHlwZSA9PT0gMSAvKiBBbmltYXRpb24gKi8gP1xuICAgICAgICAgICAgcHJlcGFyZVN5bnRoZXRpY0xpc3RlbmVyRnVuY3Rpb25OYW1lKGJpbmRpbmdOYW1lLCBiaW5kaW5nLnRhcmdldE9yUGhhc2UpIDpcbiAgICAgICAgICAgIGJpbmRpbmdOYW1lO1xuICAgICAgICBjb25zdCBoYW5kbGVyTmFtZSA9IG5hbWUgJiYgYmluZGluZ05hbWUgPyBgJHtuYW1lfV8ke2JpbmRpbmdGbk5hbWV9X0hvc3RCaW5kaW5nSGFuZGxlcmAgOiBudWxsO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBwcmVwYXJlRXZlbnRMaXN0ZW5lclBhcmFtZXRlcnMoQm91bmRFdmVudC5mcm9tUGFyc2VkRXZlbnQoYmluZGluZyksIGhhbmRsZXJOYW1lKTtcbiAgICAgICAgaWYgKGJpbmRpbmcudHlwZSA9PSAxIC8qIEFuaW1hdGlvbiAqLykge1xuICAgICAgICAgICAgc3ludGhldGljTGlzdGVuZXJzLnB1c2gocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoc3ludGhldGljTGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goY2hhaW5lZEluc3RydWN0aW9uKElkZW50aWZpZXJzJDEuc3ludGhldGljSG9zdExpc3RlbmVyLCBzeW50aGV0aWNMaXN0ZW5lcnMpLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGluc3RydWN0aW9ucy5wdXNoKGNoYWluZWRJbnN0cnVjdGlvbihJZGVudGlmaWVycyQxLmxpc3RlbmVyLCBsaXN0ZW5lcnMpLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucztcbn1cbmNvbnN0IEhPU1RfUkVHX0VYUCA9IC9eKD86XFxbKFteXFxdXSspXFxdKXwoPzpcXCgoW15cXCldKylcXCkpJC87XG5mdW5jdGlvbiBwYXJzZUhvc3RCaW5kaW5ncyhob3N0KSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHt9O1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICBjb25zdCBzcGVjaWFsQXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhvc3QpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaG9zdFtrZXldO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0ga2V5Lm1hdGNoKEhPU1RfUkVHX0VYUCk7XG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGEgZGlhZ25vc3RpYy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xhc3MgYmluZGluZyBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWxBdHRyaWJ1dGVzLmNsYXNzQXR0ciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IG1ha2UgdGhpcyBhIGRpYWdub3N0aWMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0eWxlIGJpbmRpbmcgbXVzdCBiZSBzdHJpbmdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsQXR0cmlidXRlcy5zdHlsZUF0dHIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGxpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzEgLyogQmluZGluZyAqL10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IG1ha2UgdGhpcyBhIGRpYWdub3N0aWMuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSBiaW5kaW5nIG11c3QgYmUgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzeW50aGV0aWMgcHJvcGVydGllcyAodGhlIG9uZXMgdGhhdCBoYXZlIGEgYEBgIGFzIGEgcHJlZml4KVxuICAgICAgICAgICAgLy8gYXJlIHN0aWxsIHRyZWF0ZWQgdGhlIHNhbWUgYXMgcmVndWxhciBwcm9wZXJ0aWVzLiBUaGVyZWZvcmVcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHBvaW50IGluIHN0b3JpbmcgdGhlbSBpbiBhIHNlcGFyYXRlIG1hcC5cbiAgICAgICAgICAgIHByb3BlcnRpZXNbbWF0Y2hlc1sxIC8qIEJpbmRpbmcgKi9dXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoZXNbMiAvKiBFdmVudCAqL10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IG1ha2UgdGhpcyBhIGRpYWdub3N0aWMuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdmVudCBiaW5kaW5nIG11c3QgYmUgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ZW5lcnNbbWF0Y2hlc1syIC8qIEV2ZW50ICovXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBhdHRyaWJ1dGVzLCBsaXN0ZW5lcnMsIHByb3BlcnRpZXMsIHNwZWNpYWxBdHRyaWJ1dGVzIH07XG59XG4vKipcbiAqIFZlcmlmaWVzIGhvc3QgYmluZGluZ3MgYW5kIHJldHVybnMgdGhlIGxpc3Qgb2YgZXJyb3JzIChpZiBhbnkpLiBFbXB0eSBhcnJheSBpbmRpY2F0ZXMgdGhhdCBhXG4gKiBnaXZlbiBzZXQgb2YgaG9zdCBiaW5kaW5ncyBoYXMgbm8gZXJyb3JzLlxuICpcbiAqIEBwYXJhbSBiaW5kaW5ncyBzZXQgb2YgaG9zdCBiaW5kaW5ncyB0byB2ZXJpZnkuXG4gKiBAcGFyYW0gc291cmNlU3BhbiBzb3VyY2Ugc3BhbiB3aGVyZSBob3N0IGJpbmRpbmdzIHdlcmUgZGVmaW5lZC5cbiAqIEByZXR1cm5zIGFycmF5IG9mIGVycm9ycyBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBzZXQgb2YgaG9zdCBiaW5kaW5ncy5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5SG9zdEJpbmRpbmdzKGJpbmRpbmdzLCBzb3VyY2VTcGFuKSB7XG4gICAgLy8gVE9ETzogYWJzdHJhY3Qgb3V0IGhvc3QgYmluZGluZ3MgdmVyaWZpY2F0aW9uIGxvZ2ljIGFuZCB1c2UgaXQgaW5zdGVhZCBvZlxuICAgIC8vIGNyZWF0aW5nIGV2ZW50cyBhbmQgcHJvcGVydGllcyBBU1RzIHRvIGRldGVjdCBlcnJvcnMgKEZXLTk5NilcbiAgICBjb25zdCBiaW5kaW5nUGFyc2VyID0gbWFrZUJpbmRpbmdQYXJzZXIoKTtcbiAgICBiaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoYmluZGluZ3MubGlzdGVuZXJzLCBzb3VyY2VTcGFuKTtcbiAgICBiaW5kaW5nUGFyc2VyLmNyZWF0ZUJvdW5kSG9zdFByb3BlcnRpZXMoYmluZGluZ3MucHJvcGVydGllcywgc291cmNlU3Bhbik7XG4gICAgcmV0dXJuIGJpbmRpbmdQYXJzZXIuZXJyb3JzO1xufVxuZnVuY3Rpb24gY29tcGlsZVN0eWxlcyhzdHlsZXMsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICBjb25zdCBzaGFkb3dDc3MgPSBuZXcgU2hhZG93Q3NzKCk7XG4gICAgcmV0dXJuIHN0eWxlcy5tYXAoc3R5bGUgPT4ge1xuICAgICAgICByZXR1cm4gc2hhZG93Q3NzLnNoaW1Dc3NUZXh0KHN0eWxlLCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEFuIGludGVyZmFjZSBmb3IgcmV0cmlldmluZyBkb2N1bWVudHMgYnkgVVJMIHRoYXQgdGhlIGNvbXBpbGVyIHVzZXMgdG9cbiAqIGxvYWQgdGVtcGxhdGVzLlxuICpcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MsIHJhdGhlciB0aGFuIGFuIGludGVyZmFjZSwgc28gdGhhdCBpdCBjYW4gYmUgdXNlZFxuICogYXMgaW5qZWN0aW9uIHRva2VuLlxuICovXG5jbGFzcyBSZXNvdXJjZUxvYWRlciB7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgQ29tcGlsZXJGYWNhZGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihqaXRFdmFsdWF0b3IgPSBuZXcgSml0RXZhbHVhdG9yKCkpIHtcbiAgICAgICAgdGhpcy5qaXRFdmFsdWF0b3IgPSBqaXRFdmFsdWF0b3I7XG4gICAgICAgIHRoaXMuRmFjdG9yeVRhcmdldCA9IEZhY3RvcnlUYXJnZXQkMTtcbiAgICAgICAgdGhpcy5SZXNvdXJjZUxvYWRlciA9IFJlc291cmNlTG9hZGVyO1xuICAgICAgICB0aGlzLmVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IG5ldyBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKTtcbiAgICB9XG4gICAgY29tcGlsZVBpcGUoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgbmFtZTogZmFjYWRlLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogMCxcbiAgICAgICAgICAgIGRlcHM6IG51bGwsXG4gICAgICAgICAgICBwaXBlTmFtZTogZmFjYWRlLnBpcGVOYW1lLFxuICAgICAgICAgICAgcHVyZTogZmFjYWRlLnB1cmUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvbXBpbGVQaXBlRnJvbU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgW10pO1xuICAgIH1cbiAgICBjb21waWxlUGlwZURlY2xhcmF0aW9uKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBjb252ZXJ0RGVjbGFyZVBpcGVGYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgY29uc3QgcmVzID0gY29tcGlsZVBpcGVGcm9tTWV0YWRhdGEobWV0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIFtdKTtcbiAgICB9XG4gICAgY29tcGlsZUluamVjdGFibGUoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBleHByZXNzaW9uLCBzdGF0ZW1lbnRzIH0gPSBjb21waWxlSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBuYW1lOiBmYWNhZGUubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIHR5cGVBcmd1bWVudENvdW50OiBmYWNhZGUudHlwZUFyZ3VtZW50Q291bnQsXG4gICAgICAgICAgICBwcm92aWRlZEluOiBjb21wdXRlUHJvdmlkZWRJbihmYWNhZGUucHJvdmlkZWRJbiksXG4gICAgICAgICAgICB1c2VDbGFzczogY29udmVydFRvUHJvdmlkZXJFeHByZXNzaW9uKGZhY2FkZSwgVVNFX0NMQVNTKSxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHdyYXBFeHByZXNzaW9uKGZhY2FkZSwgVVNFX0ZBQ1RPUlkpLFxuICAgICAgICAgICAgdXNlVmFsdWU6IGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihmYWNhZGUsIFVTRV9WQUxVRSksXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogY29udmVydFRvUHJvdmlkZXJFeHByZXNzaW9uKGZhY2FkZSwgVVNFX0VYSVNUSU5HKSxcbiAgICAgICAgICAgIGRlcHM6IChfYSA9IGZhY2FkZS5kZXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YSksXG4gICAgICAgIH0sIFxuICAgICAgICAvKiByZXNvbHZlRm9yd2FyZFJlZnMgKi8gdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgc3RhdGVtZW50cyk7XG4gICAgfVxuICAgIGNvbXBpbGVJbmplY3RhYmxlRGVjbGFyYXRpb24oYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBleHByZXNzaW9uLCBzdGF0ZW1lbnRzIH0gPSBjb21waWxlSW5qZWN0YWJsZSh7XG4gICAgICAgICAgICBuYW1lOiBmYWNhZGUudHlwZS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZShmYWNhZGUudHlwZSksXG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IDAsXG4gICAgICAgICAgICBwcm92aWRlZEluOiBjb21wdXRlUHJvdmlkZWRJbihmYWNhZGUucHJvdmlkZWRJbiksXG4gICAgICAgICAgICB1c2VDbGFzczogY29udmVydFRvUHJvdmlkZXJFeHByZXNzaW9uKGZhY2FkZSwgVVNFX0NMQVNTKSxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHdyYXBFeHByZXNzaW9uKGZhY2FkZSwgVVNFX0ZBQ1RPUlkpLFxuICAgICAgICAgICAgdXNlVmFsdWU6IGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihmYWNhZGUsIFVTRV9WQUxVRSksXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogY29udmVydFRvUHJvdmlkZXJFeHByZXNzaW9uKGZhY2FkZSwgVVNFX0VYSVNUSU5HKSxcbiAgICAgICAgICAgIGRlcHM6IChfYSA9IGZhY2FkZS5kZXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKGNvbnZlcnRSM0RlY2xhcmVEZXBlbmRlbmN5TWV0YWRhdGEpLFxuICAgICAgICB9LCBcbiAgICAgICAgLyogcmVzb2x2ZUZvcndhcmRSZWZzICovIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKGV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIHN0YXRlbWVudHMpO1xuICAgIH1cbiAgICBjb21waWxlSW5qZWN0b3IoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiBmYWNhZGUubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUucHJvdmlkZXJzKSxcbiAgICAgICAgICAgIGltcG9ydHM6IGZhY2FkZS5pbXBvcnRzLm1hcChpID0+IG5ldyBXcmFwcGVkTm9kZUV4cHIoaSkpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSBjb21waWxlSW5qZWN0b3IobWV0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIFtdKTtcbiAgICB9XG4gICAgY29tcGlsZUluamVjdG9yRGVjbGFyYXRpb24oYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvbnZlcnREZWNsYXJlSW5qZWN0b3JGYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgY29uc3QgcmVzID0gY29tcGlsZUluamVjdG9yKG1ldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBbXSk7XG4gICAgfVxuICAgIGNvbXBpbGVOZ01vZHVsZShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGFkamFjZW50VHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICBib290c3RyYXA6IGZhY2FkZS5ib290c3RyYXAubWFwKHdyYXBSZWZlcmVuY2UpLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBmYWNhZGUuZGVjbGFyYXRpb25zLm1hcCh3cmFwUmVmZXJlbmNlKSxcbiAgICAgICAgICAgIGltcG9ydHM6IGZhY2FkZS5pbXBvcnRzLm1hcCh3cmFwUmVmZXJlbmNlKSxcbiAgICAgICAgICAgIGV4cG9ydHM6IGZhY2FkZS5leHBvcnRzLm1hcCh3cmFwUmVmZXJlbmNlKSxcbiAgICAgICAgICAgIGVtaXRJbmxpbmU6IHRydWUsXG4gICAgICAgICAgICBjb250YWluc0ZvcndhcmREZWNsczogZmFsc2UsXG4gICAgICAgICAgICBzY2hlbWFzOiBmYWNhZGUuc2NoZW1hcyA/IGZhY2FkZS5zY2hlbWFzLm1hcCh3cmFwUmVmZXJlbmNlKSA6IG51bGwsXG4gICAgICAgICAgICBpZDogZmFjYWRlLmlkID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUuaWQpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gY29tcGlsZU5nTW9kdWxlKG1ldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBbXSk7XG4gICAgfVxuICAgIGNvbXBpbGVOZ01vZHVsZURlY2xhcmF0aW9uKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBjb21waWxlTmdNb2R1bGVEZWNsYXJhdGlvbkV4cHJlc3Npb24oZGVjbGFyYXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKGV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIFtdKTtcbiAgICB9XG4gICAgY29tcGlsZURpcmVjdGl2ZShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvbnZlcnREaXJlY3RpdmVGYWNhZGVUb01ldGFkYXRhKGZhY2FkZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBtZXRhKTtcbiAgICB9XG4gICAgY29tcGlsZURpcmVjdGl2ZURlY2xhcmF0aW9uKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHR5cGVTb3VyY2VTcGFuID0gdGhpcy5jcmVhdGVQYXJzZVNvdXJjZVNwYW4oJ0RpcmVjdGl2ZScsIGRlY2xhcmF0aW9uLnR5cGUubmFtZSwgc291cmNlTWFwVXJsKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvbnZlcnREZWNsYXJlRGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShkZWNsYXJhdGlvbiwgdHlwZVNvdXJjZVNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlRGlyZWN0aXZlRnJvbU1ldGEoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgbWV0YSk7XG4gICAgfVxuICAgIGNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50UG9vbCA9IG5ldyBDb25zdGFudFBvb2woKTtcbiAgICAgICAgY29uc3QgYmluZGluZ1BhcnNlciA9IG1ha2VCaW5kaW5nUGFyc2VyKCk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YWRhdGEobWV0YSwgY29uc3RhbnRQb29sLCBiaW5kaW5nUGFyc2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgY29uc3RhbnRQb29sLnN0YXRlbWVudHMpO1xuICAgIH1cbiAgICBjb21waWxlQ29tcG9uZW50KGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICAvLyBQYXJzZSB0aGUgdGVtcGxhdGUgYW5kIGNoZWNrIGZvciBlcnJvcnMuXG4gICAgICAgIGNvbnN0IHsgdGVtcGxhdGUsIGludGVycG9sYXRpb24gfSA9IHBhcnNlSml0VGVtcGxhdGUoZmFjYWRlLnRlbXBsYXRlLCBmYWNhZGUubmFtZSwgc291cmNlTWFwVXJsLCBmYWNhZGUucHJlc2VydmVXaGl0ZXNwYWNlcywgZmFjYWRlLmludGVycG9sYXRpb24pO1xuICAgICAgICAvLyBDb21waWxlIHRoZSBjb21wb25lbnQgbWV0YWRhdGEsIGluY2x1ZGluZyB0ZW1wbGF0ZSwgaW50byBhbiBleHByZXNzaW9uLlxuICAgICAgICBjb25zdCBtZXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZhY2FkZSksIGNvbnZlcnREaXJlY3RpdmVGYWNhZGVUb01ldGFkYXRhKGZhY2FkZSkpLCB7IHNlbGVjdG9yOiBmYWNhZGUuc2VsZWN0b3IgfHwgdGhpcy5lbGVtZW50U2NoZW1hUmVnaXN0cnkuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lKCksIHRlbXBsYXRlLCBkZWNsYXJhdGlvbkxpc3RFbWl0TW9kZTogMCAvKiBEaXJlY3QgKi8sIHN0eWxlczogWy4uLmZhY2FkZS5zdHlsZXMsIC4uLnRlbXBsYXRlLnN0eWxlc10sIGVuY2Fwc3VsYXRpb246IGZhY2FkZS5lbmNhcHN1bGF0aW9uLCBpbnRlcnBvbGF0aW9uLCBjaGFuZ2VEZXRlY3Rpb246IGZhY2FkZS5jaGFuZ2VEZXRlY3Rpb24sIGFuaW1hdGlvbnM6IGZhY2FkZS5hbmltYXRpb25zICE9IG51bGwgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS5hbmltYXRpb25zKSA6IG51bGwsIHZpZXdQcm92aWRlcnM6IGZhY2FkZS52aWV3UHJvdmlkZXJzICE9IG51bGwgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS52aWV3UHJvdmlkZXJzKSA6XG4gICAgICAgICAgICAgICAgbnVsbCwgcmVsYXRpdmVDb250ZXh0RmlsZVBhdGg6ICcnLCBpMThuVXNlRXh0ZXJuYWxJZHM6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IGppdEV4cHJlc3Npb25Tb3VyY2VNYXAgPSBgbmc6Ly8vJHtmYWNhZGUubmFtZX0uanNgO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQ29tcG9uZW50RnJvbU1ldGEoYW5ndWxhckNvcmVFbnYsIGppdEV4cHJlc3Npb25Tb3VyY2VNYXAsIG1ldGEpO1xuICAgIH1cbiAgICBjb21waWxlQ29tcG9uZW50RGVjbGFyYXRpb24oYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgY29uc3QgdHlwZVNvdXJjZVNwYW4gPSB0aGlzLmNyZWF0ZVBhcnNlU291cmNlU3BhbignQ29tcG9uZW50JywgZGVjbGFyYXRpb24udHlwZS5uYW1lLCBzb3VyY2VNYXBVcmwpO1xuICAgICAgICBjb25zdCBtZXRhID0gY29udmVydERlY2xhcmVDb21wb25lbnRGYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uLCB0eXBlU291cmNlU3Bhbiwgc291cmNlTWFwVXJsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUNvbXBvbmVudEZyb21NZXRhKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIG1ldGEpO1xuICAgIH1cbiAgICBjb21waWxlQ29tcG9uZW50RnJvbU1ldGEoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgbWV0YSkge1xuICAgICAgICBjb25zdCBjb25zdGFudFBvb2wgPSBuZXcgQ29uc3RhbnRQb29sKCk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdQYXJzZXIgPSBtYWtlQmluZGluZ1BhcnNlcihtZXRhLmludGVycG9sYXRpb24pO1xuICAgICAgICBjb25zdCByZXMgPSBjb21waWxlQ29tcG9uZW50RnJvbU1ldGFkYXRhKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGNvbnN0YW50UG9vbC5zdGF0ZW1lbnRzKTtcbiAgICB9XG4gICAgY29tcGlsZUZhY3RvcnkoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgbWV0YSkge1xuICAgICAgICBjb25zdCBmYWN0b3J5UmVzID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbih7XG4gICAgICAgICAgICBuYW1lOiBtZXRhLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKG1ldGEudHlwZSksXG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS50eXBlKSxcbiAgICAgICAgICAgIHR5cGVBcmd1bWVudENvdW50OiBtZXRhLnR5cGVBcmd1bWVudENvdW50LFxuICAgICAgICAgICAgZGVwczogY29udmVydFIzRGVwZW5kZW5jeU1ldGFkYXRhQXJyYXkobWV0YS5kZXBzKSxcbiAgICAgICAgICAgIHRhcmdldDogbWV0YS50YXJnZXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKGZhY3RvcnlSZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjdG9yeVJlcy5zdGF0ZW1lbnRzKTtcbiAgICB9XG4gICAgY29tcGlsZUZhY3RvcnlEZWNsYXJhdGlvbihhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvcnlSZXMgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6IG1ldGEudHlwZS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZShtZXRhLnR5cGUpLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKG1ldGEudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogMCxcbiAgICAgICAgICAgIGRlcHM6IEFycmF5LmlzQXJyYXkobWV0YS5kZXBzKSA/IG1ldGEuZGVwcy5tYXAoY29udmVydFIzRGVjbGFyZURlcGVuZGVuY3lNZXRhZGF0YSkgOlxuICAgICAgICAgICAgICAgIG1ldGEuZGVwcyxcbiAgICAgICAgICAgIHRhcmdldDogbWV0YS50YXJnZXQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKGZhY3RvcnlSZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjdG9yeVJlcy5zdGF0ZW1lbnRzKTtcbiAgICB9XG4gICAgY3JlYXRlUGFyc2VTb3VyY2VTcGFuKGtpbmQsIHR5cGVOYW1lLCBzb3VyY2VVcmwpIHtcbiAgICAgICAgcmV0dXJuIHIzSml0VHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZU5hbWUsIHNvdXJjZVVybCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpJVCBjb21waWxlcyBhbiBleHByZXNzaW9uIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIHRoYXQgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWYgdGhlIGRlZmluaXRpb24gd2hpY2ggd2lsbCBiZSBjb21waWxlZCBhbmQgZXhlY3V0ZWQgdG8gZ2V0IHRoZSB2YWx1ZSB0byBwYXRjaFxuICAgICAqIEBwYXJhbSBjb250ZXh0IGFuIG9iamVjdCBtYXAgb2YgQGFuZ3VsYXIvY29yZSBzeW1ib2wgbmFtZXMgdG8gc3ltYm9scyB3aGljaCB3aWxsIGJlIGF2YWlsYWJsZVxuICAgICAqIGluIHRoZSBjb250ZXh0IG9mIHRoZSBjb21waWxlZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHNvdXJjZVVybCBhIFVSTCB0byB1c2UgZm9yIHRoZSBzb3VyY2UgbWFwIG9mIHRoZSBjb21waWxlZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHByZVN0YXRlbWVudHMgYSBjb2xsZWN0aW9uIG9mIHN0YXRlbWVudHMgdGhhdCBzaG91bGQgYmUgZXZhbHVhdGVkIGJlZm9yZSB0aGUgZXhwcmVzc2lvbi5cbiAgICAgKi9cbiAgICBqaXRFeHByZXNzaW9uKGRlZiwgY29udGV4dCwgc291cmNlVXJsLCBwcmVTdGF0ZW1lbnRzKSB7XG4gICAgICAgIC8vIFRoZSBDb25zdGFudFBvb2wgbWF5IGNvbnRhaW4gU3RhdGVtZW50cyB3aGljaCBkZWNsYXJlIHZhcmlhYmxlcyB1c2VkIGluIHRoZSBmaW5hbCBleHByZXNzaW9uLlxuICAgICAgICAvLyBUaGVyZWZvcmUsIGl0cyBzdGF0ZW1lbnRzIG5lZWQgdG8gcHJlY2VkZSB0aGUgYWN0dWFsIEpJVCBvcGVyYXRpb24uIFRoZSBmaW5hbCBzdGF0ZW1lbnQgaXMgYVxuICAgICAgICAvLyBkZWNsYXJhdGlvbiBvZiAkZGVmIHdoaWNoIGlzIHNldCB0byB0aGUgZXhwcmVzc2lvbiBiZWluZyBjb21waWxlZC5cbiAgICAgICAgY29uc3Qgc3RhdGVtZW50cyA9IFtcbiAgICAgICAgICAgIC4uLnByZVN0YXRlbWVudHMsXG4gICAgICAgICAgICBuZXcgRGVjbGFyZVZhclN0bXQoJyRkZWYnLCBkZWYsIHVuZGVmaW5lZCwgU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5qaXRFdmFsdWF0b3IuZXZhbHVhdGVTdGF0ZW1lbnRzKHNvdXJjZVVybCwgc3RhdGVtZW50cywgbmV3IFIzSml0UmVmbGVjdG9yKGNvbnRleHQpLCAvKiBlbmFibGVTb3VyY2VNYXBzICovIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVzWyckZGVmJ107XG4gICAgfVxufVxuY29uc3QgVVNFX0NMQVNTID0gT2JqZWN0LmtleXMoeyB1c2VDbGFzczogbnVsbCB9KVswXTtcbmNvbnN0IFVTRV9GQUNUT1JZID0gT2JqZWN0LmtleXMoeyB1c2VGYWN0b3J5OiBudWxsIH0pWzBdO1xuY29uc3QgVVNFX1ZBTFVFID0gT2JqZWN0LmtleXMoeyB1c2VWYWx1ZTogbnVsbCB9KVswXTtcbmNvbnN0IFVTRV9FWElTVElORyA9IE9iamVjdC5rZXlzKHsgdXNlRXhpc3Rpbmc6IG51bGwgfSlbMF07XG5mdW5jdGlvbiBjb252ZXJ0VG9SM1F1ZXJ5TWV0YWRhdGEoZmFjYWRlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmFjYWRlKSwgeyBwcmVkaWNhdGU6IGNvbnZlcnRRdWVyeVByZWRpY2F0ZShmYWNhZGUucHJlZGljYXRlKSwgcmVhZDogZmFjYWRlLnJlYWQgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS5yZWFkKSA6IG51bGwsIHN0YXRpYzogZmFjYWRlLnN0YXRpYywgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHk6IGZhY2FkZS5lbWl0RGlzdGluY3RDaGFuZ2VzT25seSB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRRdWVyeURlY2xhcmF0aW9uVG9NZXRhZGF0YShkZWNsYXJhdGlvbikge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wZXJ0eU5hbWU6IGRlY2xhcmF0aW9uLnByb3BlcnR5TmFtZSxcbiAgICAgICAgZmlyc3Q6IChfYSA9IGRlY2xhcmF0aW9uLmZpcnN0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgcHJlZGljYXRlOiBjb252ZXJ0UXVlcnlQcmVkaWNhdGUoZGVjbGFyYXRpb24ucHJlZGljYXRlKSxcbiAgICAgICAgZGVzY2VuZGFudHM6IChfYiA9IGRlY2xhcmF0aW9uLmRlc2NlbmRhbnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSxcbiAgICAgICAgcmVhZDogZGVjbGFyYXRpb24ucmVhZCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbGFyYXRpb24ucmVhZCkgOiBudWxsLFxuICAgICAgICBzdGF0aWM6IChfYyA9IGRlY2xhcmF0aW9uLnN0YXRpYykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2UsXG4gICAgICAgIGVtaXREaXN0aW5jdENoYW5nZXNPbmx5OiAoX2QgPSBkZWNsYXJhdGlvbi5lbWl0RGlzdGluY3RDaGFuZ2VzT25seSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdHJ1ZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFF1ZXJ5UHJlZGljYXRlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHByZWRpY2F0ZSkgP1xuICAgICAgICAvLyBUaGUgcHJlZGljYXRlIGlzIGFuIGFycmF5IG9mIHN0cmluZ3Mgc28gcGFzcyBpdCB0aHJvdWdoLlxuICAgICAgICBwcmVkaWNhdGUgOlxuICAgICAgICAvLyBUaGUgcHJlZGljYXRlIGlzIGEgdHlwZSAtIGFzc3VtZSB0aGF0IHdlIHdpbGwgbmVlZCB0byB1bndyYXAgYW55IGBmb3J3YXJkUmVmKClgIGNhbGxzLlxuICAgICAgICBjcmVhdGVNYXlCZUZvcndhcmRSZWZFeHByZXNzaW9uKG5ldyBXcmFwcGVkTm9kZUV4cHIocHJlZGljYXRlKSwgMSAvKiBXcmFwcGVkICovKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREaXJlY3RpdmVGYWNhZGVUb01ldGFkYXRhKGZhY2FkZSkge1xuICAgIGNvbnN0IGlucHV0c0Zyb21NZXRhZGF0YSA9IHBhcnNlSW5wdXRPdXRwdXRzKGZhY2FkZS5pbnB1dHMgfHwgW10pO1xuICAgIGNvbnN0IG91dHB1dHNGcm9tTWV0YWRhdGEgPSBwYXJzZUlucHV0T3V0cHV0cyhmYWNhZGUub3V0cHV0cyB8fCBbXSk7XG4gICAgY29uc3QgcHJvcE1ldGFkYXRhID0gZmFjYWRlLnByb3BNZXRhZGF0YTtcbiAgICBjb25zdCBpbnB1dHNGcm9tVHlwZSA9IHt9O1xuICAgIGNvbnN0IG91dHB1dHNGcm9tVHlwZSA9IHt9O1xuICAgIGZvciAoY29uc3QgZmllbGQgaW4gcHJvcE1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChwcm9wTWV0YWRhdGEuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICBwcm9wTWV0YWRhdGFbZmllbGRdLmZvckVhY2goYW5uID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnB1dChhbm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0c0Zyb21UeXBlW2ZpZWxkXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm4uYmluZGluZ1Byb3BlcnR5TmFtZSA/IFthbm4uYmluZGluZ1Byb3BlcnR5TmFtZSwgZmllbGRdIDogZmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT3V0cHV0KGFubikpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0c0Zyb21UeXBlW2ZpZWxkXSA9IGFubi5iaW5kaW5nUHJvcGVydHlOYW1lIHx8IGZpZWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZhY2FkZSksIHsgdHlwZUFyZ3VtZW50Q291bnQ6IDAsIHR5cGVTb3VyY2VTcGFuOiBmYWNhZGUudHlwZVNvdXJjZVNwYW4sIHR5cGU6IHdyYXBSZWZlcmVuY2UoZmFjYWRlLnR5cGUpLCBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnR5cGUpLCBkZXBzOiBudWxsLCBob3N0OiBleHRyYWN0SG9zdEJpbmRpbmdzKGZhY2FkZS5wcm9wTWV0YWRhdGEsIGZhY2FkZS50eXBlU291cmNlU3BhbiwgZmFjYWRlLmhvc3QpLCBpbnB1dHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5wdXRzRnJvbU1ldGFkYXRhKSwgaW5wdXRzRnJvbVR5cGUpLCBvdXRwdXRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dHB1dHNGcm9tTWV0YWRhdGEpLCBvdXRwdXRzRnJvbVR5cGUpLCBxdWVyaWVzOiBmYWNhZGUucXVlcmllcy5tYXAoY29udmVydFRvUjNRdWVyeU1ldGFkYXRhKSwgcHJvdmlkZXJzOiBmYWNhZGUucHJvdmlkZXJzICE9IG51bGwgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS5wcm92aWRlcnMpIDogbnVsbCwgdmlld1F1ZXJpZXM6IGZhY2FkZS52aWV3UXVlcmllcy5tYXAoY29udmVydFRvUjNRdWVyeU1ldGFkYXRhKSwgZnVsbEluaGVyaXRhbmNlOiBmYWxzZSB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREZWNsYXJlRGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShkZWNsYXJhdGlvbiwgdHlwZVNvdXJjZVNwYW4pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRlY2xhcmF0aW9uLnR5cGUubmFtZSxcbiAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZShkZWNsYXJhdGlvbi50eXBlKSxcbiAgICAgICAgdHlwZVNvdXJjZVNwYW4sXG4gICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi50eXBlKSxcbiAgICAgICAgc2VsZWN0b3I6IChfYSA9IGRlY2xhcmF0aW9uLnNlbGVjdG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICBpbnB1dHM6IChfYiA9IGRlY2xhcmF0aW9uLmlucHV0cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30sXG4gICAgICAgIG91dHB1dHM6IChfYyA9IGRlY2xhcmF0aW9uLm91dHB1dHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LFxuICAgICAgICBob3N0OiBjb252ZXJ0SG9zdERlY2xhcmF0aW9uVG9NZXRhZGF0YShkZWNsYXJhdGlvbi5ob3N0KSxcbiAgICAgICAgcXVlcmllczogKChfZCA9IGRlY2xhcmF0aW9uLnF1ZXJpZXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFtdKS5tYXAoY29udmVydFF1ZXJ5RGVjbGFyYXRpb25Ub01ldGFkYXRhKSxcbiAgICAgICAgdmlld1F1ZXJpZXM6ICgoX2UgPSBkZWNsYXJhdGlvbi52aWV3UXVlcmllcykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogW10pLm1hcChjb252ZXJ0UXVlcnlEZWNsYXJhdGlvblRvTWV0YWRhdGEpLFxuICAgICAgICBwcm92aWRlcnM6IGRlY2xhcmF0aW9uLnByb3ZpZGVycyAhPT0gdW5kZWZpbmVkID8gbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi5wcm92aWRlcnMpIDpcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIGV4cG9ydEFzOiAoX2YgPSBkZWNsYXJhdGlvbi5leHBvcnRBcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbnVsbCxcbiAgICAgICAgdXNlc0luaGVyaXRhbmNlOiAoX2cgPSBkZWNsYXJhdGlvbi51c2VzSW5oZXJpdGFuY2UpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IGZhbHNlLFxuICAgICAgICBsaWZlY3ljbGU6IHsgdXNlc09uQ2hhbmdlczogKF9oID0gZGVjbGFyYXRpb24udXNlc09uQ2hhbmdlcykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogZmFsc2UgfSxcbiAgICAgICAgZGVwczogbnVsbCxcbiAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IDAsXG4gICAgICAgIGZ1bGxJbmhlcml0YW5jZTogZmFsc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRIb3N0RGVjbGFyYXRpb25Ub01ldGFkYXRhKGhvc3QgPSB7fSkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IGNvbnZlcnRPcGFxdWVWYWx1ZXNUb0V4cHJlc3Npb25zKChfYSA9IGhvc3QuYXR0cmlidXRlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pLFxuICAgICAgICBsaXN0ZW5lcnM6IChfYiA9IGhvc3QubGlzdGVuZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgcHJvcGVydGllczogKF9jID0gaG9zdC5wcm9wZXJ0aWVzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSxcbiAgICAgICAgc3BlY2lhbEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIGNsYXNzQXR0cjogaG9zdC5jbGFzc0F0dHJpYnV0ZSxcbiAgICAgICAgICAgIHN0eWxlQXR0cjogaG9zdC5zdHlsZUF0dHJpYnV0ZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydE9wYXF1ZVZhbHVlc1RvRXhwcmVzc2lvbnMob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG5ldyBXcmFwcGVkTm9kZUV4cHIob2JqW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29udmVydERlY2xhcmVDb21wb25lbnRGYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uLCB0eXBlU291cmNlU3Bhbiwgc291cmNlTWFwVXJsKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgY29uc3QgeyB0ZW1wbGF0ZSwgaW50ZXJwb2xhdGlvbiB9ID0gcGFyc2VKaXRUZW1wbGF0ZShkZWNsYXJhdGlvbi50ZW1wbGF0ZSwgZGVjbGFyYXRpb24udHlwZS5uYW1lLCBzb3VyY2VNYXBVcmwsIChfYSA9IGRlY2xhcmF0aW9uLnByZXNlcnZlV2hpdGVzcGFjZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLCBkZWNsYXJhdGlvbi5pbnRlcnBvbGF0aW9uKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb252ZXJ0RGVjbGFyZURpcmVjdGl2ZUZhY2FkZVRvTWV0YWRhdGEoZGVjbGFyYXRpb24sIHR5cGVTb3VyY2VTcGFuKSksIHsgdGVtcGxhdGUsIHN0eWxlczogKF9iID0gZGVjbGFyYXRpb24uc3R5bGVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSwgZGlyZWN0aXZlczogKChfYyA9IGRlY2xhcmF0aW9uLmNvbXBvbmVudHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKVxuICAgICAgICAgICAgLmNvbmNhdCgoX2QgPSBkZWNsYXJhdGlvbi5kaXJlY3RpdmVzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBbXSlcbiAgICAgICAgICAgIC5tYXAoY29udmVydFVzZWREaXJlY3RpdmVEZWNsYXJhdGlvblRvTWV0YWRhdGEpLCBwaXBlczogY29udmVydFVzZWRQaXBlc1RvTWV0YWRhdGEoZGVjbGFyYXRpb24ucGlwZXMpLCB2aWV3UHJvdmlkZXJzOiBkZWNsYXJhdGlvbi52aWV3UHJvdmlkZXJzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi52aWV3UHJvdmlkZXJzKSA6XG4gICAgICAgICAgICBudWxsLCBhbmltYXRpb25zOiBkZWNsYXJhdGlvbi5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGRlY2xhcmF0aW9uLmFuaW1hdGlvbnMpIDpcbiAgICAgICAgICAgIG51bGwsIGNoYW5nZURldGVjdGlvbjogKF9lID0gZGVjbGFyYXRpb24uY2hhbmdlRGV0ZWN0aW9uKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LCBlbmNhcHN1bGF0aW9uOiAoX2YgPSBkZWNsYXJhdGlvbi5lbmNhcHN1bGF0aW9uKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCwgaW50ZXJwb2xhdGlvbiwgZGVjbGFyYXRpb25MaXN0RW1pdE1vZGU6IDIgLyogQ2xvc3VyZVJlc29sdmVkICovLCByZWxhdGl2ZUNvbnRleHRGaWxlUGF0aDogJycsIGkxOG5Vc2VFeHRlcm5hbElkczogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVc2VkRGlyZWN0aXZlRGVjbGFyYXRpb25Ub01ldGFkYXRhKGRlY2xhcmF0aW9uKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0b3I6IGRlY2xhcmF0aW9uLnNlbGVjdG9yLFxuICAgICAgICB0eXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGRlY2xhcmF0aW9uLnR5cGUpLFxuICAgICAgICBpbnB1dHM6IChfYSA9IGRlY2xhcmF0aW9uLmlucHV0cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgIG91dHB1dHM6IChfYiA9IGRlY2xhcmF0aW9uLm91dHB1dHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICBleHBvcnRBczogKF9jID0gZGVjbGFyYXRpb24uZXhwb3J0QXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVc2VkUGlwZXNUb01ldGFkYXRhKGRlY2xhcmVkUGlwZXMpIHtcbiAgICBjb25zdCBwaXBlcyA9IG5ldyBNYXAoKTtcbiAgICBpZiAoZGVjbGFyZWRQaXBlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBwaXBlcztcbiAgICB9XG4gICAgZm9yIChjb25zdCBwaXBlTmFtZSBvZiBPYmplY3Qua2V5cyhkZWNsYXJlZFBpcGVzKSkge1xuICAgICAgICBjb25zdCBwaXBlVHlwZSA9IGRlY2xhcmVkUGlwZXNbcGlwZU5hbWVdO1xuICAgICAgICBwaXBlcy5zZXQocGlwZU5hbWUsIG5ldyBXcmFwcGVkTm9kZUV4cHIocGlwZVR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBpcGVzO1xufVxuZnVuY3Rpb24gcGFyc2VKaXRUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHlwZU5hbWUsIHNvdXJjZU1hcFVybCwgcHJlc2VydmVXaGl0ZXNwYWNlcywgaW50ZXJwb2xhdGlvbikge1xuICAgIGNvbnN0IGludGVycG9sYXRpb25Db25maWcgPSBpbnRlcnBvbGF0aW9uID8gSW50ZXJwb2xhdGlvbkNvbmZpZy5mcm9tQXJyYXkoaW50ZXJwb2xhdGlvbikgOiBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgIC8vIFBhcnNlIHRoZSB0ZW1wbGF0ZSBhbmQgY2hlY2sgZm9yIGVycm9ycy5cbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBzb3VyY2VNYXBVcmwsIHsgcHJlc2VydmVXaGl0ZXNwYWNlcywgaW50ZXJwb2xhdGlvbkNvbmZpZyB9KTtcbiAgICBpZiAocGFyc2VkLmVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBwYXJzZWQuZXJyb3JzLm1hcChlcnIgPT4gZXJyLnRvU3RyaW5nKCkpLmpvaW4oJywgJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3JzIGR1cmluZyBKSVQgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgZm9yICR7dHlwZU5hbWV9OiAke2Vycm9yc31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGVtcGxhdGU6IHBhcnNlZCwgaW50ZXJwb2xhdGlvbjogaW50ZXJwb2xhdGlvbkNvbmZpZyB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IHRoZSBleHByZXNzaW9uLCBpZiBwcmVzZW50IHRvIGFuIGBSM1Byb3ZpZGVyRXhwcmVzc2lvbmAuXG4gKlxuICogSW4gSklUIG1vZGUgd2UgZG8gbm90IHdhbnQgdGhlIGNvbXBpbGVyIHRvIHdyYXAgdGhlIGV4cHJlc3Npb24gaW4gYSBgZm9yd2FyZFJlZigpYCBjYWxsIGJlY2F1c2UsXG4gKiBpZiBpdCBpcyByZWZlcmVuY2luZyBhIHR5cGUgdGhhdCBoYXMgbm90IHlldCBiZWVuIGRlZmluZWQsIGl0IHdpbGwgaGF2ZSBhbHJlYWR5IGJlZW4gd3JhcHBlZCBpblxuICogYSBgZm9yd2FyZFJlZigpYCAtIGVpdGhlciBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIG9yIGR1cmluZyBwYXJ0aWFsLWNvbXBpbGF0aW9uLiBUaHVzIHdlIGNhblxuICogdXNlIGBGb3J3YXJkUmVmSGFuZGxpbmcuTm9uZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihvYmosIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1heUJlRm9yd2FyZFJlZkV4cHJlc3Npb24obmV3IFdyYXBwZWROb2RlRXhwcihvYmpbcHJvcGVydHldKSwgMCAvKiBOb25lICovKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcEV4cHJlc3Npb24ob2JqLCBwcm9wZXJ0eSkge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JhcHBlZE5vZGVFeHByKG9ialtwcm9wZXJ0eV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlUHJvdmlkZWRJbihwcm92aWRlZEluKSB7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHR5cGVvZiBwcm92aWRlZEluID09PSAnZnVuY3Rpb24nID8gbmV3IFdyYXBwZWROb2RlRXhwcihwcm92aWRlZEluKSA6XG4gICAgICAgIG5ldyBMaXRlcmFsRXhwcihwcm92aWRlZEluICE9PSBudWxsICYmIHByb3ZpZGVkSW4gIT09IHZvaWQgMCA/IHByb3ZpZGVkSW4gOiBudWxsKTtcbiAgICAvLyBTZWUgYGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbigpYCBmb3Igd2h5IHRoaXMgdXNlcyBgRm9yd2FyZFJlZkhhbmRsaW5nLk5vbmVgLlxuICAgIHJldHVybiBjcmVhdGVNYXlCZUZvcndhcmRSZWZFeHByZXNzaW9uKGV4cHJlc3Npb24sIDAgLyogTm9uZSAqLyk7XG59XG5mdW5jdGlvbiBjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGFBcnJheShmYWNhZGVzKSB7XG4gICAgcmV0dXJuIGZhY2FkZXMgPT0gbnVsbCA/IG51bGwgOiBmYWNhZGVzLm1hcChjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGEpO1xufVxuZnVuY3Rpb24gY29udmVydFIzRGVwZW5kZW5jeU1ldGFkYXRhKGZhY2FkZSkge1xuICAgIGNvbnN0IGlzQXR0cmlidXRlRGVwID0gZmFjYWRlLmF0dHJpYnV0ZSAhPSBudWxsOyAvLyBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBjb25zdCByYXdUb2tlbiA9IGZhY2FkZS50b2tlbiA9PT0gbnVsbCA/IG51bGwgOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50b2tlbik7XG4gICAgLy8gSW4gSklUIG1vZGUsIGlmIHRoZSBkZXAgaXMgYW4gYEBBdHRyaWJ1dGUoKWAgdGhlbiB3ZSB1c2UgdGhlIGF0dHJpYnV0ZSBuYW1lIGdpdmVuIGluXG4gICAgLy8gYGF0dHJpYnV0ZWAgcmF0aGVyIHRoYW4gdGhlIGB0b2tlbmAuXG4gICAgY29uc3QgdG9rZW4gPSBpc0F0dHJpYnV0ZURlcCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLmF0dHJpYnV0ZSkgOiByYXdUb2tlbjtcbiAgICByZXR1cm4gY3JlYXRlUjNEZXBlbmRlbmN5TWV0YWRhdGEodG9rZW4sIGlzQXR0cmlidXRlRGVwLCBmYWNhZGUuaG9zdCwgZmFjYWRlLm9wdGlvbmFsLCBmYWNhZGUuc2VsZiwgZmFjYWRlLnNraXBTZWxmKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSM0RlY2xhcmVEZXBlbmRlbmN5TWV0YWRhdGEoZmFjYWRlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBpc0F0dHJpYnV0ZURlcCA9IChfYSA9IGZhY2FkZS5hdHRyaWJ1dGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIGNvbnN0IHRva2VuID0gZmFjYWRlLnRva2VuID09PSBudWxsID8gbnVsbCA6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnRva2VuKTtcbiAgICByZXR1cm4gY3JlYXRlUjNEZXBlbmRlbmN5TWV0YWRhdGEodG9rZW4sIGlzQXR0cmlidXRlRGVwLCAoX2IgPSBmYWNhZGUuaG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsIChfYyA9IGZhY2FkZS5vcHRpb25hbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2UsIChfZCA9IGZhY2FkZS5zZWxmKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZSwgKF9lID0gZmFjYWRlLnNraXBTZWxmKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBmYWxzZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSM0RlcGVuZGVuY3lNZXRhZGF0YSh0b2tlbiwgaXNBdHRyaWJ1dGVEZXAsIGhvc3QsIG9wdGlvbmFsLCBzZWxmLCBza2lwU2VsZikge1xuICAgIC8vIElmIHRoZSBkZXAgaXMgYW4gYEBBdHRyaWJ1dGUoKWAgdGhlIGBhdHRyaWJ1dGVOYW1lVHlwZWAgb3VnaHQgdG8gYmUgdGhlIGB1bmtub3duYCB0eXBlLlxuICAgIC8vIEJ1dCB0eXBlcyBhcmUgbm90IGF2YWlsYWJsZSBhdCBydW50aW1lIHNvIHdlIGp1c3QgdXNlIGEgbGl0ZXJhbCBgXCI8dW5rbm93bj5cImAgc3RyaW5nIGFzIGEgZHVtbXlcbiAgICAvLyBtYXJrZXIuXG4gICAgY29uc3QgYXR0cmlidXRlTmFtZVR5cGUgPSBpc0F0dHJpYnV0ZURlcCA/IGxpdGVyYWwoJ3Vua25vd24nKSA6IG51bGw7XG4gICAgcmV0dXJuIHsgdG9rZW4sIGF0dHJpYnV0ZU5hbWVUeXBlLCBob3N0LCBvcHRpb25hbCwgc2VsZiwgc2tpcFNlbGYgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RIb3N0QmluZGluZ3MocHJvcE1ldGFkYXRhLCBzb3VyY2VTcGFuLCBob3N0KSB7XG4gICAgLy8gRmlyc3QgcGFyc2UgdGhlIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBtZXRhZGF0YS5cbiAgICBjb25zdCBiaW5kaW5ncyA9IHBhcnNlSG9zdEJpbmRpbmdzKGhvc3QgfHwge30pO1xuICAgIC8vIEFmdGVyIHRoYXQgY2hlY2sgaG9zdCBiaW5kaW5ncyBmb3IgZXJyb3JzXG4gICAgY29uc3QgZXJyb3JzID0gdmVyaWZ5SG9zdEJpbmRpbmdzKGJpbmRpbmdzLCBzb3VyY2VTcGFuKTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm1hcCgoZXJyb3IpID0+IGVycm9yLm1zZykuam9pbignXFxuJykpO1xuICAgIH1cbiAgICAvLyBOZXh0LCBsb29wIG92ZXIgdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCwgbG9va2luZyBmb3IgQEhvc3RCaW5kaW5nIGFuZCBASG9zdExpc3RlbmVyLlxuICAgIGZvciAoY29uc3QgZmllbGQgaW4gcHJvcE1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChwcm9wTWV0YWRhdGEuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICBwcm9wTWV0YWRhdGFbZmllbGRdLmZvckVhY2goYW5uID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIb3N0QmluZGluZyhhbm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBkZWNvcmF0b3IsIHdlIGtub3cgdGhhdCB0aGUgdmFsdWUgaXMgYSBjbGFzcyBtZW1iZXIuIEFsd2F5cyBhY2Nlc3MgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3VnaCBgdGhpc2Agc28gdGhhdCBmdXJ0aGVyIGRvd24gdGhlIGxpbmUgaXQgY2FuJ3QgYmUgY29uZnVzZWQgZm9yIGEgbGl0ZXJhbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyAoZS5nLiBpZiB0aGVyZSdzIGEgcHJvcGVydHkgY2FsbGVkIGB0cnVlYCkuXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLnByb3BlcnRpZXNbYW5uLmhvc3RQcm9wZXJ0eU5hbWUgfHwgZmllbGRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNhZmVQcm9wZXJ0eUFjY2Vzc1N0cmluZygndGhpcycsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNIb3N0TGlzdGVuZXIoYW5uKSkge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5ncy5saXN0ZW5lcnNbYW5uLmV2ZW50TmFtZSB8fCBmaWVsZF0gPSBgJHtmaWVsZH0oJHsoYW5uLmFyZ3MgfHwgW10pLmpvaW4oJywnKX0pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmluZGluZ3M7XG59XG5mdW5jdGlvbiBpc0hvc3RCaW5kaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm5nTWV0YWRhdGFOYW1lID09PSAnSG9zdEJpbmRpbmcnO1xufVxuZnVuY3Rpb24gaXNIb3N0TGlzdGVuZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubmdNZXRhZGF0YU5hbWUgPT09ICdIb3N0TGlzdGVuZXInO1xufVxuZnVuY3Rpb24gaXNJbnB1dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5uZ01ldGFkYXRhTmFtZSA9PT0gJ0lucHV0Jztcbn1cbmZ1bmN0aW9uIGlzT3V0cHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm5nTWV0YWRhdGFOYW1lID09PSAnT3V0cHV0Jztcbn1cbmZ1bmN0aW9uIHBhcnNlSW5wdXRPdXRwdXRzKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKChtYXAsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IFtmaWVsZCwgcHJvcGVydHldID0gdmFsdWUuc3BsaXQoJywnKS5tYXAocGllY2UgPT4gcGllY2UudHJpbSgpKTtcbiAgICAgICAgbWFwW2ZpZWxkXSA9IHByb3BlcnR5IHx8IGZpZWxkO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREZWNsYXJlUGlwZUZhY2FkZVRvTWV0YWRhdGEoZGVjbGFyYXRpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZGVjbGFyYXRpb24udHlwZS5uYW1lLFxuICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGRlY2xhcmF0aW9uLnR5cGUpLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbGFyYXRpb24udHlwZSksXG4gICAgICAgIHR5cGVBcmd1bWVudENvdW50OiAwLFxuICAgICAgICBwaXBlTmFtZTogZGVjbGFyYXRpb24ubmFtZSxcbiAgICAgICAgZGVwczogbnVsbCxcbiAgICAgICAgcHVyZTogKF9hID0gZGVjbGFyYXRpb24ucHVyZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydERlY2xhcmVJbmplY3RvckZhY2FkZVRvTWV0YWRhdGEoZGVjbGFyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBkZWNsYXJhdGlvbi50eXBlLm5hbWUsXG4gICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UoZGVjbGFyYXRpb24udHlwZSksXG4gICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi50eXBlKSxcbiAgICAgICAgcHJvdmlkZXJzOiBkZWNsYXJhdGlvbi5wcm92aWRlcnMgIT09IHVuZGVmaW5lZCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbGFyYXRpb24ucHJvdmlkZXJzKSA6XG4gICAgICAgICAgICBudWxsLFxuICAgICAgICBpbXBvcnRzOiBkZWNsYXJhdGlvbi5pbXBvcnRzICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgZGVjbGFyYXRpb24uaW1wb3J0cy5tYXAoaSA9PiBuZXcgV3JhcHBlZE5vZGVFeHByKGkpKSA6XG4gICAgICAgICAgICBbXSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcHVibGlzaEZhY2FkZShnbG9iYWwpIHtcbiAgICBjb25zdCBuZyA9IGdsb2JhbC5uZyB8fCAoZ2xvYmFsLm5nID0ge30pO1xuICAgIG5nLsm1Y29tcGlsZXJGYWNhZGUgPSBuZXcgQ29tcGlsZXJGYWNhZGVJbXBsKCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgVkVSU0lPTiA9IG5ldyBWZXJzaW9uKCcxMy4xLjMnKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBDb21waWxlckNvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoeyBkZWZhdWx0RW5jYXBzdWxhdGlvbiA9IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLCB1c2VKaXQgPSB0cnVlLCBqaXREZXZNb2RlID0gZmFsc2UsIG1pc3NpbmdUcmFuc2xhdGlvbiA9IG51bGwsIHByZXNlcnZlV2hpdGVzcGFjZXMsIHN0cmljdEluamVjdGlvblBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVuY2Fwc3VsYXRpb24gPSBkZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgdGhpcy51c2VKaXQgPSAhIXVzZUppdDtcbiAgICAgICAgdGhpcy5qaXREZXZNb2RlID0gISFqaXREZXZNb2RlO1xuICAgICAgICB0aGlzLm1pc3NpbmdUcmFuc2xhdGlvbiA9IG1pc3NpbmdUcmFuc2xhdGlvbjtcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2VzID0gcHJlc2VydmVXaGl0ZXNwYWNlc0RlZmF1bHQobm9VbmRlZmluZWQocHJlc2VydmVXaGl0ZXNwYWNlcykpO1xuICAgICAgICB0aGlzLnN0cmljdEluamVjdGlvblBhcmFtZXRlcnMgPSBzdHJpY3RJbmplY3Rpb25QYXJhbWV0ZXJzID09PSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZXNlcnZlV2hpdGVzcGFjZXNEZWZhdWx0KHByZXNlcnZlV2hpdGVzcGFjZXNPcHRpb24sIGRlZmF1bHRTZXR0aW5nID0gZmFsc2UpIHtcbiAgICByZXR1cm4gcHJlc2VydmVXaGl0ZXNwYWNlc09wdGlvbiA9PT0gbnVsbCA/IGRlZmF1bHRTZXR0aW5nIDogcHJlc2VydmVXaGl0ZXNwYWNlc09wdGlvbjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBfSTE4Tl9BVFRSID0gJ2kxOG4nO1xuY29uc3QgX0kxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xuY29uc3QgX0kxOE5fQ09NTUVOVF9QUkVGSVhfUkVHRVhQID0gL15pMThuOj8vO1xuY29uc3QgTUVBTklOR19TRVBBUkFUT1IgPSAnfCc7XG5jb25zdCBJRF9TRVBBUkFUT1IgPSAnQEAnO1xubGV0IGkxOG5Db21tZW50c1dhcm5lZCA9IGZhbHNlO1xuLyoqXG4gKiBFeHRyYWN0IHRyYW5zbGF0YWJsZSBtZXNzYWdlcyBmcm9tIGFuIGh0bWwgQVNUXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNZXNzYWdlcyhub2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZywgaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBfVmlzaXRvcihpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpO1xuICAgIHJldHVybiB2aXNpdG9yLmV4dHJhY3Qobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpO1xufVxuZnVuY3Rpb24gbWVyZ2VUcmFuc2xhdGlvbnMobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZywgaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBfVmlzaXRvcihpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpO1xuICAgIHJldHVybiB2aXNpdG9yLm1lcmdlKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcpO1xufVxuY2xhc3MgRXh0cmFjdGlvblJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZXMsIGVycm9ycykge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXM7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbn1cbnZhciBfVmlzaXRvck1vZGU7XG4oZnVuY3Rpb24gKF9WaXNpdG9yTW9kZSkge1xuICAgIF9WaXNpdG9yTW9kZVtfVmlzaXRvck1vZGVbXCJFeHRyYWN0XCJdID0gMF0gPSBcIkV4dHJhY3RcIjtcbiAgICBfVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlW1wiTWVyZ2VcIl0gPSAxXSA9IFwiTWVyZ2VcIjtcbn0pKF9WaXNpdG9yTW9kZSB8fCAoX1Zpc2l0b3JNb2RlID0ge30pKTtcbi8qKlxuICogVGhpcyBWaXNpdG9yIGlzIHVzZWQ6XG4gKiAxLiB0byBleHRyYWN0IGFsbCB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3MgZnJvbSBhbiBodG1sIEFTVCAoc2VlIGBleHRyYWN0KClgKSxcbiAqIDIuIHRvIHJlcGxhY2UgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIHdpdGggdGhlIGFjdHVhbCB0cmFuc2xhdGlvbnMgKHNlZSBgbWVyZ2UoKWApXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIF9WaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihfaW1wbGljaXRUYWdzLCBfaW1wbGljaXRBdHRycykge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFRhZ3MgPSBfaW1wbGljaXRUYWdzO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBtZXNzYWdlcyBmcm9tIHRoZSB0cmVlXG4gICAgICovXG4gICAgZXh0cmFjdChub2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB0aGlzLl9pbml0KF9WaXNpdG9yTW9kZS5FeHRyYWN0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUudmlzaXQodGhpcywgbnVsbCkpO1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCAnVW5jbG9zZWQgYmxvY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV4dHJhY3Rpb25SZXN1bHQodGhpcy5fbWVzc2FnZXMsIHRoaXMuX2Vycm9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0cmVlIHdoZXJlIGFsbCB0cmFuc2xhdGFibGUgbm9kZXMgYXJlIHRyYW5zbGF0ZWRcbiAgICAgKi9cbiAgICBtZXJnZShub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLk1lcmdlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25zID0gdHJhbnNsYXRpb25zO1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSBzaW5nbGUgZmFrZSByb290IGVsZW1lbnRcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IG5ldyBFbGVtZW50KCd3cmFwcGVyJywgW10sIG5vZGVzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlZE5vZGUgPSB3cmFwcGVyLnZpc2l0KHRoaXMsIG51bGwpO1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdLCAnVW5jbG9zZWQgYmxvY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdCh0cmFuc2xhdGVkTm9kZS5jaGlsZHJlbiwgdGhpcy5fZXJyb3JzKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gUGFyc2UgY2FzZXMgZm9yIHRyYW5zbGF0YWJsZSBodG1sIGF0dHJpYnV0ZXNcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHZpc2l0QWxsKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiwgY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXhwYW5zaW9uQ2FzZShpY3VDYXNlLnZhbHVlLCBleHByZXNzaW9uLCBpY3VDYXNlLnNvdXJjZVNwYW4sIGljdUNhc2UudmFsdWVTb3VyY2VTcGFuLCBpY3VDYXNlLmV4cFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uKGljdSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4oaWN1KTtcbiAgICAgICAgY29uc3Qgd2FzSW5JY3UgPSB0aGlzLl9pbkljdTtcbiAgICAgICAgaWYgKCF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgLy8gbmVzdGVkIElDVSBtZXNzYWdlcyBzaG91bGQgbm90IGJlIGV4dHJhY3RlZCBidXQgdG9wLWxldmVsIHRyYW5zbGF0ZWQgYXMgYSB3aG9sZVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZShbaWN1XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbkljdSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FzZXMgPSB2aXNpdEFsbCh0aGlzLCBpY3UuY2FzZXMsIGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICBpY3UgPSBuZXcgRXhwYW5zaW9uKGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VzLCBpY3Uuc291cmNlU3BhbiwgaWN1LnN3aXRjaFZhbHVlU291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5JY3UgPSB3YXNJbkljdTtcbiAgICAgICAgcmV0dXJuIGljdTtcbiAgICB9XG4gICAgdmlzaXRDb21tZW50KGNvbW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaXNPcGVuaW5nID0gX2lzT3BlbmluZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgIGlmIChpc09wZW5pbmcgJiYgdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbW1lbnQsICdDb3VsZCBub3Qgc3RhcnQgYSBibG9jayBpbnNpZGUgYSB0cmFuc2xhdGFibGUgc2VjdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQ2xvc2luZyA9IF9pc0Nsb3NpbmdDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICBpZiAoaXNDbG9zaW5nICYmICF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ1RyeWluZyB0byBjbG9zZSBhbiB1bm9wZW5lZCBibG9jaycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5JMThuTm9kZSAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPcGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgZnJvbSB2NSB5b3Ugc2hvdWxkIHVzZSA8bmctY29udGFpbmVyIGkxOG4+IGluc3RlYWQgb2YgaTE4biBjb21tZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWkxOG5Db21tZW50c1dhcm5lZCAmJiBjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaTE4bkNvbW1lbnRzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBjb21tZW50LnNvdXJjZVNwYW4uZGV0YWlscyA/IGAsICR7Y29tbWVudC5zb3VyY2VTcGFuLmRldGFpbHN9YCA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhvY29tYmUpOiB1c2UgYSBsb2cgc2VydmljZSBvbmNlIHRoZXJlIGlzIGEgcHVibGljIG9uZSBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSTE4biBjb21tZW50cyBhcmUgZGVwcmVjYXRlZCwgdXNlIGFuIDxuZy1jb250YWluZXI+IGVsZW1lbnQgaW5zdGVhZCAoJHtjb21tZW50LnNvdXJjZVNwYW4uc3RhcnR9JHtkZXRhaWxzfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrU3RhcnREZXB0aCA9IHRoaXMuX2RlcHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja0NoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrTWVhbmluZ0FuZERlc2MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC52YWx1ZS5yZXBsYWNlKF9JMThOX0NPTU1FTlRfUFJFRklYX1JFR0VYUCwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ2xvc2luZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oY29tbWVudCwgdGhpcy5fYmxvY2tDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UodGhpcy5fYmxvY2tDaGlsZHJlbiwgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXJnZSBhdHRyaWJ1dGVzIGluIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMuX3RyYW5zbGF0ZU1lc3NhZ2UoY29tbWVudCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRBbGwodGhpcywgbm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0kxOE4gYmxvY2tzIHNob3VsZCBub3QgY3Jvc3MgZWxlbWVudCBib3VuZGFyaWVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4odGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLl9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4oZWwpO1xuICAgICAgICB0aGlzLl9kZXB0aCsrO1xuICAgICAgICBjb25zdCB3YXNJbkkxOG5Ob2RlID0gdGhpcy5faW5JMThuTm9kZTtcbiAgICAgICAgY29uc3Qgd2FzSW5JbXBsaWNpdE5vZGUgPSB0aGlzLl9pbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IHRyYW5zbGF0ZWRDaGlsZE5vZGVzID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBFeHRyYWN0OlxuICAgICAgICAvLyAtIHRvcCBsZXZlbCBub2RlcyB3aXRoIHRoZSAoaW1wbGljaXQpIFwiaTE4blwiIGF0dHJpYnV0ZSBpZiBub3QgYWxyZWFkeSBpbiBhIHNlY3Rpb25cbiAgICAgICAgLy8gLSBJQ1UgbWVzc2FnZXNcbiAgICAgICAgY29uc3QgaTE4bkF0dHIgPSBfZ2V0STE4bkF0dHIoZWwpO1xuICAgICAgICBjb25zdCBpMThuTWV0YSA9IGkxOG5BdHRyID8gaTE4bkF0dHIudmFsdWUgOiAnJztcbiAgICAgICAgY29uc3QgaXNJbXBsaWNpdCA9IHRoaXMuX2ltcGxpY2l0VGFncy5zb21lKHRhZyA9PiBlbC5uYW1lID09PSB0YWcpICYmICF0aGlzLl9pbkljdSAmJlxuICAgICAgICAgICAgIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uO1xuICAgICAgICBjb25zdCBpc1RvcExldmVsSW1wbGljaXQgPSAhd2FzSW5JbXBsaWNpdE5vZGUgJiYgaXNJbXBsaWNpdDtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZSB8fCBpc0ltcGxpY2l0O1xuICAgICAgICBpZiAoIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uICYmICF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgaWYgKGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9hZGRNZXNzYWdlKGVsLmNoaWxkcmVuLCBpMThuTWV0YSk7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZENoaWxkTm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGVsLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09IF9WaXNpdG9yTW9kZS5FeHRyYWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNUcmFuc2xhdGFibGUgPSBpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJhbnNsYXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uKGVsLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsICdDb3VsZCBub3QgbWFyayBhbiBlbGVtZW50IGFzIHRyYW5zbGF0YWJsZSBpbnNpZGUgYSB0cmFuc2xhdGFibGUgc2VjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBEZXNjZW5kIGludG8gY2hpbGQgbm9kZXMgZm9yIGV4dHJhY3Rpb25cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgY29uc3QgdmlzaXROb2RlcyA9IHRyYW5zbGF0ZWRDaGlsZE5vZGVzIHx8IGVsLmNoaWxkcmVuO1xuICAgICAgICAgICAgdmlzaXROb2Rlcy5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNpdGVkID0gY2hpbGQudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWQgJiYgIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBhZGQgdGhlIGNoaWxkcmVuIGZyb20gdHJhbnNsYXRhYmxlIHNlY3Rpb25zICg9IGkxOG4gYmxvY2tzIGhlcmUpXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgd2lsbCBiZSBhZGRlZCBsYXRlciBpbiB0aGlzIGxvb3Agd2hlbiB0aGUgYmxvY2sgY2xvc2VzIChpLmUuIG9uIGA8IS0tIC9pMThuIC0tPmApXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBjaGlsZE5vZGVzLmNvbmNhdCh2aXNpdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXNpdEF0dHJpYnV0ZXNPZihlbCk7XG4gICAgICAgIHRoaXMuX2RlcHRoLS07XG4gICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSB3YXNJbkkxOG5Ob2RlO1xuICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IHdhc0luSW1wbGljaXROb2RlO1xuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVkQXR0cnMgPSB0aGlzLl90cmFuc2xhdGVBdHRyaWJ1dGVzKGVsKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChlbC5uYW1lLCB0cmFuc2xhdGVkQXR0cnMsIGNoaWxkTm9kZXMsIGVsLnNvdXJjZVNwYW4sIGVsLnN0YXJ0U291cmNlU3BhbiwgZWwuZW5kU291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVhY2hhYmxlIGNvZGUnKTtcbiAgICB9XG4gICAgX2luaXQobW9kZSwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX2luSWN1ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZSA9IGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeShpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgLy8gbG9va3MgZm9yIHRyYW5zbGF0YWJsZSBhdHRyaWJ1dGVzXG4gICAgX3Zpc2l0QXR0cmlidXRlc09mKGVsKSB7XG4gICAgICAgIGNvbnN0IGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlID0ge307XG4gICAgICAgIGNvbnN0IGltcGxpY2l0QXR0ck5hbWVzID0gdGhpcy5faW1wbGljaXRBdHRyc1tlbC5uYW1lXSB8fCBbXTtcbiAgICAgICAgZWwuYXR0cnMuZmlsdGVyKGF0dHIgPT4gYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKVxuICAgICAgICAgICAgLmZvckVhY2goYXR0ciA9PiBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgYXR0ci52YWx1ZSk7XG4gICAgICAgIGVsLmF0dHJzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lIGluIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZShbYXR0cl0sIGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlW2F0dHIubmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW1wbGljaXRBdHRyTmFtZXMuc29tZShuYW1lID0+IGF0dHIubmFtZSA9PT0gbmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKFthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBhZGQgYSB0cmFuc2xhdGFibGUgbWVzc2FnZVxuICAgIF9hZGRNZXNzYWdlKGFzdCwgbXNnTWV0YSkge1xuICAgICAgICBpZiAoYXN0Lmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICBhc3QubGVuZ3RoID09IDEgJiYgYXN0WzBdIGluc3RhbmNlb2YgQXR0cmlidXRlICYmICFhc3RbMF0udmFsdWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjcmVhdGUgZW1wdHkgbWVzc2FnZXNcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkIH0gPSBfcGFyc2VNZXNzYWdlTWV0YShtc2dNZXRhKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlKGFzdCwgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIC8vIFRyYW5zbGF0ZXMgdGhlIGdpdmVuIG1lc3NhZ2UgZ2l2ZW4gdGhlIGBUcmFuc2xhdGlvbkJ1bmRsZWBcbiAgICAvLyBUaGlzIGlzIHVzZWQgZm9yIHRyYW5zbGF0aW5nIGVsZW1lbnRzIC8gYmxvY2tzIC0gc2VlIGBfdHJhbnNsYXRlQXR0cmlidXRlc2AgZm9yIGF0dHJpYnV0ZXNcbiAgICAvLyBuby1vcCB3aGVuIGNhbGxlZCBpbiBleHRyYWN0aW9uIG1vZGUgKHJldHVybnMgW10pXG4gICAgX3RyYW5zbGF0ZU1lc3NhZ2UoZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgJiYgdGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMuX3RyYW5zbGF0aW9ucy5nZXQobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlbCwgYFRyYW5zbGF0aW9uIHVuYXZhaWxhYmxlIGZvciBtZXNzYWdlIGlkPVwiJHt0aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyB0cmFuc2xhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgYW4gZWxlbWVudCBhbmQgcmVtb3ZlIGkxOG4gc3BlY2lmaWMgYXR0cmlidXRlc1xuICAgIF90cmFuc2xhdGVBdHRyaWJ1dGVzKGVsKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBlbC5hdHRycztcbiAgICAgICAgY29uc3QgaTE4blBhcnNlZE1lc3NhZ2VNZXRhID0ge307XG4gICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICBpMThuUGFyc2VkTWVzc2FnZU1ldGFbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgICAgICAgICAgX3BhcnNlTWVzc2FnZU1ldGEoYXR0ci52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0cmFuc2xhdGVkQXR0cmlidXRlcyA9IFtdO1xuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IF9JMThOX0FUVFIgfHwgYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgaTE4biBzcGVjaWZpYyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUgJiYgYXR0ci52YWx1ZSAhPSAnJyAmJiBpMThuUGFyc2VkTWVzc2FnZU1ldGEuaGFzT3duUHJvcGVydHkoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkIH0gPSBpMThuUGFyc2VkTWVzc2FnZU1ldGFbYXR0ci5uYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoW2F0dHJdLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5fdHJhbnNsYXRpb25zLmdldChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQXR0cmlidXRlcy5wdXNoKG5ldyBBdHRyaWJ1dGUoYXR0ci5uYW1lLCAnJywgYXR0ci5zb3VyY2VTcGFuLCB1bmRlZmluZWQgLyoga2V5U3BhbiAqLywgdW5kZWZpbmVkIC8qIHZhbHVlU3BhbiAqLywgdW5kZWZpbmVkIC8qIHZhbHVlVG9rZW5zICovLCB1bmRlZmluZWQgLyogaTE4biAqLykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVzWzBdIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub2Rlc1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2gobmV3IEF0dHJpYnV0ZShhdHRyLm5hbWUsIHZhbHVlLCBhdHRyLnNvdXJjZVNwYW4sIHVuZGVmaW5lZCAvKiBrZXlTcGFuICovLCB1bmRlZmluZWQgLyogdmFsdWVTcGFuICovLCB1bmRlZmluZWQgLyogdmFsdWVUb2tlbnMgKi8sIHVuZGVmaW5lZCAvKiBpMThuICovKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlbCwgYFVuZXhwZWN0ZWQgdHJhbnNsYXRpb24gZm9yIGF0dHJpYnV0ZSBcIiR7YXR0ci5uYW1lfVwiIChpZD1cIiR7aWQgfHwgdGhpcy5fdHJhbnNsYXRpb25zLmRpZ2VzdChtZXNzYWdlKX1cIilgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsIGBUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgYXR0cmlidXRlIFwiJHthdHRyLm5hbWV9XCIgKGlkPVwiJHtpZCB8fCB0aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpfVwiKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRlZEF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgbm9kZSBhcyBhIGNoaWxkIG9mIHRoZSBibG9jayB3aGVuOlxuICAgICAqIC0gd2UgYXJlIGluIGEgYmxvY2ssXG4gICAgICogLSB3ZSBhcmUgbm90IGluc2lkZSBhIElDVSBtZXNzYWdlICh0aG9zZSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5KSxcbiAgICAgKiAtIHRoZSBub2RlIGlzIGEgXCJkaXJlY3QgY2hpbGRcIiBvZiB0aGUgYmxvY2tcbiAgICAgKi9cbiAgICBfbWF5QmVBZGRCbG9ja0NoaWxkcmVuKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrICYmICF0aGlzLl9pbkljdSAmJiB0aGlzLl9kZXB0aCA9PSB0aGlzLl9ibG9ja1N0YXJ0RGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrQ2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgc3RhcnQgb2YgYSBzZWN0aW9uLCBzZWUgYF9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb25gXG4gICAgICovXG4gICAgX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2RlLCAnVW5leHBlY3RlZCBzZWN0aW9uIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdGhpcy5fbWVzc2FnZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgdHJhbnNsYXRhYmxlIHNlY3Rpb24gY291bGQgYmU6XG4gICAgICogLSB0aGUgY29udGVudCBvZiB0cmFuc2xhdGFibGUgZWxlbWVudCxcbiAgICAgKiAtIG5vZGVzIGJldHdlZW4gYDwhLS0gaTE4biAtLT5gIGFuZCBgPCEtLSAvaTE4biAtLT5gIGNvbW1lbnRzXG4gICAgICovXG4gICAgZ2V0IF9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVybWluYXRlcyBhIHNlY3Rpb24uXG4gICAgICpcbiAgICAgKiBJZiBhIHNlY3Rpb24gaGFzIG9ubHkgb25lIHNpZ25pZmljYW50IGNoaWxkcmVuIChjb21tZW50cyBub3Qgc2lnbmlmaWNhbnQpIHRoZW4gd2Ugc2hvdWxkIG5vdFxuICAgICAqIGtlZXAgdGhlIG1lc3NhZ2UgZnJvbSB0aGlzIGNoaWxkcmVuOlxuICAgICAqXG4gICAgICogYDxwIGkxOG49XCJtZWFuaW5nfGRlc2NyaXB0aW9uXCI+e0lDVSBtZXNzYWdlfTwvcD5gIHdvdWxkIHByb2R1Y2UgdHdvIG1lc3NhZ2VzOlxuICAgICAqIC0gb25lIGZvciB0aGUgPHA+IGNvbnRlbnQgd2l0aCBtZWFuaW5nIGFuZCBkZXNjcmlwdGlvbixcbiAgICAgKiAtIGFub3RoZXIgb25lIGZvciB0aGUgSUNVIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGNhc2UgdGhlIGxhc3QgbWVzc2FnZSBpcyBkaXNjYXJkZWQgYXMgaXQgY29udGFpbnMgbGVzcyBpbmZvcm1hdGlvbiAodGhlIEFTVCBpc1xuICAgICAqIG90aGVyd2lzZSBpZGVudGljYWwpLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHdlIHNob3VsZCBzdGlsbCBrZWVwIG1lc3NhZ2VzIGV4dHJhY3RlZCBmcm9tIGF0dHJpYnV0ZXMgaW5zaWRlIHRoZSBzZWN0aW9uIChpZSBpbiB0aGVcbiAgICAgKiBJQ1UgbWVzc2FnZSBoZXJlKVxuICAgICAqL1xuICAgIF9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24obm9kZSwgZGlyZWN0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBlbmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydDtcbiAgICAgICAgY29uc3Qgc2lnbmlmaWNhbnRDaGlsZHJlbiA9IGRpcmVjdENoaWxkcmVuLnJlZHVjZSgoY291bnQsIG5vZGUpID0+IGNvdW50ICsgKG5vZGUgaW5zdGFuY2VvZiBDb21tZW50ID8gMCA6IDEpLCAwKTtcbiAgICAgICAgaWYgKHNpZ25pZmljYW50Q2hpbGRyZW4gPT0gMSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX21lc3NhZ2VzLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnRJbmRleDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fbWVzc2FnZXNbaV0ubm9kZXM7XG4gICAgICAgICAgICAgICAgaWYgKCEoYXN0Lmxlbmd0aCA9PSAxICYmIGFzdFswXSBpbnN0YW5jZW9mIFRleHQkMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVzc2FnZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX3JlcG9ydEVycm9yKG5vZGUsIG1zZykge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbXNnKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2lzT3BlbmluZ0NvbW1lbnQobikge1xuICAgIHJldHVybiAhIShuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUuc3RhcnRzV2l0aCgnaTE4bicpKTtcbn1cbmZ1bmN0aW9uIF9pc0Nsb3NpbmdDb21tZW50KG4pIHtcbiAgICByZXR1cm4gISEobiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlID09PSAnL2kxOG4nKTtcbn1cbmZ1bmN0aW9uIF9nZXRJMThuQXR0cihwKSB7XG4gICAgcmV0dXJuIHAuYXR0cnMuZmluZChhdHRyID0+IGF0dHIubmFtZSA9PT0gX0kxOE5fQVRUUikgfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIF9wYXJzZU1lc3NhZ2VNZXRhKGkxOG4pIHtcbiAgICBpZiAoIWkxOG4pXG4gICAgICAgIHJldHVybiB7IG1lYW5pbmc6ICcnLCBkZXNjcmlwdGlvbjogJycsIGlkOiAnJyB9O1xuICAgIGNvbnN0IGlkSW5kZXggPSBpMThuLmluZGV4T2YoSURfU0VQQVJBVE9SKTtcbiAgICBjb25zdCBkZXNjSW5kZXggPSBpMThuLmluZGV4T2YoTUVBTklOR19TRVBBUkFUT1IpO1xuICAgIGNvbnN0IFttZWFuaW5nQW5kRGVzYywgaWRdID0gKGlkSW5kZXggPiAtMSkgPyBbaTE4bi5zbGljZSgwLCBpZEluZGV4KSwgaTE4bi5zbGljZShpZEluZGV4ICsgMildIDogW2kxOG4sICcnXTtcbiAgICBjb25zdCBbbWVhbmluZywgZGVzY3JpcHRpb25dID0gKGRlc2NJbmRleCA+IC0xKSA/XG4gICAgICAgIFttZWFuaW5nQW5kRGVzYy5zbGljZSgwLCBkZXNjSW5kZXgpLCBtZWFuaW5nQW5kRGVzYy5zbGljZShkZXNjSW5kZXggKyAxKV0gOlxuICAgICAgICBbJycsIG1lYW5pbmdBbmREZXNjXTtcbiAgICByZXR1cm4geyBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQ6IGlkLnRyaW0oKSB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIFhtbFRhZ0RlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNWb2lkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWdub3JlRmlyc3RMZiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblNlbGZDbG9zZSA9IHRydWU7XG4gICAgICAgIHRoaXMucHJldmVudE5hbWVzcGFjZUluaGVyaXRhbmNlID0gZmFsc2U7XG4gICAgfVxuICAgIHJlcXVpcmVFeHRyYVBhcmVudChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNDbG9zZWRCeUNoaWxkKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRDb250ZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEE7XG4gICAgfVxufVxuY29uc3QgX1RBR19ERUZJTklUSU9OID0gbmV3IFhtbFRhZ0RlZmluaXRpb24oKTtcbmZ1bmN0aW9uIGdldFhtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgIHJldHVybiBfVEFHX0RFRklOSVRJT047XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgWG1sUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZ2V0WG1sVGFnRGVmaW5pdGlvbik7XG4gICAgfVxuICAgIHBhcnNlKHNvdXJjZSwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZShzb3VyY2UsIHVybCwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IF9WRVJTSU9OJDEgPSAnMS4yJztcbmNvbnN0IF9YTUxOUyQxID0gJ3VybjpvYXNpczpuYW1lczp0Yzp4bGlmZjpkb2N1bWVudDoxLjInO1xuLy8gVE9ETyh2aWNiKTogbWFrZSB0aGlzIGEgcGFyYW0gKHMvXy8tLylcbmNvbnN0IF9ERUZBVUxUX1NPVVJDRV9MQU5HJDEgPSAnZW4nO1xuY29uc3QgX1BMQUNFSE9MREVSX1RBRyQyID0gJ3gnO1xuY29uc3QgX01BUktFUl9UQUckMSA9ICdtcmsnO1xuY29uc3QgX0ZJTEVfVEFHID0gJ2ZpbGUnO1xuY29uc3QgX1NPVVJDRV9UQUckMSA9ICdzb3VyY2UnO1xuY29uc3QgX1NFR01FTlRfU09VUkNFX1RBRyA9ICdzZWctc291cmNlJztcbmNvbnN0IF9BTFRfVFJBTlNfVEFHID0gJ2FsdC10cmFucyc7XG5jb25zdCBfVEFSR0VUX1RBRyQxID0gJ3RhcmdldCc7XG5jb25zdCBfVU5JVF9UQUckMSA9ICd0cmFucy11bml0JztcbmNvbnN0IF9DT05URVhUX0dST1VQX1RBRyA9ICdjb250ZXh0LWdyb3VwJztcbmNvbnN0IF9DT05URVhUX1RBRyA9ICdjb250ZXh0Jztcbi8vIGh0dHBzOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi92MS4yL29zL3hsaWZmLWNvcmUuaHRtbFxuLy8gaHR0cHM6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL3hsaWZmL3YxLjIveGxpZmYtcHJvZmlsZS1odG1sL3hsaWZmLXByb2ZpbGUtaHRtbC0xLjIuaHRtbFxuY2xhc3MgWGxpZmYgZXh0ZW5kcyBTZXJpYWxpemVyIHtcbiAgICB3cml0ZShtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX1dyaXRlVmlzaXRvciQxKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zVW5pdHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgIGxldCBjb250ZXh0VGFncyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZXh0R3JvdXBUYWcgPSBuZXcgVGFnKF9DT05URVhUX0dST1VQX1RBRywgeyBwdXJwb3NlOiAnbG9jYXRpb24nIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHRHcm91cFRhZy5jaGlsZHJlbi5wdXNoKG5ldyBDUigxMCksIG5ldyBUYWcoX0NPTlRFWFRfVEFHLCB7ICdjb250ZXh0LXR5cGUnOiAnc291cmNlZmlsZScgfSwgW25ldyBUZXh0JDEoc291cmNlLmZpbGVQYXRoKV0pLCBuZXcgQ1IoMTApLCBuZXcgVGFnKF9DT05URVhUX1RBRywgeyAnY29udGV4dC10eXBlJzogJ2xpbmVudW1iZXInIH0sIFtuZXcgVGV4dCQxKGAke3NvdXJjZS5zdGFydExpbmV9YCldKSwgbmV3IENSKDgpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0VGFncy5wdXNoKG5ldyBDUig4KSwgY29udGV4dEdyb3VwVGFnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNVbml0ID0gbmV3IFRhZyhfVU5JVF9UQUckMSwgeyBpZDogbWVzc2FnZS5pZCwgZGF0YXR5cGU6ICdodG1sJyB9KTtcbiAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZyhfU09VUkNFX1RBRyQxLCB7fSwgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpLCAuLi5jb250ZXh0VGFncyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgcHJpb3JpdHk6ICcxJywgZnJvbTogJ2Rlc2NyaXB0aW9uJyB9LCBbbmV3IFRleHQkMShtZXNzYWdlLmRlc2NyaXB0aW9uKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdtZWFuaW5nJyB9LCBbbmV3IFRleHQkMShtZXNzYWdlLm1lYW5pbmcpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgIHRyYW5zVW5pdHMucHVzaChuZXcgQ1IoNiksIHRyYW5zVW5pdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBib2R5ID0gbmV3IFRhZygnYm9keScsIHt9LCBbLi4udHJhbnNVbml0cywgbmV3IENSKDQpXSk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgVGFnKCdmaWxlJywge1xuICAgICAgICAgICAgJ3NvdXJjZS1sYW5ndWFnZSc6IGxvY2FsZSB8fCBfREVGQVVMVF9TT1VSQ0VfTEFORyQxLFxuICAgICAgICAgICAgZGF0YXR5cGU6ICdwbGFpbnRleHQnLFxuICAgICAgICAgICAgb3JpZ2luYWw6ICduZzIudGVtcGxhdGUnLFxuICAgICAgICB9LCBbbmV3IENSKDQpLCBib2R5LCBuZXcgQ1IoMildKTtcbiAgICAgICAgY29uc3QgeGxpZmYgPSBuZXcgVGFnKCd4bGlmZicsIHsgdmVyc2lvbjogX1ZFUlNJT04kMSwgeG1sbnM6IF9YTUxOUyQxIH0sIFtuZXcgQ1IoMiksIGZpbGUsIG5ldyBDUigpXSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uKHsgdmVyc2lvbjogJzEuMCcsIGVuY29kaW5nOiAnVVRGLTgnIH0pLCBuZXcgQ1IoKSwgeGxpZmYsIG5ldyBDUigpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBsb2FkKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4bGlmZiB0byB4bWwgbm9kZXNcbiAgICAgICAgY29uc3QgeGxpZmZQYXJzZXIgPSBuZXcgWGxpZmZQYXJzZXIoKTtcbiAgICAgICAgY29uc3QgeyBsb2NhbGUsIG1zZ0lkVG9IdG1sLCBlcnJvcnMgfSA9IHhsaWZmUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCk7XG4gICAgICAgIC8vIHhtbCBub2RlcyB0byBpMThuIG5vZGVzXG4gICAgICAgIGNvbnN0IGkxOG5Ob2Rlc0J5TXNnSWQgPSB7fTtcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gbmV3IFhtbFRvSTE4biQyKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1zZ0lkVG9IdG1sKS5mb3JFYWNoKG1zZ0lkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaTE4bk5vZGVzLCBlcnJvcnM6IGUgfSA9IGNvbnZlcnRlci5jb252ZXJ0KG1zZ0lkVG9IdG1sW21zZ0lkXSwgdXJsKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmUpO1xuICAgICAgICAgICAgaTE4bk5vZGVzQnlNc2dJZFttc2dJZF0gPSBpMThuTm9kZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB4bGlmZiBwYXJzZSBlcnJvcnM6XFxuJHtlcnJvcnMuam9pbignXFxuJyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbG9jYWxlOiBsb2NhbGUsIGkxOG5Ob2Rlc0J5TXNnSWQgfTtcbiAgICB9XG4gICAgZGlnZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRpZ2VzdCQxKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNsYXNzIF9Xcml0ZVZpc2l0b3IkMSB7XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGV4dCQxKHRleHQudmFsdWUpXTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKChub2RlKSA9PiBub2Rlcy5wdXNoKC4uLm5vZGUudmlzaXQodGhpcykpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICB2aXNpdEljdShpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbbmV3IFRleHQkMShgeyR7aWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlcn0sICR7aWN1LnR5cGV9LCBgKV07XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKGAke2N9IHtgKSwgLi4uaWN1LmNhc2VzW2NdLnZpc2l0KHRoaXMpLCBuZXcgVGV4dCQxKGB9IGApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShgfWApKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGN0eXBlID0gZ2V0Q3R5cGVGb3JUYWcocGgudGFnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMiwgeyBpZDogcGguc3RhcnROYW1lLCBjdHlwZSwgJ2VxdWl2LXRleHQnOiBgPCR7cGgudGFnfS8+YCB9KV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IGlkOiBwaC5zdGFydE5hbWUsIGN0eXBlLCAnZXF1aXYtdGV4dCc6IGA8JHtwaC50YWd9PmAgfSk7XG4gICAgICAgIGNvbnN0IGNsb3NlVGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMiwgeyBpZDogcGguY2xvc2VOYW1lLCBjdHlwZSwgJ2VxdWl2LXRleHQnOiBgPC8ke3BoLnRhZ30+YCB9KTtcbiAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoLCAuLi50aGlzLnNlcmlhbGl6ZShwaC5jaGlsZHJlbiksIGNsb3NlVGFnUGhdO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgaWQ6IHBoLm5hbWUsICdlcXVpdi10ZXh0JzogYHt7JHtwaC52YWx1ZX19fWAgfSldO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGVxdWl2VGV4dCA9IGB7JHtwaC52YWx1ZS5leHByZXNzaW9ufSwgJHtwaC52YWx1ZS50eXBlfSwgJHtPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKyAnIHsuLi59Jykuam9pbignICcpfX1gO1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IGlkOiBwaC5uYW1lLCAnZXF1aXYtdGV4dCc6IGVxdWl2VGV4dCB9KV07XG4gICAgfVxuICAgIHNlcmlhbGl6ZShub2Rlcykge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KC4uLm5vZGVzLm1hcChub2RlID0+IG5vZGUudmlzaXQodGhpcykpKTtcbiAgICB9XG59XG4vLyBUT0RPKHZpY2IpOiBhZGQgZXJyb3IgbWFuYWdlbWVudCAoc3RydWN0dXJlKVxuLy8gRXh0cmFjdCBtZXNzYWdlcyBhcyB4bWwgbm9kZXMgZnJvbSB0aGUgeGxpZmYgZmlsZVxuY2xhc3MgWGxpZmZQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICBwYXJzZSh4bGlmZiwgdXJsKSB7XG4gICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sID0ge307XG4gICAgICAgIGNvbnN0IHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4bGlmZiwgdXJsKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sLnJvb3ROb2RlcywgbnVsbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBfVU5JVF9UQUckMTpcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgPCR7X1VOSVRfVEFHJDF9PiBtaXNzZXMgdGhlIFwiaWRcIiBhdHRyaWJ1dGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gaWRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWRUb0h0bWwuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgRHVwbGljYXRlZCB0cmFuc2xhdGlvbnMgZm9yIG1zZyAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3VuaXRNbFN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbFtpZF0gPSB0aGlzLl91bml0TWxTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgTWVzc2FnZSAke2lkfSBtaXNzZXMgYSB0cmFuc2xhdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gaWdub3JlIHRob3NlIHRhZ3NcbiAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUckMTpcbiAgICAgICAgICAgIGNhc2UgX1NFR01FTlRfU09VUkNFX1RBRzpcbiAgICAgICAgICAgIGNhc2UgX0FMVF9UUkFOU19UQUc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHJDE6XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJUZXh0U3RhcnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyVGV4dEVuZCA9IGVsZW1lbnQuZW5kU291cmNlU3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLnN0YXJ0LmZpbGUuY29udGVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHQgPSBjb250ZW50LnNsaWNlKGlubmVyVGV4dFN0YXJ0LCBpbm5lclRleHRFbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IGlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX0ZJTEVfVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZUF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ3RhcmdldC1sYW5ndWFnZScpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZUF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBhc3NlcnQgZmlsZSBzdHJ1Y3R1cmUsIHhsaWZmIHZlcnNpb25cbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93IG9ubHkgcmVjdXJzZSBvbiB1bmhhbmRsZWQgbm9kZXNcbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uLCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0IG1sIG5vZGVzICh4bGlmZiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbmNsYXNzIFhtbFRvSTE4biQyIHtcbiAgICBjb252ZXJ0KG1lc3NhZ2UsIHVybCkge1xuICAgICAgICBjb25zdCB4bWxJY3UgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UobWVzc2FnZSwgdXJsLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbEljdS5lcnJvcnM7XG4gICAgICAgIGNvbnN0IGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgW10uY29uY2F0KC4uLnZpc2l0QWxsKHRoaXMsIHhtbEljdS5yb290Tm9kZXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlczogaTE4bk5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dCQyKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbCwgY29udGV4dCkge1xuICAgICAgICBpZiAoZWwubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRyQyKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lQXR0ciA9IGVsLmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ2lkJyk7XG4gICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgZWwuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUckMn0+IG1pc3NlcyB0aGUgXCJpZFwiIGF0dHJpYnV0ZWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLm5hbWUgPT09IF9NQVJLRVJfVEFHJDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoLi4udmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYFVuZXhwZWN0ZWQgdGFnYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZU1hcCA9IHt9O1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCBpY3UuY2FzZXMpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIGNhc2VNYXBbYy52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGMubm9kZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VNYXAsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IHZpc2l0QWxsKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfVxuICAgIF9hZGRFcnJvcihub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q3R5cGVGb3JUYWcodGFnKSB7XG4gICAgc3dpdGNoICh0YWcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICByZXR1cm4gJ2xiJztcbiAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGB4LSR7dGFnfWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IF9WRVJTSU9OID0gJzIuMCc7XG5jb25zdCBfWE1MTlMgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjIuMCc7XG4vLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxuY29uc3QgX0RFRkFVTFRfU09VUkNFX0xBTkcgPSAnZW4nO1xuY29uc3QgX1BMQUNFSE9MREVSX1RBRyQxID0gJ3BoJztcbmNvbnN0IF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUcgPSAncGMnO1xuY29uc3QgX01BUktFUl9UQUcgPSAnbXJrJztcbmNvbnN0IF9YTElGRl9UQUcgPSAneGxpZmYnO1xuY29uc3QgX1NPVVJDRV9UQUcgPSAnc291cmNlJztcbmNvbnN0IF9UQVJHRVRfVEFHID0gJ3RhcmdldCc7XG5jb25zdCBfVU5JVF9UQUcgPSAndW5pdCc7XG4vLyBodHRwczovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYveGxpZmYtY29yZS92Mi4wL29zL3hsaWZmLWNvcmUtdjIuMC1vcy5odG1sXG5jbGFzcyBYbGlmZjIgZXh0ZW5kcyBTZXJpYWxpemVyIHtcbiAgICB3cml0ZShtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX1dyaXRlVmlzaXRvcigpO1xuICAgICAgICBjb25zdCB1bml0cyA9IFtdO1xuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgdW5pdCA9IG5ldyBUYWcoX1VOSVRfVEFHLCB7IGlkOiBtZXNzYWdlLmlkIH0pO1xuICAgICAgICAgICAgY29uc3Qgbm90ZXMgPSBuZXcgVGFnKCdub3RlcycpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24gfHwgbWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXMuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IGNhdGVnb3J5OiAnZGVzY3JpcHRpb24nIH0sIFtuZXcgVGV4dCQxKG1lc3NhZ2UuZGVzY3JpcHRpb24pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ21lYW5pbmcnIH0sIFtuZXcgVGV4dCQxKG1lc3NhZ2UubWVhbmluZyldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ2xvY2F0aW9uJyB9LCBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0JDEoYCR7c291cmNlLmZpbGVQYXRofToke3NvdXJjZS5zdGFydExpbmV9JHtzb3VyY2UuZW5kTGluZSAhPT0gc291cmNlLnN0YXJ0TGluZSA/ICcsJyArIHNvdXJjZS5lbmRMaW5lIDogJyd9YClcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgIHVuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoNiksIG5vdGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBuZXcgVGFnKCdzZWdtZW50Jyk7XG4gICAgICAgICAgICBzZWdtZW50LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKF9TT1VSQ0VfVEFHLCB7fSwgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpLCBuZXcgQ1IoNikpO1xuICAgICAgICAgICAgdW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSwgc2VnbWVudCwgbmV3IENSKDQpKTtcbiAgICAgICAgICAgIHVuaXRzLnB1c2gobmV3IENSKDQpLCB1bml0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgVGFnKCdmaWxlJywgeyAnb3JpZ2luYWwnOiAnbmcudGVtcGxhdGUnLCBpZDogJ25naTE4bicgfSwgWy4uLnVuaXRzLCBuZXcgQ1IoMildKTtcbiAgICAgICAgY29uc3QgeGxpZmYgPSBuZXcgVGFnKF9YTElGRl9UQUcsIHsgdmVyc2lvbjogX1ZFUlNJT04sIHhtbG5zOiBfWE1MTlMsIHNyY0xhbmc6IGxvY2FsZSB8fCBfREVGQVVMVF9TT1VSQ0VfTEFORyB9LCBbbmV3IENSKDIpLCBmaWxlLCBuZXcgQ1IoKV0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSwgbmV3IENSKCksIHhsaWZmLCBuZXcgQ1IoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgbG9hZChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgLy8geGxpZmYgdG8geG1sIG5vZGVzXG4gICAgICAgIGNvbnN0IHhsaWZmMlBhcnNlciA9IG5ldyBYbGlmZjJQYXJzZXIoKTtcbiAgICAgICAgY29uc3QgeyBsb2NhbGUsIG1zZ0lkVG9IdG1sLCBlcnJvcnMgfSA9IHhsaWZmMlBhcnNlci5wYXJzZShjb250ZW50LCB1cmwpO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICBjb25zdCBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4kMSgpO1xuICAgICAgICBPYmplY3Qua2V5cyhtc2dJZFRvSHRtbCkuZm9yRWFjaChtc2dJZCA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGkxOG5Ob2RlcywgZXJyb3JzOiBlIH0gPSBjb252ZXJ0ZXIuY29udmVydChtc2dJZFRvSHRtbFttc2dJZF0sIHVybCk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5lKTtcbiAgICAgICAgICAgIGkxOG5Ob2Rlc0J5TXNnSWRbbXNnSWRdID0gaTE4bk5vZGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgeGxpZmYyIHBhcnNlIGVycm9yczpcXG4ke2Vycm9ycy5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH1cbiAgICBkaWdlc3QobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2VzdChtZXNzYWdlKTtcbiAgICB9XG59XG5jbGFzcyBfV3JpdGVWaXNpdG9yIHtcbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUZXh0JDEodGV4dC52YWx1ZSldO1xuICAgIH1cbiAgICB2aXNpdENvbnRhaW5lcihjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goKG5vZGUpID0+IG5vZGVzLnB1c2goLi4ubm9kZS52aXNpdCh0aGlzKSkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtuZXcgVGV4dCQxKGB7JHtpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyfSwgJHtpY3UudHlwZX0sIGApXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoYCR7Y30ge2ApLCAuLi5pY3UuY2FzZXNbY10udmlzaXQodGhpcyksIG5ldyBUZXh0JDEoYH0gYCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKGB9YCkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGVGb3JUYWcocGgudGFnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwge1xuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBlcXVpdjogcGguc3RhcnROYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZGlzcDogYDwke3BoLnRhZ30vPmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbdGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ1BjID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHLCB7XG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBlcXVpdlN0YXJ0OiBwaC5zdGFydE5hbWUsXG4gICAgICAgICAgICBlcXVpdkVuZDogcGguY2xvc2VOYW1lLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRpc3BTdGFydDogYDwke3BoLnRhZ30+YCxcbiAgICAgICAgICAgIGRpc3BFbmQ6IGA8LyR7cGgudGFnfT5gLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXS5jb25jYXQoLi4ucGguY2hpbGRyZW4ubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSkpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB0YWdQYy5jaGlsZHJlbi5wdXNoKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhZ1BjLmNoaWxkcmVuLnB1c2gobmV3IFRleHQkMSgnJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGFnUGNdO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGlkU3RyID0gKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHtcbiAgICAgICAgICAgICAgICBpZDogaWRTdHIsXG4gICAgICAgICAgICAgICAgZXF1aXY6IHBoLm5hbWUsXG4gICAgICAgICAgICAgICAgZGlzcDogYHt7JHtwaC52YWx1ZX19fWAsXG4gICAgICAgICAgICB9KV07XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZXMgPSBPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKyAnIHsuLi59Jykuam9pbignICcpO1xuICAgICAgICBjb25zdCBpZFN0ciA9ICh0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCsrKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IGlkOiBpZFN0ciwgZXF1aXY6IHBoLm5hbWUsIGRpc3A6IGB7JHtwaC52YWx1ZS5leHByZXNzaW9ufSwgJHtwaC52YWx1ZS50eXBlfSwgJHtjYXNlc319YCB9KV07XG4gICAgfVxuICAgIHNlcmlhbGl6ZShub2Rlcykge1xuICAgICAgICB0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCA9IDA7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoLi4ubm9kZXMubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSkpO1xuICAgIH1cbn1cbi8vIEV4dHJhY3QgbWVzc2FnZXMgYXMgeG1sIG5vZGVzIGZyb20gdGhlIHhsaWZmIGZpbGVcbmNsYXNzIFhsaWZmMlBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIHBhcnNlKHhsaWZmLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgY29uc3QgeG1sID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKHhsaWZmLCB1cmwpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWwucm9vdE5vZGVzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ0lkVG9IdG1sOiB0aGlzLl9tc2dJZFRvSHRtbCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9VTklUX1RBRzpcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgPCR7X1VOSVRfVEFHfT4gbWlzc2VzIHRoZSBcImlkXCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkVG9IdG1sLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgYER1cGxpY2F0ZWQgdHJhbnNsYXRpb25zIGZvciBtc2cgJHtpZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl91bml0TWxTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gdGhpcy5fdW5pdE1sU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgYE1lc3NhZ2UgJHtpZH0gbWlzc2VzIGEgdHJhbnNsYXRpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUc6XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyVGV4dFN0YXJ0ID0gZWxlbWVudC5zdGFydFNvdXJjZVNwYW4uZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHRFbmQgPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJUZXh0ID0gY29udGVudC5zbGljZShpbm5lclRleHRTdGFydCwgaW5uZXJUZXh0RW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBpbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9YTElGRl9UQUc6XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAndHJnTGFuZycpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZUF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25BdHRyID0gZWxlbWVudC5hdHRycy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICd2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb25BdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09ICcyLjAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgVGhlIFhMSUZGIGZpbGUgdmVyc2lvbiAke3ZlcnNpb259IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggWExJRkYgMi4wIHNlcmlhbGl6ZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uLCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0IG1sIG5vZGVzICh4bGlmZiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbmNsYXNzIFhtbFRvSTE4biQxIHtcbiAgICBjb252ZXJ0KG1lc3NhZ2UsIHVybCkge1xuICAgICAgICBjb25zdCB4bWxJY3UgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UobWVzc2FnZSwgdXJsLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbEljdS5lcnJvcnM7XG4gICAgICAgIGNvbnN0IGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgW10uY29uY2F0KC4uLnZpc2l0QWxsKHRoaXMsIHhtbEljdS5yb290Tm9kZXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHQkMih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9UQUckMTpcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lQXR0ciA9IGVsLmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ2VxdWl2Jyk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgZWwuc291cmNlU3BhbildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUckMX0+IG1pc3NlcyB0aGUgXCJlcXVpdlwiIGF0dHJpYnV0ZWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0QXR0ciA9IGVsLmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ2VxdWl2U3RhcnQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRBdHRyID0gZWwuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnZXF1aXZFbmQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0QXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUckMX0+IG1pc3NlcyB0aGUgXCJlcXVpdlN0YXJ0XCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlbmRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBgPCR7X1BMQUNFSE9MREVSX1RBRyQxfT4gbWlzc2VzIHRoZSBcImVxdWl2RW5kXCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydElkID0gc3RhcnRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRJZCA9IGVuZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2Rlcy5jb25jYXQobmV3IFBsYWNlaG9sZGVyKCcnLCBzdGFydElkLCBlbC5zb3VyY2VTcGFuKSwgLi4uZWwuY2hpbGRyZW4ubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzLCBudWxsKSksIG5ldyBQbGFjZWhvbGRlcignJywgZW5kSWQsIGVsLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9NQVJLRVJfVEFHOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoLi4udmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIGBVbmV4cGVjdGVkIHRhZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZU1hcCA9IHt9O1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCBpY3UuY2FzZXMpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIGNhc2VNYXBbYy52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGMubm9kZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VNYXAsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IFtdLmNvbmNhdCguLi52aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24pKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRDb21tZW50KGNvbW1lbnQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUeXBlRm9yVGFnKHRhZykge1xuICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmV0dXJuICdmbXQnO1xuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBfVFJBTlNMQVRJT05TX1RBRyA9ICd0cmFuc2xhdGlvbmJ1bmRsZSc7XG5jb25zdCBfVFJBTlNMQVRJT05fVEFHID0gJ3RyYW5zbGF0aW9uJztcbmNvbnN0IF9QTEFDRUhPTERFUl9UQUcgPSAncGgnO1xuY2xhc3MgWHRiIGV4dGVuZHMgU2VyaWFsaXplciB7XG4gICAgd3JpdGUobWVzc2FnZXMsIGxvY2FsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGxvYWQoY29udGVudCwgdXJsKSB7XG4gICAgICAgIC8vIHh0YiB0byB4bWwgbm9kZXNcbiAgICAgICAgY29uc3QgeHRiUGFyc2VyID0gbmV3IFh0YlBhcnNlcigpO1xuICAgICAgICBjb25zdCB7IGxvY2FsZSwgbXNnSWRUb0h0bWwsIGVycm9ycyB9ID0geHRiUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCk7XG4gICAgICAgIC8vIHhtbCBub2RlcyB0byBpMThuIG5vZGVzXG4gICAgICAgIGNvbnN0IGkxOG5Ob2Rlc0J5TXNnSWQgPSB7fTtcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gbmV3IFhtbFRvSTE4bigpO1xuICAgICAgICAvLyBCZWNhdXNlIHdlIHNob3VsZCBiZSBhYmxlIHRvIGxvYWQgeHRiIGZpbGVzIHRoYXQgcmVseSBvbiBmZWF0dXJlcyBub3Qgc3VwcG9ydGVkIGJ5IGFuZ3VsYXIsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgdGhlIGNvbnZlcnNpb24gb2YgaHRtbCB0byBpMThuIG5vZGVzIHNvIHRoYXQgbm9uIGFuZ3VsYXIgbWVzc2FnZXMgYXJlIG5vdFxuICAgICAgICAvLyBjb252ZXJ0ZWRcbiAgICAgICAgT2JqZWN0LmtleXMobXNnSWRUb0h0bWwpLmZvckVhY2gobXNnSWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGkxOG5Ob2RlcywgZXJyb3JzIH0gPSBjb252ZXJ0ZXIuY29udmVydChtc2dJZFRvSHRtbFttc2dJZF0sIHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB4dGIgcGFyc2UgZXJyb3JzOlxcbiR7ZXJyb3JzLmpvaW4oJ1xcbicpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaTE4bk5vZGVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNyZWF0ZUxhenlQcm9wZXJ0eShpMThuTm9kZXNCeU1zZ0lkLCBtc2dJZCwgdmFsdWVGbik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB4dGIgcGFyc2UgZXJyb3JzOlxcbiR7ZXJyb3JzLmpvaW4oJ1xcbicpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxvY2FsZTogbG9jYWxlLCBpMThuTm9kZXNCeU1zZ0lkIH07XG4gICAgfVxuICAgIGRpZ2VzdChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBkaWdlc3QobWVzc2FnZSk7XG4gICAgfVxuICAgIGNyZWF0ZU5hbWVNYXBwZXIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyKG1lc3NhZ2UsIHRvUHVibGljTmFtZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTGF6eVByb3BlcnR5KG1lc3NhZ2VzLCBpZCwgdmFsdWVGbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXNzYWdlcywgaWQsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVGbigpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lc3NhZ2VzLCBpZCwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBfID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IG92ZXJ3cml0ZSBhbiBYVEIgdHJhbnNsYXRpb24nKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIEV4dHJhY3QgbWVzc2FnZXMgYXMgeG1sIG5vZGVzIGZyb20gdGhlIHh0YiBmaWxlXG5jbGFzcyBYdGJQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICBwYXJzZSh4dGIsIHVybCkge1xuICAgICAgICB0aGlzLl9idW5kbGVEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sID0ge307XG4gICAgICAgIC8vIFdlIGNhbiBub3QgcGFyc2UgdGhlIElDVSBtZXNzYWdlcyBhdCB0aGlzIHBvaW50IGFzIHNvbWUgbWVzc2FnZXMgbWlnaHQgbm90IG9yaWdpbmF0ZVxuICAgICAgICAvLyBmcm9tIEFuZ3VsYXIgdGhhdCBjb3VsZCBub3QgYmUgbGV4J2QuXG4gICAgICAgIGNvbnN0IHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4dGIsIHVybCk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbC5lcnJvcnM7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIHhtbC5yb290Tm9kZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbXNnSWRUb0h0bWw6IHRoaXMuX21zZ0lkVG9IdG1sLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgX1RSQU5TTEFUSU9OU19UQUc6XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYnVuZGxlRGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIGA8JHtfVFJBTlNMQVRJT05TX1RBR30+IGVsZW1lbnRzIGNhbiBub3QgYmUgbmVzdGVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhbmdBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICdsYW5nJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxhbmdBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9idW5kbGVEZXB0aC0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfVFJBTlNMQVRJT05fVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgPCR7X1RSQU5TTEFUSU9OX1RBR30+IG1pc3NlcyB0aGUgXCJpZFwiIGF0dHJpYnV0ZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tc2dJZFRvSHRtbC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIGBEdXBsaWNhdGVkIHRyYW5zbGF0aW9ucyBmb3IgbXNnICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHRTdGFydCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHRFbmQgPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLnN0YXJ0LmZpbGUuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyVGV4dCA9IGNvbnRlbnQuc2xpY2UoaW5uZXJUZXh0U3RhcnQsIGlubmVyVGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbFtpZF0gPSBpbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsICdVbmV4cGVjdGVkIHRhZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbihleHBhbnNpb24sIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH1cbiAgICBfYWRkRXJyb3Iobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH1cbn1cbi8vIENvbnZlcnQgbWwgbm9kZXMgKHh0YiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbmNsYXNzIFhtbFRvSTE4biB7XG4gICAgY29udmVydChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgY29uc3QgeG1sSWN1ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKG1lc3NhZ2UsIHVybCwgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWxJY3UuZXJyb3JzO1xuICAgICAgICBjb25zdCBpMThuTm9kZXMgPSB0aGlzLl9lcnJvcnMubGVuZ3RoID4gMCB8fCB4bWxJY3Uucm9vdE5vZGVzLmxlbmd0aCA9PSAwID9cbiAgICAgICAgICAgIFtdIDpcbiAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIHhtbEljdS5yb290Tm9kZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTE4bk5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dCQyKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uKGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIGNhc2VNYXBbYy52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGMubm9kZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VNYXAsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IHZpc2l0QWxsKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbCwgY29udGV4dCkge1xuICAgICAgICBpZiAoZWwubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRykge1xuICAgICAgICAgICAgY29uc3QgbmFtZUF0dHIgPSBlbC5hdHRycy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICduYW1lJyk7XG4gICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgZWwuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUd9PiBtaXNzZXMgdGhlIFwibmFtZVwiIGF0dHJpYnV0ZWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIGBVbmV4cGVjdGVkIHRhZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250ZXh0KSB7IH1cbiAgICBfYWRkRXJyb3Iobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciB0cmFuc2xhdGVkIG1lc3NhZ2VzXG4gKi9cbmNsYXNzIFRyYW5zbGF0aW9uQnVuZGxlIHtcbiAgICBjb25zdHJ1Y3RvcihfaTE4bk5vZGVzQnlNc2dJZCA9IHt9LCBsb2NhbGUsIGRpZ2VzdCwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nLCBjb25zb2xlKSB7XG4gICAgICAgIHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWQgPSBfaTE4bk5vZGVzQnlNc2dJZDtcbiAgICAgICAgdGhpcy5kaWdlc3QgPSBkaWdlc3Q7XG4gICAgICAgIHRoaXMubWFwcGVyRmFjdG9yeSA9IG1hcHBlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2kxOG5Ub0h0bWwgPSBuZXcgSTE4blRvSHRtbFZpc2l0b3IoX2kxOG5Ob2Rlc0J5TXNnSWQsIGxvY2FsZSwgZGlnZXN0LCBtYXBwZXJGYWN0b3J5LCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSk7XG4gICAgfVxuICAgIC8vIENyZWF0ZXMgYSBgVHJhbnNsYXRpb25CdW5kbGVgIGJ5IHBhcnNpbmcgdGhlIGdpdmVuIGBjb250ZW50YCB3aXRoIHRoZSBgc2VyaWFsaXplcmAuXG4gICAgc3RhdGljIGxvYWQoY29udGVudCwgdXJsLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSkge1xuICAgICAgICBjb25zdCB7IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZCB9ID0gc2VyaWFsaXplci5sb2FkKGNvbnRlbnQsIHVybCk7XG4gICAgICAgIGNvbnN0IGRpZ2VzdEZuID0gKG0pID0+IHNlcmlhbGl6ZXIuZGlnZXN0KG0pO1xuICAgICAgICBjb25zdCBtYXBwZXJGYWN0b3J5ID0gKG0pID0+IHNlcmlhbGl6ZXIuY3JlYXRlTmFtZU1hcHBlcihtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2xhdGlvbkJ1bmRsZShpMThuTm9kZXNCeU1zZ0lkLCBsb2NhbGUsIGRpZ2VzdEZuLCBtYXBwZXJGYWN0b3J5LCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGFzIEhUTUwgbm9kZXMgZnJvbSB0aGUgZ2l2ZW4gc291cmNlIG1lc3NhZ2UuXG4gICAgZ2V0KHNyY01zZykge1xuICAgICAgICBjb25zdCBodG1sID0gdGhpcy5faTE4blRvSHRtbC5jb252ZXJ0KHNyY01zZyk7XG4gICAgICAgIGlmIChodG1sLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihodG1sLmVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWwubm9kZXM7XG4gICAgfVxuICAgIGhhcyhzcmNNc2cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0KHNyY01zZykgaW4gdGhpcy5faTE4bk5vZGVzQnlNc2dJZDtcbiAgICB9XG59XG5jbGFzcyBJMThuVG9IdG1sVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoX2kxOG5Ob2Rlc0J5TXNnSWQgPSB7fSwgX2xvY2FsZSwgX2RpZ2VzdCwgX21hcHBlckZhY3RvcnksIF9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgX2NvbnNvbGUpIHtcbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB0aGlzLl9kaWdlc3QgPSBfZGlnZXN0O1xuICAgICAgICB0aGlzLl9tYXBwZXJGYWN0b3J5ID0gX21hcHBlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgY29udmVydChzcmNNc2cpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBpMThuIHRvIHRleHRcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMuX2NvbnZlcnRUb1RleHQoc3JjTXNnKTtcbiAgICAgICAgLy8gdGV4dCB0byBodG1sXG4gICAgICAgIGNvbnN0IHVybCA9IHNyY01zZy5ub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmZpbGUudXJsO1xuICAgICAgICBjb25zdCBodG1sID0gbmV3IEh0bWxQYXJzZXIoKS5wYXJzZSh0ZXh0LCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzOiBodG1sLnJvb3ROb2RlcyxcbiAgICAgICAgICAgIGVycm9yczogWy4uLnRoaXMuX2Vycm9ycywgLi4uaHRtbC5lcnJvcnNdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICAvLyBgY29udmVydCgpYCB1c2VzIGFuIGBIdG1sUGFyc2VyYCB0byByZXR1cm4gYGh0bWwuTm9kZWBzXG4gICAgICAgIC8vIHdlIHNob3VsZCB0aGVuIG1ha2Ugc3VyZSB0aGF0IGFueSBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWRcbiAgICAgICAgcmV0dXJuIGVzY2FwZVhtbCh0ZXh0LnZhbHVlKTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKG4gPT4gbi52aXNpdCh0aGlzKSkuam9pbignJyk7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGsgPT4gYCR7a30geyR7aWN1LmNhc2VzW2tdLnZpc2l0KHRoaXMpfX1gKTtcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogT25jZSBhbGwgZm9ybWF0IHN3aXRjaCB0byB1c2luZyBleHByZXNzaW9uIHBsYWNlaG9sZGVyc1xuICAgICAgICAvLyB3ZSBzaG91bGQgdGhyb3cgd2hlbiB0aGUgcGxhY2Vob2xkZXIgaXMgbm90IGluIHRoZSBzb3VyY2UgbWVzc2FnZVxuICAgICAgICBjb25zdCBleHAgPSB0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJzLmhhc093blByb3BlcnR5KGljdS5leHByZXNzaW9uKSA/XG4gICAgICAgICAgICB0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJzW2ljdS5leHByZXNzaW9uXS50ZXh0IDpcbiAgICAgICAgICAgIGljdS5leHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gYHske2V4cH0sICR7aWN1LnR5cGV9LCAke2Nhc2VzLmpvaW4oJyAnKX19YDtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBwaE5hbWUgPSB0aGlzLl9tYXBwZXIocGgubmFtZSk7XG4gICAgICAgIGlmICh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJzLmhhc093blByb3BlcnR5KHBoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJzW3BoTmFtZV0udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyVG9NZXNzYWdlLmhhc093blByb3BlcnR5KHBoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9UZXh0KHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlclRvTWVzc2FnZVtwaE5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRFcnJvcihwaCwgYFVua25vd24gcGxhY2Vob2xkZXIgXCIke3BoLm5hbWV9XCJgKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBMb2FkZWQgbWVzc2FnZSBjb250YWlucyBvbmx5IHBsYWNlaG9sZGVycyAodnMgdGFnIGFuZCBpY3UgcGxhY2Vob2xkZXJzKS5cbiAgICAvLyBIb3dldmVyIHdoZW4gYSB0cmFuc2xhdGlvbiBjYW4gbm90IGJlIGZvdW5kLCB3ZSBuZWVkIHRvIHNlcmlhbGl6ZSB0aGUgc291cmNlIG1lc3NhZ2VcbiAgICAvLyB3aGljaCBjYW4gY29udGFpbiB0YWcgcGxhY2Vob2xkZXJzXG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCB0YWcgPSBgJHtwaC50YWd9YDtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBPYmplY3Qua2V5cyhwaC5hdHRycykubWFwKG5hbWUgPT4gYCR7bmFtZX09XCIke3BoLmF0dHJzW25hbWVdfVwiYCkuam9pbignICcpO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gYDwke3RhZ30gJHthdHRyc30vPmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAoKGMpID0+IGMudmlzaXQodGhpcykpLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gYDwke3RhZ30gJHthdHRyc30+JHtjaGlsZHJlbn08LyR7dGFnfT5gO1xuICAgIH1cbiAgICAvLyBMb2FkZWQgbWVzc2FnZSBjb250YWlucyBvbmx5IHBsYWNlaG9sZGVycyAodnMgdGFnIGFuZCBpY3UgcGxhY2Vob2xkZXJzKS5cbiAgICAvLyBIb3dldmVyIHdoZW4gYSB0cmFuc2xhdGlvbiBjYW4gbm90IGJlIGZvdW5kLCB3ZSBuZWVkIHRvIHNlcmlhbGl6ZSB0aGUgc291cmNlIG1lc3NhZ2VcbiAgICAvLyB3aGljaCBjYW4gY29udGFpbiB0YWcgcGxhY2Vob2xkZXJzXG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICAvLyBBbiBJQ1UgcGxhY2Vob2xkZXIgcmVmZXJlbmNlcyB0aGUgc291cmNlIG1lc3NhZ2UgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFRvVGV4dCh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGgubmFtZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgc291cmNlIG1lc3NhZ2UgdG8gYSB0cmFuc2xhdGVkIHRleHQgc3RyaW5nOlxuICAgICAqIC0gdGV4dCBub2RlcyBhcmUgcmVwbGFjZWQgd2l0aCB0aGVpciB0cmFuc2xhdGlvbixcbiAgICAgKiAtIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgd2l0aCB0aGVpciBjb250ZW50LFxuICAgICAqIC0gSUNVIG5vZGVzIGFyZSBjb252ZXJ0ZWQgdG8gSUNVIGV4cHJlc3Npb25zLlxuICAgICAqL1xuICAgIF9jb252ZXJ0VG9UZXh0KHNyY01zZykge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuX2RpZ2VzdChzcmNNc2cpO1xuICAgICAgICBjb25zdCBtYXBwZXIgPSB0aGlzLl9tYXBwZXJGYWN0b3J5ID8gdGhpcy5fbWFwcGVyRmFjdG9yeShzcmNNc2cpIDogbnVsbDtcbiAgICAgICAgbGV0IG5vZGVzO1xuICAgICAgICB0aGlzLl9jb250ZXh0U3RhY2sucHVzaCh7IG1zZzogdGhpcy5fc3JjTXNnLCBtYXBwZXI6IHRoaXMuX21hcHBlciB9KTtcbiAgICAgICAgdGhpcy5fc3JjTXNnID0gc3JjTXNnO1xuICAgICAgICBpZiAodGhpcy5faTE4bk5vZGVzQnlNc2dJZC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgYSB0cmFuc2xhdGlvbiB1c2UgaXRzIG5vZGVzIGFzIHRoZSBzb3VyY2VcbiAgICAgICAgICAgIC8vIEFuZCBjcmVhdGUgYSBtYXBwZXIgdG8gY29udmVydCBzZXJpYWxpemVkIHBsYWNlaG9sZGVyIG5hbWVzIHRvIGludGVybmFsIG5hbWVzXG4gICAgICAgICAgICBub2RlcyA9IHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWRbaWRdO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGVyID0gKG5hbWUpID0+IG1hcHBlciA/IG1hcHBlci50b0ludGVybmFsTmFtZShuYW1lKSA6IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIG5vIHRyYW5zbGF0aW9uIGhhcyBiZWVuIGZvdW5kXG4gICAgICAgICAgICAvLyAtIHJlcG9ydCBhbiBlcnJvciAvIGEgd2FybmluZyAvIG5vdGhpbmcsXG4gICAgICAgICAgICAvLyAtIHVzZSB0aGUgbm9kZXMgZnJvbSB0aGUgb3JpZ2luYWwgbWVzc2FnZVxuICAgICAgICAgICAgLy8gLSBwbGFjZWhvbGRlcnMgYXJlIGFscmVhZHkgaW50ZXJuYWwgYW5kIG5lZWQgbm8gbWFwcGVyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LkVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fbG9jYWxlID8gYCBmb3IgbG9jYWxlIFwiJHt0aGlzLl9sb2NhbGV9XCJgIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3Ioc3JjTXNnLm5vZGVzWzBdLCBgTWlzc2luZyB0cmFuc2xhdGlvbiBmb3IgbWVzc2FnZSBcIiR7aWR9XCIke2N0eH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2NvbnNvbGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9PT0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuV2FybmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2xvY2FsZSA/IGAgZm9yIGxvY2FsZSBcIiR7dGhpcy5fbG9jYWxlfVwiYCA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihgTWlzc2luZyB0cmFuc2xhdGlvbiBmb3IgbWVzc2FnZSBcIiR7aWR9XCIke2N0eH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzID0gc3JjTXNnLm5vZGVzO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGVyID0gKG5hbWUpID0+IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IG5vZGVzLm1hcChub2RlID0+IG5vZGUudmlzaXQodGhpcykpLmpvaW4oJycpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLl9zcmNNc2cgPSBjb250ZXh0Lm1zZztcbiAgICAgICAgdGhpcy5fbWFwcGVyID0gY29udGV4dC5tYXBwZXI7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBfYWRkRXJyb3IoZWwsIG1zZykge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKGVsLnNvdXJjZVNwYW4sIG1zZykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBJMThOSHRtbFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoX2h0bWxQYXJzZXIsIHRyYW5zbGF0aW9ucywgdHJhbnNsYXRpb25zRm9ybWF0LCBtaXNzaW5nVHJhbnNsYXRpb24gPSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nLCBjb25zb2xlKSB7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IGNyZWF0ZVNlcmlhbGl6ZXIodHJhbnNsYXRpb25zRm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uQnVuZGxlID1cbiAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkKHRyYW5zbGF0aW9ucywgJ2kxOG4nLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUgPVxuICAgICAgICAgICAgICAgIG5ldyBUcmFuc2xhdGlvbkJ1bmRsZSh7fSwgbnVsbCwgZGlnZXN0JDEsIHVuZGVmaW5lZCwgbWlzc2luZ1RyYW5zbGF0aW9uLCBjb25zb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZShzb3VyY2UsIHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpb25Db25maWcgPSBvcHRpb25zLmludGVycG9sYXRpb25Db25maWcgfHwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRztcbiAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHNvdXJjZSwgdXJsLCBPYmplY3QuYXNzaWduKHsgaW50ZXJwb2xhdGlvbkNvbmZpZyB9LCBvcHRpb25zKSk7XG4gICAgICAgIGlmIChwYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHBhcnNlUmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlVHJhbnNsYXRpb25zKHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUsIGludGVycG9sYXRpb25Db25maWcsIFtdLCB7fSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSAoZm9ybWF0IHx8ICd4bGYnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3htYic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhtYigpO1xuICAgICAgICBjYXNlICd4dGInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYdGIoKTtcbiAgICAgICAgY2FzZSAneGxpZmYyJzpcbiAgICAgICAgY2FzZSAneGxmMic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmMigpO1xuICAgICAgICBjYXNlICd4bGlmZic6XG4gICAgICAgIGNhc2UgJ3hsZic6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBjb250YWluZXIgZm9yIG1lc3NhZ2UgZXh0cmFjdGVkIGZyb20gdGhlIHRlbXBsYXRlcy5cbiAqL1xuY2xhc3MgTWVzc2FnZUJ1bmRsZSB7XG4gICAgY29uc3RydWN0b3IoX2h0bWxQYXJzZXIsIF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzLCBfbG9jYWxlID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0VGFncyA9IF9pbXBsaWNpdFRhZ3M7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gX2xvY2FsZTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcbiAgICB9XG4gICAgdXBkYXRlRnJvbVRlbXBsYXRlKGh0bWwsIHVybCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBjb25zdCBodG1sUGFyc2VyUmVzdWx0ID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZShodG1sLCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyB9KTtcbiAgICAgICAgaWYgKGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkxOG5QYXJzZXJSZXN1bHQgPSBleHRyYWN0TWVzc2FnZXMoaHRtbFBhcnNlclJlc3VsdC5yb290Tm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIHRoaXMuX2ltcGxpY2l0VGFncywgdGhpcy5faW1wbGljaXRBdHRycyk7XG4gICAgICAgIGlmIChpMThuUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpMThuUGFyc2VyUmVzdWx0LmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKC4uLmkxOG5QYXJzZXJSZXN1bHQubWVzc2FnZXMpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgbWVzc2FnZSBpbiB0aGUgaW50ZXJuYWwgZm9ybWF0XG4gICAgLy8gVGhlIHB1YmxpYyAoc2VyaWFsaXplZCkgZm9ybWF0IG1pZ2h0IGJlIGRpZmZlcmVudCwgc2VlIHRoZSBgd3JpdGVgIG1ldGhvZC5cbiAgICBnZXRNZXNzYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VzO1xuICAgIH1cbiAgICB3cml0ZShzZXJpYWxpemVyLCBmaWx0ZXJTb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0ge307XG4gICAgICAgIGNvbnN0IG1hcHBlclZpc2l0b3IgPSBuZXcgTWFwUGxhY2Vob2xkZXJOYW1lcygpO1xuICAgICAgICAvLyBEZWR1cGxpY2F0ZSBtZXNzYWdlcyBiYXNlZCBvbiB0aGVpciBJRFxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXJpYWxpemVyLmRpZ2VzdChtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5zb3VyY2VzLnB1c2goLi4ubWVzc2FnZS5zb3VyY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyYW5zZm9ybSBwbGFjZWhvbGRlciBuYW1lcyB1c2luZyB0aGUgc2VyaWFsaXplciBtYXBwaW5nXG4gICAgICAgIGNvbnN0IG1zZ0xpc3QgPSBPYmplY3Qua2V5cyhtZXNzYWdlcykubWFwKGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlciA9IHNlcmlhbGl6ZXIuY3JlYXRlTmFtZU1hcHBlcihtZXNzYWdlc1tpZF0pO1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gbWVzc2FnZXNbaWRdO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBtYXBwZXIgPyBtYXBwZXJWaXNpdG9yLmNvbnZlcnQoc3JjLm5vZGVzLCBtYXBwZXIpIDogc3JjLm5vZGVzO1xuICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkTWVzc2FnZSA9IG5ldyBNZXNzYWdlKG5vZGVzLCB7fSwge30sIHNyYy5tZWFuaW5nLCBzcmMuZGVzY3JpcHRpb24sIGlkKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTWVzc2FnZS5zb3VyY2VzID0gc3JjLnNvdXJjZXM7XG4gICAgICAgICAgICBpZiAoZmlsdGVyU291cmNlcykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkTWVzc2FnZS5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4gc291cmNlLmZpbGVQYXRoID0gZmlsdGVyU291cmNlcyhzb3VyY2UuZmlsZVBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZE1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplci53cml0ZShtc2dMaXN0LCB0aGlzLl9sb2NhbGUpO1xuICAgIH1cbn1cbi8vIFRyYW5zZm9ybSBhbiBpMThuIEFTVCBieSByZW5hbWluZyB0aGUgcGxhY2Vob2xkZXIgbm9kZXMgd2l0aCB0aGUgZ2l2ZW4gbWFwcGVyXG5jbGFzcyBNYXBQbGFjZWhvbGRlck5hbWVzIGV4dGVuZHMgQ2xvbmVWaXNpdG9yIHtcbiAgICBjb252ZXJ0KG5vZGVzLCBtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBlciA/IG5vZGVzLm1hcChuID0+IG4udmlzaXQodGhpcywgbWFwcGVyKSkgOiBub2RlcztcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0TmFtZSA9IG1hcHBlci50b1B1YmxpY05hbWUocGguc3RhcnROYW1lKTtcbiAgICAgICAgY29uc3QgY2xvc2VOYW1lID0gcGguY2xvc2VOYW1lID8gbWFwcGVyLnRvUHVibGljTmFtZShwaC5jbG9zZU5hbWUpIDogcGguY2xvc2VOYW1lO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChuID0+IG4udmlzaXQodGhpcywgbWFwcGVyKSk7XG4gICAgICAgIHJldHVybiBuZXcgVGFnUGxhY2Vob2xkZXIocGgudGFnLCBwaC5hdHRycywgc3RhcnROYW1lLCBjbG9zZU5hbWUsIGNoaWxkcmVuLCBwaC5pc1ZvaWQsIHBoLnNvdXJjZVNwYW4sIHBoLnN0YXJ0U291cmNlU3BhbiwgcGguZW5kU291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgsIG1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKHBoLnZhbHVlLCBtYXBwZXIudG9QdWJsaWNOYW1lKHBoLm5hbWUpLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIG1hcHBlci50b1B1YmxpY05hbWUocGgubmFtZSksIHBoLnNvdXJjZVNwYW4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbnZhciBGYWN0b3J5VGFyZ2V0O1xuKGZ1bmN0aW9uIChGYWN0b3J5VGFyZ2V0KSB7XG4gICAgRmFjdG9yeVRhcmdldFtGYWN0b3J5VGFyZ2V0W1wiRGlyZWN0aXZlXCJdID0gMF0gPSBcIkRpcmVjdGl2ZVwiO1xuICAgIEZhY3RvcnlUYXJnZXRbRmFjdG9yeVRhcmdldFtcIkNvbXBvbmVudFwiXSA9IDFdID0gXCJDb21wb25lbnRcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJJbmplY3RhYmxlXCJdID0gMl0gPSBcIkluamVjdGFibGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJQaXBlXCJdID0gM10gPSBcIlBpcGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJOZ01vZHVsZVwiXSA9IDRdID0gXCJOZ01vZHVsZVwiO1xufSkoRmFjdG9yeVRhcmdldCB8fCAoRmFjdG9yeVRhcmdldCA9IHt9KSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBQcm9jZXNzZXMgYFRhcmdldGBzIHdpdGggYSBnaXZlbiBzZXQgb2YgZGlyZWN0aXZlcyBhbmQgcGVyZm9ybXMgYSBiaW5kaW5nIG9wZXJhdGlvbiwgd2hpY2hcbiAqIHJldHVybnMgYW4gb2JqZWN0IHNpbWlsYXIgdG8gVHlwZVNjcmlwdCdzIGB0cy5UeXBlQ2hlY2tlcmAgdGhhdCBjb250YWlucyBrbm93bGVkZ2UgYWJvdXQgdGhlXG4gKiB0YXJnZXQuXG4gKi9cbmNsYXNzIFIzVGFyZ2V0QmluZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkaXJlY3RpdmVNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlTWF0Y2hlciA9IGRpcmVjdGl2ZU1hdGNoZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBiaW5kaW5nIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYFRhcmdldGAgYW5kIHJldHVybiBhIGBCb3VuZFRhcmdldGAgd2hpY2ggY29udGFpbnNcbiAgICAgKiBtZXRhZGF0YSBhYm91dCB0aGUgdHlwZXMgcmVmZXJlbmNlZCBpbiB0aGUgdGVtcGxhdGUuXG4gICAgICovXG4gICAgYmluZCh0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogaGFuZGxlIHRhcmdldHMgd2hpY2ggY29udGFpbiB0aGluZ3MgbGlrZSBIb3N0QmluZGluZ3MsIGV0Yy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmluZGluZyB3aXRob3V0IGEgdGVtcGxhdGUgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCwgcGFyc2UgdGhlIHRlbXBsYXRlIGludG8gYSBgU2NvcGVgIHN0cnVjdHVyZS4gVGhpcyBvcGVyYXRpb24gY2FwdHVyZXMgdGhlIHN5bnRhY3RpY1xuICAgICAgICAvLyBzY29wZXMgaW4gdGhlIHRlbXBsYXRlIGFuZCBtYWtlcyB0aGVtIGF2YWlsYWJsZSBmb3IgbGF0ZXIgdXNlLlxuICAgICAgICBjb25zdCBzY29wZSA9IFNjb3BlLmFwcGx5KHRhcmdldC50ZW1wbGF0ZSk7XG4gICAgICAgIC8vIFVzZSB0aGUgYFNjb3BlYCB0byBleHRyYWN0IHRoZSBlbnRpdGllcyBwcmVzZW50IGF0IGV2ZXJ5IGxldmVsIG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgY29uc3QgdGVtcGxhdGVFbnRpdGllcyA9IGV4dHJhY3RUZW1wbGF0ZUVudGl0aWVzKHNjb3BlKTtcbiAgICAgICAgLy8gTmV4dCwgcGVyZm9ybSBkaXJlY3RpdmUgbWF0Y2hpbmcgb24gdGhlIHRlbXBsYXRlIHVzaW5nIHRoZSBgRGlyZWN0aXZlQmluZGVyYC4gVGhpcyByZXR1cm5zOlxuICAgICAgICAvLyAgIC0gZGlyZWN0aXZlczogTWFwIG9mIG5vZGVzIChlbGVtZW50cyAmIG5nLXRlbXBsYXRlcykgdG8gdGhlIGRpcmVjdGl2ZXMgb24gdGhlbS5cbiAgICAgICAgLy8gICAtIGJpbmRpbmdzOiBNYXAgb2YgaW5wdXRzLCBvdXRwdXRzLCBhbmQgYXR0cmlidXRlcyB0byB0aGUgZGlyZWN0aXZlL2VsZW1lbnQgdGhhdCBjbGFpbXNcbiAgICAgICAgLy8gICAgIHRoZW0uIFRPRE8oYWx4aHViKTogaGFuZGxlIG11bHRpcGxlIGRpcmVjdGl2ZXMgY2xhaW1pbmcgYW4gaW5wdXQvb3V0cHV0L2V0Yy5cbiAgICAgICAgLy8gICAtIHJlZmVyZW5jZXM6IE1hcCBvZiAjcmVmZXJlbmNlcyB0byB0aGVpciB0YXJnZXRzLlxuICAgICAgICBjb25zdCB7IGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzIH0gPSBEaXJlY3RpdmVCaW5kZXIuYXBwbHkodGFyZ2V0LnRlbXBsYXRlLCB0aGlzLmRpcmVjdGl2ZU1hdGNoZXIpO1xuICAgICAgICAvLyBGaW5hbGx5LCBydW4gdGhlIFRlbXBsYXRlQmluZGVyIHRvIGJpbmQgcmVmZXJlbmNlcywgdmFyaWFibGVzLCBhbmQgb3RoZXIgZW50aXRpZXMgd2l0aGluIHRoZVxuICAgICAgICAvLyB0ZW1wbGF0ZS4gVGhpcyBleHRyYWN0cyBhbGwgdGhlIG1ldGFkYXRhIHRoYXQgZG9lc24ndCBkZXBlbmQgb24gZGlyZWN0aXZlIG1hdGNoaW5nLlxuICAgICAgICBjb25zdCB7IGV4cHJlc3Npb25zLCBzeW1ib2xzLCBuZXN0aW5nTGV2ZWwsIHVzZWRQaXBlcyB9ID0gVGVtcGxhdGVCaW5kZXIuYXBwbHlXaXRoU2NvcGUodGFyZ2V0LnRlbXBsYXRlLCBzY29wZSk7XG4gICAgICAgIHJldHVybiBuZXcgUjNCb3VuZFRhcmdldCh0YXJnZXQsIGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzLCBleHByZXNzaW9ucywgc3ltYm9scywgbmVzdGluZ0xldmVsLCB0ZW1wbGF0ZUVudGl0aWVzLCB1c2VkUGlwZXMpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGJpbmRpbmcgc2NvcGUgd2l0aGluIGEgdGVtcGxhdGUuXG4gKlxuICogQW55IHZhcmlhYmxlcywgcmVmZXJlbmNlcywgb3Igb3RoZXIgbmFtZWQgZW50aXRpZXMgZGVjbGFyZWQgd2l0aGluIHRoZSB0ZW1wbGF0ZSB3aWxsXG4gKiBiZSBjYXB0dXJlZCBhbmQgYXZhaWxhYmxlIGJ5IG5hbWUgaW4gYG5hbWVkRW50aXRpZXNgLiBBZGRpdGlvbmFsbHksIGNoaWxkIHRlbXBsYXRlcyB3aWxsXG4gKiBiZSBhbmFseXplZCBhbmQgaGF2ZSB0aGVpciBjaGlsZCBgU2NvcGVgcyBhdmFpbGFibGUgaW4gYGNoaWxkU2NvcGVzYC5cbiAqL1xuY2xhc3MgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNjb3BlLCB0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnBhcmVudFNjb3BlID0gcGFyZW50U2NvcGU7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWVkIG1lbWJlcnMgb2YgdGhlIGBTY29wZWAsIHN1Y2ggYXMgYFJlZmVyZW5jZWBzIG9yIGBWYXJpYWJsZWBzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lZEVudGl0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hpbGQgYFNjb3BlYHMgZm9yIGltbWVkaWF0ZWx5IG5lc3RlZCBgVGVtcGxhdGVgcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRTY29wZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHN0YXRpYyBuZXdSb290U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NvcGUobnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSB0ZW1wbGF0ZSAoZWl0aGVyIGFzIGEgYFRlbXBsYXRlYCBzdWItdGVtcGxhdGUgd2l0aCB2YXJpYWJsZXMsIG9yIGEgcGxhaW4gYXJyYXkgb2ZcbiAgICAgKiB0ZW1wbGF0ZSBgTm9kZWBzKSBhbmQgY29uc3RydWN0IGl0cyBgU2NvcGVgLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseSh0ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBzY29wZSA9IFNjb3BlLm5ld1Jvb3RTY29wZSgpO1xuICAgICAgICBzY29wZS5pbmdlc3QodGVtcGxhdGUpO1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBwcm9jZXNzIHRoZSB0ZW1wbGF0ZSBhbmQgcG9wdWxhdGUgdGhlIGBTY29wZWAuXG4gICAgICovXG4gICAgaW5nZXN0KHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBWYXJpYWJsZXMgb24gYW4gPG5nLXRlbXBsYXRlPiBhcmUgZGVmaW5lZCBpbiB0aGUgaW5uZXIgc2NvcGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS52YXJpYWJsZXMuZm9yRWFjaChub2RlID0+IHRoaXMudmlzaXRWYXJpYWJsZShub2RlKSk7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBub2RlcyBvZiB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jaGlsZHJlbi5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBvdmVyYXJjaGluZyBgVGVtcGxhdGVgIGluc3RhbmNlLCBzbyBwcm9jZXNzIHRoZSBub2RlcyBkaXJlY3RseS5cbiAgICAgICAgICAgIHRlbXBsYXRlLmZvckVhY2gobm9kZSA9PiBub2RlLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAvLyBgRWxlbWVudGBzIGluIHRoZSB0ZW1wbGF0ZSBtYXkgaGF2ZSBgUmVmZXJlbmNlYHMgd2hpY2ggYXJlIGNhcHR1cmVkIGluIHRoZSBzY29wZS5cbiAgICAgICAgZWxlbWVudC5yZWZlcmVuY2VzLmZvckVhY2gobm9kZSA9PiB0aGlzLnZpc2l0UmVmZXJlbmNlKG5vZGUpKTtcbiAgICAgICAgLy8gUmVjdXJzZSBpbnRvIHRoZSBgRWxlbWVudGAncyBjaGlsZHJlbi5cbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0VGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgLy8gUmVmZXJlbmNlcyBvbiBhIDxuZy10ZW1wbGF0ZT4gYXJlIGRlZmluZWQgaW4gdGhlIG91dGVyIHNjb3BlLCBzbyBjYXB0dXJlIHRoZW0gYmVmb3JlXG4gICAgICAgIC8vIHByb2Nlc3NpbmcgdGhlIHRlbXBsYXRlJ3MgY2hpbGQgc2NvcGUuXG4gICAgICAgIHRlbXBsYXRlLnJlZmVyZW5jZXMuZm9yRWFjaChub2RlID0+IHRoaXMudmlzaXRSZWZlcmVuY2Uobm9kZSkpO1xuICAgICAgICAvLyBOZXh0LCBjcmVhdGUgYW4gaW5uZXIgc2NvcGUgYW5kIHByb2Nlc3MgdGhlIHRlbXBsYXRlIHdpdGhpbiBpdC5cbiAgICAgICAgY29uc3Qgc2NvcGUgPSBuZXcgU2NvcGUodGhpcywgdGVtcGxhdGUpO1xuICAgICAgICBzY29wZS5pbmdlc3QodGVtcGxhdGUpO1xuICAgICAgICB0aGlzLmNoaWxkU2NvcGVzLnNldCh0ZW1wbGF0ZSwgc2NvcGUpO1xuICAgIH1cbiAgICB2aXNpdFZhcmlhYmxlKHZhcmlhYmxlKSB7XG4gICAgICAgIC8vIERlY2xhcmUgdGhlIHZhcmlhYmxlIGlmIGl0J3Mgbm90IGFscmVhZHkuXG4gICAgICAgIHRoaXMubWF5YmVEZWNsYXJlKHZhcmlhYmxlKTtcbiAgICB9XG4gICAgdmlzaXRSZWZlcmVuY2UocmVmZXJlbmNlKSB7XG4gICAgICAgIC8vIERlY2xhcmUgdGhlIHZhcmlhYmxlIGlmIGl0J3Mgbm90IGFscmVhZHkuXG4gICAgICAgIHRoaXMubWF5YmVEZWNsYXJlKHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIC8vIFVudXNlZCB2aXNpdG9ycy5cbiAgICB2aXNpdENvbnRlbnQoY29udGVudCkgeyB9XG4gICAgdmlzaXRCb3VuZEF0dHJpYnV0ZShhdHRyKSB7IH1cbiAgICB2aXNpdEJvdW5kRXZlbnQoZXZlbnQpIHsgfVxuICAgIHZpc2l0Qm91bmRUZXh0KHRleHQpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdFRleHRBdHRyaWJ1dGUoYXR0cikgeyB9XG4gICAgdmlzaXRJY3UoaWN1KSB7IH1cbiAgICBtYXliZURlY2xhcmUodGhpbmcpIHtcbiAgICAgICAgLy8gRGVjbGFyZSBzb21ldGhpbmcgd2l0aCBhIG5hbWUsIGFzIGxvbmcgYXMgdGhhdCBuYW1lIGlzbid0IHRha2VuLlxuICAgICAgICBpZiAoIXRoaXMubmFtZWRFbnRpdGllcy5oYXModGhpbmcubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZWRFbnRpdGllcy5zZXQodGhpbmcubmFtZSwgdGhpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2sgdXAgYSB2YXJpYWJsZSB3aXRoaW4gdGhpcyBgU2NvcGVgLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gcmVjdXJzZSBpbnRvIGEgcGFyZW50IGBTY29wZWAgaWYgaXQncyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgbG9va3VwKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZWRFbnRpdGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGluIHRoZSBsb2NhbCBzY29wZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVkRW50aXRpZXMuZ2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50U2NvcGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE5vdCBpbiB0aGUgbG9jYWwgc2NvcGUsIGJ1dCB0aGVyZSdzIGEgcGFyZW50IHNjb3BlIHNvIGNoZWNrIHRoZXJlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NvcGUubG9va3VwKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQXQgdGhlIHRvcCBsZXZlbCBhbmQgaXQgd2Fzbid0IGZvdW5kLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGlsZCBzY29wZSBmb3IgYSBgVGVtcGxhdGVgLlxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgYWx3YXlzIGJlIGRlZmluZWQuXG4gICAgICovXG4gICAgZ2V0Q2hpbGRTY29wZSh0ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmNoaWxkU2NvcGVzLmdldCh0ZW1wbGF0ZSk7XG4gICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb24gZXJyb3I6IGNoaWxkIHNjb3BlIGZvciAke3RlbXBsYXRlfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbi8qKlxuICogUHJvY2Vzc2VzIGEgdGVtcGxhdGUgYW5kIG1hdGNoZXMgZGlyZWN0aXZlcyBvbiBub2RlcyAoZWxlbWVudHMgYW5kIHRlbXBsYXRlcykuXG4gKlxuICogVXN1YWxseSB1c2VkIHZpYSB0aGUgc3RhdGljIGBhcHBseSgpYCBtZXRob2QuXG4gKi9cbmNsYXNzIERpcmVjdGl2ZUJpbmRlciB7XG4gICAgY29uc3RydWN0b3IobWF0Y2hlciwgZGlyZWN0aXZlcywgYmluZGluZ3MsIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVyID0gbWF0Y2hlcjtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgdGVtcGxhdGUgKGxpc3Qgb2YgYE5vZGVgcykgYW5kIHBlcmZvcm0gZGlyZWN0aXZlIG1hdGNoaW5nIGFnYWluc3QgZWFjaCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIHRoZSBsaXN0IG9mIHRlbXBsYXRlIGBOb2RlYHMgdG8gbWF0Y2ggKHJlY3Vyc2l2ZWx5KS5cbiAgICAgKiBAcGFyYW0gc2VsZWN0b3JNYXRjaGVyIGEgYFNlbGVjdG9yTWF0Y2hlcmAgY29udGFpbmluZyB0aGUgZGlyZWN0aXZlcyB0aGF0IGFyZSBpbiBzY29wZSBmb3JcbiAgICAgKiB0aGlzIHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm5zIHRocmVlIG1hcHMgd2hpY2ggY29udGFpbiBpbmZvcm1hdGlvbiBhYm91dCBkaXJlY3RpdmVzIGluIHRoZSB0ZW1wbGF0ZTogdGhlXG4gICAgICogYGRpcmVjdGl2ZXNgIG1hcCB3aGljaCBsaXN0cyBkaXJlY3RpdmVzIG1hdGNoZWQgb24gZWFjaCBub2RlLCB0aGUgYGJpbmRpbmdzYCBtYXAgd2hpY2hcbiAgICAgKiBpbmRpY2F0ZXMgd2hpY2ggZGlyZWN0aXZlcyBjbGFpbWVkIHdoaWNoIGJpbmRpbmdzIChpbnB1dHMsIG91dHB1dHMsIGV0YyksIGFuZCB0aGUgYHJlZmVyZW5jZXNgXG4gICAgICogbWFwIHdoaWNoIHJlc29sdmVzICNyZWZlcmVuY2VzIChgUmVmZXJlbmNlYHMpIHdpdGhpbiB0aGUgdGVtcGxhdGUgdG8gdGhlIG5hbWVkIGRpcmVjdGl2ZSBvclxuICAgICAqIHRlbXBsYXRlIG5vZGUuXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5KHRlbXBsYXRlLCBzZWxlY3Rvck1hdGNoZXIpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgYmluZGluZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXIgPSBuZXcgRGlyZWN0aXZlQmluZGVyKHNlbGVjdG9yTWF0Y2hlciwgZGlyZWN0aXZlcywgYmluZGluZ3MsIHJlZmVyZW5jZXMpO1xuICAgICAgICBtYXRjaGVyLmluZ2VzdCh0ZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiB7IGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzIH07XG4gICAgfVxuICAgIGluZ2VzdCh0ZW1wbGF0ZSkge1xuICAgICAgICB0ZW1wbGF0ZS5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMudmlzaXRFbGVtZW50T3JUZW1wbGF0ZShlbGVtZW50Lm5hbWUsIGVsZW1lbnQpO1xuICAgIH1cbiAgICB2aXNpdFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMudmlzaXRFbGVtZW50T3JUZW1wbGF0ZSgnbmctdGVtcGxhdGUnLCB0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudE9yVGVtcGxhdGUoZWxlbWVudE5hbWUsIG5vZGUpIHtcbiAgICAgICAgLy8gRmlyc3QsIGRldGVybWluZSB0aGUgSFRNTCBzaGFwZSBvZiB0aGUgbm9kZSBmb3IgdGhlIHB1cnBvc2Ugb2YgZGlyZWN0aXZlIG1hdGNoaW5nLlxuICAgICAgICAvLyBEbyB0aGlzIGJ5IGJ1aWxkaW5nIHVwIGEgYENzc1NlbGVjdG9yYCBmb3IgdGhlIG5vZGUuXG4gICAgICAgIGNvbnN0IGNzc1NlbGVjdG9yID0gY3JlYXRlQ3NzU2VsZWN0b3IoZWxlbWVudE5hbWUsIGdldEF0dHJzRm9yRGlyZWN0aXZlTWF0Y2hpbmcobm9kZSkpO1xuICAgICAgICAvLyBOZXh0LCB1c2UgdGhlIGBTZWxlY3Rvck1hdGNoZXJgIHRvIGdldCB0aGUgbGlzdCBvZiBkaXJlY3RpdmVzIG9uIHRoZSBub2RlLlxuICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gW107XG4gICAgICAgIHRoaXMubWF0Y2hlci5tYXRjaChjc3NTZWxlY3RvciwgKF8sIGRpcmVjdGl2ZSkgPT4gZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSkpO1xuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuc2V0KG5vZGUsIGRpcmVjdGl2ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc29sdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBhcmUgY3JlYXRlZCBvbiB0aGlzIG5vZGUuXG4gICAgICAgIG5vZGUucmVmZXJlbmNlcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgICAgICBsZXQgZGlyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIElmIHRoZSByZWZlcmVuY2UgZXhwcmVzc2lvbiBpcyBlbXB0eSwgdGhlbiBpdCBtYXRjaGVzIHRoZSBcInByaW1hcnlcIiBkaXJlY3RpdmUgb24gdGhlIG5vZGVcbiAgICAgICAgICAgIC8vIChpZiB0aGVyZSBpcyBvbmUpLiBPdGhlcndpc2UgaXQgbWF0Y2hlcyB0aGUgaG9zdCBub2RlIGl0c2VsZiAoZWl0aGVyIGFuIGVsZW1lbnQgb3JcbiAgICAgICAgICAgIC8vIDxuZy10ZW1wbGF0ZT4gbm9kZSkuXG4gICAgICAgICAgICBpZiAocmVmLnZhbHVlLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGEgcmVmZXJlbmNlIHRvIGEgY29tcG9uZW50IGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgICAgICAgICAgICBkaXJUYXJnZXQgPSBkaXJlY3RpdmVzLmZpbmQoZGlyID0+IGRpci5pc0NvbXBvbmVudCkgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGEgcmVmZXJlbmNlIHRvIGEgZGlyZWN0aXZlIGV4cG9ydGVkIHZpYSBleHBvcnRBcy5cbiAgICAgICAgICAgICAgICBkaXJUYXJnZXQgPVxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzLmZpbmQoZGlyID0+IGRpci5leHBvcnRBcyAhPT0gbnVsbCAmJiBkaXIuZXhwb3J0QXMuc29tZSh2YWx1ZSA9PiB2YWx1ZSA9PT0gcmVmLnZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBtYXRjaGluZyBkaXJlY3RpdmUgd2FzIGZvdW5kLlxuICAgICAgICAgICAgICAgIGlmIChkaXJUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gbWF0Y2hpbmcgZGlyZWN0aXZlIHdhcyBmb3VuZCAtIHRoaXMgcmVmZXJlbmNlIHBvaW50cyB0byBhbiB1bmtub3duIHRhcmdldC4gTGVhdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5tYXBwZWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZWZlcmVuY2UgcG9pbnRzIHRvIGEgZGlyZWN0aXZlLlxuICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlcy5zZXQocmVmLCB7IGRpcmVjdGl2ZTogZGlyVGFyZ2V0LCBub2RlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZWZlcmVuY2UgcG9pbnRzIHRvIHRoZSBub2RlIGl0c2VsZi5cbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZXMuc2V0KHJlZiwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZXRBdHRyaWJ1dGVCaW5kaW5nID0gKGF0dHJpYnV0ZSwgaW9UeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXIgPSBkaXJlY3RpdmVzLmZpbmQoZGlyID0+IGRpcltpb1R5cGVdLmhhc0JpbmRpbmdQcm9wZXJ0eU5hbWUoYXR0cmlidXRlLm5hbWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmcgPSBkaXIgIT09IHVuZGVmaW5lZCA/IGRpciA6IG5vZGU7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzLnNldChhdHRyaWJ1dGUsIGJpbmRpbmcpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBOb2RlIGlucHV0cyAoYm91bmQgYXR0cmlidXRlcykgYW5kIHRleHQgYXR0cmlidXRlcyBjYW4gYmUgYm91bmQgdG8gYW5cbiAgICAgICAgLy8gaW5wdXQgb24gYSBkaXJlY3RpdmUuXG4gICAgICAgIG5vZGUuaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gc2V0QXR0cmlidXRlQmluZGluZyhpbnB1dCwgJ2lucHV0cycpKTtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLmZvckVhY2goYXR0ciA9PiBzZXRBdHRyaWJ1dGVCaW5kaW5nKGF0dHIsICdpbnB1dHMnKSk7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIG5vZGUudGVtcGxhdGVBdHRycy5mb3JFYWNoKGF0dHIgPT4gc2V0QXR0cmlidXRlQmluZGluZyhhdHRyLCAnaW5wdXRzJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vZGUgb3V0cHV0cyAoYm91bmQgZXZlbnRzKSBjYW4gYmUgYm91bmQgdG8gYW4gb3V0cHV0IG9uIGEgZGlyZWN0aXZlLlxuICAgICAgICBub2RlLm91dHB1dHMuZm9yRWFjaChvdXRwdXQgPT4gc2V0QXR0cmlidXRlQmluZGluZyhvdXRwdXQsICdvdXRwdXRzJykpO1xuICAgICAgICAvLyBSZWN1cnNlIGludG8gdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgLy8gVW51c2VkIHZpc2l0b3JzLlxuICAgIHZpc2l0Q29udGVudChjb250ZW50KSB7IH1cbiAgICB2aXNpdFZhcmlhYmxlKHZhcmlhYmxlKSB7IH1cbiAgICB2aXNpdFJlZmVyZW5jZShyZWZlcmVuY2UpIHsgfVxuICAgIHZpc2l0VGV4dEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0Qm91bmRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdEJvdW5kRXZlbnQoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdEJvdW5kQXR0cmlidXRlT3JFdmVudChub2RlKSB7IH1cbiAgICB2aXNpdFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRCb3VuZFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRJY3UoaWN1KSB7IH1cbn1cbi8qKlxuICogUHJvY2Vzc2VzIGEgdGVtcGxhdGUgYW5kIGV4dHJhY3QgbWV0YWRhdGEgYWJvdXQgZXhwcmVzc2lvbnMgYW5kIHN5bWJvbHMgd2l0aGluLlxuICpcbiAqIFRoaXMgaXMgYSBjb21wYW5pb24gdG8gdGhlIGBEaXJlY3RpdmVCaW5kZXJgIHRoYXQgZG9lc24ndCByZXF1aXJlIGtub3dsZWRnZSBvZiBkaXJlY3RpdmVzIG1hdGNoZWRcbiAqIHdpdGhpbiB0aGUgdGVtcGxhdGUgaW4gb3JkZXIgdG8gb3BlcmF0ZS5cbiAqXG4gKiBFeHByZXNzaW9ucyBhcmUgdmlzaXRlZCBieSB0aGUgc3VwZXJjbGFzcyBgUmVjdXJzaXZlQXN0VmlzaXRvcmAsIHdpdGggY3VzdG9tIGxvZ2ljIHByb3ZpZGVkXG4gKiBieSBvdmVycmlkZGVuIG1ldGhvZHMgZnJvbSB0aGF0IHZpc2l0b3IuXG4gKi9cbmNsYXNzIFRlbXBsYXRlQmluZGVyIGV4dGVuZHMgUmVjdXJzaXZlQXN0VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZ3MsIHN5bWJvbHMsIHVzZWRQaXBlcywgbmVzdGluZ0xldmVsLCBzY29wZSwgdGVtcGxhdGUsIGxldmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gc3ltYm9scztcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgICAgIHRoaXMubmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLnBpcGVzVXNlZCA9IFtdO1xuICAgICAgICAvLyBTYXZlIGEgYml0IG9mIHByb2Nlc3NpbmcgdGltZSBieSBjb25zdHJ1Y3RpbmcgdGhpcyBjbG9zdXJlIGluIGFkdmFuY2UuXG4gICAgICAgIHRoaXMudmlzaXROb2RlID0gKG5vZGUpID0+IG5vZGUudmlzaXQodGhpcyk7XG4gICAgfVxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGRlZmluZWQgdG8gcmVjb25jaWxlIHRoZSB0eXBlIG9mIFRlbXBsYXRlQmluZGVyIHNpbmNlIGJvdGhcbiAgICAvLyBSZWN1cnNpdmVBc3RWaXNpdG9yIGFuZCBWaXNpdG9yIGRlZmluZSB0aGUgdmlzaXQoKSBtZXRob2QgaW4gdGhlaXJcbiAgICAvLyBpbnRlcmZhY2VzLlxuICAgIHZpc2l0KG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1QpIHtcbiAgICAgICAgICAgIG5vZGUudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnZpc2l0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSB0ZW1wbGF0ZSBhbmQgZXh0cmFjdCBtZXRhZGF0YSBhYm91dCBleHByZXNzaW9ucyBhbmQgc3ltYm9scyB3aXRoaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGUgdGhlIG5vZGVzIG9mIHRoZSB0ZW1wbGF0ZSB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtIHNjb3BlIHRoZSBgU2NvcGVgIG9mIHRoZSB0ZW1wbGF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gICAgICogQHJldHVybnMgdGhyZWUgbWFwcyB3aGljaCBjb250YWluIG1ldGFkYXRhIGFib3V0IHRoZSB0ZW1wbGF0ZTogYGV4cHJlc3Npb25zYCB3aGljaCBpbnRlcnByZXRzXG4gICAgICogc3BlY2lhbCBgQVNUYCBub2RlcyBpbiBleHByZXNzaW9ucyBhcyBwb2ludGluZyB0byByZWZlcmVuY2VzIG9yIHZhcmlhYmxlcyBkZWNsYXJlZCB3aXRoaW4gdGhlXG4gICAgICogdGVtcGxhdGUsIGBzeW1ib2xzYCB3aGljaCBtYXBzIHRob3NlIHZhcmlhYmxlcyBhbmQgcmVmZXJlbmNlcyB0byB0aGUgbmVzdGVkIGBUZW1wbGF0ZWAgd2hpY2hcbiAgICAgKiBkZWNsYXJlcyB0aGVtLCBpZiBhbnksIGFuZCBgbmVzdGluZ0xldmVsYCB3aGljaCBhc3NvY2lhdGVzIGVhY2ggYFRlbXBsYXRlYCB3aXRoIGEgaW50ZWdlclxuICAgICAqIG5lc3RpbmcgbGV2ZWwgKGhvdyBtYW55IGxldmVscyBkZWVwIHdpdGhpbiB0aGUgdGVtcGxhdGUgc3RydWN0dXJlIHRoZSBgVGVtcGxhdGVgIGlzKSwgc3RhcnRpbmdcbiAgICAgKiBhdCAxLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseVdpdGhTY29wZSh0ZW1wbGF0ZSwgc2NvcGUpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHN5bWJvbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IG5lc3RpbmdMZXZlbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgdXNlZFBpcGVzID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBUaGUgdG9wLWxldmVsIHRlbXBsYXRlIGhhcyBuZXN0aW5nIGxldmVsIDAuXG4gICAgICAgIGNvbnN0IGJpbmRlciA9IG5ldyBUZW1wbGF0ZUJpbmRlcihleHByZXNzaW9ucywgc3ltYm9scywgdXNlZFBpcGVzLCBuZXN0aW5nTGV2ZWwsIHNjb3BlLCB0ZW1wbGF0ZSBpbnN0YW5jZW9mIFRlbXBsYXRlID8gdGVtcGxhdGUgOiBudWxsLCAwKTtcbiAgICAgICAgYmluZGVyLmluZ2VzdCh0ZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiB7IGV4cHJlc3Npb25zLCBzeW1ib2xzLCBuZXN0aW5nTGV2ZWwsIHVzZWRQaXBlcyB9O1xuICAgIH1cbiAgICBpbmdlc3QodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIEZvciA8bmctdGVtcGxhdGU+cywgcHJvY2VzcyBvbmx5IHZhcmlhYmxlcyBhbmQgY2hpbGQgbm9kZXMuIElucHV0cywgb3V0cHV0cywgdGVtcGxhdGVBdHRycyxcbiAgICAgICAgICAgIC8vIGFuZCByZWZlcmVuY2VzIHdlcmUgYWxsIHByb2Nlc3NlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIGNvbnRhaW5pbmcgdGVtcGxhdGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS52YXJpYWJsZXMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgICAgICB0ZW1wbGF0ZS5jaGlsZHJlbi5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmVzdGluZyBsZXZlbC5cbiAgICAgICAgICAgIHRoaXMubmVzdGluZ0xldmVsLnNldCh0ZW1wbGF0ZSwgdGhpcy5sZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBWaXNpdCBlYWNoIG5vZGUgZnJvbSB0aGUgdG9wLWxldmVsIHRlbXBsYXRlLlxuICAgICAgICAgICAgdGVtcGxhdGUuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgLy8gVmlzaXQgdGhlIGlucHV0cywgb3V0cHV0cywgYW5kIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50LlxuICAgICAgICBlbGVtZW50LmlucHV0cy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgZWxlbWVudC5vdXRwdXRzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgIH1cbiAgICB2aXNpdFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIC8vIEZpcnN0LCB2aXNpdCBpbnB1dHMsIG91dHB1dHMgYW5kIHRlbXBsYXRlIGF0dHJpYnV0ZXMgb2YgdGhlIHRlbXBsYXRlIG5vZGUuXG4gICAgICAgIHRlbXBsYXRlLmlucHV0cy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgdGVtcGxhdGUub3V0cHV0cy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgdGVtcGxhdGUudGVtcGxhdGVBdHRycy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgLy8gUmVmZXJlbmNlcyBhcmUgYWxzbyBldmFsdWF0ZWQgaW4gdGhlIG91dGVyIGNvbnRleHQuXG4gICAgICAgIHRlbXBsYXRlLnJlZmVyZW5jZXMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIC8vIE5leHQsIHJlY3Vyc2UgaW50byB0aGUgdGVtcGxhdGUgdXNpbmcgaXRzIHNjb3BlLCBhbmQgYnVtcGluZyB0aGUgbmVzdGluZyBsZXZlbCB1cCBieSBvbmUuXG4gICAgICAgIGNvbnN0IGNoaWxkU2NvcGUgPSB0aGlzLnNjb3BlLmdldENoaWxkU2NvcGUodGVtcGxhdGUpO1xuICAgICAgICBjb25zdCBiaW5kZXIgPSBuZXcgVGVtcGxhdGVCaW5kZXIodGhpcy5iaW5kaW5ncywgdGhpcy5zeW1ib2xzLCB0aGlzLnVzZWRQaXBlcywgdGhpcy5uZXN0aW5nTGV2ZWwsIGNoaWxkU2NvcGUsIHRlbXBsYXRlLCB0aGlzLmxldmVsICsgMSk7XG4gICAgICAgIGJpbmRlci5pbmdlc3QodGVtcGxhdGUpO1xuICAgIH1cbiAgICB2aXNpdFZhcmlhYmxlKHZhcmlhYmxlKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBgVmFyaWFibGVgIGFzIGEgc3ltYm9sIGluIHRoZSBjdXJyZW50IGBUZW1wbGF0ZWAuXG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbHMuc2V0KHZhcmlhYmxlLCB0aGlzLnRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFJlZmVyZW5jZShyZWZlcmVuY2UpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGBSZWZlcmVuY2VgIGFzIGEgc3ltYm9sIGluIHRoZSBjdXJyZW50IGBUZW1wbGF0ZWAuXG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbHMuc2V0KHJlZmVyZW5jZSwgdGhpcy50ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVW51c2VkIHRlbXBsYXRlIHZpc2l0b3JzXG4gICAgdmlzaXRUZXh0KHRleHQpIHsgfVxuICAgIHZpc2l0Q29udGVudChjb250ZW50KSB7IH1cbiAgICB2aXNpdFRleHRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdEljdShpY3UpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LnZhcnMpLmZvckVhY2goa2V5ID0+IGljdS52YXJzW2tleV0udmlzaXQodGhpcykpO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UucGxhY2Vob2xkZXJzKS5mb3JFYWNoKGtleSA9PiBpY3UucGxhY2Vob2xkZXJzW2tleV0udmlzaXQodGhpcykpO1xuICAgIH1cbiAgICAvLyBUaGUgcmVtYWluaW5nIHZpc2l0b3JzIGFyZSBjb25jZXJuZWQgd2l0aCBwcm9jZXNzaW5nIEFTVCBleHByZXNzaW9ucyB3aXRoaW4gdGVtcGxhdGUgYmluZGluZ3NcbiAgICB2aXNpdEJvdW5kQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgICAgICBhdHRyaWJ1dGUudmFsdWUudmlzaXQodGhpcyk7XG4gICAgfVxuICAgIHZpc2l0Qm91bmRFdmVudChldmVudCkge1xuICAgICAgICBldmVudC5oYW5kbGVyLnZpc2l0KHRoaXMpO1xuICAgIH1cbiAgICB2aXNpdEJvdW5kVGV4dCh0ZXh0KSB7XG4gICAgICAgIHRleHQudmFsdWUudmlzaXQodGhpcyk7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy51c2VkUGlwZXMuYWRkKGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0UGlwZShhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBUaGVzZSBmaXZlIHR5cGVzIG9mIEFTVCBleHByZXNzaW9ucyBjYW4gcmVmZXIgdG8gZXhwcmVzc2lvbiByb290cywgd2hpY2ggY291bGQgYmUgdmFyaWFibGVzXG4gICAgLy8gb3IgcmVmZXJlbmNlcyBpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXliZU1hcChjb250ZXh0LCBhc3QsIGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0UHJvcGVydHlSZWFkKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXliZU1hcChjb250ZXh0LCBhc3QsIGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubWF5YmVNYXAoY29udGV4dCwgYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBzdXBlci52aXNpdFByb3BlcnR5V3JpdGUoYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgbWF5YmVNYXAoc2NvcGUsIGFzdCwgbmFtZSkge1xuICAgICAgICAvLyBJZiB0aGUgcmVjZWl2ZXIgb2YgdGhlIGV4cHJlc3Npb24gaXNuJ3QgdGhlIGBJbXBsaWNpdFJlY2VpdmVyYCwgdGhpcyBpc24ndCB0aGUgcm9vdCBvZiBhblxuICAgICAgICAvLyBgQVNUYCBleHByZXNzaW9uIHRoYXQgbWFwcyB0byBhIGBWYXJpYWJsZWAgb3IgYFJlZmVyZW5jZWAuXG4gICAgICAgIGlmICghKGFzdC5yZWNlaXZlciBpbnN0YW5jZW9mIEltcGxpY2l0UmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgbmFtZSBleGlzdHMgaW4gdGhlIGN1cnJlbnQgc2NvcGUuIElmIHNvLCBtYXAgaXQuIE90aGVyd2lzZSwgdGhlIG5hbWUgaXNcbiAgICAgICAgLy8gcHJvYmFibHkgYSBwcm9wZXJ0eSBvbiB0aGUgdG9wLWxldmVsIGNvbXBvbmVudCBjb250ZXh0LlxuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zY29wZS5sb29rdXAobmFtZSk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3Muc2V0KGFzdCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWV0YWRhdGEgY29udGFpbmVyIGZvciBhIGBUYXJnZXRgIHRoYXQgYWxsb3dzIHF1ZXJpZXMgZm9yIHNwZWNpZmljIGJpdHMgb2YgbWV0YWRhdGEuXG4gKlxuICogU2VlIGBCb3VuZFRhcmdldGAgZm9yIGRvY3VtZW50YXRpb24gb24gdGhlIGluZGl2aWR1YWwgbWV0aG9kcy5cbiAqL1xuY2xhc3MgUjNCb3VuZFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBkaXJlY3RpdmVzLCBiaW5kaW5ncywgcmVmZXJlbmNlcywgZXhwclRhcmdldHMsIHN5bWJvbHMsIG5lc3RpbmdMZXZlbCwgdGVtcGxhdGVFbnRpdGllcywgdXNlZFBpcGVzKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgIHRoaXMuZXhwclRhcmdldHMgPSBleHByVGFyZ2V0cztcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gc3ltYm9scztcbiAgICAgICAgdGhpcy5uZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWw7XG4gICAgICAgIHRoaXMudGVtcGxhdGVFbnRpdGllcyA9IHRlbXBsYXRlRW50aXRpZXM7XG4gICAgICAgIHRoaXMudXNlZFBpcGVzID0gdXNlZFBpcGVzO1xuICAgIH1cbiAgICBnZXRFbnRpdGllc0luVGVtcGxhdGVTY29wZSh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnRlbXBsYXRlRW50aXRpZXMuZ2V0KHRlbXBsYXRlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFNldCgpO1xuICAgIH1cbiAgICBnZXREaXJlY3RpdmVzT2ZOb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aXZlcy5nZXQobm9kZSkgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0UmVmZXJlbmNlVGFyZ2V0KHJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VzLmdldChyZWYpIHx8IG51bGw7XG4gICAgfVxuICAgIGdldENvbnN1bWVyT2ZCaW5kaW5nKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3MuZ2V0KGJpbmRpbmcpIHx8IG51bGw7XG4gICAgfVxuICAgIGdldEV4cHJlc3Npb25UYXJnZXQoZXhwcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByVGFyZ2V0cy5nZXQoZXhwcikgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0VGVtcGxhdGVPZlN5bWJvbChzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9scy5nZXQoc3ltYm9sKSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXROZXN0aW5nTGV2ZWwodGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVzdGluZ0xldmVsLmdldCh0ZW1wbGF0ZSkgfHwgMDtcbiAgICB9XG4gICAgZ2V0VXNlZERpcmVjdGl2ZXMoKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmZvckVhY2goZGlycyA9PiBkaXJzLmZvckVhY2goZGlyID0+IHNldC5hZGQoZGlyKSkpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzZXQudmFsdWVzKCkpO1xuICAgIH1cbiAgICBnZXRVc2VkUGlwZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudXNlZFBpcGVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHRyYWN0VGVtcGxhdGVFbnRpdGllcyhyb290U2NvcGUpIHtcbiAgICBjb25zdCBlbnRpdHlNYXAgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gZXh0cmFjdFNjb3BlRW50aXRpZXMoc2NvcGUpIHtcbiAgICAgICAgaWYgKGVudGl0eU1hcC5oYXMoc2NvcGUudGVtcGxhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50aXR5TWFwLmdldChzY29wZS50ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEVudGl0aWVzID0gc2NvcGUubmFtZWRFbnRpdGllcztcbiAgICAgICAgbGV0IHRlbXBsYXRlRW50aXRpZXM7XG4gICAgICAgIGlmIChzY29wZS5wYXJlbnRTY29wZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGVtcGxhdGVFbnRpdGllcyA9IG5ldyBNYXAoWy4uLmV4dHJhY3RTY29wZUVudGl0aWVzKHNjb3BlLnBhcmVudFNjb3BlKSwgLi4uY3VycmVudEVudGl0aWVzXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVudGl0aWVzID0gbmV3IE1hcChjdXJyZW50RW50aXRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVudGl0eU1hcC5zZXQoc2NvcGUudGVtcGxhdGUsIHRlbXBsYXRlRW50aXRpZXMpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVFbnRpdGllcztcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzVG9Qcm9jZXNzID0gW3Jvb3RTY29wZV07XG4gICAgd2hpbGUgKHNjb3Blc1RvUHJvY2Vzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gc2NvcGVzVG9Qcm9jZXNzLnBvcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkU2NvcGUgb2Ygc2NvcGUuY2hpbGRTY29wZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNjb3Blc1RvUHJvY2Vzcy5wdXNoKGNoaWxkU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhY3RTY29wZUVudGl0aWVzKHNjb3BlKTtcbiAgICB9XG4gICAgY29uc3QgdGVtcGxhdGVFbnRpdGllcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFt0ZW1wbGF0ZSwgZW50aXRpZXNdIG9mIGVudGl0eU1hcCkge1xuICAgICAgICB0ZW1wbGF0ZUVudGl0aWVzLnNldCh0ZW1wbGF0ZSwgbmV3IFNldChlbnRpdGllcy52YWx1ZXMoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGVFbnRpdGllcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjb21waWxlQ2xhc3NNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy8gR2VuZXJhdGUgYW4gbmdEZXZNb2RlIGd1YXJkZWQgY2FsbCB0byBzZXRDbGFzc01ldGFkYXRhIHdpdGggdGhlIGNsYXNzIGlkZW50aWZpZXIgYW5kIGl0c1xuICAgIC8vIG1ldGFkYXRhLlxuICAgIGNvbnN0IGZuQ2FsbCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5zZXRDbGFzc01ldGFkYXRhKS5jYWxsRm4oW1xuICAgICAgICBtZXRhZGF0YS50eXBlLFxuICAgICAgICBtZXRhZGF0YS5kZWNvcmF0b3JzLFxuICAgICAgICAoX2EgPSBtZXRhZGF0YS5jdG9yUGFyYW1ldGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGl0ZXJhbChudWxsKSxcbiAgICAgICAgKF9iID0gbWV0YWRhdGEucHJvcERlY29yYXRvcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGxpdGVyYWwobnVsbCksXG4gICAgXSk7XG4gICAgY29uc3QgaWlmZSA9IGZuKFtdLCBbZGV2T25seUd1YXJkZWRFeHByZXNzaW9uKGZuQ2FsbCkudG9TdG10KCldKTtcbiAgICByZXR1cm4gaWlmZS5jYWxsRm4oW10pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogRXZlcnkgdGltZSB3ZSBtYWtlIGEgYnJlYWtpbmcgY2hhbmdlIHRvIHRoZSBkZWNsYXJhdGlvbiBpbnRlcmZhY2Ugb3IgcGFydGlhbC1saW5rZXIgYmVoYXZpb3IsIHdlXG4gKiBtdXN0IHVwZGF0ZSB0aGlzIGNvbnN0YW50IHRvIHByZXZlbnQgb2xkIHBhcnRpYWwtbGlua2VycyBmcm9tIGluY29ycmVjdGx5IHByb2Nlc3NpbmcgdGhlXG4gKiBkZWNsYXJhdGlvbi5cbiAqXG4gKiBEbyBub3QgaW5jbHVkZSBhbnkgcHJlcmVsZWFzZSBpbiB0aGVzZSB2ZXJzaW9ucyBhcyB0aGV5IGFyZSBpZ25vcmVkLlxuICovXG5jb25zdCBNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kNiA9ICcxMi4wLjAnO1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVDbGFzc01ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ21pblZlcnNpb24nLCBsaXRlcmFsKE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTiQ2KSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZlcnNpb24nLCBsaXRlcmFsKCcxMy4xLjMnKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nSW1wb3J0JywgaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmNvcmUpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG1ldGFkYXRhLnR5cGUpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZWNvcmF0b3JzJywgbWV0YWRhdGEuZGVjb3JhdG9ycyk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2N0b3JQYXJhbWV0ZXJzJywgbWV0YWRhdGEuY3RvclBhcmFtZXRlcnMpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdwcm9wRGVjb3JhdG9ycycsIG1ldGFkYXRhLnByb3BEZWNvcmF0b3JzKTtcbiAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlY2xhcmVDbGFzc01ldGFkYXRhKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgbGl0ZXJhbCBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIGFycmF5LCBtYXBwaW5nIGFsbCB2YWx1ZXMgdG8gYW4gZXhwcmVzc2lvblxuICogdXNpbmcgdGhlIHByb3ZpZGVkIG1hcHBpbmcgZnVuY3Rpb24uIElmIHRoZSBhcnJheSBpcyBlbXB0eSBvciBudWxsLCB0aGVuIG51bGwgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlcyBUaGUgYXJyYXkgdG8gdHJhbnNmZXIgaW50byBsaXRlcmFsIGFycmF5IGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gbWFwcGVyIFRoZSBsb2dpYyB0byB1c2UgZm9yIGNyZWF0aW5nIGFuIGV4cHJlc3Npb24gZm9yIHRoZSBhcnJheSdzIHZhbHVlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IGxpdGVyYWwgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgYHZhbHVlc2AsIG9yIG51bGwgaWYgYHZhbHVlc2AgaXMgZW1wdHkgb3JcbiAqIGlzIGl0c2VsZiBudWxsLlxuICovXG5mdW5jdGlvbiB0b09wdGlvbmFsTGl0ZXJhbEFycmF5KHZhbHVlcywgbWFwcGVyKSB7XG4gICAgaWYgKHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGl0ZXJhbEFycih2YWx1ZXMubWFwKHZhbHVlID0+IG1hcHBlcih2YWx1ZSkpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgbGl0ZXJhbCBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIG9iamVjdCwgbWFwcGluZyBhbGwgdmFsdWVzIHRvIGFuIGV4cHJlc3Npb25cbiAqIHVzaW5nIHRoZSBwcm92aWRlZCBtYXBwaW5nIGZ1bmN0aW9uLiBJZiB0aGUgb2JqZWN0IGhhcyBubyBrZXlzLCB0aGVuIG51bGwgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIHRyYW5zZmVyIGludG8gYW4gb2JqZWN0IGxpdGVyYWwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSBtYXBwZXIgVGhlIGxvZ2ljIHRvIHVzZSBmb3IgY3JlYXRpbmcgYW4gZXhwcmVzc2lvbiBmb3IgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBsaXRlcmFsIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIGBvYmplY3RgLCBvciBudWxsIGlmIGBvYmplY3RgIGRvZXMgbm90IGhhdmVcbiAqIGFueSBrZXlzLlxuICovXG5mdW5jdGlvbiB0b09wdGlvbmFsTGl0ZXJhbE1hcChvYmplY3QsIG1hcHBlcikge1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3Qua2V5cyhvYmplY3QpLm1hcChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4geyBrZXksIHZhbHVlOiBtYXBwZXIodmFsdWUpLCBxdW90ZWQ6IHRydWUgfTtcbiAgICB9KTtcbiAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsTWFwKGVudHJpZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGlsZURlcGVuZGVuY2llcyhkZXBzKSB7XG4gICAgaWYgKGRlcHMgPT09ICdpbnZhbGlkJykge1xuICAgICAgICAvLyBUaGUgYGRlcHNgIGNhbiBiZSBzZXQgdG8gdGhlIHN0cmluZyBcImludmFsaWRcIiAgYnkgdGhlIGB1bndyYXBDb25zdHJ1Y3RvckRlcGVuZGVuY2llcygpYFxuICAgICAgICAvLyBmdW5jdGlvbiwgd2hpY2ggdHJpZXMgdG8gY29udmVydCBgQ29uc3RydWN0b3JEZXBzYCBpbnRvIGBSM0RlcGVuZGVuY3lNZXRhZGF0YVtdYC5cbiAgICAgICAgcmV0dXJuIGxpdGVyYWwoJ2ludmFsaWQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVwcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbChudWxsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKGRlcHMubWFwKGNvbXBpbGVEZXBlbmRlbmN5KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGlsZURlcGVuZGVuY3koZGVwKSB7XG4gICAgY29uc3QgZGVwTWV0YSA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVwTWV0YS5zZXQoJ3Rva2VuJywgZGVwLnRva2VuKTtcbiAgICBpZiAoZGVwLmF0dHJpYnV0ZU5hbWVUeXBlICE9PSBudWxsKSB7XG4gICAgICAgIGRlcE1ldGEuc2V0KCdhdHRyaWJ1dGUnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgaWYgKGRlcC5ob3N0KSB7XG4gICAgICAgIGRlcE1ldGEuc2V0KCdob3N0JywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIGlmIChkZXAub3B0aW9uYWwpIHtcbiAgICAgICAgZGVwTWV0YS5zZXQoJ29wdGlvbmFsJywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIGlmIChkZXAuc2VsZikge1xuICAgICAgICBkZXBNZXRhLnNldCgnc2VsZicsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBpZiAoZGVwLnNraXBTZWxmKSB7XG4gICAgICAgIGRlcE1ldGEuc2V0KCdza2lwU2VsZicsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwTWV0YS50b0xpdGVyYWxNYXAoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDUgPSAnMTIuMC4wJztcbi8qKlxuICogQ29tcGlsZSBhIGRpcmVjdGl2ZSBkZWNsYXJhdGlvbiBkZWZpbmVkIGJ5IHRoZSBgUjNEaXJlY3RpdmVNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlRGlyZWN0aXZlRnJvbU1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlRGlyZWN0aXZlRGVmaW5pdGlvbk1hcChtZXRhKTtcbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlY2xhcmVEaXJlY3RpdmUpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVEaXJlY3RpdmVUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIEdhdGhlcnMgdGhlIGRlY2xhcmF0aW9uIGZpZWxkcyBmb3IgYSBkaXJlY3RpdmUgaW50byBhIGBEZWZpbml0aW9uTWFwYC4gVGhpcyBhbGxvd3MgZm9yIHJldXNpbmdcbiAqIHRoaXMgbG9naWMgZm9yIGNvbXBvbmVudHMsIGFzIHRoZXkgZXh0ZW5kIHRoZSBkaXJlY3RpdmUgbWV0YWRhdGEuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpcmVjdGl2ZURlZmluaXRpb25NYXAobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdtaW5WZXJzaW9uJywgbGl0ZXJhbChNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kNSkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2ZXJzaW9uJywgbGl0ZXJhbCgnMTMuMS4zJykpO1xuICAgIC8vIGUuZy4gYHR5cGU6IE15RGlyZWN0aXZlYFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgIC8vIGUuZy4gYHNlbGVjdG9yOiAnc29tZS1kaXInYFxuICAgIGlmIChtZXRhLnNlbGVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdzZWxlY3RvcicsIGxpdGVyYWwobWV0YS5zZWxlY3RvcikpO1xuICAgIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaW5wdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5pbnB1dHMsIHRydWUpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnb3V0cHV0cycsIGNvbmRpdGlvbmFsbHlDcmVhdGVNYXBPYmplY3RMaXRlcmFsKG1ldGEub3V0cHV0cykpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdob3N0JywgY29tcGlsZUhvc3RNZXRhZGF0YShtZXRhLmhvc3QpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgncHJvdmlkZXJzJywgbWV0YS5wcm92aWRlcnMpO1xuICAgIGlmIChtZXRhLnF1ZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgncXVlcmllcycsIGxpdGVyYWxBcnIobWV0YS5xdWVyaWVzLm1hcChjb21waWxlUXVlcnkpKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnZpZXdRdWVyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZpZXdRdWVyaWVzJywgbGl0ZXJhbEFycihtZXRhLnZpZXdRdWVyaWVzLm1hcChjb21waWxlUXVlcnkpKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmV4cG9ydEFzICE9PSBudWxsKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdleHBvcnRBcycsIGFzTGl0ZXJhbChtZXRhLmV4cG9ydEFzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnVzZXNJbmhlcml0YW5jZSkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgndXNlc0luaGVyaXRhbmNlJywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmxpZmVjeWNsZS51c2VzT25DaGFuZ2VzKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd1c2VzT25DaGFuZ2VzJywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIGRlZmluaXRpb25NYXAuc2V0KCduZ0ltcG9ydCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5jb3JlKSk7XG4gICAgcmV0dXJuIGRlZmluaXRpb25NYXA7XG59XG4vKipcbiAqIENvbXBpbGVzIHRoZSBtZXRhZGF0YSBvZiBhIHNpbmdsZSBxdWVyeSBpbnRvIGl0cyBwYXJ0aWFsIGRlY2xhcmF0aW9uIGZvcm0gYXMgZGVjbGFyZWRcbiAqIGJ5IGBSM0RlY2xhcmVRdWVyeU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgY29uc3QgbWV0YSA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgbWV0YS5zZXQoJ3Byb3BlcnR5TmFtZScsIGxpdGVyYWwocXVlcnkucHJvcGVydHlOYW1lKSk7XG4gICAgaWYgKHF1ZXJ5LmZpcnN0KSB7XG4gICAgICAgIG1ldGEuc2V0KCdmaXJzdCcsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBtZXRhLnNldCgncHJlZGljYXRlJywgQXJyYXkuaXNBcnJheShxdWVyeS5wcmVkaWNhdGUpID8gYXNMaXRlcmFsKHF1ZXJ5LnByZWRpY2F0ZSkgOlxuICAgICAgICBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24ocXVlcnkucHJlZGljYXRlKSk7XG4gICAgaWYgKCFxdWVyeS5lbWl0RGlzdGluY3RDaGFuZ2VzT25seSkge1xuICAgICAgICAvLyBgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlgIGlzIHNwZWNpYWwgYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gYmUgYHRydWVgLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgZXhwbGljaXRseSBlbWl0IHRoZSBmaWVsZCwgYW5kIGV4cGxpY2l0bHkgcGxhY2UgaXQgb25seSB3aGVuIGl0J3MgYGZhbHNlYC5cbiAgICAgICAgbWV0YS5zZXQoJ2VtaXREaXN0aW5jdENoYW5nZXNPbmx5JywgbGl0ZXJhbChmYWxzZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGxpbmtlciB3aWxsIGFzc3VtZSB0aGF0IGFuIGFic2VudCBgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlgIGZsYWcgaXMgYnkgZGVmYXVsdCBgdHJ1ZWAuXG4gICAgfVxuICAgIGlmIChxdWVyeS5kZXNjZW5kYW50cykge1xuICAgICAgICBtZXRhLnNldCgnZGVzY2VuZGFudHMnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgbWV0YS5zZXQoJ3JlYWQnLCBxdWVyeS5yZWFkKTtcbiAgICBpZiAocXVlcnkuc3RhdGljKSB7XG4gICAgICAgIG1ldGEuc2V0KCdzdGF0aWMnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGEudG9MaXRlcmFsTWFwKCk7XG59XG4vKipcbiAqIENvbXBpbGVzIHRoZSBob3N0IG1ldGFkYXRhIGludG8gaXRzIHBhcnRpYWwgZGVjbGFyYXRpb24gZm9ybSBhcyBkZWNsYXJlZFxuICogaW4gYFIzRGVjbGFyZURpcmVjdGl2ZU1ldGFkYXRhWydob3N0J11gXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVIb3N0TWV0YWRhdGEobWV0YSkge1xuICAgIGNvbnN0IGhvc3RNZXRhZGF0YSA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgaG9zdE1ldGFkYXRhLnNldCgnYXR0cmlidXRlcycsIHRvT3B0aW9uYWxMaXRlcmFsTWFwKG1ldGEuYXR0cmlidXRlcywgZXhwcmVzc2lvbiA9PiBleHByZXNzaW9uKSk7XG4gICAgaG9zdE1ldGFkYXRhLnNldCgnbGlzdGVuZXJzJywgdG9PcHRpb25hbExpdGVyYWxNYXAobWV0YS5saXN0ZW5lcnMsIGxpdGVyYWwpKTtcbiAgICBob3N0TWV0YWRhdGEuc2V0KCdwcm9wZXJ0aWVzJywgdG9PcHRpb25hbExpdGVyYWxNYXAobWV0YS5wcm9wZXJ0aWVzLCBsaXRlcmFsKSk7XG4gICAgaWYgKG1ldGEuc3BlY2lhbEF0dHJpYnV0ZXMuc3R5bGVBdHRyKSB7XG4gICAgICAgIGhvc3RNZXRhZGF0YS5zZXQoJ3N0eWxlQXR0cmlidXRlJywgbGl0ZXJhbChtZXRhLnNwZWNpYWxBdHRyaWJ1dGVzLnN0eWxlQXR0cikpO1xuICAgIH1cbiAgICBpZiAobWV0YS5zcGVjaWFsQXR0cmlidXRlcy5jbGFzc0F0dHIpIHtcbiAgICAgICAgaG9zdE1ldGFkYXRhLnNldCgnY2xhc3NBdHRyaWJ1dGUnLCBsaXRlcmFsKG1ldGEuc3BlY2lhbEF0dHJpYnV0ZXMuY2xhc3NBdHRyKSk7XG4gICAgfVxuICAgIGlmIChob3N0TWV0YWRhdGEudmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGhvc3RNZXRhZGF0YS50b0xpdGVyYWxNYXAoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENvbXBpbGUgYSBjb21wb25lbnQgZGVjbGFyYXRpb24gZGVmaW5lZCBieSB0aGUgYFIzQ29tcG9uZW50TWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlRGVjbGFyZUNvbXBvbmVudEZyb21NZXRhZGF0YShtZXRhLCB0ZW1wbGF0ZSwgYWRkaXRpb25hbFRlbXBsYXRlSW5mbykge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBjcmVhdGVDb21wb25lbnREZWZpbml0aW9uTWFwKG1ldGEsIHRlbXBsYXRlLCBhZGRpdGlvbmFsVGVtcGxhdGVJbmZvKTtcbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmRlY2xhcmVDb21wb25lbnQpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVDb21wb25lbnRUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIEdhdGhlcnMgdGhlIGRlY2xhcmF0aW9uIGZpZWxkcyBmb3IgYSBjb21wb25lbnQgaW50byBhIGBEZWZpbml0aW9uTWFwYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50RGVmaW5pdGlvbk1hcChtZXRhLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IGNyZWF0ZURpcmVjdGl2ZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3RlbXBsYXRlJywgZ2V0VGVtcGxhdGVFeHByZXNzaW9uKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8pKTtcbiAgICBpZiAodGVtcGxhdGVJbmZvLmlzSW5saW5lKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdpc0lubGluZScsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgnc3R5bGVzJywgdG9PcHRpb25hbExpdGVyYWxBcnJheShtZXRhLnN0eWxlcywgbGl0ZXJhbCkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdjb21wb25lbnRzJywgY29tcGlsZVVzZWREaXJlY3RpdmVNZXRhZGF0YShtZXRhLCBkaXJlY3RpdmUgPT4gZGlyZWN0aXZlLmlzQ29tcG9uZW50ID09PSB0cnVlKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RpcmVjdGl2ZXMnLCBjb21waWxlVXNlZERpcmVjdGl2ZU1ldGFkYXRhKG1ldGEsIGRpcmVjdGl2ZSA9PiBkaXJlY3RpdmUuaXNDb21wb25lbnQgIT09IHRydWUpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgncGlwZXMnLCBjb21waWxlVXNlZFBpcGVNZXRhZGF0YShtZXRhKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZpZXdQcm92aWRlcnMnLCBtZXRhLnZpZXdQcm92aWRlcnMpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdhbmltYXRpb25zJywgbWV0YS5hbmltYXRpb25zKTtcbiAgICBpZiAobWV0YS5jaGFuZ2VEZXRlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnY2hhbmdlRGV0ZWN0aW9uJywgaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5KVxuICAgICAgICAgICAgLnByb3AoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbbWV0YS5jaGFuZ2VEZXRlY3Rpb25dKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmVuY2Fwc3VsYXRpb24gIT09IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdlbmNhcHN1bGF0aW9uJywgaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLlZpZXdFbmNhcHN1bGF0aW9uKS5wcm9wKFZpZXdFbmNhcHN1bGF0aW9uW21ldGEuZW5jYXBzdWxhdGlvbl0pKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaW50ZXJwb2xhdGlvbiAhPT0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRykge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaW50ZXJwb2xhdGlvbicsIGxpdGVyYWxBcnIoW2xpdGVyYWwobWV0YS5pbnRlcnBvbGF0aW9uLnN0YXJ0KSwgbGl0ZXJhbChtZXRhLmludGVycG9sYXRpb24uZW5kKV0pKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlLnByZXNlcnZlV2hpdGVzcGFjZXMgPT09IHRydWUpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ByZXNlcnZlV2hpdGVzcGFjZXMnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb25NYXA7XG59XG5mdW5jdGlvbiBnZXRUZW1wbGF0ZUV4cHJlc3Npb24odGVtcGxhdGUsIHRlbXBsYXRlSW5mbykge1xuICAgIC8vIElmIHRoZSB0ZW1wbGF0ZSBoYXMgYmVlbiBkZWZpbmVkIHVzaW5nIGEgZGlyZWN0IGxpdGVyYWwsIHdlIHVzZSB0aGF0IGV4cHJlc3Npb24gZGlyZWN0bHlcbiAgICAvLyB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLiBUaGlzIGlzIGVuc3VyZXMgcHJvcGVyIHNvdXJjZSBtYXBwaW5nIGZyb20gdGhlIHBhcnRpYWxseVxuICAgIC8vIGNvbXBpbGVkIGNvZGUgdG8gdGhlIHNvdXJjZSBmaWxlIGRlY2xhcmluZyB0aGUgdGVtcGxhdGUuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGNhcHR1cmVcbiAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFscyByZWZlcmVuY2VkIGluZGlyZWN0bHkgdGhyb3VnaCBhbiBpZGVudGlmaWVyLlxuICAgIGlmICh0ZW1wbGF0ZUluZm8uaW5saW5lVGVtcGxhdGVMaXRlcmFsRXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVJbmZvLmlubGluZVRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb247XG4gICAgfVxuICAgIC8vIElmIHRoZSB0ZW1wbGF0ZSBpcyBkZWZpbmVkIGlubGluZSBidXQgbm90IHRocm91Z2ggYSBsaXRlcmFsLCB0aGUgdGVtcGxhdGUgaGFzIGJlZW4gcmVzb2x2ZWRcbiAgICAvLyB0aHJvdWdoIHN0YXRpYyBpbnRlcnByZXRhdGlvbi4gV2UgY3JlYXRlIGEgbGl0ZXJhbCBidXQgY2Fubm90IHByb3ZpZGUgYW55IHNvdXJjZSBzcGFuLiBOb3RlXG4gICAgLy8gdGhhdCB3ZSBjYW5ub3QgdXNlIHRoZSBleHByZXNzaW9uIGRlZmluaW5nIHRoZSB0ZW1wbGF0ZSBiZWNhdXNlIHRoZSBsaW5rZXIgZXhwZWN0cyB0aGUgdGVtcGxhdGVcbiAgICAvLyB0byBiZSBkZWZpbmVkIGFzIGEgbGl0ZXJhbCBpbiB0aGUgZGVjbGFyYXRpb24uXG4gICAgaWYgKHRlbXBsYXRlSW5mby5pc0lubGluZSkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbCh0ZW1wbGF0ZUluZm8uY29udGVudCwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8vIFRoZSB0ZW1wbGF0ZSBpcyBleHRlcm5hbCBzbyB3ZSBtdXN0IHN5bnRoZXNpemUgYW4gZXhwcmVzc2lvbiBub2RlIHdpdGhcbiAgICAvLyB0aGUgYXBwcm9wcmlhdGUgc291cmNlLXNwYW4uXG4gICAgY29uc3QgY29udGVudHMgPSB0ZW1wbGF0ZUluZm8uY29udGVudDtcbiAgICBjb25zdCBmaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZShjb250ZW50cywgdGVtcGxhdGVJbmZvLnNvdXJjZVVybCk7XG4gICAgY29uc3Qgc3RhcnQgPSBuZXcgUGFyc2VMb2NhdGlvbihmaWxlLCAwLCAwLCAwKTtcbiAgICBjb25zdCBlbmQgPSBjb21wdXRlRW5kTG9jYXRpb24oZmlsZSwgY29udGVudHMpO1xuICAgIGNvbnN0IHNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBsaXRlcmFsKGNvbnRlbnRzLCBudWxsLCBzcGFuKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFbmRMb2NhdGlvbihmaWxlLCBjb250ZW50cykge1xuICAgIGNvbnN0IGxlbmd0aCA9IGNvbnRlbnRzLmxlbmd0aDtcbiAgICBsZXQgbGluZVN0YXJ0ID0gMDtcbiAgICBsZXQgbGFzdExpbmVTdGFydCA9IDA7XG4gICAgbGV0IGxpbmUgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgbGluZVN0YXJ0ID0gY29udGVudHMuaW5kZXhPZignXFxuJywgbGFzdExpbmVTdGFydCk7XG4gICAgICAgIGlmIChsaW5lU3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0ICsgMTtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGxpbmVTdGFydCAhPT0gLTEpO1xuICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbihmaWxlLCBsZW5ndGgsIGxpbmUsIGxlbmd0aCAtIGxhc3RMaW5lU3RhcnQpO1xufVxuLyoqXG4gKiBDb21waWxlcyB0aGUgZGlyZWN0aXZlcyBhcyByZWdpc3RlcmVkIGluIHRoZSBjb21wb25lbnQgbWV0YWRhdGEgaW50byBhbiBhcnJheSBsaXRlcmFsIG9mIHRoZVxuICogaW5kaXZpZHVhbCBkaXJlY3RpdmVzLiBJZiB0aGUgY29tcG9uZW50IGRvZXMgbm90IHVzZSBhbnkgZGlyZWN0aXZlcywgdGhlbiBudWxsIGlzIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBjb21waWxlVXNlZERpcmVjdGl2ZU1ldGFkYXRhKG1ldGEsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IHdyYXBUeXBlID0gbWV0YS5kZWNsYXJhdGlvbkxpc3RFbWl0TW9kZSAhPT0gMCAvKiBEaXJlY3QgKi8gP1xuICAgICAgICBnZW5lcmF0ZUZvcndhcmRSZWYgOlxuICAgICAgICAoZXhwcikgPT4gZXhwcjtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gbWV0YS5kaXJlY3RpdmVzLmZpbHRlcihwcmVkaWNhdGUpO1xuICAgIHJldHVybiB0b09wdGlvbmFsTGl0ZXJhbEFycmF5KGRpcmVjdGl2ZXMsIGRpcmVjdGl2ZSA9PiB7XG4gICAgICAgIGNvbnN0IGRpck1ldGEgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgICAgICBkaXJNZXRhLnNldCgndHlwZScsIHdyYXBUeXBlKGRpcmVjdGl2ZS50eXBlKSk7XG4gICAgICAgIGRpck1ldGEuc2V0KCdzZWxlY3RvcicsIGxpdGVyYWwoZGlyZWN0aXZlLnNlbGVjdG9yKSk7XG4gICAgICAgIGRpck1ldGEuc2V0KCdpbnB1dHMnLCB0b09wdGlvbmFsTGl0ZXJhbEFycmF5KGRpcmVjdGl2ZS5pbnB1dHMsIGxpdGVyYWwpKTtcbiAgICAgICAgZGlyTWV0YS5zZXQoJ291dHB1dHMnLCB0b09wdGlvbmFsTGl0ZXJhbEFycmF5KGRpcmVjdGl2ZS5vdXRwdXRzLCBsaXRlcmFsKSk7XG4gICAgICAgIGRpck1ldGEuc2V0KCdleHBvcnRBcycsIHRvT3B0aW9uYWxMaXRlcmFsQXJyYXkoZGlyZWN0aXZlLmV4cG9ydEFzLCBsaXRlcmFsKSk7XG4gICAgICAgIHJldHVybiBkaXJNZXRhLnRvTGl0ZXJhbE1hcCgpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb21waWxlcyB0aGUgcGlwZXMgYXMgcmVnaXN0ZXJlZCBpbiB0aGUgY29tcG9uZW50IG1ldGFkYXRhIGludG8gYW4gb2JqZWN0IGxpdGVyYWwsIHdoZXJlIHRoZVxuICogcGlwZSdzIG5hbWUgaXMgdXNlZCBhcyBrZXkgYW5kIGEgcmVmZXJlbmNlIHRvIGl0cyB0eXBlIGFzIHZhbHVlLiBJZiB0aGUgY29tcG9uZW50IGRvZXMgbm90IHVzZVxuICogYW55IHBpcGVzLCB0aGVuIG51bGwgaXMgcmV0dXJuZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVVc2VkUGlwZU1ldGFkYXRhKG1ldGEpIHtcbiAgICBpZiAobWV0YS5waXBlcy5zaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB3cmFwVHlwZSA9IG1ldGEuZGVjbGFyYXRpb25MaXN0RW1pdE1vZGUgIT09IDAgLyogRGlyZWN0ICovID9cbiAgICAgICAgZ2VuZXJhdGVGb3J3YXJkUmVmIDpcbiAgICAgICAgKGV4cHIpID0+IGV4cHI7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW25hbWUsIHBpcGVdIG9mIG1ldGEucGlwZXMpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiBuYW1lLCB2YWx1ZTogd3JhcFR5cGUocGlwZSksIHF1b3RlZDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdGVyYWxNYXAoZW50cmllcyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBFdmVyeSB0aW1lIHdlIG1ha2UgYSBicmVha2luZyBjaGFuZ2UgdG8gdGhlIGRlY2xhcmF0aW9uIGludGVyZmFjZSBvciBwYXJ0aWFsLWxpbmtlciBiZWhhdmlvciwgd2VcbiAqIG11c3QgdXBkYXRlIHRoaXMgY29uc3RhbnQgdG8gcHJldmVudCBvbGQgcGFydGlhbC1saW5rZXJzIGZyb20gaW5jb3JyZWN0bHkgcHJvY2Vzc2luZyB0aGVcbiAqIGRlY2xhcmF0aW9uLlxuICpcbiAqIERvIG5vdCBpbmNsdWRlIGFueSBwcmVyZWxlYXNlIGluIHRoZXNlIHZlcnNpb25zIGFzIHRoZXkgYXJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTiQ0ID0gJzEyLjAuMCc7XG5mdW5jdGlvbiBjb21waWxlRGVjbGFyZUZhY3RvcnlGdW5jdGlvbihtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ21pblZlcnNpb24nLCBsaXRlcmFsKE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTiQ0KSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZlcnNpb24nLCBsaXRlcmFsKCcxMy4xLjMnKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nSW1wb3J0JywgaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmNvcmUpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG1ldGEuaW50ZXJuYWxUeXBlKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnZGVwcycsIGNvbXBpbGVEZXBlbmRlbmNpZXMobWV0YS5kZXBzKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3RhcmdldCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5GYWN0b3J5VGFyZ2V0KS5wcm9wKEZhY3RvcnlUYXJnZXQkMVttZXRhLnRhcmdldF0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBleHByZXNzaW9uOiBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuZGVjbGFyZUZhY3RvcnkpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pLFxuICAgICAgICBzdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgdHlwZTogY3JlYXRlRmFjdG9yeVR5cGUobWV0YSksXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDMgPSAnMTIuMC4wJztcbi8qKlxuICogQ29tcGlsZSBhIEluamVjdGFibGUgZGVjbGFyYXRpb24gZGVmaW5lZCBieSB0aGUgYFIzSW5qZWN0YWJsZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVJbmplY3RhYmxlRnJvbU1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlSW5qZWN0YWJsZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5kZWNsYXJlSW5qZWN0YWJsZSkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSk7XG4gICAgY29uc3QgdHlwZSA9IGNyZWF0ZUluamVjdGFibGVUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIEdhdGhlcnMgdGhlIGRlY2xhcmF0aW9uIGZpZWxkcyBmb3IgYSBJbmplY3RhYmxlIGludG8gYSBgRGVmaW5pdGlvbk1hcGAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluamVjdGFibGVEZWZpbml0aW9uTWFwKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbWluVmVyc2lvbicsIGxpdGVyYWwoTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDMpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndmVyc2lvbicsIGxpdGVyYWwoJzEzLjEuMycpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbmdJbXBvcnQnLCBpbXBvcnRFeHByKElkZW50aWZpZXJzJDEuY29yZSkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgIC8vIE9ubHkgZ2VuZXJhdGUgcHJvdmlkZWRJbiBwcm9wZXJ0eSBpZiBpdCBoYXMgYSBub24tbnVsbCB2YWx1ZVxuICAgIGlmIChtZXRhLnByb3ZpZGVkSW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwcm92aWRlZEluID0gY29udmVydEZyb21NYXliZUZvcndhcmRSZWZFeHByZXNzaW9uKG1ldGEucHJvdmlkZWRJbik7XG4gICAgICAgIGlmIChwcm92aWRlZEluLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgncHJvdmlkZWRJbicsIHByb3ZpZGVkSW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtZXRhLnVzZUNsYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3VzZUNsYXNzJywgY29udmVydEZyb21NYXliZUZvcndhcmRSZWZFeHByZXNzaW9uKG1ldGEudXNlQ2xhc3MpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEudXNlRXhpc3RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgndXNlRXhpc3RpbmcnLCBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24obWV0YS51c2VFeGlzdGluZykpO1xuICAgIH1cbiAgICBpZiAobWV0YS51c2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd1c2VWYWx1ZScsIGNvbnZlcnRGcm9tTWF5YmVGb3J3YXJkUmVmRXhwcmVzc2lvbihtZXRhLnVzZVZhbHVlKSk7XG4gICAgfVxuICAgIC8vIEZhY3RvcmllcyBkbyBub3QgY29udGFpbiBgRm9yd2FyZFJlZmBzIHNpbmNlIGFueSB0eXBlcyBhcmUgYWxyZWFkeSB3cmFwcGVkIGluIGEgZnVuY3Rpb24gY2FsbFxuICAgIC8vIHNvIHRoZSB0eXBlcyB3aWxsIG5vdCBiZSBlYWdlcmx5IGV2YWx1YXRlZC4gVGhlcmVmb3JlIHdlIGRvIG5vdCBuZWVkIHRvIHByb2Nlc3MgdGhpcyBleHByZXNzaW9uXG4gICAgLy8gd2l0aCBgY29udmVydEZyb21Qcm92aWRlckV4cHJlc3Npb24oKWAuXG4gICAgaWYgKG1ldGEudXNlRmFjdG9yeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd1c2VGYWN0b3J5JywgbWV0YS51c2VGYWN0b3J5KTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZXBzJywgbGl0ZXJhbEFycihtZXRhLmRlcHMubWFwKGNvbXBpbGVEZXBlbmRlbmN5KSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbk1hcDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDIgPSAnMTIuMC4wJztcbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlSW5qZWN0b3JGcm9tTWV0YWRhdGEobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBjcmVhdGVJbmplY3RvckRlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5kZWNsYXJlSW5qZWN0b3IpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVJbmplY3RvclR5cGUobWV0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50czogW10gfTtcbn1cbi8qKlxuICogR2F0aGVycyB0aGUgZGVjbGFyYXRpb24gZmllbGRzIGZvciBhbiBJbmplY3RvciBpbnRvIGEgYERlZmluaXRpb25NYXBgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmplY3RvckRlZmluaXRpb25NYXAobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdtaW5WZXJzaW9uJywgbGl0ZXJhbChNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kMikpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2ZXJzaW9uJywgbGl0ZXJhbCgnMTMuMS4zJykpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCduZ0ltcG9ydCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5jb3JlKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3R5cGUnLCBtZXRhLmludGVybmFsVHlwZSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3Byb3ZpZGVycycsIG1ldGEucHJvdmlkZXJzKTtcbiAgICBpZiAobWV0YS5pbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2ltcG9ydHMnLCBsaXRlcmFsQXJyKG1ldGEuaW1wb3J0cykpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbk1hcDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDEgPSAnMTIuMC4wJztcbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlTmdNb2R1bGVGcm9tTWV0YWRhdGEobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBjcmVhdGVOZ01vZHVsZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5kZWNsYXJlTmdNb2R1bGUpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVOZ01vZHVsZVR5cGUobWV0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50czogW10gfTtcbn1cbi8qKlxuICogR2F0aGVycyB0aGUgZGVjbGFyYXRpb24gZmllbGRzIGZvciBhbiBOZ01vZHVsZSBpbnRvIGEgYERlZmluaXRpb25NYXBgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOZ01vZHVsZURlZmluaXRpb25NYXAobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdtaW5WZXJzaW9uJywgbGl0ZXJhbChNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kMSkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2ZXJzaW9uJywgbGl0ZXJhbCgnMTMuMS4zJykpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCduZ0ltcG9ydCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5jb3JlKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3R5cGUnLCBtZXRhLmludGVybmFsVHlwZSk7XG4gICAgLy8gV2Ugb25seSBnZW5lcmF0ZSB0aGUga2V5cyBpbiB0aGUgbWV0YWRhdGEgaWYgdGhlIGFycmF5cyBjb250YWluIHZhbHVlcy5cbiAgICAvLyBXZSBtdXN0IHdyYXAgdGhlIGFycmF5cyBpbnNpZGUgYSBmdW5jdGlvbiBpZiBhbnkgb2YgdGhlIHZhbHVlcyBhcmUgYSBmb3J3YXJkIHJlZmVyZW5jZSB0byBhXG4gICAgLy8gbm90LXlldC1kZWNsYXJlZCBjbGFzcy4gVGhpcyBpcyB0byBzdXBwb3J0IEpJVCBleGVjdXRpb24gb2YgdGhlIGDJtcm1bmdEZWNsYXJlTmdNb2R1bGUoKWAgY2FsbC5cbiAgICAvLyBJbiB0aGUgbGlua2VyIHRoZXNlIHdyYXBwZXJzIGFyZSBzdHJpcHBlZCBhbmQgdGhlbiByZWFwcGxpZWQgZm9yIHRoZSBgybXJtWRlZmluZU5nTW9kdWxlKClgIGNhbGwuXG4gICAgaWYgKG1ldGEuYm9vdHN0cmFwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2Jvb3RzdHJhcCcsIHJlZnNUb0FycmF5KG1ldGEuYm9vdHN0cmFwLCBtZXRhLmNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmRlY2xhcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZWNsYXJhdGlvbnMnLCByZWZzVG9BcnJheShtZXRhLmRlY2xhcmF0aW9ucywgbWV0YS5jb250YWluc0ZvcndhcmREZWNscykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5pbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2ltcG9ydHMnLCByZWZzVG9BcnJheShtZXRhLmltcG9ydHMsIG1ldGEuY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdleHBvcnRzJywgcmVmc1RvQXJyYXkobWV0YS5leHBvcnRzLCBtZXRhLmNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnNjaGVtYXMgIT09IG51bGwgJiYgbWV0YS5zY2hlbWFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3NjaGVtYXMnLCBsaXRlcmFsQXJyKG1ldGEuc2NoZW1hcy5tYXAocmVmID0+IHJlZi52YWx1ZSkpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaWQgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2lkJywgbWV0YS5pZCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uTWFwO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogRXZlcnkgdGltZSB3ZSBtYWtlIGEgYnJlYWtpbmcgY2hhbmdlIHRvIHRoZSBkZWNsYXJhdGlvbiBpbnRlcmZhY2Ugb3IgcGFydGlhbC1saW5rZXIgYmVoYXZpb3IsIHdlXG4gKiBtdXN0IHVwZGF0ZSB0aGlzIGNvbnN0YW50IHRvIHByZXZlbnQgb2xkIHBhcnRpYWwtbGlua2VycyBmcm9tIGluY29ycmVjdGx5IHByb2Nlc3NpbmcgdGhlXG4gKiBkZWNsYXJhdGlvbi5cbiAqXG4gKiBEbyBub3QgaW5jbHVkZSBhbnkgcHJlcmVsZWFzZSBpbiB0aGVzZSB2ZXJzaW9ucyBhcyB0aGV5IGFyZSBpZ25vcmVkLlxuICovXG5jb25zdCBNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04gPSAnMTIuMC4wJztcbi8qKlxuICogQ29tcGlsZSBhIFBpcGUgZGVjbGFyYXRpb24gZGVmaW5lZCBieSB0aGUgYFIzUGlwZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVQaXBlRnJvbU1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlUGlwZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMkMS5kZWNsYXJlUGlwZSkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSk7XG4gICAgY29uc3QgdHlwZSA9IGNyZWF0ZVBpcGVUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIEdhdGhlcnMgdGhlIGRlY2xhcmF0aW9uIGZpZWxkcyBmb3IgYSBQaXBlIGludG8gYSBgRGVmaW5pdGlvbk1hcGAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBpcGVEZWZpbml0aW9uTWFwKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbWluVmVyc2lvbicsIGxpdGVyYWwoTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZlcnNpb24nLCBsaXRlcmFsKCcxMy4xLjMnKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nSW1wb3J0JywgaW1wb3J0RXhwcihJZGVudGlmaWVycyQxLmNvcmUpKTtcbiAgICAvLyBlLmcuIGB0eXBlOiBNeVBpcGVgXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3R5cGUnLCBtZXRhLmludGVybmFsVHlwZSk7XG4gICAgLy8gZS5nLiBgbmFtZTogXCJteVBpcGVcImBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbmFtZScsIGxpdGVyYWwobWV0YS5waXBlTmFtZSkpO1xuICAgIGlmIChtZXRhLnB1cmUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGUuZy4gYHB1cmU6IGZhbHNlYFxuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgncHVyZScsIGxpdGVyYWwobWV0YS5wdXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uTWFwO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIFRoaXMgZmlsZSBvbmx5IHJlZXhwb3J0cyBjb250ZW50IG9mIHRoZSBgc3JjYCBmb2xkZXIuIEtlZXAgaXQgdGhhdCB3YXkuXG4vLyBUaGlzIGZ1bmN0aW9uIGNhbGwgaGFzIGEgZ2xvYmFsIHNpZGUgZWZmZWN0cyBhbmQgcHVibGlzaGVzIHRoZSBjb21waWxlciBpbnRvIGdsb2JhbCBuYW1lc3BhY2UgZm9yXG4vLyB0aGUgbGF0ZSBiaW5kaW5nIG9mIHRoZSBDb21waWxlciB0byB0aGUgQGFuZ3VsYXIvY29yZSBmb3Igaml0IGNvbXBpbGF0aW9uLlxucHVibGlzaEZhY2FkZShfZ2xvYmFsKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBUaGlzIGZpbGUgb25seSByZWV4cG9ydHMgY29udGVudCBvZiB0aGUgYHNyY2AgZm9sZGVyLiBLZWVwIGl0IHRoYXQgd2F5LlxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmV4cG9ydCB7IEFTVCwgQVNUV2l0aE5hbWUsIEFTVFdpdGhTb3VyY2UsIEFic29sdXRlU291cmNlU3BhbiwgQXJyYXlUeXBlLCBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lciwgQXN0VHJhbnNmb3JtZXIsIEF0dHJpYnV0ZSwgQmluYXJ5LCBCaW5hcnlPcGVyYXRvciwgQmluYXJ5T3BlcmF0b3JFeHByLCBCaW5kaW5nUGlwZSwgQm91bmRFbGVtZW50UHJvcGVydHksIEJ1aWx0aW5UeXBlLCBCdWlsdGluVHlwZU5hbWUsIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsIENhbGwsIENoYWluLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tbWFFeHByLCBDb21tZW50LCBDb21waWxlckNvbmZpZywgQ29uZGl0aW9uYWwsIENvbmRpdGlvbmFsRXhwciwgQ29uc3RhbnRQb29sLCBDc3NTZWxlY3RvciwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRywgRFlOQU1JQ19UWVBFLCBEZWNsYXJlRnVuY3Rpb25TdG10LCBEZWNsYXJlVmFyU3RtdCwgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBFT0YsIEVsZW1lbnQsIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgRW1pdHRlclZpc2l0b3JDb250ZXh0LCBFbXB0eUV4cHIsIEV4cGFuc2lvbiwgRXhwYW5zaW9uQ2FzZSwgRXhwcmVzc2lvbiwgRXhwcmVzc2lvbkJpbmRpbmcsIEV4cHJlc3Npb25TdGF0ZW1lbnQsIEV4cHJlc3Npb25UeXBlLCBFeHRlcm5hbEV4cHIsIEV4dGVybmFsUmVmZXJlbmNlLCBGYWN0b3J5VGFyZ2V0JDEgYXMgRmFjdG9yeVRhcmdldCwgRnVuY3Rpb25FeHByLCBIdG1sUGFyc2VyLCBIdG1sVGFnRGVmaW5pdGlvbiwgSTE4Tkh0bWxQYXJzZXIsIElkZW50aWZpZXJzLCBJZlN0bXQsIEltcGxpY2l0UmVjZWl2ZXIsIEluc3RhbnRpYXRlRXhwciwgSW50ZXJwb2xhdGlvbiwgSW50ZXJwb2xhdGlvbkNvbmZpZywgSW52b2tlRnVuY3Rpb25FeHByLCBKU0RvY0NvbW1lbnQsIEppdEV2YWx1YXRvciwgS2V5ZWRSZWFkLCBLZXllZFdyaXRlLCBMZWFkaW5nQ29tbWVudCwgTGV4ZXIsIExpdGVyYWxBcnJheSwgTGl0ZXJhbEFycmF5RXhwciwgTGl0ZXJhbEV4cHIsIExpdGVyYWxNYXAsIExpdGVyYWxNYXBFeHByLCBMaXRlcmFsUHJpbWl0aXZlLCBMb2NhbGl6ZWRTdHJpbmcsIE1hcFR5cGUsIE1lc3NhZ2VCdW5kbGUsIE5PTkVfVFlQRSwgTk9fRVJST1JTX1NDSEVNQSwgTm9kZVdpdGhJMThuLCBOb25OdWxsQXNzZXJ0LCBOb3RFeHByLCBQYXJzZUVycm9yLCBQYXJzZUVycm9yTGV2ZWwsIFBhcnNlTG9jYXRpb24sIFBhcnNlU291cmNlRmlsZSwgUGFyc2VTb3VyY2VTcGFuLCBQYXJzZVNwYW4sIFBhcnNlVHJlZVJlc3VsdCwgUGFyc2VkRXZlbnQsIFBhcnNlZFByb3BlcnR5LCBQYXJzZWRQcm9wZXJ0eVR5cGUsIFBhcnNlZFZhcmlhYmxlLCBQYXJzZXIkMSBhcyBQYXJzZXIsIFBhcnNlckVycm9yLCBQcmVmaXhOb3QsIFByb3BlcnR5UmVhZCwgUHJvcGVydHlXcml0ZSwgUXVvdGUsIFIzQm91bmRUYXJnZXQsIElkZW50aWZpZXJzJDEgYXMgUjNJZGVudGlmaWVycywgUjNUYXJnZXRCaW5kZXIsIFJlYWRLZXlFeHByLCBSZWFkUHJvcEV4cHIsIFJlYWRWYXJFeHByLCBSZWN1cnNpdmVBc3RWaXNpdG9yLCBSZWN1cnNpdmVWaXNpdG9yLCBSZXNvdXJjZUxvYWRlciwgUmV0dXJuU3RhdGVtZW50LCBTVFJJTkdfVFlQRSwgU2FmZUtleWVkUmVhZCwgU2FmZVByb3BlcnR5UmVhZCwgU2VsZWN0b3JDb250ZXh0LCBTZWxlY3Rvckxpc3RDb250ZXh0LCBTZWxlY3Rvck1hdGNoZXIsIFNlcmlhbGl6ZXIsIFNwbGl0SW50ZXJwb2xhdGlvbiwgU3RhdGVtZW50LCBTdG10TW9kaWZpZXIsIFRhZ0NvbnRlbnRUeXBlLCBUYWdnZWRUZW1wbGF0ZUV4cHIsIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0LCBUZW1wbGF0ZUxpdGVyYWwsIFRlbXBsYXRlTGl0ZXJhbEVsZW1lbnQsIFRleHQsIFRoaXNSZWNlaXZlciwgQm91bmRBdHRyaWJ1dGUgYXMgVG1wbEFzdEJvdW5kQXR0cmlidXRlLCBCb3VuZEV2ZW50IGFzIFRtcGxBc3RCb3VuZEV2ZW50LCBCb3VuZFRleHQgYXMgVG1wbEFzdEJvdW5kVGV4dCwgQ29udGVudCBhcyBUbXBsQXN0Q29udGVudCwgRWxlbWVudCQxIGFzIFRtcGxBc3RFbGVtZW50LCBJY3UkMSBhcyBUbXBsQXN0SWN1LCBSZWN1cnNpdmVWaXNpdG9yJDEgYXMgVG1wbEFzdFJlY3Vyc2l2ZVZpc2l0b3IsIFJlZmVyZW5jZSBhcyBUbXBsQXN0UmVmZXJlbmNlLCBUZW1wbGF0ZSBhcyBUbXBsQXN0VGVtcGxhdGUsIFRleHQkMyBhcyBUbXBsQXN0VGV4dCwgVGV4dEF0dHJpYnV0ZSBhcyBUbXBsQXN0VGV4dEF0dHJpYnV0ZSwgVmFyaWFibGUgYXMgVG1wbEFzdFZhcmlhYmxlLCBUb2tlbiwgVG9rZW5UeXBlLCBUcmVlRXJyb3IsIFR5cGUsIFR5cGVNb2RpZmllciwgVHlwZW9mRXhwciwgVW5hcnksIFVuYXJ5T3BlcmF0b3IsIFVuYXJ5T3BlcmF0b3JFeHByLCBWRVJTSU9OLCBWYXJpYWJsZUJpbmRpbmcsIFZlcnNpb24sIFZpZXdFbmNhcHN1bGF0aW9uLCBXcmFwcGVkTm9kZUV4cHIsIFdyaXRlS2V5RXhwciwgV3JpdGVQcm9wRXhwciwgV3JpdGVWYXJFeHByLCBYbGlmZiwgWGxpZmYyLCBYbWIsIFhtbFBhcnNlciwgWHRiLCBfUGFyc2VBU1QsIGNvbXBpbGVDbGFzc01ldGFkYXRhLCBjb21waWxlQ29tcG9uZW50RnJvbU1ldGFkYXRhLCBjb21waWxlRGVjbGFyZUNsYXNzTWV0YWRhdGEsIGNvbXBpbGVEZWNsYXJlQ29tcG9uZW50RnJvbU1ldGFkYXRhLCBjb21waWxlRGVjbGFyZURpcmVjdGl2ZUZyb21NZXRhZGF0YSwgY29tcGlsZURlY2xhcmVGYWN0b3J5RnVuY3Rpb24sIGNvbXBpbGVEZWNsYXJlSW5qZWN0YWJsZUZyb21NZXRhZGF0YSwgY29tcGlsZURlY2xhcmVJbmplY3RvckZyb21NZXRhZGF0YSwgY29tcGlsZURlY2xhcmVOZ01vZHVsZUZyb21NZXRhZGF0YSwgY29tcGlsZURlY2xhcmVQaXBlRnJvbU1ldGFkYXRhLCBjb21waWxlRGlyZWN0aXZlRnJvbU1ldGFkYXRhLCBjb21waWxlRmFjdG9yeUZ1bmN0aW9uLCBjb21waWxlSW5qZWN0YWJsZSwgY29tcGlsZUluamVjdG9yLCBjb21waWxlTmdNb2R1bGUsIGNvbXBpbGVQaXBlRnJvbU1ldGFkYXRhLCBjb21wdXRlTXNnSWQsIGNvcmUsIGNyZWF0ZUluamVjdGFibGVUeXBlLCBjcmVhdGVNYXlCZUZvcndhcmRSZWZFeHByZXNzaW9uLCBkZXZPbmx5R3VhcmRlZEV4cHJlc3Npb24sIGVtaXREaXN0aW5jdENoYW5nZXNPbmx5RGVmYXVsdFZhbHVlLCBnZXRIdG1sVGFnRGVmaW5pdGlvbiwgZ2V0TnNQcmVmaXgsIGdldFNhZmVQcm9wZXJ0eUFjY2Vzc1N0cmluZywgaWRlbnRpZmllck5hbWUsIGlzSWRlbnRpZmllciwgaXNOZ0NvbnRhaW5lciwgaXNOZ0NvbnRlbnQsIGlzTmdUZW1wbGF0ZSwganNEb2NDb21tZW50LCBsZWFkaW5nQ29tbWVudCwgbGl0ZXJhbE1hcCwgbWFrZUJpbmRpbmdQYXJzZXIsIG1lcmdlTnNBbmROYW1lLCBvdXRwdXRfYXN0IGFzIG91dHB1dEFzdCwgcGFyc2VIb3N0QmluZGluZ3MsIHBhcnNlVGVtcGxhdGUsIHByZXNlcnZlV2hpdGVzcGFjZXNEZWZhdWx0LCBwdWJsaXNoRmFjYWRlLCByM0ppdFR5cGVTb3VyY2VTcGFuLCBzYW5pdGl6ZUlkZW50aWZpZXIsIHNwbGl0TnNOYW1lLCB2ZXJpZnlIb3N0QmluZGluZ3MsIHZpc2l0QWxsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21waWxlci5tanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@angular/compiler/fesm2015/compiler.mjs\n");

/***/ })

}]);