(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[50],{

/***/ "./node_modules/@angular-eslint/bundled-angular-compiler/dist/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@angular-eslint/bundled-angular-compiler/dist/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v14.0.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexports.TagContentType = void 0;\n(function (TagContentType) {\n    TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n    TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n    TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n})(exports.TagContentType || (exports.TagContentType = {}));\nfunction splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    const colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex === -1) {\n        throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n// `<ng-container>` tags work the same regardless the namespace\nfunction isNgContainer(tagName) {\n    return splitNsName(tagName)[1] === 'ng-container';\n}\n// `<ng-content>` tags work the same regardless the namespace\nfunction isNgContent(tagName) {\n    return splitNsName(tagName)[1] === 'ng-content';\n}\n// `<ng-template>` tags work the same regardless the namespace\nfunction isNgTemplate(tagName) {\n    return splitNsName(tagName)[1] === 'ng-template';\n}\nfunction getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\nfunction mergeNsAndName(prefix, localName) {\n    return prefix ? `:${prefix}:${localName}` : localName;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass HtmlTagDefinition {\n    constructor({ closedByChildren, implicitNamespacePrefix, contentType = exports.TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false, preventNamespaceInheritance = false } = {}) {\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        this.canSelfClose = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n        this.preventNamespaceInheritance = preventNamespaceInheritance;\n    }\n    isClosedByChild(name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    }\n    getContentType(prefix) {\n        if (typeof this.contentType === 'object') {\n            const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n            return overrideType !== null && overrideType !== void 0 ? overrideType : this.contentType.default;\n        }\n        return this.contentType;\n    }\n}\nlet _DEFAULT_TAG_DEFINITION;\n// see https://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nlet TAG_DEFINITIONS;\nfunction getHtmlTagDefinition(tagName) {\n    var _a, _b;\n    if (!TAG_DEFINITIONS) {\n        _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n        TAG_DEFINITIONS = {\n            'base': new HtmlTagDefinition({ isVoid: true }),\n            'meta': new HtmlTagDefinition({ isVoid: true }),\n            'area': new HtmlTagDefinition({ isVoid: true }),\n            'embed': new HtmlTagDefinition({ isVoid: true }),\n            'link': new HtmlTagDefinition({ isVoid: true }),\n            'img': new HtmlTagDefinition({ isVoid: true }),\n            'input': new HtmlTagDefinition({ isVoid: true }),\n            'param': new HtmlTagDefinition({ isVoid: true }),\n            'hr': new HtmlTagDefinition({ isVoid: true }),\n            'br': new HtmlTagDefinition({ isVoid: true }),\n            'source': new HtmlTagDefinition({ isVoid: true }),\n            'track': new HtmlTagDefinition({ isVoid: true }),\n            'wbr': new HtmlTagDefinition({ isVoid: true }),\n            'p': new HtmlTagDefinition({\n                closedByChildren: [\n                    'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',\n                    'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',\n                    'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',\n                    'p', 'pre', 'section', 'table', 'ul'\n                ],\n                closedByParent: true\n            }),\n            'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n            'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n            'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n            'tr': new HtmlTagDefinition({ closedByChildren: ['tr'], closedByParent: true }),\n            'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'col': new HtmlTagDefinition({ isVoid: true }),\n            'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n            'foreignObject': new HtmlTagDefinition({\n                // Usually the implicit namespace here would be redundant since it will be inherited from\n                // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser\n                // works is that the parent node of an end tag is its own start tag which means that\n                // the `preventNamespaceInheritance` on `foreignObject` would have it default to the\n                // implicit namespace which is `html`, unless specified otherwise.\n                implicitNamespacePrefix: 'svg',\n                // We want to prevent children of foreignObject from inheriting its namespace, because\n                // the point of the element is to allow nodes from other namespaces to be inserted.\n                preventNamespaceInheritance: true,\n            }),\n            'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n            'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n            'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n            'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n            'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n            'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n            'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n            'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'style': new HtmlTagDefinition({ contentType: exports.TagContentType.RAW_TEXT }),\n            'script': new HtmlTagDefinition({ contentType: exports.TagContentType.RAW_TEXT }),\n            'title': new HtmlTagDefinition({\n                // The browser supports two separate `title` tags which have to use\n                // a different content type: `HTMLTitleElement` and `SVGTitleElement`\n                contentType: { default: exports.TagContentType.ESCAPABLE_RAW_TEXT, svg: exports.TagContentType.PARSABLE_DATA }\n            }),\n            'textarea': new HtmlTagDefinition({ contentType: exports.TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n        };\n    }\n    // We have to make both a case-sensitive and a case-insensitive lookup, because\n    // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.\n    return (_b = (_a = TAG_DEFINITIONS[tagName]) !== null && _a !== void 0 ? _a : TAG_DEFINITIONS[tagName.toLowerCase()]) !== null && _b !== void 0 ? _b : _DEFAULT_TAG_DEFINITION;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + // 1: \":not(\"\n    '(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    // 4: attribute; 5: attribute_string; 6: attribute_value\n    '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' + // 7: \")\"\n    '(\\\\s*,\\\\s*)', // 8: \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nclass CssSelector {\n    constructor() {\n        this.element = null;\n        this.classNames = [];\n        /**\n         * The selectors are encoded in pairs where:\n         * - even locations are attribute names\n         * - odd locations are attribute values.\n         *\n         * Example:\n         * Selector: `[key1=value1][key2]` would parse to:\n         * ```\n         * ['key1', 'value1', 'key2', '']\n         * ```\n         */\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    static parse(selector) {\n        const results = [];\n        const _addResult = (res, cssSel) => {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        let cssSelector = new CssSelector();\n        let match;\n        let current = cssSelector;\n        let inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1 /* SelectorRegexp.NOT */]) {\n                if (inNot) {\n                    throw new Error('Nesting :not in a selector is not allowed');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            const tag = match[2 /* SelectorRegexp.TAG */];\n            if (tag) {\n                const prefix = match[3 /* SelectorRegexp.PREFIX */];\n                if (prefix === '#') {\n                    // #hash\n                    current.addAttribute('id', tag.slice(1));\n                }\n                else if (prefix === '.') {\n                    // Class\n                    current.addClassName(tag.slice(1));\n                }\n                else {\n                    // Element\n                    current.setElement(tag);\n                }\n            }\n            const attribute = match[4 /* SelectorRegexp.ATTRIBUTE */];\n            if (attribute) {\n                current.addAttribute(current.unescapeAttribute(attribute), match[6 /* SelectorRegexp.ATTRIBUTE_VALUE */]);\n            }\n            if (match[7 /* SelectorRegexp.NOT_END */]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8 /* SelectorRegexp.SEPARATOR */]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    }\n    /**\n     * Unescape `\\$` sequences from the CSS attribute selector.\n     *\n     * This is needed because `$` can have a special meaning in CSS selectors,\n     * but we might want to match an attribute that contains `$`.\n     * [MDN web link for more\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n     * @param attr the attribute to unescape.\n     * @returns the unescaped string.\n     */\n    unescapeAttribute(attr) {\n        let result = '';\n        let escaping = false;\n        for (let i = 0; i < attr.length; i++) {\n            const char = attr.charAt(i);\n            if (char === '\\\\') {\n                escaping = true;\n                continue;\n            }\n            if (char === '$' && !escaping) {\n                throw new Error(`Error in attribute selector \"${attr}\". ` +\n                    `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n            }\n            escaping = false;\n            result += char;\n        }\n        return result;\n    }\n    /**\n     * Escape `$` sequences from the CSS attribute selector.\n     *\n     * This is needed because `$` can have a special meaning in CSS selectors,\n     * with this method we are escaping `$` with `\\$'.\n     * [MDN web link for more\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n     * @param attr the attribute to escape.\n     * @returns the escaped string.\n     */\n    escapeAttribute(attr) {\n        return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n    }\n    isElementSelector() {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    }\n    hasElementSelector() {\n        return !!this.element;\n    }\n    setElement(element = null) {\n        this.element = element;\n    }\n    /** Gets a template string for an element that matches the selector. */\n    getMatchingElementTemplate() {\n        const tagName = this.element || 'div';\n        const classAttr = this.classNames.length > 0 ? ` class=\"${this.classNames.join(' ')}\"` : '';\n        let attrs = '';\n        for (let i = 0; i < this.attrs.length; i += 2) {\n            const attrName = this.attrs[i];\n            const attrValue = this.attrs[i + 1] !== '' ? `=\"${this.attrs[i + 1]}\"` : '';\n            attrs += ` ${attrName}${attrValue}`;\n        }\n        return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :\n            `<${tagName}${classAttr}${attrs}></${tagName}>`;\n    }\n    getAttrs() {\n        const result = [];\n        if (this.classNames.length > 0) {\n            result.push('class', this.classNames.join(' '));\n        }\n        return result.concat(this.attrs);\n    }\n    addAttribute(name, value = '') {\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    }\n    addClassName(name) {\n        this.classNames.push(name.toLowerCase());\n    }\n    toString() {\n        let res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(klass => res += `.${klass}`);\n        }\n        if (this.attrs) {\n            for (let i = 0; i < this.attrs.length; i += 2) {\n                const name = this.escapeAttribute(this.attrs[i]);\n                const value = this.attrs[i + 1];\n                res += `[${name}${value ? '=' + value : ''}]`;\n            }\n        }\n        this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n        return res;\n    }\n}\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nclass SelectorMatcher {\n    constructor() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    static createNotMatcher(notSelectors) {\n        const notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    }\n    addSelectables(cssSelectors, callbackCtxt) {\n        let listContext = null;\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (let i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    }\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param cssSelector A css selector\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n     */\n    _addSelectable(cssSelector, callbackCtxt, listContext) {\n        let matcher = this;\n        const element = cssSelector.element;\n        const classNames = cssSelector.classNames;\n        const attrs = cssSelector.attrs;\n        const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            const isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (let i = 0; i < classNames.length; i++) {\n                const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                const className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (let i = 0; i < attrs.length; i += 2) {\n                const isTerminal = i === attrs.length - 2;\n                const name = attrs[i];\n                const value = attrs[i + 1];\n                if (isTerminal) {\n                    const terminalMap = matcher._attrValueMap;\n                    let terminalValuesMap = terminalMap.get(name);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    const partialMap = matcher._attrValuePartialMap;\n                    let partialValuesMap = partialMap.get(name);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    }\n    _addTerminal(map, name, selectable) {\n        let terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    }\n    _addPartial(map, name) {\n        let matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    }\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param cssSelector A css selector\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return boolean true if a match was found\n     */\n    match(cssSelector, matchedCallback) {\n        let result = false;\n        const element = cssSelector.element;\n        const classNames = cssSelector.classNames;\n        const attrs = cssSelector.attrs;\n        for (let i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (let i = 0; i < classNames.length; i++) {\n                const className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (let i = 0; i < attrs.length; i += 2) {\n                const name = attrs[i];\n                const value = attrs[i + 1];\n                const terminalValuesMap = this._attrValueMap.get(name);\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                const partialValuesMap = this._attrValuePartialMap.get(name);\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    }\n    /** @internal */\n    _matchTerminal(map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        let selectables = map.get(name) || [];\n        const starSelectables = map.get('*');\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        let selectable;\n        let result = false;\n        for (let i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    }\n    /** @internal */\n    _matchPartial(map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        const nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    }\n}\nclass SelectorListContext {\n    constructor(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n}\n// Store context to pass back selector and context when a selector is matched\nclass SelectorContext {\n    constructor(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    finalize(cssSelector, callback) {\n        let result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nconst emitDistinctChangesOnlyDefaultValue = true;\nexports.ViewEncapsulation = void 0;\n(function (ViewEncapsulation) {\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));\nexports.ChangeDetectionStrategy = void 0;\n(function (ChangeDetectionStrategy) {\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));\nconst CUSTOM_ELEMENTS_SCHEMA = {\n    name: 'custom-elements'\n};\nconst NO_ERRORS_SCHEMA = {\n    name: 'no-errors-schema'\n};\nconst Type$1 = Function;\nvar SecurityContext;\n(function (SecurityContext) {\n    SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n    SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n    SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n    SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n    SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\nvar MissingTranslationStrategy;\n(function (MissingTranslationStrategy) {\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\nfunction parserSelectorToSimpleSelector(selector) {\n    const classes = selector.classNames && selector.classNames.length ?\n        [8 /* SelectorFlags.CLASS */, ...selector.classNames] :\n        [];\n    const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n    return [elementName, ...selector.attrs, ...classes];\n}\nfunction parserSelectorToNegativeSelector(selector) {\n    const classes = selector.classNames && selector.classNames.length ?\n        [8 /* SelectorFlags.CLASS */, ...selector.classNames] :\n        [];\n    if (selector.element) {\n        return [\n            1 /* SelectorFlags.NOT */ | 4 /* SelectorFlags.ELEMENT */, selector.element, ...selector.attrs, ...classes\n        ];\n    }\n    else if (selector.attrs.length) {\n        return [1 /* SelectorFlags.NOT */ | 2 /* SelectorFlags.ATTRIBUTE */, ...selector.attrs, ...classes];\n    }\n    else {\n        return selector.classNames && selector.classNames.length ?\n            [1 /* SelectorFlags.NOT */ | 8 /* SelectorFlags.CLASS */, ...selector.classNames] :\n            [];\n    }\n}\nfunction parserSelectorToR3Selector(selector) {\n    const positive = parserSelectorToSimpleSelector(selector);\n    const negative = selector.notSelectors && selector.notSelectors.length ?\n        selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :\n        [];\n    return positive.concat(...negative);\n}\nfunction parseSelectorToR3Selector(selector) {\n    return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\nvar core = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue,\n    get ViewEncapsulation () { return exports.ViewEncapsulation; },\n    get ChangeDetectionStrategy () { return exports.ChangeDetectionStrategy; },\n    CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n    NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n    Type: Type$1,\n    get SecurityContext () { return SecurityContext; },\n    get MissingTranslationStrategy () { return MissingTranslationStrategy; },\n    parseSelectorToR3Selector: parseSelectorToR3Selector\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\n}\nfunction splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\nfunction splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\nfunction _splitAt(input, character, defaultValues) {\n    const characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\nfunction noUndefined(val) {\n    return val === undefined ? null : val;\n}\nfunction error(msg) {\n    throw new Error(`Internal Error: ${msg}`);\n}\nfunction utf8Encode(str) {\n    let encoded = [];\n    for (let index = 0; index < str.length; index++) {\n        let codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            const low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded.push(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded.push((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded.push(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (Array.isArray(token)) {\n        return '[' + token.map(stringify).join(', ') + ']';\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n    if (token.name) {\n        return `${token.name}`;\n    }\n    if (!token.toString) {\n        return 'object';\n    }\n    // WARNING: do not try to `JSON.stringify(token)` here\n    // see https://github.com/angular/angular/issues/23440\n    const res = token.toString();\n    if (res == null) {\n        return '' + res;\n    }\n    const newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\nclass Version {\n    constructor(full) {\n        this.full = full;\n        const splits = full.split('.');\n        this.major = splits[0];\n        this.minor = splits[1];\n        this.patch = splits.slice(2).join('.');\n    }\n}\n// Check `global` first, because in Node tests both `global` and `window` may be defined and our\n// `_global` variable should point to the NodeJS `global` in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global = ( /* @__PURE__ */(() => (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self))());\nfunction newArray(size, value) {\n    const list = [];\n    for (let i = 0; i < size; i++) {\n        list.push(value);\n    }\n    return list;\n}\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nfunction partitionArray(arr, conditionFn) {\n    const truthy = [];\n    const falsy = [];\n    for (const item of arr) {\n        (conditionFn(item) ? truthy : falsy).push(item);\n    }\n    return [truthy, falsy];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Represents a big integer using a buffer of its individual digits, with the least significant\n * digit stored at the beginning of the array (little endian).\n *\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\n * to reduce memory pressure of allocation for the digits array.\n */\nclass BigInteger {\n    /**\n     * Creates a big integer using its individual digits in little endian storage.\n     */\n    constructor(digits) {\n        this.digits = digits;\n    }\n    static zero() {\n        return new BigInteger([0]);\n    }\n    static one() {\n        return new BigInteger([1]);\n    }\n    /**\n     * Creates a clone of this instance.\n     */\n    clone() {\n        return new BigInteger(this.digits.slice());\n    }\n    /**\n     * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n     * `this` but instead returns a new instance, unlike `addToSelf`.\n     */\n    add(other) {\n        const result = this.clone();\n        result.addToSelf(other);\n        return result;\n    }\n    /**\n     * Adds `other` to the instance itself, thereby mutating its value.\n     */\n    addToSelf(other) {\n        const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n        let carry = 0;\n        for (let i = 0; i < maxNrOfDigits; i++) {\n            let digitSum = carry;\n            if (i < this.digits.length) {\n                digitSum += this.digits[i];\n            }\n            if (i < other.digits.length) {\n                digitSum += other.digits[i];\n            }\n            if (digitSum >= 10) {\n                this.digits[i] = digitSum - 10;\n                carry = 1;\n            }\n            else {\n                this.digits[i] = digitSum;\n                carry = 0;\n            }\n        }\n        // Apply a remaining carry if needed.\n        if (carry > 0) {\n            this.digits[maxNrOfDigits] = 1;\n        }\n    }\n    /**\n     * Builds the decimal string representation of the big integer. As this is stored in\n     * little endian, the digits are concatenated in reverse order.\n     */\n    toString() {\n        let res = '';\n        for (let i = this.digits.length - 1; i >= 0; i--) {\n            res += this.digits[i];\n        }\n        return res;\n    }\n}\n/**\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n */\nclass BigIntForMultiplication {\n    constructor(value) {\n        this.powerOfTwos = [value];\n    }\n    /**\n     * Returns the big integer itself.\n     */\n    getValue() {\n        return this.powerOfTwos[0];\n    }\n    /**\n     * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n     * value for `b` is represented by a storage model that is optimized for this computation.\n     *\n     * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n     * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n     * used as exponent into the power-of-two multiplication of `b`.\n     *\n     * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n     * algorithm unrolls into the following iterations:\n     *\n     *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n     * -----------|------------|------|------------|------|--------\n     *  0         | 0b00101010 | 0    | 1337       | No   | 0\n     *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n     *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n     *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n     *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n     *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n     *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n     *\n     * The computed product of 56154 is indeed the correct result.\n     *\n     * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n     * power-of-two values to reduce the workload in computing those values.\n     */\n    multiplyBy(num) {\n        const product = BigInteger.zero();\n        this.multiplyByAndAddTo(num, product);\n        return product;\n    }\n    /**\n     * See `multiplyBy()` for details. This function allows for the computed product to be added\n     * directly to the provided result big integer.\n     */\n    multiplyByAndAddTo(num, result) {\n        for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n            if (num & 1) {\n                const value = this.getMultipliedByPowerOfTwo(exponent);\n                result.addToSelf(value);\n            }\n        }\n    }\n    /**\n     * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n     */\n    getMultipliedByPowerOfTwo(exponent) {\n        // Compute the powers up until the requested exponent, where each value is computed from its\n        // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n        // added to itself) to reach `this.number * 2^exponent`.\n        for (let i = this.powerOfTwos.length; i <= exponent; i++) {\n            const previousPower = this.powerOfTwos[i - 1];\n            this.powerOfTwos[i] = previousPower.add(previousPower);\n        }\n        return this.powerOfTwos[exponent];\n    }\n}\n/**\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n * representation that is lazily computed upon request.\n */\nclass BigIntExponentiation {\n    constructor(base) {\n        this.base = base;\n        this.exponents = [new BigIntForMultiplication(BigInteger.one())];\n    }\n    /**\n     * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n     * further multiplication operations.\n     */\n    toThePowerOf(exponent) {\n        // Compute the results up until the requested exponent, where every value is computed from its\n        // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n        // to reach `this.base^exponent`.\n        for (let i = this.exponents.length; i <= exponent; i++) {\n            const value = this.exponents[i - 1].multiplyBy(this.base);\n            this.exponents[i] = new BigIntForMultiplication(value);\n        }\n        return this.exponents[exponent];\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nfunction digest$1(message) {\n    return message.id || computeDigest(message);\n}\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nfunction computeDigest(message) {\n    return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nfunction decimalDigest(message) {\n    return message.id || computeDecimalDigest(message);\n}\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nfunction computeDecimalDigest(message) {\n    const visitor = new _SerializerIgnoreIcuExpVisitor();\n    const parts = message.nodes.map(a => a.visit(visitor, null));\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor {\n    visitText(text, context) {\n        return text.value;\n    }\n    visitContainer(container, context) {\n        return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n    }\n    visitIcu(icu, context) {\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n    }\n    visitTagPlaceholder(ph, context) {\n        return ph.isVoid ?\n            `<ph tag name=\"${ph.startName}\"/>` :\n            `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n    }\n    visitPlaceholder(ph, context) {\n        return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n    }\n    visitIcuPlaceholder(ph, context) {\n        return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n    }\n}\nconst serializerVisitor$1 = new _SerializerVisitor();\nfunction serializeNodes(nodes) {\n    return nodes.map(a => a.visit(serializerVisitor$1, null));\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n    visitIcu(icu, context) {\n        let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        // Do not take the expression into account\n        return `{${icu.type}, ${strCases.join(', ')}}`;\n    }\n}\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nfunction sha1(str) {\n    const utf8 = utf8Encode(str);\n    const words32 = bytesToWords32(utf8, Endian.Big);\n    const len = utf8.length * 8;\n    const w = newArray(80);\n    let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (let i = 0; i < words32.length; i += 16) {\n        const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\n        for (let j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            const fkVal = fk(j, b, c, d);\n            const f = fkVal[0];\n            const k = fkVal[1];\n            const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            e = d;\n            d = c;\n            c = rol32(b, 30);\n            b = a;\n            a = temp;\n        }\n        a = add32(a, h0);\n        b = add32(b, h1);\n        c = add32(c, h2);\n        d = add32(d, h3);\n        e = add32(e, h4);\n    }\n    return bytesToHexString(words32ToByteString([a, b, c, d, e]));\n}\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nfunction fingerprint(str) {\n    const utf8 = utf8Encode(str);\n    let hi = hash32(utf8, 0);\n    let lo = hash32(utf8, 102072);\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\nfunction computeMsgId(msg, meaning = '') {\n    let msgFingerprint = fingerprint(msg);\n    if (meaning) {\n        const meaningFingerprint = fingerprint(meaning);\n        msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n    }\n    const hi = msgFingerprint[0];\n    const lo = msgFingerprint[1];\n    return wordsToDecimalString(hi & 0x7fffffff, lo);\n}\nfunction hash32(bytes, c) {\n    let a = 0x9e3779b9, b = 0x9e3779b9;\n    let i;\n    const len = bytes.length;\n    for (i = 0; i + 12 <= len; i += 12) {\n        a = add32(a, wordAt(bytes, i, Endian.Little));\n        b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n        c = add32(c, wordAt(bytes, i + 8, Endian.Little));\n        const res = mix(a, b, c);\n        a = res[0], b = res[1], c = res[2];\n    }\n    a = add32(a, wordAt(bytes, i, Endian.Little));\n    b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n    // the first byte of c is reserved for the length\n    c = add32(c, len);\n    c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);\n    return mix(a, b, c)[2];\n}\n// clang-format off\nfunction mix(a, b, c) {\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 13;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 8;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 13;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 12;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 16;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 5;\n    a = sub32(a, b);\n    a = sub32(a, c);\n    a ^= c >>> 3;\n    b = sub32(b, c);\n    b = sub32(b, a);\n    b ^= a << 10;\n    c = sub32(c, a);\n    c = sub32(c, b);\n    c ^= b >>> 15;\n    return [a, b, c];\n}\n// clang-format on\n// Utils\nvar Endian;\n(function (Endian) {\n    Endian[Endian[\"Little\"] = 0] = \"Little\";\n    Endian[Endian[\"Big\"] = 1] = \"Big\";\n})(Endian || (Endian = {}));\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\nfunction add32to64(a, b) {\n    const low = (a & 0xffff) + (b & 0xffff);\n    const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\nfunction add64(a, b) {\n    const ah = a[0], al = a[1];\n    const bh = b[0], bl = b[1];\n    const result = add32to64(al, bl);\n    const carry = result[0];\n    const l = result[1];\n    const h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\nfunction sub32(a, b) {\n    const low = (a & 0xffff) - (b & 0xffff);\n    const high = (a >> 16) - (b >> 16) + (low >> 16);\n    return (high << 16) | (low & 0xffff);\n}\n// Rotate a 32b number left `count` position\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n// Rotate a 64b number left `count` position\nfunction rol64(num, count) {\n    const hi = num[0], lo = num[1];\n    const h = (hi << count) | (lo >>> (32 - count));\n    const l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\nfunction bytesToWords32(bytes, endian) {\n    const size = (bytes.length + 3) >>> 2;\n    const words32 = [];\n    for (let i = 0; i < size; i++) {\n        words32[i] = wordAt(bytes, i * 4, endian);\n    }\n    return words32;\n}\nfunction byteAt(bytes, index) {\n    return index >= bytes.length ? 0 : bytes[index];\n}\nfunction wordAt(bytes, index, endian) {\n    let word = 0;\n    if (endian === Endian.Big) {\n        for (let i = 0; i < 4; i++) {\n            word += byteAt(bytes, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (let i = 0; i < 4; i++) {\n            word += byteAt(bytes, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\nfunction words32ToByteString(words32) {\n    return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), []);\n}\nfunction word32ToByteString(word) {\n    let bytes = [];\n    for (let i = 0; i < 4; i++) {\n        bytes.push((word >>> 8 * (3 - i)) & 0xff);\n    }\n    return bytes;\n}\nfunction bytesToHexString(bytes) {\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        const b = byteAt(bytes, i);\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n    }\n    return hex.toLowerCase();\n}\n/**\n * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\n * power-of-256 results with memoized power-of-two computations for efficient multiplication.\n *\n * For our purposes, this can be safely stored as a global without memory concerns. The reason is\n * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\n * exponent.\n */\nconst base256 = new BigIntExponentiation(256);\n/**\n * Represents two 32-bit words as a single decimal number. This requires a big integer storage\n * model as JS numbers are not accurate enough to represent the 64-bit number.\n *\n * Based on https://www.danvk.org/hex2dec.html\n */\nfunction wordsToDecimalString(hi, lo) {\n    // Encode the four bytes in lo in the lower digits of the decimal number.\n    // Note: the multiplication results in lo itself but represented by a big integer using its\n    // decimal digits.\n    const decimal = base256.toThePowerOf(0).multiplyBy(lo);\n    // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\n    // this multiplication factor is applied.\n    base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\n    return decimal.toString();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n//// Types\nexports.TypeModifier = void 0;\n(function (TypeModifier) {\n    TypeModifier[TypeModifier[\"None\"] = 0] = \"None\";\n    TypeModifier[TypeModifier[\"Const\"] = 1] = \"Const\";\n})(exports.TypeModifier || (exports.TypeModifier = {}));\nclass Type {\n    constructor(modifiers = exports.TypeModifier.None) {\n        this.modifiers = modifiers;\n    }\n    hasModifier(modifier) {\n        return (this.modifiers & modifier) !== 0;\n    }\n}\nexports.BuiltinTypeName = void 0;\n(function (BuiltinTypeName) {\n    BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n    BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n    BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n    BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n    BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n    BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n    BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n    BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n})(exports.BuiltinTypeName || (exports.BuiltinTypeName = {}));\nclass BuiltinType extends Type {\n    constructor(name, modifiers) {\n        super(modifiers);\n        this.name = name;\n    }\n    visitType(visitor, context) {\n        return visitor.visitBuiltinType(this, context);\n    }\n}\nclass ExpressionType extends Type {\n    constructor(value, modifiers, typeParams = null) {\n        super(modifiers);\n        this.value = value;\n        this.typeParams = typeParams;\n    }\n    visitType(visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    }\n}\nclass ArrayType extends Type {\n    constructor(of, modifiers) {\n        super(modifiers);\n        this.of = of;\n    }\n    visitType(visitor, context) {\n        return visitor.visitArrayType(this, context);\n    }\n}\nclass MapType extends Type {\n    constructor(valueType, modifiers) {\n        super(modifiers);\n        this.valueType = valueType || null;\n    }\n    visitType(visitor, context) {\n        return visitor.visitMapType(this, context);\n    }\n}\nconst DYNAMIC_TYPE = new BuiltinType(exports.BuiltinTypeName.Dynamic);\nconst INFERRED_TYPE = new BuiltinType(exports.BuiltinTypeName.Inferred);\nconst BOOL_TYPE = new BuiltinType(exports.BuiltinTypeName.Bool);\nconst INT_TYPE = new BuiltinType(exports.BuiltinTypeName.Int);\nconst NUMBER_TYPE = new BuiltinType(exports.BuiltinTypeName.Number);\nconst STRING_TYPE = new BuiltinType(exports.BuiltinTypeName.String);\nconst FUNCTION_TYPE = new BuiltinType(exports.BuiltinTypeName.Function);\nconst NONE_TYPE = new BuiltinType(exports.BuiltinTypeName.None);\n///// Expressions\nexports.UnaryOperator = void 0;\n(function (UnaryOperator) {\n    UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n    UnaryOperator[UnaryOperator[\"Plus\"] = 1] = \"Plus\";\n})(exports.UnaryOperator || (exports.UnaryOperator = {}));\nexports.BinaryOperator = void 0;\n(function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n    BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n    BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\n    BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\n    BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\n    BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\n    BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\n    BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\n    BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 11] = \"BitwiseAnd\";\n    BinaryOperator[BinaryOperator[\"Lower\"] = 12] = \"Lower\";\n    BinaryOperator[BinaryOperator[\"LowerEquals\"] = 13] = \"LowerEquals\";\n    BinaryOperator[BinaryOperator[\"Bigger\"] = 14] = \"Bigger\";\n    BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 15] = \"BiggerEquals\";\n    BinaryOperator[BinaryOperator[\"NullishCoalesce\"] = 16] = \"NullishCoalesce\";\n})(exports.BinaryOperator || (exports.BinaryOperator = {}));\nfunction nullSafeIsEquivalent(base, other) {\n    if (base == null || other == null) {\n        return base == other;\n    }\n    return base.isEquivalent(other);\n}\nfunction areAllEquivalentPredicate(base, other, equivalentPredicate) {\n    const len = base.length;\n    if (len !== other.length) {\n        return false;\n    }\n    for (let i = 0; i < len; i++) {\n        if (!equivalentPredicate(base[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction areAllEquivalent(base, other) {\n    return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));\n}\nclass Expression {\n    constructor(type, sourceSpan) {\n        this.type = type || null;\n        this.sourceSpan = sourceSpan || null;\n    }\n    prop(name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    }\n    key(index, type, sourceSpan) {\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    }\n    callFn(params, sourceSpan, pure) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n    }\n    instantiate(params, type, sourceSpan) {\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    }\n    conditional(trueCase, falseCase = null, sourceSpan) {\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    }\n    equals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    }\n    notEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    }\n    identical(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    }\n    notIdentical(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    }\n    minus(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    }\n    plus(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    }\n    divide(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    }\n    multiply(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    }\n    modulo(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    }\n    and(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.And, this, rhs, null, sourceSpan);\n    }\n    bitwiseAnd(rhs, sourceSpan, parens = true) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n    }\n    or(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Or, this, rhs, null, sourceSpan);\n    }\n    lower(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    }\n    lowerEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    }\n    bigger(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    }\n    biggerEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    }\n    isBlank(sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    }\n    nullishCoalesce(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(exports.BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n    }\n    toStmt() {\n        return new ExpressionStatement(this, null);\n    }\n}\nclass ReadVarExpr extends Expression {\n    constructor(name, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.name = name;\n    }\n    isEquivalent(e) {\n        return e instanceof ReadVarExpr && this.name === e.name;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    }\n    set(value) {\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    }\n}\nclass TypeofExpr extends Expression {\n    constructor(expr, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.expr = expr;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitTypeofExpr(this, context);\n    }\n    isEquivalent(e) {\n        return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n    }\n    isConstant() {\n        return this.expr.isConstant();\n    }\n}\nclass WrappedNodeExpr extends Expression {\n    constructor(node, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.node = node;\n    }\n    isEquivalent(e) {\n        return e instanceof WrappedNodeExpr && this.node === e.node;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWrappedNodeExpr(this, context);\n    }\n}\nclass WriteVarExpr extends Expression {\n    constructor(name, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.name = name;\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    }\n    toDeclStmt(type, modifiers) {\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    }\n    toConstDecl() {\n        return this.toDeclStmt(INFERRED_TYPE, exports.StmtModifier.Final);\n    }\n}\nclass WriteKeyExpr extends Expression {\n    constructor(receiver, index, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.receiver = receiver;\n        this.index = index;\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    }\n}\nclass WritePropExpr extends Expression {\n    constructor(receiver, name, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.receiver = receiver;\n        this.name = name;\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name && this.value.isEquivalent(e.value);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    }\n}\nclass InvokeFunctionExpr extends Expression {\n    constructor(fn, args, type, sourceSpan, pure = false) {\n        super(type, sourceSpan);\n        this.fn = fn;\n        this.args = args;\n        this.pure = pure;\n    }\n    isEquivalent(e) {\n        return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n            areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    }\n}\nclass TaggedTemplateExpr extends Expression {\n    constructor(tag, template, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.tag = tag;\n        this.template = template;\n    }\n    isEquivalent(e) {\n        return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&\n            areAllEquivalentPredicate(this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&\n            areAllEquivalent(this.template.expressions, e.template.expressions);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitTaggedTemplateExpr(this, context);\n    }\n}\nclass InstantiateExpr extends Expression {\n    constructor(classExpr, args, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.classExpr = classExpr;\n        this.args = args;\n    }\n    isEquivalent(e) {\n        return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n            areAllEquivalent(this.args, e.args);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    }\n}\nclass LiteralExpr extends Expression {\n    constructor(value, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof LiteralExpr && this.value === e.value;\n    }\n    isConstant() {\n        return true;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    }\n}\nclass TemplateLiteral {\n    constructor(elements, expressions) {\n        this.elements = elements;\n        this.expressions = expressions;\n    }\n}\nclass TemplateLiteralElement {\n    constructor(text, sourceSpan, rawText) {\n        var _a;\n        this.text = text;\n        this.sourceSpan = sourceSpan;\n        // If `rawText` is not provided, try to extract the raw string from its\n        // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n        // string instead by escaping the following control sequences:\n        // - \"\\\" would otherwise indicate that the next character is a control character.\n        // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n        // indicate the end of the template literal element.\n        this.rawText =\n            (_a = rawText !== null && rawText !== void 0 ? rawText : sourceSpan === null || sourceSpan === void 0 ? void 0 : sourceSpan.toString()) !== null && _a !== void 0 ? _a : escapeForTemplateLiteral(escapeSlashes(text));\n    }\n}\nclass LiteralPiece {\n    constructor(text, sourceSpan) {\n        this.text = text;\n        this.sourceSpan = sourceSpan;\n    }\n}\nclass PlaceholderPiece {\n    /**\n     * Create a new instance of a `PlaceholderPiece`.\n     *\n     * @param text the name of this placeholder (e.g. `PH_1`).\n     * @param sourceSpan the location of this placeholder in its localized message the source code.\n     * @param associatedMessage reference to another message that this placeholder is associated with.\n     * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n     * been extracted out from the message containing the placeholder.\n     */\n    constructor(text, sourceSpan, associatedMessage) {\n        this.text = text;\n        this.sourceSpan = sourceSpan;\n        this.associatedMessage = associatedMessage;\n    }\n}\nconst MEANING_SEPARATOR$1 = '|';\nconst ID_SEPARATOR$1 = '@@';\nconst LEGACY_ID_INDICATOR = '␟';\nclass LocalizedString extends Expression {\n    constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n        super(STRING_TYPE, sourceSpan);\n        this.metaBlock = metaBlock;\n        this.messageParts = messageParts;\n        this.placeHolderNames = placeHolderNames;\n        this.expressions = expressions;\n    }\n    isEquivalent(e) {\n        // return e instanceof LocalizedString && this.message === e.message;\n        return false;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLocalizedString(this, context);\n    }\n    /**\n     * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n     * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n     * `parseI18nMeta()`.\n     *\n     * @param meta The metadata to serialize\n     * @param messagePart The first part of the tagged string\n     */\n    serializeI18nHead() {\n        let metaBlock = this.metaBlock.description || '';\n        if (this.metaBlock.meaning) {\n            metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR$1}${metaBlock}`;\n        }\n        if (this.metaBlock.customId) {\n            metaBlock = `${metaBlock}${ID_SEPARATOR$1}${this.metaBlock.customId}`;\n        }\n        if (this.metaBlock.legacyIds) {\n            this.metaBlock.legacyIds.forEach(legacyId => {\n                metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n            });\n        }\n        return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n    }\n    getMessagePartSourceSpan(i) {\n        var _a, _b;\n        return (_b = (_a = this.messageParts[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : this.sourceSpan;\n    }\n    getPlaceholderSourceSpan(i) {\n        var _a, _b, _c, _d;\n        return (_d = (_b = (_a = this.placeHolderNames[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : (_c = this.expressions[i]) === null || _c === void 0 ? void 0 : _c.sourceSpan) !== null && _d !== void 0 ? _d : this.sourceSpan;\n    }\n    /**\n     * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n     * can be used in a `$localize` tagged string.\n     *\n     * The format is `:<placeholder-name>[@@<associated-id>]:`.\n     *\n     * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n     * refers.\n     *\n     * @param partIndex The index of the message part to serialize.\n     */\n    serializeI18nTemplatePart(partIndex) {\n        var _a;\n        const placeholder = this.placeHolderNames[partIndex - 1];\n        const messagePart = this.messageParts[partIndex];\n        let metaBlock = placeholder.text;\n        if (((_a = placeholder.associatedMessage) === null || _a === void 0 ? void 0 : _a.legacyIds.length) === 0) {\n            metaBlock += `${ID_SEPARATOR$1}${computeMsgId(placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n        }\n        return createCookedRawString(metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n    }\n}\nconst escapeSlashes = (str) => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str) => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str) => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str) => str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(metaBlock, messagePart, range) {\n    if (metaBlock === '') {\n        return {\n            cooked: messagePart,\n            raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n            range,\n        };\n    }\n    else {\n        return {\n            cooked: `:${metaBlock}:${messagePart}`,\n            raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n            range,\n        };\n    }\n}\nclass ExternalExpr extends Expression {\n    constructor(value, type, typeParams = null, sourceSpan) {\n        super(type, sourceSpan);\n        this.value = value;\n        this.typeParams = typeParams;\n    }\n    isEquivalent(e) {\n        return e instanceof ExternalExpr && this.value.name === e.value.name &&\n            this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    }\n}\nclass ExternalReference {\n    constructor(moduleName, name, runtime) {\n        this.moduleName = moduleName;\n        this.name = name;\n        this.runtime = runtime;\n    }\n}\nclass ConditionalExpr extends Expression {\n    constructor(condition, trueCase, falseCase = null, type, sourceSpan) {\n        super(type || trueCase.type, sourceSpan);\n        this.condition = condition;\n        this.falseCase = falseCase;\n        this.trueCase = trueCase;\n    }\n    isEquivalent(e) {\n        return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n            this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    }\n}\nclass NotExpr extends Expression {\n    constructor(condition, sourceSpan) {\n        super(BOOL_TYPE, sourceSpan);\n        this.condition = condition;\n    }\n    isEquivalent(e) {\n        return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    }\n}\nclass FnParam {\n    constructor(name, type = null) {\n        this.name = name;\n        this.type = type;\n    }\n    isEquivalent(param) {\n        return this.name === param.name;\n    }\n}\nclass FunctionExpr extends Expression {\n    constructor(params, statements, type, sourceSpan, name) {\n        super(type, sourceSpan);\n        this.params = params;\n        this.statements = statements;\n        this.name = name;\n    }\n    isEquivalent(e) {\n        return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n            areAllEquivalent(this.statements, e.statements);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    }\n    toDeclStmt(name, modifiers) {\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    }\n}\nclass UnaryOperatorExpr extends Expression {\n    constructor(operator, expr, type, sourceSpan, parens = true) {\n        super(type || NUMBER_TYPE, sourceSpan);\n        this.operator = operator;\n        this.expr = expr;\n        this.parens = parens;\n    }\n    isEquivalent(e) {\n        return e instanceof UnaryOperatorExpr && this.operator === e.operator &&\n            this.expr.isEquivalent(e.expr);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitUnaryOperatorExpr(this, context);\n    }\n}\nclass BinaryOperatorExpr extends Expression {\n    constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {\n        super(type || lhs.type, sourceSpan);\n        this.operator = operator;\n        this.rhs = rhs;\n        this.parens = parens;\n        this.lhs = lhs;\n    }\n    isEquivalent(e) {\n        return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n            this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    }\n}\nclass ReadPropExpr extends Expression {\n    constructor(receiver, name, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    isEquivalent(e) {\n        return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    }\n    set(value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    }\n}\nclass ReadKeyExpr extends Expression {\n    constructor(receiver, index, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.receiver = receiver;\n        this.index = index;\n    }\n    isEquivalent(e) {\n        return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    }\n    set(value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    }\n}\nclass LiteralArrayExpr extends Expression {\n    constructor(entries, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.entries = entries;\n    }\n    isConstant() {\n        return this.entries.every(e => e.isConstant());\n    }\n    isEquivalent(e) {\n        return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    }\n}\nclass LiteralMapEntry {\n    constructor(key, value, quoted) {\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    isEquivalent(e) {\n        return this.key === e.key && this.value.isEquivalent(e.value);\n    }\n}\nclass LiteralMapExpr extends Expression {\n    constructor(entries, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.entries = entries;\n        this.valueType = null;\n        if (type) {\n            this.valueType = type.valueType;\n        }\n    }\n    isEquivalent(e) {\n        return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n    }\n    isConstant() {\n        return this.entries.every(e => e.value.isConstant());\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    }\n}\nclass CommaExpr extends Expression {\n    constructor(parts, sourceSpan) {\n        super(parts[parts.length - 1].type, sourceSpan);\n        this.parts = parts;\n    }\n    isEquivalent(e) {\n        return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    }\n}\nconst NULL_EXPR = new LiteralExpr(null, null, null);\nconst TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n//// Statements\nexports.StmtModifier = void 0;\n(function (StmtModifier) {\n    StmtModifier[StmtModifier[\"None\"] = 0] = \"None\";\n    StmtModifier[StmtModifier[\"Final\"] = 1] = \"Final\";\n    StmtModifier[StmtModifier[\"Private\"] = 2] = \"Private\";\n    StmtModifier[StmtModifier[\"Exported\"] = 4] = \"Exported\";\n    StmtModifier[StmtModifier[\"Static\"] = 8] = \"Static\";\n})(exports.StmtModifier || (exports.StmtModifier = {}));\nclass LeadingComment {\n    constructor(text, multiline, trailingNewline) {\n        this.text = text;\n        this.multiline = multiline;\n        this.trailingNewline = trailingNewline;\n    }\n    toString() {\n        return this.multiline ? ` ${this.text} ` : this.text;\n    }\n}\nclass JSDocComment extends LeadingComment {\n    constructor(tags) {\n        super('', /* multiline */ true, /* trailingNewline */ true);\n        this.tags = tags;\n    }\n    toString() {\n        return serializeTags(this.tags);\n    }\n}\nclass Statement {\n    constructor(modifiers = exports.StmtModifier.None, sourceSpan = null, leadingComments) {\n        this.modifiers = modifiers;\n        this.sourceSpan = sourceSpan;\n        this.leadingComments = leadingComments;\n    }\n    hasModifier(modifier) {\n        return (this.modifiers & modifier) !== 0;\n    }\n    addLeadingComment(leadingComment) {\n        var _a;\n        this.leadingComments = (_a = this.leadingComments) !== null && _a !== void 0 ? _a : [];\n        this.leadingComments.push(leadingComment);\n    }\n}\nclass DeclareVarStmt extends Statement {\n    constructor(name, value, type, modifiers, sourceSpan, leadingComments) {\n        super(modifiers, sourceSpan, leadingComments);\n        this.name = name;\n        this.value = value;\n        this.type = type || (value && value.type) || null;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n            (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    }\n}\nclass DeclareFunctionStmt extends Statement {\n    constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {\n        super(modifiers, sourceSpan, leadingComments);\n        this.name = name;\n        this.params = params;\n        this.statements = statements;\n        this.type = type || null;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n            areAllEquivalent(this.statements, stmt.statements);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    }\n}\nclass ExpressionStatement extends Statement {\n    constructor(expr, sourceSpan, leadingComments) {\n        super(exports.StmtModifier.None, sourceSpan, leadingComments);\n        this.expr = expr;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    }\n}\nclass ReturnStatement extends Statement {\n    constructor(value, sourceSpan = null, leadingComments) {\n        super(exports.StmtModifier.None, sourceSpan, leadingComments);\n        this.value = value;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    }\n}\nclass IfStmt extends Statement {\n    constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {\n        super(exports.StmtModifier.None, sourceSpan, leadingComments);\n        this.condition = condition;\n        this.trueCase = trueCase;\n        this.falseCase = falseCase;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n            areAllEquivalent(this.trueCase, stmt.trueCase) &&\n            areAllEquivalent(this.falseCase, stmt.falseCase);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    }\n}\nclass RecursiveAstVisitor$1 {\n    visitType(ast, context) {\n        return ast;\n    }\n    visitExpression(ast, context) {\n        if (ast.type) {\n            ast.type.visitType(this, context);\n        }\n        return ast;\n    }\n    visitBuiltinType(type, context) {\n        return this.visitType(type, context);\n    }\n    visitExpressionType(type, context) {\n        type.value.visitExpression(this, context);\n        if (type.typeParams !== null) {\n            type.typeParams.forEach(param => this.visitType(param, context));\n        }\n        return this.visitType(type, context);\n    }\n    visitArrayType(type, context) {\n        return this.visitType(type, context);\n    }\n    visitMapType(type, context) {\n        return this.visitType(type, context);\n    }\n    visitWrappedNodeExpr(ast, context) {\n        return ast;\n    }\n    visitTypeofExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitReadVarExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitWriteVarExpr(ast, context) {\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitWriteKeyExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitWritePropExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitInvokeFunctionExpr(ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    }\n    visitTaggedTemplateExpr(ast, context) {\n        ast.tag.visitExpression(this, context);\n        this.visitAllExpressions(ast.template.expressions, context);\n        return this.visitExpression(ast, context);\n    }\n    visitInstantiateExpr(ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    }\n    visitLiteralExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitLocalizedString(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitExternalExpr(ast, context) {\n        if (ast.typeParams) {\n            ast.typeParams.forEach(type => type.visitType(this, context));\n        }\n        return this.visitExpression(ast, context);\n    }\n    visitConditionalExpr(ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context);\n        ast.falseCase.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitNotExpr(ast, context) {\n        ast.condition.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitFunctionExpr(ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return this.visitExpression(ast, context);\n    }\n    visitUnaryOperatorExpr(ast, context) {\n        ast.expr.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitBinaryOperatorExpr(ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitReadPropExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitReadKeyExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitLiteralArrayExpr(ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return this.visitExpression(ast, context);\n    }\n    visitLiteralMapExpr(ast, context) {\n        ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n        return this.visitExpression(ast, context);\n    }\n    visitCommaExpr(ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n        return this.visitExpression(ast, context);\n    }\n    visitAllExpressions(exprs, context) {\n        exprs.forEach(expr => expr.visitExpression(this, context));\n    }\n    visitDeclareVarStmt(stmt, context) {\n        if (stmt.value) {\n            stmt.value.visitExpression(this, context);\n        }\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    }\n    visitDeclareFunctionStmt(stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    }\n    visitExpressionStmt(stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    }\n    visitReturnStmt(stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    }\n    visitIfStmt(stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    }\n    visitAllStatements(stmts, context) {\n        stmts.forEach(stmt => stmt.visitStatement(this, context));\n    }\n}\nfunction leadingComment(text, multiline = false, trailingNewline = true) {\n    return new LeadingComment(text, multiline, trailingNewline);\n}\nfunction jsDocComment(tags = []) {\n    return new JSDocComment(tags);\n}\nfunction variable(name, type, sourceSpan) {\n    return new ReadVarExpr(name, type, sourceSpan);\n}\nfunction importExpr(id, typeParams = null, sourceSpan) {\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\nfunction importType(id, typeParams, typeModifiers) {\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\nfunction expressionType(expr, typeModifiers, typeParams) {\n    return new ExpressionType(expr, typeModifiers, typeParams);\n}\nfunction typeofExpr(expr) {\n    return new TypeofExpr(expr);\n}\nfunction literalArr(values, type, sourceSpan) {\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\nfunction literalMap(values, type = null) {\n    return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\nfunction unary(operator, expr, type, sourceSpan) {\n    return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\nfunction not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\nfunction fn(params, body, type, sourceSpan, name) {\n    return new FunctionExpr(params, body, type, sourceSpan, name);\n}\nfunction ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {\n    return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\nfunction taggedTemplate(tag, template, type, sourceSpan) {\n    return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n}\nfunction literal(value, type, sourceSpan) {\n    return new LiteralExpr(value, type, sourceSpan);\n}\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n    return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\nfunction isNull(exp) {\n    return exp instanceof LiteralExpr && exp.value === null;\n}\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag) {\n    let out = '';\n    if (tag.tagName) {\n        out += ` @${tag.tagName}`;\n    }\n    if (tag.text) {\n        if (tag.text.match(/\\/\\*|\\*\\//)) {\n            throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n        }\n        out += ' ' + tag.text.replace(/@/g, '\\\\@');\n    }\n    return out;\n}\nfunction serializeTags(tags) {\n    if (tags.length === 0)\n        return '';\n    if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n        // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n        return `*${tagToString(tags[0])} `;\n    }\n    let out = '*\\n';\n    for (const tag of tags) {\n        out += ' *';\n        // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n        out += tagToString(tag).replace(/\\n/g, '\\n * ');\n        out += '\\n';\n    }\n    out += ' ';\n    return out;\n}\n\nvar output_ast = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get TypeModifier () { return exports.TypeModifier; },\n    Type: Type,\n    get BuiltinTypeName () { return exports.BuiltinTypeName; },\n    BuiltinType: BuiltinType,\n    ExpressionType: ExpressionType,\n    ArrayType: ArrayType,\n    MapType: MapType,\n    DYNAMIC_TYPE: DYNAMIC_TYPE,\n    INFERRED_TYPE: INFERRED_TYPE,\n    BOOL_TYPE: BOOL_TYPE,\n    INT_TYPE: INT_TYPE,\n    NUMBER_TYPE: NUMBER_TYPE,\n    STRING_TYPE: STRING_TYPE,\n    FUNCTION_TYPE: FUNCTION_TYPE,\n    NONE_TYPE: NONE_TYPE,\n    get UnaryOperator () { return exports.UnaryOperator; },\n    get BinaryOperator () { return exports.BinaryOperator; },\n    nullSafeIsEquivalent: nullSafeIsEquivalent,\n    areAllEquivalent: areAllEquivalent,\n    Expression: Expression,\n    ReadVarExpr: ReadVarExpr,\n    TypeofExpr: TypeofExpr,\n    WrappedNodeExpr: WrappedNodeExpr,\n    WriteVarExpr: WriteVarExpr,\n    WriteKeyExpr: WriteKeyExpr,\n    WritePropExpr: WritePropExpr,\n    InvokeFunctionExpr: InvokeFunctionExpr,\n    TaggedTemplateExpr: TaggedTemplateExpr,\n    InstantiateExpr: InstantiateExpr,\n    LiteralExpr: LiteralExpr,\n    TemplateLiteral: TemplateLiteral,\n    TemplateLiteralElement: TemplateLiteralElement,\n    LiteralPiece: LiteralPiece,\n    PlaceholderPiece: PlaceholderPiece,\n    LocalizedString: LocalizedString,\n    ExternalExpr: ExternalExpr,\n    ExternalReference: ExternalReference,\n    ConditionalExpr: ConditionalExpr,\n    NotExpr: NotExpr,\n    FnParam: FnParam,\n    FunctionExpr: FunctionExpr,\n    UnaryOperatorExpr: UnaryOperatorExpr,\n    BinaryOperatorExpr: BinaryOperatorExpr,\n    ReadPropExpr: ReadPropExpr,\n    ReadKeyExpr: ReadKeyExpr,\n    LiteralArrayExpr: LiteralArrayExpr,\n    LiteralMapEntry: LiteralMapEntry,\n    LiteralMapExpr: LiteralMapExpr,\n    CommaExpr: CommaExpr,\n    NULL_EXPR: NULL_EXPR,\n    TYPED_NULL_EXPR: TYPED_NULL_EXPR,\n    get StmtModifier () { return exports.StmtModifier; },\n    LeadingComment: LeadingComment,\n    JSDocComment: JSDocComment,\n    Statement: Statement,\n    DeclareVarStmt: DeclareVarStmt,\n    DeclareFunctionStmt: DeclareFunctionStmt,\n    ExpressionStatement: ExpressionStatement,\n    ReturnStatement: ReturnStatement,\n    IfStmt: IfStmt,\n    RecursiveAstVisitor: RecursiveAstVisitor$1,\n    leadingComment: leadingComment,\n    jsDocComment: jsDocComment,\n    variable: variable,\n    importExpr: importExpr,\n    importType: importType,\n    expressionType: expressionType,\n    typeofExpr: typeofExpr,\n    literalArr: literalArr,\n    literalMap: literalMap,\n    unary: unary,\n    not: not,\n    fn: fn,\n    ifStmt: ifStmt,\n    taggedTemplate: taggedTemplate,\n    literal: literal,\n    localizedString: localizedString,\n    isNull: isNull\n});\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst CONSTANT_PREFIX = '_c';\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = variable('<unknown>');\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends Expression {\n    constructor(resolved) {\n        super(resolved.type);\n        this.resolved = resolved;\n        this.original = resolved;\n    }\n    visitExpression(visitor, context) {\n        if (context === KEY_CONTEXT) {\n            // When producing a key we want to traverse the constant not the\n            // variable used to refer to it.\n            return this.original.visitExpression(visitor, context);\n        }\n        else {\n            return this.resolved.visitExpression(visitor, context);\n        }\n    }\n    isEquivalent(e) {\n        return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n    }\n    isConstant() {\n        return true;\n    }\n    fixup(expression) {\n        this.resolved = expression;\n        this.shared = true;\n    }\n}\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nclass ConstantPool {\n    constructor(isClosureCompilerEnabled = false) {\n        this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n        this.statements = [];\n        this.literals = new Map();\n        this.literalFactories = new Map();\n        this.nextNameIndex = 0;\n    }\n    getConstLiteral(literal, forceShared) {\n        if ((literal instanceof LiteralExpr && !isLongStringLiteral(literal)) ||\n            literal instanceof FixupExpression) {\n            // Do no put simple literals into the constant pool or try to produce a constant for a\n            // reference to a constant.\n            return literal;\n        }\n        const key = this.keyOf(literal);\n        let fixup = this.literals.get(key);\n        let newValue = false;\n        if (!fixup) {\n            fixup = new FixupExpression(literal);\n            this.literals.set(key, fixup);\n            newValue = true;\n        }\n        if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n            // Replace the expression with a variable\n            const name = this.freshName();\n            let definition;\n            let usage;\n            if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n                // For string literals, Closure will **always** inline the string at\n                // **all** usages, duplicating it each time. For large strings, this\n                // unnecessarily bloats bundle size. To work around this restriction, we\n                // wrap the string in a function, and call that function for each usage.\n                // This tricks Closure into using inline logic for functions instead of\n                // string literals. Function calls are only inlined if the body is small\n                // enough to be worth it. By doing this, very large strings will be\n                // shared across multiple usages, rather than duplicating the string at\n                // each usage site.\n                //\n                // const myStr = function() { return \"very very very long string\"; };\n                // const usage1 = myStr();\n                // const usage2 = myStr();\n                definition = variable(name).set(new FunctionExpr([], // Params.\n                [\n                    // Statements.\n                    new ReturnStatement(literal),\n                ]));\n                usage = variable(name).callFn([]);\n            }\n            else {\n                // Just declare and use the variable directly, without a function call\n                // indirection. This saves a few bytes and avoids an unncessary call.\n                definition = variable(name).set(literal);\n                usage = variable(name);\n            }\n            this.statements.push(definition.toDeclStmt(INFERRED_TYPE, exports.StmtModifier.Final));\n            fixup.fixup(usage);\n        }\n        return fixup;\n    }\n    getLiteralFactory(literal) {\n        // Create a pure function that builds an array of a mix of constant and variable expressions\n        if (literal instanceof LiteralArrayExpr) {\n            const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n            const key = this.keyOf(literalArr(argumentsForKey));\n            return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));\n        }\n        else {\n            const expressionForKey = literalMap(literal.entries.map(e => ({\n                key: e.key,\n                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n                quoted: e.quoted\n            })));\n            const key = this.keyOf(expressionForKey);\n            return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({\n                key: literal.entries[index].key,\n                value,\n                quoted: literal.entries[index].quoted\n            }))));\n        }\n    }\n    _getLiteralFactory(key, values, resultMap) {\n        let literalFactory = this.literalFactories.get(key);\n        const literalFactoryArguments = values.filter((e => !e.isConstant()));\n        if (!literalFactory) {\n            const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));\n            const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));\n            const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);\n            const name = this.freshName();\n            this.statements.push(variable(name)\n                .set(pureFunctionDeclaration)\n                .toDeclStmt(INFERRED_TYPE, exports.StmtModifier.Final));\n            literalFactory = variable(name);\n            this.literalFactories.set(key, literalFactory);\n        }\n        return { literalFactory, literalFactoryArguments };\n    }\n    /**\n     * Produce a unique name.\n     *\n     * The name might be unique among different prefixes if any of the prefixes end in\n     * a digit so the prefix should be a constant string (not based on user input) and\n     * must not end in a digit.\n     */\n    uniqueName(prefix) {\n        return `${prefix}${this.nextNameIndex++}`;\n    }\n    freshName() {\n        return this.uniqueName(CONSTANT_PREFIX);\n    }\n    keyOf(expression) {\n        return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n    }\n}\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor {\n    constructor() {\n        this.visitWrappedNodeExpr = invalid$1;\n        this.visitWriteVarExpr = invalid$1;\n        this.visitWriteKeyExpr = invalid$1;\n        this.visitWritePropExpr = invalid$1;\n        this.visitInvokeFunctionExpr = invalid$1;\n        this.visitTaggedTemplateExpr = invalid$1;\n        this.visitInstantiateExpr = invalid$1;\n        this.visitConditionalExpr = invalid$1;\n        this.visitNotExpr = invalid$1;\n        this.visitAssertNotNullExpr = invalid$1;\n        this.visitCastExpr = invalid$1;\n        this.visitFunctionExpr = invalid$1;\n        this.visitUnaryOperatorExpr = invalid$1;\n        this.visitBinaryOperatorExpr = invalid$1;\n        this.visitReadPropExpr = invalid$1;\n        this.visitReadKeyExpr = invalid$1;\n        this.visitCommaExpr = invalid$1;\n        this.visitLocalizedString = invalid$1;\n    }\n    visitLiteralExpr(ast) {\n        return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n    }\n    visitLiteralArrayExpr(ast, context) {\n        return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n    }\n    visitLiteralMapExpr(ast, context) {\n        const mapKey = (entry) => {\n            const quote = entry.quoted ? '\"' : '';\n            return `${quote}${entry.key}${quote}`;\n        };\n        const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n        return `{${ast.entries.map(mapEntry).join(',')}`;\n    }\n    visitExternalExpr(ast) {\n        return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n            `EX:${ast.value.runtime.name}`;\n    }\n    visitReadVarExpr(node) {\n        return `VAR:${node.name}`;\n    }\n    visitTypeofExpr(node, context) {\n        return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n    }\n}\nfunction invalid$1(arg) {\n    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\nfunction isVariable(e) {\n    return e instanceof ReadVarExpr;\n}\nfunction isLongStringLiteral(expr) {\n    return expr instanceof LiteralExpr && typeof expr.value === 'string' &&\n        expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst CORE = '@angular/core';\nclass Identifiers {\n}\n/* Methods */\nIdentifiers.NEW_METHOD = 'factory';\nIdentifiers.TRANSFORM_METHOD = 'transform';\nIdentifiers.PATCH_DEPS = 'patchedDeps';\nIdentifiers.core = { name: null, moduleName: CORE };\n/* Instructions */\nIdentifiers.namespaceHTML = { name: 'ɵɵnamespaceHTML', moduleName: CORE };\nIdentifiers.namespaceMathML = { name: 'ɵɵnamespaceMathML', moduleName: CORE };\nIdentifiers.namespaceSVG = { name: 'ɵɵnamespaceSVG', moduleName: CORE };\nIdentifiers.element = { name: 'ɵɵelement', moduleName: CORE };\nIdentifiers.elementStart = { name: 'ɵɵelementStart', moduleName: CORE };\nIdentifiers.elementEnd = { name: 'ɵɵelementEnd', moduleName: CORE };\nIdentifiers.advance = { name: 'ɵɵadvance', moduleName: CORE };\nIdentifiers.syntheticHostProperty = { name: 'ɵɵsyntheticHostProperty', moduleName: CORE };\nIdentifiers.syntheticHostListener = { name: 'ɵɵsyntheticHostListener', moduleName: CORE };\nIdentifiers.attribute = { name: 'ɵɵattribute', moduleName: CORE };\nIdentifiers.attributeInterpolate1 = { name: 'ɵɵattributeInterpolate1', moduleName: CORE };\nIdentifiers.attributeInterpolate2 = { name: 'ɵɵattributeInterpolate2', moduleName: CORE };\nIdentifiers.attributeInterpolate3 = { name: 'ɵɵattributeInterpolate3', moduleName: CORE };\nIdentifiers.attributeInterpolate4 = { name: 'ɵɵattributeInterpolate4', moduleName: CORE };\nIdentifiers.attributeInterpolate5 = { name: 'ɵɵattributeInterpolate5', moduleName: CORE };\nIdentifiers.attributeInterpolate6 = { name: 'ɵɵattributeInterpolate6', moduleName: CORE };\nIdentifiers.attributeInterpolate7 = { name: 'ɵɵattributeInterpolate7', moduleName: CORE };\nIdentifiers.attributeInterpolate8 = { name: 'ɵɵattributeInterpolate8', moduleName: CORE };\nIdentifiers.attributeInterpolateV = { name: 'ɵɵattributeInterpolateV', moduleName: CORE };\nIdentifiers.classProp = { name: 'ɵɵclassProp', moduleName: CORE };\nIdentifiers.elementContainerStart = { name: 'ɵɵelementContainerStart', moduleName: CORE };\nIdentifiers.elementContainerEnd = { name: 'ɵɵelementContainerEnd', moduleName: CORE };\nIdentifiers.elementContainer = { name: 'ɵɵelementContainer', moduleName: CORE };\nIdentifiers.styleMap = { name: 'ɵɵstyleMap', moduleName: CORE };\nIdentifiers.styleMapInterpolate1 = { name: 'ɵɵstyleMapInterpolate1', moduleName: CORE };\nIdentifiers.styleMapInterpolate2 = { name: 'ɵɵstyleMapInterpolate2', moduleName: CORE };\nIdentifiers.styleMapInterpolate3 = { name: 'ɵɵstyleMapInterpolate3', moduleName: CORE };\nIdentifiers.styleMapInterpolate4 = { name: 'ɵɵstyleMapInterpolate4', moduleName: CORE };\nIdentifiers.styleMapInterpolate5 = { name: 'ɵɵstyleMapInterpolate5', moduleName: CORE };\nIdentifiers.styleMapInterpolate6 = { name: 'ɵɵstyleMapInterpolate6', moduleName: CORE };\nIdentifiers.styleMapInterpolate7 = { name: 'ɵɵstyleMapInterpolate7', moduleName: CORE };\nIdentifiers.styleMapInterpolate8 = { name: 'ɵɵstyleMapInterpolate8', moduleName: CORE };\nIdentifiers.styleMapInterpolateV = { name: 'ɵɵstyleMapInterpolateV', moduleName: CORE };\nIdentifiers.classMap = { name: 'ɵɵclassMap', moduleName: CORE };\nIdentifiers.classMapInterpolate1 = { name: 'ɵɵclassMapInterpolate1', moduleName: CORE };\nIdentifiers.classMapInterpolate2 = { name: 'ɵɵclassMapInterpolate2', moduleName: CORE };\nIdentifiers.classMapInterpolate3 = { name: 'ɵɵclassMapInterpolate3', moduleName: CORE };\nIdentifiers.classMapInterpolate4 = { name: 'ɵɵclassMapInterpolate4', moduleName: CORE };\nIdentifiers.classMapInterpolate5 = { name: 'ɵɵclassMapInterpolate5', moduleName: CORE };\nIdentifiers.classMapInterpolate6 = { name: 'ɵɵclassMapInterpolate6', moduleName: CORE };\nIdentifiers.classMapInterpolate7 = { name: 'ɵɵclassMapInterpolate7', moduleName: CORE };\nIdentifiers.classMapInterpolate8 = { name: 'ɵɵclassMapInterpolate8', moduleName: CORE };\nIdentifiers.classMapInterpolateV = { name: 'ɵɵclassMapInterpolateV', moduleName: CORE };\nIdentifiers.styleProp = { name: 'ɵɵstyleProp', moduleName: CORE };\nIdentifiers.stylePropInterpolate1 = { name: 'ɵɵstylePropInterpolate1', moduleName: CORE };\nIdentifiers.stylePropInterpolate2 = { name: 'ɵɵstylePropInterpolate2', moduleName: CORE };\nIdentifiers.stylePropInterpolate3 = { name: 'ɵɵstylePropInterpolate3', moduleName: CORE };\nIdentifiers.stylePropInterpolate4 = { name: 'ɵɵstylePropInterpolate4', moduleName: CORE };\nIdentifiers.stylePropInterpolate5 = { name: 'ɵɵstylePropInterpolate5', moduleName: CORE };\nIdentifiers.stylePropInterpolate6 = { name: 'ɵɵstylePropInterpolate6', moduleName: CORE };\nIdentifiers.stylePropInterpolate7 = { name: 'ɵɵstylePropInterpolate7', moduleName: CORE };\nIdentifiers.stylePropInterpolate8 = { name: 'ɵɵstylePropInterpolate8', moduleName: CORE };\nIdentifiers.stylePropInterpolateV = { name: 'ɵɵstylePropInterpolateV', moduleName: CORE };\nIdentifiers.nextContext = { name: 'ɵɵnextContext', moduleName: CORE };\nIdentifiers.resetView = { name: 'ɵɵresetView', moduleName: CORE };\nIdentifiers.templateCreate = { name: 'ɵɵtemplate', moduleName: CORE };\nIdentifiers.text = { name: 'ɵɵtext', moduleName: CORE };\nIdentifiers.enableBindings = { name: 'ɵɵenableBindings', moduleName: CORE };\nIdentifiers.disableBindings = { name: 'ɵɵdisableBindings', moduleName: CORE };\nIdentifiers.getCurrentView = { name: 'ɵɵgetCurrentView', moduleName: CORE };\nIdentifiers.textInterpolate = { name: 'ɵɵtextInterpolate', moduleName: CORE };\nIdentifiers.textInterpolate1 = { name: 'ɵɵtextInterpolate1', moduleName: CORE };\nIdentifiers.textInterpolate2 = { name: 'ɵɵtextInterpolate2', moduleName: CORE };\nIdentifiers.textInterpolate3 = { name: 'ɵɵtextInterpolate3', moduleName: CORE };\nIdentifiers.textInterpolate4 = { name: 'ɵɵtextInterpolate4', moduleName: CORE };\nIdentifiers.textInterpolate5 = { name: 'ɵɵtextInterpolate5', moduleName: CORE };\nIdentifiers.textInterpolate6 = { name: 'ɵɵtextInterpolate6', moduleName: CORE };\nIdentifiers.textInterpolate7 = { name: 'ɵɵtextInterpolate7', moduleName: CORE };\nIdentifiers.textInterpolate8 = { name: 'ɵɵtextInterpolate8', moduleName: CORE };\nIdentifiers.textInterpolateV = { name: 'ɵɵtextInterpolateV', moduleName: CORE };\nIdentifiers.restoreView = { name: 'ɵɵrestoreView', moduleName: CORE };\nIdentifiers.pureFunction0 = { name: 'ɵɵpureFunction0', moduleName: CORE };\nIdentifiers.pureFunction1 = { name: 'ɵɵpureFunction1', moduleName: CORE };\nIdentifiers.pureFunction2 = { name: 'ɵɵpureFunction2', moduleName: CORE };\nIdentifiers.pureFunction3 = { name: 'ɵɵpureFunction3', moduleName: CORE };\nIdentifiers.pureFunction4 = { name: 'ɵɵpureFunction4', moduleName: CORE };\nIdentifiers.pureFunction5 = { name: 'ɵɵpureFunction5', moduleName: CORE };\nIdentifiers.pureFunction6 = { name: 'ɵɵpureFunction6', moduleName: CORE };\nIdentifiers.pureFunction7 = { name: 'ɵɵpureFunction7', moduleName: CORE };\nIdentifiers.pureFunction8 = { name: 'ɵɵpureFunction8', moduleName: CORE };\nIdentifiers.pureFunctionV = { name: 'ɵɵpureFunctionV', moduleName: CORE };\nIdentifiers.pipeBind1 = { name: 'ɵɵpipeBind1', moduleName: CORE };\nIdentifiers.pipeBind2 = { name: 'ɵɵpipeBind2', moduleName: CORE };\nIdentifiers.pipeBind3 = { name: 'ɵɵpipeBind3', moduleName: CORE };\nIdentifiers.pipeBind4 = { name: 'ɵɵpipeBind4', moduleName: CORE };\nIdentifiers.pipeBindV = { name: 'ɵɵpipeBindV', moduleName: CORE };\nIdentifiers.hostProperty = { name: 'ɵɵhostProperty', moduleName: CORE };\nIdentifiers.property = { name: 'ɵɵproperty', moduleName: CORE };\nIdentifiers.propertyInterpolate = { name: 'ɵɵpropertyInterpolate', moduleName: CORE };\nIdentifiers.propertyInterpolate1 = { name: 'ɵɵpropertyInterpolate1', moduleName: CORE };\nIdentifiers.propertyInterpolate2 = { name: 'ɵɵpropertyInterpolate2', moduleName: CORE };\nIdentifiers.propertyInterpolate3 = { name: 'ɵɵpropertyInterpolate3', moduleName: CORE };\nIdentifiers.propertyInterpolate4 = { name: 'ɵɵpropertyInterpolate4', moduleName: CORE };\nIdentifiers.propertyInterpolate5 = { name: 'ɵɵpropertyInterpolate5', moduleName: CORE };\nIdentifiers.propertyInterpolate6 = { name: 'ɵɵpropertyInterpolate6', moduleName: CORE };\nIdentifiers.propertyInterpolate7 = { name: 'ɵɵpropertyInterpolate7', moduleName: CORE };\nIdentifiers.propertyInterpolate8 = { name: 'ɵɵpropertyInterpolate8', moduleName: CORE };\nIdentifiers.propertyInterpolateV = { name: 'ɵɵpropertyInterpolateV', moduleName: CORE };\nIdentifiers.i18n = { name: 'ɵɵi18n', moduleName: CORE };\nIdentifiers.i18nAttributes = { name: 'ɵɵi18nAttributes', moduleName: CORE };\nIdentifiers.i18nExp = { name: 'ɵɵi18nExp', moduleName: CORE };\nIdentifiers.i18nStart = { name: 'ɵɵi18nStart', moduleName: CORE };\nIdentifiers.i18nEnd = { name: 'ɵɵi18nEnd', moduleName: CORE };\nIdentifiers.i18nApply = { name: 'ɵɵi18nApply', moduleName: CORE };\nIdentifiers.i18nPostprocess = { name: 'ɵɵi18nPostprocess', moduleName: CORE };\nIdentifiers.pipe = { name: 'ɵɵpipe', moduleName: CORE };\nIdentifiers.projection = { name: 'ɵɵprojection', moduleName: CORE };\nIdentifiers.projectionDef = { name: 'ɵɵprojectionDef', moduleName: CORE };\nIdentifiers.reference = { name: 'ɵɵreference', moduleName: CORE };\nIdentifiers.inject = { name: 'ɵɵinject', moduleName: CORE };\nIdentifiers.injectAttribute = { name: 'ɵɵinjectAttribute', moduleName: CORE };\nIdentifiers.directiveInject = { name: 'ɵɵdirectiveInject', moduleName: CORE };\nIdentifiers.invalidFactory = { name: 'ɵɵinvalidFactory', moduleName: CORE };\nIdentifiers.invalidFactoryDep = { name: 'ɵɵinvalidFactoryDep', moduleName: CORE };\nIdentifiers.templateRefExtractor = { name: 'ɵɵtemplateRefExtractor', moduleName: CORE };\nIdentifiers.forwardRef = { name: 'forwardRef', moduleName: CORE };\nIdentifiers.resolveForwardRef = { name: 'resolveForwardRef', moduleName: CORE };\nIdentifiers.ɵɵdefineInjectable = { name: 'ɵɵdefineInjectable', moduleName: CORE };\nIdentifiers.declareInjectable = { name: 'ɵɵngDeclareInjectable', moduleName: CORE };\nIdentifiers.InjectableDeclaration = { name: 'ɵɵInjectableDeclaration', moduleName: CORE };\nIdentifiers.resolveWindow = { name: 'ɵɵresolveWindow', moduleName: CORE };\nIdentifiers.resolveDocument = { name: 'ɵɵresolveDocument', moduleName: CORE };\nIdentifiers.resolveBody = { name: 'ɵɵresolveBody', moduleName: CORE };\nIdentifiers.defineComponent = { name: 'ɵɵdefineComponent', moduleName: CORE };\nIdentifiers.declareComponent = { name: 'ɵɵngDeclareComponent', moduleName: CORE };\nIdentifiers.setComponentScope = { name: 'ɵɵsetComponentScope', moduleName: CORE };\nIdentifiers.ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n};\nIdentifiers.ViewEncapsulation = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n};\nIdentifiers.ComponentDeclaration = {\n    name: 'ɵɵComponentDeclaration',\n    moduleName: CORE,\n};\nIdentifiers.FactoryDeclaration = {\n    name: 'ɵɵFactoryDeclaration',\n    moduleName: CORE,\n};\nIdentifiers.declareFactory = { name: 'ɵɵngDeclareFactory', moduleName: CORE };\nIdentifiers.FactoryTarget = { name: 'ɵɵFactoryTarget', moduleName: CORE };\nIdentifiers.defineDirective = { name: 'ɵɵdefineDirective', moduleName: CORE };\nIdentifiers.declareDirective = { name: 'ɵɵngDeclareDirective', moduleName: CORE };\nIdentifiers.DirectiveDeclaration = {\n    name: 'ɵɵDirectiveDeclaration',\n    moduleName: CORE,\n};\nIdentifiers.InjectorDef = { name: 'ɵɵInjectorDef', moduleName: CORE };\nIdentifiers.InjectorDeclaration = { name: 'ɵɵInjectorDeclaration', moduleName: CORE };\nIdentifiers.defineInjector = { name: 'ɵɵdefineInjector', moduleName: CORE };\nIdentifiers.declareInjector = { name: 'ɵɵngDeclareInjector', moduleName: CORE };\nIdentifiers.NgModuleDeclaration = {\n    name: 'ɵɵNgModuleDeclaration',\n    moduleName: CORE,\n};\nIdentifiers.ModuleWithProviders = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE,\n};\nIdentifiers.defineNgModule = { name: 'ɵɵdefineNgModule', moduleName: CORE };\nIdentifiers.declareNgModule = { name: 'ɵɵngDeclareNgModule', moduleName: CORE };\nIdentifiers.setNgModuleScope = { name: 'ɵɵsetNgModuleScope', moduleName: CORE };\nIdentifiers.registerNgModuleType = { name: 'ɵɵregisterNgModuleType', moduleName: CORE };\nIdentifiers.PipeDeclaration = { name: 'ɵɵPipeDeclaration', moduleName: CORE };\nIdentifiers.definePipe = { name: 'ɵɵdefinePipe', moduleName: CORE };\nIdentifiers.declarePipe = { name: 'ɵɵngDeclarePipe', moduleName: CORE };\nIdentifiers.declareClassMetadata = { name: 'ɵɵngDeclareClassMetadata', moduleName: CORE };\nIdentifiers.setClassMetadata = { name: 'ɵsetClassMetadata', moduleName: CORE };\nIdentifiers.queryRefresh = { name: 'ɵɵqueryRefresh', moduleName: CORE };\nIdentifiers.viewQuery = { name: 'ɵɵviewQuery', moduleName: CORE };\nIdentifiers.loadQuery = { name: 'ɵɵloadQuery', moduleName: CORE };\nIdentifiers.contentQuery = { name: 'ɵɵcontentQuery', moduleName: CORE };\nIdentifiers.NgOnChangesFeature = { name: 'ɵɵNgOnChangesFeature', moduleName: CORE };\nIdentifiers.InheritDefinitionFeature = { name: 'ɵɵInheritDefinitionFeature', moduleName: CORE };\nIdentifiers.CopyDefinitionFeature = { name: 'ɵɵCopyDefinitionFeature', moduleName: CORE };\nIdentifiers.StandaloneFeature = { name: 'ɵɵStandaloneFeature', moduleName: CORE };\nIdentifiers.ProvidersFeature = { name: 'ɵɵProvidersFeature', moduleName: CORE };\nIdentifiers.listener = { name: 'ɵɵlistener', moduleName: CORE };\nIdentifiers.getInheritedFactory = {\n    name: 'ɵɵgetInheritedFactory',\n    moduleName: CORE,\n};\n// sanitization-related functions\nIdentifiers.sanitizeHtml = { name: 'ɵɵsanitizeHtml', moduleName: CORE };\nIdentifiers.sanitizeStyle = { name: 'ɵɵsanitizeStyle', moduleName: CORE };\nIdentifiers.sanitizeResourceUrl = { name: 'ɵɵsanitizeResourceUrl', moduleName: CORE };\nIdentifiers.sanitizeScript = { name: 'ɵɵsanitizeScript', moduleName: CORE };\nIdentifiers.sanitizeUrl = { name: 'ɵɵsanitizeUrl', moduleName: CORE };\nIdentifiers.sanitizeUrlOrResourceUrl = { name: 'ɵɵsanitizeUrlOrResourceUrl', moduleName: CORE };\nIdentifiers.trustConstantHtml = { name: 'ɵɵtrustConstantHtml', moduleName: CORE };\nIdentifiers.trustConstantResourceUrl = { name: 'ɵɵtrustConstantResourceUrl', moduleName: CORE };\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION$1 = 3;\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nclass SourceMapGenerator {\n    constructor(file = null) {\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    // The content is `null` when the content is expected to be loaded using the URL\n    addSource(url, content = null) {\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    }\n    addLine() {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    }\n    addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(`A line must be added before mappings can be added`);\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(`Unknown source file \"${sourceUrl}\"`);\n        }\n        if (col0 == null) {\n            throw new Error(`The column in the generated code must be provided`);\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(`Mapping should be added in output order`);\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(`The source location must be provided when a source url is provided`);\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });\n        return this;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get currentLine() {\n        return this.lines.slice(-1)[0];\n    }\n    toJSON() {\n        if (!this.hasMappings) {\n            return null;\n        }\n        const sourcesIndex = new Map();\n        const sources = [];\n        const sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach((url, i) => {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(this.sourcesContent.get(url) || null);\n        });\n        let mappings = '';\n        let lastCol0 = 0;\n        let lastSourceIndex = 0;\n        let lastSourceLine0 = 0;\n        let lastSourceCol0 = 0;\n        this.lines.forEach(segments => {\n            lastCol0 = 0;\n            mappings += segments\n                .map(segment => {\n                // zero-based starting column of the line in the generated code\n                let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the “sources” list\n                    segAsStr +=\n                        toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n                    lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n                    lastSourceLine0 = segment.sourceLine0;\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n                    lastSourceCol0 = segment.sourceCol0;\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION$1,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    }\n    toJsComment() {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    }\n}\nfunction toBase64String(value) {\n    let b64 = '';\n    const encoded = utf8Encode(value);\n    for (let i = 0; i < encoded.length;) {\n        const i1 = encoded[i++];\n        const i2 = i < encoded.length ? encoded[i++] : null;\n        const i3 = i < encoded.length ? encoded[i++] : null;\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n        b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n        b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    let out = '';\n    do {\n        let digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(`Can only encode value in the range [0, 63]`);\n    }\n    return B64_DIGITS[value];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nclass _EmittedLine {\n    constructor(indent) {\n        this.indent = indent;\n        this.partsLength = 0;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n}\nclass EmitterVisitorContext {\n    constructor(_indent) {\n        this._indent = _indent;\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    static createRoot() {\n        return new EmitterVisitorContext(0);\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get _currentLine() {\n        return this._lines[this._lines.length - 1];\n    }\n    println(from, lastPart = '') {\n        this.print(from || null, lastPart, true);\n    }\n    lineIsEmpty() {\n        return this._currentLine.parts.length === 0;\n    }\n    lineLength() {\n        return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    }\n    print(from, part, newLine = false) {\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.partsLength += part.length;\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    }\n    removeEmptyLastLine() {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    }\n    incIndent() {\n        this._indent++;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    }\n    decIndent() {\n        this._indent--;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    }\n    toSource() {\n        return this.sourceLines\n            .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n            .join('\\n');\n    }\n    toSourceMapGenerator(genFilePath, startsAtLine = 0) {\n        const map = new SourceMapGenerator(genFilePath);\n        let firstOffsetMapped = false;\n        const mapFirstOffsetIfNeeded = () => {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (let i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach((line, lineIdx) => {\n            map.addLine();\n            const spans = line.srcSpans;\n            const parts = line.parts;\n            let col0 = line.indent * _INDENT_WITH.length;\n            let spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                const span = spans[spanIdx];\n                const source = span.start.file;\n                const sourceLine = span.start.line;\n                const sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    }\n    spanOf(line, column) {\n        const emittedLine = this._lines[line];\n        if (emittedLine) {\n            let columnsLeft = column - _createIndent(emittedLine.indent).length;\n            for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n                const part = emittedLine.parts[partIndex];\n                if (part.length > columnsLeft) {\n                    return emittedLine.srcSpans[partIndex];\n                }\n                columnsLeft -= part.length;\n            }\n        }\n        return null;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get sourceLines() {\n        if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n            return this._lines.slice(0, -1);\n        }\n        return this._lines;\n    }\n}\nclass AbstractEmitterVisitor {\n    constructor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    printLeadingComments(stmt, ctx) {\n        if (stmt.leadingComments === undefined) {\n            return;\n        }\n        for (const comment of stmt.leadingComments) {\n            if (comment instanceof JSDocComment) {\n                ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n            }\n            else {\n                if (comment.multiline) {\n                    ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n                }\n                else {\n                    comment.text.split('\\n').forEach((line) => {\n                        ctx.println(stmt, `// ${line}`);\n                    });\n                }\n            }\n        }\n    }\n    visitExpressionStmt(stmt, ctx) {\n        this.printLeadingComments(stmt, ctx);\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    }\n    visitReturnStmt(stmt, ctx) {\n        this.printLeadingComments(stmt, ctx);\n        ctx.print(stmt, `return `);\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    }\n    visitIfStmt(stmt, ctx) {\n        this.printLeadingComments(stmt, ctx);\n        ctx.print(stmt, `if (`);\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, `) {`);\n        const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, ` `);\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, ` `);\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, `} else {`);\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    visitWriteVarExpr(expr, ctx) {\n        const lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, `${expr.name} = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    visitWriteKeyExpr(expr, ctx) {\n        const lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, `[`);\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, `] = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    visitWritePropExpr(expr, ctx) {\n        const lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, `.${expr.name} = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    visitInvokeFunctionExpr(expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, `(`);\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, `)`);\n        return null;\n    }\n    visitTaggedTemplateExpr(expr, ctx) {\n        expr.tag.visitExpression(this, ctx);\n        ctx.print(expr, '`' + expr.template.elements[0].rawText);\n        for (let i = 1; i < expr.template.elements.length; i++) {\n            ctx.print(expr, '${');\n            expr.template.expressions[i - 1].visitExpression(this, ctx);\n            ctx.print(expr, `}${expr.template.elements[i].rawText}`);\n        }\n        ctx.print(expr, '`');\n        return null;\n    }\n    visitWrappedNodeExpr(ast, ctx) {\n        throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n    }\n    visitTypeofExpr(expr, ctx) {\n        ctx.print(expr, 'typeof ');\n        expr.expr.visitExpression(this, ctx);\n    }\n    visitReadVarExpr(ast, ctx) {\n        ctx.print(ast, ast.name);\n        return null;\n    }\n    visitInstantiateExpr(ast, ctx) {\n        ctx.print(ast, `new `);\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, `(`);\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, `)`);\n        return null;\n    }\n    visitLiteralExpr(ast, ctx) {\n        const value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, `${value}`);\n        }\n        return null;\n    }\n    visitLocalizedString(ast, ctx) {\n        const head = ast.serializeI18nHead();\n        ctx.print(ast, '$localize `' + head.raw);\n        for (let i = 1; i < ast.messageParts.length; i++) {\n            ctx.print(ast, '${');\n            ast.expressions[i - 1].visitExpression(this, ctx);\n            ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n        }\n        ctx.print(ast, '`');\n        return null;\n    }\n    visitConditionalExpr(ast, ctx) {\n        ctx.print(ast, `(`);\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': ');\n        ast.falseCase.visitExpression(this, ctx);\n        ctx.print(ast, `)`);\n        return null;\n    }\n    visitNotExpr(ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    }\n    visitUnaryOperatorExpr(ast, ctx) {\n        let opStr;\n        switch (ast.operator) {\n            case exports.UnaryOperator.Plus:\n                opStr = '+';\n                break;\n            case exports.UnaryOperator.Minus:\n                opStr = '-';\n                break;\n            default:\n                throw new Error(`Unknown operator ${ast.operator}`);\n        }\n        if (ast.parens)\n            ctx.print(ast, `(`);\n        ctx.print(ast, opStr);\n        ast.expr.visitExpression(this, ctx);\n        if (ast.parens)\n            ctx.print(ast, `)`);\n        return null;\n    }\n    visitBinaryOperatorExpr(ast, ctx) {\n        let opStr;\n        switch (ast.operator) {\n            case exports.BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case exports.BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case exports.BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case exports.BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case exports.BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case exports.BinaryOperator.BitwiseAnd:\n                opStr = '&';\n                break;\n            case exports.BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case exports.BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case exports.BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case exports.BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case exports.BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case exports.BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case exports.BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case exports.BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case exports.BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case exports.BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            case exports.BinaryOperator.NullishCoalesce:\n                opStr = '??';\n                break;\n            default:\n                throw new Error(`Unknown operator ${ast.operator}`);\n        }\n        if (ast.parens)\n            ctx.print(ast, `(`);\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, ` ${opStr} `);\n        ast.rhs.visitExpression(this, ctx);\n        if (ast.parens)\n            ctx.print(ast, `)`);\n        return null;\n    }\n    visitReadPropExpr(ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, `.`);\n        ctx.print(ast, ast.name);\n        return null;\n    }\n    visitReadKeyExpr(ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, `[`);\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, `]`);\n        return null;\n    }\n    visitLiteralArrayExpr(ast, ctx) {\n        ctx.print(ast, `[`);\n        this.visitAllExpressions(ast.entries, ctx, ',');\n        ctx.print(ast, `]`);\n        return null;\n    }\n    visitLiteralMapExpr(ast, ctx) {\n        ctx.print(ast, `{`);\n        this.visitAllObjects(entry => {\n            ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n            entry.value.visitExpression(this, ctx);\n        }, ast.entries, ctx, ',');\n        ctx.print(ast, `}`);\n        return null;\n    }\n    visitCommaExpr(ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    }\n    visitAllExpressions(expressions, ctx, separator) {\n        this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n    }\n    visitAllObjects(handler, expressions, ctx, separator) {\n        let incrementedIndent = false;\n        for (let i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                if (ctx.lineLength() > 80) {\n                    ctx.print(null, separator, true);\n                    if (!incrementedIndent) {\n                        // continuation are marked with double indent.\n                        ctx.incIndent();\n                        ctx.incIndent();\n                        incrementedIndent = true;\n                    }\n                }\n                else {\n                    ctx.print(null, separator, false);\n                }\n            }\n            handler(expressions[i]);\n        }\n        if (incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.decIndent();\n            ctx.decIndent();\n        }\n    }\n    visitAllStatements(statements, ctx) {\n        statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n    }\n}\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote = true) {\n    if (input == null) {\n        return null;\n    }\n    const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return `\\\\${match[0]}`;\n        }\n    });\n    const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? `'${body}'` : body;\n}\nfunction _createIndent(count) {\n    let res = '';\n    for (let i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction typeWithParameters(type, numParams) {\n    if (numParams === 0) {\n        return expressionType(type);\n    }\n    const params = [];\n    for (let i = 0; i < numParams; i++) {\n        params.push(DYNAMIC_TYPE);\n    }\n    return expressionType(type, undefined, params);\n}\nconst ANIMATE_SYMBOL_PREFIX = '@';\nfunction prepareSyntheticPropertyName(name) {\n    return `${ANIMATE_SYMBOL_PREFIX}${name}`;\n}\nfunction prepareSyntheticListenerName(name, phase) {\n    return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\nfunction getSafePropertyAccessString(accessor, name) {\n    const escapedName = escapeIdentifier(name, false, false);\n    return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\nfunction prepareSyntheticListenerFunctionName(name, phase) {\n    return `animation_${name}_${phase}`;\n}\nfunction jitOnlyGuardedExpression(expr) {\n    return guardedExpression('ngJitMode', expr);\n}\nfunction devOnlyGuardedExpression(expr) {\n    return guardedExpression('ngDevMode', expr);\n}\nfunction guardedExpression(guard, expr) {\n    const guardExpr = new ExternalExpr({ name: guard, moduleName: null });\n    const guardNotDefined = new BinaryOperatorExpr(exports.BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));\n    const guardUndefinedOrTrue = new BinaryOperatorExpr(exports.BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined, \n    /* sourceSpan */ undefined, true);\n    return new BinaryOperatorExpr(exports.BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\nfunction wrapReference(value) {\n    const wrapped = new WrappedNodeExpr(value);\n    return { value: wrapped, type: wrapped };\n}\nfunction refsToArray(refs, shouldForwardDeclare) {\n    const values = literalArr(refs.map(ref => ref.value));\n    return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;\n}\nfunction createMayBeForwardRefExpression(expression, forwardRef) {\n    return { expression, forwardRef };\n}\n/**\n * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n * `forwardRef()` call.\n *\n * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression\n * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated\n * in the code.\n *\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n */\nfunction convertFromMaybeForwardRefExpression({ expression, forwardRef }) {\n    switch (forwardRef) {\n        case 0 /* ForwardRefHandling.None */:\n        case 1 /* ForwardRefHandling.Wrapped */:\n            return expression;\n        case 2 /* ForwardRefHandling.Unwrapped */:\n            return generateForwardRef(expression);\n    }\n}\n/**\n * Generate an expression that has the given `expr` wrapped in the following form:\n *\n * ```\n * forwardRef(() => expr)\n * ```\n */\nfunction generateForwardRef(expr) {\n    return importExpr(Identifiers.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);\n}\n\nvar R3FactoryDelegateType;\n(function (R3FactoryDelegateType) {\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\nexports.FactoryTarget = void 0;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(exports.FactoryTarget || (exports.FactoryTarget = {}));\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nfunction compileFactoryFunction(meta) {\n    const t = variable('t');\n    let baseFactoryVar = null;\n    // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n    // this type is always created by constructor invocation, then this is the type-to-create\n    // parameter provided by the user (t) if specified, or the current type if not. If there is a\n    // delegated factory (which is used to create the current type) then this is only the type-to-\n    // create parameter (t).\n    const typeForCtor = !isDelegatedFactoryMetadata(meta) ?\n        new BinaryOperatorExpr(exports.BinaryOperator.Or, t, meta.internalType) :\n        t;\n    let ctorExpr = null;\n    if (meta.deps !== null) {\n        // There is a constructor (either explicitly or implicitly defined).\n        if (meta.deps !== 'invalid') {\n            ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n        }\n    }\n    else {\n        // There is no constructor, use the base class' factory to construct typeForCtor.\n        baseFactoryVar = variable(`ɵ${meta.name}_BaseFactory`);\n        ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n    }\n    const body = [];\n    let retExpr = null;\n    function makeConditionalFactory(nonCtorExpr) {\n        const r = variable('r');\n        body.push(r.set(NULL_EXPR).toDeclStmt());\n        const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :\n            importExpr(Identifiers.invalidFactory).callFn([]).toStmt();\n        body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n        return r;\n    }\n    if (isDelegatedFactoryMetadata(meta)) {\n        // This type is created with a delegated factory. If a type parameter is not specified, call\n        // the factory instead.\n        const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n        // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n        const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?\n            InstantiateExpr :\n            InvokeFunctionExpr)(meta.delegate, delegateArgs);\n        retExpr = makeConditionalFactory(factoryExpr);\n    }\n    else if (isExpressionFactoryMetadata(meta)) {\n        // TODO(alxhub): decide whether to lower the value here or in the caller\n        retExpr = makeConditionalFactory(meta.expression);\n    }\n    else {\n        retExpr = ctorExpr;\n    }\n    if (retExpr === null) {\n        // The expression cannot be formed so render an `ɵɵinvalidFactory()` call.\n        body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());\n    }\n    else if (baseFactoryVar !== null) {\n        // This factory uses a base factory, so call `ɵɵgetInheritedFactory()` to compute it.\n        const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.internalType]);\n        // Memoize the base factoryFn: `baseFactory || (baseFactory = ɵɵgetInheritedFactory(...))`\n        const baseFactory = new BinaryOperatorExpr(exports.BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n        body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));\n    }\n    else {\n        // This is straightforward factory, just return it.\n        body.push(new ReturnStatement(retExpr));\n    }\n    let factoryFn = fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`);\n    if (baseFactoryVar !== null) {\n        // There is a base factory variable so wrap its declaration along with the factory function into\n        // an IIFE.\n        factoryFn = fn([], [\n            new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)\n        ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);\n    }\n    return {\n        expression: factoryFn,\n        statements: [],\n        type: createFactoryType(meta),\n    };\n}\nfunction createFactoryType(meta) {\n    const ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;\n    return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\nfunction injectDependencies(deps, target) {\n    return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\nfunction compileInjectDependency(dep, target, index) {\n    // Interpret the dependency according to its resolved type.\n    if (dep.token === null) {\n        return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);\n    }\n    else if (dep.attributeNameType === null) {\n        // Build up the injection flags according to the metadata.\n        const flags = 0 /* InjectFlags.Default */ | (dep.self ? 2 /* InjectFlags.Self */ : 0) |\n            (dep.skipSelf ? 4 /* InjectFlags.SkipSelf */ : 0) | (dep.host ? 1 /* InjectFlags.Host */ : 0) |\n            (dep.optional ? 8 /* InjectFlags.Optional */ : 0) |\n            (target === exports.FactoryTarget.Pipe ? 16 /* InjectFlags.ForPipe */ : 0);\n        // If this dependency is optional or otherwise has non-default flags, then additional\n        // parameters describing how to inject the dependency must be passed to the inject function\n        // that's being used.\n        let flagsParam = (flags !== 0 /* InjectFlags.Default */ || dep.optional) ? literal(flags) : null;\n        // Build up the arguments to the injectFn call.\n        const injectArgs = [dep.token];\n        if (flagsParam) {\n            injectArgs.push(flagsParam);\n        }\n        const injectFn = getInjectFn(target);\n        return importExpr(injectFn).callFn(injectArgs);\n    }\n    else {\n        // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n        // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n        // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n        // we want to generate `ɵɵinjectAttribute(foo())`.\n        //\n        // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n        // typings.\n        return importExpr(Identifiers.injectAttribute).callFn([dep.token]);\n    }\n}\nfunction createCtorDepsType(deps) {\n    let hasTypes = false;\n    const attributeTypes = deps.map(dep => {\n        const type = createCtorDepType(dep);\n        if (type !== null) {\n            hasTypes = true;\n            return type;\n        }\n        else {\n            return literal(null);\n        }\n    });\n    if (hasTypes) {\n        return expressionType(literalArr(attributeTypes));\n    }\n    else {\n        return NONE_TYPE;\n    }\n}\nfunction createCtorDepType(dep) {\n    const entries = [];\n    if (dep.attributeNameType !== null) {\n        entries.push({ key: 'attribute', value: dep.attributeNameType, quoted: false });\n    }\n    if (dep.optional) {\n        entries.push({ key: 'optional', value: literal(true), quoted: false });\n    }\n    if (dep.host) {\n        entries.push({ key: 'host', value: literal(true), quoted: false });\n    }\n    if (dep.self) {\n        entries.push({ key: 'self', value: literal(true), quoted: false });\n    }\n    if (dep.skipSelf) {\n        entries.push({ key: 'skipSelf', value: literal(true), quoted: false });\n    }\n    return entries.length > 0 ? literalMap(entries) : null;\n}\nfunction isDelegatedFactoryMetadata(meta) {\n    return meta.delegateType !== undefined;\n}\nfunction isExpressionFactoryMetadata(meta) {\n    return meta.expression !== undefined;\n}\nfunction getInjectFn(target) {\n    switch (target) {\n        case exports.FactoryTarget.Component:\n        case exports.FactoryTarget.Directive:\n        case exports.FactoryTarget.Pipe:\n            return Identifiers.directiveInject;\n        case exports.FactoryTarget.NgModule:\n        case exports.FactoryTarget.Injectable:\n        default:\n            return Identifiers.inject;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\n * require the implementation of a visitor for Comments as they are only collected at\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\n * is true.\n */\nclass Comment$1 {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(_visitor) {\n        throw new Error('visit() not implemented for Comment');\n    }\n}\nclass Text$3 {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor) {\n        return visitor.visitText(this);\n    }\n}\nclass BoundText {\n    constructor(value, sourceSpan, i18n) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitBoundText(this);\n    }\n}\n/**\n * Represents a text attribute in the template.\n *\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\n */\nclass TextAttribute {\n    constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitTextAttribute(this);\n    }\n}\nclass BoundAttribute {\n    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    static fromBoundElementProperty(prop, i18n) {\n        if (prop.keySpan === undefined) {\n            throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);\n        }\n        return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);\n    }\n    visit(visitor) {\n        return visitor.visitBoundAttribute(this);\n    }\n}\nclass BoundEvent {\n    constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {\n        this.name = name;\n        this.type = type;\n        this.handler = handler;\n        this.target = target;\n        this.phase = phase;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n        this.keySpan = keySpan;\n    }\n    static fromParsedEvent(event) {\n        const target = event.type === 0 /* ParsedEventType.Regular */ ? event.targetOrPhase : null;\n        const phase = event.type === 1 /* ParsedEventType.Animation */ ? event.targetOrPhase : null;\n        if (event.keySpan === undefined) {\n            throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);\n        }\n        return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);\n    }\n    visit(visitor) {\n        return visitor.visitBoundEvent(this);\n    }\n}\nclass Element$1 {\n    constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.name = name;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.children = children;\n        this.references = references;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitElement(this);\n    }\n}\nclass Template {\n    constructor(\n    // tagName is the name of the container element, if applicable.\n    // `null` is a special case for when there is a structural directive on an `ng-template` so\n    // the renderer can differentiate between the synthetic template and the one written in the\n    // file.\n    tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.tagName = tagName;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.templateAttrs = templateAttrs;\n        this.children = children;\n        this.references = references;\n        this.variables = variables;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitTemplate(this);\n    }\n}\nclass Content {\n    constructor(selector, attributes, sourceSpan, i18n) {\n        this.selector = selector;\n        this.attributes = attributes;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n        this.name = 'ng-content';\n    }\n    visit(visitor) {\n        return visitor.visitContent(this);\n    }\n}\nclass Variable {\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n    visit(visitor) {\n        return visitor.visitVariable(this);\n    }\n}\nclass Reference {\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n    visit(visitor) {\n        return visitor.visitReference(this);\n    }\n}\nclass Icu$1 {\n    constructor(vars, placeholders, sourceSpan, i18n) {\n        this.vars = vars;\n        this.placeholders = placeholders;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitIcu(this);\n    }\n}\nclass RecursiveVisitor$1 {\n    visitElement(element) {\n        visitAll$1(this, element.attributes);\n        visitAll$1(this, element.inputs);\n        visitAll$1(this, element.outputs);\n        visitAll$1(this, element.children);\n        visitAll$1(this, element.references);\n    }\n    visitTemplate(template) {\n        visitAll$1(this, template.attributes);\n        visitAll$1(this, template.inputs);\n        visitAll$1(this, template.outputs);\n        visitAll$1(this, template.children);\n        visitAll$1(this, template.references);\n        visitAll$1(this, template.variables);\n    }\n    visitContent(content) { }\n    visitVariable(variable) { }\n    visitReference(reference) { }\n    visitTextAttribute(attribute) { }\n    visitBoundAttribute(attribute) { }\n    visitBoundEvent(attribute) { }\n    visitText(text) { }\n    visitBoundText(text) { }\n    visitIcu(icu) { }\n}\nfunction visitAll$1(visitor, nodes) {\n    const result = [];\n    if (visitor.visit) {\n        for (const node of nodes) {\n            visitor.visit(node) || node.visit(visitor);\n        }\n    }\n    else {\n        for (const node of nodes) {\n            const newNode = node.visit(visitor);\n            if (newNode) {\n                result.push(newNode);\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass Message {\n    /**\n     * @param nodes message AST\n     * @param placeholders maps placeholder names to static content and their source spans\n     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param meaning\n     * @param description\n     * @param customId\n     */\n    constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.customId = customId;\n        this.id = this.customId;\n        /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n        this.legacyIds = [];\n        this.messageString = serializeMessage(this.nodes);\n        if (nodes.length) {\n            this.sources = [{\n                    filePath: nodes[0].sourceSpan.start.file.url,\n                    startLine: nodes[0].sourceSpan.start.line + 1,\n                    startCol: nodes[0].sourceSpan.start.col + 1,\n                    endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n                    endCol: nodes[0].sourceSpan.start.col + 1\n                }];\n        }\n        else {\n            this.sources = [];\n        }\n    }\n}\nclass Text$2 {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitText(this, context);\n    }\n}\n// TODO(vicb): do we really need this node (vs an array) ?\nclass Container {\n    constructor(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitContainer(this, context);\n    }\n}\nclass Icu {\n    constructor(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitIcu(this, context);\n    }\n}\nclass TagPlaceholder {\n    constructor(tag, attrs, startName, closeName, children, isVoid, \n    // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n    sourceSpan, startSourceSpan, endSourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitTagPlaceholder(this, context);\n    }\n}\nclass Placeholder {\n    constructor(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitPlaceholder(this, context);\n    }\n}\nclass IcuPlaceholder {\n    constructor(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitIcuPlaceholder(this, context);\n    }\n}\n// Clone the AST\nclass CloneVisitor {\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitContainer(container, context) {\n        const children = container.children.map(n => n.visit(this, context));\n        return new Container(children, container.sourceSpan);\n    }\n    visitIcu(icu, context) {\n        const cases = {};\n        Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n        const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    }\n    visitTagPlaceholder(ph, context) {\n        const children = ph.children.map(n => n.visit(this, context));\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n    }\n    visitPlaceholder(ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    }\n    visitIcuPlaceholder(ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    }\n}\n// Visit all the nodes recursively\nclass RecurseVisitor {\n    visitText(text, context) { }\n    visitContainer(container, context) {\n        container.children.forEach(child => child.visit(this));\n    }\n    visitIcu(icu, context) {\n        Object.keys(icu.cases).forEach(k => {\n            icu.cases[k].visit(this);\n        });\n    }\n    visitTagPlaceholder(ph, context) {\n        ph.children.forEach(child => child.visit(this));\n    }\n    visitPlaceholder(ph, context) { }\n    visitIcuPlaceholder(ph, context) { }\n}\n/**\n * Serialize the message to the Localize backtick string format that would appear in compiled code.\n */\nfunction serializeMessage(messageNodes) {\n    const visitor = new LocalizeMessageStringVisitor();\n    const str = messageNodes.map(n => n.visit(visitor)).join('');\n    return str;\n}\nclass LocalizeMessageStringVisitor {\n    visitText(text) {\n        return text.value;\n    }\n    visitContainer(container) {\n        return container.children.map(child => child.visit(this)).join('');\n    }\n    visitIcu(icu) {\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n    }\n    visitTagPlaceholder(ph) {\n        const children = ph.children.map(child => child.visit(this)).join('');\n        return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n    }\n    visitPlaceholder(ph) {\n        return `{$${ph.name}}`;\n    }\n    visitIcuPlaceholder(ph) {\n        return `{$${ph.name}}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass Serializer {\n    // Creates a name mapper, see `PlaceholderMapper`\n    // Returning `null` means that no name mapping is used.\n    createNameMapper(message) {\n        return null;\n    }\n}\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nclass SimplePlaceholderMapper extends RecurseVisitor {\n    // create a mapping from the message\n    constructor(message, mapName) {\n        super();\n        this.mapName = mapName;\n        this.internalToPublic = {};\n        this.publicToNextId = {};\n        this.publicToInternal = {};\n        message.nodes.forEach(node => node.visit(this));\n    }\n    toPublicName(internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    }\n    toInternalName(publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    }\n    visitText(text, context) {\n        return null;\n    }\n    visitTagPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        super.visitTagPlaceholder(ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    }\n    visitPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.name);\n    }\n    visitIcuPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.name);\n    }\n    // XMB placeholders could only contains A-Z, 0-9 and _\n    visitPlaceholderName(internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        let publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            const nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = `${publicName}_${nextId}`;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass _Visitor$2 {\n    visitTag(tag) {\n        const strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return `<${tag.name}${strAttrs}/>`;\n        }\n        const strChildren = tag.children.map(node => node.visit(this));\n        return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n    }\n    visitText(text) {\n        return text.value;\n    }\n    visitDeclaration(decl) {\n        return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n    }\n    _serializeAttributes(attrs) {\n        const strAttrs = Object.keys(attrs).map((name) => `${name}=\"${attrs[name]}\"`).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    }\n    visitDoctype(doctype) {\n        return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n    }\n}\nconst _visitor = new _Visitor$2();\nfunction serialize(nodes) {\n    return nodes.map((node) => node.visit(_visitor)).join('');\n}\nclass Declaration {\n    constructor(unescapedAttrs) {\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach((k) => {\n            this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    visit(visitor) {\n        return visitor.visitDeclaration(this);\n    }\n}\nclass Doctype {\n    constructor(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    visit(visitor) {\n        return visitor.visitDoctype(this);\n    }\n}\nclass Tag {\n    constructor(name, unescapedAttrs = {}, children = []) {\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach((k) => {\n            this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    visit(visitor) {\n        return visitor.visitTag(this);\n    }\n}\nclass Text$1 {\n    constructor(unescapedValue) {\n        this.value = escapeXml(unescapedValue);\n    }\n    visit(visitor) {\n        return visitor.visitText(this);\n    }\n}\nclass CR extends Text$1 {\n    constructor(ws = 0) {\n        super(`\\n${new Array(ws + 1).join(' ')}`);\n    }\n}\nconst _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nfunction escapeXml(text) {\n    return _ESCAPED_CHARS.reduce((text, entry) => text.replace(entry[0], entry[1]), text);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG$3 = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG$2 = 'source';\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\nclass Xmb extends Serializer {\n    write(messages, locale) {\n        const exampleVisitor = new ExampleVisitor();\n        const visitor = new _Visitor$1();\n        let rootNode = new Tag(_MESSAGES_TAG);\n        messages.forEach(message => {\n            const attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            let sourceTags = [];\n            message.sources.forEach((source) => {\n                sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n            });\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n        });\n        rootNode.children.push(new CR());\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new CR(),\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new CR(),\n        ]);\n    }\n    load(content, url) {\n        throw new Error('Unsupported');\n    }\n    digest(message) {\n        return digest(message);\n    }\n    createNameMapper(message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    }\n}\nclass _Visitor$1 {\n    visitText(text, context) {\n        return [new Text$1(text.value)];\n    }\n    visitContainer(container, context) {\n        const nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    visitIcu(icu, context) {\n        const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n        });\n        nodes.push(new Text$1(`}`));\n        return nodes;\n    }\n    visitTagPlaceholder(ph, context) {\n        const startTagAsText = new Text$1(`<${ph.tag}>`);\n        const startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        const startTagPh = new Tag(_PLACEHOLDER_TAG$3, { name: ph.startName }, [startEx, startTagAsText]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        const closeTagAsText = new Text$1(`</${ph.tag}>`);\n        const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        const closeTagPh = new Tag(_PLACEHOLDER_TAG$3, { name: ph.closeName }, [closeEx, closeTagAsText]);\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n    }\n    visitPlaceholder(ph, context) {\n        const interpolationAsText = new Text$1(`{{${ph.value}}}`);\n        // Example tag needs to be not-empty for TC.\n        const exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG$3, { name: ph.name }, [exTag, interpolationAsText])\n        ];\n    }\n    visitIcuPlaceholder(ph, context) {\n        const icuExpression = ph.value.expression;\n        const icuType = ph.value.type;\n        const icuCases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');\n        const icuAsText = new Text$1(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n        const exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG$3, { name: ph.name }, [exTag, icuAsText])\n        ];\n    }\n    serialize(nodes) {\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\nfunction digest(message) {\n    return decimalDigest(message);\n}\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor {\n    addDefaultExamples(node) {\n        node.visit(this);\n        return node;\n    }\n    visitTag(tag) {\n        if (tag.name === _PLACEHOLDER_TAG$3) {\n            if (!tag.children || tag.children.length == 0) {\n                const exText = new Text$1(tag.attrs['name'] || '...');\n                tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(node => node.visit(this));\n        }\n    }\n    visitText(text) { }\n    visitDeclaration(decl) { }\n    visitDoctype(doctype) { }\n}\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nfunction toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nconst TRANSLATION_VAR_PREFIX = 'i18n_';\n/** Name of the i18n attributes **/\nconst I18N_ATTR = 'i18n';\nconst I18N_ATTR_PREFIX = 'i18n-';\n/** Prefix of var expressions used in ICUs */\nconst I18N_ICU_VAR_PREFIX = 'VAR_';\n/** Prefix of ICU expressions for post processing */\nconst I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n/** Placeholder wrapper for i18n expressions **/\nconst I18N_PLACEHOLDER_SYMBOL = '�';\nfunction isI18nAttribute(name) {\n    return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\nfunction isI18nRootNode(meta) {\n    return meta instanceof Message;\n}\nfunction isSingleI18nIcu(meta) {\n    return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;\n}\nfunction hasI18nMeta(node) {\n    return !!node.i18n;\n}\nfunction hasI18nAttrs(element) {\n    return element.attrs.some((attr) => isI18nAttribute(attr.name));\n}\nfunction icuFromI18nMessage(message) {\n    return message.nodes[0];\n}\nfunction wrapI18nPlaceholder(content, contextId = 0) {\n    const blockId = contextId > 0 ? `:${contextId}` : '';\n    return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\n}\nfunction assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {\n    if (!strings.length)\n        return '';\n    let acc = '';\n    const lastIdx = strings.length - 1;\n    for (let i = 0; i < lastIdx; i++) {\n        acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\n    }\n    acc += strings[lastIdx];\n    return acc;\n}\nfunction getSeqNumberGenerator(startsAt = 0) {\n    let current = startsAt;\n    return () => current++;\n}\nfunction placeholdersToParams(placeholders) {\n    const params = {};\n    placeholders.forEach((values, key) => {\n        params[key] = literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n    });\n    return params;\n}\nfunction updatePlaceholderMap(map, name, ...values) {\n    const current = map.get(name) || [];\n    current.push(...values);\n    map.set(name, current);\n}\nfunction assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {\n    const startIdx = bindingStartIndex;\n    const placeholders = new Map();\n    const node = meta instanceof Message ? meta.nodes.find(node => node instanceof Container) : meta;\n    if (node) {\n        node\n            .children\n            .filter((child) => child instanceof Placeholder)\n            .forEach((child, idx) => {\n            const content = wrapI18nPlaceholder(startIdx + idx, contextId);\n            updatePlaceholderMap(placeholders, child.name, content);\n        });\n    }\n    return placeholders;\n}\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nfunction formatI18nPlaceholderNamesInMap(params = {}, useCamelCase) {\n    const _params = {};\n    if (params && Object.keys(params).length) {\n        Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n    }\n    return _params;\n}\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nfunction formatI18nPlaceholderName(name, useCamelCase = true) {\n    const publicName = toPublicName(name);\n    if (!useCamelCase) {\n        return publicName;\n    }\n    const chunks = publicName.split('_');\n    if (chunks.length === 1) {\n        // if no \"_\" found - just lowercase the value\n        return name.toLowerCase();\n    }\n    let postfix;\n    // eject last element if it's a number\n    if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n        postfix = chunks.pop();\n    }\n    let raw = chunks.shift().toLowerCase();\n    if (chunks.length) {\n        raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n    }\n    return postfix ? `${raw}_${postfix}` : raw;\n}\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nfunction getTranslationConstPrefix(extra) {\n    return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nfunction declareI18nVariable(variable) {\n    return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n/** Name of the temporary to use during data binding */\nconst TEMPORARY_NAME = '_t';\n/** Name of the context parameter passed into a template function */\nconst CONTEXT_NAME = 'ctx';\n/** Name of the RenderFlag passed into a template function */\nconst RENDER_FLAGS = 'rf';\n/** The prefix reference variables */\nconst REFERENCE_PREFIX = '_r';\n/** The name of the implicit context reference */\nconst IMPLICIT_REFERENCE = '$implicit';\n/** Non bindable attribute name **/\nconst NON_BINDABLE_ATTR = 'ngNonBindable';\n/** Name for the variable keeping track of the context returned by `ɵɵrestoreView`. */\nconst RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';\n/**\n * Maximum length of a single instruction chain. Because our output AST uses recursion, we're\n * limited in how many expressions we can nest before we reach the call stack limit. This\n * length is set very conservatively in order to reduce the chance of problems.\n */\nconst MAX_CHAIN_LENGTH = 500;\n/** Instructions that support chaining. */\nconst CHAINABLE_INSTRUCTIONS = new Set([\n    Identifiers.element,\n    Identifiers.elementStart,\n    Identifiers.elementEnd,\n    Identifiers.elementContainer,\n    Identifiers.elementContainerStart,\n    Identifiers.elementContainerEnd,\n    Identifiers.i18nExp,\n    Identifiers.listener,\n    Identifiers.classProp,\n    Identifiers.syntheticHostListener,\n    Identifiers.hostProperty,\n    Identifiers.syntheticHostProperty,\n    Identifiers.property,\n    Identifiers.propertyInterpolate1,\n    Identifiers.propertyInterpolate2,\n    Identifiers.propertyInterpolate3,\n    Identifiers.propertyInterpolate4,\n    Identifiers.propertyInterpolate5,\n    Identifiers.propertyInterpolate6,\n    Identifiers.propertyInterpolate7,\n    Identifiers.propertyInterpolate8,\n    Identifiers.propertyInterpolateV,\n    Identifiers.attribute,\n    Identifiers.attributeInterpolate1,\n    Identifiers.attributeInterpolate2,\n    Identifiers.attributeInterpolate3,\n    Identifiers.attributeInterpolate4,\n    Identifiers.attributeInterpolate5,\n    Identifiers.attributeInterpolate6,\n    Identifiers.attributeInterpolate7,\n    Identifiers.attributeInterpolate8,\n    Identifiers.attributeInterpolateV,\n    Identifiers.styleProp,\n    Identifiers.stylePropInterpolate1,\n    Identifiers.stylePropInterpolate2,\n    Identifiers.stylePropInterpolate3,\n    Identifiers.stylePropInterpolate4,\n    Identifiers.stylePropInterpolate5,\n    Identifiers.stylePropInterpolate6,\n    Identifiers.stylePropInterpolate7,\n    Identifiers.stylePropInterpolate8,\n    Identifiers.stylePropInterpolateV,\n    Identifiers.textInterpolate,\n    Identifiers.textInterpolate1,\n    Identifiers.textInterpolate2,\n    Identifiers.textInterpolate3,\n    Identifiers.textInterpolate4,\n    Identifiers.textInterpolate5,\n    Identifiers.textInterpolate6,\n    Identifiers.textInterpolate7,\n    Identifiers.textInterpolate8,\n    Identifiers.textInterpolateV,\n]);\n/** Generates a call to a single instruction. */\nfunction invokeInstruction(span, reference, params) {\n    return importExpr(reference, null, span).callFn(params, span);\n}\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nfunction temporaryAllocator(statements, name) {\n    let temp = null;\n    return () => {\n        if (!temp) {\n            statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n            temp = variable(name);\n        }\n        return temp;\n    };\n}\nfunction invalid(arg) {\n    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\nfunction asLiteral(value) {\n    if (Array.isArray(value)) {\n        return literalArr(value.map(asLiteral));\n    }\n    return literal(value, INFERRED_TYPE);\n}\nfunction conditionallyCreateMapObjectLiteral(keys, keepDeclared) {\n    if (Object.getOwnPropertyNames(keys).length > 0) {\n        return mapToExpression(keys, keepDeclared);\n    }\n    return null;\n}\nfunction mapToExpression(map, keepDeclared) {\n    return literalMap(Object.getOwnPropertyNames(map).map(key => {\n        // canonical syntax: `dirProp: publicProp`\n        // if there is no `:`, use dirProp = elProp\n        const value = map[key];\n        let declaredName;\n        let publicName;\n        let minifiedName;\n        let needsDeclaredName;\n        if (Array.isArray(value)) {\n            [publicName, declaredName] = value;\n            minifiedName = key;\n            needsDeclaredName = publicName !== declaredName;\n        }\n        else {\n            [declaredName, publicName] = splitAtColon(key, [key, value]);\n            minifiedName = declaredName;\n            // Only include the declared name if extracted from the key, i.e. the key contains a colon.\n            // Otherwise the declared name should be omitted even if it is different from the public name,\n            // as it may have already been minified.\n            needsDeclaredName = publicName !== declaredName && key.includes(':');\n        }\n        return {\n            key: minifiedName,\n            // put quotes around keys that contain potentially unsafe characters\n            quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n            value: (keepDeclared && needsDeclaredName) ?\n                literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n                asLiteral(publicName)\n        };\n    }));\n}\n/**\n *  Remove trailing null nodes as they are implied.\n */\nfunction trimTrailingNulls(parameters) {\n    while (isNull(parameters[parameters.length - 1])) {\n        parameters.pop();\n    }\n    return parameters;\n}\nfunction getQueryPredicate(query, constantPool) {\n    if (Array.isArray(query.predicate)) {\n        let predicate = [];\n        query.predicate.forEach((selector) => {\n            // Each item in predicates array may contain strings with comma-separated refs\n            // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n            // as separate array entities\n            const selectors = selector.split(',').map(token => literal(token.trim()));\n            predicate.push(...selectors);\n        });\n        return constantPool.getConstLiteral(literalArr(predicate), true);\n    }\n    else {\n        // The original predicate may have been wrapped in a `forwardRef()` call.\n        switch (query.predicate.forwardRef) {\n            case 0 /* ForwardRefHandling.None */:\n            case 2 /* ForwardRefHandling.Unwrapped */:\n                return query.predicate.expression;\n            case 1 /* ForwardRefHandling.Wrapped */:\n                return importExpr(Identifiers.resolveForwardRef).callFn([query.predicate.expression]);\n        }\n    }\n}\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nclass DefinitionMap {\n    constructor() {\n        this.values = [];\n    }\n    set(key, value) {\n        if (value) {\n            this.values.push({ key: key, value, quoted: false });\n        }\n    }\n    toLiteralMap() {\n        return literalMap(this.values);\n    }\n}\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n    const attributesMap = {};\n    if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n        elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n    }\n    else {\n        elOrTpl.attributes.forEach(a => {\n            if (!isI18nAttribute(a.name)) {\n                attributesMap[a.name] = a.value;\n            }\n        });\n        elOrTpl.inputs.forEach(i => {\n            attributesMap[i.name] = '';\n        });\n        elOrTpl.outputs.forEach(o => {\n            attributesMap[o.name] = '';\n        });\n    }\n    return attributesMap;\n}\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nfunction getInterpolationArgsLength(interpolation) {\n    const { expressions, strings } = interpolation;\n    if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n        // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n        // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n        // `textInterpolate`.\n        return 1;\n    }\n    else {\n        return expressions.length + strings.length;\n    }\n}\n/**\n * Generates the final instruction call statements based on the passed in configuration.\n * Will try to chain instructions as much as possible, if chaining is supported.\n */\nfunction getInstructionStatements(instructions) {\n    var _a;\n    const statements = [];\n    let pendingExpression = null;\n    let pendingExpressionType = null;\n    let chainLength = 0;\n    for (const current of instructions) {\n        const resolvedParams = (_a = (typeof current.paramsOrFn === 'function' ? current.paramsOrFn() : current.paramsOrFn)) !== null && _a !== void 0 ? _a : [];\n        const params = Array.isArray(resolvedParams) ? resolvedParams : [resolvedParams];\n        // If the current instruction is the same as the previous one\n        // and it can be chained, add another call to the chain.\n        if (chainLength < MAX_CHAIN_LENGTH && pendingExpressionType === current.reference &&\n            CHAINABLE_INSTRUCTIONS.has(pendingExpressionType)) {\n            // We'll always have a pending expression when there's a pending expression type.\n            pendingExpression = pendingExpression.callFn(params, pendingExpression.sourceSpan);\n            chainLength++;\n        }\n        else {\n            if (pendingExpression !== null) {\n                statements.push(pendingExpression.toStmt());\n            }\n            pendingExpression = invokeInstruction(current.span, current.reference, params);\n            pendingExpressionType = current.reference;\n            chainLength = 0;\n        }\n    }\n    // Since the current instruction adds the previous one to the statements,\n    // we may be left with the final one at the end that is still pending.\n    if (pendingExpression !== null) {\n        statements.push(pendingExpression.toStmt());\n    }\n    return statements;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compileInjectable(meta, resolveForwardRefs) {\n    let result = null;\n    const factoryMeta = {\n        name: meta.name,\n        type: meta.type,\n        internalType: meta.internalType,\n        typeArgumentCount: meta.typeArgumentCount,\n        deps: [],\n        target: exports.FactoryTarget.Injectable,\n    };\n    if (meta.useClass !== undefined) {\n        // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n        // used to instantiate the class with dependencies injected, or deps are not specified and\n        // the factory of the class is used to instantiate it.\n        //\n        // A special case exists for useClass: Type where Type is the injectable type itself and no\n        // deps are specified, in which case 'useClass' is effectively ignored.\n        const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);\n        let deps = undefined;\n        if (meta.deps !== undefined) {\n            deps = meta.deps;\n        }\n        if (deps !== undefined) {\n            // factory: () => new meta.useClass(...deps)\n            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useClass.expression, delegateDeps: deps, delegateType: R3FactoryDelegateType.Class }));\n        }\n        else if (useClassOnSelf) {\n            result = compileFactoryFunction(factoryMeta);\n        }\n        else {\n            result = {\n                statements: [],\n                expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)\n            };\n        }\n    }\n    else if (meta.useFactory !== undefined) {\n        if (meta.deps !== undefined) {\n            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useFactory, delegateDeps: meta.deps || [], delegateType: R3FactoryDelegateType.Function }));\n        }\n        else {\n            result = {\n                statements: [],\n                expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])\n            };\n        }\n    }\n    else if (meta.useValue !== undefined) {\n        // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n        // client code because meta.useValue is an Expression which will be defined even if the actual\n        // value is undefined.\n        result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: meta.useValue.expression }));\n    }\n    else if (meta.useExisting !== undefined) {\n        // useExisting is an `inject` call on the existing token.\n        result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression]) }));\n    }\n    else {\n        result = {\n            statements: [],\n            expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)\n        };\n    }\n    const token = meta.internalType;\n    const injectableProps = new DefinitionMap();\n    injectableProps.set('token', token);\n    injectableProps.set('factory', result.expression);\n    // Only generate providedIn property if it has a non-null value\n    if (meta.providedIn.expression.value !== null) {\n        injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n    }\n    const expression = importExpr(Identifiers.ɵɵdefineInjectable)\n        .callFn([injectableProps.toLiteralMap()], undefined, true);\n    return {\n        expression,\n        type: createInjectableType(meta),\n        statements: result.statements,\n    };\n}\nfunction createInjectableType(meta) {\n    return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\nfunction delegateToFactory(type, internalType, unwrapForwardRefs) {\n    if (type.node === internalType.node) {\n        // The types are the same, so we can simply delegate directly to the type's factory.\n        // ```\n        // factory: type.ɵfac\n        // ```\n        return internalType.prop('ɵfac');\n    }\n    if (!unwrapForwardRefs) {\n        // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\n        // accepts a sub-type as an argument.\n        // ```\n        // factory: function(t) { return internalType.ɵfac(t); }\n        // ```\n        return createFactoryFunction(internalType);\n    }\n    // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before\n    // calling its factory.\n    // ```\n    // factory: function(t) { return core.resolveForwardRef(type).ɵfac(t); }\n    // ```\n    const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([internalType]);\n    return createFactoryFunction(unwrappedType);\n}\nfunction createFactoryFunction(type) {\n    return fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(type.prop('ɵfac').callFn([variable('t')]))]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//, // comment\n];\nfunction assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n    }\n    else if (value != null) {\n        const start = value[0];\n        const end = value[1];\n        // Check for unusable interpolation symbols\n        UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n            if (regexp.test(start) || regexp.test(end)) {\n                throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n            }\n        });\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass InterpolationConfig {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    static fromArray(markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    }\n}\nconst DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst $EOF = 0;\nconst $BSPACE = 8;\nconst $TAB = 9;\nconst $LF = 10;\nconst $VTAB = 11;\nconst $FF = 12;\nconst $CR = 13;\nconst $SPACE = 32;\nconst $BANG = 33;\nconst $DQ = 34;\nconst $HASH = 35;\nconst $$ = 36;\nconst $PERCENT = 37;\nconst $AMPERSAND = 38;\nconst $SQ = 39;\nconst $LPAREN = 40;\nconst $RPAREN = 41;\nconst $STAR = 42;\nconst $PLUS = 43;\nconst $COMMA = 44;\nconst $MINUS = 45;\nconst $PERIOD = 46;\nconst $SLASH = 47;\nconst $COLON = 58;\nconst $SEMICOLON = 59;\nconst $LT = 60;\nconst $EQ = 61;\nconst $GT = 62;\nconst $QUESTION = 63;\nconst $0 = 48;\nconst $7 = 55;\nconst $9 = 57;\nconst $A = 65;\nconst $E = 69;\nconst $F = 70;\nconst $X = 88;\nconst $Z = 90;\nconst $LBRACKET = 91;\nconst $BACKSLASH = 92;\nconst $RBRACKET = 93;\nconst $CARET = 94;\nconst $_ = 95;\nconst $a = 97;\nconst $b = 98;\nconst $e = 101;\nconst $f = 102;\nconst $n = 110;\nconst $r = 114;\nconst $t = 116;\nconst $u = 117;\nconst $v = 118;\nconst $x = 120;\nconst $z = 122;\nconst $LBRACE = 123;\nconst $BAR = 124;\nconst $RBRACE = 125;\nconst $NBSP = 160;\nconst $BT = 96;\nfunction isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\nfunction isDigit(code) {\n    return $0 <= code && code <= $9;\n}\nfunction isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\nfunction isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\nfunction isNewLine(code) {\n    return code === $LF || code === $CR;\n}\nfunction isOctalDigit(code) {\n    return $0 <= code && code <= $7;\n}\nfunction isQuote(code) {\n    return code === $SQ || code === $DQ || code === $BT;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ParseLocation {\n    constructor(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    toString() {\n        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n    }\n    moveBy(delta) {\n        const source = this.file.content;\n        const len = source.length;\n        let offset = this.offset;\n        let line = this.line;\n        let col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            const ch = source.charCodeAt(offset);\n            if (ch == $LF) {\n                line--;\n                const priorLine = source.substring(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            const ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == $LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    }\n    // Return the source around the location\n    // Up to `maxChars` or `maxLines` on each side of the location\n    getContext(maxChars, maxLines) {\n        const content = this.file.content;\n        let startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            let endOffset = startOffset;\n            let ctxChars = 0;\n            let ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    }\n}\nclass ParseSourceFile {\n    constructor(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n}\nclass ParseSourceSpan {\n    /**\n     * Create an object that holds information about spans of tokens/nodes captured during\n     * lexing/parsing of text.\n     *\n     * @param start\n     * The location of the start of the span (having skipped leading trivia).\n     * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n     * elements will appear to begin at the start of the opening tag, rather than at the start of any\n     * leading trivia, which could include newlines.\n     *\n     * @param end\n     * The location of the end of the span.\n     *\n     * @param fullStart\n     * The start of the token without skipping the leading trivia.\n     * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n     * from text tokens. Such tooling creates new source-spans relative to the original token's\n     * source-span. If leading trivia characters have been skipped then the new source-spans may be\n     * incorrectly offset.\n     *\n     * @param details\n     * Additional information (such as identifier names) that should be associated with the span.\n     */\n    constructor(start, end, fullStart = start, details = null) {\n        this.start = start;\n        this.end = end;\n        this.fullStart = fullStart;\n        this.details = details;\n    }\n    toString() {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    }\n}\nexports.ParseErrorLevel = void 0;\n(function (ParseErrorLevel) {\n    ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n    ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n})(exports.ParseErrorLevel || (exports.ParseErrorLevel = {}));\nclass ParseError {\n    constructor(span, msg, level = exports.ParseErrorLevel.ERROR) {\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    contextualMessage() {\n        const ctx = this.span.start.getContext(100, 3);\n        return ctx ? `${this.msg} (\"${ctx.before}[${exports.ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n            this.msg;\n    }\n    toString() {\n        const details = this.span.details ? `, ${this.span.details}` : '';\n        return `${this.contextualMessage()}: ${this.span.start}${details}`;\n    }\n}\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n    const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n    const sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\nlet _anonymousTypeIndex = 0;\nfunction identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    const ref = compileIdentifier.reference;\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    if (ref['__forward_ref__']) {\n        // We do not want to try to stringify a `forwardRef()` function because that would cause the\n        // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n        return '__forward_ref__';\n    }\n    let identifier = stringify(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = `anonymous_${_anonymousTypeIndex++}`;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\nfunction sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\n * be available in all environments.\n *\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\n * creates an inline helper with the same functionality.\n *\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\n * array.\n */\nconst makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\nclass AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n    constructor() {\n        super(false);\n    }\n    visitWrappedNodeExpr(ast, ctx) {\n        throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n    }\n    visitDeclareVarStmt(stmt, ctx) {\n        ctx.print(stmt, `var ${stmt.name}`);\n        if (stmt.value) {\n            ctx.print(stmt, ' = ');\n            stmt.value.visitExpression(this, ctx);\n        }\n        ctx.println(stmt, `;`);\n        return null;\n    }\n    visitTaggedTemplateExpr(ast, ctx) {\n        // The following convoluted piece of code is effectively the downlevelled equivalent of\n        // ```\n        // tag`...`\n        // ```\n        // which is effectively like:\n        // ```\n        // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n        // ```\n        const elements = ast.template.elements;\n        ast.tag.visitExpression(this, ctx);\n        ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n        ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n        ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n        ast.template.expressions.forEach(expression => {\n            ctx.print(ast, ', ');\n            expression.visitExpression(this, ctx);\n        });\n        ctx.print(ast, ')');\n        return null;\n    }\n    visitFunctionExpr(ast, ctx) {\n        ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, `) {`);\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, `}`);\n        return null;\n    }\n    visitDeclareFunctionStmt(stmt, ctx) {\n        ctx.print(stmt, `function ${stmt.name}(`);\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, `) {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    visitLocalizedString(ast, ctx) {\n        // The following convoluted piece of code is effectively the downlevelled equivalent of\n        // ```\n        // $localize `...`\n        // ```\n        // which is effectively like:\n        // ```\n        // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n        // ```\n        ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n        const parts = [ast.serializeI18nHead()];\n        for (let i = 1; i < ast.messageParts.length; i++) {\n            parts.push(ast.serializeI18nTemplatePart(i));\n        }\n        ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n        ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n        ast.expressions.forEach(expression => {\n            ctx.print(ast, ', ');\n            expression.visitExpression(this, ctx);\n        });\n        ctx.print(ast, ')');\n        return null;\n    }\n    _visitParams(params, ctx) {\n        this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n    if (policy === undefined) {\n        policy = null;\n        if (_global.trustedTypes) {\n            try {\n                policy =\n                    _global.trustedTypes.createPolicy('angular#unsafe-jit', {\n                        createScript: (s) => s,\n                    });\n            }\n            catch (_a) {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script) {\n    var _a;\n    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;\n}\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nfunction newTrustedFunctionForJIT(...args) {\n    if (!_global.trustedTypes) {\n        // In environments that don't support Trusted Types, fall back to the most\n        // straightforward implementation:\n        return new Function(...args);\n    }\n    // Chrome currently does not support passing TrustedScript to the Function\n    // constructor. The following implements the workaround proposed on the page\n    // below, where the Chromium bug is also referenced:\n    // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n    const fnArgs = args.slice(0, -1).join(',');\n    const fnBody = args[args.length - 1];\n    const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n    // Using eval directly confuses the compiler and prevents this module from\n    // being stripped out of JS binaries even if not used. The global['eval']\n    // indirection fixes that.\n    const fn = _global['eval'](trustedScriptFromString(body));\n    if (fn.bind === undefined) {\n        // Workaround for a browser bug that only exists in Chrome 83, where passing\n        // a TrustedScript to eval just returns the TrustedScript back without\n        // evaluating it. In that case, fall back to the most straightforward\n        // implementation:\n        return new Function(...args);\n    }\n    // To completely mimic the behavior of calling \"new Function\", two more\n    // things need to happen:\n    // 1. Stringifying the resulting function should return its source code\n    fn.toString = () => body;\n    // 2. When calling the resulting function, `this` should refer to `global`\n    return fn.bind(_global);\n    // When Trusted Types support in Function constructors is widely available,\n    // the implementation of this function can be simplified to:\n    // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nclass JitEvaluator {\n    /**\n     *\n     * @param sourceUrl The URL of the generated code.\n     * @param statements An array of Angular statement AST nodes to be evaluated.\n     * @param refResolver Resolves `o.ExternalReference`s into values.\n     * @param createSourceMaps If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns A map of all the variables in the generated code.\n     */\n    evaluateStatements(sourceUrl, statements, refResolver, createSourceMaps) {\n        const converter = new JitEmitterVisitor(refResolver);\n        const ctx = EmitterVisitorContext.createRoot();\n        // Ensure generated code is in strict mode\n        if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n            statements = [\n                literal('use strict').toStmt(),\n                ...statements,\n            ];\n        }\n        converter.visitAllStatements(statements, ctx);\n        converter.createReturnStmt(ctx);\n        return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n    }\n    /**\n     * Evaluate a piece of JIT generated code.\n     * @param sourceUrl The URL of this generated code.\n     * @param ctx A context object that contains an AST of the code to be evaluated.\n     * @param vars A map containing the names and values of variables that the evaluated code might\n     * reference.\n     * @param createSourceMap If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns The result of evaluating the code.\n     */\n    evaluateCode(sourceUrl, ctx, vars, createSourceMap) {\n        let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n        const fnArgNames = [];\n        const fnArgValues = [];\n        for (const argName in vars) {\n            fnArgValues.push(vars[argName]);\n            fnArgNames.push(argName);\n        }\n        if (createSourceMap) {\n            // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n            // E.g. ```\n            // function anonymous(a,b,c\n            // /**/) { ... }```\n            // We don't want to hard code this fact, so we auto detect it via an empty function first.\n            const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n            const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n            fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n        }\n        const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n        return this.executeFunction(fn, fnArgValues);\n    }\n    /**\n     * Execute a JIT generated function by calling it.\n     *\n     * This method can be overridden in tests to capture the functions that are generated\n     * by this `JitEvaluator` class.\n     *\n     * @param fn A function to execute.\n     * @param args The arguments to pass to the function being executed.\n     * @returns The return value of the executed function.\n     */\n    executeFunction(fn, args) {\n        return fn(...args);\n    }\n}\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nclass JitEmitterVisitor extends AbstractJsEmitterVisitor {\n    constructor(refResolver) {\n        super();\n        this.refResolver = refResolver;\n        this._evalArgNames = [];\n        this._evalArgValues = [];\n        this._evalExportedVars = [];\n    }\n    createReturnStmt(ctx) {\n        const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));\n        stmt.visitStatement(this, ctx);\n    }\n    getArgs() {\n        const result = {};\n        for (let i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    }\n    visitExternalExpr(ast, ctx) {\n        this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n        return null;\n    }\n    visitWrappedNodeExpr(ast, ctx) {\n        this._emitReferenceToExternal(ast, ast.node, ctx);\n        return null;\n    }\n    visitDeclareVarStmt(stmt, ctx) {\n        if (stmt.hasModifier(exports.StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return super.visitDeclareVarStmt(stmt, ctx);\n    }\n    visitDeclareFunctionStmt(stmt, ctx) {\n        if (stmt.hasModifier(exports.StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return super.visitDeclareFunctionStmt(stmt, ctx);\n    }\n    _emitReferenceToExternal(ast, value, ctx) {\n        let id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            const name = identifierName({ reference: value }) || 'val';\n            this._evalArgNames.push(`jit_${name}_${id}`);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n    }\n}\nfunction isUseStrictStatement(statement) {\n    return statement.isEquivalent(literal('use strict').toStmt());\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compileInjector(meta) {\n    const definitionMap = new DefinitionMap();\n    if (meta.providers !== null) {\n        definitionMap.set('providers', meta.providers);\n    }\n    if (meta.imports.length > 0) {\n        definitionMap.set('imports', literalArr(meta.imports));\n    }\n    const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createInjectorType(meta);\n    return { expression, type, statements: [] };\n}\nfunction createInjectorType(meta) {\n    return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nclass R3JitReflector {\n    constructor(context) {\n        this.context = context;\n    }\n    resolveExternalReference(ref) {\n        // This reflector only handles @angular/core imports.\n        if (ref.moduleName !== '@angular/core') {\n            throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);\n        }\n        if (!this.context.hasOwnProperty(ref.name)) {\n            throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);\n        }\n        return this.context[ref.name];\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * How the selector scope of an NgModule (its declarations, imports, and exports) should be emitted\n * as a part of the NgModule definition.\n */\nexports.R3SelectorScopeMode = void 0;\n(function (R3SelectorScopeMode) {\n    /**\n     * Emit the declarations inline into the module definition.\n     *\n     * This option is useful in certain contexts where it's known that JIT support is required. The\n     * tradeoff here is that this emit style prevents directives and pipes from being tree-shaken if\n     * they are unused, but the NgModule is used.\n     */\n    R3SelectorScopeMode[R3SelectorScopeMode[\"Inline\"] = 0] = \"Inline\";\n    /**\n     * Emit the declarations using a side effectful function call, `ɵɵsetNgModuleScope`, that is\n     * guarded with the `ngJitMode` flag.\n     *\n     * This form of emit supports JIT and can be optimized away if the `ngJitMode` flag is set to\n     * false, which allows unused directives and pipes to be tree-shaken.\n     */\n    R3SelectorScopeMode[R3SelectorScopeMode[\"SideEffect\"] = 1] = \"SideEffect\";\n    /**\n     * Don't generate selector scopes at all.\n     *\n     * This is useful for contexts where JIT support is known to be unnecessary.\n     */\n    R3SelectorScopeMode[R3SelectorScopeMode[\"Omit\"] = 2] = \"Omit\";\n})(exports.R3SelectorScopeMode || (exports.R3SelectorScopeMode = {}));\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nfunction compileNgModule(meta) {\n    const { adjacentType, internalType, bootstrap, declarations, imports, exports: exports$1, schemas, containsForwardDecls, selectorScopeMode, id } = meta;\n    const statements = [];\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('type', internalType);\n    if (bootstrap.length > 0) {\n        definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\n    }\n    if (selectorScopeMode === exports.R3SelectorScopeMode.Inline) {\n        // If requested to emit scope information inline, pass the `declarations`, `imports` and\n        // `exports` to the `ɵɵdefineNgModule()` call directly.\n        if (declarations.length > 0) {\n            definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n        }\n        if (imports.length > 0) {\n            definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\n        }\n        if (exports$1.length > 0) {\n            definitionMap.set('exports', refsToArray(exports$1, containsForwardDecls));\n        }\n    }\n    else if (selectorScopeMode === exports.R3SelectorScopeMode.SideEffect) {\n        // In this mode, scope information is not passed into `ɵɵdefineNgModule` as it\n        // would prevent tree-shaking of the declarations, imports and exports references. Instead, it's\n        // patched onto the NgModule definition with a `ɵɵsetNgModuleScope` call that's guarded by the\n        // `ngJitMode` flag.\n        const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n        if (setNgModuleScopeCall !== null) {\n            statements.push(setNgModuleScopeCall);\n        }\n    }\n    else ;\n    if (schemas !== null && schemas.length > 0) {\n        definitionMap.set('schemas', literalArr(schemas.map(ref => ref.value)));\n    }\n    if (id !== null) {\n        definitionMap.set('id', id);\n        // Generate a side-effectful call to register this NgModule by its id, as per the semantics of\n        // NgModule ids.\n        statements.push(importExpr(Identifiers.registerNgModuleType).callFn([adjacentType, id]).toStmt());\n    }\n    const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createNgModuleType(meta);\n    return { expression, type, statements };\n}\n/**\n * This function is used in JIT mode to generate the call to `ɵɵdefineNgModule()` from a call to\n * `ɵɵngDeclareNgModule()`.\n */\nfunction compileNgModuleDeclarationExpression(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('type', new WrappedNodeExpr(meta.type));\n    if (meta.bootstrap !== undefined) {\n        definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));\n    }\n    if (meta.declarations !== undefined) {\n        definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));\n    }\n    if (meta.imports !== undefined) {\n        definitionMap.set('imports', new WrappedNodeExpr(meta.imports));\n    }\n    if (meta.exports !== undefined) {\n        definitionMap.set('exports', new WrappedNodeExpr(meta.exports));\n    }\n    if (meta.schemas !== undefined) {\n        definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));\n    }\n    if (meta.id !== undefined) {\n        definitionMap.set('id', new WrappedNodeExpr(meta.id));\n    }\n    return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\nfunction createNgModuleType({ type: moduleType, declarations, imports, exports }) {\n    return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [\n        new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),\n        tupleTypeOf(exports)\n    ]));\n}\n/**\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta) {\n    const { adjacentType: moduleType, declarations, imports, exports, containsForwardDecls } = meta;\n    const scopeMap = new DefinitionMap();\n    if (declarations.length > 0) {\n        scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n    }\n    if (imports.length > 0) {\n        scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\n    }\n    if (exports.length > 0) {\n        scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\n    }\n    if (Object.keys(scopeMap.values).length === 0) {\n        return null;\n    }\n    // setNgModuleScope(...)\n    const fnCall = new InvokeFunctionExpr(\n    /* fn */ importExpr(Identifiers.setNgModuleScope), \n    /* args */ [moduleType, scopeMap.toLiteralMap()]);\n    // (ngJitMode guard) && setNgModuleScope(...)\n    const guardedCall = jitOnlyGuardedExpression(fnCall);\n    // function() { (ngJitMode guard) && setNgModuleScope(...); }\n    const iife = new FunctionExpr(\n    /* params */ [], \n    /* statements */ [guardedCall.toStmt()]);\n    // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n    const iifeCall = new InvokeFunctionExpr(\n    /* fn */ iife, \n    /* args */ []);\n    return iifeCall.toStmt();\n}\nfunction tupleTypeOf(exp) {\n    const types = exp.map(ref => typeofExpr(ref.type));\n    return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compilePipeFromMetadata(metadata) {\n    const definitionMapValues = [];\n    // e.g. `name: 'myPipe'`\n    definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });\n    // e.g. `type: MyPipe`\n    definitionMapValues.push({ key: 'type', value: metadata.type.value, quoted: false });\n    // e.g. `pure: true`\n    definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });\n    if (metadata.isStandalone) {\n        definitionMapValues.push({ key: 'standalone', value: literal(true), quoted: false });\n    }\n    const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);\n    const type = createPipeType(metadata);\n    return { expression, type, statements: [] };\n}\nfunction createPipeType(metadata) {\n    return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [\n        typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n        new ExpressionType(new LiteralExpr(metadata.pipeName)),\n        new ExpressionType(new LiteralExpr(metadata.isStandalone)),\n    ]));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexports.R3TemplateDependencyKind = void 0;\n(function (R3TemplateDependencyKind) {\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(exports.R3TemplateDependencyKind || (exports.R3TemplateDependencyKind = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ParserError {\n    constructor(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n    }\n}\nclass ParseSpan {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    toAbsolute(absoluteOffset) {\n        return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n    }\n}\nclass AST {\n    constructor(span, \n    /**\n     * Absolute location of the expression AST in a source code file.\n     */\n    sourceSpan) {\n        this.span = span;\n        this.sourceSpan = sourceSpan;\n    }\n    toString() {\n        return 'AST';\n    }\n}\nclass ASTWithName extends AST {\n    constructor(span, sourceSpan, nameSpan) {\n        super(span, sourceSpan);\n        this.nameSpan = nameSpan;\n    }\n}\nclass EmptyExpr extends AST {\n    visit(visitor, context = null) {\n        // do nothing\n    }\n}\nclass ImplicitReceiver extends AST {\n    visit(visitor, context = null) {\n        return visitor.visitImplicitReceiver(this, context);\n    }\n}\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nclass ThisReceiver extends ImplicitReceiver {\n    visit(visitor, context = null) {\n        var _a;\n        return (_a = visitor.visitThisReceiver) === null || _a === void 0 ? void 0 : _a.call(visitor, this, context);\n    }\n}\n/**\n * Multiple expressions separated by a semicolon.\n */\nclass Chain extends AST {\n    constructor(span, sourceSpan, expressions) {\n        super(span, sourceSpan);\n        this.expressions = expressions;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitChain(this, context);\n    }\n}\nclass Conditional extends AST {\n    constructor(span, sourceSpan, condition, trueExp, falseExp) {\n        super(span, sourceSpan);\n        this.condition = condition;\n        this.trueExp = trueExp;\n        this.falseExp = falseExp;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitConditional(this, context);\n    }\n}\nclass PropertyRead extends ASTWithName {\n    constructor(span, sourceSpan, nameSpan, receiver, name) {\n        super(span, sourceSpan, nameSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPropertyRead(this, context);\n    }\n}\nclass PropertyWrite extends ASTWithName {\n    constructor(span, sourceSpan, nameSpan, receiver, name, value) {\n        super(span, sourceSpan, nameSpan);\n        this.receiver = receiver;\n        this.name = name;\n        this.value = value;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPropertyWrite(this, context);\n    }\n}\nclass SafePropertyRead extends ASTWithName {\n    constructor(span, sourceSpan, nameSpan, receiver, name) {\n        super(span, sourceSpan, nameSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitSafePropertyRead(this, context);\n    }\n}\nclass KeyedRead extends AST {\n    constructor(span, sourceSpan, receiver, key) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.key = key;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitKeyedRead(this, context);\n    }\n}\nclass SafeKeyedRead extends AST {\n    constructor(span, sourceSpan, receiver, key) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.key = key;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitSafeKeyedRead(this, context);\n    }\n}\nclass KeyedWrite extends AST {\n    constructor(span, sourceSpan, receiver, key, value) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.key = key;\n        this.value = value;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitKeyedWrite(this, context);\n    }\n}\nclass BindingPipe extends ASTWithName {\n    constructor(span, sourceSpan, exp, name, args, nameSpan) {\n        super(span, sourceSpan, nameSpan);\n        this.exp = exp;\n        this.name = name;\n        this.args = args;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPipe(this, context);\n    }\n}\nclass LiteralPrimitive extends AST {\n    constructor(span, sourceSpan, value) {\n        super(span, sourceSpan);\n        this.value = value;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitLiteralPrimitive(this, context);\n    }\n}\nclass LiteralArray extends AST {\n    constructor(span, sourceSpan, expressions) {\n        super(span, sourceSpan);\n        this.expressions = expressions;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitLiteralArray(this, context);\n    }\n}\nclass LiteralMap extends AST {\n    constructor(span, sourceSpan, keys, values) {\n        super(span, sourceSpan);\n        this.keys = keys;\n        this.values = values;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitLiteralMap(this, context);\n    }\n}\nclass Interpolation extends AST {\n    constructor(span, sourceSpan, strings, expressions) {\n        super(span, sourceSpan);\n        this.strings = strings;\n        this.expressions = expressions;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitInterpolation(this, context);\n    }\n}\nclass Binary extends AST {\n    constructor(span, sourceSpan, operation, left, right) {\n        super(span, sourceSpan);\n        this.operation = operation;\n        this.left = left;\n        this.right = right;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitBinary(this, context);\n    }\n}\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nclass Unary extends Binary {\n    /**\n     * During the deprecation period this constructor is private, to avoid consumers from creating\n     * a `Unary` with the fallback properties for `Binary`.\n     */\n    constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {\n        super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n        this.operator = operator;\n        this.expr = expr;\n        // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n        // depend on these fields when operating on `Unary`.\n        this.left = null;\n        this.right = null;\n        this.operation = null;\n    }\n    /**\n     * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n     */\n    static createMinus(span, sourceSpan, expr) {\n        return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n    }\n    /**\n     * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n     */\n    static createPlus(span, sourceSpan, expr) {\n        return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n    }\n    visit(visitor, context = null) {\n        if (visitor.visitUnary !== undefined) {\n            return visitor.visitUnary(this, context);\n        }\n        return visitor.visitBinary(this, context);\n    }\n}\nclass PrefixNot extends AST {\n    constructor(span, sourceSpan, expression) {\n        super(span, sourceSpan);\n        this.expression = expression;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPrefixNot(this, context);\n    }\n}\nclass NonNullAssert extends AST {\n    constructor(span, sourceSpan, expression) {\n        super(span, sourceSpan);\n        this.expression = expression;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitNonNullAssert(this, context);\n    }\n}\nclass Call extends AST {\n    constructor(span, sourceSpan, receiver, args, argumentSpan) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.args = args;\n        this.argumentSpan = argumentSpan;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitCall(this, context);\n    }\n}\nclass SafeCall extends AST {\n    constructor(span, sourceSpan, receiver, args, argumentSpan) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.args = args;\n        this.argumentSpan = argumentSpan;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitSafeCall(this, context);\n    }\n}\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nclass AbsoluteSourceSpan {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n}\nclass ASTWithSource extends AST {\n    constructor(ast, source, location, absoluteOffset, errors) {\n        super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n        this.ast = ast;\n        this.source = source;\n        this.location = location;\n        this.errors = errors;\n    }\n    visit(visitor, context = null) {\n        if (visitor.visitASTWithSource) {\n            return visitor.visitASTWithSource(this, context);\n        }\n        return this.ast.visit(visitor, context);\n    }\n    toString() {\n        return `${this.source} in ${this.location}`;\n    }\n}\nclass VariableBinding {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key name of the LHS along with its span.\n     * @param value optional value for the RHS along with its span.\n     */\n    constructor(sourceSpan, key, value) {\n        this.sourceSpan = sourceSpan;\n        this.key = key;\n        this.value = value;\n    }\n}\nclass ExpressionBinding {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n     * span. Note that the length of the span may not be the same as\n     * `key.source.length`. For example,\n     * 1. key.source = ngFor, key.span is for \"ngFor\"\n     * 2. key.source = ngForOf, key.span is for \"of\"\n     * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n     * @param value optional expression for the RHS.\n     */\n    constructor(sourceSpan, key, value) {\n        this.sourceSpan = sourceSpan;\n        this.key = key;\n        this.value = value;\n    }\n}\nclass RecursiveAstVisitor {\n    visit(ast, context) {\n        // The default implementation just visits every node.\n        // Classes that extend RecursiveAstVisitor should override this function\n        // to selectively visit the specified node.\n        ast.visit(this, context);\n    }\n    visitUnary(ast, context) {\n        this.visit(ast.expr, context);\n    }\n    visitBinary(ast, context) {\n        this.visit(ast.left, context);\n        this.visit(ast.right, context);\n    }\n    visitChain(ast, context) {\n        this.visitAll(ast.expressions, context);\n    }\n    visitConditional(ast, context) {\n        this.visit(ast.condition, context);\n        this.visit(ast.trueExp, context);\n        this.visit(ast.falseExp, context);\n    }\n    visitPipe(ast, context) {\n        this.visit(ast.exp, context);\n        this.visitAll(ast.args, context);\n    }\n    visitImplicitReceiver(ast, context) { }\n    visitThisReceiver(ast, context) { }\n    visitInterpolation(ast, context) {\n        this.visitAll(ast.expressions, context);\n    }\n    visitKeyedRead(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.key, context);\n    }\n    visitKeyedWrite(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.key, context);\n        this.visit(ast.value, context);\n    }\n    visitLiteralArray(ast, context) {\n        this.visitAll(ast.expressions, context);\n    }\n    visitLiteralMap(ast, context) {\n        this.visitAll(ast.values, context);\n    }\n    visitLiteralPrimitive(ast, context) { }\n    visitPrefixNot(ast, context) {\n        this.visit(ast.expression, context);\n    }\n    visitNonNullAssert(ast, context) {\n        this.visit(ast.expression, context);\n    }\n    visitPropertyRead(ast, context) {\n        this.visit(ast.receiver, context);\n    }\n    visitPropertyWrite(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.value, context);\n    }\n    visitSafePropertyRead(ast, context) {\n        this.visit(ast.receiver, context);\n    }\n    visitSafeKeyedRead(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.key, context);\n    }\n    visitCall(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visitAll(ast.args, context);\n    }\n    visitSafeCall(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visitAll(ast.args, context);\n    }\n    // This is not part of the AstVisitor interface, just a helper method\n    visitAll(asts, context) {\n        for (const ast of asts) {\n            this.visit(ast, context);\n        }\n    }\n}\nclass AstTransformer {\n    visitImplicitReceiver(ast, context) {\n        return ast;\n    }\n    visitThisReceiver(ast, context) {\n        return ast;\n    }\n    visitInterpolation(ast, context) {\n        return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n    }\n    visitLiteralPrimitive(ast, context) {\n        return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n    }\n    visitPropertyRead(ast, context) {\n        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n    visitPropertyWrite(ast, context) {\n        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    }\n    visitSafePropertyRead(ast, context) {\n        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n    visitLiteralArray(ast, context) {\n        return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n    visitLiteralMap(ast, context) {\n        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n    }\n    visitUnary(ast, context) {\n        switch (ast.operator) {\n            case '+':\n                return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n            case '-':\n                return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n            default:\n                throw new Error(`Unknown unary operator ${ast.operator}`);\n        }\n    }\n    visitBinary(ast, context) {\n        return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    }\n    visitPrefixNot(ast, context) {\n        return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n    visitNonNullAssert(ast, context) {\n        return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n    visitConditional(ast, context) {\n        return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    }\n    visitPipe(ast, context) {\n        return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);\n    }\n    visitKeyedRead(ast, context) {\n        return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n    }\n    visitKeyedWrite(ast, context) {\n        return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));\n    }\n    visitCall(ast, context) {\n        return new Call(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);\n    }\n    visitSafeCall(ast, context) {\n        return new SafeCall(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);\n    }\n    visitAll(asts) {\n        const res = [];\n        for (let i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    }\n    visitChain(ast, context) {\n        return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n    visitSafeKeyedRead(ast, context) {\n        return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n    }\n}\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nclass AstMemoryEfficientTransformer {\n    visitImplicitReceiver(ast, context) {\n        return ast;\n    }\n    visitThisReceiver(ast, context) {\n        return ast;\n    }\n    visitInterpolation(ast, context) {\n        const expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions)\n            return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n        return ast;\n    }\n    visitLiteralPrimitive(ast, context) {\n        return ast;\n    }\n    visitPropertyRead(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n        }\n        return ast;\n    }\n    visitPropertyWrite(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        const value = ast.value.visit(this);\n        if (receiver !== ast.receiver || value !== ast.value) {\n            return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n        }\n        return ast;\n    }\n    visitSafePropertyRead(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n        }\n        return ast;\n    }\n    visitLiteralArray(ast, context) {\n        const expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n        }\n        return ast;\n    }\n    visitLiteralMap(ast, context) {\n        const values = this.visitAll(ast.values);\n        if (values !== ast.values) {\n            return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n        }\n        return ast;\n    }\n    visitUnary(ast, context) {\n        const expr = ast.expr.visit(this);\n        if (expr !== ast.expr) {\n            switch (ast.operator) {\n                case '+':\n                    return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n                case '-':\n                    return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n                default:\n                    throw new Error(`Unknown unary operator ${ast.operator}`);\n            }\n        }\n        return ast;\n    }\n    visitBinary(ast, context) {\n        const left = ast.left.visit(this);\n        const right = ast.right.visit(this);\n        if (left !== ast.left || right !== ast.right) {\n            return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n        }\n        return ast;\n    }\n    visitPrefixNot(ast, context) {\n        const expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new PrefixNot(ast.span, ast.sourceSpan, expression);\n        }\n        return ast;\n    }\n    visitNonNullAssert(ast, context) {\n        const expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n        }\n        return ast;\n    }\n    visitConditional(ast, context) {\n        const condition = ast.condition.visit(this);\n        const trueExp = ast.trueExp.visit(this);\n        const falseExp = ast.falseExp.visit(this);\n        if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n            return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n        }\n        return ast;\n    }\n    visitPipe(ast, context) {\n        const exp = ast.exp.visit(this);\n        const args = this.visitAll(ast.args);\n        if (exp !== ast.exp || args !== ast.args) {\n            return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n        }\n        return ast;\n    }\n    visitKeyedRead(ast, context) {\n        const obj = ast.receiver.visit(this);\n        const key = ast.key.visit(this);\n        if (obj !== ast.receiver || key !== ast.key) {\n            return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n        }\n        return ast;\n    }\n    visitKeyedWrite(ast, context) {\n        const obj = ast.receiver.visit(this);\n        const key = ast.key.visit(this);\n        const value = ast.value.visit(this);\n        if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {\n            return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n        }\n        return ast;\n    }\n    visitAll(asts) {\n        const res = [];\n        let modified = false;\n        for (let i = 0; i < asts.length; ++i) {\n            const original = asts[i];\n            const value = original.visit(this);\n            res[i] = value;\n            modified = modified || value !== original;\n        }\n        return modified ? res : asts;\n    }\n    visitChain(ast, context) {\n        const expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new Chain(ast.span, ast.sourceSpan, expressions);\n        }\n        return ast;\n    }\n    visitCall(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        const args = this.visitAll(ast.args);\n        if (receiver !== ast.receiver || args !== ast.args) {\n            return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n        }\n        return ast;\n    }\n    visitSafeCall(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        const args = this.visitAll(ast.args);\n        if (receiver !== ast.receiver || args !== ast.args) {\n            return new SafeCall(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n        }\n        return ast;\n    }\n    visitSafeKeyedRead(ast, context) {\n        const obj = ast.receiver.visit(this);\n        const key = ast.key.visit(this);\n        if (obj !== ast.receiver || key !== ast.key) {\n            return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);\n        }\n        return ast;\n    }\n}\n// Bindings\nclass ParsedProperty {\n    constructor(name, expression, type, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.isLiteral = this.type === exports.ParsedPropertyType.LITERAL_ATTR;\n        this.isAnimation = this.type === exports.ParsedPropertyType.ANIMATION;\n    }\n}\nexports.ParsedPropertyType = void 0;\n(function (ParsedPropertyType) {\n    ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n    ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\n})(exports.ParsedPropertyType || (exports.ParsedPropertyType = {}));\nclass ParsedEvent {\n    // Regular events have a target\n    // Animation events have a phase\n    constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {\n        this.name = name;\n        this.targetOrPhase = targetOrPhase;\n        this.type = type;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n        this.keySpan = keySpan;\n    }\n}\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nclass ParsedVariable {\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n}\nclass BoundElementProperty {\n    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass EventHandlerVars {\n}\nEventHandlerVars.event = variable('$event');\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId, baseSourceSpan, implicitReceiverAccesses, globals) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver(globals);\n    }\n    const actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: (argCount) => {\n            // Note: no caching for literal arrays in actions.\n            return (args) => literalArr(args);\n        },\n        createLiteralMapConverter: (keys) => {\n            // Note: no caching for literal maps in actions.\n            return (values) => {\n                const entries = keys.map((k, i) => ({\n                    key: k.key,\n                    value: values[i],\n                    quoted: k.quoted,\n                }));\n                return literalMap(entries);\n            };\n        },\n        createPipeConverter: (name) => {\n            throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n    }, action);\n    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false, baseSourceSpan, implicitReceiverAccesses);\n    const actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    const lastIndex = actionStmts.length - 1;\n    if (lastIndex >= 0) {\n        const lastStatement = actionStmts[lastIndex];\n        // Ensure that the value of the last expression statement is returned\n        if (lastStatement instanceof ExpressionStatement) {\n            actionStmts[lastIndex] = new ReturnStatement(lastStatement.expr);\n        }\n    }\n    return actionStmts;\n}\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nclass ConvertPropertyBindingResult {\n    constructor(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n}\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false);\n    const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    const stmts = getStatementsFromVisitor(visitor, bindingId);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    return new ConvertPropertyBindingResult(stmts, outputExpr);\n}\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nfunction convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {\n    const visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, /* supportsInterpolation */ true);\n    const outputExpr = visitor.visitInterpolation(expressionWithArgumentsToExtract, _Mode.Expression);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    const stmts = getStatementsFromVisitor(visitor, bindingId);\n    const args = outputExpr.args;\n    return { stmts, args };\n}\nfunction getStatementsFromVisitor(visitor, bindingId) {\n    const stmts = [];\n    for (let i = 0; i < visitor.temporaryCount; i++) {\n        stmts.push(temporaryDeclaration(bindingId, i));\n    }\n    return stmts;\n}\nfunction convertBuiltins(converterFactory, ast) {\n    const visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\nfunction temporaryName(bindingId, temporaryNumber) {\n    return `tmp_${bindingId}_${temporaryNumber}`;\n}\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));\n}\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (let i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\nvar _Mode;\n(function (_Mode) {\n    _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\n    _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\n})(_Mode || (_Mode = {}));\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(`Expected a statement, but saw ${ast}`);\n    }\n}\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(`Expected an expression, but saw ${ast}`);\n    }\n}\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nclass _BuiltinAstConverter extends AstTransformer {\n    constructor(_converterFactory) {\n        super();\n        this._converterFactory = _converterFactory;\n    }\n    visitPipe(ast, context) {\n        const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    }\n    visitLiteralArray(ast, context) {\n        const args = ast.expressions.map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    }\n    visitLiteralMap(ast, context) {\n        const args = ast.values.map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    }\n}\nclass _AstToIrVisitor {\n    constructor(_localResolver, _implicitReceiver, bindingId, supportsInterpolation, baseSourceSpan, implicitReceiverAccesses) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this.supportsInterpolation = supportsInterpolation;\n        this.baseSourceSpan = baseSourceSpan;\n        this.implicitReceiverAccesses = implicitReceiverAccesses;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n        this.usesImplicitReceiver = false;\n    }\n    visitUnary(ast, mode) {\n        let op;\n        switch (ast.operator) {\n            case '+':\n                op = exports.UnaryOperator.Plus;\n                break;\n            case '-':\n                op = exports.UnaryOperator.Minus;\n                break;\n            default:\n                throw new Error(`Unsupported operator ${ast.operator}`);\n        }\n        return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    }\n    visitBinary(ast, mode) {\n        let op;\n        switch (ast.operation) {\n            case '+':\n                op = exports.BinaryOperator.Plus;\n                break;\n            case '-':\n                op = exports.BinaryOperator.Minus;\n                break;\n            case '*':\n                op = exports.BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = exports.BinaryOperator.Divide;\n                break;\n            case '%':\n                op = exports.BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = exports.BinaryOperator.And;\n                break;\n            case '||':\n                op = exports.BinaryOperator.Or;\n                break;\n            case '==':\n                op = exports.BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = exports.BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = exports.BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = exports.BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = exports.BinaryOperator.Lower;\n                break;\n            case '>':\n                op = exports.BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = exports.BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = exports.BinaryOperator.BiggerEquals;\n                break;\n            case '??':\n                return this.convertNullishCoalesce(ast, mode);\n            default:\n                throw new Error(`Unsupported operation ${ast.operation}`);\n        }\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    }\n    visitChain(ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    }\n    visitConditional(ast, mode) {\n        const value = this._visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\n    }\n    visitPipe(ast, mode) {\n        throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n    }\n    visitImplicitReceiver(ast, mode) {\n        ensureExpressionMode(mode, ast);\n        this.usesImplicitReceiver = true;\n        return this._implicitReceiver;\n    }\n    visitThisReceiver(ast, mode) {\n        return this.visitImplicitReceiver(ast, mode);\n    }\n    visitInterpolation(ast, mode) {\n        if (!this.supportsInterpolation) {\n            throw new Error('Unexpected interpolation');\n        }\n        ensureExpressionMode(mode, ast);\n        let args = [];\n        for (let i = 0; i < ast.strings.length - 1; i++) {\n            args.push(literal(ast.strings[i]));\n            args.push(this._visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(literal(ast.strings[ast.strings.length - 1]));\n        // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n        // args returned to just the value, because we're going to pass it to a special instruction.\n        const strings = ast.strings;\n        if (strings.length === 2 && strings[0] === '' && strings[1] === '') {\n            // Single argument interpolate instructions.\n            args = [args[1]];\n        }\n        else if (ast.expressions.length >= 9) {\n            // 9 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n            // an array of arguments\n            args = [literalArr(args)];\n        }\n        return new InterpolationExpression(args);\n    }\n    visitKeyedRead(ast, mode) {\n        const leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n        }\n    }\n    visitKeyedWrite(ast, mode) {\n        const obj = this._visit(ast.receiver, _Mode.Expression);\n        const key = this._visit(ast.key, _Mode.Expression);\n        const value = this._visit(ast.value, _Mode.Expression);\n        if (obj === this._implicitReceiver) {\n            this._localResolver.maybeRestoreView();\n        }\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    }\n    visitLiteralArray(ast, mode) {\n        throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n    }\n    visitLiteralMap(ast, mode) {\n        throw new Error(`Illegal State: literal maps should have been converted into functions`);\n    }\n    visitLiteralPrimitive(ast, mode) {\n        // For literal values of null, undefined, true, or false allow type interference\n        // to infer the type.\n        const type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n            INFERRED_TYPE :\n            undefined;\n        return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));\n    }\n    _getLocal(name, receiver) {\n        var _a;\n        if (((_a = this._localResolver.globals) === null || _a === void 0 ? void 0 : _a.has(name)) && receiver instanceof ThisReceiver) {\n            return null;\n        }\n        return this._localResolver.getLocal(name);\n    }\n    visitPrefixNot(ast, mode) {\n        return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));\n    }\n    visitNonNullAssert(ast, mode) {\n        return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));\n    }\n    visitPropertyRead(ast, mode) {\n        const leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            let result = null;\n            const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n            const receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name, ast.receiver);\n                if (result) {\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                    this.addImplicitReceiverAccess(ast.name);\n                }\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    }\n    visitPropertyWrite(ast, mode) {\n        const receiver = this._visit(ast.receiver, _Mode.Expression);\n        const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n        let varExpr = null;\n        if (receiver === this._implicitReceiver) {\n            const localExpr = this._getLocal(ast.name, ast.receiver);\n            if (localExpr) {\n                if (localExpr instanceof ReadPropExpr) {\n                    // If the local variable is a property read expression, it's a reference\n                    // to a 'context.property' value and will be used as the target of the\n                    // write expression.\n                    varExpr = localExpr;\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                    this.addImplicitReceiverAccess(ast.name);\n                }\n                else {\n                    // Otherwise it's an error.\n                    const receiver = ast.name;\n                    const value = (ast.value instanceof PropertyRead) ? ast.value.name : undefined;\n                    throw new Error(`Cannot assign value \"${value}\" to template variable \"${receiver}\". Template variables are read-only.`);\n                }\n            }\n        }\n        // If no local expression could be produced, use the original receiver's\n        // property as the target.\n        if (varExpr === null) {\n            varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n        }\n        return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n    }\n    visitSafePropertyRead(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    visitSafeKeyedRead(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    visitAll(asts, mode) {\n        return asts.map(ast => this._visit(ast, mode));\n    }\n    visitCall(ast, mode) {\n        const leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        if (ast instanceof BuiltinFunctionCall) {\n            return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));\n        }\n        const receiver = ast.receiver;\n        if (receiver instanceof PropertyRead &&\n            receiver.receiver instanceof ImplicitReceiver &&\n            !(receiver.receiver instanceof ThisReceiver) && receiver.name === '$any') {\n            if (convertedArgs.length !== 1) {\n                throw new Error(`Invalid call to $any, expected 1 argument but received ${convertedArgs.length || 'none'}`);\n            }\n            return convertToStatementIfNeeded(mode, convertedArgs[0]);\n        }\n        const call = this._visit(receiver, _Mode.Expression)\n            .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n        return convertToStatementIfNeeded(mode, call);\n    }\n    visitSafeCall(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    _visit(ast, mode) {\n        const result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    }\n    convertSafeAccess(ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  .   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n        let temporary = undefined;\n        if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        const condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof SafeCall) {\n            this._nodeMap.set(leftMostSafe, new Call(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.args, leftMostSafe.argumentSpan));\n        }\n        else if (leftMostSafe instanceof SafeKeyedRead) {\n            this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        const access = this._visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));\n    }\n    convertNullishCoalesce(ast, mode) {\n        const left = this._visit(ast.left, _Mode.Expression);\n        const right = this._visit(ast.right, _Mode.Expression);\n        const temporary = this.allocateTemporary();\n        this.releaseTemporary(temporary);\n        // Generate the following expression. It is identical to how TS\n        // transpiles binary expressions with a nullish coalescing operator.\n        // let temp;\n        // (temp = a) !== null && temp !== undefined ? temp : b;\n        return convertToStatementIfNeeded(mode, temporary.set(left)\n            .notIdentical(NULL_EXPR)\n            .and(temporary.notIdentical(literal(undefined)))\n            .conditional(temporary, right));\n    }\n    // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n    // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n    // safe method call as this needs to be transformed initially to:\n    //   a == null ? null : a.c.b.c?.d.e\n    // then to:\n    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n    leftMostSafeNode(ast) {\n        const visit = (visitor, ast) => {\n            return (this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            visitUnary(ast) {\n                return null;\n            },\n            visitBinary(ast) {\n                return null;\n            },\n            visitChain(ast) {\n                return null;\n            },\n            visitConditional(ast) {\n                return null;\n            },\n            visitCall(ast) {\n                return visit(this, ast.receiver);\n            },\n            visitSafeCall(ast) {\n                return visit(this, ast.receiver) || ast;\n            },\n            visitImplicitReceiver(ast) {\n                return null;\n            },\n            visitThisReceiver(ast) {\n                return null;\n            },\n            visitInterpolation(ast) {\n                return null;\n            },\n            visitKeyedRead(ast) {\n                return visit(this, ast.receiver);\n            },\n            visitKeyedWrite(ast) {\n                return null;\n            },\n            visitLiteralArray(ast) {\n                return null;\n            },\n            visitLiteralMap(ast) {\n                return null;\n            },\n            visitLiteralPrimitive(ast) {\n                return null;\n            },\n            visitPipe(ast) {\n                return null;\n            },\n            visitPrefixNot(ast) {\n                return null;\n            },\n            visitNonNullAssert(ast) {\n                return null;\n            },\n            visitPropertyRead(ast) {\n                return visit(this, ast.receiver);\n            },\n            visitPropertyWrite(ast) {\n                return null;\n            },\n            visitSafePropertyRead(ast) {\n                return visit(this, ast.receiver) || ast;\n            },\n            visitSafeKeyedRead(ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    }\n    // Returns true of the AST includes a method or a pipe indicating that, if the\n    // expression is used as the target of a safe property or method access then\n    // the expression should be stored into a temporary variable.\n    needsTemporaryInSafeAccess(ast) {\n        const visit = (visitor, ast) => {\n            return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        const visitSome = (visitor, ast) => {\n            return ast.some(ast => visit(visitor, ast));\n        };\n        return ast.visit({\n            visitUnary(ast) {\n                return visit(this, ast.expr);\n            },\n            visitBinary(ast) {\n                return visit(this, ast.left) || visit(this, ast.right);\n            },\n            visitChain(ast) {\n                return false;\n            },\n            visitConditional(ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n            },\n            visitCall(ast) {\n                return true;\n            },\n            visitSafeCall(ast) {\n                return true;\n            },\n            visitImplicitReceiver(ast) {\n                return false;\n            },\n            visitThisReceiver(ast) {\n                return false;\n            },\n            visitInterpolation(ast) {\n                return visitSome(this, ast.expressions);\n            },\n            visitKeyedRead(ast) {\n                return false;\n            },\n            visitKeyedWrite(ast) {\n                return false;\n            },\n            visitLiteralArray(ast) {\n                return true;\n            },\n            visitLiteralMap(ast) {\n                return true;\n            },\n            visitLiteralPrimitive(ast) {\n                return false;\n            },\n            visitPipe(ast) {\n                return true;\n            },\n            visitPrefixNot(ast) {\n                return visit(this, ast.expression);\n            },\n            visitNonNullAssert(ast) {\n                return visit(this, ast.expression);\n            },\n            visitPropertyRead(ast) {\n                return false;\n            },\n            visitPropertyWrite(ast) {\n                return false;\n            },\n            visitSafePropertyRead(ast) {\n                return false;\n            },\n            visitSafeKeyedRead(ast) {\n                return false;\n            }\n        });\n    }\n    allocateTemporary() {\n        const tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    }\n    releaseTemporary(temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(`Temporary ${temporary.name} released out of order`);\n        }\n    }\n    /**\n     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n     *\n     * `ParseSpan` objects are relative to the start of the expression.\n     * This method converts these to full `ParseSourceSpan` objects that\n     * show where the span is within the overall source file.\n     *\n     * @param span the relative span to convert.\n     * @returns a `ParseSourceSpan` for the given span or null if no\n     * `baseSourceSpan` was provided to this class.\n     */\n    convertSourceSpan(span) {\n        if (this.baseSourceSpan) {\n            const start = this.baseSourceSpan.start.moveBy(span.start);\n            const end = this.baseSourceSpan.start.moveBy(span.end);\n            const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n            return new ParseSourceSpan(start, end, fullStart);\n        }\n        else {\n            return null;\n        }\n    }\n    /** Adds the name of an AST to the list of implicit receiver accesses. */\n    addImplicitReceiverAccess(name) {\n        if (this.implicitReceiverAccesses) {\n            this.implicitReceiverAccesses.add(name);\n        }\n    }\n}\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        arg.forEach((entry) => flattenStatements(entry, output));\n    }\n    else {\n        output.push(arg);\n    }\n}\nfunction unsupported() {\n    throw new Error('Unsupported operation');\n}\nclass InterpolationExpression extends Expression {\n    constructor(args) {\n        super(null, null);\n        this.args = args;\n        this.isConstant = unsupported;\n        this.isEquivalent = unsupported;\n        this.visitExpression = unsupported;\n    }\n}\nclass DefaultLocalResolver {\n    constructor(globals) {\n        this.globals = globals;\n    }\n    notifyImplicitReceiverUse() { }\n    maybeRestoreView() { }\n    getLocal(name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    }\n}\nclass BuiltinFunctionCall extends Call {\n    constructor(span, sourceSpan, args, converter) {\n        super(span, sourceSpan, new EmptyExpr(span, sourceSpan), args, null);\n        this.converter = converter;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n *\n * Please make sure to keep to edits in sync with the source file.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\n  this feature.\n\n  By default, rules are prefixed with the host element tag name\n  as a descendant selector. This ensures styling does not leak out of the 'top'\n  of the element's ShadowDOM. For example,\n\n  div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n  x-foo div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\n  selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\nclass ShadowCss {\n    constructor() {\n        this.strictStyling = true;\n    }\n    /*\n     * Shim some cssText with the given selector. Returns cssText that can\n     * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\n     *\n     * When strictStyling is true:\n     * - selector is the attribute added to all elements inside the host,\n     * - hostSelector is the attribute added to the host itself.\n     */\n    shimCssText(cssText, selector, hostSelector = '') {\n        const commentsWithHash = extractCommentsWithHash(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n        return [scopedCssText, ...commentsWithHash].join('\\n');\n    }\n    _insertDirectives(cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    }\n    /*\n     * Process styles to convert native ShadowDOM rules that will trip\n     * up the css parser; we rely on decorating the stylesheet with inert rules.\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-next-selector { content: ':host menu-item'; }\n     * ::content menu-item {\n     *\n     * to this:\n     *\n     * scopeName menu-item {\n     *\n     **/\n    _insertPolyfillDirectivesInCssText(cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentNextSelectorRe, function (...m) {\n            return m[2] + '{';\n        });\n    }\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-rule {\n     *   content: ':host menu-item';\n     * ...\n     * }\n     *\n     * to this:\n     *\n     * scopeName menu-item {...}\n     *\n     **/\n    _insertPolyfillRulesInCssText(cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        return cssText.replace(_cssContentRuleRe, (...m) => {\n            const rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    }\n    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n     *\n     *  .foo {... }\n     *\n     *  and converts this to\n     *\n     *  scopeName .foo { ... }\n     */\n    _scopeCssText(cssText, scopeSelector, hostSelector) {\n        const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    }\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n     * occasions, e.g. -webkit-calc on Safari.)\n     * For example, we convert this rule:\n     *\n     * @polyfill-unscoped-rule {\n     *   content: 'menu-item';\n     * ... }\n     *\n     * to this:\n     *\n     * menu-item {...}\n     *\n     **/\n    _extractUnscopedRulesFromCssText(cssText) {\n        // Difference with webcomponents.js: does not handle comments\n        let r = '';\n        let m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    }\n    /*\n     * convert a rule like :host(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar\n     */\n    _convertColonHost(cssText) {\n        return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {\n            if (hostSelectors) {\n                const convertedSelectors = [];\n                const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());\n                for (const hostSelector of hostSelectorArray) {\n                    if (!hostSelector)\n                        break;\n                    const convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n                    convertedSelectors.push(convertedSelector);\n                }\n                return convertedSelectors.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + otherSelectors;\n            }\n        });\n    }\n    /*\n     * convert a rule like :host-context(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n     *\n     * and\n     *\n     * :host-context(.foo:host) .bar { ... }\n     *\n     * to\n     *\n     * .foo<scopeName> .bar { ... }\n     */\n    _convertColonHostContext(cssText) {\n        return cssText.replace(_cssColonHostContextReGlobal, selectorText => {\n            var _a;\n            // We have captured a selector that contains a `:host-context` rule.\n            // For backward compatibility `:host-context` may contain a comma separated list of selectors.\n            // Each context selector group will contain a list of host-context selectors that must match\n            // an ancestor of the host.\n            // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\n            const contextSelectorGroups = [[]];\n            // There may be more than `:host-context` in this selector so `selectorText` could look like:\n            // `:host-context(.one):host-context(.two)`.\n            // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n            // `:host-context` selectors from this selector.\n            let match;\n            while (match = _cssColonHostContextRe.exec(selectorText)) {\n                // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n                // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\n                const newContextSelectors = ((_a = match[1]) !== null && _a !== void 0 ? _a : '').trim().split(',').map(m => m.trim()).filter(m => m !== '');\n                // We must duplicate the current selector group for each of these new selectors.\n                // For example if the current groups are:\n                // ```\n                // [\n                //   ['a', 'b', 'c'],\n                //   ['x', 'y', 'z'],\n                // ]\n                // ```\n                // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\n                // groups are:\n                // ```\n                // [\n                //   ['a', 'b', 'c', 'm'],\n                //   ['x', 'y', 'z', 'm'],\n                //   ['a', 'b', 'c', 'n'],\n                //   ['x', 'y', 'z', 'n'],\n                // ]\n                // ```\n                const contextSelectorGroupsLength = contextSelectorGroups.length;\n                repeatGroups(contextSelectorGroups, newContextSelectors.length);\n                for (let i = 0; i < newContextSelectors.length; i++) {\n                    for (let j = 0; j < contextSelectorGroupsLength; j++) {\n                        contextSelectorGroups[j + (i * contextSelectorGroupsLength)].push(newContextSelectors[i]);\n                    }\n                }\n                // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\n                selectorText = match[2];\n            }\n            // The context selectors now must be combined with each other to capture all the possible\n            // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more\n            // info about how this is done.\n            return contextSelectorGroups\n                .map(contextSelectors => combineHostContextSelectors(contextSelectors, selectorText))\n                .join(', ');\n        });\n    }\n    /*\n     * Convert combinators like ::shadow and pseudo-elements like ::content\n     * by replacing with space.\n     */\n    _convertShadowDOMSelectors(cssText) {\n        return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n    }\n    // change a selector like 'div' to 'name div'\n    _scopeSelectors(cssText, scopeSelector, hostSelector) {\n        return processRules(cssText, (rule) => {\n            let selector = rule.selector;\n            let content = rule.content;\n            if (rule.selector[0] !== '@') {\n                selector =\n                    this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@document') || rule.selector.startsWith('@layer')) {\n                content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n                content = this._stripScopingSelectors(rule.content);\n            }\n            return new CssRule(selector, content);\n        });\n    }\n    /**\n     * Handle a css text that is within a rule that should not contain scope selectors by simply\n     * removing them! An example of such a rule is `@font-face`.\n     *\n     * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\n     * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\n     * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\n     * can end up with broken css if the imported styles happen to contain @font-face rules.\n     *\n     * For example:\n     *\n     * ```\n     * :host ::ng-deep {\n     *   import 'some/lib/containing/font-face';\n     * }\n     *\n     * Similar logic applies to `@page` rules which can contain a particular set of properties,\n     * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\n     * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\n     * ```\n     */\n    _stripScopingSelectors(cssText) {\n        return processRules(cssText, rule => {\n            const selector = rule.selector.replace(_shadowDeepSelectors, ' ')\n                .replace(_polyfillHostNoCombinatorRe, ' ');\n            return new CssRule(selector, rule.content);\n        });\n    }\n    _scopeSelector(selector, scopeSelector, hostSelector, strict) {\n        return selector.split(',')\n            .map(part => part.trim().split(_shadowDeepSelectors))\n            .map((deepParts) => {\n            const [shallowPart, ...otherParts] = deepParts;\n            const applyScope = (shallowPart) => {\n                if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return strict ?\n                        this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                        this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return [applyScope(shallowPart), ...otherParts].join(' ');\n        })\n            .join(', ');\n    }\n    _selectorNeedsScoping(selector, scopeSelector) {\n        const re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    }\n    _makeScopeMatcher(scopeSelector) {\n        const lre = /\\[/g;\n        const rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    }\n    _applySelectorScope(selector, scopeSelector, hostSelector) {\n        // Difference from webcomponents.js: scopeSelector could not be an array\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    }\n    // scope via name and [is=name]\n    _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, (hnc, selector) => {\n                return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {\n                    return before + replaceBy + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    }\n    // return a selector with [name] suffix on each simple selector\n    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n    _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {\n        const isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);\n        const attrName = '[' + scopeSelector + ']';\n        const _scopeSelectorPart = (p) => {\n            let scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                const t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    const matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        const safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        let scopedSelector = '';\n        let startIndex = 0;\n        let res;\n        const sep = /( |>|\\+|~(?!=))\\s*/g;\n        // If a selector appears before :host it should not be shimmed as it\n        // matches on ancestor elements and not on elements in the host's shadow\n        // `:host-context(div)` is transformed to\n        // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n        // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n        // Historically `component-tag:host` was matching the component so we also want to preserve\n        // this behavior to avoid breaking legacy apps (it should not match).\n        // The behavior should be:\n        // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n        // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n        //   `:host-context(tag)`)\n        const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n        // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n        let shouldScope = !hasHost;\n        while ((res = sep.exec(selector)) !== null) {\n            const separator = res[1];\n            const part = selector.slice(startIndex, res.index).trim();\n            shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n            const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n            scopedSelector += `${scopedPart} ${separator} `;\n            startIndex = sep.lastIndex;\n        }\n        const part = selector.substring(startIndex);\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    }\n    _insertPolyfillHostInCssText(selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    }\n}\nclass SafeSelector {\n    constructor(selector) {\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n        // CSS allows for certain special characters to be used in selectors if they're escaped.\n        // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\n        // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\n        // Replace all escape sequences (`\\` followed by a character) with a placeholder so\n        // that our handling of pseudo-selectors doesn't mess with them.\n        selector = this._escapeRegexMatches(selector, /(\\\\.)/g);\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n            const replaceBy = `__ph-${this.index}__`;\n            this.placeholders.push(exp);\n            this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    restore(content) {\n        return content.replace(/__ph-(\\d+)__/g, (_ph, index) => this.placeholders[+index]);\n    }\n    content() {\n        return this._content;\n    }\n    /**\n     * Replaces all of the substrings that match a regex within a\n     * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\n     */\n    _escapeRegexMatches(content, pattern) {\n        return content.replace(pattern, (_, keep) => {\n            const replaceBy = `__ph-${this.index}__`;\n            this.placeholders.push(keep);\n            this.index++;\n            return replaceBy;\n        });\n    }\n}\nconst _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _parenSuffix = '(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\nconst _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\nconst _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    // Deprecated selectors\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nfunction extractCommentsWithHash(input) {\n    return input.match(_commentWithHashRe) || [];\n}\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst QUOTE_PLACEHOLDER = '%QUOTED%';\nconst _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nconst _quotedRe = /%QUOTED%/g;\nconst CONTENT_PAIRS = new Map([['{', '}']]);\nconst QUOTE_PAIRS = new Map([[`\"`, `\"`], [`'`, `'`]]);\nclass CssRule {\n    constructor(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n}\nfunction processRules(input, ruleCallback) {\n    const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);\n    const inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n    let nextBlockIndex = 0;\n    let nextQuoteIndex = 0;\n    return inputWithEscapedBlocks.escapedString\n        .replace(_ruleRe, (...m) => {\n        const selector = m[2];\n        let content = '';\n        let suffix = m[4];\n        let contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        const rule = ruleCallback(new CssRule(selector, content));\n        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n    })\n        .replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);\n}\nclass StringWithEscapedBlocks {\n    constructor(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n}\nfunction escapeBlocks(input, charPairs, placeholder) {\n    const resultParts = [];\n    const escapedBlocks = [];\n    let openCharCount = 0;\n    let nonBlockStartIndex = 0;\n    let blockStartIndex = -1;\n    let openChar;\n    let closeChar;\n    for (let i = 0; i < input.length; i++) {\n        const char = input[i];\n        if (char === '\\\\') {\n            i++;\n        }\n        else if (char === closeChar) {\n            openCharCount--;\n            if (openCharCount === 0) {\n                escapedBlocks.push(input.substring(blockStartIndex, i));\n                resultParts.push(placeholder);\n                nonBlockStartIndex = i;\n                blockStartIndex = -1;\n                openChar = closeChar = undefined;\n            }\n        }\n        else if (char === openChar) {\n            openCharCount++;\n        }\n        else if (openCharCount === 0 && charPairs.has(char)) {\n            openChar = char;\n            closeChar = charPairs.get(char);\n            openCharCount = 1;\n            blockStartIndex = i + 1;\n            resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n        }\n    }\n    if (blockStartIndex !== -1) {\n        escapedBlocks.push(input.substring(blockStartIndex));\n        resultParts.push(placeholder);\n    }\n    else {\n        resultParts.push(input.substring(nonBlockStartIndex));\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n/**\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n * to create a selector that matches the same as `:host-context()`.\n *\n * Given a single context selector `A` we need to output selectors that match on the host and as an\n * ancestor of the host:\n *\n * ```\n * A <hostMarker>, A<hostMarker> {}\n * ```\n *\n * When there is more than one context selector we also have to create combinations of those\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\n *\n * ```\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n * ```\n *\n * And so on...\n *\n * @param hostMarker the string that selects the host element.\n * @param contextSelectors an array of context selectors that will be combined.\n * @param otherSelectors the rest of the selectors that are not context selectors.\n */\nfunction combineHostContextSelectors(contextSelectors, otherSelectors) {\n    const hostMarker = _polyfillHostNoCombinator;\n    _polyfillHostRe.lastIndex = 0; // reset the regex to ensure we get an accurate test\n    const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n    // If there are no context selectors then just output a host marker\n    if (contextSelectors.length === 0) {\n        return hostMarker + otherSelectors;\n    }\n    const combined = [contextSelectors.pop() || ''];\n    while (contextSelectors.length > 0) {\n        const length = combined.length;\n        const contextSelector = contextSelectors.pop();\n        for (let i = 0; i < length; i++) {\n            const previousSelectors = combined[i];\n            // Add the new selector as a descendant of the previous selectors\n            combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n            // Add the new selector as an ancestor of the previous selectors\n            combined[length + i] = contextSelector + ' ' + previousSelectors;\n            // Add the new selector to act on the same element as the previous selectors\n            combined[i] = contextSelector + previousSelectors;\n        }\n    }\n    // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n    // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n    return combined\n        .map(s => otherSelectorsHasHost ?\n        `${s}${otherSelectors}` :\n        `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\n        .join(',');\n}\n/**\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\n * stored.\n *\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\n * newly added groups will be clones of the original.\n *\n * @param groups An array of groups of strings that will be repeated. This array is mutated\n *     in-place.\n * @param multiples The number of times the current groups should appear.\n */\nfunction repeatGroups(groups, multiples) {\n    const length = groups.length;\n    for (let i = 1; i < multiples; i++) {\n        for (let j = 0; j < length; j++) {\n            groups[j + (i * length)] = groups[j].slice(0);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nfunction parse(value) {\n    // we use a string array here instead of a string map\n    // because a string-map is not guaranteed to retain the\n    // order of the entries whereas a string array can be\n    // constructed in a [key, value, key, value] format.\n    const styles = [];\n    let i = 0;\n    let parenDepth = 0;\n    let quote = 0 /* Char.QuoteNone */;\n    let valueStart = 0;\n    let propStart = 0;\n    let currentProp = null;\n    let valueHasQuotes = false;\n    while (i < value.length) {\n        const token = value.charCodeAt(i++);\n        switch (token) {\n            case 40 /* Char.OpenParen */:\n                parenDepth++;\n                break;\n            case 41 /* Char.CloseParen */:\n                parenDepth--;\n                break;\n            case 39 /* Char.QuoteSingle */:\n                // valueStart needs to be there since prop values don't\n                // have quotes in CSS\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\n                if (quote === 0 /* Char.QuoteNone */) {\n                    quote = 39 /* Char.QuoteSingle */;\n                }\n                else if (quote === 39 /* Char.QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* Char.BackSlash */) {\n                    quote = 0 /* Char.QuoteNone */;\n                }\n                break;\n            case 34 /* Char.QuoteDouble */:\n                // same logic as above\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\n                if (quote === 0 /* Char.QuoteNone */) {\n                    quote = 34 /* Char.QuoteDouble */;\n                }\n                else if (quote === 34 /* Char.QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* Char.BackSlash */) {\n                    quote = 0 /* Char.QuoteNone */;\n                }\n                break;\n            case 58 /* Char.Colon */:\n                if (!currentProp && parenDepth === 0 && quote === 0 /* Char.QuoteNone */) {\n                    currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n                    valueStart = i;\n                }\n                break;\n            case 59 /* Char.Semicolon */:\n                if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* Char.QuoteNone */) {\n                    const styleVal = value.substring(valueStart, i - 1).trim();\n                    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n                    propStart = i;\n                    valueStart = 0;\n                    currentProp = null;\n                    valueHasQuotes = false;\n                }\n                break;\n        }\n    }\n    if (currentProp && valueStart) {\n        const styleVal = value.slice(valueStart).trim();\n        styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n    }\n    return styles;\n}\nfunction stripUnnecessaryQuotes(value) {\n    const qS = value.charCodeAt(0);\n    const qE = value.charCodeAt(value.length - 1);\n    if (qS == qE && (qS == 39 /* Char.QuoteSingle */ || qS == 34 /* Char.QuoteDouble */)) {\n        const tempValue = value.substring(1, value.length - 1);\n        // special case to avoid using a multi-quoted string that was just chomped\n        // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n        if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n            value = tempValue;\n        }\n    }\n    return value;\n}\nfunction hyphenate(value) {\n    return value\n        .replace(/[a-z][A-Z]/g, v => {\n        return v.charAt(0) + '-' + v.charAt(1);\n    })\n        .toLowerCase();\n}\n\nconst IMPORTANT_FLAG = '!important';\n/**\n * Minimum amount of binding slots required in the runtime for style/class bindings.\n *\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n * record binding data, property information and metadata.\n *\n * When a binding is registered it will place the following information in the `LView`:\n *\n * slot 1) binding value\n * slot 2) cached value (all other values collected before it in string form)\n *\n * When a binding is registered it will place the following information in the `TData`:\n *\n * slot 1) prop name\n * slot 2) binding index that points to the previous style/class binding (and some extra config\n * values)\n *\n * Let's imagine we have a binding that looks like so:\n *\n * ```\n * <div [style.width]=\"x\" [style.height]=\"y\">\n * ```\n *\n * Our `LView` and `TData` data-structures look like so:\n *\n * ```typescript\n * LView = [\n *   // ...\n *   x, // value of x\n *   \"width: x\",\n *\n *   y, // value of y\n *   \"width: x; height: y\",\n *   // ...\n * ];\n *\n * TData = [\n *   // ...\n *   \"width\", // binding slot 20\n *   0,\n *\n *   \"height\",\n *   20,\n *   // ...\n * ];\n * ```\n *\n * */\nconst MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nclass StylingBuilder {\n    constructor(_directiveExpr) {\n        this._directiveExpr = _directiveExpr;\n        /** Whether or not there are any static styling values present */\n        this._hasInitialValues = false;\n        /**\n         *  Whether or not there are any styling bindings present\n         *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n         */\n        this.hasBindings = false;\n        this.hasBindingsWithPipes = false;\n        /** the input for [class] (if it exists) */\n        this._classMapInput = null;\n        /** the input for [style] (if it exists) */\n        this._styleMapInput = null;\n        /** an array of each [style.prop] input */\n        this._singleStyleInputs = null;\n        /** an array of each [class.name] input */\n        this._singleClassInputs = null;\n        this._lastStylingInput = null;\n        this._firstStylingInput = null;\n        // maps are used instead of hash maps because a Map will\n        // retain the ordering of the keys\n        /**\n         * Represents the location of each style binding in the template\n         * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n         * that `width=0` and `height=1`)\n         */\n        this._stylesIndex = new Map();\n        /**\n         * Represents the location of each class binding in the template\n         * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n         * that `big=0` and `hidden=1`)\n         */\n        this._classesIndex = new Map();\n        this._initialStyleValues = [];\n        this._initialClassValues = [];\n    }\n    /**\n     * Registers a given input to the styling builder to be later used when producing AOT code.\n     *\n     * The code below will only accept the input if it is somehow tied to styling (whether it be\n     * style/class bindings or static style/class attributes).\n     */\n    registerBoundInput(input) {\n        // [attr.style] or [attr.class] are skipped in the code below,\n        // they should not be treated as styling-based bindings since\n        // they are intended to be written directly to the attr and\n        // will therefore skip all style/class resolution that is present\n        // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n        // [class.prop]=\"\". [class]=\"\" assignments\n        let binding = null;\n        let name = input.name;\n        switch (input.type) {\n            case 0 /* BindingType.Property */:\n                binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n                break;\n            case 3 /* BindingType.Style */:\n                binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n                break;\n            case 2 /* BindingType.Class */:\n                binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n                break;\n        }\n        return binding ? true : false;\n    }\n    registerInputBasedOnName(name, expression, sourceSpan) {\n        let binding = null;\n        const prefix = name.substring(0, 6);\n        const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n        const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n        if (isStyle || isClass) {\n            const isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no\n            const property = name.slice(isMapBased ? 5 : 6); // the dot explains why there's a +1\n            if (isStyle) {\n                binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n            }\n            else {\n                binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n            }\n        }\n        return binding;\n    }\n    registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        // CSS custom properties are case-sensitive so we shouldn't normalize them.\n        // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n        if (!isCssCustomProperty(name)) {\n            name = hyphenate(name);\n        }\n        const { property, hasOverrideFlag, suffix: bindingSuffix } = parseProperty(name);\n        suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n        const entry = { name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag };\n        if (isMapBased) {\n            this._styleMapInput = entry;\n        }\n        else {\n            (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n            registerIntoMap(this._stylesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this._checkForPipes(value);\n        this.hasBindings = true;\n        return entry;\n    }\n    registerClassInput(name, isMapBased, value, sourceSpan) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        const { property, hasOverrideFlag } = parseProperty(name);\n        const entry = { name: property, value, sourceSpan, hasOverrideFlag, suffix: null };\n        if (isMapBased) {\n            this._classMapInput = entry;\n        }\n        else {\n            (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n            registerIntoMap(this._classesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this._checkForPipes(value);\n        this.hasBindings = true;\n        return entry;\n    }\n    _checkForPipes(value) {\n        if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {\n            this.hasBindingsWithPipes = true;\n        }\n    }\n    /**\n     * Registers the element's static style string value to the builder.\n     *\n     * @param value the style string (e.g. `width:100px; height:200px;`)\n     */\n    registerStyleAttr(value) {\n        this._initialStyleValues = parse(value);\n        this._hasInitialValues = true;\n    }\n    /**\n     * Registers the element's static class string value to the builder.\n     *\n     * @param value the className string (e.g. `disabled gold zoom`)\n     */\n    registerClassAttr(value) {\n        this._initialClassValues = value.trim().split(/\\s+/g);\n        this._hasInitialValues = true;\n    }\n    /**\n     * Appends all styling-related expressions to the provided attrs array.\n     *\n     * @param attrs an existing array where each of the styling expressions\n     * will be inserted into.\n     */\n    populateInitialStylingAttrs(attrs) {\n        // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n        if (this._initialClassValues.length) {\n            attrs.push(literal(1 /* AttributeMarker.Classes */));\n            for (let i = 0; i < this._initialClassValues.length; i++) {\n                attrs.push(literal(this._initialClassValues[i]));\n            }\n        }\n        // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n        if (this._initialStyleValues.length) {\n            attrs.push(literal(2 /* AttributeMarker.Styles */));\n            for (let i = 0; i < this._initialStyleValues.length; i += 2) {\n                attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));\n            }\n        }\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n     *\n     * The instruction generation code below is used for producing the AOT statement code which is\n     * responsible for registering initial styles (within a directive hostBindings' creation block),\n     * as well as any of the provided attribute values, to the directive host element.\n     */\n    assignHostAttrs(attrs, definitionMap) {\n        if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n            this.populateInitialStylingAttrs(attrs);\n            definitionMap.set('hostAttrs', literalArr(attrs));\n        }\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `classMap`.\n     *\n     * The instruction data will contain all expressions for `classMap` to function\n     * which includes the `[class]` expression params.\n     */\n    buildClassMapInstruction(valueConverter) {\n        if (this._classMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n        }\n        return null;\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `styleMap`.\n     *\n     * The instruction data will contain all expressions for `styleMap` to function\n     * which includes the `[style]` expression params.\n     */\n    buildStyleMapInstruction(valueConverter) {\n        if (this._styleMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n        }\n        return null;\n    }\n    _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {\n        // each styling binding value is stored in the LView\n        // map-based bindings allocate two slots: one for the\n        // previous binding value and another for the previous\n        // className or style attribute value.\n        let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n        // these values must be outside of the update block so that they can\n        // be evaluated (the AST visit call) during creation time so that any\n        // pipes can be picked up in time before the template is built\n        const mapValue = stylingInput.value.visit(valueConverter);\n        let reference;\n        if (mapValue instanceof Interpolation) {\n            totalBindingSlotsRequired += mapValue.expressions.length;\n            reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :\n                getStyleMapInterpolationExpression(mapValue);\n        }\n        else {\n            reference = isClassBased ? Identifiers.classMap : Identifiers.styleMap;\n        }\n        return {\n            reference,\n            calls: [{\n                    supportsInterpolation: true,\n                    sourceSpan: stylingInput.sourceSpan,\n                    allocateBindingSlots: totalBindingSlotsRequired,\n                    params: (convertFn) => {\n                        const convertResult = convertFn(mapValue);\n                        const params = Array.isArray(convertResult) ? convertResult : [convertResult];\n                        return params;\n                    }\n                }]\n        };\n    }\n    _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {\n        const instructions = [];\n        inputs.forEach(input => {\n            const previousInstruction = instructions[instructions.length - 1];\n            const value = input.value.visit(valueConverter);\n            let referenceForCall = reference;\n            // each styling binding value is stored in the LView\n            // but there are two values stored for each binding:\n            //   1) the value itself\n            //   2) an intermediate value (concatenation of style up to this point).\n            //      We need to store the intermediate value so that we don't allocate\n            //      the strings on each CD.\n            let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n            if (value instanceof Interpolation) {\n                totalBindingSlotsRequired += value.expressions.length;\n                if (getInterpolationExpressionFn) {\n                    referenceForCall = getInterpolationExpressionFn(value);\n                }\n            }\n            const call = {\n                sourceSpan: input.sourceSpan,\n                allocateBindingSlots: totalBindingSlotsRequired,\n                supportsInterpolation: !!getInterpolationExpressionFn,\n                params: (convertFn) => {\n                    // params => stylingProp(propName, value, suffix)\n                    const params = [];\n                    params.push(literal(input.name));\n                    const convertResult = convertFn(value);\n                    if (Array.isArray(convertResult)) {\n                        params.push(...convertResult);\n                    }\n                    else {\n                        params.push(convertResult);\n                    }\n                    // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n                    // if that is detected then we need to pass that in as an optional param.\n                    if (!isClassBased && input.suffix !== null) {\n                        params.push(literal(input.suffix));\n                    }\n                    return params;\n                }\n            };\n            // If we ended up generating a call to the same instruction as the previous styling property\n            // we can chain the calls together safely to save some bytes, otherwise we have to generate\n            // a separate instruction call. This is primarily a concern with interpolation instructions\n            // where we may start off with one `reference`, but end up using another based on the\n            // number of interpolations.\n            if (previousInstruction && previousInstruction.reference === referenceForCall) {\n                previousInstruction.calls.push(call);\n            }\n            else {\n                instructions.push({ reference: referenceForCall, calls: [call] });\n            }\n        });\n        return instructions;\n    }\n    _buildClassInputs(valueConverter) {\n        if (this._singleClassInputs) {\n            return this._buildSingleInputs(Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);\n        }\n        return [];\n    }\n    _buildStyleInputs(valueConverter) {\n        if (this._singleStyleInputs) {\n            return this._buildSingleInputs(Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);\n        }\n        return [];\n    }\n    /**\n     * Constructs all instructions which contain the expressions that will be placed\n     * into the update block of a template function or a directive hostBindings function.\n     */\n    buildUpdateLevelInstructions(valueConverter) {\n        const instructions = [];\n        if (this.hasBindings) {\n            const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n            if (styleMapInstruction) {\n                instructions.push(styleMapInstruction);\n            }\n            const classMapInstruction = this.buildClassMapInstruction(valueConverter);\n            if (classMapInstruction) {\n                instructions.push(classMapInstruction);\n            }\n            instructions.push(...this._buildStyleInputs(valueConverter));\n            instructions.push(...this._buildClassInputs(valueConverter));\n        }\n        return instructions;\n    }\n}\nfunction registerIntoMap(map, key) {\n    if (!map.has(key)) {\n        map.set(key, map.size);\n    }\n}\nfunction parseProperty(name) {\n    let hasOverrideFlag = false;\n    const overrideIndex = name.indexOf(IMPORTANT_FLAG);\n    if (overrideIndex !== -1) {\n        name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n        hasOverrideFlag = true;\n    }\n    let suffix = null;\n    let property = name;\n    const unitIndex = name.lastIndexOf('.');\n    if (unitIndex > 0) {\n        suffix = name.slice(unitIndex + 1);\n        property = name.substring(0, unitIndex);\n    }\n    return { property, suffix, hasOverrideFlag };\n}\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\nfunction getClassMapInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.classMap;\n        case 3:\n            return Identifiers.classMapInterpolate1;\n        case 5:\n            return Identifiers.classMapInterpolate2;\n        case 7:\n            return Identifiers.classMapInterpolate3;\n        case 9:\n            return Identifiers.classMapInterpolate4;\n        case 11:\n            return Identifiers.classMapInterpolate5;\n        case 13:\n            return Identifiers.classMapInterpolate6;\n        case 15:\n            return Identifiers.classMapInterpolate7;\n        case 17:\n            return Identifiers.classMapInterpolate8;\n        default:\n            return Identifiers.classMapInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated style map.\n * @param interpolation An Interpolation AST\n */\nfunction getStyleMapInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.styleMap;\n        case 3:\n            return Identifiers.styleMapInterpolate1;\n        case 5:\n            return Identifiers.styleMapInterpolate2;\n        case 7:\n            return Identifiers.styleMapInterpolate3;\n        case 9:\n            return Identifiers.styleMapInterpolate4;\n        case 11:\n            return Identifiers.styleMapInterpolate5;\n        case 13:\n            return Identifiers.styleMapInterpolate6;\n        case 15:\n            return Identifiers.styleMapInterpolate7;\n        case 17:\n            return Identifiers.styleMapInterpolate8;\n        default:\n            return Identifiers.styleMapInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\nfunction getStylePropInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.styleProp;\n        case 3:\n            return Identifiers.stylePropInterpolate1;\n        case 5:\n            return Identifiers.stylePropInterpolate2;\n        case 7:\n            return Identifiers.stylePropInterpolate3;\n        case 9:\n            return Identifiers.stylePropInterpolate4;\n        case 11:\n            return Identifiers.stylePropInterpolate5;\n        case 13:\n            return Identifiers.stylePropInterpolate6;\n        case 15:\n            return Identifiers.stylePropInterpolate7;\n        case 17:\n            return Identifiers.stylePropInterpolate8;\n        default:\n            return Identifiers.stylePropInterpolateV;\n    }\n}\n/**\n * Checks whether property name is a custom CSS property.\n * See: https://www.w3.org/TR/css-variables-1\n */\nfunction isCssCustomProperty(name) {\n    return name.startsWith('--');\n}\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexports.TokenType = void 0;\n(function (TokenType) {\n    TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n    TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n    TokenType[TokenType[\"PrivateIdentifier\"] = 2] = \"PrivateIdentifier\";\n    TokenType[TokenType[\"Keyword\"] = 3] = \"Keyword\";\n    TokenType[TokenType[\"String\"] = 4] = \"String\";\n    TokenType[TokenType[\"Operator\"] = 5] = \"Operator\";\n    TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n    TokenType[TokenType[\"Error\"] = 7] = \"Error\";\n})(exports.TokenType || (exports.TokenType = {}));\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nclass Lexer {\n    tokenize(text) {\n        const scanner = new _Scanner(text);\n        const tokens = [];\n        let token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    }\n}\nclass Token {\n    constructor(index, end, type, numValue, strValue) {\n        this.index = index;\n        this.end = end;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    isCharacter(code) {\n        return this.type == exports.TokenType.Character && this.numValue == code;\n    }\n    isNumber() {\n        return this.type == exports.TokenType.Number;\n    }\n    isString() {\n        return this.type == exports.TokenType.String;\n    }\n    isOperator(operator) {\n        return this.type == exports.TokenType.Operator && this.strValue == operator;\n    }\n    isIdentifier() {\n        return this.type == exports.TokenType.Identifier;\n    }\n    isPrivateIdentifier() {\n        return this.type == exports.TokenType.PrivateIdentifier;\n    }\n    isKeyword() {\n        return this.type == exports.TokenType.Keyword;\n    }\n    isKeywordLet() {\n        return this.type == exports.TokenType.Keyword && this.strValue == 'let';\n    }\n    isKeywordAs() {\n        return this.type == exports.TokenType.Keyword && this.strValue == 'as';\n    }\n    isKeywordNull() {\n        return this.type == exports.TokenType.Keyword && this.strValue == 'null';\n    }\n    isKeywordUndefined() {\n        return this.type == exports.TokenType.Keyword && this.strValue == 'undefined';\n    }\n    isKeywordTrue() {\n        return this.type == exports.TokenType.Keyword && this.strValue == 'true';\n    }\n    isKeywordFalse() {\n        return this.type == exports.TokenType.Keyword && this.strValue == 'false';\n    }\n    isKeywordThis() {\n        return this.type == exports.TokenType.Keyword && this.strValue == 'this';\n    }\n    isError() {\n        return this.type == exports.TokenType.Error;\n    }\n    toNumber() {\n        return this.type == exports.TokenType.Number ? this.numValue : -1;\n    }\n    toString() {\n        switch (this.type) {\n            case exports.TokenType.Character:\n            case exports.TokenType.Identifier:\n            case exports.TokenType.Keyword:\n            case exports.TokenType.Operator:\n            case exports.TokenType.PrivateIdentifier:\n            case exports.TokenType.String:\n            case exports.TokenType.Error:\n                return this.strValue;\n            case exports.TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    }\n}\nfunction newCharacterToken(index, end, code) {\n    return new Token(index, end, exports.TokenType.Character, code, String.fromCharCode(code));\n}\nfunction newIdentifierToken(index, end, text) {\n    return new Token(index, end, exports.TokenType.Identifier, 0, text);\n}\nfunction newPrivateIdentifierToken(index, end, text) {\n    return new Token(index, end, exports.TokenType.PrivateIdentifier, 0, text);\n}\nfunction newKeywordToken(index, end, text) {\n    return new Token(index, end, exports.TokenType.Keyword, 0, text);\n}\nfunction newOperatorToken(index, end, text) {\n    return new Token(index, end, exports.TokenType.Operator, 0, text);\n}\nfunction newStringToken(index, end, text) {\n    return new Token(index, end, exports.TokenType.String, 0, text);\n}\nfunction newNumberToken(index, end, n) {\n    return new Token(index, end, exports.TokenType.Number, n, '');\n}\nfunction newErrorToken(index, end, message) {\n    return new Token(index, end, exports.TokenType.Error, 0, message);\n}\nconst EOF = new Token(-1, -1, exports.TokenType.Character, 0, '');\nclass _Scanner {\n    constructor(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    advance() {\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    }\n    scanToken() {\n        const input = this.input, length = this.length;\n        let peek = this.peek, index = this.index;\n        // Skip whitespace.\n        while (peek <= $SPACE) {\n            if (++index >= length) {\n                peek = $EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (isDigit(peek))\n            return this.scanNumber(index);\n        const start = index;\n        switch (peek) {\n            case $PERIOD:\n                this.advance();\n                return isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, this.index, $PERIOD);\n            case $LPAREN:\n            case $RPAREN:\n            case $LBRACE:\n            case $RBRACE:\n            case $LBRACKET:\n            case $RBRACKET:\n            case $COMMA:\n            case $COLON:\n            case $SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case $SQ:\n            case $DQ:\n                return this.scanString();\n            case $HASH:\n                return this.scanPrivateIdentifier();\n            case $PLUS:\n            case $MINUS:\n            case $STAR:\n            case $SLASH:\n            case $PERCENT:\n            case $CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case $QUESTION:\n                return this.scanQuestion(start);\n            case $LT:\n            case $GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n            case $BANG:\n            case $EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n            case $AMPERSAND:\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n            case $BAR:\n                return this.scanComplexOperator(start, '|', $BAR, '|');\n            case $NBSP:\n                while (isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n    }\n    scanCharacter(start, code) {\n        this.advance();\n        return newCharacterToken(start, this.index, code);\n    }\n    scanOperator(start, str) {\n        this.advance();\n        return newOperatorToken(start, this.index, str);\n    }\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     */\n    scanComplexOperator(start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        let str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, this.index, str);\n    }\n    scanIdentifier() {\n        const start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        const str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :\n            newIdentifierToken(start, this.index, str);\n    }\n    /** Scans an ECMAScript private identifier. */\n    scanPrivateIdentifier() {\n        const start = this.index;\n        this.advance();\n        if (!isIdentifierStart(this.peek)) {\n            return this.error('Invalid character [#]', -1);\n        }\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        const identifierName = this.input.substring(start, this.index);\n        return newPrivateIdentifierToken(start, this.index, identifierName);\n    }\n    scanNumber(start) {\n        let simple = (this.index === start);\n        let hasSeparators = false;\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (isDigit(this.peek)) ;\n            else if (this.peek === $_) {\n                // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is\n                // valid while `_101` and `101_` are not. The separator can't be next to the decimal\n                // point or another separator either. Note that it's unlikely that we'll hit a case where\n                // the underscore is at the start, because that's a valid identifier and it will be picked\n                // up earlier in the parsing. We validate for it anyway just in case.\n                if (!isDigit(this.input.charCodeAt(this.index - 1)) ||\n                    !isDigit(this.input.charCodeAt(this.index + 1))) {\n                    return this.error('Invalid numeric separator', 0);\n                }\n                hasSeparators = true;\n            }\n            else if (this.peek === $PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        let str = this.input.substring(start, this.index);\n        if (hasSeparators) {\n            str = str.replace(/_/g, '');\n        }\n        const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, this.index, value);\n    }\n    scanString() {\n        const start = this.index;\n        const quote = this.peek;\n        this.advance(); // Skip initial quote.\n        let buffer = '';\n        let marker = this.index;\n        const input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == $BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                this.advance();\n                let unescapedCode;\n                // Workaround for TS2.1-introduced type strictness\n                this.peek = this.peek;\n                if (this.peek == $u) {\n                    // 4 character hex code for unicode character.\n                    const hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n                    }\n                    for (let i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == $EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        const last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, this.index, buffer + last);\n    }\n    scanQuestion(start) {\n        this.advance();\n        let str = '?';\n        // Either `a ?? b` or 'a?.b'.\n        if (this.peek === $QUESTION || this.peek === $PERIOD) {\n            str += this.peek === $PERIOD ? '.' : '?';\n            this.advance();\n        }\n        return newOperatorToken(start, this.index, str);\n    }\n    error(message, offset) {\n        const position = this.index + offset;\n        return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n    }\n}\nfunction isIdentifierStart(code) {\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n        (code == $_) || (code == $$);\n}\nfunction isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    const scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== $EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\nfunction isIdentifierPart(code) {\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n        (code == $$);\n}\nfunction isExponentStart(code) {\n    return code == $e || code == $E;\n}\nfunction isExponentSign(code) {\n    return code == $MINUS || code == $PLUS;\n}\nfunction unescape(code) {\n    switch (code) {\n        case $n:\n            return $LF;\n        case $f:\n            return $FF;\n        case $r:\n            return $CR;\n        case $t:\n            return $TAB;\n        case $v:\n            return $VTAB;\n        default:\n            return code;\n    }\n}\nfunction parseIntAutoRadix(text) {\n    const result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass SplitInterpolation {\n    constructor(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n}\nclass TemplateBindingParseResult {\n    constructor(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n}\nclass Parser$1 {\n    constructor(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n    }\n    parseAction(input, isAssignmentEvent, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        let flags = 1 /* ParseFlags.Action */;\n        if (isAssignmentEvent) {\n            flags |= 2 /* ParseFlags.AssignmentEvent */;\n        }\n        const ast = new _ParseAST(input, location, absoluteOffset, tokens, flags, this.errors, 0).parseChain();\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n    parseBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n    checkSimpleExpression(ast) {\n        const checker = new SimpleExpressionChecker();\n        ast.visit(checker);\n        return checker.errors;\n    }\n    parseSimpleBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        const errors = this.checkSimpleExpression(ast);\n        if (errors.length > 0) {\n            this._reportError(`Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n        }\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n    _reportError(message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    }\n    _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, absoluteOffset, tokens, 0 /* ParseFlags.None */, this.errors, 0)\n            .parseChain();\n    }\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items\">\n     *         ^      ^ absoluteValueOffset for `templateValue`\n     *         absoluteKeyOffset for `templateKey`\n     * ```\n     * contains three bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     *\n     * This is apparent from the de-sugared template:\n     * ```\n     *   <ng-template ngFor let-item [ngForOf]=\"items\">\n     * ```\n     *\n     * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n     * @param templateValue RHS of the microsyntax attribute\n     * @param templateUrl template filename if it's external, component filename if it's inline\n     * @param absoluteKeyOffset start of the `templateKey`\n     * @param absoluteValueOffset start of the `templateValue`\n     */\n    parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {\n        const tokens = this._lexer.tokenize(templateValue);\n        const parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, 0 /* ParseFlags.None */, this.errors, 0 /* relative offset */);\n        return parser.parseTemplateBindings({\n            source: templateKey,\n            span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n        });\n    }\n    parseInterpolation(input, location, absoluteOffset, interpolatedTokens, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const { strings, expressions, offsets } = this.splitInterpolation(input, location, interpolatedTokens, interpolationConfig);\n        if (expressions.length === 0)\n            return null;\n        const expressionNodes = [];\n        for (let i = 0; i < expressions.length; ++i) {\n            const expressionText = expressions[i].text;\n            const sourceToLex = this._stripComments(expressionText);\n            const tokens = this._lexer.tokenize(sourceToLex);\n            const ast = new _ParseAST(input, location, absoluteOffset, tokens, 0 /* ParseFlags.None */, this.errors, offsets[i])\n                .parseChain();\n            expressionNodes.push(ast);\n        }\n        return this.createInterpolationAst(strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);\n    }\n    /**\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n     * This is used for parsing the switch expression in ICUs.\n     */\n    parseInterpolationExpression(expression, location, absoluteOffset) {\n        const sourceToLex = this._stripComments(expression);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        const ast = new _ParseAST(expression, location, absoluteOffset, tokens, 0 /* ParseFlags.None */, this.errors, 0)\n            .parseChain();\n        const strings = ['', '']; // The prefix and suffix strings are both empty\n        return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\n    }\n    createInterpolationAst(strings, expressions, input, location, absoluteOffset) {\n        const span = new ParseSpan(0, input.length);\n        const interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\n        return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\n    }\n    /**\n     * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n     * the string.\n     * Returns `null` if there are no interpolations, otherwise a\n     * `SplitInterpolation` with splits that look like\n     *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n     */\n    splitInterpolation(input, location, interpolatedTokens, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        var _a;\n        const strings = [];\n        const expressions = [];\n        const offsets = [];\n        const inputToTemplateIndexMap = interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;\n        let i = 0;\n        let atInterpolation = false;\n        let extendLastString = false;\n        let { start: interpStart, end: interpEnd } = interpolationConfig;\n        while (i < input.length) {\n            if (!atInterpolation) {\n                // parse until starting {{\n                const start = i;\n                i = input.indexOf(interpStart, i);\n                if (i === -1) {\n                    i = input.length;\n                }\n                const text = input.substring(start, i);\n                strings.push({ text, start, end: i });\n                atInterpolation = true;\n            }\n            else {\n                // parse from starting {{ to ending }} while ignoring content inside quotes.\n                const fullStart = i;\n                const exprStart = fullStart + interpStart.length;\n                const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n                if (exprEnd === -1) {\n                    // Could not find the end of the interpolation; do not parse an expression.\n                    // Instead we should extend the content on the last raw string.\n                    atInterpolation = false;\n                    extendLastString = true;\n                    break;\n                }\n                const fullEnd = exprEnd + interpEnd.length;\n                const text = input.substring(exprStart, exprEnd);\n                if (text.trim().length === 0) {\n                    this._reportError('Blank expressions are not allowed in interpolated strings', input, `at column ${i} in`, location);\n                }\n                expressions.push({ text, start: fullStart, end: fullEnd });\n                const startInOriginalTemplate = (_a = inputToTemplateIndexMap === null || inputToTemplateIndexMap === void 0 ? void 0 : inputToTemplateIndexMap.get(fullStart)) !== null && _a !== void 0 ? _a : fullStart;\n                const offset = startInOriginalTemplate + interpStart.length;\n                offsets.push(offset);\n                i = fullEnd;\n                atInterpolation = false;\n            }\n        }\n        if (!atInterpolation) {\n            // If we are now at a text section, add the remaining content as a raw string.\n            if (extendLastString) {\n                const piece = strings[strings.length - 1];\n                piece.text += input.substring(i);\n                piece.end = input.length;\n            }\n            else {\n                strings.push({ text: input.substring(i), start: i, end: input.length });\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    }\n    wrapLiteralPrimitive(input, location, absoluteOffset) {\n        const span = new ParseSpan(0, input == null ? 0 : input.length);\n        return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);\n    }\n    _stripComments(input) {\n        const i = this._commentStart(input);\n        return i != null ? input.substring(0, i) : input;\n    }\n    _commentStart(input) {\n        let outerQuote = null;\n        for (let i = 0; i < input.length - 1; i++) {\n            const char = input.charCodeAt(i);\n            const nextChar = input.charCodeAt(i + 1);\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    }\n    _checkNoInterpolation(input, location, { start, end }) {\n        let startIndex = -1;\n        let endIndex = -1;\n        for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n            if (startIndex === -1) {\n                if (input.startsWith(start)) {\n                    startIndex = charIndex;\n                }\n            }\n            else {\n                endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n                if (endIndex > -1) {\n                    break;\n                }\n            }\n        }\n        if (startIndex > -1 && endIndex > -1) {\n            this._reportError(`Got interpolation (${start}${end}) where expression was expected`, input, `at column ${startIndex} in`, location);\n        }\n    }\n    /**\n     * Finds the index of the end of an interpolation expression\n     * while ignoring comments and quoted content.\n     */\n    _getInterpolationEndIndex(input, expressionEnd, start) {\n        for (const charIndex of this._forEachUnquotedChar(input, start)) {\n            if (input.startsWith(expressionEnd, charIndex)) {\n                return charIndex;\n            }\n            // Nothing else in the expression matters after we've\n            // hit a comment so look directly for the end token.\n            if (input.startsWith('//', charIndex)) {\n                return input.indexOf(expressionEnd, charIndex);\n            }\n        }\n        return -1;\n    }\n    /**\n     * Generator used to iterate over the character indexes of a string that are outside of quotes.\n     * @param input String to loop through.\n     * @param start Index within the string at which to start.\n     */\n    *_forEachUnquotedChar(input, start) {\n        let currentQuote = null;\n        let escapeCount = 0;\n        for (let i = start; i < input.length; i++) {\n            const char = input[i];\n            // Skip the characters inside quotes. Note that we only care about the outer-most\n            // quotes matching up and we need to account for escape characters.\n            if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\n                escapeCount % 2 === 0) {\n                currentQuote = currentQuote === null ? char : null;\n            }\n            else if (currentQuote === null) {\n                yield i;\n            }\n            escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n        }\n    }\n}\n/** Describes a stateful context an expression parser is in. */\nvar ParseContextFlags;\n(function (ParseContextFlags) {\n    ParseContextFlags[ParseContextFlags[\"None\"] = 0] = \"None\";\n    /**\n     * A Writable context is one in which a value may be written to an lvalue.\n     * For example, after we see a property access, we may expect a write to the\n     * property via the \"=\" operator.\n     *   prop\n     *        ^ possible \"=\" after\n     */\n    ParseContextFlags[ParseContextFlags[\"Writable\"] = 1] = \"Writable\";\n})(ParseContextFlags || (ParseContextFlags = {}));\nclass _ParseAST {\n    constructor(input, location, absoluteOffset, tokens, parseFlags, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.absoluteOffset = absoluteOffset;\n        this.tokens = tokens;\n        this.parseFlags = parseFlags;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        this.context = ParseContextFlags.None;\n        // Cache of expression start and input indeces to the absolute source span they map to, used to\n        // prevent creating superfluous source spans in `sourceSpan`.\n        // A serial of the expression start and input index is used for mapping because both are stateful\n        // and may change for subsequent expressions visited by the parser.\n        this.sourceSpanCache = new Map();\n        this.index = 0;\n    }\n    peek(offset) {\n        const i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    }\n    get next() {\n        return this.peek(0);\n    }\n    /** Whether all the parser input has been processed. */\n    get atEOF() {\n        return this.index >= this.tokens.length;\n    }\n    /**\n     * Index of the next token to be processed, or the end of the last token if all have been\n     * processed.\n     */\n    get inputIndex() {\n        return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n    }\n    /**\n     * End index of the last processed token, or the start of the first token if none have been\n     * processed.\n     */\n    get currentEndIndex() {\n        if (this.index > 0) {\n            const curToken = this.peek(-1);\n            return curToken.end + this.offset;\n        }\n        // No tokens have been processed yet; return the next token's start or the length of the input\n        // if there is no token.\n        if (this.tokens.length === 0) {\n            return this.input.length + this.offset;\n        }\n        return this.next.index + this.offset;\n    }\n    /**\n     * Returns the absolute offset of the start of the current token.\n     */\n    get currentAbsoluteOffset() {\n        return this.absoluteOffset + this.inputIndex;\n    }\n    /**\n     * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n     * provided).\n     *\n     * @param start Position from which the `ParseSpan` will start.\n     * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n     *     natural ending index)\n     */\n    span(start, artificialEndIndex) {\n        let endIndex = this.currentEndIndex;\n        if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n            endIndex = artificialEndIndex;\n        }\n        // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n        // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n        // appears to be a deep-seated parser bug.\n        //\n        // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n        // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n        if (start > endIndex) {\n            const tmp = endIndex;\n            endIndex = start;\n            start = tmp;\n        }\n        return new ParseSpan(start, endIndex);\n    }\n    sourceSpan(start, artificialEndIndex) {\n        const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n        if (!this.sourceSpanCache.has(serial)) {\n            this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n        }\n        return this.sourceSpanCache.get(serial);\n    }\n    advance() {\n        this.index++;\n    }\n    /**\n     * Executes a callback in the provided context.\n     */\n    withContext(context, cb) {\n        this.context |= context;\n        const ret = cb();\n        this.context ^= context;\n        return ret;\n    }\n    consumeOptionalCharacter(code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    peekKeywordLet() {\n        return this.next.isKeywordLet();\n    }\n    peekKeywordAs() {\n        return this.next.isKeywordAs();\n    }\n    /**\n     * Consumes an expected character, otherwise emits an error about the missing expected character\n     * and skips over the token stream until reaching a recoverable point.\n     *\n     * See `this.error` and `this.skip` for more details.\n     */\n    expectCharacter(code) {\n        if (this.consumeOptionalCharacter(code))\n            return;\n        this.error(`Missing expected ${String.fromCharCode(code)}`);\n    }\n    consumeOptionalOperator(op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    expectOperator(operator) {\n        if (this.consumeOptionalOperator(operator))\n            return;\n        this.error(`Missing expected operator ${operator}`);\n    }\n    prettyPrintToken(tok) {\n        return tok === EOF ? 'end of input' : `token ${tok}`;\n    }\n    expectIdentifierOrKeyword() {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            if (n.isPrivateIdentifier()) {\n                this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n            }\n            else {\n                this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n            }\n            return null;\n        }\n        this.advance();\n        return n.toString();\n    }\n    expectIdentifierOrKeywordOrString() {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            if (n.isPrivateIdentifier()) {\n                this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n            }\n            else {\n                this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n            }\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    }\n    parseChain() {\n        const exprs = [];\n        const start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            const expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.consumeOptionalCharacter($SEMICOLON)) {\n                if (!(this.parseFlags & 1 /* ParseFlags.Action */)) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.consumeOptionalCharacter($SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                this.error(`Unexpected token '${this.next}'`);\n            }\n        }\n        if (exprs.length == 0) {\n            // We have no expressions so create an empty expression that spans the entire input length\n            const artificialStart = this.offset;\n            const artificialEnd = this.offset + this.input.length;\n            return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));\n        }\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), this.sourceSpan(start), exprs);\n    }\n    parsePipe() {\n        const start = this.inputIndex;\n        let result = this.parseExpression();\n        if (this.consumeOptionalOperator('|')) {\n            if (this.parseFlags & 1 /* ParseFlags.Action */) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                const nameStart = this.inputIndex;\n                let nameId = this.expectIdentifierOrKeyword();\n                let nameSpan;\n                let fullSpanEnd = undefined;\n                if (nameId !== null) {\n                    nameSpan = this.sourceSpan(nameStart);\n                }\n                else {\n                    // No valid identifier was found, so we'll assume an empty pipe name ('').\n                    nameId = '';\n                    // However, there may have been whitespace present between the pipe character and the next\n                    // token in the sequence (or the end of input). We want to track this whitespace so that\n                    // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n                    // whitespace beyond it. Another way of thinking about this is that the zero-length name\n                    // is assumed to be at the end of any whitespace beyond the pipe character.\n                    //\n                    // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n                    // beginning of the next token, or until the end of input if the next token is EOF.\n                    fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n                    // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n                    // beyond the pipe character.\n                    nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n                }\n                const args = [];\n                while (this.consumeOptionalCharacter($COLON)) {\n                    args.push(this.parseExpression());\n                    // If there are additional expressions beyond the name, then the artificial end for the\n                    // name is no longer relevant.\n                }\n                result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n            } while (this.consumeOptionalOperator('|'));\n        }\n        return result;\n    }\n    parseExpression() {\n        return this.parseConditional();\n    }\n    parseConditional() {\n        const start = this.inputIndex;\n        const result = this.parseLogicalOr();\n        if (this.consumeOptionalOperator('?')) {\n            const yes = this.parsePipe();\n            let no;\n            if (!this.consumeOptionalCharacter($COLON)) {\n                const end = this.inputIndex;\n                const expression = this.input.substring(start, end);\n                this.error(`Conditional expression ${expression} requires all 3 expressions`);\n                no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    }\n    parseLogicalOr() {\n        // '||'\n        const start = this.inputIndex;\n        let result = this.parseLogicalAnd();\n        while (this.consumeOptionalOperator('||')) {\n            const right = this.parseLogicalAnd();\n            result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n        }\n        return result;\n    }\n    parseLogicalAnd() {\n        // '&&'\n        const start = this.inputIndex;\n        let result = this.parseNullishCoalescing();\n        while (this.consumeOptionalOperator('&&')) {\n            const right = this.parseNullishCoalescing();\n            result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n        }\n        return result;\n    }\n    parseNullishCoalescing() {\n        // '??'\n        const start = this.inputIndex;\n        let result = this.parseEquality();\n        while (this.consumeOptionalOperator('??')) {\n            const right = this.parseEquality();\n            result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n        }\n        return result;\n    }\n    parseEquality() {\n        // '==','!=','===','!=='\n        const start = this.inputIndex;\n        let result = this.parseRelational();\n        while (this.next.type == exports.TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    const right = this.parseRelational();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parseRelational() {\n        // '<', '>', '<=', '>='\n        const start = this.inputIndex;\n        let result = this.parseAdditive();\n        while (this.next.type == exports.TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    const right = this.parseAdditive();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parseAdditive() {\n        // '+', '-'\n        const start = this.inputIndex;\n        let result = this.parseMultiplicative();\n        while (this.next.type == exports.TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    let right = this.parseMultiplicative();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parseMultiplicative() {\n        // '*', '%', '/'\n        const start = this.inputIndex;\n        let result = this.parsePrefix();\n        while (this.next.type == exports.TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    let right = this.parsePrefix();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parsePrefix() {\n        if (this.next.type == exports.TokenType.Operator) {\n            const start = this.inputIndex;\n            const operator = this.next.strValue;\n            let result;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n            }\n        }\n        return this.parseCallChain();\n    }\n    parseCallChain() {\n        const start = this.inputIndex;\n        let result = this.parsePrimary();\n        while (true) {\n            if (this.consumeOptionalCharacter($PERIOD)) {\n                result = this.parseAccessMember(result, start, false);\n            }\n            else if (this.consumeOptionalOperator('?.')) {\n                if (this.consumeOptionalCharacter($LPAREN)) {\n                    result = this.parseCall(result, start, true);\n                }\n                else {\n                    result = this.consumeOptionalCharacter($LBRACKET) ?\n                        this.parseKeyedReadOrWrite(result, start, true) :\n                        this.parseAccessMember(result, start, true);\n                }\n            }\n            else if (this.consumeOptionalCharacter($LBRACKET)) {\n                result = this.parseKeyedReadOrWrite(result, start, false);\n            }\n            else if (this.consumeOptionalCharacter($LPAREN)) {\n                result = this.parseCall(result, start, false);\n            }\n            else if (this.consumeOptionalOperator('!')) {\n                result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n            }\n            else {\n                return result;\n            }\n        }\n    }\n    parsePrimary() {\n        const start = this.inputIndex;\n        if (this.consumeOptionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            const result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter($RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ThisReceiver(this.span(start), this.sourceSpan(start));\n        }\n        else if (this.consumeOptionalCharacter($LBRACKET)) {\n            this.rbracketsExpected++;\n            const elements = this.parseExpressionList($RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n        }\n        else if (this.next.isCharacter($LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMember(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n        }\n        else if (this.next.isNumber()) {\n            const value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n        }\n        else if (this.next.isString()) {\n            const literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n        }\n        else if (this.next.isPrivateIdentifier()) {\n            this._reportErrorForPrivateIdentifier(this.next, null);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(`Unexpected end of expression: ${this.input}`);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n        else {\n            this.error(`Unexpected token ${this.next}`);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n    }\n    parseExpressionList(terminator) {\n        const result = [];\n        do {\n            if (!this.next.isCharacter(terminator)) {\n                result.push(this.parsePipe());\n            }\n            else {\n                break;\n            }\n        } while (this.consumeOptionalCharacter($COMMA));\n        return result;\n    }\n    parseLiteralMap() {\n        const keys = [];\n        const values = [];\n        const start = this.inputIndex;\n        this.expectCharacter($LBRACE);\n        if (!this.consumeOptionalCharacter($RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                const keyStart = this.inputIndex;\n                const quoted = this.next.isString();\n                const key = this.expectIdentifierOrKeywordOrString();\n                keys.push({ key, quoted });\n                // Properties with quoted keys can't use the shorthand syntax.\n                if (quoted) {\n                    this.expectCharacter($COLON);\n                    values.push(this.parsePipe());\n                }\n                else if (this.consumeOptionalCharacter($COLON)) {\n                    values.push(this.parsePipe());\n                }\n                else {\n                    const span = this.span(keyStart);\n                    const sourceSpan = this.sourceSpan(keyStart);\n                    values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n                }\n            } while (this.consumeOptionalCharacter($COMMA));\n            this.rbracesExpected--;\n            this.expectCharacter($RBRACE);\n        }\n        return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n    }\n    parseAccessMember(readReceiver, start, isSafe) {\n        const nameStart = this.inputIndex;\n        const id = this.withContext(ParseContextFlags.Writable, () => {\n            var _a;\n            const id = (_a = this.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : '';\n            if (id.length === 0) {\n                this.error(`Expected identifier for property access`, readReceiver.span.end);\n            }\n            return id;\n        });\n        const nameSpan = this.sourceSpan(nameStart);\n        let receiver;\n        if (isSafe) {\n            if (this.consumeOptionalAssignment()) {\n                this.error('The \\'?.\\' operator cannot be used in the assignment');\n                receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n            else {\n                receiver = new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n            }\n        }\n        else {\n            if (this.consumeOptionalAssignment()) {\n                if (!(this.parseFlags & 1 /* ParseFlags.Action */)) {\n                    this.error('Bindings cannot contain assignments');\n                    return new EmptyExpr(this.span(start), this.sourceSpan(start));\n                }\n                const value = this.parseConditional();\n                receiver = new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);\n            }\n            else {\n                receiver =\n                    new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n            }\n        }\n        return receiver;\n    }\n    parseCall(receiver, start, isSafe) {\n        const argumentStart = this.inputIndex;\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n        this.expectCharacter($RPAREN);\n        this.rparensExpected--;\n        const span = this.span(start);\n        const sourceSpan = this.sourceSpan(start);\n        return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) :\n            new Call(span, sourceSpan, receiver, args, argumentSpan);\n    }\n    consumeOptionalAssignment() {\n        // When parsing assignment events (originating from two-way-binding aka banana-in-a-box syntax),\n        // it is valid for the primary expression to be terminated by the non-null operator. This\n        // primary expression is substituted as LHS of the assignment operator to achieve\n        // two-way-binding, such that the LHS could be the non-null operator. The grammar doesn't\n        // naturally allow for this syntax, so assignment events are parsed specially.\n        if ((this.parseFlags & 2 /* ParseFlags.AssignmentEvent */) && this.next.isOperator('!') &&\n            this.peek(1).isOperator('=')) {\n            // First skip over the ! operator.\n            this.advance();\n            // Then skip over the = operator, to fully consume the optional assignment operator.\n            this.advance();\n            return true;\n        }\n        return this.consumeOptionalOperator('=');\n    }\n    parseCallArguments() {\n        if (this.next.isCharacter($RPAREN))\n            return [];\n        const positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.consumeOptionalCharacter($COMMA));\n        return positionals;\n    }\n    /**\n     * Parses an identifier, a keyword, a string with an optional `-` in between,\n     * and returns the string along with its absolute source span.\n     */\n    expectTemplateBindingKey() {\n        let result = '';\n        let operatorFound = false;\n        const start = this.currentAbsoluteOffset;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.consumeOptionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return {\n            source: result,\n            span: new AbsoluteSourceSpan(start, start + result.length),\n        };\n    }\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n     * ```\n     * contains five bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     * 4. i -> NgForOfContext.index\n     * 5. ngForTrackBy -> func\n     *\n     * For a full description of the microsyntax grammar, see\n     * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n     *\n     * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n     * without the *, along with its absolute span.\n     */\n    parseTemplateBindings(templateKey) {\n        const bindings = [];\n        // The first binding is for the template key itself\n        // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n        // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n        bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n        while (this.index < this.tokens.length) {\n            // If it starts with 'let', then this must be variable declaration\n            const letBinding = this.parseLetBinding();\n            if (letBinding) {\n                bindings.push(letBinding);\n            }\n            else {\n                // Two possible cases here, either `value \"as\" key` or\n                // \"directive-keyword expression\". We don't know which case, but both\n                // \"value\" and \"directive-keyword\" are template binding key, so consume\n                // the key first.\n                const key = this.expectTemplateBindingKey();\n                // Peek at the next token, if it is \"as\" then this must be variable\n                // declaration.\n                const binding = this.parseAsBinding(key);\n                if (binding) {\n                    bindings.push(binding);\n                }\n                else {\n                    // Otherwise the key must be a directive keyword, like \"of\". Transform\n                    // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n                    key.source =\n                        templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n                    bindings.push(...this.parseDirectiveKeywordBindings(key));\n                }\n            }\n            this.consumeStatementTerminator();\n        }\n        return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n    }\n    parseKeyedReadOrWrite(receiver, start, isSafe) {\n        return this.withContext(ParseContextFlags.Writable, () => {\n            this.rbracketsExpected++;\n            const key = this.parsePipe();\n            if (key instanceof EmptyExpr) {\n                this.error(`Key access cannot be empty`);\n            }\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            if (this.consumeOptionalOperator('=')) {\n                if (isSafe) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                }\n                else {\n                    const value = this.parseConditional();\n                    return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);\n                }\n            }\n            else {\n                return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) :\n                    new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n            }\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        });\n    }\n    /**\n     * Parse a directive keyword, followed by a mandatory expression.\n     * For example, \"of items\", \"trackBy: func\".\n     * The bindings are: ngForOf -> items, ngForTrackBy -> func\n     * There could be an optional \"as\" binding that follows the expression.\n     * For example,\n     * ```\n     *   *ngFor=\"let item of items | slice:0:1 as collection\".\n     *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n     *               keyword    bound target   optional 'as' binding\n     * ```\n     *\n     * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n     * absolute span.\n     */\n    parseDirectiveKeywordBindings(key) {\n        const bindings = [];\n        this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction\n        const value = this.getDirectiveBoundTarget();\n        let spanEnd = this.currentAbsoluteOffset;\n        // The binding could optionally be followed by \"as\". For example,\n        // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n        // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n        // 'key' in the current context now becomes the \"value\" in the next binding.\n        const asBinding = this.parseAsBinding(key);\n        if (!asBinding) {\n            this.consumeStatementTerminator();\n            spanEnd = this.currentAbsoluteOffset;\n        }\n        const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n        bindings.push(new ExpressionBinding(sourceSpan, key, value));\n        if (asBinding) {\n            bindings.push(asBinding);\n        }\n        return bindings;\n    }\n    /**\n     * Return the expression AST for the bound target of a directive keyword\n     * binding. For example,\n     * ```\n     *   *ngIf=\"condition | pipe\"\n     *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n     *   *ngFor=\"let item of items\"\n     *                       ^^^^^ bound target for \"ngForOf\"\n     * ```\n     */\n    getDirectiveBoundTarget() {\n        if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n            return null;\n        }\n        const ast = this.parsePipe(); // example: \"condition | async\"\n        const { start, end } = ast.span;\n        const value = this.input.substring(start, end);\n        return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n    }\n    /**\n     * Return the binding for a variable declared using `as`. Note that the order\n     * of the key-value pair in this declaration is reversed. For example,\n     * ```\n     *   *ngFor=\"let item of items; index as i\"\n     *                              ^^^^^    ^\n     *                              value    key\n     * ```\n     *\n     * @param value name of the value in the declaration, \"ngIf\" in the example\n     * above, along with its absolute span.\n     */\n    parseAsBinding(value) {\n        if (!this.peekKeywordAs()) {\n            return null;\n        }\n        this.advance(); // consume the 'as' keyword\n        const key = this.expectTemplateBindingKey();\n        this.consumeStatementTerminator();\n        const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n        return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\n     * Return the binding for a variable declared using `let`. For example,\n     * ```\n     *   *ngFor=\"let item of items; let i=index;\"\n     *           ^^^^^^^^           ^^^^^^^^^^^\n     * ```\n     * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n     * In the second binding, `i` is bound to `NgForOfContext.index`.\n     */\n    parseLetBinding() {\n        if (!this.peekKeywordLet()) {\n            return null;\n        }\n        const spanStart = this.currentAbsoluteOffset;\n        this.advance(); // consume the 'let' keyword\n        const key = this.expectTemplateBindingKey();\n        let value = null;\n        if (this.consumeOptionalOperator('=')) {\n            value = this.expectTemplateBindingKey();\n        }\n        this.consumeStatementTerminator();\n        const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n        return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\n     * Consume the optional statement terminator: semicolon or comma.\n     */\n    consumeStatementTerminator() {\n        this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\n    }\n    /**\n     * Records an error and skips over the token stream until reaching a recoverable point. See\n     * `this.skip` for more details on token skipping.\n     */\n    error(message, index = null) {\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    }\n    locationText(index = null) {\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n            `at the end of the expression`;\n    }\n    /**\n     * Records an error for an unexpected private identifier being discovered.\n     * @param token Token representing a private identifier.\n     * @param extraMessage Optional additional message being appended to the error.\n     */\n    _reportErrorForPrivateIdentifier(token, extraMessage) {\n        let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n        if (extraMessage !== null) {\n            errorMessage += `, ${extraMessage}`;\n        }\n        this.error(errorMessage);\n    }\n    /**\n     * Error recovery should skip tokens until it encounters a recovery point.\n     *\n     * The following are treated as unconditional recovery points:\n     *   - end of input\n     *   - ';' (parseChain() is always the root production, and it expects a ';')\n     *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n     *\n     * The following are conditional recovery points:\n     *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n     *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n     *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n     *       an '(' <expr> ')' production).\n     *       The recovery points of grouping symbols must be conditional as they must be skipped if\n     *       none of the calling productions are not expecting the closing token else we will never\n     *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n     *       That is, we skip a closing symbol if we are not in a grouping production.\n     *   - '=' in a `Writable` context\n     *     - In this context, we are able to recover after seeing the `=` operator, which\n     *       signals the presence of an independent rvalue expression following the `=` operator.\n     *\n     * If a production expects one of these token it increments the corresponding nesting count,\n     * and then decrements it just prior to checking if the token is in the input.\n     */\n    skip() {\n        let n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n            !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) &&\n            (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    }\n}\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.errors = [];\n    }\n    visitPipe() {\n        this.errors.push('pipes');\n    }\n}\n/**\n * Computes the real offset in the original template for indexes in an interpolation.\n *\n * Because templates can have encoded HTML entities and the input passed to the parser at this stage\n * of the compiler is the _decoded_ value, we need to compute the real offset using the original\n * encoded values in the interpolated tokens. Note that this is only a special case handling for\n * `MlParserTokenType.ENCODED_ENTITY` token types. All other interpolated tokens are expected to\n * have parts which exactly match the input string for parsing the interpolation.\n *\n * @param interpolatedTokens The tokens for the interpolated value.\n *\n * @returns A map of index locations in the decoded template to indexes in the original template\n */\nfunction getIndexMapForOriginalTemplate(interpolatedTokens) {\n    let offsetMap = new Map();\n    let consumedInOriginalTemplate = 0;\n    let consumedInInput = 0;\n    let tokenIndex = 0;\n    while (tokenIndex < interpolatedTokens.length) {\n        const currentToken = interpolatedTokens[tokenIndex];\n        if (currentToken.type === 9 /* MlParserTokenType.ENCODED_ENTITY */) {\n            const [decoded, encoded] = currentToken.parts;\n            consumedInOriginalTemplate += encoded.length;\n            consumedInInput += decoded.length;\n        }\n        else {\n            const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);\n            consumedInInput += lengthOfParts;\n            consumedInOriginalTemplate += lengthOfParts;\n        }\n        offsetMap.set(consumedInInput, consumedInOriginalTemplate);\n        tokenIndex++;\n    }\n    return offsetMap;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass NodeWithI18n {\n    constructor(sourceSpan, i18n) {\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n}\nclass Text extends NodeWithI18n {\n    constructor(value, sourceSpan, tokens, i18n) {\n        super(sourceSpan, i18n);\n        this.value = value;\n        this.tokens = tokens;\n    }\n    visit(visitor, context) {\n        return visitor.visitText(this, context);\n    }\n}\nclass Expansion extends NodeWithI18n {\n    constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n        super(sourceSpan, i18n);\n        this.switchValue = switchValue;\n        this.type = type;\n        this.cases = cases;\n        this.switchValueSourceSpan = switchValueSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitExpansion(this, context);\n    }\n}\nclass ExpansionCase {\n    constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitExpansionCase(this, context);\n    }\n}\nclass Attribute extends NodeWithI18n {\n    constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {\n        super(sourceSpan, i18n);\n        this.name = name;\n        this.value = value;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.valueTokens = valueTokens;\n    }\n    visit(visitor, context) {\n        return visitor.visitAttribute(this, context);\n    }\n}\nclass Element extends NodeWithI18n {\n    constructor(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {\n        super(sourceSpan, i18n);\n        this.name = name;\n        this.attrs = attrs;\n        this.children = children;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitElement(this, context);\n    }\n}\nclass Comment {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitComment(this, context);\n    }\n}\nfunction visitAll(visitor, nodes, context = null) {\n    const result = [];\n    const visit = visitor.visit ?\n        (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :\n        (ast) => ast.visit(visitor, context);\n    nodes.forEach(ast => {\n        const astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\nclass RecursiveVisitor {\n    constructor() { }\n    visitElement(ast, context) {\n        this.visitChildren(context, visit => {\n            visit(ast.attrs);\n            visit(ast.children);\n        });\n    }\n    visitAttribute(ast, context) { }\n    visitText(ast, context) { }\n    visitComment(ast, context) { }\n    visitExpansion(ast, context) {\n        return this.visitChildren(context, visit => {\n            visit(ast.cases);\n        });\n    }\n    visitExpansionCase(ast, context) { }\n    visitChildren(context, cb) {\n        let results = [];\n        let t = this;\n        function visit(children) {\n            if (children)\n                results.push(visitAll(t, children, context));\n        }\n        cb(visit);\n        return Array.prototype.concat.apply([], results);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Mapping between all HTML entity names and their unicode representation.\n// Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping\n// the `&` and `;` from the keys and removing the duplicates.\n// see https://www.w3.org/TR/html51/syntax.html#named-character-references\nconst NAMED_ENTITIES = {\n    'AElig': '\\u00C6',\n    'AMP': '\\u0026',\n    'amp': '\\u0026',\n    'Aacute': '\\u00C1',\n    'Abreve': '\\u0102',\n    'Acirc': '\\u00C2',\n    'Acy': '\\u0410',\n    'Afr': '\\uD835\\uDD04',\n    'Agrave': '\\u00C0',\n    'Alpha': '\\u0391',\n    'Amacr': '\\u0100',\n    'And': '\\u2A53',\n    'Aogon': '\\u0104',\n    'Aopf': '\\uD835\\uDD38',\n    'ApplyFunction': '\\u2061',\n    'af': '\\u2061',\n    'Aring': '\\u00C5',\n    'angst': '\\u00C5',\n    'Ascr': '\\uD835\\uDC9C',\n    'Assign': '\\u2254',\n    'colone': '\\u2254',\n    'coloneq': '\\u2254',\n    'Atilde': '\\u00C3',\n    'Auml': '\\u00C4',\n    'Backslash': '\\u2216',\n    'setminus': '\\u2216',\n    'setmn': '\\u2216',\n    'smallsetminus': '\\u2216',\n    'ssetmn': '\\u2216',\n    'Barv': '\\u2AE7',\n    'Barwed': '\\u2306',\n    'doublebarwedge': '\\u2306',\n    'Bcy': '\\u0411',\n    'Because': '\\u2235',\n    'becaus': '\\u2235',\n    'because': '\\u2235',\n    'Bernoullis': '\\u212C',\n    'Bscr': '\\u212C',\n    'bernou': '\\u212C',\n    'Beta': '\\u0392',\n    'Bfr': '\\uD835\\uDD05',\n    'Bopf': '\\uD835\\uDD39',\n    'Breve': '\\u02D8',\n    'breve': '\\u02D8',\n    'Bumpeq': '\\u224E',\n    'HumpDownHump': '\\u224E',\n    'bump': '\\u224E',\n    'CHcy': '\\u0427',\n    'COPY': '\\u00A9',\n    'copy': '\\u00A9',\n    'Cacute': '\\u0106',\n    'Cap': '\\u22D2',\n    'CapitalDifferentialD': '\\u2145',\n    'DD': '\\u2145',\n    'Cayleys': '\\u212D',\n    'Cfr': '\\u212D',\n    'Ccaron': '\\u010C',\n    'Ccedil': '\\u00C7',\n    'Ccirc': '\\u0108',\n    'Cconint': '\\u2230',\n    'Cdot': '\\u010A',\n    'Cedilla': '\\u00B8',\n    'cedil': '\\u00B8',\n    'CenterDot': '\\u00B7',\n    'centerdot': '\\u00B7',\n    'middot': '\\u00B7',\n    'Chi': '\\u03A7',\n    'CircleDot': '\\u2299',\n    'odot': '\\u2299',\n    'CircleMinus': '\\u2296',\n    'ominus': '\\u2296',\n    'CirclePlus': '\\u2295',\n    'oplus': '\\u2295',\n    'CircleTimes': '\\u2297',\n    'otimes': '\\u2297',\n    'ClockwiseContourIntegral': '\\u2232',\n    'cwconint': '\\u2232',\n    'CloseCurlyDoubleQuote': '\\u201D',\n    'rdquo': '\\u201D',\n    'rdquor': '\\u201D',\n    'CloseCurlyQuote': '\\u2019',\n    'rsquo': '\\u2019',\n    'rsquor': '\\u2019',\n    'Colon': '\\u2237',\n    'Proportion': '\\u2237',\n    'Colone': '\\u2A74',\n    'Congruent': '\\u2261',\n    'equiv': '\\u2261',\n    'Conint': '\\u222F',\n    'DoubleContourIntegral': '\\u222F',\n    'ContourIntegral': '\\u222E',\n    'conint': '\\u222E',\n    'oint': '\\u222E',\n    'Copf': '\\u2102',\n    'complexes': '\\u2102',\n    'Coproduct': '\\u2210',\n    'coprod': '\\u2210',\n    'CounterClockwiseContourIntegral': '\\u2233',\n    'awconint': '\\u2233',\n    'Cross': '\\u2A2F',\n    'Cscr': '\\uD835\\uDC9E',\n    'Cup': '\\u22D3',\n    'CupCap': '\\u224D',\n    'asympeq': '\\u224D',\n    'DDotrahd': '\\u2911',\n    'DJcy': '\\u0402',\n    'DScy': '\\u0405',\n    'DZcy': '\\u040F',\n    'Dagger': '\\u2021',\n    'ddagger': '\\u2021',\n    'Darr': '\\u21A1',\n    'Dashv': '\\u2AE4',\n    'DoubleLeftTee': '\\u2AE4',\n    'Dcaron': '\\u010E',\n    'Dcy': '\\u0414',\n    'Del': '\\u2207',\n    'nabla': '\\u2207',\n    'Delta': '\\u0394',\n    'Dfr': '\\uD835\\uDD07',\n    'DiacriticalAcute': '\\u00B4',\n    'acute': '\\u00B4',\n    'DiacriticalDot': '\\u02D9',\n    'dot': '\\u02D9',\n    'DiacriticalDoubleAcute': '\\u02DD',\n    'dblac': '\\u02DD',\n    'DiacriticalGrave': '\\u0060',\n    'grave': '\\u0060',\n    'DiacriticalTilde': '\\u02DC',\n    'tilde': '\\u02DC',\n    'Diamond': '\\u22C4',\n    'diam': '\\u22C4',\n    'diamond': '\\u22C4',\n    'DifferentialD': '\\u2146',\n    'dd': '\\u2146',\n    'Dopf': '\\uD835\\uDD3B',\n    'Dot': '\\u00A8',\n    'DoubleDot': '\\u00A8',\n    'die': '\\u00A8',\n    'uml': '\\u00A8',\n    'DotDot': '\\u20DC',\n    'DotEqual': '\\u2250',\n    'doteq': '\\u2250',\n    'esdot': '\\u2250',\n    'DoubleDownArrow': '\\u21D3',\n    'Downarrow': '\\u21D3',\n    'dArr': '\\u21D3',\n    'DoubleLeftArrow': '\\u21D0',\n    'Leftarrow': '\\u21D0',\n    'lArr': '\\u21D0',\n    'DoubleLeftRightArrow': '\\u21D4',\n    'Leftrightarrow': '\\u21D4',\n    'hArr': '\\u21D4',\n    'iff': '\\u21D4',\n    'DoubleLongLeftArrow': '\\u27F8',\n    'Longleftarrow': '\\u27F8',\n    'xlArr': '\\u27F8',\n    'DoubleLongLeftRightArrow': '\\u27FA',\n    'Longleftrightarrow': '\\u27FA',\n    'xhArr': '\\u27FA',\n    'DoubleLongRightArrow': '\\u27F9',\n    'Longrightarrow': '\\u27F9',\n    'xrArr': '\\u27F9',\n    'DoubleRightArrow': '\\u21D2',\n    'Implies': '\\u21D2',\n    'Rightarrow': '\\u21D2',\n    'rArr': '\\u21D2',\n    'DoubleRightTee': '\\u22A8',\n    'vDash': '\\u22A8',\n    'DoubleUpArrow': '\\u21D1',\n    'Uparrow': '\\u21D1',\n    'uArr': '\\u21D1',\n    'DoubleUpDownArrow': '\\u21D5',\n    'Updownarrow': '\\u21D5',\n    'vArr': '\\u21D5',\n    'DoubleVerticalBar': '\\u2225',\n    'par': '\\u2225',\n    'parallel': '\\u2225',\n    'shortparallel': '\\u2225',\n    'spar': '\\u2225',\n    'DownArrow': '\\u2193',\n    'ShortDownArrow': '\\u2193',\n    'darr': '\\u2193',\n    'downarrow': '\\u2193',\n    'DownArrowBar': '\\u2913',\n    'DownArrowUpArrow': '\\u21F5',\n    'duarr': '\\u21F5',\n    'DownBreve': '\\u0311',\n    'DownLeftRightVector': '\\u2950',\n    'DownLeftTeeVector': '\\u295E',\n    'DownLeftVector': '\\u21BD',\n    'leftharpoondown': '\\u21BD',\n    'lhard': '\\u21BD',\n    'DownLeftVectorBar': '\\u2956',\n    'DownRightTeeVector': '\\u295F',\n    'DownRightVector': '\\u21C1',\n    'rhard': '\\u21C1',\n    'rightharpoondown': '\\u21C1',\n    'DownRightVectorBar': '\\u2957',\n    'DownTee': '\\u22A4',\n    'top': '\\u22A4',\n    'DownTeeArrow': '\\u21A7',\n    'mapstodown': '\\u21A7',\n    'Dscr': '\\uD835\\uDC9F',\n    'Dstrok': '\\u0110',\n    'ENG': '\\u014A',\n    'ETH': '\\u00D0',\n    'Eacute': '\\u00C9',\n    'Ecaron': '\\u011A',\n    'Ecirc': '\\u00CA',\n    'Ecy': '\\u042D',\n    'Edot': '\\u0116',\n    'Efr': '\\uD835\\uDD08',\n    'Egrave': '\\u00C8',\n    'Element': '\\u2208',\n    'in': '\\u2208',\n    'isin': '\\u2208',\n    'isinv': '\\u2208',\n    'Emacr': '\\u0112',\n    'EmptySmallSquare': '\\u25FB',\n    'EmptyVerySmallSquare': '\\u25AB',\n    'Eogon': '\\u0118',\n    'Eopf': '\\uD835\\uDD3C',\n    'Epsilon': '\\u0395',\n    'Equal': '\\u2A75',\n    'EqualTilde': '\\u2242',\n    'eqsim': '\\u2242',\n    'esim': '\\u2242',\n    'Equilibrium': '\\u21CC',\n    'rightleftharpoons': '\\u21CC',\n    'rlhar': '\\u21CC',\n    'Escr': '\\u2130',\n    'expectation': '\\u2130',\n    'Esim': '\\u2A73',\n    'Eta': '\\u0397',\n    'Euml': '\\u00CB',\n    'Exists': '\\u2203',\n    'exist': '\\u2203',\n    'ExponentialE': '\\u2147',\n    'ee': '\\u2147',\n    'exponentiale': '\\u2147',\n    'Fcy': '\\u0424',\n    'Ffr': '\\uD835\\uDD09',\n    'FilledSmallSquare': '\\u25FC',\n    'FilledVerySmallSquare': '\\u25AA',\n    'blacksquare': '\\u25AA',\n    'squarf': '\\u25AA',\n    'squf': '\\u25AA',\n    'Fopf': '\\uD835\\uDD3D',\n    'ForAll': '\\u2200',\n    'forall': '\\u2200',\n    'Fouriertrf': '\\u2131',\n    'Fscr': '\\u2131',\n    'GJcy': '\\u0403',\n    'GT': '\\u003E',\n    'gt': '\\u003E',\n    'Gamma': '\\u0393',\n    'Gammad': '\\u03DC',\n    'Gbreve': '\\u011E',\n    'Gcedil': '\\u0122',\n    'Gcirc': '\\u011C',\n    'Gcy': '\\u0413',\n    'Gdot': '\\u0120',\n    'Gfr': '\\uD835\\uDD0A',\n    'Gg': '\\u22D9',\n    'ggg': '\\u22D9',\n    'Gopf': '\\uD835\\uDD3E',\n    'GreaterEqual': '\\u2265',\n    'ge': '\\u2265',\n    'geq': '\\u2265',\n    'GreaterEqualLess': '\\u22DB',\n    'gel': '\\u22DB',\n    'gtreqless': '\\u22DB',\n    'GreaterFullEqual': '\\u2267',\n    'gE': '\\u2267',\n    'geqq': '\\u2267',\n    'GreaterGreater': '\\u2AA2',\n    'GreaterLess': '\\u2277',\n    'gl': '\\u2277',\n    'gtrless': '\\u2277',\n    'GreaterSlantEqual': '\\u2A7E',\n    'geqslant': '\\u2A7E',\n    'ges': '\\u2A7E',\n    'GreaterTilde': '\\u2273',\n    'gsim': '\\u2273',\n    'gtrsim': '\\u2273',\n    'Gscr': '\\uD835\\uDCA2',\n    'Gt': '\\u226B',\n    'NestedGreaterGreater': '\\u226B',\n    'gg': '\\u226B',\n    'HARDcy': '\\u042A',\n    'Hacek': '\\u02C7',\n    'caron': '\\u02C7',\n    'Hat': '\\u005E',\n    'Hcirc': '\\u0124',\n    'Hfr': '\\u210C',\n    'Poincareplane': '\\u210C',\n    'HilbertSpace': '\\u210B',\n    'Hscr': '\\u210B',\n    'hamilt': '\\u210B',\n    'Hopf': '\\u210D',\n    'quaternions': '\\u210D',\n    'HorizontalLine': '\\u2500',\n    'boxh': '\\u2500',\n    'Hstrok': '\\u0126',\n    'HumpEqual': '\\u224F',\n    'bumpe': '\\u224F',\n    'bumpeq': '\\u224F',\n    'IEcy': '\\u0415',\n    'IJlig': '\\u0132',\n    'IOcy': '\\u0401',\n    'Iacute': '\\u00CD',\n    'Icirc': '\\u00CE',\n    'Icy': '\\u0418',\n    'Idot': '\\u0130',\n    'Ifr': '\\u2111',\n    'Im': '\\u2111',\n    'image': '\\u2111',\n    'imagpart': '\\u2111',\n    'Igrave': '\\u00CC',\n    'Imacr': '\\u012A',\n    'ImaginaryI': '\\u2148',\n    'ii': '\\u2148',\n    'Int': '\\u222C',\n    'Integral': '\\u222B',\n    'int': '\\u222B',\n    'Intersection': '\\u22C2',\n    'bigcap': '\\u22C2',\n    'xcap': '\\u22C2',\n    'InvisibleComma': '\\u2063',\n    'ic': '\\u2063',\n    'InvisibleTimes': '\\u2062',\n    'it': '\\u2062',\n    'Iogon': '\\u012E',\n    'Iopf': '\\uD835\\uDD40',\n    'Iota': '\\u0399',\n    'Iscr': '\\u2110',\n    'imagline': '\\u2110',\n    'Itilde': '\\u0128',\n    'Iukcy': '\\u0406',\n    'Iuml': '\\u00CF',\n    'Jcirc': '\\u0134',\n    'Jcy': '\\u0419',\n    'Jfr': '\\uD835\\uDD0D',\n    'Jopf': '\\uD835\\uDD41',\n    'Jscr': '\\uD835\\uDCA5',\n    'Jsercy': '\\u0408',\n    'Jukcy': '\\u0404',\n    'KHcy': '\\u0425',\n    'KJcy': '\\u040C',\n    'Kappa': '\\u039A',\n    'Kcedil': '\\u0136',\n    'Kcy': '\\u041A',\n    'Kfr': '\\uD835\\uDD0E',\n    'Kopf': '\\uD835\\uDD42',\n    'Kscr': '\\uD835\\uDCA6',\n    'LJcy': '\\u0409',\n    'LT': '\\u003C',\n    'lt': '\\u003C',\n    'Lacute': '\\u0139',\n    'Lambda': '\\u039B',\n    'Lang': '\\u27EA',\n    'Laplacetrf': '\\u2112',\n    'Lscr': '\\u2112',\n    'lagran': '\\u2112',\n    'Larr': '\\u219E',\n    'twoheadleftarrow': '\\u219E',\n    'Lcaron': '\\u013D',\n    'Lcedil': '\\u013B',\n    'Lcy': '\\u041B',\n    'LeftAngleBracket': '\\u27E8',\n    'lang': '\\u27E8',\n    'langle': '\\u27E8',\n    'LeftArrow': '\\u2190',\n    'ShortLeftArrow': '\\u2190',\n    'larr': '\\u2190',\n    'leftarrow': '\\u2190',\n    'slarr': '\\u2190',\n    'LeftArrowBar': '\\u21E4',\n    'larrb': '\\u21E4',\n    'LeftArrowRightArrow': '\\u21C6',\n    'leftrightarrows': '\\u21C6',\n    'lrarr': '\\u21C6',\n    'LeftCeiling': '\\u2308',\n    'lceil': '\\u2308',\n    'LeftDoubleBracket': '\\u27E6',\n    'lobrk': '\\u27E6',\n    'LeftDownTeeVector': '\\u2961',\n    'LeftDownVector': '\\u21C3',\n    'dharl': '\\u21C3',\n    'downharpoonleft': '\\u21C3',\n    'LeftDownVectorBar': '\\u2959',\n    'LeftFloor': '\\u230A',\n    'lfloor': '\\u230A',\n    'LeftRightArrow': '\\u2194',\n    'harr': '\\u2194',\n    'leftrightarrow': '\\u2194',\n    'LeftRightVector': '\\u294E',\n    'LeftTee': '\\u22A3',\n    'dashv': '\\u22A3',\n    'LeftTeeArrow': '\\u21A4',\n    'mapstoleft': '\\u21A4',\n    'LeftTeeVector': '\\u295A',\n    'LeftTriangle': '\\u22B2',\n    'vartriangleleft': '\\u22B2',\n    'vltri': '\\u22B2',\n    'LeftTriangleBar': '\\u29CF',\n    'LeftTriangleEqual': '\\u22B4',\n    'ltrie': '\\u22B4',\n    'trianglelefteq': '\\u22B4',\n    'LeftUpDownVector': '\\u2951',\n    'LeftUpTeeVector': '\\u2960',\n    'LeftUpVector': '\\u21BF',\n    'uharl': '\\u21BF',\n    'upharpoonleft': '\\u21BF',\n    'LeftUpVectorBar': '\\u2958',\n    'LeftVector': '\\u21BC',\n    'leftharpoonup': '\\u21BC',\n    'lharu': '\\u21BC',\n    'LeftVectorBar': '\\u2952',\n    'LessEqualGreater': '\\u22DA',\n    'leg': '\\u22DA',\n    'lesseqgtr': '\\u22DA',\n    'LessFullEqual': '\\u2266',\n    'lE': '\\u2266',\n    'leqq': '\\u2266',\n    'LessGreater': '\\u2276',\n    'lessgtr': '\\u2276',\n    'lg': '\\u2276',\n    'LessLess': '\\u2AA1',\n    'LessSlantEqual': '\\u2A7D',\n    'leqslant': '\\u2A7D',\n    'les': '\\u2A7D',\n    'LessTilde': '\\u2272',\n    'lesssim': '\\u2272',\n    'lsim': '\\u2272',\n    'Lfr': '\\uD835\\uDD0F',\n    'Ll': '\\u22D8',\n    'Lleftarrow': '\\u21DA',\n    'lAarr': '\\u21DA',\n    'Lmidot': '\\u013F',\n    'LongLeftArrow': '\\u27F5',\n    'longleftarrow': '\\u27F5',\n    'xlarr': '\\u27F5',\n    'LongLeftRightArrow': '\\u27F7',\n    'longleftrightarrow': '\\u27F7',\n    'xharr': '\\u27F7',\n    'LongRightArrow': '\\u27F6',\n    'longrightarrow': '\\u27F6',\n    'xrarr': '\\u27F6',\n    'Lopf': '\\uD835\\uDD43',\n    'LowerLeftArrow': '\\u2199',\n    'swarr': '\\u2199',\n    'swarrow': '\\u2199',\n    'LowerRightArrow': '\\u2198',\n    'searr': '\\u2198',\n    'searrow': '\\u2198',\n    'Lsh': '\\u21B0',\n    'lsh': '\\u21B0',\n    'Lstrok': '\\u0141',\n    'Lt': '\\u226A',\n    'NestedLessLess': '\\u226A',\n    'll': '\\u226A',\n    'Map': '\\u2905',\n    'Mcy': '\\u041C',\n    'MediumSpace': '\\u205F',\n    'Mellintrf': '\\u2133',\n    'Mscr': '\\u2133',\n    'phmmat': '\\u2133',\n    'Mfr': '\\uD835\\uDD10',\n    'MinusPlus': '\\u2213',\n    'mnplus': '\\u2213',\n    'mp': '\\u2213',\n    'Mopf': '\\uD835\\uDD44',\n    'Mu': '\\u039C',\n    'NJcy': '\\u040A',\n    'Nacute': '\\u0143',\n    'Ncaron': '\\u0147',\n    'Ncedil': '\\u0145',\n    'Ncy': '\\u041D',\n    'NegativeMediumSpace': '\\u200B',\n    'NegativeThickSpace': '\\u200B',\n    'NegativeThinSpace': '\\u200B',\n    'NegativeVeryThinSpace': '\\u200B',\n    'ZeroWidthSpace': '\\u200B',\n    'NewLine': '\\u000A',\n    'Nfr': '\\uD835\\uDD11',\n    'NoBreak': '\\u2060',\n    'NonBreakingSpace': '\\u00A0',\n    'nbsp': '\\u00A0',\n    'Nopf': '\\u2115',\n    'naturals': '\\u2115',\n    'Not': '\\u2AEC',\n    'NotCongruent': '\\u2262',\n    'nequiv': '\\u2262',\n    'NotCupCap': '\\u226D',\n    'NotDoubleVerticalBar': '\\u2226',\n    'npar': '\\u2226',\n    'nparallel': '\\u2226',\n    'nshortparallel': '\\u2226',\n    'nspar': '\\u2226',\n    'NotElement': '\\u2209',\n    'notin': '\\u2209',\n    'notinva': '\\u2209',\n    'NotEqual': '\\u2260',\n    'ne': '\\u2260',\n    'NotEqualTilde': '\\u2242\\u0338',\n    'nesim': '\\u2242\\u0338',\n    'NotExists': '\\u2204',\n    'nexist': '\\u2204',\n    'nexists': '\\u2204',\n    'NotGreater': '\\u226F',\n    'ngt': '\\u226F',\n    'ngtr': '\\u226F',\n    'NotGreaterEqual': '\\u2271',\n    'nge': '\\u2271',\n    'ngeq': '\\u2271',\n    'NotGreaterFullEqual': '\\u2267\\u0338',\n    'ngE': '\\u2267\\u0338',\n    'ngeqq': '\\u2267\\u0338',\n    'NotGreaterGreater': '\\u226B\\u0338',\n    'nGtv': '\\u226B\\u0338',\n    'NotGreaterLess': '\\u2279',\n    'ntgl': '\\u2279',\n    'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n    'ngeqslant': '\\u2A7E\\u0338',\n    'nges': '\\u2A7E\\u0338',\n    'NotGreaterTilde': '\\u2275',\n    'ngsim': '\\u2275',\n    'NotHumpDownHump': '\\u224E\\u0338',\n    'nbump': '\\u224E\\u0338',\n    'NotHumpEqual': '\\u224F\\u0338',\n    'nbumpe': '\\u224F\\u0338',\n    'NotLeftTriangle': '\\u22EA',\n    'nltri': '\\u22EA',\n    'ntriangleleft': '\\u22EA',\n    'NotLeftTriangleBar': '\\u29CF\\u0338',\n    'NotLeftTriangleEqual': '\\u22EC',\n    'nltrie': '\\u22EC',\n    'ntrianglelefteq': '\\u22EC',\n    'NotLess': '\\u226E',\n    'nless': '\\u226E',\n    'nlt': '\\u226E',\n    'NotLessEqual': '\\u2270',\n    'nle': '\\u2270',\n    'nleq': '\\u2270',\n    'NotLessGreater': '\\u2278',\n    'ntlg': '\\u2278',\n    'NotLessLess': '\\u226A\\u0338',\n    'nLtv': '\\u226A\\u0338',\n    'NotLessSlantEqual': '\\u2A7D\\u0338',\n    'nleqslant': '\\u2A7D\\u0338',\n    'nles': '\\u2A7D\\u0338',\n    'NotLessTilde': '\\u2274',\n    'nlsim': '\\u2274',\n    'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n    'NotNestedLessLess': '\\u2AA1\\u0338',\n    'NotPrecedes': '\\u2280',\n    'npr': '\\u2280',\n    'nprec': '\\u2280',\n    'NotPrecedesEqual': '\\u2AAF\\u0338',\n    'npre': '\\u2AAF\\u0338',\n    'npreceq': '\\u2AAF\\u0338',\n    'NotPrecedesSlantEqual': '\\u22E0',\n    'nprcue': '\\u22E0',\n    'NotReverseElement': '\\u220C',\n    'notni': '\\u220C',\n    'notniva': '\\u220C',\n    'NotRightTriangle': '\\u22EB',\n    'nrtri': '\\u22EB',\n    'ntriangleright': '\\u22EB',\n    'NotRightTriangleBar': '\\u29D0\\u0338',\n    'NotRightTriangleEqual': '\\u22ED',\n    'nrtrie': '\\u22ED',\n    'ntrianglerighteq': '\\u22ED',\n    'NotSquareSubset': '\\u228F\\u0338',\n    'NotSquareSubsetEqual': '\\u22E2',\n    'nsqsube': '\\u22E2',\n    'NotSquareSuperset': '\\u2290\\u0338',\n    'NotSquareSupersetEqual': '\\u22E3',\n    'nsqsupe': '\\u22E3',\n    'NotSubset': '\\u2282\\u20D2',\n    'nsubset': '\\u2282\\u20D2',\n    'vnsub': '\\u2282\\u20D2',\n    'NotSubsetEqual': '\\u2288',\n    'nsube': '\\u2288',\n    'nsubseteq': '\\u2288',\n    'NotSucceeds': '\\u2281',\n    'nsc': '\\u2281',\n    'nsucc': '\\u2281',\n    'NotSucceedsEqual': '\\u2AB0\\u0338',\n    'nsce': '\\u2AB0\\u0338',\n    'nsucceq': '\\u2AB0\\u0338',\n    'NotSucceedsSlantEqual': '\\u22E1',\n    'nsccue': '\\u22E1',\n    'NotSucceedsTilde': '\\u227F\\u0338',\n    'NotSuperset': '\\u2283\\u20D2',\n    'nsupset': '\\u2283\\u20D2',\n    'vnsup': '\\u2283\\u20D2',\n    'NotSupersetEqual': '\\u2289',\n    'nsupe': '\\u2289',\n    'nsupseteq': '\\u2289',\n    'NotTilde': '\\u2241',\n    'nsim': '\\u2241',\n    'NotTildeEqual': '\\u2244',\n    'nsime': '\\u2244',\n    'nsimeq': '\\u2244',\n    'NotTildeFullEqual': '\\u2247',\n    'ncong': '\\u2247',\n    'NotTildeTilde': '\\u2249',\n    'nap': '\\u2249',\n    'napprox': '\\u2249',\n    'NotVerticalBar': '\\u2224',\n    'nmid': '\\u2224',\n    'nshortmid': '\\u2224',\n    'nsmid': '\\u2224',\n    'Nscr': '\\uD835\\uDCA9',\n    'Ntilde': '\\u00D1',\n    'Nu': '\\u039D',\n    'OElig': '\\u0152',\n    'Oacute': '\\u00D3',\n    'Ocirc': '\\u00D4',\n    'Ocy': '\\u041E',\n    'Odblac': '\\u0150',\n    'Ofr': '\\uD835\\uDD12',\n    'Ograve': '\\u00D2',\n    'Omacr': '\\u014C',\n    'Omega': '\\u03A9',\n    'ohm': '\\u03A9',\n    'Omicron': '\\u039F',\n    'Oopf': '\\uD835\\uDD46',\n    'OpenCurlyDoubleQuote': '\\u201C',\n    'ldquo': '\\u201C',\n    'OpenCurlyQuote': '\\u2018',\n    'lsquo': '\\u2018',\n    'Or': '\\u2A54',\n    'Oscr': '\\uD835\\uDCAA',\n    'Oslash': '\\u00D8',\n    'Otilde': '\\u00D5',\n    'Otimes': '\\u2A37',\n    'Ouml': '\\u00D6',\n    'OverBar': '\\u203E',\n    'oline': '\\u203E',\n    'OverBrace': '\\u23DE',\n    'OverBracket': '\\u23B4',\n    'tbrk': '\\u23B4',\n    'OverParenthesis': '\\u23DC',\n    'PartialD': '\\u2202',\n    'part': '\\u2202',\n    'Pcy': '\\u041F',\n    'Pfr': '\\uD835\\uDD13',\n    'Phi': '\\u03A6',\n    'Pi': '\\u03A0',\n    'PlusMinus': '\\u00B1',\n    'plusmn': '\\u00B1',\n    'pm': '\\u00B1',\n    'Popf': '\\u2119',\n    'primes': '\\u2119',\n    'Pr': '\\u2ABB',\n    'Precedes': '\\u227A',\n    'pr': '\\u227A',\n    'prec': '\\u227A',\n    'PrecedesEqual': '\\u2AAF',\n    'pre': '\\u2AAF',\n    'preceq': '\\u2AAF',\n    'PrecedesSlantEqual': '\\u227C',\n    'prcue': '\\u227C',\n    'preccurlyeq': '\\u227C',\n    'PrecedesTilde': '\\u227E',\n    'precsim': '\\u227E',\n    'prsim': '\\u227E',\n    'Prime': '\\u2033',\n    'Product': '\\u220F',\n    'prod': '\\u220F',\n    'Proportional': '\\u221D',\n    'prop': '\\u221D',\n    'propto': '\\u221D',\n    'varpropto': '\\u221D',\n    'vprop': '\\u221D',\n    'Pscr': '\\uD835\\uDCAB',\n    'Psi': '\\u03A8',\n    'QUOT': '\\u0022',\n    'quot': '\\u0022',\n    'Qfr': '\\uD835\\uDD14',\n    'Qopf': '\\u211A',\n    'rationals': '\\u211A',\n    'Qscr': '\\uD835\\uDCAC',\n    'RBarr': '\\u2910',\n    'drbkarow': '\\u2910',\n    'REG': '\\u00AE',\n    'circledR': '\\u00AE',\n    'reg': '\\u00AE',\n    'Racute': '\\u0154',\n    'Rang': '\\u27EB',\n    'Rarr': '\\u21A0',\n    'twoheadrightarrow': '\\u21A0',\n    'Rarrtl': '\\u2916',\n    'Rcaron': '\\u0158',\n    'Rcedil': '\\u0156',\n    'Rcy': '\\u0420',\n    'Re': '\\u211C',\n    'Rfr': '\\u211C',\n    'real': '\\u211C',\n    'realpart': '\\u211C',\n    'ReverseElement': '\\u220B',\n    'SuchThat': '\\u220B',\n    'ni': '\\u220B',\n    'niv': '\\u220B',\n    'ReverseEquilibrium': '\\u21CB',\n    'leftrightharpoons': '\\u21CB',\n    'lrhar': '\\u21CB',\n    'ReverseUpEquilibrium': '\\u296F',\n    'duhar': '\\u296F',\n    'Rho': '\\u03A1',\n    'RightAngleBracket': '\\u27E9',\n    'rang': '\\u27E9',\n    'rangle': '\\u27E9',\n    'RightArrow': '\\u2192',\n    'ShortRightArrow': '\\u2192',\n    'rarr': '\\u2192',\n    'rightarrow': '\\u2192',\n    'srarr': '\\u2192',\n    'RightArrowBar': '\\u21E5',\n    'rarrb': '\\u21E5',\n    'RightArrowLeftArrow': '\\u21C4',\n    'rightleftarrows': '\\u21C4',\n    'rlarr': '\\u21C4',\n    'RightCeiling': '\\u2309',\n    'rceil': '\\u2309',\n    'RightDoubleBracket': '\\u27E7',\n    'robrk': '\\u27E7',\n    'RightDownTeeVector': '\\u295D',\n    'RightDownVector': '\\u21C2',\n    'dharr': '\\u21C2',\n    'downharpoonright': '\\u21C2',\n    'RightDownVectorBar': '\\u2955',\n    'RightFloor': '\\u230B',\n    'rfloor': '\\u230B',\n    'RightTee': '\\u22A2',\n    'vdash': '\\u22A2',\n    'RightTeeArrow': '\\u21A6',\n    'map': '\\u21A6',\n    'mapsto': '\\u21A6',\n    'RightTeeVector': '\\u295B',\n    'RightTriangle': '\\u22B3',\n    'vartriangleright': '\\u22B3',\n    'vrtri': '\\u22B3',\n    'RightTriangleBar': '\\u29D0',\n    'RightTriangleEqual': '\\u22B5',\n    'rtrie': '\\u22B5',\n    'trianglerighteq': '\\u22B5',\n    'RightUpDownVector': '\\u294F',\n    'RightUpTeeVector': '\\u295C',\n    'RightUpVector': '\\u21BE',\n    'uharr': '\\u21BE',\n    'upharpoonright': '\\u21BE',\n    'RightUpVectorBar': '\\u2954',\n    'RightVector': '\\u21C0',\n    'rharu': '\\u21C0',\n    'rightharpoonup': '\\u21C0',\n    'RightVectorBar': '\\u2953',\n    'Ropf': '\\u211D',\n    'reals': '\\u211D',\n    'RoundImplies': '\\u2970',\n    'Rrightarrow': '\\u21DB',\n    'rAarr': '\\u21DB',\n    'Rscr': '\\u211B',\n    'realine': '\\u211B',\n    'Rsh': '\\u21B1',\n    'rsh': '\\u21B1',\n    'RuleDelayed': '\\u29F4',\n    'SHCHcy': '\\u0429',\n    'SHcy': '\\u0428',\n    'SOFTcy': '\\u042C',\n    'Sacute': '\\u015A',\n    'Sc': '\\u2ABC',\n    'Scaron': '\\u0160',\n    'Scedil': '\\u015E',\n    'Scirc': '\\u015C',\n    'Scy': '\\u0421',\n    'Sfr': '\\uD835\\uDD16',\n    'ShortUpArrow': '\\u2191',\n    'UpArrow': '\\u2191',\n    'uarr': '\\u2191',\n    'uparrow': '\\u2191',\n    'Sigma': '\\u03A3',\n    'SmallCircle': '\\u2218',\n    'compfn': '\\u2218',\n    'Sopf': '\\uD835\\uDD4A',\n    'Sqrt': '\\u221A',\n    'radic': '\\u221A',\n    'Square': '\\u25A1',\n    'squ': '\\u25A1',\n    'square': '\\u25A1',\n    'SquareIntersection': '\\u2293',\n    'sqcap': '\\u2293',\n    'SquareSubset': '\\u228F',\n    'sqsub': '\\u228F',\n    'sqsubset': '\\u228F',\n    'SquareSubsetEqual': '\\u2291',\n    'sqsube': '\\u2291',\n    'sqsubseteq': '\\u2291',\n    'SquareSuperset': '\\u2290',\n    'sqsup': '\\u2290',\n    'sqsupset': '\\u2290',\n    'SquareSupersetEqual': '\\u2292',\n    'sqsupe': '\\u2292',\n    'sqsupseteq': '\\u2292',\n    'SquareUnion': '\\u2294',\n    'sqcup': '\\u2294',\n    'Sscr': '\\uD835\\uDCAE',\n    'Star': '\\u22C6',\n    'sstarf': '\\u22C6',\n    'Sub': '\\u22D0',\n    'Subset': '\\u22D0',\n    'SubsetEqual': '\\u2286',\n    'sube': '\\u2286',\n    'subseteq': '\\u2286',\n    'Succeeds': '\\u227B',\n    'sc': '\\u227B',\n    'succ': '\\u227B',\n    'SucceedsEqual': '\\u2AB0',\n    'sce': '\\u2AB0',\n    'succeq': '\\u2AB0',\n    'SucceedsSlantEqual': '\\u227D',\n    'sccue': '\\u227D',\n    'succcurlyeq': '\\u227D',\n    'SucceedsTilde': '\\u227F',\n    'scsim': '\\u227F',\n    'succsim': '\\u227F',\n    'Sum': '\\u2211',\n    'sum': '\\u2211',\n    'Sup': '\\u22D1',\n    'Supset': '\\u22D1',\n    'Superset': '\\u2283',\n    'sup': '\\u2283',\n    'supset': '\\u2283',\n    'SupersetEqual': '\\u2287',\n    'supe': '\\u2287',\n    'supseteq': '\\u2287',\n    'THORN': '\\u00DE',\n    'TRADE': '\\u2122',\n    'trade': '\\u2122',\n    'TSHcy': '\\u040B',\n    'TScy': '\\u0426',\n    'Tab': '\\u0009',\n    'Tau': '\\u03A4',\n    'Tcaron': '\\u0164',\n    'Tcedil': '\\u0162',\n    'Tcy': '\\u0422',\n    'Tfr': '\\uD835\\uDD17',\n    'Therefore': '\\u2234',\n    'there4': '\\u2234',\n    'therefore': '\\u2234',\n    'Theta': '\\u0398',\n    'ThickSpace': '\\u205F\\u200A',\n    'ThinSpace': '\\u2009',\n    'thinsp': '\\u2009',\n    'Tilde': '\\u223C',\n    'sim': '\\u223C',\n    'thicksim': '\\u223C',\n    'thksim': '\\u223C',\n    'TildeEqual': '\\u2243',\n    'sime': '\\u2243',\n    'simeq': '\\u2243',\n    'TildeFullEqual': '\\u2245',\n    'cong': '\\u2245',\n    'TildeTilde': '\\u2248',\n    'ap': '\\u2248',\n    'approx': '\\u2248',\n    'asymp': '\\u2248',\n    'thickapprox': '\\u2248',\n    'thkap': '\\u2248',\n    'Topf': '\\uD835\\uDD4B',\n    'TripleDot': '\\u20DB',\n    'tdot': '\\u20DB',\n    'Tscr': '\\uD835\\uDCAF',\n    'Tstrok': '\\u0166',\n    'Uacute': '\\u00DA',\n    'Uarr': '\\u219F',\n    'Uarrocir': '\\u2949',\n    'Ubrcy': '\\u040E',\n    'Ubreve': '\\u016C',\n    'Ucirc': '\\u00DB',\n    'Ucy': '\\u0423',\n    'Udblac': '\\u0170',\n    'Ufr': '\\uD835\\uDD18',\n    'Ugrave': '\\u00D9',\n    'Umacr': '\\u016A',\n    'UnderBar': '\\u005F',\n    'lowbar': '\\u005F',\n    'UnderBrace': '\\u23DF',\n    'UnderBracket': '\\u23B5',\n    'bbrk': '\\u23B5',\n    'UnderParenthesis': '\\u23DD',\n    'Union': '\\u22C3',\n    'bigcup': '\\u22C3',\n    'xcup': '\\u22C3',\n    'UnionPlus': '\\u228E',\n    'uplus': '\\u228E',\n    'Uogon': '\\u0172',\n    'Uopf': '\\uD835\\uDD4C',\n    'UpArrowBar': '\\u2912',\n    'UpArrowDownArrow': '\\u21C5',\n    'udarr': '\\u21C5',\n    'UpDownArrow': '\\u2195',\n    'updownarrow': '\\u2195',\n    'varr': '\\u2195',\n    'UpEquilibrium': '\\u296E',\n    'udhar': '\\u296E',\n    'UpTee': '\\u22A5',\n    'bot': '\\u22A5',\n    'bottom': '\\u22A5',\n    'perp': '\\u22A5',\n    'UpTeeArrow': '\\u21A5',\n    'mapstoup': '\\u21A5',\n    'UpperLeftArrow': '\\u2196',\n    'nwarr': '\\u2196',\n    'nwarrow': '\\u2196',\n    'UpperRightArrow': '\\u2197',\n    'nearr': '\\u2197',\n    'nearrow': '\\u2197',\n    'Upsi': '\\u03D2',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'Uring': '\\u016E',\n    'Uscr': '\\uD835\\uDCB0',\n    'Utilde': '\\u0168',\n    'Uuml': '\\u00DC',\n    'VDash': '\\u22AB',\n    'Vbar': '\\u2AEB',\n    'Vcy': '\\u0412',\n    'Vdash': '\\u22A9',\n    'Vdashl': '\\u2AE6',\n    'Vee': '\\u22C1',\n    'bigvee': '\\u22C1',\n    'xvee': '\\u22C1',\n    'Verbar': '\\u2016',\n    'Vert': '\\u2016',\n    'VerticalBar': '\\u2223',\n    'mid': '\\u2223',\n    'shortmid': '\\u2223',\n    'smid': '\\u2223',\n    'VerticalLine': '\\u007C',\n    'verbar': '\\u007C',\n    'vert': '\\u007C',\n    'VerticalSeparator': '\\u2758',\n    'VerticalTilde': '\\u2240',\n    'wr': '\\u2240',\n    'wreath': '\\u2240',\n    'VeryThinSpace': '\\u200A',\n    'hairsp': '\\u200A',\n    'Vfr': '\\uD835\\uDD19',\n    'Vopf': '\\uD835\\uDD4D',\n    'Vscr': '\\uD835\\uDCB1',\n    'Vvdash': '\\u22AA',\n    'Wcirc': '\\u0174',\n    'Wedge': '\\u22C0',\n    'bigwedge': '\\u22C0',\n    'xwedge': '\\u22C0',\n    'Wfr': '\\uD835\\uDD1A',\n    'Wopf': '\\uD835\\uDD4E',\n    'Wscr': '\\uD835\\uDCB2',\n    'Xfr': '\\uD835\\uDD1B',\n    'Xi': '\\u039E',\n    'Xopf': '\\uD835\\uDD4F',\n    'Xscr': '\\uD835\\uDCB3',\n    'YAcy': '\\u042F',\n    'YIcy': '\\u0407',\n    'YUcy': '\\u042E',\n    'Yacute': '\\u00DD',\n    'Ycirc': '\\u0176',\n    'Ycy': '\\u042B',\n    'Yfr': '\\uD835\\uDD1C',\n    'Yopf': '\\uD835\\uDD50',\n    'Yscr': '\\uD835\\uDCB4',\n    'Yuml': '\\u0178',\n    'ZHcy': '\\u0416',\n    'Zacute': '\\u0179',\n    'Zcaron': '\\u017D',\n    'Zcy': '\\u0417',\n    'Zdot': '\\u017B',\n    'Zeta': '\\u0396',\n    'Zfr': '\\u2128',\n    'zeetrf': '\\u2128',\n    'Zopf': '\\u2124',\n    'integers': '\\u2124',\n    'Zscr': '\\uD835\\uDCB5',\n    'aacute': '\\u00E1',\n    'abreve': '\\u0103',\n    'ac': '\\u223E',\n    'mstpos': '\\u223E',\n    'acE': '\\u223E\\u0333',\n    'acd': '\\u223F',\n    'acirc': '\\u00E2',\n    'acy': '\\u0430',\n    'aelig': '\\u00E6',\n    'afr': '\\uD835\\uDD1E',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'aleph': '\\u2135',\n    'alpha': '\\u03B1',\n    'amacr': '\\u0101',\n    'amalg': '\\u2A3F',\n    'and': '\\u2227',\n    'wedge': '\\u2227',\n    'andand': '\\u2A55',\n    'andd': '\\u2A5C',\n    'andslope': '\\u2A58',\n    'andv': '\\u2A5A',\n    'ang': '\\u2220',\n    'angle': '\\u2220',\n    'ange': '\\u29A4',\n    'angmsd': '\\u2221',\n    'measuredangle': '\\u2221',\n    'angmsdaa': '\\u29A8',\n    'angmsdab': '\\u29A9',\n    'angmsdac': '\\u29AA',\n    'angmsdad': '\\u29AB',\n    'angmsdae': '\\u29AC',\n    'angmsdaf': '\\u29AD',\n    'angmsdag': '\\u29AE',\n    'angmsdah': '\\u29AF',\n    'angrt': '\\u221F',\n    'angrtvb': '\\u22BE',\n    'angrtvbd': '\\u299D',\n    'angsph': '\\u2222',\n    'angzarr': '\\u237C',\n    'aogon': '\\u0105',\n    'aopf': '\\uD835\\uDD52',\n    'apE': '\\u2A70',\n    'apacir': '\\u2A6F',\n    'ape': '\\u224A',\n    'approxeq': '\\u224A',\n    'apid': '\\u224B',\n    'apos': '\\u0027',\n    'aring': '\\u00E5',\n    'ascr': '\\uD835\\uDCB6',\n    'ast': '\\u002A',\n    'midast': '\\u002A',\n    'atilde': '\\u00E3',\n    'auml': '\\u00E4',\n    'awint': '\\u2A11',\n    'bNot': '\\u2AED',\n    'backcong': '\\u224C',\n    'bcong': '\\u224C',\n    'backepsilon': '\\u03F6',\n    'bepsi': '\\u03F6',\n    'backprime': '\\u2035',\n    'bprime': '\\u2035',\n    'backsim': '\\u223D',\n    'bsim': '\\u223D',\n    'backsimeq': '\\u22CD',\n    'bsime': '\\u22CD',\n    'barvee': '\\u22BD',\n    'barwed': '\\u2305',\n    'barwedge': '\\u2305',\n    'bbrktbrk': '\\u23B6',\n    'bcy': '\\u0431',\n    'bdquo': '\\u201E',\n    'ldquor': '\\u201E',\n    'bemptyv': '\\u29B0',\n    'beta': '\\u03B2',\n    'beth': '\\u2136',\n    'between': '\\u226C',\n    'twixt': '\\u226C',\n    'bfr': '\\uD835\\uDD1F',\n    'bigcirc': '\\u25EF',\n    'xcirc': '\\u25EF',\n    'bigodot': '\\u2A00',\n    'xodot': '\\u2A00',\n    'bigoplus': '\\u2A01',\n    'xoplus': '\\u2A01',\n    'bigotimes': '\\u2A02',\n    'xotime': '\\u2A02',\n    'bigsqcup': '\\u2A06',\n    'xsqcup': '\\u2A06',\n    'bigstar': '\\u2605',\n    'starf': '\\u2605',\n    'bigtriangledown': '\\u25BD',\n    'xdtri': '\\u25BD',\n    'bigtriangleup': '\\u25B3',\n    'xutri': '\\u25B3',\n    'biguplus': '\\u2A04',\n    'xuplus': '\\u2A04',\n    'bkarow': '\\u290D',\n    'rbarr': '\\u290D',\n    'blacklozenge': '\\u29EB',\n    'lozf': '\\u29EB',\n    'blacktriangle': '\\u25B4',\n    'utrif': '\\u25B4',\n    'blacktriangledown': '\\u25BE',\n    'dtrif': '\\u25BE',\n    'blacktriangleleft': '\\u25C2',\n    'ltrif': '\\u25C2',\n    'blacktriangleright': '\\u25B8',\n    'rtrif': '\\u25B8',\n    'blank': '\\u2423',\n    'blk12': '\\u2592',\n    'blk14': '\\u2591',\n    'blk34': '\\u2593',\n    'block': '\\u2588',\n    'bne': '\\u003D\\u20E5',\n    'bnequiv': '\\u2261\\u20E5',\n    'bnot': '\\u2310',\n    'bopf': '\\uD835\\uDD53',\n    'bowtie': '\\u22C8',\n    'boxDL': '\\u2557',\n    'boxDR': '\\u2554',\n    'boxDl': '\\u2556',\n    'boxDr': '\\u2553',\n    'boxH': '\\u2550',\n    'boxHD': '\\u2566',\n    'boxHU': '\\u2569',\n    'boxHd': '\\u2564',\n    'boxHu': '\\u2567',\n    'boxUL': '\\u255D',\n    'boxUR': '\\u255A',\n    'boxUl': '\\u255C',\n    'boxUr': '\\u2559',\n    'boxV': '\\u2551',\n    'boxVH': '\\u256C',\n    'boxVL': '\\u2563',\n    'boxVR': '\\u2560',\n    'boxVh': '\\u256B',\n    'boxVl': '\\u2562',\n    'boxVr': '\\u255F',\n    'boxbox': '\\u29C9',\n    'boxdL': '\\u2555',\n    'boxdR': '\\u2552',\n    'boxdl': '\\u2510',\n    'boxdr': '\\u250C',\n    'boxhD': '\\u2565',\n    'boxhU': '\\u2568',\n    'boxhd': '\\u252C',\n    'boxhu': '\\u2534',\n    'boxminus': '\\u229F',\n    'minusb': '\\u229F',\n    'boxplus': '\\u229E',\n    'plusb': '\\u229E',\n    'boxtimes': '\\u22A0',\n    'timesb': '\\u22A0',\n    'boxuL': '\\u255B',\n    'boxuR': '\\u2558',\n    'boxul': '\\u2518',\n    'boxur': '\\u2514',\n    'boxv': '\\u2502',\n    'boxvH': '\\u256A',\n    'boxvL': '\\u2561',\n    'boxvR': '\\u255E',\n    'boxvh': '\\u253C',\n    'boxvl': '\\u2524',\n    'boxvr': '\\u251C',\n    'brvbar': '\\u00A6',\n    'bscr': '\\uD835\\uDCB7',\n    'bsemi': '\\u204F',\n    'bsol': '\\u005C',\n    'bsolb': '\\u29C5',\n    'bsolhsub': '\\u27C8',\n    'bull': '\\u2022',\n    'bullet': '\\u2022',\n    'bumpE': '\\u2AAE',\n    'cacute': '\\u0107',\n    'cap': '\\u2229',\n    'capand': '\\u2A44',\n    'capbrcup': '\\u2A49',\n    'capcap': '\\u2A4B',\n    'capcup': '\\u2A47',\n    'capdot': '\\u2A40',\n    'caps': '\\u2229\\uFE00',\n    'caret': '\\u2041',\n    'ccaps': '\\u2A4D',\n    'ccaron': '\\u010D',\n    'ccedil': '\\u00E7',\n    'ccirc': '\\u0109',\n    'ccups': '\\u2A4C',\n    'ccupssm': '\\u2A50',\n    'cdot': '\\u010B',\n    'cemptyv': '\\u29B2',\n    'cent': '\\u00A2',\n    'cfr': '\\uD835\\uDD20',\n    'chcy': '\\u0447',\n    'check': '\\u2713',\n    'checkmark': '\\u2713',\n    'chi': '\\u03C7',\n    'cir': '\\u25CB',\n    'cirE': '\\u29C3',\n    'circ': '\\u02C6',\n    'circeq': '\\u2257',\n    'cire': '\\u2257',\n    'circlearrowleft': '\\u21BA',\n    'olarr': '\\u21BA',\n    'circlearrowright': '\\u21BB',\n    'orarr': '\\u21BB',\n    'circledS': '\\u24C8',\n    'oS': '\\u24C8',\n    'circledast': '\\u229B',\n    'oast': '\\u229B',\n    'circledcirc': '\\u229A',\n    'ocir': '\\u229A',\n    'circleddash': '\\u229D',\n    'odash': '\\u229D',\n    'cirfnint': '\\u2A10',\n    'cirmid': '\\u2AEF',\n    'cirscir': '\\u29C2',\n    'clubs': '\\u2663',\n    'clubsuit': '\\u2663',\n    'colon': '\\u003A',\n    'comma': '\\u002C',\n    'commat': '\\u0040',\n    'comp': '\\u2201',\n    'complement': '\\u2201',\n    'congdot': '\\u2A6D',\n    'copf': '\\uD835\\uDD54',\n    'copysr': '\\u2117',\n    'crarr': '\\u21B5',\n    'cross': '\\u2717',\n    'cscr': '\\uD835\\uDCB8',\n    'csub': '\\u2ACF',\n    'csube': '\\u2AD1',\n    'csup': '\\u2AD0',\n    'csupe': '\\u2AD2',\n    'ctdot': '\\u22EF',\n    'cudarrl': '\\u2938',\n    'cudarrr': '\\u2935',\n    'cuepr': '\\u22DE',\n    'curlyeqprec': '\\u22DE',\n    'cuesc': '\\u22DF',\n    'curlyeqsucc': '\\u22DF',\n    'cularr': '\\u21B6',\n    'curvearrowleft': '\\u21B6',\n    'cularrp': '\\u293D',\n    'cup': '\\u222A',\n    'cupbrcap': '\\u2A48',\n    'cupcap': '\\u2A46',\n    'cupcup': '\\u2A4A',\n    'cupdot': '\\u228D',\n    'cupor': '\\u2A45',\n    'cups': '\\u222A\\uFE00',\n    'curarr': '\\u21B7',\n    'curvearrowright': '\\u21B7',\n    'curarrm': '\\u293C',\n    'curlyvee': '\\u22CE',\n    'cuvee': '\\u22CE',\n    'curlywedge': '\\u22CF',\n    'cuwed': '\\u22CF',\n    'curren': '\\u00A4',\n    'cwint': '\\u2231',\n    'cylcty': '\\u232D',\n    'dHar': '\\u2965',\n    'dagger': '\\u2020',\n    'daleth': '\\u2138',\n    'dash': '\\u2010',\n    'hyphen': '\\u2010',\n    'dbkarow': '\\u290F',\n    'rBarr': '\\u290F',\n    'dcaron': '\\u010F',\n    'dcy': '\\u0434',\n    'ddarr': '\\u21CA',\n    'downdownarrows': '\\u21CA',\n    'ddotseq': '\\u2A77',\n    'eDDot': '\\u2A77',\n    'deg': '\\u00B0',\n    'delta': '\\u03B4',\n    'demptyv': '\\u29B1',\n    'dfisht': '\\u297F',\n    'dfr': '\\uD835\\uDD21',\n    'diamondsuit': '\\u2666',\n    'diams': '\\u2666',\n    'digamma': '\\u03DD',\n    'gammad': '\\u03DD',\n    'disin': '\\u22F2',\n    'div': '\\u00F7',\n    'divide': '\\u00F7',\n    'divideontimes': '\\u22C7',\n    'divonx': '\\u22C7',\n    'djcy': '\\u0452',\n    'dlcorn': '\\u231E',\n    'llcorner': '\\u231E',\n    'dlcrop': '\\u230D',\n    'dollar': '\\u0024',\n    'dopf': '\\uD835\\uDD55',\n    'doteqdot': '\\u2251',\n    'eDot': '\\u2251',\n    'dotminus': '\\u2238',\n    'minusd': '\\u2238',\n    'dotplus': '\\u2214',\n    'plusdo': '\\u2214',\n    'dotsquare': '\\u22A1',\n    'sdotb': '\\u22A1',\n    'drcorn': '\\u231F',\n    'lrcorner': '\\u231F',\n    'drcrop': '\\u230C',\n    'dscr': '\\uD835\\uDCB9',\n    'dscy': '\\u0455',\n    'dsol': '\\u29F6',\n    'dstrok': '\\u0111',\n    'dtdot': '\\u22F1',\n    'dtri': '\\u25BF',\n    'triangledown': '\\u25BF',\n    'dwangle': '\\u29A6',\n    'dzcy': '\\u045F',\n    'dzigrarr': '\\u27FF',\n    'eacute': '\\u00E9',\n    'easter': '\\u2A6E',\n    'ecaron': '\\u011B',\n    'ecir': '\\u2256',\n    'eqcirc': '\\u2256',\n    'ecirc': '\\u00EA',\n    'ecolon': '\\u2255',\n    'eqcolon': '\\u2255',\n    'ecy': '\\u044D',\n    'edot': '\\u0117',\n    'efDot': '\\u2252',\n    'fallingdotseq': '\\u2252',\n    'efr': '\\uD835\\uDD22',\n    'eg': '\\u2A9A',\n    'egrave': '\\u00E8',\n    'egs': '\\u2A96',\n    'eqslantgtr': '\\u2A96',\n    'egsdot': '\\u2A98',\n    'el': '\\u2A99',\n    'elinters': '\\u23E7',\n    'ell': '\\u2113',\n    'els': '\\u2A95',\n    'eqslantless': '\\u2A95',\n    'elsdot': '\\u2A97',\n    'emacr': '\\u0113',\n    'empty': '\\u2205',\n    'emptyset': '\\u2205',\n    'emptyv': '\\u2205',\n    'varnothing': '\\u2205',\n    'emsp13': '\\u2004',\n    'emsp14': '\\u2005',\n    'emsp': '\\u2003',\n    'eng': '\\u014B',\n    'ensp': '\\u2002',\n    'eogon': '\\u0119',\n    'eopf': '\\uD835\\uDD56',\n    'epar': '\\u22D5',\n    'eparsl': '\\u29E3',\n    'eplus': '\\u2A71',\n    'epsi': '\\u03B5',\n    'epsilon': '\\u03B5',\n    'epsiv': '\\u03F5',\n    'straightepsilon': '\\u03F5',\n    'varepsilon': '\\u03F5',\n    'equals': '\\u003D',\n    'equest': '\\u225F',\n    'questeq': '\\u225F',\n    'equivDD': '\\u2A78',\n    'eqvparsl': '\\u29E5',\n    'erDot': '\\u2253',\n    'risingdotseq': '\\u2253',\n    'erarr': '\\u2971',\n    'escr': '\\u212F',\n    'eta': '\\u03B7',\n    'eth': '\\u00F0',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'excl': '\\u0021',\n    'fcy': '\\u0444',\n    'female': '\\u2640',\n    'ffilig': '\\uFB03',\n    'fflig': '\\uFB00',\n    'ffllig': '\\uFB04',\n    'ffr': '\\uD835\\uDD23',\n    'filig': '\\uFB01',\n    'fjlig': '\\u0066\\u006A',\n    'flat': '\\u266D',\n    'fllig': '\\uFB02',\n    'fltns': '\\u25B1',\n    'fnof': '\\u0192',\n    'fopf': '\\uD835\\uDD57',\n    'fork': '\\u22D4',\n    'pitchfork': '\\u22D4',\n    'forkv': '\\u2AD9',\n    'fpartint': '\\u2A0D',\n    'frac12': '\\u00BD',\n    'half': '\\u00BD',\n    'frac13': '\\u2153',\n    'frac14': '\\u00BC',\n    'frac15': '\\u2155',\n    'frac16': '\\u2159',\n    'frac18': '\\u215B',\n    'frac23': '\\u2154',\n    'frac25': '\\u2156',\n    'frac34': '\\u00BE',\n    'frac35': '\\u2157',\n    'frac38': '\\u215C',\n    'frac45': '\\u2158',\n    'frac56': '\\u215A',\n    'frac58': '\\u215D',\n    'frac78': '\\u215E',\n    'frasl': '\\u2044',\n    'frown': '\\u2322',\n    'sfrown': '\\u2322',\n    'fscr': '\\uD835\\uDCBB',\n    'gEl': '\\u2A8C',\n    'gtreqqless': '\\u2A8C',\n    'gacute': '\\u01F5',\n    'gamma': '\\u03B3',\n    'gap': '\\u2A86',\n    'gtrapprox': '\\u2A86',\n    'gbreve': '\\u011F',\n    'gcirc': '\\u011D',\n    'gcy': '\\u0433',\n    'gdot': '\\u0121',\n    'gescc': '\\u2AA9',\n    'gesdot': '\\u2A80',\n    'gesdoto': '\\u2A82',\n    'gesdotol': '\\u2A84',\n    'gesl': '\\u22DB\\uFE00',\n    'gesles': '\\u2A94',\n    'gfr': '\\uD835\\uDD24',\n    'gimel': '\\u2137',\n    'gjcy': '\\u0453',\n    'glE': '\\u2A92',\n    'gla': '\\u2AA5',\n    'glj': '\\u2AA4',\n    'gnE': '\\u2269',\n    'gneqq': '\\u2269',\n    'gnap': '\\u2A8A',\n    'gnapprox': '\\u2A8A',\n    'gne': '\\u2A88',\n    'gneq': '\\u2A88',\n    'gnsim': '\\u22E7',\n    'gopf': '\\uD835\\uDD58',\n    'gscr': '\\u210A',\n    'gsime': '\\u2A8E',\n    'gsiml': '\\u2A90',\n    'gtcc': '\\u2AA7',\n    'gtcir': '\\u2A7A',\n    'gtdot': '\\u22D7',\n    'gtrdot': '\\u22D7',\n    'gtlPar': '\\u2995',\n    'gtquest': '\\u2A7C',\n    'gtrarr': '\\u2978',\n    'gvertneqq': '\\u2269\\uFE00',\n    'gvnE': '\\u2269\\uFE00',\n    'hardcy': '\\u044A',\n    'harrcir': '\\u2948',\n    'harrw': '\\u21AD',\n    'leftrightsquigarrow': '\\u21AD',\n    'hbar': '\\u210F',\n    'hslash': '\\u210F',\n    'planck': '\\u210F',\n    'plankv': '\\u210F',\n    'hcirc': '\\u0125',\n    'hearts': '\\u2665',\n    'heartsuit': '\\u2665',\n    'hellip': '\\u2026',\n    'mldr': '\\u2026',\n    'hercon': '\\u22B9',\n    'hfr': '\\uD835\\uDD25',\n    'hksearow': '\\u2925',\n    'searhk': '\\u2925',\n    'hkswarow': '\\u2926',\n    'swarhk': '\\u2926',\n    'hoarr': '\\u21FF',\n    'homtht': '\\u223B',\n    'hookleftarrow': '\\u21A9',\n    'larrhk': '\\u21A9',\n    'hookrightarrow': '\\u21AA',\n    'rarrhk': '\\u21AA',\n    'hopf': '\\uD835\\uDD59',\n    'horbar': '\\u2015',\n    'hscr': '\\uD835\\uDCBD',\n    'hstrok': '\\u0127',\n    'hybull': '\\u2043',\n    'iacute': '\\u00ED',\n    'icirc': '\\u00EE',\n    'icy': '\\u0438',\n    'iecy': '\\u0435',\n    'iexcl': '\\u00A1',\n    'ifr': '\\uD835\\uDD26',\n    'igrave': '\\u00EC',\n    'iiiint': '\\u2A0C',\n    'qint': '\\u2A0C',\n    'iiint': '\\u222D',\n    'tint': '\\u222D',\n    'iinfin': '\\u29DC',\n    'iiota': '\\u2129',\n    'ijlig': '\\u0133',\n    'imacr': '\\u012B',\n    'imath': '\\u0131',\n    'inodot': '\\u0131',\n    'imof': '\\u22B7',\n    'imped': '\\u01B5',\n    'incare': '\\u2105',\n    'infin': '\\u221E',\n    'infintie': '\\u29DD',\n    'intcal': '\\u22BA',\n    'intercal': '\\u22BA',\n    'intlarhk': '\\u2A17',\n    'intprod': '\\u2A3C',\n    'iprod': '\\u2A3C',\n    'iocy': '\\u0451',\n    'iogon': '\\u012F',\n    'iopf': '\\uD835\\uDD5A',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'iscr': '\\uD835\\uDCBE',\n    'isinE': '\\u22F9',\n    'isindot': '\\u22F5',\n    'isins': '\\u22F4',\n    'isinsv': '\\u22F3',\n    'itilde': '\\u0129',\n    'iukcy': '\\u0456',\n    'iuml': '\\u00EF',\n    'jcirc': '\\u0135',\n    'jcy': '\\u0439',\n    'jfr': '\\uD835\\uDD27',\n    'jmath': '\\u0237',\n    'jopf': '\\uD835\\uDD5B',\n    'jscr': '\\uD835\\uDCBF',\n    'jsercy': '\\u0458',\n    'jukcy': '\\u0454',\n    'kappa': '\\u03BA',\n    'kappav': '\\u03F0',\n    'varkappa': '\\u03F0',\n    'kcedil': '\\u0137',\n    'kcy': '\\u043A',\n    'kfr': '\\uD835\\uDD28',\n    'kgreen': '\\u0138',\n    'khcy': '\\u0445',\n    'kjcy': '\\u045C',\n    'kopf': '\\uD835\\uDD5C',\n    'kscr': '\\uD835\\uDCC0',\n    'lAtail': '\\u291B',\n    'lBarr': '\\u290E',\n    'lEg': '\\u2A8B',\n    'lesseqqgtr': '\\u2A8B',\n    'lHar': '\\u2962',\n    'lacute': '\\u013A',\n    'laemptyv': '\\u29B4',\n    'lambda': '\\u03BB',\n    'langd': '\\u2991',\n    'lap': '\\u2A85',\n    'lessapprox': '\\u2A85',\n    'laquo': '\\u00AB',\n    'larrbfs': '\\u291F',\n    'larrfs': '\\u291D',\n    'larrlp': '\\u21AB',\n    'looparrowleft': '\\u21AB',\n    'larrpl': '\\u2939',\n    'larrsim': '\\u2973',\n    'larrtl': '\\u21A2',\n    'leftarrowtail': '\\u21A2',\n    'lat': '\\u2AAB',\n    'latail': '\\u2919',\n    'late': '\\u2AAD',\n    'lates': '\\u2AAD\\uFE00',\n    'lbarr': '\\u290C',\n    'lbbrk': '\\u2772',\n    'lbrace': '\\u007B',\n    'lcub': '\\u007B',\n    'lbrack': '\\u005B',\n    'lsqb': '\\u005B',\n    'lbrke': '\\u298B',\n    'lbrksld': '\\u298F',\n    'lbrkslu': '\\u298D',\n    'lcaron': '\\u013E',\n    'lcedil': '\\u013C',\n    'lcy': '\\u043B',\n    'ldca': '\\u2936',\n    'ldrdhar': '\\u2967',\n    'ldrushar': '\\u294B',\n    'ldsh': '\\u21B2',\n    'le': '\\u2264',\n    'leq': '\\u2264',\n    'leftleftarrows': '\\u21C7',\n    'llarr': '\\u21C7',\n    'leftthreetimes': '\\u22CB',\n    'lthree': '\\u22CB',\n    'lescc': '\\u2AA8',\n    'lesdot': '\\u2A7F',\n    'lesdoto': '\\u2A81',\n    'lesdotor': '\\u2A83',\n    'lesg': '\\u22DA\\uFE00',\n    'lesges': '\\u2A93',\n    'lessdot': '\\u22D6',\n    'ltdot': '\\u22D6',\n    'lfisht': '\\u297C',\n    'lfr': '\\uD835\\uDD29',\n    'lgE': '\\u2A91',\n    'lharul': '\\u296A',\n    'lhblk': '\\u2584',\n    'ljcy': '\\u0459',\n    'llhard': '\\u296B',\n    'lltri': '\\u25FA',\n    'lmidot': '\\u0140',\n    'lmoust': '\\u23B0',\n    'lmoustache': '\\u23B0',\n    'lnE': '\\u2268',\n    'lneqq': '\\u2268',\n    'lnap': '\\u2A89',\n    'lnapprox': '\\u2A89',\n    'lne': '\\u2A87',\n    'lneq': '\\u2A87',\n    'lnsim': '\\u22E6',\n    'loang': '\\u27EC',\n    'loarr': '\\u21FD',\n    'longmapsto': '\\u27FC',\n    'xmap': '\\u27FC',\n    'looparrowright': '\\u21AC',\n    'rarrlp': '\\u21AC',\n    'lopar': '\\u2985',\n    'lopf': '\\uD835\\uDD5D',\n    'loplus': '\\u2A2D',\n    'lotimes': '\\u2A34',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lozenge': '\\u25CA',\n    'lpar': '\\u0028',\n    'lparlt': '\\u2993',\n    'lrhard': '\\u296D',\n    'lrm': '\\u200E',\n    'lrtri': '\\u22BF',\n    'lsaquo': '\\u2039',\n    'lscr': '\\uD835\\uDCC1',\n    'lsime': '\\u2A8D',\n    'lsimg': '\\u2A8F',\n    'lsquor': '\\u201A',\n    'sbquo': '\\u201A',\n    'lstrok': '\\u0142',\n    'ltcc': '\\u2AA6',\n    'ltcir': '\\u2A79',\n    'ltimes': '\\u22C9',\n    'ltlarr': '\\u2976',\n    'ltquest': '\\u2A7B',\n    'ltrPar': '\\u2996',\n    'ltri': '\\u25C3',\n    'triangleleft': '\\u25C3',\n    'lurdshar': '\\u294A',\n    'luruhar': '\\u2966',\n    'lvertneqq': '\\u2268\\uFE00',\n    'lvnE': '\\u2268\\uFE00',\n    'mDDot': '\\u223A',\n    'macr': '\\u00AF',\n    'strns': '\\u00AF',\n    'male': '\\u2642',\n    'malt': '\\u2720',\n    'maltese': '\\u2720',\n    'marker': '\\u25AE',\n    'mcomma': '\\u2A29',\n    'mcy': '\\u043C',\n    'mdash': '\\u2014',\n    'mfr': '\\uD835\\uDD2A',\n    'mho': '\\u2127',\n    'micro': '\\u00B5',\n    'midcir': '\\u2AF0',\n    'minus': '\\u2212',\n    'minusdu': '\\u2A2A',\n    'mlcp': '\\u2ADB',\n    'models': '\\u22A7',\n    'mopf': '\\uD835\\uDD5E',\n    'mscr': '\\uD835\\uDCC2',\n    'mu': '\\u03BC',\n    'multimap': '\\u22B8',\n    'mumap': '\\u22B8',\n    'nGg': '\\u22D9\\u0338',\n    'nGt': '\\u226B\\u20D2',\n    'nLeftarrow': '\\u21CD',\n    'nlArr': '\\u21CD',\n    'nLeftrightarrow': '\\u21CE',\n    'nhArr': '\\u21CE',\n    'nLl': '\\u22D8\\u0338',\n    'nLt': '\\u226A\\u20D2',\n    'nRightarrow': '\\u21CF',\n    'nrArr': '\\u21CF',\n    'nVDash': '\\u22AF',\n    'nVdash': '\\u22AE',\n    'nacute': '\\u0144',\n    'nang': '\\u2220\\u20D2',\n    'napE': '\\u2A70\\u0338',\n    'napid': '\\u224B\\u0338',\n    'napos': '\\u0149',\n    'natur': '\\u266E',\n    'natural': '\\u266E',\n    'ncap': '\\u2A43',\n    'ncaron': '\\u0148',\n    'ncedil': '\\u0146',\n    'ncongdot': '\\u2A6D\\u0338',\n    'ncup': '\\u2A42',\n    'ncy': '\\u043D',\n    'ndash': '\\u2013',\n    'neArr': '\\u21D7',\n    'nearhk': '\\u2924',\n    'nedot': '\\u2250\\u0338',\n    'nesear': '\\u2928',\n    'toea': '\\u2928',\n    'nfr': '\\uD835\\uDD2B',\n    'nharr': '\\u21AE',\n    'nleftrightarrow': '\\u21AE',\n    'nhpar': '\\u2AF2',\n    'nis': '\\u22FC',\n    'nisd': '\\u22FA',\n    'njcy': '\\u045A',\n    'nlE': '\\u2266\\u0338',\n    'nleqq': '\\u2266\\u0338',\n    'nlarr': '\\u219A',\n    'nleftarrow': '\\u219A',\n    'nldr': '\\u2025',\n    'nopf': '\\uD835\\uDD5F',\n    'not': '\\u00AC',\n    'notinE': '\\u22F9\\u0338',\n    'notindot': '\\u22F5\\u0338',\n    'notinvb': '\\u22F7',\n    'notinvc': '\\u22F6',\n    'notnivb': '\\u22FE',\n    'notnivc': '\\u22FD',\n    'nparsl': '\\u2AFD\\u20E5',\n    'npart': '\\u2202\\u0338',\n    'npolint': '\\u2A14',\n    'nrarr': '\\u219B',\n    'nrightarrow': '\\u219B',\n    'nrarrc': '\\u2933\\u0338',\n    'nrarrw': '\\u219D\\u0338',\n    'nscr': '\\uD835\\uDCC3',\n    'nsub': '\\u2284',\n    'nsubE': '\\u2AC5\\u0338',\n    'nsubseteqq': '\\u2AC5\\u0338',\n    'nsup': '\\u2285',\n    'nsupE': '\\u2AC6\\u0338',\n    'nsupseteqq': '\\u2AC6\\u0338',\n    'ntilde': '\\u00F1',\n    'nu': '\\u03BD',\n    'num': '\\u0023',\n    'numero': '\\u2116',\n    'numsp': '\\u2007',\n    'nvDash': '\\u22AD',\n    'nvHarr': '\\u2904',\n    'nvap': '\\u224D\\u20D2',\n    'nvdash': '\\u22AC',\n    'nvge': '\\u2265\\u20D2',\n    'nvgt': '\\u003E\\u20D2',\n    'nvinfin': '\\u29DE',\n    'nvlArr': '\\u2902',\n    'nvle': '\\u2264\\u20D2',\n    'nvlt': '\\u003C\\u20D2',\n    'nvltrie': '\\u22B4\\u20D2',\n    'nvrArr': '\\u2903',\n    'nvrtrie': '\\u22B5\\u20D2',\n    'nvsim': '\\u223C\\u20D2',\n    'nwArr': '\\u21D6',\n    'nwarhk': '\\u2923',\n    'nwnear': '\\u2927',\n    'oacute': '\\u00F3',\n    'ocirc': '\\u00F4',\n    'ocy': '\\u043E',\n    'odblac': '\\u0151',\n    'odiv': '\\u2A38',\n    'odsold': '\\u29BC',\n    'oelig': '\\u0153',\n    'ofcir': '\\u29BF',\n    'ofr': '\\uD835\\uDD2C',\n    'ogon': '\\u02DB',\n    'ograve': '\\u00F2',\n    'ogt': '\\u29C1',\n    'ohbar': '\\u29B5',\n    'olcir': '\\u29BE',\n    'olcross': '\\u29BB',\n    'olt': '\\u29C0',\n    'omacr': '\\u014D',\n    'omega': '\\u03C9',\n    'omicron': '\\u03BF',\n    'omid': '\\u29B6',\n    'oopf': '\\uD835\\uDD60',\n    'opar': '\\u29B7',\n    'operp': '\\u29B9',\n    'or': '\\u2228',\n    'vee': '\\u2228',\n    'ord': '\\u2A5D',\n    'order': '\\u2134',\n    'orderof': '\\u2134',\n    'oscr': '\\u2134',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'origof': '\\u22B6',\n    'oror': '\\u2A56',\n    'orslope': '\\u2A57',\n    'orv': '\\u2A5B',\n    'oslash': '\\u00F8',\n    'osol': '\\u2298',\n    'otilde': '\\u00F5',\n    'otimesas': '\\u2A36',\n    'ouml': '\\u00F6',\n    'ovbar': '\\u233D',\n    'para': '\\u00B6',\n    'parsim': '\\u2AF3',\n    'parsl': '\\u2AFD',\n    'pcy': '\\u043F',\n    'percnt': '\\u0025',\n    'period': '\\u002E',\n    'permil': '\\u2030',\n    'pertenk': '\\u2031',\n    'pfr': '\\uD835\\uDD2D',\n    'phi': '\\u03C6',\n    'phiv': '\\u03D5',\n    'straightphi': '\\u03D5',\n    'varphi': '\\u03D5',\n    'phone': '\\u260E',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'varpi': '\\u03D6',\n    'planckh': '\\u210E',\n    'plus': '\\u002B',\n    'plusacir': '\\u2A23',\n    'pluscir': '\\u2A22',\n    'plusdu': '\\u2A25',\n    'pluse': '\\u2A72',\n    'plussim': '\\u2A26',\n    'plustwo': '\\u2A27',\n    'pointint': '\\u2A15',\n    'popf': '\\uD835\\uDD61',\n    'pound': '\\u00A3',\n    'prE': '\\u2AB3',\n    'prap': '\\u2AB7',\n    'precapprox': '\\u2AB7',\n    'precnapprox': '\\u2AB9',\n    'prnap': '\\u2AB9',\n    'precneqq': '\\u2AB5',\n    'prnE': '\\u2AB5',\n    'precnsim': '\\u22E8',\n    'prnsim': '\\u22E8',\n    'prime': '\\u2032',\n    'profalar': '\\u232E',\n    'profline': '\\u2312',\n    'profsurf': '\\u2313',\n    'prurel': '\\u22B0',\n    'pscr': '\\uD835\\uDCC5',\n    'psi': '\\u03C8',\n    'puncsp': '\\u2008',\n    'qfr': '\\uD835\\uDD2E',\n    'qopf': '\\uD835\\uDD62',\n    'qprime': '\\u2057',\n    'qscr': '\\uD835\\uDCC6',\n    'quatint': '\\u2A16',\n    'quest': '\\u003F',\n    'rAtail': '\\u291C',\n    'rHar': '\\u2964',\n    'race': '\\u223D\\u0331',\n    'racute': '\\u0155',\n    'raemptyv': '\\u29B3',\n    'rangd': '\\u2992',\n    'range': '\\u29A5',\n    'raquo': '\\u00BB',\n    'rarrap': '\\u2975',\n    'rarrbfs': '\\u2920',\n    'rarrc': '\\u2933',\n    'rarrfs': '\\u291E',\n    'rarrpl': '\\u2945',\n    'rarrsim': '\\u2974',\n    'rarrtl': '\\u21A3',\n    'rightarrowtail': '\\u21A3',\n    'rarrw': '\\u219D',\n    'rightsquigarrow': '\\u219D',\n    'ratail': '\\u291A',\n    'ratio': '\\u2236',\n    'rbbrk': '\\u2773',\n    'rbrace': '\\u007D',\n    'rcub': '\\u007D',\n    'rbrack': '\\u005D',\n    'rsqb': '\\u005D',\n    'rbrke': '\\u298C',\n    'rbrksld': '\\u298E',\n    'rbrkslu': '\\u2990',\n    'rcaron': '\\u0159',\n    'rcedil': '\\u0157',\n    'rcy': '\\u0440',\n    'rdca': '\\u2937',\n    'rdldhar': '\\u2969',\n    'rdsh': '\\u21B3',\n    'rect': '\\u25AD',\n    'rfisht': '\\u297D',\n    'rfr': '\\uD835\\uDD2F',\n    'rharul': '\\u296C',\n    'rho': '\\u03C1',\n    'rhov': '\\u03F1',\n    'varrho': '\\u03F1',\n    'rightrightarrows': '\\u21C9',\n    'rrarr': '\\u21C9',\n    'rightthreetimes': '\\u22CC',\n    'rthree': '\\u22CC',\n    'ring': '\\u02DA',\n    'rlm': '\\u200F',\n    'rmoust': '\\u23B1',\n    'rmoustache': '\\u23B1',\n    'rnmid': '\\u2AEE',\n    'roang': '\\u27ED',\n    'roarr': '\\u21FE',\n    'ropar': '\\u2986',\n    'ropf': '\\uD835\\uDD63',\n    'roplus': '\\u2A2E',\n    'rotimes': '\\u2A35',\n    'rpar': '\\u0029',\n    'rpargt': '\\u2994',\n    'rppolint': '\\u2A12',\n    'rsaquo': '\\u203A',\n    'rscr': '\\uD835\\uDCC7',\n    'rtimes': '\\u22CA',\n    'rtri': '\\u25B9',\n    'triangleright': '\\u25B9',\n    'rtriltri': '\\u29CE',\n    'ruluhar': '\\u2968',\n    'rx': '\\u211E',\n    'sacute': '\\u015B',\n    'scE': '\\u2AB4',\n    'scap': '\\u2AB8',\n    'succapprox': '\\u2AB8',\n    'scaron': '\\u0161',\n    'scedil': '\\u015F',\n    'scirc': '\\u015D',\n    'scnE': '\\u2AB6',\n    'succneqq': '\\u2AB6',\n    'scnap': '\\u2ABA',\n    'succnapprox': '\\u2ABA',\n    'scnsim': '\\u22E9',\n    'succnsim': '\\u22E9',\n    'scpolint': '\\u2A13',\n    'scy': '\\u0441',\n    'sdot': '\\u22C5',\n    'sdote': '\\u2A66',\n    'seArr': '\\u21D8',\n    'sect': '\\u00A7',\n    'semi': '\\u003B',\n    'seswar': '\\u2929',\n    'tosa': '\\u2929',\n    'sext': '\\u2736',\n    'sfr': '\\uD835\\uDD30',\n    'sharp': '\\u266F',\n    'shchcy': '\\u0449',\n    'shcy': '\\u0448',\n    'shy': '\\u00AD',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sigmav': '\\u03C2',\n    'varsigma': '\\u03C2',\n    'simdot': '\\u2A6A',\n    'simg': '\\u2A9E',\n    'simgE': '\\u2AA0',\n    'siml': '\\u2A9D',\n    'simlE': '\\u2A9F',\n    'simne': '\\u2246',\n    'simplus': '\\u2A24',\n    'simrarr': '\\u2972',\n    'smashp': '\\u2A33',\n    'smeparsl': '\\u29E4',\n    'smile': '\\u2323',\n    'ssmile': '\\u2323',\n    'smt': '\\u2AAA',\n    'smte': '\\u2AAC',\n    'smtes': '\\u2AAC\\uFE00',\n    'softcy': '\\u044C',\n    'sol': '\\u002F',\n    'solb': '\\u29C4',\n    'solbar': '\\u233F',\n    'sopf': '\\uD835\\uDD64',\n    'spades': '\\u2660',\n    'spadesuit': '\\u2660',\n    'sqcaps': '\\u2293\\uFE00',\n    'sqcups': '\\u2294\\uFE00',\n    'sscr': '\\uD835\\uDCC8',\n    'star': '\\u2606',\n    'sub': '\\u2282',\n    'subset': '\\u2282',\n    'subE': '\\u2AC5',\n    'subseteqq': '\\u2AC5',\n    'subdot': '\\u2ABD',\n    'subedot': '\\u2AC3',\n    'submult': '\\u2AC1',\n    'subnE': '\\u2ACB',\n    'subsetneqq': '\\u2ACB',\n    'subne': '\\u228A',\n    'subsetneq': '\\u228A',\n    'subplus': '\\u2ABF',\n    'subrarr': '\\u2979',\n    'subsim': '\\u2AC7',\n    'subsub': '\\u2AD5',\n    'subsup': '\\u2AD3',\n    'sung': '\\u266A',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supE': '\\u2AC6',\n    'supseteqq': '\\u2AC6',\n    'supdot': '\\u2ABE',\n    'supdsub': '\\u2AD8',\n    'supedot': '\\u2AC4',\n    'suphsol': '\\u27C9',\n    'suphsub': '\\u2AD7',\n    'suplarr': '\\u297B',\n    'supmult': '\\u2AC2',\n    'supnE': '\\u2ACC',\n    'supsetneqq': '\\u2ACC',\n    'supne': '\\u228B',\n    'supsetneq': '\\u228B',\n    'supplus': '\\u2AC0',\n    'supsim': '\\u2AC8',\n    'supsub': '\\u2AD4',\n    'supsup': '\\u2AD6',\n    'swArr': '\\u21D9',\n    'swnwar': '\\u292A',\n    'szlig': '\\u00DF',\n    'target': '\\u2316',\n    'tau': '\\u03C4',\n    'tcaron': '\\u0165',\n    'tcedil': '\\u0163',\n    'tcy': '\\u0442',\n    'telrec': '\\u2315',\n    'tfr': '\\uD835\\uDD31',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thetav': '\\u03D1',\n    'vartheta': '\\u03D1',\n    'thorn': '\\u00FE',\n    'times': '\\u00D7',\n    'timesbar': '\\u2A31',\n    'timesd': '\\u2A30',\n    'topbot': '\\u2336',\n    'topcir': '\\u2AF1',\n    'topf': '\\uD835\\uDD65',\n    'topfork': '\\u2ADA',\n    'tprime': '\\u2034',\n    'triangle': '\\u25B5',\n    'utri': '\\u25B5',\n    'triangleq': '\\u225C',\n    'trie': '\\u225C',\n    'tridot': '\\u25EC',\n    'triminus': '\\u2A3A',\n    'triplus': '\\u2A39',\n    'trisb': '\\u29CD',\n    'tritime': '\\u2A3B',\n    'trpezium': '\\u23E2',\n    'tscr': '\\uD835\\uDCC9',\n    'tscy': '\\u0446',\n    'tshcy': '\\u045B',\n    'tstrok': '\\u0167',\n    'uHar': '\\u2963',\n    'uacute': '\\u00FA',\n    'ubrcy': '\\u045E',\n    'ubreve': '\\u016D',\n    'ucirc': '\\u00FB',\n    'ucy': '\\u0443',\n    'udblac': '\\u0171',\n    'ufisht': '\\u297E',\n    'ufr': '\\uD835\\uDD32',\n    'ugrave': '\\u00F9',\n    'uhblk': '\\u2580',\n    'ulcorn': '\\u231C',\n    'ulcorner': '\\u231C',\n    'ulcrop': '\\u230F',\n    'ultri': '\\u25F8',\n    'umacr': '\\u016B',\n    'uogon': '\\u0173',\n    'uopf': '\\uD835\\uDD66',\n    'upsi': '\\u03C5',\n    'upsilon': '\\u03C5',\n    'upuparrows': '\\u21C8',\n    'uuarr': '\\u21C8',\n    'urcorn': '\\u231D',\n    'urcorner': '\\u231D',\n    'urcrop': '\\u230E',\n    'uring': '\\u016F',\n    'urtri': '\\u25F9',\n    'uscr': '\\uD835\\uDCCA',\n    'utdot': '\\u22F0',\n    'utilde': '\\u0169',\n    'uuml': '\\u00FC',\n    'uwangle': '\\u29A7',\n    'vBar': '\\u2AE8',\n    'vBarv': '\\u2AE9',\n    'vangrt': '\\u299C',\n    'varsubsetneq': '\\u228A\\uFE00',\n    'vsubne': '\\u228A\\uFE00',\n    'varsubsetneqq': '\\u2ACB\\uFE00',\n    'vsubnE': '\\u2ACB\\uFE00',\n    'varsupsetneq': '\\u228B\\uFE00',\n    'vsupne': '\\u228B\\uFE00',\n    'varsupsetneqq': '\\u2ACC\\uFE00',\n    'vsupnE': '\\u2ACC\\uFE00',\n    'vcy': '\\u0432',\n    'veebar': '\\u22BB',\n    'veeeq': '\\u225A',\n    'vellip': '\\u22EE',\n    'vfr': '\\uD835\\uDD33',\n    'vopf': '\\uD835\\uDD67',\n    'vscr': '\\uD835\\uDCCB',\n    'vzigzag': '\\u299A',\n    'wcirc': '\\u0175',\n    'wedbar': '\\u2A5F',\n    'wedgeq': '\\u2259',\n    'weierp': '\\u2118',\n    'wp': '\\u2118',\n    'wfr': '\\uD835\\uDD34',\n    'wopf': '\\uD835\\uDD68',\n    'wscr': '\\uD835\\uDCCC',\n    'xfr': '\\uD835\\uDD35',\n    'xi': '\\u03BE',\n    'xnis': '\\u22FB',\n    'xopf': '\\uD835\\uDD69',\n    'xscr': '\\uD835\\uDCCD',\n    'yacute': '\\u00FD',\n    'yacy': '\\u044F',\n    'ycirc': '\\u0177',\n    'ycy': '\\u044B',\n    'yen': '\\u00A5',\n    'yfr': '\\uD835\\uDD36',\n    'yicy': '\\u0457',\n    'yopf': '\\uD835\\uDD6A',\n    'yscr': '\\uD835\\uDCCE',\n    'yucy': '\\u044E',\n    'yuml': '\\u00FF',\n    'zacute': '\\u017A',\n    'zcaron': '\\u017E',\n    'zcy': '\\u0437',\n    'zdot': '\\u017C',\n    'zeta': '\\u03B6',\n    'zfr': '\\uD835\\uDD37',\n    'zhcy': '\\u0436',\n    'zigrarr': '\\u21DD',\n    'zopf': '\\uD835\\uDD6B',\n    'zscr': '\\uD835\\uDCCF',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C'\n};\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nconst NGSP_UNICODE = '\\uE500';\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass TokenError extends ParseError {\n    constructor(errorMsg, tokenType, span) {\n        super(span, errorMsg);\n        this.tokenType = tokenType;\n    }\n}\nclass TokenizeResult {\n    constructor(tokens, errors, nonNormalizedIcuExpressions) {\n        this.tokens = tokens;\n        this.errors = errors;\n        this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\n    }\n}\nfunction tokenize(source, url, getTagDefinition, options = {}) {\n    const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n    tokenizer.tokenize();\n    return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n    return `Unexpected character \"${char}\"`;\n}\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\nfunction _unparsableEntityErrorMsg(type, entityStr) {\n    return `Unable to parse entity \"${entityStr}\" - ${type} character reference entities must end with \";\"`;\n}\nvar CharacterReferenceType;\n(function (CharacterReferenceType) {\n    CharacterReferenceType[\"HEX\"] = \"hexadecimal\";\n    CharacterReferenceType[\"DEC\"] = \"decimal\";\n})(CharacterReferenceType || (CharacterReferenceType = {}));\nclass _ControlFlowError {\n    constructor(error) {\n        this.error = error;\n    }\n}\n// See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\nclass _Tokenizer {\n    /**\n     * @param _file The html source file being tokenized.\n     * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n     * @param options Configuration of the tokenization.\n     */\n    constructor(_file, _getTagDefinition, options) {\n        this._getTagDefinition = _getTagDefinition;\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this.nonNormalizedIcuExpressions = [];\n        this._tokenizeIcu = options.tokenizeExpansionForms || false;\n        this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        this._leadingTriviaCodePoints =\n            options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n        const range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };\n        this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\n            new PlainCharacterCursor(_file, range);\n        this._preserveLineEndings = options.preserveLineEndings || false;\n        this._escapedString = options.escapedString || false;\n        this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n        try {\n            this._cursor.init();\n        }\n        catch (e) {\n            this.handleError(e);\n        }\n    }\n    _processCarriageReturns(content) {\n        if (this._preserveLineEndings) {\n            return content;\n        }\n        // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    }\n    tokenize() {\n        while (this._cursor.peek() !== $EOF) {\n            const start = this._cursor.clone();\n            try {\n                if (this._attemptCharCode($LT)) {\n                    if (this._attemptCharCode($BANG)) {\n                        if (this._attemptCharCode($LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode($MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode($SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while\n                    // the premature end of an interpolation is given by the start of a new HTML element.\n                    this._consumeWithInterpolation(5 /* TokenType.TEXT */, 8 /* TokenType.INTERPOLATION */, () => this._isTextEnd(), () => this._isTagStart());\n                }\n            }\n            catch (e) {\n                this.handleError(e);\n            }\n        }\n        this._beginToken(24 /* TokenType.EOF */);\n        this._endToken([]);\n    }\n    /**\n     * @returns whether an ICU token has been created\n     * @internal\n     */\n    _tokenizeExpansionForm() {\n        if (this.isExpansionFormStart()) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._cursor.peek() === $RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    }\n    _beginToken(type, start = this._cursor.clone()) {\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    }\n    _endToken(parts, end) {\n        if (this._currentTokenStart === null) {\n            throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));\n        }\n        if (this._currentTokenType === null) {\n            throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));\n        }\n        const token = {\n            type: this._currentTokenType,\n            parts,\n            sourceSpan: (end !== null && end !== void 0 ? end : this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints),\n        };\n        this.tokens.push(token);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return token;\n    }\n    _createError(msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n        }\n        const error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return new _ControlFlowError(error);\n    }\n    handleError(e) {\n        if (e instanceof CursorError) {\n            e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n        }\n        if (e instanceof _ControlFlowError) {\n            this.errors.push(e.error);\n        }\n        else {\n            throw e;\n        }\n    }\n    _attemptCharCode(charCode) {\n        if (this._cursor.peek() === charCode) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    }\n    _attemptCharCodeCaseInsensitive(charCode) {\n        if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    }\n    _requireCharCode(charCode) {\n        const location = this._cursor.clone();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    }\n    _attemptStr(chars) {\n        const len = chars.length;\n        if (this._cursor.charsLeft() < len) {\n            return false;\n        }\n        const initialPosition = this._cursor.clone();\n        for (let i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._cursor = initialPosition;\n                return false;\n            }\n        }\n        return true;\n    }\n    _attemptStrCaseInsensitive(chars) {\n        for (let i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _requireStr(chars) {\n        const location = this._cursor.clone();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    }\n    _attemptCharCodeUntilFn(predicate) {\n        while (!predicate(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n    }\n    _requireCharCodeUntilFn(predicate, len) {\n        const start = this._cursor.clone();\n        this._attemptCharCodeUntilFn(predicate);\n        if (this._cursor.diff(start) < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n    }\n    _attemptUntilChar(char) {\n        while (this._cursor.peek() !== char) {\n            this._cursor.advance();\n        }\n    }\n    _readChar() {\n        // Don't rely upon reading directly from `_input` as the actual char value\n        // may have been generated from an escape sequence.\n        const char = String.fromCodePoint(this._cursor.peek());\n        this._cursor.advance();\n        return char;\n    }\n    _consumeEntity(textTokenType) {\n        this._beginToken(9 /* TokenType.ENCODED_ENTITY */);\n        const start = this._cursor.clone();\n        this._cursor.advance();\n        if (this._attemptCharCode($HASH)) {\n            const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n            const codeStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                // Advance cursor to include the peeked character in the string provided to the error\n                // message.\n                this._cursor.advance();\n                const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n                throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());\n            }\n            const strNum = this._cursor.getChars(codeStart);\n            this._cursor.advance();\n            try {\n                const charCode = parseInt(strNum, isHex ? 16 : 10);\n                this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);\n            }\n            catch (_a) {\n                throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n            }\n        }\n        else {\n            const nameStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                // No semicolon was found so abort the encoded entity token that was in progress, and treat\n                // this as a text token\n                this._beginToken(textTokenType, start);\n                this._cursor = nameStart;\n                this._endToken(['&']);\n            }\n            else {\n                const name = this._cursor.getChars(nameStart);\n                this._cursor.advance();\n                const char = NAMED_ENTITIES[name];\n                if (!char) {\n                    throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n                }\n                this._endToken([char, `&${name};`]);\n            }\n        }\n    }\n    _consumeRawText(consumeEntities, endMarkerPredicate) {\n        this._beginToken(consumeEntities ? 6 /* TokenType.ESCAPABLE_RAW_TEXT */ : 7 /* TokenType.RAW_TEXT */);\n        const parts = [];\n        while (true) {\n            const tagCloseStart = this._cursor.clone();\n            const foundEndMarker = endMarkerPredicate();\n            this._cursor = tagCloseStart;\n            if (foundEndMarker) {\n                break;\n            }\n            if (consumeEntities && this._cursor.peek() === $AMPERSAND) {\n                this._endToken([this._processCarriageReturns(parts.join(''))]);\n                parts.length = 0;\n                this._consumeEntity(6 /* TokenType.ESCAPABLE_RAW_TEXT */);\n                this._beginToken(6 /* TokenType.ESCAPABLE_RAW_TEXT */);\n            }\n            else {\n                parts.push(this._readChar());\n            }\n        }\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n    _consumeComment(start) {\n        this._beginToken(10 /* TokenType.COMMENT_START */, start);\n        this._requireCharCode($MINUS);\n        this._endToken([]);\n        this._consumeRawText(false, () => this._attemptStr('-->'));\n        this._beginToken(11 /* TokenType.COMMENT_END */);\n        this._requireStr('-->');\n        this._endToken([]);\n    }\n    _consumeCdata(start) {\n        this._beginToken(12 /* TokenType.CDATA_START */, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        this._consumeRawText(false, () => this._attemptStr(']]>'));\n        this._beginToken(13 /* TokenType.CDATA_END */);\n        this._requireStr(']]>');\n        this._endToken([]);\n    }\n    _consumeDocType(start) {\n        this._beginToken(18 /* TokenType.DOC_TYPE */, start);\n        const contentStart = this._cursor.clone();\n        this._attemptUntilChar($GT);\n        const content = this._cursor.getChars(contentStart);\n        this._cursor.advance();\n        this._endToken([content]);\n    }\n    _consumePrefixAndName() {\n        const nameOrPrefixStart = this._cursor.clone();\n        let prefix = '';\n        while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n        let nameStart;\n        if (this._cursor.peek() === $COLON) {\n            prefix = this._cursor.getChars(nameOrPrefixStart);\n            this._cursor.advance();\n            nameStart = this._cursor.clone();\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n        const name = this._cursor.getChars(nameStart);\n        return [prefix, name];\n    }\n    _consumeTagOpen(start) {\n        let tagName;\n        let prefix;\n        let openTagToken;\n        try {\n            if (!isAsciiLetter(this._cursor.peek())) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n            }\n            openTagToken = this._consumeTagOpenStart(start);\n            prefix = openTagToken.parts[0];\n            tagName = openTagToken.parts[1];\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT &&\n                this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode($EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (e) {\n            if (e instanceof _ControlFlowError) {\n                if (openTagToken) {\n                    // We errored before we could close the opening tag, so it is incomplete.\n                    openTagToken.type = 4 /* TokenType.INCOMPLETE_TAG_OPEN */;\n                }\n                else {\n                    // When the start tag is invalid, assume we want a \"<\" as text.\n                    // Back to back text tokens are merged at the end.\n                    this._beginToken(5 /* TokenType.TEXT */, start);\n                    this._endToken(['<']);\n                }\n                return;\n            }\n            throw e;\n        }\n        const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n        if (contentTokenType === exports.TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, false);\n        }\n        else if (contentTokenType === exports.TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, true);\n        }\n    }\n    _consumeRawTextWithTagClose(prefix, tagName, consumeEntities) {\n        this._consumeRawText(consumeEntities, () => {\n            if (!this._attemptCharCode($LT))\n                return false;\n            if (!this._attemptCharCode($SLASH))\n                return false;\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!this._attemptStrCaseInsensitive(tagName))\n                return false;\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            return this._attemptCharCode($GT);\n        });\n        this._beginToken(3 /* TokenType.TAG_CLOSE */);\n        this._requireCharCodeUntilFn(code => code === $GT, 3);\n        this._cursor.advance(); // Consume the `>`\n        this._endToken([prefix, tagName]);\n    }\n    _consumeTagOpenStart(start) {\n        this._beginToken(0 /* TokenType.TAG_OPEN_START */, start);\n        const parts = this._consumePrefixAndName();\n        return this._endToken(parts);\n    }\n    _consumeAttributeName() {\n        const attrNameStart = this._cursor.peek();\n        if (attrNameStart === $SQ || attrNameStart === $DQ) {\n            throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n        }\n        this._beginToken(14 /* TokenType.ATTR_NAME */);\n        const prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    }\n    _consumeAttributeValue() {\n        if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n            const quoteChar = this._cursor.peek();\n            this._consumeQuote(quoteChar);\n            // In an attribute then end of the attribute value and the premature end to an interpolation\n            // are both triggered by the `quoteChar`.\n            const endPredicate = () => this._cursor.peek() === quoteChar;\n            this._consumeWithInterpolation(16 /* TokenType.ATTR_VALUE_TEXT */, 17 /* TokenType.ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);\n            this._consumeQuote(quoteChar);\n        }\n        else {\n            const endPredicate = () => isNameEnd(this._cursor.peek());\n            this._consumeWithInterpolation(16 /* TokenType.ATTR_VALUE_TEXT */, 17 /* TokenType.ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);\n        }\n    }\n    _consumeQuote(quoteChar) {\n        this._beginToken(15 /* TokenType.ATTR_QUOTE */);\n        this._requireCharCode(quoteChar);\n        this._endToken([String.fromCodePoint(quoteChar)]);\n    }\n    _consumeTagOpenEnd() {\n        const tokenType = this._attemptCharCode($SLASH) ? 2 /* TokenType.TAG_OPEN_END_VOID */ : 1 /* TokenType.TAG_OPEN_END */;\n        this._beginToken(tokenType);\n        this._requireCharCode($GT);\n        this._endToken([]);\n    }\n    _consumeTagClose(start) {\n        this._beginToken(3 /* TokenType.TAG_CLOSE */, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        const prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(prefixAndName);\n    }\n    _consumeExpansionFormStart() {\n        this._beginToken(19 /* TokenType.EXPANSION_FORM_START */);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(19 /* TokenType.EXPANSION_FORM_START */);\n        this._beginToken(7 /* TokenType.RAW_TEXT */);\n        const condition = this._readUntil($COMMA);\n        const normalizedCondition = this._processCarriageReturns(condition);\n        if (this._i18nNormalizeLineEndingsInICUs) {\n            // We explicitly want to normalize line endings for this text.\n            this._endToken([normalizedCondition]);\n        }\n        else {\n            // We are not normalizing line endings.\n            const conditionToken = this._endToken([condition]);\n            if (normalizedCondition !== condition) {\n                this.nonNormalizedIcuExpressions.push(conditionToken);\n            }\n        }\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(7 /* TokenType.RAW_TEXT */);\n        const type = this._readUntil($COMMA);\n        this._endToken([type]);\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    }\n    _consumeExpansionCaseStart() {\n        this._beginToken(20 /* TokenType.EXPANSION_CASE_VALUE */);\n        const value = this._readUntil($LBRACE).trim();\n        this._endToken([value]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(21 /* TokenType.EXPANSION_CASE_EXP_START */);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(21 /* TokenType.EXPANSION_CASE_EXP_START */);\n    }\n    _consumeExpansionCaseEnd() {\n        this._beginToken(22 /* TokenType.EXPANSION_CASE_EXP_END */);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    }\n    _consumeExpansionFormEnd() {\n        this._beginToken(23 /* TokenType.EXPANSION_FORM_END */);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    }\n    /**\n     * Consume a string that may contain interpolation expressions.\n     *\n     * The first token consumed will be of `tokenType` and then there will be alternating\n     * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.\n     *\n     * If an interpolation token ends prematurely it will have no end marker in its `parts` array.\n     *\n     * @param textTokenType the kind of tokens to interleave around interpolation tokens.\n     * @param interpolationTokenType the kind of tokens that contain interpolation.\n     * @param endPredicate a function that should return true when we should stop consuming.\n     * @param endInterpolation a function that should return true if there is a premature end to an\n     *     interpolation expression - i.e. before we get to the normal interpolation closing marker.\n     */\n    _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {\n        this._beginToken(textTokenType);\n        const parts = [];\n        while (!endPredicate()) {\n            const current = this._cursor.clone();\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                this._endToken([this._processCarriageReturns(parts.join(''))], current);\n                parts.length = 0;\n                this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n                this._beginToken(textTokenType);\n            }\n            else if (this._cursor.peek() === $AMPERSAND) {\n                this._endToken([this._processCarriageReturns(parts.join(''))]);\n                parts.length = 0;\n                this._consumeEntity(textTokenType);\n                this._beginToken(textTokenType);\n            }\n            else {\n                parts.push(this._readChar());\n            }\n        }\n        // It is possible that an interpolation was started but not ended inside this text token.\n        // Make sure that we reset the state of the lexer correctly.\n        this._inInterpolation = false;\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n    /**\n     * Consume a block of text that has been interpreted as an Angular interpolation.\n     *\n     * @param interpolationTokenType the type of the interpolation token to generate.\n     * @param interpolationStart a cursor that points to the start of this interpolation.\n     * @param prematureEndPredicate a function that should return true if the next characters indicate\n     *     an end to the interpolation before its normal closing marker.\n     */\n    _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {\n        const parts = [];\n        this._beginToken(interpolationTokenType, interpolationStart);\n        parts.push(this._interpolationConfig.start);\n        // Find the end of the interpolation, ignoring content inside quotes.\n        const expressionStart = this._cursor.clone();\n        let inQuote = null;\n        let inComment = false;\n        while (this._cursor.peek() !== $EOF &&\n            (prematureEndPredicate === null || !prematureEndPredicate())) {\n            const current = this._cursor.clone();\n            if (this._isTagStart()) {\n                // We are starting what looks like an HTML element in the middle of this interpolation.\n                // Reset the cursor to before the `<` character and end the interpolation token.\n                // (This is actually wrong but here for backward compatibility).\n                this._cursor = current;\n                parts.push(this._getProcessedChars(expressionStart, current));\n                this._endToken(parts);\n                return;\n            }\n            if (inQuote === null) {\n                if (this._attemptStr(this._interpolationConfig.end)) {\n                    // We are not in a string, and we hit the end interpolation marker\n                    parts.push(this._getProcessedChars(expressionStart, current));\n                    parts.push(this._interpolationConfig.end);\n                    this._endToken(parts);\n                    return;\n                }\n                else if (this._attemptStr('//')) {\n                    // Once we are in a comment we ignore any quotes\n                    inComment = true;\n                }\n            }\n            const char = this._cursor.peek();\n            this._cursor.advance();\n            if (char === $BACKSLASH) {\n                // Skip the next character because it was escaped.\n                this._cursor.advance();\n            }\n            else if (char === inQuote) {\n                // Exiting the current quoted string\n                inQuote = null;\n            }\n            else if (!inComment && inQuote === null && isQuote(char)) {\n                // Entering a new quoted string\n                inQuote = char;\n            }\n        }\n        // We hit EOF without finding a closing interpolation marker\n        parts.push(this._getProcessedChars(expressionStart, this._cursor));\n        this._endToken(parts);\n    }\n    _getProcessedChars(start, end) {\n        return this._processCarriageReturns(end.getChars(start));\n    }\n    _isTextEnd() {\n        if (this._isTagStart() || this._cursor.peek() === $EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (this.isExpansionFormStart()) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns true if the current cursor is pointing to the start of a tag\n     * (opening/closing/comments/cdata/etc).\n     */\n    _isTagStart() {\n        if (this._cursor.peek() === $LT) {\n            // We assume that `<` followed by whitespace is not the start of an HTML element.\n            const tmp = this._cursor.clone();\n            tmp.advance();\n            // If the next character is alphabetic, ! nor / then it is a tag start\n            const code = tmp.peek();\n            if (($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n                code === $SLASH || code === $BANG) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _readUntil(char) {\n        const start = this._cursor.clone();\n        this._attemptUntilChar(char);\n        return this._cursor.getChars(start);\n    }\n    _isInExpansionCase() {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                21 /* TokenType.EXPANSION_CASE_EXP_START */;\n    }\n    _isInExpansionForm() {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                19 /* TokenType.EXPANSION_FORM_START */;\n    }\n    isExpansionFormStart() {\n        if (this._cursor.peek() !== $LBRACE) {\n            return false;\n        }\n        if (this._interpolationConfig) {\n            const start = this._cursor.clone();\n            const isInterpolation = this._attemptStr(this._interpolationConfig.start);\n            this._cursor = start;\n            return !isInterpolation;\n        }\n        return true;\n    }\n}\nfunction isNotWhitespace(code) {\n    return !isWhitespace(code) || code === $EOF;\n}\nfunction isNameEnd(code) {\n    return isWhitespace(code) || code === $GT || code === $LT ||\n        code === $SLASH || code === $SQ || code === $DQ || code === $EQ ||\n        code === $EOF;\n}\nfunction isPrefixEnd(code) {\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\n        (code < $0 || code > $9);\n}\nfunction isDigitEntityEnd(code) {\n    return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);\n}\nfunction isNamedEntityEnd(code) {\n    return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);\n}\nfunction isExpansionCaseStart(peek) {\n    return peek !== $RBRACE;\n}\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\nfunction toUpperCaseCharCode(code) {\n    return code >= $a && code <= $z ? code - $a + $A : code;\n}\nfunction mergeTextTokens(srcTokens) {\n    const dstTokens = [];\n    let lastDstToken = undefined;\n    for (let i = 0; i < srcTokens.length; i++) {\n        const token = srcTokens[i];\n        if ((lastDstToken && lastDstToken.type === 5 /* TokenType.TEXT */ && token.type === 5 /* TokenType.TEXT */) ||\n            (lastDstToken && lastDstToken.type === 16 /* TokenType.ATTR_VALUE_TEXT */ &&\n                token.type === 16 /* TokenType.ATTR_VALUE_TEXT */)) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\nclass PlainCharacterCursor {\n    constructor(fileOrCursor, range) {\n        if (fileOrCursor instanceof PlainCharacterCursor) {\n            this.file = fileOrCursor.file;\n            this.input = fileOrCursor.input;\n            this.end = fileOrCursor.end;\n            const state = fileOrCursor.state;\n            // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n            // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n            // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n            // called in tight loops, this difference matters.\n            this.state = {\n                peek: state.peek,\n                offset: state.offset,\n                line: state.line,\n                column: state.column,\n            };\n        }\n        else {\n            if (!range) {\n                throw new Error('Programming error: the range argument must be provided with a file argument.');\n            }\n            this.file = fileOrCursor;\n            this.input = fileOrCursor.content;\n            this.end = range.endPos;\n            this.state = {\n                peek: -1,\n                offset: range.startPos,\n                line: range.startLine,\n                column: range.startCol,\n            };\n        }\n    }\n    clone() {\n        return new PlainCharacterCursor(this);\n    }\n    peek() {\n        return this.state.peek;\n    }\n    charsLeft() {\n        return this.end - this.state.offset;\n    }\n    diff(other) {\n        return this.state.offset - other.state.offset;\n    }\n    advance() {\n        this.advanceState(this.state);\n    }\n    init() {\n        this.updatePeek(this.state);\n    }\n    getSpan(start, leadingTriviaCodePoints) {\n        start = start || this;\n        let fullStart = start;\n        if (leadingTriviaCodePoints) {\n            while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n                if (fullStart === start) {\n                    start = start.clone();\n                }\n                start.advance();\n            }\n        }\n        const startLocation = this.locationFromCursor(start);\n        const endLocation = this.locationFromCursor(this);\n        const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n        return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n    }\n    getChars(start) {\n        return this.input.substring(start.state.offset, this.state.offset);\n    }\n    charAt(pos) {\n        return this.input.charCodeAt(pos);\n    }\n    advanceState(state) {\n        if (state.offset >= this.end) {\n            this.state = state;\n            throw new CursorError('Unexpected character \"EOF\"', this);\n        }\n        const currentChar = this.charAt(state.offset);\n        if (currentChar === $LF) {\n            state.line++;\n            state.column = 0;\n        }\n        else if (!isNewLine(currentChar)) {\n            state.column++;\n        }\n        state.offset++;\n        this.updatePeek(state);\n    }\n    updatePeek(state) {\n        state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n    }\n    locationFromCursor(cursor) {\n        return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n    }\n}\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n    constructor(fileOrCursor, range) {\n        if (fileOrCursor instanceof EscapedCharacterCursor) {\n            super(fileOrCursor);\n            this.internalState = Object.assign({}, fileOrCursor.internalState);\n        }\n        else {\n            super(fileOrCursor, range);\n            this.internalState = this.state;\n        }\n    }\n    advance() {\n        this.state = this.internalState;\n        super.advance();\n        this.processEscapeSequence();\n    }\n    init() {\n        super.init();\n        this.processEscapeSequence();\n    }\n    clone() {\n        return new EscapedCharacterCursor(this);\n    }\n    getChars(start) {\n        const cursor = start.clone();\n        let chars = '';\n        while (cursor.internalState.offset < this.internalState.offset) {\n            chars += String.fromCodePoint(cursor.peek());\n            cursor.advance();\n        }\n        return chars;\n    }\n    /**\n     * Process the escape sequence that starts at the current position in the text.\n     *\n     * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n     */\n    processEscapeSequence() {\n        const peek = () => this.internalState.peek;\n        if (peek() === $BACKSLASH) {\n            // We have hit an escape sequence so we need the internal state to become independent\n            // of the external state.\n            this.internalState = Object.assign({}, this.state);\n            // Move past the backslash\n            this.advanceState(this.internalState);\n            // First check for standard control char sequences\n            if (peek() === $n) {\n                this.state.peek = $LF;\n            }\n            else if (peek() === $r) {\n                this.state.peek = $CR;\n            }\n            else if (peek() === $v) {\n                this.state.peek = $VTAB;\n            }\n            else if (peek() === $t) {\n                this.state.peek = $TAB;\n            }\n            else if (peek() === $b) {\n                this.state.peek = $BSPACE;\n            }\n            else if (peek() === $f) {\n                this.state.peek = $FF;\n            }\n            // Now consider more complex sequences\n            else if (peek() === $u) {\n                // Unicode code-point sequence\n                this.advanceState(this.internalState); // advance past the `u` char\n                if (peek() === $LBRACE) {\n                    // Variable length Unicode, e.g. `\\x{123}`\n                    this.advanceState(this.internalState); // advance past the `{` char\n                    // Advance past the variable number of hex digits until we hit a `}` char\n                    const digitStart = this.clone();\n                    let length = 0;\n                    while (peek() !== $RBRACE) {\n                        this.advanceState(this.internalState);\n                        length++;\n                    }\n                    this.state.peek = this.decodeHexDigits(digitStart, length);\n                }\n                else {\n                    // Fixed length Unicode, e.g. `\\u1234`\n                    const digitStart = this.clone();\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.state.peek = this.decodeHexDigits(digitStart, 4);\n                }\n            }\n            else if (peek() === $x) {\n                // Hex char code, e.g. `\\x2F`\n                this.advanceState(this.internalState); // advance past the `x` char\n                const digitStart = this.clone();\n                this.advanceState(this.internalState);\n                this.state.peek = this.decodeHexDigits(digitStart, 2);\n            }\n            else if (isOctalDigit(peek())) {\n                // Octal char code, e.g. `\\012`,\n                let octal = '';\n                let length = 0;\n                let previous = this.clone();\n                while (isOctalDigit(peek()) && length < 3) {\n                    previous = this.clone();\n                    octal += String.fromCodePoint(peek());\n                    this.advanceState(this.internalState);\n                    length++;\n                }\n                this.state.peek = parseInt(octal, 8);\n                // Backup one char\n                this.internalState = previous.internalState;\n            }\n            else if (isNewLine(this.internalState.peek)) {\n                // Line continuation `\\` followed by a new line\n                this.advanceState(this.internalState); // advance over the newline\n                this.state = this.internalState;\n            }\n            else {\n                // If none of the `if` blocks were executed then we just have an escaped normal character.\n                // In that case we just, effectively, skip the backslash from the character.\n                this.state.peek = this.internalState.peek;\n            }\n        }\n    }\n    decodeHexDigits(start, length) {\n        const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);\n        const charCode = parseInt(hex, 16);\n        if (!isNaN(charCode)) {\n            return charCode;\n        }\n        else {\n            start.state = start.internalState;\n            throw new CursorError('Invalid hexadecimal escape sequence', start);\n        }\n    }\n}\nclass CursorError {\n    constructor(msg, cursor) {\n        this.msg = msg;\n        this.cursor = cursor;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass TreeError extends ParseError {\n    constructor(elementName, span, msg) {\n        super(span, msg);\n        this.elementName = elementName;\n    }\n    static create(elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    }\n}\nclass ParseTreeResult {\n    constructor(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n}\nclass Parser {\n    constructor(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    parse(source, url, options) {\n        const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n        const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n        parser.build();\n        return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));\n    }\n}\nclass _TreeBuilder {\n    constructor(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._elementStack = [];\n        this.rootNodes = [];\n        this.errors = [];\n        this._advance();\n    }\n    build() {\n        while (this._peek.type !== 24 /* TokenType.EOF */) {\n            if (this._peek.type === 0 /* TokenType.TAG_OPEN_START */ ||\n                this._peek.type === 4 /* TokenType.INCOMPLETE_TAG_OPEN */) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === 3 /* TokenType.TAG_CLOSE */) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === 12 /* TokenType.CDATA_START */) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === 10 /* TokenType.COMMENT_START */) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === 5 /* TokenType.TEXT */ || this._peek.type === 7 /* TokenType.RAW_TEXT */ ||\n                this._peek.type === 6 /* TokenType.ESCAPABLE_RAW_TEXT */) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === 19 /* TokenType.EXPANSION_FORM_START */) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n    }\n    _advance() {\n        const prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    }\n    _advanceIf(type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    }\n    _consumeCdata(_startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(13 /* TokenType.CDATA_END */);\n    }\n    _consumeComment(token) {\n        const text = this._advanceIf(7 /* TokenType.RAW_TEXT */);\n        this._advanceIf(11 /* TokenType.COMMENT_END */);\n        const value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new Comment(value, token.sourceSpan));\n    }\n    _consumeExpansion(token) {\n        const switchValue = this._advance();\n        const type = this._advance();\n        const cases = [];\n        // read =\n        while (this._peek.type === 20 /* TokenType.EXPANSION_CASE_VALUE */) {\n            const expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== 23 /* TokenType.EXPANSION_FORM_END */) {\n            this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n            return;\n        }\n        const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    }\n    _parseExpansionCase() {\n        const value = this._advance();\n        // read {\n        if (this._peek.type !== 21 /* TokenType.EXPANSION_CASE_EXP_START */) {\n            this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n            return null;\n        }\n        // read until }\n        const start = this._advance();\n        const exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        const end = this._advance();\n        exp.push({ type: 24 /* TokenType.EOF */, parts: [], sourceSpan: end.sourceSpan });\n        // parse everything in between { and }\n        const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);\n        expansionCaseParser.build();\n        if (expansionCaseParser.errors.length > 0) {\n            this.errors = this.errors.concat(expansionCaseParser.errors);\n            return null;\n        }\n        const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\n        const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\n        return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    }\n    _collectExpansionExpTokens(start) {\n        const exp = [];\n        const expansionFormStack = [21 /* TokenType.EXPANSION_CASE_EXP_START */];\n        while (true) {\n            if (this._peek.type === 19 /* TokenType.EXPANSION_FORM_START */ ||\n                this._peek.type === 21 /* TokenType.EXPANSION_CASE_EXP_START */) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === 22 /* TokenType.EXPANSION_CASE_EXP_END */) {\n                if (lastOnStack(expansionFormStack, 21 /* TokenType.EXPANSION_CASE_EXP_START */)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length === 0)\n                        return exp;\n                }\n                else {\n                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                    return null;\n                }\n            }\n            if (this._peek.type === 23 /* TokenType.EXPANSION_FORM_END */) {\n                if (lastOnStack(expansionFormStack, 19 /* TokenType.EXPANSION_FORM_START */)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                    return null;\n                }\n            }\n            if (this._peek.type === 24 /* TokenType.EOF */) {\n                this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    }\n    _consumeText(token) {\n        const tokens = [token];\n        const startSpan = token.sourceSpan;\n        let text = token.parts[0];\n        if (text.length > 0 && text[0] === '\\n') {\n            const parent = this._getParentElement();\n            if (parent != null && parent.children.length === 0 &&\n                this.getTagDefinition(parent.name).ignoreFirstLf) {\n                text = text.substring(1);\n                tokens[0] = { type: token.type, sourceSpan: token.sourceSpan, parts: [text] };\n            }\n        }\n        while (this._peek.type === 8 /* TokenType.INTERPOLATION */ || this._peek.type === 5 /* TokenType.TEXT */ ||\n            this._peek.type === 9 /* TokenType.ENCODED_ENTITY */) {\n            token = this._advance();\n            tokens.push(token);\n            if (token.type === 8 /* TokenType.INTERPOLATION */) {\n                // For backward compatibility we decode HTML entities that appear in interpolation\n                // expressions. This is arguably a bug, but it could be a considerable breaking change to\n                // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n                // chain after View Engine has been removed.\n                text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n            }\n            else if (token.type === 9 /* TokenType.ENCODED_ENTITY */) {\n                text += token.parts[0];\n            }\n            else {\n                text += token.parts.join('');\n            }\n        }\n        if (text.length > 0) {\n            const endSpan = token.sourceSpan;\n            this._addToParent(new Text(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));\n        }\n    }\n    _closeVoidElement() {\n        const el = this._getParentElement();\n        if (el && this.getTagDefinition(el.name).isVoid) {\n            this._elementStack.pop();\n        }\n    }\n    _consumeStartTag(startTagToken) {\n        const [prefix, name] = startTagToken.parts;\n        const attrs = [];\n        while (this._peek.type === 14 /* TokenType.ATTR_NAME */) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        const fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        let selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === 2 /* TokenType.TAG_OPEN_END_VOID */) {\n            this._advance();\n            selfClosing = true;\n            const tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\n            }\n        }\n        else if (this._peek.type === 1 /* TokenType.TAG_OPEN_END */) {\n            this._advance();\n            selfClosing = false;\n        }\n        const end = this._peek.sourceSpan.fullStart;\n        const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n        // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n        const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n        const el = new Element(fullName, attrs, [], span, startSpan, undefined);\n        this._pushElement(el);\n        if (selfClosing) {\n            // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n            // element start tag also represents the end tag.\n            this._popElement(fullName, span);\n        }\n        else if (startTagToken.type === 4 /* TokenType.INCOMPLETE_TAG_OPEN */) {\n            // We already know the opening tag is not complete, so it is unlikely it has a corresponding\n            // close tag. Let's optimistically parse it as a full element and emit an error.\n            this._popElement(fullName, null);\n            this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n        }\n    }\n    _pushElement(el) {\n        const parentEl = this._getParentElement();\n        if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n            this._elementStack.pop();\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    }\n    _consumeEndTag(endTagToken) {\n        const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this.getTagDefinition(fullName).isVoid) {\n            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n        }\n        else if (!this._popElement(fullName, endTagToken.sourceSpan)) {\n            const errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    }\n    /**\n     * Closes the nearest element with the tag name `fullName` in the parse tree.\n     * `endSourceSpan` is the span of the closing tag, or null if the element does\n     * not have a closing tag (for example, this happens when an incomplete\n     * opening tag is recovered).\n     */\n    _popElement(fullName, endSourceSpan) {\n        let unexpectedCloseTagDetected = false;\n        for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            const el = this._elementStack[stackIndex];\n            if (el.name === fullName) {\n                // Record the parse span with the element that is being closed. Any elements that are\n                // removed from the element stack at this point are closed implicitly, so they won't get\n                // an end source span (as there is no explicit closing element).\n                el.endSourceSpan = endSourceSpan;\n                el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return !unexpectedCloseTagDetected;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                // Note that we encountered an unexpected close tag but continue processing the element\n                // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\n                // end tag in the stack.\n                unexpectedCloseTagDetected = true;\n            }\n        }\n        return false;\n    }\n    _consumeAttr(attrName) {\n        const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        let attrEnd = attrName.sourceSpan.end;\n        // Consume any quote\n        if (this._peek.type === 15 /* TokenType.ATTR_QUOTE */) {\n            this._advance();\n        }\n        // Consume the attribute value\n        let value = '';\n        const valueTokens = [];\n        let valueStartSpan = undefined;\n        let valueEnd = undefined;\n        // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of\n        // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from\n        // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not\n        // able to see that `_advance()` will actually mutate `_peek`.\n        const nextTokenType = this._peek.type;\n        if (nextTokenType === 16 /* TokenType.ATTR_VALUE_TEXT */) {\n            valueStartSpan = this._peek.sourceSpan;\n            valueEnd = this._peek.sourceSpan.end;\n            while (this._peek.type === 16 /* TokenType.ATTR_VALUE_TEXT */ ||\n                this._peek.type === 17 /* TokenType.ATTR_VALUE_INTERPOLATION */ ||\n                this._peek.type === 9 /* TokenType.ENCODED_ENTITY */) {\n                const valueToken = this._advance();\n                valueTokens.push(valueToken);\n                if (valueToken.type === 17 /* TokenType.ATTR_VALUE_INTERPOLATION */) {\n                    // For backward compatibility we decode HTML entities that appear in interpolation\n                    // expressions. This is arguably a bug, but it could be a considerable breaking change to\n                    // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n                    // chain after View Engine has been removed.\n                    value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n                }\n                else if (valueToken.type === 9 /* TokenType.ENCODED_ENTITY */) {\n                    value += valueToken.parts[0];\n                }\n                else {\n                    value += valueToken.parts.join('');\n                }\n                valueEnd = attrEnd = valueToken.sourceSpan.end;\n            }\n        }\n        // Consume any quote\n        if (this._peek.type === 15 /* TokenType.ATTR_QUOTE */) {\n            const quoteToken = this._advance();\n            attrEnd = quoteToken.sourceSpan.end;\n        }\n        const valueSpan = valueStartSpan && valueEnd &&\n            new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n        return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);\n    }\n    _getParentElement() {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    }\n    _addToParent(node) {\n        const parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this.rootNodes.push(node);\n        }\n    }\n    _getElementFullName(prefix, localName, parentElement) {\n        if (prefix === '') {\n            prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n            if (prefix === '' && parentElement != null) {\n                const parentTagName = splitNsName(parentElement.name)[1];\n                const parentTagDefinition = this.getTagDefinition(parentTagName);\n                if (!parentTagDefinition.preventNamespaceInheritance) {\n                    prefix = getNsPrefix(parentElement.name);\n                }\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    }\n}\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n/**\n * Decode the `entity` string, which we believe is the contents of an HTML entity.\n *\n * If the string is not actually a valid/known entity then just return the original `match` string.\n */\nfunction decodeEntity(match, entity) {\n    if (NAMED_ENTITIES[entity] !== undefined) {\n        return NAMED_ENTITIES[entity] || match;\n    }\n    if (/^#x[a-f0-9]+$/i.test(entity)) {\n        return String.fromCodePoint(parseInt(entity.slice(2), 16));\n    }\n    if (/^#\\d+$/.test(entity)) {\n        return String.fromCodePoint(parseInt(entity.slice(1), 10));\n    }\n    return match;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass HtmlParser extends Parser {\n    constructor() {\n        super(getHtmlTagDefinition);\n    }\n    parse(source, url, options) {\n        return super.parse(source, url, options);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\nfunction hasPreserveWhitespacesAttr(attrs) {\n    return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);\n}\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here.\n */\nfunction replaceNgsp(value) {\n    // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n    return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\nclass WhitespaceVisitor {\n    visitElement(element, context) {\n        if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n            // don't descent into elements where we need to preserve whitespaces\n            // but still visit all attributes to eliminate one used as a market to preserve WS\n            return new Element(element.name, visitAll(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        return new Element(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n    visitAttribute(attribute, context) {\n        return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n    }\n    visitText(text, context) {\n        const isNotBlank = text.value.match(NO_WS_REGEXP);\n        const hasExpansionSibling = context &&\n            (context.prev instanceof Expansion || context.next instanceof Expansion);\n        if (isNotBlank || hasExpansionSibling) {\n            // Process the whitespace in the tokens of this Text node\n            const tokens = text.tokens.map(token => token.type === 5 /* TokenType.TEXT */ ? createWhitespaceProcessedTextToken(token) : token);\n            // Process the whitespace of the value of this Text node\n            const value = processWhitespace(text.value);\n            return new Text(value, text.sourceSpan, tokens, text.i18n);\n        }\n        return null;\n    }\n    visitComment(comment, context) {\n        return comment;\n    }\n    visitExpansion(expansion, context) {\n        return expansion;\n    }\n    visitExpansionCase(expansionCase, context) {\n        return expansionCase;\n    }\n}\nfunction createWhitespaceProcessedTextToken({ type, parts, sourceSpan }) {\n    return { type, parts: [processWhitespace(parts[0])], sourceSpan };\n}\nfunction processWhitespace(text) {\n    return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');\n}\nfunction visitAllWithSiblings(visitor, nodes) {\n    const result = [];\n    nodes.forEach((ast, i) => {\n        const context = { prev: nodes[i - 1], next: nodes[i + 1] };\n        const astResult = ast.visit(visitor, context);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\nfunction mapLiteral(obj, quoted = false) {\n    return literalMap(Object.keys(obj).map(key => ({\n        key,\n        quoted,\n        value: obj[key],\n    })));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */\nlet _SECURITY_SCHEMA;\nfunction SECURITY_SCHEMA() {\n    if (!_SECURITY_SCHEMA) {\n        _SECURITY_SCHEMA = {};\n        // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n        registerContext(SecurityContext.HTML, [\n            'iframe|srcdoc',\n            '*|innerHTML',\n            '*|outerHTML',\n        ]);\n        registerContext(SecurityContext.STYLE, ['*|style']);\n        // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n        registerContext(SecurityContext.URL, [\n            '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\n            'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\n            'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\n            'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\n        ]);\n        registerContext(SecurityContext.RESOURCE_URL, [\n            'applet|code',\n            'applet|codebase',\n            'base|href',\n            'embed|src',\n            'frame|src',\n            'head|profile',\n            'html|manifest',\n            'iframe|src',\n            'link|href',\n            'media|src',\n            'object|codebase',\n            'object|data',\n            'script|src',\n        ]);\n    }\n    return _SECURITY_SCHEMA;\n}\nfunction registerContext(ctx, specs) {\n    for (const spec of specs)\n        _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ElementSchemaRegistry {\n}\nconst BOOLEAN = 'boolean';\nconst NUMBER = 'number';\nconst STRING = 'string';\nconst OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\nconst SCHEMA = [\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\n        /* added manually to avoid breaking changes */\n        ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\n    'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\n    'select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'shadow^[HTMLElement]|',\n    'slot^[HTMLElement]|name',\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|#height,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n    ':svg:cursor^:svg:|',\n];\nconst _ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n};\n// Invert _ATTR_TO_PROP.\nconst _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce((inverted, attr) => {\n    inverted[_ATTR_TO_PROP[attr]] = attr;\n    return inverted;\n}, {});\nclass DomElementSchemaRegistry extends ElementSchemaRegistry {\n    constructor() {\n        super();\n        this._schema = {};\n        // We don't allow binding to events for security reasons. Allowing event bindings would almost\n        // certainly introduce bad XSS vulnerabilities. Instead, we store events in a separate schema.\n        this._eventSchema = {};\n        SCHEMA.forEach(encodedType => {\n            const type = {};\n            const events = new Set();\n            const [strType, strProperties] = encodedType.split('|');\n            const properties = strProperties.split(',');\n            const [typeNames, superName] = strType.split('^');\n            typeNames.split(',').forEach(tag => {\n                this._schema[tag.toLowerCase()] = type;\n                this._eventSchema[tag.toLowerCase()] = events;\n            });\n            const superType = superName && this._schema[superName.toLowerCase()];\n            if (superType) {\n                Object.keys(superType).forEach((prop) => {\n                    type[prop] = superType[prop];\n                });\n                for (const superEvent of this._eventSchema[superName.toLowerCase()]) {\n                    events.add(superEvent);\n                }\n            }\n            properties.forEach((property) => {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            events.add(property.substring(1));\n                            break;\n                        case '!':\n                            type[property.substring(1)] = BOOLEAN;\n                            break;\n                        case '#':\n                            type[property.substring(1)] = NUMBER;\n                            break;\n                        case '%':\n                            type[property.substring(1)] = OBJECT;\n                            break;\n                        default:\n                            type[property] = STRING;\n                    }\n                }\n            });\n        });\n    }\n    hasProperty(tagName, propName, schemaMetas) {\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return false;\n            }\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        return !!elementProperties[propName];\n    }\n    hasElement(tagName, schemaMetas) {\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return true;\n            }\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return !!this._schema[tagName.toLowerCase()];\n    }\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\n     * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\n     * string values. Only specific well known attack vectors are assigned their appropriate context.\n     */\n    securityContext(tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA()['*|' + propName];\n        return ctx ? ctx : SecurityContext.NONE;\n    }\n    getMappedPropName(propName) {\n        return _ATTR_TO_PROP[propName] || propName;\n    }\n    getDefaultComponentElementName() {\n        return 'ng-component';\n    }\n    validateProperty(name) {\n        if (name.toLowerCase().startsWith('on')) {\n            const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +\n                `please use (${name.slice(2)})=...` +\n                `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n                ` current module.`;\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    }\n    validateAttribute(name) {\n        if (name.toLowerCase().startsWith('on')) {\n            const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n                `please use (${name.slice(2)})=...`;\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    }\n    allKnownElementNames() {\n        return Object.keys(this._schema);\n    }\n    allKnownAttributesOfElement(tagName) {\n        const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n        // Convert properties to attributes.\n        return Object.keys(elementProperties).map(prop => { var _a; return (_a = _PROP_TO_ATTR[prop]) !== null && _a !== void 0 ? _a : prop; });\n    }\n    allKnownEventsOfElement(tagName) {\n        var _a;\n        return Array.from((_a = this._eventSchema[tagName.toLowerCase()]) !== null && _a !== void 0 ? _a : []);\n    }\n    normalizeAnimationStyleProperty(propName) {\n        return dashCaseToCamelCase(propName);\n    }\n    normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\n        let unit = '';\n        const strVal = val.toString().trim();\n        let errorMsg = null;\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    }\n}\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all\n * tags use '*'.\n *\n * Extracted from, and should be kept in sync with\n * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations\n */\nconst TRUSTED_TYPES_SINKS = new Set([\n    // NOTE: All strings in this set *must* be lowercase!\n    // TrustedHTML\n    'iframe|srcdoc',\n    '*|innerhtml',\n    '*|outerhtml',\n    // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.\n    // TrustedScriptURL\n    'embed|src',\n    'object|codebase',\n    'object|data',\n]);\n/**\n * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types\n * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular\n * Trusted Type is required for values passed to the sink:\n * - SecurityContext.HTML corresponds to TrustedHTML\n * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL\n */\nfunction isTrustedTypesSink(tagName, propName) {\n    // Make sure comparisons are case insensitive, so that case differences between attribute and\n    // property names do not have a security impact.\n    tagName = tagName.toLowerCase();\n    propName = propName.toLowerCase();\n    return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) ||\n        TRUSTED_TYPES_SINKS.has('*|' + propName);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX$1 = '*';\nconst ANIMATE_PROP_PREFIX = 'animate-';\n/**\n * Parses bindings in templates and in the directive host area.\n */\nclass BindingParser {\n    constructor(_exprParser, _interpolationConfig, _schemaRegistry, errors) {\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this.errors = errors;\n    }\n    get interpolationConfig() {\n        return this._interpolationConfig;\n    }\n    createBoundHostProperties(properties, sourceSpan) {\n        const boundProps = [];\n        for (const propName of Object.keys(properties)) {\n            const expression = properties[propName];\n            if (typeof expression === 'string') {\n                this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], \n                // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n                // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n                // source of the host binding (which doesn't exist in the template). Regardless,\n                // neither of these values are used in Ivy but are only here to satisfy the function\n                // signature. This should likely be refactored in the future so that `sourceSpan`\n                // isn't being used inaccurately.\n                boundProps, sourceSpan);\n            }\n            else {\n                this._reportError(`Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n            }\n        }\n        return boundProps;\n    }\n    createDirectiveHostEventAsts(hostListeners, sourceSpan) {\n        const targetEvents = [];\n        for (const propName of Object.keys(hostListeners)) {\n            const expression = hostListeners[propName];\n            if (typeof expression === 'string') {\n                // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n                // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n                // rather than the source of the host binding (which doesn't exist in the template).\n                // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n                // function signature. This should likely be refactored in the future so that `sourceSpan`\n                // isn't being used inaccurately.\n                this.parseEvent(propName, expression, /* isAssignmentEvent */ false, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n            }\n            else {\n                this._reportError(`Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n            }\n        }\n        return targetEvents;\n    }\n    parseInterpolation(value, sourceSpan, interpolatedTokens) {\n        const sourceInfo = sourceSpan.start.toString();\n        const absoluteOffset = sourceSpan.fullStart.offset;\n        try {\n            const ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, interpolatedTokens, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    /**\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n     * This is used for parsing the switch expression in ICUs.\n     */\n    parseInterpolationExpression(expression, sourceSpan) {\n        const sourceInfo = sourceSpan.start.toString();\n        const absoluteOffset = sourceSpan.start.offset;\n        try {\n            const ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    /**\n     * Parses the bindings in a microsyntax expression, and converts them to\n     * `ParsedProperty` or `ParsedVariable`.\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteValueOffset start of the tplValue relative to the entire template\n     * @param targetMatchableAttrs potential attributes to match in the template\n     * @param targetProps target property bindings in the template\n     * @param targetVars target variables in the template\n     */\n    parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {\n        const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$1.length;\n        const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n        for (const binding of bindings) {\n            // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n            // binding within the microsyntax expression so it's more narrow than sourceSpan.\n            const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n            const key = binding.key.source;\n            const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n            if (binding instanceof VariableBinding) {\n                const value = binding.value ? binding.value.source : '$implicit';\n                const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n                targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n            }\n            else if (binding.value) {\n                const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n                const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n                this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n            }\n            else {\n                targetMatchableAttrs.push([key, '' /* value */]);\n                // Since this is a literal attribute with no RHS, source span should be\n                // just the key span.\n                this.parseLiteralAttr(key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */, targetMatchableAttrs, targetProps, keySpan);\n            }\n        }\n    }\n    /**\n     * Parses the bindings in a microsyntax expression, e.g.\n     * ```\n     *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n     * ```\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteKeyOffset start of the `tplKey`\n     * @param absoluteValueOffset start of the `tplValue`\n     */\n    _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n        const sourceInfo = sourceSpan.start.toString();\n        try {\n            const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.warnings.forEach((warning) => {\n                this._reportError(warning, sourceSpan, exports.ParseErrorLevel.WARNING);\n            });\n            return bindingsResult.templateBindings;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return [];\n        }\n    }\n    parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n        if (isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n            }\n            if (value) {\n                this._reportError(`Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                    ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, exports.ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), exports.ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n        }\n    }\n    parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n        if (name.length === 0) {\n            this._reportError(`Property name is missing in binding`, sourceSpan);\n        }\n        let isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n            }\n        }\n        else if (isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n            }\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n    }\n    parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan, interpolatedTokens) {\n        const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    }\n    _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, exports.ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n    }\n    _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n        if (name.length === 0) {\n            this._reportError('Animation trigger is missing', sourceSpan);\n        }\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        const ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, exports.ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n    }\n    _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {\n        const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n        try {\n            const ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {\n        if (boundProp.isAnimation) {\n            return new BoundElementProperty(boundProp.name, 4 /* BindingType.Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n        }\n        let unit = null;\n        let bindingType = undefined;\n        let boundPropertyName = null;\n        const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        let securityContexts = undefined;\n        // Check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n                if (!skipValidation) {\n                    this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                }\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                const nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name);\n                }\n                bindingType = 1 /* BindingType.Attribute */;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = 2 /* BindingType.Class */;\n                securityContexts = [SecurityContext.NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = 3 /* BindingType.Style */;\n                securityContexts = [SecurityContext.STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n            bindingType = 0 /* BindingType.Property */;\n            if (!skipValidation) {\n                this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n            }\n        }\n        return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }\n    // TODO: keySpan should be required but was made optional to avoid changing VE parser.\n    parseEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n        if (name.length === 0) {\n            this._reportError(`Event name is missing in binding`, sourceSpan);\n        }\n        if (isAnimationLabel(name)) {\n            name = name.slice(1);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n            }\n            this._parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan);\n        }\n        else {\n            this._parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\n        }\n    }\n    calcPossibleSecurityContexts(selector, propName, isAttribute) {\n        const prop = this._schemaRegistry.getMappedPropName(propName);\n        return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n    }\n    _parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan) {\n        const matches = splitAtPeriod(name, [name, '']);\n        const eventName = matches[0];\n        const phase = matches[1].toLowerCase();\n        const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);\n        targetEvents.push(new ParsedEvent(eventName, phase, 1 /* ParsedEventType.Animation */, ast, sourceSpan, handlerSpan, keySpan));\n        if (eventName.length === 0) {\n            this._reportError(`Animation event name is missing in binding`, sourceSpan);\n        }\n        if (phase) {\n            if (phase !== 'start' && phase !== 'done') {\n                this._reportError(`The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`, sourceSpan);\n            }\n        }\n        else {\n            this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);\n        }\n    }\n    _parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n        // long format: 'target: eventName'\n        const [target, eventName] = splitAtColon(name, [null, name]);\n        const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetEvents.push(new ParsedEvent(eventName, target, 0 /* ParsedEventType.Regular */, ast, sourceSpan, handlerSpan, keySpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    }\n    _parseAction(value, isAssignmentEvent, sourceSpan) {\n        const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n        const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\n        try {\n            const ast = this._exprParser.parseAction(value, isAssignmentEvent, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(`Empty expressions are not allowed`, sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n            }\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    _reportError(message, sourceSpan, level = exports.ParseErrorLevel.ERROR) {\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n    _reportExpressionParserErrors(errors, sourceSpan) {\n        for (const error of errors) {\n            this._reportError(error.message, sourceSpan);\n        }\n    }\n    /**\n     * @param propName the name of the property / attribute\n     * @param sourceSpan\n     * @param isAttr true when binding to an attribute\n     */\n    _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\n        const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(report.msg, sourceSpan, exports.ParseErrorLevel.ERROR);\n        }\n    }\n}\nfunction isAnimationLabel(name) {\n    return name[0] == '@';\n}\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    const ctxs = [];\n    CssSelector.parse(selector).forEach((selector) => {\n        const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n            .map((selector) => selector.element));\n        const possibleElementNames = elementNames.filter(elementName => !notElementNames.has(elementName));\n        ctxs.push(...possibleElementNames.map(elementName => registry.securityContext(elementName, propName, isAttribute)));\n    });\n    return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\n    // The difference of two absolute offsets provide the relative offset\n    const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n    const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n    return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Some of the code comes from WebComponents.JS\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js\nfunction isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst NG_CONTENT_SELECT_ATTR$1 = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\nfunction preparseElement(ast) {\n    let selectAttr = null;\n    let hrefAttr = null;\n    let relAttr = null;\n    let nonBindable = false;\n    let projectAs = '';\n    ast.attrs.forEach(attr => {\n        const lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR$1) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    const nodeName = ast.name.toLowerCase();\n    let type = PreparsedElementType.OTHER;\n    if (isNgContent(nodeName)) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType;\n(function (PreparsedElementType) {\n    PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n    PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n    PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n    PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n})(PreparsedElementType || (PreparsedElementType = {}));\nclass PreparsedElement {\n    constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n}\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\nconst BINDING_DELIMS = {\n    BANANA_BOX: { start: '[(', end: ')]' },\n    PROPERTY: { start: '[', end: ']' },\n    EVENT: { start: '(', end: ')' },\n};\nconst TEMPLATE_ATTR_PREFIX = '*';\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser, options) {\n    const transformer = new HtmlAstToIvyAst(bindingParser, options);\n    const ivyNodes = visitAll(transformer, htmlNodes);\n    // Errors might originate in either the binding parser or the html to ivy transformer\n    const allErrors = bindingParser.errors.concat(transformer.errors);\n    const result = {\n        nodes: ivyNodes,\n        errors: allErrors,\n        styleUrls: transformer.styleUrls,\n        styles: transformer.styles,\n        ngContentSelectors: transformer.ngContentSelectors\n    };\n    if (options.collectCommentNodes) {\n        result.commentNodes = transformer.commentNodes;\n    }\n    return result;\n}\nclass HtmlAstToIvyAst {\n    constructor(bindingParser, options) {\n        this.bindingParser = bindingParser;\n        this.options = options;\n        this.errors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngContentSelectors = [];\n        // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\n        this.commentNodes = [];\n        this.inI18nBlock = false;\n    }\n    // HTML visitor\n    visitElement(element) {\n        const isI18nRootElement = isI18nRootNode(element.i18n);\n        if (isI18nRootElement) {\n            if (this.inI18nBlock) {\n                this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n            }\n            this.inI18nBlock = true;\n        }\n        const preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLE) {\n            const contents = textContents(element);\n            if (contents !== null) {\n                this.styles.push(contents);\n            }\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            this.styleUrls.push(preparsedElement.hrefAttr);\n            return null;\n        }\n        // Whether the element is a `<ng-template>`\n        const isTemplateElement = isNgTemplate(element.name);\n        const parsedProperties = [];\n        const boundEvents = [];\n        const variables = [];\n        const references = [];\n        const attributes = [];\n        const i18nAttrsMeta = {};\n        const templateParsedProperties = [];\n        const templateVariables = [];\n        // Whether the element has any *-attribute\n        let elementHasInlineTemplate = false;\n        for (const attribute of element.attrs) {\n            let hasBinding = false;\n            const normalizedName = normalizeAttributeName(attribute.name);\n            // `*attr` defines template bindings\n            let isTemplateBinding = false;\n            if (attribute.i18n) {\n                i18nAttrsMeta[attribute.name] = attribute.i18n;\n            }\n            if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                // *-attributes\n                if (elementHasInlineTemplate) {\n                    this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);\n                }\n                isTemplateBinding = true;\n                elementHasInlineTemplate = true;\n                const templateValue = attribute.value;\n                const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n                const parsedVariables = [];\n                const absoluteValueOffset = attribute.valueSpan ?\n                    attribute.valueSpan.start.offset :\n                    // If there is no value span the attribute does not have a value, like `attr` in\n                    //`<div attr></div>`. In this case, point to one character beyond the last character of\n                    // the attribute name.\n                    attribute.sourceSpan.start.offset + attribute.name.length;\n                this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true /* isIvyAst */);\n                templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\n            }\n            else {\n                // Check for variables, events, property bindings, interpolation\n                hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n            }\n            if (!hasBinding && !isTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attributes.push(this.visitAttribute(attribute));\n            }\n        }\n        const children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);\n        let parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            // `<ng-content>`\n            if (element.children &&\n                !element.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {\n                this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\n            }\n            const selector = preparsedElement.selectAttr;\n            const attrs = element.attrs.map(attr => this.visitAttribute(attr));\n            parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);\n            this.ngContentSelectors.push(selector);\n        }\n        else if (isTemplateElement) {\n            // `<ng-template>`\n            const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [ /* no template attributes */], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        else {\n            const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Element$1(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        if (elementHasInlineTemplate) {\n            // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n            // node that contains this node.\n            // Moreover, if the node is an element, then we need to hoist its attributes to the template\n            // node for matching against content projection selectors.\n            const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n            const templateAttrs = [];\n            attrs.literal.forEach(attr => templateAttrs.push(attr));\n            attrs.bound.forEach(attr => templateAttrs.push(attr));\n            const hoistedAttrs = parsedElement instanceof Element$1 ?\n                {\n                    attributes: parsedElement.attributes,\n                    inputs: parsedElement.inputs,\n                    outputs: parsedElement.outputs,\n                } :\n                { attributes: [], inputs: [], outputs: [] };\n            // For <ng-template>s with structural directives on them, avoid passing i18n information to\n            // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n            // necessary i18n meta information will be extracted from child elements.\n            const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;\n            const name = parsedElement instanceof Template ? null : parsedElement.name;\n            parsedElement = new Template(name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [ /* no references */], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);\n        }\n        if (isI18nRootElement) {\n            this.inI18nBlock = false;\n        }\n        return parsedElement;\n    }\n    visitAttribute(attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    }\n    visitText(text) {\n        return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);\n    }\n    visitExpansion(expansion) {\n        if (!expansion.i18n) {\n            // do not generate Icu in case it was created\n            // outside of i18n block in a template\n            return null;\n        }\n        if (!isI18nRootNode(expansion.i18n)) {\n            throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${expansion.sourceSpan.toString()}. Expected a \"Message\"`);\n        }\n        const message = expansion.i18n;\n        const vars = {};\n        const placeholders = {};\n        // extract VARs from ICUs - we process them separately while\n        // assembling resulting message via goog.getMsg function, since\n        // we need to pass them to top-level goog.getMsg call\n        Object.keys(message.placeholders).forEach(key => {\n            const value = message.placeholders[key];\n            if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n                // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\n                // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\n                // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\n                // converted into `_` symbols while normalizing placeholder names, which might lead to\n                // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\n                const formattedKey = key.trim();\n                const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n                vars[formattedKey] = new BoundText(ast, value.sourceSpan);\n            }\n            else {\n                placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);\n            }\n        });\n        return new Icu$1(vars, placeholders, expansion.sourceSpan, message);\n    }\n    visitExpansionCase(expansionCase) {\n        return null;\n    }\n    visitComment(comment) {\n        if (this.options.collectCommentNodes) {\n            this.commentNodes.push(new Comment$1(comment.value || '', comment.sourceSpan));\n        }\n        return null;\n    }\n    // convert view engine `ParsedProperty` to a format suitable for IVY\n    extractAttributes(elementName, properties, i18nPropsMeta) {\n        const bound = [];\n        const literal = [];\n        properties.forEach(prop => {\n            const i18n = i18nPropsMeta[prop.name];\n            if (prop.isLiteral) {\n                literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));\n            }\n            else {\n                // Note that validation is skipped and property mapping is disabled\n                // due to the fact that we need to make sure a given prop is not an\n                // input of a directive and directive matching happens at runtime.\n                const bep = this.bindingParser.createBoundElementProperty(elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);\n                bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n            }\n        });\n        return { bound, literal };\n    }\n    parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n        var _a;\n        const name = normalizeAttributeName(attribute.name);\n        const value = attribute.value;\n        const srcSpan = attribute.sourceSpan;\n        const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n        function createKeySpan(srcSpan, prefix, identifier) {\n            // We need to adjust the start location for the keySpan to account for the removed 'data-'\n            // prefix from `normalizeAttributeName`.\n            const normalizationAdjustment = attribute.name.length - name.length;\n            const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n            const keySpanEnd = keySpanStart.moveBy(identifier.length);\n            return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n        }\n        const bindParts = name.match(BIND_NAME_REGEXP);\n        if (bindParts) {\n            if (bindParts[KW_BIND_IDX] != null) {\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    const identifier = bindParts[IDENT_KW_IDX];\n                    const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n                    this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n                }\n                else {\n                    this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n                this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                const events = [];\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n                this.bindingParser.parseEvent(identifier, value, /* isAssignmentEvent */ false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n                addEvents(events, boundEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                const keySpan = createKeySpan(srcSpan, '', name);\n                this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n            }\n            return true;\n        }\n        // We didn't see a kw-prefixed property binding, but we have not yet checked\n        // for the []/()/[()] syntax.\n        let delims = null;\n        if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n            delims = BINDING_DELIMS.BANANA_BOX;\n        }\n        else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n            delims = BINDING_DELIMS.PROPERTY;\n        }\n        else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n            delims = BINDING_DELIMS.EVENT;\n        }\n        if (delims !== null &&\n            // NOTE: older versions of the parser would match a start/end delimited\n            // binding iff the property name was terminated by the ending delimiter\n            // and the identifier in the binding was non-empty.\n            // TODO(ayazhafiz): update this to handle malformed bindings.\n            name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n            const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n            const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n            if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);\n            }\n            else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n            }\n            else {\n                const events = [];\n                this.bindingParser.parseEvent(identifier, value, /* isAssignmentEvent */ false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n                addEvents(events, boundEvents);\n            }\n            return true;\n        }\n        // No explicit binding found.\n        const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n        const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan, (_a = attribute.valueTokens) !== null && _a !== void 0 ? _a : null);\n        return hasBinding;\n    }\n    _visitTextWithInterpolation(value, sourceSpan, interpolatedTokens, i18n) {\n        const valueNoNgsp = replaceNgsp(value);\n        const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);\n        return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);\n    }\n    parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this.reportError(`Variable does not have a name`, sourceSpan);\n        }\n        variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n    }\n    parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this.reportError(`Reference does not have a name`, sourceSpan);\n        }\n        else if (references.some(reference => reference.name === identifier)) {\n            this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n        }\n        references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n    }\n    parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {\n        const events = [];\n        this.bindingParser.parseEvent(`${name}Change`, `${expression} =$event`, /* isAssignmentEvent */ true, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n        addEvents(events, boundEvents);\n    }\n    reportError(message, sourceSpan, level = exports.ParseErrorLevel.ERROR) {\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n}\nclass NonBindableVisitor {\n    visitElement(ast) {\n        const preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        const children = visitAll(this, ast.children, null);\n        return new Element$1(ast.name, visitAll(this, ast.attrs), \n        /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);\n    }\n    visitComment(comment) {\n        return null;\n    }\n    visitAttribute(attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    }\n    visitText(text) {\n        return new Text$3(text.value, text.sourceSpan);\n    }\n    visitExpansion(expansion) {\n        return null;\n    }\n    visitExpansionCase(expansionCase) {\n        return null;\n    }\n}\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\nfunction normalizeAttributeName(attrName) {\n    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\nfunction addEvents(events, boundEvents) {\n    boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));\n}\nfunction isEmptyTextNode(node) {\n    return node instanceof Text && node.value.trim().length == 0;\n}\nfunction isCommentNode(node) {\n    return node instanceof Comment;\n}\nfunction textContents(node) {\n    if (node.children.length !== 1 || !(node.children[0] instanceof Text)) {\n        return null;\n    }\n    else {\n        return node.children[0].value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TagType;\n(function (TagType) {\n    TagType[TagType[\"ELEMENT\"] = 0] = \"ELEMENT\";\n    TagType[TagType[\"TEMPLATE\"] = 1] = \"TEMPLATE\";\n})(TagType || (TagType = {}));\n/**\n * Generates an object that is used as a shared state between parent and all child contexts.\n */\nfunction setupRegistry() {\n    return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };\n}\n/**\n * I18nContext is a helper class which keeps track of all i18n-related aspects\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n *\n * When we enter a nested template, the top-level context is being passed down\n * to the nested component, which uses this context to generate a child instance\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\n * with the parent context.\n *\n * @param index Instruction index of i18nStart, which initiates this context\n * @param ref Reference to a translation const that represents the content if thus context\n * @param level Nestng level defined for child contexts\n * @param templateIndex Instruction index of a template which this context belongs to\n * @param meta Meta information (id, meaning, description, etc) associated with this context\n */\nclass I18nContext {\n    constructor(index, ref, level = 0, templateIndex = null, meta, registry) {\n        this.index = index;\n        this.ref = ref;\n        this.level = level;\n        this.templateIndex = templateIndex;\n        this.meta = meta;\n        this.registry = registry;\n        this.bindings = new Set();\n        this.placeholders = new Map();\n        this.isEmitted = false;\n        this._unresolvedCtxCount = 0;\n        this._registry = registry || setupRegistry();\n        this.id = this._registry.getUniqueId();\n    }\n    appendTag(type, node, index, closed) {\n        if (node.isVoid && closed) {\n            return; // ignore \"close\" for void tags\n        }\n        const ph = node.isVoid || !closed ? node.startName : node.closeName;\n        const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };\n        updatePlaceholderMap(this.placeholders, ph, content);\n    }\n    get icus() {\n        return this._registry.icus;\n    }\n    get isRoot() {\n        return this.level === 0;\n    }\n    get isResolved() {\n        return this._unresolvedCtxCount === 0;\n    }\n    getSerializedPlaceholders() {\n        const result = new Map();\n        this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));\n        return result;\n    }\n    // public API to accumulate i18n-related content\n    appendBinding(binding) {\n        this.bindings.add(binding);\n    }\n    appendIcu(name, ref) {\n        updatePlaceholderMap(this._registry.icus, name, ref);\n    }\n    appendBoundText(node) {\n        const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n        phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));\n    }\n    appendTemplate(node, index) {\n        // add open and close tags at the same time,\n        // since we process nested templates separately\n        this.appendTag(TagType.TEMPLATE, node, index, false);\n        this.appendTag(TagType.TEMPLATE, node, index, true);\n        this._unresolvedCtxCount++;\n    }\n    appendElement(node, index, closed) {\n        this.appendTag(TagType.ELEMENT, node, index, closed);\n    }\n    appendProjection(node, index) {\n        // Add open and close tags at the same time, since `<ng-content>` has no content,\n        // so when we come across `<ng-content>` we can register both open and close tags.\n        // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and\n        // regular element tag placeholders, so we generate element placeholders for both types.\n        this.appendTag(TagType.ELEMENT, node, index, false);\n        this.appendTag(TagType.ELEMENT, node, index, true);\n    }\n    /**\n     * Generates an instance of a child context based on the root one,\n     * when we enter a nested template within I18n section.\n     *\n     * @param index Instruction index of corresponding i18nStart, which initiates this context\n     * @param templateIndex Instruction index of a template which this context belongs to\n     * @param meta Meta information (id, meaning, description, etc) associated with this context\n     *\n     * @returns I18nContext instance\n     */\n    forkChildContext(index, templateIndex, meta) {\n        return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n    }\n    /**\n     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n     *\n     * @param context Child I18nContext instance to be reconciled with parent context.\n     */\n    reconcileChildContext(context) {\n        // set the right context id for open and close\n        // template tags, so we can use it as sub-block ids\n        ['start', 'close'].forEach((op) => {\n            const key = context.meta[`${op}Name`];\n            const phs = this.placeholders.get(key) || [];\n            const tag = phs.find(findTemplateFn(this.id, context.templateIndex));\n            if (tag) {\n                tag.ctx = context.id;\n            }\n        });\n        // reconcile placeholders\n        const childPhs = context.placeholders;\n        childPhs.forEach((values, key) => {\n            const phs = this.placeholders.get(key);\n            if (!phs) {\n                this.placeholders.set(key, values);\n                return;\n            }\n            // try to find matching template...\n            const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n            if (tmplIdx >= 0) {\n                // ... if found - replace it with nested template content\n                const isCloseTag = key.startsWith('CLOSE');\n                const isTemplateTag = key.endsWith('NG-TEMPLATE');\n                if (isTemplateTag) {\n                    // current template's content is placed before or after\n                    // parent template tag, depending on the open/close atrribute\n                    phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);\n                }\n                else {\n                    const idx = isCloseTag ? values.length - 1 : 0;\n                    values[idx].tmpl = phs[tmplIdx];\n                    phs.splice(tmplIdx, 1, ...values);\n                }\n            }\n            else {\n                // ... otherwise just append content to placeholder value\n                phs.push(...values);\n            }\n            this.placeholders.set(key, phs);\n        });\n        this._unresolvedCtxCount--;\n    }\n}\n//\n// Helper methods\n//\nfunction wrap(symbol, index, contextId, closed) {\n    const state = closed ? '/' : '';\n    return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);\n}\nfunction wrapTag(symbol, { index, ctx, isVoid }, closed) {\n    return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :\n        wrap(symbol, index, ctx, closed);\n}\nfunction findTemplateFn(ctx, templateIndex) {\n    return (token) => typeof token === 'object' && token.type === TagType.TEMPLATE &&\n        token.index === templateIndex && token.ctx === ctx;\n}\nfunction serializePlaceholderValue(value) {\n    const element = (data, closed) => wrapTag('#', data, closed);\n    const template = (data, closed) => wrapTag('*', data, closed);\n    switch (value.type) {\n        case TagType.ELEMENT:\n            // close element tag\n            if (value.closed) {\n                return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n            }\n            // open element tag that also initiates a template\n            if (value.tmpl) {\n                return template(value.tmpl) + element(value) +\n                    (value.isVoid ? template(value.tmpl, true) : '');\n            }\n            return element(value);\n        case TagType.TEMPLATE:\n            return template(value, value.closed);\n        default:\n            return value;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass IcuSerializerVisitor {\n    visitText(text) {\n        return text.value;\n    }\n    visitContainer(container) {\n        return container.children.map(child => child.visit(this)).join('');\n    }\n    visitIcu(icu) {\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n        return result;\n    }\n    visitTagPlaceholder(ph) {\n        return ph.isVoid ?\n            this.formatPh(ph.startName) :\n            `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n    }\n    visitPlaceholder(ph) {\n        return this.formatPh(ph.name);\n    }\n    visitIcuPlaceholder(ph, context) {\n        return this.formatPh(ph.name);\n    }\n    formatPh(value) {\n        return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;\n    }\n}\nconst serializer = new IcuSerializerVisitor();\nfunction serializeIcuNode(icu) {\n    return icu.visit(serializer);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n */\nclass PlaceholderRegistry {\n    constructor() {\n        // Count the occurrence of the base name top generate a unique name\n        this._placeHolderNameCounts = {};\n        // Maps signature to placeholder names\n        this._signatureToName = {};\n    }\n    getStartTagPlaceholderName(tag, attrs, isVoid) {\n        const signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const upperTag = tag.toUpperCase();\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n        const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n        this._signatureToName[signature] = name;\n        return name;\n    }\n    getCloseTagPlaceholderName(tag) {\n        const signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const upperTag = tag.toUpperCase();\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n        const name = this._generateUniqueName(`CLOSE_${baseName}`);\n        this._signatureToName[signature] = name;\n        return name;\n    }\n    getPlaceholderName(name, content) {\n        const upperName = name.toUpperCase();\n        const signature = `PH: ${upperName}=${content}`;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    }\n    getUniquePlaceholder(name) {\n        return this._generateUniqueName(name.toUpperCase());\n    }\n    // Generate a hash for a tag - does not take attribute order into account\n    _hashTag(tag, attrs, isVoid) {\n        const start = `<${tag}`;\n        const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\n        const end = isVoid ? '/>' : `></${tag}>`;\n        return start + strAttrs + end;\n    }\n    _hashClosingTag(tag) {\n        return this._hashTag(`/${tag}`, {}, false);\n    }\n    _generateUniqueName(base) {\n        const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        const id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return `${base}_${id}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _expParser = new Parser$1(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nfunction createI18nMessageFactory(interpolationConfig) {\n    const visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\nfunction noopVisitNodeFn(_html, i18n) {\n    return i18n;\n}\nclass _I18nVisitor {\n    constructor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {\n        const context = {\n            isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\n            icuDepth: 0,\n            placeholderRegistry: new PlaceholderRegistry(),\n            placeholderToContent: {},\n            placeholderToMessage: {},\n            visitNodeFn: visitNodeFn || noopVisitNodeFn,\n        };\n        const i18nodes = visitAll(this, nodes, context);\n        return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n    }\n    visitElement(el, context) {\n        var _a;\n        const children = visitAll(this, el.children, context);\n        const attrs = {};\n        el.attrs.forEach(attr => {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        const isVoid = getHtmlTagDefinition(el.name).isVoid;\n        const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        context.placeholderToContent[startPhName] = {\n            text: el.startSourceSpan.toString(),\n            sourceSpan: el.startSourceSpan,\n        };\n        let closePhName = '';\n        if (!isVoid) {\n            closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            context.placeholderToContent[closePhName] = {\n                text: `</${el.name}>`,\n                sourceSpan: (_a = el.endSourceSpan) !== null && _a !== void 0 ? _a : el.sourceSpan,\n            };\n        }\n        const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        return context.visitNodeFn(el, node);\n    }\n    visitAttribute(attribute, context) {\n        const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ?\n            new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) :\n            this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\n        return context.visitNodeFn(attribute, node);\n    }\n    visitText(text, context) {\n        const node = text.tokens.length === 1 ?\n            new Text$2(text.value, text.sourceSpan) :\n            this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n        return context.visitNodeFn(text, node);\n    }\n    visitComment(comment, context) {\n        return null;\n    }\n    visitExpansion(icu, context) {\n        context.icuDepth++;\n        const i18nIcuCases = {};\n        const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach((caze) => {\n            i18nIcuCases[caze.value] = new Container(caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);\n        });\n        context.icuDepth--;\n        if (context.isIcu || context.icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n            i18nIcu.expressionPlaceholder = expPh;\n            context.placeholderToContent[expPh] = {\n                text: icu.switchValue,\n                sourceSpan: icu.switchValueSourceSpan,\n            };\n            return context.visitNodeFn(icu, i18nIcu);\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n        const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n        return context.visitNodeFn(icu, node);\n    }\n    visitExpansionCase(_icuCase, _context) {\n        throw new Error('Unreachable code');\n    }\n    /**\n     * Convert, text and interpolated tokens up into text and placeholder pieces.\n     *\n     * @param tokens The text and interpolated tokens.\n     * @param sourceSpan The span of the whole of the `text` string.\n     * @param context The current context of the visitor, used to compute and store placeholders.\n     * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n     */\n    _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {\n        // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n        const nodes = [];\n        // We will only create a container if there are actually interpolations,\n        // so this flag tracks that.\n        let hasInterpolation = false;\n        for (const token of tokens) {\n            switch (token.type) {\n                case 8 /* TokenType.INTERPOLATION */:\n                case 17 /* TokenType.ATTR_VALUE_INTERPOLATION */:\n                    hasInterpolation = true;\n                    const expression = token.parts[1];\n                    const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n                    const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n                    context.placeholderToContent[phName] = {\n                        text: token.parts.join(''),\n                        sourceSpan: token.sourceSpan\n                    };\n                    nodes.push(new Placeholder(expression, phName, token.sourceSpan));\n                    break;\n                default:\n                    if (token.parts[0].length > 0) {\n                        // This token is text or an encoded entity.\n                        // If it is following on from a previous text node then merge it into that node\n                        // Otherwise, if it is following an interpolation, then add a new node.\n                        const previous = nodes[nodes.length - 1];\n                        if (previous instanceof Text$2) {\n                            previous.value += token.parts[0];\n                            previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);\n                        }\n                        else {\n                            nodes.push(new Text$2(token.parts[0], token.sourceSpan));\n                        }\n                    }\n                    break;\n            }\n        }\n        if (hasInterpolation) {\n            // Whitespace removal may have invalidated the interpolation source-spans.\n            reusePreviousSourceSpans(nodes, previousI18n);\n            return new Container(nodes, sourceSpan);\n        }\n        else {\n            return nodes[0];\n        }\n    }\n}\n/**\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n *\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n * reuse the source-span stored from a previous pass before the whitespace was removed.\n *\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n */\nfunction reusePreviousSourceSpans(nodes, previousI18n) {\n    if (previousI18n instanceof Message) {\n        // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n        // metadata. The `Message` should consist only of a single `Container` that contains the\n        // parts (`Text` and `Placeholder`) to process.\n        assertSingleContainerMessage(previousI18n);\n        previousI18n = previousI18n.nodes[0];\n    }\n    if (previousI18n instanceof Container) {\n        // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n        // after whitespace has been removed from the AST nodes.\n        assertEquivalentNodes(previousI18n.children, nodes);\n        // Reuse the source-spans from the first pass.\n        for (let i = 0; i < nodes.length; i++) {\n            nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n        }\n    }\n}\n/**\n * Asserts that the `message` contains exactly one `Container` node.\n */\nfunction assertSingleContainerMessage(message) {\n    const nodes = message.nodes;\n    if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {\n        throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n    }\n}\n/**\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n * corresponding elements have the same node type.\n */\nfunction assertEquivalentNodes(previousNodes, nodes) {\n    if (previousNodes.length !== nodes.length) {\n        throw new Error('The number of i18n message children changed between first and second pass.');\n    }\n    if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n        throw new Error('The types of the i18n message children changed between first and second pass.');\n    }\n}\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\nfunction extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An i18n error.\n */\nclass I18nError extends ParseError {\n    constructor(span, msg) {\n        super(span, msg);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst setI18nRefs = (htmlNode, i18nNode) => {\n    if (htmlNode instanceof NodeWithI18n) {\n        if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {\n            // This html node represents an ICU but this is a second processing pass, and the legacy id\n            // was computed in the previous pass and stored in the `i18n` property as a message.\n            // We are about to wipe out that property so capture the previous message to be reused when\n            // generating the message for this ICU later. See `_generateI18nMessage()`.\n            i18nNode.previousMessage = htmlNode.i18n;\n        }\n        htmlNode.i18n = i18nNode;\n    }\n    return i18nNode;\n};\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\nclass I18nMetaVisitor {\n    constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {\n        this.interpolationConfig = interpolationConfig;\n        this.keepI18nAttrs = keepI18nAttrs;\n        this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n        // whether visited nodes contain i18n information\n        this.hasI18nMeta = false;\n        this._errors = [];\n        // i18n message generation factory\n        this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\n    }\n    _generateI18nMessage(nodes, meta = '', visitNodeFn) {\n        const { meaning, description, customId } = this._parseMetadata(meta);\n        const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n        this._setMessageId(message, meta);\n        this._setLegacyIds(message, meta);\n        return message;\n    }\n    visitAllWithErrors(nodes) {\n        const result = nodes.map(node => node.visit(this, null));\n        return new ParseTreeResult(result, this._errors);\n    }\n    visitElement(element) {\n        let message = undefined;\n        if (hasI18nAttrs(element)) {\n            this.hasI18nMeta = true;\n            const attrs = [];\n            const attrsMeta = {};\n            for (const attr of element.attrs) {\n                if (attr.name === I18N_ATTR) {\n                    // root 'i18n' node attribute\n                    const i18n = element.i18n || attr.value;\n                    message = this._generateI18nMessage(element.children, i18n, setI18nRefs);\n                    if (message.nodes.length === 0) {\n                        // Ignore the message if it is empty.\n                        message = undefined;\n                    }\n                    // Store the message on the element\n                    element.i18n = message;\n                }\n                else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n                    // 'i18n-*' attributes\n                    const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n                    if (isTrustedTypesSink(element.name, name)) {\n                        this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);\n                    }\n                    else {\n                        attrsMeta[name] = attr.value;\n                    }\n                }\n                else {\n                    // non-i18n attributes\n                    attrs.push(attr);\n                }\n            }\n            // set i18n meta for attributes\n            if (Object.keys(attrsMeta).length) {\n                for (const attr of attrs) {\n                    const meta = attrsMeta[attr.name];\n                    // do not create translation for empty attributes\n                    if (meta !== undefined && attr.value) {\n                        attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n                    }\n                }\n            }\n            if (!this.keepI18nAttrs) {\n                // update element's attributes,\n                // keeping only non-i18n related ones\n                element.attrs = attrs;\n            }\n        }\n        visitAll(this, element.children, message);\n        return element;\n    }\n    visitExpansion(expansion, currentMessage) {\n        let message;\n        const meta = expansion.i18n;\n        this.hasI18nMeta = true;\n        if (meta instanceof IcuPlaceholder) {\n            // set ICU placeholder name (e.g. \"ICU_1\"),\n            // generated while processing root element contents,\n            // so we can reference it when we output translation\n            const name = meta.name;\n            message = this._generateI18nMessage([expansion], meta);\n            const icu = icuFromI18nMessage(message);\n            icu.name = name;\n            if (currentMessage !== null) {\n                // Also update the placeholderToMessage map with this new message\n                currentMessage.placeholderToMessage[name] = message;\n            }\n        }\n        else {\n            // ICU is a top level message, try to use metadata from container element if provided via\n            // `context` argument. Note: context may not be available for standalone ICUs (without\n            // wrapping element), so fallback to ICU metadata in this case.\n            message = this._generateI18nMessage([expansion], currentMessage || meta);\n        }\n        expansion.i18n = message;\n        return expansion;\n    }\n    visitText(text) {\n        return text;\n    }\n    visitAttribute(attribute) {\n        return attribute;\n    }\n    visitComment(comment) {\n        return comment;\n    }\n    visitExpansionCase(expansionCase) {\n        return expansionCase;\n    }\n    /**\n     * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n     * `Message`.\n     *\n     * There are three possibilities for the `meta` variable\n     * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n     * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n     * 4) other: ignore this and just process the message metadata as normal\n     *\n     * @param meta the bucket that holds information about the message\n     * @returns the parsed metadata.\n     */\n    _parseMetadata(meta) {\n        return typeof meta === 'string' ? parseI18nMeta(meta) :\n            meta instanceof Message ? meta :\n                {};\n    }\n    /**\n     * Generate (or restore) message id if not specified already.\n     */\n    _setMessageId(message, meta) {\n        if (!message.id) {\n            message.id = meta instanceof Message && meta.id || decimalDigest(message);\n        }\n    }\n    /**\n     * Update the `message` with a `legacyId` if necessary.\n     *\n     * @param message the message whose legacy id should be set\n     * @param meta information about the message being processed\n     */\n    _setLegacyIds(message, meta) {\n        if (this.enableI18nLegacyMessageIdFormat) {\n            message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n        }\n        else if (typeof meta !== 'string') {\n            // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n            // `packages/compiler/src/render3/view/template.ts`).\n            // In that case we want to reuse the legacy message generated in the 1st pass (see\n            // `setI18nRefs()`).\n            const previousMessage = meta instanceof Message ? meta :\n                meta instanceof IcuPlaceholder ? meta.previousMessage :\n                    undefined;\n            message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n        }\n    }\n    _reportError(node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    }\n}\n/** I18n separators for metadata **/\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\nfunction parseI18nMeta(meta = '') {\n    let customId;\n    let meaning;\n    let description;\n    meta = meta.trim();\n    if (meta) {\n        const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n        const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n        let meaningAndDesc;\n        [meaningAndDesc, customId] =\n            (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n        [meaning, description] = (descIndex > -1) ?\n            [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n            ['', meaningAndDesc];\n    }\n    return { customId, meaning, description };\n}\n// Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nfunction i18nMetaToJSDoc(meta) {\n    const tags = [];\n    if (meta.description) {\n        tags.push({ tagName: \"desc\" /* o.JSDocTagName.Desc */, text: meta.description });\n    }\n    else {\n        // Suppress the JSCompiler warning that a `@desc` was not given for this message.\n        tags.push({ tagName: \"suppress\" /* o.JSDocTagName.Suppress */, text: '{msgDescriptions}' });\n    }\n    if (meta.meaning) {\n        tags.push({ tagName: \"meaning\" /* o.JSDocTagName.Meaning */, text: meta.meaning });\n    }\n    return jsDocComment(tags);\n}\n\n/** Closure uses `goog.getMsg(message)` to lookup translations */\nconst GOOG_GET_MSG = 'goog.getMsg';\n/**\n * Generates a `goog.getMsg()` statement and reassignment. The template:\n *\n * ```html\n * <div i18n>Sent from {{ sender }} to <span class=\"receiver\">{{ receiver }}</span></div>\n * ```\n *\n * Generates:\n *\n * ```typescript\n * const MSG_FOO = goog.getMsg(\n *   // Message template.\n *   'Sent from {$interpolation} to {$startTagSpan}{$interpolation_1}{$closeTagSpan}.',\n *   // Placeholder values, set to magic strings which get replaced by the Angular runtime.\n *   {\n *     'interpolation': '\\uFFFD0\\uFFFD',\n *     'startTagSpan': '\\uFFFD1\\uFFFD',\n *     'interpolation_1': '\\uFFFD2\\uFFFD',\n *     'closeTagSpan': '\\uFFFD3\\uFFFD',\n *   },\n *   // Options bag.\n *   {\n *     // Maps each placeholder to the original Angular source code which generates it's value.\n *     original_code: {\n *       'interpolation': '{{ sender }}',\n *       'startTagSpan': '<span class=\"receiver\">',\n *       'interploation_1': '{{ receiver }}',\n *       'closeTagSpan': '</span>',\n *     },\n *   },\n * );\n * const I18N_0 = MSG_FOO;\n * ```\n */\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, placeholderValues) {\n    const messageString = serializeI18nMessageForGetMsg(message);\n    const args = [literal(messageString)];\n    if (Object.keys(placeholderValues).length) {\n        // Message template parameters containing the magic strings replaced by the Angular runtime with\n        // real data, e.g. `{'interpolation': '\\uFFFD0\\uFFFD'}`.\n        args.push(mapLiteral(formatI18nPlaceholderNamesInMap(placeholderValues, true /* useCamelCase */), true /* quoted */));\n        // Message options object, which contains original source code for placeholders (as they are\n        // present in a template, e.g.\n        // `{original_code: {'interpolation': '{{ name }}', 'startTagSpan': '<span>'}}`.\n        args.push(mapLiteral({\n            original_code: literalMap(Object.keys(placeholderValues)\n                .map((param) => ({\n                key: formatI18nPlaceholderName(param),\n                quoted: true,\n                value: message.placeholders[param] ?\n                    // Get source span for typical placeholder if it exists.\n                    literal(message.placeholders[param].sourceSpan.toString()) :\n                    // Otherwise must be an ICU expression, get it's source span.\n                    literal(message.placeholderToMessage[param]\n                        .nodes.map((node) => node.sourceSpan.toString())\n                        .join('')),\n            }))),\n        }));\n    }\n    // /**\n    //  * @desc description of message\n    //  * @meaning meaning of message\n    //  */\n    // const MSG_... = goog.getMsg(..);\n    // I18N_X = MSG_...;\n    const googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();\n    googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));\n    const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));\n    return [googGetMsgStmt, i18nAssignmentStmt];\n}\n/**\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\n */\nclass GetMsgSerializerVisitor {\n    formatPh(value) {\n        return `{$${formatI18nPlaceholderName(value)}}`;\n    }\n    visitText(text) {\n        return text.value;\n    }\n    visitContainer(container) {\n        return container.children.map(child => child.visit(this)).join('');\n    }\n    visitIcu(icu) {\n        return serializeIcuNode(icu);\n    }\n    visitTagPlaceholder(ph) {\n        return ph.isVoid ?\n            this.formatPh(ph.startName) :\n            `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n    }\n    visitPlaceholder(ph) {\n        return this.formatPh(ph.name);\n    }\n    visitIcuPlaceholder(ph, context) {\n        return this.formatPh(ph.name);\n    }\n}\nconst serializerVisitor = new GetMsgSerializerVisitor();\nfunction serializeI18nMessageForGetMsg(message) {\n    return message.nodes.map(node => node.visit(serializerVisitor, null)).join('');\n}\n\nfunction createLocalizeStatements(variable, message, params) {\n    const { messageParts, placeHolders } = serializeI18nMessageForLocalize(message);\n    const sourceSpan = getSourceSpan(message);\n    const expressions = placeHolders.map(ph => params[ph.text]);\n    const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n    const variableInitialization = variable.set(localizedString$1);\n    return [new ExpressionStatement(variableInitialization)];\n}\n/**\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n *\n * The result can be used for generating the `$localize` tagged template literals.\n */\nclass LocalizeSerializerVisitor {\n    constructor(placeholderToMessage, pieces) {\n        this.placeholderToMessage = placeholderToMessage;\n        this.pieces = pieces;\n    }\n    visitText(text) {\n        if (this.pieces[this.pieces.length - 1] instanceof LiteralPiece) {\n            // Two literal pieces in a row means that there was some comment node in-between.\n            this.pieces[this.pieces.length - 1].text += text.value;\n        }\n        else {\n            const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);\n            this.pieces.push(new LiteralPiece(text.value, sourceSpan));\n        }\n    }\n    visitContainer(container) {\n        container.children.forEach(child => child.visit(this));\n    }\n    visitIcu(icu) {\n        this.pieces.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n    }\n    visitTagPlaceholder(ph) {\n        var _a, _b;\n        this.pieces.push(this.createPlaceholderPiece(ph.startName, (_a = ph.startSourceSpan) !== null && _a !== void 0 ? _a : ph.sourceSpan));\n        if (!ph.isVoid) {\n            ph.children.forEach(child => child.visit(this));\n            this.pieces.push(this.createPlaceholderPiece(ph.closeName, (_b = ph.endSourceSpan) !== null && _b !== void 0 ? _b : ph.sourceSpan));\n        }\n    }\n    visitPlaceholder(ph) {\n        this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n    }\n    visitIcuPlaceholder(ph) {\n        this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));\n    }\n    createPlaceholderPiece(name, sourceSpan, associatedMessage) {\n        return new PlaceholderPiece(formatI18nPlaceholderName(name, /* useCamelCase */ false), sourceSpan, associatedMessage);\n    }\n}\n/**\n * Serialize an i18n message into two arrays: messageParts and placeholders.\n *\n * These arrays will be used to generate `$localize` tagged template literals.\n *\n * @param message The message to be serialized.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction serializeI18nMessageForLocalize(message) {\n    const pieces = [];\n    const serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);\n    message.nodes.forEach(node => node.visit(serializerVisitor));\n    return processMessagePieces(pieces);\n}\nfunction getSourceSpan(message) {\n    const startNode = message.nodes[0];\n    const endNode = message.nodes[message.nodes.length - 1];\n    return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);\n}\n/**\n * Convert the list of serialized MessagePieces into two arrays.\n *\n * One contains the literal string pieces and the other the placeholders that will be replaced by\n * expressions when rendering `$localize` tagged template literals.\n *\n * @param pieces The pieces to process.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction processMessagePieces(pieces) {\n    const messageParts = [];\n    const placeHolders = [];\n    if (pieces[0] instanceof PlaceholderPiece) {\n        // The first piece was a placeholder so we need to add an initial empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n    }\n    for (let i = 0; i < pieces.length; i++) {\n        const part = pieces[i];\n        if (part instanceof LiteralPiece) {\n            messageParts.push(part);\n        }\n        else {\n            placeHolders.push(part);\n            if (pieces[i - 1] instanceof PlaceholderPiece) {\n                // There were two placeholders in a row, so we need to add an empty message part.\n                messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n            }\n        }\n    }\n    if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\n        // The last piece was a placeholder so we need to add a final empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n    }\n    return { messageParts, placeHolders };\n}\nfunction createEmptyMessagePart(location) {\n    return new LiteralPiece('', new ParseSourceSpan(location, location));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Selector attribute name of `<ng-content>`\nconst NG_CONTENT_SELECT_ATTR = 'select';\n// Attribute name of `ngProjectAs`.\nconst NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n// Global symbols available only inside event bindings.\nconst EVENT_BINDING_SCOPE_GLOBALS = new Set(['$event']);\n// List of supported global targets for event listeners\nconst GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);\nconst LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n//  if (rf & flags) { .. }\nfunction renderFlagCheckIfStmt(flags, statements) {\n    return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);\n}\nfunction prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {\n    const { type, name, target, phase, handler } = eventAst;\n    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n        throw new Error(`Unexpected global target '${target}' defined for '${name}' event.\n        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);\n    }\n    const eventArgumentName = '$event';\n    const implicitReceiverAccesses = new Set();\n    const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\n        variable(CONTEXT_NAME) :\n        scope.getOrCreateSharedContextVar(0);\n    const bindingStatements = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);\n    const statements = [];\n    const variableDeclarations = scope === null || scope === void 0 ? void 0 : scope.variableDeclarations();\n    const restoreViewStatement = scope === null || scope === void 0 ? void 0 : scope.restoreViewStatement();\n    if (variableDeclarations) {\n        // `variableDeclarations` needs to run first, because\n        // `restoreViewStatement` depends on the result.\n        statements.push(...variableDeclarations);\n    }\n    statements.push(...bindingStatements);\n    if (restoreViewStatement) {\n        statements.unshift(restoreViewStatement);\n        // If there's a `restoreView` call, we need to reset the view at the end of the listener\n        // in order to avoid a leak. If there's a `return` statement already, we wrap it in the\n        // call, e.g. `return resetView(ctx.foo())`. Otherwise we add the call as the last statement.\n        const lastStatement = statements[statements.length - 1];\n        if (lastStatement instanceof ReturnStatement) {\n            statements[statements.length - 1] = new ReturnStatement(invokeInstruction(lastStatement.value.sourceSpan, Identifiers.resetView, [lastStatement.value]));\n        }\n        else {\n            statements.push(new ExpressionStatement(invokeInstruction(null, Identifiers.resetView, [])));\n        }\n    }\n    const eventName = type === 1 /* ParsedEventType.Animation */ ? prepareSyntheticListenerName(name, phase) : name;\n    const fnName = handlerName && sanitizeIdentifier(handlerName);\n    const fnArgs = [];\n    if (implicitReceiverAccesses.has(eventArgumentName)) {\n        fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));\n    }\n    const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);\n    const params = [literal(eventName), handlerFn];\n    if (target) {\n        params.push(literal(false), // `useCapture` flag, defaults to `false`\n        importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));\n    }\n    return params;\n}\nfunction createComponentDefConsts() {\n    return {\n        prepareStatements: [],\n        constExpressions: [],\n        i18nVarRefsCache: new Map(),\n    };\n}\nclass TemplateDefinitionBuilder {\n    constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = createComponentDefConsts()) {\n        this.constantPool = constantPool;\n        this.level = level;\n        this.contextName = contextName;\n        this.i18nContext = i18nContext;\n        this.templateIndex = templateIndex;\n        this.templateName = templateName;\n        this._namespace = _namespace;\n        this.i18nUseExternalIds = i18nUseExternalIds;\n        this._constants = _constants;\n        this._dataIndex = 0;\n        this._bindingContext = 0;\n        this._prefixCode = [];\n        /**\n         * List of callbacks to generate creation mode instructions. We store them here as we process\n         * the template so bindings in listeners are resolved only once all nodes have been visited.\n         * This ensures all local refs and context variables are available for matching.\n         */\n        this._creationCodeFns = [];\n        /**\n         * List of callbacks to generate update mode instructions. We store them here as we process\n         * the template so bindings are resolved only once all nodes have been visited. This ensures\n         * all local refs and context variables are available for matching.\n         */\n        this._updateCodeFns = [];\n        /** Index of the currently-selected node. */\n        this._currentIndex = 0;\n        /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n        this._tempVariables = [];\n        /**\n         * List of callbacks to build nested templates. Nested templates must not be visited until\n         * after the parent template has finished visiting all of its nodes. This ensures that all\n         * local ref bindings in nested templates are able to find local ref values if the refs\n         * are defined after the template declaration.\n         */\n        this._nestedTemplateFns = [];\n        // i18n context local to this template\n        this.i18n = null;\n        // Number of slots to reserve for pureFunctions\n        this._pureFunctionSlots = 0;\n        // Number of binding slots\n        this._bindingSlots = 0;\n        // Projection slots found in the template. Projection slots can distribute projected\n        // nodes based on a selector, or can just use the wildcard selector to match\n        // all nodes which aren't matching any selector.\n        this._ngContentReservedSlots = [];\n        // Number of non-default selectors found in all parent templates of this template. We need to\n        // track it to properly adjust projection slot index in the `projection` instruction.\n        this._ngContentSelectorsOffset = 0;\n        // Expression that should be used as implicit receiver when converting template\n        // expressions to output AST.\n        this._implicitReceiverExpr = null;\n        // These should be handled in the template or element directly.\n        this.visitReference = invalid;\n        this.visitVariable = invalid;\n        this.visitTextAttribute = invalid;\n        this.visitBoundAttribute = invalid;\n        this.visitBoundEvent = invalid;\n        this._bindingScope = parentBindingScope.nestedScope(level);\n        // Turn the relative context file path into an identifier by replacing non-alphanumeric\n        // characters with underscores.\n        this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n        this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {\n            this._bindingScope.set(this.level, localName, value);\n            this.creationInstruction(null, Identifiers.pipe, [literal(slot), literal(name)]);\n        });\n    }\n    buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {\n        this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n        if (this._namespace !== Identifiers.namespaceHTML) {\n            this.creationInstruction(null, this._namespace);\n        }\n        // Create variable bindings\n        variables.forEach(v => this.registerContextVariables(v));\n        // Initiate i18n context in case:\n        // - this template has parent i18n context\n        // - or the template has i18n meta associated with it,\n        //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n        const initI18nContext = this.i18nContext ||\n            (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&\n                !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));\n        const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n        if (initI18nContext) {\n            this.i18nStart(null, i18n, selfClosingI18nInstruction);\n        }\n        // This is the initial pass through the nodes of this template. In this pass, we\n        // queue all creation mode and update mode instructions for generation in the second\n        // pass. It's necessary to separate the passes to ensure local refs are defined before\n        // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n        visitAll$1(this, nodes);\n        // Add total binding count to pure function count so pure function instructions are\n        // generated with the correct slot offset when update instructions are processed.\n        this._pureFunctionSlots += this._bindingSlots;\n        // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n        // `pipeBind` update instructions), so we have to update the slot offsets manually\n        // to account for bindings.\n        this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\n        // Nested templates must be processed before creation instructions so template()\n        // instructions can be generated with the correct internal const count.\n        this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());\n        // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n        // The `projectionDef` instruction is only emitted for the component template and\n        // is skipped for nested templates (<ng-template> tags).\n        if (this.level === 0 && this._ngContentReservedSlots.length) {\n            const parameters = [];\n            // By default the `projectionDef` instructions creates one slot for the wildcard\n            // selector if no parameters are passed. Therefore we only want to allocate a new\n            // array for the projection slots if the default projection slot is not sufficient.\n            if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n                const r3ReservedSlots = this._ngContentReservedSlots.map(s => s !== '*' ? parseSelectorToR3Selector(s) : s);\n                parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n            }\n            // Since we accumulate ngContent selectors while processing template elements,\n            // we *prepend* `projectionDef` to creation instructions block, to put it before\n            // any `projection` instructions\n            this.creationInstruction(null, Identifiers.projectionDef, parameters, /* prepend */ true);\n        }\n        if (initI18nContext) {\n            this.i18nEnd(null, selfClosingI18nInstruction);\n        }\n        // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n        const creationStatements = getInstructionStatements(this._creationCodeFns);\n        // Generate all the update mode instructions (e.g. resolve property or text bindings)\n        const updateStatements = getInstructionStatements(this._updateCodeFns);\n        //  Variable declaration must occur after binding resolution so we can generate context\n        //  instructions that build on each other.\n        // e.g. const b = nextContext().$implicit(); const b = nextContext();\n        const creationVariables = this._bindingScope.viewSnapshotStatements();\n        const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n        const creationBlock = creationStatements.length > 0 ?\n            [renderFlagCheckIfStmt(1 /* core.RenderFlags.Create */, creationVariables.concat(creationStatements))] :\n            [];\n        const updateBlock = updateStatements.length > 0 ?\n            [renderFlagCheckIfStmt(2 /* core.RenderFlags.Update */, updateVariables.concat(updateStatements))] :\n            [];\n        return fn(\n        // i.e. (rf: RenderFlags, ctx: any)\n        [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\n            // Temporary variable declarations for query refresh (i.e. let _t: any;)\n            ...this._prefixCode,\n            // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })\n            ...creationBlock,\n            // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})\n            ...updateBlock,\n        ], INFERRED_TYPE, null, this.templateName);\n    }\n    // LocalResolver\n    getLocal(name) {\n        return this._bindingScope.get(name);\n    }\n    // LocalResolver\n    notifyImplicitReceiverUse() {\n        this._bindingScope.notifyImplicitReceiverUse();\n    }\n    // LocalResolver\n    maybeRestoreView() {\n        this._bindingScope.maybeRestoreView();\n    }\n    i18nTranslate(message, params = {}, ref, transformFn) {\n        const _ref = ref || this.i18nGenerateMainBlockVar();\n        // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n        // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n        const closureVar = this.i18nGenerateClosureVar(message.id);\n        const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n        this._constants.prepareStatements.push(...statements);\n        return _ref;\n    }\n    registerContextVariables(variable$1) {\n        const scopedName = this._bindingScope.freshReferenceName();\n        const retrievalLevel = this.level;\n        const lhs = variable(variable$1.name + scopedName);\n        this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1 /* DeclarationPriority.CONTEXT */, (scope, relativeLevel) => {\n            let rhs;\n            if (scope.bindingLevel === retrievalLevel) {\n                if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {\n                    // e.g. restoredCtx.\n                    // We have to get the context from a view reference, if one is available, because\n                    // the context that was passed in during creation may not be correct anymore.\n                    // For more information see: https://github.com/angular/angular/pull/40360.\n                    rhs = variable(RESTORED_VIEW_CONTEXT_NAME);\n                    scope.notifyRestoredViewContextUse();\n                }\n                else {\n                    // e.g. ctx\n                    rhs = variable(CONTEXT_NAME);\n                }\n            }\n            else {\n                const sharedCtxVar = scope.getSharedContextName(retrievalLevel);\n                // e.g. ctx_r0   OR  x(2);\n                rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n            }\n            // e.g. const $item$ = x(2).$implicit;\n            return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];\n        });\n    }\n    i18nAppendBindings(expressions) {\n        if (expressions.length > 0) {\n            expressions.forEach(expression => this.i18n.appendBinding(expression));\n        }\n    }\n    i18nBindProps(props) {\n        const bound = {};\n        Object.keys(props).forEach(key => {\n            const prop = props[key];\n            if (prop instanceof Text$3) {\n                bound[key] = literal(prop.value);\n            }\n            else {\n                const value = prop.value.visit(this._valueConverter);\n                this.allocateBindingSlots(value);\n                if (value instanceof Interpolation) {\n                    const { strings, expressions } = value;\n                    const { id, bindings } = this.i18n;\n                    const label = assembleI18nBoundString(strings, bindings.size, id);\n                    this.i18nAppendBindings(expressions);\n                    bound[key] = literal(label);\n                }\n            }\n        });\n        return bound;\n    }\n    // Generates top level vars for i18n blocks (i.e. `i18n_N`).\n    i18nGenerateMainBlockVar() {\n        return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));\n    }\n    // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n    i18nGenerateClosureVar(messageId) {\n        let name;\n        const suffix = this.fileBasedI18nSuffix.toUpperCase();\n        if (this.i18nUseExternalIds) {\n            const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n            const uniqueSuffix = this.constantPool.uniqueName(suffix);\n            name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n        }\n        else {\n            const prefix = getTranslationConstPrefix(suffix);\n            name = this.constantPool.uniqueName(prefix);\n        }\n        return variable(name);\n    }\n    i18nUpdateRef(context) {\n        const { icus, meta, isRoot, isResolved, isEmitted } = context;\n        if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n            context.isEmitted = true;\n            const placeholders = context.getSerializedPlaceholders();\n            let icuMapping = {};\n            let params = placeholders.size ? placeholdersToParams(placeholders) : {};\n            if (icus.size) {\n                icus.forEach((refs, key) => {\n                    if (refs.length === 1) {\n                        // if we have one ICU defined for a given\n                        // placeholder - just output its reference\n                        params[key] = refs[0];\n                    }\n                    else {\n                        // ... otherwise we need to activate post-processing\n                        // to replace ICU placeholders with proper values\n                        const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);\n                        params[key] = literal(placeholder);\n                        icuMapping[key] = literalArr(refs);\n                    }\n                });\n            }\n            // translation requires post processing in 2 cases:\n            // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])\n            // - if we have multiple ICUs that refer to the same placeholder name\n            const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) ||\n                Object.keys(icuMapping).length;\n            let transformFn;\n            if (needsPostprocessing) {\n                transformFn = (raw) => {\n                    const args = [raw];\n                    if (Object.keys(icuMapping).length) {\n                        args.push(mapLiteral(icuMapping, true));\n                    }\n                    return invokeInstruction(null, Identifiers.i18nPostprocess, args);\n                };\n            }\n            this.i18nTranslate(meta, params, context.ref, transformFn);\n        }\n    }\n    i18nStart(span = null, meta, selfClosing) {\n        const index = this.allocateDataSlot();\n        this.i18n = this.i18nContext ?\n            this.i18nContext.forkChildContext(index, this.templateIndex, meta) :\n            new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);\n        // generate i18nStart instruction\n        const { id, ref } = this.i18n;\n        const params = [literal(index), this.addToConsts(ref)];\n        if (id > 0) {\n            // do not push 3rd argument (sub-block id)\n            // into i18nStart call for top level i18n context\n            params.push(literal(id));\n        }\n        this.creationInstruction(span, selfClosing ? Identifiers.i18n : Identifiers.i18nStart, params);\n    }\n    i18nEnd(span = null, selfClosing) {\n        if (!this.i18n) {\n            throw new Error('i18nEnd is executed with no i18n context present');\n        }\n        if (this.i18nContext) {\n            this.i18nContext.reconcileChildContext(this.i18n);\n            this.i18nUpdateRef(this.i18nContext);\n        }\n        else {\n            this.i18nUpdateRef(this.i18n);\n        }\n        // setup accumulated bindings\n        const { index, bindings } = this.i18n;\n        if (bindings.size) {\n            for (const binding of bindings) {\n                // for i18n block, advance to the most recent element index (by taking the current number of\n                // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n                // necessary lifecycle hooks of components/directives are properly flushed.\n                this.updateInstructionWithAdvance(this.getConstCount() - 1, span, Identifiers.i18nExp, () => this.convertPropertyBinding(binding));\n            }\n            this.updateInstruction(span, Identifiers.i18nApply, [literal(index)]);\n        }\n        if (!selfClosing) {\n            this.creationInstruction(span, Identifiers.i18nEnd);\n        }\n        this.i18n = null; // reset local i18n context\n    }\n    i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {\n        let hasBindings = false;\n        const i18nAttrArgs = [];\n        attrs.forEach(attr => {\n            const message = attr.i18n;\n            const converted = attr.value.visit(this._valueConverter);\n            this.allocateBindingSlots(converted);\n            if (converted instanceof Interpolation) {\n                const placeholders = assembleBoundTextPlaceholders(message);\n                const params = placeholdersToParams(placeholders);\n                i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));\n                converted.expressions.forEach(expression => {\n                    hasBindings = true;\n                    this.updateInstructionWithAdvance(nodeIndex, sourceSpan, Identifiers.i18nExp, () => this.convertPropertyBinding(expression));\n                });\n            }\n        });\n        if (i18nAttrArgs.length > 0) {\n            const index = literal(this.allocateDataSlot());\n            const constIndex = this.addToConsts(literalArr(i18nAttrArgs));\n            this.creationInstruction(sourceSpan, Identifiers.i18nAttributes, [index, constIndex]);\n            if (hasBindings) {\n                this.updateInstruction(sourceSpan, Identifiers.i18nApply, [index]);\n            }\n        }\n    }\n    getNamespaceInstruction(namespaceKey) {\n        switch (namespaceKey) {\n            case 'math':\n                return Identifiers.namespaceMathML;\n            case 'svg':\n                return Identifiers.namespaceSVG;\n            default:\n                return Identifiers.namespaceHTML;\n        }\n    }\n    addNamespaceInstruction(nsInstruction, element) {\n        this._namespace = nsInstruction;\n        this.creationInstruction(element.startSourceSpan, nsInstruction);\n    }\n    /**\n     * Adds an update instruction for an interpolated property or attribute, such as\n     * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n     */\n    interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {\n        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);\n    }\n    visitContent(ngContent) {\n        const slot = this.allocateDataSlot();\n        const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n        const parameters = [literal(slot)];\n        this._ngContentReservedSlots.push(ngContent.selector);\n        const nonContentSelectAttributes = ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR);\n        const attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);\n        if (attributes.length > 0) {\n            parameters.push(literal(projectionSlotIdx), literalArr(attributes));\n        }\n        else if (projectionSlotIdx !== 0) {\n            parameters.push(literal(projectionSlotIdx));\n        }\n        this.creationInstruction(ngContent.sourceSpan, Identifiers.projection, parameters);\n        if (this.i18n) {\n            this.i18n.appendProjection(ngContent.i18n, slot);\n        }\n    }\n    visitElement(element) {\n        var _a, _b;\n        const elementIndex = this.allocateDataSlot();\n        const stylingBuilder = new StylingBuilder(null);\n        let isNonBindableMode = false;\n        const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n        const outputAttrs = [];\n        const [namespaceKey, elementName] = splitNsName(element.name);\n        const isNgContainer$1 = isNgContainer(element.name);\n        // Handle styling, i18n, ngNonBindable attributes\n        for (const attr of element.attributes) {\n            const { name, value } = attr;\n            if (name === NON_BINDABLE_ATTR) {\n                isNonBindableMode = true;\n            }\n            else if (name === 'style') {\n                stylingBuilder.registerStyleAttr(value);\n            }\n            else if (name === 'class') {\n                stylingBuilder.registerClassAttr(value);\n            }\n            else {\n                outputAttrs.push(attr);\n            }\n        }\n        // Regular element or ng-container creation mode\n        const parameters = [literal(elementIndex)];\n        if (!isNgContainer$1) {\n            parameters.push(literal(elementName));\n        }\n        // Add the attributes\n        const allOtherInputs = [];\n        const boundI18nAttrs = [];\n        element.inputs.forEach(input => {\n            const stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n            if (!stylingInputWasSet) {\n                if (input.type === 0 /* BindingType.Property */ && input.i18n) {\n                    boundI18nAttrs.push(input);\n                }\n                else {\n                    allOtherInputs.push(input);\n                }\n            }\n        });\n        // add attributes for directive and projection matching purposes\n        const attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);\n        parameters.push(this.addAttrsToConsts(attributes));\n        // local refs (ex.: <div #foo #bar=\"baz\">)\n        const refs = this.prepareRefsArray(element.references);\n        parameters.push(this.addToConsts(refs));\n        const wasInNamespace = this._namespace;\n        const currentNamespace = this.getNamespaceInstruction(namespaceKey);\n        // If the namespace is changing now, include an instruction to change it\n        // during element creation.\n        if (currentNamespace !== wasInNamespace) {\n            this.addNamespaceInstruction(currentNamespace, element);\n        }\n        if (this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex);\n        }\n        // Note that we do not append text node instructions and ICUs inside i18n section,\n        // so we exclude them while calculating whether current element has children\n        const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :\n            element.children.length > 0;\n        const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&\n            element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;\n        const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n        if (createSelfClosingInstruction) {\n            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers.elementContainer : Identifiers.element, trimTrailingNulls(parameters));\n        }\n        else {\n            this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers.elementContainerStart : Identifiers.elementStart, trimTrailingNulls(parameters));\n            if (isNonBindableMode) {\n                this.creationInstruction(element.startSourceSpan, Identifiers.disableBindings);\n            }\n            if (boundI18nAttrs.length > 0) {\n                this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan);\n            }\n            // Generate Listeners (outputs)\n            if (element.outputs.length > 0) {\n                for (const outputAst of element.outputs) {\n                    this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter(element.name, outputAst, elementIndex));\n                }\n            }\n            // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n            // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n            if (isI18nRootElement) {\n                this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);\n            }\n        }\n        // the code here will collect all update-level styling instructions and add them to the\n        // update block of the template function AOT code. Instructions like `styleProp`,\n        // `styleMap`, `classMap`, `classProp`\n        // are all generated and assigned in the code below.\n        const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n        const limit = stylingInstructions.length - 1;\n        for (let i = 0; i <= limit; i++) {\n            const instruction = stylingInstructions[i];\n            this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);\n        }\n        // the reason why `undefined` is used is because the renderer understands this as a\n        // special value to symbolize that there is no RHS to this binding\n        // TODO (matsko): revisit this once FW-959 is approached\n        const emptyValueBindInstruction = literal(undefined);\n        const propertyBindings = [];\n        const attributeBindings = [];\n        // Generate element input bindings\n        allOtherInputs.forEach(input => {\n            const inputType = input.type;\n            if (inputType === 4 /* BindingType.Animation */) {\n                const value = input.value.visit(this._valueConverter);\n                // animation bindings can be presented in the following formats:\n                // 1. [@binding]=\"fooExp\"\n                // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n                // 3. [@binding]\n                // 4. @binding\n                // All formats will be valid for when a synthetic binding is created.\n                // The reasoning for this is because the renderer should get each\n                // synthetic binding value in the order of the array that they are\n                // defined in...\n                const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;\n                this.allocateBindingSlots(value);\n                propertyBindings.push({\n                    span: input.sourceSpan,\n                    paramsOrFn: getBindingFunctionParams(() => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction, prepareSyntheticPropertyName(input.name))\n                });\n            }\n            else {\n                // we must skip attributes with associated i18n context, since these attributes are handled\n                // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n                if (input.i18n)\n                    return;\n                const value = input.value.visit(this._valueConverter);\n                if (value !== undefined) {\n                    const params = [];\n                    const [attrNamespace, attrName] = splitNsName(input.name);\n                    const isAttributeBinding = inputType === 1 /* BindingType.Attribute */;\n                    const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n                    if (sanitizationRef)\n                        params.push(sanitizationRef);\n                    if (attrNamespace) {\n                        const namespaceLiteral = literal(attrNamespace);\n                        if (sanitizationRef) {\n                            params.push(namespaceLiteral);\n                        }\n                        else {\n                            // If there wasn't a sanitization ref, we need to add\n                            // an extra param so that we can pass in the namespace.\n                            params.push(literal(null), namespaceLiteral);\n                        }\n                    }\n                    this.allocateBindingSlots(value);\n                    if (inputType === 0 /* BindingType.Property */) {\n                        if (value instanceof Interpolation) {\n                            // prop=\"{{value}}\" and friends\n                            this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);\n                        }\n                        else {\n                            // [prop]=\"value\"\n                            // Collect all the properties so that we can chain into a single function at the end.\n                            propertyBindings.push({\n                                span: input.sourceSpan,\n                                paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), attrName, params)\n                            });\n                        }\n                    }\n                    else if (inputType === 1 /* BindingType.Attribute */) {\n                        if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {\n                            // attr.name=\"text{{value}}\" and friends\n                            this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);\n                        }\n                        else {\n                            const boundValue = value instanceof Interpolation ? value.expressions[0] : value;\n                            // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n                            // Collect the attribute bindings so that they can be chained at the end.\n                            attributeBindings.push({\n                                span: input.sourceSpan,\n                                paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(boundValue), attrName, params)\n                            });\n                        }\n                    }\n                    else {\n                        // class prop\n                        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers.classProp, () => {\n                            return [\n                                literal(elementIndex), literal(attrName), this.convertPropertyBinding(value),\n                                ...params\n                            ];\n                        });\n                    }\n                }\n            }\n        });\n        for (const propertyBinding of propertyBindings) {\n            this.updateInstructionWithAdvance(elementIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);\n        }\n        for (const attributeBinding of attributeBindings) {\n            this.updateInstructionWithAdvance(elementIndex, attributeBinding.span, Identifiers.attribute, attributeBinding.paramsOrFn);\n        }\n        // Traverse element child nodes\n        visitAll$1(this, element.children);\n        if (!isI18nRootElement && this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex, true);\n        }\n        if (!createSelfClosingInstruction) {\n            // Finish element construction mode.\n            const span = (_b = element.endSourceSpan) !== null && _b !== void 0 ? _b : element.sourceSpan;\n            if (isI18nRootElement) {\n                this.i18nEnd(span, createSelfClosingI18nInstruction);\n            }\n            if (isNonBindableMode) {\n                this.creationInstruction(span, Identifiers.enableBindings);\n            }\n            this.creationInstruction(span, isNgContainer$1 ? Identifiers.elementContainerEnd : Identifiers.elementEnd);\n        }\n    }\n    visitTemplate(template) {\n        var _a;\n        const NG_TEMPLATE_TAG_NAME = 'ng-template';\n        const templateIndex = this.allocateDataSlot();\n        if (this.i18n) {\n            this.i18n.appendTemplate(template.i18n, templateIndex);\n        }\n        const tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;\n        const contextName = `${this.contextName}${template.tagName ? '_' + sanitizeIdentifier(template.tagName) : ''}_${templateIndex}`;\n        const templateName = `${contextName}_Template`;\n        const parameters = [\n            literal(templateIndex),\n            variable(templateName),\n            // We don't care about the tag's namespace here, because we infer\n            // it based on the parent nodes inside the template instruction.\n            literal(tagNameWithoutNamespace),\n        ];\n        // prepare attributes parameter (including attributes used for directive matching)\n        const attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, undefined /* styles */, template.templateAttrs);\n        parameters.push(this.addAttrsToConsts(attrsExprs));\n        // local refs (ex.: <ng-template #foo>)\n        if (template.references && template.references.length) {\n            const refs = this.prepareRefsArray(template.references);\n            parameters.push(this.addToConsts(refs));\n            parameters.push(importExpr(Identifiers.templateRefExtractor));\n        }\n        // Create the template function\n        const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);\n        // Nested templates must not be visited until after their parent templates have completed\n        // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n        // be able to support bindings in nested templates to local refs that occur after the\n        // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n        this._nestedTemplateFns.push(() => {\n            const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);\n            this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\n            if (templateVisitor._ngContentReservedSlots.length) {\n                this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);\n            }\n        });\n        // e.g. template(1, MyComp_Template_1)\n        this.creationInstruction(template.sourceSpan, Identifiers.templateCreate, () => {\n            parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));\n            return trimTrailingNulls(parameters);\n        });\n        // handle property bindings e.g. ɵɵproperty('ngForOf', ctx.items), et al;\n        this.templatePropertyBindings(templateIndex, template.templateAttrs);\n        // Only add normal input/output binding instructions on explicit <ng-template> elements.\n        if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {\n            const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);\n            // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n            // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n            // elements, in case of inline templates, corresponding instructions will be generated in the\n            // nested template function.\n            if (i18nInputs.length > 0) {\n                this.i18nAttributesInstruction(templateIndex, i18nInputs, (_a = template.startSourceSpan) !== null && _a !== void 0 ? _a : template.sourceSpan);\n            }\n            // Add the input bindings\n            if (inputs.length > 0) {\n                this.templatePropertyBindings(templateIndex, inputs);\n            }\n            // Generate listeners for directive output\n            for (const outputAst of template.outputs) {\n                this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter('ng_template', outputAst, templateIndex));\n            }\n        }\n    }\n    visitBoundText(text) {\n        if (this.i18n) {\n            const value = text.value.visit(this._valueConverter);\n            this.allocateBindingSlots(value);\n            if (value instanceof Interpolation) {\n                this.i18n.appendBoundText(text.i18n);\n                this.i18nAppendBindings(value.expressions);\n            }\n            return;\n        }\n        const nodeIndex = this.allocateDataSlot();\n        this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(nodeIndex)]);\n        const value = text.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value);\n        if (value instanceof Interpolation) {\n            this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));\n        }\n        else {\n            error('Text nodes should be interpolated and never bound directly.');\n        }\n    }\n    visitText(text) {\n        // when a text element is located within a translatable\n        // block, we exclude this text element from instructions set,\n        // since it will be captured in i18n content and processed at runtime\n        if (!this.i18n) {\n            this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(this.allocateDataSlot()), literal(text.value)]);\n        }\n    }\n    visitIcu(icu) {\n        let initWasInvoked = false;\n        // if an ICU was created outside of i18n block, we still treat\n        // it as a translatable entity and invoke i18nStart and i18nEnd\n        // to generate i18n context and the necessary instructions\n        if (!this.i18n) {\n            initWasInvoked = true;\n            this.i18nStart(null, icu.i18n, true);\n        }\n        const i18n = this.i18n;\n        const vars = this.i18nBindProps(icu.vars);\n        const placeholders = this.i18nBindProps(icu.placeholders);\n        // output ICU directly and keep ICU reference in context\n        const message = icu.i18n;\n        // we always need post-processing function for ICUs, to make sure that:\n        // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n        // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n        // inside ICUs)\n        // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n        const transformFn = (raw) => {\n            const params = Object.assign(Object.assign({}, vars), placeholders);\n            const formatted = formatI18nPlaceholderNamesInMap(params, /* useCamelCase */ false);\n            return invokeInstruction(null, Identifiers.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n        };\n        // in case the whole i18n message is a single ICU - we do not need to\n        // create a separate top-level translation, we can use the root ref instead\n        // and make this ICU a top-level translation\n        // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n        // separately, so we do not pass placeholders into `i18nTranslate` function.\n        if (isSingleI18nIcu(i18n.meta)) {\n            this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);\n        }\n        else {\n            // output ICU directly and keep ICU reference in context\n            const ref = this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);\n            i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n        }\n        if (initWasInvoked) {\n            this.i18nEnd(null, true);\n        }\n        return null;\n    }\n    allocateDataSlot() {\n        return this._dataIndex++;\n    }\n    getConstCount() {\n        return this._dataIndex;\n    }\n    getVarCount() {\n        return this._pureFunctionSlots;\n    }\n    getConsts() {\n        return this._constants;\n    }\n    getNgContentSelectors() {\n        return this._ngContentReservedSlots.length ?\n            this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :\n            null;\n    }\n    bindingContext() {\n        return `${this._bindingContext++}`;\n    }\n    templatePropertyBindings(templateIndex, attrs) {\n        const propertyBindings = [];\n        for (const input of attrs) {\n            if (!(input instanceof BoundAttribute)) {\n                continue;\n            }\n            const value = input.value.visit(this._valueConverter);\n            if (value === undefined) {\n                continue;\n            }\n            this.allocateBindingSlots(value);\n            if (value instanceof Interpolation) {\n                // Params typically contain attribute namespace and value sanitizer, which is applicable\n                // for regular HTML elements, but not applicable for <ng-template> (since props act as\n                // inputs to directives), so keep params array empty.\n                const params = [];\n                // prop=\"{{value}}\" case\n                this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);\n            }\n            else {\n                // [prop]=\"value\" case\n                propertyBindings.push({\n                    span: input.sourceSpan,\n                    paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), input.name)\n                });\n            }\n        }\n        for (const propertyBinding of propertyBindings) {\n            this.updateInstructionWithAdvance(templateIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);\n        }\n    }\n    // Bindings must only be resolved after all local refs have been visited, so all\n    // instructions are queued in callbacks that execute once the initial pass has completed.\n    // Otherwise, we wouldn't be able to support local refs that are defined after their\n    // bindings. e.g. {{ foo }} <div #foo></div>\n    instructionFn(fns, span, reference, paramsOrFn, prepend = false) {\n        fns[prepend ? 'unshift' : 'push']({ span, reference, paramsOrFn });\n    }\n    processStylingUpdateInstruction(elementIndex, instruction) {\n        let allocateBindingSlots = 0;\n        if (instruction) {\n            for (const call of instruction.calls) {\n                allocateBindingSlots += call.allocateBindingSlots;\n                this.updateInstructionWithAdvance(elementIndex, call.sourceSpan, instruction.reference, () => call.params(value => (call.supportsInterpolation && value instanceof Interpolation) ?\n                    this.getUpdateInstructionArguments(value) :\n                    this.convertPropertyBinding(value)));\n            }\n        }\n        return allocateBindingSlots;\n    }\n    creationInstruction(span, reference, paramsOrFn, prepend) {\n        this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n    }\n    updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {\n        this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n        this.updateInstruction(span, reference, paramsOrFn);\n    }\n    updateInstruction(span, reference, paramsOrFn) {\n        this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n    }\n    addAdvanceInstructionIfNecessary(nodeIndex, span) {\n        if (nodeIndex !== this._currentIndex) {\n            const delta = nodeIndex - this._currentIndex;\n            if (delta < 1) {\n                throw new Error('advance instruction can only go forwards');\n            }\n            this.instructionFn(this._updateCodeFns, span, Identifiers.advance, [literal(delta)]);\n            this._currentIndex = nodeIndex;\n        }\n    }\n    allocatePureFunctionSlots(numSlots) {\n        const originalSlots = this._pureFunctionSlots;\n        this._pureFunctionSlots += numSlots;\n        return originalSlots;\n    }\n    allocateBindingSlots(value) {\n        this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n    }\n    /**\n     * Gets an expression that refers to the implicit receiver. The implicit\n     * receiver is always the root level context.\n     */\n    getImplicitReceiverExpr() {\n        if (this._implicitReceiverExpr) {\n            return this._implicitReceiverExpr;\n        }\n        return this._implicitReceiverExpr = this.level === 0 ?\n            variable(CONTEXT_NAME) :\n            this._bindingScope.getOrCreateSharedContextVar(0);\n    }\n    convertPropertyBinding(value) {\n        const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n        const valExpr = convertedPropertyBinding.currValExpr;\n        this._tempVariables.push(...convertedPropertyBinding.stmts);\n        return valExpr;\n    }\n    /**\n     * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n     * the temp variables state with temp variables that were identified as needing to be created\n     * while visiting the arguments.\n     * @param value The original expression we will be resolving an arguments list from.\n     */\n    getUpdateInstructionArguments(value) {\n        const { args, stmts } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n        this._tempVariables.push(...stmts);\n        return args;\n    }\n    /**\n     * Prepares all attribute expression values for the `TAttributes` array.\n     *\n     * The purpose of this function is to properly construct an attributes array that\n     * is passed into the `elementStart` (or just `element`) functions. Because there\n     * are many different types of attributes, the array needs to be constructed in a\n     * special way so that `elementStart` can properly evaluate them.\n     *\n     * The format looks like this:\n     *\n     * ```\n     * attrs = [prop, value, prop2, value2,\n     *   PROJECT_AS, selector,\n     *   CLASSES, class1, class2,\n     *   STYLES, style1, value1, style2, value2,\n     *   BINDINGS, name1, name2, name3,\n     *   TEMPLATE, name4, name5, name6,\n     *   I18N, name7, name8, ...]\n     * ```\n     *\n     * Note that this function will fully ignore all synthetic (@foo) attribute values\n     * because those values are intended to always be generated as property instructions.\n     */\n    getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles, templateAttrs = [], boundI18nAttrs = []) {\n        const alreadySeen = new Set();\n        const attrExprs = [];\n        let ngProjectAsAttr;\n        for (const attr of renderAttributes) {\n            if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n                ngProjectAsAttr = attr;\n            }\n            // Note that static i18n attributes aren't in the i18n array,\n            // because they're treated in the same way as regular attributes.\n            if (attr.i18n) {\n                // When i18n attributes are present on elements with structural directives\n                // (e.g. `<div *ngIf title=\"Hello\" i18n-title>`), we want to avoid generating\n                // duplicate i18n translation blocks for `ɵɵtemplate` and `ɵɵelement` instruction\n                // attributes. So we do a cache lookup to see if suitable i18n translation block\n                // already exists.\n                const { i18nVarRefsCache } = this._constants;\n                let i18nVarRef;\n                if (i18nVarRefsCache.has(attr.i18n)) {\n                    i18nVarRef = i18nVarRefsCache.get(attr.i18n);\n                }\n                else {\n                    i18nVarRef = this.i18nTranslate(attr.i18n);\n                    i18nVarRefsCache.set(attr.i18n, i18nVarRef);\n                }\n                attrExprs.push(literal(attr.name), i18nVarRef);\n            }\n            else {\n                attrExprs.push(...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));\n            }\n        }\n        // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n        // ngProjectAs marker in the attribute name slot.\n        if (ngProjectAsAttr) {\n            attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));\n        }\n        function addAttrExpr(key, value) {\n            if (typeof key === 'string') {\n                if (!alreadySeen.has(key)) {\n                    attrExprs.push(...getAttributeNameLiterals(key));\n                    value !== undefined && attrExprs.push(value);\n                    alreadySeen.add(key);\n                }\n            }\n            else {\n                attrExprs.push(literal(key));\n            }\n        }\n        // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n        // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n        // as single property value cell by cell.\n        if (styles) {\n            styles.populateInitialStylingAttrs(attrExprs);\n        }\n        if (inputs.length || outputs.length) {\n            const attrsLengthBeforeInputs = attrExprs.length;\n            for (let i = 0; i < inputs.length; i++) {\n                const input = inputs[i];\n                // We don't want the animation and attribute bindings in the\n                // attributes array since they aren't used for directive matching.\n                if (input.type !== 4 /* BindingType.Animation */ && input.type !== 1 /* BindingType.Attribute */) {\n                    addAttrExpr(input.name);\n                }\n            }\n            for (let i = 0; i < outputs.length; i++) {\n                const output = outputs[i];\n                if (output.type !== 1 /* ParsedEventType.Animation */) {\n                    addAttrExpr(output.name);\n                }\n            }\n            // this is a cheap way of adding the marker only after all the input/output\n            // values have been filtered (by not including the animation ones) and added\n            // to the expressions. The marker is important because it tells the runtime\n            // code that this is where attributes without values start...\n            if (attrExprs.length !== attrsLengthBeforeInputs) {\n                attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3 /* core.AttributeMarker.Bindings */));\n            }\n        }\n        if (templateAttrs.length) {\n            attrExprs.push(literal(4 /* core.AttributeMarker.Template */));\n            templateAttrs.forEach(attr => addAttrExpr(attr.name));\n        }\n        if (boundI18nAttrs.length) {\n            attrExprs.push(literal(6 /* core.AttributeMarker.I18n */));\n            boundI18nAttrs.forEach(attr => addAttrExpr(attr.name));\n        }\n        return attrExprs;\n    }\n    addToConsts(expression) {\n        if (isNull(expression)) {\n            return TYPED_NULL_EXPR;\n        }\n        const consts = this._constants.constExpressions;\n        // Try to reuse a literal that's already in the array, if possible.\n        for (let i = 0; i < consts.length; i++) {\n            if (consts[i].isEquivalent(expression)) {\n                return literal(i);\n            }\n        }\n        return literal(consts.push(expression) - 1);\n    }\n    addAttrsToConsts(attrs) {\n        return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;\n    }\n    prepareRefsArray(references) {\n        if (!references || references.length === 0) {\n            return TYPED_NULL_EXPR;\n        }\n        const refsParam = flatten(references.map(reference => {\n            const slot = this.allocateDataSlot();\n            // Generate the update temporary.\n            const variableName = this._bindingScope.freshReferenceName();\n            const retrievalLevel = this.level;\n            const lhs = variable(variableName);\n            this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DeclarationPriority.DEFAULT */, (scope, relativeLevel) => {\n                // e.g. nextContext(2);\n                const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\n                // e.g. const $foo$ = reference(1);\n                const refExpr = lhs.set(importExpr(Identifiers.reference).callFn([literal(slot)]));\n                return nextContextStmt.concat(refExpr.toConstDecl());\n            }, true);\n            return [reference.name, reference.value];\n        }));\n        return asLiteral(refsParam);\n    }\n    prepareListenerParameter(tagName, outputAst, index) {\n        return () => {\n            const eventName = outputAst.name;\n            const bindingFnName = outputAst.type === 1 /* ParsedEventType.Animation */ ?\n                // synthetic @listener.foo values are treated the exact same as are standard listeners\n                prepareSyntheticListenerFunctionName(eventName, outputAst.phase) :\n                sanitizeIdentifier(eventName);\n            const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;\n            const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);\n            return prepareEventListenerParameters(outputAst, handlerName, scope);\n        };\n    }\n}\nclass ValueConverter extends AstMemoryEfficientTransformer {\n    constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {\n        super();\n        this.constantPool = constantPool;\n        this.allocateSlot = allocateSlot;\n        this.allocatePureFunctionSlots = allocatePureFunctionSlots;\n        this.definePipe = definePipe;\n        this._pipeBindExprs = [];\n    }\n    // AstMemoryEfficientTransformer\n    visitPipe(pipe, context) {\n        // Allocate a slot to create the pipe\n        const slot = this.allocateSlot();\n        const slotPseudoLocal = `PIPE:${slot}`;\n        // Allocate one slot for the result plus one slot per pipe argument\n        const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n        const target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);\n        const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);\n        this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));\n        const args = [pipe.exp, ...pipe.args];\n        const convertedArgs = isVarLength ?\n            this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :\n            this.visitAll(args);\n        const pipeBindExpr = new Call(pipe.span, pipe.sourceSpan, target, [\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),\n            ...convertedArgs,\n        ], null);\n        this._pipeBindExprs.push(pipeBindExpr);\n        return pipeBindExpr;\n    }\n    updatePipeSlotOffsets(bindingSlots) {\n        this._pipeBindExprs.forEach((pipe) => {\n            // update the slot offset arg (index 1) to account for binding slots\n            const slotOffset = pipe.args[1];\n            slotOffset.value += bindingSlots;\n        });\n    }\n    visitLiteralArray(array, context) {\n        return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), values => {\n            // If the literal has calculated (non-literal) elements transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values.\n            const literal = literalArr(values);\n            return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n        });\n    }\n    visitLiteralMap(map, context) {\n        return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {\n            // If the literal has calculated (non-literal) elements  transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values.\n            const literal = literalMap(values.map((value, index) => ({ key: map.keys[index].key, value, quoted: map.keys[index].quoted })));\n            return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n        });\n    }\n}\n// Pipes always have at least one parameter, the value they operate on\nconst pipeBindingIdentifiers = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];\nfunction pipeBindingCallInfo(args) {\n    const identifier = pipeBindingIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers.pipeBindV,\n        isVarLength: !identifier,\n    };\n}\nconst pureFunctionIdentifiers = [\n    Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4,\n    Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8\n];\nfunction pureFunctionCallInfo(args) {\n    const identifier = pureFunctionIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers.pureFunctionV,\n        isVarLength: !identifier,\n    };\n}\n// e.g. x(2);\nfunction generateNextContextExpr(relativeLevelDiff) {\n    return importExpr(Identifiers.nextContext)\n        .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);\n}\nfunction getLiteralFactory(constantPool, literal$1, allocateSlots) {\n    const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$1);\n    // Allocate 1 slot for the result plus 1 per argument\n    const startSlot = allocateSlots(1 + literalFactoryArguments.length);\n    const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);\n    // Literal factories are pure functions that only need to be re-invoked when the parameters\n    // change.\n    const args = [literal(startSlot), literalFactory];\n    if (isVarLength) {\n        args.push(literalArr(literalFactoryArguments));\n    }\n    else {\n        args.push(...literalFactoryArguments);\n    }\n    return importExpr(identifier).callFn(args);\n}\n/**\n * Gets an array of literals that can be added to an expression\n * to represent the name and namespace of an attribute. E.g.\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n *\n * @param name Name of the attribute, including the namespace.\n */\nfunction getAttributeNameLiterals(name) {\n    const [attributeNamespace, attributeName] = splitNsName(name);\n    const nameLiteral = literal(attributeName);\n    if (attributeNamespace) {\n        return [\n            literal(0 /* core.AttributeMarker.NamespaceURI */), literal(attributeNamespace), nameLiteral\n        ];\n    }\n    return [nameLiteral];\n}\n/** The prefix used to get a shared context in BindingScope's map. */\nconst SHARED_CONTEXT_KEY = '$$shared_ctx$$';\nclass BindingScope {\n    constructor(bindingLevel = 0, parent = null, globals) {\n        this.bindingLevel = bindingLevel;\n        this.parent = parent;\n        this.globals = globals;\n        /** Keeps a map from local variables to their BindingData. */\n        this.map = new Map();\n        this.referenceNameIndex = 0;\n        this.restoreViewVariable = null;\n        this.usesRestoredViewContext = false;\n        if (globals !== undefined) {\n            for (const name of globals) {\n                this.set(0, name, variable(name));\n            }\n        }\n    }\n    static createRootScope() {\n        return new BindingScope();\n    }\n    get(name) {\n        let current = this;\n        while (current) {\n            let value = current.map.get(name);\n            if (value != null) {\n                if (current !== this) {\n                    // make a local copy and reset the `declare` state\n                    value = {\n                        retrievalLevel: value.retrievalLevel,\n                        lhs: value.lhs,\n                        declareLocalCallback: value.declareLocalCallback,\n                        declare: false,\n                        priority: value.priority\n                    };\n                    // Cache the value locally.\n                    this.map.set(name, value);\n                    // Possibly generate a shared context var\n                    this.maybeGenerateSharedContextVar(value);\n                    this.maybeRestoreView();\n                }\n                if (value.declareLocalCallback && !value.declare) {\n                    value.declare = true;\n                }\n                return value.lhs;\n            }\n            current = current.parent;\n        }\n        // If we get to this point, we are looking for a property on the top level component\n        // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n        // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n        // local var we used to store the component context, e.g. const $comp$ = x();\n        return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n    }\n    /**\n     * Create a local variable for later reference.\n     *\n     * @param retrievalLevel The level from which this value can be retrieved\n     * @param name Name of the variable.\n     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n     * @param priority The sorting priority of this var\n     * @param declareLocalCallback The callback to invoke when declaring this local var\n     * @param localRef Whether or not this is a local ref\n     */\n    set(retrievalLevel, name, lhs, priority = 0 /* DeclarationPriority.DEFAULT */, declareLocalCallback, localRef) {\n        if (this.map.has(name)) {\n            if (localRef) {\n                // Do not throw an error if it's a local ref and do not update existing value,\n                // so the first defined ref is always returned.\n                return this;\n            }\n            error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);\n        }\n        this.map.set(name, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declare: false,\n            declareLocalCallback: declareLocalCallback,\n            priority: priority,\n        });\n        return this;\n    }\n    // Implemented as part of LocalResolver.\n    getLocal(name) {\n        return this.get(name);\n    }\n    // Implemented as part of LocalResolver.\n    notifyImplicitReceiverUse() {\n        if (this.bindingLevel !== 0) {\n            // Since the implicit receiver is accessed in an embedded view, we need to\n            // ensure that we declare a shared context variable for the current template\n            // in the update variables.\n            this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;\n        }\n    }\n    nestedScope(level, globals) {\n        const newScope = new BindingScope(level, this, globals);\n        if (level > 0)\n            newScope.generateSharedContextVar(0);\n        return newScope;\n    }\n    /**\n     * Gets or creates a shared context variable and returns its expression. Note that\n     * this does not mean that the shared variable will be declared. Variables in the\n     * binding scope will be only declared if they are used.\n     */\n    getOrCreateSharedContextVar(retrievalLevel) {\n        const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n        if (!this.map.has(bindingKey)) {\n            this.generateSharedContextVar(retrievalLevel);\n        }\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return this.map.get(bindingKey).lhs;\n    }\n    getSharedContextName(retrievalLevel) {\n        const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;\n    }\n    maybeGenerateSharedContextVar(value) {\n        if (value.priority === 1 /* DeclarationPriority.CONTEXT */ &&\n            value.retrievalLevel < this.bindingLevel) {\n            const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n            if (sharedCtxObj) {\n                sharedCtxObj.declare = true;\n            }\n            else {\n                this.generateSharedContextVar(value.retrievalLevel);\n            }\n        }\n    }\n    generateSharedContextVar(retrievalLevel) {\n        const lhs = variable(CONTEXT_NAME + this.freshReferenceName());\n        this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declareLocalCallback: (scope, relativeLevel) => {\n                // const ctx_r0 = nextContext(2);\n                return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n            },\n            declare: false,\n            priority: 2 /* DeclarationPriority.SHARED_CONTEXT */,\n        });\n    }\n    getComponentProperty(name) {\n        const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);\n        componentValue.declare = true;\n        this.maybeRestoreView();\n        return componentValue.lhs.prop(name);\n    }\n    maybeRestoreView() {\n        // View restoration is required for listener instructions inside embedded views, because\n        // they only run in creation mode and they can have references to the context object.\n        // If the context object changes in update mode, the reference will be incorrect, because\n        // it was established during creation.\n        if (this.isListenerScope()) {\n            if (!this.parent.restoreViewVariable) {\n                // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n                this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());\n            }\n            this.restoreViewVariable = this.parent.restoreViewVariable;\n        }\n    }\n    restoreViewStatement() {\n        if (this.restoreViewVariable) {\n            const restoreCall = invokeInstruction(null, Identifiers.restoreView, [this.restoreViewVariable]);\n            // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`\n            // depending on whether it is being used.\n            return this.usesRestoredViewContext ?\n                variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() :\n                restoreCall.toStmt();\n        }\n        return null;\n    }\n    viewSnapshotStatements() {\n        // const $state$ = getCurrentView();\n        return this.restoreViewVariable ?\n            [\n                this.restoreViewVariable.set(invokeInstruction(null, Identifiers.getCurrentView, [])).toConstDecl()\n            ] :\n            [];\n    }\n    isListenerScope() {\n        return this.parent && this.parent.bindingLevel === this.bindingLevel;\n    }\n    variableDeclarations() {\n        let currentContextLevel = 0;\n        return Array.from(this.map.values())\n            .filter(value => value.declare)\n            .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)\n            .reduce((stmts, value) => {\n            const levelDiff = this.bindingLevel - value.retrievalLevel;\n            const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);\n            currentContextLevel = levelDiff;\n            return stmts.concat(currStmts);\n        }, []);\n    }\n    freshReferenceName() {\n        let current = this;\n        // Find the top scope as it maintains the global reference count\n        while (current.parent)\n            current = current.parent;\n        const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;\n        return ref;\n    }\n    hasRestoreViewVariable() {\n        return !!this.restoreViewVariable;\n    }\n    notifyRestoredViewContextUse() {\n        this.usesRestoredViewContext = true;\n    }\n}\n/**\n * Creates a `CssSelector` given a tag name and a map of attributes\n */\nfunction createCssSelector(elementName, attributes) {\n    const cssSelector = new CssSelector();\n    const elementNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elementNameNoNs);\n    Object.getOwnPropertyNames(attributes).forEach((name) => {\n        const nameNoNs = splitNsName(name)[1];\n        const value = attributes[name];\n        cssSelector.addAttribute(nameNoNs, value);\n        if (name.toLowerCase() === 'class') {\n            const classes = value.trim().split(/\\s+/);\n            classes.forEach(className => cssSelector.addClassName(className));\n        }\n    });\n    return cssSelector;\n}\n/**\n * Creates an array of expressions out of an `ngProjectAs` attributes\n * which can be added to the instruction parameters.\n */\nfunction getNgProjectAsLiteral(attribute) {\n    // Parse the attribute value into a CssSelectorList. Note that we only take the\n    // first selector, because we don't support multiple selectors in ngProjectAs.\n    const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];\n    return [literal(5 /* core.AttributeMarker.ProjectAs */), asLiteral(parsedR3Selector)];\n}\n/**\n * Gets the instruction to generate for an interpolated property\n * @param interpolation An Interpolation AST\n */\nfunction getPropertyInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.propertyInterpolate;\n        case 3:\n            return Identifiers.propertyInterpolate1;\n        case 5:\n            return Identifiers.propertyInterpolate2;\n        case 7:\n            return Identifiers.propertyInterpolate3;\n        case 9:\n            return Identifiers.propertyInterpolate4;\n        case 11:\n            return Identifiers.propertyInterpolate5;\n        case 13:\n            return Identifiers.propertyInterpolate6;\n        case 15:\n            return Identifiers.propertyInterpolate7;\n        case 17:\n            return Identifiers.propertyInterpolate8;\n        default:\n            return Identifiers.propertyInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated attribute\n * @param interpolation An Interpolation AST\n */\nfunction getAttributeInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 3:\n            return Identifiers.attributeInterpolate1;\n        case 5:\n            return Identifiers.attributeInterpolate2;\n        case 7:\n            return Identifiers.attributeInterpolate3;\n        case 9:\n            return Identifiers.attributeInterpolate4;\n        case 11:\n            return Identifiers.attributeInterpolate5;\n        case 13:\n            return Identifiers.attributeInterpolate6;\n        case 15:\n            return Identifiers.attributeInterpolate7;\n        case 17:\n            return Identifiers.attributeInterpolate8;\n        default:\n            return Identifiers.attributeInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for interpolated text.\n * @param interpolation An Interpolation AST\n */\nfunction getTextInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.textInterpolate;\n        case 3:\n            return Identifiers.textInterpolate1;\n        case 5:\n            return Identifiers.textInterpolate2;\n        case 7:\n            return Identifiers.textInterpolate3;\n        case 9:\n            return Identifiers.textInterpolate4;\n        case 11:\n            return Identifiers.textInterpolate5;\n        case 13:\n            return Identifiers.textInterpolate6;\n        case 15:\n            return Identifiers.textInterpolate7;\n        case 17:\n            return Identifiers.textInterpolate8;\n        default:\n            return Identifiers.textInterpolateV;\n    }\n}\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nfunction parseTemplate(template, templateUrl, options = {}) {\n    const { interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat } = options;\n    const bindingParser = makeBindingParser(interpolationConfig);\n    const htmlParser = new HtmlParser();\n    const parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({ leadingTriviaChars: LEADING_TRIVIA_CHARS }, options), { tokenizeExpansionForms: true }));\n    if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors &&\n        parseResult.errors.length > 0) {\n        const parsedTemplate = {\n            interpolationConfig,\n            preserveWhitespaces,\n            errors: parseResult.errors,\n            nodes: [],\n            styleUrls: [],\n            styles: [],\n            ngContentSelectors: []\n        };\n        if (options.collectCommentNodes) {\n            parsedTemplate.commentNodes = [];\n        }\n        return parsedTemplate;\n    }\n    let rootNodes = parseResult.rootNodes;\n    // process i18n meta information (scan attributes, generate ids)\n    // before we run whitespace removal process, because existing i18n\n    // extraction process (ng extract-i18n) relies on a raw content to generate\n    // message ids\n    const i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces, enableI18nLegacyMessageIdFormat);\n    const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n    if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors &&\n        i18nMetaResult.errors.length > 0) {\n        const parsedTemplate = {\n            interpolationConfig,\n            preserveWhitespaces,\n            errors: i18nMetaResult.errors,\n            nodes: [],\n            styleUrls: [],\n            styles: [],\n            ngContentSelectors: []\n        };\n        if (options.collectCommentNodes) {\n            parsedTemplate.commentNodes = [];\n        }\n        return parsedTemplate;\n    }\n    rootNodes = i18nMetaResult.rootNodes;\n    if (!preserveWhitespaces) {\n        rootNodes = visitAll(new WhitespaceVisitor(), rootNodes);\n        // run i18n meta visitor again in case whitespaces are removed (because that might affect\n        // generated i18n message content) and first pass indicated that i18n content is present in a\n        // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n        // mimic existing extraction process (ng extract-i18n)\n        if (i18nMetaVisitor.hasI18nMeta) {\n            rootNodes = visitAll(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);\n        }\n    }\n    const { nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes } = htmlAstToRender3Ast(rootNodes, bindingParser, { collectCommentNodes: !!options.collectCommentNodes });\n    errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n    const parsedTemplate = {\n        interpolationConfig,\n        preserveWhitespaces,\n        errors: errors.length > 0 ? errors : null,\n        nodes,\n        styleUrls,\n        styles,\n        ngContentSelectors\n    };\n    if (options.collectCommentNodes) {\n        parsedTemplate.commentNodes = commentNodes;\n    }\n    return parsedTemplate;\n}\nconst elementRegistry = new DomElementSchemaRegistry();\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nfunction makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n    return new BindingParser(new Parser$1(new Lexer()), interpolationConfig, elementRegistry, []);\n}\nfunction resolveSanitizationFn(context, isAttribute) {\n    switch (context) {\n        case SecurityContext.HTML:\n            return importExpr(Identifiers.sanitizeHtml);\n        case SecurityContext.SCRIPT:\n            return importExpr(Identifiers.sanitizeScript);\n        case SecurityContext.STYLE:\n            // the compiler does not fill in an instruction for [style.prop?] binding\n            // values because the style algorithm knows internally what props are subject\n            // to sanitization (only [attr.style] values are explicitly sanitized)\n            return isAttribute ? importExpr(Identifiers.sanitizeStyle) : null;\n        case SecurityContext.URL:\n            return importExpr(Identifiers.sanitizeUrl);\n        case SecurityContext.RESOURCE_URL:\n            return importExpr(Identifiers.sanitizeResourceUrl);\n        default:\n            return null;\n    }\n}\nfunction trustedConstAttribute(tagName, attr) {\n    const value = asLiteral(attr.value);\n    if (isTrustedTypesSink(tagName, attr.name)) {\n        switch (elementRegistry.securityContext(tagName, attr.name, /* isAttribute */ true)) {\n            case SecurityContext.HTML:\n                return taggedTemplate(importExpr(Identifiers.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n            // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.\n            case SecurityContext.RESOURCE_URL:\n                return taggedTemplate(importExpr(Identifiers.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n            default:\n                return value;\n        }\n    }\n    else {\n        return value;\n    }\n}\nfunction isSingleElementTemplate(children) {\n    return children.length === 1 && children[0] instanceof Element$1;\n}\nfunction isTextNode(node) {\n    return node instanceof Text$3 || node instanceof BoundText || node instanceof Icu$1;\n}\nfunction hasTextChildrenOnly(children) {\n    return children.every(isTextNode);\n}\nfunction getBindingFunctionParams(deferredParams, name, eagerParams) {\n    return () => {\n        const value = deferredParams();\n        const fnParams = Array.isArray(value) ? value : [value];\n        if (eagerParams) {\n            fnParams.push(...eagerParams);\n        }\n        if (name) {\n            // We want the property name to always be the first function parameter.\n            fnParams.unshift(literal(name));\n        }\n        return fnParams;\n    };\n}\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n/**\n * Generate statements that define a given translation message.\n *\n * ```\n * var I18N_1;\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\n *          \"Some message with {$interpolation}!\",\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n *     );\n *     I18N_1 = MSG_EXTERNAL_XXX;\n * }\n * else {\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n * }\n * ```\n *\n * @param message The original i18n AST message node\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n * @param params Object mapping placeholder names to their values (e.g.\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n * @param transformFn Optional transformation function that will be applied to the translation (e.g.\n * post-processing).\n * @returns An array of statements that defined a given translation.\n */\nfunction getTranslationDeclStmts(message, variable, closureVar, params = {}, transformFn) {\n    const statements = [\n        declareI18nVariable(variable),\n        ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, params), createLocalizeStatements(variable, message, formatI18nPlaceholderNamesInMap(params, /* useCamelCase */ false))),\n    ];\n    if (transformFn) {\n        statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\n    }\n    return statements;\n}\n/**\n * Create the expression that will be used to guard the closure mode block\n * It is equivalent to:\n *\n * ```\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n * ```\n */\nfunction createClosureModeGuard() {\n    return typeofExpr(variable(NG_I18N_CLOSURE_MODE))\n        .notIdentical(literal('undefined', STRING_TYPE))\n        .and(variable(NG_I18N_CLOSURE_MODE));\n}\nfunction flatten(list) {\n    return list.reduce((flat, item) => {\n        const flatItem = Array.isArray(item) ? flatten(item) : item;\n        return flat.concat(flatItem);\n    }, []);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n// If there is a match, the first matching group will contain the attribute name to bind.\nconst ATTR_REGEX = /attr\\.([^\\]]+)/;\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\n    const definitionMap = new DefinitionMap();\n    const selectors = parseSelectorToR3Selector(meta.selector);\n    // e.g. `type: MyDirective`\n    definitionMap.set('type', meta.internalType);\n    // e.g. `selectors: [['', 'someDir', '']]`\n    if (selectors.length > 0) {\n        definitionMap.set('selectors', asLiteral(selectors));\n    }\n    if (meta.queries.length > 0) {\n        // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n        definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n    }\n    if (meta.viewQueries.length) {\n        definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n    }\n    // e.g. `hostBindings: (rf, ctx) => { ... }\n    definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));\n    // e.g 'inputs: {a: 'a'}`\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n    // e.g 'outputs: {a: 'a'}`\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n    if (meta.exportAs !== null) {\n        definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));\n    }\n    if (meta.isStandalone) {\n        definitionMap.set('standalone', literal(true));\n    }\n    return definitionMap;\n}\n/**\n * Add features to the definition map.\n */\nfunction addFeatures(definitionMap, meta) {\n    // e.g. `features: [NgOnChangesFeature]`\n    const features = [];\n    const providers = meta.providers;\n    const viewProviders = meta.viewProviders;\n    if (providers || viewProviders) {\n        const args = [providers || new LiteralArrayExpr([])];\n        if (viewProviders) {\n            args.push(viewProviders);\n        }\n        features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));\n    }\n    if (meta.usesInheritance) {\n        features.push(importExpr(Identifiers.InheritDefinitionFeature));\n    }\n    if (meta.fullInheritance) {\n        features.push(importExpr(Identifiers.CopyDefinitionFeature));\n    }\n    if (meta.lifecycle.usesOnChanges) {\n        features.push(importExpr(Identifiers.NgOnChangesFeature));\n    }\n    // TODO: better way of differentiating component vs directive metadata.\n    if (meta.hasOwnProperty('template') && meta.isStandalone) {\n        features.push(importExpr(Identifiers.StandaloneFeature));\n    }\n    if (features.length) {\n        definitionMap.set('features', literalArr(features));\n    }\n}\n/**\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n */\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createDirectiveType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n */\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\n    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    const selector = meta.selector && CssSelector.parse(meta.selector);\n    const firstSelector = selector && selector[0];\n    // e.g. `attr: [\"class\", \".my.app\"]`\n    // This is optional an only included if the first selector of a component specifies attributes.\n    if (firstSelector) {\n        const selectorAttributes = firstSelector.getAttrs();\n        if (selectorAttributes.length) {\n            definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), \n            /* forceShared */ true));\n        }\n    }\n    // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n    const templateTypeName = meta.name;\n    const templateName = templateTypeName ? `${templateTypeName}_Template` : null;\n    const changeDetection = meta.changeDetection;\n    const template = meta.template;\n    const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n    const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\n    // We need to provide this so that dynamically generated components know what\n    // projected content blocks to pass through to the component when it is instantiated.\n    const ngContentSelectors = templateBuilder.getNgContentSelectors();\n    if (ngContentSelectors) {\n        definitionMap.set('ngContentSelectors', ngContentSelectors);\n    }\n    // e.g. `decls: 2`\n    definitionMap.set('decls', literal(templateBuilder.getConstCount()));\n    // e.g. `vars: 2`\n    definitionMap.set('vars', literal(templateBuilder.getVarCount()));\n    // Generate `consts` section of ComponentDef:\n    // - either as an array:\n    //   `consts: [['one', 'two'], ['three', 'four']]`\n    // - or as a factory function in case additional statements are present (to support i18n):\n    //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`\n    const { constExpressions, prepareStatements } = templateBuilder.getConsts();\n    if (constExpressions.length > 0) {\n        let constsExpr = literalArr(constExpressions);\n        // Prepare statements are present - turn `consts` into a function.\n        if (prepareStatements.length > 0) {\n            constsExpr = fn([], [...prepareStatements, new ReturnStatement(constsExpr)]);\n        }\n        definitionMap.set('consts', constsExpr);\n    }\n    definitionMap.set('template', templateFunctionExpression);\n    if (meta.declarations.length > 0) {\n        definitionMap.set('dependencies', compileDeclarationList(literalArr(meta.declarations.map(decl => decl.type)), meta.declarationListEmitMode));\n    }\n    if (meta.encapsulation === null) {\n        meta.encapsulation = exports.ViewEncapsulation.Emulated;\n    }\n    // e.g. `styles: [str1, str2]`\n    if (meta.styles && meta.styles.length) {\n        const styleValues = meta.encapsulation == exports.ViewEncapsulation.Emulated ?\n            compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :\n            meta.styles;\n        const styleNodes = styleValues.reduce((result, style) => {\n            if (style.trim().length > 0) {\n                result.push(constantPool.getConstLiteral(literal(style)));\n            }\n            return result;\n        }, []);\n        if (styleNodes.length > 0) {\n            definitionMap.set('styles', literalArr(styleNodes));\n        }\n    }\n    else if (meta.encapsulation === exports.ViewEncapsulation.Emulated) {\n        // If there is no style, don't generate css selectors on elements\n        meta.encapsulation = exports.ViewEncapsulation.None;\n    }\n    // Only set view encapsulation if it's not the default value\n    if (meta.encapsulation !== exports.ViewEncapsulation.Emulated) {\n        definitionMap.set('encapsulation', literal(meta.encapsulation));\n    }\n    // e.g. `animation: [trigger('123', [])]`\n    if (meta.animations !== null) {\n        definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));\n    }\n    // Only set the change detection flag if it's defined and it's not the default.\n    if (changeDetection != null && changeDetection !== exports.ChangeDetectionStrategy.Default) {\n        definitionMap.set('changeDetection', literal(changeDetection));\n    }\n    const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createComponentType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Creates the type specification from the component meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nfunction createComponentType(meta) {\n    const typeParams = createBaseDirectiveTypeParams(meta);\n    typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n    typeParams.push(expressionType(literal(meta.isStandalone)));\n    return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));\n}\n/**\n * Compiles the array literal of declarations into an expression according to the provided emit\n * mode.\n */\nfunction compileDeclarationList(list, mode) {\n    switch (mode) {\n        case 0 /* DeclarationListEmitMode.Direct */:\n            // directives: [MyDir],\n            return list;\n        case 1 /* DeclarationListEmitMode.Closure */:\n            // directives: function () { return [MyDir]; }\n            return fn([], [new ReturnStatement(list)]);\n        case 2 /* DeclarationListEmitMode.ClosureResolved */:\n            // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n            const resolvedList = list.prop('map').callFn([importExpr(Identifiers.resolveForwardRef)]);\n            return fn([], [new ReturnStatement(resolvedList)]);\n    }\n}\nfunction prepareQueryParams(query, constantPool) {\n    const parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];\n    if (query.read) {\n        parameters.push(query.read);\n    }\n    return parameters;\n}\n/**\n * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts\n * @param query\n */\nfunction toQueryFlags(query) {\n    return (query.descendants ? 1 /* QueryFlags.descendants */ : 0 /* QueryFlags.none */) |\n        (query.static ? 2 /* QueryFlags.isStatic */ : 0 /* QueryFlags.none */) |\n        (query.emitDistinctChangesOnly ? 4 /* QueryFlags.emitDistinctChangesOnly */ : 0 /* QueryFlags.none */);\n}\nfunction convertAttributesToExpressions(attributes) {\n    const values = [];\n    for (let key of Object.getOwnPropertyNames(attributes)) {\n        const value = attributes[key];\n        values.push(literal(key), value);\n    }\n    return values;\n}\n// Define and update any content queries\nfunction createContentQueriesFunction(queries, constantPool, name) {\n    const createStatements = [];\n    const updateStatements = [];\n    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    for (const query of queries) {\n        // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n        createStatements.push(importExpr(Identifiers.contentQuery)\n            .callFn([variable('dirIndex'), ...prepareQueryParams(query, constantPool)])\n            .toStmt());\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n        const temporary = tempAllocator();\n        const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n        const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n        const updateDirective = variable(CONTEXT_NAME)\n            .prop(query.propertyName)\n            .set(query.first ? temporary.prop('first') : temporary);\n        updateStatements.push(refresh.and(updateDirective).toStmt());\n    }\n    const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n    return fn([\n        new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),\n        new FnParam('dirIndex', null)\n    ], [\n        renderFlagCheckIfStmt(1 /* core.RenderFlags.Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* core.RenderFlags.Update */, updateStatements)\n    ], INFERRED_TYPE, null, contentQueriesFnName);\n}\nfunction stringAsType(str) {\n    return expressionType(literal(str));\n}\nfunction stringMapAsType(map) {\n    const mapValues = Object.keys(map).map(key => {\n        const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n        return {\n            key,\n            value: literal(value),\n            quoted: true,\n        };\n    });\n    return expressionType(literalMap(mapValues));\n}\nfunction stringArrayAsType(arr) {\n    return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) :\n        NONE_TYPE;\n}\nfunction createBaseDirectiveTypeParams(meta) {\n    // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n    // string literal, which must be on one line.\n    const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n    return [\n        typeWithParameters(meta.type.type, meta.typeArgumentCount),\n        selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,\n        meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,\n        stringMapAsType(meta.inputs),\n        stringMapAsType(meta.outputs),\n        stringArrayAsType(meta.queries.map(q => q.propertyName)),\n    ];\n}\n/**\n * Creates the type specification from the directive meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nfunction createDirectiveType(meta) {\n    const typeParams = createBaseDirectiveTypeParams(meta);\n    // Directives have no NgContentSelectors slot, but instead express a `never` type\n    // so that future fields align.\n    typeParams.push(NONE_TYPE);\n    typeParams.push(expressionType(literal(meta.isStandalone)));\n    return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));\n}\n// Define and update any view queries\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\n    const createStatements = [];\n    const updateStatements = [];\n    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    viewQueries.forEach((query) => {\n        // creation, e.g. r3.viewQuery(somePredicate, true);\n        const queryDefinition = importExpr(Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));\n        createStatements.push(queryDefinition.toStmt());\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n        const temporary = tempAllocator();\n        const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n        const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n        const updateDirective = variable(CONTEXT_NAME)\n            .prop(query.propertyName)\n            .set(query.first ? temporary.prop('first') : temporary);\n        updateStatements.push(refresh.and(updateDirective).toStmt());\n    });\n    const viewQueryFnName = name ? `${name}_Query` : null;\n    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\n        renderFlagCheckIfStmt(1 /* core.RenderFlags.Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* core.RenderFlags.Update */, updateStatements)\n    ], INFERRED_TYPE, null, viewQueryFnName);\n}\n// Return a host binding function or null if one is not necessary.\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\n    const bindingContext = variable(CONTEXT_NAME);\n    const styleBuilder = new StylingBuilder(bindingContext);\n    const { styleAttr, classAttr } = hostBindingsMetadata.specialAttributes;\n    if (styleAttr !== undefined) {\n        styleBuilder.registerStyleAttr(styleAttr);\n    }\n    if (classAttr !== undefined) {\n        styleBuilder.registerClassAttr(classAttr);\n    }\n    const createInstructions = [];\n    const updateInstructions = [];\n    const updateVariables = [];\n    const hostBindingSourceSpan = typeSourceSpan;\n    // Calculate host event bindings\n    const eventBindings = bindingParser.createDirectiveHostEventAsts(hostBindingsMetadata.listeners, hostBindingSourceSpan);\n    if (eventBindings && eventBindings.length) {\n        createInstructions.push(...createHostListeners(eventBindings, name));\n    }\n    // Calculate the host property bindings\n    const bindings = bindingParser.createBoundHostProperties(hostBindingsMetadata.properties, hostBindingSourceSpan);\n    const allOtherBindings = [];\n    // We need to calculate the total amount of binding slots required by\n    // all the instructions together before any value conversions happen.\n    // Value conversions may require additional slots for interpolation and\n    // bindings with pipes. These calculates happen after this block.\n    let totalHostVarsCount = 0;\n    bindings && bindings.forEach((binding) => {\n        const stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);\n        if (stylingInputWasSet) {\n            totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\n        }\n        else {\n            allOtherBindings.push(binding);\n            totalHostVarsCount++;\n        }\n    });\n    let valueConverter;\n    const getValueConverter = () => {\n        if (!valueConverter) {\n            const hostVarsCountFn = (numSlots) => {\n                const originalVarsCount = totalHostVarsCount;\n                totalHostVarsCount += numSlots;\n                return originalVarsCount;\n            };\n            valueConverter = new ValueConverter(constantPool, () => error('Unexpected node'), // new nodes are illegal here\n            hostVarsCountFn, () => error('Unexpected pipe')); // pipes are illegal here\n        }\n        return valueConverter;\n    };\n    const propertyBindings = [];\n    const attributeBindings = [];\n    const syntheticHostBindings = [];\n    for (const binding of allOtherBindings) {\n        // resolve literal arrays and literal objects\n        const value = binding.expression.visit(getValueConverter());\n        const bindingExpr = bindingFn(bindingContext, value);\n        const { bindingName, instruction, isAttribute } = getBindingNameAndInstruction(binding);\n        const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)\n            .filter(context => context !== SecurityContext.NONE);\n        let sanitizerFn = null;\n        if (securityContexts.length) {\n            if (securityContexts.length === 2 &&\n                securityContexts.indexOf(SecurityContext.URL) > -1 &&\n                securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {\n                // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n                // of different security contexts. In this case we use special sanitization function and\n                // select the actual sanitizer at runtime based on a tag name that is provided while\n                // invoking sanitization function.\n                sanitizerFn = importExpr(Identifiers.sanitizeUrlOrResourceUrl);\n            }\n            else {\n                sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\n            }\n        }\n        const instructionParams = [literal(bindingName), bindingExpr.currValExpr];\n        if (sanitizerFn) {\n            instructionParams.push(sanitizerFn);\n        }\n        updateVariables.push(...bindingExpr.stmts);\n        if (instruction === Identifiers.hostProperty) {\n            propertyBindings.push(instructionParams);\n        }\n        else if (instruction === Identifiers.attribute) {\n            attributeBindings.push(instructionParams);\n        }\n        else if (instruction === Identifiers.syntheticHostProperty) {\n            syntheticHostBindings.push(instructionParams);\n        }\n        else {\n            updateInstructions.push({ reference: instruction, paramsOrFn: instructionParams, span: null });\n        }\n    }\n    for (const bindingParams of propertyBindings) {\n        updateInstructions.push({ reference: Identifiers.hostProperty, paramsOrFn: bindingParams, span: null });\n    }\n    for (const bindingParams of attributeBindings) {\n        updateInstructions.push({ reference: Identifiers.attribute, paramsOrFn: bindingParams, span: null });\n    }\n    for (const bindingParams of syntheticHostBindings) {\n        updateInstructions.push({ reference: Identifiers.syntheticHostProperty, paramsOrFn: bindingParams, span: null });\n    }\n    // since we're dealing with directives/components and both have hostBinding\n    // functions, we need to generate a special hostAttrs instruction that deals\n    // with both the assignment of styling as well as static attributes to the host\n    // element. The instruction below will instruct all initial styling (styling\n    // that is inside of a host binding within a directive/component) to be attached\n    // to the host element alongside any of the provided host attributes that were\n    // collected earlier.\n    const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n    styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\n    if (styleBuilder.hasBindings) {\n        // finally each binding that was registered in the statement above will need to be added to\n        // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n        // are evaluated and updated for the element.\n        styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {\n            for (const call of instruction.calls) {\n                // we subtract a value of `1` here because the binding slot was already allocated\n                // at the top of this method when all the input bindings were counted.\n                totalHostVarsCount +=\n                    Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\n                updateInstructions.push({\n                    reference: instruction.reference,\n                    paramsOrFn: convertStylingCall(call, bindingContext, bindingFn),\n                    span: null\n                });\n            }\n        });\n    }\n    if (totalHostVarsCount) {\n        definitionMap.set('hostVars', literal(totalHostVarsCount));\n    }\n    if (createInstructions.length > 0 || updateInstructions.length > 0) {\n        const hostBindingsFnName = name ? `${name}_HostBindings` : null;\n        const statements = [];\n        if (createInstructions.length > 0) {\n            statements.push(renderFlagCheckIfStmt(1 /* core.RenderFlags.Create */, getInstructionStatements(createInstructions)));\n        }\n        if (updateInstructions.length > 0) {\n            statements.push(renderFlagCheckIfStmt(2 /* core.RenderFlags.Update */, updateVariables.concat(getInstructionStatements(updateInstructions))));\n        }\n        return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);\n    }\n    return null;\n}\nfunction bindingFn(implicit, value) {\n    return convertPropertyBinding(null, implicit, value, 'b');\n}\nfunction convertStylingCall(call, bindingContext, bindingFn) {\n    return call.params(value => bindingFn(bindingContext, value).currValExpr);\n}\nfunction getBindingNameAndInstruction(binding) {\n    let bindingName = binding.name;\n    let instruction;\n    // Check to see if this is an attr binding or a property binding\n    const attrMatches = bindingName.match(ATTR_REGEX);\n    if (attrMatches) {\n        bindingName = attrMatches[1];\n        instruction = Identifiers.attribute;\n    }\n    else {\n        if (binding.isAnimation) {\n            bindingName = prepareSyntheticPropertyName(bindingName);\n            // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n            // in the context of the component and not the parent. Therefore there is a special\n            // compatibility instruction available for this purpose.\n            instruction = Identifiers.syntheticHostProperty;\n        }\n        else {\n            instruction = Identifiers.hostProperty;\n        }\n    }\n    return { bindingName, instruction, isAttribute: !!attrMatches };\n}\nfunction createHostListeners(eventBindings, name) {\n    const listenerParams = [];\n    const syntheticListenerParams = [];\n    const instructions = [];\n    for (const binding of eventBindings) {\n        let bindingName = binding.name && sanitizeIdentifier(binding.name);\n        const bindingFnName = binding.type === 1 /* ParsedEventType.Animation */ ?\n            prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :\n            bindingName;\n        const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;\n        const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\n        if (binding.type == 1 /* ParsedEventType.Animation */) {\n            syntheticListenerParams.push(params);\n        }\n        else {\n            listenerParams.push(params);\n        }\n    }\n    for (const params of syntheticListenerParams) {\n        instructions.push({ reference: Identifiers.syntheticHostListener, paramsOrFn: params, span: null });\n    }\n    for (const params of listenerParams) {\n        instructions.push({ reference: Identifiers.listener, paramsOrFn: params, span: null });\n    }\n    return instructions;\n}\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\nfunction parseHostBindings(host) {\n    const attributes = {};\n    const listeners = {};\n    const properties = {};\n    const specialAttributes = {};\n    for (const key of Object.keys(host)) {\n        const value = host[key];\n        const matches = key.match(HOST_REG_EXP);\n        if (matches === null) {\n            switch (key) {\n                case 'class':\n                    if (typeof value !== 'string') {\n                        // TODO(alxhub): make this a diagnostic.\n                        throw new Error(`Class binding must be string`);\n                    }\n                    specialAttributes.classAttr = value;\n                    break;\n                case 'style':\n                    if (typeof value !== 'string') {\n                        // TODO(alxhub): make this a diagnostic.\n                        throw new Error(`Style binding must be string`);\n                    }\n                    specialAttributes.styleAttr = value;\n                    break;\n                default:\n                    if (typeof value === 'string') {\n                        attributes[key] = literal(value);\n                    }\n                    else {\n                        attributes[key] = value;\n                    }\n            }\n        }\n        else if (matches[1 /* HostBindingGroup.Binding */] != null) {\n            if (typeof value !== 'string') {\n                // TODO(alxhub): make this a diagnostic.\n                throw new Error(`Property binding must be string`);\n            }\n            // synthetic properties (the ones that have a `@` as a prefix)\n            // are still treated the same as regular properties. Therefore\n            // there is no point in storing them in a separate map.\n            properties[matches[1 /* HostBindingGroup.Binding */]] = value;\n        }\n        else if (matches[2 /* HostBindingGroup.Event */] != null) {\n            if (typeof value !== 'string') {\n                // TODO(alxhub): make this a diagnostic.\n                throw new Error(`Event binding must be string`);\n            }\n            listeners[matches[2 /* HostBindingGroup.Event */]] = value;\n        }\n    }\n    return { attributes, listeners, properties, specialAttributes };\n}\n/**\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n * given set of host bindings has no errors.\n *\n * @param bindings set of host bindings to verify.\n * @param sourceSpan source span where host bindings were defined.\n * @returns array of errors associated with a given set of host bindings.\n */\nfunction verifyHostBindings(bindings, sourceSpan) {\n    // TODO: abstract out host bindings verification logic and use it instead of\n    // creating events and properties ASTs to detect errors (FW-996)\n    const bindingParser = makeBindingParser();\n    bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n    bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n    return bindingParser.errors;\n}\nfunction compileStyles(styles, selector, hostSelector) {\n    const shadowCss = new ShadowCss();\n    return styles.map(style => {\n        return shadowCss.shimCssText(style, selector, hostSelector);\n    });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * An interface for retrieving documents by URL that the compiler uses to\n * load templates.\n *\n * This is an abstract class, rather than an interface, so that it can be used\n * as injection token.\n */\nclass ResourceLoader {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass CompilerFacadeImpl {\n    constructor(jitEvaluator = new JitEvaluator()) {\n        this.jitEvaluator = jitEvaluator;\n        this.FactoryTarget = exports.FactoryTarget;\n        this.ResourceLoader = ResourceLoader;\n        this.elementSchemaRegistry = new DomElementSchemaRegistry();\n    }\n    compilePipe(angularCoreEnv, sourceMapUrl, facade) {\n        const metadata = {\n            name: facade.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: 0,\n            deps: null,\n            pipeName: facade.pipeName,\n            pure: facade.pure,\n            isStandalone: facade.isStandalone,\n        };\n        const res = compilePipeFromMetadata(metadata);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const meta = convertDeclarePipeFacadeToMetadata(declaration);\n        const res = compilePipeFromMetadata(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileInjectable(angularCoreEnv, sourceMapUrl, facade) {\n        var _a;\n        const { expression, statements } = compileInjectable({\n            name: facade.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: facade.typeArgumentCount,\n            providedIn: computeProvidedIn(facade.providedIn),\n            useClass: convertToProviderExpression(facade, 'useClass'),\n            useFactory: wrapExpression(facade, 'useFactory'),\n            useValue: convertToProviderExpression(facade, 'useValue'),\n            useExisting: convertToProviderExpression(facade, 'useExisting'),\n            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DependencyMetadata),\n        }, \n        /* resolveForwardRefs */ true);\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    }\n    compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {\n        var _a;\n        const { expression, statements } = compileInjectable({\n            name: facade.type.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: 0,\n            providedIn: computeProvidedIn(facade.providedIn),\n            useClass: convertToProviderExpression(facade, 'useClass'),\n            useFactory: wrapExpression(facade, 'useFactory'),\n            useValue: convertToProviderExpression(facade, 'useValue'),\n            useExisting: convertToProviderExpression(facade, 'useExisting'),\n            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DeclareDependencyMetadata),\n        }, \n        /* resolveForwardRefs */ true);\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    }\n    compileInjector(angularCoreEnv, sourceMapUrl, facade) {\n        const meta = {\n            name: facade.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            providers: new WrappedNodeExpr(facade.providers),\n            imports: facade.imports.map(i => new WrappedNodeExpr(i)),\n        };\n        const res = compileInjector(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const meta = convertDeclareInjectorFacadeToMetadata(declaration);\n        const res = compileInjector(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileNgModule(angularCoreEnv, sourceMapUrl, facade) {\n        const meta = {\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            adjacentType: new WrappedNodeExpr(facade.type),\n            bootstrap: facade.bootstrap.map(wrapReference),\n            declarations: facade.declarations.map(wrapReference),\n            imports: facade.imports.map(wrapReference),\n            exports: facade.exports.map(wrapReference),\n            selectorScopeMode: exports.R3SelectorScopeMode.Inline,\n            containsForwardDecls: false,\n            schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n            id: facade.id ? new WrappedNodeExpr(facade.id) : null,\n        };\n        const res = compileNgModule(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const expression = compileNgModuleDeclarationExpression(declaration);\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileDirective(angularCoreEnv, sourceMapUrl, facade) {\n        const meta = convertDirectiveFacadeToMetadata(facade);\n        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n    compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n        const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n    compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n        const constantPool = new ConstantPool();\n        const bindingParser = makeBindingParser();\n        const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    }\n    compileComponent(angularCoreEnv, sourceMapUrl, facade) {\n        // Parse the template and check for errors.\n        const { template, interpolation } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation);\n        // Compile the component metadata, including template, into an expression.\n        const meta = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template, declarations: facade.declarations.map(convertDeclarationFacadeToMetadata), declarationListEmitMode: 0 /* DeclarationListEmitMode.Direct */, styles: [...facade.styles, ...template.styles], encapsulation: facade.encapsulation, interpolation, changeDetection: facade.changeDetection, animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :\n                null, relativeContextFilePath: '', i18nUseExternalIds: true });\n        const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n        return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n    }\n    compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n        const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n        return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n    compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n        const constantPool = new ConstantPool();\n        const bindingParser = makeBindingParser(meta.interpolation);\n        const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    }\n    compileFactory(angularCoreEnv, sourceMapUrl, meta) {\n        const factoryRes = compileFactoryFunction({\n            name: meta.name,\n            type: wrapReference(meta.type),\n            internalType: new WrappedNodeExpr(meta.type),\n            typeArgumentCount: meta.typeArgumentCount,\n            deps: convertR3DependencyMetadataArray(meta.deps),\n            target: meta.target,\n        });\n        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    }\n    compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {\n        const factoryRes = compileFactoryFunction({\n            name: meta.type.name,\n            type: wrapReference(meta.type),\n            internalType: new WrappedNodeExpr(meta.type),\n            typeArgumentCount: 0,\n            deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) :\n                meta.deps,\n            target: meta.target,\n        });\n        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    }\n    createParseSourceSpan(kind, typeName, sourceUrl) {\n        return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n    }\n    /**\n     * JIT compiles an expression and returns the result of executing that expression.\n     *\n     * @param def the definition which will be compiled and executed to get the value to patch\n     * @param context an object map of @angular/core symbol names to symbols which will be available\n     * in the context of the compiled expression\n     * @param sourceUrl a URL to use for the source map of the compiled expression\n     * @param preStatements a collection of statements that should be evaluated before the expression.\n     */\n    jitExpression(def, context, sourceUrl, preStatements) {\n        // The ConstantPool may contain Statements which declare variables used in the final expression.\n        // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n        // declaration of $def which is set to the expression being compiled.\n        const statements = [\n            ...preStatements,\n            new DeclareVarStmt('$def', def, undefined, exports.StmtModifier.Exported),\n        ];\n        const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);\n        return res['$def'];\n    }\n}\nfunction convertToR3QueryMetadata(facade) {\n    return Object.assign(Object.assign({}, facade), { predicate: convertQueryPredicate(facade.predicate), read: facade.read ? new WrappedNodeExpr(facade.read) : null, static: facade.static, emitDistinctChangesOnly: facade.emitDistinctChangesOnly });\n}\nfunction convertQueryDeclarationToMetadata(declaration) {\n    var _a, _b, _c, _d;\n    return {\n        propertyName: declaration.propertyName,\n        first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,\n        predicate: convertQueryPredicate(declaration.predicate),\n        descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,\n        read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n        static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,\n        emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true,\n    };\n}\nfunction convertQueryPredicate(predicate) {\n    return Array.isArray(predicate) ?\n        // The predicate is an array of strings so pass it through.\n        predicate :\n        // The predicate is a type - assume that we will need to unwrap any `forwardRef()` calls.\n        createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), 1 /* ForwardRefHandling.Wrapped */);\n}\nfunction convertDirectiveFacadeToMetadata(facade) {\n    const inputsFromMetadata = parseInputOutputs(facade.inputs || []);\n    const outputsFromMetadata = parseInputOutputs(facade.outputs || []);\n    const propMetadata = facade.propMetadata;\n    const inputsFromType = {};\n    const outputsFromType = {};\n    for (const field in propMetadata) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(ann => {\n                if (isInput(ann)) {\n                    inputsFromType[field] =\n                        ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\n                }\n                else if (isOutput(ann)) {\n                    outputsFromType[field] = ann.bindingPropertyName || field;\n                }\n            });\n        }\n    }\n    return Object.assign(Object.assign({}, facade), { typeArgumentCount: 0, typeSourceSpan: facade.typeSourceSpan, type: wrapReference(facade.type), internalType: new WrappedNodeExpr(facade.type), deps: null, host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host), inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType), outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata), fullInheritance: false });\n}\nfunction convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    return {\n        name: declaration.type.name,\n        type: wrapReference(declaration.type),\n        typeSourceSpan,\n        internalType: new WrappedNodeExpr(declaration.type),\n        selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,\n        inputs: (_b = declaration.inputs) !== null && _b !== void 0 ? _b : {},\n        outputs: (_c = declaration.outputs) !== null && _c !== void 0 ? _c : {},\n        host: convertHostDeclarationToMetadata(declaration.host),\n        queries: ((_d = declaration.queries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),\n        viewQueries: ((_e = declaration.viewQueries) !== null && _e !== void 0 ? _e : []).map(convertQueryDeclarationToMetadata),\n        providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\n            null,\n        exportAs: (_f = declaration.exportAs) !== null && _f !== void 0 ? _f : null,\n        usesInheritance: (_g = declaration.usesInheritance) !== null && _g !== void 0 ? _g : false,\n        lifecycle: { usesOnChanges: (_h = declaration.usesOnChanges) !== null && _h !== void 0 ? _h : false },\n        deps: null,\n        typeArgumentCount: 0,\n        fullInheritance: false,\n        isStandalone: (_j = declaration.isStandalone) !== null && _j !== void 0 ? _j : false,\n    };\n}\nfunction convertHostDeclarationToMetadata(host = {}) {\n    var _a, _b, _c;\n    return {\n        attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),\n        listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},\n        properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},\n        specialAttributes: {\n            classAttr: host.classAttribute,\n            styleAttr: host.styleAttribute,\n        },\n    };\n}\nfunction convertOpaqueValuesToExpressions(obj) {\n    const result = {};\n    for (const key of Object.keys(obj)) {\n        result[key] = new WrappedNodeExpr(obj[key]);\n    }\n    return result;\n}\nfunction convertDeclareComponentFacadeToMetadata(decl, typeSourceSpan, sourceMapUrl) {\n    var _a, _b, _c, _d;\n    const { template, interpolation } = parseJitTemplate(decl.template, decl.type.name, sourceMapUrl, (_a = decl.preserveWhitespaces) !== null && _a !== void 0 ? _a : false, decl.interpolation);\n    const declarations = [];\n    if (decl.dependencies) {\n        for (const innerDep of decl.dependencies) {\n            switch (innerDep.kind) {\n                case 'directive':\n                case 'component':\n                    declarations.push(convertDirectiveDeclarationToMetadata(innerDep));\n                    break;\n                case 'pipe':\n                    declarations.push(convertPipeDeclarationToMetadata(innerDep));\n                    break;\n            }\n        }\n    }\n    else if (decl.components || decl.directives || decl.pipes) {\n        // Existing declarations on NPM may not be using the new `dependencies` merged field, and may\n        // have separate fields for dependencies instead. Unify them for JIT compilation.\n        decl.components &&\n            declarations.push(...decl.components.map(dir => convertDirectiveDeclarationToMetadata(dir, /* isComponent */ true)));\n        decl.directives &&\n            declarations.push(...decl.directives.map(dir => convertDirectiveDeclarationToMetadata(dir)));\n        decl.pipes && declarations.push(...convertPipeMapToMetadata(decl.pipes));\n    }\n    return Object.assign(Object.assign({}, convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan)), { template, styles: (_b = decl.styles) !== null && _b !== void 0 ? _b : [], declarations, viewProviders: decl.viewProviders !== undefined ? new WrappedNodeExpr(decl.viewProviders) :\n            null, animations: decl.animations !== undefined ? new WrappedNodeExpr(decl.animations) : null, changeDetection: (_c = decl.changeDetection) !== null && _c !== void 0 ? _c : exports.ChangeDetectionStrategy.Default, encapsulation: (_d = decl.encapsulation) !== null && _d !== void 0 ? _d : exports.ViewEncapsulation.Emulated, interpolation, declarationListEmitMode: 2 /* DeclarationListEmitMode.ClosureResolved */, relativeContextFilePath: '', i18nUseExternalIds: true });\n}\nfunction convertDeclarationFacadeToMetadata(declaration) {\n    return Object.assign(Object.assign({}, declaration), { type: new WrappedNodeExpr(declaration.type) });\n}\nfunction convertDirectiveDeclarationToMetadata(declaration, isComponent = null) {\n    var _a, _b, _c;\n    return {\n        kind: exports.R3TemplateDependencyKind.Directive,\n        isComponent: isComponent || declaration.kind === 'component',\n        selector: declaration.selector,\n        type: new WrappedNodeExpr(declaration.type),\n        inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],\n        outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],\n        exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null,\n    };\n}\nfunction convertPipeMapToMetadata(pipes) {\n    if (!pipes) {\n        return [];\n    }\n    return Object.keys(pipes).map(name => {\n        return {\n            kind: exports.R3TemplateDependencyKind.Pipe,\n            name,\n            type: new WrappedNodeExpr(pipes[name]),\n        };\n    });\n}\nfunction convertPipeDeclarationToMetadata(pipe) {\n    return {\n        kind: exports.R3TemplateDependencyKind.Pipe,\n        name: pipe.name,\n        type: new WrappedNodeExpr(pipe.type),\n    };\n}\nfunction parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {\n    const interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;\n    // Parse the template and check for errors.\n    const parsed = parseTemplate(template, sourceMapUrl, { preserveWhitespaces, interpolationConfig });\n    if (parsed.errors !== null) {\n        const errors = parsed.errors.map(err => err.toString()).join(', ');\n        throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n    }\n    return { template: parsed, interpolation: interpolationConfig };\n}\n/**\n * Convert the expression, if present to an `R3ProviderExpression`.\n *\n * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,\n * if it is referencing a type that has not yet been defined, it will have already been wrapped in\n * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can\n * use `ForwardRefHandling.None`.\n */\nfunction convertToProviderExpression(obj, property) {\n    if (obj.hasOwnProperty(property)) {\n        return createMayBeForwardRefExpression(new WrappedNodeExpr(obj[property]), 0 /* ForwardRefHandling.None */);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction wrapExpression(obj, property) {\n    if (obj.hasOwnProperty(property)) {\n        return new WrappedNodeExpr(obj[property]);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction computeProvidedIn(providedIn) {\n    const expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) :\n        new LiteralExpr(providedIn !== null && providedIn !== void 0 ? providedIn : null);\n    // See `convertToProviderExpression()` for why this uses `ForwardRefHandling.None`.\n    return createMayBeForwardRefExpression(expression, 0 /* ForwardRefHandling.None */);\n}\nfunction convertR3DependencyMetadataArray(facades) {\n    return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\nfunction convertR3DependencyMetadata(facade) {\n    const isAttributeDep = facade.attribute != null; // both `null` and `undefined`\n    const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n    // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in\n    // `attribute` rather than the `token`.\n    const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n    return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\n}\nfunction convertR3DeclareDependencyMetadata(facade) {\n    var _a, _b, _c, _d, _e;\n    const isAttributeDep = (_a = facade.attribute) !== null && _a !== void 0 ? _a : false;\n    const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n    return createR3DependencyMetadata(token, isAttributeDep, (_b = facade.host) !== null && _b !== void 0 ? _b : false, (_c = facade.optional) !== null && _c !== void 0 ? _c : false, (_d = facade.self) !== null && _d !== void 0 ? _d : false, (_e = facade.skipSelf) !== null && _e !== void 0 ? _e : false);\n}\nfunction createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {\n    // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.\n    // But types are not available at runtime so we just use a literal `\"<unknown>\"` string as a dummy\n    // marker.\n    const attributeNameType = isAttributeDep ? literal('unknown') : null;\n    return { token, attributeNameType, host, optional, self, skipSelf };\n}\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\n    // First parse the declarations from the metadata.\n    const bindings = parseHostBindings(host || {});\n    // After that check host bindings for errors\n    const errors = verifyHostBindings(bindings, sourceSpan);\n    if (errors.length) {\n        throw new Error(errors.map((error) => error.msg).join('\\n'));\n    }\n    // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n    for (const field in propMetadata) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(ann => {\n                if (isHostBinding(ann)) {\n                    // Since this is a decorator, we know that the value is a class member. Always access it\n                    // through `this` so that further down the line it can't be confused for a literal value\n                    // (e.g. if there's a property called `true`).\n                    bindings.properties[ann.hostPropertyName || field] =\n                        getSafePropertyAccessString('this', field);\n                }\n                else if (isHostListener(ann)) {\n                    bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n                }\n            });\n        }\n    }\n    return bindings;\n}\nfunction isHostBinding(value) {\n    return value.ngMetadataName === 'HostBinding';\n}\nfunction isHostListener(value) {\n    return value.ngMetadataName === 'HostListener';\n}\nfunction isInput(value) {\n    return value.ngMetadataName === 'Input';\n}\nfunction isOutput(value) {\n    return value.ngMetadataName === 'Output';\n}\nfunction parseInputOutputs(values) {\n    return values.reduce((map, value) => {\n        const [field, property] = value.split(',').map(piece => piece.trim());\n        map[field] = property || field;\n        return map;\n    }, {});\n}\nfunction convertDeclarePipeFacadeToMetadata(declaration) {\n    var _a, _b;\n    return {\n        name: declaration.type.name,\n        type: wrapReference(declaration.type),\n        internalType: new WrappedNodeExpr(declaration.type),\n        typeArgumentCount: 0,\n        pipeName: declaration.name,\n        deps: null,\n        pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true,\n        isStandalone: (_b = declaration.isStandalone) !== null && _b !== void 0 ? _b : false,\n    };\n}\nfunction convertDeclareInjectorFacadeToMetadata(declaration) {\n    return {\n        name: declaration.type.name,\n        type: wrapReference(declaration.type),\n        internalType: new WrappedNodeExpr(declaration.type),\n        providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\n            null,\n        imports: declaration.imports !== undefined ?\n            declaration.imports.map(i => new WrappedNodeExpr(i)) :\n            [],\n    };\n}\nfunction publishFacade(global) {\n    const ng = global.ng || (global.ng = {});\n    ng.ɵcompilerFacade = new CompilerFacadeImpl();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst VERSION = new Version('14.0.0');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass CompilerConfig {\n    constructor({ defaultEncapsulation = exports.ViewEncapsulation.Emulated, useJit = true, jitDevMode = false, missingTranslation = null, preserveWhitespaces, strictInjectionParameters } = {}) {\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = !!useJit;\n        this.jitDevMode = !!jitDevMode;\n        this.missingTranslation = missingTranslation;\n        this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n        this.strictInjectionParameters = strictInjectionParameters === true;\n    }\n}\nfunction preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {\n    return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\n/**\n * Extract translatable messages from an html AST\n */\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    const visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    const visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nclass ExtractionResult {\n    constructor(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n}\nvar _VisitorMode;\n(function (_VisitorMode) {\n    _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n    _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n})(_VisitorMode || (_VisitorMode = {}));\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass _Visitor {\n    constructor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     */\n    extract(nodes, interpolationConfig) {\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(node => node.visit(this, null));\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    }\n    /**\n     * Returns a tree where all translatable nodes are translated\n     */\n    merge(nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        const wrapper = new Element('wrapper', [], nodes, undefined, undefined, undefined);\n        const translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    }\n    visitExpansionCase(icuCase, context) {\n        // Parse cases for translatable html attributes\n        const expression = visitAll(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    }\n    visitExpansion(icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        const wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        const cases = visitAll(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    }\n    visitComment(comment, context) {\n        const isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        const isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n                    if (!i18nCommentsWarned && console && console.warn) {\n                        i18nCommentsWarned = true;\n                        const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n                        // TODO(ocombe): use a log service once there is a public one available\n                        console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`);\n                    }\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc =\n                        comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n                        // merge attributes in sections\n                        const nodes = this._translateMessage(comment, message);\n                        return visitAll(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    visitText(text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    }\n    visitElement(el, context) {\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        const wasInI18nNode = this._inI18nNode;\n        const wasInImplicitNode = this._inImplicitNode;\n        let childNodes = [];\n        let translatedChildNodes = undefined;\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        const i18nAttr = _getI18nAttr(el);\n        const i18nMeta = i18nAttr ? i18nAttr.value : '';\n        const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                const message = this._addMessage(el.children, i18nMeta);\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                const isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                visitAll(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                visitAll(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            const visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(child => {\n                const visited = child.visit(this, context);\n                if (visited && !this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            const translatedAttrs = this._translateAttributes(el);\n            return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n        return null;\n    }\n    visitAttribute(attribute, context) {\n        throw new Error('unreachable code');\n    }\n    _init(mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = undefined;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    }\n    // looks for translatable attributes\n    _visitAttributesOf(el) {\n        const explicitAttrNameToValue = {};\n        const implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(attr => attr.name.startsWith(_I18N_ATTR_PREFIX))\n            .forEach(attr => explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value);\n        el.attrs.forEach(attr => {\n            if (attr.name in explicitAttrNameToValue) {\n                this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(name => attr.name === name)) {\n                this._addMessage([attr]);\n            }\n        });\n    }\n    // add a translatable message\n    _addMessage(ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {\n            // Do not create empty messages\n            return null;\n        }\n        const { meaning, description, id } = _parseMessageMeta(msgMeta);\n        const message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    }\n    // Translates the given message given the `TranslationBundle`\n    // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n    // no-op when called in extraction mode (returns [])\n    _translateMessage(el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            const nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n        }\n        return [];\n    }\n    // translate the attributes of an element and remove i18n specific attributes\n    _translateAttributes(el) {\n        const attributes = el.attrs;\n        const i18nParsedMessageMeta = {};\n        attributes.forEach(attr => {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        const translatedAttributes = [];\n        attributes.forEach((attr) => {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                const { meaning, description, id } = i18nParsedMessageMeta[attr.name];\n                const message = this._createI18nMessage([attr], meaning, description, id);\n                const nodes = this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */));\n                    }\n                    else if (nodes[0] instanceof Text) {\n                        const value = nodes[0].value;\n                        translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */));\n                    }\n                    else {\n                        this._reportError(el, `Unexpected translation for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n                    }\n                }\n                else {\n                    this._reportError(el, `Translation unavailable for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    }\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     */\n    _mayBeAddBlockChildren(node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    }\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     */\n    _openTranslatableSection(node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    }\n    /**\n     * A translatable section could be:\n     * - the content of translatable element,\n     * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n     */\n    get _isInTranslatableSection() {\n        return this._msgCountAtSectionStart !== void 0;\n    }\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     */\n    _closeTranslatableSection(node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        const startIndex = this._msgCountAtSectionStart;\n        const significantChildren = directChildren.reduce((count, node) => count + (node instanceof Comment ? 0 : 1), 0);\n        if (significantChildren == 1) {\n            for (let i = this._messages.length - 1; i >= startIndex; i--) {\n                const ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof Text$2)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = undefined;\n    }\n    _reportError(node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    }\n}\nfunction _isOpeningComment(n) {\n    return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\nfunction _isClosingComment(n) {\n    return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\nfunction _getI18nAttr(p) {\n    return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    const idIndex = i18n.indexOf(ID_SEPARATOR);\n    const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    const [meaningAndDesc, id] = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n    const [meaning, description] = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc];\n    return { meaning, description, id: id.trim() };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass XmlTagDefinition {\n    constructor() {\n        this.closedByParent = false;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n        this.preventNamespaceInheritance = false;\n    }\n    requireExtraParent(currentParent) {\n        return false;\n    }\n    isClosedByChild(name) {\n        return false;\n    }\n    getContentType() {\n        return exports.TagContentType.PARSABLE_DATA;\n    }\n}\nconst _TAG_DEFINITION = new XmlTagDefinition();\nfunction getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass XmlParser extends Parser {\n    constructor() {\n        super(getXmlTagDefinition);\n    }\n    parse(source, url, options) {\n        return super.parse(source, url, options);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _VERSION$1 = '1.2';\nconst _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG$1 = 'en';\nconst _PLACEHOLDER_TAG$2 = 'x';\nconst _MARKER_TAG$1 = 'mrk';\nconst _FILE_TAG = 'file';\nconst _SOURCE_TAG$1 = 'source';\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\nconst _ALT_TRANS_TAG = 'alt-trans';\nconst _TARGET_TAG$1 = 'target';\nconst _UNIT_TAG$1 = 'trans-unit';\nconst _CONTEXT_GROUP_TAG = 'context-group';\nconst _CONTEXT_TAG = 'context';\n// https://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// https://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nclass Xliff extends Serializer {\n    write(messages, locale) {\n        const visitor = new _WriteVisitor$1();\n        const transUnits = [];\n        messages.forEach(message => {\n            let contextTags = [];\n            message.sources.forEach((source) => {\n                let contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });\n                contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new Text$1(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new Text$1(`${source.startLine}`)]), new CR(8));\n                contextTags.push(new CR(8), contextGroupTag);\n            });\n            const transUnit = new Tag(_UNIT_TAG$1, { id: message.id, datatype: 'html' });\n            transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), ...contextTags);\n            if (message.description) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$1(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$1(message.meaning)]));\n            }\n            transUnit.children.push(new CR(6));\n            transUnits.push(new CR(6), transUnit);\n        });\n        const body = new Tag('body', {}, [...transUnits, new CR(4)]);\n        const file = new Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG$1,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new CR(4), body, new CR(2)]);\n        const xliff = new Tag('xliff', { version: _VERSION$1, xmlns: _XMLNS$1 }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    }\n    load(content, url) {\n        // xliff to xml nodes\n        const xliffParser = new XliffParser();\n        const { locale, msgIdToHtml, errors } = xliffParser.parse(content, url);\n        // xml nodes to i18n nodes\n        const i18nNodesByMsgId = {};\n        const converter = new XmlToI18n$2();\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\n            errors.push(...e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: locale, i18nNodesByMsgId };\n    }\n    digest(message) {\n        return digest$1(message);\n    }\n}\nclass _WriteVisitor$1 {\n    visitText(text, context) {\n        return [new Text$1(text.value)];\n    }\n    visitContainer(container, context) {\n        const nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    visitIcu(icu, context) {\n        const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n        });\n        nodes.push(new Text$1(`}`));\n        return nodes;\n    }\n    visitTagPlaceholder(ph, context) {\n        const ctype = getCtypeForTag(ph.tag);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [new Tag(_PLACEHOLDER_TAG$2, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}/>` })];\n        }\n        const startTagPh = new Tag(_PLACEHOLDER_TAG$2, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}>` });\n        const closeTagPh = new Tag(_PLACEHOLDER_TAG$2, { id: ph.closeName, ctype, 'equiv-text': `</${ph.tag}>` });\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n    }\n    visitPlaceholder(ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$2, { id: ph.name, 'equiv-text': `{{${ph.value}}}` })];\n    }\n    visitIcuPlaceholder(ph, context) {\n        const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ')}}`;\n        return [new Tag(_PLACEHOLDER_TAG$2, { id: ph.name, 'equiv-text': equivText })];\n    }\n    serialize(nodes) {\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\n// TODO(vicb): add error management (structure)\n// Extract messages as xml nodes from the xliff file\nclass XliffParser {\n    constructor() {\n        this._locale = null;\n    }\n    parse(xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        const xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    visitElement(element, context) {\n        switch (element.name) {\n            case _UNIT_TAG$1:\n                this._unitMlString = null;\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_UNIT_TAG$1}> misses the \"id\" attribute`);\n                }\n                else {\n                    const id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, `Message ${id} misses a translation`);\n                        }\n                    }\n                }\n                break;\n            // ignore those tags\n            case _SOURCE_TAG$1:\n            case _SEGMENT_SOURCE_TAG:\n            case _ALT_TRANS_TAG:\n                break;\n            case _TARGET_TAG$1:\n                const innerTextStart = element.startSourceSpan.end.offset;\n                const innerTextEnd = element.endSourceSpan.start.offset;\n                const content = element.startSourceSpan.start.file.content;\n                const innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _FILE_TAG:\n                const localeAttr = element.attrs.find((attr) => attr.name === 'target-language');\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                visitAll(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                visitAll(this, element.children, null);\n        }\n    }\n    visitAttribute(attribute, context) { }\n    visitText(text, context) { }\n    visitComment(comment, context) { }\n    visitExpansion(expansion, context) { }\n    visitExpansionCase(expansionCase, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n$2 {\n    convert(message, url) {\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            [].concat(...visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    }\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitElement(el, context) {\n        if (el.name === _PLACEHOLDER_TAG$2) {\n            const nameAttr = el.attrs.find((attr) => attr.name === 'id');\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the \"id\" attribute`);\n            return null;\n        }\n        if (el.name === _MARKER_TAG$1) {\n            return [].concat(...visitAll(this, el.children));\n        }\n        this._addError(el, `Unexpected tag`);\n        return null;\n    }\n    visitExpansion(icu, context) {\n        const caseMap = {};\n        visitAll(this, icu.cases).forEach((c) => {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    }\n    visitComment(comment, context) { }\n    visitAttribute(attribute, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return `x-${tag}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _VERSION = '2.0';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG$1 = 'ph';\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst _MARKER_TAG = 'mrk';\nconst _XLIFF_TAG = 'xliff';\nconst _SOURCE_TAG = 'source';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'unit';\n// https://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nclass Xliff2 extends Serializer {\n    write(messages, locale) {\n        const visitor = new _WriteVisitor();\n        const units = [];\n        messages.forEach(message => {\n            const unit = new Tag(_UNIT_TAG, { id: message.id });\n            const notes = new Tag('notes');\n            if (message.description || message.meaning) {\n                if (message.description) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$1(message.description)]));\n                }\n                if (message.meaning) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$1(message.meaning)]));\n                }\n            }\n            message.sources.forEach((source) => {\n                notes.children.push(new CR(8), new Tag('note', { category: 'location' }, [\n                    new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)\n                ]));\n            });\n            notes.children.push(new CR(6));\n            unit.children.push(new CR(6), notes);\n            const segment = new Tag('segment');\n            segment.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(6));\n            unit.children.push(new CR(6), segment, new CR(4));\n            units.push(new CR(4), unit);\n        });\n        const file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, [...units, new CR(2)]);\n        const xliff = new Tag(_XLIFF_TAG, { version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    }\n    load(content, url) {\n        // xliff to xml nodes\n        const xliff2Parser = new Xliff2Parser();\n        const { locale, msgIdToHtml, errors } = xliff2Parser.parse(content, url);\n        // xml nodes to i18n nodes\n        const i18nNodesByMsgId = {};\n        const converter = new XmlToI18n$1();\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\n            errors.push(...e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: locale, i18nNodesByMsgId };\n    }\n    digest(message) {\n        return decimalDigest(message);\n    }\n}\nclass _WriteVisitor {\n    visitText(text, context) {\n        return [new Text$1(text.value)];\n    }\n    visitContainer(container, context) {\n        const nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    visitIcu(icu, context) {\n        const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n        });\n        nodes.push(new Text$1(`}`));\n        return nodes;\n    }\n    visitTagPlaceholder(ph, context) {\n        const type = getTypeForTag(ph.tag);\n        if (ph.isVoid) {\n            const tagPh = new Tag(_PLACEHOLDER_TAG$1, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.startName,\n                type: type,\n                disp: `<${ph.tag}/>`,\n            });\n            return [tagPh];\n        }\n        const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n            id: (this._nextPlaceholderId++).toString(),\n            equivStart: ph.startName,\n            equivEnd: ph.closeName,\n            type: type,\n            dispStart: `<${ph.tag}>`,\n            dispEnd: `</${ph.tag}>`,\n        });\n        const nodes = [].concat(...ph.children.map(node => node.visit(this)));\n        if (nodes.length) {\n            nodes.forEach((node) => tagPc.children.push(node));\n        }\n        else {\n            tagPc.children.push(new Text$1(''));\n        }\n        return [tagPc];\n    }\n    visitPlaceholder(ph, context) {\n        const idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$1, {\n                id: idStr,\n                equiv: ph.name,\n                disp: `{{${ph.value}}}`,\n            })];\n    }\n    visitIcuPlaceholder(ph, context) {\n        const cases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');\n        const idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: idStr, equiv: ph.name, disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}` })];\n    }\n    serialize(nodes) {\n        this._nextPlaceholderId = 0;\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\n// Extract messages as xml nodes from the xliff file\nclass Xliff2Parser {\n    constructor() {\n        this._locale = null;\n    }\n    parse(xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        const xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    visitElement(element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlString = null;\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n                }\n                else {\n                    const id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, `Message ${id} misses a translation`);\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG:\n                // ignore source message\n                break;\n            case _TARGET_TAG:\n                const innerTextStart = element.startSourceSpan.end.offset;\n                const innerTextEnd = element.endSourceSpan.start.offset;\n                const content = element.startSourceSpan.start.file.content;\n                const innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _XLIFF_TAG:\n                const localeAttr = element.attrs.find((attr) => attr.name === 'trgLang');\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                const versionAttr = element.attrs.find((attr) => attr.name === 'version');\n                if (versionAttr) {\n                    const version = versionAttr.value;\n                    if (version !== '2.0') {\n                        this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                    }\n                }\n                break;\n            default:\n                visitAll(this, element.children, null);\n        }\n    }\n    visitAttribute(attribute, context) { }\n    visitText(text, context) { }\n    visitComment(comment, context) { }\n    visitExpansion(expansion, context) { }\n    visitExpansionCase(expansionCase, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n$1 {\n    convert(message, url) {\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            [].concat(...visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes,\n            errors: this._errors,\n        };\n    }\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitElement(el, context) {\n        switch (el.name) {\n            case _PLACEHOLDER_TAG$1:\n                const nameAttr = el.attrs.find((attr) => attr.name === 'equiv');\n                if (nameAttr) {\n                    return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n                }\n                this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equiv\" attribute`);\n                break;\n            case _PLACEHOLDER_SPANNING_TAG:\n                const startAttr = el.attrs.find((attr) => attr.name === 'equivStart');\n                const endAttr = el.attrs.find((attr) => attr.name === 'equivEnd');\n                if (!startAttr) {\n                    this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivStart\" attribute`);\n                }\n                else if (!endAttr) {\n                    this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivEnd\" attribute`);\n                }\n                else {\n                    const startId = startAttr.value;\n                    const endId = endAttr.value;\n                    const nodes = [];\n                    return nodes.concat(new Placeholder('', startId, el.sourceSpan), ...el.children.map(node => node.visit(this, null)), new Placeholder('', endId, el.sourceSpan));\n                }\n                break;\n            case _MARKER_TAG:\n                return [].concat(...visitAll(this, el.children));\n            default:\n                this._addError(el, `Unexpected tag`);\n        }\n        return null;\n    }\n    visitExpansion(icu, context) {\n        const caseMap = {};\n        visitAll(this, icu.cases).forEach((c) => {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: [].concat(...visitAll(this, icuCase.expression)),\n        };\n    }\n    visitComment(comment, context) { }\n    visitAttribute(attribute, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\nfunction getTypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n        case 'b':\n        case 'i':\n        case 'u':\n            return 'fmt';\n        case 'img':\n            return 'image';\n        case 'a':\n            return 'link';\n        default:\n            return 'other';\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _TRANSLATIONS_TAG = 'translationbundle';\nconst _TRANSLATION_TAG = 'translation';\nconst _PLACEHOLDER_TAG = 'ph';\nclass Xtb extends Serializer {\n    write(messages, locale) {\n        throw new Error('Unsupported');\n    }\n    load(content, url) {\n        // xtb to xml nodes\n        const xtbParser = new XtbParser();\n        const { locale, msgIdToHtml, errors } = xtbParser.parse(content, url);\n        // xml nodes to i18n nodes\n        const i18nNodesByMsgId = {};\n        const converter = new XmlToI18n();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const valueFn = function () {\n                const { i18nNodes, errors } = converter.convert(msgIdToHtml[msgId], url);\n                if (errors.length) {\n                    throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: locale, i18nNodesByMsgId };\n    }\n    digest(message) {\n        return digest(message);\n    }\n    createNameMapper(message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    }\n}\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            const value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value });\n            return value;\n        },\n        set: _ => {\n            throw new Error('Could not overwrite an XTB translation');\n        },\n    });\n}\n// Extract messages as xml nodes from the xtb file\nclass XtbParser {\n    constructor() {\n        this._locale = null;\n    }\n    parse(xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        const xml = new XmlParser().parse(xtb, url);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    visitElement(element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n                }\n                const langAttr = element.attrs.find((attr) => attr.name === 'lang');\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                visitAll(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n                }\n                else {\n                    const id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        const innerTextStart = element.startSourceSpan.end.offset;\n                        const innerTextEnd = element.endSourceSpan.start.offset;\n                        const content = element.startSourceSpan.start.file.content;\n                        const innerText = content.slice(innerTextStart, innerTextEnd);\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    }\n    visitAttribute(attribute, context) { }\n    visitText(text, context) { }\n    visitComment(comment, context) { }\n    visitExpansion(expansion, context) { }\n    visitExpansionCase(expansionCase, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n// Convert ml nodes (xtb syntax) to i18n nodes\nclass XmlToI18n {\n    convert(message, url) {\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes,\n            errors: this._errors,\n        };\n    }\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitExpansion(icu, context) {\n        const caseMap = {};\n        visitAll(this, icu.cases).forEach(c => {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    }\n    visitElement(el, context) {\n        if (el.name === _PLACEHOLDER_TAG) {\n            const nameAttr = el.attrs.find((attr) => attr.name === 'name');\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n        }\n        else {\n            this._addError(el, `Unexpected tag`);\n        }\n        return null;\n    }\n    visitComment(comment, context) { }\n    visitAttribute(attribute, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for translated messages\n */\nclass TranslationBundle {\n    constructor(_i18nNodesByMsgId = {}, locale, digest, mapperFactory, missingTranslationStrategy = MissingTranslationStrategy.Warning, console) {\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    }\n    // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n    static load(content, url, serializer, missingTranslationStrategy, console) {\n        const { locale, i18nNodesByMsgId } = serializer.load(content, url);\n        const digestFn = (m) => serializer.digest(m);\n        const mapperFactory = (m) => serializer.createNameMapper(m);\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    }\n    // Returns the translation as HTML nodes from the given source message.\n    get(srcMsg) {\n        const html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    }\n    has(srcMsg) {\n        return this.digest(srcMsg) in this._i18nNodesByMsgId;\n    }\n}\nclass I18nToHtmlVisitor {\n    constructor(_i18nNodesByMsgId = {}, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    convert(srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        const text = this._convertToText(srcMsg);\n        // text to html\n        const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        const html = new HtmlParser().parse(text, url, { tokenizeExpansionForms: true });\n        return {\n            nodes: html.rootNodes,\n            errors: [...this._errors, ...html.errors],\n        };\n    }\n    visitText(text, context) {\n        // `convert()` uses an `HtmlParser` to return `html.Node`s\n        // we should then make sure that any special characters are escaped\n        return escapeXml(text.value);\n    }\n    visitContainer(container, context) {\n        return container.children.map(n => n.visit(this)).join('');\n    }\n    visitIcu(icu, context) {\n        const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression].text :\n            icu.expression;\n        return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n    }\n    visitPlaceholder(ph, context) {\n        const phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName].text;\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n        return '';\n    }\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    visitTagPlaceholder(ph, context) {\n        const tag = `${ph.tag}`;\n        const attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\n        if (ph.isVoid) {\n            return `<${tag} ${attrs}/>`;\n        }\n        const children = ph.children.map((c) => c.visit(this)).join('');\n        return `<${tag} ${attrs}>${children}</${tag}>`;\n    }\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    visitIcuPlaceholder(ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    }\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     */\n    _convertToText(srcMsg) {\n        const id = this._digest(srcMsg);\n        const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        let nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = (name) => mapper ? mapper.toInternalName(name) : name;\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n                const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n                this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n                const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n                this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = (name) => name;\n        }\n        const text = nodes.map(node => node.visit(this)).join('');\n        const context = this._contextStack.pop();\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    }\n    _addError(el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass I18NHtmlParser {\n    constructor(_htmlParser, translations, translationsFormat, missingTranslation = MissingTranslationStrategy.Warning, console) {\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            const serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n        else {\n            this._translationBundle =\n                new TranslationBundle({}, null, digest$1, undefined, missingTranslation, console);\n        }\n    }\n    parse(source, url, options = {}) {\n        const interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        const parseResult = this._htmlParser.parse(source, url, Object.assign({ interpolationConfig }, options));\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    }\n}\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff2':\n        case 'xlf2':\n            return new Xliff2();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A container for message extracted from the templates.\n */\nclass MessageBundle {\n    constructor(_htmlParser, _implicitTags, _implicitAttrs, _locale = null) {\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    updateFromTemplate(html, url, interpolationConfig) {\n        const htmlParserResult = this._htmlParser.parse(html, url, { tokenizeExpansionForms: true, interpolationConfig });\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        const i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        this._messages.push(...i18nParserResult.messages);\n        return [];\n    }\n    // Return the message in the internal format\n    // The public (serialized) format might be different, see the `write` method.\n    getMessages() {\n        return this._messages;\n    }\n    write(serializer, filterSources) {\n        const messages = {};\n        const mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(message => {\n            const id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n            else {\n                messages[id].sources.push(...message.sources);\n            }\n        });\n        // Transform placeholder names using the serializer mapping\n        const msgList = Object.keys(messages).map(id => {\n            const mapper = serializer.createNameMapper(messages[id]);\n            const src = messages[id];\n            const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            let transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n            transformedMessage.sources = src.sources;\n            if (filterSources) {\n                transformedMessage.sources.forEach((source) => source.filePath = filterSources(source.filePath));\n            }\n            return transformedMessage;\n        });\n        return serializer.write(msgList, this._locale);\n    }\n}\n// Transform an i18n AST by renaming the placeholder nodes with the given mapper\nclass MapPlaceholderNames extends CloneVisitor {\n    convert(nodes, mapper) {\n        return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\n    }\n    visitTagPlaceholder(ph, mapper) {\n        const startName = mapper.toPublicName(ph.startName);\n        const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n        const children = ph.children.map(n => n.visit(this, mapper));\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n    }\n    visitPlaceholder(ph, mapper) {\n        return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    }\n    visitIcuPlaceholder(ph, mapper) {\n        return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar FactoryTarget;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nclass R3TargetBinder {\n    constructor(directiveMatcher) {\n        this.directiveMatcher = directiveMatcher;\n    }\n    /**\n     * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n     * metadata about the types referenced in the template.\n     */\n    bind(target) {\n        if (!target.template) {\n            // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n            throw new Error('Binding without a template not yet supported');\n        }\n        // First, parse the template into a `Scope` structure. This operation captures the syntactic\n        // scopes in the template and makes them available for later use.\n        const scope = Scope.apply(target.template);\n        // Use the `Scope` to extract the entities present at every level of the template.\n        const templateEntities = extractTemplateEntities(scope);\n        // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n        //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n        //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n        //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n        //   - references: Map of #references to their targets.\n        const { directives, bindings, references } = DirectiveBinder.apply(target.template, this.directiveMatcher);\n        // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n        // template. This extracts all the metadata that doesn't depend on directive matching.\n        const { expressions, symbols, nestingLevel, usedPipes } = TemplateBinder.applyWithScope(target.template, scope);\n        return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, templateEntities, usedPipes);\n    }\n}\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nclass Scope {\n    constructor(parentScope, template) {\n        this.parentScope = parentScope;\n        this.template = template;\n        /**\n         * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n         */\n        this.namedEntities = new Map();\n        /**\n         * Child `Scope`s for immediately nested `Template`s.\n         */\n        this.childScopes = new Map();\n    }\n    static newRootScope() {\n        return new Scope(null, null);\n    }\n    /**\n     * Process a template (either as a `Template` sub-template with variables, or a plain array of\n     * template `Node`s) and construct its `Scope`.\n     */\n    static apply(template) {\n        const scope = Scope.newRootScope();\n        scope.ingest(template);\n        return scope;\n    }\n    /**\n     * Internal method to process the template and populate the `Scope`.\n     */\n    ingest(template) {\n        if (template instanceof Template) {\n            // Variables on an <ng-template> are defined in the inner scope.\n            template.variables.forEach(node => this.visitVariable(node));\n            // Process the nodes of the template.\n            template.children.forEach(node => node.visit(this));\n        }\n        else {\n            // No overarching `Template` instance, so process the nodes directly.\n            template.forEach(node => node.visit(this));\n        }\n    }\n    visitElement(element) {\n        // `Element`s in the template may have `Reference`s which are captured in the scope.\n        element.references.forEach(node => this.visitReference(node));\n        // Recurse into the `Element`'s children.\n        element.children.forEach(node => node.visit(this));\n    }\n    visitTemplate(template) {\n        // References on a <ng-template> are defined in the outer scope, so capture them before\n        // processing the template's child scope.\n        template.references.forEach(node => this.visitReference(node));\n        // Next, create an inner scope and process the template within it.\n        const scope = new Scope(this, template);\n        scope.ingest(template);\n        this.childScopes.set(template, scope);\n    }\n    visitVariable(variable) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(variable);\n    }\n    visitReference(reference) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(reference);\n    }\n    // Unused visitors.\n    visitContent(content) { }\n    visitBoundAttribute(attr) { }\n    visitBoundEvent(event) { }\n    visitBoundText(text) { }\n    visitText(text) { }\n    visitTextAttribute(attr) { }\n    visitIcu(icu) { }\n    maybeDeclare(thing) {\n        // Declare something with a name, as long as that name isn't taken.\n        if (!this.namedEntities.has(thing.name)) {\n            this.namedEntities.set(thing.name, thing);\n        }\n    }\n    /**\n     * Look up a variable within this `Scope`.\n     *\n     * This can recurse into a parent `Scope` if it's available.\n     */\n    lookup(name) {\n        if (this.namedEntities.has(name)) {\n            // Found in the local scope.\n            return this.namedEntities.get(name);\n        }\n        else if (this.parentScope !== null) {\n            // Not in the local scope, but there's a parent scope so check there.\n            return this.parentScope.lookup(name);\n        }\n        else {\n            // At the top level and it wasn't found.\n            return null;\n        }\n    }\n    /**\n     * Get the child scope for a `Template`.\n     *\n     * This should always be defined.\n     */\n    getChildScope(template) {\n        const res = this.childScopes.get(template);\n        if (res === undefined) {\n            throw new Error(`Assertion error: child scope for ${template} not found`);\n        }\n        return res;\n    }\n}\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nclass DirectiveBinder {\n    constructor(matcher, directives, bindings, references) {\n        this.matcher = matcher;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n    }\n    /**\n     * Process a template (list of `Node`s) and perform directive matching against each node.\n     *\n     * @param template the list of template `Node`s to match (recursively).\n     * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n     * this template.\n     * @returns three maps which contain information about directives in the template: the\n     * `directives` map which lists directives matched on each node, the `bindings` map which\n     * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n     * map which resolves #references (`Reference`s) within the template to the named directive or\n     * template node.\n     */\n    static apply(template, selectorMatcher) {\n        const directives = new Map();\n        const bindings = new Map();\n        const references = new Map();\n        const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n        matcher.ingest(template);\n        return { directives, bindings, references };\n    }\n    ingest(template) {\n        template.forEach(node => node.visit(this));\n    }\n    visitElement(element) {\n        this.visitElementOrTemplate(element.name, element);\n    }\n    visitTemplate(template) {\n        this.visitElementOrTemplate('ng-template', template);\n    }\n    visitElementOrTemplate(elementName, node) {\n        // First, determine the HTML shape of the node for the purpose of directive matching.\n        // Do this by building up a `CssSelector` for the node.\n        const cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));\n        // Next, use the `SelectorMatcher` to get the list of directives on the node.\n        const directives = [];\n        this.matcher.match(cssSelector, (_, directive) => directives.push(directive));\n        if (directives.length > 0) {\n            this.directives.set(node, directives);\n        }\n        // Resolve any references that are created on this node.\n        node.references.forEach(ref => {\n            let dirTarget = null;\n            // If the reference expression is empty, then it matches the \"primary\" directive on the node\n            // (if there is one). Otherwise it matches the host node itself (either an element or\n            // <ng-template> node).\n            if (ref.value.trim() === '') {\n                // This could be a reference to a component if there is one.\n                dirTarget = directives.find(dir => dir.isComponent) || null;\n            }\n            else {\n                // This should be a reference to a directive exported via exportAs.\n                dirTarget =\n                    directives.find(dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) ||\n                        null;\n                // Check if a matching directive was found.\n                if (dirTarget === null) {\n                    // No matching directive was found - this reference points to an unknown target. Leave it\n                    // unmapped.\n                    return;\n                }\n            }\n            if (dirTarget !== null) {\n                // This reference points to a directive.\n                this.references.set(ref, { directive: dirTarget, node });\n            }\n            else {\n                // This reference points to the node itself.\n                this.references.set(ref, node);\n            }\n        });\n        const setAttributeBinding = (attribute, ioType) => {\n            const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n            const binding = dir !== undefined ? dir : node;\n            this.bindings.set(attribute, binding);\n        };\n        // Node inputs (bound attributes) and text attributes can be bound to an\n        // input on a directive.\n        node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\n        node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\n        if (node instanceof Template) {\n            node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\n        }\n        // Node outputs (bound events) can be bound to an output on a directive.\n        node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\n        // Recurse into the node's children.\n        node.children.forEach(child => child.visit(this));\n    }\n    // Unused visitors.\n    visitContent(content) { }\n    visitVariable(variable) { }\n    visitReference(reference) { }\n    visitTextAttribute(attribute) { }\n    visitBoundAttribute(attribute) { }\n    visitBoundEvent(attribute) { }\n    visitBoundAttributeOrEvent(node) { }\n    visitText(text) { }\n    visitBoundText(text) { }\n    visitIcu(icu) { }\n}\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nclass TemplateBinder extends RecursiveAstVisitor {\n    constructor(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {\n        super();\n        this.bindings = bindings;\n        this.symbols = symbols;\n        this.usedPipes = usedPipes;\n        this.nestingLevel = nestingLevel;\n        this.scope = scope;\n        this.template = template;\n        this.level = level;\n        this.pipesUsed = [];\n        // Save a bit of processing time by constructing this closure in advance.\n        this.visitNode = (node) => node.visit(this);\n    }\n    // This method is defined to reconcile the type of TemplateBinder since both\n    // RecursiveAstVisitor and Visitor define the visit() method in their\n    // interfaces.\n    visit(node, context) {\n        if (node instanceof AST) {\n            node.visit(this, context);\n        }\n        else {\n            node.visit(this);\n        }\n    }\n    /**\n     * Process a template and extract metadata about expressions and symbols within.\n     *\n     * @param template the nodes of the template to process\n     * @param scope the `Scope` of the template being processed.\n     * @returns three maps which contain metadata about the template: `expressions` which interprets\n     * special `AST` nodes in expressions as pointing to references or variables declared within the\n     * template, `symbols` which maps those variables and references to the nested `Template` which\n     * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n     * nesting level (how many levels deep within the template structure the `Template` is), starting\n     * at 1.\n     */\n    static applyWithScope(template, scope) {\n        const expressions = new Map();\n        const symbols = new Map();\n        const nestingLevel = new Map();\n        const usedPipes = new Set();\n        // The top-level template has nesting level 0.\n        const binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);\n        binder.ingest(template);\n        return { expressions, symbols, nestingLevel, usedPipes };\n    }\n    ingest(template) {\n        if (template instanceof Template) {\n            // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n            // and references were all processed in the scope of the containing template.\n            template.variables.forEach(this.visitNode);\n            template.children.forEach(this.visitNode);\n            // Set the nesting level.\n            this.nestingLevel.set(template, this.level);\n        }\n        else {\n            // Visit each node from the top-level template.\n            template.forEach(this.visitNode);\n        }\n    }\n    visitElement(element) {\n        // Visit the inputs, outputs, and children of the element.\n        element.inputs.forEach(this.visitNode);\n        element.outputs.forEach(this.visitNode);\n        element.children.forEach(this.visitNode);\n    }\n    visitTemplate(template) {\n        // First, visit inputs, outputs and template attributes of the template node.\n        template.inputs.forEach(this.visitNode);\n        template.outputs.forEach(this.visitNode);\n        template.templateAttrs.forEach(this.visitNode);\n        // References are also evaluated in the outer context.\n        template.references.forEach(this.visitNode);\n        // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n        const childScope = this.scope.getChildScope(template);\n        const binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);\n        binder.ingest(template);\n    }\n    visitVariable(variable) {\n        // Register the `Variable` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(variable, this.template);\n        }\n    }\n    visitReference(reference) {\n        // Register the `Reference` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(reference, this.template);\n        }\n    }\n    // Unused template visitors\n    visitText(text) { }\n    visitContent(content) { }\n    visitTextAttribute(attribute) { }\n    visitIcu(icu) {\n        Object.keys(icu.vars).forEach(key => icu.vars[key].visit(this));\n        Object.keys(icu.placeholders).forEach(key => icu.placeholders[key].visit(this));\n    }\n    // The remaining visitors are concerned with processing AST expressions within template bindings\n    visitBoundAttribute(attribute) {\n        attribute.value.visit(this);\n    }\n    visitBoundEvent(event) {\n        event.handler.visit(this);\n    }\n    visitBoundText(text) {\n        text.value.visit(this);\n    }\n    visitPipe(ast, context) {\n        this.usedPipes.add(ast.name);\n        return super.visitPipe(ast, context);\n    }\n    // These five types of AST expressions can refer to expression roots, which could be variables\n    // or references in the current scope.\n    visitPropertyRead(ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return super.visitPropertyRead(ast, context);\n    }\n    visitSafePropertyRead(ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return super.visitSafePropertyRead(ast, context);\n    }\n    visitPropertyWrite(ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return super.visitPropertyWrite(ast, context);\n    }\n    maybeMap(scope, ast, name) {\n        // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n        // `AST` expression that maps to a `Variable` or `Reference`.\n        if (!(ast.receiver instanceof ImplicitReceiver)) {\n            return;\n        }\n        // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n        // probably a property on the top-level component context.\n        let target = this.scope.lookup(name);\n        if (target !== null) {\n            this.bindings.set(ast, target);\n        }\n    }\n}\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nclass R3BoundTarget {\n    constructor(target, directives, bindings, references, exprTargets, symbols, nestingLevel, templateEntities, usedPipes) {\n        this.target = target;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n        this.exprTargets = exprTargets;\n        this.symbols = symbols;\n        this.nestingLevel = nestingLevel;\n        this.templateEntities = templateEntities;\n        this.usedPipes = usedPipes;\n    }\n    getEntitiesInTemplateScope(template) {\n        var _a;\n        return (_a = this.templateEntities.get(template)) !== null && _a !== void 0 ? _a : new Set();\n    }\n    getDirectivesOfNode(node) {\n        return this.directives.get(node) || null;\n    }\n    getReferenceTarget(ref) {\n        return this.references.get(ref) || null;\n    }\n    getConsumerOfBinding(binding) {\n        return this.bindings.get(binding) || null;\n    }\n    getExpressionTarget(expr) {\n        return this.exprTargets.get(expr) || null;\n    }\n    getTemplateOfSymbol(symbol) {\n        return this.symbols.get(symbol) || null;\n    }\n    getNestingLevel(template) {\n        return this.nestingLevel.get(template) || 0;\n    }\n    getUsedDirectives() {\n        const set = new Set();\n        this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n        return Array.from(set.values());\n    }\n    getUsedPipes() {\n        return Array.from(this.usedPipes);\n    }\n}\nfunction extractTemplateEntities(rootScope) {\n    const entityMap = new Map();\n    function extractScopeEntities(scope) {\n        if (entityMap.has(scope.template)) {\n            return entityMap.get(scope.template);\n        }\n        const currentEntities = scope.namedEntities;\n        let templateEntities;\n        if (scope.parentScope !== null) {\n            templateEntities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n        }\n        else {\n            templateEntities = new Map(currentEntities);\n        }\n        entityMap.set(scope.template, templateEntities);\n        return templateEntities;\n    }\n    const scopesToProcess = [rootScope];\n    while (scopesToProcess.length > 0) {\n        const scope = scopesToProcess.pop();\n        for (const childScope of scope.childScopes.values()) {\n            scopesToProcess.push(childScope);\n        }\n        extractScopeEntities(scope);\n    }\n    const templateEntities = new Map();\n    for (const [template, entities] of entityMap) {\n        templateEntities.set(template, new Set(entities.values()));\n    }\n    return templateEntities;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction compileClassMetadata(metadata) {\n    var _a, _b;\n    // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its\n    // metadata.\n    const fnCall = importExpr(Identifiers.setClassMetadata).callFn([\n        metadata.type,\n        metadata.decorators,\n        (_a = metadata.ctorParameters) !== null && _a !== void 0 ? _a : literal(null),\n        (_b = metadata.propDecorators) !== null && _b !== void 0 ? _b : literal(null),\n    ]);\n    const iife = fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n    return iife.callFn([]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$6 = '12.0.0';\nfunction compileDeclareClassMetadata(metadata) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$6));\n    definitionMap.set('version', literal('14.0.0'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', metadata.type);\n    definitionMap.set('decorators', metadata.decorators);\n    definitionMap.set('ctorParameters', metadata.ctorParameters);\n    definitionMap.set('propDecorators', metadata.propDecorators);\n    return importExpr(Identifiers.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Creates an array literal expression from the given array, mapping all values to an expression\n * using the provided mapping function. If the array is empty or null, then null is returned.\n *\n * @param values The array to transfer into literal array expression.\n * @param mapper The logic to use for creating an expression for the array's values.\n * @returns An array literal expression representing `values`, or null if `values` is empty or\n * is itself null.\n */\nfunction toOptionalLiteralArray(values, mapper) {\n    if (values === null || values.length === 0) {\n        return null;\n    }\n    return literalArr(values.map(value => mapper(value)));\n}\n/**\n * Creates an object literal expression from the given object, mapping all values to an expression\n * using the provided mapping function. If the object has no keys, then null is returned.\n *\n * @param object The object to transfer into an object literal expression.\n * @param mapper The logic to use for creating an expression for the object's values.\n * @returns An object literal expression representing `object`, or null if `object` does not have\n * any keys.\n */\nfunction toOptionalLiteralMap(object, mapper) {\n    const entries = Object.keys(object).map(key => {\n        const value = object[key];\n        return { key, value: mapper(value), quoted: true };\n    });\n    if (entries.length > 0) {\n        return literalMap(entries);\n    }\n    else {\n        return null;\n    }\n}\nfunction compileDependencies(deps) {\n    if (deps === 'invalid') {\n        // The `deps` can be set to the string \"invalid\"  by the `unwrapConstructorDependencies()`\n        // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.\n        return literal('invalid');\n    }\n    else if (deps === null) {\n        return literal(null);\n    }\n    else {\n        return literalArr(deps.map(compileDependency));\n    }\n}\nfunction compileDependency(dep) {\n    const depMeta = new DefinitionMap();\n    depMeta.set('token', dep.token);\n    if (dep.attributeNameType !== null) {\n        depMeta.set('attribute', literal(true));\n    }\n    if (dep.host) {\n        depMeta.set('host', literal(true));\n    }\n    if (dep.optional) {\n        depMeta.set('optional', literal(true));\n    }\n    if (dep.self) {\n        depMeta.set('self', literal(true));\n    }\n    if (dep.skipSelf) {\n        depMeta.set('skipSelf', literal(true));\n    }\n    return depMeta.toLiteralMap();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$5 = '14.0.0';\n/**\n * Compile a directive declaration defined by the `R3DirectiveMetadata`.\n */\nfunction compileDeclareDirectiveFromMetadata(meta) {\n    const definitionMap = createDirectiveDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declareDirective).callFn([definitionMap.toLiteralMap()]);\n    const type = createDirectiveType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing\n * this logic for components, as they extend the directive metadata.\n */\nfunction createDirectiveDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));\n    definitionMap.set('version', literal('14.0.0'));\n    // e.g. `type: MyDirective`\n    definitionMap.set('type', meta.internalType);\n    if (meta.isStandalone) {\n        definitionMap.set('isStandalone', literal(meta.isStandalone));\n    }\n    // e.g. `selector: 'some-dir'`\n    if (meta.selector !== null) {\n        definitionMap.set('selector', literal(meta.selector));\n    }\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n    definitionMap.set('host', compileHostMetadata(meta.host));\n    definitionMap.set('providers', meta.providers);\n    if (meta.queries.length > 0) {\n        definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));\n    }\n    if (meta.viewQueries.length > 0) {\n        definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));\n    }\n    if (meta.exportAs !== null) {\n        definitionMap.set('exportAs', asLiteral(meta.exportAs));\n    }\n    if (meta.usesInheritance) {\n        definitionMap.set('usesInheritance', literal(true));\n    }\n    if (meta.lifecycle.usesOnChanges) {\n        definitionMap.set('usesOnChanges', literal(true));\n    }\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    return definitionMap;\n}\n/**\n * Compiles the metadata of a single query into its partial declaration form as declared\n * by `R3DeclareQueryMetadata`.\n */\nfunction compileQuery(query) {\n    const meta = new DefinitionMap();\n    meta.set('propertyName', literal(query.propertyName));\n    if (query.first) {\n        meta.set('first', literal(true));\n    }\n    meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) :\n        convertFromMaybeForwardRefExpression(query.predicate));\n    if (!query.emitDistinctChangesOnly) {\n        // `emitDistinctChangesOnly` is special because we expect it to be `true`.\n        // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.\n        meta.set('emitDistinctChangesOnly', literal(false));\n    }\n    if (query.descendants) {\n        meta.set('descendants', literal(true));\n    }\n    meta.set('read', query.read);\n    if (query.static) {\n        meta.set('static', literal(true));\n    }\n    return meta.toLiteralMap();\n}\n/**\n * Compiles the host metadata into its partial declaration form as declared\n * in `R3DeclareDirectiveMetadata['host']`\n */\nfunction compileHostMetadata(meta) {\n    const hostMetadata = new DefinitionMap();\n    hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\n    hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));\n    hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));\n    if (meta.specialAttributes.styleAttr) {\n        hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));\n    }\n    if (meta.specialAttributes.classAttr) {\n        hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));\n    }\n    if (hostMetadata.values.length > 0) {\n        return hostMetadata.toLiteralMap();\n    }\n    else {\n        return null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Compile a component declaration defined by the `R3ComponentMetadata`.\n */\nfunction compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {\n    const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n    const expression = importExpr(Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);\n    const type = createComponentType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a component into a `DefinitionMap`.\n */\nfunction createComponentDefinitionMap(meta, template, templateInfo) {\n    const definitionMap = createDirectiveDefinitionMap(meta);\n    definitionMap.set('template', getTemplateExpression(template, templateInfo));\n    if (templateInfo.isInline) {\n        definitionMap.set('isInline', literal(true));\n    }\n    definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));\n    definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n    definitionMap.set('viewProviders', meta.viewProviders);\n    definitionMap.set('animations', meta.animations);\n    if (meta.changeDetection !== undefined) {\n        definitionMap.set('changeDetection', importExpr(Identifiers.ChangeDetectionStrategy)\n            .prop(exports.ChangeDetectionStrategy[meta.changeDetection]));\n    }\n    if (meta.encapsulation !== exports.ViewEncapsulation.Emulated) {\n        definitionMap.set('encapsulation', importExpr(Identifiers.ViewEncapsulation).prop(exports.ViewEncapsulation[meta.encapsulation]));\n    }\n    if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n        definitionMap.set('interpolation', literalArr([literal(meta.interpolation.start), literal(meta.interpolation.end)]));\n    }\n    if (template.preserveWhitespaces === true) {\n        definitionMap.set('preserveWhitespaces', literal(true));\n    }\n    return definitionMap;\n}\nfunction getTemplateExpression(template, templateInfo) {\n    // If the template has been defined using a direct literal, we use that expression directly\n    // without any modifications. This is ensures proper source mapping from the partially\n    // compiled code to the source file declaring the template. Note that this does not capture\n    // template literals referenced indirectly through an identifier.\n    if (templateInfo.inlineTemplateLiteralExpression !== null) {\n        return templateInfo.inlineTemplateLiteralExpression;\n    }\n    // If the template is defined inline but not through a literal, the template has been resolved\n    // through static interpretation. We create a literal but cannot provide any source span. Note\n    // that we cannot use the expression defining the template because the linker expects the template\n    // to be defined as a literal in the declaration.\n    if (templateInfo.isInline) {\n        return literal(templateInfo.content, null, null);\n    }\n    // The template is external so we must synthesize an expression node with\n    // the appropriate source-span.\n    const contents = templateInfo.content;\n    const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n    const start = new ParseLocation(file, 0, 0, 0);\n    const end = computeEndLocation(file, contents);\n    const span = new ParseSourceSpan(start, end);\n    return literal(contents, null, span);\n}\nfunction computeEndLocation(file, contents) {\n    const length = contents.length;\n    let lineStart = 0;\n    let lastLineStart = 0;\n    let line = 0;\n    do {\n        lineStart = contents.indexOf('\\n', lastLineStart);\n        if (lineStart !== -1) {\n            lastLineStart = lineStart + 1;\n            line++;\n        }\n    } while (lineStart !== -1);\n    return new ParseLocation(file, length, line, length - lastLineStart);\n}\nfunction compileUsedDependenciesMetadata(meta) {\n    const wrapType = meta.declarationListEmitMode !== 0 /* DeclarationListEmitMode.Direct */ ?\n        generateForwardRef :\n        (expr) => expr;\n    return toOptionalLiteralArray(meta.declarations, decl => {\n        switch (decl.kind) {\n            case exports.R3TemplateDependencyKind.Directive:\n                const dirMeta = new DefinitionMap();\n                dirMeta.set('kind', literal(decl.isComponent ? 'component' : 'directive'));\n                dirMeta.set('type', wrapType(decl.type));\n                dirMeta.set('selector', literal(decl.selector));\n                dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, literal));\n                dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, literal));\n                dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, literal));\n                return dirMeta.toLiteralMap();\n            case exports.R3TemplateDependencyKind.Pipe:\n                const pipeMeta = new DefinitionMap();\n                pipeMeta.set('kind', literal('pipe'));\n                pipeMeta.set('type', wrapType(decl.type));\n                pipeMeta.set('name', literal(decl.name));\n                return pipeMeta.toLiteralMap();\n            case exports.R3TemplateDependencyKind.NgModule:\n                const ngModuleMeta = new DefinitionMap();\n                ngModuleMeta.set('kind', literal('ngmodule'));\n                ngModuleMeta.set('type', wrapType(decl.type));\n                return ngModuleMeta.toLiteralMap();\n        }\n    });\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';\nfunction compileDeclareFactoryFunction(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));\n    definitionMap.set('version', literal('14.0.0'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', meta.internalType);\n    definitionMap.set('deps', compileDependencies(meta.deps));\n    definitionMap.set('target', importExpr(Identifiers.FactoryTarget).prop(exports.FactoryTarget[meta.target]));\n    return {\n        expression: importExpr(Identifiers.declareFactory).callFn([definitionMap.toLiteralMap()]),\n        statements: [],\n        type: createFactoryType(meta),\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';\n/**\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\n */\nfunction compileDeclareInjectableFromMetadata(meta) {\n    const definitionMap = createInjectableDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n    const type = createInjectableType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\n */\nfunction createInjectableDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));\n    definitionMap.set('version', literal('14.0.0'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', meta.internalType);\n    // Only generate providedIn property if it has a non-null value\n    if (meta.providedIn !== undefined) {\n        const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n        if (providedIn.value !== null) {\n            definitionMap.set('providedIn', providedIn);\n        }\n    }\n    if (meta.useClass !== undefined) {\n        definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n    }\n    if (meta.useExisting !== undefined) {\n        definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n    }\n    if (meta.useValue !== undefined) {\n        definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n    }\n    // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n    // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n    // with `convertFromProviderExpression()`.\n    if (meta.useFactory !== undefined) {\n        definitionMap.set('useFactory', meta.useFactory);\n    }\n    if (meta.deps !== undefined) {\n        definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));\n    }\n    return definitionMap;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';\nfunction compileDeclareInjectorFromMetadata(meta) {\n    const definitionMap = createInjectorDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declareInjector).callFn([definitionMap.toLiteralMap()]);\n    const type = createInjectorType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for an Injector into a `DefinitionMap`.\n */\nfunction createInjectorDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));\n    definitionMap.set('version', literal('14.0.0'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', meta.internalType);\n    definitionMap.set('providers', meta.providers);\n    if (meta.imports.length > 0) {\n        definitionMap.set('imports', literalArr(meta.imports));\n    }\n    return definitionMap;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$1 = '14.0.0';\nfunction compileDeclareNgModuleFromMetadata(meta) {\n    const definitionMap = createNgModuleDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n    const type = createNgModuleType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for an NgModule into a `DefinitionMap`.\n */\nfunction createNgModuleDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));\n    definitionMap.set('version', literal('14.0.0'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', meta.internalType);\n    // We only generate the keys in the metadata if the arrays contain values.\n    // We must wrap the arrays inside a function if any of the values are a forward reference to a\n    // not-yet-declared class. This is to support JIT execution of the `ɵɵngDeclareNgModule()` call.\n    // In the linker these wrappers are stripped and then reapplied for the `ɵɵdefineNgModule()` call.\n    if (meta.bootstrap.length > 0) {\n        definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n    }\n    if (meta.declarations.length > 0) {\n        definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n    if (meta.imports.length > 0) {\n        definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n    if (meta.exports.length > 0) {\n        definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n    if (meta.schemas !== null && meta.schemas.length > 0) {\n        definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\n    }\n    if (meta.id !== null) {\n        definitionMap.set('id', meta.id);\n    }\n    return definitionMap;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n/**\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\n */\nfunction compileDeclarePipeFromMetadata(meta) {\n    const definitionMap = createPipeDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);\n    const type = createPipeType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`.\n */\nfunction createPipeDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));\n    definitionMap.set('version', literal('14.0.0'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    // e.g. `type: MyPipe`\n    definitionMap.set('type', meta.internalType);\n    if (meta.isStandalone) {\n        definitionMap.set('isStandalone', literal(meta.isStandalone));\n    }\n    // e.g. `name: \"myPipe\"`\n    definitionMap.set('name', literal(meta.pipeName));\n    if (meta.pure === false) {\n        // e.g. `pure: false`\n        definitionMap.set('pure', literal(meta.pure));\n    }\n    return definitionMap;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\npublishFacade(_global);\n\nexports.AST = AST;\nexports.ASTWithName = ASTWithName;\nexports.ASTWithSource = ASTWithSource;\nexports.AbsoluteSourceSpan = AbsoluteSourceSpan;\nexports.ArrayType = ArrayType;\nexports.AstMemoryEfficientTransformer = AstMemoryEfficientTransformer;\nexports.AstTransformer = AstTransformer;\nexports.Attribute = Attribute;\nexports.Binary = Binary;\nexports.BinaryOperatorExpr = BinaryOperatorExpr;\nexports.BindingPipe = BindingPipe;\nexports.BoundElementProperty = BoundElementProperty;\nexports.BuiltinType = BuiltinType;\nexports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;\nexports.Call = Call;\nexports.Chain = Chain;\nexports.CommaExpr = CommaExpr;\nexports.Comment = Comment;\nexports.CompilerConfig = CompilerConfig;\nexports.Conditional = Conditional;\nexports.ConditionalExpr = ConditionalExpr;\nexports.ConstantPool = ConstantPool;\nexports.CssSelector = CssSelector;\nexports.DEFAULT_INTERPOLATION_CONFIG = DEFAULT_INTERPOLATION_CONFIG;\nexports.DYNAMIC_TYPE = DYNAMIC_TYPE;\nexports.DeclareFunctionStmt = DeclareFunctionStmt;\nexports.DeclareVarStmt = DeclareVarStmt;\nexports.DomElementSchemaRegistry = DomElementSchemaRegistry;\nexports.EOF = EOF;\nexports.Element = Element;\nexports.ElementSchemaRegistry = ElementSchemaRegistry;\nexports.EmitterVisitorContext = EmitterVisitorContext;\nexports.EmptyExpr = EmptyExpr;\nexports.Expansion = Expansion;\nexports.ExpansionCase = ExpansionCase;\nexports.Expression = Expression;\nexports.ExpressionBinding = ExpressionBinding;\nexports.ExpressionStatement = ExpressionStatement;\nexports.ExpressionType = ExpressionType;\nexports.ExternalExpr = ExternalExpr;\nexports.ExternalReference = ExternalReference;\nexports.FunctionExpr = FunctionExpr;\nexports.HtmlParser = HtmlParser;\nexports.HtmlTagDefinition = HtmlTagDefinition;\nexports.I18NHtmlParser = I18NHtmlParser;\nexports.IfStmt = IfStmt;\nexports.ImplicitReceiver = ImplicitReceiver;\nexports.InstantiateExpr = InstantiateExpr;\nexports.Interpolation = Interpolation;\nexports.InterpolationConfig = InterpolationConfig;\nexports.InvokeFunctionExpr = InvokeFunctionExpr;\nexports.JSDocComment = JSDocComment;\nexports.JitEvaluator = JitEvaluator;\nexports.KeyedRead = KeyedRead;\nexports.KeyedWrite = KeyedWrite;\nexports.LeadingComment = LeadingComment;\nexports.Lexer = Lexer;\nexports.LiteralArray = LiteralArray;\nexports.LiteralArrayExpr = LiteralArrayExpr;\nexports.LiteralExpr = LiteralExpr;\nexports.LiteralMap = LiteralMap;\nexports.LiteralMapExpr = LiteralMapExpr;\nexports.LiteralPrimitive = LiteralPrimitive;\nexports.LocalizedString = LocalizedString;\nexports.MapType = MapType;\nexports.MessageBundle = MessageBundle;\nexports.NONE_TYPE = NONE_TYPE;\nexports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;\nexports.NodeWithI18n = NodeWithI18n;\nexports.NonNullAssert = NonNullAssert;\nexports.NotExpr = NotExpr;\nexports.ParseError = ParseError;\nexports.ParseLocation = ParseLocation;\nexports.ParseSourceFile = ParseSourceFile;\nexports.ParseSourceSpan = ParseSourceSpan;\nexports.ParseSpan = ParseSpan;\nexports.ParseTreeResult = ParseTreeResult;\nexports.ParsedEvent = ParsedEvent;\nexports.ParsedProperty = ParsedProperty;\nexports.ParsedVariable = ParsedVariable;\nexports.Parser = Parser$1;\nexports.ParserError = ParserError;\nexports.PrefixNot = PrefixNot;\nexports.PropertyRead = PropertyRead;\nexports.PropertyWrite = PropertyWrite;\nexports.R3BoundTarget = R3BoundTarget;\nexports.R3Identifiers = Identifiers;\nexports.R3TargetBinder = R3TargetBinder;\nexports.ReadKeyExpr = ReadKeyExpr;\nexports.ReadPropExpr = ReadPropExpr;\nexports.ReadVarExpr = ReadVarExpr;\nexports.RecursiveAstVisitor = RecursiveAstVisitor;\nexports.RecursiveVisitor = RecursiveVisitor;\nexports.ResourceLoader = ResourceLoader;\nexports.ReturnStatement = ReturnStatement;\nexports.STRING_TYPE = STRING_TYPE;\nexports.SafeCall = SafeCall;\nexports.SafeKeyedRead = SafeKeyedRead;\nexports.SafePropertyRead = SafePropertyRead;\nexports.SelectorContext = SelectorContext;\nexports.SelectorListContext = SelectorListContext;\nexports.SelectorMatcher = SelectorMatcher;\nexports.Serializer = Serializer;\nexports.SplitInterpolation = SplitInterpolation;\nexports.Statement = Statement;\nexports.TaggedTemplateExpr = TaggedTemplateExpr;\nexports.TemplateBindingParseResult = TemplateBindingParseResult;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TemplateLiteralElement = TemplateLiteralElement;\nexports.Text = Text;\nexports.ThisReceiver = ThisReceiver;\nexports.TmplAstBoundAttribute = BoundAttribute;\nexports.TmplAstBoundEvent = BoundEvent;\nexports.TmplAstBoundText = BoundText;\nexports.TmplAstContent = Content;\nexports.TmplAstElement = Element$1;\nexports.TmplAstIcu = Icu$1;\nexports.TmplAstRecursiveVisitor = RecursiveVisitor$1;\nexports.TmplAstReference = Reference;\nexports.TmplAstTemplate = Template;\nexports.TmplAstText = Text$3;\nexports.TmplAstTextAttribute = TextAttribute;\nexports.TmplAstVariable = Variable;\nexports.Token = Token;\nexports.TreeError = TreeError;\nexports.Type = Type;\nexports.TypeofExpr = TypeofExpr;\nexports.Unary = Unary;\nexports.UnaryOperatorExpr = UnaryOperatorExpr;\nexports.VERSION = VERSION;\nexports.VariableBinding = VariableBinding;\nexports.Version = Version;\nexports.WrappedNodeExpr = WrappedNodeExpr;\nexports.WriteKeyExpr = WriteKeyExpr;\nexports.WritePropExpr = WritePropExpr;\nexports.WriteVarExpr = WriteVarExpr;\nexports.Xliff = Xliff;\nexports.Xliff2 = Xliff2;\nexports.Xmb = Xmb;\nexports.XmlParser = XmlParser;\nexports.Xtb = Xtb;\nexports._ParseAST = _ParseAST;\nexports.compileClassMetadata = compileClassMetadata;\nexports.compileComponentFromMetadata = compileComponentFromMetadata;\nexports.compileDeclareClassMetadata = compileDeclareClassMetadata;\nexports.compileDeclareComponentFromMetadata = compileDeclareComponentFromMetadata;\nexports.compileDeclareDirectiveFromMetadata = compileDeclareDirectiveFromMetadata;\nexports.compileDeclareFactoryFunction = compileDeclareFactoryFunction;\nexports.compileDeclareInjectableFromMetadata = compileDeclareInjectableFromMetadata;\nexports.compileDeclareInjectorFromMetadata = compileDeclareInjectorFromMetadata;\nexports.compileDeclareNgModuleFromMetadata = compileDeclareNgModuleFromMetadata;\nexports.compileDeclarePipeFromMetadata = compileDeclarePipeFromMetadata;\nexports.compileDirectiveFromMetadata = compileDirectiveFromMetadata;\nexports.compileFactoryFunction = compileFactoryFunction;\nexports.compileInjectable = compileInjectable;\nexports.compileInjector = compileInjector;\nexports.compileNgModule = compileNgModule;\nexports.compilePipeFromMetadata = compilePipeFromMetadata;\nexports.computeMsgId = computeMsgId;\nexports.core = core;\nexports.createInjectableType = createInjectableType;\nexports.createMayBeForwardRefExpression = createMayBeForwardRefExpression;\nexports.devOnlyGuardedExpression = devOnlyGuardedExpression;\nexports.emitDistinctChangesOnlyDefaultValue = emitDistinctChangesOnlyDefaultValue;\nexports.getHtmlTagDefinition = getHtmlTagDefinition;\nexports.getNsPrefix = getNsPrefix;\nexports.getSafePropertyAccessString = getSafePropertyAccessString;\nexports.identifierName = identifierName;\nexports.isIdentifier = isIdentifier;\nexports.isNgContainer = isNgContainer;\nexports.isNgContent = isNgContent;\nexports.isNgTemplate = isNgTemplate;\nexports.jsDocComment = jsDocComment;\nexports.leadingComment = leadingComment;\nexports.literalMap = literalMap;\nexports.makeBindingParser = makeBindingParser;\nexports.mergeNsAndName = mergeNsAndName;\nexports.outputAst = output_ast;\nexports.parseHostBindings = parseHostBindings;\nexports.parseTemplate = parseTemplate;\nexports.preserveWhitespacesDefault = preserveWhitespacesDefault;\nexports.publishFacade = publishFacade;\nexports.r3JitTypeSourceSpan = r3JitTypeSourceSpan;\nexports.sanitizeIdentifier = sanitizeIdentifier;\nexports.splitNsName = splitNsName;\nexports.verifyHostBindings = verifyHostBindings;\nexports.visitAll = visitAll;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXItZXNsaW50L2J1bmRsZWQtYW5ndWxhci1jb21waWxlci9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyLWVzbGludC9idW5kbGVkLWFuZ3VsYXItY29tcGlsZXIvZGlzdC9pbmRleC5qcz82OGNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2MTQuMC4wXG4gKiAoYykgMjAxMC0yMDIyIEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZXhwb3J0cy5UYWdDb250ZW50VHlwZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoVGFnQ29udGVudFR5cGUpIHtcbiAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIlJBV19URVhUXCJdID0gMF0gPSBcIlJBV19URVhUXCI7XG4gICAgVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGVbXCJFU0NBUEFCTEVfUkFXX1RFWFRcIl0gPSAxXSA9IFwiRVNDQVBBQkxFX1JBV19URVhUXCI7XG4gICAgVGFnQ29udGVudFR5cGVbVGFnQ29udGVudFR5cGVbXCJQQVJTQUJMRV9EQVRBXCJdID0gMl0gPSBcIlBBUlNBQkxFX0RBVEFcIjtcbn0pKGV4cG9ydHMuVGFnQ29udGVudFR5cGUgfHwgKGV4cG9ydHMuVGFnQ29udGVudFR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpIHtcbiAgICBpZiAoZWxlbWVudE5hbWVbMF0gIT0gJzonKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgZWxlbWVudE5hbWVdO1xuICAgIH1cbiAgICBjb25zdCBjb2xvbkluZGV4ID0gZWxlbWVudE5hbWUuaW5kZXhPZignOicsIDEpO1xuICAgIGlmIChjb2xvbkluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGZvcm1hdCBcIiR7ZWxlbWVudE5hbWV9XCIgZXhwZWN0aW5nIFwiOm5hbWVzcGFjZTpuYW1lXCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtlbGVtZW50TmFtZS5zbGljZSgxLCBjb2xvbkluZGV4KSwgZWxlbWVudE5hbWUuc2xpY2UoY29sb25JbmRleCArIDEpXTtcbn1cbi8vIGA8bmctY29udGFpbmVyPmAgdGFncyB3b3JrIHRoZSBzYW1lIHJlZ2FyZGxlc3MgdGhlIG5hbWVzcGFjZVxuZnVuY3Rpb24gaXNOZ0NvbnRhaW5lcih0YWdOYW1lKSB7XG4gICAgcmV0dXJuIHNwbGl0TnNOYW1lKHRhZ05hbWUpWzFdID09PSAnbmctY29udGFpbmVyJztcbn1cbi8vIGA8bmctY29udGVudD5gIHRhZ3Mgd29yayB0aGUgc2FtZSByZWdhcmRsZXNzIHRoZSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGlzTmdDb250ZW50KHRhZ05hbWUpIHtcbiAgICByZXR1cm4gc3BsaXROc05hbWUodGFnTmFtZSlbMV0gPT09ICduZy1jb250ZW50Jztcbn1cbi8vIGA8bmctdGVtcGxhdGU+YCB0YWdzIHdvcmsgdGhlIHNhbWUgcmVnYXJkbGVzcyB0aGUgbmFtZXNwYWNlXG5mdW5jdGlvbiBpc05nVGVtcGxhdGUodGFnTmFtZSkge1xuICAgIHJldHVybiBzcGxpdE5zTmFtZSh0YWdOYW1lKVsxXSA9PT0gJ25nLXRlbXBsYXRlJztcbn1cbmZ1bmN0aW9uIGdldE5zUHJlZml4KGZ1bGxOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bGxOYW1lID09PSBudWxsID8gbnVsbCA6IHNwbGl0TnNOYW1lKGZ1bGxOYW1lKVswXTtcbn1cbmZ1bmN0aW9uIG1lcmdlTnNBbmROYW1lKHByZWZpeCwgbG9jYWxOYW1lKSB7XG4gICAgcmV0dXJuIHByZWZpeCA/IGA6JHtwcmVmaXh9OiR7bG9jYWxOYW1lfWAgOiBsb2NhbE5hbWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgSHRtbFRhZ0RlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHsgY2xvc2VkQnlDaGlsZHJlbiwgaW1wbGljaXROYW1lc3BhY2VQcmVmaXgsIGNvbnRlbnRUeXBlID0gZXhwb3J0cy5UYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBLCBjbG9zZWRCeVBhcmVudCA9IGZhbHNlLCBpc1ZvaWQgPSBmYWxzZSwgaWdub3JlRmlyc3RMZiA9IGZhbHNlLCBwcmV2ZW50TmFtZXNwYWNlSW5oZXJpdGFuY2UgPSBmYWxzZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5jbG9zZWRCeUNoaWxkcmVuID0ge307XG4gICAgICAgIHRoaXMuY2xvc2VkQnlQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNsb3NlZEJ5Q2hpbGRyZW4gJiYgY2xvc2VkQnlDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjbG9zZWRCeUNoaWxkcmVuLmZvckVhY2godGFnTmFtZSA9PiB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW5bdGFnTmFtZV0gPSB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGNsb3NlZEJ5UGFyZW50IHx8IGlzVm9pZDtcbiAgICAgICAgdGhpcy5pbXBsaWNpdE5hbWVzcGFjZVByZWZpeCA9IGltcGxpY2l0TmFtZXNwYWNlUHJlZml4IHx8IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZTtcbiAgICAgICAgdGhpcy5pZ25vcmVGaXJzdExmID0gaWdub3JlRmlyc3RMZjtcbiAgICAgICAgdGhpcy5wcmV2ZW50TmFtZXNwYWNlSW5oZXJpdGFuY2UgPSBwcmV2ZW50TmFtZXNwYWNlSW5oZXJpdGFuY2U7XG4gICAgfVxuICAgIGlzQ2xvc2VkQnlDaGlsZChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVm9pZCB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgaW4gdGhpcy5jbG9zZWRCeUNoaWxkcmVuO1xuICAgIH1cbiAgICBnZXRDb250ZW50VHlwZShwcmVmaXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbnRlbnRUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGVUeXBlID0gcHJlZml4ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB0aGlzLmNvbnRlbnRUeXBlW3ByZWZpeF07XG4gICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGVUeXBlICE9PSBudWxsICYmIG92ZXJyaWRlVHlwZSAhPT0gdm9pZCAwID8gb3ZlcnJpZGVUeXBlIDogdGhpcy5jb250ZW50VHlwZS5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRUeXBlO1xuICAgIH1cbn1cbmxldCBfREVGQVVMVF9UQUdfREVGSU5JVElPTjtcbi8vIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI29wdGlvbmFsLXRhZ3Ncbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgZnVsbHkgY29uZm9ybSB0byB0aGUgSFRNTDUgc3BlYy5cbmxldCBUQUdfREVGSU5JVElPTlM7XG5mdW5jdGlvbiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIVRBR19ERUZJTklUSU9OUykge1xuICAgICAgICBfREVGQVVMVF9UQUdfREVGSU5JVElPTiA9IG5ldyBIdG1sVGFnRGVmaW5pdGlvbigpO1xuICAgICAgICBUQUdfREVGSU5JVElPTlMgPSB7XG4gICAgICAgICAgICAnYmFzZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdtZXRhJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2FyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnZW1iZWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnbGluayc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdpbWcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnaW5wdXQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAncGFyYW0nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnaHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnYnInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnc291cmNlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3RyYWNrJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3dicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHtcbiAgICAgICAgICAgICAgICBjbG9zZWRCeUNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgICdhZGRyZXNzJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmxvY2txdW90ZScsICdkaXYnLCAnZGwnLCAnZmllbGRzZXQnLFxuICAgICAgICAgICAgICAgICAgICAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLFxuICAgICAgICAgICAgICAgICAgICAnaDYnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdtYWluJywgJ25hdicsICdvbCcsXG4gICAgICAgICAgICAgICAgICAgICdwJywgJ3ByZScsICdzZWN0aW9uJywgJ3RhYmxlJywgJ3VsJ1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgY2xvc2VkQnlQYXJlbnQ6IHRydWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgJ3RoZWFkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddIH0pLFxuICAgICAgICAgICAgJ3Rib2R5JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keScsICd0Zm9vdCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICd0Zm9vdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGJvZHknXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAndHInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RyJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3RkJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICd0aCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndGQnLCAndGgnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAnY29sJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3N2Zyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGltcGxpY2l0TmFtZXNwYWNlUHJlZml4OiAnc3ZnJyB9KSxcbiAgICAgICAgICAgICdmb3JlaWduT2JqZWN0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHtcbiAgICAgICAgICAgICAgICAvLyBVc3VhbGx5IHRoZSBpbXBsaWNpdCBuYW1lc3BhY2UgaGVyZSB3b3VsZCBiZSByZWR1bmRhbnQgc2luY2UgaXQgd2lsbCBiZSBpbmhlcml0ZWQgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHRoZSBwYXJlbnQgYHN2Z2AsIGJ1dCB3ZSBoYXZlIHRvIGRvIGl0IGZvciBgZm9yZWlnbk9iamVjdGAsIGJlY2F1c2UgdGhlIHdheSB0aGUgcGFyc2VyXG4gICAgICAgICAgICAgICAgLy8gd29ya3MgaXMgdGhhdCB0aGUgcGFyZW50IG5vZGUgb2YgYW4gZW5kIHRhZyBpcyBpdHMgb3duIHN0YXJ0IHRhZyB3aGljaCBtZWFucyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGBwcmV2ZW50TmFtZXNwYWNlSW5oZXJpdGFuY2VgIG9uIGBmb3JlaWduT2JqZWN0YCB3b3VsZCBoYXZlIGl0IGRlZmF1bHQgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gaW1wbGljaXQgbmFtZXNwYWNlIHdoaWNoIGlzIGBodG1sYCwgdW5sZXNzIHNwZWNpZmllZCBvdGhlcndpc2UuXG4gICAgICAgICAgICAgICAgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdzdmcnLFxuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gcHJldmVudCBjaGlsZHJlbiBvZiBmb3JlaWduT2JqZWN0IGZyb20gaW5oZXJpdGluZyBpdHMgbmFtZXNwYWNlLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBvaW50IG9mIHRoZSBlbGVtZW50IGlzIHRvIGFsbG93IG5vZGVzIGZyb20gb3RoZXIgbmFtZXNwYWNlcyB0byBiZSBpbnNlcnRlZC5cbiAgICAgICAgICAgICAgICBwcmV2ZW50TmFtZXNwYWNlSW5oZXJpdGFuY2U6IHRydWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdtYXRoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdtYXRoJyB9KSxcbiAgICAgICAgICAgICdsaSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnbGknXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAnZHQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10gfSksXG4gICAgICAgICAgICAnZGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ2R0JywgJ2RkJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3JiJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAncnQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdydGMnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdycCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ29wdGdyb3VwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdvcHRpb24nOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGlvbicsICdvcHRncm91cCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdwcmUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2xpc3RpbmcnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3N0eWxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IGV4cG9ydHMuVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgICAgICAgICAnc2NyaXB0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IGV4cG9ydHMuVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgICAgICAgICAndGl0bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICAgICAgICAgIC8vIFRoZSBicm93c2VyIHN1cHBvcnRzIHR3byBzZXBhcmF0ZSBgdGl0bGVgIHRhZ3Mgd2hpY2ggaGF2ZSB0byB1c2VcbiAgICAgICAgICAgICAgICAvLyBhIGRpZmZlcmVudCBjb250ZW50IHR5cGU6IGBIVE1MVGl0bGVFbGVtZW50YCBhbmQgYFNWR1RpdGxlRWxlbWVudGBcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogeyBkZWZhdWx0OiBleHBvcnRzLlRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCwgc3ZnOiBleHBvcnRzLlRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAndGV4dGFyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogZXhwb3J0cy5UYWdDb250ZW50VHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQsIGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFdlIGhhdmUgdG8gbWFrZSBib3RoIGEgY2FzZS1zZW5zaXRpdmUgYW5kIGEgY2FzZS1pbnNlbnNpdGl2ZSBsb29rdXAsIGJlY2F1c2VcbiAgICAvLyBIVE1MIHRhZyBuYW1lcyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgd2hlcmVhcyBzb21lIFNWRyB0YWdzIGFyZSBjYXNlIHNlbnNpdGl2ZS5cbiAgICByZXR1cm4gKF9iID0gKF9hID0gVEFHX0RFRklOSVRJT05TW3RhZ05hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBUQUdfREVGSU5JVElPTlNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX0RFRkFVTFRfVEFHX0RFRklOSVRJT047XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgX1NFTEVDVE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJyhcXFxcOm5vdFxcXFwoKXwnICsgLy8gMTogXCI6bm90KFwiXG4gICAgJygoW1xcXFwuXFxcXCNdPylbLVxcXFx3XSspfCcgKyAvLyAyOiBcInRhZ1wiOyAzOiBcIi5cIi9cIiNcIjtcbiAgICAvLyBcIi1cIiBzaG91bGQgYXBwZWFyIGZpcnN0IGluIHRoZSByZWdleHAgYmVsb3cgYXMgRkYzMSBwYXJzZXMgXCJbLi1cXHddXCIgYXMgYSByYW5nZVxuICAgIC8vIDQ6IGF0dHJpYnV0ZTsgNTogYXR0cmlidXRlX3N0cmluZzsgNjogYXR0cmlidXRlX3ZhbHVlXG4gICAgJyg/OlxcXFxbKFstLlxcXFx3KlxcXFxcXFxcJF0rKSg/Oj0oW1xcXCJcXCddPykoW15cXFxcXVxcXCJcXCddKilcXFxcNSk/XFxcXF0pfCcgKyAvLyBcIltuYW1lXVwiLCBcIltuYW1lPXZhbHVlXVwiLFxuICAgIC8vIFwiW25hbWU9XCJ2YWx1ZVwiXVwiLFxuICAgIC8vIFwiW25hbWU9J3ZhbHVlJ11cIlxuICAgICcoXFxcXCkpfCcgKyAvLyA3OiBcIilcIlxuICAgICcoXFxcXHMqLFxcXFxzKiknLCAvLyA4OiBcIixcIlxuJ2cnKTtcbi8qKlxuICogQSBjc3Mgc2VsZWN0b3IgY29udGFpbnMgYW4gZWxlbWVudCBuYW1lLFxuICogY3NzIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZS92YWx1ZSBwYWlycyB3aXRoIHRoZSBwdXJwb3NlXG4gKiBvZiBzZWxlY3Rpbmcgc3Vic2V0cyBvdXQgb2YgdGhlbS5cbiAqL1xuY2xhc3MgQ3NzU2VsZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZWxlY3RvcnMgYXJlIGVuY29kZWQgaW4gcGFpcnMgd2hlcmU6XG4gICAgICAgICAqIC0gZXZlbiBsb2NhdGlvbnMgYXJlIGF0dHJpYnV0ZSBuYW1lc1xuICAgICAgICAgKiAtIG9kZCBsb2NhdGlvbnMgYXJlIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAqIFNlbGVjdG9yOiBgW2tleTE9dmFsdWUxXVtrZXkyXWAgd291bGQgcGFyc2UgdG86XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBbJ2tleTEnLCAndmFsdWUxJywgJ2tleTInLCAnJ11cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dHJzID0gW107XG4gICAgICAgIHRoaXMubm90U2VsZWN0b3JzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IF9hZGRSZXN1bHQgPSAocmVzLCBjc3NTZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChjc3NTZWwubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgIWNzc1NlbC5lbGVtZW50ICYmIGNzc1NlbC5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgY3NzU2VsLmF0dHJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3NzU2VsLmVsZW1lbnQgPSAnKic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChjc3NTZWwpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY3NzU2VsZWN0b3IgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBsZXQgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICBsZXQgaW5Ob3QgPSBmYWxzZTtcbiAgICAgICAgX1NFTEVDVE9SX1JFR0VYUC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSBfU0VMRUNUT1JfUkVHRVhQLmV4ZWMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hbMSAvKiBTZWxlY3RvclJlZ2V4cC5OT1QgKi9dKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluTm90KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVzdGluZyA6bm90IGluIGEgc2VsZWN0b3IgaXMgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5Ob3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgICBjc3NTZWxlY3Rvci5ub3RTZWxlY3RvcnMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IG1hdGNoWzIgLyogU2VsZWN0b3JSZWdleHAuVEFHICovXTtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBtYXRjaFszIC8qIFNlbGVjdG9yUmVnZXhwLlBSRUZJWCAqL107XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICNoYXNoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQXR0cmlidXRlKCdpZCcsIHRhZy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsYXNzXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQ2xhc3NOYW1lKHRhZy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0RWxlbWVudCh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG1hdGNoWzQgLyogU2VsZWN0b3JSZWdleHAuQVRUUklCVVRFICovXTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmFkZEF0dHJpYnV0ZShjdXJyZW50LnVuZXNjYXBlQXR0cmlidXRlKGF0dHJpYnV0ZSksIG1hdGNoWzYgLyogU2VsZWN0b3JSZWdleHAuQVRUUklCVVRFX1ZBTFVFICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNyAvKiBTZWxlY3RvclJlZ2V4cC5OT1RfRU5EICovXSkge1xuICAgICAgICAgICAgICAgIGluTm90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzggLyogU2VsZWN0b3JSZWdleHAuU0VQQVJBVE9SICovXSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNlbGVjdG9ycyBpbiA6bm90IGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yID0gY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5lc2NhcGUgYFxcJGAgc2VxdWVuY2VzIGZyb20gdGhlIENTUyBhdHRyaWJ1dGUgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGAkYCBjYW4gaGF2ZSBhIHNwZWNpYWwgbWVhbmluZyBpbiBDU1Mgc2VsZWN0b3JzLFxuICAgICAqIGJ1dCB3ZSBtaWdodCB3YW50IHRvIG1hdGNoIGFuIGF0dHJpYnV0ZSB0aGF0IGNvbnRhaW5zIGAkYC5cbiAgICAgKiBbTUROIHdlYiBsaW5rIGZvciBtb3JlXG4gICAgICogaW5mb10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0F0dHJpYnV0ZV9zZWxlY3RvcnMpLlxuICAgICAqIEBwYXJhbSBhdHRyIHRoZSBhdHRyaWJ1dGUgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICovXG4gICAgdW5lc2NhcGVBdHRyaWJ1dGUoYXR0cikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBhdHRyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJyQnICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gYXR0cmlidXRlIHNlbGVjdG9yIFwiJHthdHRyfVwiLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFVuZXNjYXBlZCBcIiRcIiBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgZXNjYXBlIHdpdGggXCJcXFxcJFwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzY2FwZSBgJGAgc2VxdWVuY2VzIGZyb20gdGhlIENTUyBhdHRyaWJ1dGUgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGAkYCBjYW4gaGF2ZSBhIHNwZWNpYWwgbWVhbmluZyBpbiBDU1Mgc2VsZWN0b3JzLFxuICAgICAqIHdpdGggdGhpcyBtZXRob2Qgd2UgYXJlIGVzY2FwaW5nIGAkYCB3aXRoIGBcXCQnLlxuICAgICAqIFtNRE4gd2ViIGxpbmsgZm9yIG1vcmVcbiAgICAgKiBpbmZvXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQXR0cmlidXRlX3NlbGVjdG9ycykuXG4gICAgICogQHBhcmFtIGF0dHIgdGhlIGF0dHJpYnV0ZSB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGVzY2FwZUF0dHJpYnV0ZShhdHRyKSB7XG4gICAgICAgIHJldHVybiBhdHRyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFwkL2csICdcXFxcJCcpO1xuICAgIH1cbiAgICBpc0VsZW1lbnRTZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzRWxlbWVudFNlbGVjdG9yKCkgJiYgdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmIHRoaXMuYXR0cnMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgIHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaGFzRWxlbWVudFNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmVsZW1lbnQ7XG4gICAgfVxuICAgIHNldEVsZW1lbnQoZWxlbWVudCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9XG4gICAgLyoqIEdldHMgYSB0ZW1wbGF0ZSBzdHJpbmcgZm9yIGFuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rvci4gKi9cbiAgICBnZXRNYXRjaGluZ0VsZW1lbnRUZW1wbGF0ZSgpIHtcbiAgICAgICAgY29uc3QgdGFnTmFtZSA9IHRoaXMuZWxlbWVudCB8fCAnZGl2JztcbiAgICAgICAgY29uc3QgY2xhc3NBdHRyID0gdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA+IDAgPyBgIGNsYXNzPVwiJHt0aGlzLmNsYXNzTmFtZXMuam9pbignICcpfVwiYCA6ICcnO1xuICAgICAgICBsZXQgYXR0cnMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF0dHJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMuYXR0cnNbaV07XG4gICAgICAgICAgICBjb25zdCBhdHRyVmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXSAhPT0gJycgPyBgPVwiJHt0aGlzLmF0dHJzW2kgKyAxXX1cImAgOiAnJztcbiAgICAgICAgICAgIGF0dHJzICs9IGAgJHthdHRyTmFtZX0ke2F0dHJWYWx1ZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRIdG1sVGFnRGVmaW5pdGlvbih0YWdOYW1lKS5pc1ZvaWQgPyBgPCR7dGFnTmFtZX0ke2NsYXNzQXR0cn0ke2F0dHJzfS8+YCA6XG4gICAgICAgICAgICBgPCR7dGFnTmFtZX0ke2NsYXNzQXR0cn0ke2F0dHJzfT48LyR7dGFnTmFtZX0+YDtcbiAgICB9XG4gICAgZ2V0QXR0cnMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdjbGFzcycsIHRoaXMuY2xhc3NOYW1lcy5qb2luKCcgJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KHRoaXMuYXR0cnMpO1xuICAgIH1cbiAgICBhZGRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPSAnJykge1xuICAgICAgICB0aGlzLmF0dHJzLnB1c2gobmFtZSwgdmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSB8fCAnJyk7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZShuYW1lKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5lbGVtZW50IHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZXMuZm9yRWFjaChrbGFzcyA9PiByZXMgKz0gYC4ke2tsYXNzfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5lc2NhcGVBdHRyaWJ1dGUodGhpcy5hdHRyc1tpXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICByZXMgKz0gYFske25hbWV9JHt2YWx1ZSA/ICc9JyArIHZhbHVlIDogJyd9XWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMuZm9yRWFjaChub3RTZWxlY3RvciA9PiByZXMgKz0gYDpub3QoJHtub3RTZWxlY3Rvcn0pYCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkcyBhIGxpc3Qgb2YgQ3NzU2VsZWN0b3JzIGFuZCBhbGxvd3MgdG8gY2FsY3VsYXRlIHdoaWNoIG9uZXNcbiAqIGFyZSBjb250YWluZWQgaW4gYSBnaXZlbiBDc3NTZWxlY3Rvci5cbiAqL1xuY2xhc3MgU2VsZWN0b3JNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFBhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NsYXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jbGFzc1BhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJWYWx1ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVOb3RNYXRjaGVyKG5vdFNlbGVjdG9ycykge1xuICAgICAgICBjb25zdCBub3RNYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICBub3RNYXRjaGVyLmFkZFNlbGVjdGFibGVzKG5vdFNlbGVjdG9ycywgbnVsbCk7XG4gICAgICAgIHJldHVybiBub3RNYXRjaGVyO1xuICAgIH1cbiAgICBhZGRTZWxlY3RhYmxlcyhjc3NTZWxlY3RvcnMsIGNhbGxiYWNrQ3R4dCkge1xuICAgICAgICBsZXQgbGlzdENvbnRleHQgPSBudWxsO1xuICAgICAgICBpZiAoY3NzU2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxpc3RDb250ZXh0ID0gbmV3IFNlbGVjdG9yTGlzdENvbnRleHQoY3NzU2VsZWN0b3JzKTtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RDb250ZXh0cy5wdXNoKGxpc3RDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkU2VsZWN0YWJsZShjc3NTZWxlY3RvcnNbaV0sIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvYmplY3QgdGhhdCBjYW4gYmUgZm91bmQgbGF0ZXIgb24gYnkgY2FsbGluZyBgbWF0Y2hgLlxuICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICovXG4gICAgX2FkZFNlbGVjdGFibGUoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgbGV0IG1hdGNoZXIgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IGNzc1NlbGVjdG9yLmNsYXNzTmFtZXM7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gY3NzU2VsZWN0b3IuYXR0cnM7XG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGUgPSBuZXcgU2VsZWN0b3JDb250ZXh0KGNzc1NlbGVjdG9yLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVGVybWluYWwgPSBhdHRycy5sZW5ndGggPT09IDAgJiYgY2xhc3NOYW1lcy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2VsZW1lbnRNYXAsIGVsZW1lbnQsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fZWxlbWVudFBhcnRpYWxNYXAsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGkgPT09IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2NsYXNzTWFwLCBjbGFzc05hbWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Rlcm1pbmFsID0gaSA9PT0gYXR0cnMubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtaW5hbFZhbHVlc01hcCA9IHRlcm1pbmFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbFZhbHVlc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxWYWx1ZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbE1hcC5zZXQobmFtZSwgdGVybWluYWxWYWx1ZXNNYXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlUGFydGlhbE1hcDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRpYWxWYWx1ZXNNYXAgPSBwYXJ0aWFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsVmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE1hcC5zZXQobmFtZSwgcGFydGlhbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkVGVybWluYWwobWFwLCBuYW1lLCBzZWxlY3RhYmxlKSB7XG4gICAgICAgIGxldCB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgfVxuICAgIF9hZGRQYXJ0aWFsKG1hcCwgbmFtZSkge1xuICAgICAgICBsZXQgbWF0Y2hlciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdmlhIGBhZGRTZWxlY3RhYmxlYFxuICAgICAqIHdob3NlIGNzcyBzZWxlY3RvciBpcyBjb250YWluZWQgaW4gdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cbiAgICAgKiBAcGFyYW0gY3NzU2VsZWN0b3IgQSBjc3Mgc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gbWF0Y2hlZENhbGxiYWNrIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IGhhbmRlZCBpbnRvIGBhZGRTZWxlY3RhYmxlYFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICovXG4gICAgbWF0Y2goY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcbiAgICAgICAgY29uc3QgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saXN0Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RDb250ZXh0c1tpXS5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fZWxlbWVudE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fZWxlbWVudFBhcnRpYWxNYXAsIGVsZW1lbnQsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVNYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgJycsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsVmFsdWVzTWFwID0gdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX21hdGNoVGVybWluYWwobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3RhYmxlcyA9IG1hcC5nZXQobmFtZSkgfHwgW107XG4gICAgICAgIGNvbnN0IHN0YXJTZWxlY3RhYmxlcyA9IG1hcC5nZXQoJyonKTtcbiAgICAgICAgaWYgKHN0YXJTZWxlY3RhYmxlcykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZXMgPSBzZWxlY3RhYmxlcy5jb25jYXQoc3RhclNlbGVjdGFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0YWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGFibGU7XG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2ldO1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZWN0YWJsZS5maW5hbGl6ZShjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9tYXRjaFBhcnRpYWwobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lc3RlZFNlbGVjdG9yID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFuZXN0ZWRTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGdldCByaWQgb2YgcmVjdXJzaW9uIGFuZCBtZWFzdXJlIGFnYWluXG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGRvbid0IHBhc3MgdGhlIHdob2xlIHNlbGVjdG9yIGludG8gdGhlIHJlY3Vyc2lvbixcbiAgICAgICAgLy8gYnV0IG9ubHkgdGhlIG5vdCBwcm9jZXNzZWQgcGFydHNcbiAgICAgICAgcmV0dXJuIG5lc3RlZFNlbGVjdG9yLm1hdGNoKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spO1xuICAgIH1cbn1cbmNsYXNzIFNlbGVjdG9yTGlzdENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9ycykge1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vIFN0b3JlIGNvbnRleHQgdG8gcGFzcyBiYWNrIHNlbGVjdG9yIGFuZCBjb250ZXh0IHdoZW4gYSBzZWxlY3RvciBpcyBtYXRjaGVkXG5jbGFzcyBTZWxlY3RvckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBjYkNvbnRleHQsIGxpc3RDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jYkNvbnRleHQgPSBjYkNvbnRleHQ7XG4gICAgICAgIHRoaXMubGlzdENvbnRleHQgPSBsaXN0Q29udGV4dDtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBzZWxlY3Rvci5ub3RTZWxlY3RvcnM7XG4gICAgfVxuICAgIGZpbmFsaXplKGNzc1NlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgKCF0aGlzLmxpc3RDb250ZXh0IHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xuICAgICAgICAgICAgY29uc3Qgbm90TWF0Y2hlciA9IFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyKHRoaXMubm90U2VsZWN0b3JzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICFub3RNYXRjaGVyLm1hdGNoKGNzc1NlbGVjdG9yLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIGNhbGxiYWNrICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLnNlbGVjdG9yLCB0aGlzLmNiQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gU3RvcmVzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBlbWl0RGlzdGluY3RDaGFuZ2VzT25seWAgd2hlbiB0aGUgYGVtaXREaXN0aW5jdENoYW5nZXNPbmx5YCBpcyBub3Rcbi8vIGV4cGxpY2l0bHkgc2V0LlxuY29uc3QgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlEZWZhdWx0VmFsdWUgPSB0cnVlO1xuZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbiA9IHZvaWQgMDtcbihmdW5jdGlvbiAoVmlld0VuY2Fwc3VsYXRpb24pIHtcbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIkVtdWxhdGVkXCJdID0gMF0gPSBcIkVtdWxhdGVkXCI7XG4gICAgLy8gSGlzdG9yaWNhbGx5IHRoZSAxIHZhbHVlIHdhcyBmb3IgYE5hdGl2ZWAgZW5jYXBzdWxhdGlvbiB3aGljaCBoYXMgYmVlbiByZW1vdmVkIGFzIG9mIHYxMS5cbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIk5vbmVcIl0gPSAyXSA9IFwiTm9uZVwiO1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiU2hhZG93RG9tXCJdID0gM10gPSBcIlNoYWRvd0RvbVwiO1xufSkoZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbiB8fCAoZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbiA9IHt9KSk7XG5leHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSkge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiT25QdXNoXCJdID0gMF0gPSBcIk9uUHVzaFwiO1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5W0NoYW5nZURldGVjdGlvblN0cmF0ZWd5W1wiRGVmYXVsdFwiXSA9IDFdID0gXCJEZWZhdWx0XCI7XG59KShleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5IHx8IChleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0ge30pKTtcbmNvbnN0IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEgPSB7XG4gICAgbmFtZTogJ2N1c3RvbS1lbGVtZW50cydcbn07XG5jb25zdCBOT19FUlJPUlNfU0NIRU1BID0ge1xuICAgIG5hbWU6ICduby1lcnJvcnMtc2NoZW1hJ1xufTtcbmNvbnN0IFR5cGUkMSA9IEZ1bmN0aW9uO1xudmFyIFNlY3VyaXR5Q29udGV4dDtcbihmdW5jdGlvbiAoU2VjdXJpdHlDb250ZXh0KSB7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJIVE1MXCJdID0gMV0gPSBcIkhUTUxcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiU1RZTEVcIl0gPSAyXSA9IFwiU1RZTEVcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiU0NSSVBUXCJdID0gM10gPSBcIlNDUklQVFwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJVUkxcIl0gPSA0XSA9IFwiVVJMXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlJFU09VUkNFX1VSTFwiXSA9IDVdID0gXCJSRVNPVVJDRV9VUkxcIjtcbn0pKFNlY3VyaXR5Q29udGV4dCB8fCAoU2VjdXJpdHlDb250ZXh0ID0ge30pKTtcbnZhciBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtcIkVycm9yXCJdID0gMF0gPSBcIkVycm9yXCI7XG4gICAgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbXCJXYXJuaW5nXCJdID0gMV0gPSBcIldhcm5pbmdcIjtcbiAgICBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtcIklnbm9yZVwiXSA9IDJdID0gXCJJZ25vcmVcIjtcbn0pKE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5IHx8IChNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9IHt9KSk7XG5mdW5jdGlvbiBwYXJzZXJTZWxlY3RvclRvU2ltcGxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICBjb25zdCBjbGFzc2VzID0gc2VsZWN0b3IuY2xhc3NOYW1lcyAmJiBzZWxlY3Rvci5jbGFzc05hbWVzLmxlbmd0aCA/XG4gICAgICAgIFs4IC8qIFNlbGVjdG9yRmxhZ3MuQ0xBU1MgKi8sIC4uLnNlbGVjdG9yLmNsYXNzTmFtZXNdIDpcbiAgICAgICAgW107XG4gICAgY29uc3QgZWxlbWVudE5hbWUgPSBzZWxlY3Rvci5lbGVtZW50ICYmIHNlbGVjdG9yLmVsZW1lbnQgIT09ICcqJyA/IHNlbGVjdG9yLmVsZW1lbnQgOiAnJztcbiAgICByZXR1cm4gW2VsZW1lbnROYW1lLCAuLi5zZWxlY3Rvci5hdHRycywgLi4uY2xhc3Nlc107XG59XG5mdW5jdGlvbiBwYXJzZXJTZWxlY3RvclRvTmVnYXRpdmVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBzZWxlY3Rvci5jbGFzc05hbWVzICYmIHNlbGVjdG9yLmNsYXNzTmFtZXMubGVuZ3RoID9cbiAgICAgICAgWzggLyogU2VsZWN0b3JGbGFncy5DTEFTUyAqLywgLi4uc2VsZWN0b3IuY2xhc3NOYW1lc10gOlxuICAgICAgICBbXTtcbiAgICBpZiAoc2VsZWN0b3IuZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMSAvKiBTZWxlY3RvckZsYWdzLk5PVCAqLyB8IDQgLyogU2VsZWN0b3JGbGFncy5FTEVNRU5UICovLCBzZWxlY3Rvci5lbGVtZW50LCAuLi5zZWxlY3Rvci5hdHRycywgLi4uY2xhc3Nlc1xuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3Rvci5hdHRycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFsxIC8qIFNlbGVjdG9yRmxhZ3MuTk9UICovIHwgMiAvKiBTZWxlY3RvckZsYWdzLkFUVFJJQlVURSAqLywgLi4uc2VsZWN0b3IuYXR0cnMsIC4uLmNsYXNzZXNdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmNsYXNzTmFtZXMgJiYgc2VsZWN0b3IuY2xhc3NOYW1lcy5sZW5ndGggP1xuICAgICAgICAgICAgWzEgLyogU2VsZWN0b3JGbGFncy5OT1QgKi8gfCA4IC8qIFNlbGVjdG9yRmxhZ3MuQ0xBU1MgKi8sIC4uLnNlbGVjdG9yLmNsYXNzTmFtZXNdIDpcbiAgICAgICAgICAgIFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlclNlbGVjdG9yVG9SM1NlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgcG9zaXRpdmUgPSBwYXJzZXJTZWxlY3RvclRvU2ltcGxlU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gc2VsZWN0b3Iubm90U2VsZWN0b3JzICYmIHNlbGVjdG9yLm5vdFNlbGVjdG9ycy5sZW5ndGggP1xuICAgICAgICBzZWxlY3Rvci5ub3RTZWxlY3RvcnMubWFwKG5vdFNlbGVjdG9yID0+IHBhcnNlclNlbGVjdG9yVG9OZWdhdGl2ZVNlbGVjdG9yKG5vdFNlbGVjdG9yKSkgOlxuICAgICAgICBbXTtcbiAgICByZXR1cm4gcG9zaXRpdmUuY29uY2F0KC4uLm5lZ2F0aXZlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgPyBDc3NTZWxlY3Rvci5wYXJzZShzZWxlY3RvcikubWFwKHBhcnNlclNlbGVjdG9yVG9SM1NlbGVjdG9yKSA6IFtdO1xufVxuXG52YXIgY29yZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlEZWZhdWx0VmFsdWU6IGVtaXREaXN0aW5jdENoYW5nZXNPbmx5RGVmYXVsdFZhbHVlLFxuICAgIGdldCBWaWV3RW5jYXBzdWxhdGlvbiAoKSB7IHJldHVybiBleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uOyB9LFxuICAgIGdldCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSAoKSB7IHJldHVybiBleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5OyB9LFxuICAgIENVU1RPTV9FTEVNRU5UU19TQ0hFTUE6IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsXG4gICAgTk9fRVJST1JTX1NDSEVNQTogTk9fRVJST1JTX1NDSEVNQSxcbiAgICBUeXBlOiBUeXBlJDEsXG4gICAgZ2V0IFNlY3VyaXR5Q29udGV4dCAoKSB7IHJldHVybiBTZWN1cml0eUNvbnRleHQ7IH0sXG4gICAgZ2V0IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ICgpIHsgcmV0dXJuIE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5OyB9LFxuICAgIHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3I6IHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3Jcbn0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IERBU0hfQ0FTRV9SRUdFWFAgPSAvLSsoW2EtejAtOV0pL2c7XG5mdW5jdGlvbiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoREFTSF9DQVNFX1JFR0VYUCwgKC4uLm0pID0+IG1bMV0udG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBzcGxpdEF0Q29sb24oaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICByZXR1cm4gX3NwbGl0QXQoaW5wdXQsICc6JywgZGVmYXVsdFZhbHVlcyk7XG59XG5mdW5jdGlvbiBzcGxpdEF0UGVyaW9kKGlucHV0LCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgcmV0dXJuIF9zcGxpdEF0KGlucHV0LCAnLicsIGRlZmF1bHRWYWx1ZXMpO1xufVxuZnVuY3Rpb24gX3NwbGl0QXQoaW5wdXQsIGNoYXJhY3RlciwgZGVmYXVsdFZhbHVlcykge1xuICAgIGNvbnN0IGNoYXJhY3RlckluZGV4ID0gaW5wdXQuaW5kZXhPZihjaGFyYWN0ZXIpO1xuICAgIGlmIChjaGFyYWN0ZXJJbmRleCA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XG4gICAgcmV0dXJuIFtpbnB1dC5zbGljZSgwLCBjaGFyYWN0ZXJJbmRleCkudHJpbSgpLCBpbnB1dC5zbGljZShjaGFyYWN0ZXJJbmRleCArIDEpLnRyaW0oKV07XG59XG5mdW5jdGlvbiBub1VuZGVmaW5lZCh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsO1xufVxuZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBFcnJvcjogJHttc2d9YCk7XG59XG5mdW5jdGlvbiB1dGY4RW5jb2RlKHN0cikge1xuICAgIGxldCBlbmNvZGVkID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgbGV0IGNvZGVQb2ludCA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgLy8gZGVjb2RlIHN1cnJvZ2F0ZVxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMHhkODAwICYmIGNvZGVQb2ludCA8PSAweGRiZmYgJiYgc3RyLmxlbmd0aCA+IChpbmRleCArIDEpKSB7XG4gICAgICAgICAgICBjb25zdCBsb3cgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgICAgICAgICAgaWYgKGxvdyA+PSAweGRjMDAgJiYgbG93IDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gKChjb2RlUG9pbnQgLSAweGQ4MDApIDw8IDEwKSArIGxvdyAtIDB4ZGMwMCArIDB4MTAwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweDdmKSB7XG4gICAgICAgICAgICBlbmNvZGVkLnB1c2goY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHg3ZmYpIHtcbiAgICAgICAgICAgIGVuY29kZWQucHVzaCgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhjMCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgZW5jb2RlZC5wdXNoKChjb2RlUG9pbnQgPj4gMTIpIHwgMHhlMCwgKChjb2RlUG9pbnQgPj4gNikgJiAweDNmKSB8IDB4ODAsIChjb2RlUG9pbnQgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDFmZmZmZikge1xuICAgICAgICAgICAgZW5jb2RlZC5wdXNoKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhmMCwgKChjb2RlUG9pbnQgPj4gMTIpICYgMHgzZikgfCAweDgwLCAoKGNvZGVQb2ludCA+PiA2KSAmIDB4M2YpIHwgMHg4MCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodG9rZW4pIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgICByZXR1cm4gJ1snICsgdG9rZW4ubWFwKHN0cmluZ2lmeSkuam9pbignLCAnKSArICddJztcbiAgICB9XG4gICAgaWYgKHRva2VuID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdG9rZW47XG4gICAgfVxuICAgIGlmICh0b2tlbi5vdmVycmlkZGVuTmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7dG9rZW4ub3ZlcnJpZGRlbk5hbWV9YDtcbiAgICB9XG4gICAgaWYgKHRva2VuLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke3Rva2VuLm5hbWV9YDtcbiAgICB9XG4gICAgaWYgKCF0b2tlbi50b1N0cmluZykge1xuICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIC8vIFdBUk5JTkc6IGRvIG5vdCB0cnkgdG8gYEpTT04uc3RyaW5naWZ5KHRva2VuKWAgaGVyZVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMzQ0MFxuICAgIGNvbnN0IHJlcyA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJyArIHJlcztcbiAgICB9XG4gICAgY29uc3QgbmV3TGluZUluZGV4ID0gcmVzLmluZGV4T2YoJ1xcbicpO1xuICAgIHJldHVybiBuZXdMaW5lSW5kZXggPT09IC0xID8gcmVzIDogcmVzLnN1YnN0cmluZygwLCBuZXdMaW5lSW5kZXgpO1xufVxuY2xhc3MgVmVyc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZnVsbCkge1xuICAgICAgICB0aGlzLmZ1bGwgPSBmdWxsO1xuICAgICAgICBjb25zdCBzcGxpdHMgPSBmdWxsLnNwbGl0KCcuJyk7XG4gICAgICAgIHRoaXMubWFqb3IgPSBzcGxpdHNbMF07XG4gICAgICAgIHRoaXMubWlub3IgPSBzcGxpdHNbMV07XG4gICAgICAgIHRoaXMucGF0Y2ggPSBzcGxpdHMuc2xpY2UoMikuam9pbignLicpO1xuICAgIH1cbn1cbi8vIENoZWNrIGBnbG9iYWxgIGZpcnN0LCBiZWNhdXNlIGluIE5vZGUgdGVzdHMgYm90aCBgZ2xvYmFsYCBhbmQgYHdpbmRvd2AgbWF5IGJlIGRlZmluZWQgYW5kIG91clxuLy8gYF9nbG9iYWxgIHZhcmlhYmxlIHNob3VsZCBwb2ludCB0byB0aGUgTm9kZUpTIGBnbG9iYWxgIGluIHRoYXQgY2FzZS4gTm90ZTogVHlwZW9mL0luc3RhbmNlb2Zcbi8vIGNoZWNrcyBhcmUgY29uc2lkZXJlZCBzaWRlLWVmZmVjdHMgaW4gVGVyc2VyLiBXZSBleHBsaWNpdGx5IG1hcmsgdGhpcyBhcyBzaWRlLWVmZmVjdCBmcmVlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RlcnNlci90ZXJzZXIvaXNzdWVzLzI1MC5cbmNvbnN0IF9nbG9iYWwgPSAoIC8qIEBfX1BVUkVfXyAqLygoKSA9PiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsKSB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93KSB8fFxuICAgICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiYgc2VsZikpKCkpO1xuZnVuY3Rpb24gbmV3QXJyYXkoc2l6ZSwgdmFsdWUpIHtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgbGlzdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG4vKipcbiAqIFBhcnRpdGlvbnMgYSBnaXZlbiBhcnJheSBpbnRvIDIgYXJyYXlzLCBiYXNlZCBvbiBhIGJvb2xlYW4gdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGNvbmRpdGlvblxuICogZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGFyciBJbnB1dCBhcnJheSB0aGF0IHNob3VsZCBiZSBwYXJ0aXRpb25lZFxuICogQHBhcmFtIGNvbmRpdGlvbkZuIENvbmRpdGlvbiBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZWFjaCBpdGVtIGluIGEgZ2l2ZW4gYXJyYXkgYW5kIHJldHVybnMgYVxuICogYm9vbGVhbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFydGl0aW9uQXJyYXkoYXJyLCBjb25kaXRpb25Gbikge1xuICAgIGNvbnN0IHRydXRoeSA9IFtdO1xuICAgIGNvbnN0IGZhbHN5ID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAoY29uZGl0aW9uRm4oaXRlbSkgPyB0cnV0aHkgOiBmYWxzeSkucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0cnV0aHksIGZhbHN5XTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYSBiaWcgaW50ZWdlciB1c2luZyBhIGJ1ZmZlciBvZiBpdHMgaW5kaXZpZHVhbCBkaWdpdHMsIHdpdGggdGhlIGxlYXN0IHNpZ25pZmljYW50XG4gKiBkaWdpdCBzdG9yZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgKGxpdHRsZSBlbmRpYW4pLlxuICpcbiAqIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBlYWNoIGluc3RhbmNlIGlzIG11dGFibGUuIFRoZSBhZGRpdGlvbiBvcGVyYXRpb24gY2FuIGJlIGRvbmUgaW4tcGxhY2VcbiAqIHRvIHJlZHVjZSBtZW1vcnkgcHJlc3N1cmUgb2YgYWxsb2NhdGlvbiBmb3IgdGhlIGRpZ2l0cyBhcnJheS5cbiAqL1xuY2xhc3MgQmlnSW50ZWdlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGJpZyBpbnRlZ2VyIHVzaW5nIGl0cyBpbmRpdmlkdWFsIGRpZ2l0cyBpbiBsaXR0bGUgZW5kaWFuIHN0b3JhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZGlnaXRzKSB7XG4gICAgICAgIHRoaXMuZGlnaXRzID0gZGlnaXRzO1xuICAgIH1cbiAgICBzdGF0aWMgemVybygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFswXSk7XG4gICAgfVxuICAgIHN0YXRpYyBvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihbMV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMuZGlnaXRzLnNsaWNlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGJpZyBpbnRlZ2VyIHdpdGggdGhlIHN1bSBvZiBgdGhpc2AgYW5kIGBvdGhlcmAgYXMgaXRzIHZhbHVlLiBUaGlzIGRvZXMgbm90IG11dGF0ZVxuICAgICAqIGB0aGlzYCBidXQgaW5zdGVhZCByZXR1cm5zIGEgbmV3IGluc3RhbmNlLCB1bmxpa2UgYGFkZFRvU2VsZmAuXG4gICAgICovXG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0LmFkZFRvU2VsZihvdGhlcik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYG90aGVyYCB0byB0aGUgaW5zdGFuY2UgaXRzZWxmLCB0aGVyZWJ5IG11dGF0aW5nIGl0cyB2YWx1ZS5cbiAgICAgKi9cbiAgICBhZGRUb1NlbGYob3RoZXIpIHtcbiAgICAgICAgY29uc3QgbWF4TnJPZkRpZ2l0cyA9IE1hdGgubWF4KHRoaXMuZGlnaXRzLmxlbmd0aCwgb3RoZXIuZGlnaXRzLmxlbmd0aCk7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TnJPZkRpZ2l0czsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGlnaXRTdW0gPSBjYXJyeTtcbiAgICAgICAgICAgIGlmIChpIDwgdGhpcy5kaWdpdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGlnaXRTdW0gKz0gdGhpcy5kaWdpdHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IG90aGVyLmRpZ2l0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkaWdpdFN1bSArPSBvdGhlci5kaWdpdHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlnaXRTdW0gPj0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpZ2l0c1tpXSA9IGRpZ2l0U3VtIC0gMTA7XG4gICAgICAgICAgICAgICAgY2FycnkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWdpdHNbaV0gPSBkaWdpdFN1bTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwbHkgYSByZW1haW5pbmcgY2FycnkgaWYgbmVlZGVkLlxuICAgICAgICBpZiAoY2FycnkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpZ2l0c1ttYXhOck9mRGlnaXRzXSA9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmlnIGludGVnZXIuIEFzIHRoaXMgaXMgc3RvcmVkIGluXG4gICAgICogbGl0dGxlIGVuZGlhbiwgdGhlIGRpZ2l0cyBhcmUgY29uY2F0ZW5hdGVkIGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZGlnaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXMgKz0gdGhpcy5kaWdpdHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBiaWcgaW50ZWdlciB3aGljaCBpcyBvcHRpbWl6ZWQgZm9yIG11bHRpcGxpY2F0aW9uIG9wZXJhdGlvbnMsIGFzIGl0cyBwb3dlci1vZi10d29zXG4gKiBhcmUgbWVtb2l6ZWQuIFNlZSBgbXVsdGlwbHlCeSgpYCBmb3IgZGV0YWlscyBvbiB0aGUgbXVsdGlwbGljYXRpb24gYWxnb3JpdGhtLlxuICovXG5jbGFzcyBCaWdJbnRGb3JNdWx0aXBsaWNhdGlvbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wb3dlck9mVHdvcyA9IFt2YWx1ZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpZyBpbnRlZ2VyIGl0c2VsZi5cbiAgICAgKi9cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG93ZXJPZlR3b3NbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSB2YWx1ZSBmb3IgYG51bSAqIGJgLCB3aGVyZSBgbnVtYCBpcyBhIEpTIG51bWJlciBhbmQgYGJgIGlzIGEgYmlnIGludGVnZXIuIFRoZVxuICAgICAqIHZhbHVlIGZvciBgYmAgaXMgcmVwcmVzZW50ZWQgYnkgYSBzdG9yYWdlIG1vZGVsIHRoYXQgaXMgb3B0aW1pemVkIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBvcGVyYXRpb24gaXMgaW1wbGVtZW50ZWQgaW4gTihsb2cyKG51bSkpIGJ5IGNvbnRpbnVvdXMgaGFsdmluZyBvZiB0aGUgbnVtYmVyLCB3aGVyZSB0aGVcbiAgICAgKiBsZWFzdC1zaWduaWZpY2FudCBiaXQgKExTQikgaXMgdGVzdGVkIGluIGVhY2ggaXRlcmF0aW9uLiBJZiB0aGUgYml0IGlzIHNldCwgdGhlIGJpdCdzIGluZGV4IGlzXG4gICAgICogdXNlZCBhcyBleHBvbmVudCBpbnRvIHRoZSBwb3dlci1vZi10d28gbXVsdGlwbGljYXRpb24gb2YgYGJgLlxuICAgICAqXG4gICAgICogQXMgYW4gZXhhbXBsZSwgY29uc2lkZXIgdGhlIG11bHRpcGxpY2F0aW9uIG51bT00MiwgYj0xMzM3LiBJbiBiaW5hcnkgNDIgaXMgMGIwMDEwMTAxMCBhbmQgdGhlXG4gICAgICogYWxnb3JpdGhtIHVucm9sbHMgaW50byB0aGUgZm9sbG93aW5nIGl0ZXJhdGlvbnM6XG4gICAgICpcbiAgICAgKiAgSXRlcmF0aW9uIHwgbnVtICAgICAgICB8IExTQiAgfCBiICogMl5pdGVyIHwgQWRkPyB8IHByb2R1Y3RcbiAgICAgKiAtLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS18LS0tLS0tfC0tLS0tLS0tLS0tLXwtLS0tLS18LS0tLS0tLS1cbiAgICAgKiAgMCAgICAgICAgIHwgMGIwMDEwMTAxMCB8IDAgICAgfCAxMzM3ICAgICAgIHwgTm8gICB8IDBcbiAgICAgKiAgMSAgICAgICAgIHwgMGIwMDAxMDEwMSB8IDEgICAgfCAyNjc0ICAgICAgIHwgWWVzICB8IDI2NzRcbiAgICAgKiAgMiAgICAgICAgIHwgMGIwMDAwMTAxMCB8IDAgICAgfCA1MzQ4ICAgICAgIHwgTm8gICB8IDI2NzRcbiAgICAgKiAgMyAgICAgICAgIHwgMGIwMDAwMDEwMSB8IDEgICAgfCAxMDY5NiAgICAgIHwgWWVzICB8IDEzMzcwXG4gICAgICogIDQgICAgICAgICB8IDBiMDAwMDAwMTAgfCAwICAgIHwgMjEzOTIgICAgICB8IE5vICAgfCAxMzM3MFxuICAgICAqICA1ICAgICAgICAgfCAwYjAwMDAwMDAxIHwgMSAgICB8IDQyNzg0ICAgICAgfCBZZXMgIHwgNTYxNTRcbiAgICAgKiAgNiAgICAgICAgIHwgMGIwMDAwMDAwMCB8IDAgICAgfCA4NTU2OCAgICAgIHwgTm8gICB8IDU2MTU0XG4gICAgICpcbiAgICAgKiBUaGUgY29tcHV0ZWQgcHJvZHVjdCBvZiA1NjE1NCBpcyBpbmRlZWQgdGhlIGNvcnJlY3QgcmVzdWx0LlxuICAgICAqXG4gICAgICogVGhlIGBCaWdJbnRGb3JNdWx0aXBsaWNhdGlvbmAgcmVwcmVzZW50YXRpb24gZm9yIGEgYmlnIGludGVnZXIgcHJvdmlkZXMgbWVtb2l6ZWQgYWNjZXNzIHRvIHRoZVxuICAgICAqIHBvd2VyLW9mLXR3byB2YWx1ZXMgdG8gcmVkdWNlIHRoZSB3b3JrbG9hZCBpbiBjb21wdXRpbmcgdGhvc2UgdmFsdWVzLlxuICAgICAqL1xuICAgIG11bHRpcGx5QnkobnVtKSB7XG4gICAgICAgIGNvbnN0IHByb2R1Y3QgPSBCaWdJbnRlZ2VyLnplcm8oKTtcbiAgICAgICAgdGhpcy5tdWx0aXBseUJ5QW5kQWRkVG8obnVtLCBwcm9kdWN0KTtcbiAgICAgICAgcmV0dXJuIHByb2R1Y3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlZSBgbXVsdGlwbHlCeSgpYCBmb3IgZGV0YWlscy4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgZm9yIHRoZSBjb21wdXRlZCBwcm9kdWN0IHRvIGJlIGFkZGVkXG4gICAgICogZGlyZWN0bHkgdG8gdGhlIHByb3ZpZGVkIHJlc3VsdCBiaWcgaW50ZWdlci5cbiAgICAgKi9cbiAgICBtdWx0aXBseUJ5QW5kQWRkVG8obnVtLCByZXN1bHQpIHtcbiAgICAgICAgZm9yIChsZXQgZXhwb25lbnQgPSAwOyBudW0gIT09IDA7IG51bSA9IG51bSA+Pj4gMSwgZXhwb25lbnQrKykge1xuICAgICAgICAgICAgaWYgKG51bSAmIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0TXVsdGlwbGllZEJ5UG93ZXJPZlR3byhleHBvbmVudCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZFRvU2VsZih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYW5kIG1lbW9pemVzIHRoZSBiaWcgaW50ZWdlciB2YWx1ZSBmb3IgYHRoaXMubnVtYmVyICogMl5leHBvbmVudGAuXG4gICAgICovXG4gICAgZ2V0TXVsdGlwbGllZEJ5UG93ZXJPZlR3byhleHBvbmVudCkge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBwb3dlcnMgdXAgdW50aWwgdGhlIHJlcXVlc3RlZCBleHBvbmVudCwgd2hlcmUgZWFjaCB2YWx1ZSBpcyBjb21wdXRlZCBmcm9tIGl0c1xuICAgICAgICAvLyBwcmVkZWNlc3Nvci4gVGhpcyBpcyBzaW1wbGUgYXMgYHRoaXMubnVtYmVyICogMl4oZXhwb25lbnQgLSAxKWAgb25seSBoYXMgdG8gYmUgZG91YmxlZCAoaS5lLlxuICAgICAgICAvLyBhZGRlZCB0byBpdHNlbGYpIHRvIHJlYWNoIGB0aGlzLm51bWJlciAqIDJeZXhwb25lbnRgLlxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5wb3dlck9mVHdvcy5sZW5ndGg7IGkgPD0gZXhwb25lbnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQb3dlciA9IHRoaXMucG93ZXJPZlR3b3NbaSAtIDFdO1xuICAgICAgICAgICAgdGhpcy5wb3dlck9mVHdvc1tpXSA9IHByZXZpb3VzUG93ZXIuYWRkKHByZXZpb3VzUG93ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBvd2VyT2ZUd29zW2V4cG9uZW50XTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXhwb25lbnRpYXRpb24gb3BlcmF0aW9uIGZvciB0aGUgcHJvdmlkZWQgYmFzZSwgb2Ygd2hpY2ggZXhwb25lbnRzIGFyZSBjb21wdXRlZCBhbmRcbiAqIG1lbW9pemVkLiBUaGUgcmVzdWx0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYSBgQmlnSW50Rm9yTXVsdGlwbGljYXRpb25gIHdoaWNoIGlzIHRhaWxvcmVkIGZvclxuICogbXVsdGlwbGljYXRpb24gb3BlcmF0aW9ucyBieSBtZW1vaXppbmcgdGhlIHBvd2VyLW9mLXR3b3MuIFRoaXMgZWZmZWN0aXZlbHkgcmVzdWx0cyBpbiBhIG1hdHJpeFxuICogcmVwcmVzZW50YXRpb24gdGhhdCBpcyBsYXppbHkgY29tcHV0ZWQgdXBvbiByZXF1ZXN0LlxuICovXG5jbGFzcyBCaWdJbnRFeHBvbmVudGlhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYmFzZSkge1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLmV4cG9uZW50cyA9IFtuZXcgQmlnSW50Rm9yTXVsdGlwbGljYXRpb24oQmlnSW50ZWdlci5vbmUoKSldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSB2YWx1ZSBmb3IgYHRoaXMuYmFzZV5leHBvbmVudGAsIHJlc3VsdGluZyBpbiBhIGJpZyBpbnRlZ2VyIHRoYXQgaXMgb3B0aW1pemVkIGZvclxuICAgICAqIGZ1cnRoZXIgbXVsdGlwbGljYXRpb24gb3BlcmF0aW9ucy5cbiAgICAgKi9cbiAgICB0b1RoZVBvd2VyT2YoZXhwb25lbnQpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcmVzdWx0cyB1cCB1bnRpbCB0aGUgcmVxdWVzdGVkIGV4cG9uZW50LCB3aGVyZSBldmVyeSB2YWx1ZSBpcyBjb21wdXRlZCBmcm9tIGl0c1xuICAgICAgICAvLyBwcmVkZWNlc3Nvci4gVGhpcyBpcyBiZWNhdXNlIGB0aGlzLmJhc2VeKGV4cG9uZW50IC0gMSlgIG9ubHkgaGFzIHRvIGJlIG11bHRpcGxpZWQgYnkgYGJhc2VgXG4gICAgICAgIC8vIHRvIHJlYWNoIGB0aGlzLmJhc2VeZXhwb25lbnRgLlxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5leHBvbmVudHMubGVuZ3RoOyBpIDw9IGV4cG9uZW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5leHBvbmVudHNbaSAtIDFdLm11bHRpcGx5QnkodGhpcy5iYXNlKTtcbiAgICAgICAgICAgIHRoaXMuZXhwb25lbnRzW2ldID0gbmV3IEJpZ0ludEZvck11bHRpcGxpY2F0aW9uKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHBvbmVudHNbZXhwb25lbnRdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFJldHVybiB0aGUgbWVzc2FnZSBpZCBvciBjb21wdXRlIGl0IHVzaW5nIHRoZSBYTElGRjEgZGlnZXN0LlxuICovXG5mdW5jdGlvbiBkaWdlc3QkMShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UuaWQgfHwgY29tcHV0ZURpZ2VzdChtZXNzYWdlKTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWVzc2FnZSBpZCB1c2luZyB0aGUgWExJRkYxIGRpZ2VzdC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZURpZ2VzdChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHNoYTEoc2VyaWFsaXplTm9kZXMobWVzc2FnZS5ub2Rlcykuam9pbignJykgKyBgWyR7bWVzc2FnZS5tZWFuaW5nfV1gKTtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBtZXNzYWdlIGlkIG9yIGNvbXB1dGUgaXQgdXNpbmcgdGhlIFhMSUZGMi9YTUIvJGxvY2FsaXplIGRpZ2VzdC5cbiAqL1xuZnVuY3Rpb24gZGVjaW1hbERpZ2VzdChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UuaWQgfHwgY29tcHV0ZURlY2ltYWxEaWdlc3QobWVzc2FnZSk7XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIG1lc3NhZ2UgaWQgdXNpbmcgdGhlIFhMSUZGMi9YTUIvJGxvY2FsaXplIGRpZ2VzdC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZURlY2ltYWxEaWdlc3QobWVzc2FnZSkge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX1NlcmlhbGl6ZXJJZ25vcmVJY3VFeHBWaXNpdG9yKCk7XG4gICAgY29uc3QgcGFydHMgPSBtZXNzYWdlLm5vZGVzLm1hcChhID0+IGEudmlzaXQodmlzaXRvciwgbnVsbCkpO1xuICAgIHJldHVybiBjb21wdXRlTXNnSWQocGFydHMuam9pbignJyksIG1lc3NhZ2UubWVhbmluZyk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgaTE4biBhc3QgdG8gc29tZXRoaW5nIHhtbC1saWtlIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIFVJRC5cbiAqXG4gKiBUaGUgdmlzaXRvciBpcyBhbHNvIHVzZWQgaW4gdGhlIGkxOG4gcGFyc2VyIHRlc3RzXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIF9TZXJpYWxpemVyVmlzaXRvciB7XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQudmFsdWU7XG4gICAgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYFske2NvbnRhaW5lci5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpLmpvaW4oJywgJyl9XWA7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKChrKSA9PiBgJHtrfSB7JHtpY3UuY2FzZXNba10udmlzaXQodGhpcyl9fWApO1xuICAgICAgICByZXR1cm4gYHske2ljdS5leHByZXNzaW9ufSwgJHtpY3UudHlwZX0sICR7c3RyQ2FzZXMuam9pbignLCAnKX19YDtcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcGguaXNWb2lkID9cbiAgICAgICAgICAgIGA8cGggdGFnIG5hbWU9XCIke3BoLnN0YXJ0TmFtZX1cIi8+YCA6XG4gICAgICAgICAgICBgPHBoIHRhZyBuYW1lPVwiJHtwaC5zdGFydE5hbWV9XCI+JHtwaC5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpLmpvaW4oJywgJyl9PC9waCBuYW1lPVwiJHtwaC5jbG9zZU5hbWV9XCI+YDtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcGgudmFsdWUgPyBgPHBoIG5hbWU9XCIke3BoLm5hbWV9XCI+JHtwaC52YWx1ZX08L3BoPmAgOiBgPHBoIG5hbWU9XCIke3BoLm5hbWV9XCIvPmA7XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8cGggaWN1IG5hbWU9XCIke3BoLm5hbWV9XCI+JHtwaC52YWx1ZS52aXNpdCh0aGlzKX08L3BoPmA7XG4gICAgfVxufVxuY29uc3Qgc2VyaWFsaXplclZpc2l0b3IkMSA9IG5ldyBfU2VyaWFsaXplclZpc2l0b3IoKTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVzKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcChhID0+IGEudmlzaXQoc2VyaWFsaXplclZpc2l0b3IkMSwgbnVsbCkpO1xufVxuLyoqXG4gKiBTZXJpYWxpemUgdGhlIGkxOG4gYXN0IHRvIHNvbWV0aGluZyB4bWwtbGlrZSBpbiBvcmRlciB0byBnZW5lcmF0ZSBhbiBVSUQuXG4gKlxuICogSWdub3JlIHRoZSBJQ1UgZXhwcmVzc2lvbnMgc28gdGhhdCBtZXNzYWdlIElEcyBzdGF5cyBpZGVudGljYWwgaWYgb25seSB0aGUgZXhwcmVzc2lvbiBjaGFuZ2VzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IgZXh0ZW5kcyBfU2VyaWFsaXplclZpc2l0b3Ige1xuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBsZXQgc3RyQ2FzZXMgPSBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLm1hcCgoaykgPT4gYCR7a30geyR7aWN1LmNhc2VzW2tdLnZpc2l0KHRoaXMpfX1gKTtcbiAgICAgICAgLy8gRG8gbm90IHRha2UgdGhlIGV4cHJlc3Npb24gaW50byBhY2NvdW50XG4gICAgICAgIHJldHVybiBgeyR7aWN1LnR5cGV9LCAke3N0ckNhc2VzLmpvaW4oJywgJyl9fWA7XG4gICAgfVxufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBTSEExIG9mIHRoZSBnaXZlbiBzdHJpbmdcbiAqXG4gKiBzZWUgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9maXBzL2ZpcHMxODAtNC9maXBzLTE4MC00LnBkZlxuICpcbiAqIFdBUk5JTkc6IHRoaXMgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGRlc2lnbmVkIG5vdCB0ZXN0ZWQgd2l0aCBzZWN1cml0eSBpbiBtaW5kLlxuICogICAgICAgICAgRE8gTk9UIFVTRSBJVCBJTiBBIFNFQ1VSSVRZIFNFTlNJVElWRSBDT05URVhULlxuICovXG5mdW5jdGlvbiBzaGExKHN0cikge1xuICAgIGNvbnN0IHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgY29uc3Qgd29yZHMzMiA9IGJ5dGVzVG9Xb3JkczMyKHV0ZjgsIEVuZGlhbi5CaWcpO1xuICAgIGNvbnN0IGxlbiA9IHV0ZjgubGVuZ3RoICogODtcbiAgICBjb25zdCB3ID0gbmV3QXJyYXkoODApO1xuICAgIGxldCBhID0gMHg2NzQ1MjMwMSwgYiA9IDB4ZWZjZGFiODksIGMgPSAweDk4YmFkY2ZlLCBkID0gMHgxMDMyNTQ3NiwgZSA9IDB4YzNkMmUxZjA7XG4gICAgd29yZHMzMltsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XG4gICAgd29yZHMzMlsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMzMi5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgY29uc3QgaDAgPSBhLCBoMSA9IGIsIGgyID0gYywgaDMgPSBkLCBoNCA9IGU7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODA7IGorKykge1xuICAgICAgICAgICAgaWYgKGogPCAxNikge1xuICAgICAgICAgICAgICAgIHdbal0gPSB3b3JkczMyW2kgKyBqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdbal0gPSByb2wzMih3W2ogLSAzXSBeIHdbaiAtIDhdIF4gd1tqIC0gMTRdIF4gd1tqIC0gMTZdLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZrVmFsID0gZmsoaiwgYiwgYywgZCk7XG4gICAgICAgICAgICBjb25zdCBmID0gZmtWYWxbMF07XG4gICAgICAgICAgICBjb25zdCBrID0gZmtWYWxbMV07XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gW3JvbDMyKGEsIDUpLCBmLCBlLCBrLCB3W2pdXS5yZWR1Y2UoYWRkMzIpO1xuICAgICAgICAgICAgZSA9IGQ7XG4gICAgICAgICAgICBkID0gYztcbiAgICAgICAgICAgIGMgPSByb2wzMihiLCAzMCk7XG4gICAgICAgICAgICBiID0gYTtcbiAgICAgICAgICAgIGEgPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhZGQzMihhLCBoMCk7XG4gICAgICAgIGIgPSBhZGQzMihiLCBoMSk7XG4gICAgICAgIGMgPSBhZGQzMihjLCBoMik7XG4gICAgICAgIGQgPSBhZGQzMihkLCBoMyk7XG4gICAgICAgIGUgPSBhZGQzMihlLCBoNCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlc1RvSGV4U3RyaW5nKHdvcmRzMzJUb0J5dGVTdHJpbmcoW2EsIGIsIGMsIGQsIGVdKSk7XG59XG5mdW5jdGlvbiBmayhpbmRleCwgYiwgYywgZCkge1xuICAgIGlmIChpbmRleCA8IDIwKSB7XG4gICAgICAgIHJldHVybiBbKGIgJiBjKSB8ICh+YiAmIGQpLCAweDVhODI3OTk5XTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgNDApIHtcbiAgICAgICAgcmV0dXJuIFtiIF4gYyBeIGQsIDB4NmVkOWViYTFdO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCA2MCkge1xuICAgICAgICByZXR1cm4gWyhiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSwgMHg4ZjFiYmNkY107XG4gICAgfVxuICAgIHJldHVybiBbYiBeIGMgXiBkLCAweGNhNjJjMWQ2XTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgZmluZ2VycHJpbnQgb2YgdGhlIGdpdmVuIHN0cmluZ1xuICpcbiAqIFRoZSBvdXRwdXQgaXMgNjQgYml0IG51bWJlciBlbmNvZGVkIGFzIGEgZGVjaW1hbCBzdHJpbmdcbiAqXG4gKiBiYXNlZCBvbjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1jb21waWxlci9ibG9iL21hc3Rlci9zcmMvY29tL2dvb2dsZS9qYXZhc2NyaXB0L2pzY29tcC9Hb29nbGVKc01lc3NhZ2VJZEdlbmVyYXRvci5qYXZhXG4gKi9cbmZ1bmN0aW9uIGZpbmdlcnByaW50KHN0cikge1xuICAgIGNvbnN0IHV0ZjggPSB1dGY4RW5jb2RlKHN0cik7XG4gICAgbGV0IGhpID0gaGFzaDMyKHV0ZjgsIDApO1xuICAgIGxldCBsbyA9IGhhc2gzMih1dGY4LCAxMDIwNzIpO1xuICAgIGlmIChoaSA9PSAwICYmIChsbyA9PSAwIHx8IGxvID09IDEpKSB7XG4gICAgICAgIGhpID0gaGkgXiAweDEzMGY5YmVmO1xuICAgICAgICBsbyA9IGxvIF4gLTB4NmI1ZjU2ZDg7XG4gICAgfVxuICAgIHJldHVybiBbaGksIGxvXTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNc2dJZChtc2csIG1lYW5pbmcgPSAnJykge1xuICAgIGxldCBtc2dGaW5nZXJwcmludCA9IGZpbmdlcnByaW50KG1zZyk7XG4gICAgaWYgKG1lYW5pbmcpIHtcbiAgICAgICAgY29uc3QgbWVhbmluZ0ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQobWVhbmluZyk7XG4gICAgICAgIG1zZ0ZpbmdlcnByaW50ID0gYWRkNjQocm9sNjQobXNnRmluZ2VycHJpbnQsIDEpLCBtZWFuaW5nRmluZ2VycHJpbnQpO1xuICAgIH1cbiAgICBjb25zdCBoaSA9IG1zZ0ZpbmdlcnByaW50WzBdO1xuICAgIGNvbnN0IGxvID0gbXNnRmluZ2VycHJpbnRbMV07XG4gICAgcmV0dXJuIHdvcmRzVG9EZWNpbWFsU3RyaW5nKGhpICYgMHg3ZmZmZmZmZiwgbG8pO1xufVxuZnVuY3Rpb24gaGFzaDMyKGJ5dGVzLCBjKSB7XG4gICAgbGV0IGEgPSAweDllMzc3OWI5LCBiID0gMHg5ZTM3NzliOTtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSArIDEyIDw9IGxlbjsgaSArPSAxMikge1xuICAgICAgICBhID0gYWRkMzIoYSwgd29yZEF0KGJ5dGVzLCBpLCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgICAgIGIgPSBhZGQzMihiLCB3b3JkQXQoYnl0ZXMsIGkgKyA0LCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgICAgIGMgPSBhZGQzMihjLCB3b3JkQXQoYnl0ZXMsIGkgKyA4LCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG1peChhLCBiLCBjKTtcbiAgICAgICAgYSA9IHJlc1swXSwgYiA9IHJlc1sxXSwgYyA9IHJlc1syXTtcbiAgICB9XG4gICAgYSA9IGFkZDMyKGEsIHdvcmRBdChieXRlcywgaSwgRW5kaWFuLkxpdHRsZSkpO1xuICAgIGIgPSBhZGQzMihiLCB3b3JkQXQoYnl0ZXMsIGkgKyA0LCBFbmRpYW4uTGl0dGxlKSk7XG4gICAgLy8gdGhlIGZpcnN0IGJ5dGUgb2YgYyBpcyByZXNlcnZlZCBmb3IgdGhlIGxlbmd0aFxuICAgIGMgPSBhZGQzMihjLCBsZW4pO1xuICAgIGMgPSBhZGQzMihjLCB3b3JkQXQoYnl0ZXMsIGkgKyA4LCBFbmRpYW4uTGl0dGxlKSA8PCA4KTtcbiAgICByZXR1cm4gbWl4KGEsIGIsIGMpWzJdO1xufVxuLy8gY2xhbmctZm9ybWF0IG9mZlxuZnVuY3Rpb24gbWl4KGEsIGIsIGMpIHtcbiAgICBhID0gc3ViMzIoYSwgYik7XG4gICAgYSA9IHN1YjMyKGEsIGMpO1xuICAgIGEgXj0gYyA+Pj4gMTM7XG4gICAgYiA9IHN1YjMyKGIsIGMpO1xuICAgIGIgPSBzdWIzMihiLCBhKTtcbiAgICBiIF49IGEgPDwgODtcbiAgICBjID0gc3ViMzIoYywgYSk7XG4gICAgYyA9IHN1YjMyKGMsIGIpO1xuICAgIGMgXj0gYiA+Pj4gMTM7XG4gICAgYSA9IHN1YjMyKGEsIGIpO1xuICAgIGEgPSBzdWIzMihhLCBjKTtcbiAgICBhIF49IGMgPj4+IDEyO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDE2O1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiA1O1xuICAgIGEgPSBzdWIzMihhLCBiKTtcbiAgICBhID0gc3ViMzIoYSwgYyk7XG4gICAgYSBePSBjID4+PiAzO1xuICAgIGIgPSBzdWIzMihiLCBjKTtcbiAgICBiID0gc3ViMzIoYiwgYSk7XG4gICAgYiBePSBhIDw8IDEwO1xuICAgIGMgPSBzdWIzMihjLCBhKTtcbiAgICBjID0gc3ViMzIoYywgYik7XG4gICAgYyBePSBiID4+PiAxNTtcbiAgICByZXR1cm4gW2EsIGIsIGNdO1xufVxuLy8gY2xhbmctZm9ybWF0IG9uXG4vLyBVdGlsc1xudmFyIEVuZGlhbjtcbihmdW5jdGlvbiAoRW5kaWFuKSB7XG4gICAgRW5kaWFuW0VuZGlhbltcIkxpdHRsZVwiXSA9IDBdID0gXCJMaXR0bGVcIjtcbiAgICBFbmRpYW5bRW5kaWFuW1wiQmlnXCJdID0gMV0gPSBcIkJpZ1wiO1xufSkoRW5kaWFuIHx8IChFbmRpYW4gPSB7fSkpO1xuZnVuY3Rpb24gYWRkMzIoYSwgYikge1xuICAgIHJldHVybiBhZGQzMnRvNjQoYSwgYilbMV07XG59XG5mdW5jdGlvbiBhZGQzMnRvNjQoYSwgYikge1xuICAgIGNvbnN0IGxvdyA9IChhICYgMHhmZmZmKSArIChiICYgMHhmZmZmKTtcbiAgICBjb25zdCBoaWdoID0gKGEgPj4+IDE2KSArIChiID4+PiAxNikgKyAobG93ID4+PiAxNik7XG4gICAgcmV0dXJuIFtoaWdoID4+PiAxNiwgKGhpZ2ggPDwgMTYpIHwgKGxvdyAmIDB4ZmZmZildO1xufVxuZnVuY3Rpb24gYWRkNjQoYSwgYikge1xuICAgIGNvbnN0IGFoID0gYVswXSwgYWwgPSBhWzFdO1xuICAgIGNvbnN0IGJoID0gYlswXSwgYmwgPSBiWzFdO1xuICAgIGNvbnN0IHJlc3VsdCA9IGFkZDMydG82NChhbCwgYmwpO1xuICAgIGNvbnN0IGNhcnJ5ID0gcmVzdWx0WzBdO1xuICAgIGNvbnN0IGwgPSByZXN1bHRbMV07XG4gICAgY29uc3QgaCA9IGFkZDMyKGFkZDMyKGFoLCBiaCksIGNhcnJ5KTtcbiAgICByZXR1cm4gW2gsIGxdO1xufVxuZnVuY3Rpb24gc3ViMzIoYSwgYikge1xuICAgIGNvbnN0IGxvdyA9IChhICYgMHhmZmZmKSAtIChiICYgMHhmZmZmKTtcbiAgICBjb25zdCBoaWdoID0gKGEgPj4gMTYpIC0gKGIgPj4gMTYpICsgKGxvdyA+PiAxNik7XG4gICAgcmV0dXJuIChoaWdoIDw8IDE2KSB8IChsb3cgJiAweGZmZmYpO1xufVxuLy8gUm90YXRlIGEgMzJiIG51bWJlciBsZWZ0IGBjb3VudGAgcG9zaXRpb25cbmZ1bmN0aW9uIHJvbDMyKGEsIGNvdW50KSB7XG4gICAgcmV0dXJuIChhIDw8IGNvdW50KSB8IChhID4+PiAoMzIgLSBjb3VudCkpO1xufVxuLy8gUm90YXRlIGEgNjRiIG51bWJlciBsZWZ0IGBjb3VudGAgcG9zaXRpb25cbmZ1bmN0aW9uIHJvbDY0KG51bSwgY291bnQpIHtcbiAgICBjb25zdCBoaSA9IG51bVswXSwgbG8gPSBudW1bMV07XG4gICAgY29uc3QgaCA9IChoaSA8PCBjb3VudCkgfCAobG8gPj4+ICgzMiAtIGNvdW50KSk7XG4gICAgY29uc3QgbCA9IChsbyA8PCBjb3VudCkgfCAoaGkgPj4+ICgzMiAtIGNvdW50KSk7XG4gICAgcmV0dXJuIFtoLCBsXTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkczMyKGJ5dGVzLCBlbmRpYW4pIHtcbiAgICBjb25zdCBzaXplID0gKGJ5dGVzLmxlbmd0aCArIDMpID4+PiAyO1xuICAgIGNvbnN0IHdvcmRzMzIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICB3b3JkczMyW2ldID0gd29yZEF0KGJ5dGVzLCBpICogNCwgZW5kaWFuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmRzMzI7XG59XG5mdW5jdGlvbiBieXRlQXQoYnl0ZXMsIGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IGJ5dGVzLmxlbmd0aCA/IDAgOiBieXRlc1tpbmRleF07XG59XG5mdW5jdGlvbiB3b3JkQXQoYnl0ZXMsIGluZGV4LCBlbmRpYW4pIHtcbiAgICBsZXQgd29yZCA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gRW5kaWFuLkJpZykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgd29yZCArPSBieXRlQXQoYnl0ZXMsIGluZGV4ICsgaSkgPDwgKDI0IC0gOCAqIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgd29yZCArPSBieXRlQXQoYnl0ZXMsIGluZGV4ICsgaSkgPDwgOCAqIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdvcmQ7XG59XG5mdW5jdGlvbiB3b3JkczMyVG9CeXRlU3RyaW5nKHdvcmRzMzIpIHtcbiAgICByZXR1cm4gd29yZHMzMi5yZWR1Y2UoKGJ5dGVzLCB3b3JkKSA9PiBieXRlcy5jb25jYXQod29yZDMyVG9CeXRlU3RyaW5nKHdvcmQpKSwgW10pO1xufVxuZnVuY3Rpb24gd29yZDMyVG9CeXRlU3RyaW5nKHdvcmQpIHtcbiAgICBsZXQgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBieXRlcy5wdXNoKCh3b3JkID4+PiA4ICogKDMgLSBpKSkgJiAweGZmKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gYnl0ZXNUb0hleFN0cmluZyhieXRlcykge1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGIgPSBieXRlQXQoYnl0ZXMsIGkpO1xuICAgICAgICBoZXggKz0gKGIgPj4+IDQpLnRvU3RyaW5nKDE2KSArIChiICYgMHgwZikudG9TdHJpbmcoMTYpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4LnRvTG93ZXJDYXNlKCk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHNoYXJlZCBleHBvbmVudGlhdGlvbiBwb29sIGZvciBiYXNlLTI1NiBjb21wdXRhdGlvbnMuIFRoaXMgc2hhcmVkIHBvb2wgcHJvdmlkZXMgbWVtb2l6ZWRcbiAqIHBvd2VyLW9mLTI1NiByZXN1bHRzIHdpdGggbWVtb2l6ZWQgcG93ZXItb2YtdHdvIGNvbXB1dGF0aW9ucyBmb3IgZWZmaWNpZW50IG11bHRpcGxpY2F0aW9uLlxuICpcbiAqIEZvciBvdXIgcHVycG9zZXMsIHRoaXMgY2FuIGJlIHNhZmVseSBzdG9yZWQgYXMgYSBnbG9iYWwgd2l0aG91dCBtZW1vcnkgY29uY2VybnMuIFRoZSByZWFzb24gaXNcbiAqIHRoYXQgd2UgZW5jb2RlIHR3byB3b3Jkcywgc28gb25seSBuZWVkIHRoZSAwdGggKGZvciB0aGUgbG93IHdvcmQpIGFuZCA0dGggKGZvciB0aGUgaGlnaCB3b3JkKVxuICogZXhwb25lbnQuXG4gKi9cbmNvbnN0IGJhc2UyNTYgPSBuZXcgQmlnSW50RXhwb25lbnRpYXRpb24oMjU2KTtcbi8qKlxuICogUmVwcmVzZW50cyB0d28gMzItYml0IHdvcmRzIGFzIGEgc2luZ2xlIGRlY2ltYWwgbnVtYmVyLiBUaGlzIHJlcXVpcmVzIGEgYmlnIGludGVnZXIgc3RvcmFnZVxuICogbW9kZWwgYXMgSlMgbnVtYmVycyBhcmUgbm90IGFjY3VyYXRlIGVub3VnaCB0byByZXByZXNlbnQgdGhlIDY0LWJpdCBudW1iZXIuXG4gKlxuICogQmFzZWQgb24gaHR0cHM6Ly93d3cuZGFudmsub3JnL2hleDJkZWMuaHRtbFxuICovXG5mdW5jdGlvbiB3b3Jkc1RvRGVjaW1hbFN0cmluZyhoaSwgbG8pIHtcbiAgICAvLyBFbmNvZGUgdGhlIGZvdXIgYnl0ZXMgaW4gbG8gaW4gdGhlIGxvd2VyIGRpZ2l0cyBvZiB0aGUgZGVjaW1hbCBudW1iZXIuXG4gICAgLy8gTm90ZTogdGhlIG11bHRpcGxpY2F0aW9uIHJlc3VsdHMgaW4gbG8gaXRzZWxmIGJ1dCByZXByZXNlbnRlZCBieSBhIGJpZyBpbnRlZ2VyIHVzaW5nIGl0c1xuICAgIC8vIGRlY2ltYWwgZGlnaXRzLlxuICAgIGNvbnN0IGRlY2ltYWwgPSBiYXNlMjU2LnRvVGhlUG93ZXJPZigwKS5tdWx0aXBseUJ5KGxvKTtcbiAgICAvLyBFbmNvZGUgdGhlIGZvdXIgYnl0ZXMgaW4gaGkgYWJvdmUgdGhlIGZvdXIgbG8gYnl0ZXMuIGxvIGlzIGEgbWF4aW11bSBvZiAoMl44KV40LCB3aGljaCBpcyB3aHlcbiAgICAvLyB0aGlzIG11bHRpcGxpY2F0aW9uIGZhY3RvciBpcyBhcHBsaWVkLlxuICAgIGJhc2UyNTYudG9UaGVQb3dlck9mKDQpLm11bHRpcGx5QnlBbmRBZGRUbyhoaSwgZGVjaW1hbCk7XG4gICAgcmV0dXJuIGRlY2ltYWwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLy8vIFR5cGVzXG5leHBvcnRzLlR5cGVNb2RpZmllciA9IHZvaWQgMDtcbihmdW5jdGlvbiAoVHlwZU1vZGlmaWVyKSB7XG4gICAgVHlwZU1vZGlmaWVyW1R5cGVNb2RpZmllcltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIFR5cGVNb2RpZmllcltUeXBlTW9kaWZpZXJbXCJDb25zdFwiXSA9IDFdID0gXCJDb25zdFwiO1xufSkoZXhwb3J0cy5UeXBlTW9kaWZpZXIgfHwgKGV4cG9ydHMuVHlwZU1vZGlmaWVyID0ge30pKTtcbmNsYXNzIFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1vZGlmaWVycyA9IGV4cG9ydHMuVHlwZU1vZGlmaWVyLk5vbmUpIHtcbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgfVxuICAgIGhhc01vZGlmaWVyKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2RpZmllcnMgJiBtb2RpZmllcikgIT09IDA7XG4gICAgfVxufVxuZXhwb3J0cy5CdWlsdGluVHlwZU5hbWUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKEJ1aWx0aW5UeXBlTmFtZSkge1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJEeW5hbWljXCJdID0gMF0gPSBcIkR5bmFtaWNcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiQm9vbFwiXSA9IDFdID0gXCJCb29sXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIlN0cmluZ1wiXSA9IDJdID0gXCJTdHJpbmdcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiSW50XCJdID0gM10gPSBcIkludFwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJOdW1iZXJcIl0gPSA0XSA9IFwiTnVtYmVyXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkZ1bmN0aW9uXCJdID0gNV0gPSBcIkZ1bmN0aW9uXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkluZmVycmVkXCJdID0gNl0gPSBcIkluZmVycmVkXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIk5vbmVcIl0gPSA3XSA9IFwiTm9uZVwiO1xufSkoZXhwb3J0cy5CdWlsdGluVHlwZU5hbWUgfHwgKGV4cG9ydHMuQnVpbHRpblR5cGVOYW1lID0ge30pKTtcbmNsYXNzIEJ1aWx0aW5UeXBlIGV4dGVuZHMgVHlwZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIHN1cGVyKG1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHZpc2l0VHlwZSh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QnVpbHRpblR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRXhwcmVzc2lvblR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgbW9kaWZpZXJzLCB0eXBlUGFyYW1zID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtb2RpZmllcnMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudHlwZVBhcmFtcyA9IHR5cGVQYXJhbXM7XG4gICAgfVxuICAgIHZpc2l0VHlwZSh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwcmVzc2lvblR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQXJyYXlUeXBlIGV4dGVuZHMgVHlwZSB7XG4gICAgY29uc3RydWN0b3Iob2YsIG1vZGlmaWVycykge1xuICAgICAgICBzdXBlcihtb2RpZmllcnMpO1xuICAgICAgICB0aGlzLm9mID0gb2Y7XG4gICAgfVxuICAgIHZpc2l0VHlwZSh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXlUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIE1hcFR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZVR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBzdXBlcihtb2RpZmllcnMpO1xuICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IHZhbHVlVHlwZSB8fCBudWxsO1xuICAgIH1cbiAgICB2aXNpdFR5cGUodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE1hcFR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY29uc3QgRFlOQU1JQ19UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKGV4cG9ydHMuQnVpbHRpblR5cGVOYW1lLkR5bmFtaWMpO1xuY29uc3QgSU5GRVJSRURfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShleHBvcnRzLkJ1aWx0aW5UeXBlTmFtZS5JbmZlcnJlZCk7XG5jb25zdCBCT09MX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoZXhwb3J0cy5CdWlsdGluVHlwZU5hbWUuQm9vbCk7XG5jb25zdCBJTlRfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShleHBvcnRzLkJ1aWx0aW5UeXBlTmFtZS5JbnQpO1xuY29uc3QgTlVNQkVSX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoZXhwb3J0cy5CdWlsdGluVHlwZU5hbWUuTnVtYmVyKTtcbmNvbnN0IFNUUklOR19UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKGV4cG9ydHMuQnVpbHRpblR5cGVOYW1lLlN0cmluZyk7XG5jb25zdCBGVU5DVElPTl9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKGV4cG9ydHMuQnVpbHRpblR5cGVOYW1lLkZ1bmN0aW9uKTtcbmNvbnN0IE5PTkVfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShleHBvcnRzLkJ1aWx0aW5UeXBlTmFtZS5Ob25lKTtcbi8vLy8vIEV4cHJlc3Npb25zXG5leHBvcnRzLlVuYXJ5T3BlcmF0b3IgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFVuYXJ5T3BlcmF0b3IpIHtcbiAgICBVbmFyeU9wZXJhdG9yW1VuYXJ5T3BlcmF0b3JbXCJNaW51c1wiXSA9IDBdID0gXCJNaW51c1wiO1xuICAgIFVuYXJ5T3BlcmF0b3JbVW5hcnlPcGVyYXRvcltcIlBsdXNcIl0gPSAxXSA9IFwiUGx1c1wiO1xufSkoZXhwb3J0cy5VbmFyeU9wZXJhdG9yIHx8IChleHBvcnRzLlVuYXJ5T3BlcmF0b3IgPSB7fSkpO1xuZXhwb3J0cy5CaW5hcnlPcGVyYXRvciA9IHZvaWQgMDtcbihmdW5jdGlvbiAoQmluYXJ5T3BlcmF0b3IpIHtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkVxdWFsc1wiXSA9IDBdID0gXCJFcXVhbHNcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk5vdEVxdWFsc1wiXSA9IDFdID0gXCJOb3RFcXVhbHNcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIklkZW50aWNhbFwiXSA9IDJdID0gXCJJZGVudGljYWxcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk5vdElkZW50aWNhbFwiXSA9IDNdID0gXCJOb3RJZGVudGljYWxcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk1pbnVzXCJdID0gNF0gPSBcIk1pbnVzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJQbHVzXCJdID0gNV0gPSBcIlBsdXNcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkRpdmlkZVwiXSA9IDZdID0gXCJEaXZpZGVcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk11bHRpcGx5XCJdID0gN10gPSBcIk11bHRpcGx5XCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJNb2R1bG9cIl0gPSA4XSA9IFwiTW9kdWxvXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJBbmRcIl0gPSA5XSA9IFwiQW5kXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJPclwiXSA9IDEwXSA9IFwiT3JcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkJpdHdpc2VBbmRcIl0gPSAxMV0gPSBcIkJpdHdpc2VBbmRcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkxvd2VyXCJdID0gMTJdID0gXCJMb3dlclwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTG93ZXJFcXVhbHNcIl0gPSAxM10gPSBcIkxvd2VyRXF1YWxzXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaWdnZXJcIl0gPSAxNF0gPSBcIkJpZ2dlclwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQmlnZ2VyRXF1YWxzXCJdID0gMTVdID0gXCJCaWdnZXJFcXVhbHNcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk51bGxpc2hDb2FsZXNjZVwiXSA9IDE2XSA9IFwiTnVsbGlzaENvYWxlc2NlXCI7XG59KShleHBvcnRzLkJpbmFyeU9wZXJhdG9yIHx8IChleHBvcnRzLkJpbmFyeU9wZXJhdG9yID0ge30pKTtcbmZ1bmN0aW9uIG51bGxTYWZlSXNFcXVpdmFsZW50KGJhc2UsIG90aGVyKSB7XG4gICAgaWYgKGJhc2UgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiYXNlID09IG90aGVyO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZS5pc0VxdWl2YWxlbnQob3RoZXIpO1xufVxuZnVuY3Rpb24gYXJlQWxsRXF1aXZhbGVudFByZWRpY2F0ZShiYXNlLCBvdGhlciwgZXF1aXZhbGVudFByZWRpY2F0ZSkge1xuICAgIGNvbnN0IGxlbiA9IGJhc2UubGVuZ3RoO1xuICAgIGlmIChsZW4gIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKCFlcXVpdmFsZW50UHJlZGljYXRlKGJhc2VbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXJlQWxsRXF1aXZhbGVudChiYXNlLCBvdGhlcikge1xuICAgIHJldHVybiBhcmVBbGxFcXVpdmFsZW50UHJlZGljYXRlKGJhc2UsIG90aGVyLCAoYmFzZUVsZW1lbnQsIG90aGVyRWxlbWVudCkgPT4gYmFzZUVsZW1lbnQuaXNFcXVpdmFsZW50KG90aGVyRWxlbWVudCkpO1xufVxuY2xhc3MgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW4gfHwgbnVsbDtcbiAgICB9XG4gICAgcHJvcChuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFByb3BFeHByKHRoaXMsIG5hbWUsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBrZXkoaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkS2V5RXhwcih0aGlzLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGNhbGxGbihwYXJhbXMsIHNvdXJjZVNwYW4sIHB1cmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZva2VGdW5jdGlvbkV4cHIodGhpcywgcGFyYW1zLCBudWxsLCBzb3VyY2VTcGFuLCBwdXJlKTtcbiAgICB9XG4gICAgaW5zdGFudGlhdGUocGFyYW1zLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5zdGFudGlhdGVFeHByKHRoaXMsIHBhcmFtcywgdHlwZSwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGNvbmRpdGlvbmFsKHRydWVDYXNlLCBmYWxzZUNhc2UgPSBudWxsLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWxFeHByKHRoaXMsIHRydWVDYXNlLCBmYWxzZUNhc2UsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBlcXVhbHMocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuRXF1YWxzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBub3RFcXVhbHMocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBpZGVudGljYWwocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBub3RJZGVudGljYWwocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuTm90SWRlbnRpY2FsLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBtaW51cyhyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5NaW51cywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgcGx1cyhyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5QbHVzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBkaXZpZGUocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuRGl2aWRlLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBtdWx0aXBseShyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5NdWx0aXBseSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgbW9kdWxvKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk1vZHVsbywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgYW5kKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihleHBvcnRzLkJpbmFyeU9wZXJhdG9yLkFuZCwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgYml0d2lzZUFuZChyaHMsIHNvdXJjZVNwYW4sIHBhcmVucyA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5CaXR3aXNlQW5kLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4sIHBhcmVucyk7XG4gICAgfVxuICAgIG9yKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk9yLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBsb3dlcihyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5Mb3dlciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgbG93ZXJFcXVhbHMocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGJpZ2dlcihyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5CaWdnZXIsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGJpZ2dlckVxdWFscyhyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGlzQmxhbmsoc291cmNlU3Bhbikge1xuICAgICAgICAvLyBOb3RlOiBXZSB1c2UgZXF1YWxzIGJ5IHB1cnBvc2UgaGVyZSB0byBjb21wYXJlIHRvIG51bGwgYW5kIHVuZGVmaW5lZCBpbiBKUy5cbiAgICAgICAgLy8gV2UgdXNlIHRoZSB0eXBlZCBudWxsIHRvIGFsbG93IHN0cmljdE51bGxDaGVja3MgdG8gbmFycm93IHR5cGVzLlxuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoVFlQRURfTlVMTF9FWFBSLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgbnVsbGlzaENvYWxlc2NlKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk51bGxpc2hDb2FsZXNjZSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdG9TdG10KCkge1xuICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodGhpcywgbnVsbCk7XG4gICAgfVxufVxuY2xhc3MgUmVhZFZhckV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIHRoaXMubmFtZSA9PT0gZS5uYW1lO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZFZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcih0aGlzLm5hbWUsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH1cbn1cbmNsYXNzIFR5cGVvZkV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihleHByLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFR5cGVvZkV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgVHlwZW9mRXhwciAmJiBlLmV4cHIuaXNFcXVpdmFsZW50KHRoaXMuZXhwcik7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHIuaXNDb25zdGFudCgpO1xuICAgIH1cbn1cbmNsYXNzIFdyYXBwZWROb2RlRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIodHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgV3JhcHBlZE5vZGVFeHByICYmIHRoaXMubm9kZSA9PT0gZS5ub2RlO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JhcHBlZE5vZGVFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFdyaXRlVmFyRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBXcml0ZVZhckV4cHIgJiYgdGhpcy5uYW1lID09PSBlLm5hbWUgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoZS52YWx1ZSk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHRvRGVjbFN0bXQodHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGhpcy5uYW1lLCB0aGlzLnZhbHVlLCB0eXBlLCBtb2RpZmllcnMsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHRvQ29uc3REZWNsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RlY2xTdG10KElORkVSUkVEX1RZUEUsIGV4cG9ydHMuU3RtdE1vZGlmaWVyLkZpbmFsKTtcbiAgICB9XG59XG5jbGFzcyBXcml0ZUtleUV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZWNlaXZlciwgaW5kZXgsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgV3JpdGVLZXlFeHByICYmIHRoaXMucmVjZWl2ZXIuaXNFcXVpdmFsZW50KGUucmVjZWl2ZXIpICYmXG4gICAgICAgICAgICB0aGlzLmluZGV4LmlzRXF1aXZhbGVudChlLmluZGV4KSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChlLnZhbHVlKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBXcml0ZVByb3BFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocmVjZWl2ZXIsIG5hbWUsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFdyaXRlUHJvcEV4cHIgJiYgdGhpcy5yZWNlaXZlci5pc0VxdWl2YWxlbnQoZS5yZWNlaXZlcikgJiZcbiAgICAgICAgICAgIHRoaXMubmFtZSA9PT0gZS5uYW1lICYmIHRoaXMudmFsdWUuaXNFcXVpdmFsZW50KGUudmFsdWUpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JpdGVQcm9wRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBJbnZva2VGdW5jdGlvbkV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmbiwgYXJncywgdHlwZSwgc291cmNlU3BhbiwgcHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMucHVyZSA9IHB1cmU7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSW52b2tlRnVuY3Rpb25FeHByICYmIHRoaXMuZm4uaXNFcXVpdmFsZW50KGUuZm4pICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuYXJncywgZS5hcmdzKSAmJiB0aGlzLnB1cmUgPT09IGUucHVyZTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludm9rZUZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBUYWdnZWRUZW1wbGF0ZUV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIHRlbXBsYXRlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFRhZ2dlZFRlbXBsYXRlRXhwciAmJiB0aGlzLnRhZy5pc0VxdWl2YWxlbnQoZS50YWcpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50UHJlZGljYXRlKHRoaXMudGVtcGxhdGUuZWxlbWVudHMsIGUudGVtcGxhdGUuZWxlbWVudHMsIChhLCBiKSA9PiBhLnRleHQgPT09IGIudGV4dCkgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy50ZW1wbGF0ZS5leHByZXNzaW9ucywgZS50ZW1wbGF0ZS5leHByZXNzaW9ucyk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdnZWRUZW1wbGF0ZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgSW5zdGFudGlhdGVFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY2xhc3NFeHByLCBhcmdzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmNsYXNzRXhwciA9IGNsYXNzRXhwcjtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBJbnN0YW50aWF0ZUV4cHIgJiYgdGhpcy5jbGFzc0V4cHIuaXNFcXVpdmFsZW50KGUuY2xhc3NFeHByKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmFyZ3MsIGUuYXJncyk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnN0YW50aWF0ZUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIExpdGVyYWxFeHByICYmIHRoaXMudmFsdWUgPT09IGUudmFsdWU7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFRlbXBsYXRlTGl0ZXJhbCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMsIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgIH1cbn1cbmNsYXNzIFRlbXBsYXRlTGl0ZXJhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHNvdXJjZVNwYW4sIHJhd1RleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICAvLyBJZiBgcmF3VGV4dGAgaXMgbm90IHByb3ZpZGVkLCB0cnkgdG8gZXh0cmFjdCB0aGUgcmF3IHN0cmluZyBmcm9tIGl0c1xuICAgICAgICAvLyBhc3NvY2lhdGVkIGBzb3VyY2VTcGFuYC4gSWYgdGhhdCBpcyBhbHNvIG5vdCBhdmFpbGFibGUsIFwiZmFrZVwiIHRoZSByYXdcbiAgICAgICAgLy8gc3RyaW5nIGluc3RlYWQgYnkgZXNjYXBpbmcgdGhlIGZvbGxvd2luZyBjb250cm9sIHNlcXVlbmNlczpcbiAgICAgICAgLy8gLSBcIlxcXCIgd291bGQgb3RoZXJ3aXNlIGluZGljYXRlIHRoYXQgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIuXG4gICAgICAgIC8vIC0gXCJgXCIgYW5kIFwiJHtcIiBhcmUgdGVtcGxhdGUgc3RyaW5nIGNvbnRyb2wgc2VxdWVuY2VzIHRoYXQgd291bGQgb3RoZXJ3aXNlIHByZW1hdHVyZWx5XG4gICAgICAgIC8vIGluZGljYXRlIHRoZSBlbmQgb2YgdGhlIHRlbXBsYXRlIGxpdGVyYWwgZWxlbWVudC5cbiAgICAgICAgdGhpcy5yYXdUZXh0ID1cbiAgICAgICAgICAgIChfYSA9IHJhd1RleHQgIT09IG51bGwgJiYgcmF3VGV4dCAhPT0gdm9pZCAwID8gcmF3VGV4dCA6IHNvdXJjZVNwYW4gPT09IG51bGwgfHwgc291cmNlU3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlU3Bhbi50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlc2NhcGVGb3JUZW1wbGF0ZUxpdGVyYWwoZXNjYXBlU2xhc2hlcyh0ZXh0KSk7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbFBpZWNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxufVxuY2xhc3MgUGxhY2Vob2xkZXJQaWVjZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgYFBsYWNlaG9sZGVyUGllY2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRleHQgdGhlIG5hbWUgb2YgdGhpcyBwbGFjZWhvbGRlciAoZS5nLiBgUEhfMWApLlxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuIHRoZSBsb2NhdGlvbiBvZiB0aGlzIHBsYWNlaG9sZGVyIGluIGl0cyBsb2NhbGl6ZWQgbWVzc2FnZSB0aGUgc291cmNlIGNvZGUuXG4gICAgICogQHBhcmFtIGFzc29jaWF0ZWRNZXNzYWdlIHJlZmVyZW5jZSB0byBhbm90aGVyIG1lc3NhZ2UgdGhhdCB0aGlzIHBsYWNlaG9sZGVyIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICAgKiBUaGUgYGFzc29jaWF0ZWRNZXNzYWdlYCBpcyBtYWlubHkgdXNlZCB0byBwcm92aWRlIGEgcmVsYXRpb25zaGlwIHRvIGFuIElDVSBtZXNzYWdlIHRoYXQgaGFzXG4gICAgICogYmVlbiBleHRyYWN0ZWQgb3V0IGZyb20gdGhlIG1lc3NhZ2UgY29udGFpbmluZyB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGV4dCwgc291cmNlU3BhbiwgYXNzb2NpYXRlZE1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGVkTWVzc2FnZSA9IGFzc29jaWF0ZWRNZXNzYWdlO1xuICAgIH1cbn1cbmNvbnN0IE1FQU5JTkdfU0VQQVJBVE9SJDEgPSAnfCc7XG5jb25zdCBJRF9TRVBBUkFUT1IkMSA9ICdAQCc7XG5jb25zdCBMRUdBQ1lfSURfSU5ESUNBVE9SID0gJ+KQnyc7XG5jbGFzcyBMb2NhbGl6ZWRTdHJpbmcgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhQmxvY2ssIG1lc3NhZ2VQYXJ0cywgcGxhY2VIb2xkZXJOYW1lcywgZXhwcmVzc2lvbnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIoU1RSSU5HX1RZUEUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLm1ldGFCbG9jayA9IG1ldGFCbG9jaztcbiAgICAgICAgdGhpcy5tZXNzYWdlUGFydHMgPSBtZXNzYWdlUGFydHM7XG4gICAgICAgIHRoaXMucGxhY2VIb2xkZXJOYW1lcyA9IHBsYWNlSG9sZGVyTmFtZXM7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgLy8gcmV0dXJuIGUgaW5zdGFuY2VvZiBMb2NhbGl6ZWRTdHJpbmcgJiYgdGhpcy5tZXNzYWdlID09PSBlLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExvY2FsaXplZFN0cmluZyh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBnaXZlbiBgbWV0YWAgYW5kIGBtZXNzYWdlUGFydGAgaW50byBcImNvb2tlZFwiIGFuZCBcInJhd1wiIHN0cmluZ3MgdGhhdCBjYW4gYmUgdXNlZFxuICAgICAqIGluIGEgYCRsb2NhbGl6ZWAgdGFnZ2VkIHN0cmluZy4gVGhlIGZvcm1hdCBvZiB0aGUgbWV0YWRhdGEgaXMgdGhlIHNhbWUgYXMgdGhhdCBwYXJzZWQgYnlcbiAgICAgKiBgcGFyc2VJMThuTWV0YSgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRhIFRoZSBtZXRhZGF0YSB0byBzZXJpYWxpemVcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcnQgVGhlIGZpcnN0IHBhcnQgb2YgdGhlIHRhZ2dlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBzZXJpYWxpemVJMThuSGVhZCgpIHtcbiAgICAgICAgbGV0IG1ldGFCbG9jayA9IHRoaXMubWV0YUJsb2NrLmRlc2NyaXB0aW9uIHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5tZXRhQmxvY2subWVhbmluZykge1xuICAgICAgICAgICAgbWV0YUJsb2NrID0gYCR7dGhpcy5tZXRhQmxvY2subWVhbmluZ30ke01FQU5JTkdfU0VQQVJBVE9SJDF9JHttZXRhQmxvY2t9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhQmxvY2suY3VzdG9tSWQpIHtcbiAgICAgICAgICAgIG1ldGFCbG9jayA9IGAke21ldGFCbG9ja30ke0lEX1NFUEFSQVRPUiQxfSR7dGhpcy5tZXRhQmxvY2suY3VzdG9tSWR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhQmxvY2subGVnYWN5SWRzKSB7XG4gICAgICAgICAgICB0aGlzLm1ldGFCbG9jay5sZWdhY3lJZHMuZm9yRWFjaChsZWdhY3lJZCA9PiB7XG4gICAgICAgICAgICAgICAgbWV0YUJsb2NrID0gYCR7bWV0YUJsb2NrfSR7TEVHQUNZX0lEX0lORElDQVRPUn0ke2xlZ2FjeUlkfWA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQ29va2VkUmF3U3RyaW5nKG1ldGFCbG9jaywgdGhpcy5tZXNzYWdlUGFydHNbMF0udGV4dCwgdGhpcy5nZXRNZXNzYWdlUGFydFNvdXJjZVNwYW4oMCkpO1xuICAgIH1cbiAgICBnZXRNZXNzYWdlUGFydFNvdXJjZVNwYW4oaSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5tZXNzYWdlUGFydHNbaV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnNvdXJjZVNwYW47XG4gICAgfVxuICAgIGdldFBsYWNlaG9sZGVyU291cmNlU3BhbihpKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuIChfZCA9IChfYiA9IChfYSA9IHRoaXMucGxhY2VIb2xkZXJOYW1lc1tpXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvdXJjZVNwYW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChfYyA9IHRoaXMuZXhwcmVzc2lvbnNbaV0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLnNvdXJjZVNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYHBsYWNlaG9sZGVyTmFtZWAgYW5kIGBtZXNzYWdlUGFydGAgaW50byBcImNvb2tlZFwiIGFuZCBcInJhd1wiIHN0cmluZ3MgdGhhdFxuICAgICAqIGNhbiBiZSB1c2VkIGluIGEgYCRsb2NhbGl6ZWAgdGFnZ2VkIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgaXMgYDo8cGxhY2Vob2xkZXItbmFtZT5bQEA8YXNzb2NpYXRlZC1pZD5dOmAuXG4gICAgICpcbiAgICAgKiBUaGUgYGFzc29jaWF0ZWQtaWRgIGlzIHRoZSBtZXNzYWdlIGlkIG9mIHRoZSAodXN1YWxseSBhbiBJQ1UpIG1lc3NhZ2UgdG8gd2hpY2ggdGhpcyBwbGFjZWhvbGRlclxuICAgICAqIHJlZmVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJ0SW5kZXggVGhlIGluZGV4IG9mIHRoZSBtZXNzYWdlIHBhcnQgdG8gc2VyaWFsaXplLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZUkxOG5UZW1wbGF0ZVBhcnQocGFydEluZGV4KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlSG9sZGVyTmFtZXNbcGFydEluZGV4IC0gMV07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJ0ID0gdGhpcy5tZXNzYWdlUGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgbGV0IG1ldGFCbG9jayA9IHBsYWNlaG9sZGVyLnRleHQ7XG4gICAgICAgIGlmICgoKF9hID0gcGxhY2Vob2xkZXIuYXNzb2NpYXRlZE1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZWdhY3lJZHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgbWV0YUJsb2NrICs9IGAke0lEX1NFUEFSQVRPUiQxfSR7Y29tcHV0ZU1zZ0lkKHBsYWNlaG9sZGVyLmFzc29jaWF0ZWRNZXNzYWdlLm1lc3NhZ2VTdHJpbmcsIHBsYWNlaG9sZGVyLmFzc29jaWF0ZWRNZXNzYWdlLm1lYW5pbmcpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvb2tlZFJhd1N0cmluZyhtZXRhQmxvY2ssIG1lc3NhZ2VQYXJ0LnRleHQsIHRoaXMuZ2V0TWVzc2FnZVBhcnRTb3VyY2VTcGFuKHBhcnRJbmRleCkpO1xuICAgIH1cbn1cbmNvbnN0IGVzY2FwZVNsYXNoZXMgPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKTtcbmNvbnN0IGVzY2FwZVN0YXJ0aW5nQ29sb24gPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvXjovLCAnXFxcXDonKTtcbmNvbnN0IGVzY2FwZUNvbG9ucyA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC86L2csICdcXFxcOicpO1xuY29uc3QgZXNjYXBlRm9yVGVtcGxhdGVMaXRlcmFsID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL2AvZywgJ1xcXFxgJykucmVwbGFjZSgvXFwkey9nLCAnJFxcXFx7Jyk7XG4vKipcbiAqIENyZWF0ZXMgYSBge2Nvb2tlZCwgcmF3fWAgb2JqZWN0IGZyb20gdGhlIGBtZXRhQmxvY2tgIGFuZCBgbWVzc2FnZVBhcnRgLlxuICpcbiAqIFRoZSBgcmF3YCB0ZXh0IG11c3QgaGF2ZSB2YXJpb3VzIGNoYXJhY3RlciBzZXF1ZW5jZXMgZXNjYXBlZDpcbiAqICogXCJcXFwiIHdvdWxkIG90aGVyd2lzZSBpbmRpY2F0ZSB0aGF0IHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLlxuICogKiBcImBcIiBhbmQgXCIke1wiIGFyZSB0ZW1wbGF0ZSBzdHJpbmcgY29udHJvbCBzZXF1ZW5jZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgcHJlbWF0dXJlbHkgaW5kaWNhdGVcbiAqICAgdGhlIGVuZCBvZiBhIG1lc3NhZ2UgcGFydC5cbiAqICogXCI6XCIgaW5zaWRlIGEgbWV0YWJsb2NrIHdvdWxkIHByZW1hdHVyZWx5IGluZGljYXRlIHRoZSBlbmQgb2YgdGhlIG1ldGFibG9jay5cbiAqICogXCI6XCIgYXQgdGhlIHN0YXJ0IG9mIGEgbWVzc2FnZVBhcnQgd2l0aCBubyBtZXRhYmxvY2sgd291bGQgZXJyb25lb3VzbHkgaW5kaWNhdGUgdGhlIHN0YXJ0IG9mIGFcbiAqICAgbWV0YWJsb2NrLlxuICpcbiAqIEBwYXJhbSBtZXRhQmxvY2sgQW55IG1ldGFkYXRhIHRoYXQgc2hvdWxkIGJlIHByZXBlbmRlZCB0byB0aGUgc3RyaW5nXG4gKiBAcGFyYW0gbWVzc2FnZVBhcnQgVGhlIG1lc3NhZ2UgcGFydCBvZiB0aGUgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvb2tlZFJhd1N0cmluZyhtZXRhQmxvY2ssIG1lc3NhZ2VQYXJ0LCByYW5nZSkge1xuICAgIGlmIChtZXRhQmxvY2sgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb29rZWQ6IG1lc3NhZ2VQYXJ0LFxuICAgICAgICAgICAgcmF3OiBlc2NhcGVGb3JUZW1wbGF0ZUxpdGVyYWwoZXNjYXBlU3RhcnRpbmdDb2xvbihlc2NhcGVTbGFzaGVzKG1lc3NhZ2VQYXJ0KSkpLFxuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29va2VkOiBgOiR7bWV0YUJsb2NrfToke21lc3NhZ2VQYXJ0fWAsXG4gICAgICAgICAgICByYXc6IGVzY2FwZUZvclRlbXBsYXRlTGl0ZXJhbChgOiR7ZXNjYXBlQ29sb25zKGVzY2FwZVNsYXNoZXMobWV0YUJsb2NrKSl9OiR7ZXNjYXBlU2xhc2hlcyhtZXNzYWdlUGFydCl9YCksXG4gICAgICAgICAgICByYW5nZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBFeHRlcm5hbEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdHlwZSwgdHlwZVBhcmFtcyA9IG51bGwsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIodHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50eXBlUGFyYW1zID0gdHlwZVBhcmFtcztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBFeHRlcm5hbEV4cHIgJiYgdGhpcy52YWx1ZS5uYW1lID09PSBlLnZhbHVlLm5hbWUgJiZcbiAgICAgICAgICAgIHRoaXMudmFsdWUubW9kdWxlTmFtZSA9PT0gZS52YWx1ZS5tb2R1bGVOYW1lICYmIHRoaXMudmFsdWUucnVudGltZSA9PT0gZS52YWx1ZS5ydW50aW1lO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXh0ZXJuYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEV4dGVybmFsUmVmZXJlbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2R1bGVOYW1lLCBuYW1lLCBydW50aW1lKSB7XG4gICAgICAgIHRoaXMubW9kdWxlTmFtZSA9IG1vZHVsZU5hbWU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gICAgfVxufVxuY2xhc3MgQ29uZGl0aW9uYWxFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCB0cnVlQ2FzZSwgZmFsc2VDYXNlID0gbnVsbCwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlIHx8IHRydWVDYXNlLnR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy5mYWxzZUNhc2UgPSBmYWxzZUNhc2U7XG4gICAgICAgIHRoaXMudHJ1ZUNhc2UgPSB0cnVlQ2FzZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDb25kaXRpb25hbEV4cHIgJiYgdGhpcy5jb25kaXRpb24uaXNFcXVpdmFsZW50KGUuY29uZGl0aW9uKSAmJlxuICAgICAgICAgICAgdGhpcy50cnVlQ2FzZS5pc0VxdWl2YWxlbnQoZS50cnVlQ2FzZSkgJiYgbnVsbFNhZmVJc0VxdWl2YWxlbnQodGhpcy5mYWxzZUNhc2UsIGUuZmFsc2VDYXNlKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbmRpdGlvbmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBOb3RFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZGl0aW9uLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKEJPT0xfVFlQRSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIE5vdEV4cHIgJiYgdGhpcy5jb25kaXRpb24uaXNFcXVpdmFsZW50KGUuY29uZGl0aW9uKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5vdEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRm5QYXJhbSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KHBhcmFtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT09IHBhcmFtLm5hbWU7XG4gICAgfVxufVxuY2xhc3MgRnVuY3Rpb25FeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBzb3VyY2VTcGFuLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBGdW5jdGlvbkV4cHIgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLnBhcmFtcywgZS5wYXJhbXMpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuc3RhdGVtZW50cywgZS5zdGF0ZW1lbnRzKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEZ1bmN0aW9uRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdG9EZWNsU3RtdChuYW1lLCBtb2RpZmllcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJlRnVuY3Rpb25TdG10KG5hbWUsIHRoaXMucGFyYW1zLCB0aGlzLnN0YXRlbWVudHMsIHRoaXMudHlwZSwgbW9kaWZpZXJzLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH1cbn1cbmNsYXNzIFVuYXJ5T3BlcmF0b3JFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0b3IsIGV4cHIsIHR5cGUsIHNvdXJjZVNwYW4sIHBhcmVucyA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSB8fCBOVU1CRVJfVFlQRSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5leHByID0gZXhwcjtcbiAgICAgICAgdGhpcy5wYXJlbnMgPSBwYXJlbnM7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgVW5hcnlPcGVyYXRvckV4cHIgJiYgdGhpcy5vcGVyYXRvciA9PT0gZS5vcGVyYXRvciAmJlxuICAgICAgICAgICAgdGhpcy5leHByLmlzRXF1aXZhbGVudChlLmV4cHIpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VW5hcnlPcGVyYXRvckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQmluYXJ5T3BlcmF0b3JFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0b3IsIGxocywgcmhzLCB0eXBlLCBzb3VyY2VTcGFuLCBwYXJlbnMgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKHR5cGUgfHwgbGhzLnR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgICB0aGlzLnBhcmVucyA9IHBhcmVucztcbiAgICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgQmluYXJ5T3BlcmF0b3JFeHByICYmIHRoaXMub3BlcmF0b3IgPT09IGUub3BlcmF0b3IgJiZcbiAgICAgICAgICAgIHRoaXMubGhzLmlzRXF1aXZhbGVudChlLmxocykgJiYgdGhpcy5yaHMuaXNFcXVpdmFsZW50KGUucmhzKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeU9wZXJhdG9yRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBSZWFkUHJvcEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZWNlaXZlciwgbmFtZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFJlYWRQcm9wRXhwciAmJiB0aGlzLnJlY2VpdmVyLmlzRXF1aXZhbGVudChlLnJlY2VpdmVyKSAmJlxuICAgICAgICAgICAgdGhpcy5uYW1lID09PSBlLm5hbWU7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkUHJvcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlUHJvcEV4cHIodGhpcy5yZWNlaXZlciwgdGhpcy5uYW1lLCB2YWx1ZSwgbnVsbCwgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9XG59XG5jbGFzcyBSZWFkS2V5RXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHJlY2VpdmVyLCBpbmRleCwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgUmVhZEtleUV4cHIgJiYgdGhpcy5yZWNlaXZlci5pc0VxdWl2YWxlbnQoZS5yZWNlaXZlcikgJiZcbiAgICAgICAgICAgIHRoaXMuaW5kZXguaXNFcXVpdmFsZW50KGUuaW5kZXgpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZEtleUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlS2V5RXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLmluZGV4LCB2YWx1ZSwgbnVsbCwgdGhpcy5zb3VyY2VTcGFuKTtcbiAgICB9XG59XG5jbGFzcyBMaXRlcmFsQXJyYXlFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZW50cmllcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5ldmVyeShlID0+IGUuaXNDb25zdGFudCgpKTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBMaXRlcmFsQXJyYXlFeHByICYmIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5lbnRyaWVzLCBlLmVudHJpZXMpO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxBcnJheUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbE1hcEVudHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBxdW90ZWQpIHtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5xdW90ZWQgPSBxdW90ZWQ7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleSA9PT0gZS5rZXkgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoZS52YWx1ZSk7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbE1hcEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IHR5cGUudmFsdWVUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgTGl0ZXJhbE1hcEV4cHIgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmVudHJpZXMsIGUuZW50cmllcyk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMuZXZlcnkoZSA9PiBlLnZhbHVlLmlzQ29uc3RhbnQoKSk7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQ29tbWFFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocGFydHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIocGFydHNbcGFydHMubGVuZ3RoIC0gMV0udHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucGFydHMgPSBwYXJ0cztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDb21tYUV4cHIgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLnBhcnRzLCBlLnBhcnRzKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbW1hRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jb25zdCBOVUxMX0VYUFIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCwgbnVsbCwgbnVsbCk7XG5jb25zdCBUWVBFRF9OVUxMX0VYUFIgPSBuZXcgTGl0ZXJhbEV4cHIobnVsbCwgSU5GRVJSRURfVFlQRSwgbnVsbCk7XG4vLy8vIFN0YXRlbWVudHNcbmV4cG9ydHMuU3RtdE1vZGlmaWVyID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChTdG10TW9kaWZpZXIpIHtcbiAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIkZpbmFsXCJdID0gMV0gPSBcIkZpbmFsXCI7XG4gICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIlByaXZhdGVcIl0gPSAyXSA9IFwiUHJpdmF0ZVwiO1xuICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJFeHBvcnRlZFwiXSA9IDRdID0gXCJFeHBvcnRlZFwiO1xuICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJTdGF0aWNcIl0gPSA4XSA9IFwiU3RhdGljXCI7XG59KShleHBvcnRzLlN0bXRNb2RpZmllciB8fCAoZXhwb3J0cy5TdG10TW9kaWZpZXIgPSB7fSkpO1xuY2xhc3MgTGVhZGluZ0NvbW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIG11bHRpbGluZSwgdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubXVsdGlsaW5lID0gbXVsdGlsaW5lO1xuICAgICAgICB0aGlzLnRyYWlsaW5nTmV3bGluZSA9IHRyYWlsaW5nTmV3bGluZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpbGluZSA/IGAgJHt0aGlzLnRleHR9IGAgOiB0aGlzLnRleHQ7XG4gICAgfVxufVxuY2xhc3MgSlNEb2NDb21tZW50IGV4dGVuZHMgTGVhZGluZ0NvbW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MpIHtcbiAgICAgICAgc3VwZXIoJycsIC8qIG11bHRpbGluZSAqLyB0cnVlLCAvKiB0cmFpbGluZ05ld2xpbmUgKi8gdHJ1ZSk7XG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplVGFncyh0aGlzLnRhZ3MpO1xuICAgIH1cbn1cbmNsYXNzIFN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3IobW9kaWZpZXJzID0gZXhwb3J0cy5TdG10TW9kaWZpZXIuTm9uZSwgc291cmNlU3BhbiA9IG51bGwsIGxlYWRpbmdDb21tZW50cykge1xuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5sZWFkaW5nQ29tbWVudHMgPSBsZWFkaW5nQ29tbWVudHM7XG4gICAgfVxuICAgIGhhc01vZGlmaWVyKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2RpZmllcnMgJiBtb2RpZmllcikgIT09IDA7XG4gICAgfVxuICAgIGFkZExlYWRpbmdDb21tZW50KGxlYWRpbmdDb21tZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5sZWFkaW5nQ29tbWVudHMgPSAoX2EgPSB0aGlzLmxlYWRpbmdDb21tZW50cykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIHRoaXMubGVhZGluZ0NvbW1lbnRzLnB1c2gobGVhZGluZ0NvbW1lbnQpO1xuICAgIH1cbn1cbmNsYXNzIERlY2xhcmVWYXJTdG10IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSwgdHlwZSwgbW9kaWZpZXJzLCBzb3VyY2VTcGFuLCBsZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgc3VwZXIobW9kaWZpZXJzLCBzb3VyY2VTcGFuLCBsZWFkaW5nQ29tbWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgKHZhbHVlICYmIHZhbHVlLnR5cGUpIHx8IG51bGw7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChzdG10KSB7XG4gICAgICAgIHJldHVybiBzdG10IGluc3RhbmNlb2YgRGVjbGFyZVZhclN0bXQgJiYgdGhpcy5uYW1lID09PSBzdG10Lm5hbWUgJiZcbiAgICAgICAgICAgICh0aGlzLnZhbHVlID8gISFzdG10LnZhbHVlICYmIHRoaXMudmFsdWUuaXNFcXVpdmFsZW50KHN0bXQudmFsdWUpIDogIXN0bXQudmFsdWUpO1xuICAgIH1cbiAgICB2aXNpdFN0YXRlbWVudCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZVZhclN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRGVjbGFyZUZ1bmN0aW9uU3RtdCBleHRlbmRzIFN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcGFyYW1zLCBzdGF0ZW1lbnRzLCB0eXBlLCBtb2RpZmllcnMsIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cykge1xuICAgICAgICBzdXBlcihtb2RpZmllcnMsIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IG51bGw7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChzdG10KSB7XG4gICAgICAgIHJldHVybiBzdG10IGluc3RhbmNlb2YgRGVjbGFyZUZ1bmN0aW9uU3RtdCAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMucGFyYW1zLCBzdG10LnBhcmFtcykgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5zdGF0ZW1lbnRzLCBzdG10LnN0YXRlbWVudHMpO1xuICAgIH1cbiAgICB2aXNpdFN0YXRlbWVudCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBFeHByZXNzaW9uU3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihleHByLCBzb3VyY2VTcGFuLCBsZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgc3VwZXIoZXhwb3J0cy5TdG10TW9kaWZpZXIuTm9uZSwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKTtcbiAgICAgICAgdGhpcy5leHByID0gZXhwcjtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBFeHByZXNzaW9uU3RhdGVtZW50ICYmIHRoaXMuZXhwci5pc0VxdWl2YWxlbnQoc3RtdC5leHByKTtcbiAgICB9XG4gICAgdmlzaXRTdGF0ZW1lbnQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cHJlc3Npb25TdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFJldHVyblN0YXRlbWVudCBleHRlbmRzIFN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNvdXJjZVNwYW4gPSBudWxsLCBsZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgc3VwZXIoZXhwb3J0cy5TdG10TW9kaWZpZXIuTm9uZSwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIFJldHVyblN0YXRlbWVudCAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChzdG10LnZhbHVlKTtcbiAgICB9XG4gICAgdmlzaXRTdGF0ZW1lbnQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJldHVyblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgSWZTdG10IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIHRydWVDYXNlLCBmYWxzZUNhc2UgPSBbXSwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKGV4cG9ydHMuU3RtdE1vZGlmaWVyLk5vbmUsIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cyk7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnRydWVDYXNlID0gdHJ1ZUNhc2U7XG4gICAgICAgIHRoaXMuZmFsc2VDYXNlID0gZmFsc2VDYXNlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIElmU3RtdCAmJiB0aGlzLmNvbmRpdGlvbi5pc0VxdWl2YWxlbnQoc3RtdC5jb25kaXRpb24pICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMudHJ1ZUNhc2UsIHN0bXQudHJ1ZUNhc2UpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuZmFsc2VDYXNlLCBzdG10LmZhbHNlQ2FzZSk7XG4gICAgfVxuICAgIHZpc2l0U3RhdGVtZW50KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJZlN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgUmVjdXJzaXZlQXN0VmlzaXRvciQxIHtcbiAgICB2aXNpdFR5cGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGFzdC50eXBlKSB7XG4gICAgICAgICAgICBhc3QudHlwZS52aXNpdFR5cGUodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRCdWlsdGluVHlwZSh0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uVHlwZSh0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHR5cGUudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBpZiAodHlwZS50eXBlUGFyYW1zICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0eXBlLnR5cGVQYXJhbXMuZm9yRWFjaChwYXJhbSA9PiB0aGlzLnZpc2l0VHlwZShwYXJhbSwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRBcnJheVR5cGUodHlwZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodHlwZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TWFwVHlwZSh0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0VHlwZSh0eXBlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRXcmFwcGVkTm9kZUV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0VHlwZW9mRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0UmVhZFZhckV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFdyaXRlVmFyRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0V3JpdGVLZXlFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRXcml0ZVByb3BFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRJbnZva2VGdW5jdGlvbkV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5mbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFRhZ2dlZFRlbXBsYXRlRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnRhZy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QudGVtcGxhdGUuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRJbnN0YW50aWF0ZUV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jbGFzc0V4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TG9jYWxpemVkU3RyaW5nKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRFeHRlcm5hbEV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhc3QudHlwZVBhcmFtcykge1xuICAgICAgICAgICAgYXN0LnR5cGVQYXJhbXMuZm9yRWFjaCh0eXBlID0+IHR5cGUudmlzaXRUeXBlKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRDb25kaXRpb25hbEV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QudHJ1ZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QuZmFsc2VDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0Tm90RXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEZ1bmN0aW9uRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoYXN0LnN0YXRlbWVudHMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRVbmFyeU9wZXJhdG9yRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRCaW5hcnlPcGVyYXRvckV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5saHMudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0UmVhZFByb3BFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRSZWFkS2V5RXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5RXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcEV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5lbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiBlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRDb21tYUV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QucGFydHMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRBbGxFeHByZXNzaW9ucyhleHBycywgY29udGV4dCkge1xuICAgICAgICBleHBycy5mb3JFYWNoKGV4cHIgPT4gZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCkpO1xuICAgIH1cbiAgICB2aXNpdERlY2xhcmVWYXJTdG10KHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKHN0bXQudmFsdWUpIHtcbiAgICAgICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG10LnR5cGUpIHtcbiAgICAgICAgICAgIHN0bXQudHlwZS52aXNpdFR5cGUodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuICAgIHZpc2l0RGVjbGFyZUZ1bmN0aW9uU3RtdChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY29udGV4dCk7XG4gICAgICAgIGlmIChzdG10LnR5cGUpIHtcbiAgICAgICAgICAgIHN0bXQudHlwZS52aXNpdFR5cGUodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvblN0bXQoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG4gICAgdmlzaXRSZXR1cm5TdG10KHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH1cbiAgICB2aXNpdElmU3RtdChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC50cnVlQ2FzZSwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuZmFsc2VDYXNlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuICAgIHZpc2l0QWxsU3RhdGVtZW50cyhzdG10cywgY29udGV4dCkge1xuICAgICAgICBzdG10cy5mb3JFYWNoKHN0bXQgPT4gc3RtdC52aXNpdFN0YXRlbWVudCh0aGlzLCBjb250ZXh0KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGVhZGluZ0NvbW1lbnQodGV4dCwgbXVsdGlsaW5lID0gZmFsc2UsIHRyYWlsaW5nTmV3bGluZSA9IHRydWUpIHtcbiAgICByZXR1cm4gbmV3IExlYWRpbmdDb21tZW50KHRleHQsIG11bHRpbGluZSwgdHJhaWxpbmdOZXdsaW5lKTtcbn1cbmZ1bmN0aW9uIGpzRG9jQ29tbWVudCh0YWdzID0gW10pIHtcbiAgICByZXR1cm4gbmV3IEpTRG9jQ29tbWVudCh0YWdzKTtcbn1cbmZ1bmN0aW9uIHZhcmlhYmxlKG5hbWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IFJlYWRWYXJFeHByKG5hbWUsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gaW1wb3J0RXhwcihpZCwgdHlwZVBhcmFtcyA9IG51bGwsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IEV4dGVybmFsRXhwcihpZCwgbnVsbCwgdHlwZVBhcmFtcywgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBpbXBvcnRUeXBlKGlkLCB0eXBlUGFyYW1zLCB0eXBlTW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuIGlkICE9IG51bGwgPyBleHByZXNzaW9uVHlwZShpbXBvcnRFeHByKGlkLCB0eXBlUGFyYW1zLCBudWxsKSwgdHlwZU1vZGlmaWVycykgOiBudWxsO1xufVxuZnVuY3Rpb24gZXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycywgdHlwZVBhcmFtcykge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblR5cGUoZXhwciwgdHlwZU1vZGlmaWVycywgdHlwZVBhcmFtcyk7XG59XG5mdW5jdGlvbiB0eXBlb2ZFeHByKGV4cHIpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVvZkV4cHIoZXhwcik7XG59XG5mdW5jdGlvbiBsaXRlcmFsQXJyKHZhbHVlcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5RXhwcih2YWx1ZXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbE1hcCh2YWx1ZXMsIHR5cGUgPSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwRXhwcih2YWx1ZXMubWFwKGUgPT4gbmV3IExpdGVyYWxNYXBFbnRyeShlLmtleSwgZS52YWx1ZSwgZS5xdW90ZWQpKSwgdHlwZSwgbnVsbCk7XG59XG5mdW5jdGlvbiB1bmFyeShvcGVyYXRvciwgZXhwciwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgVW5hcnlPcGVyYXRvckV4cHIob3BlcmF0b3IsIGV4cHIsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gbm90KGV4cHIsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IE5vdEV4cHIoZXhwciwgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBmbihwYXJhbXMsIGJvZHksIHR5cGUsIHNvdXJjZVNwYW4sIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRXhwcihwYXJhbXMsIGJvZHksIHR5cGUsIHNvdXJjZVNwYW4sIG5hbWUpO1xufVxuZnVuY3Rpb24gaWZTdG10KGNvbmRpdGlvbiwgdGhlbkNsYXVzZSwgZWxzZUNsYXVzZSwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgcmV0dXJuIG5ldyBJZlN0bXQoY29uZGl0aW9uLCB0aGVuQ2xhdXNlLCBlbHNlQ2xhdXNlLCBzb3VyY2VTcGFuLCBsZWFkaW5nQ29tbWVudHMpO1xufVxuZnVuY3Rpb24gdGFnZ2VkVGVtcGxhdGUodGFnLCB0ZW1wbGF0ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgVGFnZ2VkVGVtcGxhdGVFeHByKHRhZywgdGVtcGxhdGUsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbEV4cHIodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gbG9jYWxpemVkU3RyaW5nKG1ldGFCbG9jaywgbWVzc2FnZVBhcnRzLCBwbGFjZWhvbGRlck5hbWVzLCBleHByZXNzaW9ucywgc291cmNlU3Bhbikge1xuICAgIHJldHVybiBuZXcgTG9jYWxpemVkU3RyaW5nKG1ldGFCbG9jaywgbWVzc2FnZVBhcnRzLCBwbGFjZWhvbGRlck5hbWVzLCBleHByZXNzaW9ucywgc291cmNlU3Bhbik7XG59XG5mdW5jdGlvbiBpc051bGwoZXhwKSB7XG4gICAgcmV0dXJuIGV4cCBpbnN0YW5jZW9mIExpdGVyYWxFeHByICYmIGV4cC52YWx1ZSA9PT0gbnVsbDtcbn1cbi8qXG4gKiBTZXJpYWxpemVzIGEgYFRhZ2AgaW50byBhIHN0cmluZy5cbiAqIFJldHVybnMgYSBzdHJpbmcgbGlrZSBcIiBAZm9vIHtiYXJ9IGJhelwiIChub3RlIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2UgYmVmb3JlIGBAZm9vYCkuXG4gKi9cbmZ1bmN0aW9uIHRhZ1RvU3RyaW5nKHRhZykge1xuICAgIGxldCBvdXQgPSAnJztcbiAgICBpZiAodGFnLnRhZ05hbWUpIHtcbiAgICAgICAgb3V0ICs9IGAgQCR7dGFnLnRhZ05hbWV9YDtcbiAgICB9XG4gICAgaWYgKHRhZy50ZXh0KSB7XG4gICAgICAgIGlmICh0YWcudGV4dC5tYXRjaCgvXFwvXFwqfFxcKlxcLy8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTRG9jIHRleHQgY2Fubm90IGNvbnRhaW4gXCIvKlwiIGFuZCBcIiovXCInKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJyAnICsgdGFnLnRleHQucmVwbGFjZSgvQC9nLCAnXFxcXEAnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRhZ3ModGFncykge1xuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMSAmJiB0YWdzWzBdLnRhZ05hbWUgJiYgIXRhZ3NbMF0udGV4dCkge1xuICAgICAgICAvLyBUaGUgSlNET0MgY29tbWVudCBpcyBhIHNpbmdsZSBzaW1wbGUgdGFnOiBlLmcgYC8qKiBAdGFnbmFtZSAqL2AuXG4gICAgICAgIHJldHVybiBgKiR7dGFnVG9TdHJpbmcodGFnc1swXSl9IGA7XG4gICAgfVxuICAgIGxldCBvdXQgPSAnKlxcbic7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgICBvdXQgKz0gJyAqJztcbiAgICAgICAgLy8gSWYgdGhlIHRhZ1RvU3RyaW5nIGlzIG11bHRpLWxpbmUsIGluc2VydCBcIiAqIFwiIHByZWZpeGVzIG9uIGxpbmVzLlxuICAgICAgICBvdXQgKz0gdGFnVG9TdHJpbmcodGFnKS5yZXBsYWNlKC9cXG4vZywgJ1xcbiAqICcpO1xuICAgICAgICBvdXQgKz0gJ1xcbic7XG4gICAgfVxuICAgIG91dCArPSAnICc7XG4gICAgcmV0dXJuIG91dDtcbn1cblxudmFyIG91dHB1dF9hc3QgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdldCBUeXBlTW9kaWZpZXIgKCkgeyByZXR1cm4gZXhwb3J0cy5UeXBlTW9kaWZpZXI7IH0sXG4gICAgVHlwZTogVHlwZSxcbiAgICBnZXQgQnVpbHRpblR5cGVOYW1lICgpIHsgcmV0dXJuIGV4cG9ydHMuQnVpbHRpblR5cGVOYW1lOyB9LFxuICAgIEJ1aWx0aW5UeXBlOiBCdWlsdGluVHlwZSxcbiAgICBFeHByZXNzaW9uVHlwZTogRXhwcmVzc2lvblR5cGUsXG4gICAgQXJyYXlUeXBlOiBBcnJheVR5cGUsXG4gICAgTWFwVHlwZTogTWFwVHlwZSxcbiAgICBEWU5BTUlDX1RZUEU6IERZTkFNSUNfVFlQRSxcbiAgICBJTkZFUlJFRF9UWVBFOiBJTkZFUlJFRF9UWVBFLFxuICAgIEJPT0xfVFlQRTogQk9PTF9UWVBFLFxuICAgIElOVF9UWVBFOiBJTlRfVFlQRSxcbiAgICBOVU1CRVJfVFlQRTogTlVNQkVSX1RZUEUsXG4gICAgU1RSSU5HX1RZUEU6IFNUUklOR19UWVBFLFxuICAgIEZVTkNUSU9OX1RZUEU6IEZVTkNUSU9OX1RZUEUsXG4gICAgTk9ORV9UWVBFOiBOT05FX1RZUEUsXG4gICAgZ2V0IFVuYXJ5T3BlcmF0b3IgKCkgeyByZXR1cm4gZXhwb3J0cy5VbmFyeU9wZXJhdG9yOyB9LFxuICAgIGdldCBCaW5hcnlPcGVyYXRvciAoKSB7IHJldHVybiBleHBvcnRzLkJpbmFyeU9wZXJhdG9yOyB9LFxuICAgIG51bGxTYWZlSXNFcXVpdmFsZW50OiBudWxsU2FmZUlzRXF1aXZhbGVudCxcbiAgICBhcmVBbGxFcXVpdmFsZW50OiBhcmVBbGxFcXVpdmFsZW50LFxuICAgIEV4cHJlc3Npb246IEV4cHJlc3Npb24sXG4gICAgUmVhZFZhckV4cHI6IFJlYWRWYXJFeHByLFxuICAgIFR5cGVvZkV4cHI6IFR5cGVvZkV4cHIsXG4gICAgV3JhcHBlZE5vZGVFeHByOiBXcmFwcGVkTm9kZUV4cHIsXG4gICAgV3JpdGVWYXJFeHByOiBXcml0ZVZhckV4cHIsXG4gICAgV3JpdGVLZXlFeHByOiBXcml0ZUtleUV4cHIsXG4gICAgV3JpdGVQcm9wRXhwcjogV3JpdGVQcm9wRXhwcixcbiAgICBJbnZva2VGdW5jdGlvbkV4cHI6IEludm9rZUZ1bmN0aW9uRXhwcixcbiAgICBUYWdnZWRUZW1wbGF0ZUV4cHI6IFRhZ2dlZFRlbXBsYXRlRXhwcixcbiAgICBJbnN0YW50aWF0ZUV4cHI6IEluc3RhbnRpYXRlRXhwcixcbiAgICBMaXRlcmFsRXhwcjogTGl0ZXJhbEV4cHIsXG4gICAgVGVtcGxhdGVMaXRlcmFsOiBUZW1wbGF0ZUxpdGVyYWwsXG4gICAgVGVtcGxhdGVMaXRlcmFsRWxlbWVudDogVGVtcGxhdGVMaXRlcmFsRWxlbWVudCxcbiAgICBMaXRlcmFsUGllY2U6IExpdGVyYWxQaWVjZSxcbiAgICBQbGFjZWhvbGRlclBpZWNlOiBQbGFjZWhvbGRlclBpZWNlLFxuICAgIExvY2FsaXplZFN0cmluZzogTG9jYWxpemVkU3RyaW5nLFxuICAgIEV4dGVybmFsRXhwcjogRXh0ZXJuYWxFeHByLFxuICAgIEV4dGVybmFsUmVmZXJlbmNlOiBFeHRlcm5hbFJlZmVyZW5jZSxcbiAgICBDb25kaXRpb25hbEV4cHI6IENvbmRpdGlvbmFsRXhwcixcbiAgICBOb3RFeHByOiBOb3RFeHByLFxuICAgIEZuUGFyYW06IEZuUGFyYW0sXG4gICAgRnVuY3Rpb25FeHByOiBGdW5jdGlvbkV4cHIsXG4gICAgVW5hcnlPcGVyYXRvckV4cHI6IFVuYXJ5T3BlcmF0b3JFeHByLFxuICAgIEJpbmFyeU9wZXJhdG9yRXhwcjogQmluYXJ5T3BlcmF0b3JFeHByLFxuICAgIFJlYWRQcm9wRXhwcjogUmVhZFByb3BFeHByLFxuICAgIFJlYWRLZXlFeHByOiBSZWFkS2V5RXhwcixcbiAgICBMaXRlcmFsQXJyYXlFeHByOiBMaXRlcmFsQXJyYXlFeHByLFxuICAgIExpdGVyYWxNYXBFbnRyeTogTGl0ZXJhbE1hcEVudHJ5LFxuICAgIExpdGVyYWxNYXBFeHByOiBMaXRlcmFsTWFwRXhwcixcbiAgICBDb21tYUV4cHI6IENvbW1hRXhwcixcbiAgICBOVUxMX0VYUFI6IE5VTExfRVhQUixcbiAgICBUWVBFRF9OVUxMX0VYUFI6IFRZUEVEX05VTExfRVhQUixcbiAgICBnZXQgU3RtdE1vZGlmaWVyICgpIHsgcmV0dXJuIGV4cG9ydHMuU3RtdE1vZGlmaWVyOyB9LFxuICAgIExlYWRpbmdDb21tZW50OiBMZWFkaW5nQ29tbWVudCxcbiAgICBKU0RvY0NvbW1lbnQ6IEpTRG9jQ29tbWVudCxcbiAgICBTdGF0ZW1lbnQ6IFN0YXRlbWVudCxcbiAgICBEZWNsYXJlVmFyU3RtdDogRGVjbGFyZVZhclN0bXQsXG4gICAgRGVjbGFyZUZ1bmN0aW9uU3RtdDogRGVjbGFyZUZ1bmN0aW9uU3RtdCxcbiAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBFeHByZXNzaW9uU3RhdGVtZW50LFxuICAgIFJldHVyblN0YXRlbWVudDogUmV0dXJuU3RhdGVtZW50LFxuICAgIElmU3RtdDogSWZTdG10LFxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3I6IFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSxcbiAgICBsZWFkaW5nQ29tbWVudDogbGVhZGluZ0NvbW1lbnQsXG4gICAganNEb2NDb21tZW50OiBqc0RvY0NvbW1lbnQsXG4gICAgdmFyaWFibGU6IHZhcmlhYmxlLFxuICAgIGltcG9ydEV4cHI6IGltcG9ydEV4cHIsXG4gICAgaW1wb3J0VHlwZTogaW1wb3J0VHlwZSxcbiAgICBleHByZXNzaW9uVHlwZTogZXhwcmVzc2lvblR5cGUsXG4gICAgdHlwZW9mRXhwcjogdHlwZW9mRXhwcixcbiAgICBsaXRlcmFsQXJyOiBsaXRlcmFsQXJyLFxuICAgIGxpdGVyYWxNYXA6IGxpdGVyYWxNYXAsXG4gICAgdW5hcnk6IHVuYXJ5LFxuICAgIG5vdDogbm90LFxuICAgIGZuOiBmbixcbiAgICBpZlN0bXQ6IGlmU3RtdCxcbiAgICB0YWdnZWRUZW1wbGF0ZTogdGFnZ2VkVGVtcGxhdGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbCxcbiAgICBsb2NhbGl6ZWRTdHJpbmc6IGxvY2FsaXplZFN0cmluZyxcbiAgICBpc051bGw6IGlzTnVsbFxufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgQ09OU1RBTlRfUFJFRklYID0gJ19jJztcbi8qKlxuICogYENvbnN0YW50UG9vbGAgdHJpZXMgdG8gcmV1c2UgbGl0ZXJhbCBmYWN0b3JpZXMgd2hlbiB0d28gb3IgbW9yZSBsaXRlcmFscyBhcmUgaWRlbnRpY2FsLlxuICogV2UgZGV0ZXJtaW5lIHdoZXRoZXIgbGl0ZXJhbHMgYXJlIGlkZW50aWNhbCBieSBjcmVhdGluZyBhIGtleSBvdXQgb2YgdGhlaXIgQVNUIHVzaW5nIHRoZVxuICogYEtleVZpc2l0b3JgLiBUaGlzIGNvbnN0YW50IGlzIHVzZWQgdG8gcmVwbGFjZSBkeW5hbWljIGV4cHJlc3Npb25zIHdoaWNoIGNhbid0IGJlIHNhZmVseVxuICogY29udmVydGVkIGludG8gYSBrZXkuIEUuZy4gZ2l2ZW4gYW4gZXhwcmVzc2lvbiBge2ZvbzogYmFyKCl9YCwgc2luY2Ugd2UgZG9uJ3Qga25vdyB3aGF0XG4gKiB0aGUgcmVzdWx0IG9mIGBiYXJgIHdpbGwgYmUsIHdlIGNyZWF0ZSBhIGtleSB0aGF0IGxvb2tzIGxpa2UgYHtmb286IDx1bmtub3duPn1gLiBOb3RlXG4gKiB0aGF0IHdlIHVzZSBhIHZhcmlhYmxlLCByYXRoZXIgdGhhbiBzb21ldGhpbmcgbGlrZSBgbnVsbGAgaW4gb3JkZXIgdG8gYXZvaWQgY29sbGlzaW9ucy5cbiAqL1xuY29uc3QgVU5LTk9XTl9WQUxVRV9LRVkgPSB2YXJpYWJsZSgnPHVua25vd24+Jyk7XG4vKipcbiAqIENvbnRleHQgdG8gdXNlIHdoZW4gcHJvZHVjaW5nIGEga2V5LlxuICpcbiAqIFRoaXMgZW5zdXJlcyB3ZSBzZWUgdGhlIGNvbnN0YW50IG5vdCB0aGUgcmVmZXJlbmNlIHZhcmlhYmxlIHdoZW4gcHJvZHVjaW5nXG4gKiBhIGtleS5cbiAqL1xuY29uc3QgS0VZX0NPTlRFWFQgPSB7fTtcbi8qKlxuICogR2VuZXJhbGx5IGFsbCBwcmltaXRpdmUgdmFsdWVzIGFyZSBleGNsdWRlZCBmcm9tIHRoZSBgQ29uc3RhbnRQb29sYCwgYnV0IHRoZXJlIGlzIGFuIGV4Y2x1c2lvblxuICogZm9yIHN0cmluZ3MgdGhhdCByZWFjaCBhIGNlcnRhaW4gbGVuZ3RoIHRocmVzaG9sZC4gVGhpcyBjb25zdGFudCBkZWZpbmVzIHRoZSBsZW5ndGggdGhyZXNob2xkIGZvclxuICogc3RyaW5ncy5cbiAqL1xuY29uc3QgUE9PTF9JTkNMVVNJT05fTEVOR1RIX1RIUkVTSE9MRF9GT1JfU1RSSU5HUyA9IDUwO1xuLyoqXG4gKiBBIG5vZGUgdGhhdCBpcyBhIHBsYWNlLWhvbGRlciB0aGF0IGFsbG93cyB0aGUgbm9kZSB0byBiZSByZXBsYWNlZCB3aGVuIHRoZSBhY3R1YWxcbiAqIG5vZGUgaXMga25vd24uXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIGNvbnN0YW50IHBvb2wgdG8gY2hhbmdlIGFuIGV4cHJlc3Npb24gZnJvbSBhIGRpcmVjdCByZWZlcmVuY2UgdG9cbiAqIGEgY29uc3RhbnQgdG8gYSBzaGFyZWQgY29uc3RhbnQuIEl0IHJldHVybnMgYSBmaXgtdXAgbm9kZSB0aGF0IGlzIGxhdGVyIGFsbG93ZWQgdG9cbiAqIGNoYW5nZSB0aGUgcmVmZXJlbmNlZCBleHByZXNzaW9uLlxuICovXG5jbGFzcyBGaXh1cEV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvbHZlZCkge1xuICAgICAgICBzdXBlcihyZXNvbHZlZC50eXBlKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZCA9IHJlc29sdmVkO1xuICAgICAgICB0aGlzLm9yaWdpbmFsID0gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSBLRVlfQ09OVEVYVCkge1xuICAgICAgICAgICAgLy8gV2hlbiBwcm9kdWNpbmcgYSBrZXkgd2Ugd2FudCB0byB0cmF2ZXJzZSB0aGUgY29uc3RhbnQgbm90IHRoZVxuICAgICAgICAgICAgLy8gdmFyaWFibGUgdXNlZCB0byByZWZlciB0byBpdC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsLnZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkLnZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEZpeHVwRXhwcmVzc2lvbiAmJiB0aGlzLnJlc29sdmVkLmlzRXF1aXZhbGVudChlLnJlc29sdmVkKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZpeHVwKGV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuc2hhcmVkID0gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIEEgY29uc3RhbnQgcG9vbCBhbGxvd3MgYSBjb2RlIGVtaXR0ZXIgdG8gc2hhcmUgY29uc3RhbnQgaW4gYW4gb3V0cHV0IGNvbnRleHQuXG4gKlxuICogVGhlIGNvbnN0YW50IHBvb2wgYWxzbyBzdXBwb3J0cyBzaGFyaW5nIGFjY2VzcyB0byBpdnkgZGVmaW5pdGlvbnMgcmVmZXJlbmNlcy5cbiAqL1xuY2xhc3MgQ29uc3RhbnRQb29sIHtcbiAgICBjb25zdHJ1Y3Rvcihpc0Nsb3N1cmVDb21waWxlckVuYWJsZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmlzQ2xvc3VyZUNvbXBpbGVyRW5hYmxlZCA9IGlzQ2xvc3VyZUNvbXBpbGVyRW5hYmxlZDtcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMubGl0ZXJhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGl0ZXJhbEZhY3RvcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uZXh0TmFtZUluZGV4ID0gMDtcbiAgICB9XG4gICAgZ2V0Q29uc3RMaXRlcmFsKGxpdGVyYWwsIGZvcmNlU2hhcmVkKSB7XG4gICAgICAgIGlmICgobGl0ZXJhbCBpbnN0YW5jZW9mIExpdGVyYWxFeHByICYmICFpc0xvbmdTdHJpbmdMaXRlcmFsKGxpdGVyYWwpKSB8fFxuICAgICAgICAgICAgbGl0ZXJhbCBpbnN0YW5jZW9mIEZpeHVwRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgLy8gRG8gbm8gcHV0IHNpbXBsZSBsaXRlcmFscyBpbnRvIHRoZSBjb25zdGFudCBwb29sIG9yIHRyeSB0byBwcm9kdWNlIGEgY29uc3RhbnQgZm9yIGFcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZSB0byBhIGNvbnN0YW50LlxuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlPZihsaXRlcmFsKTtcbiAgICAgICAgbGV0IGZpeHVwID0gdGhpcy5saXRlcmFscy5nZXQoa2V5KTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIGlmICghZml4dXApIHtcbiAgICAgICAgICAgIGZpeHVwID0gbmV3IEZpeHVwRXhwcmVzc2lvbihsaXRlcmFsKTtcbiAgICAgICAgICAgIHRoaXMubGl0ZXJhbHMuc2V0KGtleSwgZml4dXApO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIW5ld1ZhbHVlICYmICFmaXh1cC5zaGFyZWQpIHx8IChuZXdWYWx1ZSAmJiBmb3JjZVNoYXJlZCkpIHtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGV4cHJlc3Npb24gd2l0aCBhIHZhcmlhYmxlXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5mcmVzaE5hbWUoKTtcbiAgICAgICAgICAgIGxldCBkZWZpbml0aW9uO1xuICAgICAgICAgICAgbGV0IHVzYWdlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDbG9zdXJlQ29tcGlsZXJFbmFibGVkICYmIGlzTG9uZ1N0cmluZ0xpdGVyYWwobGl0ZXJhbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igc3RyaW5nIGxpdGVyYWxzLCBDbG9zdXJlIHdpbGwgKiphbHdheXMqKiBpbmxpbmUgdGhlIHN0cmluZyBhdFxuICAgICAgICAgICAgICAgIC8vICoqYWxsKiogdXNhZ2VzLCBkdXBsaWNhdGluZyBpdCBlYWNoIHRpbWUuIEZvciBsYXJnZSBzdHJpbmdzLCB0aGlzXG4gICAgICAgICAgICAgICAgLy8gdW5uZWNlc3NhcmlseSBibG9hdHMgYnVuZGxlIHNpemUuIFRvIHdvcmsgYXJvdW5kIHRoaXMgcmVzdHJpY3Rpb24sIHdlXG4gICAgICAgICAgICAgICAgLy8gd3JhcCB0aGUgc3RyaW5nIGluIGEgZnVuY3Rpb24sIGFuZCBjYWxsIHRoYXQgZnVuY3Rpb24gZm9yIGVhY2ggdXNhZ2UuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0cmlja3MgQ2xvc3VyZSBpbnRvIHVzaW5nIGlubGluZSBsb2dpYyBmb3IgZnVuY3Rpb25zIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcgbGl0ZXJhbHMuIEZ1bmN0aW9uIGNhbGxzIGFyZSBvbmx5IGlubGluZWQgaWYgdGhlIGJvZHkgaXMgc21hbGxcbiAgICAgICAgICAgICAgICAvLyBlbm91Z2ggdG8gYmUgd29ydGggaXQuIEJ5IGRvaW5nIHRoaXMsIHZlcnkgbGFyZ2Ugc3RyaW5ncyB3aWxsIGJlXG4gICAgICAgICAgICAgICAgLy8gc2hhcmVkIGFjcm9zcyBtdWx0aXBsZSB1c2FnZXMsIHJhdGhlciB0aGFuIGR1cGxpY2F0aW5nIHRoZSBzdHJpbmcgYXRcbiAgICAgICAgICAgICAgICAvLyBlYWNoIHVzYWdlIHNpdGUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBjb25zdCBteVN0ciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJ2ZXJ5IHZlcnkgdmVyeSBsb25nIHN0cmluZ1wiOyB9O1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHVzYWdlMSA9IG15U3RyKCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgdXNhZ2UyID0gbXlTdHIoKTtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0gdmFyaWFibGUobmFtZSkuc2V0KG5ldyBGdW5jdGlvbkV4cHIoW10sIC8vIFBhcmFtcy5cbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXRlbWVudHMuXG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbCksXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIHVzYWdlID0gdmFyaWFibGUobmFtZSkuY2FsbEZuKFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgZGVjbGFyZSBhbmQgdXNlIHRoZSB2YXJpYWJsZSBkaXJlY3RseSwgd2l0aG91dCBhIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgICAgICAvLyBpbmRpcmVjdGlvbi4gVGhpcyBzYXZlcyBhIGZldyBieXRlcyBhbmQgYXZvaWRzIGFuIHVubmNlc3NhcnkgY2FsbC5cbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0gdmFyaWFibGUobmFtZSkuc2V0KGxpdGVyYWwpO1xuICAgICAgICAgICAgICAgIHVzYWdlID0gdmFyaWFibGUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudHMucHVzaChkZWZpbml0aW9uLnRvRGVjbFN0bXQoSU5GRVJSRURfVFlQRSwgZXhwb3J0cy5TdG10TW9kaWZpZXIuRmluYWwpKTtcbiAgICAgICAgICAgIGZpeHVwLmZpeHVwKHVzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZml4dXA7XG4gICAgfVxuICAgIGdldExpdGVyYWxGYWN0b3J5KGxpdGVyYWwpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcHVyZSBmdW5jdGlvbiB0aGF0IGJ1aWxkcyBhbiBhcnJheSBvZiBhIG1peCBvZiBjb25zdGFudCBhbmQgdmFyaWFibGUgZXhwcmVzc2lvbnNcbiAgICAgICAgaWYgKGxpdGVyYWwgaW5zdGFuY2VvZiBMaXRlcmFsQXJyYXlFeHByKSB7XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNGb3JLZXkgPSBsaXRlcmFsLmVudHJpZXMubWFwKGUgPT4gZS5pc0NvbnN0YW50KCkgPyBlIDogVU5LTk9XTl9WQUxVRV9LRVkpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlPZihsaXRlcmFsQXJyKGFyZ3VtZW50c0ZvcktleSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldExpdGVyYWxGYWN0b3J5KGtleSwgbGl0ZXJhbC5lbnRyaWVzLCBlbnRyaWVzID0+IGxpdGVyYWxBcnIoZW50cmllcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbkZvcktleSA9IGxpdGVyYWxNYXAobGl0ZXJhbC5lbnRyaWVzLm1hcChlID0+ICh7XG4gICAgICAgICAgICAgICAga2V5OiBlLmtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZS52YWx1ZS5pc0NvbnN0YW50KCkgPyBlLnZhbHVlIDogVU5LTk9XTl9WQUxVRV9LRVksXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBlLnF1b3RlZFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5T2YoZXhwcmVzc2lvbkZvcktleSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGl0ZXJhbEZhY3Rvcnkoa2V5LCBsaXRlcmFsLmVudHJpZXMubWFwKGUgPT4gZS52YWx1ZSksIGVudHJpZXMgPT4gbGl0ZXJhbE1hcChlbnRyaWVzLm1hcCgodmFsdWUsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIGtleTogbGl0ZXJhbC5lbnRyaWVzW2luZGV4XS5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBsaXRlcmFsLmVudHJpZXNbaW5kZXhdLnF1b3RlZFxuICAgICAgICAgICAgfSkpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldExpdGVyYWxGYWN0b3J5KGtleSwgdmFsdWVzLCByZXN1bHRNYXApIHtcbiAgICAgICAgbGV0IGxpdGVyYWxGYWN0b3J5ID0gdGhpcy5saXRlcmFsRmFjdG9yaWVzLmdldChrZXkpO1xuICAgICAgICBjb25zdCBsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cyA9IHZhbHVlcy5maWx0ZXIoKGUgPT4gIWUuaXNDb25zdGFudCgpKSk7XG4gICAgICAgIGlmICghbGl0ZXJhbEZhY3RvcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdEV4cHJlc3Npb25zID0gdmFsdWVzLm1hcCgoZSwgaW5kZXgpID0+IGUuaXNDb25zdGFudCgpID8gdGhpcy5nZXRDb25zdExpdGVyYWwoZSwgdHJ1ZSkgOiB2YXJpYWJsZShgYSR7aW5kZXh9YCkpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJlc3VsdEV4cHJlc3Npb25zLmZpbHRlcihpc1ZhcmlhYmxlKS5tYXAoZSA9PiBuZXcgRm5QYXJhbShlLm5hbWUsIERZTkFNSUNfVFlQRSkpO1xuICAgICAgICAgICAgY29uc3QgcHVyZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSBmbihwYXJhbWV0ZXJzLCBbbmV3IFJldHVyblN0YXRlbWVudChyZXN1bHRNYXAocmVzdWx0RXhwcmVzc2lvbnMpKV0sIElORkVSUkVEX1RZUEUpO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZnJlc2hOYW1lKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudHMucHVzaCh2YXJpYWJsZShuYW1lKVxuICAgICAgICAgICAgICAgIC5zZXQocHVyZUZ1bmN0aW9uRGVjbGFyYXRpb24pXG4gICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoSU5GRVJSRURfVFlQRSwgZXhwb3J0cy5TdG10TW9kaWZpZXIuRmluYWwpKTtcbiAgICAgICAgICAgIGxpdGVyYWxGYWN0b3J5ID0gdmFyaWFibGUobmFtZSk7XG4gICAgICAgICAgICB0aGlzLmxpdGVyYWxGYWN0b3JpZXMuc2V0KGtleSwgbGl0ZXJhbEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpdGVyYWxGYWN0b3J5LCBsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlIGEgdW5pcXVlIG5hbWUuXG4gICAgICpcbiAgICAgKiBUaGUgbmFtZSBtaWdodCBiZSB1bmlxdWUgYW1vbmcgZGlmZmVyZW50IHByZWZpeGVzIGlmIGFueSBvZiB0aGUgcHJlZml4ZXMgZW5kIGluXG4gICAgICogYSBkaWdpdCBzbyB0aGUgcHJlZml4IHNob3VsZCBiZSBhIGNvbnN0YW50IHN0cmluZyAobm90IGJhc2VkIG9uIHVzZXIgaW5wdXQpIGFuZFxuICAgICAqIG11c3Qgbm90IGVuZCBpbiBhIGRpZ2l0LlxuICAgICAqL1xuICAgIHVuaXF1ZU5hbWUocHJlZml4KSB7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHt0aGlzLm5leHROYW1lSW5kZXgrK31gO1xuICAgIH1cbiAgICBmcmVzaE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaXF1ZU5hbWUoQ09OU1RBTlRfUFJFRklYKTtcbiAgICB9XG4gICAga2V5T2YoZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi52aXNpdEV4cHJlc3Npb24obmV3IEtleVZpc2l0b3IoKSwgS0VZX0NPTlRFWFQpO1xuICAgIH1cbn1cbi8qKlxuICogVmlzaXRvciB1c2VkIHRvIGRldGVybWluZSBpZiAyIGV4cHJlc3Npb25zIGFyZSBlcXVpdmFsZW50IGFuZCBjYW4gYmUgc2hhcmVkIGluIHRoZVxuICogYENvbnN0YW50UG9vbGAuXG4gKlxuICogV2hlbiB0aGUgaWQgKHN0cmluZykgZ2VuZXJhdGVkIGJ5IHRoZSB2aXNpdG9yIGlzIGVxdWFsLCBleHByZXNzaW9ucyBhcmUgY29uc2lkZXJlZCBlcXVpdmFsZW50LlxuICovXG5jbGFzcyBLZXlWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52aXNpdFdyYXBwZWROb2RlRXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFdyaXRlVmFyRXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFdyaXRlS2V5RXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFdyaXRlUHJvcEV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRUYWdnZWRUZW1wbGF0ZUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRJbnN0YW50aWF0ZUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRDb25kaXRpb25hbEV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXROb3RFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0QXNzZXJ0Tm90TnVsbEV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRDYXN0RXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uRXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFVuYXJ5T3BlcmF0b3JFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0UmVhZFByb3BFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0UmVhZEtleUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRDb21tYUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRMb2NhbGl6ZWRTdHJpbmcgPSBpbnZhbGlkJDE7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEV4cHIoYXN0KSB7XG4gICAgICAgIHJldHVybiBgJHt0eXBlb2YgYXN0LnZhbHVlID09PSAnc3RyaW5nJyA/ICdcIicgKyBhc3QudmFsdWUgKyAnXCInIDogYXN0LnZhbHVlfWA7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5RXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGBbJHthc3QuZW50cmllcy5tYXAoZW50cnkgPT4gZW50cnkudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKS5qb2luKCcsJyl9XWA7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcEV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG1hcEtleSA9IChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcXVvdGUgPSBlbnRyeS5xdW90ZWQgPyAnXCInIDogJyc7XG4gICAgICAgICAgICByZXR1cm4gYCR7cXVvdGV9JHtlbnRyeS5rZXl9JHtxdW90ZX1gO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXBFbnRyeSA9IChlbnRyeSkgPT4gYCR7bWFwS2V5KGVudHJ5KX06JHtlbnRyeS52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCl9YDtcbiAgICAgICAgcmV0dXJuIGB7JHthc3QuZW50cmllcy5tYXAobWFwRW50cnkpLmpvaW4oJywnKX1gO1xuICAgIH1cbiAgICB2aXNpdEV4dGVybmFsRXhwcihhc3QpIHtcbiAgICAgICAgcmV0dXJuIGFzdC52YWx1ZS5tb2R1bGVOYW1lID8gYEVYOiR7YXN0LnZhbHVlLm1vZHVsZU5hbWV9OiR7YXN0LnZhbHVlLm5hbWV9YCA6XG4gICAgICAgICAgICBgRVg6JHthc3QudmFsdWUucnVudGltZS5uYW1lfWA7XG4gICAgfVxuICAgIHZpc2l0UmVhZFZhckV4cHIobm9kZSkge1xuICAgICAgICByZXR1cm4gYFZBUjoke25vZGUubmFtZX1gO1xuICAgIH1cbiAgICB2aXNpdFR5cGVvZkV4cHIobm9kZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYFRZUEVPRjoke25vZGUuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCl9YDtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnZhbGlkJDEoYXJnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlOiBWaXNpdG9yICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBkb2Vzbid0IGhhbmRsZSAke2FyZy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xufVxuZnVuY3Rpb24gaXNWYXJpYWJsZShlKSB7XG4gICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBSZWFkVmFyRXhwcjtcbn1cbmZ1bmN0aW9uIGlzTG9uZ1N0cmluZ0xpdGVyYWwoZXhwcikge1xuICAgIHJldHVybiBleHByIGluc3RhbmNlb2YgTGl0ZXJhbEV4cHIgJiYgdHlwZW9mIGV4cHIudmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGV4cHIudmFsdWUubGVuZ3RoID49IFBPT0xfSU5DTFVTSU9OX0xFTkdUSF9USFJFU0hPTERfRk9SX1NUUklOR1M7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgQ09SRSA9ICdAYW5ndWxhci9jb3JlJztcbmNsYXNzIElkZW50aWZpZXJzIHtcbn1cbi8qIE1ldGhvZHMgKi9cbklkZW50aWZpZXJzLk5FV19NRVRIT0QgPSAnZmFjdG9yeSc7XG5JZGVudGlmaWVycy5UUkFOU0ZPUk1fTUVUSE9EID0gJ3RyYW5zZm9ybSc7XG5JZGVudGlmaWVycy5QQVRDSF9ERVBTID0gJ3BhdGNoZWREZXBzJztcbklkZW50aWZpZXJzLmNvcmUgPSB7IG5hbWU6IG51bGwsIG1vZHVsZU5hbWU6IENPUkUgfTtcbi8qIEluc3RydWN0aW9ucyAqL1xuSWRlbnRpZmllcnMubmFtZXNwYWNlSFRNTCA9IHsgbmFtZTogJ8m1ybVuYW1lc3BhY2VIVE1MJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMubmFtZXNwYWNlTWF0aE1MID0geyBuYW1lOiAnybXJtW5hbWVzcGFjZU1hdGhNTCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLm5hbWVzcGFjZVNWRyA9IHsgbmFtZTogJ8m1ybVuYW1lc3BhY2VTVkcnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5lbGVtZW50ID0geyBuYW1lOiAnybXJtWVsZW1lbnQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5lbGVtZW50U3RhcnQgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudFN0YXJ0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZWxlbWVudEVuZCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50RW5kJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuYWR2YW5jZSA9IHsgbmFtZTogJ8m1ybVhZHZhbmNlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3ludGhldGljSG9zdFByb3BlcnR5ID0geyBuYW1lOiAnybXJtXN5bnRoZXRpY0hvc3RQcm9wZXJ0eScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN5bnRoZXRpY0hvc3RMaXN0ZW5lciA9IHsgbmFtZTogJ8m1ybVzeW50aGV0aWNIb3N0TGlzdGVuZXInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5hdHRyaWJ1dGUgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUxID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTMgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU0ID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTYgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU3ID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTgnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZVYgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuY2xhc3NQcm9wID0geyBuYW1lOiAnybXJtWNsYXNzUHJvcCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmVsZW1lbnRDb250YWluZXJTdGFydCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50Q29udGFpbmVyU3RhcnQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5lbGVtZW50Q29udGFpbmVyRW5kID0geyBuYW1lOiAnybXJtWVsZW1lbnRDb250YWluZXJFbmQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5lbGVtZW50Q29udGFpbmVyID0geyBuYW1lOiAnybXJtWVsZW1lbnRDb250YWluZXInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZU1hcCA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGUxID0geyBuYW1lOiAnybXJtXN0eWxlTWFwSW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTIgPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXBJbnRlcnBvbGF0ZTInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGU0ID0geyBuYW1lOiAnybXJtXN0eWxlTWFwSW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTUgPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXBJbnRlcnBvbGF0ZTUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGU3ID0geyBuYW1lOiAnybXJtXN0eWxlTWFwSW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTggPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXBJbnRlcnBvbGF0ZTgnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmNsYXNzTWFwID0geyBuYW1lOiAnybXJtWNsYXNzTWFwJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTEgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTEnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGUzID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTQgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU2ID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTcgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTcnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGVWID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVQcm9wID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTEnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTIgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGUyJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGUzID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTUgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGU1JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU2ID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTcnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTggPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGU4JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGVWID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLm5leHRDb250ZXh0ID0geyBuYW1lOiAnybXJtW5leHRDb250ZXh0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucmVzZXRWaWV3ID0geyBuYW1lOiAnybXJtXJlc2V0VmlldycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnRlbXBsYXRlQ3JlYXRlID0geyBuYW1lOiAnybXJtXRlbXBsYXRlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dCA9IHsgbmFtZTogJ8m1ybV0ZXh0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZW5hYmxlQmluZGluZ3MgPSB7IG5hbWU6ICfJtcm1ZW5hYmxlQmluZGluZ3MnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5kaXNhYmxlQmluZGluZ3MgPSB7IG5hbWU6ICfJtcm1ZGlzYWJsZUJpbmRpbmdzJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZ2V0Q3VycmVudFZpZXcgPSB7IG5hbWU6ICfJtcm1Z2V0Q3VycmVudFZpZXcnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGUgPSB7IG5hbWU6ICfJtcm1dGV4dEludGVycG9sYXRlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGUyJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU1JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGU4JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucmVzdG9yZVZpZXcgPSB7IG5hbWU6ICfJtcm1cmVzdG9yZVZpZXcnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb24wID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjAnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb24xID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjEnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb24yID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb24zID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjMnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb240ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb241ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb242ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb243ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjcnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb244ID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvbjgnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wdXJlRnVuY3Rpb25WID0geyBuYW1lOiAnybXJtXB1cmVGdW5jdGlvblYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5waXBlQmluZDEgPSB7IG5hbWU6ICfJtcm1cGlwZUJpbmQxJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucGlwZUJpbmQyID0geyBuYW1lOiAnybXJtXBpcGVCaW5kMicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnBpcGVCaW5kMyA9IHsgbmFtZTogJ8m1ybVwaXBlQmluZDMnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5waXBlQmluZDQgPSB7IG5hbWU6ICfJtcm1cGlwZUJpbmQ0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucGlwZUJpbmRWID0geyBuYW1lOiAnybXJtXBpcGVCaW5kVicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmhvc3RQcm9wZXJ0eSA9IHsgbmFtZTogJ8m1ybVob3N0UHJvcGVydHknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wcm9wZXJ0eSA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUxID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTIgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlMycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU0ID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTUgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlNicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU3ID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTggPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTgnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlVicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmkxOG4gPSB7IG5hbWU6ICfJtcm1aTE4bicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmkxOG5BdHRyaWJ1dGVzID0geyBuYW1lOiAnybXJtWkxOG5BdHRyaWJ1dGVzJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaTE4bkV4cCA9IHsgbmFtZTogJ8m1ybVpMThuRXhwJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaTE4blN0YXJ0ID0geyBuYW1lOiAnybXJtWkxOG5TdGFydCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmkxOG5FbmQgPSB7IG5hbWU6ICfJtcm1aTE4bkVuZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmkxOG5BcHBseSA9IHsgbmFtZTogJ8m1ybVpMThuQXBwbHknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5pMThuUG9zdHByb2Nlc3MgPSB7IG5hbWU6ICfJtcm1aTE4blBvc3Rwcm9jZXNzJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucGlwZSA9IHsgbmFtZTogJ8m1ybVwaXBlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucHJvamVjdGlvbiA9IHsgbmFtZTogJ8m1ybVwcm9qZWN0aW9uJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucHJvamVjdGlvbkRlZiA9IHsgbmFtZTogJ8m1ybVwcm9qZWN0aW9uRGVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucmVmZXJlbmNlID0geyBuYW1lOiAnybXJtXJlZmVyZW5jZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmluamVjdCA9IHsgbmFtZTogJ8m1ybVpbmplY3QnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5pbmplY3RBdHRyaWJ1dGUgPSB7IG5hbWU6ICfJtcm1aW5qZWN0QXR0cmlidXRlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZGlyZWN0aXZlSW5qZWN0ID0geyBuYW1lOiAnybXJtWRpcmVjdGl2ZUluamVjdCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmludmFsaWRGYWN0b3J5ID0geyBuYW1lOiAnybXJtWludmFsaWRGYWN0b3J5JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaW52YWxpZEZhY3RvcnlEZXAgPSB7IG5hbWU6ICfJtcm1aW52YWxpZEZhY3RvcnlEZXAnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZW1wbGF0ZVJlZkV4dHJhY3RvciA9IHsgbmFtZTogJ8m1ybV0ZW1wbGF0ZVJlZkV4dHJhY3RvcicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmZvcndhcmRSZWYgPSB7IG5hbWU6ICdmb3J3YXJkUmVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucmVzb2x2ZUZvcndhcmRSZWYgPSB7IG5hbWU6ICdyZXNvbHZlRm9yd2FyZFJlZicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLsm1ybVkZWZpbmVJbmplY3RhYmxlID0geyBuYW1lOiAnybXJtWRlZmluZUluamVjdGFibGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5kZWNsYXJlSW5qZWN0YWJsZSA9IHsgbmFtZTogJ8m1ybVuZ0RlY2xhcmVJbmplY3RhYmxlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuSW5qZWN0YWJsZURlY2xhcmF0aW9uID0geyBuYW1lOiAnybXJtUluamVjdGFibGVEZWNsYXJhdGlvbicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnJlc29sdmVXaW5kb3cgPSB7IG5hbWU6ICfJtcm1cmVzb2x2ZVdpbmRvdycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnJlc29sdmVEb2N1bWVudCA9IHsgbmFtZTogJ8m1ybVyZXNvbHZlRG9jdW1lbnQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5yZXNvbHZlQm9keSA9IHsgbmFtZTogJ8m1ybVyZXNvbHZlQm9keScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRlZmluZUNvbXBvbmVudCA9IHsgbmFtZTogJ8m1ybVkZWZpbmVDb21wb25lbnQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5kZWNsYXJlQ29tcG9uZW50ID0geyBuYW1lOiAnybXJtW5nRGVjbGFyZUNvbXBvbmVudCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnNldENvbXBvbmVudFNjb3BlID0geyBuYW1lOiAnybXJtXNldENvbXBvbmVudFNjb3BlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgPSB7XG4gICAgbmFtZTogJ0NoYW5nZURldGVjdGlvblN0cmF0ZWd5JyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxufTtcbklkZW50aWZpZXJzLlZpZXdFbmNhcHN1bGF0aW9uID0ge1xuICAgIG5hbWU6ICdWaWV3RW5jYXBzdWxhdGlvbicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5Db21wb25lbnREZWNsYXJhdGlvbiA9IHtcbiAgICBuYW1lOiAnybXJtUNvbXBvbmVudERlY2xhcmF0aW9uJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxufTtcbklkZW50aWZpZXJzLkZhY3RvcnlEZWNsYXJhdGlvbiA9IHtcbiAgICBuYW1lOiAnybXJtUZhY3RvcnlEZWNsYXJhdGlvbicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5kZWNsYXJlRmFjdG9yeSA9IHsgbmFtZTogJ8m1ybVuZ0RlY2xhcmVGYWN0b3J5JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuRmFjdG9yeVRhcmdldCA9IHsgbmFtZTogJ8m1ybVGYWN0b3J5VGFyZ2V0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZGVmaW5lRGlyZWN0aXZlID0geyBuYW1lOiAnybXJtWRlZmluZURpcmVjdGl2ZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRlY2xhcmVEaXJlY3RpdmUgPSB7IG5hbWU6ICfJtcm1bmdEZWNsYXJlRGlyZWN0aXZlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuRGlyZWN0aXZlRGVjbGFyYXRpb24gPSB7XG4gICAgbmFtZTogJ8m1ybVEaXJlY3RpdmVEZWNsYXJhdGlvbicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5JbmplY3RvckRlZiA9IHsgbmFtZTogJ8m1ybVJbmplY3RvckRlZicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLkluamVjdG9yRGVjbGFyYXRpb24gPSB7IG5hbWU6ICfJtcm1SW5qZWN0b3JEZWNsYXJhdGlvbicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRlZmluZUluamVjdG9yID0geyBuYW1lOiAnybXJtWRlZmluZUluamVjdG9yJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZGVjbGFyZUluamVjdG9yID0geyBuYW1lOiAnybXJtW5nRGVjbGFyZUluamVjdG9yJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuTmdNb2R1bGVEZWNsYXJhdGlvbiA9IHtcbiAgICBuYW1lOiAnybXJtU5nTW9kdWxlRGVjbGFyYXRpb24nLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuSWRlbnRpZmllcnMuTW9kdWxlV2l0aFByb3ZpZGVycyA9IHtcbiAgICBuYW1lOiAnTW9kdWxlV2l0aFByb3ZpZGVycycsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5kZWZpbmVOZ01vZHVsZSA9IHsgbmFtZTogJ8m1ybVkZWZpbmVOZ01vZHVsZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRlY2xhcmVOZ01vZHVsZSA9IHsgbmFtZTogJ8m1ybVuZ0RlY2xhcmVOZ01vZHVsZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnNldE5nTW9kdWxlU2NvcGUgPSB7IG5hbWU6ICfJtcm1c2V0TmdNb2R1bGVTY29wZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnJlZ2lzdGVyTmdNb2R1bGVUeXBlID0geyBuYW1lOiAnybXJtXJlZ2lzdGVyTmdNb2R1bGVUeXBlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuUGlwZURlY2xhcmF0aW9uID0geyBuYW1lOiAnybXJtVBpcGVEZWNsYXJhdGlvbicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRlZmluZVBpcGUgPSB7IG5hbWU6ICfJtcm1ZGVmaW5lUGlwZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRlY2xhcmVQaXBlID0geyBuYW1lOiAnybXJtW5nRGVjbGFyZVBpcGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5kZWNsYXJlQ2xhc3NNZXRhZGF0YSA9IHsgbmFtZTogJ8m1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc2V0Q2xhc3NNZXRhZGF0YSA9IHsgbmFtZTogJ8m1c2V0Q2xhc3NNZXRhZGF0YScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnF1ZXJ5UmVmcmVzaCA9IHsgbmFtZTogJ8m1ybVxdWVyeVJlZnJlc2gnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy52aWV3UXVlcnkgPSB7IG5hbWU6ICfJtcm1dmlld1F1ZXJ5JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMubG9hZFF1ZXJ5ID0geyBuYW1lOiAnybXJtWxvYWRRdWVyeScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmNvbnRlbnRRdWVyeSA9IHsgbmFtZTogJ8m1ybVjb250ZW50UXVlcnknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5OZ09uQ2hhbmdlc0ZlYXR1cmUgPSB7IG5hbWU6ICfJtcm1TmdPbkNoYW5nZXNGZWF0dXJlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuSW5oZXJpdERlZmluaXRpb25GZWF0dXJlID0geyBuYW1lOiAnybXJtUluaGVyaXREZWZpbml0aW9uRmVhdHVyZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLkNvcHlEZWZpbml0aW9uRmVhdHVyZSA9IHsgbmFtZTogJ8m1ybVDb3B5RGVmaW5pdGlvbkZlYXR1cmUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5TdGFuZGFsb25lRmVhdHVyZSA9IHsgbmFtZTogJ8m1ybVTdGFuZGFsb25lRmVhdHVyZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLlByb3ZpZGVyc0ZlYXR1cmUgPSB7IG5hbWU6ICfJtcm1UHJvdmlkZXJzRmVhdHVyZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmxpc3RlbmVyID0geyBuYW1lOiAnybXJtWxpc3RlbmVyJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZ2V0SW5oZXJpdGVkRmFjdG9yeSA9IHtcbiAgICBuYW1lOiAnybXJtWdldEluaGVyaXRlZEZhY3RvcnknLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuLy8gc2FuaXRpemF0aW9uLXJlbGF0ZWQgZnVuY3Rpb25zXG5JZGVudGlmaWVycy5zYW5pdGl6ZUh0bWwgPSB7IG5hbWU6ICfJtcm1c2FuaXRpemVIdG1sJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc2FuaXRpemVTdHlsZSA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVN0eWxlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc2FuaXRpemVSZXNvdXJjZVVybCA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVJlc291cmNlVXJsJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc2FuaXRpemVTY3JpcHQgPSB7IG5hbWU6ICfJtcm1c2FuaXRpemVTY3JpcHQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zYW5pdGl6ZVVybCA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVVybCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnNhbml0aXplVXJsT3JSZXNvdXJjZVVybCA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVVybE9yUmVzb3VyY2VVcmwnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50cnVzdENvbnN0YW50SHRtbCA9IHsgbmFtZTogJ8m1ybV0cnVzdENvbnN0YW50SHRtbCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnRydXN0Q29uc3RhbnRSZXNvdXJjZVVybCA9IHsgbmFtZTogJ8m1ybV0cnVzdENvbnN0YW50UmVzb3VyY2VVcmwnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0XG5jb25zdCBWRVJTSU9OJDEgPSAzO1xuY29uc3QgSlNfQjY0X1BSRUZJWCA9ICcjIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnO1xuY2xhc3MgU291cmNlTWFwR2VuZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihmaWxlID0gbnVsbCkge1xuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICAgIHRoaXMubGFzdENvbDAgPSAwO1xuICAgICAgICB0aGlzLmhhc01hcHBpbmdzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoZSBjb250ZW50IGlzIGBudWxsYCB3aGVuIHRoZSBjb250ZW50IGlzIGV4cGVjdGVkIHRvIGJlIGxvYWRlZCB1c2luZyB0aGUgVVJMXG4gICAgYWRkU291cmNlKHVybCwgY29udGVudCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50Lmhhcyh1cmwpKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXNDb250ZW50LnNldCh1cmwsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRMaW5lKCkge1xuICAgICAgICB0aGlzLmxpbmVzLnB1c2goW10pO1xuICAgICAgICB0aGlzLmxhc3RDb2wwID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZE1hcHBpbmcoY29sMCwgc291cmNlVXJsLCBzb3VyY2VMaW5lMCwgc291cmNlQ29sMCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudExpbmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBsaW5lIG11c3QgYmUgYWRkZWQgYmVmb3JlIG1hcHBpbmdzIGNhbiBiZSBhZGRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VVcmwgIT0gbnVsbCAmJiAhdGhpcy5zb3VyY2VzQ29udGVudC5oYXMoc291cmNlVXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNvdXJjZSBmaWxlIFwiJHtzb3VyY2VVcmx9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sMCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjb2x1bW4gaW4gdGhlIGdlbmVyYXRlZCBjb2RlIG11c3QgYmUgcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sMCA8IHRoaXMubGFzdENvbDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFwcGluZyBzaG91bGQgYmUgYWRkZWQgaW4gb3V0cHV0IG9yZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVVybCAmJiAoc291cmNlTGluZTAgPT0gbnVsbCB8fCBzb3VyY2VDb2wwID09IG51bGwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzb3VyY2UgbG9jYXRpb24gbXVzdCBiZSBwcm92aWRlZCB3aGVuIGEgc291cmNlIHVybCBpcyBwcm92aWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhc3RDb2wwID0gY29sMDtcbiAgICAgICAgdGhpcy5jdXJyZW50TGluZS5wdXNoKHsgY29sMCwgc291cmNlVXJsLCBzb3VyY2VMaW5lMCwgc291cmNlQ29sMCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbCBzdHJpcCB0aGlzIGZyb20gcHVibGlzaGVkIGQudHMgZmlsZXMgZHVlIHRvXG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zNjIxNlxuICAgICAqL1xuICAgIGdldCBjdXJyZW50TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXMuc2xpY2UoLTEpWzBdO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNNYXBwaW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlc0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgICAgIGNvbnN0IHNvdXJjZXNDb250ZW50ID0gW107XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5zb3VyY2VzQ29udGVudC5rZXlzKCkpLmZvckVhY2goKHVybCwgaSkgPT4ge1xuICAgICAgICAgICAgc291cmNlc0luZGV4LnNldCh1cmwsIGkpO1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHVybCk7XG4gICAgICAgICAgICBzb3VyY2VzQ29udGVudC5wdXNoKHRoaXMuc291cmNlc0NvbnRlbnQuZ2V0KHVybCkgfHwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbWFwcGluZ3MgPSAnJztcbiAgICAgICAgbGV0IGxhc3RDb2wwID0gMDtcbiAgICAgICAgbGV0IGxhc3RTb3VyY2VJbmRleCA9IDA7XG4gICAgICAgIGxldCBsYXN0U291cmNlTGluZTAgPSAwO1xuICAgICAgICBsZXQgbGFzdFNvdXJjZUNvbDAgPSAwO1xuICAgICAgICB0aGlzLmxpbmVzLmZvckVhY2goc2VnbWVudHMgPT4ge1xuICAgICAgICAgICAgbGFzdENvbDAgPSAwO1xuICAgICAgICAgICAgbWFwcGluZ3MgKz0gc2VnbWVudHNcbiAgICAgICAgICAgICAgICAubWFwKHNlZ21lbnQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHplcm8tYmFzZWQgc3RhcnRpbmcgY29sdW1uIG9mIHRoZSBsaW5lIGluIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgICAgICAgICAgIGxldCBzZWdBc1N0ciA9IHRvQmFzZTY0VkxRKHNlZ21lbnQuY29sMCAtIGxhc3RDb2wwKTtcbiAgICAgICAgICAgICAgICBsYXN0Q29sMCA9IHNlZ21lbnQuY29sMDtcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5zb3VyY2VVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB6ZXJvLWJhc2VkIGluZGV4IGludG8gdGhlIOKAnHNvdXJjZXPigJ0gbGlzdFxuICAgICAgICAgICAgICAgICAgICBzZWdBc1N0ciArPVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9CYXNlNjRWTFEoc291cmNlc0luZGV4LmdldChzZWdtZW50LnNvdXJjZVVybCkgLSBsYXN0U291cmNlSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U291cmNlSW5kZXggPSBzb3VyY2VzSW5kZXguZ2V0KHNlZ21lbnQuc291cmNlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHplcm8tYmFzZWQgc3RhcnRpbmcgbGluZSBpbiB0aGUgb3JpZ2luYWwgc291cmNlXG4gICAgICAgICAgICAgICAgICAgIHNlZ0FzU3RyICs9IHRvQmFzZTY0VkxRKHNlZ21lbnQuc291cmNlTGluZTAgLSBsYXN0U291cmNlTGluZTApO1xuICAgICAgICAgICAgICAgICAgICBsYXN0U291cmNlTGluZTAgPSBzZWdtZW50LnNvdXJjZUxpbmUwO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgemVyby1iYXNlZCBzdGFydGluZyBjb2x1bW4gaW4gdGhlIG9yaWdpbmFsIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICBzZWdBc1N0ciArPSB0b0Jhc2U2NFZMUShzZWdtZW50LnNvdXJjZUNvbDAgLSBsYXN0U291cmNlQ29sMCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VDb2wwID0gc2VnbWVudC5zb3VyY2VDb2wwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VnQXNTdHI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgICAgICAgICBtYXBwaW5ncyArPSAnOyc7XG4gICAgICAgIH0pO1xuICAgICAgICBtYXBwaW5ncyA9IG1hcHBpbmdzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdmaWxlJzogdGhpcy5maWxlIHx8ICcnLFxuICAgICAgICAgICAgJ3ZlcnNpb24nOiBWRVJTSU9OJDEsXG4gICAgICAgICAgICAnc291cmNlUm9vdCc6ICcnLFxuICAgICAgICAgICAgJ3NvdXJjZXMnOiBzb3VyY2VzLFxuICAgICAgICAgICAgJ3NvdXJjZXNDb250ZW50Jzogc291cmNlc0NvbnRlbnQsXG4gICAgICAgICAgICAnbWFwcGluZ3MnOiBtYXBwaW5ncyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9Kc0NvbW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc01hcHBpbmdzID8gJy8vJyArIEpTX0I2NF9QUkVGSVggKyB0b0Jhc2U2NFN0cmluZyhKU09OLnN0cmluZ2lmeSh0aGlzLCBudWxsLCAwKSkgOlxuICAgICAgICAgICAgJyc7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9CYXNlNjRTdHJpbmcodmFsdWUpIHtcbiAgICBsZXQgYjY0ID0gJyc7XG4gICAgY29uc3QgZW5jb2RlZCA9IHV0ZjhFbmNvZGUodmFsdWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7KSB7XG4gICAgICAgIGNvbnN0IGkxID0gZW5jb2RlZFtpKytdO1xuICAgICAgICBjb25zdCBpMiA9IGkgPCBlbmNvZGVkLmxlbmd0aCA/IGVuY29kZWRbaSsrXSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGkzID0gaSA8IGVuY29kZWQubGVuZ3RoID8gZW5jb2RlZFtpKytdIDogbnVsbDtcbiAgICAgICAgYjY0ICs9IHRvQmFzZTY0RGlnaXQoaTEgPj4gMik7XG4gICAgICAgIGI2NCArPSB0b0Jhc2U2NERpZ2l0KCgoaTEgJiAzKSA8PCA0KSB8IChpMiA9PT0gbnVsbCA/IDAgOiBpMiA+PiA0KSk7XG4gICAgICAgIGI2NCArPSBpMiA9PT0gbnVsbCA/ICc9JyA6IHRvQmFzZTY0RGlnaXQoKChpMiAmIDE1KSA8PCAyKSB8IChpMyA9PT0gbnVsbCA/IDAgOiBpMyA+PiA2KSk7XG4gICAgICAgIGI2NCArPSBpMiA9PT0gbnVsbCB8fCBpMyA9PT0gbnVsbCA/ICc9JyA6IHRvQmFzZTY0RGlnaXQoaTMgJiA2Myk7XG4gICAgfVxuICAgIHJldHVybiBiNjQ7XG59XG5mdW5jdGlvbiB0b0Jhc2U2NFZMUSh2YWx1ZSkge1xuICAgIHZhbHVlID0gdmFsdWUgPCAwID8gKCgtdmFsdWUpIDw8IDEpICsgMSA6IHZhbHVlIDw8IDE7XG4gICAgbGV0IG91dCA9ICcnO1xuICAgIGRvIHtcbiAgICAgICAgbGV0IGRpZ2l0ID0gdmFsdWUgJiAzMTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiA1O1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICBkaWdpdCA9IGRpZ2l0IHwgMzI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IHRvQmFzZTY0RGlnaXQoZGlnaXQpO1xuICAgIH0gd2hpbGUgKHZhbHVlID4gMCk7XG4gICAgcmV0dXJuIG91dDtcbn1cbmNvbnN0IEI2NF9ESUdJVFMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5mdW5jdGlvbiB0b0Jhc2U2NERpZ2l0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBvbmx5IGVuY29kZSB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsIDYzXWApO1xuICAgIH1cbiAgICByZXR1cm4gQjY0X0RJR0lUU1t2YWx1ZV07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgX1NJTkdMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFID0gLyd8XFxcXHxcXG58XFxyfFxcJC9nO1xuY29uc3QgX0xFR0FMX0lERU5USUZJRVJfUkUgPSAvXlskQS1aX11bMC05QS1aXyRdKiQvaTtcbmNvbnN0IF9JTkRFTlRfV0lUSCA9ICcgICc7XG5jbGFzcyBfRW1pdHRlZExpbmUge1xuICAgIGNvbnN0cnVjdG9yKGluZGVudCkge1xuICAgICAgICB0aGlzLmluZGVudCA9IGluZGVudDtcbiAgICAgICAgdGhpcy5wYXJ0c0xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5zcmNTcGFucyA9IFtdO1xuICAgIH1cbn1cbmNsYXNzIEVtaXR0ZXJWaXNpdG9yQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoX2luZGVudCkge1xuICAgICAgICB0aGlzLl9pbmRlbnQgPSBfaW5kZW50O1xuICAgICAgICB0aGlzLl9saW5lcyA9IFtuZXcgX0VtaXR0ZWRMaW5lKF9pbmRlbnQpXTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1pdHRlclZpc2l0b3JDb250ZXh0KDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgc3RyaXAgdGhpcyBmcm9tIHB1Ymxpc2hlZCBkLnRzIGZpbGVzIGR1ZSB0b1xuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzYyMTZcbiAgICAgKi9cbiAgICBnZXQgX2N1cnJlbnRMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHByaW50bG4oZnJvbSwgbGFzdFBhcnQgPSAnJykge1xuICAgICAgICB0aGlzLnByaW50KGZyb20gfHwgbnVsbCwgbGFzdFBhcnQsIHRydWUpO1xuICAgIH1cbiAgICBsaW5lSXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgbGluZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCAqIF9JTkRFTlRfV0lUSC5sZW5ndGggKyB0aGlzLl9jdXJyZW50TGluZS5wYXJ0c0xlbmd0aDtcbiAgICB9XG4gICAgcHJpbnQoZnJvbSwgcGFydCwgbmV3TGluZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5wYXJ0c0xlbmd0aCArPSBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnNyY1NwYW5zLnB1c2goZnJvbSAmJiBmcm9tLnNvdXJjZVNwYW4gfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0xpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3IF9FbWl0dGVkTGluZSh0aGlzLl9pbmRlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVFbXB0eUxhc3RMaW5lKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lSXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmNJbmRlbnQoKSB7XG4gICAgICAgIHRoaXMuX2luZGVudCsrO1xuICAgICAgICBpZiAodGhpcy5saW5lSXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjSW5kZW50KCkge1xuICAgICAgICB0aGlzLl9pbmRlbnQtLTtcbiAgICAgICAgaWYgKHRoaXMubGluZUlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUuaW5kZW50ID0gdGhpcy5faW5kZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VMaW5lc1xuICAgICAgICAgICAgLm1hcChsID0+IGwucGFydHMubGVuZ3RoID4gMCA/IF9jcmVhdGVJbmRlbnQobC5pbmRlbnQpICsgbC5wYXJ0cy5qb2luKCcnKSA6ICcnKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICB0b1NvdXJjZU1hcEdlbmVyYXRvcihnZW5GaWxlUGF0aCwgc3RhcnRzQXRMaW5lID0gMCkge1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGdlbkZpbGVQYXRoKTtcbiAgICAgICAgbGV0IGZpcnN0T2Zmc2V0TWFwcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0T2Zmc2V0TWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgc2luZ2xlIHNwYWNlIHNvIHRoYXQgdG9vbHMgd29uJ3QgdHJ5IHRvIGxvYWQgdGhlIGZpbGUgZnJvbSBkaXNrLlxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGFyZSB1c2luZyB2aXJ0dWFsIHVybHMgbGlrZSBgbmc6Ly8vYCwgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgYSBjb250ZW50IGhlcmUuXG4gICAgICAgICAgICAgICAgbWFwLmFkZFNvdXJjZShnZW5GaWxlUGF0aCwgJyAnKS5hZGRNYXBwaW5nKDAsIGdlbkZpbGVQYXRoLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBmaXJzdE9mZnNldE1hcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnRzQXRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIG1hcC5hZGRMaW5lKCk7XG4gICAgICAgICAgICBtYXBGaXJzdE9mZnNldElmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2VMaW5lcy5mb3JFYWNoKChsaW5lLCBsaW5lSWR4KSA9PiB7XG4gICAgICAgICAgICBtYXAuYWRkTGluZSgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBsaW5lLnNyY1NwYW5zO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnBhcnRzO1xuICAgICAgICAgICAgbGV0IGNvbDAgPSBsaW5lLmluZGVudCAqIF9JTkRFTlRfV0lUSC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgc3BhbklkeCA9IDA7XG4gICAgICAgICAgICAvLyBza2lwIGxlYWRpbmcgcGFydHMgd2l0aG91dCBzb3VyY2Ugc3BhbnNcbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmICFzcGFuc1tzcGFuSWR4XSkge1xuICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmIGxpbmVJZHggPT09IDAgJiYgY29sMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0T2Zmc2V0TWFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbiA9IHNwYW5zW3NwYW5JZHhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHNwYW4uc3RhcnQuZmlsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VMaW5lID0gc3Bhbi5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbCA9IHNwYW4uc3RhcnQuY29sO1xuICAgICAgICAgICAgICAgIG1hcC5hZGRTb3VyY2Uoc291cmNlLnVybCwgc291cmNlLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRNYXBwaW5nKGNvbDAsIHNvdXJjZS51cmwsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbCk7XG4gICAgICAgICAgICAgICAgY29sMCArPSBwYXJ0c1tzcGFuSWR4XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3BhbklkeCsrO1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBwYXJ0cyB3aXRob3V0IHNwYW4gb3IgdGhlIHNhbWUgc3BhbiB0byB0aGUgcHJldmlvdXMgc2VnbWVudFxuICAgICAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmIChzcGFuID09PSBzcGFuc1tzcGFuSWR4XSB8fCAhc3BhbnNbc3BhbklkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzcGFuSWR4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgc3Bhbk9mKGxpbmUsIGNvbHVtbikge1xuICAgICAgICBjb25zdCBlbWl0dGVkTGluZSA9IHRoaXMuX2xpbmVzW2xpbmVdO1xuICAgICAgICBpZiAoZW1pdHRlZExpbmUpIHtcbiAgICAgICAgICAgIGxldCBjb2x1bW5zTGVmdCA9IGNvbHVtbiAtIF9jcmVhdGVJbmRlbnQoZW1pdHRlZExpbmUuaW5kZW50KS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCBlbWl0dGVkTGluZS5wYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGVtaXR0ZWRMaW5lLnBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID4gY29sdW1uc0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZWRMaW5lLnNyY1NwYW5zW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbHVtbnNMZWZ0IC09IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgc3RyaXAgdGhpcyBmcm9tIHB1Ymxpc2hlZCBkLnRzIGZpbGVzIGR1ZSB0b1xuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzYyMTZcbiAgICAgKi9cbiAgICBnZXQgc291cmNlTGluZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lcy5sZW5ndGggJiYgdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV0ucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lcztcbiAgICB9XG59XG5jbGFzcyBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihfZXNjYXBlRG9sbGFySW5TdHJpbmdzKSB7XG4gICAgICAgIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncyA9IF9lc2NhcGVEb2xsYXJJblN0cmluZ3M7XG4gICAgfVxuICAgIHByaW50TGVhZGluZ0NvbW1lbnRzKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5sZWFkaW5nQ29tbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY29tbWVudCBvZiBzdG10LmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgaWYgKGNvbW1lbnQgaW5zdGFuY2VvZiBKU0RvY0NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgYC8qJHtjb21tZW50LnRvU3RyaW5nKCl9Ki9gLCBjb21tZW50LnRyYWlsaW5nTmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIGAvKiAke2NvbW1lbnQudGV4dH0gKi9gLCBjb21tZW50LnRyYWlsaW5nTmV3bGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50LnRleHQuc3BsaXQoJ1xcbicpLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIGAvLyAke2xpbmV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb25TdG10KHN0bXQsIGN0eCkge1xuICAgICAgICB0aGlzLnByaW50TGVhZGluZ0NvbW1lbnRzKHN0bXQsIGN0eCk7XG4gICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0UmV0dXJuU3RtdChzdG10LCBjdHgpIHtcbiAgICAgICAgdGhpcy5wcmludExlYWRpbmdDb21tZW50cyhzdG10LCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgYHJldHVybiBgKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0SWZTdG10KHN0bXQsIGN0eCkge1xuICAgICAgICB0aGlzLnByaW50TGVhZGluZ0NvbW1lbnRzKHN0bXQsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBgaWYgKGApO1xuICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIGApIHtgKTtcbiAgICAgICAgY29uc3QgaGFzRWxzZUNhc2UgPSBzdG10LmZhbHNlQ2FzZSAhPSBudWxsICYmIHN0bXQuZmFsc2VDYXNlLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChzdG10LnRydWVDYXNlLmxlbmd0aCA8PSAxICYmICFoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIGAgYCk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnJlbW92ZUVtcHR5TGFzdExpbmUoKTtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBgIGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICBpZiAoaGFzRWxzZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBgfSBlbHNlIHtgKTtcbiAgICAgICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIGB9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFdyaXRlVmFyRXhwcihleHByLCBjdHgpIHtcbiAgICAgICAgY29uc3QgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJygnKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoZXhwciwgYCR7ZXhwci5uYW1lfSA9IGApO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0V3JpdGVLZXlFeHByKGV4cHIsIGN0eCkge1xuICAgICAgICBjb25zdCBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBgW2ApO1xuICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgYF0gPSBgKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFdyaXRlUHJvcEV4cHIoZXhwciwgY3R4KSB7XG4gICAgICAgIGNvbnN0IGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIGAuJHtleHByLm5hbWV9ID0gYCk7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRJbnZva2VGdW5jdGlvbkV4cHIoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBgKGApO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwci5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBgKWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRUYWdnZWRUZW1wbGF0ZUV4cHIoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIudGFnLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgJ2AnICsgZXhwci50ZW1wbGF0ZS5lbGVtZW50c1swXS5yYXdUZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHByLnRlbXBsYXRlLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyR7Jyk7XG4gICAgICAgICAgICBleHByLnRlbXBsYXRlLmV4cHJlc3Npb25zW2kgLSAxXS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCBgfSR7ZXhwci50ZW1wbGF0ZS5lbGVtZW50c1tpXS5yYXdUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChleHByLCAnYCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRXcmFwcGVkTm9kZUV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBYnN0cmFjdCBlbWl0dGVyIGNhbm5vdCB2aXNpdCBXcmFwcGVkTm9kZUV4cHIuJyk7XG4gICAgfVxuICAgIHZpc2l0VHlwZW9mRXhwcihleHByLCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsICd0eXBlb2YgJyk7XG4gICAgICAgIGV4cHIuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9XG4gICAgdmlzaXRSZWFkVmFyRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEluc3RhbnRpYXRlRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgbmV3IGApO1xuICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgKGApO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYClgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhc3QudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBlc2NhcGVJZGVudGlmaWVyKHZhbHVlLCB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdExvY2FsaXplZFN0cmluZyhhc3QsIGN0eCkge1xuICAgICAgICBjb25zdCBoZWFkID0gYXN0LnNlcmlhbGl6ZUkxOG5IZWFkKCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICckbG9jYWxpemUgYCcgKyBoZWFkLnJhdyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXN0Lm1lc3NhZ2VQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJyR7Jyk7XG4gICAgICAgICAgICBhc3QuZXhwcmVzc2lvbnNbaSAtIDFdLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgYH0ke2FzdC5zZXJpYWxpemVJMThuVGVtcGxhdGVQYXJ0KGkpLnJhd31gKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoYXN0LCAnYCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRDb25kaXRpb25hbEV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYChgKTtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJz8gJyk7XG4gICAgICAgIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJzogJyk7XG4gICAgICAgIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGApYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdE5vdEV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJyEnKTtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0VW5hcnlPcGVyYXRvckV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgbGV0IG9wU3RyO1xuICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlVuYXJ5T3BlcmF0b3IuUGx1czpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcrJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5VbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3IgJHthc3Qub3BlcmF0b3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdC5wYXJlbnMpXG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBgKGApO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBvcFN0cik7XG4gICAgICAgIGFzdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoYXN0LnBhcmVucylcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGApYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEJpbmFyeU9wZXJhdG9yRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBsZXQgb3BTdHI7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5JZGVudGljYWw6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPT09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5Ob3RFcXVhbHM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnIT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICchPT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkJpbmFyeU9wZXJhdG9yLkFuZDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcmJic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuQml0d2lzZUFuZDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcmJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5PcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICd8fCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuUGx1czpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICcrJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5NaW51czpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICctJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5EaXZpZGU6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnLyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuTXVsdGlwbHk6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnKic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuTW9kdWxvOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkJpbmFyeU9wZXJhdG9yLkxvd2VyOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJzwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLkJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJzw9JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5CaWdnZXI6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz49JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5OdWxsaXNoQ29hbGVzY2U6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnPz8nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3BlcmF0b3IgJHthc3Qub3BlcmF0b3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzdC5wYXJlbnMpXG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBgKGApO1xuICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgICR7b3BTdHJ9IGApO1xuICAgICAgICBhc3QucmhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoYXN0LnBhcmVucylcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGApYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFJlYWRQcm9wRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBhc3QucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGAuYCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0UmVhZEtleUV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgW2ApO1xuICAgICAgICBhc3QuaW5kZXgudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGBdYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxBcnJheUV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYFtgKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5lbnRyaWVzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGBdYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxNYXBFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGB7YCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxPYmplY3RzKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGAke2VzY2FwZUlkZW50aWZpZXIoZW50cnkua2V5LCB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MsIGVudHJ5LnF1b3RlZCl9OmApO1xuICAgICAgICAgICAgZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIH0sIGFzdC5lbnRyaWVzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGB9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdENvbW1hRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnKCcpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcpJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEFsbEV4cHJlc3Npb25zKGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvcikge1xuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhleHByID0+IGV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCksIGV4cHJlc3Npb25zLCBjdHgsIHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHZpc2l0QWxsT2JqZWN0cyhoYW5kbGVyLCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IpIHtcbiAgICAgICAgbGV0IGluY3JlbWVudGVkSW5kZW50ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChjdHgubGluZUxlbmd0aCgpID4gODApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIHNlcGFyYXRvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5jcmVtZW50ZWRJbmRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVhdGlvbiBhcmUgbWFya2VkIHdpdGggZG91YmxlIGluZGVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudGVkSW5kZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnByaW50KG51bGwsIHNlcGFyYXRvciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIoZXhwcmVzc2lvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNyZW1lbnRlZEluZGVudCkge1xuICAgICAgICAgICAgLy8gY29udGludWF0aW9uIGFyZSBtYXJrZWQgd2l0aCBkb3VibGUgaW5kZW50LlxuICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0QWxsU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjdHgpIHtcbiAgICAgICAgc3RhdGVtZW50cy5mb3JFYWNoKChzdG10KSA9PiBzdG10LnZpc2l0U3RhdGVtZW50KHRoaXMsIGN0eCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZUlkZW50aWZpZXIoaW5wdXQsIGVzY2FwZURvbGxhciwgYWx3YXlzUXVvdGUgPSB0cnVlKSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBpbnB1dC5yZXBsYWNlKF9TSU5HTEVfUVVPVEVfRVNDQVBFX1NUUklOR19SRSwgKC4uLm1hdGNoKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaFswXSA9PSAnJCcpIHtcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVEb2xsYXIgPyAnXFxcXCQnIDogJyQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09ICdcXG4nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PSAnXFxyJykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxccic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYFxcXFwke21hdGNoWzBdfWA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCByZXF1aXJlc1F1b3RlcyA9IGFsd2F5c1F1b3RlIHx8ICFfTEVHQUxfSURFTlRJRklFUl9SRS50ZXN0KGJvZHkpO1xuICAgIHJldHVybiByZXF1aXJlc1F1b3RlcyA/IGAnJHtib2R5fSdgIDogYm9keTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVJbmRlbnQoY291bnQpIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHJlcyArPSBfSU5ERU5UX1dJVEg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gdHlwZVdpdGhQYXJhbWV0ZXJzKHR5cGUsIG51bVBhcmFtcykge1xuICAgIGlmIChudW1QYXJhbXMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25UeXBlKHR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBhcmFtczsgaSsrKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKERZTkFNSUNfVFlQRSk7XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9uVHlwZSh0eXBlLCB1bmRlZmluZWQsIHBhcmFtcyk7XG59XG5jb25zdCBBTklNQVRFX1NZTUJPTF9QUkVGSVggPSAnQCc7XG5mdW5jdGlvbiBwcmVwYXJlU3ludGhldGljUHJvcGVydHlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gYCR7QU5JTUFURV9TWU1CT0xfUFJFRklYfSR7bmFtZX1gO1xufVxuZnVuY3Rpb24gcHJlcGFyZVN5bnRoZXRpY0xpc3RlbmVyTmFtZShuYW1lLCBwaGFzZSkge1xuICAgIHJldHVybiBgJHtBTklNQVRFX1NZTUJPTF9QUkVGSVh9JHtuYW1lfS4ke3BoYXNlfWA7XG59XG5mdW5jdGlvbiBnZXRTYWZlUHJvcGVydHlBY2Nlc3NTdHJpbmcoYWNjZXNzb3IsIG5hbWUpIHtcbiAgICBjb25zdCBlc2NhcGVkTmFtZSA9IGVzY2FwZUlkZW50aWZpZXIobmFtZSwgZmFsc2UsIGZhbHNlKTtcbiAgICByZXR1cm4gZXNjYXBlZE5hbWUgIT09IG5hbWUgPyBgJHthY2Nlc3Nvcn1bJHtlc2NhcGVkTmFtZX1dYCA6IGAke2FjY2Vzc29yfS4ke25hbWV9YDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTeW50aGV0aWNMaXN0ZW5lckZ1bmN0aW9uTmFtZShuYW1lLCBwaGFzZSkge1xuICAgIHJldHVybiBgYW5pbWF0aW9uXyR7bmFtZX1fJHtwaGFzZX1gO1xufVxuZnVuY3Rpb24gaml0T25seUd1YXJkZWRFeHByZXNzaW9uKGV4cHIpIHtcbiAgICByZXR1cm4gZ3VhcmRlZEV4cHJlc3Npb24oJ25nSml0TW9kZScsIGV4cHIpO1xufVxuZnVuY3Rpb24gZGV2T25seUd1YXJkZWRFeHByZXNzaW9uKGV4cHIpIHtcbiAgICByZXR1cm4gZ3VhcmRlZEV4cHJlc3Npb24oJ25nRGV2TW9kZScsIGV4cHIpO1xufVxuZnVuY3Rpb24gZ3VhcmRlZEV4cHJlc3Npb24oZ3VhcmQsIGV4cHIpIHtcbiAgICBjb25zdCBndWFyZEV4cHIgPSBuZXcgRXh0ZXJuYWxFeHByKHsgbmFtZTogZ3VhcmQsIG1vZHVsZU5hbWU6IG51bGwgfSk7XG4gICAgY29uc3QgZ3VhcmROb3REZWZpbmVkID0gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihleHBvcnRzLkJpbmFyeU9wZXJhdG9yLklkZW50aWNhbCwgbmV3IFR5cGVvZkV4cHIoZ3VhcmRFeHByKSwgbGl0ZXJhbCgndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGd1YXJkVW5kZWZpbmVkT3JUcnVlID0gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk9yLCBndWFyZE5vdERlZmluZWQsIGd1YXJkRXhwciwgLyogdHlwZSAqLyB1bmRlZmluZWQsIFxuICAgIC8qIHNvdXJjZVNwYW4gKi8gdW5kZWZpbmVkLCB0cnVlKTtcbiAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihleHBvcnRzLkJpbmFyeU9wZXJhdG9yLkFuZCwgZ3VhcmRVbmRlZmluZWRPclRydWUsIGV4cHIpO1xufVxuZnVuY3Rpb24gd3JhcFJlZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHdyYXBwZWQgPSBuZXcgV3JhcHBlZE5vZGVFeHByKHZhbHVlKTtcbiAgICByZXR1cm4geyB2YWx1ZTogd3JhcHBlZCwgdHlwZTogd3JhcHBlZCB9O1xufVxuZnVuY3Rpb24gcmVmc1RvQXJyYXkocmVmcywgc2hvdWxkRm9yd2FyZERlY2xhcmUpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBsaXRlcmFsQXJyKHJlZnMubWFwKHJlZiA9PiByZWYudmFsdWUpKTtcbiAgICByZXR1cm4gc2hvdWxkRm9yd2FyZERlY2xhcmUgPyBmbihbXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQodmFsdWVzKV0pIDogdmFsdWVzO1xufVxuZnVuY3Rpb24gY3JlYXRlTWF5QmVGb3J3YXJkUmVmRXhwcmVzc2lvbihleHByZXNzaW9uLCBmb3J3YXJkUmVmKSB7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgZm9yd2FyZFJlZiB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgYE1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb25gIHRvIGFuIGBFeHByZXNzaW9uYCwgcG9zc2libHkgd3JhcHBpbmcgaXRzIGV4cHJlc3Npb24gaW4gYVxuICogYGZvcndhcmRSZWYoKWAgY2FsbC5cbiAqXG4gKiBJZiBgTWF5YmVGb3J3YXJkUmVmRXhwcmVzc2lvbi5mb3J3YXJkUmVmYCBpcyBgRm9yd2FyZFJlZkhhbmRsaW5nLlVud3JhcHBlZGAgdGhlbiB0aGUgZXhwcmVzc2lvblxuICogd2FzIG9yaWdpbmFsbHkgd3JhcHBlZCBpbiBhIGBmb3J3YXJkUmVmKClgIGNhbGwgdG8gcHJldmVudCB0aGUgdmFsdWUgZnJvbSBiZWluZyBlYWdlcmx5IGV2YWx1YXRlZFxuICogaW4gdGhlIGNvZGUuXG4gKlxuICogU2VlIGBwYWNrYWdlcy9jb21waWxlci1jbGkvc3JjL25ndHNjL2Fubm90YXRpb25zL3NyYy9pbmplY3RhYmxlLnRzYCBhbmRcbiAqIGBwYWNrYWdlcy9jb21waWxlci9zcmMvaml0X2NvbXBpbGVyX2ZhY2FkZS50c2AgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRGcm9tTWF5YmVGb3J3YXJkUmVmRXhwcmVzc2lvbih7IGV4cHJlc3Npb24sIGZvcndhcmRSZWYgfSkge1xuICAgIHN3aXRjaCAoZm9yd2FyZFJlZikge1xuICAgICAgICBjYXNlIDAgLyogRm9yd2FyZFJlZkhhbmRsaW5nLk5vbmUgKi86XG4gICAgICAgIGNhc2UgMSAvKiBGb3J3YXJkUmVmSGFuZGxpbmcuV3JhcHBlZCAqLzpcbiAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgICBjYXNlIDIgLyogRm9yd2FyZFJlZkhhbmRsaW5nLlVud3JhcHBlZCAqLzpcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUZvcndhcmRSZWYoZXhwcmVzc2lvbik7XG4gICAgfVxufVxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBleHByZXNzaW9uIHRoYXQgaGFzIHRoZSBnaXZlbiBgZXhwcmAgd3JhcHBlZCBpbiB0aGUgZm9sbG93aW5nIGZvcm06XG4gKlxuICogYGBgXG4gKiBmb3J3YXJkUmVmKCgpID0+IGV4cHIpXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVGb3J3YXJkUmVmKGV4cHIpIHtcbiAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycy5mb3J3YXJkUmVmKS5jYWxsRm4oW2ZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudChleHByKV0pXSk7XG59XG5cbnZhciBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGU7XG4oZnVuY3Rpb24gKFIzRmFjdG9yeURlbGVnYXRlVHlwZSkge1xuICAgIFIzRmFjdG9yeURlbGVnYXRlVHlwZVtSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbXCJDbGFzc1wiXSA9IDBdID0gXCJDbGFzc1wiO1xuICAgIFIzRmFjdG9yeURlbGVnYXRlVHlwZVtSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGVbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xufSkoUjNGYWN0b3J5RGVsZWdhdGVUeXBlIHx8IChSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGUgPSB7fSkpO1xuZXhwb3J0cy5GYWN0b3J5VGFyZ2V0ID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChGYWN0b3J5VGFyZ2V0KSB7XG4gICAgRmFjdG9yeVRhcmdldFtGYWN0b3J5VGFyZ2V0W1wiRGlyZWN0aXZlXCJdID0gMF0gPSBcIkRpcmVjdGl2ZVwiO1xuICAgIEZhY3RvcnlUYXJnZXRbRmFjdG9yeVRhcmdldFtcIkNvbXBvbmVudFwiXSA9IDFdID0gXCJDb21wb25lbnRcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJJbmplY3RhYmxlXCJdID0gMl0gPSBcIkluamVjdGFibGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJQaXBlXCJdID0gM10gPSBcIlBpcGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJOZ01vZHVsZVwiXSA9IDRdID0gXCJOZ01vZHVsZVwiO1xufSkoZXhwb3J0cy5GYWN0b3J5VGFyZ2V0IHx8IChleHBvcnRzLkZhY3RvcnlUYXJnZXQgPSB7fSkpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBmYWN0b3J5IGZ1bmN0aW9uIGV4cHJlc3Npb24gZm9yIHRoZSBnaXZlbiBgUjNGYWN0b3J5TWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKG1ldGEpIHtcbiAgICBjb25zdCB0ID0gdmFyaWFibGUoJ3QnKTtcbiAgICBsZXQgYmFzZUZhY3RvcnlWYXIgPSBudWxsO1xuICAgIC8vIFRoZSB0eXBlIHRvIGluc3RhbnRpYXRlIHZpYSBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uLiBJZiB0aGVyZSBpcyBubyBkZWxlZ2F0ZWQgZmFjdG9yeSwgbWVhbmluZ1xuICAgIC8vIHRoaXMgdHlwZSBpcyBhbHdheXMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uLCB0aGVuIHRoaXMgaXMgdGhlIHR5cGUtdG8tY3JlYXRlXG4gICAgLy8gcGFyYW1ldGVyIHByb3ZpZGVkIGJ5IHRoZSB1c2VyICh0KSBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjdXJyZW50IHR5cGUgaWYgbm90LiBJZiB0aGVyZSBpcyBhXG4gICAgLy8gZGVsZWdhdGVkIGZhY3RvcnkgKHdoaWNoIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBjdXJyZW50IHR5cGUpIHRoZW4gdGhpcyBpcyBvbmx5IHRoZSB0eXBlLXRvLVxuICAgIC8vIGNyZWF0ZSBwYXJhbWV0ZXIgKHQpLlxuICAgIGNvbnN0IHR5cGVGb3JDdG9yID0gIWlzRGVsZWdhdGVkRmFjdG9yeU1ldGFkYXRhKG1ldGEpID9cbiAgICAgICAgbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk9yLCB0LCBtZXRhLmludGVybmFsVHlwZSkgOlxuICAgICAgICB0O1xuICAgIGxldCBjdG9yRXhwciA9IG51bGw7XG4gICAgaWYgKG1ldGEuZGVwcyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGVyZSBpcyBhIGNvbnN0cnVjdG9yIChlaXRoZXIgZXhwbGljaXRseSBvciBpbXBsaWNpdGx5IGRlZmluZWQpLlxuICAgICAgICBpZiAobWV0YS5kZXBzICE9PSAnaW52YWxpZCcpIHtcbiAgICAgICAgICAgIGN0b3JFeHByID0gbmV3IEluc3RhbnRpYXRlRXhwcih0eXBlRm9yQ3RvciwgaW5qZWN0RGVwZW5kZW5jaWVzKG1ldGEuZGVwcywgbWV0YS50YXJnZXQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gY29uc3RydWN0b3IsIHVzZSB0aGUgYmFzZSBjbGFzcycgZmFjdG9yeSB0byBjb25zdHJ1Y3QgdHlwZUZvckN0b3IuXG4gICAgICAgIGJhc2VGYWN0b3J5VmFyID0gdmFyaWFibGUoYMm1JHttZXRhLm5hbWV9X0Jhc2VGYWN0b3J5YCk7XG4gICAgICAgIGN0b3JFeHByID0gYmFzZUZhY3RvcnlWYXIuY2FsbEZuKFt0eXBlRm9yQ3Rvcl0pO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgbGV0IHJldEV4cHIgPSBudWxsO1xuICAgIGZ1bmN0aW9uIG1ha2VDb25kaXRpb25hbEZhY3Rvcnkobm9uQ3RvckV4cHIpIHtcbiAgICAgICAgY29uc3QgciA9IHZhcmlhYmxlKCdyJyk7XG4gICAgICAgIGJvZHkucHVzaChyLnNldChOVUxMX0VYUFIpLnRvRGVjbFN0bXQoKSk7XG4gICAgICAgIGNvbnN0IGN0b3JTdG10ID0gY3RvckV4cHIgIT09IG51bGwgPyByLnNldChjdG9yRXhwcikudG9TdG10KCkgOlxuICAgICAgICAgICAgaW1wb3J0RXhwcihJZGVudGlmaWVycy5pbnZhbGlkRmFjdG9yeSkuY2FsbEZuKFtdKS50b1N0bXQoKTtcbiAgICAgICAgYm9keS5wdXNoKGlmU3RtdCh0LCBbY3RvclN0bXRdLCBbci5zZXQobm9uQ3RvckV4cHIpLnRvU3RtdCgpXSkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgaWYgKGlzRGVsZWdhdGVkRmFjdG9yeU1ldGFkYXRhKG1ldGEpKSB7XG4gICAgICAgIC8vIFRoaXMgdHlwZSBpcyBjcmVhdGVkIHdpdGggYSBkZWxlZ2F0ZWQgZmFjdG9yeS4gSWYgYSB0eXBlIHBhcmFtZXRlciBpcyBub3Qgc3BlY2lmaWVkLCBjYWxsXG4gICAgICAgIC8vIHRoZSBmYWN0b3J5IGluc3RlYWQuXG4gICAgICAgIGNvbnN0IGRlbGVnYXRlQXJncyA9IGluamVjdERlcGVuZGVuY2llcyhtZXRhLmRlbGVnYXRlRGVwcywgbWV0YS50YXJnZXQpO1xuICAgICAgICAvLyBFaXRoZXIgY2FsbCBgbmV3IGRlbGVnYXRlKC4uLilgIG9yIGBkZWxlZ2F0ZSguLi4pYCBkZXBlbmRpbmcgb24gbWV0YS5kZWxlZ2F0ZVR5cGUuXG4gICAgICAgIGNvbnN0IGZhY3RvcnlFeHByID0gbmV3IChtZXRhLmRlbGVnYXRlVHlwZSA9PT0gUjNGYWN0b3J5RGVsZWdhdGVUeXBlLkNsYXNzID9cbiAgICAgICAgICAgIEluc3RhbnRpYXRlRXhwciA6XG4gICAgICAgICAgICBJbnZva2VGdW5jdGlvbkV4cHIpKG1ldGEuZGVsZWdhdGUsIGRlbGVnYXRlQXJncyk7XG4gICAgICAgIHJldEV4cHIgPSBtYWtlQ29uZGl0aW9uYWxGYWN0b3J5KGZhY3RvcnlFeHByKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFeHByZXNzaW9uRmFjdG9yeU1ldGFkYXRhKG1ldGEpKSB7XG4gICAgICAgIC8vIFRPRE8oYWx4aHViKTogZGVjaWRlIHdoZXRoZXIgdG8gbG93ZXIgdGhlIHZhbHVlIGhlcmUgb3IgaW4gdGhlIGNhbGxlclxuICAgICAgICByZXRFeHByID0gbWFrZUNvbmRpdGlvbmFsRmFjdG9yeShtZXRhLmV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0RXhwciA9IGN0b3JFeHByO1xuICAgIH1cbiAgICBpZiAocmV0RXhwciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiBjYW5ub3QgYmUgZm9ybWVkIHNvIHJlbmRlciBhbiBgybXJtWludmFsaWRGYWN0b3J5KClgIGNhbGwuXG4gICAgICAgIGJvZHkucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzLmludmFsaWRGYWN0b3J5KS5jYWxsRm4oW10pLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmFzZUZhY3RvcnlWYXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBmYWN0b3J5IHVzZXMgYSBiYXNlIGZhY3RvcnksIHNvIGNhbGwgYMm1ybVnZXRJbmhlcml0ZWRGYWN0b3J5KClgIHRvIGNvbXB1dGUgaXQuXG4gICAgICAgIGNvbnN0IGdldEluaGVyaXRlZEZhY3RvcnlDYWxsID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5nZXRJbmhlcml0ZWRGYWN0b3J5KS5jYWxsRm4oW21ldGEuaW50ZXJuYWxUeXBlXSk7XG4gICAgICAgIC8vIE1lbW9pemUgdGhlIGJhc2UgZmFjdG9yeUZuOiBgYmFzZUZhY3RvcnkgfHwgKGJhc2VGYWN0b3J5ID0gybXJtWdldEluaGVyaXRlZEZhY3RvcnkoLi4uKSlgXG4gICAgICAgIGNvbnN0IGJhc2VGYWN0b3J5ID0gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk9yLCBiYXNlRmFjdG9yeVZhciwgYmFzZUZhY3RvcnlWYXIuc2V0KGdldEluaGVyaXRlZEZhY3RvcnlDYWxsKSk7XG4gICAgICAgIGJvZHkucHVzaChuZXcgUmV0dXJuU3RhdGVtZW50KGJhc2VGYWN0b3J5LmNhbGxGbihbdHlwZUZvckN0b3JdKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBzdHJhaWdodGZvcndhcmQgZmFjdG9yeSwganVzdCByZXR1cm4gaXQuXG4gICAgICAgIGJvZHkucHVzaChuZXcgUmV0dXJuU3RhdGVtZW50KHJldEV4cHIpKTtcbiAgICB9XG4gICAgbGV0IGZhY3RvcnlGbiA9IGZuKFtuZXcgRm5QYXJhbSgndCcsIERZTkFNSUNfVFlQRSldLCBib2R5LCBJTkZFUlJFRF9UWVBFLCB1bmRlZmluZWQsIGAke21ldGEubmFtZX1fRmFjdG9yeWApO1xuICAgIGlmIChiYXNlRmFjdG9yeVZhciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGVyZSBpcyBhIGJhc2UgZmFjdG9yeSB2YXJpYWJsZSBzbyB3cmFwIGl0cyBkZWNsYXJhdGlvbiBhbG9uZyB3aXRoIHRoZSBmYWN0b3J5IGZ1bmN0aW9uIGludG9cbiAgICAgICAgLy8gYW4gSUlGRS5cbiAgICAgICAgZmFjdG9yeUZuID0gZm4oW10sIFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJlVmFyU3RtdChiYXNlRmFjdG9yeVZhci5uYW1lKSwgbmV3IFJldHVyblN0YXRlbWVudChmYWN0b3J5Rm4pXG4gICAgICAgIF0pLmNhbGxGbihbXSwgLyogc291cmNlU3BhbiAqLyB1bmRlZmluZWQsIC8qIHB1cmUgKi8gdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGV4cHJlc3Npb246IGZhY3RvcnlGbixcbiAgICAgICAgc3RhdGVtZW50czogW10sXG4gICAgICAgIHR5cGU6IGNyZWF0ZUZhY3RvcnlUeXBlKG1ldGEpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5VHlwZShtZXRhKSB7XG4gICAgY29uc3QgY3RvckRlcHNUeXBlID0gbWV0YS5kZXBzICE9PSBudWxsICYmIG1ldGEuZGVwcyAhPT0gJ2ludmFsaWQnID8gY3JlYXRlQ3RvckRlcHNUeXBlKG1ldGEuZGVwcykgOiBOT05FX1RZUEU7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuRmFjdG9yeURlY2xhcmF0aW9uLCBbdHlwZVdpdGhQYXJhbWV0ZXJzKG1ldGEudHlwZS50eXBlLCBtZXRhLnR5cGVBcmd1bWVudENvdW50KSwgY3RvckRlcHNUeXBlXSkpO1xufVxuZnVuY3Rpb24gaW5qZWN0RGVwZW5kZW5jaWVzKGRlcHMsIHRhcmdldCkge1xuICAgIHJldHVybiBkZXBzLm1hcCgoZGVwLCBpbmRleCkgPT4gY29tcGlsZUluamVjdERlcGVuZGVuY3koZGVwLCB0YXJnZXQsIGluZGV4KSk7XG59XG5mdW5jdGlvbiBjb21waWxlSW5qZWN0RGVwZW5kZW5jeShkZXAsIHRhcmdldCwgaW5kZXgpIHtcbiAgICAvLyBJbnRlcnByZXQgdGhlIGRlcGVuZGVuY3kgYWNjb3JkaW5nIHRvIGl0cyByZXNvbHZlZCB0eXBlLlxuICAgIGlmIChkZXAudG9rZW4gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuaW52YWxpZEZhY3RvcnlEZXApLmNhbGxGbihbbGl0ZXJhbChpbmRleCldKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVwLmF0dHJpYnV0ZU5hbWVUeXBlID09PSBudWxsKSB7XG4gICAgICAgIC8vIEJ1aWxkIHVwIHRoZSBpbmplY3Rpb24gZmxhZ3MgYWNjb3JkaW5nIHRvIHRoZSBtZXRhZGF0YS5cbiAgICAgICAgY29uc3QgZmxhZ3MgPSAwIC8qIEluamVjdEZsYWdzLkRlZmF1bHQgKi8gfCAoZGVwLnNlbGYgPyAyIC8qIEluamVjdEZsYWdzLlNlbGYgKi8gOiAwKSB8XG4gICAgICAgICAgICAoZGVwLnNraXBTZWxmID8gNCAvKiBJbmplY3RGbGFncy5Ta2lwU2VsZiAqLyA6IDApIHwgKGRlcC5ob3N0ID8gMSAvKiBJbmplY3RGbGFncy5Ib3N0ICovIDogMCkgfFxuICAgICAgICAgICAgKGRlcC5vcHRpb25hbCA/IDggLyogSW5qZWN0RmxhZ3MuT3B0aW9uYWwgKi8gOiAwKSB8XG4gICAgICAgICAgICAodGFyZ2V0ID09PSBleHBvcnRzLkZhY3RvcnlUYXJnZXQuUGlwZSA/IDE2IC8qIEluamVjdEZsYWdzLkZvclBpcGUgKi8gOiAwKTtcbiAgICAgICAgLy8gSWYgdGhpcyBkZXBlbmRlbmN5IGlzIG9wdGlvbmFsIG9yIG90aGVyd2lzZSBoYXMgbm9uLWRlZmF1bHQgZmxhZ3MsIHRoZW4gYWRkaXRpb25hbFxuICAgICAgICAvLyBwYXJhbWV0ZXJzIGRlc2NyaWJpbmcgaG93IHRvIGluamVjdCB0aGUgZGVwZW5kZW5jeSBtdXN0IGJlIHBhc3NlZCB0byB0aGUgaW5qZWN0IGZ1bmN0aW9uXG4gICAgICAgIC8vIHRoYXQncyBiZWluZyB1c2VkLlxuICAgICAgICBsZXQgZmxhZ3NQYXJhbSA9IChmbGFncyAhPT0gMCAvKiBJbmplY3RGbGFncy5EZWZhdWx0ICovIHx8IGRlcC5vcHRpb25hbCkgPyBsaXRlcmFsKGZsYWdzKSA6IG51bGw7XG4gICAgICAgIC8vIEJ1aWxkIHVwIHRoZSBhcmd1bWVudHMgdG8gdGhlIGluamVjdEZuIGNhbGwuXG4gICAgICAgIGNvbnN0IGluamVjdEFyZ3MgPSBbZGVwLnRva2VuXTtcbiAgICAgICAgaWYgKGZsYWdzUGFyYW0pIHtcbiAgICAgICAgICAgIGluamVjdEFyZ3MucHVzaChmbGFnc1BhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmplY3RGbiA9IGdldEluamVjdEZuKHRhcmdldCk7XG4gICAgICAgIHJldHVybiBpbXBvcnRFeHByKGluamVjdEZuKS5jYWxsRm4oaW5qZWN0QXJncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGUgYGRlcC5hdHRyaWJ1dGVUeXBlTmFtZWAgdmFsdWUgaXMgZGVmaW5lZCwgd2hpY2ggaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyBhbiBgQEF0dHJpYnV0ZSgpYFxuICAgICAgICAvLyB0eXBlIGRlcGVuZGVuY3kuIEZvciB0aGUgZ2VuZXJhdGVkIEpTIHdlIHN0aWxsIHdhbnQgdG8gdXNlIHRoZSBgZGVwLnRva2VuYCB2YWx1ZSBpbiBjYXNlIHRoZVxuICAgICAgICAvLyBuYW1lIGdpdmVuIGZvciB0aGUgYXR0cmlidXRlIGlzIG5vdCBhIHN0cmluZyBsaXRlcmFsLiBGb3IgZXhhbXBsZSBnaXZlbiBgQEF0dHJpYnV0ZShmb28oKSlgLFxuICAgICAgICAvLyB3ZSB3YW50IHRvIGdlbmVyYXRlIGDJtcm1aW5qZWN0QXR0cmlidXRlKGZvbygpKWAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBgZGVwLmF0dHJpYnV0ZVR5cGVOYW1lYCBpcyBvbmx5IGFjdHVhbGx5IHVzZWQgKGluIGBjcmVhdGVDdG9yRGVwVHlwZSgpYCkgdG8gZ2VuZXJhdGVcbiAgICAgICAgLy8gdHlwaW5ncy5cbiAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuaW5qZWN0QXR0cmlidXRlKS5jYWxsRm4oW2RlcC50b2tlbl0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUN0b3JEZXBzVHlwZShkZXBzKSB7XG4gICAgbGV0IGhhc1R5cGVzID0gZmFsc2U7XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZXMgPSBkZXBzLm1hcChkZXAgPT4ge1xuICAgICAgICBjb25zdCB0eXBlID0gY3JlYXRlQ3RvckRlcFR5cGUoZGVwKTtcbiAgICAgICAgaWYgKHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGhhc1R5cGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWwobnVsbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaGFzVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25UeXBlKGxpdGVyYWxBcnIoYXR0cmlidXRlVHlwZXMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBOT05FX1RZUEU7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ3RvckRlcFR5cGUoZGVwKSB7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGlmIChkZXAuYXR0cmlidXRlTmFtZVR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiAnYXR0cmlidXRlJywgdmFsdWU6IGRlcC5hdHRyaWJ1dGVOYW1lVHlwZSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKGRlcC5vcHRpb25hbCkge1xuICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6ICdvcHRpb25hbCcsIHZhbHVlOiBsaXRlcmFsKHRydWUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAoZGVwLmhvc3QpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiAnaG9zdCcsIHZhbHVlOiBsaXRlcmFsKHRydWUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAoZGVwLnNlbGYpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiAnc2VsZicsIHZhbHVlOiBsaXRlcmFsKHRydWUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAoZGVwLnNraXBTZWxmKSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IGtleTogJ3NraXBTZWxmJywgdmFsdWU6IGxpdGVyYWwodHJ1ZSksIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyaWVzLmxlbmd0aCA+IDAgPyBsaXRlcmFsTWFwKGVudHJpZXMpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRGVsZWdhdGVkRmFjdG9yeU1ldGFkYXRhKG1ldGEpIHtcbiAgICByZXR1cm4gbWV0YS5kZWxlZ2F0ZVR5cGUgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbkZhY3RvcnlNZXRhZGF0YShtZXRhKSB7XG4gICAgcmV0dXJuIG1ldGEuZXhwcmVzc2lvbiAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0SW5qZWN0Rm4odGFyZ2V0KSB7XG4gICAgc3dpdGNoICh0YXJnZXQpIHtcbiAgICAgICAgY2FzZSBleHBvcnRzLkZhY3RvcnlUYXJnZXQuQ29tcG9uZW50OlxuICAgICAgICBjYXNlIGV4cG9ydHMuRmFjdG9yeVRhcmdldC5EaXJlY3RpdmU6XG4gICAgICAgIGNhc2UgZXhwb3J0cy5GYWN0b3J5VGFyZ2V0LlBpcGU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuZGlyZWN0aXZlSW5qZWN0O1xuICAgICAgICBjYXNlIGV4cG9ydHMuRmFjdG9yeVRhcmdldC5OZ01vZHVsZTpcbiAgICAgICAgY2FzZSBleHBvcnRzLkZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5pbmplY3Q7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogVGhpcyBpcyBhbiBSMyBgTm9kZWAtbGlrZSB3cmFwcGVyIGZvciBhIHJhdyBgaHRtbC5Db21tZW50YCBub2RlLiBXZSBkbyBub3QgY3VycmVudGx5XG4gKiByZXF1aXJlIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHZpc2l0b3IgZm9yIENvbW1lbnRzIGFzIHRoZXkgYXJlIG9ubHkgY29sbGVjdGVkIGF0XG4gKiB0aGUgdG9wLWxldmVsIG9mIHRoZSBSMyBBU1QsIGFuZCBvbmx5IGlmIGBSZW5kZXIzUGFyc2VPcHRpb25zWydjb2xsZWN0Q29tbWVudE5vZGVzJ11gXG4gKiBpcyB0cnVlLlxuICovXG5jbGFzcyBDb21tZW50JDEge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQoX3Zpc2l0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2aXNpdCgpIG5vdCBpbXBsZW1lbnRlZCBmb3IgQ29tbWVudCcpO1xuICAgIH1cbn1cbmNsYXNzIFRleHQkMyB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBCb3VuZFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJvdW5kVGV4dCh0aGlzKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZXh0IGF0dHJpYnV0ZSBpbiB0aGUgdGVtcGxhdGUuXG4gKlxuICogYHZhbHVlU3BhbmAgbWF5IG5vdCBiZSBwcmVzZW50IGluIGNhc2VzIHdoZXJlIHRoZXJlIGlzIG5vIHZhbHVlIGA8ZGl2IGE+PC9kaXY+YC5cbiAqIGBrZXlTcGFuYCBtYXkgYWxzbyBub3QgYmUgcHJlc2VudCBmb3Igc3ludGhldGljIGF0dHJpYnV0ZXMgZnJvbSBJQ1UgZXhwYW5zaW9ucy5cbiAqL1xuY2xhc3MgVGV4dEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dEF0dHJpYnV0ZSh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBCb3VuZEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHlDb250ZXh0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJvdW5kRWxlbWVudFByb3BlcnR5KHByb3AsIGkxOG4pIHtcbiAgICAgICAgaWYgKHByb3Aua2V5U3BhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc3RhdGU6IGtleVNwYW4gbXVzdCBiZSBkZWZpbmVkIGZvciBib3VuZCBhdHRyaWJ1dGVzIGJ1dCB3YXMgbm90IGZvciAke3Byb3AubmFtZX06ICR7cHJvcC5zb3VyY2VTcGFufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRBdHRyaWJ1dGUocHJvcC5uYW1lLCBwcm9wLnR5cGUsIHByb3Auc2VjdXJpdHlDb250ZXh0LCBwcm9wLnZhbHVlLCBwcm9wLnVuaXQsIHByb3Auc291cmNlU3BhbiwgcHJvcC5rZXlTcGFuLCBwcm9wLnZhbHVlU3BhbiwgaTE4bik7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZEF0dHJpYnV0ZSh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBCb3VuZEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBoYW5kbGVyLCB0YXJnZXQsIHBoYXNlLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3Bhbiwga2V5U3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmhhbmRsZXJTcGFuID0gaGFuZGxlclNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUGFyc2VkRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudHlwZSA9PT0gMCAvKiBQYXJzZWRFdmVudFR5cGUuUmVndWxhciAqLyA/IGV2ZW50LnRhcmdldE9yUGhhc2UgOiBudWxsO1xuICAgICAgICBjb25zdCBwaGFzZSA9IGV2ZW50LnR5cGUgPT09IDEgLyogUGFyc2VkRXZlbnRUeXBlLkFuaW1hdGlvbiAqLyA/IGV2ZW50LnRhcmdldE9yUGhhc2UgOiBudWxsO1xuICAgICAgICBpZiAoZXZlbnQua2V5U3BhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc3RhdGU6IGtleVNwYW4gbXVzdCBiZSBkZWZpbmVkIGZvciBib3VuZCBldmVudCBidXQgd2FzIG5vdCBmb3IgJHtldmVudC5uYW1lfTogJHtldmVudC5zb3VyY2VTcGFufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRFdmVudChldmVudC5uYW1lLCBldmVudC50eXBlLCBldmVudC5oYW5kbGVyLCB0YXJnZXQsIHBoYXNlLCBldmVudC5zb3VyY2VTcGFuLCBldmVudC5oYW5kbGVyU3BhbiwgZXZlbnQua2V5U3Bhbik7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZEV2ZW50KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIEVsZW1lbnQkMSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXR0cmlidXRlcywgaW5wdXRzLCBvdXRwdXRzLCBjaGlsZHJlbiwgcmVmZXJlbmNlcywgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gdGFnTmFtZSBpcyB0aGUgbmFtZSBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQsIGlmIGFwcGxpY2FibGUuXG4gICAgLy8gYG51bGxgIGlzIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIHRoZXJlIGlzIGEgc3RydWN0dXJhbCBkaXJlY3RpdmUgb24gYW4gYG5nLXRlbXBsYXRlYCBzb1xuICAgIC8vIHRoZSByZW5kZXJlciBjYW4gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSBzeW50aGV0aWMgdGVtcGxhdGUgYW5kIHRoZSBvbmUgd3JpdHRlbiBpbiB0aGVcbiAgICAvLyBmaWxlLlxuICAgIHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGlucHV0cywgb3V0cHV0cywgdGVtcGxhdGVBdHRycywgY2hpbGRyZW4sIHJlZmVyZW5jZXMsIHZhcmlhYmxlcywgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnRlbXBsYXRlQXR0cnMgPSB0ZW1wbGF0ZUF0dHJzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRlbXBsYXRlKHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENvbnRlbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCBzb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ25nLWNvbnRlbnQnO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGVudCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmFyaWFibGUodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgUmVmZXJlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgSWN1JDEge1xuICAgIGNvbnN0cnVjdG9yKHZhcnMsIHBsYWNlaG9sZGVycywgc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVycztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEljdSh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBSZWN1cnNpdmVWaXNpdG9yJDEge1xuICAgIHZpc2l0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBlbGVtZW50LmlucHV0cyk7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5vdXRwdXRzKTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBlbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBlbGVtZW50LnJlZmVyZW5jZXMpO1xuICAgIH1cbiAgICB2aXNpdFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgdGVtcGxhdGUuYXR0cmlidXRlcyk7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgdGVtcGxhdGUuaW5wdXRzKTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB0ZW1wbGF0ZS5vdXRwdXRzKTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB0ZW1wbGF0ZS5jaGlsZHJlbik7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgdGVtcGxhdGUucmVmZXJlbmNlcyk7XG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgdGVtcGxhdGUudmFyaWFibGVzKTtcbiAgICB9XG4gICAgdmlzaXRDb250ZW50KGNvbnRlbnQpIHsgfVxuICAgIHZpc2l0VmFyaWFibGUodmFyaWFibGUpIHsgfVxuICAgIHZpc2l0UmVmZXJlbmNlKHJlZmVyZW5jZSkgeyB9XG4gICAgdmlzaXRUZXh0QXR0cmlidXRlKGF0dHJpYnV0ZSkgeyB9XG4gICAgdmlzaXRCb3VuZEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0Qm91bmRFdmVudChhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdEJvdW5kVGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdEljdShpY3UpIHsgfVxufVxuZnVuY3Rpb24gdmlzaXRBbGwkMSh2aXNpdG9yLCBub2Rlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICh2aXNpdG9yLnZpc2l0KSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgdmlzaXRvci52aXNpdChub2RlKSB8fCBub2RlLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSBub2RlLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBub2RlcyBtZXNzYWdlIEFTVFxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlcnMgbWFwcyBwbGFjZWhvbGRlciBuYW1lcyB0byBzdGF0aWMgY29udGVudCBhbmQgdGhlaXIgc291cmNlIHNwYW5zXG4gICAgICogQHBhcmFtIHBsYWNlaG9sZGVyVG9NZXNzYWdlIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gbWVzc2FnZXMgKHVzZWQgZm9yIG5lc3RlZCBJQ1UgbWVzc2FnZXMpXG4gICAgICogQHBhcmFtIG1lYW5pbmdcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0gY3VzdG9tSWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlcywgcGxhY2Vob2xkZXJzLCBwbGFjZWhvbGRlclRvTWVzc2FnZSwgbWVhbmluZywgZGVzY3JpcHRpb24sIGN1c3RvbUlkKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMgPSBwbGFjZWhvbGRlcnM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2UgPSBwbGFjZWhvbGRlclRvTWVzc2FnZTtcbiAgICAgICAgdGhpcy5tZWFuaW5nID0gbWVhbmluZztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmN1c3RvbUlkID0gY3VzdG9tSWQ7XG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmN1c3RvbUlkO1xuICAgICAgICAvKiogVGhlIGlkcyB0byB1c2UgaWYgdGhlcmUgYXJlIG5vIGN1c3RvbSBpZCBhbmQgaWYgYGkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXRgIGlzIG5vdCBlbXB0eSAqL1xuICAgICAgICB0aGlzLmxlZ2FjeUlkcyA9IFtdO1xuICAgICAgICB0aGlzLm1lc3NhZ2VTdHJpbmcgPSBzZXJpYWxpemVNZXNzYWdlKHRoaXMubm9kZXMpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aDogbm9kZXNbMF0uc291cmNlU3Bhbi5zdGFydC5maWxlLnVybCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMaW5lOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmxpbmUgKyAxLFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbDogbm9kZXNbMF0uc291cmNlU3Bhbi5zdGFydC5jb2wgKyAxLFxuICAgICAgICAgICAgICAgICAgICBlbmRMaW5lOiBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS5zb3VyY2VTcGFuLmVuZC5saW5lICsgMSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29sOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmNvbCArIDFcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVGV4dCQyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8vIFRPRE8odmljYik6IGRvIHdlIHJlYWxseSBuZWVkIHRoaXMgbm9kZSAodnMgYW4gYXJyYXkpID9cbmNsYXNzIENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGFpbmVyKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEljdSB7XG4gICAgY29uc3RydWN0b3IoZXhwcmVzc2lvbiwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SWN1KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFRhZ1BsYWNlaG9sZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGF0dHJzLCBzdGFydE5hbWUsIGNsb3NlTmFtZSwgY2hpbGRyZW4sIGlzVm9pZCwgXG4gICAgLy8gVE9ETyBzb3VyY2VTcGFuIHNob3VsZCBjb3ZlciBhbGwgKHdlIG5lZWQgYSBzdGFydFNvdXJjZVNwYW4gYW5kIGVuZFNvdXJjZVNwYW4pXG4gICAgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3RhcnROYW1lID0gc3RhcnROYW1lO1xuICAgICAgICB0aGlzLmNsb3NlTmFtZSA9IGNsb3NlTmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5zdGFydFNvdXJjZVNwYW4gPSBzdGFydFNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZW5kU291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBQbGFjZWhvbGRlciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGxhY2Vob2xkZXIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgSWN1UGxhY2Vob2xkZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEljdVBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8vIENsb25lIHRoZSBBU1RcbmNsYXNzIENsb25lVmlzaXRvciB7XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDIodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuLm1hcChuID0+IG4udmlzaXQodGhpcywgY29udGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lcihjaGlsZHJlbiwgY29udGFpbmVyLnNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEljdShpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGtleSA9PiBjYXNlc1trZXldID0gaWN1LmNhc2VzW2tleV0udmlzaXQodGhpcywgY29udGV4dCkpO1xuICAgICAgICBjb25zdCBtc2cgPSBuZXcgSWN1KGljdS5leHByZXNzaW9uLCBpY3UudHlwZSwgY2FzZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgbXNnLmV4cHJlc3Npb25QbGFjZWhvbGRlciA9IGljdS5leHByZXNzaW9uUGxhY2Vob2xkZXI7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAobiA9PiBuLnZpc2l0KHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWdQbGFjZWhvbGRlcihwaC50YWcsIHBoLmF0dHJzLCBwaC5zdGFydE5hbWUsIHBoLmNsb3NlTmFtZSwgY2hpbGRyZW4sIHBoLmlzVm9pZCwgcGguc291cmNlU3BhbiwgcGguc3RhcnRTb3VyY2VTcGFuLCBwaC5lbmRTb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKHBoLnZhbHVlLCBwaC5uYW1lLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEljdVBsYWNlaG9sZGVyKHBoLnZhbHVlLCBwaC5uYW1lLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9XG59XG4vLyBWaXNpdCBhbGwgdGhlIG5vZGVzIHJlY3Vyc2l2ZWx5XG5jbGFzcyBSZWN1cnNlVmlzaXRvciB7XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpY3UuY2FzZXNba10udmlzaXQodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHBoLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7IH1cbn1cbi8qKlxuICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIHRoZSBMb2NhbGl6ZSBiYWNrdGljayBzdHJpbmcgZm9ybWF0IHRoYXQgd291bGQgYXBwZWFyIGluIGNvbXBpbGVkIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU1lc3NhZ2UobWVzc2FnZU5vZGVzKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBMb2NhbGl6ZU1lc3NhZ2VTdHJpbmdWaXNpdG9yKCk7XG4gICAgY29uc3Qgc3RyID0gbWVzc2FnZU5vZGVzLm1hcChuID0+IG4udmlzaXQodmlzaXRvcikpLmpvaW4oJycpO1xuICAgIHJldHVybiBzdHI7XG59XG5jbGFzcyBMb2NhbGl6ZU1lc3NhZ2VTdHJpbmdWaXNpdG9yIHtcbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1KSB7XG4gICAgICAgIGNvbnN0IHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoKGspID0+IGAke2t9IHske2ljdS5jYXNlc1trXS52aXNpdCh0aGlzKX19YCk7XG4gICAgICAgIHJldHVybiBgeyR7aWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlcn0sICR7aWN1LnR5cGV9LCAke3N0ckNhc2VzLmpvaW4oJyAnKX19YDtcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSkuam9pbignJyk7XG4gICAgICAgIHJldHVybiBgeyQke3BoLnN0YXJ0TmFtZX19JHtjaGlsZHJlbn17JCR7cGguY2xvc2VOYW1lfX1gO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHJldHVybiBgeyQke3BoLm5hbWV9fWA7XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgcmV0dXJuIGB7JCR7cGgubmFtZX19YDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgU2VyaWFsaXplciB7XG4gICAgLy8gQ3JlYXRlcyBhIG5hbWUgbWFwcGVyLCBzZWUgYFBsYWNlaG9sZGVyTWFwcGVyYFxuICAgIC8vIFJldHVybmluZyBgbnVsbGAgbWVhbnMgdGhhdCBubyBuYW1lIG1hcHBpbmcgaXMgdXNlZC5cbiAgICBjcmVhdGVOYW1lTWFwcGVyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNpbXBsZSBtYXBwZXIgdGhhdCB0YWtlIGEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGFuIGludGVybmFsIG5hbWUgdG8gYSBwdWJsaWMgbmFtZVxuICovXG5jbGFzcyBTaW1wbGVQbGFjZWhvbGRlck1hcHBlciBleHRlbmRzIFJlY3Vyc2VWaXNpdG9yIHtcbiAgICAvLyBjcmVhdGUgYSBtYXBwaW5nIGZyb20gdGhlIG1lc3NhZ2VcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBtYXBOYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFwTmFtZSA9IG1hcE5hbWU7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpYyA9IHt9O1xuICAgICAgICB0aGlzLnB1YmxpY1RvTmV4dElkID0ge307XG4gICAgICAgIHRoaXMucHVibGljVG9JbnRlcm5hbCA9IHt9O1xuICAgICAgICBtZXNzYWdlLm5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgdG9QdWJsaWNOYW1lKGludGVybmFsTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFRvUHVibGljLmhhc093blByb3BlcnR5KGludGVybmFsTmFtZSkgP1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFRvUHVibGljW2ludGVybmFsTmFtZV0gOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgdG9JbnRlcm5hbE5hbWUocHVibGljTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNUb0ludGVybmFsLmhhc093blByb3BlcnR5KHB1YmxpY05hbWUpID8gdGhpcy5wdWJsaWNUb0ludGVybmFsW3B1YmxpY05hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGguc3RhcnROYW1lKTtcbiAgICAgICAgc3VwZXIudmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGguY2xvc2VOYW1lKTtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRQbGFjZWhvbGRlck5hbWUocGgubmFtZSk7XG4gICAgfVxuICAgIC8vIFhNQiBwbGFjZWhvbGRlcnMgY291bGQgb25seSBjb250YWlucyBBLVosIDAtOSBhbmQgX1xuICAgIHZpc2l0UGxhY2Vob2xkZXJOYW1lKGludGVybmFsTmFtZSkge1xuICAgICAgICBpZiAoIWludGVybmFsTmFtZSB8fCB0aGlzLmludGVybmFsVG9QdWJsaWMuaGFzT3duUHJvcGVydHkoaW50ZXJuYWxOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdWJsaWNOYW1lID0gdGhpcy5tYXBOYW1lKGludGVybmFsTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY1RvSW50ZXJuYWwuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBYTUIgd2hlbiBpdCBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAgICAgICAgIGNvbnN0IG5leHRJZCA9IHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV07XG4gICAgICAgICAgICB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdID0gbmV4dElkICsgMTtcbiAgICAgICAgICAgIHB1YmxpY05hbWUgPSBgJHtwdWJsaWNOYW1lfV8ke25leHRJZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdWJsaWNUb05leHRJZFtwdWJsaWNOYW1lXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcm5hbFRvUHVibGljW2ludGVybmFsTmFtZV0gPSBwdWJsaWNOYW1lO1xuICAgICAgICB0aGlzLnB1YmxpY1RvSW50ZXJuYWxbcHVibGljTmFtZV0gPSBpbnRlcm5hbE5hbWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIF9WaXNpdG9yJDIge1xuICAgIHZpc2l0VGFnKHRhZykge1xuICAgICAgICBjb25zdCBzdHJBdHRycyA9IHRoaXMuX3NlcmlhbGl6ZUF0dHJpYnV0ZXModGFnLmF0dHJzKTtcbiAgICAgICAgaWYgKHRhZy5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGA8JHt0YWcubmFtZX0ke3N0ckF0dHJzfS8+YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJDaGlsZHJlbiA9IHRhZy5jaGlsZHJlbi5tYXAobm9kZSA9PiBub2RlLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIGA8JHt0YWcubmFtZX0ke3N0ckF0dHJzfT4ke3N0ckNoaWxkcmVuLmpvaW4oJycpfTwvJHt0YWcubmFtZX0+YDtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQudmFsdWU7XG4gICAgfVxuICAgIHZpc2l0RGVjbGFyYXRpb24oZGVjbCkge1xuICAgICAgICByZXR1cm4gYDw/eG1sJHt0aGlzLl9zZXJpYWxpemVBdHRyaWJ1dGVzKGRlY2wuYXR0cnMpfSA/PmA7XG4gICAgfVxuICAgIF9zZXJpYWxpemVBdHRyaWJ1dGVzKGF0dHJzKSB7XG4gICAgICAgIGNvbnN0IHN0ckF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpLm1hcCgobmFtZSkgPT4gYCR7bmFtZX09XCIke2F0dHJzW25hbWVdfVwiYCkuam9pbignICcpO1xuICAgICAgICByZXR1cm4gc3RyQXR0cnMubGVuZ3RoID4gMCA/ICcgJyArIHN0ckF0dHJzIDogJyc7XG4gICAgfVxuICAgIHZpc2l0RG9jdHlwZShkb2N0eXBlKSB7XG4gICAgICAgIHJldHVybiBgPCFET0NUWVBFICR7ZG9jdHlwZS5yb290VGFnfSBbXFxuJHtkb2N0eXBlLmR0ZH1cXG5dPmA7XG4gICAgfVxufVxuY29uc3QgX3Zpc2l0b3IgPSBuZXcgX1Zpc2l0b3IkMigpO1xuZnVuY3Rpb24gc2VyaWFsaXplKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcCgobm9kZSkgPT4gbm9kZS52aXNpdChfdmlzaXRvcikpLmpvaW4oJycpO1xufVxuY2xhc3MgRGVjbGFyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHVuZXNjYXBlZEF0dHJzKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModW5lc2NhcGVkQXR0cnMpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXR0cnNba10gPSBlc2NhcGVYbWwodW5lc2NhcGVkQXR0cnNba10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmF0aW9uKHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIERvY3R5cGUge1xuICAgIGNvbnN0cnVjdG9yKHJvb3RUYWcsIGR0ZCkge1xuICAgICAgICB0aGlzLnJvb3RUYWcgPSByb290VGFnO1xuICAgICAgICB0aGlzLmR0ZCA9IGR0ZDtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERvY3R5cGUodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgVGFnIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB1bmVzY2FwZWRBdHRycyA9IHt9LCBjaGlsZHJlbiA9IFtdKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh1bmVzY2FwZWRBdHRycykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdHRyc1trXSA9IGVzY2FwZVhtbCh1bmVzY2FwZWRBdHRyc1trXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGFnKHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIFRleHQkMSB7XG4gICAgY29uc3RydWN0b3IodW5lc2NhcGVkVmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGVzY2FwZVhtbCh1bmVzY2FwZWRWYWx1ZSk7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENSIGV4dGVuZHMgVGV4dCQxIHtcbiAgICBjb25zdHJ1Y3Rvcih3cyA9IDApIHtcbiAgICAgICAgc3VwZXIoYFxcbiR7bmV3IEFycmF5KHdzICsgMSkuam9pbignICcpfWApO1xuICAgIH1cbn1cbmNvbnN0IF9FU0NBUEVEX0NIQVJTID0gW1xuICAgIFsvJi9nLCAnJmFtcDsnXSxcbiAgICBbL1wiL2csICcmcXVvdDsnXSxcbiAgICBbLycvZywgJyZhcG9zOyddLFxuICAgIFsvPC9nLCAnJmx0OyddLFxuICAgIFsvPi9nLCAnJmd0OyddLFxuXTtcbi8vIEVzY2FwZSBgX0VTQ0FQRURfQ0hBUlNgIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHRleHQgd2l0aCBlbmNvZGVkIGVudGl0aWVzXG5mdW5jdGlvbiBlc2NhcGVYbWwodGV4dCkge1xuICAgIHJldHVybiBfRVNDQVBFRF9DSEFSUy5yZWR1Y2UoKHRleHQsIGVudHJ5KSA9PiB0ZXh0LnJlcGxhY2UoZW50cnlbMF0sIGVudHJ5WzFdKSwgdGV4dCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgX01FU1NBR0VTX1RBRyA9ICdtZXNzYWdlYnVuZGxlJztcbmNvbnN0IF9NRVNTQUdFX1RBRyA9ICdtc2cnO1xuY29uc3QgX1BMQUNFSE9MREVSX1RBRyQzID0gJ3BoJztcbmNvbnN0IF9FWEFNUExFX1RBRyA9ICdleCc7XG5jb25zdCBfU09VUkNFX1RBRyQyID0gJ3NvdXJjZSc7XG5jb25zdCBfRE9DVFlQRSA9IGA8IUVMRU1FTlQgbWVzc2FnZWJ1bmRsZSAobXNnKSo+XG48IUFUVExJU1QgbWVzc2FnZWJ1bmRsZSBjbGFzcyBDREFUQSAjSU1QTElFRD5cblxuPCFFTEVNRU5UIG1zZyAoI1BDREFUQXxwaHxzb3VyY2UpKj5cbjwhQVRUTElTVCBtc2cgaWQgQ0RBVEEgI0lNUExJRUQ+XG48IUFUVExJU1QgbXNnIHNlcSBDREFUQSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgbmFtZSBDREFUQSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgZGVzYyBDREFUQSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgbWVhbmluZyBDREFUQSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgb2Jzb2xldGUgKG9ic29sZXRlKSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgeG1sOnNwYWNlIChkZWZhdWx0fHByZXNlcnZlKSBcImRlZmF1bHRcIj5cbjwhQVRUTElTVCBtc2cgaXNfaGlkZGVuIENEQVRBICNJTVBMSUVEPlxuXG48IUVMRU1FTlQgc291cmNlICgjUENEQVRBKT5cblxuPCFFTEVNRU5UIHBoICgjUENEQVRBfGV4KSo+XG48IUFUVExJU1QgcGggbmFtZSBDREFUQSAjUkVRVUlSRUQ+XG5cbjwhRUxFTUVOVCBleCAoI1BDREFUQSk+YDtcbmNsYXNzIFhtYiBleHRlbmRzIFNlcmlhbGl6ZXIge1xuICAgIHdyaXRlKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgY29uc3QgZXhhbXBsZVZpc2l0b3IgPSBuZXcgRXhhbXBsZVZpc2l0b3IoKTtcbiAgICAgICAgY29uc3QgdmlzaXRvciA9IG5ldyBfVmlzaXRvciQxKCk7XG4gICAgICAgIGxldCByb290Tm9kZSA9IG5ldyBUYWcoX01FU1NBR0VTX1RBRyk7XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHsgaWQ6IG1lc3NhZ2UuaWQgfTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNbJ2Rlc2MnXSA9IG1lc3NhZ2UuZGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNbJ21lYW5pbmcnXSA9IG1lc3NhZ2UubWVhbmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzb3VyY2VUYWdzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgc291cmNlVGFncy5wdXNoKG5ldyBUYWcoX1NPVVJDRV9UQUckMiwge30sIFtuZXcgVGV4dCQxKGAke3NvdXJjZS5maWxlUGF0aH06JHtzb3VyY2Uuc3RhcnRMaW5lfSR7c291cmNlLmVuZExpbmUgIT09IHNvdXJjZS5zdGFydExpbmUgPyAnLCcgKyBzb3VyY2UuZW5kTGluZSA6ICcnfWApXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigyKSwgbmV3IFRhZyhfTUVTU0FHRV9UQUcsIGF0dHJzLCBbLi4uc291cmNlVGFncywgLi4udmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcyldKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigpKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksXG4gICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgICAgIG5ldyBEb2N0eXBlKF9NRVNTQUdFU19UQUcsIF9ET0NUWVBFKSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgZXhhbXBsZVZpc2l0b3IuYWRkRGVmYXVsdEV4YW1wbGVzKHJvb3ROb2RlKSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgbG9hZChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBkaWdlc3QobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZGlnZXN0KG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjcmVhdGVOYW1lTWFwcGVyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVQbGFjZWhvbGRlck1hcHBlcihtZXNzYWdlLCB0b1B1YmxpY05hbWUpO1xuICAgIH1cbn1cbmNsYXNzIF9WaXNpdG9yJDEge1xuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRleHQkMSh0ZXh0LnZhbHVlKV07XG4gICAgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaCgobm9kZSkgPT4gbm9kZXMucHVzaCguLi5ub2RlLnZpc2l0KHRoaXMpKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gW25ldyBUZXh0JDEoYHske2ljdS5leHByZXNzaW9uUGxhY2Vob2xkZXJ9LCAke2ljdS50eXBlfSwgYCldO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShgJHtjfSB7YCksIC4uLmljdS5jYXNlc1tjXS52aXNpdCh0aGlzKSwgbmV3IFRleHQkMShgfSBgKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoYH1gKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBzdGFydFRhZ0FzVGV4dCA9IG5ldyBUZXh0JDEoYDwke3BoLnRhZ30+YCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0RXggPSBuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtzdGFydFRhZ0FzVGV4dF0pO1xuICAgICAgICAvLyBUQyByZXF1aXJlcyBQSCB0byBoYXZlIGEgbm9uIGVtcHR5IEVYLCBhbmQgdXNlcyB0aGUgdGV4dCBub2RlIHRvIHNob3cgdGhlIFwib3JpZ2luYWxcIiB2YWx1ZS5cbiAgICAgICAgY29uc3Qgc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQzLCB7IG5hbWU6IHBoLnN0YXJ0TmFtZSB9LCBbc3RhcnRFeCwgc3RhcnRUYWdBc1RleHRdKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9zZVRhZ0FzVGV4dCA9IG5ldyBUZXh0JDEoYDwvJHtwaC50YWd9PmApO1xuICAgICAgICBjb25zdCBjbG9zZUV4ID0gbmV3IFRhZyhfRVhBTVBMRV9UQUcsIHt9LCBbY2xvc2VUYWdBc1RleHRdKTtcbiAgICAgICAgLy8gVEMgcmVxdWlyZXMgUEggdG8gaGF2ZSBhIG5vbiBlbXB0eSBFWCwgYW5kIHVzZXMgdGhlIHRleHQgbm9kZSB0byBzaG93IHRoZSBcIm9yaWdpbmFsXCIgdmFsdWUuXG4gICAgICAgIGNvbnN0IGNsb3NlVGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMywgeyBuYW1lOiBwaC5jbG9zZU5hbWUgfSwgW2Nsb3NlRXgsIGNsb3NlVGFnQXNUZXh0XSk7XG4gICAgICAgIHJldHVybiBbc3RhcnRUYWdQaCwgLi4udGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBjbG9zZVRhZ1BoXTtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uQXNUZXh0ID0gbmV3IFRleHQkMShge3ske3BoLnZhbHVlfX19YCk7XG4gICAgICAgIC8vIEV4YW1wbGUgdGFnIG5lZWRzIHRvIGJlIG5vdC1lbXB0eSBmb3IgVEMuXG4gICAgICAgIGNvbnN0IGV4VGFnID0gbmV3IFRhZyhfRVhBTVBMRV9UQUcsIHt9LCBbaW50ZXJwb2xhdGlvbkFzVGV4dF0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gVEMgcmVxdWlyZXMgUEggdG8gaGF2ZSBhIG5vbiBlbXB0eSBFWCwgYW5kIHVzZXMgdGhlIHRleHQgbm9kZSB0byBzaG93IHRoZSBcIm9yaWdpbmFsXCIgdmFsdWUuXG4gICAgICAgICAgICBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMywgeyBuYW1lOiBwaC5uYW1lIH0sIFtleFRhZywgaW50ZXJwb2xhdGlvbkFzVGV4dF0pXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaWN1RXhwcmVzc2lvbiA9IHBoLnZhbHVlLmV4cHJlc3Npb247XG4gICAgICAgIGNvbnN0IGljdVR5cGUgPSBwaC52YWx1ZS50eXBlO1xuICAgICAgICBjb25zdCBpY3VDYXNlcyA9IE9iamVjdC5rZXlzKHBoLnZhbHVlLmNhc2VzKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZSArICcgey4uLn0nKS5qb2luKCcgJyk7XG4gICAgICAgIGNvbnN0IGljdUFzVGV4dCA9IG5ldyBUZXh0JDEoYHske2ljdUV4cHJlc3Npb259LCAke2ljdVR5cGV9LCAke2ljdUNhc2VzfX1gKTtcbiAgICAgICAgY29uc3QgZXhUYWcgPSBuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtpY3VBc1RleHRdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFRDIHJlcXVpcmVzIFBIIHRvIGhhdmUgYSBub24gZW1wdHkgRVgsIGFuZCB1c2VzIHRoZSB0ZXh0IG5vZGUgdG8gc2hvdyB0aGUgXCJvcmlnaW5hbFwiIHZhbHVlLlxuICAgICAgICAgICAgbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDMsIHsgbmFtZTogcGgubmFtZSB9LCBbZXhUYWcsIGljdUFzVGV4dF0pXG4gICAgICAgIF07XG4gICAgfVxuICAgIHNlcmlhbGl6ZShub2Rlcykge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KC4uLm5vZGVzLm1hcChub2RlID0+IG5vZGUudmlzaXQodGhpcykpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaWdlc3QobWVzc2FnZSkge1xuICAgIHJldHVybiBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpO1xufVxuLy8gVEMgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIG5vbi1lbXB0eSBleGFtcGxlIG9uIHBsYWNlaG9sZGVyc1xuY2xhc3MgRXhhbXBsZVZpc2l0b3Ige1xuICAgIGFkZERlZmF1bHRFeGFtcGxlcyhub2RlKSB7XG4gICAgICAgIG5vZGUudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB2aXNpdFRhZyh0YWcpIHtcbiAgICAgICAgaWYgKHRhZy5uYW1lID09PSBfUExBQ0VIT0xERVJfVEFHJDMpIHtcbiAgICAgICAgICAgIGlmICghdGFnLmNoaWxkcmVuIHx8IHRhZy5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4VGV4dCA9IG5ldyBUZXh0JDEodGFnLmF0dHJzWyduYW1lJ10gfHwgJy4uLicpO1xuICAgICAgICAgICAgICAgIHRhZy5jaGlsZHJlbiA9IFtuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtleFRleHRdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0YWcuY2hpbGRyZW4uZm9yRWFjaChub2RlID0+IG5vZGUudmlzaXQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdERlY2xhcmF0aW9uKGRlY2wpIHsgfVxuICAgIHZpc2l0RG9jdHlwZShkb2N0eXBlKSB7IH1cbn1cbi8vIFhNQi9YVEIgcGxhY2Vob2xkZXJzIGNhbiBvbmx5IGNvbnRhaW4gQS1aLCAwLTkgYW5kIF9cbmZ1bmN0aW9uIHRvUHVibGljTmFtZShpbnRlcm5hbE5hbWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxOYW1lLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvW15BLVowLTlfXS9nLCAnXycpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qIENsb3N1cmUgdmFyaWFibGVzIGhvbGRpbmcgbWVzc2FnZXMgbXVzdCBiZSBuYW1lZCBgTVNHX1tBLVowLTldK2AgKi9cbmNvbnN0IENMT1NVUkVfVFJBTlNMQVRJT05fVkFSX1BSRUZJWCA9ICdNU0dfJztcbi8qKlxuICogUHJlZml4IGZvciBub24tYGdvb2cuZ2V0TXNnYCBpMThuLXJlbGF0ZWQgdmFycy5cbiAqIE5vdGU6IHRoZSBwcmVmaXggdXNlcyBsb3dlcmNhc2UgY2hhcmFjdGVycyBpbnRlbnRpb25hbGx5IGR1ZSB0byBhIENsb3N1cmUgYmVoYXZpb3IgdGhhdFxuICogY29uc2lkZXJzIHZhcmlhYmxlcyBsaWtlIGBJMThOXzBgIGFzIGNvbnN0YW50cyBhbmQgdGhyb3dzIGFuIGVycm9yIHdoZW4gdGhlaXIgdmFsdWUgY2hhbmdlcy5cbiAqL1xuY29uc3QgVFJBTlNMQVRJT05fVkFSX1BSRUZJWCA9ICdpMThuXyc7XG4vKiogTmFtZSBvZiB0aGUgaTE4biBhdHRyaWJ1dGVzICoqL1xuY29uc3QgSTE4Tl9BVFRSID0gJ2kxOG4nO1xuY29uc3QgSTE4Tl9BVFRSX1BSRUZJWCA9ICdpMThuLSc7XG4vKiogUHJlZml4IG9mIHZhciBleHByZXNzaW9ucyB1c2VkIGluIElDVXMgKi9cbmNvbnN0IEkxOE5fSUNVX1ZBUl9QUkVGSVggPSAnVkFSXyc7XG4vKiogUHJlZml4IG9mIElDVSBleHByZXNzaW9ucyBmb3IgcG9zdCBwcm9jZXNzaW5nICovXG5jb25zdCBJMThOX0lDVV9NQVBQSU5HX1BSRUZJWCA9ICdJMThOX0VYUF8nO1xuLyoqIFBsYWNlaG9sZGVyIHdyYXBwZXIgZm9yIGkxOG4gZXhwcmVzc2lvbnMgKiovXG5jb25zdCBJMThOX1BMQUNFSE9MREVSX1NZTUJPTCA9ICfvv70nO1xuZnVuY3Rpb24gaXNJMThuQXR0cmlidXRlKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSA9PT0gSTE4Tl9BVFRSIHx8IG5hbWUuc3RhcnRzV2l0aChJMThOX0FUVFJfUFJFRklYKTtcbn1cbmZ1bmN0aW9uIGlzSTE4blJvb3ROb2RlKG1ldGEpIHtcbiAgICByZXR1cm4gbWV0YSBpbnN0YW5jZW9mIE1lc3NhZ2U7XG59XG5mdW5jdGlvbiBpc1NpbmdsZUkxOG5JY3UobWV0YSkge1xuICAgIHJldHVybiBpc0kxOG5Sb290Tm9kZShtZXRhKSAmJiBtZXRhLm5vZGVzLmxlbmd0aCA9PT0gMSAmJiBtZXRhLm5vZGVzWzBdIGluc3RhbmNlb2YgSWN1O1xufVxuZnVuY3Rpb24gaGFzSTE4bk1ldGEobm9kZSkge1xuICAgIHJldHVybiAhIW5vZGUuaTE4bjtcbn1cbmZ1bmN0aW9uIGhhc0kxOG5BdHRycyhlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuYXR0cnMuc29tZSgoYXR0cikgPT4gaXNJMThuQXR0cmlidXRlKGF0dHIubmFtZSkpO1xufVxuZnVuY3Rpb24gaWN1RnJvbUkxOG5NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5ub2Rlc1swXTtcbn1cbmZ1bmN0aW9uIHdyYXBJMThuUGxhY2Vob2xkZXIoY29udGVudCwgY29udGV4dElkID0gMCkge1xuICAgIGNvbnN0IGJsb2NrSWQgPSBjb250ZXh0SWQgPiAwID8gYDoke2NvbnRleHRJZH1gIDogJyc7XG4gICAgcmV0dXJuIGAke0kxOE5fUExBQ0VIT0xERVJfU1lNQk9MfSR7Y29udGVudH0ke2Jsb2NrSWR9JHtJMThOX1BMQUNFSE9MREVSX1NZTUJPTH1gO1xufVxuZnVuY3Rpb24gYXNzZW1ibGVJMThuQm91bmRTdHJpbmcoc3RyaW5ncywgYmluZGluZ1N0YXJ0SW5kZXggPSAwLCBjb250ZXh0SWQgPSAwKSB7XG4gICAgaWYgKCFzdHJpbmdzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGxldCBhY2MgPSAnJztcbiAgICBjb25zdCBsYXN0SWR4ID0gc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdElkeDsgaSsrKSB7XG4gICAgICAgIGFjYyArPSBgJHtzdHJpbmdzW2ldfSR7d3JhcEkxOG5QbGFjZWhvbGRlcihiaW5kaW5nU3RhcnRJbmRleCArIGksIGNvbnRleHRJZCl9YDtcbiAgICB9XG4gICAgYWNjICs9IHN0cmluZ3NbbGFzdElkeF07XG4gICAgcmV0dXJuIGFjYztcbn1cbmZ1bmN0aW9uIGdldFNlcU51bWJlckdlbmVyYXRvcihzdGFydHNBdCA9IDApIHtcbiAgICBsZXQgY3VycmVudCA9IHN0YXJ0c0F0O1xuICAgIHJldHVybiAoKSA9PiBjdXJyZW50Kys7XG59XG5mdW5jdGlvbiBwbGFjZWhvbGRlcnNUb1BhcmFtcyhwbGFjZWhvbGRlcnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgICBwbGFjZWhvbGRlcnMuZm9yRWFjaCgodmFsdWVzLCBrZXkpID0+IHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSBsaXRlcmFsKHZhbHVlcy5sZW5ndGggPiAxID8gYFske3ZhbHVlcy5qb2luKCd8Jyl9XWAgOiB2YWx1ZXNbMF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiB1cGRhdGVQbGFjZWhvbGRlck1hcChtYXAsIG5hbWUsIC4uLnZhbHVlcykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBtYXAuZ2V0KG5hbWUpIHx8IFtdO1xuICAgIGN1cnJlbnQucHVzaCguLi52YWx1ZXMpO1xuICAgIG1hcC5zZXQobmFtZSwgY3VycmVudCk7XG59XG5mdW5jdGlvbiBhc3NlbWJsZUJvdW5kVGV4dFBsYWNlaG9sZGVycyhtZXRhLCBiaW5kaW5nU3RhcnRJbmRleCA9IDAsIGNvbnRleHRJZCA9IDApIHtcbiAgICBjb25zdCBzdGFydElkeCA9IGJpbmRpbmdTdGFydEluZGV4O1xuICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBub2RlID0gbWV0YSBpbnN0YW5jZW9mIE1lc3NhZ2UgPyBtZXRhLm5vZGVzLmZpbmQobm9kZSA9PiBub2RlIGluc3RhbmNlb2YgQ29udGFpbmVyKSA6IG1ldGE7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbm9kZVxuICAgICAgICAgICAgLmNoaWxkcmVuXG4gICAgICAgICAgICAuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQgaW5zdGFuY2VvZiBQbGFjZWhvbGRlcilcbiAgICAgICAgICAgIC5mb3JFYWNoKChjaGlsZCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gd3JhcEkxOG5QbGFjZWhvbGRlcihzdGFydElkeCArIGlkeCwgY29udGV4dElkKTtcbiAgICAgICAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyTWFwKHBsYWNlaG9sZGVycywgY2hpbGQubmFtZSwgY29udGVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGxhY2Vob2xkZXJzO1xufVxuLyoqXG4gKiBGb3JtYXQgdGhlIHBsYWNlaG9sZGVyIG5hbWVzIGluIGEgbWFwIG9mIHBsYWNlaG9sZGVycyB0byBleHByZXNzaW9ucy5cbiAqXG4gKiBUaGUgcGxhY2Vob2xkZXIgbmFtZXMgYXJlIGNvbnZlcnRlZCBmcm9tIFwiaW50ZXJuYWxcIiBmb3JtYXQgKGUuZy4gYFNUQVJUX1RBR19ESVZfMWApIHRvIFwiZXh0ZXJuYWxcIlxuICogZm9ybWF0IChlLmcuIGBzdGFydFRhZ0Rpdl8xYCkuXG4gKlxuICogQHBhcmFtIHBhcmFtcyBBIG1hcCBvZiBwbGFjZWhvbGRlciBuYW1lcyB0byBleHByZXNzaW9ucy5cbiAqIEBwYXJhbSB1c2VDYW1lbENhc2Ugd2hldGhlciB0byBjYW1lbENhc2UgdGhlIHBsYWNlaG9sZGVyIG5hbWUgd2hlbiBmb3JtYXR0aW5nLlxuICogQHJldHVybnMgQSBuZXcgbWFwIG9mIGZvcm1hdHRlZCBwbGFjZWhvbGRlciBuYW1lcyB0byBleHByZXNzaW9ucy5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZXNJbk1hcChwYXJhbXMgPSB7fSwgdXNlQ2FtZWxDYXNlKSB7XG4gICAgY29uc3QgX3BhcmFtcyA9IHt9O1xuICAgIGlmIChwYXJhbXMgJiYgT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGgpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGtleSA9PiBfcGFyYW1zW2Zvcm1hdEkxOG5QbGFjZWhvbGRlck5hbWUoa2V5LCB1c2VDYW1lbENhc2UpXSA9IHBhcmFtc1trZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wYXJhbXM7XG59XG4vKipcbiAqIENvbnZlcnRzIGludGVybmFsIHBsYWNlaG9sZGVyIG5hbWVzIHRvIHB1YmxpYy1mYWNpbmcgZm9ybWF0XG4gKiAoZm9yIGV4YW1wbGUgdG8gdXNlIGluIGdvb2cuZ2V0TXNnIGNhbGwpLlxuICogRXhhbXBsZTogYFNUQVJUX1RBR19ESVZfMWAgaXMgY29udmVydGVkIHRvIGBzdGFydFRhZ0Rpdl8xYC5cbiAqXG4gKiBAcGFyYW0gbmFtZSBUaGUgcGxhY2Vob2xkZXIgbmFtZSB0aGF0IHNob3VsZCBiZSBmb3JtYXR0ZWRcbiAqIEByZXR1cm5zIEZvcm1hdHRlZCBwbGFjZWhvbGRlciBuYW1lXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEkxOG5QbGFjZWhvbGRlck5hbWUobmFtZSwgdXNlQ2FtZWxDYXNlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHB1YmxpY05hbWUgPSB0b1B1YmxpY05hbWUobmFtZSk7XG4gICAgaWYgKCF1c2VDYW1lbENhc2UpIHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY05hbWU7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rcyA9IHB1YmxpY05hbWUuc3BsaXQoJ18nKTtcbiAgICBpZiAoY2h1bmtzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBpZiBubyBcIl9cIiBmb3VuZCAtIGp1c3QgbG93ZXJjYXNlIHRoZSB2YWx1ZVxuICAgICAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBsZXQgcG9zdGZpeDtcbiAgICAvLyBlamVjdCBsYXN0IGVsZW1lbnQgaWYgaXQncyBhIG51bWJlclxuICAgIGlmICgvXlxcZCskLy50ZXN0KGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHBvc3RmaXggPSBjaHVua3MucG9wKCk7XG4gICAgfVxuICAgIGxldCByYXcgPSBjaHVua3Muc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgIHJhdyArPSBjaHVua3MubWFwKGMgPT4gYy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGMuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSkuam9pbignJyk7XG4gICAgfVxuICAgIHJldHVybiBwb3N0Zml4ID8gYCR7cmF3fV8ke3Bvc3RmaXh9YCA6IHJhdztcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgcHJlZml4IGZvciB0cmFuc2xhdGlvbiBjb25zdCBuYW1lLlxuICpcbiAqIEBwYXJhbSBleHRyYSBBZGRpdGlvbmFsIGxvY2FsIHByZWZpeCB0aGF0IHNob3VsZCBiZSBpbmplY3RlZCBpbnRvIHRyYW5zbGF0aW9uIHZhciBuYW1lXG4gKiBAcmV0dXJucyBDb21wbGV0ZSB0cmFuc2xhdGlvbiBjb25zdCBwcmVmaXhcbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb25Db25zdFByZWZpeChleHRyYSkge1xuICAgIHJldHVybiBgJHtDTE9TVVJFX1RSQU5TTEFUSU9OX1ZBUl9QUkVGSVh9JHtleHRyYX1gLnRvVXBwZXJDYXNlKCk7XG59XG4vKipcbiAqIEdlbmVyYXRlIEFTVCB0byBkZWNsYXJlIGEgdmFyaWFibGUuIEUuZy4gYHZhciBJMThOXzE7YC5cbiAqIEBwYXJhbSB2YXJpYWJsZSB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gZGVjbGFyZS5cbiAqL1xuZnVuY3Rpb24gZGVjbGFyZUkxOG5WYXJpYWJsZSh2YXJpYWJsZSkge1xuICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodmFyaWFibGUubmFtZSwgdW5kZWZpbmVkLCBJTkZFUlJFRF9UWVBFLCB1bmRlZmluZWQsIHZhcmlhYmxlLnNvdXJjZVNwYW4pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGtleSBjb250YWlucyBwb3RlbnRpYWxseSB1bnNhZmUgY2hhcnMsIHRodXMgdGhlIGtleSBzaG91bGQgYmUgd3JhcHBlZCBpblxuICogcXVvdGVzLiBOb3RlOiB3ZSBkbyBub3Qgd3JhcCBhbGwga2V5cyBpbnRvIHF1b3RlcywgYXMgaXQgbWF5IGhhdmUgaW1wYWN0IG9uIG1pbmlmaWNhdGlvbiBhbmQgbWF5XG4gKiBib3Qgd29yayBpbiBzb21lIGNhc2VzIHdoZW4gb2JqZWN0IGtleXMgYXJlIG1hbmdsZWQgYnkgbWluaWZpZXIuXG4gKlxuICogVE9ETyhGVy0xMTM2KTogdGhpcyBpcyBhIHRlbXBvcmFyeSBzb2x1dGlvbiwgd2UgbmVlZCB0byBjb21lIHVwIHdpdGggYSBiZXR0ZXIgd2F5IG9mIHdvcmtpbmcgd2l0aFxuICogaW5wdXRzIHRoYXQgY29udGFpbiBwb3RlbnRpYWxseSB1bnNhZmUgY2hhcnMuXG4gKi9cbmNvbnN0IFVOU0FGRV9PQkpFQ1RfS0VZX05BTUVfUkVHRVhQID0gL1stLl0vO1xuLyoqIE5hbWUgb2YgdGhlIHRlbXBvcmFyeSB0byB1c2UgZHVyaW5nIGRhdGEgYmluZGluZyAqL1xuY29uc3QgVEVNUE9SQVJZX05BTUUgPSAnX3QnO1xuLyoqIE5hbWUgb2YgdGhlIGNvbnRleHQgcGFyYW1ldGVyIHBhc3NlZCBpbnRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gKi9cbmNvbnN0IENPTlRFWFRfTkFNRSA9ICdjdHgnO1xuLyoqIE5hbWUgb2YgdGhlIFJlbmRlckZsYWcgcGFzc2VkIGludG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiAqL1xuY29uc3QgUkVOREVSX0ZMQUdTID0gJ3JmJztcbi8qKiBUaGUgcHJlZml4IHJlZmVyZW5jZSB2YXJpYWJsZXMgKi9cbmNvbnN0IFJFRkVSRU5DRV9QUkVGSVggPSAnX3InO1xuLyoqIFRoZSBuYW1lIG9mIHRoZSBpbXBsaWNpdCBjb250ZXh0IHJlZmVyZW5jZSAqL1xuY29uc3QgSU1QTElDSVRfUkVGRVJFTkNFID0gJyRpbXBsaWNpdCc7XG4vKiogTm9uIGJpbmRhYmxlIGF0dHJpYnV0ZSBuYW1lICoqL1xuY29uc3QgTk9OX0JJTkRBQkxFX0FUVFIgPSAnbmdOb25CaW5kYWJsZSc7XG4vKiogTmFtZSBmb3IgdGhlIHZhcmlhYmxlIGtlZXBpbmcgdHJhY2sgb2YgdGhlIGNvbnRleHQgcmV0dXJuZWQgYnkgYMm1ybVyZXN0b3JlVmlld2AuICovXG5jb25zdCBSRVNUT1JFRF9WSUVXX0NPTlRFWFRfTkFNRSA9ICdyZXN0b3JlZEN0eCc7XG4vKipcbiAqIE1heGltdW0gbGVuZ3RoIG9mIGEgc2luZ2xlIGluc3RydWN0aW9uIGNoYWluLiBCZWNhdXNlIG91ciBvdXRwdXQgQVNUIHVzZXMgcmVjdXJzaW9uLCB3ZSdyZVxuICogbGltaXRlZCBpbiBob3cgbWFueSBleHByZXNzaW9ucyB3ZSBjYW4gbmVzdCBiZWZvcmUgd2UgcmVhY2ggdGhlIGNhbGwgc3RhY2sgbGltaXQuIFRoaXNcbiAqIGxlbmd0aCBpcyBzZXQgdmVyeSBjb25zZXJ2YXRpdmVseSBpbiBvcmRlciB0byByZWR1Y2UgdGhlIGNoYW5jZSBvZiBwcm9ibGVtcy5cbiAqL1xuY29uc3QgTUFYX0NIQUlOX0xFTkdUSCA9IDUwMDtcbi8qKiBJbnN0cnVjdGlvbnMgdGhhdCBzdXBwb3J0IGNoYWluaW5nLiAqL1xuY29uc3QgQ0hBSU5BQkxFX0lOU1RSVUNUSU9OUyA9IG5ldyBTZXQoW1xuICAgIElkZW50aWZpZXJzLmVsZW1lbnQsXG4gICAgSWRlbnRpZmllcnMuZWxlbWVudFN0YXJ0LFxuICAgIElkZW50aWZpZXJzLmVsZW1lbnRFbmQsXG4gICAgSWRlbnRpZmllcnMuZWxlbWVudENvbnRhaW5lcixcbiAgICBJZGVudGlmaWVycy5lbGVtZW50Q29udGFpbmVyU3RhcnQsXG4gICAgSWRlbnRpZmllcnMuZWxlbWVudENvbnRhaW5lckVuZCxcbiAgICBJZGVudGlmaWVycy5pMThuRXhwLFxuICAgIElkZW50aWZpZXJzLmxpc3RlbmVyLFxuICAgIElkZW50aWZpZXJzLmNsYXNzUHJvcCxcbiAgICBJZGVudGlmaWVycy5zeW50aGV0aWNIb3N0TGlzdGVuZXIsXG4gICAgSWRlbnRpZmllcnMuaG9zdFByb3BlcnR5LFxuICAgIElkZW50aWZpZXJzLnN5bnRoZXRpY0hvc3RQcm9wZXJ0eSxcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eSxcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlMSxcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlMixcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlMyxcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNCxcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNSxcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNixcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNyxcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlOCxcbiAgICBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlVixcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGUsXG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUxLFxuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlMixcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTMsXG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU0LFxuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlNSxcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTYsXG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU3LFxuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlOCxcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZVYsXG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wLFxuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlMSxcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTIsXG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGUzLFxuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNCxcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTUsXG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU2LFxuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNyxcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTgsXG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGVWLFxuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZSxcbiAgICBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGUxLFxuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTIsXG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMyxcbiAgICBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU0LFxuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTUsXG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNixcbiAgICBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU3LFxuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTgsXG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlVixcbl0pO1xuLyoqIEdlbmVyYXRlcyBhIGNhbGwgdG8gYSBzaW5nbGUgaW5zdHJ1Y3Rpb24uICovXG5mdW5jdGlvbiBpbnZva2VJbnN0cnVjdGlvbihzcGFuLCByZWZlcmVuY2UsIHBhcmFtcykge1xuICAgIHJldHVybiBpbXBvcnRFeHByKHJlZmVyZW5jZSwgbnVsbCwgc3BhbikuY2FsbEZuKHBhcmFtcywgc3Bhbik7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gYWxsb2NhdG9yIGZvciBhIHRlbXBvcmFyeSB2YXJpYWJsZS5cbiAqXG4gKiBBIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBzdGF0ZW1lbnRzIHRoZSBmaXJzdCB0aW1lIHRoZSBhbGxvY2F0b3IgaXMgaW52b2tlZC5cbiAqL1xuZnVuY3Rpb24gdGVtcG9yYXJ5QWxsb2NhdG9yKHN0YXRlbWVudHMsIG5hbWUpIHtcbiAgICBsZXQgdGVtcCA9IG51bGw7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCF0ZW1wKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IERlY2xhcmVWYXJTdG10KFRFTVBPUkFSWV9OQU1FLCB1bmRlZmluZWQsIERZTkFNSUNfVFlQRSkpO1xuICAgICAgICAgICAgdGVtcCA9IHZhcmlhYmxlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wO1xuICAgIH07XG59XG5mdW5jdGlvbiBpbnZhbGlkKGFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZTogVmlzaXRvciAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gZG9lc24ndCBoYW5kbGUgJHthcmcuY29uc3RydWN0b3IubmFtZX1gKTtcbn1cbmZ1bmN0aW9uIGFzTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbEFycih2YWx1ZS5tYXAoYXNMaXRlcmFsKSk7XG4gICAgfVxuICAgIHJldHVybiBsaXRlcmFsKHZhbHVlLCBJTkZFUlJFRF9UWVBFKTtcbn1cbmZ1bmN0aW9uIGNvbmRpdGlvbmFsbHlDcmVhdGVNYXBPYmplY3RMaXRlcmFsKGtleXMsIGtlZXBEZWNsYXJlZCkge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhrZXlzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBtYXBUb0V4cHJlc3Npb24oa2V5cywga2VlcERlY2xhcmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYXBUb0V4cHJlc3Npb24obWFwLCBrZWVwRGVjbGFyZWQpIHtcbiAgICByZXR1cm4gbGl0ZXJhbE1hcChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtYXApLm1hcChrZXkgPT4ge1xuICAgICAgICAvLyBjYW5vbmljYWwgc3ludGF4OiBgZGlyUHJvcDogcHVibGljUHJvcGBcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gYDpgLCB1c2UgZGlyUHJvcCA9IGVsUHJvcFxuICAgICAgICBjb25zdCB2YWx1ZSA9IG1hcFtrZXldO1xuICAgICAgICBsZXQgZGVjbGFyZWROYW1lO1xuICAgICAgICBsZXQgcHVibGljTmFtZTtcbiAgICAgICAgbGV0IG1pbmlmaWVkTmFtZTtcbiAgICAgICAgbGV0IG5lZWRzRGVjbGFyZWROYW1lO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIFtwdWJsaWNOYW1lLCBkZWNsYXJlZE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBtaW5pZmllZE5hbWUgPSBrZXk7XG4gICAgICAgICAgICBuZWVkc0RlY2xhcmVkTmFtZSA9IHB1YmxpY05hbWUgIT09IGRlY2xhcmVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFtkZWNsYXJlZE5hbWUsIHB1YmxpY05hbWVdID0gc3BsaXRBdENvbG9uKGtleSwgW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgIG1pbmlmaWVkTmFtZSA9IGRlY2xhcmVkTmFtZTtcbiAgICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0aGUgZGVjbGFyZWQgbmFtZSBpZiBleHRyYWN0ZWQgZnJvbSB0aGUga2V5LCBpLmUuIHRoZSBrZXkgY29udGFpbnMgYSBjb2xvbi5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgZGVjbGFyZWQgbmFtZSBzaG91bGQgYmUgb21pdHRlZCBldmVuIGlmIGl0IGlzIGRpZmZlcmVudCBmcm9tIHRoZSBwdWJsaWMgbmFtZSxcbiAgICAgICAgICAgIC8vIGFzIGl0IG1heSBoYXZlIGFscmVhZHkgYmVlbiBtaW5pZmllZC5cbiAgICAgICAgICAgIG5lZWRzRGVjbGFyZWROYW1lID0gcHVibGljTmFtZSAhPT0gZGVjbGFyZWROYW1lICYmIGtleS5pbmNsdWRlcygnOicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IG1pbmlmaWVkTmFtZSxcbiAgICAgICAgICAgIC8vIHB1dCBxdW90ZXMgYXJvdW5kIGtleXMgdGhhdCBjb250YWluIHBvdGVudGlhbGx5IHVuc2FmZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBxdW90ZWQ6IFVOU0FGRV9PQkpFQ1RfS0VZX05BTUVfUkVHRVhQLnRlc3QobWluaWZpZWROYW1lKSxcbiAgICAgICAgICAgIHZhbHVlOiAoa2VlcERlY2xhcmVkICYmIG5lZWRzRGVjbGFyZWROYW1lKSA/XG4gICAgICAgICAgICAgICAgbGl0ZXJhbEFycihbYXNMaXRlcmFsKHB1YmxpY05hbWUpLCBhc0xpdGVyYWwoZGVjbGFyZWROYW1lKV0pIDpcbiAgICAgICAgICAgICAgICBhc0xpdGVyYWwocHVibGljTmFtZSlcbiAgICAgICAgfTtcbiAgICB9KSk7XG59XG4vKipcbiAqICBSZW1vdmUgdHJhaWxpbmcgbnVsbCBub2RlcyBhcyB0aGV5IGFyZSBpbXBsaWVkLlxuICovXG5mdW5jdGlvbiB0cmltVHJhaWxpbmdOdWxscyhwYXJhbWV0ZXJzKSB7XG4gICAgd2hpbGUgKGlzTnVsbChwYXJhbWV0ZXJzW3BhcmFtZXRlcnMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHBhcmFtZXRlcnMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuZnVuY3Rpb24gZ2V0UXVlcnlQcmVkaWNhdGUocXVlcnksIGNvbnN0YW50UG9vbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5LnByZWRpY2F0ZSkpIHtcbiAgICAgICAgbGV0IHByZWRpY2F0ZSA9IFtdO1xuICAgICAgICBxdWVyeS5wcmVkaWNhdGUuZm9yRWFjaCgoc2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIC8vIEVhY2ggaXRlbSBpbiBwcmVkaWNhdGVzIGFycmF5IG1heSBjb250YWluIHN0cmluZ3Mgd2l0aCBjb21tYS1zZXBhcmF0ZWQgcmVmc1xuICAgICAgICAgICAgLy8gKGZvciBleC4gJ3JlZiwgcmVmMSwgLi4uLCByZWZOJyksIHRodXMgd2UgZXh0cmFjdCBpbmRpdmlkdWFsIHJlZnMgYW5kIHN0b3JlIHRoZW1cbiAgICAgICAgICAgIC8vIGFzIHNlcGFyYXRlIGFycmF5IGVudGl0aWVzXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RvcnMgPSBzZWxlY3Rvci5zcGxpdCgnLCcpLm1hcCh0b2tlbiA9PiBsaXRlcmFsKHRva2VuLnRyaW0oKSkpO1xuICAgICAgICAgICAgcHJlZGljYXRlLnB1c2goLi4uc2VsZWN0b3JzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGxpdGVyYWxBcnIocHJlZGljYXRlKSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGUgb3JpZ2luYWwgcHJlZGljYXRlIG1heSBoYXZlIGJlZW4gd3JhcHBlZCBpbiBhIGBmb3J3YXJkUmVmKClgIGNhbGwuXG4gICAgICAgIHN3aXRjaCAocXVlcnkucHJlZGljYXRlLmZvcndhcmRSZWYpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBGb3J3YXJkUmVmSGFuZGxpbmcuTm9uZSAqLzpcbiAgICAgICAgICAgIGNhc2UgMiAvKiBGb3J3YXJkUmVmSGFuZGxpbmcuVW53cmFwcGVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeS5wcmVkaWNhdGUuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBGb3J3YXJkUmVmSGFuZGxpbmcuV3JhcHBlZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycy5yZXNvbHZlRm9yd2FyZFJlZikuY2FsbEZuKFtxdWVyeS5wcmVkaWNhdGUuZXhwcmVzc2lvbl0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIGZvciBhbiBvYmplY3QgbGl0ZXJhbCB1c2VkIGR1cmluZyBjb2RlZ2VuIG9mIGRlZmluaXRpb24gb2JqZWN0cy4gVGhlIGdlbmVyaWNcbiAqIHR5cGUgYFRgIGFsbG93cyB0byByZWZlcmVuY2UgYSBkb2N1bWVudGVkIHR5cGUgb2YgdGhlIGdlbmVyYXRlZCBzdHJ1Y3R1cmUsIHN1Y2ggdGhhdCB0aGVcbiAqIHByb3BlcnR5IG5hbWVzIHRoYXQgYXJlIHNldCBjYW4gYmUgcmVzb2x2ZWQgdG8gdGhlaXIgZG9jdW1lbnRlZCBkZWNsYXJhdGlvbi5cbiAqL1xuY2xhc3MgRGVmaW5pdGlvbk1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaCh7IGtleToga2V5LCB2YWx1ZSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0xpdGVyYWxNYXAoKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsTWFwKHRoaXMudmFsdWVzKTtcbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3QgYSBtYXAgb2YgcHJvcGVydGllcyB0byB2YWx1ZXMgZm9yIGEgZ2l2ZW4gZWxlbWVudCBvciB0ZW1wbGF0ZSBub2RlLCB3aGljaCBjYW4gYmUgdXNlZFxuICogYnkgdGhlIGRpcmVjdGl2ZSBtYXRjaGluZyBtYWNoaW5lcnkuXG4gKlxuICogQHBhcmFtIGVsT3JUcGwgdGhlIGVsZW1lbnQgb3IgdGVtcGxhdGUgaW4gcXVlc3Rpb25cbiAqIEByZXR1cm4gYW4gb2JqZWN0IHNldCB1cCBmb3IgZGlyZWN0aXZlIG1hdGNoaW5nLiBGb3IgYXR0cmlidXRlcyBvbiB0aGUgZWxlbWVudC90ZW1wbGF0ZSwgdGhpc1xuICogb2JqZWN0IG1hcHMgYSBwcm9wZXJ0eSBuYW1lIHRvIGl0cyAoc3RhdGljKSB2YWx1ZS4gRm9yIGFueSBiaW5kaW5ncywgdGhpcyBtYXAgc2ltcGx5IG1hcHMgdGhlXG4gKiBwcm9wZXJ0eSBuYW1lIHRvIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cnNGb3JEaXJlY3RpdmVNYXRjaGluZyhlbE9yVHBsKSB7XG4gICAgY29uc3QgYXR0cmlidXRlc01hcCA9IHt9O1xuICAgIGlmIChlbE9yVHBsIGluc3RhbmNlb2YgVGVtcGxhdGUgJiYgZWxPclRwbC50YWdOYW1lICE9PSAnbmctdGVtcGxhdGUnKSB7XG4gICAgICAgIGVsT3JUcGwudGVtcGxhdGVBdHRycy5mb3JFYWNoKGEgPT4gYXR0cmlidXRlc01hcFthLm5hbWVdID0gJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWxPclRwbC5hdHRyaWJ1dGVzLmZvckVhY2goYSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzSTE4bkF0dHJpYnV0ZShhLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc01hcFthLm5hbWVdID0gYS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVsT3JUcGwuaW5wdXRzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzTWFwW2kubmFtZV0gPSAnJztcbiAgICAgICAgfSk7XG4gICAgICAgIGVsT3JUcGwub3V0cHV0cy5mb3JFYWNoKG8gPT4ge1xuICAgICAgICAgICAgYXR0cmlidXRlc01hcFtvLm5hbWVdID0gJyc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlc01hcDtcbn1cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZCB0byBiZSBwYXNzZWQgdG8gYSBnZW5lcmF0ZWQgaW5zdHJ1Y3Rpb24gaW4gdGhlIGNhc2Ugb2ZcbiAqIGludGVycG9sYXRpb24gaW5zdHJ1Y3Rpb25zLlxuICogQHBhcmFtIGludGVycG9sYXRpb24gQW4gaW50ZXJwb2xhdGlvbiBhc3RcbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikge1xuICAgIGNvbnN0IHsgZXhwcmVzc2lvbnMsIHN0cmluZ3MgfSA9IGludGVycG9sYXRpb247XG4gICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSAmJiBzdHJpbmdzLmxlbmd0aCA9PT0gMiAmJiBzdHJpbmdzWzBdID09PSAnJyAmJiBzdHJpbmdzWzFdID09PSAnJykge1xuICAgICAgICAvLyBJZiB0aGUgaW50ZXJwb2xhdGlvbiBoYXMgb25lIGludGVycG9sYXRlZCB2YWx1ZSwgYnV0IHRoZSBwcmVmaXggYW5kIHN1ZmZpeCBhcmUgYm90aCBlbXB0eVxuICAgICAgICAvLyBzdHJpbmdzLCB3ZSBvbmx5IHBhc3Mgb25lIGFyZ3VtZW50LCB0byBhIHNwZWNpYWwgaW5zdHJ1Y3Rpb24gbGlrZSBgcHJvcGVydHlJbnRlcnBvbGF0ZWAgb3JcbiAgICAgICAgLy8gYHRleHRJbnRlcnBvbGF0ZWAuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLmxlbmd0aCArIHN0cmluZ3MubGVuZ3RoO1xuICAgIH1cbn1cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBmaW5hbCBpbnN0cnVjdGlvbiBjYWxsIHN0YXRlbWVudHMgYmFzZWQgb24gdGhlIHBhc3NlZCBpbiBjb25maWd1cmF0aW9uLlxuICogV2lsbCB0cnkgdG8gY2hhaW4gaW5zdHJ1Y3Rpb25zIGFzIG11Y2ggYXMgcG9zc2libGUsIGlmIGNoYWluaW5nIGlzIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdHJ1Y3Rpb25TdGF0ZW1lbnRzKGluc3RydWN0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gW107XG4gICAgbGV0IHBlbmRpbmdFeHByZXNzaW9uID0gbnVsbDtcbiAgICBsZXQgcGVuZGluZ0V4cHJlc3Npb25UeXBlID0gbnVsbDtcbiAgICBsZXQgY2hhaW5MZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgY3VycmVudCBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXJhbXMgPSAoX2EgPSAodHlwZW9mIGN1cnJlbnQucGFyYW1zT3JGbiA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQucGFyYW1zT3JGbigpIDogY3VycmVudC5wYXJhbXNPckZuKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IEFycmF5LmlzQXJyYXkocmVzb2x2ZWRQYXJhbXMpID8gcmVzb2x2ZWRQYXJhbXMgOiBbcmVzb2x2ZWRQYXJhbXNdO1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBpbnN0cnVjdGlvbiBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgIC8vIGFuZCBpdCBjYW4gYmUgY2hhaW5lZCwgYWRkIGFub3RoZXIgY2FsbCB0byB0aGUgY2hhaW4uXG4gICAgICAgIGlmIChjaGFpbkxlbmd0aCA8IE1BWF9DSEFJTl9MRU5HVEggJiYgcGVuZGluZ0V4cHJlc3Npb25UeXBlID09PSBjdXJyZW50LnJlZmVyZW5jZSAmJlxuICAgICAgICAgICAgQ0hBSU5BQkxFX0lOU1RSVUNUSU9OUy5oYXMocGVuZGluZ0V4cHJlc3Npb25UeXBlKSkge1xuICAgICAgICAgICAgLy8gV2UnbGwgYWx3YXlzIGhhdmUgYSBwZW5kaW5nIGV4cHJlc3Npb24gd2hlbiB0aGVyZSdzIGEgcGVuZGluZyBleHByZXNzaW9uIHR5cGUuXG4gICAgICAgICAgICBwZW5kaW5nRXhwcmVzc2lvbiA9IHBlbmRpbmdFeHByZXNzaW9uLmNhbGxGbihwYXJhbXMsIHBlbmRpbmdFeHByZXNzaW9uLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgY2hhaW5MZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nRXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChwZW5kaW5nRXhwcmVzc2lvbi50b1N0bXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nRXhwcmVzc2lvbiA9IGludm9rZUluc3RydWN0aW9uKGN1cnJlbnQuc3BhbiwgY3VycmVudC5yZWZlcmVuY2UsIHBhcmFtcyk7XG4gICAgICAgICAgICBwZW5kaW5nRXhwcmVzc2lvblR5cGUgPSBjdXJyZW50LnJlZmVyZW5jZTtcbiAgICAgICAgICAgIGNoYWluTGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTaW5jZSB0aGUgY3VycmVudCBpbnN0cnVjdGlvbiBhZGRzIHRoZSBwcmV2aW91cyBvbmUgdG8gdGhlIHN0YXRlbWVudHMsXG4gICAgLy8gd2UgbWF5IGJlIGxlZnQgd2l0aCB0aGUgZmluYWwgb25lIGF0IHRoZSBlbmQgdGhhdCBpcyBzdGlsbCBwZW5kaW5nLlxuICAgIGlmIChwZW5kaW5nRXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocGVuZGluZ0V4cHJlc3Npb24udG9TdG10KCkpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGVtZW50cztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjb21waWxlSW5qZWN0YWJsZShtZXRhLCByZXNvbHZlRm9yd2FyZFJlZnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBjb25zdCBmYWN0b3J5TWV0YSA9IHtcbiAgICAgICAgbmFtZTogbWV0YS5uYW1lLFxuICAgICAgICB0eXBlOiBtZXRhLnR5cGUsXG4gICAgICAgIGludGVybmFsVHlwZTogbWV0YS5pbnRlcm5hbFR5cGUsXG4gICAgICAgIHR5cGVBcmd1bWVudENvdW50OiBtZXRhLnR5cGVBcmd1bWVudENvdW50LFxuICAgICAgICBkZXBzOiBbXSxcbiAgICAgICAgdGFyZ2V0OiBleHBvcnRzLkZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSxcbiAgICB9O1xuICAgIGlmIChtZXRhLnVzZUNsYXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbWV0YS51c2VDbGFzcyBoYXMgdHdvIG1vZGVzIG9mIG9wZXJhdGlvbi4gRWl0aGVyIGRlcHMgYXJlIHNwZWNpZmllZCwgaW4gd2hpY2ggY2FzZSBgbmV3YCBpc1xuICAgICAgICAvLyB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBjbGFzcyB3aXRoIGRlcGVuZGVuY2llcyBpbmplY3RlZCwgb3IgZGVwcyBhcmUgbm90IHNwZWNpZmllZCBhbmRcbiAgICAgICAgLy8gdGhlIGZhY3Rvcnkgb2YgdGhlIGNsYXNzIGlzIHVzZWQgdG8gaW5zdGFudGlhdGUgaXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEEgc3BlY2lhbCBjYXNlIGV4aXN0cyBmb3IgdXNlQ2xhc3M6IFR5cGUgd2hlcmUgVHlwZSBpcyB0aGUgaW5qZWN0YWJsZSB0eXBlIGl0c2VsZiBhbmQgbm9cbiAgICAgICAgLy8gZGVwcyBhcmUgc3BlY2lmaWVkLCBpbiB3aGljaCBjYXNlICd1c2VDbGFzcycgaXMgZWZmZWN0aXZlbHkgaWdub3JlZC5cbiAgICAgICAgY29uc3QgdXNlQ2xhc3NPblNlbGYgPSBtZXRhLnVzZUNsYXNzLmV4cHJlc3Npb24uaXNFcXVpdmFsZW50KG1ldGEuaW50ZXJuYWxUeXBlKTtcbiAgICAgICAgbGV0IGRlcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtZXRhLmRlcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVwcyA9IG1ldGEuZGVwcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBmYWN0b3J5OiAoKSA9PiBuZXcgbWV0YS51c2VDbGFzcyguLi5kZXBzKVxuICAgICAgICAgICAgcmVzdWx0ID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZhY3RvcnlNZXRhKSwgeyBkZWxlZ2F0ZTogbWV0YS51c2VDbGFzcy5leHByZXNzaW9uLCBkZWxlZ2F0ZURlcHM6IGRlcHMsIGRlbGVnYXRlVHlwZTogUjNGYWN0b3J5RGVsZWdhdGVUeXBlLkNsYXNzIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1c2VDbGFzc09uU2VsZikge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbihmYWN0b3J5TWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50czogW10sXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZGVsZWdhdGVUb0ZhY3RvcnkobWV0YS50eXBlLnZhbHVlLCBtZXRhLnVzZUNsYXNzLmV4cHJlc3Npb24sIHJlc29sdmVGb3J3YXJkUmVmcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS51c2VGYWN0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG1ldGEuZGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmFjdG9yeU1ldGEpLCB7IGRlbGVnYXRlOiBtZXRhLnVzZUZhY3RvcnksIGRlbGVnYXRlRGVwczogbWV0YS5kZXBzIHx8IFtdLCBkZWxlZ2F0ZVR5cGU6IFIzRmFjdG9yeURlbGVnYXRlVHlwZS5GdW5jdGlvbiB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50czogW10sXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KG1ldGEudXNlRmFjdG9yeS5jYWxsRm4oW10pKV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGEudXNlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOb3RlOiBpdCdzIHNhZmUgdG8gdXNlIGBtZXRhLnVzZVZhbHVlYCBpbnN0ZWFkIG9mIHRoZSBgVVNFX1ZBTFVFIGluIG1ldGFgIGNoZWNrIHVzZWQgZm9yXG4gICAgICAgIC8vIGNsaWVudCBjb2RlIGJlY2F1c2UgbWV0YS51c2VWYWx1ZSBpcyBhbiBFeHByZXNzaW9uIHdoaWNoIHdpbGwgYmUgZGVmaW5lZCBldmVuIGlmIHRoZSBhY3R1YWxcbiAgICAgICAgLy8gdmFsdWUgaXMgdW5kZWZpbmVkLlxuICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmFjdG9yeU1ldGEpLCB7IGV4cHJlc3Npb246IG1ldGEudXNlVmFsdWUuZXhwcmVzc2lvbiB9KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGEudXNlRXhpc3RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB1c2VFeGlzdGluZyBpcyBhbiBgaW5qZWN0YCBjYWxsIG9uIHRoZSBleGlzdGluZyB0b2tlbi5cbiAgICAgICAgcmVzdWx0ID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZhY3RvcnlNZXRhKSwgeyBleHByZXNzaW9uOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmluamVjdCkuY2FsbEZuKFttZXRhLnVzZUV4aXN0aW5nLmV4cHJlc3Npb25dKSB9KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGRlbGVnYXRlVG9GYWN0b3J5KG1ldGEudHlwZS52YWx1ZSwgbWV0YS5pbnRlcm5hbFR5cGUsIHJlc29sdmVGb3J3YXJkUmVmcylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSBtZXRhLmludGVybmFsVHlwZTtcbiAgICBjb25zdCBpbmplY3RhYmxlUHJvcHMgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGluamVjdGFibGVQcm9wcy5zZXQoJ3Rva2VuJywgdG9rZW4pO1xuICAgIGluamVjdGFibGVQcm9wcy5zZXQoJ2ZhY3RvcnknLCByZXN1bHQuZXhwcmVzc2lvbik7XG4gICAgLy8gT25seSBnZW5lcmF0ZSBwcm92aWRlZEluIHByb3BlcnR5IGlmIGl0IGhhcyBhIG5vbi1udWxsIHZhbHVlXG4gICAgaWYgKG1ldGEucHJvdmlkZWRJbi5leHByZXNzaW9uLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGluamVjdGFibGVQcm9wcy5zZXQoJ3Byb3ZpZGVkSW4nLCBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24obWV0YS5wcm92aWRlZEluKSk7XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLsm1ybVkZWZpbmVJbmplY3RhYmxlKVxuICAgICAgICAuY2FsbEZuKFtpbmplY3RhYmxlUHJvcHMudG9MaXRlcmFsTWFwKCldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgIHR5cGU6IGNyZWF0ZUluamVjdGFibGVUeXBlKG1ldGEpLFxuICAgICAgICBzdGF0ZW1lbnRzOiByZXN1bHQuc3RhdGVtZW50cyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5qZWN0YWJsZVR5cGUobWV0YSkge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihJZGVudGlmaWVycy5JbmplY3RhYmxlRGVjbGFyYXRpb24sIFt0eXBlV2l0aFBhcmFtZXRlcnMobWV0YS50eXBlLnR5cGUsIG1ldGEudHlwZUFyZ3VtZW50Q291bnQpXSkpO1xufVxuZnVuY3Rpb24gZGVsZWdhdGVUb0ZhY3RvcnkodHlwZSwgaW50ZXJuYWxUeXBlLCB1bndyYXBGb3J3YXJkUmVmcykge1xuICAgIGlmICh0eXBlLm5vZGUgPT09IGludGVybmFsVHlwZS5ub2RlKSB7XG4gICAgICAgIC8vIFRoZSB0eXBlcyBhcmUgdGhlIHNhbWUsIHNvIHdlIGNhbiBzaW1wbHkgZGVsZWdhdGUgZGlyZWN0bHkgdG8gdGhlIHR5cGUncyBmYWN0b3J5LlxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gZmFjdG9yeTogdHlwZS7JtWZhY1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgcmV0dXJuIGludGVybmFsVHlwZS5wcm9wKCfJtWZhYycpO1xuICAgIH1cbiAgICBpZiAoIXVud3JhcEZvcndhcmRSZWZzKSB7XG4gICAgICAgIC8vIFRoZSB0eXBlIGlzIG5vdCB3cmFwcGVkIGluIGEgYGZvcndhcmRSZWYoKWAsIHNvIHdlIGNyZWF0ZSBhIHNpbXBsZSBmYWN0b3J5IGZ1bmN0aW9uIHRoYXRcbiAgICAgICAgLy8gYWNjZXB0cyBhIHN1Yi10eXBlIGFzIGFuIGFyZ3VtZW50LlxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gZmFjdG9yeTogZnVuY3Rpb24odCkgeyByZXR1cm4gaW50ZXJuYWxUeXBlLsm1ZmFjKHQpOyB9XG4gICAgICAgIC8vIGBgYFxuICAgICAgICByZXR1cm4gY3JlYXRlRmFjdG9yeUZ1bmN0aW9uKGludGVybmFsVHlwZSk7XG4gICAgfVxuICAgIC8vIFRoZSBpbnRlcm5hbFR5cGUgaXMgYWN0dWFsbHkgd3JhcHBlZCBpbiBhIGBmb3J3YXJkUmVmKClgIHNvIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGF0IGJlZm9yZVxuICAgIC8vIGNhbGxpbmcgaXRzIGZhY3RvcnkuXG4gICAgLy8gYGBgXG4gICAgLy8gZmFjdG9yeTogZnVuY3Rpb24odCkgeyByZXR1cm4gY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKS7JtWZhYyh0KTsgfVxuICAgIC8vIGBgYFxuICAgIGNvbnN0IHVud3JhcHBlZFR5cGUgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLnJlc29sdmVGb3J3YXJkUmVmKS5jYWxsRm4oW2ludGVybmFsVHlwZV0pO1xuICAgIHJldHVybiBjcmVhdGVGYWN0b3J5RnVuY3Rpb24odW53cmFwcGVkVHlwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5RnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiBmbihbbmV3IEZuUGFyYW0oJ3QnLCBEWU5BTUlDX1RZUEUpXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQodHlwZS5wcm9wKCfJtWZhYycpLmNhbGxGbihbdmFyaWFibGUoJ3QnKV0pKV0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IFVOVVNBQkxFX0lOVEVSUE9MQVRJT05fUkVHRVhQUyA9IFtcbiAgICAvXlxccyokLyxcbiAgICAvWzw+XS8sXG4gICAgL15be31dJC8sXG4gICAgLyYoI3xbYS16XSkvaSxcbiAgICAvXlxcL1xcLy8sIC8vIGNvbW1lbnRcbl07XG5mdW5jdGlvbiBhc3NlcnRJbnRlcnBvbGF0aW9uU3ltYm9scyhpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICEoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09IDIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJyR7aWRlbnRpZmllcn0nIHRvIGJlIGFuIGFycmF5LCBbc3RhcnQsIGVuZF0uYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB2YWx1ZVswXTtcbiAgICAgICAgY29uc3QgZW5kID0gdmFsdWVbMV07XG4gICAgICAgIC8vIENoZWNrIGZvciB1bnVzYWJsZSBpbnRlcnBvbGF0aW9uIHN5bWJvbHNcbiAgICAgICAgVU5VU0FCTEVfSU5URVJQT0xBVElPTl9SRUdFWFBTLmZvckVhY2gocmVnZXhwID0+IHtcbiAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChzdGFydCkgfHwgcmVnZXhwLnRlc3QoZW5kKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgWycke3N0YXJ0fScsICcke2VuZH0nXSBjb250YWlucyB1bnVzYWJsZSBpbnRlcnBvbGF0aW9uIHN5bWJvbC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIEludGVycG9sYXRpb25Db25maWcge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BcnJheShtYXJrZXJzKSB7XG4gICAgICAgIGlmICghbWFya2Vycykge1xuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoJ2ludGVycG9sYXRpb24nLCBtYXJrZXJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uQ29uZmlnKG1hcmtlcnNbMF0sIG1hcmtlcnNbMV0pO1xuICAgIH1cbn1cbmNvbnN0IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcgPSBuZXcgSW50ZXJwb2xhdGlvbkNvbmZpZygne3snLCAnfX0nKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCAkRU9GID0gMDtcbmNvbnN0ICRCU1BBQ0UgPSA4O1xuY29uc3QgJFRBQiA9IDk7XG5jb25zdCAkTEYgPSAxMDtcbmNvbnN0ICRWVEFCID0gMTE7XG5jb25zdCAkRkYgPSAxMjtcbmNvbnN0ICRDUiA9IDEzO1xuY29uc3QgJFNQQUNFID0gMzI7XG5jb25zdCAkQkFORyA9IDMzO1xuY29uc3QgJERRID0gMzQ7XG5jb25zdCAkSEFTSCA9IDM1O1xuY29uc3QgJCQgPSAzNjtcbmNvbnN0ICRQRVJDRU5UID0gMzc7XG5jb25zdCAkQU1QRVJTQU5EID0gMzg7XG5jb25zdCAkU1EgPSAzOTtcbmNvbnN0ICRMUEFSRU4gPSA0MDtcbmNvbnN0ICRSUEFSRU4gPSA0MTtcbmNvbnN0ICRTVEFSID0gNDI7XG5jb25zdCAkUExVUyA9IDQzO1xuY29uc3QgJENPTU1BID0gNDQ7XG5jb25zdCAkTUlOVVMgPSA0NTtcbmNvbnN0ICRQRVJJT0QgPSA0NjtcbmNvbnN0ICRTTEFTSCA9IDQ3O1xuY29uc3QgJENPTE9OID0gNTg7XG5jb25zdCAkU0VNSUNPTE9OID0gNTk7XG5jb25zdCAkTFQgPSA2MDtcbmNvbnN0ICRFUSA9IDYxO1xuY29uc3QgJEdUID0gNjI7XG5jb25zdCAkUVVFU1RJT04gPSA2MztcbmNvbnN0ICQwID0gNDg7XG5jb25zdCAkNyA9IDU1O1xuY29uc3QgJDkgPSA1NztcbmNvbnN0ICRBID0gNjU7XG5jb25zdCAkRSA9IDY5O1xuY29uc3QgJEYgPSA3MDtcbmNvbnN0ICRYID0gODg7XG5jb25zdCAkWiA9IDkwO1xuY29uc3QgJExCUkFDS0VUID0gOTE7XG5jb25zdCAkQkFDS1NMQVNIID0gOTI7XG5jb25zdCAkUkJSQUNLRVQgPSA5MztcbmNvbnN0ICRDQVJFVCA9IDk0O1xuY29uc3QgJF8gPSA5NTtcbmNvbnN0ICRhID0gOTc7XG5jb25zdCAkYiA9IDk4O1xuY29uc3QgJGUgPSAxMDE7XG5jb25zdCAkZiA9IDEwMjtcbmNvbnN0ICRuID0gMTEwO1xuY29uc3QgJHIgPSAxMTQ7XG5jb25zdCAkdCA9IDExNjtcbmNvbnN0ICR1ID0gMTE3O1xuY29uc3QgJHYgPSAxMTg7XG5jb25zdCAkeCA9IDEyMDtcbmNvbnN0ICR6ID0gMTIyO1xuY29uc3QgJExCUkFDRSA9IDEyMztcbmNvbnN0ICRCQVIgPSAxMjQ7XG5jb25zdCAkUkJSQUNFID0gMTI1O1xuY29uc3QgJE5CU1AgPSAxNjA7XG5jb25zdCAkQlQgPSA5NjtcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShjb2RlKSB7XG4gICAgcmV0dXJuIChjb2RlID49ICRUQUIgJiYgY29kZSA8PSAkU1BBQ0UpIHx8IChjb2RlID09ICROQlNQKTtcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICAgIHJldHVybiAkMCA8PSBjb2RlICYmIGNvZGUgPD0gJDk7XG59XG5mdW5jdGlvbiBpc0FzY2lpTGV0dGVyKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAkYSAmJiBjb2RlIDw9ICR6IHx8IGNvZGUgPj0gJEEgJiYgY29kZSA8PSAkWjtcbn1cbmZ1bmN0aW9uIGlzQXNjaWlIZXhEaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkZiB8fCBjb2RlID49ICRBICYmIGNvZGUgPD0gJEYgfHwgaXNEaWdpdChjb2RlKTtcbn1cbmZ1bmN0aW9uIGlzTmV3TGluZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09ICRMRiB8fCBjb2RlID09PSAkQ1I7XG59XG5mdW5jdGlvbiBpc09jdGFsRGlnaXQoY29kZSkge1xuICAgIHJldHVybiAkMCA8PSBjb2RlICYmIGNvZGUgPD0gJDc7XG59XG5mdW5jdGlvbiBpc1F1b3RlKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gJFNRIHx8IGNvZGUgPT09ICREUSB8fCBjb2RlID09PSAkQlQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgUGFyc2VMb2NhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZmlsZSwgb2Zmc2V0LCBsaW5lLCBjb2wpIHtcbiAgICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuY29sID0gY29sO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICE9IG51bGwgPyBgJHt0aGlzLmZpbGUudXJsfUAke3RoaXMubGluZX06JHt0aGlzLmNvbH1gIDogdGhpcy5maWxlLnVybDtcbiAgICB9XG4gICAgbW92ZUJ5KGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZmlsZS5jb250ZW50O1xuICAgICAgICBjb25zdCBsZW4gPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5saW5lO1xuICAgICAgICBsZXQgY29sID0gdGhpcy5jb2w7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPiAwICYmIGRlbHRhIDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgICBkZWx0YSsrO1xuICAgICAgICAgICAgY29uc3QgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGNoID09ICRMRikge1xuICAgICAgICAgICAgICAgIGxpbmUtLTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmlvckxpbmUgPSBzb3VyY2Uuc3Vic3RyaW5nKDAsIG9mZnNldCAtIDEpLmxhc3RJbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUoJExGKSk7XG4gICAgICAgICAgICAgICAgY29sID0gcHJpb3JMaW5lID4gMCA/IG9mZnNldCAtIHByaW9yTGluZSA6IG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW4gJiYgZGVsdGEgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGRlbHRhLS07XG4gICAgICAgICAgICBpZiAoY2ggPT0gJExGKSB7XG4gICAgICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgICAgIGNvbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2wrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTG9jYXRpb24odGhpcy5maWxlLCBvZmZzZXQsIGxpbmUsIGNvbCk7XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgc291cmNlIGFyb3VuZCB0aGUgbG9jYXRpb25cbiAgICAvLyBVcCB0byBgbWF4Q2hhcnNgIG9yIGBtYXhMaW5lc2Agb24gZWFjaCBzaWRlIG9mIHRoZSBsb2NhdGlvblxuICAgIGdldENvbnRleHQobWF4Q2hhcnMsIG1heExpbmVzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmZpbGUuY29udGVudDtcbiAgICAgICAgbGV0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGlmIChzdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPiBjb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IGNvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbmRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgICAgIGxldCBjdHhDaGFycyA9IDA7XG4gICAgICAgICAgICBsZXQgY3R4TGluZXMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGN0eENoYXJzIDwgbWF4Q2hhcnMgJiYgc3RhcnRPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRPZmZzZXQtLTtcbiAgICAgICAgICAgICAgICBjdHhDaGFycysrO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50W3N0YXJ0T2Zmc2V0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKytjdHhMaW5lcyA9PSBtYXhMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHhDaGFycyA9IDA7XG4gICAgICAgICAgICBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY3R4Q2hhcnMgPCBtYXhDaGFycyAmJiBlbmRPZmZzZXQgPCBjb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBlbmRPZmZzZXQrKztcbiAgICAgICAgICAgICAgICBjdHhDaGFycysrO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50W2VuZE9mZnNldF0gPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrY3R4TGluZXMgPT0gbWF4TGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGNvbnRlbnQuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCB0aGlzLm9mZnNldCksXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IGNvbnRlbnQuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LCBlbmRPZmZzZXQgKyAxKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgUGFyc2VTb3VyY2VGaWxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgfVxufVxuY2xhc3MgUGFyc2VTb3VyY2VTcGFuIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gb2JqZWN0IHRoYXQgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgc3BhbnMgb2YgdG9rZW5zL25vZGVzIGNhcHR1cmVkIGR1cmluZ1xuICAgICAqIGxleGluZy9wYXJzaW5nIG9mIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnRcbiAgICAgKiBUaGUgbG9jYXRpb24gb2YgdGhlIHN0YXJ0IG9mIHRoZSBzcGFuIChoYXZpbmcgc2tpcHBlZCBsZWFkaW5nIHRyaXZpYSkuXG4gICAgICogU2tpcHBpbmcgbGVhZGluZyB0cml2aWEgbWFrZXMgc291cmNlLXNwYW5zIG1vcmUgXCJ1c2VyIGZyaWVuZGx5XCIsIHNpbmNlIHRoaW5ncyBsaWtlIEhUTUxcbiAgICAgKiBlbGVtZW50cyB3aWxsIGFwcGVhciB0byBiZWdpbiBhdCB0aGUgc3RhcnQgb2YgdGhlIG9wZW5pbmcgdGFnLCByYXRoZXIgdGhhbiBhdCB0aGUgc3RhcnQgb2YgYW55XG4gICAgICogbGVhZGluZyB0cml2aWEsIHdoaWNoIGNvdWxkIGluY2x1ZGUgbmV3bGluZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5kXG4gICAgICogVGhlIGxvY2F0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHNwYW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVsbFN0YXJ0XG4gICAgICogVGhlIHN0YXJ0IG9mIHRoZSB0b2tlbiB3aXRob3V0IHNraXBwaW5nIHRoZSBsZWFkaW5nIHRyaXZpYS5cbiAgICAgKiBUaGlzIGlzIHVzZWQgYnkgdG9vbGluZyB0aGF0IHNwbGl0cyB0b2tlbnMgZnVydGhlciwgc3VjaCBhcyBleHRyYWN0aW5nIEFuZ3VsYXIgaW50ZXJwb2xhdGlvbnNcbiAgICAgKiBmcm9tIHRleHQgdG9rZW5zLiBTdWNoIHRvb2xpbmcgY3JlYXRlcyBuZXcgc291cmNlLXNwYW5zIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCB0b2tlbidzXG4gICAgICogc291cmNlLXNwYW4uIElmIGxlYWRpbmcgdHJpdmlhIGNoYXJhY3RlcnMgaGF2ZSBiZWVuIHNraXBwZWQgdGhlbiB0aGUgbmV3IHNvdXJjZS1zcGFucyBtYXkgYmVcbiAgICAgKiBpbmNvcnJlY3RseSBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGV0YWlsc1xuICAgICAqIEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gKHN1Y2ggYXMgaWRlbnRpZmllciBuYW1lcykgdGhhdCBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGFuLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQsIGZ1bGxTdGFydCA9IHN0YXJ0LCBkZXRhaWxzID0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmZ1bGxTdGFydCA9IGZ1bGxTdGFydDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0LmZpbGUuY29udGVudC5zdWJzdHJpbmcodGhpcy5zdGFydC5vZmZzZXQsIHRoaXMuZW5kLm9mZnNldCk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFBhcnNlRXJyb3JMZXZlbCkge1xuICAgIFBhcnNlRXJyb3JMZXZlbFtQYXJzZUVycm9yTGV2ZWxbXCJXQVJOSU5HXCJdID0gMF0gPSBcIldBUk5JTkdcIjtcbiAgICBQYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsW1wiRVJST1JcIl0gPSAxXSA9IFwiRVJST1JcIjtcbn0pKGV4cG9ydHMuUGFyc2VFcnJvckxldmVsIHx8IChleHBvcnRzLlBhcnNlRXJyb3JMZXZlbCA9IHt9KSk7XG5jbGFzcyBQYXJzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBtc2csIGxldmVsID0gZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuRVJST1IpIHtcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgY29udGV4dHVhbE1lc3NhZ2UoKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuc3Bhbi5zdGFydC5nZXRDb250ZXh0KDEwMCwgMyk7XG4gICAgICAgIHJldHVybiBjdHggPyBgJHt0aGlzLm1zZ30gKFwiJHtjdHguYmVmb3JlfVske2V4cG9ydHMuUGFyc2VFcnJvckxldmVsW3RoaXMubGV2ZWxdfSAtPl0ke2N0eC5hZnRlcn1cIilgIDpcbiAgICAgICAgICAgIHRoaXMubXNnO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IHRoaXMuc3Bhbi5kZXRhaWxzID8gYCwgJHt0aGlzLnNwYW4uZGV0YWlsc31gIDogJyc7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnRleHR1YWxNZXNzYWdlKCl9OiAke3RoaXMuc3Bhbi5zdGFydH0ke2RldGFpbHN9YDtcbiAgICB9XG59XG4vKipcbiAqIEdlbmVyYXRlcyBTb3VyY2UgU3BhbiBvYmplY3QgZm9yIGEgZ2l2ZW4gUjMgVHlwZSBmb3IgSklUIG1vZGUuXG4gKlxuICogQHBhcmFtIGtpbmQgQ29tcG9uZW50IG9yIERpcmVjdGl2ZS5cbiAqIEBwYXJhbSB0eXBlTmFtZSBuYW1lIG9mIHRoZSBDb21wb25lbnQgb3IgRGlyZWN0aXZlLlxuICogQHBhcmFtIHNvdXJjZVVybCByZWZlcmVuY2UgdG8gQ29tcG9uZW50IG9yIERpcmVjdGl2ZSBzb3VyY2UuXG4gKiBAcmV0dXJucyBpbnN0YW5jZSBvZiBQYXJzZVNvdXJjZVNwYW4gdGhhdCByZXByZXNlbnQgYSBnaXZlbiBDb21wb25lbnQgb3IgRGlyZWN0aXZlLlxuICovXG5mdW5jdGlvbiByM0ppdFR5cGVTb3VyY2VTcGFuKGtpbmQsIHR5cGVOYW1lLCBzb3VyY2VVcmwpIHtcbiAgICBjb25zdCBzb3VyY2VGaWxlTmFtZSA9IGBpbiAke2tpbmR9ICR7dHlwZU5hbWV9IGluICR7c291cmNlVXJsfWA7XG4gICAgY29uc3Qgc291cmNlRmlsZSA9IG5ldyBQYXJzZVNvdXJjZUZpbGUoJycsIHNvdXJjZUZpbGVOYW1lKTtcbiAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCAtMSwgLTEsIC0xKSwgbmV3IFBhcnNlTG9jYXRpb24oc291cmNlRmlsZSwgLTEsIC0xLCAtMSkpO1xufVxubGV0IF9hbm9ueW1vdXNUeXBlSW5kZXggPSAwO1xuZnVuY3Rpb24gaWRlbnRpZmllck5hbWUoY29tcGlsZUlkZW50aWZpZXIpIHtcbiAgICBpZiAoIWNvbXBpbGVJZGVudGlmaWVyIHx8ICFjb21waWxlSWRlbnRpZmllci5yZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlZiA9IGNvbXBpbGVJZGVudGlmaWVyLnJlZmVyZW5jZTtcbiAgICBpZiAocmVmWydfX2Fub255bW91c1R5cGUnXSkge1xuICAgICAgICByZXR1cm4gcmVmWydfX2Fub255bW91c1R5cGUnXTtcbiAgICB9XG4gICAgaWYgKHJlZlsnX19mb3J3YXJkX3JlZl9fJ10pIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IHdhbnQgdG8gdHJ5IHRvIHN0cmluZ2lmeSBhIGBmb3J3YXJkUmVmKClgIGZ1bmN0aW9uIGJlY2F1c2UgdGhhdCB3b3VsZCBjYXVzZSB0aGVcbiAgICAgICAgLy8gaW5uZXIgZnVuY3Rpb24gdG8gYmUgZXZhbHVhdGVkIHRvbyBlYXJseSwgZGVmZWF0aW5nIHRoZSB3aG9sZSBwb2ludCBvZiB0aGUgYGZvcndhcmRSZWZgLlxuICAgICAgICByZXR1cm4gJ19fZm9yd2FyZF9yZWZfXyc7XG4gICAgfVxuICAgIGxldCBpZGVudGlmaWVyID0gc3RyaW5naWZ5KHJlZik7XG4gICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignKCcpID49IDApIHtcbiAgICAgICAgLy8gY2FzZTogYW5vbnltb3VzIGZ1bmN0aW9ucyFcbiAgICAgICAgaWRlbnRpZmllciA9IGBhbm9ueW1vdXNfJHtfYW5vbnltb3VzVHlwZUluZGV4Kyt9YDtcbiAgICAgICAgcmVmWydfX2Fub255bW91c1R5cGUnXSA9IGlkZW50aWZpZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZGVudGlmaWVyID0gc2FuaXRpemVJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbn1cbmZ1bmN0aW9uIHNhbml0aXplSWRlbnRpZmllcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvXFxXL2csICdfJyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBJbiBUeXBlU2NyaXB0LCB0YWdnZWQgdGVtcGxhdGUgZnVuY3Rpb25zIGV4cGVjdCBhIFwidGVtcGxhdGUgb2JqZWN0XCIsIHdoaWNoIGlzIGFuIGFycmF5IG9mXG4gKiBcImNvb2tlZFwiIHN0cmluZ3MgcGx1cyBhIGByYXdgIHByb3BlcnR5IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgXCJyYXdcIiBzdHJpbmdzLiBUaGlzIGlzXG4gKiB0eXBpY2FsbHkgY29uc3RydWN0ZWQgd2l0aCBhIGZ1bmN0aW9uIGNhbGxlZCBgX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpYCwgYnV0IGl0IG1heSBub3RcbiAqIGJlIGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzLlxuICpcbiAqIFRoaXMgaXMgYSBKYXZhU2NyaXB0IHBvbHlmaWxsIHRoYXQgdXNlcyBfX21ha2VUZW1wbGF0ZU9iamVjdCB3aGVuIGl0J3MgYXZhaWxhYmxlLCBidXQgb3RoZXJ3aXNlXG4gKiBjcmVhdGVzIGFuIGlubGluZSBoZWxwZXIgd2l0aCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIEluIHRoZSBpbmxpbmUgZnVuY3Rpb24sIGlmIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIGlzIGF2YWlsYWJsZSB3ZSB1c2UgdGhhdCB0byBhdHRhY2ggdGhlIGByYXdgXG4gKiBhcnJheS5cbiAqL1xuY29uc3QgbWFrZVRlbXBsYXRlT2JqZWN0UG9seWZpbGwgPSAnKHRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTp0fSk6ZS5yYXc9dCxlfSknO1xuY2xhc3MgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yIGV4dGVuZHMgQWJzdHJhY3RFbWl0dGVyVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGZhbHNlKTtcbiAgICB9XG4gICAgdmlzaXRXcmFwcGVkTm9kZUV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW1pdCBhIFdyYXBwZWROb2RlRXhwciBpbiBKYXZhc2NyaXB0LicpO1xuICAgIH1cbiAgICB2aXNpdERlY2xhcmVWYXJTdG10KHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgYHZhciAke3N0bXQubmFtZX1gKTtcbiAgICAgICAgaWYgKHN0bXQudmFsdWUpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCAnID0gJyk7XG4gICAgICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIGA7YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFRhZ2dlZFRlbXBsYXRlRXhwcihhc3QsIGN0eCkge1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvbnZvbHV0ZWQgcGllY2Ugb2YgY29kZSBpcyBlZmZlY3RpdmVseSB0aGUgZG93bmxldmVsbGVkIGVxdWl2YWxlbnQgb2ZcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIHRhZ2AuLi5gXG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyB3aGljaCBpcyBlZmZlY3RpdmVseSBsaWtlOlxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gdGFnKF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSwgZXhwcmVzc2lvbjEsIGV4cHJlc3Npb24yLCAuLi4pO1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBhc3QudGVtcGxhdGUuZWxlbWVudHM7XG4gICAgICAgIGFzdC50YWcudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGAoJHttYWtlVGVtcGxhdGVPYmplY3RQb2x5ZmlsbH0oYCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGBbJHtlbGVtZW50cy5tYXAocGFydCA9PiBlc2NhcGVJZGVudGlmaWVyKHBhcnQudGV4dCwgZmFsc2UpKS5qb2luKCcsICcpfV0sIGApO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgWyR7ZWxlbWVudHMubWFwKHBhcnQgPT4gZXNjYXBlSWRlbnRpZmllcihwYXJ0LnJhd1RleHQsIGZhbHNlKSkuam9pbignLCAnKX1dKWApO1xuICAgICAgICBhc3QudGVtcGxhdGUuZXhwcmVzc2lvbnMuZm9yRWFjaChleHByZXNzaW9uID0+IHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICcsICcpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcpJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEZ1bmN0aW9uRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgZnVuY3Rpb24ke2FzdC5uYW1lID8gJyAnICsgYXN0Lm5hbWUgOiAnJ30oYCk7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKGFzdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKGFzdCwgYCkge2ApO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGB9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdERlY2xhcmVGdW5jdGlvblN0bXQoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBgZnVuY3Rpb24gJHtzdG10Lm5hbWV9KGApO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgYCkge2ApO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBgfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRMb2NhbGl6ZWRTdHJpbmcoYXN0LCBjdHgpIHtcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb252b2x1dGVkIHBpZWNlIG9mIGNvZGUgaXMgZWZmZWN0aXZlbHkgdGhlIGRvd25sZXZlbGxlZCBlcXVpdmFsZW50IG9mXG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyAkbG9jYWxpemUgYC4uLmBcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGxpa2U6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyAkbG9jYWxpemUoX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpLCBleHByZXNzaW9uMSwgZXhwcmVzc2lvbjIsIC4uLik7XG4gICAgICAgIC8vIGBgYFxuICAgICAgICBjdHgucHJpbnQoYXN0LCBgJGxvY2FsaXplKCR7bWFrZVRlbXBsYXRlT2JqZWN0UG9seWZpbGx9KGApO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFthc3Quc2VyaWFsaXplSTE4bkhlYWQoKV07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXN0Lm1lc3NhZ2VQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFydHMucHVzaChhc3Quc2VyaWFsaXplSTE4blRlbXBsYXRlUGFydChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGFzdCwgYFske3BhcnRzLm1hcChwYXJ0ID0+IGVzY2FwZUlkZW50aWZpZXIocGFydC5jb29rZWQsIGZhbHNlKSkuam9pbignLCAnKX1dLCBgKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYFske3BhcnRzLm1hcChwYXJ0ID0+IGVzY2FwZUlkZW50aWZpZXIocGFydC5yYXcsIGZhbHNlKSkuam9pbignLCAnKX1dKWApO1xuICAgICAgICBhc3QuZXhwcmVzc2lvbnMuZm9yRWFjaChleHByZXNzaW9uID0+IHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICcsICcpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcpJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfdmlzaXRQYXJhbXMocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMocGFyYW0gPT4gY3R4LnByaW50KG51bGwsIHBhcmFtLm5hbWUpLCBwYXJhbXMsIGN0eCwgJywnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGUgVHJ1c3RlZCBUeXBlcyBwb2xpY3ksIG9yIG51bGwgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgbm90XG4gKiBlbmFibGVkL3N1cHBvcnRlZCwgb3IgdW5kZWZpbmVkIGlmIHRoZSBwb2xpY3kgaGFzIG5vdCBiZWVuIGNyZWF0ZWQgeWV0LlxuICovXG5sZXQgcG9saWN5O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBUcnVzdGVkIFR5cGVzIHBvbGljeSwgb3IgbnVsbCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBub3RcbiAqIGVuYWJsZWQvc3VwcG9ydGVkLiBUaGUgZmlyc3QgY2FsbCB0byB0aGlzIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIHRoZSBwb2xpY3kuXG4gKi9cbmZ1bmN0aW9uIGdldFBvbGljeSgpIHtcbiAgICBpZiAocG9saWN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9saWN5ID0gbnVsbDtcbiAgICAgICAgaWYgKF9nbG9iYWwudHJ1c3RlZFR5cGVzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBvbGljeSA9XG4gICAgICAgICAgICAgICAgICAgIF9nbG9iYWwudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSgnYW5ndWxhciN1bnNhZmUtaml0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2NyaXB0OiAocykgPT4gcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5IHRocm93cyBpZiBjYWxsZWQgd2l0aCBhIG5hbWUgdGhhdCBpc1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgcmVnaXN0ZXJlZCwgZXZlbiBpbiByZXBvcnQtb25seSBtb2RlLiBVbnRpbCB0aGUgQVBJIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgLy8gY2F0Y2ggdGhlIGVycm9yIG5vdCB0byBicmVhayB0aGUgYXBwbGljYXRpb25zIGZ1bmN0aW9uYWxseS4gSW4gc3VjaFxuICAgICAgICAgICAgICAgIC8vIGNhc2VzLCB0aGUgY29kZSB3aWxsIGZhbGwgYmFjayB0byB1c2luZyBzdHJpbmdzLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb2xpY3k7XG59XG4vKipcbiAqIFVuc2FmZWx5IHByb21vdGUgYSBzdHJpbmcgdG8gYSBUcnVzdGVkU2NyaXB0LCBmYWxsaW5nIGJhY2sgdG8gc3RyaW5ncyB3aGVuXG4gKiBUcnVzdGVkIFR5cGVzIGFyZSBub3QgYXZhaWxhYmxlLlxuICogQHNlY3VyaXR5IEluIHBhcnRpY3VsYXIsIGl0IG11c3QgYmUgYXNzdXJlZCB0aGF0IHRoZSBwcm92aWRlZCBzdHJpbmcgd2lsbFxuICogbmV2ZXIgY2F1c2UgYW4gWFNTIHZ1bG5lcmFiaWxpdHkgaWYgdXNlZCBpbiBhIGNvbnRleHQgdGhhdCB3aWxsIGJlXG4gKiBpbnRlcnByZXRlZCBhbmQgZXhlY3V0ZWQgYXMgYSBzY3JpcHQgYnkgYSBicm93c2VyLCBlLmcuIHdoZW4gY2FsbGluZyBldmFsLlxuICovXG5mdW5jdGlvbiB0cnVzdGVkU2NyaXB0RnJvbVN0cmluZyhzY3JpcHQpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBnZXRQb2xpY3koKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNyZWF0ZVNjcmlwdChzY3JpcHQpKSB8fCBzY3JpcHQ7XG59XG4vKipcbiAqIFVuc2FmZWx5IGNhbGwgdGhlIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIHdpdGggdGhlIGdpdmVuIHN0cmluZyBhcmd1bWVudHMuXG4gKiBAc2VjdXJpdHkgVGhpcyBpcyBhIHNlY3VyaXR5LXNlbnNpdGl2ZSBmdW5jdGlvbjsgYW55IHVzZSBvZiB0aGlzIGZ1bmN0aW9uXG4gKiBtdXN0IGdvIHRocm91Z2ggc2VjdXJpdHkgcmV2aWV3LiBJbiBwYXJ0aWN1bGFyLCBpdCBtdXN0IGJlIGFzc3VyZWQgdGhhdCBpdFxuICogaXMgb25seSBjYWxsZWQgZnJvbSB0aGUgSklUIGNvbXBpbGVyLCBhcyB1c2UgaW4gb3RoZXIgY29kZSBjYW4gbGVhZCB0byBYU1NcbiAqIHZ1bG5lcmFiaWxpdGllcy5cbiAqL1xuZnVuY3Rpb24gbmV3VHJ1c3RlZEZ1bmN0aW9uRm9ySklUKC4uLmFyZ3MpIHtcbiAgICBpZiAoIV9nbG9iYWwudHJ1c3RlZFR5cGVzKSB7XG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB0aGF0IGRvbid0IHN1cHBvcnQgVHJ1c3RlZCBUeXBlcywgZmFsbCBiYWNrIHRvIHRoZSBtb3N0XG4gICAgICAgIC8vIHN0cmFpZ2h0Zm9yd2FyZCBpbXBsZW1lbnRhdGlvbjpcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbiguLi5hcmdzKTtcbiAgICB9XG4gICAgLy8gQ2hyb21lIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHBhc3NpbmcgVHJ1c3RlZFNjcmlwdCB0byB0aGUgRnVuY3Rpb25cbiAgICAvLyBjb25zdHJ1Y3Rvci4gVGhlIGZvbGxvd2luZyBpbXBsZW1lbnRzIHRoZSB3b3JrYXJvdW5kIHByb3Bvc2VkIG9uIHRoZSBwYWdlXG4gICAgLy8gYmVsb3csIHdoZXJlIHRoZSBDaHJvbWl1bSBidWcgaXMgYWxzbyByZWZlcmVuY2VkOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2ViYXBwc2VjLXRydXN0ZWQtdHlwZXMvd2lraS9UcnVzdGVkLVR5cGVzLWZvci1mdW5jdGlvbi1jb25zdHJ1Y3RvclxuICAgIGNvbnN0IGZuQXJncyA9IGFyZ3Muc2xpY2UoMCwgLTEpLmpvaW4oJywnKTtcbiAgICBjb25zdCBmbkJvZHkgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgYm9keSA9IGAoZnVuY3Rpb24gYW5vbnltb3VzKCR7Zm5BcmdzfVxuKSB7ICR7Zm5Cb2R5fVxufSlgO1xuICAgIC8vIFVzaW5nIGV2YWwgZGlyZWN0bHkgY29uZnVzZXMgdGhlIGNvbXBpbGVyIGFuZCBwcmV2ZW50cyB0aGlzIG1vZHVsZSBmcm9tXG4gICAgLy8gYmVpbmcgc3RyaXBwZWQgb3V0IG9mIEpTIGJpbmFyaWVzIGV2ZW4gaWYgbm90IHVzZWQuIFRoZSBnbG9iYWxbJ2V2YWwnXVxuICAgIC8vIGluZGlyZWN0aW9uIGZpeGVzIHRoYXQuXG4gICAgY29uc3QgZm4gPSBfZ2xvYmFsWydldmFsJ10odHJ1c3RlZFNjcmlwdEZyb21TdHJpbmcoYm9keSkpO1xuICAgIGlmIChmbi5iaW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgYSBicm93c2VyIGJ1ZyB0aGF0IG9ubHkgZXhpc3RzIGluIENocm9tZSA4Mywgd2hlcmUgcGFzc2luZ1xuICAgICAgICAvLyBhIFRydXN0ZWRTY3JpcHQgdG8gZXZhbCBqdXN0IHJldHVybnMgdGhlIFRydXN0ZWRTY3JpcHQgYmFjayB3aXRob3V0XG4gICAgICAgIC8vIGV2YWx1YXRpbmcgaXQuIEluIHRoYXQgY2FzZSwgZmFsbCBiYWNrIHRvIHRoZSBtb3N0IHN0cmFpZ2h0Zm9yd2FyZFxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbjpcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbiguLi5hcmdzKTtcbiAgICB9XG4gICAgLy8gVG8gY29tcGxldGVseSBtaW1pYyB0aGUgYmVoYXZpb3Igb2YgY2FsbGluZyBcIm5ldyBGdW5jdGlvblwiLCB0d28gbW9yZVxuICAgIC8vIHRoaW5ncyBuZWVkIHRvIGhhcHBlbjpcbiAgICAvLyAxLiBTdHJpbmdpZnlpbmcgdGhlIHJlc3VsdGluZyBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGl0cyBzb3VyY2UgY29kZVxuICAgIGZuLnRvU3RyaW5nID0gKCkgPT4gYm9keTtcbiAgICAvLyAyLiBXaGVuIGNhbGxpbmcgdGhlIHJlc3VsdGluZyBmdW5jdGlvbiwgYHRoaXNgIHNob3VsZCByZWZlciB0byBgZ2xvYmFsYFxuICAgIHJldHVybiBmbi5iaW5kKF9nbG9iYWwpO1xuICAgIC8vIFdoZW4gVHJ1c3RlZCBUeXBlcyBzdXBwb3J0IGluIEZ1bmN0aW9uIGNvbnN0cnVjdG9ycyBpcyB3aWRlbHkgYXZhaWxhYmxlLFxuICAgIC8vIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBzaW1wbGlmaWVkIHRvOlxuICAgIC8vIHJldHVybiBuZXcgRnVuY3Rpb24oLi4uYXJncy5tYXAoYSA9PiB0cnVzdGVkU2NyaXB0RnJvbVN0cmluZyhhKSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBoZWxwZXIgY2xhc3MgdG8gbWFuYWdlIHRoZSBldmFsdWF0aW9uIG9mIEpJVCBnZW5lcmF0ZWQgY29kZS5cbiAqL1xuY2xhc3MgSml0RXZhbHVhdG9yIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2VVcmwgVGhlIFVSTCBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICogQHBhcmFtIHN0YXRlbWVudHMgQW4gYXJyYXkgb2YgQW5ndWxhciBzdGF0ZW1lbnQgQVNUIG5vZGVzIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgKiBAcGFyYW0gcmVmUmVzb2x2ZXIgUmVzb2x2ZXMgYG8uRXh0ZXJuYWxSZWZlcmVuY2VgcyBpbnRvIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gY3JlYXRlU291cmNlTWFwcyBJZiB0cnVlIHRoZW4gY3JlYXRlIGEgc291cmNlLW1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlIGFuZCBpbmNsdWRlIGl0XG4gICAgICogaW5saW5lIGFzIGEgc291cmNlLW1hcCBjb21tZW50LlxuICAgICAqIEByZXR1cm5zIEEgbWFwIG9mIGFsbCB0aGUgdmFyaWFibGVzIGluIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKi9cbiAgICBldmFsdWF0ZVN0YXRlbWVudHMoc291cmNlVXJsLCBzdGF0ZW1lbnRzLCByZWZSZXNvbHZlciwgY3JlYXRlU291cmNlTWFwcykge1xuICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgSml0RW1pdHRlclZpc2l0b3IocmVmUmVzb2x2ZXIpO1xuICAgICAgICBjb25zdCBjdHggPSBFbWl0dGVyVmlzaXRvckNvbnRleHQuY3JlYXRlUm9vdCgpO1xuICAgICAgICAvLyBFbnN1cmUgZ2VuZXJhdGVkIGNvZGUgaXMgaW4gc3RyaWN0IG1vZGVcbiAgICAgICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoID4gMCAmJiAhaXNVc2VTdHJpY3RTdGF0ZW1lbnQoc3RhdGVtZW50c1swXSkpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMgPSBbXG4gICAgICAgICAgICAgICAgbGl0ZXJhbCgndXNlIHN0cmljdCcpLnRvU3RtdCgpLFxuICAgICAgICAgICAgICAgIC4uLnN0YXRlbWVudHMsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnZlcnRlci52aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY29udmVydGVyLmNyZWF0ZVJldHVyblN0bXQoY3R4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVDb2RlKHNvdXJjZVVybCwgY3R4LCBjb252ZXJ0ZXIuZ2V0QXJncygpLCBjcmVhdGVTb3VyY2VNYXBzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgYSBwaWVjZSBvZiBKSVQgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICogQHBhcmFtIHNvdXJjZVVybCBUaGUgVVJMIG9mIHRoaXMgZ2VuZXJhdGVkIGNvZGUuXG4gICAgICogQHBhcmFtIGN0eCBBIGNvbnRleHQgb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gQVNUIG9mIHRoZSBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgKiBAcGFyYW0gdmFycyBBIG1hcCBjb250YWluaW5nIHRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIHZhcmlhYmxlcyB0aGF0IHRoZSBldmFsdWF0ZWQgY29kZSBtaWdodFxuICAgICAqIHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0gY3JlYXRlU291cmNlTWFwIElmIHRydWUgdGhlbiBjcmVhdGUgYSBzb3VyY2UtbWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGUgYW5kIGluY2x1ZGUgaXRcbiAgICAgKiBpbmxpbmUgYXMgYSBzb3VyY2UtbWFwIGNvbW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiBldmFsdWF0aW5nIHRoZSBjb2RlLlxuICAgICAqL1xuICAgIGV2YWx1YXRlQ29kZShzb3VyY2VVcmwsIGN0eCwgdmFycywgY3JlYXRlU291cmNlTWFwKSB7XG4gICAgICAgIGxldCBmbkJvZHkgPSBgXCJ1c2Ugc3RyaWN0XCI7JHtjdHgudG9Tb3VyY2UoKX1cXG4vLyMgc291cmNlVVJMPSR7c291cmNlVXJsfWA7XG4gICAgICAgIGNvbnN0IGZuQXJnTmFtZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZm5BcmdWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhcmdOYW1lIGluIHZhcnMpIHtcbiAgICAgICAgICAgIGZuQXJnVmFsdWVzLnB1c2godmFyc1thcmdOYW1lXSk7XG4gICAgICAgICAgICBmbkFyZ05hbWVzLnB1c2goYXJnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNyZWF0ZVNvdXJjZU1hcCkge1xuICAgICAgICAgICAgLy8gdXNpbmcgYG5ldyBGdW5jdGlvbiguLi4pYCBnZW5lcmF0ZXMgYSBoZWFkZXIsIDEgbGluZSBvZiBubyBhcmd1bWVudHMsIDIgbGluZXMgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBFLmcuIGBgYFxuICAgICAgICAgICAgLy8gZnVuY3Rpb24gYW5vbnltb3VzKGEsYixjXG4gICAgICAgICAgICAvLyAvKiovKSB7IC4uLiB9YGBgXG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGhhcmQgY29kZSB0aGlzIGZhY3QsIHNvIHdlIGF1dG8gZGV0ZWN0IGl0IHZpYSBhbiBlbXB0eSBmdW5jdGlvbiBmaXJzdC5cbiAgICAgICAgICAgIGNvbnN0IGVtcHR5Rm4gPSBuZXdUcnVzdGVkRnVuY3Rpb25Gb3JKSVQoLi4uZm5BcmdOYW1lcy5jb25jYXQoJ3JldHVybiBudWxsOycpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyTGluZXMgPSBlbXB0eUZuLnNsaWNlKDAsIGVtcHR5Rm4uaW5kZXhPZigncmV0dXJuIG51bGw7JykpLnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm5Cb2R5ICs9IGBcXG4ke2N0eC50b1NvdXJjZU1hcEdlbmVyYXRvcihzb3VyY2VVcmwsIGhlYWRlckxpbmVzKS50b0pzQ29tbWVudCgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm4gPSBuZXdUcnVzdGVkRnVuY3Rpb25Gb3JKSVQoLi4uZm5BcmdOYW1lcy5jb25jYXQoZm5Cb2R5KSk7XG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVGdW5jdGlvbihmbiwgZm5BcmdWYWx1ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgSklUIGdlbmVyYXRlZCBmdW5jdGlvbiBieSBjYWxsaW5nIGl0LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gdGVzdHMgdG8gY2FwdHVyZSB0aGUgZnVuY3Rpb25zIHRoYXQgYXJlIGdlbmVyYXRlZFxuICAgICAqIGJ5IHRoaXMgYEppdEV2YWx1YXRvcmAgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gQSBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgICAqIEBwYXJhbSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gYmVpbmcgZXhlY3V0ZWQuXG4gICAgICogQHJldHVybnMgVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZXhlY3V0ZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZXhlY3V0ZUZ1bmN0aW9uKGZuLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbiguLi5hcmdzKTtcbiAgICB9XG59XG4vKipcbiAqIEFuIEFuZ3VsYXIgQVNUIHZpc2l0b3IgdGhhdCBjb252ZXJ0cyBBU1Qgbm9kZXMgaW50byBleGVjdXRhYmxlIEphdmFTY3JpcHQgY29kZS5cbiAqL1xuY2xhc3MgSml0RW1pdHRlclZpc2l0b3IgZXh0ZW5kcyBBYnN0cmFjdEpzRW1pdHRlclZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlZlJlc29sdmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVmUmVzb2x2ZXIgPSByZWZSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzID0gW107XG4gICAgICAgIHRoaXMuX2V2YWxBcmdWYWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZXZhbEV4cG9ydGVkVmFycyA9IFtdO1xuICAgIH1cbiAgICBjcmVhdGVSZXR1cm5TdG10KGN0eCkge1xuICAgICAgICBjb25zdCBzdG10ID0gbmV3IFJldHVyblN0YXRlbWVudChuZXcgTGl0ZXJhbE1hcEV4cHIodGhpcy5fZXZhbEV4cG9ydGVkVmFycy5tYXAocmVzdWx0VmFyID0+IG5ldyBMaXRlcmFsTWFwRW50cnkocmVzdWx0VmFyLCB2YXJpYWJsZShyZXN1bHRWYXIpLCBmYWxzZSkpKSk7XG4gICAgICAgIHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY3R4KTtcbiAgICB9XG4gICAgZ2V0QXJncygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZXZhbEFyZ05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRbdGhpcy5fZXZhbEFyZ05hbWVzW2ldXSA9IHRoaXMuX2V2YWxBcmdWYWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmlzaXRFeHRlcm5hbEV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhpcy5fZW1pdFJlZmVyZW5jZVRvRXh0ZXJuYWwoYXN0LCB0aGlzLnJlZlJlc29sdmVyLnJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZShhc3QudmFsdWUpLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRXcmFwcGVkTm9kZUV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhpcy5fZW1pdFJlZmVyZW5jZVRvRXh0ZXJuYWwoYXN0LCBhc3Qubm9kZSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0RGVjbGFyZVZhclN0bXQoc3RtdCwgY3R4KSB7XG4gICAgICAgIGlmIChzdG10Lmhhc01vZGlmaWVyKGV4cG9ydHMuU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgdGhpcy5fZXZhbEV4cG9ydGVkVmFycy5wdXNoKHN0bXQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0RGVjbGFyZVZhclN0bXQoc3RtdCwgY3R4KTtcbiAgICB9XG4gICAgdmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihleHBvcnRzLlN0bXRNb2RpZmllci5FeHBvcnRlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2YWxFeHBvcnRlZFZhcnMucHVzaChzdG10Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQoc3RtdCwgY3R4KTtcbiAgICB9XG4gICAgX2VtaXRSZWZlcmVuY2VUb0V4dGVybmFsKGFzdCwgdmFsdWUsIGN0eCkge1xuICAgICAgICBsZXQgaWQgPSB0aGlzLl9ldmFsQXJnVmFsdWVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICBpZiAoaWQgPT09IC0xKSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMuX2V2YWxBcmdWYWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ1ZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBpZGVudGlmaWVyTmFtZSh7IHJlZmVyZW5jZTogdmFsdWUgfSkgfHwgJ3ZhbCc7XG4gICAgICAgICAgICB0aGlzLl9ldmFsQXJnTmFtZXMucHVzaChgaml0XyR7bmFtZX1fJHtpZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoYXN0LCB0aGlzLl9ldmFsQXJnTmFtZXNbaWRdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1VzZVN0cmljdFN0YXRlbWVudChzdGF0ZW1lbnQpIHtcbiAgICByZXR1cm4gc3RhdGVtZW50LmlzRXF1aXZhbGVudChsaXRlcmFsKCd1c2Ugc3RyaWN0JykudG9TdG10KCkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVJbmplY3RvcihtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgaWYgKG1ldGEucHJvdmlkZXJzICE9PSBudWxsKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdwcm92aWRlcnMnLCBtZXRhLnByb3ZpZGVycyk7XG4gICAgfVxuICAgIGlmIChtZXRhLmltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaW1wb3J0cycsIGxpdGVyYWxBcnIobWV0YS5pbXBvcnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlZmluZUluamVjdG9yKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVJbmplY3RvclR5cGUobWV0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50czogW10gfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluamVjdG9yVHlwZShtZXRhKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzLkluamVjdG9yRGVjbGFyYXRpb24sIFtuZXcgRXhwcmVzc2lvblR5cGUobWV0YS50eXBlLnR5cGUpXSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYENvbXBpbGVSZWZsZWN0b3JgIHdoaWNoIHJlc29sdmVzIHJlZmVyZW5jZXMgdG8gQGFuZ3VsYXIvY29yZVxuICogc3ltYm9scyBhdCBydW50aW1lLCBhY2NvcmRpbmcgdG8gYSBjb25zdW1lci1wcm92aWRlZCBtYXBwaW5nLlxuICpcbiAqIE9ubHkgc3VwcG9ydHMgYHJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZWAsIGFsbCBvdGhlciBtZXRob2RzIHRocm93LlxuICovXG5jbGFzcyBSM0ppdFJlZmxlY3RvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICByZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UocmVmKSB7XG4gICAgICAgIC8vIFRoaXMgcmVmbGVjdG9yIG9ubHkgaGFuZGxlcyBAYW5ndWxhci9jb3JlIGltcG9ydHMuXG4gICAgICAgIGlmIChyZWYubW9kdWxlTmFtZSAhPT0gJ0Bhbmd1bGFyL2NvcmUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIGV4dGVybmFsIHJlZmVyZW5jZSB0byAke3JlZi5tb2R1bGVOYW1lfSwgb25seSByZWZlcmVuY2VzIHRvIEBhbmd1bGFyL2NvcmUgYXJlIHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5oYXNPd25Qcm9wZXJ0eShyZWYubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdmFsdWUgcHJvdmlkZWQgZm9yIEBhbmd1bGFyL2NvcmUgc3ltYm9sICcke3JlZi5uYW1lfScuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFtyZWYubmFtZV07XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogSG93IHRoZSBzZWxlY3RvciBzY29wZSBvZiBhbiBOZ01vZHVsZSAoaXRzIGRlY2xhcmF0aW9ucywgaW1wb3J0cywgYW5kIGV4cG9ydHMpIHNob3VsZCBiZSBlbWl0dGVkXG4gKiBhcyBhIHBhcnQgb2YgdGhlIE5nTW9kdWxlIGRlZmluaXRpb24uXG4gKi9cbmV4cG9ydHMuUjNTZWxlY3RvclNjb3BlTW9kZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoUjNTZWxlY3RvclNjb3BlTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEVtaXQgdGhlIGRlY2xhcmF0aW9ucyBpbmxpbmUgaW50byB0aGUgbW9kdWxlIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG9wdGlvbiBpcyB1c2VmdWwgaW4gY2VydGFpbiBjb250ZXh0cyB3aGVyZSBpdCdzIGtub3duIHRoYXQgSklUIHN1cHBvcnQgaXMgcmVxdWlyZWQuIFRoZVxuICAgICAqIHRyYWRlb2ZmIGhlcmUgaXMgdGhhdCB0aGlzIGVtaXQgc3R5bGUgcHJldmVudHMgZGlyZWN0aXZlcyBhbmQgcGlwZXMgZnJvbSBiZWluZyB0cmVlLXNoYWtlbiBpZlxuICAgICAqIHRoZXkgYXJlIHVudXNlZCwgYnV0IHRoZSBOZ01vZHVsZSBpcyB1c2VkLlxuICAgICAqL1xuICAgIFIzU2VsZWN0b3JTY29wZU1vZGVbUjNTZWxlY3RvclNjb3BlTW9kZVtcIklubGluZVwiXSA9IDBdID0gXCJJbmxpbmVcIjtcbiAgICAvKipcbiAgICAgKiBFbWl0IHRoZSBkZWNsYXJhdGlvbnMgdXNpbmcgYSBzaWRlIGVmZmVjdGZ1bCBmdW5jdGlvbiBjYWxsLCBgybXJtXNldE5nTW9kdWxlU2NvcGVgLCB0aGF0IGlzXG4gICAgICogZ3VhcmRlZCB3aXRoIHRoZSBgbmdKaXRNb2RlYCBmbGFnLlxuICAgICAqXG4gICAgICogVGhpcyBmb3JtIG9mIGVtaXQgc3VwcG9ydHMgSklUIGFuZCBjYW4gYmUgb3B0aW1pemVkIGF3YXkgaWYgdGhlIGBuZ0ppdE1vZGVgIGZsYWcgaXMgc2V0IHRvXG4gICAgICogZmFsc2UsIHdoaWNoIGFsbG93cyB1bnVzZWQgZGlyZWN0aXZlcyBhbmQgcGlwZXMgdG8gYmUgdHJlZS1zaGFrZW4uXG4gICAgICovXG4gICAgUjNTZWxlY3RvclNjb3BlTW9kZVtSM1NlbGVjdG9yU2NvcGVNb2RlW1wiU2lkZUVmZmVjdFwiXSA9IDFdID0gXCJTaWRlRWZmZWN0XCI7XG4gICAgLyoqXG4gICAgICogRG9uJ3QgZ2VuZXJhdGUgc2VsZWN0b3Igc2NvcGVzIGF0IGFsbC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb250ZXh0cyB3aGVyZSBKSVQgc3VwcG9ydCBpcyBrbm93biB0byBiZSB1bm5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBSM1NlbGVjdG9yU2NvcGVNb2RlW1IzU2VsZWN0b3JTY29wZU1vZGVbXCJPbWl0XCJdID0gMl0gPSBcIk9taXRcIjtcbn0pKGV4cG9ydHMuUjNTZWxlY3RvclNjb3BlTW9kZSB8fCAoZXhwb3J0cy5SM1NlbGVjdG9yU2NvcGVNb2RlID0ge30pKTtcbi8qKlxuICogQ29uc3RydWN0IGFuIGBSM05nTW9kdWxlRGVmYCBmb3IgdGhlIGdpdmVuIGBSM05nTW9kdWxlTWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlTmdNb2R1bGUobWV0YSkge1xuICAgIGNvbnN0IHsgYWRqYWNlbnRUeXBlLCBpbnRlcm5hbFR5cGUsIGJvb3RzdHJhcCwgZGVjbGFyYXRpb25zLCBpbXBvcnRzLCBleHBvcnRzOiBleHBvcnRzJDEsIHNjaGVtYXMsIGNvbnRhaW5zRm9yd2FyZERlY2xzLCBzZWxlY3RvclNjb3BlTW9kZSwgaWQgfSA9IG1ldGE7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgaW50ZXJuYWxUeXBlKTtcbiAgICBpZiAoYm9vdHN0cmFwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2Jvb3RzdHJhcCcsIHJlZnNUb0FycmF5KGJvb3RzdHJhcCwgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdG9yU2NvcGVNb2RlID09PSBleHBvcnRzLlIzU2VsZWN0b3JTY29wZU1vZGUuSW5saW5lKSB7XG4gICAgICAgIC8vIElmIHJlcXVlc3RlZCB0byBlbWl0IHNjb3BlIGluZm9ybWF0aW9uIGlubGluZSwgcGFzcyB0aGUgYGRlY2xhcmF0aW9uc2AsIGBpbXBvcnRzYCBhbmRcbiAgICAgICAgLy8gYGV4cG9ydHNgIHRvIHRoZSBgybXJtWRlZmluZU5nTW9kdWxlKClgIGNhbGwgZGlyZWN0bHkuXG4gICAgICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlY2xhcmF0aW9ucycsIHJlZnNUb0FycmF5KGRlY2xhcmF0aW9ucywgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaW1wb3J0cycsIHJlZnNUb0FycmF5KGltcG9ydHMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9ydHMkMS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZXhwb3J0cycsIHJlZnNUb0FycmF5KGV4cG9ydHMkMSwgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3RvclNjb3BlTW9kZSA9PT0gZXhwb3J0cy5SM1NlbGVjdG9yU2NvcGVNb2RlLlNpZGVFZmZlY3QpIHtcbiAgICAgICAgLy8gSW4gdGhpcyBtb2RlLCBzY29wZSBpbmZvcm1hdGlvbiBpcyBub3QgcGFzc2VkIGludG8gYMm1ybVkZWZpbmVOZ01vZHVsZWAgYXMgaXRcbiAgICAgICAgLy8gd291bGQgcHJldmVudCB0cmVlLXNoYWtpbmcgb2YgdGhlIGRlY2xhcmF0aW9ucywgaW1wb3J0cyBhbmQgZXhwb3J0cyByZWZlcmVuY2VzLiBJbnN0ZWFkLCBpdCdzXG4gICAgICAgIC8vIHBhdGNoZWQgb250byB0aGUgTmdNb2R1bGUgZGVmaW5pdGlvbiB3aXRoIGEgYMm1ybVzZXROZ01vZHVsZVNjb3BlYCBjYWxsIHRoYXQncyBndWFyZGVkIGJ5IHRoZVxuICAgICAgICAvLyBgbmdKaXRNb2RlYCBmbGFnLlxuICAgICAgICBjb25zdCBzZXROZ01vZHVsZVNjb3BlQ2FsbCA9IGdlbmVyYXRlU2V0TmdNb2R1bGVTY29wZUNhbGwobWV0YSk7XG4gICAgICAgIGlmIChzZXROZ01vZHVsZVNjb3BlQ2FsbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKHNldE5nTW9kdWxlU2NvcGVDYWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIDtcbiAgICBpZiAoc2NoZW1hcyAhPT0gbnVsbCAmJiBzY2hlbWFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3NjaGVtYXMnLCBsaXRlcmFsQXJyKHNjaGVtYXMubWFwKHJlZiA9PiByZWYudmFsdWUpKSk7XG4gICAgfVxuICAgIGlmIChpZCAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaWQnLCBpZCk7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgc2lkZS1lZmZlY3RmdWwgY2FsbCB0byByZWdpc3RlciB0aGlzIE5nTW9kdWxlIGJ5IGl0cyBpZCwgYXMgcGVyIHRoZSBzZW1hbnRpY3Mgb2ZcbiAgICAgICAgLy8gTmdNb2R1bGUgaWRzLlxuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycy5yZWdpc3Rlck5nTW9kdWxlVHlwZSkuY2FsbEZuKFthZGphY2VudFR5cGUsIGlkXSkudG9TdG10KCkpO1xuICAgIH1cbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5kZWZpbmVOZ01vZHVsZSkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBjb25zdCB0eXBlID0gY3JlYXRlTmdNb2R1bGVUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHMgfTtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluIEpJVCBtb2RlIHRvIGdlbmVyYXRlIHRoZSBjYWxsIHRvIGDJtcm1ZGVmaW5lTmdNb2R1bGUoKWAgZnJvbSBhIGNhbGwgdG9cbiAqIGDJtcm1bmdEZWNsYXJlTmdNb2R1bGUoKWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVOZ01vZHVsZURlY2xhcmF0aW9uRXhwcmVzc2lvbihtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3R5cGUnLCBuZXcgV3JhcHBlZE5vZGVFeHByKG1ldGEudHlwZSkpO1xuICAgIGlmIChtZXRhLmJvb3RzdHJhcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdib290c3RyYXAnLCBuZXcgV3JhcHBlZE5vZGVFeHByKG1ldGEuYm9vdHN0cmFwKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmRlY2xhcmF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZWNsYXJhdGlvbnMnLCBuZXcgV3JhcHBlZE5vZGVFeHByKG1ldGEuZGVjbGFyYXRpb25zKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmltcG9ydHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaW1wb3J0cycsIG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS5pbXBvcnRzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmV4cG9ydHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZXhwb3J0cycsIG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS5leHBvcnRzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnNjaGVtYXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc2NoZW1hcycsIG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS5zY2hlbWFzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2lkJywgbmV3IFdyYXBwZWROb2RlRXhwcihtZXRhLmlkKSk7XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlZmluZU5nTW9kdWxlKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5nTW9kdWxlVHlwZSh7IHR5cGU6IG1vZHVsZVR5cGUsIGRlY2xhcmF0aW9ucywgaW1wb3J0cywgZXhwb3J0cyB9KSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzLk5nTW9kdWxlRGVjbGFyYXRpb24sIFtcbiAgICAgICAgbmV3IEV4cHJlc3Npb25UeXBlKG1vZHVsZVR5cGUudHlwZSksIHR1cGxlVHlwZU9mKGRlY2xhcmF0aW9ucyksIHR1cGxlVHlwZU9mKGltcG9ydHMpLFxuICAgICAgICB0dXBsZVR5cGVPZihleHBvcnRzKVxuICAgIF0pKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgZnVuY3Rpb24gY2FsbCB0byBgybXJtXNldE5nTW9kdWxlU2NvcGVgIHdpdGggYWxsIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBzbyB0aGF0IHRoZVxuICogdHJhbnNpdGl2ZSBtb2R1bGUgc2NvcGUgY2FuIGJlIGNvbXB1dGVkIGR1cmluZyBydW50aW1lIGluIEpJVCBtb2RlLiBUaGlzIGNhbGwgaXMgbWFya2VkIHB1cmVcbiAqIHN1Y2ggdGhhdCB0aGUgcmVmZXJlbmNlcyB0byBkZWNsYXJhdGlvbnMsIGltcG9ydHMgYW5kIGV4cG9ydHMgbWF5IGJlIGVsaWRlZCBjYXVzaW5nIHRoZXNlXG4gKiBzeW1ib2xzIHRvIGJlY29tZSB0cmVlLXNoYWtlYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVTZXROZ01vZHVsZVNjb3BlQ2FsbChtZXRhKSB7XG4gICAgY29uc3QgeyBhZGphY2VudFR5cGU6IG1vZHVsZVR5cGUsIGRlY2xhcmF0aW9ucywgaW1wb3J0cywgZXhwb3J0cywgY29udGFpbnNGb3J3YXJkRGVjbHMgfSA9IG1ldGE7XG4gICAgY29uc3Qgc2NvcGVNYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGlmIChkZWNsYXJhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBzY29wZU1hcC5zZXQoJ2RlY2xhcmF0aW9ucycsIHJlZnNUb0FycmF5KGRlY2xhcmF0aW9ucywgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgaWYgKGltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzY29wZU1hcC5zZXQoJ2ltcG9ydHMnLCByZWZzVG9BcnJheShpbXBvcnRzLCBjb250YWluc0ZvcndhcmREZWNscykpO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNjb3BlTWFwLnNldCgnZXhwb3J0cycsIHJlZnNUb0FycmF5KGV4cG9ydHMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhzY29wZU1hcC52YWx1ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gc2V0TmdNb2R1bGVTY29wZSguLi4pXG4gICAgY29uc3QgZm5DYWxsID0gbmV3IEludm9rZUZ1bmN0aW9uRXhwcihcbiAgICAvKiBmbiAqLyBpbXBvcnRFeHByKElkZW50aWZpZXJzLnNldE5nTW9kdWxlU2NvcGUpLCBcbiAgICAvKiBhcmdzICovIFttb2R1bGVUeXBlLCBzY29wZU1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIC8vIChuZ0ppdE1vZGUgZ3VhcmQpICYmIHNldE5nTW9kdWxlU2NvcGUoLi4uKVxuICAgIGNvbnN0IGd1YXJkZWRDYWxsID0gaml0T25seUd1YXJkZWRFeHByZXNzaW9uKGZuQ2FsbCk7XG4gICAgLy8gZnVuY3Rpb24oKSB7IChuZ0ppdE1vZGUgZ3VhcmQpICYmIHNldE5nTW9kdWxlU2NvcGUoLi4uKTsgfVxuICAgIGNvbnN0IGlpZmUgPSBuZXcgRnVuY3Rpb25FeHByKFxuICAgIC8qIHBhcmFtcyAqLyBbXSwgXG4gICAgLyogc3RhdGVtZW50cyAqLyBbZ3VhcmRlZENhbGwudG9TdG10KCldKTtcbiAgICAvLyAoZnVuY3Rpb24oKSB7IChuZ0ppdE1vZGUgZ3VhcmQpICYmIHNldE5nTW9kdWxlU2NvcGUoLi4uKTsgfSkoKVxuICAgIGNvbnN0IGlpZmVDYWxsID0gbmV3IEludm9rZUZ1bmN0aW9uRXhwcihcbiAgICAvKiBmbiAqLyBpaWZlLCBcbiAgICAvKiBhcmdzICovIFtdKTtcbiAgICByZXR1cm4gaWlmZUNhbGwudG9TdG10KCk7XG59XG5mdW5jdGlvbiB0dXBsZVR5cGVPZihleHApIHtcbiAgICBjb25zdCB0eXBlcyA9IGV4cC5tYXAocmVmID0+IHR5cGVvZkV4cHIocmVmLnR5cGUpKTtcbiAgICByZXR1cm4gZXhwLmxlbmd0aCA+IDAgPyBleHByZXNzaW9uVHlwZShsaXRlcmFsQXJyKHR5cGVzKSkgOiBOT05FX1RZUEU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gY29tcGlsZVBpcGVGcm9tTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwVmFsdWVzID0gW107XG4gICAgLy8gZS5nLiBgbmFtZTogJ215UGlwZSdgXG4gICAgZGVmaW5pdGlvbk1hcFZhbHVlcy5wdXNoKHsga2V5OiAnbmFtZScsIHZhbHVlOiBsaXRlcmFsKG1ldGFkYXRhLnBpcGVOYW1lKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICAvLyBlLmcuIGB0eXBlOiBNeVBpcGVgXG4gICAgZGVmaW5pdGlvbk1hcFZhbHVlcy5wdXNoKHsga2V5OiAndHlwZScsIHZhbHVlOiBtZXRhZGF0YS50eXBlLnZhbHVlLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIC8vIGUuZy4gYHB1cmU6IHRydWVgXG4gICAgZGVmaW5pdGlvbk1hcFZhbHVlcy5wdXNoKHsga2V5OiAncHVyZScsIHZhbHVlOiBsaXRlcmFsKG1ldGFkYXRhLnB1cmUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIGlmIChtZXRhZGF0YS5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcFZhbHVlcy5wdXNoKHsga2V5OiAnc3RhbmRhbG9uZScsIHZhbHVlOiBsaXRlcmFsKHRydWUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5kZWZpbmVQaXBlKS5jYWxsRm4oW2xpdGVyYWxNYXAoZGVmaW5pdGlvbk1hcFZhbHVlcyldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVQaXBlVHlwZShtZXRhZGF0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50czogW10gfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBpcGVUeXBlKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzLlBpcGVEZWNsYXJhdGlvbiwgW1xuICAgICAgICB0eXBlV2l0aFBhcmFtZXRlcnMobWV0YWRhdGEudHlwZS50eXBlLCBtZXRhZGF0YS50eXBlQXJndW1lbnRDb3VudCksXG4gICAgICAgIG5ldyBFeHByZXNzaW9uVHlwZShuZXcgTGl0ZXJhbEV4cHIobWV0YWRhdGEucGlwZU5hbWUpKSxcbiAgICAgICAgbmV3IEV4cHJlc3Npb25UeXBlKG5ldyBMaXRlcmFsRXhwcihtZXRhZGF0YS5pc1N0YW5kYWxvbmUpKSxcbiAgICBdKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZXhwb3J0cy5SM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmQgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZCkge1xuICAgIFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZFtSM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmRbXCJEaXJlY3RpdmVcIl0gPSAwXSA9IFwiRGlyZWN0aXZlXCI7XG4gICAgUjNUZW1wbGF0ZURlcGVuZGVuY3lLaW5kW1IzVGVtcGxhdGVEZXBlbmRlbmN5S2luZFtcIlBpcGVcIl0gPSAxXSA9IFwiUGlwZVwiO1xuICAgIFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZFtSM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmRbXCJOZ01vZHVsZVwiXSA9IDJdID0gXCJOZ01vZHVsZVwiO1xufSkoZXhwb3J0cy5SM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmQgfHwgKGV4cG9ydHMuUjNUZW1wbGF0ZURlcGVuZGVuY3lLaW5kID0ge30pKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBQYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZXJyTG9jYXRpb24gPSBlcnJMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5jdHhMb2NhdGlvbiA9IGN0eExvY2F0aW9uO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgUGFyc2VyIEVycm9yOiAke21lc3NhZ2V9ICR7ZXJyTG9jYXRpb259IFske2lucHV0fV0gaW4gJHtjdHhMb2NhdGlvbn1gO1xuICAgIH1cbn1cbmNsYXNzIFBhcnNlU3BhbiB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICB0b0Fic29sdXRlKGFic29sdXRlT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGFic29sdXRlT2Zmc2V0ICsgdGhpcy5zdGFydCwgYWJzb2x1dGVPZmZzZXQgKyB0aGlzLmVuZCk7XG4gICAgfVxufVxuY2xhc3MgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBcbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSBsb2NhdGlvbiBvZiB0aGUgZXhwcmVzc2lvbiBBU1QgaW4gYSBzb3VyY2UgY29kZSBmaWxlLlxuICAgICAqL1xuICAgIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnQVNUJztcbiAgICB9XG59XG5jbGFzcyBBU1RXaXRoTmFtZSBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMubmFtZVNwYW4gPSBuYW1lU3BhbjtcbiAgICB9XG59XG5jbGFzcyBFbXB0eUV4cHIgZXh0ZW5kcyBBU1Qge1xuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5jbGFzcyBJbXBsaWNpdFJlY2VpdmVyIGV4dGVuZHMgQVNUIHtcbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEltcGxpY2l0UmVjZWl2ZXIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWNlaXZlciB3aGVuIHNvbWV0aGluZyBpcyBhY2Nlc3NlZCB0aHJvdWdoIGB0aGlzYCAoZS5nLiBgdGhpcy5mb29gKS4gTm90ZSB0aGF0IHRoaXMgY2xhc3NcbiAqIGluaGVyaXRzIGZyb20gYEltcGxpY2l0UmVjZWl2ZXJgLCBiZWNhdXNlIGFjY2Vzc2luZyBzb21ldGhpbmcgdGhyb3VnaCBgdGhpc2AgaXMgdHJlYXRlZCB0aGVcbiAqIHNhbWUgYXMgYWNjZXNzaW5nIGl0IGltcGxpY2l0bHkgaW5zaWRlIG9mIGFuIEFuZ3VsYXIgdGVtcGxhdGUgKGUuZy4gYFthdHRyLnRpdGxlXT1cInRoaXMudGl0bGVcImBcbiAqIGlzIHRoZSBzYW1lIGFzIGBbYXR0ci50aXRsZV09XCJ0aXRsZVwiYC4pLiBJbmhlcml0aW5nIGFsbG93cyBmb3IgdGhlIGB0aGlzYCBhY2Nlc3NlcyB0byBiZSB0cmVhdGVkXG4gKiB0aGUgc2FtZSBhcyBpbXBsaWNpdCBvbmVzLCBleGNlcHQgZm9yIGEgY291cGxlIG9mIGV4Y2VwdGlvbnMgbGlrZSBgJGV2ZW50YCBhbmQgYCRhbnlgLlxuICogVE9ETzogd2Ugc2hvdWxkIGZpbmQgYSB3YXkgZm9yIHRoaXMgY2xhc3Mgbm90IHRvIGV4dGVuZCBmcm9tIGBJbXBsaWNpdFJlY2VpdmVyYCBpbiB0aGUgZnV0dXJlLlxuICovXG5jbGFzcyBUaGlzUmVjZWl2ZXIgZXh0ZW5kcyBJbXBsaWNpdFJlY2VpdmVyIHtcbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB2aXNpdG9yLnZpc2l0VGhpc1JlY2VpdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2aXNpdG9yLCB0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG4vKipcbiAqIE11bHRpcGxlIGV4cHJlc3Npb25zIHNlcGFyYXRlZCBieSBhIHNlbWljb2xvbi5cbiAqL1xuY2xhc3MgQ2hhaW4gZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q2hhaW4odGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQ29uZGl0aW9uYWwgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGNvbmRpdGlvbiwgdHJ1ZUV4cCwgZmFsc2VFeHApIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICB0aGlzLnRydWVFeHAgPSB0cnVlRXhwO1xuICAgICAgICB0aGlzLmZhbHNlRXhwID0gZmFsc2VFeHA7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWwodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgUHJvcGVydHlSZWFkIGV4dGVuZHMgQVNUV2l0aE5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuLCByZWNlaXZlciwgbmFtZSkge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuLCBuYW1lU3Bhbik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgUHJvcGVydHlXcml0ZSBleHRlbmRzIEFTVFdpdGhOYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBuYW1lU3BhbiwgcmVjZWl2ZXIsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJvcGVydHlXcml0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBTYWZlUHJvcGVydHlSZWFkIGV4dGVuZHMgQVNUV2l0aE5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuLCByZWNlaXZlciwgbmFtZSkge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuLCBuYW1lU3Bhbik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlUHJvcGVydHlSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEtleWVkUmVhZCBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgcmVjZWl2ZXIsIGtleSkge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgU2FmZUtleWVkUmVhZCBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgcmVjZWl2ZXIsIGtleSkge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTYWZlS2V5ZWRSZWFkKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEtleWVkV3JpdGUgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIHJlY2VpdmVyLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0S2V5ZWRXcml0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBCaW5kaW5nUGlwZSBleHRlbmRzIEFTVFdpdGhOYW1lIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBleHAsIG5hbWUsIGFyZ3MsIG5hbWVTcGFuKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuKTtcbiAgICAgICAgdGhpcy5leHAgPSBleHA7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGlwZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBMaXRlcmFsUHJpbWl0aXZlIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxQcmltaXRpdmUodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgTGl0ZXJhbEFycmF5IGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBleHByZXNzaW9ucykge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxBcnJheSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBMaXRlcmFsTWFwIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBrZXlzLCB2YWx1ZXMpIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdExpdGVyYWxNYXAodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgSW50ZXJwb2xhdGlvbiBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3Bhbiwgc3RyaW5ncywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnRlcnBvbGF0aW9uKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEJpbmFyeSBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3Bhbiwgb3BlcmF0aW9uLCBsZWZ0LCByaWdodCkge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5hcnkodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29ucywgYFVuYXJ5YCBpbmhlcml0cyBmcm9tIGBCaW5hcnlgIGFuZCBtaW1pY3MgdGhlIGJpbmFyeSBBU1RcbiAqIG5vZGUgdGhhdCB3YXMgb3JpZ2luYWxseSB1c2VkLiBUaGlzIGluaGVyaXRhbmNlIHJlbGF0aW9uIGNhbiBiZSBkZWxldGVkIGluIHNvbWUgZnV0dXJlIG1ham9yLFxuICogYWZ0ZXIgY29uc3VtZXJzIGhhdmUgYmVlbiBnaXZlbiBhIGNoYW5jZSB0byBmdWxseSBzdXBwb3J0IFVuYXJ5LlxuICovXG5jbGFzcyBVbmFyeSBleHRlbmRzIEJpbmFyeSB7XG4gICAgLyoqXG4gICAgICogRHVyaW5nIHRoZSBkZXByZWNhdGlvbiBwZXJpb2QgdGhpcyBjb25zdHJ1Y3RvciBpcyBwcml2YXRlLCB0byBhdm9pZCBjb25zdW1lcnMgZnJvbSBjcmVhdGluZ1xuICAgICAqIGEgYFVuYXJ5YCB3aXRoIHRoZSBmYWxsYmFjayBwcm9wZXJ0aWVzIGZvciBgQmluYXJ5YC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBvcGVyYXRvciwgZXhwciwgYmluYXJ5T3AsIGJpbmFyeUxlZnQsIGJpbmFyeVJpZ2h0KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4sIGJpbmFyeU9wLCBiaW5hcnlMZWZ0LCBiaW5hcnlSaWdodCk7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5leHByID0gZXhwcjtcbiAgICAgICAgLy8gUmVkZWNsYXJlIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGluaGVyaXRlZCBmcm9tIGBCaW5hcnlgIGFzIGBuZXZlcmAsIGFzIGNvbnN1bWVycyBzaG91bGQgbm90XG4gICAgICAgIC8vIGRlcGVuZCBvbiB0aGVzZSBmaWVsZHMgd2hlbiBvcGVyYXRpbmcgb24gYFVuYXJ5YC5cbiAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHVuYXJ5IG1pbnVzIGV4cHJlc3Npb24gXCIteFwiLCByZXByZXNlbnRlZCBhcyBgQmluYXJ5YCB1c2luZyBcIjAgLSB4XCIuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU1pbnVzKHNwYW4sIHNvdXJjZVNwYW4sIGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmFyeShzcGFuLCBzb3VyY2VTcGFuLCAnLScsIGV4cHIsICctJywgbmV3IExpdGVyYWxQcmltaXRpdmUoc3Bhbiwgc291cmNlU3BhbiwgMCksIGV4cHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdW5hcnkgcGx1cyBleHByZXNzaW9uIFwiK3hcIiwgcmVwcmVzZW50ZWQgYXMgYEJpbmFyeWAgdXNpbmcgXCJ4IC0gMFwiLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQbHVzKHNwYW4sIHNvdXJjZVNwYW4sIGV4cHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmFyeShzcGFuLCBzb3VyY2VTcGFuLCAnKycsIGV4cHIsICctJywgZXhwciwgbmV3IExpdGVyYWxQcmltaXRpdmUoc3Bhbiwgc291cmNlU3BhbiwgMCkpO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICBpZiAodmlzaXRvci52aXNpdFVuYXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VW5hcnkodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCaW5hcnkodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgUHJlZml4Tm90IGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByZWZpeE5vdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBOb25OdWxsQXNzZXJ0IGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE5vbk51bGxBc3NlcnQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQ2FsbCBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgcmVjZWl2ZXIsIGFyZ3MsIGFyZ3VtZW50U3Bhbikge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmFyZ3VtZW50U3BhbiA9IGFyZ3VtZW50U3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFNhZmVDYWxsIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCByZWNlaXZlciwgYXJncywgYXJndW1lbnRTcGFuKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuYXJndW1lbnRTcGFuID0gYXJndW1lbnRTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVDYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8qKlxuICogUmVjb3JkcyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgYSB0ZXh0IHNwYW4gaW4gYSBzb3VyY2UgZmlsZSwgd2hlcmUgYHN0YXJ0YCBhbmQgYGVuZGAgYXJlIHRoZVxuICogc3RhcnRpbmcgYW5kIGVuZGluZyBieXRlIG9mZnNldHMsIHJlc3BlY3RpdmVseSwgb2YgdGhlIHRleHQgc3BhbiBpbiBhIHNvdXJjZSBmaWxlLlxuICovXG5jbGFzcyBBYnNvbHV0ZVNvdXJjZVNwYW4ge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB9XG59XG5jbGFzcyBBU1RXaXRoU291cmNlIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3Rvcihhc3QsIHNvdXJjZSwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBlcnJvcnMpIHtcbiAgICAgICAgc3VwZXIobmV3IFBhcnNlU3BhbigwLCBzb3VyY2UgPT09IG51bGwgPyAwIDogc291cmNlLmxlbmd0aCksIG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oYWJzb2x1dGVPZmZzZXQsIHNvdXJjZSA9PT0gbnVsbCA/IGFic29sdXRlT2Zmc2V0IDogYWJzb2x1dGVPZmZzZXQgKyBzb3VyY2UubGVuZ3RoKSk7XG4gICAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IudmlzaXRBU1RXaXRoU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFTVFdpdGhTb3VyY2UodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuc291cmNlfSBpbiAke3RoaXMubG9jYXRpb259YDtcbiAgICB9XG59XG5jbGFzcyBWYXJpYWJsZUJpbmRpbmcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuIGVudGlyZSBzcGFuIG9mIHRoZSBiaW5kaW5nLlxuICAgICAqIEBwYXJhbSBrZXkgbmFtZSBvZiB0aGUgTEhTIGFsb25nIHdpdGggaXRzIHNwYW4uXG4gICAgICogQHBhcmFtIHZhbHVlIG9wdGlvbmFsIHZhbHVlIGZvciB0aGUgUkhTIGFsb25nIHdpdGggaXRzIHNwYW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc291cmNlU3Bhbiwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIEV4cHJlc3Npb25CaW5kaW5nIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gc291cmNlU3BhbiBlbnRpcmUgc3BhbiBvZiB0aGUgYmluZGluZy5cbiAgICAgKiBAcGFyYW0ga2V5IGJpbmRpbmcgbmFtZSwgbGlrZSBuZ0Zvck9mLCBuZ0ZvclRyYWNrQnksIG5nSWYsIGFsb25nIHdpdGggaXRzXG4gICAgICogc3Bhbi4gTm90ZSB0aGF0IHRoZSBsZW5ndGggb2YgdGhlIHNwYW4gbWF5IG5vdCBiZSB0aGUgc2FtZSBhc1xuICAgICAqIGBrZXkuc291cmNlLmxlbmd0aGAuIEZvciBleGFtcGxlLFxuICAgICAqIDEuIGtleS5zb3VyY2UgPSBuZ0Zvciwga2V5LnNwYW4gaXMgZm9yIFwibmdGb3JcIlxuICAgICAqIDIuIGtleS5zb3VyY2UgPSBuZ0Zvck9mLCBrZXkuc3BhbiBpcyBmb3IgXCJvZlwiXG4gICAgICogMy4ga2V5LnNvdXJjZSA9IG5nRm9yVHJhY2tCeSwga2V5LnNwYW4gaXMgZm9yIFwidHJhY2tCeVwiXG4gICAgICogQHBhcmFtIHZhbHVlIG9wdGlvbmFsIGV4cHJlc3Npb24gZm9yIHRoZSBSSFMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc291cmNlU3Bhbiwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIFJlY3Vyc2l2ZUFzdFZpc2l0b3Ige1xuICAgIHZpc2l0KGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBqdXN0IHZpc2l0cyBldmVyeSBub2RlLlxuICAgICAgICAvLyBDbGFzc2VzIHRoYXQgZXh0ZW5kIFJlY3Vyc2l2ZUFzdFZpc2l0b3Igc2hvdWxkIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgLy8gdG8gc2VsZWN0aXZlbHkgdmlzaXQgdGhlIHNwZWNpZmllZCBub2RlLlxuICAgICAgICBhc3QudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0VW5hcnkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmV4cHIsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEJpbmFyeShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QubGVmdCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnJpZ2h0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRDaGFpbihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdENvbmRpdGlvbmFsKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5jb25kaXRpb24sIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC50cnVlRXhwLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdChhc3QuZmFsc2VFeHAsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFBpcGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmV4cCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXIoYXN0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdFRoaXNSZWNlaXZlcihhc3QsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0SW50ZXJwb2xhdGlvbihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEtleWVkUmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5rZXksIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdEtleWVkV3JpdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdChhc3Qua2V5LCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdChhc3QudmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxBcnJheShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxNYXAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZShhc3QsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0UHJlZml4Tm90KGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXROb25OdWxsQXNzZXJ0KGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVdyaXRlKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0U2FmZUtleWVkUmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5rZXksIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdENhbGwoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0U2FmZUNhbGwoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIEFzdFZpc2l0b3IgaW50ZXJmYWNlLCBqdXN0IGEgaGVscGVyIG1ldGhvZFxuICAgIHZpc2l0QWxsKGFzdHMsIGNvbnRleHQpIHtcbiAgICAgICAgZm9yIChjb25zdCBhc3Qgb2YgYXN0cykge1xuICAgICAgICAgICAgdGhpcy52aXNpdChhc3QsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQXN0VHJhbnNmb3JtZXIge1xuICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRUaGlzUmVjZWl2ZXIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0SW50ZXJwb2xhdGlvbihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnN0cmluZ3MsIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnZhbHVlKTtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lKTtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVdyaXRlKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5V3JpdGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QubmFtZVNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIGFzdC52YWx1ZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5uYW1lKTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsQXJyYXkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsTWFwKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxNYXAoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Qua2V5cywgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKSk7XG4gICAgfVxuICAgIHZpc2l0VW5hcnkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVW5hcnkuY3JlYXRlUGx1cyhhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5leHByLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeS5jcmVhdGVNaW51cyhhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5leHByLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHVuYXJ5IG9wZXJhdG9yICR7YXN0Lm9wZXJhdG9yfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0QmluYXJ5KGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5vcGVyYXRpb24sIGFzdC5sZWZ0LnZpc2l0KHRoaXMpLCBhc3QucmlnaHQudmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdFByZWZpeE5vdChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhOb3QoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0Tm9uTnVsbEFzc2VydChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb25OdWxsQXNzZXJ0KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdENvbmRpdGlvbmFsKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKSwgYXN0LnRydWVFeHAudmlzaXQodGhpcyksIGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUGlwZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5leHAudmlzaXQodGhpcyksIGFzdC5uYW1lLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSwgYXN0Lm5hbWVTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRLZXllZFJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3Qua2V5LnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgdmlzaXRLZXllZFdyaXRlKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEtleWVkV3JpdGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5rZXkudmlzaXQodGhpcyksIGFzdC52YWx1ZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0Q2FsbChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKSwgYXN0LmFyZ3VtZW50U3Bhbik7XG4gICAgfVxuICAgIHZpc2l0U2FmZUNhbGwoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FmZUNhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpLCBhc3QuYXJndW1lbnRTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRBbGwoYXN0cykge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBhc3RzW2ldLnZpc2l0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHZpc2l0Q2hhaW4oYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW4oYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucykpO1xuICAgIH1cbiAgICB2aXNpdFNhZmVLZXllZFJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FmZUtleWVkUmVhZChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0LmtleS52aXNpdCh0aGlzKSk7XG4gICAgfVxufVxuLy8gQSB0cmFuc2Zvcm1lciB0aGF0IG9ubHkgY3JlYXRlcyBuZXcgbm9kZXMgaWYgdGhlIHRyYW5zZm9ybWVyIG1ha2VzIGEgY2hhbmdlIG9yXG4vLyBhIGNoYW5nZSBpcyBtYWRlIGEgY2hpbGQgbm9kZS5cbmNsYXNzIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyIHtcbiAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0VGhpc1JlY2VpdmVyKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdEludGVycG9sYXRpb24oYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMgIT09IGFzdC5leHByZXNzaW9ucylcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbihhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5zdHJpbmdzLCBleHByZXNzaW9ucyk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgIT09IGFzdC5yZWNlaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QubmFtZVNwYW4sIHJlY2VpdmVyLCBhc3QubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVdyaXRlKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhc3QudmFsdWUudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gYXN0LnJlY2VpdmVyIHx8IHZhbHVlICE9PSBhc3QudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5uYW1lU3BhbiwgcmVjZWl2ZXIsIGFzdC5uYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBhc3QucmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZVByb3BlcnR5UmVhZChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5uYW1lU3BhbiwgcmVjZWl2ZXIsIGFzdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxBcnJheShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucyAhPT0gYXN0LmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGV4cHJlc3Npb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxNYXAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmlzaXRBbGwoYXN0LnZhbHVlcyk7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IGFzdC52YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5rZXlzLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0VW5hcnkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBhc3QuZXhwci52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKGV4cHIgIT09IGFzdC5leHByKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVW5hcnkuY3JlYXRlUGx1cyhhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGV4cHIpO1xuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVW5hcnkuY3JlYXRlTWludXMoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBleHByKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdW5hcnkgb3BlcmF0b3IgJHthc3Qub3BlcmF0b3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRCaW5hcnkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBhc3QubGVmdC52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBhc3QucmlnaHQudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChsZWZ0ICE9PSBhc3QubGVmdCB8fCByaWdodCAhPT0gYXN0LnJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5vcGVyYXRpb24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFByZWZpeE5vdChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiAhPT0gYXN0LmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJlZml4Tm90KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXROb25OdWxsQXNzZXJ0KGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uICE9PSBhc3QuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb25OdWxsQXNzZXJ0KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRDb25kaXRpb25hbChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY29uZGl0aW9uID0gYXN0LmNvbmRpdGlvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3QgdHJ1ZUV4cCA9IGFzdC50cnVlRXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCBmYWxzZUV4cCA9IGFzdC5mYWxzZUV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiAhPT0gYXN0LmNvbmRpdGlvbiB8fCB0cnVlRXhwICE9PSBhc3QudHJ1ZUV4cCB8fCBmYWxzZUV4cCAhPT0gYXN0LmZhbHNlRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgY29uZGl0aW9uLCB0cnVlRXhwLCBmYWxzZUV4cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRQaXBlKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBleHAgPSBhc3QuZXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncyk7XG4gICAgICAgIGlmIChleHAgIT09IGFzdC5leHAgfHwgYXJncyAhPT0gYXN0LmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluZGluZ1BpcGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBleHAsIGFzdC5uYW1lLCBhcmdzLCBhc3QubmFtZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0S2V5ZWRSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBvYmogPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IGtleSA9IGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChvYmogIT09IGFzdC5yZWNlaXZlciB8fCBrZXkgIT09IGFzdC5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgS2V5ZWRSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3Bhbiwgb2JqLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0S2V5ZWRXcml0ZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCBrZXkgPSBhc3Qua2V5LnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKG9iaiAhPT0gYXN0LnJlY2VpdmVyIHx8IGtleSAhPT0gYXN0LmtleSB8fCB2YWx1ZSAhPT0gYXN0LnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEtleWVkV3JpdGUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBvYmosIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0QWxsKGFzdHMpIHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gYXN0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3JpZ2luYWwudmlzaXQodGhpcyk7XG4gICAgICAgICAgICByZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIG1vZGlmaWVkID0gbW9kaWZpZWQgfHwgdmFsdWUgIT09IG9yaWdpbmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2RpZmllZCA/IHJlcyA6IGFzdHM7XG4gICAgfVxuICAgIHZpc2l0Q2hhaW4oYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25zID0gdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMgIT09IGFzdC5leHByZXNzaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGFpbihhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGV4cHJlc3Npb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdENhbGwoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncyk7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gYXN0LnJlY2VpdmVyIHx8IGFyZ3MgIT09IGFzdC5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCByZWNlaXZlciwgYXJncywgYXN0LmFyZ3VtZW50U3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRTYWZlQ2FsbChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBhc3QucmVjZWl2ZXIgfHwgYXJncyAhPT0gYXN0LmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZUNhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCByZWNlaXZlciwgYXJncywgYXN0LmFyZ3VtZW50U3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRTYWZlS2V5ZWRSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBvYmogPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IGtleSA9IGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChvYmogIT09IGFzdC5yZWNlaXZlciB8fCBrZXkgIT09IGFzdC5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2FmZUtleWVkUmVhZChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIG9iaiwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbn1cbi8vIEJpbmRpbmdzXG5jbGFzcyBQYXJzZWRQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZXhwcmVzc2lvbiwgdHlwZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLmlzTGl0ZXJhbCA9IHRoaXMudHlwZSA9PT0gZXhwb3J0cy5QYXJzZWRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSO1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW9uID0gdGhpcy50eXBlID09PSBleHBvcnRzLlBhcnNlZFByb3BlcnR5VHlwZS5BTklNQVRJT047XG4gICAgfVxufVxuZXhwb3J0cy5QYXJzZWRQcm9wZXJ0eVR5cGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFBhcnNlZFByb3BlcnR5VHlwZSkge1xuICAgIFBhcnNlZFByb3BlcnR5VHlwZVtQYXJzZWRQcm9wZXJ0eVR5cGVbXCJERUZBVUxUXCJdID0gMF0gPSBcIkRFRkFVTFRcIjtcbiAgICBQYXJzZWRQcm9wZXJ0eVR5cGVbUGFyc2VkUHJvcGVydHlUeXBlW1wiTElURVJBTF9BVFRSXCJdID0gMV0gPSBcIkxJVEVSQUxfQVRUUlwiO1xuICAgIFBhcnNlZFByb3BlcnR5VHlwZVtQYXJzZWRQcm9wZXJ0eVR5cGVbXCJBTklNQVRJT05cIl0gPSAyXSA9IFwiQU5JTUFUSU9OXCI7XG59KShleHBvcnRzLlBhcnNlZFByb3BlcnR5VHlwZSB8fCAoZXhwb3J0cy5QYXJzZWRQcm9wZXJ0eVR5cGUgPSB7fSkpO1xuY2xhc3MgUGFyc2VkRXZlbnQge1xuICAgIC8vIFJlZ3VsYXIgZXZlbnRzIGhhdmUgYSB0YXJnZXRcbiAgICAvLyBBbmltYXRpb24gZXZlbnRzIGhhdmUgYSBwaGFzZVxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHRhcmdldE9yUGhhc2UsIHR5cGUsIGhhbmRsZXIsIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCBrZXlTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudGFyZ2V0T3JQaGFzZSA9IHRhcmdldE9yUGhhc2U7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuaGFuZGxlclNwYW4gPSBoYW5kbGVyU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlZFZhcmlhYmxlIHJlcHJlc2VudHMgYSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBpbiBhIG1pY3Jvc3ludGF4IGV4cHJlc3Npb24uXG4gKi9cbmNsYXNzIFBhcnNlZFZhcmlhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxufVxuY2xhc3MgQm91bmRFbGVtZW50UHJvcGVydHkge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIHNlY3VyaXR5Q29udGV4dCwgdmFsdWUsIHVuaXQsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlY3VyaXR5Q29udGV4dCA9IHNlY3VyaXR5Q29udGV4dDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVuaXQgPSB1bml0O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmtleVNwYW4gPSBrZXlTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgRXZlbnRIYW5kbGVyVmFycyB7XG59XG5FdmVudEhhbmRsZXJWYXJzLmV2ZW50ID0gdmFyaWFibGUoJyRldmVudCcpO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBBU1QgaW50byBhbiBleGVjdXRhYmxlIG91dHB1dCBBU1QsIGFzc3VtaW5nIHRoZSBleHByZXNzaW9uIGlzXG4gKiB1c2VkIGluIGFuIGFjdGlvbiBiaW5kaW5nIChlLmcuIGFuIGV2ZW50IGhhbmRsZXIpLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0QWN0aW9uQmluZGluZyhsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBhY3Rpb24sIGJpbmRpbmdJZCwgYmFzZVNvdXJjZVNwYW4sIGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3NlcywgZ2xvYmFscykge1xuICAgIGlmICghbG9jYWxSZXNvbHZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyID0gbmV3IERlZmF1bHRMb2NhbFJlc29sdmVyKGdsb2JhbHMpO1xuICAgIH1cbiAgICBjb25zdCBhY3Rpb25XaXRob3V0QnVpbHRpbnMgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnMoe1xuICAgICAgICBjcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXI6IChhcmdDb3VudCkgPT4ge1xuICAgICAgICAgICAgLy8gTm90ZTogbm8gY2FjaGluZyBmb3IgbGl0ZXJhbCBhcnJheXMgaW4gYWN0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiAoYXJncykgPT4gbGl0ZXJhbEFycihhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcjogKGtleXMpID0+IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IG5vIGNhY2hpbmcgZm9yIGxpdGVyYWwgbWFwcyBpbiBhY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0ga2V5cy5tYXAoKGssIGkpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogay5rZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlZDogay5xdW90ZWQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXRlcmFsTWFwKGVudHJpZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlUGlwZUNvbnZlcnRlcjogKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBTdGF0ZTogQWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgdG8gY29udGFpbiBwaXBlcy4gUGlwZTogJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgfSwgYWN0aW9uKTtcbiAgICBjb25zdCB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBiaW5kaW5nSWQsIC8qIHN1cHBvcnRzSW50ZXJwb2xhdGlvbiAqLyBmYWxzZSwgYmFzZVNvdXJjZVNwYW4sIGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3Nlcyk7XG4gICAgY29uc3QgYWN0aW9uU3RtdHMgPSBbXTtcbiAgICBmbGF0dGVuU3RhdGVtZW50cyhhY3Rpb25XaXRob3V0QnVpbHRpbnMudmlzaXQodmlzaXRvciwgX01vZGUuU3RhdGVtZW50KSwgYWN0aW9uU3RtdHMpO1xuICAgIHByZXBlbmRUZW1wb3JhcnlEZWNscyh2aXNpdG9yLnRlbXBvcmFyeUNvdW50LCBiaW5kaW5nSWQsIGFjdGlvblN0bXRzKTtcbiAgICBpZiAodmlzaXRvci51c2VzSW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdEluZGV4ID0gYWN0aW9uU3RtdHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgY29uc3QgbGFzdFN0YXRlbWVudCA9IGFjdGlvblN0bXRzW2xhc3RJbmRleF07XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBleHByZXNzaW9uIHN0YXRlbWVudCBpcyByZXR1cm5lZFxuICAgICAgICBpZiAobGFzdFN0YXRlbWVudCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGFjdGlvblN0bXRzW2xhc3RJbmRleF0gPSBuZXcgUmV0dXJuU3RhdGVtZW50KGxhc3RTdGF0ZW1lbnQuZXhwcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvblN0bXRzO1xufVxuZnVuY3Rpb24gY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIHJldHVybiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KTtcbn1cbmNsYXNzIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHN0bXRzLCBjdXJyVmFsRXhwcikge1xuICAgICAgICB0aGlzLnN0bXRzID0gc3RtdHM7XG4gICAgICAgIHRoaXMuY3VyclZhbEV4cHIgPSBjdXJyVmFsRXhwcjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBleHByZXNzaW9uIEFTVCBpbnRvIGFuIGV4ZWN1dGFibGUgb3V0cHV0IEFTVCwgYXNzdW1pbmcgdGhlIGV4cHJlc3Npb25cbiAqIGlzIHVzZWQgaW4gcHJvcGVydHkgYmluZGluZy4gVGhlIGV4cHJlc3Npb24gaGFzIHRvIGJlIHByZXByb2Nlc3NlZCB2aWFcbiAqIGBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnNgLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGV4cHJlc3Npb25XaXRob3V0QnVpbHRpbnMsIGJpbmRpbmdJZCkge1xuICAgIGlmICghbG9jYWxSZXNvbHZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyID0gbmV3IERlZmF1bHRMb2NhbFJlc29sdmVyKCk7XG4gICAgfVxuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCwgLyogc3VwcG9ydHNJbnRlcnBvbGF0aW9uICovIGZhbHNlKTtcbiAgICBjb25zdCBvdXRwdXRFeHByID0gZXhwcmVzc2lvbldpdGhvdXRCdWlsdGlucy52aXNpdCh2aXNpdG9yLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICBjb25zdCBzdG10cyA9IGdldFN0YXRlbWVudHNGcm9tVmlzaXRvcih2aXNpdG9yLCBiaW5kaW5nSWQpO1xuICAgIGlmICh2aXNpdG9yLnVzZXNJbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIG91dHB1dEV4cHIpO1xufVxuLyoqXG4gKiBHaXZlbiBzb21lIGV4cHJlc3Npb24sIHN1Y2ggYXMgYSBiaW5kaW5nIG9yIGludGVycG9sYXRpb24gZXhwcmVzc2lvbiwgYW5kIGEgY29udGV4dCBleHByZXNzaW9uIHRvXG4gKiBsb29rIHZhbHVlcyB1cCBvbiwgdmlzaXQgZWFjaCBmYWNldCBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiByZXNvbHZpbmcgdmFsdWVzIGZyb20gdGhlIGNvbnRleHRcbiAqIGV4cHJlc3Npb24gc3VjaCB0aGF0IGEgbGlzdCBvZiBhcmd1bWVudHMgY2FuIGJlIGRlcml2ZWQgZnJvbSB0aGUgZm91bmQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgYXNcbiAqIGFyZ3VtZW50cyB0byBhbiBleHRlcm5hbCB1cGRhdGUgaW5zdHJ1Y3Rpb24uXG4gKlxuICogQHBhcmFtIGxvY2FsUmVzb2x2ZXIgVGhlIHJlc29sdmVyIHRvIHVzZSB0byBsb29rIHVwIGV4cHJlc3Npb25zIGJ5IG5hbWUgYXBwcm9wcmlhdGVseVxuICogQHBhcmFtIGNvbnRleHRWYXJpYWJsZUV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBjb250ZXh0IHZhcmlhYmxlIHVzZWQgdG8gY3JlYXRlXG4gKiB0aGUgZmluYWwgYXJndW1lbnQgZXhwcmVzc2lvbnNcbiAqIEBwYXJhbSBleHByZXNzaW9uV2l0aEFyZ3VtZW50c1RvRXh0cmFjdCBUaGUgZXhwcmVzc2lvbiB0byB2aXNpdCB0byBmaWd1cmUgb3V0IHdoYXQgdmFsdWVzIG5lZWQgdG9cbiAqIGJlIHJlc29sdmVkIGFuZCB3aGF0IGFyZ3VtZW50cyBsaXN0IHRvIGJ1aWxkLlxuICogQHBhcmFtIGJpbmRpbmdJZCBBIG5hbWUgcHJlZml4IHVzZWQgdG8gY3JlYXRlIHRlbXBvcmFyeSB2YXJpYWJsZSBuYW1lcyBpZiB0aGV5J3JlIG5lZWRlZCBmb3IgdGhlXG4gKiBhcmd1bWVudHMgZ2VuZXJhdGVkXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBleHByZXNzaW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIGluc3RydWN0aW9uIGV4cHJlc3Npb25zIGxpa2VcbiAqIGBvLmltcG9ydEV4cHIoUjMucHJvcGVydHlJbnRlcnBvbGF0ZSkuY2FsbEZuKHJlc3VsdClgXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRVcGRhdGVBcmd1bWVudHMobG9jYWxSZXNvbHZlciwgY29udGV4dFZhcmlhYmxlRXhwcmVzc2lvbiwgZXhwcmVzc2lvbldpdGhBcmd1bWVudHNUb0V4dHJhY3QsIGJpbmRpbmdJZCkge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGxvY2FsUmVzb2x2ZXIsIGNvbnRleHRWYXJpYWJsZUV4cHJlc3Npb24sIGJpbmRpbmdJZCwgLyogc3VwcG9ydHNJbnRlcnBvbGF0aW9uICovIHRydWUpO1xuICAgIGNvbnN0IG91dHB1dEV4cHIgPSB2aXNpdG9yLnZpc2l0SW50ZXJwb2xhdGlvbihleHByZXNzaW9uV2l0aEFyZ3VtZW50c1RvRXh0cmFjdCwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgaWYgKHZpc2l0b3IudXNlc0ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgbG9jYWxSZXNvbHZlci5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlKCk7XG4gICAgfVxuICAgIGNvbnN0IHN0bXRzID0gZ2V0U3RhdGVtZW50c0Zyb21WaXNpdG9yKHZpc2l0b3IsIGJpbmRpbmdJZCk7XG4gICAgY29uc3QgYXJncyA9IG91dHB1dEV4cHIuYXJncztcbiAgICByZXR1cm4geyBzdG10cywgYXJncyB9O1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVtZW50c0Zyb21WaXNpdG9yKHZpc2l0b3IsIGJpbmRpbmdJZCkge1xuICAgIGNvbnN0IHN0bXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdG9yLnRlbXBvcmFyeUNvdW50OyBpKyspIHtcbiAgICAgICAgc3RtdHMucHVzaCh0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXRzO1xufVxuZnVuY3Rpb24gY29udmVydEJ1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX0J1aWx0aW5Bc3RDb252ZXJ0ZXIoY29udmVydGVyRmFjdG9yeSk7XG4gICAgcmV0dXJuIGFzdC52aXNpdCh2aXNpdG9yKTtcbn1cbmZ1bmN0aW9uIHRlbXBvcmFyeU5hbWUoYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICByZXR1cm4gYHRtcF8ke2JpbmRpbmdJZH1fJHt0ZW1wb3JhcnlOdW1iZXJ9YDtcbn1cbmZ1bmN0aW9uIHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJZCwgdGVtcG9yYXJ5TnVtYmVyKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJlVmFyU3RtdCh0ZW1wb3JhcnlOYW1lKGJpbmRpbmdJZCwgdGVtcG9yYXJ5TnVtYmVyKSk7XG59XG5mdW5jdGlvbiBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModGVtcG9yYXJ5Q291bnQsIGJpbmRpbmdJZCwgc3RhdGVtZW50cykge1xuICAgIGZvciAobGV0IGkgPSB0ZW1wb3JhcnlDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0YXRlbWVudHMudW5zaGlmdCh0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIGkpKTtcbiAgICB9XG59XG52YXIgX01vZGU7XG4oZnVuY3Rpb24gKF9Nb2RlKSB7XG4gICAgX01vZGVbX01vZGVbXCJTdGF0ZW1lbnRcIl0gPSAwXSA9IFwiU3RhdGVtZW50XCI7XG4gICAgX01vZGVbX01vZGVbXCJFeHByZXNzaW9uXCJdID0gMV0gPSBcIkV4cHJlc3Npb25cIjtcbn0pKF9Nb2RlIHx8IChfTW9kZSA9IHt9KSk7XG5mdW5jdGlvbiBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCkge1xuICAgIGlmIChtb2RlICE9PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHN0YXRlbWVudCwgYnV0IHNhdyAke2FzdH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpIHtcbiAgICBpZiAobW9kZSAhPT0gX01vZGUuRXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIGV4cHJlc3Npb24sIGJ1dCBzYXcgJHthc3R9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgZXhwcikge1xuICAgIGlmIChtb2RlID09PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGV4cHIudG9TdG10KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG59XG5jbGFzcyBfQnVpbHRpbkFzdENvbnZlcnRlciBleHRlbmRzIEFzdFRyYW5zZm9ybWVyIHtcbiAgICBjb25zdHJ1Y3RvcihfY29udmVydGVyRmFjdG9yeSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9jb252ZXJ0ZXJGYWN0b3J5ID0gX2NvbnZlcnRlckZhY3Rvcnk7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFthc3QuZXhwLCAuLi5hc3QuYXJnc10ubWFwKGFzdCA9PiBhc3QudmlzaXQodGhpcywgY29udGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhcmdzLCB0aGlzLl9jb252ZXJ0ZXJGYWN0b3J5LmNyZWF0ZVBpcGVDb252ZXJ0ZXIoYXN0Lm5hbWUsIGFyZ3MubGVuZ3RoKSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBhcmdzID0gYXN0LmV4cHJlc3Npb25zLm1hcChhc3QgPT4gYXN0LnZpc2l0KHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXIoYXN0LmV4cHJlc3Npb25zLmxlbmd0aCkpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxNYXAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBhc3QudmFsdWVzLm1hcChhc3QgPT4gYXN0LnZpc2l0KHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyKGFzdC5rZXlzKSk7XG4gICAgfVxufVxuY2xhc3MgX0FzdFRvSXJWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihfbG9jYWxSZXNvbHZlciwgX2ltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCwgc3VwcG9ydHNJbnRlcnBvbGF0aW9uLCBiYXNlU291cmNlU3BhbiwgaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsUmVzb2x2ZXIgPSBfbG9jYWxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlciA9IF9pbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICB0aGlzLmJpbmRpbmdJZCA9IGJpbmRpbmdJZDtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0ludGVycG9sYXRpb24gPSBzdXBwb3J0c0ludGVycG9sYXRpb247XG4gICAgICAgIHRoaXMuYmFzZVNvdXJjZVNwYW4gPSBiYXNlU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMgPSBpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXM7XG4gICAgICAgIHRoaXMuX25vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Jlc3VsdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRlbXBvcmFyeSA9IDA7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnVzZXNJbXBsaWNpdFJlY2VpdmVyID0gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0VW5hcnkoYXN0LCBtb2RlKSB7XG4gICAgICAgIGxldCBvcDtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIG9wID0gZXhwb3J0cy5VbmFyeU9wZXJhdG9yLlBsdXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICBvcCA9IGV4cG9ydHMuVW5hcnlPcGVyYXRvci5NaW51cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRvciAke2FzdC5vcGVyYXRvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbmV3IFVuYXJ5T3BlcmF0b3JFeHByKG9wLCB0aGlzLl92aXNpdChhc3QuZXhwciwgX01vZGUuRXhwcmVzc2lvbiksIHVuZGVmaW5lZCwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpKTtcbiAgICB9XG4gICAgdmlzaXRCaW5hcnkoYXN0LCBtb2RlKSB7XG4gICAgICAgIGxldCBvcDtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICBvcCA9IGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuUGx1cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIG9wID0gZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5NaW51cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIG9wID0gZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5NdWx0aXBseTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgIG9wID0gZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5EaXZpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBvcCA9IGV4cG9ydHMuQmluYXJ5T3BlcmF0b3IuTW9kdWxvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgICAgICAgIG9wID0gZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5BbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgICAgICAgb3AgPSBleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk9yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIG9wID0gZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5FcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgICAgICAgb3AgPSBleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk5vdEVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBleHBvcnRzLkJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBleHBvcnRzLkJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIG9wID0gZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5Mb3dlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAgIG9wID0gZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5CaWdnZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBleHBvcnRzLkJpbmFyeU9wZXJhdG9yLkxvd2VyRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgIG9wID0gZXhwb3J0cy5CaW5hcnlPcGVyYXRvci5CaWdnZXJFcXVhbHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc/Pyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydE51bGxpc2hDb2FsZXNjZShhc3QsIG1vZGUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG9wZXJhdGlvbiAke2FzdC5vcGVyYXRpb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIob3AsIHRoaXMuX3Zpc2l0KGFzdC5sZWZ0LCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy5fdmlzaXQoYXN0LnJpZ2h0LCBfTW9kZS5FeHByZXNzaW9uKSwgdW5kZWZpbmVkLCB0aGlzLmNvbnZlcnRTb3VyY2VTcGFuKGFzdC5zcGFuKSkpO1xuICAgIH1cbiAgICB2aXNpdENoYWluKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgbW9kZSk7XG4gICAgfVxuICAgIHZpc2l0Q29uZGl0aW9uYWwoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdmlzaXQoYXN0LmNvbmRpdGlvbiwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCB2YWx1ZS5jb25kaXRpb25hbCh0aGlzLl92aXNpdChhc3QudHJ1ZUV4cCwgX01vZGUuRXhwcmVzc2lvbiksIHRoaXMuX3Zpc2l0KGFzdC5mYWxzZUV4cCwgX01vZGUuRXhwcmVzc2lvbiksIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKSk7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIHN0YXRlOiBQaXBlcyBzaG91bGQgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIGZ1bmN0aW9ucy4gUGlwZTogJHthc3QubmFtZX1gKTtcbiAgICB9XG4gICAgdmlzaXRJbXBsaWNpdFJlY2VpdmVyKGFzdCwgbW9kZSkge1xuICAgICAgICBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpO1xuICAgICAgICB0aGlzLnVzZXNJbXBsaWNpdFJlY2VpdmVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgfVxuICAgIHZpc2l0VGhpc1JlY2VpdmVyKGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEltcGxpY2l0UmVjZWl2ZXIoYXN0LCBtb2RlKTtcbiAgICB9XG4gICAgdmlzaXRJbnRlcnBvbGF0aW9uKGFzdCwgbW9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgaW50ZXJwb2xhdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0LnN0cmluZ3MubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbChhc3Quc3RyaW5nc1tpXSkpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMuX3Zpc2l0KGFzdC5leHByZXNzaW9uc1tpXSwgX01vZGUuRXhwcmVzc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2FzdC5zdHJpbmdzLmxlbmd0aCAtIDFdKSk7XG4gICAgICAgIC8vIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBpbnRlcnBvbGF0aW9uIG9mIDEgdmFsdWUgd2l0aCBhbiBlbXB0eSBwcmVmaXggYW5kIHN1ZmZpeCwgcmVkdWNlIHRoZVxuICAgICAgICAvLyBhcmdzIHJldHVybmVkIHRvIGp1c3QgdGhlIHZhbHVlLCBiZWNhdXNlIHdlJ3JlIGdvaW5nIHRvIHBhc3MgaXQgdG8gYSBzcGVjaWFsIGluc3RydWN0aW9uLlxuICAgICAgICBjb25zdCBzdHJpbmdzID0gYXN0LnN0cmluZ3M7XG4gICAgICAgIGlmIChzdHJpbmdzLmxlbmd0aCA9PT0gMiAmJiBzdHJpbmdzWzBdID09PSAnJyAmJiBzdHJpbmdzWzFdID09PSAnJykge1xuICAgICAgICAgICAgLy8gU2luZ2xlIGFyZ3VtZW50IGludGVycG9sYXRlIGluc3RydWN0aW9ucy5cbiAgICAgICAgICAgIGFyZ3MgPSBbYXJnc1sxXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmV4cHJlc3Npb25zLmxlbmd0aCA+PSA5KSB7XG4gICAgICAgICAgICAvLyA5IG9yIG1vcmUgYXJndW1lbnRzIG11c3QgYmUgcGFzc2VkIHRvIHRoZSBgaW50ZXJwb2xhdGVWYC1zdHlsZSBpbnN0cnVjdGlvbnMsIHdoaWNoIGFjY2VwdFxuICAgICAgICAgICAgLy8gYW4gYXJyYXkgb2YgYXJndW1lbnRzXG4gICAgICAgICAgICBhcmdzID0gW2xpdGVyYWxBcnIoYXJncyldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oYXJncyk7XG4gICAgfVxuICAgIHZpc2l0S2V5ZWRSZWFkKGFzdCwgbW9kZSkge1xuICAgICAgICBjb25zdCBsZWZ0TW9zdFNhZmUgPSB0aGlzLmxlZnRNb3N0U2FmZU5vZGUoYXN0KTtcbiAgICAgICAgaWYgKGxlZnRNb3N0U2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydFNhZmVBY2Nlc3MoYXN0LCBsZWZ0TW9zdFNhZmUsIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHRoaXMuX3Zpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbikua2V5KHRoaXMuX3Zpc2l0KGFzdC5rZXksIF9Nb2RlLkV4cHJlc3Npb24pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRLZXllZFdyaXRlKGFzdCwgbW9kZSkge1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLl92aXNpdChhc3QucmVjZWl2ZXIsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl92aXNpdChhc3Qua2V5LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl92aXNpdChhc3QudmFsdWUsIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICBpZiAob2JqID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbFJlc29sdmVyLm1heWJlUmVzdG9yZVZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgb2JqLmtleShrZXkpLnNldCh2YWx1ZSkpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxBcnJheShhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIFN0YXRlOiBsaXRlcmFsIGFycmF5cyBzaG91bGQgaGF2ZSBiZWVuIGNvbnZlcnRlZCBpbnRvIGZ1bmN0aW9uc2ApO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxNYXAoYXN0LCBtb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBTdGF0ZTogbGl0ZXJhbCBtYXBzIHNob3VsZCBoYXZlIGJlZW4gY29udmVydGVkIGludG8gZnVuY3Rpb25zYCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbFByaW1pdGl2ZShhc3QsIG1vZGUpIHtcbiAgICAgICAgLy8gRm9yIGxpdGVyYWwgdmFsdWVzIG9mIG51bGwsIHVuZGVmaW5lZCwgdHJ1ZSwgb3IgZmFsc2UgYWxsb3cgdHlwZSBpbnRlcmZlcmVuY2VcbiAgICAgICAgLy8gdG8gaW5mZXIgdGhlIHR5cGUuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBhc3QudmFsdWUgPT09IG51bGwgfHwgYXN0LnZhbHVlID09PSB1bmRlZmluZWQgfHwgYXN0LnZhbHVlID09PSB0cnVlIHx8IGFzdC52YWx1ZSA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICBJTkZFUlJFRF9UWVBFIDpcbiAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGxpdGVyYWwoYXN0LnZhbHVlLCB0eXBlLCB0aGlzLmNvbnZlcnRTb3VyY2VTcGFuKGFzdC5zcGFuKSkpO1xuICAgIH1cbiAgICBfZ2V0TG9jYWwobmFtZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuX2xvY2FsUmVzb2x2ZXIuZ2xvYmFscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhcyhuYW1lKSkgJiYgcmVjZWl2ZXIgaW5zdGFuY2VvZiBUaGlzUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFJlc29sdmVyLmdldExvY2FsKG5hbWUpO1xuICAgIH1cbiAgICB2aXNpdFByZWZpeE5vdChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5vdCh0aGlzLl92aXNpdChhc3QuZXhwcmVzc2lvbiwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICB9XG4gICAgdmlzaXROb25OdWxsQXNzZXJ0KGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy5fdmlzaXQoYXN0LmV4cHJlc3Npb24sIF9Nb2RlLkV4cHJlc3Npb24pKTtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVJlYWQoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZVc2VzSW1wbGljaXRSZWNlaXZlciA9IHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICBjb25zdCByZWNlaXZlciA9IHRoaXMuX3Zpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSwgYXN0LnJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIFwidXNlc0ltcGxpY2l0UmVjZWl2ZXJcIiBzdGF0ZSBzaW5jZSB0aGUgaW1wbGljaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZXIgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHJlc29sdmVkIGxvY2FsIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW1wbGljaXRSZWNlaXZlckFjY2Vzcyhhc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIucHJvcChhc3QubmFtZSwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVdyaXRlKGFzdCwgbW9kZSkge1xuICAgICAgICBjb25zdCByZWNlaXZlciA9IHRoaXMuX3Zpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IHByZXZVc2VzSW1wbGljaXRSZWNlaXZlciA9IHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgIGxldCB2YXJFeHByID0gbnVsbDtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbEV4cHIgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSwgYXN0LnJlY2VpdmVyKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEV4cHIpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxFeHByIGluc3RhbmNlb2YgUmVhZFByb3BFeHByKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsb2NhbCB2YXJpYWJsZSBpcyBhIHByb3BlcnR5IHJlYWQgZXhwcmVzc2lvbiwgaXQncyBhIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhICdjb250ZXh0LnByb3BlcnR5JyB2YWx1ZSBhbmQgd2lsbCBiZSB1c2VkIGFzIHRoZSB0YXJnZXQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyaXRlIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHZhckV4cHIgPSBsb2NhbEV4cHI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIFwidXNlc0ltcGxpY2l0UmVjZWl2ZXJcIiBzdGF0ZSBzaW5jZSB0aGUgaW1wbGljaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZXIgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHJlc29sdmVkIGxvY2FsIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW1wbGljaXRSZWNlaXZlckFjY2Vzcyhhc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQncyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoYXN0LnZhbHVlIGluc3RhbmNlb2YgUHJvcGVydHlSZWFkKSA/IGFzdC52YWx1ZS5uYW1lIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhc3NpZ24gdmFsdWUgXCIke3ZhbHVlfVwiIHRvIHRlbXBsYXRlIHZhcmlhYmxlIFwiJHtyZWNlaXZlcn1cIi4gVGVtcGxhdGUgdmFyaWFibGVzIGFyZSByZWFkLW9ubHkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIGxvY2FsIGV4cHJlc3Npb24gY291bGQgYmUgcHJvZHVjZWQsIHVzZSB0aGUgb3JpZ2luYWwgcmVjZWl2ZXInc1xuICAgICAgICAvLyBwcm9wZXJ0eSBhcyB0aGUgdGFyZ2V0LlxuICAgICAgICBpZiAodmFyRXhwciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyRXhwciA9IHJlY2VpdmVyLnByb3AoYXN0Lm5hbWUsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdmFyRXhwci5zZXQodGhpcy5fdmlzaXQoYXN0LnZhbHVlLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH1cbiAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH1cbiAgICB2aXNpdFNhZmVLZXllZFJlYWQoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH1cbiAgICB2aXNpdEFsbChhc3RzLCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBhc3RzLm1hcChhc3QgPT4gdGhpcy5fdmlzaXQoYXN0LCBtb2RlKSk7XG4gICAgfVxuICAgIHZpc2l0Q2FsbChhc3QsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRBcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBCdWlsdGluRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgYXN0LmNvbnZlcnRlcihjb252ZXJ0ZWRBcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXI7XG4gICAgICAgIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3BlcnR5UmVhZCAmJlxuICAgICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZXIgaW5zdGFuY2VvZiBJbXBsaWNpdFJlY2VpdmVyICYmXG4gICAgICAgICAgICAhKHJlY2VpdmVyLnJlY2VpdmVyIGluc3RhbmNlb2YgVGhpc1JlY2VpdmVyKSAmJiByZWNlaXZlci5uYW1lID09PSAnJGFueScpIHtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0ZWRBcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjYWxsIHRvICRhbnksIGV4cGVjdGVkIDEgYXJndW1lbnQgYnV0IHJlY2VpdmVkICR7Y29udmVydGVkQXJncy5sZW5ndGggfHwgJ25vbmUnfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGNvbnZlcnRlZEFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzLl92aXNpdChyZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbilcbiAgICAgICAgICAgIC5jYWxsRm4oY29udmVydGVkQXJncywgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY2FsbCk7XG4gICAgfVxuICAgIHZpc2l0U2FmZUNhbGwoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH1cbiAgICBfdmlzaXQoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3Jlc3VsdE1hcC5nZXQoYXN0KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHRoaXMsIG1vZGUpO1xuICAgIH1cbiAgICBjb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSkge1xuICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBjb250YWlucyBhIHNhZmUgYWNjZXNzIG5vZGUgb24gdGhlIGxlZnQgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvXG4gICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBwcm9jZWVkcyBmcm9tIGxlZnQgdG8gcmlnaHQsIHRoZSBsZWZ0IG1vc3QgcGFydCBvZiB0aGUgZXhwcmVzc2lvbiBtdXN0IGJlIGd1YXJkZWRcbiAgICAgICAgLy8gZmlyc3QgYnV0LCBiZWNhdXNlIG1lbWJlciBhY2Nlc3MgaXMgbGVmdCBhc3NvY2lhdGl2ZSwgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGV4cHJlc3Npb24gaXMgYXRcbiAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIGxlZnQgcGFydCBvZiB0aGVcbiAgICAgICAgLy8gZXhwcmVzc2lvbiB1cCB0byB0ZXN0IGl0IGZvciBibGFuayBiZWZvcmUgZ2VuZXJhdGluZyB0aGUgdW5ndWFyZGVkIHZlcnNpb24uXG4gICAgICAgIC8vIENvbnNpZGVyLCBmb3IgZXhhbXBsZSB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb246IGE/LmIuYz8uZC5lXG4gICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiB0aGUgYXN0OlxuICAgICAgICAvLyAgICAgICAgIC5cbiAgICAgICAgLy8gICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICAgPy4gICBlXG4gICAgICAgIC8vICAgICAgLyAgXFxcbiAgICAgICAgLy8gICAgIC4gICAgZFxuICAgICAgICAvLyAgICAvIFxcXG4gICAgICAgIC8vICAgPy4gIGNcbiAgICAgICAgLy8gIC8gIFxcXG4gICAgICAgIC8vIGEgICAgYlxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHRyZWUgc2hvdWxkIGJlIGdlbmVyYXRlZDpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgIC8tLS0tID8gLS0tLVxcXG4gICAgICAgIC8vICAgICAgIC8gICAgICB8ICAgICAgXFxcbiAgICAgICAgLy8gICAgIGEgICAvLS0tID8gLS0tXFwgIG51bGxcbiAgICAgICAgLy8gICAgICAgIC8gICAgIHwgICAgIFxcXG4gICAgICAgIC8vICAgICAgIC4gICAgICAuICAgICBudWxsXG4gICAgICAgIC8vICAgICAgLyBcXCAgICAvIFxcXG4gICAgICAgIC8vICAgICAuICBjICAgLiAgIGVcbiAgICAgICAgLy8gICAgLyBcXCAgICAvIFxcXG4gICAgICAgIC8vICAgYSAgIGIgIC4gICBkXG4gICAgICAgIC8vICAgICAgICAgLyBcXFxuICAgICAgICAvLyAgICAgICAgLiAgIGNcbiAgICAgICAgLy8gICAgICAgLyBcXFxuICAgICAgICAvLyAgICAgIGEgICBiXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGljZSB0aGF0IHRoZSBmaXJzdCBndWFyZCBjb25kaXRpb24gaXMgdGhlIGxlZnQgaGFuZCBvZiB0aGUgbGVmdCBtb3N0IHNhZmUgYWNjZXNzIG5vZGVcbiAgICAgICAgLy8gd2hpY2ggY29tZXMgaW4gYXMgbGVmdE1vc3RTYWZlIHRvIHRoaXMgcm91dGluZS5cbiAgICAgICAgbGV0IGd1YXJkZWRFeHByZXNzaW9uID0gdGhpcy5fdmlzaXQobGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgbGV0IHRlbXBvcmFyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNUZW1wb3JhcnlJblNhZmVBY2Nlc3MobGVmdE1vc3RTYWZlLnJlY2VpdmVyKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGV4cHJlc3Npb24gaGFzIG1ldGhvZCBjYWxscyBvciBwaXBlcyB0aGVuIHdlIG5lZWQgdG8gc2F2ZSB0aGUgcmVzdWx0IGludG8gYVxuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIGF2b2lkIGNhbGxpbmcgc3RhdGVmdWwgb3IgaW1wdXJlIGNvZGUgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgICAgICB0ZW1wb3JhcnkgPSB0aGlzLmFsbG9jYXRlVGVtcG9yYXJ5KCk7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgcmVzdWx0IGluIHRoZSB0ZW1wb3JhcnkgdmFyaWFibGVcbiAgICAgICAgICAgIGd1YXJkZWRFeHByZXNzaW9uID0gdGVtcG9yYXJ5LnNldChndWFyZGVkRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAvLyBFbnN1cmUgYWxsIGZ1cnRoZXIgcmVmZXJlbmNlcyB0byB0aGUgZ3VhcmRlZCBleHByZXNzaW9uIHJlZmVyIHRvIHRoZSB0ZW1wb3JhcnkgaW5zdGVhZC5cbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdE1hcC5zZXQobGVmdE1vc3RTYWZlLnJlY2VpdmVyLCB0ZW1wb3JhcnkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGd1YXJkZWRFeHByZXNzaW9uLmlzQmxhbmsoKTtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgYXN0IHRvIGFuIHVuZ3VhcmRlZCBhY2Nlc3MgdG8gdGhlIHJlY2VpdmVyJ3MgbWVtYmVyLiBUaGUgbWFwIHdpbGwgc3Vic3RpdHV0ZVxuICAgICAgICAvLyBsZWZ0TW9zdE5vZGUgd2l0aCBpdHMgdW5ndWFyZGVkIHZlcnNpb24gaW4gdGhlIGNhbGwgdG8gYHRoaXMudmlzaXQoKWAuXG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUgaW5zdGFuY2VvZiBTYWZlQ2FsbCkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgQ2FsbChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnNvdXJjZVNwYW4sIGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgbGVmdE1vc3RTYWZlLmFyZ3MsIGxlZnRNb3N0U2FmZS5hcmd1bWVudFNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZWZ0TW9zdFNhZmUgaW5zdGFuY2VvZiBTYWZlS2V5ZWRSZWFkKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlTWFwLnNldChsZWZ0TW9zdFNhZmUsIG5ldyBLZXllZFJlYWQobGVmdE1vc3RTYWZlLnNwYW4sIGxlZnRNb3N0U2FmZS5zb3VyY2VTcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5rZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVNYXAuc2V0KGxlZnRNb3N0U2FmZSwgbmV3IFByb3BlcnR5UmVhZChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnNvdXJjZVNwYW4sIGxlZnRNb3N0U2FmZS5uYW1lU3BhbiwgbGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBsZWZ0TW9zdFNhZmUubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdGhlIG5vZGUgbm93IHdpdGhvdXQgdGhlIGd1YXJkZWQgbWVtYmVyIGFjY2Vzcy5cbiAgICAgICAgY29uc3QgYWNjZXNzID0gdGhpcy5fdmlzaXQoYXN0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBtYXBwaW5nLiBUaGlzIGlzIG5vdCBzdHJpY3RseSByZXF1aXJlZCBhcyB0aGUgY29udmVydGVyIG9ubHkgdHJhdmVyc2VzIGVhY2ggbm9kZVxuICAgICAgICAvLyBvbmNlIGJ1dCBpcyBzYWZlciBpZiB0aGUgY29udmVyc2lvbiBpcyBjaGFuZ2VkIHRvIHRyYXZlcnNlIHRoZSBub2RlcyBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgdGhpcy5fbm9kZU1hcC5kZWxldGUobGVmdE1vc3RTYWZlKTtcbiAgICAgICAgLy8gSWYgd2UgYWxsb2NhdGVkIGEgdGVtcG9yYXJ5LCByZWxlYXNlIGl0LlxuICAgICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9kdWNlIHRoZSBjb25kaXRpb25hbFxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY29uZGl0aW9uLmNvbmRpdGlvbmFsKE5VTExfRVhQUiwgYWNjZXNzKSk7XG4gICAgfVxuICAgIGNvbnZlcnROdWxsaXNoQ29hbGVzY2UoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLl92aXNpdChhc3QubGVmdCwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5fdmlzaXQoYXN0LnJpZ2h0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5ID0gdGhpcy5hbGxvY2F0ZVRlbXBvcmFyeSgpO1xuICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uLiBJdCBpcyBpZGVudGljYWwgdG8gaG93IFRTXG4gICAgICAgIC8vIHRyYW5zcGlsZXMgYmluYXJ5IGV4cHJlc3Npb25zIHdpdGggYSBudWxsaXNoIGNvYWxlc2Npbmcgb3BlcmF0b3IuXG4gICAgICAgIC8vIGxldCB0ZW1wO1xuICAgICAgICAvLyAodGVtcCA9IGEpICE9PSBudWxsICYmIHRlbXAgIT09IHVuZGVmaW5lZCA/IHRlbXAgOiBiO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGVtcG9yYXJ5LnNldChsZWZ0KVxuICAgICAgICAgICAgLm5vdElkZW50aWNhbChOVUxMX0VYUFIpXG4gICAgICAgICAgICAuYW5kKHRlbXBvcmFyeS5ub3RJZGVudGljYWwobGl0ZXJhbCh1bmRlZmluZWQpKSlcbiAgICAgICAgICAgIC5jb25kaXRpb25hbCh0ZW1wb3JhcnksIHJpZ2h0KSk7XG4gICAgfVxuICAgIC8vIEdpdmVuIGFuIGV4cHJlc3Npb24gb2YgdGhlIGZvcm0gYT8uYi5jPy5kLmUgdGhlbiB0aGUgbGVmdCBtb3N0IHNhZmUgbm9kZSBpc1xuICAgIC8vIHRoZSAoYT8uYikuIFRoZSAuIGFuZCA/LiBhcmUgbGVmdCBhc3NvY2lhdGl2ZSB0aHVzIGNhbiBiZSByZXdyaXR0ZW4gYXM6XG4gICAgLy8gKCgoKGE/LmMpLmIpLmMpPy5kKS5lLiBUaGlzIHJldHVybnMgdGhlIG1vc3QgZGVlcGx5IG5lc3RlZCBzYWZlIHJlYWQgb3JcbiAgICAvLyBzYWZlIG1ldGhvZCBjYWxsIGFzIHRoaXMgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW5pdGlhbGx5IHRvOlxuICAgIC8vICAgYSA9PSBudWxsID8gbnVsbCA6IGEuYy5iLmM/LmQuZVxuICAgIC8vIHRoZW4gdG86XG4gICAgLy8gICBhID09IG51bGwgPyBudWxsIDogYS5iLmMgPT0gbnVsbCA/IG51bGwgOiBhLmIuYy5kLmVcbiAgICBsZWZ0TW9zdFNhZmVOb2RlKGFzdCkge1xuICAgICAgICBjb25zdCB2aXNpdCA9ICh2aXNpdG9yLCBhc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgIHZpc2l0VW5hcnkoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRCaW5hcnkoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRDaGFpbihhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdENvbmRpdGlvbmFsKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Q2FsbChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFNhZmVDYWxsKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXIoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRUaGlzUmVjZWl2ZXIoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxBcnJheShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxNYXAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0UGlwZShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdE5vbk51bGxBc3NlcnQoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVJlYWQoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKSB8fCBhc3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRTYWZlS2V5ZWRSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdHJ1ZSBvZiB0aGUgQVNUIGluY2x1ZGVzIGEgbWV0aG9kIG9yIGEgcGlwZSBpbmRpY2F0aW5nIHRoYXQsIGlmIHRoZVxuICAgIC8vIGV4cHJlc3Npb24gaXMgdXNlZCBhcyB0aGUgdGFyZ2V0IG9mIGEgc2FmZSBwcm9wZXJ0eSBvciBtZXRob2QgYWNjZXNzIHRoZW5cbiAgICAvLyB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgc3RvcmVkIGludG8gYSB0ZW1wb3JhcnkgdmFyaWFibGUuXG4gICAgbmVlZHNUZW1wb3JhcnlJblNhZmVBY2Nlc3MoYXN0KSB7XG4gICAgICAgIGNvbnN0IHZpc2l0ID0gKHZpc2l0b3IsIGFzdCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFzdCAmJiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2aXNpdFNvbWUgPSAodmlzaXRvciwgYXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXN0LnNvbWUoYXN0ID0+IHZpc2l0KHZpc2l0b3IsIGFzdCkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgIHZpc2l0VW5hcnkoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5leHByKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEJpbmFyeShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmxlZnQpIHx8IHZpc2l0KHRoaXMsIGFzdC5yaWdodCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRDaGFpbihhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRDb25kaXRpb25hbChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmNvbmRpdGlvbikgfHwgdmlzaXQodGhpcywgYXN0LnRydWVFeHApIHx8IHZpc2l0KHRoaXMsIGFzdC5mYWxzZUV4cCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRDYWxsKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0U2FmZUNhbGwoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRJbXBsaWNpdFJlY2VpdmVyKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFRoaXNSZWNlaXZlcihhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdFNvbWUodGhpcywgYXN0LmV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEtleWVkUmVhZChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRLZXllZFdyaXRlKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxBcnJheShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxNYXAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFBpcGUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRQcmVmaXhOb3QoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdE5vbk51bGxBc3NlcnQoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRQcm9wZXJ0eVdyaXRlKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0U2FmZUtleWVkUmVhZChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhbGxvY2F0ZVRlbXBvcmFyeSgpIHtcbiAgICAgICAgY29uc3QgdGVtcE51bWJlciA9IHRoaXMuX2N1cnJlbnRUZW1wb3JhcnkrKztcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlDb3VudCA9IE1hdGgubWF4KHRoaXMuX2N1cnJlbnRUZW1wb3JhcnksIHRoaXMudGVtcG9yYXJ5Q291bnQpO1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRWYXJFeHByKHRlbXBvcmFyeU5hbWUodGhpcy5iaW5kaW5nSWQsIHRlbXBOdW1iZXIpKTtcbiAgICB9XG4gICAgcmVsZWFzZVRlbXBvcmFyeSh0ZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFRlbXBvcmFyeS0tO1xuICAgICAgICBpZiAodGVtcG9yYXJ5Lm5hbWUgIT0gdGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGhpcy5fY3VycmVudFRlbXBvcmFyeSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVtcG9yYXJ5ICR7dGVtcG9yYXJ5Lm5hbWV9IHJlbGVhc2VkIG91dCBvZiBvcmRlcmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYWJzb2x1dGUgYFBhcnNlU291cmNlU3BhbmAgZnJvbSB0aGUgcmVsYXRpdmUgYFBhcnNlU3BhbmAuXG4gICAgICpcbiAgICAgKiBgUGFyc2VTcGFuYCBvYmplY3RzIGFyZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGV4cHJlc3Npb24uXG4gICAgICogVGhpcyBtZXRob2QgY29udmVydHMgdGhlc2UgdG8gZnVsbCBgUGFyc2VTb3VyY2VTcGFuYCBvYmplY3RzIHRoYXRcbiAgICAgKiBzaG93IHdoZXJlIHRoZSBzcGFuIGlzIHdpdGhpbiB0aGUgb3ZlcmFsbCBzb3VyY2UgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcGFuIHRoZSByZWxhdGl2ZSBzcGFuIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMgYSBgUGFyc2VTb3VyY2VTcGFuYCBmb3IgdGhlIGdpdmVuIHNwYW4gb3IgbnVsbCBpZiBub1xuICAgICAqIGBiYXNlU291cmNlU3BhbmAgd2FzIHByb3ZpZGVkIHRvIHRoaXMgY2xhc3MuXG4gICAgICovXG4gICAgY29udmVydFNvdXJjZVNwYW4oc3Bhbikge1xuICAgICAgICBpZiAodGhpcy5iYXNlU291cmNlU3Bhbikge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmJhc2VTb3VyY2VTcGFuLnN0YXJ0Lm1vdmVCeShzcGFuLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuYmFzZVNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KHNwYW4uZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxTdGFydCA9IHRoaXMuYmFzZVNvdXJjZVNwYW4uZnVsbFN0YXJ0Lm1vdmVCeShzcGFuLnN0YXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQsIGZ1bGxTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQWRkcyB0aGUgbmFtZSBvZiBhbiBBU1QgdG8gdGhlIGxpc3Qgb2YgaW1wbGljaXQgcmVjZWl2ZXIgYWNjZXNzZXMuICovXG4gICAgYWRkSW1wbGljaXRSZWNlaXZlckFjY2VzcyhuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmltcGxpY2l0UmVjZWl2ZXJBY2Nlc3Nlcykge1xuICAgICAgICAgICAgdGhpcy5pbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMuYWRkKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZmxhdHRlblN0YXRlbWVudHMoYXJnLCBvdXRwdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIGFyZy5mb3JFYWNoKChlbnRyeSkgPT4gZmxhdHRlblN0YXRlbWVudHMoZW50cnksIG91dHB1dCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYXJnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bnN1cHBvcnRlZCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG9wZXJhdGlvbicpO1xufVxuY2xhc3MgSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmlzQ29uc3RhbnQgPSB1bnN1cHBvcnRlZDtcbiAgICAgICAgdGhpcy5pc0VxdWl2YWxlbnQgPSB1bnN1cHBvcnRlZDtcbiAgICAgICAgdGhpcy52aXNpdEV4cHJlc3Npb24gPSB1bnN1cHBvcnRlZDtcbiAgICB9XG59XG5jbGFzcyBEZWZhdWx0TG9jYWxSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IoZ2xvYmFscykge1xuICAgICAgICB0aGlzLmdsb2JhbHMgPSBnbG9iYWxzO1xuICAgIH1cbiAgICBub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlKCkgeyB9XG4gICAgbWF5YmVSZXN0b3JlVmlldygpIHsgfVxuICAgIGdldExvY2FsKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IEV2ZW50SGFuZGxlclZhcnMuZXZlbnQubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlclZhcnMuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgQnVpbHRpbkZ1bmN0aW9uQ2FsbCBleHRlbmRzIENhbGwge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGFyZ3MsIGNvbnZlcnRlcikge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuLCBuZXcgRW1wdHlFeHByKHNwYW4sIHNvdXJjZVNwYW4pLCBhcmdzLCBudWxsKTtcbiAgICAgICAgdGhpcy5jb252ZXJ0ZXIgPSBjb252ZXJ0ZXI7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogVGhpcyBmaWxlIGlzIGEgcG9ydCBvZiBzaGFkb3dDU1MgZnJvbSB3ZWJjb21wb25lbnRzLmpzIHRvIFR5cGVTY3JpcHQuXG4gKlxuICogUGxlYXNlIG1ha2Ugc3VyZSB0byBrZWVwIHRvIGVkaXRzIGluIHN5bmMgd2l0aCB0aGUgc291cmNlIGZpbGUuXG4gKlxuICogU291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL2Jsb2IvNGVmZWNkN2UwZS9zcmMvU2hhZG93Q1NTL1NoYWRvd0NTUy5qc1xuICpcbiAqIFRoZSBvcmlnaW5hbCBmaWxlIGxldmVsIGNvbW1lbnQgaXMgcmVwcm9kdWNlZCBiZWxvd1xuICovXG4vKlxuICBUaGlzIGlzIGEgbGltaXRlZCBzaGltIGZvciBTaGFkb3dET00gY3NzIHN0eWxpbmcuXG4gIGh0dHBzOi8vZHZjcy53My5vcmcvaGcvd2ViY29tcG9uZW50cy9yYXctZmlsZS90aXAvc3BlYy9zaGFkb3cvaW5kZXguaHRtbCNzdHlsZXNcblxuICBUaGUgaW50ZW50aW9uIGhlcmUgaXMgdG8gc3VwcG9ydCBvbmx5IHRoZSBzdHlsaW5nIGZlYXR1cmVzIHdoaWNoIGNhbiBiZVxuICByZWxhdGl2ZWx5IHNpbXBseSBpbXBsZW1lbnRlZC4gVGhlIGdvYWwgaXMgdG8gYWxsb3cgdXNlcnMgdG8gYXZvaWQgdGhlXG4gIG1vc3Qgb2J2aW91cyBwaXRmYWxscyBhbmQgZG8gc28gd2l0aG91dCBjb21wcm9taXNpbmcgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbiAgRm9yIFNoYWRvd0RPTSBzdHlsaW5nIHRoYXQncyBub3QgY292ZXJlZCBoZXJlLCBhIHNldCBvZiBiZXN0IHByYWN0aWNlc1xuICBjYW4gYmUgcHJvdmlkZWQgdGhhdCBzaG91bGQgYWxsb3cgdXNlcnMgdG8gYWNjb21wbGlzaCBtb3JlIGNvbXBsZXggc3R5bGluZy5cblxuICBUaGUgZm9sbG93aW5nIGlzIGEgbGlzdCBvZiBzcGVjaWZpYyBTaGFkb3dET00gc3R5bGluZyBmZWF0dXJlcyBhbmQgYSBicmllZlxuICBkaXNjdXNzaW9uIG9mIHRoZSBhcHByb2FjaCB1c2VkIHRvIHNoaW0uXG5cbiAgU2hpbW1lZCBmZWF0dXJlczpcblxuICAqIDpob3N0LCA6aG9zdC1jb250ZXh0OiBTaGFkb3dET00gYWxsb3dzIHN0eWxpbmcgb2YgdGhlIHNoYWRvd1Jvb3QncyBob3N0XG4gIGVsZW1lbnQgdXNpbmcgdGhlIDpob3N0IHJ1bGUuIFRvIHNoaW0gdGhpcyBmZWF0dXJlLCB0aGUgOmhvc3Qgc3R5bGVzIGFyZVxuICByZWZvcm1hdHRlZCBhbmQgcHJlZml4ZWQgd2l0aCBhIGdpdmVuIHNjb3BlIG5hbWUgYW5kIHByb21vdGVkIHRvIGFcbiAgZG9jdW1lbnQgbGV2ZWwgc3R5bGVzaGVldC5cbiAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiAuZm9vLCBhIHJ1bGUgbGlrZSB0aGlzOlxuXG4gICAgOmhvc3Qge1xuICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gIGJlY29tZXM6XG5cbiAgICAuZm9vIHtcbiAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICB9XG5cbiAgKiBlbmNhcHN1bGF0aW9uOiBTdHlsZXMgZGVmaW5lZCB3aXRoaW4gU2hhZG93RE9NLCBhcHBseSBvbmx5IHRvXG4gIGRvbSBpbnNpZGUgdGhlIFNoYWRvd0RPTS4gUG9seW1lciB1c2VzIG9uZSBvZiB0d28gdGVjaG5pcXVlcyB0byBpbXBsZW1lbnRcbiAgdGhpcyBmZWF0dXJlLlxuXG4gIEJ5IGRlZmF1bHQsIHJ1bGVzIGFyZSBwcmVmaXhlZCB3aXRoIHRoZSBob3N0IGVsZW1lbnQgdGFnIG5hbWVcbiAgYXMgYSBkZXNjZW5kYW50IHNlbGVjdG9yLiBUaGlzIGVuc3VyZXMgc3R5bGluZyBkb2VzIG5vdCBsZWFrIG91dCBvZiB0aGUgJ3RvcCdcbiAgb2YgdGhlIGVsZW1lbnQncyBTaGFkb3dET00uIEZvciBleGFtcGxlLFxuXG4gIGRpdiB7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5cbiAgYmVjb21lczpcblxuICB4LWZvbyBkaXYge1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG4gIGJlY29tZXM6XG5cblxuICBBbHRlcm5hdGl2ZWx5LCBpZiBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5zdHJpY3RTdHlsaW5nIGlzIHNldCB0byB0cnVlIHRoZW5cbiAgc2VsZWN0b3JzIGFyZSBzY29wZWQgYnkgYWRkaW5nIGFuIGF0dHJpYnV0ZSBzZWxlY3RvciBzdWZmaXggdG8gZWFjaFxuICBzaW1wbGUgc2VsZWN0b3IgdGhhdCBjb250YWlucyB0aGUgaG9zdCBlbGVtZW50IHRhZyBuYW1lLiBFYWNoIGVsZW1lbnRcbiAgaW4gdGhlIGVsZW1lbnQncyBTaGFkb3dET00gdGVtcGxhdGUgaXMgYWxzbyBnaXZlbiB0aGUgc2NvcGUgYXR0cmlidXRlLlxuICBUaHVzLCB0aGVzZSBydWxlcyBtYXRjaCBvbmx5IGVsZW1lbnRzIHRoYXQgaGF2ZSB0aGUgc2NvcGUgYXR0cmlidXRlLlxuICBGb3IgZXhhbXBsZSwgZ2l2ZW4gYSBzY29wZSBuYW1lIG9mIHgtZm9vLCBhIHJ1bGUgbGlrZSB0aGlzOlxuXG4gICAgZGl2IHtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIH1cblxuICBiZWNvbWVzOlxuXG4gICAgZGl2W3gtZm9vXSB7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5cbiAgTm90ZSB0aGF0IGVsZW1lbnRzIHRoYXQgYXJlIGR5bmFtaWNhbGx5IGFkZGVkIHRvIGEgc2NvcGUgbXVzdCBoYXZlIHRoZSBzY29wZVxuICBzZWxlY3RvciBhZGRlZCB0byB0aGVtIG1hbnVhbGx5LlxuXG4gICogdXBwZXIvbG93ZXIgYm91bmQgZW5jYXBzdWxhdGlvbjogU3R5bGVzIHdoaWNoIGFyZSBkZWZpbmVkIG91dHNpZGUgYVxuICBzaGFkb3dSb290IHNob3VsZCBub3QgY3Jvc3MgdGhlIFNoYWRvd0RPTSBib3VuZGFyeSBhbmQgc2hvdWxkIG5vdCBhcHBseVxuICBpbnNpZGUgYSBzaGFkb3dSb290LlxuXG4gIFRoaXMgc3R5bGluZyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIFNvbWUgcG9zc2libGUgd2F5cyB0byBkbyB0aGlzIHRoYXRcbiAgd2VyZSByZWplY3RlZCBkdWUgdG8gY29tcGxleGl0eSBhbmQvb3IgcGVyZm9ybWFuY2UgY29uY2VybnMgaW5jbHVkZTogKDEpIHJlc2V0XG4gIGV2ZXJ5IHBvc3NpYmxlIHByb3BlcnR5IGZvciBldmVyeSBwb3NzaWJsZSBzZWxlY3RvciBmb3IgYSBnaXZlbiBzY29wZSBuYW1lO1xuICAoMikgcmUtaW1wbGVtZW50IGNzcyBpbiBqYXZhc2NyaXB0LlxuXG4gIEFzIGFuIGFsdGVybmF0aXZlLCB1c2VycyBzaG91bGQgbWFrZSBzdXJlIHRvIHVzZSBzZWxlY3RvcnNcbiAgc3BlY2lmaWMgdG8gdGhlIHNjb3BlIGluIHdoaWNoIHRoZXkgYXJlIHdvcmtpbmcuXG5cbiAgKiA6OmRpc3RyaWJ1dGVkOiBUaGlzIGJlaGF2aW9yIGlzIG5vdCBlbXVsYXRlZC4gSXQncyBvZnRlbiBub3QgbmVjZXNzYXJ5XG4gIHRvIHN0eWxlIHRoZSBjb250ZW50cyBvZiBhIHNwZWNpZmljIGluc2VydGlvbiBwb2ludCBhbmQgaW5zdGVhZCwgZGVzY2VuZGFudHNcbiAgb2YgdGhlIGhvc3QgZWxlbWVudCBjYW4gYmUgc3R5bGVkIHNlbGVjdGl2ZWx5LiBVc2VycyBjYW4gYWxzbyBjcmVhdGUgYW5cbiAgZXh0cmEgbm9kZSBhcm91bmQgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBzdHlsZSB0aGF0IG5vZGUncyBjb250ZW50c1xuICB2aWEgZGVzY2VuZGVudCBzZWxlY3RvcnMuIEZvciBleGFtcGxlLCB3aXRoIGEgc2hhZG93Um9vdCBsaWtlIHRoaXM6XG5cbiAgICA8c3R5bGU+XG4gICAgICA6OmNvbnRlbnQoZGl2KSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICAgIDxjb250ZW50PjwvY29udGVudD5cblxuICBjb3VsZCBiZWNvbWU6XG5cbiAgICA8c3R5bGU+XG4gICAgICAvICpAcG9seWZpbGwgLmNvbnRlbnQtY29udGFpbmVyIGRpdiAqIC9cbiAgICAgIDo6Y29udGVudChkaXYpIHtcbiAgICAgICAgYmFja2dyb3VuZDogcmVkO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRlbnQtY29udGFpbmVyXCI+XG4gICAgICA8Y29udGVudD48L2NvbnRlbnQ+XG4gICAgPC9kaXY+XG5cbiAgTm90ZSB0aGUgdXNlIG9mIEBwb2x5ZmlsbCBpbiB0aGUgY29tbWVudCBhYm92ZSBhIFNoYWRvd0RPTSBzcGVjaWZpYyBzdHlsZVxuICBkZWNsYXJhdGlvbi4gVGhpcyBpcyBhIGRpcmVjdGl2ZSB0byB0aGUgc3R5bGluZyBzaGltIHRvIHVzZSB0aGUgc2VsZWN0b3JcbiAgaW4gY29tbWVudHMgaW4gbGlldSBvZiB0aGUgbmV4dCBzZWxlY3RvciB3aGVuIHJ1bm5pbmcgdW5kZXIgcG9seWZpbGwuXG4qL1xuY2xhc3MgU2hhZG93Q3NzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdHJpY3RTdHlsaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBTaGltIHNvbWUgY3NzVGV4dCB3aXRoIHRoZSBnaXZlbiBzZWxlY3Rvci4gUmV0dXJucyBjc3NUZXh0IHRoYXQgY2FuXG4gICAgICogYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50IHZpYSBXZWJDb21wb25lbnRzLlNoYWRvd0NTUy5hZGRDc3NUb0RvY3VtZW50KGNzcykuXG4gICAgICpcbiAgICAgKiBXaGVuIHN0cmljdFN0eWxpbmcgaXMgdHJ1ZTpcbiAgICAgKiAtIHNlbGVjdG9yIGlzIHRoZSBhdHRyaWJ1dGUgYWRkZWQgdG8gYWxsIGVsZW1lbnRzIGluc2lkZSB0aGUgaG9zdCxcbiAgICAgKiAtIGhvc3RTZWxlY3RvciBpcyB0aGUgYXR0cmlidXRlIGFkZGVkIHRvIHRoZSBob3N0IGl0c2VsZi5cbiAgICAgKi9cbiAgICBzaGltQ3NzVGV4dChjc3NUZXh0LCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yID0gJycpIHtcbiAgICAgICAgY29uc3QgY29tbWVudHNXaXRoSGFzaCA9IGV4dHJhY3RDb21tZW50c1dpdGhIYXNoKGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gc3RyaXBDb21tZW50cyhjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydERpcmVjdGl2ZXMoY3NzVGV4dCk7XG4gICAgICAgIGNvbnN0IHNjb3BlZENzc1RleHQgPSB0aGlzLl9zY29wZUNzc1RleHQoY3NzVGV4dCwgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBbc2NvcGVkQ3NzVGV4dCwgLi4uY29tbWVudHNXaXRoSGFzaF0uam9pbignXFxuJyk7XG4gICAgfVxuICAgIF9pbnNlcnREaXJlY3RpdmVzKGNzc1RleHQpIHtcbiAgICAgICAgY3NzVGV4dCA9IHRoaXMuX2luc2VydFBvbHlmaWxsRGlyZWN0aXZlc0luQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgfVxuICAgIC8qXG4gICAgICogUHJvY2VzcyBzdHlsZXMgdG8gY29udmVydCBuYXRpdmUgU2hhZG93RE9NIHJ1bGVzIHRoYXQgd2lsbCB0cmlwXG4gICAgICogdXAgdGhlIGNzcyBwYXJzZXI7IHdlIHJlbHkgb24gZGVjb3JhdGluZyB0aGUgc3R5bGVzaGVldCB3aXRoIGluZXJ0IHJ1bGVzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdlIGNvbnZlcnQgdGhpcyBydWxlOlxuICAgICAqXG4gICAgICogcG9seWZpbGwtbmV4dC1zZWxlY3RvciB7IGNvbnRlbnQ6ICc6aG9zdCBtZW51LWl0ZW0nOyB9XG4gICAgICogOjpjb250ZW50IG1lbnUtaXRlbSB7XG4gICAgICpcbiAgICAgKiB0byB0aGlzOlxuICAgICAqXG4gICAgICogc2NvcGVOYW1lIG1lbnUtaXRlbSB7XG4gICAgICpcbiAgICAgKiovXG4gICAgX2luc2VydFBvbHlmaWxsRGlyZWN0aXZlc0luQ3NzVGV4dChjc3NUZXh0KSB7XG4gICAgICAgIC8vIERpZmZlcmVuY2Ugd2l0aCB3ZWJjb21wb25lbnRzLmpzOiBkb2VzIG5vdCBoYW5kbGUgY29tbWVudHNcbiAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShfY3NzQ29udGVudE5leHRTZWxlY3RvclJlLCBmdW5jdGlvbiAoLi4ubSkge1xuICAgICAgICAgICAgcmV0dXJuIG1bMl0gKyAneyc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGFkZCBydWxlcyB3aGljaCB3aWxsIG9ubHkgYXBwbHkgdW5kZXIgdGhlIHBvbHlmaWxsXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XG4gICAgICpcbiAgICAgKiBwb2x5ZmlsbC1ydWxlIHtcbiAgICAgKiAgIGNvbnRlbnQ6ICc6aG9zdCBtZW51LWl0ZW0nO1xuICAgICAqIC4uLlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHRvIHRoaXM6XG4gICAgICpcbiAgICAgKiBzY29wZU5hbWUgbWVudS1pdGVtIHsuLi59XG4gICAgICpcbiAgICAgKiovXG4gICAgX2luc2VydFBvbHlmaWxsUnVsZXNJbkNzc1RleHQoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnRSdWxlUmUsICguLi5tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gbVswXS5yZXBsYWNlKG1bMV0sICcnKS5yZXBsYWNlKG1bMl0sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBtWzRdICsgcnVsZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qIEVuc3VyZSBzdHlsZXMgYXJlIHNjb3BlZC4gUHNldWRvLXNjb3BpbmcgdGFrZXMgYSBydWxlIGxpa2U6XG4gICAgICpcbiAgICAgKiAgLmZvbyB7Li4uIH1cbiAgICAgKlxuICAgICAqICBhbmQgY29udmVydHMgdGhpcyB0b1xuICAgICAqXG4gICAgICogIHNjb3BlTmFtZSAuZm9vIHsgLi4uIH1cbiAgICAgKi9cbiAgICBfc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCB1bnNjb3BlZFJ1bGVzID0gdGhpcy5fZXh0cmFjdFVuc2NvcGVkUnVsZXNGcm9tQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgLy8gcmVwbGFjZSA6aG9zdCBhbmQgOmhvc3QtY29udGV4dCAtc2hhZG93Y3NzaG9zdCBhbmQgLXNoYWRvd2Nzc2hvc3QgcmVzcGVjdGl2ZWx5XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0Q29sb25Ib3N0KGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xuICAgICAgICBpZiAoc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX3Njb3BlU2VsZWN0b3JzKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQgKyAnXFxuJyArIHVuc2NvcGVkUnVsZXM7XG4gICAgICAgIHJldHVybiBjc3NUZXh0LnRyaW0oKTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBhZGQgcnVsZXMgd2hpY2ggd2lsbCBvbmx5IGFwcGx5IHVuZGVyIHRoZSBwb2x5ZmlsbFxuICAgICAqIGFuZCBkbyBub3QgcHJvY2VzcyB2aWEgQ1NTT00uIChDU1NPTSBpcyBkZXN0cnVjdGl2ZSB0byBydWxlcyBvbiByYXJlXG4gICAgICogb2NjYXNpb25zLCBlLmcuIC13ZWJraXQtY2FsYyBvbiBTYWZhcmkuKVxuICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgKlxuICAgICAqIEBwb2x5ZmlsbC11bnNjb3BlZC1ydWxlIHtcbiAgICAgKiAgIGNvbnRlbnQ6ICdtZW51LWl0ZW0nO1xuICAgICAqIC4uLiB9XG4gICAgICpcbiAgICAgKiB0byB0aGlzOlxuICAgICAqXG4gICAgICogbWVudS1pdGVtIHsuLi59XG4gICAgICpcbiAgICAgKiovXG4gICAgX2V4dHJhY3RVbnNjb3BlZFJ1bGVzRnJvbUNzc1RleHQoY3NzVGV4dCkge1xuICAgICAgICAvLyBEaWZmZXJlbmNlIHdpdGggd2ViY29tcG9uZW50cy5qczogZG9lcyBub3QgaGFuZGxlIGNvbW1lbnRzXG4gICAgICAgIGxldCByID0gJyc7XG4gICAgICAgIGxldCBtO1xuICAgICAgICBfY3NzQ29udGVudFVuc2NvcGVkUnVsZVJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICgobSA9IF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUuZXhlYyhjc3NUZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBtWzBdLnJlcGxhY2UobVsyXSwgJycpLnJlcGxhY2UobVsxXSwgbVs0XSk7XG4gICAgICAgICAgICByICs9IHJ1bGUgKyAnXFxuXFxuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgLypcbiAgICAgKiBjb252ZXJ0IGEgcnVsZSBsaWtlIDpob3N0KC5mb28pID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIHRvXG4gICAgICpcbiAgICAgKiAuZm9vPHNjb3BlTmFtZT4gPiAuYmFyXG4gICAgICovXG4gICAgX2NvbnZlcnRDb2xvbkhvc3QoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb2xvbkhvc3RSZSwgKF8sIGhvc3RTZWxlY3RvcnMsIG90aGVyU2VsZWN0b3JzKSA9PiB7XG4gICAgICAgICAgICBpZiAoaG9zdFNlbGVjdG9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvc3RTZWxlY3RvckFycmF5ID0gaG9zdFNlbGVjdG9ycy5zcGxpdCgnLCcpLm1hcChwID0+IHAudHJpbSgpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhvc3RTZWxlY3RvciBvZiBob3N0U2VsZWN0b3JBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhvc3RTZWxlY3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRTZWxlY3RvciA9IF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgKyBob3N0U2VsZWN0b3IucmVwbGFjZShfcG9seWZpbGxIb3N0LCAnJykgKyBvdGhlclNlbGVjdG9ycztcbiAgICAgICAgICAgICAgICAgICAgY29udmVydGVkU2VsZWN0b3JzLnB1c2goY29udmVydGVkU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydGVkU2VsZWN0b3JzLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yICsgb3RoZXJTZWxlY3RvcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIGNvbnZlcnQgYSBydWxlIGxpa2UgOmhvc3QtY29udGV4dCguZm9vKSA+IC5iYXIgeyB9XG4gICAgICpcbiAgICAgKiB0b1xuICAgICAqXG4gICAgICogLmZvbzxzY29wZU5hbWU+ID4gLmJhciwgLmZvbyA8c2NvcGVOYW1lPiA+IC5iYXIgeyB9XG4gICAgICpcbiAgICAgKiBhbmRcbiAgICAgKlxuICAgICAqIDpob3N0LWNvbnRleHQoLmZvbzpob3N0KSAuYmFyIHsgLi4uIH1cbiAgICAgKlxuICAgICAqIHRvXG4gICAgICpcbiAgICAgKiAuZm9vPHNjb3BlTmFtZT4gLmJhciB7IC4uLiB9XG4gICAgICovXG4gICAgX2NvbnZlcnRDb2xvbkhvc3RDb250ZXh0KGNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShfY3NzQ29sb25Ib3N0Q29udGV4dFJlR2xvYmFsLCBzZWxlY3RvclRleHQgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBjYXB0dXJlZCBhIHNlbGVjdG9yIHRoYXQgY29udGFpbnMgYSBgOmhvc3QtY29udGV4dGAgcnVsZS5cbiAgICAgICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGA6aG9zdC1jb250ZXh0YCBtYXkgY29udGFpbiBhIGNvbW1hIHNlcGFyYXRlZCBsaXN0IG9mIHNlbGVjdG9ycy5cbiAgICAgICAgICAgIC8vIEVhY2ggY29udGV4dCBzZWxlY3RvciBncm91cCB3aWxsIGNvbnRhaW4gYSBsaXN0IG9mIGhvc3QtY29udGV4dCBzZWxlY3RvcnMgdGhhdCBtdXN0IG1hdGNoXG4gICAgICAgICAgICAvLyBhbiBhbmNlc3RvciBvZiB0aGUgaG9zdC5cbiAgICAgICAgICAgIC8vIChOb3JtYWxseSBgY29udGV4dFNlbGVjdG9yR3JvdXBzYCB3aWxsIG9ubHkgY29udGFpbiBhIHNpbmdsZSBhcnJheSBvZiBjb250ZXh0IHNlbGVjdG9ycy4pXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0U2VsZWN0b3JHcm91cHMgPSBbW11dO1xuICAgICAgICAgICAgLy8gVGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBgOmhvc3QtY29udGV4dGAgaW4gdGhpcyBzZWxlY3RvciBzbyBgc2VsZWN0b3JUZXh0YCBjb3VsZCBsb29rIGxpa2U6XG4gICAgICAgICAgICAvLyBgOmhvc3QtY29udGV4dCgub25lKTpob3N0LWNvbnRleHQoLnR3bylgLlxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBgX2Nzc0NvbG9uSG9zdENvbnRleHRSZWAgb3ZlciBhbmQgb3ZlciB1bnRpbCB3ZSBoYXZlIGV4dHJhY3RlZCBhbGwgdGhlXG4gICAgICAgICAgICAvLyBgOmhvc3QtY29udGV4dGAgc2VsZWN0b3JzIGZyb20gdGhpcyBzZWxlY3Rvci5cbiAgICAgICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IF9jc3NDb2xvbkhvc3RDb250ZXh0UmUuZXhlYyhzZWxlY3RvclRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gYG1hdGNoYCA9IFsnOmhvc3QtY29udGV4dCg8c2VsZWN0b3JzPik8cmVzdD4nLCA8c2VsZWN0b3JzPiwgPHJlc3Q+XVxuICAgICAgICAgICAgICAgIC8vIFRoZSBgPHNlbGVjdG9ycz5gIGNvdWxkIGFjdHVhbGx5IGJlIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Q6IGA6aG9zdC1jb250ZXh0KC5vbmUsIC50d28pYC5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0U2VsZWN0b3JzID0gKChfYSA9IG1hdGNoWzFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudHJpbSgpLnNwbGl0KCcsJykubWFwKG0gPT4gbS50cmltKCkpLmZpbHRlcihtID0+IG0gIT09ICcnKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGR1cGxpY2F0ZSB0aGUgY3VycmVudCBzZWxlY3RvciBncm91cCBmb3IgZWFjaCBvZiB0aGVzZSBuZXcgc2VsZWN0b3JzLlxuICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlIGlmIHRoZSBjdXJyZW50IGdyb3VwcyBhcmU6XG4gICAgICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICAgICAgICAgIC8vICAgWydhJywgJ2InLCAnYyddLFxuICAgICAgICAgICAgICAgIC8vICAgWyd4JywgJ3knLCAneiddLFxuICAgICAgICAgICAgICAgIC8vIF1cbiAgICAgICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgICAgICAvLyBBbmQgd2UgaGF2ZSBhIG5ldyBzZXQgb2YgY29tbWEgc2VwYXJhdGVkIHNlbGVjdG9yczogYDpob3N0LWNvbnRleHQobSxuKWAgdGhlbiB0aGUgbmV3XG4gICAgICAgICAgICAgICAgLy8gZ3JvdXBzIGFyZTpcbiAgICAgICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgICAgICAgICAgLy8gICBbJ2EnLCAnYicsICdjJywgJ20nXSxcbiAgICAgICAgICAgICAgICAvLyAgIFsneCcsICd5JywgJ3onLCAnbSddLFxuICAgICAgICAgICAgICAgIC8vICAgWydhJywgJ2InLCAnYycsICduJ10sXG4gICAgICAgICAgICAgICAgLy8gICBbJ3gnLCAneScsICd6JywgJ24nXSxcbiAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dFNlbGVjdG9yR3JvdXBzTGVuZ3RoID0gY29udGV4dFNlbGVjdG9yR3JvdXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXBlYXRHcm91cHMoY29udGV4dFNlbGVjdG9yR3JvdXBzLCBuZXdDb250ZXh0U2VsZWN0b3JzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdDb250ZXh0U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29udGV4dFNlbGVjdG9yR3JvdXBzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRTZWxlY3Rvckdyb3Vwc1tqICsgKGkgKiBjb250ZXh0U2VsZWN0b3JHcm91cHNMZW5ndGgpXS5wdXNoKG5ld0NvbnRleHRTZWxlY3RvcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgYHNlbGVjdG9yVGV4dGAgYW5kIHNlZSByZXBlYXQgdG8gc2VlIGlmIHRoZXJlIGFyZSBtb3JlIGA6aG9zdC1jb250ZXh0YHMuXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JUZXh0ID0gbWF0Y2hbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgY29udGV4dCBzZWxlY3RvcnMgbm93IG11c3QgYmUgY29tYmluZWQgd2l0aCBlYWNoIG90aGVyIHRvIGNhcHR1cmUgYWxsIHRoZSBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gc2VsZWN0b3JzIHRoYXQgYDpob3N0LWNvbnRleHRgIGNhbiBtYXRjaC4gU2VlIGBjb21iaW5lSG9zdENvbnRleHRTZWxlY3RvcnMoKWAgZm9yIG1vcmVcbiAgICAgICAgICAgIC8vIGluZm8gYWJvdXQgaG93IHRoaXMgaXMgZG9uZS5cbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0U2VsZWN0b3JHcm91cHNcbiAgICAgICAgICAgICAgICAubWFwKGNvbnRleHRTZWxlY3RvcnMgPT4gY29tYmluZUhvc3RDb250ZXh0U2VsZWN0b3JzKGNvbnRleHRTZWxlY3RvcnMsIHNlbGVjdG9yVGV4dCkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIENvbnZlcnQgY29tYmluYXRvcnMgbGlrZSA6OnNoYWRvdyBhbmQgcHNldWRvLWVsZW1lbnRzIGxpa2UgOjpjb250ZW50XG4gICAgICogYnkgcmVwbGFjaW5nIHdpdGggc3BhY2UuXG4gICAgICovXG4gICAgX2NvbnZlcnRTaGFkb3dET01TZWxlY3RvcnMoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gX3NoYWRvd0RPTVNlbGVjdG9yc1JlLnJlZHVjZSgocmVzdWx0LCBwYXR0ZXJuKSA9PiByZXN1bHQucmVwbGFjZShwYXR0ZXJuLCAnICcpLCBjc3NUZXh0KTtcbiAgICB9XG4gICAgLy8gY2hhbmdlIGEgc2VsZWN0b3IgbGlrZSAnZGl2JyB0byAnbmFtZSBkaXYnXG4gICAgX3Njb3BlU2VsZWN0b3JzKGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1J1bGVzKGNzc1RleHQsIChydWxlKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBydWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAocnVsZS5zZWxlY3RvclswXSAhPT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY29wZVNlbGVjdG9yKHJ1bGUuc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3RvciwgdGhpcy5zdHJpY3RTdHlsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQG1lZGlhJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAc3VwcG9ydHMnKSB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQGRvY3VtZW50JykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAbGF5ZXInKSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLl9zY29wZVNlbGVjdG9ycyhydWxlLmNvbnRlbnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0Bmb250LWZhY2UnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BwYWdlJykpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5fc3RyaXBTY29waW5nU2VsZWN0b3JzKHJ1bGUuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGEgY3NzIHRleHQgdGhhdCBpcyB3aXRoaW4gYSBydWxlIHRoYXQgc2hvdWxkIG5vdCBjb250YWluIHNjb3BlIHNlbGVjdG9ycyBieSBzaW1wbHlcbiAgICAgKiByZW1vdmluZyB0aGVtISBBbiBleGFtcGxlIG9mIHN1Y2ggYSBydWxlIGlzIGBAZm9udC1mYWNlYC5cbiAgICAgKlxuICAgICAqIGBAZm9udC1mYWNlYCBydWxlcyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgc2VsZWN0b3JzLiBOb3IgY2FuIHRoZXkgYmUgbmVzdGVkIHVuZGVyIGEgc2VsZWN0b3IuXG4gICAgICogTm9ybWFsbHkgdGhpcyB3b3VsZCBiZSBhIHN5bnRheCBlcnJvciBieSB0aGUgYXV0aG9yIG9mIHRoZSBzdHlsZXMuIEJ1dCBpbiBzb21lIHJhcmUgY2FzZXMsIHN1Y2hcbiAgICAgKiBhcyBpbXBvcnRpbmcgc3R5bGVzIGZyb20gYSBsaWJyYXJ5LCBhbmQgYXBwbHlpbmcgYDpob3N0IDo6bmctZGVlcGAgdG8gdGhlIGltcG9ydGVkIHN0eWxlcywgd2VcbiAgICAgKiBjYW4gZW5kIHVwIHdpdGggYnJva2VuIGNzcyBpZiB0aGUgaW1wb3J0ZWQgc3R5bGVzIGhhcHBlbiB0byBjb250YWluIEBmb250LWZhY2UgcnVsZXMuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDpob3N0IDo6bmctZGVlcCB7XG4gICAgICogICBpbXBvcnQgJ3NvbWUvbGliL2NvbnRhaW5pbmcvZm9udC1mYWNlJztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBTaW1pbGFyIGxvZ2ljIGFwcGxpZXMgdG8gYEBwYWdlYCBydWxlcyB3aGljaCBjYW4gY29udGFpbiBhIHBhcnRpY3VsYXIgc2V0IG9mIHByb3BlcnRpZXMsXG4gICAgICogYXMgd2VsbCBhcyBzb21lIHNwZWNpZmljIGF0LXJ1bGVzLiBTaW5jZSB0aGV5IGNhbid0IGJlIGVuY2Fwc3VsYXRlZCwgd2UgaGF2ZSB0byBzdHJpcFxuICAgICAqIGFueSBzY29waW5nIHNlbGVjdG9ycyBmcm9tIHRoZW0uIEZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXBhZ2UtM1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIF9zdHJpcFNjb3BpbmdTZWxlY3RvcnMoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1J1bGVzKGNzc1RleHQsIHJ1bGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBydWxlLnNlbGVjdG9yLnJlcGxhY2UoX3NoYWRvd0RlZXBTZWxlY3RvcnMsICcgJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZShfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUsICcgJyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENzc1J1bGUoc2VsZWN0b3IsIHJ1bGUuY29udGVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2NvcGVTZWxlY3RvcihzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnNwbGl0KCcsJylcbiAgICAgICAgICAgIC5tYXAocGFydCA9PiBwYXJ0LnRyaW0oKS5zcGxpdChfc2hhZG93RGVlcFNlbGVjdG9ycykpXG4gICAgICAgICAgICAubWFwKChkZWVwUGFydHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtzaGFsbG93UGFydCwgLi4ub3RoZXJQYXJ0c10gPSBkZWVwUGFydHM7XG4gICAgICAgICAgICBjb25zdCBhcHBseVNjb3BlID0gKHNoYWxsb3dQYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdG9yTmVlZHNTY29waW5nKHNoYWxsb3dQYXJ0LCBzY29wZVNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaWN0ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5U3RyaWN0U2VsZWN0b3JTY29wZShzaGFsbG93UGFydCwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVNlbGVjdG9yU2NvcGUoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1BhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBbYXBwbHlTY29wZShzaGFsbG93UGFydCksIC4uLm90aGVyUGFydHNdLmpvaW4oJyAnKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgIH1cbiAgICBfc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmUgPSB0aGlzLl9tYWtlU2NvcGVNYXRjaGVyKHNjb3BlU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gIXJlLnRlc3Qoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBfbWFrZVNjb3BlTWF0Y2hlcihzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGxyZSA9IC9cXFsvZztcbiAgICAgICAgY29uc3QgcnJlID0gL1xcXS9nO1xuICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGxyZSwgJ1xcXFxbJykucmVwbGFjZShycmUsICdcXFxcXScpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgc2NvcGVTZWxlY3RvciArICcpJyArIF9zZWxlY3RvclJlU3VmZml4LCAnbScpO1xuICAgIH1cbiAgICBfYXBwbHlTZWxlY3RvclNjb3BlKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgLy8gRGlmZmVyZW5jZSBmcm9tIHdlYmNvbXBvbmVudHMuanM6IHNjb3BlU2VsZWN0b3IgY291bGQgbm90IGJlIGFuIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBseVNpbXBsZVNlbGVjdG9yU2NvcGUoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgfVxuICAgIC8vIHNjb3BlIHZpYSBuYW1lIGFuZCBbaXM9bmFtZV1cbiAgICBfYXBwbHlTaW1wbGVTZWxlY3RvclNjb3BlKHNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgLy8gSW4gQW5kcm9pZCBicm93c2VyLCB0aGUgbGFzdEluZGV4IGlzIG5vdCByZXNldCB3aGVuIHRoZSByZWdleCBpcyB1c2VkIGluIFN0cmluZy5yZXBsYWNlKClcbiAgICAgICAgX3BvbHlmaWxsSG9zdFJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmIChfcG9seWZpbGxIb3N0UmUudGVzdChzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VCeSA9IHRoaXMuc3RyaWN0U3R5bGluZyA/IGBbJHtob3N0U2VsZWN0b3J9XWAgOiBzY29wZVNlbGVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCAoaG5jLCBzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKC8oW146XSopKDoqKSguKikvLCAoXywgYmVmb3JlLCBjb2xvbiwgYWZ0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSArIHJlcGxhY2VCeSArIGNvbG9uICsgYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgcmVwbGFjZUJ5ICsgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVTZWxlY3RvciArICcgJyArIHNlbGVjdG9yO1xuICAgIH1cbiAgICAvLyByZXR1cm4gYSBzZWxlY3RvciB3aXRoIFtuYW1lXSBzdWZmaXggb24gZWFjaCBzaW1wbGUgc2VsZWN0b3JcbiAgICAvLyBlLmcuIC5mb28uYmFyID4gLnpvdCBiZWNvbWVzIC5mb29bbmFtZV0uYmFyW25hbWVdID4gLnpvdFtuYW1lXSAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hcHBseVN0cmljdFNlbGVjdG9yU2NvcGUoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBpc1JlID0gL1xcW2lzPShbXlxcXV0qKVxcXS9nO1xuICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGlzUmUsIChfLCAuLi5wYXJ0cykgPT4gcGFydHNbMF0pO1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9ICdbJyArIHNjb3BlU2VsZWN0b3IgKyAnXSc7XG4gICAgICAgIGNvbnN0IF9zY29wZVNlbGVjdG9yUGFydCA9IChwKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFzY29wZWRQKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVkUCA9IHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShwLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIDpob3N0IHNpbmNlIGl0IHNob3VsZCBiZSB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwLnJlcGxhY2UoX3BvbHlmaWxsSG9zdFJlLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdC5tYXRjaCgvKFteOl0qKSg6KikoLiopLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZWRQID0gbWF0Y2hlc1sxXSArIGF0dHJOYW1lICsgbWF0Y2hlc1syXSArIG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVkUDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2FmZUNvbnRlbnQgPSBuZXcgU2FmZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzYWZlQ29udGVudC5jb250ZW50KCk7XG4gICAgICAgIGxldCBzY29wZWRTZWxlY3RvciA9ICcnO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGNvbnN0IHNlcCA9IC8oIHw+fFxcK3x+KD8hPSkpXFxzKi9nO1xuICAgICAgICAvLyBJZiBhIHNlbGVjdG9yIGFwcGVhcnMgYmVmb3JlIDpob3N0IGl0IHNob3VsZCBub3QgYmUgc2hpbW1lZCBhcyBpdFxuICAgICAgICAvLyBtYXRjaGVzIG9uIGFuY2VzdG9yIGVsZW1lbnRzIGFuZCBub3Qgb24gZWxlbWVudHMgaW4gdGhlIGhvc3QncyBzaGFkb3dcbiAgICAgICAgLy8gYDpob3N0LWNvbnRleHQoZGl2KWAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAgICAgLy8gYC1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3JkaXYsIGRpdiAtc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yYFxuICAgICAgICAvLyB0aGUgYGRpdmAgaXMgbm90IHBhcnQgb2YgdGhlIGNvbXBvbmVudCBpbiB0aGUgMm5kIHNlbGVjdG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBzY29wZWQuXG4gICAgICAgIC8vIEhpc3RvcmljYWxseSBgY29tcG9uZW50LXRhZzpob3N0YCB3YXMgbWF0Y2hpbmcgdGhlIGNvbXBvbmVudCBzbyB3ZSBhbHNvIHdhbnQgdG8gcHJlc2VydmVcbiAgICAgICAgLy8gdGhpcyBiZWhhdmlvciB0byBhdm9pZCBicmVha2luZyBsZWdhY3kgYXBwcyAoaXQgc2hvdWxkIG5vdCBtYXRjaCkuXG4gICAgICAgIC8vIFRoZSBiZWhhdmlvciBzaG91bGQgYmU6XG4gICAgICAgIC8vIC0gYHRhZzpob3N0YCAtPiBgdGFnW2hdYCAodGhpcyBpcyB0byBhdm9pZCBicmVha2luZyBsZWdhY3kgYXBwcywgc2hvdWxkIG5vdCBtYXRjaCBhbnl0aGluZylcbiAgICAgICAgLy8gLSBgdGFnIDpob3N0YCAtPiBgdGFnIFtoXWAgKGB0YWdgIGlzIG5vdCBzY29wZWQgYmVjYXVzZSBpdCdzIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgICAgIC8vICAgYDpob3N0LWNvbnRleHQodGFnKWApXG4gICAgICAgIGNvbnN0IGhhc0hvc3QgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgICAgIC8vIE9ubHkgc2NvcGUgcGFydHMgYWZ0ZXIgdGhlIGZpcnN0IGAtc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yYCB3aGVuIGl0IGlzIHByZXNlbnRcbiAgICAgICAgbGV0IHNob3VsZFNjb3BlID0gIWhhc0hvc3Q7XG4gICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gcmVzWzFdO1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHNlbGVjdG9yLnNsaWNlKHN0YXJ0SW5kZXgsIHJlcy5pbmRleCkudHJpbSgpO1xuICAgICAgICAgICAgc2hvdWxkU2NvcGUgPSBzaG91bGRTY29wZSB8fCBwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlZFBhcnQgPSBzaG91bGRTY29wZSA/IF9zY29wZVNlbGVjdG9yUGFydChwYXJ0KSA6IHBhcnQ7XG4gICAgICAgICAgICBzY29wZWRTZWxlY3RvciArPSBgJHtzY29wZWRQYXJ0fSAke3NlcGFyYXRvcn0gYDtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBzZXAubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnQgPSBzZWxlY3Rvci5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XG4gICAgICAgIHNob3VsZFNjb3BlID0gc2hvdWxkU2NvcGUgfHwgcGFydC5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IHNob3VsZFNjb3BlID8gX3Njb3BlU2VsZWN0b3JQYXJ0KHBhcnQpIDogcGFydDtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXJzIHdpdGggdGhlaXIgb3JpZ2luYWwgdmFsdWVzXG4gICAgICAgIHJldHVybiBzYWZlQ29udGVudC5yZXN0b3JlKHNjb3BlZFNlbGVjdG9yKTtcbiAgICB9XG4gICAgX2luc2VydFBvbHlmaWxsSG9zdEluQ3NzVGV4dChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShfY29sb25Ib3N0Q29udGV4dFJlLCBfcG9seWZpbGxIb3N0Q29udGV4dClcbiAgICAgICAgICAgIC5yZXBsYWNlKF9jb2xvbkhvc3RSZSwgX3BvbHlmaWxsSG9zdCk7XG4gICAgfVxufVxuY2xhc3MgU2FmZVNlbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IFtdO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgLy8gUmVwbGFjZXMgYXR0cmlidXRlIHNlbGVjdG9ycyB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgICAgLy8gVGhlIFdTIGluIFthdHRyPVwidmEgbHVlXCJdIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBhIHNlbGVjdG9yIHNlcGFyYXRvci5cbiAgICAgICAgc2VsZWN0b3IgPSB0aGlzLl9lc2NhcGVSZWdleE1hdGNoZXMoc2VsZWN0b3IsIC8oXFxbW15cXF1dKlxcXSkvZyk7XG4gICAgICAgIC8vIENTUyBhbGxvd3MgZm9yIGNlcnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzIHRvIGJlIHVzZWQgaW4gc2VsZWN0b3JzIGlmIHRoZXkncmUgZXNjYXBlZC5cbiAgICAgICAgLy8gRS5nLiBgLmZvbzpibHVlYCB3b24ndCBtYXRjaCBhIGNsYXNzIGNhbGxlZCBgZm9vOmJsdWVgLCBiZWNhdXNlIHRoZSBjb2xvbiBkZW5vdGVzIGFcbiAgICAgICAgLy8gcHNldWRvLWNsYXNzLCBidXQgd3JpdGluZyBgLmZvb1xcOmJsdWVgIHdpbGwgbWF0Y2gsIGJlY2F1c2UgdGhlIGNvbG9uIHdhcyBlc2NhcGVkLlxuICAgICAgICAvLyBSZXBsYWNlIGFsbCBlc2NhcGUgc2VxdWVuY2VzIChgXFxgIGZvbGxvd2VkIGJ5IGEgY2hhcmFjdGVyKSB3aXRoIGEgcGxhY2Vob2xkZXIgc29cbiAgICAgICAgLy8gdGhhdCBvdXIgaGFuZGxpbmcgb2YgcHNldWRvLXNlbGVjdG9ycyBkb2Vzbid0IG1lc3Mgd2l0aCB0aGVtLlxuICAgICAgICBzZWxlY3RvciA9IHRoaXMuX2VzY2FwZVJlZ2V4TWF0Y2hlcyhzZWxlY3RvciwgLyhcXFxcLikvZyk7XG4gICAgICAgIC8vIFJlcGxhY2VzIHRoZSBleHByZXNzaW9uIGluIGA6bnRoLWNoaWxkKDJuICsgMSlgIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICAgICAgLy8gV1MgYW5kIFwiK1wiIHdvdWxkIG90aGVyd2lzZSBiZSBpbnRlcnByZXRlZCBhcyBzZWxlY3RvciBzZXBhcmF0b3JzLlxuICAgICAgICB0aGlzLl9jb250ZW50ID0gc2VsZWN0b3IucmVwbGFjZSgvKDpudGgtWy1cXHddKykoXFwoW14pXStcXCkpL2csIChfLCBwc2V1ZG8sIGV4cCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZUJ5ID0gYF9fcGgtJHt0aGlzLmluZGV4fV9fYDtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJzLnB1c2goZXhwKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgIHJldHVybiBwc2V1ZG8gKyByZXBsYWNlQnk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXN0b3JlKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZSgvX19waC0oXFxkKylfXy9nLCAoX3BoLCBpbmRleCkgPT4gdGhpcy5wbGFjZWhvbGRlcnNbK2luZGV4XSk7XG4gICAgfVxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN1YnN0cmluZ3MgdGhhdCBtYXRjaCBhIHJlZ2V4IHdpdGhpbiBhXG4gICAgICogc3BlY2lhbCBzdHJpbmcgKGUuZy4gYF9fcGgtMF9fYCwgYF9fcGgtMV9fYCwgZXRjKS5cbiAgICAgKi9cbiAgICBfZXNjYXBlUmVnZXhNYXRjaGVzKGNvbnRlbnQsIHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZShwYXR0ZXJuLCAoXywga2VlcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZUJ5ID0gYF9fcGgtJHt0aGlzLmluZGV4fV9fYDtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJzLnB1c2goa2VlcCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZUJ5O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBfY3NzQ29udGVudE5leHRTZWxlY3RvclJlID0gL3BvbHlmaWxsLW5leHQtc2VsZWN0b3JbXn1dKmNvbnRlbnQ6W1xcc10qPyhbJ1wiXSkoLio/KVxcMVs7XFxzXSp9KFtee10qPyl7L2dpbTtcbmNvbnN0IF9jc3NDb250ZW50UnVsZVJlID0gLyhwb2x5ZmlsbC1ydWxlKVtefV0qKGNvbnRlbnQ6W1xcc10qKFsnXCJdKSguKj8pXFwzKVs7XFxzXSpbXn1dKn0vZ2ltO1xuY29uc3QgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZSA9IC8ocG9seWZpbGwtdW5zY29wZWQtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbmNvbnN0IF9wb2x5ZmlsbEhvc3QgPSAnLXNoYWRvd2Nzc2hvc3QnO1xuLy8gbm90ZTogOmhvc3QtY29udGV4dCBwcmUtcHJvY2Vzc2VkIHRvIC1zaGFkb3djc3Nob3N0Y29udGV4dC5cbmNvbnN0IF9wb2x5ZmlsbEhvc3RDb250ZXh0ID0gJy1zaGFkb3djc3Njb250ZXh0JztcbmNvbnN0IF9wYXJlblN1ZmZpeCA9ICcoPzpcXFxcKCgnICtcbiAgICAnKD86XFxcXChbXikoXSpcXFxcKXxbXikoXSopKz8nICtcbiAgICAnKVxcXFwpKT8oW14se10qKSc7XG5jb25zdCBfY3NzQ29sb25Ib3N0UmUgPSBuZXcgUmVnRXhwKF9wb2x5ZmlsbEhvc3QgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbmNvbnN0IF9jc3NDb2xvbkhvc3RDb250ZXh0UmVHbG9iYWwgPSBuZXcgUmVnRXhwKF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG5jb25zdCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlID0gbmV3IFJlZ0V4cChfcG9seWZpbGxIb3N0Q29udGV4dCArIF9wYXJlblN1ZmZpeCwgJ2ltJyk7XG5jb25zdCBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yID0gX3BvbHlmaWxsSG9zdCArICctbm8tY29tYmluYXRvcic7XG5jb25zdCBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUgPSAvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcihbXlxcc10qKS87XG5jb25zdCBfc2hhZG93RE9NU2VsZWN0b3JzUmUgPSBbXG4gICAgLzo6c2hhZG93L2csXG4gICAgLzo6Y29udGVudC9nLFxuICAgIC8vIERlcHJlY2F0ZWQgc2VsZWN0b3JzXG4gICAgL1xcL3NoYWRvdy1kZWVwXFwvL2csXG4gICAgL1xcL3NoYWRvd1xcLy9nLFxuXTtcbi8vIFRoZSBkZWVwIGNvbWJpbmF0b3IgaXMgZGVwcmVjYXRlZCBpbiB0aGUgQ1NTIHNwZWNcbi8vIFN1cHBvcnQgZm9yIGA+Pj5gLCBgZGVlcGAsIGA6Om5nLWRlZXBgIGlzIHRoZW4gYWxzbyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvMTc2NzdcbmNvbnN0IF9zaGFkb3dEZWVwU2VsZWN0b3JzID0gLyg/Oj4+Pil8KD86XFwvZGVlcFxcLyl8KD86OjpuZy1kZWVwKS9nO1xuY29uc3QgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1suLHs6XVtcXFxcc1xcXFxTXSopPyQnO1xuY29uc3QgX3BvbHlmaWxsSG9zdFJlID0gLy1zaGFkb3djc3Nob3N0L2dpbTtcbmNvbnN0IF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XG5jb25zdCBfY29sb25Ib3N0Q29udGV4dFJlID0gLzpob3N0LWNvbnRleHQvZ2ltO1xuY29uc3QgX2NvbW1lbnRSZSA9IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2c7XG5mdW5jdGlvbiBzdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoX2NvbW1lbnRSZSwgJycpO1xufVxuY29uc3QgX2NvbW1lbnRXaXRoSGFzaFJlID0gL1xcL1xcKlxccyojXFxzKnNvdXJjZShNYXBwaW5nKT9VUkw9W1xcc1xcU10rP1xcKlxcLy9nO1xuZnVuY3Rpb24gZXh0cmFjdENvbW1lbnRzV2l0aEhhc2goaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQubWF0Y2goX2NvbW1lbnRXaXRoSGFzaFJlKSB8fCBbXTtcbn1cbmNvbnN0IEJMT0NLX1BMQUNFSE9MREVSID0gJyVCTE9DSyUnO1xuY29uc3QgUVVPVEVfUExBQ0VIT0xERVIgPSAnJVFVT1RFRCUnO1xuY29uc3QgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG5jb25zdCBfcXVvdGVkUmUgPSAvJVFVT1RFRCUvZztcbmNvbnN0IENPTlRFTlRfUEFJUlMgPSBuZXcgTWFwKFtbJ3snLCAnfSddXSk7XG5jb25zdCBRVU9URV9QQUlSUyA9IG5ldyBNYXAoW1tgXCJgLCBgXCJgXSwgW2AnYCwgYCdgXV0pO1xuY2xhc3MgQ3NzUnVsZSB7XG4gICAgY29uc3RydWN0b3Ioc2VsZWN0b3IsIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NSdWxlcyhpbnB1dCwgcnVsZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5wdXRXaXRoRXNjYXBlZFF1b3RlcyA9IGVzY2FwZUJsb2NrcyhpbnB1dCwgUVVPVEVfUEFJUlMsIFFVT1RFX1BMQUNFSE9MREVSKTtcbiAgICBjb25zdCBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzID0gZXNjYXBlQmxvY2tzKGlucHV0V2l0aEVzY2FwZWRRdW90ZXMuZXNjYXBlZFN0cmluZywgQ09OVEVOVF9QQUlSUywgQkxPQ0tfUExBQ0VIT0xERVIpO1xuICAgIGxldCBuZXh0QmxvY2tJbmRleCA9IDA7XG4gICAgbGV0IG5leHRRdW90ZUluZGV4ID0gMDtcbiAgICByZXR1cm4gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5lc2NhcGVkU3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKF9ydWxlUmUsICguLi5tKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gbVsyXTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICAgICAgbGV0IHN1ZmZpeCA9IG1bNF07XG4gICAgICAgIGxldCBjb250ZW50UHJlZml4ID0gJyc7XG4gICAgICAgIGlmIChzdWZmaXggJiYgc3VmZml4LnN0YXJ0c1dpdGgoJ3snICsgQkxPQ0tfUExBQ0VIT0xERVIpKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gaW5wdXRXaXRoRXNjYXBlZEJsb2Nrcy5ibG9ja3NbbmV4dEJsb2NrSW5kZXgrK107XG4gICAgICAgICAgICBzdWZmaXggPSBzdWZmaXguc3Vic3RyaW5nKEJMT0NLX1BMQUNFSE9MREVSLmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgY29udGVudFByZWZpeCA9ICd7JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydWxlID0gcnVsZUNhbGxiYWNrKG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KSk7XG4gICAgICAgIHJldHVybiBgJHttWzFdfSR7cnVsZS5zZWxlY3Rvcn0ke21bM119JHtjb250ZW50UHJlZml4fSR7cnVsZS5jb250ZW50fSR7c3VmZml4fWA7XG4gICAgfSlcbiAgICAgICAgLnJlcGxhY2UoX3F1b3RlZFJlLCAoKSA9PiBpbnB1dFdpdGhFc2NhcGVkUXVvdGVzLmJsb2Nrc1tuZXh0UXVvdGVJbmRleCsrXSk7XG59XG5jbGFzcyBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyB7XG4gICAgY29uc3RydWN0b3IoZXNjYXBlZFN0cmluZywgYmxvY2tzKSB7XG4gICAgICAgIHRoaXMuZXNjYXBlZFN0cmluZyA9IGVzY2FwZWRTdHJpbmc7XG4gICAgICAgIHRoaXMuYmxvY2tzID0gYmxvY2tzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZUJsb2NrcyhpbnB1dCwgY2hhclBhaXJzLCBwbGFjZWhvbGRlcikge1xuICAgIGNvbnN0IHJlc3VsdFBhcnRzID0gW107XG4gICAgY29uc3QgZXNjYXBlZEJsb2NrcyA9IFtdO1xuICAgIGxldCBvcGVuQ2hhckNvdW50ID0gMDtcbiAgICBsZXQgbm9uQmxvY2tTdGFydEluZGV4ID0gMDtcbiAgICBsZXQgYmxvY2tTdGFydEluZGV4ID0gLTE7XG4gICAgbGV0IG9wZW5DaGFyO1xuICAgIGxldCBjbG9zZUNoYXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGFyID09PSBjbG9zZUNoYXIpIHtcbiAgICAgICAgICAgIG9wZW5DaGFyQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChvcGVuQ2hhckNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGlucHV0LnN1YnN0cmluZyhibG9ja1N0YXJ0SW5kZXgsIGkpKTtcbiAgICAgICAgICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICBub25CbG9ja1N0YXJ0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJsb2NrU3RhcnRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIG9wZW5DaGFyID0gY2xvc2VDaGFyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IG9wZW5DaGFyKSB7XG4gICAgICAgICAgICBvcGVuQ2hhckNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlbkNoYXJDb3VudCA9PT0gMCAmJiBjaGFyUGFpcnMuaGFzKGNoYXIpKSB7XG4gICAgICAgICAgICBvcGVuQ2hhciA9IGNoYXI7XG4gICAgICAgICAgICBjbG9zZUNoYXIgPSBjaGFyUGFpcnMuZ2V0KGNoYXIpO1xuICAgICAgICAgICAgb3BlbkNoYXJDb3VudCA9IDE7XG4gICAgICAgICAgICBibG9ja1N0YXJ0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIHJlc3VsdFBhcnRzLnB1c2goaW5wdXQuc3Vic3RyaW5nKG5vbkJsb2NrU3RhcnRJbmRleCwgYmxvY2tTdGFydEluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJsb2NrU3RhcnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgZXNjYXBlZEJsb2Nrcy5wdXNoKGlucHV0LnN1YnN0cmluZyhibG9ja1N0YXJ0SW5kZXgpKTtcbiAgICAgICAgcmVzdWx0UGFydHMucHVzaChwbGFjZWhvbGRlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKGlucHV0LnN1YnN0cmluZyhub25CbG9ja1N0YXJ0SW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJpbmdXaXRoRXNjYXBlZEJsb2NrcyhyZXN1bHRQYXJ0cy5qb2luKCcnKSwgZXNjYXBlZEJsb2Nrcyk7XG59XG4vKipcbiAqIENvbWJpbmUgdGhlIGBjb250ZXh0U2VsZWN0b3JzYCB3aXRoIHRoZSBgaG9zdE1hcmtlcmAgYW5kIHRoZSBgb3RoZXJTZWxlY3RvcnNgXG4gKiB0byBjcmVhdGUgYSBzZWxlY3RvciB0aGF0IG1hdGNoZXMgdGhlIHNhbWUgYXMgYDpob3N0LWNvbnRleHQoKWAuXG4gKlxuICogR2l2ZW4gYSBzaW5nbGUgY29udGV4dCBzZWxlY3RvciBgQWAgd2UgbmVlZCB0byBvdXRwdXQgc2VsZWN0b3JzIHRoYXQgbWF0Y2ggb24gdGhlIGhvc3QgYW5kIGFzIGFuXG4gKiBhbmNlc3RvciBvZiB0aGUgaG9zdDpcbiAqXG4gKiBgYGBcbiAqIEEgPGhvc3RNYXJrZXI+LCBBPGhvc3RNYXJrZXI+IHt9XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY29udGV4dCBzZWxlY3RvciB3ZSBhbHNvIGhhdmUgdG8gY3JlYXRlIGNvbWJpbmF0aW9ucyBvZiB0aG9zZVxuICogc2VsZWN0b3JzIHdpdGggZWFjaCBvdGhlci4gRm9yIGV4YW1wbGUgaWYgdGhlcmUgYXJlIGBBYCBhbmQgYEJgIHNlbGVjdG9ycyB0aGUgb3V0cHV0IGlzOlxuICpcbiAqIGBgYFxuICogQUI8aG9zdE1hcmtlcj4sIEFCIDxob3N0TWFya2VyPiwgQSBCPGhvc3RNYXJrZXI+LFxuICogQiBBPGhvc3RNYXJrZXI+LCBBIEIgPGhvc3RNYXJrZXI+LCBCIEEgPGhvc3RNYXJrZXI+IHt9XG4gKiBgYGBcbiAqXG4gKiBBbmQgc28gb24uLi5cbiAqXG4gKiBAcGFyYW0gaG9zdE1hcmtlciB0aGUgc3RyaW5nIHRoYXQgc2VsZWN0cyB0aGUgaG9zdCBlbGVtZW50LlxuICogQHBhcmFtIGNvbnRleHRTZWxlY3RvcnMgYW4gYXJyYXkgb2YgY29udGV4dCBzZWxlY3RvcnMgdGhhdCB3aWxsIGJlIGNvbWJpbmVkLlxuICogQHBhcmFtIG90aGVyU2VsZWN0b3JzIHRoZSByZXN0IG9mIHRoZSBzZWxlY3RvcnMgdGhhdCBhcmUgbm90IGNvbnRleHQgc2VsZWN0b3JzLlxuICovXG5mdW5jdGlvbiBjb21iaW5lSG9zdENvbnRleHRTZWxlY3RvcnMoY29udGV4dFNlbGVjdG9ycywgb3RoZXJTZWxlY3RvcnMpIHtcbiAgICBjb25zdCBob3N0TWFya2VyID0gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcjtcbiAgICBfcG9seWZpbGxIb3N0UmUubGFzdEluZGV4ID0gMDsgLy8gcmVzZXQgdGhlIHJlZ2V4IHRvIGVuc3VyZSB3ZSBnZXQgYW4gYWNjdXJhdGUgdGVzdFxuICAgIGNvbnN0IG90aGVyU2VsZWN0b3JzSGFzSG9zdCA9IF9wb2x5ZmlsbEhvc3RSZS50ZXN0KG90aGVyU2VsZWN0b3JzKTtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY29udGV4dCBzZWxlY3RvcnMgdGhlbiBqdXN0IG91dHB1dCBhIGhvc3QgbWFya2VyXG4gICAgaWYgKGNvbnRleHRTZWxlY3RvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBob3N0TWFya2VyICsgb3RoZXJTZWxlY3RvcnM7XG4gICAgfVxuICAgIGNvbnN0IGNvbWJpbmVkID0gW2NvbnRleHRTZWxlY3RvcnMucG9wKCkgfHwgJyddO1xuICAgIHdoaWxlIChjb250ZXh0U2VsZWN0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY29tYmluZWQubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb250ZXh0U2VsZWN0b3IgPSBjb250ZXh0U2VsZWN0b3JzLnBvcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1NlbGVjdG9ycyA9IGNvbWJpbmVkW2ldO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgc2VsZWN0b3IgYXMgYSBkZXNjZW5kYW50IG9mIHRoZSBwcmV2aW91cyBzZWxlY3RvcnNcbiAgICAgICAgICAgIGNvbWJpbmVkW2xlbmd0aCAqIDIgKyBpXSA9IHByZXZpb3VzU2VsZWN0b3JzICsgJyAnICsgY29udGV4dFNlbGVjdG9yO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgc2VsZWN0b3IgYXMgYW4gYW5jZXN0b3Igb2YgdGhlIHByZXZpb3VzIHNlbGVjdG9yc1xuICAgICAgICAgICAgY29tYmluZWRbbGVuZ3RoICsgaV0gPSBjb250ZXh0U2VsZWN0b3IgKyAnICcgKyBwcmV2aW91c1NlbGVjdG9ycztcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV3IHNlbGVjdG9yIHRvIGFjdCBvbiB0aGUgc2FtZSBlbGVtZW50IGFzIHRoZSBwcmV2aW91cyBzZWxlY3RvcnNcbiAgICAgICAgICAgIGNvbWJpbmVkW2ldID0gY29udGV4dFNlbGVjdG9yICsgcHJldmlvdXNTZWxlY3RvcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmluYWxseSBjb25uZWN0IHRoZSBzZWxlY3RvciB0byB0aGUgYGhvc3RNYXJrZXJgczogZWl0aGVyIGFjdGluZyBkaXJlY3RseSBvbiB0aGUgaG9zdFxuICAgIC8vIChBPGhvc3RNYXJrZXI+KSBvciBhcyBhbiBhbmNlc3RvciAoQSA8aG9zdE1hcmtlcj4pLlxuICAgIHJldHVybiBjb21iaW5lZFxuICAgICAgICAubWFwKHMgPT4gb3RoZXJTZWxlY3RvcnNIYXNIb3N0ID9cbiAgICAgICAgYCR7c30ke290aGVyU2VsZWN0b3JzfWAgOlxuICAgICAgICBgJHtzfSR7aG9zdE1hcmtlcn0ke290aGVyU2VsZWN0b3JzfSwgJHtzfSAke2hvc3RNYXJrZXJ9JHtvdGhlclNlbGVjdG9yc31gKVxuICAgICAgICAuam9pbignLCcpO1xufVxuLyoqXG4gKiBNdXRhdGUgdGhlIGdpdmVuIGBncm91cHNgIGFycmF5IHNvIHRoYXQgdGhlcmUgYXJlIGBtdWx0aXBsZXNgIGNsb25lcyBvZiB0aGUgb3JpZ2luYWwgYXJyYXlcbiAqIHN0b3JlZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBgcmVwZWF0R3JvdXBzKFthLCBiXSwgMylgIHdpbGwgcmVzdWx0IGluIGBbYSwgYiwgYSwgYiwgYSwgYl1gIC0gYnV0IGltcG9ydGFudGx5IHRoZVxuICogbmV3bHkgYWRkZWQgZ3JvdXBzIHdpbGwgYmUgY2xvbmVzIG9mIHRoZSBvcmlnaW5hbC5cbiAqXG4gKiBAcGFyYW0gZ3JvdXBzIEFuIGFycmF5IG9mIGdyb3VwcyBvZiBzdHJpbmdzIHRoYXQgd2lsbCBiZSByZXBlYXRlZC4gVGhpcyBhcnJheSBpcyBtdXRhdGVkXG4gKiAgICAgaW4tcGxhY2UuXG4gKiBAcGFyYW0gbXVsdGlwbGVzIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGN1cnJlbnQgZ3JvdXBzIHNob3VsZCBhcHBlYXIuXG4gKi9cbmZ1bmN0aW9uIHJlcGVhdEdyb3Vwcyhncm91cHMsIG11bHRpcGxlcykge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdyb3Vwcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtdWx0aXBsZXM7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBncm91cHNbaiArIChpICogbGVuZ3RoKV0gPSBncm91cHNbal0uc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBQYXJzZXMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgc3R5bGUgYW5kIGNvbnZlcnRzIGl0IGludG8gb2JqZWN0IGxpdGVyYWwuXG4gKlxuICogQHBhcmFtIHZhbHVlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBzdHlsZSBhcyB1c2VkIGluIHRoZSBgc3R5bGVgIGF0dHJpYnV0ZSBpbiBIVE1MLlxuICogICBFeGFtcGxlOiBgY29sb3I6IHJlZDsgaGVpZ2h0OiBhdXRvYC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0eWxlIHByb3BlcnR5IG5hbWUgYW5kIHZhbHVlIHBhaXJzLCBlLmcuIGBbJ2NvbG9yJywgJ3JlZCcsICdoZWlnaHQnLFxuICogJ2F1dG8nXWBcbiAqL1xuZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcbiAgICAvLyB3ZSB1c2UgYSBzdHJpbmcgYXJyYXkgaGVyZSBpbnN0ZWFkIG9mIGEgc3RyaW5nIG1hcFxuICAgIC8vIGJlY2F1c2UgYSBzdHJpbmctbWFwIGlzIG5vdCBndWFyYW50ZWVkIHRvIHJldGFpbiB0aGVcbiAgICAvLyBvcmRlciBvZiB0aGUgZW50cmllcyB3aGVyZWFzIGEgc3RyaW5nIGFycmF5IGNhbiBiZVxuICAgIC8vIGNvbnN0cnVjdGVkIGluIGEgW2tleSwgdmFsdWUsIGtleSwgdmFsdWVdIGZvcm1hdC5cbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHBhcmVuRGVwdGggPSAwO1xuICAgIGxldCBxdW90ZSA9IDAgLyogQ2hhci5RdW90ZU5vbmUgKi87XG4gICAgbGV0IHZhbHVlU3RhcnQgPSAwO1xuICAgIGxldCBwcm9wU3RhcnQgPSAwO1xuICAgIGxldCBjdXJyZW50UHJvcCA9IG51bGw7XG4gICAgbGV0IHZhbHVlSGFzUXVvdGVzID0gZmFsc2U7XG4gICAgd2hpbGUgKGkgPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgNDAgLyogQ2hhci5PcGVuUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgcGFyZW5EZXB0aCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MSAvKiBDaGFyLkNsb3NlUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgcGFyZW5EZXB0aC0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOSAvKiBDaGFyLlF1b3RlU2luZ2xlICovOlxuICAgICAgICAgICAgICAgIC8vIHZhbHVlU3RhcnQgbmVlZHMgdG8gYmUgdGhlcmUgc2luY2UgcHJvcCB2YWx1ZXMgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBoYXZlIHF1b3RlcyBpbiBDU1NcbiAgICAgICAgICAgICAgICB2YWx1ZUhhc1F1b3RlcyA9IHZhbHVlSGFzUXVvdGVzIHx8IHZhbHVlU3RhcnQgPiAwO1xuICAgICAgICAgICAgICAgIGlmIChxdW90ZSA9PT0gMCAvKiBDaGFyLlF1b3RlTm9uZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IDM5IC8qIENoYXIuUXVvdGVTaW5nbGUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1b3RlID09PSAzOSAvKiBDaGFyLlF1b3RlU2luZ2xlICovICYmIHZhbHVlLmNoYXJDb2RlQXQoaSAtIDEpICE9PSA5MiAvKiBDaGFyLkJhY2tTbGFzaCAqLykge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IDAgLyogQ2hhci5RdW90ZU5vbmUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzNCAvKiBDaGFyLlF1b3RlRG91YmxlICovOlxuICAgICAgICAgICAgICAgIC8vIHNhbWUgbG9naWMgYXMgYWJvdmVcbiAgICAgICAgICAgICAgICB2YWx1ZUhhc1F1b3RlcyA9IHZhbHVlSGFzUXVvdGVzIHx8IHZhbHVlU3RhcnQgPiAwO1xuICAgICAgICAgICAgICAgIGlmIChxdW90ZSA9PT0gMCAvKiBDaGFyLlF1b3RlTm9uZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IDM0IC8qIENoYXIuUXVvdGVEb3VibGUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1b3RlID09PSAzNCAvKiBDaGFyLlF1b3RlRG91YmxlICovICYmIHZhbHVlLmNoYXJDb2RlQXQoaSAtIDEpICE9PSA5MiAvKiBDaGFyLkJhY2tTbGFzaCAqLykge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IDAgLyogQ2hhci5RdW90ZU5vbmUgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OCAvKiBDaGFyLkNvbG9uICovOlxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb3AgJiYgcGFyZW5EZXB0aCA9PT0gMCAmJiBxdW90ZSA9PT0gMCAvKiBDaGFyLlF1b3RlTm9uZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcCA9IGh5cGhlbmF0ZSh2YWx1ZS5zdWJzdHJpbmcocHJvcFN0YXJ0LCBpIC0gMSkudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OSAvKiBDaGFyLlNlbWljb2xvbiAqLzpcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb3AgJiYgdmFsdWVTdGFydCA+IDAgJiYgcGFyZW5EZXB0aCA9PT0gMCAmJiBxdW90ZSA9PT0gMCAvKiBDaGFyLlF1b3RlTm9uZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHlsZVZhbCA9IHZhbHVlLnN1YnN0cmluZyh2YWx1ZVN0YXJ0LCBpIC0gMSkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChjdXJyZW50UHJvcCwgdmFsdWVIYXNRdW90ZXMgPyBzdHJpcFVubmVjZXNzYXJ5UXVvdGVzKHN0eWxlVmFsKSA6IHN0eWxlVmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVIYXNRdW90ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQcm9wICYmIHZhbHVlU3RhcnQpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVWYWwgPSB2YWx1ZS5zbGljZSh2YWx1ZVN0YXJ0KS50cmltKCk7XG4gICAgICAgIHN0eWxlcy5wdXNoKGN1cnJlbnRQcm9wLCB2YWx1ZUhhc1F1b3RlcyA/IHN0cmlwVW5uZWNlc3NhcnlRdW90ZXMoc3R5bGVWYWwpIDogc3R5bGVWYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xufVxuZnVuY3Rpb24gc3RyaXBVbm5lY2Vzc2FyeVF1b3Rlcyh2YWx1ZSkge1xuICAgIGNvbnN0IHFTID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBxRSA9IHZhbHVlLmNoYXJDb2RlQXQodmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgaWYgKHFTID09IHFFICYmIChxUyA9PSAzOSAvKiBDaGFyLlF1b3RlU2luZ2xlICovIHx8IHFTID09IDM0IC8qIENoYXIuUXVvdGVEb3VibGUgKi8pKSB7XG4gICAgICAgIGNvbnN0IHRlbXBWYWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHVzaW5nIGEgbXVsdGktcXVvdGVkIHN0cmluZyB0aGF0IHdhcyBqdXN0IGNob21wZWRcbiAgICAgICAgLy8gKGUuZy4gYGZvbnQtZmFtaWx5OiBcIlZlcmRhbmFcIiwgXCJzYW5zLXNlcmlmXCJgKVxuICAgICAgICBpZiAodGVtcFZhbHVlLmluZGV4T2YoJ1xcJycpID09IC0xICYmIHRlbXBWYWx1ZS5pbmRleE9mKCdcIicpID09IC0xKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRlbXBWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBoeXBoZW5hdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgLnJlcGxhY2UoL1thLXpdW0EtWl0vZywgdiA9PiB7XG4gICAgICAgIHJldHVybiB2LmNoYXJBdCgwKSArICctJyArIHYuY2hhckF0KDEpO1xuICAgIH0pXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5jb25zdCBJTVBPUlRBTlRfRkxBRyA9ICchaW1wb3J0YW50Jztcbi8qKlxuICogTWluaW11bSBhbW91bnQgb2YgYmluZGluZyBzbG90cyByZXF1aXJlZCBpbiB0aGUgcnVudGltZSBmb3Igc3R5bGUvY2xhc3MgYmluZGluZ3MuXG4gKlxuICogU3R5bGluZyBpbiBBbmd1bGFyIHVzZXMgdXAgdHdvIHNsb3RzIGluIHRoZSBydW50aW1lIExWaWV3L1REYXRhIGRhdGEgc3RydWN0dXJlcyB0b1xuICogcmVjb3JkIGJpbmRpbmcgZGF0YSwgcHJvcGVydHkgaW5mb3JtYXRpb24gYW5kIG1ldGFkYXRhLlxuICpcbiAqIFdoZW4gYSBiaW5kaW5nIGlzIHJlZ2lzdGVyZWQgaXQgd2lsbCBwbGFjZSB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uIGluIHRoZSBgTFZpZXdgOlxuICpcbiAqIHNsb3QgMSkgYmluZGluZyB2YWx1ZVxuICogc2xvdCAyKSBjYWNoZWQgdmFsdWUgKGFsbCBvdGhlciB2YWx1ZXMgY29sbGVjdGVkIGJlZm9yZSBpdCBpbiBzdHJpbmcgZm9ybSlcbiAqXG4gKiBXaGVuIGEgYmluZGluZyBpcyByZWdpc3RlcmVkIGl0IHdpbGwgcGxhY2UgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgYFREYXRhYDpcbiAqXG4gKiBzbG90IDEpIHByb3AgbmFtZVxuICogc2xvdCAyKSBiaW5kaW5nIGluZGV4IHRoYXQgcG9pbnRzIHRvIHRoZSBwcmV2aW91cyBzdHlsZS9jbGFzcyBiaW5kaW5nIChhbmQgc29tZSBleHRyYSBjb25maWdcbiAqIHZhbHVlcylcbiAqXG4gKiBMZXQncyBpbWFnaW5lIHdlIGhhdmUgYSBiaW5kaW5nIHRoYXQgbG9va3MgbGlrZSBzbzpcbiAqXG4gKiBgYGBcbiAqIDxkaXYgW3N0eWxlLndpZHRoXT1cInhcIiBbc3R5bGUuaGVpZ2h0XT1cInlcIj5cbiAqIGBgYFxuICpcbiAqIE91ciBgTFZpZXdgIGFuZCBgVERhdGFgIGRhdGEtc3RydWN0dXJlcyBsb29rIGxpa2Ugc286XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogTFZpZXcgPSBbXG4gKiAgIC8vIC4uLlxuICogICB4LCAvLyB2YWx1ZSBvZiB4XG4gKiAgIFwid2lkdGg6IHhcIixcbiAqXG4gKiAgIHksIC8vIHZhbHVlIG9mIHlcbiAqICAgXCJ3aWR0aDogeDsgaGVpZ2h0OiB5XCIsXG4gKiAgIC8vIC4uLlxuICogXTtcbiAqXG4gKiBURGF0YSA9IFtcbiAqICAgLy8gLi4uXG4gKiAgIFwid2lkdGhcIiwgLy8gYmluZGluZyBzbG90IDIwXG4gKiAgIDAsXG4gKlxuICogICBcImhlaWdodFwiLFxuICogICAyMCxcbiAqICAgLy8gLi4uXG4gKiBdO1xuICogYGBgXG4gKlxuICogKi9cbmNvbnN0IE1JTl9TVFlMSU5HX0JJTkRJTkdfU0xPVFNfUkVRVUlSRUQgPSAyO1xuLyoqXG4gKiBQcm9kdWNlcyBjcmVhdGlvbi91cGRhdGUgaW5zdHJ1Y3Rpb25zIGZvciBhbGwgc3R5bGluZyBiaW5kaW5ncyAoY2xhc3MgYW5kIHN0eWxlKVxuICpcbiAqIEl0IGFsc28gcHJvZHVjZXMgdGhlIGNyZWF0aW9uIGluc3RydWN0aW9uIHRvIHJlZ2lzdGVyIGFsbCBpbml0aWFsIHN0eWxpbmcgdmFsdWVzXG4gKiAod2hpY2ggYXJlIGFsbCB0aGUgc3RhdGljIGNsYXNzPVwiLi4uXCIgYW5kIHN0eWxlPVwiLi4uXCIgYXR0cmlidXRlIHZhbHVlcyB0aGF0IGV4aXN0XG4gKiBvbiBhbiBlbGVtZW50IHdpdGhpbiBhIHRlbXBsYXRlKS5cbiAqXG4gKiBUaGUgYnVpbGRlciBjbGFzcyBiZWxvdyBoYW5kbGVzIHByb2R1Y2luZyBpbnN0cnVjdGlvbnMgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gKlxuICogLSBTdGF0aWMgc3R5bGUvY2xhc3MgYXR0cmlidXRlcyAoc3R5bGU9XCIuLi5cIiBhbmQgY2xhc3M9XCIuLi5cIilcbiAqIC0gRHluYW1pYyBzdHlsZS9jbGFzcyBtYXAgYmluZGluZ3MgKFtzdHlsZV09XCJtYXBcIiBhbmQgW2NsYXNzXT1cIm1hcHxzdHJpbmdcIilcbiAqIC0gRHluYW1pYyBzdHlsZS9jbGFzcyBwcm9wZXJ0eSBiaW5kaW5ncyAoW3N0eWxlLnByb3BdPVwiZXhwXCIgYW5kIFtjbGFzcy5uYW1lXT1cImV4cFwiKVxuICpcbiAqIER1ZSB0byB0aGUgY29tcGxleCByZWxhdGlvbnNoaXAgb2YgYWxsIG9mIHRoZXNlIGNhc2VzLCB0aGUgaW5zdHJ1Y3Rpb25zIGdlbmVyYXRlZFxuICogZm9yIHRoZXNlIGF0dHJpYnV0ZXMvcHJvcGVydGllcy9iaW5kaW5ncyBtdXN0IGJlIGRvbmUgc28gaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFRoZVxuICogb3JkZXIgd2hpY2ggdGhlc2UgbXVzdCBiZSBnZW5lcmF0ZWQgaXMgYXMgZm9sbG93czpcbiAqXG4gKiBpZiAoY3JlYXRlTW9kZSkge1xuICogICBzdHlsaW5nKC4uLilcbiAqIH1cbiAqIGlmICh1cGRhdGVNb2RlKSB7XG4gKiAgIHN0eWxlTWFwKC4uLilcbiAqICAgY2xhc3NNYXAoLi4uKVxuICogICBzdHlsZVByb3AoLi4uKVxuICogICBjbGFzc1Byb3AoLi4uKVxuICogfVxuICpcbiAqIFRoZSBjcmVhdGlvbi91cGRhdGUgbWV0aG9kcyB3aXRoaW4gdGhlIGJ1aWxkZXIgY2xhc3MgcHJvZHVjZSB0aGVzZSBpbnN0cnVjdGlvbnMuXG4gKi9cbmNsYXNzIFN0eWxpbmdCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfZGlyZWN0aXZlRXhwcikge1xuICAgICAgICB0aGlzLl9kaXJlY3RpdmVFeHByID0gX2RpcmVjdGl2ZUV4cHI7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGVyZSBhcmUgYW55IHN0YXRpYyBzdHlsaW5nIHZhbHVlcyBwcmVzZW50ICovXG4gICAgICAgIHRoaXMuX2hhc0luaXRpYWxWYWx1ZXMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBXaGV0aGVyIG9yIG5vdCB0aGVyZSBhcmUgYW55IHN0eWxpbmcgYmluZGluZ3MgcHJlc2VudFxuICAgICAgICAgKiAgKGkuZS4gYFtzdHlsZV1gLCBgW2NsYXNzXWAsIGBbc3R5bGUucHJvcF1gIG9yIGBbY2xhc3MubmFtZV1gKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNCaW5kaW5ncyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0JpbmRpbmdzV2l0aFBpcGVzID0gZmFsc2U7XG4gICAgICAgIC8qKiB0aGUgaW5wdXQgZm9yIFtjbGFzc10gKGlmIGl0IGV4aXN0cykgKi9cbiAgICAgICAgdGhpcy5fY2xhc3NNYXBJbnB1dCA9IG51bGw7XG4gICAgICAgIC8qKiB0aGUgaW5wdXQgZm9yIFtzdHlsZV0gKGlmIGl0IGV4aXN0cykgKi9cbiAgICAgICAgdGhpcy5fc3R5bGVNYXBJbnB1dCA9IG51bGw7XG4gICAgICAgIC8qKiBhbiBhcnJheSBvZiBlYWNoIFtzdHlsZS5wcm9wXSBpbnB1dCAqL1xuICAgICAgICB0aGlzLl9zaW5nbGVTdHlsZUlucHV0cyA9IG51bGw7XG4gICAgICAgIC8qKiBhbiBhcnJheSBvZiBlYWNoIFtjbGFzcy5uYW1lXSBpbnB1dCAqL1xuICAgICAgICB0aGlzLl9zaW5nbGVDbGFzc0lucHV0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RTdHlsaW5nSW5wdXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9maXJzdFN0eWxpbmdJbnB1dCA9IG51bGw7XG4gICAgICAgIC8vIG1hcHMgYXJlIHVzZWQgaW5zdGVhZCBvZiBoYXNoIG1hcHMgYmVjYXVzZSBhIE1hcCB3aWxsXG4gICAgICAgIC8vIHJldGFpbiB0aGUgb3JkZXJpbmcgb2YgdGhlIGtleXNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIGVhY2ggc3R5bGUgYmluZGluZyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgICAgICogKGUuZy4gYDxkaXYgW3N0eWxlLndpZHRoXT1cIndcIiBbc3R5bGUuaGVpZ2h0XT1cImhcIj5gIGltcGxpZXNcbiAgICAgICAgICogdGhhdCBgd2lkdGg9MGAgYW5kIGBoZWlnaHQ9MWApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdHlsZXNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIGxvY2F0aW9uIG9mIGVhY2ggY2xhc3MgYmluZGluZyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgICAgICogKGUuZy4gYDxkaXYgW2NsYXNzLmJpZ109XCJiXCIgW2NsYXNzLmhpZGRlbl09XCJoXCI+YCBpbXBsaWVzXG4gICAgICAgICAqIHRoYXQgYGJpZz0wYCBhbmQgYGhpZGRlbj0xYClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NsYXNzZXNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbFN0eWxlVmFsdWVzID0gW107XG4gICAgICAgIHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBnaXZlbiBpbnB1dCB0byB0aGUgc3R5bGluZyBidWlsZGVyIHRvIGJlIGxhdGVyIHVzZWQgd2hlbiBwcm9kdWNpbmcgQU9UIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGUgY29kZSBiZWxvdyB3aWxsIG9ubHkgYWNjZXB0IHRoZSBpbnB1dCBpZiBpdCBpcyBzb21laG93IHRpZWQgdG8gc3R5bGluZyAod2hldGhlciBpdCBiZVxuICAgICAqIHN0eWxlL2NsYXNzIGJpbmRpbmdzIG9yIHN0YXRpYyBzdHlsZS9jbGFzcyBhdHRyaWJ1dGVzKS5cbiAgICAgKi9cbiAgICByZWdpc3RlckJvdW5kSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgLy8gW2F0dHIuc3R5bGVdIG9yIFthdHRyLmNsYXNzXSBhcmUgc2tpcHBlZCBpbiB0aGUgY29kZSBiZWxvdyxcbiAgICAgICAgLy8gdGhleSBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXMgc3R5bGluZy1iYXNlZCBiaW5kaW5ncyBzaW5jZVxuICAgICAgICAvLyB0aGV5IGFyZSBpbnRlbmRlZCB0byBiZSB3cml0dGVuIGRpcmVjdGx5IHRvIHRoZSBhdHRyIGFuZFxuICAgICAgICAvLyB3aWxsIHRoZXJlZm9yZSBza2lwIGFsbCBzdHlsZS9jbGFzcyByZXNvbHV0aW9uIHRoYXQgaXMgcHJlc2VudFxuICAgICAgICAvLyB3aXRoIHN0eWxlPVwiXCIsIFtzdHlsZV09XCJcIiBhbmQgW3N0eWxlLnByb3BdPVwiXCIsIGNsYXNzPVwiXCIsXG4gICAgICAgIC8vIFtjbGFzcy5wcm9wXT1cIlwiLiBbY2xhc3NdPVwiXCIgYXNzaWdubWVudHNcbiAgICAgICAgbGV0IGJpbmRpbmcgPSBudWxsO1xuICAgICAgICBsZXQgbmFtZSA9IGlucHV0Lm5hbWU7XG4gICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwIC8qIEJpbmRpbmdUeXBlLlByb3BlcnR5ICovOlxuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVySW5wdXRCYXNlZE9uTmFtZShuYW1lLCBpbnB1dC52YWx1ZSwgaW5wdXQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMgLyogQmluZGluZ1R5cGUuU3R5bGUgKi86XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMucmVnaXN0ZXJTdHlsZUlucHV0KG5hbWUsIGZhbHNlLCBpbnB1dC52YWx1ZSwgaW5wdXQuc291cmNlU3BhbiwgaW5wdXQudW5pdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogQmluZGluZ1R5cGUuQ2xhc3MgKi86XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMucmVnaXN0ZXJDbGFzc0lucHV0KG5hbWUsIGZhbHNlLCBpbnB1dC52YWx1ZSwgaW5wdXQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbmRpbmcgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIHJlZ2lzdGVySW5wdXRCYXNlZE9uTmFtZShuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGxldCBiaW5kaW5nID0gbnVsbDtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmFtZS5zdWJzdHJpbmcoMCwgNik7XG4gICAgICAgIGNvbnN0IGlzU3R5bGUgPSBuYW1lID09PSAnc3R5bGUnIHx8IHByZWZpeCA9PT0gJ3N0eWxlLicgfHwgcHJlZml4ID09PSAnc3R5bGUhJztcbiAgICAgICAgY29uc3QgaXNDbGFzcyA9ICFpc1N0eWxlICYmIChuYW1lID09PSAnY2xhc3MnIHx8IHByZWZpeCA9PT0gJ2NsYXNzLicgfHwgcHJlZml4ID09PSAnY2xhc3MhJyk7XG4gICAgICAgIGlmIChpc1N0eWxlIHx8IGlzQ2xhc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTWFwQmFzZWQgPSBuYW1lLmNoYXJBdCg1KSAhPT0gJy4nOyAvLyBzdHlsZS5wcm9wIG9yIGNsYXNzLnByb3AgbWFrZXMgdGhpcyBhIG5vXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IG5hbWUuc2xpY2UoaXNNYXBCYXNlZCA/IDUgOiA2KTsgLy8gdGhlIGRvdCBleHBsYWlucyB3aHkgdGhlcmUncyBhICsxXG4gICAgICAgICAgICBpZiAoaXNTdHlsZSkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVyU3R5bGVJbnB1dChwcm9wZXJ0eSwgaXNNYXBCYXNlZCwgZXhwcmVzc2lvbiwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nID0gdGhpcy5yZWdpc3RlckNsYXNzSW5wdXQocHJvcGVydHksIGlzTWFwQmFzZWQsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nO1xuICAgIH1cbiAgICByZWdpc3RlclN0eWxlSW5wdXQobmFtZSwgaXNNYXBCYXNlZCwgdmFsdWUsIHNvdXJjZVNwYW4sIHN1ZmZpeCkge1xuICAgICAgICBpZiAoaXNFbXB0eUV4cHJlc3Npb24odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDU1MgY3VzdG9tIHByb3BlcnRpZXMgYXJlIGNhc2Utc2Vuc2l0aXZlIHNvIHdlIHNob3VsZG4ndCBub3JtYWxpemUgdGhlbS5cbiAgICAgICAgLy8gU2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXZhcmlhYmxlcy0xLyNkZWZpbmluZy12YXJpYWJsZXNcbiAgICAgICAgaWYgKCFpc0Nzc0N1c3RvbVByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lID0gaHlwaGVuYXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydHksIGhhc092ZXJyaWRlRmxhZywgc3VmZml4OiBiaW5kaW5nU3VmZml4IH0gPSBwYXJzZVByb3BlcnR5KG5hbWUpO1xuICAgICAgICBzdWZmaXggPSB0eXBlb2Ygc3VmZml4ID09PSAnc3RyaW5nJyAmJiBzdWZmaXgubGVuZ3RoICE9PSAwID8gc3VmZml4IDogYmluZGluZ1N1ZmZpeDtcbiAgICAgICAgY29uc3QgZW50cnkgPSB7IG5hbWU6IHByb3BlcnR5LCBzdWZmaXg6IHN1ZmZpeCwgdmFsdWUsIHNvdXJjZVNwYW4sIGhhc092ZXJyaWRlRmxhZyB9O1xuICAgICAgICBpZiAoaXNNYXBCYXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVNYXBJbnB1dCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHRoaXMuX3NpbmdsZVN0eWxlSW5wdXRzID0gdGhpcy5fc2luZ2xlU3R5bGVJbnB1dHMgfHwgW10pLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgcmVnaXN0ZXJJbnRvTWFwKHRoaXMuX3N0eWxlc0luZGV4LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFN0eWxpbmdJbnB1dCA9IGVudHJ5O1xuICAgICAgICB0aGlzLl9maXJzdFN0eWxpbmdJbnB1dCA9IHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0IHx8IGVudHJ5O1xuICAgICAgICB0aGlzLl9jaGVja0ZvclBpcGVzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gICAgcmVnaXN0ZXJDbGFzc0lucHV0KG5hbWUsIGlzTWFwQmFzZWQsIHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGlmIChpc0VtcHR5RXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydHksIGhhc092ZXJyaWRlRmxhZyB9ID0gcGFyc2VQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgY29uc3QgZW50cnkgPSB7IG5hbWU6IHByb3BlcnR5LCB2YWx1ZSwgc291cmNlU3BhbiwgaGFzT3ZlcnJpZGVGbGFnLCBzdWZmaXg6IG51bGwgfTtcbiAgICAgICAgaWYgKGlzTWFwQmFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsYXNzTWFwSW5wdXQgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh0aGlzLl9zaW5nbGVDbGFzc0lucHV0cyA9IHRoaXMuX3NpbmdsZUNsYXNzSW5wdXRzIHx8IFtdKS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIHJlZ2lzdGVySW50b01hcCh0aGlzLl9jbGFzc2VzSW5kZXgsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U3R5bGluZ0lucHV0ID0gZW50cnk7XG4gICAgICAgIHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0ID0gdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQgfHwgZW50cnk7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9yUGlwZXModmFsdWUpO1xuICAgICAgICB0aGlzLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgICBfY2hlY2tGb3JQaXBlcyh2YWx1ZSkge1xuICAgICAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgQVNUV2l0aFNvdXJjZSkgJiYgKHZhbHVlLmFzdCBpbnN0YW5jZW9mIEJpbmRpbmdQaXBlKSkge1xuICAgICAgICAgICAgdGhpcy5oYXNCaW5kaW5nc1dpdGhQaXBlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBlbGVtZW50J3Mgc3RhdGljIHN0eWxlIHN0cmluZyB2YWx1ZSB0byB0aGUgYnVpbGRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB0aGUgc3R5bGUgc3RyaW5nIChlLmcuIGB3aWR0aDoxMDBweDsgaGVpZ2h0OjIwMHB4O2ApXG4gICAgICovXG4gICAgcmVnaXN0ZXJTdHlsZUF0dHIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbFN0eWxlVmFsdWVzID0gcGFyc2UodmFsdWUpO1xuICAgICAgICB0aGlzLl9oYXNJbml0aWFsVmFsdWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBlbGVtZW50J3Mgc3RhdGljIGNsYXNzIHN0cmluZyB2YWx1ZSB0byB0aGUgYnVpbGRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB0aGUgY2xhc3NOYW1lIHN0cmluZyAoZS5nLiBgZGlzYWJsZWQgZ29sZCB6b29tYClcbiAgICAgKi9cbiAgICByZWdpc3RlckNsYXNzQXR0cih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NWYWx1ZXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvZyk7XG4gICAgICAgIHRoaXMuX2hhc0luaXRpYWxWYWx1ZXMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGFsbCBzdHlsaW5nLXJlbGF0ZWQgZXhwcmVzc2lvbnMgdG8gdGhlIHByb3ZpZGVkIGF0dHJzIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGF0dHJzIGFuIGV4aXN0aW5nIGFycmF5IHdoZXJlIGVhY2ggb2YgdGhlIHN0eWxpbmcgZXhwcmVzc2lvbnNcbiAgICAgKiB3aWxsIGJlIGluc2VydGVkIGludG8uXG4gICAgICovXG4gICAgcG9wdWxhdGVJbml0aWFsU3R5bGluZ0F0dHJzKGF0dHJzKSB7XG4gICAgICAgIC8vIFtDTEFTU19NQVJLRVIsICdmb28nLCAnYmFyJywgJ2JheicgLi4uXVxuICAgICAgICBpZiAodGhpcy5faW5pdGlhbENsYXNzVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXR0cnMucHVzaChsaXRlcmFsKDEgLyogQXR0cmlidXRlTWFya2VyLkNsYXNzZXMgKi8pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5pdGlhbENsYXNzVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXR0cnMucHVzaChsaXRlcmFsKHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFtTVFlMRV9NQVJLRVIsICd3aWR0aCcsICcyMDBweCcsICdoZWlnaHQnLCAnMTAwcHgnLCAuLi5dXG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRycy5wdXNoKGxpdGVyYWwoMiAvKiBBdHRyaWJ1dGVNYXJrZXIuU3R5bGVzICovKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2gobGl0ZXJhbCh0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXNbaV0pLCBsaXRlcmFsKHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlc1tpICsgMV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gaW5zdHJ1Y3Rpb24gd2l0aCBhbGwgdGhlIGV4cHJlc3Npb25zIGFuZCBwYXJhbWV0ZXJzIGZvciBgZWxlbWVudEhvc3RBdHRyc2AuXG4gICAgICpcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gZ2VuZXJhdGlvbiBjb2RlIGJlbG93IGlzIHVzZWQgZm9yIHByb2R1Y2luZyB0aGUgQU9UIHN0YXRlbWVudCBjb2RlIHdoaWNoIGlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIHJlZ2lzdGVyaW5nIGluaXRpYWwgc3R5bGVzICh3aXRoaW4gYSBkaXJlY3RpdmUgaG9zdEJpbmRpbmdzJyBjcmVhdGlvbiBibG9jayksXG4gICAgICogYXMgd2VsbCBhcyBhbnkgb2YgdGhlIHByb3ZpZGVkIGF0dHJpYnV0ZSB2YWx1ZXMsIHRvIHRoZSBkaXJlY3RpdmUgaG9zdCBlbGVtZW50LlxuICAgICAqL1xuICAgIGFzc2lnbkhvc3RBdHRycyhhdHRycywgZGVmaW5pdGlvbk1hcCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aXZlRXhwciAmJiAoYXR0cnMubGVuZ3RoIHx8IHRoaXMuX2hhc0luaXRpYWxWYWx1ZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVsYXRlSW5pdGlhbFN0eWxpbmdBdHRycyhhdHRycyk7XG4gICAgICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaG9zdEF0dHJzJywgbGl0ZXJhbEFycihhdHRycykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiBpbnN0cnVjdGlvbiB3aXRoIGFsbCB0aGUgZXhwcmVzc2lvbnMgYW5kIHBhcmFtZXRlcnMgZm9yIGBjbGFzc01hcGAuXG4gICAgICpcbiAgICAgKiBUaGUgaW5zdHJ1Y3Rpb24gZGF0YSB3aWxsIGNvbnRhaW4gYWxsIGV4cHJlc3Npb25zIGZvciBgY2xhc3NNYXBgIHRvIGZ1bmN0aW9uXG4gICAgICogd2hpY2ggaW5jbHVkZXMgdGhlIGBbY2xhc3NdYCBleHByZXNzaW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgICBidWlsZENsYXNzTWFwSW5zdHJ1Y3Rpb24odmFsdWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NsYXNzTWFwSW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZE1hcEJhc2VkSW5zdHJ1Y3Rpb24odmFsdWVDb252ZXJ0ZXIsIHRydWUsIHRoaXMuX2NsYXNzTWFwSW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gaW5zdHJ1Y3Rpb24gd2l0aCBhbGwgdGhlIGV4cHJlc3Npb25zIGFuZCBwYXJhbWV0ZXJzIGZvciBgc3R5bGVNYXBgLlxuICAgICAqXG4gICAgICogVGhlIGluc3RydWN0aW9uIGRhdGEgd2lsbCBjb250YWluIGFsbCBleHByZXNzaW9ucyBmb3IgYHN0eWxlTWFwYCB0byBmdW5jdGlvblxuICAgICAqIHdoaWNoIGluY2x1ZGVzIHRoZSBgW3N0eWxlXWAgZXhwcmVzc2lvbiBwYXJhbXMuXG4gICAgICovXG4gICAgYnVpbGRTdHlsZU1hcEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZU1hcElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRNYXBCYXNlZEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyLCBmYWxzZSwgdGhpcy5fc3R5bGVNYXBJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9idWlsZE1hcEJhc2VkSW5zdHJ1Y3Rpb24odmFsdWVDb252ZXJ0ZXIsIGlzQ2xhc3NCYXNlZCwgc3R5bGluZ0lucHV0KSB7XG4gICAgICAgIC8vIGVhY2ggc3R5bGluZyBiaW5kaW5nIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgTFZpZXdcbiAgICAgICAgLy8gbWFwLWJhc2VkIGJpbmRpbmdzIGFsbG9jYXRlIHR3byBzbG90czogb25lIGZvciB0aGVcbiAgICAgICAgLy8gcHJldmlvdXMgYmluZGluZyB2YWx1ZSBhbmQgYW5vdGhlciBmb3IgdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIGNsYXNzTmFtZSBvciBzdHlsZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICAgIGxldCB0b3RhbEJpbmRpbmdTbG90c1JlcXVpcmVkID0gTUlOX1NUWUxJTkdfQklORElOR19TTE9UU19SRVFVSVJFRDtcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIG11c3QgYmUgb3V0c2lkZSBvZiB0aGUgdXBkYXRlIGJsb2NrIHNvIHRoYXQgdGhleSBjYW5cbiAgICAgICAgLy8gYmUgZXZhbHVhdGVkICh0aGUgQVNUIHZpc2l0IGNhbGwpIGR1cmluZyBjcmVhdGlvbiB0aW1lIHNvIHRoYXQgYW55XG4gICAgICAgIC8vIHBpcGVzIGNhbiBiZSBwaWNrZWQgdXAgaW4gdGltZSBiZWZvcmUgdGhlIHRlbXBsYXRlIGlzIGJ1aWx0XG4gICAgICAgIGNvbnN0IG1hcFZhbHVlID0gc3R5bGluZ0lucHV0LnZhbHVlLnZpc2l0KHZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgbGV0IHJlZmVyZW5jZTtcbiAgICAgICAgaWYgKG1hcFZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCArPSBtYXBWYWx1ZS5leHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICByZWZlcmVuY2UgPSBpc0NsYXNzQmFzZWQgPyBnZXRDbGFzc01hcEludGVycG9sYXRpb25FeHByZXNzaW9uKG1hcFZhbHVlKSA6XG4gICAgICAgICAgICAgICAgZ2V0U3R5bGVNYXBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihtYXBWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWZlcmVuY2UgPSBpc0NsYXNzQmFzZWQgPyBJZGVudGlmaWVycy5jbGFzc01hcCA6IElkZW50aWZpZXJzLnN0eWxlTWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgICAgICBjYWxsczogW3tcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VTcGFuOiBzdHlsaW5nSW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgYWxsb2NhdGVCaW5kaW5nU2xvdHM6IHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogKGNvbnZlcnRGbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udmVydFJlc3VsdCA9IGNvbnZlcnRGbihtYXBWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBBcnJheS5pc0FycmF5KGNvbnZlcnRSZXN1bHQpID8gY29udmVydFJlc3VsdCA6IFtjb252ZXJ0UmVzdWx0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYnVpbGRTaW5nbGVJbnB1dHMocmVmZXJlbmNlLCBpbnB1dHMsIHZhbHVlQ29udmVydGVyLCBnZXRJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbkZuLCBpc0NsYXNzQmFzZWQpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzSW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaW5zdHJ1Y3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZS52aXNpdCh2YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlRm9yQ2FsbCA9IHJlZmVyZW5jZTtcbiAgICAgICAgICAgIC8vIGVhY2ggc3R5bGluZyBiaW5kaW5nIHZhbHVlIGlzIHN0b3JlZCBpbiB0aGUgTFZpZXdcbiAgICAgICAgICAgIC8vIGJ1dCB0aGVyZSBhcmUgdHdvIHZhbHVlcyBzdG9yZWQgZm9yIGVhY2ggYmluZGluZzpcbiAgICAgICAgICAgIC8vICAgMSkgdGhlIHZhbHVlIGl0c2VsZlxuICAgICAgICAgICAgLy8gICAyKSBhbiBpbnRlcm1lZGlhdGUgdmFsdWUgKGNvbmNhdGVuYXRpb24gb2Ygc3R5bGUgdXAgdG8gdGhpcyBwb2ludCkuXG4gICAgICAgICAgICAvLyAgICAgIFdlIG5lZWQgdG8gc3RvcmUgdGhlIGludGVybWVkaWF0ZSB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0IGFsbG9jYXRlXG4gICAgICAgICAgICAvLyAgICAgIHRoZSBzdHJpbmdzIG9uIGVhY2ggQ0QuXG4gICAgICAgICAgICBsZXQgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCA9IE1JTl9TVFlMSU5HX0JJTkRJTkdfU0xPVFNfUkVRVUlSRUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCArPSB2YWx1ZS5leHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGdldEludGVycG9sYXRpb25FeHByZXNzaW9uRm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlRm9yQ2FsbCA9IGdldEludGVycG9sYXRpb25FeHByZXNzaW9uRm4odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSB7XG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZUJpbmRpbmdTbG90czogdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCxcbiAgICAgICAgICAgICAgICBzdXBwb3J0c0ludGVycG9sYXRpb246ICEhZ2V0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb25GbixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IChjb252ZXJ0Rm4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyYW1zID0+IHN0eWxpbmdQcm9wKHByb3BOYW1lLCB2YWx1ZSwgc3VmZml4KVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gobGl0ZXJhbChpbnB1dC5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRSZXN1bHQgPSBjb252ZXJ0Rm4odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb252ZXJ0UmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goLi4uY29udmVydFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChjb252ZXJ0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBbc3R5bGUucHJvcF0gYmluZGluZ3MgbWF5IHVzZSBzdWZmaXggdmFsdWVzIChlLmcuIHB4LCBlbSwgZXRjLi4uKSwgdGhlcmVmb3JlLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGF0IGlzIGRldGVjdGVkIHRoZW4gd2UgbmVlZCB0byBwYXNzIHRoYXQgaW4gYXMgYW4gb3B0aW9uYWwgcGFyYW0uXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNDbGFzc0Jhc2VkICYmIGlucHV0LnN1ZmZpeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gobGl0ZXJhbChpbnB1dC5zdWZmaXgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBJZiB3ZSBlbmRlZCB1cCBnZW5lcmF0aW5nIGEgY2FsbCB0byB0aGUgc2FtZSBpbnN0cnVjdGlvbiBhcyB0aGUgcHJldmlvdXMgc3R5bGluZyBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gd2UgY2FuIGNoYWluIHRoZSBjYWxscyB0b2dldGhlciBzYWZlbHkgdG8gc2F2ZSBzb21lIGJ5dGVzLCBvdGhlcndpc2Ugd2UgaGF2ZSB0byBnZW5lcmF0ZVxuICAgICAgICAgICAgLy8gYSBzZXBhcmF0ZSBpbnN0cnVjdGlvbiBjYWxsLiBUaGlzIGlzIHByaW1hcmlseSBhIGNvbmNlcm4gd2l0aCBpbnRlcnBvbGF0aW9uIGluc3RydWN0aW9uc1xuICAgICAgICAgICAgLy8gd2hlcmUgd2UgbWF5IHN0YXJ0IG9mZiB3aXRoIG9uZSBgcmVmZXJlbmNlYCwgYnV0IGVuZCB1cCB1c2luZyBhbm90aGVyIGJhc2VkIG9uIHRoZVxuICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGludGVycG9sYXRpb25zLlxuICAgICAgICAgICAgaWYgKHByZXZpb3VzSW5zdHJ1Y3Rpb24gJiYgcHJldmlvdXNJbnN0cnVjdGlvbi5yZWZlcmVuY2UgPT09IHJlZmVyZW5jZUZvckNhbGwpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0luc3RydWN0aW9uLmNhbGxzLnB1c2goY2FsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCh7IHJlZmVyZW5jZTogcmVmZXJlbmNlRm9yQ2FsbCwgY2FsbHM6IFtjYWxsXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gICAgfVxuICAgIF9idWlsZENsYXNzSW5wdXRzKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaW5nbGVDbGFzc0lucHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2luZ2xlSW5wdXRzKElkZW50aWZpZXJzLmNsYXNzUHJvcCwgdGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMsIHZhbHVlQ29udmVydGVyLCBudWxsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIF9idWlsZFN0eWxlSW5wdXRzKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaW5nbGVTdHlsZUlucHV0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkU2luZ2xlSW5wdXRzKElkZW50aWZpZXJzLnN0eWxlUHJvcCwgdGhpcy5fc2luZ2xlU3R5bGVJbnB1dHMsIHZhbHVlQ29udmVydGVyLCBnZXRTdHlsZVByb3BJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhbGwgaW5zdHJ1Y3Rpb25zIHdoaWNoIGNvbnRhaW4gdGhlIGV4cHJlc3Npb25zIHRoYXQgd2lsbCBiZSBwbGFjZWRcbiAgICAgKiBpbnRvIHRoZSB1cGRhdGUgYmxvY2sgb2YgYSB0ZW1wbGF0ZSBmdW5jdGlvbiBvciBhIGRpcmVjdGl2ZSBob3N0QmluZGluZ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgYnVpbGRVcGRhdGVMZXZlbEluc3RydWN0aW9ucyh2YWx1ZUNvbnZlcnRlcikge1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQmluZGluZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlTWFwSW5zdHJ1Y3Rpb24gPSB0aGlzLmJ1aWxkU3R5bGVNYXBJbnN0cnVjdGlvbih2YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVNYXBJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKHN0eWxlTWFwSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xhc3NNYXBJbnN0cnVjdGlvbiA9IHRoaXMuYnVpbGRDbGFzc01hcEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgIGlmIChjbGFzc01hcEluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goY2xhc3NNYXBJbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCguLi50aGlzLl9idWlsZFN0eWxlSW5wdXRzKHZhbHVlQ29udmVydGVyKSk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCguLi50aGlzLl9idWlsZENsYXNzSW5wdXRzKHZhbHVlQ29udmVydGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICB9XG59XG5mdW5jdGlvbiByZWdpc3RlckludG9NYXAobWFwLCBrZXkpIHtcbiAgICBpZiAoIW1hcC5oYXMoa2V5KSkge1xuICAgICAgICBtYXAuc2V0KGtleSwgbWFwLnNpemUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUHJvcGVydHkobmFtZSkge1xuICAgIGxldCBoYXNPdmVycmlkZUZsYWcgPSBmYWxzZTtcbiAgICBjb25zdCBvdmVycmlkZUluZGV4ID0gbmFtZS5pbmRleE9mKElNUE9SVEFOVF9GTEFHKTtcbiAgICBpZiAob3ZlcnJpZGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbmFtZSA9IG92ZXJyaWRlSW5kZXggPiAwID8gbmFtZS5zdWJzdHJpbmcoMCwgb3ZlcnJpZGVJbmRleCkgOiAnJztcbiAgICAgICAgaGFzT3ZlcnJpZGVGbGFnID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHN1ZmZpeCA9IG51bGw7XG4gICAgbGV0IHByb3BlcnR5ID0gbmFtZTtcbiAgICBjb25zdCB1bml0SW5kZXggPSBuYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKHVuaXRJbmRleCA+IDApIHtcbiAgICAgICAgc3VmZml4ID0gbmFtZS5zbGljZSh1bml0SW5kZXggKyAxKTtcbiAgICAgICAgcHJvcGVydHkgPSBuYW1lLnN1YnN0cmluZygwLCB1bml0SW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4geyBwcm9wZXJ0eSwgc3VmZml4LCBoYXNPdmVycmlkZUZsYWcgfTtcbn1cbi8qKlxuICogR2V0cyB0aGUgaW5zdHJ1Y3Rpb24gdG8gZ2VuZXJhdGUgZm9yIGFuIGludGVycG9sYXRlZCBjbGFzcyBtYXAuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRDbGFzc01hcEludGVycG9sYXRpb25FeHByZXNzaW9uKGludGVycG9sYXRpb24pIHtcbiAgICBzd2l0Y2ggKGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5jbGFzc01hcDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTI7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlMztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU1O1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU2O1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU4O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGVWO1xuICAgIH1cbn1cbi8qKlxuICogR2V0cyB0aGUgaW5zdHJ1Y3Rpb24gdG8gZ2VuZXJhdGUgZm9yIGFuIGludGVycG9sYXRlZCBzdHlsZSBtYXAuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZU1hcEludGVycG9sYXRpb25FeHByZXNzaW9uKGludGVycG9sYXRpb24pIHtcbiAgICBzd2l0Y2ggKGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZU1hcDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTI7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlMztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGU1O1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGU2O1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGU4O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGVWO1xuICAgIH1cbn1cbi8qKlxuICogR2V0cyB0aGUgaW5zdHJ1Y3Rpb24gdG8gZ2VuZXJhdGUgZm9yIGFuIGludGVycG9sYXRlZCBzdHlsZSBwcm9wLlxuICogQHBhcmFtIGludGVycG9sYXRpb24gQW4gSW50ZXJwb2xhdGlvbiBBU1RcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVQcm9wSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlUHJvcDtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlMTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlMjtcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlMztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNDtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTU7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU2O1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNztcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTg7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGVWO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgcHJvcGVydHkgbmFtZSBpcyBhIGN1c3RvbSBDU1MgcHJvcGVydHkuXG4gKiBTZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtdmFyaWFibGVzLTFcbiAqL1xuZnVuY3Rpb24gaXNDc3NDdXN0b21Qcm9wZXJ0eShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aCgnLS0nKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlFeHByZXNzaW9uKGFzdCkge1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBBU1RXaXRoU291cmNlKSB7XG4gICAgICAgIGFzdCA9IGFzdC5hc3Q7XG4gICAgfVxuICAgIHJldHVybiBhc3QgaW5zdGFuY2VvZiBFbXB0eUV4cHI7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZXhwb3J0cy5Ub2tlblR5cGUgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKFRva2VuVHlwZSkge1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJDaGFyYWN0ZXJcIl0gPSAwXSA9IFwiQ2hhcmFjdGVyXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIklkZW50aWZpZXJcIl0gPSAxXSA9IFwiSWRlbnRpZmllclwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJQcml2YXRlSWRlbnRpZmllclwiXSA9IDJdID0gXCJQcml2YXRlSWRlbnRpZmllclwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJLZXl3b3JkXCJdID0gM10gPSBcIktleXdvcmRcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiU3RyaW5nXCJdID0gNF0gPSBcIlN0cmluZ1wiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJPcGVyYXRvclwiXSA9IDVdID0gXCJPcGVyYXRvclwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJOdW1iZXJcIl0gPSA2XSA9IFwiTnVtYmVyXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIkVycm9yXCJdID0gN10gPSBcIkVycm9yXCI7XG59KShleHBvcnRzLlRva2VuVHlwZSB8fCAoZXhwb3J0cy5Ub2tlblR5cGUgPSB7fSkpO1xuY29uc3QgS0VZV09SRFMgPSBbJ3ZhcicsICdsZXQnLCAnYXMnLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJywgJ3RoaXMnXTtcbmNsYXNzIExleGVyIHtcbiAgICB0b2tlbml6ZSh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIodGV4dCk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICB3aGlsZSAodG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuY2xhc3MgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCBlbmQsIHR5cGUsIG51bVZhbHVlLCBzdHJWYWx1ZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm51bVZhbHVlID0gbnVtVmFsdWU7XG4gICAgICAgIHRoaXMuc3RyVmFsdWUgPSBzdHJWYWx1ZTtcbiAgICB9XG4gICAgaXNDaGFyYWN0ZXIoY29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLkNoYXJhY3RlciAmJiB0aGlzLm51bVZhbHVlID09IGNvZGU7XG4gICAgfVxuICAgIGlzTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk51bWJlcjtcbiAgICB9XG4gICAgaXNTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuU3RyaW5nO1xuICAgIH1cbiAgICBpc09wZXJhdG9yKG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3IgJiYgdGhpcy5zdHJWYWx1ZSA9PSBvcGVyYXRvcjtcbiAgICB9XG4gICAgaXNJZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLklkZW50aWZpZXI7XG4gICAgfVxuICAgIGlzUHJpdmF0ZUlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuUHJpdmF0ZUlkZW50aWZpZXI7XG4gICAgfVxuICAgIGlzS2V5d29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkO1xuICAgIH1cbiAgICBpc0tleXdvcmRMZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdsZXQnO1xuICAgIH1cbiAgICBpc0tleXdvcmRBcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2FzJztcbiAgICB9XG4gICAgaXNLZXl3b3JkTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ251bGwnO1xuICAgIH1cbiAgICBpc0tleXdvcmRVbmRlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBpc0tleXdvcmRUcnVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndHJ1ZSc7XG4gICAgfVxuICAgIGlzS2V5d29yZEZhbHNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAnZmFsc2UnO1xuICAgIH1cbiAgICBpc0tleXdvcmRUaGlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndGhpcyc7XG4gICAgfVxuICAgIGlzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuRXJyb3I7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk51bWJlciA/IHRoaXMubnVtVmFsdWUgOiAtMTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLkNoYXJhY3RlcjpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZDpcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3I6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLlByaXZhdGVJZGVudGlmaWVyOlxuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRva2VuVHlwZS5TdHJpbmc6XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVG9rZW5UeXBlLkVycm9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0clZhbHVlO1xuICAgICAgICAgICAgY2FzZSBleHBvcnRzLlRva2VuVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBuZXdDaGFyYWN0ZXJUb2tlbihpbmRleCwgZW5kLCBjb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZW5kLCBleHBvcnRzLlRva2VuVHlwZS5DaGFyYWN0ZXIsIGNvZGUsIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpO1xufVxuZnVuY3Rpb24gbmV3SWRlbnRpZmllclRva2VuKGluZGV4LCBlbmQsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBlbmQsIGV4cG9ydHMuVG9rZW5UeXBlLklkZW50aWZpZXIsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3UHJpdmF0ZUlkZW50aWZpZXJUb2tlbihpbmRleCwgZW5kLCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZW5kLCBleHBvcnRzLlRva2VuVHlwZS5Qcml2YXRlSWRlbnRpZmllciwgMCwgdGV4dCk7XG59XG5mdW5jdGlvbiBuZXdLZXl3b3JkVG9rZW4oaW5kZXgsIGVuZCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGVuZCwgZXhwb3J0cy5Ub2tlblR5cGUuS2V5d29yZCwgMCwgdGV4dCk7XG59XG5mdW5jdGlvbiBuZXdPcGVyYXRvclRva2VuKGluZGV4LCBlbmQsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBlbmQsIGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yLCAwLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIG5ld1N0cmluZ1Rva2VuKGluZGV4LCBlbmQsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBlbmQsIGV4cG9ydHMuVG9rZW5UeXBlLlN0cmluZywgMCwgdGV4dCk7XG59XG5mdW5jdGlvbiBuZXdOdW1iZXJUb2tlbihpbmRleCwgZW5kLCBuKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZW5kLCBleHBvcnRzLlRva2VuVHlwZS5OdW1iZXIsIG4sICcnKTtcbn1cbmZ1bmN0aW9uIG5ld0Vycm9yVG9rZW4oaW5kZXgsIGVuZCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGVuZCwgZXhwb3J0cy5Ub2tlblR5cGUuRXJyb3IsIDAsIG1lc3NhZ2UpO1xufVxuY29uc3QgRU9GID0gbmV3IFRva2VuKC0xLCAtMSwgZXhwb3J0cy5Ub2tlblR5cGUuQ2hhcmFjdGVyLCAwLCAnJyk7XG5jbGFzcyBfU2Nhbm5lciB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnBlZWsgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgdGhpcy5wZWVrID0gKyt0aGlzLmluZGV4ID49IHRoaXMubGVuZ3RoID8gJEVPRiA6IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgc2NhblRva2VuKCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQsIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBsZXQgcGVlayA9IHRoaXMucGVlaywgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UuXG4gICAgICAgIHdoaWxlIChwZWVrIDw9ICRTUEFDRSkge1xuICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGVlayA9ICRFT0Y7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWVrID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZWVrID0gcGVlaztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgaWRlbnRpZmllcnMgYW5kIG51bWJlcnMuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChwZWVrKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChpc0RpZ2l0KHBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWJlcihpbmRleCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIHN3aXRjaCAocGVlaykge1xuICAgICAgICAgICAgY2FzZSAkUEVSSU9EOlxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RpZ2l0KHRoaXMucGVlaykgPyB0aGlzLnNjYW5OdW1iZXIoc3RhcnQpIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsICRQRVJJT0QpO1xuICAgICAgICAgICAgY2FzZSAkTFBBUkVOOlxuICAgICAgICAgICAgY2FzZSAkUlBBUkVOOlxuICAgICAgICAgICAgY2FzZSAkTEJSQUNFOlxuICAgICAgICAgICAgY2FzZSAkUkJSQUNFOlxuICAgICAgICAgICAgY2FzZSAkTEJSQUNLRVQ6XG4gICAgICAgICAgICBjYXNlICRSQlJBQ0tFVDpcbiAgICAgICAgICAgIGNhc2UgJENPTU1BOlxuICAgICAgICAgICAgY2FzZSAkQ09MT046XG4gICAgICAgICAgICBjYXNlICRTRU1JQ09MT046XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNoYXJhY3RlcihzdGFydCwgcGVlayk7XG4gICAgICAgICAgICBjYXNlICRTUTpcbiAgICAgICAgICAgIGNhc2UgJERROlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJEhBU0g6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblByaXZhdGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBjYXNlICRQTFVTOlxuICAgICAgICAgICAgY2FzZSAkTUlOVVM6XG4gICAgICAgICAgICBjYXNlICRTVEFSOlxuICAgICAgICAgICAgY2FzZSAkU0xBU0g6XG4gICAgICAgICAgICBjYXNlICRQRVJDRU5UOlxuICAgICAgICAgICAgY2FzZSAkQ0FSRVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspKTtcbiAgICAgICAgICAgIGNhc2UgJFFVRVNUSU9OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5RdWVzdGlvbihzdGFydCk7XG4gICAgICAgICAgICBjYXNlICRMVDpcbiAgICAgICAgICAgIGNhc2UgJEdUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlayksICRFUSwgJz0nKTtcbiAgICAgICAgICAgIGNhc2UgJEJBTkc6XG4gICAgICAgICAgICBjYXNlICRFUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9JywgJEVRLCAnPScpO1xuICAgICAgICAgICAgY2FzZSAkQU1QRVJTQU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICcmJywgJEFNUEVSU0FORCwgJyYnKTtcbiAgICAgICAgICAgIGNhc2UgJEJBUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnfCcsICRCQVIsICd8Jyk7XG4gICAgICAgICAgICBjYXNlICROQlNQOlxuICAgICAgICAgICAgICAgIHdoaWxlIChpc1doaXRlc3BhY2UodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBbJHtTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspfV1gLCAwKTtcbiAgICB9XG4gICAgc2NhbkNoYXJhY3RlcihzdGFydCwgY29kZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCBjb2RlKTtcbiAgICB9XG4gICAgc2Nhbk9wZXJhdG9yKHN0YXJ0LCBzdHIpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCBzdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZSBhIDIvMyBjaGFyIGxvbmcgb3BlcmF0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBpbmRleCBpbiB0aGUgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSBvbmUgZmlyc3Qgc3ltYm9sIChhbHdheXMgcGFydCBvZiB0aGUgb3BlcmF0b3IpXG4gICAgICogQHBhcmFtIHR3b0NvZGUgY29kZSBwb2ludCBmb3IgdGhlIHNlY29uZCBzeW1ib2xcbiAgICAgKiBAcGFyYW0gdHdvIHNlY29uZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gdGhlIHNlY29uZCBjb2RlIHBvaW50IG1hdGNoZXMpXG4gICAgICogQHBhcmFtIHRocmVlQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgdGhpcmQgc3ltYm9sXG4gICAgICogQHBhcmFtIHRocmVlIHRoaXJkIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiBwcm92aWRlZCBhbmQgbWF0Y2hlcyBzb3VyY2UgZXhwcmVzc2lvbilcbiAgICAgKi9cbiAgICBzY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBvbmUsIHR3b0NvZGUsIHR3bywgdGhyZWVDb2RlLCB0aHJlZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgbGV0IHN0ciA9IG9uZTtcbiAgICAgICAgaWYgKHRoaXMucGVlayA9PSB0d29Db2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHN0ciArPSB0d287XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVlQ29kZSAhPSBudWxsICYmIHRoaXMucGVlayA9PSB0aHJlZUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgc3RyICs9IHRocmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCBzdHIpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgd2hpbGUgKGlzSWRlbnRpZmllclBhcnQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiBLRVlXT1JEUy5pbmRleE9mKHN0cikgPiAtMSA/IG5ld0tleXdvcmRUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgc3RyKSA6XG4gICAgICAgICAgICBuZXdJZGVudGlmaWVyVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIHN0cik7XG4gICAgfVxuICAgIC8qKiBTY2FucyBhbiBFQ01BU2NyaXB0IHByaXZhdGUgaWRlbnRpZmllci4gKi9cbiAgICBzY2FuUHJpdmF0ZUlkZW50aWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIFsjXScsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXNJZGVudGlmaWVyUGFydCh0aGlzLnBlZWspKVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJOYW1lID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gbmV3UHJpdmF0ZUlkZW50aWZpZXJUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgaWRlbnRpZmllck5hbWUpO1xuICAgIH1cbiAgICBzY2FuTnVtYmVyKHN0YXJ0KSB7XG4gICAgICAgIGxldCBzaW1wbGUgPSAodGhpcy5pbmRleCA9PT0gc3RhcnQpO1xuICAgICAgICBsZXQgaGFzU2VwYXJhdG9ycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIGRpZ2l0LlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGlzRGlnaXQodGhpcy5wZWVrKSkgO1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09PSAkXykge1xuICAgICAgICAgICAgICAgIC8vIFNlcGFyYXRvcnMgYXJlIG9ubHkgdmFsaWQgd2hlbiB0aGV5J3JlIHN1cnJvdW5kZWQgYnkgZGlnaXRzLiBFLmcuIGAxXzBfMWAgaXNcbiAgICAgICAgICAgICAgICAvLyB2YWxpZCB3aGlsZSBgXzEwMWAgYW5kIGAxMDFfYCBhcmUgbm90LiBUaGUgc2VwYXJhdG9yIGNhbid0IGJlIG5leHQgdG8gdGhlIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAvLyBwb2ludCBvciBhbm90aGVyIHNlcGFyYXRvciBlaXRoZXIuIE5vdGUgdGhhdCBpdCdzIHVubGlrZWx5IHRoYXQgd2UnbGwgaGl0IGEgY2FzZSB3aGVyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSB1bmRlcnNjb3JlIGlzIGF0IHRoZSBzdGFydCwgYmVjYXVzZSB0aGF0J3MgYSB2YWxpZCBpZGVudGlmaWVyIGFuZCBpdCB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAgICAgICAgIC8vIHVwIGVhcmxpZXIgaW4gdGhlIHBhcnNpbmcuIFdlIHZhbGlkYXRlIGZvciBpdCBhbnl3YXkganVzdCBpbiBjYXNlLlxuICAgICAgICAgICAgICAgIGlmICghaXNEaWdpdCh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCAtIDEpKSB8fFxuICAgICAgICAgICAgICAgICAgICAhaXNEaWdpdCh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignSW52YWxpZCBudW1lcmljIHNlcGFyYXRvcicsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNTZXBhcmF0b3JzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVlayA9PT0gJFBFUklPRCkge1xuICAgICAgICAgICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFeHBvbmVudFN0YXJ0KHRoaXMucGVlaykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFeHBvbmVudFNpZ24odGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RpZ2l0KHRoaXMucGVlaykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdJbnZhbGlkIGV4cG9uZW50JywgLTEpO1xuICAgICAgICAgICAgICAgIHNpbXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICBpZiAoaGFzU2VwYXJhdG9ycykge1xuICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2ltcGxlID8gcGFyc2VJbnRBdXRvUmFkaXgoc3RyKSA6IHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgICAgcmV0dXJuIG5ld051bWJlclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIHNjYW5TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgY29uc3QgcXVvdGUgPSB0aGlzLnBlZWs7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIGluaXRpYWwgcXVvdGUuXG4gICAgICAgIGxldCBidWZmZXIgPSAnJztcbiAgICAgICAgbGV0IG1hcmtlciA9IHRoaXMuaW5kZXg7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVlayAhPSBxdW90ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVlayA9PSAkQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyICs9IGlucHV0LnN1YnN0cmluZyhtYXJrZXIsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGxldCB1bmVzY2FwZWRDb2RlO1xuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIFRTMi4xLWludHJvZHVjZWQgdHlwZSBzdHJpY3RuZXNzXG4gICAgICAgICAgICAgICAgdGhpcy5wZWVrID0gdGhpcy5wZWVrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJHUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gNCBjaGFyYWN0ZXIgaGV4IGNvZGUgZm9yIHVuaWNvZGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZXggPSBpbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eWzAtOWEtZl0rJC9pLnRlc3QoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYEludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1JHtoZXh9XWAsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHVuZXNjYXBlKHRoaXMucGVlayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmVzY2FwZWRDb2RlKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRFT0YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignVW50ZXJtaW5hdGVkIHF1b3RlJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0ID0gaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIHRlcm1pbmF0aW5nIHF1b3RlLlxuICAgICAgICByZXR1cm4gbmV3U3RyaW5nVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIGJ1ZmZlciArIGxhc3QpO1xuICAgIH1cbiAgICBzY2FuUXVlc3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGxldCBzdHIgPSAnPyc7XG4gICAgICAgIC8vIEVpdGhlciBgYSA/PyBiYCBvciAnYT8uYicuXG4gICAgICAgIGlmICh0aGlzLnBlZWsgPT09ICRRVUVTVElPTiB8fCB0aGlzLnBlZWsgPT09ICRQRVJJT0QpIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnBlZWsgPT09ICRQRVJJT0QgPyAnLicgOiAnPyc7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgc3RyKTtcbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZSwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5ld0Vycm9yVG9rZW4ocG9zaXRpb24sIHRoaXMuaW5kZXgsIGBMZXhlciBFcnJvcjogJHttZXNzYWdlfSBhdCBjb2x1bW4gJHtwb3NpdGlvbn0gaW4gZXhwcmVzc2lvbiBbJHt0aGlzLmlucHV0fV1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuICgkYSA8PSBjb2RlICYmIGNvZGUgPD0gJHopIHx8ICgkQSA8PSBjb2RlICYmIGNvZGUgPD0gJFopIHx8XG4gICAgICAgIChjb2RlID09ICRfKSB8fCAoY29kZSA9PSAkJCk7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzY2FubmVyID0gbmV3IF9TY2FubmVyKGlucHV0KTtcbiAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB3aGlsZSAoc2Nhbm5lci5wZWVrICE9PSAkRU9GKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gaXNBc2NpaUxldHRlcihjb2RlKSB8fCBpc0RpZ2l0KGNvZGUpIHx8IChjb2RlID09ICRfKSB8fFxuICAgICAgICAoY29kZSA9PSAkJCk7XG59XG5mdW5jdGlvbiBpc0V4cG9uZW50U3RhcnQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09ICRlIHx8IGNvZGUgPT0gJEU7XG59XG5mdW5jdGlvbiBpc0V4cG9uZW50U2lnbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJE1JTlVTIHx8IGNvZGUgPT0gJFBMVVM7XG59XG5mdW5jdGlvbiB1bmVzY2FwZShjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgJG46XG4gICAgICAgICAgICByZXR1cm4gJExGO1xuICAgICAgICBjYXNlICRmOlxuICAgICAgICAgICAgcmV0dXJuICRGRjtcbiAgICAgICAgY2FzZSAkcjpcbiAgICAgICAgICAgIHJldHVybiAkQ1I7XG4gICAgICAgIGNhc2UgJHQ6XG4gICAgICAgICAgICByZXR1cm4gJFRBQjtcbiAgICAgICAgY2FzZSAkdjpcbiAgICAgICAgICAgIHJldHVybiAkVlRBQjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW50QXV0b1JhZGl4KHRleHQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZUludCh0ZXh0KTtcbiAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgU3BsaXRJbnRlcnBvbGF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cykge1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XG4gICAgfVxufVxuY2xhc3MgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlQmluZGluZ3MsIHdhcm5pbmdzLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUJpbmRpbmdzID0gdGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG59XG5jbGFzcyBQYXJzZXIkMSB7XG4gICAgY29uc3RydWN0b3IoX2xleGVyKSB7XG4gICAgICAgIHRoaXMuX2xleGVyID0gX2xleGVyO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICBwYXJzZUFjdGlvbihpbnB1dCwgaXNBc3NpZ25tZW50RXZlbnQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tOb0ludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgY29uc3Qgc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGlucHV0KTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICBsZXQgZmxhZ3MgPSAxIC8qIFBhcnNlRmxhZ3MuQWN0aW9uICovO1xuICAgICAgICBpZiAoaXNBc3NpZ25tZW50RXZlbnQpIHtcbiAgICAgICAgICAgIGZsYWdzIHw9IDIgLyogUGFyc2VGbGFncy5Bc3NpZ25tZW50RXZlbnQgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0b2tlbnMsIGZsYWdzLCB0aGlzLmVycm9ycywgMCkucGFyc2VDaGFpbigpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICAgIHBhcnNlQmluZGluZyhpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRykge1xuICAgICAgICBjb25zdCBhc3QgPSB0aGlzLl9wYXJzZUJpbmRpbmdBc3QoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShhc3QsIGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRoaXMuZXJyb3JzKTtcbiAgICB9XG4gICAgY2hlY2tTaW1wbGVFeHByZXNzaW9uKGFzdCkge1xuICAgICAgICBjb25zdCBjaGVja2VyID0gbmV3IFNpbXBsZUV4cHJlc3Npb25DaGVja2VyKCk7XG4gICAgICAgIGFzdC52aXNpdChjaGVja2VyKTtcbiAgICAgICAgcmV0dXJuIGNoZWNrZXIuZXJyb3JzO1xuICAgIH1cbiAgICBwYXJzZVNpbXBsZUJpbmRpbmcoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcpIHtcbiAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSB0aGlzLmNoZWNrU2ltcGxlRXhwcmVzc2lvbihhc3QpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBIb3N0IGJpbmRpbmcgZXhwcmVzc2lvbiBjYW5ub3QgY29udGFpbiAke2Vycm9ycy5qb2luKCcgJyl9YCwgaW5wdXQsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICAgIF9yZXBvcnRFcnJvcihtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIGlucHV0LCBlcnJMb2NhdGlvbiwgY3R4TG9jYXRpb24pKTtcbiAgICB9XG4gICAgX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHNvdXJjZVRvTGV4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdG9rZW5zLCAwIC8qIFBhcnNlRmxhZ3MuTm9uZSAqLywgdGhpcy5lcnJvcnMsIDApXG4gICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWNyb3N5bnRheCB0ZW1wbGF0ZSBleHByZXNzaW9uIGFuZCByZXR1cm4gYSBsaXN0IG9mIGJpbmRpbmdzIG9yXG4gICAgICogcGFyc2luZyBlcnJvcnMgaW4gY2FzZSB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsXG4gICAgICogYGBgXG4gICAgICogICA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+XG4gICAgICogICAgICAgICBeICAgICAgXiBhYnNvbHV0ZVZhbHVlT2Zmc2V0IGZvciBgdGVtcGxhdGVWYWx1ZWBcbiAgICAgKiAgICAgICAgIGFic29sdXRlS2V5T2Zmc2V0IGZvciBgdGVtcGxhdGVLZXlgXG4gICAgICogYGBgXG4gICAgICogY29udGFpbnMgdGhyZWUgYmluZGluZ3M6XG4gICAgICogMS4gbmdGb3IgLT4gbnVsbFxuICAgICAqIDIuIGl0ZW0gLT4gTmdGb3JPZkNvbnRleHQuJGltcGxpY2l0XG4gICAgICogMy4gbmdGb3JPZiAtPiBpdGVtc1xuICAgICAqXG4gICAgICogVGhpcyBpcyBhcHBhcmVudCBmcm9tIHRoZSBkZS1zdWdhcmVkIHRlbXBsYXRlOlxuICAgICAqIGBgYFxuICAgICAqICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cIml0ZW1zXCI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVLZXkgbmFtZSBvZiBkaXJlY3RpdmUsIHdpdGhvdXQgdGhlICogcHJlZml4LiBGb3IgZXhhbXBsZTogbmdJZiwgbmdGb3JcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVWYWx1ZSBSSFMgb2YgdGhlIG1pY3Jvc3ludGF4IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZVVybCB0ZW1wbGF0ZSBmaWxlbmFtZSBpZiBpdCdzIGV4dGVybmFsLCBjb21wb25lbnQgZmlsZW5hbWUgaWYgaXQncyBpbmxpbmVcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVLZXlPZmZzZXQgc3RhcnQgb2YgdGhlIGB0ZW1wbGF0ZUtleWBcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVWYWx1ZU9mZnNldCBzdGFydCBvZiB0aGUgYHRlbXBsYXRlVmFsdWVgXG4gICAgICovXG4gICAgcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRlbXBsYXRlS2V5LCB0ZW1wbGF0ZVZhbHVlLCB0ZW1wbGF0ZVVybCwgYWJzb2x1dGVLZXlPZmZzZXQsIGFic29sdXRlVmFsdWVPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUodGVtcGxhdGVWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfUGFyc2VBU1QodGVtcGxhdGVWYWx1ZSwgdGVtcGxhdGVVcmwsIGFic29sdXRlVmFsdWVPZmZzZXQsIHRva2VucywgMCAvKiBQYXJzZUZsYWdzLk5vbmUgKi8sIHRoaXMuZXJyb3JzLCAwIC8qIHJlbGF0aXZlIG9mZnNldCAqLyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHtcbiAgICAgICAgICAgIHNvdXJjZTogdGVtcGxhdGVLZXksXG4gICAgICAgICAgICBzcGFuOiBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGFic29sdXRlS2V5T2Zmc2V0LCBhYnNvbHV0ZUtleU9mZnNldCArIHRlbXBsYXRlS2V5Lmxlbmd0aCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZUludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGVkVG9rZW5zLCBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRykge1xuICAgICAgICBjb25zdCB7IHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzIH0gPSB0aGlzLnNwbGl0SW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRlZFRva2VucywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbk5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25UZXh0ID0gZXhwcmVzc2lvbnNbaV0udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhleHByZXNzaW9uVGV4dCk7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShzb3VyY2VUb0xleCk7XG4gICAgICAgICAgICBjb25zdCBhc3QgPSBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRva2VucywgMCAvKiBQYXJzZUZsYWdzLk5vbmUgKi8sIHRoaXMuZXJyb3JzLCBvZmZzZXRzW2ldKVxuICAgICAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgICAgICAgICBleHByZXNzaW9uTm9kZXMucHVzaChhc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUludGVycG9sYXRpb25Bc3Qoc3RyaW5ncy5tYXAocyA9PiBzLnRleHQpLCBleHByZXNzaW9uTm9kZXMsIGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGBwYXJzZUludGVycG9sYXRpb25gLCBidXQgdHJlYXRzIHRoZSBwcm92aWRlZCBzdHJpbmcgYXMgYSBzaW5nbGUgZXhwcmVzc2lvblxuICAgICAqIGVsZW1lbnQgdGhhdCB3b3VsZCBub3JtYWxseSBhcHBlYXIgd2l0aGluIHRoZSBpbnRlcnBvbGF0aW9uIHByZWZpeCBhbmQgc3VmZml4IChge3tgIGFuZCBgfX1gKS5cbiAgICAgKiBUaGlzIGlzIHVzZWQgZm9yIHBhcnNpbmcgdGhlIHN3aXRjaCBleHByZXNzaW9uIGluIElDVXMuXG4gICAgICovXG4gICAgcGFyc2VJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uLCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlVG9MZXggPSB0aGlzLl9zdHJpcENvbW1lbnRzKGV4cHJlc3Npb24pO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShzb3VyY2VUb0xleCk7XG4gICAgICAgIGNvbnN0IGFzdCA9IG5ldyBfUGFyc2VBU1QoZXhwcmVzc2lvbiwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0b2tlbnMsIDAgLyogUGFyc2VGbGFncy5Ob25lICovLCB0aGlzLmVycm9ycywgMClcbiAgICAgICAgICAgIC5wYXJzZUNoYWluKCk7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBbJycsICcnXTsgLy8gVGhlIHByZWZpeCBhbmQgc3VmZml4IHN0cmluZ3MgYXJlIGJvdGggZW1wdHlcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW50ZXJwb2xhdGlvbkFzdChzdHJpbmdzLCBbYXN0XSwgZXhwcmVzc2lvbiwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0KTtcbiAgICB9XG4gICAgY3JlYXRlSW50ZXJwb2xhdGlvbkFzdChzdHJpbmdzLCBleHByZXNzaW9ucywgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBzcGFuID0gbmV3IFBhcnNlU3BhbigwLCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gbmV3IEludGVycG9sYXRpb24oc3Bhbiwgc3Bhbi50b0Fic29sdXRlKGFic29sdXRlT2Zmc2V0KSwgc3RyaW5ncywgZXhwcmVzc2lvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoaW50ZXJwb2xhdGlvbiwgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYSBzdHJpbmcgb2YgdGV4dCBpbnRvIFwicmF3XCIgdGV4dCBzZWdtZW50cyBhbmQgZXhwcmVzc2lvbnMgcHJlc2VudCBpbiBpbnRlcnBvbGF0aW9ucyBpblxuICAgICAqIHRoZSBzdHJpbmcuXG4gICAgICogUmV0dXJucyBgbnVsbGAgaWYgdGhlcmUgYXJlIG5vIGludGVycG9sYXRpb25zLCBvdGhlcndpc2UgYVxuICAgICAqIGBTcGxpdEludGVycG9sYXRpb25gIHdpdGggc3BsaXRzIHRoYXQgbG9vayBsaWtlXG4gICAgICogICA8cmF3IHRleHQ+IDxleHByZXNzaW9uPiA8cmF3IHRleHQ+IC4uLiA8cmF3IHRleHQ+IDxleHByZXNzaW9uPiA8cmF3IHRleHQ+XG4gICAgICovXG4gICAgc3BsaXRJbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGVkVG9rZW5zLCBpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IFtdO1xuICAgICAgICBjb25zdCBpbnB1dFRvVGVtcGxhdGVJbmRleE1hcCA9IGludGVycG9sYXRlZFRva2VucyA/IGdldEluZGV4TWFwRm9yT3JpZ2luYWxUZW1wbGF0ZShpbnRlcnBvbGF0ZWRUb2tlbnMpIDogbnVsbDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgYXRJbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICAgIGxldCBleHRlbmRMYXN0U3RyaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCB7IHN0YXJ0OiBpbnRlcnBTdGFydCwgZW5kOiBpbnRlcnBFbmQgfSA9IGludGVycG9sYXRpb25Db25maWc7XG4gICAgICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWF0SW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHVudGlsIHN0YXJ0aW5nIHt7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpO1xuICAgICAgICAgICAgICAgIGkgPSBpbnB1dC5pbmRleE9mKGludGVycFN0YXJ0LCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGlucHV0LnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKHsgdGV4dCwgc3RhcnQsIGVuZDogaSB9KTtcbiAgICAgICAgICAgICAgICBhdEludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgZnJvbSBzdGFydGluZyB7eyB0byBlbmRpbmcgfX0gd2hpbGUgaWdub3JpbmcgY29udGVudCBpbnNpZGUgcXVvdGVzLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwclN0YXJ0ID0gZnVsbFN0YXJ0ICsgaW50ZXJwU3RhcnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJFbmQgPSB0aGlzLl9nZXRJbnRlcnBvbGF0aW9uRW5kSW5kZXgoaW5wdXQsIGludGVycEVuZCwgZXhwclN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwckVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bGQgbm90IGZpbmQgdGhlIGVuZCBvZiB0aGUgaW50ZXJwb2xhdGlvbjsgZG8gbm90IHBhcnNlIGFuIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc3RlYWQgd2Ugc2hvdWxkIGV4dGVuZCB0aGUgY29udGVudCBvbiB0aGUgbGFzdCByYXcgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICBhdEludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kTGFzdFN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsRW5kID0gZXhwckVuZCArIGludGVycEVuZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGlucHV0LnN1YnN0cmluZyhleHByU3RhcnQsIGV4cHJFbmQpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoJ0JsYW5rIGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZCBpbiBpbnRlcnBvbGF0ZWQgc3RyaW5ncycsIGlucHV0LCBgYXQgY29sdW1uICR7aX0gaW5gLCBsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2goeyB0ZXh0LCBzdGFydDogZnVsbFN0YXJ0LCBlbmQ6IGZ1bGxFbmQgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRJbk9yaWdpbmFsVGVtcGxhdGUgPSAoX2EgPSBpbnB1dFRvVGVtcGxhdGVJbmRleE1hcCA9PT0gbnVsbCB8fCBpbnB1dFRvVGVtcGxhdGVJbmRleE1hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRUb1RlbXBsYXRlSW5kZXhNYXAuZ2V0KGZ1bGxTdGFydCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bGxTdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydEluT3JpZ2luYWxUZW1wbGF0ZSArIGludGVycFN0YXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpID0gZnVsbEVuZDtcbiAgICAgICAgICAgICAgICBhdEludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWF0SW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIG5vdyBhdCBhIHRleHQgc2VjdGlvbiwgYWRkIHRoZSByZW1haW5pbmcgY29udGVudCBhcyBhIHJhdyBzdHJpbmcuXG4gICAgICAgICAgICBpZiAoZXh0ZW5kTGFzdFN0cmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gc3RyaW5nc1tzdHJpbmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHBpZWNlLnRleHQgKz0gaW5wdXQuc3Vic3RyaW5nKGkpO1xuICAgICAgICAgICAgICAgIHBpZWNlLmVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaCh7IHRleHQ6IGlucHV0LnN1YnN0cmluZyhpKSwgc3RhcnQ6IGksIGVuZDogaW5wdXQubGVuZ3RoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3BsaXRJbnRlcnBvbGF0aW9uKHN0cmluZ3MsIGV4cHJlc3Npb25zLCBvZmZzZXRzKTtcbiAgICB9XG4gICAgd3JhcExpdGVyYWxQcmltaXRpdmUoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBzcGFuID0gbmV3IFBhcnNlU3BhbigwLCBpbnB1dCA9PSBudWxsID8gMCA6IGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUV2l0aFNvdXJjZShuZXcgTGl0ZXJhbFByaW1pdGl2ZShzcGFuLCBzcGFuLnRvQWJzb2x1dGUoYWJzb2x1dGVPZmZzZXQpLCBpbnB1dCksIGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRoaXMuZXJyb3JzKTtcbiAgICB9XG4gICAgX3N0cmlwQ29tbWVudHMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuX2NvbW1lbnRTdGFydChpbnB1dCk7XG4gICAgICAgIHJldHVybiBpICE9IG51bGwgPyBpbnB1dC5zdWJzdHJpbmcoMCwgaSkgOiBpbnB1dDtcbiAgICB9XG4gICAgX2NvbW1lbnRTdGFydChpbnB1dCkge1xuICAgICAgICBsZXQgb3V0ZXJRdW90ZSA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gaW5wdXQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJFNMQVNIICYmIG5leHRDaGFyID09ICRTTEFTSCAmJiBvdXRlclF1b3RlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICBpZiAob3V0ZXJRdW90ZSA9PT0gY2hhcikge1xuICAgICAgICAgICAgICAgIG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3V0ZXJRdW90ZSA9PSBudWxsICYmIGlzUXVvdGUoY2hhcikpIHtcbiAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgeyBzdGFydCwgZW5kIH0pIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGVuZEluZGV4ID0gLTE7XG4gICAgICAgIGZvciAoY29uc3QgY2hhckluZGV4IG9mIHRoaXMuX2ZvckVhY2hVbnF1b3RlZENoYXIoaW5wdXQsIDApKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChzdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IGNoYXJJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IHRoaXMuX2dldEludGVycG9sYXRpb25FbmRJbmRleChpbnB1dCwgZW5kLCBjaGFySW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRJbmRleCA+IC0xICYmIGVuZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBHb3QgaW50ZXJwb2xhdGlvbiAoJHtzdGFydH0ke2VuZH0pIHdoZXJlIGV4cHJlc3Npb24gd2FzIGV4cGVjdGVkYCwgaW5wdXQsIGBhdCBjb2x1bW4gJHtzdGFydEluZGV4fSBpbmAsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGVuZCBvZiBhbiBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb25cbiAgICAgKiB3aGlsZSBpZ25vcmluZyBjb21tZW50cyBhbmQgcXVvdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgX2dldEludGVycG9sYXRpb25FbmRJbmRleChpbnB1dCwgZXhwcmVzc2lvbkVuZCwgc3RhcnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGFySW5kZXggb2YgdGhpcy5fZm9yRWFjaFVucXVvdGVkQ2hhcihpbnB1dCwgc3RhcnQpKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aChleHByZXNzaW9uRW5kLCBjaGFySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGhpbmcgZWxzZSBpbiB0aGUgZXhwcmVzc2lvbiBtYXR0ZXJzIGFmdGVyIHdlJ3ZlXG4gICAgICAgICAgICAvLyBoaXQgYSBjb21tZW50IHNvIGxvb2sgZGlyZWN0bHkgZm9yIHRoZSBlbmQgdG9rZW4uXG4gICAgICAgICAgICBpZiAoaW5wdXQuc3RhcnRzV2l0aCgnLy8nLCBjaGFySW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LmluZGV4T2YoZXhwcmVzc2lvbkVuZCwgY2hhckluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRvciB1c2VkIHRvIGl0ZXJhdGUgb3ZlciB0aGUgY2hhcmFjdGVyIGluZGV4ZXMgb2YgYSBzdHJpbmcgdGhhdCBhcmUgb3V0c2lkZSBvZiBxdW90ZXMuXG4gICAgICogQHBhcmFtIGlucHV0IFN0cmluZyB0byBsb29wIHRocm91Z2guXG4gICAgICogQHBhcmFtIHN0YXJ0IEluZGV4IHdpdGhpbiB0aGUgc3RyaW5nIGF0IHdoaWNoIHRvIHN0YXJ0LlxuICAgICAqL1xuICAgICpfZm9yRWFjaFVucXVvdGVkQ2hhcihpbnB1dCwgc3RhcnQpIHtcbiAgICAgICAgbGV0IGN1cnJlbnRRdW90ZSA9IG51bGw7XG4gICAgICAgIGxldCBlc2NhcGVDb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBjaGFyYWN0ZXJzIGluc2lkZSBxdW90ZXMuIE5vdGUgdGhhdCB3ZSBvbmx5IGNhcmUgYWJvdXQgdGhlIG91dGVyLW1vc3RcbiAgICAgICAgICAgIC8vIHF1b3RlcyBtYXRjaGluZyB1cCBhbmQgd2UgbmVlZCB0byBhY2NvdW50IGZvciBlc2NhcGUgY2hhcmFjdGVycy5cbiAgICAgICAgICAgIGlmIChpc1F1b3RlKGlucHV0LmNoYXJDb2RlQXQoaSkpICYmIChjdXJyZW50UXVvdGUgPT09IG51bGwgfHwgY3VycmVudFF1b3RlID09PSBjaGFyKSAmJlxuICAgICAgICAgICAgICAgIGVzY2FwZUNvdW50ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdW90ZSA9IGN1cnJlbnRRdW90ZSA9PT0gbnVsbCA/IGNoYXIgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFF1b3RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVzY2FwZUNvdW50ID0gY2hhciA9PT0gJ1xcXFwnID8gZXNjYXBlQ291bnQgKyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKiBEZXNjcmliZXMgYSBzdGF0ZWZ1bCBjb250ZXh0IGFuIGV4cHJlc3Npb24gcGFyc2VyIGlzIGluLiAqL1xudmFyIFBhcnNlQ29udGV4dEZsYWdzO1xuKGZ1bmN0aW9uIChQYXJzZUNvbnRleHRGbGFncykge1xuICAgIFBhcnNlQ29udGV4dEZsYWdzW1BhcnNlQ29udGV4dEZsYWdzW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgLyoqXG4gICAgICogQSBXcml0YWJsZSBjb250ZXh0IGlzIG9uZSBpbiB3aGljaCBhIHZhbHVlIG1heSBiZSB3cml0dGVuIHRvIGFuIGx2YWx1ZS5cbiAgICAgKiBGb3IgZXhhbXBsZSwgYWZ0ZXIgd2Ugc2VlIGEgcHJvcGVydHkgYWNjZXNzLCB3ZSBtYXkgZXhwZWN0IGEgd3JpdGUgdG8gdGhlXG4gICAgICogcHJvcGVydHkgdmlhIHRoZSBcIj1cIiBvcGVyYXRvci5cbiAgICAgKiAgIHByb3BcbiAgICAgKiAgICAgICAgXiBwb3NzaWJsZSBcIj1cIiBhZnRlclxuICAgICAqL1xuICAgIFBhcnNlQ29udGV4dEZsYWdzW1BhcnNlQ29udGV4dEZsYWdzW1wiV3JpdGFibGVcIl0gPSAxXSA9IFwiV3JpdGFibGVcIjtcbn0pKFBhcnNlQ29udGV4dEZsYWdzIHx8IChQYXJzZUNvbnRleHRGbGFncyA9IHt9KSk7XG5jbGFzcyBfUGFyc2VBU1Qge1xuICAgIGNvbnN0cnVjdG9yKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRva2VucywgcGFyc2VGbGFncywgZXJyb3JzLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuYWJzb2x1dGVPZmZzZXQgPSBhYnNvbHV0ZU9mZnNldDtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMucGFyc2VGbGFncyA9IHBhcnNlRmxhZ3M7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQgPSAwO1xuICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBQYXJzZUNvbnRleHRGbGFncy5Ob25lO1xuICAgICAgICAvLyBDYWNoZSBvZiBleHByZXNzaW9uIHN0YXJ0IGFuZCBpbnB1dCBpbmRlY2VzIHRvIHRoZSBhYnNvbHV0ZSBzb3VyY2Ugc3BhbiB0aGV5IG1hcCB0bywgdXNlZCB0b1xuICAgICAgICAvLyBwcmV2ZW50IGNyZWF0aW5nIHN1cGVyZmx1b3VzIHNvdXJjZSBzcGFucyBpbiBgc291cmNlU3BhbmAuXG4gICAgICAgIC8vIEEgc2VyaWFsIG9mIHRoZSBleHByZXNzaW9uIHN0YXJ0IGFuZCBpbnB1dCBpbmRleCBpcyB1c2VkIGZvciBtYXBwaW5nIGJlY2F1c2UgYm90aCBhcmUgc3RhdGVmdWxcbiAgICAgICAgLy8gYW5kIG1heSBjaGFuZ2UgZm9yIHN1YnNlcXVlbnQgZXhwcmVzc2lvbnMgdmlzaXRlZCBieSB0aGUgcGFyc2VyLlxuICAgICAgICB0aGlzLnNvdXJjZVNwYW5DYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLmluZGV4ICsgb2Zmc2V0O1xuICAgICAgICByZXR1cm4gaSA8IHRoaXMudG9rZW5zLmxlbmd0aCA/IHRoaXMudG9rZW5zW2ldIDogRU9GO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVlaygwKTtcbiAgICB9XG4gICAgLyoqIFdoZXRoZXIgYWxsIHRoZSBwYXJzZXIgaW5wdXQgaGFzIGJlZW4gcHJvY2Vzc2VkLiAqL1xuICAgIGdldCBhdEVPRigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPj0gdGhpcy50b2tlbnMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiB0aGUgbmV4dCB0b2tlbiB0byBiZSBwcm9jZXNzZWQsIG9yIHRoZSBlbmQgb2YgdGhlIGxhc3QgdG9rZW4gaWYgYWxsIGhhdmUgYmVlblxuICAgICAqIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBnZXQgaW5wdXRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXRFT0YgPyB0aGlzLmN1cnJlbnRFbmRJbmRleCA6IHRoaXMubmV4dC5pbmRleCArIHRoaXMub2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmQgaW5kZXggb2YgdGhlIGxhc3QgcHJvY2Vzc2VkIHRva2VuLCBvciB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IHRva2VuIGlmIG5vbmUgaGF2ZSBiZWVuXG4gICAgICogcHJvY2Vzc2VkLlxuICAgICAqL1xuICAgIGdldCBjdXJyZW50RW5kSW5kZXgoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VyVG9rZW4gPSB0aGlzLnBlZWsoLTEpO1xuICAgICAgICAgICAgcmV0dXJuIGN1clRva2VuLmVuZCArIHRoaXMub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHRva2VucyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHlldDsgcmV0dXJuIHRoZSBuZXh0IHRva2VuJ3Mgc3RhcnQgb3IgdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXRcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gdG9rZW4uXG4gICAgICAgIGlmICh0aGlzLnRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0Lmxlbmd0aCArIHRoaXMub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQuaW5kZXggKyB0aGlzLm9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWJzb2x1dGUgb2Zmc2V0IG9mIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudEFic29sdXRlT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hYnNvbHV0ZU9mZnNldCArIHRoaXMuaW5wdXRJbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBgUGFyc2VTcGFuYCBmcm9tIGBzdGFydGAgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gKG9yIHRvIGBhcnRpZmljaWFsRW5kSW5kZXhgIGlmXG4gICAgICogcHJvdmlkZWQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXJ0IFBvc2l0aW9uIGZyb20gd2hpY2ggdGhlIGBQYXJzZVNwYW5gIHdpbGwgc3RhcnQuXG4gICAgICogQHBhcmFtIGFydGlmaWNpYWxFbmRJbmRleCBPcHRpb25hbCBlbmRpbmcgaW5kZXggdG8gYmUgdXNlZCBpZiBwcm92aWRlZCAoYW5kIGlmIGdyZWF0ZXIgdGhhbiB0aGVcbiAgICAgKiAgICAgbmF0dXJhbCBlbmRpbmcgaW5kZXgpXG4gICAgICovXG4gICAgc3BhbihzdGFydCwgYXJ0aWZpY2lhbEVuZEluZGV4KSB7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IHRoaXMuY3VycmVudEVuZEluZGV4O1xuICAgICAgICBpZiAoYXJ0aWZpY2lhbEVuZEluZGV4ICE9PSB1bmRlZmluZWQgJiYgYXJ0aWZpY2lhbEVuZEluZGV4ID4gdGhpcy5jdXJyZW50RW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gYXJ0aWZpY2lhbEVuZEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHNvbWUgdW51c3VhbCBwYXJzaW5nIHNjZW5hcmlvcyAobGlrZSB3aGVuIGNlcnRhaW4gdG9rZW5zIGFyZSBtaXNzaW5nIGFuZCBhbiBgRW1wdHlFeHByYCBpc1xuICAgICAgICAvLyBiZWluZyBjcmVhdGVkKSwgdGhlIGN1cnJlbnQgdG9rZW4gbWF5IGFscmVhZHkgYmUgYWR2YW5jZWQgYmV5b25kIHRoZSBgY3VycmVudEVuZEluZGV4YC4gVGhpc1xuICAgICAgICAvLyBhcHBlYXJzIHRvIGJlIGEgZGVlcC1zZWF0ZWQgcGFyc2VyIGJ1Zy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQXMgYSB3b3JrYXJvdW5kIGZvciBub3csIHN3YXAgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyB0byBlbnN1cmUgYSB2YWxpZCBgUGFyc2VTcGFuYC5cbiAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBmaXggdGhlIGJ1ZyB1cHN0cmVhbSBpbiB0aGUgcGFyc2VyIHN0YXRlLCBhbmQgcmVtb3ZlIHRoaXMgd29ya2Fyb3VuZC5cbiAgICAgICAgaWYgKHN0YXJ0ID4gZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGVuZEluZGV4O1xuICAgICAgICAgICAgZW5kSW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgIHN0YXJ0ID0gdG1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VTcGFuKHN0YXJ0LCBlbmRJbmRleCk7XG4gICAgfVxuICAgIHNvdXJjZVNwYW4oc3RhcnQsIGFydGlmaWNpYWxFbmRJbmRleCkge1xuICAgICAgICBjb25zdCBzZXJpYWwgPSBgJHtzdGFydH1AJHt0aGlzLmlucHV0SW5kZXh9OiR7YXJ0aWZpY2lhbEVuZEluZGV4fWA7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2VTcGFuQ2FjaGUuaGFzKHNlcmlhbCkpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlU3BhbkNhY2hlLnNldChzZXJpYWwsIHRoaXMuc3BhbihzdGFydCwgYXJ0aWZpY2lhbEVuZEluZGV4KS50b0Fic29sdXRlKHRoaXMuYWJzb2x1dGVPZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VTcGFuQ2FjaGUuZ2V0KHNlcmlhbCk7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBjYWxsYmFjayBpbiB0aGUgcHJvdmlkZWQgY29udGV4dC5cbiAgICAgKi9cbiAgICB3aXRoQ29udGV4dChjb250ZXh0LCBjYikge1xuICAgICAgICB0aGlzLmNvbnRleHQgfD0gY29udGV4dDtcbiAgICAgICAgY29uc3QgcmV0ID0gY2IoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0IF49IGNvbnRleHQ7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGNvbnN1bWVPcHRpb25hbENoYXJhY3Rlcihjb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoY29kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVla0tleXdvcmRMZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQuaXNLZXl3b3JkTGV0KCk7XG4gICAgfVxuICAgIHBlZWtLZXl3b3JkQXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHQuaXNLZXl3b3JkQXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZXMgYW4gZXhwZWN0ZWQgY2hhcmFjdGVyLCBvdGhlcndpc2UgZW1pdHMgYW4gZXJyb3IgYWJvdXQgdGhlIG1pc3NpbmcgZXhwZWN0ZWQgY2hhcmFjdGVyXG4gICAgICogYW5kIHNraXBzIG92ZXIgdGhlIHRva2VuIHN0cmVhbSB1bnRpbCByZWFjaGluZyBhIHJlY292ZXJhYmxlIHBvaW50LlxuICAgICAqXG4gICAgICogU2VlIGB0aGlzLmVycm9yYCBhbmQgYHRoaXMuc2tpcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKi9cbiAgICBleHBlY3RDaGFyYWN0ZXIoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoY29kZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZXJyb3IoYE1pc3NpbmcgZXhwZWN0ZWQgJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpfWApO1xuICAgIH1cbiAgICBjb25zdW1lT3B0aW9uYWxPcGVyYXRvcihvcCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzT3BlcmF0b3Iob3ApKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cGVjdE9wZXJhdG9yKG9wZXJhdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKG9wZXJhdG9yKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lcnJvcihgTWlzc2luZyBleHBlY3RlZCBvcGVyYXRvciAke29wZXJhdG9yfWApO1xuICAgIH1cbiAgICBwcmV0dHlQcmludFRva2VuKHRvaykge1xuICAgICAgICByZXR1cm4gdG9rID09PSBFT0YgPyAnZW5kIG9mIGlucHV0JyA6IGB0b2tlbiAke3Rva31gO1xuICAgIH1cbiAgICBleHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAoIW4uaXNJZGVudGlmaWVyKCkgJiYgIW4uaXNLZXl3b3JkKCkpIHtcbiAgICAgICAgICAgIGlmIChuLmlzUHJpdmF0ZUlkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yRm9yUHJpdmF0ZUlkZW50aWZpZXIobiwgJ2V4cGVjdGVkIGlkZW50aWZpZXIgb3Iga2V5d29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgVW5leHBlY3RlZCAke3RoaXMucHJldHR5UHJpbnRUb2tlbihuKX0sIGV4cGVjdGVkIGlkZW50aWZpZXIgb3Iga2V5d29yZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZygpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpICYmICFuLmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIGlmIChuLmlzUHJpdmF0ZUlkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yRm9yUHJpdmF0ZUlkZW50aWZpZXIobiwgJ2V4cGVjdGVkIGlkZW50aWZpZXIsIGtleXdvcmQgb3Igc3RyaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGBVbmV4cGVjdGVkICR7dGhpcy5wcmV0dHlQcmludFRva2VuKG4pfSwgZXhwZWN0ZWQgaWRlbnRpZmllciwga2V5d29yZCwgb3Igc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHBhcnNlQ2hhaW4oKSB7XG4gICAgICAgIGNvbnN0IGV4cHJzID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICBleHBycy5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy5wYXJzZUZsYWdzICYgMSAvKiBQYXJzZUZsYWdzLkFjdGlvbiAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignQmluZGluZyBleHByZXNzaW9uIGNhbm5vdCBjb250YWluIGNoYWluZWQgZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikpIHtcbiAgICAgICAgICAgICAgICB9IC8vIHJlYWQgYWxsIHNlbWljb2xvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGBVbmV4cGVjdGVkIHRva2VuICcke3RoaXMubmV4dH0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIG5vIGV4cHJlc3Npb25zIHNvIGNyZWF0ZSBhbiBlbXB0eSBleHByZXNzaW9uIHRoYXQgc3BhbnMgdGhlIGVudGlyZSBpbnB1dCBsZW5ndGhcbiAgICAgICAgICAgIGNvbnN0IGFydGlmaWNpYWxTdGFydCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgYXJ0aWZpY2lhbEVuZCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oYXJ0aWZpY2lhbFN0YXJ0LCBhcnRpZmljaWFsRW5kKSwgdGhpcy5zb3VyY2VTcGFuKGFydGlmaWNpYWxTdGFydCwgYXJ0aWZpY2lhbEVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBycy5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgIHJldHVybiBleHByc1swXTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbih0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBleHBycyk7XG4gICAgfVxuICAgIHBhcnNlUGlwZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignfCcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZUZsYWdzICYgMSAvKiBQYXJzZUZsYWdzLkFjdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0Nhbm5vdCBoYXZlIGEgcGlwZSBpbiBhbiBhY3Rpb24gZXhwcmVzc2lvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVTdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZUlkID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCk7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWVTcGFuO1xuICAgICAgICAgICAgICAgIGxldCBmdWxsU3BhbkVuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAobmFtZUlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVTcGFuID0gdGhpcy5zb3VyY2VTcGFuKG5hbWVTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyB2YWxpZCBpZGVudGlmaWVyIHdhcyBmb3VuZCwgc28gd2UnbGwgYXNzdW1lIGFuIGVtcHR5IHBpcGUgbmFtZSAoJycpLlxuICAgICAgICAgICAgICAgICAgICBuYW1lSWQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlcmUgbWF5IGhhdmUgYmVlbiB3aGl0ZXNwYWNlIHByZXNlbnQgYmV0d2VlbiB0aGUgcGlwZSBjaGFyYWN0ZXIgYW5kIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRva2VuIGluIHRoZSBzZXF1ZW5jZSAob3IgdGhlIGVuZCBvZiBpbnB1dCkuIFdlIHdhbnQgdG8gdHJhY2sgdGhpcyB3aGl0ZXNwYWNlIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGBCaW5kaW5nUGlwZWAgd2UgcHJvZHVjZSBjb3ZlcnMgbm90IGp1c3QgdGhlIHBpcGUgY2hhcmFjdGVyLCBidXQgYW55IHRyYWlsaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaXRlc3BhY2UgYmV5b25kIGl0LiBBbm90aGVyIHdheSBvZiB0aGlua2luZyBhYm91dCB0aGlzIGlzIHRoYXQgdGhlIHplcm8tbGVuZ3RoIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgYXNzdW1lZCB0byBiZSBhdCB0aGUgZW5kIG9mIGFueSB3aGl0ZXNwYWNlIGJleW9uZCB0aGUgcGlwZSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgd2UgcHVzaCB0aGUgZW5kIG9mIHRoZSBgUGFyc2VTcGFuYCBmb3IgdGhpcyBwaXBlIGFsbCB0aGUgd2F5IHVwIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIG5leHQgdG9rZW4sIG9yIHVudGlsIHRoZSBlbmQgb2YgaW5wdXQgaWYgdGhlIG5leHQgdG9rZW4gaXMgRU9GLlxuICAgICAgICAgICAgICAgICAgICBmdWxsU3BhbkVuZCA9IHRoaXMubmV4dC5pbmRleCAhPT0gLTEgPyB0aGlzLm5leHQuaW5kZXggOiB0aGlzLmlucHV0Lmxlbmd0aCArIHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYG5hbWVTcGFuYCBmb3IgYW4gZW1wdHkgcGlwZSBuYW1lIGlzIHplcm8tbGVuZ3RoIGF0IHRoZSBlbmQgb2YgYW55IHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYmV5b25kIHRoZSBwaXBlIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgbmFtZVNwYW4gPSBuZXcgUGFyc2VTcGFuKGZ1bGxTcGFuRW5kLCBmdWxsU3BhbkVuZCkudG9BYnNvbHV0ZSh0aGlzLmFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFkZGl0aW9uYWwgZXhwcmVzc2lvbnMgYmV5b25kIHRoZSBuYW1lLCB0aGVuIHRoZSBhcnRpZmljaWFsIGVuZCBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5hbWUgaXMgbm8gbG9uZ2VyIHJlbGV2YW50LlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluZGluZ1BpcGUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0LCBmdWxsU3BhbkVuZCksIHJlc3VsdCwgbmFtZUlkLCBhcmdzLCBuYW1lU3Bhbik7XG4gICAgICAgICAgICB9IHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCd8JykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbCgpO1xuICAgIH1cbiAgICBwYXJzZUNvbmRpdGlvbmFsKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxPcigpO1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignPycpKSB7XG4gICAgICAgICAgICBjb25zdCB5ZXMgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgbGV0IG5vO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGBDb25kaXRpb25hbCBleHByZXNzaW9uICR7ZXhwcmVzc2lvbn0gcmVxdWlyZXMgYWxsIDMgZXhwcmVzc2lvbnNgKTtcbiAgICAgICAgICAgICAgICBubyA9IG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBubyA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlc3VsdCwgeWVzLCBubyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlTG9naWNhbE9yKCkge1xuICAgICAgICAvLyAnfHwnXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJ3x8JykpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5wYXJzZUxvZ2ljYWxBbmQoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgJ3x8JywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VMb2dpY2FsQW5kKCkge1xuICAgICAgICAvLyAnJiYnXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU51bGxpc2hDb2FsZXNjaW5nKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCcmJicpKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucGFyc2VOdWxsaXNoQ29hbGVzY2luZygpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCAnJiYnLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZU51bGxpc2hDb2FsZXNjaW5nKCkge1xuICAgICAgICAvLyAnPz8nXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZUVxdWFsaXR5KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc/PycpKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCAnPz8nLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZUVxdWFsaXR5KCkge1xuICAgICAgICAvLyAnPT0nLCchPScsJz09PScsJyE9PSdcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICB3aGlsZSAodGhpcy5uZXh0LnR5cGUgPT0gZXhwb3J0cy5Ub2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJz09JzpcbiAgICAgICAgICAgICAgICBjYXNlICc9PT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgICAgICBjYXNlICchPT0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnBhcnNlUmVsYXRpb25hbCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZVJlbGF0aW9uYWwoKSB7XG4gICAgICAgIC8vICc8JywgJz4nLCAnPD0nLCAnPj0nXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlQWRkaXRpdmUoKSB7XG4gICAgICAgIC8vICcrJywgJy0nXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSB0aGlzLnBhcnNlTXVsdGlwbGljYXRpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VNdWx0aXBsaWNhdGl2ZSgpIHtcbiAgICAgICAgLy8gJyonLCAnJScsICcvJ1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IGV4cG9ydHMuVG9rZW5UeXBlLk9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCByaWdodCA9IHRoaXMucGFyc2VQcmVmaXgoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmFyeSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBvcGVyYXRvciwgcmVzdWx0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VQcmVmaXgoKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQudHlwZSA9PSBleHBvcnRzLlRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeS5jcmVhdGVQbHVzKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeS5jcmVhdGVNaW51cyh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FsbENoYWluKCk7XG4gICAgfVxuICAgIHBhcnNlQ2FsbENoYWluKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJFBFUklPRCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyKHJlc3VsdCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJz8uJykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUNhbGwocmVzdWx0LCBzdGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VLZXllZFJlYWRPcldyaXRlKHJlc3VsdCwgc3RhcnQsIHRydWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXIocmVzdWx0LCBzdGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VLZXllZFJlYWRPcldyaXRlKHJlc3VsdCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUNhbGwocmVzdWx0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignIScpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IE5vbk51bGxBc3NlcnQodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VQcmltYXJ5KCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZE51bGwoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFVuZGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUcnVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRGYWxzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRoaXMoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRoaXNSZWNlaXZlcih0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkKys7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMucGFyc2VFeHByZXNzaW9uTGlzdCgkUkJSQUNLRVQpO1xuICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJExCUkFDRSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXIobmV3IEltcGxpY2l0UmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSksIHN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzTnVtYmVyKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5uZXh0LnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpdGVyYWxWYWx1ZSA9IHRoaXMubmV4dC50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgbGl0ZXJhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNQcml2YXRlSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvckZvclByaXZhdGVJZGVudGlmaWVyKHRoaXMubmV4dCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihgVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbjogJHt0aGlzLmlucHV0fWApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGBVbmV4cGVjdGVkIHRva2VuICR7dGhpcy5uZXh0fWApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VFeHByZXNzaW9uTGlzdCh0ZXJtaW5hdG9yKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubmV4dC5pc0NoYXJhY3Rlcih0ZXJtaW5hdG9yKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZUxpdGVyYWxNYXAoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkTEJSQUNFKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkUkJSQUNFKSkge1xuICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBxdW90ZWQgPSB0aGlzLm5leHQuaXNTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZygpO1xuICAgICAgICAgICAgICAgIGtleXMucHVzaCh7IGtleSwgcXVvdGVkIH0pO1xuICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgd2l0aCBxdW90ZWQga2V5cyBjYW4ndCB1c2UgdGhlIHNob3J0aGFuZCBzeW50YXguXG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkQ09MT04pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnNwYW4oa2V5U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VTcGFuID0gdGhpcy5zb3VyY2VTcGFuKGtleVN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gobmV3IFByb3BlcnR5UmVhZChzcGFuLCBzb3VyY2VTcGFuLCBzb3VyY2VTcGFuLCBuZXcgSW1wbGljaXRSZWNlaXZlcihzcGFuLCBzb3VyY2VTcGFuKSwga2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgICAgICB0aGlzLnJicmFjZXNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIGtleXMsIHZhbHVlcyk7XG4gICAgfVxuICAgIHBhcnNlQWNjZXNzTWVtYmVyKHJlYWRSZWNlaXZlciwgc3RhcnQsIGlzU2FmZSkge1xuICAgICAgICBjb25zdCBuYW1lU3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy53aXRoQ29udGV4dChQYXJzZUNvbnRleHRGbGFncy5Xcml0YWJsZSwgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgaWQgPSAoX2EgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmQoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgRXhwZWN0ZWQgaWRlbnRpZmllciBmb3IgcHJvcGVydHkgYWNjZXNzYCwgcmVhZFJlY2VpdmVyLnNwYW4uZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5hbWVTcGFuID0gdGhpcy5zb3VyY2VTcGFuKG5hbWVTdGFydCk7XG4gICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgaWYgKGlzU2FmZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQXNzaWdubWVudCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVGhlIFxcJz8uXFwnIG9wZXJhdG9yIGNhbm5vdCBiZSB1c2VkIGluIHRoZSBhc3NpZ25tZW50Jyk7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSBuZXcgU2FmZVByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBuYW1lU3BhbiwgcmVhZFJlY2VpdmVyLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxBc3NpZ25tZW50KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnBhcnNlRmxhZ3MgJiAxIC8qIFBhcnNlRmxhZ3MuQWN0aW9uICovKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdCaW5kaW5ncyBjYW5ub3QgY29udGFpbiBhc3NpZ25tZW50cycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IG5ldyBQcm9wZXJ0eVdyaXRlKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIG5hbWVTcGFuLCByZWFkUmVjZWl2ZXIsIGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9XG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9wZXJ0eVJlYWQodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgbmFtZVNwYW4sIHJlYWRSZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNlaXZlcjtcbiAgICB9XG4gICAgcGFyc2VDYWxsKHJlY2VpdmVyLCBzdGFydCwgaXNTYWZlKSB7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50U3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkKys7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICBjb25zdCBhcmd1bWVudFNwYW4gPSB0aGlzLnNwYW4oYXJndW1lbnRTdGFydCwgdGhpcy5pbnB1dEluZGV4KS50b0Fic29sdXRlKHRoaXMuYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuc3BhbihzdGFydCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVNwYW4gPSB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpO1xuICAgICAgICByZXR1cm4gaXNTYWZlID8gbmV3IFNhZmVDYWxsKHNwYW4sIHNvdXJjZVNwYW4sIHJlY2VpdmVyLCBhcmdzLCBhcmd1bWVudFNwYW4pIDpcbiAgICAgICAgICAgIG5ldyBDYWxsKHNwYW4sIHNvdXJjZVNwYW4sIHJlY2VpdmVyLCBhcmdzLCBhcmd1bWVudFNwYW4pO1xuICAgIH1cbiAgICBjb25zdW1lT3B0aW9uYWxBc3NpZ25tZW50KCkge1xuICAgICAgICAvLyBXaGVuIHBhcnNpbmcgYXNzaWdubWVudCBldmVudHMgKG9yaWdpbmF0aW5nIGZyb20gdHdvLXdheS1iaW5kaW5nIGFrYSBiYW5hbmEtaW4tYS1ib3ggc3ludGF4KSxcbiAgICAgICAgLy8gaXQgaXMgdmFsaWQgZm9yIHRoZSBwcmltYXJ5IGV4cHJlc3Npb24gdG8gYmUgdGVybWluYXRlZCBieSB0aGUgbm9uLW51bGwgb3BlcmF0b3IuIFRoaXNcbiAgICAgICAgLy8gcHJpbWFyeSBleHByZXNzaW9uIGlzIHN1YnN0aXR1dGVkIGFzIExIUyBvZiB0aGUgYXNzaWdubWVudCBvcGVyYXRvciB0byBhY2hpZXZlXG4gICAgICAgIC8vIHR3by13YXktYmluZGluZywgc3VjaCB0aGF0IHRoZSBMSFMgY291bGQgYmUgdGhlIG5vbi1udWxsIG9wZXJhdG9yLiBUaGUgZ3JhbW1hciBkb2Vzbid0XG4gICAgICAgIC8vIG5hdHVyYWxseSBhbGxvdyBmb3IgdGhpcyBzeW50YXgsIHNvIGFzc2lnbm1lbnQgZXZlbnRzIGFyZSBwYXJzZWQgc3BlY2lhbGx5LlxuICAgICAgICBpZiAoKHRoaXMucGFyc2VGbGFncyAmIDIgLyogUGFyc2VGbGFncy5Bc3NpZ25tZW50RXZlbnQgKi8pICYmIHRoaXMubmV4dC5pc09wZXJhdG9yKCchJykgJiZcbiAgICAgICAgICAgIHRoaXMucGVlaygxKS5pc09wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHNraXAgb3ZlciB0aGUgISBvcGVyYXRvci5cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgLy8gVGhlbiBza2lwIG92ZXIgdGhlID0gb3BlcmF0b3IsIHRvIGZ1bGx5IGNvbnN1bWUgdGhlIG9wdGlvbmFsIGFzc2lnbm1lbnQgb3BlcmF0b3IuXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9Jyk7XG4gICAgfVxuICAgIHBhcnNlQ2FsbEFyZ3VtZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkUlBBUkVOKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25hbHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbmFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIGlkZW50aWZpZXIsIGEga2V5d29yZCwgYSBzdHJpbmcgd2l0aCBhbiBvcHRpb25hbCBgLWAgaW4gYmV0d2VlbixcbiAgICAgKiBhbmQgcmV0dXJucyB0aGUgc3RyaW5nIGFsb25nIHdpdGggaXRzIGFic29sdXRlIHNvdXJjZSBzcGFuLlxuICAgICAqL1xuICAgIGV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBsZXQgb3BlcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuY3VycmVudEFic29sdXRlT2Zmc2V0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgIG9wZXJhdG9yRm91bmQgPSB0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCctJyk7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JGb3VuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG9wZXJhdG9yRm91bmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiByZXN1bHQsXG4gICAgICAgICAgICBzcGFuOiBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKHN0YXJ0LCBzdGFydCArIHJlc3VsdC5sZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWNyb3N5bnRheCB0ZW1wbGF0ZSBleHByZXNzaW9uIGFuZCByZXR1cm4gYSBsaXN0IG9mIGJpbmRpbmdzIG9yXG4gICAgICogcGFyc2luZyBlcnJvcnMgaW4gY2FzZSB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsXG4gICAgICogYGBgXG4gICAgICogICA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBpbmRleCBhcyBpOyB0cmFja0J5OiBmdW5jXCI+XG4gICAgICogYGBgXG4gICAgICogY29udGFpbnMgZml2ZSBiaW5kaW5nczpcbiAgICAgKiAxLiBuZ0ZvciAtPiBudWxsXG4gICAgICogMi4gaXRlbSAtPiBOZ0Zvck9mQ29udGV4dC4kaW1wbGljaXRcbiAgICAgKiAzLiBuZ0Zvck9mIC0+IGl0ZW1zXG4gICAgICogNC4gaSAtPiBOZ0Zvck9mQ29udGV4dC5pbmRleFxuICAgICAqIDUuIG5nRm9yVHJhY2tCeSAtPiBmdW5jXG4gICAgICpcbiAgICAgKiBGb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBtaWNyb3N5bnRheCBncmFtbWFyLCBzZWVcbiAgICAgKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9taGV2ZXJ5L2QzNTMwMjk0Y2ZmMmU0YTFiM2ZlMTVmZjc1ZDA4ODU1XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVLZXkgbmFtZSBvZiB0aGUgbWljcm9zeW50YXggZGlyZWN0aXZlLCBsaWtlIG5nSWYsIG5nRm9yLFxuICAgICAqIHdpdGhvdXQgdGhlICosIGFsb25nIHdpdGggaXRzIGFic29sdXRlIHNwYW4uXG4gICAgICovXG4gICAgcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRlbXBsYXRlS2V5KSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gW107XG4gICAgICAgIC8vIFRoZSBmaXJzdCBiaW5kaW5nIGlzIGZvciB0aGUgdGVtcGxhdGUga2V5IGl0c2VsZlxuICAgICAgICAvLyBJbiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiLCBrZXkgPSBcIm5nRm9yXCIsIHZhbHVlID0gbnVsbFxuICAgICAgICAvLyBJbiAqbmdJZj1cImNvbmQgfCBwaXBlXCIsIGtleSA9IFwibmdJZlwiLCB2YWx1ZSA9IFwiY29uZCB8IHBpcGVcIlxuICAgICAgICBiaW5kaW5ncy5wdXNoKC4uLnRoaXMucGFyc2VEaXJlY3RpdmVLZXl3b3JkQmluZGluZ3ModGVtcGxhdGVLZXkpKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IHN0YXJ0cyB3aXRoICdsZXQnLCB0aGVuIHRoaXMgbXVzdCBiZSB2YXJpYWJsZSBkZWNsYXJhdGlvblxuICAgICAgICAgICAgY29uc3QgbGV0QmluZGluZyA9IHRoaXMucGFyc2VMZXRCaW5kaW5nKCk7XG4gICAgICAgICAgICBpZiAobGV0QmluZGluZykge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobGV0QmluZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUd28gcG9zc2libGUgY2FzZXMgaGVyZSwgZWl0aGVyIGB2YWx1ZSBcImFzXCIga2V5YCBvclxuICAgICAgICAgICAgICAgIC8vIFwiZGlyZWN0aXZlLWtleXdvcmQgZXhwcmVzc2lvblwiLiBXZSBkb24ndCBrbm93IHdoaWNoIGNhc2UsIGJ1dCBib3RoXG4gICAgICAgICAgICAgICAgLy8gXCJ2YWx1ZVwiIGFuZCBcImRpcmVjdGl2ZS1rZXl3b3JkXCIgYXJlIHRlbXBsYXRlIGJpbmRpbmcga2V5LCBzbyBjb25zdW1lXG4gICAgICAgICAgICAgICAgLy8gdGhlIGtleSBmaXJzdC5cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICAgICAgICAgIC8vIFBlZWsgYXQgdGhlIG5leHQgdG9rZW4sIGlmIGl0IGlzIFwiYXNcIiB0aGVuIHRoaXMgbXVzdCBiZSB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIC8vIGRlY2xhcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLnBhcnNlQXNCaW5kaW5nKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUga2V5IG11c3QgYmUgYSBkaXJlY3RpdmUga2V5d29yZCwgbGlrZSBcIm9mXCIuIFRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUga2V5IHRvIGFjdHVhbCBrZXkuIEVnLiBvZiAtPiBuZ0Zvck9mLCB0cmFja0J5IC0+IG5nRm9yVHJhY2tCeVxuICAgICAgICAgICAgICAgICAgICBrZXkuc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlS2V5LnNvdXJjZSArIGtleS5zb3VyY2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MucHVzaCguLi50aGlzLnBhcnNlRGlyZWN0aXZlS2V5d29yZEJpbmRpbmdzKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29uc3VtZVN0YXRlbWVudFRlcm1pbmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KGJpbmRpbmdzLCBbXSAvKiB3YXJuaW5ncyAqLywgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICBwYXJzZUtleWVkUmVhZE9yV3JpdGUocmVjZWl2ZXIsIHN0YXJ0LCBpc1NhZmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbnRleHQoUGFyc2VDb250ZXh0RmxhZ3MuV3JpdGFibGUsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgRW1wdHlFeHByKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgS2V5IGFjY2VzcyBjYW5ub3QgYmUgZW1wdHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2FmZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdUaGUgXFwnPy5cXCcgb3BlcmF0b3IgY2Fubm90IGJlIHVzZWQgaW4gdGhlIGFzc2lnbm1lbnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS2V5ZWRXcml0ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZWNlaXZlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FmZSA/IG5ldyBTYWZlS2V5ZWRSZWFkKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlY2VpdmVyLCBrZXkpIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3IEtleWVkUmVhZCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZWNlaXZlciwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBkaXJlY3RpdmUga2V5d29yZCwgZm9sbG93ZWQgYnkgYSBtYW5kYXRvcnkgZXhwcmVzc2lvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSwgXCJvZiBpdGVtc1wiLCBcInRyYWNrQnk6IGZ1bmNcIi5cbiAgICAgKiBUaGUgYmluZGluZ3MgYXJlOiBuZ0Zvck9mIC0+IGl0ZW1zLCBuZ0ZvclRyYWNrQnkgLT4gZnVuY1xuICAgICAqIFRoZXJlIGNvdWxkIGJlIGFuIG9wdGlvbmFsIFwiYXNcIiBiaW5kaW5nIHRoYXQgZm9sbG93cyB0aGUgZXhwcmVzc2lvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zIHwgc2xpY2U6MDoxIGFzIGNvbGxlY3Rpb25cIi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgXl4gXl5eXl5eXl5eXl5eXl5eXl4gXl5eXl5eXl5eXl5eXlxuICAgICAqICAgICAgICAgICAgICAga2V5d29yZCAgICBib3VuZCB0YXJnZXQgICBvcHRpb25hbCAnYXMnIGJpbmRpbmdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgYmluZGluZyBrZXksIGZvciBleGFtcGxlLCBuZ0ZvciwgbmdJZiwgbmdGb3JPZiwgYWxvbmcgd2l0aCBpdHNcbiAgICAgKiBhYnNvbHV0ZSBzcGFuLlxuICAgICAqL1xuICAgIHBhcnNlRGlyZWN0aXZlS2V5d29yZEJpbmRpbmdzKGtleSkge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkQ09MT04pOyAvLyB0cmFja0J5OiB0cmFja0J5RnVuY3Rpb25cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldERpcmVjdGl2ZUJvdW5kVGFyZ2V0KCk7XG4gICAgICAgIGxldCBzcGFuRW5kID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIC8vIFRoZSBiaW5kaW5nIGNvdWxkIG9wdGlvbmFsbHkgYmUgZm9sbG93ZWQgYnkgXCJhc1wiLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgLy8gKm5nSWY9XCJjb25kIHwgcGlwZSBhcyB4XCIuIEluIHRoaXMgY2FzZSwgdGhlIGtleSBpbiB0aGUgXCJhc1wiIGJpbmRpbmdcbiAgICAgICAgLy8gaXMgXCJ4XCIgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgdGVtcGxhdGUga2V5IGl0c2VsZiAoXCJuZ0lmXCIpLiBOb3RlIHRoYXQgdGhlXG4gICAgICAgIC8vICdrZXknIGluIHRoZSBjdXJyZW50IGNvbnRleHQgbm93IGJlY29tZXMgdGhlIFwidmFsdWVcIiBpbiB0aGUgbmV4dCBiaW5kaW5nLlxuICAgICAgICBjb25zdCBhc0JpbmRpbmcgPSB0aGlzLnBhcnNlQXNCaW5kaW5nKGtleSk7XG4gICAgICAgIGlmICghYXNCaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yKCk7XG4gICAgICAgICAgICBzcGFuRW5kID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oa2V5LnNwYW4uc3RhcnQsIHNwYW5FbmQpO1xuICAgICAgICBiaW5kaW5ncy5wdXNoKG5ldyBFeHByZXNzaW9uQmluZGluZyhzb3VyY2VTcGFuLCBrZXksIHZhbHVlKSk7XG4gICAgICAgIGlmIChhc0JpbmRpbmcpIHtcbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goYXNCaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZXhwcmVzc2lvbiBBU1QgZm9yIHRoZSBib3VuZCB0YXJnZXQgb2YgYSBkaXJlY3RpdmUga2V5d29yZFxuICAgICAqIGJpbmRpbmcuIEZvciBleGFtcGxlLFxuICAgICAqIGBgYFxuICAgICAqICAgKm5nSWY9XCJjb25kaXRpb24gfCBwaXBlXCJcbiAgICAgKiAgICAgICAgICBeXl5eXl5eXl5eXl5eXl5eIGJvdW5kIHRhcmdldCBmb3IgXCJuZ0lmXCJcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgXl5eXl4gYm91bmQgdGFyZ2V0IGZvciBcIm5nRm9yT2ZcIlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldERpcmVjdGl2ZUJvdW5kVGFyZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0ID09PSBFT0YgfHwgdGhpcy5wZWVrS2V5d29yZEFzKCkgfHwgdGhpcy5wZWVrS2V5d29yZExldCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3QgPSB0aGlzLnBhcnNlUGlwZSgpOyAvLyBleGFtcGxlOiBcImNvbmRpdGlvbiB8IGFzeW5jXCJcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBhc3Quc3BhbjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgdmFsdWUsIHRoaXMubG9jYXRpb24sIHRoaXMuYWJzb2x1dGVPZmZzZXQgKyBzdGFydCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGJpbmRpbmcgZm9yIGEgdmFyaWFibGUgZGVjbGFyZWQgdXNpbmcgYGFzYC4gTm90ZSB0aGF0IHRoZSBvcmRlclxuICAgICAqIG9mIHRoZSBrZXktdmFsdWUgcGFpciBpbiB0aGlzIGRlY2xhcmF0aW9uIGlzIHJldmVyc2VkLiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBpbmRleCBhcyBpXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eICAgIF5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIGtleVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIG5hbWUgb2YgdGhlIHZhbHVlIGluIHRoZSBkZWNsYXJhdGlvbiwgXCJuZ0lmXCIgaW4gdGhlIGV4YW1wbGVcbiAgICAgKiBhYm92ZSwgYWxvbmcgd2l0aCBpdHMgYWJzb2x1dGUgc3Bhbi5cbiAgICAgKi9cbiAgICBwYXJzZUFzQmluZGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMucGVla0tleXdvcmRBcygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSB0aGUgJ2FzJyBrZXl3b3JkXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgIHRoaXMuY29uc3VtZVN0YXRlbWVudFRlcm1pbmF0b3IoKTtcbiAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4odmFsdWUuc3Bhbi5zdGFydCwgdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlQmluZGluZyhzb3VyY2VTcGFuLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaW5kaW5nIGZvciBhIHZhcmlhYmxlIGRlY2xhcmVkIHVzaW5nIGBsZXRgLiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaT1pbmRleDtcIlxuICAgICAqICAgICAgICAgICBeXl5eXl5eXiAgICAgICAgICAgXl5eXl5eXl5eXl5cbiAgICAgKiBgYGBcbiAgICAgKiBJbiB0aGUgZmlyc3QgYmluZGluZywgYGl0ZW1gIGlzIGJvdW5kIHRvIGBOZ0Zvck9mQ29udGV4dC4kaW1wbGljaXRgLlxuICAgICAqIEluIHRoZSBzZWNvbmQgYmluZGluZywgYGlgIGlzIGJvdW5kIHRvIGBOZ0Zvck9mQ29udGV4dC5pbmRleGAuXG4gICAgICovXG4gICAgcGFyc2VMZXRCaW5kaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMucGVla0tleXdvcmRMZXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BhblN0YXJ0ID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIHRoZSAnbGV0JyBrZXl3b3JkXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yKCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVNwYW4gPSBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKHNwYW5TdGFydCwgdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlQmluZGluZyhzb3VyY2VTcGFuLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZSB0aGUgb3B0aW9uYWwgc3RhdGVtZW50IHRlcm1pbmF0b3I6IHNlbWljb2xvbiBvciBjb21tYS5cbiAgICAgKi9cbiAgICBjb25zdW1lU3RhdGVtZW50VGVybWluYXRvcigpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikgfHwgdGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyBhbiBlcnJvciBhbmQgc2tpcHMgb3ZlciB0aGUgdG9rZW4gc3RyZWFtIHVudGlsIHJlYWNoaW5nIGEgcmVjb3ZlcmFibGUgcG9pbnQuIFNlZVxuICAgICAqIGB0aGlzLnNraXBgIGZvciBtb3JlIGRldGFpbHMgb24gdG9rZW4gc2tpcHBpbmcuXG4gICAgICovXG4gICAgZXJyb3IobWVzc2FnZSwgaW5kZXggPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KGluZGV4KSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICB9XG4gICAgbG9jYXRpb25UZXh0KGluZGV4ID0gbnVsbCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gbnVsbClcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgcmV0dXJuIChpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyBgYXQgY29sdW1uICR7dGhpcy50b2tlbnNbaW5kZXhdLmluZGV4ICsgMX0gaW5gIDpcbiAgICAgICAgICAgIGBhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyBhbiBlcnJvciBmb3IgYW4gdW5leHBlY3RlZCBwcml2YXRlIGlkZW50aWZpZXIgYmVpbmcgZGlzY292ZXJlZC5cbiAgICAgKiBAcGFyYW0gdG9rZW4gVG9rZW4gcmVwcmVzZW50aW5nIGEgcHJpdmF0ZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSBleHRyYU1lc3NhZ2UgT3B0aW9uYWwgYWRkaXRpb25hbCBtZXNzYWdlIGJlaW5nIGFwcGVuZGVkIHRvIHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBfcmVwb3J0RXJyb3JGb3JQcml2YXRlSWRlbnRpZmllcih0b2tlbiwgZXh0cmFNZXNzYWdlKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgUHJpdmF0ZSBpZGVudGlmaWVycyBhcmUgbm90IHN1cHBvcnRlZC4gVW5leHBlY3RlZCBwcml2YXRlIGlkZW50aWZpZXI6ICR7dG9rZW59YDtcbiAgICAgICAgaWYgKGV4dHJhTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGAsICR7ZXh0cmFNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcnJvciByZWNvdmVyeSBzaG91bGQgc2tpcCB0b2tlbnMgdW50aWwgaXQgZW5jb3VudGVycyBhIHJlY292ZXJ5IHBvaW50LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBhcmUgdHJlYXRlZCBhcyB1bmNvbmRpdGlvbmFsIHJlY292ZXJ5IHBvaW50czpcbiAgICAgKiAgIC0gZW5kIG9mIGlucHV0XG4gICAgICogICAtICc7JyAocGFyc2VDaGFpbigpIGlzIGFsd2F5cyB0aGUgcm9vdCBwcm9kdWN0aW9uLCBhbmQgaXQgZXhwZWN0cyBhICc7JylcbiAgICAgKiAgIC0gJ3wnIChzaW5jZSBwaXBlcyBtYXkgYmUgY2hhaW5lZCBhbmQgZWFjaCBwaXBlIGV4cHJlc3Npb24gbWF5IGJlIHRyZWF0ZWQgaW5kZXBlbmRlbnRseSlcbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgYXJlIGNvbmRpdGlvbmFsIHJlY292ZXJ5IHBvaW50czpcbiAgICAgKiAgIC0gJyknLCAnfScsICddJyBpZiBvbmUgb2YgY2FsbGluZyBwcm9kdWN0aW9ucyBpcyBleHBlY3Rpbmcgb25lIG9mIHRoZXNlIHN5bWJvbHNcbiAgICAgKiAgICAgLSBUaGlzIGFsbG93cyBza2lwKCkgdG8gcmVjb3ZlciBmcm9tIGVycm9ycyBzdWNoIGFzICcoYS4pICsgMScgYWxsb3dpbmcgbW9yZSBvZiB0aGUgQVNUIHRvXG4gICAgICogICAgICAgYmUgcmV0YWluZWQgKGl0IGRvZXNuJ3Qgc2tpcCBhbnkgdG9rZW5zIGFzIHRoZSAnKScgaXMgcmV0YWluZWQgYmVjYXVzZSBvZiB0aGUgJygnIGJlZ2luc1xuICAgICAqICAgICAgIGFuICcoJyA8ZXhwcj4gJyknIHByb2R1Y3Rpb24pLlxuICAgICAqICAgICAgIFRoZSByZWNvdmVyeSBwb2ludHMgb2YgZ3JvdXBpbmcgc3ltYm9scyBtdXN0IGJlIGNvbmRpdGlvbmFsIGFzIHRoZXkgbXVzdCBiZSBza2lwcGVkIGlmXG4gICAgICogICAgICAgbm9uZSBvZiB0aGUgY2FsbGluZyBwcm9kdWN0aW9ucyBhcmUgbm90IGV4cGVjdGluZyB0aGUgY2xvc2luZyB0b2tlbiBlbHNlIHdlIHdpbGwgbmV2ZXJcbiAgICAgKiAgICAgICBtYWtlIHByb2dyZXNzIGluIHRoZSBjYXNlIG9mIGFuIGV4dHJhbmVvdXMgZ3JvdXAgY2xvc2luZyBzeW1ib2wgKHN1Y2ggYXMgYSBzdHJheSAnKScpLlxuICAgICAqICAgICAgIFRoYXQgaXMsIHdlIHNraXAgYSBjbG9zaW5nIHN5bWJvbCBpZiB3ZSBhcmUgbm90IGluIGEgZ3JvdXBpbmcgcHJvZHVjdGlvbi5cbiAgICAgKiAgIC0gJz0nIGluIGEgYFdyaXRhYmxlYCBjb250ZXh0XG4gICAgICogICAgIC0gSW4gdGhpcyBjb250ZXh0LCB3ZSBhcmUgYWJsZSB0byByZWNvdmVyIGFmdGVyIHNlZWluZyB0aGUgYD1gIG9wZXJhdG9yLCB3aGljaFxuICAgICAqICAgICAgIHNpZ25hbHMgdGhlIHByZXNlbmNlIG9mIGFuIGluZGVwZW5kZW50IHJ2YWx1ZSBleHByZXNzaW9uIGZvbGxvd2luZyB0aGUgYD1gIG9wZXJhdG9yLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9kdWN0aW9uIGV4cGVjdHMgb25lIG9mIHRoZXNlIHRva2VuIGl0IGluY3JlbWVudHMgdGhlIGNvcnJlc3BvbmRpbmcgbmVzdGluZyBjb3VudCxcbiAgICAgKiBhbmQgdGhlbiBkZWNyZW1lbnRzIGl0IGp1c3QgcHJpb3IgdG8gY2hlY2tpbmcgaWYgdGhlIHRva2VuIGlzIGluIHRoZSBpbnB1dC5cbiAgICAgKi9cbiAgICBza2lwKCkge1xuICAgICAgICBsZXQgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggJiYgIW4uaXNDaGFyYWN0ZXIoJFNFTUlDT0xPTikgJiZcbiAgICAgICAgICAgICFuLmlzT3BlcmF0b3IoJ3wnKSAmJiAodGhpcy5ycGFyZW5zRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUlBBUkVOKSkgJiZcbiAgICAgICAgICAgICh0aGlzLnJicmFjZXNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSQlJBQ0UpKSAmJlxuICAgICAgICAgICAgKHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNLRVQpKSAmJlxuICAgICAgICAgICAgKCEodGhpcy5jb250ZXh0ICYgUGFyc2VDb250ZXh0RmxhZ3MuV3JpdGFibGUpIHx8ICFuLmlzT3BlcmF0b3IoJz0nKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNFcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IodGhpcy5uZXh0LnRvU3RyaW5nKCksIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KCksIHRoaXMubG9jYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyIGV4dGVuZHMgUmVjdXJzaXZlQXN0VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHZpc2l0UGlwZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCgncGlwZXMnKTtcbiAgICB9XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSByZWFsIG9mZnNldCBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgZm9yIGluZGV4ZXMgaW4gYW4gaW50ZXJwb2xhdGlvbi5cbiAqXG4gKiBCZWNhdXNlIHRlbXBsYXRlcyBjYW4gaGF2ZSBlbmNvZGVkIEhUTUwgZW50aXRpZXMgYW5kIHRoZSBpbnB1dCBwYXNzZWQgdG8gdGhlIHBhcnNlciBhdCB0aGlzIHN0YWdlXG4gKiBvZiB0aGUgY29tcGlsZXIgaXMgdGhlIF9kZWNvZGVkXyB2YWx1ZSwgd2UgbmVlZCB0byBjb21wdXRlIHRoZSByZWFsIG9mZnNldCB1c2luZyB0aGUgb3JpZ2luYWxcbiAqIGVuY29kZWQgdmFsdWVzIGluIHRoZSBpbnRlcnBvbGF0ZWQgdG9rZW5zLiBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IGEgc3BlY2lhbCBjYXNlIGhhbmRsaW5nIGZvclxuICogYE1sUGFyc2VyVG9rZW5UeXBlLkVOQ09ERURfRU5USVRZYCB0b2tlbiB0eXBlcy4gQWxsIG90aGVyIGludGVycG9sYXRlZCB0b2tlbnMgYXJlIGV4cGVjdGVkIHRvXG4gKiBoYXZlIHBhcnRzIHdoaWNoIGV4YWN0bHkgbWF0Y2ggdGhlIGlucHV0IHN0cmluZyBmb3IgcGFyc2luZyB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGVkVG9rZW5zIFRoZSB0b2tlbnMgZm9yIHRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gKlxuICogQHJldHVybnMgQSBtYXAgb2YgaW5kZXggbG9jYXRpb25zIGluIHRoZSBkZWNvZGVkIHRlbXBsYXRlIHRvIGluZGV4ZXMgaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlXG4gKi9cbmZ1bmN0aW9uIGdldEluZGV4TWFwRm9yT3JpZ2luYWxUZW1wbGF0ZShpbnRlcnBvbGF0ZWRUb2tlbnMpIHtcbiAgICBsZXQgb2Zmc2V0TWFwID0gbmV3IE1hcCgpO1xuICAgIGxldCBjb25zdW1lZEluT3JpZ2luYWxUZW1wbGF0ZSA9IDA7XG4gICAgbGV0IGNvbnN1bWVkSW5JbnB1dCA9IDA7XG4gICAgbGV0IHRva2VuSW5kZXggPSAwO1xuICAgIHdoaWxlICh0b2tlbkluZGV4IDwgaW50ZXJwb2xhdGVkVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VG9rZW4gPSBpbnRlcnBvbGF0ZWRUb2tlbnNbdG9rZW5JbmRleF07XG4gICAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gOSAvKiBNbFBhcnNlclRva2VuVHlwZS5FTkNPREVEX0VOVElUWSAqLykge1xuICAgICAgICAgICAgY29uc3QgW2RlY29kZWQsIGVuY29kZWRdID0gY3VycmVudFRva2VuLnBhcnRzO1xuICAgICAgICAgICAgY29uc3VtZWRJbk9yaWdpbmFsVGVtcGxhdGUgKz0gZW5jb2RlZC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdW1lZEluSW5wdXQgKz0gZGVjb2RlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGhPZlBhcnRzID0gY3VycmVudFRva2VuLnBhcnRzLnJlZHVjZSgoc3VtLCBjdXJyZW50KSA9PiBzdW0gKyBjdXJyZW50Lmxlbmd0aCwgMCk7XG4gICAgICAgICAgICBjb25zdW1lZEluSW5wdXQgKz0gbGVuZ3RoT2ZQYXJ0cztcbiAgICAgICAgICAgIGNvbnN1bWVkSW5PcmlnaW5hbFRlbXBsYXRlICs9IGxlbmd0aE9mUGFydHM7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0TWFwLnNldChjb25zdW1lZEluSW5wdXQsIGNvbnN1bWVkSW5PcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgICAgdG9rZW5JbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0TWFwO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIE5vZGVXaXRoSTE4biB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbn1cbmNsYXNzIFRleHQgZXh0ZW5kcyBOb2RlV2l0aEkxOG4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzb3VyY2VTcGFuLCB0b2tlbnMsIGkxOG4pIHtcbiAgICAgICAgc3VwZXIoc291cmNlU3BhbiwgaTE4bik7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEV4cGFuc2lvbiBleHRlbmRzIE5vZGVXaXRoSTE4biB7XG4gICAgY29uc3RydWN0b3Ioc3dpdGNoVmFsdWUsIHR5cGUsIGNhc2VzLCBzb3VyY2VTcGFuLCBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgc3VwZXIoc291cmNlU3BhbiwgaTE4bik7XG4gICAgICAgIHRoaXMuc3dpdGNoVmFsdWUgPSBzd2l0Y2hWYWx1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICB0aGlzLnN3aXRjaFZhbHVlU291cmNlU3BhbiA9IHN3aXRjaFZhbHVlU291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEV4cGFuc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBFeHBhbnNpb25DYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgZXhwcmVzc2lvbiwgc291cmNlU3BhbiwgdmFsdWVTb3VyY2VTcGFuLCBleHBTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNvdXJjZVNwYW4gPSB2YWx1ZVNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZXhwU291cmNlU3BhbiA9IGV4cFNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHBhbnNpb25DYXNlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEF0dHJpYnV0ZSBleHRlbmRzIE5vZGVXaXRoSTE4biB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgdmFsdWVUb2tlbnMsIGkxOG4pIHtcbiAgICAgICAgc3VwZXIoc291cmNlU3BhbiwgaTE4bik7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVUb2tlbnMgPSB2YWx1ZVRva2VucztcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEF0dHJpYnV0ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBFbGVtZW50IGV4dGVuZHMgTm9kZVdpdGhJMThuIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhdHRycywgY2hpbGRyZW4sIHNvdXJjZVNwYW4sIHN0YXJ0U291cmNlU3BhbiwgZW5kU291cmNlU3BhbiA9IG51bGwsIGkxOG4pIHtcbiAgICAgICAgc3VwZXIoc291cmNlU3BhbiwgaTE4bik7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEVsZW1lbnQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQ29tbWVudCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWVudCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5mdW5jdGlvbiB2aXNpdEFsbCh2aXNpdG9yLCBub2RlcywgY29udGV4dCA9IG51bGwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCB2aXNpdCA9IHZpc2l0b3IudmlzaXQgP1xuICAgICAgICAoYXN0KSA9PiB2aXNpdG9yLnZpc2l0KGFzdCwgY29udGV4dCkgfHwgYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIDpcbiAgICAgICAgKGFzdCkgPT4gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgIG5vZGVzLmZvckVhY2goYXN0ID0+IHtcbiAgICAgICAgY29uc3QgYXN0UmVzdWx0ID0gdmlzaXQoYXN0KTtcbiAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5jbGFzcyBSZWN1cnNpdmVWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIHZpc2l0RWxlbWVudChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKGNvbnRleHQsIHZpc2l0ID0+IHtcbiAgICAgICAgICAgIHZpc2l0KGFzdC5hdHRycyk7XG4gICAgICAgICAgICB2aXNpdChhc3QuY2hpbGRyZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXRBdHRyaWJ1dGUoYXN0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdFRleHQoYXN0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdENvbW1lbnQoYXN0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRDaGlsZHJlbihjb250ZXh0LCB2aXNpdCA9PiB7XG4gICAgICAgICAgICB2aXNpdChhc3QuY2FzZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGFzdCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRDaGlsZHJlbihjb250ZXh0LCBjYikge1xuICAgICAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgICAgICBsZXQgdCA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIHZpc2l0KGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZpc2l0QWxsKHQsIGNoaWxkcmVuLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2IodmlzaXQpO1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgcmVzdWx0cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIE1hcHBpbmcgYmV0d2VlbiBhbGwgSFRNTCBlbnRpdHkgbmFtZXMgYW5kIHRoZWlyIHVuaWNvZGUgcmVwcmVzZW50YXRpb24uXG4vLyBHZW5lcmF0ZWQgZnJvbSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbnRpdGllcy5qc29uIGJ5IHN0cmlwcGluZ1xuLy8gdGhlIGAmYCBhbmQgYDtgIGZyb20gdGhlIGtleXMgYW5kIHJlbW92aW5nIHRoZSBkdXBsaWNhdGVzLlxuLy8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjbmFtZWQtY2hhcmFjdGVyLXJlZmVyZW5jZXNcbmNvbnN0IE5BTUVEX0VOVElUSUVTID0ge1xuICAgICdBRWxpZyc6ICdcXHUwMEM2JyxcbiAgICAnQU1QJzogJ1xcdTAwMjYnLFxuICAgICdhbXAnOiAnXFx1MDAyNicsXG4gICAgJ0FhY3V0ZSc6ICdcXHUwMEMxJyxcbiAgICAnQWJyZXZlJzogJ1xcdTAxMDInLFxuICAgICdBY2lyYyc6ICdcXHUwMEMyJyxcbiAgICAnQWN5JzogJ1xcdTA0MTAnLFxuICAgICdBZnInOiAnXFx1RDgzNVxcdUREMDQnLFxuICAgICdBZ3JhdmUnOiAnXFx1MDBDMCcsXG4gICAgJ0FscGhhJzogJ1xcdTAzOTEnLFxuICAgICdBbWFjcic6ICdcXHUwMTAwJyxcbiAgICAnQW5kJzogJ1xcdTJBNTMnLFxuICAgICdBb2dvbic6ICdcXHUwMTA0JyxcbiAgICAnQW9wZic6ICdcXHVEODM1XFx1REQzOCcsXG4gICAgJ0FwcGx5RnVuY3Rpb24nOiAnXFx1MjA2MScsXG4gICAgJ2FmJzogJ1xcdTIwNjEnLFxuICAgICdBcmluZyc6ICdcXHUwMEM1JyxcbiAgICAnYW5nc3QnOiAnXFx1MDBDNScsXG4gICAgJ0FzY3InOiAnXFx1RDgzNVxcdURDOUMnLFxuICAgICdBc3NpZ24nOiAnXFx1MjI1NCcsXG4gICAgJ2NvbG9uZSc6ICdcXHUyMjU0JyxcbiAgICAnY29sb25lcSc6ICdcXHUyMjU0JyxcbiAgICAnQXRpbGRlJzogJ1xcdTAwQzMnLFxuICAgICdBdW1sJzogJ1xcdTAwQzQnLFxuICAgICdCYWNrc2xhc2gnOiAnXFx1MjIxNicsXG4gICAgJ3NldG1pbnVzJzogJ1xcdTIyMTYnLFxuICAgICdzZXRtbic6ICdcXHUyMjE2JyxcbiAgICAnc21hbGxzZXRtaW51cyc6ICdcXHUyMjE2JyxcbiAgICAnc3NldG1uJzogJ1xcdTIyMTYnLFxuICAgICdCYXJ2JzogJ1xcdTJBRTcnLFxuICAgICdCYXJ3ZWQnOiAnXFx1MjMwNicsXG4gICAgJ2RvdWJsZWJhcndlZGdlJzogJ1xcdTIzMDYnLFxuICAgICdCY3knOiAnXFx1MDQxMScsXG4gICAgJ0JlY2F1c2UnOiAnXFx1MjIzNScsXG4gICAgJ2JlY2F1cyc6ICdcXHUyMjM1JyxcbiAgICAnYmVjYXVzZSc6ICdcXHUyMjM1JyxcbiAgICAnQmVybm91bGxpcyc6ICdcXHUyMTJDJyxcbiAgICAnQnNjcic6ICdcXHUyMTJDJyxcbiAgICAnYmVybm91JzogJ1xcdTIxMkMnLFxuICAgICdCZXRhJzogJ1xcdTAzOTInLFxuICAgICdCZnInOiAnXFx1RDgzNVxcdUREMDUnLFxuICAgICdCb3BmJzogJ1xcdUQ4MzVcXHVERDM5JyxcbiAgICAnQnJldmUnOiAnXFx1MDJEOCcsXG4gICAgJ2JyZXZlJzogJ1xcdTAyRDgnLFxuICAgICdCdW1wZXEnOiAnXFx1MjI0RScsXG4gICAgJ0h1bXBEb3duSHVtcCc6ICdcXHUyMjRFJyxcbiAgICAnYnVtcCc6ICdcXHUyMjRFJyxcbiAgICAnQ0hjeSc6ICdcXHUwNDI3JyxcbiAgICAnQ09QWSc6ICdcXHUwMEE5JyxcbiAgICAnY29weSc6ICdcXHUwMEE5JyxcbiAgICAnQ2FjdXRlJzogJ1xcdTAxMDYnLFxuICAgICdDYXAnOiAnXFx1MjJEMicsXG4gICAgJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJzogJ1xcdTIxNDUnLFxuICAgICdERCc6ICdcXHUyMTQ1JyxcbiAgICAnQ2F5bGV5cyc6ICdcXHUyMTJEJyxcbiAgICAnQ2ZyJzogJ1xcdTIxMkQnLFxuICAgICdDY2Fyb24nOiAnXFx1MDEwQycsXG4gICAgJ0NjZWRpbCc6ICdcXHUwMEM3JyxcbiAgICAnQ2NpcmMnOiAnXFx1MDEwOCcsXG4gICAgJ0Njb25pbnQnOiAnXFx1MjIzMCcsXG4gICAgJ0Nkb3QnOiAnXFx1MDEwQScsXG4gICAgJ0NlZGlsbGEnOiAnXFx1MDBCOCcsXG4gICAgJ2NlZGlsJzogJ1xcdTAwQjgnLFxuICAgICdDZW50ZXJEb3QnOiAnXFx1MDBCNycsXG4gICAgJ2NlbnRlcmRvdCc6ICdcXHUwMEI3JyxcbiAgICAnbWlkZG90JzogJ1xcdTAwQjcnLFxuICAgICdDaGknOiAnXFx1MDNBNycsXG4gICAgJ0NpcmNsZURvdCc6ICdcXHUyMjk5JyxcbiAgICAnb2RvdCc6ICdcXHUyMjk5JyxcbiAgICAnQ2lyY2xlTWludXMnOiAnXFx1MjI5NicsXG4gICAgJ29taW51cyc6ICdcXHUyMjk2JyxcbiAgICAnQ2lyY2xlUGx1cyc6ICdcXHUyMjk1JyxcbiAgICAnb3BsdXMnOiAnXFx1MjI5NScsXG4gICAgJ0NpcmNsZVRpbWVzJzogJ1xcdTIyOTcnLFxuICAgICdvdGltZXMnOiAnXFx1MjI5NycsXG4gICAgJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCc6ICdcXHUyMjMyJyxcbiAgICAnY3djb25pbnQnOiAnXFx1MjIzMicsXG4gICAgJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZSc6ICdcXHUyMDFEJyxcbiAgICAncmRxdW8nOiAnXFx1MjAxRCcsXG4gICAgJ3JkcXVvcic6ICdcXHUyMDFEJyxcbiAgICAnQ2xvc2VDdXJseVF1b3RlJzogJ1xcdTIwMTknLFxuICAgICdyc3F1byc6ICdcXHUyMDE5JyxcbiAgICAncnNxdW9yJzogJ1xcdTIwMTknLFxuICAgICdDb2xvbic6ICdcXHUyMjM3JyxcbiAgICAnUHJvcG9ydGlvbic6ICdcXHUyMjM3JyxcbiAgICAnQ29sb25lJzogJ1xcdTJBNzQnLFxuICAgICdDb25ncnVlbnQnOiAnXFx1MjI2MScsXG4gICAgJ2VxdWl2JzogJ1xcdTIyNjEnLFxuICAgICdDb25pbnQnOiAnXFx1MjIyRicsXG4gICAgJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCc6ICdcXHUyMjJGJyxcbiAgICAnQ29udG91ckludGVncmFsJzogJ1xcdTIyMkUnLFxuICAgICdjb25pbnQnOiAnXFx1MjIyRScsXG4gICAgJ29pbnQnOiAnXFx1MjIyRScsXG4gICAgJ0NvcGYnOiAnXFx1MjEwMicsXG4gICAgJ2NvbXBsZXhlcyc6ICdcXHUyMTAyJyxcbiAgICAnQ29wcm9kdWN0JzogJ1xcdTIyMTAnLFxuICAgICdjb3Byb2QnOiAnXFx1MjIxMCcsXG4gICAgJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnOiAnXFx1MjIzMycsXG4gICAgJ2F3Y29uaW50JzogJ1xcdTIyMzMnLFxuICAgICdDcm9zcyc6ICdcXHUyQTJGJyxcbiAgICAnQ3Njcic6ICdcXHVEODM1XFx1REM5RScsXG4gICAgJ0N1cCc6ICdcXHUyMkQzJyxcbiAgICAnQ3VwQ2FwJzogJ1xcdTIyNEQnLFxuICAgICdhc3ltcGVxJzogJ1xcdTIyNEQnLFxuICAgICdERG90cmFoZCc6ICdcXHUyOTExJyxcbiAgICAnREpjeSc6ICdcXHUwNDAyJyxcbiAgICAnRFNjeSc6ICdcXHUwNDA1JyxcbiAgICAnRFpjeSc6ICdcXHUwNDBGJyxcbiAgICAnRGFnZ2VyJzogJ1xcdTIwMjEnLFxuICAgICdkZGFnZ2VyJzogJ1xcdTIwMjEnLFxuICAgICdEYXJyJzogJ1xcdTIxQTEnLFxuICAgICdEYXNodic6ICdcXHUyQUU0JyxcbiAgICAnRG91YmxlTGVmdFRlZSc6ICdcXHUyQUU0JyxcbiAgICAnRGNhcm9uJzogJ1xcdTAxMEUnLFxuICAgICdEY3knOiAnXFx1MDQxNCcsXG4gICAgJ0RlbCc6ICdcXHUyMjA3JyxcbiAgICAnbmFibGEnOiAnXFx1MjIwNycsXG4gICAgJ0RlbHRhJzogJ1xcdTAzOTQnLFxuICAgICdEZnInOiAnXFx1RDgzNVxcdUREMDcnLFxuICAgICdEaWFjcml0aWNhbEFjdXRlJzogJ1xcdTAwQjQnLFxuICAgICdhY3V0ZSc6ICdcXHUwMEI0JyxcbiAgICAnRGlhY3JpdGljYWxEb3QnOiAnXFx1MDJEOScsXG4gICAgJ2RvdCc6ICdcXHUwMkQ5JyxcbiAgICAnRGlhY3JpdGljYWxEb3VibGVBY3V0ZSc6ICdcXHUwMkREJyxcbiAgICAnZGJsYWMnOiAnXFx1MDJERCcsXG4gICAgJ0RpYWNyaXRpY2FsR3JhdmUnOiAnXFx1MDA2MCcsXG4gICAgJ2dyYXZlJzogJ1xcdTAwNjAnLFxuICAgICdEaWFjcml0aWNhbFRpbGRlJzogJ1xcdTAyREMnLFxuICAgICd0aWxkZSc6ICdcXHUwMkRDJyxcbiAgICAnRGlhbW9uZCc6ICdcXHUyMkM0JyxcbiAgICAnZGlhbSc6ICdcXHUyMkM0JyxcbiAgICAnZGlhbW9uZCc6ICdcXHUyMkM0JyxcbiAgICAnRGlmZmVyZW50aWFsRCc6ICdcXHUyMTQ2JyxcbiAgICAnZGQnOiAnXFx1MjE0NicsXG4gICAgJ0RvcGYnOiAnXFx1RDgzNVxcdUREM0InLFxuICAgICdEb3QnOiAnXFx1MDBBOCcsXG4gICAgJ0RvdWJsZURvdCc6ICdcXHUwMEE4JyxcbiAgICAnZGllJzogJ1xcdTAwQTgnLFxuICAgICd1bWwnOiAnXFx1MDBBOCcsXG4gICAgJ0RvdERvdCc6ICdcXHUyMERDJyxcbiAgICAnRG90RXF1YWwnOiAnXFx1MjI1MCcsXG4gICAgJ2RvdGVxJzogJ1xcdTIyNTAnLFxuICAgICdlc2RvdCc6ICdcXHUyMjUwJyxcbiAgICAnRG91YmxlRG93bkFycm93JzogJ1xcdTIxRDMnLFxuICAgICdEb3duYXJyb3cnOiAnXFx1MjFEMycsXG4gICAgJ2RBcnInOiAnXFx1MjFEMycsXG4gICAgJ0RvdWJsZUxlZnRBcnJvdyc6ICdcXHUyMUQwJyxcbiAgICAnTGVmdGFycm93JzogJ1xcdTIxRDAnLFxuICAgICdsQXJyJzogJ1xcdTIxRDAnLFxuICAgICdEb3VibGVMZWZ0UmlnaHRBcnJvdyc6ICdcXHUyMUQ0JyxcbiAgICAnTGVmdHJpZ2h0YXJyb3cnOiAnXFx1MjFENCcsXG4gICAgJ2hBcnInOiAnXFx1MjFENCcsXG4gICAgJ2lmZic6ICdcXHUyMUQ0JyxcbiAgICAnRG91YmxlTG9uZ0xlZnRBcnJvdyc6ICdcXHUyN0Y4JyxcbiAgICAnTG9uZ2xlZnRhcnJvdyc6ICdcXHUyN0Y4JyxcbiAgICAneGxBcnInOiAnXFx1MjdGOCcsXG4gICAgJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyc6ICdcXHUyN0ZBJyxcbiAgICAnTG9uZ2xlZnRyaWdodGFycm93JzogJ1xcdTI3RkEnLFxuICAgICd4aEFycic6ICdcXHUyN0ZBJyxcbiAgICAnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnOiAnXFx1MjdGOScsXG4gICAgJ0xvbmdyaWdodGFycm93JzogJ1xcdTI3RjknLFxuICAgICd4ckFycic6ICdcXHUyN0Y5JyxcbiAgICAnRG91YmxlUmlnaHRBcnJvdyc6ICdcXHUyMUQyJyxcbiAgICAnSW1wbGllcyc6ICdcXHUyMUQyJyxcbiAgICAnUmlnaHRhcnJvdyc6ICdcXHUyMUQyJyxcbiAgICAnckFycic6ICdcXHUyMUQyJyxcbiAgICAnRG91YmxlUmlnaHRUZWUnOiAnXFx1MjJBOCcsXG4gICAgJ3ZEYXNoJzogJ1xcdTIyQTgnLFxuICAgICdEb3VibGVVcEFycm93JzogJ1xcdTIxRDEnLFxuICAgICdVcGFycm93JzogJ1xcdTIxRDEnLFxuICAgICd1QXJyJzogJ1xcdTIxRDEnLFxuICAgICdEb3VibGVVcERvd25BcnJvdyc6ICdcXHUyMUQ1JyxcbiAgICAnVXBkb3duYXJyb3cnOiAnXFx1MjFENScsXG4gICAgJ3ZBcnInOiAnXFx1MjFENScsXG4gICAgJ0RvdWJsZVZlcnRpY2FsQmFyJzogJ1xcdTIyMjUnLFxuICAgICdwYXInOiAnXFx1MjIyNScsXG4gICAgJ3BhcmFsbGVsJzogJ1xcdTIyMjUnLFxuICAgICdzaG9ydHBhcmFsbGVsJzogJ1xcdTIyMjUnLFxuICAgICdzcGFyJzogJ1xcdTIyMjUnLFxuICAgICdEb3duQXJyb3cnOiAnXFx1MjE5MycsXG4gICAgJ1Nob3J0RG93bkFycm93JzogJ1xcdTIxOTMnLFxuICAgICdkYXJyJzogJ1xcdTIxOTMnLFxuICAgICdkb3duYXJyb3cnOiAnXFx1MjE5MycsXG4gICAgJ0Rvd25BcnJvd0Jhcic6ICdcXHUyOTEzJyxcbiAgICAnRG93bkFycm93VXBBcnJvdyc6ICdcXHUyMUY1JyxcbiAgICAnZHVhcnInOiAnXFx1MjFGNScsXG4gICAgJ0Rvd25CcmV2ZSc6ICdcXHUwMzExJyxcbiAgICAnRG93bkxlZnRSaWdodFZlY3Rvcic6ICdcXHUyOTUwJyxcbiAgICAnRG93bkxlZnRUZWVWZWN0b3InOiAnXFx1Mjk1RScsXG4gICAgJ0Rvd25MZWZ0VmVjdG9yJzogJ1xcdTIxQkQnLFxuICAgICdsZWZ0aGFycG9vbmRvd24nOiAnXFx1MjFCRCcsXG4gICAgJ2xoYXJkJzogJ1xcdTIxQkQnLFxuICAgICdEb3duTGVmdFZlY3RvckJhcic6ICdcXHUyOTU2JyxcbiAgICAnRG93blJpZ2h0VGVlVmVjdG9yJzogJ1xcdTI5NUYnLFxuICAgICdEb3duUmlnaHRWZWN0b3InOiAnXFx1MjFDMScsXG4gICAgJ3JoYXJkJzogJ1xcdTIxQzEnLFxuICAgICdyaWdodGhhcnBvb25kb3duJzogJ1xcdTIxQzEnLFxuICAgICdEb3duUmlnaHRWZWN0b3JCYXInOiAnXFx1Mjk1NycsXG4gICAgJ0Rvd25UZWUnOiAnXFx1MjJBNCcsXG4gICAgJ3RvcCc6ICdcXHUyMkE0JyxcbiAgICAnRG93blRlZUFycm93JzogJ1xcdTIxQTcnLFxuICAgICdtYXBzdG9kb3duJzogJ1xcdTIxQTcnLFxuICAgICdEc2NyJzogJ1xcdUQ4MzVcXHVEQzlGJyxcbiAgICAnRHN0cm9rJzogJ1xcdTAxMTAnLFxuICAgICdFTkcnOiAnXFx1MDE0QScsXG4gICAgJ0VUSCc6ICdcXHUwMEQwJyxcbiAgICAnRWFjdXRlJzogJ1xcdTAwQzknLFxuICAgICdFY2Fyb24nOiAnXFx1MDExQScsXG4gICAgJ0VjaXJjJzogJ1xcdTAwQ0EnLFxuICAgICdFY3knOiAnXFx1MDQyRCcsXG4gICAgJ0Vkb3QnOiAnXFx1MDExNicsXG4gICAgJ0Vmcic6ICdcXHVEODM1XFx1REQwOCcsXG4gICAgJ0VncmF2ZSc6ICdcXHUwMEM4JyxcbiAgICAnRWxlbWVudCc6ICdcXHUyMjA4JyxcbiAgICAnaW4nOiAnXFx1MjIwOCcsXG4gICAgJ2lzaW4nOiAnXFx1MjIwOCcsXG4gICAgJ2lzaW52JzogJ1xcdTIyMDgnLFxuICAgICdFbWFjcic6ICdcXHUwMTEyJyxcbiAgICAnRW1wdHlTbWFsbFNxdWFyZSc6ICdcXHUyNUZCJyxcbiAgICAnRW1wdHlWZXJ5U21hbGxTcXVhcmUnOiAnXFx1MjVBQicsXG4gICAgJ0VvZ29uJzogJ1xcdTAxMTgnLFxuICAgICdFb3BmJzogJ1xcdUQ4MzVcXHVERDNDJyxcbiAgICAnRXBzaWxvbic6ICdcXHUwMzk1JyxcbiAgICAnRXF1YWwnOiAnXFx1MkE3NScsXG4gICAgJ0VxdWFsVGlsZGUnOiAnXFx1MjI0MicsXG4gICAgJ2Vxc2ltJzogJ1xcdTIyNDInLFxuICAgICdlc2ltJzogJ1xcdTIyNDInLFxuICAgICdFcXVpbGlicml1bSc6ICdcXHUyMUNDJyxcbiAgICAncmlnaHRsZWZ0aGFycG9vbnMnOiAnXFx1MjFDQycsXG4gICAgJ3JsaGFyJzogJ1xcdTIxQ0MnLFxuICAgICdFc2NyJzogJ1xcdTIxMzAnLFxuICAgICdleHBlY3RhdGlvbic6ICdcXHUyMTMwJyxcbiAgICAnRXNpbSc6ICdcXHUyQTczJyxcbiAgICAnRXRhJzogJ1xcdTAzOTcnLFxuICAgICdFdW1sJzogJ1xcdTAwQ0InLFxuICAgICdFeGlzdHMnOiAnXFx1MjIwMycsXG4gICAgJ2V4aXN0JzogJ1xcdTIyMDMnLFxuICAgICdFeHBvbmVudGlhbEUnOiAnXFx1MjE0NycsXG4gICAgJ2VlJzogJ1xcdTIxNDcnLFxuICAgICdleHBvbmVudGlhbGUnOiAnXFx1MjE0NycsXG4gICAgJ0ZjeSc6ICdcXHUwNDI0JyxcbiAgICAnRmZyJzogJ1xcdUQ4MzVcXHVERDA5JyxcbiAgICAnRmlsbGVkU21hbGxTcXVhcmUnOiAnXFx1MjVGQycsXG4gICAgJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZSc6ICdcXHUyNUFBJyxcbiAgICAnYmxhY2tzcXVhcmUnOiAnXFx1MjVBQScsXG4gICAgJ3NxdWFyZic6ICdcXHUyNUFBJyxcbiAgICAnc3F1Zic6ICdcXHUyNUFBJyxcbiAgICAnRm9wZic6ICdcXHVEODM1XFx1REQzRCcsXG4gICAgJ0ZvckFsbCc6ICdcXHUyMjAwJyxcbiAgICAnZm9yYWxsJzogJ1xcdTIyMDAnLFxuICAgICdGb3VyaWVydHJmJzogJ1xcdTIxMzEnLFxuICAgICdGc2NyJzogJ1xcdTIxMzEnLFxuICAgICdHSmN5JzogJ1xcdTA0MDMnLFxuICAgICdHVCc6ICdcXHUwMDNFJyxcbiAgICAnZ3QnOiAnXFx1MDAzRScsXG4gICAgJ0dhbW1hJzogJ1xcdTAzOTMnLFxuICAgICdHYW1tYWQnOiAnXFx1MDNEQycsXG4gICAgJ0dicmV2ZSc6ICdcXHUwMTFFJyxcbiAgICAnR2NlZGlsJzogJ1xcdTAxMjInLFxuICAgICdHY2lyYyc6ICdcXHUwMTFDJyxcbiAgICAnR2N5JzogJ1xcdTA0MTMnLFxuICAgICdHZG90JzogJ1xcdTAxMjAnLFxuICAgICdHZnInOiAnXFx1RDgzNVxcdUREMEEnLFxuICAgICdHZyc6ICdcXHUyMkQ5JyxcbiAgICAnZ2dnJzogJ1xcdTIyRDknLFxuICAgICdHb3BmJzogJ1xcdUQ4MzVcXHVERDNFJyxcbiAgICAnR3JlYXRlckVxdWFsJzogJ1xcdTIyNjUnLFxuICAgICdnZSc6ICdcXHUyMjY1JyxcbiAgICAnZ2VxJzogJ1xcdTIyNjUnLFxuICAgICdHcmVhdGVyRXF1YWxMZXNzJzogJ1xcdTIyREInLFxuICAgICdnZWwnOiAnXFx1MjJEQicsXG4gICAgJ2d0cmVxbGVzcyc6ICdcXHUyMkRCJyxcbiAgICAnR3JlYXRlckZ1bGxFcXVhbCc6ICdcXHUyMjY3JyxcbiAgICAnZ0UnOiAnXFx1MjI2NycsXG4gICAgJ2dlcXEnOiAnXFx1MjI2NycsXG4gICAgJ0dyZWF0ZXJHcmVhdGVyJzogJ1xcdTJBQTInLFxuICAgICdHcmVhdGVyTGVzcyc6ICdcXHUyMjc3JyxcbiAgICAnZ2wnOiAnXFx1MjI3NycsXG4gICAgJ2d0cmxlc3MnOiAnXFx1MjI3NycsXG4gICAgJ0dyZWF0ZXJTbGFudEVxdWFsJzogJ1xcdTJBN0UnLFxuICAgICdnZXFzbGFudCc6ICdcXHUyQTdFJyxcbiAgICAnZ2VzJzogJ1xcdTJBN0UnLFxuICAgICdHcmVhdGVyVGlsZGUnOiAnXFx1MjI3MycsXG4gICAgJ2dzaW0nOiAnXFx1MjI3MycsXG4gICAgJ2d0cnNpbSc6ICdcXHUyMjczJyxcbiAgICAnR3Njcic6ICdcXHVEODM1XFx1RENBMicsXG4gICAgJ0d0JzogJ1xcdTIyNkInLFxuICAgICdOZXN0ZWRHcmVhdGVyR3JlYXRlcic6ICdcXHUyMjZCJyxcbiAgICAnZ2cnOiAnXFx1MjI2QicsXG4gICAgJ0hBUkRjeSc6ICdcXHUwNDJBJyxcbiAgICAnSGFjZWsnOiAnXFx1MDJDNycsXG4gICAgJ2Nhcm9uJzogJ1xcdTAyQzcnLFxuICAgICdIYXQnOiAnXFx1MDA1RScsXG4gICAgJ0hjaXJjJzogJ1xcdTAxMjQnLFxuICAgICdIZnInOiAnXFx1MjEwQycsXG4gICAgJ1BvaW5jYXJlcGxhbmUnOiAnXFx1MjEwQycsXG4gICAgJ0hpbGJlcnRTcGFjZSc6ICdcXHUyMTBCJyxcbiAgICAnSHNjcic6ICdcXHUyMTBCJyxcbiAgICAnaGFtaWx0JzogJ1xcdTIxMEInLFxuICAgICdIb3BmJzogJ1xcdTIxMEQnLFxuICAgICdxdWF0ZXJuaW9ucyc6ICdcXHUyMTBEJyxcbiAgICAnSG9yaXpvbnRhbExpbmUnOiAnXFx1MjUwMCcsXG4gICAgJ2JveGgnOiAnXFx1MjUwMCcsXG4gICAgJ0hzdHJvayc6ICdcXHUwMTI2JyxcbiAgICAnSHVtcEVxdWFsJzogJ1xcdTIyNEYnLFxuICAgICdidW1wZSc6ICdcXHUyMjRGJyxcbiAgICAnYnVtcGVxJzogJ1xcdTIyNEYnLFxuICAgICdJRWN5JzogJ1xcdTA0MTUnLFxuICAgICdJSmxpZyc6ICdcXHUwMTMyJyxcbiAgICAnSU9jeSc6ICdcXHUwNDAxJyxcbiAgICAnSWFjdXRlJzogJ1xcdTAwQ0QnLFxuICAgICdJY2lyYyc6ICdcXHUwMENFJyxcbiAgICAnSWN5JzogJ1xcdTA0MTgnLFxuICAgICdJZG90JzogJ1xcdTAxMzAnLFxuICAgICdJZnInOiAnXFx1MjExMScsXG4gICAgJ0ltJzogJ1xcdTIxMTEnLFxuICAgICdpbWFnZSc6ICdcXHUyMTExJyxcbiAgICAnaW1hZ3BhcnQnOiAnXFx1MjExMScsXG4gICAgJ0lncmF2ZSc6ICdcXHUwMENDJyxcbiAgICAnSW1hY3InOiAnXFx1MDEyQScsXG4gICAgJ0ltYWdpbmFyeUknOiAnXFx1MjE0OCcsXG4gICAgJ2lpJzogJ1xcdTIxNDgnLFxuICAgICdJbnQnOiAnXFx1MjIyQycsXG4gICAgJ0ludGVncmFsJzogJ1xcdTIyMkInLFxuICAgICdpbnQnOiAnXFx1MjIyQicsXG4gICAgJ0ludGVyc2VjdGlvbic6ICdcXHUyMkMyJyxcbiAgICAnYmlnY2FwJzogJ1xcdTIyQzInLFxuICAgICd4Y2FwJzogJ1xcdTIyQzInLFxuICAgICdJbnZpc2libGVDb21tYSc6ICdcXHUyMDYzJyxcbiAgICAnaWMnOiAnXFx1MjA2MycsXG4gICAgJ0ludmlzaWJsZVRpbWVzJzogJ1xcdTIwNjInLFxuICAgICdpdCc6ICdcXHUyMDYyJyxcbiAgICAnSW9nb24nOiAnXFx1MDEyRScsXG4gICAgJ0lvcGYnOiAnXFx1RDgzNVxcdURENDAnLFxuICAgICdJb3RhJzogJ1xcdTAzOTknLFxuICAgICdJc2NyJzogJ1xcdTIxMTAnLFxuICAgICdpbWFnbGluZSc6ICdcXHUyMTEwJyxcbiAgICAnSXRpbGRlJzogJ1xcdTAxMjgnLFxuICAgICdJdWtjeSc6ICdcXHUwNDA2JyxcbiAgICAnSXVtbCc6ICdcXHUwMENGJyxcbiAgICAnSmNpcmMnOiAnXFx1MDEzNCcsXG4gICAgJ0pjeSc6ICdcXHUwNDE5JyxcbiAgICAnSmZyJzogJ1xcdUQ4MzVcXHVERDBEJyxcbiAgICAnSm9wZic6ICdcXHVEODM1XFx1REQ0MScsXG4gICAgJ0pzY3InOiAnXFx1RDgzNVxcdURDQTUnLFxuICAgICdKc2VyY3knOiAnXFx1MDQwOCcsXG4gICAgJ0p1a2N5JzogJ1xcdTA0MDQnLFxuICAgICdLSGN5JzogJ1xcdTA0MjUnLFxuICAgICdLSmN5JzogJ1xcdTA0MEMnLFxuICAgICdLYXBwYSc6ICdcXHUwMzlBJyxcbiAgICAnS2NlZGlsJzogJ1xcdTAxMzYnLFxuICAgICdLY3knOiAnXFx1MDQxQScsXG4gICAgJ0tmcic6ICdcXHVEODM1XFx1REQwRScsXG4gICAgJ0tvcGYnOiAnXFx1RDgzNVxcdURENDInLFxuICAgICdLc2NyJzogJ1xcdUQ4MzVcXHVEQ0E2JyxcbiAgICAnTEpjeSc6ICdcXHUwNDA5JyxcbiAgICAnTFQnOiAnXFx1MDAzQycsXG4gICAgJ2x0JzogJ1xcdTAwM0MnLFxuICAgICdMYWN1dGUnOiAnXFx1MDEzOScsXG4gICAgJ0xhbWJkYSc6ICdcXHUwMzlCJyxcbiAgICAnTGFuZyc6ICdcXHUyN0VBJyxcbiAgICAnTGFwbGFjZXRyZic6ICdcXHUyMTEyJyxcbiAgICAnTHNjcic6ICdcXHUyMTEyJyxcbiAgICAnbGFncmFuJzogJ1xcdTIxMTInLFxuICAgICdMYXJyJzogJ1xcdTIxOUUnLFxuICAgICd0d29oZWFkbGVmdGFycm93JzogJ1xcdTIxOUUnLFxuICAgICdMY2Fyb24nOiAnXFx1MDEzRCcsXG4gICAgJ0xjZWRpbCc6ICdcXHUwMTNCJyxcbiAgICAnTGN5JzogJ1xcdTA0MUInLFxuICAgICdMZWZ0QW5nbGVCcmFja2V0JzogJ1xcdTI3RTgnLFxuICAgICdsYW5nJzogJ1xcdTI3RTgnLFxuICAgICdsYW5nbGUnOiAnXFx1MjdFOCcsXG4gICAgJ0xlZnRBcnJvdyc6ICdcXHUyMTkwJyxcbiAgICAnU2hvcnRMZWZ0QXJyb3cnOiAnXFx1MjE5MCcsXG4gICAgJ2xhcnInOiAnXFx1MjE5MCcsXG4gICAgJ2xlZnRhcnJvdyc6ICdcXHUyMTkwJyxcbiAgICAnc2xhcnInOiAnXFx1MjE5MCcsXG4gICAgJ0xlZnRBcnJvd0Jhcic6ICdcXHUyMUU0JyxcbiAgICAnbGFycmInOiAnXFx1MjFFNCcsXG4gICAgJ0xlZnRBcnJvd1JpZ2h0QXJyb3cnOiAnXFx1MjFDNicsXG4gICAgJ2xlZnRyaWdodGFycm93cyc6ICdcXHUyMUM2JyxcbiAgICAnbHJhcnInOiAnXFx1MjFDNicsXG4gICAgJ0xlZnRDZWlsaW5nJzogJ1xcdTIzMDgnLFxuICAgICdsY2VpbCc6ICdcXHUyMzA4JyxcbiAgICAnTGVmdERvdWJsZUJyYWNrZXQnOiAnXFx1MjdFNicsXG4gICAgJ2xvYnJrJzogJ1xcdTI3RTYnLFxuICAgICdMZWZ0RG93blRlZVZlY3Rvcic6ICdcXHUyOTYxJyxcbiAgICAnTGVmdERvd25WZWN0b3InOiAnXFx1MjFDMycsXG4gICAgJ2RoYXJsJzogJ1xcdTIxQzMnLFxuICAgICdkb3duaGFycG9vbmxlZnQnOiAnXFx1MjFDMycsXG4gICAgJ0xlZnREb3duVmVjdG9yQmFyJzogJ1xcdTI5NTknLFxuICAgICdMZWZ0Rmxvb3InOiAnXFx1MjMwQScsXG4gICAgJ2xmbG9vcic6ICdcXHUyMzBBJyxcbiAgICAnTGVmdFJpZ2h0QXJyb3cnOiAnXFx1MjE5NCcsXG4gICAgJ2hhcnInOiAnXFx1MjE5NCcsXG4gICAgJ2xlZnRyaWdodGFycm93JzogJ1xcdTIxOTQnLFxuICAgICdMZWZ0UmlnaHRWZWN0b3InOiAnXFx1Mjk0RScsXG4gICAgJ0xlZnRUZWUnOiAnXFx1MjJBMycsXG4gICAgJ2Rhc2h2JzogJ1xcdTIyQTMnLFxuICAgICdMZWZ0VGVlQXJyb3cnOiAnXFx1MjFBNCcsXG4gICAgJ21hcHN0b2xlZnQnOiAnXFx1MjFBNCcsXG4gICAgJ0xlZnRUZWVWZWN0b3InOiAnXFx1Mjk1QScsXG4gICAgJ0xlZnRUcmlhbmdsZSc6ICdcXHUyMkIyJyxcbiAgICAndmFydHJpYW5nbGVsZWZ0JzogJ1xcdTIyQjInLFxuICAgICd2bHRyaSc6ICdcXHUyMkIyJyxcbiAgICAnTGVmdFRyaWFuZ2xlQmFyJzogJ1xcdTI5Q0YnLFxuICAgICdMZWZ0VHJpYW5nbGVFcXVhbCc6ICdcXHUyMkI0JyxcbiAgICAnbHRyaWUnOiAnXFx1MjJCNCcsXG4gICAgJ3RyaWFuZ2xlbGVmdGVxJzogJ1xcdTIyQjQnLFxuICAgICdMZWZ0VXBEb3duVmVjdG9yJzogJ1xcdTI5NTEnLFxuICAgICdMZWZ0VXBUZWVWZWN0b3InOiAnXFx1Mjk2MCcsXG4gICAgJ0xlZnRVcFZlY3Rvcic6ICdcXHUyMUJGJyxcbiAgICAndWhhcmwnOiAnXFx1MjFCRicsXG4gICAgJ3VwaGFycG9vbmxlZnQnOiAnXFx1MjFCRicsXG4gICAgJ0xlZnRVcFZlY3RvckJhcic6ICdcXHUyOTU4JyxcbiAgICAnTGVmdFZlY3Rvcic6ICdcXHUyMUJDJyxcbiAgICAnbGVmdGhhcnBvb251cCc6ICdcXHUyMUJDJyxcbiAgICAnbGhhcnUnOiAnXFx1MjFCQycsXG4gICAgJ0xlZnRWZWN0b3JCYXInOiAnXFx1Mjk1MicsXG4gICAgJ0xlc3NFcXVhbEdyZWF0ZXInOiAnXFx1MjJEQScsXG4gICAgJ2xlZyc6ICdcXHUyMkRBJyxcbiAgICAnbGVzc2VxZ3RyJzogJ1xcdTIyREEnLFxuICAgICdMZXNzRnVsbEVxdWFsJzogJ1xcdTIyNjYnLFxuICAgICdsRSc6ICdcXHUyMjY2JyxcbiAgICAnbGVxcSc6ICdcXHUyMjY2JyxcbiAgICAnTGVzc0dyZWF0ZXInOiAnXFx1MjI3NicsXG4gICAgJ2xlc3NndHInOiAnXFx1MjI3NicsXG4gICAgJ2xnJzogJ1xcdTIyNzYnLFxuICAgICdMZXNzTGVzcyc6ICdcXHUyQUExJyxcbiAgICAnTGVzc1NsYW50RXF1YWwnOiAnXFx1MkE3RCcsXG4gICAgJ2xlcXNsYW50JzogJ1xcdTJBN0QnLFxuICAgICdsZXMnOiAnXFx1MkE3RCcsXG4gICAgJ0xlc3NUaWxkZSc6ICdcXHUyMjcyJyxcbiAgICAnbGVzc3NpbSc6ICdcXHUyMjcyJyxcbiAgICAnbHNpbSc6ICdcXHUyMjcyJyxcbiAgICAnTGZyJzogJ1xcdUQ4MzVcXHVERDBGJyxcbiAgICAnTGwnOiAnXFx1MjJEOCcsXG4gICAgJ0xsZWZ0YXJyb3cnOiAnXFx1MjFEQScsXG4gICAgJ2xBYXJyJzogJ1xcdTIxREEnLFxuICAgICdMbWlkb3QnOiAnXFx1MDEzRicsXG4gICAgJ0xvbmdMZWZ0QXJyb3cnOiAnXFx1MjdGNScsXG4gICAgJ2xvbmdsZWZ0YXJyb3cnOiAnXFx1MjdGNScsXG4gICAgJ3hsYXJyJzogJ1xcdTI3RjUnLFxuICAgICdMb25nTGVmdFJpZ2h0QXJyb3cnOiAnXFx1MjdGNycsXG4gICAgJ2xvbmdsZWZ0cmlnaHRhcnJvdyc6ICdcXHUyN0Y3JyxcbiAgICAneGhhcnInOiAnXFx1MjdGNycsXG4gICAgJ0xvbmdSaWdodEFycm93JzogJ1xcdTI3RjYnLFxuICAgICdsb25ncmlnaHRhcnJvdyc6ICdcXHUyN0Y2JyxcbiAgICAneHJhcnInOiAnXFx1MjdGNicsXG4gICAgJ0xvcGYnOiAnXFx1RDgzNVxcdURENDMnLFxuICAgICdMb3dlckxlZnRBcnJvdyc6ICdcXHUyMTk5JyxcbiAgICAnc3dhcnInOiAnXFx1MjE5OScsXG4gICAgJ3N3YXJyb3cnOiAnXFx1MjE5OScsXG4gICAgJ0xvd2VyUmlnaHRBcnJvdyc6ICdcXHUyMTk4JyxcbiAgICAnc2VhcnInOiAnXFx1MjE5OCcsXG4gICAgJ3NlYXJyb3cnOiAnXFx1MjE5OCcsXG4gICAgJ0xzaCc6ICdcXHUyMUIwJyxcbiAgICAnbHNoJzogJ1xcdTIxQjAnLFxuICAgICdMc3Ryb2snOiAnXFx1MDE0MScsXG4gICAgJ0x0JzogJ1xcdTIyNkEnLFxuICAgICdOZXN0ZWRMZXNzTGVzcyc6ICdcXHUyMjZBJyxcbiAgICAnbGwnOiAnXFx1MjI2QScsXG4gICAgJ01hcCc6ICdcXHUyOTA1JyxcbiAgICAnTWN5JzogJ1xcdTA0MUMnLFxuICAgICdNZWRpdW1TcGFjZSc6ICdcXHUyMDVGJyxcbiAgICAnTWVsbGludHJmJzogJ1xcdTIxMzMnLFxuICAgICdNc2NyJzogJ1xcdTIxMzMnLFxuICAgICdwaG1tYXQnOiAnXFx1MjEzMycsXG4gICAgJ01mcic6ICdcXHVEODM1XFx1REQxMCcsXG4gICAgJ01pbnVzUGx1cyc6ICdcXHUyMjEzJyxcbiAgICAnbW5wbHVzJzogJ1xcdTIyMTMnLFxuICAgICdtcCc6ICdcXHUyMjEzJyxcbiAgICAnTW9wZic6ICdcXHVEODM1XFx1REQ0NCcsXG4gICAgJ011JzogJ1xcdTAzOUMnLFxuICAgICdOSmN5JzogJ1xcdTA0MEEnLFxuICAgICdOYWN1dGUnOiAnXFx1MDE0MycsXG4gICAgJ05jYXJvbic6ICdcXHUwMTQ3JyxcbiAgICAnTmNlZGlsJzogJ1xcdTAxNDUnLFxuICAgICdOY3knOiAnXFx1MDQxRCcsXG4gICAgJ05lZ2F0aXZlTWVkaXVtU3BhY2UnOiAnXFx1MjAwQicsXG4gICAgJ05lZ2F0aXZlVGhpY2tTcGFjZSc6ICdcXHUyMDBCJyxcbiAgICAnTmVnYXRpdmVUaGluU3BhY2UnOiAnXFx1MjAwQicsXG4gICAgJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZSc6ICdcXHUyMDBCJyxcbiAgICAnWmVyb1dpZHRoU3BhY2UnOiAnXFx1MjAwQicsXG4gICAgJ05ld0xpbmUnOiAnXFx1MDAwQScsXG4gICAgJ05mcic6ICdcXHVEODM1XFx1REQxMScsXG4gICAgJ05vQnJlYWsnOiAnXFx1MjA2MCcsXG4gICAgJ05vbkJyZWFraW5nU3BhY2UnOiAnXFx1MDBBMCcsXG4gICAgJ25ic3AnOiAnXFx1MDBBMCcsXG4gICAgJ05vcGYnOiAnXFx1MjExNScsXG4gICAgJ25hdHVyYWxzJzogJ1xcdTIxMTUnLFxuICAgICdOb3QnOiAnXFx1MkFFQycsXG4gICAgJ05vdENvbmdydWVudCc6ICdcXHUyMjYyJyxcbiAgICAnbmVxdWl2JzogJ1xcdTIyNjInLFxuICAgICdOb3RDdXBDYXAnOiAnXFx1MjI2RCcsXG4gICAgJ05vdERvdWJsZVZlcnRpY2FsQmFyJzogJ1xcdTIyMjYnLFxuICAgICducGFyJzogJ1xcdTIyMjYnLFxuICAgICducGFyYWxsZWwnOiAnXFx1MjIyNicsXG4gICAgJ25zaG9ydHBhcmFsbGVsJzogJ1xcdTIyMjYnLFxuICAgICduc3Bhcic6ICdcXHUyMjI2JyxcbiAgICAnTm90RWxlbWVudCc6ICdcXHUyMjA5JyxcbiAgICAnbm90aW4nOiAnXFx1MjIwOScsXG4gICAgJ25vdGludmEnOiAnXFx1MjIwOScsXG4gICAgJ05vdEVxdWFsJzogJ1xcdTIyNjAnLFxuICAgICduZSc6ICdcXHUyMjYwJyxcbiAgICAnTm90RXF1YWxUaWxkZSc6ICdcXHUyMjQyXFx1MDMzOCcsXG4gICAgJ25lc2ltJzogJ1xcdTIyNDJcXHUwMzM4JyxcbiAgICAnTm90RXhpc3RzJzogJ1xcdTIyMDQnLFxuICAgICduZXhpc3QnOiAnXFx1MjIwNCcsXG4gICAgJ25leGlzdHMnOiAnXFx1MjIwNCcsXG4gICAgJ05vdEdyZWF0ZXInOiAnXFx1MjI2RicsXG4gICAgJ25ndCc6ICdcXHUyMjZGJyxcbiAgICAnbmd0cic6ICdcXHUyMjZGJyxcbiAgICAnTm90R3JlYXRlckVxdWFsJzogJ1xcdTIyNzEnLFxuICAgICduZ2UnOiAnXFx1MjI3MScsXG4gICAgJ25nZXEnOiAnXFx1MjI3MScsXG4gICAgJ05vdEdyZWF0ZXJGdWxsRXF1YWwnOiAnXFx1MjI2N1xcdTAzMzgnLFxuICAgICduZ0UnOiAnXFx1MjI2N1xcdTAzMzgnLFxuICAgICduZ2VxcSc6ICdcXHUyMjY3XFx1MDMzOCcsXG4gICAgJ05vdEdyZWF0ZXJHcmVhdGVyJzogJ1xcdTIyNkJcXHUwMzM4JyxcbiAgICAnbkd0dic6ICdcXHUyMjZCXFx1MDMzOCcsXG4gICAgJ05vdEdyZWF0ZXJMZXNzJzogJ1xcdTIyNzknLFxuICAgICdudGdsJzogJ1xcdTIyNzknLFxuICAgICdOb3RHcmVhdGVyU2xhbnRFcXVhbCc6ICdcXHUyQTdFXFx1MDMzOCcsXG4gICAgJ25nZXFzbGFudCc6ICdcXHUyQTdFXFx1MDMzOCcsXG4gICAgJ25nZXMnOiAnXFx1MkE3RVxcdTAzMzgnLFxuICAgICdOb3RHcmVhdGVyVGlsZGUnOiAnXFx1MjI3NScsXG4gICAgJ25nc2ltJzogJ1xcdTIyNzUnLFxuICAgICdOb3RIdW1wRG93bkh1bXAnOiAnXFx1MjI0RVxcdTAzMzgnLFxuICAgICduYnVtcCc6ICdcXHUyMjRFXFx1MDMzOCcsXG4gICAgJ05vdEh1bXBFcXVhbCc6ICdcXHUyMjRGXFx1MDMzOCcsXG4gICAgJ25idW1wZSc6ICdcXHUyMjRGXFx1MDMzOCcsXG4gICAgJ05vdExlZnRUcmlhbmdsZSc6ICdcXHUyMkVBJyxcbiAgICAnbmx0cmknOiAnXFx1MjJFQScsXG4gICAgJ250cmlhbmdsZWxlZnQnOiAnXFx1MjJFQScsXG4gICAgJ05vdExlZnRUcmlhbmdsZUJhcic6ICdcXHUyOUNGXFx1MDMzOCcsXG4gICAgJ05vdExlZnRUcmlhbmdsZUVxdWFsJzogJ1xcdTIyRUMnLFxuICAgICdubHRyaWUnOiAnXFx1MjJFQycsXG4gICAgJ250cmlhbmdsZWxlZnRlcSc6ICdcXHUyMkVDJyxcbiAgICAnTm90TGVzcyc6ICdcXHUyMjZFJyxcbiAgICAnbmxlc3MnOiAnXFx1MjI2RScsXG4gICAgJ25sdCc6ICdcXHUyMjZFJyxcbiAgICAnTm90TGVzc0VxdWFsJzogJ1xcdTIyNzAnLFxuICAgICdubGUnOiAnXFx1MjI3MCcsXG4gICAgJ25sZXEnOiAnXFx1MjI3MCcsXG4gICAgJ05vdExlc3NHcmVhdGVyJzogJ1xcdTIyNzgnLFxuICAgICdudGxnJzogJ1xcdTIyNzgnLFxuICAgICdOb3RMZXNzTGVzcyc6ICdcXHUyMjZBXFx1MDMzOCcsXG4gICAgJ25MdHYnOiAnXFx1MjI2QVxcdTAzMzgnLFxuICAgICdOb3RMZXNzU2xhbnRFcXVhbCc6ICdcXHUyQTdEXFx1MDMzOCcsXG4gICAgJ25sZXFzbGFudCc6ICdcXHUyQTdEXFx1MDMzOCcsXG4gICAgJ25sZXMnOiAnXFx1MkE3RFxcdTAzMzgnLFxuICAgICdOb3RMZXNzVGlsZGUnOiAnXFx1MjI3NCcsXG4gICAgJ25sc2ltJzogJ1xcdTIyNzQnLFxuICAgICdOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcic6ICdcXHUyQUEyXFx1MDMzOCcsXG4gICAgJ05vdE5lc3RlZExlc3NMZXNzJzogJ1xcdTJBQTFcXHUwMzM4JyxcbiAgICAnTm90UHJlY2VkZXMnOiAnXFx1MjI4MCcsXG4gICAgJ25wcic6ICdcXHUyMjgwJyxcbiAgICAnbnByZWMnOiAnXFx1MjI4MCcsXG4gICAgJ05vdFByZWNlZGVzRXF1YWwnOiAnXFx1MkFBRlxcdTAzMzgnLFxuICAgICducHJlJzogJ1xcdTJBQUZcXHUwMzM4JyxcbiAgICAnbnByZWNlcSc6ICdcXHUyQUFGXFx1MDMzOCcsXG4gICAgJ05vdFByZWNlZGVzU2xhbnRFcXVhbCc6ICdcXHUyMkUwJyxcbiAgICAnbnByY3VlJzogJ1xcdTIyRTAnLFxuICAgICdOb3RSZXZlcnNlRWxlbWVudCc6ICdcXHUyMjBDJyxcbiAgICAnbm90bmknOiAnXFx1MjIwQycsXG4gICAgJ25vdG5pdmEnOiAnXFx1MjIwQycsXG4gICAgJ05vdFJpZ2h0VHJpYW5nbGUnOiAnXFx1MjJFQicsXG4gICAgJ25ydHJpJzogJ1xcdTIyRUInLFxuICAgICdudHJpYW5nbGVyaWdodCc6ICdcXHUyMkVCJyxcbiAgICAnTm90UmlnaHRUcmlhbmdsZUJhcic6ICdcXHUyOUQwXFx1MDMzOCcsXG4gICAgJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCc6ICdcXHUyMkVEJyxcbiAgICAnbnJ0cmllJzogJ1xcdTIyRUQnLFxuICAgICdudHJpYW5nbGVyaWdodGVxJzogJ1xcdTIyRUQnLFxuICAgICdOb3RTcXVhcmVTdWJzZXQnOiAnXFx1MjI4RlxcdTAzMzgnLFxuICAgICdOb3RTcXVhcmVTdWJzZXRFcXVhbCc6ICdcXHUyMkUyJyxcbiAgICAnbnNxc3ViZSc6ICdcXHUyMkUyJyxcbiAgICAnTm90U3F1YXJlU3VwZXJzZXQnOiAnXFx1MjI5MFxcdTAzMzgnLFxuICAgICdOb3RTcXVhcmVTdXBlcnNldEVxdWFsJzogJ1xcdTIyRTMnLFxuICAgICduc3FzdXBlJzogJ1xcdTIyRTMnLFxuICAgICdOb3RTdWJzZXQnOiAnXFx1MjI4MlxcdTIwRDInLFxuICAgICduc3Vic2V0JzogJ1xcdTIyODJcXHUyMEQyJyxcbiAgICAndm5zdWInOiAnXFx1MjI4MlxcdTIwRDInLFxuICAgICdOb3RTdWJzZXRFcXVhbCc6ICdcXHUyMjg4JyxcbiAgICAnbnN1YmUnOiAnXFx1MjI4OCcsXG4gICAgJ25zdWJzZXRlcSc6ICdcXHUyMjg4JyxcbiAgICAnTm90U3VjY2VlZHMnOiAnXFx1MjI4MScsXG4gICAgJ25zYyc6ICdcXHUyMjgxJyxcbiAgICAnbnN1Y2MnOiAnXFx1MjI4MScsXG4gICAgJ05vdFN1Y2NlZWRzRXF1YWwnOiAnXFx1MkFCMFxcdTAzMzgnLFxuICAgICduc2NlJzogJ1xcdTJBQjBcXHUwMzM4JyxcbiAgICAnbnN1Y2NlcSc6ICdcXHUyQUIwXFx1MDMzOCcsXG4gICAgJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCc6ICdcXHUyMkUxJyxcbiAgICAnbnNjY3VlJzogJ1xcdTIyRTEnLFxuICAgICdOb3RTdWNjZWVkc1RpbGRlJzogJ1xcdTIyN0ZcXHUwMzM4JyxcbiAgICAnTm90U3VwZXJzZXQnOiAnXFx1MjI4M1xcdTIwRDInLFxuICAgICduc3Vwc2V0JzogJ1xcdTIyODNcXHUyMEQyJyxcbiAgICAndm5zdXAnOiAnXFx1MjI4M1xcdTIwRDInLFxuICAgICdOb3RTdXBlcnNldEVxdWFsJzogJ1xcdTIyODknLFxuICAgICduc3VwZSc6ICdcXHUyMjg5JyxcbiAgICAnbnN1cHNldGVxJzogJ1xcdTIyODknLFxuICAgICdOb3RUaWxkZSc6ICdcXHUyMjQxJyxcbiAgICAnbnNpbSc6ICdcXHUyMjQxJyxcbiAgICAnTm90VGlsZGVFcXVhbCc6ICdcXHUyMjQ0JyxcbiAgICAnbnNpbWUnOiAnXFx1MjI0NCcsXG4gICAgJ25zaW1lcSc6ICdcXHUyMjQ0JyxcbiAgICAnTm90VGlsZGVGdWxsRXF1YWwnOiAnXFx1MjI0NycsXG4gICAgJ25jb25nJzogJ1xcdTIyNDcnLFxuICAgICdOb3RUaWxkZVRpbGRlJzogJ1xcdTIyNDknLFxuICAgICduYXAnOiAnXFx1MjI0OScsXG4gICAgJ25hcHByb3gnOiAnXFx1MjI0OScsXG4gICAgJ05vdFZlcnRpY2FsQmFyJzogJ1xcdTIyMjQnLFxuICAgICdubWlkJzogJ1xcdTIyMjQnLFxuICAgICduc2hvcnRtaWQnOiAnXFx1MjIyNCcsXG4gICAgJ25zbWlkJzogJ1xcdTIyMjQnLFxuICAgICdOc2NyJzogJ1xcdUQ4MzVcXHVEQ0E5JyxcbiAgICAnTnRpbGRlJzogJ1xcdTAwRDEnLFxuICAgICdOdSc6ICdcXHUwMzlEJyxcbiAgICAnT0VsaWcnOiAnXFx1MDE1MicsXG4gICAgJ09hY3V0ZSc6ICdcXHUwMEQzJyxcbiAgICAnT2NpcmMnOiAnXFx1MDBENCcsXG4gICAgJ09jeSc6ICdcXHUwNDFFJyxcbiAgICAnT2RibGFjJzogJ1xcdTAxNTAnLFxuICAgICdPZnInOiAnXFx1RDgzNVxcdUREMTInLFxuICAgICdPZ3JhdmUnOiAnXFx1MDBEMicsXG4gICAgJ09tYWNyJzogJ1xcdTAxNEMnLFxuICAgICdPbWVnYSc6ICdcXHUwM0E5JyxcbiAgICAnb2htJzogJ1xcdTAzQTknLFxuICAgICdPbWljcm9uJzogJ1xcdTAzOUYnLFxuICAgICdPb3BmJzogJ1xcdUQ4MzVcXHVERDQ2JyxcbiAgICAnT3BlbkN1cmx5RG91YmxlUXVvdGUnOiAnXFx1MjAxQycsXG4gICAgJ2xkcXVvJzogJ1xcdTIwMUMnLFxuICAgICdPcGVuQ3VybHlRdW90ZSc6ICdcXHUyMDE4JyxcbiAgICAnbHNxdW8nOiAnXFx1MjAxOCcsXG4gICAgJ09yJzogJ1xcdTJBNTQnLFxuICAgICdPc2NyJzogJ1xcdUQ4MzVcXHVEQ0FBJyxcbiAgICAnT3NsYXNoJzogJ1xcdTAwRDgnLFxuICAgICdPdGlsZGUnOiAnXFx1MDBENScsXG4gICAgJ090aW1lcyc6ICdcXHUyQTM3JyxcbiAgICAnT3VtbCc6ICdcXHUwMEQ2JyxcbiAgICAnT3ZlckJhcic6ICdcXHUyMDNFJyxcbiAgICAnb2xpbmUnOiAnXFx1MjAzRScsXG4gICAgJ092ZXJCcmFjZSc6ICdcXHUyM0RFJyxcbiAgICAnT3ZlckJyYWNrZXQnOiAnXFx1MjNCNCcsXG4gICAgJ3RicmsnOiAnXFx1MjNCNCcsXG4gICAgJ092ZXJQYXJlbnRoZXNpcyc6ICdcXHUyM0RDJyxcbiAgICAnUGFydGlhbEQnOiAnXFx1MjIwMicsXG4gICAgJ3BhcnQnOiAnXFx1MjIwMicsXG4gICAgJ1BjeSc6ICdcXHUwNDFGJyxcbiAgICAnUGZyJzogJ1xcdUQ4MzVcXHVERDEzJyxcbiAgICAnUGhpJzogJ1xcdTAzQTYnLFxuICAgICdQaSc6ICdcXHUwM0EwJyxcbiAgICAnUGx1c01pbnVzJzogJ1xcdTAwQjEnLFxuICAgICdwbHVzbW4nOiAnXFx1MDBCMScsXG4gICAgJ3BtJzogJ1xcdTAwQjEnLFxuICAgICdQb3BmJzogJ1xcdTIxMTknLFxuICAgICdwcmltZXMnOiAnXFx1MjExOScsXG4gICAgJ1ByJzogJ1xcdTJBQkInLFxuICAgICdQcmVjZWRlcyc6ICdcXHUyMjdBJyxcbiAgICAncHInOiAnXFx1MjI3QScsXG4gICAgJ3ByZWMnOiAnXFx1MjI3QScsXG4gICAgJ1ByZWNlZGVzRXF1YWwnOiAnXFx1MkFBRicsXG4gICAgJ3ByZSc6ICdcXHUyQUFGJyxcbiAgICAncHJlY2VxJzogJ1xcdTJBQUYnLFxuICAgICdQcmVjZWRlc1NsYW50RXF1YWwnOiAnXFx1MjI3QycsXG4gICAgJ3ByY3VlJzogJ1xcdTIyN0MnLFxuICAgICdwcmVjY3VybHllcSc6ICdcXHUyMjdDJyxcbiAgICAnUHJlY2VkZXNUaWxkZSc6ICdcXHUyMjdFJyxcbiAgICAncHJlY3NpbSc6ICdcXHUyMjdFJyxcbiAgICAncHJzaW0nOiAnXFx1MjI3RScsXG4gICAgJ1ByaW1lJzogJ1xcdTIwMzMnLFxuICAgICdQcm9kdWN0JzogJ1xcdTIyMEYnLFxuICAgICdwcm9kJzogJ1xcdTIyMEYnLFxuICAgICdQcm9wb3J0aW9uYWwnOiAnXFx1MjIxRCcsXG4gICAgJ3Byb3AnOiAnXFx1MjIxRCcsXG4gICAgJ3Byb3B0byc6ICdcXHUyMjFEJyxcbiAgICAndmFycHJvcHRvJzogJ1xcdTIyMUQnLFxuICAgICd2cHJvcCc6ICdcXHUyMjFEJyxcbiAgICAnUHNjcic6ICdcXHVEODM1XFx1RENBQicsXG4gICAgJ1BzaSc6ICdcXHUwM0E4JyxcbiAgICAnUVVPVCc6ICdcXHUwMDIyJyxcbiAgICAncXVvdCc6ICdcXHUwMDIyJyxcbiAgICAnUWZyJzogJ1xcdUQ4MzVcXHVERDE0JyxcbiAgICAnUW9wZic6ICdcXHUyMTFBJyxcbiAgICAncmF0aW9uYWxzJzogJ1xcdTIxMUEnLFxuICAgICdRc2NyJzogJ1xcdUQ4MzVcXHVEQ0FDJyxcbiAgICAnUkJhcnInOiAnXFx1MjkxMCcsXG4gICAgJ2RyYmthcm93JzogJ1xcdTI5MTAnLFxuICAgICdSRUcnOiAnXFx1MDBBRScsXG4gICAgJ2NpcmNsZWRSJzogJ1xcdTAwQUUnLFxuICAgICdyZWcnOiAnXFx1MDBBRScsXG4gICAgJ1JhY3V0ZSc6ICdcXHUwMTU0JyxcbiAgICAnUmFuZyc6ICdcXHUyN0VCJyxcbiAgICAnUmFycic6ICdcXHUyMUEwJyxcbiAgICAndHdvaGVhZHJpZ2h0YXJyb3cnOiAnXFx1MjFBMCcsXG4gICAgJ1JhcnJ0bCc6ICdcXHUyOTE2JyxcbiAgICAnUmNhcm9uJzogJ1xcdTAxNTgnLFxuICAgICdSY2VkaWwnOiAnXFx1MDE1NicsXG4gICAgJ1JjeSc6ICdcXHUwNDIwJyxcbiAgICAnUmUnOiAnXFx1MjExQycsXG4gICAgJ1Jmcic6ICdcXHUyMTFDJyxcbiAgICAncmVhbCc6ICdcXHUyMTFDJyxcbiAgICAncmVhbHBhcnQnOiAnXFx1MjExQycsXG4gICAgJ1JldmVyc2VFbGVtZW50JzogJ1xcdTIyMEInLFxuICAgICdTdWNoVGhhdCc6ICdcXHUyMjBCJyxcbiAgICAnbmknOiAnXFx1MjIwQicsXG4gICAgJ25pdic6ICdcXHUyMjBCJyxcbiAgICAnUmV2ZXJzZUVxdWlsaWJyaXVtJzogJ1xcdTIxQ0InLFxuICAgICdsZWZ0cmlnaHRoYXJwb29ucyc6ICdcXHUyMUNCJyxcbiAgICAnbHJoYXInOiAnXFx1MjFDQicsXG4gICAgJ1JldmVyc2VVcEVxdWlsaWJyaXVtJzogJ1xcdTI5NkYnLFxuICAgICdkdWhhcic6ICdcXHUyOTZGJyxcbiAgICAnUmhvJzogJ1xcdTAzQTEnLFxuICAgICdSaWdodEFuZ2xlQnJhY2tldCc6ICdcXHUyN0U5JyxcbiAgICAncmFuZyc6ICdcXHUyN0U5JyxcbiAgICAncmFuZ2xlJzogJ1xcdTI3RTknLFxuICAgICdSaWdodEFycm93JzogJ1xcdTIxOTInLFxuICAgICdTaG9ydFJpZ2h0QXJyb3cnOiAnXFx1MjE5MicsXG4gICAgJ3JhcnInOiAnXFx1MjE5MicsXG4gICAgJ3JpZ2h0YXJyb3cnOiAnXFx1MjE5MicsXG4gICAgJ3NyYXJyJzogJ1xcdTIxOTInLFxuICAgICdSaWdodEFycm93QmFyJzogJ1xcdTIxRTUnLFxuICAgICdyYXJyYic6ICdcXHUyMUU1JyxcbiAgICAnUmlnaHRBcnJvd0xlZnRBcnJvdyc6ICdcXHUyMUM0JyxcbiAgICAncmlnaHRsZWZ0YXJyb3dzJzogJ1xcdTIxQzQnLFxuICAgICdybGFycic6ICdcXHUyMUM0JyxcbiAgICAnUmlnaHRDZWlsaW5nJzogJ1xcdTIzMDknLFxuICAgICdyY2VpbCc6ICdcXHUyMzA5JyxcbiAgICAnUmlnaHREb3VibGVCcmFja2V0JzogJ1xcdTI3RTcnLFxuICAgICdyb2Jyayc6ICdcXHUyN0U3JyxcbiAgICAnUmlnaHREb3duVGVlVmVjdG9yJzogJ1xcdTI5NUQnLFxuICAgICdSaWdodERvd25WZWN0b3InOiAnXFx1MjFDMicsXG4gICAgJ2RoYXJyJzogJ1xcdTIxQzInLFxuICAgICdkb3duaGFycG9vbnJpZ2h0JzogJ1xcdTIxQzInLFxuICAgICdSaWdodERvd25WZWN0b3JCYXInOiAnXFx1Mjk1NScsXG4gICAgJ1JpZ2h0Rmxvb3InOiAnXFx1MjMwQicsXG4gICAgJ3JmbG9vcic6ICdcXHUyMzBCJyxcbiAgICAnUmlnaHRUZWUnOiAnXFx1MjJBMicsXG4gICAgJ3ZkYXNoJzogJ1xcdTIyQTInLFxuICAgICdSaWdodFRlZUFycm93JzogJ1xcdTIxQTYnLFxuICAgICdtYXAnOiAnXFx1MjFBNicsXG4gICAgJ21hcHN0byc6ICdcXHUyMUE2JyxcbiAgICAnUmlnaHRUZWVWZWN0b3InOiAnXFx1Mjk1QicsXG4gICAgJ1JpZ2h0VHJpYW5nbGUnOiAnXFx1MjJCMycsXG4gICAgJ3ZhcnRyaWFuZ2xlcmlnaHQnOiAnXFx1MjJCMycsXG4gICAgJ3ZydHJpJzogJ1xcdTIyQjMnLFxuICAgICdSaWdodFRyaWFuZ2xlQmFyJzogJ1xcdTI5RDAnLFxuICAgICdSaWdodFRyaWFuZ2xlRXF1YWwnOiAnXFx1MjJCNScsXG4gICAgJ3J0cmllJzogJ1xcdTIyQjUnLFxuICAgICd0cmlhbmdsZXJpZ2h0ZXEnOiAnXFx1MjJCNScsXG4gICAgJ1JpZ2h0VXBEb3duVmVjdG9yJzogJ1xcdTI5NEYnLFxuICAgICdSaWdodFVwVGVlVmVjdG9yJzogJ1xcdTI5NUMnLFxuICAgICdSaWdodFVwVmVjdG9yJzogJ1xcdTIxQkUnLFxuICAgICd1aGFycic6ICdcXHUyMUJFJyxcbiAgICAndXBoYXJwb29ucmlnaHQnOiAnXFx1MjFCRScsXG4gICAgJ1JpZ2h0VXBWZWN0b3JCYXInOiAnXFx1Mjk1NCcsXG4gICAgJ1JpZ2h0VmVjdG9yJzogJ1xcdTIxQzAnLFxuICAgICdyaGFydSc6ICdcXHUyMUMwJyxcbiAgICAncmlnaHRoYXJwb29udXAnOiAnXFx1MjFDMCcsXG4gICAgJ1JpZ2h0VmVjdG9yQmFyJzogJ1xcdTI5NTMnLFxuICAgICdSb3BmJzogJ1xcdTIxMUQnLFxuICAgICdyZWFscyc6ICdcXHUyMTFEJyxcbiAgICAnUm91bmRJbXBsaWVzJzogJ1xcdTI5NzAnLFxuICAgICdScmlnaHRhcnJvdyc6ICdcXHUyMURCJyxcbiAgICAnckFhcnInOiAnXFx1MjFEQicsXG4gICAgJ1JzY3InOiAnXFx1MjExQicsXG4gICAgJ3JlYWxpbmUnOiAnXFx1MjExQicsXG4gICAgJ1JzaCc6ICdcXHUyMUIxJyxcbiAgICAncnNoJzogJ1xcdTIxQjEnLFxuICAgICdSdWxlRGVsYXllZCc6ICdcXHUyOUY0JyxcbiAgICAnU0hDSGN5JzogJ1xcdTA0MjknLFxuICAgICdTSGN5JzogJ1xcdTA0MjgnLFxuICAgICdTT0ZUY3knOiAnXFx1MDQyQycsXG4gICAgJ1NhY3V0ZSc6ICdcXHUwMTVBJyxcbiAgICAnU2MnOiAnXFx1MkFCQycsXG4gICAgJ1NjYXJvbic6ICdcXHUwMTYwJyxcbiAgICAnU2NlZGlsJzogJ1xcdTAxNUUnLFxuICAgICdTY2lyYyc6ICdcXHUwMTVDJyxcbiAgICAnU2N5JzogJ1xcdTA0MjEnLFxuICAgICdTZnInOiAnXFx1RDgzNVxcdUREMTYnLFxuICAgICdTaG9ydFVwQXJyb3cnOiAnXFx1MjE5MScsXG4gICAgJ1VwQXJyb3cnOiAnXFx1MjE5MScsXG4gICAgJ3VhcnInOiAnXFx1MjE5MScsXG4gICAgJ3VwYXJyb3cnOiAnXFx1MjE5MScsXG4gICAgJ1NpZ21hJzogJ1xcdTAzQTMnLFxuICAgICdTbWFsbENpcmNsZSc6ICdcXHUyMjE4JyxcbiAgICAnY29tcGZuJzogJ1xcdTIyMTgnLFxuICAgICdTb3BmJzogJ1xcdUQ4MzVcXHVERDRBJyxcbiAgICAnU3FydCc6ICdcXHUyMjFBJyxcbiAgICAncmFkaWMnOiAnXFx1MjIxQScsXG4gICAgJ1NxdWFyZSc6ICdcXHUyNUExJyxcbiAgICAnc3F1JzogJ1xcdTI1QTEnLFxuICAgICdzcXVhcmUnOiAnXFx1MjVBMScsXG4gICAgJ1NxdWFyZUludGVyc2VjdGlvbic6ICdcXHUyMjkzJyxcbiAgICAnc3FjYXAnOiAnXFx1MjI5MycsXG4gICAgJ1NxdWFyZVN1YnNldCc6ICdcXHUyMjhGJyxcbiAgICAnc3FzdWInOiAnXFx1MjI4RicsXG4gICAgJ3Nxc3Vic2V0JzogJ1xcdTIyOEYnLFxuICAgICdTcXVhcmVTdWJzZXRFcXVhbCc6ICdcXHUyMjkxJyxcbiAgICAnc3FzdWJlJzogJ1xcdTIyOTEnLFxuICAgICdzcXN1YnNldGVxJzogJ1xcdTIyOTEnLFxuICAgICdTcXVhcmVTdXBlcnNldCc6ICdcXHUyMjkwJyxcbiAgICAnc3FzdXAnOiAnXFx1MjI5MCcsXG4gICAgJ3Nxc3Vwc2V0JzogJ1xcdTIyOTAnLFxuICAgICdTcXVhcmVTdXBlcnNldEVxdWFsJzogJ1xcdTIyOTInLFxuICAgICdzcXN1cGUnOiAnXFx1MjI5MicsXG4gICAgJ3Nxc3Vwc2V0ZXEnOiAnXFx1MjI5MicsXG4gICAgJ1NxdWFyZVVuaW9uJzogJ1xcdTIyOTQnLFxuICAgICdzcWN1cCc6ICdcXHUyMjk0JyxcbiAgICAnU3Njcic6ICdcXHVEODM1XFx1RENBRScsXG4gICAgJ1N0YXInOiAnXFx1MjJDNicsXG4gICAgJ3NzdGFyZic6ICdcXHUyMkM2JyxcbiAgICAnU3ViJzogJ1xcdTIyRDAnLFxuICAgICdTdWJzZXQnOiAnXFx1MjJEMCcsXG4gICAgJ1N1YnNldEVxdWFsJzogJ1xcdTIyODYnLFxuICAgICdzdWJlJzogJ1xcdTIyODYnLFxuICAgICdzdWJzZXRlcSc6ICdcXHUyMjg2JyxcbiAgICAnU3VjY2VlZHMnOiAnXFx1MjI3QicsXG4gICAgJ3NjJzogJ1xcdTIyN0InLFxuICAgICdzdWNjJzogJ1xcdTIyN0InLFxuICAgICdTdWNjZWVkc0VxdWFsJzogJ1xcdTJBQjAnLFxuICAgICdzY2UnOiAnXFx1MkFCMCcsXG4gICAgJ3N1Y2NlcSc6ICdcXHUyQUIwJyxcbiAgICAnU3VjY2VlZHNTbGFudEVxdWFsJzogJ1xcdTIyN0QnLFxuICAgICdzY2N1ZSc6ICdcXHUyMjdEJyxcbiAgICAnc3VjY2N1cmx5ZXEnOiAnXFx1MjI3RCcsXG4gICAgJ1N1Y2NlZWRzVGlsZGUnOiAnXFx1MjI3RicsXG4gICAgJ3Njc2ltJzogJ1xcdTIyN0YnLFxuICAgICdzdWNjc2ltJzogJ1xcdTIyN0YnLFxuICAgICdTdW0nOiAnXFx1MjIxMScsXG4gICAgJ3N1bSc6ICdcXHUyMjExJyxcbiAgICAnU3VwJzogJ1xcdTIyRDEnLFxuICAgICdTdXBzZXQnOiAnXFx1MjJEMScsXG4gICAgJ1N1cGVyc2V0JzogJ1xcdTIyODMnLFxuICAgICdzdXAnOiAnXFx1MjI4MycsXG4gICAgJ3N1cHNldCc6ICdcXHUyMjgzJyxcbiAgICAnU3VwZXJzZXRFcXVhbCc6ICdcXHUyMjg3JyxcbiAgICAnc3VwZSc6ICdcXHUyMjg3JyxcbiAgICAnc3Vwc2V0ZXEnOiAnXFx1MjI4NycsXG4gICAgJ1RIT1JOJzogJ1xcdTAwREUnLFxuICAgICdUUkFERSc6ICdcXHUyMTIyJyxcbiAgICAndHJhZGUnOiAnXFx1MjEyMicsXG4gICAgJ1RTSGN5JzogJ1xcdTA0MEInLFxuICAgICdUU2N5JzogJ1xcdTA0MjYnLFxuICAgICdUYWInOiAnXFx1MDAwOScsXG4gICAgJ1RhdSc6ICdcXHUwM0E0JyxcbiAgICAnVGNhcm9uJzogJ1xcdTAxNjQnLFxuICAgICdUY2VkaWwnOiAnXFx1MDE2MicsXG4gICAgJ1RjeSc6ICdcXHUwNDIyJyxcbiAgICAnVGZyJzogJ1xcdUQ4MzVcXHVERDE3JyxcbiAgICAnVGhlcmVmb3JlJzogJ1xcdTIyMzQnLFxuICAgICd0aGVyZTQnOiAnXFx1MjIzNCcsXG4gICAgJ3RoZXJlZm9yZSc6ICdcXHUyMjM0JyxcbiAgICAnVGhldGEnOiAnXFx1MDM5OCcsXG4gICAgJ1RoaWNrU3BhY2UnOiAnXFx1MjA1RlxcdTIwMEEnLFxuICAgICdUaGluU3BhY2UnOiAnXFx1MjAwOScsXG4gICAgJ3RoaW5zcCc6ICdcXHUyMDA5JyxcbiAgICAnVGlsZGUnOiAnXFx1MjIzQycsXG4gICAgJ3NpbSc6ICdcXHUyMjNDJyxcbiAgICAndGhpY2tzaW0nOiAnXFx1MjIzQycsXG4gICAgJ3Roa3NpbSc6ICdcXHUyMjNDJyxcbiAgICAnVGlsZGVFcXVhbCc6ICdcXHUyMjQzJyxcbiAgICAnc2ltZSc6ICdcXHUyMjQzJyxcbiAgICAnc2ltZXEnOiAnXFx1MjI0MycsXG4gICAgJ1RpbGRlRnVsbEVxdWFsJzogJ1xcdTIyNDUnLFxuICAgICdjb25nJzogJ1xcdTIyNDUnLFxuICAgICdUaWxkZVRpbGRlJzogJ1xcdTIyNDgnLFxuICAgICdhcCc6ICdcXHUyMjQ4JyxcbiAgICAnYXBwcm94JzogJ1xcdTIyNDgnLFxuICAgICdhc3ltcCc6ICdcXHUyMjQ4JyxcbiAgICAndGhpY2thcHByb3gnOiAnXFx1MjI0OCcsXG4gICAgJ3Roa2FwJzogJ1xcdTIyNDgnLFxuICAgICdUb3BmJzogJ1xcdUQ4MzVcXHVERDRCJyxcbiAgICAnVHJpcGxlRG90JzogJ1xcdTIwREInLFxuICAgICd0ZG90JzogJ1xcdTIwREInLFxuICAgICdUc2NyJzogJ1xcdUQ4MzVcXHVEQ0FGJyxcbiAgICAnVHN0cm9rJzogJ1xcdTAxNjYnLFxuICAgICdVYWN1dGUnOiAnXFx1MDBEQScsXG4gICAgJ1VhcnInOiAnXFx1MjE5RicsXG4gICAgJ1VhcnJvY2lyJzogJ1xcdTI5NDknLFxuICAgICdVYnJjeSc6ICdcXHUwNDBFJyxcbiAgICAnVWJyZXZlJzogJ1xcdTAxNkMnLFxuICAgICdVY2lyYyc6ICdcXHUwMERCJyxcbiAgICAnVWN5JzogJ1xcdTA0MjMnLFxuICAgICdVZGJsYWMnOiAnXFx1MDE3MCcsXG4gICAgJ1Vmcic6ICdcXHVEODM1XFx1REQxOCcsXG4gICAgJ1VncmF2ZSc6ICdcXHUwMEQ5JyxcbiAgICAnVW1hY3InOiAnXFx1MDE2QScsXG4gICAgJ1VuZGVyQmFyJzogJ1xcdTAwNUYnLFxuICAgICdsb3diYXInOiAnXFx1MDA1RicsXG4gICAgJ1VuZGVyQnJhY2UnOiAnXFx1MjNERicsXG4gICAgJ1VuZGVyQnJhY2tldCc6ICdcXHUyM0I1JyxcbiAgICAnYmJyayc6ICdcXHUyM0I1JyxcbiAgICAnVW5kZXJQYXJlbnRoZXNpcyc6ICdcXHUyM0REJyxcbiAgICAnVW5pb24nOiAnXFx1MjJDMycsXG4gICAgJ2JpZ2N1cCc6ICdcXHUyMkMzJyxcbiAgICAneGN1cCc6ICdcXHUyMkMzJyxcbiAgICAnVW5pb25QbHVzJzogJ1xcdTIyOEUnLFxuICAgICd1cGx1cyc6ICdcXHUyMjhFJyxcbiAgICAnVW9nb24nOiAnXFx1MDE3MicsXG4gICAgJ1VvcGYnOiAnXFx1RDgzNVxcdURENEMnLFxuICAgICdVcEFycm93QmFyJzogJ1xcdTI5MTInLFxuICAgICdVcEFycm93RG93bkFycm93JzogJ1xcdTIxQzUnLFxuICAgICd1ZGFycic6ICdcXHUyMUM1JyxcbiAgICAnVXBEb3duQXJyb3cnOiAnXFx1MjE5NScsXG4gICAgJ3VwZG93bmFycm93JzogJ1xcdTIxOTUnLFxuICAgICd2YXJyJzogJ1xcdTIxOTUnLFxuICAgICdVcEVxdWlsaWJyaXVtJzogJ1xcdTI5NkUnLFxuICAgICd1ZGhhcic6ICdcXHUyOTZFJyxcbiAgICAnVXBUZWUnOiAnXFx1MjJBNScsXG4gICAgJ2JvdCc6ICdcXHUyMkE1JyxcbiAgICAnYm90dG9tJzogJ1xcdTIyQTUnLFxuICAgICdwZXJwJzogJ1xcdTIyQTUnLFxuICAgICdVcFRlZUFycm93JzogJ1xcdTIxQTUnLFxuICAgICdtYXBzdG91cCc6ICdcXHUyMUE1JyxcbiAgICAnVXBwZXJMZWZ0QXJyb3cnOiAnXFx1MjE5NicsXG4gICAgJ253YXJyJzogJ1xcdTIxOTYnLFxuICAgICdud2Fycm93JzogJ1xcdTIxOTYnLFxuICAgICdVcHBlclJpZ2h0QXJyb3cnOiAnXFx1MjE5NycsXG4gICAgJ25lYXJyJzogJ1xcdTIxOTcnLFxuICAgICduZWFycm93JzogJ1xcdTIxOTcnLFxuICAgICdVcHNpJzogJ1xcdTAzRDInLFxuICAgICd1cHNpaCc6ICdcXHUwM0QyJyxcbiAgICAnVXBzaWxvbic6ICdcXHUwM0E1JyxcbiAgICAnVXJpbmcnOiAnXFx1MDE2RScsXG4gICAgJ1VzY3InOiAnXFx1RDgzNVxcdURDQjAnLFxuICAgICdVdGlsZGUnOiAnXFx1MDE2OCcsXG4gICAgJ1V1bWwnOiAnXFx1MDBEQycsXG4gICAgJ1ZEYXNoJzogJ1xcdTIyQUInLFxuICAgICdWYmFyJzogJ1xcdTJBRUInLFxuICAgICdWY3knOiAnXFx1MDQxMicsXG4gICAgJ1ZkYXNoJzogJ1xcdTIyQTknLFxuICAgICdWZGFzaGwnOiAnXFx1MkFFNicsXG4gICAgJ1ZlZSc6ICdcXHUyMkMxJyxcbiAgICAnYmlndmVlJzogJ1xcdTIyQzEnLFxuICAgICd4dmVlJzogJ1xcdTIyQzEnLFxuICAgICdWZXJiYXInOiAnXFx1MjAxNicsXG4gICAgJ1ZlcnQnOiAnXFx1MjAxNicsXG4gICAgJ1ZlcnRpY2FsQmFyJzogJ1xcdTIyMjMnLFxuICAgICdtaWQnOiAnXFx1MjIyMycsXG4gICAgJ3Nob3J0bWlkJzogJ1xcdTIyMjMnLFxuICAgICdzbWlkJzogJ1xcdTIyMjMnLFxuICAgICdWZXJ0aWNhbExpbmUnOiAnXFx1MDA3QycsXG4gICAgJ3ZlcmJhcic6ICdcXHUwMDdDJyxcbiAgICAndmVydCc6ICdcXHUwMDdDJyxcbiAgICAnVmVydGljYWxTZXBhcmF0b3InOiAnXFx1Mjc1OCcsXG4gICAgJ1ZlcnRpY2FsVGlsZGUnOiAnXFx1MjI0MCcsXG4gICAgJ3dyJzogJ1xcdTIyNDAnLFxuICAgICd3cmVhdGgnOiAnXFx1MjI0MCcsXG4gICAgJ1ZlcnlUaGluU3BhY2UnOiAnXFx1MjAwQScsXG4gICAgJ2hhaXJzcCc6ICdcXHUyMDBBJyxcbiAgICAnVmZyJzogJ1xcdUQ4MzVcXHVERDE5JyxcbiAgICAnVm9wZic6ICdcXHVEODM1XFx1REQ0RCcsXG4gICAgJ1ZzY3InOiAnXFx1RDgzNVxcdURDQjEnLFxuICAgICdWdmRhc2gnOiAnXFx1MjJBQScsXG4gICAgJ1djaXJjJzogJ1xcdTAxNzQnLFxuICAgICdXZWRnZSc6ICdcXHUyMkMwJyxcbiAgICAnYmlnd2VkZ2UnOiAnXFx1MjJDMCcsXG4gICAgJ3h3ZWRnZSc6ICdcXHUyMkMwJyxcbiAgICAnV2ZyJzogJ1xcdUQ4MzVcXHVERDFBJyxcbiAgICAnV29wZic6ICdcXHVEODM1XFx1REQ0RScsXG4gICAgJ1dzY3InOiAnXFx1RDgzNVxcdURDQjInLFxuICAgICdYZnInOiAnXFx1RDgzNVxcdUREMUInLFxuICAgICdYaSc6ICdcXHUwMzlFJyxcbiAgICAnWG9wZic6ICdcXHVEODM1XFx1REQ0RicsXG4gICAgJ1hzY3InOiAnXFx1RDgzNVxcdURDQjMnLFxuICAgICdZQWN5JzogJ1xcdTA0MkYnLFxuICAgICdZSWN5JzogJ1xcdTA0MDcnLFxuICAgICdZVWN5JzogJ1xcdTA0MkUnLFxuICAgICdZYWN1dGUnOiAnXFx1MDBERCcsXG4gICAgJ1ljaXJjJzogJ1xcdTAxNzYnLFxuICAgICdZY3knOiAnXFx1MDQyQicsXG4gICAgJ1lmcic6ICdcXHVEODM1XFx1REQxQycsXG4gICAgJ1lvcGYnOiAnXFx1RDgzNVxcdURENTAnLFxuICAgICdZc2NyJzogJ1xcdUQ4MzVcXHVEQ0I0JyxcbiAgICAnWXVtbCc6ICdcXHUwMTc4JyxcbiAgICAnWkhjeSc6ICdcXHUwNDE2JyxcbiAgICAnWmFjdXRlJzogJ1xcdTAxNzknLFxuICAgICdaY2Fyb24nOiAnXFx1MDE3RCcsXG4gICAgJ1pjeSc6ICdcXHUwNDE3JyxcbiAgICAnWmRvdCc6ICdcXHUwMTdCJyxcbiAgICAnWmV0YSc6ICdcXHUwMzk2JyxcbiAgICAnWmZyJzogJ1xcdTIxMjgnLFxuICAgICd6ZWV0cmYnOiAnXFx1MjEyOCcsXG4gICAgJ1pvcGYnOiAnXFx1MjEyNCcsXG4gICAgJ2ludGVnZXJzJzogJ1xcdTIxMjQnLFxuICAgICdac2NyJzogJ1xcdUQ4MzVcXHVEQ0I1JyxcbiAgICAnYWFjdXRlJzogJ1xcdTAwRTEnLFxuICAgICdhYnJldmUnOiAnXFx1MDEwMycsXG4gICAgJ2FjJzogJ1xcdTIyM0UnLFxuICAgICdtc3Rwb3MnOiAnXFx1MjIzRScsXG4gICAgJ2FjRSc6ICdcXHUyMjNFXFx1MDMzMycsXG4gICAgJ2FjZCc6ICdcXHUyMjNGJyxcbiAgICAnYWNpcmMnOiAnXFx1MDBFMicsXG4gICAgJ2FjeSc6ICdcXHUwNDMwJyxcbiAgICAnYWVsaWcnOiAnXFx1MDBFNicsXG4gICAgJ2Fmcic6ICdcXHVEODM1XFx1REQxRScsXG4gICAgJ2FncmF2ZSc6ICdcXHUwMEUwJyxcbiAgICAnYWxlZnN5bSc6ICdcXHUyMTM1JyxcbiAgICAnYWxlcGgnOiAnXFx1MjEzNScsXG4gICAgJ2FscGhhJzogJ1xcdTAzQjEnLFxuICAgICdhbWFjcic6ICdcXHUwMTAxJyxcbiAgICAnYW1hbGcnOiAnXFx1MkEzRicsXG4gICAgJ2FuZCc6ICdcXHUyMjI3JyxcbiAgICAnd2VkZ2UnOiAnXFx1MjIyNycsXG4gICAgJ2FuZGFuZCc6ICdcXHUyQTU1JyxcbiAgICAnYW5kZCc6ICdcXHUyQTVDJyxcbiAgICAnYW5kc2xvcGUnOiAnXFx1MkE1OCcsXG4gICAgJ2FuZHYnOiAnXFx1MkE1QScsXG4gICAgJ2FuZyc6ICdcXHUyMjIwJyxcbiAgICAnYW5nbGUnOiAnXFx1MjIyMCcsXG4gICAgJ2FuZ2UnOiAnXFx1MjlBNCcsXG4gICAgJ2FuZ21zZCc6ICdcXHUyMjIxJyxcbiAgICAnbWVhc3VyZWRhbmdsZSc6ICdcXHUyMjIxJyxcbiAgICAnYW5nbXNkYWEnOiAnXFx1MjlBOCcsXG4gICAgJ2FuZ21zZGFiJzogJ1xcdTI5QTknLFxuICAgICdhbmdtc2RhYyc6ICdcXHUyOUFBJyxcbiAgICAnYW5nbXNkYWQnOiAnXFx1MjlBQicsXG4gICAgJ2FuZ21zZGFlJzogJ1xcdTI5QUMnLFxuICAgICdhbmdtc2RhZic6ICdcXHUyOUFEJyxcbiAgICAnYW5nbXNkYWcnOiAnXFx1MjlBRScsXG4gICAgJ2FuZ21zZGFoJzogJ1xcdTI5QUYnLFxuICAgICdhbmdydCc6ICdcXHUyMjFGJyxcbiAgICAnYW5ncnR2Yic6ICdcXHUyMkJFJyxcbiAgICAnYW5ncnR2YmQnOiAnXFx1Mjk5RCcsXG4gICAgJ2FuZ3NwaCc6ICdcXHUyMjIyJyxcbiAgICAnYW5nemFycic6ICdcXHUyMzdDJyxcbiAgICAnYW9nb24nOiAnXFx1MDEwNScsXG4gICAgJ2FvcGYnOiAnXFx1RDgzNVxcdURENTInLFxuICAgICdhcEUnOiAnXFx1MkE3MCcsXG4gICAgJ2FwYWNpcic6ICdcXHUyQTZGJyxcbiAgICAnYXBlJzogJ1xcdTIyNEEnLFxuICAgICdhcHByb3hlcSc6ICdcXHUyMjRBJyxcbiAgICAnYXBpZCc6ICdcXHUyMjRCJyxcbiAgICAnYXBvcyc6ICdcXHUwMDI3JyxcbiAgICAnYXJpbmcnOiAnXFx1MDBFNScsXG4gICAgJ2FzY3InOiAnXFx1RDgzNVxcdURDQjYnLFxuICAgICdhc3QnOiAnXFx1MDAyQScsXG4gICAgJ21pZGFzdCc6ICdcXHUwMDJBJyxcbiAgICAnYXRpbGRlJzogJ1xcdTAwRTMnLFxuICAgICdhdW1sJzogJ1xcdTAwRTQnLFxuICAgICdhd2ludCc6ICdcXHUyQTExJyxcbiAgICAnYk5vdCc6ICdcXHUyQUVEJyxcbiAgICAnYmFja2NvbmcnOiAnXFx1MjI0QycsXG4gICAgJ2Jjb25nJzogJ1xcdTIyNEMnLFxuICAgICdiYWNrZXBzaWxvbic6ICdcXHUwM0Y2JyxcbiAgICAnYmVwc2knOiAnXFx1MDNGNicsXG4gICAgJ2JhY2twcmltZSc6ICdcXHUyMDM1JyxcbiAgICAnYnByaW1lJzogJ1xcdTIwMzUnLFxuICAgICdiYWNrc2ltJzogJ1xcdTIyM0QnLFxuICAgICdic2ltJzogJ1xcdTIyM0QnLFxuICAgICdiYWNrc2ltZXEnOiAnXFx1MjJDRCcsXG4gICAgJ2JzaW1lJzogJ1xcdTIyQ0QnLFxuICAgICdiYXJ2ZWUnOiAnXFx1MjJCRCcsXG4gICAgJ2JhcndlZCc6ICdcXHUyMzA1JyxcbiAgICAnYmFyd2VkZ2UnOiAnXFx1MjMwNScsXG4gICAgJ2Jicmt0YnJrJzogJ1xcdTIzQjYnLFxuICAgICdiY3knOiAnXFx1MDQzMScsXG4gICAgJ2JkcXVvJzogJ1xcdTIwMUUnLFxuICAgICdsZHF1b3InOiAnXFx1MjAxRScsXG4gICAgJ2JlbXB0eXYnOiAnXFx1MjlCMCcsXG4gICAgJ2JldGEnOiAnXFx1MDNCMicsXG4gICAgJ2JldGgnOiAnXFx1MjEzNicsXG4gICAgJ2JldHdlZW4nOiAnXFx1MjI2QycsXG4gICAgJ3R3aXh0JzogJ1xcdTIyNkMnLFxuICAgICdiZnInOiAnXFx1RDgzNVxcdUREMUYnLFxuICAgICdiaWdjaXJjJzogJ1xcdTI1RUYnLFxuICAgICd4Y2lyYyc6ICdcXHUyNUVGJyxcbiAgICAnYmlnb2RvdCc6ICdcXHUyQTAwJyxcbiAgICAneG9kb3QnOiAnXFx1MkEwMCcsXG4gICAgJ2JpZ29wbHVzJzogJ1xcdTJBMDEnLFxuICAgICd4b3BsdXMnOiAnXFx1MkEwMScsXG4gICAgJ2JpZ290aW1lcyc6ICdcXHUyQTAyJyxcbiAgICAneG90aW1lJzogJ1xcdTJBMDInLFxuICAgICdiaWdzcWN1cCc6ICdcXHUyQTA2JyxcbiAgICAneHNxY3VwJzogJ1xcdTJBMDYnLFxuICAgICdiaWdzdGFyJzogJ1xcdTI2MDUnLFxuICAgICdzdGFyZic6ICdcXHUyNjA1JyxcbiAgICAnYmlndHJpYW5nbGVkb3duJzogJ1xcdTI1QkQnLFxuICAgICd4ZHRyaSc6ICdcXHUyNUJEJyxcbiAgICAnYmlndHJpYW5nbGV1cCc6ICdcXHUyNUIzJyxcbiAgICAneHV0cmknOiAnXFx1MjVCMycsXG4gICAgJ2JpZ3VwbHVzJzogJ1xcdTJBMDQnLFxuICAgICd4dXBsdXMnOiAnXFx1MkEwNCcsXG4gICAgJ2JrYXJvdyc6ICdcXHUyOTBEJyxcbiAgICAncmJhcnInOiAnXFx1MjkwRCcsXG4gICAgJ2JsYWNrbG96ZW5nZSc6ICdcXHUyOUVCJyxcbiAgICAnbG96Zic6ICdcXHUyOUVCJyxcbiAgICAnYmxhY2t0cmlhbmdsZSc6ICdcXHUyNUI0JyxcbiAgICAndXRyaWYnOiAnXFx1MjVCNCcsXG4gICAgJ2JsYWNrdHJpYW5nbGVkb3duJzogJ1xcdTI1QkUnLFxuICAgICdkdHJpZic6ICdcXHUyNUJFJyxcbiAgICAnYmxhY2t0cmlhbmdsZWxlZnQnOiAnXFx1MjVDMicsXG4gICAgJ2x0cmlmJzogJ1xcdTI1QzInLFxuICAgICdibGFja3RyaWFuZ2xlcmlnaHQnOiAnXFx1MjVCOCcsXG4gICAgJ3J0cmlmJzogJ1xcdTI1QjgnLFxuICAgICdibGFuayc6ICdcXHUyNDIzJyxcbiAgICAnYmxrMTInOiAnXFx1MjU5MicsXG4gICAgJ2JsazE0JzogJ1xcdTI1OTEnLFxuICAgICdibGszNCc6ICdcXHUyNTkzJyxcbiAgICAnYmxvY2snOiAnXFx1MjU4OCcsXG4gICAgJ2JuZSc6ICdcXHUwMDNEXFx1MjBFNScsXG4gICAgJ2JuZXF1aXYnOiAnXFx1MjI2MVxcdTIwRTUnLFxuICAgICdibm90JzogJ1xcdTIzMTAnLFxuICAgICdib3BmJzogJ1xcdUQ4MzVcXHVERDUzJyxcbiAgICAnYm93dGllJzogJ1xcdTIyQzgnLFxuICAgICdib3hETCc6ICdcXHUyNTU3JyxcbiAgICAnYm94RFInOiAnXFx1MjU1NCcsXG4gICAgJ2JveERsJzogJ1xcdTI1NTYnLFxuICAgICdib3hEcic6ICdcXHUyNTUzJyxcbiAgICAnYm94SCc6ICdcXHUyNTUwJyxcbiAgICAnYm94SEQnOiAnXFx1MjU2NicsXG4gICAgJ2JveEhVJzogJ1xcdTI1NjknLFxuICAgICdib3hIZCc6ICdcXHUyNTY0JyxcbiAgICAnYm94SHUnOiAnXFx1MjU2NycsXG4gICAgJ2JveFVMJzogJ1xcdTI1NUQnLFxuICAgICdib3hVUic6ICdcXHUyNTVBJyxcbiAgICAnYm94VWwnOiAnXFx1MjU1QycsXG4gICAgJ2JveFVyJzogJ1xcdTI1NTknLFxuICAgICdib3hWJzogJ1xcdTI1NTEnLFxuICAgICdib3hWSCc6ICdcXHUyNTZDJyxcbiAgICAnYm94VkwnOiAnXFx1MjU2MycsXG4gICAgJ2JveFZSJzogJ1xcdTI1NjAnLFxuICAgICdib3hWaCc6ICdcXHUyNTZCJyxcbiAgICAnYm94VmwnOiAnXFx1MjU2MicsXG4gICAgJ2JveFZyJzogJ1xcdTI1NUYnLFxuICAgICdib3hib3gnOiAnXFx1MjlDOScsXG4gICAgJ2JveGRMJzogJ1xcdTI1NTUnLFxuICAgICdib3hkUic6ICdcXHUyNTUyJyxcbiAgICAnYm94ZGwnOiAnXFx1MjUxMCcsXG4gICAgJ2JveGRyJzogJ1xcdTI1MEMnLFxuICAgICdib3hoRCc6ICdcXHUyNTY1JyxcbiAgICAnYm94aFUnOiAnXFx1MjU2OCcsXG4gICAgJ2JveGhkJzogJ1xcdTI1MkMnLFxuICAgICdib3hodSc6ICdcXHUyNTM0JyxcbiAgICAnYm94bWludXMnOiAnXFx1MjI5RicsXG4gICAgJ21pbnVzYic6ICdcXHUyMjlGJyxcbiAgICAnYm94cGx1cyc6ICdcXHUyMjlFJyxcbiAgICAncGx1c2InOiAnXFx1MjI5RScsXG4gICAgJ2JveHRpbWVzJzogJ1xcdTIyQTAnLFxuICAgICd0aW1lc2InOiAnXFx1MjJBMCcsXG4gICAgJ2JveHVMJzogJ1xcdTI1NUInLFxuICAgICdib3h1Uic6ICdcXHUyNTU4JyxcbiAgICAnYm94dWwnOiAnXFx1MjUxOCcsXG4gICAgJ2JveHVyJzogJ1xcdTI1MTQnLFxuICAgICdib3h2JzogJ1xcdTI1MDInLFxuICAgICdib3h2SCc6ICdcXHUyNTZBJyxcbiAgICAnYm94dkwnOiAnXFx1MjU2MScsXG4gICAgJ2JveHZSJzogJ1xcdTI1NUUnLFxuICAgICdib3h2aCc6ICdcXHUyNTNDJyxcbiAgICAnYm94dmwnOiAnXFx1MjUyNCcsXG4gICAgJ2JveHZyJzogJ1xcdTI1MUMnLFxuICAgICdicnZiYXInOiAnXFx1MDBBNicsXG4gICAgJ2JzY3InOiAnXFx1RDgzNVxcdURDQjcnLFxuICAgICdic2VtaSc6ICdcXHUyMDRGJyxcbiAgICAnYnNvbCc6ICdcXHUwMDVDJyxcbiAgICAnYnNvbGInOiAnXFx1MjlDNScsXG4gICAgJ2Jzb2xoc3ViJzogJ1xcdTI3QzgnLFxuICAgICdidWxsJzogJ1xcdTIwMjInLFxuICAgICdidWxsZXQnOiAnXFx1MjAyMicsXG4gICAgJ2J1bXBFJzogJ1xcdTJBQUUnLFxuICAgICdjYWN1dGUnOiAnXFx1MDEwNycsXG4gICAgJ2NhcCc6ICdcXHUyMjI5JyxcbiAgICAnY2FwYW5kJzogJ1xcdTJBNDQnLFxuICAgICdjYXBicmN1cCc6ICdcXHUyQTQ5JyxcbiAgICAnY2FwY2FwJzogJ1xcdTJBNEInLFxuICAgICdjYXBjdXAnOiAnXFx1MkE0NycsXG4gICAgJ2NhcGRvdCc6ICdcXHUyQTQwJyxcbiAgICAnY2Fwcyc6ICdcXHUyMjI5XFx1RkUwMCcsXG4gICAgJ2NhcmV0JzogJ1xcdTIwNDEnLFxuICAgICdjY2Fwcyc6ICdcXHUyQTREJyxcbiAgICAnY2Nhcm9uJzogJ1xcdTAxMEQnLFxuICAgICdjY2VkaWwnOiAnXFx1MDBFNycsXG4gICAgJ2NjaXJjJzogJ1xcdTAxMDknLFxuICAgICdjY3Vwcyc6ICdcXHUyQTRDJyxcbiAgICAnY2N1cHNzbSc6ICdcXHUyQTUwJyxcbiAgICAnY2RvdCc6ICdcXHUwMTBCJyxcbiAgICAnY2VtcHR5dic6ICdcXHUyOUIyJyxcbiAgICAnY2VudCc6ICdcXHUwMEEyJyxcbiAgICAnY2ZyJzogJ1xcdUQ4MzVcXHVERDIwJyxcbiAgICAnY2hjeSc6ICdcXHUwNDQ3JyxcbiAgICAnY2hlY2snOiAnXFx1MjcxMycsXG4gICAgJ2NoZWNrbWFyayc6ICdcXHUyNzEzJyxcbiAgICAnY2hpJzogJ1xcdTAzQzcnLFxuICAgICdjaXInOiAnXFx1MjVDQicsXG4gICAgJ2NpckUnOiAnXFx1MjlDMycsXG4gICAgJ2NpcmMnOiAnXFx1MDJDNicsXG4gICAgJ2NpcmNlcSc6ICdcXHUyMjU3JyxcbiAgICAnY2lyZSc6ICdcXHUyMjU3JyxcbiAgICAnY2lyY2xlYXJyb3dsZWZ0JzogJ1xcdTIxQkEnLFxuICAgICdvbGFycic6ICdcXHUyMUJBJyxcbiAgICAnY2lyY2xlYXJyb3dyaWdodCc6ICdcXHUyMUJCJyxcbiAgICAnb3JhcnInOiAnXFx1MjFCQicsXG4gICAgJ2NpcmNsZWRTJzogJ1xcdTI0QzgnLFxuICAgICdvUyc6ICdcXHUyNEM4JyxcbiAgICAnY2lyY2xlZGFzdCc6ICdcXHUyMjlCJyxcbiAgICAnb2FzdCc6ICdcXHUyMjlCJyxcbiAgICAnY2lyY2xlZGNpcmMnOiAnXFx1MjI5QScsXG4gICAgJ29jaXInOiAnXFx1MjI5QScsXG4gICAgJ2NpcmNsZWRkYXNoJzogJ1xcdTIyOUQnLFxuICAgICdvZGFzaCc6ICdcXHUyMjlEJyxcbiAgICAnY2lyZm5pbnQnOiAnXFx1MkExMCcsXG4gICAgJ2Npcm1pZCc6ICdcXHUyQUVGJyxcbiAgICAnY2lyc2Npcic6ICdcXHUyOUMyJyxcbiAgICAnY2x1YnMnOiAnXFx1MjY2MycsXG4gICAgJ2NsdWJzdWl0JzogJ1xcdTI2NjMnLFxuICAgICdjb2xvbic6ICdcXHUwMDNBJyxcbiAgICAnY29tbWEnOiAnXFx1MDAyQycsXG4gICAgJ2NvbW1hdCc6ICdcXHUwMDQwJyxcbiAgICAnY29tcCc6ICdcXHUyMjAxJyxcbiAgICAnY29tcGxlbWVudCc6ICdcXHUyMjAxJyxcbiAgICAnY29uZ2RvdCc6ICdcXHUyQTZEJyxcbiAgICAnY29wZic6ICdcXHVEODM1XFx1REQ1NCcsXG4gICAgJ2NvcHlzcic6ICdcXHUyMTE3JyxcbiAgICAnY3JhcnInOiAnXFx1MjFCNScsXG4gICAgJ2Nyb3NzJzogJ1xcdTI3MTcnLFxuICAgICdjc2NyJzogJ1xcdUQ4MzVcXHVEQ0I4JyxcbiAgICAnY3N1Yic6ICdcXHUyQUNGJyxcbiAgICAnY3N1YmUnOiAnXFx1MkFEMScsXG4gICAgJ2NzdXAnOiAnXFx1MkFEMCcsXG4gICAgJ2NzdXBlJzogJ1xcdTJBRDInLFxuICAgICdjdGRvdCc6ICdcXHUyMkVGJyxcbiAgICAnY3VkYXJybCc6ICdcXHUyOTM4JyxcbiAgICAnY3VkYXJycic6ICdcXHUyOTM1JyxcbiAgICAnY3VlcHInOiAnXFx1MjJERScsXG4gICAgJ2N1cmx5ZXFwcmVjJzogJ1xcdTIyREUnLFxuICAgICdjdWVzYyc6ICdcXHUyMkRGJyxcbiAgICAnY3VybHllcXN1Y2MnOiAnXFx1MjJERicsXG4gICAgJ2N1bGFycic6ICdcXHUyMUI2JyxcbiAgICAnY3VydmVhcnJvd2xlZnQnOiAnXFx1MjFCNicsXG4gICAgJ2N1bGFycnAnOiAnXFx1MjkzRCcsXG4gICAgJ2N1cCc6ICdcXHUyMjJBJyxcbiAgICAnY3VwYnJjYXAnOiAnXFx1MkE0OCcsXG4gICAgJ2N1cGNhcCc6ICdcXHUyQTQ2JyxcbiAgICAnY3VwY3VwJzogJ1xcdTJBNEEnLFxuICAgICdjdXBkb3QnOiAnXFx1MjI4RCcsXG4gICAgJ2N1cG9yJzogJ1xcdTJBNDUnLFxuICAgICdjdXBzJzogJ1xcdTIyMkFcXHVGRTAwJyxcbiAgICAnY3VyYXJyJzogJ1xcdTIxQjcnLFxuICAgICdjdXJ2ZWFycm93cmlnaHQnOiAnXFx1MjFCNycsXG4gICAgJ2N1cmFycm0nOiAnXFx1MjkzQycsXG4gICAgJ2N1cmx5dmVlJzogJ1xcdTIyQ0UnLFxuICAgICdjdXZlZSc6ICdcXHUyMkNFJyxcbiAgICAnY3VybHl3ZWRnZSc6ICdcXHUyMkNGJyxcbiAgICAnY3V3ZWQnOiAnXFx1MjJDRicsXG4gICAgJ2N1cnJlbic6ICdcXHUwMEE0JyxcbiAgICAnY3dpbnQnOiAnXFx1MjIzMScsXG4gICAgJ2N5bGN0eSc6ICdcXHUyMzJEJyxcbiAgICAnZEhhcic6ICdcXHUyOTY1JyxcbiAgICAnZGFnZ2VyJzogJ1xcdTIwMjAnLFxuICAgICdkYWxldGgnOiAnXFx1MjEzOCcsXG4gICAgJ2Rhc2gnOiAnXFx1MjAxMCcsXG4gICAgJ2h5cGhlbic6ICdcXHUyMDEwJyxcbiAgICAnZGJrYXJvdyc6ICdcXHUyOTBGJyxcbiAgICAnckJhcnInOiAnXFx1MjkwRicsXG4gICAgJ2RjYXJvbic6ICdcXHUwMTBGJyxcbiAgICAnZGN5JzogJ1xcdTA0MzQnLFxuICAgICdkZGFycic6ICdcXHUyMUNBJyxcbiAgICAnZG93bmRvd25hcnJvd3MnOiAnXFx1MjFDQScsXG4gICAgJ2Rkb3RzZXEnOiAnXFx1MkE3NycsXG4gICAgJ2VERG90JzogJ1xcdTJBNzcnLFxuICAgICdkZWcnOiAnXFx1MDBCMCcsXG4gICAgJ2RlbHRhJzogJ1xcdTAzQjQnLFxuICAgICdkZW1wdHl2JzogJ1xcdTI5QjEnLFxuICAgICdkZmlzaHQnOiAnXFx1Mjk3RicsXG4gICAgJ2Rmcic6ICdcXHVEODM1XFx1REQyMScsXG4gICAgJ2RpYW1vbmRzdWl0JzogJ1xcdTI2NjYnLFxuICAgICdkaWFtcyc6ICdcXHUyNjY2JyxcbiAgICAnZGlnYW1tYSc6ICdcXHUwM0REJyxcbiAgICAnZ2FtbWFkJzogJ1xcdTAzREQnLFxuICAgICdkaXNpbic6ICdcXHUyMkYyJyxcbiAgICAnZGl2JzogJ1xcdTAwRjcnLFxuICAgICdkaXZpZGUnOiAnXFx1MDBGNycsXG4gICAgJ2RpdmlkZW9udGltZXMnOiAnXFx1MjJDNycsXG4gICAgJ2Rpdm9ueCc6ICdcXHUyMkM3JyxcbiAgICAnZGpjeSc6ICdcXHUwNDUyJyxcbiAgICAnZGxjb3JuJzogJ1xcdTIzMUUnLFxuICAgICdsbGNvcm5lcic6ICdcXHUyMzFFJyxcbiAgICAnZGxjcm9wJzogJ1xcdTIzMEQnLFxuICAgICdkb2xsYXInOiAnXFx1MDAyNCcsXG4gICAgJ2RvcGYnOiAnXFx1RDgzNVxcdURENTUnLFxuICAgICdkb3RlcWRvdCc6ICdcXHUyMjUxJyxcbiAgICAnZURvdCc6ICdcXHUyMjUxJyxcbiAgICAnZG90bWludXMnOiAnXFx1MjIzOCcsXG4gICAgJ21pbnVzZCc6ICdcXHUyMjM4JyxcbiAgICAnZG90cGx1cyc6ICdcXHUyMjE0JyxcbiAgICAncGx1c2RvJzogJ1xcdTIyMTQnLFxuICAgICdkb3RzcXVhcmUnOiAnXFx1MjJBMScsXG4gICAgJ3Nkb3RiJzogJ1xcdTIyQTEnLFxuICAgICdkcmNvcm4nOiAnXFx1MjMxRicsXG4gICAgJ2xyY29ybmVyJzogJ1xcdTIzMUYnLFxuICAgICdkcmNyb3AnOiAnXFx1MjMwQycsXG4gICAgJ2RzY3InOiAnXFx1RDgzNVxcdURDQjknLFxuICAgICdkc2N5JzogJ1xcdTA0NTUnLFxuICAgICdkc29sJzogJ1xcdTI5RjYnLFxuICAgICdkc3Ryb2snOiAnXFx1MDExMScsXG4gICAgJ2R0ZG90JzogJ1xcdTIyRjEnLFxuICAgICdkdHJpJzogJ1xcdTI1QkYnLFxuICAgICd0cmlhbmdsZWRvd24nOiAnXFx1MjVCRicsXG4gICAgJ2R3YW5nbGUnOiAnXFx1MjlBNicsXG4gICAgJ2R6Y3knOiAnXFx1MDQ1RicsXG4gICAgJ2R6aWdyYXJyJzogJ1xcdTI3RkYnLFxuICAgICdlYWN1dGUnOiAnXFx1MDBFOScsXG4gICAgJ2Vhc3Rlcic6ICdcXHUyQTZFJyxcbiAgICAnZWNhcm9uJzogJ1xcdTAxMUInLFxuICAgICdlY2lyJzogJ1xcdTIyNTYnLFxuICAgICdlcWNpcmMnOiAnXFx1MjI1NicsXG4gICAgJ2VjaXJjJzogJ1xcdTAwRUEnLFxuICAgICdlY29sb24nOiAnXFx1MjI1NScsXG4gICAgJ2VxY29sb24nOiAnXFx1MjI1NScsXG4gICAgJ2VjeSc6ICdcXHUwNDREJyxcbiAgICAnZWRvdCc6ICdcXHUwMTE3JyxcbiAgICAnZWZEb3QnOiAnXFx1MjI1MicsXG4gICAgJ2ZhbGxpbmdkb3RzZXEnOiAnXFx1MjI1MicsXG4gICAgJ2Vmcic6ICdcXHVEODM1XFx1REQyMicsXG4gICAgJ2VnJzogJ1xcdTJBOUEnLFxuICAgICdlZ3JhdmUnOiAnXFx1MDBFOCcsXG4gICAgJ2Vncyc6ICdcXHUyQTk2JyxcbiAgICAnZXFzbGFudGd0cic6ICdcXHUyQTk2JyxcbiAgICAnZWdzZG90JzogJ1xcdTJBOTgnLFxuICAgICdlbCc6ICdcXHUyQTk5JyxcbiAgICAnZWxpbnRlcnMnOiAnXFx1MjNFNycsXG4gICAgJ2VsbCc6ICdcXHUyMTEzJyxcbiAgICAnZWxzJzogJ1xcdTJBOTUnLFxuICAgICdlcXNsYW50bGVzcyc6ICdcXHUyQTk1JyxcbiAgICAnZWxzZG90JzogJ1xcdTJBOTcnLFxuICAgICdlbWFjcic6ICdcXHUwMTEzJyxcbiAgICAnZW1wdHknOiAnXFx1MjIwNScsXG4gICAgJ2VtcHR5c2V0JzogJ1xcdTIyMDUnLFxuICAgICdlbXB0eXYnOiAnXFx1MjIwNScsXG4gICAgJ3Zhcm5vdGhpbmcnOiAnXFx1MjIwNScsXG4gICAgJ2Vtc3AxMyc6ICdcXHUyMDA0JyxcbiAgICAnZW1zcDE0JzogJ1xcdTIwMDUnLFxuICAgICdlbXNwJzogJ1xcdTIwMDMnLFxuICAgICdlbmcnOiAnXFx1MDE0QicsXG4gICAgJ2Vuc3AnOiAnXFx1MjAwMicsXG4gICAgJ2VvZ29uJzogJ1xcdTAxMTknLFxuICAgICdlb3BmJzogJ1xcdUQ4MzVcXHVERDU2JyxcbiAgICAnZXBhcic6ICdcXHUyMkQ1JyxcbiAgICAnZXBhcnNsJzogJ1xcdTI5RTMnLFxuICAgICdlcGx1cyc6ICdcXHUyQTcxJyxcbiAgICAnZXBzaSc6ICdcXHUwM0I1JyxcbiAgICAnZXBzaWxvbic6ICdcXHUwM0I1JyxcbiAgICAnZXBzaXYnOiAnXFx1MDNGNScsXG4gICAgJ3N0cmFpZ2h0ZXBzaWxvbic6ICdcXHUwM0Y1JyxcbiAgICAndmFyZXBzaWxvbic6ICdcXHUwM0Y1JyxcbiAgICAnZXF1YWxzJzogJ1xcdTAwM0QnLFxuICAgICdlcXVlc3QnOiAnXFx1MjI1RicsXG4gICAgJ3F1ZXN0ZXEnOiAnXFx1MjI1RicsXG4gICAgJ2VxdWl2REQnOiAnXFx1MkE3OCcsXG4gICAgJ2VxdnBhcnNsJzogJ1xcdTI5RTUnLFxuICAgICdlckRvdCc6ICdcXHUyMjUzJyxcbiAgICAncmlzaW5nZG90c2VxJzogJ1xcdTIyNTMnLFxuICAgICdlcmFycic6ICdcXHUyOTcxJyxcbiAgICAnZXNjcic6ICdcXHUyMTJGJyxcbiAgICAnZXRhJzogJ1xcdTAzQjcnLFxuICAgICdldGgnOiAnXFx1MDBGMCcsXG4gICAgJ2V1bWwnOiAnXFx1MDBFQicsXG4gICAgJ2V1cm8nOiAnXFx1MjBBQycsXG4gICAgJ2V4Y2wnOiAnXFx1MDAyMScsXG4gICAgJ2ZjeSc6ICdcXHUwNDQ0JyxcbiAgICAnZmVtYWxlJzogJ1xcdTI2NDAnLFxuICAgICdmZmlsaWcnOiAnXFx1RkIwMycsXG4gICAgJ2ZmbGlnJzogJ1xcdUZCMDAnLFxuICAgICdmZmxsaWcnOiAnXFx1RkIwNCcsXG4gICAgJ2Zmcic6ICdcXHVEODM1XFx1REQyMycsXG4gICAgJ2ZpbGlnJzogJ1xcdUZCMDEnLFxuICAgICdmamxpZyc6ICdcXHUwMDY2XFx1MDA2QScsXG4gICAgJ2ZsYXQnOiAnXFx1MjY2RCcsXG4gICAgJ2ZsbGlnJzogJ1xcdUZCMDInLFxuICAgICdmbHRucyc6ICdcXHUyNUIxJyxcbiAgICAnZm5vZic6ICdcXHUwMTkyJyxcbiAgICAnZm9wZic6ICdcXHVEODM1XFx1REQ1NycsXG4gICAgJ2ZvcmsnOiAnXFx1MjJENCcsXG4gICAgJ3BpdGNoZm9yayc6ICdcXHUyMkQ0JyxcbiAgICAnZm9ya3YnOiAnXFx1MkFEOScsXG4gICAgJ2ZwYXJ0aW50JzogJ1xcdTJBMEQnLFxuICAgICdmcmFjMTInOiAnXFx1MDBCRCcsXG4gICAgJ2hhbGYnOiAnXFx1MDBCRCcsXG4gICAgJ2ZyYWMxMyc6ICdcXHUyMTUzJyxcbiAgICAnZnJhYzE0JzogJ1xcdTAwQkMnLFxuICAgICdmcmFjMTUnOiAnXFx1MjE1NScsXG4gICAgJ2ZyYWMxNic6ICdcXHUyMTU5JyxcbiAgICAnZnJhYzE4JzogJ1xcdTIxNUInLFxuICAgICdmcmFjMjMnOiAnXFx1MjE1NCcsXG4gICAgJ2ZyYWMyNSc6ICdcXHUyMTU2JyxcbiAgICAnZnJhYzM0JzogJ1xcdTAwQkUnLFxuICAgICdmcmFjMzUnOiAnXFx1MjE1NycsXG4gICAgJ2ZyYWMzOCc6ICdcXHUyMTVDJyxcbiAgICAnZnJhYzQ1JzogJ1xcdTIxNTgnLFxuICAgICdmcmFjNTYnOiAnXFx1MjE1QScsXG4gICAgJ2ZyYWM1OCc6ICdcXHUyMTVEJyxcbiAgICAnZnJhYzc4JzogJ1xcdTIxNUUnLFxuICAgICdmcmFzbCc6ICdcXHUyMDQ0JyxcbiAgICAnZnJvd24nOiAnXFx1MjMyMicsXG4gICAgJ3Nmcm93bic6ICdcXHUyMzIyJyxcbiAgICAnZnNjcic6ICdcXHVEODM1XFx1RENCQicsXG4gICAgJ2dFbCc6ICdcXHUyQThDJyxcbiAgICAnZ3RyZXFxbGVzcyc6ICdcXHUyQThDJyxcbiAgICAnZ2FjdXRlJzogJ1xcdTAxRjUnLFxuICAgICdnYW1tYSc6ICdcXHUwM0IzJyxcbiAgICAnZ2FwJzogJ1xcdTJBODYnLFxuICAgICdndHJhcHByb3gnOiAnXFx1MkE4NicsXG4gICAgJ2dicmV2ZSc6ICdcXHUwMTFGJyxcbiAgICAnZ2NpcmMnOiAnXFx1MDExRCcsXG4gICAgJ2djeSc6ICdcXHUwNDMzJyxcbiAgICAnZ2RvdCc6ICdcXHUwMTIxJyxcbiAgICAnZ2VzY2MnOiAnXFx1MkFBOScsXG4gICAgJ2dlc2RvdCc6ICdcXHUyQTgwJyxcbiAgICAnZ2VzZG90byc6ICdcXHUyQTgyJyxcbiAgICAnZ2VzZG90b2wnOiAnXFx1MkE4NCcsXG4gICAgJ2dlc2wnOiAnXFx1MjJEQlxcdUZFMDAnLFxuICAgICdnZXNsZXMnOiAnXFx1MkE5NCcsXG4gICAgJ2dmcic6ICdcXHVEODM1XFx1REQyNCcsXG4gICAgJ2dpbWVsJzogJ1xcdTIxMzcnLFxuICAgICdnamN5JzogJ1xcdTA0NTMnLFxuICAgICdnbEUnOiAnXFx1MkE5MicsXG4gICAgJ2dsYSc6ICdcXHUyQUE1JyxcbiAgICAnZ2xqJzogJ1xcdTJBQTQnLFxuICAgICdnbkUnOiAnXFx1MjI2OScsXG4gICAgJ2duZXFxJzogJ1xcdTIyNjknLFxuICAgICdnbmFwJzogJ1xcdTJBOEEnLFxuICAgICdnbmFwcHJveCc6ICdcXHUyQThBJyxcbiAgICAnZ25lJzogJ1xcdTJBODgnLFxuICAgICdnbmVxJzogJ1xcdTJBODgnLFxuICAgICdnbnNpbSc6ICdcXHUyMkU3JyxcbiAgICAnZ29wZic6ICdcXHVEODM1XFx1REQ1OCcsXG4gICAgJ2dzY3InOiAnXFx1MjEwQScsXG4gICAgJ2dzaW1lJzogJ1xcdTJBOEUnLFxuICAgICdnc2ltbCc6ICdcXHUyQTkwJyxcbiAgICAnZ3RjYyc6ICdcXHUyQUE3JyxcbiAgICAnZ3RjaXInOiAnXFx1MkE3QScsXG4gICAgJ2d0ZG90JzogJ1xcdTIyRDcnLFxuICAgICdndHJkb3QnOiAnXFx1MjJENycsXG4gICAgJ2d0bFBhcic6ICdcXHUyOTk1JyxcbiAgICAnZ3RxdWVzdCc6ICdcXHUyQTdDJyxcbiAgICAnZ3RyYXJyJzogJ1xcdTI5NzgnLFxuICAgICdndmVydG5lcXEnOiAnXFx1MjI2OVxcdUZFMDAnLFxuICAgICdndm5FJzogJ1xcdTIyNjlcXHVGRTAwJyxcbiAgICAnaGFyZGN5JzogJ1xcdTA0NEEnLFxuICAgICdoYXJyY2lyJzogJ1xcdTI5NDgnLFxuICAgICdoYXJydyc6ICdcXHUyMUFEJyxcbiAgICAnbGVmdHJpZ2h0c3F1aWdhcnJvdyc6ICdcXHUyMUFEJyxcbiAgICAnaGJhcic6ICdcXHUyMTBGJyxcbiAgICAnaHNsYXNoJzogJ1xcdTIxMEYnLFxuICAgICdwbGFuY2snOiAnXFx1MjEwRicsXG4gICAgJ3BsYW5rdic6ICdcXHUyMTBGJyxcbiAgICAnaGNpcmMnOiAnXFx1MDEyNScsXG4gICAgJ2hlYXJ0cyc6ICdcXHUyNjY1JyxcbiAgICAnaGVhcnRzdWl0JzogJ1xcdTI2NjUnLFxuICAgICdoZWxsaXAnOiAnXFx1MjAyNicsXG4gICAgJ21sZHInOiAnXFx1MjAyNicsXG4gICAgJ2hlcmNvbic6ICdcXHUyMkI5JyxcbiAgICAnaGZyJzogJ1xcdUQ4MzVcXHVERDI1JyxcbiAgICAnaGtzZWFyb3cnOiAnXFx1MjkyNScsXG4gICAgJ3NlYXJoayc6ICdcXHUyOTI1JyxcbiAgICAnaGtzd2Fyb3cnOiAnXFx1MjkyNicsXG4gICAgJ3N3YXJoayc6ICdcXHUyOTI2JyxcbiAgICAnaG9hcnInOiAnXFx1MjFGRicsXG4gICAgJ2hvbXRodCc6ICdcXHUyMjNCJyxcbiAgICAnaG9va2xlZnRhcnJvdyc6ICdcXHUyMUE5JyxcbiAgICAnbGFycmhrJzogJ1xcdTIxQTknLFxuICAgICdob29rcmlnaHRhcnJvdyc6ICdcXHUyMUFBJyxcbiAgICAncmFycmhrJzogJ1xcdTIxQUEnLFxuICAgICdob3BmJzogJ1xcdUQ4MzVcXHVERDU5JyxcbiAgICAnaG9yYmFyJzogJ1xcdTIwMTUnLFxuICAgICdoc2NyJzogJ1xcdUQ4MzVcXHVEQ0JEJyxcbiAgICAnaHN0cm9rJzogJ1xcdTAxMjcnLFxuICAgICdoeWJ1bGwnOiAnXFx1MjA0MycsXG4gICAgJ2lhY3V0ZSc6ICdcXHUwMEVEJyxcbiAgICAnaWNpcmMnOiAnXFx1MDBFRScsXG4gICAgJ2ljeSc6ICdcXHUwNDM4JyxcbiAgICAnaWVjeSc6ICdcXHUwNDM1JyxcbiAgICAnaWV4Y2wnOiAnXFx1MDBBMScsXG4gICAgJ2lmcic6ICdcXHVEODM1XFx1REQyNicsXG4gICAgJ2lncmF2ZSc6ICdcXHUwMEVDJyxcbiAgICAnaWlpaW50JzogJ1xcdTJBMEMnLFxuICAgICdxaW50JzogJ1xcdTJBMEMnLFxuICAgICdpaWludCc6ICdcXHUyMjJEJyxcbiAgICAndGludCc6ICdcXHUyMjJEJyxcbiAgICAnaWluZmluJzogJ1xcdTI5REMnLFxuICAgICdpaW90YSc6ICdcXHUyMTI5JyxcbiAgICAnaWpsaWcnOiAnXFx1MDEzMycsXG4gICAgJ2ltYWNyJzogJ1xcdTAxMkInLFxuICAgICdpbWF0aCc6ICdcXHUwMTMxJyxcbiAgICAnaW5vZG90JzogJ1xcdTAxMzEnLFxuICAgICdpbW9mJzogJ1xcdTIyQjcnLFxuICAgICdpbXBlZCc6ICdcXHUwMUI1JyxcbiAgICAnaW5jYXJlJzogJ1xcdTIxMDUnLFxuICAgICdpbmZpbic6ICdcXHUyMjFFJyxcbiAgICAnaW5maW50aWUnOiAnXFx1MjlERCcsXG4gICAgJ2ludGNhbCc6ICdcXHUyMkJBJyxcbiAgICAnaW50ZXJjYWwnOiAnXFx1MjJCQScsXG4gICAgJ2ludGxhcmhrJzogJ1xcdTJBMTcnLFxuICAgICdpbnRwcm9kJzogJ1xcdTJBM0MnLFxuICAgICdpcHJvZCc6ICdcXHUyQTNDJyxcbiAgICAnaW9jeSc6ICdcXHUwNDUxJyxcbiAgICAnaW9nb24nOiAnXFx1MDEyRicsXG4gICAgJ2lvcGYnOiAnXFx1RDgzNVxcdURENUEnLFxuICAgICdpb3RhJzogJ1xcdTAzQjknLFxuICAgICdpcXVlc3QnOiAnXFx1MDBCRicsXG4gICAgJ2lzY3InOiAnXFx1RDgzNVxcdURDQkUnLFxuICAgICdpc2luRSc6ICdcXHUyMkY5JyxcbiAgICAnaXNpbmRvdCc6ICdcXHUyMkY1JyxcbiAgICAnaXNpbnMnOiAnXFx1MjJGNCcsXG4gICAgJ2lzaW5zdic6ICdcXHUyMkYzJyxcbiAgICAnaXRpbGRlJzogJ1xcdTAxMjknLFxuICAgICdpdWtjeSc6ICdcXHUwNDU2JyxcbiAgICAnaXVtbCc6ICdcXHUwMEVGJyxcbiAgICAnamNpcmMnOiAnXFx1MDEzNScsXG4gICAgJ2pjeSc6ICdcXHUwNDM5JyxcbiAgICAnamZyJzogJ1xcdUQ4MzVcXHVERDI3JyxcbiAgICAnam1hdGgnOiAnXFx1MDIzNycsXG4gICAgJ2pvcGYnOiAnXFx1RDgzNVxcdURENUInLFxuICAgICdqc2NyJzogJ1xcdUQ4MzVcXHVEQ0JGJyxcbiAgICAnanNlcmN5JzogJ1xcdTA0NTgnLFxuICAgICdqdWtjeSc6ICdcXHUwNDU0JyxcbiAgICAna2FwcGEnOiAnXFx1MDNCQScsXG4gICAgJ2thcHBhdic6ICdcXHUwM0YwJyxcbiAgICAndmFya2FwcGEnOiAnXFx1MDNGMCcsXG4gICAgJ2tjZWRpbCc6ICdcXHUwMTM3JyxcbiAgICAna2N5JzogJ1xcdTA0M0EnLFxuICAgICdrZnInOiAnXFx1RDgzNVxcdUREMjgnLFxuICAgICdrZ3JlZW4nOiAnXFx1MDEzOCcsXG4gICAgJ2toY3knOiAnXFx1MDQ0NScsXG4gICAgJ2tqY3knOiAnXFx1MDQ1QycsXG4gICAgJ2tvcGYnOiAnXFx1RDgzNVxcdURENUMnLFxuICAgICdrc2NyJzogJ1xcdUQ4MzVcXHVEQ0MwJyxcbiAgICAnbEF0YWlsJzogJ1xcdTI5MUInLFxuICAgICdsQmFycic6ICdcXHUyOTBFJyxcbiAgICAnbEVnJzogJ1xcdTJBOEInLFxuICAgICdsZXNzZXFxZ3RyJzogJ1xcdTJBOEInLFxuICAgICdsSGFyJzogJ1xcdTI5NjInLFxuICAgICdsYWN1dGUnOiAnXFx1MDEzQScsXG4gICAgJ2xhZW1wdHl2JzogJ1xcdTI5QjQnLFxuICAgICdsYW1iZGEnOiAnXFx1MDNCQicsXG4gICAgJ2xhbmdkJzogJ1xcdTI5OTEnLFxuICAgICdsYXAnOiAnXFx1MkE4NScsXG4gICAgJ2xlc3NhcHByb3gnOiAnXFx1MkE4NScsXG4gICAgJ2xhcXVvJzogJ1xcdTAwQUInLFxuICAgICdsYXJyYmZzJzogJ1xcdTI5MUYnLFxuICAgICdsYXJyZnMnOiAnXFx1MjkxRCcsXG4gICAgJ2xhcnJscCc6ICdcXHUyMUFCJyxcbiAgICAnbG9vcGFycm93bGVmdCc6ICdcXHUyMUFCJyxcbiAgICAnbGFycnBsJzogJ1xcdTI5MzknLFxuICAgICdsYXJyc2ltJzogJ1xcdTI5NzMnLFxuICAgICdsYXJydGwnOiAnXFx1MjFBMicsXG4gICAgJ2xlZnRhcnJvd3RhaWwnOiAnXFx1MjFBMicsXG4gICAgJ2xhdCc6ICdcXHUyQUFCJyxcbiAgICAnbGF0YWlsJzogJ1xcdTI5MTknLFxuICAgICdsYXRlJzogJ1xcdTJBQUQnLFxuICAgICdsYXRlcyc6ICdcXHUyQUFEXFx1RkUwMCcsXG4gICAgJ2xiYXJyJzogJ1xcdTI5MEMnLFxuICAgICdsYmJyayc6ICdcXHUyNzcyJyxcbiAgICAnbGJyYWNlJzogJ1xcdTAwN0InLFxuICAgICdsY3ViJzogJ1xcdTAwN0InLFxuICAgICdsYnJhY2snOiAnXFx1MDA1QicsXG4gICAgJ2xzcWInOiAnXFx1MDA1QicsXG4gICAgJ2xicmtlJzogJ1xcdTI5OEInLFxuICAgICdsYnJrc2xkJzogJ1xcdTI5OEYnLFxuICAgICdsYnJrc2x1JzogJ1xcdTI5OEQnLFxuICAgICdsY2Fyb24nOiAnXFx1MDEzRScsXG4gICAgJ2xjZWRpbCc6ICdcXHUwMTNDJyxcbiAgICAnbGN5JzogJ1xcdTA0M0InLFxuICAgICdsZGNhJzogJ1xcdTI5MzYnLFxuICAgICdsZHJkaGFyJzogJ1xcdTI5NjcnLFxuICAgICdsZHJ1c2hhcic6ICdcXHUyOTRCJyxcbiAgICAnbGRzaCc6ICdcXHUyMUIyJyxcbiAgICAnbGUnOiAnXFx1MjI2NCcsXG4gICAgJ2xlcSc6ICdcXHUyMjY0JyxcbiAgICAnbGVmdGxlZnRhcnJvd3MnOiAnXFx1MjFDNycsXG4gICAgJ2xsYXJyJzogJ1xcdTIxQzcnLFxuICAgICdsZWZ0dGhyZWV0aW1lcyc6ICdcXHUyMkNCJyxcbiAgICAnbHRocmVlJzogJ1xcdTIyQ0InLFxuICAgICdsZXNjYyc6ICdcXHUyQUE4JyxcbiAgICAnbGVzZG90JzogJ1xcdTJBN0YnLFxuICAgICdsZXNkb3RvJzogJ1xcdTJBODEnLFxuICAgICdsZXNkb3Rvcic6ICdcXHUyQTgzJyxcbiAgICAnbGVzZyc6ICdcXHUyMkRBXFx1RkUwMCcsXG4gICAgJ2xlc2dlcyc6ICdcXHUyQTkzJyxcbiAgICAnbGVzc2RvdCc6ICdcXHUyMkQ2JyxcbiAgICAnbHRkb3QnOiAnXFx1MjJENicsXG4gICAgJ2xmaXNodCc6ICdcXHUyOTdDJyxcbiAgICAnbGZyJzogJ1xcdUQ4MzVcXHVERDI5JyxcbiAgICAnbGdFJzogJ1xcdTJBOTEnLFxuICAgICdsaGFydWwnOiAnXFx1Mjk2QScsXG4gICAgJ2xoYmxrJzogJ1xcdTI1ODQnLFxuICAgICdsamN5JzogJ1xcdTA0NTknLFxuICAgICdsbGhhcmQnOiAnXFx1Mjk2QicsXG4gICAgJ2xsdHJpJzogJ1xcdTI1RkEnLFxuICAgICdsbWlkb3QnOiAnXFx1MDE0MCcsXG4gICAgJ2xtb3VzdCc6ICdcXHUyM0IwJyxcbiAgICAnbG1vdXN0YWNoZSc6ICdcXHUyM0IwJyxcbiAgICAnbG5FJzogJ1xcdTIyNjgnLFxuICAgICdsbmVxcSc6ICdcXHUyMjY4JyxcbiAgICAnbG5hcCc6ICdcXHUyQTg5JyxcbiAgICAnbG5hcHByb3gnOiAnXFx1MkE4OScsXG4gICAgJ2xuZSc6ICdcXHUyQTg3JyxcbiAgICAnbG5lcSc6ICdcXHUyQTg3JyxcbiAgICAnbG5zaW0nOiAnXFx1MjJFNicsXG4gICAgJ2xvYW5nJzogJ1xcdTI3RUMnLFxuICAgICdsb2Fycic6ICdcXHUyMUZEJyxcbiAgICAnbG9uZ21hcHN0byc6ICdcXHUyN0ZDJyxcbiAgICAneG1hcCc6ICdcXHUyN0ZDJyxcbiAgICAnbG9vcGFycm93cmlnaHQnOiAnXFx1MjFBQycsXG4gICAgJ3JhcnJscCc6ICdcXHUyMUFDJyxcbiAgICAnbG9wYXInOiAnXFx1Mjk4NScsXG4gICAgJ2xvcGYnOiAnXFx1RDgzNVxcdURENUQnLFxuICAgICdsb3BsdXMnOiAnXFx1MkEyRCcsXG4gICAgJ2xvdGltZXMnOiAnXFx1MkEzNCcsXG4gICAgJ2xvd2FzdCc6ICdcXHUyMjE3JyxcbiAgICAnbG96JzogJ1xcdTI1Q0EnLFxuICAgICdsb3plbmdlJzogJ1xcdTI1Q0EnLFxuICAgICdscGFyJzogJ1xcdTAwMjgnLFxuICAgICdscGFybHQnOiAnXFx1Mjk5MycsXG4gICAgJ2xyaGFyZCc6ICdcXHUyOTZEJyxcbiAgICAnbHJtJzogJ1xcdTIwMEUnLFxuICAgICdscnRyaSc6ICdcXHUyMkJGJyxcbiAgICAnbHNhcXVvJzogJ1xcdTIwMzknLFxuICAgICdsc2NyJzogJ1xcdUQ4MzVcXHVEQ0MxJyxcbiAgICAnbHNpbWUnOiAnXFx1MkE4RCcsXG4gICAgJ2xzaW1nJzogJ1xcdTJBOEYnLFxuICAgICdsc3F1b3InOiAnXFx1MjAxQScsXG4gICAgJ3NicXVvJzogJ1xcdTIwMUEnLFxuICAgICdsc3Ryb2snOiAnXFx1MDE0MicsXG4gICAgJ2x0Y2MnOiAnXFx1MkFBNicsXG4gICAgJ2x0Y2lyJzogJ1xcdTJBNzknLFxuICAgICdsdGltZXMnOiAnXFx1MjJDOScsXG4gICAgJ2x0bGFycic6ICdcXHUyOTc2JyxcbiAgICAnbHRxdWVzdCc6ICdcXHUyQTdCJyxcbiAgICAnbHRyUGFyJzogJ1xcdTI5OTYnLFxuICAgICdsdHJpJzogJ1xcdTI1QzMnLFxuICAgICd0cmlhbmdsZWxlZnQnOiAnXFx1MjVDMycsXG4gICAgJ2x1cmRzaGFyJzogJ1xcdTI5NEEnLFxuICAgICdsdXJ1aGFyJzogJ1xcdTI5NjYnLFxuICAgICdsdmVydG5lcXEnOiAnXFx1MjI2OFxcdUZFMDAnLFxuICAgICdsdm5FJzogJ1xcdTIyNjhcXHVGRTAwJyxcbiAgICAnbUREb3QnOiAnXFx1MjIzQScsXG4gICAgJ21hY3InOiAnXFx1MDBBRicsXG4gICAgJ3N0cm5zJzogJ1xcdTAwQUYnLFxuICAgICdtYWxlJzogJ1xcdTI2NDInLFxuICAgICdtYWx0JzogJ1xcdTI3MjAnLFxuICAgICdtYWx0ZXNlJzogJ1xcdTI3MjAnLFxuICAgICdtYXJrZXInOiAnXFx1MjVBRScsXG4gICAgJ21jb21tYSc6ICdcXHUyQTI5JyxcbiAgICAnbWN5JzogJ1xcdTA0M0MnLFxuICAgICdtZGFzaCc6ICdcXHUyMDE0JyxcbiAgICAnbWZyJzogJ1xcdUQ4MzVcXHVERDJBJyxcbiAgICAnbWhvJzogJ1xcdTIxMjcnLFxuICAgICdtaWNybyc6ICdcXHUwMEI1JyxcbiAgICAnbWlkY2lyJzogJ1xcdTJBRjAnLFxuICAgICdtaW51cyc6ICdcXHUyMjEyJyxcbiAgICAnbWludXNkdSc6ICdcXHUyQTJBJyxcbiAgICAnbWxjcCc6ICdcXHUyQURCJyxcbiAgICAnbW9kZWxzJzogJ1xcdTIyQTcnLFxuICAgICdtb3BmJzogJ1xcdUQ4MzVcXHVERDVFJyxcbiAgICAnbXNjcic6ICdcXHVEODM1XFx1RENDMicsXG4gICAgJ211JzogJ1xcdTAzQkMnLFxuICAgICdtdWx0aW1hcCc6ICdcXHUyMkI4JyxcbiAgICAnbXVtYXAnOiAnXFx1MjJCOCcsXG4gICAgJ25HZyc6ICdcXHUyMkQ5XFx1MDMzOCcsXG4gICAgJ25HdCc6ICdcXHUyMjZCXFx1MjBEMicsXG4gICAgJ25MZWZ0YXJyb3cnOiAnXFx1MjFDRCcsXG4gICAgJ25sQXJyJzogJ1xcdTIxQ0QnLFxuICAgICduTGVmdHJpZ2h0YXJyb3cnOiAnXFx1MjFDRScsXG4gICAgJ25oQXJyJzogJ1xcdTIxQ0UnLFxuICAgICduTGwnOiAnXFx1MjJEOFxcdTAzMzgnLFxuICAgICduTHQnOiAnXFx1MjI2QVxcdTIwRDInLFxuICAgICduUmlnaHRhcnJvdyc6ICdcXHUyMUNGJyxcbiAgICAnbnJBcnInOiAnXFx1MjFDRicsXG4gICAgJ25WRGFzaCc6ICdcXHUyMkFGJyxcbiAgICAnblZkYXNoJzogJ1xcdTIyQUUnLFxuICAgICduYWN1dGUnOiAnXFx1MDE0NCcsXG4gICAgJ25hbmcnOiAnXFx1MjIyMFxcdTIwRDInLFxuICAgICduYXBFJzogJ1xcdTJBNzBcXHUwMzM4JyxcbiAgICAnbmFwaWQnOiAnXFx1MjI0QlxcdTAzMzgnLFxuICAgICduYXBvcyc6ICdcXHUwMTQ5JyxcbiAgICAnbmF0dXInOiAnXFx1MjY2RScsXG4gICAgJ25hdHVyYWwnOiAnXFx1MjY2RScsXG4gICAgJ25jYXAnOiAnXFx1MkE0MycsXG4gICAgJ25jYXJvbic6ICdcXHUwMTQ4JyxcbiAgICAnbmNlZGlsJzogJ1xcdTAxNDYnLFxuICAgICduY29uZ2RvdCc6ICdcXHUyQTZEXFx1MDMzOCcsXG4gICAgJ25jdXAnOiAnXFx1MkE0MicsXG4gICAgJ25jeSc6ICdcXHUwNDNEJyxcbiAgICAnbmRhc2gnOiAnXFx1MjAxMycsXG4gICAgJ25lQXJyJzogJ1xcdTIxRDcnLFxuICAgICduZWFyaGsnOiAnXFx1MjkyNCcsXG4gICAgJ25lZG90JzogJ1xcdTIyNTBcXHUwMzM4JyxcbiAgICAnbmVzZWFyJzogJ1xcdTI5MjgnLFxuICAgICd0b2VhJzogJ1xcdTI5MjgnLFxuICAgICduZnInOiAnXFx1RDgzNVxcdUREMkInLFxuICAgICduaGFycic6ICdcXHUyMUFFJyxcbiAgICAnbmxlZnRyaWdodGFycm93JzogJ1xcdTIxQUUnLFxuICAgICduaHBhcic6ICdcXHUyQUYyJyxcbiAgICAnbmlzJzogJ1xcdTIyRkMnLFxuICAgICduaXNkJzogJ1xcdTIyRkEnLFxuICAgICduamN5JzogJ1xcdTA0NUEnLFxuICAgICdubEUnOiAnXFx1MjI2NlxcdTAzMzgnLFxuICAgICdubGVxcSc6ICdcXHUyMjY2XFx1MDMzOCcsXG4gICAgJ25sYXJyJzogJ1xcdTIxOUEnLFxuICAgICdubGVmdGFycm93JzogJ1xcdTIxOUEnLFxuICAgICdubGRyJzogJ1xcdTIwMjUnLFxuICAgICdub3BmJzogJ1xcdUQ4MzVcXHVERDVGJyxcbiAgICAnbm90JzogJ1xcdTAwQUMnLFxuICAgICdub3RpbkUnOiAnXFx1MjJGOVxcdTAzMzgnLFxuICAgICdub3RpbmRvdCc6ICdcXHUyMkY1XFx1MDMzOCcsXG4gICAgJ25vdGludmInOiAnXFx1MjJGNycsXG4gICAgJ25vdGludmMnOiAnXFx1MjJGNicsXG4gICAgJ25vdG5pdmInOiAnXFx1MjJGRScsXG4gICAgJ25vdG5pdmMnOiAnXFx1MjJGRCcsXG4gICAgJ25wYXJzbCc6ICdcXHUyQUZEXFx1MjBFNScsXG4gICAgJ25wYXJ0JzogJ1xcdTIyMDJcXHUwMzM4JyxcbiAgICAnbnBvbGludCc6ICdcXHUyQTE0JyxcbiAgICAnbnJhcnInOiAnXFx1MjE5QicsXG4gICAgJ25yaWdodGFycm93JzogJ1xcdTIxOUInLFxuICAgICducmFycmMnOiAnXFx1MjkzM1xcdTAzMzgnLFxuICAgICducmFycncnOiAnXFx1MjE5RFxcdTAzMzgnLFxuICAgICduc2NyJzogJ1xcdUQ4MzVcXHVEQ0MzJyxcbiAgICAnbnN1Yic6ICdcXHUyMjg0JyxcbiAgICAnbnN1YkUnOiAnXFx1MkFDNVxcdTAzMzgnLFxuICAgICduc3Vic2V0ZXFxJzogJ1xcdTJBQzVcXHUwMzM4JyxcbiAgICAnbnN1cCc6ICdcXHUyMjg1JyxcbiAgICAnbnN1cEUnOiAnXFx1MkFDNlxcdTAzMzgnLFxuICAgICduc3Vwc2V0ZXFxJzogJ1xcdTJBQzZcXHUwMzM4JyxcbiAgICAnbnRpbGRlJzogJ1xcdTAwRjEnLFxuICAgICdudSc6ICdcXHUwM0JEJyxcbiAgICAnbnVtJzogJ1xcdTAwMjMnLFxuICAgICdudW1lcm8nOiAnXFx1MjExNicsXG4gICAgJ251bXNwJzogJ1xcdTIwMDcnLFxuICAgICdudkRhc2gnOiAnXFx1MjJBRCcsXG4gICAgJ252SGFycic6ICdcXHUyOTA0JyxcbiAgICAnbnZhcCc6ICdcXHUyMjREXFx1MjBEMicsXG4gICAgJ252ZGFzaCc6ICdcXHUyMkFDJyxcbiAgICAnbnZnZSc6ICdcXHUyMjY1XFx1MjBEMicsXG4gICAgJ252Z3QnOiAnXFx1MDAzRVxcdTIwRDInLFxuICAgICdudmluZmluJzogJ1xcdTI5REUnLFxuICAgICdudmxBcnInOiAnXFx1MjkwMicsXG4gICAgJ252bGUnOiAnXFx1MjI2NFxcdTIwRDInLFxuICAgICdudmx0JzogJ1xcdTAwM0NcXHUyMEQyJyxcbiAgICAnbnZsdHJpZSc6ICdcXHUyMkI0XFx1MjBEMicsXG4gICAgJ252ckFycic6ICdcXHUyOTAzJyxcbiAgICAnbnZydHJpZSc6ICdcXHUyMkI1XFx1MjBEMicsXG4gICAgJ252c2ltJzogJ1xcdTIyM0NcXHUyMEQyJyxcbiAgICAnbndBcnInOiAnXFx1MjFENicsXG4gICAgJ253YXJoayc6ICdcXHUyOTIzJyxcbiAgICAnbnduZWFyJzogJ1xcdTI5MjcnLFxuICAgICdvYWN1dGUnOiAnXFx1MDBGMycsXG4gICAgJ29jaXJjJzogJ1xcdTAwRjQnLFxuICAgICdvY3knOiAnXFx1MDQzRScsXG4gICAgJ29kYmxhYyc6ICdcXHUwMTUxJyxcbiAgICAnb2Rpdic6ICdcXHUyQTM4JyxcbiAgICAnb2Rzb2xkJzogJ1xcdTI5QkMnLFxuICAgICdvZWxpZyc6ICdcXHUwMTUzJyxcbiAgICAnb2ZjaXInOiAnXFx1MjlCRicsXG4gICAgJ29mcic6ICdcXHVEODM1XFx1REQyQycsXG4gICAgJ29nb24nOiAnXFx1MDJEQicsXG4gICAgJ29ncmF2ZSc6ICdcXHUwMEYyJyxcbiAgICAnb2d0JzogJ1xcdTI5QzEnLFxuICAgICdvaGJhcic6ICdcXHUyOUI1JyxcbiAgICAnb2xjaXInOiAnXFx1MjlCRScsXG4gICAgJ29sY3Jvc3MnOiAnXFx1MjlCQicsXG4gICAgJ29sdCc6ICdcXHUyOUMwJyxcbiAgICAnb21hY3InOiAnXFx1MDE0RCcsXG4gICAgJ29tZWdhJzogJ1xcdTAzQzknLFxuICAgICdvbWljcm9uJzogJ1xcdTAzQkYnLFxuICAgICdvbWlkJzogJ1xcdTI5QjYnLFxuICAgICdvb3BmJzogJ1xcdUQ4MzVcXHVERDYwJyxcbiAgICAnb3Bhcic6ICdcXHUyOUI3JyxcbiAgICAnb3BlcnAnOiAnXFx1MjlCOScsXG4gICAgJ29yJzogJ1xcdTIyMjgnLFxuICAgICd2ZWUnOiAnXFx1MjIyOCcsXG4gICAgJ29yZCc6ICdcXHUyQTVEJyxcbiAgICAnb3JkZXInOiAnXFx1MjEzNCcsXG4gICAgJ29yZGVyb2YnOiAnXFx1MjEzNCcsXG4gICAgJ29zY3InOiAnXFx1MjEzNCcsXG4gICAgJ29yZGYnOiAnXFx1MDBBQScsXG4gICAgJ29yZG0nOiAnXFx1MDBCQScsXG4gICAgJ29yaWdvZic6ICdcXHUyMkI2JyxcbiAgICAnb3Jvcic6ICdcXHUyQTU2JyxcbiAgICAnb3JzbG9wZSc6ICdcXHUyQTU3JyxcbiAgICAnb3J2JzogJ1xcdTJBNUInLFxuICAgICdvc2xhc2gnOiAnXFx1MDBGOCcsXG4gICAgJ29zb2wnOiAnXFx1MjI5OCcsXG4gICAgJ290aWxkZSc6ICdcXHUwMEY1JyxcbiAgICAnb3RpbWVzYXMnOiAnXFx1MkEzNicsXG4gICAgJ291bWwnOiAnXFx1MDBGNicsXG4gICAgJ292YmFyJzogJ1xcdTIzM0QnLFxuICAgICdwYXJhJzogJ1xcdTAwQjYnLFxuICAgICdwYXJzaW0nOiAnXFx1MkFGMycsXG4gICAgJ3BhcnNsJzogJ1xcdTJBRkQnLFxuICAgICdwY3knOiAnXFx1MDQzRicsXG4gICAgJ3BlcmNudCc6ICdcXHUwMDI1JyxcbiAgICAncGVyaW9kJzogJ1xcdTAwMkUnLFxuICAgICdwZXJtaWwnOiAnXFx1MjAzMCcsXG4gICAgJ3BlcnRlbmsnOiAnXFx1MjAzMScsXG4gICAgJ3Bmcic6ICdcXHVEODM1XFx1REQyRCcsXG4gICAgJ3BoaSc6ICdcXHUwM0M2JyxcbiAgICAncGhpdic6ICdcXHUwM0Q1JyxcbiAgICAnc3RyYWlnaHRwaGknOiAnXFx1MDNENScsXG4gICAgJ3ZhcnBoaSc6ICdcXHUwM0Q1JyxcbiAgICAncGhvbmUnOiAnXFx1MjYwRScsXG4gICAgJ3BpJzogJ1xcdTAzQzAnLFxuICAgICdwaXYnOiAnXFx1MDNENicsXG4gICAgJ3ZhcnBpJzogJ1xcdTAzRDYnLFxuICAgICdwbGFuY2toJzogJ1xcdTIxMEUnLFxuICAgICdwbHVzJzogJ1xcdTAwMkInLFxuICAgICdwbHVzYWNpcic6ICdcXHUyQTIzJyxcbiAgICAncGx1c2Npcic6ICdcXHUyQTIyJyxcbiAgICAncGx1c2R1JzogJ1xcdTJBMjUnLFxuICAgICdwbHVzZSc6ICdcXHUyQTcyJyxcbiAgICAncGx1c3NpbSc6ICdcXHUyQTI2JyxcbiAgICAncGx1c3R3byc6ICdcXHUyQTI3JyxcbiAgICAncG9pbnRpbnQnOiAnXFx1MkExNScsXG4gICAgJ3BvcGYnOiAnXFx1RDgzNVxcdURENjEnLFxuICAgICdwb3VuZCc6ICdcXHUwMEEzJyxcbiAgICAncHJFJzogJ1xcdTJBQjMnLFxuICAgICdwcmFwJzogJ1xcdTJBQjcnLFxuICAgICdwcmVjYXBwcm94JzogJ1xcdTJBQjcnLFxuICAgICdwcmVjbmFwcHJveCc6ICdcXHUyQUI5JyxcbiAgICAncHJuYXAnOiAnXFx1MkFCOScsXG4gICAgJ3ByZWNuZXFxJzogJ1xcdTJBQjUnLFxuICAgICdwcm5FJzogJ1xcdTJBQjUnLFxuICAgICdwcmVjbnNpbSc6ICdcXHUyMkU4JyxcbiAgICAncHJuc2ltJzogJ1xcdTIyRTgnLFxuICAgICdwcmltZSc6ICdcXHUyMDMyJyxcbiAgICAncHJvZmFsYXInOiAnXFx1MjMyRScsXG4gICAgJ3Byb2ZsaW5lJzogJ1xcdTIzMTInLFxuICAgICdwcm9mc3VyZic6ICdcXHUyMzEzJyxcbiAgICAncHJ1cmVsJzogJ1xcdTIyQjAnLFxuICAgICdwc2NyJzogJ1xcdUQ4MzVcXHVEQ0M1JyxcbiAgICAncHNpJzogJ1xcdTAzQzgnLFxuICAgICdwdW5jc3AnOiAnXFx1MjAwOCcsXG4gICAgJ3Fmcic6ICdcXHVEODM1XFx1REQyRScsXG4gICAgJ3FvcGYnOiAnXFx1RDgzNVxcdURENjInLFxuICAgICdxcHJpbWUnOiAnXFx1MjA1NycsXG4gICAgJ3FzY3InOiAnXFx1RDgzNVxcdURDQzYnLFxuICAgICdxdWF0aW50JzogJ1xcdTJBMTYnLFxuICAgICdxdWVzdCc6ICdcXHUwMDNGJyxcbiAgICAnckF0YWlsJzogJ1xcdTI5MUMnLFxuICAgICdySGFyJzogJ1xcdTI5NjQnLFxuICAgICdyYWNlJzogJ1xcdTIyM0RcXHUwMzMxJyxcbiAgICAncmFjdXRlJzogJ1xcdTAxNTUnLFxuICAgICdyYWVtcHR5dic6ICdcXHUyOUIzJyxcbiAgICAncmFuZ2QnOiAnXFx1Mjk5MicsXG4gICAgJ3JhbmdlJzogJ1xcdTI5QTUnLFxuICAgICdyYXF1byc6ICdcXHUwMEJCJyxcbiAgICAncmFycmFwJzogJ1xcdTI5NzUnLFxuICAgICdyYXJyYmZzJzogJ1xcdTI5MjAnLFxuICAgICdyYXJyYyc6ICdcXHUyOTMzJyxcbiAgICAncmFycmZzJzogJ1xcdTI5MUUnLFxuICAgICdyYXJycGwnOiAnXFx1Mjk0NScsXG4gICAgJ3JhcnJzaW0nOiAnXFx1Mjk3NCcsXG4gICAgJ3JhcnJ0bCc6ICdcXHUyMUEzJyxcbiAgICAncmlnaHRhcnJvd3RhaWwnOiAnXFx1MjFBMycsXG4gICAgJ3JhcnJ3JzogJ1xcdTIxOUQnLFxuICAgICdyaWdodHNxdWlnYXJyb3cnOiAnXFx1MjE5RCcsXG4gICAgJ3JhdGFpbCc6ICdcXHUyOTFBJyxcbiAgICAncmF0aW8nOiAnXFx1MjIzNicsXG4gICAgJ3JiYnJrJzogJ1xcdTI3NzMnLFxuICAgICdyYnJhY2UnOiAnXFx1MDA3RCcsXG4gICAgJ3JjdWInOiAnXFx1MDA3RCcsXG4gICAgJ3JicmFjayc6ICdcXHUwMDVEJyxcbiAgICAncnNxYic6ICdcXHUwMDVEJyxcbiAgICAncmJya2UnOiAnXFx1Mjk4QycsXG4gICAgJ3JicmtzbGQnOiAnXFx1Mjk4RScsXG4gICAgJ3JicmtzbHUnOiAnXFx1Mjk5MCcsXG4gICAgJ3JjYXJvbic6ICdcXHUwMTU5JyxcbiAgICAncmNlZGlsJzogJ1xcdTAxNTcnLFxuICAgICdyY3knOiAnXFx1MDQ0MCcsXG4gICAgJ3JkY2EnOiAnXFx1MjkzNycsXG4gICAgJ3JkbGRoYXInOiAnXFx1Mjk2OScsXG4gICAgJ3Jkc2gnOiAnXFx1MjFCMycsXG4gICAgJ3JlY3QnOiAnXFx1MjVBRCcsXG4gICAgJ3JmaXNodCc6ICdcXHUyOTdEJyxcbiAgICAncmZyJzogJ1xcdUQ4MzVcXHVERDJGJyxcbiAgICAncmhhcnVsJzogJ1xcdTI5NkMnLFxuICAgICdyaG8nOiAnXFx1MDNDMScsXG4gICAgJ3Job3YnOiAnXFx1MDNGMScsXG4gICAgJ3ZhcnJobyc6ICdcXHUwM0YxJyxcbiAgICAncmlnaHRyaWdodGFycm93cyc6ICdcXHUyMUM5JyxcbiAgICAncnJhcnInOiAnXFx1MjFDOScsXG4gICAgJ3JpZ2h0dGhyZWV0aW1lcyc6ICdcXHUyMkNDJyxcbiAgICAncnRocmVlJzogJ1xcdTIyQ0MnLFxuICAgICdyaW5nJzogJ1xcdTAyREEnLFxuICAgICdybG0nOiAnXFx1MjAwRicsXG4gICAgJ3Jtb3VzdCc6ICdcXHUyM0IxJyxcbiAgICAncm1vdXN0YWNoZSc6ICdcXHUyM0IxJyxcbiAgICAncm5taWQnOiAnXFx1MkFFRScsXG4gICAgJ3JvYW5nJzogJ1xcdTI3RUQnLFxuICAgICdyb2Fycic6ICdcXHUyMUZFJyxcbiAgICAncm9wYXInOiAnXFx1Mjk4NicsXG4gICAgJ3JvcGYnOiAnXFx1RDgzNVxcdURENjMnLFxuICAgICdyb3BsdXMnOiAnXFx1MkEyRScsXG4gICAgJ3JvdGltZXMnOiAnXFx1MkEzNScsXG4gICAgJ3JwYXInOiAnXFx1MDAyOScsXG4gICAgJ3JwYXJndCc6ICdcXHUyOTk0JyxcbiAgICAncnBwb2xpbnQnOiAnXFx1MkExMicsXG4gICAgJ3JzYXF1byc6ICdcXHUyMDNBJyxcbiAgICAncnNjcic6ICdcXHVEODM1XFx1RENDNycsXG4gICAgJ3J0aW1lcyc6ICdcXHUyMkNBJyxcbiAgICAncnRyaSc6ICdcXHUyNUI5JyxcbiAgICAndHJpYW5nbGVyaWdodCc6ICdcXHUyNUI5JyxcbiAgICAncnRyaWx0cmknOiAnXFx1MjlDRScsXG4gICAgJ3J1bHVoYXInOiAnXFx1Mjk2OCcsXG4gICAgJ3J4JzogJ1xcdTIxMUUnLFxuICAgICdzYWN1dGUnOiAnXFx1MDE1QicsXG4gICAgJ3NjRSc6ICdcXHUyQUI0JyxcbiAgICAnc2NhcCc6ICdcXHUyQUI4JyxcbiAgICAnc3VjY2FwcHJveCc6ICdcXHUyQUI4JyxcbiAgICAnc2Nhcm9uJzogJ1xcdTAxNjEnLFxuICAgICdzY2VkaWwnOiAnXFx1MDE1RicsXG4gICAgJ3NjaXJjJzogJ1xcdTAxNUQnLFxuICAgICdzY25FJzogJ1xcdTJBQjYnLFxuICAgICdzdWNjbmVxcSc6ICdcXHUyQUI2JyxcbiAgICAnc2NuYXAnOiAnXFx1MkFCQScsXG4gICAgJ3N1Y2NuYXBwcm94JzogJ1xcdTJBQkEnLFxuICAgICdzY25zaW0nOiAnXFx1MjJFOScsXG4gICAgJ3N1Y2Nuc2ltJzogJ1xcdTIyRTknLFxuICAgICdzY3BvbGludCc6ICdcXHUyQTEzJyxcbiAgICAnc2N5JzogJ1xcdTA0NDEnLFxuICAgICdzZG90JzogJ1xcdTIyQzUnLFxuICAgICdzZG90ZSc6ICdcXHUyQTY2JyxcbiAgICAnc2VBcnInOiAnXFx1MjFEOCcsXG4gICAgJ3NlY3QnOiAnXFx1MDBBNycsXG4gICAgJ3NlbWknOiAnXFx1MDAzQicsXG4gICAgJ3Nlc3dhcic6ICdcXHUyOTI5JyxcbiAgICAndG9zYSc6ICdcXHUyOTI5JyxcbiAgICAnc2V4dCc6ICdcXHUyNzM2JyxcbiAgICAnc2ZyJzogJ1xcdUQ4MzVcXHVERDMwJyxcbiAgICAnc2hhcnAnOiAnXFx1MjY2RicsXG4gICAgJ3NoY2hjeSc6ICdcXHUwNDQ5JyxcbiAgICAnc2hjeSc6ICdcXHUwNDQ4JyxcbiAgICAnc2h5JzogJ1xcdTAwQUQnLFxuICAgICdzaWdtYSc6ICdcXHUwM0MzJyxcbiAgICAnc2lnbWFmJzogJ1xcdTAzQzInLFxuICAgICdzaWdtYXYnOiAnXFx1MDNDMicsXG4gICAgJ3ZhcnNpZ21hJzogJ1xcdTAzQzInLFxuICAgICdzaW1kb3QnOiAnXFx1MkE2QScsXG4gICAgJ3NpbWcnOiAnXFx1MkE5RScsXG4gICAgJ3NpbWdFJzogJ1xcdTJBQTAnLFxuICAgICdzaW1sJzogJ1xcdTJBOUQnLFxuICAgICdzaW1sRSc6ICdcXHUyQTlGJyxcbiAgICAnc2ltbmUnOiAnXFx1MjI0NicsXG4gICAgJ3NpbXBsdXMnOiAnXFx1MkEyNCcsXG4gICAgJ3NpbXJhcnInOiAnXFx1Mjk3MicsXG4gICAgJ3NtYXNocCc6ICdcXHUyQTMzJyxcbiAgICAnc21lcGFyc2wnOiAnXFx1MjlFNCcsXG4gICAgJ3NtaWxlJzogJ1xcdTIzMjMnLFxuICAgICdzc21pbGUnOiAnXFx1MjMyMycsXG4gICAgJ3NtdCc6ICdcXHUyQUFBJyxcbiAgICAnc210ZSc6ICdcXHUyQUFDJyxcbiAgICAnc210ZXMnOiAnXFx1MkFBQ1xcdUZFMDAnLFxuICAgICdzb2Z0Y3knOiAnXFx1MDQ0QycsXG4gICAgJ3NvbCc6ICdcXHUwMDJGJyxcbiAgICAnc29sYic6ICdcXHUyOUM0JyxcbiAgICAnc29sYmFyJzogJ1xcdTIzM0YnLFxuICAgICdzb3BmJzogJ1xcdUQ4MzVcXHVERDY0JyxcbiAgICAnc3BhZGVzJzogJ1xcdTI2NjAnLFxuICAgICdzcGFkZXN1aXQnOiAnXFx1MjY2MCcsXG4gICAgJ3NxY2Fwcyc6ICdcXHUyMjkzXFx1RkUwMCcsXG4gICAgJ3NxY3Vwcyc6ICdcXHUyMjk0XFx1RkUwMCcsXG4gICAgJ3NzY3InOiAnXFx1RDgzNVxcdURDQzgnLFxuICAgICdzdGFyJzogJ1xcdTI2MDYnLFxuICAgICdzdWInOiAnXFx1MjI4MicsXG4gICAgJ3N1YnNldCc6ICdcXHUyMjgyJyxcbiAgICAnc3ViRSc6ICdcXHUyQUM1JyxcbiAgICAnc3Vic2V0ZXFxJzogJ1xcdTJBQzUnLFxuICAgICdzdWJkb3QnOiAnXFx1MkFCRCcsXG4gICAgJ3N1YmVkb3QnOiAnXFx1MkFDMycsXG4gICAgJ3N1Ym11bHQnOiAnXFx1MkFDMScsXG4gICAgJ3N1Ym5FJzogJ1xcdTJBQ0InLFxuICAgICdzdWJzZXRuZXFxJzogJ1xcdTJBQ0InLFxuICAgICdzdWJuZSc6ICdcXHUyMjhBJyxcbiAgICAnc3Vic2V0bmVxJzogJ1xcdTIyOEEnLFxuICAgICdzdWJwbHVzJzogJ1xcdTJBQkYnLFxuICAgICdzdWJyYXJyJzogJ1xcdTI5NzknLFxuICAgICdzdWJzaW0nOiAnXFx1MkFDNycsXG4gICAgJ3N1YnN1Yic6ICdcXHUyQUQ1JyxcbiAgICAnc3Vic3VwJzogJ1xcdTJBRDMnLFxuICAgICdzdW5nJzogJ1xcdTI2NkEnLFxuICAgICdzdXAxJzogJ1xcdTAwQjknLFxuICAgICdzdXAyJzogJ1xcdTAwQjInLFxuICAgICdzdXAzJzogJ1xcdTAwQjMnLFxuICAgICdzdXBFJzogJ1xcdTJBQzYnLFxuICAgICdzdXBzZXRlcXEnOiAnXFx1MkFDNicsXG4gICAgJ3N1cGRvdCc6ICdcXHUyQUJFJyxcbiAgICAnc3VwZHN1Yic6ICdcXHUyQUQ4JyxcbiAgICAnc3VwZWRvdCc6ICdcXHUyQUM0JyxcbiAgICAnc3VwaHNvbCc6ICdcXHUyN0M5JyxcbiAgICAnc3VwaHN1Yic6ICdcXHUyQUQ3JyxcbiAgICAnc3VwbGFycic6ICdcXHUyOTdCJyxcbiAgICAnc3VwbXVsdCc6ICdcXHUyQUMyJyxcbiAgICAnc3VwbkUnOiAnXFx1MkFDQycsXG4gICAgJ3N1cHNldG5lcXEnOiAnXFx1MkFDQycsXG4gICAgJ3N1cG5lJzogJ1xcdTIyOEInLFxuICAgICdzdXBzZXRuZXEnOiAnXFx1MjI4QicsXG4gICAgJ3N1cHBsdXMnOiAnXFx1MkFDMCcsXG4gICAgJ3N1cHNpbSc6ICdcXHUyQUM4JyxcbiAgICAnc3Vwc3ViJzogJ1xcdTJBRDQnLFxuICAgICdzdXBzdXAnOiAnXFx1MkFENicsXG4gICAgJ3N3QXJyJzogJ1xcdTIxRDknLFxuICAgICdzd253YXInOiAnXFx1MjkyQScsXG4gICAgJ3N6bGlnJzogJ1xcdTAwREYnLFxuICAgICd0YXJnZXQnOiAnXFx1MjMxNicsXG4gICAgJ3RhdSc6ICdcXHUwM0M0JyxcbiAgICAndGNhcm9uJzogJ1xcdTAxNjUnLFxuICAgICd0Y2VkaWwnOiAnXFx1MDE2MycsXG4gICAgJ3RjeSc6ICdcXHUwNDQyJyxcbiAgICAndGVscmVjJzogJ1xcdTIzMTUnLFxuICAgICd0ZnInOiAnXFx1RDgzNVxcdUREMzEnLFxuICAgICd0aGV0YSc6ICdcXHUwM0I4JyxcbiAgICAndGhldGFzeW0nOiAnXFx1MDNEMScsXG4gICAgJ3RoZXRhdic6ICdcXHUwM0QxJyxcbiAgICAndmFydGhldGEnOiAnXFx1MDNEMScsXG4gICAgJ3Rob3JuJzogJ1xcdTAwRkUnLFxuICAgICd0aW1lcyc6ICdcXHUwMEQ3JyxcbiAgICAndGltZXNiYXInOiAnXFx1MkEzMScsXG4gICAgJ3RpbWVzZCc6ICdcXHUyQTMwJyxcbiAgICAndG9wYm90JzogJ1xcdTIzMzYnLFxuICAgICd0b3BjaXInOiAnXFx1MkFGMScsXG4gICAgJ3RvcGYnOiAnXFx1RDgzNVxcdURENjUnLFxuICAgICd0b3Bmb3JrJzogJ1xcdTJBREEnLFxuICAgICd0cHJpbWUnOiAnXFx1MjAzNCcsXG4gICAgJ3RyaWFuZ2xlJzogJ1xcdTI1QjUnLFxuICAgICd1dHJpJzogJ1xcdTI1QjUnLFxuICAgICd0cmlhbmdsZXEnOiAnXFx1MjI1QycsXG4gICAgJ3RyaWUnOiAnXFx1MjI1QycsXG4gICAgJ3RyaWRvdCc6ICdcXHUyNUVDJyxcbiAgICAndHJpbWludXMnOiAnXFx1MkEzQScsXG4gICAgJ3RyaXBsdXMnOiAnXFx1MkEzOScsXG4gICAgJ3RyaXNiJzogJ1xcdTI5Q0QnLFxuICAgICd0cml0aW1lJzogJ1xcdTJBM0InLFxuICAgICd0cnBleml1bSc6ICdcXHUyM0UyJyxcbiAgICAndHNjcic6ICdcXHVEODM1XFx1RENDOScsXG4gICAgJ3RzY3knOiAnXFx1MDQ0NicsXG4gICAgJ3RzaGN5JzogJ1xcdTA0NUInLFxuICAgICd0c3Ryb2snOiAnXFx1MDE2NycsXG4gICAgJ3VIYXInOiAnXFx1Mjk2MycsXG4gICAgJ3VhY3V0ZSc6ICdcXHUwMEZBJyxcbiAgICAndWJyY3knOiAnXFx1MDQ1RScsXG4gICAgJ3VicmV2ZSc6ICdcXHUwMTZEJyxcbiAgICAndWNpcmMnOiAnXFx1MDBGQicsXG4gICAgJ3VjeSc6ICdcXHUwNDQzJyxcbiAgICAndWRibGFjJzogJ1xcdTAxNzEnLFxuICAgICd1ZmlzaHQnOiAnXFx1Mjk3RScsXG4gICAgJ3Vmcic6ICdcXHVEODM1XFx1REQzMicsXG4gICAgJ3VncmF2ZSc6ICdcXHUwMEY5JyxcbiAgICAndWhibGsnOiAnXFx1MjU4MCcsXG4gICAgJ3VsY29ybic6ICdcXHUyMzFDJyxcbiAgICAndWxjb3JuZXInOiAnXFx1MjMxQycsXG4gICAgJ3VsY3JvcCc6ICdcXHUyMzBGJyxcbiAgICAndWx0cmknOiAnXFx1MjVGOCcsXG4gICAgJ3VtYWNyJzogJ1xcdTAxNkInLFxuICAgICd1b2dvbic6ICdcXHUwMTczJyxcbiAgICAndW9wZic6ICdcXHVEODM1XFx1REQ2NicsXG4gICAgJ3Vwc2knOiAnXFx1MDNDNScsXG4gICAgJ3Vwc2lsb24nOiAnXFx1MDNDNScsXG4gICAgJ3VwdXBhcnJvd3MnOiAnXFx1MjFDOCcsXG4gICAgJ3V1YXJyJzogJ1xcdTIxQzgnLFxuICAgICd1cmNvcm4nOiAnXFx1MjMxRCcsXG4gICAgJ3VyY29ybmVyJzogJ1xcdTIzMUQnLFxuICAgICd1cmNyb3AnOiAnXFx1MjMwRScsXG4gICAgJ3VyaW5nJzogJ1xcdTAxNkYnLFxuICAgICd1cnRyaSc6ICdcXHUyNUY5JyxcbiAgICAndXNjcic6ICdcXHVEODM1XFx1RENDQScsXG4gICAgJ3V0ZG90JzogJ1xcdTIyRjAnLFxuICAgICd1dGlsZGUnOiAnXFx1MDE2OScsXG4gICAgJ3V1bWwnOiAnXFx1MDBGQycsXG4gICAgJ3V3YW5nbGUnOiAnXFx1MjlBNycsXG4gICAgJ3ZCYXInOiAnXFx1MkFFOCcsXG4gICAgJ3ZCYXJ2JzogJ1xcdTJBRTknLFxuICAgICd2YW5ncnQnOiAnXFx1Mjk5QycsXG4gICAgJ3ZhcnN1YnNldG5lcSc6ICdcXHUyMjhBXFx1RkUwMCcsXG4gICAgJ3ZzdWJuZSc6ICdcXHUyMjhBXFx1RkUwMCcsXG4gICAgJ3ZhcnN1YnNldG5lcXEnOiAnXFx1MkFDQlxcdUZFMDAnLFxuICAgICd2c3VibkUnOiAnXFx1MkFDQlxcdUZFMDAnLFxuICAgICd2YXJzdXBzZXRuZXEnOiAnXFx1MjI4QlxcdUZFMDAnLFxuICAgICd2c3VwbmUnOiAnXFx1MjI4QlxcdUZFMDAnLFxuICAgICd2YXJzdXBzZXRuZXFxJzogJ1xcdTJBQ0NcXHVGRTAwJyxcbiAgICAndnN1cG5FJzogJ1xcdTJBQ0NcXHVGRTAwJyxcbiAgICAndmN5JzogJ1xcdTA0MzInLFxuICAgICd2ZWViYXInOiAnXFx1MjJCQicsXG4gICAgJ3ZlZWVxJzogJ1xcdTIyNUEnLFxuICAgICd2ZWxsaXAnOiAnXFx1MjJFRScsXG4gICAgJ3Zmcic6ICdcXHVEODM1XFx1REQzMycsXG4gICAgJ3ZvcGYnOiAnXFx1RDgzNVxcdURENjcnLFxuICAgICd2c2NyJzogJ1xcdUQ4MzVcXHVEQ0NCJyxcbiAgICAndnppZ3phZyc6ICdcXHUyOTlBJyxcbiAgICAnd2NpcmMnOiAnXFx1MDE3NScsXG4gICAgJ3dlZGJhcic6ICdcXHUyQTVGJyxcbiAgICAnd2VkZ2VxJzogJ1xcdTIyNTknLFxuICAgICd3ZWllcnAnOiAnXFx1MjExOCcsXG4gICAgJ3dwJzogJ1xcdTIxMTgnLFxuICAgICd3ZnInOiAnXFx1RDgzNVxcdUREMzQnLFxuICAgICd3b3BmJzogJ1xcdUQ4MzVcXHVERDY4JyxcbiAgICAnd3Njcic6ICdcXHVEODM1XFx1RENDQycsXG4gICAgJ3hmcic6ICdcXHVEODM1XFx1REQzNScsXG4gICAgJ3hpJzogJ1xcdTAzQkUnLFxuICAgICd4bmlzJzogJ1xcdTIyRkInLFxuICAgICd4b3BmJzogJ1xcdUQ4MzVcXHVERDY5JyxcbiAgICAneHNjcic6ICdcXHVEODM1XFx1RENDRCcsXG4gICAgJ3lhY3V0ZSc6ICdcXHUwMEZEJyxcbiAgICAneWFjeSc6ICdcXHUwNDRGJyxcbiAgICAneWNpcmMnOiAnXFx1MDE3NycsXG4gICAgJ3ljeSc6ICdcXHUwNDRCJyxcbiAgICAneWVuJzogJ1xcdTAwQTUnLFxuICAgICd5ZnInOiAnXFx1RDgzNVxcdUREMzYnLFxuICAgICd5aWN5JzogJ1xcdTA0NTcnLFxuICAgICd5b3BmJzogJ1xcdUQ4MzVcXHVERDZBJyxcbiAgICAneXNjcic6ICdcXHVEODM1XFx1RENDRScsXG4gICAgJ3l1Y3knOiAnXFx1MDQ0RScsXG4gICAgJ3l1bWwnOiAnXFx1MDBGRicsXG4gICAgJ3phY3V0ZSc6ICdcXHUwMTdBJyxcbiAgICAnemNhcm9uJzogJ1xcdTAxN0UnLFxuICAgICd6Y3knOiAnXFx1MDQzNycsXG4gICAgJ3pkb3QnOiAnXFx1MDE3QycsXG4gICAgJ3pldGEnOiAnXFx1MDNCNicsXG4gICAgJ3pmcic6ICdcXHVEODM1XFx1REQzNycsXG4gICAgJ3poY3knOiAnXFx1MDQzNicsXG4gICAgJ3ppZ3JhcnInOiAnXFx1MjFERCcsXG4gICAgJ3pvcGYnOiAnXFx1RDgzNVxcdURENkInLFxuICAgICd6c2NyJzogJ1xcdUQ4MzVcXHVEQ0NGJyxcbiAgICAnendqJzogJ1xcdTIwMEQnLFxuICAgICd6d25qJzogJ1xcdTIwMEMnXG59O1xuLy8gVGhlICZuZ3NwOyBwc2V1ZG8tZW50aXR5IGlzIGRlbm90aW5nIGEgc3BhY2UuIHNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJ0LWxhbmcvYW5ndWxhci9ibG9iLzBiYjYxMTM4N2QyOWQ2NWI1YWY3ZjlkMjUxNWFiNTcxZmQzZmJlZTQvX3Rlc3RzL3Rlc3QvY29tcGlsZXIvcHJlc2VydmVfd2hpdGVzcGFjZV90ZXN0LmRhcnRcbmNvbnN0IE5HU1BfVU5JQ09ERSA9ICdcXHVFNTAwJztcbk5BTUVEX0VOVElUSUVTWyduZ3NwJ10gPSBOR1NQX1VOSUNPREU7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgVG9rZW5FcnJvciBleHRlbmRzIFBhcnNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9yTXNnLCB0b2tlblR5cGUsIHNwYW4pIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgZXJyb3JNc2cpO1xuICAgICAgICB0aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcbiAgICB9XG59XG5jbGFzcyBUb2tlbml6ZVJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IodG9rZW5zLCBlcnJvcnMsIG5vbk5vcm1hbGl6ZWRJY3VFeHByZXNzaW9ucykge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMubm9uTm9ybWFsaXplZEljdUV4cHJlc3Npb25zID0gbm9uTm9ybWFsaXplZEljdUV4cHJlc3Npb25zO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRva2VuaXplKHNvdXJjZSwgdXJsLCBnZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB0b2tlbml6ZXIgPSBuZXcgX1Rva2VuaXplcihuZXcgUGFyc2VTb3VyY2VGaWxlKHNvdXJjZSwgdXJsKSwgZ2V0VGFnRGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gICAgdG9rZW5pemVyLnRva2VuaXplKCk7XG4gICAgcmV0dXJuIG5ldyBUb2tlbml6ZVJlc3VsdChtZXJnZVRleHRUb2tlbnModG9rZW5pemVyLnRva2VucyksIHRva2VuaXplci5lcnJvcnMsIHRva2VuaXplci5ub25Ob3JtYWxpemVkSWN1RXhwcmVzc2lvbnMpO1xufVxuY29uc3QgX0NSX09SX0NSTEZfUkVHRVhQID0gL1xcclxcbj8vZztcbmZ1bmN0aW9uIF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2coY2hhckNvZGUpIHtcbiAgICBjb25zdCBjaGFyID0gY2hhckNvZGUgPT09ICRFT0YgPyAnRU9GJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIHJldHVybiBgVW5leHBlY3RlZCBjaGFyYWN0ZXIgXCIke2NoYXJ9XCJgO1xufVxuZnVuY3Rpb24gX3Vua25vd25FbnRpdHlFcnJvck1zZyhlbnRpdHlTcmMpIHtcbiAgICByZXR1cm4gYFVua25vd24gZW50aXR5IFwiJHtlbnRpdHlTcmN9XCIgLSB1c2UgdGhlIFwiJiM8ZGVjaW1hbD47XCIgb3IgIFwiJiN4PGhleD47XCIgc3ludGF4YDtcbn1cbmZ1bmN0aW9uIF91bnBhcnNhYmxlRW50aXR5RXJyb3JNc2codHlwZSwgZW50aXR5U3RyKSB7XG4gICAgcmV0dXJuIGBVbmFibGUgdG8gcGFyc2UgZW50aXR5IFwiJHtlbnRpdHlTdHJ9XCIgLSAke3R5cGV9IGNoYXJhY3RlciByZWZlcmVuY2UgZW50aXRpZXMgbXVzdCBlbmQgd2l0aCBcIjtcImA7XG59XG52YXIgQ2hhcmFjdGVyUmVmZXJlbmNlVHlwZTtcbihmdW5jdGlvbiAoQ2hhcmFjdGVyUmVmZXJlbmNlVHlwZSkge1xuICAgIENoYXJhY3RlclJlZmVyZW5jZVR5cGVbXCJIRVhcIl0gPSBcImhleGFkZWNpbWFsXCI7XG4gICAgQ2hhcmFjdGVyUmVmZXJlbmNlVHlwZVtcIkRFQ1wiXSA9IFwiZGVjaW1hbFwiO1xufSkoQ2hhcmFjdGVyUmVmZXJlbmNlVHlwZSB8fCAoQ2hhcmFjdGVyUmVmZXJlbmNlVHlwZSA9IHt9KSk7XG5jbGFzcyBfQ29udHJvbEZsb3dFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbn1cbi8vIFNlZSBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI3dyaXRpbmctaHRtbC1kb2N1bWVudHNcbmNsYXNzIF9Ub2tlbml6ZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBfZmlsZSBUaGUgaHRtbCBzb3VyY2UgZmlsZSBiZWluZyB0b2tlbml6ZWQuXG4gICAgICogQHBhcmFtIF9nZXRUYWdEZWZpbml0aW9uIEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHJpZXZlIGEgdGFnIGRlZmluaXRpb24gZm9yIGEgZ2l2ZW4gdGFnIG5hbWUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvZiB0aGUgdG9rZW5pemF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9maWxlLCBfZ2V0VGFnRGVmaW5pdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9nZXRUYWdEZWZpbml0aW9uID0gX2dldFRhZ0RlZmluaXRpb247XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ub25Ob3JtYWxpemVkSWN1RXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fdG9rZW5pemVJY3UgPSBvcHRpb25zLnRva2VuaXplRXhwYW5zaW9uRm9ybXMgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcgPSBvcHRpb25zLmludGVycG9sYXRpb25Db25maWcgfHwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRztcbiAgICAgICAgdGhpcy5fbGVhZGluZ1RyaXZpYUNvZGVQb2ludHMgPVxuICAgICAgICAgICAgb3B0aW9ucy5sZWFkaW5nVHJpdmlhQ2hhcnMgJiYgb3B0aW9ucy5sZWFkaW5nVHJpdmlhQ2hhcnMubWFwKGMgPT4gYy5jb2RlUG9pbnRBdCgwKSB8fCAwKTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLnJhbmdlIHx8IHsgZW5kUG9zOiBfZmlsZS5jb250ZW50Lmxlbmd0aCwgc3RhcnRQb3M6IDAsIHN0YXJ0TGluZTogMCwgc3RhcnRDb2w6IDAgfTtcbiAgICAgICAgdGhpcy5fY3Vyc29yID0gb3B0aW9ucy5lc2NhcGVkU3RyaW5nID8gbmV3IEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IoX2ZpbGUsIHJhbmdlKSA6XG4gICAgICAgICAgICBuZXcgUGxhaW5DaGFyYWN0ZXJDdXJzb3IoX2ZpbGUsIHJhbmdlKTtcbiAgICAgICAgdGhpcy5fcHJlc2VydmVMaW5lRW5kaW5ncyA9IG9wdGlvbnMucHJlc2VydmVMaW5lRW5kaW5ncyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXNjYXBlZFN0cmluZyA9IG9wdGlvbnMuZXNjYXBlZFN0cmluZyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5faTE4bk5vcm1hbGl6ZUxpbmVFbmRpbmdzSW5JQ1VzID0gb3B0aW9ucy5pMThuTm9ybWFsaXplTGluZUVuZGluZ3NJbklDVXMgfHwgZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ByZXNlcnZlTGluZUVuZGluZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGtlZXAgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIGluIHRoZSBzb3VyY2UsIHdlIGNhbiBub3RcbiAgICAgICAgLy8gcHJlLXByb2Nlc3MgaXQuXG4gICAgICAgIC8vIEluc3RlYWQgQ1JzIGFyZSBwcm9jZXNzZWQgcmlnaHQgYmVmb3JlIGluc3RhbnRpYXRpbmcgdGhlIHRva2Vucy5cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZShfQ1JfT1JfQ1JMRl9SRUdFWFAsICdcXG4nKTtcbiAgICB9XG4gICAgdG9rZW5pemUoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkRU9GKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRMVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkQkFORykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDZGF0YShzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJE1JTlVTKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDb21tZW50KHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVEb2NUeXBlKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ0Nsb3NlKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHRoaXMuX3Rva2VuaXplSWN1ICYmIHRoaXMuX3Rva2VuaXplRXhwYW5zaW9uRm9ybSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiAocG9zc2libHkgaW50ZXJwb2xhdGVkKSB0ZXh0IHRoZSBlbmQgb2YgdGhlIHRleHQgaXMgZ2l2ZW4gYnkgYGlzVGV4dEVuZCgpYCwgd2hpbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByZW1hdHVyZSBlbmQgb2YgYW4gaW50ZXJwb2xhdGlvbiBpcyBnaXZlbiBieSB0aGUgc3RhcnQgb2YgYSBuZXcgSFRNTCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lV2l0aEludGVycG9sYXRpb24oNSAvKiBUb2tlblR5cGUuVEVYVCAqLywgOCAvKiBUb2tlblR5cGUuSU5URVJQT0xBVElPTiAqLywgKCkgPT4gdGhpcy5faXNUZXh0RW5kKCksICgpID0+IHRoaXMuX2lzVGFnU3RhcnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMjQgLyogVG9rZW5UeXBlLkVPRiAqLyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgd2hldGhlciBhbiBJQ1UgdG9rZW4gaGFzIGJlZW4gY3JlYXRlZFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF90b2tlbml6ZUV4cGFuc2lvbkZvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRXhwYW5zaW9uRm9ybVN0YXJ0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtU3RhcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0V4cGFuc2lvbkNhc2VTdGFydCh0aGlzLl9jdXJzb3IucGVlaygpKSAmJiB0aGlzLl9pc0luRXhwYW5zaW9uRm9ybSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uQ2FzZVN0YXJ0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJFJCUkFDRSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25DYXNlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uRm9ybUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2JlZ2luVG9rZW4odHlwZSwgc3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5TdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gdHlwZTtcbiAgICB9XG4gICAgX2VuZFRva2VuKHBhcnRzLCBlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVG9rZW5FcnJvcignUHJvZ3JhbW1pbmcgZXJyb3IgLSBhdHRlbXB0ZWQgdG8gZW5kIGEgdG9rZW4gd2hlbiB0aGVyZSB3YXMgbm8gc3RhcnQgdG8gdGhlIHRva2VuJywgdGhpcy5fY3VycmVudFRva2VuVHlwZSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb2tlbkVycm9yKCdQcm9ncmFtbWluZyBlcnJvciAtIGF0dGVtcHRlZCB0byBlbmQgYSB0b2tlbiB3aGljaCBoYXMgbm8gdG9rZW4gdHlwZScsIG51bGwsIHRoaXMuX2N1cnNvci5nZXRTcGFuKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl9jdXJyZW50VG9rZW5UeXBlLFxuICAgICAgICAgICAgcGFydHMsXG4gICAgICAgICAgICBzb3VyY2VTcGFuOiAoZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogdGhpcy5fY3Vyc29yKS5nZXRTcGFuKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0LCB0aGlzLl9sZWFkaW5nVHJpdmlhQ29kZVBvaW50cyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5TdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIF9jcmVhdGVFcnJvcihtc2csIHNwYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgIG1zZyArPSBgIChEbyB5b3UgaGF2ZSBhbiB1bmVzY2FwZWQgXCJ7XCIgaW4geW91ciB0ZW1wbGF0ZT8gVXNlIFwie3sgJ3snIH19XCIpIHRvIGVzY2FwZSBpdC4pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBUb2tlbkVycm9yKG1zZywgdGhpcy5fY3VycmVudFRva2VuVHlwZSwgc3Bhbik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ3Vyc29yRXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSB0aGlzLl9jcmVhdGVFcnJvcihlLm1zZywgdGhpcy5fY3Vyc29yLmdldFNwYW4oZS5jdXJzb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIF9Db250cm9sRmxvd0Vycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXR0ZW1wdENoYXJDb2RlKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSBjaGFyQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjaGFyQ29kZSkge1xuICAgICAgICBpZiAoY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKHRoaXMuX2N1cnNvci5wZWVrKCksIGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX3JlcXVpcmVDaGFyQ29kZShjaGFyQ29kZSkge1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dGVtcHRTdHIoY2hhcnMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLmNoYXJzTGVmdCgpIDwgbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5pdGlhbFBvc2l0aW9uID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJzLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYXR0ZW1wdGluZyB0byBwYXJzZSB0aGUgc3RyaW5nIGZhaWxzLCB3ZSB3YW50IHRvIHJlc2V0IHRoZSBwYXJzZXJcbiAgICAgICAgICAgICAgICAvLyB0byB3aGVyZSBpdCB3YXMgYmVmb3JlIHRoZSBhdHRlbXB0XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gaW5pdGlhbFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2F0dGVtcHRTdHJDYXNlSW5zZW5zaXRpdmUoY2hhcnMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9yZXF1aXJlU3RyKGNoYXJzKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdFN0cihjaGFycykpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4ocHJlZGljYXRlKSB7XG4gICAgICAgIHdoaWxlICghcHJlZGljYXRlKHRoaXMuX2N1cnNvci5wZWVrKCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuKHByZWRpY2F0ZSwgbGVuKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4ocHJlZGljYXRlKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5kaWZmKHN0YXJ0KSA8IGxlbikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9jdXJzb3IucGVlaygpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXR0ZW1wdFVudGlsQ2hhcihjaGFyKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSBjaGFyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZWFkQ2hhcigpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVseSB1cG9uIHJlYWRpbmcgZGlyZWN0bHkgZnJvbSBgX2lucHV0YCBhcyB0aGUgYWN0dWFsIGNoYXIgdmFsdWVcbiAgICAgICAgLy8gbWF5IGhhdmUgYmVlbiBnZW5lcmF0ZWQgZnJvbSBhbiBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLl9jdXJzb3IucGVlaygpKTtcbiAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgfVxuICAgIF9jb25zdW1lRW50aXR5KHRleHRUb2tlblR5cGUpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbig5IC8qIFRva2VuVHlwZS5FTkNPREVEX0VOVElUWSAqLyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEhBU0gpKSB7XG4gICAgICAgICAgICBjb25zdCBpc0hleCA9IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkeCkgfHwgdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRYKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc0RpZ2l0RW50aXR5RW5kKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIGN1cnNvciB0byBpbmNsdWRlIHRoZSBwZWVrZWQgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgcHJvdmlkZWQgdG8gdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gbWVzc2FnZS5cbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBpc0hleCA/IENoYXJhY3RlclJlZmVyZW5jZVR5cGUuSEVYIDogQ2hhcmFjdGVyUmVmZXJlbmNlVHlwZS5ERUM7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VucGFyc2FibGVFbnRpdHlFcnJvck1zZyhlbnRpdHlUeXBlLCB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoc3RhcnQpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJOdW0gPSB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoY29kZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyTnVtLCBpc0hleCA/IDE2IDogMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSwgdGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3Vua25vd25FbnRpdHlFcnJvck1zZyh0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoc3RhcnQpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lU3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOYW1lZEVudGl0eUVuZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSAhPSAkU0VNSUNPTE9OKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gc2VtaWNvbG9uIHdhcyBmb3VuZCBzbyBhYm9ydCB0aGUgZW5jb2RlZCBlbnRpdHkgdG9rZW4gdGhhdCB3YXMgaW4gcHJvZ3Jlc3MsIGFuZCB0cmVhdFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgYXMgYSB0ZXh0IHRva2VuXG4gICAgICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbih0ZXh0VG9rZW5UeXBlLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gbmFtZVN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFsnJiddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMobmFtZVN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBOQU1FRF9FTlRJVElFU1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3Vua25vd25FbnRpdHlFcnJvck1zZyhuYW1lKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NoYXIsIGAmJHtuYW1lfTtgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnN1bWVSYXdUZXh0KGNvbnN1bWVFbnRpdGllcywgZW5kTWFya2VyUHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oY29uc3VtZUVudGl0aWVzID8gNiAvKiBUb2tlblR5cGUuRVNDQVBBQkxFX1JBV19URVhUICovIDogNyAvKiBUb2tlblR5cGUuUkFXX1RFWFQgKi8pO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgdGFnQ2xvc2VTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3QgZm91bmRFbmRNYXJrZXIgPSBlbmRNYXJrZXJQcmVkaWNhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHRhZ0Nsb3NlU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZm91bmRFbmRNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25zdW1lRW50aXRpZXMgJiYgdGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJEFNUEVSU0FORCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0pO1xuICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUVudGl0eSg2IC8qIFRva2VuVHlwZS5FU0NBUEFCTEVfUkFXX1RFWFQgKi8pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oNiAvKiBUb2tlblR5cGUuRVNDQVBBQkxFX1JBV19URVhUICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fcmVhZENoYXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgfVxuICAgIF9jb25zdW1lQ29tbWVudChzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDEwIC8qIFRva2VuVHlwZS5DT01NRU5UX1NUQVJUICovLCBzdGFydCk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTUlOVVMpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0KGZhbHNlLCAoKSA9PiB0aGlzLl9hdHRlbXB0U3RyKCctLT4nKSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMTEgLyogVG9rZW5UeXBlLkNPTU1FTlRfRU5EICovKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZVN0cignLS0+Jyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9XG4gICAgX2NvbnN1bWVDZGF0YShzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDEyIC8qIFRva2VuVHlwZS5DREFUQV9TVEFSVCAqLywgc3RhcnQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCdDREFUQVsnKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgKCkgPT4gdGhpcy5fYXR0ZW1wdFN0cignXV0+JykpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDEzIC8qIFRva2VuVHlwZS5DREFUQV9FTkQgKi8pO1xuICAgICAgICB0aGlzLl9yZXF1aXJlU3RyKCddXT4nKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgIH1cbiAgICBfY29uc3VtZURvY1R5cGUoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxOCAvKiBUb2tlblR5cGUuRE9DX1RZUEUgKi8sIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgY29udGVudFN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRVbnRpbENoYXIoJEdUKTtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyhjb250ZW50U3RhcnQpO1xuICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbY29udGVudF0pO1xuICAgIH1cbiAgICBfY29uc3VtZVByZWZpeEFuZE5hbWUoKSB7XG4gICAgICAgIGNvbnN0IG5hbWVPclByZWZpeFN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIGxldCBwcmVmaXggPSAnJztcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRDT0xPTiAmJiAhaXNQcmVmaXhFbmQodGhpcy5fY3Vyc29yLnBlZWsoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWVTdGFydDtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRDT0xPTikge1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5fY3Vyc29yLmdldENoYXJzKG5hbWVPclByZWZpeFN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICBuYW1lU3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hbWVTdGFydCA9IG5hbWVPclByZWZpeFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZVVudGlsRm4oaXNOYW1lRW5kLCBwcmVmaXggPT09ICcnID8gMCA6IDEpO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fY3Vyc29yLmdldENoYXJzKG5hbWVTdGFydCk7XG4gICAgICAgIHJldHVybiBbcHJlZml4LCBuYW1lXTtcbiAgICB9XG4gICAgX2NvbnN1bWVUYWdPcGVuKHN0YXJ0KSB7XG4gICAgICAgIGxldCB0YWdOYW1lO1xuICAgICAgICBsZXQgcHJlZml4O1xuICAgICAgICBsZXQgb3BlblRhZ1Rva2VuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFpc0FzY2lpTGV0dGVyKHRoaXMuX2N1cnNvci5wZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9jdXJzb3IucGVlaygpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW5UYWdUb2tlbiA9IHRoaXMuX2NvbnN1bWVUYWdPcGVuU3RhcnQoc3RhcnQpO1xuICAgICAgICAgICAgcHJlZml4ID0gb3BlblRhZ1Rva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgdGFnTmFtZSA9IG9wZW5UYWdUb2tlbi5wYXJ0c1sxXTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkU0xBU0ggJiYgdGhpcy5fY3Vyc29yLnBlZWsoKSAhPT0gJEdUICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yLnBlZWsoKSAhPT0gJExUICYmIHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRFT0YpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQXR0cmlidXRlTmFtZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRFUSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW5FbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBfQ29udHJvbEZsb3dFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChvcGVuVGFnVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZXJyb3JlZCBiZWZvcmUgd2UgY291bGQgY2xvc2UgdGhlIG9wZW5pbmcgdGFnLCBzbyBpdCBpcyBpbmNvbXBsZXRlLlxuICAgICAgICAgICAgICAgICAgICBvcGVuVGFnVG9rZW4udHlwZSA9IDQgLyogVG9rZW5UeXBlLklOQ09NUExFVEVfVEFHX09QRU4gKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBzdGFydCB0YWcgaXMgaW52YWxpZCwgYXNzdW1lIHdlIHdhbnQgYSBcIjxcIiBhcyB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrIHRvIGJhY2sgdGV4dCB0b2tlbnMgYXJlIG1lcmdlZCBhdCB0aGUgZW5kLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKDUgLyogVG9rZW5UeXBlLlRFWFQgKi8sIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4oWyc8J10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUb2tlblR5cGUgPSB0aGlzLl9nZXRUYWdEZWZpbml0aW9uKHRhZ05hbWUpLmdldENvbnRlbnRUeXBlKHByZWZpeCk7XG4gICAgICAgIGlmIChjb250ZW50VG9rZW5UeXBlID09PSBleHBvcnRzLlRhZ0NvbnRlbnRUeXBlLlJBV19URVhUKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dFdpdGhUYWdDbG9zZShwcmVmaXgsIHRhZ05hbWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50VG9rZW5UeXBlID09PSBleHBvcnRzLlRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVJhd1RleHRXaXRoVGFnQ2xvc2UocHJlZml4LCB0YWdOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29uc3VtZVJhd1RleHRXaXRoVGFnQ2xvc2UocHJlZml4LCB0YWdOYW1lLCBjb25zdW1lRW50aXRpZXMpIHtcbiAgICAgICAgdGhpcy5fY29uc3VtZVJhd1RleHQoY29uc3VtZUVudGl0aWVzLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlKHRhZ05hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEdUKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMyAvKiBUb2tlblR5cGUuVEFHX0NMT1NFICovKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihjb2RlID0+IGNvZGUgPT09ICRHVCwgMyk7XG4gICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7IC8vIENvbnN1bWUgdGhlIGA+YFxuICAgICAgICB0aGlzLl9lbmRUb2tlbihbcHJlZml4LCB0YWdOYW1lXSk7XG4gICAgfVxuICAgIF9jb25zdW1lVGFnT3BlblN0YXJ0KHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMCAvKiBUb2tlblR5cGUuVEFHX09QRU5fU1RBUlQgKi8sIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgIH1cbiAgICBfY29uc3VtZUF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGF0dHJOYW1lU3RhcnQgPSB0aGlzLl9jdXJzb3IucGVlaygpO1xuICAgICAgICBpZiAoYXR0ck5hbWVTdGFydCA9PT0gJFNRIHx8IGF0dHJOYW1lU3RhcnQgPT09ICREUSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyhhdHRyTmFtZVN0YXJ0KSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxNCAvKiBUb2tlblR5cGUuQVRUUl9OQU1FICovKTtcbiAgICAgICAgY29uc3QgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH1cbiAgICBfY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJFNRIHx8IHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICREUSkge1xuICAgICAgICAgICAgY29uc3QgcXVvdGVDaGFyID0gdGhpcy5fY3Vyc29yLnBlZWsoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVRdW90ZShxdW90ZUNoYXIpO1xuICAgICAgICAgICAgLy8gSW4gYW4gYXR0cmlidXRlIHRoZW4gZW5kIG9mIHRoZSBhdHRyaWJ1dGUgdmFsdWUgYW5kIHRoZSBwcmVtYXR1cmUgZW5kIHRvIGFuIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIC8vIGFyZSBib3RoIHRyaWdnZXJlZCBieSB0aGUgYHF1b3RlQ2hhcmAuXG4gICAgICAgICAgICBjb25zdCBlbmRQcmVkaWNhdGUgPSAoKSA9PiB0aGlzLl9jdXJzb3IucGVlaygpID09PSBxdW90ZUNoYXI7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lV2l0aEludGVycG9sYXRpb24oMTYgLyogVG9rZW5UeXBlLkFUVFJfVkFMVUVfVEVYVCAqLywgMTcgLyogVG9rZW5UeXBlLkFUVFJfVkFMVUVfSU5URVJQT0xBVElPTiAqLywgZW5kUHJlZGljYXRlLCBlbmRQcmVkaWNhdGUpO1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVF1b3RlKHF1b3RlQ2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbmRQcmVkaWNhdGUgPSAoKSA9PiBpc05hbWVFbmQodGhpcy5fY3Vyc29yLnBlZWsoKSk7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lV2l0aEludGVycG9sYXRpb24oMTYgLyogVG9rZW5UeXBlLkFUVFJfVkFMVUVfVEVYVCAqLywgMTcgLyogVG9rZW5UeXBlLkFUVFJfVkFMVUVfSU5URVJQT0xBVElPTiAqLywgZW5kUHJlZGljYXRlLCBlbmRQcmVkaWNhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb25zdW1lUXVvdGUocXVvdGVDaGFyKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMTUgLyogVG9rZW5UeXBlLkFUVFJfUVVPVEUgKi8pO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUocXVvdGVDaGFyKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW1N0cmluZy5mcm9tQ29kZVBvaW50KHF1b3RlQ2hhcildKTtcbiAgICB9XG4gICAgX2NvbnN1bWVUYWdPcGVuRW5kKCkge1xuICAgICAgICBjb25zdCB0b2tlblR5cGUgPSB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJFNMQVNIKSA/IDIgLyogVG9rZW5UeXBlLlRBR19PUEVOX0VORF9WT0lEICovIDogMSAvKiBUb2tlblR5cGUuVEFHX09QRU5fRU5EICovO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKHRva2VuVHlwZSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfVxuICAgIF9jb25zdW1lVGFnQ2xvc2Uoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigzIC8qIFRva2VuVHlwZS5UQUdfQ0xPU0UgKi8sIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICBjb25zdCBwcmVmaXhBbmROYW1lID0gdGhpcy5fY29uc3VtZVByZWZpeEFuZE5hbWUoKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJEdUKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4ocHJlZml4QW5kTmFtZSk7XG4gICAgfVxuICAgIF9jb25zdW1lRXhwYW5zaW9uRm9ybVN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDE5IC8qIFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVCAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucHVzaCgxOSAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQgKi8pO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDcgLyogVG9rZW5UeXBlLlJBV19URVhUICovKTtcbiAgICAgICAgY29uc3QgY29uZGl0aW9uID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRDb25kaXRpb24gPSB0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKGNvbmRpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLl9pMThuTm9ybWFsaXplTGluZUVuZGluZ3NJbklDVXMpIHtcbiAgICAgICAgICAgIC8vIFdlIGV4cGxpY2l0bHkgd2FudCB0byBub3JtYWxpemUgbGluZSBlbmRpbmdzIGZvciB0aGlzIHRleHQuXG4gICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbbm9ybWFsaXplZENvbmRpdGlvbl0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgYXJlIG5vdCBub3JtYWxpemluZyBsaW5lIGVuZGluZ3MuXG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25Ub2tlbiA9IHRoaXMuX2VuZFRva2VuKFtjb25kaXRpb25dKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkQ29uZGl0aW9uICE9PSBjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vbk5vcm1hbGl6ZWRJY3VFeHByZXNzaW9ucy5wdXNoKGNvbmRpdGlvblRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDcgLyogVG9rZW5UeXBlLlJBV19URVhUICovKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuX3JlYWRVbnRpbCgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbdHlwZV0pO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJENPTU1BKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgIH1cbiAgICBfY29uc3VtZUV4cGFuc2lvbkNhc2VTdGFydCgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigyMCAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfVkFMVUUgKi8pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3JlYWRVbnRpbCgkTEJSQUNFKS50cmltKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt2YWx1ZV0pO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMjEgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkTEJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wdXNoKDIxIC8qIFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgKi8pO1xuICAgIH1cbiAgICBfY29uc3VtZUV4cGFuc2lvbkNhc2VFbmQoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMjIgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQgKi8pO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJFJCUkFDRSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIF9jb25zdW1lRXhwYW5zaW9uRm9ybUVuZCgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigyMyAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fRU5EICovKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRSQlJBQ0UpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZSBhIHN0cmluZyB0aGF0IG1heSBjb250YWluIGludGVycG9sYXRpb24gZXhwcmVzc2lvbnMuXG4gICAgICpcbiAgICAgKiBUaGUgZmlyc3QgdG9rZW4gY29uc3VtZWQgd2lsbCBiZSBvZiBgdG9rZW5UeXBlYCBhbmQgdGhlbiB0aGVyZSB3aWxsIGJlIGFsdGVybmF0aW5nXG4gICAgICogYGludGVycG9sYXRpb25Ub2tlblR5cGVgIGFuZCBgdG9rZW5UeXBlYCB0b2tlbnMgdW50aWwgdGhlIGBlbmRQcmVkaWNhdGUoKWAgcmV0dXJucyB0cnVlLlxuICAgICAqXG4gICAgICogSWYgYW4gaW50ZXJwb2xhdGlvbiB0b2tlbiBlbmRzIHByZW1hdHVyZWx5IGl0IHdpbGwgaGF2ZSBubyBlbmQgbWFya2VyIGluIGl0cyBgcGFydHNgIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRleHRUb2tlblR5cGUgdGhlIGtpbmQgb2YgdG9rZW5zIHRvIGludGVybGVhdmUgYXJvdW5kIGludGVycG9sYXRpb24gdG9rZW5zLlxuICAgICAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uVG9rZW5UeXBlIHRoZSBraW5kIG9mIHRva2VucyB0aGF0IGNvbnRhaW4gaW50ZXJwb2xhdGlvbi5cbiAgICAgKiBAcGFyYW0gZW5kUHJlZGljYXRlIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgcmV0dXJuIHRydWUgd2hlbiB3ZSBzaG91bGQgc3RvcCBjb25zdW1pbmcuXG4gICAgICogQHBhcmFtIGVuZEludGVycG9sYXRpb24gYSBmdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhIHByZW1hdHVyZSBlbmQgdG8gYW5cbiAgICAgKiAgICAgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9uIC0gaS5lLiBiZWZvcmUgd2UgZ2V0IHRvIHRoZSBub3JtYWwgaW50ZXJwb2xhdGlvbiBjbG9zaW5nIG1hcmtlci5cbiAgICAgKi9cbiAgICBfY29uc3VtZVdpdGhJbnRlcnBvbGF0aW9uKHRleHRUb2tlblR5cGUsIGludGVycG9sYXRpb25Ub2tlblR5cGUsIGVuZFByZWRpY2F0ZSwgZW5kSW50ZXJwb2xhdGlvbikge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKHRleHRUb2tlblR5cGUpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWVuZFByZWRpY2F0ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyAmJiB0aGlzLl9hdHRlbXB0U3RyKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lSW50ZXJwb2xhdGlvbihpbnRlcnBvbGF0aW9uVG9rZW5UeXBlLCBjdXJyZW50LCBlbmRJbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKHRleHRUb2tlblR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJEFNUEVSU0FORCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0pO1xuICAgICAgICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUVudGl0eSh0ZXh0VG9rZW5UeXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKHRleHRUb2tlblR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9yZWFkQ2hhcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IGFuIGludGVycG9sYXRpb24gd2FzIHN0YXJ0ZWQgYnV0IG5vdCBlbmRlZCBpbnNpZGUgdGhpcyB0ZXh0IHRva2VuLlxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSByZXNldCB0aGUgc3RhdGUgb2YgdGhlIGxleGVyIGNvcnJlY3RseS5cbiAgICAgICAgdGhpcy5faW5JbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdW1lIGEgYmxvY2sgb2YgdGV4dCB0aGF0IGhhcyBiZWVuIGludGVycHJldGVkIGFzIGFuIEFuZ3VsYXIgaW50ZXJwb2xhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uVG9rZW5UeXBlIHRoZSB0eXBlIG9mIHRoZSBpbnRlcnBvbGF0aW9uIHRva2VuIHRvIGdlbmVyYXRlLlxuICAgICAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uU3RhcnQgYSBjdXJzb3IgdGhhdCBwb2ludHMgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgaW50ZXJwb2xhdGlvbi5cbiAgICAgKiBAcGFyYW0gcHJlbWF0dXJlRW5kUHJlZGljYXRlIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgcmV0dXJuIHRydWUgaWYgdGhlIG5leHQgY2hhcmFjdGVycyBpbmRpY2F0ZVxuICAgICAqICAgICBhbiBlbmQgdG8gdGhlIGludGVycG9sYXRpb24gYmVmb3JlIGl0cyBub3JtYWwgY2xvc2luZyBtYXJrZXIuXG4gICAgICovXG4gICAgX2NvbnN1bWVJbnRlcnBvbGF0aW9uKGludGVycG9sYXRpb25Ub2tlblR5cGUsIGludGVycG9sYXRpb25TdGFydCwgcHJlbWF0dXJlRW5kUHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oaW50ZXJwb2xhdGlvblRva2VuVHlwZSwgaW50ZXJwb2xhdGlvblN0YXJ0KTtcbiAgICAgICAgcGFydHMucHVzaCh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLnN0YXJ0KTtcbiAgICAgICAgLy8gRmluZCB0aGUgZW5kIG9mIHRoZSBpbnRlcnBvbGF0aW9uLCBpZ25vcmluZyBjb250ZW50IGluc2lkZSBxdW90ZXMuXG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25TdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICBsZXQgaW5RdW90ZSA9IG51bGw7XG4gICAgICAgIGxldCBpbkNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRFT0YgJiZcbiAgICAgICAgICAgIChwcmVtYXR1cmVFbmRQcmVkaWNhdGUgPT09IG51bGwgfHwgIXByZW1hdHVyZUVuZFByZWRpY2F0ZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGFnU3RhcnQoKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBzdGFydGluZyB3aGF0IGxvb2tzIGxpa2UgYW4gSFRNTCBlbGVtZW50IGluIHRoZSBtaWRkbGUgb2YgdGhpcyBpbnRlcnBvbGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjdXJzb3IgdG8gYmVmb3JlIHRoZSBgPGAgY2hhcmFjdGVyIGFuZCBlbmQgdGhlIGludGVycG9sYXRpb24gdG9rZW4uXG4gICAgICAgICAgICAgICAgLy8gKFRoaXMgaXMgYWN0dWFsbHkgd3JvbmcgYnV0IGhlcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpLlxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9nZXRQcm9jZXNzZWRDaGFycyhleHByZXNzaW9uU3RhcnQsIGN1cnJlbnQpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihwYXJ0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluUXVvdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdFN0cih0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIG5vdCBpbiBhIHN0cmluZywgYW5kIHdlIGhpdCB0aGUgZW5kIGludGVycG9sYXRpb24gbWFya2VyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fZ2V0UHJvY2Vzc2VkQ2hhcnMoZXhwcmVzc2lvblN0YXJ0LCBjdXJyZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5lbmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihwYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYXR0ZW1wdFN0cignLy8nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmNlIHdlIGFyZSBpbiBhIGNvbW1lbnQgd2UgaWdub3JlIGFueSBxdW90ZXNcbiAgICAgICAgICAgICAgICAgICAgaW5Db21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gdGhpcy5fY3Vyc29yLnBlZWsoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgdGhlIG5leHQgY2hhcmFjdGVyIGJlY2F1c2UgaXQgd2FzIGVzY2FwZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGluUXVvdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGl0aW5nIHRoZSBjdXJyZW50IHF1b3RlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICBpblF1b3RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpbkNvbW1lbnQgJiYgaW5RdW90ZSA9PT0gbnVsbCAmJiBpc1F1b3RlKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gRW50ZXJpbmcgYSBuZXcgcXVvdGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgIGluUXVvdGUgPSBjaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhpdCBFT0Ygd2l0aG91dCBmaW5kaW5nIGEgY2xvc2luZyBpbnRlcnBvbGF0aW9uIG1hcmtlclxuICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2dldFByb2Nlc3NlZENoYXJzKGV4cHJlc3Npb25TdGFydCwgdGhpcy5fY3Vyc29yKSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHBhcnRzKTtcbiAgICB9XG4gICAgX2dldFByb2Nlc3NlZENoYXJzKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMoZW5kLmdldENoYXJzKHN0YXJ0KSk7XG4gICAgfVxuICAgIF9pc1RleHRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1RhZ1N0YXJ0KCkgfHwgdGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJEVPRikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Rva2VuaXplSWN1ICYmICF0aGlzLl9pbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRXhwYW5zaW9uRm9ybVN0YXJ0KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBvZiBhbiBleHBhbnNpb24gZm9ybVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRSQlJBQ0UgJiYgdGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBhbmQgZXhwYW5zaW9uIGNhc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBjdXJzb3IgaXMgcG9pbnRpbmcgdG8gdGhlIHN0YXJ0IG9mIGEgdGFnXG4gICAgICogKG9wZW5pbmcvY2xvc2luZy9jb21tZW50cy9jZGF0YS9ldGMpLlxuICAgICAqL1xuICAgIF9pc1RhZ1N0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJExUKSB7XG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBgPGAgZm9sbG93ZWQgYnkgd2hpdGVzcGFjZSBpcyBub3QgdGhlIHN0YXJ0IG9mIGFuIEhUTUwgZWxlbWVudC5cbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgdG1wLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhbHBoYWJldGljLCAhIG5vciAvIHRoZW4gaXQgaXMgYSB0YWcgc3RhcnRcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0bXAucGVlaygpO1xuICAgICAgICAgICAgaWYgKCgkYSA8PSBjb2RlICYmIGNvZGUgPD0gJHopIHx8ICgkQSA8PSBjb2RlICYmIGNvZGUgPD0gJFopIHx8XG4gICAgICAgICAgICAgICAgY29kZSA9PT0gJFNMQVNIIHx8IGNvZGUgPT09ICRCQU5HKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfcmVhZFVudGlsKGNoYXIpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5fYXR0ZW1wdFVudGlsQ2hhcihjaGFyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnNvci5nZXRDaGFycyhzdGFydCk7XG4gICAgfVxuICAgIF9pc0luRXhwYW5zaW9uQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIDIxIC8qIFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgKi87XG4gICAgfVxuICAgIF9pc0luRXhwYW5zaW9uRm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25DYXNlU3RhY2tbdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCAtIDFdID09PVxuICAgICAgICAgICAgICAgIDE5IC8qIFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVCAqLztcbiAgICB9XG4gICAgaXNFeHBhbnNpb25Gb3JtU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkTEJSQUNFKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBpc0ludGVycG9sYXRpb24gPSB0aGlzLl9hdHRlbXB0U3RyKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gIWlzSW50ZXJwb2xhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc05vdFdoaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiAhaXNXaGl0ZXNwYWNlKGNvZGUpIHx8IGNvZGUgPT09ICRFT0Y7XG59XG5mdW5jdGlvbiBpc05hbWVFbmQoY29kZSkge1xuICAgIHJldHVybiBpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEdUIHx8IGNvZGUgPT09ICRMVCB8fFxuICAgICAgICBjb2RlID09PSAkU0xBU0ggfHwgY29kZSA9PT0gJFNRIHx8IGNvZGUgPT09ICREUSB8fCBjb2RlID09PSAkRVEgfHxcbiAgICAgICAgY29kZSA9PT0gJEVPRjtcbn1cbmZ1bmN0aW9uIGlzUHJlZml4RW5kKGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPCAkYSB8fCAkeiA8IGNvZGUpICYmIChjb2RlIDwgJEEgfHwgJFogPCBjb2RlKSAmJlxuICAgICAgICAoY29kZSA8ICQwIHx8IGNvZGUgPiAkOSk7XG59XG5mdW5jdGlvbiBpc0RpZ2l0RW50aXR5RW5kKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gJFNFTUlDT0xPTiB8fCBjb2RlID09PSAkRU9GIHx8ICFpc0FzY2lpSGV4RGlnaXQoY29kZSk7XG59XG5mdW5jdGlvbiBpc05hbWVkRW50aXR5RW5kKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gJFNFTUlDT0xPTiB8fCBjb2RlID09PSAkRU9GIHx8ICFpc0FzY2lpTGV0dGVyKGNvZGUpO1xufVxuZnVuY3Rpb24gaXNFeHBhbnNpb25DYXNlU3RhcnQocGVlaykge1xuICAgIHJldHVybiBwZWVrICE9PSAkUkJSQUNFO1xufVxuZnVuY3Rpb24gY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKGNvZGUxLCBjb2RlMikge1xuICAgIHJldHVybiB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUxKSA9PT0gdG9VcHBlckNhc2VDaGFyQ29kZShjb2RlMik7XG59XG5mdW5jdGlvbiB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAkYSAmJiBjb2RlIDw9ICR6ID8gY29kZSAtICRhICsgJEEgOiBjb2RlO1xufVxuZnVuY3Rpb24gbWVyZ2VUZXh0VG9rZW5zKHNyY1Rva2Vucykge1xuICAgIGNvbnN0IGRzdFRva2VucyA9IFtdO1xuICAgIGxldCBsYXN0RHN0VG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcmNUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBzcmNUb2tlbnNbaV07XG4gICAgICAgIGlmICgobGFzdERzdFRva2VuICYmIGxhc3REc3RUb2tlbi50eXBlID09PSA1IC8qIFRva2VuVHlwZS5URVhUICovICYmIHRva2VuLnR5cGUgPT09IDUgLyogVG9rZW5UeXBlLlRFWFQgKi8pIHx8XG4gICAgICAgICAgICAobGFzdERzdFRva2VuICYmIGxhc3REc3RUb2tlbi50eXBlID09PSAxNiAvKiBUb2tlblR5cGUuQVRUUl9WQUxVRV9URVhUICovICYmXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9PT0gMTYgLyogVG9rZW5UeXBlLkFUVFJfVkFMVUVfVEVYVCAqLykpIHtcbiAgICAgICAgICAgIGxhc3REc3RUb2tlbi5wYXJ0c1swXSArPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgIGxhc3REc3RUb2tlbi5zb3VyY2VTcGFuLmVuZCA9IHRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFzdERzdFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICBkc3RUb2tlbnMucHVzaChsYXN0RHN0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkc3RUb2tlbnM7XG59XG5jbGFzcyBQbGFpbkNoYXJhY3RlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZmlsZU9yQ3Vyc29yLCByYW5nZSkge1xuICAgICAgICBpZiAoZmlsZU9yQ3Vyc29yIGluc3RhbmNlb2YgUGxhaW5DaGFyYWN0ZXJDdXJzb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZSA9IGZpbGVPckN1cnNvci5maWxlO1xuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IGZpbGVPckN1cnNvci5pbnB1dDtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gZmlsZU9yQ3Vyc29yLmVuZDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZmlsZU9yQ3Vyc29yLnN0YXRlO1xuICAgICAgICAgICAgLy8gTm90ZTogYXZvaWQgdXNpbmcgYHsuLi5maWxlT3JDdXJzb3Iuc3RhdGV9YCBoZXJlIGFzIHRoYXQgaGFzIGEgc2V2ZXJlIHBlcmZvcm1hbmNlIHBlbmFsdHkuXG4gICAgICAgICAgICAvLyBJbiBFUzUgYnVuZGxlcyB0aGUgb2JqZWN0IHNwcmVhZCBvcGVyYXRvciBpcyB0cmFuc2xhdGVkIGludG8gdGhlIGBfX2Fzc2lnbmAgaGVscGVyLCB3aGljaFxuICAgICAgICAgICAgLy8gaXMgbm90IG9wdGltaXplZCBieSBWTXMgYXMgZWZmaWNpZW50bHkgYXMgYSByYXcgb2JqZWN0IGxpdGVyYWwuIFNpbmNlIHRoaXMgY29uc3RydWN0b3IgaXNcbiAgICAgICAgICAgIC8vIGNhbGxlZCBpbiB0aWdodCBsb29wcywgdGhpcyBkaWZmZXJlbmNlIG1hdHRlcnMuXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgICAgIHBlZWs6IHN0YXRlLnBlZWssXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBzdGF0ZS5vZmZzZXQsXG4gICAgICAgICAgICAgICAgbGluZTogc3RhdGUubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHN0YXRlLmNvbHVtbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ncmFtbWluZyBlcnJvcjogdGhlIHJhbmdlIGFyZ3VtZW50IG11c3QgYmUgcHJvdmlkZWQgd2l0aCBhIGZpbGUgYXJndW1lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZpbGUgPSBmaWxlT3JDdXJzb3I7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gZmlsZU9yQ3Vyc29yLmNvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHJhbmdlLmVuZFBvcztcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgcGVlazogLTEsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiByYW5nZS5zdGFydFBvcyxcbiAgICAgICAgICAgICAgICBsaW5lOiByYW5nZS5zdGFydExpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiByYW5nZS5zdGFydENvbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGxhaW5DaGFyYWN0ZXJDdXJzb3IodGhpcyk7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBlZWs7XG4gICAgfVxuICAgIGNoYXJzTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kIC0gdGhpcy5zdGF0ZS5vZmZzZXQ7XG4gICAgfVxuICAgIGRpZmYob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUub2Zmc2V0IC0gb3RoZXIuc3RhdGUub2Zmc2V0O1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQZWVrKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBnZXRTcGFuKHN0YXJ0LCBsZWFkaW5nVHJpdmlhQ29kZVBvaW50cykge1xuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IHRoaXM7XG4gICAgICAgIGxldCBmdWxsU3RhcnQgPSBzdGFydDtcbiAgICAgICAgaWYgKGxlYWRpbmdUcml2aWFDb2RlUG9pbnRzKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5kaWZmKHN0YXJ0KSA+IDAgJiYgbGVhZGluZ1RyaXZpYUNvZGVQb2ludHMuaW5kZXhPZihzdGFydC5wZWVrKCkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmdWxsU3RhcnQgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQuYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0TG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uRnJvbUN1cnNvcihzdGFydCk7XG4gICAgICAgIGNvbnN0IGVuZExvY2F0aW9uID0gdGhpcy5sb2NhdGlvbkZyb21DdXJzb3IodGhpcyk7XG4gICAgICAgIGNvbnN0IGZ1bGxTdGFydExvY2F0aW9uID0gZnVsbFN0YXJ0ICE9PSBzdGFydCA/IHRoaXMubG9jYXRpb25Gcm9tQ3Vyc29yKGZ1bGxTdGFydCkgOiBzdGFydExvY2F0aW9uO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydExvY2F0aW9uLCBlbmRMb2NhdGlvbiwgZnVsbFN0YXJ0TG9jYXRpb24pO1xuICAgIH1cbiAgICBnZXRDaGFycyhzdGFydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQuc3RhdGUub2Zmc2V0LCB0aGlzLnN0YXRlLm9mZnNldCk7XG4gICAgfVxuICAgIGNoYXJBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgIH1cbiAgICBhZHZhbmNlU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+PSB0aGlzLmVuZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEN1cnNvckVycm9yKCdVbmV4cGVjdGVkIGNoYXJhY3RlciBcIkVPRlwiJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudENoYXIgPSB0aGlzLmNoYXJBdChzdGF0ZS5vZmZzZXQpO1xuICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICRMRikge1xuICAgICAgICAgICAgc3RhdGUubGluZSsrO1xuICAgICAgICAgICAgc3RhdGUuY29sdW1uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNOZXdMaW5lKGN1cnJlbnRDaGFyKSkge1xuICAgICAgICAgICAgc3RhdGUuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMudXBkYXRlUGVlayhzdGF0ZSk7XG4gICAgfVxuICAgIHVwZGF0ZVBlZWsoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUucGVlayA9IHN0YXRlLm9mZnNldCA+PSB0aGlzLmVuZCA/ICRFT0YgOiB0aGlzLmNoYXJBdChzdGF0ZS5vZmZzZXQpO1xuICAgIH1cbiAgICBsb2NhdGlvbkZyb21DdXJzb3IoY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbihjdXJzb3IuZmlsZSwgY3Vyc29yLnN0YXRlLm9mZnNldCwgY3Vyc29yLnN0YXRlLmxpbmUsIGN1cnNvci5zdGF0ZS5jb2x1bW4pO1xuICAgIH1cbn1cbmNsYXNzIEVzY2FwZWRDaGFyYWN0ZXJDdXJzb3IgZXh0ZW5kcyBQbGFpbkNoYXJhY3RlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZmlsZU9yQ3Vyc29yLCByYW5nZSkge1xuICAgICAgICBpZiAoZmlsZU9yQ3Vyc29yIGluc3RhbmNlb2YgRXNjYXBlZENoYXJhY3RlckN1cnNvcikge1xuICAgICAgICAgICAgc3VwZXIoZmlsZU9yQ3Vyc29yKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIGZpbGVPckN1cnNvci5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyKGZpbGVPckN1cnNvciwgcmFuZ2UpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5pbnRlcm5hbFN0YXRlO1xuICAgICAgICBzdXBlci5hZHZhbmNlKCk7XG4gICAgICAgIHRoaXMucHJvY2Vzc0VzY2FwZVNlcXVlbmNlKCk7XG4gICAgfVxuICAgIGluaXQoKSB7XG4gICAgICAgIHN1cGVyLmluaXQoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzRXNjYXBlU2VxdWVuY2UoKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXNjYXBlZENoYXJhY3RlckN1cnNvcih0aGlzKTtcbiAgICB9XG4gICAgZ2V0Q2hhcnMoc3RhcnQpIHtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgbGV0IGNoYXJzID0gJyc7XG4gICAgICAgIHdoaWxlIChjdXJzb3IuaW50ZXJuYWxTdGF0ZS5vZmZzZXQgPCB0aGlzLmludGVybmFsU3RhdGUub2Zmc2V0KSB7XG4gICAgICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChjdXJzb3IucGVlaygpKTtcbiAgICAgICAgICAgIGN1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHRoZSBlc2NhcGUgc2VxdWVuY2UgdGhhdCBzdGFydHMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIHRleHQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgdG8gZW5zdXJlIHRoYXQgYHBlZWtgIGhhcyB0aGUgdW5lc2NhcGVkIHZhbHVlIG9mIGVzY2FwZSBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgcHJvY2Vzc0VzY2FwZVNlcXVlbmNlKCkge1xuICAgICAgICBjb25zdCBwZWVrID0gKCkgPT4gdGhpcy5pbnRlcm5hbFN0YXRlLnBlZWs7XG4gICAgICAgIGlmIChwZWVrKCkgPT09ICRCQUNLU0xBU0gpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgaGl0IGFuIGVzY2FwZSBzZXF1ZW5jZSBzbyB3ZSBuZWVkIHRoZSBpbnRlcm5hbCBzdGF0ZSB0byBiZWNvbWUgaW5kZXBlbmRlbnRcbiAgICAgICAgICAgIC8vIG9mIHRoZSBleHRlcm5hbCBzdGF0ZS5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgLy8gTW92ZSBwYXN0IHRoZSBiYWNrc2xhc2hcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAvLyBGaXJzdCBjaGVjayBmb3Igc3RhbmRhcmQgY29udHJvbCBjaGFyIHNlcXVlbmNlc1xuICAgICAgICAgICAgaWYgKHBlZWsoKSA9PT0gJG4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkTEY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICRyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJENSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkdikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRWVEFCO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRUQUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICRiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJEJTUEFDRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkRkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgY29uc2lkZXIgbW9yZSBjb21wbGV4IHNlcXVlbmNlc1xuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkdSkge1xuICAgICAgICAgICAgICAgIC8vIFVuaWNvZGUgY29kZS1wb2ludCBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7IC8vIGFkdmFuY2UgcGFzdCB0aGUgYHVgIGNoYXJcbiAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSAkTEJSQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhcmlhYmxlIGxlbmd0aCBVbmljb2RlLCBlLmcuIGBcXHh7MTIzfWBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTsgLy8gYWR2YW5jZSBwYXN0IHRoZSBge2AgY2hhclxuICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIHZhcmlhYmxlIG51bWJlciBvZiBoZXggZGlnaXRzIHVudGlsIHdlIGhpdCBhIGB9YCBjaGFyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2l0U3RhcnQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGVlaygpICE9PSAkUkJSQUNFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gdGhpcy5kZWNvZGVIZXhEaWdpdHMoZGlnaXRTdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVkIGxlbmd0aCBVbmljb2RlLCBlLmcuIGBcXHUxMjM0YFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWdpdFN0YXJ0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSB0aGlzLmRlY29kZUhleERpZ2l0cyhkaWdpdFN0YXJ0LCA0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICR4KSB7XG4gICAgICAgICAgICAgICAgLy8gSGV4IGNoYXIgY29kZSwgZS5nLiBgXFx4MkZgXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTsgLy8gYWR2YW5jZSBwYXN0IHRoZSBgeGAgY2hhclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2l0U3RhcnQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSB0aGlzLmRlY29kZUhleERpZ2l0cyhkaWdpdFN0YXJ0LCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2N0YWxEaWdpdChwZWVrKCkpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2N0YWwgY2hhciBjb2RlLCBlLmcuIGBcXDAxMmAsXG4gICAgICAgICAgICAgICAgbGV0IG9jdGFsID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZpb3VzID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpc09jdGFsRGlnaXQocGVlaygpKSAmJiBsZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBvY3RhbCArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChwZWVrKCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gcGFyc2VJbnQob2N0YWwsIDgpO1xuICAgICAgICAgICAgICAgIC8vIEJhY2t1cCBvbmUgY2hhclxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHByZXZpb3VzLmludGVybmFsU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc05ld0xpbmUodGhpcy5pbnRlcm5hbFN0YXRlLnBlZWspKSB7XG4gICAgICAgICAgICAgICAgLy8gTGluZSBjb250aW51YXRpb24gYFxcYCBmb2xsb3dlZCBieSBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTsgLy8gYWR2YW5jZSBvdmVyIHRoZSBuZXdsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGBpZmAgYmxvY2tzIHdlcmUgZXhlY3V0ZWQgdGhlbiB3ZSBqdXN0IGhhdmUgYW4gZXNjYXBlZCBub3JtYWwgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSB3ZSBqdXN0LCBlZmZlY3RpdmVseSwgc2tpcCB0aGUgYmFja3NsYXNoIGZyb20gdGhlIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSB0aGlzLmludGVybmFsU3RhdGUucGVlaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvZGVIZXhEaWdpdHMoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBoZXggPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LmludGVybmFsU3RhdGUub2Zmc2V0LCBzdGFydC5pbnRlcm5hbFN0YXRlLm9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgIGlmICghaXNOYU4oY2hhckNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydC5zdGF0ZSA9IHN0YXJ0LmludGVybmFsU3RhdGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3Vyc29yRXJyb3IoJ0ludmFsaWQgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlJywgc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ3Vyc29yRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZywgY3Vyc29yKSB7XG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGN1cnNvcjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgVHJlZUVycm9yIGV4dGVuZHMgUGFyc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICBzdXBlcihzcGFuLCBtc2cpO1xuICAgICAgICB0aGlzLmVsZW1lbnROYW1lID0gZWxlbWVudE5hbWU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoZWxlbWVudE5hbWUsIHNwYW4sIG1zZykge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVFcnJvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZVRyZWVSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHJvb3ROb2RlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gcm9vdE5vZGVzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG59XG5jbGFzcyBQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKGdldFRhZ0RlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICB9XG4gICAgcGFyc2Uoc291cmNlLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdG9rZW5pemVSZXN1bHQgPSB0b2tlbml6ZShzb3VyY2UsIHVybCwgdGhpcy5nZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9UcmVlQnVpbGRlcih0b2tlbml6ZVJlc3VsdC50b2tlbnMsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbik7XG4gICAgICAgIHBhcnNlci5idWlsZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZXIucm9vdE5vZGVzLCB0b2tlbml6ZVJlc3VsdC5lcnJvcnMuY29uY2F0KHBhcnNlci5lcnJvcnMpKTtcbiAgICB9XG59XG5jbGFzcyBfVHJlZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHRva2VucywgZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgIT09IDI0IC8qIFRva2VuVHlwZS5FT0YgKi8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDAgLyogVG9rZW5UeXBlLlRBR19PUEVOX1NUQVJUICovIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSA0IC8qIFRva2VuVHlwZS5JTkNPTVBMRVRFX1RBR19PUEVOICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVN0YXJ0VGFnKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDMgLyogVG9rZW5UeXBlLlRBR19DTE9TRSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFbmRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMTIgLyogVG9rZW5UeXBlLkNEQVRBX1NUQVJUICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDZGF0YSh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSAxMCAvKiBUb2tlblR5cGUuQ09NTUVOVF9TVEFSVCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSA1IC8qIFRva2VuVHlwZS5URVhUICovIHx8IHRoaXMuX3BlZWsudHlwZSA9PT0gNyAvKiBUb2tlblR5cGUuUkFXX1RFWFQgKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9wZWVrLnR5cGUgPT09IDYgLyogVG9rZW5UeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSAxOSAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFsbCBvdGhlciB0b2tlbnMuLi5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FkdmFuY2UoKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9wZWVrO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGVyZSBpcyBhbHdheXMgYW4gRU9GIHRva2VuIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGVlayA9IHRoaXMudG9rZW5zW3RoaXMuX2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuICAgIF9hZHZhbmNlSWYodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfY29uc3VtZUNkYXRhKF9zdGFydFRva2VuKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2VJZigxMyAvKiBUb2tlblR5cGUuQ0RBVEFfRU5EICovKTtcbiAgICB9XG4gICAgX2NvbnN1bWVDb21tZW50KHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLl9hZHZhbmNlSWYoNyAvKiBUb2tlblR5cGUuUkFXX1RFWFQgKi8pO1xuICAgICAgICB0aGlzLl9hZHZhbmNlSWYoMTEgLyogVG9rZW5UeXBlLkNPTU1FTlRfRU5EICovKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXh0ICE9IG51bGwgPyB0ZXh0LnBhcnRzWzBdLnRyaW0oKSA6IG51bGw7XG4gICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBDb21tZW50KHZhbHVlLCB0b2tlbi5zb3VyY2VTcGFuKSk7XG4gICAgfVxuICAgIF9jb25zdW1lRXhwYW5zaW9uKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHN3aXRjaFZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICBjb25zdCBjYXNlcyA9IFtdO1xuICAgICAgICAvLyByZWFkID1cbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gMjAgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX1ZBTFVFICovKSB7XG4gICAgICAgICAgICBjb25zdCBleHBDYXNlID0gdGhpcy5fcGFyc2VFeHBhbnNpb25DYXNlKCk7XG4gICAgICAgICAgICBpZiAoIWV4cENhc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlcnJvclxuICAgICAgICAgICAgY2FzZXMucHVzaChleHBDYXNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkIHRoZSBmaW5hbCB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IDIzIC8qIFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9FTkQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4sIGBJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5gKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odG9rZW4uc291cmNlU3Bhbi5zdGFydCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLmVuZCwgdG9rZW4uc291cmNlU3Bhbi5mdWxsU3RhcnQpO1xuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgRXhwYW5zaW9uKHN3aXRjaFZhbHVlLnBhcnRzWzBdLCB0eXBlLnBhcnRzWzBdLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWUuc291cmNlU3BhbikpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfVxuICAgIF9wYXJzZUV4cGFuc2lvbkNhc2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAvLyByZWFkIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gMjEgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCAqLykge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHRoaXMuX3BlZWsuc291cmNlU3BhbiwgYEludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ3snLmApKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgdW50aWwgfVxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgY29uc3QgZXhwID0gdGhpcy5fY29sbGVjdEV4cGFuc2lvbkV4cFRva2VucyhzdGFydCk7XG4gICAgICAgIGlmICghZXhwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgZXhwLnB1c2goeyB0eXBlOiAyNCAvKiBUb2tlblR5cGUuRU9GICovLCBwYXJ0czogW10sIHNvdXJjZVNwYW46IGVuZC5zb3VyY2VTcGFuIH0pO1xuICAgICAgICAvLyBwYXJzZSBldmVyeXRoaW5nIGluIGJldHdlZW4geyBhbmQgfVxuICAgICAgICBjb25zdCBleHBhbnNpb25DYXNlUGFyc2VyID0gbmV3IF9UcmVlQnVpbGRlcihleHAsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbik7XG4gICAgICAgIGV4cGFuc2lvbkNhc2VQYXJzZXIuYnVpbGQoKTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbkNhc2VQYXJzZXIuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuY29uY2F0KGV4cGFuc2lvbkNhc2VQYXJzZXIuZXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHZhbHVlLnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCwgdmFsdWUuc291cmNlU3Bhbi5mdWxsU3RhcnQpO1xuICAgICAgICBjb25zdCBleHBTb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydC5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQuc291cmNlU3Bhbi5lbmQsIHN0YXJ0LnNvdXJjZVNwYW4uZnVsbFN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKHZhbHVlLnBhcnRzWzBdLCBleHBhbnNpb25DYXNlUGFyc2VyLnJvb3ROb2Rlcywgc291cmNlU3BhbiwgdmFsdWUuc291cmNlU3BhbiwgZXhwU291cmNlU3Bhbik7XG4gICAgfVxuICAgIF9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zKHN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IFtdO1xuICAgICAgICBjb25zdCBleHBhbnNpb25Gb3JtU3RhY2sgPSBbMjEgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCAqL107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSAxOSAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQgKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9wZWVrLnR5cGUgPT09IDIxIC8qIFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgKi8pIHtcbiAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucHVzaCh0aGlzLl9wZWVrLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMjIgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCAyMSAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUICovKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBhbnNpb25Gb3JtU3RhY2subGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBgSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuYCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSAyMyAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fRU5EICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RPblN0YWNrKGV4cGFuc2lvbkZvcm1TdGFjaywgMTkgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX1NUQVJUICovKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgYEludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLmApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMjQgLyogVG9rZW5UeXBlLkVPRiAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBgSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuYCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwLnB1c2godGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29uc3VtZVRleHQodG9rZW4pIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW3Rva2VuXTtcbiAgICAgICAgY29uc3Qgc3RhcnRTcGFuID0gdG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgbGV0IHRleHQgPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiB0ZXh0WzBdID09PSAnXFxuJykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50Lm5hbWUpLmlnbm9yZUZpcnN0TGYpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgdG9rZW5zWzBdID0geyB0eXBlOiB0b2tlbi50eXBlLCBzb3VyY2VTcGFuOiB0b2tlbi5zb3VyY2VTcGFuLCBwYXJ0czogW3RleHRdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gOCAvKiBUb2tlblR5cGUuSU5URVJQT0xBVElPTiAqLyB8fCB0aGlzLl9wZWVrLnR5cGUgPT09IDUgLyogVG9rZW5UeXBlLlRFWFQgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gOSAvKiBUb2tlblR5cGUuRU5DT0RFRF9FTlRJVFkgKi8pIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDggLyogVG9rZW5UeXBlLklOVEVSUE9MQVRJT04gKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3ZSBkZWNvZGUgSFRNTCBlbnRpdGllcyB0aGF0IGFwcGVhciBpbiBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbnMuIFRoaXMgaXMgYXJndWFibHkgYSBidWcsIGJ1dCBpdCBjb3VsZCBiZSBhIGNvbnNpZGVyYWJsZSBicmVha2luZyBjaGFuZ2UgdG9cbiAgICAgICAgICAgICAgICAvLyBmaXggaXQuIEl0IHNob3VsZCBiZSBhZGRyZXNzZWQgaW4gYSBsYXJnZXIgcHJvamVjdCB0byByZWZhY3RvciB0aGUgZW50aXJlIHBhcnNlci9sZXhlclxuICAgICAgICAgICAgICAgIC8vIGNoYWluIGFmdGVyIFZpZXcgRW5naW5lIGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgdGV4dCArPSB0b2tlbi5wYXJ0cy5qb2luKCcnKS5yZXBsYWNlKC8mKFteO10rKTsvZywgZGVjb2RlRW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogVG9rZW5UeXBlLkVOQ09ERURfRU5USVRZICovKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gdG9rZW4ucGFydHMuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZW5kU3BhbiA9IHRva2VuLnNvdXJjZVNwYW47XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgVGV4dCh0ZXh0LCBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0U3Bhbi5zdGFydCwgZW5kU3Bhbi5lbmQsIHN0YXJ0U3Bhbi5mdWxsU3RhcnQsIHN0YXJ0U3Bhbi5kZXRhaWxzKSwgdG9rZW5zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Nsb3NlVm9pZEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAoZWwgJiYgdGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb25zdW1lU3RhcnRUYWcoc3RhcnRUYWdUb2tlbikge1xuICAgICAgICBjb25zdCBbcHJlZml4LCBuYW1lXSA9IHN0YXJ0VGFnVG9rZW4ucGFydHM7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IDE0IC8qIFRva2VuVHlwZS5BVFRSX05BTUUgKi8pIHtcbiAgICAgICAgICAgIGF0dHJzLnB1c2godGhpcy5fY29uc3VtZUF0dHIodGhpcy5fYWR2YW5jZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUocHJlZml4LCBuYW1lLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICBsZXQgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gTm90ZTogVGhlcmUgY291bGQgaGF2ZSBiZWVuIGEgdG9rZW5pemVyIGVycm9yXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IGEgdG9rZW4gZm9yIHRoZSBlbmQgdGFnLi4uXG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDIgLyogVG9rZW5UeXBlLlRBR19PUEVOX0VORF9WT0lEICovKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBzZWxmQ2xvc2luZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0YWdEZWYgPSB0aGlzLmdldFRhZ0RlZmluaXRpb24oZnVsbE5hbWUpO1xuICAgICAgICAgICAgaWYgKCEodGFnRGVmLmNhblNlbGZDbG9zZSB8fCBnZXROc1ByZWZpeChmdWxsTmFtZSkgIT09IG51bGwgfHwgdGFnRGVmLmlzVm9pZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIHN0YXJ0VGFnVG9rZW4uc291cmNlU3BhbiwgYE9ubHkgdm9pZCBhbmQgZm9yZWlnbiBlbGVtZW50cyBjYW4gYmUgc2VsZiBjbG9zZWQgXCIke3N0YXJ0VGFnVG9rZW4ucGFydHNbMV19XCJgKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSAxIC8qIFRva2VuVHlwZS5UQUdfT1BFTl9FTkQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fcGVlay5zb3VyY2VTcGFuLmZ1bGxTdGFydDtcbiAgICAgICAgY29uc3Qgc3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQsIHN0YXJ0VGFnVG9rZW4uc291cmNlU3Bhbi5mdWxsU3RhcnQpO1xuICAgICAgICAvLyBDcmVhdGUgYSBzZXBhcmF0ZSBgc3RhcnRTcGFuYCBiZWNhdXNlIGBzcGFuYCB3aWxsIGJlIG1vZGlmaWVkIHdoZW4gdGhlcmUgaXMgYW4gYGVuZGAgc3Bhbi5cbiAgICAgICAgY29uc3Qgc3RhcnRTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCwgc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLmZ1bGxTdGFydCk7XG4gICAgICAgIGNvbnN0IGVsID0gbmV3IEVsZW1lbnQoZnVsbE5hbWUsIGF0dHJzLCBbXSwgc3Bhbiwgc3RhcnRTcGFuLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9wdXNoRWxlbWVudChlbCk7XG4gICAgICAgIGlmIChzZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgLy8gRWxlbWVudHMgdGhhdCBhcmUgc2VsZi1jbG9zZWQgaGF2ZSB0aGVpciBgZW5kU291cmNlU3BhbmAgc2V0IHRvIHRoZSBmdWxsIHNwYW4sIGFzIHRoZVxuICAgICAgICAgICAgLy8gZWxlbWVudCBzdGFydCB0YWcgYWxzbyByZXByZXNlbnRzIHRoZSBlbmQgdGFnLlxuICAgICAgICAgICAgdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSwgc3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhcnRUYWdUb2tlbi50eXBlID09PSA0IC8qIFRva2VuVHlwZS5JTkNPTVBMRVRFX1RBR19PUEVOICovKSB7XG4gICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGtub3cgdGhlIG9wZW5pbmcgdGFnIGlzIG5vdCBjb21wbGV0ZSwgc28gaXQgaXMgdW5saWtlbHkgaXQgaGFzIGEgY29ycmVzcG9uZGluZ1xuICAgICAgICAgICAgLy8gY2xvc2UgdGFnLiBMZXQncyBvcHRpbWlzdGljYWxseSBwYXJzZSBpdCBhcyBhIGZ1bGwgZWxlbWVudCBhbmQgZW1pdCBhbiBlcnJvci5cbiAgICAgICAgICAgIHRoaXMuX3BvcEVsZW1lbnQoZnVsbE5hbWUsIG51bGwpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBzcGFuLCBgT3BlbmluZyB0YWcgXCIke2Z1bGxOYW1lfVwiIG5vdCB0ZXJtaW5hdGVkLmApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcHVzaEVsZW1lbnQoZWwpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RWwgPSB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChwYXJlbnRFbCAmJiB0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50RWwubmFtZSkuaXNDbG9zZWRCeUNoaWxkKGVsLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWRkVG9QYXJlbnQoZWwpO1xuICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2sucHVzaChlbCk7XG4gICAgfVxuICAgIF9jb25zdW1lRW5kVGFnKGVuZFRhZ1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxOYW1lID0gdGhpcy5fZ2V0RWxlbWVudEZ1bGxOYW1lKGVuZFRhZ1Rva2VuLnBhcnRzWzBdLCBlbmRUYWdUb2tlbi5wYXJ0c1sxXSwgdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihmdWxsTmFtZSkuaXNWb2lkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIGVuZFRhZ1Rva2VuLnNvdXJjZVNwYW4sIGBWb2lkIGVsZW1lbnRzIGRvIG5vdCBoYXZlIGVuZCB0YWdzIFwiJHtlbmRUYWdUb2tlbi5wYXJ0c1sxXX1cImApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbikpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGBVbmV4cGVjdGVkIGNsb3NpbmcgdGFnIFwiJHtmdWxsTmFtZX1cIi4gSXQgbWF5IGhhcHBlbiB3aGVuIHRoZSB0YWcgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnkgYW5vdGhlciB0YWcuIEZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNjbG9zaW5nLWVsZW1lbnRzLXRoYXQtaGF2ZS1pbXBsaWVkLWVuZC10YWdzYDtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgZXJyTXNnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBuZWFyZXN0IGVsZW1lbnQgd2l0aCB0aGUgdGFnIG5hbWUgYGZ1bGxOYW1lYCBpbiB0aGUgcGFyc2UgdHJlZS5cbiAgICAgKiBgZW5kU291cmNlU3BhbmAgaXMgdGhlIHNwYW4gb2YgdGhlIGNsb3NpbmcgdGFnLCBvciBudWxsIGlmIHRoZSBlbGVtZW50IGRvZXNcbiAgICAgKiBub3QgaGF2ZSBhIGNsb3NpbmcgdGFnIChmb3IgZXhhbXBsZSwgdGhpcyBoYXBwZW5zIHdoZW4gYW4gaW5jb21wbGV0ZVxuICAgICAqIG9wZW5pbmcgdGFnIGlzIHJlY292ZXJlZCkuXG4gICAgICovXG4gICAgX3BvcEVsZW1lbnQoZnVsbE5hbWUsIGVuZFNvdXJjZVNwYW4pIHtcbiAgICAgICAgbGV0IHVuZXhwZWN0ZWRDbG9zZVRhZ0RldGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHN0YWNrSW5kZXggPSB0aGlzLl9lbGVtZW50U3RhY2subGVuZ3RoIC0gMTsgc3RhY2tJbmRleCA+PSAwOyBzdGFja0luZGV4LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy5fZWxlbWVudFN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT09IGZ1bGxOYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSBwYXJzZSBzcGFuIHdpdGggdGhlIGVsZW1lbnQgdGhhdCBpcyBiZWluZyBjbG9zZWQuIEFueSBlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCBzdGFjayBhdCB0aGlzIHBvaW50IGFyZSBjbG9zZWQgaW1wbGljaXRseSwgc28gdGhleSB3b24ndCBnZXRcbiAgICAgICAgICAgICAgICAvLyBhbiBlbmQgc291cmNlIHNwYW4gKGFzIHRoZXJlIGlzIG5vIGV4cGxpY2l0IGNsb3NpbmcgZWxlbWVudCkuXG4gICAgICAgICAgICAgICAgZWwuZW5kU291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW47XG4gICAgICAgICAgICAgICAgZWwuc291cmNlU3Bhbi5lbmQgPSBlbmRTb3VyY2VTcGFuICE9PSBudWxsID8gZW5kU291cmNlU3Bhbi5lbmQgOiBlbC5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50U3RhY2suc3BsaWNlKHN0YWNrSW5kZXgsIHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSBzdGFja0luZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXVuZXhwZWN0ZWRDbG9zZVRhZ0RldGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFRhZ0RlZmluaXRpb24oZWwubmFtZSkuY2xvc2VkQnlQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgZW5jb3VudGVyZWQgYW4gdW5leHBlY3RlZCBjbG9zZSB0YWcgYnV0IGNvbnRpbnVlIHByb2Nlc3NpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBzdGFjayBzbyB3ZSBjYW4gYXNzaWduIGFuIGBlbmRTb3VyY2VTcGFuYCBpZiB0aGVyZSBpcyBhIGNvcnJlc3BvbmRpbmcgc3RhcnQgdGFnIGZvciB0aGlzXG4gICAgICAgICAgICAgICAgLy8gZW5kIHRhZyBpbiB0aGUgc3RhY2suXG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZENsb3NlVGFnRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2NvbnN1bWVBdHRyKGF0dHJOYW1lKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxOYW1lID0gbWVyZ2VOc0FuZE5hbWUoYXR0ck5hbWUucGFydHNbMF0sIGF0dHJOYW1lLnBhcnRzWzFdKTtcbiAgICAgICAgbGV0IGF0dHJFbmQgPSBhdHRyTmFtZS5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgLy8gQ29uc3VtZSBhbnkgcXVvdGVcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMTUgLyogVG9rZW5UeXBlLkFUVFJfUVVPVEUgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25zdW1lIHRoZSBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgIGNvbnN0IHZhbHVlVG9rZW5zID0gW107XG4gICAgICAgIGxldCB2YWx1ZVN0YXJ0U3BhbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHZhbHVlRW5kID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBOT1RFOiBXZSBuZWVkIHRvIHVzZSBhIG5ldyB2YXJpYWJsZSBgbmV4dFRva2VuVHlwZWAgaGVyZSB0byBoaWRlIHRoZSBhY3R1YWwgdHlwZSBvZlxuICAgICAgICAvLyBgX3BlZWsudHlwZWAgZnJvbSBUUy4gT3RoZXJ3aXNlIFRTIHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIGBfcGVlay50eXBlYCBwcmV2ZW50aW5nIGl0IGZyb21cbiAgICAgICAgLy8gYmVpbmcgYWJsZSB0byBjb25zaWRlciBgQVRUUl9WQUxVRV9JTlRFUlBPTEFUSU9OYCBhcyBhbiBvcHRpb24uIFRoaXMgaXMgYmVjYXVzZSBUUyBpcyBub3RcbiAgICAgICAgLy8gYWJsZSB0byBzZWUgdGhhdCBgX2FkdmFuY2UoKWAgd2lsbCBhY3R1YWxseSBtdXRhdGUgYF9wZWVrYC5cbiAgICAgICAgY29uc3QgbmV4dFRva2VuVHlwZSA9IHRoaXMuX3BlZWsudHlwZTtcbiAgICAgICAgaWYgKG5leHRUb2tlblR5cGUgPT09IDE2IC8qIFRva2VuVHlwZS5BVFRSX1ZBTFVFX1RFWFQgKi8pIHtcbiAgICAgICAgICAgIHZhbHVlU3RhcnRTcGFuID0gdGhpcy5fcGVlay5zb3VyY2VTcGFuO1xuICAgICAgICAgICAgdmFsdWVFbmQgPSB0aGlzLl9wZWVrLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gMTYgLyogVG9rZW5UeXBlLkFUVFJfVkFMVUVfVEVYVCAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gMTcgLyogVG9rZW5UeXBlLkFUVFJfVkFMVUVfSU5URVJQT0xBVElPTiAqLyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gOSAvKiBUb2tlblR5cGUuRU5DT0RFRF9FTlRJVFkgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVRva2VuID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlVG9rZW5zLnB1c2godmFsdWVUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlVG9rZW4udHlwZSA9PT0gMTcgLyogVG9rZW5UeXBlLkFUVFJfVkFMVUVfSU5URVJQT0xBVElPTiAqLykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3ZSBkZWNvZGUgSFRNTCBlbnRpdGllcyB0aGF0IGFwcGVhciBpbiBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb25zLiBUaGlzIGlzIGFyZ3VhYmx5IGEgYnVnLCBidXQgaXQgY291bGQgYmUgYSBjb25zaWRlcmFibGUgYnJlYWtpbmcgY2hhbmdlIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeCBpdC4gSXQgc2hvdWxkIGJlIGFkZHJlc3NlZCBpbiBhIGxhcmdlciBwcm9qZWN0IHRvIHJlZmFjdG9yIHRoZSBlbnRpcmUgcGFyc2VyL2xleGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYWluIGFmdGVyIFZpZXcgRW5naW5lIGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHZhbHVlVG9rZW4ucGFydHMuam9pbignJykucmVwbGFjZSgvJihbXjtdKyk7L2csIGRlY29kZUVudGl0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlVG9rZW4udHlwZSA9PT0gOSAvKiBUb2tlblR5cGUuRU5DT0RFRF9FTlRJVFkgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdmFsdWVUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHZhbHVlVG9rZW4ucGFydHMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlRW5kID0gYXR0ckVuZCA9IHZhbHVlVG9rZW4uc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uc3VtZSBhbnkgcXVvdGVcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMTUgLyogVG9rZW5UeXBlLkFUVFJfUVVPVEUgKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IHF1b3RlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBhdHRyRW5kID0gcXVvdGVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVNwYW4gPSB2YWx1ZVN0YXJ0U3BhbiAmJiB2YWx1ZUVuZCAmJlxuICAgICAgICAgICAgbmV3IFBhcnNlU291cmNlU3Bhbih2YWx1ZVN0YXJ0U3Bhbi5zdGFydCwgdmFsdWVFbmQsIHZhbHVlU3RhcnRTcGFuLmZ1bGxTdGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlKGZ1bGxOYW1lLCB2YWx1ZSwgbmV3IFBhcnNlU291cmNlU3BhbihhdHRyTmFtZS5zb3VyY2VTcGFuLnN0YXJ0LCBhdHRyRW5kLCBhdHRyTmFtZS5zb3VyY2VTcGFuLmZ1bGxTdGFydCksIGF0dHJOYW1lLnNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdmFsdWVUb2tlbnMubGVuZ3RoID4gMCA/IHZhbHVlVG9rZW5zIDogdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBfZ2V0UGFyZW50RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggPiAwID8gdGhpcy5fZWxlbWVudFN0YWNrW3RoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxXSA6IG51bGw7XG4gICAgfVxuICAgIF9hZGRUb1BhcmVudChub2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldEVsZW1lbnRGdWxsTmFtZShwcmVmaXgsIGxvY2FsTmFtZSwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICBpZiAocHJlZml4ID09PSAnJykge1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKGxvY2FsTmFtZSkuaW1wbGljaXROYW1lc3BhY2VQcmVmaXggfHwgJyc7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSAnJyAmJiBwYXJlbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUYWdOYW1lID0gc3BsaXROc05hbWUocGFyZW50RWxlbWVudC5uYW1lKVsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRUYWdEZWZpbml0aW9uID0gdGhpcy5nZXRUYWdEZWZpbml0aW9uKHBhcmVudFRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50VGFnRGVmaW5pdGlvbi5wcmV2ZW50TmFtZXNwYWNlSW5oZXJpdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gZ2V0TnNQcmVmaXgocGFyZW50RWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlTnNBbmROYW1lKHByZWZpeCwgbG9jYWxOYW1lKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsYXN0T25TdGFjayhzdGFjaywgZWxlbWVudCkge1xuICAgIHJldHVybiBzdGFjay5sZW5ndGggPiAwICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBlbGVtZW50O1xufVxuLyoqXG4gKiBEZWNvZGUgdGhlIGBlbnRpdHlgIHN0cmluZywgd2hpY2ggd2UgYmVsaWV2ZSBpcyB0aGUgY29udGVudHMgb2YgYW4gSFRNTCBlbnRpdHkuXG4gKlxuICogSWYgdGhlIHN0cmluZyBpcyBub3QgYWN0dWFsbHkgYSB2YWxpZC9rbm93biBlbnRpdHkgdGhlbiBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWwgYG1hdGNoYCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUVudGl0eShtYXRjaCwgZW50aXR5KSB7XG4gICAgaWYgKE5BTUVEX0VOVElUSUVTW2VudGl0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gTkFNRURfRU5USVRJRVNbZW50aXR5XSB8fCBtYXRjaDtcbiAgICB9XG4gICAgaWYgKC9eI3hbYS1mMC05XSskL2kudGVzdChlbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChlbnRpdHkuc2xpY2UoMiksIDE2KSk7XG4gICAgfVxuICAgIGlmICgvXiNcXGQrJC8udGVzdChlbnRpdHkpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChlbnRpdHkuc2xpY2UoMSksIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBIdG1sUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZ2V0SHRtbFRhZ0RlZmluaXRpb24pO1xuICAgIH1cbiAgICBwYXJzZShzb3VyY2UsIHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2Uoc291cmNlLCB1cmwsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBQUkVTRVJWRV9XU19BVFRSX05BTUUgPSAnbmdQcmVzZXJ2ZVdoaXRlc3BhY2VzJztcbmNvbnN0IFNLSVBfV1NfVFJJTV9UQUdTID0gbmV3IFNldChbJ3ByZScsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICdzY3JpcHQnLCAnc3R5bGUnXSk7XG4vLyBFcXVpdmFsZW50IHRvIFxccyB3aXRoIFxcdTAwYTAgKG5vbi1icmVha2luZyBzcGFjZSkgZXhjbHVkZWQuXG4vLyBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHBcbmNvbnN0IFdTX0NIQVJTID0gJyBcXGZcXG5cXHJcXHRcXHZcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZic7XG5jb25zdCBOT19XU19SRUdFWFAgPSBuZXcgUmVnRXhwKGBbXiR7V1NfQ0hBUlN9XWApO1xuY29uc3QgV1NfUkVQTEFDRV9SRUdFWFAgPSBuZXcgUmVnRXhwKGBbJHtXU19DSEFSU31dezIsfWAsICdnJyk7XG5mdW5jdGlvbiBoYXNQcmVzZXJ2ZVdoaXRlc3BhY2VzQXR0cihhdHRycykge1xuICAgIHJldHVybiBhdHRycy5zb21lKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09IFBSRVNFUlZFX1dTX0FUVFJfTkFNRSk7XG59XG4vKipcbiAqIEFuZ3VsYXIgRGFydCBpbnRyb2R1Y2VkICZuZ3NwOyBhcyBhIHBsYWNlaG9sZGVyIGZvciBub24tcmVtb3ZhYmxlIHNwYWNlLCBzZWU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZGFydC1sYW5nL2FuZ3VsYXIvYmxvYi8wYmI2MTEzODdkMjlkNjViNWFmN2Y5ZDI1MTVhYjU3MWZkM2ZiZWU0L190ZXN0cy90ZXN0L2NvbXBpbGVyL3ByZXNlcnZlX3doaXRlc3BhY2VfdGVzdC5kYXJ0I0wyNS1MMzJcbiAqIEluIEFuZ3VsYXIgRGFydCAmbmdzcDsgaXMgY29udmVydGVkIHRvIHRoZSAweEU1MDAgUFVBIChQcml2YXRlIFVzZSBBcmVhcykgdW5pY29kZSBjaGFyYWN0ZXJcbiAqIGFuZCBsYXRlciBvbiByZXBsYWNlZCBieSBhIHNwYWNlLiBXZSBhcmUgcmUtaW1wbGVtZW50aW5nIHRoZSBzYW1lIGlkZWEgaGVyZS5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZU5nc3AodmFsdWUpIHtcbiAgICAvLyBsZXhlciBpcyByZXBsYWNpbmcgdGhlICZuZ3NwOyBwc2V1ZG8tZW50aXR5IHdpdGggTkdTUF9VTklDT0RFXG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UobmV3IFJlZ0V4cChOR1NQX1VOSUNPREUsICdnJyksICcgJyk7XG59XG4vKipcbiAqIFRoaXMgdmlzaXRvciBjYW4gd2FsayBIVE1MIHBhcnNlIHRyZWUgYW5kIHJlbW92ZSAvIHRyaW0gdGV4dCBub2RlcyB1c2luZyB0aGUgZm9sbG93aW5nIHJ1bGVzOlxuICogLSBjb25zaWRlciBzcGFjZXMsIHRhYnMgYW5kIG5ldyBsaW5lcyBhcyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnM7XG4gKiAtIGRyb3AgdGV4dCBub2RlcyBjb25zaXN0aW5nIG9mIHdoaXRlc3BhY2UgY2hhcmFjdGVycyBvbmx5O1xuICogLSBmb3IgYWxsIG90aGVyIHRleHQgbm9kZXMgcmVwbGFjZSBjb25zZWN1dGl2ZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgd2l0aCBvbmUgc3BhY2U7XG4gKiAtIGNvbnZlcnQgJm5nc3A7IHBzZXVkby1lbnRpdHkgdG8gYSBzaW5nbGUgc3BhY2U7XG4gKlxuICogUmVtb3ZhbCBhbmQgdHJpbW1pbmcgb2Ygd2hpdGVzcGFjZXMgaGF2ZSBwb3NpdGl2ZSBwZXJmb3JtYW5jZSBpbXBhY3QgKGxlc3MgY29kZSB0byBnZW5lcmF0ZVxuICogd2hpbGUgY29tcGlsaW5nIHRlbXBsYXRlcywgZmFzdGVyIHZpZXcgY3JlYXRpb24pLiBBdCB0aGUgc2FtZSB0aW1lIGl0IGNhbiBiZSBcImRlc3RydWN0aXZlXCJcbiAqIGluIHNvbWUgY2FzZXMgKHdoaXRlc3BhY2VzIGNhbiBpbmZsdWVuY2UgbGF5b3V0KS4gQmVjYXVzZSBvZiB0aGUgcG90ZW50aWFsIG9mIGJyZWFraW5nIGxheW91dFxuICogdGhpcyB2aXNpdG9yIGlzIG5vdCBhY3RpdmF0ZWQgYnkgZGVmYXVsdCBpbiBBbmd1bGFyIDUgYW5kIHBlb3BsZSBuZWVkIHRvIGV4cGxpY2l0bHkgb3B0LWluIGZvclxuICogd2hpdGVzcGFjZSByZW1vdmFsLiBUaGUgZGVmYXVsdCBvcHRpb24gZm9yIHdoaXRlc3BhY2UgcmVtb3ZhbCB3aWxsIGJlIHJldmlzaXRlZCBpbiBBbmd1bGFyIDZcbiAqIGFuZCBtaWdodCBiZSBjaGFuZ2VkIHRvIFwib25cIiBieSBkZWZhdWx0LlxuICovXG5jbGFzcyBXaGl0ZXNwYWNlVmlzaXRvciB7XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKFNLSVBfV1NfVFJJTV9UQUdTLmhhcyhlbGVtZW50Lm5hbWUpIHx8IGhhc1ByZXNlcnZlV2hpdGVzcGFjZXNBdHRyKGVsZW1lbnQuYXR0cnMpKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBkZXNjZW50IGludG8gZWxlbWVudHMgd2hlcmUgd2UgbmVlZCB0byBwcmVzZXJ2ZSB3aGl0ZXNwYWNlc1xuICAgICAgICAgICAgLy8gYnV0IHN0aWxsIHZpc2l0IGFsbCBhdHRyaWJ1dGVzIHRvIGVsaW1pbmF0ZSBvbmUgdXNlZCBhcyBhIG1hcmtldCB0byBwcmVzZXJ2ZSBXU1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsZW1lbnQubmFtZSwgdmlzaXRBbGwodGhpcywgZWxlbWVudC5hdHRycyksIGVsZW1lbnQuY2hpbGRyZW4sIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3BhbiwgZWxlbWVudC5pMThuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWxlbWVudC5uYW1lLCBlbGVtZW50LmF0dHJzLCB2aXNpdEFsbFdpdGhTaWJsaW5ncyh0aGlzLCBlbGVtZW50LmNoaWxkcmVuKSwgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuLCBlbGVtZW50LmkxOG4pO1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lICE9PSBQUkVTRVJWRV9XU19BVFRSX05BTUUgPyBhdHRyaWJ1dGUgOiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBpc05vdEJsYW5rID0gdGV4dC52YWx1ZS5tYXRjaChOT19XU19SRUdFWFApO1xuICAgICAgICBjb25zdCBoYXNFeHBhbnNpb25TaWJsaW5nID0gY29udGV4dCAmJlxuICAgICAgICAgICAgKGNvbnRleHQucHJldiBpbnN0YW5jZW9mIEV4cGFuc2lvbiB8fCBjb250ZXh0Lm5leHQgaW5zdGFuY2VvZiBFeHBhbnNpb24pO1xuICAgICAgICBpZiAoaXNOb3RCbGFuayB8fCBoYXNFeHBhbnNpb25TaWJsaW5nKSB7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSB3aGl0ZXNwYWNlIGluIHRoZSB0b2tlbnMgb2YgdGhpcyBUZXh0IG5vZGVcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IHRleHQudG9rZW5zLm1hcCh0b2tlbiA9PiB0b2tlbi50eXBlID09PSA1IC8qIFRva2VuVHlwZS5URVhUICovID8gY3JlYXRlV2hpdGVzcGFjZVByb2Nlc3NlZFRleHRUb2tlbih0b2tlbikgOiB0b2tlbik7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSB3aGl0ZXNwYWNlIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIFRleHQgbm9kZVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9jZXNzV2hpdGVzcGFjZSh0ZXh0LnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dCh2YWx1ZSwgdGV4dC5zb3VyY2VTcGFuLCB0b2tlbnMsIHRleHQuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb21tZW50O1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihleHBhbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuc2lvbjtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGV4cGFuc2lvbkNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuc2lvbkNhc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlV2hpdGVzcGFjZVByb2Nlc3NlZFRleHRUb2tlbih7IHR5cGUsIHBhcnRzLCBzb3VyY2VTcGFuIH0pIHtcbiAgICByZXR1cm4geyB0eXBlLCBwYXJ0czogW3Byb2Nlc3NXaGl0ZXNwYWNlKHBhcnRzWzBdKV0sIHNvdXJjZVNwYW4gfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NXaGl0ZXNwYWNlKHRleHQpIHtcbiAgICByZXR1cm4gcmVwbGFjZU5nc3AodGV4dCkucmVwbGFjZShXU19SRVBMQUNFX1JFR0VYUCwgJyAnKTtcbn1cbmZ1bmN0aW9uIHZpc2l0QWxsV2l0aFNpYmxpbmdzKHZpc2l0b3IsIG5vZGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbm9kZXMuZm9yRWFjaCgoYXN0LCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IHByZXY6IG5vZGVzW2kgLSAxXSwgbmV4dDogbm9kZXNbaSArIDFdIH07XG4gICAgICAgIGNvbnN0IGFzdFJlc3VsdCA9IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBMaXRlcmFsKG9iaiwgcXVvdGVkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbGl0ZXJhbE1hcChPYmplY3Qua2V5cyhvYmopLm1hcChrZXkgPT4gKHtcbiAgICAgICAga2V5LFxuICAgICAgICBxdW90ZWQsXG4gICAgICAgIHZhbHVlOiBvYmpba2V5XSxcbiAgICB9KSkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09IFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgPT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAgICAgICAgRE8gTk9UIEVESVQgVEhJUyBMSVNUIE9GIFNFQ1VSSVRZIFNFTlNJVElWRSBQUk9QRVJUSUVTIFdJVEhPVVQgQSBTRUNVUklUWSBSRVZJRVchXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjaCBvdXQgdG8gbXByb2JzdCBmb3IgZGV0YWlscy5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKiogTWFwIGZyb20gdGFnTmFtZXxwcm9wZXJ0eU5hbWUgdG8gU2VjdXJpdHlDb250ZXh0LiBQcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIGFsbCB0YWdzIHVzZSAnKicuICovXG5sZXQgX1NFQ1VSSVRZX1NDSEVNQTtcbmZ1bmN0aW9uIFNFQ1VSSVRZX1NDSEVNQSgpIHtcbiAgICBpZiAoIV9TRUNVUklUWV9TQ0hFTUEpIHtcbiAgICAgICAgX1NFQ1VSSVRZX1NDSEVNQSA9IHt9O1xuICAgICAgICAvLyBDYXNlIGlzIGluc2lnbmlmaWNhbnQgYmVsb3csIGFsbCBlbGVtZW50IGFuZCBhdHRyaWJ1dGUgbmFtZXMgYXJlIGxvd2VyLWNhc2VkIGZvciBsb29rdXAuXG4gICAgICAgIHJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuSFRNTCwgW1xuICAgICAgICAgICAgJ2lmcmFtZXxzcmNkb2MnLFxuICAgICAgICAgICAgJyp8aW5uZXJIVE1MJyxcbiAgICAgICAgICAgICcqfG91dGVySFRNTCcsXG4gICAgICAgIF0pO1xuICAgICAgICByZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlNUWUxFLCBbJyp8c3R5bGUnXSk7XG4gICAgICAgIC8vIE5COiBubyBTQ1JJUFQgY29udGV4dHMgaGVyZSwgdGhleSBhcmUgbmV2ZXIgYWxsb3dlZCBkdWUgdG8gdGhlIHBhcnNlciBzdHJpcHBpbmcgdGhlbS5cbiAgICAgICAgcmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5VUkwsIFtcbiAgICAgICAgICAgICcqfGZvcm1BY3Rpb24nLCAnYXJlYXxocmVmJywgJ2FyZWF8cGluZycsICdhdWRpb3xzcmMnLCAnYXxocmVmJyxcbiAgICAgICAgICAgICdhfHBpbmcnLCAnYmxvY2txdW90ZXxjaXRlJywgJ2JvZHl8YmFja2dyb3VuZCcsICdkZWx8Y2l0ZScsICdmb3JtfGFjdGlvbicsXG4gICAgICAgICAgICAnaW1nfHNyYycsICdpbWd8c3Jjc2V0JywgJ2lucHV0fHNyYycsICdpbnN8Y2l0ZScsICdxfGNpdGUnLFxuICAgICAgICAgICAgJ3NvdXJjZXxzcmMnLCAnc291cmNlfHNyY3NldCcsICd0cmFja3xzcmMnLCAndmlkZW98cG9zdGVyJywgJ3ZpZGVvfHNyYycsXG4gICAgICAgIF0pO1xuICAgICAgICByZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCwgW1xuICAgICAgICAgICAgJ2FwcGxldHxjb2RlJyxcbiAgICAgICAgICAgICdhcHBsZXR8Y29kZWJhc2UnLFxuICAgICAgICAgICAgJ2Jhc2V8aHJlZicsXG4gICAgICAgICAgICAnZW1iZWR8c3JjJyxcbiAgICAgICAgICAgICdmcmFtZXxzcmMnLFxuICAgICAgICAgICAgJ2hlYWR8cHJvZmlsZScsXG4gICAgICAgICAgICAnaHRtbHxtYW5pZmVzdCcsXG4gICAgICAgICAgICAnaWZyYW1lfHNyYycsXG4gICAgICAgICAgICAnbGlua3xocmVmJyxcbiAgICAgICAgICAgICdtZWRpYXxzcmMnLFxuICAgICAgICAgICAgJ29iamVjdHxjb2RlYmFzZScsXG4gICAgICAgICAgICAnb2JqZWN0fGRhdGEnLFxuICAgICAgICAgICAgJ3NjcmlwdHxzcmMnLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIF9TRUNVUklUWV9TQ0hFTUE7XG59XG5mdW5jdGlvbiByZWdpc3RlckNvbnRleHQoY3R4LCBzcGVjcykge1xuICAgIGZvciAoY29uc3Qgc3BlYyBvZiBzcGVjcylcbiAgICAgICAgX1NFQ1VSSVRZX1NDSEVNQVtzcGVjLnRvTG93ZXJDYXNlKCldID0gY3R4O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSB7XG59XG5jb25zdCBCT09MRUFOID0gJ2Jvb2xlYW4nO1xuY29uc3QgTlVNQkVSID0gJ251bWJlcic7XG5jb25zdCBTVFJJTkcgPSAnc3RyaW5nJztcbmNvbnN0IE9CSkVDVCA9ICdvYmplY3QnO1xuLyoqXG4gKiBUaGlzIGFycmF5IHJlcHJlc2VudHMgdGhlIERPTSBzY2hlbWEuIEl0IGVuY29kZXMgaW5oZXJpdGFuY2UsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gKlxuICogIyMgT3ZlcnZpZXdcbiAqXG4gKiBFYWNoIGxpbmUgcmVwcmVzZW50cyBvbmUga2luZCBvZiBlbGVtZW50LiBUaGUgYGVsZW1lbnRfaW5oZXJpdGFuY2VgIGFuZCBwcm9wZXJ0aWVzIGFyZSBqb2luZWRcbiAqIHVzaW5nIGBlbGVtZW50X2luaGVyaXRhbmNlfHByb3BlcnRpZXNgIHN5bnRheC5cbiAqXG4gKiAjIyBFbGVtZW50IEluaGVyaXRhbmNlXG4gKlxuICogVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBjYW4gYmUgZnVydGhlciBzdWJkaXZpZGVkIGFzIGBlbGVtZW50MSxlbGVtZW50MiwuLi5ecGFyZW50RWxlbWVudGAuXG4gKiBIZXJlIHRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFdmVyeSBlbGVtZW50IGluIHRoZSBsaXN0XG4gKiBoYXMgaWRlbnRpY2FsIHByb3BlcnRpZXMuXG4gKlxuICogQW4gYGVsZW1lbnRgIG1heSBpbmhlcml0IGFkZGl0aW9uYWwgcHJvcGVydGllcyBmcm9tIGBwYXJlbnRFbGVtZW50YCBJZiBubyBgXnBhcmVudEVsZW1lbnRgIGlzXG4gKiBzcGVjaWZpZWQgdGhlbiBgXCJcImAgKGJsYW5rKSBlbGVtZW50IGlzIGFzc3VtZWQuXG4gKlxuICogTk9URTogVGhlIGJsYW5rIGVsZW1lbnQgaW5oZXJpdHMgZnJvbSByb290IGBbRWxlbWVudF1gIGVsZW1lbnQsIHRoZSBzdXBlciBlbGVtZW50IG9mIGFsbFxuICogZWxlbWVudHMuXG4gKlxuICogTk9URSBhbiBlbGVtZW50IHByZWZpeCBzdWNoIGFzIGA6c3ZnOmAgaGFzIG5vIHNwZWNpYWwgbWVhbmluZyB0byB0aGUgc2NoZW1hLlxuICpcbiAqICMjIFByb3BlcnRpZXNcbiAqXG4gKiBFYWNoIGVsZW1lbnQgaGFzIGEgc2V0IG9mIHByb3BlcnRpZXMgc2VwYXJhdGVkIGJ5IGAsYCAoY29tbWFzKS4gRWFjaCBwcm9wZXJ0eSBjYW4gYmUgcHJlZml4ZWRcbiAqIGJ5IGEgc3BlY2lhbCBjaGFyYWN0ZXIgZGVzaWduYXRpbmcgaXRzIHR5cGU6XG4gKlxuICogLSAobm8gcHJlZml4KTogcHJvcGVydHkgaXMgYSBzdHJpbmcuXG4gKiAtIGAqYDogcHJvcGVydHkgcmVwcmVzZW50cyBhbiBldmVudC5cbiAqIC0gYCFgOiBwcm9wZXJ0eSBpcyBhIGJvb2xlYW4uXG4gKiAtIGAjYDogcHJvcGVydHkgaXMgYSBudW1iZXIuXG4gKiAtIGAlYDogcHJvcGVydHkgaXMgYW4gb2JqZWN0LlxuICpcbiAqICMjIFF1ZXJ5XG4gKlxuICogVGhlIGNsYXNzIGNyZWF0ZXMgYW4gaW50ZXJuYWwgc3F1YXMgcmVwcmVzZW50YXRpb24gd2hpY2ggYWxsb3dzIHRvIGVhc2lseSBhbnN3ZXIgdGhlIHF1ZXJ5IG9mXG4gKiBpZiBhIGdpdmVuIHByb3BlcnR5IGV4aXN0IG9uIGEgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCB5ZXQgc3VwcG9ydCBxdWVyeWluZyBmb3IgdHlwZXMgb3IgZXZlbnRzLlxuICogTk9URTogVGhpcyBzY2hlbWEgaXMgYXV0byBleHRyYWN0ZWQgZnJvbSBgc2NoZW1hX2V4dHJhY3Rvci50c2AgbG9jYXRlZCBpbiB0aGUgdGVzdCBmb2xkZXIsXG4gKiAgICAgICBzZWUgZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5X3NwZWMudHNcbiAqL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICBETyBOT1QgRURJVCBUSElTIERPTSBTQ0hFTUEgV0lUSE9VVCBBIFNFQ1VSSVRZIFJFVklFVyFcbi8vXG4vLyBOZXdseSBhZGRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgc2VjdXJpdHkgcmV2aWV3ZWQgYW5kIGFzc2lnbmVkIGFuIGFwcHJvcHJpYXRlIFNlY3VyaXR5Q29udGV4dCBpblxuLy8gZG9tX3NlY3VyaXR5X3NjaGVtYS50cy4gUmVhY2ggb3V0IHRvIG1wcm9ic3QgJiByamFtZXQgZm9yIGRldGFpbHMuXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgU0NIRU1BID0gW1xuICAgICdbRWxlbWVudF18dGV4dENvbnRlbnQsJWNsYXNzTGlzdCxjbGFzc05hbWUsaWQsaW5uZXJIVE1MLCpiZWZvcmVjb3B5LCpiZWZvcmVjdXQsKmJlZm9yZXBhc3RlLCpjb3B5LCpjdXQsKnBhc3RlLCpzZWFyY2gsKnNlbGVjdHN0YXJ0LCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3IsKndoZWVsLG91dGVySFRNTCwjc2Nyb2xsTGVmdCwjc2Nyb2xsVG9wLHNsb3QnICtcbiAgICAgICAgLyogYWRkZWQgbWFudWFsbHkgdG8gYXZvaWQgYnJlYWtpbmcgY2hhbmdlcyAqL1xuICAgICAgICAnLCptZXNzYWdlLCptb3pmdWxsc2NyZWVuY2hhbmdlLCptb3pmdWxsc2NyZWVuZXJyb3IsKm1venBvaW50ZXJsb2NrY2hhbmdlLCptb3pwb2ludGVybG9ja2Vycm9yLCp3ZWJnbGNvbnRleHRjcmVhdGlvbmVycm9yLCp3ZWJnbGNvbnRleHRsb3N0LCp3ZWJnbGNvbnRleHRyZXN0b3JlZCcsXG4gICAgJ1tIVE1MRWxlbWVudF1eW0VsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmF1eGNsaWNrLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwb2ludGVyY2FuY2VsLCpwb2ludGVyZG93biwqcG9pbnRlcmVudGVyLCpwb2ludGVybGVhdmUsKnBvaW50ZXJtb3ZlLCpwb2ludGVyb3V0LCpwb2ludGVyb3ZlciwqcG9pbnRlcnVwLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZyxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnYWJicixhZGRyZXNzLGFydGljbGUsYXNpZGUsYixiZGksYmRvLGNpdGUsY29kZSxkZCxkZm4sZHQsZW0sZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixpLGtiZCxtYWluLG1hcmssbmF2LG5vc2NyaXB0LHJiLHJwLHJ0LHJ0YyxydWJ5LHMsc2FtcCxzZWN0aW9uLHNtYWxsLHN0cm9uZyxzdWIsc3VwLHUsdmFyLHdicl5bSFRNTEVsZW1lbnRdfGFjY2Vzc0tleSxjb250ZW50RWRpdGFibGUsZGlyLCFkcmFnZ2FibGUsIWhpZGRlbixpbm5lclRleHQsbGFuZywqYWJvcnQsKmF1eGNsaWNrLCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmN1ZWNoYW5nZSwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhdXNlLCpwbGF5LCpwbGF5aW5nLCpwb2ludGVyY2FuY2VsLCpwb2ludGVyZG93biwqcG9pbnRlcmVudGVyLCpwb2ludGVybGVhdmUsKnBvaW50ZXJtb3ZlLCpwb2ludGVyb3V0LCpwb2ludGVyb3ZlciwqcG9pbnRlcnVwLCpwcm9ncmVzcywqcmF0ZWNoYW5nZSwqcmVzZXQsKnJlc2l6ZSwqc2Nyb2xsLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2hvdywqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnZvbHVtZWNoYW5nZSwqd2FpdGluZyxvdXRlclRleHQsIXNwZWxsY2hlY2ssJXN0eWxlLCN0YWJJbmRleCx0aXRsZSwhdHJhbnNsYXRlJyxcbiAgICAnbWVkaWFeW0hUTUxFbGVtZW50XXwhYXV0b3BsYXksIWNvbnRyb2xzLCVjb250cm9sc0xpc3QsJWNyb3NzT3JpZ2luLCNjdXJyZW50VGltZSwhZGVmYXVsdE11dGVkLCNkZWZhdWx0UGxheWJhY2tSYXRlLCFkaXNhYmxlUmVtb3RlUGxheWJhY2ssIWxvb3AsIW11dGVkLCplbmNyeXB0ZWQsKndhaXRpbmdmb3JrZXksI3BsYXliYWNrUmF0ZSxwcmVsb2FkLHNyYywlc3JjT2JqZWN0LCN2b2x1bWUnLFxuICAgICc6c3ZnOl5bSFRNTEVsZW1lbnRdfCphYm9ydCwqYXV4Y2xpY2ssKmJsdXIsKmNhbmNlbCwqY2FucGxheSwqY2FucGxheXRocm91Z2gsKmNoYW5nZSwqY2xpY2ssKmNsb3NlLCpjb250ZXh0bWVudSwqY3VlY2hhbmdlLCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCpnb3Rwb2ludGVyY2FwdHVyZSwqaW5wdXQsKmludmFsaWQsKmtleWRvd24sKmtleXByZXNzLCprZXl1cCwqbG9hZCwqbG9hZGVkZGF0YSwqbG9hZGVkbWV0YWRhdGEsKmxvYWRzdGFydCwqbG9zdHBvaW50ZXJjYXB0dXJlLCptb3VzZWRvd24sKm1vdXNlZW50ZXIsKm1vdXNlbGVhdmUsKm1vdXNlbW92ZSwqbW91c2VvdXQsKm1vdXNlb3ZlciwqbW91c2V1cCwqbW91c2V3aGVlbCwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnBvaW50ZXJjYW5jZWwsKnBvaW50ZXJkb3duLCpwb2ludGVyZW50ZXIsKnBvaW50ZXJsZWF2ZSwqcG9pbnRlcm1vdmUsKnBvaW50ZXJvdXQsKnBvaW50ZXJvdmVyLCpwb2ludGVydXAsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzaG93LCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCVzdHlsZSwjdGFiSW5kZXgnLFxuICAgICc6c3ZnOmdyYXBoaWNzXjpzdmc6fCcsXG4gICAgJzpzdmc6YW5pbWF0aW9uXjpzdmc6fCpiZWdpbiwqZW5kLCpyZXBlYXQnLFxuICAgICc6c3ZnOmdlb21ldHJ5Xjpzdmc6fCcsXG4gICAgJzpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbl46c3ZnOnwnLFxuICAgICc6c3ZnOmdyYWRpZW50Xjpzdmc6fCcsXG4gICAgJzpzdmc6dGV4dENvbnRlbnReOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOnRleHRQb3NpdGlvbmluZ146c3ZnOnRleHRDb250ZW50fCcsXG4gICAgJ2FeW0hUTUxFbGVtZW50XXxjaGFyc2V0LGNvb3Jkcyxkb3dubG9hZCxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZixocmVmbGFuZyxuYW1lLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxyZWwscmV2LHNlYXJjaCxzaGFwZSx0YXJnZXQsdGV4dCx0eXBlLHVzZXJuYW1lJyxcbiAgICAnYXJlYV5bSFRNTEVsZW1lbnRdfGFsdCxjb29yZHMsZG93bmxvYWQsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsIW5vSHJlZixwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3kscmVsLHNlYXJjaCxzaGFwZSx0YXJnZXQsdXNlcm5hbWUnLFxuICAgICdhdWRpb15tZWRpYXwnLFxuICAgICdicl5bSFRNTEVsZW1lbnRdfGNsZWFyJyxcbiAgICAnYmFzZV5bSFRNTEVsZW1lbnRdfGhyZWYsdGFyZ2V0JyxcbiAgICAnYm9keV5bSFRNTEVsZW1lbnRdfGFMaW5rLGJhY2tncm91bmQsYmdDb2xvcixsaW5rLCpiZWZvcmV1bmxvYWQsKmJsdXIsKmVycm9yLCpmb2N1cywqaGFzaGNoYW5nZSwqbGFuZ3VhZ2VjaGFuZ2UsKmxvYWQsKm1lc3NhZ2UsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHRleHQsdkxpbmsnLFxuICAgICdidXR0b25eW0hUTUxFbGVtZW50XXwhYXV0b2ZvY3VzLCFkaXNhYmxlZCxmb3JtQWN0aW9uLGZvcm1FbmN0eXBlLGZvcm1NZXRob2QsIWZvcm1Ob1ZhbGlkYXRlLGZvcm1UYXJnZXQsbmFtZSx0eXBlLHZhbHVlJyxcbiAgICAnY2FudmFzXltIVE1MRWxlbWVudF18I2hlaWdodCwjd2lkdGgnLFxuICAgICdjb250ZW50XltIVE1MRWxlbWVudF18c2VsZWN0JyxcbiAgICAnZGxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2RhdGFsaXN0XltIVE1MRWxlbWVudF18JyxcbiAgICAnZGV0YWlsc15bSFRNTEVsZW1lbnRdfCFvcGVuJyxcbiAgICAnZGlhbG9nXltIVE1MRWxlbWVudF18IW9wZW4scmV0dXJuVmFsdWUnLFxuICAgICdkaXJeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ2Rpdl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnZW1iZWReW0hUTUxFbGVtZW50XXxhbGlnbixoZWlnaHQsbmFtZSxzcmMsdHlwZSx3aWR0aCcsXG4gICAgJ2ZpZWxkc2V0XltIVE1MRWxlbWVudF18IWRpc2FibGVkLG5hbWUnLFxuICAgICdmb250XltIVE1MRWxlbWVudF18Y29sb3IsZmFjZSxzaXplJyxcbiAgICAnZm9ybV5bSFRNTEVsZW1lbnRdfGFjY2VwdENoYXJzZXQsYWN0aW9uLGF1dG9jb21wbGV0ZSxlbmNvZGluZyxlbmN0eXBlLG1ldGhvZCxuYW1lLCFub1ZhbGlkYXRlLHRhcmdldCcsXG4gICAgJ2ZyYW1lXltIVE1MRWxlbWVudF18ZnJhbWVCb3JkZXIsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUsIW5vUmVzaXplLHNjcm9sbGluZyxzcmMnLFxuICAgICdmcmFtZXNldF5bSFRNTEVsZW1lbnRdfGNvbHMsKmJlZm9yZXVubG9hZCwqYmx1ciwqZXJyb3IsKmZvY3VzLCpoYXNoY2hhbmdlLCpsYW5ndWFnZWNoYW5nZSwqbG9hZCwqbWVzc2FnZSwqb2ZmbGluZSwqb25saW5lLCpwYWdlaGlkZSwqcGFnZXNob3csKnBvcHN0YXRlLCpyZWplY3Rpb25oYW5kbGVkLCpyZXNpemUsKnNjcm9sbCwqc3RvcmFnZSwqdW5oYW5kbGVkcmVqZWN0aW9uLCp1bmxvYWQscm93cycsXG4gICAgJ2hyXltIVE1MRWxlbWVudF18YWxpZ24sY29sb3IsIW5vU2hhZGUsc2l6ZSx3aWR0aCcsXG4gICAgJ2hlYWReW0hUTUxFbGVtZW50XXwnLFxuICAgICdoMSxoMixoMyxoNCxoNSxoNl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAnaHRtbF5bSFRNTEVsZW1lbnRdfHZlcnNpb24nLFxuICAgICdpZnJhbWVeW0hUTUxFbGVtZW50XXxhbGlnbiwhYWxsb3dGdWxsc2NyZWVuLGZyYW1lQm9yZGVyLGhlaWdodCxsb25nRGVzYyxtYXJnaW5IZWlnaHQsbWFyZ2luV2lkdGgsbmFtZSxyZWZlcnJlclBvbGljeSwlc2FuZGJveCxzY3JvbGxpbmcsc3JjLHNyY2RvYyx3aWR0aCcsXG4gICAgJ2ltZ15bSFRNTEVsZW1lbnRdfGFsaWduLGFsdCxib3JkZXIsJWNyb3NzT3JpZ2luLCNoZWlnaHQsI2hzcGFjZSwhaXNNYXAsbG9uZ0Rlc2MsbG93c3JjLG5hbWUscmVmZXJyZXJQb2xpY3ksc2l6ZXMsc3JjLHNyY3NldCx1c2VNYXAsI3ZzcGFjZSwjd2lkdGgnLFxuICAgICdpbnB1dF5bSFRNTEVsZW1lbnRdfGFjY2VwdCxhbGlnbixhbHQsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLCFhdXRvZm9jdXMsIWNoZWNrZWQsIWRlZmF1bHRDaGVja2VkLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwlZmlsZXMsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LCNoZWlnaHQsIWluY3JlbWVudGFsLCFpbmRldGVybWluYXRlLG1heCwjbWF4TGVuZ3RoLG1pbiwjbWluTGVuZ3RoLCFtdWx0aXBsZSxuYW1lLHBhdHRlcm4scGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsI3NpemUsc3JjLHN0ZXAsdHlwZSx1c2VNYXAsdmFsdWUsJXZhbHVlQXNEYXRlLCN2YWx1ZUFzTnVtYmVyLCN3aWR0aCcsXG4gICAgJ2xpXltIVE1MRWxlbWVudF18dHlwZSwjdmFsdWUnLFxuICAgICdsYWJlbF5bSFRNTEVsZW1lbnRdfGh0bWxGb3InLFxuICAgICdsZWdlbmReW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ2xpbmteW0hUTUxFbGVtZW50XXxhcyxjaGFyc2V0LCVjcm9zc09yaWdpbiwhZGlzYWJsZWQsaHJlZixocmVmbGFuZyxpbnRlZ3JpdHksbWVkaWEscmVmZXJyZXJQb2xpY3kscmVsLCVyZWxMaXN0LHJldiwlc2l6ZXMsdGFyZ2V0LHR5cGUnLFxuICAgICdtYXBeW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAnbWFycXVlZV5bSFRNTEVsZW1lbnRdfGJlaGF2aW9yLGJnQ29sb3IsZGlyZWN0aW9uLGhlaWdodCwjaHNwYWNlLCNsb29wLCNzY3JvbGxBbW91bnQsI3Njcm9sbERlbGF5LCF0cnVlU3BlZWQsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ21lbnVeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ21ldGFeW0hUTUxFbGVtZW50XXxjb250ZW50LGh0dHBFcXVpdixuYW1lLHNjaGVtZScsXG4gICAgJ21ldGVyXltIVE1MRWxlbWVudF18I2hpZ2gsI2xvdywjbWF4LCNtaW4sI29wdGltdW0sI3ZhbHVlJyxcbiAgICAnaW5zLGRlbF5bSFRNTEVsZW1lbnRdfGNpdGUsZGF0ZVRpbWUnLFxuICAgICdvbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LCFyZXZlcnNlZCwjc3RhcnQsdHlwZScsXG4gICAgJ29iamVjdF5bSFRNTEVsZW1lbnRdfGFsaWduLGFyY2hpdmUsYm9yZGVyLGNvZGUsY29kZUJhc2UsY29kZVR5cGUsZGF0YSwhZGVjbGFyZSxoZWlnaHQsI2hzcGFjZSxuYW1lLHN0YW5kYnksdHlwZSx1c2VNYXAsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ29wdGdyb3VwXltIVE1MRWxlbWVudF18IWRpc2FibGVkLGxhYmVsJyxcbiAgICAnb3B0aW9uXltIVE1MRWxlbWVudF18IWRlZmF1bHRTZWxlY3RlZCwhZGlzYWJsZWQsbGFiZWwsIXNlbGVjdGVkLHRleHQsdmFsdWUnLFxuICAgICdvdXRwdXReW0hUTUxFbGVtZW50XXxkZWZhdWx0VmFsdWUsJWh0bWxGb3IsbmFtZSx2YWx1ZScsXG4gICAgJ3BeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ3BhcmFtXltIVE1MRWxlbWVudF18bmFtZSx0eXBlLHZhbHVlLHZhbHVlVHlwZScsXG4gICAgJ3BpY3R1cmVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdwcmVeW0hUTUxFbGVtZW50XXwjd2lkdGgnLFxuICAgICdwcm9ncmVzc15bSFRNTEVsZW1lbnRdfCNtYXgsI3ZhbHVlJyxcbiAgICAncSxibG9ja3F1b3RlLGNpdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdzY3JpcHReW0hUTUxFbGVtZW50XXwhYXN5bmMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRlZmVyLGV2ZW50LGh0bWxGb3IsaW50ZWdyaXR5LHNyYyx0ZXh0LHR5cGUnLFxuICAgICdzZWxlY3ReW0hUTUxFbGVtZW50XXxhdXRvY29tcGxldGUsIWF1dG9mb2N1cywhZGlzYWJsZWQsI2xlbmd0aCwhbXVsdGlwbGUsbmFtZSwhcmVxdWlyZWQsI3NlbGVjdGVkSW5kZXgsI3NpemUsdmFsdWUnLFxuICAgICdzaGFkb3deW0hUTUxFbGVtZW50XXwnLFxuICAgICdzbG90XltIVE1MRWxlbWVudF18bmFtZScsXG4gICAgJ3NvdXJjZV5bSFRNTEVsZW1lbnRdfG1lZGlhLHNpemVzLHNyYyxzcmNzZXQsdHlwZScsXG4gICAgJ3NwYW5eW0hUTUxFbGVtZW50XXwnLFxuICAgICdzdHlsZV5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxtZWRpYSx0eXBlJyxcbiAgICAnY2FwdGlvbl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAndGgsdGReW0hUTUxFbGVtZW50XXxhYmJyLGFsaWduLGF4aXMsYmdDb2xvcixjaCxjaE9mZiwjY29sU3BhbixoZWFkZXJzLGhlaWdodCwhbm9XcmFwLCNyb3dTcGFuLHNjb3BlLHZBbGlnbix3aWR0aCcsXG4gICAgJ2NvbCxjb2xncm91cF5bSFRNTEVsZW1lbnRdfGFsaWduLGNoLGNoT2ZmLCNzcGFuLHZBbGlnbix3aWR0aCcsXG4gICAgJ3RhYmxlXltIVE1MRWxlbWVudF18YWxpZ24sYmdDb2xvcixib3JkZXIsJWNhcHRpb24sY2VsbFBhZGRpbmcsY2VsbFNwYWNpbmcsZnJhbWUscnVsZXMsc3VtbWFyeSwldEZvb3QsJXRIZWFkLHdpZHRoJyxcbiAgICAndHJeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGNoLGNoT2ZmLHZBbGlnbicsXG4gICAgJ3Rmb290LHRoZWFkLHRib2R5XltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsdkFsaWduJyxcbiAgICAndGVtcGxhdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICd0ZXh0YXJlYV5bSFRNTEVsZW1lbnRdfGF1dG9jYXBpdGFsaXplLGF1dG9jb21wbGV0ZSwhYXV0b2ZvY3VzLCNjb2xzLGRlZmF1bHRWYWx1ZSxkaXJOYW1lLCFkaXNhYmxlZCwjbWF4TGVuZ3RoLCNtaW5MZW5ndGgsbmFtZSxwbGFjZWhvbGRlciwhcmVhZE9ubHksIXJlcXVpcmVkLCNyb3dzLHNlbGVjdGlvbkRpcmVjdGlvbiwjc2VsZWN0aW9uRW5kLCNzZWxlY3Rpb25TdGFydCx2YWx1ZSx3cmFwJyxcbiAgICAndGl0bGVeW0hUTUxFbGVtZW50XXx0ZXh0JyxcbiAgICAndHJhY2teW0hUTUxFbGVtZW50XXwhZGVmYXVsdCxraW5kLGxhYmVsLHNyYyxzcmNsYW5nJyxcbiAgICAndWxeW0hUTUxFbGVtZW50XXwhY29tcGFjdCx0eXBlJyxcbiAgICAndW5rbm93bl5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ3ZpZGVvXm1lZGlhfCNoZWlnaHQscG9zdGVyLCN3aWR0aCcsXG4gICAgJzpzdmc6YV46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6YW5pbWF0ZV46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOmFuaW1hdGVNb3Rpb25eOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzphbmltYXRlVHJhbnNmb3JtXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6Y2lyY2xlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpjbGlwUGF0aF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6ZGVmc146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6ZGVzY146c3ZnOnwnLFxuICAgICc6c3ZnOmRpc2NhcmReOnN2Zzp8JyxcbiAgICAnOnN2ZzplbGxpcHNlXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2ZzpmZUJsZW5kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb2xvck1hdHJpeF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29tcG9uZW50VHJhbnNmZXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbXBvc2l0ZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29udm9sdmVNYXRyaXheOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURpZmZ1c2VMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlRGlzcGxhY2VtZW50TWFwXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEaXN0YW50TGlnaHReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURyb3BTaGFkb3deOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUZsb29kXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVGdW5jQV46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUZ1bmNCXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlRnVuY0deOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVGdW5jUl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUdhdXNzaWFuQmx1cl46c3ZnOnwnLFxuICAgICc6c3ZnOmZlSW1hZ2VeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1lcmdlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNZXJnZU5vZGVeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU1vcnBob2xvZ3leOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZU9mZnNldF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlUG9pbnRMaWdodF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BlY3VsYXJMaWdodGluZ146c3ZnOnwnLFxuICAgICc6c3ZnOmZlU3BvdExpZ2h0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUaWxlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVUdXJidWxlbmNlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmlsdGVyXjpzdmc6fCcsXG4gICAgJzpzdmc6Zm9yZWlnbk9iamVjdF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6Z146c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6aW1hZ2VeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOmxpbmVhckdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAnOnN2ZzptcGF0aF46c3ZnOnwnLFxuICAgICc6c3ZnOm1hcmtlcl46c3ZnOnwnLFxuICAgICc6c3ZnOm1hc2teOnN2Zzp8JyxcbiAgICAnOnN2ZzptZXRhZGF0YV46c3ZnOnwnLFxuICAgICc6c3ZnOnBhdGheOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnBhdHRlcm5eOnN2Zzp8JyxcbiAgICAnOnN2Zzpwb2x5Z29uXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2Zzpwb2x5bGluZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6cmFkaWFsR3JhZGllbnReOnN2ZzpncmFkaWVudHwnLFxuICAgICc6c3ZnOnJlY3ReOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnN2Z146c3ZnOmdyYXBoaWNzfCNjdXJyZW50U2NhbGUsI3pvb21BbmRQYW4nLFxuICAgICc6c3ZnOnNjcmlwdF46c3ZnOnx0eXBlJyxcbiAgICAnOnN2ZzpzZXReOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzpzdG9wXjpzdmc6fCcsXG4gICAgJzpzdmc6c3R5bGVeOnN2Zzp8IWRpc2FibGVkLG1lZGlhLHRpdGxlLHR5cGUnLFxuICAgICc6c3ZnOnN3aXRjaF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6c3ltYm9sXjpzdmc6fCcsXG4gICAgJzpzdmc6dHNwYW5eOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAnOnN2Zzp0ZXh0Xjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgJzpzdmc6dGV4dFBhdGheOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICc6c3ZnOnRpdGxlXjpzdmc6fCcsXG4gICAgJzpzdmc6dXNlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2Zzp2aWV3Xjpzdmc6fCN6b29tQW5kUGFuJyxcbiAgICAnZGF0YV5bSFRNTEVsZW1lbnRdfHZhbHVlJyxcbiAgICAna2V5Z2VuXltIVE1MRWxlbWVudF18IWF1dG9mb2N1cyxjaGFsbGVuZ2UsIWRpc2FibGVkLGZvcm0sa2V5dHlwZSxuYW1lJyxcbiAgICAnbWVudWl0ZW1eW0hUTUxFbGVtZW50XXx0eXBlLGxhYmVsLGljb24sIWRpc2FibGVkLCFjaGVja2VkLHJhZGlvZ3JvdXAsIWRlZmF1bHQnLFxuICAgICdzdW1tYXJ5XltIVE1MRWxlbWVudF18JyxcbiAgICAndGltZV5bSFRNTEVsZW1lbnRdfGRhdGVUaW1lJyxcbiAgICAnOnN2ZzpjdXJzb3JeOnN2Zzp8Jyxcbl07XG5jb25zdCBfQVRUUl9UT19QUk9QID0ge1xuICAgICdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICAgICdmb3InOiAnaHRtbEZvcicsXG4gICAgJ2Zvcm1hY3Rpb24nOiAnZm9ybUFjdGlvbicsXG4gICAgJ2lubmVySHRtbCc6ICdpbm5lckhUTUwnLFxuICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4Jyxcbn07XG4vLyBJbnZlcnQgX0FUVFJfVE9fUFJPUC5cbmNvbnN0IF9QUk9QX1RPX0FUVFIgPSBPYmplY3Qua2V5cyhfQVRUUl9UT19QUk9QKS5yZWR1Y2UoKGludmVydGVkLCBhdHRyKSA9PiB7XG4gICAgaW52ZXJ0ZWRbX0FUVFJfVE9fUFJPUFthdHRyXV0gPSBhdHRyO1xuICAgIHJldHVybiBpbnZlcnRlZDtcbn0sIHt9KTtcbmNsYXNzIERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSBleHRlbmRzIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3NjaGVtYSA9IHt9O1xuICAgICAgICAvLyBXZSBkb24ndCBhbGxvdyBiaW5kaW5nIHRvIGV2ZW50cyBmb3Igc2VjdXJpdHkgcmVhc29ucy4gQWxsb3dpbmcgZXZlbnQgYmluZGluZ3Mgd291bGQgYWxtb3N0XG4gICAgICAgIC8vIGNlcnRhaW5seSBpbnRyb2R1Y2UgYmFkIFhTUyB2dWxuZXJhYmlsaXRpZXMuIEluc3RlYWQsIHdlIHN0b3JlIGV2ZW50cyBpbiBhIHNlcGFyYXRlIHNjaGVtYS5cbiAgICAgICAgdGhpcy5fZXZlbnRTY2hlbWEgPSB7fTtcbiAgICAgICAgU0NIRU1BLmZvckVhY2goZW5jb2RlZFR5cGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHt9O1xuICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgY29uc3QgW3N0clR5cGUsIHN0clByb3BlcnRpZXNdID0gZW5jb2RlZFR5cGUuc3BsaXQoJ3wnKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBzdHJQcm9wZXJ0aWVzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBjb25zdCBbdHlwZU5hbWVzLCBzdXBlck5hbWVdID0gc3RyVHlwZS5zcGxpdCgnXicpO1xuICAgICAgICAgICAgdHlwZU5hbWVzLnNwbGl0KCcsJykuZm9yRWFjaCh0YWcgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVtYVt0YWcudG9Mb3dlckNhc2UoKV0gPSB0eXBlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50U2NoZW1hW3RhZy50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50cztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3VwZXJUeXBlID0gc3VwZXJOYW1lICYmIHRoaXMuX3NjaGVtYVtzdXBlck5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAoc3VwZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc3VwZXJUeXBlKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVbcHJvcF0gPSBzdXBlclR5cGVbcHJvcF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdXBlckV2ZW50IG9mIHRoaXMuX2V2ZW50U2NoZW1hW3N1cGVyTmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKHN1cGVyRXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHByb3BlcnR5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuYWRkKHByb3BlcnR5LnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5LnN1YnN0cmluZygxKV0gPSBCT09MRUFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gTlVNQkVSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVtwcm9wZXJ0eS5zdWJzdHJpbmcoMSldID0gT0JKRUNUO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlW3Byb3BlcnR5XSA9IFNUUklORztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFzUHJvcGVydHkodGFnTmFtZSwgcHJvcE5hbWUsIHNjaGVtYU1ldGFzKSB7XG4gICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKChzY2hlbWEpID0+IHNjaGVtYS5uYW1lID09PSBOT19FUlJPUlNfU0NIRU1BLm5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgaWYgKGlzTmdDb250YWluZXIodGFnTmFtZSkgfHwgaXNOZ0NvbnRlbnQodGFnTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hTWV0YXMuc29tZSgoc2NoZW1hKSA9PiBzY2hlbWEubmFtZSA9PT0gQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIENhbid0IHRlbGwgbm93IGFzIHdlIGRvbid0IGtub3cgd2hpY2ggcHJvcGVydGllcyBhIGN1c3RvbSBlbGVtZW50IHdpbGwgZ2V0XG4gICAgICAgICAgICAgICAgLy8gb25jZSBpdCBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50UHJvcGVydGllcyA9IHRoaXMuX3NjaGVtYVt0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8IHRoaXMuX3NjaGVtYVsndW5rbm93biddO1xuICAgICAgICByZXR1cm4gISFlbGVtZW50UHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgfVxuICAgIGhhc0VsZW1lbnQodGFnTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoKHNjaGVtYSkgPT4gc2NoZW1hLm5hbWUgPT09IE5PX0VSUk9SU19TQ0hFTUEubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNOZ0NvbnRhaW5lcih0YWdOYW1lKSB8fCBpc05nQ29udGVudCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoKHNjaGVtYSkgPT4gc2NoZW1hLm5hbWUgPT09IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbnkgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhdGhpcy5fc2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNlY3VyaXR5Q29udGV4dCByZXR1cm5zIHRoZSBzZWN1cml0eSBjb250ZXh0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgb24gdGhlIGdpdmVuIERPTSB0YWcuXG4gICAgICpcbiAgICAgKiBUYWcgYW5kIHByb3BlcnR5IG5hbWUgYXJlIHN0YXRpY2FsbHkga25vd24gYW5kIGNhbm5vdCBjaGFuZ2UgYXQgcnVudGltZSwgaS5lLiBpdCBpcyBub3RcbiAgICAgKiBwb3NzaWJsZSB0byBiaW5kIGEgdmFsdWUgaW50byBhIGNoYW5naW5nIGF0dHJpYnV0ZSBvciB0YWcgbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSBmaWx0ZXJpbmcgaXMgYmFzZWQgb24gYSBsaXN0IG9mIGFsbG93ZWQgdGFnc3xhdHRyaWJ1dGVzLiBBbGwgYXR0cmlidXRlcyBpbiB0aGUgc2NoZW1hXG4gICAgICogYWJvdmUgYXJlIGFzc3VtZWQgdG8gaGF2ZSB0aGUgJ05PTkUnIHNlY3VyaXR5IGNvbnRleHQsIGkuZS4gdGhhdCB0aGV5IGFyZSBzYWZlIGluZXJ0XG4gICAgICogc3RyaW5nIHZhbHVlcy4gT25seSBzcGVjaWZpYyB3ZWxsIGtub3duIGF0dGFjayB2ZWN0b3JzIGFyZSBhc3NpZ25lZCB0aGVpciBhcHByb3ByaWF0ZSBjb250ZXh0LlxuICAgICAqL1xuICAgIHNlY3VyaXR5Q29udGV4dCh0YWdOYW1lLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGlzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAvLyBOQjogRm9yIHNlY3VyaXR5IHB1cnBvc2VzLCB1c2UgdGhlIG1hcHBlZCBwcm9wZXJ0eSBuYW1lLCBub3QgdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgICAgICAgICAgcHJvcE5hbWUgPSB0aGlzLmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgY29tcGFyaXNvbnMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIHNvIHRoYXQgY2FzZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGF0dHJpYnV0ZSBhbmRcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IGN0eCA9IFNFQ1VSSVRZX1NDSEVNQSgpW3RhZ05hbWUgKyAnfCcgKyBwcm9wTmFtZV07XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH1cbiAgICAgICAgY3R4ID0gU0VDVVJJVFlfU0NIRU1BKClbJyp8JyArIHByb3BOYW1lXTtcbiAgICAgICAgcmV0dXJuIGN0eCA/IGN0eCA6IFNlY3VyaXR5Q29udGV4dC5OT05FO1xuICAgIH1cbiAgICBnZXRNYXBwZWRQcm9wTmFtZShwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gX0FUVFJfVE9fUFJPUFtwcm9wTmFtZV0gfHwgcHJvcE5hbWU7XG4gICAgfVxuICAgIGdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICduZy1jb21wb25lbnQnO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BlcnR5KG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgQmluZGluZyB0byBldmVudCBwcm9wZXJ0eSAnJHtuYW1lfScgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgYCArXG4gICAgICAgICAgICAgICAgYHBsZWFzZSB1c2UgKCR7bmFtZS5zbGljZSgyKX0pPS4uLmAgK1xuICAgICAgICAgICAgICAgIGBcXG5JZiAnJHtuYW1lfScgaXMgYSBkaXJlY3RpdmUgaW5wdXQsIG1ha2Ugc3VyZSB0aGUgZGlyZWN0aXZlIGlzIGltcG9ydGVkIGJ5IHRoZWAgK1xuICAgICAgICAgICAgICAgIGAgY3VycmVudCBtb2R1bGUuYDtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBCaW5kaW5nIHRvIGV2ZW50IGF0dHJpYnV0ZSAnJHtuYW1lfScgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgYCArXG4gICAgICAgICAgICAgICAgYHBsZWFzZSB1c2UgKCR7bmFtZS5zbGljZSgyKX0pPS4uLmA7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFsbEtub3duRWxlbWVudE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc2NoZW1hKTtcbiAgICB9XG4gICAgYWxsS25vd25BdHRyaWJ1dGVzT2ZFbGVtZW50KHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BlcnRpZXMgPSB0aGlzLl9zY2hlbWFbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCB0aGlzLl9zY2hlbWFbJ3Vua25vd24nXTtcbiAgICAgICAgLy8gQ29udmVydCBwcm9wZXJ0aWVzIHRvIGF0dHJpYnV0ZXMuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhlbGVtZW50UHJvcGVydGllcykubWFwKHByb3AgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBfUFJPUF9UT19BVFRSW3Byb3BdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm9wOyB9KTtcbiAgICB9XG4gICAgYWxsS25vd25FdmVudHNPZkVsZW1lbnQodGFnTmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKChfYSA9IHRoaXMuX2V2ZW50U2NoZW1hW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcbiAgICB9XG4gICAgbm9ybWFsaXplQW5pbWF0aW9uU3R5bGVQcm9wZXJ0eShwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gZGFzaENhc2VUb0NhbWVsQ2FzZShwcm9wTmFtZSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlVmFsdWUoY2FtZWxDYXNlUHJvcCwgdXNlclByb3ZpZGVkUHJvcCwgdmFsKSB7XG4gICAgICAgIGxldCB1bml0ID0gJyc7XG4gICAgICAgIGNvbnN0IHN0clZhbCA9IHZhbC50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgbGV0IGVycm9yTXNnID0gbnVsbDtcbiAgICAgICAgaWYgKF9pc1BpeGVsRGltZW5zaW9uU3R5bGUoY2FtZWxDYXNlUHJvcCkgJiYgdmFsICE9PSAwICYmIHZhbCAhPT0gJzAnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbEFuZFN1ZmZpeE1hdGNoID0gdmFsLm1hdGNoKC9eWystXT9bXFxkXFwuXSsoW2Etel0qKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsQW5kU3VmZml4TWF0Y2ggJiYgdmFsQW5kU3VmZml4TWF0Y2hbMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgPSBgUGxlYXNlIHByb3ZpZGUgYSBDU1MgdW5pdCB2YWx1ZSBmb3IgJHt1c2VyUHJvdmlkZWRQcm9wfToke3ZhbH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyb3JNc2csIHZhbHVlOiBzdHJWYWwgKyB1bml0IH07XG4gICAgfVxufVxuZnVuY3Rpb24gX2lzUGl4ZWxEaW1lbnNpb25TdHlsZShwcm9wKSB7XG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWluV2lkdGgnOlxuICAgICAgICBjYXNlICdtaW5IZWlnaHQnOlxuICAgICAgICBjYXNlICdtYXhXaWR0aCc6XG4gICAgICAgIGNhc2UgJ21heEhlaWdodCc6XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNhc2UgJ2ZvbnRTaXplJzpcbiAgICAgICAgY2FzZSAnb3V0bGluZVdpZHRoJzpcbiAgICAgICAgY2FzZSAnb3V0bGluZU9mZnNldCc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdUb3AnOlxuICAgICAgICBjYXNlICdwYWRkaW5nTGVmdCc6XG4gICAgICAgIGNhc2UgJ3BhZGRpbmdCb3R0b20nOlxuICAgICAgICBjYXNlICdwYWRkaW5nUmlnaHQnOlxuICAgICAgICBjYXNlICdtYXJnaW5Ub3AnOlxuICAgICAgICBjYXNlICdtYXJnaW5MZWZ0JzpcbiAgICAgICAgY2FzZSAnbWFyZ2luQm90dG9tJzpcbiAgICAgICAgY2FzZSAnbWFyZ2luUmlnaHQnOlxuICAgICAgICBjYXNlICdib3JkZXJSYWRpdXMnOlxuICAgICAgICBjYXNlICdib3JkZXJXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlclRvcFdpZHRoJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyTGVmdFdpZHRoJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyUmlnaHRXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlckJvdHRvbVdpZHRoJzpcbiAgICAgICAgY2FzZSAndGV4dEluZGVudCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBTZXQgb2YgdGFnTmFtZXxwcm9wZXJ0eU5hbWUgY29ycmVzcG9uZGluZyB0byBUcnVzdGVkIFR5cGVzIHNpbmtzLiBQcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIGFsbFxuICogdGFncyB1c2UgJyonLlxuICpcbiAqIEV4dHJhY3RlZCBmcm9tLCBhbmQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoXG4gKiBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXRydXN0ZWQtdHlwZXMvZGlzdC9zcGVjLyNpbnRlZ3JhdGlvbnNcbiAqL1xuY29uc3QgVFJVU1RFRF9UWVBFU19TSU5LUyA9IG5ldyBTZXQoW1xuICAgIC8vIE5PVEU6IEFsbCBzdHJpbmdzIGluIHRoaXMgc2V0ICptdXN0KiBiZSBsb3dlcmNhc2UhXG4gICAgLy8gVHJ1c3RlZEhUTUxcbiAgICAnaWZyYW1lfHNyY2RvYycsXG4gICAgJyp8aW5uZXJodG1sJyxcbiAgICAnKnxvdXRlcmh0bWwnLFxuICAgIC8vIE5COiBubyBUcnVzdGVkU2NyaXB0IGhlcmUsIGFzIHRoZSBjb3JyZXNwb25kaW5nIHRhZ3MgYXJlIHN0cmlwcGVkIGJ5IHRoZSBjb21waWxlci5cbiAgICAvLyBUcnVzdGVkU2NyaXB0VVJMXG4gICAgJ2VtYmVkfHNyYycsXG4gICAgJ29iamVjdHxjb2RlYmFzZScsXG4gICAgJ29iamVjdHxkYXRhJyxcbl0pO1xuLyoqXG4gKiBpc1RydXN0ZWRUeXBlc1NpbmsgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gRE9NIHRhZyBpcyBhIFRydXN0ZWQgVHlwZXNcbiAqIHNpbmsuIEluIHRoYXQgY2FzZSwgdXNlIGBFbGVtZW50U2NoZW1hUmVnaXN0cnkuc2VjdXJpdHlDb250ZXh0YCB0byBkZXRlcm1pbmUgd2hpY2ggcGFydGljdWxhclxuICogVHJ1c3RlZCBUeXBlIGlzIHJlcXVpcmVkIGZvciB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBzaW5rOlxuICogLSBTZWN1cml0eUNvbnRleHQuSFRNTCBjb3JyZXNwb25kcyB0byBUcnVzdGVkSFRNTFxuICogLSBTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMIGNvcnJlc3BvbmRzIHRvIFRydXN0ZWRTY3JpcHRVUkxcbiAqL1xuZnVuY3Rpb24gaXNUcnVzdGVkVHlwZXNTaW5rKHRhZ05hbWUsIHByb3BOYW1lKSB7XG4gICAgLy8gTWFrZSBzdXJlIGNvbXBhcmlzb25zIGFyZSBjYXNlIGluc2Vuc2l0aXZlLCBzbyB0aGF0IGNhc2UgZGlmZmVyZW5jZXMgYmV0d2VlbiBhdHRyaWJ1dGUgYW5kXG4gICAgLy8gcHJvcGVydHkgbmFtZXMgZG8gbm90IGhhdmUgYSBzZWN1cml0eSBpbXBhY3QuXG4gICAgdGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwcm9wTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIFRSVVNURURfVFlQRVNfU0lOS1MuaGFzKHRhZ05hbWUgKyAnfCcgKyBwcm9wTmFtZSkgfHxcbiAgICAgICAgVFJVU1RFRF9UWVBFU19TSU5LUy5oYXMoJyp8JyArIHByb3BOYW1lKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IgPSAnLic7XG5jb25zdCBBVFRSSUJVVEVfUFJFRklYID0gJ2F0dHInO1xuY29uc3QgQ0xBU1NfUFJFRklYID0gJ2NsYXNzJztcbmNvbnN0IFNUWUxFX1BSRUZJWCA9ICdzdHlsZSc7XG5jb25zdCBURU1QTEFURV9BVFRSX1BSRUZJWCQxID0gJyonO1xuY29uc3QgQU5JTUFURV9QUk9QX1BSRUZJWCA9ICdhbmltYXRlLSc7XG4vKipcbiAqIFBhcnNlcyBiaW5kaW5ncyBpbiB0ZW1wbGF0ZXMgYW5kIGluIHRoZSBkaXJlY3RpdmUgaG9zdCBhcmVhLlxuICovXG5jbGFzcyBCaW5kaW5nUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihfZXhwclBhcnNlciwgX2ludGVycG9sYXRpb25Db25maWcsIF9zY2hlbWFSZWdpc3RyeSwgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMuX2V4cHJQYXJzZXIgPSBfZXhwclBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeSA9IF9zY2hlbWFSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxuICAgIGdldCBpbnRlcnBvbGF0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICB9XG4gICAgY3JlYXRlQm91bmRIb3N0UHJvcGVydGllcyhwcm9wZXJ0aWVzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eUJpbmRpbmcocHJvcE5hbWUsIGV4cHJlc3Npb24sIHRydWUsIHNvdXJjZVNwYW4sIHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0LCB1bmRlZmluZWQsIFtdLCBcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGBzb3VyY2VTcGFuYCBmb3IgIGBrZXlTcGFuYC4gVGhpcyBpc24ndCByZWFsbHkgYWNjdXJhdGUsIGJ1dCBuZWl0aGVyIGlzIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNvdXJjZVNwYW4sIGFzIGl0IHJlcHJlc2VudHMgdGhlIHNvdXJjZVNwYW4gb2YgdGhlIGhvc3QgaXRzZWxmIHJhdGhlciB0aGFuIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNvdXJjZSBvZiB0aGUgaG9zdCBiaW5kaW5nICh3aGljaCBkb2Vzbid0IGV4aXN0IGluIHRoZSB0ZW1wbGF0ZSkuIFJlZ2FyZGxlc3MsXG4gICAgICAgICAgICAgICAgLy8gbmVpdGhlciBvZiB0aGVzZSB2YWx1ZXMgYXJlIHVzZWQgaW4gSXZ5IGJ1dCBhcmUgb25seSBoZXJlIHRvIHNhdGlzZnkgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgLy8gc2lnbmF0dXJlLiBUaGlzIHNob3VsZCBsaWtlbHkgYmUgcmVmYWN0b3JlZCBpbiB0aGUgZnV0dXJlIHNvIHRoYXQgYHNvdXJjZVNwYW5gXG4gICAgICAgICAgICAgICAgLy8gaXNuJ3QgYmVpbmcgdXNlZCBpbmFjY3VyYXRlbHkuXG4gICAgICAgICAgICAgICAgYm91bmRQcm9wcywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgVmFsdWUgb2YgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZyBcIiR7cHJvcE5hbWV9XCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcIiR7ZXhwcmVzc2lvbn1cIiAoJHt0eXBlb2YgZXhwcmVzc2lvbn0pYCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kUHJvcHM7XG4gICAgfVxuICAgIGNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoaG9zdExpc3RlbmVycywgc291cmNlU3Bhbikge1xuICAgICAgICBjb25zdCB0YXJnZXRFdmVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wTmFtZSBvZiBPYmplY3Qua2V5cyhob3N0TGlzdGVuZXJzKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IGhvc3RMaXN0ZW5lcnNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgYHNvdXJjZVNwYW5gIGZvciAgYGtleVNwYW5gIGFuZCBgaGFuZGxlclNwYW5gLiBUaGlzIGlzbid0IHJlYWxseSBhY2N1cmF0ZSwgYnV0XG4gICAgICAgICAgICAgICAgLy8gbmVpdGhlciBpcyB0aGUgYHNvdXJjZVNwYW5gLCBhcyBpdCByZXByZXNlbnRzIHRoZSBgc291cmNlU3BhbmAgb2YgdGhlIGhvc3QgaXRzZWxmXG4gICAgICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gdGhlIHNvdXJjZSBvZiB0aGUgaG9zdCBiaW5kaW5nICh3aGljaCBkb2Vzbid0IGV4aXN0IGluIHRoZSB0ZW1wbGF0ZSkuXG4gICAgICAgICAgICAgICAgLy8gUmVnYXJkbGVzcywgbmVpdGhlciBvZiB0aGVzZSB2YWx1ZXMgYXJlIHVzZWQgaW4gSXZ5IGJ1dCBhcmUgb25seSBoZXJlIHRvIHNhdGlzZnkgdGhlXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gc2lnbmF0dXJlLiBUaGlzIHNob3VsZCBsaWtlbHkgYmUgcmVmYWN0b3JlZCBpbiB0aGUgZnV0dXJlIHNvIHRoYXQgYHNvdXJjZVNwYW5gXG4gICAgICAgICAgICAgICAgLy8gaXNuJ3QgYmVpbmcgdXNlZCBpbmFjY3VyYXRlbHkuXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUV2ZW50KHByb3BOYW1lLCBleHByZXNzaW9uLCAvKiBpc0Fzc2lnbm1lbnRFdmVudCAqLyBmYWxzZSwgc291cmNlU3Bhbiwgc291cmNlU3BhbiwgW10sIHRhcmdldEV2ZW50cywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgVmFsdWUgb2YgdGhlIGhvc3QgbGlzdGVuZXIgXCIke3Byb3BOYW1lfVwiIG5lZWRzIHRvIGJlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBleHByZXNzaW9uIGJ1dCBnb3QgXCIke2V4cHJlc3Npb259XCIgKCR7dHlwZW9mIGV4cHJlc3Npb259KWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRFdmVudHM7XG4gICAgfVxuICAgIHBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlU3BhbiwgaW50ZXJwb2xhdGVkVG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGFic29sdXRlT2Zmc2V0ID0gc291cmNlU3Bhbi5mdWxsU3RhcnQub2Zmc2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0ZWRUb2tlbnMsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYCR7ZX1gLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGBwYXJzZUludGVycG9sYXRpb25gLCBidXQgdHJlYXRzIHRoZSBwcm92aWRlZCBzdHJpbmcgYXMgYSBzaW5nbGUgZXhwcmVzc2lvblxuICAgICAqIGVsZW1lbnQgdGhhdCB3b3VsZCBub3JtYWxseSBhcHBlYXIgd2l0aGluIHRoZSBpbnRlcnBvbGF0aW9uIHByZWZpeCBhbmQgc3VmZml4IChge3tgIGFuZCBgfX1gKS5cbiAgICAgKiBUaGlzIGlzIHVzZWQgZm9yIHBhcnNpbmcgdGhlIHN3aXRjaCBleHByZXNzaW9uIGluIElDVXMuXG4gICAgICovXG4gICAgcGFyc2VJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUluZm8gPSBzb3VyY2VTcGFuLnN0YXJ0LnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGFic29sdXRlT2Zmc2V0ID0gc291cmNlU3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhc3QgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oZXhwcmVzc2lvbiwgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYCR7ZX1gLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGJpbmRpbmdzIGluIGEgbWljcm9zeW50YXggZXhwcmVzc2lvbiwgYW5kIGNvbnZlcnRzIHRoZW0gdG9cbiAgICAgKiBgUGFyc2VkUHJvcGVydHlgIG9yIGBQYXJzZWRWYXJpYWJsZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHBsS2V5IHRlbXBsYXRlIGJpbmRpbmcgbmFtZVxuICAgICAqIEBwYXJhbSB0cGxWYWx1ZSB0ZW1wbGF0ZSBiaW5kaW5nIHZhbHVlXG4gICAgICogQHBhcmFtIHNvdXJjZVNwYW4gc3BhbiBvZiB0ZW1wbGF0ZSBiaW5kaW5nIHJlbGF0aXZlIHRvIGVudGlyZSB0aGUgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVWYWx1ZU9mZnNldCBzdGFydCBvZiB0aGUgdHBsVmFsdWUgcmVsYXRpdmUgdG8gdGhlIGVudGlyZSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB0YXJnZXRNYXRjaGFibGVBdHRycyBwb3RlbnRpYWwgYXR0cmlidXRlcyB0byBtYXRjaCBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0gdGFyZ2V0UHJvcHMgdGFyZ2V0IHByb3BlcnR5IGJpbmRpbmdzIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB0YXJnZXRWYXJzIHRhcmdldCB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlXG4gICAgICovXG4gICAgcGFyc2VJbmxpbmVUZW1wbGF0ZUJpbmRpbmcodHBsS2V5LCB0cGxWYWx1ZSwgc291cmNlU3BhbiwgYWJzb2x1dGVWYWx1ZU9mZnNldCwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCB0YXJnZXRWYXJzLCBpc0l2eUFzdCkge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZUtleU9mZnNldCA9IHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0ICsgVEVNUExBVEVfQVRUUl9QUkVGSVgkMS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpcy5fcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRwbEtleSwgdHBsVmFsdWUsIHNvdXJjZVNwYW4sIGFic29sdXRlS2V5T2Zmc2V0LCBhYnNvbHV0ZVZhbHVlT2Zmc2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgICAgICAvLyBzb3VyY2VTcGFuIGlzIGZvciB0aGUgZW50aXJlIEhUTUwgYXR0cmlidXRlLiBiaW5kaW5nU3BhbiBpcyBmb3IgYSBwYXJ0aWN1bGFyXG4gICAgICAgICAgICAvLyBiaW5kaW5nIHdpdGhpbiB0aGUgbWljcm9zeW50YXggZXhwcmVzc2lvbiBzbyBpdCdzIG1vcmUgbmFycm93IHRoYW4gc291cmNlU3Bhbi5cbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdTcGFuID0gbW92ZVBhcnNlU291cmNlU3Bhbihzb3VyY2VTcGFuLCBiaW5kaW5nLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYmluZGluZy5rZXkuc291cmNlO1xuICAgICAgICAgICAgY29uc3Qga2V5U3BhbiA9IG1vdmVQYXJzZVNvdXJjZVNwYW4oc291cmNlU3BhbiwgYmluZGluZy5rZXkuc3Bhbik7XG4gICAgICAgICAgICBpZiAoYmluZGluZyBpbnN0YW5jZW9mIFZhcmlhYmxlQmluZGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYmluZGluZy52YWx1ZSA/IGJpbmRpbmcudmFsdWUuc291cmNlIDogJyRpbXBsaWNpdCc7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVTcGFuID0gYmluZGluZy52YWx1ZSA/IG1vdmVQYXJzZVNvdXJjZVNwYW4oc291cmNlU3BhbiwgYmluZGluZy52YWx1ZS5zcGFuKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0YXJnZXRWYXJzLnB1c2gobmV3IFBhcnNlZFZhcmlhYmxlKGtleSwgdmFsdWUsIGJpbmRpbmdTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRpbmcudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmNTcGFuID0gaXNJdnlBc3QgPyBiaW5kaW5nU3BhbiA6IHNvdXJjZVNwYW47XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVTcGFuID0gbW92ZVBhcnNlU291cmNlU3Bhbihzb3VyY2VTcGFuLCBiaW5kaW5nLnZhbHVlLmFzdC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KGtleSwgYmluZGluZy52YWx1ZSwgc3JjU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChba2V5LCAnJyAvKiB2YWx1ZSAqL10pO1xuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBsaXRlcmFsIGF0dHJpYnV0ZSB3aXRoIG5vIFJIUywgc291cmNlIHNwYW4gc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8ganVzdCB0aGUga2V5IHNwYW4uXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUxpdGVyYWxBdHRyKGtleSwgbnVsbCAvKiB2YWx1ZSAqLywga2V5U3BhbiwgYWJzb2x1dGVWYWx1ZU9mZnNldCwgdW5kZWZpbmVkIC8qIHZhbHVlU3BhbiAqLywgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCBrZXlTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGJpbmRpbmdzIGluIGEgbWljcm9zeW50YXggZXhwcmVzc2lvbiwgZS5nLlxuICAgICAqIGBgYFxuICAgICAqICAgIDx0YWcgKnRwbEtleT1cImxldCB2YWx1ZTEgPSBwcm9wOyBsZXQgdmFsdWUyID0gbG9jYWxWYXJcIj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cGxLZXkgdGVtcGxhdGUgYmluZGluZyBuYW1lXG4gICAgICogQHBhcmFtIHRwbFZhbHVlIHRlbXBsYXRlIGJpbmRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0gc291cmNlU3BhbiBzcGFuIG9mIHRlbXBsYXRlIGJpbmRpbmcgcmVsYXRpdmUgdG8gZW50aXJlIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZUtleU9mZnNldCBzdGFydCBvZiB0aGUgYHRwbEtleWBcbiAgICAgKiBAcGFyYW0gYWJzb2x1dGVWYWx1ZU9mZnNldCBzdGFydCBvZiB0aGUgYHRwbFZhbHVlYFxuICAgICAqL1xuICAgIF9wYXJzZVRlbXBsYXRlQmluZGluZ3ModHBsS2V5LCB0cGxWYWx1ZSwgc291cmNlU3BhbiwgYWJzb2x1dGVLZXlPZmZzZXQsIGFic29sdXRlVmFsdWVPZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdzUmVzdWx0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZVRlbXBsYXRlQmluZGluZ3ModHBsS2V5LCB0cGxWYWx1ZSwgc291cmNlSW5mbywgYWJzb2x1dGVLZXlPZmZzZXQsIGFic29sdXRlVmFsdWVPZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhiaW5kaW5nc1Jlc3VsdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgYmluZGluZ3NSZXN1bHQud2FybmluZ3MuZm9yRWFjaCgod2FybmluZykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHdhcm5pbmcsIHNvdXJjZVNwYW4sIGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLldBUk5JTkcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYCR7ZX1gLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIGtleVNwYW4pIHtcbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGlmIChrZXlTcGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrZXlTcGFuID0gbW92ZVBhcnNlU291cmNlU3BhbihrZXlTcGFuLCBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGtleVNwYW4uc3RhcnQub2Zmc2V0ICsgMSwga2V5U3Bhbi5lbmQub2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgQXNzaWduaW5nIGFuaW1hdGlvbiB0cmlnZ2VycyB2aWEgQHByb3A9XCJleHBcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLmAgK1xuICAgICAgICAgICAgICAgICAgICBgIFVzZSBwcm9wZXJ0eSBiaW5kaW5ncyAoZS5nLiBbQHByb3BdPVwiZXhwXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLmAsIHNvdXJjZVNwYW4sIGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkVSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwga2V5U3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgUGFyc2VkUHJvcGVydHkobmFtZSwgdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSh2YWx1ZSwgJycsIGFic29sdXRlT2Zmc2V0KSwgZXhwb3J0cy5QYXJzZWRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZVByb3BlcnR5QmluZGluZyhuYW1lLCBleHByZXNzaW9uLCBpc0hvc3QsIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcywga2V5U3Bhbikge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBQcm9wZXJ0eSBuYW1lIGlzIG1pc3NpbmcgaW4gYmluZGluZ2AsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc0FuaW1hdGlvblByb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChBTklNQVRFX1BST1BfUFJFRklYKSkge1xuICAgICAgICAgICAgaXNBbmltYXRpb25Qcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhBTklNQVRFX1BST1BfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoa2V5U3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAga2V5U3BhbiA9IG1vdmVQYXJzZVNvdXJjZVNwYW4oa2V5U3BhbiwgbmV3IEFic29sdXRlU291cmNlU3BhbihrZXlTcGFuLnN0YXJ0Lm9mZnNldCArIEFOSU1BVEVfUFJPUF9QUkVGSVgubGVuZ3RoLCBrZXlTcGFuLmVuZC5vZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FuaW1hdGlvbkxhYmVsKG5hbWUpKSB7XG4gICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgaWYgKGtleVNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGtleVNwYW4gPSBtb3ZlUGFyc2VTb3VyY2VTcGFuKGtleVNwYW4sIG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oa2V5U3Bhbi5zdGFydC5vZmZzZXQgKyAxLCBrZXlTcGFuLmVuZC5vZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbmltYXRpb25Qcm9wKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbihuYW1lLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwga2V5U3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCB0aGlzLl9wYXJzZUJpbmRpbmcoZXhwcmVzc2lvbiwgaXNIb3N0LCB2YWx1ZVNwYW4gfHwgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQpLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VQcm9wZXJ0eUludGVycG9sYXRpb24obmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCBrZXlTcGFuLCBpbnRlcnBvbGF0ZWRUb2tlbnMpIHtcbiAgICAgICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCB2YWx1ZVNwYW4gfHwgc291cmNlU3BhbiwgaW50ZXJwb2xhdGVkVG9rZW5zKTtcbiAgICAgICAgaWYgKGV4cHIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3QobmFtZSwgZXhwciwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCBhc3QsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKSB7XG4gICAgICAgIHRhcmdldE1hdGNoYWJsZUF0dHJzLnB1c2goW25hbWUsIGFzdC5zb3VyY2VdKTtcbiAgICAgICAgdGFyZ2V0UHJvcHMucHVzaChuZXcgUGFyc2VkUHJvcGVydHkobmFtZSwgYXN0LCBleHBvcnRzLlBhcnNlZFByb3BlcnR5VHlwZS5ERUZBVUxULCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICB9XG4gICAgX3BhcnNlQW5pbWF0aW9uKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCBrZXlTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKCdBbmltYXRpb24gdHJpZ2dlciBpcyBtaXNzaW5nJywgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB3aWxsIG9jY3VyIHdoZW4gYSBAdHJpZ2dlciBpcyBub3QgcGFpcmVkIHdpdGggYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgLy8gRm9yIGFuaW1hdGlvbnMgaXQgaXMgdmFsaWQgdG8gbm90IGhhdmUgYW4gZXhwcmVzc2lvbiBzaW5jZSAqL3ZvaWRcbiAgICAgICAgLy8gc3RhdGVzIHdpbGwgYmUgYXBwbGllZCBieSBhbmd1bGFyIHdoZW4gdGhlIGVsZW1lbnQgaXMgYXR0YWNoZWQvZGV0YWNoZWRcbiAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24gfHwgJ3VuZGVmaW5lZCcsIGZhbHNlLCB2YWx1ZVNwYW4gfHwgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IFBhcnNlZFByb3BlcnR5KG5hbWUsIGFzdCwgZXhwb3J0cy5QYXJzZWRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICB9XG4gICAgX3BhcnNlQmluZGluZyh2YWx1ZSwgaXNIb3N0QmluZGluZywgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc291cmNlSW5mbyA9IChzb3VyY2VTcGFuICYmIHNvdXJjZVNwYW4uc3RhcnQgfHwgJyh1bmtub3duKScpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhc3QgPSBpc0hvc3RCaW5kaW5nID9cbiAgICAgICAgICAgICAgICB0aGlzLl9leHByUGFyc2VyLnBhcnNlU2ltcGxlQmluZGluZyh2YWx1ZSwgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9leHByUGFyc2VyLnBhcnNlQmluZGluZyh2YWx1ZSwgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgaWYgKGFzdClcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYCR7ZX1gLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVCb3VuZEVsZW1lbnRQcm9wZXJ0eShlbGVtZW50U2VsZWN0b3IsIGJvdW5kUHJvcCwgc2tpcFZhbGlkYXRpb24gPSBmYWxzZSwgbWFwUHJvcGVydHlOYW1lID0gdHJ1ZSkge1xuICAgICAgICBpZiAoYm91bmRQcm9wLmlzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kRWxlbWVudFByb3BlcnR5KGJvdW5kUHJvcC5uYW1lLCA0IC8qIEJpbmRpbmdUeXBlLkFuaW1hdGlvbiAqLywgU2VjdXJpdHlDb250ZXh0Lk5PTkUsIGJvdW5kUHJvcC5leHByZXNzaW9uLCBudWxsLCBib3VuZFByb3Auc291cmNlU3BhbiwgYm91bmRQcm9wLmtleVNwYW4sIGJvdW5kUHJvcC52YWx1ZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1bml0ID0gbnVsbDtcbiAgICAgICAgbGV0IGJpbmRpbmdUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYm91bmRQcm9wZXJ0eU5hbWUgPSBudWxsO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGJvdW5kUHJvcC5uYW1lLnNwbGl0KFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUik7XG4gICAgICAgIGxldCBzZWN1cml0eUNvbnRleHRzID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBDaGVjayBmb3Igc3BlY2lhbCBjYXNlcyAocHJlZml4IHN0eWxlLCBhdHRyLCBjbGFzcylcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PSBBVFRSSUJVVEVfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUik7XG4gICAgICAgICAgICAgICAgaWYgKCFza2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lKGJvdW5kUHJvcGVydHlOYW1lLCBib3VuZFByb3Auc291cmNlU3BhbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCBlbGVtZW50U2VsZWN0b3IsIGJvdW5kUHJvcGVydHlOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuc1NlcGFyYXRvcklkeCA9IGJvdW5kUHJvcGVydHlOYW1lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAobnNTZXBhcmF0b3JJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBucyA9IGJvdW5kUHJvcGVydHlOYW1lLnN1YnN0cmluZygwLCBuc1NlcGFyYXRvcklkeCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcobnNTZXBhcmF0b3JJZHggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBtZXJnZU5zQW5kTmFtZShucywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMSAvKiBCaW5kaW5nVHlwZS5BdHRyaWJ1dGUgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBDTEFTU19QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMiAvKiBCaW5kaW5nVHlwZS5DbGFzcyAqLztcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gW1NlY3VyaXR5Q29udGV4dC5OT05FXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnRzWzBdID09IFNUWUxFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSBwYXJ0cy5sZW5ndGggPiAyID8gcGFydHNbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgYmluZGluZ1R5cGUgPSAzIC8qIEJpbmRpbmdUeXBlLlN0eWxlICovO1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMgPSBbU2VjdXJpdHlDb250ZXh0LlNUWUxFXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgYSBzcGVjaWFsIGNhc2UsIHVzZSB0aGUgZnVsbCBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIGlmIChib3VuZFByb3BlcnR5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbWFwcGVkUHJvcE5hbWUgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShib3VuZFByb3AubmFtZSk7XG4gICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IG1hcFByb3BlcnR5TmFtZSA/IG1hcHBlZFByb3BOYW1lIDogYm91bmRQcm9wLm5hbWU7XG4gICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyh0aGlzLl9zY2hlbWFSZWdpc3RyeSwgZWxlbWVudFNlbGVjdG9yLCBtYXBwZWRQcm9wTmFtZSwgZmFsc2UpO1xuICAgICAgICAgICAgYmluZGluZ1R5cGUgPSAwIC8qIEJpbmRpbmdUeXBlLlByb3BlcnR5ICovO1xuICAgICAgICAgICAgaWYgKCFza2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUobWFwcGVkUHJvcE5hbWUsIGJvdW5kUHJvcC5zb3VyY2VTcGFuLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eShib3VuZFByb3BlcnR5TmFtZSwgYmluZGluZ1R5cGUsIHNlY3VyaXR5Q29udGV4dHNbMF0sIGJvdW5kUHJvcC5leHByZXNzaW9uLCB1bml0LCBib3VuZFByb3Auc291cmNlU3BhbiwgYm91bmRQcm9wLmtleVNwYW4sIGJvdW5kUHJvcC52YWx1ZVNwYW4pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBrZXlTcGFuIHNob3VsZCBiZSByZXF1aXJlZCBidXQgd2FzIG1hZGUgb3B0aW9uYWwgdG8gYXZvaWQgY2hhbmdpbmcgVkUgcGFyc2VyLlxuICAgIHBhcnNlRXZlbnQobmFtZSwgZXhwcmVzc2lvbiwgaXNBc3NpZ25tZW50RXZlbnQsIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzLCBrZXlTcGFuKSB7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYEV2ZW50IG5hbWUgaXMgbWlzc2luZyBpbiBiaW5kaW5nYCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEpO1xuICAgICAgICAgICAgaWYgKGtleVNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGtleVNwYW4gPSBtb3ZlUGFyc2VTb3VyY2VTcGFuKGtleVNwYW4sIG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oa2V5U3Bhbi5zdGFydC5vZmZzZXQgKyAxLCBrZXlTcGFuLmVuZC5vZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uRXZlbnQobmFtZSwgZXhwcmVzc2lvbiwgaXNBc3NpZ25tZW50RXZlbnQsIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCB0YXJnZXRFdmVudHMsIGtleVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VSZWd1bGFyRXZlbnQobmFtZSwgZXhwcmVzc2lvbiwgaXNBc3NpZ25tZW50RXZlbnQsIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzLCBrZXlTcGFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHNlbGVjdG9yLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LmdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKTtcbiAgICAgICAgcmV0dXJuIGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIHNlbGVjdG9yLCBwcm9wLCBpc0F0dHJpYnV0ZSk7XG4gICAgfVxuICAgIF9wYXJzZUFuaW1hdGlvbkV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIGlzQXNzaWdubWVudEV2ZW50LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0RXZlbnRzLCBrZXlTcGFuKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBzcGxpdEF0UGVyaW9kKG5hbWUsIFtuYW1lLCAnJ10pO1xuICAgICAgICBjb25zdCBldmVudE5hbWUgPSBtYXRjaGVzWzBdO1xuICAgICAgICBjb25zdCBwaGFzZSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgaXNBc3NpZ25tZW50RXZlbnQsIGhhbmRsZXJTcGFuKTtcbiAgICAgICAgdGFyZ2V0RXZlbnRzLnB1c2gobmV3IFBhcnNlZEV2ZW50KGV2ZW50TmFtZSwgcGhhc2UsIDEgLyogUGFyc2VkRXZlbnRUeXBlLkFuaW1hdGlvbiAqLywgYXN0LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3Bhbiwga2V5U3BhbikpO1xuICAgICAgICBpZiAoZXZlbnROYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYEFuaW1hdGlvbiBldmVudCBuYW1lIGlzIG1pc3NpbmcgaW4gYmluZGluZ2AsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaGFzZSkge1xuICAgICAgICAgICAgaWYgKHBoYXNlICE9PSAnc3RhcnQnICYmIHBoYXNlICE9PSAnZG9uZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgVGhlIHByb3ZpZGVkIGFuaW1hdGlvbiBvdXRwdXQgcGhhc2UgdmFsdWUgXCIke3BoYXNlfVwiIGZvciBcIkAke2V2ZW50TmFtZX1cIiBpcyBub3Qgc3VwcG9ydGVkICh1c2Ugc3RhcnQgb3IgZG9uZSlgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBUaGUgYW5pbWF0aW9uIHRyaWdnZXIgb3V0cHV0IGV2ZW50IChAJHtldmVudE5hbWV9KSBpcyBtaXNzaW5nIGl0cyBwaGFzZSB2YWx1ZSBuYW1lIChzdGFydCBvciBkb25lIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkKWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wYXJzZVJlZ3VsYXJFdmVudChuYW1lLCBleHByZXNzaW9uLCBpc0Fzc2lnbm1lbnRFdmVudCwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRFdmVudHMsIGtleVNwYW4pIHtcbiAgICAgICAgLy8gbG9uZyBmb3JtYXQ6ICd0YXJnZXQ6IGV2ZW50TmFtZSdcbiAgICAgICAgY29uc3QgW3RhcmdldCwgZXZlbnROYW1lXSA9IHNwbGl0QXRDb2xvbihuYW1lLCBbbnVsbCwgbmFtZV0pO1xuICAgICAgICBjb25zdCBhc3QgPSB0aGlzLl9wYXJzZUFjdGlvbihleHByZXNzaW9uLCBpc0Fzc2lnbm1lbnRFdmVudCwgaGFuZGxlclNwYW4pO1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBQYXJzZWRFdmVudChldmVudE5hbWUsIHRhcmdldCwgMCAvKiBQYXJzZWRFdmVudFR5cGUuUmVndWxhciAqLywgYXN0LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3Bhbiwga2V5U3BhbikpO1xuICAgICAgICAvLyBEb24ndCBkZXRlY3QgZGlyZWN0aXZlcyBmb3IgZXZlbnQgbmFtZXMgZm9yIG5vdyxcbiAgICAgICAgLy8gc28gZG9uJ3QgYWRkIHRoZSBldmVudCBuYW1lIHRvIHRoZSBtYXRjaGFibGVBdHRyc1xuICAgIH1cbiAgICBfcGFyc2VBY3Rpb24odmFsdWUsIGlzQXNzaWdubWVudEV2ZW50LCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUluZm8gPSAoc291cmNlU3BhbiAmJiBzb3VyY2VTcGFuLnN0YXJ0IHx8ICcodW5rbm93bicpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGFic29sdXRlT2Zmc2V0ID0gKHNvdXJjZVNwYW4gJiYgc291cmNlU3Bhbi5zdGFydCkgPyBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldCA6IDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhc3QgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlQWN0aW9uKHZhbHVlLCBpc0Fzc2lnbm1lbnRFdmVudCwgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQsIHRoaXMuX2ludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICAgICAgaWYgKGFzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFzdCB8fCBhc3QuYXN0IGluc3RhbmNlb2YgRW1wdHlFeHByKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYEVtcHR5IGV4cHJlc3Npb25zIGFyZSBub3QgYWxsb3dlZGAsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9leHByUGFyc2VyLndyYXBMaXRlcmFsUHJpbWl0aXZlKCdFUlJPUicsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGAke2V9YCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlcG9ydEVycm9yKG1lc3NhZ2UsIHNvdXJjZVNwYW4sIGxldmVsID0gZXhwb3J0cy5QYXJzZUVycm9yTGV2ZWwuRVJST1IpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VFcnJvcihzb3VyY2VTcGFuLCBtZXNzYWdlLCBsZXZlbCkpO1xuICAgIH1cbiAgICBfcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhlcnJvcnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgZm9yIChjb25zdCBlcnJvciBvZiBlcnJvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVycm9yLm1lc3NhZ2UsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBwcm9wTmFtZSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgLyBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gc291cmNlU3BhblxuICAgICAqIEBwYXJhbSBpc0F0dHIgdHJ1ZSB3aGVuIGJpbmRpbmcgdG8gYW4gYXR0cmlidXRlXG4gICAgICovXG4gICAgX3ZhbGlkYXRlUHJvcGVydHlPckF0dHJpYnV0ZU5hbWUocHJvcE5hbWUsIHNvdXJjZVNwYW4sIGlzQXR0cikge1xuICAgICAgICBjb25zdCByZXBvcnQgPSBpc0F0dHIgPyB0aGlzLl9zY2hlbWFSZWdpc3RyeS52YWxpZGF0ZUF0dHJpYnV0ZShwcm9wTmFtZSkgOlxuICAgICAgICAgICAgdGhpcy5fc2NoZW1hUmVnaXN0cnkudmFsaWRhdGVQcm9wZXJ0eShwcm9wTmFtZSk7XG4gICAgICAgIGlmIChyZXBvcnQuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKHJlcG9ydC5tc2csIHNvdXJjZVNwYW4sIGV4cG9ydHMuUGFyc2VFcnJvckxldmVsLkVSUk9SKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQW5pbWF0aW9uTGFiZWwobmFtZSkge1xuICAgIHJldHVybiBuYW1lWzBdID09ICdAJztcbn1cbmZ1bmN0aW9uIGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHMocmVnaXN0cnksIHNlbGVjdG9yLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBjdHhzID0gW107XG4gICAgQ3NzU2VsZWN0b3IucGFyc2Uoc2VsZWN0b3IpLmZvckVhY2goKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnROYW1lcyA9IHNlbGVjdG9yLmVsZW1lbnQgPyBbc2VsZWN0b3IuZWxlbWVudF0gOiByZWdpc3RyeS5hbGxLbm93bkVsZW1lbnROYW1lcygpO1xuICAgICAgICBjb25zdCBub3RFbGVtZW50TmFtZXMgPSBuZXcgU2V0KHNlbGVjdG9yLm5vdFNlbGVjdG9ycy5maWx0ZXIoc2VsZWN0b3IgPT4gc2VsZWN0b3IuaXNFbGVtZW50U2VsZWN0b3IoKSlcbiAgICAgICAgICAgIC5tYXAoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5lbGVtZW50KSk7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlRWxlbWVudE5hbWVzID0gZWxlbWVudE5hbWVzLmZpbHRlcihlbGVtZW50TmFtZSA9PiAhbm90RWxlbWVudE5hbWVzLmhhcyhlbGVtZW50TmFtZSkpO1xuICAgICAgICBjdHhzLnB1c2goLi4ucG9zc2libGVFbGVtZW50TmFtZXMubWFwKGVsZW1lbnROYW1lID0+IHJlZ2lzdHJ5LnNlY3VyaXR5Q29udGV4dChlbGVtZW50TmFtZSwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjdHhzLmxlbmd0aCA9PT0gMCA/IFtTZWN1cml0eUNvbnRleHQuTk9ORV0gOiBBcnJheS5mcm9tKG5ldyBTZXQoY3R4cykpLnNvcnQoKTtcbn1cbi8qKlxuICogQ29tcHV0ZSBhIG5ldyBQYXJzZVNvdXJjZVNwYW4gYmFzZWQgb2ZmIGFuIG9yaWdpbmFsIGBzb3VyY2VTcGFuYCBieSB1c2luZ1xuICogYWJzb2x1dGUgb2Zmc2V0cyBmcm9tIHRoZSBzcGVjaWZpZWQgYGFic29sdXRlU3BhbmAuXG4gKlxuICogQHBhcmFtIHNvdXJjZVNwYW4gb3JpZ2luYWwgc291cmNlIHNwYW5cbiAqIEBwYXJhbSBhYnNvbHV0ZVNwYW4gYWJzb2x1dGUgc291cmNlIHNwYW4gdG8gbW92ZSB0b1xuICovXG5mdW5jdGlvbiBtb3ZlUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4sIGFic29sdXRlU3Bhbikge1xuICAgIC8vIFRoZSBkaWZmZXJlbmNlIG9mIHR3byBhYnNvbHV0ZSBvZmZzZXRzIHByb3ZpZGUgdGhlIHJlbGF0aXZlIG9mZnNldFxuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGFic29sdXRlU3Bhbi5zdGFydCAtIHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgIGNvbnN0IGVuZERpZmYgPSBhYnNvbHV0ZVNwYW4uZW5kIC0gc291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KHN0YXJ0RGlmZiksIHNvdXJjZVNwYW4uZW5kLm1vdmVCeShlbmREaWZmKSwgc291cmNlU3Bhbi5mdWxsU3RhcnQubW92ZUJ5KHN0YXJ0RGlmZiksIHNvdXJjZVNwYW4uZGV0YWlscyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gU29tZSBvZiB0aGUgY29kZSBjb21lcyBmcm9tIFdlYkNvbXBvbmVudHMuSlNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy9ibG9iL21hc3Rlci9zcmMvSFRNTEltcG9ydHMvcGF0aC5qc1xuZnVuY3Rpb24gaXNTdHlsZVVybFJlc29sdmFibGUodXJsKSB7XG4gICAgaWYgKHVybCA9PSBudWxsIHx8IHVybC5sZW5ndGggPT09IDAgfHwgdXJsWzBdID09ICcvJylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHNjaGVtZU1hdGNoID0gdXJsLm1hdGNoKFVSTF9XSVRIX1NDSEVNQV9SRUdFWFApO1xuICAgIHJldHVybiBzY2hlbWVNYXRjaCA9PT0gbnVsbCB8fCBzY2hlbWVNYXRjaFsxXSA9PSAncGFja2FnZScgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ2Fzc2V0Jztcbn1cbmNvbnN0IFVSTF9XSVRIX1NDSEVNQV9SRUdFWFAgPSAvXihbXjovPyNdKyk6LztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBOR19DT05URU5UX1NFTEVDVF9BVFRSJDEgPSAnc2VsZWN0JztcbmNvbnN0IExJTktfRUxFTUVOVCA9ICdsaW5rJztcbmNvbnN0IExJTktfU1RZTEVfUkVMX0FUVFIgPSAncmVsJztcbmNvbnN0IExJTktfU1RZTEVfSFJFRl9BVFRSID0gJ2hyZWYnO1xuY29uc3QgTElOS19TVFlMRV9SRUxfVkFMVUUgPSAnc3R5bGVzaGVldCc7XG5jb25zdCBTVFlMRV9FTEVNRU5UID0gJ3N0eWxlJztcbmNvbnN0IFNDUklQVF9FTEVNRU5UID0gJ3NjcmlwdCc7XG5jb25zdCBOR19OT05fQklOREFCTEVfQVRUUiA9ICduZ05vbkJpbmRhYmxlJztcbmNvbnN0IE5HX1BST0pFQ1RfQVMgPSAnbmdQcm9qZWN0QXMnO1xuZnVuY3Rpb24gcHJlcGFyc2VFbGVtZW50KGFzdCkge1xuICAgIGxldCBzZWxlY3RBdHRyID0gbnVsbDtcbiAgICBsZXQgaHJlZkF0dHIgPSBudWxsO1xuICAgIGxldCByZWxBdHRyID0gbnVsbDtcbiAgICBsZXQgbm9uQmluZGFibGUgPSBmYWxzZTtcbiAgICBsZXQgcHJvamVjdEFzID0gJyc7XG4gICAgYXN0LmF0dHJzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgIGNvbnN0IGxjQXR0ck5hbWUgPSBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGxjQXR0ck5hbWUgPT0gTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUiQxKSB7XG4gICAgICAgICAgICBzZWxlY3RBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfSFJFRl9BVFRSKSB7XG4gICAgICAgICAgICBocmVmQXR0ciA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGNBdHRyTmFtZSA9PSBMSU5LX1NUWUxFX1JFTF9BVFRSKSB7XG4gICAgICAgICAgICByZWxBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfTk9OX0JJTkRBQkxFX0FUVFIpIHtcbiAgICAgICAgICAgIG5vbkJpbmRhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUgPT0gTkdfUFJPSkVDVF9BUykge1xuICAgICAgICAgICAgaWYgKGF0dHIudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHByb2plY3RBcyA9IGF0dHIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzZWxlY3RBdHRyID0gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpO1xuICAgIGNvbnN0IG5vZGVOYW1lID0gYXN0Lm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk9USEVSO1xuICAgIGlmIChpc05nQ29udGVudChub2RlTmFtZSkpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLk5HX0NPTlRFTlQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNUWUxFX0VMRU1FTlQpIHtcbiAgICAgICAgdHlwZSA9IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBTQ1JJUFRfRUxFTUVOVCkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlTmFtZSA9PSBMSU5LX0VMRU1FTlQgJiYgcmVsQXR0ciA9PSBMSU5LX1NUWUxFX1JFTF9WQUxVRSkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEVTSEVFVDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcmVwYXJzZWRFbGVtZW50KHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKTtcbn1cbnZhciBQcmVwYXJzZWRFbGVtZW50VHlwZTtcbihmdW5jdGlvbiAoUHJlcGFyc2VkRWxlbWVudFR5cGUpIHtcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIk5HX0NPTlRFTlRcIl0gPSAwXSA9IFwiTkdfQ09OVEVOVFwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU1RZTEVcIl0gPSAxXSA9IFwiU1RZTEVcIjtcbiAgICBQcmVwYXJzZWRFbGVtZW50VHlwZVtQcmVwYXJzZWRFbGVtZW50VHlwZVtcIlNUWUxFU0hFRVRcIl0gPSAyXSA9IFwiU1RZTEVTSEVFVFwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU0NSSVBUXCJdID0gM10gPSBcIlNDUklQVFwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiT1RIRVJcIl0gPSA0XSA9IFwiT1RIRVJcIjtcbn0pKFByZXBhcnNlZEVsZW1lbnRUeXBlIHx8IChQcmVwYXJzZWRFbGVtZW50VHlwZSA9IHt9KSk7XG5jbGFzcyBQcmVwYXJzZWRFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBzZWxlY3RBdHRyLCBocmVmQXR0ciwgbm9uQmluZGFibGUsIHByb2plY3RBcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNlbGVjdEF0dHIgPSBzZWxlY3RBdHRyO1xuICAgICAgICB0aGlzLmhyZWZBdHRyID0gaHJlZkF0dHI7XG4gICAgICAgIHRoaXMubm9uQmluZGFibGUgPSBub25CaW5kYWJsZTtcbiAgICAgICAgdGhpcy5wcm9qZWN0QXMgPSBwcm9qZWN0QXM7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplTmdDb250ZW50U2VsZWN0KHNlbGVjdEF0dHIpIHtcbiAgICBpZiAoc2VsZWN0QXR0ciA9PT0gbnVsbCB8fCBzZWxlY3RBdHRyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyonO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0QXR0cjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBCSU5EX05BTUVfUkVHRVhQID0gL14oPzooYmluZC0pfChsZXQtKXwocmVmLXwjKXwob24tKXwoYmluZG9uLSl8KEApKSguKikkLztcbi8vIEdyb3VwIDEgPSBcImJpbmQtXCJcbmNvbnN0IEtXX0JJTkRfSURYID0gMTtcbi8vIEdyb3VwIDIgPSBcImxldC1cIlxuY29uc3QgS1dfTEVUX0lEWCA9IDI7XG4vLyBHcm91cCAzID0gXCJyZWYtLyNcIlxuY29uc3QgS1dfUkVGX0lEWCA9IDM7XG4vLyBHcm91cCA0ID0gXCJvbi1cIlxuY29uc3QgS1dfT05fSURYID0gNDtcbi8vIEdyb3VwIDUgPSBcImJpbmRvbi1cIlxuY29uc3QgS1dfQklORE9OX0lEWCA9IDU7XG4vLyBHcm91cCA2ID0gXCJAXCJcbmNvbnN0IEtXX0FUX0lEWCA9IDY7XG4vLyBHcm91cCA3ID0gdGhlIGlkZW50aWZpZXIgYWZ0ZXIgXCJiaW5kLVwiLCBcImxldC1cIiwgXCJyZWYtLyNcIiwgXCJvbi1cIiwgXCJiaW5kb24tXCIgb3IgXCJAXCJcbmNvbnN0IElERU5UX0tXX0lEWCA9IDc7XG5jb25zdCBCSU5ESU5HX0RFTElNUyA9IHtcbiAgICBCQU5BTkFfQk9YOiB7IHN0YXJ0OiAnWygnLCBlbmQ6ICcpXScgfSxcbiAgICBQUk9QRVJUWTogeyBzdGFydDogJ1snLCBlbmQ6ICddJyB9LFxuICAgIEVWRU5UOiB7IHN0YXJ0OiAnKCcsIGVuZDogJyknIH0sXG59O1xuY29uc3QgVEVNUExBVEVfQVRUUl9QUkVGSVggPSAnKic7XG5mdW5jdGlvbiBodG1sQXN0VG9SZW5kZXIzQXN0KGh0bWxOb2RlcywgYmluZGluZ1BhcnNlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gbmV3IEh0bWxBc3RUb0l2eUFzdChiaW5kaW5nUGFyc2VyLCBvcHRpb25zKTtcbiAgICBjb25zdCBpdnlOb2RlcyA9IHZpc2l0QWxsKHRyYW5zZm9ybWVyLCBodG1sTm9kZXMpO1xuICAgIC8vIEVycm9ycyBtaWdodCBvcmlnaW5hdGUgaW4gZWl0aGVyIHRoZSBiaW5kaW5nIHBhcnNlciBvciB0aGUgaHRtbCB0byBpdnkgdHJhbnNmb3JtZXJcbiAgICBjb25zdCBhbGxFcnJvcnMgPSBiaW5kaW5nUGFyc2VyLmVycm9ycy5jb25jYXQodHJhbnNmb3JtZXIuZXJyb3JzKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5vZGVzOiBpdnlOb2RlcyxcbiAgICAgICAgZXJyb3JzOiBhbGxFcnJvcnMsXG4gICAgICAgIHN0eWxlVXJsczogdHJhbnNmb3JtZXIuc3R5bGVVcmxzLFxuICAgICAgICBzdHlsZXM6IHRyYW5zZm9ybWVyLnN0eWxlcyxcbiAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB0cmFuc2Zvcm1lci5uZ0NvbnRlbnRTZWxlY3RvcnNcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMpIHtcbiAgICAgICAgcmVzdWx0LmNvbW1lbnROb2RlcyA9IHRyYW5zZm9ybWVyLmNvbW1lbnROb2RlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIEh0bWxBc3RUb0l2eUFzdCB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZ1BhcnNlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIgPSBiaW5kaW5nUGFyc2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICAvLyBUaGlzIGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIGlmIGBSZW5kZXIzUGFyc2VPcHRpb25zWydjb2xsZWN0Q29tbWVudE5vZGVzJ11gIGlzIHRydWVcbiAgICAgICAgdGhpcy5jb21tZW50Tm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBIVE1MIHZpc2l0b3JcbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBpc0kxOG5Sb290RWxlbWVudCA9IGlzSTE4blJvb3ROb2RlKGVsZW1lbnQuaTE4bik7XG4gICAgICAgIGlmIChpc0kxOG5Sb290RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdDYW5ub3QgbWFyayBhbiBlbGVtZW50IGFzIHRyYW5zbGF0YWJsZSBpbnNpZGUgb2YgYSB0cmFuc2xhdGFibGUgc2VjdGlvbi4gUGxlYXNlIHJlbW92ZSB0aGUgbmVzdGVkIGkxOG4gbWFya2VyLicsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluSTE4bkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGV4dENvbnRlbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaChjb250ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQgJiZcbiAgICAgICAgICAgIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlVXJscy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hldGhlciB0aGUgZWxlbWVudCBpcyBhIGA8bmctdGVtcGxhdGU+YFxuICAgICAgICBjb25zdCBpc1RlbXBsYXRlRWxlbWVudCA9IGlzTmdUZW1wbGF0ZShlbGVtZW50Lm5hbWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRQcm9wZXJ0aWVzID0gW107XG4gICAgICAgIGNvbnN0IGJvdW5kRXZlbnRzID0gW107XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtdO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gW107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgaTE4bkF0dHJzTWV0YSA9IHt9O1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZVBhcnNlZFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgLy8gV2hldGhlciB0aGUgZWxlbWVudCBoYXMgYW55ICotYXR0cmlidXRlXG4gICAgICAgIGxldCBlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgZWxlbWVudC5hdHRycykge1xuICAgICAgICAgICAgbGV0IGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAvLyBgKmF0dHJgIGRlZmluZXMgdGVtcGxhdGUgYmluZGluZ3NcbiAgICAgICAgICAgIGxldCBpc1RlbXBsYXRlQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pMThuKSB7XG4gICAgICAgICAgICAgICAgaTE4bkF0dHJzTWV0YVthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUuaTE4bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkTmFtZS5zdGFydHNXaXRoKFRFTVBMQVRFX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIC8vICotYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgQ2FuJ3QgaGF2ZSBtdWx0aXBsZSB0ZW1wbGF0ZSBiaW5kaW5ncyBvbiBvbmUgZWxlbWVudC4gVXNlIG9ubHkgb25lIGF0dHJpYnV0ZSBwcmVmaXhlZCB3aXRoICpgLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzVGVtcGxhdGVCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVLZXkgPSBub3JtYWxpemVkTmFtZS5zdWJzdHJpbmcoVEVNUExBVEVfQVRUUl9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBhYnNvbHV0ZVZhbHVlT2Zmc2V0ID0gYXR0cmlidXRlLnZhbHVlU3BhbiA/XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0IDpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdmFsdWUgc3BhbiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGhhdmUgYSB2YWx1ZSwgbGlrZSBgYXR0cmAgaW5cbiAgICAgICAgICAgICAgICAgICAgLy9gPGRpdiBhdHRyPjwvZGl2PmAuIEluIHRoaXMgY2FzZSwgcG9pbnQgdG8gb25lIGNoYXJhY3RlciBiZXlvbmQgdGhlIGxhc3QgY2hhcmFjdGVyIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0ICsgYXR0cmlidXRlLm5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyh0ZW1wbGF0ZUtleSwgdGVtcGxhdGVWYWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4sIGFic29sdXRlVmFsdWVPZmZzZXQsIFtdLCB0ZW1wbGF0ZVBhcnNlZFByb3BlcnRpZXMsIHBhcnNlZFZhcmlhYmxlcywgdHJ1ZSAvKiBpc0l2eUFzdCAqLyk7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVWYXJpYWJsZXMucHVzaCguLi5wYXJzZWRWYXJpYWJsZXMubWFwKHYgPT4gbmV3IFZhcmlhYmxlKHYubmFtZSwgdi52YWx1ZSwgdi5zb3VyY2VTcGFuLCB2LmtleVNwYW4sIHYudmFsdWVTcGFuKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHZhcmlhYmxlcywgZXZlbnRzLCBwcm9wZXJ0eSBiaW5kaW5ncywgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLnBhcnNlQXR0cmlidXRlKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyaWJ1dGUsIFtdLCBwYXJzZWRQcm9wZXJ0aWVzLCBib3VuZEV2ZW50cywgdmFyaWFibGVzLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaXNUZW1wbGF0ZUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaCh0aGlzLnZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdmlzaXRBbGwocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSA/IE5PTl9CSU5EQUJMRV9WSVNJVE9SIDogdGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGxldCBwYXJzZWRFbGVtZW50O1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UKSB7XG4gICAgICAgICAgICAvLyBgPG5nLWNvbnRlbnQ+YFxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4gJiZcbiAgICAgICAgICAgICAgICAhZWxlbWVudC5jaGlsZHJlbi5ldmVyeSgobm9kZSkgPT4gaXNFbXB0eVRleHROb2RlKG5vZGUpIHx8IGlzQ29tbWVudE5vZGUobm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgPG5nLWNvbnRlbnQ+IGVsZW1lbnQgY2Fubm90IGhhdmUgY29udGVudC5gLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBwcmVwYXJzZWRFbGVtZW50LnNlbGVjdEF0dHI7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IGVsZW1lbnQuYXR0cnMubWFwKGF0dHIgPT4gdGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IENvbnRlbnQoc2VsZWN0b3IsIGF0dHJzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gYDxuZy10ZW1wbGF0ZT5gXG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHRoaXMuZXh0cmFjdEF0dHJpYnV0ZXMoZWxlbWVudC5uYW1lLCBwYXJzZWRQcm9wZXJ0aWVzLCBpMThuQXR0cnNNZXRhKTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgVGVtcGxhdGUoZWxlbWVudC5uYW1lLCBhdHRyaWJ1dGVzLCBhdHRycy5ib3VuZCwgYm91bmRFdmVudHMsIFsgLyogbm8gdGVtcGxhdGUgYXR0cmlidXRlcyAqL10sIGNoaWxkcmVuLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3BhbiwgZWxlbWVudC5pMThuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gdGhpcy5leHRyYWN0QXR0cmlidXRlcyhlbGVtZW50Lm5hbWUsIHBhcnNlZFByb3BlcnRpZXMsIGkxOG5BdHRyc01ldGEpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50JDEoZWxlbWVudC5uYW1lLCBhdHRyaWJ1dGVzLCBhdHRycy5ib3VuZCwgYm91bmRFdmVudHMsIGNoaWxkcmVuLCByZWZlcmVuY2VzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRIYXNJbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBub2RlIGlzIGFuIGlubGluZS10ZW1wbGF0ZSAoZS5nLiBoYXMgKm5nRm9yKSB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlIGEgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIG5vZGUgdGhhdCBjb250YWlucyB0aGlzIG5vZGUuXG4gICAgICAgICAgICAvLyBNb3Jlb3ZlciwgaWYgdGhlIG5vZGUgaXMgYW4gZWxlbWVudCwgdGhlbiB3ZSBuZWVkIHRvIGhvaXN0IGl0cyBhdHRyaWJ1dGVzIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gbm9kZSBmb3IgbWF0Y2hpbmcgYWdhaW5zdCBjb250ZW50IHByb2plY3Rpb24gc2VsZWN0b3JzLlxuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSB0aGlzLmV4dHJhY3RBdHRyaWJ1dGVzKCduZy10ZW1wbGF0ZScsIHRlbXBsYXRlUGFyc2VkUHJvcGVydGllcywgaTE4bkF0dHJzTWV0YSk7XG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZUF0dHJzID0gW107XG4gICAgICAgICAgICBhdHRycy5saXRlcmFsLmZvckVhY2goYXR0ciA9PiB0ZW1wbGF0ZUF0dHJzLnB1c2goYXR0cikpO1xuICAgICAgICAgICAgYXR0cnMuYm91bmQuZm9yRWFjaChhdHRyID0+IHRlbXBsYXRlQXR0cnMucHVzaChhdHRyKSk7XG4gICAgICAgICAgICBjb25zdCBob2lzdGVkQXR0cnMgPSBwYXJzZWRFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCQxID9cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHBhcnNlZEVsZW1lbnQuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBwYXJzZWRFbGVtZW50LmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogcGFyc2VkRWxlbWVudC5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIHsgYXR0cmlidXRlczogW10sIGlucHV0czogW10sIG91dHB1dHM6IFtdIH07XG4gICAgICAgICAgICAvLyBGb3IgPG5nLXRlbXBsYXRlPnMgd2l0aCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgb24gdGhlbSwgYXZvaWQgcGFzc2luZyBpMThuIGluZm9ybWF0aW9uIHRvXG4gICAgICAgICAgICAvLyB0aGUgd3JhcHBpbmcgdGVtcGxhdGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBpMThuIGluc3RydWN0aW9ucyBmcm9tIGJlaW5nIGdlbmVyYXRlZC4gVGhlXG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgaTE4biBtZXRhIGluZm9ybWF0aW9uIHdpbGwgYmUgZXh0cmFjdGVkIGZyb20gY2hpbGQgZWxlbWVudHMuXG4gICAgICAgICAgICBjb25zdCBpMThuID0gaXNUZW1wbGF0ZUVsZW1lbnQgJiYgaXNJMThuUm9vdEVsZW1lbnQgPyB1bmRlZmluZWQgOiBlbGVtZW50LmkxOG47XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gcGFyc2VkRWxlbWVudCBpbnN0YW5jZW9mIFRlbXBsYXRlID8gbnVsbCA6IHBhcnNlZEVsZW1lbnQubmFtZTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgVGVtcGxhdGUobmFtZSwgaG9pc3RlZEF0dHJzLmF0dHJpYnV0ZXMsIGhvaXN0ZWRBdHRycy5pbnB1dHMsIGhvaXN0ZWRBdHRycy5vdXRwdXRzLCB0ZW1wbGF0ZUF0dHJzLCBbcGFyc2VkRWxlbWVudF0sIFsgLyogbm8gcmVmZXJlbmNlcyAqL10sIHRlbXBsYXRlVmFyaWFibGVzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0kxOG5Sb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRFbGVtZW50O1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuLCBhdHRyaWJ1dGUua2V5U3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgYXR0cmlidXRlLmkxOG4pO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuLCB0ZXh0LnRva2VucywgdGV4dC5pMThuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uKSB7XG4gICAgICAgIGlmICghZXhwYW5zaW9uLmkxOG4pIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdCBnZW5lcmF0ZSBJY3UgaW4gY2FzZSBpdCB3YXMgY3JlYXRlZFxuICAgICAgICAgICAgLy8gb3V0c2lkZSBvZiBpMThuIGJsb2NrIGluIGEgdGVtcGxhdGVcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNJMThuUm9vdE5vZGUoZXhwYW5zaW9uLmkxOG4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHlwZSBcIiR7ZXhwYW5zaW9uLmkxOG4uY29uc3RydWN0b3J9XCIgZm9yIFwiaTE4blwiIHByb3BlcnR5IG9mICR7ZXhwYW5zaW9uLnNvdXJjZVNwYW4udG9TdHJpbmcoKX0uIEV4cGVjdGVkIGEgXCJNZXNzYWdlXCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXhwYW5zaW9uLmkxOG47XG4gICAgICAgIGNvbnN0IHZhcnMgPSB7fTtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJzID0ge307XG4gICAgICAgIC8vIGV4dHJhY3QgVkFScyBmcm9tIElDVXMgLSB3ZSBwcm9jZXNzIHRoZW0gc2VwYXJhdGVseSB3aGlsZVxuICAgICAgICAvLyBhc3NlbWJsaW5nIHJlc3VsdGluZyBtZXNzYWdlIHZpYSBnb29nLmdldE1zZyBmdW5jdGlvbiwgc2luY2VcbiAgICAgICAgLy8gd2UgbmVlZCB0byBwYXNzIHRoZW0gdG8gdG9wLWxldmVsIGdvb2cuZ2V0TXNnIGNhbGxcbiAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZS5wbGFjZWhvbGRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWVzc2FnZS5wbGFjZWhvbGRlcnNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChJMThOX0lDVV9WQVJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIC8vIEN1cnJlbnRseSB3aGVuIHRoZSBgcGx1cmFsYCBvciBgc2VsZWN0YCBrZXl3b3JkcyBpbiBhbiBJQ1UgY29udGFpbiB0cmFpbGluZyBzcGFjZXMgKGUuZy5cbiAgICAgICAgICAgICAgICAvLyBge2NvdW50LCBzZWxlY3QgLCAuLi59YCksIHRoZXNlIHNwYWNlcyBhcmUgYWxzbyBpbmNsdWRlZCBpbnRvIHRoZSBrZXkgbmFtZXMgaW4gSUNVIHZhcnNcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBcIlZBUl9TRUxFQ1QgXCIpLiBUaGVzZSB0cmFpbGluZyBzcGFjZXMgYXJlIG5vdCBkZXNpcmFibGUsIHNpbmNlIHRoZXkgd2lsbCBsYXRlciBiZVxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRlZCBpbnRvIGBfYCBzeW1ib2xzIHdoaWxlIG5vcm1hbGl6aW5nIHBsYWNlaG9sZGVyIG5hbWVzLCB3aGljaCBtaWdodCBsZWFkIHRvXG4gICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2hlcyBhdCBydW50aW1lIChpLmUuIHBsYWNlaG9sZGVyIHdpbGwgbm90IGJlIHJlcGxhY2VkIHdpdGggdGhlIGNvcnJlY3QgdmFsdWUpLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZEtleSA9IGtleS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24odmFsdWUudGV4dCwgdmFsdWUuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgdmFyc1tmb3JtYXR0ZWRLZXldID0gbmV3IEJvdW5kVGV4dChhc3QsIHZhbHVlLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJzW2tleV0gPSB0aGlzLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbih2YWx1ZS50ZXh0LCB2YWx1ZS5zb3VyY2VTcGFuLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1JDEodmFycywgcGxhY2Vob2xkZXJzLCBleHBhbnNpb24uc291cmNlU3BhbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShleHBhbnNpb25DYXNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWVudE5vZGVzLnB1c2gobmV3IENvbW1lbnQkMShjb21tZW50LnZhbHVlIHx8ICcnLCBjb21tZW50LnNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gY29udmVydCB2aWV3IGVuZ2luZSBgUGFyc2VkUHJvcGVydHlgIHRvIGEgZm9ybWF0IHN1aXRhYmxlIGZvciBJVllcbiAgICBleHRyYWN0QXR0cmlidXRlcyhlbGVtZW50TmFtZSwgcHJvcGVydGllcywgaTE4blByb3BzTWV0YSkge1xuICAgICAgICBjb25zdCBib3VuZCA9IFtdO1xuICAgICAgICBjb25zdCBsaXRlcmFsID0gW107XG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGkxOG4gPSBpMThuUHJvcHNNZXRhW3Byb3AubmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcC5pc0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsLnB1c2gobmV3IFRleHRBdHRyaWJ1dGUocHJvcC5uYW1lLCBwcm9wLmV4cHJlc3Npb24uc291cmNlIHx8ICcnLCBwcm9wLnNvdXJjZVNwYW4sIHByb3Aua2V5U3BhbiwgcHJvcC52YWx1ZVNwYW4sIGkxOG4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB2YWxpZGF0aW9uIGlzIHNraXBwZWQgYW5kIHByb3BlcnR5IG1hcHBpbmcgaXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAvLyBkdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBhIGdpdmVuIHByb3AgaXMgbm90IGFuXG4gICAgICAgICAgICAgICAgLy8gaW5wdXQgb2YgYSBkaXJlY3RpdmUgYW5kIGRpcmVjdGl2ZSBtYXRjaGluZyBoYXBwZW5zIGF0IHJ1bnRpbWUuXG4gICAgICAgICAgICAgICAgY29uc3QgYmVwID0gdGhpcy5iaW5kaW5nUGFyc2VyLmNyZWF0ZUJvdW5kRWxlbWVudFByb3BlcnR5KGVsZW1lbnROYW1lLCBwcm9wLCAvKiBza2lwVmFsaWRhdGlvbiAqLyB0cnVlLCAvKiBtYXBQcm9wZXJ0eU5hbWUgKi8gZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJvdW5kLnB1c2goQm91bmRBdHRyaWJ1dGUuZnJvbUJvdW5kRWxlbWVudFByb3BlcnR5KGJlcCwgaTE4bikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgYm91bmQsIGxpdGVyYWwgfTtcbiAgICB9XG4gICAgcGFyc2VBdHRyaWJ1dGUoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHJpYnV0ZSwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywgYm91bmRFdmVudHMsIHZhcmlhYmxlcywgcmVmZXJlbmNlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgIGNvbnN0IHNyY1NwYW4gPSBhdHRyaWJ1dGUuc291cmNlU3BhbjtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVPZmZzZXQgPSBhdHRyaWJ1dGUudmFsdWVTcGFuID8gYXR0cmlidXRlLnZhbHVlU3Bhbi5zdGFydC5vZmZzZXQgOiBzcmNTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCBwcmVmaXgsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYWRqdXN0IHRoZSBzdGFydCBsb2NhdGlvbiBmb3IgdGhlIGtleVNwYW4gdG8gYWNjb3VudCBmb3IgdGhlIHJlbW92ZWQgJ2RhdGEtJ1xuICAgICAgICAgICAgLy8gcHJlZml4IGZyb20gYG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWVgLlxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXphdGlvbkFkanVzdG1lbnQgPSBhdHRyaWJ1dGUubmFtZS5sZW5ndGggLSBuYW1lLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGtleVNwYW5TdGFydCA9IHNyY1NwYW4uc3RhcnQubW92ZUJ5KHByZWZpeC5sZW5ndGggKyBub3JtYWxpemF0aW9uQWRqdXN0bWVudCk7XG4gICAgICAgICAgICBjb25zdCBrZXlTcGFuRW5kID0ga2V5U3BhblN0YXJ0Lm1vdmVCeShpZGVudGlmaWVyLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihrZXlTcGFuU3RhcnQsIGtleVNwYW5FbmQsIGtleVNwYW5TdGFydCwgaWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmluZFBhcnRzID0gbmFtZS5tYXRjaChCSU5EX05BTUVfUkVHRVhQKTtcbiAgICAgICAgaWYgKGJpbmRQYXJ0cykge1xuICAgICAgICAgICAgaWYgKGJpbmRQYXJ0c1tLV19CSU5EX0lEWF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTcGFuID0gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCBiaW5kUGFydHNbS1dfQklORF9JRFhdLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoaWRlbnRpZmllciwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywga2V5U3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfTEVUX0lEWF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNUZW1wbGF0ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlTcGFuID0gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCBiaW5kUGFydHNbS1dfTEVUX0lEWF0sIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVmFyaWFibGUoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIGtleVNwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGBcImxldC1cIiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBuZy10ZW1wbGF0ZSBlbGVtZW50cy5gLCBzcmNTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfUkVGX0lEWF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5U3BhbiA9IGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgYmluZFBhcnRzW0tXX1JFRl9JRFhdLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlUmVmZXJlbmNlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCBrZXlTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19PTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVNwYW4gPSBjcmVhdGVLZXlTcGFuKHNyY1NwYW4sIGJpbmRQYXJ0c1tLV19PTl9JRFhdLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VFdmVudChpZGVudGlmaWVyLCB2YWx1ZSwgLyogaXNBc3NpZ25tZW50RXZlbnQgKi8gZmFsc2UsIHNyY1NwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4gfHwgc3JjU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgZXZlbnRzLCBrZXlTcGFuKTtcbiAgICAgICAgICAgICAgICBhZGRFdmVudHMoZXZlbnRzLCBib3VuZEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfQklORE9OX0lEWF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5U3BhbiA9IGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgYmluZFBhcnRzW0tXX0JJTkRPTl9JRFhdLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoaWRlbnRpZmllciwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywga2V5U3Bhbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUFzc2lnbm1lbnRFdmVudChpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgYm91bmRFdmVudHMsIGtleVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0FUX0lEWF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTcGFuID0gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCAnJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlTGl0ZXJhbEF0dHIobmFtZSwgdmFsdWUsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzLCBrZXlTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRpZG4ndCBzZWUgYSBrdy1wcmVmaXhlZCBwcm9wZXJ0eSBiaW5kaW5nLCBidXQgd2UgaGF2ZSBub3QgeWV0IGNoZWNrZWRcbiAgICAgICAgLy8gZm9yIHRoZSBbXS8oKS9bKCldIHN5bnRheC5cbiAgICAgICAgbGV0IGRlbGltcyA9IG51bGw7XG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoQklORElOR19ERUxJTVMuQkFOQU5BX0JPWC5zdGFydCkpIHtcbiAgICAgICAgICAgIGRlbGltcyA9IEJJTkRJTkdfREVMSU1TLkJBTkFOQV9CT1g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKEJJTkRJTkdfREVMSU1TLlBST1BFUlRZLnN0YXJ0KSkge1xuICAgICAgICAgICAgZGVsaW1zID0gQklORElOR19ERUxJTVMuUFJPUEVSVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKEJJTkRJTkdfREVMSU1TLkVWRU5ULnN0YXJ0KSkge1xuICAgICAgICAgICAgZGVsaW1zID0gQklORElOR19ERUxJTVMuRVZFTlQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGltcyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgLy8gTk9URTogb2xkZXIgdmVyc2lvbnMgb2YgdGhlIHBhcnNlciB3b3VsZCBtYXRjaCBhIHN0YXJ0L2VuZCBkZWxpbWl0ZWRcbiAgICAgICAgICAgIC8vIGJpbmRpbmcgaWZmIHRoZSBwcm9wZXJ0eSBuYW1lIHdhcyB0ZXJtaW5hdGVkIGJ5IHRoZSBlbmRpbmcgZGVsaW1pdGVyXG4gICAgICAgICAgICAvLyBhbmQgdGhlIGlkZW50aWZpZXIgaW4gdGhlIGJpbmRpbmcgd2FzIG5vbi1lbXB0eS5cbiAgICAgICAgICAgIC8vIFRPRE8oYXlhemhhZml6KTogdXBkYXRlIHRoaXMgdG8gaGFuZGxlIG1hbGZvcm1lZCBiaW5kaW5ncy5cbiAgICAgICAgICAgIG5hbWUuZW5kc1dpdGgoZGVsaW1zLmVuZCkgJiYgbmFtZS5sZW5ndGggPiBkZWxpbXMuc3RhcnQubGVuZ3RoICsgZGVsaW1zLmVuZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBuYW1lLnN1YnN0cmluZyhkZWxpbXMuc3RhcnQubGVuZ3RoLCBuYW1lLmxlbmd0aCAtIGRlbGltcy5lbmQubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGtleVNwYW4gPSBjcmVhdGVLZXlTcGFuKHNyY1NwYW4sIGRlbGltcy5zdGFydCwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoZGVsaW1zLnN0YXJ0ID09PSBCSU5ESU5HX0RFTElNUy5CQU5BTkFfQk9YLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGlkZW50aWZpZXIsIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIHBhcnNlZFByb3BlcnRpZXMsIGtleVNwYW4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBc3NpZ25tZW50RXZlbnQoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIGJvdW5kRXZlbnRzLCBrZXlTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlbGltcy5zdGFydCA9PT0gQklORElOR19ERUxJTVMuUFJPUEVSVFkuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VQcm9wZXJ0eUJpbmRpbmcoaWRlbnRpZmllciwgdmFsdWUsIGZhbHNlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywga2V5U3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VFdmVudChpZGVudGlmaWVyLCB2YWx1ZSwgLyogaXNBc3NpZ25tZW50RXZlbnQgKi8gZmFsc2UsIHNyY1NwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4gfHwgc3JjU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgZXZlbnRzLCBrZXlTcGFuKTtcbiAgICAgICAgICAgICAgICBhZGRFdmVudHMoZXZlbnRzLCBib3VuZEV2ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBleHBsaWNpdCBiaW5kaW5nIGZvdW5kLlxuICAgICAgICBjb25zdCBrZXlTcGFuID0gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCAnJyAvKiBwcmVmaXggKi8sIG5hbWUpO1xuICAgICAgICBjb25zdCBoYXNCaW5kaW5nID0gdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlJbnRlcnBvbGF0aW9uKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzLCBrZXlTcGFuLCAoX2EgPSBhdHRyaWJ1dGUudmFsdWVUb2tlbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwpO1xuICAgICAgICByZXR1cm4gaGFzQmluZGluZztcbiAgICB9XG4gICAgX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VTcGFuLCBpbnRlcnBvbGF0ZWRUb2tlbnMsIGkxOG4pIHtcbiAgICAgICAgY29uc3QgdmFsdWVOb05nc3AgPSByZXBsYWNlTmdzcCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlTm9OZ3NwLCBzb3VyY2VTcGFuLCBpbnRlcnBvbGF0ZWRUb2tlbnMpO1xuICAgICAgICByZXR1cm4gZXhwciA/IG5ldyBCb3VuZFRleHQoZXhwciwgc291cmNlU3BhbiwgaTE4bikgOiBuZXcgVGV4dCQzKHZhbHVlTm9OZ3NwLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgcGFyc2VWYXJpYWJsZShpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoYFwiLVwiIGlzIG5vdCBhbGxvd2VkIGluIHZhcmlhYmxlIG5hbWVzYCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpZmllci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoYFZhcmlhYmxlIGRvZXMgbm90IGhhdmUgYSBuYW1lYCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyaWFibGVzLnB1c2gobmV3IFZhcmlhYmxlKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICB9XG4gICAgcGFyc2VSZWZlcmVuY2UoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgcmVmZXJlbmNlcykge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgXCItXCIgaXMgbm90IGFsbG93ZWQgaW4gcmVmZXJlbmNlIG5hbWVzYCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpZmllci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoYFJlZmVyZW5jZSBkb2VzIG5vdCBoYXZlIGEgbmFtZWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZmVyZW5jZXMuc29tZShyZWZlcmVuY2UgPT4gcmVmZXJlbmNlLm5hbWUgPT09IGlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGBSZWZlcmVuY2UgXCIjJHtpZGVudGlmaWVyfVwiIGlzIGRlZmluZWQgbW9yZSB0aGFuIG9uY2VgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZShpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgfVxuICAgIHBhcnNlQXNzaWdubWVudEV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIGJvdW5kRXZlbnRzLCBrZXlTcGFuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VFdmVudChgJHtuYW1lfUNoYW5nZWAsIGAke2V4cHJlc3Npb259ID0kZXZlbnRgLCAvKiBpc0Fzc2lnbm1lbnRFdmVudCAqLyB0cnVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4gfHwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIGV2ZW50cywga2V5U3Bhbik7XG4gICAgICAgIGFkZEV2ZW50cyhldmVudHMsIGJvdW5kRXZlbnRzKTtcbiAgICB9XG4gICAgcmVwb3J0RXJyb3IobWVzc2FnZSwgc291cmNlU3BhbiwgbGV2ZWwgPSBleHBvcnRzLlBhcnNlRXJyb3JMZXZlbC5FUlJPUikge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfVxufVxuY2xhc3MgTm9uQmluZGFibGVWaXNpdG9yIHtcbiAgICB2aXNpdEVsZW1lbnQoYXN0KSB7XG4gICAgICAgIGNvbnN0IHByZXBhcnNlZEVsZW1lbnQgPSBwcmVwYXJzZUVsZW1lbnQoYXN0KTtcbiAgICAgICAgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU0NSSVBUIHx8XG4gICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFIHx8XG4gICAgICAgICAgICBwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQpIHtcbiAgICAgICAgICAgIC8vIFNraXBwaW5nIDxzY3JpcHQ+IGZvciBzZWN1cml0eSByZWFzb25zXG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c3R5bGU+IGFuZCBzdHlsZXNoZWV0cyBhcyB3ZSBhbHJlYWR5IHByb2Nlc3NlZCB0aGVtXG4gICAgICAgICAgICAvLyBpbiB0aGUgU3R5bGVDb21waWxlclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB2aXNpdEFsbCh0aGlzLCBhc3QuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQkMShhc3QubmFtZSwgdmlzaXRBbGwodGhpcywgYXN0LmF0dHJzKSwgXG4gICAgICAgIC8qIGlucHV0cyAqLyBbXSwgLyogb3V0cHV0cyAqLyBbXSwgY2hpbGRyZW4sIC8qIHJlZmVyZW5jZXMgKi8gW10sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc3RhcnRTb3VyY2VTcGFuLCBhc3QuZW5kU291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuLCBhdHRyaWJ1dGUua2V5U3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgYXR0cmlidXRlLmkxOG4pO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHQkMyh0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihleHBhbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShleHBhbnNpb25DYXNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IE5PTl9CSU5EQUJMRV9WSVNJVE9SID0gbmV3IE5vbkJpbmRhYmxlVmlzaXRvcigpO1xuZnVuY3Rpb24gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyTmFtZSkge1xuICAgIHJldHVybiAvXmRhdGEtL2kudGVzdChhdHRyTmFtZSkgPyBhdHRyTmFtZS5zdWJzdHJpbmcoNSkgOiBhdHRyTmFtZTtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50cyhldmVudHMsIGJvdW5kRXZlbnRzKSB7XG4gICAgYm91bmRFdmVudHMucHVzaCguLi5ldmVudHMubWFwKGUgPT4gQm91bmRFdmVudC5mcm9tUGFyc2VkRXZlbnQoZSkpKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUZXh0ICYmIG5vZGUudmFsdWUudHJpbSgpLmxlbmd0aCA9PSAwO1xufVxuZnVuY3Rpb24gaXNDb21tZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb21tZW50O1xufVxuZnVuY3Rpb24gdGV4dENvbnRlbnRzKG5vZGUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgIShub2RlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlblswXS52YWx1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xudmFyIFRhZ1R5cGU7XG4oZnVuY3Rpb24gKFRhZ1R5cGUpIHtcbiAgICBUYWdUeXBlW1RhZ1R5cGVbXCJFTEVNRU5UXCJdID0gMF0gPSBcIkVMRU1FTlRcIjtcbiAgICBUYWdUeXBlW1RhZ1R5cGVbXCJURU1QTEFURVwiXSA9IDFdID0gXCJURU1QTEFURVwiO1xufSkoVGFnVHlwZSB8fCAoVGFnVHlwZSA9IHt9KSk7XG4vKipcbiAqIEdlbmVyYXRlcyBhbiBvYmplY3QgdGhhdCBpcyB1c2VkIGFzIGEgc2hhcmVkIHN0YXRlIGJldHdlZW4gcGFyZW50IGFuZCBhbGwgY2hpbGQgY29udGV4dHMuXG4gKi9cbmZ1bmN0aW9uIHNldHVwUmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIHsgZ2V0VW5pcXVlSWQ6IGdldFNlcU51bWJlckdlbmVyYXRvcigpLCBpY3VzOiBuZXcgTWFwKCkgfTtcbn1cbi8qKlxuICogSTE4bkNvbnRleHQgaXMgYSBoZWxwZXIgY2xhc3Mgd2hpY2gga2VlcHMgdHJhY2sgb2YgYWxsIGkxOG4tcmVsYXRlZCBhc3BlY3RzXG4gKiAoYWNjdW11bGF0ZXMgcGxhY2Vob2xkZXJzLCBiaW5kaW5ncywgZXRjKSBiZXR3ZWVuIGkxOG5TdGFydCBhbmQgaTE4bkVuZCBpbnN0cnVjdGlvbnMuXG4gKlxuICogV2hlbiB3ZSBlbnRlciBhIG5lc3RlZCB0ZW1wbGF0ZSwgdGhlIHRvcC1sZXZlbCBjb250ZXh0IGlzIGJlaW5nIHBhc3NlZCBkb3duXG4gKiB0byB0aGUgbmVzdGVkIGNvbXBvbmVudCwgd2hpY2ggdXNlcyB0aGlzIGNvbnRleHQgdG8gZ2VuZXJhdGUgYSBjaGlsZCBpbnN0YW5jZVxuICogb2YgSTE4bkNvbnRleHQgY2xhc3MgKHRvIGhhbmRsZSBuZXN0ZWQgdGVtcGxhdGUpIGFuZCBhdCB0aGUgZW5kLCByZWNvbmNpbGVzIGl0IGJhY2tcbiAqIHdpdGggdGhlIHBhcmVudCBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBpbmRleCBJbnN0cnVjdGlvbiBpbmRleCBvZiBpMThuU3RhcnQsIHdoaWNoIGluaXRpYXRlcyB0aGlzIGNvbnRleHRcbiAqIEBwYXJhbSByZWYgUmVmZXJlbmNlIHRvIGEgdHJhbnNsYXRpb24gY29uc3QgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IGlmIHRodXMgY29udGV4dFxuICogQHBhcmFtIGxldmVsIE5lc3RuZyBsZXZlbCBkZWZpbmVkIGZvciBjaGlsZCBjb250ZXh0c1xuICogQHBhcmFtIHRlbXBsYXRlSW5kZXggSW5zdHJ1Y3Rpb24gaW5kZXggb2YgYSB0ZW1wbGF0ZSB3aGljaCB0aGlzIGNvbnRleHQgYmVsb25ncyB0b1xuICogQHBhcmFtIG1ldGEgTWV0YSBpbmZvcm1hdGlvbiAoaWQsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBldGMpIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRleHRcbiAqL1xuY2xhc3MgSTE4bkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCByZWYsIGxldmVsID0gMCwgdGVtcGxhdGVJbmRleCA9IG51bGwsIG1ldGEsIHJlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUluZGV4ID0gdGVtcGxhdGVJbmRleDtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pc0VtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdW5yZXNvbHZlZEN0eENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcmVnaXN0cnkgPSByZWdpc3RyeSB8fCBzZXR1cFJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLl9yZWdpc3RyeS5nZXRVbmlxdWVJZCgpO1xuICAgIH1cbiAgICBhcHBlbmRUYWcodHlwZSwgbm9kZSwgaW5kZXgsIGNsb3NlZCkge1xuICAgICAgICBpZiAobm9kZS5pc1ZvaWQgJiYgY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBcImNsb3NlXCIgZm9yIHZvaWQgdGFnc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBoID0gbm9kZS5pc1ZvaWQgfHwgIWNsb3NlZCA/IG5vZGUuc3RhcnROYW1lIDogbm9kZS5jbG9zZU5hbWU7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB7IHR5cGUsIGluZGV4LCBjdHg6IHRoaXMuaWQsIGlzVm9pZDogbm9kZS5pc1ZvaWQsIGNsb3NlZCB9O1xuICAgICAgICB1cGRhdGVQbGFjZWhvbGRlck1hcCh0aGlzLnBsYWNlaG9sZGVycywgcGgsIGNvbnRlbnQpO1xuICAgIH1cbiAgICBnZXQgaWN1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5LmljdXM7XG4gICAgfVxuICAgIGdldCBpc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxldmVsID09PSAwO1xuICAgIH1cbiAgICBnZXQgaXNSZXNvbHZlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudCA9PT0gMDtcbiAgICB9XG4gICAgZ2V0U2VyaWFsaXplZFBsYWNlaG9sZGVycygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycy5mb3JFYWNoKCh2YWx1ZXMsIGtleSkgPT4gcmVzdWx0LnNldChrZXksIHZhbHVlcy5tYXAoc2VyaWFsaXplUGxhY2Vob2xkZXJWYWx1ZSkpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gcHVibGljIEFQSSB0byBhY2N1bXVsYXRlIGkxOG4tcmVsYXRlZCBjb250ZW50XG4gICAgYXBwZW5kQmluZGluZyhiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MuYWRkKGJpbmRpbmcpO1xuICAgIH1cbiAgICBhcHBlbmRJY3UobmFtZSwgcmVmKSB7XG4gICAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyTWFwKHRoaXMuX3JlZ2lzdHJ5LmljdXMsIG5hbWUsIHJlZik7XG4gICAgfVxuICAgIGFwcGVuZEJvdW5kVGV4dChub2RlKSB7XG4gICAgICAgIGNvbnN0IHBocyA9IGFzc2VtYmxlQm91bmRUZXh0UGxhY2Vob2xkZXJzKG5vZGUsIHRoaXMuYmluZGluZ3Muc2l6ZSwgdGhpcy5pZCk7XG4gICAgICAgIHBocy5mb3JFYWNoKCh2YWx1ZXMsIGtleSkgPT4gdXBkYXRlUGxhY2Vob2xkZXJNYXAodGhpcy5wbGFjZWhvbGRlcnMsIGtleSwgLi4udmFsdWVzKSk7XG4gICAgfVxuICAgIGFwcGVuZFRlbXBsYXRlKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIC8vIGFkZCBvcGVuIGFuZCBjbG9zZSB0YWdzIGF0IHRoZSBzYW1lIHRpbWUsXG4gICAgICAgIC8vIHNpbmNlIHdlIHByb2Nlc3MgbmVzdGVkIHRlbXBsYXRlcyBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuYXBwZW5kVGFnKFRhZ1R5cGUuVEVNUExBVEUsIG5vZGUsIGluZGV4LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuYXBwZW5kVGFnKFRhZ1R5cGUuVEVNUExBVEUsIG5vZGUsIGluZGV4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdW5yZXNvbHZlZEN0eENvdW50Kys7XG4gICAgfVxuICAgIGFwcGVuZEVsZW1lbnQobm9kZSwgaW5kZXgsIGNsb3NlZCkge1xuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLkVMRU1FTlQsIG5vZGUsIGluZGV4LCBjbG9zZWQpO1xuICAgIH1cbiAgICBhcHBlbmRQcm9qZWN0aW9uKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIC8vIEFkZCBvcGVuIGFuZCBjbG9zZSB0YWdzIGF0IHRoZSBzYW1lIHRpbWUsIHNpbmNlIGA8bmctY29udGVudD5gIGhhcyBubyBjb250ZW50LFxuICAgICAgICAvLyBzbyB3aGVuIHdlIGNvbWUgYWNyb3NzIGA8bmctY29udGVudD5gIHdlIGNhbiByZWdpc3RlciBib3RoIG9wZW4gYW5kIGNsb3NlIHRhZ3MuXG4gICAgICAgIC8vIE5vdGU6IHJ1bnRpbWUgaTE4biBsb2dpYyBkb2Vzbid0IGRpc3Rpbmd1aXNoIGA8bmctY29udGVudD5gIHRhZyBwbGFjZWhvbGRlcnMgYW5kXG4gICAgICAgIC8vIHJlZ3VsYXIgZWxlbWVudCB0YWcgcGxhY2Vob2xkZXJzLCBzbyB3ZSBnZW5lcmF0ZSBlbGVtZW50IHBsYWNlaG9sZGVycyBmb3IgYm90aCB0eXBlcy5cbiAgICAgICAgdGhpcy5hcHBlbmRUYWcoVGFnVHlwZS5FTEVNRU5ULCBub2RlLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLkVMRU1FTlQsIG5vZGUsIGluZGV4LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGluc3RhbmNlIG9mIGEgY2hpbGQgY29udGV4dCBiYXNlZCBvbiB0aGUgcm9vdCBvbmUsXG4gICAgICogd2hlbiB3ZSBlbnRlciBhIG5lc3RlZCB0ZW1wbGF0ZSB3aXRoaW4gSTE4biBzZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IEluc3RydWN0aW9uIGluZGV4IG9mIGNvcnJlc3BvbmRpbmcgaTE4blN0YXJ0LCB3aGljaCBpbml0aWF0ZXMgdGhpcyBjb250ZXh0XG4gICAgICogQHBhcmFtIHRlbXBsYXRlSW5kZXggSW5zdHJ1Y3Rpb24gaW5kZXggb2YgYSB0ZW1wbGF0ZSB3aGljaCB0aGlzIGNvbnRleHQgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSBtZXRhIE1ldGEgaW5mb3JtYXRpb24gKGlkLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgZXRjKSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJMThuQ29udGV4dCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZvcmtDaGlsZENvbnRleHQoaW5kZXgsIHRlbXBsYXRlSW5kZXgsIG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJMThuQ29udGV4dChpbmRleCwgdGhpcy5yZWYsIHRoaXMubGV2ZWwgKyAxLCB0ZW1wbGF0ZUluZGV4LCBtZXRhLCB0aGlzLl9yZWdpc3RyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29uY2lsZXMgY2hpbGQgY29udGV4dCBpbnRvIHBhcmVudCBvbmUgb25jZSB0aGUgZW5kIG9mIHRoZSBpMThuIGJsb2NrIGlzIHJlYWNoZWQgKGkxOG5FbmQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRleHQgQ2hpbGQgSTE4bkNvbnRleHQgaW5zdGFuY2UgdG8gYmUgcmVjb25jaWxlZCB3aXRoIHBhcmVudCBjb250ZXh0LlxuICAgICAqL1xuICAgIHJlY29uY2lsZUNoaWxkQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIC8vIHNldCB0aGUgcmlnaHQgY29udGV4dCBpZCBmb3Igb3BlbiBhbmQgY2xvc2VcbiAgICAgICAgLy8gdGVtcGxhdGUgdGFncywgc28gd2UgY2FuIHVzZSBpdCBhcyBzdWItYmxvY2sgaWRzXG4gICAgICAgIFsnc3RhcnQnLCAnY2xvc2UnXS5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY29udGV4dC5tZXRhW2Ake29wfU5hbWVgXTtcbiAgICAgICAgICAgIGNvbnN0IHBocyA9IHRoaXMucGxhY2Vob2xkZXJzLmdldChrZXkpIHx8IFtdO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcGhzLmZpbmQoZmluZFRlbXBsYXRlRm4odGhpcy5pZCwgY29udGV4dC50ZW1wbGF0ZUluZGV4KSk7XG4gICAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICAgICAgdGFnLmN0eCA9IGNvbnRleHQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZWNvbmNpbGUgcGxhY2Vob2xkZXJzXG4gICAgICAgIGNvbnN0IGNoaWxkUGhzID0gY29udGV4dC5wbGFjZWhvbGRlcnM7XG4gICAgICAgIGNoaWxkUGhzLmZvckVhY2goKHZhbHVlcywga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwaHMgPSB0aGlzLnBsYWNlaG9sZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghcGhzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMuc2V0KGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cnkgdG8gZmluZCBtYXRjaGluZyB0ZW1wbGF0ZS4uLlxuICAgICAgICAgICAgY29uc3QgdG1wbElkeCA9IHBocy5maW5kSW5kZXgoZmluZFRlbXBsYXRlRm4oY29udGV4dC5pZCwgY29udGV4dC50ZW1wbGF0ZUluZGV4KSk7XG4gICAgICAgICAgICBpZiAodG1wbElkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uIGlmIGZvdW5kIC0gcmVwbGFjZSBpdCB3aXRoIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDbG9zZVRhZyA9IGtleS5zdGFydHNXaXRoKCdDTE9TRScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVGVtcGxhdGVUYWcgPSBrZXkuZW5kc1dpdGgoJ05HLVRFTVBMQVRFJyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCB0ZW1wbGF0ZSdzIGNvbnRlbnQgaXMgcGxhY2VkIGJlZm9yZSBvciBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgdGVtcGxhdGUgdGFnLCBkZXBlbmRpbmcgb24gdGhlIG9wZW4vY2xvc2UgYXRycmlidXRlXG4gICAgICAgICAgICAgICAgICAgIHBocy5zcGxpY2UodG1wbElkeCArIChpc0Nsb3NlVGFnID8gMCA6IDEpLCAwLCAuLi52YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gaXNDbG9zZVRhZyA/IHZhbHVlcy5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2lkeF0udG1wbCA9IHBoc1t0bXBsSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgcGhzLnNwbGljZSh0bXBsSWR4LCAxLCAuLi52YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2UganVzdCBhcHBlbmQgY29udGVudCB0byBwbGFjZWhvbGRlciB2YWx1ZVxuICAgICAgICAgICAgICAgIHBocy5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVycy5zZXQoa2V5LCBwaHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdW5yZXNvbHZlZEN0eENvdW50LS07XG4gICAgfVxufVxuLy9cbi8vIEhlbHBlciBtZXRob2RzXG4vL1xuZnVuY3Rpb24gd3JhcChzeW1ib2wsIGluZGV4LCBjb250ZXh0SWQsIGNsb3NlZCkge1xuICAgIGNvbnN0IHN0YXRlID0gY2xvc2VkID8gJy8nIDogJyc7XG4gICAgcmV0dXJuIHdyYXBJMThuUGxhY2Vob2xkZXIoYCR7c3RhdGV9JHtzeW1ib2x9JHtpbmRleH1gLCBjb250ZXh0SWQpO1xufVxuZnVuY3Rpb24gd3JhcFRhZyhzeW1ib2wsIHsgaW5kZXgsIGN0eCwgaXNWb2lkIH0sIGNsb3NlZCkge1xuICAgIHJldHVybiBpc1ZvaWQgPyB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCkgKyB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCwgdHJ1ZSkgOlxuICAgICAgICB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCwgY2xvc2VkKTtcbn1cbmZ1bmN0aW9uIGZpbmRUZW1wbGF0ZUZuKGN0eCwgdGVtcGxhdGVJbmRleCkge1xuICAgIHJldHVybiAodG9rZW4pID0+IHR5cGVvZiB0b2tlbiA9PT0gJ29iamVjdCcgJiYgdG9rZW4udHlwZSA9PT0gVGFnVHlwZS5URU1QTEFURSAmJlxuICAgICAgICB0b2tlbi5pbmRleCA9PT0gdGVtcGxhdGVJbmRleCAmJiB0b2tlbi5jdHggPT09IGN0eDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBsYWNlaG9sZGVyVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gKGRhdGEsIGNsb3NlZCkgPT4gd3JhcFRhZygnIycsIGRhdGEsIGNsb3NlZCk7XG4gICAgY29uc3QgdGVtcGxhdGUgPSAoZGF0YSwgY2xvc2VkKSA9PiB3cmFwVGFnKCcqJywgZGF0YSwgY2xvc2VkKTtcbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBUYWdUeXBlLkVMRU1FTlQ6XG4gICAgICAgICAgICAvLyBjbG9zZSBlbGVtZW50IHRhZ1xuICAgICAgICAgICAgaWYgKHZhbHVlLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50KHZhbHVlLCB0cnVlKSArICh2YWx1ZS50bXBsID8gdGVtcGxhdGUodmFsdWUudG1wbCwgdHJ1ZSkgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvcGVuIGVsZW1lbnQgdGFnIHRoYXQgYWxzbyBpbml0aWF0ZXMgYSB0ZW1wbGF0ZVxuICAgICAgICAgICAgaWYgKHZhbHVlLnRtcGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUodmFsdWUudG1wbCkgKyBlbGVtZW50KHZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5pc1ZvaWQgPyB0ZW1wbGF0ZSh2YWx1ZS50bXBsLCB0cnVlKSA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBUYWdUeXBlLlRFTVBMQVRFOlxuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHZhbHVlLCB2YWx1ZS5jbG9zZWQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBJY3VTZXJpYWxpemVyVmlzaXRvciB7XG4gICAgdmlzaXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQudmFsdWU7XG4gICAgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSkuam9pbignJyk7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSkge1xuICAgICAgICBjb25zdCBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKChrKSA9PiBgJHtrfSB7JHtpY3UuY2FzZXNba10udmlzaXQodGhpcyl9fWApO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBgeyR7aWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlcn0sICR7aWN1LnR5cGV9LCAke3N0ckNhc2VzLmpvaW4oJyAnKX19YDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCkge1xuICAgICAgICByZXR1cm4gcGguaXNWb2lkID9cbiAgICAgICAgICAgIHRoaXMuZm9ybWF0UGgocGguc3RhcnROYW1lKSA6XG4gICAgICAgICAgICBgJHt0aGlzLmZvcm1hdFBoKHBoLnN0YXJ0TmFtZSl9JHtwaC5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpLmpvaW4oJycpfSR7dGhpcy5mb3JtYXRQaChwaC5jbG9zZU5hbWUpfWA7XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UGgocGgubmFtZSk7XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UGgocGgubmFtZSk7XG4gICAgfVxuICAgIGZvcm1hdFBoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBgeyR7Zm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZSh2YWx1ZSwgLyogdXNlQ2FtZWxDYXNlICovIGZhbHNlKX19YDtcbiAgICB9XG59XG5jb25zdCBzZXJpYWxpemVyID0gbmV3IEljdVNlcmlhbGl6ZXJWaXNpdG9yKCk7XG5mdW5jdGlvbiBzZXJpYWxpemVJY3VOb2RlKGljdSkge1xuICAgIHJldHVybiBpY3UudmlzaXQoc2VyaWFsaXplcik7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTID0ge1xuICAgICdBJzogJ0xJTksnLFxuICAgICdCJzogJ0JPTERfVEVYVCcsXG4gICAgJ0JSJzogJ0xJTkVfQlJFQUsnLFxuICAgICdFTSc6ICdFTVBIQVNJU0VEX1RFWFQnLFxuICAgICdIMSc6ICdIRUFESU5HX0xFVkVMMScsXG4gICAgJ0gyJzogJ0hFQURJTkdfTEVWRUwyJyxcbiAgICAnSDMnOiAnSEVBRElOR19MRVZFTDMnLFxuICAgICdINCc6ICdIRUFESU5HX0xFVkVMNCcsXG4gICAgJ0g1JzogJ0hFQURJTkdfTEVWRUw1JyxcbiAgICAnSDYnOiAnSEVBRElOR19MRVZFTDYnLFxuICAgICdIUic6ICdIT1JJWk9OVEFMX1JVTEUnLFxuICAgICdJJzogJ0lUQUxJQ19URVhUJyxcbiAgICAnTEknOiAnTElTVF9JVEVNJyxcbiAgICAnTElOSyc6ICdNRURJQV9MSU5LJyxcbiAgICAnT0wnOiAnT1JERVJFRF9MSVNUJyxcbiAgICAnUCc6ICdQQVJBR1JBUEgnLFxuICAgICdRJzogJ1FVT1RBVElPTicsXG4gICAgJ1MnOiAnU1RSSUtFVEhST1VHSF9URVhUJyxcbiAgICAnU01BTEwnOiAnU01BTExfVEVYVCcsXG4gICAgJ1NVQic6ICdTVUJTVFJJUFQnLFxuICAgICdTVVAnOiAnU1VQRVJTQ1JJUFQnLFxuICAgICdUQk9EWSc6ICdUQUJMRV9CT0RZJyxcbiAgICAnVEQnOiAnVEFCTEVfQ0VMTCcsXG4gICAgJ1RGT09UJzogJ1RBQkxFX0ZPT1RFUicsXG4gICAgJ1RIJzogJ1RBQkxFX0hFQURFUl9DRUxMJyxcbiAgICAnVEhFQUQnOiAnVEFCTEVfSEVBREVSJyxcbiAgICAnVFInOiAnVEFCTEVfUk9XJyxcbiAgICAnVFQnOiAnTU9OT1NQQUNFRF9URVhUJyxcbiAgICAnVSc6ICdVTkRFUkxJTkVEX1RFWFQnLFxuICAgICdVTCc6ICdVTk9SREVSRURfTElTVCcsXG59O1xuLyoqXG4gKiBDcmVhdGVzIHVuaXF1ZSBuYW1lcyBmb3IgcGxhY2Vob2xkZXIgd2l0aCBkaWZmZXJlbnQgY29udGVudC5cbiAqXG4gKiBSZXR1cm5zIHRoZSBzYW1lIHBsYWNlaG9sZGVyIG5hbWUgd2hlbiB0aGUgY29udGVudCBpcyBpZGVudGljYWwuXG4gKi9cbmNsYXNzIFBsYWNlaG9sZGVyUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBDb3VudCB0aGUgb2NjdXJyZW5jZSBvZiB0aGUgYmFzZSBuYW1lIHRvcCBnZW5lcmF0ZSBhIHVuaXF1ZSBuYW1lXG4gICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50cyA9IHt9O1xuICAgICAgICAvLyBNYXBzIHNpZ25hdHVyZSB0byBwbGFjZWhvbGRlciBuYW1lc1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWUgPSB7fTtcbiAgICB9XG4gICAgZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUodGFnLCBhdHRycywgaXNWb2lkKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuX2hhc2hUYWcodGFnLCBhdHRycywgaXNWb2lkKTtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBwZXJUYWcgPSB0YWcudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYmFzZU5hbWUgPSBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVNbdXBwZXJUYWddIHx8IGBUQUdfJHt1cHBlclRhZ31gO1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKGlzVm9pZCA/IGJhc2VOYW1lIDogYFNUQVJUXyR7YmFzZU5hbWV9YCk7XG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldENsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKHRhZykge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLl9oYXNoQ2xvc2luZ1RhZyh0YWcpO1xuICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cHBlclRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjb25zdCBiYXNlTmFtZSA9IFRBR19UT19QTEFDRUhPTERFUl9OQU1FU1t1cHBlclRhZ10gfHwgYFRBR18ke3VwcGVyVGFnfWA7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoYENMT1NFXyR7YmFzZU5hbWV9YCk7XG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGdldFBsYWNlaG9sZGVyTmFtZShuYW1lLCBjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHVwcGVyTmFtZSA9IG5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYFBIOiAke3VwcGVyTmFtZX09JHtjb250ZW50fWA7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUodXBwZXJOYW1lKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSB1bmlxdWVOYW1lO1xuICAgICAgICByZXR1cm4gdW5pcXVlTmFtZTtcbiAgICB9XG4gICAgZ2V0VW5pcXVlUGxhY2Vob2xkZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2VuZXJhdGVVbmlxdWVOYW1lKG5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlIGEgaGFzaCBmb3IgYSB0YWcgLSBkb2VzIG5vdCB0YWtlIGF0dHJpYnV0ZSBvcmRlciBpbnRvIGFjY291bnRcbiAgICBfaGFzaFRhZyh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBgPCR7dGFnfWA7XG4gICAgICAgIGNvbnN0IHN0ckF0dHJzID0gT2JqZWN0LmtleXMoYXR0cnMpLnNvcnQoKS5tYXAoKG5hbWUpID0+IGAgJHtuYW1lfT0ke2F0dHJzW25hbWVdfWApLmpvaW4oJycpO1xuICAgICAgICBjb25zdCBlbmQgPSBpc1ZvaWQgPyAnLz4nIDogYD48LyR7dGFnfT5gO1xuICAgICAgICByZXR1cm4gc3RhcnQgKyBzdHJBdHRycyArIGVuZDtcbiAgICB9XG4gICAgX2hhc2hDbG9zaW5nVGFnKHRhZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzaFRhZyhgLyR7dGFnfWAsIHt9LCBmYWxzZSk7XG4gICAgfVxuICAgIF9nZW5lcmF0ZVVuaXF1ZU5hbWUoYmFzZSkge1xuICAgICAgICBjb25zdCBzZWVuID0gdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzLmhhc093blByb3BlcnR5KGJhc2UpO1xuICAgICAgICBpZiAoIXNlZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZCA9IHRoaXMuX3BsYWNlSG9sZGVyTmFtZUNvdW50c1tiYXNlXTtcbiAgICAgICAgdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW2Jhc2VdID0gaWQgKyAxO1xuICAgICAgICByZXR1cm4gYCR7YmFzZX1fJHtpZH1gO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBfZXhwUGFyc2VyID0gbmV3IFBhcnNlciQxKG5ldyBMZXhlcigpKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGNvbnZlcnRpbmcgaHRtbCBub2RlcyB0byBhbiBpMThuIE1lc3NhZ2UgZ2l2ZW4gYW4gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICovXG5mdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKF9leHBQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgIHJldHVybiAobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBjdXN0b21JZCwgdmlzaXROb2RlRm4pID0+IHZpc2l0b3IudG9JMThuTWVzc2FnZShub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGN1c3RvbUlkLCB2aXNpdE5vZGVGbik7XG59XG5mdW5jdGlvbiBub29wVmlzaXROb2RlRm4oX2h0bWwsIGkxOG4pIHtcbiAgICByZXR1cm4gaTE4bjtcbn1cbmNsYXNzIF9JMThuVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2V4cHJlc3Npb25QYXJzZXIgPSBfZXhwcmVzc2lvblBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgIH1cbiAgICB0b0kxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nID0gJycsIGRlc2NyaXB0aW9uID0gJycsIGN1c3RvbUlkID0gJycsIHZpc2l0Tm9kZUZuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBpc0ljdTogbm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZXNbMF0gaW5zdGFuY2VvZiBFeHBhbnNpb24sXG4gICAgICAgICAgICBpY3VEZXB0aDogMCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyUmVnaXN0cnk6IG5ldyBQbGFjZWhvbGRlclJlZ2lzdHJ5KCksXG4gICAgICAgICAgICBwbGFjZWhvbGRlclRvQ29udGVudDoge30sXG4gICAgICAgICAgICBwbGFjZWhvbGRlclRvTWVzc2FnZToge30sXG4gICAgICAgICAgICB2aXNpdE5vZGVGbjogdmlzaXROb2RlRm4gfHwgbm9vcFZpc2l0Tm9kZUZuLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpMThub2RlcyA9IHZpc2l0QWxsKHRoaXMsIG5vZGVzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGkxOG5vZGVzLCBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50LCBjb250ZXh0LnBsYWNlaG9sZGVyVG9NZXNzYWdlLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgY3VzdG9tSWQpO1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgYXR0cnMgPSB7fTtcbiAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB2aXNpdCB0aGUgYXR0cmlidXRlcywgdHJhbnNsYXRhYmxlIG9uZXMgYXJlIHRvcC1sZXZlbCBBU1RzXG4gICAgICAgICAgICBhdHRyc1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGlzVm9pZCA9IGdldEh0bWxUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmlzVm9pZDtcbiAgICAgICAgY29uc3Qgc3RhcnRQaE5hbWUgPSBjb250ZXh0LnBsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0U3RhcnRUYWdQbGFjZWhvbGRlck5hbWUoZWwubmFtZSwgYXR0cnMsIGlzVm9pZCk7XG4gICAgICAgIGNvbnRleHQucGxhY2Vob2xkZXJUb0NvbnRlbnRbc3RhcnRQaE5hbWVdID0ge1xuICAgICAgICAgICAgdGV4dDogZWwuc3RhcnRTb3VyY2VTcGFuLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzb3VyY2VTcGFuOiBlbC5zdGFydFNvdXJjZVNwYW4sXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjbG9zZVBoTmFtZSA9ICcnO1xuICAgICAgICBpZiAoIWlzVm9pZCkge1xuICAgICAgICAgICAgY2xvc2VQaE5hbWUgPSBjb250ZXh0LnBsYWNlaG9sZGVyUmVnaXN0cnkuZ2V0Q2xvc2VUYWdQbGFjZWhvbGRlck5hbWUoZWwubmFtZSk7XG4gICAgICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50W2Nsb3NlUGhOYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBgPC8ke2VsLm5hbWV9PmAsXG4gICAgICAgICAgICAgICAgc291cmNlU3BhbjogKF9hID0gZWwuZW5kU291cmNlU3BhbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZWwuc291cmNlU3BhbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUYWdQbGFjZWhvbGRlcihlbC5uYW1lLCBhdHRycywgc3RhcnRQaE5hbWUsIGNsb3NlUGhOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICByZXR1cm4gY29udGV4dC52aXNpdE5vZGVGbihlbCwgbm9kZSk7XG4gICAgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlID0gYXR0cmlidXRlLnZhbHVlVG9rZW5zID09PSB1bmRlZmluZWQgfHwgYXR0cmlidXRlLnZhbHVlVG9rZW5zLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICBuZXcgVGV4dCQyKGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnZhbHVlU3BhbiB8fCBhdHRyaWJ1dGUuc291cmNlU3BhbikgOlxuICAgICAgICAgICAgdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24oYXR0cmlidXRlLnZhbHVlVG9rZW5zLCBhdHRyaWJ1dGUudmFsdWVTcGFuIHx8IGF0dHJpYnV0ZS5zb3VyY2VTcGFuLCBjb250ZXh0LCBhdHRyaWJ1dGUuaTE4bik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKGF0dHJpYnV0ZSwgbm9kZSk7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0ZXh0LnRva2Vucy5sZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgbmV3IFRleHQkMih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pIDpcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHRleHQudG9rZW5zLCB0ZXh0LnNvdXJjZVNwYW4sIGNvbnRleHQsIHRleHQuaTE4bik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKHRleHQsIG5vZGUpO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb24oaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuaWN1RGVwdGgrKztcbiAgICAgICAgY29uc3QgaTE4bkljdUNhc2VzID0ge307XG4gICAgICAgIGNvbnN0IGkxOG5JY3UgPSBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGkxOG5JY3VDYXNlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICBpY3UuY2FzZXMuZm9yRWFjaCgoY2F6ZSkgPT4ge1xuICAgICAgICAgICAgaTE4bkljdUNhc2VzW2NhemUudmFsdWVdID0gbmV3IENvbnRhaW5lcihjYXplLmV4cHJlc3Npb24ubWFwKChub2RlKSA9PiBub2RlLnZpc2l0KHRoaXMsIGNvbnRleHQpKSwgY2F6ZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuaWN1RGVwdGgtLTtcbiAgICAgICAgaWYgKGNvbnRleHQuaXNJY3UgfHwgY29udGV4dC5pY3VEZXB0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgYW4gSUNVIG5vZGUgd2hlbjpcbiAgICAgICAgICAgIC8vIC0gdGhlIG1lc3NhZ2UgKHZzIGEgcGFydCBvZiB0aGUgbWVzc2FnZSkgaXMgYW4gSUNVIG1lc3NhZ2UsIG9yXG4gICAgICAgICAgICAvLyAtIHRoZSBJQ1UgbWVzc2FnZSBpcyBuZXN0ZWQuXG4gICAgICAgICAgICBjb25zdCBleHBQaCA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRVbmlxdWVQbGFjZWhvbGRlcihgVkFSXyR7aWN1LnR5cGV9YCk7XG4gICAgICAgICAgICBpMThuSWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlciA9IGV4cFBoO1xuICAgICAgICAgICAgY29udGV4dC5wbGFjZWhvbGRlclRvQ29udGVudFtleHBQaF0gPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogaWN1LnN3aXRjaFZhbHVlLFxuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGljdS5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudmlzaXROb2RlRm4oaWN1LCBpMThuSWN1KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHJldHVybnMgYSBwbGFjZWhvbGRlclxuICAgICAgICAvLyBJQ1UgcGxhY2Vob2xkZXJzIHNob3VsZCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0aGVpciBvcmlnaW5hbCBjb250ZW50IGJ1dCB3aXRoIHRoZSB0aGVpclxuICAgICAgICAvLyB0cmFuc2xhdGlvbnMuXG4gICAgICAgIC8vIFRPRE8odmljYik6IGFkZCBhIGh0bWwuTm9kZSAtPiBpMThuLk1lc3NhZ2UgY2FjaGUgdG8gYXZvaWQgaGF2aW5nIHRvIHJlLWNyZWF0ZSB0aGUgbXNnXG4gICAgICAgIGNvbnN0IHBoTmFtZSA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoJ0lDVScsIGljdS5zb3VyY2VTcGFuLnRvU3RyaW5nKCkpO1xuICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9NZXNzYWdlW3BoTmFtZV0gPSB0aGlzLnRvSTE4bk1lc3NhZ2UoW2ljdV0sICcnLCAnJywgJycsIHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgSWN1UGxhY2Vob2xkZXIoaTE4bkljdSwgcGhOYW1lLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKGljdSwgbm9kZSk7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShfaWN1Q2FzZSwgX2NvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQsIHRleHQgYW5kIGludGVycG9sYXRlZCB0b2tlbnMgdXAgaW50byB0ZXh0IGFuZCBwbGFjZWhvbGRlciBwaWVjZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5zIFRoZSB0ZXh0IGFuZCBpbnRlcnBvbGF0ZWQgdG9rZW5zLlxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuIFRoZSBzcGFuIG9mIHRoZSB3aG9sZSBvZiB0aGUgYHRleHRgIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSB2aXNpdG9yLCB1c2VkIHRvIGNvbXB1dGUgYW5kIHN0b3JlIHBsYWNlaG9sZGVycy5cbiAgICAgKiBAcGFyYW0gcHJldmlvdXNJMThuIEFueSBpMThuIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGB0ZXh0YCBmcm9tIGEgcHJldmlvdXMgcGFzcy5cbiAgICAgKi9cbiAgICBfdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odG9rZW5zLCBzb3VyY2VTcGFuLCBjb250ZXh0LCBwcmV2aW91c0kxOG4pIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgc2VxdWVuY2Ugb2YgYFRleHRgIGFuZCBgUGxhY2Vob2xkZXJgIG5vZGVzIGdyb3VwZWQgaW4gYSBgQ29udGFpbmVyYC5cbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgLy8gV2Ugd2lsbCBvbmx5IGNyZWF0ZSBhIGNvbnRhaW5lciBpZiB0aGVyZSBhcmUgYWN0dWFsbHkgaW50ZXJwb2xhdGlvbnMsXG4gICAgICAgIC8vIHNvIHRoaXMgZmxhZyB0cmFja3MgdGhhdC5cbiAgICAgICAgbGV0IGhhc0ludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgOCAvKiBUb2tlblR5cGUuSU5URVJQT0xBVElPTiAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDE3IC8qIFRva2VuVHlwZS5BVFRSX1ZBTFVFX0lOVEVSUE9MQVRJT04gKi86XG4gICAgICAgICAgICAgICAgICAgIGhhc0ludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdG9rZW4ucGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VOYW1lID0gZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShleHByZXNzaW9uKSB8fCAnSU5URVJQT0xBVElPTic7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBoTmFtZSA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoYmFzZU5hbWUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50W3BoTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0b2tlbi5wYXJ0cy5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IHRva2VuLnNvdXJjZVNwYW5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgUGxhY2Vob2xkZXIoZXhwcmVzc2lvbiwgcGhOYW1lLCB0b2tlbi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5wYXJ0c1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHRva2VuIGlzIHRleHQgb3IgYW4gZW5jb2RlZCBlbnRpdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBmb2xsb3dpbmcgb24gZnJvbSBhIHByZXZpb3VzIHRleHQgbm9kZSB0aGVuIG1lcmdlIGl0IGludG8gdGhhdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGl0IGlzIGZvbGxvd2luZyBhbiBpbnRlcnBvbGF0aW9uLCB0aGVuIGFkZCBhIG5ldyBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIFRleHQkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLnZhbHVlICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLnNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHByZXZpb3VzLnNvdXJjZVNwYW4uc3RhcnQsIHRva2VuLnNvdXJjZVNwYW4uZW5kLCBwcmV2aW91cy5zb3VyY2VTcGFuLmZ1bGxTdGFydCwgcHJldmlvdXMuc291cmNlU3Bhbi5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMih0b2tlbi5wYXJ0c1swXSwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBXaGl0ZXNwYWNlIHJlbW92YWwgbWF5IGhhdmUgaW52YWxpZGF0ZWQgdGhlIGludGVycG9sYXRpb24gc291cmNlLXNwYW5zLlxuICAgICAgICAgICAgcmV1c2VQcmV2aW91c1NvdXJjZVNwYW5zKG5vZGVzLCBwcmV2aW91c0kxOG4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXIobm9kZXMsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZS11c2UgdGhlIHNvdXJjZS1zcGFucyBmcm9tIGBwcmV2aW91c0kxOG5gIG1ldGFkYXRhIGZvciB0aGUgYG5vZGVzYC5cbiAqXG4gKiBXaGl0ZXNwYWNlIHJlbW92YWwgY2FuIGludmFsaWRhdGUgdGhlIHNvdXJjZS1zcGFucyBvZiBpbnRlcnBvbGF0aW9uIG5vZGVzLCBzbyB3ZVxuICogcmV1c2UgdGhlIHNvdXJjZS1zcGFuIHN0b3JlZCBmcm9tIGEgcHJldmlvdXMgcGFzcyBiZWZvcmUgdGhlIHdoaXRlc3BhY2Ugd2FzIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIG5vZGVzIFRoZSBgVGV4dGAgYW5kIGBQbGFjZWhvbGRlcmAgbm9kZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHByZXZpb3VzSTE4biBBbnkgaTE4biBtZXRhZGF0YSBmb3IgdGhlc2UgYG5vZGVzYCBzdG9yZWQgZnJvbSBhIHByZXZpb3VzIHBhc3MuXG4gKi9cbmZ1bmN0aW9uIHJldXNlUHJldmlvdXNTb3VyY2VTcGFucyhub2RlcywgcHJldmlvdXNJMThuKSB7XG4gICAgaWYgKHByZXZpb3VzSTE4biBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVGhlIGBwcmV2aW91c0kxOG5gIGlzIGFuIGkxOG4gYE1lc3NhZ2VgLCBzbyB3ZSBhcmUgcHJvY2Vzc2luZyBhbiBgQXR0cmlidXRlYCB3aXRoIGkxOG5cbiAgICAgICAgLy8gbWV0YWRhdGEuIFRoZSBgTWVzc2FnZWAgc2hvdWxkIGNvbnNpc3Qgb25seSBvZiBhIHNpbmdsZSBgQ29udGFpbmVyYCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICAvLyBwYXJ0cyAoYFRleHRgIGFuZCBgUGxhY2Vob2xkZXJgKSB0byBwcm9jZXNzLlxuICAgICAgICBhc3NlcnRTaW5nbGVDb250YWluZXJNZXNzYWdlKHByZXZpb3VzSTE4bik7XG4gICAgICAgIHByZXZpb3VzSTE4biA9IHByZXZpb3VzSTE4bi5ub2Rlc1swXTtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzSTE4biBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgICAvLyBUaGUgYHByZXZpb3VzSTE4bmAgaXMgYSBgQ29udGFpbmVyYCwgd2hpY2ggbWVhbnMgdGhhdCB0aGlzIGlzIGEgc2Vjb25kIGkxOG4gZXh0cmFjdGlvbiBwYXNzXG4gICAgICAgIC8vIGFmdGVyIHdoaXRlc3BhY2UgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBBU1Qgbm9kZXMuXG4gICAgICAgIGFzc2VydEVxdWl2YWxlbnROb2RlcyhwcmV2aW91c0kxOG4uY2hpbGRyZW4sIG5vZGVzKTtcbiAgICAgICAgLy8gUmV1c2UgdGhlIHNvdXJjZS1zcGFucyBmcm9tIHRoZSBmaXJzdCBwYXNzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2Rlc1tpXS5zb3VyY2VTcGFuID0gcHJldmlvdXNJMThuLmNoaWxkcmVuW2ldLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgYG1lc3NhZ2VgIGNvbnRhaW5zIGV4YWN0bHkgb25lIGBDb250YWluZXJgIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFNpbmdsZUNvbnRhaW5lck1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IG5vZGVzID0gbWVzc2FnZS5ub2RlcztcbiAgICBpZiAobm9kZXMubGVuZ3RoICE9PSAxIHx8ICEobm9kZXNbMF0gaW5zdGFuY2VvZiBDb250YWluZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwcmV2aW91cyBpMThuIG1lc3NhZ2UgLSBleHBlY3RlZCBpdCB0byBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgYENvbnRhaW5lcmAgbm9kZS4nKTtcbiAgICB9XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgYHByZXZpb3VzTm9kZXNgIGFuZCBgbm9kZWAgY29sbGVjdGlvbnMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYW5kXG4gKiBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIGhhdmUgdGhlIHNhbWUgbm9kZSB0eXBlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRFcXVpdmFsZW50Tm9kZXMocHJldmlvdXNOb2Rlcywgbm9kZXMpIHtcbiAgICBpZiAocHJldmlvdXNOb2Rlcy5sZW5ndGggIT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBudW1iZXIgb2YgaTE4biBtZXNzYWdlIGNoaWxkcmVuIGNoYW5nZWQgYmV0d2VlbiBmaXJzdCBhbmQgc2Vjb25kIHBhc3MuJyk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c05vZGVzLnNvbWUoKG5vZGUsIGkpID0+IG5vZGVzW2ldLmNvbnN0cnVjdG9yICE9PSBub2RlLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0eXBlcyBvZiB0aGUgaTE4biBtZXNzYWdlIGNoaWxkcmVuIGNoYW5nZWQgYmV0d2VlbiBmaXJzdCBhbmQgc2Vjb25kIHBhc3MuJyk7XG4gICAgfVxufVxuY29uc3QgX0NVU1RPTV9QSF9FWFAgPSAvXFwvXFwvW1xcc1xcU10qaTE4bltcXHNcXFNdKlxcKFtcXHNcXFNdKnBoW1xcc1xcU10qPVtcXHNcXFNdKihcInwnKShbXFxzXFxTXSo/KVxcMVtcXHNcXFNdKlxcKS9nO1xuZnVuY3Rpb24gZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5zcGxpdChfQ1VTVE9NX1BIX0VYUClbMl07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBbiBpMThuIGVycm9yLlxuICovXG5jbGFzcyBJMThuRXJyb3IgZXh0ZW5kcyBQYXJzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBtc2cpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgbXNnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3Qgc2V0STE4blJlZnMgPSAoaHRtbE5vZGUsIGkxOG5Ob2RlKSA9PiB7XG4gICAgaWYgKGh0bWxOb2RlIGluc3RhbmNlb2YgTm9kZVdpdGhJMThuKSB7XG4gICAgICAgIGlmIChpMThuTm9kZSBpbnN0YW5jZW9mIEljdVBsYWNlaG9sZGVyICYmIGh0bWxOb2RlLmkxOG4gaW5zdGFuY2VvZiBNZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGh0bWwgbm9kZSByZXByZXNlbnRzIGFuIElDVSBidXQgdGhpcyBpcyBhIHNlY29uZCBwcm9jZXNzaW5nIHBhc3MsIGFuZCB0aGUgbGVnYWN5IGlkXG4gICAgICAgICAgICAvLyB3YXMgY29tcHV0ZWQgaW4gdGhlIHByZXZpb3VzIHBhc3MgYW5kIHN0b3JlZCBpbiB0aGUgYGkxOG5gIHByb3BlcnR5IGFzIGEgbWVzc2FnZS5cbiAgICAgICAgICAgIC8vIFdlIGFyZSBhYm91dCB0byB3aXBlIG91dCB0aGF0IHByb3BlcnR5IHNvIGNhcHR1cmUgdGhlIHByZXZpb3VzIG1lc3NhZ2UgdG8gYmUgcmV1c2VkIHdoZW5cbiAgICAgICAgICAgIC8vIGdlbmVyYXRpbmcgdGhlIG1lc3NhZ2UgZm9yIHRoaXMgSUNVIGxhdGVyLiBTZWUgYF9nZW5lcmF0ZUkxOG5NZXNzYWdlKClgLlxuICAgICAgICAgICAgaTE4bk5vZGUucHJldmlvdXNNZXNzYWdlID0gaHRtbE5vZGUuaTE4bjtcbiAgICAgICAgfVxuICAgICAgICBodG1sTm9kZS5pMThuID0gaTE4bk5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpMThuTm9kZTtcbn07XG4vKipcbiAqIFRoaXMgdmlzaXRvciB3YWxrcyBvdmVyIEhUTUwgcGFyc2UgdHJlZSBhbmQgY29udmVydHMgaW5mb3JtYXRpb24gc3RvcmVkIGluXG4gKiBpMThuLXJlbGF0ZWQgYXR0cmlidXRlcyAoXCJpMThuXCIgYW5kIFwiaTE4bi0qXCIpIGludG8gaTE4biBtZXRhIG9iamVjdCB0aGF0IGlzXG4gKiBzdG9yZWQgd2l0aCBvdGhlciBlbGVtZW50J3MgYW5kIGF0dHJpYnV0ZSdzIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBJMThuTWV0YVZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHLCBrZWVwSTE4bkF0dHJzID0gZmFsc2UsIGVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmludGVycG9sYXRpb25Db25maWcgPSBpbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLmtlZXBJMThuQXR0cnMgPSBrZWVwSTE4bkF0dHJzO1xuICAgICAgICB0aGlzLmVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQgPSBlbmFibGVJMThuTGVnYWN5TWVzc2FnZUlkRm9ybWF0O1xuICAgICAgICAvLyB3aGV0aGVyIHZpc2l0ZWQgbm9kZXMgY29udGFpbiBpMThuIGluZm9ybWF0aW9uXG4gICAgICAgIHRoaXMuaGFzSTE4bk1ldGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgIC8vIGkxOG4gbWVzc2FnZSBnZW5lcmF0aW9uIGZhY3RvcnlcbiAgICAgICAgdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UgPSBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkodGhpcy5pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgX2dlbmVyYXRlSTE4bk1lc3NhZ2Uobm9kZXMsIG1ldGEgPSAnJywgdmlzaXROb2RlRm4pIHtcbiAgICAgICAgY29uc3QgeyBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgY3VzdG9tSWQgfSA9IHRoaXMuX3BhcnNlTWV0YWRhdGEobWV0YSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZShub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGN1c3RvbUlkLCB2aXNpdE5vZGVGbik7XG4gICAgICAgIHRoaXMuX3NldE1lc3NhZ2VJZChtZXNzYWdlLCBtZXRhKTtcbiAgICAgICAgdGhpcy5fc2V0TGVnYWN5SWRzKG1lc3NhZ2UsIG1ldGEpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgdmlzaXRBbGxXaXRoRXJyb3JzKG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5vZGVzLm1hcChub2RlID0+IG5vZGUudmlzaXQodGhpcywgbnVsbCkpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChyZXN1bHQsIHRoaXMuX2Vycm9ycyk7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaGFzSTE4bkF0dHJzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0kxOG5NZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgICAgICBjb25zdCBhdHRyc01ldGEgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBlbGVtZW50LmF0dHJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIubmFtZSA9PT0gSTE4Tl9BVFRSKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJvb3QgJ2kxOG4nIG5vZGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkxOG4gPSBlbGVtZW50LmkxOG4gfHwgYXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoZWxlbWVudC5jaGlsZHJlbiwgaTE4biwgc2V0STE4blJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5ub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgbWVzc2FnZSBpZiBpdCBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIG1lc3NhZ2Ugb24gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pMThuID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0ci5uYW1lLnN0YXJ0c1dpdGgoSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJ2kxOG4tKicgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0ci5uYW1lLnNsaWNlKEkxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHJ1c3RlZFR5cGVzU2luayhlbGVtZW50Lm5hbWUsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihhdHRyLCBgVHJhbnNsYXRpbmcgYXR0cmlidXRlICcke25hbWV9JyBpcyBkaXNhbGxvd2VkIGZvciBzZWN1cml0eSByZWFzb25zLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnNNZXRhW25hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9uLWkxOG4gYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBpMThuIG1ldGEgZm9yIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyc01ldGEpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gYXR0cnNNZXRhW2F0dHIubmFtZV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgdHJhbnNsYXRpb24gZm9yIGVtcHR5IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGEgIT09IHVuZGVmaW5lZCAmJiBhdHRyLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmkxOG4gPSB0aGlzLl9nZW5lcmF0ZUkxOG5NZXNzYWdlKFthdHRyXSwgYXR0ci5pMThuIHx8IG1ldGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBJMThuQXR0cnMpIHtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgZWxlbWVudCdzIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8ga2VlcGluZyBvbmx5IG5vbi1pMThuIHJlbGF0ZWQgb25lc1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXR0cnMgPSBhdHRycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uKGV4cGFuc2lvbiwgY3VycmVudE1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBleHBhbnNpb24uaTE4bjtcbiAgICAgICAgdGhpcy5oYXNJMThuTWV0YSA9IHRydWU7XG4gICAgICAgIGlmIChtZXRhIGluc3RhbmNlb2YgSWN1UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICAgIC8vIHNldCBJQ1UgcGxhY2Vob2xkZXIgbmFtZSAoZS5nLiBcIklDVV8xXCIpLFxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIHdoaWxlIHByb2Nlc3Npbmcgcm9vdCBlbGVtZW50IGNvbnRlbnRzLFxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIHJlZmVyZW5jZSBpdCB3aGVuIHdlIG91dHB1dCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG1ldGEubmFtZTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9nZW5lcmF0ZUkxOG5NZXNzYWdlKFtleHBhbnNpb25dLCBtZXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGljdSA9IGljdUZyb21JMThuTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGljdS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEFsc28gdXBkYXRlIHRoZSBwbGFjZWhvbGRlclRvTWVzc2FnZSBtYXAgd2l0aCB0aGlzIG5ldyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgY3VycmVudE1lc3NhZ2UucGxhY2Vob2xkZXJUb01lc3NhZ2VbbmFtZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSUNVIGlzIGEgdG9wIGxldmVsIG1lc3NhZ2UsIHRyeSB0byB1c2UgbWV0YWRhdGEgZnJvbSBjb250YWluZXIgZWxlbWVudCBpZiBwcm92aWRlZCB2aWFcbiAgICAgICAgICAgIC8vIGBjb250ZXh0YCBhcmd1bWVudC4gTm90ZTogY29udGV4dCBtYXkgbm90IGJlIGF2YWlsYWJsZSBmb3Igc3RhbmRhbG9uZSBJQ1VzICh3aXRob3V0XG4gICAgICAgICAgICAvLyB3cmFwcGluZyBlbGVtZW50KSwgc28gZmFsbGJhY2sgdG8gSUNVIG1ldGFkYXRhIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLl9nZW5lcmF0ZUkxOG5NZXNzYWdlKFtleHBhbnNpb25dLCBjdXJyZW50TWVzc2FnZSB8fCBtZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBleHBhbnNpb24uaTE4biA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBleHBhbnNpb247XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9XG4gICAgdmlzaXRDb21tZW50KGNvbW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShleHBhbnNpb25DYXNlKSB7XG4gICAgICAgIHJldHVybiBleHBhbnNpb25DYXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgZ2VuZXJhbCBmb3JtIGBtZXRhYCBwYXNzZWQgaW50byBleHRyYWN0IHRoZSBleHBsaWNpdCBtZXRhZGF0YSBuZWVkZWQgdG8gY3JlYXRlIGFcbiAgICAgKiBgTWVzc2FnZWAuXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdGhyZWUgcG9zc2liaWxpdGllcyBmb3IgdGhlIGBtZXRhYCB2YXJpYWJsZVxuICAgICAqIDEpIGEgc3RyaW5nIGZyb20gYW4gYGkxOG5gIHRlbXBsYXRlIGF0dHJpYnV0ZTogcGFyc2UgaXQgdG8gZXh0cmFjdCB0aGUgbWV0YWRhdGEgdmFsdWVzLlxuICAgICAqIDIpIGEgYE1lc3NhZ2VgIGZyb20gYSBwcmV2aW91cyBwcm9jZXNzaW5nIHBhc3M6IHJldXNlIHRoZSBtZXRhZGF0YSB2YWx1ZXMgaW4gdGhlIG1lc3NhZ2UuXG4gICAgICogNCkgb3RoZXI6IGlnbm9yZSB0aGlzIGFuZCBqdXN0IHByb2Nlc3MgdGhlIG1lc3NhZ2UgbWV0YWRhdGEgYXMgbm9ybWFsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWV0YSB0aGUgYnVja2V0IHRoYXQgaG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB0aGUgcGFyc2VkIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIF9wYXJzZU1ldGFkYXRhKG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyA/IHBhcnNlSTE4bk1ldGEobWV0YSkgOlxuICAgICAgICAgICAgbWV0YSBpbnN0YW5jZW9mIE1lc3NhZ2UgPyBtZXRhIDpcbiAgICAgICAgICAgICAgICB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgKG9yIHJlc3RvcmUpIG1lc3NhZ2UgaWQgaWYgbm90IHNwZWNpZmllZCBhbHJlYWR5LlxuICAgICAqL1xuICAgIF9zZXRNZXNzYWdlSWQobWVzc2FnZSwgbWV0YSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UuaWQpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSBtZXRhIGluc3RhbmNlb2YgTWVzc2FnZSAmJiBtZXRhLmlkIHx8IGRlY2ltYWxEaWdlc3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBgbWVzc2FnZWAgd2l0aCBhIGBsZWdhY3lJZGAgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgdGhlIG1lc3NhZ2Ugd2hvc2UgbGVnYWN5IGlkIHNob3VsZCBiZSBzZXRcbiAgICAgKiBAcGFyYW0gbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbWVzc2FnZSBiZWluZyBwcm9jZXNzZWRcbiAgICAgKi9cbiAgICBfc2V0TGVnYWN5SWRzKG1lc3NhZ2UsIG1ldGEpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCkge1xuICAgICAgICAgICAgbWVzc2FnZS5sZWdhY3lJZHMgPSBbY29tcHV0ZURpZ2VzdChtZXNzYWdlKSwgY29tcHV0ZURlY2ltYWxEaWdlc3QobWVzc2FnZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gVGhpcyBvY2N1cnMgaWYgd2UgYXJlIGRvaW5nIHRoZSAybmQgcGFzcyBhZnRlciB3aGl0ZXNwYWNlIHJlbW92YWwgKHNlZSBgcGFyc2VUZW1wbGF0ZSgpYCBpblxuICAgICAgICAgICAgLy8gYHBhY2thZ2VzL2NvbXBpbGVyL3NyYy9yZW5kZXIzL3ZpZXcvdGVtcGxhdGUudHNgKS5cbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSB3ZSB3YW50IHRvIHJldXNlIHRoZSBsZWdhY3kgbWVzc2FnZSBnZW5lcmF0ZWQgaW4gdGhlIDFzdCBwYXNzIChzZWVcbiAgICAgICAgICAgIC8vIGBzZXRJMThuUmVmcygpYCkuXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c01lc3NhZ2UgPSBtZXRhIGluc3RhbmNlb2YgTWVzc2FnZSA/IG1ldGEgOlxuICAgICAgICAgICAgICAgIG1ldGEgaW5zdGFuY2VvZiBJY3VQbGFjZWhvbGRlciA/IG1ldGEucHJldmlvdXNNZXNzYWdlIDpcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICAgICAgbWVzc2FnZS5sZWdhY3lJZHMgPSBwcmV2aW91c01lc3NhZ2UgPyBwcmV2aW91c01lc3NhZ2UubGVnYWN5SWRzIDogW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlcG9ydEVycm9yKG5vZGUsIG1zZykge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbXNnKSk7XG4gICAgfVxufVxuLyoqIEkxOG4gc2VwYXJhdG9ycyBmb3IgbWV0YWRhdGEgKiovXG5jb25zdCBJMThOX01FQU5JTkdfU0VQQVJBVE9SID0gJ3wnO1xuY29uc3QgSTE4Tl9JRF9TRVBBUkFUT1IgPSAnQEAnO1xuLyoqXG4gKiBQYXJzZXMgaTE4biBtZXRhcyBsaWtlOlxuICogIC0gXCJAQGlkXCIsXG4gKiAgLSBcImRlc2NyaXB0aW9uW0BAaWRdXCIsXG4gKiAgLSBcIm1lYW5pbmd8ZGVzY3JpcHRpb25bQEBpZF1cIlxuICogYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFyc2VkIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gbWV0YSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIGkxOG4gbWV0YVxuICogQHJldHVybnMgT2JqZWN0IHdpdGggaWQsIG1lYW5pbmcgYW5kIGRlc2NyaXB0aW9uIGZpZWxkc1xuICovXG5mdW5jdGlvbiBwYXJzZUkxOG5NZXRhKG1ldGEgPSAnJykge1xuICAgIGxldCBjdXN0b21JZDtcbiAgICBsZXQgbWVhbmluZztcbiAgICBsZXQgZGVzY3JpcHRpb247XG4gICAgbWV0YSA9IG1ldGEudHJpbSgpO1xuICAgIGlmIChtZXRhKSB7XG4gICAgICAgIGNvbnN0IGlkSW5kZXggPSBtZXRhLmluZGV4T2YoSTE4Tl9JRF9TRVBBUkFUT1IpO1xuICAgICAgICBjb25zdCBkZXNjSW5kZXggPSBtZXRhLmluZGV4T2YoSTE4Tl9NRUFOSU5HX1NFUEFSQVRPUik7XG4gICAgICAgIGxldCBtZWFuaW5nQW5kRGVzYztcbiAgICAgICAgW21lYW5pbmdBbmREZXNjLCBjdXN0b21JZF0gPVxuICAgICAgICAgICAgKGlkSW5kZXggPiAtMSkgPyBbbWV0YS5zbGljZSgwLCBpZEluZGV4KSwgbWV0YS5zbGljZShpZEluZGV4ICsgMildIDogW21ldGEsICcnXTtcbiAgICAgICAgW21lYW5pbmcsIGRlc2NyaXB0aW9uXSA9IChkZXNjSW5kZXggPiAtMSkgP1xuICAgICAgICAgICAgW21lYW5pbmdBbmREZXNjLnNsaWNlKDAsIGRlc2NJbmRleCksIG1lYW5pbmdBbmREZXNjLnNsaWNlKGRlc2NJbmRleCArIDEpXSA6XG4gICAgICAgICAgICBbJycsIG1lYW5pbmdBbmREZXNjXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY3VzdG9tSWQsIG1lYW5pbmcsIGRlc2NyaXB0aW9uIH07XG59XG4vLyBDb252ZXJ0cyBpMThuIG1ldGEgaW5mb3JtYXRpb24gZm9yIGEgbWVzc2FnZSAoaWQsIGRlc2NyaXB0aW9uLCBtZWFuaW5nKVxuLy8gdG8gYSBKc0RvYyBzdGF0ZW1lbnQgZm9ybWF0dGVkIGFzIGV4cGVjdGVkIGJ5IHRoZSBDbG9zdXJlIGNvbXBpbGVyLlxuZnVuY3Rpb24gaTE4bk1ldGFUb0pTRG9jKG1ldGEpIHtcbiAgICBjb25zdCB0YWdzID0gW107XG4gICAgaWYgKG1ldGEuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdGFncy5wdXNoKHsgdGFnTmFtZTogXCJkZXNjXCIgLyogby5KU0RvY1RhZ05hbWUuRGVzYyAqLywgdGV4dDogbWV0YS5kZXNjcmlwdGlvbiB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFN1cHByZXNzIHRoZSBKU0NvbXBpbGVyIHdhcm5pbmcgdGhhdCBhIGBAZGVzY2Agd2FzIG5vdCBnaXZlbiBmb3IgdGhpcyBtZXNzYWdlLlxuICAgICAgICB0YWdzLnB1c2goeyB0YWdOYW1lOiBcInN1cHByZXNzXCIgLyogby5KU0RvY1RhZ05hbWUuU3VwcHJlc3MgKi8sIHRleHQ6ICd7bXNnRGVzY3JpcHRpb25zfScgfSk7XG4gICAgfVxuICAgIGlmIChtZXRhLm1lYW5pbmcpIHtcbiAgICAgICAgdGFncy5wdXNoKHsgdGFnTmFtZTogXCJtZWFuaW5nXCIgLyogby5KU0RvY1RhZ05hbWUuTWVhbmluZyAqLywgdGV4dDogbWV0YS5tZWFuaW5nIH0pO1xuICAgIH1cbiAgICByZXR1cm4ganNEb2NDb21tZW50KHRhZ3MpO1xufVxuXG4vKiogQ2xvc3VyZSB1c2VzIGBnb29nLmdldE1zZyhtZXNzYWdlKWAgdG8gbG9va3VwIHRyYW5zbGF0aW9ucyAqL1xuY29uc3QgR09PR19HRVRfTVNHID0gJ2dvb2cuZ2V0TXNnJztcbi8qKlxuICogR2VuZXJhdGVzIGEgYGdvb2cuZ2V0TXNnKClgIHN0YXRlbWVudCBhbmQgcmVhc3NpZ25tZW50LiBUaGUgdGVtcGxhdGU6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiBpMThuPlNlbnQgZnJvbSB7eyBzZW5kZXIgfX0gdG8gPHNwYW4gY2xhc3M9XCJyZWNlaXZlclwiPnt7IHJlY2VpdmVyIH19PC9zcGFuPjwvZGl2PlxuICogYGBgXG4gKlxuICogR2VuZXJhdGVzOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IE1TR19GT08gPSBnb29nLmdldE1zZyhcbiAqICAgLy8gTWVzc2FnZSB0ZW1wbGF0ZS5cbiAqICAgJ1NlbnQgZnJvbSB7JGludGVycG9sYXRpb259IHRvIHskc3RhcnRUYWdTcGFufXskaW50ZXJwb2xhdGlvbl8xfXskY2xvc2VUYWdTcGFufS4nLFxuICogICAvLyBQbGFjZWhvbGRlciB2YWx1ZXMsIHNldCB0byBtYWdpYyBzdHJpbmdzIHdoaWNoIGdldCByZXBsYWNlZCBieSB0aGUgQW5ndWxhciBydW50aW1lLlxuICogICB7XG4gKiAgICAgJ2ludGVycG9sYXRpb24nOiAnXFx1RkZGRDBcXHVGRkZEJyxcbiAqICAgICAnc3RhcnRUYWdTcGFuJzogJ1xcdUZGRkQxXFx1RkZGRCcsXG4gKiAgICAgJ2ludGVycG9sYXRpb25fMSc6ICdcXHVGRkZEMlxcdUZGRkQnLFxuICogICAgICdjbG9zZVRhZ1NwYW4nOiAnXFx1RkZGRDNcXHVGRkZEJyxcbiAqICAgfSxcbiAqICAgLy8gT3B0aW9ucyBiYWcuXG4gKiAgIHtcbiAqICAgICAvLyBNYXBzIGVhY2ggcGxhY2Vob2xkZXIgdG8gdGhlIG9yaWdpbmFsIEFuZ3VsYXIgc291cmNlIGNvZGUgd2hpY2ggZ2VuZXJhdGVzIGl0J3MgdmFsdWUuXG4gKiAgICAgb3JpZ2luYWxfY29kZToge1xuICogICAgICAgJ2ludGVycG9sYXRpb24nOiAne3sgc2VuZGVyIH19JyxcbiAqICAgICAgICdzdGFydFRhZ1NwYW4nOiAnPHNwYW4gY2xhc3M9XCJyZWNlaXZlclwiPicsXG4gKiAgICAgICAnaW50ZXJwbG9hdGlvbl8xJzogJ3t7IHJlY2VpdmVyIH19JyxcbiAqICAgICAgICdjbG9zZVRhZ1NwYW4nOiAnPC9zcGFuPicsXG4gKiAgICAgfSxcbiAqICAgfSxcbiAqICk7XG4gKiBjb25zdCBJMThOXzAgPSBNU0dfRk9PO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUdvb2dsZUdldE1zZ1N0YXRlbWVudHModmFyaWFibGUkMSwgbWVzc2FnZSwgY2xvc3VyZVZhciwgcGxhY2Vob2xkZXJWYWx1ZXMpIHtcbiAgICBjb25zdCBtZXNzYWdlU3RyaW5nID0gc2VyaWFsaXplSTE4bk1lc3NhZ2VGb3JHZXRNc2cobWVzc2FnZSk7XG4gICAgY29uc3QgYXJncyA9IFtsaXRlcmFsKG1lc3NhZ2VTdHJpbmcpXTtcbiAgICBpZiAoT2JqZWN0LmtleXMocGxhY2Vob2xkZXJWYWx1ZXMpLmxlbmd0aCkge1xuICAgICAgICAvLyBNZXNzYWdlIHRlbXBsYXRlIHBhcmFtZXRlcnMgY29udGFpbmluZyB0aGUgbWFnaWMgc3RyaW5ncyByZXBsYWNlZCBieSB0aGUgQW5ndWxhciBydW50aW1lIHdpdGhcbiAgICAgICAgLy8gcmVhbCBkYXRhLCBlLmcuIGB7J2ludGVycG9sYXRpb24nOiAnXFx1RkZGRDBcXHVGRkZEJ31gLlxuICAgICAgICBhcmdzLnB1c2gobWFwTGl0ZXJhbChmb3JtYXRJMThuUGxhY2Vob2xkZXJOYW1lc0luTWFwKHBsYWNlaG9sZGVyVmFsdWVzLCB0cnVlIC8qIHVzZUNhbWVsQ2FzZSAqLyksIHRydWUgLyogcXVvdGVkICovKSk7XG4gICAgICAgIC8vIE1lc3NhZ2Ugb3B0aW9ucyBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIG9yaWdpbmFsIHNvdXJjZSBjb2RlIGZvciBwbGFjZWhvbGRlcnMgKGFzIHRoZXkgYXJlXG4gICAgICAgIC8vIHByZXNlbnQgaW4gYSB0ZW1wbGF0ZSwgZS5nLlxuICAgICAgICAvLyBge29yaWdpbmFsX2NvZGU6IHsnaW50ZXJwb2xhdGlvbic6ICd7eyBuYW1lIH19JywgJ3N0YXJ0VGFnU3Bhbic6ICc8c3Bhbj4nfX1gLlxuICAgICAgICBhcmdzLnB1c2gobWFwTGl0ZXJhbCh7XG4gICAgICAgICAgICBvcmlnaW5hbF9jb2RlOiBsaXRlcmFsTWFwKE9iamVjdC5rZXlzKHBsYWNlaG9sZGVyVmFsdWVzKVxuICAgICAgICAgICAgICAgIC5tYXAoKHBhcmFtKSA9PiAoe1xuICAgICAgICAgICAgICAgIGtleTogZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZShwYXJhbSksXG4gICAgICAgICAgICAgICAgcXVvdGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBtZXNzYWdlLnBsYWNlaG9sZGVyc1twYXJhbV0gP1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgc291cmNlIHNwYW4gZm9yIHR5cGljYWwgcGxhY2Vob2xkZXIgaWYgaXQgZXhpc3RzLlxuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKG1lc3NhZ2UucGxhY2Vob2xkZXJzW3BhcmFtXS5zb3VyY2VTcGFuLnRvU3RyaW5nKCkpIDpcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIG11c3QgYmUgYW4gSUNVIGV4cHJlc3Npb24sIGdldCBpdCdzIHNvdXJjZSBzcGFuLlxuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsKG1lc3NhZ2UucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGFyYW1dXG4gICAgICAgICAgICAgICAgICAgICAgICAubm9kZXMubWFwKChub2RlKSA9PiBub2RlLnNvdXJjZVNwYW4udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcnKSksXG4gICAgICAgICAgICB9KSkpLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8vIC8qKlxuICAgIC8vICAqIEBkZXNjIGRlc2NyaXB0aW9uIG9mIG1lc3NhZ2VcbiAgICAvLyAgKiBAbWVhbmluZyBtZWFuaW5nIG9mIG1lc3NhZ2VcbiAgICAvLyAgKi9cbiAgICAvLyBjb25zdCBNU0dfLi4uID0gZ29vZy5nZXRNc2coLi4pO1xuICAgIC8vIEkxOE5fWCA9IE1TR18uLi47XG4gICAgY29uc3QgZ29vZ0dldE1zZ1N0bXQgPSBjbG9zdXJlVmFyLnNldCh2YXJpYWJsZShHT09HX0dFVF9NU0cpLmNhbGxGbihhcmdzKSkudG9Db25zdERlY2woKTtcbiAgICBnb29nR2V0TXNnU3RtdC5hZGRMZWFkaW5nQ29tbWVudChpMThuTWV0YVRvSlNEb2MobWVzc2FnZSkpO1xuICAgIGNvbnN0IGkxOG5Bc3NpZ25tZW50U3RtdCA9IG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KHZhcmlhYmxlJDEuc2V0KGNsb3N1cmVWYXIpKTtcbiAgICByZXR1cm4gW2dvb2dHZXRNc2dTdG10LCBpMThuQXNzaWdubWVudFN0bXRdO1xufVxuLyoqXG4gKiBUaGlzIHZpc2l0b3Igd2Fsa3Mgb3ZlciBpMThuIHRyZWUgYW5kIGdlbmVyYXRlcyBpdHMgc3RyaW5nIHJlcHJlc2VudGF0aW9uLCBpbmNsdWRpbmcgSUNVcyBhbmRcbiAqIHBsYWNlaG9sZGVycyBpbiBgeyRwbGFjZWhvbGRlcn1gIChmb3IgcGxhaW4gbWVzc2FnZXMpIG9yIGB7UExBQ0VIT0xERVJ9YCAoaW5zaWRlIElDVXMpIGZvcm1hdC5cbiAqL1xuY2xhc3MgR2V0TXNnU2VyaWFsaXplclZpc2l0b3Ige1xuICAgIGZvcm1hdFBoKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBgeyQke2Zvcm1hdEkxOG5QbGFjZWhvbGRlck5hbWUodmFsdWUpfX1gO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1KSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVJY3VOb2RlKGljdSk7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgcmV0dXJuIHBoLmlzVm9pZCA/XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBoKHBoLnN0YXJ0TmFtZSkgOlxuICAgICAgICAgICAgYCR7dGhpcy5mb3JtYXRQaChwaC5zdGFydE5hbWUpfSR7cGguY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKS5qb2luKCcnKX0ke3RoaXMuZm9ybWF0UGgocGguY2xvc2VOYW1lKX1gO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFBoKHBoLm5hbWUpO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFBoKHBoLm5hbWUpO1xuICAgIH1cbn1cbmNvbnN0IHNlcmlhbGl6ZXJWaXNpdG9yID0gbmV3IEdldE1zZ1NlcmlhbGl6ZXJWaXNpdG9yKCk7XG5mdW5jdGlvbiBzZXJpYWxpemVJMThuTWVzc2FnZUZvckdldE1zZyhtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2Uubm9kZXMubWFwKG5vZGUgPT4gbm9kZS52aXNpdChzZXJpYWxpemVyVmlzaXRvciwgbnVsbCkpLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbGl6ZVN0YXRlbWVudHModmFyaWFibGUsIG1lc3NhZ2UsIHBhcmFtcykge1xuICAgIGNvbnN0IHsgbWVzc2FnZVBhcnRzLCBwbGFjZUhvbGRlcnMgfSA9IHNlcmlhbGl6ZUkxOG5NZXNzYWdlRm9yTG9jYWxpemUobWVzc2FnZSk7XG4gICAgY29uc3Qgc291cmNlU3BhbiA9IGdldFNvdXJjZVNwYW4obWVzc2FnZSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbnMgPSBwbGFjZUhvbGRlcnMubWFwKHBoID0+IHBhcmFtc1twaC50ZXh0XSk7XG4gICAgY29uc3QgbG9jYWxpemVkU3RyaW5nJDEgPSBsb2NhbGl6ZWRTdHJpbmcobWVzc2FnZSwgbWVzc2FnZVBhcnRzLCBwbGFjZUhvbGRlcnMsIGV4cHJlc3Npb25zLCBzb3VyY2VTcGFuKTtcbiAgICBjb25zdCB2YXJpYWJsZUluaXRpYWxpemF0aW9uID0gdmFyaWFibGUuc2V0KGxvY2FsaXplZFN0cmluZyQxKTtcbiAgICByZXR1cm4gW25ldyBFeHByZXNzaW9uU3RhdGVtZW50KHZhcmlhYmxlSW5pdGlhbGl6YXRpb24pXTtcbn1cbi8qKlxuICogVGhpcyB2aXNpdG9yIHdhbGtzIG92ZXIgYW4gaTE4biB0cmVlLCBjYXB0dXJpbmcgbGl0ZXJhbCBzdHJpbmdzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKlxuICogVGhlIHJlc3VsdCBjYW4gYmUgdXNlZCBmb3IgZ2VuZXJhdGluZyB0aGUgYCRsb2NhbGl6ZWAgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxzLlxuICovXG5jbGFzcyBMb2NhbGl6ZVNlcmlhbGl6ZXJWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihwbGFjZWhvbGRlclRvTWVzc2FnZSwgcGllY2VzKSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2UgPSBwbGFjZWhvbGRlclRvTWVzc2FnZTtcbiAgICAgICAgdGhpcy5waWVjZXMgPSBwaWVjZXM7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlc1t0aGlzLnBpZWNlcy5sZW5ndGggLSAxXSBpbnN0YW5jZW9mIExpdGVyYWxQaWVjZSkge1xuICAgICAgICAgICAgLy8gVHdvIGxpdGVyYWwgcGllY2VzIGluIGEgcm93IG1lYW5zIHRoYXQgdGhlcmUgd2FzIHNvbWUgY29tbWVudCBub2RlIGluLWJldHdlZW4uXG4gICAgICAgICAgICB0aGlzLnBpZWNlc1t0aGlzLnBpZWNlcy5sZW5ndGggLSAxXS50ZXh0ICs9IHRleHQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3Bhbih0ZXh0LnNvdXJjZVNwYW4uZnVsbFN0YXJ0LCB0ZXh0LnNvdXJjZVNwYW4uZW5kLCB0ZXh0LnNvdXJjZVNwYW4uZnVsbFN0YXJ0LCB0ZXh0LnNvdXJjZVNwYW4uZGV0YWlscyk7XG4gICAgICAgICAgICB0aGlzLnBpZWNlcy5wdXNoKG5ldyBMaXRlcmFsUGllY2UodGV4dC52YWx1ZSwgc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSkge1xuICAgICAgICB0aGlzLnBpZWNlcy5wdXNoKG5ldyBMaXRlcmFsUGllY2Uoc2VyaWFsaXplSWN1Tm9kZShpY3UpLCBpY3Uuc291cmNlU3BhbikpO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMucGllY2VzLnB1c2godGhpcy5jcmVhdGVQbGFjZWhvbGRlclBpZWNlKHBoLnN0YXJ0TmFtZSwgKF9hID0gcGguc3RhcnRTb3VyY2VTcGFuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwaC5zb3VyY2VTcGFuKSk7XG4gICAgICAgIGlmICghcGguaXNWb2lkKSB7XG4gICAgICAgICAgICBwaC5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMucGllY2VzLnB1c2godGhpcy5jcmVhdGVQbGFjZWhvbGRlclBpZWNlKHBoLmNsb3NlTmFtZSwgKF9iID0gcGguZW5kU291cmNlU3BhbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcGguc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgdGhpcy5waWVjZXMucHVzaCh0aGlzLmNyZWF0ZVBsYWNlaG9sZGVyUGllY2UocGgubmFtZSwgcGguc291cmNlU3BhbikpO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHRoaXMucGllY2VzLnB1c2godGhpcy5jcmVhdGVQbGFjZWhvbGRlclBpZWNlKHBoLm5hbWUsIHBoLnNvdXJjZVNwYW4sIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGgubmFtZV0pKTtcbiAgICB9XG4gICAgY3JlYXRlUGxhY2Vob2xkZXJQaWVjZShuYW1lLCBzb3VyY2VTcGFuLCBhc3NvY2lhdGVkTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyUGllY2UoZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZShuYW1lLCAvKiB1c2VDYW1lbENhc2UgKi8gZmFsc2UpLCBzb3VyY2VTcGFuLCBhc3NvY2lhdGVkTWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXJpYWxpemUgYW4gaTE4biBtZXNzYWdlIGludG8gdHdvIGFycmF5czogbWVzc2FnZVBhcnRzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKlxuICogVGhlc2UgYXJyYXlzIHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSBgJGxvY2FsaXplYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgc2VyaWFsaXplZC5cbiAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtZXNzYWdlUGFydHMgYW5kIHBsYWNlaG9sZGVycy5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplSTE4bk1lc3NhZ2VGb3JMb2NhbGl6ZShtZXNzYWdlKSB7XG4gICAgY29uc3QgcGllY2VzID0gW107XG4gICAgY29uc3Qgc2VyaWFsaXplclZpc2l0b3IgPSBuZXcgTG9jYWxpemVTZXJpYWxpemVyVmlzaXRvcihtZXNzYWdlLnBsYWNlaG9sZGVyVG9NZXNzYWdlLCBwaWVjZXMpO1xuICAgIG1lc3NhZ2Uubm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUudmlzaXQoc2VyaWFsaXplclZpc2l0b3IpKTtcbiAgICByZXR1cm4gcHJvY2Vzc01lc3NhZ2VQaWVjZXMocGllY2VzKTtcbn1cbmZ1bmN0aW9uIGdldFNvdXJjZVNwYW4obWVzc2FnZSkge1xuICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IG1lc3NhZ2Uubm9kZXNbMF07XG4gICAgY29uc3QgZW5kTm9kZSA9IG1lc3NhZ2Uubm9kZXNbbWVzc2FnZS5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydE5vZGUuc291cmNlU3Bhbi5mdWxsU3RhcnQsIGVuZE5vZGUuc291cmNlU3Bhbi5lbmQsIHN0YXJ0Tm9kZS5zb3VyY2VTcGFuLmZ1bGxTdGFydCwgc3RhcnROb2RlLnNvdXJjZVNwYW4uZGV0YWlscyk7XG59XG4vKipcbiAqIENvbnZlcnQgdGhlIGxpc3Qgb2Ygc2VyaWFsaXplZCBNZXNzYWdlUGllY2VzIGludG8gdHdvIGFycmF5cy5cbiAqXG4gKiBPbmUgY29udGFpbnMgdGhlIGxpdGVyYWwgc3RyaW5nIHBpZWNlcyBhbmQgdGhlIG90aGVyIHRoZSBwbGFjZWhvbGRlcnMgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5XG4gKiBleHByZXNzaW9ucyB3aGVuIHJlbmRlcmluZyBgJGxvY2FsaXplYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gKlxuICogQHBhcmFtIHBpZWNlcyBUaGUgcGllY2VzIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWVzc2FnZVBhcnRzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUGllY2VzKHBpZWNlcykge1xuICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHBsYWNlSG9sZGVycyA9IFtdO1xuICAgIGlmIChwaWVjZXNbMF0gaW5zdGFuY2VvZiBQbGFjZWhvbGRlclBpZWNlKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwaWVjZSB3YXMgYSBwbGFjZWhvbGRlciBzbyB3ZSBuZWVkIHRvIGFkZCBhbiBpbml0aWFsIGVtcHR5IG1lc3NhZ2UgcGFydC5cbiAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY3JlYXRlRW1wdHlNZXNzYWdlUGFydChwaWVjZXNbMF0uc291cmNlU3Bhbi5zdGFydCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGllY2VzW2ldO1xuICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIExpdGVyYWxQaWVjZSkge1xuICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbGFjZUhvbGRlcnMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIGlmIChwaWVjZXNbaSAtIDFdIGluc3RhbmNlb2YgUGxhY2Vob2xkZXJQaWVjZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdlcmUgdHdvIHBsYWNlaG9sZGVycyBpbiBhIHJvdywgc28gd2UgbmVlZCB0byBhZGQgYW4gZW1wdHkgbWVzc2FnZSBwYXJ0LlxuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGNyZWF0ZUVtcHR5TWVzc2FnZVBhcnQocGllY2VzW2kgLSAxXS5zb3VyY2VTcGFuLmVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgUGxhY2Vob2xkZXJQaWVjZSkge1xuICAgICAgICAvLyBUaGUgbGFzdCBwaWVjZSB3YXMgYSBwbGFjZWhvbGRlciBzbyB3ZSBuZWVkIHRvIGFkZCBhIGZpbmFsIGVtcHR5IG1lc3NhZ2UgcGFydC5cbiAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY3JlYXRlRW1wdHlNZXNzYWdlUGFydChwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdLnNvdXJjZVNwYW4uZW5kKSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2VQYXJ0cywgcGxhY2VIb2xkZXJzIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eU1lc3NhZ2VQYXJ0KGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsUGllY2UoJycsIG5ldyBQYXJzZVNvdXJjZVNwYW4obG9jYXRpb24sIGxvY2F0aW9uKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gU2VsZWN0b3IgYXR0cmlidXRlIG5hbWUgb2YgYDxuZy1jb250ZW50PmBcbmNvbnN0IE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIgPSAnc2VsZWN0Jztcbi8vIEF0dHJpYnV0ZSBuYW1lIG9mIGBuZ1Byb2plY3RBc2AuXG5jb25zdCBOR19QUk9KRUNUX0FTX0FUVFJfTkFNRSA9ICduZ1Byb2plY3RBcyc7XG4vLyBHbG9iYWwgc3ltYm9scyBhdmFpbGFibGUgb25seSBpbnNpZGUgZXZlbnQgYmluZGluZ3MuXG5jb25zdCBFVkVOVF9CSU5ESU5HX1NDT1BFX0dMT0JBTFMgPSBuZXcgU2V0KFsnJGV2ZW50J10pO1xuLy8gTGlzdCBvZiBzdXBwb3J0ZWQgZ2xvYmFsIHRhcmdldHMgZm9yIGV2ZW50IGxpc3RlbmVyc1xuY29uc3QgR0xPQkFMX1RBUkdFVF9SRVNPTFZFUlMgPSBuZXcgTWFwKFtbJ3dpbmRvdycsIElkZW50aWZpZXJzLnJlc29sdmVXaW5kb3ddLCBbJ2RvY3VtZW50JywgSWRlbnRpZmllcnMucmVzb2x2ZURvY3VtZW50XSwgWydib2R5JywgSWRlbnRpZmllcnMucmVzb2x2ZUJvZHldXSk7XG5jb25zdCBMRUFESU5HX1RSSVZJQV9DSEFSUyA9IFsnICcsICdcXG4nLCAnXFxyJywgJ1xcdCddO1xuLy8gIGlmIChyZiAmIGZsYWdzKSB7IC4uIH1cbmZ1bmN0aW9uIHJlbmRlckZsYWdDaGVja0lmU3RtdChmbGFncywgc3RhdGVtZW50cykge1xuICAgIHJldHVybiBpZlN0bXQodmFyaWFibGUoUkVOREVSX0ZMQUdTKS5iaXR3aXNlQW5kKGxpdGVyYWwoZmxhZ3MpLCBudWxsLCBmYWxzZSksIHN0YXRlbWVudHMpO1xufVxuZnVuY3Rpb24gcHJlcGFyZUV2ZW50TGlzdGVuZXJQYXJhbWV0ZXJzKGV2ZW50QXN0LCBoYW5kbGVyTmFtZSA9IG51bGwsIHNjb3BlID0gbnVsbCkge1xuICAgIGNvbnN0IHsgdHlwZSwgbmFtZSwgdGFyZ2V0LCBwaGFzZSwgaGFuZGxlciB9ID0gZXZlbnRBc3Q7XG4gICAgaWYgKHRhcmdldCAmJiAhR0xPQkFMX1RBUkdFVF9SRVNPTFZFUlMuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGdsb2JhbCB0YXJnZXQgJyR7dGFyZ2V0fScgZGVmaW5lZCBmb3IgJyR7bmFtZX0nIGV2ZW50LlxuICAgICAgICBTdXBwb3J0ZWQgbGlzdCBvZiBnbG9iYWwgdGFyZ2V0czogJHtBcnJheS5mcm9tKEdMT0JBTF9UQVJHRVRfUkVTT0xWRVJTLmtleXMoKSl9LmApO1xuICAgIH1cbiAgICBjb25zdCBldmVudEFyZ3VtZW50TmFtZSA9ICckZXZlbnQnO1xuICAgIGNvbnN0IGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3NlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbXBsaWNpdFJlY2VpdmVyRXhwciA9IChzY29wZSA9PT0gbnVsbCB8fCBzY29wZS5iaW5kaW5nTGV2ZWwgPT09IDApID9cbiAgICAgICAgdmFyaWFibGUoQ09OVEVYVF9OQU1FKSA6XG4gICAgICAgIHNjb3BlLmdldE9yQ3JlYXRlU2hhcmVkQ29udGV4dFZhcigwKTtcbiAgICBjb25zdCBiaW5kaW5nU3RhdGVtZW50cyA9IGNvbnZlcnRBY3Rpb25CaW5kaW5nKHNjb3BlLCBpbXBsaWNpdFJlY2VpdmVyRXhwciwgaGFuZGxlciwgJ2InLCBldmVudEFzdC5oYW5kbGVyU3BhbiwgaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzLCBFVkVOVF9CSU5ESU5HX1NDT1BFX0dMT0JBTFMpO1xuICAgIGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcbiAgICBjb25zdCB2YXJpYWJsZURlY2xhcmF0aW9ucyA9IHNjb3BlID09PSBudWxsIHx8IHNjb3BlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY29wZS52YXJpYWJsZURlY2xhcmF0aW9ucygpO1xuICAgIGNvbnN0IHJlc3RvcmVWaWV3U3RhdGVtZW50ID0gc2NvcGUgPT09IG51bGwgfHwgc2NvcGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjb3BlLnJlc3RvcmVWaWV3U3RhdGVtZW50KCk7XG4gICAgaWYgKHZhcmlhYmxlRGVjbGFyYXRpb25zKSB7XG4gICAgICAgIC8vIGB2YXJpYWJsZURlY2xhcmF0aW9uc2AgbmVlZHMgdG8gcnVuIGZpcnN0LCBiZWNhdXNlXG4gICAgICAgIC8vIGByZXN0b3JlVmlld1N0YXRlbWVudGAgZGVwZW5kcyBvbiB0aGUgcmVzdWx0LlxuICAgICAgICBzdGF0ZW1lbnRzLnB1c2goLi4udmFyaWFibGVEZWNsYXJhdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0ZW1lbnRzLnB1c2goLi4uYmluZGluZ1N0YXRlbWVudHMpO1xuICAgIGlmIChyZXN0b3JlVmlld1N0YXRlbWVudCkge1xuICAgICAgICBzdGF0ZW1lbnRzLnVuc2hpZnQocmVzdG9yZVZpZXdTdGF0ZW1lbnQpO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgYHJlc3RvcmVWaWV3YCBjYWxsLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSB2aWV3IGF0IHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVyXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGF2b2lkIGEgbGVhay4gSWYgdGhlcmUncyBhIGByZXR1cm5gIHN0YXRlbWVudCBhbHJlYWR5LCB3ZSB3cmFwIGl0IGluIHRoZVxuICAgICAgICAvLyBjYWxsLCBlLmcuIGByZXR1cm4gcmVzZXRWaWV3KGN0eC5mb28oKSlgLiBPdGhlcndpc2Ugd2UgYWRkIHRoZSBjYWxsIGFzIHRoZSBsYXN0IHN0YXRlbWVudC5cbiAgICAgICAgY29uc3QgbGFzdFN0YXRlbWVudCA9IHN0YXRlbWVudHNbc3RhdGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3RTdGF0ZW1lbnQgaW5zdGFuY2VvZiBSZXR1cm5TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHNbc3RhdGVtZW50cy5sZW5ndGggLSAxXSA9IG5ldyBSZXR1cm5TdGF0ZW1lbnQoaW52b2tlSW5zdHJ1Y3Rpb24obGFzdFN0YXRlbWVudC52YWx1ZS5zb3VyY2VTcGFuLCBJZGVudGlmaWVycy5yZXNldFZpZXcsIFtsYXN0U3RhdGVtZW50LnZhbHVlXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5ldyBFeHByZXNzaW9uU3RhdGVtZW50KGludm9rZUluc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzLnJlc2V0VmlldywgW10pKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXZlbnROYW1lID0gdHlwZSA9PT0gMSAvKiBQYXJzZWRFdmVudFR5cGUuQW5pbWF0aW9uICovID8gcHJlcGFyZVN5bnRoZXRpY0xpc3RlbmVyTmFtZShuYW1lLCBwaGFzZSkgOiBuYW1lO1xuICAgIGNvbnN0IGZuTmFtZSA9IGhhbmRsZXJOYW1lICYmIHNhbml0aXplSWRlbnRpZmllcihoYW5kbGVyTmFtZSk7XG4gICAgY29uc3QgZm5BcmdzID0gW107XG4gICAgaWYgKGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3Nlcy5oYXMoZXZlbnRBcmd1bWVudE5hbWUpKSB7XG4gICAgICAgIGZuQXJncy5wdXNoKG5ldyBGblBhcmFtKGV2ZW50QXJndW1lbnROYW1lLCBEWU5BTUlDX1RZUEUpKTtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlckZuID0gZm4oZm5BcmdzLCBzdGF0ZW1lbnRzLCBJTkZFUlJFRF9UWVBFLCBudWxsLCBmbk5hbWUpO1xuICAgIGNvbnN0IHBhcmFtcyA9IFtsaXRlcmFsKGV2ZW50TmFtZSksIGhhbmRsZXJGbl07XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBwYXJhbXMucHVzaChsaXRlcmFsKGZhbHNlKSwgLy8gYHVzZUNhcHR1cmVgIGZsYWcsIGRlZmF1bHRzIHRvIGBmYWxzZWBcbiAgICAgICAgaW1wb3J0RXhwcihHTE9CQUxfVEFSR0VUX1JFU09MVkVSUy5nZXQodGFyZ2V0KSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50RGVmQ29uc3RzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZXBhcmVTdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgY29uc3RFeHByZXNzaW9uczogW10sXG4gICAgICAgIGkxOG5WYXJSZWZzQ2FjaGU6IG5ldyBNYXAoKSxcbiAgICB9O1xufVxuY2xhc3MgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoY29uc3RhbnRQb29sLCBwYXJlbnRCaW5kaW5nU2NvcGUsIGxldmVsID0gMCwgY29udGV4dE5hbWUsIGkxOG5Db250ZXh0LCB0ZW1wbGF0ZUluZGV4LCB0ZW1wbGF0ZU5hbWUsIF9uYW1lc3BhY2UsIHJlbGF0aXZlQ29udGV4dEZpbGVQYXRoLCBpMThuVXNlRXh0ZXJuYWxJZHMsIF9jb25zdGFudHMgPSBjcmVhdGVDb21wb25lbnREZWZDb25zdHMoKSkge1xuICAgICAgICB0aGlzLmNvbnN0YW50UG9vbCA9IGNvbnN0YW50UG9vbDtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLmNvbnRleHROYW1lID0gY29udGV4dE5hbWU7XG4gICAgICAgIHRoaXMuaTE4bkNvbnRleHQgPSBpMThuQ29udGV4dDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUluZGV4ID0gdGVtcGxhdGVJbmRleDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZU5hbWUgPSB0ZW1wbGF0ZU5hbWU7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZSA9IF9uYW1lc3BhY2U7XG4gICAgICAgIHRoaXMuaTE4blVzZUV4dGVybmFsSWRzID0gaTE4blVzZUV4dGVybmFsSWRzO1xuICAgICAgICB0aGlzLl9jb25zdGFudHMgPSBfY29uc3RhbnRzO1xuICAgICAgICB0aGlzLl9kYXRhSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9iaW5kaW5nQ29udGV4dCA9IDA7XG4gICAgICAgIHRoaXMuX3ByZWZpeENvZGUgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgY2FsbGJhY2tzIHRvIGdlbmVyYXRlIGNyZWF0aW9uIG1vZGUgaW5zdHJ1Y3Rpb25zLiBXZSBzdG9yZSB0aGVtIGhlcmUgYXMgd2UgcHJvY2Vzc1xuICAgICAgICAgKiB0aGUgdGVtcGxhdGUgc28gYmluZGluZ3MgaW4gbGlzdGVuZXJzIGFyZSByZXNvbHZlZCBvbmx5IG9uY2UgYWxsIG5vZGVzIGhhdmUgYmVlbiB2aXNpdGVkLlxuICAgICAgICAgKiBUaGlzIGVuc3VyZXMgYWxsIGxvY2FsIHJlZnMgYW5kIGNvbnRleHQgdmFyaWFibGVzIGFyZSBhdmFpbGFibGUgZm9yIG1hdGNoaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3JlYXRpb25Db2RlRm5zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGNhbGxiYWNrcyB0byBnZW5lcmF0ZSB1cGRhdGUgbW9kZSBpbnN0cnVjdGlvbnMuIFdlIHN0b3JlIHRoZW0gaGVyZSBhcyB3ZSBwcm9jZXNzXG4gICAgICAgICAqIHRoZSB0ZW1wbGF0ZSBzbyBiaW5kaW5ncyBhcmUgcmVzb2x2ZWQgb25seSBvbmNlIGFsbCBub2RlcyBoYXZlIGJlZW4gdmlzaXRlZC4gVGhpcyBlbnN1cmVzXG4gICAgICAgICAqIGFsbCBsb2NhbCByZWZzIGFuZCBjb250ZXh0IHZhcmlhYmxlcyBhcmUgYXZhaWxhYmxlIGZvciBtYXRjaGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvZGVGbnMgPSBbXTtcbiAgICAgICAgLyoqIEluZGV4IG9mIHRoZSBjdXJyZW50bHktc2VsZWN0ZWQgbm9kZS4gKi9cbiAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgLyoqIFRlbXBvcmFyeSB2YXJpYWJsZSBkZWNsYXJhdGlvbnMgZ2VuZXJhdGVkIGZyb20gdmlzaXRpbmcgcGlwZXMsIGxpdGVyYWxzLCBldGMuICovXG4gICAgICAgIHRoaXMuX3RlbXBWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgY2FsbGJhY2tzIHRvIGJ1aWxkIG5lc3RlZCB0ZW1wbGF0ZXMuIE5lc3RlZCB0ZW1wbGF0ZXMgbXVzdCBub3QgYmUgdmlzaXRlZCB1bnRpbFxuICAgICAgICAgKiBhZnRlciB0aGUgcGFyZW50IHRlbXBsYXRlIGhhcyBmaW5pc2hlZCB2aXNpdGluZyBhbGwgb2YgaXRzIG5vZGVzLiBUaGlzIGVuc3VyZXMgdGhhdCBhbGxcbiAgICAgICAgICogbG9jYWwgcmVmIGJpbmRpbmdzIGluIG5lc3RlZCB0ZW1wbGF0ZXMgYXJlIGFibGUgdG8gZmluZCBsb2NhbCByZWYgdmFsdWVzIGlmIHRoZSByZWZzXG4gICAgICAgICAqIGFyZSBkZWZpbmVkIGFmdGVyIHRoZSB0ZW1wbGF0ZSBkZWNsYXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25lc3RlZFRlbXBsYXRlRm5zID0gW107XG4gICAgICAgIC8vIGkxOG4gY29udGV4dCBsb2NhbCB0byB0aGlzIHRlbXBsYXRlXG4gICAgICAgIHRoaXMuaTE4biA9IG51bGw7XG4gICAgICAgIC8vIE51bWJlciBvZiBzbG90cyB0byByZXNlcnZlIGZvciBwdXJlRnVuY3Rpb25zXG4gICAgICAgIHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzID0gMDtcbiAgICAgICAgLy8gTnVtYmVyIG9mIGJpbmRpbmcgc2xvdHNcbiAgICAgICAgdGhpcy5fYmluZGluZ1Nsb3RzID0gMDtcbiAgICAgICAgLy8gUHJvamVjdGlvbiBzbG90cyBmb3VuZCBpbiB0aGUgdGVtcGxhdGUuIFByb2plY3Rpb24gc2xvdHMgY2FuIGRpc3RyaWJ1dGUgcHJvamVjdGVkXG4gICAgICAgIC8vIG5vZGVzIGJhc2VkIG9uIGEgc2VsZWN0b3IsIG9yIGNhbiBqdXN0IHVzZSB0aGUgd2lsZGNhcmQgc2VsZWN0b3IgdG8gbWF0Y2hcbiAgICAgICAgLy8gYWxsIG5vZGVzIHdoaWNoIGFyZW4ndCBtYXRjaGluZyBhbnkgc2VsZWN0b3IuXG4gICAgICAgIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMgPSBbXTtcbiAgICAgICAgLy8gTnVtYmVyIG9mIG5vbi1kZWZhdWx0IHNlbGVjdG9ycyBmb3VuZCBpbiBhbGwgcGFyZW50IHRlbXBsYXRlcyBvZiB0aGlzIHRlbXBsYXRlLiBXZSBuZWVkIHRvXG4gICAgICAgIC8vIHRyYWNrIGl0IHRvIHByb3Blcmx5IGFkanVzdCBwcm9qZWN0aW9uIHNsb3QgaW5kZXggaW4gdGhlIGBwcm9qZWN0aW9uYCBpbnN0cnVjdGlvbi5cbiAgICAgICAgdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0ID0gMDtcbiAgICAgICAgLy8gRXhwcmVzc2lvbiB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIGltcGxpY2l0IHJlY2VpdmVyIHdoZW4gY29udmVydGluZyB0ZW1wbGF0ZVxuICAgICAgICAvLyBleHByZXNzaW9ucyB0byBvdXRwdXQgQVNULlxuICAgICAgICB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyRXhwciA9IG51bGw7XG4gICAgICAgIC8vIFRoZXNlIHNob3VsZCBiZSBoYW5kbGVkIGluIHRoZSB0ZW1wbGF0ZSBvciBlbGVtZW50IGRpcmVjdGx5LlxuICAgICAgICB0aGlzLnZpc2l0UmVmZXJlbmNlID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdFZhcmlhYmxlID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdFRleHRBdHRyaWJ1dGUgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0Qm91bmRBdHRyaWJ1dGUgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLnZpc2l0Qm91bmRFdmVudCA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdTY29wZSA9IHBhcmVudEJpbmRpbmdTY29wZS5uZXN0ZWRTY29wZShsZXZlbCk7XG4gICAgICAgIC8vIFR1cm4gdGhlIHJlbGF0aXZlIGNvbnRleHQgZmlsZSBwYXRoIGludG8gYW4gaWRlbnRpZmllciBieSByZXBsYWNpbmcgbm9uLWFscGhhbnVtZXJpY1xuICAgICAgICAvLyBjaGFyYWN0ZXJzIHdpdGggdW5kZXJzY29yZXMuXG4gICAgICAgIHRoaXMuZmlsZUJhc2VkSTE4blN1ZmZpeCA9IHJlbGF0aXZlQ29udGV4dEZpbGVQYXRoLnJlcGxhY2UoL1teQS1aYS16MC05XS9nLCAnXycpICsgJ18nO1xuICAgICAgICB0aGlzLl92YWx1ZUNvbnZlcnRlciA9IG5ldyBWYWx1ZUNvbnZlcnRlcihjb25zdGFudFBvb2wsICgpID0+IHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpLCAobnVtU2xvdHMpID0+IHRoaXMuYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cyhudW1TbG90cyksIChuYW1lLCBsb2NhbE5hbWUsIHNsb3QsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nU2NvcGUuc2V0KHRoaXMubGV2ZWwsIGxvY2FsTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzLnBpcGUsIFtsaXRlcmFsKHNsb3QpLCBsaXRlcmFsKG5hbWUpXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZFRlbXBsYXRlRnVuY3Rpb24obm9kZXMsIHZhcmlhYmxlcywgbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0ID0gMCwgaTE4bikge1xuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRTZWxlY3RvcnNPZmZzZXQgPSBuZ0NvbnRlbnRTZWxlY3RvcnNPZmZzZXQ7XG4gICAgICAgIGlmICh0aGlzLl9uYW1lc3BhY2UgIT09IElkZW50aWZpZXJzLm5hbWVzcGFjZUhUTUwpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihudWxsLCB0aGlzLl9uYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB2YXJpYWJsZSBiaW5kaW5nc1xuICAgICAgICB2YXJpYWJsZXMuZm9yRWFjaCh2ID0+IHRoaXMucmVnaXN0ZXJDb250ZXh0VmFyaWFibGVzKHYpKTtcbiAgICAgICAgLy8gSW5pdGlhdGUgaTE4biBjb250ZXh0IGluIGNhc2U6XG4gICAgICAgIC8vIC0gdGhpcyB0ZW1wbGF0ZSBoYXMgcGFyZW50IGkxOG4gY29udGV4dFxuICAgICAgICAvLyAtIG9yIHRoZSB0ZW1wbGF0ZSBoYXMgaTE4biBtZXRhIGFzc29jaWF0ZWQgd2l0aCBpdCxcbiAgICAgICAgLy8gICBidXQgaXQncyBub3QgaW5pdGlhdGVkIGJ5IHRoZSBFbGVtZW50IChlLmcuIDxuZy10ZW1wbGF0ZSBpMThuPilcbiAgICAgICAgY29uc3QgaW5pdEkxOG5Db250ZXh0ID0gdGhpcy5pMThuQ29udGV4dCB8fFxuICAgICAgICAgICAgKGlzSTE4blJvb3ROb2RlKGkxOG4pICYmICFpc1NpbmdsZUkxOG5JY3UoaTE4bikgJiZcbiAgICAgICAgICAgICAgICAhKGlzU2luZ2xlRWxlbWVudFRlbXBsYXRlKG5vZGVzKSAmJiBub2Rlc1swXS5pMThuID09PSBpMThuKSk7XG4gICAgICAgIGNvbnN0IHNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uID0gaGFzVGV4dENoaWxkcmVuT25seShub2Rlcyk7XG4gICAgICAgIGlmIChpbml0STE4bkNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4blN0YXJ0KG51bGwsIGkxOG4sIHNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBpbml0aWFsIHBhc3MgdGhyb3VnaCB0aGUgbm9kZXMgb2YgdGhpcyB0ZW1wbGF0ZS4gSW4gdGhpcyBwYXNzLCB3ZVxuICAgICAgICAvLyBxdWV1ZSBhbGwgY3JlYXRpb24gbW9kZSBhbmQgdXBkYXRlIG1vZGUgaW5zdHJ1Y3Rpb25zIGZvciBnZW5lcmF0aW9uIGluIHRoZSBzZWNvbmRcbiAgICAgICAgLy8gcGFzcy4gSXQncyBuZWNlc3NhcnkgdG8gc2VwYXJhdGUgdGhlIHBhc3NlcyB0byBlbnN1cmUgbG9jYWwgcmVmcyBhcmUgZGVmaW5lZCBiZWZvcmVcbiAgICAgICAgLy8gcmVzb2x2aW5nIGJpbmRpbmdzLiBXZSBhbHNvIGNvdW50IGJpbmRpbmdzIGluIHRoaXMgcGFzcyBhcyB3ZSB3YWxrIGJvdW5kIGV4cHJlc3Npb25zLlxuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIG5vZGVzKTtcbiAgICAgICAgLy8gQWRkIHRvdGFsIGJpbmRpbmcgY291bnQgdG8gcHVyZSBmdW5jdGlvbiBjb3VudCBzbyBwdXJlIGZ1bmN0aW9uIGluc3RydWN0aW9ucyBhcmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHdpdGggdGhlIGNvcnJlY3Qgc2xvdCBvZmZzZXQgd2hlbiB1cGRhdGUgaW5zdHJ1Y3Rpb25zIGFyZSBwcm9jZXNzZWQuXG4gICAgICAgIHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzICs9IHRoaXMuX2JpbmRpbmdTbG90cztcbiAgICAgICAgLy8gUGlwZXMgYXJlIHdhbGtlZCBpbiB0aGUgZmlyc3QgcGFzcyAodG8gZW5xdWV1ZSBgcGlwZSgpYCBjcmVhdGlvbiBpbnN0cnVjdGlvbnMgYW5kXG4gICAgICAgIC8vIGBwaXBlQmluZGAgdXBkYXRlIGluc3RydWN0aW9ucyksIHNvIHdlIGhhdmUgdG8gdXBkYXRlIHRoZSBzbG90IG9mZnNldHMgbWFudWFsbHlcbiAgICAgICAgLy8gdG8gYWNjb3VudCBmb3IgYmluZGluZ3MuXG4gICAgICAgIHRoaXMuX3ZhbHVlQ29udmVydGVyLnVwZGF0ZVBpcGVTbG90T2Zmc2V0cyh0aGlzLl9iaW5kaW5nU2xvdHMpO1xuICAgICAgICAvLyBOZXN0ZWQgdGVtcGxhdGVzIG11c3QgYmUgcHJvY2Vzc2VkIGJlZm9yZSBjcmVhdGlvbiBpbnN0cnVjdGlvbnMgc28gdGVtcGxhdGUoKVxuICAgICAgICAvLyBpbnN0cnVjdGlvbnMgY2FuIGJlIGdlbmVyYXRlZCB3aXRoIHRoZSBjb3JyZWN0IGludGVybmFsIGNvbnN0IGNvdW50LlxuICAgICAgICB0aGlzLl9uZXN0ZWRUZW1wbGF0ZUZucy5mb3JFYWNoKGJ1aWxkVGVtcGxhdGVGbiA9PiBidWlsZFRlbXBsYXRlRm4oKSk7XG4gICAgICAgIC8vIE91dHB1dCB0aGUgYHByb2plY3Rpb25EZWZgIGluc3RydWN0aW9uIHdoZW4gc29tZSBgPG5nLWNvbnRlbnQ+YCB0YWdzIGFyZSBwcmVzZW50LlxuICAgICAgICAvLyBUaGUgYHByb2plY3Rpb25EZWZgIGluc3RydWN0aW9uIGlzIG9ubHkgZW1pdHRlZCBmb3IgdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZSBhbmRcbiAgICAgICAgLy8gaXMgc2tpcHBlZCBmb3IgbmVzdGVkIHRlbXBsYXRlcyAoPG5nLXRlbXBsYXRlPiB0YWdzKS5cbiAgICAgICAgaWYgKHRoaXMubGV2ZWwgPT09IDAgJiYgdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQgdGhlIGBwcm9qZWN0aW9uRGVmYCBpbnN0cnVjdGlvbnMgY3JlYXRlcyBvbmUgc2xvdCBmb3IgdGhlIHdpbGRjYXJkXG4gICAgICAgICAgICAvLyBzZWxlY3RvciBpZiBubyBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQuIFRoZXJlZm9yZSB3ZSBvbmx5IHdhbnQgdG8gYWxsb2NhdGUgYSBuZXdcbiAgICAgICAgICAgIC8vIGFycmF5IGZvciB0aGUgcHJvamVjdGlvbiBzbG90cyBpZiB0aGUgZGVmYXVsdCBwcm9qZWN0aW9uIHNsb3QgaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGggPiAxIHx8IHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHNbMF0gIT09ICcqJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIzUmVzZXJ2ZWRTbG90cyA9IHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubWFwKHMgPT4gcyAhPT0gJyonID8gcGFyc2VTZWxlY3RvclRvUjNTZWxlY3RvcihzKSA6IHMpO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLmNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwoYXNMaXRlcmFsKHIzUmVzZXJ2ZWRTbG90cyksIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGFjY3VtdWxhdGUgbmdDb250ZW50IHNlbGVjdG9ycyB3aGlsZSBwcm9jZXNzaW5nIHRlbXBsYXRlIGVsZW1lbnRzLFxuICAgICAgICAgICAgLy8gd2UgKnByZXBlbmQqIGBwcm9qZWN0aW9uRGVmYCB0byBjcmVhdGlvbiBpbnN0cnVjdGlvbnMgYmxvY2ssIHRvIHB1dCBpdCBiZWZvcmVcbiAgICAgICAgICAgIC8vIGFueSBgcHJvamVjdGlvbmAgaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMucHJvamVjdGlvbkRlZiwgcGFyYW1ldGVycywgLyogcHJlcGVuZCAqLyB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdEkxOG5Db250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5FbmQobnVsbCwgc2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYXRlIGFsbCB0aGUgY3JlYXRpb24gbW9kZSBpbnN0cnVjdGlvbnMgKGUuZy4gcmVzb2x2ZSBiaW5kaW5ncyBpbiBsaXN0ZW5lcnMpXG4gICAgICAgIGNvbnN0IGNyZWF0aW9uU3RhdGVtZW50cyA9IGdldEluc3RydWN0aW9uU3RhdGVtZW50cyh0aGlzLl9jcmVhdGlvbkNvZGVGbnMpO1xuICAgICAgICAvLyBHZW5lcmF0ZSBhbGwgdGhlIHVwZGF0ZSBtb2RlIGluc3RydWN0aW9ucyAoZS5nLiByZXNvbHZlIHByb3BlcnR5IG9yIHRleHQgYmluZGluZ3MpXG4gICAgICAgIGNvbnN0IHVwZGF0ZVN0YXRlbWVudHMgPSBnZXRJbnN0cnVjdGlvblN0YXRlbWVudHModGhpcy5fdXBkYXRlQ29kZUZucyk7XG4gICAgICAgIC8vICBWYXJpYWJsZSBkZWNsYXJhdGlvbiBtdXN0IG9jY3VyIGFmdGVyIGJpbmRpbmcgcmVzb2x1dGlvbiBzbyB3ZSBjYW4gZ2VuZXJhdGUgY29udGV4dFxuICAgICAgICAvLyAgaW5zdHJ1Y3Rpb25zIHRoYXQgYnVpbGQgb24gZWFjaCBvdGhlci5cbiAgICAgICAgLy8gZS5nLiBjb25zdCBiID0gbmV4dENvbnRleHQoKS4kaW1wbGljaXQoKTsgY29uc3QgYiA9IG5leHRDb250ZXh0KCk7XG4gICAgICAgIGNvbnN0IGNyZWF0aW9uVmFyaWFibGVzID0gdGhpcy5fYmluZGluZ1Njb3BlLnZpZXdTbmFwc2hvdFN0YXRlbWVudHMoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlVmFyaWFibGVzID0gdGhpcy5fYmluZGluZ1Njb3BlLnZhcmlhYmxlRGVjbGFyYXRpb25zKCkuY29uY2F0KHRoaXMuX3RlbXBWYXJpYWJsZXMpO1xuICAgICAgICBjb25zdCBjcmVhdGlvbkJsb2NrID0gY3JlYXRpb25TdGF0ZW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgW3JlbmRlckZsYWdDaGVja0lmU3RtdCgxIC8qIGNvcmUuUmVuZGVyRmxhZ3MuQ3JlYXRlICovLCBjcmVhdGlvblZhcmlhYmxlcy5jb25jYXQoY3JlYXRpb25TdGF0ZW1lbnRzKSldIDpcbiAgICAgICAgICAgIFtdO1xuICAgICAgICBjb25zdCB1cGRhdGVCbG9jayA9IHVwZGF0ZVN0YXRlbWVudHMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICBbcmVuZGVyRmxhZ0NoZWNrSWZTdG10KDIgLyogY29yZS5SZW5kZXJGbGFncy5VcGRhdGUgKi8sIHVwZGF0ZVZhcmlhYmxlcy5jb25jYXQodXBkYXRlU3RhdGVtZW50cykpXSA6XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIGZuKFxuICAgICAgICAvLyBpLmUuIChyZjogUmVuZGVyRmxhZ3MsIGN0eDogYW55KVxuICAgICAgICBbbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCldLCBbXG4gICAgICAgICAgICAvLyBUZW1wb3JhcnkgdmFyaWFibGUgZGVjbGFyYXRpb25zIGZvciBxdWVyeSByZWZyZXNoIChpLmUuIGxldCBfdDogYW55OylcbiAgICAgICAgICAgIC4uLnRoaXMuX3ByZWZpeENvZGUsXG4gICAgICAgICAgICAvLyBDcmVhdGluZyBtb2RlIChpLmUuIGlmIChyZiAmIFJlbmRlckZsYWdzLkNyZWF0ZSkgeyAuLi4gfSlcbiAgICAgICAgICAgIC4uLmNyZWF0aW9uQmxvY2ssXG4gICAgICAgICAgICAvLyBCaW5kaW5nIGFuZCByZWZyZXNoIG1vZGUgKGkuZS4gaWYgKHJmICYgUmVuZGVyRmxhZ3MuVXBkYXRlKSB7Li4ufSlcbiAgICAgICAgICAgIC4uLnVwZGF0ZUJsb2NrLFxuICAgICAgICBdLCBJTkZFUlJFRF9UWVBFLCBudWxsLCB0aGlzLnRlbXBsYXRlTmFtZSk7XG4gICAgfVxuICAgIC8vIExvY2FsUmVzb2x2ZXJcbiAgICBnZXRMb2NhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5nU2NvcGUuZ2V0KG5hbWUpO1xuICAgIH1cbiAgICAvLyBMb2NhbFJlc29sdmVyXG4gICAgbm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKTtcbiAgICB9XG4gICAgLy8gTG9jYWxSZXNvbHZlclxuICAgIG1heWJlUmVzdG9yZVZpZXcoKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdTY29wZS5tYXliZVJlc3RvcmVWaWV3KCk7XG4gICAgfVxuICAgIGkxOG5UcmFuc2xhdGUobWVzc2FnZSwgcGFyYW1zID0ge30sIHJlZiwgdHJhbnNmb3JtRm4pIHtcbiAgICAgICAgY29uc3QgX3JlZiA9IHJlZiB8fCB0aGlzLmkxOG5HZW5lcmF0ZU1haW5CbG9ja1ZhcigpO1xuICAgICAgICAvLyBDbG9zdXJlIENvbXBpbGVyIHJlcXVpcmVzIGNvbnN0IG5hbWVzIHRvIHN0YXJ0IHdpdGggYE1TR19gIGJ1dCBkaXNhbGxvd3MgYW55IG90aGVyIGNvbnN0IHRvXG4gICAgICAgIC8vIHN0YXJ0IHdpdGggYE1TR19gLiBXZSBkZWZpbmUgYSB2YXJpYWJsZSBzdGFydGluZyB3aXRoIGBNU0dfYCBqdXN0IGZvciB0aGUgYGdvb2cuZ2V0TXNnYCBjYWxsXG4gICAgICAgIGNvbnN0IGNsb3N1cmVWYXIgPSB0aGlzLmkxOG5HZW5lcmF0ZUNsb3N1cmVWYXIobWVzc2FnZS5pZCk7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSBnZXRUcmFuc2xhdGlvbkRlY2xTdG10cyhtZXNzYWdlLCBfcmVmLCBjbG9zdXJlVmFyLCBwYXJhbXMsIHRyYW5zZm9ybUZuKTtcbiAgICAgICAgdGhpcy5fY29uc3RhbnRzLnByZXBhcmVTdGF0ZW1lbnRzLnB1c2goLi4uc3RhdGVtZW50cyk7XG4gICAgICAgIHJldHVybiBfcmVmO1xuICAgIH1cbiAgICByZWdpc3RlckNvbnRleHRWYXJpYWJsZXModmFyaWFibGUkMSkge1xuICAgICAgICBjb25zdCBzY29wZWROYW1lID0gdGhpcy5fYmluZGluZ1Njb3BlLmZyZXNoUmVmZXJlbmNlTmFtZSgpO1xuICAgICAgICBjb25zdCByZXRyaWV2YWxMZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgIGNvbnN0IGxocyA9IHZhcmlhYmxlKHZhcmlhYmxlJDEubmFtZSArIHNjb3BlZE5hbWUpO1xuICAgICAgICB0aGlzLl9iaW5kaW5nU2NvcGUuc2V0KHJldHJpZXZhbExldmVsLCB2YXJpYWJsZSQxLm5hbWUsIGxocywgMSAvKiBEZWNsYXJhdGlvblByaW9yaXR5LkNPTlRFWFQgKi8sIChzY29wZSwgcmVsYXRpdmVMZXZlbCkgPT4ge1xuICAgICAgICAgICAgbGV0IHJocztcbiAgICAgICAgICAgIGlmIChzY29wZS5iaW5kaW5nTGV2ZWwgPT09IHJldHJpZXZhbExldmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLmlzTGlzdGVuZXJTY29wZSgpICYmIHNjb3BlLmhhc1Jlc3RvcmVWaWV3VmFyaWFibGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIHJlc3RvcmVkQ3R4LlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGdldCB0aGUgY29udGV4dCBmcm9tIGEgdmlldyByZWZlcmVuY2UsIGlmIG9uZSBpcyBhdmFpbGFibGUsIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNvbnRleHQgdGhhdCB3YXMgcGFzc2VkIGluIGR1cmluZyBjcmVhdGlvbiBtYXkgbm90IGJlIGNvcnJlY3QgYW55bW9yZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvNDAzNjAuXG4gICAgICAgICAgICAgICAgICAgIHJocyA9IHZhcmlhYmxlKFJFU1RPUkVEX1ZJRVdfQ09OVEVYVF9OQU1FKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUubm90aWZ5UmVzdG9yZWRWaWV3Q29udGV4dFVzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiBjdHhcbiAgICAgICAgICAgICAgICAgICAgcmhzID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFyZWRDdHhWYXIgPSBzY29wZS5nZXRTaGFyZWRDb250ZXh0TmFtZShyZXRyaWV2YWxMZXZlbCk7XG4gICAgICAgICAgICAgICAgLy8gZS5nLiBjdHhfcjAgICBPUiAgeCgyKTtcbiAgICAgICAgICAgICAgICByaHMgPSBzaGFyZWRDdHhWYXIgPyBzaGFyZWRDdHhWYXIgOiBnZW5lcmF0ZU5leHRDb250ZXh0RXhwcihyZWxhdGl2ZUxldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGUuZy4gY29uc3QgJGl0ZW0kID0geCgyKS4kaW1wbGljaXQ7XG4gICAgICAgICAgICByZXR1cm4gW2xocy5zZXQocmhzLnByb3AodmFyaWFibGUkMS52YWx1ZSB8fCBJTVBMSUNJVF9SRUZFUkVOQ0UpKS50b0NvbnN0RGVjbCgpXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGkxOG5BcHBlbmRCaW5kaW5ncyhleHByZXNzaW9ucykge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMuZm9yRWFjaChleHByZXNzaW9uID0+IHRoaXMuaTE4bi5hcHBlbmRCaW5kaW5nKGV4cHJlc3Npb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpMThuQmluZFByb3BzKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChwcm9wIGluc3RhbmNlb2YgVGV4dCQzKSB7XG4gICAgICAgICAgICAgICAgYm91bmRba2V5XSA9IGxpdGVyYWwocHJvcC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3AudmFsdWUudmlzaXQodGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdHJpbmdzLCBleHByZXNzaW9ucyB9ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIGJpbmRpbmdzIH0gPSB0aGlzLmkxOG47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gYXNzZW1ibGVJMThuQm91bmRTdHJpbmcoc3RyaW5ncywgYmluZGluZ3Muc2l6ZSwgaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmkxOG5BcHBlbmRCaW5kaW5ncyhleHByZXNzaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kW2tleV0gPSBsaXRlcmFsKGxhYmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlcyB0b3AgbGV2ZWwgdmFycyBmb3IgaTE4biBibG9ja3MgKGkuZS4gYGkxOG5fTmApLlxuICAgIGkxOG5HZW5lcmF0ZU1haW5CbG9ja1ZhcigpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlKHRoaXMuY29uc3RhbnRQb29sLnVuaXF1ZU5hbWUoVFJBTlNMQVRJT05fVkFSX1BSRUZJWCkpO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZXMgdmFycyB3aXRoIENsb3N1cmUtc3BlY2lmaWMgbmFtZXMgZm9yIGkxOG4gYmxvY2tzIChpLmUuIGBNU0dfWFhYYCkuXG4gICAgaTE4bkdlbmVyYXRlQ2xvc3VyZVZhcihtZXNzYWdlSWQpIHtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IHRoaXMuZmlsZUJhc2VkSTE4blN1ZmZpeC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAodGhpcy5pMThuVXNlRXh0ZXJuYWxJZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGdldFRyYW5zbGF0aW9uQ29uc3RQcmVmaXgoYEVYVEVSTkFMX2ApO1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlU3VmZml4ID0gdGhpcy5jb25zdGFudFBvb2wudW5pcXVlTmFtZShzdWZmaXgpO1xuICAgICAgICAgICAgbmFtZSA9IGAke3ByZWZpeH0ke3Nhbml0aXplSWRlbnRpZmllcihtZXNzYWdlSWQpfSQkJHt1bmlxdWVTdWZmaXh9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGdldFRyYW5zbGF0aW9uQ29uc3RQcmVmaXgoc3VmZml4KTtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLmNvbnN0YW50UG9vbC51bmlxdWVOYW1lKHByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlKG5hbWUpO1xuICAgIH1cbiAgICBpMThuVXBkYXRlUmVmKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgeyBpY3VzLCBtZXRhLCBpc1Jvb3QsIGlzUmVzb2x2ZWQsIGlzRW1pdHRlZCB9ID0gY29udGV4dDtcbiAgICAgICAgaWYgKGlzUm9vdCAmJiBpc1Jlc29sdmVkICYmICFpc0VtaXR0ZWQgJiYgIWlzU2luZ2xlSTE4bkljdShtZXRhKSkge1xuICAgICAgICAgICAgY29udGV4dC5pc0VtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJzID0gY29udGV4dC5nZXRTZXJpYWxpemVkUGxhY2Vob2xkZXJzKCk7XG4gICAgICAgICAgICBsZXQgaWN1TWFwcGluZyA9IHt9O1xuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHBsYWNlaG9sZGVycy5zaXplID8gcGxhY2Vob2xkZXJzVG9QYXJhbXMocGxhY2Vob2xkZXJzKSA6IHt9O1xuICAgICAgICAgICAgaWYgKGljdXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGljdXMuZm9yRWFjaCgocmVmcywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBvbmUgSUNVIGRlZmluZWQgZm9yIGEgZ2l2ZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIC0ganVzdCBvdXRwdXQgaXRzIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2tleV0gPSByZWZzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGFjdGl2YXRlIHBvc3QtcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gcmVwbGFjZSBJQ1UgcGxhY2Vob2xkZXJzIHdpdGggcHJvcGVyIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB3cmFwSTE4blBsYWNlaG9sZGVyKGAke0kxOE5fSUNVX01BUFBJTkdfUFJFRklYfSR7a2V5fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2tleV0gPSBsaXRlcmFsKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGljdU1hcHBpbmdba2V5XSA9IGxpdGVyYWxBcnIocmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyYW5zbGF0aW9uIHJlcXVpcmVzIHBvc3QgcHJvY2Vzc2luZyBpbiAyIGNhc2VzOlxuICAgICAgICAgICAgLy8gLSBpZiB3ZSBoYXZlIHBsYWNlaG9sZGVycyB3aXRoIG11bHRpcGxlIHZhbHVlcyAoZXguIGBTVEFSVF9ESVZgOiBb77+9IzHvv70sIO+/vSMy77+9LCAuLi5dKVxuICAgICAgICAgICAgLy8gLSBpZiB3ZSBoYXZlIG11bHRpcGxlIElDVXMgdGhhdCByZWZlciB0byB0aGUgc2FtZSBwbGFjZWhvbGRlciBuYW1lXG4gICAgICAgICAgICBjb25zdCBuZWVkc1Bvc3Rwcm9jZXNzaW5nID0gQXJyYXkuZnJvbShwbGFjZWhvbGRlcnMudmFsdWVzKCkpLnNvbWUoKHZhbHVlKSA9PiB2YWx1ZS5sZW5ndGggPiAxKSB8fFxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGljdU1hcHBpbmcpLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1GbjtcbiAgICAgICAgICAgIGlmIChuZWVkc1Bvc3Rwcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtRm4gPSAocmF3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbcmF3XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGljdU1hcHBpbmcpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKG1hcExpdGVyYWwoaWN1TWFwcGluZywgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZva2VJbnN0cnVjdGlvbihudWxsLCBJZGVudGlmaWVycy5pMThuUG9zdHByb2Nlc3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmkxOG5UcmFuc2xhdGUobWV0YSwgcGFyYW1zLCBjb250ZXh0LnJlZiwgdHJhbnNmb3JtRm4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkxOG5TdGFydChzcGFuID0gbnVsbCwgbWV0YSwgc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgdGhpcy5pMThuID0gdGhpcy5pMThuQ29udGV4dCA/XG4gICAgICAgICAgICB0aGlzLmkxOG5Db250ZXh0LmZvcmtDaGlsZENvbnRleHQoaW5kZXgsIHRoaXMudGVtcGxhdGVJbmRleCwgbWV0YSkgOlxuICAgICAgICAgICAgbmV3IEkxOG5Db250ZXh0KGluZGV4LCB0aGlzLmkxOG5HZW5lcmF0ZU1haW5CbG9ja1ZhcigpLCAwLCB0aGlzLnRlbXBsYXRlSW5kZXgsIG1ldGEpO1xuICAgICAgICAvLyBnZW5lcmF0ZSBpMThuU3RhcnQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgY29uc3QgeyBpZCwgcmVmIH0gPSB0aGlzLmkxOG47XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtsaXRlcmFsKGluZGV4KSwgdGhpcy5hZGRUb0NvbnN0cyhyZWYpXTtcbiAgICAgICAgaWYgKGlkID4gMCkge1xuICAgICAgICAgICAgLy8gZG8gbm90IHB1c2ggM3JkIGFyZ3VtZW50IChzdWItYmxvY2sgaWQpXG4gICAgICAgICAgICAvLyBpbnRvIGkxOG5TdGFydCBjYWxsIGZvciB0b3AgbGV2ZWwgaTE4biBjb250ZXh0XG4gICAgICAgICAgICBwYXJhbXMucHVzaChsaXRlcmFsKGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHNwYW4sIHNlbGZDbG9zaW5nID8gSWRlbnRpZmllcnMuaTE4biA6IElkZW50aWZpZXJzLmkxOG5TdGFydCwgcGFyYW1zKTtcbiAgICB9XG4gICAgaTE4bkVuZChzcGFuID0gbnVsbCwgc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgaWYgKCF0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaTE4bkVuZCBpcyBleGVjdXRlZCB3aXRoIG5vIGkxOG4gY29udGV4dCBwcmVzZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaTE4bkNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bkNvbnRleHQucmVjb25jaWxlQ2hpbGRDb250ZXh0KHRoaXMuaTE4bik7XG4gICAgICAgICAgICB0aGlzLmkxOG5VcGRhdGVSZWYodGhpcy5pMThuQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5VcGRhdGVSZWYodGhpcy5pMThuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR1cCBhY2N1bXVsYXRlZCBiaW5kaW5nc1xuICAgICAgICBjb25zdCB7IGluZGV4LCBiaW5kaW5ncyB9ID0gdGhpcy5pMThuO1xuICAgICAgICBpZiAoYmluZGluZ3Muc2l6ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGkxOG4gYmxvY2ssIGFkdmFuY2UgdG8gdGhlIG1vc3QgcmVjZW50IGVsZW1lbnQgaW5kZXggKGJ5IHRha2luZyB0aGUgY3VycmVudCBudW1iZXIgb2ZcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50cyBhbmQgc3VidHJhY3Rpbmcgb25lKSBiZWZvcmUgaW52b2tpbmcgYGkxOG5FeHBgIGluc3RydWN0aW9ucywgdG8gbWFrZSBzdXJlIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5lY2Vzc2FyeSBsaWZlY3ljbGUgaG9va3Mgb2YgY29tcG9uZW50cy9kaXJlY3RpdmVzIGFyZSBwcm9wZXJseSBmbHVzaGVkLlxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25XaXRoQWR2YW5jZSh0aGlzLmdldENvbnN0Q291bnQoKSAtIDEsIHNwYW4sIElkZW50aWZpZXJzLmkxOG5FeHAsICgpID0+IHRoaXMuY29udmVydFByb3BlcnR5QmluZGluZyhiaW5kaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uKHNwYW4sIElkZW50aWZpZXJzLmkxOG5BcHBseSwgW2xpdGVyYWwoaW5kZXgpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxmQ2xvc2luZykge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHNwYW4sIElkZW50aWZpZXJzLmkxOG5FbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaTE4biA9IG51bGw7IC8vIHJlc2V0IGxvY2FsIGkxOG4gY29udGV4dFxuICAgIH1cbiAgICBpMThuQXR0cmlidXRlc0luc3RydWN0aW9uKG5vZGVJbmRleCwgYXR0cnMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgbGV0IGhhc0JpbmRpbmdzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGkxOG5BdHRyQXJncyA9IFtdO1xuICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGF0dHIuaTE4bjtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZCA9IGF0dHIudmFsdWUudmlzaXQodGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyhjb252ZXJ0ZWQpO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnRlZCBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlcnMgPSBhc3NlbWJsZUJvdW5kVGV4dFBsYWNlaG9sZGVycyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBwbGFjZWhvbGRlcnNUb1BhcmFtcyhwbGFjZWhvbGRlcnMpO1xuICAgICAgICAgICAgICAgIGkxOG5BdHRyQXJncy5wdXNoKGxpdGVyYWwoYXR0ci5uYW1lKSwgdGhpcy5pMThuVHJhbnNsYXRlKG1lc3NhZ2UsIHBhcmFtcykpO1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZC5leHByZXNzaW9ucy5mb3JFYWNoKGV4cHJlc3Npb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25XaXRoQWR2YW5jZShub2RlSW5kZXgsIHNvdXJjZVNwYW4sIElkZW50aWZpZXJzLmkxOG5FeHAsICgpID0+IHRoaXMuY29udmVydFByb3BlcnR5QmluZGluZyhleHByZXNzaW9uKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaTE4bkF0dHJBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gbGl0ZXJhbCh0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKSk7XG4gICAgICAgICAgICBjb25zdCBjb25zdEluZGV4ID0gdGhpcy5hZGRUb0NvbnN0cyhsaXRlcmFsQXJyKGkxOG5BdHRyQXJncykpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHNvdXJjZVNwYW4sIElkZW50aWZpZXJzLmkxOG5BdHRyaWJ1dGVzLCBbaW5kZXgsIGNvbnN0SW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChoYXNCaW5kaW5ncykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb24oc291cmNlU3BhbiwgSWRlbnRpZmllcnMuaTE4bkFwcGx5LCBbaW5kZXhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXROYW1lc3BhY2VJbnN0cnVjdGlvbihuYW1lc3BhY2VLZXkpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lc3BhY2VLZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ21hdGgnOlxuICAgICAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5uYW1lc3BhY2VNYXRoTUw7XG4gICAgICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5uYW1lc3BhY2VTVkc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5uYW1lc3BhY2VIVE1MO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZE5hbWVzcGFjZUluc3RydWN0aW9uKG5zSW5zdHJ1Y3Rpb24sIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fbmFtZXNwYWNlID0gbnNJbnN0cnVjdGlvbjtcbiAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBuc0luc3RydWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiB1cGRhdGUgaW5zdHJ1Y3Rpb24gZm9yIGFuIGludGVycG9sYXRlZCBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUsIHN1Y2ggYXNcbiAgICAgKiBgcHJvcD1cInt7dmFsdWV9fVwiYCBvciBgYXR0ci50aXRsZT1cInt7dmFsdWV9fVwiYFxuICAgICAqL1xuICAgIGludGVycG9sYXRlZFVwZGF0ZUluc3RydWN0aW9uKGluc3RydWN0aW9uLCBlbGVtZW50SW5kZXgsIGF0dHJOYW1lLCBpbnB1dCwgdmFsdWUsIHBhcmFtcykge1xuICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2UoZWxlbWVudEluZGV4LCBpbnB1dC5zb3VyY2VTcGFuLCBpbnN0cnVjdGlvbiwgKCkgPT4gW2xpdGVyYWwoYXR0ck5hbWUpLCAuLi50aGlzLmdldFVwZGF0ZUluc3RydWN0aW9uQXJndW1lbnRzKHZhbHVlKSwgLi4ucGFyYW1zXSk7XG4gICAgfVxuICAgIHZpc2l0Q29udGVudChuZ0NvbnRlbnQpIHtcbiAgICAgICAgY29uc3Qgc2xvdCA9IHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpO1xuICAgICAgICBjb25zdCBwcm9qZWN0aW9uU2xvdElkeCA9IHRoaXMuX25nQ29udGVudFNlbGVjdG9yc09mZnNldCArIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gW2xpdGVyYWwoc2xvdCldO1xuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLnB1c2gobmdDb250ZW50LnNlbGVjdG9yKTtcbiAgICAgICAgY29uc3Qgbm9uQ29udGVudFNlbGVjdEF0dHJpYnV0ZXMgPSBuZ0NvbnRlbnQuYXR0cmlidXRlcy5maWx0ZXIoYXR0ciA9PiBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSAhPT0gTkdfQ09OVEVOVF9TRUxFQ1RfQVRUUik7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmdldEF0dHJpYnV0ZUV4cHJlc3Npb25zKG5nQ29udGVudC5uYW1lLCBub25Db250ZW50U2VsZWN0QXR0cmlidXRlcywgW10sIFtdKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKGxpdGVyYWwocHJvamVjdGlvblNsb3RJZHgpLCBsaXRlcmFsQXJyKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0aW9uU2xvdElkeCAhPT0gMCkge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5wdXNoKGxpdGVyYWwocHJvamVjdGlvblNsb3RJZHgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obmdDb250ZW50LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzLnByb2plY3Rpb24sIHBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAodGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kUHJvamVjdGlvbihuZ0NvbnRlbnQuaTE4biwgc2xvdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZWxlbWVudEluZGV4ID0gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7XG4gICAgICAgIGNvbnN0IHN0eWxpbmdCdWlsZGVyID0gbmV3IFN0eWxpbmdCdWlsZGVyKG51bGwpO1xuICAgICAgICBsZXQgaXNOb25CaW5kYWJsZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaXNJMThuUm9vdEVsZW1lbnQgPSBpc0kxOG5Sb290Tm9kZShlbGVtZW50LmkxOG4pICYmICFpc1NpbmdsZUkxOG5JY3UoZWxlbWVudC5pMThuKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0QXR0cnMgPSBbXTtcbiAgICAgICAgY29uc3QgW25hbWVzcGFjZUtleSwgZWxlbWVudE5hbWVdID0gc3BsaXROc05hbWUoZWxlbWVudC5uYW1lKTtcbiAgICAgICAgY29uc3QgaXNOZ0NvbnRhaW5lciQxID0gaXNOZ0NvbnRhaW5lcihlbGVtZW50Lm5hbWUpO1xuICAgICAgICAvLyBIYW5kbGUgc3R5bGluZywgaTE4biwgbmdOb25CaW5kYWJsZSBhdHRyaWJ1dGVzXG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBlbGVtZW50LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUgfSA9IGF0dHI7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gTk9OX0JJTkRBQkxFX0FUVFIpIHtcbiAgICAgICAgICAgICAgICBpc05vbkJpbmRhYmxlTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgc3R5bGluZ0J1aWxkZXIucmVnaXN0ZXJTdHlsZUF0dHIodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIHN0eWxpbmdCdWlsZGVyLnJlZ2lzdGVyQ2xhc3NBdHRyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dEF0dHJzLnB1c2goYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVndWxhciBlbGVtZW50IG9yIG5nLWNvbnRhaW5lciBjcmVhdGlvbiBtb2RlXG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbbGl0ZXJhbChlbGVtZW50SW5kZXgpXTtcbiAgICAgICAgaWYgKCFpc05nQ29udGFpbmVyJDEpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChsaXRlcmFsKGVsZW1lbnROYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG4gICAgICAgIGNvbnN0IGFsbE90aGVySW5wdXRzID0gW107XG4gICAgICAgIGNvbnN0IGJvdW5kSTE4bkF0dHJzID0gW107XG4gICAgICAgIGVsZW1lbnQuaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGluZ0lucHV0V2FzU2V0ID0gc3R5bGluZ0J1aWxkZXIucmVnaXN0ZXJCb3VuZElucHV0KGlucHV0KTtcbiAgICAgICAgICAgIGlmICghc3R5bGluZ0lucHV0V2FzU2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09IDAgLyogQmluZGluZ1R5cGUuUHJvcGVydHkgKi8gJiYgaW5wdXQuaTE4bikge1xuICAgICAgICAgICAgICAgICAgICBib3VuZEkxOG5BdHRycy5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbE90aGVySW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGFkZCBhdHRyaWJ1dGVzIGZvciBkaXJlY3RpdmUgYW5kIHByb2plY3Rpb24gbWF0Y2hpbmcgcHVycG9zZXNcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMuZ2V0QXR0cmlidXRlRXhwcmVzc2lvbnMoZWxlbWVudC5uYW1lLCBvdXRwdXRBdHRycywgYWxsT3RoZXJJbnB1dHMsIGVsZW1lbnQub3V0cHV0cywgc3R5bGluZ0J1aWxkZXIsIFtdLCBib3VuZEkxOG5BdHRycyk7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLmFkZEF0dHJzVG9Db25zdHMoYXR0cmlidXRlcykpO1xuICAgICAgICAvLyBsb2NhbCByZWZzIChleC46IDxkaXYgI2ZvbyAjYmFyPVwiYmF6XCI+KVxuICAgICAgICBjb25zdCByZWZzID0gdGhpcy5wcmVwYXJlUmVmc0FycmF5KGVsZW1lbnQucmVmZXJlbmNlcyk7XG4gICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLmFkZFRvQ29uc3RzKHJlZnMpKTtcbiAgICAgICAgY29uc3Qgd2FzSW5OYW1lc3BhY2UgPSB0aGlzLl9uYW1lc3BhY2U7XG4gICAgICAgIGNvbnN0IGN1cnJlbnROYW1lc3BhY2UgPSB0aGlzLmdldE5hbWVzcGFjZUluc3RydWN0aW9uKG5hbWVzcGFjZUtleSk7XG4gICAgICAgIC8vIElmIHRoZSBuYW1lc3BhY2UgaXMgY2hhbmdpbmcgbm93LCBpbmNsdWRlIGFuIGluc3RydWN0aW9uIHRvIGNoYW5nZSBpdFxuICAgICAgICAvLyBkdXJpbmcgZWxlbWVudCBjcmVhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnROYW1lc3BhY2UgIT09IHdhc0luTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmFkZE5hbWVzcGFjZUluc3RydWN0aW9uKGN1cnJlbnROYW1lc3BhY2UsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bi5hcHBlbmRFbGVtZW50KGVsZW1lbnQuaTE4biwgZWxlbWVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgZG8gbm90IGFwcGVuZCB0ZXh0IG5vZGUgaW5zdHJ1Y3Rpb25zIGFuZCBJQ1VzIGluc2lkZSBpMThuIHNlY3Rpb24sXG4gICAgICAgIC8vIHNvIHdlIGV4Y2x1ZGUgdGhlbSB3aGlsZSBjYWxjdWxhdGluZyB3aGV0aGVyIGN1cnJlbnQgZWxlbWVudCBoYXMgY2hpbGRyZW5cbiAgICAgICAgY29uc3QgaGFzQ2hpbGRyZW4gPSAoIWlzSTE4blJvb3RFbGVtZW50ICYmIHRoaXMuaTE4bikgPyAhaGFzVGV4dENoaWxkcmVuT25seShlbGVtZW50LmNoaWxkcmVuKSA6XG4gICAgICAgICAgICBlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IGNyZWF0ZVNlbGZDbG9zaW5nSW5zdHJ1Y3Rpb24gPSAhc3R5bGluZ0J1aWxkZXIuaGFzQmluZGluZ3NXaXRoUGlwZXMgJiZcbiAgICAgICAgICAgIGVsZW1lbnQub3V0cHV0cy5sZW5ndGggPT09IDAgJiYgYm91bmRJMThuQXR0cnMubGVuZ3RoID09PSAwICYmICFoYXNDaGlsZHJlbjtcbiAgICAgICAgY29uc3QgY3JlYXRlU2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24gPSAhY3JlYXRlU2VsZkNsb3NpbmdJbnN0cnVjdGlvbiAmJiBoYXNUZXh0Q2hpbGRyZW5Pbmx5KGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICBpZiAoY3JlYXRlU2VsZkNsb3NpbmdJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKGVsZW1lbnQuc291cmNlU3BhbiwgaXNOZ0NvbnRhaW5lciQxID8gSWRlbnRpZmllcnMuZWxlbWVudENvbnRhaW5lciA6IElkZW50aWZpZXJzLmVsZW1lbnQsIHRyaW1UcmFpbGluZ051bGxzKHBhcmFtZXRlcnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgaXNOZ0NvbnRhaW5lciQxID8gSWRlbnRpZmllcnMuZWxlbWVudENvbnRhaW5lclN0YXJ0IDogSWRlbnRpZmllcnMuZWxlbWVudFN0YXJ0LCB0cmltVHJhaWxpbmdOdWxscyhwYXJhbWV0ZXJzKSk7XG4gICAgICAgICAgICBpZiAoaXNOb25CaW5kYWJsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIElkZW50aWZpZXJzLmRpc2FibGVCaW5kaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm91bmRJMThuQXR0cnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaTE4bkF0dHJpYnV0ZXNJbnN0cnVjdGlvbihlbGVtZW50SW5kZXgsIGJvdW5kSTE4bkF0dHJzLCAoX2EgPSBlbGVtZW50LnN0YXJ0U291cmNlU3BhbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIExpc3RlbmVycyAob3V0cHV0cylcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm91dHB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3V0cHV0QXN0IG9mIGVsZW1lbnQub3V0cHV0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24ob3V0cHV0QXN0LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzLmxpc3RlbmVyLCB0aGlzLnByZXBhcmVMaXN0ZW5lclBhcmFtZXRlcihlbGVtZW50Lm5hbWUsIG91dHB1dEFzdCwgZWxlbWVudEluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogaXQncyBpbXBvcnRhbnQgdG8ga2VlcCBpMThuL2kxOG5TdGFydCBpbnN0cnVjdGlvbnMgYWZ0ZXIgaTE4bkF0dHJpYnV0ZXMgYW5kXG4gICAgICAgICAgICAvLyBsaXN0ZW5lcnMsIHRvIG1ha2Ugc3VyZSBpMThuQXR0cmlidXRlcyBpbnN0cnVjdGlvbiB0YXJnZXRzIGN1cnJlbnQgZWxlbWVudCBhdCBydW50aW1lLlxuICAgICAgICAgICAgaWYgKGlzSTE4blJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuU3RhcnQoZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4biwgY3JlYXRlU2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBjb2RlIGhlcmUgd2lsbCBjb2xsZWN0IGFsbCB1cGRhdGUtbGV2ZWwgc3R5bGluZyBpbnN0cnVjdGlvbnMgYW5kIGFkZCB0aGVtIHRvIHRoZVxuICAgICAgICAvLyB1cGRhdGUgYmxvY2sgb2YgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uIEFPVCBjb2RlLiBJbnN0cnVjdGlvbnMgbGlrZSBgc3R5bGVQcm9wYCxcbiAgICAgICAgLy8gYHN0eWxlTWFwYCwgYGNsYXNzTWFwYCwgYGNsYXNzUHJvcGBcbiAgICAgICAgLy8gYXJlIGFsbCBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGluIHRoZSBjb2RlIGJlbG93LlxuICAgICAgICBjb25zdCBzdHlsaW5nSW5zdHJ1Y3Rpb25zID0gc3R5bGluZ0J1aWxkZXIuYnVpbGRVcGRhdGVMZXZlbEluc3RydWN0aW9ucyh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gc3R5bGluZ0luc3RydWN0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHN0eWxpbmdJbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nU2xvdHMgKz0gdGhpcy5wcm9jZXNzU3R5bGluZ1VwZGF0ZUluc3RydWN0aW9uKGVsZW1lbnRJbmRleCwgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSByZWFzb24gd2h5IGB1bmRlZmluZWRgIGlzIHVzZWQgaXMgYmVjYXVzZSB0aGUgcmVuZGVyZXIgdW5kZXJzdGFuZHMgdGhpcyBhcyBhXG4gICAgICAgIC8vIHNwZWNpYWwgdmFsdWUgdG8gc3ltYm9saXplIHRoYXQgdGhlcmUgaXMgbm8gUkhTIHRvIHRoaXMgYmluZGluZ1xuICAgICAgICAvLyBUT0RPIChtYXRza28pOiByZXZpc2l0IHRoaXMgb25jZSBGVy05NTkgaXMgYXBwcm9hY2hlZFxuICAgICAgICBjb25zdCBlbXB0eVZhbHVlQmluZEluc3RydWN0aW9uID0gbGl0ZXJhbCh1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eUJpbmRpbmdzID0gW107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZUJpbmRpbmdzID0gW107XG4gICAgICAgIC8vIEdlbmVyYXRlIGVsZW1lbnQgaW5wdXQgYmluZGluZ3NcbiAgICAgICAgYWxsT3RoZXJJbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dC50eXBlO1xuICAgICAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gNCAvKiBCaW5kaW5nVHlwZS5BbmltYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlLnZpc2l0KHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24gYmluZGluZ3MgY2FuIGJlIHByZXNlbnRlZCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6XG4gICAgICAgICAgICAgICAgLy8gMS4gW0BiaW5kaW5nXT1cImZvb0V4cFwiXG4gICAgICAgICAgICAgICAgLy8gMi4gW0BiaW5kaW5nXT1cInt2YWx1ZTpmb29FeHAsIHBhcmFtczp7Li4ufX1cIlxuICAgICAgICAgICAgICAgIC8vIDMuIFtAYmluZGluZ11cbiAgICAgICAgICAgICAgICAvLyA0LiBAYmluZGluZ1xuICAgICAgICAgICAgICAgIC8vIEFsbCBmb3JtYXRzIHdpbGwgYmUgdmFsaWQgZm9yIHdoZW4gYSBzeW50aGV0aWMgYmluZGluZyBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb25pbmcgZm9yIHRoaXMgaXMgYmVjYXVzZSB0aGUgcmVuZGVyZXIgc2hvdWxkIGdldCBlYWNoXG4gICAgICAgICAgICAgICAgLy8gc3ludGhldGljIGJpbmRpbmcgdmFsdWUgaW4gdGhlIG9yZGVyIG9mIHRoZSBhcnJheSB0aGF0IHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lZCBpbi4uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1ZhbHVlID0gdmFsdWUgaW5zdGFuY2VvZiBMaXRlcmFsUHJpbWl0aXZlID8gISF2YWx1ZS52YWx1ZSA6IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zT3JGbjogZ2V0QmluZGluZ0Z1bmN0aW9uUGFyYW1zKCgpID0+IGhhc1ZhbHVlID8gdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSA6IGVtcHR5VmFsdWVCaW5kSW5zdHJ1Y3Rpb24sIHByZXBhcmVTeW50aGV0aWNQcm9wZXJ0eU5hbWUoaW5wdXQubmFtZSkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBtdXN0IHNraXAgYXR0cmlidXRlcyB3aXRoIGFzc29jaWF0ZWQgaTE4biBjb250ZXh0LCBzaW5jZSB0aGVzZSBhdHRyaWJ1dGVzIGFyZSBoYW5kbGVkXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdGVseSBhbmQgY29ycmVzcG9uZGluZyBgaTE4bkV4cGAgYW5kIGBpMThuQXBwbHlgIGluc3RydWN0aW9ucyB3aWxsIGJlIGdlbmVyYXRlZFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5pMThuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZS52aXNpdCh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFthdHRyTmFtZXNwYWNlLCBhdHRyTmFtZV0gPSBzcGxpdE5zTmFtZShpbnB1dC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNBdHRyaWJ1dGVCaW5kaW5nID0gaW5wdXRUeXBlID09PSAxIC8qIEJpbmRpbmdUeXBlLkF0dHJpYnV0ZSAqLztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemF0aW9uUmVmID0gcmVzb2x2ZVNhbml0aXphdGlvbkZuKGlucHV0LnNlY3VyaXR5Q29udGV4dCwgaXNBdHRyaWJ1dGVCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbml0aXphdGlvblJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHNhbml0aXphdGlvblJlZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2VMaXRlcmFsID0gbGl0ZXJhbChhdHRyTmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYW5pdGl6YXRpb25SZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChuYW1lc3BhY2VMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhc24ndCBhIHNhbml0aXphdGlvbiByZWYsIHdlIG5lZWQgdG8gYWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gZXh0cmEgcGFyYW0gc28gdGhhdCB3ZSBjYW4gcGFzcyBpbiB0aGUgbmFtZXNwYWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwobnVsbCksIG5hbWVzcGFjZUxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRUeXBlID09PSAwIC8qIEJpbmRpbmdUeXBlLlByb3BlcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcD1cInt7dmFsdWV9fVwiIGFuZCBmcmllbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZWRVcGRhdGVJbnN0cnVjdGlvbihnZXRQcm9wZXJ0eUludGVycG9sYXRpb25FeHByZXNzaW9uKHZhbHVlKSwgZWxlbWVudEluZGV4LCBhdHRyTmFtZSwgaW5wdXQsIHZhbHVlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW3Byb3BdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbGxlY3QgYWxsIHRoZSBwcm9wZXJ0aWVzIHNvIHRoYXQgd2UgY2FuIGNoYWluIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gYXQgdGhlIGVuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNPckZuOiBnZXRCaW5kaW5nRnVuY3Rpb25QYXJhbXMoKCkgPT4gdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSwgYXR0ck5hbWUsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnB1dFR5cGUgPT09IDEgLyogQmluZGluZ1R5cGUuQXR0cmlidXRlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uICYmIGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKHZhbHVlKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRyLm5hbWU9XCJ0ZXh0e3t2YWx1ZX19XCIgYW5kIGZyaWVuZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRlZFVwZGF0ZUluc3RydWN0aW9uKGdldEF0dHJpYnV0ZUludGVycG9sYXRpb25FeHByZXNzaW9uKHZhbHVlKSwgZWxlbWVudEluZGV4LCBhdHRyTmFtZSwgaW5wdXQsIHZhbHVlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRWYWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbiA/IHZhbHVlLmV4cHJlc3Npb25zWzBdIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW2F0dHIubmFtZV09XCJ2YWx1ZVwiIG9yIGF0dHIubmFtZT1cInt7dmFsdWV9fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCB0aGUgYXR0cmlidXRlIGJpbmRpbmdzIHNvIHRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZCBhdCB0aGUgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNPckZuOiBnZXRCaW5kaW5nRnVuY3Rpb25QYXJhbXMoKCkgPT4gdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKGJvdW5kVmFsdWUpLCBhdHRyTmFtZSwgcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xhc3MgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgaW5wdXQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMuY2xhc3NQcm9wLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbChlbGVtZW50SW5kZXgpLCBsaXRlcmFsKGF0dHJOYW1lKSwgdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eUJpbmRpbmcgb2YgcHJvcGVydHlCaW5kaW5ncykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgcHJvcGVydHlCaW5kaW5nLnNwYW4sIElkZW50aWZpZXJzLnByb3BlcnR5LCBwcm9wZXJ0eUJpbmRpbmcucGFyYW1zT3JGbik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVCaW5kaW5nIG9mIGF0dHJpYnV0ZUJpbmRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2UoZWxlbWVudEluZGV4LCBhdHRyaWJ1dGVCaW5kaW5nLnNwYW4sIElkZW50aWZpZXJzLmF0dHJpYnV0ZSwgYXR0cmlidXRlQmluZGluZy5wYXJhbXNPckZuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmF2ZXJzZSBlbGVtZW50IGNoaWxkIG5vZGVzXG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGlmICghaXNJMThuUm9vdEVsZW1lbnQgJiYgdGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kRWxlbWVudChlbGVtZW50LmkxOG4sIGVsZW1lbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjcmVhdGVTZWxmQ2xvc2luZ0luc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2ggZWxlbWVudCBjb25zdHJ1Y3Rpb24gbW9kZS5cbiAgICAgICAgICAgIGNvbnN0IHNwYW4gPSAoX2IgPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGVsZW1lbnQuc291cmNlU3BhbjtcbiAgICAgICAgICAgIGlmIChpc0kxOG5Sb290RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaTE4bkVuZChzcGFuLCBjcmVhdGVTZWxmQ2xvc2luZ0kxOG5JbnN0cnVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOb25CaW5kYWJsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3BhbiwgSWRlbnRpZmllcnMuZW5hYmxlQmluZGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHNwYW4sIGlzTmdDb250YWluZXIkMSA/IElkZW50aWZpZXJzLmVsZW1lbnRDb250YWluZXJFbmQgOiBJZGVudGlmaWVycy5lbGVtZW50RW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgTkdfVEVNUExBVEVfVEFHX05BTUUgPSAnbmctdGVtcGxhdGUnO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZUluZGV4ID0gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7XG4gICAgICAgIGlmICh0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bi5hcHBlbmRUZW1wbGF0ZSh0ZW1wbGF0ZS5pMThuLCB0ZW1wbGF0ZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWdOYW1lV2l0aG91dE5hbWVzcGFjZSA9IHRlbXBsYXRlLnRhZ05hbWUgPyBzcGxpdE5zTmFtZSh0ZW1wbGF0ZS50YWdOYW1lKVsxXSA6IHRlbXBsYXRlLnRhZ05hbWU7XG4gICAgICAgIGNvbnN0IGNvbnRleHROYW1lID0gYCR7dGhpcy5jb250ZXh0TmFtZX0ke3RlbXBsYXRlLnRhZ05hbWUgPyAnXycgKyBzYW5pdGl6ZUlkZW50aWZpZXIodGVtcGxhdGUudGFnTmFtZSkgOiAnJ31fJHt0ZW1wbGF0ZUluZGV4fWA7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlTmFtZSA9IGAke2NvbnRleHROYW1lfV9UZW1wbGF0ZWA7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICBsaXRlcmFsKHRlbXBsYXRlSW5kZXgpLFxuICAgICAgICAgICAgdmFyaWFibGUodGVtcGxhdGVOYW1lKSxcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIHRhZydzIG5hbWVzcGFjZSBoZXJlLCBiZWNhdXNlIHdlIGluZmVyXG4gICAgICAgICAgICAvLyBpdCBiYXNlZCBvbiB0aGUgcGFyZW50IG5vZGVzIGluc2lkZSB0aGUgdGVtcGxhdGUgaW5zdHJ1Y3Rpb24uXG4gICAgICAgICAgICBsaXRlcmFsKHRhZ05hbWVXaXRob3V0TmFtZXNwYWNlKSxcbiAgICAgICAgXTtcbiAgICAgICAgLy8gcHJlcGFyZSBhdHRyaWJ1dGVzIHBhcmFtZXRlciAoaW5jbHVkaW5nIGF0dHJpYnV0ZXMgdXNlZCBmb3IgZGlyZWN0aXZlIG1hdGNoaW5nKVxuICAgICAgICBjb25zdCBhdHRyc0V4cHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVFeHByZXNzaW9ucyhOR19URU1QTEFURV9UQUdfTkFNRSwgdGVtcGxhdGUuYXR0cmlidXRlcywgdGVtcGxhdGUuaW5wdXRzLCB0ZW1wbGF0ZS5vdXRwdXRzLCB1bmRlZmluZWQgLyogc3R5bGVzICovLCB0ZW1wbGF0ZS50ZW1wbGF0ZUF0dHJzKTtcbiAgICAgICAgcGFyYW1ldGVycy5wdXNoKHRoaXMuYWRkQXR0cnNUb0NvbnN0cyhhdHRyc0V4cHJzKSk7XG4gICAgICAgIC8vIGxvY2FsIHJlZnMgKGV4LjogPG5nLXRlbXBsYXRlICNmb28+KVxuICAgICAgICBpZiAodGVtcGxhdGUucmVmZXJlbmNlcyAmJiB0ZW1wbGF0ZS5yZWZlcmVuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVmcyA9IHRoaXMucHJlcGFyZVJlZnNBcnJheSh0ZW1wbGF0ZS5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLmFkZFRvQ29uc3RzKHJlZnMpKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzLnRlbXBsYXRlUmVmRXh0cmFjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZVZpc2l0b3IgPSBuZXcgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlcih0aGlzLmNvbnN0YW50UG9vbCwgdGhpcy5fYmluZGluZ1Njb3BlLCB0aGlzLmxldmVsICsgMSwgY29udGV4dE5hbWUsIHRoaXMuaTE4biwgdGVtcGxhdGVJbmRleCwgdGVtcGxhdGVOYW1lLCB0aGlzLl9uYW1lc3BhY2UsIHRoaXMuZmlsZUJhc2VkSTE4blN1ZmZpeCwgdGhpcy5pMThuVXNlRXh0ZXJuYWxJZHMsIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgICAgIC8vIE5lc3RlZCB0ZW1wbGF0ZXMgbXVzdCBub3QgYmUgdmlzaXRlZCB1bnRpbCBhZnRlciB0aGVpciBwYXJlbnQgdGVtcGxhdGVzIGhhdmUgY29tcGxldGVkXG4gICAgICAgIC8vIHByb2Nlc3NpbmcsIHNvIHRoZXkgYXJlIHF1ZXVlZCBoZXJlIHVudGlsIGFmdGVyIHRoZSBpbml0aWFsIHBhc3MuIE90aGVyd2lzZSwgd2Ugd291bGRuJ3RcbiAgICAgICAgLy8gYmUgYWJsZSB0byBzdXBwb3J0IGJpbmRpbmdzIGluIG5lc3RlZCB0ZW1wbGF0ZXMgdG8gbG9jYWwgcmVmcyB0aGF0IG9jY3VyIGFmdGVyIHRoZVxuICAgICAgICAvLyB0ZW1wbGF0ZSBkZWZpbml0aW9uLiBlLmcuIDxkaXYgKm5nSWY9XCJzaG93aW5nXCI+e3sgZm9vIH19PC9kaXY+ICA8ZGl2ICNmb28+PC9kaXY+XG4gICAgICAgIHRoaXMuX25lc3RlZFRlbXBsYXRlRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVGdW5jdGlvbkV4cHIgPSB0ZW1wbGF0ZVZpc2l0b3IuYnVpbGRUZW1wbGF0ZUZ1bmN0aW9uKHRlbXBsYXRlLmNoaWxkcmVuLCB0ZW1wbGF0ZS52YXJpYWJsZXMsIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoICsgdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0LCB0ZW1wbGF0ZS5pMThuKTtcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRQb29sLnN0YXRlbWVudHMucHVzaCh0ZW1wbGF0ZUZ1bmN0aW9uRXhwci50b0RlY2xTdG10KHRlbXBsYXRlTmFtZSkpO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlVmlzaXRvci5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLnB1c2goLi4udGVtcGxhdGVWaXNpdG9yLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGUuZy4gdGVtcGxhdGUoMSwgTXlDb21wX1RlbXBsYXRlXzEpXG4gICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbih0ZW1wbGF0ZS5zb3VyY2VTcGFuLCBJZGVudGlmaWVycy50ZW1wbGF0ZUNyZWF0ZSwgKCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5zcGxpY2UoMiwgMCwgbGl0ZXJhbCh0ZW1wbGF0ZVZpc2l0b3IuZ2V0Q29uc3RDb3VudCgpKSwgbGl0ZXJhbCh0ZW1wbGF0ZVZpc2l0b3IuZ2V0VmFyQ291bnQoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRyaW1UcmFpbGluZ051bGxzKHBhcmFtZXRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaGFuZGxlIHByb3BlcnR5IGJpbmRpbmdzIGUuZy4gybXJtXByb3BlcnR5KCduZ0Zvck9mJywgY3R4Lml0ZW1zKSwgZXQgYWw7XG4gICAgICAgIHRoaXMudGVtcGxhdGVQcm9wZXJ0eUJpbmRpbmdzKHRlbXBsYXRlSW5kZXgsIHRlbXBsYXRlLnRlbXBsYXRlQXR0cnMpO1xuICAgICAgICAvLyBPbmx5IGFkZCBub3JtYWwgaW5wdXQvb3V0cHV0IGJpbmRpbmcgaW5zdHJ1Y3Rpb25zIG9uIGV4cGxpY2l0IDxuZy10ZW1wbGF0ZT4gZWxlbWVudHMuXG4gICAgICAgIGlmICh0YWdOYW1lV2l0aG91dE5hbWVzcGFjZSA9PT0gTkdfVEVNUExBVEVfVEFHX05BTUUpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpMThuSW5wdXRzLCBpbnB1dHNdID0gcGFydGl0aW9uQXJyYXkodGVtcGxhdGUuaW5wdXRzLCBoYXNJMThuTWV0YSk7XG4gICAgICAgICAgICAvLyBBZGQgaTE4biBhdHRyaWJ1dGVzIHRoYXQgbWF5IGFjdCBhcyBpbnB1dHMgdG8gZGlyZWN0aXZlcy4gSWYgc3VjaCBhdHRyaWJ1dGVzIGFyZSBwcmVzZW50LFxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgYGkxOG5BdHRyaWJ1dGVzYCBpbnN0cnVjdGlvbi4gTm90ZTogd2UgZ2VuZXJhdGUgaXQgb25seSBmb3IgZXhwbGljaXQgPG5nLXRlbXBsYXRlPlxuICAgICAgICAgICAgLy8gZWxlbWVudHMsIGluIGNhc2Ugb2YgaW5saW5lIHRlbXBsYXRlcywgY29ycmVzcG9uZGluZyBpbnN0cnVjdGlvbnMgd2lsbCBiZSBnZW5lcmF0ZWQgaW4gdGhlXG4gICAgICAgICAgICAvLyBuZXN0ZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAoaTE4bklucHV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuQXR0cmlidXRlc0luc3RydWN0aW9uKHRlbXBsYXRlSW5kZXgsIGkxOG5JbnB1dHMsIChfYSA9IHRlbXBsYXRlLnN0YXJ0U291cmNlU3BhbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGVtcGxhdGUuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGlucHV0IGJpbmRpbmdzXG4gICAgICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlUHJvcGVydHlCaW5kaW5ncyh0ZW1wbGF0ZUluZGV4LCBpbnB1dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgbGlzdGVuZXJzIGZvciBkaXJlY3RpdmUgb3V0cHV0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG91dHB1dEFzdCBvZiB0ZW1wbGF0ZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKG91dHB1dEFzdC5zb3VyY2VTcGFuLCBJZGVudGlmaWVycy5saXN0ZW5lciwgdGhpcy5wcmVwYXJlTGlzdGVuZXJQYXJhbWV0ZXIoJ25nX3RlbXBsYXRlJywgb3V0cHV0QXN0LCB0ZW1wbGF0ZUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRCb3VuZFRleHQodGV4dCkge1xuICAgICAgICBpZiAodGhpcy5pMThuKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRleHQudmFsdWUudmlzaXQodGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuLmFwcGVuZEJvdW5kVGV4dCh0ZXh0LmkxOG4pO1xuICAgICAgICAgICAgICAgIHRoaXMuaTE4bkFwcGVuZEJpbmRpbmdzKHZhbHVlLmV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlSW5kZXggPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKHRleHQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMudGV4dCwgW2xpdGVyYWwobm9kZUluZGV4KV0pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRleHQudmFsdWUudmlzaXQodGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICB0aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlKG5vZGVJbmRleCwgdGV4dC5zb3VyY2VTcGFuLCBnZXRUZXh0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24odmFsdWUpLCAoKSA9PiB0aGlzLmdldFVwZGF0ZUluc3RydWN0aW9uQXJndW1lbnRzKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignVGV4dCBub2RlcyBzaG91bGQgYmUgaW50ZXJwb2xhdGVkIGFuZCBuZXZlciBib3VuZCBkaXJlY3RseS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICAvLyB3aGVuIGEgdGV4dCBlbGVtZW50IGlzIGxvY2F0ZWQgd2l0aGluIGEgdHJhbnNsYXRhYmxlXG4gICAgICAgIC8vIGJsb2NrLCB3ZSBleGNsdWRlIHRoaXMgdGV4dCBlbGVtZW50IGZyb20gaW5zdHJ1Y3Rpb25zIHNldCxcbiAgICAgICAgLy8gc2luY2UgaXQgd2lsbCBiZSBjYXB0dXJlZCBpbiBpMThuIGNvbnRlbnQgYW5kIHByb2Nlc3NlZCBhdCBydW50aW1lXG4gICAgICAgIGlmICghdGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24odGV4dC5zb3VyY2VTcGFuLCBJZGVudGlmaWVycy50ZXh0LCBbbGl0ZXJhbCh0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKSksIGxpdGVyYWwodGV4dC52YWx1ZSldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEljdShpY3UpIHtcbiAgICAgICAgbGV0IGluaXRXYXNJbnZva2VkID0gZmFsc2U7XG4gICAgICAgIC8vIGlmIGFuIElDVSB3YXMgY3JlYXRlZCBvdXRzaWRlIG9mIGkxOG4gYmxvY2ssIHdlIHN0aWxsIHRyZWF0XG4gICAgICAgIC8vIGl0IGFzIGEgdHJhbnNsYXRhYmxlIGVudGl0eSBhbmQgaW52b2tlIGkxOG5TdGFydCBhbmQgaTE4bkVuZFxuICAgICAgICAvLyB0byBnZW5lcmF0ZSBpMThuIGNvbnRleHQgYW5kIHRoZSBuZWNlc3NhcnkgaW5zdHJ1Y3Rpb25zXG4gICAgICAgIGlmICghdGhpcy5pMThuKSB7XG4gICAgICAgICAgICBpbml0V2FzSW52b2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmkxOG5TdGFydChudWxsLCBpY3UuaTE4biwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaTE4biA9IHRoaXMuaTE4bjtcbiAgICAgICAgY29uc3QgdmFycyA9IHRoaXMuaTE4bkJpbmRQcm9wcyhpY3UudmFycyk7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IHRoaXMuaTE4bkJpbmRQcm9wcyhpY3UucGxhY2Vob2xkZXJzKTtcbiAgICAgICAgLy8gb3V0cHV0IElDVSBkaXJlY3RseSBhbmQga2VlcCBJQ1UgcmVmZXJlbmNlIGluIGNvbnRleHRcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGljdS5pMThuO1xuICAgICAgICAvLyB3ZSBhbHdheXMgbmVlZCBwb3N0LXByb2Nlc3NpbmcgZnVuY3Rpb24gZm9yIElDVXMsIHRvIG1ha2Ugc3VyZSB0aGF0OlxuICAgICAgICAvLyAtIGFsbCBwbGFjZWhvbGRlcnMgaW4gYSBmb3JtIG9mIHtQTEFDRUhPTERFUn0gYXJlIHJlcGxhY2VkIHdpdGggYWN0dWFsIHZhbHVlcyAobm90ZTpcbiAgICAgICAgLy8gYGdvb2cuZ2V0TXNnYCBkb2VzIG5vdCBwcm9jZXNzIElDVXMgYW5kIHVzZXMgdGhlIGB7UExBQ0VIT0xERVJ9YCBmb3JtYXQgZm9yIHBsYWNlaG9sZGVyc1xuICAgICAgICAvLyBpbnNpZGUgSUNVcylcbiAgICAgICAgLy8gLSBhbGwgSUNVIHZhcnMgKHN1Y2ggYXMgYFZBUl9TRUxFQ1RgIG9yIGBWQVJfUExVUkFMYCkgYXJlIHJlcGxhY2VkIHdpdGggY29ycmVjdCB2YWx1ZXNcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtRm4gPSAocmF3KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhcnMpLCBwbGFjZWhvbGRlcnMpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZXNJbk1hcChwYXJhbXMsIC8qIHVzZUNhbWVsQ2FzZSAqLyBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlSW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMuaTE4blBvc3Rwcm9jZXNzLCBbcmF3LCBtYXBMaXRlcmFsKGZvcm1hdHRlZCwgdHJ1ZSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgd2hvbGUgaTE4biBtZXNzYWdlIGlzIGEgc2luZ2xlIElDVSAtIHdlIGRvIG5vdCBuZWVkIHRvXG4gICAgICAgIC8vIGNyZWF0ZSBhIHNlcGFyYXRlIHRvcC1sZXZlbCB0cmFuc2xhdGlvbiwgd2UgY2FuIHVzZSB0aGUgcm9vdCByZWYgaW5zdGVhZFxuICAgICAgICAvLyBhbmQgbWFrZSB0aGlzIElDVSBhIHRvcC1sZXZlbCB0cmFuc2xhdGlvblxuICAgICAgICAvLyBub3RlOiBJQ1UgcGxhY2Vob2xkZXJzIGFyZSByZXBsYWNlZCB3aXRoIGFjdHVhbCB2YWx1ZXMgaW4gYGkxOG5Qb3N0cHJvY2Vzc2AgZnVuY3Rpb25cbiAgICAgICAgLy8gc2VwYXJhdGVseSwgc28gd2UgZG8gbm90IHBhc3MgcGxhY2Vob2xkZXJzIGludG8gYGkxOG5UcmFuc2xhdGVgIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoaXNTaW5nbGVJMThuSWN1KGkxOG4ubWV0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4blRyYW5zbGF0ZShtZXNzYWdlLCAvKiBwbGFjZWhvbGRlcnMgKi8ge30sIGkxOG4ucmVmLCB0cmFuc2Zvcm1Gbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvdXRwdXQgSUNVIGRpcmVjdGx5IGFuZCBrZWVwIElDVSByZWZlcmVuY2UgaW4gY29udGV4dFxuICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5pMThuVHJhbnNsYXRlKG1lc3NhZ2UsIC8qIHBsYWNlaG9sZGVycyAqLyB7fSwgLyogcmVmICovIHVuZGVmaW5lZCwgdHJhbnNmb3JtRm4pO1xuICAgICAgICAgICAgaTE4bi5hcHBlbmRJY3UoaWN1RnJvbUkxOG5NZXNzYWdlKG1lc3NhZ2UpLm5hbWUsIHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRXYXNJbnZva2VkKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5FbmQobnVsbCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFsbG9jYXRlRGF0YVNsb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhSW5kZXgrKztcbiAgICB9XG4gICAgZ2V0Q29uc3RDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFJbmRleDtcbiAgICB9XG4gICAgZ2V0VmFyQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXJlRnVuY3Rpb25TbG90cztcbiAgICB9XG4gICAgZ2V0Q29uc3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uc3RhbnRzO1xuICAgIH1cbiAgICBnZXROZ0NvbnRlbnRTZWxlY3RvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLmxlbmd0aCA/XG4gICAgICAgICAgICB0aGlzLmNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwoYXNMaXRlcmFsKHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMpLCB0cnVlKSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH1cbiAgICBiaW5kaW5nQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuX2JpbmRpbmdDb250ZXh0Kyt9YDtcbiAgICB9XG4gICAgdGVtcGxhdGVQcm9wZXJ0eUJpbmRpbmdzKHRlbXBsYXRlSW5kZXgsIGF0dHJzKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5QmluZGluZ3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBhdHRycykge1xuICAgICAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBCb3VuZEF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQudmFsdWUudmlzaXQodGhpcy5fdmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFBhcmFtcyB0eXBpY2FsbHkgY29udGFpbiBhdHRyaWJ1dGUgbmFtZXNwYWNlIGFuZCB2YWx1ZSBzYW5pdGl6ZXIsIHdoaWNoIGlzIGFwcGxpY2FibGVcbiAgICAgICAgICAgICAgICAvLyBmb3IgcmVndWxhciBIVE1MIGVsZW1lbnRzLCBidXQgbm90IGFwcGxpY2FibGUgZm9yIDxuZy10ZW1wbGF0ZT4gKHNpbmNlIHByb3BzIGFjdCBhc1xuICAgICAgICAgICAgICAgIC8vIGlucHV0cyB0byBkaXJlY3RpdmVzKSwgc28ga2VlcCBwYXJhbXMgYXJyYXkgZW1wdHkuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgLy8gcHJvcD1cInt7dmFsdWV9fVwiIGNhc2VcbiAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRlZFVwZGF0ZUluc3RydWN0aW9uKGdldFByb3BlcnR5SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24odmFsdWUpLCB0ZW1wbGF0ZUluZGV4LCBpbnB1dC5uYW1lLCBpbnB1dCwgdmFsdWUsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBbcHJvcF09XCJ2YWx1ZVwiIGNhc2VcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNPckZuOiBnZXRCaW5kaW5nRnVuY3Rpb25QYXJhbXMoKCkgPT4gdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSwgaW5wdXQubmFtZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5QmluZGluZyBvZiBwcm9wZXJ0eUJpbmRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2UodGVtcGxhdGVJbmRleCwgcHJvcGVydHlCaW5kaW5nLnNwYW4sIElkZW50aWZpZXJzLnByb3BlcnR5LCBwcm9wZXJ0eUJpbmRpbmcucGFyYW1zT3JGbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQmluZGluZ3MgbXVzdCBvbmx5IGJlIHJlc29sdmVkIGFmdGVyIGFsbCBsb2NhbCByZWZzIGhhdmUgYmVlbiB2aXNpdGVkLCBzbyBhbGxcbiAgICAvLyBpbnN0cnVjdGlvbnMgYXJlIHF1ZXVlZCBpbiBjYWxsYmFja3MgdGhhdCBleGVjdXRlIG9uY2UgdGhlIGluaXRpYWwgcGFzcyBoYXMgY29tcGxldGVkLlxuICAgIC8vIE90aGVyd2lzZSwgd2Ugd291bGRuJ3QgYmUgYWJsZSB0byBzdXBwb3J0IGxvY2FsIHJlZnMgdGhhdCBhcmUgZGVmaW5lZCBhZnRlciB0aGVpclxuICAgIC8vIGJpbmRpbmdzLiBlLmcuIHt7IGZvbyB9fSA8ZGl2ICNmb28+PC9kaXY+XG4gICAgaW5zdHJ1Y3Rpb25GbihmbnMsIHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zT3JGbiwgcHJlcGVuZCA9IGZhbHNlKSB7XG4gICAgICAgIGZuc1twcmVwZW5kID8gJ3Vuc2hpZnQnIDogJ3B1c2gnXSh7IHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zT3JGbiB9KTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0eWxpbmdVcGRhdGVJbnN0cnVjdGlvbihlbGVtZW50SW5kZXgsIGluc3RydWN0aW9uKSB7XG4gICAgICAgIGxldCBhbGxvY2F0ZUJpbmRpbmdTbG90cyA9IDA7XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGluc3RydWN0aW9uLmNhbGxzKSB7XG4gICAgICAgICAgICAgICAgYWxsb2NhdGVCaW5kaW5nU2xvdHMgKz0gY2FsbC5hbGxvY2F0ZUJpbmRpbmdTbG90cztcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2UoZWxlbWVudEluZGV4LCBjYWxsLnNvdXJjZVNwYW4sIGluc3RydWN0aW9uLnJlZmVyZW5jZSwgKCkgPT4gY2FsbC5wYXJhbXModmFsdWUgPT4gKGNhbGwuc3VwcG9ydHNJbnRlcnBvbGF0aW9uICYmIHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFVwZGF0ZUluc3RydWN0aW9uQXJndW1lbnRzKHZhbHVlKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmVydFByb3BlcnR5QmluZGluZyh2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsb2NhdGVCaW5kaW5nU2xvdHM7XG4gICAgfVxuICAgIGNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuLCBwcmVwZW5kKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25Gbih0aGlzLl9jcmVhdGlvbkNvZGVGbnMsIHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zT3JGbiB8fCBbXSwgcHJlcGVuZCk7XG4gICAgfVxuICAgIHVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2Uobm9kZUluZGV4LCBzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4pIHtcbiAgICAgICAgdGhpcy5hZGRBZHZhbmNlSW5zdHJ1Y3Rpb25JZk5lY2Vzc2FyeShub2RlSW5kZXgsIHNwYW4pO1xuICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uKHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zT3JGbik7XG4gICAgfVxuICAgIHVwZGF0ZUluc3RydWN0aW9uKHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zT3JGbikge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9uRm4odGhpcy5fdXBkYXRlQ29kZUZucywgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuIHx8IFtdKTtcbiAgICB9XG4gICAgYWRkQWR2YW5jZUluc3RydWN0aW9uSWZOZWNlc3Nhcnkobm9kZUluZGV4LCBzcGFuKSB7XG4gICAgICAgIGlmIChub2RlSW5kZXggIT09IHRoaXMuX2N1cnJlbnRJbmRleCkge1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBub2RlSW5kZXggLSB0aGlzLl9jdXJyZW50SW5kZXg7XG4gICAgICAgICAgICBpZiAoZGVsdGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZHZhbmNlIGluc3RydWN0aW9uIGNhbiBvbmx5IGdvIGZvcndhcmRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluc3RydWN0aW9uRm4odGhpcy5fdXBkYXRlQ29kZUZucywgc3BhbiwgSWRlbnRpZmllcnMuYWR2YW5jZSwgW2xpdGVyYWwoZGVsdGEpXSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50SW5kZXggPSBub2RlSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cyhudW1TbG90cykge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFNsb3RzID0gdGhpcy5fcHVyZUZ1bmN0aW9uU2xvdHM7XG4gICAgICAgIHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzICs9IG51bVNsb3RzO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxTbG90cztcbiAgICB9XG4gICAgYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ1Nsb3RzICs9IHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbiA/IHZhbHVlLmV4cHJlc3Npb25zLmxlbmd0aCA6IDE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW4gZXhwcmVzc2lvbiB0aGF0IHJlZmVycyB0byB0aGUgaW1wbGljaXQgcmVjZWl2ZXIuIFRoZSBpbXBsaWNpdFxuICAgICAqIHJlY2VpdmVyIGlzIGFsd2F5cyB0aGUgcm9vdCBsZXZlbCBjb250ZXh0LlxuICAgICAqL1xuICAgIGdldEltcGxpY2l0UmVjZWl2ZXJFeHByKCkge1xuICAgICAgICBpZiAodGhpcy5faW1wbGljaXRSZWNlaXZlckV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyRXhwcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlckV4cHIgPSB0aGlzLmxldmVsID09PSAwID9cbiAgICAgICAgICAgIHZhcmlhYmxlKENPTlRFWFRfTkFNRSkgOlxuICAgICAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlLmdldE9yQ3JlYXRlU2hhcmVkQ29udGV4dFZhcigwKTtcbiAgICB9XG4gICAgY29udmVydFByb3BlcnR5QmluZGluZyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRQcm9wZXJ0eUJpbmRpbmcgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKHRoaXMsIHRoaXMuZ2V0SW1wbGljaXRSZWNlaXZlckV4cHIoKSwgdmFsdWUsIHRoaXMuYmluZGluZ0NvbnRleHQoKSk7XG4gICAgICAgIGNvbnN0IHZhbEV4cHIgPSBjb252ZXJ0ZWRQcm9wZXJ0eUJpbmRpbmcuY3VyclZhbEV4cHI7XG4gICAgICAgIHRoaXMuX3RlbXBWYXJpYWJsZXMucHVzaCguLi5jb252ZXJ0ZWRQcm9wZXJ0eUJpbmRpbmcuc3RtdHMpO1xuICAgICAgICByZXR1cm4gdmFsRXhwcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYXJndW1lbnQgZXhwcmVzc2lvbnMgdG8gcGFzcyB0byBhbiB1cGRhdGUgaW5zdHJ1Y3Rpb24gZXhwcmVzc2lvbi4gQWxzbyB1cGRhdGVzXG4gICAgICogdGhlIHRlbXAgdmFyaWFibGVzIHN0YXRlIHdpdGggdGVtcCB2YXJpYWJsZXMgdGhhdCB3ZXJlIGlkZW50aWZpZWQgYXMgbmVlZGluZyB0byBiZSBjcmVhdGVkXG4gICAgICogd2hpbGUgdmlzaXRpbmcgdGhlIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG9yaWdpbmFsIGV4cHJlc3Npb24gd2Ugd2lsbCBiZSByZXNvbHZpbmcgYW4gYXJndW1lbnRzIGxpc3QgZnJvbS5cbiAgICAgKi9cbiAgICBnZXRVcGRhdGVJbnN0cnVjdGlvbkFyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgICBjb25zdCB7IGFyZ3MsIHN0bXRzIH0gPSBjb252ZXJ0VXBkYXRlQXJndW1lbnRzKHRoaXMsIHRoaXMuZ2V0SW1wbGljaXRSZWNlaXZlckV4cHIoKSwgdmFsdWUsIHRoaXMuYmluZGluZ0NvbnRleHQoKSk7XG4gICAgICAgIHRoaXMuX3RlbXBWYXJpYWJsZXMucHVzaCguLi5zdG10cyk7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBhbGwgYXR0cmlidXRlIGV4cHJlc3Npb24gdmFsdWVzIGZvciB0aGUgYFRBdHRyaWJ1dGVzYCBhcnJheS5cbiAgICAgKlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gcHJvcGVybHkgY29uc3RydWN0IGFuIGF0dHJpYnV0ZXMgYXJyYXkgdGhhdFxuICAgICAqIGlzIHBhc3NlZCBpbnRvIHRoZSBgZWxlbWVudFN0YXJ0YCAob3IganVzdCBgZWxlbWVudGApIGZ1bmN0aW9ucy4gQmVjYXVzZSB0aGVyZVxuICAgICAqIGFyZSBtYW55IGRpZmZlcmVudCB0eXBlcyBvZiBhdHRyaWJ1dGVzLCB0aGUgYXJyYXkgbmVlZHMgdG8gYmUgY29uc3RydWN0ZWQgaW4gYVxuICAgICAqIHNwZWNpYWwgd2F5IHNvIHRoYXQgYGVsZW1lbnRTdGFydGAgY2FuIHByb3Blcmx5IGV2YWx1YXRlIHRoZW0uXG4gICAgICpcbiAgICAgKiBUaGUgZm9ybWF0IGxvb2tzIGxpa2UgdGhpczpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGF0dHJzID0gW3Byb3AsIHZhbHVlLCBwcm9wMiwgdmFsdWUyLFxuICAgICAqICAgUFJPSkVDVF9BUywgc2VsZWN0b3IsXG4gICAgICogICBDTEFTU0VTLCBjbGFzczEsIGNsYXNzMixcbiAgICAgKiAgIFNUWUxFUywgc3R5bGUxLCB2YWx1ZTEsIHN0eWxlMiwgdmFsdWUyLFxuICAgICAqICAgQklORElOR1MsIG5hbWUxLCBuYW1lMiwgbmFtZTMsXG4gICAgICogICBURU1QTEFURSwgbmFtZTQsIG5hbWU1LCBuYW1lNixcbiAgICAgKiAgIEkxOE4sIG5hbWU3LCBuYW1lOCwgLi4uXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gd2lsbCBmdWxseSBpZ25vcmUgYWxsIHN5bnRoZXRpYyAoQGZvbykgYXR0cmlidXRlIHZhbHVlc1xuICAgICAqIGJlY2F1c2UgdGhvc2UgdmFsdWVzIGFyZSBpbnRlbmRlZCB0byBhbHdheXMgYmUgZ2VuZXJhdGVkIGFzIHByb3BlcnR5IGluc3RydWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVFeHByZXNzaW9ucyhlbGVtZW50TmFtZSwgcmVuZGVyQXR0cmlidXRlcywgaW5wdXRzLCBvdXRwdXRzLCBzdHlsZXMsIHRlbXBsYXRlQXR0cnMgPSBbXSwgYm91bmRJMThuQXR0cnMgPSBbXSkge1xuICAgICAgICBjb25zdCBhbHJlYWR5U2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgYXR0ckV4cHJzID0gW107XG4gICAgICAgIGxldCBuZ1Byb2plY3RBc0F0dHI7XG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiByZW5kZXJBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBOR19QUk9KRUNUX0FTX0FUVFJfTkFNRSkge1xuICAgICAgICAgICAgICAgIG5nUHJvamVjdEFzQXR0ciA9IGF0dHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgc3RhdGljIGkxOG4gYXR0cmlidXRlcyBhcmVuJ3QgaW4gdGhlIGkxOG4gYXJyYXksXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkncmUgdHJlYXRlZCBpbiB0aGUgc2FtZSB3YXkgYXMgcmVndWxhciBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgaWYgKGF0dHIuaTE4bikge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gaTE4biBhdHRyaWJ1dGVzIGFyZSBwcmVzZW50IG9uIGVsZW1lbnRzIHdpdGggc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgICAgICAgICAgLy8gKGUuZy4gYDxkaXYgKm5nSWYgdGl0bGU9XCJIZWxsb1wiIGkxOG4tdGl0bGU+YCksIHdlIHdhbnQgdG8gYXZvaWQgZ2VuZXJhdGluZ1xuICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0ZSBpMThuIHRyYW5zbGF0aW9uIGJsb2NrcyBmb3IgYMm1ybV0ZW1wbGF0ZWAgYW5kIGDJtcm1ZWxlbWVudGAgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzLiBTbyB3ZSBkbyBhIGNhY2hlIGxvb2t1cCB0byBzZWUgaWYgc3VpdGFibGUgaTE4biB0cmFuc2xhdGlvbiBibG9ja1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgZXhpc3RzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaTE4blZhclJlZnNDYWNoZSB9ID0gdGhpcy5fY29uc3RhbnRzO1xuICAgICAgICAgICAgICAgIGxldCBpMThuVmFyUmVmO1xuICAgICAgICAgICAgICAgIGlmIChpMThuVmFyUmVmc0NhY2hlLmhhcyhhdHRyLmkxOG4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGkxOG5WYXJSZWYgPSBpMThuVmFyUmVmc0NhY2hlLmdldChhdHRyLmkxOG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaTE4blZhclJlZiA9IHRoaXMuaTE4blRyYW5zbGF0ZShhdHRyLmkxOG4pO1xuICAgICAgICAgICAgICAgICAgICBpMThuVmFyUmVmc0NhY2hlLnNldChhdHRyLmkxOG4sIGkxOG5WYXJSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdHRyRXhwcnMucHVzaChsaXRlcmFsKGF0dHIubmFtZSksIGkxOG5WYXJSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0ckV4cHJzLnB1c2goLi4uZ2V0QXR0cmlidXRlTmFtZUxpdGVyYWxzKGF0dHIubmFtZSksIHRydXN0ZWRDb25zdEF0dHJpYnV0ZShlbGVtZW50TmFtZSwgYXR0cikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEtlZXAgbmdQcm9qZWN0QXMgbmV4dCB0byB0aGUgb3RoZXIgbmFtZSwgdmFsdWUgcGFpcnMgc28gd2UgY2FuIHZlcmlmeSB0aGF0IHdlIG1hdGNoXG4gICAgICAgIC8vIG5nUHJvamVjdEFzIG1hcmtlciBpbiB0aGUgYXR0cmlidXRlIG5hbWUgc2xvdC5cbiAgICAgICAgaWYgKG5nUHJvamVjdEFzQXR0cikge1xuICAgICAgICAgICAgYXR0ckV4cHJzLnB1c2goLi4uZ2V0TmdQcm9qZWN0QXNMaXRlcmFsKG5nUHJvamVjdEFzQXR0cikpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFkZEF0dHJFeHByKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghYWxyZWFkeVNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ckV4cHJzLnB1c2goLi4uZ2V0QXR0cmlidXRlTmFtZUxpdGVyYWxzKGtleSkpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGF0dHJFeHBycy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVNlZW4uYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0ckV4cHJzLnB1c2gobGl0ZXJhbChrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgb2NjdXJzIGJlZm9yZSBCSU5ESU5HUyBhbmQgVEVNUExBVEUgYmVjYXVzZSBvbmNlIGBlbGVtZW50U3RhcnRgXG4gICAgICAgIC8vIGNvbWVzIGFjcm9zcyB0aGUgQklORElOR1Mgb3IgVEVNUExBVEUgbWFya2VycyB0aGVuIGl0IHdpbGwgY29udGludWUgcmVhZGluZyBlYWNoIHZhbHVlIGFzXG4gICAgICAgIC8vIGFzIHNpbmdsZSBwcm9wZXJ0eSB2YWx1ZSBjZWxsIGJ5IGNlbGwuXG4gICAgICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgICAgIHN0eWxlcy5wb3B1bGF0ZUluaXRpYWxTdHlsaW5nQXR0cnMoYXR0ckV4cHJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXRzLmxlbmd0aCB8fCBvdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYXR0cnNMZW5ndGhCZWZvcmVJbnB1dHMgPSBhdHRyRXhwcnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRoZSBhbmltYXRpb24gYW5kIGF0dHJpYnV0ZSBiaW5kaW5ncyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGFycmF5IHNpbmNlIHRoZXkgYXJlbid0IHVzZWQgZm9yIGRpcmVjdGl2ZSBtYXRjaGluZy5cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQudHlwZSAhPT0gNCAvKiBCaW5kaW5nVHlwZS5BbmltYXRpb24gKi8gJiYgaW5wdXQudHlwZSAhPT0gMSAvKiBCaW5kaW5nVHlwZS5BdHRyaWJ1dGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQXR0ckV4cHIoaW5wdXQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LnR5cGUgIT09IDEgLyogUGFyc2VkRXZlbnRUeXBlLkFuaW1hdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBhZGRBdHRyRXhwcihvdXRwdXQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGNoZWFwIHdheSBvZiBhZGRpbmcgdGhlIG1hcmtlciBvbmx5IGFmdGVyIGFsbCB0aGUgaW5wdXQvb3V0cHV0XG4gICAgICAgICAgICAvLyB2YWx1ZXMgaGF2ZSBiZWVuIGZpbHRlcmVkIChieSBub3QgaW5jbHVkaW5nIHRoZSBhbmltYXRpb24gb25lcykgYW5kIGFkZGVkXG4gICAgICAgICAgICAvLyB0byB0aGUgZXhwcmVzc2lvbnMuIFRoZSBtYXJrZXIgaXMgaW1wb3J0YW50IGJlY2F1c2UgaXQgdGVsbHMgdGhlIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIGNvZGUgdGhhdCB0aGlzIGlzIHdoZXJlIGF0dHJpYnV0ZXMgd2l0aG91dCB2YWx1ZXMgc3RhcnQuLi5cbiAgICAgICAgICAgIGlmIChhdHRyRXhwcnMubGVuZ3RoICE9PSBhdHRyc0xlbmd0aEJlZm9yZUlucHV0cykge1xuICAgICAgICAgICAgICAgIGF0dHJFeHBycy5zcGxpY2UoYXR0cnNMZW5ndGhCZWZvcmVJbnB1dHMsIDAsIGxpdGVyYWwoMyAvKiBjb3JlLkF0dHJpYnV0ZU1hcmtlci5CaW5kaW5ncyAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZUF0dHJzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXR0ckV4cHJzLnB1c2gobGl0ZXJhbCg0IC8qIGNvcmUuQXR0cmlidXRlTWFya2VyLlRlbXBsYXRlICovKSk7XG4gICAgICAgICAgICB0ZW1wbGF0ZUF0dHJzLmZvckVhY2goYXR0ciA9PiBhZGRBdHRyRXhwcihhdHRyLm5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm91bmRJMThuQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRyRXhwcnMucHVzaChsaXRlcmFsKDYgLyogY29yZS5BdHRyaWJ1dGVNYXJrZXIuSTE4biAqLykpO1xuICAgICAgICAgICAgYm91bmRJMThuQXR0cnMuZm9yRWFjaChhdHRyID0+IGFkZEF0dHJFeHByKGF0dHIubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyRXhwcnM7XG4gICAgfVxuICAgIGFkZFRvQ29uc3RzKGV4cHJlc3Npb24pIHtcbiAgICAgICAgaWYgKGlzTnVsbChleHByZXNzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRZUEVEX05VTExfRVhQUjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25zdHMgPSB0aGlzLl9jb25zdGFudHMuY29uc3RFeHByZXNzaW9ucztcbiAgICAgICAgLy8gVHJ5IHRvIHJldXNlIGEgbGl0ZXJhbCB0aGF0J3MgYWxyZWFkeSBpbiB0aGUgYXJyYXksIGlmIHBvc3NpYmxlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbnN0c1tpXS5pc0VxdWl2YWxlbnQoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGl0ZXJhbChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGl0ZXJhbChjb25zdHMucHVzaChleHByZXNzaW9uKSAtIDEpO1xuICAgIH1cbiAgICBhZGRBdHRyc1RvQ29uc3RzKGF0dHJzKSB7XG4gICAgICAgIHJldHVybiBhdHRycy5sZW5ndGggPiAwID8gdGhpcy5hZGRUb0NvbnN0cyhsaXRlcmFsQXJyKGF0dHJzKSkgOiBUWVBFRF9OVUxMX0VYUFI7XG4gICAgfVxuICAgIHByZXBhcmVSZWZzQXJyYXkocmVmZXJlbmNlcykge1xuICAgICAgICBpZiAoIXJlZmVyZW5jZXMgfHwgcmVmZXJlbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBUWVBFRF9OVUxMX0VYUFI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmc1BhcmFtID0gZmxhdHRlbihyZWZlcmVuY2VzLm1hcChyZWZlcmVuY2UgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgdGhlIHVwZGF0ZSB0ZW1wb3JhcnkuXG4gICAgICAgICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSB0aGlzLl9iaW5kaW5nU2NvcGUuZnJlc2hSZWZlcmVuY2VOYW1lKCk7XG4gICAgICAgICAgICBjb25zdCByZXRyaWV2YWxMZXZlbCA9IHRoaXMubGV2ZWw7XG4gICAgICAgICAgICBjb25zdCBsaHMgPSB2YXJpYWJsZSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlLnNldChyZXRyaWV2YWxMZXZlbCwgcmVmZXJlbmNlLm5hbWUsIGxocywgMCAvKiBEZWNsYXJhdGlvblByaW9yaXR5LkRFRkFVTFQgKi8sIChzY29wZSwgcmVsYXRpdmVMZXZlbCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGUuZy4gbmV4dENvbnRleHQoMik7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENvbnRleHRTdG10ID0gcmVsYXRpdmVMZXZlbCA+IDAgPyBbZ2VuZXJhdGVOZXh0Q29udGV4dEV4cHIocmVsYXRpdmVMZXZlbCkudG9TdG10KCldIDogW107XG4gICAgICAgICAgICAgICAgLy8gZS5nLiBjb25zdCAkZm9vJCA9IHJlZmVyZW5jZSgxKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZFeHByID0gbGhzLnNldChpbXBvcnRFeHByKElkZW50aWZpZXJzLnJlZmVyZW5jZSkuY2FsbEZuKFtsaXRlcmFsKHNsb3QpXSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0Q29udGV4dFN0bXQuY29uY2F0KHJlZkV4cHIudG9Db25zdERlY2woKSk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBbcmVmZXJlbmNlLm5hbWUsIHJlZmVyZW5jZS52YWx1ZV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGFzTGl0ZXJhbChyZWZzUGFyYW0pO1xuICAgIH1cbiAgICBwcmVwYXJlTGlzdGVuZXJQYXJhbWV0ZXIodGFnTmFtZSwgb3V0cHV0QXN0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gb3V0cHV0QXN0Lm5hbWU7XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nRm5OYW1lID0gb3V0cHV0QXN0LnR5cGUgPT09IDEgLyogUGFyc2VkRXZlbnRUeXBlLkFuaW1hdGlvbiAqLyA/XG4gICAgICAgICAgICAgICAgLy8gc3ludGhldGljIEBsaXN0ZW5lci5mb28gdmFsdWVzIGFyZSB0cmVhdGVkIHRoZSBleGFjdCBzYW1lIGFzIGFyZSBzdGFuZGFyZCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJGdW5jdGlvbk5hbWUoZXZlbnROYW1lLCBvdXRwdXRBc3QucGhhc2UpIDpcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZUlkZW50aWZpZXIoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJOYW1lID0gYCR7dGhpcy50ZW1wbGF0ZU5hbWV9XyR7dGFnTmFtZX1fJHtiaW5kaW5nRm5OYW1lfV8ke2luZGV4fV9saXN0ZW5lcmA7XG4gICAgICAgICAgICBjb25zdCBzY29wZSA9IHRoaXMuX2JpbmRpbmdTY29wZS5uZXN0ZWRTY29wZSh0aGlzLl9iaW5kaW5nU2NvcGUuYmluZGluZ0xldmVsLCBFVkVOVF9CSU5ESU5HX1NDT1BFX0dMT0JBTFMpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVFdmVudExpc3RlbmVyUGFyYW1ldGVycyhvdXRwdXRBc3QsIGhhbmRsZXJOYW1lLCBzY29wZSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgVmFsdWVDb252ZXJ0ZXIgZXh0ZW5kcyBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lciB7XG4gICAgY29uc3RydWN0b3IoY29uc3RhbnRQb29sLCBhbGxvY2F0ZVNsb3QsIGFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMsIGRlZmluZVBpcGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25zdGFudFBvb2wgPSBjb25zdGFudFBvb2w7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVTbG90ID0gYWxsb2NhdGVTbG90O1xuICAgICAgICB0aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMgPSBhbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzO1xuICAgICAgICB0aGlzLmRlZmluZVBpcGUgPSBkZWZpbmVQaXBlO1xuICAgICAgICB0aGlzLl9waXBlQmluZEV4cHJzID0gW107XG4gICAgfVxuICAgIC8vIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyXG4gICAgdmlzaXRQaXBlKHBpcGUsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gQWxsb2NhdGUgYSBzbG90IHRvIGNyZWF0ZSB0aGUgcGlwZVxuICAgICAgICBjb25zdCBzbG90ID0gdGhpcy5hbGxvY2F0ZVNsb3QoKTtcbiAgICAgICAgY29uc3Qgc2xvdFBzZXVkb0xvY2FsID0gYFBJUEU6JHtzbG90fWA7XG4gICAgICAgIC8vIEFsbG9jYXRlIG9uZSBzbG90IGZvciB0aGUgcmVzdWx0IHBsdXMgb25lIHNsb3QgcGVyIHBpcGUgYXJndW1lbnRcbiAgICAgICAgY29uc3QgcHVyZUZ1bmN0aW9uU2xvdCA9IHRoaXMuYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cygyICsgcGlwZS5hcmdzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG5ldyBQcm9wZXJ0eVJlYWQocGlwZS5zcGFuLCBwaXBlLnNvdXJjZVNwYW4sIHBpcGUubmFtZVNwYW4sIG5ldyBJbXBsaWNpdFJlY2VpdmVyKHBpcGUuc3BhbiwgcGlwZS5zb3VyY2VTcGFuKSwgc2xvdFBzZXVkb0xvY2FsKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGlmaWVyLCBpc1Zhckxlbmd0aCB9ID0gcGlwZUJpbmRpbmdDYWxsSW5mbyhwaXBlLmFyZ3MpO1xuICAgICAgICB0aGlzLmRlZmluZVBpcGUocGlwZS5uYW1lLCBzbG90UHNldWRvTG9jYWwsIHNsb3QsIGltcG9ydEV4cHIoaWRlbnRpZmllcikpO1xuICAgICAgICBjb25zdCBhcmdzID0gW3BpcGUuZXhwLCAuLi5waXBlLmFyZ3NdO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRBcmdzID0gaXNWYXJMZW5ndGggP1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbChbbmV3IExpdGVyYWxBcnJheShwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiwgYXJncyldKSA6XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsKGFyZ3MpO1xuICAgICAgICBjb25zdCBwaXBlQmluZEV4cHIgPSBuZXcgQ2FsbChwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiwgdGFyZ2V0LCBbXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbFByaW1pdGl2ZShwaXBlLnNwYW4sIHBpcGUuc291cmNlU3Bhbiwgc2xvdCksXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbFByaW1pdGl2ZShwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiwgcHVyZUZ1bmN0aW9uU2xvdCksXG4gICAgICAgICAgICAuLi5jb252ZXJ0ZWRBcmdzLFxuICAgICAgICBdLCBudWxsKTtcbiAgICAgICAgdGhpcy5fcGlwZUJpbmRFeHBycy5wdXNoKHBpcGVCaW5kRXhwcik7XG4gICAgICAgIHJldHVybiBwaXBlQmluZEV4cHI7XG4gICAgfVxuICAgIHVwZGF0ZVBpcGVTbG90T2Zmc2V0cyhiaW5kaW5nU2xvdHMpIHtcbiAgICAgICAgdGhpcy5fcGlwZUJpbmRFeHBycy5mb3JFYWNoKChwaXBlKSA9PiB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNsb3Qgb2Zmc2V0IGFyZyAoaW5kZXggMSkgdG8gYWNjb3VudCBmb3IgYmluZGluZyBzbG90c1xuICAgICAgICAgICAgY29uc3Qgc2xvdE9mZnNldCA9IHBpcGUuYXJnc1sxXTtcbiAgICAgICAgICAgIHNsb3RPZmZzZXQudmFsdWUgKz0gYmluZGluZ1Nsb3RzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsQXJyYXkoYXJyYXksIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFycmF5LnNwYW4sIGFycmF5LnNvdXJjZVNwYW4sIHRoaXMudmlzaXRBbGwoYXJyYXkuZXhwcmVzc2lvbnMpLCB2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGxpdGVyYWwgaGFzIGNhbGN1bGF0ZWQgKG5vbi1saXRlcmFsKSBlbGVtZW50cyB0cmFuc2Zvcm0gaXQgaW50b1xuICAgICAgICAgICAgLy8gY2FsbHMgdG8gbGl0ZXJhbCBmYWN0b3JpZXMgdGhhdCBjb21wb3NlIHRoZSBsaXRlcmFsIGFuZCB3aWxsIGNhY2hlIGludGVybWVkaWF0ZVxuICAgICAgICAgICAgLy8gdmFsdWVzLlxuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbCA9IGxpdGVyYWxBcnIodmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRMaXRlcmFsRmFjdG9yeSh0aGlzLmNvbnN0YW50UG9vbCwgbGl0ZXJhbCwgdGhpcy5hbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKG1hcC5zcGFuLCBtYXAuc291cmNlU3BhbiwgdGhpcy52aXNpdEFsbChtYXAudmFsdWVzKSwgdmFsdWVzID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBsaXRlcmFsIGhhcyBjYWxjdWxhdGVkIChub24tbGl0ZXJhbCkgZWxlbWVudHMgIHRyYW5zZm9ybSBpdCBpbnRvXG4gICAgICAgICAgICAvLyBjYWxscyB0byBsaXRlcmFsIGZhY3RvcmllcyB0aGF0IGNvbXBvc2UgdGhlIGxpdGVyYWwgYW5kIHdpbGwgY2FjaGUgaW50ZXJtZWRpYXRlXG4gICAgICAgICAgICAvLyB2YWx1ZXMuXG4gICAgICAgICAgICBjb25zdCBsaXRlcmFsID0gbGl0ZXJhbE1hcCh2YWx1ZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7IGtleTogbWFwLmtleXNbaW5kZXhdLmtleSwgdmFsdWUsIHF1b3RlZDogbWFwLmtleXNbaW5kZXhdLnF1b3RlZCB9KSkpO1xuICAgICAgICAgICAgcmV0dXJuIGdldExpdGVyYWxGYWN0b3J5KHRoaXMuY29uc3RhbnRQb29sLCBsaXRlcmFsLCB0aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyBQaXBlcyBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgcGFyYW1ldGVyLCB0aGUgdmFsdWUgdGhleSBvcGVyYXRlIG9uXG5jb25zdCBwaXBlQmluZGluZ0lkZW50aWZpZXJzID0gW0lkZW50aWZpZXJzLnBpcGVCaW5kMSwgSWRlbnRpZmllcnMucGlwZUJpbmQyLCBJZGVudGlmaWVycy5waXBlQmluZDMsIElkZW50aWZpZXJzLnBpcGVCaW5kNF07XG5mdW5jdGlvbiBwaXBlQmluZGluZ0NhbGxJbmZvKGFyZ3MpIHtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gcGlwZUJpbmRpbmdJZGVudGlmaWVyc1thcmdzLmxlbmd0aF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllciB8fCBJZGVudGlmaWVycy5waXBlQmluZFYsXG4gICAgICAgIGlzVmFyTGVuZ3RoOiAhaWRlbnRpZmllcixcbiAgICB9O1xufVxuY29uc3QgcHVyZUZ1bmN0aW9uSWRlbnRpZmllcnMgPSBbXG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMCwgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMSwgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMiwgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMywgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uNCxcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb241LCBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb242LCBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb243LCBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb244XG5dO1xuZnVuY3Rpb24gcHVyZUZ1bmN0aW9uQ2FsbEluZm8oYXJncykge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBwdXJlRnVuY3Rpb25JZGVudGlmaWVyc1thcmdzLmxlbmd0aF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllciB8fCBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb25WLFxuICAgICAgICBpc1Zhckxlbmd0aDogIWlkZW50aWZpZXIsXG4gICAgfTtcbn1cbi8vIGUuZy4geCgyKTtcbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dENvbnRleHRFeHByKHJlbGF0aXZlTGV2ZWxEaWZmKSB7XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMubmV4dENvbnRleHQpXG4gICAgICAgIC5jYWxsRm4ocmVsYXRpdmVMZXZlbERpZmYgPiAxID8gW2xpdGVyYWwocmVsYXRpdmVMZXZlbERpZmYpXSA6IFtdKTtcbn1cbmZ1bmN0aW9uIGdldExpdGVyYWxGYWN0b3J5KGNvbnN0YW50UG9vbCwgbGl0ZXJhbCQxLCBhbGxvY2F0ZVNsb3RzKSB7XG4gICAgY29uc3QgeyBsaXRlcmFsRmFjdG9yeSwgbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMgfSA9IGNvbnN0YW50UG9vbC5nZXRMaXRlcmFsRmFjdG9yeShsaXRlcmFsJDEpO1xuICAgIC8vIEFsbG9jYXRlIDEgc2xvdCBmb3IgdGhlIHJlc3VsdCBwbHVzIDEgcGVyIGFyZ3VtZW50XG4gICAgY29uc3Qgc3RhcnRTbG90ID0gYWxsb2NhdGVTbG90cygxICsgbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMubGVuZ3RoKTtcbiAgICBjb25zdCB7IGlkZW50aWZpZXIsIGlzVmFyTGVuZ3RoIH0gPSBwdXJlRnVuY3Rpb25DYWxsSW5mbyhsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cyk7XG4gICAgLy8gTGl0ZXJhbCBmYWN0b3JpZXMgYXJlIHB1cmUgZnVuY3Rpb25zIHRoYXQgb25seSBuZWVkIHRvIGJlIHJlLWludm9rZWQgd2hlbiB0aGUgcGFyYW1ldGVyc1xuICAgIC8vIGNoYW5nZS5cbiAgICBjb25zdCBhcmdzID0gW2xpdGVyYWwoc3RhcnRTbG90KSwgbGl0ZXJhbEZhY3RvcnldO1xuICAgIGlmIChpc1Zhckxlbmd0aCkge1xuICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbEFycihsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXJncy5wdXNoKC4uLmxpdGVyYWxGYWN0b3J5QXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoaWRlbnRpZmllcikuY2FsbEZuKGFyZ3MpO1xufVxuLyoqXG4gKiBHZXRzIGFuIGFycmF5IG9mIGxpdGVyYWxzIHRoYXQgY2FuIGJlIGFkZGVkIHRvIGFuIGV4cHJlc3Npb25cbiAqIHRvIHJlcHJlc2VudCB0aGUgbmFtZSBhbmQgbmFtZXNwYWNlIG9mIGFuIGF0dHJpYnV0ZS4gRS5nLlxuICogYDp4bGluazpocmVmYCB0dXJucyBpbnRvIGBbQXR0cmlidXRlTWFya2VyLk5hbWVzcGFjZVVSSSwgJ3hsaW5rJywgJ2hyZWYnXWAuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlLCBpbmNsdWRpbmcgdGhlIG5hbWVzcGFjZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlTmFtZUxpdGVyYWxzKG5hbWUpIHtcbiAgICBjb25zdCBbYXR0cmlidXRlTmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lXSA9IHNwbGl0TnNOYW1lKG5hbWUpO1xuICAgIGNvbnN0IG5hbWVMaXRlcmFsID0gbGl0ZXJhbChhdHRyaWJ1dGVOYW1lKTtcbiAgICBpZiAoYXR0cmlidXRlTmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsaXRlcmFsKDAgLyogY29yZS5BdHRyaWJ1dGVNYXJrZXIuTmFtZXNwYWNlVVJJICovKSwgbGl0ZXJhbChhdHRyaWJ1dGVOYW1lc3BhY2UpLCBuYW1lTGl0ZXJhbFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW25hbWVMaXRlcmFsXTtcbn1cbi8qKiBUaGUgcHJlZml4IHVzZWQgdG8gZ2V0IGEgc2hhcmVkIGNvbnRleHQgaW4gQmluZGluZ1Njb3BlJ3MgbWFwLiAqL1xuY29uc3QgU0hBUkVEX0NPTlRFWFRfS0VZID0gJyQkc2hhcmVkX2N0eCQkJztcbmNsYXNzIEJpbmRpbmdTY29wZSB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZ0xldmVsID0gMCwgcGFyZW50ID0gbnVsbCwgZ2xvYmFscykge1xuICAgICAgICB0aGlzLmJpbmRpbmdMZXZlbCA9IGJpbmRpbmdMZXZlbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgICAgIC8qKiBLZWVwcyBhIG1hcCBmcm9tIGxvY2FsIHZhcmlhYmxlcyB0byB0aGVpciBCaW5kaW5nRGF0YS4gKi9cbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlTmFtZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlID0gbnVsbDtcbiAgICAgICAgdGhpcy51c2VzUmVzdG9yZWRWaWV3Q29udGV4dCA9IGZhbHNlO1xuICAgICAgICBpZiAoZ2xvYmFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZ2xvYmFscykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KDAsIG5hbWUsIHZhcmlhYmxlKG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlUm9vdFNjb3BlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdTY29wZSgpO1xuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjdXJyZW50Lm1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBsb2NhbCBjb3B5IGFuZCByZXNldCB0aGUgYGRlY2xhcmVgIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmFsTGV2ZWw6IHZhbHVlLnJldHJpZXZhbExldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGhzOiB2YWx1ZS5saHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJlTG9jYWxDYWxsYmFjazogdmFsdWUuZGVjbGFyZUxvY2FsQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB2YWx1ZS5wcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgdmFsdWUgbG9jYWxseS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libHkgZ2VuZXJhdGUgYSBzaGFyZWQgY29udGV4dCB2YXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZUdlbmVyYXRlU2hhcmVkQ29udGV4dFZhcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZXN0b3JlVmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZGVjbGFyZUxvY2FsQ2FsbGJhY2sgJiYgIXZhbHVlLmRlY2xhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5saHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IHRvIHRoaXMgcG9pbnQsIHdlIGFyZSBsb29raW5nIGZvciBhIHByb3BlcnR5IG9uIHRoZSB0b3AgbGV2ZWwgY29tcG9uZW50XG4gICAgICAgIC8vIC0gSWYgbGV2ZWwgPT09IDAsIHdlIGFyZSBvbiB0aGUgdG9wIGFuZCBkb24ndCBuZWVkIHRvIHJlLWRlY2xhcmUgYGN0eGAuXG4gICAgICAgIC8vIC0gSWYgbGV2ZWwgPiAwLCB3ZSBhcmUgaW4gYW4gZW1iZWRkZWQgdmlldy4gV2UgbmVlZCB0byByZXRyaWV2ZSB0aGUgbmFtZSBvZiB0aGVcbiAgICAgICAgLy8gbG9jYWwgdmFyIHdlIHVzZWQgdG8gc3RvcmUgdGhlIGNvbXBvbmVudCBjb250ZXh0LCBlLmcuIGNvbnN0ICRjb21wJCA9IHgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ0xldmVsID09PSAwID8gbnVsbCA6IHRoaXMuZ2V0Q29tcG9uZW50UHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGxvY2FsIHZhcmlhYmxlIGZvciBsYXRlciByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV0cmlldmFsTGV2ZWwgVGhlIGxldmVsIGZyb20gd2hpY2ggdGhpcyB2YWx1ZSBjYW4gYmUgcmV0cmlldmVkXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAgICogQHBhcmFtIGxocyBBU1QgcmVwcmVzZW50aW5nIHRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgYGxldCBsaHMgPSByaHM7YC5cbiAgICAgKiBAcGFyYW0gcHJpb3JpdHkgVGhlIHNvcnRpbmcgcHJpb3JpdHkgb2YgdGhpcyB2YXJcbiAgICAgKiBAcGFyYW0gZGVjbGFyZUxvY2FsQ2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGRlY2xhcmluZyB0aGlzIGxvY2FsIHZhclxuICAgICAqIEBwYXJhbSBsb2NhbFJlZiBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIGEgbG9jYWwgcmVmXG4gICAgICovXG4gICAgc2V0KHJldHJpZXZhbExldmVsLCBuYW1lLCBsaHMsIHByaW9yaXR5ID0gMCAvKiBEZWNsYXJhdGlvblByaW9yaXR5LkRFRkFVTFQgKi8sIGRlY2xhcmVMb2NhbENhbGxiYWNrLCBsb2NhbFJlZikge1xuICAgICAgICBpZiAodGhpcy5tYXAuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxSZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBhIGxvY2FsIHJlZiBhbmQgZG8gbm90IHVwZGF0ZSBleGlzdGluZyB2YWx1ZSxcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGUgZmlyc3QgZGVmaW5lZCByZWYgaXMgYWx3YXlzIHJldHVybmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoYFRoZSBuYW1lICR7bmFtZX0gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHNjb3BlIHRvIGJlICR7dGhpcy5tYXAuZ2V0KG5hbWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwLnNldChuYW1lLCB7XG4gICAgICAgICAgICByZXRyaWV2YWxMZXZlbDogcmV0cmlldmFsTGV2ZWwsXG4gICAgICAgICAgICBsaHM6IGxocyxcbiAgICAgICAgICAgIGRlY2xhcmU6IGZhbHNlLFxuICAgICAgICAgICAgZGVjbGFyZUxvY2FsQ2FsbGJhY2s6IGRlY2xhcmVMb2NhbENhbGxiYWNrLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgTG9jYWxSZXNvbHZlci5cbiAgICBnZXRMb2NhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcbiAgICB9XG4gICAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBMb2NhbFJlc29sdmVyLlxuICAgIG5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdMZXZlbCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIGltcGxpY2l0IHJlY2VpdmVyIGlzIGFjY2Vzc2VkIGluIGFuIGVtYmVkZGVkIHZpZXcsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHdlIGRlY2xhcmUgYSBzaGFyZWQgY29udGV4dCB2YXJpYWJsZSBmb3IgdGhlIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIGluIHRoZSB1cGRhdGUgdmFyaWFibGVzLlxuICAgICAgICAgICAgdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIDApLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5lc3RlZFNjb3BlKGxldmVsLCBnbG9iYWxzKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gbmV3IEJpbmRpbmdTY29wZShsZXZlbCwgdGhpcywgZ2xvYmFscyk7XG4gICAgICAgIGlmIChsZXZlbCA+IDApXG4gICAgICAgICAgICBuZXdTY29wZS5nZW5lcmF0ZVNoYXJlZENvbnRleHRWYXIoMCk7XG4gICAgICAgIHJldHVybiBuZXdTY29wZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBjcmVhdGVzIGEgc2hhcmVkIGNvbnRleHQgdmFyaWFibGUgYW5kIHJldHVybnMgaXRzIGV4cHJlc3Npb24uIE5vdGUgdGhhdFxuICAgICAqIHRoaXMgZG9lcyBub3QgbWVhbiB0aGF0IHRoZSBzaGFyZWQgdmFyaWFibGUgd2lsbCBiZSBkZWNsYXJlZC4gVmFyaWFibGVzIGluIHRoZVxuICAgICAqIGJpbmRpbmcgc2NvcGUgd2lsbCBiZSBvbmx5IGRlY2xhcmVkIGlmIHRoZXkgYXJlIHVzZWQuXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVTaGFyZWRDb250ZXh0VmFyKHJldHJpZXZhbExldmVsKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdLZXkgPSBTSEFSRURfQ09OVEVYVF9LRVkgKyByZXRyaWV2YWxMZXZlbDtcbiAgICAgICAgaWYgKCF0aGlzLm1hcC5oYXMoYmluZGluZ0tleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyKHJldHJpZXZhbExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFyZWQgY29udGV4dCB2YXJpYWJsZXMgYXJlIGFsd2F5cyBnZW5lcmF0ZWQgYXMgXCJSZWFkVmFyRXhwclwiLlxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGJpbmRpbmdLZXkpLmxocztcbiAgICB9XG4gICAgZ2V0U2hhcmVkQ29udGV4dE5hbWUocmV0cmlldmFsTGV2ZWwpIHtcbiAgICAgICAgY29uc3Qgc2hhcmVkQ3R4T2JqID0gdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIHJldHJpZXZhbExldmVsKTtcbiAgICAgICAgLy8gU2hhcmVkIGNvbnRleHQgdmFyaWFibGVzIGFyZSBhbHdheXMgZ2VuZXJhdGVkIGFzIFwiUmVhZFZhckV4cHJcIi5cbiAgICAgICAgcmV0dXJuIHNoYXJlZEN0eE9iaiAmJiBzaGFyZWRDdHhPYmouZGVjbGFyZSA/IHNoYXJlZEN0eE9iai5saHMgOiBudWxsO1xuICAgIH1cbiAgICBtYXliZUdlbmVyYXRlU2hhcmVkQ29udGV4dFZhcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUucHJpb3JpdHkgPT09IDEgLyogRGVjbGFyYXRpb25Qcmlvcml0eS5DT05URVhUICovICYmXG4gICAgICAgICAgICB2YWx1ZS5yZXRyaWV2YWxMZXZlbCA8IHRoaXMuYmluZGluZ0xldmVsKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRDdHhPYmogPSB0aGlzLm1hcC5nZXQoU0hBUkVEX0NPTlRFWFRfS0VZICsgdmFsdWUucmV0cmlldmFsTGV2ZWwpO1xuICAgICAgICAgICAgaWYgKHNoYXJlZEN0eE9iaikge1xuICAgICAgICAgICAgICAgIHNoYXJlZEN0eE9iai5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyKHZhbHVlLnJldHJpZXZhbExldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW5lcmF0ZVNoYXJlZENvbnRleHRWYXIocmV0cmlldmFsTGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbGhzID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FICsgdGhpcy5mcmVzaFJlZmVyZW5jZU5hbWUoKSk7XG4gICAgICAgIHRoaXMubWFwLnNldChTSEFSRURfQ09OVEVYVF9LRVkgKyByZXRyaWV2YWxMZXZlbCwge1xuICAgICAgICAgICAgcmV0cmlldmFsTGV2ZWw6IHJldHJpZXZhbExldmVsLFxuICAgICAgICAgICAgbGhzOiBsaHMsXG4gICAgICAgICAgICBkZWNsYXJlTG9jYWxDYWxsYmFjazogKHNjb3BlLCByZWxhdGl2ZUxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgY3R4X3IwID0gbmV4dENvbnRleHQoMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsaHMuc2V0KGdlbmVyYXRlTmV4dENvbnRleHRFeHByKHJlbGF0aXZlTGV2ZWwpKS50b0NvbnN0RGVjbCgpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNsYXJlOiBmYWxzZSxcbiAgICAgICAgICAgIHByaW9yaXR5OiAyIC8qIERlY2xhcmF0aW9uUHJpb3JpdHkuU0hBUkVEX0NPTlRFWFQgKi8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb21wb25lbnRQcm9wZXJ0eShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFZhbHVlID0gdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIDApO1xuICAgICAgICBjb21wb25lbnRWYWx1ZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXliZVJlc3RvcmVWaWV3KCk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRWYWx1ZS5saHMucHJvcChuYW1lKTtcbiAgICB9XG4gICAgbWF5YmVSZXN0b3JlVmlldygpIHtcbiAgICAgICAgLy8gVmlldyByZXN0b3JhdGlvbiBpcyByZXF1aXJlZCBmb3IgbGlzdGVuZXIgaW5zdHJ1Y3Rpb25zIGluc2lkZSBlbWJlZGRlZCB2aWV3cywgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IG9ubHkgcnVuIGluIGNyZWF0aW9uIG1vZGUgYW5kIHRoZXkgY2FuIGhhdmUgcmVmZXJlbmNlcyB0byB0aGUgY29udGV4dCBvYmplY3QuXG4gICAgICAgIC8vIElmIHRoZSBjb250ZXh0IG9iamVjdCBjaGFuZ2VzIGluIHVwZGF0ZSBtb2RlLCB0aGUgcmVmZXJlbmNlIHdpbGwgYmUgaW5jb3JyZWN0LCBiZWNhdXNlXG4gICAgICAgIC8vIGl0IHdhcyBlc3RhYmxpc2hlZCBkdXJpbmcgY3JlYXRpb24uXG4gICAgICAgIGlmICh0aGlzLmlzTGlzdGVuZXJTY29wZSgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50LnJlc3RvcmVWaWV3VmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgc2F2ZXMgdmFyaWFibGUgdG8gZ2VuZXJhdGUgYSBzaGFyZWQgYGNvbnN0ICRzJCA9IGdldEN1cnJlbnRWaWV3KCk7YCBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJlc3RvcmVWaWV3VmFyaWFibGUgPSB2YXJpYWJsZSh0aGlzLnBhcmVudC5mcmVzaFJlZmVyZW5jZU5hbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGUgPSB0aGlzLnBhcmVudC5yZXN0b3JlVmlld1ZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3RvcmVWaWV3U3RhdGVtZW50KCkge1xuICAgICAgICBpZiAodGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN0b3JlQ2FsbCA9IGludm9rZUluc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzLnJlc3RvcmVWaWV3LCBbdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlXSk7XG4gICAgICAgICAgICAvLyBFaXRoZXIgYGNvbnN0IHJlc3RvcmVkQ3R4ID0gcmVzdG9yZVZpZXcoJHN0YXRlJCk7YCBvciBgcmVzdG9yZVZpZXcoJHN0YXRlJCk7YFxuICAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYmVpbmcgdXNlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXNSZXN0b3JlZFZpZXdDb250ZXh0ID9cbiAgICAgICAgICAgICAgICB2YXJpYWJsZShSRVNUT1JFRF9WSUVXX0NPTlRFWFRfTkFNRSkuc2V0KHJlc3RvcmVDYWxsKS50b0NvbnN0RGVjbCgpIDpcbiAgICAgICAgICAgICAgICByZXN0b3JlQ2FsbC50b1N0bXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlld1NuYXBzaG90U3RhdGVtZW50cygpIHtcbiAgICAgICAgLy8gY29uc3QgJHN0YXRlJCA9IGdldEN1cnJlbnRWaWV3KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGUgP1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVZpZXdWYXJpYWJsZS5zZXQoaW52b2tlSW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMuZ2V0Q3VycmVudFZpZXcsIFtdKSkudG9Db25zdERlY2woKVxuICAgICAgICAgICAgXSA6XG4gICAgICAgICAgICBbXTtcbiAgICB9XG4gICAgaXNMaXN0ZW5lclNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuYmluZGluZ0xldmVsID09PSB0aGlzLmJpbmRpbmdMZXZlbDtcbiAgICB9XG4gICAgdmFyaWFibGVEZWNsYXJhdGlvbnMoKSB7XG4gICAgICAgIGxldCBjdXJyZW50Q29udGV4dExldmVsID0gMDtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAudmFsdWVzKCkpXG4gICAgICAgICAgICAuZmlsdGVyKHZhbHVlID0+IHZhbHVlLmRlY2xhcmUpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5yZXRyaWV2YWxMZXZlbCAtIGEucmV0cmlldmFsTGV2ZWwgfHwgYi5wcmlvcml0eSAtIGEucHJpb3JpdHkpXG4gICAgICAgICAgICAucmVkdWNlKChzdG10cywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRGlmZiA9IHRoaXMuYmluZGluZ0xldmVsIC0gdmFsdWUucmV0cmlldmFsTGV2ZWw7XG4gICAgICAgICAgICBjb25zdCBjdXJyU3RtdHMgPSB2YWx1ZS5kZWNsYXJlTG9jYWxDYWxsYmFjayh0aGlzLCBsZXZlbERpZmYgLSBjdXJyZW50Q29udGV4dExldmVsKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0TGV2ZWwgPSBsZXZlbERpZmY7XG4gICAgICAgICAgICByZXR1cm4gc3RtdHMuY29uY2F0KGN1cnJTdG10cyk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgZnJlc2hSZWZlcmVuY2VOYW1lKCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIC8vIEZpbmQgdGhlIHRvcCBzY29wZSBhcyBpdCBtYWludGFpbnMgdGhlIGdsb2JhbCByZWZlcmVuY2UgY291bnRcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQucGFyZW50KVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICBjb25zdCByZWYgPSBgJHtSRUZFUkVOQ0VfUFJFRklYfSR7Y3VycmVudC5yZWZlcmVuY2VOYW1lSW5kZXgrK31gO1xuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBoYXNSZXN0b3JlVmlld1ZhcmlhYmxlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGU7XG4gICAgfVxuICAgIG5vdGlmeVJlc3RvcmVkVmlld0NvbnRleHRVc2UoKSB7XG4gICAgICAgIHRoaXMudXNlc1Jlc3RvcmVkVmlld0NvbnRleHQgPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBDc3NTZWxlY3RvcmAgZ2l2ZW4gYSB0YWcgbmFtZSBhbmQgYSBtYXAgb2YgYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVDc3NTZWxlY3RvcihlbGVtZW50TmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgY29uc3QgZWxlbWVudE5hbWVOb05zID0gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpWzFdO1xuICAgIGNzc1NlbGVjdG9yLnNldEVsZW1lbnQoZWxlbWVudE5hbWVOb05zKTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWVOb05zID0gc3BsaXROc05hbWUobmFtZSlbMV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgY3NzU2VsZWN0b3IuYWRkQXR0cmlidXRlKG5hbWVOb05zLCB2YWx1ZSk7XG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaChjbGFzc05hbWUgPT4gY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTmFtZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNzc1NlbGVjdG9yO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGV4cHJlc3Npb25zIG91dCBvZiBhbiBgbmdQcm9qZWN0QXNgIGF0dHJpYnV0ZXNcbiAqIHdoaWNoIGNhbiBiZSBhZGRlZCB0byB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gZ2V0TmdQcm9qZWN0QXNMaXRlcmFsKGF0dHJpYnV0ZSkge1xuICAgIC8vIFBhcnNlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgaW50byBhIENzc1NlbGVjdG9yTGlzdC4gTm90ZSB0aGF0IHdlIG9ubHkgdGFrZSB0aGVcbiAgICAvLyBmaXJzdCBzZWxlY3RvciwgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IG11bHRpcGxlIHNlbGVjdG9ycyBpbiBuZ1Byb2plY3RBcy5cbiAgICBjb25zdCBwYXJzZWRSM1NlbGVjdG9yID0gcGFyc2VTZWxlY3RvclRvUjNTZWxlY3RvcihhdHRyaWJ1dGUudmFsdWUpWzBdO1xuICAgIHJldHVybiBbbGl0ZXJhbCg1IC8qIGNvcmUuQXR0cmlidXRlTWFya2VyLlByb2plY3RBcyAqLyksIGFzTGl0ZXJhbChwYXJzZWRSM1NlbGVjdG9yKV07XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uIEFuIEludGVycG9sYXRpb24gQVNUXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlMTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNDtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNztcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgYXR0cmlidXRlXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihpbnRlcnBvbGF0aW9uKSB7XG4gICAgc3dpdGNoIChnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSkge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgaW50ZXJwb2xhdGVkIHRleHQuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRUZXh0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU2O1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGVWO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2UgYSB0ZW1wbGF0ZSBpbnRvIHJlbmRlcjMgYE5vZGVgcyBhbmQgYWRkaXRpb25hbCBtZXRhZGF0YSwgd2l0aCBubyBvdGhlciBkZXBlbmRlbmNpZXMuXG4gKlxuICogQHBhcmFtIHRlbXBsYXRlIHRleHQgb2YgdGhlIHRlbXBsYXRlIHRvIHBhcnNlXG4gKiBAcGFyYW0gdGVtcGxhdGVVcmwgVVJMIHRvIHVzZSBmb3Igc291cmNlIG1hcHBpbmcgb2YgdGhlIHBhcnNlZCB0ZW1wbGF0ZVxuICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyB0byBtb2RpZnkgaG93IHRoZSB0ZW1wbGF0ZSBpcyBwYXJzZWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgaW50ZXJwb2xhdGlvbkNvbmZpZywgcHJlc2VydmVXaGl0ZXNwYWNlcywgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiaW5kaW5nUGFyc2VyID0gbWFrZUJpbmRpbmdQYXJzZXIoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgY29uc3QgaHRtbFBhcnNlciA9IG5ldyBIdG1sUGFyc2VyKCk7XG4gICAgY29uc3QgcGFyc2VSZXN1bHQgPSBodG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgbGVhZGluZ1RyaXZpYUNoYXJzOiBMRUFESU5HX1RSSVZJQV9DSEFSUyB9LCBvcHRpb25zKSwgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlIH0pKTtcbiAgICBpZiAoIW9wdGlvbnMuYWx3YXlzQXR0ZW1wdEh0bWxUb1IzQXN0Q29udmVyc2lvbiAmJiBwYXJzZVJlc3VsdC5lcnJvcnMgJiZcbiAgICAgICAgcGFyc2VSZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVGVtcGxhdGUgPSB7XG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uQ29uZmlnLFxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlcyxcbiAgICAgICAgICAgIGVycm9yczogcGFyc2VSZXN1bHQuZXJyb3JzLFxuICAgICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgICAgc3R5bGVVcmxzOiBbXSxcbiAgICAgICAgICAgIHN0eWxlczogW10sXG4gICAgICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIHBhcnNlZFRlbXBsYXRlLmNvbW1lbnROb2RlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRUZW1wbGF0ZTtcbiAgICB9XG4gICAgbGV0IHJvb3ROb2RlcyA9IHBhcnNlUmVzdWx0LnJvb3ROb2RlcztcbiAgICAvLyBwcm9jZXNzIGkxOG4gbWV0YSBpbmZvcm1hdGlvbiAoc2NhbiBhdHRyaWJ1dGVzLCBnZW5lcmF0ZSBpZHMpXG4gICAgLy8gYmVmb3JlIHdlIHJ1biB3aGl0ZXNwYWNlIHJlbW92YWwgcHJvY2VzcywgYmVjYXVzZSBleGlzdGluZyBpMThuXG4gICAgLy8gZXh0cmFjdGlvbiBwcm9jZXNzIChuZyBleHRyYWN0LWkxOG4pIHJlbGllcyBvbiBhIHJhdyBjb250ZW50IHRvIGdlbmVyYXRlXG4gICAgLy8gbWVzc2FnZSBpZHNcbiAgICBjb25zdCBpMThuTWV0YVZpc2l0b3IgPSBuZXcgSTE4bk1ldGFWaXNpdG9yKGludGVycG9sYXRpb25Db25maWcsIC8qIGtlZXBJMThuQXR0cnMgKi8gIXByZXNlcnZlV2hpdGVzcGFjZXMsIGVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQpO1xuICAgIGNvbnN0IGkxOG5NZXRhUmVzdWx0ID0gaTE4bk1ldGFWaXNpdG9yLnZpc2l0QWxsV2l0aEVycm9ycyhyb290Tm9kZXMpO1xuICAgIGlmICghb3B0aW9ucy5hbHdheXNBdHRlbXB0SHRtbFRvUjNBc3RDb252ZXJzaW9uICYmIGkxOG5NZXRhUmVzdWx0LmVycm9ycyAmJlxuICAgICAgICBpMThuTWV0YVJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUZW1wbGF0ZSA9IHtcbiAgICAgICAgICAgIGludGVycG9sYXRpb25Db25maWcsXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzLFxuICAgICAgICAgICAgZXJyb3JzOiBpMThuTWV0YVJlc3VsdC5lcnJvcnMsXG4gICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgc3R5bGVzOiBbXSxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29sbGVjdENvbW1lbnROb2Rlcykge1xuICAgICAgICAgICAgcGFyc2VkVGVtcGxhdGUuY29tbWVudE5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZFRlbXBsYXRlO1xuICAgIH1cbiAgICByb290Tm9kZXMgPSBpMThuTWV0YVJlc3VsdC5yb290Tm9kZXM7XG4gICAgaWYgKCFwcmVzZXJ2ZVdoaXRlc3BhY2VzKSB7XG4gICAgICAgIHJvb3ROb2RlcyA9IHZpc2l0QWxsKG5ldyBXaGl0ZXNwYWNlVmlzaXRvcigpLCByb290Tm9kZXMpO1xuICAgICAgICAvLyBydW4gaTE4biBtZXRhIHZpc2l0b3IgYWdhaW4gaW4gY2FzZSB3aGl0ZXNwYWNlcyBhcmUgcmVtb3ZlZCAoYmVjYXVzZSB0aGF0IG1pZ2h0IGFmZmVjdFxuICAgICAgICAvLyBnZW5lcmF0ZWQgaTE4biBtZXNzYWdlIGNvbnRlbnQpIGFuZCBmaXJzdCBwYXNzIGluZGljYXRlZCB0aGF0IGkxOG4gY29udGVudCBpcyBwcmVzZW50IGluIGFcbiAgICAgICAgLy8gdGVtcGxhdGUuIER1cmluZyB0aGlzIHBhc3MgaTE4biBJRHMgZ2VuZXJhdGVkIGF0IHRoZSBmaXJzdCBwYXNzIHdpbGwgYmUgcHJlc2VydmVkLCBzbyB3ZSBjYW5cbiAgICAgICAgLy8gbWltaWMgZXhpc3RpbmcgZXh0cmFjdGlvbiBwcm9jZXNzIChuZyBleHRyYWN0LWkxOG4pXG4gICAgICAgIGlmIChpMThuTWV0YVZpc2l0b3IuaGFzSTE4bk1ldGEpIHtcbiAgICAgICAgICAgIHJvb3ROb2RlcyA9IHZpc2l0QWxsKG5ldyBJMThuTWV0YVZpc2l0b3IoaW50ZXJwb2xhdGlvbkNvbmZpZywgLyoga2VlcEkxOG5BdHRycyAqLyBmYWxzZSksIHJvb3ROb2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBub2RlcywgZXJyb3JzLCBzdHlsZVVybHMsIHN0eWxlcywgbmdDb250ZW50U2VsZWN0b3JzLCBjb21tZW50Tm9kZXMgfSA9IGh0bWxBc3RUb1JlbmRlcjNBc3Qocm9vdE5vZGVzLCBiaW5kaW5nUGFyc2VyLCB7IGNvbGxlY3RDb21tZW50Tm9kZXM6ICEhb3B0aW9ucy5jb2xsZWN0Q29tbWVudE5vZGVzIH0pO1xuICAgIGVycm9ycy5wdXNoKC4uLnBhcnNlUmVzdWx0LmVycm9ycywgLi4uaTE4bk1ldGFSZXN1bHQuZXJyb3JzKTtcbiAgICBjb25zdCBwYXJzZWRUZW1wbGF0ZSA9IHtcbiAgICAgICAgaW50ZXJwb2xhdGlvbkNvbmZpZyxcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlcyxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID4gMCA/IGVycm9ycyA6IG51bGwsXG4gICAgICAgIG5vZGVzLFxuICAgICAgICBzdHlsZVVybHMsXG4gICAgICAgIHN0eWxlcyxcbiAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5jb2xsZWN0Q29tbWVudE5vZGVzKSB7XG4gICAgICAgIHBhcnNlZFRlbXBsYXRlLmNvbW1lbnROb2RlcyA9IGNvbW1lbnROb2RlcztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFRlbXBsYXRlO1xufVxuY29uc3QgZWxlbWVudFJlZ2lzdHJ5ID0gbmV3IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSgpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBgQmluZGluZ1BhcnNlcmAgd2l0aCBhIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFrZUJpbmRpbmdQYXJzZXIoaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcpIHtcbiAgICByZXR1cm4gbmV3IEJpbmRpbmdQYXJzZXIobmV3IFBhcnNlciQxKG5ldyBMZXhlcigpKSwgaW50ZXJwb2xhdGlvbkNvbmZpZywgZWxlbWVudFJlZ2lzdHJ5LCBbXSk7XG59XG5mdW5jdGlvbiByZXNvbHZlU2FuaXRpemF0aW9uRm4oY29udGV4dCwgaXNBdHRyaWJ1dGUpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuSFRNTDpcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnNhbml0aXplSHRtbCk7XG4gICAgICAgIGNhc2UgU2VjdXJpdHlDb250ZXh0LlNDUklQVDpcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnNhbml0aXplU2NyaXB0KTtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuU1RZTEU6XG4gICAgICAgICAgICAvLyB0aGUgY29tcGlsZXIgZG9lcyBub3QgZmlsbCBpbiBhbiBpbnN0cnVjdGlvbiBmb3IgW3N0eWxlLnByb3A/XSBiaW5kaW5nXG4gICAgICAgICAgICAvLyB2YWx1ZXMgYmVjYXVzZSB0aGUgc3R5bGUgYWxnb3JpdGhtIGtub3dzIGludGVybmFsbHkgd2hhdCBwcm9wcyBhcmUgc3ViamVjdFxuICAgICAgICAgICAgLy8gdG8gc2FuaXRpemF0aW9uIChvbmx5IFthdHRyLnN0eWxlXSB2YWx1ZXMgYXJlIGV4cGxpY2l0bHkgc2FuaXRpemVkKVxuICAgICAgICAgICAgcmV0dXJuIGlzQXR0cmlidXRlID8gaW1wb3J0RXhwcihJZGVudGlmaWVycy5zYW5pdGl6ZVN0eWxlKSA6IG51bGw7XG4gICAgICAgIGNhc2UgU2VjdXJpdHlDb250ZXh0LlVSTDpcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnNhbml0aXplVXJsKTtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMOlxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuc2FuaXRpemVSZXNvdXJjZVVybCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnVzdGVkQ29uc3RBdHRyaWJ1dGUodGFnTmFtZSwgYXR0cikge1xuICAgIGNvbnN0IHZhbHVlID0gYXNMaXRlcmFsKGF0dHIudmFsdWUpO1xuICAgIGlmIChpc1RydXN0ZWRUeXBlc1NpbmsodGFnTmFtZSwgYXR0ci5uYW1lKSkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnRSZWdpc3RyeS5zZWN1cml0eUNvbnRleHQodGFnTmFtZSwgYXR0ci5uYW1lLCAvKiBpc0F0dHJpYnV0ZSAqLyB0cnVlKSkge1xuICAgICAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuSFRNTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnZ2VkVGVtcGxhdGUoaW1wb3J0RXhwcihJZGVudGlmaWVycy50cnVzdENvbnN0YW50SHRtbCksIG5ldyBUZW1wbGF0ZUxpdGVyYWwoW25ldyBUZW1wbGF0ZUxpdGVyYWxFbGVtZW50KGF0dHIudmFsdWUpXSwgW10pLCB1bmRlZmluZWQsIGF0dHIudmFsdWVTcGFuKTtcbiAgICAgICAgICAgIC8vIE5COiBubyBTZWN1cml0eUNvbnRleHQuU0NSSVBUIGhlcmUsIGFzIHRoZSBjb3JyZXNwb25kaW5nIHRhZ3MgYXJlIHN0cmlwcGVkIGJ5IHRoZSBjb21waWxlci5cbiAgICAgICAgICAgIGNhc2UgU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnZ2VkVGVtcGxhdGUoaW1wb3J0RXhwcihJZGVudGlmaWVycy50cnVzdENvbnN0YW50UmVzb3VyY2VVcmwpLCBuZXcgVGVtcGxhdGVMaXRlcmFsKFtuZXcgVGVtcGxhdGVMaXRlcmFsRWxlbWVudChhdHRyLnZhbHVlKV0sIFtdKSwgdW5kZWZpbmVkLCBhdHRyLnZhbHVlU3Bhbik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzU2luZ2xlRWxlbWVudFRlbXBsYXRlKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXSBpbnN0YW5jZW9mIEVsZW1lbnQkMTtcbn1cbmZ1bmN0aW9uIGlzVGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dCQzIHx8IG5vZGUgaW5zdGFuY2VvZiBCb3VuZFRleHQgfHwgbm9kZSBpbnN0YW5jZW9mIEljdSQxO1xufVxuZnVuY3Rpb24gaGFzVGV4dENoaWxkcmVuT25seShjaGlsZHJlbikge1xuICAgIHJldHVybiBjaGlsZHJlbi5ldmVyeShpc1RleHROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmdGdW5jdGlvblBhcmFtcyhkZWZlcnJlZFBhcmFtcywgbmFtZSwgZWFnZXJQYXJhbXMpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRlZmVycmVkUGFyYW1zKCk7XG4gICAgICAgIGNvbnN0IGZuUGFyYW1zID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgICAgIGlmIChlYWdlclBhcmFtcykge1xuICAgICAgICAgICAgZm5QYXJhbXMucHVzaCguLi5lYWdlclBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdGhlIHByb3BlcnR5IG5hbWUgdG8gYWx3YXlzIGJlIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXJhbWV0ZXIuXG4gICAgICAgICAgICBmblBhcmFtcy51bnNoaWZ0KGxpdGVyYWwobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmblBhcmFtcztcbiAgICB9O1xufVxuLyoqIE5hbWUgb2YgdGhlIGdsb2JhbCB2YXJpYWJsZSB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHdlIHVzZSBDbG9zdXJlIHRyYW5zbGF0aW9ucyBvciBub3QgKi9cbmNvbnN0IE5HX0kxOE5fQ0xPU1VSRV9NT0RFID0gJ25nSTE4bkNsb3N1cmVNb2RlJztcbi8qKlxuICogR2VuZXJhdGUgc3RhdGVtZW50cyB0aGF0IGRlZmluZSBhIGdpdmVuIHRyYW5zbGF0aW9uIG1lc3NhZ2UuXG4gKlxuICogYGBgXG4gKiB2YXIgSTE4Tl8xO1xuICogaWYgKHR5cGVvZiBuZ0kxOG5DbG9zdXJlTW9kZSAhPT0gdW5kZWZpbmVkICYmIG5nSTE4bkNsb3N1cmVNb2RlKSB7XG4gKiAgICAgdmFyIE1TR19FWFRFUk5BTF9YWFggPSBnb29nLmdldE1zZyhcbiAqICAgICAgICAgIFwiU29tZSBtZXNzYWdlIHdpdGggeyRpbnRlcnBvbGF0aW9ufSFcIixcbiAqICAgICAgICAgIHsgXCJpbnRlcnBvbGF0aW9uXCI6IFwiXFx1RkZGRDBcXHVGRkZEXCIgfVxuICogICAgICk7XG4gKiAgICAgSTE4Tl8xID0gTVNHX0VYVEVSTkFMX1hYWDtcbiAqIH1cbiAqIGVsc2Uge1xuICogICAgIEkxOE5fMSA9ICRsb2NhbGl6ZWBTb21lIG1lc3NhZ2Ugd2l0aCAkeydcXHVGRkZEMFxcdUZGRkQnfSFgO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG9yaWdpbmFsIGkxOG4gQVNUIG1lc3NhZ2Ugbm9kZVxuICogQHBhcmFtIHZhcmlhYmxlIFRoZSB2YXJpYWJsZSB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdGhlIHRyYW5zbGF0aW9uLCBlLmcuIGBJMThOXzFgLlxuICogQHBhcmFtIGNsb3N1cmVWYXIgVGhlIHZhcmlhYmxlIGZvciBDbG9zdXJlIGBnb29nLmdldE1zZ2AgY2FsbHMsIGUuZy4gYE1TR19FWFRFUk5BTF9YWFhgLlxuICogQHBhcmFtIHBhcmFtcyBPYmplY3QgbWFwcGluZyBwbGFjZWhvbGRlciBuYW1lcyB0byB0aGVpciB2YWx1ZXMgKGUuZy5cbiAqIGB7IFwiaW50ZXJwb2xhdGlvblwiOiBcIlxcdUZGRkQwXFx1RkZGRFwiIH1gKS5cbiAqIEBwYXJhbSB0cmFuc2Zvcm1GbiBPcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgdHJhbnNsYXRpb24gKGUuZy5cbiAqIHBvc3QtcHJvY2Vzc2luZykuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHRoYXQgZGVmaW5lZCBhIGdpdmVuIHRyYW5zbGF0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbkRlY2xTdG10cyhtZXNzYWdlLCB2YXJpYWJsZSwgY2xvc3VyZVZhciwgcGFyYW1zID0ge30sIHRyYW5zZm9ybUZuKSB7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IFtcbiAgICAgICAgZGVjbGFyZUkxOG5WYXJpYWJsZSh2YXJpYWJsZSksXG4gICAgICAgIGlmU3RtdChjcmVhdGVDbG9zdXJlTW9kZUd1YXJkKCksIGNyZWF0ZUdvb2dsZUdldE1zZ1N0YXRlbWVudHModmFyaWFibGUsIG1lc3NhZ2UsIGNsb3N1cmVWYXIsIHBhcmFtcyksIGNyZWF0ZUxvY2FsaXplU3RhdGVtZW50cyh2YXJpYWJsZSwgbWVzc2FnZSwgZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZXNJbk1hcChwYXJhbXMsIC8qIHVzZUNhbWVsQ2FzZSAqLyBmYWxzZSkpKSxcbiAgICBdO1xuICAgIGlmICh0cmFuc2Zvcm1Gbikge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodmFyaWFibGUuc2V0KHRyYW5zZm9ybUZuKHZhcmlhYmxlKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgZXhwcmVzc2lvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBndWFyZCB0aGUgY2xvc3VyZSBtb2RlIGJsb2NrXG4gKiBJdCBpcyBlcXVpdmFsZW50IHRvOlxuICpcbiAqIGBgYFxuICogdHlwZW9mIG5nSTE4bkNsb3N1cmVNb2RlICE9PSB1bmRlZmluZWQgJiYgbmdJMThuQ2xvc3VyZU1vZGVcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjcmVhdGVDbG9zdXJlTW9kZUd1YXJkKCkge1xuICAgIHJldHVybiB0eXBlb2ZFeHByKHZhcmlhYmxlKE5HX0kxOE5fQ0xPU1VSRV9NT0RFKSlcbiAgICAgICAgLm5vdElkZW50aWNhbChsaXRlcmFsKCd1bmRlZmluZWQnLCBTVFJJTkdfVFlQRSkpXG4gICAgICAgIC5hbmQodmFyaWFibGUoTkdfSTE4Tl9DTE9TVVJFX01PREUpKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW4obGlzdCkge1xuICAgIHJldHVybiBsaXN0LnJlZHVjZSgoZmxhdCwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBmbGF0SXRlbSA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBmbGF0dGVuKGl0ZW0pIDogaXRlbTtcbiAgICAgICAgcmV0dXJuIGZsYXQuY29uY2F0KGZsYXRJdGVtKTtcbiAgICB9LCBbXSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gVGhpcyByZWdleCBtYXRjaGVzIGFueSBiaW5kaW5nIG5hbWVzIHRoYXQgY29udGFpbiB0aGUgXCJhdHRyLlwiIHByZWZpeCwgZS5nLiBcImF0dHIucmVxdWlyZWRcIlxuLy8gSWYgdGhlcmUgaXMgYSBtYXRjaCwgdGhlIGZpcnN0IG1hdGNoaW5nIGdyb3VwIHdpbGwgY29udGFpbiB0aGUgYXR0cmlidXRlIG5hbWUgdG8gYmluZC5cbmNvbnN0IEFUVFJfUkVHRVggPSAvYXR0clxcLihbXlxcXV0rKS87XG5jb25zdCBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbmNvbnN0IEhPU1RfQVRUUiA9IGBfbmdob3N0LSR7Q09NUE9ORU5UX1ZBUklBQkxFfWA7XG5jb25zdCBDT05URU5UX0FUVFIgPSBgX25nY29udGVudC0ke0NPTVBPTkVOVF9WQVJJQUJMRX1gO1xuZnVuY3Rpb24gYmFzZURpcmVjdGl2ZUZpZWxkcyhtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBjb25zdCBzZWxlY3RvcnMgPSBwYXJzZVNlbGVjdG9yVG9SM1NlbGVjdG9yKG1ldGEuc2VsZWN0b3IpO1xuICAgIC8vIGUuZy4gYHR5cGU6IE15RGlyZWN0aXZlYFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgIC8vIGUuZy4gYHNlbGVjdG9yczogW1snJywgJ3NvbWVEaXInLCAnJ11dYFxuICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc2VsZWN0b3JzJywgYXNMaXRlcmFsKHNlbGVjdG9ycykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5xdWVyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZS5nLiBgY29udGVudFF1ZXJpZXM6IChyZiwgY3R4LCBkaXJJbmRleCkgPT4geyAuLi4gfVxuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnY29udGVudFF1ZXJpZXMnLCBjcmVhdGVDb250ZW50UXVlcmllc0Z1bmN0aW9uKG1ldGEucXVlcmllcywgY29uc3RhbnRQb29sLCBtZXRhLm5hbWUpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEudmlld1F1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd2aWV3UXVlcnknLCBjcmVhdGVWaWV3UXVlcmllc0Z1bmN0aW9uKG1ldGEudmlld1F1ZXJpZXMsIGNvbnN0YW50UG9vbCwgbWV0YS5uYW1lKSk7XG4gICAgfVxuICAgIC8vIGUuZy4gYGhvc3RCaW5kaW5nczogKHJmLCBjdHgpID0+IHsgLi4uIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaG9zdEJpbmRpbmdzJywgY3JlYXRlSG9zdEJpbmRpbmdzRnVuY3Rpb24obWV0YS5ob3N0LCBtZXRhLnR5cGVTb3VyY2VTcGFuLCBiaW5kaW5nUGFyc2VyLCBjb25zdGFudFBvb2wsIG1ldGEuc2VsZWN0b3IgfHwgJycsIG1ldGEubmFtZSwgZGVmaW5pdGlvbk1hcCkpO1xuICAgIC8vIGUuZyAnaW5wdXRzOiB7YTogJ2EnfWBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaW5wdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5pbnB1dHMsIHRydWUpKTtcbiAgICAvLyBlLmcgJ291dHB1dHM6IHthOiAnYSd9YFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdvdXRwdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5vdXRwdXRzKSk7XG4gICAgaWYgKG1ldGEuZXhwb3J0QXMgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2V4cG9ydEFzJywgbGl0ZXJhbEFycihtZXRhLmV4cG9ydEFzLm1hcChlID0+IGxpdGVyYWwoZSkpKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc3RhbmRhbG9uZScsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbk1hcDtcbn1cbi8qKlxuICogQWRkIGZlYXR1cmVzIHRvIHRoZSBkZWZpbml0aW9uIG1hcC5cbiAqL1xuZnVuY3Rpb24gYWRkRmVhdHVyZXMoZGVmaW5pdGlvbk1hcCwgbWV0YSkge1xuICAgIC8vIGUuZy4gYGZlYXR1cmVzOiBbTmdPbkNoYW5nZXNGZWF0dXJlXWBcbiAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgIGNvbnN0IHByb3ZpZGVycyA9IG1ldGEucHJvdmlkZXJzO1xuICAgIGNvbnN0IHZpZXdQcm92aWRlcnMgPSBtZXRhLnZpZXdQcm92aWRlcnM7XG4gICAgaWYgKHByb3ZpZGVycyB8fCB2aWV3UHJvdmlkZXJzKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbcHJvdmlkZXJzIHx8IG5ldyBMaXRlcmFsQXJyYXlFeHByKFtdKV07XG4gICAgICAgIGlmICh2aWV3UHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2godmlld1Byb3ZpZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZXMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzLlByb3ZpZGVyc0ZlYXR1cmUpLmNhbGxGbihhcmdzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnVzZXNJbmhlcml0YW5jZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuSW5oZXJpdERlZmluaXRpb25GZWF0dXJlKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmZ1bGxJbmhlcml0YW5jZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuQ29weURlZmluaXRpb25GZWF0dXJlKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmxpZmVjeWNsZS51c2VzT25DaGFuZ2VzKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycy5OZ09uQ2hhbmdlc0ZlYXR1cmUpKTtcbiAgICB9XG4gICAgLy8gVE9ETzogYmV0dGVyIHdheSBvZiBkaWZmZXJlbnRpYXRpbmcgY29tcG9uZW50IHZzIGRpcmVjdGl2ZSBtZXRhZGF0YS5cbiAgICBpZiAobWV0YS5oYXNPd25Qcm9wZXJ0eSgndGVtcGxhdGUnKSAmJiBtZXRhLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuU3RhbmRhbG9uZUZlYXR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZmVhdHVyZXMnLCBsaXRlcmFsQXJyKGZlYXR1cmVzKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDb21waWxlIGEgZGlyZWN0aXZlIGZvciB0aGUgcmVuZGVyMyBydW50aW1lIGFzIGRlZmluZWQgYnkgdGhlIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURpcmVjdGl2ZUZyb21NZXRhZGF0YShtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gYmFzZURpcmVjdGl2ZUZpZWxkcyhtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpO1xuICAgIGFkZEZlYXR1cmVzKGRlZmluaXRpb25NYXAsIG1ldGEpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlZmluZURpcmVjdGl2ZSkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBjb25zdCB0eXBlID0gY3JlYXRlRGlyZWN0aXZlVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuLyoqXG4gKiBDb21waWxlIGEgY29tcG9uZW50IGZvciB0aGUgcmVuZGVyMyBydW50aW1lIGFzIGRlZmluZWQgYnkgdGhlIGBSM0NvbXBvbmVudE1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUNvbXBvbmVudEZyb21NZXRhZGF0YShtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gYmFzZURpcmVjdGl2ZUZpZWxkcyhtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpO1xuICAgIGFkZEZlYXR1cmVzKGRlZmluaXRpb25NYXAsIG1ldGEpO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gbWV0YS5zZWxlY3RvciAmJiBDc3NTZWxlY3Rvci5wYXJzZShtZXRhLnNlbGVjdG9yKTtcbiAgICBjb25zdCBmaXJzdFNlbGVjdG9yID0gc2VsZWN0b3IgJiYgc2VsZWN0b3JbMF07XG4gICAgLy8gZS5nLiBgYXR0cjogW1wiY2xhc3NcIiwgXCIubXkuYXBwXCJdYFxuICAgIC8vIFRoaXMgaXMgb3B0aW9uYWwgYW4gb25seSBpbmNsdWRlZCBpZiB0aGUgZmlyc3Qgc2VsZWN0b3Igb2YgYSBjb21wb25lbnQgc3BlY2lmaWVzIGF0dHJpYnV0ZXMuXG4gICAgaWYgKGZpcnN0U2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JBdHRyaWJ1dGVzID0gZmlyc3RTZWxlY3Rvci5nZXRBdHRycygpO1xuICAgICAgICBpZiAoc2VsZWN0b3JBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2F0dHJzJywgY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChsaXRlcmFsQXJyKHNlbGVjdG9yQXR0cmlidXRlcy5tYXAodmFsdWUgPT4gdmFsdWUgIT0gbnVsbCA/IGxpdGVyYWwodmFsdWUpIDogbGl0ZXJhbCh1bmRlZmluZWQpKSksIFxuICAgICAgICAgICAgLyogZm9yY2VTaGFyZWQgKi8gdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGUuZy4gYHRlbXBsYXRlOiBmdW5jdGlvbiBNeUNvbXBvbmVudF9UZW1wbGF0ZShfY3R4LCBfY20pIHsuLi59YFxuICAgIGNvbnN0IHRlbXBsYXRlVHlwZU5hbWUgPSBtZXRhLm5hbWU7XG4gICAgY29uc3QgdGVtcGxhdGVOYW1lID0gdGVtcGxhdGVUeXBlTmFtZSA/IGAke3RlbXBsYXRlVHlwZU5hbWV9X1RlbXBsYXRlYCA6IG51bGw7XG4gICAgY29uc3QgY2hhbmdlRGV0ZWN0aW9uID0gbWV0YS5jaGFuZ2VEZXRlY3Rpb247XG4gICAgY29uc3QgdGVtcGxhdGUgPSBtZXRhLnRlbXBsYXRlO1xuICAgIGNvbnN0IHRlbXBsYXRlQnVpbGRlciA9IG5ldyBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyKGNvbnN0YW50UG9vbCwgQmluZGluZ1Njb3BlLmNyZWF0ZVJvb3RTY29wZSgpLCAwLCB0ZW1wbGF0ZVR5cGVOYW1lLCBudWxsLCBudWxsLCB0ZW1wbGF0ZU5hbWUsIElkZW50aWZpZXJzLm5hbWVzcGFjZUhUTUwsIG1ldGEucmVsYXRpdmVDb250ZXh0RmlsZVBhdGgsIG1ldGEuaTE4blVzZUV4dGVybmFsSWRzKTtcbiAgICBjb25zdCB0ZW1wbGF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IHRlbXBsYXRlQnVpbGRlci5idWlsZFRlbXBsYXRlRnVuY3Rpb24odGVtcGxhdGUubm9kZXMsIFtdKTtcbiAgICAvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdGhpcyBzbyB0aGF0IGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBjb21wb25lbnRzIGtub3cgd2hhdFxuICAgIC8vIHByb2plY3RlZCBjb250ZW50IGJsb2NrcyB0byBwYXNzIHRocm91Z2ggdG8gdGhlIGNvbXBvbmVudCB3aGVuIGl0IGlzIGluc3RhbnRpYXRlZC5cbiAgICBjb25zdCBuZ0NvbnRlbnRTZWxlY3RvcnMgPSB0ZW1wbGF0ZUJ1aWxkZXIuZ2V0TmdDb250ZW50U2VsZWN0b3JzKCk7XG4gICAgaWYgKG5nQ29udGVudFNlbGVjdG9ycykge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnbmdDb250ZW50U2VsZWN0b3JzJywgbmdDb250ZW50U2VsZWN0b3JzKTtcbiAgICB9XG4gICAgLy8gZS5nLiBgZGVjbHM6IDJgXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlY2xzJywgbGl0ZXJhbCh0ZW1wbGF0ZUJ1aWxkZXIuZ2V0Q29uc3RDb3VudCgpKSk7XG4gICAgLy8gZS5nLiBgdmFyczogMmBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndmFycycsIGxpdGVyYWwodGVtcGxhdGVCdWlsZGVyLmdldFZhckNvdW50KCkpKTtcbiAgICAvLyBHZW5lcmF0ZSBgY29uc3RzYCBzZWN0aW9uIG9mIENvbXBvbmVudERlZjpcbiAgICAvLyAtIGVpdGhlciBhcyBhbiBhcnJheTpcbiAgICAvLyAgIGBjb25zdHM6IFtbJ29uZScsICd0d28nXSwgWyd0aHJlZScsICdmb3VyJ11dYFxuICAgIC8vIC0gb3IgYXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGluIGNhc2UgYWRkaXRpb25hbCBzdGF0ZW1lbnRzIGFyZSBwcmVzZW50ICh0byBzdXBwb3J0IGkxOG4pOlxuICAgIC8vICAgYGNvbnN0czogZnVuY3Rpb24oKSB7IHZhciBpMThuXzA7IGlmIChuZ0kxOG5DbG9zdXJlTW9kZSkgey4uLn0gZWxzZSB7Li4ufSByZXR1cm4gW2kxOG5fMF07IH1gXG4gICAgY29uc3QgeyBjb25zdEV4cHJlc3Npb25zLCBwcmVwYXJlU3RhdGVtZW50cyB9ID0gdGVtcGxhdGVCdWlsZGVyLmdldENvbnN0cygpO1xuICAgIGlmIChjb25zdEV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGNvbnN0c0V4cHIgPSBsaXRlcmFsQXJyKGNvbnN0RXhwcmVzc2lvbnMpO1xuICAgICAgICAvLyBQcmVwYXJlIHN0YXRlbWVudHMgYXJlIHByZXNlbnQgLSB0dXJuIGBjb25zdHNgIGludG8gYSBmdW5jdGlvbi5cbiAgICAgICAgaWYgKHByZXBhcmVTdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0c0V4cHIgPSBmbihbXSwgWy4uLnByZXBhcmVTdGF0ZW1lbnRzLCBuZXcgUmV0dXJuU3RhdGVtZW50KGNvbnN0c0V4cHIpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2NvbnN0cycsIGNvbnN0c0V4cHIpO1xuICAgIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgndGVtcGxhdGUnLCB0ZW1wbGF0ZUZ1bmN0aW9uRXhwcmVzc2lvbik7XG4gICAgaWYgKG1ldGEuZGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlcGVuZGVuY2llcycsIGNvbXBpbGVEZWNsYXJhdGlvbkxpc3QobGl0ZXJhbEFycihtZXRhLmRlY2xhcmF0aW9ucy5tYXAoZGVjbCA9PiBkZWNsLnR5cGUpKSwgbWV0YS5kZWNsYXJhdGlvbkxpc3RFbWl0TW9kZSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5lbmNhcHN1bGF0aW9uID09PSBudWxsKSB7XG4gICAgICAgIG1ldGEuZW5jYXBzdWxhdGlvbiA9IGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ7XG4gICAgfVxuICAgIC8vIGUuZy4gYHN0eWxlczogW3N0cjEsIHN0cjJdYFxuICAgIGlmIChtZXRhLnN0eWxlcyAmJiBtZXRhLnN0eWxlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVWYWx1ZXMgPSBtZXRhLmVuY2Fwc3VsYXRpb24gPT0gZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCA/XG4gICAgICAgICAgICBjb21waWxlU3R5bGVzKG1ldGEuc3R5bGVzLCBDT05URU5UX0FUVFIsIEhPU1RfQVRUUikgOlxuICAgICAgICAgICAgbWV0YS5zdHlsZXM7XG4gICAgICAgIGNvbnN0IHN0eWxlTm9kZXMgPSBzdHlsZVZhbHVlcy5yZWR1Y2UoKHJlc3VsdCwgc3R5bGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzdHlsZS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwobGl0ZXJhbChzdHlsZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgaWYgKHN0eWxlTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3N0eWxlcycsIGxpdGVyYWxBcnIoc3R5bGVOb2RlcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1ldGEuZW5jYXBzdWxhdGlvbiA9PT0gZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdHlsZSwgZG9uJ3QgZ2VuZXJhdGUgY3NzIHNlbGVjdG9ycyBvbiBlbGVtZW50c1xuICAgICAgICBtZXRhLmVuY2Fwc3VsYXRpb24gPSBleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmU7XG4gICAgfVxuICAgIC8vIE9ubHkgc2V0IHZpZXcgZW5jYXBzdWxhdGlvbiBpZiBpdCdzIG5vdCB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgIGlmIChtZXRhLmVuY2Fwc3VsYXRpb24gIT09IGV4cG9ydHMuVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2VuY2Fwc3VsYXRpb24nLCBsaXRlcmFsKG1ldGEuZW5jYXBzdWxhdGlvbikpO1xuICAgIH1cbiAgICAvLyBlLmcuIGBhbmltYXRpb246IFt0cmlnZ2VyKCcxMjMnLCBbXSldYFxuICAgIGlmIChtZXRhLmFuaW1hdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RhdGEnLCBsaXRlcmFsTWFwKFt7IGtleTogJ2FuaW1hdGlvbicsIHZhbHVlOiBtZXRhLmFuaW1hdGlvbnMsIHF1b3RlZDogZmFsc2UgfV0pKTtcbiAgICB9XG4gICAgLy8gT25seSBzZXQgdGhlIGNoYW5nZSBkZXRlY3Rpb24gZmxhZyBpZiBpdCdzIGRlZmluZWQgYW5kIGl0J3Mgbm90IHRoZSBkZWZhdWx0LlxuICAgIGlmIChjaGFuZ2VEZXRlY3Rpb24gIT0gbnVsbCAmJiBjaGFuZ2VEZXRlY3Rpb24gIT09IGV4cG9ydHMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnY2hhbmdlRGV0ZWN0aW9uJywgbGl0ZXJhbChjaGFuZ2VEZXRlY3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVmaW5lQ29tcG9uZW50KS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVDb21wb25lbnRUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIENyZWF0ZXMgdGhlIHR5cGUgc3BlY2lmaWNhdGlvbiBmcm9tIHRoZSBjb21wb25lbnQgbWV0YS4gVGhpcyB0eXBlIGlzIGluc2VydGVkIGludG8gLmQudHMgZmlsZXNcbiAqIHRvIGJlIGNvbnN1bWVkIGJ5IHVwc3RyZWFtIGNvbXBpbGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50VHlwZShtZXRhKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtcyA9IGNyZWF0ZUJhc2VEaXJlY3RpdmVUeXBlUGFyYW1zKG1ldGEpO1xuICAgIHR5cGVQYXJhbXMucHVzaChzdHJpbmdBcnJheUFzVHlwZShtZXRhLnRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycykpO1xuICAgIHR5cGVQYXJhbXMucHVzaChleHByZXNzaW9uVHlwZShsaXRlcmFsKG1ldGEuaXNTdGFuZGFsb25lKSkpO1xuICAgIHJldHVybiBleHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzLkNvbXBvbmVudERlY2xhcmF0aW9uLCB0eXBlUGFyYW1zKSk7XG59XG4vKipcbiAqIENvbXBpbGVzIHRoZSBhcnJheSBsaXRlcmFsIG9mIGRlY2xhcmF0aW9ucyBpbnRvIGFuIGV4cHJlc3Npb24gYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBlbWl0XG4gKiBtb2RlLlxuICovXG5mdW5jdGlvbiBjb21waWxlRGVjbGFyYXRpb25MaXN0KGxpc3QsIG1vZGUpIHtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIERlY2xhcmF0aW9uTGlzdEVtaXRNb2RlLkRpcmVjdCAqLzpcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZXM6IFtNeURpcl0sXG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgY2FzZSAxIC8qIERlY2xhcmF0aW9uTGlzdEVtaXRNb2RlLkNsb3N1cmUgKi86XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbTXlEaXJdOyB9XG4gICAgICAgICAgICByZXR1cm4gZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KGxpc3QpXSk7XG4gICAgICAgIGNhc2UgMiAvKiBEZWNsYXJhdGlvbkxpc3RFbWl0TW9kZS5DbG9zdXJlUmVzb2x2ZWQgKi86XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbTXlEaXJdLm1hcChuZy5yZXNvbHZlRm9yd2FyZFJlZik7IH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkTGlzdCA9IGxpc3QucHJvcCgnbWFwJykuY2FsbEZuKFtpbXBvcnRFeHByKElkZW50aWZpZXJzLnJlc29sdmVGb3J3YXJkUmVmKV0pO1xuICAgICAgICAgICAgcmV0dXJuIGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudChyZXNvbHZlZExpc3QpXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVF1ZXJ5UGFyYW1zKHF1ZXJ5LCBjb25zdGFudFBvb2wpIHtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gW2dldFF1ZXJ5UHJlZGljYXRlKHF1ZXJ5LCBjb25zdGFudFBvb2wpLCBsaXRlcmFsKHRvUXVlcnlGbGFncyhxdWVyeSkpXTtcbiAgICBpZiAocXVlcnkucmVhZCkge1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2gocXVlcnkucmVhZCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuLyoqXG4gKiBUcmFuc2xhdGVzIHF1ZXJ5IGZsYWdzIGludG8gYFRRdWVyeUZsYWdzYCB0eXBlIGluIHBhY2thZ2VzL2NvcmUvc3JjL3JlbmRlcjMvaW50ZXJmYWNlcy9xdWVyeS50c1xuICogQHBhcmFtIHF1ZXJ5XG4gKi9cbmZ1bmN0aW9uIHRvUXVlcnlGbGFncyhxdWVyeSkge1xuICAgIHJldHVybiAocXVlcnkuZGVzY2VuZGFudHMgPyAxIC8qIFF1ZXJ5RmxhZ3MuZGVzY2VuZGFudHMgKi8gOiAwIC8qIFF1ZXJ5RmxhZ3Mubm9uZSAqLykgfFxuICAgICAgICAocXVlcnkuc3RhdGljID8gMiAvKiBRdWVyeUZsYWdzLmlzU3RhdGljICovIDogMCAvKiBRdWVyeUZsYWdzLm5vbmUgKi8pIHxcbiAgICAgICAgKHF1ZXJ5LmVtaXREaXN0aW5jdENoYW5nZXNPbmx5ID8gNCAvKiBRdWVyeUZsYWdzLmVtaXREaXN0aW5jdENoYW5nZXNPbmx5ICovIDogMCAvKiBRdWVyeUZsYWdzLm5vbmUgKi8pO1xufVxuZnVuY3Rpb24gY29udmVydEF0dHJpYnV0ZXNUb0V4cHJlc3Npb25zKGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIHZhbHVlcy5wdXNoKGxpdGVyYWwoa2V5KSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuLy8gRGVmaW5lIGFuZCB1cGRhdGUgYW55IGNvbnRlbnQgcXVlcmllc1xuZnVuY3Rpb24gY3JlYXRlQ29udGVudFF1ZXJpZXNGdW5jdGlvbihxdWVyaWVzLCBjb25zdGFudFBvb2wsIG5hbWUpIHtcbiAgICBjb25zdCBjcmVhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgY29uc3QgdXBkYXRlU3RhdGVtZW50cyA9IFtdO1xuICAgIGNvbnN0IHRlbXBBbGxvY2F0b3IgPSB0ZW1wb3JhcnlBbGxvY2F0b3IodXBkYXRlU3RhdGVtZW50cywgVEVNUE9SQVJZX05BTUUpO1xuICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xuICAgICAgICAvLyBjcmVhdGlvbiwgZS5nLiByMy5jb250ZW50UXVlcnkoZGlySW5kZXgsIHNvbWVQcmVkaWNhdGUsIHRydWUsIG51bGwpO1xuICAgICAgICBjcmVhdGVTdGF0ZW1lbnRzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycy5jb250ZW50UXVlcnkpXG4gICAgICAgICAgICAuY2FsbEZuKFt2YXJpYWJsZSgnZGlySW5kZXgnKSwgLi4ucHJlcGFyZVF1ZXJ5UGFyYW1zKHF1ZXJ5LCBjb25zdGFudFBvb2wpXSlcbiAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgIC8vIHVwZGF0ZSwgZS5nLiAocjMucXVlcnlSZWZyZXNoKHRtcCA9IHIzLmxvYWRRdWVyeSgpKSAmJiAoY3R4LnNvbWVEaXIgPSB0bXApKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5ID0gdGVtcEFsbG9jYXRvcigpO1xuICAgICAgICBjb25zdCBnZXRRdWVyeUxpc3QgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmxvYWRRdWVyeSkuY2FsbEZuKFtdKTtcbiAgICAgICAgY29uc3QgcmVmcmVzaCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucXVlcnlSZWZyZXNoKS5jYWxsRm4oW3RlbXBvcmFyeS5zZXQoZ2V0UXVlcnlMaXN0KV0pO1xuICAgICAgICBjb25zdCB1cGRhdGVEaXJlY3RpdmUgPSB2YXJpYWJsZShDT05URVhUX05BTUUpXG4gICAgICAgICAgICAucHJvcChxdWVyeS5wcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAuc2V0KHF1ZXJ5LmZpcnN0ID8gdGVtcG9yYXJ5LnByb3AoJ2ZpcnN0JykgOiB0ZW1wb3JhcnkpO1xuICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2gocmVmcmVzaC5hbmQodXBkYXRlRGlyZWN0aXZlKS50b1N0bXQoKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRRdWVyaWVzRm5OYW1lID0gbmFtZSA/IGAke25hbWV9X0NvbnRlbnRRdWVyaWVzYCA6IG51bGw7XG4gICAgcmV0dXJuIGZuKFtcbiAgICAgICAgbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCksXG4gICAgICAgIG5ldyBGblBhcmFtKCdkaXJJbmRleCcsIG51bGwpXG4gICAgXSwgW1xuICAgICAgICByZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBjb3JlLlJlbmRlckZsYWdzLkNyZWF0ZSAqLywgY3JlYXRlU3RhdGVtZW50cyksXG4gICAgICAgIHJlbmRlckZsYWdDaGVja0lmU3RtdCgyIC8qIGNvcmUuUmVuZGVyRmxhZ3MuVXBkYXRlICovLCB1cGRhdGVTdGF0ZW1lbnRzKVxuICAgIF0sIElORkVSUkVEX1RZUEUsIG51bGwsIGNvbnRlbnRRdWVyaWVzRm5OYW1lKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0FzVHlwZShzdHIpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUobGl0ZXJhbChzdHIpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ01hcEFzVHlwZShtYXApIHtcbiAgICBjb25zdCBtYXBWYWx1ZXMgPSBPYmplY3Qua2V5cyhtYXApLm1hcChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEFycmF5LmlzQXJyYXkobWFwW2tleV0pID8gbWFwW2tleV1bMF0gOiBtYXBba2V5XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsKHZhbHVlKSxcbiAgICAgICAgICAgIHF1b3RlZDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUobGl0ZXJhbE1hcChtYXBWYWx1ZXMpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0FycmF5QXNUeXBlKGFycikge1xuICAgIHJldHVybiBhcnIubGVuZ3RoID4gMCA/IGV4cHJlc3Npb25UeXBlKGxpdGVyYWxBcnIoYXJyLm1hcCh2YWx1ZSA9PiBsaXRlcmFsKHZhbHVlKSkpKSA6XG4gICAgICAgIE5PTkVfVFlQRTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEaXJlY3RpdmVUeXBlUGFyYW1zKG1ldGEpIHtcbiAgICAvLyBPbiB0aGUgdHlwZSBzaWRlLCByZW1vdmUgbmV3bGluZXMgZnJvbSB0aGUgc2VsZWN0b3IgYXMgaXQgd2lsbCBuZWVkIHRvIGZpdCBpbnRvIGEgVHlwZVNjcmlwdFxuICAgIC8vIHN0cmluZyBsaXRlcmFsLCB3aGljaCBtdXN0IGJlIG9uIG9uZSBsaW5lLlxuICAgIGNvbnN0IHNlbGVjdG9yRm9yVHlwZSA9IG1ldGEuc2VsZWN0b3IgIT09IG51bGwgPyBtZXRhLnNlbGVjdG9yLnJlcGxhY2UoL1xcbi9nLCAnJykgOiBudWxsO1xuICAgIHJldHVybiBbXG4gICAgICAgIHR5cGVXaXRoUGFyYW1ldGVycyhtZXRhLnR5cGUudHlwZSwgbWV0YS50eXBlQXJndW1lbnRDb3VudCksXG4gICAgICAgIHNlbGVjdG9yRm9yVHlwZSAhPT0gbnVsbCA/IHN0cmluZ0FzVHlwZShzZWxlY3RvckZvclR5cGUpIDogTk9ORV9UWVBFLFxuICAgICAgICBtZXRhLmV4cG9ydEFzICE9PSBudWxsID8gc3RyaW5nQXJyYXlBc1R5cGUobWV0YS5leHBvcnRBcykgOiBOT05FX1RZUEUsXG4gICAgICAgIHN0cmluZ01hcEFzVHlwZShtZXRhLmlucHV0cyksXG4gICAgICAgIHN0cmluZ01hcEFzVHlwZShtZXRhLm91dHB1dHMpLFxuICAgICAgICBzdHJpbmdBcnJheUFzVHlwZShtZXRhLnF1ZXJpZXMubWFwKHEgPT4gcS5wcm9wZXJ0eU5hbWUpKSxcbiAgICBdO1xufVxuLyoqXG4gKiBDcmVhdGVzIHRoZSB0eXBlIHNwZWNpZmljYXRpb24gZnJvbSB0aGUgZGlyZWN0aXZlIG1ldGEuIFRoaXMgdHlwZSBpcyBpbnNlcnRlZCBpbnRvIC5kLnRzIGZpbGVzXG4gKiB0byBiZSBjb25zdW1lZCBieSB1cHN0cmVhbSBjb21waWxhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpcmVjdGl2ZVR5cGUobWV0YSkge1xuICAgIGNvbnN0IHR5cGVQYXJhbXMgPSBjcmVhdGVCYXNlRGlyZWN0aXZlVHlwZVBhcmFtcyhtZXRhKTtcbiAgICAvLyBEaXJlY3RpdmVzIGhhdmUgbm8gTmdDb250ZW50U2VsZWN0b3JzIHNsb3QsIGJ1dCBpbnN0ZWFkIGV4cHJlc3MgYSBgbmV2ZXJgIHR5cGVcbiAgICAvLyBzbyB0aGF0IGZ1dHVyZSBmaWVsZHMgYWxpZ24uXG4gICAgdHlwZVBhcmFtcy5wdXNoKE5PTkVfVFlQRSk7XG4gICAgdHlwZVBhcmFtcy5wdXNoKGV4cHJlc3Npb25UeXBlKGxpdGVyYWwobWV0YS5pc1N0YW5kYWxvbmUpKSk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuRGlyZWN0aXZlRGVjbGFyYXRpb24sIHR5cGVQYXJhbXMpKTtcbn1cbi8vIERlZmluZSBhbmQgdXBkYXRlIGFueSB2aWV3IHF1ZXJpZXNcbmZ1bmN0aW9uIGNyZWF0ZVZpZXdRdWVyaWVzRnVuY3Rpb24odmlld1F1ZXJpZXMsIGNvbnN0YW50UG9vbCwgbmFtZSkge1xuICAgIGNvbnN0IGNyZWF0ZVN0YXRlbWVudHMgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgY29uc3QgdGVtcEFsbG9jYXRvciA9IHRlbXBvcmFyeUFsbG9jYXRvcih1cGRhdGVTdGF0ZW1lbnRzLCBURU1QT1JBUllfTkFNRSk7XG4gICAgdmlld1F1ZXJpZXMuZm9yRWFjaCgocXVlcnkpID0+IHtcbiAgICAgICAgLy8gY3JlYXRpb24sIGUuZy4gcjMudmlld1F1ZXJ5KHNvbWVQcmVkaWNhdGUsIHRydWUpO1xuICAgICAgICBjb25zdCBxdWVyeURlZmluaXRpb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLnZpZXdRdWVyeSkuY2FsbEZuKHByZXBhcmVRdWVyeVBhcmFtcyhxdWVyeSwgY29uc3RhbnRQb29sKSk7XG4gICAgICAgIGNyZWF0ZVN0YXRlbWVudHMucHVzaChxdWVyeURlZmluaXRpb24udG9TdG10KCkpO1xuICAgICAgICAvLyB1cGRhdGUsIGUuZy4gKHIzLnF1ZXJ5UmVmcmVzaCh0bXAgPSByMy5sb2FkUXVlcnkoKSkgJiYgKGN0eC5zb21lRGlyID0gdG1wKSk7XG4gICAgICAgIGNvbnN0IHRlbXBvcmFyeSA9IHRlbXBBbGxvY2F0b3IoKTtcbiAgICAgICAgY29uc3QgZ2V0UXVlcnlMaXN0ID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5sb2FkUXVlcnkpLmNhbGxGbihbXSk7XG4gICAgICAgIGNvbnN0IHJlZnJlc2ggPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLnF1ZXJ5UmVmcmVzaCkuY2FsbEZuKFt0ZW1wb3Jhcnkuc2V0KGdldFF1ZXJ5TGlzdCldKTtcbiAgICAgICAgY29uc3QgdXBkYXRlRGlyZWN0aXZlID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FKVxuICAgICAgICAgICAgLnByb3AocXVlcnkucHJvcGVydHlOYW1lKVxuICAgICAgICAgICAgLnNldChxdWVyeS5maXJzdCA/IHRlbXBvcmFyeS5wcm9wKCdmaXJzdCcpIDogdGVtcG9yYXJ5KTtcbiAgICAgICAgdXBkYXRlU3RhdGVtZW50cy5wdXNoKHJlZnJlc2guYW5kKHVwZGF0ZURpcmVjdGl2ZSkudG9TdG10KCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IHZpZXdRdWVyeUZuTmFtZSA9IG5hbWUgPyBgJHtuYW1lfV9RdWVyeWAgOiBudWxsO1xuICAgIHJldHVybiBmbihbbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCldLCBbXG4gICAgICAgIHJlbmRlckZsYWdDaGVja0lmU3RtdCgxIC8qIGNvcmUuUmVuZGVyRmxhZ3MuQ3JlYXRlICovLCBjcmVhdGVTdGF0ZW1lbnRzKSxcbiAgICAgICAgcmVuZGVyRmxhZ0NoZWNrSWZTdG10KDIgLyogY29yZS5SZW5kZXJGbGFncy5VcGRhdGUgKi8sIHVwZGF0ZVN0YXRlbWVudHMpXG4gICAgXSwgSU5GRVJSRURfVFlQRSwgbnVsbCwgdmlld1F1ZXJ5Rm5OYW1lKTtcbn1cbi8vIFJldHVybiBhIGhvc3QgYmluZGluZyBmdW5jdGlvbiBvciBudWxsIGlmIG9uZSBpcyBub3QgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gY3JlYXRlSG9zdEJpbmRpbmdzRnVuY3Rpb24oaG9zdEJpbmRpbmdzTWV0YWRhdGEsIHR5cGVTb3VyY2VTcGFuLCBiaW5kaW5nUGFyc2VyLCBjb25zdGFudFBvb2wsIHNlbGVjdG9yLCBuYW1lLCBkZWZpbml0aW9uTWFwKSB7XG4gICAgY29uc3QgYmluZGluZ0NvbnRleHQgPSB2YXJpYWJsZShDT05URVhUX05BTUUpO1xuICAgIGNvbnN0IHN0eWxlQnVpbGRlciA9IG5ldyBTdHlsaW5nQnVpbGRlcihiaW5kaW5nQ29udGV4dCk7XG4gICAgY29uc3QgeyBzdHlsZUF0dHIsIGNsYXNzQXR0ciB9ID0gaG9zdEJpbmRpbmdzTWV0YWRhdGEuc3BlY2lhbEF0dHJpYnV0ZXM7XG4gICAgaWYgKHN0eWxlQXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0eWxlQnVpbGRlci5yZWdpc3RlclN0eWxlQXR0cihzdHlsZUF0dHIpO1xuICAgIH1cbiAgICBpZiAoY2xhc3NBdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3R5bGVCdWlsZGVyLnJlZ2lzdGVyQ2xhc3NBdHRyKGNsYXNzQXR0cik7XG4gICAgfVxuICAgIGNvbnN0IGNyZWF0ZUluc3RydWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZUluc3RydWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHVwZGF0ZVZhcmlhYmxlcyA9IFtdO1xuICAgIGNvbnN0IGhvc3RCaW5kaW5nU291cmNlU3BhbiA9IHR5cGVTb3VyY2VTcGFuO1xuICAgIC8vIENhbGN1bGF0ZSBob3N0IGV2ZW50IGJpbmRpbmdzXG4gICAgY29uc3QgZXZlbnRCaW5kaW5ncyA9IGJpbmRpbmdQYXJzZXIuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyhob3N0QmluZGluZ3NNZXRhZGF0YS5saXN0ZW5lcnMsIGhvc3RCaW5kaW5nU291cmNlU3Bhbik7XG4gICAgaWYgKGV2ZW50QmluZGluZ3MgJiYgZXZlbnRCaW5kaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgY3JlYXRlSW5zdHJ1Y3Rpb25zLnB1c2goLi4uY3JlYXRlSG9zdExpc3RlbmVycyhldmVudEJpbmRpbmdzLCBuYW1lKSk7XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSB0aGUgaG9zdCBwcm9wZXJ0eSBiaW5kaW5nc1xuICAgIGNvbnN0IGJpbmRpbmdzID0gYmluZGluZ1BhcnNlci5jcmVhdGVCb3VuZEhvc3RQcm9wZXJ0aWVzKGhvc3RCaW5kaW5nc01ldGFkYXRhLnByb3BlcnRpZXMsIGhvc3RCaW5kaW5nU291cmNlU3Bhbik7XG4gICAgY29uc3QgYWxsT3RoZXJCaW5kaW5ncyA9IFtdO1xuICAgIC8vIFdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSB0b3RhbCBhbW91bnQgb2YgYmluZGluZyBzbG90cyByZXF1aXJlZCBieVxuICAgIC8vIGFsbCB0aGUgaW5zdHJ1Y3Rpb25zIHRvZ2V0aGVyIGJlZm9yZSBhbnkgdmFsdWUgY29udmVyc2lvbnMgaGFwcGVuLlxuICAgIC8vIFZhbHVlIGNvbnZlcnNpb25zIG1heSByZXF1aXJlIGFkZGl0aW9uYWwgc2xvdHMgZm9yIGludGVycG9sYXRpb24gYW5kXG4gICAgLy8gYmluZGluZ3Mgd2l0aCBwaXBlcy4gVGhlc2UgY2FsY3VsYXRlcyBoYXBwZW4gYWZ0ZXIgdGhpcyBibG9jay5cbiAgICBsZXQgdG90YWxIb3N0VmFyc0NvdW50ID0gMDtcbiAgICBiaW5kaW5ncyAmJiBiaW5kaW5ncy5mb3JFYWNoKChiaW5kaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0eWxpbmdJbnB1dFdhc1NldCA9IHN0eWxlQnVpbGRlci5yZWdpc3RlcklucHV0QmFzZWRPbk5hbWUoYmluZGluZy5uYW1lLCBiaW5kaW5nLmV4cHJlc3Npb24sIGhvc3RCaW5kaW5nU291cmNlU3Bhbik7XG4gICAgICAgIGlmIChzdHlsaW5nSW5wdXRXYXNTZXQpIHtcbiAgICAgICAgICAgIHRvdGFsSG9zdFZhcnNDb3VudCArPSBNSU5fU1RZTElOR19CSU5ESU5HX1NMT1RTX1JFUVVJUkVEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxsT3RoZXJCaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuICAgICAgICAgICAgdG90YWxIb3N0VmFyc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgdmFsdWVDb252ZXJ0ZXI7XG4gICAgY29uc3QgZ2V0VmFsdWVDb252ZXJ0ZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGhvc3RWYXJzQ291bnRGbiA9IChudW1TbG90cykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVmFyc0NvdW50ID0gdG90YWxIb3N0VmFyc0NvdW50O1xuICAgICAgICAgICAgICAgIHRvdGFsSG9zdFZhcnNDb3VudCArPSBudW1TbG90cztcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxWYXJzQ291bnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWVDb252ZXJ0ZXIgPSBuZXcgVmFsdWVDb252ZXJ0ZXIoY29uc3RhbnRQb29sLCAoKSA9PiBlcnJvcignVW5leHBlY3RlZCBub2RlJyksIC8vIG5ldyBub2RlcyBhcmUgaWxsZWdhbCBoZXJlXG4gICAgICAgICAgICBob3N0VmFyc0NvdW50Rm4sICgpID0+IGVycm9yKCdVbmV4cGVjdGVkIHBpcGUnKSk7IC8vIHBpcGVzIGFyZSBpbGxlZ2FsIGhlcmVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVDb252ZXJ0ZXI7XG4gICAgfTtcbiAgICBjb25zdCBwcm9wZXJ0eUJpbmRpbmdzID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlQmluZGluZ3MgPSBbXTtcbiAgICBjb25zdCBzeW50aGV0aWNIb3N0QmluZGluZ3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgYWxsT3RoZXJCaW5kaW5ncykge1xuICAgICAgICAvLyByZXNvbHZlIGxpdGVyYWwgYXJyYXlzIGFuZCBsaXRlcmFsIG9iamVjdHNcbiAgICAgICAgY29uc3QgdmFsdWUgPSBiaW5kaW5nLmV4cHJlc3Npb24udmlzaXQoZ2V0VmFsdWVDb252ZXJ0ZXIoKSk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdFeHByID0gYmluZGluZ0ZuKGJpbmRpbmdDb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHsgYmluZGluZ05hbWUsIGluc3RydWN0aW9uLCBpc0F0dHJpYnV0ZSB9ID0gZ2V0QmluZGluZ05hbWVBbmRJbnN0cnVjdGlvbihiaW5kaW5nKTtcbiAgICAgICAgY29uc3Qgc2VjdXJpdHlDb250ZXh0cyA9IGJpbmRpbmdQYXJzZXIuY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyhzZWxlY3RvciwgYmluZGluZ05hbWUsIGlzQXR0cmlidXRlKVxuICAgICAgICAgICAgLmZpbHRlcihjb250ZXh0ID0+IGNvbnRleHQgIT09IFNlY3VyaXR5Q29udGV4dC5OT05FKTtcbiAgICAgICAgbGV0IHNhbml0aXplckZuID0gbnVsbDtcbiAgICAgICAgaWYgKHNlY3VyaXR5Q29udGV4dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2VjdXJpdHlDb250ZXh0cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzLmluZGV4T2YoU2VjdXJpdHlDb250ZXh0LlVSTCkgPiAtMSAmJlxuICAgICAgICAgICAgICAgIHNlY3VyaXR5Q29udGV4dHMuaW5kZXhPZihTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBzb21lIFVSTCBhdHRyaWJ1dGVzIChzdWNoIGFzIFwic3JjXCIgYW5kIFwiaHJlZlwiKSB0aGF0IG1heSBiZSBhIHBhcnRcbiAgICAgICAgICAgICAgICAvLyBvZiBkaWZmZXJlbnQgc2VjdXJpdHkgY29udGV4dHMuIEluIHRoaXMgY2FzZSB3ZSB1c2Ugc3BlY2lhbCBzYW5pdGl6YXRpb24gZnVuY3Rpb24gYW5kXG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0IHRoZSBhY3R1YWwgc2FuaXRpemVyIGF0IHJ1bnRpbWUgYmFzZWQgb24gYSB0YWcgbmFtZSB0aGF0IGlzIHByb3ZpZGVkIHdoaWxlXG4gICAgICAgICAgICAgICAgLy8gaW52b2tpbmcgc2FuaXRpemF0aW9uIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIHNhbml0aXplckZuID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5zYW5pdGl6ZVVybE9yUmVzb3VyY2VVcmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2FuaXRpemVyRm4gPSByZXNvbHZlU2FuaXRpemF0aW9uRm4oc2VjdXJpdHlDb250ZXh0c1swXSwgaXNBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9uUGFyYW1zID0gW2xpdGVyYWwoYmluZGluZ05hbWUpLCBiaW5kaW5nRXhwci5jdXJyVmFsRXhwcl07XG4gICAgICAgIGlmIChzYW5pdGl6ZXJGbikge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25QYXJhbXMucHVzaChzYW5pdGl6ZXJGbik7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlVmFyaWFibGVzLnB1c2goLi4uYmluZGluZ0V4cHIuc3RtdHMpO1xuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24gPT09IElkZW50aWZpZXJzLmhvc3RQcm9wZXJ0eSkge1xuICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5ncy5wdXNoKGluc3RydWN0aW9uUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbiA9PT0gSWRlbnRpZmllcnMuYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVCaW5kaW5ncy5wdXNoKGluc3RydWN0aW9uUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnN0cnVjdGlvbiA9PT0gSWRlbnRpZmllcnMuc3ludGhldGljSG9zdFByb3BlcnR5KSB7XG4gICAgICAgICAgICBzeW50aGV0aWNIb3N0QmluZGluZ3MucHVzaChpbnN0cnVjdGlvblBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVJbnN0cnVjdGlvbnMucHVzaCh7IHJlZmVyZW5jZTogaW5zdHJ1Y3Rpb24sIHBhcmFtc09yRm46IGluc3RydWN0aW9uUGFyYW1zLCBzcGFuOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgYmluZGluZ1BhcmFtcyBvZiBwcm9wZXJ0eUJpbmRpbmdzKSB7XG4gICAgICAgIHVwZGF0ZUluc3RydWN0aW9ucy5wdXNoKHsgcmVmZXJlbmNlOiBJZGVudGlmaWVycy5ob3N0UHJvcGVydHksIHBhcmFtc09yRm46IGJpbmRpbmdQYXJhbXMsIHNwYW46IG51bGwgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYmluZGluZ1BhcmFtcyBvZiBhdHRyaWJ1dGVCaW5kaW5ncykge1xuICAgICAgICB1cGRhdGVJbnN0cnVjdGlvbnMucHVzaCh7IHJlZmVyZW5jZTogSWRlbnRpZmllcnMuYXR0cmlidXRlLCBwYXJhbXNPckZuOiBiaW5kaW5nUGFyYW1zLCBzcGFuOiBudWxsIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGJpbmRpbmdQYXJhbXMgb2Ygc3ludGhldGljSG9zdEJpbmRpbmdzKSB7XG4gICAgICAgIHVwZGF0ZUluc3RydWN0aW9ucy5wdXNoKHsgcmVmZXJlbmNlOiBJZGVudGlmaWVycy5zeW50aGV0aWNIb3N0UHJvcGVydHksIHBhcmFtc09yRm46IGJpbmRpbmdQYXJhbXMsIHNwYW46IG51bGwgfSk7XG4gICAgfVxuICAgIC8vIHNpbmNlIHdlJ3JlIGRlYWxpbmcgd2l0aCBkaXJlY3RpdmVzL2NvbXBvbmVudHMgYW5kIGJvdGggaGF2ZSBob3N0QmluZGluZ1xuICAgIC8vIGZ1bmN0aW9ucywgd2UgbmVlZCB0byBnZW5lcmF0ZSBhIHNwZWNpYWwgaG9zdEF0dHJzIGluc3RydWN0aW9uIHRoYXQgZGVhbHNcbiAgICAvLyB3aXRoIGJvdGggdGhlIGFzc2lnbm1lbnQgb2Ygc3R5bGluZyBhcyB3ZWxsIGFzIHN0YXRpYyBhdHRyaWJ1dGVzIHRvIHRoZSBob3N0XG4gICAgLy8gZWxlbWVudC4gVGhlIGluc3RydWN0aW9uIGJlbG93IHdpbGwgaW5zdHJ1Y3QgYWxsIGluaXRpYWwgc3R5bGluZyAoc3R5bGluZ1xuICAgIC8vIHRoYXQgaXMgaW5zaWRlIG9mIGEgaG9zdCBiaW5kaW5nIHdpdGhpbiBhIGRpcmVjdGl2ZS9jb21wb25lbnQpIHRvIGJlIGF0dGFjaGVkXG4gICAgLy8gdG8gdGhlIGhvc3QgZWxlbWVudCBhbG9uZ3NpZGUgYW55IG9mIHRoZSBwcm92aWRlZCBob3N0IGF0dHJpYnV0ZXMgdGhhdCB3ZXJlXG4gICAgLy8gY29sbGVjdGVkIGVhcmxpZXIuXG4gICAgY29uc3QgaG9zdEF0dHJzID0gY29udmVydEF0dHJpYnV0ZXNUb0V4cHJlc3Npb25zKGhvc3RCaW5kaW5nc01ldGFkYXRhLmF0dHJpYnV0ZXMpO1xuICAgIHN0eWxlQnVpbGRlci5hc3NpZ25Ib3N0QXR0cnMoaG9zdEF0dHJzLCBkZWZpbml0aW9uTWFwKTtcbiAgICBpZiAoc3R5bGVCdWlsZGVyLmhhc0JpbmRpbmdzKSB7XG4gICAgICAgIC8vIGZpbmFsbHkgZWFjaCBiaW5kaW5nIHRoYXQgd2FzIHJlZ2lzdGVyZWQgaW4gdGhlIHN0YXRlbWVudCBhYm92ZSB3aWxsIG5lZWQgdG8gYmUgYWRkZWQgdG9cbiAgICAgICAgLy8gdGhlIHVwZGF0ZSBibG9jayBvZiBhIGNvbXBvbmVudC9kaXJlY3RpdmUgdGVtcGxhdGVGbi9ob3N0QmluZGluZ3NGbiBzbyB0aGF0IHRoZSBiaW5kaW5nc1xuICAgICAgICAvLyBhcmUgZXZhbHVhdGVkIGFuZCB1cGRhdGVkIGZvciB0aGUgZWxlbWVudC5cbiAgICAgICAgc3R5bGVCdWlsZGVyLmJ1aWxkVXBkYXRlTGV2ZWxJbnN0cnVjdGlvbnMoZ2V0VmFsdWVDb252ZXJ0ZXIoKSkuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgaW5zdHJ1Y3Rpb24uY2FsbHMpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBzdWJ0cmFjdCBhIHZhbHVlIG9mIGAxYCBoZXJlIGJlY2F1c2UgdGhlIGJpbmRpbmcgc2xvdCB3YXMgYWxyZWFkeSBhbGxvY2F0ZWRcbiAgICAgICAgICAgICAgICAvLyBhdCB0aGUgdG9wIG9mIHRoaXMgbWV0aG9kIHdoZW4gYWxsIHRoZSBpbnB1dCBiaW5kaW5ncyB3ZXJlIGNvdW50ZWQuXG4gICAgICAgICAgICAgICAgdG90YWxIb3N0VmFyc0NvdW50ICs9XG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGNhbGwuYWxsb2NhdGVCaW5kaW5nU2xvdHMgLSBNSU5fU1RZTElOR19CSU5ESU5HX1NMT1RTX1JFUVVJUkVELCAwKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVJbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogaW5zdHJ1Y3Rpb24ucmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNPckZuOiBjb252ZXJ0U3R5bGluZ0NhbGwoY2FsbCwgYmluZGluZ0NvbnRleHQsIGJpbmRpbmdGbiksXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0b3RhbEhvc3RWYXJzQ291bnQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2hvc3RWYXJzJywgbGl0ZXJhbCh0b3RhbEhvc3RWYXJzQ291bnQpKTtcbiAgICB9XG4gICAgaWYgKGNyZWF0ZUluc3RydWN0aW9ucy5sZW5ndGggPiAwIHx8IHVwZGF0ZUluc3RydWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGhvc3RCaW5kaW5nc0ZuTmFtZSA9IG5hbWUgPyBgJHtuYW1lfV9Ib3N0QmluZGluZ3NgIDogbnVsbDtcbiAgICAgICAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICBpZiAoY3JlYXRlSW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChyZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBjb3JlLlJlbmRlckZsYWdzLkNyZWF0ZSAqLywgZ2V0SW5zdHJ1Y3Rpb25TdGF0ZW1lbnRzKGNyZWF0ZUluc3RydWN0aW9ucykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlSW5zdHJ1Y3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChyZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMiAvKiBjb3JlLlJlbmRlckZsYWdzLlVwZGF0ZSAqLywgdXBkYXRlVmFyaWFibGVzLmNvbmNhdChnZXRJbnN0cnVjdGlvblN0YXRlbWVudHModXBkYXRlSW5zdHJ1Y3Rpb25zKSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4oW25ldyBGblBhcmFtKFJFTkRFUl9GTEFHUywgTlVNQkVSX1RZUEUpLCBuZXcgRm5QYXJhbShDT05URVhUX05BTUUsIG51bGwpXSwgc3RhdGVtZW50cywgSU5GRVJSRURfVFlQRSwgbnVsbCwgaG9zdEJpbmRpbmdzRm5OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBiaW5kaW5nRm4oaW1wbGljaXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcobnVsbCwgaW1wbGljaXQsIHZhbHVlLCAnYicpO1xufVxuZnVuY3Rpb24gY29udmVydFN0eWxpbmdDYWxsKGNhbGwsIGJpbmRpbmdDb250ZXh0LCBiaW5kaW5nRm4pIHtcbiAgICByZXR1cm4gY2FsbC5wYXJhbXModmFsdWUgPT4gYmluZGluZ0ZuKGJpbmRpbmdDb250ZXh0LCB2YWx1ZSkuY3VyclZhbEV4cHIpO1xufVxuZnVuY3Rpb24gZ2V0QmluZGluZ05hbWVBbmRJbnN0cnVjdGlvbihiaW5kaW5nKSB7XG4gICAgbGV0IGJpbmRpbmdOYW1lID0gYmluZGluZy5uYW1lO1xuICAgIGxldCBpbnN0cnVjdGlvbjtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhbiBhdHRyIGJpbmRpbmcgb3IgYSBwcm9wZXJ0eSBiaW5kaW5nXG4gICAgY29uc3QgYXR0ck1hdGNoZXMgPSBiaW5kaW5nTmFtZS5tYXRjaChBVFRSX1JFR0VYKTtcbiAgICBpZiAoYXR0ck1hdGNoZXMpIHtcbiAgICAgICAgYmluZGluZ05hbWUgPSBhdHRyTWF0Y2hlc1sxXTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24gPSBJZGVudGlmaWVycy5hdHRyaWJ1dGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoYmluZGluZy5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgYmluZGluZ05hbWUgPSBwcmVwYXJlU3ludGhldGljUHJvcGVydHlOYW1lKGJpbmRpbmdOYW1lKTtcbiAgICAgICAgICAgIC8vIGhvc3QgYmluZGluZ3MgdGhhdCBoYXZlIGEgc3ludGhldGljIHByb3BlcnR5IChlLmcuIEBmb28pIHNob3VsZCBhbHdheXMgYmUgcmVuZGVyZWRcbiAgICAgICAgICAgIC8vIGluIHRoZSBjb250ZXh0IG9mIHRoZSBjb21wb25lbnQgYW5kIG5vdCB0aGUgcGFyZW50LiBUaGVyZWZvcmUgdGhlcmUgaXMgYSBzcGVjaWFsXG4gICAgICAgICAgICAvLyBjb21wYXRpYmlsaXR5IGluc3RydWN0aW9uIGF2YWlsYWJsZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBJZGVudGlmaWVycy5zeW50aGV0aWNIb3N0UHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbiA9IElkZW50aWZpZXJzLmhvc3RQcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiaW5kaW5nTmFtZSwgaW5zdHJ1Y3Rpb24sIGlzQXR0cmlidXRlOiAhIWF0dHJNYXRjaGVzIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIb3N0TGlzdGVuZXJzKGV2ZW50QmluZGluZ3MsIG5hbWUpIHtcbiAgICBjb25zdCBsaXN0ZW5lclBhcmFtcyA9IFtdO1xuICAgIGNvbnN0IHN5bnRoZXRpY0xpc3RlbmVyUGFyYW1zID0gW107XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGV2ZW50QmluZGluZ3MpIHtcbiAgICAgICAgbGV0IGJpbmRpbmdOYW1lID0gYmluZGluZy5uYW1lICYmIHNhbml0aXplSWRlbnRpZmllcihiaW5kaW5nLm5hbWUpO1xuICAgICAgICBjb25zdCBiaW5kaW5nRm5OYW1lID0gYmluZGluZy50eXBlID09PSAxIC8qIFBhcnNlZEV2ZW50VHlwZS5BbmltYXRpb24gKi8gP1xuICAgICAgICAgICAgcHJlcGFyZVN5bnRoZXRpY0xpc3RlbmVyRnVuY3Rpb25OYW1lKGJpbmRpbmdOYW1lLCBiaW5kaW5nLnRhcmdldE9yUGhhc2UpIDpcbiAgICAgICAgICAgIGJpbmRpbmdOYW1lO1xuICAgICAgICBjb25zdCBoYW5kbGVyTmFtZSA9IG5hbWUgJiYgYmluZGluZ05hbWUgPyBgJHtuYW1lfV8ke2JpbmRpbmdGbk5hbWV9X0hvc3RCaW5kaW5nSGFuZGxlcmAgOiBudWxsO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBwcmVwYXJlRXZlbnRMaXN0ZW5lclBhcmFtZXRlcnMoQm91bmRFdmVudC5mcm9tUGFyc2VkRXZlbnQoYmluZGluZyksIGhhbmRsZXJOYW1lKTtcbiAgICAgICAgaWYgKGJpbmRpbmcudHlwZSA9PSAxIC8qIFBhcnNlZEV2ZW50VHlwZS5BbmltYXRpb24gKi8pIHtcbiAgICAgICAgICAgIHN5bnRoZXRpY0xpc3RlbmVyUGFyYW1zLnB1c2gocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVyUGFyYW1zLnB1c2gocGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcmFtcyBvZiBzeW50aGV0aWNMaXN0ZW5lclBhcmFtcykge1xuICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCh7IHJlZmVyZW5jZTogSWRlbnRpZmllcnMuc3ludGhldGljSG9zdExpc3RlbmVyLCBwYXJhbXNPckZuOiBwYXJhbXMsIHNwYW46IG51bGwgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGFyYW1zIG9mIGxpc3RlbmVyUGFyYW1zKSB7XG4gICAgICAgIGluc3RydWN0aW9ucy5wdXNoKHsgcmVmZXJlbmNlOiBJZGVudGlmaWVycy5saXN0ZW5lciwgcGFyYW1zT3JGbjogcGFyYW1zLCBzcGFuOiBudWxsIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xufVxuY29uc3QgSE9TVF9SRUdfRVhQID0gL14oPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkkLztcbmZ1bmN0aW9uIHBhcnNlSG9zdEJpbmRpbmdzKGhvc3QpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgY29uc3QgbGlzdGVuZXJzID0ge307XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHt9O1xuICAgIGNvbnN0IHNwZWNpYWxBdHRyaWJ1dGVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaG9zdCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBob3N0W2tleV07XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBrZXkubWF0Y2goSE9TVF9SRUdfRVhQKTtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBtYWtlIHRoaXMgYSBkaWFnbm9zdGljLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGFzcyBiaW5kaW5nIG11c3QgYmUgc3RyaW5nYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEF0dHJpYnV0ZXMuY2xhc3NBdHRyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0eWxlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGEgZGlhZ25vc3RpYy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3R5bGUgYmluZGluZyBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWxBdHRyaWJ1dGVzLnN0eWxlQXR0ciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gbGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoZXNbMSAvKiBIb3N0QmluZGluZ0dyb3VwLkJpbmRpbmcgKi9dICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbHhodWIpOiBtYWtlIHRoaXMgYSBkaWFnbm9zdGljLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgYmluZGluZyBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3ludGhldGljIHByb3BlcnRpZXMgKHRoZSBvbmVzIHRoYXQgaGF2ZSBhIGBAYCBhcyBhIHByZWZpeClcbiAgICAgICAgICAgIC8vIGFyZSBzdGlsbCB0cmVhdGVkIHRoZSBzYW1lIGFzIHJlZ3VsYXIgcHJvcGVydGllcy4gVGhlcmVmb3JlXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBwb2ludCBpbiBzdG9yaW5nIHRoZW0gaW4gYSBzZXBhcmF0ZSBtYXAuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzW21hdGNoZXNbMSAvKiBIb3N0QmluZGluZ0dyb3VwLkJpbmRpbmcgKi9dXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoZXNbMiAvKiBIb3N0QmluZGluZ0dyb3VwLkV2ZW50ICovXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGEgZGlhZ25vc3RpYy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50IGJpbmRpbmcgbXVzdCBiZSBzdHJpbmdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyc1ttYXRjaGVzWzIgLyogSG9zdEJpbmRpbmdHcm91cC5FdmVudCAqL11dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYXR0cmlidXRlcywgbGlzdGVuZXJzLCBwcm9wZXJ0aWVzLCBzcGVjaWFsQXR0cmlidXRlcyB9O1xufVxuLyoqXG4gKiBWZXJpZmllcyBob3N0IGJpbmRpbmdzIGFuZCByZXR1cm5zIHRoZSBsaXN0IG9mIGVycm9ycyAoaWYgYW55KS4gRW1wdHkgYXJyYXkgaW5kaWNhdGVzIHRoYXQgYVxuICogZ2l2ZW4gc2V0IG9mIGhvc3QgYmluZGluZ3MgaGFzIG5vIGVycm9ycy5cbiAqXG4gKiBAcGFyYW0gYmluZGluZ3Mgc2V0IG9mIGhvc3QgYmluZGluZ3MgdG8gdmVyaWZ5LlxuICogQHBhcmFtIHNvdXJjZVNwYW4gc291cmNlIHNwYW4gd2hlcmUgaG9zdCBiaW5kaW5ncyB3ZXJlIGRlZmluZWQuXG4gKiBAcmV0dXJucyBhcnJheSBvZiBlcnJvcnMgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gc2V0IG9mIGhvc3QgYmluZGluZ3MuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmeUhvc3RCaW5kaW5ncyhiaW5kaW5ncywgc291cmNlU3Bhbikge1xuICAgIC8vIFRPRE86IGFic3RyYWN0IG91dCBob3N0IGJpbmRpbmdzIHZlcmlmaWNhdGlvbiBsb2dpYyBhbmQgdXNlIGl0IGluc3RlYWQgb2ZcbiAgICAvLyBjcmVhdGluZyBldmVudHMgYW5kIHByb3BlcnRpZXMgQVNUcyB0byBkZXRlY3QgZXJyb3JzIChGVy05OTYpXG4gICAgY29uc3QgYmluZGluZ1BhcnNlciA9IG1ha2VCaW5kaW5nUGFyc2VyKCk7XG4gICAgYmluZGluZ1BhcnNlci5jcmVhdGVEaXJlY3RpdmVIb3N0RXZlbnRBc3RzKGJpbmRpbmdzLmxpc3RlbmVycywgc291cmNlU3Bhbik7XG4gICAgYmluZGluZ1BhcnNlci5jcmVhdGVCb3VuZEhvc3RQcm9wZXJ0aWVzKGJpbmRpbmdzLnByb3BlcnRpZXMsIHNvdXJjZVNwYW4pO1xuICAgIHJldHVybiBiaW5kaW5nUGFyc2VyLmVycm9ycztcbn1cbmZ1bmN0aW9uIGNvbXBpbGVTdHlsZXMoc3R5bGVzLCBzZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgY29uc3Qgc2hhZG93Q3NzID0gbmV3IFNoYWRvd0NzcygpO1xuICAgIHJldHVybiBzdHlsZXMubWFwKHN0eWxlID0+IHtcbiAgICAgICAgcmV0dXJuIHNoYWRvd0Nzcy5zaGltQ3NzVGV4dChzdHlsZSwgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBbiBpbnRlcmZhY2UgZm9yIHJldHJpZXZpbmcgZG9jdW1lbnRzIGJ5IFVSTCB0aGF0IHRoZSBjb21waWxlciB1c2VzIHRvXG4gKiBsb2FkIHRlbXBsYXRlcy5cbiAqXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IGNsYXNzLCByYXRoZXIgdGhhbiBhbiBpbnRlcmZhY2UsIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWRcbiAqIGFzIGluamVjdGlvbiB0b2tlbi5cbiAqL1xuY2xhc3MgUmVzb3VyY2VMb2FkZXIge1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIENvbXBpbGVyRmFjYWRlSW1wbCB7XG4gICAgY29uc3RydWN0b3Ioaml0RXZhbHVhdG9yID0gbmV3IEppdEV2YWx1YXRvcigpKSB7XG4gICAgICAgIHRoaXMuaml0RXZhbHVhdG9yID0gaml0RXZhbHVhdG9yO1xuICAgICAgICB0aGlzLkZhY3RvcnlUYXJnZXQgPSBleHBvcnRzLkZhY3RvcnlUYXJnZXQ7XG4gICAgICAgIHRoaXMuUmVzb3VyY2VMb2FkZXIgPSBSZXNvdXJjZUxvYWRlcjtcbiAgICAgICAgdGhpcy5lbGVtZW50U2NoZW1hUmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4gICAgfVxuICAgIGNvbXBpbGVQaXBlKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGZhY2FkZS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZShmYWNhZGUudHlwZSksXG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IDAsXG4gICAgICAgICAgICBkZXBzOiBudWxsLFxuICAgICAgICAgICAgcGlwZU5hbWU6IGZhY2FkZS5waXBlTmFtZSxcbiAgICAgICAgICAgIHB1cmU6IGZhY2FkZS5wdXJlLFxuICAgICAgICAgICAgaXNTdGFuZGFsb25lOiBmYWNhZGUuaXNTdGFuZGFsb25lLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSBjb21waWxlUGlwZUZyb21NZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIFtdKTtcbiAgICB9XG4gICAgY29tcGlsZVBpcGVEZWNsYXJhdGlvbihhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBkZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBtZXRhID0gY29udmVydERlY2xhcmVQaXBlRmFjYWRlVG9NZXRhZGF0YShkZWNsYXJhdGlvbik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvbXBpbGVQaXBlRnJvbU1ldGFkYXRhKG1ldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBbXSk7XG4gICAgfVxuICAgIGNvbXBpbGVJbmplY3RhYmxlKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgZXhwcmVzc2lvbiwgc3RhdGVtZW50cyB9ID0gY29tcGlsZUluamVjdGFibGUoe1xuICAgICAgICAgICAgbmFtZTogZmFjYWRlLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogZmFjYWRlLnR5cGVBcmd1bWVudENvdW50LFxuICAgICAgICAgICAgcHJvdmlkZWRJbjogY29tcHV0ZVByb3ZpZGVkSW4oZmFjYWRlLnByb3ZpZGVkSW4pLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihmYWNhZGUsICd1c2VDbGFzcycpLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogd3JhcEV4cHJlc3Npb24oZmFjYWRlLCAndXNlRmFjdG9yeScpLFxuICAgICAgICAgICAgdXNlVmFsdWU6IGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihmYWNhZGUsICd1c2VWYWx1ZScpLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihmYWNhZGUsICd1c2VFeGlzdGluZycpLFxuICAgICAgICAgICAgZGVwczogKF9hID0gZmFjYWRlLmRlcHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoY29udmVydFIzRGVwZW5kZW5jeU1ldGFkYXRhKSxcbiAgICAgICAgfSwgXG4gICAgICAgIC8qIHJlc29sdmVGb3J3YXJkUmVmcyAqLyB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihleHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBzdGF0ZW1lbnRzKTtcbiAgICB9XG4gICAgY29tcGlsZUluamVjdGFibGVEZWNsYXJhdGlvbihhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGV4cHJlc3Npb24sIHN0YXRlbWVudHMgfSA9IGNvbXBpbGVJbmplY3RhYmxlKHtcbiAgICAgICAgICAgIG5hbWU6IGZhY2FkZS50eXBlLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogMCxcbiAgICAgICAgICAgIHByb3ZpZGVkSW46IGNvbXB1dGVQcm92aWRlZEluKGZhY2FkZS5wcm92aWRlZEluKSxcbiAgICAgICAgICAgIHVzZUNsYXNzOiBjb252ZXJ0VG9Qcm92aWRlckV4cHJlc3Npb24oZmFjYWRlLCAndXNlQ2xhc3MnKSxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHdyYXBFeHByZXNzaW9uKGZhY2FkZSwgJ3VzZUZhY3RvcnknKSxcbiAgICAgICAgICAgIHVzZVZhbHVlOiBjb252ZXJ0VG9Qcm92aWRlckV4cHJlc3Npb24oZmFjYWRlLCAndXNlVmFsdWUnKSxcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBjb252ZXJ0VG9Qcm92aWRlckV4cHJlc3Npb24oZmFjYWRlLCAndXNlRXhpc3RpbmcnKSxcbiAgICAgICAgICAgIGRlcHM6IChfYSA9IGZhY2FkZS5kZXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKGNvbnZlcnRSM0RlY2xhcmVEZXBlbmRlbmN5TWV0YWRhdGEpLFxuICAgICAgICB9LCBcbiAgICAgICAgLyogcmVzb2x2ZUZvcndhcmRSZWZzICovIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKGV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIHN0YXRlbWVudHMpO1xuICAgIH1cbiAgICBjb21waWxlSW5qZWN0b3IoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiBmYWNhZGUubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUucHJvdmlkZXJzKSxcbiAgICAgICAgICAgIGltcG9ydHM6IGZhY2FkZS5pbXBvcnRzLm1hcChpID0+IG5ldyBXcmFwcGVkTm9kZUV4cHIoaSkpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSBjb21waWxlSW5qZWN0b3IobWV0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIFtdKTtcbiAgICB9XG4gICAgY29tcGlsZUluamVjdG9yRGVjbGFyYXRpb24oYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvbnZlcnREZWNsYXJlSW5qZWN0b3JGYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgY29uc3QgcmVzID0gY29tcGlsZUluamVjdG9yKG1ldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBbXSk7XG4gICAgfVxuICAgIGNvbXBpbGVOZ01vZHVsZShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGFkamFjZW50VHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICBib290c3RyYXA6IGZhY2FkZS5ib290c3RyYXAubWFwKHdyYXBSZWZlcmVuY2UpLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBmYWNhZGUuZGVjbGFyYXRpb25zLm1hcCh3cmFwUmVmZXJlbmNlKSxcbiAgICAgICAgICAgIGltcG9ydHM6IGZhY2FkZS5pbXBvcnRzLm1hcCh3cmFwUmVmZXJlbmNlKSxcbiAgICAgICAgICAgIGV4cG9ydHM6IGZhY2FkZS5leHBvcnRzLm1hcCh3cmFwUmVmZXJlbmNlKSxcbiAgICAgICAgICAgIHNlbGVjdG9yU2NvcGVNb2RlOiBleHBvcnRzLlIzU2VsZWN0b3JTY29wZU1vZGUuSW5saW5lLFxuICAgICAgICAgICAgY29udGFpbnNGb3J3YXJkRGVjbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2NoZW1hczogZmFjYWRlLnNjaGVtYXMgPyBmYWNhZGUuc2NoZW1hcy5tYXAod3JhcFJlZmVyZW5jZSkgOiBudWxsLFxuICAgICAgICAgICAgaWQ6IGZhY2FkZS5pZCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLmlkKSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvbXBpbGVOZ01vZHVsZShtZXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgW10pO1xuICAgIH1cbiAgICBjb21waWxlTmdNb2R1bGVEZWNsYXJhdGlvbihhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBkZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gY29tcGlsZU5nTW9kdWxlRGVjbGFyYXRpb25FeHByZXNzaW9uKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihleHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBbXSk7XG4gICAgfVxuICAgIGNvbXBpbGVEaXJlY3RpdmUoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBjb252ZXJ0RGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShmYWNhZGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlRGlyZWN0aXZlRnJvbU1ldGEoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgbWV0YSk7XG4gICAgfVxuICAgIGNvbXBpbGVEaXJlY3RpdmVEZWNsYXJhdGlvbihhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBkZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCB0eXBlU291cmNlU3BhbiA9IHRoaXMuY3JlYXRlUGFyc2VTb3VyY2VTcGFuKCdEaXJlY3RpdmUnLCBkZWNsYXJhdGlvbi50eXBlLm5hbWUsIHNvdXJjZU1hcFVybCk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBjb252ZXJ0RGVjbGFyZURpcmVjdGl2ZUZhY2FkZVRvTWV0YWRhdGEoZGVjbGFyYXRpb24sIHR5cGVTb3VyY2VTcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZURpcmVjdGl2ZUZyb21NZXRhKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIG1ldGEpO1xuICAgIH1cbiAgICBjb21waWxlRGlyZWN0aXZlRnJvbU1ldGEoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgbWV0YSkge1xuICAgICAgICBjb25zdCBjb25zdGFudFBvb2wgPSBuZXcgQ29uc3RhbnRQb29sKCk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdQYXJzZXIgPSBtYWtlQmluZGluZ1BhcnNlcigpO1xuICAgICAgICBjb25zdCByZXMgPSBjb21waWxlRGlyZWN0aXZlRnJvbU1ldGFkYXRhKG1ldGEsIGNvbnN0YW50UG9vbCwgYmluZGluZ1BhcnNlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGNvbnN0YW50UG9vbC5zdGF0ZW1lbnRzKTtcbiAgICB9XG4gICAgY29tcGlsZUNvbXBvbmVudChhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgLy8gUGFyc2UgdGhlIHRlbXBsYXRlIGFuZCBjaGVjayBmb3IgZXJyb3JzLlxuICAgICAgICBjb25zdCB7IHRlbXBsYXRlLCBpbnRlcnBvbGF0aW9uIH0gPSBwYXJzZUppdFRlbXBsYXRlKGZhY2FkZS50ZW1wbGF0ZSwgZmFjYWRlLm5hbWUsIHNvdXJjZU1hcFVybCwgZmFjYWRlLnByZXNlcnZlV2hpdGVzcGFjZXMsIGZhY2FkZS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgLy8gQ29tcGlsZSB0aGUgY29tcG9uZW50IG1ldGFkYXRhLCBpbmNsdWRpbmcgdGVtcGxhdGUsIGludG8gYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgY29uc3QgbWV0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmYWNhZGUpLCBjb252ZXJ0RGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShmYWNhZGUpKSwgeyBzZWxlY3RvcjogZmFjYWRlLnNlbGVjdG9yIHx8IHRoaXMuZWxlbWVudFNjaGVtYVJlZ2lzdHJ5LmdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSgpLCB0ZW1wbGF0ZSwgZGVjbGFyYXRpb25zOiBmYWNhZGUuZGVjbGFyYXRpb25zLm1hcChjb252ZXJ0RGVjbGFyYXRpb25GYWNhZGVUb01ldGFkYXRhKSwgZGVjbGFyYXRpb25MaXN0RW1pdE1vZGU6IDAgLyogRGVjbGFyYXRpb25MaXN0RW1pdE1vZGUuRGlyZWN0ICovLCBzdHlsZXM6IFsuLi5mYWNhZGUuc3R5bGVzLCAuLi50ZW1wbGF0ZS5zdHlsZXNdLCBlbmNhcHN1bGF0aW9uOiBmYWNhZGUuZW5jYXBzdWxhdGlvbiwgaW50ZXJwb2xhdGlvbiwgY2hhbmdlRGV0ZWN0aW9uOiBmYWNhZGUuY2hhbmdlRGV0ZWN0aW9uLCBhbmltYXRpb25zOiBmYWNhZGUuYW5pbWF0aW9ucyAhPSBudWxsID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUuYW5pbWF0aW9ucykgOiBudWxsLCB2aWV3UHJvdmlkZXJzOiBmYWNhZGUudmlld1Byb3ZpZGVycyAhPSBudWxsID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudmlld1Byb3ZpZGVycykgOlxuICAgICAgICAgICAgICAgIG51bGwsIHJlbGF0aXZlQ29udGV4dEZpbGVQYXRoOiAnJywgaTE4blVzZUV4dGVybmFsSWRzOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBqaXRFeHByZXNzaW9uU291cmNlTWFwID0gYG5nOi8vLyR7ZmFjYWRlLm5hbWV9LmpzYDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUNvbXBvbmVudEZyb21NZXRhKGFuZ3VsYXJDb3JlRW52LCBqaXRFeHByZXNzaW9uU291cmNlTWFwLCBtZXRhKTtcbiAgICB9XG4gICAgY29tcGlsZUNvbXBvbmVudERlY2xhcmF0aW9uKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHR5cGVTb3VyY2VTcGFuID0gdGhpcy5jcmVhdGVQYXJzZVNvdXJjZVNwYW4oJ0NvbXBvbmVudCcsIGRlY2xhcmF0aW9uLnR5cGUubmFtZSwgc291cmNlTWFwVXJsKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvbnZlcnREZWNsYXJlQ29tcG9uZW50RmFjYWRlVG9NZXRhZGF0YShkZWNsYXJhdGlvbiwgdHlwZVNvdXJjZVNwYW4sIHNvdXJjZU1hcFVybCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVDb21wb25lbnRGcm9tTWV0YShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBtZXRhKTtcbiAgICB9XG4gICAgY29tcGlsZUNvbXBvbmVudEZyb21NZXRhKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIG1ldGEpIHtcbiAgICAgICAgY29uc3QgY29uc3RhbnRQb29sID0gbmV3IENvbnN0YW50UG9vbCgpO1xuICAgICAgICBjb25zdCBiaW5kaW5nUGFyc2VyID0gbWFrZUJpbmRpbmdQYXJzZXIobWV0YS5pbnRlcnBvbGF0aW9uKTtcbiAgICAgICAgY29uc3QgcmVzID0gY29tcGlsZUNvbXBvbmVudEZyb21NZXRhZGF0YShtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBjb25zdGFudFBvb2wuc3RhdGVtZW50cyk7XG4gICAgfVxuICAgIGNvbXBpbGVGYWN0b3J5KGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIG1ldGEpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yeVJlcyA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oe1xuICAgICAgICAgICAgbmFtZTogbWV0YS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZShtZXRhLnR5cGUpLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKG1ldGEudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogbWV0YS50eXBlQXJndW1lbnRDb3VudCxcbiAgICAgICAgICAgIGRlcHM6IGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YUFycmF5KG1ldGEuZGVwcyksXG4gICAgICAgICAgICB0YXJnZXQ6IG1ldGEudGFyZ2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihmYWN0b3J5UmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY3RvcnlSZXMuc3RhdGVtZW50cyk7XG4gICAgfVxuICAgIGNvbXBpbGVGYWN0b3J5RGVjbGFyYXRpb24oYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgbWV0YSkge1xuICAgICAgICBjb25zdCBmYWN0b3J5UmVzID0gY29tcGlsZUZhY3RvcnlGdW5jdGlvbih7XG4gICAgICAgICAgICBuYW1lOiBtZXRhLnR5cGUubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UobWV0YS50eXBlKSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihtZXRhLnR5cGUpLFxuICAgICAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IDAsXG4gICAgICAgICAgICBkZXBzOiBBcnJheS5pc0FycmF5KG1ldGEuZGVwcykgPyBtZXRhLmRlcHMubWFwKGNvbnZlcnRSM0RlY2xhcmVEZXBlbmRlbmN5TWV0YWRhdGEpIDpcbiAgICAgICAgICAgICAgICBtZXRhLmRlcHMsXG4gICAgICAgICAgICB0YXJnZXQ6IG1ldGEudGFyZ2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihmYWN0b3J5UmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY3RvcnlSZXMuc3RhdGVtZW50cyk7XG4gICAgfVxuICAgIGNyZWF0ZVBhcnNlU291cmNlU3BhbihraW5kLCB0eXBlTmFtZSwgc291cmNlVXJsKSB7XG4gICAgICAgIHJldHVybiByM0ppdFR5cGVTb3VyY2VTcGFuKGtpbmQsIHR5cGVOYW1lLCBzb3VyY2VVcmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKSVQgY29tcGlsZXMgYW4gZXhwcmVzc2lvbiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyB0aGF0IGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVmIHRoZSBkZWZpbml0aW9uIHdoaWNoIHdpbGwgYmUgY29tcGlsZWQgYW5kIGV4ZWN1dGVkIHRvIGdldCB0aGUgdmFsdWUgdG8gcGF0Y2hcbiAgICAgKiBAcGFyYW0gY29udGV4dCBhbiBvYmplY3QgbWFwIG9mIEBhbmd1bGFyL2NvcmUgc3ltYm9sIG5hbWVzIHRvIHN5bWJvbHMgd2hpY2ggd2lsbCBiZSBhdmFpbGFibGVcbiAgICAgKiBpbiB0aGUgY29udGV4dCBvZiB0aGUgY29tcGlsZWQgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSBzb3VyY2VVcmwgYSBVUkwgdG8gdXNlIGZvciB0aGUgc291cmNlIG1hcCBvZiB0aGUgY29tcGlsZWQgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSBwcmVTdGF0ZW1lbnRzIGEgY29sbGVjdGlvbiBvZiBzdGF0ZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGV2YWx1YXRlZCBiZWZvcmUgdGhlIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgaml0RXhwcmVzc2lvbihkZWYsIGNvbnRleHQsIHNvdXJjZVVybCwgcHJlU3RhdGVtZW50cykge1xuICAgICAgICAvLyBUaGUgQ29uc3RhbnRQb29sIG1heSBjb250YWluIFN0YXRlbWVudHMgd2hpY2ggZGVjbGFyZSB2YXJpYWJsZXMgdXNlZCBpbiB0aGUgZmluYWwgZXhwcmVzc2lvbi5cbiAgICAgICAgLy8gVGhlcmVmb3JlLCBpdHMgc3RhdGVtZW50cyBuZWVkIHRvIHByZWNlZGUgdGhlIGFjdHVhbCBKSVQgb3BlcmF0aW9uLiBUaGUgZmluYWwgc3RhdGVtZW50IGlzIGFcbiAgICAgICAgLy8gZGVjbGFyYXRpb24gb2YgJGRlZiB3aGljaCBpcyBzZXQgdG8gdGhlIGV4cHJlc3Npb24gYmVpbmcgY29tcGlsZWQuXG4gICAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSBbXG4gICAgICAgICAgICAuLi5wcmVTdGF0ZW1lbnRzLFxuICAgICAgICAgICAgbmV3IERlY2xhcmVWYXJTdG10KCckZGVmJywgZGVmLCB1bmRlZmluZWQsIGV4cG9ydHMuU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5qaXRFdmFsdWF0b3IuZXZhbHVhdGVTdGF0ZW1lbnRzKHNvdXJjZVVybCwgc3RhdGVtZW50cywgbmV3IFIzSml0UmVmbGVjdG9yKGNvbnRleHQpLCAvKiBlbmFibGVTb3VyY2VNYXBzICovIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVzWyckZGVmJ107XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFRvUjNRdWVyeU1ldGFkYXRhKGZhY2FkZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZhY2FkZSksIHsgcHJlZGljYXRlOiBjb252ZXJ0UXVlcnlQcmVkaWNhdGUoZmFjYWRlLnByZWRpY2F0ZSksIHJlYWQ6IGZhY2FkZS5yZWFkID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUucmVhZCkgOiBudWxsLCBzdGF0aWM6IGZhY2FkZS5zdGF0aWMsIGVtaXREaXN0aW5jdENoYW5nZXNPbmx5OiBmYWNhZGUuZW1pdERpc3RpbmN0Q2hhbmdlc09ubHkgfSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0UXVlcnlEZWNsYXJhdGlvblRvTWV0YWRhdGEoZGVjbGFyYXRpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcGVydHlOYW1lOiBkZWNsYXJhdGlvbi5wcm9wZXJ0eU5hbWUsXG4gICAgICAgIGZpcnN0OiAoX2EgPSBkZWNsYXJhdGlvbi5maXJzdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsXG4gICAgICAgIHByZWRpY2F0ZTogY29udmVydFF1ZXJ5UHJlZGljYXRlKGRlY2xhcmF0aW9uLnByZWRpY2F0ZSksXG4gICAgICAgIGRlc2NlbmRhbnRzOiAoX2IgPSBkZWNsYXJhdGlvbi5kZXNjZW5kYW50cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAgIHJlYWQ6IGRlY2xhcmF0aW9uLnJlYWQgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGRlY2xhcmF0aW9uLnJlYWQpIDogbnVsbCxcbiAgICAgICAgc3RhdGljOiAoX2MgPSBkZWNsYXJhdGlvbi5zdGF0aWMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlLFxuICAgICAgICBlbWl0RGlzdGluY3RDaGFuZ2VzT25seTogKF9kID0gZGVjbGFyYXRpb24uZW1pdERpc3RpbmN0Q2hhbmdlc09ubHkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRRdWVyeVByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwcmVkaWNhdGUpID9cbiAgICAgICAgLy8gVGhlIHByZWRpY2F0ZSBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIHNvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICAgICAgcHJlZGljYXRlIDpcbiAgICAgICAgLy8gVGhlIHByZWRpY2F0ZSBpcyBhIHR5cGUgLSBhc3N1bWUgdGhhdCB3ZSB3aWxsIG5lZWQgdG8gdW53cmFwIGFueSBgZm9yd2FyZFJlZigpYCBjYWxscy5cbiAgICAgICAgY3JlYXRlTWF5QmVGb3J3YXJkUmVmRXhwcmVzc2lvbihuZXcgV3JhcHBlZE5vZGVFeHByKHByZWRpY2F0ZSksIDEgLyogRm9yd2FyZFJlZkhhbmRsaW5nLldyYXBwZWQgKi8pO1xufVxuZnVuY3Rpb24gY29udmVydERpcmVjdGl2ZUZhY2FkZVRvTWV0YWRhdGEoZmFjYWRlKSB7XG4gICAgY29uc3QgaW5wdXRzRnJvbU1ldGFkYXRhID0gcGFyc2VJbnB1dE91dHB1dHMoZmFjYWRlLmlucHV0cyB8fCBbXSk7XG4gICAgY29uc3Qgb3V0cHV0c0Zyb21NZXRhZGF0YSA9IHBhcnNlSW5wdXRPdXRwdXRzKGZhY2FkZS5vdXRwdXRzIHx8IFtdKTtcbiAgICBjb25zdCBwcm9wTWV0YWRhdGEgPSBmYWNhZGUucHJvcE1ldGFkYXRhO1xuICAgIGNvbnN0IGlucHV0c0Zyb21UeXBlID0ge307XG4gICAgY29uc3Qgb3V0cHV0c0Zyb21UeXBlID0ge307XG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBwcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKHByb3BNZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgICAgIHByb3BNZXRhZGF0YVtmaWVsZF0uZm9yRWFjaChhbm4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0lucHV0KGFubikpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzRnJvbVR5cGVbZmllbGRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFubi5iaW5kaW5nUHJvcGVydHlOYW1lID8gW2Fubi5iaW5kaW5nUHJvcGVydHlOYW1lLCBmaWVsZF0gOiBmaWVsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPdXRwdXQoYW5uKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzRnJvbVR5cGVbZmllbGRdID0gYW5uLmJpbmRpbmdQcm9wZXJ0eU5hbWUgfHwgZmllbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmFjYWRlKSwgeyB0eXBlQXJndW1lbnRDb3VudDogMCwgdHlwZVNvdXJjZVNwYW46IGZhY2FkZS50eXBlU291cmNlU3BhbiwgdHlwZTogd3JhcFJlZmVyZW5jZShmYWNhZGUudHlwZSksIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksIGRlcHM6IG51bGwsIGhvc3Q6IGV4dHJhY3RIb3N0QmluZGluZ3MoZmFjYWRlLnByb3BNZXRhZGF0YSwgZmFjYWRlLnR5cGVTb3VyY2VTcGFuLCBmYWNhZGUuaG9zdCksIGlucHV0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnB1dHNGcm9tTWV0YWRhdGEpLCBpbnB1dHNGcm9tVHlwZSksIG91dHB1dHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0c0Zyb21NZXRhZGF0YSksIG91dHB1dHNGcm9tVHlwZSksIHF1ZXJpZXM6IGZhY2FkZS5xdWVyaWVzLm1hcChjb252ZXJ0VG9SM1F1ZXJ5TWV0YWRhdGEpLCBwcm92aWRlcnM6IGZhY2FkZS5wcm92aWRlcnMgIT0gbnVsbCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnByb3ZpZGVycykgOiBudWxsLCB2aWV3UXVlcmllczogZmFjYWRlLnZpZXdRdWVyaWVzLm1hcChjb252ZXJ0VG9SM1F1ZXJ5TWV0YWRhdGEpLCBmdWxsSW5oZXJpdGFuY2U6IGZhbHNlIH0pO1xufVxuZnVuY3Rpb24gY29udmVydERlY2xhcmVEaXJlY3RpdmVGYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uLCB0eXBlU291cmNlU3Bhbikge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRlY2xhcmF0aW9uLnR5cGUubmFtZSxcbiAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZShkZWNsYXJhdGlvbi50eXBlKSxcbiAgICAgICAgdHlwZVNvdXJjZVNwYW4sXG4gICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi50eXBlKSxcbiAgICAgICAgc2VsZWN0b3I6IChfYSA9IGRlY2xhcmF0aW9uLnNlbGVjdG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICBpbnB1dHM6IChfYiA9IGRlY2xhcmF0aW9uLmlucHV0cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge30sXG4gICAgICAgIG91dHB1dHM6IChfYyA9IGRlY2xhcmF0aW9uLm91dHB1dHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LFxuICAgICAgICBob3N0OiBjb252ZXJ0SG9zdERlY2xhcmF0aW9uVG9NZXRhZGF0YShkZWNsYXJhdGlvbi5ob3N0KSxcbiAgICAgICAgcXVlcmllczogKChfZCA9IGRlY2xhcmF0aW9uLnF1ZXJpZXMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFtdKS5tYXAoY29udmVydFF1ZXJ5RGVjbGFyYXRpb25Ub01ldGFkYXRhKSxcbiAgICAgICAgdmlld1F1ZXJpZXM6ICgoX2UgPSBkZWNsYXJhdGlvbi52aWV3UXVlcmllcykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogW10pLm1hcChjb252ZXJ0UXVlcnlEZWNsYXJhdGlvblRvTWV0YWRhdGEpLFxuICAgICAgICBwcm92aWRlcnM6IGRlY2xhcmF0aW9uLnByb3ZpZGVycyAhPT0gdW5kZWZpbmVkID8gbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi5wcm92aWRlcnMpIDpcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIGV4cG9ydEFzOiAoX2YgPSBkZWNsYXJhdGlvbi5leHBvcnRBcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbnVsbCxcbiAgICAgICAgdXNlc0luaGVyaXRhbmNlOiAoX2cgPSBkZWNsYXJhdGlvbi51c2VzSW5oZXJpdGFuY2UpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IGZhbHNlLFxuICAgICAgICBsaWZlY3ljbGU6IHsgdXNlc09uQ2hhbmdlczogKF9oID0gZGVjbGFyYXRpb24udXNlc09uQ2hhbmdlcykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogZmFsc2UgfSxcbiAgICAgICAgZGVwczogbnVsbCxcbiAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IDAsXG4gICAgICAgIGZ1bGxJbmhlcml0YW5jZTogZmFsc2UsXG4gICAgICAgIGlzU3RhbmRhbG9uZTogKF9qID0gZGVjbGFyYXRpb24uaXNTdGFuZGFsb25lKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiBmYWxzZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydEhvc3REZWNsYXJhdGlvblRvTWV0YWRhdGEoaG9zdCA9IHt9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXR0cmlidXRlczogY29udmVydE9wYXF1ZVZhbHVlc1RvRXhwcmVzc2lvbnMoKF9hID0gaG9zdC5hdHRyaWJ1dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSksXG4gICAgICAgIGxpc3RlbmVyczogKF9iID0gaG9zdC5saXN0ZW5lcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LFxuICAgICAgICBwcm9wZXJ0aWVzOiAoX2MgPSBob3N0LnByb3BlcnRpZXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LFxuICAgICAgICBzcGVjaWFsQXR0cmlidXRlczoge1xuICAgICAgICAgICAgY2xhc3NBdHRyOiBob3N0LmNsYXNzQXR0cmlidXRlLFxuICAgICAgICAgICAgc3R5bGVBdHRyOiBob3N0LnN0eWxlQXR0cmlidXRlLFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0T3BhcXVlVmFsdWVzVG9FeHByZXNzaW9ucyhvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gbmV3IFdyYXBwZWROb2RlRXhwcihvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGVjbGFyZUNvbXBvbmVudEZhY2FkZVRvTWV0YWRhdGEoZGVjbCwgdHlwZVNvdXJjZVNwYW4sIHNvdXJjZU1hcFVybCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCB7IHRlbXBsYXRlLCBpbnRlcnBvbGF0aW9uIH0gPSBwYXJzZUppdFRlbXBsYXRlKGRlY2wudGVtcGxhdGUsIGRlY2wudHlwZS5uYW1lLCBzb3VyY2VNYXBVcmwsIChfYSA9IGRlY2wucHJlc2VydmVXaGl0ZXNwYWNlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UsIGRlY2wuaW50ZXJwb2xhdGlvbik7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gW107XG4gICAgaWYgKGRlY2wuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5uZXJEZXAgb2YgZGVjbC5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5uZXJEZXAua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcG9uZW50JzpcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2goY29udmVydERpcmVjdGl2ZURlY2xhcmF0aW9uVG9NZXRhZGF0YShpbm5lckRlcCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwaXBlJzpcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2goY29udmVydFBpcGVEZWNsYXJhdGlvblRvTWV0YWRhdGEoaW5uZXJEZXApKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGVjbC5jb21wb25lbnRzIHx8IGRlY2wuZGlyZWN0aXZlcyB8fCBkZWNsLnBpcGVzKSB7XG4gICAgICAgIC8vIEV4aXN0aW5nIGRlY2xhcmF0aW9ucyBvbiBOUE0gbWF5IG5vdCBiZSB1c2luZyB0aGUgbmV3IGBkZXBlbmRlbmNpZXNgIG1lcmdlZCBmaWVsZCwgYW5kIG1heVxuICAgICAgICAvLyBoYXZlIHNlcGFyYXRlIGZpZWxkcyBmb3IgZGVwZW5kZW5jaWVzIGluc3RlYWQuIFVuaWZ5IHRoZW0gZm9yIEpJVCBjb21waWxhdGlvbi5cbiAgICAgICAgZGVjbC5jb21wb25lbnRzICYmXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnMucHVzaCguLi5kZWNsLmNvbXBvbmVudHMubWFwKGRpciA9PiBjb252ZXJ0RGlyZWN0aXZlRGVjbGFyYXRpb25Ub01ldGFkYXRhKGRpciwgLyogaXNDb21wb25lbnQgKi8gdHJ1ZSkpKTtcbiAgICAgICAgZGVjbC5kaXJlY3RpdmVzICYmXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnMucHVzaCguLi5kZWNsLmRpcmVjdGl2ZXMubWFwKGRpciA9PiBjb252ZXJ0RGlyZWN0aXZlRGVjbGFyYXRpb25Ub01ldGFkYXRhKGRpcikpKTtcbiAgICAgICAgZGVjbC5waXBlcyAmJiBkZWNsYXJhdGlvbnMucHVzaCguLi5jb252ZXJ0UGlwZU1hcFRvTWV0YWRhdGEoZGVjbC5waXBlcykpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb252ZXJ0RGVjbGFyZURpcmVjdGl2ZUZhY2FkZVRvTWV0YWRhdGEoZGVjbCwgdHlwZVNvdXJjZVNwYW4pKSwgeyB0ZW1wbGF0ZSwgc3R5bGVzOiAoX2IgPSBkZWNsLnN0eWxlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sIGRlY2xhcmF0aW9ucywgdmlld1Byb3ZpZGVyczogZGVjbC52aWV3UHJvdmlkZXJzICE9PSB1bmRlZmluZWQgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGRlY2wudmlld1Byb3ZpZGVycykgOlxuICAgICAgICAgICAgbnVsbCwgYW5pbWF0aW9uczogZGVjbC5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGRlY2wuYW5pbWF0aW9ucykgOiBudWxsLCBjaGFuZ2VEZXRlY3Rpb246IChfYyA9IGRlY2wuY2hhbmdlRGV0ZWN0aW9uKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsIGVuY2Fwc3VsYXRpb246IChfZCA9IGRlY2wuZW5jYXBzdWxhdGlvbikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCwgaW50ZXJwb2xhdGlvbiwgZGVjbGFyYXRpb25MaXN0RW1pdE1vZGU6IDIgLyogRGVjbGFyYXRpb25MaXN0RW1pdE1vZGUuQ2xvc3VyZVJlc29sdmVkICovLCByZWxhdGl2ZUNvbnRleHRGaWxlUGF0aDogJycsIGkxOG5Vc2VFeHRlcm5hbElkczogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREZWNsYXJhdGlvbkZhY2FkZVRvTWV0YWRhdGEoZGVjbGFyYXRpb24pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWNsYXJhdGlvbiksIHsgdHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi50eXBlKSB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREaXJlY3RpdmVEZWNsYXJhdGlvblRvTWV0YWRhdGEoZGVjbGFyYXRpb24sIGlzQ29tcG9uZW50ID0gbnVsbCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IGV4cG9ydHMuUjNUZW1wbGF0ZURlcGVuZGVuY3lLaW5kLkRpcmVjdGl2ZSxcbiAgICAgICAgaXNDb21wb25lbnQ6IGlzQ29tcG9uZW50IHx8IGRlY2xhcmF0aW9uLmtpbmQgPT09ICdjb21wb25lbnQnLFxuICAgICAgICBzZWxlY3RvcjogZGVjbGFyYXRpb24uc2VsZWN0b3IsXG4gICAgICAgIHR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbGFyYXRpb24udHlwZSksXG4gICAgICAgIGlucHV0czogKF9hID0gZGVjbGFyYXRpb24uaW5wdXRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgb3V0cHV0czogKF9iID0gZGVjbGFyYXRpb24ub3V0cHV0cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIGV4cG9ydEFzOiAoX2MgPSBkZWNsYXJhdGlvbi5leHBvcnRBcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFBpcGVNYXBUb01ldGFkYXRhKHBpcGVzKSB7XG4gICAgaWYgKCFwaXBlcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhwaXBlcykubWFwKG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2luZDogZXhwb3J0cy5SM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmQuUGlwZSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0eXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKHBpcGVzW25hbWVdKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRQaXBlRGVjbGFyYXRpb25Ub01ldGFkYXRhKHBpcGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBleHBvcnRzLlIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZC5QaXBlLFxuICAgICAgICBuYW1lOiBwaXBlLm5hbWUsXG4gICAgICAgIHR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIocGlwZS50eXBlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VKaXRUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHlwZU5hbWUsIHNvdXJjZU1hcFVybCwgcHJlc2VydmVXaGl0ZXNwYWNlcywgaW50ZXJwb2xhdGlvbikge1xuICAgIGNvbnN0IGludGVycG9sYXRpb25Db25maWcgPSBpbnRlcnBvbGF0aW9uID8gSW50ZXJwb2xhdGlvbkNvbmZpZy5mcm9tQXJyYXkoaW50ZXJwb2xhdGlvbikgOiBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgIC8vIFBhcnNlIHRoZSB0ZW1wbGF0ZSBhbmQgY2hlY2sgZm9yIGVycm9ycy5cbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBzb3VyY2VNYXBVcmwsIHsgcHJlc2VydmVXaGl0ZXNwYWNlcywgaW50ZXJwb2xhdGlvbkNvbmZpZyB9KTtcbiAgICBpZiAocGFyc2VkLmVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBwYXJzZWQuZXJyb3JzLm1hcChlcnIgPT4gZXJyLnRvU3RyaW5nKCkpLmpvaW4oJywgJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3JzIGR1cmluZyBKSVQgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgZm9yICR7dHlwZU5hbWV9OiAke2Vycm9yc31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGVtcGxhdGU6IHBhcnNlZCwgaW50ZXJwb2xhdGlvbjogaW50ZXJwb2xhdGlvbkNvbmZpZyB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IHRoZSBleHByZXNzaW9uLCBpZiBwcmVzZW50IHRvIGFuIGBSM1Byb3ZpZGVyRXhwcmVzc2lvbmAuXG4gKlxuICogSW4gSklUIG1vZGUgd2UgZG8gbm90IHdhbnQgdGhlIGNvbXBpbGVyIHRvIHdyYXAgdGhlIGV4cHJlc3Npb24gaW4gYSBgZm9yd2FyZFJlZigpYCBjYWxsIGJlY2F1c2UsXG4gKiBpZiBpdCBpcyByZWZlcmVuY2luZyBhIHR5cGUgdGhhdCBoYXMgbm90IHlldCBiZWVuIGRlZmluZWQsIGl0IHdpbGwgaGF2ZSBhbHJlYWR5IGJlZW4gd3JhcHBlZCBpblxuICogYSBgZm9yd2FyZFJlZigpYCAtIGVpdGhlciBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIG9yIGR1cmluZyBwYXJ0aWFsLWNvbXBpbGF0aW9uLiBUaHVzIHdlIGNhblxuICogdXNlIGBGb3J3YXJkUmVmSGFuZGxpbmcuTm9uZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihvYmosIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1heUJlRm9yd2FyZFJlZkV4cHJlc3Npb24obmV3IFdyYXBwZWROb2RlRXhwcihvYmpbcHJvcGVydHldKSwgMCAvKiBGb3J3YXJkUmVmSGFuZGxpbmcuTm9uZSAqLyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBFeHByZXNzaW9uKG9iaiwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyYXBwZWROb2RlRXhwcihvYmpbcHJvcGVydHldKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVByb3ZpZGVkSW4ocHJvdmlkZWRJbikge1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0eXBlb2YgcHJvdmlkZWRJbiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBXcmFwcGVkTm9kZUV4cHIocHJvdmlkZWRJbikgOlxuICAgICAgICBuZXcgTGl0ZXJhbEV4cHIocHJvdmlkZWRJbiAhPT0gbnVsbCAmJiBwcm92aWRlZEluICE9PSB2b2lkIDAgPyBwcm92aWRlZEluIDogbnVsbCk7XG4gICAgLy8gU2VlIGBjb252ZXJ0VG9Qcm92aWRlckV4cHJlc3Npb24oKWAgZm9yIHdoeSB0aGlzIHVzZXMgYEZvcndhcmRSZWZIYW5kbGluZy5Ob25lYC5cbiAgICByZXR1cm4gY3JlYXRlTWF5QmVGb3J3YXJkUmVmRXhwcmVzc2lvbihleHByZXNzaW9uLCAwIC8qIEZvcndhcmRSZWZIYW5kbGluZy5Ob25lICovKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YUFycmF5KGZhY2FkZXMpIHtcbiAgICByZXR1cm4gZmFjYWRlcyA9PSBudWxsID8gbnVsbCA6IGZhY2FkZXMubWFwKGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YSk7XG59XG5mdW5jdGlvbiBjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGEoZmFjYWRlKSB7XG4gICAgY29uc3QgaXNBdHRyaWJ1dGVEZXAgPSBmYWNhZGUuYXR0cmlidXRlICE9IG51bGw7IC8vIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIGNvbnN0IHJhd1Rva2VuID0gZmFjYWRlLnRva2VuID09PSBudWxsID8gbnVsbCA6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnRva2VuKTtcbiAgICAvLyBJbiBKSVQgbW9kZSwgaWYgdGhlIGRlcCBpcyBhbiBgQEF0dHJpYnV0ZSgpYCB0aGVuIHdlIHVzZSB0aGUgYXR0cmlidXRlIG5hbWUgZ2l2ZW4gaW5cbiAgICAvLyBgYXR0cmlidXRlYCByYXRoZXIgdGhhbiB0aGUgYHRva2VuYC5cbiAgICBjb25zdCB0b2tlbiA9IGlzQXR0cmlidXRlRGVwID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUuYXR0cmlidXRlKSA6IHJhd1Rva2VuO1xuICAgIHJldHVybiBjcmVhdGVSM0RlcGVuZGVuY3lNZXRhZGF0YSh0b2tlbiwgaXNBdHRyaWJ1dGVEZXAsIGZhY2FkZS5ob3N0LCBmYWNhZGUub3B0aW9uYWwsIGZhY2FkZS5zZWxmLCBmYWNhZGUuc2tpcFNlbGYpO1xufVxuZnVuY3Rpb24gY29udmVydFIzRGVjbGFyZURlcGVuZGVuY3lNZXRhZGF0YShmYWNhZGUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IGlzQXR0cmlidXRlRGVwID0gKF9hID0gZmFjYWRlLmF0dHJpYnV0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgY29uc3QgdG9rZW4gPSBmYWNhZGUudG9rZW4gPT09IG51bGwgPyBudWxsIDogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudG9rZW4pO1xuICAgIHJldHVybiBjcmVhdGVSM0RlcGVuZGVuY3lNZXRhZGF0YSh0b2tlbiwgaXNBdHRyaWJ1dGVEZXAsIChfYiA9IGZhY2FkZS5ob3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSwgKF9jID0gZmFjYWRlLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZSwgKF9kID0gZmFjYWRlLnNlbGYpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlLCAoX2UgPSBmYWNhZGUuc2tpcFNlbGYpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVIzRGVwZW5kZW5jeU1ldGFkYXRhKHRva2VuLCBpc0F0dHJpYnV0ZURlcCwgaG9zdCwgb3B0aW9uYWwsIHNlbGYsIHNraXBTZWxmKSB7XG4gICAgLy8gSWYgdGhlIGRlcCBpcyBhbiBgQEF0dHJpYnV0ZSgpYCB0aGUgYGF0dHJpYnV0ZU5hbWVUeXBlYCBvdWdodCB0byBiZSB0aGUgYHVua25vd25gIHR5cGUuXG4gICAgLy8gQnV0IHR5cGVzIGFyZSBub3QgYXZhaWxhYmxlIGF0IHJ1bnRpbWUgc28gd2UganVzdCB1c2UgYSBsaXRlcmFsIGBcIjx1bmtub3duPlwiYCBzdHJpbmcgYXMgYSBkdW1teVxuICAgIC8vIG1hcmtlci5cbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lVHlwZSA9IGlzQXR0cmlidXRlRGVwID8gbGl0ZXJhbCgndW5rbm93bicpIDogbnVsbDtcbiAgICByZXR1cm4geyB0b2tlbiwgYXR0cmlidXRlTmFtZVR5cGUsIGhvc3QsIG9wdGlvbmFsLCBzZWxmLCBza2lwU2VsZiB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdEhvc3RCaW5kaW5ncyhwcm9wTWV0YWRhdGEsIHNvdXJjZVNwYW4sIGhvc3QpIHtcbiAgICAvLyBGaXJzdCBwYXJzZSB0aGUgZGVjbGFyYXRpb25zIGZyb20gdGhlIG1ldGFkYXRhLlxuICAgIGNvbnN0IGJpbmRpbmdzID0gcGFyc2VIb3N0QmluZGluZ3MoaG9zdCB8fCB7fSk7XG4gICAgLy8gQWZ0ZXIgdGhhdCBjaGVjayBob3N0IGJpbmRpbmdzIGZvciBlcnJvcnNcbiAgICBjb25zdCBlcnJvcnMgPSB2ZXJpZnlIb3N0QmluZGluZ3MoYmluZGluZ3MsIHNvdXJjZVNwYW4pO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMubWFwKChlcnJvcikgPT4gZXJyb3IubXNnKS5qb2luKCdcXG4nKSk7XG4gICAgfVxuICAgIC8vIE5leHQsIGxvb3Agb3ZlciB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0LCBsb29raW5nIGZvciBASG9zdEJpbmRpbmcgYW5kIEBIb3N0TGlzdGVuZXIuXG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBwcm9wTWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKHByb3BNZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgICAgIHByb3BNZXRhZGF0YVtmaWVsZF0uZm9yRWFjaChhbm4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc0hvc3RCaW5kaW5nKGFubikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGRlY29yYXRvciwgd2Uga25vdyB0aGF0IHRoZSB2YWx1ZSBpcyBhIGNsYXNzIG1lbWJlci4gQWx3YXlzIGFjY2VzcyBpdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIGB0aGlzYCBzbyB0aGF0IGZ1cnRoZXIgZG93biB0aGUgbGluZSBpdCBjYW4ndCBiZSBjb25mdXNlZCBmb3IgYSBsaXRlcmFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIChlLmcuIGlmIHRoZXJlJ3MgYSBwcm9wZXJ0eSBjYWxsZWQgYHRydWVgKS5cbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MucHJvcGVydGllc1thbm4uaG9zdFByb3BlcnR5TmFtZSB8fCBmaWVsZF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U2FmZVByb3BlcnR5QWNjZXNzU3RyaW5nKCd0aGlzJywgZmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0hvc3RMaXN0ZW5lcihhbm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLmxpc3RlbmVyc1thbm4uZXZlbnROYW1lIHx8IGZpZWxkXSA9IGAke2ZpZWxkfSgkeyhhbm4uYXJncyB8fCBbXSkuam9pbignLCcpfSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaW5kaW5ncztcbn1cbmZ1bmN0aW9uIGlzSG9zdEJpbmRpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubmdNZXRhZGF0YU5hbWUgPT09ICdIb3N0QmluZGluZyc7XG59XG5mdW5jdGlvbiBpc0hvc3RMaXN0ZW5lcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5uZ01ldGFkYXRhTmFtZSA9PT0gJ0hvc3RMaXN0ZW5lcic7XG59XG5mdW5jdGlvbiBpc0lucHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm5nTWV0YWRhdGFOYW1lID09PSAnSW5wdXQnO1xufVxuZnVuY3Rpb24gaXNPdXRwdXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubmdNZXRhZGF0YU5hbWUgPT09ICdPdXRwdXQnO1xufVxuZnVuY3Rpb24gcGFyc2VJbnB1dE91dHB1dHModmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoKG1hcCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgW2ZpZWxkLCBwcm9wZXJ0eV0gPSB2YWx1ZS5zcGxpdCgnLCcpLm1hcChwaWVjZSA9PiBwaWVjZS50cmltKCkpO1xuICAgICAgICBtYXBbZmllbGRdID0gcHJvcGVydHkgfHwgZmllbGQ7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gY29udmVydERlY2xhcmVQaXBlRmFjYWRlVG9NZXRhZGF0YShkZWNsYXJhdGlvbikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZGVjbGFyYXRpb24udHlwZS5uYW1lLFxuICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGRlY2xhcmF0aW9uLnR5cGUpLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbGFyYXRpb24udHlwZSksXG4gICAgICAgIHR5cGVBcmd1bWVudENvdW50OiAwLFxuICAgICAgICBwaXBlTmFtZTogZGVjbGFyYXRpb24ubmFtZSxcbiAgICAgICAgZGVwczogbnVsbCxcbiAgICAgICAgcHVyZTogKF9hID0gZGVjbGFyYXRpb24ucHVyZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZSxcbiAgICAgICAgaXNTdGFuZGFsb25lOiAoX2IgPSBkZWNsYXJhdGlvbi5pc1N0YW5kYWxvbmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0RGVjbGFyZUluamVjdG9yRmFjYWRlVG9NZXRhZGF0YShkZWNsYXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRlY2xhcmF0aW9uLnR5cGUubmFtZSxcbiAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZShkZWNsYXJhdGlvbi50eXBlKSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGRlY2xhcmF0aW9uLnR5cGUpLFxuICAgICAgICBwcm92aWRlcnM6IGRlY2xhcmF0aW9uLnByb3ZpZGVycyAhPT0gdW5kZWZpbmVkID8gbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi5wcm92aWRlcnMpIDpcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIGltcG9ydHM6IGRlY2xhcmF0aW9uLmltcG9ydHMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5pbXBvcnRzLm1hcChpID0+IG5ldyBXcmFwcGVkTm9kZUV4cHIoaSkpIDpcbiAgICAgICAgICAgIFtdLFxuICAgIH07XG59XG5mdW5jdGlvbiBwdWJsaXNoRmFjYWRlKGdsb2JhbCkge1xuICAgIGNvbnN0IG5nID0gZ2xvYmFsLm5nIHx8IChnbG9iYWwubmcgPSB7fSk7XG4gICAgbmcuybVjb21waWxlckZhY2FkZSA9IG5ldyBDb21waWxlckZhY2FkZUltcGwoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBWRVJTSU9OID0gbmV3IFZlcnNpb24oJzE0LjAuMCcpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIENvbXBpbGVyQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRlZmF1bHRFbmNhcHN1bGF0aW9uID0gZXhwb3J0cy5WaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCwgdXNlSml0ID0gdHJ1ZSwgaml0RGV2TW9kZSA9IGZhbHNlLCBtaXNzaW5nVHJhbnNsYXRpb24gPSBudWxsLCBwcmVzZXJ2ZVdoaXRlc3BhY2VzLCBzdHJpY3RJbmplY3Rpb25QYXJhbWV0ZXJzIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmRlZmF1bHRFbmNhcHN1bGF0aW9uID0gZGVmYXVsdEVuY2Fwc3VsYXRpb247XG4gICAgICAgIHRoaXMudXNlSml0ID0gISF1c2VKaXQ7XG4gICAgICAgIHRoaXMuaml0RGV2TW9kZSA9ICEhaml0RGV2TW9kZTtcbiAgICAgICAgdGhpcy5taXNzaW5nVHJhbnNsYXRpb24gPSBtaXNzaW5nVHJhbnNsYXRpb247XG4gICAgICAgIHRoaXMucHJlc2VydmVXaGl0ZXNwYWNlcyA9IHByZXNlcnZlV2hpdGVzcGFjZXNEZWZhdWx0KG5vVW5kZWZpbmVkKHByZXNlcnZlV2hpdGVzcGFjZXMpKTtcbiAgICAgICAgdGhpcy5zdHJpY3RJbmplY3Rpb25QYXJhbWV0ZXJzID0gc3RyaWN0SW5qZWN0aW9uUGFyYW1ldGVycyA9PT0gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVzZXJ2ZVdoaXRlc3BhY2VzRGVmYXVsdChwcmVzZXJ2ZVdoaXRlc3BhY2VzT3B0aW9uLCBkZWZhdWx0U2V0dGluZyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHByZXNlcnZlV2hpdGVzcGFjZXNPcHRpb24gPT09IG51bGwgPyBkZWZhdWx0U2V0dGluZyA6IHByZXNlcnZlV2hpdGVzcGFjZXNPcHRpb247XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgX0kxOE5fQVRUUiA9ICdpMThuJztcbmNvbnN0IF9JMThOX0FUVFJfUFJFRklYID0gJ2kxOG4tJztcbmNvbnN0IF9JMThOX0NPTU1FTlRfUFJFRklYX1JFR0VYUCA9IC9eaTE4bjo/LztcbmNvbnN0IE1FQU5JTkdfU0VQQVJBVE9SID0gJ3wnO1xuY29uc3QgSURfU0VQQVJBVE9SID0gJ0BAJztcbmxldCBpMThuQ29tbWVudHNXYXJuZWQgPSBmYWxzZTtcbi8qKlxuICogRXh0cmFjdCB0cmFuc2xhdGFibGUgbWVzc2FnZXMgZnJvbSBhbiBodG1sIEFTVFxuICovXG5mdW5jdGlvbiBleHRyYWN0TWVzc2FnZXMobm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICByZXR1cm4gdmlzaXRvci5leHRyYWN0KG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbn1cbmZ1bmN0aW9uIG1lcmdlVHJhbnNsYXRpb25zKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcsIGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycykge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX1Zpc2l0b3IoaW1wbGljaXRUYWdzLCBpbXBsaWNpdEF0dHJzKTtcbiAgICByZXR1cm4gdmlzaXRvci5tZXJnZShub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbn1cbmNsYXNzIEV4dHJhY3Rpb25SZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2VzLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG59XG52YXIgX1Zpc2l0b3JNb2RlO1xuKGZ1bmN0aW9uIChfVmlzaXRvck1vZGUpIHtcbiAgICBfVmlzaXRvck1vZGVbX1Zpc2l0b3JNb2RlW1wiRXh0cmFjdFwiXSA9IDBdID0gXCJFeHRyYWN0XCI7XG4gICAgX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZVtcIk1lcmdlXCJdID0gMV0gPSBcIk1lcmdlXCI7XG59KShfVmlzaXRvck1vZGUgfHwgKF9WaXNpdG9yTW9kZSA9IHt9KSk7XG4vKipcbiAqIFRoaXMgVmlzaXRvciBpcyB1c2VkOlxuICogMS4gdG8gZXh0cmFjdCBhbGwgdGhlIHRyYW5zbGF0YWJsZSBzdHJpbmdzIGZyb20gYW4gaHRtbCBBU1QgKHNlZSBgZXh0cmFjdCgpYCksXG4gKiAyLiB0byByZXBsYWNlIHRoZSB0cmFuc2xhdGFibGUgc3RyaW5ncyB3aXRoIHRoZSBhY3R1YWwgdHJhbnNsYXRpb25zIChzZWUgYG1lcmdlKClgKVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBfVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoX2ltcGxpY2l0VGFncywgX2ltcGxpY2l0QXR0cnMpIHtcbiAgICAgICAgdGhpcy5faW1wbGljaXRUYWdzID0gX2ltcGxpY2l0VGFncztcbiAgICAgICAgdGhpcy5faW1wbGljaXRBdHRycyA9IF9pbXBsaWNpdEF0dHJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgbWVzc2FnZXMgZnJvbSB0aGUgdHJlZVxuICAgICAqL1xuICAgIGV4dHJhY3Qobm9kZXMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdGhpcy5faW5pdChfVmlzaXRvck1vZGUuRXh0cmFjdCwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLnZpc2l0KHRoaXMsIG51bGwpKTtcbiAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgJ1VuY2xvc2VkIGJsb2NrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFeHRyYWN0aW9uUmVzdWx0KHRoaXMuX21lc3NhZ2VzLCB0aGlzLl9lcnJvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdHJlZSB3aGVyZSBhbGwgdHJhbnNsYXRhYmxlIG5vZGVzIGFyZSB0cmFuc2xhdGVkXG4gICAgICovXG4gICAgbWVyZ2Uobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB0aGlzLl9pbml0KF9WaXNpdG9yTW9kZS5NZXJnZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0aW9ucyA9IHRyYW5zbGF0aW9ucztcbiAgICAgICAgLy8gQ29uc3RydWN0IGEgc2luZ2xlIGZha2Ugcm9vdCBlbGVtZW50XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgRWxlbWVudCgnd3JhcHBlcicsIFtdLCBub2RlcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZWROb2RlID0gd3JhcHBlci52aXNpdCh0aGlzLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgJ1VuY2xvc2VkIGJsb2NrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVRyZWVSZXN1bHQodHJhbnNsYXRlZE5vZGUuY2hpbGRyZW4sIHRoaXMuX2Vycm9ycyk7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIFBhcnNlIGNhc2VzIGZvciB0cmFuc2xhdGFibGUgaHRtbCBhdHRyaWJ1dGVzXG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4cGFuc2lvbkNhc2UoaWN1Q2FzZS52YWx1ZSwgZXhwcmVzc2lvbiwgaWN1Q2FzZS5zb3VyY2VTcGFuLCBpY3VDYXNlLnZhbHVlU291cmNlU3BhbiwgaWN1Q2FzZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGljdSk7XG4gICAgICAgIGNvbnN0IHdhc0luSWN1ID0gdGhpcy5faW5JY3U7XG4gICAgICAgIGlmICghdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIC8vIG5lc3RlZCBJQ1UgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBleHRyYWN0ZWQgYnV0IHRvcC1sZXZlbCB0cmFuc2xhdGVkIGFzIGEgd2hvbGVcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoW2ljdV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faW5JY3UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhc2VzID0gdmlzaXRBbGwodGhpcywgaWN1LmNhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgaWN1ID0gbmV3IEV4cGFuc2lvbihpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlcywgaWN1LnNvdXJjZVNwYW4sIGljdS5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luSWN1ID0gd2FzSW5JY3U7XG4gICAgICAgIHJldHVybiBpY3U7XG4gICAgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGlzT3BlbmluZyA9IF9pc09wZW5pbmdDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICBpZiAoaXNPcGVuaW5nICYmIHRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnQ291bGQgbm90IHN0YXJ0IGEgYmxvY2sgaW5zaWRlIGEgdHJhbnNsYXRhYmxlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0Nsb3NpbmcgPSBfaXNDbG9zaW5nQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgaWYgKGlzQ2xvc2luZyAmJiAhdGhpcy5faW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbW1lbnQsICdUcnlpbmcgdG8gY2xvc2UgYW4gdW5vcGVuZWQgYmxvY2snKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2luSTE4bk5vZGUgJiYgIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3BlbmluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkIGZyb20gdjUgeW91IHNob3VsZCB1c2UgPG5nLWNvbnRhaW5lciBpMThuPiBpbnN0ZWFkIG9mIGkxOG4gY29tbWVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpMThuQ29tbWVudHNXYXJuZWQgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkxOG5Db21tZW50c1dhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gY29tbWVudC5zb3VyY2VTcGFuLmRldGFpbHMgPyBgLCAke2NvbW1lbnQuc291cmNlU3Bhbi5kZXRhaWxzfWAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8ob2NvbWJlKTogdXNlIGEgbG9nIHNlcnZpY2Ugb25jZSB0aGVyZSBpcyBhIHB1YmxpYyBvbmUgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEkxOG4gY29tbWVudHMgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhbiA8bmctY29udGFpbmVyPiBlbGVtZW50IGluc3RlYWQgKCR7Y29tbWVudC5zb3VyY2VTcGFuLnN0YXJ0fSR7ZGV0YWlsc30pYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja1N0YXJ0RGVwdGggPSB0aGlzLl9kZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQudmFsdWUucmVwbGFjZShfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAsICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc0Nsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlcHRoID09IHRoaXMuX2Jsb2NrU3RhcnREZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uKGNvbW1lbnQsIHRoaXMuX2Jsb2NrQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5JMThuQmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9hZGRNZXNzYWdlKHRoaXMuX2Jsb2NrQ2hpbGRyZW4sIHRoaXMuX2Jsb2NrTWVhbmluZ0FuZERlc2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2UgYXR0cmlidXRlcyBpbiBzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLl90cmFuc2xhdGVNZXNzYWdlKGNvbW1lbnQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0QWxsKHRoaXMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGNvbW1lbnQsICdJMThOIGJsb2NrcyBzaG91bGQgbm90IGNyb3NzIGVsZW1lbnQgYm91bmRhcmllcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fbWF5QmVBZGRCbG9ja0NoaWxkcmVuKGVsKTtcbiAgICAgICAgdGhpcy5fZGVwdGgrKztcbiAgICAgICAgY29uc3Qgd2FzSW5JMThuTm9kZSA9IHRoaXMuX2luSTE4bk5vZGU7XG4gICAgICAgIGNvbnN0IHdhc0luSW1wbGljaXROb2RlID0gdGhpcy5faW5JbXBsaWNpdE5vZGU7XG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gW107XG4gICAgICAgIGxldCB0cmFuc2xhdGVkQ2hpbGROb2RlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gRXh0cmFjdDpcbiAgICAgICAgLy8gLSB0b3AgbGV2ZWwgbm9kZXMgd2l0aCB0aGUgKGltcGxpY2l0KSBcImkxOG5cIiBhdHRyaWJ1dGUgaWYgbm90IGFscmVhZHkgaW4gYSBzZWN0aW9uXG4gICAgICAgIC8vIC0gSUNVIG1lc3NhZ2VzXG4gICAgICAgIGNvbnN0IGkxOG5BdHRyID0gX2dldEkxOG5BdHRyKGVsKTtcbiAgICAgICAgY29uc3QgaTE4bk1ldGEgPSBpMThuQXR0ciA/IGkxOG5BdHRyLnZhbHVlIDogJyc7XG4gICAgICAgIGNvbnN0IGlzSW1wbGljaXQgPSB0aGlzLl9pbXBsaWNpdFRhZ3Muc29tZSh0YWcgPT4gZWwubmFtZSA9PT0gdGFnKSAmJiAhdGhpcy5faW5JY3UgJiZcbiAgICAgICAgICAgICF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbjtcbiAgICAgICAgY29uc3QgaXNUb3BMZXZlbEltcGxpY2l0ID0gIXdhc0luSW1wbGljaXROb2RlICYmIGlzSW1wbGljaXQ7XG4gICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gd2FzSW5JbXBsaWNpdE5vZGUgfHwgaXNJbXBsaWNpdDtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbiAmJiAhdGhpcy5faW5JY3UpIHtcbiAgICAgICAgICAgIGlmIChpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fYWRkTWVzc2FnZShlbC5jaGlsZHJlbiwgaTE4bk1ldGEpO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRDaGlsZE5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShlbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PSBfVmlzaXRvck1vZGUuRXh0cmFjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVHJhbnNsYXRhYmxlID0gaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0O1xuICAgICAgICAgICAgICAgIGlmIChpc1RyYW5zbGF0YWJsZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24oZWwpO1xuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUcmFuc2xhdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbihlbCwgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCAnQ291bGQgbm90IG1hcmsgYW4gZWxlbWVudCBhcyB0cmFuc2xhdGFibGUgaW5zaWRlIGEgdHJhbnNsYXRhYmxlIHNlY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlID09IF9WaXNpdG9yTW9kZS5FeHRyYWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gRGVzY2VuZCBpbnRvIGNoaWxkIG5vZGVzIGZvciBleHRyYWN0aW9uXG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpc2l0Tm9kZXMgPSB0cmFuc2xhdGVkQ2hpbGROb2RlcyB8fCBlbC5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZpc2l0Tm9kZXMuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzaXRlZCA9IGNoaWxkLnZpc2l0KHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkICYmICF0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIHRoZSBjaGlsZHJlbiBmcm9tIHRyYW5zbGF0YWJsZSBzZWN0aW9ucyAoPSBpMThuIGJsb2NrcyBoZXJlKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdpbGwgYmUgYWRkZWQgbGF0ZXIgaW4gdGhpcyBsb29wIHdoZW4gdGhlIGJsb2NrIGNsb3NlcyAoaS5lLiBvbiBgPCEtLSAvaTE4biAtLT5gKVxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gY2hpbGROb2Rlcy5jb25jYXQodmlzaXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaXRBdHRyaWJ1dGVzT2YoZWwpO1xuICAgICAgICB0aGlzLl9kZXB0aC0tO1xuICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gd2FzSW5JMThuTm9kZTtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSB3YXNJbkltcGxpY2l0Tm9kZTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRlZEF0dHJzID0gdGhpcy5fdHJhbnNsYXRlQXR0cmlidXRlcyhlbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnQoZWwubmFtZSwgdHJhbnNsYXRlZEF0dHJzLCBjaGlsZE5vZGVzLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgfVxuICAgIF9pbml0KG1vZGUsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luSTE4bk5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVwdGggPSAwO1xuICAgICAgICB0aGlzLl9pbkljdSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5JbXBsaWNpdE5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UgPSBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGxvb2tzIGZvciB0cmFuc2xhdGFibGUgYXR0cmlidXRlc1xuICAgIF92aXNpdEF0dHJpYnV0ZXNPZihlbCkge1xuICAgICAgICBjb25zdCBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZSA9IHt9O1xuICAgICAgICBjb25zdCBpbXBsaWNpdEF0dHJOYW1lcyA9IHRoaXMuX2ltcGxpY2l0QXR0cnNbZWwubmFtZV0gfHwgW107XG4gICAgICAgIGVsLmF0dHJzLmZpbHRlcihhdHRyID0+IGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGF0dHIgPT4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lLnNsaWNlKF9JMThOX0FUVFJfUFJFRklYLmxlbmd0aCldID1cbiAgICAgICAgICAgIGF0dHIudmFsdWUpO1xuICAgICAgICBlbC5hdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dHIubmFtZSBpbiBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdLCBleHBsaWNpdEF0dHJOYW1lVG9WYWx1ZVthdHRyLm5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGltcGxpY2l0QXR0ck5hbWVzLnNvbWUobmFtZSA9PiBhdHRyLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZShbYXR0cl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgdHJhbnNsYXRhYmxlIG1lc3NhZ2VcbiAgICBfYWRkTWVzc2FnZShhc3QsIG1zZ01ldGEpIHtcbiAgICAgICAgaWYgKGFzdC5sZW5ndGggPT0gMCB8fFxuICAgICAgICAgICAgYXN0Lmxlbmd0aCA9PSAxICYmIGFzdFswXSBpbnN0YW5jZW9mIEF0dHJpYnV0ZSAmJiAhYXN0WzBdLnZhbHVlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgY3JlYXRlIGVtcHR5IG1lc3NhZ2VzXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCB9ID0gX3BhcnNlTWVzc2FnZU1ldGEobXNnTWV0YSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZShhc3QsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICAvLyBUcmFuc2xhdGVzIHRoZSBnaXZlbiBtZXNzYWdlIGdpdmVuIHRoZSBgVHJhbnNsYXRpb25CdW5kbGVgXG4gICAgLy8gVGhpcyBpcyB1c2VkIGZvciB0cmFuc2xhdGluZyBlbGVtZW50cyAvIGJsb2NrcyAtIHNlZSBgX3RyYW5zbGF0ZUF0dHJpYnV0ZXNgIGZvciBhdHRyaWJ1dGVzXG4gICAgLy8gbm8tb3Agd2hlbiBjYWxsZWQgaW4gZXh0cmFjdGlvbiBtb2RlIChyZXR1cm5zIFtdKVxuICAgIF90cmFuc2xhdGVNZXNzYWdlKGVsLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlICYmIHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLl90cmFuc2xhdGlvbnMuZ2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsIGBUcmFuc2xhdGlvbiB1bmF2YWlsYWJsZSBmb3IgbWVzc2FnZSBpZD1cIiR7dGhpcy5fdHJhbnNsYXRpb25zLmRpZ2VzdChtZXNzYWdlKX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gdHJhbnNsYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIGFuIGVsZW1lbnQgYW5kIHJlbW92ZSBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICBfdHJhbnNsYXRlQXR0cmlidXRlcyhlbCkge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gZWwuYXR0cnM7XG4gICAgICAgIGNvbnN0IGkxOG5QYXJzZWRNZXNzYWdlTWV0YSA9IHt9O1xuICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lLnN0YXJ0c1dpdGgoX0kxOE5fQVRUUl9QUkVGSVgpKSB7XG4gICAgICAgICAgICAgICAgaTE4blBhcnNlZE1lc3NhZ2VNZXRhW2F0dHIubmFtZS5zbGljZShfSTE4Tl9BVFRSX1BSRUZJWC5sZW5ndGgpXSA9XG4gICAgICAgICAgICAgICAgICAgIF9wYXJzZU1lc3NhZ2VNZXRhKGF0dHIudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlZEF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBfSTE4Tl9BVFRSIHx8IGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGkxOG4gc3BlY2lmaWMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyLnZhbHVlICYmIGF0dHIudmFsdWUgIT0gJycgJiYgaTE4blBhcnNlZE1lc3NhZ2VNZXRhLmhhc093blByb3BlcnR5KGF0dHIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCB9ID0gaTE4blBhcnNlZE1lc3NhZ2VNZXRhW2F0dHIubmFtZV07XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlKFthdHRyXSwgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlcyA9IHRoaXMuX3RyYW5zbGF0aW9ucy5nZXQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlKGF0dHIubmFtZSwgJycsIGF0dHIuc291cmNlU3BhbiwgdW5kZWZpbmVkIC8qIGtleVNwYW4gKi8sIHVuZGVmaW5lZCAvKiB2YWx1ZVNwYW4gKi8sIHVuZGVmaW5lZCAvKiB2YWx1ZVRva2VucyAqLywgdW5kZWZpbmVkIC8qIGkxOG4gKi8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2Rlc1swXSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZXNbMF0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQXR0cmlidXRlcy5wdXNoKG5ldyBBdHRyaWJ1dGUoYXR0ci5uYW1lLCB2YWx1ZSwgYXR0ci5zb3VyY2VTcGFuLCB1bmRlZmluZWQgLyoga2V5U3BhbiAqLywgdW5kZWZpbmVkIC8qIHZhbHVlU3BhbiAqLywgdW5kZWZpbmVkIC8qIHZhbHVlVG9rZW5zICovLCB1bmRlZmluZWQgLyogaTE4biAqLykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZWwsIGBVbmV4cGVjdGVkIHRyYW5zbGF0aW9uIGZvciBhdHRyaWJ1dGUgXCIke2F0dHIubmFtZX1cIiAoaWQ9XCIke2lkIHx8IHRoaXMuX3RyYW5zbGF0aW9ucy5kaWdlc3QobWVzc2FnZSl9XCIpYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCBgVHJhbnNsYXRpb24gdW5hdmFpbGFibGUgZm9yIGF0dHJpYnV0ZSBcIiR7YXR0ci5uYW1lfVwiIChpZD1cIiR7aWQgfHwgdGhpcy5fdHJhbnNsYXRpb25zLmRpZ2VzdChtZXNzYWdlKX1cIilgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQXR0cmlidXRlcy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIG5vZGUgYXMgYSBjaGlsZCBvZiB0aGUgYmxvY2sgd2hlbjpcbiAgICAgKiAtIHdlIGFyZSBpbiBhIGJsb2NrLFxuICAgICAqIC0gd2UgYXJlIG5vdCBpbnNpZGUgYSBJQ1UgbWVzc2FnZSAodGhvc2UgYXJlIGhhbmRsZWQgc2VwYXJhdGVseSksXG4gICAgICogLSB0aGUgbm9kZSBpcyBhIFwiZGlyZWN0IGNoaWxkXCIgb2YgdGhlIGJsb2NrXG4gICAgICovXG4gICAgX21heUJlQWRkQmxvY2tDaGlsZHJlbihub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jayAmJiAhdGhpcy5faW5JY3UgJiYgdGhpcy5fZGVwdGggPT0gdGhpcy5fYmxvY2tTdGFydERlcHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9ibG9ja0NoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIHN0YXJ0IG9mIGEgc2VjdGlvbiwgc2VlIGBfY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uYFxuICAgICAqL1xuICAgIF9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbihub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZSwgJ1VuZXhwZWN0ZWQgc2VjdGlvbiBzdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHRyYW5zbGF0YWJsZSBzZWN0aW9uIGNvdWxkIGJlOlxuICAgICAqIC0gdGhlIGNvbnRlbnQgb2YgdHJhbnNsYXRhYmxlIGVsZW1lbnQsXG4gICAgICogLSBub2RlcyBiZXR3ZWVuIGA8IS0tIGkxOG4gLS0+YCBhbmQgYDwhLS0gL2kxOG4gLS0+YCBjb21tZW50c1xuICAgICAqL1xuICAgIGdldCBfaXNJblRyYW5zbGF0YWJsZVNlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0ZXMgYSBzZWN0aW9uLlxuICAgICAqXG4gICAgICogSWYgYSBzZWN0aW9uIGhhcyBvbmx5IG9uZSBzaWduaWZpY2FudCBjaGlsZHJlbiAoY29tbWVudHMgbm90IHNpZ25pZmljYW50KSB0aGVuIHdlIHNob3VsZCBub3RcbiAgICAgKiBrZWVwIHRoZSBtZXNzYWdlIGZyb20gdGhpcyBjaGlsZHJlbjpcbiAgICAgKlxuICAgICAqIGA8cCBpMThuPVwibWVhbmluZ3xkZXNjcmlwdGlvblwiPntJQ1UgbWVzc2FnZX08L3A+YCB3b3VsZCBwcm9kdWNlIHR3byBtZXNzYWdlczpcbiAgICAgKiAtIG9uZSBmb3IgdGhlIDxwPiBjb250ZW50IHdpdGggbWVhbmluZyBhbmQgZGVzY3JpcHRpb24sXG4gICAgICogLSBhbm90aGVyIG9uZSBmb3IgdGhlIElDVSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogSW4gdGhpcyBjYXNlIHRoZSBsYXN0IG1lc3NhZ2UgaXMgZGlzY2FyZGVkIGFzIGl0IGNvbnRhaW5zIGxlc3MgaW5mb3JtYXRpb24gKHRoZSBBU1QgaXNcbiAgICAgKiBvdGhlcndpc2UgaWRlbnRpY2FsKS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3ZSBzaG91bGQgc3RpbGwga2VlcCBtZXNzYWdlcyBleHRyYWN0ZWQgZnJvbSBhdHRyaWJ1dGVzIGluc2lkZSB0aGUgc2VjdGlvbiAoaWUgaW4gdGhlXG4gICAgICogSUNVIG1lc3NhZ2UgaGVyZSlcbiAgICAgKi9cbiAgICBfY2xvc2VUcmFuc2xhdGFibGVTZWN0aW9uKG5vZGUsIGRpcmVjdENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGUsICdVbmV4cGVjdGVkIHNlY3Rpb24gZW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQ7XG4gICAgICAgIGNvbnN0IHNpZ25pZmljYW50Q2hpbGRyZW4gPSBkaXJlY3RDaGlsZHJlbi5yZWR1Y2UoKGNvdW50LCBub2RlKSA9PiBjb3VudCArIChub2RlIGluc3RhbmNlb2YgQ29tbWVudCA/IDAgOiAxKSwgMCk7XG4gICAgICAgIGlmIChzaWduaWZpY2FudENoaWxkcmVuID09IDEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGggLSAxOyBpID49IHN0YXJ0SW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzdCA9IHRoaXMuX21lc3NhZ2VzW2ldLm5vZGVzO1xuICAgICAgICAgICAgICAgIGlmICghKGFzdC5sZW5ndGggPT0gMSAmJiBhc3RbMF0gaW5zdGFuY2VvZiBUZXh0JDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF9yZXBvcnRFcnJvcihub2RlLCBtc2cpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1zZykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9pc09wZW5pbmdDb21tZW50KG4pIHtcbiAgICByZXR1cm4gISEobiBpbnN0YW5jZW9mIENvbW1lbnQgJiYgbi52YWx1ZSAmJiBuLnZhbHVlLnN0YXJ0c1dpdGgoJ2kxOG4nKSk7XG59XG5mdW5jdGlvbiBfaXNDbG9zaW5nQ29tbWVudChuKSB7XG4gICAgcmV0dXJuICEhKG4gaW5zdGFuY2VvZiBDb21tZW50ICYmIG4udmFsdWUgJiYgbi52YWx1ZSA9PT0gJy9pMThuJyk7XG59XG5mdW5jdGlvbiBfZ2V0STE4bkF0dHIocCkge1xuICAgIHJldHVybiBwLmF0dHJzLmZpbmQoYXR0ciA9PiBhdHRyLm5hbWUgPT09IF9JMThOX0FUVFIpIHx8IG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VNZXNzYWdlTWV0YShpMThuKSB7XG4gICAgaWYgKCFpMThuKVxuICAgICAgICByZXR1cm4geyBtZWFuaW5nOiAnJywgZGVzY3JpcHRpb246ICcnLCBpZDogJycgfTtcbiAgICBjb25zdCBpZEluZGV4ID0gaTE4bi5pbmRleE9mKElEX1NFUEFSQVRPUik7XG4gICAgY29uc3QgZGVzY0luZGV4ID0gaTE4bi5pbmRleE9mKE1FQU5JTkdfU0VQQVJBVE9SKTtcbiAgICBjb25zdCBbbWVhbmluZ0FuZERlc2MsIGlkXSA9IChpZEluZGV4ID4gLTEpID8gW2kxOG4uc2xpY2UoMCwgaWRJbmRleCksIGkxOG4uc2xpY2UoaWRJbmRleCArIDIpXSA6IFtpMThuLCAnJ107XG4gICAgY29uc3QgW21lYW5pbmcsIGRlc2NyaXB0aW9uXSA9IChkZXNjSW5kZXggPiAtMSkgP1xuICAgICAgICBbbWVhbmluZ0FuZERlc2Muc2xpY2UoMCwgZGVzY0luZGV4KSwgbWVhbmluZ0FuZERlc2Muc2xpY2UoZGVzY0luZGV4ICsgMSldIDpcbiAgICAgICAgWycnLCBtZWFuaW5nQW5kRGVzY107XG4gICAgcmV0dXJuIHsgbWVhbmluZywgZGVzY3JpcHRpb24sIGlkOiBpZC50cmltKCkgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBYbWxUYWdEZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICB0aGlzLnByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXF1aXJlRXh0cmFQYXJlbnQoY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzQ2xvc2VkQnlDaGlsZChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0Q29udGVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLlRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEE7XG4gICAgfVxufVxuY29uc3QgX1RBR19ERUZJTklUSU9OID0gbmV3IFhtbFRhZ0RlZmluaXRpb24oKTtcbmZ1bmN0aW9uIGdldFhtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgIHJldHVybiBfVEFHX0RFRklOSVRJT047XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgWG1sUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZ2V0WG1sVGFnRGVmaW5pdGlvbik7XG4gICAgfVxuICAgIHBhcnNlKHNvdXJjZSwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZShzb3VyY2UsIHVybCwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IF9WRVJTSU9OJDEgPSAnMS4yJztcbmNvbnN0IF9YTUxOUyQxID0gJ3VybjpvYXNpczpuYW1lczp0Yzp4bGlmZjpkb2N1bWVudDoxLjInO1xuLy8gVE9ETyh2aWNiKTogbWFrZSB0aGlzIGEgcGFyYW0gKHMvXy8tLylcbmNvbnN0IF9ERUZBVUxUX1NPVVJDRV9MQU5HJDEgPSAnZW4nO1xuY29uc3QgX1BMQUNFSE9MREVSX1RBRyQyID0gJ3gnO1xuY29uc3QgX01BUktFUl9UQUckMSA9ICdtcmsnO1xuY29uc3QgX0ZJTEVfVEFHID0gJ2ZpbGUnO1xuY29uc3QgX1NPVVJDRV9UQUckMSA9ICdzb3VyY2UnO1xuY29uc3QgX1NFR01FTlRfU09VUkNFX1RBRyA9ICdzZWctc291cmNlJztcbmNvbnN0IF9BTFRfVFJBTlNfVEFHID0gJ2FsdC10cmFucyc7XG5jb25zdCBfVEFSR0VUX1RBRyQxID0gJ3RhcmdldCc7XG5jb25zdCBfVU5JVF9UQUckMSA9ICd0cmFucy11bml0JztcbmNvbnN0IF9DT05URVhUX0dST1VQX1RBRyA9ICdjb250ZXh0LWdyb3VwJztcbmNvbnN0IF9DT05URVhUX1RBRyA9ICdjb250ZXh0Jztcbi8vIGh0dHBzOi8vZG9jcy5vYXNpcy1vcGVuLm9yZy94bGlmZi92MS4yL29zL3hsaWZmLWNvcmUuaHRtbFxuLy8gaHR0cHM6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL3hsaWZmL3YxLjIveGxpZmYtcHJvZmlsZS1odG1sL3hsaWZmLXByb2ZpbGUtaHRtbC0xLjIuaHRtbFxuY2xhc3MgWGxpZmYgZXh0ZW5kcyBTZXJpYWxpemVyIHtcbiAgICB3cml0ZShtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX1dyaXRlVmlzaXRvciQxKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zVW5pdHMgPSBbXTtcbiAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgIGxldCBjb250ZXh0VGFncyA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZXh0R3JvdXBUYWcgPSBuZXcgVGFnKF9DT05URVhUX0dST1VQX1RBRywgeyBwdXJwb3NlOiAnbG9jYXRpb24nIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRleHRHcm91cFRhZy5jaGlsZHJlbi5wdXNoKG5ldyBDUigxMCksIG5ldyBUYWcoX0NPTlRFWFRfVEFHLCB7ICdjb250ZXh0LXR5cGUnOiAnc291cmNlZmlsZScgfSwgW25ldyBUZXh0JDEoc291cmNlLmZpbGVQYXRoKV0pLCBuZXcgQ1IoMTApLCBuZXcgVGFnKF9DT05URVhUX1RBRywgeyAnY29udGV4dC10eXBlJzogJ2xpbmVudW1iZXInIH0sIFtuZXcgVGV4dCQxKGAke3NvdXJjZS5zdGFydExpbmV9YCldKSwgbmV3IENSKDgpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0VGFncy5wdXNoKG5ldyBDUig4KSwgY29udGV4dEdyb3VwVGFnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNVbml0ID0gbmV3IFRhZyhfVU5JVF9UQUckMSwgeyBpZDogbWVzc2FnZS5pZCwgZGF0YXR5cGU6ICdodG1sJyB9KTtcbiAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZyhfU09VUkNFX1RBRyQxLCB7fSwgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpLCAuLi5jb250ZXh0VGFncyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgcHJpb3JpdHk6ICcxJywgZnJvbTogJ2Rlc2NyaXB0aW9uJyB9LCBbbmV3IFRleHQkMShtZXNzYWdlLmRlc2NyaXB0aW9uKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lYW5pbmcpIHtcbiAgICAgICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IHByaW9yaXR5OiAnMScsIGZyb206ICdtZWFuaW5nJyB9LCBbbmV3IFRleHQkMShtZXNzYWdlLm1lYW5pbmcpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgIHRyYW5zVW5pdHMucHVzaChuZXcgQ1IoNiksIHRyYW5zVW5pdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBib2R5ID0gbmV3IFRhZygnYm9keScsIHt9LCBbLi4udHJhbnNVbml0cywgbmV3IENSKDQpXSk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgVGFnKCdmaWxlJywge1xuICAgICAgICAgICAgJ3NvdXJjZS1sYW5ndWFnZSc6IGxvY2FsZSB8fCBfREVGQVVMVF9TT1VSQ0VfTEFORyQxLFxuICAgICAgICAgICAgZGF0YXR5cGU6ICdwbGFpbnRleHQnLFxuICAgICAgICAgICAgb3JpZ2luYWw6ICduZzIudGVtcGxhdGUnLFxuICAgICAgICB9LCBbbmV3IENSKDQpLCBib2R5LCBuZXcgQ1IoMildKTtcbiAgICAgICAgY29uc3QgeGxpZmYgPSBuZXcgVGFnKCd4bGlmZicsIHsgdmVyc2lvbjogX1ZFUlNJT04kMSwgeG1sbnM6IF9YTUxOUyQxIH0sIFtuZXcgQ1IoMiksIGZpbGUsIG5ldyBDUigpXSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemUoW1xuICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uKHsgdmVyc2lvbjogJzEuMCcsIGVuY29kaW5nOiAnVVRGLTgnIH0pLCBuZXcgQ1IoKSwgeGxpZmYsIG5ldyBDUigpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBsb2FkKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4bGlmZiB0byB4bWwgbm9kZXNcbiAgICAgICAgY29uc3QgeGxpZmZQYXJzZXIgPSBuZXcgWGxpZmZQYXJzZXIoKTtcbiAgICAgICAgY29uc3QgeyBsb2NhbGUsIG1zZ0lkVG9IdG1sLCBlcnJvcnMgfSA9IHhsaWZmUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCk7XG4gICAgICAgIC8vIHhtbCBub2RlcyB0byBpMThuIG5vZGVzXG4gICAgICAgIGNvbnN0IGkxOG5Ob2Rlc0J5TXNnSWQgPSB7fTtcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gbmV3IFhtbFRvSTE4biQyKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKG1zZ0lkVG9IdG1sKS5mb3JFYWNoKG1zZ0lkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaTE4bk5vZGVzLCBlcnJvcnM6IGUgfSA9IGNvbnZlcnRlci5jb252ZXJ0KG1zZ0lkVG9IdG1sW21zZ0lkXSwgdXJsKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmUpO1xuICAgICAgICAgICAgaTE4bk5vZGVzQnlNc2dJZFttc2dJZF0gPSBpMThuTm9kZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB4bGlmZiBwYXJzZSBlcnJvcnM6XFxuJHtlcnJvcnMuam9pbignXFxuJyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbG9jYWxlOiBsb2NhbGUsIGkxOG5Ob2Rlc0J5TXNnSWQgfTtcbiAgICB9XG4gICAgZGlnZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRpZ2VzdCQxKG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNsYXNzIF9Xcml0ZVZpc2l0b3IkMSB7XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGV4dCQxKHRleHQudmFsdWUpXTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKChub2RlKSA9PiBub2Rlcy5wdXNoKC4uLm5vZGUudmlzaXQodGhpcykpKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICB2aXNpdEljdShpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbbmV3IFRleHQkMShgeyR7aWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlcn0sICR7aWN1LnR5cGV9LCBgKV07XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5jYXNlcykuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKGAke2N9IHtgKSwgLi4uaWN1LmNhc2VzW2NdLnZpc2l0KHRoaXMpLCBuZXcgVGV4dCQxKGB9IGApKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShgfWApKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGN0eXBlID0gZ2V0Q3R5cGVGb3JUYWcocGgudGFnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMiwgeyBpZDogcGguc3RhcnROYW1lLCBjdHlwZSwgJ2VxdWl2LXRleHQnOiBgPCR7cGgudGFnfS8+YCB9KV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IGlkOiBwaC5zdGFydE5hbWUsIGN0eXBlLCAnZXF1aXYtdGV4dCc6IGA8JHtwaC50YWd9PmAgfSk7XG4gICAgICAgIGNvbnN0IGNsb3NlVGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMiwgeyBpZDogcGguY2xvc2VOYW1lLCBjdHlwZSwgJ2VxdWl2LXRleHQnOiBgPC8ke3BoLnRhZ30+YCB9KTtcbiAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoLCAuLi50aGlzLnNlcmlhbGl6ZShwaC5jaGlsZHJlbiksIGNsb3NlVGFnUGhdO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgaWQ6IHBoLm5hbWUsICdlcXVpdi10ZXh0JzogYHt7JHtwaC52YWx1ZX19fWAgfSldO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGVxdWl2VGV4dCA9IGB7JHtwaC52YWx1ZS5leHByZXNzaW9ufSwgJHtwaC52YWx1ZS50eXBlfSwgJHtPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKyAnIHsuLi59Jykuam9pbignICcpfX1gO1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IGlkOiBwaC5uYW1lLCAnZXF1aXYtdGV4dCc6IGVxdWl2VGV4dCB9KV07XG4gICAgfVxuICAgIHNlcmlhbGl6ZShub2Rlcykge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KC4uLm5vZGVzLm1hcChub2RlID0+IG5vZGUudmlzaXQodGhpcykpKTtcbiAgICB9XG59XG4vLyBUT0RPKHZpY2IpOiBhZGQgZXJyb3IgbWFuYWdlbWVudCAoc3RydWN0dXJlKVxuLy8gRXh0cmFjdCBtZXNzYWdlcyBhcyB4bWwgbm9kZXMgZnJvbSB0aGUgeGxpZmYgZmlsZVxuY2xhc3MgWGxpZmZQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICBwYXJzZSh4bGlmZiwgdXJsKSB7XG4gICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sID0ge307XG4gICAgICAgIGNvbnN0IHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4bGlmZiwgdXJsKTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sLmVycm9ycztcbiAgICAgICAgdmlzaXRBbGwodGhpcywgeG1sLnJvb3ROb2RlcywgbnVsbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2dJZFRvSHRtbDogdGhpcy5fbXNnSWRUb0h0bWwsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBfVU5JVF9UQUckMTpcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgPCR7X1VOSVRfVEFHJDF9PiBtaXNzZXMgdGhlIFwiaWRcIiBhdHRyaWJ1dGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gaWRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWRUb0h0bWwuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgRHVwbGljYXRlZCB0cmFuc2xhdGlvbnMgZm9yIG1zZyAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3VuaXRNbFN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbFtpZF0gPSB0aGlzLl91bml0TWxTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgTWVzc2FnZSAke2lkfSBtaXNzZXMgYSB0cmFuc2xhdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gaWdub3JlIHRob3NlIHRhZ3NcbiAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUckMTpcbiAgICAgICAgICAgIGNhc2UgX1NFR01FTlRfU09VUkNFX1RBRzpcbiAgICAgICAgICAgIGNhc2UgX0FMVF9UUkFOU19UQUc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHJDE6XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJUZXh0U3RhcnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyVGV4dEVuZCA9IGVsZW1lbnQuZW5kU291cmNlU3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLnN0YXJ0LmZpbGUuY29udGVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHQgPSBjb250ZW50LnNsaWNlKGlubmVyVGV4dFN0YXJ0LCBpbm5lclRleHRFbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IGlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX0ZJTEVfVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZUF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ3RhcmdldC1sYW5ndWFnZScpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZUF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHZpY2IpOiBhc3NlcnQgZmlsZSBzdHJ1Y3R1cmUsIHhsaWZmIHZlcnNpb25cbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93IG9ubHkgcmVjdXJzZSBvbiB1bmhhbmRsZWQgbm9kZXNcbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uLCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0IG1sIG5vZGVzICh4bGlmZiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbmNsYXNzIFhtbFRvSTE4biQyIHtcbiAgICBjb252ZXJ0KG1lc3NhZ2UsIHVybCkge1xuICAgICAgICBjb25zdCB4bWxJY3UgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UobWVzc2FnZSwgdXJsLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbEljdS5lcnJvcnM7XG4gICAgICAgIGNvbnN0IGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgW10uY29uY2F0KC4uLnZpc2l0QWxsKHRoaXMsIHhtbEljdS5yb290Tm9kZXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlczogaTE4bk5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dCQyKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbCwgY29udGV4dCkge1xuICAgICAgICBpZiAoZWwubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRyQyKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lQXR0ciA9IGVsLmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ2lkJyk7XG4gICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgZWwuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUckMn0+IG1pc3NlcyB0aGUgXCJpZFwiIGF0dHJpYnV0ZWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLm5hbWUgPT09IF9NQVJLRVJfVEFHJDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoLi4udmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYFVuZXhwZWN0ZWQgdGFnYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZU1hcCA9IHt9O1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCBpY3UuY2FzZXMpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIGNhc2VNYXBbYy52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGMubm9kZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VNYXAsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IHZpc2l0QWxsKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfVxuICAgIF9hZGRFcnJvcihub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtZXNzYWdlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q3R5cGVGb3JUYWcodGFnKSB7XG4gICAgc3dpdGNoICh0YWcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICByZXR1cm4gJ2xiJztcbiAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICAgIHJldHVybiAnaW1hZ2UnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGB4LSR7dGFnfWA7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IF9WRVJTSU9OID0gJzIuMCc7XG5jb25zdCBfWE1MTlMgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjIuMCc7XG4vLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxuY29uc3QgX0RFRkFVTFRfU09VUkNFX0xBTkcgPSAnZW4nO1xuY29uc3QgX1BMQUNFSE9MREVSX1RBRyQxID0gJ3BoJztcbmNvbnN0IF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUcgPSAncGMnO1xuY29uc3QgX01BUktFUl9UQUcgPSAnbXJrJztcbmNvbnN0IF9YTElGRl9UQUcgPSAneGxpZmYnO1xuY29uc3QgX1NPVVJDRV9UQUcgPSAnc291cmNlJztcbmNvbnN0IF9UQVJHRVRfVEFHID0gJ3RhcmdldCc7XG5jb25zdCBfVU5JVF9UQUcgPSAndW5pdCc7XG4vLyBodHRwczovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYveGxpZmYtY29yZS92Mi4wL29zL3hsaWZmLWNvcmUtdjIuMC1vcy5odG1sXG5jbGFzcyBYbGlmZjIgZXh0ZW5kcyBTZXJpYWxpemVyIHtcbiAgICB3cml0ZShtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX1dyaXRlVmlzaXRvcigpO1xuICAgICAgICBjb25zdCB1bml0cyA9IFtdO1xuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgdW5pdCA9IG5ldyBUYWcoX1VOSVRfVEFHLCB7IGlkOiBtZXNzYWdlLmlkIH0pO1xuICAgICAgICAgICAgY29uc3Qgbm90ZXMgPSBuZXcgVGFnKCdub3RlcycpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24gfHwgbWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXMuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IGNhdGVnb3J5OiAnZGVzY3JpcHRpb24nIH0sIFtuZXcgVGV4dCQxKG1lc3NhZ2UuZGVzY3JpcHRpb24pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ21lYW5pbmcnIH0sIFtuZXcgVGV4dCQxKG1lc3NhZ2UubWVhbmluZyldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ2xvY2F0aW9uJyB9LCBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0JDEoYCR7c291cmNlLmZpbGVQYXRofToke3NvdXJjZS5zdGFydExpbmV9JHtzb3VyY2UuZW5kTGluZSAhPT0gc291cmNlLnN0YXJ0TGluZSA/ICcsJyArIHNvdXJjZS5lbmRMaW5lIDogJyd9YClcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgIHVuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoNiksIG5vdGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBuZXcgVGFnKCdzZWdtZW50Jyk7XG4gICAgICAgICAgICBzZWdtZW50LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKF9TT1VSQ0VfVEFHLCB7fSwgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpLCBuZXcgQ1IoNikpO1xuICAgICAgICAgICAgdW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSwgc2VnbWVudCwgbmV3IENSKDQpKTtcbiAgICAgICAgICAgIHVuaXRzLnB1c2gobmV3IENSKDQpLCB1bml0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgVGFnKCdmaWxlJywgeyAnb3JpZ2luYWwnOiAnbmcudGVtcGxhdGUnLCBpZDogJ25naTE4bicgfSwgWy4uLnVuaXRzLCBuZXcgQ1IoMildKTtcbiAgICAgICAgY29uc3QgeGxpZmYgPSBuZXcgVGFnKF9YTElGRl9UQUcsIHsgdmVyc2lvbjogX1ZFUlNJT04sIHhtbG5zOiBfWE1MTlMsIHNyY0xhbmc6IGxvY2FsZSB8fCBfREVGQVVMVF9TT1VSQ0VfTEFORyB9LCBbbmV3IENSKDIpLCBmaWxlLCBuZXcgQ1IoKV0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSwgbmV3IENSKCksIHhsaWZmLCBuZXcgQ1IoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgbG9hZChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgLy8geGxpZmYgdG8geG1sIG5vZGVzXG4gICAgICAgIGNvbnN0IHhsaWZmMlBhcnNlciA9IG5ldyBYbGlmZjJQYXJzZXIoKTtcbiAgICAgICAgY29uc3QgeyBsb2NhbGUsIG1zZ0lkVG9IdG1sLCBlcnJvcnMgfSA9IHhsaWZmMlBhcnNlci5wYXJzZShjb250ZW50LCB1cmwpO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICBjb25zdCBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4kMSgpO1xuICAgICAgICBPYmplY3Qua2V5cyhtc2dJZFRvSHRtbCkuZm9yRWFjaChtc2dJZCA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGkxOG5Ob2RlcywgZXJyb3JzOiBlIH0gPSBjb252ZXJ0ZXIuY29udmVydChtc2dJZFRvSHRtbFttc2dJZF0sIHVybCk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5lKTtcbiAgICAgICAgICAgIGkxOG5Ob2Rlc0J5TXNnSWRbbXNnSWRdID0gaTE4bk5vZGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgeGxpZmYyIHBhcnNlIGVycm9yczpcXG4ke2Vycm9ycy5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH1cbiAgICBkaWdlc3QobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2VzdChtZXNzYWdlKTtcbiAgICB9XG59XG5jbGFzcyBfV3JpdGVWaXNpdG9yIHtcbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUZXh0JDEodGV4dC52YWx1ZSldO1xuICAgIH1cbiAgICB2aXNpdENvbnRhaW5lcihjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goKG5vZGUpID0+IG5vZGVzLnB1c2goLi4ubm9kZS52aXNpdCh0aGlzKSkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtuZXcgVGV4dCQxKGB7JHtpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyfSwgJHtpY3UudHlwZX0sIGApXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoYCR7Y30ge2ApLCAuLi5pY3UuY2FzZXNbY10udmlzaXQodGhpcyksIG5ldyBUZXh0JDEoYH0gYCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKGB9YCkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGVGb3JUYWcocGgudGFnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwge1xuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBlcXVpdjogcGguc3RhcnROYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZGlzcDogYDwke3BoLnRhZ30vPmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbdGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ1BjID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHLCB7XG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBlcXVpdlN0YXJ0OiBwaC5zdGFydE5hbWUsXG4gICAgICAgICAgICBlcXVpdkVuZDogcGguY2xvc2VOYW1lLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRpc3BTdGFydDogYDwke3BoLnRhZ30+YCxcbiAgICAgICAgICAgIGRpc3BFbmQ6IGA8LyR7cGgudGFnfT5gLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXS5jb25jYXQoLi4ucGguY2hpbGRyZW4ubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSkpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB0YWdQYy5jaGlsZHJlbi5wdXNoKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhZ1BjLmNoaWxkcmVuLnB1c2gobmV3IFRleHQkMSgnJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGFnUGNdO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGlkU3RyID0gKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHtcbiAgICAgICAgICAgICAgICBpZDogaWRTdHIsXG4gICAgICAgICAgICAgICAgZXF1aXY6IHBoLm5hbWUsXG4gICAgICAgICAgICAgICAgZGlzcDogYHt7JHtwaC52YWx1ZX19fWAsXG4gICAgICAgICAgICB9KV07XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZXMgPSBPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKyAnIHsuLi59Jykuam9pbignICcpO1xuICAgICAgICBjb25zdCBpZFN0ciA9ICh0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCsrKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IGlkOiBpZFN0ciwgZXF1aXY6IHBoLm5hbWUsIGRpc3A6IGB7JHtwaC52YWx1ZS5leHByZXNzaW9ufSwgJHtwaC52YWx1ZS50eXBlfSwgJHtjYXNlc319YCB9KV07XG4gICAgfVxuICAgIHNlcmlhbGl6ZShub2Rlcykge1xuICAgICAgICB0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCA9IDA7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoLi4ubm9kZXMubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSkpO1xuICAgIH1cbn1cbi8vIEV4dHJhY3QgbWVzc2FnZXMgYXMgeG1sIG5vZGVzIGZyb20gdGhlIHhsaWZmIGZpbGVcbmNsYXNzIFhsaWZmMlBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIHBhcnNlKHhsaWZmLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgY29uc3QgeG1sID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKHhsaWZmLCB1cmwpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWwucm9vdE5vZGVzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ0lkVG9IdG1sOiB0aGlzLl9tc2dJZFRvSHRtbCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9VTklUX1RBRzpcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgPCR7X1VOSVRfVEFHfT4gbWlzc2VzIHRoZSBcImlkXCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkVG9IdG1sLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgYER1cGxpY2F0ZWQgdHJhbnNsYXRpb25zIGZvciBtc2cgJHtpZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl91bml0TWxTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gdGhpcy5fdW5pdE1sU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgYE1lc3NhZ2UgJHtpZH0gbWlzc2VzIGEgdHJhbnNsYXRpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUc6XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyVGV4dFN0YXJ0ID0gZWxlbWVudC5zdGFydFNvdXJjZVNwYW4uZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHRFbmQgPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJUZXh0ID0gY29udGVudC5zbGljZShpbm5lclRleHRTdGFydCwgaW5uZXJUZXh0RW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBpbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9YTElGRl9UQUc6XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAndHJnTGFuZycpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZUF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25BdHRyID0gZWxlbWVudC5hdHRycy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICd2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb25BdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09ICcyLjAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgVGhlIFhMSUZGIGZpbGUgdmVyc2lvbiAke3ZlcnNpb259IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggWExJRkYgMi4wIHNlcmlhbGl6ZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uLCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0IG1sIG5vZGVzICh4bGlmZiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbmNsYXNzIFhtbFRvSTE4biQxIHtcbiAgICBjb252ZXJ0KG1lc3NhZ2UsIHVybCkge1xuICAgICAgICBjb25zdCB4bWxJY3UgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UobWVzc2FnZSwgdXJsLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbEljdS5lcnJvcnM7XG4gICAgICAgIGNvbnN0IGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgW10uY29uY2F0KC4uLnZpc2l0QWxsKHRoaXMsIHhtbEljdS5yb290Tm9kZXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHQkMih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9UQUckMTpcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lQXR0ciA9IGVsLmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ2VxdWl2Jyk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgZWwuc291cmNlU3BhbildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUckMX0+IG1pc3NlcyB0aGUgXCJlcXVpdlwiIGF0dHJpYnV0ZWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0QXR0ciA9IGVsLmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ2VxdWl2U3RhcnQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRBdHRyID0gZWwuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnZXF1aXZFbmQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0QXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUckMX0+IG1pc3NlcyB0aGUgXCJlcXVpdlN0YXJ0XCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlbmRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBgPCR7X1BMQUNFSE9MREVSX1RBRyQxfT4gbWlzc2VzIHRoZSBcImVxdWl2RW5kXCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydElkID0gc3RhcnRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRJZCA9IGVuZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2Rlcy5jb25jYXQobmV3IFBsYWNlaG9sZGVyKCcnLCBzdGFydElkLCBlbC5zb3VyY2VTcGFuKSwgLi4uZWwuY2hpbGRyZW4ubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzLCBudWxsKSksIG5ldyBQbGFjZWhvbGRlcignJywgZW5kSWQsIGVsLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9NQVJLRVJfVEFHOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoLi4udmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIGBVbmV4cGVjdGVkIHRhZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZU1hcCA9IHt9O1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCBpY3UuY2FzZXMpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIGNhc2VNYXBbYy52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGMubm9kZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VNYXAsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IFtdLmNvbmNhdCguLi52aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24pKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRDb21tZW50KGNvbW1lbnQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUeXBlRm9yVGFnKHRhZykge1xuICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmV0dXJuICdmbXQnO1xuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBfVFJBTlNMQVRJT05TX1RBRyA9ICd0cmFuc2xhdGlvbmJ1bmRsZSc7XG5jb25zdCBfVFJBTlNMQVRJT05fVEFHID0gJ3RyYW5zbGF0aW9uJztcbmNvbnN0IF9QTEFDRUhPTERFUl9UQUcgPSAncGgnO1xuY2xhc3MgWHRiIGV4dGVuZHMgU2VyaWFsaXplciB7XG4gICAgd3JpdGUobWVzc2FnZXMsIGxvY2FsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGxvYWQoY29udGVudCwgdXJsKSB7XG4gICAgICAgIC8vIHh0YiB0byB4bWwgbm9kZXNcbiAgICAgICAgY29uc3QgeHRiUGFyc2VyID0gbmV3IFh0YlBhcnNlcigpO1xuICAgICAgICBjb25zdCB7IGxvY2FsZSwgbXNnSWRUb0h0bWwsIGVycm9ycyB9ID0geHRiUGFyc2VyLnBhcnNlKGNvbnRlbnQsIHVybCk7XG4gICAgICAgIC8vIHhtbCBub2RlcyB0byBpMThuIG5vZGVzXG4gICAgICAgIGNvbnN0IGkxOG5Ob2Rlc0J5TXNnSWQgPSB7fTtcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gbmV3IFhtbFRvSTE4bigpO1xuICAgICAgICAvLyBCZWNhdXNlIHdlIHNob3VsZCBiZSBhYmxlIHRvIGxvYWQgeHRiIGZpbGVzIHRoYXQgcmVseSBvbiBmZWF0dXJlcyBub3Qgc3VwcG9ydGVkIGJ5IGFuZ3VsYXIsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgdGhlIGNvbnZlcnNpb24gb2YgaHRtbCB0byBpMThuIG5vZGVzIHNvIHRoYXQgbm9uIGFuZ3VsYXIgbWVzc2FnZXMgYXJlIG5vdFxuICAgICAgICAvLyBjb252ZXJ0ZWRcbiAgICAgICAgT2JqZWN0LmtleXMobXNnSWRUb0h0bWwpLmZvckVhY2gobXNnSWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGkxOG5Ob2RlcywgZXJyb3JzIH0gPSBjb252ZXJ0ZXIuY29udmVydChtc2dJZFRvSHRtbFttc2dJZF0sIHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB4dGIgcGFyc2UgZXJyb3JzOlxcbiR7ZXJyb3JzLmpvaW4oJ1xcbicpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaTE4bk5vZGVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNyZWF0ZUxhenlQcm9wZXJ0eShpMThuTm9kZXNCeU1zZ0lkLCBtc2dJZCwgdmFsdWVGbik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB4dGIgcGFyc2UgZXJyb3JzOlxcbiR7ZXJyb3JzLmpvaW4oJ1xcbicpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxvY2FsZTogbG9jYWxlLCBpMThuTm9kZXNCeU1zZ0lkIH07XG4gICAgfVxuICAgIGRpZ2VzdChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBkaWdlc3QobWVzc2FnZSk7XG4gICAgfVxuICAgIGNyZWF0ZU5hbWVNYXBwZXIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZVBsYWNlaG9sZGVyTWFwcGVyKG1lc3NhZ2UsIHRvUHVibGljTmFtZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTGF6eVByb3BlcnR5KG1lc3NhZ2VzLCBpZCwgdmFsdWVGbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXNzYWdlcywgaWQsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVGbigpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lc3NhZ2VzLCBpZCwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBfID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IG92ZXJ3cml0ZSBhbiBYVEIgdHJhbnNsYXRpb24nKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIEV4dHJhY3QgbWVzc2FnZXMgYXMgeG1sIG5vZGVzIGZyb20gdGhlIHh0YiBmaWxlXG5jbGFzcyBYdGJQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBudWxsO1xuICAgIH1cbiAgICBwYXJzZSh4dGIsIHVybCkge1xuICAgICAgICB0aGlzLl9idW5kbGVEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sID0ge307XG4gICAgICAgIC8vIFdlIGNhbiBub3QgcGFyc2UgdGhlIElDVSBtZXNzYWdlcyBhdCB0aGlzIHBvaW50IGFzIHNvbWUgbWVzc2FnZXMgbWlnaHQgbm90IG9yaWdpbmF0ZVxuICAgICAgICAvLyBmcm9tIEFuZ3VsYXIgdGhhdCBjb3VsZCBub3QgYmUgbGV4J2QuXG4gICAgICAgIGNvbnN0IHhtbCA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZSh4dGIsIHVybCk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbC5lcnJvcnM7XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIHhtbC5yb290Tm9kZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbXNnSWRUb0h0bWw6IHRoaXMuX21zZ0lkVG9IdG1sLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgX1RSQU5TTEFUSU9OU19UQUc6XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgrKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYnVuZGxlRGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIGA8JHtfVFJBTlNMQVRJT05TX1RBR30+IGVsZW1lbnRzIGNhbiBub3QgYmUgbmVzdGVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxhbmdBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICdsYW5nJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmdBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxhbmdBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9idW5kbGVEZXB0aC0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfVFJBTlNMQVRJT05fVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgPCR7X1RSQU5TTEFUSU9OX1RBR30+IG1pc3NlcyB0aGUgXCJpZFwiIGF0dHJpYnV0ZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tc2dJZFRvSHRtbC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIGBEdXBsaWNhdGVkIHRyYW5zbGF0aW9ucyBmb3IgbXNnICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHRTdGFydCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHRFbmQgPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLnN0YXJ0LmZpbGUuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyVGV4dCA9IGNvbnRlbnQuc2xpY2UoaW5uZXJUZXh0U3RhcnQsIGlubmVyVGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbFtpZF0gPSBpbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsICdVbmV4cGVjdGVkIHRhZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbihleHBhbnNpb24sIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH1cbiAgICBfYWRkRXJyb3Iobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH1cbn1cbi8vIENvbnZlcnQgbWwgbm9kZXMgKHh0YiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbmNsYXNzIFhtbFRvSTE4biB7XG4gICAgY29udmVydChtZXNzYWdlLCB1cmwpIHtcbiAgICAgICAgY29uc3QgeG1sSWN1ID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKG1lc3NhZ2UsIHVybCwgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWxJY3UuZXJyb3JzO1xuICAgICAgICBjb25zdCBpMThuTm9kZXMgPSB0aGlzLl9lcnJvcnMubGVuZ3RoID4gMCB8fCB4bWxJY3Uucm9vdE5vZGVzLmxlbmd0aCA9PSAwID9cbiAgICAgICAgICAgIFtdIDpcbiAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIHhtbEljdS5yb290Tm9kZXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTE4bk5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLl9lcnJvcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dCQyKHRleHQudmFsdWUsIHRleHQuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uKGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIGNhc2VNYXBbYy52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGMubm9kZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VNYXAsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IHZpc2l0QWxsKHRoaXMsIGljdUNhc2UuZXhwcmVzc2lvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbCwgY29udGV4dCkge1xuICAgICAgICBpZiAoZWwubmFtZSA9PT0gX1BMQUNFSE9MREVSX1RBRykge1xuICAgICAgICAgICAgY29uc3QgbmFtZUF0dHIgPSBlbC5hdHRycy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICduYW1lJyk7XG4gICAgICAgICAgICBpZiAobmFtZUF0dHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgZWwuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUd9PiBtaXNzZXMgdGhlIFwibmFtZVwiIGF0dHJpYnV0ZWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIGBVbmV4cGVjdGVkIHRhZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250ZXh0KSB7IH1cbiAgICBfYWRkRXJyb3Iobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciB0cmFuc2xhdGVkIG1lc3NhZ2VzXG4gKi9cbmNsYXNzIFRyYW5zbGF0aW9uQnVuZGxlIHtcbiAgICBjb25zdHJ1Y3RvcihfaTE4bk5vZGVzQnlNc2dJZCA9IHt9LCBsb2NhbGUsIGRpZ2VzdCwgbWFwcGVyRmFjdG9yeSwgbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nLCBjb25zb2xlKSB7XG4gICAgICAgIHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWQgPSBfaTE4bk5vZGVzQnlNc2dJZDtcbiAgICAgICAgdGhpcy5kaWdlc3QgPSBkaWdlc3Q7XG4gICAgICAgIHRoaXMubWFwcGVyRmFjdG9yeSA9IG1hcHBlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2kxOG5Ub0h0bWwgPSBuZXcgSTE4blRvSHRtbFZpc2l0b3IoX2kxOG5Ob2Rlc0J5TXNnSWQsIGxvY2FsZSwgZGlnZXN0LCBtYXBwZXJGYWN0b3J5LCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSk7XG4gICAgfVxuICAgIC8vIENyZWF0ZXMgYSBgVHJhbnNsYXRpb25CdW5kbGVgIGJ5IHBhcnNpbmcgdGhlIGdpdmVuIGBjb250ZW50YCB3aXRoIHRoZSBgc2VyaWFsaXplcmAuXG4gICAgc3RhdGljIGxvYWQoY29udGVudCwgdXJsLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSkge1xuICAgICAgICBjb25zdCB7IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZCB9ID0gc2VyaWFsaXplci5sb2FkKGNvbnRlbnQsIHVybCk7XG4gICAgICAgIGNvbnN0IGRpZ2VzdEZuID0gKG0pID0+IHNlcmlhbGl6ZXIuZGlnZXN0KG0pO1xuICAgICAgICBjb25zdCBtYXBwZXJGYWN0b3J5ID0gKG0pID0+IHNlcmlhbGl6ZXIuY3JlYXRlTmFtZU1hcHBlcihtKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2xhdGlvbkJ1bmRsZShpMThuTm9kZXNCeU1zZ0lkLCBsb2NhbGUsIGRpZ2VzdEZuLCBtYXBwZXJGYWN0b3J5LCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgY29uc29sZSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIGFzIEhUTUwgbm9kZXMgZnJvbSB0aGUgZ2l2ZW4gc291cmNlIG1lc3NhZ2UuXG4gICAgZ2V0KHNyY01zZykge1xuICAgICAgICBjb25zdCBodG1sID0gdGhpcy5faTE4blRvSHRtbC5jb252ZXJ0KHNyY01zZyk7XG4gICAgICAgIGlmIChodG1sLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihodG1sLmVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGh0bWwubm9kZXM7XG4gICAgfVxuICAgIGhhcyhzcmNNc2cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0KHNyY01zZykgaW4gdGhpcy5faTE4bk5vZGVzQnlNc2dJZDtcbiAgICB9XG59XG5jbGFzcyBJMThuVG9IdG1sVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoX2kxOG5Ob2Rlc0J5TXNnSWQgPSB7fSwgX2xvY2FsZSwgX2RpZ2VzdCwgX21hcHBlckZhY3RvcnksIF9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSwgX2NvbnNvbGUpIHtcbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLl9sb2NhbGUgPSBfbG9jYWxlO1xuICAgICAgICB0aGlzLl9kaWdlc3QgPSBfZGlnZXN0O1xuICAgICAgICB0aGlzLl9tYXBwZXJGYWN0b3J5ID0gX21hcHBlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID0gX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9jb25zb2xlID0gX2NvbnNvbGU7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgY29udmVydChzcmNNc2cpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBpMThuIHRvIHRleHRcbiAgICAgICAgY29uc3QgdGV4dCA9IHRoaXMuX2NvbnZlcnRUb1RleHQoc3JjTXNnKTtcbiAgICAgICAgLy8gdGV4dCB0byBodG1sXG4gICAgICAgIGNvbnN0IHVybCA9IHNyY01zZy5ub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmZpbGUudXJsO1xuICAgICAgICBjb25zdCBodG1sID0gbmV3IEh0bWxQYXJzZXIoKS5wYXJzZSh0ZXh0LCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vZGVzOiBodG1sLnJvb3ROb2RlcyxcbiAgICAgICAgICAgIGVycm9yczogWy4uLnRoaXMuX2Vycm9ycywgLi4uaHRtbC5lcnJvcnNdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICAvLyBgY29udmVydCgpYCB1c2VzIGFuIGBIdG1sUGFyc2VyYCB0byByZXR1cm4gYGh0bWwuTm9kZWBzXG4gICAgICAgIC8vIHdlIHNob3VsZCB0aGVuIG1ha2Ugc3VyZSB0aGF0IGFueSBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWRcbiAgICAgICAgcmV0dXJuIGVzY2FwZVhtbCh0ZXh0LnZhbHVlKTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKG4gPT4gbi52aXNpdCh0aGlzKSkuam9pbignJyk7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKGsgPT4gYCR7a30geyR7aWN1LmNhc2VzW2tdLnZpc2l0KHRoaXMpfX1gKTtcbiAgICAgICAgLy8gVE9ETyh2aWNiKTogT25jZSBhbGwgZm9ybWF0IHN3aXRjaCB0byB1c2luZyBleHByZXNzaW9uIHBsYWNlaG9sZGVyc1xuICAgICAgICAvLyB3ZSBzaG91bGQgdGhyb3cgd2hlbiB0aGUgcGxhY2Vob2xkZXIgaXMgbm90IGluIHRoZSBzb3VyY2UgbWVzc2FnZVxuICAgICAgICBjb25zdCBleHAgPSB0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJzLmhhc093blByb3BlcnR5KGljdS5leHByZXNzaW9uKSA/XG4gICAgICAgICAgICB0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJzW2ljdS5leHByZXNzaW9uXS50ZXh0IDpcbiAgICAgICAgICAgIGljdS5leHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gYHske2V4cH0sICR7aWN1LnR5cGV9LCAke2Nhc2VzLmpvaW4oJyAnKX19YDtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBwaE5hbWUgPSB0aGlzLl9tYXBwZXIocGgubmFtZSk7XG4gICAgICAgIGlmICh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJzLmhhc093blByb3BlcnR5KHBoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJzW3BoTmFtZV0udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyVG9NZXNzYWdlLmhhc093blByb3BlcnR5KHBoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9UZXh0KHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlclRvTWVzc2FnZVtwaE5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRFcnJvcihwaCwgYFVua25vd24gcGxhY2Vob2xkZXIgXCIke3BoLm5hbWV9XCJgKTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBMb2FkZWQgbWVzc2FnZSBjb250YWlucyBvbmx5IHBsYWNlaG9sZGVycyAodnMgdGFnIGFuZCBpY3UgcGxhY2Vob2xkZXJzKS5cbiAgICAvLyBIb3dldmVyIHdoZW4gYSB0cmFuc2xhdGlvbiBjYW4gbm90IGJlIGZvdW5kLCB3ZSBuZWVkIHRvIHNlcmlhbGl6ZSB0aGUgc291cmNlIG1lc3NhZ2VcbiAgICAvLyB3aGljaCBjYW4gY29udGFpbiB0YWcgcGxhY2Vob2xkZXJzXG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCB0YWcgPSBgJHtwaC50YWd9YDtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBPYmplY3Qua2V5cyhwaC5hdHRycykubWFwKG5hbWUgPT4gYCR7bmFtZX09XCIke3BoLmF0dHJzW25hbWVdfVwiYCkuam9pbignICcpO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gYDwke3RhZ30gJHthdHRyc30vPmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAoKGMpID0+IGMudmlzaXQodGhpcykpLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gYDwke3RhZ30gJHthdHRyc30+JHtjaGlsZHJlbn08LyR7dGFnfT5gO1xuICAgIH1cbiAgICAvLyBMb2FkZWQgbWVzc2FnZSBjb250YWlucyBvbmx5IHBsYWNlaG9sZGVycyAodnMgdGFnIGFuZCBpY3UgcGxhY2Vob2xkZXJzKS5cbiAgICAvLyBIb3dldmVyIHdoZW4gYSB0cmFuc2xhdGlvbiBjYW4gbm90IGJlIGZvdW5kLCB3ZSBuZWVkIHRvIHNlcmlhbGl6ZSB0aGUgc291cmNlIG1lc3NhZ2VcbiAgICAvLyB3aGljaCBjYW4gY29udGFpbiB0YWcgcGxhY2Vob2xkZXJzXG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICAvLyBBbiBJQ1UgcGxhY2Vob2xkZXIgcmVmZXJlbmNlcyB0aGUgc291cmNlIG1lc3NhZ2UgdG8gYmUgc2VyaWFsaXplZFxuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFRvVGV4dCh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGgubmFtZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgc291cmNlIG1lc3NhZ2UgdG8gYSB0cmFuc2xhdGVkIHRleHQgc3RyaW5nOlxuICAgICAqIC0gdGV4dCBub2RlcyBhcmUgcmVwbGFjZWQgd2l0aCB0aGVpciB0cmFuc2xhdGlvbixcbiAgICAgKiAtIHBsYWNlaG9sZGVycyBhcmUgcmVwbGFjZWQgd2l0aCB0aGVpciBjb250ZW50LFxuICAgICAqIC0gSUNVIG5vZGVzIGFyZSBjb252ZXJ0ZWQgdG8gSUNVIGV4cHJlc3Npb25zLlxuICAgICAqL1xuICAgIF9jb252ZXJ0VG9UZXh0KHNyY01zZykge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuX2RpZ2VzdChzcmNNc2cpO1xuICAgICAgICBjb25zdCBtYXBwZXIgPSB0aGlzLl9tYXBwZXJGYWN0b3J5ID8gdGhpcy5fbWFwcGVyRmFjdG9yeShzcmNNc2cpIDogbnVsbDtcbiAgICAgICAgbGV0IG5vZGVzO1xuICAgICAgICB0aGlzLl9jb250ZXh0U3RhY2sucHVzaCh7IG1zZzogdGhpcy5fc3JjTXNnLCBtYXBwZXI6IHRoaXMuX21hcHBlciB9KTtcbiAgICAgICAgdGhpcy5fc3JjTXNnID0gc3JjTXNnO1xuICAgICAgICBpZiAodGhpcy5faTE4bk5vZGVzQnlNc2dJZC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlcmUgaXMgYSB0cmFuc2xhdGlvbiB1c2UgaXRzIG5vZGVzIGFzIHRoZSBzb3VyY2VcbiAgICAgICAgICAgIC8vIEFuZCBjcmVhdGUgYSBtYXBwZXIgdG8gY29udmVydCBzZXJpYWxpemVkIHBsYWNlaG9sZGVyIG5hbWVzIHRvIGludGVybmFsIG5hbWVzXG4gICAgICAgICAgICBub2RlcyA9IHRoaXMuX2kxOG5Ob2Rlc0J5TXNnSWRbaWRdO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGVyID0gKG5hbWUpID0+IG1hcHBlciA/IG1hcHBlci50b0ludGVybmFsTmFtZShuYW1lKSA6IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIG5vIHRyYW5zbGF0aW9uIGhhcyBiZWVuIGZvdW5kXG4gICAgICAgICAgICAvLyAtIHJlcG9ydCBhbiBlcnJvciAvIGEgd2FybmluZyAvIG5vdGhpbmcsXG4gICAgICAgICAgICAvLyAtIHVzZSB0aGUgbm9kZXMgZnJvbSB0aGUgb3JpZ2luYWwgbWVzc2FnZVxuICAgICAgICAgICAgLy8gLSBwbGFjZWhvbGRlcnMgYXJlIGFscmVhZHkgaW50ZXJuYWwgYW5kIG5lZWQgbm8gbWFwcGVyXG4gICAgICAgICAgICBpZiAodGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPT09IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LkVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fbG9jYWxlID8gYCBmb3IgbG9jYWxlIFwiJHt0aGlzLl9sb2NhbGV9XCJgIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3Ioc3JjTXNnLm5vZGVzWzBdLCBgTWlzc2luZyB0cmFuc2xhdGlvbiBmb3IgbWVzc2FnZSBcIiR7aWR9XCIke2N0eH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2NvbnNvbGUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9PT0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuV2FybmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2xvY2FsZSA/IGAgZm9yIGxvY2FsZSBcIiR7dGhpcy5fbG9jYWxlfVwiYCA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnNvbGUud2FybihgTWlzc2luZyB0cmFuc2xhdGlvbiBmb3IgbWVzc2FnZSBcIiR7aWR9XCIke2N0eH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzID0gc3JjTXNnLm5vZGVzO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGVyID0gKG5hbWUpID0+IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IG5vZGVzLm1hcChub2RlID0+IG5vZGUudmlzaXQodGhpcykpLmpvaW4oJycpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dFN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLl9zcmNNc2cgPSBjb250ZXh0Lm1zZztcbiAgICAgICAgdGhpcy5fbWFwcGVyID0gY29udGV4dC5tYXBwZXI7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBfYWRkRXJyb3IoZWwsIG1zZykge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKGVsLnNvdXJjZVNwYW4sIG1zZykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBJMThOSHRtbFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoX2h0bWxQYXJzZXIsIHRyYW5zbGF0aW9ucywgdHJhbnNsYXRpb25zRm9ybWF0LCBtaXNzaW5nVHJhbnNsYXRpb24gPSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nLCBjb25zb2xlKSB7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IGNyZWF0ZVNlcmlhbGl6ZXIodHJhbnNsYXRpb25zRm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uQnVuZGxlID1cbiAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkKHRyYW5zbGF0aW9ucywgJ2kxOG4nLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUgPVxuICAgICAgICAgICAgICAgIG5ldyBUcmFuc2xhdGlvbkJ1bmRsZSh7fSwgbnVsbCwgZGlnZXN0JDEsIHVuZGVmaW5lZCwgbWlzc2luZ1RyYW5zbGF0aW9uLCBjb25zb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZShzb3VyY2UsIHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpb25Db25maWcgPSBvcHRpb25zLmludGVycG9sYXRpb25Db25maWcgfHwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRztcbiAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHNvdXJjZSwgdXJsLCBPYmplY3QuYXNzaWduKHsgaW50ZXJwb2xhdGlvbkNvbmZpZyB9LCBvcHRpb25zKSk7XG4gICAgICAgIGlmIChwYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHBhcnNlUmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlVHJhbnNsYXRpb25zKHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUsIGludGVycG9sYXRpb25Db25maWcsIFtdLCB7fSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSAoZm9ybWF0IHx8ICd4bGYnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3htYic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhtYigpO1xuICAgICAgICBjYXNlICd4dGInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYdGIoKTtcbiAgICAgICAgY2FzZSAneGxpZmYyJzpcbiAgICAgICAgY2FzZSAneGxmMic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmMigpO1xuICAgICAgICBjYXNlICd4bGlmZic6XG4gICAgICAgIGNhc2UgJ3hsZic6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSBjb250YWluZXIgZm9yIG1lc3NhZ2UgZXh0cmFjdGVkIGZyb20gdGhlIHRlbXBsYXRlcy5cbiAqL1xuY2xhc3MgTWVzc2FnZUJ1bmRsZSB7XG4gICAgY29uc3RydWN0b3IoX2h0bWxQYXJzZXIsIF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzLCBfbG9jYWxlID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9odG1sUGFyc2VyID0gX2h0bWxQYXJzZXI7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0VGFncyA9IF9pbXBsaWNpdFRhZ3M7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gX2xvY2FsZTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcbiAgICB9XG4gICAgdXBkYXRlRnJvbVRlbXBsYXRlKGh0bWwsIHVybCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICBjb25zdCBodG1sUGFyc2VyUmVzdWx0ID0gdGhpcy5faHRtbFBhcnNlci5wYXJzZShodG1sLCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSwgaW50ZXJwb2xhdGlvbkNvbmZpZyB9KTtcbiAgICAgICAgaWYgKGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGh0bWxQYXJzZXJSZXN1bHQuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkxOG5QYXJzZXJSZXN1bHQgPSBleHRyYWN0TWVzc2FnZXMoaHRtbFBhcnNlclJlc3VsdC5yb290Tm9kZXMsIGludGVycG9sYXRpb25Db25maWcsIHRoaXMuX2ltcGxpY2l0VGFncywgdGhpcy5faW1wbGljaXRBdHRycyk7XG4gICAgICAgIGlmIChpMThuUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpMThuUGFyc2VyUmVzdWx0LmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKC4uLmkxOG5QYXJzZXJSZXN1bHQubWVzc2FnZXMpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgbWVzc2FnZSBpbiB0aGUgaW50ZXJuYWwgZm9ybWF0XG4gICAgLy8gVGhlIHB1YmxpYyAoc2VyaWFsaXplZCkgZm9ybWF0IG1pZ2h0IGJlIGRpZmZlcmVudCwgc2VlIHRoZSBgd3JpdGVgIG1ldGhvZC5cbiAgICBnZXRNZXNzYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VzO1xuICAgIH1cbiAgICB3cml0ZShzZXJpYWxpemVyLCBmaWx0ZXJTb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0ge307XG4gICAgICAgIGNvbnN0IG1hcHBlclZpc2l0b3IgPSBuZXcgTWFwUGxhY2Vob2xkZXJOYW1lcygpO1xuICAgICAgICAvLyBEZWR1cGxpY2F0ZSBtZXNzYWdlcyBiYXNlZCBvbiB0aGVpciBJRFxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBzZXJpYWxpemVyLmRpZ2VzdChtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZXMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbaWRdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXS5zb3VyY2VzLnB1c2goLi4ubWVzc2FnZS5zb3VyY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyYW5zZm9ybSBwbGFjZWhvbGRlciBuYW1lcyB1c2luZyB0aGUgc2VyaWFsaXplciBtYXBwaW5nXG4gICAgICAgIGNvbnN0IG1zZ0xpc3QgPSBPYmplY3Qua2V5cyhtZXNzYWdlcykubWFwKGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlciA9IHNlcmlhbGl6ZXIuY3JlYXRlTmFtZU1hcHBlcihtZXNzYWdlc1tpZF0pO1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gbWVzc2FnZXNbaWRdO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBtYXBwZXIgPyBtYXBwZXJWaXNpdG9yLmNvbnZlcnQoc3JjLm5vZGVzLCBtYXBwZXIpIDogc3JjLm5vZGVzO1xuICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkTWVzc2FnZSA9IG5ldyBNZXNzYWdlKG5vZGVzLCB7fSwge30sIHNyYy5tZWFuaW5nLCBzcmMuZGVzY3JpcHRpb24sIGlkKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTWVzc2FnZS5zb3VyY2VzID0gc3JjLnNvdXJjZXM7XG4gICAgICAgICAgICBpZiAoZmlsdGVyU291cmNlcykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkTWVzc2FnZS5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4gc291cmNlLmZpbGVQYXRoID0gZmlsdGVyU291cmNlcyhzb3VyY2UuZmlsZVBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZE1lc3NhZ2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplci53cml0ZShtc2dMaXN0LCB0aGlzLl9sb2NhbGUpO1xuICAgIH1cbn1cbi8vIFRyYW5zZm9ybSBhbiBpMThuIEFTVCBieSByZW5hbWluZyB0aGUgcGxhY2Vob2xkZXIgbm9kZXMgd2l0aCB0aGUgZ2l2ZW4gbWFwcGVyXG5jbGFzcyBNYXBQbGFjZWhvbGRlck5hbWVzIGV4dGVuZHMgQ2xvbmVWaXNpdG9yIHtcbiAgICBjb252ZXJ0KG5vZGVzLCBtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBlciA/IG5vZGVzLm1hcChuID0+IG4udmlzaXQodGhpcywgbWFwcGVyKSkgOiBub2RlcztcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0TmFtZSA9IG1hcHBlci50b1B1YmxpY05hbWUocGguc3RhcnROYW1lKTtcbiAgICAgICAgY29uc3QgY2xvc2VOYW1lID0gcGguY2xvc2VOYW1lID8gbWFwcGVyLnRvUHVibGljTmFtZShwaC5jbG9zZU5hbWUpIDogcGguY2xvc2VOYW1lO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChuID0+IG4udmlzaXQodGhpcywgbWFwcGVyKSk7XG4gICAgICAgIHJldHVybiBuZXcgVGFnUGxhY2Vob2xkZXIocGgudGFnLCBwaC5hdHRycywgc3RhcnROYW1lLCBjbG9zZU5hbWUsIGNoaWxkcmVuLCBwaC5pc1ZvaWQsIHBoLnNvdXJjZVNwYW4sIHBoLnN0YXJ0U291cmNlU3BhbiwgcGguZW5kU291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgsIG1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKHBoLnZhbHVlLCBtYXBwZXIudG9QdWJsaWNOYW1lKHBoLm5hbWUpLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSWN1UGxhY2Vob2xkZXIocGgudmFsdWUsIG1hcHBlci50b1B1YmxpY05hbWUocGgubmFtZSksIHBoLnNvdXJjZVNwYW4pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbnZhciBGYWN0b3J5VGFyZ2V0O1xuKGZ1bmN0aW9uIChGYWN0b3J5VGFyZ2V0KSB7XG4gICAgRmFjdG9yeVRhcmdldFtGYWN0b3J5VGFyZ2V0W1wiRGlyZWN0aXZlXCJdID0gMF0gPSBcIkRpcmVjdGl2ZVwiO1xuICAgIEZhY3RvcnlUYXJnZXRbRmFjdG9yeVRhcmdldFtcIkNvbXBvbmVudFwiXSA9IDFdID0gXCJDb21wb25lbnRcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJJbmplY3RhYmxlXCJdID0gMl0gPSBcIkluamVjdGFibGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJQaXBlXCJdID0gM10gPSBcIlBpcGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJOZ01vZHVsZVwiXSA9IDRdID0gXCJOZ01vZHVsZVwiO1xufSkoRmFjdG9yeVRhcmdldCB8fCAoRmFjdG9yeVRhcmdldCA9IHt9KSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBQcm9jZXNzZXMgYFRhcmdldGBzIHdpdGggYSBnaXZlbiBzZXQgb2YgZGlyZWN0aXZlcyBhbmQgcGVyZm9ybXMgYSBiaW5kaW5nIG9wZXJhdGlvbiwgd2hpY2hcbiAqIHJldHVybnMgYW4gb2JqZWN0IHNpbWlsYXIgdG8gVHlwZVNjcmlwdCdzIGB0cy5UeXBlQ2hlY2tlcmAgdGhhdCBjb250YWlucyBrbm93bGVkZ2UgYWJvdXQgdGhlXG4gKiB0YXJnZXQuXG4gKi9cbmNsYXNzIFIzVGFyZ2V0QmluZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkaXJlY3RpdmVNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlTWF0Y2hlciA9IGRpcmVjdGl2ZU1hdGNoZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBiaW5kaW5nIG9wZXJhdGlvbiBvbiB0aGUgZ2l2ZW4gYFRhcmdldGAgYW5kIHJldHVybiBhIGBCb3VuZFRhcmdldGAgd2hpY2ggY29udGFpbnNcbiAgICAgKiBtZXRhZGF0YSBhYm91dCB0aGUgdHlwZXMgcmVmZXJlbmNlZCBpbiB0aGUgdGVtcGxhdGUuXG4gICAgICovXG4gICAgYmluZCh0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogaGFuZGxlIHRhcmdldHMgd2hpY2ggY29udGFpbiB0aGluZ3MgbGlrZSBIb3N0QmluZGluZ3MsIGV0Yy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmluZGluZyB3aXRob3V0IGEgdGVtcGxhdGUgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJzdCwgcGFyc2UgdGhlIHRlbXBsYXRlIGludG8gYSBgU2NvcGVgIHN0cnVjdHVyZS4gVGhpcyBvcGVyYXRpb24gY2FwdHVyZXMgdGhlIHN5bnRhY3RpY1xuICAgICAgICAvLyBzY29wZXMgaW4gdGhlIHRlbXBsYXRlIGFuZCBtYWtlcyB0aGVtIGF2YWlsYWJsZSBmb3IgbGF0ZXIgdXNlLlxuICAgICAgICBjb25zdCBzY29wZSA9IFNjb3BlLmFwcGx5KHRhcmdldC50ZW1wbGF0ZSk7XG4gICAgICAgIC8vIFVzZSB0aGUgYFNjb3BlYCB0byBleHRyYWN0IHRoZSBlbnRpdGllcyBwcmVzZW50IGF0IGV2ZXJ5IGxldmVsIG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgY29uc3QgdGVtcGxhdGVFbnRpdGllcyA9IGV4dHJhY3RUZW1wbGF0ZUVudGl0aWVzKHNjb3BlKTtcbiAgICAgICAgLy8gTmV4dCwgcGVyZm9ybSBkaXJlY3RpdmUgbWF0Y2hpbmcgb24gdGhlIHRlbXBsYXRlIHVzaW5nIHRoZSBgRGlyZWN0aXZlQmluZGVyYC4gVGhpcyByZXR1cm5zOlxuICAgICAgICAvLyAgIC0gZGlyZWN0aXZlczogTWFwIG9mIG5vZGVzIChlbGVtZW50cyAmIG5nLXRlbXBsYXRlcykgdG8gdGhlIGRpcmVjdGl2ZXMgb24gdGhlbS5cbiAgICAgICAgLy8gICAtIGJpbmRpbmdzOiBNYXAgb2YgaW5wdXRzLCBvdXRwdXRzLCBhbmQgYXR0cmlidXRlcyB0byB0aGUgZGlyZWN0aXZlL2VsZW1lbnQgdGhhdCBjbGFpbXNcbiAgICAgICAgLy8gICAgIHRoZW0uIFRPRE8oYWx4aHViKTogaGFuZGxlIG11bHRpcGxlIGRpcmVjdGl2ZXMgY2xhaW1pbmcgYW4gaW5wdXQvb3V0cHV0L2V0Yy5cbiAgICAgICAgLy8gICAtIHJlZmVyZW5jZXM6IE1hcCBvZiAjcmVmZXJlbmNlcyB0byB0aGVpciB0YXJnZXRzLlxuICAgICAgICBjb25zdCB7IGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzIH0gPSBEaXJlY3RpdmVCaW5kZXIuYXBwbHkodGFyZ2V0LnRlbXBsYXRlLCB0aGlzLmRpcmVjdGl2ZU1hdGNoZXIpO1xuICAgICAgICAvLyBGaW5hbGx5LCBydW4gdGhlIFRlbXBsYXRlQmluZGVyIHRvIGJpbmQgcmVmZXJlbmNlcywgdmFyaWFibGVzLCBhbmQgb3RoZXIgZW50aXRpZXMgd2l0aGluIHRoZVxuICAgICAgICAvLyB0ZW1wbGF0ZS4gVGhpcyBleHRyYWN0cyBhbGwgdGhlIG1ldGFkYXRhIHRoYXQgZG9lc24ndCBkZXBlbmQgb24gZGlyZWN0aXZlIG1hdGNoaW5nLlxuICAgICAgICBjb25zdCB7IGV4cHJlc3Npb25zLCBzeW1ib2xzLCBuZXN0aW5nTGV2ZWwsIHVzZWRQaXBlcyB9ID0gVGVtcGxhdGVCaW5kZXIuYXBwbHlXaXRoU2NvcGUodGFyZ2V0LnRlbXBsYXRlLCBzY29wZSk7XG4gICAgICAgIHJldHVybiBuZXcgUjNCb3VuZFRhcmdldCh0YXJnZXQsIGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzLCBleHByZXNzaW9ucywgc3ltYm9scywgbmVzdGluZ0xldmVsLCB0ZW1wbGF0ZUVudGl0aWVzLCB1c2VkUGlwZXMpO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGJpbmRpbmcgc2NvcGUgd2l0aGluIGEgdGVtcGxhdGUuXG4gKlxuICogQW55IHZhcmlhYmxlcywgcmVmZXJlbmNlcywgb3Igb3RoZXIgbmFtZWQgZW50aXRpZXMgZGVjbGFyZWQgd2l0aGluIHRoZSB0ZW1wbGF0ZSB3aWxsXG4gKiBiZSBjYXB0dXJlZCBhbmQgYXZhaWxhYmxlIGJ5IG5hbWUgaW4gYG5hbWVkRW50aXRpZXNgLiBBZGRpdGlvbmFsbHksIGNoaWxkIHRlbXBsYXRlcyB3aWxsXG4gKiBiZSBhbmFseXplZCBhbmQgaGF2ZSB0aGVpciBjaGlsZCBgU2NvcGVgcyBhdmFpbGFibGUgaW4gYGNoaWxkU2NvcGVzYC5cbiAqL1xuY2xhc3MgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudFNjb3BlLCB0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnBhcmVudFNjb3BlID0gcGFyZW50U2NvcGU7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWVkIG1lbWJlcnMgb2YgdGhlIGBTY29wZWAsIHN1Y2ggYXMgYFJlZmVyZW5jZWBzIG9yIGBWYXJpYWJsZWBzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lZEVudGl0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hpbGQgYFNjb3BlYHMgZm9yIGltbWVkaWF0ZWx5IG5lc3RlZCBgVGVtcGxhdGVgcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRTY29wZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHN0YXRpYyBuZXdSb290U2NvcGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NvcGUobnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSB0ZW1wbGF0ZSAoZWl0aGVyIGFzIGEgYFRlbXBsYXRlYCBzdWItdGVtcGxhdGUgd2l0aCB2YXJpYWJsZXMsIG9yIGEgcGxhaW4gYXJyYXkgb2ZcbiAgICAgKiB0ZW1wbGF0ZSBgTm9kZWBzKSBhbmQgY29uc3RydWN0IGl0cyBgU2NvcGVgLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseSh0ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBzY29wZSA9IFNjb3BlLm5ld1Jvb3RTY29wZSgpO1xuICAgICAgICBzY29wZS5pbmdlc3QodGVtcGxhdGUpO1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byBwcm9jZXNzIHRoZSB0ZW1wbGF0ZSBhbmQgcG9wdWxhdGUgdGhlIGBTY29wZWAuXG4gICAgICovXG4gICAgaW5nZXN0KHRlbXBsYXRlKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZSBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBWYXJpYWJsZXMgb24gYW4gPG5nLXRlbXBsYXRlPiBhcmUgZGVmaW5lZCBpbiB0aGUgaW5uZXIgc2NvcGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS52YXJpYWJsZXMuZm9yRWFjaChub2RlID0+IHRoaXMudmlzaXRWYXJpYWJsZShub2RlKSk7XG4gICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBub2RlcyBvZiB0aGUgdGVtcGxhdGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS5jaGlsZHJlbi5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBvdmVyYXJjaGluZyBgVGVtcGxhdGVgIGluc3RhbmNlLCBzbyBwcm9jZXNzIHRoZSBub2RlcyBkaXJlY3RseS5cbiAgICAgICAgICAgIHRlbXBsYXRlLmZvckVhY2gobm9kZSA9PiBub2RlLnZpc2l0KHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAvLyBgRWxlbWVudGBzIGluIHRoZSB0ZW1wbGF0ZSBtYXkgaGF2ZSBgUmVmZXJlbmNlYHMgd2hpY2ggYXJlIGNhcHR1cmVkIGluIHRoZSBzY29wZS5cbiAgICAgICAgZWxlbWVudC5yZWZlcmVuY2VzLmZvckVhY2gobm9kZSA9PiB0aGlzLnZpc2l0UmVmZXJlbmNlKG5vZGUpKTtcbiAgICAgICAgLy8gUmVjdXJzZSBpbnRvIHRoZSBgRWxlbWVudGAncyBjaGlsZHJlbi5cbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0VGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgLy8gUmVmZXJlbmNlcyBvbiBhIDxuZy10ZW1wbGF0ZT4gYXJlIGRlZmluZWQgaW4gdGhlIG91dGVyIHNjb3BlLCBzbyBjYXB0dXJlIHRoZW0gYmVmb3JlXG4gICAgICAgIC8vIHByb2Nlc3NpbmcgdGhlIHRlbXBsYXRlJ3MgY2hpbGQgc2NvcGUuXG4gICAgICAgIHRlbXBsYXRlLnJlZmVyZW5jZXMuZm9yRWFjaChub2RlID0+IHRoaXMudmlzaXRSZWZlcmVuY2Uobm9kZSkpO1xuICAgICAgICAvLyBOZXh0LCBjcmVhdGUgYW4gaW5uZXIgc2NvcGUgYW5kIHByb2Nlc3MgdGhlIHRlbXBsYXRlIHdpdGhpbiBpdC5cbiAgICAgICAgY29uc3Qgc2NvcGUgPSBuZXcgU2NvcGUodGhpcywgdGVtcGxhdGUpO1xuICAgICAgICBzY29wZS5pbmdlc3QodGVtcGxhdGUpO1xuICAgICAgICB0aGlzLmNoaWxkU2NvcGVzLnNldCh0ZW1wbGF0ZSwgc2NvcGUpO1xuICAgIH1cbiAgICB2aXNpdFZhcmlhYmxlKHZhcmlhYmxlKSB7XG4gICAgICAgIC8vIERlY2xhcmUgdGhlIHZhcmlhYmxlIGlmIGl0J3Mgbm90IGFscmVhZHkuXG4gICAgICAgIHRoaXMubWF5YmVEZWNsYXJlKHZhcmlhYmxlKTtcbiAgICB9XG4gICAgdmlzaXRSZWZlcmVuY2UocmVmZXJlbmNlKSB7XG4gICAgICAgIC8vIERlY2xhcmUgdGhlIHZhcmlhYmxlIGlmIGl0J3Mgbm90IGFscmVhZHkuXG4gICAgICAgIHRoaXMubWF5YmVEZWNsYXJlKHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIC8vIFVudXNlZCB2aXNpdG9ycy5cbiAgICB2aXNpdENvbnRlbnQoY29udGVudCkgeyB9XG4gICAgdmlzaXRCb3VuZEF0dHJpYnV0ZShhdHRyKSB7IH1cbiAgICB2aXNpdEJvdW5kRXZlbnQoZXZlbnQpIHsgfVxuICAgIHZpc2l0Qm91bmRUZXh0KHRleHQpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdFRleHRBdHRyaWJ1dGUoYXR0cikgeyB9XG4gICAgdmlzaXRJY3UoaWN1KSB7IH1cbiAgICBtYXliZURlY2xhcmUodGhpbmcpIHtcbiAgICAgICAgLy8gRGVjbGFyZSBzb21ldGhpbmcgd2l0aCBhIG5hbWUsIGFzIGxvbmcgYXMgdGhhdCBuYW1lIGlzbid0IHRha2VuLlxuICAgICAgICBpZiAoIXRoaXMubmFtZWRFbnRpdGllcy5oYXModGhpbmcubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZWRFbnRpdGllcy5zZXQodGhpbmcubmFtZSwgdGhpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2sgdXAgYSB2YXJpYWJsZSB3aXRoaW4gdGhpcyBgU2NvcGVgLlxuICAgICAqXG4gICAgICogVGhpcyBjYW4gcmVjdXJzZSBpbnRvIGEgcGFyZW50IGBTY29wZWAgaWYgaXQncyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgbG9va3VwKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZWRFbnRpdGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGluIHRoZSBsb2NhbCBzY29wZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWVkRW50aXRpZXMuZ2V0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50U2NvcGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE5vdCBpbiB0aGUgbG9jYWwgc2NvcGUsIGJ1dCB0aGVyZSdzIGEgcGFyZW50IHNjb3BlIHNvIGNoZWNrIHRoZXJlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NvcGUubG9va3VwKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQXQgdGhlIHRvcCBsZXZlbCBhbmQgaXQgd2Fzbid0IGZvdW5kLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGlsZCBzY29wZSBmb3IgYSBgVGVtcGxhdGVgLlxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgYWx3YXlzIGJlIGRlZmluZWQuXG4gICAgICovXG4gICAgZ2V0Q2hpbGRTY29wZSh0ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmNoaWxkU2NvcGVzLmdldCh0ZW1wbGF0ZSk7XG4gICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb24gZXJyb3I6IGNoaWxkIHNjb3BlIGZvciAke3RlbXBsYXRlfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbi8qKlxuICogUHJvY2Vzc2VzIGEgdGVtcGxhdGUgYW5kIG1hdGNoZXMgZGlyZWN0aXZlcyBvbiBub2RlcyAoZWxlbWVudHMgYW5kIHRlbXBsYXRlcykuXG4gKlxuICogVXN1YWxseSB1c2VkIHZpYSB0aGUgc3RhdGljIGBhcHBseSgpYCBtZXRob2QuXG4gKi9cbmNsYXNzIERpcmVjdGl2ZUJpbmRlciB7XG4gICAgY29uc3RydWN0b3IobWF0Y2hlciwgZGlyZWN0aXZlcywgYmluZGluZ3MsIHJlZmVyZW5jZXMpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVyID0gbWF0Y2hlcjtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gZGlyZWN0aXZlcztcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSByZWZlcmVuY2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgdGVtcGxhdGUgKGxpc3Qgb2YgYE5vZGVgcykgYW5kIHBlcmZvcm0gZGlyZWN0aXZlIG1hdGNoaW5nIGFnYWluc3QgZWFjaCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIHRoZSBsaXN0IG9mIHRlbXBsYXRlIGBOb2RlYHMgdG8gbWF0Y2ggKHJlY3Vyc2l2ZWx5KS5cbiAgICAgKiBAcGFyYW0gc2VsZWN0b3JNYXRjaGVyIGEgYFNlbGVjdG9yTWF0Y2hlcmAgY29udGFpbmluZyB0aGUgZGlyZWN0aXZlcyB0aGF0IGFyZSBpbiBzY29wZSBmb3JcbiAgICAgKiB0aGlzIHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm5zIHRocmVlIG1hcHMgd2hpY2ggY29udGFpbiBpbmZvcm1hdGlvbiBhYm91dCBkaXJlY3RpdmVzIGluIHRoZSB0ZW1wbGF0ZTogdGhlXG4gICAgICogYGRpcmVjdGl2ZXNgIG1hcCB3aGljaCBsaXN0cyBkaXJlY3RpdmVzIG1hdGNoZWQgb24gZWFjaCBub2RlLCB0aGUgYGJpbmRpbmdzYCBtYXAgd2hpY2hcbiAgICAgKiBpbmRpY2F0ZXMgd2hpY2ggZGlyZWN0aXZlcyBjbGFpbWVkIHdoaWNoIGJpbmRpbmdzIChpbnB1dHMsIG91dHB1dHMsIGV0YyksIGFuZCB0aGUgYHJlZmVyZW5jZXNgXG4gICAgICogbWFwIHdoaWNoIHJlc29sdmVzICNyZWZlcmVuY2VzIChgUmVmZXJlbmNlYHMpIHdpdGhpbiB0aGUgdGVtcGxhdGUgdG8gdGhlIG5hbWVkIGRpcmVjdGl2ZSBvclxuICAgICAqIHRlbXBsYXRlIG5vZGUuXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5KHRlbXBsYXRlLCBzZWxlY3Rvck1hdGNoZXIpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgYmluZGluZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IG1hdGNoZXIgPSBuZXcgRGlyZWN0aXZlQmluZGVyKHNlbGVjdG9yTWF0Y2hlciwgZGlyZWN0aXZlcywgYmluZGluZ3MsIHJlZmVyZW5jZXMpO1xuICAgICAgICBtYXRjaGVyLmluZ2VzdCh0ZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiB7IGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzIH07XG4gICAgfVxuICAgIGluZ2VzdCh0ZW1wbGF0ZSkge1xuICAgICAgICB0ZW1wbGF0ZS5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMudmlzaXRFbGVtZW50T3JUZW1wbGF0ZShlbGVtZW50Lm5hbWUsIGVsZW1lbnQpO1xuICAgIH1cbiAgICB2aXNpdFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMudmlzaXRFbGVtZW50T3JUZW1wbGF0ZSgnbmctdGVtcGxhdGUnLCB0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudE9yVGVtcGxhdGUoZWxlbWVudE5hbWUsIG5vZGUpIHtcbiAgICAgICAgLy8gRmlyc3QsIGRldGVybWluZSB0aGUgSFRNTCBzaGFwZSBvZiB0aGUgbm9kZSBmb3IgdGhlIHB1cnBvc2Ugb2YgZGlyZWN0aXZlIG1hdGNoaW5nLlxuICAgICAgICAvLyBEbyB0aGlzIGJ5IGJ1aWxkaW5nIHVwIGEgYENzc1NlbGVjdG9yYCBmb3IgdGhlIG5vZGUuXG4gICAgICAgIGNvbnN0IGNzc1NlbGVjdG9yID0gY3JlYXRlQ3NzU2VsZWN0b3IoZWxlbWVudE5hbWUsIGdldEF0dHJzRm9yRGlyZWN0aXZlTWF0Y2hpbmcobm9kZSkpO1xuICAgICAgICAvLyBOZXh0LCB1c2UgdGhlIGBTZWxlY3Rvck1hdGNoZXJgIHRvIGdldCB0aGUgbGlzdCBvZiBkaXJlY3RpdmVzIG9uIHRoZSBub2RlLlxuICAgICAgICBjb25zdCBkaXJlY3RpdmVzID0gW107XG4gICAgICAgIHRoaXMubWF0Y2hlci5tYXRjaChjc3NTZWxlY3RvciwgKF8sIGRpcmVjdGl2ZSkgPT4gZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSkpO1xuICAgICAgICBpZiAoZGlyZWN0aXZlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuc2V0KG5vZGUsIGRpcmVjdGl2ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc29sdmUgYW55IHJlZmVyZW5jZXMgdGhhdCBhcmUgY3JlYXRlZCBvbiB0aGlzIG5vZGUuXG4gICAgICAgIG5vZGUucmVmZXJlbmNlcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgICAgICBsZXQgZGlyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIElmIHRoZSByZWZlcmVuY2UgZXhwcmVzc2lvbiBpcyBlbXB0eSwgdGhlbiBpdCBtYXRjaGVzIHRoZSBcInByaW1hcnlcIiBkaXJlY3RpdmUgb24gdGhlIG5vZGVcbiAgICAgICAgICAgIC8vIChpZiB0aGVyZSBpcyBvbmUpLiBPdGhlcndpc2UgaXQgbWF0Y2hlcyB0aGUgaG9zdCBub2RlIGl0c2VsZiAoZWl0aGVyIGFuIGVsZW1lbnQgb3JcbiAgICAgICAgICAgIC8vIDxuZy10ZW1wbGF0ZT4gbm9kZSkuXG4gICAgICAgICAgICBpZiAocmVmLnZhbHVlLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGEgcmVmZXJlbmNlIHRvIGEgY29tcG9uZW50IGlmIHRoZXJlIGlzIG9uZS5cbiAgICAgICAgICAgICAgICBkaXJUYXJnZXQgPSBkaXJlY3RpdmVzLmZpbmQoZGlyID0+IGRpci5pc0NvbXBvbmVudCkgfHwgbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGEgcmVmZXJlbmNlIHRvIGEgZGlyZWN0aXZlIGV4cG9ydGVkIHZpYSBleHBvcnRBcy5cbiAgICAgICAgICAgICAgICBkaXJUYXJnZXQgPVxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzLmZpbmQoZGlyID0+IGRpci5leHBvcnRBcyAhPT0gbnVsbCAmJiBkaXIuZXhwb3J0QXMuc29tZSh2YWx1ZSA9PiB2YWx1ZSA9PT0gcmVmLnZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSBtYXRjaGluZyBkaXJlY3RpdmUgd2FzIGZvdW5kLlxuICAgICAgICAgICAgICAgIGlmIChkaXJUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gbWF0Y2hpbmcgZGlyZWN0aXZlIHdhcyBmb3VuZCAtIHRoaXMgcmVmZXJlbmNlIHBvaW50cyB0byBhbiB1bmtub3duIHRhcmdldC4gTGVhdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5tYXBwZWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZWZlcmVuY2UgcG9pbnRzIHRvIGEgZGlyZWN0aXZlLlxuICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlcy5zZXQocmVmLCB7IGRpcmVjdGl2ZTogZGlyVGFyZ2V0LCBub2RlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyByZWZlcmVuY2UgcG9pbnRzIHRvIHRoZSBub2RlIGl0c2VsZi5cbiAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jZXMuc2V0KHJlZiwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZXRBdHRyaWJ1dGVCaW5kaW5nID0gKGF0dHJpYnV0ZSwgaW9UeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXIgPSBkaXJlY3RpdmVzLmZpbmQoZGlyID0+IGRpcltpb1R5cGVdLmhhc0JpbmRpbmdQcm9wZXJ0eU5hbWUoYXR0cmlidXRlLm5hbWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGJpbmRpbmcgPSBkaXIgIT09IHVuZGVmaW5lZCA/IGRpciA6IG5vZGU7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzLnNldChhdHRyaWJ1dGUsIGJpbmRpbmcpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBOb2RlIGlucHV0cyAoYm91bmQgYXR0cmlidXRlcykgYW5kIHRleHQgYXR0cmlidXRlcyBjYW4gYmUgYm91bmQgdG8gYW5cbiAgICAgICAgLy8gaW5wdXQgb24gYSBkaXJlY3RpdmUuXG4gICAgICAgIG5vZGUuaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gc2V0QXR0cmlidXRlQmluZGluZyhpbnB1dCwgJ2lucHV0cycpKTtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLmZvckVhY2goYXR0ciA9PiBzZXRBdHRyaWJ1dGVCaW5kaW5nKGF0dHIsICdpbnB1dHMnKSk7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIG5vZGUudGVtcGxhdGVBdHRycy5mb3JFYWNoKGF0dHIgPT4gc2V0QXR0cmlidXRlQmluZGluZyhhdHRyLCAnaW5wdXRzJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vZGUgb3V0cHV0cyAoYm91bmQgZXZlbnRzKSBjYW4gYmUgYm91bmQgdG8gYW4gb3V0cHV0IG9uIGEgZGlyZWN0aXZlLlxuICAgICAgICBub2RlLm91dHB1dHMuZm9yRWFjaChvdXRwdXQgPT4gc2V0QXR0cmlidXRlQmluZGluZyhvdXRwdXQsICdvdXRwdXRzJykpO1xuICAgICAgICAvLyBSZWN1cnNlIGludG8gdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgLy8gVW51c2VkIHZpc2l0b3JzLlxuICAgIHZpc2l0Q29udGVudChjb250ZW50KSB7IH1cbiAgICB2aXNpdFZhcmlhYmxlKHZhcmlhYmxlKSB7IH1cbiAgICB2aXNpdFJlZmVyZW5jZShyZWZlcmVuY2UpIHsgfVxuICAgIHZpc2l0VGV4dEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0Qm91bmRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdEJvdW5kRXZlbnQoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdEJvdW5kQXR0cmlidXRlT3JFdmVudChub2RlKSB7IH1cbiAgICB2aXNpdFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRCb3VuZFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRJY3UoaWN1KSB7IH1cbn1cbi8qKlxuICogUHJvY2Vzc2VzIGEgdGVtcGxhdGUgYW5kIGV4dHJhY3QgbWV0YWRhdGEgYWJvdXQgZXhwcmVzc2lvbnMgYW5kIHN5bWJvbHMgd2l0aGluLlxuICpcbiAqIFRoaXMgaXMgYSBjb21wYW5pb24gdG8gdGhlIGBEaXJlY3RpdmVCaW5kZXJgIHRoYXQgZG9lc24ndCByZXF1aXJlIGtub3dsZWRnZSBvZiBkaXJlY3RpdmVzIG1hdGNoZWRcbiAqIHdpdGhpbiB0aGUgdGVtcGxhdGUgaW4gb3JkZXIgdG8gb3BlcmF0ZS5cbiAqXG4gKiBFeHByZXNzaW9ucyBhcmUgdmlzaXRlZCBieSB0aGUgc3VwZXJjbGFzcyBgUmVjdXJzaXZlQXN0VmlzaXRvcmAsIHdpdGggY3VzdG9tIGxvZ2ljIHByb3ZpZGVkXG4gKiBieSBvdmVycmlkZGVuIG1ldGhvZHMgZnJvbSB0aGF0IHZpc2l0b3IuXG4gKi9cbmNsYXNzIFRlbXBsYXRlQmluZGVyIGV4dGVuZHMgUmVjdXJzaXZlQXN0VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZ3MsIHN5bWJvbHMsIHVzZWRQaXBlcywgbmVzdGluZ0xldmVsLCBzY29wZSwgdGVtcGxhdGUsIGxldmVsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gc3ltYm9scztcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgICAgIHRoaXMubmVzdGluZ0xldmVsID0gbmVzdGluZ0xldmVsO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLnBpcGVzVXNlZCA9IFtdO1xuICAgICAgICAvLyBTYXZlIGEgYml0IG9mIHByb2Nlc3NpbmcgdGltZSBieSBjb25zdHJ1Y3RpbmcgdGhpcyBjbG9zdXJlIGluIGFkdmFuY2UuXG4gICAgICAgIHRoaXMudmlzaXROb2RlID0gKG5vZGUpID0+IG5vZGUudmlzaXQodGhpcyk7XG4gICAgfVxuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGRlZmluZWQgdG8gcmVjb25jaWxlIHRoZSB0eXBlIG9mIFRlbXBsYXRlQmluZGVyIHNpbmNlIGJvdGhcbiAgICAvLyBSZWN1cnNpdmVBc3RWaXNpdG9yIGFuZCBWaXNpdG9yIGRlZmluZSB0aGUgdmlzaXQoKSBtZXRob2QgaW4gdGhlaXJcbiAgICAvLyBpbnRlcmZhY2VzLlxuICAgIHZpc2l0KG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1QpIHtcbiAgICAgICAgICAgIG5vZGUudmlzaXQodGhpcywgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLnZpc2l0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgYSB0ZW1wbGF0ZSBhbmQgZXh0cmFjdCBtZXRhZGF0YSBhYm91dCBleHByZXNzaW9ucyBhbmQgc3ltYm9scyB3aXRoaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGUgdGhlIG5vZGVzIG9mIHRoZSB0ZW1wbGF0ZSB0byBwcm9jZXNzXG4gICAgICogQHBhcmFtIHNjb3BlIHRoZSBgU2NvcGVgIG9mIHRoZSB0ZW1wbGF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gICAgICogQHJldHVybnMgdGhyZWUgbWFwcyB3aGljaCBjb250YWluIG1ldGFkYXRhIGFib3V0IHRoZSB0ZW1wbGF0ZTogYGV4cHJlc3Npb25zYCB3aGljaCBpbnRlcnByZXRzXG4gICAgICogc3BlY2lhbCBgQVNUYCBub2RlcyBpbiBleHByZXNzaW9ucyBhcyBwb2ludGluZyB0byByZWZlcmVuY2VzIG9yIHZhcmlhYmxlcyBkZWNsYXJlZCB3aXRoaW4gdGhlXG4gICAgICogdGVtcGxhdGUsIGBzeW1ib2xzYCB3aGljaCBtYXBzIHRob3NlIHZhcmlhYmxlcyBhbmQgcmVmZXJlbmNlcyB0byB0aGUgbmVzdGVkIGBUZW1wbGF0ZWAgd2hpY2hcbiAgICAgKiBkZWNsYXJlcyB0aGVtLCBpZiBhbnksIGFuZCBgbmVzdGluZ0xldmVsYCB3aGljaCBhc3NvY2lhdGVzIGVhY2ggYFRlbXBsYXRlYCB3aXRoIGEgaW50ZWdlclxuICAgICAqIG5lc3RpbmcgbGV2ZWwgKGhvdyBtYW55IGxldmVscyBkZWVwIHdpdGhpbiB0aGUgdGVtcGxhdGUgc3RydWN0dXJlIHRoZSBgVGVtcGxhdGVgIGlzKSwgc3RhcnRpbmdcbiAgICAgKiBhdCAxLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseVdpdGhTY29wZSh0ZW1wbGF0ZSwgc2NvcGUpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHN5bWJvbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IG5lc3RpbmdMZXZlbCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgdXNlZFBpcGVzID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBUaGUgdG9wLWxldmVsIHRlbXBsYXRlIGhhcyBuZXN0aW5nIGxldmVsIDAuXG4gICAgICAgIGNvbnN0IGJpbmRlciA9IG5ldyBUZW1wbGF0ZUJpbmRlcihleHByZXNzaW9ucywgc3ltYm9scywgdXNlZFBpcGVzLCBuZXN0aW5nTGV2ZWwsIHNjb3BlLCB0ZW1wbGF0ZSBpbnN0YW5jZW9mIFRlbXBsYXRlID8gdGVtcGxhdGUgOiBudWxsLCAwKTtcbiAgICAgICAgYmluZGVyLmluZ2VzdCh0ZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiB7IGV4cHJlc3Npb25zLCBzeW1ib2xzLCBuZXN0aW5nTGV2ZWwsIHVzZWRQaXBlcyB9O1xuICAgIH1cbiAgICBpbmdlc3QodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIC8vIEZvciA8bmctdGVtcGxhdGU+cywgcHJvY2VzcyBvbmx5IHZhcmlhYmxlcyBhbmQgY2hpbGQgbm9kZXMuIElucHV0cywgb3V0cHV0cywgdGVtcGxhdGVBdHRycyxcbiAgICAgICAgICAgIC8vIGFuZCByZWZlcmVuY2VzIHdlcmUgYWxsIHByb2Nlc3NlZCBpbiB0aGUgc2NvcGUgb2YgdGhlIGNvbnRhaW5pbmcgdGVtcGxhdGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS52YXJpYWJsZXMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgICAgICB0ZW1wbGF0ZS5jaGlsZHJlbi5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmVzdGluZyBsZXZlbC5cbiAgICAgICAgICAgIHRoaXMubmVzdGluZ0xldmVsLnNldCh0ZW1wbGF0ZSwgdGhpcy5sZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBWaXNpdCBlYWNoIG5vZGUgZnJvbSB0aGUgdG9wLWxldmVsIHRlbXBsYXRlLlxuICAgICAgICAgICAgdGVtcGxhdGUuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgLy8gVmlzaXQgdGhlIGlucHV0cywgb3V0cHV0cywgYW5kIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50LlxuICAgICAgICBlbGVtZW50LmlucHV0cy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgZWxlbWVudC5vdXRwdXRzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICBlbGVtZW50LmNoaWxkcmVuLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgIH1cbiAgICB2aXNpdFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIC8vIEZpcnN0LCB2aXNpdCBpbnB1dHMsIG91dHB1dHMgYW5kIHRlbXBsYXRlIGF0dHJpYnV0ZXMgb2YgdGhlIHRlbXBsYXRlIG5vZGUuXG4gICAgICAgIHRlbXBsYXRlLmlucHV0cy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgdGVtcGxhdGUub3V0cHV0cy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgdGVtcGxhdGUudGVtcGxhdGVBdHRycy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgLy8gUmVmZXJlbmNlcyBhcmUgYWxzbyBldmFsdWF0ZWQgaW4gdGhlIG91dGVyIGNvbnRleHQuXG4gICAgICAgIHRlbXBsYXRlLnJlZmVyZW5jZXMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIC8vIE5leHQsIHJlY3Vyc2UgaW50byB0aGUgdGVtcGxhdGUgdXNpbmcgaXRzIHNjb3BlLCBhbmQgYnVtcGluZyB0aGUgbmVzdGluZyBsZXZlbCB1cCBieSBvbmUuXG4gICAgICAgIGNvbnN0IGNoaWxkU2NvcGUgPSB0aGlzLnNjb3BlLmdldENoaWxkU2NvcGUodGVtcGxhdGUpO1xuICAgICAgICBjb25zdCBiaW5kZXIgPSBuZXcgVGVtcGxhdGVCaW5kZXIodGhpcy5iaW5kaW5ncywgdGhpcy5zeW1ib2xzLCB0aGlzLnVzZWRQaXBlcywgdGhpcy5uZXN0aW5nTGV2ZWwsIGNoaWxkU2NvcGUsIHRlbXBsYXRlLCB0aGlzLmxldmVsICsgMSk7XG4gICAgICAgIGJpbmRlci5pbmdlc3QodGVtcGxhdGUpO1xuICAgIH1cbiAgICB2aXNpdFZhcmlhYmxlKHZhcmlhYmxlKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBgVmFyaWFibGVgIGFzIGEgc3ltYm9sIGluIHRoZSBjdXJyZW50IGBUZW1wbGF0ZWAuXG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbHMuc2V0KHZhcmlhYmxlLCB0aGlzLnRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFJlZmVyZW5jZShyZWZlcmVuY2UpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGBSZWZlcmVuY2VgIGFzIGEgc3ltYm9sIGluIHRoZSBjdXJyZW50IGBUZW1wbGF0ZWAuXG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN5bWJvbHMuc2V0KHJlZmVyZW5jZSwgdGhpcy50ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVW51c2VkIHRlbXBsYXRlIHZpc2l0b3JzXG4gICAgdmlzaXRUZXh0KHRleHQpIHsgfVxuICAgIHZpc2l0Q29udGVudChjb250ZW50KSB7IH1cbiAgICB2aXNpdFRleHRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdEljdShpY3UpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LnZhcnMpLmZvckVhY2goa2V5ID0+IGljdS52YXJzW2tleV0udmlzaXQodGhpcykpO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UucGxhY2Vob2xkZXJzKS5mb3JFYWNoKGtleSA9PiBpY3UucGxhY2Vob2xkZXJzW2tleV0udmlzaXQodGhpcykpO1xuICAgIH1cbiAgICAvLyBUaGUgcmVtYWluaW5nIHZpc2l0b3JzIGFyZSBjb25jZXJuZWQgd2l0aCBwcm9jZXNzaW5nIEFTVCBleHByZXNzaW9ucyB3aXRoaW4gdGVtcGxhdGUgYmluZGluZ3NcbiAgICB2aXNpdEJvdW5kQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgICAgICBhdHRyaWJ1dGUudmFsdWUudmlzaXQodGhpcyk7XG4gICAgfVxuICAgIHZpc2l0Qm91bmRFdmVudChldmVudCkge1xuICAgICAgICBldmVudC5oYW5kbGVyLnZpc2l0KHRoaXMpO1xuICAgIH1cbiAgICB2aXNpdEJvdW5kVGV4dCh0ZXh0KSB7XG4gICAgICAgIHRleHQudmFsdWUudmlzaXQodGhpcyk7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy51c2VkUGlwZXMuYWRkKGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0UGlwZShhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBUaGVzZSBmaXZlIHR5cGVzIG9mIEFTVCBleHByZXNzaW9ucyBjYW4gcmVmZXIgdG8gZXhwcmVzc2lvbiByb290cywgd2hpY2ggY291bGQgYmUgdmFyaWFibGVzXG4gICAgLy8gb3IgcmVmZXJlbmNlcyBpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXliZU1hcChjb250ZXh0LCBhc3QsIGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0UHJvcGVydHlSZWFkKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXliZU1hcChjb250ZXh0LCBhc3QsIGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubWF5YmVNYXAoY29udGV4dCwgYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBzdXBlci52aXNpdFByb3BlcnR5V3JpdGUoYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgbWF5YmVNYXAoc2NvcGUsIGFzdCwgbmFtZSkge1xuICAgICAgICAvLyBJZiB0aGUgcmVjZWl2ZXIgb2YgdGhlIGV4cHJlc3Npb24gaXNuJ3QgdGhlIGBJbXBsaWNpdFJlY2VpdmVyYCwgdGhpcyBpc24ndCB0aGUgcm9vdCBvZiBhblxuICAgICAgICAvLyBgQVNUYCBleHByZXNzaW9uIHRoYXQgbWFwcyB0byBhIGBWYXJpYWJsZWAgb3IgYFJlZmVyZW5jZWAuXG4gICAgICAgIGlmICghKGFzdC5yZWNlaXZlciBpbnN0YW5jZW9mIEltcGxpY2l0UmVjZWl2ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgbmFtZSBleGlzdHMgaW4gdGhlIGN1cnJlbnQgc2NvcGUuIElmIHNvLCBtYXAgaXQuIE90aGVyd2lzZSwgdGhlIG5hbWUgaXNcbiAgICAgICAgLy8gcHJvYmFibHkgYSBwcm9wZXJ0eSBvbiB0aGUgdG9wLWxldmVsIGNvbXBvbmVudCBjb250ZXh0LlxuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zY29wZS5sb29rdXAobmFtZSk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3Muc2V0KGFzdCwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWV0YWRhdGEgY29udGFpbmVyIGZvciBhIGBUYXJnZXRgIHRoYXQgYWxsb3dzIHF1ZXJpZXMgZm9yIHNwZWNpZmljIGJpdHMgb2YgbWV0YWRhdGEuXG4gKlxuICogU2VlIGBCb3VuZFRhcmdldGAgZm9yIGRvY3VtZW50YXRpb24gb24gdGhlIGluZGl2aWR1YWwgbWV0aG9kcy5cbiAqL1xuY2xhc3MgUjNCb3VuZFRhcmdldCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBkaXJlY3RpdmVzLCBiaW5kaW5ncywgcmVmZXJlbmNlcywgZXhwclRhcmdldHMsIHN5bWJvbHMsIG5lc3RpbmdMZXZlbCwgdGVtcGxhdGVFbnRpdGllcywgdXNlZFBpcGVzKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBkaXJlY3RpdmVzO1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgIHRoaXMuZXhwclRhcmdldHMgPSBleHByVGFyZ2V0cztcbiAgICAgICAgdGhpcy5zeW1ib2xzID0gc3ltYm9scztcbiAgICAgICAgdGhpcy5uZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWw7XG4gICAgICAgIHRoaXMudGVtcGxhdGVFbnRpdGllcyA9IHRlbXBsYXRlRW50aXRpZXM7XG4gICAgICAgIHRoaXMudXNlZFBpcGVzID0gdXNlZFBpcGVzO1xuICAgIH1cbiAgICBnZXRFbnRpdGllc0luVGVtcGxhdGVTY29wZSh0ZW1wbGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnRlbXBsYXRlRW50aXRpZXMuZ2V0KHRlbXBsYXRlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFNldCgpO1xuICAgIH1cbiAgICBnZXREaXJlY3RpdmVzT2ZOb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aXZlcy5nZXQobm9kZSkgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0UmVmZXJlbmNlVGFyZ2V0KHJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VzLmdldChyZWYpIHx8IG51bGw7XG4gICAgfVxuICAgIGdldENvbnN1bWVyT2ZCaW5kaW5nKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3MuZ2V0KGJpbmRpbmcpIHx8IG51bGw7XG4gICAgfVxuICAgIGdldEV4cHJlc3Npb25UYXJnZXQoZXhwcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByVGFyZ2V0cy5nZXQoZXhwcikgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0VGVtcGxhdGVPZlN5bWJvbChzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9scy5nZXQoc3ltYm9sKSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXROZXN0aW5nTGV2ZWwodGVtcGxhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVzdGluZ0xldmVsLmdldCh0ZW1wbGF0ZSkgfHwgMDtcbiAgICB9XG4gICAgZ2V0VXNlZERpcmVjdGl2ZXMoKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmZvckVhY2goZGlycyA9PiBkaXJzLmZvckVhY2goZGlyID0+IHNldC5hZGQoZGlyKSkpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzZXQudmFsdWVzKCkpO1xuICAgIH1cbiAgICBnZXRVc2VkUGlwZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudXNlZFBpcGVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBleHRyYWN0VGVtcGxhdGVFbnRpdGllcyhyb290U2NvcGUpIHtcbiAgICBjb25zdCBlbnRpdHlNYXAgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gZXh0cmFjdFNjb3BlRW50aXRpZXMoc2NvcGUpIHtcbiAgICAgICAgaWYgKGVudGl0eU1hcC5oYXMoc2NvcGUudGVtcGxhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50aXR5TWFwLmdldChzY29wZS50ZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEVudGl0aWVzID0gc2NvcGUubmFtZWRFbnRpdGllcztcbiAgICAgICAgbGV0IHRlbXBsYXRlRW50aXRpZXM7XG4gICAgICAgIGlmIChzY29wZS5wYXJlbnRTY29wZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGVtcGxhdGVFbnRpdGllcyA9IG5ldyBNYXAoWy4uLmV4dHJhY3RTY29wZUVudGl0aWVzKHNjb3BlLnBhcmVudFNjb3BlKSwgLi4uY3VycmVudEVudGl0aWVzXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVudGl0aWVzID0gbmV3IE1hcChjdXJyZW50RW50aXRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVudGl0eU1hcC5zZXQoc2NvcGUudGVtcGxhdGUsIHRlbXBsYXRlRW50aXRpZXMpO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVFbnRpdGllcztcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzVG9Qcm9jZXNzID0gW3Jvb3RTY29wZV07XG4gICAgd2hpbGUgKHNjb3Blc1RvUHJvY2Vzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gc2NvcGVzVG9Qcm9jZXNzLnBvcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkU2NvcGUgb2Ygc2NvcGUuY2hpbGRTY29wZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNjb3Blc1RvUHJvY2Vzcy5wdXNoKGNoaWxkU2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhY3RTY29wZUVudGl0aWVzKHNjb3BlKTtcbiAgICB9XG4gICAgY29uc3QgdGVtcGxhdGVFbnRpdGllcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFt0ZW1wbGF0ZSwgZW50aXRpZXNdIG9mIGVudGl0eU1hcCkge1xuICAgICAgICB0ZW1wbGF0ZUVudGl0aWVzLnNldCh0ZW1wbGF0ZSwgbmV3IFNldChlbnRpdGllcy52YWx1ZXMoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGVFbnRpdGllcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjb21waWxlQ2xhc3NNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgLy8gR2VuZXJhdGUgYW4gbmdEZXZNb2RlIGd1YXJkZWQgY2FsbCB0byBzZXRDbGFzc01ldGFkYXRhIHdpdGggdGhlIGNsYXNzIGlkZW50aWZpZXIgYW5kIGl0c1xuICAgIC8vIG1ldGFkYXRhLlxuICAgIGNvbnN0IGZuQ2FsbCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuc2V0Q2xhc3NNZXRhZGF0YSkuY2FsbEZuKFtcbiAgICAgICAgbWV0YWRhdGEudHlwZSxcbiAgICAgICAgbWV0YWRhdGEuZGVjb3JhdG9ycyxcbiAgICAgICAgKF9hID0gbWV0YWRhdGEuY3RvclBhcmFtZXRlcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGxpdGVyYWwobnVsbCksXG4gICAgICAgIChfYiA9IG1ldGFkYXRhLnByb3BEZWNvcmF0b3JzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBsaXRlcmFsKG51bGwpLFxuICAgIF0pO1xuICAgIGNvbnN0IGlpZmUgPSBmbihbXSwgW2Rldk9ubHlHdWFyZGVkRXhwcmVzc2lvbihmbkNhbGwpLnRvU3RtdCgpXSk7XG4gICAgcmV0dXJuIGlpZmUuY2FsbEZuKFtdKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDYgPSAnMTIuMC4wJztcbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlQ2xhc3NNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdtaW5WZXJzaW9uJywgbGl0ZXJhbChNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kNikpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2ZXJzaW9uJywgbGl0ZXJhbCgnMTQuMC4wJykpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCduZ0ltcG9ydCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuY29yZSkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbWV0YWRhdGEudHlwZSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlY29yYXRvcnMnLCBtZXRhZGF0YS5kZWNvcmF0b3JzKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnY3RvclBhcmFtZXRlcnMnLCBtZXRhZGF0YS5jdG9yUGFyYW1ldGVycyk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3Byb3BEZWNvcmF0b3JzJywgbWV0YWRhdGEucHJvcERlY29yYXRvcnMpO1xuICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlY2xhcmVDbGFzc01ldGFkYXRhKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgbGl0ZXJhbCBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIGFycmF5LCBtYXBwaW5nIGFsbCB2YWx1ZXMgdG8gYW4gZXhwcmVzc2lvblxuICogdXNpbmcgdGhlIHByb3ZpZGVkIG1hcHBpbmcgZnVuY3Rpb24uIElmIHRoZSBhcnJheSBpcyBlbXB0eSBvciBudWxsLCB0aGVuIG51bGwgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlcyBUaGUgYXJyYXkgdG8gdHJhbnNmZXIgaW50byBsaXRlcmFsIGFycmF5IGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gbWFwcGVyIFRoZSBsb2dpYyB0byB1c2UgZm9yIGNyZWF0aW5nIGFuIGV4cHJlc3Npb24gZm9yIHRoZSBhcnJheSdzIHZhbHVlcy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IGxpdGVyYWwgZXhwcmVzc2lvbiByZXByZXNlbnRpbmcgYHZhbHVlc2AsIG9yIG51bGwgaWYgYHZhbHVlc2AgaXMgZW1wdHkgb3JcbiAqIGlzIGl0c2VsZiBudWxsLlxuICovXG5mdW5jdGlvbiB0b09wdGlvbmFsTGl0ZXJhbEFycmF5KHZhbHVlcywgbWFwcGVyKSB7XG4gICAgaWYgKHZhbHVlcyA9PT0gbnVsbCB8fCB2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbGl0ZXJhbEFycih2YWx1ZXMubWFwKHZhbHVlID0+IG1hcHBlcih2YWx1ZSkpKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgbGl0ZXJhbCBleHByZXNzaW9uIGZyb20gdGhlIGdpdmVuIG9iamVjdCwgbWFwcGluZyBhbGwgdmFsdWVzIHRvIGFuIGV4cHJlc3Npb25cbiAqIHVzaW5nIHRoZSBwcm92aWRlZCBtYXBwaW5nIGZ1bmN0aW9uLiBJZiB0aGUgb2JqZWN0IGhhcyBubyBrZXlzLCB0aGVuIG51bGwgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIHRyYW5zZmVyIGludG8gYW4gb2JqZWN0IGxpdGVyYWwgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSBtYXBwZXIgVGhlIGxvZ2ljIHRvIHVzZSBmb3IgY3JlYXRpbmcgYW4gZXhwcmVzc2lvbiBmb3IgdGhlIG9iamVjdCdzIHZhbHVlcy5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBsaXRlcmFsIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIGBvYmplY3RgLCBvciBudWxsIGlmIGBvYmplY3RgIGRvZXMgbm90IGhhdmVcbiAqIGFueSBrZXlzLlxuICovXG5mdW5jdGlvbiB0b09wdGlvbmFsTGl0ZXJhbE1hcChvYmplY3QsIG1hcHBlcikge1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3Qua2V5cyhvYmplY3QpLm1hcChrZXkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICByZXR1cm4geyBrZXksIHZhbHVlOiBtYXBwZXIodmFsdWUpLCBxdW90ZWQ6IHRydWUgfTtcbiAgICB9KTtcbiAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsTWFwKGVudHJpZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGlsZURlcGVuZGVuY2llcyhkZXBzKSB7XG4gICAgaWYgKGRlcHMgPT09ICdpbnZhbGlkJykge1xuICAgICAgICAvLyBUaGUgYGRlcHNgIGNhbiBiZSBzZXQgdG8gdGhlIHN0cmluZyBcImludmFsaWRcIiAgYnkgdGhlIGB1bndyYXBDb25zdHJ1Y3RvckRlcGVuZGVuY2llcygpYFxuICAgICAgICAvLyBmdW5jdGlvbiwgd2hpY2ggdHJpZXMgdG8gY29udmVydCBgQ29uc3RydWN0b3JEZXBzYCBpbnRvIGBSM0RlcGVuZGVuY3lNZXRhZGF0YVtdYC5cbiAgICAgICAgcmV0dXJuIGxpdGVyYWwoJ2ludmFsaWQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVwcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbChudWxsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKGRlcHMubWFwKGNvbXBpbGVEZXBlbmRlbmN5KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGlsZURlcGVuZGVuY3koZGVwKSB7XG4gICAgY29uc3QgZGVwTWV0YSA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVwTWV0YS5zZXQoJ3Rva2VuJywgZGVwLnRva2VuKTtcbiAgICBpZiAoZGVwLmF0dHJpYnV0ZU5hbWVUeXBlICE9PSBudWxsKSB7XG4gICAgICAgIGRlcE1ldGEuc2V0KCdhdHRyaWJ1dGUnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgaWYgKGRlcC5ob3N0KSB7XG4gICAgICAgIGRlcE1ldGEuc2V0KCdob3N0JywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIGlmIChkZXAub3B0aW9uYWwpIHtcbiAgICAgICAgZGVwTWV0YS5zZXQoJ29wdGlvbmFsJywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIGlmIChkZXAuc2VsZikge1xuICAgICAgICBkZXBNZXRhLnNldCgnc2VsZicsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBpZiAoZGVwLnNraXBTZWxmKSB7XG4gICAgICAgIGRlcE1ldGEuc2V0KCdza2lwU2VsZicsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVwTWV0YS50b0xpdGVyYWxNYXAoKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDUgPSAnMTQuMC4wJztcbi8qKlxuICogQ29tcGlsZSBhIGRpcmVjdGl2ZSBkZWNsYXJhdGlvbiBkZWZpbmVkIGJ5IHRoZSBgUjNEaXJlY3RpdmVNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlRGlyZWN0aXZlRnJvbU1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlRGlyZWN0aXZlRGVmaW5pdGlvbk1hcChtZXRhKTtcbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5kZWNsYXJlRGlyZWN0aXZlKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbiAgICBjb25zdCB0eXBlID0gY3JlYXRlRGlyZWN0aXZlVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuLyoqXG4gKiBHYXRoZXJzIHRoZSBkZWNsYXJhdGlvbiBmaWVsZHMgZm9yIGEgZGlyZWN0aXZlIGludG8gYSBgRGVmaW5pdGlvbk1hcGAuIFRoaXMgYWxsb3dzIGZvciByZXVzaW5nXG4gKiB0aGlzIGxvZ2ljIGZvciBjb21wb25lbnRzLCBhcyB0aGV5IGV4dGVuZCB0aGUgZGlyZWN0aXZlIG1ldGFkYXRhLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXJlY3RpdmVEZWZpbml0aW9uTWFwKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbWluVmVyc2lvbicsIGxpdGVyYWwoTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDUpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndmVyc2lvbicsIGxpdGVyYWwoJzE0LjAuMCcpKTtcbiAgICAvLyBlLmcuIGB0eXBlOiBNeURpcmVjdGl2ZWBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG1ldGEuaW50ZXJuYWxUeXBlKTtcbiAgICBpZiAobWV0YS5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2lzU3RhbmRhbG9uZScsIGxpdGVyYWwobWV0YS5pc1N0YW5kYWxvbmUpKTtcbiAgICB9XG4gICAgLy8gZS5nLiBgc2VsZWN0b3I6ICdzb21lLWRpcidgXG4gICAgaWYgKG1ldGEuc2VsZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3NlbGVjdG9yJywgbGl0ZXJhbChtZXRhLnNlbGVjdG9yKSk7XG4gICAgfVxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdpbnB1dHMnLCBjb25kaXRpb25hbGx5Q3JlYXRlTWFwT2JqZWN0TGl0ZXJhbChtZXRhLmlucHV0cywgdHJ1ZSkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdvdXRwdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5vdXRwdXRzKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2hvc3QnLCBjb21waWxlSG9zdE1ldGFkYXRhKG1ldGEuaG9zdCkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdwcm92aWRlcnMnLCBtZXRhLnByb3ZpZGVycyk7XG4gICAgaWYgKG1ldGEucXVlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdxdWVyaWVzJywgbGl0ZXJhbEFycihtZXRhLnF1ZXJpZXMubWFwKGNvbXBpbGVRdWVyeSkpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEudmlld1F1ZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgndmlld1F1ZXJpZXMnLCBsaXRlcmFsQXJyKG1ldGEudmlld1F1ZXJpZXMubWFwKGNvbXBpbGVRdWVyeSkpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZXhwb3J0QXMgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2V4cG9ydEFzJywgYXNMaXRlcmFsKG1ldGEuZXhwb3J0QXMpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEudXNlc0luaGVyaXRhbmNlKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd1c2VzSW5oZXJpdGFuY2UnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEubGlmZWN5Y2xlLnVzZXNPbkNoYW5nZXMpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3VzZXNPbkNoYW5nZXMnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nSW1wb3J0JywgaW1wb3J0RXhwcihJZGVudGlmaWVycy5jb3JlKSk7XG4gICAgcmV0dXJuIGRlZmluaXRpb25NYXA7XG59XG4vKipcbiAqIENvbXBpbGVzIHRoZSBtZXRhZGF0YSBvZiBhIHNpbmdsZSBxdWVyeSBpbnRvIGl0cyBwYXJ0aWFsIGRlY2xhcmF0aW9uIGZvcm0gYXMgZGVjbGFyZWRcbiAqIGJ5IGBSM0RlY2xhcmVRdWVyeU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgY29uc3QgbWV0YSA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgbWV0YS5zZXQoJ3Byb3BlcnR5TmFtZScsIGxpdGVyYWwocXVlcnkucHJvcGVydHlOYW1lKSk7XG4gICAgaWYgKHF1ZXJ5LmZpcnN0KSB7XG4gICAgICAgIG1ldGEuc2V0KCdmaXJzdCcsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBtZXRhLnNldCgncHJlZGljYXRlJywgQXJyYXkuaXNBcnJheShxdWVyeS5wcmVkaWNhdGUpID8gYXNMaXRlcmFsKHF1ZXJ5LnByZWRpY2F0ZSkgOlxuICAgICAgICBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24ocXVlcnkucHJlZGljYXRlKSk7XG4gICAgaWYgKCFxdWVyeS5lbWl0RGlzdGluY3RDaGFuZ2VzT25seSkge1xuICAgICAgICAvLyBgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlgIGlzIHNwZWNpYWwgYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gYmUgYHRydWVgLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgZXhwbGljaXRseSBlbWl0IHRoZSBmaWVsZCwgYW5kIGV4cGxpY2l0bHkgcGxhY2UgaXQgb25seSB3aGVuIGl0J3MgYGZhbHNlYC5cbiAgICAgICAgbWV0YS5zZXQoJ2VtaXREaXN0aW5jdENoYW5nZXNPbmx5JywgbGl0ZXJhbChmYWxzZSkpO1xuICAgIH1cbiAgICBpZiAocXVlcnkuZGVzY2VuZGFudHMpIHtcbiAgICAgICAgbWV0YS5zZXQoJ2Rlc2NlbmRhbnRzJywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIG1ldGEuc2V0KCdyZWFkJywgcXVlcnkucmVhZCk7XG4gICAgaWYgKHF1ZXJ5LnN0YXRpYykge1xuICAgICAgICBtZXRhLnNldCgnc3RhdGljJywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRhLnRvTGl0ZXJhbE1hcCgpO1xufVxuLyoqXG4gKiBDb21waWxlcyB0aGUgaG9zdCBtZXRhZGF0YSBpbnRvIGl0cyBwYXJ0aWFsIGRlY2xhcmF0aW9uIGZvcm0gYXMgZGVjbGFyZWRcbiAqIGluIGBSM0RlY2xhcmVEaXJlY3RpdmVNZXRhZGF0YVsnaG9zdCddYFxuICovXG5mdW5jdGlvbiBjb21waWxlSG9zdE1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBob3N0TWV0YWRhdGEgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGhvc3RNZXRhZGF0YS5zZXQoJ2F0dHJpYnV0ZXMnLCB0b09wdGlvbmFsTGl0ZXJhbE1hcChtZXRhLmF0dHJpYnV0ZXMsIGV4cHJlc3Npb24gPT4gZXhwcmVzc2lvbikpO1xuICAgIGhvc3RNZXRhZGF0YS5zZXQoJ2xpc3RlbmVycycsIHRvT3B0aW9uYWxMaXRlcmFsTWFwKG1ldGEubGlzdGVuZXJzLCBsaXRlcmFsKSk7XG4gICAgaG9zdE1ldGFkYXRhLnNldCgncHJvcGVydGllcycsIHRvT3B0aW9uYWxMaXRlcmFsTWFwKG1ldGEucHJvcGVydGllcywgbGl0ZXJhbCkpO1xuICAgIGlmIChtZXRhLnNwZWNpYWxBdHRyaWJ1dGVzLnN0eWxlQXR0cikge1xuICAgICAgICBob3N0TWV0YWRhdGEuc2V0KCdzdHlsZUF0dHJpYnV0ZScsIGxpdGVyYWwobWV0YS5zcGVjaWFsQXR0cmlidXRlcy5zdHlsZUF0dHIpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuc3BlY2lhbEF0dHJpYnV0ZXMuY2xhc3NBdHRyKSB7XG4gICAgICAgIGhvc3RNZXRhZGF0YS5zZXQoJ2NsYXNzQXR0cmlidXRlJywgbGl0ZXJhbChtZXRhLnNwZWNpYWxBdHRyaWJ1dGVzLmNsYXNzQXR0cikpO1xuICAgIH1cbiAgICBpZiAoaG9zdE1ldGFkYXRhLnZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBob3N0TWV0YWRhdGEudG9MaXRlcmFsTWFwKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb21waWxlIGEgY29tcG9uZW50IGRlY2xhcmF0aW9uIGRlZmluZWQgYnkgdGhlIGBSM0NvbXBvbmVudE1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVDb21wb25lbnRGcm9tTWV0YWRhdGEobWV0YSwgdGVtcGxhdGUsIGFkZGl0aW9uYWxUZW1wbGF0ZUluZm8pIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlQ29tcG9uZW50RGVmaW5pdGlvbk1hcChtZXRhLCB0ZW1wbGF0ZSwgYWRkaXRpb25hbFRlbXBsYXRlSW5mbyk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVjbGFyZUNvbXBvbmVudCkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSk7XG4gICAgY29uc3QgdHlwZSA9IGNyZWF0ZUNvbXBvbmVudFR5cGUobWV0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50czogW10gfTtcbn1cbi8qKlxuICogR2F0aGVycyB0aGUgZGVjbGFyYXRpb24gZmllbGRzIGZvciBhIGNvbXBvbmVudCBpbnRvIGEgYERlZmluaXRpb25NYXBgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnREZWZpbml0aW9uTWFwKG1ldGEsIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8pIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlRGlyZWN0aXZlRGVmaW5pdGlvbk1hcChtZXRhKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndGVtcGxhdGUnLCBnZXRUZW1wbGF0ZUV4cHJlc3Npb24odGVtcGxhdGUsIHRlbXBsYXRlSW5mbykpO1xuICAgIGlmICh0ZW1wbGF0ZUluZm8uaXNJbmxpbmUpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2lzSW5saW5lJywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdzdHlsZXMnLCB0b09wdGlvbmFsTGl0ZXJhbEFycmF5KG1ldGEuc3R5bGVzLCBsaXRlcmFsKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlcGVuZGVuY2llcycsIGNvbXBpbGVVc2VkRGVwZW5kZW5jaWVzTWV0YWRhdGEobWV0YSkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2aWV3UHJvdmlkZXJzJywgbWV0YS52aWV3UHJvdmlkZXJzKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnYW5pbWF0aW9ucycsIG1ldGEuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG1ldGEuY2hhbmdlRGV0ZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2NoYW5nZURldGVjdGlvbicsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpXG4gICAgICAgICAgICAucHJvcChleHBvcnRzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5W21ldGEuY2hhbmdlRGV0ZWN0aW9uXSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5lbmNhcHN1bGF0aW9uICE9PSBleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdlbmNhcHN1bGF0aW9uJywgaW1wb3J0RXhwcihJZGVudGlmaWVycy5WaWV3RW5jYXBzdWxhdGlvbikucHJvcChleHBvcnRzLlZpZXdFbmNhcHN1bGF0aW9uW21ldGEuZW5jYXBzdWxhdGlvbl0pKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaW50ZXJwb2xhdGlvbiAhPT0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRykge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaW50ZXJwb2xhdGlvbicsIGxpdGVyYWxBcnIoW2xpdGVyYWwobWV0YS5pbnRlcnBvbGF0aW9uLnN0YXJ0KSwgbGl0ZXJhbChtZXRhLmludGVycG9sYXRpb24uZW5kKV0pKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlLnByZXNlcnZlV2hpdGVzcGFjZXMgPT09IHRydWUpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ByZXNlcnZlV2hpdGVzcGFjZXMnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb25NYXA7XG59XG5mdW5jdGlvbiBnZXRUZW1wbGF0ZUV4cHJlc3Npb24odGVtcGxhdGUsIHRlbXBsYXRlSW5mbykge1xuICAgIC8vIElmIHRoZSB0ZW1wbGF0ZSBoYXMgYmVlbiBkZWZpbmVkIHVzaW5nIGEgZGlyZWN0IGxpdGVyYWwsIHdlIHVzZSB0aGF0IGV4cHJlc3Npb24gZGlyZWN0bHlcbiAgICAvLyB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLiBUaGlzIGlzIGVuc3VyZXMgcHJvcGVyIHNvdXJjZSBtYXBwaW5nIGZyb20gdGhlIHBhcnRpYWxseVxuICAgIC8vIGNvbXBpbGVkIGNvZGUgdG8gdGhlIHNvdXJjZSBmaWxlIGRlY2xhcmluZyB0aGUgdGVtcGxhdGUuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGNhcHR1cmVcbiAgICAvLyB0ZW1wbGF0ZSBsaXRlcmFscyByZWZlcmVuY2VkIGluZGlyZWN0bHkgdGhyb3VnaCBhbiBpZGVudGlmaWVyLlxuICAgIGlmICh0ZW1wbGF0ZUluZm8uaW5saW5lVGVtcGxhdGVMaXRlcmFsRXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGVJbmZvLmlubGluZVRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb247XG4gICAgfVxuICAgIC8vIElmIHRoZSB0ZW1wbGF0ZSBpcyBkZWZpbmVkIGlubGluZSBidXQgbm90IHRocm91Z2ggYSBsaXRlcmFsLCB0aGUgdGVtcGxhdGUgaGFzIGJlZW4gcmVzb2x2ZWRcbiAgICAvLyB0aHJvdWdoIHN0YXRpYyBpbnRlcnByZXRhdGlvbi4gV2UgY3JlYXRlIGEgbGl0ZXJhbCBidXQgY2Fubm90IHByb3ZpZGUgYW55IHNvdXJjZSBzcGFuLiBOb3RlXG4gICAgLy8gdGhhdCB3ZSBjYW5ub3QgdXNlIHRoZSBleHByZXNzaW9uIGRlZmluaW5nIHRoZSB0ZW1wbGF0ZSBiZWNhdXNlIHRoZSBsaW5rZXIgZXhwZWN0cyB0aGUgdGVtcGxhdGVcbiAgICAvLyB0byBiZSBkZWZpbmVkIGFzIGEgbGl0ZXJhbCBpbiB0aGUgZGVjbGFyYXRpb24uXG4gICAgaWYgKHRlbXBsYXRlSW5mby5pc0lubGluZSkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbCh0ZW1wbGF0ZUluZm8uY29udGVudCwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIC8vIFRoZSB0ZW1wbGF0ZSBpcyBleHRlcm5hbCBzbyB3ZSBtdXN0IHN5bnRoZXNpemUgYW4gZXhwcmVzc2lvbiBub2RlIHdpdGhcbiAgICAvLyB0aGUgYXBwcm9wcmlhdGUgc291cmNlLXNwYW4uXG4gICAgY29uc3QgY29udGVudHMgPSB0ZW1wbGF0ZUluZm8uY29udGVudDtcbiAgICBjb25zdCBmaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZShjb250ZW50cywgdGVtcGxhdGVJbmZvLnNvdXJjZVVybCk7XG4gICAgY29uc3Qgc3RhcnQgPSBuZXcgUGFyc2VMb2NhdGlvbihmaWxlLCAwLCAwLCAwKTtcbiAgICBjb25zdCBlbmQgPSBjb21wdXRlRW5kTG9jYXRpb24oZmlsZSwgY29udGVudHMpO1xuICAgIGNvbnN0IHNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBsaXRlcmFsKGNvbnRlbnRzLCBudWxsLCBzcGFuKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFbmRMb2NhdGlvbihmaWxlLCBjb250ZW50cykge1xuICAgIGNvbnN0IGxlbmd0aCA9IGNvbnRlbnRzLmxlbmd0aDtcbiAgICBsZXQgbGluZVN0YXJ0ID0gMDtcbiAgICBsZXQgbGFzdExpbmVTdGFydCA9IDA7XG4gICAgbGV0IGxpbmUgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgbGluZVN0YXJ0ID0gY29udGVudHMuaW5kZXhPZignXFxuJywgbGFzdExpbmVTdGFydCk7XG4gICAgICAgIGlmIChsaW5lU3RhcnQgIT09IC0xKSB7XG4gICAgICAgICAgICBsYXN0TGluZVN0YXJ0ID0gbGluZVN0YXJ0ICsgMTtcbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGxpbmVTdGFydCAhPT0gLTEpO1xuICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbihmaWxlLCBsZW5ndGgsIGxpbmUsIGxlbmd0aCAtIGxhc3RMaW5lU3RhcnQpO1xufVxuZnVuY3Rpb24gY29tcGlsZVVzZWREZXBlbmRlbmNpZXNNZXRhZGF0YShtZXRhKSB7XG4gICAgY29uc3Qgd3JhcFR5cGUgPSBtZXRhLmRlY2xhcmF0aW9uTGlzdEVtaXRNb2RlICE9PSAwIC8qIERlY2xhcmF0aW9uTGlzdEVtaXRNb2RlLkRpcmVjdCAqLyA/XG4gICAgICAgIGdlbmVyYXRlRm9yd2FyZFJlZiA6XG4gICAgICAgIChleHByKSA9PiBleHByO1xuICAgIHJldHVybiB0b09wdGlvbmFsTGl0ZXJhbEFycmF5KG1ldGEuZGVjbGFyYXRpb25zLCBkZWNsID0+IHtcbiAgICAgICAgc3dpdGNoIChkZWNsLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5SM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmQuRGlyZWN0aXZlOlxuICAgICAgICAgICAgICAgIGNvbnN0IGRpck1ldGEgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgICAgICAgICAgICAgIGRpck1ldGEuc2V0KCdraW5kJywgbGl0ZXJhbChkZWNsLmlzQ29tcG9uZW50ID8gJ2NvbXBvbmVudCcgOiAnZGlyZWN0aXZlJykpO1xuICAgICAgICAgICAgICAgIGRpck1ldGEuc2V0KCd0eXBlJywgd3JhcFR5cGUoZGVjbC50eXBlKSk7XG4gICAgICAgICAgICAgICAgZGlyTWV0YS5zZXQoJ3NlbGVjdG9yJywgbGl0ZXJhbChkZWNsLnNlbGVjdG9yKSk7XG4gICAgICAgICAgICAgICAgZGlyTWV0YS5zZXQoJ2lucHV0cycsIHRvT3B0aW9uYWxMaXRlcmFsQXJyYXkoZGVjbC5pbnB1dHMsIGxpdGVyYWwpKTtcbiAgICAgICAgICAgICAgICBkaXJNZXRhLnNldCgnb3V0cHV0cycsIHRvT3B0aW9uYWxMaXRlcmFsQXJyYXkoZGVjbC5vdXRwdXRzLCBsaXRlcmFsKSk7XG4gICAgICAgICAgICAgICAgZGlyTWV0YS5zZXQoJ2V4cG9ydEFzJywgdG9PcHRpb25hbExpdGVyYWxBcnJheShkZWNsLmV4cG9ydEFzLCBsaXRlcmFsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpck1ldGEudG9MaXRlcmFsTWFwKCk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuUjNUZW1wbGF0ZURlcGVuZGVuY3lLaW5kLlBpcGU6XG4gICAgICAgICAgICAgICAgY29uc3QgcGlwZU1ldGEgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgICAgICAgICAgICAgIHBpcGVNZXRhLnNldCgna2luZCcsIGxpdGVyYWwoJ3BpcGUnKSk7XG4gICAgICAgICAgICAgICAgcGlwZU1ldGEuc2V0KCd0eXBlJywgd3JhcFR5cGUoZGVjbC50eXBlKSk7XG4gICAgICAgICAgICAgICAgcGlwZU1ldGEuc2V0KCduYW1lJywgbGl0ZXJhbChkZWNsLm5hbWUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlwZU1ldGEudG9MaXRlcmFsTWFwKCk7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuUjNUZW1wbGF0ZURlcGVuZGVuY3lLaW5kLk5nTW9kdWxlOlxuICAgICAgICAgICAgICAgIGNvbnN0IG5nTW9kdWxlTWV0YSA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgICAgICAgICAgICAgbmdNb2R1bGVNZXRhLnNldCgna2luZCcsIGxpdGVyYWwoJ25nbW9kdWxlJykpO1xuICAgICAgICAgICAgICAgIG5nTW9kdWxlTWV0YS5zZXQoJ3R5cGUnLCB3cmFwVHlwZShkZWNsLnR5cGUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmdNb2R1bGVNZXRhLnRvTGl0ZXJhbE1hcCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBFdmVyeSB0aW1lIHdlIG1ha2UgYSBicmVha2luZyBjaGFuZ2UgdG8gdGhlIGRlY2xhcmF0aW9uIGludGVyZmFjZSBvciBwYXJ0aWFsLWxpbmtlciBiZWhhdmlvciwgd2VcbiAqIG11c3QgdXBkYXRlIHRoaXMgY29uc3RhbnQgdG8gcHJldmVudCBvbGQgcGFydGlhbC1saW5rZXJzIGZyb20gaW5jb3JyZWN0bHkgcHJvY2Vzc2luZyB0aGVcbiAqIGRlY2xhcmF0aW9uLlxuICpcbiAqIERvIG5vdCBpbmNsdWRlIGFueSBwcmVyZWxlYXNlIGluIHRoZXNlIHZlcnNpb25zIGFzIHRoZXkgYXJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTiQ0ID0gJzEyLjAuMCc7XG5mdW5jdGlvbiBjb21waWxlRGVjbGFyZUZhY3RvcnlGdW5jdGlvbihtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ21pblZlcnNpb24nLCBsaXRlcmFsKE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTiQ0KSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZlcnNpb24nLCBsaXRlcmFsKCcxNC4wLjAnKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nSW1wb3J0JywgaW1wb3J0RXhwcihJZGVudGlmaWVycy5jb3JlKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3R5cGUnLCBtZXRhLmludGVybmFsVHlwZSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlcHMnLCBjb21waWxlRGVwZW5kZW5jaWVzKG1ldGEuZGVwcykpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0YXJnZXQnLCBpbXBvcnRFeHByKElkZW50aWZpZXJzLkZhY3RvcnlUYXJnZXQpLnByb3AoZXhwb3J0cy5GYWN0b3J5VGFyZ2V0W21ldGEudGFyZ2V0XSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4cHJlc3Npb246IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVjbGFyZUZhY3RvcnkpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pLFxuICAgICAgICBzdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgdHlwZTogY3JlYXRlRmFjdG9yeVR5cGUobWV0YSksXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDMgPSAnMTIuMC4wJztcbi8qKlxuICogQ29tcGlsZSBhIEluamVjdGFibGUgZGVjbGFyYXRpb24gZGVmaW5lZCBieSB0aGUgYFIzSW5qZWN0YWJsZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVJbmplY3RhYmxlRnJvbU1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlSW5qZWN0YWJsZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVjbGFyZUluamVjdGFibGUpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVJbmplY3RhYmxlVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuLyoqXG4gKiBHYXRoZXJzIHRoZSBkZWNsYXJhdGlvbiBmaWVsZHMgZm9yIGEgSW5qZWN0YWJsZSBpbnRvIGEgYERlZmluaXRpb25NYXBgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmplY3RhYmxlRGVmaW5pdGlvbk1hcChtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ21pblZlcnNpb24nLCBsaXRlcmFsKE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTiQzKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZlcnNpb24nLCBsaXRlcmFsKCcxNC4wLjAnKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nSW1wb3J0JywgaW1wb3J0RXhwcihJZGVudGlmaWVycy5jb3JlKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3R5cGUnLCBtZXRhLmludGVybmFsVHlwZSk7XG4gICAgLy8gT25seSBnZW5lcmF0ZSBwcm92aWRlZEluIHByb3BlcnR5IGlmIGl0IGhhcyBhIG5vbi1udWxsIHZhbHVlXG4gICAgaWYgKG1ldGEucHJvdmlkZWRJbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVkSW4gPSBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24obWV0YS5wcm92aWRlZEluKTtcbiAgICAgICAgaWYgKHByb3ZpZGVkSW4udmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdwcm92aWRlZEluJywgcHJvdmlkZWRJbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1ldGEudXNlQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgndXNlQ2xhc3MnLCBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24obWV0YS51c2VDbGFzcykpO1xuICAgIH1cbiAgICBpZiAobWV0YS51c2VFeGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd1c2VFeGlzdGluZycsIGNvbnZlcnRGcm9tTWF5YmVGb3J3YXJkUmVmRXhwcmVzc2lvbihtZXRhLnVzZUV4aXN0aW5nKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnVzZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3VzZVZhbHVlJywgY29udmVydEZyb21NYXliZUZvcndhcmRSZWZFeHByZXNzaW9uKG1ldGEudXNlVmFsdWUpKTtcbiAgICB9XG4gICAgLy8gRmFjdG9yaWVzIGRvIG5vdCBjb250YWluIGBGb3J3YXJkUmVmYHMgc2luY2UgYW55IHR5cGVzIGFyZSBhbHJlYWR5IHdyYXBwZWQgaW4gYSBmdW5jdGlvbiBjYWxsXG4gICAgLy8gc28gdGhlIHR5cGVzIHdpbGwgbm90IGJlIGVhZ2VybHkgZXZhbHVhdGVkLiBUaGVyZWZvcmUgd2UgZG8gbm90IG5lZWQgdG8gcHJvY2VzcyB0aGlzIGV4cHJlc3Npb25cbiAgICAvLyB3aXRoIGBjb252ZXJ0RnJvbVByb3ZpZGVyRXhwcmVzc2lvbigpYC5cbiAgICBpZiAobWV0YS51c2VGYWN0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3VzZUZhY3RvcnknLCBtZXRhLnVzZUZhY3RvcnkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5kZXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlcHMnLCBsaXRlcmFsQXJyKG1ldGEuZGVwcy5tYXAoY29tcGlsZURlcGVuZGVuY3kpKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uTWFwO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogRXZlcnkgdGltZSB3ZSBtYWtlIGEgYnJlYWtpbmcgY2hhbmdlIHRvIHRoZSBkZWNsYXJhdGlvbiBpbnRlcmZhY2Ugb3IgcGFydGlhbC1saW5rZXIgYmVoYXZpb3IsIHdlXG4gKiBtdXN0IHVwZGF0ZSB0aGlzIGNvbnN0YW50IHRvIHByZXZlbnQgb2xkIHBhcnRpYWwtbGlua2VycyBmcm9tIGluY29ycmVjdGx5IHByb2Nlc3NpbmcgdGhlXG4gKiBkZWNsYXJhdGlvbi5cbiAqXG4gKiBEbyBub3QgaW5jbHVkZSBhbnkgcHJlcmVsZWFzZSBpbiB0aGVzZSB2ZXJzaW9ucyBhcyB0aGV5IGFyZSBpZ25vcmVkLlxuICovXG5jb25zdCBNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kMiA9ICcxMi4wLjAnO1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVJbmplY3RvckZyb21NZXRhZGF0YShtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IGNyZWF0ZUluamVjdG9yRGVmaW5pdGlvbk1hcChtZXRhKTtcbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5kZWNsYXJlSW5qZWN0b3IpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVJbmplY3RvclR5cGUobWV0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50czogW10gfTtcbn1cbi8qKlxuICogR2F0aGVycyB0aGUgZGVjbGFyYXRpb24gZmllbGRzIGZvciBhbiBJbmplY3RvciBpbnRvIGEgYERlZmluaXRpb25NYXBgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmplY3RvckRlZmluaXRpb25NYXAobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdtaW5WZXJzaW9uJywgbGl0ZXJhbChNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kMikpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2ZXJzaW9uJywgbGl0ZXJhbCgnMTQuMC4wJykpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCduZ0ltcG9ydCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuY29yZSkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdwcm92aWRlcnMnLCBtZXRhLnByb3ZpZGVycyk7XG4gICAgaWYgKG1ldGEuaW1wb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdpbXBvcnRzJywgbGl0ZXJhbEFycihtZXRhLmltcG9ydHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb25NYXA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBFdmVyeSB0aW1lIHdlIG1ha2UgYSBicmVha2luZyBjaGFuZ2UgdG8gdGhlIGRlY2xhcmF0aW9uIGludGVyZmFjZSBvciBwYXJ0aWFsLWxpbmtlciBiZWhhdmlvciwgd2VcbiAqIG11c3QgdXBkYXRlIHRoaXMgY29uc3RhbnQgdG8gcHJldmVudCBvbGQgcGFydGlhbC1saW5rZXJzIGZyb20gaW5jb3JyZWN0bHkgcHJvY2Vzc2luZyB0aGVcbiAqIGRlY2xhcmF0aW9uLlxuICpcbiAqIERvIG5vdCBpbmNsdWRlIGFueSBwcmVyZWxlYXNlIGluIHRoZXNlIHZlcnNpb25zIGFzIHRoZXkgYXJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTiQxID0gJzE0LjAuMCc7XG5mdW5jdGlvbiBjb21waWxlRGVjbGFyZU5nTW9kdWxlRnJvbU1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlTmdNb2R1bGVEZWZpbml0aW9uTWFwKG1ldGEpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlY2xhcmVOZ01vZHVsZSkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSk7XG4gICAgY29uc3QgdHlwZSA9IGNyZWF0ZU5nTW9kdWxlVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuLyoqXG4gKiBHYXRoZXJzIHRoZSBkZWNsYXJhdGlvbiBmaWVsZHMgZm9yIGFuIE5nTW9kdWxlIGludG8gYSBgRGVmaW5pdGlvbk1hcGAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5nTW9kdWxlRGVmaW5pdGlvbk1hcChtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ21pblZlcnNpb24nLCBsaXRlcmFsKE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTiQxKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZlcnNpb24nLCBsaXRlcmFsKCcxNC4wLjAnKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nSW1wb3J0JywgaW1wb3J0RXhwcihJZGVudGlmaWVycy5jb3JlKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3R5cGUnLCBtZXRhLmludGVybmFsVHlwZSk7XG4gICAgLy8gV2Ugb25seSBnZW5lcmF0ZSB0aGUga2V5cyBpbiB0aGUgbWV0YWRhdGEgaWYgdGhlIGFycmF5cyBjb250YWluIHZhbHVlcy5cbiAgICAvLyBXZSBtdXN0IHdyYXAgdGhlIGFycmF5cyBpbnNpZGUgYSBmdW5jdGlvbiBpZiBhbnkgb2YgdGhlIHZhbHVlcyBhcmUgYSBmb3J3YXJkIHJlZmVyZW5jZSB0byBhXG4gICAgLy8gbm90LXlldC1kZWNsYXJlZCBjbGFzcy4gVGhpcyBpcyB0byBzdXBwb3J0IEpJVCBleGVjdXRpb24gb2YgdGhlIGDJtcm1bmdEZWNsYXJlTmdNb2R1bGUoKWAgY2FsbC5cbiAgICAvLyBJbiB0aGUgbGlua2VyIHRoZXNlIHdyYXBwZXJzIGFyZSBzdHJpcHBlZCBhbmQgdGhlbiByZWFwcGxpZWQgZm9yIHRoZSBgybXJtWRlZmluZU5nTW9kdWxlKClgIGNhbGwuXG4gICAgaWYgKG1ldGEuYm9vdHN0cmFwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2Jvb3RzdHJhcCcsIHJlZnNUb0FycmF5KG1ldGEuYm9vdHN0cmFwLCBtZXRhLmNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmRlY2xhcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZWNsYXJhdGlvbnMnLCByZWZzVG9BcnJheShtZXRhLmRlY2xhcmF0aW9ucywgbWV0YS5jb250YWluc0ZvcndhcmREZWNscykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5pbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2ltcG9ydHMnLCByZWZzVG9BcnJheShtZXRhLmltcG9ydHMsIG1ldGEuY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdleHBvcnRzJywgcmVmc1RvQXJyYXkobWV0YS5leHBvcnRzLCBtZXRhLmNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnNjaGVtYXMgIT09IG51bGwgJiYgbWV0YS5zY2hlbWFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3NjaGVtYXMnLCBsaXRlcmFsQXJyKG1ldGEuc2NoZW1hcy5tYXAocmVmID0+IHJlZi52YWx1ZSkpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaWQgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2lkJywgbWV0YS5pZCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uTWFwO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogRXZlcnkgdGltZSB3ZSBtYWtlIGEgYnJlYWtpbmcgY2hhbmdlIHRvIHRoZSBkZWNsYXJhdGlvbiBpbnRlcmZhY2Ugb3IgcGFydGlhbC1saW5rZXIgYmVoYXZpb3IsIHdlXG4gKiBtdXN0IHVwZGF0ZSB0aGlzIGNvbnN0YW50IHRvIHByZXZlbnQgb2xkIHBhcnRpYWwtbGlua2VycyBmcm9tIGluY29ycmVjdGx5IHByb2Nlc3NpbmcgdGhlXG4gKiBkZWNsYXJhdGlvbi5cbiAqXG4gKiBEbyBub3QgaW5jbHVkZSBhbnkgcHJlcmVsZWFzZSBpbiB0aGVzZSB2ZXJzaW9ucyBhcyB0aGV5IGFyZSBpZ25vcmVkLlxuICovXG5jb25zdCBNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04gPSAnMTQuMC4wJztcbi8qKlxuICogQ29tcGlsZSBhIFBpcGUgZGVjbGFyYXRpb24gZGVmaW5lZCBieSB0aGUgYFIzUGlwZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVQaXBlRnJvbU1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlUGlwZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVjbGFyZVBpcGUpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVQaXBlVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuLyoqXG4gKiBHYXRoZXJzIHRoZSBkZWNsYXJhdGlvbiBmaWVsZHMgZm9yIGEgUGlwZSBpbnRvIGEgYERlZmluaXRpb25NYXBgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQaXBlRGVmaW5pdGlvbk1hcChtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ21pblZlcnNpb24nLCBsaXRlcmFsKE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTikpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2ZXJzaW9uJywgbGl0ZXJhbCgnMTQuMC4wJykpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCduZ0ltcG9ydCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuY29yZSkpO1xuICAgIC8vIGUuZy4gYHR5cGU6IE15UGlwZWBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG1ldGEuaW50ZXJuYWxUeXBlKTtcbiAgICBpZiAobWV0YS5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2lzU3RhbmRhbG9uZScsIGxpdGVyYWwobWV0YS5pc1N0YW5kYWxvbmUpKTtcbiAgICB9XG4gICAgLy8gZS5nLiBgbmFtZTogXCJteVBpcGVcImBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbmFtZScsIGxpdGVyYWwobWV0YS5waXBlTmFtZSkpO1xuICAgIGlmIChtZXRhLnB1cmUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGUuZy4gYHB1cmU6IGZhbHNlYFxuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgncHVyZScsIGxpdGVyYWwobWV0YS5wdXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uTWFwO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIFRoaXMgZmlsZSBvbmx5IHJlZXhwb3J0cyBjb250ZW50IG9mIHRoZSBgc3JjYCBmb2xkZXIuIEtlZXAgaXQgdGhhdCB3YXkuXG4vLyBUaGlzIGZ1bmN0aW9uIGNhbGwgaGFzIGEgZ2xvYmFsIHNpZGUgZWZmZWN0cyBhbmQgcHVibGlzaGVzIHRoZSBjb21waWxlciBpbnRvIGdsb2JhbCBuYW1lc3BhY2UgZm9yXG4vLyB0aGUgbGF0ZSBiaW5kaW5nIG9mIHRoZSBDb21waWxlciB0byB0aGUgQGFuZ3VsYXIvY29yZSBmb3Igaml0IGNvbXBpbGF0aW9uLlxucHVibGlzaEZhY2FkZShfZ2xvYmFsKTtcblxuZXhwb3J0cy5BU1QgPSBBU1Q7XG5leHBvcnRzLkFTVFdpdGhOYW1lID0gQVNUV2l0aE5hbWU7XG5leHBvcnRzLkFTVFdpdGhTb3VyY2UgPSBBU1RXaXRoU291cmNlO1xuZXhwb3J0cy5BYnNvbHV0ZVNvdXJjZVNwYW4gPSBBYnNvbHV0ZVNvdXJjZVNwYW47XG5leHBvcnRzLkFycmF5VHlwZSA9IEFycmF5VHlwZTtcbmV4cG9ydHMuQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIgPSBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lcjtcbmV4cG9ydHMuQXN0VHJhbnNmb3JtZXIgPSBBc3RUcmFuc2Zvcm1lcjtcbmV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlO1xuZXhwb3J0cy5CaW5hcnkgPSBCaW5hcnk7XG5leHBvcnRzLkJpbmFyeU9wZXJhdG9yRXhwciA9IEJpbmFyeU9wZXJhdG9yRXhwcjtcbmV4cG9ydHMuQmluZGluZ1BpcGUgPSBCaW5kaW5nUGlwZTtcbmV4cG9ydHMuQm91bmRFbGVtZW50UHJvcGVydHkgPSBCb3VuZEVsZW1lbnRQcm9wZXJ0eTtcbmV4cG9ydHMuQnVpbHRpblR5cGUgPSBCdWlsdGluVHlwZTtcbmV4cG9ydHMuQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQSA9IENVU1RPTV9FTEVNRU5UU19TQ0hFTUE7XG5leHBvcnRzLkNhbGwgPSBDYWxsO1xuZXhwb3J0cy5DaGFpbiA9IENoYWluO1xuZXhwb3J0cy5Db21tYUV4cHIgPSBDb21tYUV4cHI7XG5leHBvcnRzLkNvbW1lbnQgPSBDb21tZW50O1xuZXhwb3J0cy5Db21waWxlckNvbmZpZyA9IENvbXBpbGVyQ29uZmlnO1xuZXhwb3J0cy5Db25kaXRpb25hbCA9IENvbmRpdGlvbmFsO1xuZXhwb3J0cy5Db25kaXRpb25hbEV4cHIgPSBDb25kaXRpb25hbEV4cHI7XG5leHBvcnRzLkNvbnN0YW50UG9vbCA9IENvbnN0YW50UG9vbDtcbmV4cG9ydHMuQ3NzU2VsZWN0b3IgPSBDc3NTZWxlY3RvcjtcbmV4cG9ydHMuREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7XG5leHBvcnRzLkRZTkFNSUNfVFlQRSA9IERZTkFNSUNfVFlQRTtcbmV4cG9ydHMuRGVjbGFyZUZ1bmN0aW9uU3RtdCA9IERlY2xhcmVGdW5jdGlvblN0bXQ7XG5leHBvcnRzLkRlY2xhcmVWYXJTdG10ID0gRGVjbGFyZVZhclN0bXQ7XG5leHBvcnRzLkRvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IERvbUVsZW1lbnRTY2hlbWFSZWdpc3RyeTtcbmV4cG9ydHMuRU9GID0gRU9GO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRWxlbWVudFNjaGVtYVJlZ2lzdHJ5ID0gRWxlbWVudFNjaGVtYVJlZ2lzdHJ5O1xuZXhwb3J0cy5FbWl0dGVyVmlzaXRvckNvbnRleHQgPSBFbWl0dGVyVmlzaXRvckNvbnRleHQ7XG5leHBvcnRzLkVtcHR5RXhwciA9IEVtcHR5RXhwcjtcbmV4cG9ydHMuRXhwYW5zaW9uID0gRXhwYW5zaW9uO1xuZXhwb3J0cy5FeHBhbnNpb25DYXNlID0gRXhwYW5zaW9uQ2FzZTtcbmV4cG9ydHMuRXhwcmVzc2lvbiA9IEV4cHJlc3Npb247XG5leHBvcnRzLkV4cHJlc3Npb25CaW5kaW5nID0gRXhwcmVzc2lvbkJpbmRpbmc7XG5leHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBFeHByZXNzaW9uU3RhdGVtZW50O1xuZXhwb3J0cy5FeHByZXNzaW9uVHlwZSA9IEV4cHJlc3Npb25UeXBlO1xuZXhwb3J0cy5FeHRlcm5hbEV4cHIgPSBFeHRlcm5hbEV4cHI7XG5leHBvcnRzLkV4dGVybmFsUmVmZXJlbmNlID0gRXh0ZXJuYWxSZWZlcmVuY2U7XG5leHBvcnRzLkZ1bmN0aW9uRXhwciA9IEZ1bmN0aW9uRXhwcjtcbmV4cG9ydHMuSHRtbFBhcnNlciA9IEh0bWxQYXJzZXI7XG5leHBvcnRzLkh0bWxUYWdEZWZpbml0aW9uID0gSHRtbFRhZ0RlZmluaXRpb247XG5leHBvcnRzLkkxOE5IdG1sUGFyc2VyID0gSTE4Tkh0bWxQYXJzZXI7XG5leHBvcnRzLklmU3RtdCA9IElmU3RtdDtcbmV4cG9ydHMuSW1wbGljaXRSZWNlaXZlciA9IEltcGxpY2l0UmVjZWl2ZXI7XG5leHBvcnRzLkluc3RhbnRpYXRlRXhwciA9IEluc3RhbnRpYXRlRXhwcjtcbmV4cG9ydHMuSW50ZXJwb2xhdGlvbiA9IEludGVycG9sYXRpb247XG5leHBvcnRzLkludGVycG9sYXRpb25Db25maWcgPSBJbnRlcnBvbGF0aW9uQ29uZmlnO1xuZXhwb3J0cy5JbnZva2VGdW5jdGlvbkV4cHIgPSBJbnZva2VGdW5jdGlvbkV4cHI7XG5leHBvcnRzLkpTRG9jQ29tbWVudCA9IEpTRG9jQ29tbWVudDtcbmV4cG9ydHMuSml0RXZhbHVhdG9yID0gSml0RXZhbHVhdG9yO1xuZXhwb3J0cy5LZXllZFJlYWQgPSBLZXllZFJlYWQ7XG5leHBvcnRzLktleWVkV3JpdGUgPSBLZXllZFdyaXRlO1xuZXhwb3J0cy5MZWFkaW5nQ29tbWVudCA9IExlYWRpbmdDb21tZW50O1xuZXhwb3J0cy5MZXhlciA9IExleGVyO1xuZXhwb3J0cy5MaXRlcmFsQXJyYXkgPSBMaXRlcmFsQXJyYXk7XG5leHBvcnRzLkxpdGVyYWxBcnJheUV4cHIgPSBMaXRlcmFsQXJyYXlFeHByO1xuZXhwb3J0cy5MaXRlcmFsRXhwciA9IExpdGVyYWxFeHByO1xuZXhwb3J0cy5MaXRlcmFsTWFwID0gTGl0ZXJhbE1hcDtcbmV4cG9ydHMuTGl0ZXJhbE1hcEV4cHIgPSBMaXRlcmFsTWFwRXhwcjtcbmV4cG9ydHMuTGl0ZXJhbFByaW1pdGl2ZSA9IExpdGVyYWxQcmltaXRpdmU7XG5leHBvcnRzLkxvY2FsaXplZFN0cmluZyA9IExvY2FsaXplZFN0cmluZztcbmV4cG9ydHMuTWFwVHlwZSA9IE1hcFR5cGU7XG5leHBvcnRzLk1lc3NhZ2VCdW5kbGUgPSBNZXNzYWdlQnVuZGxlO1xuZXhwb3J0cy5OT05FX1RZUEUgPSBOT05FX1RZUEU7XG5leHBvcnRzLk5PX0VSUk9SU19TQ0hFTUEgPSBOT19FUlJPUlNfU0NIRU1BO1xuZXhwb3J0cy5Ob2RlV2l0aEkxOG4gPSBOb2RlV2l0aEkxOG47XG5leHBvcnRzLk5vbk51bGxBc3NlcnQgPSBOb25OdWxsQXNzZXJ0O1xuZXhwb3J0cy5Ob3RFeHByID0gTm90RXhwcjtcbmV4cG9ydHMuUGFyc2VFcnJvciA9IFBhcnNlRXJyb3I7XG5leHBvcnRzLlBhcnNlTG9jYXRpb24gPSBQYXJzZUxvY2F0aW9uO1xuZXhwb3J0cy5QYXJzZVNvdXJjZUZpbGUgPSBQYXJzZVNvdXJjZUZpbGU7XG5leHBvcnRzLlBhcnNlU291cmNlU3BhbiA9IFBhcnNlU291cmNlU3BhbjtcbmV4cG9ydHMuUGFyc2VTcGFuID0gUGFyc2VTcGFuO1xuZXhwb3J0cy5QYXJzZVRyZWVSZXN1bHQgPSBQYXJzZVRyZWVSZXN1bHQ7XG5leHBvcnRzLlBhcnNlZEV2ZW50ID0gUGFyc2VkRXZlbnQ7XG5leHBvcnRzLlBhcnNlZFByb3BlcnR5ID0gUGFyc2VkUHJvcGVydHk7XG5leHBvcnRzLlBhcnNlZFZhcmlhYmxlID0gUGFyc2VkVmFyaWFibGU7XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlciQxO1xuZXhwb3J0cy5QYXJzZXJFcnJvciA9IFBhcnNlckVycm9yO1xuZXhwb3J0cy5QcmVmaXhOb3QgPSBQcmVmaXhOb3Q7XG5leHBvcnRzLlByb3BlcnR5UmVhZCA9IFByb3BlcnR5UmVhZDtcbmV4cG9ydHMuUHJvcGVydHlXcml0ZSA9IFByb3BlcnR5V3JpdGU7XG5leHBvcnRzLlIzQm91bmRUYXJnZXQgPSBSM0JvdW5kVGFyZ2V0O1xuZXhwb3J0cy5SM0lkZW50aWZpZXJzID0gSWRlbnRpZmllcnM7XG5leHBvcnRzLlIzVGFyZ2V0QmluZGVyID0gUjNUYXJnZXRCaW5kZXI7XG5leHBvcnRzLlJlYWRLZXlFeHByID0gUmVhZEtleUV4cHI7XG5leHBvcnRzLlJlYWRQcm9wRXhwciA9IFJlYWRQcm9wRXhwcjtcbmV4cG9ydHMuUmVhZFZhckV4cHIgPSBSZWFkVmFyRXhwcjtcbmV4cG9ydHMuUmVjdXJzaXZlQXN0VmlzaXRvciA9IFJlY3Vyc2l2ZUFzdFZpc2l0b3I7XG5leHBvcnRzLlJlY3Vyc2l2ZVZpc2l0b3IgPSBSZWN1cnNpdmVWaXNpdG9yO1xuZXhwb3J0cy5SZXNvdXJjZUxvYWRlciA9IFJlc291cmNlTG9hZGVyO1xuZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgPSBSZXR1cm5TdGF0ZW1lbnQ7XG5leHBvcnRzLlNUUklOR19UWVBFID0gU1RSSU5HX1RZUEU7XG5leHBvcnRzLlNhZmVDYWxsID0gU2FmZUNhbGw7XG5leHBvcnRzLlNhZmVLZXllZFJlYWQgPSBTYWZlS2V5ZWRSZWFkO1xuZXhwb3J0cy5TYWZlUHJvcGVydHlSZWFkID0gU2FmZVByb3BlcnR5UmVhZDtcbmV4cG9ydHMuU2VsZWN0b3JDb250ZXh0ID0gU2VsZWN0b3JDb250ZXh0O1xuZXhwb3J0cy5TZWxlY3Rvckxpc3RDb250ZXh0ID0gU2VsZWN0b3JMaXN0Q29udGV4dDtcbmV4cG9ydHMuU2VsZWN0b3JNYXRjaGVyID0gU2VsZWN0b3JNYXRjaGVyO1xuZXhwb3J0cy5TZXJpYWxpemVyID0gU2VyaWFsaXplcjtcbmV4cG9ydHMuU3BsaXRJbnRlcnBvbGF0aW9uID0gU3BsaXRJbnRlcnBvbGF0aW9uO1xuZXhwb3J0cy5TdGF0ZW1lbnQgPSBTdGF0ZW1lbnQ7XG5leHBvcnRzLlRhZ2dlZFRlbXBsYXRlRXhwciA9IFRhZ2dlZFRlbXBsYXRlRXhwcjtcbmV4cG9ydHMuVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQgPSBUZW1wbGF0ZUJpbmRpbmdQYXJzZVJlc3VsdDtcbmV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsID0gVGVtcGxhdGVMaXRlcmFsO1xuZXhwb3J0cy5UZW1wbGF0ZUxpdGVyYWxFbGVtZW50ID0gVGVtcGxhdGVMaXRlcmFsRWxlbWVudDtcbmV4cG9ydHMuVGV4dCA9IFRleHQ7XG5leHBvcnRzLlRoaXNSZWNlaXZlciA9IFRoaXNSZWNlaXZlcjtcbmV4cG9ydHMuVG1wbEFzdEJvdW5kQXR0cmlidXRlID0gQm91bmRBdHRyaWJ1dGU7XG5leHBvcnRzLlRtcGxBc3RCb3VuZEV2ZW50ID0gQm91bmRFdmVudDtcbmV4cG9ydHMuVG1wbEFzdEJvdW5kVGV4dCA9IEJvdW5kVGV4dDtcbmV4cG9ydHMuVG1wbEFzdENvbnRlbnQgPSBDb250ZW50O1xuZXhwb3J0cy5UbXBsQXN0RWxlbWVudCA9IEVsZW1lbnQkMTtcbmV4cG9ydHMuVG1wbEFzdEljdSA9IEljdSQxO1xuZXhwb3J0cy5UbXBsQXN0UmVjdXJzaXZlVmlzaXRvciA9IFJlY3Vyc2l2ZVZpc2l0b3IkMTtcbmV4cG9ydHMuVG1wbEFzdFJlZmVyZW5jZSA9IFJlZmVyZW5jZTtcbmV4cG9ydHMuVG1wbEFzdFRlbXBsYXRlID0gVGVtcGxhdGU7XG5leHBvcnRzLlRtcGxBc3RUZXh0ID0gVGV4dCQzO1xuZXhwb3J0cy5UbXBsQXN0VGV4dEF0dHJpYnV0ZSA9IFRleHRBdHRyaWJ1dGU7XG5leHBvcnRzLlRtcGxBc3RWYXJpYWJsZSA9IFZhcmlhYmxlO1xuZXhwb3J0cy5Ub2tlbiA9IFRva2VuO1xuZXhwb3J0cy5UcmVlRXJyb3IgPSBUcmVlRXJyb3I7XG5leHBvcnRzLlR5cGUgPSBUeXBlO1xuZXhwb3J0cy5UeXBlb2ZFeHByID0gVHlwZW9mRXhwcjtcbmV4cG9ydHMuVW5hcnkgPSBVbmFyeTtcbmV4cG9ydHMuVW5hcnlPcGVyYXRvckV4cHIgPSBVbmFyeU9wZXJhdG9yRXhwcjtcbmV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG5leHBvcnRzLlZhcmlhYmxlQmluZGluZyA9IFZhcmlhYmxlQmluZGluZztcbmV4cG9ydHMuVmVyc2lvbiA9IFZlcnNpb247XG5leHBvcnRzLldyYXBwZWROb2RlRXhwciA9IFdyYXBwZWROb2RlRXhwcjtcbmV4cG9ydHMuV3JpdGVLZXlFeHByID0gV3JpdGVLZXlFeHByO1xuZXhwb3J0cy5Xcml0ZVByb3BFeHByID0gV3JpdGVQcm9wRXhwcjtcbmV4cG9ydHMuV3JpdGVWYXJFeHByID0gV3JpdGVWYXJFeHByO1xuZXhwb3J0cy5YbGlmZiA9IFhsaWZmO1xuZXhwb3J0cy5YbGlmZjIgPSBYbGlmZjI7XG5leHBvcnRzLlhtYiA9IFhtYjtcbmV4cG9ydHMuWG1sUGFyc2VyID0gWG1sUGFyc2VyO1xuZXhwb3J0cy5YdGIgPSBYdGI7XG5leHBvcnRzLl9QYXJzZUFTVCA9IF9QYXJzZUFTVDtcbmV4cG9ydHMuY29tcGlsZUNsYXNzTWV0YWRhdGEgPSBjb21waWxlQ2xhc3NNZXRhZGF0YTtcbmV4cG9ydHMuY29tcGlsZUNvbXBvbmVudEZyb21NZXRhZGF0YSA9IGNvbXBpbGVDb21wb25lbnRGcm9tTWV0YWRhdGE7XG5leHBvcnRzLmNvbXBpbGVEZWNsYXJlQ2xhc3NNZXRhZGF0YSA9IGNvbXBpbGVEZWNsYXJlQ2xhc3NNZXRhZGF0YTtcbmV4cG9ydHMuY29tcGlsZURlY2xhcmVDb21wb25lbnRGcm9tTWV0YWRhdGEgPSBjb21waWxlRGVjbGFyZUNvbXBvbmVudEZyb21NZXRhZGF0YTtcbmV4cG9ydHMuY29tcGlsZURlY2xhcmVEaXJlY3RpdmVGcm9tTWV0YWRhdGEgPSBjb21waWxlRGVjbGFyZURpcmVjdGl2ZUZyb21NZXRhZGF0YTtcbmV4cG9ydHMuY29tcGlsZURlY2xhcmVGYWN0b3J5RnVuY3Rpb24gPSBjb21waWxlRGVjbGFyZUZhY3RvcnlGdW5jdGlvbjtcbmV4cG9ydHMuY29tcGlsZURlY2xhcmVJbmplY3RhYmxlRnJvbU1ldGFkYXRhID0gY29tcGlsZURlY2xhcmVJbmplY3RhYmxlRnJvbU1ldGFkYXRhO1xuZXhwb3J0cy5jb21waWxlRGVjbGFyZUluamVjdG9yRnJvbU1ldGFkYXRhID0gY29tcGlsZURlY2xhcmVJbmplY3RvckZyb21NZXRhZGF0YTtcbmV4cG9ydHMuY29tcGlsZURlY2xhcmVOZ01vZHVsZUZyb21NZXRhZGF0YSA9IGNvbXBpbGVEZWNsYXJlTmdNb2R1bGVGcm9tTWV0YWRhdGE7XG5leHBvcnRzLmNvbXBpbGVEZWNsYXJlUGlwZUZyb21NZXRhZGF0YSA9IGNvbXBpbGVEZWNsYXJlUGlwZUZyb21NZXRhZGF0YTtcbmV4cG9ydHMuY29tcGlsZURpcmVjdGl2ZUZyb21NZXRhZGF0YSA9IGNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YWRhdGE7XG5leHBvcnRzLmNvbXBpbGVGYWN0b3J5RnVuY3Rpb24gPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uO1xuZXhwb3J0cy5jb21waWxlSW5qZWN0YWJsZSA9IGNvbXBpbGVJbmplY3RhYmxlO1xuZXhwb3J0cy5jb21waWxlSW5qZWN0b3IgPSBjb21waWxlSW5qZWN0b3I7XG5leHBvcnRzLmNvbXBpbGVOZ01vZHVsZSA9IGNvbXBpbGVOZ01vZHVsZTtcbmV4cG9ydHMuY29tcGlsZVBpcGVGcm9tTWV0YWRhdGEgPSBjb21waWxlUGlwZUZyb21NZXRhZGF0YTtcbmV4cG9ydHMuY29tcHV0ZU1zZ0lkID0gY29tcHV0ZU1zZ0lkO1xuZXhwb3J0cy5jb3JlID0gY29yZTtcbmV4cG9ydHMuY3JlYXRlSW5qZWN0YWJsZVR5cGUgPSBjcmVhdGVJbmplY3RhYmxlVHlwZTtcbmV4cG9ydHMuY3JlYXRlTWF5QmVGb3J3YXJkUmVmRXhwcmVzc2lvbiA9IGNyZWF0ZU1heUJlRm9yd2FyZFJlZkV4cHJlc3Npb247XG5leHBvcnRzLmRldk9ubHlHdWFyZGVkRXhwcmVzc2lvbiA9IGRldk9ubHlHdWFyZGVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlEZWZhdWx0VmFsdWUgPSBlbWl0RGlzdGluY3RDaGFuZ2VzT25seURlZmF1bHRWYWx1ZTtcbmV4cG9ydHMuZ2V0SHRtbFRhZ0RlZmluaXRpb24gPSBnZXRIdG1sVGFnRGVmaW5pdGlvbjtcbmV4cG9ydHMuZ2V0TnNQcmVmaXggPSBnZXROc1ByZWZpeDtcbmV4cG9ydHMuZ2V0U2FmZVByb3BlcnR5QWNjZXNzU3RyaW5nID0gZ2V0U2FmZVByb3BlcnR5QWNjZXNzU3RyaW5nO1xuZXhwb3J0cy5pZGVudGlmaWVyTmFtZSA9IGlkZW50aWZpZXJOYW1lO1xuZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG5leHBvcnRzLmlzTmdDb250YWluZXIgPSBpc05nQ29udGFpbmVyO1xuZXhwb3J0cy5pc05nQ29udGVudCA9IGlzTmdDb250ZW50O1xuZXhwb3J0cy5pc05nVGVtcGxhdGUgPSBpc05nVGVtcGxhdGU7XG5leHBvcnRzLmpzRG9jQ29tbWVudCA9IGpzRG9jQ29tbWVudDtcbmV4cG9ydHMubGVhZGluZ0NvbW1lbnQgPSBsZWFkaW5nQ29tbWVudDtcbmV4cG9ydHMubGl0ZXJhbE1hcCA9IGxpdGVyYWxNYXA7XG5leHBvcnRzLm1ha2VCaW5kaW5nUGFyc2VyID0gbWFrZUJpbmRpbmdQYXJzZXI7XG5leHBvcnRzLm1lcmdlTnNBbmROYW1lID0gbWVyZ2VOc0FuZE5hbWU7XG5leHBvcnRzLm91dHB1dEFzdCA9IG91dHB1dF9hc3Q7XG5leHBvcnRzLnBhcnNlSG9zdEJpbmRpbmdzID0gcGFyc2VIb3N0QmluZGluZ3M7XG5leHBvcnRzLnBhcnNlVGVtcGxhdGUgPSBwYXJzZVRlbXBsYXRlO1xuZXhwb3J0cy5wcmVzZXJ2ZVdoaXRlc3BhY2VzRGVmYXVsdCA9IHByZXNlcnZlV2hpdGVzcGFjZXNEZWZhdWx0O1xuZXhwb3J0cy5wdWJsaXNoRmFjYWRlID0gcHVibGlzaEZhY2FkZTtcbmV4cG9ydHMucjNKaXRUeXBlU291cmNlU3BhbiA9IHIzSml0VHlwZVNvdXJjZVNwYW47XG5leHBvcnRzLnNhbml0aXplSWRlbnRpZmllciA9IHNhbml0aXplSWRlbnRpZmllcjtcbmV4cG9ydHMuc3BsaXROc05hbWUgPSBzcGxpdE5zTmFtZTtcbmV4cG9ydHMudmVyaWZ5SG9zdEJpbmRpbmdzID0gdmVyaWZ5SG9zdEJpbmRpbmdzO1xuZXhwb3J0cy52aXNpdEFsbCA9IHZpc2l0QWxsO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@angular-eslint/bundled-angular-compiler/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@angular-eslint/template-parser/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@angular-eslint/template-parser/dist/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var e=__webpack_require__(/*! @angular-eslint/bundled-angular-compiler */ \"./node_modules/@angular-eslint/bundled-angular-compiler/dist/index.js\"),t=__webpack_require__(/*! eslint-scope */ \"./node_modules/eslint-scope/lib/index.js\");function n(e){return{start:{line:e.start.line+1,column:e.start.col},end:{line:e.end.line+1,column:e.end.col}}}function r(t,r){if(\"Element$1\"!==r.type)throw new Error(\"convertElementSourceSpanToLoc is intented to be used only with elements.\");return e.getHtmlTagDefinition(r.name).isVoid&&(r=function(t,n){const{rootNodes:r}=(s||(s=new e.HtmlParser)).parse(t.getSourceCode().getText(),t.getFilename());return o(r,n.sourceSpan)}(t,r)||r),n(r.sourceSpan)}function o(t,n){for(const r of t){if(r.sourceSpan.start.line===n.start.line&&r.sourceSpan.start.offset===n.start.offset)return r;if(r instanceof e.Element){const e=o(r.children,n);if(null!==e)return e}}return null}let s=null;const a={ASTWithSource:[\"ast\"],Binary:[\"left\",\"right\"],BoundAttribute:[\"value\"],BoundEvent:[\"handler\"],BoundText:[\"value\"],Conditional:[\"condition\",\"trueExp\",\"falseExp\"],Element$1:[\"children\",\"inputs\",\"outputs\",\"attributes\"],Interpolation:[\"expressions\"],PrefixNot:[\"expression\"],Program:[\"templateNodes\"],PropertyRead:[\"receiver\"],Template:[\"templateAttrs\",\"children\",\"inputs\"],BindingPipe:[\"exp\"]};function l(e){let t=null;return\"comments\"!==e&&\"leadingComments\"!==e&&\"loc\"!==e&&\"parent\"!==e&&\"range\"!==e&&\"tokens\"!==e&&\"trailingComments\"!==e&&null!==(t=this[e])&&\"object\"==typeof t&&(\"string\"==typeof t.type||Array.isArray(t))}function i(e){return null!==e&&\"object\"==typeof e&&\"string\"==typeof e.type}function c(e){let t=0,r=0;const o=a[e.type]||function(e){return Object.keys(e).filter(l,e)}(e);for(!e.loc&&e.sourceSpan&&(e.loc=n(e.sourceSpan)),t=0;t<o.length;++t){const n=e[o[t]],s=Array.isArray(n);if(void 0!==n.type&&(n.__originalType=n.type),s||n.type||(n.type=n.constructor.name),s)for(r=0;r<n.length;++r){const e=n[r];void 0!==e.type&&(e.__originalType=e.type),e.type&&\"number\"!=typeof e.type||(e.type=e.constructor.name),i(e)&&c(e)}else i(n)&&c(n)}}class u extends Error{constructor(e,t,n,r,o){super(e),this.fileName=void 0,this.index=void 0,this.lineNumber=void 0,this.column=void 0,this.fileName=t,this.index=n,this.lineNumber=r,this.column=o,Object.defineProperty(this,\"name\",{value:new.target.name,enumerable:!1,configurable:!0})}}function p(e){return new u(e.msg,e.span.start.file.url,e.span.start.offset,e.span.start.line+1,e.span.start.col+1)}function f(o,s){var l,i;const u=e.parseTemplate(o,s.filePath,{preserveWhitespaces:!0,preserveLineEndings:!0,collectCommentNodes:!0});let f=[];Array.isArray(u.commentNodes)&&(f=u.commentNodes);const m={type:\"Program\",comments:(d=f,d.map(e=>({type:\"Block\",value:e.value,loc:n(e.sourceSpan),range:[e.sourceSpan.start.offset,e.sourceSpan.end.offset]})).sort((e,t)=>e.range[0]-t.range[0])),tokens:[],range:[0,0],loc:{start:{line:0,column:0},end:{line:0,column:0}},templateNodes:u.nodes,value:o};var d;const y=new t.ScopeManager({});new t.Scope(y,\"module\",null,m,!1),c(m);const g=function(e){let t=null;return e.templateNodes.forEach(e=>{const n=e.startSourceSpan||e.sourceSpan;t?n&&n.start.offset<t.start.offset&&(t=n):t=n}),t}(m),S=function(e){let t=null;return e.templateNodes.forEach(e=>{const n=e.endSourceSpan||e.sourceSpan;t?n&&n.end.offset>t.end.offset&&(t=n):t=n}),t}(m);if(g&&S&&(m.range=[g.start.offset,S.end.offset],m.loc={start:n(g).start,end:n(S).end}),null!=(l=s.suppressParseErrors)&&!l&&null!=(i=u.errors)&&i.length)throw p(u.errors[0]);return{ast:m,scopeManager:y,visitorKeys:a,services:{convertNodeSourceSpanToLoc:n,convertElementSourceSpanToLoc:r}}}exports.TemplateParseError=u,exports.createTemplateParseError=p,exports.parse=function(e,t){return f(e,t).ast},exports.parseForESLint=f;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXItZXNsaW50L3RlbXBsYXRlLXBhcnNlci9kaXN0L2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyLWVzbGludC90ZW1wbGF0ZS1wYXJzZXIvZGlzdC9pbmRleC5qcz8zYWFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlPXJlcXVpcmUoXCJAYW5ndWxhci1lc2xpbnQvYnVuZGxlZC1hbmd1bGFyLWNvbXBpbGVyXCIpLHQ9cmVxdWlyZShcImVzbGludC1zY29wZVwiKTtmdW5jdGlvbiBuKGUpe3JldHVybntzdGFydDp7bGluZTplLnN0YXJ0LmxpbmUrMSxjb2x1bW46ZS5zdGFydC5jb2x9LGVuZDp7bGluZTplLmVuZC5saW5lKzEsY29sdW1uOmUuZW5kLmNvbH19fWZ1bmN0aW9uIHIodCxyKXtpZihcIkVsZW1lbnQkMVwiIT09ci50eXBlKXRocm93IG5ldyBFcnJvcihcImNvbnZlcnRFbGVtZW50U291cmNlU3BhblRvTG9jIGlzIGludGVudGVkIHRvIGJlIHVzZWQgb25seSB3aXRoIGVsZW1lbnRzLlwiKTtyZXR1cm4gZS5nZXRIdG1sVGFnRGVmaW5pdGlvbihyLm5hbWUpLmlzVm9pZCYmKHI9ZnVuY3Rpb24odCxuKXtjb25zdHtyb290Tm9kZXM6cn09KHN8fChzPW5ldyBlLkh0bWxQYXJzZXIpKS5wYXJzZSh0LmdldFNvdXJjZUNvZGUoKS5nZXRUZXh0KCksdC5nZXRGaWxlbmFtZSgpKTtyZXR1cm4gbyhyLG4uc291cmNlU3Bhbil9KHQscil8fHIpLG4oci5zb3VyY2VTcGFuKX1mdW5jdGlvbiBvKHQsbil7Zm9yKGNvbnN0IHIgb2YgdCl7aWYoci5zb3VyY2VTcGFuLnN0YXJ0LmxpbmU9PT1uLnN0YXJ0LmxpbmUmJnIuc291cmNlU3Bhbi5zdGFydC5vZmZzZXQ9PT1uLnN0YXJ0Lm9mZnNldClyZXR1cm4gcjtpZihyIGluc3RhbmNlb2YgZS5FbGVtZW50KXtjb25zdCBlPW8oci5jaGlsZHJlbixuKTtpZihudWxsIT09ZSlyZXR1cm4gZX19cmV0dXJuIG51bGx9bGV0IHM9bnVsbDtjb25zdCBhPXtBU1RXaXRoU291cmNlOltcImFzdFwiXSxCaW5hcnk6W1wibGVmdFwiLFwicmlnaHRcIl0sQm91bmRBdHRyaWJ1dGU6W1widmFsdWVcIl0sQm91bmRFdmVudDpbXCJoYW5kbGVyXCJdLEJvdW5kVGV4dDpbXCJ2YWx1ZVwiXSxDb25kaXRpb25hbDpbXCJjb25kaXRpb25cIixcInRydWVFeHBcIixcImZhbHNlRXhwXCJdLEVsZW1lbnQkMTpbXCJjaGlsZHJlblwiLFwiaW5wdXRzXCIsXCJvdXRwdXRzXCIsXCJhdHRyaWJ1dGVzXCJdLEludGVycG9sYXRpb246W1wiZXhwcmVzc2lvbnNcIl0sUHJlZml4Tm90OltcImV4cHJlc3Npb25cIl0sUHJvZ3JhbTpbXCJ0ZW1wbGF0ZU5vZGVzXCJdLFByb3BlcnR5UmVhZDpbXCJyZWNlaXZlclwiXSxUZW1wbGF0ZTpbXCJ0ZW1wbGF0ZUF0dHJzXCIsXCJjaGlsZHJlblwiLFwiaW5wdXRzXCJdLEJpbmRpbmdQaXBlOltcImV4cFwiXX07ZnVuY3Rpb24gbChlKXtsZXQgdD1udWxsO3JldHVyblwiY29tbWVudHNcIiE9PWUmJlwibGVhZGluZ0NvbW1lbnRzXCIhPT1lJiZcImxvY1wiIT09ZSYmXCJwYXJlbnRcIiE9PWUmJlwicmFuZ2VcIiE9PWUmJlwidG9rZW5zXCIhPT1lJiZcInRyYWlsaW5nQ29tbWVudHNcIiE9PWUmJm51bGwhPT0odD10aGlzW2VdKSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJihcInN0cmluZ1wiPT10eXBlb2YgdC50eXBlfHxBcnJheS5pc0FycmF5KHQpKX1mdW5jdGlvbiBpKGUpe3JldHVybiBudWxsIT09ZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwic3RyaW5nXCI9PXR5cGVvZiBlLnR5cGV9ZnVuY3Rpb24gYyhlKXtsZXQgdD0wLHI9MDtjb25zdCBvPWFbZS50eXBlXXx8ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5rZXlzKGUpLmZpbHRlcihsLGUpfShlKTtmb3IoIWUubG9jJiZlLnNvdXJjZVNwYW4mJihlLmxvYz1uKGUuc291cmNlU3BhbikpLHQ9MDt0PG8ubGVuZ3RoOysrdCl7Y29uc3Qgbj1lW29bdF1dLHM9QXJyYXkuaXNBcnJheShuKTtpZih2b2lkIDAhPT1uLnR5cGUmJihuLl9fb3JpZ2luYWxUeXBlPW4udHlwZSksc3x8bi50eXBlfHwobi50eXBlPW4uY29uc3RydWN0b3IubmFtZSkscylmb3Iocj0wO3I8bi5sZW5ndGg7KytyKXtjb25zdCBlPW5bcl07dm9pZCAwIT09ZS50eXBlJiYoZS5fX29yaWdpbmFsVHlwZT1lLnR5cGUpLGUudHlwZSYmXCJudW1iZXJcIiE9dHlwZW9mIGUudHlwZXx8KGUudHlwZT1lLmNvbnN0cnVjdG9yLm5hbWUpLGkoZSkmJmMoZSl9ZWxzZSBpKG4pJiZjKG4pfX1jbGFzcyB1IGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoZSx0LG4scixvKXtzdXBlcihlKSx0aGlzLmZpbGVOYW1lPXZvaWQgMCx0aGlzLmluZGV4PXZvaWQgMCx0aGlzLmxpbmVOdW1iZXI9dm9pZCAwLHRoaXMuY29sdW1uPXZvaWQgMCx0aGlzLmZpbGVOYW1lPXQsdGhpcy5pbmRleD1uLHRoaXMubGluZU51bWJlcj1yLHRoaXMuY29sdW1uPW8sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJuYW1lXCIse3ZhbHVlOm5ldy50YXJnZXQubmFtZSxlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMH0pfX1mdW5jdGlvbiBwKGUpe3JldHVybiBuZXcgdShlLm1zZyxlLnNwYW4uc3RhcnQuZmlsZS51cmwsZS5zcGFuLnN0YXJ0Lm9mZnNldCxlLnNwYW4uc3RhcnQubGluZSsxLGUuc3Bhbi5zdGFydC5jb2wrMSl9ZnVuY3Rpb24gZihvLHMpe3ZhciBsLGk7Y29uc3QgdT1lLnBhcnNlVGVtcGxhdGUobyxzLmZpbGVQYXRoLHtwcmVzZXJ2ZVdoaXRlc3BhY2VzOiEwLHByZXNlcnZlTGluZUVuZGluZ3M6ITAsY29sbGVjdENvbW1lbnROb2RlczohMH0pO2xldCBmPVtdO0FycmF5LmlzQXJyYXkodS5jb21tZW50Tm9kZXMpJiYoZj11LmNvbW1lbnROb2Rlcyk7Y29uc3QgbT17dHlwZTpcIlByb2dyYW1cIixjb21tZW50czooZD1mLGQubWFwKGU9Pih7dHlwZTpcIkJsb2NrXCIsdmFsdWU6ZS52YWx1ZSxsb2M6bihlLnNvdXJjZVNwYW4pLHJhbmdlOltlLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0LGUuc291cmNlU3Bhbi5lbmQub2Zmc2V0XX0pKS5zb3J0KChlLHQpPT5lLnJhbmdlWzBdLXQucmFuZ2VbMF0pKSx0b2tlbnM6W10scmFuZ2U6WzAsMF0sbG9jOntzdGFydDp7bGluZTowLGNvbHVtbjowfSxlbmQ6e2xpbmU6MCxjb2x1bW46MH19LHRlbXBsYXRlTm9kZXM6dS5ub2Rlcyx2YWx1ZTpvfTt2YXIgZDtjb25zdCB5PW5ldyB0LlNjb3BlTWFuYWdlcih7fSk7bmV3IHQuU2NvcGUoeSxcIm1vZHVsZVwiLG51bGwsbSwhMSksYyhtKTtjb25zdCBnPWZ1bmN0aW9uKGUpe2xldCB0PW51bGw7cmV0dXJuIGUudGVtcGxhdGVOb2Rlcy5mb3JFYWNoKGU9Pntjb25zdCBuPWUuc3RhcnRTb3VyY2VTcGFufHxlLnNvdXJjZVNwYW47dD9uJiZuLnN0YXJ0Lm9mZnNldDx0LnN0YXJ0Lm9mZnNldCYmKHQ9bik6dD1ufSksdH0obSksUz1mdW5jdGlvbihlKXtsZXQgdD1udWxsO3JldHVybiBlLnRlbXBsYXRlTm9kZXMuZm9yRWFjaChlPT57Y29uc3Qgbj1lLmVuZFNvdXJjZVNwYW58fGUuc291cmNlU3Bhbjt0P24mJm4uZW5kLm9mZnNldD50LmVuZC5vZmZzZXQmJih0PW4pOnQ9bn0pLHR9KG0pO2lmKGcmJlMmJihtLnJhbmdlPVtnLnN0YXJ0Lm9mZnNldCxTLmVuZC5vZmZzZXRdLG0ubG9jPXtzdGFydDpuKGcpLnN0YXJ0LGVuZDpuKFMpLmVuZH0pLG51bGwhPShsPXMuc3VwcHJlc3NQYXJzZUVycm9ycykmJiFsJiZudWxsIT0oaT11LmVycm9ycykmJmkubGVuZ3RoKXRocm93IHAodS5lcnJvcnNbMF0pO3JldHVybnthc3Q6bSxzY29wZU1hbmFnZXI6eSx2aXNpdG9yS2V5czphLHNlcnZpY2VzOntjb252ZXJ0Tm9kZVNvdXJjZVNwYW5Ub0xvYzpuLGNvbnZlcnRFbGVtZW50U291cmNlU3BhblRvTG9jOnJ9fX1leHBvcnRzLlRlbXBsYXRlUGFyc2VFcnJvcj11LGV4cG9ydHMuY3JlYXRlVGVtcGxhdGVQYXJzZUVycm9yPXAsZXhwb3J0cy5wYXJzZT1mdW5jdGlvbihlLHQpe3JldHVybiBmKGUsdCkuYXN0fSxleHBvcnRzLnBhcnNlRm9yRVNMaW50PWY7XG4iXSwibWFwcGluZ3MiOiJBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@angular-eslint/template-parser/dist/index.js\n");

/***/ }),

/***/ "./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzP2Y2NTQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBjb21wYXJlIGFuZCBpc0J1ZmZlciB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgdHlwZW9mIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgfVxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn1cblxuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcbi8vIE5COiBUaGUgVVJMIHRvIHRoZSBDb21tb25KUyBzcGVjIGlzIGtlcHQganVzdCBmb3IgdHJhZGl0aW9uLlxuLy8gICAgIG5vZGUtYXNzZXJ0IGhhcyBldm9sdmVkIGEgbG90IHNpbmNlIHRoZW4sIGJvdGggaW4gQVBJIGFuZCBiZWhhdmlvci5cblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbi8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5mdW5jdGlvbiBzdHJpY3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09Jywgc3RyaWN0KTtcbn1cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/assert/assert.js\n");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/definition.js":
/*!*****************************************************!*\
  !*** ./node_modules/eslint-scope/lib/definition.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nconst Variable = __webpack_require__(/*! ./variable */ \"./node_modules/eslint-scope/lib/variable.js\");\n/**\n * @class Definition\n */\n\n\nclass Definition {\n  constructor(type, name, node, parent, index, kind) {\n    /**\n     * @member {String} Definition#type - type of the occurrence (e.g. \"Parameter\", \"Variable\", ...).\n     */\n    this.type = type;\n    /**\n     * @member {espree.Identifier} Definition#name - the identifier AST node of the occurrence.\n     */\n\n    this.name = name;\n    /**\n     * @member {espree.Node} Definition#node - the enclosing node of the identifier.\n     */\n\n    this.node = node;\n    /**\n     * @member {espree.Node?} Definition#parent - the enclosing statement node of the identifier.\n     */\n\n    this.parent = parent;\n    /**\n     * @member {Number?} Definition#index - the index in the declaration statement.\n     */\n\n    this.index = index;\n    /**\n     * @member {String?} Definition#kind - the kind of the declaration statement.\n     */\n\n    this.kind = kind;\n  }\n\n}\n/**\n * @class ParameterDefinition\n */\n\n\nclass ParameterDefinition extends Definition {\n  constructor(name, node, index, rest) {\n    super(Variable.Parameter, name, node, null, index, null);\n    /**\n     * Whether the parameter definition is a part of a rest parameter.\n     * @member {boolean} ParameterDefinition#rest\n     */\n\n    this.rest = rest;\n  }\n\n}\n\nmodule.exports = {\n  ParameterDefinition,\n  Definition\n};\n/* vim: set sw=4 ts=4 et tw=80 : *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi9kZWZpbml0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzbGludC1zY29wZS9saWIvZGVmaW5pdGlvbi5qcz9kZTFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxNSBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblwidXNlIHN0cmljdFwiO1xuXG5jb25zdCBWYXJpYWJsZSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlXCIpO1xuXG4vKipcbiAqIEBjbGFzcyBEZWZpbml0aW9uXG4gKi9cbmNsYXNzIERlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIG5hbWUsIG5vZGUsIHBhcmVudCwgaW5kZXgsIGtpbmQpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBEZWZpbml0aW9uI3R5cGUgLSB0eXBlIG9mIHRoZSBvY2N1cnJlbmNlIChlLmcuIFwiUGFyYW1ldGVyXCIsIFwiVmFyaWFibGVcIiwgLi4uKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge2VzcHJlZS5JZGVudGlmaWVyfSBEZWZpbml0aW9uI25hbWUgLSB0aGUgaWRlbnRpZmllciBBU1Qgbm9kZSBvZiB0aGUgb2NjdXJyZW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge2VzcHJlZS5Ob2RlfSBEZWZpbml0aW9uI25vZGUgLSB0aGUgZW5jbG9zaW5nIG5vZGUgb2YgdGhlIGlkZW50aWZpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtlc3ByZWUuTm9kZT99IERlZmluaXRpb24jcGFyZW50IC0gdGhlIGVuY2xvc2luZyBzdGF0ZW1lbnQgbm9kZSBvZiB0aGUgaWRlbnRpZmllci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtOdW1iZXI/fSBEZWZpbml0aW9uI2luZGV4IC0gdGhlIGluZGV4IGluIHRoZSBkZWNsYXJhdGlvbiBzdGF0ZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge1N0cmluZz99IERlZmluaXRpb24ja2luZCAtIHRoZSBraW5kIG9mIHRoZSBkZWNsYXJhdGlvbiBzdGF0ZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgUGFyYW1ldGVyRGVmaW5pdGlvblxuICovXG5jbGFzcyBQYXJhbWV0ZXJEZWZpbml0aW9uIGV4dGVuZHMgRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgbm9kZSwgaW5kZXgsIHJlc3QpIHtcbiAgICAgICAgc3VwZXIoVmFyaWFibGUuUGFyYW1ldGVyLCBuYW1lLCBub2RlLCBudWxsLCBpbmRleCwgbnVsbCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHBhcmFtZXRlciBkZWZpbml0aW9uIGlzIGEgcGFydCBvZiBhIHJlc3QgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBQYXJhbWV0ZXJEZWZpbml0aW9uI3Jlc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQYXJhbWV0ZXJEZWZpbml0aW9uLFxuICAgIERlZmluaXRpb25cbn07XG5cbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBakNBO0FBbUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUZBO0FBS0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/eslint-scope/lib/definition.js\n");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/eslint-scope/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>\n  Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * Escope (<a href=\"http://github.com/estools/escope\">escope</a>) is an <a\n * href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript</a>\n * scope analyzer extracted from the <a\n * href=\"http://github.com/estools/esmangle\">esmangle project</a/>.\n * <p>\n * <em>escope</em> finds lexical scopes in a source program, i.e. areas of that\n * program where different occurrences of the same identifier refer to the same\n * variable. With each scope the contained variables are collected, and each\n * identifier reference in code is linked to its corresponding variable (if\n * possible).\n * <p>\n * <em>escope</em> works on a syntax tree of the parsed source code which has\n * to adhere to the <a\n * href=\"https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\">\n * Mozilla Parser API</a>. E.g. <a href=\"https://github.com/eslint/espree\">espree</a> is a parser\n * that produces such syntax trees.\n * <p>\n * The main interface is the {@link analyze} function.\n * @module escope\n */\n\n/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"__currentScope\"] }] */\n\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\");\n\nconst ScopeManager = __webpack_require__(/*! ./scope-manager */ \"./node_modules/eslint-scope/lib/scope-manager.js\");\n\nconst Referencer = __webpack_require__(/*! ./referencer */ \"./node_modules/eslint-scope/lib/referencer.js\");\n\nconst Reference = __webpack_require__(/*! ./reference */ \"./node_modules/eslint-scope/lib/reference.js\");\n\nconst Variable = __webpack_require__(/*! ./variable */ \"./node_modules/eslint-scope/lib/variable.js\");\n\nconst Scope = __webpack_require__(/*! ./scope */ \"./node_modules/eslint-scope/lib/scope.js\").Scope;\n\nconst version = __webpack_require__(/*! ../package.json */ \"./node_modules/eslint-scope/package.json\").version;\n/**\n * Set the default options\n * @returns {Object} options\n */\n\n\nfunction defaultOptions() {\n  return {\n    optimistic: false,\n    directive: false,\n    nodejsScope: false,\n    impliedStrict: false,\n    sourceType: \"script\",\n    // one of ['script', 'module']\n    ecmaVersion: 5,\n    childVisitorKeys: null,\n    fallback: \"iteration\"\n  };\n}\n/**\n * Preform deep update on option object\n * @param {Object} target - Options\n * @param {Object} override - Updates\n * @returns {Object} Updated options\n */\n\n\nfunction updateDeeply(target, override) {\n  /**\n   * Is hash object\n   * @param {Object} value - Test value\n   * @returns {boolean} Result\n   */\n  function isHashObject(value) {\n    return typeof value === \"object\" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);\n  }\n\n  for (const key in override) {\n    if (Object.prototype.hasOwnProperty.call(override, key)) {\n      const val = override[key];\n\n      if (isHashObject(val)) {\n        if (isHashObject(target[key])) {\n          updateDeeply(target[key], val);\n        } else {\n          target[key] = updateDeeply({}, val);\n        }\n      } else {\n        target[key] = val;\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * Main interface function. Takes an Espree syntax tree and returns the\n * analyzed scopes.\n * @function analyze\n * @param {espree.Tree} tree - Abstract Syntax Tree\n * @param {Object} providedOptions - Options that tailor the scope analysis\n * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag\n * @param {boolean} [providedOptions.directive=false]- the directive flag\n * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls\n * @param {boolean} [providedOptions.nodejsScope=false]- whether the whole\n * script is executed under node.js environment. When enabled, escope adds\n * a function scope immediately following the global scope.\n * @param {boolean} [providedOptions.impliedStrict=false]- implied strict mode\n * (if ecmaVersion >= 5).\n * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'\n * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered\n * @param {Object} [providedOptions.childVisitorKeys=null] - Additional known visitor keys. See [esrecurse](https://github.com/estools/esrecurse)'s the `childVisitorKeys` option.\n * @param {string} [providedOptions.fallback='iteration'] - A kind of the fallback in order to encounter with unknown node. See [esrecurse](https://github.com/estools/esrecurse)'s the `fallback` option.\n * @returns {ScopeManager} ScopeManager\n */\n\n\nfunction analyze(tree, providedOptions) {\n  const options = updateDeeply(defaultOptions(), providedOptions);\n  const scopeManager = new ScopeManager(options);\n  const referencer = new Referencer(options, scopeManager);\n  referencer.visit(tree);\n  assert(scopeManager.__currentScope === null, \"currentScope should be null.\");\n  return scopeManager;\n}\n\nmodule.exports = {\n  /** @name module:escope.version */\n  version,\n\n  /** @name module:escope.Reference */\n  Reference,\n\n  /** @name module:escope.Variable */\n  Variable,\n\n  /** @name module:escope.Scope */\n  Scope,\n\n  /** @name module:escope.ScopeManager */\n  ScopeManager,\n  analyze\n};\n/* vim: set sw=4 ts=4 et tw=80 : *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc2xpbnQtc2NvcGUvbGliL2luZGV4LmpzP2EzNGIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEyLTIwMTQgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQWxleCBTZXZpbGxlIDxoaUBhbGV4YW5kZXJzZXZpbGxlLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDE0IFRoaWFnbyBkZSBBcnJ1ZGEgPHRwYWRpbGhhODRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qKlxuICogRXNjb3BlICg8YSBocmVmPVwiaHR0cDovL2dpdGh1Yi5jb20vZXN0b29scy9lc2NvcGVcIj5lc2NvcGU8L2E+KSBpcyBhbiA8YVxuICogaHJlZj1cImh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvc3RhbmRhcmRzL0VjbWEtMjYyLmh0bVwiPkVDTUFTY3JpcHQ8L2E+XG4gKiBzY29wZSBhbmFseXplciBleHRyYWN0ZWQgZnJvbSB0aGUgPGFcbiAqIGhyZWY9XCJodHRwOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzbWFuZ2xlXCI+ZXNtYW5nbGUgcHJvamVjdDwvYS8+LlxuICogPHA+XG4gKiA8ZW0+ZXNjb3BlPC9lbT4gZmluZHMgbGV4aWNhbCBzY29wZXMgaW4gYSBzb3VyY2UgcHJvZ3JhbSwgaS5lLiBhcmVhcyBvZiB0aGF0XG4gKiBwcm9ncmFtIHdoZXJlIGRpZmZlcmVudCBvY2N1cnJlbmNlcyBvZiB0aGUgc2FtZSBpZGVudGlmaWVyIHJlZmVyIHRvIHRoZSBzYW1lXG4gKiB2YXJpYWJsZS4gV2l0aCBlYWNoIHNjb3BlIHRoZSBjb250YWluZWQgdmFyaWFibGVzIGFyZSBjb2xsZWN0ZWQsIGFuZCBlYWNoXG4gKiBpZGVudGlmaWVyIHJlZmVyZW5jZSBpbiBjb2RlIGlzIGxpbmtlZCB0byBpdHMgY29ycmVzcG9uZGluZyB2YXJpYWJsZSAoaWZcbiAqIHBvc3NpYmxlKS5cbiAqIDxwPlxuICogPGVtPmVzY29wZTwvZW0+IHdvcmtzIG9uIGEgc3ludGF4IHRyZWUgb2YgdGhlIHBhcnNlZCBzb3VyY2UgY29kZSB3aGljaCBoYXNcbiAqIHRvIGFkaGVyZSB0byB0aGUgPGFcbiAqIGhyZWY9XCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXCI+XG4gKiBNb3ppbGxhIFBhcnNlciBBUEk8L2E+LiBFLmcuIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzcHJlZVwiPmVzcHJlZTwvYT4gaXMgYSBwYXJzZXJcbiAqIHRoYXQgcHJvZHVjZXMgc3VjaCBzeW50YXggdHJlZXMuXG4gKiA8cD5cbiAqIFRoZSBtYWluIGludGVyZmFjZSBpcyB0aGUge0BsaW5rIGFuYWx5emV9IGZ1bmN0aW9uLlxuICogQG1vZHVsZSBlc2NvcGVcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGVzbGludCBuby11bmRlcnNjb3JlLWRhbmdsZTogW1wiZXJyb3JcIiwgeyBcImFsbG93XCI6IFtcIl9fY3VycmVudFNjb3BlXCJdIH1dICovXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbmNvbnN0IFNjb3BlTWFuYWdlciA9IHJlcXVpcmUoXCIuL3Njb3BlLW1hbmFnZXJcIik7XG5jb25zdCBSZWZlcmVuY2VyID0gcmVxdWlyZShcIi4vcmVmZXJlbmNlclwiKTtcbmNvbnN0IFJlZmVyZW5jZSA9IHJlcXVpcmUoXCIuL3JlZmVyZW5jZVwiKTtcbmNvbnN0IFZhcmlhYmxlID0gcmVxdWlyZShcIi4vdmFyaWFibGVcIik7XG5jb25zdCBTY29wZSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpLlNjb3BlO1xuY29uc3QgdmVyc2lvbiA9IHJlcXVpcmUoXCIuLi9wYWNrYWdlLmpzb25cIikudmVyc2lvbjtcblxuLyoqXG4gKiBTZXQgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgZGlyZWN0aXZlOiBmYWxzZSxcbiAgICAgICAgbm9kZWpzU2NvcGU6IGZhbHNlLFxuICAgICAgICBpbXBsaWVkU3RyaWN0OiBmYWxzZSxcbiAgICAgICAgc291cmNlVHlwZTogXCJzY3JpcHRcIiwgLy8gb25lIG9mIFsnc2NyaXB0JywgJ21vZHVsZSddXG4gICAgICAgIGVjbWFWZXJzaW9uOiA1LFxuICAgICAgICBjaGlsZFZpc2l0b3JLZXlzOiBudWxsLFxuICAgICAgICBmYWxsYmFjazogXCJpdGVyYXRpb25cIlxuICAgIH07XG59XG5cbi8qKlxuICogUHJlZm9ybSBkZWVwIHVwZGF0ZSBvbiBvcHRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IC0gT3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlIC0gVXBkYXRlc1xuICogQHJldHVybnMge09iamVjdH0gVXBkYXRlZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZURlZXBseSh0YXJnZXQsIG92ZXJyaWRlKSB7XG5cbiAgICAvKipcbiAgICAgKiBJcyBoYXNoIG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIFRlc3QgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmVzdWx0XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNIYXNoT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvdmVycmlkZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG92ZXJyaWRlLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBvdmVycmlkZVtrZXldO1xuXG4gICAgICAgICAgICBpZiAoaXNIYXNoT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIYXNoT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEZWVwbHkodGFyZ2V0W2tleV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB1cGRhdGVEZWVwbHkoe30sIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1haW4gaW50ZXJmYWNlIGZ1bmN0aW9uLiBUYWtlcyBhbiBFc3ByZWUgc3ludGF4IHRyZWUgYW5kIHJldHVybnMgdGhlXG4gKiBhbmFseXplZCBzY29wZXMuXG4gKiBAZnVuY3Rpb24gYW5hbHl6ZVxuICogQHBhcmFtIHtlc3ByZWUuVHJlZX0gdHJlZSAtIEFic3RyYWN0IFN5bnRheCBUcmVlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdmlkZWRPcHRpb25zIC0gT3B0aW9ucyB0aGF0IHRhaWxvciB0aGUgc2NvcGUgYW5hbHlzaXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3ZpZGVkT3B0aW9ucy5vcHRpbWlzdGljPWZhbHNlXSAtIHRoZSBvcHRpbWlzdGljIGZsYWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3ZpZGVkT3B0aW9ucy5kaXJlY3RpdmU9ZmFsc2VdLSB0aGUgZGlyZWN0aXZlIGZsYWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3ZpZGVkT3B0aW9ucy5pZ25vcmVFdmFsPWZhbHNlXS0gd2hldGhlciB0byBjaGVjayAnZXZhbCgpJyBjYWxsc1xuICogQHBhcmFtIHtib29sZWFufSBbcHJvdmlkZWRPcHRpb25zLm5vZGVqc1Njb3BlPWZhbHNlXS0gd2hldGhlciB0aGUgd2hvbGVcbiAqIHNjcmlwdCBpcyBleGVjdXRlZCB1bmRlciBub2RlLmpzIGVudmlyb25tZW50LiBXaGVuIGVuYWJsZWQsIGVzY29wZSBhZGRzXG4gKiBhIGZ1bmN0aW9uIHNjb3BlIGltbWVkaWF0ZWx5IGZvbGxvd2luZyB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJvdmlkZWRPcHRpb25zLmltcGxpZWRTdHJpY3Q9ZmFsc2VdLSBpbXBsaWVkIHN0cmljdCBtb2RlXG4gKiAoaWYgZWNtYVZlcnNpb24gPj0gNSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3ZpZGVkT3B0aW9ucy5zb3VyY2VUeXBlPSdzY3JpcHQnXS0gdGhlIHNvdXJjZSB0eXBlIG9mIHRoZSBzY3JpcHQuIG9uZSBvZiAnc2NyaXB0JyBhbmQgJ21vZHVsZSdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvdmlkZWRPcHRpb25zLmVjbWFWZXJzaW9uPTVdLSB3aGljaCBFQ01BU2NyaXB0IHZlcnNpb24gaXMgY29uc2lkZXJlZFxuICogQHBhcmFtIHtPYmplY3R9IFtwcm92aWRlZE9wdGlvbnMuY2hpbGRWaXNpdG9yS2V5cz1udWxsXSAtIEFkZGl0aW9uYWwga25vd24gdmlzaXRvciBrZXlzLiBTZWUgW2VzcmVjdXJzZV0oaHR0cHM6Ly9naXRodWIuY29tL2VzdG9vbHMvZXNyZWN1cnNlKSdzIHRoZSBgY2hpbGRWaXNpdG9yS2V5c2Agb3B0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm92aWRlZE9wdGlvbnMuZmFsbGJhY2s9J2l0ZXJhdGlvbiddIC0gQSBraW5kIG9mIHRoZSBmYWxsYmFjayBpbiBvcmRlciB0byBlbmNvdW50ZXIgd2l0aCB1bmtub3duIG5vZGUuIFNlZSBbZXNyZWN1cnNlXShodHRwczovL2dpdGh1Yi5jb20vZXN0b29scy9lc3JlY3Vyc2UpJ3MgdGhlIGBmYWxsYmFja2Agb3B0aW9uLlxuICogQHJldHVybnMge1Njb3BlTWFuYWdlcn0gU2NvcGVNYW5hZ2VyXG4gKi9cbmZ1bmN0aW9uIGFuYWx5emUodHJlZSwgcHJvdmlkZWRPcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHVwZGF0ZURlZXBseShkZWZhdWx0T3B0aW9ucygpLCBwcm92aWRlZE9wdGlvbnMpO1xuICAgIGNvbnN0IHNjb3BlTWFuYWdlciA9IG5ldyBTY29wZU1hbmFnZXIob3B0aW9ucyk7XG4gICAgY29uc3QgcmVmZXJlbmNlciA9IG5ldyBSZWZlcmVuY2VyKG9wdGlvbnMsIHNjb3BlTWFuYWdlcik7XG5cbiAgICByZWZlcmVuY2VyLnZpc2l0KHRyZWUpO1xuXG4gICAgYXNzZXJ0KHNjb3BlTWFuYWdlci5fX2N1cnJlbnRTY29wZSA9PT0gbnVsbCwgXCJjdXJyZW50U2NvcGUgc2hvdWxkIGJlIG51bGwuXCIpO1xuXG4gICAgcmV0dXJuIHNjb3BlTWFuYWdlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvKiogQG5hbWUgbW9kdWxlOmVzY29wZS52ZXJzaW9uICovXG4gICAgdmVyc2lvbixcblxuICAgIC8qKiBAbmFtZSBtb2R1bGU6ZXNjb3BlLlJlZmVyZW5jZSAqL1xuICAgIFJlZmVyZW5jZSxcblxuICAgIC8qKiBAbmFtZSBtb2R1bGU6ZXNjb3BlLlZhcmlhYmxlICovXG4gICAgVmFyaWFibGUsXG5cbiAgICAvKiogQG5hbWUgbW9kdWxlOmVzY29wZS5TY29wZSAqL1xuICAgIFNjb3BlLFxuXG4gICAgLyoqIEBuYW1lIG1vZHVsZTplc2NvcGUuU2NvcGVNYW5hZ2VyICovXG4gICAgU2NvcGVNYW5hZ2VyLFxuICAgIGFuYWx5emVcbn07XG5cblxuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBb0JBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/eslint-scope/lib/index.js\n");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/pattern-visitor.js":
/*!**********************************************************!*\
  !*** ./node_modules/eslint-scope/lib/pattern-visitor.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* eslint-disable no-undefined */\n\nconst Syntax = __webpack_require__(/*! estraverse */ \"./node_modules/estraverse/estraverse.js\").Syntax;\n\nconst esrecurse = __webpack_require__(/*! esrecurse */ \"./node_modules/esrecurse/esrecurse.js\");\n/**\n * Get last array element\n * @param {array} xs - array\n * @returns {any} Last elment\n */\n\n\nfunction getLast(xs) {\n  return xs[xs.length - 1] || null;\n}\n\nclass PatternVisitor extends esrecurse.Visitor {\n  static isPattern(node) {\n    const nodeType = node.type;\n    return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;\n  }\n\n  constructor(options, rootPattern, callback) {\n    super(null, options);\n    this.rootPattern = rootPattern;\n    this.callback = callback;\n    this.assignments = [];\n    this.rightHandNodes = [];\n    this.restElements = [];\n  }\n\n  Identifier(pattern) {\n    const lastRestElement = getLast(this.restElements);\n    this.callback(pattern, {\n      topLevel: pattern === this.rootPattern,\n      rest: lastRestElement !== null && lastRestElement !== undefined && lastRestElement.argument === pattern,\n      assignments: this.assignments\n    });\n  }\n\n  Property(property) {\n    // Computed property's key is a right hand node.\n    if (property.computed) {\n      this.rightHandNodes.push(property.key);\n    } // If it's shorthand, its key is same as its value.\n    // If it's shorthand and has its default value, its key is same as its value.left (the value is AssignmentPattern).\n    // If it's not shorthand, the name of new variable is its value's.\n\n\n    this.visit(property.value);\n  }\n\n  ArrayPattern(pattern) {\n    for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {\n      const element = pattern.elements[i];\n      this.visit(element);\n    }\n  }\n\n  AssignmentPattern(pattern) {\n    this.assignments.push(pattern);\n    this.visit(pattern.left);\n    this.rightHandNodes.push(pattern.right);\n    this.assignments.pop();\n  }\n\n  RestElement(pattern) {\n    this.restElements.push(pattern);\n    this.visit(pattern.argument);\n    this.restElements.pop();\n  }\n\n  MemberExpression(node) {\n    // Computed property's key is a right hand node.\n    if (node.computed) {\n      this.rightHandNodes.push(node.property);\n    } // the object is only read, write to its property.\n\n\n    this.rightHandNodes.push(node.object);\n  } //\n  // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.\n  // By spec, LeftHandSideExpression is Pattern or MemberExpression.\n  //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)\n  // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...\n  //\n\n\n  SpreadElement(node) {\n    this.visit(node.argument);\n  }\n\n  ArrayExpression(node) {\n    node.elements.forEach(this.visit, this);\n  }\n\n  AssignmentExpression(node) {\n    this.assignments.push(node);\n    this.visit(node.left);\n    this.rightHandNodes.push(node.right);\n    this.assignments.pop();\n  }\n\n  CallExpression(node) {\n    // arguments are right hand nodes.\n    node.arguments.forEach(a => {\n      this.rightHandNodes.push(a);\n    });\n    this.visit(node.callee);\n  }\n\n}\n\nmodule.exports = PatternVisitor;\n/* vim: set sw=4 ts=4 et tw=80 : *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi9wYXR0ZXJuLXZpc2l0b3IuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi9wYXR0ZXJuLXZpc2l0b3IuanM/M2M4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cInVzZSBzdHJpY3RcIjtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG5cbmNvbnN0IFN5bnRheCA9IHJlcXVpcmUoXCJlc3RyYXZlcnNlXCIpLlN5bnRheDtcbmNvbnN0IGVzcmVjdXJzZSA9IHJlcXVpcmUoXCJlc3JlY3Vyc2VcIik7XG5cbi8qKlxuICogR2V0IGxhc3QgYXJyYXkgZWxlbWVudFxuICogQHBhcmFtIHthcnJheX0geHMgLSBhcnJheVxuICogQHJldHVybnMge2FueX0gTGFzdCBlbG1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0TGFzdCh4cykge1xuICAgIHJldHVybiB4c1t4cy5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuXG5jbGFzcyBQYXR0ZXJuVmlzaXRvciBleHRlbmRzIGVzcmVjdXJzZS5WaXNpdG9yIHtcbiAgICBzdGF0aWMgaXNQYXR0ZXJuKG5vZGUpIHtcbiAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBTeW50YXguSWRlbnRpZmllciB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFN5bnRheC5PYmplY3RQYXR0ZXJuIHx8XG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gU3ludGF4LkFycmF5UGF0dGVybiB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFN5bnRheC5TcHJlYWRFbGVtZW50IHx8XG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gU3ludGF4LlJlc3RFbGVtZW50IHx8XG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gU3ludGF4LkFzc2lnbm1lbnRQYXR0ZXJuXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgcm9vdFBhdHRlcm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJvb3RQYXR0ZXJuID0gcm9vdFBhdHRlcm47XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50cyA9IFtdO1xuICAgICAgICB0aGlzLnJpZ2h0SGFuZE5vZGVzID0gW107XG4gICAgICAgIHRoaXMucmVzdEVsZW1lbnRzID0gW107XG4gICAgfVxuXG4gICAgSWRlbnRpZmllcihwYXR0ZXJuKSB7XG4gICAgICAgIGNvbnN0IGxhc3RSZXN0RWxlbWVudCA9IGdldExhc3QodGhpcy5yZXN0RWxlbWVudHMpO1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2socGF0dGVybiwge1xuICAgICAgICAgICAgdG9wTGV2ZWw6IHBhdHRlcm4gPT09IHRoaXMucm9vdFBhdHRlcm4sXG4gICAgICAgICAgICByZXN0OiBsYXN0UmVzdEVsZW1lbnQgIT09IG51bGwgJiYgbGFzdFJlc3RFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgbGFzdFJlc3RFbGVtZW50LmFyZ3VtZW50ID09PSBwYXR0ZXJuLFxuICAgICAgICAgICAgYXNzaWdubWVudHM6IHRoaXMuYXNzaWdubWVudHNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgUHJvcGVydHkocHJvcGVydHkpIHtcblxuICAgICAgICAvLyBDb21wdXRlZCBwcm9wZXJ0eSdzIGtleSBpcyBhIHJpZ2h0IGhhbmQgbm9kZS5cbiAgICAgICAgaWYgKHByb3BlcnR5LmNvbXB1dGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0SGFuZE5vZGVzLnB1c2gocHJvcGVydHkua2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0J3Mgc2hvcnRoYW5kLCBpdHMga2V5IGlzIHNhbWUgYXMgaXRzIHZhbHVlLlxuICAgICAgICAvLyBJZiBpdCdzIHNob3J0aGFuZCBhbmQgaGFzIGl0cyBkZWZhdWx0IHZhbHVlLCBpdHMga2V5IGlzIHNhbWUgYXMgaXRzIHZhbHVlLmxlZnQgKHRoZSB2YWx1ZSBpcyBBc3NpZ25tZW50UGF0dGVybikuXG4gICAgICAgIC8vIElmIGl0J3Mgbm90IHNob3J0aGFuZCwgdGhlIG5hbWUgb2YgbmV3IHZhcmlhYmxlIGlzIGl0cyB2YWx1ZSdzLlxuICAgICAgICB0aGlzLnZpc2l0KHByb3BlcnR5LnZhbHVlKTtcbiAgICB9XG5cbiAgICBBcnJheVBhdHRlcm4ocGF0dGVybikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaXogPSBwYXR0ZXJuLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBwYXR0ZXJuLmVsZW1lbnRzW2ldO1xuXG4gICAgICAgICAgICB0aGlzLnZpc2l0KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQXNzaWdubWVudFBhdHRlcm4ocGF0dGVybikge1xuICAgICAgICB0aGlzLmFzc2lnbm1lbnRzLnB1c2gocGF0dGVybik7XG4gICAgICAgIHRoaXMudmlzaXQocGF0dGVybi5sZWZ0KTtcbiAgICAgICAgdGhpcy5yaWdodEhhbmROb2Rlcy5wdXNoKHBhdHRlcm4ucmlnaHQpO1xuICAgICAgICB0aGlzLmFzc2lnbm1lbnRzLnBvcCgpO1xuICAgIH1cblxuICAgIFJlc3RFbGVtZW50KHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5yZXN0RWxlbWVudHMucHVzaChwYXR0ZXJuKTtcbiAgICAgICAgdGhpcy52aXNpdChwYXR0ZXJuLmFyZ3VtZW50KTtcbiAgICAgICAgdGhpcy5yZXN0RWxlbWVudHMucG9wKCk7XG4gICAgfVxuXG4gICAgTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XG5cbiAgICAgICAgLy8gQ29tcHV0ZWQgcHJvcGVydHkncyBrZXkgaXMgYSByaWdodCBoYW5kIG5vZGUuXG4gICAgICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0SGFuZE5vZGVzLnB1c2gobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgb2JqZWN0IGlzIG9ubHkgcmVhZCwgd3JpdGUgdG8gaXRzIHByb3BlcnR5LlxuICAgICAgICB0aGlzLnJpZ2h0SGFuZE5vZGVzLnB1c2gobm9kZS5vYmplY3QpO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gRm9ySW5TdGF0ZW1lbnQubGVmdCBhbmQgQXNzaWdubWVudEV4cHJlc3Npb24ubGVmdCBhcmUgTGVmdEhhbmRTaWRlRXhwcmVzc2lvbi5cbiAgICAvLyBCeSBzcGVjLCBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uIGlzIFBhdHRlcm4gb3IgTWVtYmVyRXhwcmVzc2lvbi5cbiAgICAvLyAgIChzZWUgYWxzbzogaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvcHVsbC8yMCNpc3N1ZWNvbW1lbnQtNzQ1ODQ3NTgpXG4gICAgLy8gQnV0IGVzcHJlZSAyLjAgcGFyc2VzIHRvIEFycmF5RXhwcmVzc2lvbiwgT2JqZWN0RXhwcmVzc2lvbiwgZXRjLi4uXG4gICAgLy9cblxuICAgIFNwcmVhZEVsZW1lbnQobm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0KG5vZGUuYXJndW1lbnQpO1xuICAgIH1cblxuICAgIEFycmF5RXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIG5vZGUuZWxlbWVudHMuZm9yRWFjaCh0aGlzLnZpc2l0LCB0aGlzKTtcbiAgICB9XG5cbiAgICBBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIHRoaXMuYXNzaWdubWVudHMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLmxlZnQpO1xuICAgICAgICB0aGlzLnJpZ2h0SGFuZE5vZGVzLnB1c2gobm9kZS5yaWdodCk7XG4gICAgICAgIHRoaXMuYXNzaWdubWVudHMucG9wKCk7XG4gICAgfVxuXG4gICAgQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuXG4gICAgICAgIC8vIGFyZ3VtZW50cyBhcmUgcmlnaHQgaGFuZCBub2Rlcy5cbiAgICAgICAgbm9kZS5hcmd1bWVudHMuZm9yRWFjaChhID0+IHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRIYW5kTm9kZXMucHVzaChhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5jYWxsZWUpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXR0ZXJuVmlzaXRvcjtcblxuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUdBO0FBQ0E7QUE2R0E7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/eslint-scope/lib/pattern-visitor.js\n");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/reference.js":
/*!****************************************************!*\
  !*** ./node_modules/eslint-scope/lib/reference.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nconst READ = 0x1;\nconst WRITE = 0x2;\nconst RW = READ | WRITE;\n/**\n * A Reference represents a single occurrence of an identifier in code.\n * @class Reference\n */\n\nclass Reference {\n  constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {\n    /**\n     * Identifier syntax node.\n     * @member {espreeIdentifier} Reference#identifier\n     */\n    this.identifier = ident;\n    /**\n     * Reference to the enclosing Scope.\n     * @member {Scope} Reference#from\n     */\n\n    this.from = scope;\n    /**\n     * Whether the reference comes from a dynamic scope (such as 'eval',\n     * 'with', etc.), and may be trapped by dynamic scopes.\n     * @member {boolean} Reference#tainted\n     */\n\n    this.tainted = false;\n    /**\n     * The variable this reference is resolved with.\n     * @member {Variable} Reference#resolved\n     */\n\n    this.resolved = null;\n    /**\n     * The read-write mode of the reference. (Value is one of {@link\n     * Reference.READ}, {@link Reference.RW}, {@link Reference.WRITE}).\n     * @member {number} Reference#flag\n     * @private\n     */\n\n    this.flag = flag;\n\n    if (this.isWrite()) {\n      /**\n       * If reference is writeable, this is the tree being written to it.\n       * @member {espreeNode} Reference#writeExpr\n       */\n      this.writeExpr = writeExpr;\n      /**\n       * Whether the Reference might refer to a partial value of writeExpr.\n       * @member {boolean} Reference#partial\n       */\n\n      this.partial = partial;\n      /**\n       * Whether the Reference is to write of initialization.\n       * @member {boolean} Reference#init\n       */\n\n      this.init = init;\n    }\n\n    this.__maybeImplicitGlobal = maybeImplicitGlobal;\n  }\n  /**\n   * Whether the reference is static.\n   * @method Reference#isStatic\n   * @returns {boolean} static\n   */\n\n\n  isStatic() {\n    return !this.tainted && this.resolved && this.resolved.scope.isStatic();\n  }\n  /**\n   * Whether the reference is writeable.\n   * @method Reference#isWrite\n   * @returns {boolean} write\n   */\n\n\n  isWrite() {\n    return !!(this.flag & Reference.WRITE);\n  }\n  /**\n   * Whether the reference is readable.\n   * @method Reference#isRead\n   * @returns {boolean} read\n   */\n\n\n  isRead() {\n    return !!(this.flag & Reference.READ);\n  }\n  /**\n   * Whether the reference is read-only.\n   * @method Reference#isReadOnly\n   * @returns {boolean} read only\n   */\n\n\n  isReadOnly() {\n    return this.flag === Reference.READ;\n  }\n  /**\n   * Whether the reference is write-only.\n   * @method Reference#isWriteOnly\n   * @returns {boolean} write only\n   */\n\n\n  isWriteOnly() {\n    return this.flag === Reference.WRITE;\n  }\n  /**\n   * Whether the reference is read-write.\n   * @method Reference#isReadWrite\n   * @returns {boolean} read write\n   */\n\n\n  isReadWrite() {\n    return this.flag === Reference.RW;\n  }\n\n}\n/**\n * @constant Reference.READ\n * @private\n */\n\n\nReference.READ = READ;\n/**\n * @constant Reference.WRITE\n * @private\n */\n\nReference.WRITE = WRITE;\n/**\n * @constant Reference.RW\n * @private\n */\n\nReference.RW = RW;\nmodule.exports = Reference;\n/* vim: set sw=4 ts=4 et tw=80 : *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi9yZWZlcmVuY2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi9yZWZlcmVuY2UuanM/MzBhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cInVzZSBzdHJpY3RcIjtcblxuY29uc3QgUkVBRCA9IDB4MTtcbmNvbnN0IFdSSVRFID0gMHgyO1xuY29uc3QgUlcgPSBSRUFEIHwgV1JJVEU7XG5cbi8qKlxuICogQSBSZWZlcmVuY2UgcmVwcmVzZW50cyBhIHNpbmdsZSBvY2N1cnJlbmNlIG9mIGFuIGlkZW50aWZpZXIgaW4gY29kZS5cbiAqIEBjbGFzcyBSZWZlcmVuY2VcbiAqL1xuY2xhc3MgUmVmZXJlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihpZGVudCwgc2NvcGUsIGZsYWcsIHdyaXRlRXhwciwgbWF5YmVJbXBsaWNpdEdsb2JhbCwgcGFydGlhbCwgaW5pdCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVudGlmaWVyIHN5bnRheCBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtlc3ByZWVJZGVudGlmaWVyfSBSZWZlcmVuY2UjaWRlbnRpZmllclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgZW5jbG9zaW5nIFNjb3BlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTY29wZX0gUmVmZXJlbmNlI2Zyb21cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZnJvbSA9IHNjb3BlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSByZWZlcmVuY2UgY29tZXMgZnJvbSBhIGR5bmFtaWMgc2NvcGUgKHN1Y2ggYXMgJ2V2YWwnLFxuICAgICAgICAgKiAnd2l0aCcsIGV0Yy4pLCBhbmQgbWF5IGJlIHRyYXBwZWQgYnkgZHluYW1pYyBzY29wZXMuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IFJlZmVyZW5jZSN0YWludGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhaW50ZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhcmlhYmxlIHRoaXMgcmVmZXJlbmNlIGlzIHJlc29sdmVkIHdpdGguXG4gICAgICAgICAqIEBtZW1iZXIge1ZhcmlhYmxlfSBSZWZlcmVuY2UjcmVzb2x2ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVhZC13cml0ZSBtb2RlIG9mIHRoZSByZWZlcmVuY2UuIChWYWx1ZSBpcyBvbmUgb2Yge0BsaW5rXG4gICAgICAgICAqIFJlZmVyZW5jZS5SRUFEfSwge0BsaW5rIFJlZmVyZW5jZS5SV30sIHtAbGluayBSZWZlcmVuY2UuV1JJVEV9KS5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBSZWZlcmVuY2UjZmxhZ1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbGFnID0gZmxhZztcbiAgICAgICAgaWYgKHRoaXMuaXNXcml0ZSgpKSB7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgcmVmZXJlbmNlIGlzIHdyaXRlYWJsZSwgdGhpcyBpcyB0aGUgdHJlZSBiZWluZyB3cml0dGVuIHRvIGl0LlxuICAgICAgICAgICAgICogQG1lbWJlciB7ZXNwcmVlTm9kZX0gUmVmZXJlbmNlI3dyaXRlRXhwclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLndyaXRlRXhwciA9IHdyaXRlRXhwcjtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBSZWZlcmVuY2UgbWlnaHQgcmVmZXIgdG8gYSBwYXJ0aWFsIHZhbHVlIG9mIHdyaXRlRXhwci5cbiAgICAgICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IFJlZmVyZW5jZSNwYXJ0aWFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFydGlhbCA9IHBhcnRpYWw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgUmVmZXJlbmNlIGlzIHRvIHdyaXRlIG9mIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gUmVmZXJlbmNlI2luaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fbWF5YmVJbXBsaWNpdEdsb2JhbCA9IG1heWJlSW1wbGljaXRHbG9iYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHN0YXRpYy5cbiAgICAgKiBAbWV0aG9kIFJlZmVyZW5jZSNpc1N0YXRpY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBzdGF0aWNcbiAgICAgKi9cbiAgICBpc1N0YXRpYygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnRhaW50ZWQgJiYgdGhpcy5yZXNvbHZlZCAmJiB0aGlzLnJlc29sdmVkLnNjb3BlLmlzU3RhdGljKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHdyaXRlYWJsZS5cbiAgICAgKiBAbWV0aG9kIFJlZmVyZW5jZSNpc1dyaXRlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdyaXRlXG4gICAgICovXG4gICAgaXNXcml0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZyAmIFJlZmVyZW5jZS5XUklURSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHJlYWRhYmxlLlxuICAgICAqIEBtZXRob2QgUmVmZXJlbmNlI2lzUmVhZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZWFkXG4gICAgICovXG4gICAgaXNSZWFkKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5mbGFnICYgUmVmZXJlbmNlLlJFQUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlZmVyZW5jZSBpcyByZWFkLW9ubHkuXG4gICAgICogQG1ldGhvZCBSZWZlcmVuY2UjaXNSZWFkT25seVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZWFkIG9ubHlcbiAgICAgKi9cbiAgICBpc1JlYWRPbmx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFnID09PSBSZWZlcmVuY2UuUkVBRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZWZlcmVuY2UgaXMgd3JpdGUtb25seS5cbiAgICAgKiBAbWV0aG9kIFJlZmVyZW5jZSNpc1dyaXRlT25seVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3cml0ZSBvbmx5XG4gICAgICovXG4gICAgaXNXcml0ZU9ubHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWcgPT09IFJlZmVyZW5jZS5XUklURTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSByZWZlcmVuY2UgaXMgcmVhZC13cml0ZS5cbiAgICAgKiBAbWV0aG9kIFJlZmVyZW5jZSNpc1JlYWRXcml0ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSByZWFkIHdyaXRlXG4gICAgICovXG4gICAgaXNSZWFkV3JpdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWcgPT09IFJlZmVyZW5jZS5SVztcbiAgICB9XG59XG5cbi8qKlxuICogQGNvbnN0YW50IFJlZmVyZW5jZS5SRUFEXG4gKiBAcHJpdmF0ZVxuICovXG5SZWZlcmVuY2UuUkVBRCA9IFJFQUQ7XG5cbi8qKlxuICogQGNvbnN0YW50IFJlZmVyZW5jZS5XUklURVxuICogQHByaXZhdGVcbiAqL1xuUmVmZXJlbmNlLldSSVRFID0gV1JJVEU7XG5cbi8qKlxuICogQGNvbnN0YW50IFJlZmVyZW5jZS5SV1xuICogQHByaXZhdGVcbiAqL1xuUmVmZXJlbmNlLlJXID0gUlc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVmZXJlbmNlO1xuXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQS9HQTtBQWlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/eslint-scope/lib/reference.js\n");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/referencer.js":
/*!*****************************************************!*\
  !*** ./node_modules/eslint-scope/lib/referencer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable no-undefined */\n\nconst Syntax = __webpack_require__(/*! estraverse */ \"./node_modules/estraverse/estraverse.js\").Syntax;\n\nconst esrecurse = __webpack_require__(/*! esrecurse */ \"./node_modules/esrecurse/esrecurse.js\");\n\nconst Reference = __webpack_require__(/*! ./reference */ \"./node_modules/eslint-scope/lib/reference.js\");\n\nconst Variable = __webpack_require__(/*! ./variable */ \"./node_modules/eslint-scope/lib/variable.js\");\n\nconst PatternVisitor = __webpack_require__(/*! ./pattern-visitor */ \"./node_modules/eslint-scope/lib/pattern-visitor.js\");\n\nconst definition = __webpack_require__(/*! ./definition */ \"./node_modules/eslint-scope/lib/definition.js\");\n\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\");\n\nconst ParameterDefinition = definition.ParameterDefinition;\nconst Definition = definition.Definition;\n/**\n * Traverse identifier in pattern\n * @param {Object} options - options\n * @param {pattern} rootPattern - root pattern\n * @param {Refencer} referencer - referencer\n * @param {callback} callback - callback\n * @returns {void}\n */\n\nfunction traverseIdentifierInPattern(options, rootPattern, referencer, callback) {\n  // Call the callback at left hand identifier nodes, and Collect right hand nodes.\n  const visitor = new PatternVisitor(options, rootPattern, callback);\n  visitor.visit(rootPattern); // Process the right hand nodes recursively.\n\n  if (referencer !== null && referencer !== undefined) {\n    visitor.rightHandNodes.forEach(referencer.visit, referencer);\n  }\n} // Importing ImportDeclaration.\n// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation\n// https://github.com/estree/estree/blob/master/es6.md#importdeclaration\n// FIXME: Now, we don't create module environment, because the context is\n// implementation dependent.\n\n\nclass Importer extends esrecurse.Visitor {\n  constructor(declaration, referencer) {\n    super(null, referencer.options);\n    this.declaration = declaration;\n    this.referencer = referencer;\n  }\n\n  visitImport(id, specifier) {\n    this.referencer.visitPattern(id, pattern => {\n      this.referencer.currentScope().__define(pattern, new Definition(Variable.ImportBinding, pattern, specifier, this.declaration, null, null));\n    });\n  }\n\n  ImportNamespaceSpecifier(node) {\n    const local = node.local || node.id;\n\n    if (local) {\n      this.visitImport(local, node);\n    }\n  }\n\n  ImportDefaultSpecifier(node) {\n    const local = node.local || node.id;\n    this.visitImport(local, node);\n  }\n\n  ImportSpecifier(node) {\n    const local = node.local || node.id;\n\n    if (node.name) {\n      this.visitImport(node.name, node);\n    } else {\n      this.visitImport(local, node);\n    }\n  }\n\n} // Referencing variables and creating bindings.\n\n\nclass Referencer extends esrecurse.Visitor {\n  constructor(options, scopeManager) {\n    super(null, options);\n    this.options = options;\n    this.scopeManager = scopeManager;\n    this.parent = null;\n    this.isInnerMethodDefinition = false;\n  }\n\n  currentScope() {\n    return this.scopeManager.__currentScope;\n  }\n\n  close(node) {\n    while (this.currentScope() && node === this.currentScope().block) {\n      this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);\n    }\n  }\n\n  pushInnerMethodDefinition(isInnerMethodDefinition) {\n    const previous = this.isInnerMethodDefinition;\n    this.isInnerMethodDefinition = isInnerMethodDefinition;\n    return previous;\n  }\n\n  popInnerMethodDefinition(isInnerMethodDefinition) {\n    this.isInnerMethodDefinition = isInnerMethodDefinition;\n  }\n\n  referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {\n    const scope = this.currentScope();\n    assignments.forEach(assignment => {\n      scope.__referencing(pattern, Reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);\n    });\n  }\n\n  visitPattern(node, options, callback) {\n    let visitPatternOptions = options;\n    let visitPatternCallback = callback;\n\n    if (typeof options === \"function\") {\n      visitPatternCallback = options;\n      visitPatternOptions = {\n        processRightHandNodes: false\n      };\n    }\n\n    traverseIdentifierInPattern(this.options, node, visitPatternOptions.processRightHandNodes ? this : null, visitPatternCallback);\n  }\n\n  visitFunction(node) {\n    let i, iz; // FunctionDeclaration name is defined in upper scope\n    // NOTE: Not referring variableScope. It is intended.\n    // Since\n    //  in ES5, FunctionDeclaration should be in FunctionBody.\n    //  in ES6, FunctionDeclaration should be block scoped.\n\n    if (node.type === Syntax.FunctionDeclaration) {\n      // id is defined in upper scope\n      this.currentScope().__define(node.id, new Definition(Variable.FunctionName, node.id, node, null, null, null));\n    } // FunctionExpression with name creates its special scope;\n    // FunctionExpressionNameScope.\n\n\n    if (node.type === Syntax.FunctionExpression && node.id) {\n      this.scopeManager.__nestFunctionExpressionNameScope(node);\n    } // Consider this function is in the MethodDefinition.\n\n\n    this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);\n\n    const that = this;\n    /**\n     * Visit pattern callback\n     * @param {pattern} pattern - pattern\n     * @param {Object} info - info\n     * @returns {void}\n     */\n\n    function visitPatternCallback(pattern, info) {\n      that.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info.rest));\n\n      that.referencingDefaultValue(pattern, info.assignments, null, true);\n    } // Process parameter declarations.\n\n\n    for (i = 0, iz = node.params.length; i < iz; ++i) {\n      this.visitPattern(node.params[i], {\n        processRightHandNodes: true\n      }, visitPatternCallback);\n    } // if there's a rest argument, add that\n\n\n    if (node.rest) {\n      this.visitPattern({\n        type: \"RestElement\",\n        argument: node.rest\n      }, pattern => {\n        this.currentScope().__define(pattern, new ParameterDefinition(pattern, node, node.params.length, true));\n      });\n    } // In TypeScript there are a number of function-like constructs which have no body,\n    // so check it exists before traversing\n\n\n    if (node.body) {\n      // Skip BlockStatement to prevent creating BlockStatement scope.\n      if (node.body.type === Syntax.BlockStatement) {\n        this.visitChildren(node.body);\n      } else {\n        this.visit(node.body);\n      }\n    }\n\n    this.close(node);\n  }\n\n  visitClass(node) {\n    if (node.type === Syntax.ClassDeclaration) {\n      this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node, null, null, null));\n    }\n\n    this.visit(node.superClass);\n\n    this.scopeManager.__nestClassScope(node);\n\n    if (node.id) {\n      this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node));\n    }\n\n    this.visit(node.body);\n    this.close(node);\n  }\n\n  visitProperty(node) {\n    let previous;\n\n    if (node.computed) {\n      this.visit(node.key);\n    }\n\n    const isMethodDefinition = node.type === Syntax.MethodDefinition;\n\n    if (isMethodDefinition) {\n      previous = this.pushInnerMethodDefinition(true);\n    }\n\n    this.visit(node.value);\n\n    if (isMethodDefinition) {\n      this.popInnerMethodDefinition(previous);\n    }\n  }\n\n  visitForIn(node) {\n    if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== \"var\") {\n      this.scopeManager.__nestForScope(node);\n    }\n\n    if (node.left.type === Syntax.VariableDeclaration) {\n      this.visit(node.left);\n      this.visitPattern(node.left.declarations[0].id, pattern => {\n        this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);\n      });\n    } else {\n      this.visitPattern(node.left, {\n        processRightHandNodes: true\n      }, (pattern, info) => {\n        let maybeImplicitGlobal = null;\n\n        if (!this.currentScope().isStrict) {\n          maybeImplicitGlobal = {\n            pattern,\n            node\n          };\n        }\n\n        this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n\n        this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);\n      });\n    }\n\n    this.visit(node.right);\n    this.visit(node.body);\n    this.close(node);\n  }\n\n  visitVariableDeclaration(variableTargetScope, type, node, index) {\n    const decl = node.declarations[index];\n    const init = decl.init;\n    this.visitPattern(decl.id, {\n      processRightHandNodes: true\n    }, (pattern, info) => {\n      variableTargetScope.__define(pattern, new Definition(type, pattern, decl, node, index, node.kind));\n\n      this.referencingDefaultValue(pattern, info.assignments, null, true);\n\n      if (init) {\n        this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);\n      }\n    });\n  }\n\n  AssignmentExpression(node) {\n    if (PatternVisitor.isPattern(node.left)) {\n      if (node.operator === \"=\") {\n        this.visitPattern(node.left, {\n          processRightHandNodes: true\n        }, (pattern, info) => {\n          let maybeImplicitGlobal = null;\n\n          if (!this.currentScope().isStrict) {\n            maybeImplicitGlobal = {\n              pattern,\n              node\n            };\n          }\n\n          this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n\n          this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);\n        });\n      } else {\n        this.currentScope().__referencing(node.left, Reference.RW, node.right);\n      }\n    } else {\n      this.visit(node.left);\n    }\n\n    this.visit(node.right);\n  }\n\n  CatchClause(node) {\n    this.scopeManager.__nestCatchScope(node);\n\n    this.visitPattern(node.param, {\n      processRightHandNodes: true\n    }, (pattern, info) => {\n      this.currentScope().__define(pattern, new Definition(Variable.CatchClause, node.param, node, null, null, null));\n\n      this.referencingDefaultValue(pattern, info.assignments, null, true);\n    });\n    this.visit(node.body);\n    this.close(node);\n  }\n\n  Program(node) {\n    this.scopeManager.__nestGlobalScope(node);\n\n    if (this.scopeManager.__isNodejsScope()) {\n      // Force strictness of GlobalScope to false when using node.js scope.\n      this.currentScope().isStrict = false;\n\n      this.scopeManager.__nestFunctionScope(node, false);\n    }\n\n    if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {\n      this.scopeManager.__nestModuleScope(node);\n    }\n\n    if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {\n      this.currentScope().isStrict = true;\n    }\n\n    this.visitChildren(node);\n    this.close(node);\n  }\n\n  Identifier(node) {\n    this.currentScope().__referencing(node);\n  }\n\n  UpdateExpression(node) {\n    if (PatternVisitor.isPattern(node.argument)) {\n      this.currentScope().__referencing(node.argument, Reference.RW, null);\n    } else {\n      this.visitChildren(node);\n    }\n  }\n\n  MemberExpression(node) {\n    this.visit(node.object);\n\n    if (node.computed) {\n      this.visit(node.property);\n    }\n  }\n\n  Property(node) {\n    this.visitProperty(node);\n  }\n\n  MethodDefinition(node) {\n    this.visitProperty(node);\n  }\n\n  BreakStatement() {} // eslint-disable-line class-methods-use-this\n\n\n  ContinueStatement() {} // eslint-disable-line class-methods-use-this\n\n\n  LabeledStatement(node) {\n    this.visit(node.body);\n  }\n\n  ForStatement(node) {\n    // Create ForStatement declaration.\n    // NOTE: In ES6, ForStatement dynamically generates\n    // per iteration environment. However, escope is\n    // a static analyzer, we only generate one scope for ForStatement.\n    if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== \"var\") {\n      this.scopeManager.__nestForScope(node);\n    }\n\n    this.visitChildren(node);\n    this.close(node);\n  }\n\n  ClassExpression(node) {\n    this.visitClass(node);\n  }\n\n  ClassDeclaration(node) {\n    this.visitClass(node);\n  }\n\n  CallExpression(node) {\n    // Check this is direct call to eval\n    if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === \"eval\") {\n      // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and\n      // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.\n      this.currentScope().variableScope.__detectEval();\n    }\n\n    this.visitChildren(node);\n  }\n\n  BlockStatement(node) {\n    if (this.scopeManager.__isES6()) {\n      this.scopeManager.__nestBlockScope(node);\n    }\n\n    this.visitChildren(node);\n    this.close(node);\n  }\n\n  ThisExpression() {\n    this.currentScope().variableScope.__detectThis();\n  }\n\n  WithStatement(node) {\n    this.visit(node.object); // Then nest scope for WithStatement.\n\n    this.scopeManager.__nestWithScope(node);\n\n    this.visit(node.body);\n    this.close(node);\n  }\n\n  VariableDeclaration(node) {\n    const variableTargetScope = node.kind === \"var\" ? this.currentScope().variableScope : this.currentScope();\n\n    for (let i = 0, iz = node.declarations.length; i < iz; ++i) {\n      const decl = node.declarations[i];\n      this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);\n\n      if (decl.init) {\n        this.visit(decl.init);\n      }\n    }\n  } // sec 13.11.8\n\n\n  SwitchStatement(node) {\n    this.visit(node.discriminant);\n\n    if (this.scopeManager.__isES6()) {\n      this.scopeManager.__nestSwitchScope(node);\n    }\n\n    for (let i = 0, iz = node.cases.length; i < iz; ++i) {\n      this.visit(node.cases[i]);\n    }\n\n    this.close(node);\n  }\n\n  FunctionDeclaration(node) {\n    this.visitFunction(node);\n  }\n\n  FunctionExpression(node) {\n    this.visitFunction(node);\n  }\n\n  ForOfStatement(node) {\n    this.visitForIn(node);\n  }\n\n  ForInStatement(node) {\n    this.visitForIn(node);\n  }\n\n  ArrowFunctionExpression(node) {\n    this.visitFunction(node);\n  }\n\n  ImportDeclaration(node) {\n    assert(this.scopeManager.__isES6() && this.scopeManager.isModule(), \"ImportDeclaration should appear when the mode is ES6 and in the module context.\");\n    const importer = new Importer(node, this);\n    importer.visit(node);\n  }\n\n  visitExportDeclaration(node) {\n    if (node.source) {\n      return;\n    }\n\n    if (node.declaration) {\n      this.visit(node.declaration);\n      return;\n    }\n\n    this.visitChildren(node);\n  } // TODO: ExportDeclaration doesn't exist. for bc?\n\n\n  ExportDeclaration(node) {\n    this.visitExportDeclaration(node);\n  }\n\n  ExportAllDeclaration(node) {\n    this.visitExportDeclaration(node);\n  }\n\n  ExportDefaultDeclaration(node) {\n    this.visitExportDeclaration(node);\n  }\n\n  ExportNamedDeclaration(node) {\n    this.visitExportDeclaration(node);\n  }\n\n  ExportSpecifier(node) {\n    // TODO: `node.id` doesn't exist. for bc?\n    const local = node.id || node.local;\n    this.visit(local);\n  }\n\n  MetaProperty() {// eslint-disable-line class-methods-use-this\n    // do nothing.\n  }\n\n}\n\nmodule.exports = Referencer;\n/* vim: set sw=4 ts=4 et tw=80 : *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi9yZWZlcmVuY2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzbGludC1zY29wZS9saWIvcmVmZXJlbmNlci5qcz82OWY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxNSBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblwidXNlIHN0cmljdFwiO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkICovXG5cbmNvbnN0IFN5bnRheCA9IHJlcXVpcmUoXCJlc3RyYXZlcnNlXCIpLlN5bnRheDtcbmNvbnN0IGVzcmVjdXJzZSA9IHJlcXVpcmUoXCJlc3JlY3Vyc2VcIik7XG5jb25zdCBSZWZlcmVuY2UgPSByZXF1aXJlKFwiLi9yZWZlcmVuY2VcIik7XG5jb25zdCBWYXJpYWJsZSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlXCIpO1xuY29uc3QgUGF0dGVyblZpc2l0b3IgPSByZXF1aXJlKFwiLi9wYXR0ZXJuLXZpc2l0b3JcIik7XG5jb25zdCBkZWZpbml0aW9uID0gcmVxdWlyZShcIi4vZGVmaW5pdGlvblwiKTtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbmNvbnN0IFBhcmFtZXRlckRlZmluaXRpb24gPSBkZWZpbml0aW9uLlBhcmFtZXRlckRlZmluaXRpb247XG5jb25zdCBEZWZpbml0aW9uID0gZGVmaW5pdGlvbi5EZWZpbml0aW9uO1xuXG4vKipcbiAqIFRyYXZlcnNlIGlkZW50aWZpZXIgaW4gcGF0dGVyblxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zXG4gKiBAcGFyYW0ge3BhdHRlcm59IHJvb3RQYXR0ZXJuIC0gcm9vdCBwYXR0ZXJuXG4gKiBAcGFyYW0ge1JlZmVuY2VyfSByZWZlcmVuY2VyIC0gcmVmZXJlbmNlclxuICogQHBhcmFtIHtjYWxsYmFja30gY2FsbGJhY2sgLSBjYWxsYmFja1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlSWRlbnRpZmllckluUGF0dGVybihvcHRpb25zLCByb290UGF0dGVybiwgcmVmZXJlbmNlciwgY2FsbGJhY2spIHtcblxuICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIGF0IGxlZnQgaGFuZCBpZGVudGlmaWVyIG5vZGVzLCBhbmQgQ29sbGVjdCByaWdodCBoYW5kIG5vZGVzLlxuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgUGF0dGVyblZpc2l0b3Iob3B0aW9ucywgcm9vdFBhdHRlcm4sIGNhbGxiYWNrKTtcblxuICAgIHZpc2l0b3IudmlzaXQocm9vdFBhdHRlcm4pO1xuXG4gICAgLy8gUHJvY2VzcyB0aGUgcmlnaHQgaGFuZCBub2RlcyByZWN1cnNpdmVseS5cbiAgICBpZiAocmVmZXJlbmNlciAhPT0gbnVsbCAmJiByZWZlcmVuY2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmlzaXRvci5yaWdodEhhbmROb2Rlcy5mb3JFYWNoKHJlZmVyZW5jZXIudmlzaXQsIHJlZmVyZW5jZXIpO1xuICAgIH1cbn1cblxuLy8gSW1wb3J0aW5nIEltcG9ydERlY2xhcmF0aW9uLlxuLy8gaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtbW9kdWxlZGVjbGFyYXRpb25pbnN0YW50aWF0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZXN0cmVlL2VzdHJlZS9ibG9iL21hc3Rlci9lczYubWQjaW1wb3J0ZGVjbGFyYXRpb25cbi8vIEZJWE1FOiBOb3csIHdlIGRvbid0IGNyZWF0ZSBtb2R1bGUgZW52aXJvbm1lbnQsIGJlY2F1c2UgdGhlIGNvbnRleHQgaXNcbi8vIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudC5cblxuY2xhc3MgSW1wb3J0ZXIgZXh0ZW5kcyBlc3JlY3Vyc2UuVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoZGVjbGFyYXRpb24sIHJlZmVyZW5jZXIpIHtcbiAgICAgICAgc3VwZXIobnVsbCwgcmVmZXJlbmNlci5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbiA9IGRlY2xhcmF0aW9uO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXIgPSByZWZlcmVuY2VyO1xuICAgIH1cblxuICAgIHZpc2l0SW1wb3J0KGlkLCBzcGVjaWZpZXIpIHtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VyLnZpc2l0UGF0dGVybihpZCwgcGF0dGVybiA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZmVyZW5jZXIuY3VycmVudFNjb3BlKCkuX19kZWZpbmUocGF0dGVybixcbiAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICAgICAgVmFyaWFibGUuSW1wb3J0QmluZGluZyxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVyLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY2xhcmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsID0gKG5vZGUubG9jYWwgfHwgbm9kZS5pZCk7XG5cbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0SW1wb3J0KGxvY2FsLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSkge1xuICAgICAgICBjb25zdCBsb2NhbCA9IChub2RlLmxvY2FsIHx8IG5vZGUuaWQpO1xuXG4gICAgICAgIHRoaXMudmlzaXRJbXBvcnQobG9jYWwsIG5vZGUpO1xuICAgIH1cblxuICAgIEltcG9ydFNwZWNpZmllcihub2RlKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsID0gKG5vZGUubG9jYWwgfHwgbm9kZS5pZCk7XG5cbiAgICAgICAgaWYgKG5vZGUubmFtZSkge1xuICAgICAgICAgICAgdGhpcy52aXNpdEltcG9ydChub2RlLm5hbWUsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aXNpdEltcG9ydChsb2NhbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFJlZmVyZW5jaW5nIHZhcmlhYmxlcyBhbmQgY3JlYXRpbmcgYmluZGluZ3MuXG5jbGFzcyBSZWZlcmVuY2VyIGV4dGVuZHMgZXNyZWN1cnNlLlZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHNjb3BlTWFuYWdlcikge1xuICAgICAgICBzdXBlcihudWxsLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIgPSBzY29wZU1hbmFnZXI7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0lubmVyTWV0aG9kRGVmaW5pdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGN1cnJlbnRTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGVNYW5hZ2VyLl9fY3VycmVudFNjb3BlO1xuICAgIH1cblxuICAgIGNsb3NlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VycmVudFNjb3BlKCkgJiYgbm9kZSA9PT0gdGhpcy5jdXJyZW50U2NvcGUoKS5ibG9jaykge1xuICAgICAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19jdXJyZW50U2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpLl9fY2xvc2UodGhpcy5zY29wZU1hbmFnZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVzaElubmVyTWV0aG9kRGVmaW5pdGlvbihpc0lubmVyTWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuaXNJbm5lck1ldGhvZERlZmluaXRpb247XG5cbiAgICAgICAgdGhpcy5pc0lubmVyTWV0aG9kRGVmaW5pdGlvbiA9IGlzSW5uZXJNZXRob2REZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuXG4gICAgcG9wSW5uZXJNZXRob2REZWZpbml0aW9uKGlzSW5uZXJNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuaXNJbm5lck1ldGhvZERlZmluaXRpb24gPSBpc0lubmVyTWV0aG9kRGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICByZWZlcmVuY2luZ0RlZmF1bHRWYWx1ZShwYXR0ZXJuLCBhc3NpZ25tZW50cywgbWF5YmVJbXBsaWNpdEdsb2JhbCwgaW5pdCkge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG5cbiAgICAgICAgYXNzaWdubWVudHMuZm9yRWFjaChhc3NpZ25tZW50ID0+IHtcbiAgICAgICAgICAgIHNjb3BlLl9fcmVmZXJlbmNpbmcoXG4gICAgICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgICAgICBSZWZlcmVuY2UuV1JJVEUsXG4gICAgICAgICAgICAgICAgYXNzaWdubWVudC5yaWdodCxcbiAgICAgICAgICAgICAgICBtYXliZUltcGxpY2l0R2xvYmFsLFxuICAgICAgICAgICAgICAgIHBhdHRlcm4gIT09IGFzc2lnbm1lbnQubGVmdCxcbiAgICAgICAgICAgICAgICBpbml0XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2aXNpdFBhdHRlcm4obm9kZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IHZpc2l0UGF0dGVybk9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBsZXQgdmlzaXRQYXR0ZXJuQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmlzaXRQYXR0ZXJuQ2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICAgICAgdmlzaXRQYXR0ZXJuT3B0aW9ucyA9IHsgcHJvY2Vzc1JpZ2h0SGFuZE5vZGVzOiBmYWxzZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhdmVyc2VJZGVudGlmaWVySW5QYXR0ZXJuKFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHZpc2l0UGF0dGVybk9wdGlvbnMucHJvY2Vzc1JpZ2h0SGFuZE5vZGVzID8gdGhpcyA6IG51bGwsXG4gICAgICAgICAgICB2aXNpdFBhdHRlcm5DYWxsYmFja1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHZpc2l0RnVuY3Rpb24obm9kZSkge1xuICAgICAgICBsZXQgaSwgaXo7XG5cbiAgICAgICAgLy8gRnVuY3Rpb25EZWNsYXJhdGlvbiBuYW1lIGlzIGRlZmluZWQgaW4gdXBwZXIgc2NvcGVcbiAgICAgICAgLy8gTk9URTogTm90IHJlZmVycmluZyB2YXJpYWJsZVNjb3BlLiBJdCBpcyBpbnRlbmRlZC5cbiAgICAgICAgLy8gU2luY2VcbiAgICAgICAgLy8gIGluIEVTNSwgRnVuY3Rpb25EZWNsYXJhdGlvbiBzaG91bGQgYmUgaW4gRnVuY3Rpb25Cb2R5LlxuICAgICAgICAvLyAgaW4gRVM2LCBGdW5jdGlvbkRlY2xhcmF0aW9uIHNob3VsZCBiZSBibG9jayBzY29wZWQuXG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcblxuICAgICAgICAgICAgLy8gaWQgaXMgZGVmaW5lZCBpbiB1cHBlciBzY29wZVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX2RlZmluZShub2RlLmlkLFxuICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICBWYXJpYWJsZS5GdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZ1bmN0aW9uRXhwcmVzc2lvbiB3aXRoIG5hbWUgY3JlYXRlcyBpdHMgc3BlY2lhbCBzY29wZTtcbiAgICAgICAgLy8gRnVuY3Rpb25FeHByZXNzaW9uTmFtZVNjb3BlLlxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uICYmIG5vZGUuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnNpZGVyIHRoaXMgZnVuY3Rpb24gaXMgaW4gdGhlIE1ldGhvZERlZmluaXRpb24uXG4gICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdEZ1bmN0aW9uU2NvcGUobm9kZSwgdGhpcy5pc0lubmVyTWV0aG9kRGVmaW5pdGlvbik7XG5cbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpc2l0IHBhdHRlcm4gY2FsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHtwYXR0ZXJufSBwYXR0ZXJuIC0gcGF0dGVyblxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIGluZm9cbiAgICAgICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB2aXNpdFBhdHRlcm5DYWxsYmFjayhwYXR0ZXJuLCBpbmZvKSB7XG4gICAgICAgICAgICB0aGF0LmN1cnJlbnRTY29wZSgpLl9fZGVmaW5lKHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbmV3IFBhcmFtZXRlckRlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGluZm8ucmVzdFxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICB0aGF0LnJlZmVyZW5jaW5nRGVmYXVsdFZhbHVlKHBhdHRlcm4sIGluZm8uYXNzaWdubWVudHMsIG51bGwsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvY2VzcyBwYXJhbWV0ZXIgZGVjbGFyYXRpb25zLlxuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IG5vZGUucGFyYW1zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRQYXR0ZXJuKG5vZGUucGFyYW1zW2ldLCB7IHByb2Nlc3NSaWdodEhhbmROb2RlczogdHJ1ZSB9LCB2aXNpdFBhdHRlcm5DYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcmVzdCBhcmd1bWVudCwgYWRkIHRoYXRcbiAgICAgICAgaWYgKG5vZGUucmVzdCkge1xuICAgICAgICAgICAgdGhpcy52aXNpdFBhdHRlcm4oe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiUmVzdEVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBhcmd1bWVudDogbm9kZS5yZXN0XG4gICAgICAgICAgICB9LCBwYXR0ZXJuID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fZGVmaW5lKHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQYXJhbWV0ZXJEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmFtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiBUeXBlU2NyaXB0IHRoZXJlIGFyZSBhIG51bWJlciBvZiBmdW5jdGlvbi1saWtlIGNvbnN0cnVjdHMgd2hpY2ggaGF2ZSBubyBib2R5LFxuICAgICAgICAvLyBzbyBjaGVjayBpdCBleGlzdHMgYmVmb3JlIHRyYXZlcnNpbmdcbiAgICAgICAgaWYgKG5vZGUuYm9keSkge1xuXG4gICAgICAgICAgICAvLyBTa2lwIEJsb2NrU3RhdGVtZW50IHRvIHByZXZlbnQgY3JlYXRpbmcgQmxvY2tTdGF0ZW1lbnQgc2NvcGUuXG4gICAgICAgICAgICBpZiAobm9kZS5ib2R5LnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRDaGlsZHJlbihub2RlLmJvZHkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUuYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb3NlKG5vZGUpO1xuICAgIH1cblxuICAgIHZpc2l0Q2xhc3Mobm9kZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQ2xhc3NEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX2RlZmluZShub2RlLmlkLFxuICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICBWYXJpYWJsZS5DbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5zdXBlckNsYXNzKTtcblxuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RDbGFzc1Njb3BlKG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlLmlkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fZGVmaW5lKG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIFZhcmlhYmxlLkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5ib2R5KTtcblxuICAgICAgICB0aGlzLmNsb3NlKG5vZGUpO1xuICAgIH1cblxuICAgIHZpc2l0UHJvcGVydHkobm9kZSkge1xuICAgICAgICBsZXQgcHJldmlvdXM7XG5cbiAgICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNNZXRob2REZWZpbml0aW9uID0gbm9kZS50eXBlID09PSBTeW50YXguTWV0aG9kRGVmaW5pdGlvbjtcblxuICAgICAgICBpZiAoaXNNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgICAgICBwcmV2aW91cyA9IHRoaXMucHVzaElubmVyTWV0aG9kRGVmaW5pdGlvbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0KG5vZGUudmFsdWUpO1xuICAgICAgICBpZiAoaXNNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBvcElubmVyTWV0aG9kRGVmaW5pdGlvbihwcmV2aW91cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2aXNpdEZvckluKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSBTeW50YXguVmFyaWFibGVEZWNsYXJhdGlvbiAmJiBub2RlLmxlZnQua2luZCAhPT0gXCJ2YXJcIikge1xuICAgICAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19uZXN0Rm9yU2NvcGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUubGVmdCk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihub2RlLmxlZnQuZGVjbGFyYXRpb25zWzBdLmlkLCBwYXR0ZXJuID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fcmVmZXJlbmNpbmcocGF0dGVybiwgUmVmZXJlbmNlLldSSVRFLCBub2RlLnJpZ2h0LCBudWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aXNpdFBhdHRlcm4obm9kZS5sZWZ0LCB7IHByb2Nlc3NSaWdodEhhbmROb2RlczogdHJ1ZSB9LCAocGF0dGVybiwgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtYXliZUltcGxpY2l0R2xvYmFsID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50U2NvcGUoKS5pc1N0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZUltcGxpY2l0R2xvYmFsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2luZ0RlZmF1bHRWYWx1ZShwYXR0ZXJuLCBpbmZvLmFzc2lnbm1lbnRzLCBtYXliZUltcGxpY2l0R2xvYmFsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX3JlZmVyZW5jaW5nKHBhdHRlcm4sIFJlZmVyZW5jZS5XUklURSwgbm9kZS5yaWdodCwgbWF5YmVJbXBsaWNpdEdsb2JhbCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdChub2RlLnJpZ2h0KTtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuXG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgdmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uKHZhcmlhYmxlVGFyZ2V0U2NvcGUsIHR5cGUsIG5vZGUsIGluZGV4KSB7XG5cbiAgICAgICAgY29uc3QgZGVjbCA9IG5vZGUuZGVjbGFyYXRpb25zW2luZGV4XTtcbiAgICAgICAgY29uc3QgaW5pdCA9IGRlY2wuaW5pdDtcblxuICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihkZWNsLmlkLCB7IHByb2Nlc3NSaWdodEhhbmROb2RlczogdHJ1ZSB9LCAocGF0dGVybiwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdmFyaWFibGVUYXJnZXRTY29wZS5fX2RlZmluZShcbiAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBkZWNsLFxuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5raW5kXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2luZ0RlZmF1bHRWYWx1ZShwYXR0ZXJuLCBpbmZvLmFzc2lnbm1lbnRzLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX3JlZmVyZW5jaW5nKHBhdHRlcm4sIFJlZmVyZW5jZS5XUklURSwgaW5pdCwgbnVsbCwgIWluZm8udG9wTGV2ZWwsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIGlmIChQYXR0ZXJuVmlzaXRvci5pc1BhdHRlcm4obm9kZS5sZWZ0KSkge1xuICAgICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdFBhdHRlcm4obm9kZS5sZWZ0LCB7IHByb2Nlc3NSaWdodEhhbmROb2RlczogdHJ1ZSB9LCAocGF0dGVybiwgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF5YmVJbXBsaWNpdEdsb2JhbCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRTY29wZSgpLmlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZUltcGxpY2l0R2xvYmFsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jaW5nRGVmYXVsdFZhbHVlKHBhdHRlcm4sIGluZm8uYXNzaWdubWVudHMsIG1heWJlSW1wbGljaXRHbG9iYWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX3JlZmVyZW5jaW5nKHBhdHRlcm4sIFJlZmVyZW5jZS5XUklURSwgbm9kZS5yaWdodCwgbWF5YmVJbXBsaWNpdEdsb2JhbCwgIWluZm8udG9wTGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX3JlZmVyZW5jaW5nKG5vZGUubGVmdCwgUmVmZXJlbmNlLlJXLCBub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0KG5vZGUucmlnaHQpO1xuICAgIH1cblxuICAgIENhdGNoQ2xhdXNlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19uZXN0Q2F0Y2hTY29wZShub2RlKTtcblxuICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihub2RlLnBhcmFtLCB7IHByb2Nlc3NSaWdodEhhbmROb2RlczogdHJ1ZSB9LCAocGF0dGVybiwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX2RlZmluZShwYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICBWYXJpYWJsZS5DYXRjaENsYXVzZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJhbSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2luZ0RlZmF1bHRWYWx1ZShwYXR0ZXJuLCBpbmZvLmFzc2lnbm1lbnRzLCBudWxsLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5ib2R5KTtcblxuICAgICAgICB0aGlzLmNsb3NlKG5vZGUpO1xuICAgIH1cblxuICAgIFByb2dyYW0obm9kZSkge1xuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RHbG9iYWxTY29wZShub2RlKTtcblxuICAgICAgICBpZiAodGhpcy5zY29wZU1hbmFnZXIuX19pc05vZGVqc1Njb3BlKCkpIHtcblxuICAgICAgICAgICAgLy8gRm9yY2Ugc3RyaWN0bmVzcyBvZiBHbG9iYWxTY29wZSB0byBmYWxzZSB3aGVuIHVzaW5nIG5vZGUuanMgc2NvcGUuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLmlzU3RyaWN0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RGdW5jdGlvblNjb3BlKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNjb3BlTWFuYWdlci5fX2lzRVM2KCkgJiYgdGhpcy5zY29wZU1hbmFnZXIuaXNNb2R1bGUoKSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19uZXN0TW9kdWxlU2NvcGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zY29wZU1hbmFnZXIuaXNTdHJpY3RNb2RlU3VwcG9ydGVkKCkgJiYgdGhpcy5zY29wZU1hbmFnZXIuaXNJbXBsaWVkU3RyaWN0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuaXNTdHJpY3QgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKG5vZGUpO1xuICAgICAgICB0aGlzLmNsb3NlKG5vZGUpO1xuICAgIH1cblxuICAgIElkZW50aWZpZXIobm9kZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fcmVmZXJlbmNpbmcobm9kZSk7XG4gICAgfVxuXG4gICAgVXBkYXRlRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIGlmIChQYXR0ZXJuVmlzaXRvci5pc1BhdHRlcm4obm9kZS5hcmd1bWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19yZWZlcmVuY2luZyhub2RlLmFyZ3VtZW50LCBSZWZlcmVuY2UuUlcsIG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5vYmplY3QpO1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgICAgICAgdGhpcy52aXNpdChub2RlLnByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFByb3BlcnR5KG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdFByb3BlcnR5KG5vZGUpO1xuICAgIH1cblxuICAgIE1ldGhvZERlZmluaXRpb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0UHJvcGVydHkobm9kZSk7XG4gICAgfVxuXG4gICAgQnJlYWtTdGF0ZW1lbnQoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcblxuICAgIENvbnRpbnVlU3RhdGVtZW50KCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG5cbiAgICBMYWJlbGVkU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuICAgIH1cblxuICAgIEZvclN0YXRlbWVudChub2RlKSB7XG5cbiAgICAgICAgLy8gQ3JlYXRlIEZvclN0YXRlbWVudCBkZWNsYXJhdGlvbi5cbiAgICAgICAgLy8gTk9URTogSW4gRVM2LCBGb3JTdGF0ZW1lbnQgZHluYW1pY2FsbHkgZ2VuZXJhdGVzXG4gICAgICAgIC8vIHBlciBpdGVyYXRpb24gZW52aXJvbm1lbnQuIEhvd2V2ZXIsIGVzY29wZSBpc1xuICAgICAgICAvLyBhIHN0YXRpYyBhbmFseXplciwgd2Ugb25seSBnZW5lcmF0ZSBvbmUgc2NvcGUgZm9yIEZvclN0YXRlbWVudC5cbiAgICAgICAgaWYgKG5vZGUuaW5pdCAmJiBub2RlLmluaXQudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24gJiYgbm9kZS5pbml0LmtpbmQgIT09IFwidmFyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdEZvclNjb3BlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKG5vZGUpO1xuXG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgQ2xhc3NFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdENsYXNzKG5vZGUpO1xuICAgIH1cblxuICAgIENsYXNzRGVjbGFyYXRpb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0Q2xhc3Mobm9kZSk7XG4gICAgfVxuXG4gICAgQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuXG4gICAgICAgIC8vIENoZWNrIHRoaXMgaXMgZGlyZWN0IGNhbGwgdG8gZXZhbFxuICAgICAgICBpZiAoIXRoaXMuc2NvcGVNYW5hZ2VyLl9faWdub3JlRXZhbCgpICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIG5vZGUuY2FsbGVlLm5hbWUgPT09IFwiZXZhbFwiKSB7XG5cbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgc2hvdWxkIGJlIGB2YXJpYWJsZVNjb3BlYC4gU2luY2UgZGlyZWN0IGV2YWwgY2FsbCBhbHdheXMgY3JlYXRlcyBMZXhpY2FsIGVudmlyb25tZW50IGFuZFxuICAgICAgICAgICAgLy8gbGV0IC8gY29uc3Qgc2hvdWxkIGJlIGVuY2xvc2VkIGludG8gaXQuIE9ubHkgVmFyaWFibGVEZWNsYXJhdGlvbiBhZmZlY3RzIG9uIHRoZSBjYWxsZXIncyBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkudmFyaWFibGVTY29wZS5fX2RldGVjdEV2YWwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG4gICAgfVxuXG4gICAgQmxvY2tTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICBpZiAodGhpcy5zY29wZU1hbmFnZXIuX19pc0VTNigpKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RCbG9ja1Njb3BlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKG5vZGUpO1xuXG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgVGhpc0V4cHJlc3Npb24oKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkudmFyaWFibGVTY29wZS5fX2RldGVjdFRoaXMoKTtcbiAgICB9XG5cbiAgICBXaXRoU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLm9iamVjdCk7XG5cbiAgICAgICAgLy8gVGhlbiBuZXN0IHNjb3BlIGZvciBXaXRoU3RhdGVtZW50LlxuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RXaXRoU2NvcGUobm9kZSk7XG5cbiAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuXG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlVGFyZ2V0U2NvcGUgPSAobm9kZS5raW5kID09PSBcInZhclwiKSA/IHRoaXMuY3VycmVudFNjb3BlKCkudmFyaWFibGVTY29wZSA6IHRoaXMuY3VycmVudFNjb3BlKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGl6ID0gbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZGVjbCA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuXG4gICAgICAgICAgICB0aGlzLnZpc2l0VmFyaWFibGVEZWNsYXJhdGlvbih2YXJpYWJsZVRhcmdldFNjb3BlLCBWYXJpYWJsZS5WYXJpYWJsZSwgbm9kZSwgaSk7XG4gICAgICAgICAgICBpZiAoZGVjbC5pbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdChkZWNsLmluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2VjIDEzLjExLjhcbiAgICBTd2l0Y2hTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0KG5vZGUuZGlzY3JpbWluYW50KTtcblxuICAgICAgICBpZiAodGhpcy5zY29wZU1hbmFnZXIuX19pc0VTNigpKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RTd2l0Y2hTY29wZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpeiA9IG5vZGUuY2FzZXMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgdGhpcy52aXNpdChub2RlLmNhc2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbihub2RlKTtcbiAgICB9XG5cbiAgICBGdW5jdGlvbkV4cHJlc3Npb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0RnVuY3Rpb24obm9kZSk7XG4gICAgfVxuXG4gICAgRm9yT2ZTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0Rm9ySW4obm9kZSk7XG4gICAgfVxuXG4gICAgRm9ySW5TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0Rm9ySW4obm9kZSk7XG4gICAgfVxuXG4gICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0RnVuY3Rpb24obm9kZSk7XG4gICAgfVxuXG4gICAgSW1wb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICAgICAgICBhc3NlcnQodGhpcy5zY29wZU1hbmFnZXIuX19pc0VTNigpICYmIHRoaXMuc2NvcGVNYW5hZ2VyLmlzTW9kdWxlKCksIFwiSW1wb3J0RGVjbGFyYXRpb24gc2hvdWxkIGFwcGVhciB3aGVuIHRoZSBtb2RlIGlzIEVTNiBhbmQgaW4gdGhlIG1vZHVsZSBjb250ZXh0LlwiKTtcblxuICAgICAgICBjb25zdCBpbXBvcnRlciA9IG5ldyBJbXBvcnRlcihub2RlLCB0aGlzKTtcblxuICAgICAgICBpbXBvcnRlci52aXNpdChub2RlKTtcbiAgICB9XG5cbiAgICB2aXNpdEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5kZWNsYXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogRXhwb3J0RGVjbGFyYXRpb24gZG9lc24ndCBleGlzdC4gZm9yIGJjP1xuICAgIEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMudmlzaXRFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG5cbiAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIEV4cG9ydFNwZWNpZmllcihub2RlKSB7XG5cbiAgICAgICAgLy8gVE9ETzogYG5vZGUuaWRgIGRvZXNuJ3QgZXhpc3QuIGZvciBiYz9cbiAgICAgICAgY29uc3QgbG9jYWwgPSAobm9kZS5pZCB8fCBub2RlLmxvY2FsKTtcblxuICAgICAgICB0aGlzLnZpc2l0KGxvY2FsKTtcbiAgICB9XG5cbiAgICBNZXRhUHJvcGVydHkoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuXG4gICAgICAgIC8vIGRvIG5vdGhpbmcuXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlZmVyZW5jZXI7XG5cbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1Q0E7QUFDQTtBQUNBO0FBNkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVNBO0FBR0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVdBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBL2ZBO0FBQ0E7QUFnZ0JBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/eslint-scope/lib/referencer.js\n");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/scope-manager.js":
/*!********************************************************!*\
  !*** ./node_modules/eslint-scope/lib/scope-manager.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\nconst Scope = __webpack_require__(/*! ./scope */ \"./node_modules/eslint-scope/lib/scope.js\");\n\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\");\n\nconst GlobalScope = Scope.GlobalScope;\nconst CatchScope = Scope.CatchScope;\nconst WithScope = Scope.WithScope;\nconst ModuleScope = Scope.ModuleScope;\nconst ClassScope = Scope.ClassScope;\nconst SwitchScope = Scope.SwitchScope;\nconst FunctionScope = Scope.FunctionScope;\nconst ForScope = Scope.ForScope;\nconst FunctionExpressionNameScope = Scope.FunctionExpressionNameScope;\nconst BlockScope = Scope.BlockScope;\n/**\n * @class ScopeManager\n */\n\nclass ScopeManager {\n  constructor(options) {\n    this.scopes = [];\n    this.globalScope = null;\n    this.__nodeToScope = new WeakMap();\n    this.__currentScope = null;\n    this.__options = options;\n    this.__declaredVariables = new WeakMap();\n  }\n\n  __useDirective() {\n    return this.__options.directive;\n  }\n\n  __isOptimistic() {\n    return this.__options.optimistic;\n  }\n\n  __ignoreEval() {\n    return this.__options.ignoreEval;\n  }\n\n  __isNodejsScope() {\n    return this.__options.nodejsScope;\n  }\n\n  isModule() {\n    return this.__options.sourceType === \"module\";\n  }\n\n  isImpliedStrict() {\n    return this.__options.impliedStrict;\n  }\n\n  isStrictModeSupported() {\n    return this.__options.ecmaVersion >= 5;\n  } // Returns appropriate scope for this node.\n\n\n  __get(node) {\n    return this.__nodeToScope.get(node);\n  }\n  /**\n   * Get variables that are declared by the node.\n   *\n   * \"are declared by the node\" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.\n   * If the node declares nothing, this method returns an empty array.\n   * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.\n   *\n   * @param {Espree.Node} node - a node to get.\n   * @returns {Variable[]} variables that declared by the node.\n   */\n\n\n  getDeclaredVariables(node) {\n    return this.__declaredVariables.get(node) || [];\n  }\n  /**\n   * acquire scope from node.\n   * @method ScopeManager#acquire\n   * @param {Espree.Node} node - node for the acquired scope.\n   * @param {boolean=} inner - look up the most inner scope, default value is false.\n   * @returns {Scope?} Scope from node\n   */\n\n\n  acquire(node, inner) {\n    /**\n     * predicate\n     * @param {Scope} testScope - scope to test\n     * @returns {boolean} predicate\n     */\n    function predicate(testScope) {\n      if (testScope.type === \"function\" && testScope.functionExpressionScope) {\n        return false;\n      }\n\n      return true;\n    }\n\n    const scopes = this.__get(node);\n\n    if (!scopes || scopes.length === 0) {\n      return null;\n    } // Heuristic selection from all scopes.\n    // If you would like to get all scopes, please use ScopeManager#acquireAll.\n\n\n    if (scopes.length === 1) {\n      return scopes[0];\n    }\n\n    if (inner) {\n      for (let i = scopes.length - 1; i >= 0; --i) {\n        const scope = scopes[i];\n\n        if (predicate(scope)) {\n          return scope;\n        }\n      }\n    } else {\n      for (let i = 0, iz = scopes.length; i < iz; ++i) {\n        const scope = scopes[i];\n\n        if (predicate(scope)) {\n          return scope;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * acquire all scopes from node.\n   * @method ScopeManager#acquireAll\n   * @param {Espree.Node} node - node for the acquired scope.\n   * @returns {Scopes?} Scope array\n   */\n\n\n  acquireAll(node) {\n    return this.__get(node);\n  }\n  /**\n   * release the node.\n   * @method ScopeManager#release\n   * @param {Espree.Node} node - releasing node.\n   * @param {boolean=} inner - look up the most inner scope, default value is false.\n   * @returns {Scope?} upper scope for the node.\n   */\n\n\n  release(node, inner) {\n    const scopes = this.__get(node);\n\n    if (scopes && scopes.length) {\n      const scope = scopes[0].upper;\n\n      if (!scope) {\n        return null;\n      }\n\n      return this.acquire(scope.block, inner);\n    }\n\n    return null;\n  }\n\n  attach() {} // eslint-disable-line class-methods-use-this\n\n\n  detach() {} // eslint-disable-line class-methods-use-this\n\n\n  __nestScope(scope) {\n    if (scope instanceof GlobalScope) {\n      assert(this.__currentScope === null);\n      this.globalScope = scope;\n    }\n\n    this.__currentScope = scope;\n    return scope;\n  }\n\n  __nestGlobalScope(node) {\n    return this.__nestScope(new GlobalScope(this, node));\n  }\n\n  __nestBlockScope(node) {\n    return this.__nestScope(new BlockScope(this, this.__currentScope, node));\n  }\n\n  __nestFunctionScope(node, isMethodDefinition) {\n    return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));\n  }\n\n  __nestForScope(node) {\n    return this.__nestScope(new ForScope(this, this.__currentScope, node));\n  }\n\n  __nestCatchScope(node) {\n    return this.__nestScope(new CatchScope(this, this.__currentScope, node));\n  }\n\n  __nestWithScope(node) {\n    return this.__nestScope(new WithScope(this, this.__currentScope, node));\n  }\n\n  __nestClassScope(node) {\n    return this.__nestScope(new ClassScope(this, this.__currentScope, node));\n  }\n\n  __nestSwitchScope(node) {\n    return this.__nestScope(new SwitchScope(this, this.__currentScope, node));\n  }\n\n  __nestModuleScope(node) {\n    return this.__nestScope(new ModuleScope(this, this.__currentScope, node));\n  }\n\n  __nestFunctionExpressionNameScope(node) {\n    return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));\n  }\n\n  __isES6() {\n    return this.__options.ecmaVersion >= 6;\n  }\n\n}\n\nmodule.exports = ScopeManager;\n/* vim: set sw=4 ts=4 et tw=80 : *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi9zY29wZS1tYW5hZ2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzbGludC1zY29wZS9saWIvc2NvcGUtbWFuYWdlci5qcz9jZGQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxNSBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblwidXNlIHN0cmljdFwiO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuXG5jb25zdCBTY29wZSA9IHJlcXVpcmUoXCIuL3Njb3BlXCIpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcblxuY29uc3QgR2xvYmFsU2NvcGUgPSBTY29wZS5HbG9iYWxTY29wZTtcbmNvbnN0IENhdGNoU2NvcGUgPSBTY29wZS5DYXRjaFNjb3BlO1xuY29uc3QgV2l0aFNjb3BlID0gU2NvcGUuV2l0aFNjb3BlO1xuY29uc3QgTW9kdWxlU2NvcGUgPSBTY29wZS5Nb2R1bGVTY29wZTtcbmNvbnN0IENsYXNzU2NvcGUgPSBTY29wZS5DbGFzc1Njb3BlO1xuY29uc3QgU3dpdGNoU2NvcGUgPSBTY29wZS5Td2l0Y2hTY29wZTtcbmNvbnN0IEZ1bmN0aW9uU2NvcGUgPSBTY29wZS5GdW5jdGlvblNjb3BlO1xuY29uc3QgRm9yU2NvcGUgPSBTY29wZS5Gb3JTY29wZTtcbmNvbnN0IEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZSA9IFNjb3BlLkZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZTtcbmNvbnN0IEJsb2NrU2NvcGUgPSBTY29wZS5CbG9ja1Njb3BlO1xuXG4vKipcbiAqIEBjbGFzcyBTY29wZU1hbmFnZXJcbiAqL1xuY2xhc3MgU2NvcGVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2NvcGVzID0gW107XG4gICAgICAgIHRoaXMuZ2xvYmFsU2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9fbm9kZVRvU2NvcGUgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9fY3VycmVudFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9fZGVjbGFyZWRWYXJpYWJsZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cblxuICAgIF9fdXNlRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMuZGlyZWN0aXZlO1xuICAgIH1cblxuICAgIF9faXNPcHRpbWlzdGljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMub3B0aW1pc3RpYztcbiAgICB9XG5cbiAgICBfX2lnbm9yZUV2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3B0aW9ucy5pZ25vcmVFdmFsO1xuICAgIH1cblxuICAgIF9faXNOb2RlanNTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19vcHRpb25zLm5vZGVqc1Njb3BlO1xuICAgIH1cblxuICAgIGlzTW9kdWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgICB9XG5cbiAgICBpc0ltcGxpZWRTdHJpY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3B0aW9ucy5pbXBsaWVkU3RyaWN0O1xuICAgIH1cblxuICAgIGlzU3RyaWN0TW9kZVN1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19vcHRpb25zLmVjbWFWZXJzaW9uID49IDU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyBhcHByb3ByaWF0ZSBzY29wZSBmb3IgdGhpcyBub2RlLlxuICAgIF9fZ2V0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19ub2RlVG9TY29wZS5nZXQobm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHZhcmlhYmxlcyB0aGF0IGFyZSBkZWNsYXJlZCBieSB0aGUgbm9kZS5cbiAgICAgKlxuICAgICAqIFwiYXJlIGRlY2xhcmVkIGJ5IHRoZSBub2RlXCIgbWVhbnMgdGhlIG5vZGUgaXMgc2FtZSBhcyBgVmFyaWFibGUuZGVmc1tdLm5vZGVgIG9yIGBWYXJpYWJsZS5kZWZzW10ucGFyZW50YC5cbiAgICAgKiBJZiB0aGUgbm9kZSBkZWNsYXJlcyBub3RoaW5nLCB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxuICAgICAqIENBVVRJT046IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3Rvb2xzL2VzY29wZS9wdWxsLzY5IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VzcHJlZS5Ob2RlfSBub2RlIC0gYSBub2RlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7VmFyaWFibGVbXX0gdmFyaWFibGVzIHRoYXQgZGVjbGFyZWQgYnkgdGhlIG5vZGUuXG4gICAgICovXG4gICAgZ2V0RGVjbGFyZWRWYXJpYWJsZXMobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2RlY2xhcmVkVmFyaWFibGVzLmdldChub2RlKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhY3F1aXJlIHNjb3BlIGZyb20gbm9kZS5cbiAgICAgKiBAbWV0aG9kIFNjb3BlTWFuYWdlciNhY3F1aXJlXG4gICAgICogQHBhcmFtIHtFc3ByZWUuTm9kZX0gbm9kZSAtIG5vZGUgZm9yIHRoZSBhY3F1aXJlZCBzY29wZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbm5lciAtIGxvb2sgdXAgdGhlIG1vc3QgaW5uZXIgc2NvcGUsIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXG4gICAgICogQHJldHVybnMge1Njb3BlP30gU2NvcGUgZnJvbSBub2RlXG4gICAgICovXG4gICAgYWNxdWlyZShub2RlLCBpbm5lcikge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmVkaWNhdGVcbiAgICAgICAgICogQHBhcmFtIHtTY29wZX0gdGVzdFNjb3BlIC0gc2NvcGUgdG8gdGVzdFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcHJlZGljYXRlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBwcmVkaWNhdGUodGVzdFNjb3BlKSB7XG4gICAgICAgICAgICBpZiAodGVzdFNjb3BlLnR5cGUgPT09IFwiZnVuY3Rpb25cIiAmJiB0ZXN0U2NvcGUuZnVuY3Rpb25FeHByZXNzaW9uU2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMuX19nZXQobm9kZSk7XG5cbiAgICAgICAgaWYgKCFzY29wZXMgfHwgc2NvcGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIZXVyaXN0aWMgc2VsZWN0aW9uIGZyb20gYWxsIHNjb3Blcy5cbiAgICAgICAgLy8gSWYgeW91IHdvdWxkIGxpa2UgdG8gZ2V0IGFsbCBzY29wZXMsIHBsZWFzZSB1c2UgU2NvcGVNYW5hZ2VyI2FjcXVpcmVBbGwuXG4gICAgICAgIGlmIChzY29wZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc2NvcGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NvcGUgPSBzY29wZXNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGl6ID0gc2NvcGVzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY29wZSA9IHNjb3Blc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhY3F1aXJlIGFsbCBzY29wZXMgZnJvbSBub2RlLlxuICAgICAqIEBtZXRob2QgU2NvcGVNYW5hZ2VyI2FjcXVpcmVBbGxcbiAgICAgKiBAcGFyYW0ge0VzcHJlZS5Ob2RlfSBub2RlIC0gbm9kZSBmb3IgdGhlIGFjcXVpcmVkIHNjb3BlLlxuICAgICAqIEByZXR1cm5zIHtTY29wZXM/fSBTY29wZSBhcnJheVxuICAgICAqL1xuICAgIGFjcXVpcmVBbGwobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2dldChub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZWxlYXNlIHRoZSBub2RlLlxuICAgICAqIEBtZXRob2QgU2NvcGVNYW5hZ2VyI3JlbGVhc2VcbiAgICAgKiBAcGFyYW0ge0VzcHJlZS5Ob2RlfSBub2RlIC0gcmVsZWFzaW5nIG5vZGUuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5uZXIgLSBsb29rIHVwIHRoZSBtb3N0IGlubmVyIHNjb3BlLCBkZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxuICAgICAqIEByZXR1cm5zIHtTY29wZT99IHVwcGVyIHNjb3BlIGZvciB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICByZWxlYXNlKG5vZGUsIGlubmVyKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMuX19nZXQobm9kZSk7XG5cbiAgICAgICAgaWYgKHNjb3BlcyAmJiBzY29wZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzY29wZSA9IHNjb3Blc1swXS51cHBlcjtcblxuICAgICAgICAgICAgaWYgKCFzY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWNxdWlyZShzY29wZS5ibG9jaywgaW5uZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGF0dGFjaCgpIHsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcblxuICAgIGRldGFjaCgpIHsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcblxuICAgIF9fbmVzdFNjb3BlKHNjb3BlKSB7XG4gICAgICAgIGlmIChzY29wZSBpbnN0YW5jZW9mIEdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5fX2N1cnJlbnRTY29wZSA9PT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbFNjb3BlID0gc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2N1cnJlbnRTY29wZSA9IHNjb3BlO1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuXG4gICAgX19uZXN0R2xvYmFsU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgR2xvYmFsU2NvcGUodGhpcywgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdEJsb2NrU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgQmxvY2tTY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19uZXN0RnVuY3Rpb25TY29wZShub2RlLCBpc01ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19uZXN0U2NvcGUobmV3IEZ1bmN0aW9uU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSwgaXNNZXRob2REZWZpbml0aW9uKSk7XG4gICAgfVxuXG4gICAgX19uZXN0Rm9yU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgRm9yU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdENhdGNoU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgQ2F0Y2hTY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19uZXN0V2l0aFNjb3BlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19uZXN0U2NvcGUobmV3IFdpdGhTY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19uZXN0Q2xhc3NTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBDbGFzc1Njb3BlKHRoaXMsIHRoaXMuX19jdXJyZW50U2NvcGUsIG5vZGUpKTtcbiAgICB9XG5cbiAgICBfX25lc3RTd2l0Y2hTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBTd2l0Y2hTY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19uZXN0TW9kdWxlU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgTW9kdWxlU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBGdW5jdGlvbkV4cHJlc3Npb25OYW1lU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9faXNFUzYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTY29wZU1hbmFnZXI7XG5cbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRNQTtBQUNBO0FBdU1BO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/eslint-scope/lib/scope-manager.js\n");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/scope.js":
/*!************************************************!*\
  !*** ./node_modules/eslint-scope/lib/scope.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable no-undefined */\n\nconst Syntax = __webpack_require__(/*! estraverse */ \"./node_modules/estraverse/estraverse.js\").Syntax;\n\nconst Reference = __webpack_require__(/*! ./reference */ \"./node_modules/eslint-scope/lib/reference.js\");\n\nconst Variable = __webpack_require__(/*! ./variable */ \"./node_modules/eslint-scope/lib/variable.js\");\n\nconst Definition = __webpack_require__(/*! ./definition */ \"./node_modules/eslint-scope/lib/definition.js\").Definition;\n\nconst assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\");\n/**\n * Test if scope is struct\n * @param {Scope} scope - scope\n * @param {Block} block - block\n * @param {boolean} isMethodDefinition - is method definition\n * @param {boolean} useDirective - use directive\n * @returns {boolean} is strict scope\n */\n\n\nfunction isStrictScope(scope, block, isMethodDefinition, useDirective) {\n  let body; // When upper scope is exists and strict, inner scope is also strict.\n\n  if (scope.upper && scope.upper.isStrict) {\n    return true;\n  }\n\n  if (isMethodDefinition) {\n    return true;\n  }\n\n  if (scope.type === \"class\" || scope.type === \"module\") {\n    return true;\n  }\n\n  if (scope.type === \"block\" || scope.type === \"switch\") {\n    return false;\n  }\n\n  if (scope.type === \"function\") {\n    if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement) {\n      return false;\n    }\n\n    if (block.type === Syntax.Program) {\n      body = block;\n    } else {\n      body = block.body;\n    }\n\n    if (!body) {\n      return false;\n    }\n  } else if (scope.type === \"global\") {\n    body = block;\n  } else {\n    return false;\n  } // Search 'use strict' directive.\n\n\n  if (useDirective) {\n    for (let i = 0, iz = body.body.length; i < iz; ++i) {\n      const stmt = body.body[i];\n\n      if (stmt.type !== Syntax.DirectiveStatement) {\n        break;\n      }\n\n      if (stmt.raw === \"\\\"use strict\\\"\" || stmt.raw === \"'use strict'\") {\n        return true;\n      }\n    }\n  } else {\n    for (let i = 0, iz = body.body.length; i < iz; ++i) {\n      const stmt = body.body[i];\n\n      if (stmt.type !== Syntax.ExpressionStatement) {\n        break;\n      }\n\n      const expr = stmt.expression;\n\n      if (expr.type !== Syntax.Literal || typeof expr.value !== \"string\") {\n        break;\n      }\n\n      if (expr.raw !== null && expr.raw !== undefined) {\n        if (expr.raw === \"\\\"use strict\\\"\" || expr.raw === \"'use strict'\") {\n          return true;\n        }\n      } else {\n        if (expr.value === \"use strict\") {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Register scope\n * @param {ScopeManager} scopeManager - scope manager\n * @param {Scope} scope - scope\n * @returns {void}\n */\n\n\nfunction registerScope(scopeManager, scope) {\n  scopeManager.scopes.push(scope);\n\n  const scopes = scopeManager.__nodeToScope.get(scope.block);\n\n  if (scopes) {\n    scopes.push(scope);\n  } else {\n    scopeManager.__nodeToScope.set(scope.block, [scope]);\n  }\n}\n/**\n * Should be statically\n * @param {Object} def - def\n * @returns {boolean} should be statically\n */\n\n\nfunction shouldBeStatically(def) {\n  return def.type === Variable.ClassName || def.type === Variable.Variable && def.parent.kind !== \"var\";\n}\n/**\n * @class Scope\n */\n\n\nclass Scope {\n  constructor(scopeManager, type, upperScope, block, isMethodDefinition) {\n    /**\n     * One of 'module', 'block', 'switch', 'function', 'catch', 'with', 'function', 'class', 'global'.\n     * @member {String} Scope#type\n     */\n    this.type = type;\n    /**\n     * The scoped {@link Variable}s of this scope, as <code>{ Variable.name\n     * : Variable }</code>.\n     * @member {Map} Scope#set\n     */\n\n    this.set = new Map();\n    /**\n     * The tainted variables of this scope, as <code>{ Variable.name :\n     * boolean }</code>.\n     * @member {Map} Scope#taints */\n\n    this.taints = new Map();\n    /**\n     * Generally, through the lexical scoping of JS you can always know\n     * which variable an identifier in the source code refers to. There are\n     * a few exceptions to this rule. With 'global' and 'with' scopes you\n     * can only decide at runtime which variable a reference refers to.\n     * Moreover, if 'eval()' is used in a scope, it might introduce new\n     * bindings in this or its parent scopes.\n     * All those scopes are considered 'dynamic'.\n     * @member {boolean} Scope#dynamic\n     */\n\n    this.dynamic = this.type === \"global\" || this.type === \"with\";\n    /**\n     * A reference to the scope-defining syntax node.\n     * @member {espree.Node} Scope#block\n     */\n\n    this.block = block;\n    /**\n     * The {@link Reference|references} that are not resolved with this scope.\n     * @member {Reference[]} Scope#through\n     */\n\n    this.through = [];\n    /**\n     * The scoped {@link Variable}s of this scope. In the case of a\n     * 'function' scope this includes the automatic argument <em>arguments</em> as\n     * its first element, as well as all further formal arguments.\n     * @member {Variable[]} Scope#variables\n     */\n\n    this.variables = [];\n    /**\n     * Any variable {@link Reference|reference} found in this scope. This\n     * includes occurrences of local variables as well as variables from\n     * parent scopes (including the global scope). For local variables\n     * this also includes defining occurrences (like in a 'var' statement).\n     * In a 'function' scope this does not include the occurrences of the\n     * formal parameter in the parameter list.\n     * @member {Reference[]} Scope#references\n     */\n\n    this.references = [];\n    /**\n     * For 'global' and 'function' scopes, this is a self-reference. For\n     * other scope types this is the <em>variableScope</em> value of the\n     * parent scope.\n     * @member {Scope} Scope#variableScope\n     */\n\n    this.variableScope = this.type === \"global\" || this.type === \"function\" || this.type === \"module\" ? this : upperScope.variableScope;\n    /**\n     * Whether this scope is created by a FunctionExpression.\n     * @member {boolean} Scope#functionExpressionScope\n     */\n\n    this.functionExpressionScope = false;\n    /**\n     * Whether this is a scope that contains an 'eval()' invocation.\n     * @member {boolean} Scope#directCallToEvalScope\n     */\n\n    this.directCallToEvalScope = false;\n    /**\n     * @member {boolean} Scope#thisFound\n     */\n\n    this.thisFound = false;\n    this.__left = [];\n    /**\n     * Reference to the parent {@link Scope|scope}.\n     * @member {Scope} Scope#upper\n     */\n\n    this.upper = upperScope;\n    /**\n     * Whether 'use strict' is in effect in this scope.\n     * @member {boolean} Scope#isStrict\n     */\n\n    this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());\n    /**\n     * List of nested {@link Scope}s.\n     * @member {Scope[]} Scope#childScopes\n     */\n\n    this.childScopes = [];\n\n    if (this.upper) {\n      this.upper.childScopes.push(this);\n    }\n\n    this.__declaredVariables = scopeManager.__declaredVariables;\n    registerScope(scopeManager, this);\n  }\n\n  __shouldStaticallyClose(scopeManager) {\n    return !this.dynamic || scopeManager.__isOptimistic();\n  }\n\n  __shouldStaticallyCloseForGlobal(ref) {\n    // On global scope, let/const/class declarations should be resolved statically.\n    const name = ref.identifier.name;\n\n    if (!this.set.has(name)) {\n      return false;\n    }\n\n    const variable = this.set.get(name);\n    const defs = variable.defs;\n    return defs.length > 0 && defs.every(shouldBeStatically);\n  }\n\n  __staticCloseRef(ref) {\n    if (!this.__resolve(ref)) {\n      this.__delegateToUpperScope(ref);\n    }\n  }\n\n  __dynamicCloseRef(ref) {\n    // notify all names are through to global\n    let current = this;\n\n    do {\n      current.through.push(ref);\n      current = current.upper;\n    } while (current);\n  }\n\n  __globalCloseRef(ref) {\n    // let/const/class declarations should be resolved statically.\n    // others should be resolved dynamically.\n    if (this.__shouldStaticallyCloseForGlobal(ref)) {\n      this.__staticCloseRef(ref);\n    } else {\n      this.__dynamicCloseRef(ref);\n    }\n  }\n\n  __close(scopeManager) {\n    let closeRef;\n\n    if (this.__shouldStaticallyClose(scopeManager)) {\n      closeRef = this.__staticCloseRef;\n    } else if (this.type !== \"global\") {\n      closeRef = this.__dynamicCloseRef;\n    } else {\n      closeRef = this.__globalCloseRef;\n    } // Try Resolving all references in this scope.\n\n\n    for (let i = 0, iz = this.__left.length; i < iz; ++i) {\n      const ref = this.__left[i];\n      closeRef.call(this, ref);\n    }\n\n    this.__left = null;\n    return this.upper;\n  } // To override by function scopes.\n  // References in default parameters isn't resolved to variables which are in their function body.\n\n\n  __isValidResolution(ref, variable) {\n    // eslint-disable-line class-methods-use-this, no-unused-vars\n    return true;\n  }\n\n  __resolve(ref) {\n    const name = ref.identifier.name;\n\n    if (!this.set.has(name)) {\n      return false;\n    }\n\n    const variable = this.set.get(name);\n\n    if (!this.__isValidResolution(ref, variable)) {\n      return false;\n    }\n\n    variable.references.push(ref);\n    variable.stack = variable.stack && ref.from.variableScope === this.variableScope;\n\n    if (ref.tainted) {\n      variable.tainted = true;\n      this.taints.set(variable.name, true);\n    }\n\n    ref.resolved = variable;\n    return true;\n  }\n\n  __delegateToUpperScope(ref) {\n    if (this.upper) {\n      this.upper.__left.push(ref);\n    }\n\n    this.through.push(ref);\n  }\n\n  __addDeclaredVariablesOfNode(variable, node) {\n    if (node === null || node === undefined) {\n      return;\n    }\n\n    let variables = this.__declaredVariables.get(node);\n\n    if (variables === null || variables === undefined) {\n      variables = [];\n\n      this.__declaredVariables.set(node, variables);\n    }\n\n    if (variables.indexOf(variable) === -1) {\n      variables.push(variable);\n    }\n  }\n\n  __defineGeneric(name, set, variables, node, def) {\n    let variable;\n    variable = set.get(name);\n\n    if (!variable) {\n      variable = new Variable(name, this);\n      set.set(name, variable);\n      variables.push(variable);\n    }\n\n    if (def) {\n      variable.defs.push(def);\n\n      this.__addDeclaredVariablesOfNode(variable, def.node);\n\n      this.__addDeclaredVariablesOfNode(variable, def.parent);\n    }\n\n    if (node) {\n      variable.identifiers.push(node);\n    }\n  }\n\n  __define(node, def) {\n    if (node && node.type === Syntax.Identifier) {\n      this.__defineGeneric(node.name, this.set, this.variables, node, def);\n    }\n  }\n\n  __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {\n    // because Array element may be null\n    if (!node || node.type !== Syntax.Identifier) {\n      return;\n    } // Specially handle like `this`.\n\n\n    if (node.name === \"super\") {\n      return;\n    }\n\n    const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);\n    this.references.push(ref);\n\n    this.__left.push(ref);\n  }\n\n  __detectEval() {\n    let current = this;\n    this.directCallToEvalScope = true;\n\n    do {\n      current.dynamic = true;\n      current = current.upper;\n    } while (current);\n  }\n\n  __detectThis() {\n    this.thisFound = true;\n  }\n\n  __isClosed() {\n    return this.__left === null;\n  }\n  /**\n   * returns resolved {Reference}\n   * @method Scope#resolve\n   * @param {Espree.Identifier} ident - identifier to be resolved.\n   * @returns {Reference} reference\n   */\n\n\n  resolve(ident) {\n    let ref, i, iz;\n    assert(this.__isClosed(), \"Scope should be closed.\");\n    assert(ident.type === Syntax.Identifier, \"Target should be identifier.\");\n\n    for (i = 0, iz = this.references.length; i < iz; ++i) {\n      ref = this.references[i];\n\n      if (ref.identifier === ident) {\n        return ref;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * returns this scope is static\n   * @method Scope#isStatic\n   * @returns {boolean} static\n   */\n\n\n  isStatic() {\n    return !this.dynamic;\n  }\n  /**\n   * returns this scope has materialized arguments\n   * @method Scope#isArgumentsMaterialized\n   * @returns {boolean} arguemnts materialized\n   */\n\n\n  isArgumentsMaterialized() {\n    // eslint-disable-line class-methods-use-this\n    return true;\n  }\n  /**\n   * returns this scope has materialized `this` reference\n   * @method Scope#isThisMaterialized\n   * @returns {boolean} this materialized\n   */\n\n\n  isThisMaterialized() {\n    // eslint-disable-line class-methods-use-this\n    return true;\n  }\n\n  isUsedName(name) {\n    if (this.set.has(name)) {\n      return true;\n    }\n\n    for (let i = 0, iz = this.through.length; i < iz; ++i) {\n      if (this.through[i].identifier.name === name) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass GlobalScope extends Scope {\n  constructor(scopeManager, block) {\n    super(scopeManager, \"global\", null, block, false);\n    this.implicit = {\n      set: new Map(),\n      variables: [],\n\n      /**\n      * List of {@link Reference}s that are left to be resolved (i.e. which\n      * need to be linked to the variable they refer to).\n      * @member {Reference[]} Scope#implicit#left\n      */\n      left: []\n    };\n  }\n\n  __close(scopeManager) {\n    const implicit = [];\n\n    for (let i = 0, iz = this.__left.length; i < iz; ++i) {\n      const ref = this.__left[i];\n\n      if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {\n        implicit.push(ref.__maybeImplicitGlobal);\n      }\n    } // create an implicit global variable from assignment expression\n\n\n    for (let i = 0, iz = implicit.length; i < iz; ++i) {\n      const info = implicit[i];\n\n      this.__defineImplicit(info.pattern, new Definition(Variable.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));\n    }\n\n    this.implicit.left = this.__left;\n    return super.__close(scopeManager);\n  }\n\n  __defineImplicit(node, def) {\n    if (node && node.type === Syntax.Identifier) {\n      this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);\n    }\n  }\n\n}\n\nclass ModuleScope extends Scope {\n  constructor(scopeManager, upperScope, block) {\n    super(scopeManager, \"module\", upperScope, block, false);\n  }\n\n}\n\nclass FunctionExpressionNameScope extends Scope {\n  constructor(scopeManager, upperScope, block) {\n    super(scopeManager, \"function-expression-name\", upperScope, block, false);\n\n    this.__define(block.id, new Definition(Variable.FunctionName, block.id, block, null, null, null));\n\n    this.functionExpressionScope = true;\n  }\n\n}\n\nclass CatchScope extends Scope {\n  constructor(scopeManager, upperScope, block) {\n    super(scopeManager, \"catch\", upperScope, block, false);\n  }\n\n}\n\nclass WithScope extends Scope {\n  constructor(scopeManager, upperScope, block) {\n    super(scopeManager, \"with\", upperScope, block, false);\n  }\n\n  __close(scopeManager) {\n    if (this.__shouldStaticallyClose(scopeManager)) {\n      return super.__close(scopeManager);\n    }\n\n    for (let i = 0, iz = this.__left.length; i < iz; ++i) {\n      const ref = this.__left[i];\n      ref.tainted = true;\n\n      this.__delegateToUpperScope(ref);\n    }\n\n    this.__left = null;\n    return this.upper;\n  }\n\n}\n\nclass BlockScope extends Scope {\n  constructor(scopeManager, upperScope, block) {\n    super(scopeManager, \"block\", upperScope, block, false);\n  }\n\n}\n\nclass SwitchScope extends Scope {\n  constructor(scopeManager, upperScope, block) {\n    super(scopeManager, \"switch\", upperScope, block, false);\n  }\n\n}\n\nclass FunctionScope extends Scope {\n  constructor(scopeManager, upperScope, block, isMethodDefinition) {\n    super(scopeManager, \"function\", upperScope, block, isMethodDefinition); // section 9.2.13, FunctionDeclarationInstantiation.\n    // NOTE Arrow functions never have an arguments objects.\n\n    if (this.block.type !== Syntax.ArrowFunctionExpression) {\n      this.__defineArguments();\n    }\n  }\n\n  isArgumentsMaterialized() {\n    // TODO(Constellation)\n    // We can more aggressive on this condition like this.\n    //\n    // function t() {\n    //     // arguments of t is always hidden.\n    //     function arguments() {\n    //     }\n    // }\n    if (this.block.type === Syntax.ArrowFunctionExpression) {\n      return false;\n    }\n\n    if (!this.isStatic()) {\n      return true;\n    }\n\n    const variable = this.set.get(\"arguments\");\n    assert(variable, \"Always have arguments variable.\");\n    return variable.tainted || variable.references.length !== 0;\n  }\n\n  isThisMaterialized() {\n    if (!this.isStatic()) {\n      return true;\n    }\n\n    return this.thisFound;\n  }\n\n  __defineArguments() {\n    this.__defineGeneric(\"arguments\", this.set, this.variables, null, null);\n\n    this.taints.set(\"arguments\", true);\n  } // References in default parameters isn't resolved to variables which are in their function body.\n  //     const x = 1\n  //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.\n  //         const x = 2\n  //         console.log(a)\n  //     }\n\n\n  __isValidResolution(ref, variable) {\n    // If `options.nodejsScope` is true, `this.block` becomes a Program node.\n    if (this.block.type === \"Program\") {\n      return true;\n    }\n\n    const bodyStart = this.block.body.range[0]; // It's invalid resolution in the following case:\n\n    return !(variable.scope === this && ref.identifier.range[0] < bodyStart && // the reference is in the parameter part.\n    variable.defs.every(d => d.name.range[0] >= bodyStart) // the variable is in the body.\n    );\n  }\n\n}\n\nclass ForScope extends Scope {\n  constructor(scopeManager, upperScope, block) {\n    super(scopeManager, \"for\", upperScope, block, false);\n  }\n\n}\n\nclass ClassScope extends Scope {\n  constructor(scopeManager, upperScope, block) {\n    super(scopeManager, \"class\", upperScope, block, false);\n  }\n\n}\n\nmodule.exports = {\n  Scope,\n  GlobalScope,\n  ModuleScope,\n  FunctionExpressionNameScope,\n  CatchScope,\n  WithScope,\n  BlockScope,\n  SwitchScope,\n  FunctionScope,\n  ForScope,\n  ClassScope\n};\n/* vim: set sw=4 ts=4 et tw=80 : *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi9zY29wZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc2xpbnQtc2NvcGUvbGliL3Njb3BlLmpzPzRiYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDE1IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cblxuY29uc3QgU3ludGF4ID0gcmVxdWlyZShcImVzdHJhdmVyc2VcIikuU3ludGF4O1xuXG5jb25zdCBSZWZlcmVuY2UgPSByZXF1aXJlKFwiLi9yZWZlcmVuY2VcIik7XG5jb25zdCBWYXJpYWJsZSA9IHJlcXVpcmUoXCIuL3ZhcmlhYmxlXCIpO1xuY29uc3QgRGVmaW5pdGlvbiA9IHJlcXVpcmUoXCIuL2RlZmluaXRpb25cIikuRGVmaW5pdGlvbjtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbi8qKlxuICogVGVzdCBpZiBzY29wZSBpcyBzdHJ1Y3RcbiAqIEBwYXJhbSB7U2NvcGV9IHNjb3BlIC0gc2NvcGVcbiAqIEBwYXJhbSB7QmxvY2t9IGJsb2NrIC0gYmxvY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNZXRob2REZWZpbml0aW9uIC0gaXMgbWV0aG9kIGRlZmluaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlRGlyZWN0aXZlIC0gdXNlIGRpcmVjdGl2ZVxuICogQHJldHVybnMge2Jvb2xlYW59IGlzIHN0cmljdCBzY29wZVxuICovXG5mdW5jdGlvbiBpc1N0cmljdFNjb3BlKHNjb3BlLCBibG9jaywgaXNNZXRob2REZWZpbml0aW9uLCB1c2VEaXJlY3RpdmUpIHtcbiAgICBsZXQgYm9keTtcblxuICAgIC8vIFdoZW4gdXBwZXIgc2NvcGUgaXMgZXhpc3RzIGFuZCBzdHJpY3QsIGlubmVyIHNjb3BlIGlzIGFsc28gc3RyaWN0LlxuICAgIGlmIChzY29wZS51cHBlciAmJiBzY29wZS51cHBlci5pc1N0cmljdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzY29wZS50eXBlID09PSBcImNsYXNzXCIgfHwgc2NvcGUudHlwZSA9PT0gXCJtb2R1bGVcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUudHlwZSA9PT0gXCJibG9ja1wiIHx8IHNjb3BlLnR5cGUgPT09IFwic3dpdGNoXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzY29wZS50eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT09IFN5bnRheC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiAmJiBibG9jay5ib2R5LnR5cGUgIT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT09IFN5bnRheC5Qcm9ncmFtKSB7XG4gICAgICAgICAgICBib2R5ID0gYmxvY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gYmxvY2suYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZS50eXBlID09PSBcImdsb2JhbFwiKSB7XG4gICAgICAgIGJvZHkgPSBibG9jaztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUuXG4gICAgaWYgKHVzZURpcmVjdGl2ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaXogPSBib2R5LmJvZHkubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGJvZHkuYm9keVtpXTtcblxuICAgICAgICAgICAgaWYgKHN0bXQudHlwZSAhPT0gU3ludGF4LkRpcmVjdGl2ZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0bXQucmF3ID09PSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIlwiIHx8IHN0bXQucmF3ID09PSBcIid1c2Ugc3RyaWN0J1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaXogPSBib2R5LmJvZHkubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGJvZHkuYm9keVtpXTtcblxuICAgICAgICAgICAgaWYgKHN0bXQudHlwZSAhPT0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBzdG10LmV4cHJlc3Npb247XG5cbiAgICAgICAgICAgIGlmIChleHByLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsIHx8IHR5cGVvZiBleHByLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwci5yYXcgIT09IG51bGwgJiYgZXhwci5yYXcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChleHByLnJhdyA9PT0gXCJcXFwidXNlIHN0cmljdFxcXCJcIiB8fCBleHByLnJhdyA9PT0gXCIndXNlIHN0cmljdCdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSBcInVzZSBzdHJpY3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHNjb3BlXG4gKiBAcGFyYW0ge1Njb3BlTWFuYWdlcn0gc2NvcGVNYW5hZ2VyIC0gc2NvcGUgbWFuYWdlclxuICogQHBhcmFtIHtTY29wZX0gc2NvcGUgLSBzY29wZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyU2NvcGUoc2NvcGVNYW5hZ2VyLCBzY29wZSkge1xuICAgIHNjb3BlTWFuYWdlci5zY29wZXMucHVzaChzY29wZSk7XG5cbiAgICBjb25zdCBzY29wZXMgPSBzY29wZU1hbmFnZXIuX19ub2RlVG9TY29wZS5nZXQoc2NvcGUuYmxvY2spO1xuXG4gICAgaWYgKHNjb3Blcykge1xuICAgICAgICBzY29wZXMucHVzaChzY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGVNYW5hZ2VyLl9fbm9kZVRvU2NvcGUuc2V0KHNjb3BlLmJsb2NrLCBbc2NvcGVdKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIHN0YXRpY2FsbHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWYgLSBkZWZcbiAqIEByZXR1cm5zIHtib29sZWFufSBzaG91bGQgYmUgc3RhdGljYWxseVxuICovXG5mdW5jdGlvbiBzaG91bGRCZVN0YXRpY2FsbHkoZGVmKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgKGRlZi50eXBlID09PSBWYXJpYWJsZS5DbGFzc05hbWUpIHx8XG4gICAgICAgIChkZWYudHlwZSA9PT0gVmFyaWFibGUuVmFyaWFibGUgJiYgZGVmLnBhcmVudC5raW5kICE9PSBcInZhclwiKVxuICAgICk7XG59XG5cbi8qKlxuICogQGNsYXNzIFNjb3BlXG4gKi9cbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHR5cGUsIHVwcGVyU2NvcGUsIGJsb2NrLCBpc01ldGhvZERlZmluaXRpb24pIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT25lIG9mICdtb2R1bGUnLCAnYmxvY2snLCAnc3dpdGNoJywgJ2Z1bmN0aW9uJywgJ2NhdGNoJywgJ3dpdGgnLCAnZnVuY3Rpb24nLCAnY2xhc3MnLCAnZ2xvYmFsJy5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBTY29wZSN0eXBlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NvcGVkIHtAbGluayBWYXJpYWJsZX1zIG9mIHRoaXMgc2NvcGUsIGFzIDxjb2RlPnsgVmFyaWFibGUubmFtZVxuICAgICAgICAgKiA6IFZhcmlhYmxlIH08L2NvZGU+LlxuICAgICAgICAgKiBAbWVtYmVyIHtNYXB9IFNjb3BlI3NldFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXQgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YWludGVkIHZhcmlhYmxlcyBvZiB0aGlzIHNjb3BlLCBhcyA8Y29kZT57IFZhcmlhYmxlLm5hbWUgOlxuICAgICAgICAgKiBib29sZWFuIH08L2NvZGU+LlxuICAgICAgICAgKiBAbWVtYmVyIHtNYXB9IFNjb3BlI3RhaW50cyAqL1xuICAgICAgICB0aGlzLnRhaW50cyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhbGx5LCB0aHJvdWdoIHRoZSBsZXhpY2FsIHNjb3Bpbmcgb2YgSlMgeW91IGNhbiBhbHdheXMga25vd1xuICAgICAgICAgKiB3aGljaCB2YXJpYWJsZSBhbiBpZGVudGlmaWVyIGluIHRoZSBzb3VyY2UgY29kZSByZWZlcnMgdG8uIFRoZXJlIGFyZVxuICAgICAgICAgKiBhIGZldyBleGNlcHRpb25zIHRvIHRoaXMgcnVsZS4gV2l0aCAnZ2xvYmFsJyBhbmQgJ3dpdGgnIHNjb3BlcyB5b3VcbiAgICAgICAgICogY2FuIG9ubHkgZGVjaWRlIGF0IHJ1bnRpbWUgd2hpY2ggdmFyaWFibGUgYSByZWZlcmVuY2UgcmVmZXJzIHRvLlxuICAgICAgICAgKiBNb3Jlb3ZlciwgaWYgJ2V2YWwoKScgaXMgdXNlZCBpbiBhIHNjb3BlLCBpdCBtaWdodCBpbnRyb2R1Y2UgbmV3XG4gICAgICAgICAqIGJpbmRpbmdzIGluIHRoaXMgb3IgaXRzIHBhcmVudCBzY29wZXMuXG4gICAgICAgICAqIEFsbCB0aG9zZSBzY29wZXMgYXJlIGNvbnNpZGVyZWQgJ2R5bmFtaWMnLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBTY29wZSNkeW5hbWljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmR5bmFtaWMgPSB0aGlzLnR5cGUgPT09IFwiZ2xvYmFsXCIgfHwgdGhpcy50eXBlID09PSBcIndpdGhcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHNjb3BlLWRlZmluaW5nIHN5bnRheCBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtlc3ByZWUuTm9kZX0gU2NvcGUjYmxvY2tcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHtAbGluayBSZWZlcmVuY2V8cmVmZXJlbmNlc30gdGhhdCBhcmUgbm90IHJlc29sdmVkIHdpdGggdGhpcyBzY29wZS5cbiAgICAgICAgICogQG1lbWJlciB7UmVmZXJlbmNlW119IFNjb3BlI3Rocm91Z2hcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhyb3VnaCA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2NvcGVkIHtAbGluayBWYXJpYWJsZX1zIG9mIHRoaXMgc2NvcGUuIEluIHRoZSBjYXNlIG9mIGFcbiAgICAgICAgICogJ2Z1bmN0aW9uJyBzY29wZSB0aGlzIGluY2x1ZGVzIHRoZSBhdXRvbWF0aWMgYXJndW1lbnQgPGVtPmFyZ3VtZW50czwvZW0+IGFzXG4gICAgICAgICAqIGl0cyBmaXJzdCBlbGVtZW50LCBhcyB3ZWxsIGFzIGFsbCBmdXJ0aGVyIGZvcm1hbCBhcmd1bWVudHMuXG4gICAgICAgICAqIEBtZW1iZXIge1ZhcmlhYmxlW119IFNjb3BlI3ZhcmlhYmxlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YXJpYWJsZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW55IHZhcmlhYmxlIHtAbGluayBSZWZlcmVuY2V8cmVmZXJlbmNlfSBmb3VuZCBpbiB0aGlzIHNjb3BlLiBUaGlzXG4gICAgICAgICAqIGluY2x1ZGVzIG9jY3VycmVuY2VzIG9mIGxvY2FsIHZhcmlhYmxlcyBhcyB3ZWxsIGFzIHZhcmlhYmxlcyBmcm9tXG4gICAgICAgICAqIHBhcmVudCBzY29wZXMgKGluY2x1ZGluZyB0aGUgZ2xvYmFsIHNjb3BlKS4gRm9yIGxvY2FsIHZhcmlhYmxlc1xuICAgICAgICAgKiB0aGlzIGFsc28gaW5jbHVkZXMgZGVmaW5pbmcgb2NjdXJyZW5jZXMgKGxpa2UgaW4gYSAndmFyJyBzdGF0ZW1lbnQpLlxuICAgICAgICAgKiBJbiBhICdmdW5jdGlvbicgc2NvcGUgdGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBvY2N1cnJlbmNlcyBvZiB0aGVcbiAgICAgICAgICogZm9ybWFsIHBhcmFtZXRlciBpbiB0aGUgcGFyYW1ldGVyIGxpc3QuXG4gICAgICAgICAqIEBtZW1iZXIge1JlZmVyZW5jZVtdfSBTY29wZSNyZWZlcmVuY2VzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yICdnbG9iYWwnIGFuZCAnZnVuY3Rpb24nIHNjb3BlcywgdGhpcyBpcyBhIHNlbGYtcmVmZXJlbmNlLiBGb3JcbiAgICAgICAgICogb3RoZXIgc2NvcGUgdHlwZXMgdGhpcyBpcyB0aGUgPGVtPnZhcmlhYmxlU2NvcGU8L2VtPiB2YWx1ZSBvZiB0aGVcbiAgICAgICAgICogcGFyZW50IHNjb3BlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTY29wZX0gU2NvcGUjdmFyaWFibGVTY29wZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YXJpYWJsZVNjb3BlID1cbiAgICAgICAgICAgICh0aGlzLnR5cGUgPT09IFwiZ2xvYmFsXCIgfHwgdGhpcy50eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgdGhpcy50eXBlID09PSBcIm1vZHVsZVwiKSA/IHRoaXMgOiB1cHBlclNjb3BlLnZhcmlhYmxlU2NvcGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBzY29wZSBpcyBjcmVhdGVkIGJ5IGEgRnVuY3Rpb25FeHByZXNzaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBTY29wZSNmdW5jdGlvbkV4cHJlc3Npb25TY29wZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mdW5jdGlvbkV4cHJlc3Npb25TY29wZSA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBzY29wZSB0aGF0IGNvbnRhaW5zIGFuICdldmFsKCknIGludm9jYXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IFNjb3BlI2RpcmVjdENhbGxUb0V2YWxTY29wZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJlY3RDYWxsVG9FdmFsU2NvcGUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gU2NvcGUjdGhpc0ZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRoaXNGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX19sZWZ0ID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHtAbGluayBTY29wZXxzY29wZX0uXG4gICAgICAgICAqIEBtZW1iZXIge1Njb3BlfSBTY29wZSN1cHBlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cHBlciA9IHVwcGVyU2NvcGU7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgJ3VzZSBzdHJpY3QnIGlzIGluIGVmZmVjdCBpbiB0aGlzIHNjb3BlLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBTY29wZSNpc1N0cmljdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1N0cmljdCA9IGlzU3RyaWN0U2NvcGUodGhpcywgYmxvY2ssIGlzTWV0aG9kRGVmaW5pdGlvbiwgc2NvcGVNYW5hZ2VyLl9fdXNlRGlyZWN0aXZlKCkpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIG5lc3RlZCB7QGxpbmsgU2NvcGV9cy5cbiAgICAgICAgICogQG1lbWJlciB7U2NvcGVbXX0gU2NvcGUjY2hpbGRTY29wZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRTY29wZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMudXBwZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBwZXIuY2hpbGRTY29wZXMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19kZWNsYXJlZFZhcmlhYmxlcyA9IHNjb3BlTWFuYWdlci5fX2RlY2xhcmVkVmFyaWFibGVzO1xuXG4gICAgICAgIHJlZ2lzdGVyU2NvcGUoc2NvcGVNYW5hZ2VyLCB0aGlzKTtcbiAgICB9XG5cbiAgICBfX3Nob3VsZFN0YXRpY2FsbHlDbG9zZShzY29wZU1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuICghdGhpcy5keW5hbWljIHx8IHNjb3BlTWFuYWdlci5fX2lzT3B0aW1pc3RpYygpKTtcbiAgICB9XG5cbiAgICBfX3Nob3VsZFN0YXRpY2FsbHlDbG9zZUZvckdsb2JhbChyZWYpIHtcblxuICAgICAgICAvLyBPbiBnbG9iYWwgc2NvcGUsIGxldC9jb25zdC9jbGFzcyBkZWNsYXJhdGlvbnMgc2hvdWxkIGJlIHJlc29sdmVkIHN0YXRpY2FsbHkuXG4gICAgICAgIGNvbnN0IG5hbWUgPSByZWYuaWRlbnRpZmllci5uYW1lO1xuXG4gICAgICAgIGlmICghdGhpcy5zZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuc2V0LmdldChuYW1lKTtcbiAgICAgICAgY29uc3QgZGVmcyA9IHZhcmlhYmxlLmRlZnM7XG5cbiAgICAgICAgcmV0dXJuIGRlZnMubGVuZ3RoID4gMCAmJiBkZWZzLmV2ZXJ5KHNob3VsZEJlU3RhdGljYWxseSk7XG4gICAgfVxuXG4gICAgX19zdGF0aWNDbG9zZVJlZihyZWYpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fcmVzb2x2ZShyZWYpKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVsZWdhdGVUb1VwcGVyU2NvcGUocmVmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9fZHluYW1pY0Nsb3NlUmVmKHJlZikge1xuXG4gICAgICAgIC8vIG5vdGlmeSBhbGwgbmFtZXMgYXJlIHRocm91Z2ggdG8gZ2xvYmFsXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjdXJyZW50LnRocm91Z2gucHVzaChyZWYpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQudXBwZXI7XG4gICAgICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuICAgIH1cblxuICAgIF9fZ2xvYmFsQ2xvc2VSZWYocmVmKSB7XG5cbiAgICAgICAgLy8gbGV0L2NvbnN0L2NsYXNzIGRlY2xhcmF0aW9ucyBzaG91bGQgYmUgcmVzb2x2ZWQgc3RhdGljYWxseS5cbiAgICAgICAgLy8gb3RoZXJzIHNob3VsZCBiZSByZXNvbHZlZCBkeW5hbWljYWxseS5cbiAgICAgICAgaWYgKHRoaXMuX19zaG91bGRTdGF0aWNhbGx5Q2xvc2VGb3JHbG9iYWwocmVmKSkge1xuICAgICAgICAgICAgdGhpcy5fX3N0YXRpY0Nsb3NlUmVmKHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fZHluYW1pY0Nsb3NlUmVmKHJlZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfX2Nsb3NlKHNjb3BlTWFuYWdlcikge1xuICAgICAgICBsZXQgY2xvc2VSZWY7XG5cbiAgICAgICAgaWYgKHRoaXMuX19zaG91bGRTdGF0aWNhbGx5Q2xvc2Uoc2NvcGVNYW5hZ2VyKSkge1xuICAgICAgICAgICAgY2xvc2VSZWYgPSB0aGlzLl9fc3RhdGljQ2xvc2VSZWY7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlICE9PSBcImdsb2JhbFwiKSB7XG4gICAgICAgICAgICBjbG9zZVJlZiA9IHRoaXMuX19keW5hbWljQ2xvc2VSZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbG9zZVJlZiA9IHRoaXMuX19nbG9iYWxDbG9zZVJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyeSBSZXNvbHZpbmcgYWxsIHJlZmVyZW5jZXMgaW4gdGhpcyBzY29wZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGl6ID0gdGhpcy5fX2xlZnQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5fX2xlZnRbaV07XG5cbiAgICAgICAgICAgIGNsb3NlUmVmLmNhbGwodGhpcywgcmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fbGVmdCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBwZXI7XG4gICAgfVxuXG4gICAgLy8gVG8gb3ZlcnJpZGUgYnkgZnVuY3Rpb24gc2NvcGVzLlxuICAgIC8vIFJlZmVyZW5jZXMgaW4gZGVmYXVsdCBwYXJhbWV0ZXJzIGlzbid0IHJlc29sdmVkIHRvIHZhcmlhYmxlcyB3aGljaCBhcmUgaW4gdGhlaXIgZnVuY3Rpb24gYm9keS5cbiAgICBfX2lzVmFsaWRSZXNvbHV0aW9uKHJlZiwgdmFyaWFibGUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzLCBuby11bnVzZWQtdmFyc1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfX3Jlc29sdmUocmVmKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSByZWYuaWRlbnRpZmllci5uYW1lO1xuXG4gICAgICAgIGlmICghdGhpcy5zZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFyaWFibGUgPSB0aGlzLnNldC5nZXQobmFtZSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9faXNWYWxpZFJlc29sdXRpb24ocmVmLCB2YXJpYWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXJpYWJsZS5yZWZlcmVuY2VzLnB1c2gocmVmKTtcbiAgICAgICAgdmFyaWFibGUuc3RhY2sgPSB2YXJpYWJsZS5zdGFjayAmJiByZWYuZnJvbS52YXJpYWJsZVNjb3BlID09PSB0aGlzLnZhcmlhYmxlU2NvcGU7XG4gICAgICAgIGlmIChyZWYudGFpbnRlZCkge1xuICAgICAgICAgICAgdmFyaWFibGUudGFpbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRhaW50cy5zZXQodmFyaWFibGUubmFtZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmLnJlc29sdmVkID0gdmFyaWFibGU7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX19kZWxlZ2F0ZVRvVXBwZXJTY29wZShyZWYpIHtcbiAgICAgICAgaWYgKHRoaXMudXBwZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBwZXIuX19sZWZ0LnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm91Z2gucHVzaChyZWYpO1xuICAgIH1cblxuICAgIF9fYWRkRGVjbGFyZWRWYXJpYWJsZXNPZk5vZGUodmFyaWFibGUsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmFyaWFibGVzID0gdGhpcy5fX2RlY2xhcmVkVmFyaWFibGVzLmdldChub2RlKTtcblxuICAgICAgICBpZiAodmFyaWFibGVzID09PSBudWxsIHx8IHZhcmlhYmxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX19kZWNsYXJlZFZhcmlhYmxlcy5zZXQobm9kZSwgdmFyaWFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFibGVzLmluZGV4T2YodmFyaWFibGUpID09PSAtMSkge1xuICAgICAgICAgICAgdmFyaWFibGVzLnB1c2godmFyaWFibGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX19kZWZpbmVHZW5lcmljKG5hbWUsIHNldCwgdmFyaWFibGVzLCBub2RlLCBkZWYpIHtcbiAgICAgICAgbGV0IHZhcmlhYmxlO1xuXG4gICAgICAgIHZhcmlhYmxlID0gc2V0LmdldChuYW1lKTtcbiAgICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICAgICAgdmFyaWFibGUgPSBuZXcgVmFyaWFibGUobmFtZSwgdGhpcyk7XG4gICAgICAgICAgICBzZXQuc2V0KG5hbWUsIHZhcmlhYmxlKTtcbiAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlLmRlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgdGhpcy5fX2FkZERlY2xhcmVkVmFyaWFibGVzT2ZOb2RlKHZhcmlhYmxlLCBkZWYubm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9fYWRkRGVjbGFyZWRWYXJpYWJsZXNPZk5vZGUodmFyaWFibGUsIGRlZi5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5pZGVudGlmaWVycy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX19kZWZpbmUobm9kZSwgZGVmKSB7XG4gICAgICAgIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX19kZWZpbmVHZW5lcmljKFxuICAgICAgICAgICAgICAgIG5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICB0aGlzLnNldCxcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGRlZlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9fcmVmZXJlbmNpbmcobm9kZSwgYXNzaWduLCB3cml0ZUV4cHIsIG1heWJlSW1wbGljaXRHbG9iYWwsIHBhcnRpYWwsIGluaXQpIHtcblxuICAgICAgICAvLyBiZWNhdXNlIEFycmF5IGVsZW1lbnQgbWF5IGJlIG51bGxcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNwZWNpYWxseSBoYW5kbGUgbGlrZSBgdGhpc2AuXG4gICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwic3VwZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmID0gbmV3IFJlZmVyZW5jZShub2RlLCB0aGlzLCBhc3NpZ24gfHwgUmVmZXJlbmNlLlJFQUQsIHdyaXRlRXhwciwgbWF5YmVJbXBsaWNpdEdsb2JhbCwgISFwYXJ0aWFsLCAhIWluaXQpO1xuXG4gICAgICAgIHRoaXMucmVmZXJlbmNlcy5wdXNoKHJlZik7XG4gICAgICAgIHRoaXMuX19sZWZ0LnB1c2gocmVmKTtcbiAgICB9XG5cbiAgICBfX2RldGVjdEV2YWwoKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcblxuICAgICAgICB0aGlzLmRpcmVjdENhbGxUb0V2YWxTY29wZSA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGN1cnJlbnQuZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC51cHBlcjtcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgfVxuXG4gICAgX19kZXRlY3RUaGlzKCkge1xuICAgICAgICB0aGlzLnRoaXNGb3VuZCA9IHRydWU7XG4gICAgfVxuXG4gICAgX19pc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19sZWZ0ID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgcmVzb2x2ZWQge1JlZmVyZW5jZX1cbiAgICAgKiBAbWV0aG9kIFNjb3BlI3Jlc29sdmVcbiAgICAgKiBAcGFyYW0ge0VzcHJlZS5JZGVudGlmaWVyfSBpZGVudCAtIGlkZW50aWZpZXIgdG8gYmUgcmVzb2x2ZWQuXG4gICAgICogQHJldHVybnMge1JlZmVyZW5jZX0gcmVmZXJlbmNlXG4gICAgICovXG4gICAgcmVzb2x2ZShpZGVudCkge1xuICAgICAgICBsZXQgcmVmLCBpLCBpejtcblxuICAgICAgICBhc3NlcnQodGhpcy5fX2lzQ2xvc2VkKCksIFwiU2NvcGUgc2hvdWxkIGJlIGNsb3NlZC5cIik7XG4gICAgICAgIGFzc2VydChpZGVudC50eXBlID09PSBTeW50YXguSWRlbnRpZmllciwgXCJUYXJnZXQgc2hvdWxkIGJlIGlkZW50aWZpZXIuXCIpO1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHRoaXMucmVmZXJlbmNlcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnJlZmVyZW5jZXNbaV07XG4gICAgICAgICAgICBpZiAocmVmLmlkZW50aWZpZXIgPT09IGlkZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoaXMgc2NvcGUgaXMgc3RhdGljXG4gICAgICogQG1ldGhvZCBTY29wZSNpc1N0YXRpY1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBzdGF0aWNcbiAgICAgKi9cbiAgICBpc1N0YXRpYygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmR5bmFtaWM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGlzIHNjb3BlIGhhcyBtYXRlcmlhbGl6ZWQgYXJndW1lbnRzXG4gICAgICogQG1ldGhvZCBTY29wZSNpc0FyZ3VtZW50c01hdGVyaWFsaXplZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBhcmd1ZW1udHMgbWF0ZXJpYWxpemVkXG4gICAgICovXG4gICAgaXNBcmd1bWVudHNNYXRlcmlhbGl6ZWQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoaXMgc2NvcGUgaGFzIG1hdGVyaWFsaXplZCBgdGhpc2AgcmVmZXJlbmNlXG4gICAgICogQG1ldGhvZCBTY29wZSNpc1RoaXNNYXRlcmlhbGl6ZWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGhpcyBtYXRlcmlhbGl6ZWRcbiAgICAgKi9cbiAgICBpc1RoaXNNYXRlcmlhbGl6ZWQoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpc1VzZWROYW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0LmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGl6ID0gdGhpcy50aHJvdWdoLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRocm91Z2hbaV0uaWRlbnRpZmllci5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuY2xhc3MgR2xvYmFsU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsIFwiZ2xvYmFsXCIsIG51bGwsIGJsb2NrLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuaW1wbGljaXQgPSB7XG4gICAgICAgICAgICBzZXQ6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBMaXN0IG9mIHtAbGluayBSZWZlcmVuY2V9cyB0aGF0IGFyZSBsZWZ0IHRvIGJlIHJlc29sdmVkIChpLmUuIHdoaWNoXG4gICAgICAgICAgICAqIG5lZWQgdG8gYmUgbGlua2VkIHRvIHRoZSB2YXJpYWJsZSB0aGV5IHJlZmVyIHRvKS5cbiAgICAgICAgICAgICogQG1lbWJlciB7UmVmZXJlbmNlW119IFNjb3BlI2ltcGxpY2l0I2xlZnRcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZWZ0OiBbXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9fY2xvc2Uoc2NvcGVNYW5hZ2VyKSB7XG4gICAgICAgIGNvbnN0IGltcGxpY2l0ID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGl6ID0gdGhpcy5fX2xlZnQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5fX2xlZnRbaV07XG5cbiAgICAgICAgICAgIGlmIChyZWYuX19tYXliZUltcGxpY2l0R2xvYmFsICYmICF0aGlzLnNldC5oYXMocmVmLmlkZW50aWZpZXIubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpbXBsaWNpdC5wdXNoKHJlZi5fX21heWJlSW1wbGljaXRHbG9iYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGFuIGltcGxpY2l0IGdsb2JhbCB2YXJpYWJsZSBmcm9tIGFzc2lnbm1lbnQgZXhwcmVzc2lvblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaXogPSBpbXBsaWNpdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gaW1wbGljaXRbaV07XG5cbiAgICAgICAgICAgIHRoaXMuX19kZWZpbmVJbXBsaWNpdChpbmZvLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIFZhcmlhYmxlLkltcGxpY2l0R2xvYmFsVmFyaWFibGUsXG4gICAgICAgICAgICAgICAgICAgIGluZm8ucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgaW5mby5ub2RlLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgKSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW1wbGljaXQubGVmdCA9IHRoaXMuX19sZWZ0O1xuXG4gICAgICAgIHJldHVybiBzdXBlci5fX2Nsb3NlKHNjb3BlTWFuYWdlcik7XG4gICAgfVxuXG4gICAgX19kZWZpbmVJbXBsaWNpdChub2RlLCBkZWYpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgdGhpcy5fX2RlZmluZUdlbmVyaWMoXG4gICAgICAgICAgICAgICAgbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgIHRoaXMuaW1wbGljaXQuc2V0LFxuICAgICAgICAgICAgICAgIHRoaXMuaW1wbGljaXQudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgZGVmXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBNb2R1bGVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgXCJtb2R1bGVcIiwgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgXCJmdW5jdGlvbi1leHByZXNzaW9uLW5hbWVcIiwgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fX2RlZmluZShibG9jay5pZCxcbiAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgIFZhcmlhYmxlLkZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBibG9jay5pZCxcbiAgICAgICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgKSk7XG4gICAgICAgIHRoaXMuZnVuY3Rpb25FeHByZXNzaW9uU2NvcGUgPSB0cnVlO1xuICAgIH1cbn1cblxuY2xhc3MgQ2F0Y2hTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgXCJjYXRjaFwiLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cbn1cblxuY2xhc3MgV2l0aFNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCBcIndpdGhcIiwgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfX2Nsb3NlKHNjb3BlTWFuYWdlcikge1xuICAgICAgICBpZiAodGhpcy5fX3Nob3VsZFN0YXRpY2FsbHlDbG9zZShzY29wZU1hbmFnZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX19jbG9zZShzY29wZU1hbmFnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGl6ID0gdGhpcy5fX2xlZnQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5fX2xlZnRbaV07XG5cbiAgICAgICAgICAgIHJlZi50YWludGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX19kZWxlZ2F0ZVRvVXBwZXJTY29wZShyZWYpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19sZWZ0ID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gdGhpcy51cHBlcjtcbiAgICB9XG59XG5cbmNsYXNzIEJsb2NrU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCB1cHBlclNjb3BlLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsIFwiYmxvY2tcIiwgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICB9XG59XG5cbmNsYXNzIFN3aXRjaFNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCBcInN3aXRjaFwiLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cbn1cblxuY2xhc3MgRnVuY3Rpb25TY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrLCBpc01ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCBcImZ1bmN0aW9uXCIsIHVwcGVyU2NvcGUsIGJsb2NrLCBpc01ldGhvZERlZmluaXRpb24pO1xuXG4gICAgICAgIC8vIHNlY3Rpb24gOS4yLjEzLCBGdW5jdGlvbkRlY2xhcmF0aW9uSW5zdGFudGlhdGlvbi5cbiAgICAgICAgLy8gTk9URSBBcnJvdyBmdW5jdGlvbnMgbmV2ZXIgaGF2ZSBhbiBhcmd1bWVudHMgb2JqZWN0cy5cbiAgICAgICAgaWYgKHRoaXMuYmxvY2sudHlwZSAhPT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVmaW5lQXJndW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0FyZ3VtZW50c01hdGVyaWFsaXplZCgpIHtcblxuICAgICAgICAvLyBUT0RPKENvbnN0ZWxsYXRpb24pXG4gICAgICAgIC8vIFdlIGNhbiBtb3JlIGFnZ3Jlc3NpdmUgb24gdGhpcyBjb25kaXRpb24gbGlrZSB0aGlzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBmdW5jdGlvbiB0KCkge1xuICAgICAgICAvLyAgICAgLy8gYXJndW1lbnRzIG9mIHQgaXMgYWx3YXlzIGhpZGRlbi5cbiAgICAgICAgLy8gICAgIGZ1bmN0aW9uIGFyZ3VtZW50cygpIHtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICBpZiAodGhpcy5ibG9jay50eXBlID09PSBTeW50YXguQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5zZXQuZ2V0KFwiYXJndW1lbnRzXCIpO1xuXG4gICAgICAgIGFzc2VydCh2YXJpYWJsZSwgXCJBbHdheXMgaGF2ZSBhcmd1bWVudHMgdmFyaWFibGUuXCIpO1xuICAgICAgICByZXR1cm4gdmFyaWFibGUudGFpbnRlZCB8fCB2YXJpYWJsZS5yZWZlcmVuY2VzLmxlbmd0aCAhPT0gMDtcbiAgICB9XG5cbiAgICBpc1RoaXNNYXRlcmlhbGl6ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aGlzRm91bmQ7XG4gICAgfVxuXG4gICAgX19kZWZpbmVBcmd1bWVudHMoKSB7XG4gICAgICAgIHRoaXMuX19kZWZpbmVHZW5lcmljKFxuICAgICAgICAgICAgXCJhcmd1bWVudHNcIixcbiAgICAgICAgICAgIHRoaXMuc2V0LFxuICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRhaW50cy5zZXQoXCJhcmd1bWVudHNcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gUmVmZXJlbmNlcyBpbiBkZWZhdWx0IHBhcmFtZXRlcnMgaXNuJ3QgcmVzb2x2ZWQgdG8gdmFyaWFibGVzIHdoaWNoIGFyZSBpbiB0aGVpciBmdW5jdGlvbiBib2R5LlxuICAgIC8vICAgICBjb25zdCB4ID0gMVxuICAgIC8vICAgICBmdW5jdGlvbiBmKGEgPSB4KSB7IC8vIFRoaXMgYHhgIGlzIHJlc29sdmVkIHRvIHRoZSBgeGAgaW4gdGhlIG91dGVyIHNjb3BlLlxuICAgIC8vICAgICAgICAgY29uc3QgeCA9IDJcbiAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKGEpXG4gICAgLy8gICAgIH1cbiAgICBfX2lzVmFsaWRSZXNvbHV0aW9uKHJlZiwgdmFyaWFibGUpIHtcblxuICAgICAgICAvLyBJZiBgb3B0aW9ucy5ub2RlanNTY29wZWAgaXMgdHJ1ZSwgYHRoaXMuYmxvY2tgIGJlY29tZXMgYSBQcm9ncmFtIG5vZGUuXG4gICAgICAgIGlmICh0aGlzLmJsb2NrLnR5cGUgPT09IFwiUHJvZ3JhbVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJvZHlTdGFydCA9IHRoaXMuYmxvY2suYm9keS5yYW5nZVswXTtcblxuICAgICAgICAvLyBJdCdzIGludmFsaWQgcmVzb2x1dGlvbiBpbiB0aGUgZm9sbG93aW5nIGNhc2U6XG4gICAgICAgIHJldHVybiAhKFxuICAgICAgICAgICAgdmFyaWFibGUuc2NvcGUgPT09IHRoaXMgJiZcbiAgICAgICAgICAgIHJlZi5pZGVudGlmaWVyLnJhbmdlWzBdIDwgYm9keVN0YXJ0ICYmIC8vIHRoZSByZWZlcmVuY2UgaXMgaW4gdGhlIHBhcmFtZXRlciBwYXJ0LlxuICAgICAgICAgICAgdmFyaWFibGUuZGVmcy5ldmVyeShkID0+IGQubmFtZS5yYW5nZVswXSA+PSBib2R5U3RhcnQpIC8vIHRoZSB2YXJpYWJsZSBpcyBpbiB0aGUgYm9keS5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmNsYXNzIEZvclNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCBcImZvclwiLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2xhc3NTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgXCJjbGFzc1wiLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgU2NvcGUsXG4gICAgR2xvYmFsU2NvcGUsXG4gICAgTW9kdWxlU2NvcGUsXG4gICAgRnVuY3Rpb25FeHByZXNzaW9uTmFtZVNjb3BlLFxuICAgIENhdGNoU2NvcGUsXG4gICAgV2l0aFNjb3BlLFxuICAgIEJsb2NrU2NvcGUsXG4gICAgU3dpdGNoU2NvcGUsXG4gICAgRnVuY3Rpb25TY29wZSxcbiAgICBGb3JTY29wZSxcbiAgICBDbGFzc1Njb3BlXG59O1xuXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTdXQTtBQUNBO0FBOFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUEzREE7QUFDQTtBQTREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQWRBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQXBCQTtBQUNBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBSEE7QUFLQTtBQUNBO0FBM0VBO0FBQ0E7QUE0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBY0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/eslint-scope/lib/scope.js\n");

/***/ }),

/***/ "./node_modules/eslint-scope/lib/variable.js":
/*!***************************************************!*\
  !*** ./node_modules/eslint-scope/lib/variable.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * A Variable represents a locally scoped identifier. These include arguments to\n * functions.\n * @class Variable\n */\n\nclass Variable {\n  constructor(name, scope) {\n    /**\n     * The variable name, as given in the source code.\n     * @member {String} Variable#name\n     */\n    this.name = name;\n    /**\n     * List of defining occurrences of this variable (like in 'var ...'\n     * statements or as parameter), as AST nodes.\n     * @member {espree.Identifier[]} Variable#identifiers\n     */\n\n    this.identifiers = [];\n    /**\n     * List of {@link Reference|references} of this variable (excluding parameter entries)\n     * in its defining scope and all nested scopes. For defining\n     * occurrences only see {@link Variable#defs}.\n     * @member {Reference[]} Variable#references\n     */\n\n    this.references = [];\n    /**\n     * List of defining occurrences of this variable (like in 'var ...'\n     * statements or as parameter), as custom objects.\n     * @member {Definition[]} Variable#defs\n     */\n\n    this.defs = [];\n    this.tainted = false;\n    /**\n     * Whether this is a stack variable.\n     * @member {boolean} Variable#stack\n     */\n\n    this.stack = true;\n    /**\n     * Reference to the enclosing Scope.\n     * @member {Scope} Variable#scope\n     */\n\n    this.scope = scope;\n  }\n\n}\n\nVariable.CatchClause = \"CatchClause\";\nVariable.Parameter = \"Parameter\";\nVariable.FunctionName = \"FunctionName\";\nVariable.ClassName = \"ClassName\";\nVariable.Variable = \"Variable\";\nVariable.ImportBinding = \"ImportBinding\";\nVariable.ImplicitGlobalVariable = \"ImplicitGlobalVariable\";\nmodule.exports = Variable;\n/* vim: set sw=4 ts=4 et tw=80 : *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL2xpYi92YXJpYWJsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc2xpbnQtc2NvcGUvbGliL3ZhcmlhYmxlLmpzPzUyMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDE1IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQSBWYXJpYWJsZSByZXByZXNlbnRzIGEgbG9jYWxseSBzY29wZWQgaWRlbnRpZmllci4gVGhlc2UgaW5jbHVkZSBhcmd1bWVudHMgdG9cbiAqIGZ1bmN0aW9ucy5cbiAqIEBjbGFzcyBWYXJpYWJsZVxuICovXG5jbGFzcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgc2NvcGUpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhcmlhYmxlIG5hbWUsIGFzIGdpdmVuIGluIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBWYXJpYWJsZSNuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGRlZmluaW5nIG9jY3VycmVuY2VzIG9mIHRoaXMgdmFyaWFibGUgKGxpa2UgaW4gJ3ZhciAuLi4nXG4gICAgICAgICAqIHN0YXRlbWVudHMgb3IgYXMgcGFyYW1ldGVyKSwgYXMgQVNUIG5vZGVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtlc3ByZWUuSWRlbnRpZmllcltdfSBWYXJpYWJsZSNpZGVudGlmaWVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZGVudGlmaWVycyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIHtAbGluayBSZWZlcmVuY2V8cmVmZXJlbmNlc30gb2YgdGhpcyB2YXJpYWJsZSAoZXhjbHVkaW5nIHBhcmFtZXRlciBlbnRyaWVzKVxuICAgICAgICAgKiBpbiBpdHMgZGVmaW5pbmcgc2NvcGUgYW5kIGFsbCBuZXN0ZWQgc2NvcGVzLiBGb3IgZGVmaW5pbmdcbiAgICAgICAgICogb2NjdXJyZW5jZXMgb25seSBzZWUge0BsaW5rIFZhcmlhYmxlI2RlZnN9LlxuICAgICAgICAgKiBAbWVtYmVyIHtSZWZlcmVuY2VbXX0gVmFyaWFibGUjcmVmZXJlbmNlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgZGVmaW5pbmcgb2NjdXJyZW5jZXMgb2YgdGhpcyB2YXJpYWJsZSAobGlrZSBpbiAndmFyIC4uLidcbiAgICAgICAgICogc3RhdGVtZW50cyBvciBhcyBwYXJhbWV0ZXIpLCBhcyBjdXN0b20gb2JqZWN0cy5cbiAgICAgICAgICogQG1lbWJlciB7RGVmaW5pdGlvbltdfSBWYXJpYWJsZSNkZWZzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZnMgPSBbXTtcblxuICAgICAgICB0aGlzLnRhaW50ZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIGlzIGEgc3RhY2sgdmFyaWFibGUuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IFZhcmlhYmxlI3N0YWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gdHJ1ZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBlbmNsb3NpbmcgU2NvcGUuXG4gICAgICAgICAqIEBtZW1iZXIge1Njb3BlfSBWYXJpYWJsZSNzY29wZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbn1cblxuVmFyaWFibGUuQ2F0Y2hDbGF1c2UgPSBcIkNhdGNoQ2xhdXNlXCI7XG5WYXJpYWJsZS5QYXJhbWV0ZXIgPSBcIlBhcmFtZXRlclwiO1xuVmFyaWFibGUuRnVuY3Rpb25OYW1lID0gXCJGdW5jdGlvbk5hbWVcIjtcblZhcmlhYmxlLkNsYXNzTmFtZSA9IFwiQ2xhc3NOYW1lXCI7XG5WYXJpYWJsZS5WYXJpYWJsZSA9IFwiVmFyaWFibGVcIjtcblZhcmlhYmxlLkltcG9ydEJpbmRpbmcgPSBcIkltcG9ydEJpbmRpbmdcIjtcblZhcmlhYmxlLkltcGxpY2l0R2xvYmFsVmFyaWFibGUgPSBcIkltcGxpY2l0R2xvYmFsVmFyaWFibGVcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBWYXJpYWJsZTtcblxuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTdDQTtBQUNBO0FBOENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/eslint-scope/lib/variable.js\n");

/***/ }),

/***/ "./node_modules/eslint-scope/package.json":
/*!************************************************!*\
  !*** ./node_modules/eslint-scope/package.json ***!
  \************************************************/
/*! exports provided: name, description, homepage, main, version, engines, repository, bugs, license, scripts, files, dependencies, devDependencies, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"eslint-scope\\\",\\\"description\\\":\\\"ECMAScript scope analyzer for ESLint\\\",\\\"homepage\\\":\\\"http://github.com/eslint/eslint-scope\\\",\\\"main\\\":\\\"lib/index.js\\\",\\\"version\\\":\\\"5.1.1\\\",\\\"engines\\\":{\\\"node\\\":\\\">=8.0.0\\\"},\\\"repository\\\":\\\"eslint/eslint-scope\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/eslint/eslint-scope/issues\\\"},\\\"license\\\":\\\"BSD-2-Clause\\\",\\\"scripts\\\":{\\\"test\\\":\\\"node Makefile.js test\\\",\\\"lint\\\":\\\"node Makefile.js lint\\\",\\\"generate-release\\\":\\\"eslint-generate-release\\\",\\\"generate-alpharelease\\\":\\\"eslint-generate-prerelease alpha\\\",\\\"generate-betarelease\\\":\\\"eslint-generate-prerelease beta\\\",\\\"generate-rcrelease\\\":\\\"eslint-generate-prerelease rc\\\",\\\"publish-release\\\":\\\"eslint-publish-release\\\"},\\\"files\\\":[\\\"LICENSE\\\",\\\"README.md\\\",\\\"lib\\\"],\\\"dependencies\\\":{\\\"esrecurse\\\":\\\"^4.3.0\\\",\\\"estraverse\\\":\\\"^4.1.1\\\"},\\\"devDependencies\\\":{\\\"@typescript-eslint/parser\\\":\\\"^1.11.0\\\",\\\"chai\\\":\\\"^4.2.0\\\",\\\"eslint\\\":\\\"^6.0.1\\\",\\\"eslint-config-eslint\\\":\\\"^5.0.1\\\",\\\"eslint-plugin-node\\\":\\\"^9.1.0\\\",\\\"eslint-release\\\":\\\"^1.0.0\\\",\\\"eslint-visitor-keys\\\":\\\"^1.2.0\\\",\\\"espree\\\":\\\"^7.1.0\\\",\\\"istanbul\\\":\\\"^0.4.5\\\",\\\"mocha\\\":\\\"^6.1.4\\\",\\\"npm-license\\\":\\\"^0.3.3\\\",\\\"shelljs\\\":\\\"^0.8.3\\\",\\\"typescript\\\":\\\"^3.5.2\\\"}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNsaW50LXNjb3BlL3BhY2thZ2UuanNvbi5qcyIsInNvdXJjZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/eslint-scope/package.json\n");

/***/ }),

/***/ "./node_modules/esrecurse/esrecurse.js":
/*!*********************************************!*\
  !*** ./node_modules/esrecurse/esrecurse.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n(function () {\n    'use strict';\n\n    var estraverse = __webpack_require__(/*! estraverse */ \"./node_modules/esrecurse/node_modules/estraverse/estraverse.js\");\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === 'properties';\n    }\n\n    function Visitor(visitor, options) {\n        options = options || {};\n\n        this.__visitor = visitor ||  this;\n        this.__childVisitorKeys = options.childVisitorKeys\n            ? Object.assign({}, estraverse.VisitorKeys, options.childVisitorKeys)\n            : estraverse.VisitorKeys;\n        if (options.fallback === 'iteration') {\n            this.__fallback = Object.keys;\n        } else if (typeof options.fallback === 'function') {\n            this.__fallback = options.fallback;\n        }\n    }\n\n    /* Default method for visiting children.\n     * When you need to call default visiting operation inside custom visiting\n     * operation, you can use it with `this.visitChildren(node)`.\n     */\n    Visitor.prototype.visitChildren = function (node) {\n        var type, children, i, iz, j, jz, child;\n\n        if (node == null) {\n            return;\n        }\n\n        type = node.type || estraverse.Syntax.Property;\n\n        children = this.__childVisitorKeys[type];\n        if (!children) {\n            if (this.__fallback) {\n                children = this.__fallback(node);\n            } else {\n                throw new Error('Unknown node type ' + type + '.');\n            }\n        }\n\n        for (i = 0, iz = children.length; i < iz; ++i) {\n            child = node[children[i]];\n            if (child) {\n                if (Array.isArray(child)) {\n                    for (j = 0, jz = child.length; j < jz; ++j) {\n                        if (child[j]) {\n                            if (isNode(child[j]) || isProperty(type, children[i])) {\n                                this.visit(child[j]);\n                            }\n                        }\n                    }\n                } else if (isNode(child)) {\n                    this.visit(child);\n                }\n            }\n        }\n    };\n\n    /* Dispatching node. */\n    Visitor.prototype.visit = function (node) {\n        var type;\n\n        if (node == null) {\n            return;\n        }\n\n        type = node.type || estraverse.Syntax.Property;\n        if (this.__visitor[type]) {\n            this.__visitor[type].call(this, node);\n            return;\n        }\n        this.visitChildren(node);\n    };\n\n    exports.version = __webpack_require__(/*! ./package.json */ \"./node_modules/esrecurse/package.json\").version;\n    exports.Visitor = Visitor;\n    exports.visit = function (node, visitor, options) {\n        var v = new Visitor(visitor, options);\n        v.visit(node);\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyZWN1cnNlL2VzcmVjdXJzZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lc3JlY3Vyc2UvZXNyZWN1cnNlLmpzPzI5OTkiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDE0IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgZXN0cmF2ZXJzZSA9IHJlcXVpcmUoJ2VzdHJhdmVyc2UnKTtcblxuICAgIGZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBub2RlLnR5cGUgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUHJvcGVydHkobm9kZVR5cGUsIGtleSkge1xuICAgICAgICByZXR1cm4gKG5vZGVUeXBlID09PSBlc3RyYXZlcnNlLlN5bnRheC5PYmplY3RFeHByZXNzaW9uIHx8IG5vZGVUeXBlID09PSBlc3RyYXZlcnNlLlN5bnRheC5PYmplY3RQYXR0ZXJuKSAmJiBrZXkgPT09ICdwcm9wZXJ0aWVzJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBWaXNpdG9yKHZpc2l0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdGhpcy5fX3Zpc2l0b3IgPSB2aXNpdG9yIHx8ICB0aGlzO1xuICAgICAgICB0aGlzLl9fY2hpbGRWaXNpdG9yS2V5cyA9IG9wdGlvbnMuY2hpbGRWaXNpdG9yS2V5c1xuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBlc3RyYXZlcnNlLlZpc2l0b3JLZXlzLCBvcHRpb25zLmNoaWxkVmlzaXRvcktleXMpXG4gICAgICAgICAgICA6IGVzdHJhdmVyc2UuVmlzaXRvcktleXM7XG4gICAgICAgIGlmIChvcHRpb25zLmZhbGxiYWNrID09PSAnaXRlcmF0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fX2ZhbGxiYWNrID0gT2JqZWN0LmtleXM7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZmFsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX19mYWxsYmFjayA9IG9wdGlvbnMuZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBEZWZhdWx0IG1ldGhvZCBmb3IgdmlzaXRpbmcgY2hpbGRyZW4uXG4gICAgICogV2hlbiB5b3UgbmVlZCB0byBjYWxsIGRlZmF1bHQgdmlzaXRpbmcgb3BlcmF0aW9uIGluc2lkZSBjdXN0b20gdmlzaXRpbmdcbiAgICAgKiBvcGVyYXRpb24sIHlvdSBjYW4gdXNlIGl0IHdpdGggYHRoaXMudmlzaXRDaGlsZHJlbihub2RlKWAuXG4gICAgICovXG4gICAgVmlzaXRvci5wcm90b3R5cGUudmlzaXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciB0eXBlLCBjaGlsZHJlbiwgaSwgaXosIGosIGp6LCBjaGlsZDtcblxuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gbm9kZS50eXBlIHx8IGVzdHJhdmVyc2UuU3ludGF4LlByb3BlcnR5O1xuXG4gICAgICAgIGNoaWxkcmVuID0gdGhpcy5fX2NoaWxkVmlzaXRvcktleXNbdHlwZV07XG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMuX19mYWxsYmFjayhub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZSAnICsgdHlwZSArICcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZVtjaGlsZHJlbltpXV07XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMCwganogPSBjaGlsZC5sZW5ndGg7IGogPCBqejsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKGNoaWxkW2pdKSB8fCBpc1Byb3BlcnR5KHR5cGUsIGNoaWxkcmVuW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KGNoaWxkW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIERpc3BhdGNoaW5nIG5vZGUuICovXG4gICAgVmlzaXRvci5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgdHlwZTtcblxuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gbm9kZS50eXBlIHx8IGVzdHJhdmVyc2UuU3ludGF4LlByb3BlcnR5O1xuICAgICAgICBpZiAodGhpcy5fX3Zpc2l0b3JbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX192aXNpdG9yW3R5cGVdLmNhbGwodGhpcywgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKG5vZGUpO1xuICAgIH07XG5cbiAgICBleHBvcnRzLnZlcnNpb24gPSByZXF1aXJlKCcuL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4gICAgZXhwb3J0cy5WaXNpdG9yID0gVmlzaXRvcjtcbiAgICBleHBvcnRzLnZpc2l0ID0gZnVuY3Rpb24gKG5vZGUsIHZpc2l0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHYgPSBuZXcgVmlzaXRvcih2aXNpdG9yLCBvcHRpb25zKTtcbiAgICAgICAgdi52aXNpdChub2RlKTtcbiAgICB9O1xufSgpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esrecurse/esrecurse.js\n");

/***/ }),

/***/ "./node_modules/esrecurse/node_modules/estraverse/estraverse.js":
/*!**********************************************************************!*\
  !*** ./node_modules/esrecurse/node_modules/estraverse/estraverse.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        VisitorOption,\n        VisitorKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ChainExpression: 'ChainExpression',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportExpression: 'ImportExpression',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ChainExpression: ['expression'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportExpression: ['source'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (Array.isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n        if (visitor.fallback === 'iteration') {\n            this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === 'function') {\n            this.__fallback = visitor.fallback;\n        }\n\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n  \n    function candidateExistsInLeaveList(leavelist, candidate) {\n        for (var i = leavelist.length - 1; i >= 0; --i) {\n            if (leavelist[i].node === candidate) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = node.type || element.wrap;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = this.__fallback(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (Array.isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n\n                            if (candidateExistsInLeaveList(leavelist, candidate[current2])) {\n                              continue;\n                            }\n\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        if (candidateExistsInLeaveList(leavelist, candidate)) {\n                          continue;\n                        }\n\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = this.__fallback(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (Array.isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyZWN1cnNlL25vZGVfbW9kdWxlcy9lc3RyYXZlcnNlL2VzdHJhdmVyc2UuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXNyZWN1cnNlL25vZGVfbW9kdWxlcy9lc3RyYXZlcnNlL2VzdHJhdmVyc2UuanM/ZjZmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTItMjAxMyBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuLypqc2xpbnQgdmFyczpmYWxzZSwgYml0d2lzZTp0cnVlKi9cbi8qanNoaW50IGluZGVudDo0Ki9cbi8qZ2xvYmFsIGV4cG9ydHM6dHJ1ZSovXG4oZnVuY3Rpb24gY2xvbmUoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBTeW50YXgsXG4gICAgICAgIFZpc2l0b3JPcHRpb24sXG4gICAgICAgIFZpc2l0b3JLZXlzLFxuICAgICAgICBCUkVBSyxcbiAgICAgICAgU0tJUCxcbiAgICAgICAgUkVNT1ZFO1xuXG4gICAgZnVuY3Rpb24gZGVlcENvcHkob2JqKSB7XG4gICAgICAgIHZhciByZXQgPSB7fSwga2V5LCB2YWw7XG4gICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IGRlZXBDb3B5KHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gYmFzZWQgb24gTExWTSBsaWJjKysgdXBwZXJfYm91bmQgLyBsb3dlcl9ib3VuZFxuICAgIC8vIE1JVCBMaWNlbnNlXG5cbiAgICBmdW5jdGlvbiB1cHBlckJvdW5kKGFycmF5LCBmdW5jKSB7XG4gICAgICAgIHZhciBkaWZmLCBsZW4sIGksIGN1cnJlbnQ7XG5cbiAgICAgICAgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBpID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuKSB7XG4gICAgICAgICAgICBkaWZmID0gbGVuID4+PiAxO1xuICAgICAgICAgICAgY3VycmVudCA9IGkgKyBkaWZmO1xuICAgICAgICAgICAgaWYgKGZ1bmMoYXJyYXlbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgbGVuID0gZGlmZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaSA9IGN1cnJlbnQgKyAxO1xuICAgICAgICAgICAgICAgIGxlbiAtPSBkaWZmICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBTeW50YXggPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgICBBc3NpZ25tZW50UGF0dGVybjogJ0Fzc2lnbm1lbnRQYXR0ZXJuJyxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiAnQXJyYXlQYXR0ZXJuJyxcbiAgICAgICAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogJ0F3YWl0RXhwcmVzc2lvbicsIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBCbG9ja1N0YXRlbWVudDogJ0Jsb2NrU3RhdGVtZW50JyxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgICBCcmVha1N0YXRlbWVudDogJ0JyZWFrU3RhdGVtZW50JyxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICAgIENhdGNoQ2xhdXNlOiAnQ2F0Y2hDbGF1c2UnLFxuICAgICAgICBDaGFpbkV4cHJlc3Npb246ICdDaGFpbkV4cHJlc3Npb24nLFxuICAgICAgICBDbGFzc0JvZHk6ICdDbGFzc0JvZHknLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiAnQ2xhc3NEZWNsYXJhdGlvbicsXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogJ0NsYXNzRXhwcmVzc2lvbicsXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogJ0NvbXByZWhlbnNpb25CbG9jaycsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246ICdDb21wcmVoZW5zaW9uRXhwcmVzc2lvbicsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6ICdDb250aW51ZVN0YXRlbWVudCcsXG4gICAgICAgIERlYnVnZ2VyU3RhdGVtZW50OiAnRGVidWdnZXJTdGF0ZW1lbnQnLFxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6ICdEaXJlY3RpdmVTdGF0ZW1lbnQnLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiAnRG9XaGlsZVN0YXRlbWVudCcsXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiAnRW1wdHlTdGF0ZW1lbnQnLFxuICAgICAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogJ0V4cG9ydEFsbERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJyxcbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogJ0V4cG9ydE5hbWVkRGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6ICdFeHBvcnRTcGVjaWZpZXInLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICAgIEZvclN0YXRlbWVudDogJ0ZvclN0YXRlbWVudCcsXG4gICAgICAgIEZvckluU3RhdGVtZW50OiAnRm9ySW5TdGF0ZW1lbnQnLFxuICAgICAgICBGb3JPZlN0YXRlbWVudDogJ0Zvck9mU3RhdGVtZW50JyxcbiAgICAgICAgRnVuY3Rpb25EZWNsYXJhdGlvbjogJ0Z1bmN0aW9uRGVjbGFyYXRpb24nLFxuICAgICAgICBGdW5jdGlvbkV4cHJlc3Npb246ICdGdW5jdGlvbkV4cHJlc3Npb24nLFxuICAgICAgICBHZW5lcmF0b3JFeHByZXNzaW9uOiAnR2VuZXJhdG9yRXhwcmVzc2lvbicsICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgICBJZlN0YXRlbWVudDogJ0lmU3RhdGVtZW50JyxcbiAgICAgICAgSW1wb3J0RXhwcmVzc2lvbjogJ0ltcG9ydEV4cHJlc3Npb24nLFxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogJ0ltcG9ydERlY2xhcmF0aW9uJyxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInLFxuICAgICAgICBJbXBvcnRTcGVjaWZpZXI6ICdJbXBvcnRTcGVjaWZpZXInLFxuICAgICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6ICdMYWJlbGVkU3RhdGVtZW50JyxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgICAgTWV0YVByb3BlcnR5OiAnTWV0YVByb3BlcnR5JyxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogJ01ldGhvZERlZmluaXRpb24nLFxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6ICdNb2R1bGVTcGVjaWZpZXInLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiAnTmV3RXhwcmVzc2lvbicsXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0UGF0dGVybjogJ09iamVjdFBhdHRlcm4nLFxuICAgICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgICBSZXN0RWxlbWVudDogJ1Jlc3RFbGVtZW50JyxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiAnUmV0dXJuU3RhdGVtZW50JyxcbiAgICAgICAgU2VxdWVuY2VFeHByZXNzaW9uOiAnU2VxdWVuY2VFeHByZXNzaW9uJyxcbiAgICAgICAgU3ByZWFkRWxlbWVudDogJ1NwcmVhZEVsZW1lbnQnLFxuICAgICAgICBTdXBlcjogJ1N1cGVyJyxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiAnU3dpdGNoU3RhdGVtZW50JyxcbiAgICAgICAgU3dpdGNoQ2FzZTogJ1N3aXRjaENhc2UnLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246ICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6ICdUZW1wbGF0ZUVsZW1lbnQnLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6ICdUZW1wbGF0ZUxpdGVyYWwnLFxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogJ1RoaXNFeHByZXNzaW9uJyxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6ICdUaHJvd1N0YXRlbWVudCcsXG4gICAgICAgIFRyeVN0YXRlbWVudDogJ1RyeVN0YXRlbWVudCcsXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJyxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogJ1ZhcmlhYmxlRGVjbGFyYXRpb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0b3I6ICdWYXJpYWJsZURlY2xhcmF0b3InLFxuICAgICAgICBXaGlsZVN0YXRlbWVudDogJ1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgV2l0aFN0YXRlbWVudDogJ1dpdGhTdGF0ZW1lbnQnLFxuICAgICAgICBZaWVsZEV4cHJlc3Npb246ICdZaWVsZEV4cHJlc3Npb24nXG4gICAgfTtcblxuICAgIFZpc2l0b3JLZXlzID0ge1xuICAgICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQXJyYXlFeHByZXNzaW9uOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycmF5UGF0dGVybjogWydlbGVtZW50cyddLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogWydwYXJhbXMnLCAnYm9keSddLFxuICAgICAgICBBd2FpdEV4cHJlc3Npb246IFsnYXJndW1lbnQnXSwgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiBbJ2JvZHknXSxcbiAgICAgICAgQmluYXJ5RXhwcmVzc2lvbjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiBbJ2xhYmVsJ10sXG4gICAgICAgIENhbGxFeHByZXNzaW9uOiBbJ2NhbGxlZScsICdhcmd1bWVudHMnXSxcbiAgICAgICAgQ2F0Y2hDbGF1c2U6IFsncGFyYW0nLCAnYm9keSddLFxuICAgICAgICBDaGFpbkV4cHJlc3Npb246IFsnZXhwcmVzc2lvbiddLFxuICAgICAgICBDbGFzc0JvZHk6IFsnYm9keSddLFxuICAgICAgICBDbGFzc0RlY2xhcmF0aW9uOiBbJ2lkJywgJ3N1cGVyQ2xhc3MnLCAnYm9keSddLFxuICAgICAgICBDbGFzc0V4cHJlc3Npb246IFsnaWQnLCAnc3VwZXJDbGFzcycsICdib2R5J10sXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogWydsZWZ0JywgJ3JpZ2h0J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246IFsnYmxvY2tzJywgJ2ZpbHRlcicsICdib2R5J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBbJ3Rlc3QnLCAnY29uc2VxdWVudCcsICdhbHRlcm5hdGUnXSxcbiAgICAgICAgQ29udGludWVTdGF0ZW1lbnQ6IFsnbGFiZWwnXSxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBEaXJlY3RpdmVTdGF0ZW1lbnQ6IFtdLFxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiBbJ2JvZHknLCAndGVzdCddLFxuICAgICAgICBFbXB0eVN0YXRlbWVudDogW10sXG4gICAgICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiBbJ3NvdXJjZSddLFxuICAgICAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246IFsnZGVjbGFyYXRpb24nXSxcbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbicsICdzcGVjaWZpZXJzJywgJ3NvdXJjZSddLFxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6IFsnZXhwb3J0ZWQnLCAnbG9jYWwnXSxcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogWydleHByZXNzaW9uJ10sXG4gICAgICAgIEZvclN0YXRlbWVudDogWydpbml0JywgJ3Rlc3QnLCAndXBkYXRlJywgJ2JvZHknXSxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6IFsnbGVmdCcsICdyaWdodCcsICdib2R5J10sXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiBbJ2xlZnQnLCAncmlnaHQnLCAnYm9keSddLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBbJ2lkJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogWydpZCcsICdwYXJhbXMnLCAnYm9keSddLFxuICAgICAgICBHZW5lcmF0b3JFeHByZXNzaW9uOiBbJ2Jsb2NrcycsICdmaWx0ZXInLCAnYm9keSddLCAgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIElkZW50aWZpZXI6IFtdLFxuICAgICAgICBJZlN0YXRlbWVudDogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnLCAnYWx0ZXJuYXRlJ10sXG4gICAgICAgIEltcG9ydEV4cHJlc3Npb246IFsnc291cmNlJ10sXG4gICAgICAgIEltcG9ydERlY2xhcmF0aW9uOiBbJ3NwZWNpZmllcnMnLCAnc291cmNlJ10sXG4gICAgICAgIEltcG9ydERlZmF1bHRTcGVjaWZpZXI6IFsnbG9jYWwnXSxcbiAgICAgICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyOiBbJ2xvY2FsJ10sXG4gICAgICAgIEltcG9ydFNwZWNpZmllcjogWydpbXBvcnRlZCcsICdsb2NhbCddLFxuICAgICAgICBMaXRlcmFsOiBbXSxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogWydsYWJlbCcsICdib2R5J10sXG4gICAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogWydvYmplY3QnLCAncHJvcGVydHknXSxcbiAgICAgICAgTWV0YVByb3BlcnR5OiBbJ21ldGEnLCAncHJvcGVydHknXSxcbiAgICAgICAgTWV0aG9kRGVmaW5pdGlvbjogWydrZXknLCAndmFsdWUnXSxcbiAgICAgICAgTW9kdWxlU3BlY2lmaWVyOiBbXSxcbiAgICAgICAgTmV3RXhwcmVzc2lvbjogWydjYWxsZWUnLCAnYXJndW1lbnRzJ10sXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246IFsncHJvcGVydGllcyddLFxuICAgICAgICBPYmplY3RQYXR0ZXJuOiBbJ3Byb3BlcnRpZXMnXSxcbiAgICAgICAgUHJvZ3JhbTogWydib2R5J10sXG4gICAgICAgIFByb3BlcnR5OiBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgICBSZXN0RWxlbWVudDogWyAnYXJndW1lbnQnIF0sXG4gICAgICAgIFJldHVyblN0YXRlbWVudDogWydhcmd1bWVudCddLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246IFsnZXhwcmVzc2lvbnMnXSxcbiAgICAgICAgU3ByZWFkRWxlbWVudDogWydhcmd1bWVudCddLFxuICAgICAgICBTdXBlcjogW10sXG4gICAgICAgIFN3aXRjaFN0YXRlbWVudDogWydkaXNjcmltaW5hbnQnLCAnY2FzZXMnXSxcbiAgICAgICAgU3dpdGNoQ2FzZTogWyd0ZXN0JywgJ2NvbnNlcXVlbnQnXSxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBbJ3RhZycsICdxdWFzaSddLFxuICAgICAgICBUZW1wbGF0ZUVsZW1lbnQ6IFtdLFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6IFsncXVhc2lzJywgJ2V4cHJlc3Npb25zJ10sXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiBbXSxcbiAgICAgICAgVGhyb3dTdGF0ZW1lbnQ6IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiBbJ2Jsb2NrJywgJ2hhbmRsZXInLCAnZmluYWxpemVyJ10sXG4gICAgICAgIFVuYXJ5RXhwcmVzc2lvbjogWydhcmd1bWVudCddLFxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRpb246IFsnZGVjbGFyYXRpb25zJ10sXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogWydpZCcsICdpbml0J10sXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiBbJ3Rlc3QnLCAnYm9keSddLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiBbJ29iamVjdCcsICdib2R5J10sXG4gICAgICAgIFlpZWxkRXhwcmVzc2lvbjogWydhcmd1bWVudCddXG4gICAgfTtcblxuICAgIC8vIHVuaXF1ZSBpZFxuICAgIEJSRUFLID0ge307XG4gICAgU0tJUCA9IHt9O1xuICAgIFJFTU9WRSA9IHt9O1xuXG4gICAgVmlzaXRvck9wdGlvbiA9IHtcbiAgICAgICAgQnJlYWs6IEJSRUFLLFxuICAgICAgICBTa2lwOiBTS0lQLFxuICAgICAgICBSZW1vdmU6IFJFTU9WRVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBSZWZlcmVuY2UocGFyZW50LCBrZXkpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cblxuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uobm9kZSkge1xuICAgICAgICB0aGlzLnBhcmVudFt0aGlzLmtleV0gPSBub2RlO1xuICAgIH07XG5cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5wYXJlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5zcGxpY2UodGhpcy5rZXksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2UobnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRWxlbWVudChub2RlLCBwYXRoLCB3cmFwLCByZWYpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy53cmFwID0gd3JhcDtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29udHJvbGxlcigpIHsgfVxuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBwcm9wZXJ0eSBwYXRoIGFycmF5IGZyb20gcm9vdCB0byBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gcGF0aCgpIHtcbiAgICAgICAgdmFyIGksIGl6LCBqLCBqeiwgcmVzdWx0LCBlbGVtZW50O1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvUGF0aChyZXN1bHQsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwganogPSBwYXRoLmxlbmd0aDsgaiA8IGp6OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGF0aFtqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvb3Qgbm9kZVxuICAgICAgICBpZiAoIXRoaXMuX19jdXJyZW50LnBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3Qgbm9kZSBpcyBzZW50aW5lbCwgc2Vjb25kIG5vZGUgaXMgcm9vdCBlbGVtZW50XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAyLCBpeiA9IHRoaXMuX19sZWF2ZWxpc3QubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IHRoaXMuX19sZWF2ZWxpc3RbaV07XG4gICAgICAgICAgICBhZGRUb1BhdGgocmVzdWx0LCBlbGVtZW50LnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFRvUGF0aChyZXN1bHQsIHRoaXMuX19jdXJyZW50LnBhdGgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIHR5cGUgb2YgY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSB8fCB0aGlzLl9fY3VycmVudC53cmFwO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIGFycmF5IG9mIHBhcmVudCBlbGVtZW50c1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnBhcmVudHMgPSBmdW5jdGlvbiBwYXJlbnRzKCkge1xuICAgICAgICB2YXIgaSwgaXosIHJlc3VsdDtcblxuICAgICAgICAvLyBmaXJzdCBub2RlIGlzIHNlbnRpbmVsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IHRoaXMuX19sZWF2ZWxpc3QubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5fX2xlYXZlbGlzdFtpXS5ub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gY3VycmVudCBub2RlXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIGN1cnJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY3VycmVudC5ub2RlO1xuICAgIH07XG5cbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5fX2V4ZWN1dGUgPSBmdW5jdGlvbiBfX2V4ZWN1dGUoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzLCByZXN1bHQ7XG5cbiAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHByZXZpb3VzICA9IHRoaXMuX19jdXJyZW50O1xuICAgICAgICB0aGlzLl9fY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IG51bGw7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2suY2FsbCh0aGlzLCBlbGVtZW50Lm5vZGUsIHRoaXMuX19sZWF2ZWxpc3RbdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGggLSAxXS5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fY3VycmVudCA9IHByZXZpb3VzO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBub3RpZnkgY29udHJvbCBza2lwIC8gYnJlYWtcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkoZmxhZykge1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBmbGFnO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gc2tpcCBjaGlsZCBub2RlcyBvZiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShTS0lQKTtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIGJyZWFrIHRyYXZlcnNhbHNcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZVsnYnJlYWsnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoQlJFQUspO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmVtb3ZlIG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KFJFTU9WRSk7XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLl9faW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHJvb3QsIHZpc2l0b3IpIHtcbiAgICAgICAgdGhpcy52aXNpdG9yID0gdmlzaXRvcjtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5fX3dvcmtsaXN0ID0gW107XG4gICAgICAgIHRoaXMuX19sZWF2ZWxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fX2N1cnJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9fc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZmFsbGJhY2sgPSBudWxsO1xuICAgICAgICBpZiAodmlzaXRvci5mYWxsYmFjayA9PT0gJ2l0ZXJhdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX19mYWxsYmFjayA9IE9iamVjdC5rZXlzO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2aXNpdG9yLmZhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9fZmFsbGJhY2sgPSB2aXNpdG9yLmZhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2tleXMgPSBWaXNpdG9yS2V5cztcbiAgICAgICAgaWYgKHZpc2l0b3Iua2V5cykge1xuICAgICAgICAgICAgdGhpcy5fX2tleXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUodGhpcy5fX2tleXMpLCB2aXNpdG9yLmtleXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBub2RlLnR5cGUgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUHJvcGVydHkobm9kZVR5cGUsIGtleSkge1xuICAgICAgICByZXR1cm4gKG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbiB8fCBub2RlVHlwZSA9PT0gU3ludGF4Lk9iamVjdFBhdHRlcm4pICYmICdwcm9wZXJ0aWVzJyA9PT0ga2V5O1xuICAgIH1cbiAgXG4gICAgZnVuY3Rpb24gY2FuZGlkYXRlRXhpc3RzSW5MZWF2ZUxpc3QobGVhdmVsaXN0LCBjYW5kaWRhdGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlYXZlbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYgKGxlYXZlbGlzdFtpXS5ub2RlID09PSBjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWw7XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG51bGwpKTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2gobmV3IEVsZW1lbnQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgcmV0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG5cbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHJldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCByZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgICAgICBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCBlbGVtZW50LndyYXA7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19rZXlzW25vZGVUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19mYWxsYmFjayhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGUgJyArIG5vZGVUeXBlICsgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGVzW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBub2RlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQyID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudDIgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlW2N1cnJlbnQyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlRXhpc3RzSW5MZWF2ZUxpc3QobGVhdmVsaXN0LCBjYW5kaWRhdGVbY3VycmVudDJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHkobm9kZVR5cGUsIGNhbmRpZGF0ZXNbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sICdQcm9wZXJ0eScsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKGNhbmRpZGF0ZVtjdXJyZW50Ml0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlRXhpc3RzSW5MZWF2ZUxpc3QobGVhdmVsaXN0LCBjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KGNhbmRpZGF0ZSwga2V5LCBudWxsLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgd29ya2xpc3QsXG4gICAgICAgICAgICBsZWF2ZWxpc3QsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGN1cnJlbnQyLFxuICAgICAgICAgICAgY2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICAgIHNlbnRpbmVsLFxuICAgICAgICAgICAgb3V0ZXIsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWxlbShlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmV4dEVsZW0sXG4gICAgICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5yZWYucmVtb3ZlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSByZWZlcmVuY2UgaXMgYW4gZWxlbWVudCBvZiBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICBrZXkgPSBlbGVtZW50LnJlZi5rZXk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudC5yZWYucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVtb3ZlZCBmcm9tIGFycmF5LCB0aGVuIGRlY3JlYXNlIGZvbGxvd2luZyBpdGVtcycga2V5cy5cbiAgICAgICAgICAgICAgICBpID0gd29ya2xpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsZW0gPSB3b3JrbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtLnJlZiAmJiBuZXh0RWxlbS5yZWYucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICAobmV4dEVsZW0ucmVmLmtleSA8IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLS1uZXh0RWxlbS5yZWYua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICBvdXRlciA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3RcbiAgICAgICAgfTtcbiAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG5ldyBSZWZlcmVuY2Uob3V0ZXIsICdyb290JykpO1xuICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBsZWF2ZWxpc3QucHVzaChlbGVtZW50KTtcblxuICAgICAgICB3aGlsZSAod29ya2xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gd29ya2xpc3QucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBzZW50aW5lbCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBsZWF2ZWxpc3QucG9wKCk7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmxlYXZlLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIHJlcGxhY2VkIHdpdGggbnVsbCxcbiAgICAgICAgICAgICAgICAvLyBzbyBkaXN0aW5ndWlzaCBiZXR3ZWVuIHVuZGVmaW5lZCBhbmQgbnVsbCBpbiB0aGlzIHBsYWNlXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gQlJFQUsgJiYgdGFyZ2V0ICE9PSBTS0lQICYmIHRhcmdldCAhPT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZWYucmVwbGFjZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFJFTU9WRSB8fCB0YXJnZXQgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFbGVtKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHRhcmdldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyLnJvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgcmVwbGFjZWQgd2l0aCBudWxsLFxuICAgICAgICAgICAgLy8gc28gZGlzdGluZ3Vpc2ggYmV0d2VlbiB1bmRlZmluZWQgYW5kIG51bGwgaW4gdGhpcyBwbGFjZVxuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gQlJFQUsgJiYgdGFyZ2V0ICE9PSBTS0lQICYmIHRhcmdldCAhPT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZVxuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVmLnJlcGxhY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5vZGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFJFTU9WRSB8fCB0YXJnZXQgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW0oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ub2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgdGFyZ2V0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub2RlIG1heSBiZSBudWxsXG4gICAgICAgICAgICBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFNLSVAgfHwgdGFyZ2V0ID09PSBTS0lQKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGVUeXBlID0gbm9kZS50eXBlIHx8IGVsZW1lbnQud3JhcDtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9fa2V5c1tub2RlVHlwZV07XG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9fZmFsbGJhY2sobm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZSAnICsgbm9kZVR5cGUgKyAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudCA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50IC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGVzW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQyID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50MiAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5KG5vZGVUeXBlLCBjYW5kaWRhdGVzW2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sICdQcm9wZXJ0eScsIG5ldyBSZWZlcmVuY2UoY2FuZGlkYXRlLCBjdXJyZW50MikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlW2N1cnJlbnQyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCBudWxsLCBuZXcgUmVmZXJlbmNlKGNhbmRpZGF0ZSwgY3VycmVudDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KGNhbmRpZGF0ZSwga2V5LCBudWxsLCBuZXcgUmVmZXJlbmNlKG5vZGUsIGtleSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJhdmVyc2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnRyYXZlcnNlKHJvb3QsIHZpc2l0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnJlcGxhY2Uocm9vdCwgdmlzaXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kQ29tbWVudFJhbmdlKGNvbW1lbnQsIHRva2Vucykge1xuICAgICAgICB2YXIgdGFyZ2V0O1xuXG4gICAgICAgIHRhcmdldCA9IHVwcGVyQm91bmQodG9rZW5zLCBmdW5jdGlvbiBzZWFyY2godG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5yYW5nZVswXSA+IGNvbW1lbnQucmFuZ2VbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZSA9IFtjb21tZW50LnJhbmdlWzBdLCBjb21tZW50LnJhbmdlWzFdXTtcblxuICAgICAgICBpZiAodGFyZ2V0ICE9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPSB0b2tlbnNbdGFyZ2V0XS5yYW5nZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCAtPSAxO1xuICAgICAgICBpZiAodGFyZ2V0ID49IDApIHtcbiAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSA9IHRva2Vuc1t0YXJnZXRdLnJhbmdlWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0YWNoQ29tbWVudHModHJlZSwgcHJvdmlkZWRDb21tZW50cywgdG9rZW5zKSB7XG4gICAgICAgIC8vIEF0IGZpcnN0LCB3ZSBzaG91bGQgY2FsY3VsYXRlIGV4dGVuZGVkIGNvbW1lbnQgcmFuZ2VzLlxuICAgICAgICB2YXIgY29tbWVudHMgPSBbXSwgY29tbWVudCwgbGVuLCBpLCBjdXJzb3I7XG5cbiAgICAgICAgaWYgKCF0cmVlLnJhbmdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGFjaENvbW1lbnRzIG5lZWRzIHJhbmdlIGluZm9ybWF0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2tlbnMgYXJyYXkgaXMgZW1wdHksIHdlIGF0dGFjaCBjb21tZW50cyB0byB0cmVlIGFzICdsZWFkaW5nQ29tbWVudHMnXG4gICAgICAgIGlmICghdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVkQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvdmlkZWRDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZGVlcENvcHkocHJvdmlkZWRDb21tZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZSA9IFswLCB0cmVlLnJhbmdlWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJlZS5sZWFkaW5nQ29tbWVudHMgPSBjb21tZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvdmlkZWRDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY29tbWVudHMucHVzaChleHRlbmRDb21tZW50UmFuZ2UoZGVlcENvcHkocHJvdmlkZWRDb21tZW50c1tpXSksIHRva2VucykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBiYXNlZCBvbiBKb2huIEZyZWVtYW4ncyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgY3Vyc29yID0gMDtcbiAgICAgICAgdHJhdmVyc2UodHJlZSwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yIDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tjdXJzb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID4gbm9kZS5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID09PSBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5zcGxpY2UoY3Vyc29yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBvdXQgb2Ygb3duZWQgbm9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgPT09IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5CcmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbY3Vyc29yXS5leHRlbmRlZFJhbmdlWzBdID4gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3Vyc29yID0gMDtcbiAgICAgICAgdHJhdmVyc2UodHJlZSwge1xuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yIDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tjdXJzb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yYW5nZVsxXSA8IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yYW5nZVsxXSA9PT0gY29tbWVudC5leHRlbmRlZFJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUudHJhaWxpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5zcGxpY2UoY3Vyc29yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBvdXQgb2Ygb3duZWQgbm9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgPT09IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5CcmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbY3Vyc29yXS5leHRlbmRlZFJhbmdlWzBdID4gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5TeW50YXggPSBTeW50YXg7XG4gICAgZXhwb3J0cy50cmF2ZXJzZSA9IHRyYXZlcnNlO1xuICAgIGV4cG9ydHMucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgZXhwb3J0cy5hdHRhY2hDb21tZW50cyA9IGF0dGFjaENvbW1lbnRzO1xuICAgIGV4cG9ydHMuVmlzaXRvcktleXMgPSBWaXNpdG9yS2V5cztcbiAgICBleHBvcnRzLlZpc2l0b3JPcHRpb24gPSBWaXNpdG9yT3B0aW9uO1xuICAgIGV4cG9ydHMuQ29udHJvbGxlciA9IENvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5jbG9uZUVudmlyb25tZW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xvbmUoe30pOyB9O1xuXG4gICAgcmV0dXJuIGV4cG9ydHM7XG59KGV4cG9ydHMpKTtcbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/esrecurse/node_modules/estraverse/estraverse.js\n");

/***/ }),

/***/ "./node_modules/esrecurse/package.json":
/*!*********************************************!*\
  !*** ./node_modules/esrecurse/package.json ***!
  \*********************************************/
/*! exports provided: name, description, homepage, main, version, engines, maintainers, repository, dependencies, devDependencies, license, scripts, babel, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"esrecurse\\\",\\\"description\\\":\\\"ECMAScript AST recursive visitor\\\",\\\"homepage\\\":\\\"https://github.com/estools/esrecurse\\\",\\\"main\\\":\\\"esrecurse.js\\\",\\\"version\\\":\\\"4.3.0\\\",\\\"engines\\\":{\\\"node\\\":\\\">=4.0\\\"},\\\"maintainers\\\":[{\\\"name\\\":\\\"Yusuke Suzuki\\\",\\\"email\\\":\\\"utatane.tea@gmail.com\\\",\\\"web\\\":\\\"https://github.com/Constellation\\\"}],\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"https://github.com/estools/esrecurse.git\\\"},\\\"dependencies\\\":{\\\"estraverse\\\":\\\"^5.2.0\\\"},\\\"devDependencies\\\":{\\\"babel-cli\\\":\\\"^6.24.1\\\",\\\"babel-eslint\\\":\\\"^7.2.3\\\",\\\"babel-preset-es2015\\\":\\\"^6.24.1\\\",\\\"babel-register\\\":\\\"^6.24.1\\\",\\\"chai\\\":\\\"^4.0.2\\\",\\\"esprima\\\":\\\"^4.0.0\\\",\\\"gulp\\\":\\\"^3.9.0\\\",\\\"gulp-bump\\\":\\\"^2.7.0\\\",\\\"gulp-eslint\\\":\\\"^4.0.0\\\",\\\"gulp-filter\\\":\\\"^5.0.0\\\",\\\"gulp-git\\\":\\\"^2.4.1\\\",\\\"gulp-mocha\\\":\\\"^4.3.1\\\",\\\"gulp-tag-version\\\":\\\"^1.2.1\\\",\\\"jsdoc\\\":\\\"^3.3.0-alpha10\\\",\\\"minimist\\\":\\\"^1.1.0\\\"},\\\"license\\\":\\\"BSD-2-Clause\\\",\\\"scripts\\\":{\\\"test\\\":\\\"gulp travis\\\",\\\"unit-test\\\":\\\"gulp test\\\",\\\"lint\\\":\\\"gulp lint\\\"},\\\"babel\\\":{\\\"presets\\\":[\\\"es2015\\\"]}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXNyZWN1cnNlL3BhY2thZ2UuanNvbi5qcyIsInNvdXJjZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/esrecurse/package.json\n");

/***/ }),

/***/ "./node_modules/estraverse/estraverse.js":
/*!***********************************************!*\
  !*** ./node_modules/estraverse/estraverse.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*jslint vars:false, bitwise:true*/\n/*jshint indent:4*/\n/*global exports:true*/\n(function clone(exports) {\n    'use strict';\n\n    var Syntax,\n        VisitorOption,\n        VisitorKeys,\n        BREAK,\n        SKIP,\n        REMOVE;\n\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for (key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === 'object' && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n\n    function upperBound(array, func) {\n        var diff, len, i, current;\n\n        len = array.length;\n        i = 0;\n\n        while (len) {\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportExpression: 'ImportExpression',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n    };\n\n    VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportExpression: ['source'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: [ 'argument' ],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n    };\n\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n\n    Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n\n    function Controller() { }\n\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n            if (Array.isArray(path)) {\n                for (j = 0, jz = path.length; j < jz; ++j) {\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n\n        // first node is sentinel, second node is root element\n        result = [];\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n\n    // API:\n    // return type of current node\n    Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n\n        // first node is sentinel\n        result = [];\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n            result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n    };\n\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n\n        result = undefined;\n\n        previous  = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n\n        return result;\n    };\n\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function () {\n        this.notify(SKIP);\n    };\n\n    // API:\n    // break traversals\n    Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n    };\n\n    // API:\n    // remove node\n    Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n    };\n\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n        if (visitor.fallback === 'iteration') {\n            this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === 'function') {\n            this.__fallback = visitor.fallback;\n        }\n\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n    };\n\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === 'object' && typeof node.type === 'string';\n    }\n\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n    }\n\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist,\n            leavelist,\n            element,\n            node,\n            nodeType,\n            ret,\n            key,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                ret = this.__execute(visitor.leave, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n\n            if (element.node) {\n\n                ret = this.__execute(visitor.enter, element);\n\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n\n                worklist.push(sentinel);\n                leavelist.push(element);\n\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n\n                node = element.node;\n                nodeType = node.type || element.wrap;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = this.__fallback(node);\n                    } else {\n                        throw new Error('Unknown node type ' + nodeType + '.');\n                    }\n                }\n\n                current = candidates.length;\n                while ((current -= 1) >= 0) {\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n\n                    if (Array.isArray(candidate)) {\n                        current2 = candidate.length;\n                        while ((current2 -= 1) >= 0) {\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [key, current2], 'Property', null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [key, current2], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n\n    Controller.prototype.replace = function replace(root, visitor) {\n        var worklist,\n            leavelist,\n            node,\n            nodeType,\n            target,\n            element,\n            current,\n            current2,\n            candidates,\n            candidate,\n            sentinel,\n            outer,\n            key;\n\n        function removeElem(element) {\n            var i,\n                key,\n                nextElem,\n                parent;\n\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while (i--) {\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if  (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n\n        this.__initialize(root, visitor);\n\n        sentinel = {};\n\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n            element = worklist.pop();\n\n            if (element === sentinel) {\n                element = leavelist.pop();\n\n                target = this.__execute(visitor.leave, element);\n\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n\n            target = this.__execute(visitor.enter, element);\n\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = this.__fallback(node);\n                } else {\n                    throw new Error('Unknown node type ' + nodeType + '.');\n                }\n            }\n\n            current = candidates.length;\n            while ((current -= 1) >= 0) {\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n\n                if (Array.isArray(candidate)) {\n                    current2 = candidate.length;\n                    while ((current2 -= 1) >= 0) {\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n\n        return outer.root;\n    };\n\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n\n    function extendCommentRange(comment, tokens) {\n        var target;\n\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n    }\n\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n\n        if (!tree.range) {\n            throw new Error('attachComments needs range information');\n        }\n\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for (i = 0, len = providedComments.length; i < len; i += 1) {\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [0, tree.range[0]];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        cursor = 0;\n        traverse(tree, {\n            leave: function (node) {\n                var comment;\n\n                while (cursor < comments.length) {\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n\n        return tree;\n    }\n\n    exports.version = __webpack_require__(/*! ./package.json */ \"./node_modules/estraverse/package.json\").version;\n    exports.Syntax = Syntax;\n    exports.traverse = traverse;\n    exports.replace = replace;\n    exports.attachComments = attachComments;\n    exports.VisitorKeys = VisitorKeys;\n    exports.VisitorOption = VisitorOption;\n    exports.Controller = Controller;\n    exports.cloneEnvironment = function () { return clone({}); };\n\n    return exports;\n}(exports));\n/* vim: set sw=4 ts=4 et tw=80 : */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXN0cmF2ZXJzZS9lc3RyYXZlcnNlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VzdHJhdmVyc2UvZXN0cmF2ZXJzZS5qcz9iMTFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKmpzbGludCB2YXJzOmZhbHNlLCBiaXR3aXNlOnRydWUqL1xuLypqc2hpbnQgaW5kZW50OjQqL1xuLypnbG9iYWwgZXhwb3J0czp0cnVlKi9cbihmdW5jdGlvbiBjbG9uZShleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFN5bnRheCxcbiAgICAgICAgVmlzaXRvck9wdGlvbixcbiAgICAgICAgVmlzaXRvcktleXMsXG4gICAgICAgIEJSRUFLLFxuICAgICAgICBTS0lQLFxuICAgICAgICBSRU1PVkU7XG5cbiAgICBmdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICAgICAgdmFyIHJldCA9IHt9LCBrZXksIHZhbDtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZGVlcENvcHkodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBiYXNlZCBvbiBMTFZNIGxpYmMrKyB1cHBlcl9ib3VuZCAvIGxvd2VyX2JvdW5kXG4gICAgLy8gTUlUIExpY2Vuc2VcblxuICAgIGZ1bmN0aW9uIHVwcGVyQm91bmQoYXJyYXksIGZ1bmMpIHtcbiAgICAgICAgdmFyIGRpZmYsIGxlbiwgaSwgY3VycmVudDtcblxuICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgIGRpZmYgPSBsZW4gPj4+IDE7XG4gICAgICAgICAgICBjdXJyZW50ID0gaSArIGRpZmY7XG4gICAgICAgICAgICBpZiAoZnVuYyhhcnJheVtjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBkaWZmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgbGVuIC09IGRpZmYgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIFN5bnRheCA9IHtcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiAnQXNzaWdubWVudFBhdHRlcm4nLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheVBhdHRlcm46ICdBcnJheVBhdHRlcm4nLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiAnQXdhaXRFeHByZXNzaW9uJywgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLFxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiAnQnJlYWtTdGF0ZW1lbnQnLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgICAgQ2F0Y2hDbGF1c2U6ICdDYXRjaENsYXVzZScsXG4gICAgICAgIENsYXNzQm9keTogJ0NsYXNzQm9keScsXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246ICdDbGFzc0RlY2xhcmF0aW9uJyxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiAnQ2xhc3NFeHByZXNzaW9uJyxcbiAgICAgICAgQ29tcHJlaGVuc2lvbkJsb2NrOiAnQ29tcHJlaGVuc2lvbkJsb2NrJywgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogJ0NvbXByZWhlbnNpb25FeHByZXNzaW9uJywgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogJ0RpcmVjdGl2ZVN0YXRlbWVudCcsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXG4gICAgICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiAnRXhwb3J0QWxsRGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246ICdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246ICdHZW5lcmF0b3JFeHByZXNzaW9uJywgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBJbXBvcnRFeHByZXNzaW9uOiAnSW1wb3J0RXhwcmVzc2lvbicsXG4gICAgICAgIEltcG9ydERlY2xhcmF0aW9uOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxuICAgICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicsXG4gICAgICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicsXG4gICAgICAgIEltcG9ydFNwZWNpZmllcjogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICBNZXRhUHJvcGVydHk6ICdNZXRhUHJvcGVydHknLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiAnTWV0aG9kRGVmaW5pdGlvbicsXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogJ01vZHVsZVNwZWNpZmllcicsXG4gICAgICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICBPYmplY3RQYXR0ZXJuOiAnT2JqZWN0UGF0dGVybicsXG4gICAgICAgIFByb2dyYW06ICdQcm9ncmFtJyxcbiAgICAgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXG4gICAgICAgIFJlc3RFbGVtZW50OiAnUmVzdEVsZW1lbnQnLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXG4gICAgICAgIFN1cGVyOiAnU3VwZXInLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbicsXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogJ1RlbXBsYXRlRWxlbWVudCcsXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogJ1RlbXBsYXRlTGl0ZXJhbCcsXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXG4gICAgICAgIFlpZWxkRXhwcmVzc2lvbjogJ1lpZWxkRXhwcmVzc2lvbidcbiAgICB9O1xuXG4gICAgVmlzaXRvcktleXMgPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQXNzaWdubWVudFBhdHRlcm46IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246IFsnZWxlbWVudHMnXSxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBbJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogWydhcmd1bWVudCddLCAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6IFsnYm9keSddLFxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6IFsnbGFiZWwnXSxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246IFsnY2FsbGVlJywgJ2FyZ3VtZW50cyddLFxuICAgICAgICBDYXRjaENsYXVzZTogWydwYXJhbScsICdib2R5J10sXG4gICAgICAgIENsYXNzQm9keTogWydib2R5J10sXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246IFsnaWQnLCAnc3VwZXJDbGFzcycsICdib2R5J10sXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogWydpZCcsICdzdXBlckNsYXNzJywgJ2JvZHknXSxcbiAgICAgICAgQ29tcHJlaGVuc2lvbkJsb2NrOiBbJ2xlZnQnLCAncmlnaHQnXSwgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogWydibG9ja3MnLCAnZmlsdGVyJywgJ2JvZHknXSwgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IFsndGVzdCcsICdjb25zZXF1ZW50JywgJ2FsdGVybmF0ZSddLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogW10sXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogW10sXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6IFsnYm9keScsICd0ZXN0J10sXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiBbXSxcbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246IFsnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbiddLFxuICAgICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9uJywgJ3NwZWNpZmllcnMnLCAnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogWydleHBvcnRlZCcsICdsb2NhbCddLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBbJ2V4cHJlc3Npb24nXSxcbiAgICAgICAgRm9yU3RhdGVtZW50OiBbJ2luaXQnLCAndGVzdCcsICd1cGRhdGUnLCAnYm9keSddLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvZHknXSxcbiAgICAgICAgRm9yT2ZTdGF0ZW1lbnQ6IFsnbGVmdCcsICdyaWdodCcsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IFsnaWQnLCAncGFyYW1zJywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiBbJ2lkJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246IFsnYmxvY2tzJywgJ2ZpbHRlcicsICdib2R5J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogW10sXG4gICAgICAgIElmU3RhdGVtZW50OiBbJ3Rlc3QnLCAnY29uc2VxdWVudCcsICdhbHRlcm5hdGUnXSxcbiAgICAgICAgSW1wb3J0RXhwcmVzc2lvbjogWydzb3VyY2UnXSxcbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IFsnc3BlY2lmaWVycycsICdzb3VyY2UnXSxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogWydsb2NhbCddLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFsnbG9jYWwnXSxcbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBbJ2ltcG9ydGVkJywgJ2xvY2FsJ10sXG4gICAgICAgIExpdGVyYWw6IFtdLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBbJ2xhYmVsJywgJ2JvZHknXSxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBbJ29iamVjdCcsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZXRhUHJvcGVydHk6IFsnbWV0YScsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6IFtdLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiBbJ2NhbGxlZScsICdhcmd1bWVudHMnXSxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIE9iamVjdFBhdHRlcm46IFsncHJvcGVydGllcyddLFxuICAgICAgICBQcm9ncmFtOiBbJ2JvZHknXSxcbiAgICAgICAgUHJvcGVydHk6IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgIFJlc3RFbGVtZW50OiBbICdhcmd1bWVudCcgXSxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogWydleHByZXNzaW9ucyddLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFN1cGVyOiBbXSxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiBbJ2Rpc2NyaW1pbmFudCcsICdjYXNlcyddLFxuICAgICAgICBTd2l0Y2hDYXNlOiBbJ3Rlc3QnLCAnY29uc2VxdWVudCddLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IFsndGFnJywgJ3F1YXNpJ10sXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogW10sXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogWydxdWFzaXMnLCAnZXhwcmVzc2lvbnMnXSxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246IFtdLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogWydhcmd1bWVudCddLFxuICAgICAgICBUcnlTdGF0ZW1lbnQ6IFsnYmxvY2snLCAnaGFuZGxlcicsICdmaW5hbGl6ZXInXSxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbnMnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiBbJ2lkJywgJ2luaXQnXSxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6IFsndGVzdCcsICdib2R5J10sXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6IFsnb2JqZWN0JywgJ2JvZHknXSxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J11cbiAgICB9O1xuXG4gICAgLy8gdW5pcXVlIGlkXG4gICAgQlJFQUsgPSB7fTtcbiAgICBTS0lQID0ge307XG4gICAgUkVNT1ZFID0ge307XG5cbiAgICBWaXNpdG9yT3B0aW9uID0ge1xuICAgICAgICBCcmVhazogQlJFQUssXG4gICAgICAgIFNraXA6IFNLSVAsXG4gICAgICAgIFJlbW92ZTogUkVNT1ZFXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZShwYXJlbnQsIGtleSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShub2RlKSB7XG4gICAgICAgIHRoaXMucGFyZW50W3RoaXMua2V5XSA9IG5vZGU7XG4gICAgfTtcblxuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnNwbGljZSh0aGlzLmtleSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBFbGVtZW50KG5vZGUsIHBhdGgsIHdyYXAsIHJlZikge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLndyYXAgPSB3cmFwO1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb250cm9sbGVyKCkgeyB9XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIHByb3BlcnR5IHBhdGggYXJyYXkgZnJvbSByb290IHRvIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiBwYXRoKCkge1xuICAgICAgICB2YXIgaSwgaXosIGosIGp6LCByZXN1bHQsIGVsZW1lbnQ7XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkVG9QYXRoKHJlc3VsdCwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqeiA9IHBhdGgubGVuZ3RoOyBqIDwgano7ICsraikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm9vdCBub2RlXG4gICAgICAgIGlmICghdGhpcy5fX2N1cnJlbnQucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCBub2RlIGlzIHNlbnRpbmVsLCBzZWNvbmQgbm9kZSBpcyByb290IGVsZW1lbnRcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDIsIGl6ID0gdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5fX2xlYXZlbGlzdFtpXTtcbiAgICAgICAgICAgIGFkZFRvUGF0aChyZXN1bHQsIGVsZW1lbnQucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkVG9QYXRoKHJlc3VsdCwgdGhpcy5fX2N1cnJlbnQucGF0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gdHlwZSBvZiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICByZXR1cm4gbm9kZS50eXBlIHx8IHRoaXMuX19jdXJyZW50LndyYXA7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gYXJyYXkgb2YgcGFyZW50IGVsZW1lbnRzXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucGFyZW50cyA9IGZ1bmN0aW9uIHBhcmVudHMoKSB7XG4gICAgICAgIHZhciBpLCBpeiwgcmVzdWx0O1xuXG4gICAgICAgIC8vIGZpcnN0IG5vZGUgaXMgc2VudGluZWxcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDEsIGl6ID0gdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9fbGVhdmVsaXN0W2ldLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jdXJyZW50Lm5vZGU7XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLl9fZXhlY3V0ZSA9IGZ1bmN0aW9uIF9fZXhlY3V0ZShjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgICB2YXIgcHJldmlvdXMsIHJlc3VsdDtcblxuICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcHJldmlvdXMgID0gdGhpcy5fX2N1cnJlbnQ7XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjay5jYWxsKHRoaXMsIGVsZW1lbnQubm9kZSwgdGhpcy5fX2xlYXZlbGlzdFt0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aCAtIDFdLm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gcHJldmlvdXM7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIG5vdGlmeSBjb250cm9sIHNraXAgLyBicmVha1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeShmbGFnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IGZsYWc7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBza2lwIGNoaWxkIG5vZGVzIG9mIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KFNLSVApO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gYnJlYWsgdHJhdmVyc2Fsc1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlWydicmVhayddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShCUkVBSyk7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZW1vdmUgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoUkVNT1ZFKTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuX19pbml0aWFsaXplID0gZnVuY3Rpb24ocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB0aGlzLnZpc2l0b3IgPSB2aXNpdG9yO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLl9fd29ya2xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fX2xlYXZlbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9fY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX19mYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGlmICh2aXNpdG9yLmZhbGxiYWNrID09PSAnaXRlcmF0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fX2ZhbGxiYWNrID0gT2JqZWN0LmtleXM7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZpc2l0b3IuZmFsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX19mYWxsYmFjayA9IHZpc2l0b3IuZmFsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fa2V5cyA9IFZpc2l0b3JLZXlzO1xuICAgICAgICBpZiAodmlzaXRvci5rZXlzKSB7XG4gICAgICAgICAgICB0aGlzLl9fa2V5cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh0aGlzLl9fa2V5cyksIHZpc2l0b3Iua2V5cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5vZGUudHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQcm9wZXJ0eShub2RlVHlwZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAobm9kZVR5cGUgPT09IFN5bnRheC5PYmplY3RFeHByZXNzaW9uIHx8IG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0UGF0dGVybikgJiYgJ3Byb3BlcnRpZXMnID09PSBrZXk7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWw7XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG51bGwpKTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2gobmV3IEVsZW1lbnQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgcmV0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG5cbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHJldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCByZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgICAgICBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCBlbGVtZW50LndyYXA7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19rZXlzW25vZGVUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19mYWxsYmFjayhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGUgJyArIG5vZGVUeXBlICsgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGVzW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBub2RlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQyID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudDIgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlW2N1cnJlbnQyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHkobm9kZVR5cGUsIGNhbmRpZGF0ZXNbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sICdQcm9wZXJ0eScsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKGNhbmRpZGF0ZVtjdXJyZW50Ml0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KGNhbmRpZGF0ZSwga2V5LCBudWxsLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgd29ya2xpc3QsXG4gICAgICAgICAgICBsZWF2ZWxpc3QsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGN1cnJlbnQyLFxuICAgICAgICAgICAgY2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICAgIHNlbnRpbmVsLFxuICAgICAgICAgICAgb3V0ZXIsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWxlbShlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmV4dEVsZW0sXG4gICAgICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5yZWYucmVtb3ZlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSByZWZlcmVuY2UgaXMgYW4gZWxlbWVudCBvZiBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICBrZXkgPSBlbGVtZW50LnJlZi5rZXk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudC5yZWYucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVtb3ZlZCBmcm9tIGFycmF5LCB0aGVuIGRlY3JlYXNlIGZvbGxvd2luZyBpdGVtcycga2V5cy5cbiAgICAgICAgICAgICAgICBpID0gd29ya2xpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsZW0gPSB3b3JrbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtLnJlZiAmJiBuZXh0RWxlbS5yZWYucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICAobmV4dEVsZW0ucmVmLmtleSA8IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLS1uZXh0RWxlbS5yZWYua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICBvdXRlciA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3RcbiAgICAgICAgfTtcbiAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG5ldyBSZWZlcmVuY2Uob3V0ZXIsICdyb290JykpO1xuICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBsZWF2ZWxpc3QucHVzaChlbGVtZW50KTtcblxuICAgICAgICB3aGlsZSAod29ya2xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gd29ya2xpc3QucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBzZW50aW5lbCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBsZWF2ZWxpc3QucG9wKCk7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmxlYXZlLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIHJlcGxhY2VkIHdpdGggbnVsbCxcbiAgICAgICAgICAgICAgICAvLyBzbyBkaXN0aW5ndWlzaCBiZXR3ZWVuIHVuZGVmaW5lZCBhbmQgbnVsbCBpbiB0aGlzIHBsYWNlXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gQlJFQUsgJiYgdGFyZ2V0ICE9PSBTS0lQICYmIHRhcmdldCAhPT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZWYucmVwbGFjZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFJFTU9WRSB8fCB0YXJnZXQgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFbGVtKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHRhcmdldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyLnJvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgcmVwbGFjZWQgd2l0aCBudWxsLFxuICAgICAgICAgICAgLy8gc28gZGlzdGluZ3Vpc2ggYmV0d2VlbiB1bmRlZmluZWQgYW5kIG51bGwgaW4gdGhpcyBwbGFjZVxuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gQlJFQUsgJiYgdGFyZ2V0ICE9PSBTS0lQICYmIHRhcmdldCAhPT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZVxuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVmLnJlcGxhY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5vZGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFJFTU9WRSB8fCB0YXJnZXQgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW0oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ub2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgdGFyZ2V0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub2RlIG1heSBiZSBudWxsXG4gICAgICAgICAgICBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFNLSVAgfHwgdGFyZ2V0ID09PSBTS0lQKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGVUeXBlID0gbm9kZS50eXBlIHx8IGVsZW1lbnQud3JhcDtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9fa2V5c1tub2RlVHlwZV07XG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9fZmFsbGJhY2sobm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZSAnICsgbm9kZVR5cGUgKyAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudCA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50IC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGVzW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQyID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50MiAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5KG5vZGVUeXBlLCBjYW5kaWRhdGVzW2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sICdQcm9wZXJ0eScsIG5ldyBSZWZlcmVuY2UoY2FuZGlkYXRlLCBjdXJyZW50MikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlW2N1cnJlbnQyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCBudWxsLCBuZXcgUmVmZXJlbmNlKGNhbmRpZGF0ZSwgY3VycmVudDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KGNhbmRpZGF0ZSwga2V5LCBudWxsLCBuZXcgUmVmZXJlbmNlKG5vZGUsIGtleSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJhdmVyc2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnRyYXZlcnNlKHJvb3QsIHZpc2l0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnJlcGxhY2Uocm9vdCwgdmlzaXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kQ29tbWVudFJhbmdlKGNvbW1lbnQsIHRva2Vucykge1xuICAgICAgICB2YXIgdGFyZ2V0O1xuXG4gICAgICAgIHRhcmdldCA9IHVwcGVyQm91bmQodG9rZW5zLCBmdW5jdGlvbiBzZWFyY2godG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5yYW5nZVswXSA+IGNvbW1lbnQucmFuZ2VbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZSA9IFtjb21tZW50LnJhbmdlWzBdLCBjb21tZW50LnJhbmdlWzFdXTtcblxuICAgICAgICBpZiAodGFyZ2V0ICE9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPSB0b2tlbnNbdGFyZ2V0XS5yYW5nZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCAtPSAxO1xuICAgICAgICBpZiAodGFyZ2V0ID49IDApIHtcbiAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSA9IHRva2Vuc1t0YXJnZXRdLnJhbmdlWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0YWNoQ29tbWVudHModHJlZSwgcHJvdmlkZWRDb21tZW50cywgdG9rZW5zKSB7XG4gICAgICAgIC8vIEF0IGZpcnN0LCB3ZSBzaG91bGQgY2FsY3VsYXRlIGV4dGVuZGVkIGNvbW1lbnQgcmFuZ2VzLlxuICAgICAgICB2YXIgY29tbWVudHMgPSBbXSwgY29tbWVudCwgbGVuLCBpLCBjdXJzb3I7XG5cbiAgICAgICAgaWYgKCF0cmVlLnJhbmdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGFjaENvbW1lbnRzIG5lZWRzIHJhbmdlIGluZm9ybWF0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2tlbnMgYXJyYXkgaXMgZW1wdHksIHdlIGF0dGFjaCBjb21tZW50cyB0byB0cmVlIGFzICdsZWFkaW5nQ29tbWVudHMnXG4gICAgICAgIGlmICghdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVkQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvdmlkZWRDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZGVlcENvcHkocHJvdmlkZWRDb21tZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZSA9IFswLCB0cmVlLnJhbmdlWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJlZS5sZWFkaW5nQ29tbWVudHMgPSBjb21tZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvdmlkZWRDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY29tbWVudHMucHVzaChleHRlbmRDb21tZW50UmFuZ2UoZGVlcENvcHkocHJvdmlkZWRDb21tZW50c1tpXSksIHRva2VucykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBiYXNlZCBvbiBKb2huIEZyZWVtYW4ncyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgY3Vyc29yID0gMDtcbiAgICAgICAgdHJhdmVyc2UodHJlZSwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yIDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tjdXJzb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID4gbm9kZS5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID09PSBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5zcGxpY2UoY3Vyc29yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBvdXQgb2Ygb3duZWQgbm9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgPT09IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5CcmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbY3Vyc29yXS5leHRlbmRlZFJhbmdlWzBdID4gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3Vyc29yID0gMDtcbiAgICAgICAgdHJhdmVyc2UodHJlZSwge1xuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yIDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tjdXJzb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yYW5nZVsxXSA8IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yYW5nZVsxXSA9PT0gY29tbWVudC5leHRlbmRlZFJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUudHJhaWxpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5zcGxpY2UoY3Vyc29yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBvdXQgb2Ygb3duZWQgbm9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgPT09IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5CcmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbY3Vyc29yXS5leHRlbmRlZFJhbmdlWzBdID4gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICAgIGV4cG9ydHMuU3ludGF4ID0gU3ludGF4O1xuICAgIGV4cG9ydHMudHJhdmVyc2UgPSB0cmF2ZXJzZTtcbiAgICBleHBvcnRzLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGV4cG9ydHMuYXR0YWNoQ29tbWVudHMgPSBhdHRhY2hDb21tZW50cztcbiAgICBleHBvcnRzLlZpc2l0b3JLZXlzID0gVmlzaXRvcktleXM7XG4gICAgZXhwb3J0cy5WaXNpdG9yT3B0aW9uID0gVmlzaXRvck9wdGlvbjtcbiAgICBleHBvcnRzLkNvbnRyb2xsZXIgPSBDb250cm9sbGVyO1xuICAgIGV4cG9ydHMuY2xvbmVFbnZpcm9ubWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsb25lKHt9KTsgfTtcblxuICAgIHJldHVybiBleHBvcnRzO1xufShleHBvcnRzKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/estraverse/estraverse.js\n");

/***/ }),

/***/ "./node_modules/estraverse/package.json":
/*!**********************************************!*\
  !*** ./node_modules/estraverse/package.json ***!
  \**********************************************/
/*! exports provided: name, description, homepage, main, version, engines, maintainers, repository, devDependencies, license, scripts, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"estraverse\\\",\\\"description\\\":\\\"ECMAScript JS AST traversal functions\\\",\\\"homepage\\\":\\\"https://github.com/estools/estraverse\\\",\\\"main\\\":\\\"estraverse.js\\\",\\\"version\\\":\\\"4.3.0\\\",\\\"engines\\\":{\\\"node\\\":\\\">=4.0\\\"},\\\"maintainers\\\":[{\\\"name\\\":\\\"Yusuke Suzuki\\\",\\\"email\\\":\\\"utatane.tea@gmail.com\\\",\\\"web\\\":\\\"http://github.com/Constellation\\\"}],\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"http://github.com/estools/estraverse.git\\\"},\\\"devDependencies\\\":{\\\"babel-preset-env\\\":\\\"^1.6.1\\\",\\\"babel-register\\\":\\\"^6.3.13\\\",\\\"chai\\\":\\\"^2.1.1\\\",\\\"espree\\\":\\\"^1.11.0\\\",\\\"gulp\\\":\\\"^3.8.10\\\",\\\"gulp-bump\\\":\\\"^0.2.2\\\",\\\"gulp-filter\\\":\\\"^2.0.0\\\",\\\"gulp-git\\\":\\\"^1.0.1\\\",\\\"gulp-tag-version\\\":\\\"^1.3.0\\\",\\\"jshint\\\":\\\"^2.5.6\\\",\\\"mocha\\\":\\\"^2.1.0\\\"},\\\"license\\\":\\\"BSD-2-Clause\\\",\\\"scripts\\\":{\\\"test\\\":\\\"npm run-script lint && npm run-script unit-test\\\",\\\"lint\\\":\\\"jshint estraverse.js\\\",\\\"unit-test\\\":\\\"mocha --compilers js:babel-register\\\"}}\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXN0cmF2ZXJzZS9wYWNrYWdlLmpzb24uanMiLCJzb3VyY2VzIjpbXSwibWFwcGluZ3MiOiIiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/estraverse/package.json\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzPzI4YTAiXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/util/node_modules/inherits/inherits_browser.js\n");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzP2Q2MGEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/util/support/isBufferBrowser.js\n");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/util/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcz8zMDIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIHx8XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzY3JpcHRvcnNba2V5c1tpXV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfTtcblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IsIG51bGwsIHJldCkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZCwgcmVqLCBjYikgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/util/util.js\n");

/***/ })

}]);